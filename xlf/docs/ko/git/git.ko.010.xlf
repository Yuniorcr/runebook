<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="35e3581a01e860cba15921ad7e00a74542d34f54" translate="yes" xml:space="preserve">
          <source>The merge backend works with a full copy of each relevant file, insulating it from these types of problems.</source>
          <target state="translated">The merge backend works with a full copy of each relevant file, insulating it from these types of problems.</target>
        </trans-unit>
        <trans-unit id="d2c94b31b25e0c09828d4438bdd636247e16e902" translate="yes" xml:space="preserve">
          <source>The merge backend works with the full commits on both sides of history and thus has no such limitations.</source>
          <target state="translated">The merge backend works with the full commits on both sides of history and thus has no such limitations.</target>
        </trans-unit>
        <trans-unit id="657f593653b8985b76ea363799992d9ccd8552d1" translate="yes" xml:space="preserve">
          <source>The merge driver can learn the pathname in which the merged result will be stored via placeholder &lt;code&gt;%P&lt;/code&gt;.</source>
          <target state="translated">병합 드라이버는 자리 표시 자 &lt;code&gt;%P&lt;/code&gt; 를 통해 병합 된 결과가 저장 될 경로 이름을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a4ee88dc1fd419e5903b5a6b97383e8c2a1fab9" translate="yes" xml:space="preserve">
          <source>The merge driver is expected to leave the result of the merge in the file named with &lt;code&gt;%A&lt;/code&gt; by overwriting it, and exit with zero status if it managed to merge them cleanly, or non-zero if there were conflicts.</source>
          <target state="translated">병합 드라이버는 병합 결과를 &lt;code&gt;%A&lt;/code&gt; 로 이름이 지정된 파일 에 겹쳐 써서 그대로두고, 완전히 병합 할 경우 상태가 0으로, 충돌이있는 경우 0이 아닌 상태로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="d39522f0982abae4a359335f63ed088d0f4a4c4e" translate="yes" xml:space="preserve">
          <source>The merge mechanism (&lt;code&gt;git merge&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt; commands) allows the backend &lt;code&gt;merge strategies&lt;/code&gt; to be chosen with &lt;code&gt;-s&lt;/code&gt; option. Some strategies can also take their own options, which can be passed by giving &lt;code&gt;-X&amp;lt;option&amp;gt;&lt;/code&gt; arguments to &lt;code&gt;git merge&lt;/code&gt; and/or &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">병합 메커니즘 ( &lt;code&gt;git merge&lt;/code&gt; 및 &lt;code&gt;git pull&lt;/code&gt; 명령)을 사용하면 백엔드 &lt;code&gt;merge strategies&lt;/code&gt; 을 &lt;code&gt;-s&lt;/code&gt; 옵션 으로 선택할 수 있습니다 . 일부 전략은 자체 옵션을 사용할 수도 있습니다.이 &lt;code&gt;-X&amp;lt;option&amp;gt;&lt;/code&gt; 은 &lt;code&gt;git merge&lt;/code&gt; 및 / 또는 &lt;code&gt;git pull&lt;/code&gt; 에-X &amp;lt;option&amp;gt; 인수를 제공하여 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa594438c3581495b74bb79c047cb66382bd8b0d" translate="yes" xml:space="preserve">
          <source>The merge workflow works by copying branches between upstream and downstream. Upstream can merge contributions into the official history; downstream base their work on the official history.</source>
          <target state="translated">병합 워크 플로는 업스트림과 다운 스트림간에 분기를 복사하여 작동합니다. 업스트림은 기여를 공식 역사에 통합 할 수 있습니다. 공식적인 역사를 바탕으로 작업을 진행합니다.</target>
        </trans-unit>
        <trans-unit id="1df107645dfce75dc8613a8a0f6007cf8381d780" translate="yes" xml:space="preserve">
          <source>The merge-base command finds a common ancestor of the given commits, and always returns one or the other in the case where one is a descendant of the other; so the above output shows that e05db0fd actually is an ancestor of v1.5.0-rc1.</source>
          <target state="translated">merge-base 명령은 주어진 커밋의 공통 조상을 찾고 하나가 다른 하나의 자손 인 경우 항상 하나 또는 다른 하나를 반환합니다. 위의 출력은 e05db0fd가 실제로 v1.5.0-rc1의 조상임을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="91d3bf0b3d356085e2e60914fc9a13ad2e2b8ebf" translate="yes" xml:space="preserve">
          <source>The message in a commit or a tag object is &lt;code&gt;contents&lt;/code&gt;, from which &lt;code&gt;contents:&amp;lt;part&amp;gt;&lt;/code&gt; can be used to extract various parts out of:</source>
          <target state="translated">The message in a commit or a tag object is &lt;code&gt;contents&lt;/code&gt; , from which &lt;code&gt;contents:&amp;lt;part&amp;gt;&lt;/code&gt; can be used to extract various parts out of:</target>
        </trans-unit>
        <trans-unit id="19f5c4372c6fc154ead993a9f4b5a82da922524d" translate="yes" xml:space="preserve">
          <source>The message taken from file with &lt;code&gt;-F&lt;/code&gt; and command line with &lt;code&gt;-m&lt;/code&gt; are usually used as the tag message unmodified. This option lets you further edit the message taken from these sources.</source>
          <target state="translated">&lt;code&gt;-F&lt;/code&gt; 를 사용하여 파일에서 가져온 메시지 와 &lt;code&gt;-m&lt;/code&gt; 을 사용하는 명령 행 은 일반적으로 수정되지 않은 태그 메시지로 사용됩니다. 이 옵션을 사용하면 이러한 소스에서 가져온 메시지를 추가로 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e2b72f6afed427d21f4e345d320e470730d82f9" translate="yes" xml:space="preserve">
          <source>The message taken from file with &lt;code&gt;-F&lt;/code&gt;, command line with &lt;code&gt;-m&lt;/code&gt;, and from commit object with &lt;code&gt;-C&lt;/code&gt; are usually used as the commit log message unmodified. This option lets you further edit the message taken from these sources.</source>
          <target state="translated">&lt;code&gt;-F&lt;/code&gt; 로 파일에서 , &lt;code&gt;-m&lt;/code&gt; 으로 명령 행 및 &lt;code&gt;-C&lt;/code&gt; 로 커미트 오브젝트에서 가져온 메시지는 일반적으로 수정되지 않은 커미트 로그 메시지로 사용됩니다. 이 옵션을 사용하면 이러한 소스에서 가져온 메시지를 추가로 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae16f65784862fd6e529b736650355763df13327" translate="yes" xml:space="preserve">
          <source>The method by which a submodule is updated by &lt;code&gt;git submodule update&lt;/code&gt;, which is the only affected command, others such as &lt;code&gt;git checkout --recurse-submodules&lt;/code&gt; are unaffected. It exists for historical reasons, when &lt;code&gt;git submodule&lt;/code&gt; was the only command to interact with submodules; settings like &lt;code&gt;submodule.active&lt;/code&gt; and &lt;code&gt;pull.rebase&lt;/code&gt; are more specific. It is populated by &lt;code&gt;git submodule init&lt;/code&gt; from the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file. See description of &lt;code&gt;update&lt;/code&gt; command in &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;.</source>
          <target state="translated">영향을받는 유일한 명령 인 &lt;code&gt;git submodule update&lt;/code&gt; 에 의해 서브 모듈이 업데이트되는 방법 은 &lt;code&gt;git checkout --recurse-submodules&lt;/code&gt; 과 같은 다른 영향을받지 않습니다. &lt;code&gt;git submodule&lt;/code&gt; 이 하위 모듈과 상호 작용하는 유일한 명령이었던 역사적인 이유가 있습니다 . &lt;code&gt;submodule.active&lt;/code&gt; 및 &lt;code&gt;pull.rebase&lt;/code&gt; 와 같은 설정 이 더 구체적입니다. &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 파일 에서 &lt;code&gt;git submodule init&lt;/code&gt; 로 채워집니다 . &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; 의 &lt;code&gt;update&lt;/code&gt; 명령에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04ef06b50b9899f38b1e5f5c81eb00396b6d2328" translate="yes" xml:space="preserve">
          <source>The mode parameter is optional (defaults to &lt;code&gt;all&lt;/code&gt;), and is used to specify the handling of untracked files; when -u is not used, the default is &lt;code&gt;normal&lt;/code&gt;, i.e. show untracked files and directories.</source>
          <target state="translated">mode 매개 변수는 선택 사항이며 (기본값은 &lt;code&gt;all&lt;/code&gt; ) 추적되지 않은 파일 처리를 지정하는 데 사용됩니다. -u를 사용하지 않으면 기본값은 &lt;code&gt;normal&lt;/code&gt; 입니다 (예 : 추적되지 않은 파일 및 디렉토리 표시).</target>
        </trans-unit>
        <trans-unit id="daee71f2e966cf5f390a0401b9f0381f1242178c" translate="yes" xml:space="preserve">
          <source>The mode parameter is used to specify the handling of ignored files. It is optional: it defaults to &lt;code&gt;traditional&lt;/code&gt;.</source>
          <target state="translated">mode 매개 변수는 무시 된 파일 처리를 지정하는 데 사용됩니다. 선택 사항입니다. 기본값은 &lt;code&gt;traditional&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="789771a80f50eaf70002a855307c4e88ea3d25bd" translate="yes" xml:space="preserve">
          <source>The mode parameter is used to specify the handling of untracked files. It is optional: it defaults to &lt;code&gt;all&lt;/code&gt;, and if specified, it must be stuck to the option (e.g. &lt;code&gt;-uno&lt;/code&gt;, but not &lt;code&gt;-u no&lt;/code&gt;).</source>
          <target state="translated">mode 매개 변수는 추적되지 않은 파일 처리를 지정하는 데 사용됩니다. 에 기본값 : 그것은 선택 사항입니다 &lt;code&gt;all&lt;/code&gt; , 지정된 경우,이 옵션에 붙어 있어야합니다 (예 : &lt;code&gt;-uno&lt;/code&gt; ,하지만 &lt;code&gt;-u no&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d56062b3fd6eee94e49e5896b7d127ee25df01a1" translate="yes" xml:space="preserve">
          <source>The modifications stashed away by this command can be listed with &lt;code&gt;git stash list&lt;/code&gt;, inspected with &lt;code&gt;git stash show&lt;/code&gt;, and restored (potentially on top of a different commit) with &lt;code&gt;git stash apply&lt;/code&gt;. Calling &lt;code&gt;git stash&lt;/code&gt; without any arguments is equivalent to &lt;code&gt;git stash push&lt;/code&gt;. A stash is by default listed as &quot;WIP on &lt;code&gt;branchname&lt;/code&gt; &amp;hellip;​&quot;, but you can give a more descriptive message on the command line when you create one.</source>
          <target state="translated">이 명령으로 &lt;code&gt;git stash list&lt;/code&gt; 된 수정 사항은 git stash list 로 나열하고 git &lt;code&gt;git stash show&lt;/code&gt; 검사 하고 &lt;code&gt;git stash apply&lt;/code&gt; 로 잠재적으로 다른 커밋 위에 복원 할 수 있습니다 . 인수없이 &lt;code&gt;git stash&lt;/code&gt; 를 호출 하는 것은 &lt;code&gt;git stash push&lt;/code&gt; 와 같습니다 . 감춰는 &quot;에 WIP로 나열 디폴트로 &lt;code&gt;branchname&lt;/code&gt; ...&quot;하지만, 당신이 하나를 만들 때 명령 행에 더 자세한 설명 메시지를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e06fa83026ee56ec3b62a659fa5a44c6e4e4728d" translate="yes" xml:space="preserve">
          <source>The module path (only needed if httpd is Apache). (Default: /usr/lib/apache2/modules)</source>
          <target state="translated">모듈 경로 (httpd가 Apache 인 경우에만 필요) (기본값 : / usr / lib / apache2 / modules)</target>
        </trans-unit>
        <trans-unit id="08ed4170506fa174e84f549a0e3f26086c486529" translate="yes" xml:space="preserve">
          <source>The more complex forms are:</source>
          <target state="translated">더 복잡한 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d735293dee944ca58932a7261110828d307c793" translate="yes" xml:space="preserve">
          <source>The most common cause of dangling objects is that you&amp;rsquo;ve rebased a branch, or you have pulled from somebody else who rebased a branch&amp;mdash;​see &lt;a href=&quot;#cleaning-up-history&quot;&gt;Rewriting history and maintaining patch series&lt;/a&gt;. In that case, the old head of the original branch still exists, as does everything it pointed to. The branch pointer itself just doesn&amp;rsquo;t, since you replaced it with another one.</source>
          <target state="translated">매달린 오브젝트의 가장 일반적인 원인은 브랜치를 리베이스했거나 브랜치를 리베이스 한 다른 누군가로부터 가져온 것입니다 . &lt;a href=&quot;#cleaning-up-history&quot;&gt;히스토리 다시 작성 및 패치 시리즈 유지 보수를&lt;/a&gt; 참조하십시오 . 이 경우 원래 지점의 오래된 헤드는 여전히 똑같이 존재합니다. 분기 포인터 자체는 다른 포인터로 대체 되었기 때문에 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8bc143dd44c89f63596943262174b04211332773" translate="yes" xml:space="preserve">
          <source>The multi-pack-index (MIDX for short) stores a list of objects and their offsets into multiple packfiles. It contains:</source>
          <target state="translated">다중 팩 인덱스 (MIDX)는 객체 목록과 해당 오프셋을 여러 팩 파일에 저장합니다. 그것은 포함합니다 :</target>
        </trans-unit>
        <trans-unit id="4ca15f678a55a1443f2d701a54958e45ad8a0235" translate="yes" xml:space="preserve">
          <source>The multi-pack-index allows many packfiles, especially in a context where repacking is expensive (such as a very large repo), or unexpected maintenance time is unacceptable (such as a high-demand build machine). However, the multi-pack-index needs to be rewritten in full every time. We can extend the format to be incremental, so writes are fast. By storing a small &quot;tip&quot; multi-pack-index that points to large &quot;base&quot; MIDX files, we can keep writes fast while still reducing the number of binary searches required for object lookups.</source>
          <target state="translated">다중 팩 색인은 특히 재 포장이 비싸거나 (예 : 매우 큰 리포지토리) 예상치 못한 유지 보수 시간이 허용되지 않는 (예 : 수요가 많은 빌드 머신) 상황에서 많은 팩 파일을 허용합니다. 그러나 다중 팩 인덱스는 매번 다시 작성해야합니다. 형식을 증분으로 늘릴 수 있으므로 쓰기 속도가 빠릅니다. 큰 &quot;기본&quot;MIDX 파일을 가리키는 작은 &quot;팁&quot;다중 팩 인덱스를 저장하여 객체 조회에 필요한 이진 검색 수를 줄이면서 빠르게 기록을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d98c840529f1ab7c2fa3df48a823219f4ff9a17e" translate="yes" xml:space="preserve">
          <source>The multi-pack-index files refer to multiple pack-files and loose objects.</source>
          <target state="translated">다중 팩 인덱스 파일은 다중 팩 파일 및 느슨한 객체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1e0c8af9211e361d1a35789c37df84247f7ae9ac" translate="yes" xml:space="preserve">
          <source>The name and the e-mail address of the owner of the key that signed the push certificate.</source>
          <target state="translated">푸시 인증서에 서명 한 키 소유자의 이름 및 이메일 주소입니다.</target>
        </trans-unit>
        <trans-unit id="2551d22d5e60fb51293e5ef827d3f2d640624d55" translate="yes" xml:space="preserve">
          <source>The name of a commit at which to start the new branch; see &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details. Defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">새 브랜치를 시작할 커밋의 이름. 자세한 내용은 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; 을 참조하십시오. 기본값은 &lt;code&gt;HEAD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0efd5464958e1be85e38672256be6f6e17bc462a" translate="yes" xml:space="preserve">
          <source>The name of a local ref which can be considered &amp;ldquo;upstream&amp;rdquo; from the displayed ref. Respects &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt; and &lt;code&gt;:rstrip&lt;/code&gt; in the same way as &lt;code&gt;refname&lt;/code&gt; above. Additionally respects &lt;code&gt;:track&lt;/code&gt; to show &quot;[ahead N, behind M]&quot; and &lt;code&gt;:trackshort&lt;/code&gt; to show the terse version: &quot;&amp;gt;&quot; (ahead), &quot;&amp;lt;&quot; (behind), &quot;&amp;lt;&amp;gt;&quot; (ahead and behind), or &quot;=&quot; (in sync). &lt;code&gt;:track&lt;/code&gt; also prints &quot;[gone]&quot; whenever unknown upstream ref is encountered. Append &lt;code&gt;:track,nobracket&lt;/code&gt; to show tracking information without brackets (i.e &quot;ahead N, behind M&quot;).</source>
          <target state="translated">표시된 참조에서 &quot;업스트림&quot;으로 간주 될 수있는 로컬 참조의 이름입니다. 위의 &lt;code&gt;refname&lt;/code&gt; 과 동일한 방식으로 &lt;code&gt;:short&lt;/code&gt; , &lt;code&gt;:lstrip&lt;/code&gt; 및 &lt;code&gt;:rstrip&lt;/code&gt; 을 존중 합니다. 또한 &lt;code&gt;:track&lt;/code&gt; 은 &quot;[ahead N, behind M]&quot; 을 표시 하고 &lt;code&gt;:trackshort&lt;/code&gt; 는 &quot;&amp;gt;&quot;(ahead), &quot;&amp;lt;&quot;(behind), &quot;&amp;lt;&amp;gt;&quot;(ahead and behind) 또는 &quot; = &quot;(동기화). &lt;code&gt;:track&lt;/code&gt; 은 알 수없는 업스트림 참조가 발생할 때마다 &quot;[gone]&quot;을 인쇄합니다. Append &lt;code&gt;:track,nobracket&lt;/code&gt; 은 대괄호없이 추적 정보를 표시합니다 (예 : &quot;M 뒤에 M&quot;).</target>
        </trans-unit>
        <trans-unit id="285243cf13ade280f7038dfb92bbdaa7d26dec36" translate="yes" xml:space="preserve">
          <source>The name of a local ref which represents the &lt;code&gt;@{push}&lt;/code&gt; location for the displayed ref. Respects &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt;, &lt;code&gt;:rstrip&lt;/code&gt;, &lt;code&gt;:track&lt;/code&gt;, &lt;code&gt;:trackshort&lt;/code&gt;, &lt;code&gt;:remotename&lt;/code&gt;, and &lt;code&gt;:remoteref&lt;/code&gt; options as &lt;code&gt;upstream&lt;/code&gt; does. Produces an empty string if no &lt;code&gt;@{push}&lt;/code&gt; ref is configured.</source>
          <target state="translated">표시된 참조 의 &lt;code&gt;@{push}&lt;/code&gt; 위치를 나타내는 로컬 참조의 이름입니다 . 존중 &lt;code&gt;:short&lt;/code&gt; , &lt;code&gt;:lstrip&lt;/code&gt; , &lt;code&gt;:rstrip&lt;/code&gt; , &lt;code&gt;:track&lt;/code&gt; , &lt;code&gt;:trackshort&lt;/code&gt; , &lt;code&gt;:remotename&lt;/code&gt; , 그리고 &lt;code&gt;:remoteref&lt;/code&gt; 같은 옵션 &lt;code&gt;upstream&lt;/code&gt; 않습니다. &lt;code&gt;@{push}&lt;/code&gt; 참조가 구성 되지 않은 경우 빈 문자열을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="25973fbcb02049e23787d52ffa23363b0665166c" translate="yes" xml:space="preserve">
          <source>The name of a new directory to clone into. The &quot;humanish&quot; part of the source repository is used if no directory is explicitly given (&lt;code&gt;repo&lt;/code&gt; for &lt;code&gt;/path/to/repo.git&lt;/code&gt; and &lt;code&gt;foo&lt;/code&gt; for &lt;code&gt;host.xz:foo/.git&lt;/code&gt;). Cloning into an existing directory is only allowed if the directory is empty.</source>
          <target state="translated">복제 할 새 디렉토리의 이름입니다. 어떤 디렉토리이 명시 적으로 지정되지 않는 경우, 소스 저장소의 &quot;humanish&quot;부분이 사용됩니다 ( &lt;code&gt;repo&lt;/code&gt; 에 대한 &lt;code&gt;/path/to/repo.git&lt;/code&gt; 및 &lt;code&gt;foo&lt;/code&gt; 에 대한 &lt;code&gt;host.xz:foo/.git&lt;/code&gt; ). 기존 디렉토리로의 복제는 디렉토리가 비어있는 경우에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3c836d4cc86fbcc3a897aa8fab973465c40a1899" translate="yes" xml:space="preserve">
          <source>The name of an existing branch already in fast-import&amp;rsquo;s internal branch table. If fast-import doesn&amp;rsquo;t know the name, it&amp;rsquo;s treated as a SHA-1 expression.</source>
          <target state="translated">이미 빠른 가져 오기의 내부 분기 테이블에있는 기존 분기의 이름입니다. 빠른 가져 오기에서 이름을 모르면 SHA-1 표현식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="c21a579b2f8550495cd7f286a4f77b45b3df2f6e" translate="yes" xml:space="preserve">
          <source>The name of an existing branch to rename.</source>
          <target state="translated">이름을 바꿀 기존 지점의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b35cfa9e6735c6918643ac8769ab4e5dd81020f0" translate="yes" xml:space="preserve">
          <source>The name of an external credential helper, and any associated options. If the helper name is not an absolute path, then the string &lt;code&gt;git
credential-&lt;/code&gt; is prepended. The resulting string is executed by the shell (so, for example, setting this to &lt;code&gt;foo --option=bar&lt;/code&gt; will execute &lt;code&gt;git credential-foo --option=bar&lt;/code&gt; via the shell. See the manual of specific helpers for examples of their use.</source>
          <target state="translated">외부 자격 증명 도우미의 이름 및 관련 옵션 도우미 이름이 절대 경로가 아닌 경우 문자열 &lt;code&gt;git credential-&lt;/code&gt; 이 앞에 붙습니다. 결과 문자열은 쉘에 의해 실행되는 (그래서, 예를 들어,이 설정 &lt;code&gt;foo --option=bar&lt;/code&gt; 실행됩니다 &lt;code&gt;git credential-foo --option=bar&lt;/code&gt; 통해 쉘에게. 그 사용의 예는 특정 헬퍼의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7efaaad02f8c0d5eaaddaa5b6f8a8113410c8ef1" translate="yes" xml:space="preserve">
          <source>The name of one of the following can be used instead of a URL as &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; argument:</source>
          <target state="translated">&lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; 인수 로 URL 대신 다음 중 하나의 이름을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f54520854ea19fafb55997c9840c558f7f80fed9" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;replace&lt;/code&gt; reference is the SHA-1 of the object that is replaced. The content of the &lt;code&gt;replace&lt;/code&gt; reference is the SHA-1 of the replacement object.</source>
          <target state="translated">&lt;code&gt;replace&lt;/code&gt; 참조 의 이름은 교체 된 개체의 SHA-1입니다. &lt;code&gt;replace&lt;/code&gt; 참조 의 내용은 교체 객체의 SHA-1입니다.</target>
        </trans-unit>
        <trans-unit id="117daad0c937bbfd67b26eaa98382dde664a6203" translate="yes" xml:space="preserve">
          <source>The name of the branch to create or delete. The new branch name must pass all checks defined by &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format[1]&lt;/a&gt;. Some of these checks may restrict the characters allowed in a branch name.</source>
          <target state="translated">만들거나 삭제할 지점의 이름입니다. 새로운 브랜치 이름은 &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format [1]에&lt;/a&gt; 의해 정의 된 모든 검사를 통과해야합니다 . 이러한 검사 중 일부는 지사 이름에 허용되는 문자를 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f40b450a4e1f94bf798289a960712dae0a6f632b" translate="yes" xml:space="preserve">
          <source>The name of the client can be given to &lt;code&gt;git p4&lt;/code&gt; in multiple ways. The variable &lt;code&gt;git-p4.client&lt;/code&gt; takes precedence if it exists. Otherwise, normal p4 mechanisms of determining the client are used: environment variable &lt;code&gt;P4CLIENT&lt;/code&gt;, a file referenced by &lt;code&gt;P4CONFIG&lt;/code&gt;, or the local host name.</source>
          <target state="translated">클라이언트의 이름은 &lt;code&gt;git p4&lt;/code&gt; 에 여러 가지 방법 으로 주어질 수 있습니다 . 변수 &lt;code&gt;git-p4.client&lt;/code&gt; 가있는 경우 우선권을 갖습니다. 그렇지 않으면, 클라이언트를 판별하는 일반적인 p4 메커니즘 (환경 변수 &lt;code&gt;P4CLIENT&lt;/code&gt; , &lt;code&gt;P4CONFIG&lt;/code&gt; 가 참조하는 파일 또는 로컬 호스트 이름)이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d25f4900ca4ac26428c337fc8a49a0fffaa87baa" translate="yes" xml:space="preserve">
          <source>The name of the current branch is stored in .git/HEAD.</source>
          <target state="translated">현재 브랜치의 이름은 .git / HEAD에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9192c74ec25457f29baaadaeb1d2b767ba20ddac" translate="yes" xml:space="preserve">
          <source>The name of the local ref being pushed, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix. In the case of deletion, the name of the local ref is omitted.</source>
          <target state="translated">푸시되는 로컬 참조의 이름에서 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 접두사를 뺀 것 입니다. 삭제시 로컬 참조 이름은 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="61c75d700127b0c70d569d247bca51622e343006" translate="yes" xml:space="preserve">
          <source>The name of the local ref being updated, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix.</source>
          <target state="translated">업데이트되는 로컬 참조의 이름에서 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 접두사를 뺀 것 입니다.</target>
        </trans-unit>
        <trans-unit id="40299b8374a45bc90296f421fddf5763cb8c6908" translate="yes" xml:space="preserve">
          <source>The name of the object to show. For a more complete list of ways to spell object names, see the &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">표시 할 객체의 이름입니다. 객체 이름을 철자하는 방법에 대한 전체 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]의&lt;/a&gt; &quot; SPECIFYING REVISIONS&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="15cfdda92a704493f44c3f6bda85fdb4fe25cc87" translate="yes" xml:space="preserve">
          <source>The name of the ref (the part after $GIT_DIR/). For a non-ambiguous short name of the ref append &lt;code&gt;:short&lt;/code&gt;. The option core.warnAmbiguousRefs is used to select the strict abbreviation mode. If &lt;code&gt;lstrip=&amp;lt;N&amp;gt;&lt;/code&gt; (&lt;code&gt;rstrip=&amp;lt;N&amp;gt;&lt;/code&gt;) is appended, strips &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; slash-separated path components from the front (back) of the refname (e.g. &lt;code&gt;%(refname:lstrip=2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;%(refname:rstrip=2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;refs&lt;/code&gt;). If &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; is a negative number, strip as many path components as necessary from the specified end to leave &lt;code&gt;-&amp;lt;N&amp;gt;&lt;/code&gt; path components (e.g. &lt;code&gt;%(refname:lstrip=-2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;tags/foo&lt;/code&gt; and &lt;code&gt;%(refname:rstrip=-1)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;refs&lt;/code&gt;). When the ref does not have enough components, the result becomes an empty string if stripping with positive &amp;lt;N&amp;gt;, or it becomes the full refname if stripping with negative &amp;lt;N&amp;gt;. Neither is an error.</source>
          <target state="translated">심판의 이름 ($ GIT_DIR / 다음 부분). ref append &lt;code&gt;:short&lt;/code&gt; 의 모호하지 않은 짧은 이름 . core.warnAmbiguousRefs 옵션은 엄격한 약어 모드를 선택하는 데 사용됩니다. 만약 &lt;code&gt;lstrip=&amp;lt;N&amp;gt;&lt;/code&gt; ( &lt;code&gt;rstrip=&amp;lt;N&amp;gt;&lt;/code&gt; )가 추가되어, 스트립 &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; refname의 앞 (뒤)로부터 슬래시 구분 경로 구성 요소 (예 &lt;code&gt;%(refname:lstrip=2)&lt;/code&gt; 온 &lt;code&gt;refs/tags/foo&lt;/code&gt; 에 &lt;code&gt;foo&lt;/code&gt; 에 와 &lt;code&gt;%(refname:rstrip=2)&lt;/code&gt; 회전 &lt;code&gt;refs/tags/foo&lt;/code&gt; 에 &lt;code&gt;refs&lt;/code&gt; ). 경우 &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; 떠날 지정된 단부로부터 필요한만큼 경로 성분으로서 음극 번호, 스트립은 &lt;code&gt;-&amp;lt;N&amp;gt;&lt;/code&gt; 경로 구성 요소 (예 : &lt;code&gt;%(refname:lstrip=-2)&lt;/code&gt; 회전 &lt;code&gt;refs/tags/foo&lt;/code&gt; 로 &lt;code&gt;tags/foo&lt;/code&gt; 및 &lt;code&gt;%(refname:rstrip=-1)&lt;/code&gt; 온 &lt;code&gt;refs/tags/foo&lt;/code&gt; 로 &lt;code&gt;refs&lt;/code&gt; ). 참조에 충분한 구성 요소가 없으면 양수 &amp;lt;N&amp;gt;으로 스트립하면 결과가 빈 문자열이되거나 음수 &amp;lt;N&amp;gt;으로 스트립하면 전체 참조 이름이됩니다. 오류도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d3667dc69f3d60260150d30873ae903291e9c610" translate="yes" xml:space="preserve">
          <source>The name of the remote ref being fetched from, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix. In the case of deletion, the name of the remote ref is &quot;(none)&quot;.</source>
          <target state="translated">가져 오는 원격 참조의 이름에서 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 접두사를 뺀 값 입니다. 삭제의 경우 원격 참조의 이름은 &quot;(없음)&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="f1e1380262032f81dbdd04e4a724dd0dac2f66a0" translate="yes" xml:space="preserve">
          <source>The name of the remote ref being updated, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix.</source>
          <target state="translated">업데이트중인 원격 참조의 이름에서 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 접두사를 뺀 것 입니다.</target>
        </trans-unit>
        <trans-unit id="cf1208454bdf4c7c5a0ab602103e6dd838ca212a" translate="yes" xml:space="preserve">
          <source>The name of the repository in gitweb is the path to its &lt;code&gt;$GIT_DIR&lt;/code&gt; (its object database) relative to &lt;code&gt;$projectroot&lt;/code&gt;. Therefore the repository $repo can be found at &quot;$projectroot/$repo&quot;.</source>
          <target state="translated">gitweb에있는 저장소의 이름은 그것의 경로입니다 &lt;code&gt;$GIT_DIR&lt;/code&gt; 에 (의 객체 데이터베이스) 기준으로 &lt;code&gt;$projectroot&lt;/code&gt; . 따라서 $ repo 저장소는 &quot;$ projectroot / $ repo&quot;에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b6cc45302b6351d18e813818cde0845c0a5a22a" translate="yes" xml:space="preserve">
          <source>The name of the tag to create, delete, or describe. The new tag name must pass all checks defined by &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format[1]&lt;/a&gt;. Some of these checks may restrict the characters allowed in a tag name.</source>
          <target state="translated">작성, 삭제 또는 설명 할 태그의 이름입니다. 새 태그 이름은 &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format [1]에&lt;/a&gt; 의해 정의 된 모든 검사를 통과해야합니다 . 이러한 검사 중 일부는 태그 이름에 허용되는 문자를 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="964fd80a7ebc3b646125e059ac3c7f8c3a22061f" translate="yes" xml:space="preserve">
          <source>The named branches will be interpreted as if specified with the &lt;code&gt;-t&lt;/code&gt; option on the &lt;code&gt;git remote add&lt;/code&gt; command line.</source>
          <target state="translated">명명 된 브랜치는 &lt;code&gt;git remote add&lt;/code&gt; 명령 행 에서 &lt;code&gt;-t&lt;/code&gt; 옵션으로 지정된 것처럼 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="a7226417649eb7c8f42ca4934a290033c08aad1c" translate="yes" xml:space="preserve">
          <source>The names of objects to show (defaults to &lt;code&gt;HEAD&lt;/code&gt;). For a more complete list of ways to spell object names, see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">표시 할 객체의 이름입니다 (기본값은 &lt;code&gt;HEAD&lt;/code&gt; ). 객체 이름을 철자하는 방법에 대한 전체 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]의&lt;/a&gt; &quot; SPECIFYING REVISIONS&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="df439b2df93c9264d2652e8aa379f62f3b6ab5ac" translate="yes" xml:space="preserve">
          <source>The names of refs that are fetched, together with the object names they point at, are written to &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt;. This information may be used by scripts or other git commands, such as &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;.</source>
          <target state="translated">페치 된 참조 이름은 오브젝트 이름과 함께 &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; 에 기록됩니다 . 이 정보는 스크립트 또는 &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt; 과 같은 다른 git 명령에 의해 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b9c4b549f992b26edb42d00411780a65661d81d" translate="yes" xml:space="preserve">
          <source>The native transport (i.e. git:// URL) does no authentication and should be used with caution on unsecured networks.</source>
          <target state="translated">원시 전송 (예 : git : // URL)은 인증이 없으므로 보안되지 않은 네트워크에서는주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="86d32cda4c46d201605240981feec896fb3daceb" translate="yes" xml:space="preserve">
          <source>The new branch head will point to this commit. It may be given as a branch name, a commit-id, or a tag. If this option is omitted, the current HEAD will be used instead.</source>
          <target state="translated">새로운 지점장은이 커밋을 가리 킵니다. 브랜치 이름, 커밋 ID 또는 태그로 제공 될 수 있습니다. 이 옵션을 생략하면 현재 HEAD가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="597e47a48a8bd8b3528838dd5cebedeb7b241f60" translate="yes" xml:space="preserve">
          <source>The new name for an existing branch. The same restrictions as for &amp;lt;branchname&amp;gt; apply.</source>
          <target state="translated">기존 지점의 새 이름 &amp;lt;branchname&amp;gt;과 동일한 제한 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="05a068e20a6ba11ea4fd1dbaef65a93e78041978" translate="yes" xml:space="preserve">
          <source>The new stash entry records the modified states only for the files that match the pathspec. The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact.</source>
          <target state="translated">The new stash entry records the modified states only for the files that match the pathspec. The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact.</target>
        </trans-unit>
        <trans-unit id="ade318097a09c67b5bdaa6c1344cf2a281d7cac8" translate="yes" xml:space="preserve">
          <source>The next parameter is the pattern. This option has to be used for patterns starting with &lt;code&gt;-&lt;/code&gt; and should be used in scripts passing user input to grep. Multiple patterns are combined by &lt;code&gt;or&lt;/code&gt;.</source>
          <target state="translated">다음 매개 변수는 패턴입니다. 이 옵션은 &lt;code&gt;-&lt;/code&gt; 로 시작하는 패턴에 사용해야하며 grep에 사용자 입력을 전달하는 스크립트에 사용해야합니다. 여러 패턴이 &lt;code&gt;or&lt;/code&gt; 로 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="00f28e3b882b5553d45ceeb08082d3dcda522dd0" translate="yes" xml:space="preserve">
          <source>The next step of merging is to merge these three versions of the file, using 3-way merge. This is done by giving &lt;code&gt;git merge-one-file&lt;/code&gt; command as one of the arguments to &lt;code&gt;git merge-index&lt;/code&gt; command:</source>
          <target state="translated">병합의 다음 단계는 3 방향 병합을 사용하여이 세 가지 버전의 파일을 병합하는 것입니다. 이것은 &lt;code&gt;git merge-one-file&lt;/code&gt; 명령을 &lt;code&gt;git merge-index&lt;/code&gt; 명령 의 인수 중 하나로 제공하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="c203649e7405cacf1f66f3229b4d864ccf1b5f34" translate="yes" xml:space="preserve">
          <source>The nonce string the process asked the signer to include in the push certificate. If this does not match the value recorded on the &quot;nonce&quot; header in the push certificate, it may indicate that the certificate is a valid one that is being replayed from a separate &quot;git push&quot; session.</source>
          <target state="translated">프로세스에서 nonce 문자열은 서명자에게 푸시 인증서에 포함하도록 요청했습니다. 이것이 푸시 인증서의 &quot;nonce&quot;헤더에 기록 된 값과 일치하지 않으면 인증서가 별도의 &quot;git push&quot;세션에서 재생되는 유효한 인증서임을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a81eae6f204563324e9f0299e6e5a18af11339c2" translate="yes" xml:space="preserve">
          <source>The normal format target is a tradition printf format and similar to GIT_TRACE format. This format is enabled with the &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variable or the &lt;code&gt;trace2.normalTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">일반 형식 대상은 일반적인 printf 형식이며 GIT_TRACE 형식과 유사합니다. 이 형식은 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 환경 변수 또는 &lt;code&gt;trace2.normalTarget&lt;/code&gt; 시스템 또는 글로벌 구성 설정으로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="08867837836724d3f4c3cfbd7d03fa5d964eec62" translate="yes" xml:space="preserve">
          <source>The number of additional commits is the number of commits which would be displayed by &quot;git log v1.0.4..parent&quot;. The hash suffix is &quot;-g&quot; + unambiguous abbreviation for the tip commit of parent (which was &lt;code&gt;2414721b194453f058079d897d13c4e377f92dc6&lt;/code&gt;). The &quot;g&quot; prefix stands for &quot;git&quot; and is used to allow describing the version of a software depending on the SCM the software is managed with. This is useful in an environment where people may use different SCMs.</source>
          <target state="translated">추가 커밋 수는 &quot;git log v1.0.4..parent&quot;로 표시되는 커밋 수입니다. 해시 접미사는 &quot;-g&quot;+ 부모의 팁 커밋 ( &lt;code&gt;2414721b194453f058079d897d13c4e377f92dc6&lt;/code&gt; )에 대한 모호하지 않은 약어입니다 . &quot;g&quot;접두사는 &quot;git&quot;을 나타내며 소프트웨어가 관리되는 SCM에 따라 소프트웨어 버전을 설명하는 데 사용됩니다. 사람들이 다른 SCM을 사용할 수있는 환경에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="83386653d6009935020ea78a4c28a793cc5fa198" translate="yes" xml:space="preserve">
          <source>The number of curl sessions (counted across slots) to be kept across requests. They will not be ended with curl_easy_cleanup() until http_cleanup() is invoked. If USE_CURL_MULTI is not defined, this value will be capped at 1. Defaults to 1.</source>
          <target state="translated">요청간에 유지 될 컬 세션 수 (슬롯에 걸쳐 계산) http_cleanup ()이 호출 될 때까지 curl_easy_cleanup ()으로 끝나지 않습니다. USE_CURL_MULTI가 정의되지 않은 경우이 값은 1로 제한됩니다. 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="eb593ed0188a165abaa2fc9b58825ac993fcfa11" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing rename detection during a merge; if not specified, defaults to the value of diff.renameLimit. This setting has no effect if rename detection is turned off.</source>
          <target state="translated">병합 중에 이름 바꾸기 감지를 수행 할 때 고려할 파일 수입니다. 지정하지 않으면 기본값은 diff.renameLimit입니다. 이름 바꾸기 감지 기능이 해제되어 있으면이 설정이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b49ca7e6ecad75b8cf0b0ec3dcf469e017a13140" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing rename detection in &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;. Defaults to the value of diff.renameLimit.</source>
          <target state="translated">&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 및 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 에서 이름 바꾸기 감지를 수행 할 때 고려할 파일 수입니다 . 기본값은 diff.renameLimit입니다.</target>
        </trans-unit>
        <trans-unit id="62caddb975571c60931b3e5e41910f9ec3dfea6e" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing the copy/rename detection; equivalent to the &lt;code&gt;git diff&lt;/code&gt; option &lt;code&gt;-l&lt;/code&gt;. This setting has no effect if rename detection is turned off.</source>
          <target state="translated">복사 / 이름 바꾸기 감지를 수행 할 때 고려할 파일 수입니다. &lt;code&gt;git diff&lt;/code&gt; 옵션 &lt;code&gt;-l&lt;/code&gt; 과 같습니다 . 이름 바꾸기 감지 기능이 해제되어 있으면이 설정이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f40a726880d5eda55c8da498a0add02c8ea2a7b1" translate="yes" xml:space="preserve">
          <source>The number of push options given on the command line of &lt;code&gt;git push --push-option=...&lt;/code&gt; can be read from the environment variable &lt;code&gt;GIT_PUSH_OPTION_COUNT&lt;/code&gt;, and the options themselves are found in &lt;code&gt;GIT_PUSH_OPTION_0&lt;/code&gt;, &lt;code&gt;GIT_PUSH_OPTION_1&lt;/code&gt;,&amp;hellip;​ If it is negotiated to not use the push options phase, the environment variables will not be set. If the client selects to use push options, but doesn&amp;rsquo;t transmit any, the count variable will be set to zero, &lt;code&gt;GIT_PUSH_OPTION_COUNT=0&lt;/code&gt;.</source>
          <target state="translated">의 명령 행에서 주어진 푸시 옵션의 수는 &lt;code&gt;git push --push-option=...&lt;/code&gt; 환경 변수에서 읽을 수 &lt;code&gt;GIT_PUSH_OPTION_COUNT&lt;/code&gt; 하고, 옵션 자체에서 발견되는 &lt;code&gt;GIT_PUSH_OPTION_0&lt;/code&gt; , &lt;code&gt;GIT_PUSH_OPTION_1&lt;/code&gt; 이하지에 협상 경우 ... 푸시 옵션 단계를 사용하면 환경 변수가 설정되지 않습니다. 클라이언트가 푸시 옵션을 사용하도록 선택했지만 전송하지 않으면 카운트 변수는 0으로 설정됩니다 ( &lt;code&gt;GIT_PUSH_OPTION_COUNT=0&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="c5ad10bd3ab58adc794f2122271c46d58529bef4" translate="yes" xml:space="preserve">
          <source>The number of spaces between columns. One space by default.</source>
          <target state="translated">열 사이의 공백 수입니다. 기본적으로 하나의 공간.</target>
        </trans-unit>
        <trans-unit id="911462b0802b22317c5a57a0a0510dbf0c397a66" translate="yes" xml:space="preserve">
          <source>The number of submodules fetched at the same time. Defaults to the &lt;code&gt;submodule.fetchJobs&lt;/code&gt; option.</source>
          <target state="translated">동시에 가져온 서브 모듈의 수입니다. &lt;code&gt;submodule.fetchJobs&lt;/code&gt; 옵션이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="34de3b8749bfae0c14ff8d34783f05c9920748b5" translate="yes" xml:space="preserve">
          <source>The object can be a blob or a submodule commit. It implies the &lt;code&gt;-t&lt;/code&gt; option in &lt;code&gt;git-log&lt;/code&gt; to also find trees.</source>
          <target state="translated">오브젝트는 Blob 또는 서브 모듈 커밋 일 수 있습니다. &lt;code&gt;git-log&lt;/code&gt; 의 &lt;code&gt;-t&lt;/code&gt; 옵션을 사용하여 트리를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="2794f5933199b4937a09c41b8d049f6b88620c25" translate="yes" xml:space="preserve">
          <source>The object database contains objects of three main types: blobs, which hold file data; trees, which point to blobs and other trees to build up directory hierarchies; and commits, which each reference a single tree and some number of parent commits.</source>
          <target state="translated">오브젝트 데이터베이스에는 세 가지 주요 유형의 오브젝트가 있습니다. 파일 데이터를 보유하는 블롭; 디렉토리 계층을 구축하기위한 블롭 및 다른 트리를 가리키는 트리; 커밋-각각은 단일 트리와 몇 개의 부모 커밋을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="b5ea163b65a2243d9fc238d7c50700c517adc350" translate="yes" xml:space="preserve">
          <source>The object database is the rather elegant system used to store the history of your project&amp;mdash;​files, directories, and commits.</source>
          <target state="translated">객체 데이터베이스는 프로젝트 기록 (파일, 디렉토리 및 커밋)을 저장하는 데 사용되는 다소 우아한 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="db080c7937810b605e4381605a2e18077b89e3c0" translate="yes" xml:space="preserve">
          <source>The object name (aka SHA-1). For a non-ambiguous abbreviation of the object name append &lt;code&gt;:short&lt;/code&gt;. For an abbreviation of the object name with desired length append &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt;, where the minimum length is MINIMUM_ABBREV. The length may be exceeded to ensure unique object names.</source>
          <target state="translated">객체 이름 (일명 SHA-1). 객체 이름의 모호하지 않은 약어의 경우 append &lt;code&gt;:short&lt;/code&gt; . 원하는 길이를 추가 한 객체 이름의 약어 인 append &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt; 는 최소 길이가 MINIMUM_ABBREV입니다. 고유 한 객체 이름을 보장하기 위해 길이를 초과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b335d1a75376848bee9affb50a6203b316fcc02d" translate="yes" xml:space="preserve">
          <source>The object referenced by &amp;lt;src&amp;gt; is used to update the &amp;lt;dst&amp;gt; reference on the remote side. Whether this is allowed depends on where in &lt;code&gt;refs/*&lt;/code&gt; the &amp;lt;dst&amp;gt; reference lives as described in detail below, in those sections &quot;update&quot; means any modifications except deletes, which as noted after the next few sections are treated differently.</source>
          <target state="translated">&amp;lt;src&amp;gt;가 참조하는 객체는 원격 측에서 &amp;lt;dst&amp;gt; 참조를 업데이트하는 데 사용됩니다. 이것이 허용되는지 여부는 &lt;code&gt;refs/*&lt;/code&gt; 에서 &amp;lt;dst&amp;gt; 참조가 아래에 자세히 설명 된대로 존재 하는 위치에 따라 달라집니다. &quot;업데이트&quot;섹션에서 &quot;업데이트&quot;는 삭제를 제외한 모든 수정을 의미하며, 다음 섹션은 다르게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="afdbad7acf93ca3457880eb431fd58ab07141e11" translate="yes" xml:space="preserve">
          <source>The object table is actually a hashtable keyed on the object name (the unique SHA-1). This storage configuration allows fast-import to reuse an existing or already written object and avoid writing duplicates to the output packfile. Duplicate blobs are surprisingly common in an import, typically due to branch merges in the source.</source>
          <target state="translated">오브젝트 테이블은 실제로 오브젝트 이름 (고유 한 SHA-1)을 기반으로하는 해시 테이블입니다. 이 저장소 구성을 사용하면 빠른 가져 오기로 기존 또는 이미 작성된 객체를 재사용 할 수 있으며 출력 팩 파일에 복제본을 쓰지 않아도됩니다. 일반적으로 소스의 브랜치 병합으로 인해 가져 오기에서 중복 얼룩이 흔하게 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0b16e9c4d73790474d293fcd4d96547c235d7d1f" translate="yes" xml:space="preserve">
          <source>The object that the new tag will refer to, usually a commit. Defaults to HEAD.</source>
          <target state="translated">새 태그가 참조 할 객체, 일반적으로 커밋. 기본값은 HEAD입니다.</target>
        </trans-unit>
        <trans-unit id="5468420c6f62137502c6bb00574138b237765047" translate="yes" xml:space="preserve">
          <source>The object type may be a blob, representing the contents of a file, or another tree, representing the contents of a subdirectory. Since trees and blobs, like all other objects, are named by the SHA-1 hash of their contents, two trees have the same SHA-1 name if and only if their contents (including, recursively, the contents of all subdirectories) are identical. This allows Git to quickly determine the differences between two related tree objects, since it can ignore any entries with identical object names.</source>
          <target state="translated">객체 유형은 파일의 내용을 나타내는 블롭이거나 하위 디렉토리의 내용을 나타내는 다른 트리 일 수 있습니다. 다른 모든 객체와 마찬가지로 트리와 BLOB는 내용의 SHA-1 해시로 이름이 지정되므로 내용 (재귀 적으로 모든 하위 디렉토리의 내용 포함)이 동일한 경우에만 두 개의 트리가 동일한 SHA-1 이름을 갖습니다. . 이를 통해 Git은 동일한 객체 이름을 가진 항목을 무시할 수 있기 때문에 두 개의 관련 트리 객체 간의 차이점을 신속하게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abf9c48e6cb6157bcc4ecdd7fbfd1167ee2a4bc5" translate="yes" xml:space="preserve">
          <source>The object types in some more detail:</source>
          <target state="translated">객체 유형에 대한 자세한 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1aa11fdf087f0d8d0d32eb67b923b0efa29ecf46" translate="yes" xml:space="preserve">
          <source>The objects are output in the order in which they are found in the index file, which should be (in a correctly constructed file) sorted by object id.</source>
          <target state="translated">객체는 색인 파일에서 찾은 순서대로 출력되며,이 파일은 객체 ID별로 (정확하게 구성된 파일에서) 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="113c9617d3615ff46d1de3788621403d384bc970" translate="yes" xml:space="preserve">
          <source>The official repository of the &lt;code&gt;git gui&lt;/code&gt; project can be found at:</source>
          <target state="translated">&lt;code&gt;git gui&lt;/code&gt; 프로젝트 의 공식 저장소는 다음 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2925f4342d92a06228b4eeddfbffd0ada540f91" translate="yes" xml:space="preserve">
          <source>The one commit in this list that is not related to CMake may very well have been motivated by working on fixing all those bugs introduced by switching to CMake, but it addresses a different concern. To split this branch into two topic branches, the todo list could be edited like this:</source>
          <target state="translated">CMake와 관련이없는이 목록의 커밋은 CMake로 전환하여 발생하는 모든 버그를 수정하여 동기를 부여 받았을 수도 있지만 다른 문제를 해결합니다. 이 브랜치를 두 개의 토픽 브랜치로 나누기 위해 할 일 목록을 다음과 같이 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="680930999bd0e3bf9880124c135a89bca3a329f3" translate="yes" xml:space="preserve">
          <source>The oneline descriptions are purely for your pleasure; &lt;code&gt;git rebase&lt;/code&gt; will not look at them but at the commit names (&quot;deadbee&quot; and &quot;fa1afe1&quot; in this example), so do not delete or edit the names.</source>
          <target state="translated">oneline 설명은 순전히 당신의 즐거움을위한 것입니다. &lt;code&gt;git rebase&lt;/code&gt; 는 커밋 이름 (이 예제에서는 &quot;deadbee&quot;및 &quot;fa1afe1&quot;)을 보지 않으므로 이름을 삭제하거나 편집하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b174b5f513a45da66bee660cec63368b38af2a1f" translate="yes" xml:space="preserve">
          <source>The only difference between this command and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; is that they use slightly different output formats, and this command exists only for backward compatibility to support existing scripts, and provide a more familiar command name for people coming from other SCM systems.</source>
          <target state="translated">이 명령과 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; 의 유일한 차이점은 약간 다른 출력 형식을 사용한다는 점입니다.이 명령은 기존 스크립트를 지원하기 위해 이전 버전과의 호환성을 위해서만 존재하며 다른 SCM 시스템 사용자에게 친숙한 명령 이름을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="90482aceb580582ec33d188b8fb1bca29f8136a1" translate="yes" xml:space="preserve">
          <source>The option can have the following values, defaulting to &lt;code&gt;group&lt;/code&gt; if no value is given:</source>
          <target state="translated">이 옵션은 다음과 같은 값을 가질 수 있으며, 값이 제공되지 않으면 &lt;code&gt;group&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="72a352b7174eb63582b749d1295b267e0dae9887" translate="yes" xml:space="preserve">
          <source>The optional &amp;lt;limit&amp;gt; is useful in cases where your topic is based on other work that is not in upstream. Expanding on the previous example, this might look like:</source>
          <target state="translated">선택적인 &amp;lt;limit&amp;gt;는 주제가 업스트림이 아닌 다른 작업을 기반으로하는 경우에 유용합니다. 이전 예제에서 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4136e1c0c625091f77db10ec0b76e55e39fdb1b6" translate="yes" xml:space="preserve">
          <source>The optional &amp;lt;style&amp;gt; argument can be either &lt;code&gt;shallow&lt;/code&gt; or &lt;code&gt;deep&lt;/code&gt;. &lt;code&gt;shallow&lt;/code&gt; threading makes every mail a reply to the head of the series, where the head is chosen from the cover letter, the &lt;code&gt;--in-reply-to&lt;/code&gt;, and the first patch mail, in this order. &lt;code&gt;deep&lt;/code&gt; threading makes every mail a reply to the previous one.</source>
          <target state="translated">선택적 &amp;lt;style&amp;gt; 인수는 &lt;code&gt;shallow&lt;/code&gt; 또는 &lt;code&gt;deep&lt;/code&gt; 일 수 있습니다 . &lt;code&gt;shallow&lt;/code&gt; 스레딩은 모든 메일을 시리즈의 헤드에 대한 답장으로 만듭니다. 헤드는 표지, &lt;code&gt;--in-reply-to&lt;/code&gt; 및 첫 번째 패치 메일에서이 순서대로 선택됩니다. &lt;code&gt;deep&lt;/code&gt; 스레딩은 모든 메일을 이전 메일에 대한 회신으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="3dd98bdacd886ba292b303baaba2ecefebed8bab" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;encoding&lt;/code&gt; command indicates the encoding of the commit message. Most commits are UTF-8 and the encoding is omitted, but this allows importing commit messages into git without first reencoding them.</source>
          <target state="translated">선택적 &lt;code&gt;encoding&lt;/code&gt; 명령은 커밋 메시지의 인코딩을 나타냅니다. 대부분의 커밋은 UTF-8이며 인코딩은 생략되지만 커밋 메시지를 먼저 다시 인코딩하지 않고 git으로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1f596d4ea27770161ef3ea6df226eac8321e34f" translate="yes" xml:space="preserve">
          <source>The optional GPG signature of the tag.</source>
          <target state="translated">The optional GPG signature of the tag.</target>
        </trans-unit>
        <trans-unit id="b0ae75c1b10bf71d7e20ef9926e29585fa74a2e0" translate="yes" xml:space="preserve">
          <source>The optional argument &amp;lt;path&amp;gt; is the relative location for the cloned submodule to exist in the superproject. If &amp;lt;path&amp;gt; is not given, the canonical part of the source repository is used (&quot;repo&quot; for &quot;/path/to/repo.git&quot; and &quot;foo&quot; for &quot;host.xz:foo/.git&quot;). If &amp;lt;path&amp;gt; exists and is already a valid Git repository, then it is staged for commit without cloning. The &amp;lt;path&amp;gt; is also used as the submodule&amp;rsquo;s logical name in its configuration entries unless &lt;code&gt;--name&lt;/code&gt; is used to specify a logical name.</source>
          <target state="translated">선택적 인수 &amp;lt;path&amp;gt;는 복제 된 하위 모듈이 수퍼 프로젝트에 존재하는 상대 위치입니다. &amp;lt;path&amp;gt;를 지정하지 않으면 소스 저장소의 표준 부분이 사용됩니다 ( &quot;/path/to/repo.git&quot;의 경우 &quot;repo&quot;, &quot;host.xz : foo / .git&quot;의 경우 &quot;foo&quot;). &amp;lt;path&amp;gt;가 존재하고 이미 유효한 Git 리포지토리 인 경우 복제하지 않고 커밋을 위해 준비됩니다. &lt;code&gt;--name&lt;/code&gt; 을 사용하여 논리적 이름을 지정 하지 않으면 &amp;lt;path&amp;gt;는 구성 항목에서 하위 모듈의 논리적 이름으로도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="476c5c2c4870d6be72c4d31b42e1450136c51807" translate="yes" xml:space="preserve">
          <source>The optional configuration variable &lt;code&gt;core.excludesFile&lt;/code&gt; indicates a path to a file containing patterns of file names to exclude, similar to &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt;. Patterns in the exclude file are used in addition to those in &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt;.</source>
          <target state="translated">선택적 구성 변수 &lt;code&gt;core.excludesFile&lt;/code&gt; 은 &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; 와 유사하게 제외 할 파일 이름 패턴이 포함 된 파일의 경로를 나타냅니다 . 제외 파일의 패턴은 &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; 패턴과 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad80c43bd988ae6e6061dfab8a056d2afaee7691" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;--contains&lt;/code&gt;, &lt;code&gt;--no-contains&lt;/code&gt;, &lt;code&gt;--merged&lt;/code&gt; and &lt;code&gt;--no-merged&lt;/code&gt; serve four related but different purposes:</source>
          <target state="translated">옵션의 &lt;code&gt;--contains&lt;/code&gt; 는 , &lt;code&gt;--no-contains&lt;/code&gt; , &lt;code&gt;--merged&lt;/code&gt; 및 &lt;code&gt;--no-merged&lt;/code&gt; 사 관련이 있지만, 다른 용도로 사용</target>
        </trans-unit>
        <trans-unit id="081a3bdc8213b4774c97cebf32978af69c3476cb" translate="yes" xml:space="preserve">
          <source>The order of stages 1, 2 and 3 (hence the order of three &amp;lt;tree-ish&amp;gt; command-line arguments) are significant when you start a 3-way merge with an index file that is already populated. Here is an outline of how the algorithm works:</source>
          <target state="translated">단계 1, 2 및 3의 순서 (따라서 세 개의 &amp;lt;tree-ish&amp;gt; 명령 행 인수의 순서)는 이미 채워진 색인 파일과 3 방향 병합을 시작할 때 중요합니다. 다음은 알고리즘 작동 방식에 대한 개요입니다.</target>
        </trans-unit>
        <trans-unit id="3fb57cf5101f783ba73fc6eba17ed42ef2940627" translate="yes" xml:space="preserve">
          <source>The order of the flags used to matter, but not anymore.</source>
          <target state="translated">중요했던 플래그의 순서는 더 이상 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32a54a6aa8ff67e3d76c47c6fabd2affc1e5cbb5" translate="yes" xml:space="preserve">
          <source>The origin of lines is automatically followed across whole-file renames (currently there is no option to turn the rename-following off). To follow lines moved from one file to another, or to follow lines that were copied and pasted from another file, etc., see the &lt;code&gt;-C&lt;/code&gt; and &lt;code&gt;-M&lt;/code&gt; options.</source>
          <target state="translated">행의 원점은 전체 파일 이름 바꾸기에서 자동으로 따릅니다 (현재 이름 바꾸기를 끄는 옵션은 없습니다). 한 파일에서 다른 파일로 이동 한 행을 따르거나 다른 파일에서 복사하여 붙여 넣은 행을 따르려면 &lt;code&gt;-C&lt;/code&gt; 및 &lt;code&gt;-M&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b66619a4ae8f145d6aac4431781b08d6ac86597a" translate="yes" xml:space="preserve">
          <source>The origin revision can be changed with the &quot;--origin&quot; option.</source>
          <target state="translated">원점 수정은 &quot;--origin&quot;옵션으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="617fe8d1d55cfe9ccc09f76fcfa190410b239da3" translate="yes" xml:space="preserve">
          <source>The original format used by Greg Kroah-Hartman&amp;rsquo;s &lt;code&gt;send_lots_of_email.pl&lt;/code&gt; script</source>
          <target state="translated">Greg Kroah-Hartman의 &lt;code&gt;send_lots_of_email.pl&lt;/code&gt; 스크립트가 사용한 원래 형식</target>
        </trans-unit>
        <trans-unit id="a7a5cdcdcd4d6fcaaf02e53acebd8443c9b015da" translate="yes" xml:space="preserve">
          <source>The original job of &lt;code&gt;git rev-parse&lt;/code&gt; is now taken by the function &lt;code&gt;setup_revisions()&lt;/code&gt;, which parses the revisions and the common command-line options for the revision walker. This information is stored in the struct &lt;code&gt;rev_info&lt;/code&gt; for later consumption. You can do your own command-line option parsing after calling &lt;code&gt;setup_revisions()&lt;/code&gt;. After that, you have to call &lt;code&gt;prepare_revision_walk()&lt;/code&gt; for initialization, and then you can get the commits one by one with the function &lt;code&gt;get_revision()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git rev-parse&lt;/code&gt; 의 원래 작업 은 이제 &lt;code&gt;setup_revisions()&lt;/code&gt; 함수에 의해 수행됩니다.이 함수 는 개정 및 워커에 대한 공통 명령 행 옵션을 구문 분석합니다. 이 정보는 나중에 &lt;code&gt;rev_info&lt;/code&gt; 있도록 struct rev_info 에 저장됩니다 . &lt;code&gt;setup_revisions()&lt;/code&gt; 호출 한 후 고유 한 명령 행 옵션 구문 분석을 수행 할 수 있습니다 . 그 후, 당신은 전화로이 &lt;code&gt;prepare_revision_walk()&lt;/code&gt; 초기화, 다음은 함수에 의해 커밋 하나를 얻을 수 있습니다 &lt;code&gt;get_revision()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c9da327e28b59015cec84abd98a33aec635328d" translate="yes" xml:space="preserve">
          <source>The original tags are not deleted, but can be overwritten; use &quot;--tag-name-filter cat&quot; to simply update the tags. In this case, be very careful and make sure you have the old tags backed up in case the conversion has run afoul.</source>
          <target state="translated">원래 태그는 삭제되지 않지만 덮어 쓸 수 있습니다. 단순히 태그를 업데이트하려면 &quot;--tag-name-filter cat&quot;을 사용하십시오. 이 경우 전환에 문제가있는 경우를 대비하여 매우 신중하고 이전 태그를 백업해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c2cf73d4477ea65ac2368f08dedbcc07c9eafb4" translate="yes" xml:space="preserve">
          <source>The other nice thing with test suites, is that when you have one, you already know how to test for bad behavior. So you can use this knowledge to create a new test case for &quot;git bisect&quot; when it appears that there is a regression. So it will be easier to bisect the bug and fix it. And then you can add the test case you just created to your test suite.</source>
          <target state="translated">테스트 스위트의 또 다른 좋은 점은 하나가 있으면 나쁜 동작을 테스트하는 방법을 이미 알고 있다는 것입니다. 따라서이 지식을 사용하여 회귀가있는 경우 &quot;git bisect&quot;에 대한 새로운 테스트 사례를 만들 수 있습니다. 따라서 버그를 양분하고 수정하는 것이 더 쉬울 것입니다. 그런 다음 방금 생성 한 테스트 사례를 테스트 스위트에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94bda500b4b5c47f0218909469e6ab7f1eee52b6" translate="yes" xml:space="preserve">
          <source>The other way to drive the bisection process is to tell &quot;git bisect&quot; to launch a script or command at each bisection step to know if the current commit is &quot;good&quot; or &quot;bad&quot;. To do that, we use the &quot;git bisect run&quot; command. For example:</source>
          <target state="translated">bisection 프로세스를 구동하는 다른 방법은 &quot;git bisect&quot;에게 각 bisection 단계에서 스크립트 또는 명령을 실행하여 현재 커밋이 &quot;good&quot;또는 &quot;bad&quot;인지 알도록 지시하는 것입니다. 이를 위해 &quot;git bisect run&quot;명령을 사용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="013b9f528101f55f667633859403afae697697c4" translate="yes" xml:space="preserve">
          <source>The output format is modified to be machine-parsable (see below). If &lt;code&gt;--stdin&lt;/code&gt; is also given, input paths are separated with a NUL character instead of a linefeed character.</source>
          <target state="translated">출력 형식이 기계 구문 분석 가능하도록 수정되었습니다 (아래 참조). 경우 &lt;code&gt;--stdin&lt;/code&gt; 옵션은 또한 주어진 입력 경로는 널 문자 대신 개행 문자로 분리된다.</target>
        </trans-unit>
        <trans-unit id="4ebdc78d172a0b82e38a898aa2ae716344def4d5" translate="yes" xml:space="preserve">
          <source>The output format is modified to be machine-parsable. If &lt;code&gt;--stdin&lt;/code&gt; is also given, input paths are separated with a NUL character instead of a linefeed character.</source>
          <target state="translated">출력 형식이 기계 구문 분석 가능하도록 수정되었습니다. 경우 &lt;code&gt;--stdin&lt;/code&gt; 옵션은 또한 주어진 입력 경로는 널 문자 대신 개행 문자로 분리된다.</target>
        </trans-unit>
        <trans-unit id="885a3d9b027501a3f7ddd2554d827f984cacfcf5" translate="yes" xml:space="preserve">
          <source>The output format is similar to the Porcelain format, but it does not contain the actual lines from the file that is being annotated.</source>
          <target state="translated">출력 형식은 Porcelain 형식과 유사하지만 주석이 추가 된 파일의 실제 줄은 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="16ca2e6d144e9c4d47f91cfe57ded6c4b6f874af" translate="yes" xml:space="preserve">
          <source>The output from this command is designed to be used as a commit template comment. The default, long format, is designed to be human readable, verbose and descriptive. Its contents and format are subject to change at any time.</source>
          <target state="translated">이 명령의 출력은 커밋 템플릿 주석으로 사용되도록 설계되었습니다. 기본적으로 긴 형식은 사람이 읽을 수 있고 자세하며 설명이 가능하도록 설계되었습니다. 내용과 형식은 언제든지 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="467b04ab4f0f42e5eb4db50995625d7a06a04bbc" translate="yes" xml:space="preserve">
          <source>The output is in the format: &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;space&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;reference name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">출력은 &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;space&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;reference name&amp;gt;&lt;/code&gt; 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="297e105083265b9b5df9c784faa30006468bc5fd" translate="yes" xml:space="preserve">
          <source>The output is of the form: &amp;lt;path&amp;gt; COLON SP &amp;lt;attribute&amp;gt; COLON SP &amp;lt;info&amp;gt; LF</source>
          <target state="translated">출력은 &amp;lt;path&amp;gt; COLON SP &amp;lt;attribute&amp;gt; COLON SP &amp;lt;info&amp;gt; LF 형식입니다.</target>
        </trans-unit>
        <trans-unit id="00d47eecfb8e7c432b9a2a4461da0aa0b0a14445" translate="yes" xml:space="preserve">
          <source>The output is the new tag&amp;rsquo;s &amp;lt;object&amp;gt; identifier.</source>
          <target state="translated">출력은 새 태그의 &amp;lt;object&amp;gt; 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="c209f5f99a30592095be06f60778bfc6143218e8" translate="yes" xml:space="preserve">
          <source>The output of &quot;git fetch&quot; depends on the transport method used; this section describes the output when fetching over the Git protocol (either locally or via ssh) and Smart HTTP protocol.</source>
          <target state="translated">&quot;git fetch&quot;의 출력은 사용 된 전송 방법에 따라 다릅니다. 이 섹션에서는 Git 프로토콜 (로컬 또는 ssh를 통해) 및 Smart HTTP 프로토콜을 통해 가져올 때의 출력에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="249df455a76d6d8a4ee813f24ba8c68836888f67" translate="yes" xml:space="preserve">
          <source>The output of &quot;git push&quot; depends on the transport method used; this section describes the output when pushing over the Git protocol (either locally or via ssh).</source>
          <target state="translated">&quot;git push&quot;의 출력은 사용 된 전송 방법에 따라 다릅니다. 이 섹션에서는 로컬 또는 ssh를 통해 Git 프로토콜을 푸시 할 때의 출력에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2012a50a7ce95c41c81b087cc42352c50e07741b" translate="yes" xml:space="preserve">
          <source>The output of ls-refs is as follows:</source>
          <target state="translated">ls-refs의 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9897264787fe814346af61567793268dae2ec95" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;range-diff&lt;/code&gt; command is subject to change. It is intended to be human-readable porcelain output, not something that can be used across versions of Git to get a textually stable &lt;code&gt;range-diff&lt;/code&gt; (as opposed to something like the &lt;code&gt;--stable&lt;/code&gt; option to &lt;a href=&quot;git-patch-id&quot;&gt;git-patch-id[1]&lt;/a&gt;). There&amp;rsquo;s also no equivalent of &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt; for &lt;code&gt;range-diff&lt;/code&gt;, the output is not intended to be machine-readable.</source>
          <target state="translated">&lt;code&gt;range-diff&lt;/code&gt; 명령 의 출력은 변경 될 수 있습니다. Git의 모든 버전에서 텍스트로 안정적인 &lt;code&gt;range-diff&lt;/code&gt; 를 얻는 데 사용할 수있는 것이 아니라 사람이 읽을 수있는 도자기 출력이되도록 고안되었습니다 ( &lt;a href=&quot;git-patch-id&quot;&gt;git-patch-id [-]에&lt;/a&gt; 대한 &lt;code&gt;--stable&lt;/code&gt; 옵션 과 반대 ) . &lt;code&gt;range-diff&lt;/code&gt; 에 대해 &lt;a href=&quot;git-apply&quot;&gt;git-apply [1]&lt;/a&gt; 에 해당하는 것도 없으며 , 출력은 기계 판독 가능하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="acccdb81223db3ebfe60a727e12d9a4ed87719fe" translate="yes" xml:space="preserve">
          <source>The output order is determined by the order of glob patterns in &amp;lt;orderfile&amp;gt;. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order.</source>
          <target state="translated">출력 순서는 &amp;lt;orderfile&amp;gt;의 glob 패턴 순서에 따라 결정됩니다. 첫 번째 패턴과 일치하는 경로 이름을 가진 모든 파일이 먼저 출력되고 두 번째 패턴과 일치하는 경로 이름을 가진 모든 파일 (첫 번째는 아님)이 다음에 출력됩니다. 패턴 끝에 일치하지 않는 경로 이름을 가진 모든 파일은 파일 끝에 암시 적 일치 패턴이있는 것처럼 마지막에 출력됩니다. 여러 경로 이름이 동일한 순위를 갖는 경우 (동일한 패턴과 일치하지만 이전 패턴은 일치하지 않음) 서로에 대한 출력 순서는 정상적인 순서입니다.</target>
        </trans-unit>
        <trans-unit id="70ec2e58d64c53608a589a3f892a41e430e23c0e" translate="yes" xml:space="preserve">
          <source>The overall time needed to compute this algorithm is the time needed to compute n+m commit diffs and then n*m diffs of patches, plus the time needed to compute the least-cost assignment between n and m diffs. Git uses an implementation of the Jonker-Volgenant algorithm to solve the assignment problem, which has cubic runtime complexity. The matching found in this case will look like this:</source>
          <target state="translated">이 알고리즘을 계산하는 데 필요한 전체 시간은 n + m 커밋 차이를 계산 한 다음 n * m 패치를 계산하는 데 필요한 시간과 n과 m 차이 사이의 최소 비용 할당을 계산하는 데 필요한 시간입니다. Git은 Jonker-Volgenant 알고리즘의 구현을 사용하여 3 차 런타임 복잡성을 갖는 할당 문제를 해결합니다. 이 경우에 일치하는 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8c05a901b25f6434301621f82a267dcb0caae54" translate="yes" xml:space="preserve">
          <source>The p4 changes will be created as the user invoking &lt;code&gt;git p4 submit&lt;/code&gt;. The &lt;code&gt;--preserve-user&lt;/code&gt; option will cause ownership to be modified according to the author of the Git commit. This option requires admin privileges in p4, which can be granted using &lt;code&gt;p4 protect&lt;/code&gt;.</source>
          <target state="translated">사용자가 &lt;code&gt;git p4 submit&lt;/code&gt; 를 호출하면 p4 변경 사항이 작성됩니다 . &lt;code&gt;--preserve-user&lt;/code&gt; 옵션은 커밋 망할 놈의 저자에 따라 소유권이 변경되는 원인이됩니다. 이 옵션은 &lt;code&gt;p4 protect&lt;/code&gt; 를 사용하여 부여 할 수있는 p4의 관리자 권한이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="bc53387773cbb38b899a330a03a788e5288eab48" translate="yes" xml:space="preserve">
          <source>The p4 client specification is maintained with the &lt;code&gt;p4 client&lt;/code&gt; command and contains among other fields, a View that specifies how the depot is mapped into the client repository. The &lt;code&gt;clone&lt;/code&gt; and &lt;code&gt;sync&lt;/code&gt; commands can consult the client spec when given the &lt;code&gt;--use-client-spec&lt;/code&gt; option or when the useClientSpec variable is true. After &lt;code&gt;git p4 clone&lt;/code&gt;, the useClientSpec variable is automatically set in the repository configuration file. This allows future &lt;code&gt;git p4 submit&lt;/code&gt; commands to work properly; the submit command looks only at the variable and does not have a command-line option.</source>
          <target state="translated">p4 클라이언트 스펙은 &lt;code&gt;p4 client&lt;/code&gt; 명령으로 유지 보수되며 , 저장소가 클라이언트 저장소에 맵핑되는 방법을 지정하는보기 인 다른 필드를 포함합니다. &lt;code&gt;clone&lt;/code&gt; 및 &lt;code&gt;sync&lt;/code&gt; 주어진 경우 명령은 클라이언트 사양을 참조 할 수 &lt;code&gt;--use-client-spec&lt;/code&gt; 옵션 또는 때 useClientSpec 변수가 true를. &lt;code&gt;git p4 clone&lt;/code&gt; 후에 는 useClientSpec 변수가 저장소 구성 파일에 자동으로 설정됩니다. 이것은 미래의 &lt;code&gt;git p4 submit&lt;/code&gt; 명령이 올바르게 작동 하도록 합니다. submit 명령은 변수 만보고 명령 행 옵션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9fec68b06723905b09b9270262e6a13c1b490876" translate="yes" xml:space="preserve">
          <source>The p4 depot path argument to &lt;code&gt;git p4 sync&lt;/code&gt; and &lt;code&gt;git p4 clone&lt;/code&gt; can be one or more space-separated p4 depot paths, with an optional p4 revision specifier on the end:</source>
          <target state="translated">&lt;code&gt;git p4 sync&lt;/code&gt; 및 &lt;code&gt;git p4 clone&lt;/code&gt; 에 대한 p4 저장소 경로 인수 는 선택적 p4 개정 지정자가 끝에있는 하나 이상의 공백으로 분리 된 p4 저장소 경로 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d877dea1de89fdb5a15efd47a5debfe5403b96f4" translate="yes" xml:space="preserve">
          <source>The pack-indexes (.idx files) remain in the pack directory so we can delete the MIDX file, set core.midx to false, or downgrade without any loss of information.</source>
          <target state="translated">팩 인덱스 (.idx 파일)는 팩 디렉토리에 남아 있으므로 MIDX 파일을 삭제하거나 core.midx를 false로 설정하거나 정보 손실없이 다운 그레이드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="933f30be1e83e4fe09dc8528b693f5b5a75f065d" translate="yes" xml:space="preserve">
          <source>The packed archive format (.pack) is designed to be self-contained so that it can be unpacked without any further information. Therefore, each object that a delta depends upon must be present within the pack.</source>
          <target state="translated">압축 아카이브 형식 (.pack)은 추가 정보없이 압축을 풀 수 있도록 자체 포함되도록 설계되었습니다. 따라서 델타가 의존하는 각 오브젝트는 팩 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="75cd7427877d4a48fded775aaaba114771e37304" translate="yes" xml:space="preserve">
          <source>The packfile(s) created by fast-import do not encourage good disk access patterns. This is caused by fast-import writing the data in the order it is received on standard input, while Git typically organizes data within packfiles to make the most recent (current tip) data appear before historical data. Git also clusters commits together, speeding up revision traversal through better cache locality.</source>
          <target state="translated">빠른 가져 오기로 작성된 팩 파일은 양호한 디스크 액세스 패턴을 권장하지 않습니다. 이는 표준 입력에서 수신 한 순서대로 데이터를 빠르게 가져 오기 때문에 발생합니다. Git은 일반적으로 가장 최근 (현재의 팁) 데이터가 기록 데이터 앞에 나타나도록 팩 파일 내에 데이터를 구성합니다. 또한 Git은 클러스터를 함께 커밋하여 더 나은 캐시 위치를 통해 개정 순회를 가속화합니다.</target>
        </trans-unit>
        <trans-unit id="73715b9a828b5f7ca9623cd366d376d487c8e126" translate="yes" xml:space="preserve">
          <source>The partial clone feature records special &quot;promisor&quot; packs that may point to objects that are not stored locally, but available on request to a server. The multi-pack-index does not currently track these promisor packs.</source>
          <target state="translated">부분 복제 기능은 로컬에 저장되지 않았지만 요청시 서버에 사용 가능한 개체를 가리킬 수있는 특수 &quot;프로 미저&quot;팩을 기록합니다. 다중 팩 인덱스는 현재 이러한 유망 팩을 추적하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="608e992a19f0287b5b2e4cbdc92416d882bd253c" translate="yes" xml:space="preserve">
          <source>The password to use when logging in to the server.</source>
          <target state="translated">서버에 로그인 할 때 사용할 비밀번호입니다.</target>
        </trans-unit>
        <trans-unit id="f899bc9ba76fee3c960f01f1f955c5a4bf020e98" translate="yes" xml:space="preserve">
          <source>The patch extracted from e-mail.</source>
          <target state="translated">전자 우편에서 추출한 패치입니다.</target>
        </trans-unit>
        <trans-unit id="621265bbad5d0651c63283720f8a5ccddfdeeb61" translate="yes" xml:space="preserve">
          <source>The patch is expected to be inline, directly following the message. Any line that is of the form:</source>
          <target state="translated">패치는 메시지 바로 다음에 인라인이 될 것으로 예상됩니다. 다음과 같은 형식의 라인 :</target>
        </trans-unit>
        <trans-unit id="eedf9ed2547b7a76bcd6fb69785bf954af8d224f" translate="yes" xml:space="preserve">
          <source>The patch itself does not apply cleanly. That is &lt;code&gt;bad&lt;/code&gt; but does not have much to do with your MUA. You might want to rebase the patch with &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; before regenerating it in this case.</source>
          <target state="translated">패치 자체는 깨끗하게 적용되지 않습니다. 그것은 &lt;code&gt;bad&lt;/code&gt; MUA와 관련이 없습니다. 이 경우 패치를 다시 생성하기 전에 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]로&lt;/a&gt; 패치를 리베이스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9ecbf09d9172bac5285d567a6e1031058a01024" translate="yes" xml:space="preserve">
          <source>The patch produced by &lt;code&gt;git format-patch&lt;/code&gt; is in UNIX mailbox format, with a fixed &quot;magic&quot; time stamp to indicate that the file is output from format-patch rather than a real mailbox, like so:</source>
          <target state="translated">&lt;code&gt;git format-patch&lt;/code&gt; 에 의해 생성 된 패치 는 UNIX 메일 박스 형식이며, 고정 된 &quot;마법의&quot;타임 스탬프는 다음과 같이 파일이 실제 메일 상자가 아닌 format-patch에서 출력됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7072603eb0a607d061c366f3e4a9cba6cffbd377" translate="yes" xml:space="preserve">
          <source>The path can be either absolute or relative. A relative path is taken as relative to the directory where the hooks are run (see the &quot;DESCRIPTION&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;).</source>
          <target state="translated">경로는 절대적이거나 상대적 일 수 있습니다. 상대 경로는 후크가 실행되는 디렉토리를 기준으로합니다 ( &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 의 &quot;DESCRIPTION&quot;섹션 참조 ).</target>
        </trans-unit>
        <trans-unit id="6ccace0f35f0f4e5cab0e8cffbdf924135579b2e" translate="yes" xml:space="preserve">
          <source>The path has the attribute with special value &quot;false&quot;; this is specified by listing the name of the attribute prefixed with a dash &lt;code&gt;-&lt;/code&gt; in the attribute list.</source>
          <target state="translated">경로에는 특수 값이 &quot;false&quot;인 속성이 있습니다. 이것은 대시로 시작하는 속성의 이름을 나열하여 지정 &lt;code&gt;-&lt;/code&gt; 속성리스트에 있습니다.</target>
        </trans-unit>
        <trans-unit id="96cc920a42ed7b296307f756480841c1366430ee" translate="yes" xml:space="preserve">
          <source>The path has the attribute with special value &quot;true&quot;; this is specified by listing only the name of the attribute in the attribute list.</source>
          <target state="translated">경로에는 특수 값 &quot;true&quot;를 갖는 속성이 있습니다. 이것은 속성 목록에 속성 이름 만 나열하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="f3d259c7dde8e69cba5e131da2dcac58054c5102" translate="yes" xml:space="preserve">
          <source>The path has the attribute with specified string value; this is specified by listing the name of the attribute followed by an equal sign &lt;code&gt;=&lt;/code&gt; and its value in the attribute list.</source>
          <target state="translated">경로에는 지정된 문자열 값을 가진 속성이 있습니다. 이것은 속성 이름과 등호 &lt;code&gt;=&lt;/code&gt; 및 속성 값을 속성 목록에 나열하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="9a89a340b481b20bfabef5b1bcb5482c1e173e57" translate="yes" xml:space="preserve">
          <source>The path to a list of object names (i.e. one unabbreviated SHA-1 per line) that are known to be broken in a non-fatal way and should be ignored. On versions of Git 2.20 and later comments (&lt;code&gt;#&lt;/code&gt;), empty lines, and any leading and trailing whitespace is ignored. Everything but a SHA-1 per line will error out on older versions.</source>
          <target state="translated">치명적이지 않은 방식으로 손상되어 무시되는 것으로 알려진 개체 이름 목록 (즉, 줄당 하나의 SHA-1)에 대한 경로입니다. Git 2.20 및 이후 버전의 주석 ( &lt;code&gt;#&lt;/code&gt; ), 빈 줄 및 선행 및 후행 공백은 무시됩니다. 라인 당 SHA-1을 제외한 모든 것은 이전 버전에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="66bacdcfb6546645ce51a1173beecea036fe198b" translate="yes" xml:space="preserve">
          <source>The path to higher software quality is significantly improved software testing.</source>
          <target state="translated">소프트웨어 품질 향상의 길은 소프트웨어 테스트를 크게 개선하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a62f8e77f19dbb91947274f4224d3b2000deceef" translate="yes" xml:space="preserve">
          <source>The path with which the credential will be used. E.g., for accessing a remote https repository, this will be the repository&amp;rsquo;s path on the server.</source>
          <target state="translated">신임 정보가 사용될 경로입니다. 예를 들어 원격 https 리포지토리에 액세스하려면 서버의 리포지토리 경로가됩니다.</target>
        </trans-unit>
        <trans-unit id="75a6542b84624c1ec2a2753cb02bac2dc12deb38" translate="yes" xml:space="preserve">
          <source>The path within the &amp;lt;repository&amp;gt; that the action is performed on, for those actions that require it.</source>
          <target state="translated">조치가 필요한 &amp;lt;repository&amp;gt; 내의 경로.</target>
        </trans-unit>
        <trans-unit id="42c5355b2496aa717e00373f3c96e2614e271309" translate="yes" xml:space="preserve">
          <source>The pathname of a file containing previously stored cookie lines, which should be used in the Git http session, if they match the server. The file format of the file to read cookies from should be plain HTTP headers or the Netscape/Mozilla cookie file format (see &lt;code&gt;curl(1)&lt;/code&gt;). NOTE that the file specified with http.cookieFile is used only as input unless http.saveCookies is set.</source>
          <target state="translated">이전에 저장된 쿠키 행을 포함하는 파일의 경로 이름으로, 서버와 일치하는 경우 Git http 세션에서 사용해야합니다. 쿠키를 읽을 파일의 파일 형식은 일반 HTTP 헤더 또는 Netscape / Mozilla 쿠키 파일 형식이어야합니다 ( &lt;code&gt;curl(1)&lt;/code&gt; 참조 ). http.cookieFile로 지정된 파일은 http.saveCookies가 설정되어 있지 않으면 입력으로 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7529cc524422963391df3cb62b329f757e09e898" translate="yes" xml:space="preserve">
          <source>The pathname of a file that stores a client certificate to use to authenticate with an HTTPS proxy. Can be overridden by the &lt;code&gt;GIT_PROXY_SSL_CERT&lt;/code&gt; environment variable.</source>
          <target state="translated">The pathname of a file that stores a client certificate to use to authenticate with an HTTPS proxy. Can be overridden by the &lt;code&gt;GIT_PROXY_SSL_CERT&lt;/code&gt; environment variable.</target>
        </trans-unit>
        <trans-unit id="5cd72157b1a828f8662a88c728954dfe8fd532c2" translate="yes" xml:space="preserve">
          <source>The pathname of a file that stores a private key to use to authenticate with an HTTPS proxy. Can be overridden by the &lt;code&gt;GIT_PROXY_SSL_KEY&lt;/code&gt; environment variable.</source>
          <target state="translated">The pathname of a file that stores a private key to use to authenticate with an HTTPS proxy. Can be overridden by the &lt;code&gt;GIT_PROXY_SSL_KEY&lt;/code&gt; environment variable.</target>
        </trans-unit>
        <trans-unit id="cdb891f79fbec881d22446bf8cf74ef0a3e451e0" translate="yes" xml:space="preserve">
          <source>The paths mentioned in the output, unlike many other Git commands, are made relative to the current directory if you are working in a subdirectory (this is on purpose, to help cutting and pasting). See the status.relativePaths config option below.</source>
          <target state="translated">다른 Git 명령과 달리 출력에 언급 된 경로는 하위 디렉토리에서 작업하는 경우 현재 디렉토리를 기준으로 만들어집니다 (절삭 및 붙여 넣기를 돕기위한 것임). 아래 status.relativePaths 구성 옵션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ae851010ea42ad696931dec57e7a58d6d0655b81" translate="yes" xml:space="preserve">
          <source>The pathspecs are used to limit the world diff operates in. They remove the filepairs outside the specified sets of pathnames. E.g. If the input set of filepairs included:</source>
          <target state="translated">pathspec은 월드 diff가 작동하는 것을 제한하는 데 사용됩니다. 지정된 pathname 세트 외부의 파일 쌍을 제거합니다. 예를 들어 입력 파일 세트 세트가 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="a35fe6e03b5cf8e686f61a60362e87d3cf937722" translate="yes" xml:space="preserve">
          <source>The pattern &quot;foo/*&quot;, matches &quot;foo/test.json&quot; (a regular file), &quot;foo/bar&quot; (a directory), but it does not match &quot;foo/bar/hello.c&quot; (a regular file), as the asterisk in the pattern does not match &quot;bar/hello.c&quot; which has a slash in it.</source>
          <target state="translated">&quot;foo / *&quot;패턴은 &quot;foo / test.json&quot;(일반 파일), &quot;foo / bar&quot;(디렉토리)와 일치하지만 &quot;foo / bar / hello.c&quot;(일반 파일)와 일치하지 않습니다 ), 패턴의 별표가 슬래시가있는 &quot;bar / hello.c&quot;와 일치하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="472a6ff8d8e6e0153adf76e5ad83f89df7215b9f" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;doc/frotz&lt;/code&gt; and &lt;code&gt;/doc/frotz&lt;/code&gt; have the same effect in any &lt;code&gt;.gitignore&lt;/code&gt; file. In other words, a leading slash is not relevant if there is already a middle slash in the pattern.</source>
          <target state="translated">패턴 &lt;code&gt;doc/frotz&lt;/code&gt; 및 &lt;code&gt;/doc/frotz&lt;/code&gt; 어떤에서 같은 효과가 &lt;code&gt;.gitignore&lt;/code&gt; 의 파일을. 즉, 패턴에 중간 슬래시가있는 경우 선행 슬래시는 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f3e3da749b8fed6cc11585c7aa5dbe77eee53ad" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;foo/&lt;/code&gt; will match a directory &lt;code&gt;foo&lt;/code&gt; and paths underneath it, but will not match a regular file or a symbolic link &lt;code&gt;foo&lt;/code&gt; (this is consistent with the way how pathspec works in general in Git)</source>
          <target state="translated">패턴 &lt;code&gt;foo/&lt;/code&gt; 는 디렉토리 &lt;code&gt;foo&lt;/code&gt; 및 그 아래의 경로와 일치하지만 일반 파일 또는 기호 링크 &lt;code&gt;foo&lt;/code&gt; 와 일치하지 않습니다 (이것은 경로 스펙이 Git에서 일반적으로 작동하는 방식과 일치합니다)</target>
        </trans-unit>
        <trans-unit id="32166ee916b00891724c1bd52223b5e1e2d10da0" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;hello.*&lt;/code&gt; matches any file or folder whose name begins with &lt;code&gt;hello&lt;/code&gt;. If one wants to restrict this only to the directory and not in its subdirectories, one can prepend the pattern with a slash, i.e. &lt;code&gt;/hello.*&lt;/code&gt;; the pattern now matches &lt;code&gt;hello.txt&lt;/code&gt;, &lt;code&gt;hello.c&lt;/code&gt; but not &lt;code&gt;a/hello.java&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hello.*&lt;/code&gt; 패턴 은 이름이 &lt;code&gt;hello&lt;/code&gt; 로 시작하는 파일 또는 폴더와 일치합니다 . 서브 디렉토리가 아닌 디렉토리로만 제한하려는 경우 슬래시 (예 : &lt;code&gt;/hello.*&lt;/code&gt; )를 사용 하여 패턴을 추가 할 수 있습니다 . 패턴은 이제 &lt;code&gt;hello.txt&lt;/code&gt; , &lt;code&gt;hello.c&lt;/code&gt; 와 일치 하지만 &lt;code&gt;a/hello.java&lt;/code&gt; 와는 일치 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b35cb663783a3682a66157f3dc9fd508efdfceba" translate="yes" xml:space="preserve">
          <source>The pattern can contain standard globbing wildcards and two additional ones, &lt;code&gt;**/&lt;/code&gt; and &lt;code&gt;/**&lt;/code&gt;, that can match multiple path components. Please refer to &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt; for details. For convenience:</source>
          <target state="translated">이 패턴에는 표준 경로 지정 와일드 카드와 여러 경로 구성 요소와 일치 할 수있는 두 개의 추가 &lt;code&gt;**/&lt;/code&gt; 및 &lt;code&gt;/**&lt;/code&gt; 가 포함될 수 있습니다 . 자세한 내용은 &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; 를 참조하십시오. 편의상:</target>
        </trans-unit>
        <trans-unit id="ae88d32c3f9079756948f2fdc8ae4c4c2e834b93" translate="yes" xml:space="preserve">
          <source>The patterns given should not begin with &lt;code&gt;refs/heads&lt;/code&gt;, &lt;code&gt;refs/tags&lt;/code&gt;, or &lt;code&gt;refs/remotes&lt;/code&gt; when applied to &lt;code&gt;--branches&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt;, or &lt;code&gt;--remotes&lt;/code&gt;, respectively, and they must begin with &lt;code&gt;refs/&lt;/code&gt; when applied to &lt;code&gt;--glob&lt;/code&gt; or &lt;code&gt;--all&lt;/code&gt;. If a trailing &lt;code&gt;/*&lt;/code&gt; is intended, it must be given explicitly.</source>
          <target state="translated">로 시작하지 않아야 주어진 패턴 &lt;code&gt;refs/heads&lt;/code&gt; , &lt;code&gt;refs/tags&lt;/code&gt; , 또는 &lt;code&gt;refs/remotes&lt;/code&gt; 에 적용 할 때 &lt;code&gt;--branches&lt;/code&gt; 는 , &lt;code&gt;--tags&lt;/code&gt; , 또는 &lt;code&gt;--remotes&lt;/code&gt; 는 각각, 그들은 시작해야 &lt;code&gt;refs/&lt;/code&gt; 에 적용 할 때 &lt;code&gt;--glob&lt;/code&gt; 또는 &lt;code&gt;--all&lt;/code&gt; . 후행 &lt;code&gt;/*&lt;/code&gt; 가 의도 된 경우 명시 적으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="86b0de7f6b1176e8c07c5aaa523447c3abd4915b" translate="yes" xml:space="preserve">
          <source>The performance format target (PERF) is a column-based format to replace GIT_TRACE_PERFORMANCE and is suitable for development and testing, possibly to complement tools like gprof. This format is enabled with the &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; environment variable or the &lt;code&gt;trace2.perfTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">PERF (Performance Format Target)는 GIT_TRACE_PERFORMANCE를 대체하는 열 기반 형식이며 개발 및 테스트에 적합하며 gprof와 같은 도구를 보완 할 수 있습니다. 이 형식은 &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; 환경 변수 또는 &lt;code&gt;trace2.perfTarget&lt;/code&gt; 시스템 또는 글로벌 구성 설정으로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="506071bbd9d0908b14e8f015ca1b0ff23e4ec21e" translate="yes" xml:space="preserve">
          <source>The performance of git-filter-branch is glacially slow; its design makes it impossible for a backward-compatible implementation to ever be fast:</source>
          <target state="translated">git-filter-branch의 성능은 빙하 적으로 느립니다. 그것의 디자인은 이전 버전과 호환되는 구현이 빠를 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d698b970e30734158c98cc5647b57a259a47bb36" translate="yes" xml:space="preserve">
          <source>The person who put a piece of code into Git.</source>
          <target state="translated">코드 조각을 Git에 넣은 사람.</target>
        </trans-unit>
        <trans-unit id="81b84527afb0ae2e697e75bbd7638af25fa12741" translate="yes" xml:space="preserve">
          <source>The pickaxe search is described in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; (the description of &lt;code&gt;-S&amp;lt;string&amp;gt;&lt;/code&gt; option, which refers to pickaxe entry in &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore[7]&lt;/a&gt; for more details).</source>
          <target state="translated">곡괭이 검색은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; ( 자세한 내용 은 &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore [7]의&lt;/a&gt; 곡괭이 항목을 나타내는 &lt;code&gt;-S&amp;lt;string&amp;gt;&lt;/code&gt; 옵션에 대한 설명)에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="525e6a0e6ee3d9fa31ab39c46532aa0c693111e1" translate="yes" xml:space="preserve">
          <source>The placeholders are:</source>
          <target state="translated">자리 표시자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1651136b42ed906ec527c0b5bb6ead2e015774c3" translate="yes" xml:space="preserve">
          <source>The point of this helper is to reduce the number of times you must type your username or password. For example:</source>
          <target state="translated">이 도우미의 요점은 사용자 이름이나 암호를 입력해야하는 횟수를 줄이는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c89cea9d29e269d3d21a2bb103d39e43b1e539d2" translate="yes" xml:space="preserve">
          <source>The porcelain format</source>
          <target state="translated">도자기 형식</target>
        </trans-unit>
        <trans-unit id="26e08a1995b67cc0010521ba6bed170106483645" translate="yes" xml:space="preserve">
          <source>The porcelain format generally suppresses commit information that has already been seen. For example, two lines that are blamed to the same commit will both be shown, but the details for that commit will be shown only once. This is more efficient, but may require more state be kept by the reader. The &lt;code&gt;--line-porcelain&lt;/code&gt; option can be used to output full commit information for each line, allowing simpler (but less efficient) usage like:</source>
          <target state="translated">도자기 형식은 일반적으로 이미 본 커밋 정보를 억제합니다. 예를 들어, 동일한 커밋으로 비난 된 두 줄이 모두 표시되지만 해당 커밋에 대한 세부 정보는 한 번만 표시됩니다. 이것은 더 효율적이지만 독자가 더 많은 상태를 유지해야 할 수도 있습니다. &lt;code&gt;--line-porcelain&lt;/code&gt; 옵션은 전체 같은 간단한 (하지만 비효율적) 사용을 허용, 각 라인에 대한 정보를 커밋 출력에 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="20c54b7279b5d1b2be6928d44083be1fd00dfbb8" translate="yes" xml:space="preserve">
          <source>The porcelain format has a line per attribute. Attributes are listed with a label and value separated by a single space. Boolean attributes (like &lt;code&gt;bare&lt;/code&gt; and &lt;code&gt;detached&lt;/code&gt;) are listed as a label only, and are only present if and only if the value is true. The first attribute of a worktree is always &lt;code&gt;worktree&lt;/code&gt;, an empty line indicates the end of the record. For example:</source>
          <target state="translated">도자기 형식에는 속성 당 한 줄이 있습니다. 속성은 레이블과 값이 단일 공백으로 구분되어 나열됩니다. 부울 속성 ( &lt;code&gt;bare&lt;/code&gt; 및 &lt;code&gt;detached&lt;/code&gt; 등 )은 레이블로만 나열되며 값이 true 인 경우에만 나타납니다. 작업 트리의 첫 번째 속성은 항상 &lt;code&gt;worktree&lt;/code&gt; 이며 빈 줄은 레코드의 끝을 나타냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d78141a7bccc3a1873780a422f8d41a19ce92e1b" translate="yes" xml:space="preserve">
          <source>The porcelain format has a line per attribute. Attributes are listed with a label and value separated by a single space. Boolean attributes (like &lt;code&gt;bare&lt;/code&gt; and &lt;code&gt;detached&lt;/code&gt;) are listed as a label only, and are present only if the value is true. The first attribute of a working tree is always &lt;code&gt;worktree&lt;/code&gt;, an empty line indicates the end of the record. For example:</source>
          <target state="translated">The porcelain format has a line per attribute. Attributes are listed with a label and value separated by a single space. Boolean attributes (like &lt;code&gt;bare&lt;/code&gt; and &lt;code&gt;detached&lt;/code&gt; ) are listed as a label only, and are present only if the value is true. The first attribute of a working tree is always &lt;code&gt;worktree&lt;/code&gt; , an empty line indicates the end of the record. For example:</target>
        </trans-unit>
        <trans-unit id="a362940b066b853917862099c8e9ab263cba72b1" translate="yes" xml:space="preserve">
          <source>The port number to bind the gitweb httpd to. See &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;.</source>
          <target state="translated">gitweb httpd를 바인딩 할 포트 번호. &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cecf31c324042fa16f4839249194885b3982bae" translate="yes" xml:space="preserve">
          <source>The port number to bind the httpd to. (Default: 1234)</source>
          <target state="translated">httpd를 바인딩 할 포트 번호입니다. (기본값 : 1234)</target>
        </trans-unit>
        <trans-unit id="735bfd35b5b101e4c116696c3cd1ebf6bc58faa9" translate="yes" xml:space="preserve">
          <source>The possible options are:</source>
          <target state="translated">가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8bc0e360ec6eefb74bc5a1aed65f13e846b6d915" translate="yes" xml:space="preserve">
          <source>The preferred strategy for rolling out a version bump (whether whole repository or for a single file) is to teach git to read the new format, and allow writing the new format with a config switch or command line option (for experimentation or for those who do not care about backwards compatibility with older gits). Then after a long period to allow the reading capability to become common, we may switch to writing the new format by default.</source>
          <target state="translated">버전 범프 (전체 저장소 또는 단일 파일에 관계없이)를 롤아웃하는 데 선호되는 전략은 git에게 새 형식을 읽도록 설정하고 구성 스위치 또는 명령 줄 옵션으로 실험 또는 이전 gits와의 하위 호환성에 대해서는 신경 쓰지 마십시오. 그런 다음 읽기 기능이 일반화되도록 오랜 시간이 지난 후 기본적으로 새 형식 쓰기로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adf8f6f66c16d1ab5dcd5c39342b75931e439ba4" translate="yes" xml:space="preserve">
          <source>The prefix ability basically makes it trivial to use &lt;code&gt;git checkout-index&lt;/code&gt; as an &quot;export as tree&quot; function. Just read the desired tree into the index, and do:</source>
          <target state="translated">접두사 기능은 기본적으로 &lt;code&gt;git checkout-index&lt;/code&gt; 를 &quot;트리로 내보내기&quot;기능 으로 사용하는 것이 간단 합니다. 원하는 트리를 인덱스로 읽고 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0f1fc4f35ab6b79f4468bd7525c0542dc9193da5" translate="yes" xml:space="preserve">
          <source>The previously introduced &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; is just a wrapper for &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">이전에 소개 된 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 은 &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt; 의 래퍼 일뿐 입니다.</target>
        </trans-unit>
        <trans-unit id="675ae216ecd575fef2e1ffa9eadeda52bdab6e90" translate="yes" xml:space="preserve">
          <source>The primary problem with rewriting the history of a branch has to do with merging. Suppose somebody fetches your branch and merges it into their branch, with a result something like this:</source>
          <target state="translated">브랜치 히스토리를 재 작성할 때의 주요 문제점은 병합과 관련이 있습니다. 누군가가 분기를 가져 와서 분기로 병합한다고 가정하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ff3dc4a94f1f540e3dd725f6eef6c2d405d85a87" translate="yes" xml:space="preserve">
          <source>The primary tool we&amp;rsquo;ve been using to create commits is &lt;code&gt;git-commit
-a&lt;/code&gt;, which creates a commit including every change you&amp;rsquo;ve made to your working tree. But what if you want to commit changes only to certain files? Or only certain changes to certain files?</source>
          <target state="translated">커밋을 만드는 데 사용했던 기본 도구는 &lt;code&gt;git-commit -a&lt;/code&gt; 이며 작업 트리에 대한 모든 변경 사항을 포함하여 커밋을 만듭니다. 그러나 특정 파일에만 변경 사항을 커밋하려면 어떻게해야합니까? 아니면 특정 파일에 대한 특정 변경 사항 만 있습니까?</target>
        </trans-unit>
        <trans-unit id="bc32172ebad82b3a8531284b76fc91d0e2655fc8" translate="yes" xml:space="preserve">
          <source>The protection it offers over &lt;code&gt;--force&lt;/code&gt; is ensuring that subsequent changes your work wasn&amp;rsquo;t based on aren&amp;rsquo;t clobbered, but this is trivially defeated if some background process is updating refs in the background. We don&amp;rsquo;t have anything except the remote tracking info to go by as a heuristic for refs you&amp;rsquo;re expected to have seen &amp;amp; are willing to clobber.</source>
          <target state="translated">그것이 &lt;code&gt;--force&lt;/code&gt; 로 제공하는 보호는 작업이 기반으로하지 않은 후속 변경 사항이 방해받지 않도록 보장하지만 일부 백그라운드 프로세스가 백그라운드에서 참조를 업데이트하면 사소하게 무시됩니다. 원격 추적 정보 이외의 다른 정보는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c8ef7004934ae749808b9e22322b2c11275f98e4" translate="yes" xml:space="preserve">
          <source>The protocol names currently used by git are:</source>
          <target state="translated">현재 git에서 사용되는 프로토콜 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="19913c2c5a680884fd5ab271ea84dfe92e10bf53" translate="yes" xml:space="preserve">
          <source>The protocol over which the credential will be used (e.g., &lt;code&gt;https&lt;/code&gt;).</source>
          <target state="translated">신임 정보가 사용될 프로토콜 (예 : &lt;code&gt;https&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="27c53e4d1c63b3496c93b1976851fe0522937712" translate="yes" xml:space="preserve">
          <source>The provided options must not contain a NUL or LF character.</source>
          <target state="translated">제공된 옵션에는 NUL 또는 LF 문자가 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="5fb1f43ddd5fc4b8ac18d086f82e6f88c9ed5855" translate="yes" xml:space="preserve">
          <source>The purpose of gitignore files is to ensure that certain files not tracked by Git remain untracked.</source>
          <target state="translated">gitignore 파일의 목적은 Git이 추적하지 않는 특정 파일이 추적되지 않도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a2b9675d20ab3c1e80e15b296d660914f6ea2131" translate="yes" xml:space="preserve">
          <source>The purpose of the hook is to edit the message file in place, and it is not suppressed by the &lt;code&gt;--no-verify&lt;/code&gt; option. A non-zero exit means a failure of the hook and aborts the commit. It should not be used as replacement for pre-commit hook.</source>
          <target state="translated">후크의 목적은 메시지 파일을 제자리에서 편집하는 것이며 &lt;code&gt;--no-verify&lt;/code&gt; 옵션으로 억제되지 않습니다 . 0이 아닌 종료는 후크 실패를 의미하며 커밋을 중단합니다. 사전 커미트 후크를 대체하는 데 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="96e3995f595001b3f723f5fc30a3546a03e6b50b" translate="yes" xml:space="preserve">
          <source>The purpose of the hook is to edit the message file in place, and it is not supressed by the &lt;code&gt;--no-verify&lt;/code&gt; option. This hook is called even if &lt;code&gt;--prepare-p4-only&lt;/code&gt; is set.</source>
          <target state="translated">The purpose of the hook is to edit the message file in place, and it is not supressed by the &lt;code&gt;--no-verify&lt;/code&gt; option. This hook is called even if &lt;code&gt;--prepare-p4-only&lt;/code&gt; is set.</target>
        </trans-unit>
        <trans-unit id="383a661ab7ffdec395082f1f22f245f53263885b" translate="yes" xml:space="preserve">
          <source>The push URL of a remote repository. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">원격 저장소의 푸시 URL입니다. &lt;a href=&quot;git-push&quot;&gt;git-push [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8cd29a2b80ae7f4721c7a9c69324052af609357" translate="yes" xml:space="preserve">
          <source>The push done by the other person updated the branch that used to point at commit X to point at commit A. It is a fast-forward.</source>
          <target state="translated">다른 사람이 한 푸시는 커밋 X가 커밋 A를 가리 키도록 사용했던 브랜치를 업데이트했습니다.</target>
        </trans-unit>
        <trans-unit id="79a20eedac198c71849aef6d1fe1606ea1ee319f" translate="yes" xml:space="preserve">
          <source>The quilt series file.</source>
          <target state="translated">이불 시리즈 파일.</target>
        </trans-unit>
        <trans-unit id="eb2f9ed5ec284eab8396a9b582f3da5582d364ca" translate="yes" xml:space="preserve">
          <source>The raw output format from &quot;git-diff-index&quot;, &quot;git-diff-tree&quot;, &quot;git-diff-files&quot; and &quot;git diff --raw&quot; are very similar.</source>
          <target state="translated">&quot;git-diff-index&quot;, &quot;git-diff-tree&quot;, &quot;git-diff-files&quot;및 &quot;git diff --raw&quot;의 원시 출력 형식은 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="a6ab1028c44c2d54846a9217b4a7ad959d178f38" translate="yes" xml:space="preserve">
          <source>The reachability bitmap is currently paired directly with a single packfile, using the pack-order as the object order to hopefully compress the bitmaps well using run-length encoding. This could be extended to pair a reachability bitmap with a multi-pack-index. If the multi-pack-index is extended to store a &quot;stable object order&quot; (a function Order(hash) = integer that is constant for a given hash, even as the multi-pack-index is updated) then a reachability bitmap could point to a multi-pack-index and be updated independently.</source>
          <target state="translated">도달 가능성 비트 맵은 현재 실행 순서 인코딩을 사용하여 비트 맵을 잘 압축하기 위해 팩 순서를 객체 순서로 사용하여 단일 팩 파일과 직접 쌍을 이룹니다. 도달 가능성 비트 맵을 다중 팩 인덱스와 쌍으로 확장 할 수 있습니다. 멀티 팩 인덱스가 &quot;안정된 객체 순서&quot;(멀티 팩 인덱스가 업데이트 되더라도 주어진 해시에 대해 상수 인 함수 Order (hash) = 정수)를 저장하도록 확장되면 도달 가능성 비트 맵은 멀티 팩 인덱스를 가리키고 독립적으로 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="0aca04dff2f76e52dde4dcdd1542bfe4e1470100" translate="yes" xml:space="preserve">
          <source>The reason fast-import uses &lt;code&gt;:&lt;/code&gt; to denote a mark reference is this character is not legal in a Git branch name. The leading &lt;code&gt;:&lt;/code&gt; makes it easy to distinguish between the mark 42 (&lt;code&gt;:42&lt;/code&gt;) and the branch 42 (&lt;code&gt;42&lt;/code&gt; or &lt;code&gt;refs/heads/42&lt;/code&gt;), or an abbreviated SHA-1 which happened to consist only of base-10 digits.</source>
          <target state="translated">빠른 가져 오기가 &lt;code&gt;:&lt;/code&gt; 를 사용하여 마크 참조를 표시하는 이유 는이 문자가 Git 브랜치 이름에 적합하지 않기 때문입니다. 선행 &lt;code&gt;:&lt;/code&gt; 마크 42 ( &lt;code&gt;:42&lt;/code&gt; )와 분기 42 ( &lt;code&gt;42&lt;/code&gt; 또는 &lt;code&gt;refs/heads/42&lt;/code&gt; ) 또는 10 진수만으로 구성된 약어 SHA-1을 쉽게 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1aba410e8fcfe74102eea2fcf73898889acee3ed" translate="yes" xml:space="preserve">
          <source>The reason it doesn&amp;rsquo;t error out when provided without &lt;code&gt;--prune&lt;/code&gt; or its config versions is for flexibility of the configured versions, and to maintain a 1=1 mapping between what the command line flags do, and what the configuration versions do.</source>
          <target state="translated">&lt;code&gt;--prune&lt;/code&gt; 또는 구성 버전 없이 제공 될 때 오류가 발생하지 않는 이유 는 구성된 버전의 유연성과 명령 줄 플래그의 기능과 구성 버전의 기능간에 1 = 1 매핑을 유지하기 위함 입니다.</target>
        </trans-unit>
        <trans-unit id="b2defd752d90b2a93e28eb3efe0e516f3fc264fc" translate="yes" xml:space="preserve">
          <source>The rebase will stop where &lt;code&gt;pick&lt;/code&gt; has been replaced with &lt;code&gt;edit&lt;/code&gt; or when a step in the list fails to mechanically resolve conflicts and needs your help. When you are done editing and/or resolving conflicts you can continue with &lt;code&gt;git rebase --continue&lt;/code&gt;. If you decide that things are getting too hairy, you can always bail out with &lt;code&gt;git rebase
--abort&lt;/code&gt;. Even after the rebase is complete, you can still recover the original branch by using the &lt;a href=&quot;#reflogs&quot;&gt;reflog&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pick&lt;/code&gt; 이 &lt;code&gt;edit&lt;/code&gt; 으로 대체 되거나 목록의 단계가 충돌을 기계적으로 해결하지 못해 도움이 필요한 경우 rebase가 중지됩니다 . 충돌 편집 및 / 또는 해결이 끝나면 &lt;code&gt;git rebase --continue&lt;/code&gt; 를 계속할 수 있습니다 . 물건이 너무 털이 있다고 결정하면 언제든지 &lt;code&gt;git rebase --abort&lt;/code&gt; 구제 할 수 있습니다 . 리베이스가 완료된 후에도 &lt;a href=&quot;#reflogs&quot;&gt;reflog&lt;/a&gt; 를 사용하여 원래 분기를 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="939cf091c711a461fc7775d9278b48a4457f30c1" translate="yes" xml:space="preserve">
          <source>The ref namespace is hierarchical. Different subhierarchies are used for different purposes (e.g. the &lt;code&gt;refs/heads/&lt;/code&gt; hierarchy is used to represent local branches).</source>
          <target state="translated">ref 네임 스페이스는 계층 적입니다. 서로 다른 하위 계층이 서로 다른 목적으로 사용됩니다 (예 : 참조 &lt;code&gt;refs/heads/&lt;/code&gt; 계층이 로컬 분기를 나타내는 데 사용됨).</target>
        </trans-unit>
        <trans-unit id="d11d2f57237e560f1ae2f7da112ae694568b2d78" translate="yes" xml:space="preserve">
          <source>The ref which the given symbolic ref refers to. If not a symbolic ref, nothing is printed. Respects the &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt; and &lt;code&gt;:rstrip&lt;/code&gt; options in the same way as &lt;code&gt;refname&lt;/code&gt; above.</source>
          <target state="translated">주어진 기호 참조가 참조하는 참조. 기호 참조가 아닌 경우 아무것도 인쇄되지 않습니다. 위의 &lt;code&gt;refname&lt;/code&gt; 과 같은 방식으로 &lt;code&gt;:short&lt;/code&gt; , &lt;code&gt;:lstrip&lt;/code&gt; 및 &lt;code&gt;:rstrip&lt;/code&gt; 옵션을 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="09256802b46aa557905f47df9fc0a1148d341199" translate="yes" xml:space="preserve">
          <source>The reflogs are kept by default for 30 days, after which they may be pruned. See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt; and &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; to learn how to control this pruning, and see the &quot;SPECIFYING REVISIONS&quot; section of &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; for details.</source>
          <target state="translated">reflog는 기본적으로 30 일 동안 유지되며 그 후에 정리 될 수 있습니다. 참조 &lt;a href=&quot;git-reflog&quot;&gt;자식-reflog [1]&lt;/a&gt; 와 &lt;a href=&quot;git-gc&quot;&gt;자식-GC [1]&lt;/a&gt; 의 &quot;개정 이력을 지정하기&quot;섹션이 가지 치기를 제어하고 참조하는 방법을 배울 수 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 세부 사항을.</target>
        </trans-unit>
        <trans-unit id="29e87ce112fa8f38582e71025c0e3c162626939f" translate="yes" xml:space="preserve">
          <source>The refname parameter is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 arguments are the object names for the refname before and after the update. Note that the hook is called before the refname is updated, so either sha1-old is 0{40} (meaning there is no such ref yet), or it should match what is recorded in refname.</source>
          <target state="translated">refname 매개 변수는 $ GIT_DIR에 상대적입니다. 예를 들어 마스터 헤드의 경우 &quot;refs / heads / master&quot;입니다. 두 sha1 인수는 업데이트 전후의 참조 이름에 대한 객체 이름입니다. 참조 이름이 업데이트되기 전에 후크가 호출되므로 sha1-old는 0 {40} (아직 그러한 참조가 없음을 의미 함)이거나 참조 이름에 기록 된 것과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="21810fe3549bedbdcfb85519d93701f4c1ec8042" translate="yes" xml:space="preserve">
          <source>The refname value is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 values before each refname are the object names for the refname before and after the update. Refs that were created will have sha1-old equal to 0{40}, while refs that were deleted will have sha1-new equal to 0{40}, otherwise sha1-old and sha1-new should be valid objects in the repository.</source>
          <target state="translated">참조 이름 값은 $ GIT_DIR에 상대적입니다. 예를 들어 마스터 헤드의 경우 &quot;refs / heads / master&quot;입니다. 각 참조 이름 앞의 두 sha1 값은 업데이트 전후의 참조 이름에 대한 객체 이름입니다. 작성된 참조는 sha1이 0 {40}이고, 삭제 된 참조는 sha1이 0 {40}과 같으며, 그렇지 않으면 sha1-old 및 sha1new는 저장소에서 유효한 오브젝트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="f7cd6bb7198b77eda24e90f3bdabb1a4fb56aeb0" translate="yes" xml:space="preserve">
          <source>The refname value is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 values before each refname are the object names for the refname before and after the update. Refs to be created will have sha1-old equal to 0{40}, while refs to be deleted will have sha1-new equal to 0{40}, otherwise sha1-old and sha1-new should be valid objects in the repository.</source>
          <target state="translated">참조 이름 값은 $ GIT_DIR에 상대적입니다. 예를 들어 마스터 헤드의 경우 &quot;refs / heads / master&quot;입니다. 각 참조 이름 앞의 두 sha1 값은 업데이트 전후의 참조 이름에 대한 객체 이름입니다. 생성 된 참조는 sha1-old는 0 {40}이고, 삭제 될 참조는 sha1-new는 0 {40}입니다. 그렇지 않으면 sha1-old 및 sha1-new는 리포지토리에서 유효한 객체 여야합니다.</target>
        </trans-unit>
        <trans-unit id="efb922792d6081ee214f4a8e1d665108721507f6" translate="yes" xml:space="preserve">
          <source>The refs are using the given hash algorithm. This keyword is only used if the server and client both support the object-format extension.</source>
          <target state="translated">The refs are using the given hash algorithm. This keyword is only used if the server and client both support the object-format extension.</target>
        </trans-unit>
        <trans-unit id="ce26e3499eea5a4c24942a8e072b3a9539557d0b" translate="yes" xml:space="preserve">
          <source>The regex can also be set via a diff driver or configuration option, see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; or &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;. Giving it explicitly overrides any diff driver or configuration setting. Diff drivers override configuration settings.</source>
          <target state="translated">정규식은 diff 드라이버 또는 구성 옵션을 통해 설정할 수도 있습니다 ( &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 또는 &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조)&lt;/a&gt; . 이를 제공하면 diff 드라이버 또는 구성 설정이 명시 적으로 무시됩니다. Diff 드라이버는 구성 설정보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="db9cbae31eee7dd0453a2f75d2431a49c7ce5a43" translate="yes" xml:space="preserve">
          <source>The regex must capture the source branch name in $1.</source>
          <target state="translated">정규식은 소스 분기 이름을 $ 1로 캡처해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f22e3781909efae9d373f9fa46942441b8a264c" translate="yes" xml:space="preserve">
          <source>The regular expression that the diff driver should use to recognize the hunk header. A built-in pattern may also be used. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">diff 드라이버가 덩어리 헤더를 인식하는 데 사용해야하는 정규식입니다. 내장 패턴을 사용할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4211f7342bdc098f581fc9d7939f84dc24cd9689" translate="yes" xml:space="preserve">
          <source>The regular expression that the diff driver should use to split words in a line. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">diff 드라이버가 단어를 한 줄로 나눌 때 사용해야하는 정규식입니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aa527c60a8440b01958ab1ade21254172db5c938" translate="yes" xml:space="preserve">
          <source>The remainder of the commit or the tag message that follows the &quot;subject&quot;.</source>
          <target state="translated">The remainder of the commit or the tag message that follows the &quot;subject&quot;.</target>
        </trans-unit>
        <trans-unit id="f0619f2eb83a7faf485cba23bd4bbef8fb0cb4dd" translate="yes" xml:space="preserve">
          <source>The remainder of the line, after stripping the spaces, is used as the help associated to the option.</source>
          <target state="translated">공백을 제거한 후 나머지 줄은 옵션과 관련된 도움말로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="19c5350e9da63f63a8abbccc7168a03dfd13ebac" translate="yes" xml:space="preserve">
          <source>The remaining features cannot be overridden on a per project basis.</source>
          <target state="translated">나머지 기능은 프로젝트별로 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="303228bfc99fc67a561e0782dc3e0ceb08c259bb" translate="yes" xml:space="preserve">
          <source>The remote branch name for a submodule, used by &lt;code&gt;git submodule
update --remote&lt;/code&gt;. Set this option to override the value found in the &lt;code&gt;.gitmodules&lt;/code&gt; file. See &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;git submodule update --remote&lt;/code&gt; 의해 사용되는 서브 모듈의 원격 브랜치 이름 . &lt;code&gt;.gitmodules&lt;/code&gt; 파일 에있는 값을 무시하려면이 옵션을 설정 하십시오. 자세한 내용은 &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; 및 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4fdf928f1cd746e7574e5e26895f63052b9e3300" translate="yes" xml:space="preserve">
          <source>The remote configuration is achieved using the &lt;code&gt;remote.origin.url&lt;/code&gt; and &lt;code&gt;remote.origin.fetch&lt;/code&gt; configuration variables. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">원격 구성은 &lt;code&gt;remote.origin.url&lt;/code&gt; 및 &lt;code&gt;remote.origin.fetch&lt;/code&gt; 구성 변수를 사용하여 수행됩니다 . ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e7b65b070cfabceee72964f903404025034f8258" translate="yes" xml:space="preserve">
          <source>The remote end did not report the successful update of the ref, perhaps because of a temporary error on the remote side, a break in the network connection, or other transient error.</source>
          <target state="translated">원격 측에서 원격 측의 일시적인 오류, 네트워크 연결 끊기 또는 기타 일시적인 오류로 인해 참조의 성공적인 업데이트를보고하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="53c927a78ca0c11dc61a2c100f0e02c446d49374" translate="yes" xml:space="preserve">
          <source>The remote end refused the update. Usually caused by a hook on the remote side, or because the remote repository has one of the following safety options in effect: &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; (for pushes to the checked out branch), &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; (for forced non-fast-forward updates), &lt;code&gt;receive.denyDeletes&lt;/code&gt; or &lt;code&gt;receive.denyDeleteCurrent&lt;/code&gt;. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">원격 끝이 업데이트를 거부했습니다. 일반적으로 원격 측의 후크로 인해 발생하거나 원격 저장소에 다음 안전 옵션 중 하나가 적용되어 있기 때문에 발생합니다. &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; (체크 아웃 된 분기로 푸시), &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; (비 빨리 감기 강제 업데이트의 경우) ), &lt;code&gt;receive.denyDeletes&lt;/code&gt; 또는 &lt;code&gt;receive.denyDeleteCurrent&lt;/code&gt; 입니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9422d899b3eadda77c8387091e37d96facb6c2f" translate="yes" xml:space="preserve">
          <source>The remote heads to update from. This is relative to $GIT_DIR (e.g. &quot;HEAD&quot;, &quot;refs/heads/master&quot;). When unspecified, update from all heads the remote side has.</source>
          <target state="translated">업데이트 할 원격 헤드 이는 $ GIT_DIR과 관련이 있습니다 (예 : &quot;HEAD&quot;, &quot;refs / heads / master&quot;). 지정되지 않은 경우 원격 측에있는 모든 헤드에서 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="0419c5b470511fe246bdc207ab1f44978b5929c7" translate="yes" xml:space="preserve">
          <source>The remote hostname for a network credential.</source>
          <target state="translated">네트워크 자격 증명의 원격 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2acecc1c91d3ba6caf56ecf7245b62c949c434da" translate="yes" xml:space="preserve">
          <source>The remote hostname for a network credential. This includes the port number if one was specified (e.g., &quot;example.com:8088&quot;).</source>
          <target state="translated">The remote hostname for a network credential. This includes the port number if one was specified (e.g., &quot;example.com:8088&quot;).</target>
        </trans-unit>
        <trans-unit id="a7632b9807699f7e6cd146f3dd66e0428b068933" translate="yes" xml:space="preserve">
          <source>The remote ref that matches &amp;lt;src&amp;gt; is fetched, and if &amp;lt;dst&amp;gt; is not an empty string, an attempt is made to update the local ref that matches it.</source>
          <target state="translated">&amp;lt;src&amp;gt;와 일치하는 원격 참조가 페치되고 &amp;lt;dst&amp;gt;가 빈 문자열이 아닌 경우 일치하는 로컬 참조를 업데이트하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="282ef7eedc5a5bdee9740e04ed8375ea205f3da3" translate="yes" xml:space="preserve">
          <source>The remote refs to update.</source>
          <target state="translated">원격은 업데이트를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="1126548b6dd0a73d0e4b3cf8a47f765ced5296ec" translate="yes" xml:space="preserve">
          <source>The remote to push to by default. Overrides &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; for all branches, and is overridden by &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; for specific branches.</source>
          <target state="translated">기본적으로 푸시 할 리모콘입니다. 오버라이드 (override) &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 모든 지점에 대한, 그리고에 의해 무시되는 &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; 특정 지점에 대해.</target>
        </trans-unit>
        <trans-unit id="69cc315a656a6408b19c28c1250214347094ab33" translate="yes" xml:space="preserve">
          <source>The replaced object and the replacement object must be of the same type. This restriction can be bypassed using &lt;code&gt;-f&lt;/code&gt;.</source>
          <target state="translated">대체 된 오브젝트와 대체 오브젝트는 동일한 유형이어야합니다. 이 제한은 &lt;code&gt;-f&lt;/code&gt; 를 사용하여 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ad56792b1c232c0733d7ad92a2a6edfcbfd7d1e" translate="yes" xml:space="preserve">
          <source>The report does not tell you anything about lines which have been deleted or replaced; you need to use a tool such as &lt;code&gt;git diff&lt;/code&gt; or the &quot;pickaxe&quot; interface briefly mentioned in the following paragraph.</source>
          <target state="translated">보고서는 삭제되거나 교체 된 라인에 대해서는 아무 것도 알려주지 않습니다. 다음 단락에서 간략하게 언급 한 &lt;code&gt;git diff&lt;/code&gt; 또는 &quot;pickaxe&quot;인터페이스 와 같은 도구를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b4fd8af335028abdc88c8957e63b788cd43e89cc" translate="yes" xml:space="preserve">
          <source>The report of the commands of this hook should have the same order as the input. The exit status of the &lt;code&gt;proc-receive&lt;/code&gt; hook only determines the success or failure of the group of commands sent to it, unless atomic push is in use.</source>
          <target state="translated">The report of the commands of this hook should have the same order as the input. The exit status of the &lt;code&gt;proc-receive&lt;/code&gt; hook only determines the success or failure of the group of commands sent to it, unless atomic push is in use.</target>
        </trans-unit>
        <trans-unit id="2c986c29f6ffa22f2a8c706bbb75b7aeb4461294" translate="yes" xml:space="preserve">
          <source>The repository URL to be pulled from.</source>
          <target state="translated">가져올 리포지토리 URL입니다.</target>
        </trans-unit>
        <trans-unit id="944d2d5ccd37faa608b4a3dce165543a5adf2fbf" translate="yes" xml:space="preserve">
          <source>The repository the action will be performed on.</source>
          <target state="translated">조치가 수행 될 저장소입니다.</target>
        </trans-unit>
        <trans-unit id="0e7c4601cfd7634812fd5318d08d4f529fb59bef" translate="yes" xml:space="preserve">
          <source>The repository to get a tar archive from.</source>
          <target state="translated">tar 아카이브를 가져올 저장소입니다.</target>
        </trans-unit>
        <trans-unit id="bc81f7623489d466e462d3597d8dc6ebd3c462a1" translate="yes" xml:space="preserve">
          <source>The repository to sync from.</source>
          <target state="translated">동기화 할 저장소입니다.</target>
        </trans-unit>
        <trans-unit id="3d7b45c15d44961366710f29c0592cfbaf8293a2" translate="yes" xml:space="preserve">
          <source>The repository to sync into.</source>
          <target state="translated">동기화 할 저장소입니다.</target>
        </trans-unit>
        <trans-unit id="85a32286326310d42bba4488de0fbceb84f9845b" translate="yes" xml:space="preserve">
          <source>The repository to update.</source>
          <target state="translated">업데이트 할 저장소입니다.</target>
        </trans-unit>
        <trans-unit id="15ea4cb9c0b7ca59bf54604e4e274c258d2ab5d8" translate="yes" xml:space="preserve">
          <source>The response of &lt;code&gt;fetch&lt;/code&gt; is broken into a number of sections separated by delimiter packets (0001), with each section beginning with its section header.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 응답은 구분자 패킷 (0001)으로 구분 된 여러 섹션으로 구분되며 각 섹션은 섹션 헤더로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="f5a3baabdc3717b14a2e7f02d6a5a2eab21baf8b" translate="yes" xml:space="preserve">
          <source>The response of &lt;code&gt;fetch&lt;/code&gt; is broken into a number of sections separated by delimiter packets (0001), with each section beginning with its section header. Most sections are sent only when the packfile is sent.</source>
          <target state="translated">The response of &lt;code&gt;fetch&lt;/code&gt; is broken into a number of sections separated by delimiter packets (0001), with each section beginning with its section header. Most sections are sent only when the packfile is sent.</target>
        </trans-unit>
        <trans-unit id="4f1a001f6b3f7c16917c0e0241e976b8717f870a" translate="yes" xml:space="preserve">
          <source>The rest of the documentation discusses &lt;code&gt;fsck.*&lt;/code&gt; for brevity, but the same applies for the corresponding &lt;code&gt;receive.fsck.*&lt;/code&gt; and &lt;code&gt;fetch.&amp;lt;msg-id&amp;gt;.*&lt;/code&gt;. variables.</source>
          <target state="translated">설명서의 나머지 부분에서는 간결성을 위해 &lt;code&gt;fsck.*&lt;/code&gt; 에 대해 설명 하지만 해당 &lt;code&gt;receive.fsck.*&lt;/code&gt; 및 &lt;code&gt;fetch.&amp;lt;msg-id&amp;gt;.*&lt;/code&gt; 에도 동일하게 적용됩니다 . 변수.</target>
        </trans-unit>
        <trans-unit id="ac10b74ced74e00c661f52e9250a42f47fd6add4" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;git merge-base --octopus A B C&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;, because &lt;code&gt;2&lt;/code&gt; is the best common ancestor of all commits.</source>
          <target state="translated">의 결과 &lt;code&gt;git merge-base --octopus A B C&lt;/code&gt; 이다 &lt;code&gt;2&lt;/code&gt; 때문에, &lt;code&gt;2&lt;/code&gt; 모든 커밋의 최선의 공통 조상이다.</target>
        </trans-unit>
        <trans-unit id="1e8fa948e18ddfaa21178042cd566eaada7aae80" translate="yes" xml:space="preserve">
          <source>The result of comparison is passed from these commands to what is internally called &quot;diffcore&quot;, in a format similar to what is output when the -p option is not used. E.g.</source>
          <target state="translated">비교 결과는 -p 옵션을 사용하지 않을 때 출력되는 것과 유사한 형식으로 이러한 명령에서 내부적으로 &quot;diffcore&quot;로 전달됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="d6478eddd3e6be6e1f0703d8450a597d1ea3dfe6" translate="yes" xml:space="preserve">
          <source>The result of such a bisection would be that we would find that H is the first bad commit, when in fact it&amp;rsquo;s B. So that would be wrong!</source>
          <target state="translated">그러한 이분법의 결과는 실제로 B 일 때 H가 첫 번째 잘못된 커밋임을 알게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="9ed4c9f58d5e6595458ce4cb4952fdfe7c07ce9b" translate="yes" xml:space="preserve">
          <source>The resulting command then has an &quot;operation&quot; argument appended to it (see below for details), and the result is executed by the shell.</source>
          <target state="translated">The resulting command then has an &quot;operation&quot; argument appended to it (see below for details), and the result is executed by the shell.</target>
        </trans-unit>
        <trans-unit id="baad8b31b0f95aa1296c5c88ad34816424f2926e" translate="yes" xml:space="preserve">
          <source>The resulting directory proj.git contains a &quot;bare&quot; git repository&amp;mdash;​it is just the contents of the &lt;code&gt;.git&lt;/code&gt; directory, without any files checked out around it.</source>
          <target state="translated">결과 디렉토리 proj.git에는 &quot;bare&quot;git 저장소가 있습니다. 파일을 체크 아웃하지 않고 &lt;code&gt;.git&lt;/code&gt; 디렉토리 의 내용 일뿐 입니다.</target>
        </trans-unit>
        <trans-unit id="31dc4b206e7be8ca9a78c4871cc58f03a5340e5b" translate="yes" xml:space="preserve">
          <source>The revision data is appended to the file if it already exists, for use when doing incremental imports.</source>
          <target state="translated">증분 가져 오기를 수행 할 때 사용할 수 있도록 수정본 데이터가 이미 존재하는 경우 파일에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="0ca811b30547ebe29846859e95a6c9147e8141b4" translate="yes" xml:space="preserve">
          <source>The rewrite rule guarantees that existing static files will be properly served, whereas any other URL will be passed to gitweb as PATH_INFO parameter.</source>
          <target state="translated">다시 쓰기 규칙은 기존 정적 파일이 올바르게 제공되는 반면 다른 URL은 PATH_INFO 매개 변수로 gitweb에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="7511d9248c0671ec876d283606ae9df0bea2f6b2" translate="yes" xml:space="preserve">
          <source>The ripple effect of a &quot;hard case&quot; recovery is especially bad: &lt;code&gt;everyone&lt;/code&gt; downstream from &lt;code&gt;topic&lt;/code&gt; will now have to perform a &quot;hard case&quot; recovery too!</source>
          <target state="translated">&quot;하드 케이스&quot;복구의 파급 효과는 특히 나쁩니다. 이제 &lt;code&gt;topic&lt;/code&gt; &lt;code&gt;everyone&lt;/code&gt; 다운 스트림 사용자도 &quot;하드 케이스&quot;복구를 수행해야합니다!</target>
        </trans-unit>
        <trans-unit id="93d5c7537e241865d860131eb6d72edc95c9d772" translate="yes" xml:space="preserve">
          <source>The root of the CVS archive. May be local (a simple path) or remote; currently, only the :local:, :ext: and :pserver: access methods are supported. If not given, &lt;code&gt;git cvsimport&lt;/code&gt; will try to read it from &lt;code&gt;CVS/Root&lt;/code&gt;. If no such file exists, it checks for the &lt;code&gt;CVSROOT&lt;/code&gt; environment variable.</source>
          <target state="translated">CVS 아카이브의 루트 로컬 (간단한 경로) 또는 원격 일 수 있습니다. 현재 : local :, : ext : 및 : pserver : 액세스 방법 만 지원됩니다. 지정하지 않으면 &lt;code&gt;git cvsimport&lt;/code&gt; 는 &lt;code&gt;CVS/Root&lt;/code&gt; 에서 읽습니다 . 그러한 파일이 없으면 &lt;code&gt;CVSROOT&lt;/code&gt; 환경 변수를 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="df41fdf293aec02e3dee1ead27003284471a1181" translate="yes" xml:space="preserve">
          <source>The root of the tree can be represented by an empty string as &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">트리의 루트는 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 로 빈 문자열로 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="557dc21e01559e09224bc25bcbd6a672b4e3d883" translate="yes" xml:space="preserve">
          <source>The rule to determine which remote branch to merge after fetching is a bit involved, in order not to break backward compatibility.</source>
          <target state="translated">이전 버전과의 호환성을 위반하지 않기 위해 페치 후 병합 할 원격 브랜치를 결정하는 규칙이 약간 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bbff5506f0bff9eed6d1a29f80ce8f838449bb56" translate="yes" xml:space="preserve">
          <source>The rules by which the pattern matches paths are the same as in &lt;code&gt;.gitignore&lt;/code&gt; files (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;), with a few exceptions:</source>
          <target state="translated">패턴이 경로와 일치하는 규칙은 &lt;code&gt;.gitignore&lt;/code&gt; 파일 ( &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; 참조 )과 동일하지만 몇 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="579e7c08387accae89723ba13e3ec53145837232" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;--merge&lt;/code&gt; option above, but changes the way the conflicting hunks are presented, overriding the &lt;code&gt;merge.conflictStyle&lt;/code&gt; configuration variable. Possible values are &quot;merge&quot; (default) and &quot;diff3&quot; (in addition to what is shown by &quot;merge&quot; style, shows the original contents).</source>
          <target state="translated">위의 &lt;code&gt;--merge&lt;/code&gt; 옵션 과 동일 하지만 충돌하는 덩어리가 표시되는 방식을 변경하여 &lt;code&gt;merge.conflictStyle&lt;/code&gt; 구성 변수를 재정의하십시오 . 가능한 값은 &quot;병합&quot;(기본값) 및 &quot;diff3&quot;입니다 ( &quot;병합&quot;스타일로 표시되는 것 외에 원래 내용 표시).</target>
        </trans-unit>
        <trans-unit id="1a11cc7f94381fe2de07d484775d2914bf62d241" translate="yes" xml:space="preserve">
          <source>The same as the previous one:</source>
          <target state="translated">이전과 동일</target>
        </trans-unit>
        <trans-unit id="ebdfbbadd1b4e3e4d3c390aed297730072348592" translate="yes" xml:space="preserve">
          <source>The same rewind and rebuild process may be followed for &lt;code&gt;pu&lt;/code&gt;. A public announcement is not necessary since &lt;code&gt;pu&lt;/code&gt; is a throw-away branch, as described above.</source>
          <target state="translated">&lt;code&gt;pu&lt;/code&gt; 에 대해 동일한 되감기 및 재구성 프로세스가 수행 될 수 있습니다 . &lt;code&gt;pu&lt;/code&gt; 는 위에서 설명한 것처럼 버림 지점 이므로 공개 발표가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="982acf1816c2fb0e10e67de1c939cdcea16cc699" translate="yes" xml:space="preserve">
          <source>The same rewind and rebuild process may be followed for &lt;code&gt;seen&lt;/code&gt;. A public announcement is not necessary since &lt;code&gt;seen&lt;/code&gt; is a throw-away branch, as described above.</source>
          <target state="translated">The same rewind and rebuild process may be followed for &lt;code&gt;seen&lt;/code&gt; . A public announcement is not necessary since &lt;code&gt;seen&lt;/code&gt; is a throw-away branch, as described above.</target>
        </trans-unit>
        <trans-unit id="30d931302d20c8d2d3f4d29cdb99720d08f56244" translate="yes" xml:space="preserve">
          <source>The same trailer as a v1 pack file:</source>
          <target state="translated">v1 팩 파일과 동일한 트레일러 :</target>
        </trans-unit>
        <trans-unit id="ef6e4cd5de79a2002e4df69090fc16d7024fe532" translate="yes" xml:space="preserve">
          <source>The sample &lt;code&gt;prepare-commit-msg&lt;/code&gt; hook that comes with Git removes the help message found in the commented portion of the commit template.</source>
          <target state="translated">Git과 함께 제공 되는 샘플 &lt;code&gt;prepare-commit-msg&lt;/code&gt; 훅은 커밋 템플릿의 주석 처리 된 부분에있는 도움말 메시지를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="0814a224cf6ffffca90b05b46ffd264f8d62f600" translate="yes" xml:space="preserve">
          <source>The sample hooks are all disabled by default. To enable one of the sample hooks rename it by removing its &lt;code&gt;.sample&lt;/code&gt; suffix.</source>
          <target state="translated">샘플 후크는 기본적으로 비활성화되어 있습니다. 샘플 후크 중 하나를 사용하려면 &lt;code&gt;.sample&lt;/code&gt; 접미 부를 제거하여 이름을 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="ee2f5fb52849fdcd69a62a399938c4c71ec4e36c" translate="yes" xml:space="preserve">
          <source>The sane thing. Just admit you screwed up, and use a different name. Others have already seen one tag-name, and if you keep the same name, you may be in the situation that two people both have &quot;version X&quot;, but they actually have &lt;code&gt;different&lt;/code&gt; &quot;X&quot;'s. So just call it &quot;X.1&quot; and be done with it.</source>
          <target state="translated">제정신 망했음을 인정하고 다른 이름을 사용하십시오. 다른 사람들은 이미 하나의 태그 이름을 보았고 같은 이름을 유지하면 두 사람이 모두 &quot;버전 X&quot;를 가지고 있지만 실제로는 &quot;X&quot; 가 &lt;code&gt;different&lt;/code&gt; 상황에있을 수 있습니다 . &quot;X.1&quot;이라고 부르고 완료하십시오.</target>
        </trans-unit>
        <trans-unit id="16a78cd21b6c709f016f4a17d2a1069e970db97c" translate="yes" xml:space="preserve">
          <source>The script expects you to provide the key roots where it can start the import from an &lt;code&gt;initial import&lt;/code&gt; or &lt;code&gt;tag&lt;/code&gt; type of Arch commit. It will follow and import new branches within the provided roots.</source>
          <target state="translated">스크립트는 &lt;code&gt;initial import&lt;/code&gt; 또는 &lt;code&gt;tag&lt;/code&gt; 유형의 Arch commit 에서 가져 오기를 시작할 수있는 핵심 루트를 제공 할 것으로 예상합니다 . 제공된 루트 내에서 새 분기를 따르고 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="793ca81ee99913a2e3edc7ca33209f79549422e8" translate="yes" xml:space="preserve">
          <source>The scriptlet sets &lt;code&gt;GIT_DIR&lt;/code&gt; and &lt;code&gt;GIT_OBJECT_DIRECTORY&lt;/code&gt; shell variables, but does &lt;strong&gt;not&lt;/strong&gt; export them to the environment.</source>
          <target state="translated">스크립틀릿은 설정 &lt;code&gt;GIT_DIR&lt;/code&gt; 및 &lt;code&gt;GIT_OBJECT_DIRECTORY&lt;/code&gt; 쉘 변수를하지만, 않습니다 &lt;strong&gt;없는&lt;/strong&gt; 환경에 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b53f7beee61a37b0174ea389f5f36080ff3c1b7" translate="yes" xml:space="preserve">
          <source>The second .gitignore prevents Git from ignoring &lt;code&gt;arch/foo/kernel/vmlinux.lds.S&lt;/code&gt;.</source>
          <target state="translated">두 번째 .gitignore는 Git이 &lt;code&gt;arch/foo/kernel/vmlinux.lds.S&lt;/code&gt; 를 무시하지 못하게 합니다.</target>
        </trans-unit>
        <trans-unit id="fc737587a80c0c07a4fffd3646c479ff0f86cddd" translate="yes" xml:space="preserve">
          <source>The second example demonstrates that you can abbreviate the object name to only the first several hexadecimal digits in most places.</source>
          <target state="translated">두 번째 예는 대부분의 장소에서 처음 몇 개의 16 진수로만 객체 이름을 약어로 표시 할 수 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2890a9def3fff903603dee47b68cd9b5af108707" translate="yes" xml:space="preserve">
          <source>The second format is what gets used when &lt;code&gt;--stage=all&lt;/code&gt;. The three stage temporary fields (stage1temp, stage2temp, stage3temp) list the name of the temporary file if there is a stage entry in the index or &lt;code&gt;.&lt;/code&gt; if there is no stage entry. Paths which only have a stage 0 entry will always be omitted from the output.</source>
          <target state="translated">두 번째 형식은 &lt;code&gt;--stage=all&lt;/code&gt; 일 때 사용됩니다 . 세 개의 스테이지 임시 필드 (stage1temp, stage2temp, stage3temp)는 색인 또는에 스테이지 항목이있는 경우 임시 파일의 이름을 나열합니다 &lt;code&gt;.&lt;/code&gt; 무대 진입이없는 경우 단계 0 항목 만있는 경로는 항상 출력에서 ​​생략됩니다.</target>
        </trans-unit>
        <trans-unit id="8a6f107e4f2dc8b17455f1349e940becb9fc3a6b" translate="yes" xml:space="preserve">
          <source>The second issue is one of auditing. When many contributors are working on the same repository, it is important which merge commits introduced a change into an important branch. The problematic merge &lt;code&gt;R&lt;/code&gt; above is not likely to be the merge commit that was used to merge into an important branch. Instead, the merge &lt;code&gt;N&lt;/code&gt; was used to merge &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; into the important branch. This commit may have information about why the change &lt;code&gt;X&lt;/code&gt; came to override the changes from &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; in its commit message.</source>
          <target state="translated">The second issue is one of auditing. When many contributors are working on the same repository, it is important which merge commits introduced a change into an important branch. The problematic merge &lt;code&gt;R&lt;/code&gt; above is not likely to be the merge commit that was used to merge into an important branch. Instead, the merge &lt;code&gt;N&lt;/code&gt; was used to merge &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; into the important branch. This commit may have information about why the change &lt;code&gt;X&lt;/code&gt; came to override the changes from &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; in its commit message.</target>
        </trans-unit>
        <trans-unit id="86b87f951d8d8be1a02da6e062a3489256945d73" translate="yes" xml:space="preserve">
          <source>The second parameter passed to the hook is the indicator for whether or not the index was updated and the skip-worktree bit could have changed. &quot;1&quot; meaning skip-worktree bits could have been updated and &quot;0&quot; meaning they were not.</source>
          <target state="translated">후크에 전달 된 두 번째 매개 변수는 색인이 업데이트되었고 스킵 작업 트리 비트가 변경 될 수 있는지 여부에 대한 표시기입니다. &quot;1&quot;은 skip-worktree 비트가 업데이트 될 수 있음을 의미하고 &quot;0&quot;은 비트 워크가 업데이트되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b730007914036d9f0fb3ba6052d64853bae216ae" translate="yes" xml:space="preserve">
          <source>The second syntax (&quot;&lt;code&gt;git merge --abort&lt;/code&gt;&quot;) can only be run after the merge has resulted in conflicts. &lt;code&gt;git merge --abort&lt;/code&gt; will abort the merge process and try to reconstruct the pre-merge state. However, if there were uncommitted changes when the merge started (and especially if those changes were further modified after the merge was started), &lt;code&gt;git merge --abort&lt;/code&gt; will in some cases be unable to reconstruct the original (pre-merge) changes. Therefore:</source>
          <target state="translated">두 번째 구문 ( &quot; &lt;code&gt;git merge --abort&lt;/code&gt; &quot;)은 병합이 충돌 한 후에 만 ​​실행할 수 있습니다. &lt;code&gt;git merge --abort&lt;/code&gt; 는 병합 프로세스를 중단하고 병합 전 상태를 재구성하려고 시도합니다. 그러나 병합이 시작될 때 커밋되지 않은 변경 사항이 있었을 때 (특히 병합이 시작된 후 이러한 변경 사항이 추가로 수정 된 경우) &lt;code&gt;git merge --abort&lt;/code&gt; 는 원래 (병합 전) 변경 사항을 재구성 할 수없는 경우가 있습니다. 따라서:</target>
        </trans-unit>
        <trans-unit id="1f7dcee78b5872602756cd0d868ad6253db301fe" translate="yes" xml:space="preserve">
          <source>The second transformation in the chain is diffcore-break, and is controlled by the -B option to the &lt;code&gt;git diff-*&lt;/code&gt; commands. This is used to detect a filepair that represents &quot;complete rewrite&quot; and break such filepair into two filepairs that represent delete and create. E.g. If the input contained this filepair:</source>
          <target state="translated">체인의 두 번째 변환은 diffcore-break이며, &lt;code&gt;git diff-*&lt;/code&gt; 명령 에 대한 -B 옵션으로 제어됩니다 . &quot;완전한 다시 쓰기&quot;를 나타내는 파일 쌍을 감지하고 해당 파일 쌍을 삭제 및 작성을 나타내는 두 개의 파일 쌍으로 나눕니다. 예를 들어, 입력에이 파일 쌍이 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="5aa738048a0181b9705365955bd04c18156f9d33" translate="yes" xml:space="preserve">
          <source>The section &lt;code&gt;submodule.foo.*&lt;/code&gt; in the &lt;code&gt;.gitmodules&lt;/code&gt; file gives additional hints to Git&amp;rsquo;s porcelain layer. For example, the &lt;code&gt;submodule.foo.url&lt;/code&gt; setting specifies where to obtain the submodule.</source>
          <target state="translated">&lt;code&gt;.gitmodules&lt;/code&gt; 파일 의 &lt;code&gt;submodule.foo.*&lt;/code&gt; 섹션 은 Git의 도자기 레이어에 대한 추가 힌트를 제공합니다. 예를 들어, &lt;code&gt;submodule.foo.url&lt;/code&gt; 설정 은 서브 모듈 을 얻을 위치를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="addff8a92e5ddb901ae8a38330bc2dcce4be9fbb" translate="yes" xml:space="preserve">
          <source>The section or key is invalid (ret=1),</source>
          <target state="translated">섹션 또는 키가 유효하지 않습니다 (ret = 1).</target>
        </trans-unit>
        <trans-unit id="463ba2454fad2719570e32271a038c3acce699a7" translate="yes" xml:space="preserve">
          <source>The server MUST NOT send any &quot;unshallow&quot; lines for anything which the client has not indicated was shallow as a part of its request.</source>
          <target state="translated">서버는 클라이언트가 요청의 일부로 얕은 것으로 표시하지 않은 항목에 대해 &quot;얕지 않은&quot;행을 보내서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d868af4cbdec034778f61defdf53e9a4307fd341" translate="yes" xml:space="preserve">
          <source>The server MUST NOT send any refs which were not requested using &lt;code&gt;want-ref&lt;/code&gt; lines.</source>
          <target state="translated">서버는 &lt;code&gt;want-ref&lt;/code&gt; 라인을 사용하여 요청되지 않은 심판을 보내서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="446930d87bed0e82e29e329dd081708ba37057c2" translate="yes" xml:space="preserve">
          <source>The server can advertise the &lt;code&gt;agent&lt;/code&gt; capability with a value &lt;code&gt;X&lt;/code&gt; (in the form &lt;code&gt;agent=X&lt;/code&gt;) to notify the client that the server is running version &lt;code&gt;X&lt;/code&gt;. The client may optionally send its own agent string by including the &lt;code&gt;agent&lt;/code&gt; capability with a value &lt;code&gt;Y&lt;/code&gt; (in the form &lt;code&gt;agent=Y&lt;/code&gt;) in its request to the server (but it MUST NOT do so if the server did not advertise the agent capability). The &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; strings may contain any printable ASCII characters except space (i.e., the byte range 32 &amp;lt; x &amp;lt; 127), and are typically of the form &quot;package/version&quot; (e.g., &quot;git/1.8.3.1&quot;). The agent strings are purely informative for statistics and debugging purposes, and MUST NOT be used to programmatically assume the presence or absence of particular features.</source>
          <target state="translated">서버는 &lt;code&gt;agent&lt;/code&gt; 기능을 값 &lt;code&gt;X&lt;/code&gt; ( &lt;code&gt;agent=X&lt;/code&gt; 형식 )로 알리고 서버가 버전 &lt;code&gt;X&lt;/code&gt; 를 실행 중임을 클라이언트에 알릴 수 있습니다. 클라이언트는 요청 에 값 &lt;code&gt;Y&lt;/code&gt; ( &lt;code&gt;agent=Y&lt;/code&gt; 형식) 의 &lt;code&gt;agent&lt;/code&gt; 기능을 서버 에 포함 시켜서 자체 에이전트 문자열을 선택적으로 전송할 수 있습니다 (하지만 서버가 에이전트 기능을 알리지 않은 경우에는 안됩니다). &lt;code&gt;X&lt;/code&gt; 및 &lt;code&gt;Y&lt;/code&gt; 문자열은 공백 (예 : 바이트 범위 32 &amp;lt;x &amp;lt;127)을 제외한 인쇄 가능한 ASCII 문자를 포함 할 수 있으며 일반적으로 &quot;package / version&quot;형식 (예 : &quot;git / 1.8.3.1&quot;)입니다. 에이전트 문자열은 통계 및 디버깅 목적으로 만 정보를 제공하며 특정 기능의 존재 유무를 프로그래밍 방식으로 가정하는 데 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5d8f08f3df19bb2371d7bbd09e4f22512a514d87" translate="yes" xml:space="preserve">
          <source>The server can advertise the &lt;code&gt;object-format&lt;/code&gt; capability with a value &lt;code&gt;X&lt;/code&gt; (in the form &lt;code&gt;object-format=X&lt;/code&gt;) to notify the client that the server is able to deal with objects using hash algorithm X. If not specified, the server is assumed to only handle SHA-1. If the client would like to use a hash algorithm other than SHA-1, it should specify its object-format string.</source>
          <target state="translated">The server can advertise the &lt;code&gt;object-format&lt;/code&gt; capability with a value &lt;code&gt;X&lt;/code&gt; (in the form &lt;code&gt;object-format=X&lt;/code&gt; ) to notify the client that the server is able to deal with objects using hash algorithm X. If not specified, the server is assumed to only handle SHA-1. If the client would like to use a hash algorithm other than SHA-1, it should specify its object-format string.</target>
        </trans-unit>
        <trans-unit id="5dbb8fc2dd2ef1317864e26b0a2f75da26a1d7f0" translate="yes" xml:space="preserve">
          <source>The server sends a &quot;shallow obj-id&quot; line for each commit whose parents will not be sent in the following packfile.</source>
          <target state="translated">서버는 부모가 다음 팩 파일로 전송되지 않을 각 커밋에 대해 &quot;shallow obj-id&quot;행을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="15cbc52acb55c8a437e7a9fc2cb2ebb8c994afc3" translate="yes" xml:space="preserve">
          <source>The server sends an &quot;unshallow obj-id&quot; line for each commit which the client has indicated is shallow, but is no longer shallow as a result of the fetch (due to its parents being sent in the following packfile).</source>
          <target state="translated">서버는 클라이언트가 표시 한 각 커밋에 대해 &quot;unshallow obj-id&quot;행을 전송하지만, 페치 결과로 더 이상 얕은 것은 아닙니다 (부모가 다음 팩 파일로 전송 됨).</target>
        </trans-unit>
        <trans-unit id="3f482eecb5e3fca563243c0419eece540e0582ac" translate="yes" xml:space="preserve">
          <source>The server will respond with &quot;ACK obj-id&quot; for all of the object ids sent as have lines which are common.</source>
          <target state="translated">서버는 공통의 행이있는 것으로 전송 된 모든 객체 ID에 대해 &quot;ACK obj-id&quot;로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="543a974b0aa8c62d541ca2830198235b945cc003" translate="yes" xml:space="preserve">
          <source>The server will respond with &quot;NAK&quot; if none of the object ids sent as have lines were common.</source>
          <target state="translated">라인이있는 것으로 전송 된 오브젝트 ID가 공통되지 않은 경우 서버는 &quot;NAK&quot;로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="568256da628f1737b5310a22de9a07629ce73e0d" translate="yes" xml:space="preserve">
          <source>The server will respond with a &quot;ready&quot; line indicating that the server has found an acceptable common base and is ready to make and send a packfile (which will be found in the packfile section of the same response)</source>
          <target state="translated">서버는 &quot;준비된&quot;라인으로 응답하여 서버가 허용 가능한 공통 기반을 찾았고 팩 파일 (동일한 응답의 packfile 섹션에 있음)을 작성할 준비가되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="69ff3eec8c55e5a8095ea13f51e31e429dc845d6" translate="yes" xml:space="preserve">
          <source>The server will send a ref listing (&quot;&amp;lt;oid&amp;gt; &amp;lt;refname&amp;gt;&quot;) for each reference requested using &lt;code&gt;want-ref&lt;/code&gt; lines.</source>
          <target state="translated">서버는 &lt;code&gt;want-ref&lt;/code&gt; 행을 사용하여 요청 된 각 참조에 대해 참조 목록 ( &quot;&amp;lt;oid&amp;gt; &amp;lt;refname&amp;gt;&quot;)을 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="afb7e2ac1ca268d29d3dabe65a1485bc3c99ebf1" translate="yes" xml:space="preserve">
          <source>The server will then check to ensure that the client&amp;rsquo;s request is comprised of a valid command as well as valid capabilities which were advertised. If the request is valid the server will then execute the command. A server MUST wait till it has received the client&amp;rsquo;s entire request before issuing a response. The format of the response is determined by the command being executed, but in all cases a flush-pkt indicates the end of the response.</source>
          <target state="translated">그런 다음 서버는 클라이언트 요청이 유효한 명령뿐만 아니라 알려진 유효한 기능으로 구성되어 있는지 확인합니다. 요청이 유효하면 서버는 명령을 실행합니다. 서버는 응답을 발행하기 전에 클라이언트의 전체 요청을 수신 할 때까지 기다려야합니다. 응답의 형식은 실행중인 명령에 따라 결정되지만 flush-pkt는 응답의 끝을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="537b1e0777fad4eaaafbf4ccf5940ab37b1e2ed6" translate="yes" xml:space="preserve">
          <source>The shared index part, to be referenced by $GIT_DIR/index and other temporary index files. Only valid in split index mode.</source>
          <target state="translated">$ GIT_DIR / index 및 기타 임시 색인 파일에서 참조 할 공유 색인 부분. 분할 인덱스 모드에서만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="d11a14c0103fd18e1ebb96bcb7251e0f8abbce80" translate="yes" xml:space="preserve">
          <source>The shift magic first throws away the tree id and then the -p parameters. Note that this handles merges properly! In case Darl committed a merge between P1 and P2, it will be propagated properly and all children of the merge will become merge commits with P1,P2 as their parents instead of the merge commit.</source>
          <target state="translated">시프트 매직은 먼저 트리 ID와 -p 매개 변수를 모두 버립니다. 이 처리는 병합을 올바르게 처리합니다. Darl이 P1과 P2간에 병합을 커밋 한 경우 제대로 전파되고 병합의 모든 자식은 병합 커밋 대신 P1, P2를 부모로 병합 커밋이됩니다.</target>
        </trans-unit>
        <trans-unit id="e33b2d8b27401f604cb70ad4d214df90a2abf20c" translate="yes" xml:space="preserve">
          <source>The similarity index is the percentage of unchanged lines, and the dissimilarity index is the percentage of changed lines. It is a rounded down integer, followed by a percent sign. The similarity index value of 100% is thus reserved for two equal files, while 100% dissimilarity means that no line from the old file made it into the new one.</source>
          <target state="translated">유사성 지수는 변경되지 않은 라인의 백분율이며, 비 유사성 지수는 변경된 라인의 백분율입니다. 반올림 된 정수 다음에 백분율 기호가옵니다. 100 %의 유사성 색인 값은 두 개의 동일한 파일에 대해 예약되어 있으며 100 %의 유사하지 않음은 이전 파일의 행이 새 파일로 작성되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="09f0c715250f8ac9e78727d6768d66502facff83" translate="yes" xml:space="preserve">
          <source>The simplest commit to find is the HEAD commit, which we can find from .git/HEAD:</source>
          <target state="translated">가장 간단한 커밋은 HEAD 커밋이며, .git / HEAD에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="938f800e1b465bd0f07eb377492ba2456bfbed2c" translate="yes" xml:space="preserve">
          <source>The simplest way to do this is using &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and ssh; to update the remote branch named &lt;code&gt;master&lt;/code&gt; with the latest state of your branch named &lt;code&gt;master&lt;/code&gt;, run</source>
          <target state="translated">가장 간단한 방법은 &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 및 ssh; 라는 이름의 원격 지사 업데이트 &lt;code&gt;master&lt;/code&gt; 지사라는 이름의 최신 상태 &lt;code&gt;master&lt;/code&gt; , 실행</target>
        </trans-unit>
        <trans-unit id="a5eba655ac4b55a1106bdc6c6dbf2b0d1ad04c8a" translate="yes" xml:space="preserve">
          <source>The simplest way to mark a file as binary is to unset the diff attribute in the &lt;code&gt;.gitattributes&lt;/code&gt; file:</source>
          <target state="translated">파일을 바이너리로 표시하는 가장 간단한 방법은 &lt;code&gt;.gitattributes&lt;/code&gt; 파일 에서 diff 속성을 설정 해제하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="0f95b7ebe5f42d4f0766af1eda2b35efa6854fa9" translate="yes" xml:space="preserve">
          <source>The size in bytes of the commit or tag message.</source>
          <target state="translated">The size in bytes of the commit or tag message.</target>
        </trans-unit>
        <trans-unit id="99bb329f9f9a76ae9c81982693e8d5911709e87c" translate="yes" xml:space="preserve">
          <source>The size of the object (the same as &lt;code&gt;git cat-file -s&lt;/code&gt; reports). Append &lt;code&gt;:disk&lt;/code&gt; to get the size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the &lt;code&gt;CAVEATS&lt;/code&gt; section below.</source>
          <target state="translated">객체의 크기 ( &lt;code&gt;git cat-file -s&lt;/code&gt; reports 와 동일 ) &lt;code&gt;:disk&lt;/code&gt; 를 추가 하여 개체가 디스크에서 차지하는 크기 (바이트)를 가져옵니다. 아래 의 &lt;code&gt;CAVEATS&lt;/code&gt; 섹션 에서 온 디스크 크기에 대한 참고 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3527fa64b6fd749102c379b2fd96b0df5cd454cb" translate="yes" xml:space="preserve">
          <source>The size of the window used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; when no window size is given on the command line. Defaults to 10.</source>
          <target state="translated">창 크기가 사용 &lt;a href=&quot;git-pack-objects&quot;&gt;자식 팩 - 오브젝트 [1]&lt;/a&gt; 어떤 윈도우 사이즈는 명령 라인에 제공되지 않는 경우. 기본값은 10입니다.</target>
        </trans-unit>
        <trans-unit id="2372575566ae8c805d7580bdcbad6da1c4463611" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the object (the same as &lt;code&gt;cat-file -s&lt;/code&gt; reports).</source>
          <target state="translated">개체의 크기 (바이트) ( &lt;code&gt;cat-file -s&lt;/code&gt; 보고서 와 동일 )</target>
        </trans-unit>
        <trans-unit id="43c333a5a6bd3bca8b34d5163a7aa7b6d79d2d40" translate="yes" xml:space="preserve">
          <source>The size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the &lt;code&gt;CAVEATS&lt;/code&gt; section below.</source>
          <target state="translated">객체가 디스크에서 차지하는 크기 (바이트)입니다. 아래 의 &lt;code&gt;CAVEATS&lt;/code&gt; 섹션 에서 온 디스크 크기에 대한 참고 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d544171c06a9cb39c4059f830c0a8558d3922c9" translate="yes" xml:space="preserve">
          <source>The slash &lt;code&gt;/&lt;/code&gt; is used as the directory separator. Separators may occur at the beginning, middle or end of the &lt;code&gt;.gitignore&lt;/code&gt; search pattern.</source>
          <target state="translated">슬래시 ( &lt;code&gt;/&lt;/code&gt; ) 는 디렉토리 구분 기호로 사용됩니다. 구분 기호는 &lt;code&gt;.gitignore&lt;/code&gt; 검색 패턴 의 시작, 중간 또는 끝에서 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e18b2266f1b1b9062e466bd05dd697dc8d44c68f" translate="yes" xml:space="preserve">
          <source>The smaller the changes in your commit, the most effective &quot;git bisect&quot; will be. And you will probably need &quot;git bisect&quot; less in the first place, as small changes are easier to review even if they are only reviewed by the committer.</source>
          <target state="translated">커밋의 변경 사항이 작을수록 가장 효과적인 &quot;git bisect&quot;가됩니다. 그리고 커미터에 의해서만 검토 되더라도 작은 변경 사항을 검토하기가 더 쉬우므로 처음에는 &quot;git bisect&quot;가 덜 필요할 것입니다.</target>
        </trans-unit>
        <trans-unit id="0dab2fe7462a5d0c0b797d08e789dbaaf7bfa1df" translate="yes" xml:space="preserve">
          <source>The smart HTTP server, &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend[1]&lt;/a&gt;, will pass GIT_NAMESPACE through to the backend programs; see &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend[1]&lt;/a&gt; for sample configuration to expose repository namespaces as repositories.</source>
          <target state="translated">스마트 HTTP 서버 인 &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend [1]&lt;/a&gt; 은 GIT_NAMESPACE를 백엔드 프로그램으로 전달합니다. 리포지토리 네임 스페이스를 리포지토리로 노출하는 샘플 구성 은 &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend [1]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ee3be6f644f850e9ae409b580b74ced862493f8" translate="yes" xml:space="preserve">
          <source>The solution, of course, is to make a merge that we can undo: merge into a throw-away branch.</source>
          <target state="translated">물론 해결책은 취소 할 수있는 병합을 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a1117f540255f9a5dcffa1baa25558f77657b0e" translate="yes" xml:space="preserve">
          <source>The special case of restarting an incremental import from the current branch value should be written as:</source>
          <target state="translated">현재 분기 값에서 증분 가져 오기를 다시 시작하는 특별한 경우는 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="3599d1b8b89ee48d0b633dcff9041c57284c3251" translate="yes" xml:space="preserve">
          <source>The special exit code 125 should be used when the current source code cannot be tested. If the script exits with this code, the current revision will be skipped (see &lt;code&gt;git bisect skip&lt;/code&gt; above). 125 was chosen as the highest sensible value to use for this purpose, because 126 and 127 are used by POSIX shells to signal specific error status (127 is for command not found, 126 is for command found but not executable&amp;mdash;​these details do not matter, as they are normal errors in the script, as far as &lt;code&gt;bisect run&lt;/code&gt; is concerned).</source>
          <target state="translated">현재 소스 코드를 테스트 할 수없는 경우 특수 종료 코드 125를 사용해야합니다. 스크립트가이 코드와 함께 종료되면 현재 개정판을 건너 뜁니다 ( 위의 &lt;code&gt;git bisect skip&lt;/code&gt; 참조). 126과 127은 POSIX 셸에서 특정 오류 상태를 알리기 위해 사용하기 때문에 125가이 목적에 사용할 수있는 가장 합리적인 값으로 선택되었습니다 (127은 명령을 찾을 수없고 126은 명령을 찾았지만 실행할 수 없음). &lt;code&gt;bisect run&lt;/code&gt; 과 관련 하여 스크립트에서 정상적인 오류 이므로 문제가 발생합니다).</target>
        </trans-unit>
        <trans-unit id="60ac8fe2a99f998c150bb7d9adc8dfbeed95a10d" translate="yes" xml:space="preserve">
          <source>The special null SHA-1 (40 zeros) specifies that the branch is to be removed.</source>
          <target state="translated">특수 null SHA-1 (40 개의 0)은 분기가 제거되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="a4c2fa6682338e4d7c45557107add1984be0213c" translate="yes" xml:space="preserve">
          <source>The special refspec &lt;code&gt;:&lt;/code&gt; (or &lt;code&gt;+:&lt;/code&gt; to allow non-fast-forward updates) directs Git to push &quot;matching&quot; branches: for every branch that exists on the local side, the remote side is updated if a branch of the same name already exists on the remote side.</source>
          <target state="translated">특별한 refspec &lt;code&gt;:&lt;/code&gt; (또는 &lt;code&gt;+:&lt;/code&gt; 빨리 감기가 아닌 업데이트를 허용하기 위해) Git은 &quot;일치하는&quot;분기를 푸시하도록 지시합니다. 로컬 측에 존재하는 모든 분기에 대해 동일한 이름의 분기가 이미 존재하면 원격 측이 업데이트됩니다 원격에서.</target>
        </trans-unit>
        <trans-unit id="f2f702d2704e1b64279419d712ca4460c3b7f78e" translate="yes" xml:space="preserve">
          <source>The special string &lt;code&gt;none&lt;/code&gt; can be used as the proxy command to specify that no proxy be used for a given domain pattern. This is useful for excluding servers inside a firewall from proxy use, while defaulting to a common proxy for external domains.</source>
          <target state="translated">지정된 문자열 패턴에 프록시를 사용하지 않도록 지정하기 위해 특수 문자열 &lt;code&gt;none&lt;/code&gt; 을 proxy 명령으로 사용할 수 없습니다. 이는 방화벽 내부의 서버를 프록시 사용에서 제외하고 외부 도메인의 공통 프록시로 기본 설정하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="65b859a3a4528b4a1eebafeebe9d2d28ac0eb085" translate="yes" xml:space="preserve">
          <source>The special symbol &quot;HEAD&quot; can always be used to refer to the current branch. In fact, Git uses a file named &lt;code&gt;HEAD&lt;/code&gt; in the &lt;code&gt;.git&lt;/code&gt; directory to remember which branch is current:</source>
          <target state="translated">특수 기호 &quot;HEAD&quot;는 항상 현재 분기를 나타내는 데 사용할 수 있습니다. 사실, 힘내라는 이름의 파일 사용 &lt;code&gt;HEAD&lt;/code&gt; 에 &lt;code&gt;.git&lt;/code&gt; 현재 어느 지점 기억해야 할 디렉토리를 :</target>
        </trans-unit>
        <trans-unit id="54b91d851f1b23aa70b29c0e74d2c28879b6de30" translate="yes" xml:space="preserve">
          <source>The ssh and git protocols additionally support ~username expansion:</source>
          <target state="translated">ssh 및 git 프로토콜은 ~ username 확장을 추가로 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ac6c6d73b5f6b7c3cef28dfe32da61495601bd7c" translate="yes" xml:space="preserve">
          <source>The standard actions are:</source>
          <target state="translated">표준 조치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a72f515f06e2719cd062e161d9ed80a61b68c92f" translate="yes" xml:space="preserve">
          <source>The standard email format as described by RFC 2822, for example &lt;code&gt;Thu, 07 Apr 2005 22:13:13 +0200&lt;/code&gt;.</source>
          <target state="translated">RFC 2822에 설명 된 표준 이메일 형식 (예 : &lt;code&gt;Thu, 07 Apr 2005 22:13:13 +0200&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8128f4cfe82d86e129a0094608260664c3bb1ba3" translate="yes" xml:space="preserve">
          <source>The standard helper program to use with git-merge-index</source>
          <target state="translated">git-merge-index와 함께 사용할 표준 도우미 프로그램</target>
        </trans-unit>
        <trans-unit id="4d34b021b617aa2bf3f93982ac428b041f085fbe" translate="yes" xml:space="preserve">
          <source>The starting point for the new branch. Specifying a &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; allows you to create a branch based on some other point in history than where HEAD currently points. (Or, in the case of &lt;code&gt;--detach&lt;/code&gt;, allows you to inspect and detach from some other point.)</source>
          <target state="translated">새로운 지점의 출발점. &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; 를 지정하면 HEAD가 현재 가리키는 위치 이외의 다른 기록 포인트를 기반으로 분기를 만들 수 있습니다. 또는 &lt;code&gt;--detach&lt;/code&gt; 의 경우 다른 지점을 검사하고 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="ca9ba47b83a1def4d8a6c769f2e642f061d5236a" translate="yes" xml:space="preserve">
          <source>The status of GPG verification of the push certificate, using the same mnemonic as used in &lt;code&gt;%G?&lt;/code&gt; format of &lt;code&gt;git log&lt;/code&gt; family of commands (see &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;%G?&lt;/code&gt; 사용 된 것과 동일한 니모닉을 사용하여 푸시 인증서의 GPG 확인 상태 ? &lt;code&gt;git log&lt;/code&gt; 명령 계열 형식 ( &lt;a href=&quot;git-log&quot;&gt;git-log [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c902748a09ab505851b0b39809c60f3db2027be9" translate="yes" xml:space="preserve">
          <source>The status of the fetch is output in tabular form, with each line representing the status of a single ref. Each line is of the form:</source>
          <target state="translated">페치 상태는 표 형식으로 출력되며 각 라인은 단일 심판의 상태를 나타냅니다. 각 줄의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7729563c964ef73ba71f39abfa320766ac0cea33" translate="yes" xml:space="preserve">
          <source>The status of the push is output in tabular form, with each line representing the status of a single ref. Each line is of the form:</source>
          <target state="translated">푸시 상태는 표 형식으로 출력되며 각 라인은 단일 심판의 상태를 나타냅니다. 각 줄의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e939f21e3282d453b1398071feb25115360b90b4" translate="yes" xml:space="preserve">
          <source>The status of up-to-date refs is shown only if --porcelain or --verbose option is used.</source>
          <target state="translated">최신 참조 상태는 --porcelain 또는 --verbose 옵션을 사용하는 경우에만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0ebfa7ce02ec5605e425e0cd98062f5bbd8f2510" translate="yes" xml:space="preserve">
          <source>The status of up-to-date refs is shown only if the --verbose option is used.</source>
          <target state="translated">최신 참조 상태는 --verbose 옵션이 사용 된 경우에만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a97643bd561fabe3d136679e4752cb73667ec062" translate="yes" xml:space="preserve">
          <source>The structured objects can further have their structure and connectivity to other objects verified. This is generally done with the &lt;code&gt;git fsck&lt;/code&gt; program, which generates a full dependency graph of all objects, and verifies their internal consistency (in addition to just verifying their superficial consistency through the hash).</source>
          <target state="translated">구조화 된 객체는 구조 및 다른 객체와의 연결성을 확인할 수 있습니다. 이것은 일반적으로 &lt;code&gt;git fsck&lt;/code&gt; 프로그램을 사용하여 수행됩니다.이 프로그램은 모든 객체의 전체 의존성 그래프를 생성하고 해시를 통해 표면 일관성을 확인하는 것 외에도 내부 일관성을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="af4ab93b8907c3bc82033e90c4bc6eedaac09e1c" translate="yes" xml:space="preserve">
          <source>The submit process invokes the editor before each p4 change is submitted. If this setting is true, though, the editing step is skipped.</source>
          <target state="translated">제출 프로세스는 각 p4 변경 사항이 제출되기 전에 편집기를 호출합니다. 그러나이 설정이 참이면 편집 단계를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="72386229ffdfc0f6ba847ccdd7620fcafabeae30" translate="yes" xml:space="preserve">
          <source>The submodule directories are there, but they&amp;rsquo;re empty:</source>
          <target state="translated">하위 모듈 디렉토리가 있지만 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="802b1c9a36cac97c548242e11fe5baa3275576f0" translate="yes" xml:space="preserve">
          <source>The submodule will never be considered modified (but will nonetheless show up in the output of status and commit when it has been staged).</source>
          <target state="translated">서브 모듈은 수정 된 것으로 간주되지 않습니다 (그러나 그럼에도 불구하고 스테이트 출력시 상태 출력 및 커밋에 표시됨).</target>
        </trans-unit>
        <trans-unit id="7180d60887d97b6ca57dd91c2b86681f019ca631" translate="yes" xml:space="preserve">
          <source>The submodule&amp;rsquo;s &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file would come into play when running &lt;code&gt;git push --recurse-submodules=check&lt;/code&gt; in the superproject, as this would check if the submodule has any changes not published to any remote. The remotes are configured in the submodule as usual in the &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file.</source>
          <target state="translated">서브 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 의 $ GIT_DIR / config 파일은 수퍼 &lt;code&gt;git push --recurse-submodules=check&lt;/code&gt; 에서 git push --recurse-submodules = check 를 실행할 때 서브 모듈이 원격에 게시되지 않은 변경 사항이 있는지 확인하므로 실행 됩니다. 리모트는 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 에서 평소와 같이 서브 모듈에서 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="2a87578b15befa74b2d27eca3216884ceb35493c" translate="yes" xml:space="preserve">
          <source>The suffix &lt;code&gt;@{push}&lt;/code&gt; reports the branch &quot;where we would push to&quot; if &lt;code&gt;git push&lt;/code&gt; were run while &lt;code&gt;branchname&lt;/code&gt; was checked out (or the current &lt;code&gt;HEAD&lt;/code&gt; if no branchname is specified). Since our push destination is in a remote repository, of course, we report the local tracking branch that corresponds to that branch (i.e., something in &lt;code&gt;refs/remotes/&lt;/code&gt;).</source>
          <target state="translated">접미사 &lt;code&gt;@{push}&lt;/code&gt; 는 &lt;code&gt;branchname&lt;/code&gt; 이 체크 아웃 된 상태에서 &lt;code&gt;git push&lt;/code&gt; 가 실행 된 경우 (또는 branchname이 지정되지 않은 경우 현재 &lt;code&gt;HEAD&lt;/code&gt; ) &quot;분기 할 위치&quot;분기를보고합니다 . 푸시 대상은 원격 저장소에 있기 때문에 해당 분기에 해당하는 로컬 추적 분기 (예 : &lt;code&gt;refs/remotes/&lt;/code&gt; )를보고합니다.</target>
        </trans-unit>
        <trans-unit id="c10fd9c6c93e1de11dbe32978aa15d853b4103fb" translate="yes" xml:space="preserve">
          <source>The suffix &lt;code&gt;@{upstream}&lt;/code&gt; to a branchname (short form &lt;code&gt;&amp;lt;branchname&amp;gt;@{u}&lt;/code&gt;) refers to the branch that the branch specified by branchname is set to build on top of (configured with &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;). A missing branchname defaults to the current one. These suffixes are also accepted when spelled in uppercase, and they mean the same thing no matter the case.</source>
          <target state="translated">분기 이름 의 접미사 &lt;code&gt;@{upstream}&lt;/code&gt; (약식 &lt;code&gt;&amp;lt;branchname&amp;gt;@{u}&lt;/code&gt; )은 branchname으로 지정된 분기가 ( &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 및 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 구성된) 위에 빌드되도록 설정된 분기를 나타냅니다. &amp;lt;이름&amp;gt; .merge ). 누락 된 분기 이름은 기본적으로 현재 이름입니다. 이 접미어는 대문자로 표기 할 때도 허용되며 경우에 상관없이 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="35fca7d90e0c51050df5863335fd96cb674d847a" translate="yes" xml:space="preserve">
          <source>The symlink will either be absolute (beginning with a /), or relative to the tree root. For instance, if dir/link points to ../../foo, then &amp;lt;symlink&amp;gt; will be ../foo. &amp;lt;size&amp;gt; is the size of the symlink in bytes.</source>
          <target state="translated">심볼릭 링크는 절대적이거나 (/로 시작) 나무 루트에 상대적입니다. 예를 들어 dir / link가 ../../foo를 가리키는 경우 &amp;lt;symlink&amp;gt;는 ../foo가됩니다. &amp;lt;size&amp;gt;는 바이트 단위의 심볼릭 링크 크기입니다.</target>
        </trans-unit>
        <trans-unit id="1e32c77f2578ce3c979cd217827d9aa3c6897be9" translate="yes" xml:space="preserve">
          <source>The syntax is fairly flexible and permissive; whitespaces are mostly ignored. The &lt;code&gt;#&lt;/code&gt; and &lt;code&gt;;&lt;/code&gt; characters begin comments to the end of line, blank lines are ignored.</source>
          <target state="translated">구문은 상당히 유연하고 허용 적입니다. 공백은 대부분 무시됩니다. &lt;code&gt;#&lt;/code&gt; 와 &lt;code&gt;;&lt;/code&gt; 문자는 줄 끝에 주석을 시작하고 빈 줄은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e9a240786337cb206c43c416821000b9a6721022" translate="yes" xml:space="preserve">
          <source>The syntax of the configuration files is that of Perl, since these files are handled by sourcing them as fragments of Perl code (the language that gitweb itself is written in). Variables are typically set using the &lt;code&gt;our&lt;/code&gt; qualifier (as in &quot;&lt;code&gt;our $variable = &amp;lt;value&amp;gt;;&lt;/code&gt;&quot;) to avoid syntax errors if a new version of gitweb no longer uses a variable and therefore stops declaring it.</source>
          <target state="translated">구성 파일의 구문은 Perl의 구문입니다. 이러한 파일은 파일을 Perl 코드 (gitweb 자체가 작성하는 언어)의 조각으로 소싱하여 처리되기 때문입니다. 변수는 일반적으로 사용되지 설정된 &lt;code&gt;our&lt;/code&gt; ( &quot;과 규정을 &lt;code&gt;our $variable = &amp;lt;value&amp;gt;;&lt;/code&gt; gitweb의 새 버전이 더 이상 변수를 사용하며, 따라서 선언 멈 추면 않도록 문법 에러&quot;).</target>
        </trans-unit>
        <trans-unit id="85d5722bf15562fb833fe3c8f580a92fe2e2d3db" translate="yes" xml:space="preserve">
          <source>The tables below show what happens when running:</source>
          <target state="translated">아래 표는 실행시 발생하는 상황을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0ab961c529e0da6916842ede03d74fc7b0e0f90e" translate="yes" xml:space="preserve">
          <source>The tag &lt;code&gt;v2.6.18&lt;/code&gt; is short for &lt;code&gt;refs/tags/v2.6.18&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v2.6.18&lt;/code&gt; 태그 는 &lt;code&gt;refs/tags/v2.6.18&lt;/code&gt; 의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="e5173af0305c1d6df2de24b7ea317c256f65109e" translate="yes" xml:space="preserve">
          <source>The template directory will be one of the following (in order):</source>
          <target state="translated">템플릿 디렉토리는 다음 중 하나입니다 (순서대로).</target>
        </trans-unit>
        <trans-unit id="45d4fdaf8fe9ac583ec50051c8f5eb8c944a1ec1" translate="yes" xml:space="preserve">
          <source>The term &lt;a href=&quot;#def_pickaxe&quot;&gt;pickaxe&lt;/a&gt; refers to an option to the diffcore routines that help select changes that add or delete a given text string. With the &lt;code&gt;--pickaxe-all&lt;/code&gt; option, it can be used to view the full &lt;a href=&quot;#def_changeset&quot;&gt;changeset&lt;/a&gt; that introduced or removed, say, a particular line of text. See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_pickaxe&quot;&gt;pickaxe&lt;/a&gt; 라는 용어 는 주어진 텍스트 문자열을 추가하거나 삭제하는 변경 사항을 선택하는 데 도움이되는 diffcore 루틴에 대한 옵션을 나타냅니다. 으로 &lt;code&gt;--pickaxe-all&lt;/code&gt; 옵션, 전체 볼 수 있습니다 &lt;a href=&quot;#def_changeset&quot;&gt;변경 집합을&lt;/a&gt; 말한다, 텍스트의 특정 라인을 도입하거나 제거 할 것이다. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2ba0595fa8d197d8c3640c03007e070ceba5b47" translate="yes" xml:space="preserve">
          <source>The text conversion is generally a one-way conversion; in this example, we lose the actual image contents and focus just on the text data. This means that diffs generated by textconv are &lt;em&gt;not&lt;/em&gt; suitable for applying. For this reason, only &lt;code&gt;git diff&lt;/code&gt; and the &lt;code&gt;git log&lt;/code&gt; family of commands (i.e., log, whatchanged, show) will perform text conversion. &lt;code&gt;git
format-patch&lt;/code&gt; will never generate this output. If you want to send somebody a text-converted diff of a binary file (e.g., because it quickly conveys the changes you have made), you should generate it separately and send it as a comment &lt;em&gt;in addition to&lt;/em&gt; the usual binary diff that you might send.</source>
          <target state="translated">텍스트 변환은 일반적으로 단방향 변환입니다. 이 예에서는 실제 이미지 내용을 잃고 텍스트 데이터에만 집중합니다. 이것은 textconv에 의해 생성 된 diff가 적용하기에 적합 &lt;em&gt;하지 않음을&lt;/em&gt; 의미합니다 . 따라서 &lt;code&gt;git diff&lt;/code&gt; 및 &lt;code&gt;git log&lt;/code&gt; 명령 계열 (즉, log, whatchanged, show) 만 텍스트 변환을 수행합니다. &lt;code&gt;git format-patch&lt;/code&gt; 는이 출력을 생성하지 않습니다. 누군가에게 이진 파일의 텍스트로 변환 된 diff를 보내려면 (예를 들어, 변경 한 내용을 빠르게 전달하기 때문에),이 파일을 별도로 생성 하여 일반적인 바이너리 diff &lt;em&gt;외에&lt;/em&gt; 주석으로 보내야합니다. 보내다.</target>
        </trans-unit>
        <trans-unit id="eb234a21c48fd769b7576108683d04bf29f253cb" translate="yes" xml:space="preserve">
          <source>The third syntax (&quot;&lt;code&gt;git merge --continue&lt;/code&gt;&quot;) can only be run after the merge has resulted in conflicts.</source>
          <target state="translated">세 번째 구문 ( &quot; &lt;code&gt;git merge --continue&lt;/code&gt; &quot;)은 병합이 충돌 한 후에 만 ​​실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a25be90a41e318ce76ddb9737f9c1a04e1e950e3" translate="yes" xml:space="preserve">
          <source>The time between the first rc release and the final release is supposed to be used to test rc versions and fight bugs and especially regressions. And this time is more than 80% of the release cycle time. But this is not the end of the fight yet, as of course it continues after the release.</source>
          <target state="translated">첫 번째 rc 릴리스와 마지막 릴리스 사이의 시간은 rc 버전을 테스트하고 버그 및 특히 회귀와 싸우는 데 사용됩니다. 그리고이 시간은 릴리스주기 시간의 80 % 이상입니다. 그러나 이것은 아직 싸움의 끝이 아니며, 물론 석방 후에도 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="75271c1b7d85cdfdc3bad04249d4464b9c292a44" translate="yes" xml:space="preserve">
          <source>The time of the change is specified by &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; using the date format that was selected by the --date-format=&amp;lt;fmt&amp;gt; command-line option. See &amp;ldquo;Date Formats&amp;rdquo; above for the set of supported formats, and their syntax.</source>
          <target state="translated">변경 시간은 --date-format = &amp;lt;fmt&amp;gt; 명령 줄 옵션에서 선택한 날짜 형식을 사용하여 &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; 에 의해 지정됩니다 . 지원되는 형식 세트와 구문은 위의 &quot;날짜 형식&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="05b9a4ac37ff05623171d65150ac27013efa2fa0" translate="yes" xml:space="preserve">
          <source>The time of the event is specified by &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; as the number of seconds since the UNIX epoch (midnight, Jan 1, 1970, UTC) and is written as an ASCII decimal integer.</source>
          <target state="translated">이벤트 &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; 은 UNIX 시간 (1970 년 1 월 1 일 자정, UTC) 이후의 초 수로 &amp;lt;time&amp;gt; 으로 지정되며 ASCII 10 진수 정수로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="e85bdfa8e02113c7aa36696add629ec632f05440" translate="yes" xml:space="preserve">
          <source>The todo list presented by the deprecated &lt;code&gt;--preserve-merges --interactive&lt;/code&gt; does not represent the topology of the revision graph (use &lt;code&gt;--rebase-merges&lt;/code&gt; instead). Editing commits and rewording their commit messages should work fine, but attempts to reorder commits tend to produce counterintuitive results. Use &lt;code&gt;--rebase-merges&lt;/code&gt; in such scenarios instead.</source>
          <target state="translated">더 이상 사용되지 않는 &lt;code&gt;--preserve-merges --interactive&lt;/code&gt; 로 표시되는 할 일 목록 은 개정 그래프의 토폴로지를 나타내지 않습니다 ( 대신 &lt;code&gt;--rebase-merges&lt;/code&gt; 를 사용하십시오). 커밋을 편집하고 커밋 메시지를 바꾸면 커밋 순서를 바꾸려고 시도하면 반 직관적 인 결과를 얻는 경향이 있습니다. 사용 &lt;code&gt;--rebase-merges&lt;/code&gt; 대신 같은 시나리오를.</target>
        </trans-unit>
        <trans-unit id="0f8166907df228eb9266d7566c3cde991d9d39bd" translate="yes" xml:space="preserve">
          <source>The total number of paths.</source>
          <target state="translated">총 경로 수</target>
        </trans-unit>
        <trans-unit id="46c0269533706ef03961ed4548e480cdcfd7a84a" translate="yes" xml:space="preserve">
          <source>The trailer records 20-byte SHA-1 checksum of all of the above.</source>
          <target state="translated">트레일러는 위의 모든 것의 20 바이트 SHA-1 체크섬을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="b9ae27ef547547fea9cd9f5b91bb86a4c8f93238" translate="yes" xml:space="preserve">
          <source>The trailer records a pack checksum of all of the above.</source>
          <target state="translated">The trailer records a pack checksum of all of the above.</target>
        </trans-unit>
        <trans-unit id="9380254df0eb0e126f55d72177d625190ab23928" translate="yes" xml:space="preserve">
          <source>The transmission of the packfile begins immediately after the section header</source>
          <target state="translated">팩 파일의 전송은 섹션 헤더 바로 다음에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="de285c430d2e1f897693d7ccc23434e1a3a5c103" translate="yes" xml:space="preserve">
          <source>The tree object is the tree we examined first, and this commit is unusual in that it lacks any parent.</source>
          <target state="translated">트리 객체는 우리가 먼저 검사 한 트리이며,이 커밋은 부모가 없다는 점에서 특이합니다.</target>
        </trans-unit>
        <trans-unit id="9178b43dc9b2907a6afd7a3693f2c6894ec0ecd9" translate="yes" xml:space="preserve">
          <source>The tree of actual checked out files. The working tree normally contains the contents of the &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; commit&amp;rsquo;s tree, plus any local changes that you have made but not yet committed.</source>
          <target state="translated">실제로 체크 아웃 된 파일의 트리입니다. 작업 트리에는 일반적으로 &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; 커밋 트리 의 내용과 함께 아직 커밋하지 않은 로컬 변경 내용이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="26b5c7d70f82997ceabb111adeeb911e4d89a340" translate="yes" xml:space="preserve">
          <source>The tree or commit to produce an archive for.</source>
          <target state="translated">아카이브를 생성하기위한 트리 또는 커밋.</target>
        </trans-unit>
        <trans-unit id="90f78952a054862b4ed6d79982e2eab2fc081a24" translate="yes" xml:space="preserve">
          <source>The twist is that if some file doesn&amp;rsquo;t match the index, we don&amp;rsquo;t have a backing store thing for it, and we use the magic &quot;all-zero&quot; sha1 to show that. So let&amp;rsquo;s say that you have edited &lt;code&gt;kernel/sched.c&lt;/code&gt;, but have not actually done a &lt;code&gt;git update-index&lt;/code&gt; on it yet - there is no &quot;object&quot; associated with the new state, and you get:</source>
          <target state="translated">일부 파일이 색인과 일치하지 않으면 백업 저장소가 없으며 마술 &quot;0&quot;sha1을 사용하여 표시합니다. 따라서 &lt;code&gt;kernel/sched.c&lt;/code&gt; 를 편집 했지만 실제로 &lt;code&gt;git update-index&lt;/code&gt; 를 아직 수행하지 않았다고 가정 해 봅시다 . 새로운 상태와 관련된 &quot;객체&quot;가 없으며 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="43d0ee9ad50c1c3c133c4c2ff3f216463ab119aa" translate="yes" xml:space="preserve">
          <source>The two options can be specified together to ask a command to work on both the index and the working tree.</source>
          <target state="translated">인덱스와 작업 트리 모두에서 작동하도록 명령을 요청하기 위해 두 옵션을 함께 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="293c342524c5d665ec090c34f37c73d153be74d5" translate="yes" xml:space="preserve">
          <source>The type of the object (&lt;code&gt;blob&lt;/code&gt;, &lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;tag&lt;/code&gt;).</source>
          <target state="translated">객체의 유형 ( &lt;code&gt;blob&lt;/code&gt; , &lt;code&gt;tree&lt;/code&gt; , &lt;code&gt;commit&lt;/code&gt; , &lt;code&gt;tag&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="35ca6d49608b210b7cf8be4b86261fa4bd55e249" translate="yes" xml:space="preserve">
          <source>The type of the object (the same as &lt;code&gt;cat-file -t&lt;/code&gt; reports).</source>
          <target state="translated">개체 유형 ( &lt;code&gt;cat-file -t&lt;/code&gt; 보고서 와 동일 )</target>
        </trans-unit>
        <trans-unit id="a4f9324e934e3998d2ea50e9e2c5152c5cb8ca76" translate="yes" xml:space="preserve">
          <source>The typical usage is to set just the &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; variables; the other options are provided for more complex use cases.</source>
          <target state="translated">The typical usage is to set just the &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; variables; the other options are provided for more complex use cases.</target>
        </trans-unit>
        <trans-unit id="4785efb96aaa5561500dccbb8420f79e52290b85" translate="yes" xml:space="preserve">
          <source>The underlying Git plumbing tools, such as &lt;code&gt;git ls-files&lt;/code&gt; and &lt;code&gt;git read-tree&lt;/code&gt;, read &lt;code&gt;gitignore&lt;/code&gt; patterns specified by command-line options, or from files specified by command-line options. Higher-level Git tools, such as &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git add&lt;/code&gt;, use patterns from the sources specified above.</source>
          <target state="translated">&lt;code&gt;git ls-files&lt;/code&gt; 및 &lt;code&gt;git read-tree&lt;/code&gt; 와 같은 기본 Git 배관 도구 는 명령 행 옵션으로 지정된 &lt;code&gt;gitignore&lt;/code&gt; 패턴을 읽 거나 명령 행 옵션으로 지정된 파일에서 읽습니다 . &lt;code&gt;git status&lt;/code&gt; 및 &lt;code&gt;git add&lt;/code&gt; 와 같은 상위 레벨 Git 도구는 위에 지정된 소스의 패턴을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c7717dd458d0c51efaa12d77d8ac91e6b1b7952a" translate="yes" xml:space="preserve">
          <source>The unique identifier of an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;. The object name is usually represented by a 40 character hexadecimal string. Also colloquially called &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_object&quot;&gt;객체&lt;/a&gt; 의 고유 식별자입니다 . 오브젝트 이름은 일반적으로 40 자 16 진 문자열로 표시됩니다. 구어 적으로 &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; 이라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="190c2fffcaa0444f677f39ee7f8533684a0964b1" translate="yes" xml:space="preserve">
          <source>The unit of storage in Git. It is uniquely identified by the &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; of its contents. Consequently, an object cannot be changed.</source>
          <target state="translated">Git의 저장 단위. 내용 의 &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; 로 고유하게 식별됩니다 . 따라서 개체를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="39871fae2a5575ced5627a5aed0eb792e4c6cc2e" translate="yes" xml:space="preserve">
          <source>The untracked cache extension can be enabled by the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">추적되지 않은 캐시 확장은 &lt;code&gt;core.untrackedCache&lt;/code&gt; 구성 변수에 의해 활성화 될 수 있습니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cc7260429a75073116cdc4eb67dbd95326cbd29d" translate="yes" xml:space="preserve">
          <source>The upstream project is expected to have the commit named by &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; and the output asks it to integrate the changes you made since that commit, up to the commit named by &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt;, by visiting the repository named by &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">업스트림 프로젝트는 &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; 라는 커밋을 가질 것으로 예상되며 출력은 &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; 이라는 리포지토리를 방문하여 커밋 이후 변경 사항을 &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; 라는 커밋까지 통합하도록 요청합니다 .</target>
        </trans-unit>
        <trans-unit id="90c1df21766dd92e926e4168cc9d516f756c7832" translate="yes" xml:space="preserve">
          <source>The upstream reference is generally &lt;code&gt;refs/remotes/p4/master&lt;/code&gt;, but can be overridden using the &lt;code&gt;--origin=&lt;/code&gt; command-line option.</source>
          <target state="translated">업스트림 참조는 일반적으로 &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; 이지만 &lt;code&gt;--origin=&lt;/code&gt; 명령 줄 옵션을 사용하여 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26e6d639f86a47deca57ab3911edaae9c5141f38" translate="yes" xml:space="preserve">
          <source>The user wants to fast-forward to $M.</source>
          <target state="translated">사용자는 $ M으로 빨리 감기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="6df61c6f9e257fdbf1ce4a60fb1d73b618d329ca" translate="yes" xml:space="preserve">
          <source>The user&amp;rsquo;s color.status configuration is not respected; color will always be off.</source>
          <target state="translated">사용자의 color.status 구성은 존중되지 않습니다. 색상은 항상 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab6a20b222f27dba657bc91ae7970effd7a690ca" translate="yes" xml:space="preserve">
          <source>The user&amp;rsquo;s status.relativePaths configuration is not respected; paths shown will always be relative to the repository root.</source>
          <target state="translated">사용자의 status.relativePaths 구성은 존중되지 않습니다. 표시된 경로는 항상 저장소 루트를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="20126eaca194f3ace1deaba2aaa4133e6326b674" translate="yes" xml:space="preserve">
          <source>The user-provided shell commands will likely involve a pipeline of commands, resulting in the creation of many processes per commit. Creating and running another process takes a widely varying amount of time between operating systems, but on any platform it is very slow relative to invoking a function.</source>
          <target state="translated">사용자가 제공 한 셸 명령에는 명령 파이프 라인이 포함되어 커밋 당 많은 프로세스가 만들어집니다. 다른 프로세스를 작성하고 실행하는 데는 운영 체제마다 시간이 많이 걸리지 만 플랫폼에 관계없이 함수 호출에 비해 속도가 느립니다.</target>
        </trans-unit>
        <trans-unit id="b70cc2efdcbaf68bada34e0550746a0012d52bae" translate="yes" xml:space="preserve">
          <source>The username to use when logging in to the server.</source>
          <target state="translated">서버에 로그인 할 때 사용할 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="46c33e134557b27ccb1a85349808f80ba518bd84" translate="yes" xml:space="preserve">
          <source>The valid values for this option are: &lt;code&gt;add&lt;/code&gt; (this is the default) and &lt;code&gt;doNothing&lt;/code&gt;.</source>
          <target state="translated">이 옵션의 유효한 값은 &lt;code&gt;add&lt;/code&gt; (이것이 기본값 임) 및 &lt;code&gt;doNothing&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="17a990c606d2e2e22a8f755a1f843b57ef2f5ef2" translate="yes" xml:space="preserve">
          <source>The valid values for this option are: &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; (this is the default), &lt;code&gt;addIfDifferent&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt; or &lt;code&gt;doNothing&lt;/code&gt;.</source>
          <target state="translated">이 옵션의 유효한 값은 &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; (이것이 기본값 임), &lt;code&gt;addIfDifferent&lt;/code&gt; , &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;replace&lt;/code&gt; 또는 &lt;code&gt;doNothing&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="505e929c5c3b27eed17b03a2625718de5c7f7031" translate="yes" xml:space="preserve">
          <source>The value for a variable that takes a color is a list of colors (at most two, one for foreground and one for background) and attributes (as many as you want), separated by spaces.</source>
          <target state="translated">색상을 취하는 변수의 값은 공백으로 구분 된 색상 (최대 2 개, 전경 및 1) 및 속성 (원하는 수) 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e1d242fc18797a443a86ba553d48e3f3cae01e9a" translate="yes" xml:space="preserve">
          <source>The value for many variables that specify various sizes can be suffixed with &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt;,&amp;hellip;​ to mean &quot;scale the number by 1024&quot;, &quot;by 1024x1024&quot;, etc.</source>
          <target state="translated">다양한 크기를 지정하는 많은 변수의 값은 &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;M&lt;/code&gt; 으로 접미사를 붙일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1dedc58ec3c676ad597a786553123421e517365" translate="yes" xml:space="preserve">
          <source>The value is a list of three values: a default time zone (for if the client hasn&amp;rsquo;t selected some other time zone and saved it in a cookie), a name of cookie where to store selected time zone, and a CSS class used to mark up dates for manipulation. If you want to turn this feature off, set &quot;default&quot; to empty list: &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">이 값은 기본 시간대 (클라이언트가 다른 시간대를 선택하지 않고 쿠키에 저장 한 경우), 선택한 시간대를 저장할 쿠키 이름 및 사용 된 CSS 클래스의 세 가지 값 목록입니다. 조작 날짜를 표시합니다. 이 기능을 끄려면 &quot;default&quot;를 빈 목록으로 설정하십시오 : &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0462ada8e80b752f4ecad69fb2563ec0b8b930aa" translate="yes" xml:space="preserve">
          <source>The value of 'default' is a list of names of snapshot formats, defined in &lt;code&gt;%known_snapshot_formats&lt;/code&gt; hash, that you wish to offer. Supported formats include &quot;tgz&quot;, &quot;tbz2&quot;, &quot;txz&quot; (gzip/bzip2/xz compressed tar archive) and &quot;zip&quot;; please consult gitweb sources for a definitive list. By default only &quot;tgz&quot; is offered.</source>
          <target state="translated">'default'값은 제공하려는 &lt;code&gt;%known_snapshot_formats&lt;/code&gt; 해시에 정의 된 스냅 샷 형식의 이름 목록입니다 . 지원되는 형식은 &quot;tgz&quot;, &quot;tbz2&quot;, &quot;txz&quot;(gzip / bzip2 / xz 압축 tar 아카이브) 및 &quot;zip&quot;입니다. 결정적인 목록은 gitweb 소스를 참조하십시오. 기본적으로 &quot;tgz&quot;만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c34b53e9a12553098df9adad4c30762484ffde18" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; must be a valid refname in Git and therefore may contain forward slashes. As &lt;code&gt;LF&lt;/code&gt; is not valid in a Git refname, no quoting or escaping syntax is supported here.</source>
          <target state="translated">&lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 의 값은 Git에서 유효한 참조 이름 이어야하므로 슬래시를 포함 할 수 있습니다. 으로 &lt;code&gt;LF&lt;/code&gt; 가 힘내 refname에 유효하지 않은, 더 인용 또는 이스케이프 구문은 여기에 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b5a30f586808b1827fdb8f433a15c6c9d49f6ba" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; must be in canonical form. That is it must not:</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 의 값은 정식 형식이어야합니다. 그것은해서는 안됩니다 :</target>
        </trans-unit>
        <trans-unit id="dfb2ec984e9987b1b930824861a3abbf3e4aa29f" translate="yes" xml:space="preserve">
          <source>The value of this attribute specifies the character encoding that should be used by GUI tools (e.g. &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; and &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;) to display the contents of the relevant file. Note that due to performance considerations &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; does not use this attribute unless you manually enable per-file encodings in its options.</source>
          <target state="translated">이 속성의 값은 GUI 도구 (예 : &lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt; 및 &lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt; )가 관련 파일의 내용을 표시하는 데 사용해야하는 문자 인코딩을 지정 합니다. 성능 고려 사항으로 인해 &lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt; 은 옵션에서 파일 별 인코딩을 수동으로 활성화하지 않는 한이 속성을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4bdcd2a8dee01aee6c5f0f23e7e10ac25985aae6" translate="yes" xml:space="preserve">
          <source>The value of this key is the name of the promisor remote.</source>
          <target state="translated">이 키의 값은 Promisor Remote의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="49e3be97b83e2e2d47823db7b33592c5066364cc" translate="yes" xml:space="preserve">
          <source>The version parameter is used to specify the format version. This is optional and defaults to the original version &lt;code&gt;v1&lt;/code&gt; format.</source>
          <target state="translated">version 매개 변수는 형식 버전을 지정하는 데 사용됩니다. 이것은 선택 사항이며 기본값은 원래 버전 &lt;code&gt;v1&lt;/code&gt; 형식입니다.</target>
        </trans-unit>
        <trans-unit id="a720bc9826a296e909d26ea1e1addd2076945090" translate="yes" xml:space="preserve">
          <source>The victim sends &quot;have&quot; lines advertising the IDs of objects it has that are not explicitly intended to be shared but can be used to optimize the transfer if the peer also has them. The attacker chooses an object ID X to steal and sends a ref to X, but isn&amp;rsquo;t required to send the content of X because the victim already has it. Now the victim believes that the attacker has X, and it sends the content of X back to the attacker later. (This attack is most straightforward for a client to perform on a server, by creating a ref to X in the namespace the client has access to and then fetching it. The most likely way for a server to perform it on a client is to &quot;merge&quot; X into a public branch and hope that the user does additional work on this branch and pushes it back to the server without noticing the merge.)</source>
          <target state="translated">피해자는 명시 적으로 공유 할 의도는 없지만 피어가 가지고있는 경우 전송을 최적화하는 데 사용할 수있는 오브젝트의 ID를 알리는 &quot;have&quot;라인을 보냅니다. 공격자는 개체 ID X를 선택하여 도용하고 참조를 X에 보냅니다. 그러나 피해자가 이미 가지고 있기 때문에 X의 내용을 보낼 필요는 없습니다. 이제 피해자는 공격자가 X를 가지고 있다고 믿고 나중에 X의 내용을 공격자에게 다시 보냅니다. (이 공격은 클라이언트가 액세스 할 수있는 네임 스페이스에서 X에 대한 참조를 생성 한 후 가져 와서 클라이언트가 서버에서 수행 할 수있는 가장 간단한 방법입니다. X를 공개 브랜치로 병합하고 사용자가이 브랜치에서 추가 작업을 수행하고 병합을 알리지 않고 서버로 다시 밀어 넣기를 바랍니다.)</target>
        </trans-unit>
        <trans-unit id="bad569f9e07003c7e9ba90b91ff6d5e2d3ebab92" translate="yes" xml:space="preserve">
          <source>The virtual host configuration (in Apache configuration file) should look like this:</source>
          <target state="translated">Apache 구성 파일의 가상 호스트 구성은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="6258db9fdd3beac891e6dcfd7dedb19764ce413e" translate="yes" xml:space="preserve">
          <source>The way &lt;code&gt;git update-index&lt;/code&gt; handles files it is told about can be modified using the various options:</source>
          <target state="translated">&lt;code&gt;git update-index&lt;/code&gt; 가 파일을 처리 하는 방식 은 다양한 옵션을 사용하여 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae6c5b18c0fd18e4f577ab3723eb5808f05d9f12" translate="yes" xml:space="preserve">
          <source>The web browser can be specified using the configuration variable &lt;code&gt;help.browser&lt;/code&gt;, or &lt;code&gt;web.browser&lt;/code&gt; if the former is not set. If none of these config variables is set, the &lt;code&gt;git web--browse&lt;/code&gt; helper script (called by &lt;code&gt;git help&lt;/code&gt;) will pick a suitable default. See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt; for more information about this.</source>
          <target state="translated">The web browser can be specified using the configuration variable &lt;code&gt;help.browser&lt;/code&gt; , or &lt;code&gt;web.browser&lt;/code&gt; if the former is not set. If none of these config variables is set, the &lt;code&gt;git web--browse&lt;/code&gt; helper script (called by &lt;code&gt;git help&lt;/code&gt; ) will pick a suitable default. See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt; for more information about this.</target>
        </trans-unit>
        <trans-unit id="dc2adc08265063993fb836b81a622f1e26249d55" translate="yes" xml:space="preserve">
          <source>The web browser can be specified using the configuration variable &lt;code&gt;help.browser&lt;/code&gt;, or &lt;code&gt;web.browser&lt;/code&gt; if the former is not set. If none of these config variables is set, the &lt;code&gt;git web{litdd}browse&lt;/code&gt; helper script (called by &lt;code&gt;git help&lt;/code&gt;) will pick a suitable default. See git-web{litdd}browse[1] for more information about this.</source>
          <target state="translated">구성 변수 &lt;code&gt;help.browser&lt;/code&gt; 또는 &lt;code&gt;web.browser&lt;/code&gt; 를 설정하지 않은 경우 웹 브라우저를 지정할 수 있습니다 . 이러한 구성 변수가 설정되지 않은 경우 &lt;code&gt;git web{litdd}browse&lt;/code&gt; 도우미 스크립트 ( &lt;code&gt;git help&lt;/code&gt; 라고 함 )가 적절한 기본값을 선택합니다. 이에 대한 자세한 내용은 git-web {litdd} browse [1]를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d52f23a775c5f3aadffb0193202482a8a4b8d0b1" translate="yes" xml:space="preserve">
          <source>The web browser that should be used to view the gitweb page. This will be passed to the &lt;code&gt;git web--browse&lt;/code&gt; helper script along with the URL of the gitweb instance. See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt; for more information about this. If the script fails, the URL will be printed to stdout.</source>
          <target state="translated">The web browser that should be used to view the gitweb page. This will be passed to the &lt;code&gt;git web--browse&lt;/code&gt; helper script along with the URL of the gitweb instance. See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt; for more information about this. If the script fails, the URL will be printed to stdout.</target>
        </trans-unit>
        <trans-unit id="c38f40c77930468f76ac59e3f127231f37c11803" translate="yes" xml:space="preserve">
          <source>The web browser that should be used to view the gitweb page. This will be passed to the &lt;code&gt;git web{litdd}browse&lt;/code&gt; helper script along with the URL of the gitweb instance. See git-web{litdd}browse[1] for more information about this. If the script fails, the URL will be printed to stdout.</source>
          <target state="translated">gitweb 페이지를 보는 데 사용해야하는 웹 브라우저. 이것은 gitweb 인스턴스의 URL과 함께 &lt;code&gt;git web{litdd}browse&lt;/code&gt; 도우미 스크립트 로 전달됩니다 . 이에 대한 자세한 내용은 git-web {litdd} browse [1]를 참조하십시오. 스크립트가 실패하면 URL이 표준 출력으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="c7492cc5fa9e9927a227312bd1f1ea85a3766cb5" translate="yes" xml:space="preserve">
          <source>The width (in characters) of the &quot;Description&quot; column of the projects list. Longer descriptions will be truncated (trying to cut at word boundary); the full description is available in the &lt;code&gt;title&lt;/code&gt; attribute (usually shown on mouseover). The default is 25, which might be too small if you use long project descriptions.</source>
          <target state="translated">프로젝트 목록의 &quot;설명&quot;열의 너비 (문자)입니다. 더 긴 설명은 잘립니다 (단어 경계에서 자르려고 시도 함). 자세한 설명은 &lt;code&gt;title&lt;/code&gt; 속성 (일반적으로 마우스 오버에 표시)에서 사용할 수 있습니다 . 기본값은 25이며, 긴 프로젝트 설명을 사용하면 너무 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a9553b8b798d28f6c8fd9f09980f5b7959498e9" translate="yes" xml:space="preserve">
          <source>The window size parameter used in the delta compression algorithm used by &lt;code&gt;git gc --aggressive&lt;/code&gt;. This defaults to 250, which is a much more aggressive window size than the default &lt;code&gt;--window&lt;/code&gt; of 10.</source>
          <target state="translated">&lt;code&gt;git gc --aggressive&lt;/code&gt; 가 사용하는 델타 압축 알고리즘에 사용되는 창 크기 매개 변수 입니다. 기본값은 250으로, 기본 &lt;code&gt;--window&lt;/code&gt; 10 보다 훨씬 공격적인 창 크기 입니다.</target>
        </trans-unit>
        <trans-unit id="046739930d5e8946cdceaf820a70c4ac9ebc8d51" translate="yes" xml:space="preserve">
          <source>The working directory then reflects the contents that the project had when it was tagged v2.6.13, and &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; shows two branches, with an asterisk marking the currently checked-out branch:</source>
          <target state="translated">작업 디렉토리는 프로젝트가 v2.6.13으로 태그 될 때 가지고 있던 내용을 반영하고 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; 은 현재 체크 아웃 된 분기를 표시하는 별표와 함께 두 개의 분기를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c76d23bfcb6d4a63fd96acda23f8bee068090518" translate="yes" xml:space="preserve">
          <source>The worktree list command has two output formats. The default format shows the details on a single line with columns. For example:</source>
          <target state="translated">worktree list 명령에는 두 가지 출력 형식이 있습니다. 기본 형식은 열이있는 단일 행에 세부 사항을 표시합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ecaf7c5f30215b083ffbd406549425a7d1040c7d" translate="yes" xml:space="preserve">
          <source>Then &quot;&lt;code&gt;git merge topic&lt;/code&gt;&quot; will replay the changes made on the &lt;code&gt;topic&lt;/code&gt; branch since it diverged from &lt;code&gt;master&lt;/code&gt; (i.e., &lt;code&gt;E&lt;/code&gt;) until its current commit (&lt;code&gt;C&lt;/code&gt;) on top of &lt;code&gt;master&lt;/code&gt;, and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes.</source>
          <target state="translated">그런 다음 &quot; &lt;code&gt;git merge topic&lt;/code&gt; &quot;는에 변경 사항 재생됩니다 &lt;code&gt;topic&lt;/code&gt; 는에서 분기 이후 분기 &lt;code&gt;master&lt;/code&gt; (즉, &lt;code&gt;E&lt;/code&gt; 현재는 (커밋 될 때까지) &lt;code&gt;C&lt;/code&gt; 의 상단에) &lt;code&gt;master&lt;/code&gt; 의 이름과 함께 커밋, 새로운의 결과를 기록 부모 커밋 두 개와 변경 사항을 설명하는 사용자의 로그 메시지</target>
        </trans-unit>
        <trans-unit id="f3bf49c80f1bf671798b336ee7a6337eb982b2bc" translate="yes" xml:space="preserve">
          <source>Then &quot;&lt;code&gt;git pull&lt;/code&gt;&quot; will fetch and replay the changes from the remote &lt;code&gt;master&lt;/code&gt; branch since it diverged from the local &lt;code&gt;master&lt;/code&gt; (i.e., &lt;code&gt;E&lt;/code&gt;) until its current commit (&lt;code&gt;C&lt;/code&gt;) on top of &lt;code&gt;master&lt;/code&gt; and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes.</source>
          <target state="translated">그런 다음 &quot; &lt;code&gt;git pull&lt;/code&gt; &quot;가져 오기 및 원격의 변경 재생됩니다 &lt;code&gt;master&lt;/code&gt; 는 지역에서 분기 이후 분기를 &lt;code&gt;master&lt;/code&gt; (즉, &lt;code&gt;E&lt;/code&gt; ) 현재 커밋 될 때까지 ( &lt;code&gt;C&lt;/code&gt; 위에) &lt;code&gt;master&lt;/code&gt; 과 함께 커밋하고 새에 결과를 기록 두 개의 상위 커밋 이름과 사용자가 변경 내용을 설명하는 로그 메시지.</target>
        </trans-unit>
        <trans-unit id="44f92500b7ae9560ae64e2f2fc4f1af900d3ff26" translate="yes" xml:space="preserve">
          <source>Then &quot;git bisect&quot; will checkout a commit of its choosing and ask the user to test it, like this:</source>
          <target state="translated">그런 다음 &quot;git bisect&quot;는 선택한 커밋을 체크 아웃하고 사용자에게 다음과 같이 테스트하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="e1ef052a3cd59f805d0ae45d1b9033a6a2faaa95" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;git bisect&lt;/code&gt; will respond with something like</source>
          <target state="translated">그런 다음 &lt;code&gt;git bisect&lt;/code&gt; 는 다음과 같이 응답합니다.</target>
        </trans-unit>
        <trans-unit id="307236a389d15c9e88cc574f3c2b3a0314992840" translate="yes" xml:space="preserve">
          <source>Then compile and test the chosen revision, and afterwards mark the revision as good or bad in the usual manner.</source>
          <target state="translated">그런 다음 선택한 개정을 컴파일하고 테스트 한 후 일반적인 방식으로 개정을 양호 또는 불량으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="876e252bd62eb2a97f748800c6625b2b00ccfdec" translate="yes" xml:space="preserve">
          <source>Then confirm that the bug persists in a repository created from that stream (many bugs will not, as they really do depend on the exact repository contents):</source>
          <target state="translated">그런 다음 해당 스트림에서 생성 된 리포지토리에 버그가 지속되는지 확인합니다 (정확한 리포지토리 내용에 따라 많은 버그가 발생하지 않음).</target>
        </trans-unit>
        <trans-unit id="87463a5d117dae6022935ddfd68f09bfbb9b0943" translate="yes" xml:space="preserve">
          <source>Then create the following script to get list of project in the format suitable for GITWEB_LIST build configuration variable (or &lt;code&gt;$projects_list&lt;/code&gt; variable in gitweb config):</source>
          <target state="translated">그런 다음 GITWEB_LIST 빌드 구성 변수 (또는 gitweb config의 &lt;code&gt;$projects_list&lt;/code&gt; 변수)에 적합한 형식으로 프로젝트 목록을 가져 오려면 다음 스크립트를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5a742d8577423cd13ed5705b5290de27ff73949" translate="yes" xml:space="preserve">
          <source>Then fixup &quot;master&quot; with &lt;code&gt;git rebase&lt;/code&gt;. Do NOT use &lt;code&gt;git merge&lt;/code&gt; or your history will not be compatible with a future &lt;code&gt;dcommit&lt;/code&gt;!</source>
          <target state="translated">그런 다음 &lt;code&gt;git rebase&lt;/code&gt; 로 &quot;master&quot;를 수정하십시오 . &lt;code&gt;git merge&lt;/code&gt; 를 사용하지 마십시오. 그러면 히스토리는 향후 &lt;code&gt;dcommit&lt;/code&gt; 과 호환되지 않습니다 !</target>
        </trans-unit>
        <trans-unit id="78318329e21f0014f75ba54a708b1f46ad0d023c" translate="yes" xml:space="preserve">
          <source>Then it compares the new skip-worktree value with the previous one. If skip-worktree turns from set to unset, it will add the corresponding file back. If it turns from unset to set, that file will be removed.</source>
          <target state="translated">그런 다음 새로운 skip-worktree 값과 이전 skip-worktree 값을 비교합니다. skip-worktree가 set에서 unset으로 바뀌면 해당 파일이 다시 추가됩니다. 설정되지 않은 상태에서 설정 상태로 바뀌면 해당 파일이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5e9c59419a3e5d8568740259a39319d49129c624" translate="yes" xml:space="preserve">
          <source>Then it examines &lt;code&gt;.gitattributes&lt;/code&gt; (which is in the parent directory), and finds that the first line matches, but &lt;code&gt;t/.gitattributes&lt;/code&gt; file already decided how &lt;code&gt;merge&lt;/code&gt;, &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; attributes should be given to this path, so it leaves &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; unset. Attribute &lt;code&gt;baz&lt;/code&gt; is set.</source>
          <target state="translated">그런 다음 &lt;code&gt;.gitattributes&lt;/code&gt; (부모 디렉토리에 있음)를 검사 하고 첫 번째 줄이 일치하는 것을 발견하지만 &lt;code&gt;t/.gitattributes&lt;/code&gt; 파일은 이미 &lt;code&gt;merge&lt;/code&gt; , &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 속성 이이 경로에 제공되어야 하는 방법을 결정 했기 때문에 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 를 남깁니다. 설정되지 않았습니다. 속성 &lt;code&gt;baz&lt;/code&gt; 가 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="1100f313a3d209e54bf3bc725a364711886dbfc4" translate="yes" xml:space="preserve">
          <source>Then modify, reorder, or eliminate patches as needed before applying them again with &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;git-am&quot;&gt;git-am [1]으로&lt;/a&gt; 패치를 다시 적용하기 전에 필요에 따라 패치를 수정, 재 배열 또는 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd43ef848f2d3c4afb2a44ae28c2a413397c1d96" translate="yes" xml:space="preserve">
          <source>Then provide your password via the pserver method, for example:</source>
          <target state="translated">그런 다음 pserver 메소드를 통해 비밀번호를 제공하십시오 (예 :</target>
        </trans-unit>
        <trans-unit id="a774f276f116b48d127c0c1418ef7aa2fe46b49b" translate="yes" xml:space="preserve">
          <source>Then simplify each commit &lt;code&gt;C&lt;/code&gt; to its replacement &lt;code&gt;C'&lt;/code&gt; in the final history according to the following rules:</source>
          <target state="translated">그런 다음 다음 규칙에 따라 각 커밋 &lt;code&gt;C&lt;/code&gt; 를 최종 히스토리에서 대체 &lt;code&gt;C'&lt;/code&gt; 로 단순화 하십시오.</target>
        </trans-unit>
        <trans-unit id="2f5d7fdcf8fcb013dcf3c597507de91a5cb0f77d" translate="yes" xml:space="preserve">
          <source>Then simply fork your topic branches from the stable remotes as explained earlier.</source>
          <target state="translated">그런 다음 앞에서 설명한대로 안정된 리모컨에서 주제 분기를 포크하면됩니다.</target>
        </trans-unit>
        <trans-unit id="b19a7b2e2b2e2252f0564256c9b87915d5db46d3" translate="yes" xml:space="preserve">
          <source>Then suppose you modify the last three commits:</source>
          <target state="translated">그런 다음 마지막 3 개의 커밋을 수정한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e69e2e34d497710c4127a780d2a5ed5c7d7fac83" translate="yes" xml:space="preserve">
          <source>Then there are two ways to get a smaller repository. A safer way is to clone, that keeps your original intact.</source>
          <target state="translated">그런 다음 더 작은 저장소를 얻는 두 가지 방법이 있습니다. 더 안전한 방법은 복제하여 원본을 그대로 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5c871054b486e3acaf28dc409c1ab3e693b4fc90" translate="yes" xml:space="preserve">
          <source>Then this &lt;code&gt;git p4 clone&lt;/code&gt; command:</source>
          <target state="translated">그런 다음이 &lt;code&gt;git p4 clone&lt;/code&gt; 명령 :</target>
        </trans-unit>
        <trans-unit id="db9b57b987ef397bc0b191d278e31ed2d827cb0a" translate="yes" xml:space="preserve">
          <source>Then you can disable sparse checkout. Sparse checkout support in &lt;code&gt;git read-tree&lt;/code&gt; and similar commands is disabled by default. You need to turn &lt;code&gt;core.sparseCheckout&lt;/code&gt; on in order to have sparse checkout support.</source>
          <target state="translated">그런 다음 스파 스 체크 아웃을 비활성화 할 수 있습니다. &lt;code&gt;git read-tree&lt;/code&gt; 및 유사한 명령 에서 스파 스 체크 아웃 지원은 기본적으로 비활성화되어 있습니다. 스파 스 체크 아웃을 지원하려면 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 을 켜야 합니다.</target>
        </trans-unit>
        <trans-unit id="87a33f516a8ffec885e906dbb29e388a5f30ada0" translate="yes" xml:space="preserve">
          <source>Then you can pull and merge, leaving &lt;code&gt;frotz.c&lt;/code&gt; and &lt;code&gt;filfre.c&lt;/code&gt; changes still in the working tree.</source>
          <target state="translated">그런 다음 &lt;code&gt;frotz.c&lt;/code&gt; 및 &lt;code&gt;filfre.c&lt;/code&gt; 변경 사항을 작업 트리에 그대로두고 끌어서 병합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa280cd97c17d646b4ce0e60bbbcb27953b34fb3" translate="yes" xml:space="preserve">
          <source>Then you can push both the test and release trees using &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;git-push&quot;&gt;git-push [1]을&lt;/a&gt; 사용하여 테스트 트리와 릴리스 트리를 모두 푸시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9015e54306232b9477b76c544780cb6cb29e184c" translate="yes" xml:space="preserve">
          <source>Then you might want a &lt;code&gt;.mailmap&lt;/code&gt; file that looks like:</source>
          <target state="translated">그러면 다음과 같은 &lt;code&gt;.mailmap&lt;/code&gt; 파일 이 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bdefcc2b7f4d341c71ca424367a0164c209ac375" translate="yes" xml:space="preserve">
          <source>Then you transfer file.bundle to the target machine B. Because this bundle does not require any existing object to be extracted, you can create a new repository on machine B by cloning from it:</source>
          <target state="translated">그런 다음 file.bundle을 대상 머신 B로 전송합니다.이 번들은 기존 오브젝트를 추출 할 필요가 없으므로 머신 B에서 복제하여 새 저장소를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e826c3727c0c79aa7b30f2352881ef1c5a35f171" translate="yes" xml:space="preserve">
          <source>Then you would define a &quot;filter.indent.clean&quot; and &quot;filter.indent.smudge&quot; configuration in your .git/config to specify a pair of commands to modify the contents of C programs when the source files are checked in (&quot;clean&quot; is run) and checked out (no change is made because the command is &quot;cat&quot;).</source>
          <target state="translated">그런 다음 .git / config에서 &quot;filter.indent.clean&quot;및 &quot;filter.indent.smudge&quot;구성을 정의하여 소스 파일이 체크인 될 때 ​​C 프로그램의 내용을 수정하는 명령 쌍을 지정합니다 ( &quot;clean &quot;가 실행 됨) 및 체크 아웃되었습니다 (명령이&quot;cat &quot;이므로 변경되지 않음).</target>
        </trans-unit>
        <trans-unit id="c6308f4c83137c8ddf705f0b33927bc3a2a2d3bf" translate="yes" xml:space="preserve">
          <source>Then, make that directory into a Git repository by running &lt;code&gt;git init&lt;/code&gt;, but this time, since its name is not the usual &lt;code&gt;.git&lt;/code&gt;, we do things slightly differently:</source>
          <target state="translated">그런 다음 &lt;code&gt;git init&lt;/code&gt; 를 실행하여 해당 디렉토리를 Git 저장소로 만드십시오 .하지만 이번에는 그 이름이 일반적인 &lt;code&gt;.git&lt;/code&gt; 이 아니기 때문에 약간 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4d45e0228f3dfbda52666260c02f45c435d7f13c" translate="yes" xml:space="preserve">
          <source>Then, use &lt;code&gt;git bisect &amp;lt;term-old&amp;gt;&lt;/code&gt; and &lt;code&gt;git bisect &amp;lt;term-new&amp;gt;&lt;/code&gt; instead of &lt;code&gt;git bisect good&lt;/code&gt; and &lt;code&gt;git bisect bad&lt;/code&gt; to mark commits.</source>
          <target state="translated">그런 다음 커밋을 표시하기 위해 &lt;code&gt;git bisect good&lt;/code&gt; 및 &lt;code&gt;git bisect bad&lt;/code&gt; 대신 &lt;code&gt;git bisect &amp;lt;term-old&amp;gt;&lt;/code&gt; 및 &lt;code&gt;git bisect &amp;lt;term-new&amp;gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b100177b4f5d14520d5631ccbd2bc2ff52393e78" translate="yes" xml:space="preserve">
          <source>Then, you run this command:</source>
          <target state="translated">그런 다음이 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ebbdc2314a6104dc9178c4c9ed7835ad78f84727" translate="yes" xml:space="preserve">
          <source>Then, you would define a &quot;diff.tex.xfuncname&quot; configuration to specify a regular expression that matches a line that you would want to appear as the hunk header &quot;TEXT&quot;. Add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">그런 다음 &quot;diff.tex.xfuncname&quot;구성을 정의하여 헝크 헤더 &quot;TEXT&quot;로 표시 할 행과 일치하는 정규식을 지정하십시오. &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 (또는 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 파일)에 다음과 같이 섹션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d94c9456285c171a8f18dcac7b76fd1fccc9ff4" translate="yes" xml:space="preserve">
          <source>There are (number of parents + 1) &lt;code&gt;@&lt;/code&gt; characters in the chunk header for combined diff format.</source>
          <target state="translated">결합 된 diff 형식의 청크 헤더 에는 (부모 수 + 1) &lt;code&gt;@&lt;/code&gt; 문자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7e9cf96a6ce9ed5c513750352c4736c076b5145" translate="yes" xml:space="preserve">
          <source>There are CPP wrapper macros and ifdefs to hide most of these details. See &lt;code&gt;trace2.h&lt;/code&gt; for more details. The following discussion will only describe the simplified forms.</source>
          <target state="translated">CPP 랩퍼 매크로와 ifdef는 대부분의 세부 사항을 숨길 수 있습니다. 자세한 내용은 &lt;code&gt;trace2.h&lt;/code&gt; 를 참조하십시오. 다음 설명에서는 단순화 된 양식 만 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e4287f1e47cb2bfc1b9e5f25165aef43ceec9d6c" translate="yes" xml:space="preserve">
          <source>There are a few built-in low-level merge drivers defined that can be asked for via the &lt;code&gt;merge&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 속성 을 통해 요청할 수있는 몇 가지 기본 제공 저수준 병합 드라이버가 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12f3989319ea3c0cba3d029a62ee2c306fd0616b" translate="yes" xml:space="preserve">
          <source>There are a few built-in patterns to make this easier, and &lt;code&gt;tex&lt;/code&gt; is one of them, so you do not have to write the above in your configuration file (you still need to enable this with the attribute mechanism, via &lt;code&gt;.gitattributes&lt;/code&gt;). The following built in patterns are available:</source>
          <target state="translated">이것을 쉽게하기 위해 몇 가지 내장 패턴이 있으며 &lt;code&gt;tex&lt;/code&gt; 는 그중 하나이므로 구성 파일에 위의 내용을 쓸 필요가 없습니다 (여전히 &lt;code&gt;.gitattributes&lt;/code&gt; 를 통해 속성 메커니즘으로 이것을 활성화해야합니다 ). 다음과 같은 내장 패턴을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="336d04ab3583042f88f12edf2d051324b94f62a0" translate="yes" xml:space="preserve">
          <source>There are a few issues to resolve before we can completely switch to Trace2.</source>
          <target state="translated">Trace2로 완전히 전환하기 전에 해결해야 할 몇 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8e0813ee0029806de1de3d5b367acd9c0a0d07d" translate="yes" xml:space="preserve">
          <source>There are a few more behavioral differences that most folks would probably consider inconsequential but which are mentioned for completeness:</source>
          <target state="translated">There are a few more behavioral differences that most folks would probably consider inconsequential but which are mentioned for completeness:</target>
        </trans-unit>
        <trans-unit id="f553cccafe9fdfa62552e6e1af4be573be245c47" translate="yes" xml:space="preserve">
          <source>There are a few special-purpose refs that do not begin with &lt;code&gt;refs/&lt;/code&gt;. The most notable example is &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;refs/&lt;/code&gt; 시작하지 않는 몇 가지 특수 목적 ref가 있습니다. 가장 주목할만한 예는 &lt;code&gt;HEAD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cc9f53378dabd08666f7e5c5af2a717dbbd37e28" translate="yes" xml:space="preserve">
          <source>There are a number of factors which affect how much memory fast-import requires to perform an import. Like critical sections of core Git, fast-import uses its own memory allocators to amortize any overheads associated with malloc. In practice fast-import tends to amortize any malloc overheads to 0, due to its use of large block allocations.</source>
          <target state="translated">가져 오기를 수행하기 위해 빠른 가져 오기에 필요한 메모리 양에 영향을주는 여러 가지 요소가 있습니다. 핵심 Git의 중요한 섹션과 마찬가지로 빠른 가져 오기는 자체 메모리 할당자를 사용하여 malloc과 관련된 모든 오버 헤드를 상각합니다. 실제로 빠른 가져 오기는 큰 블록 할당을 사용하기 때문에 malloc 오버 헤드를 0으로 상각하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0b2b532209e8b05d8ee20f67e782301986fd65a" translate="yes" xml:space="preserve">
          <source>There are also cases where existing indexes written by git versions before 2.17 will reference directories that don&amp;rsquo;t exist anymore, potentially causing many &quot;could not open directory&quot; warnings to be printed on &quot;git status&quot;. These are new warnings for existing issues that were previously silently discarded.</source>
          <target state="translated">2.17 이전의 git 버전으로 작성된 기존 인덱스가 더 이상 존재하지 않는 디렉토리를 참조하여 &quot;git status&quot;에 많은 &quot;디렉토리를 열 수 없음&quot;경고가 표시되는 경우도 있습니다. 이전에 자동으로 삭제 된 기존 문제에 대한 새로운 경고입니다.</target>
        </trans-unit>
        <trans-unit id="aec0acb7fb7522f7c5da2df9b13975842cb9d1be" translate="yes" xml:space="preserve">
          <source>There are also more complex operations that can be performed. But beware that because the patch is applied only to the index and not the working tree, the working tree will appear to &quot;undo&quot; the change in the index. For example, introducing a new line into the index that is in neither the HEAD nor the working tree will stage the new line for commit, but the line will appear to be reverted in the working tree.</source>
          <target state="translated">수행 할 수있는 더 복잡한 작업도 있습니다. 그러나 패치는 작업 트리가 아닌 인덱스에만 적용되므로 작업 트리는 인덱스 변경을 &quot;실행 취소&quot;하는 것처럼 보입니다. 예를 들어, HEAD 나 작업 트리에없는 색인에 새 줄을 도입하면 커밋을 위해 새 줄을 스테이징하지만 작업 트리에서 줄이 되돌아 간 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="a266660a35cd18470141c43d8a3ffa2b3074c06a" translate="yes" xml:space="preserve">
          <source>There are also other situations that cause dangling objects. For example, a &quot;dangling blob&quot; may arise because you did a &lt;code&gt;git add&lt;/code&gt; of a file, but then, before you actually committed it and made it part of the bigger picture, you changed something else in that file and committed that &lt;strong&gt;updated&lt;/strong&gt; thing&amp;mdash;​the old state that you added originally ends up not being pointed to by any commit or tree, so it&amp;rsquo;s now a dangling blob object.</source>
          <target state="translated">매달린 물체를 일으키는 다른 상황도 있습니다. 예를 들어, &quot;매달려 BLOB는&quot;당신이했기 때문에 발생할 수있는 &lt;code&gt;git add&lt;/code&gt; 당신이 실제로 노력과 더 큰 그림의 일부가 만든 전에, 다음의 파일을하지만, 그 파일에 다른 뭔가를 변경 한 것을 최선을 다하고 &lt;strong&gt;업데이트&lt;/strong&gt; 쿄코 원래 추가 한 이전 상태는 커밋이나 트리가 가리 키지 않으므로 이제 매달려있는 얼룩 개체입니다.</target>
        </trans-unit>
        <trans-unit id="232088d916b340ecad3098c72c2ebccbe30b76e5" translate="yes" xml:space="preserve">
          <source>There are also several operations which should be avoided entirely, as they will make the patch impossible to apply:</source>
          <target state="translated">패치를 적용 할 수 없게하므로 완전히 피해야하는 여러 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eeb0752be9462c9bd2e54575f2023419e06b3d3b" translate="yes" xml:space="preserve">
          <source>There are also ways to automate the bisecting process if you have a test script that can tell a good from a bad commit. See &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; for more information about this and other &lt;code&gt;git
bisect&lt;/code&gt; features.</source>
          <target state="translated">잘못된 커밋에서 좋은 것을 알 수있는 테스트 스크립트가있는 경우 이등분 프로세스를 자동화하는 방법도 있습니다. 참조 &lt;a href=&quot;git-bisect&quot;&gt;자식-양분 [1]&lt;/a&gt; 및 기타에 대한 자세한 내용은 &lt;code&gt;git bisect&lt;/code&gt; 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="753d0dde7d0dbacd496fb113e3e96e5ea6d9494d" translate="yes" xml:space="preserve">
          <source>There are four different types of objects: &quot;blob&quot;, &quot;tree&quot;, &quot;commit&quot;, and &quot;tag&quot;.</source>
          <target state="translated">&quot;blob&quot;, &quot;tree&quot;, &quot;commit&quot;및 &quot;tag&quot;의 네 가지 유형의 개체가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3d0232ce28c94288cf502f722ca216e09b8c5b1" translate="yes" xml:space="preserve">
          <source>There are implementations of Git that do not leave usable values in some fields (e.g. JGit); by excluding these fields from the comparison, the &lt;code&gt;minimal&lt;/code&gt; mode may help interoperability when the same repository is used by these other systems at the same time.</source>
          <target state="translated">일부 필드에서 사용 가능한 값을 남기지 않는 Git 구현이 있습니다 (예 : JGit). 이러한 필드를 비교에서 제외함으로써 &lt;code&gt;minimal&lt;/code&gt; 모드는 다른 시스템에서 동일한 저장소를 동시에 사용할 때 상호 운용성을 도울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac26d523869587e187089ca0cfe8dfa88bde0428" translate="yes" xml:space="preserve">
          <source>There are many more; see the &quot;SPECIFYING REVISIONS&quot; section of the &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; man page for the complete list of ways to name revisions. Some examples:</source>
          <target state="translated">더 많은 것이 있습니다. 개정판 이름 지정 방법의 전체 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 매뉴얼 페이지 의 &quot;사양 수정&quot;섹션을 참조하십시오. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="caa64d4f477bb9cc6ae8b8763c8d93ec4bfb0cef" translate="yes" xml:space="preserve">
          <source>There are no facilities for helping users find what unwanted crud they should delete, which means they are much more likely to have incomplete or partial cleanups that sometimes result in confusion and people wasting time trying to understand. (For example, folks tend to just look for big files to delete instead of big directories or extensions, and once they do so, then sometime later folks using the new repository who are going through history will notice a build artifact directory that has some files but not others, or a cache of dependencies (node_modules or similar) which couldn&amp;rsquo;t have ever been functional since it&amp;rsquo;s missing some files.)</source>
          <target state="translated">사용자가 삭제해야하는 원치 않는 크 러드를 찾도록 도와주는 기능이 없기 때문에 때때로 불완전하거나 부분적으로 정리되어 혼동을 일으키고 사람들이 이해하려고 시간을 낭비하는 경우가 훨씬 많습니다. (예를 들어, 사람들은 큰 디렉토리 또는 확장명 대신 삭제할 큰 파일을 찾는 경향이 있으며 일단 그렇게되면 역사를 겪고있는 새로운 저장소를 사용하는 사람들은 나중에 일부 파일이있는 빌드 아티팩트 디렉토리를 보게됩니다 그러나 다른 파일이나 종속성 캐시 (node_modules 또는 이와 유사한)는 일부 파일이 없기 때문에 작동 할 수 없었습니다.)</target>
        </trans-unit>
        <trans-unit id="ce4a9f9a1026ea763732ff998a2bcfb7b60f26ca" translate="yes" xml:space="preserve">
          <source>There are no public Trace2 data structures.</source>
          <target state="translated">공개 Trace2 데이터 구조가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a1dbdef2a9d4fcde2fec24ad984bfc7ec6f3aa2" translate="yes" xml:space="preserve">
          <source>There are numerous other tools, such as StGit, which exist for the purpose of maintaining a patch series. These are outside of the scope of this manual.</source>
          <target state="translated">패치 시리즈를 유지하기 위해 존재하는 StGit과 같은 다른 많은 도구가 있습니다. 이것들은이 매뉴얼의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="306721e74c73edf4b4a1c2554be600724c25d3f0" translate="yes" xml:space="preserve">
          <source>There are other estimates saying that 80% of the cost related to software is about maintenance &lt;a href=&quot;#2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">소프트웨어와 관련된 비용의 80 %가 유지 보수에 관한 것이라고 다른 추정이 있습니다 &lt;a href=&quot;#2&quot;&gt;[2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7eccee0caa41472aded0ea349d3d3fa4831b32ab" translate="yes" xml:space="preserve">
          <source>There are other real-world examples of using update and post-update hooks found in the Documentation/howto directory.</source>
          <target state="translated">Documentation / howto 디렉토리에있는 업데이트 및 사후 업데이트 후크 사용에 대한 다른 실제 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddc4304f0c733f93eaa36c71971b210be6c86baa" translate="yes" xml:space="preserve">
          <source>There are several built-in formats, and you can define additional formats by setting a pretty.&amp;lt;name&amp;gt; config option to either another format name, or a &lt;code&gt;format:&lt;/code&gt; string, as described below (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Here are the details of the built-in formats:</source>
          <target state="translated">몇 가지 기본 제공 형식이 있으며 아래에 설명 된대로 pretty. &amp;lt;name&amp;gt; 구성 옵션을 다른 형식 이름 또는 &lt;code&gt;format:&lt;/code&gt; 문자열 로 설정하여 추가 형식을 정의 할 수 있습니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). 내장 형식의 세부 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="172e083c83bf7e6cbde177805c61722f6bdc0777" translate="yes" xml:space="preserve">
          <source>There are some numbers about bugs in general, like a NIST study in 2002 &lt;a href=&quot;#1&quot;&gt;[1]&lt;/a&gt; that said:</source>
          <target state="translated">2002 년 NIST 연구 &lt;a href=&quot;#1&quot;&gt;[1]&lt;/a&gt; 와 같이 일반적으로 버그에 관한 몇 가지 숫자 가있다 :</target>
        </trans-unit>
        <trans-unit id="1a73feb2f257a54073e6e874ef78ceeefd47d29e" translate="yes" xml:space="preserve">
          <source>There are some subtle differences how the backends behave.</source>
          <target state="translated">백엔드의 작동 방식에는 미묘한 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a41ebe77f2eb54fbd4f30714a2e14c8c1d436ea0" translate="yes" xml:space="preserve">
          <source>There are three commands with similar names: &lt;code&gt;git reset&lt;/code&gt;, &lt;code&gt;git restore&lt;/code&gt; and &lt;code&gt;git revert&lt;/code&gt;.</source>
          <target state="translated">비슷한 이름을 가진 &lt;code&gt;git reset&lt;/code&gt; , &lt;code&gt;git restore&lt;/code&gt; 및 &lt;code&gt;git revert&lt;/code&gt; 의 세 가지 명령이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27e17ed315eeb27fa67bd10d3870c4d2deb8a92d" translate="yes" xml:space="preserve">
          <source>There are three different approaches: use an add-on to turn off line wraps, configure Thunderbird to not mangle patches, or use an external editor to keep Thunderbird from mangling the patches.</source>
          <target state="translated">추가 기능을 사용하여 줄 바꿈 기능을 끄거나, 패치를 처리하지 않도록 Thunderbird를 구성하거나, 외부 편집기를 사용하여 패치를 관리하지 못하도록하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c553f5839a8296a42918c5ea6f6a2fcca19fa49" translate="yes" xml:space="preserve">
          <source>There are three main tools that can be used for this:</source>
          <target state="translated">이를 위해 사용할 수있는 세 가지 주요 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="86e24f426735724adb9ab7ea59c461905251e8e9" translate="yes" xml:space="preserve">
          <source>There are three ways to specify which refs to update on the remote end.</source>
          <target state="translated">원격 측에서 업데이트 할 참조를 지정하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5544b2d42620b4375dbc730230171fe04b9f972b" translate="yes" xml:space="preserve">
          <source>There are two different types of capabilities: normal capabilities, which can be used to convey information or alter the behavior of a request, and commands, which are the core actions that a client wants to perform (fetch, push, etc).</source>
          <target state="translated">두 가지 유형의 기능이 있습니다. 정보를 전달하거나 요청의 동작을 변경하는 데 사용할 수있는 일반 기능과 클라이언트가 수행하고자하는 핵심 작업 (페치, 푸시 등) 인 명령입니다.</target>
        </trans-unit>
        <trans-unit id="c2015c03c4c8786233c499c7815e06c17100a16b" translate="yes" xml:space="preserve">
          <source>There are two formats accepted for patch files:</source>
          <target state="translated">패치 파일에는 두 가지 형식이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9b5e9b84c7e0cf0cc62bfad7ffc7f5a42847bbc1" translate="yes" xml:space="preserve">
          <source>There are two kinds of fixes, discussed in the following subsections:</source>
          <target state="translated">다음 하위 섹션에서 설명하는 두 가지 수정 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="afe3df249e404830655fd820b0b8e96397ac9183" translate="yes" xml:space="preserve">
          <source>There are two main tools that can be used to include changes from one branch on another: &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; and &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt; 및 &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick [1]의&lt;/a&gt; 한 가지 브랜치 변경 사항을 포함하는 데 사용할 수있는 두 가지 주요 도구가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1432c9def859812f2dcccb492cbe2b422538cffb" translate="yes" xml:space="preserve">
          <source>There are two ways to specify which commits to operate on.</source>
          <target state="translated">작동 할 커밋을 지정하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="04a6eae6f43fc050171fa2270096884eaba0fee3" translate="yes" xml:space="preserve">
          <source>There is a difference between listing multiple &amp;lt;refspec&amp;gt; directly on &lt;em&gt;git pull&lt;/em&gt; command line and having multiple &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; entries in your configuration for a &amp;lt;repository&amp;gt; and running a &lt;em&gt;git pull&lt;/em&gt; command without any explicit &amp;lt;refspec&amp;gt; parameters. &amp;lt;refspec&amp;gt;s listed explicitly on the command line are always merged into the current branch after fetching. In other words, if you list more than one remote ref, &lt;em&gt;git pull&lt;/em&gt; will create an Octopus merge. On the other hand, if you do not list any explicit &amp;lt;refspec&amp;gt; parameter on the command line, &lt;em&gt;git pull&lt;/em&gt; will fetch all the &amp;lt;refspec&amp;gt;s it finds in the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; configuration and merge only the first &amp;lt;refspec&amp;gt; found into the current branch. This is because making an Octopus from remote refs is rarely done, while keeping track of multiple remote heads in one-go by fetching more than one is often useful.</source>
          <target state="translated">&lt;em&gt;git pull&lt;/em&gt; 명령 행 에 직접 여러 &amp;lt;refspec&amp;gt;을 나열 하고 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 에 대한 구성에 여러 remote. &amp;lt;repository&amp;gt; .fetch 항목을 갖는 것과 명시적인 &amp;lt;refspec&amp;gt; 매개 변수없이 &lt;em&gt;git pull&lt;/em&gt; 명령을 실행하는 것에는 차이가 있습니다. 명령 행에 명시 적으로 나열된 &amp;lt;refspec&amp;gt;은 페치 후에 항상 현재 분기로 병합됩니다. 즉, 하나 이상의 원격 참조를 나열하면 &lt;em&gt;git pull&lt;/em&gt; 이 Octopus 병합을 생성합니다. 반면에 명령 행에 명시 적 &amp;lt;refspec&amp;gt; 매개 변수를 나열하지 않으면 &lt;em&gt;git pull&lt;/em&gt; 은 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 에서 찾은 모든 &amp;lt;refspec&amp;gt;을 가져옵니다 . &amp;lt;repository&amp;gt; .fetch구성하고 현재 분기에있는 첫 번째 &amp;lt;refspec&amp;gt; 만 병합하십시오. 원격 참조에서 Octopus를 만드는 것은 거의 이루어지지 않기 때문에 여러 원격 헤드를 한 번에 가져 와서 여러 원격 헤드를 추적하는 것이 종종 유용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="08d27e369ae02f07111163548604defe0fd7ba02" translate="yes" xml:space="preserve">
          <source>There is a fourth official branch that is used slightly differently:</source>
          <target state="translated">약간 다르게 사용되는 네 번째 공식 지점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ab0818052937d36eff9b5a2767bc99b339b1151" translate="yes" xml:space="preserve">
          <source>There is a script in contrib/thunderbird-patch-inline which can help you include patches with Thunderbird in an easy way. To use it, do the steps above and then use the script as the external editor.</source>
          <target state="translated">contrib / thunderbird-patch-inline에는 Thunderbird 패치를 쉽게 포함시킬 수있는 스크립트가 있습니다. 이를 사용하려면 위 단계를 수행 한 다음 스크립트를 외부 편집기로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1232149fc68bcd969b013f8dcdb8f804dc24a0d6" translate="yes" xml:space="preserve">
          <source>There is a tradeoff of course: merges require a more careful branch management. The following subsections discuss the important points.</source>
          <target state="translated">물론 절충이 있습니다. 병합에는보다 신중한 지점 관리가 필요합니다. 다음 하위 섹션에서는 중요한 사항에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="dad64266cc32a47cdf74ec10317455f91f86159c" translate="yes" xml:space="preserve">
          <source>There is already a project called BBChop created by Ealdwulf Wuffinga on Github that does something like that using Bayesian Search Theory &lt;a href=&quot;#9&quot;&gt;[9]&lt;/a&gt;:</source>
          <target state="translated">같은 무언가를 Github에서에 일 둘프 Wuffinga 만든 BBChop라는 프로젝트가 이미 있다는 것을 사용하여 베이지안 검색 이론 &lt;a href=&quot;#9&quot;&gt;[9]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="72c8cb7314c2d9e687a4188f4607320887a3abaf" translate="yes" xml:space="preserve">
          <source>There is also a deprecated &lt;code&gt;[section.subsection]&lt;/code&gt; syntax. With this syntax, the subsection name is converted to lower-case and is also compared case sensitively. These subsection names follow the same restrictions as section names.</source>
          <target state="translated">더 이상 사용되지 않는 &lt;code&gt;[section.subsection]&lt;/code&gt; 구문도 있습니다. 이 구문을 사용하면 하위 섹션 이름이 소문자로 변환되고 대소 문자를 구분합니다. 이 하위 섹션 이름은 섹션 이름과 동일한 제한 사항을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="562a7aac41f0a6a2b8bd94c80ba1df49ae8c2861" translate="yes" xml:space="preserve">
          <source>There is also an alternate -z format recommended for machine parsing. In that format, the status field is the same, but some other things change. First, the &lt;code&gt;-&amp;gt;&lt;/code&gt; is omitted from rename entries and the field order is reversed (e.g &lt;code&gt;from -&amp;gt; to&lt;/code&gt; becomes &lt;code&gt;to from&lt;/code&gt;). Second, a NUL (ASCII 0) follows each filename, replacing space as a field separator and the terminating newline (but a space still separates the status field from the first filename). Third, filenames containing special characters are not specially formatted; no quoting or backslash-escaping is performed.</source>
          <target state="translated">기계 구문 분석에 권장되는 대체 -z 형식도 있습니다. 이 형식에서 상태 필드는 동일하지만 다른 사항이 변경됩니다. 먼저, &lt;code&gt;-&amp;gt;&lt;/code&gt; (예 바꾸기 항목 생략하고 필드 순서 반전 &lt;code&gt;from -&amp;gt; to&lt;/code&gt; 된다 &lt;code&gt;to from&lt;/code&gt; ). 둘째, NUL (ASCII 0)은 각 파일 이름 뒤에 공백을 필드 구분 기호와 종료 줄 바꿈으로 대체하지만 공백은 여전히 ​​상태 필드를 첫 번째 파일 이름과 분리합니다. 셋째, 특수 문자가 포함 된 파일 이름은 특별히 형식이 지정되지 않습니다. 인용 또는 백 슬래시 이스케이프가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23b53316aea0dd64f8f21ea0eae539235bf45a74" translate="yes" xml:space="preserve">
          <source>There is also an option to sort by versions, this can be done by using the fieldname &lt;code&gt;version:refname&lt;/code&gt; or its alias &lt;code&gt;v:refname&lt;/code&gt;.</source>
          <target state="translated">버전별로 정렬하는 옵션도 있습니다. fieldname &lt;code&gt;version:refname&lt;/code&gt; 또는 별명 &lt;code&gt;v:refname&lt;/code&gt; 을 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="490f0c7223e032436f3ed74187899d6766a21bb5" translate="yes" xml:space="preserve">
          <source>There is another common situation where you may encounter non-fast-forward rejection when you try to push, and it is possible even when you are pushing into a repository nobody else pushes into. After you push commit A yourself (in the first picture in this section), replace it with &quot;git commit --amend&quot; to produce commit B, and you try to push it out, because forgot that you have pushed A out already. In such a case, and only if you are certain that nobody in the meantime fetched your earlier commit A (and started building on top of it), you can run &quot;git push --force&quot; to overwrite it. In other words, &quot;git push --force&quot; is a method reserved for a case where you do mean to lose history.</source>
          <target state="translated">푸시하려고 할 때 빨리 감기를 거부 할 수있는 또 다른 일반적인 상황이 있으며, 아무도 밀어 넣지 않고 저장소로 밀어 넣을 때도 가능합니다. 커밋 A를 직접 푸시 한 후 (이 섹션의 첫 번째 그림에서) 커밋 B를 생성하기 위해 &quot;git commit --amend&quot;로 바꾸고, 이미 푸시 아웃 한 것을 잊었 기 때문에 밀어 내려고합니다. 이 경우, 그 동안 아무도 이전 커밋 A를 가져 오지 않고 그 위에 빌드를 시작한 사람이 아무도없는 경우에만 &quot;git push --force&quot;를 실행하여 덮어 쓸 수 있습니다. 즉, &quot;git push --force&quot;는 히스토리를 잃어 버리려는 경우를 위해 예약 된 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8a8fda27a5ab0014e2c03663c10e41e5858f14f1" translate="yes" xml:space="preserve">
          <source>There is another simplification mode available:</source>
          <target state="translated">There is another simplification mode available:</target>
        </trans-unit>
        <trans-unit id="76938def2c927fda8d1c815e17291d57380d4a8a" translate="yes" xml:space="preserve">
          <source>There is another tweak in the bisection algorithm that has not been described in the &quot;bisection algorithm&quot; above.</source>
          <target state="translated">이분법 알고리즘에는 위의 &quot;이분법 알고리즘&quot;에 설명되지 않은 또 다른 조정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cd697be600e420b39bb68cc6d967c4ceca70af4" translate="yes" xml:space="preserve">
          <source>There is no option for &lt;code&gt;git rm&lt;/code&gt; to remove from the index only the paths that have disappeared from the filesystem. However, depending on the use case, there are several ways that can be done.</source>
          <target state="translated">&lt;code&gt;git rm&lt;/code&gt; 이 파일 시스템에서 사라진 경로 만 인덱스에서 제거하는 옵션은 없습니다 . 그러나 사용 사례에 따라 수행 할 수있는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="60bcaa98facce6fa9b4916fcb4556840549eaf70" translate="yes" xml:space="preserve">
          <source>There is no other restriction on the replaced and replacement objects. Merge commits can be replaced by non-merge commits and vice versa.</source>
          <target state="translated">교체 및 교체 객체에 대한 다른 제한은 없습니다. 병합 커밋은 병합되지 않은 커밋으로 대체 할 수 있으며 그 반대도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5b920fe2651a1acef3f4de11b5f87d418bf37e32" translate="yes" xml:space="preserve">
          <source>There is now a new commit &lt;code&gt;e&lt;/code&gt;, but it is referenced only by &lt;code&gt;HEAD&lt;/code&gt;. We can of course add yet another commit in this state:</source>
          <target state="translated">이제 새로운 커밋 &lt;code&gt;e&lt;/code&gt; 가 있지만 &lt;code&gt;HEAD&lt;/code&gt; 에서만 참조됩니다 . 물론이 상태에서 또 다른 커밋을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e84a3494173a3e4e1765afc114a7bb8588db5e4e" translate="yes" xml:space="preserve">
          <source>There is one special case not mentioned above, which is treated differently. Normally, a merge results in a merge commit, with two parents, one pointing at each of the two lines of development that were merged.</source>
          <target state="translated">위에서 언급되지 않은 특별한 경우가 하나 있는데, 다르게 취급됩니다. 일반적으로 병합을 수행하면 병합 된 두 개의 개발 라인 각각을 가리키는 두 개의 부모가있는 병합 커밋이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9c233ac02212216497063926a3cd425b73c1b106" translate="yes" xml:space="preserve">
          <source>There may be other problems when using &lt;code&gt;git rev-list&lt;/code&gt; related to pending objects.</source>
          <target state="translated">보류중인 객체와 관련된 &lt;code&gt;git rev-list&lt;/code&gt; 를 사용할 때 다른 문제가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3cc97d3b58e95d007d294ed252208117b7ea36ad" translate="yes" xml:space="preserve">
          <source>There was a discussion at one point on the linux kernel mailing list of whether it was ok to always ask end user to bisect, and very good points were made to support the point of view that it is ok.</source>
          <target state="translated">리눅스 커널 메일 링리스트의 어느 시점에서 최종 사용자에게 항상 이등분을 요구하는 것이 좋았는지에 대한 토론이 있었고, 괜찮다는 관점을 지원하기 위해 매우 좋은 점이 만들어졌습니다.</target>
        </trans-unit>
        <trans-unit id="e31f2056d77b9761665b1e39804c963e7c7e3f73" translate="yes" xml:space="preserve">
          <source>Therefore if the refspec for the remote includes e.g. &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt;, or you manually run e.g. &lt;code&gt;git fetch
--prune &amp;lt;name&amp;gt; &quot;refs/tags/*:refs/tags/*&quot;&lt;/code&gt; it won&amp;rsquo;t be stale remote tracking branches that are deleted, but any local tag that doesn&amp;rsquo;t exist on the remote.</source>
          <target state="translated">따라서 원격에 대한 참조 사양에 &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; 가 포함 되어 있거나 수동으로 &lt;code&gt;git fetch --prune &amp;lt;name&amp;gt; &quot;refs/tags/*:refs/tags/*&quot;&lt;/code&gt; 하면 ' 삭제 된 오래된 원격 추적 분기는 아니지만 원격에 존재하지 않는 로컬 태그는 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="22e33781a4f63d74c967572b3d2d5742f6f5b3cf" translate="yes" xml:space="preserve">
          <source>These are applied in sequence. The set of filepairs &lt;code&gt;git diff-*&lt;/code&gt; commands find are used as the input to diffcore-break, and the output from diffcore-break is used as the input to the next transformation. The final result is then passed to the output routine and generates either diff-raw format (see Output format sections of the manual for &lt;code&gt;git diff-*&lt;/code&gt; commands) or diff-patch format.</source>
          <target state="translated">이들은 순차적으로 적용됩니다. &lt;code&gt;git diff-*&lt;/code&gt; diff- * 명령 find 파일 쌍 세트는 diffcore -break에 대한 입력으로 사용되며 diffcore-break의 출력은 다음 변환에 대한 입력으로 사용됩니다. 최종 결과는 출력 루틴으로 전달되고 diff-raw 형식 ( &lt;code&gt;git diff-*&lt;/code&gt; 명령 에 대한 매뉴얼의 출력 형식 섹션 참조 ) 또는 diff-patch 형식을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5e4c5d2d8cb413a7bc102a12d4b32266eb5dffbd" translate="yes" xml:space="preserve">
          <source>These are concerned with describing the specific Git command after the command line, config, and environment are inspected. e.g: &lt;code&gt;void trace2_cmd_name(const char *name)&lt;/code&gt;, &lt;code&gt;void trace2_cmd_mode(const char *mode)&lt;/code&gt;.</source>
          <target state="translated">이것들은 커맨드 라인, 구성 및 환경을 검사 한 후 특정 Git 명령을 설명하는 것과 관련이 있습니다. 예 : &lt;code&gt;void trace2_cmd_name(const char *name)&lt;/code&gt; , &lt;code&gt;void trace2_cmd_mode(const char *mode)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd918e1aed68e545e545890a5d457bd39124acbb" translate="yes" xml:space="preserve">
          <source>These are concerned with recording performance data over regions or spans of code. e.g: &lt;code&gt;void trace2_region_enter(const char *category, const char *label, const struct repository *repo)&lt;/code&gt;.</source>
          <target state="translated">이들은 영역 또는 코드 범위에 걸쳐 성능 데이터를 기록하는 것과 관련이 있습니다. 예 : &lt;code&gt;void trace2_region_enter(const char *category, const char *label, const struct repository *repo)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10ea7c6e4b3ea51596f6b19ba236a57b5e812041" translate="yes" xml:space="preserve">
          <source>These are concerned with the lifetime of the overall git process. e.g: &lt;code&gt;void trace2_initialize_clock()&lt;/code&gt;, &lt;code&gt;void trace2_initialize()&lt;/code&gt;, &lt;code&gt;int trace2_is_enabled()&lt;/code&gt;, &lt;code&gt;void trace2_cmd_start(int argc, const char **argv)&lt;/code&gt;.</source>
          <target state="translated">이것들은 전체 자식 프로세스의 수명과 관련이 있습니다. 예 : &lt;code&gt;void trace2_initialize_clock()&lt;/code&gt; , &lt;code&gt;void trace2_initialize()&lt;/code&gt; , &lt;code&gt;int trace2_is_enabled()&lt;/code&gt; , &lt;code&gt;void trace2_cmd_start(int argc, const char **argv)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3dce3473c941e3b3b27a31ac8449a2f1991a75d0" translate="yes" xml:space="preserve">
          <source>These are concerned with the various spawned child processes, including shell scripts, git commands, editors, pagers, and hooks.</source>
          <target state="translated">이들은 쉘 스크립트, git 명령, 편집기, 호출기 및 후크를 포함하여 다양한 생성 된 자식 프로세스와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="64d6caf87f558c78a882445d71ea9cd47be32d78" translate="yes" xml:space="preserve">
          <source>These are internal helper commands used by other commands; end users typically do not use them directly.</source>
          <target state="translated">이들은 다른 명령에서 사용되는 내부 도우미 명령입니다. 최종 사용자는 일반적으로 직접 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14e40973cf60a547a4fee511ff95c4f84a31a06f" translate="yes" xml:space="preserve">
          <source>These are only used with the &lt;code&gt;dcommit&lt;/code&gt; and &lt;code&gt;rebase&lt;/code&gt; commands.</source>
          <target state="translated">이들은 &lt;code&gt;dcommit&lt;/code&gt; 및 &lt;code&gt;rebase&lt;/code&gt; 명령 에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1f4226446a769c76931ca392e2a09f31777b3654" translate="yes" xml:space="preserve">
          <source>These are optional command-line options for init. Each of these flags can point to a relative repository path (--tags=project/tags) or a full url (--tags=https://foo.org/project/tags). You can specify more than one --tags and/or --branches options, in case your Subversion repository places tags or branches under multiple paths. The option --stdlayout is a shorthand way of setting trunk,tags,branches as the relative paths, which is the Subversion default. If any of the other options are given as well, they take precedence.</source>
          <target state="translated">이들은 init에 대한 선택적 명령 행 옵션입니다. 이러한 각 플래그는 상대 리포지토리 경로 (--tags = project / tags) 또는 전체 URL (--tags = https : //foo.org/project/tags)을 가리킬 수 있습니다. Subversion 저장소가 여러 경로 아래에 태그 또는 분기를 배치하는 경우 둘 이상의 --tags 및 / 또는 --branches 옵션을 지정할 수 있습니다. --stdlayout 옵션은 트렁크, 태그, 분기를 상대 경로로 설정하는 간단한 방법으로 Subversion 기본값입니다. 다른 옵션도 제공되면 우선권을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="ef89fe03d8c6b725e4e01a5ddca75169500d3912" translate="yes" xml:space="preserve">
          <source>These attributes affect how the contents stored in the repository are copied to the working tree files when commands such as &lt;code&gt;git switch&lt;/code&gt;, &lt;code&gt;git checkout&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt; run. They also affect how Git stores the contents you prepare in the working tree in the repository upon &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">이러한 속성은 &lt;code&gt;git switch&lt;/code&gt; , &lt;code&gt;git checkout&lt;/code&gt; 및 &lt;code&gt;git merge&lt;/code&gt; 와 같은 명령이 실행될 때 리포지토리에 저장된 내용이 작업 트리 파일에 복사되는 방식에 영향을줍니다 . 또한 &lt;code&gt;git add&lt;/code&gt; 및 &lt;code&gt;git commit&lt;/code&gt; 시 작업 트리에서 준비한 내용을 저장소에 저장하는 방법에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="1e36f59cc4fba5296689c97860f8ef3c808cbf54" translate="yes" xml:space="preserve">
          <source>These can be easily kept up to date using &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;.</source>
          <target state="translated">이것들은 &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]을&lt;/a&gt; 사용하여 쉽게 최신 상태로 유지할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8f5a662d30248028e58618a9cb324b38272bbd8" translate="yes" xml:space="preserve">
          <source>These commands all compare two sets of things; what is compared differs:</source>
          <target state="translated">이 명령은 모두 두 가지 세트를 비교합니다. 비교되는 내용이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6e07bfec6529e0e8049d6a168dde51eb0ed55268" translate="yes" xml:space="preserve">
          <source>These commands are to interact with foreign SCM and with other people via patch over e-mail.</source>
          <target state="translated">이 명령은 전자 우편을 통해 외부 SCM 및 다른 사람들과 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="008c5282b165f202ade67dc870d3522a81a841bd" translate="yes" xml:space="preserve">
          <source>These configuration variables control &lt;code&gt;internal&lt;/code&gt; gitweb behavior.</source>
          <target state="translated">이 구성 변수는 &lt;code&gt;internal&lt;/code&gt; gitweb 동작을 제어 합니다.</target>
        </trans-unit>
        <trans-unit id="94d243826a65ff43f06f691e3b2f877746c8e3a7" translate="yes" xml:space="preserve">
          <source>These configurations enable two things. First, each unix user (&lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt;) of the server will be able to browse through gitweb Git repositories found in &lt;code&gt;~/public_git/&lt;/code&gt; with the following url:</source>
          <target state="translated">이러한 구성은 두 가지를 가능하게합니다. 먼저 서버의 각 유닉스 사용자 ( &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; )는 &lt;code&gt;~/public_git/&lt;/code&gt; 에있는 gitweb Git 저장소를 다음 URL 로 찾아 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c188c162ef90ed4e72b2204b53fd7bbdf63ed82" translate="yes" xml:space="preserve">
          <source>These environment variables apply to &lt;code&gt;all&lt;/code&gt; core Git commands. Nb: it is worth noting that they may be used/overridden by SCMS sitting above Git so take care if using a foreign front-end.</source>
          <target state="translated">이러한 환경 변수는 &lt;code&gt;all&lt;/code&gt; 핵심 Git 명령에 적용됩니다 . Nb : Git 위에있는 SCMS에 의해 사용 / 재정의 될 수 있으므로 외국 프론트 엔드를 사용하는 경우주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="e4a9928c908043039dae5cc89a184941db222aba" translate="yes" xml:space="preserve">
          <source>These exclude patterns come from these places, in order:</source>
          <target state="translated">이러한 제외 패턴은 다음 위치에서 순서대로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="75ad982aca6a7add80092ae27820348741497d7e" translate="yes" xml:space="preserve">
          <source>These flag are passed to the &lt;code&gt;git apply&lt;/code&gt; program (see &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;) that applies the patch.</source>
          <target state="translated">이 플래그는 패치를 적용하는 &lt;code&gt;git apply&lt;/code&gt; 프로그램 ( &lt;a href=&quot;git-apply&quot;&gt;git-apply [1]&lt;/a&gt; 참조)으로 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="a66ecfa5cef3d43b11b6332452dde3bc34998a82" translate="yes" xml:space="preserve">
          <source>These flags are passed to &lt;code&gt;git am&lt;/code&gt; to easily change the dates of the rebased commits (see &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;).</source>
          <target state="translated">이 플래그는 리베이스 된 커밋의 날짜를 쉽게 변경하기 위해 &lt;code&gt;git am&lt;/code&gt; 에 전달됩니다 ( &lt;a href=&quot;git-am&quot;&gt;git-am [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6f1d3498209d5426cb1c8295c9947466ac12cab4" translate="yes" xml:space="preserve">
          <source>These flags are passed to the &lt;code&gt;git apply&lt;/code&gt; (see &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;) program that applies the patch.</source>
          <target state="translated">이 플래그는 패치를 적용하는 &lt;code&gt;git apply&lt;/code&gt; ( &lt;a href=&quot;git-apply&quot;&gt;git-apply [1] 참조&lt;/a&gt; ) 프로그램으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="17c5d825c714d7f669df648adc8ffa3b9865aa3a" translate="yes" xml:space="preserve">
          <source>These forms reset the index entries for all paths that match the &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; to their state at &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;. (It does not affect the working tree or the current branch.)</source>
          <target state="translated">이 형식은 &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; 과 일치하는 모든 경로의 인덱스 항목을 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 의 상태로 재설정합니다 . 작업 트리 또는 현재 분기에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84dfe82e69639d7dd0490e18b4061edc5e5f61bb" translate="yes" xml:space="preserve">
          <source>These general best practices are very helpful if you bisect often.</source>
          <target state="translated">이러한 일반적인 모범 사례는 자주 이등분하는 경우 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="db63350c8a27af092cfd256119dcf34d87e7125f" translate="yes" xml:space="preserve">
          <source>These instructions use the &lt;code&gt;git-cvsimport&lt;/code&gt; script which ships with git, but other importers may provide better results. See the note in &lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport[1]&lt;/a&gt; for other options.</source>
          <target state="translated">이 지침에서는 &lt;code&gt;git-cvsimport&lt;/code&gt; 과 함께 제공되는 git-cvsimport 스크립트를 사용 하지만 다른 수입 업체가 더 나은 결과를 제공 할 수 있습니다. 다른 옵션에 대해서는 &lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport [1]&lt;/a&gt; 의 참고 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4de4cd9ec9920076e498bf4f8c01b7cc0e7335b0" translate="yes" xml:space="preserve">
          <source>These messages are concerned with Git thread usage.</source>
          <target state="translated">이 메시지는 Git 스레드 사용과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8e5bd243ffdab655773f15dbcfc0554b819902f" translate="yes" xml:space="preserve">
          <source>These options are deprecated. Use the above --notes/--no-notes options instead.</source>
          <target state="translated">이 옵션은 더 이상 사용되지 않습니다. 위의 --notes /-no-notes 옵션을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="894173daf027c82b1254f620d2cbbddacd04b7fd" translate="yes" xml:space="preserve">
          <source>These options are ignored for historical reasons.</source>
          <target state="translated">이러한 옵션은 역사적 이유로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0608f735748e7710136ac2ca4b1a8fc7f8d0f8a8" translate="yes" xml:space="preserve">
          <source>These options are mostly targeted for packing of Git repositories.</source>
          <target state="translated">이 옵션은 대부분 Git 리포지토리 패킹을 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="44fc7c2eb5b5d3f683db2d8973767b7defab9c76" translate="yes" xml:space="preserve">
          <source>These options are passed to &lt;a href=&quot;git-send-pack&quot;&gt;git-send-pack[1]&lt;/a&gt;. A thin transfer significantly reduces the amount of sent data when the sender and receiver share many of the same objects in common. The default is &lt;code&gt;--thin&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;git-send-pack&quot;&gt;git-send-pack [1]&lt;/a&gt; 로 전달됩니다 . 발신자와 수신자가 동일한 많은 객체를 공통으로 공유 할 때 씬 전송은 전송 된 데이터의 양을 크게 줄입니다. 기본값은 &lt;code&gt;--thin&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="38ddfaeebf99ab2e211259f05e2350cca6be519d" translate="yes" xml:space="preserve">
          <source>These options are primarily useful when converting a repository from one hash algorithm to another; without them, fast-import will fail if it encounters a submodule because it has no way of writing the object ID into the new hash algorithm.</source>
          <target state="translated">These options are primarily useful when converting a repository from one hash algorithm to another; without them, fast-import will fail if it encounters a submodule because it has no way of writing the object ID into the new hash algorithm.</target>
        </trans-unit>
        <trans-unit id="0c86ff6978b6c3146e6796c4f36abf160da0176d" translate="yes" xml:space="preserve">
          <source>These options can be used in an initial &lt;code&gt;clone&lt;/code&gt;, along with the &lt;code&gt;sync&lt;/code&gt; options described above.</source>
          <target state="translated">이러한 옵션은 위에서 설명한 &lt;code&gt;sync&lt;/code&gt; 옵션 과 함께 초기 &lt;code&gt;clone&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ade32a888d52a4ba127b2e5cb51121d4b067e67" translate="yes" xml:space="preserve">
          <source>These options can be used in the initial &lt;code&gt;clone&lt;/code&gt; as well as in subsequent &lt;code&gt;sync&lt;/code&gt; operations.</source>
          <target state="translated">이 옵션은 초기 &lt;code&gt;clone&lt;/code&gt; 및 후속 &lt;code&gt;sync&lt;/code&gt; 작업 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f45787718e6c314237aec0cf2c5e63156df92c4" translate="yes" xml:space="preserve">
          <source>These options can be used to modify &lt;code&gt;git p4 rebase&lt;/code&gt; behavior.</source>
          <target state="translated">이 옵션은 &lt;code&gt;git p4 rebase&lt;/code&gt; 동작 을 수정하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="046bf3cadb648529c8cbf517d3ba66246fc697fc" translate="yes" xml:space="preserve">
          <source>These options can be used to modify &lt;code&gt;git p4 submit&lt;/code&gt; behavior.</source>
          <target state="translated">이 옵션은 &lt;code&gt;git p4 submit&lt;/code&gt; 동작 을 수정하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5bf9264c3d2f29d27aed45b38db366aee6362601" translate="yes" xml:space="preserve">
          <source>These options control layout (defaults to &lt;code&gt;column&lt;/code&gt;). Setting any of these implies &lt;code&gt;always&lt;/code&gt; if none of &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;, or &lt;code&gt;auto&lt;/code&gt; are specified.</source>
          <target state="translated">이 옵션은 레이아웃을 제어합니다 (기본값은 &lt;code&gt;column&lt;/code&gt; ). 이들의 설정을 의미 &lt;code&gt;always&lt;/code&gt; 하나도 경우 &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;never&lt;/code&gt; , 또는 &lt;code&gt;auto&lt;/code&gt; 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="510a1cbefb424a60db8479a49dd55a0966d6d945" translate="yes" xml:space="preserve">
          <source>These options control when the feature should be enabled (defaults to &lt;code&gt;never&lt;/code&gt;):</source>
          <target state="translated">이 옵션은 기능을 활성화해야하는시기를 제어합니다 (기본값은 &lt;code&gt;never&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="931e215644554fa9404627a014bfd3cf51399ea5" translate="yes" xml:space="preserve">
          <source>These options take effect whatever the value of the &lt;code&gt;core.splitIndex&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.</source>
          <target state="translated">이 옵션은 &lt;code&gt;core.splitIndex&lt;/code&gt; 구성 변수 의 값에 관계없이 적용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). 그러나 구성된 값이 다음에 인덱스를 읽을 때 적용되고 옵션의 의도 된 효과가 제거되므로 구성된 값에 대한 변경이 발생하면 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="932e8c22c29966222600cac9510425979eeabd1c" translate="yes" xml:space="preserve">
          <source>These options take effect whatever the value of the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.</source>
          <target state="translated">이러한 옵션은 &lt;code&gt;core.untrackedCache&lt;/code&gt; 구성 변수 의 값에 관계없이 적용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). 그러나 구성된 값이 다음에 인덱스를 읽을 때 적용되고 옵션의 의도 된 효과가 제거되므로 구성된 값에 대한 변경이 발생하면 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ff7024be4fc3bd9a63ff1aab42e5c2f33080a5ad" translate="yes" xml:space="preserve">
          <source>These parameters can also be set individually with &lt;code&gt;--stat-width=&amp;lt;width&amp;gt;&lt;/code&gt;, &lt;code&gt;--stat-name-width=&amp;lt;name-width&amp;gt;&lt;/code&gt; and &lt;code&gt;--stat-count=&amp;lt;count&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 매개 변수는 &lt;code&gt;--stat-width=&amp;lt;width&amp;gt;&lt;/code&gt; , &lt;code&gt;--stat-name-width=&amp;lt;name-width&amp;gt;&lt;/code&gt; 및 &lt;code&gt;--stat-count=&amp;lt;count&amp;gt;&lt;/code&gt; 로 개별적으로 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25d97f197e2ad468ea791c831ca2e71054c4e207" translate="yes" xml:space="preserve">
          <source>These remote-tracking references can be deleted as a one-off with either of:</source>
          <target state="translated">이러한 원격 추적 참조는 다음 중 하나를 사용하여 일회용으로 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4994737bcfd88cfa54486bc85e99d5152416b798" translate="yes" xml:space="preserve">
          <source>These rules make it easy for shell script based tools to parse reference names, pathname expansion by the shell when a reference name is used unquoted (by mistake), and also avoid ambiguities in certain reference name expressions (see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;):</source>
          <target state="translated">이 규칙을 사용하면 쉘 스크립트 기반 도구가 참조 이름을 쉽게 구문 분석하고 참조 이름을 인용 부호없이 사용할 때 쉘에 의한 경로 이름 확장을 쉽게 할 수 있으며 특정 참조 이름 표현식에서 모호성을 피할 수 있습니다 ( &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d2d3b8bc5c27c38dddb2f7c9e54b52668c820483" translate="yes" xml:space="preserve">
          <source>These services can be enabled/disabled using the per-repository configuration file:</source>
          <target state="translated">이러한 서비스는 저장소 별 구성 파일을 사용하여 활성화 / 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11be9ffec744e4c727f505822229118ed50ca097" translate="yes" xml:space="preserve">
          <source>These services can be globally enabled/disabled using the command-line options of this command. If finer-grained control is desired (e.g. to allow &lt;code&gt;git archive&lt;/code&gt; to be run against only in a few selected repositories the daemon serves), the per-repository configuration file can be used to enable or disable them.</source>
          <target state="translated">이 서비스는이 명령의 명령 줄 옵션을 사용하여 전체적으로 활성화 / 비활성화 할 수 있습니다. 보다 세부적인 제어가 필요한 경우 (예 : 데몬이 제공하는 선택된 일부 리포지토리에서만 &lt;code&gt;git archive&lt;/code&gt; 를 실행할 수 있도록 ) 리포지토리 당 구성 파일을 사용하여 활성화 또는 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e7a1043f71fa1813c0b5e398e97710f483944d9" translate="yes" xml:space="preserve">
          <source>These things may exist in a Git repository.</source>
          <target state="translated">이러한 것들이 Git 저장소에 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5c7f688db050c92cfc9bb2aa9d676e52849ec7b" translate="yes" xml:space="preserve">
          <source>These three branches all forked from a common commit, [master], whose commit message is &quot;Add 'git show-branch'&quot;. The &quot;fixes&quot; branch adds one commit &quot;Introduce &quot;reset type&quot; flag to &quot;git reset&quot;&quot;. The &quot;mhf&quot; branch adds many other commits. The current branch is &quot;master&quot;.</source>
          <target state="translated">이 세 가지 분기는 모두 커밋 메시지가 &quot;Add 'git show-branch'&quot;인 공통 커밋 [master]에서 분기되었습니다. &quot;fixes&quot;브랜치는 하나의 커밋 &quot;&quot;reset type &quot;플래그를&quot;git reset &quot;에 추가합니다.&quot; &quot;mhf&quot;브랜치는 다른 많은 커밋을 추가합니다. 현재 지점은 &quot;마스터&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="c6204a9318b7a0526e46b8696b2eb378d52ecf11" translate="yes" xml:space="preserve">
          <source>These two filters behave differently, and by default, a filter is taken as the former, massaging the contents into more convenient shape. A missing filter driver definition in the config, or a filter driver that exits with a non-zero status, is not an error but makes the filter a no-op passthru.</source>
          <target state="translated">이 두 필터는 다르게 동작하며 기본적으로 필터는 전자로 사용되어 내용을보다 편리한 모양으로 마사지합니다. 구성에서 누락 된 필터 드라이버 정의 또는 0이 아닌 상태로 종료되는 필터 드라이버는 오류가 아니라 필터를 무 작동 패스 스루로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e20e46dc24b79b5218925e423850545226b0898e" translate="yes" xml:space="preserve">
          <source>These two options affect how the objects contained in the pack are stored using delta compression. The objects are first internally sorted by type, size and optionally names and compared against the other objects within --window to see if using delta compression saves space. --depth limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object.</source>
          <target state="translated">이 두 옵션은 팩에 포함 된 오브젝트가 델타 압축을 사용하여 저장되는 방법에 영향을줍니다. 객체는 유형, 크기 및 선택적으로 이름별로 내부적으로 정렬되어 델타 압축을 사용하여 공간이 절약되는지 확인하기 위해 --window 내의 다른 객체와 비교됩니다. --depth는 최대 델타 깊이를 제한합니다. 델타 데이터를 필요한 오브젝트에 도달하기 위해 여러 번 적용해야하기 때문에 너무 깊게 만들면 언 패커 측 성능에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="de212a952b72f4cd05af023bbd056fa8307c4a9f" translate="yes" xml:space="preserve">
          <source>These two options affect how the objects contained in the pack are stored using delta compression. The objects are first internally sorted by type, size and optionally names and compared against the other objects within &lt;code&gt;--window&lt;/code&gt; to see if using delta compression saves space. &lt;code&gt;--depth&lt;/code&gt; limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object.</source>
          <target state="translated">이 두 옵션은 팩에 포함 된 오브젝트가 델타 압축을 사용하여 저장되는 방법에 영향을줍니다. 객체는 유형, 크기 및 선택적으로 이름별로 내부적으로 정렬되어 델타 압축을 사용하여 공간이 절약되는지 확인하기 위해 &lt;code&gt;--window&lt;/code&gt; 내의 다른 객체와 비교 됩니다. &lt;code&gt;--depth&lt;/code&gt; 는 최대 델타 깊이를 제한합니다. 델타 데이터를 필요한 오브젝트에 도달하기 위해 여러 번 적용해야하기 때문에 너무 깊게하면 언 패커 측 성능에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="6a0bfaec1ca5ad5a0f6710f22f7b4b78eecfef67" translate="yes" xml:space="preserve">
          <source>These two syntaxes are mostly equivalent, except the former implies --local option.</source>
          <target state="translated">이 두 구문은 전자가 --local 옵션을 암시하는 것을 제외하고는 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9270307e15adf00d482cdebd8e068750f310bc87" translate="yes" xml:space="preserve">
          <source>These two syntaxes are mostly equivalent, except when cloning, when the former implies --local option. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; for details.</source>
          <target state="translated">이 두 구문은 복제 할 때를 제외하고 전자가 --local 옵션을 암시 할 때를 제외하고는 거의 동일합니다. 자세한 내용은 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="469e074d32a553c54f69af6603803ffbfd2e6dda" translate="yes" xml:space="preserve">
          <source>These types of entries are generally created as a result of using &lt;code&gt;git
commit --amend&lt;/code&gt; or &lt;code&gt;git rebase&lt;/code&gt; and are the commits prior to the amend or rebase occurring. Since these changes are not part of the current project most users will want to expire them sooner, which is why the default is more aggressive than &lt;code&gt;gc.reflogExpire&lt;/code&gt;.</source>
          <target state="translated">이러한 유형의 항목은 일반적으로 &lt;code&gt;git commit --amend&lt;/code&gt; 또는 &lt;code&gt;git rebase&lt;/code&gt; 를 사용한 결과로 작성되며 수정 또는 rebase가 발생하기 전에 커밋됩니다. 이러한 변경 사항은 현재 프로젝트의 일부가 아니므로 대부분의 사용자는 더 빨리 만료하려고하므로 기본값이 &lt;code&gt;gc.reflogExpire&lt;/code&gt; 보다 더 공격적인 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="99a10a0726ee032ba80815c05eceb6d5a6ab2aa8" translate="yes" xml:space="preserve">
          <source>These variables control various optional help messages designed to aid new users. All &lt;code&gt;advice.*&lt;/code&gt; variables default to &lt;code&gt;true&lt;/code&gt;, and you can tell Git that you do not need help by setting these to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">이 변수는 새로운 사용자를 돕기 위해 설계된 다양한 선택적 도움말 메시지를 제어합니다. 모든 &lt;code&gt;advice.*&lt;/code&gt; 변수는 기본적으로 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있으며, Git에게 이것들을 &lt;code&gt;false&lt;/code&gt; 로 설정하면 도움이 필요 없다고 말할 수있다 .</target>
        </trans-unit>
        <trans-unit id="289bbff1e27f0cf157d5208bbfcb9f369ecc1504" translate="yes" xml:space="preserve">
          <source>These variables obviate the need for command-line options in some circumstances, allowing easier restricted usage through git-shell.</source>
          <target state="translated">이러한 변수는 일부 상황에서 명령 줄 옵션이 필요하지 않으므로 git-shell을 통해 사용을보다 쉽게 ​​제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48d5c4b33cae3d35014b5a5e266ea897c2a18c9f" translate="yes" xml:space="preserve">
          <source>These will display all commits which exist only on HEAD or on MERGE_HEAD, and which touch an unmerged file.</source>
          <target state="translated">HEAD 또는 MERGE_HEAD에만 존재하며 병합되지 않은 파일을 건 드리는 모든 커밋이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e9ab0d9bdf3f35b7d6ece2d3bc65f4fbb38bad38" translate="yes" xml:space="preserve">
          <source>They are both passed directly to &lt;code&gt;git diff-tree&lt;/code&gt;; see &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree[1]&lt;/a&gt; for more information.</source>
          <target state="translated">둘 다 &lt;code&gt;git diff-tree&lt;/code&gt; 로 직접 전달됩니다 . 자세한 내용은 &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="afa16f632fa562fed5a34ad41431101aacb568d7" translate="yes" xml:space="preserve">
          <source>They can include slash &lt;code&gt;/&lt;/code&gt; for hierarchical (directory) grouping, but no slash-separated component can begin with a dot &lt;code&gt;.&lt;/code&gt; or end with the sequence &lt;code&gt;.lock&lt;/code&gt;.</source>
          <target state="translated">슬래시 &lt;code&gt;/&lt;/code&gt; 계층 적 (디렉토리) 그룹화를 포함 할 수 있지만 슬래시로 분리 된 구성 요소는 dot로 시작할 수 없습니다 &lt;code&gt;.&lt;/code&gt; 또는 시퀀스 &lt;code&gt;.lock&lt;/code&gt; 으로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="48a933f433abac80f2e0e41b240081f7a399893c" translate="yes" xml:space="preserve">
          <source>They cannot be the single character &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">단일 문자 &lt;code&gt;@&lt;/code&gt; 일 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c798a840110b095cd0c31cb10cad16c17f5292dd" translate="yes" xml:space="preserve">
          <source>They cannot begin or end with a slash &lt;code&gt;/&lt;/code&gt; or contain multiple consecutive slashes (see the &lt;code&gt;--normalize&lt;/code&gt; option below for an exception to this rule)</source>
          <target state="translated">그들은 시작이나 끝 슬래시로 수 &lt;code&gt;/&lt;/code&gt; 또는 여러 개의 연속 슬래시를 포함합니다 (참조 &lt;code&gt;--normalize&lt;/code&gt; 이 규칙에 예외 아래 옵션)</target>
        </trans-unit>
        <trans-unit id="794c847c2b033448497ba9e6f46f59b7325ccd69" translate="yes" xml:space="preserve">
          <source>They cannot contain a &lt;code&gt;\&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\&lt;/code&gt; 를 포함 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c4cf89d0a711867dbdfa498e7e6b80fb04c020f3" translate="yes" xml:space="preserve">
          <source>They cannot contain a sequence &lt;code&gt;@{&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@{&lt;/code&gt; 시퀀스를 포함 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c781dcfcbfa7c545717cc72f3f25ac7fba039fd7" translate="yes" xml:space="preserve">
          <source>They cannot end with a dot &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">그들은 점으로 끝날 수 없습니다 &lt;code&gt;.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdf3c698f8591838633d63d5550c41009f5d53bb" translate="yes" xml:space="preserve">
          <source>They cannot have ASCII control characters (i.e. bytes whose values are lower than \040, or \177 &lt;code&gt;DEL&lt;/code&gt;), space, tilde &lt;code&gt;~&lt;/code&gt;, caret &lt;code&gt;^&lt;/code&gt;, or colon &lt;code&gt;:&lt;/code&gt; anywhere.</source>
          <target state="translated">ASCII 제어 문자 (예 : 값이 \ 040 또는 \ 177 &lt;code&gt;DEL&lt;/code&gt; 보다 작은 바이트 ), 공백, 틸드 &lt;code&gt;~&lt;/code&gt; , 캐럿 &lt;code&gt;^&lt;/code&gt; 또는 콜론 &lt;code&gt;:&lt;/code&gt; 어디서나 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9fa9a35ba99f055f59e5fb0fc3903845af8141d1" translate="yes" xml:space="preserve">
          <source>They cannot have question-mark &lt;code&gt;?&lt;/code&gt;, asterisk &lt;code&gt;*&lt;/code&gt;, or open bracket &lt;code&gt;[&lt;/code&gt; anywhere. See the &lt;code&gt;--refspec-pattern&lt;/code&gt; option below for an exception to this rule.</source>
          <target state="translated">그들은 물음표를 가질 수 &lt;code&gt;?&lt;/code&gt; , 별표 &lt;code&gt;*&lt;/code&gt; 또는 열린 괄호 &lt;code&gt;[&lt;/code&gt; 어디서나 사용 가능합니다. 이 규칙에 대한 예외는 아래 의 &lt;code&gt;--refspec-pattern&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="07233de88d34b821d099ea14e09099281360fa3d" translate="yes" xml:space="preserve">
          <source>They cannot have two consecutive dots &lt;code&gt;..&lt;/code&gt; anywhere.</source>
          <target state="translated">그들은 두 개의 연속 된 점을 가질 수 없습니다 &lt;code&gt;..&lt;/code&gt; 어디.</target>
        </trans-unit>
        <trans-unit id="08cc7b3818b658e36c5e9a0a0fcefabb2c9bd5ce" translate="yes" xml:space="preserve">
          <source>They must contain at least one &lt;code&gt;/&lt;/code&gt;. This enforces the presence of a category like &lt;code&gt;heads/&lt;/code&gt;, &lt;code&gt;tags/&lt;/code&gt; etc. but the actual names are not restricted. If the &lt;code&gt;--allow-onelevel&lt;/code&gt; option is used, this rule is waived.</source>
          <target state="translated">그들은 적어도 하나의 메시지 있어야합니다 &lt;code&gt;/&lt;/code&gt; 을 . 이것은 &lt;code&gt;heads/&lt;/code&gt; , &lt;code&gt;tags/&lt;/code&gt; 등과 같은 카테고리의 존재를 강제 하지만 실제 이름은 제한되지 않습니다. 는 IF &lt;code&gt;--allow-onelevel&lt;/code&gt; 은 옵션을 사용,이 규칙은 면제됩니다.</target>
        </trans-unit>
        <trans-unit id="9c66e1086c1b783565f285e9f8d345796e4a920b" translate="yes" xml:space="preserve">
          <source>Things get more complicated if the &lt;code&gt;subsystem&lt;/code&gt; changes do not exactly correspond to the ones before the rebase.</source>
          <target state="translated">&lt;code&gt;subsystem&lt;/code&gt; 변경 사항이 리베이스 이전의 서브 시스템 변경 사항과 정확히 일치하지 않으면 상황이 더 복잡해집니다 .</target>
        </trans-unit>
        <trans-unit id="877bd5e347693a4c90610529b809f198ae203a8a" translate="yes" xml:space="preserve">
          <source>Think about how to create a clear chapter dependency graph that will allow people to get to important topics without necessarily reading everything in between.</source>
          <target state="translated">사람들이 반드시 사이에있는 모든 것을 읽지 않고도 중요한 주제에 도달 할 수있는 명확한 장 종속성 그래프를 작성하는 방법에 대해 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="5f03012af2a22f62503c31e1e064eb23ddd2be46" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;key&lt;/code&gt; will be used instead of &amp;lt;token&amp;gt; in the trailer. At the end of this key, a separator can appear and then some space characters. By default the only valid separator is &lt;code&gt;:&lt;/code&gt;, but this can be changed using the &lt;code&gt;trailer.separators&lt;/code&gt; config variable.</source>
          <target state="translated">이 &lt;code&gt;key&lt;/code&gt; 는 예고편에서 &amp;lt;토큰&amp;gt; 대신 사용됩니다. 이 키의 끝에 구분 기호가 나타난 다음 일부 공백 문자가 나타날 수 있습니다. 기본적으로 유일하게 유효한 구분자는 &lt;code&gt;:&lt;/code&gt; 이지만 &lt;code&gt;trailer.separators&lt;/code&gt; config 변수를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ed9ef222233001104259cd6ab7e0ea2e028dedb" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;merge&lt;/code&gt; can also be done by &lt;code&gt;pulling from her own remote-tracking branch&lt;/code&gt;, like this:</source>
          <target state="translated">이 &lt;code&gt;merge&lt;/code&gt; 은 다음과 같이 &lt;code&gt;pulling from her own remote-tracking branch&lt;/code&gt; 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0007248c88629a35b9fa8e1cf4c8fdf299191526" translate="yes" xml:space="preserve">
          <source>This accepts all options that &lt;code&gt;git svn fetch&lt;/code&gt; and &lt;code&gt;git rebase&lt;/code&gt; accept. However, &lt;code&gt;--fetch-all&lt;/code&gt; only fetches from the current [svn-remote], and not all [svn-remote] definitions.</source>
          <target state="translated">이것은 &lt;code&gt;git svn fetch&lt;/code&gt; 및 &lt;code&gt;git rebase&lt;/code&gt; 가 허용 하는 모든 옵션을 허용합니다. 그러나 &lt;code&gt;--fetch-all&lt;/code&gt; 은 모든 [svn-remote] 정의가 아니라 현재 [svn-remote]에서만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c118365ba0290d763b2d4e635fbfbb09d23e73e6" translate="yes" xml:space="preserve">
          <source>This action is disabled by default for performance reasons.</source>
          <target state="translated">이 작업은 성능상의 이유로 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="692de83ae64c152ace96a6b22c40c6c7b5256f5f" translate="yes" xml:space="preserve">
          <source>This adds a link titled &quot;graphiclog&quot; after the &quot;summary&quot; link, leading to &lt;code&gt;git-browser&lt;/code&gt; script, passing &lt;code&gt;r=&amp;lt;project&amp;gt;&lt;/code&gt; as a query parameter.</source>
          <target state="translated">&quot;summary&quot;링크 뒤에 &quot;graphiclog&quot;라는 제목의 링크가 추가되어 &lt;code&gt;git-browser&lt;/code&gt; 스크립트가 생성되어 &lt;code&gt;r=&amp;lt;project&amp;gt;&lt;/code&gt; 를 쿼리 매개 변수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="9647e1f610a9d28b74cedc3ffa625f5d98628ec8" translate="yes" xml:space="preserve">
          <source>This algorithm extends the patience algorithm to &quot;support low-occurrence common elements&quot;.</source>
          <target state="translated">이 알고리즘은 인내심 알고리즘을 &quot;낮은 발생 공통 요소 지원&quot;으로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="5f9e4d22cfa1bc9f924abb0f51a443db2655b318" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;git svn&lt;/code&gt; to re-map repository URLs and UUIDs from mirrors created using SVN::Mirror (or svk) for metadata.</source>
          <target state="translated">이를 통해 &lt;code&gt;git svn&lt;/code&gt; 은 메타 데이터를 위해 SVN :: Mirror (또는 svk)를 사용하여 생성 된 미러에서 리포지토리 URL과 UUID를 다시 매핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb552885bcd7df779f362e35a229c9d935657c60" translate="yes" xml:space="preserve">
          <source>This allows one to specify a Perl regular expression that will cause skipping of all matching paths from checkout from SVN. The &lt;code&gt;--ignore-paths&lt;/code&gt; option should match for every &lt;code&gt;fetch&lt;/code&gt; (including automatic fetches due to &lt;code&gt;clone&lt;/code&gt;, &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, etc) on a given repository.</source>
          <target state="translated">이것은 SVN의 체크 아웃에서 모든 일치하는 경로를 건너 뛰게하는 Perl 정규식을 지정할 수있게합니다. &lt;code&gt;--ignore-paths&lt;/code&gt; 옵션은 모든에 대해 일치해야합니다 &lt;code&gt;fetch&lt;/code&gt; (로 인해 포함하여 자동 인출 &lt;code&gt;clone&lt;/code&gt; , &lt;code&gt;dcommit&lt;/code&gt; , &lt;code&gt;rebase&lt;/code&gt; 주어진 저장소에, 등).</target>
        </trans-unit>
        <trans-unit id="bf5d12ceb1111e8b06bd58f3985472091a1cae12" translate="yes" xml:space="preserve">
          <source>This allows one to specify a Perl regular expression that will cause the inclusion of only matching paths from checkout from SVN. The &lt;code&gt;--include-paths&lt;/code&gt; option should match for every &lt;code&gt;fetch&lt;/code&gt; (including automatic fetches due to &lt;code&gt;clone&lt;/code&gt;, &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, etc) on a given repository. &lt;code&gt;--ignore-paths&lt;/code&gt; takes precedence over &lt;code&gt;--include-paths&lt;/code&gt;.</source>
          <target state="translated">이를 통해 SVN에서 체크 아웃 할 때 일치하는 경로 만 포함시키는 Perl 정규식을 지정할 수 있습니다. &lt;code&gt;--include-paths&lt;/code&gt; 옵션은 모든에 대해 일치해야합니다 &lt;code&gt;fetch&lt;/code&gt; (로 인해 포함하여 자동 인출 &lt;code&gt;clone&lt;/code&gt; , &lt;code&gt;dcommit&lt;/code&gt; , &lt;code&gt;rebase&lt;/code&gt; 주어진 저장소에, 등). &lt;code&gt;--ignore-paths&lt;/code&gt; 가 &lt;code&gt;--include-paths&lt;/code&gt; 보다 우선 합니다 .</target>
        </trans-unit>
        <trans-unit id="c68f089f9144bc4bdc1d710532bfa75a569d11ed" translate="yes" xml:space="preserve">
          <source>This allows one to specify a prefix which is prepended to the names of remotes if trunk/branches/tags are specified. The prefix does not automatically include a trailing slash, so be sure you include one in the argument if that is what you want. If --branches/-b is specified, the prefix must include a trailing slash. Setting a prefix (with a trailing slash) is strongly encouraged in any case, as your SVN-tracking refs will then be located at &quot;refs/remotes/$prefix/&lt;strong&gt;&quot;, which is compatible with Git&amp;rsquo;s own remote-tracking ref layout (refs/remotes/$remote/&lt;/strong&gt;). Setting a prefix is also useful if you wish to track multiple projects that share a common repository. By default, the prefix is set to &lt;code&gt;origin/&lt;/code&gt;.</source>
          <target state="translated">이를 통해 트렁크 / 분기 / 태그가 지정된 경우 원격의 이름 앞에 붙는 접두사를 지정할 수 있습니다. 접두사는 자동으로 슬래시를 포함하지 않으므로 원하는 경우 인수에 하나를 포함시켜야합니다. --branches / -b를 지정하면 접두사 뒤에 슬래시가 포함되어야합니다. SVN 추적 참조가 &quot;refs / remotes / $ prefix / &lt;strong&gt;&quot;에 위치하므로 Git의 자체 원격 추적 참조 레이아웃 (refs)과 호환되므로&lt;/strong&gt; 접두사 (후행 슬래시 포함)를 설정하는 것이 좋습니다. &lt;strong&gt;/ remotes / $ remote /&lt;/strong&gt; ). 공통 저장소를 공유하는 여러 프로젝트를 추적하려는 경우 접 두부를 설정하는 것도 유용합니다. 기본적으로 접두사는 &lt;code&gt;origin/&lt;/code&gt; 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="99b10fdeae941de841a9ac73e39b7c06fcc2d978" translate="yes" xml:space="preserve">
          <source>This allows revision ranges for partial/cauterized history to be supported. $NUMBER, $NUMBER1:$NUMBER2 (numeric ranges), $NUMBER:HEAD, and BASE:$NUMBER are all supported.</source>
          <target state="translated">이를 통해 부분 / 소화 이력에 대한 수정 범위를 지원할 수 있습니다. $ NUMBER, $ NUMBER1 : $ NUMBER2 (숫자 범위), $ NUMBER : HEAD 및 BASE : $ NUMBER가 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f18b167effc162d347deb782b83eab22ac73f014" translate="yes" xml:space="preserve">
          <source>This allows users to create repositories from alternate URLs. For example, an administrator could run &lt;code&gt;git svn&lt;/code&gt; on the server locally (accessing via file://) but wish to distribute the repository with a public http:// or svn:// URL in the metadata so users of it will see the public URL.</source>
          <target state="translated">이를 통해 사용자는 대체 URL에서 리포지토리를 만들 수 있습니다. 예를 들어, 관리자 는 서버에서 로컬로 &lt;code&gt;git svn&lt;/code&gt; 을 실행 (file : //를 통해 액세스) 할 수 있지만 메타 데이터에 공개 http : // 또는 svn : // URL을 사용하여 리포지토리를 배포하여 사용자가 공개 URL.</target>
        </trans-unit>
        <trans-unit id="86c4c002dbb35b192dee2247feadc27722ad842a" translate="yes" xml:space="preserve">
          <source>This application is a CVS emulation layer for Git.</source>
          <target state="translated">이 애플리케이션은 Git의 CVS 에뮬레이션 레이어입니다.</target>
        </trans-unit>
        <trans-unit id="8feea1468fa1fae814e84f89aca492fad30e5da4" translate="yes" xml:space="preserve">
          <source>This applies modifications from a hot-fix branch before each test run, e.g. in case your build or test environment changed so that older revisions may need a fix which newer ones have already. (Make sure the hot-fix branch is based off a commit which is contained in all revisions which you are bisecting, so that the merge does not pull in too much, or use &lt;code&gt;git cherry-pick&lt;/code&gt; instead of &lt;code&gt;git merge&lt;/code&gt;.)</source>
          <target state="translated">예를 들어 빌드 또는 테스트 환경이 변경되어 이전 개정판에 이미 수정 된 수정본이 필요할 수있는 경우와 같이 각 테스트 실행 전에 핫픽스 브랜치의 수정 사항이 적용됩니다. (핫픽스 브랜치는 bisecting하는 모든 개정판에 포함 된 커밋을 기반으로하여 병합이 너무 많이 걸리지 않도록하거나 &lt;code&gt;git merge&lt;/code&gt; 대신 &lt;code&gt;git cherry-pick&lt;/code&gt; 을 사용해야 합니다.)</target>
        </trans-unit>
        <trans-unit id="889d1277201779cf18582f69129975a9bf60d357" translate="yes" xml:space="preserve">
          <source>This applies to files added to the source branch &lt;strong&gt;after&lt;/strong&gt; a daughter branch was created: if previously no commit was made on the daughter branch they will erroneously be added to the daughter branch in git.</source>
          <target state="translated">이는 딸 브랜치가 생성 된 &lt;strong&gt;후&lt;/strong&gt; 소스 브랜치에 추가 된 파일에 적용됩니다 . 이전에 딸 브랜치에서 커밋이 수행되지 않은 경우 git의 딸 브랜치에 잘못 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="cd519f993fc33ca56b2cb882b0ae5ba8b983012d" translate="yes" xml:space="preserve">
          <source>This argument will not be passed to &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt;. Instead it sets the vhost field in the git:// service request (to rest of the argument). Default is not to send vhost in such request (if sent).</source>
          <target state="translated">이 인수는 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 로 전달되지 않습니다 . 대신 git : // 서비스 요청에서 vhost 필드를 설정합니다 (인수의 나머지 부분). 기본적으로 이러한 요청에서 vhost를 보내지 않습니다 (전송 된 경우).</target>
        </trans-unit>
        <trans-unit id="9535ee34f2074fa8e689413e0518f1d3faf71e7d" translate="yes" xml:space="preserve">
          <source>This argument will not be passed to &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt;. Instead, it will cause the helper to start by sending git:// service requests to the remote side with the service field set to an appropriate value and the repository field set to rest of the argument. Default is not to send such a request.</source>
          <target state="translated">이 인수는 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 로 전달되지 않습니다 . 대신, 서비스 필드가 적절한 값으로 설정되고 저장소 필드가 인수의 나머지 부분으로 설정된 상태에서 git : // 서비스 요청을 원격으로 전송하여 헬퍼가 시작되도록합니다. 기본적으로 그러한 요청을 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b50cd8ffcdc46b4b68ae7776a2b00f1d1183b6dd" translate="yes" xml:space="preserve">
          <source>This asks for all the history reachable from the given commit but not from any branch, tag, or other reference. If you decide it&amp;rsquo;s something you want, you can always create a new reference to it, e.g.,</source>
          <target state="translated">이것은 주어진 커밋에서 도달 할 수있는 모든 히스토리를 요청하지만 브랜치, 태그 또는 다른 참조는 아닙니다. 원하는 것으로 결정하면 언제든지 새로운 참조를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7efa4dea1c9da210003e0c08e382eb543f66cbf7" translate="yes" xml:space="preserve">
          <source>This attribute controls the length of conflict markers left in the work tree file during a conflicted merge. Only setting to the value to a positive integer has any meaningful effect.</source>
          <target state="translated">이 속성은 충돌 병합 중에 작업 트리 파일에 남아있는 충돌 마커의 길이를 제어합니다. 값을 양의 정수로 설정하면 의미있는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4caef1788f338fb02906a32b34bfb366a7539a3a" translate="yes" xml:space="preserve">
          <source>This attribute enables and controls end-of-line normalization. When a text file is normalized, its line endings are converted to LF in the repository. To control what line ending style is used in the working directory, use the &lt;code&gt;eol&lt;/code&gt; attribute for a single file and the &lt;code&gt;core.eol&lt;/code&gt; configuration variable for all text files. Note that setting &lt;code&gt;core.autocrlf&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;input&lt;/code&gt; overrides &lt;code&gt;core.eol&lt;/code&gt; (see the definitions of those options in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">이 속성은 줄 끝 정규화를 활성화하고 제어합니다. 텍스트 파일이 정규화되면 저장소의 줄 끝이 LF로 변환됩니다. 작업 디렉토리에서 사용되는 줄 끝 스타일을 제어하려면 단일 파일에 &lt;code&gt;eol&lt;/code&gt; 속성을 사용하고 모든 텍스트 파일에 &lt;code&gt;core.eol&lt;/code&gt; 구성 변수를 사용하십시오. &lt;code&gt;core.autocrlf&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;input&lt;/code&gt; 설정하면 core.eol 이 재정의 &lt;code&gt;core.eol&lt;/code&gt; ( &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 해당 옵션 정의 참조 ).</target>
        </trans-unit>
        <trans-unit id="9abb1dada669f4b282e87943eaa4c10d9676f824" translate="yes" xml:space="preserve">
          <source>This attribute sets a specific line-ending style to be used in the working directory. It enables end-of-line conversion without any content checks, effectively setting the &lt;code&gt;text&lt;/code&gt; attribute. Note that setting this attribute on paths which are in the index with CRLF line endings may make the paths to be considered dirty. Adding the path to the index again will normalize the line endings in the index.</source>
          <target state="translated">이 속성은 작업 디렉토리에서 사용할 특정 줄 끝 스타일을 설정합니다. 내용 확인없이 줄 끝 변환을 가능하게하여 &lt;code&gt;text&lt;/code&gt; 속성을 효과적으로 설정 합니다. CRLF 줄 끝으로 색인에있는 경로에이 속성을 설정하면 경로가 더티로 간주 될 수 있습니다. 색인에 경로를 다시 추가하면 색인의 줄 끝이 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="a95f413f93d421b5f0b609911f7201baca2aa2de" translate="yes" xml:space="preserve">
          <source>This automatically updates the rev_map if needed (see &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; in the FILES section below for details).</source>
          <target state="translated">필요한 경우 rev_map이 자동으로 업데이트됩니다 (자세한 내용은 아래 파일 섹션의 &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; GIT_DIR / svn / ** /. rev_map. * 참조).</target>
        </trans-unit>
        <trans-unit id="756e07e0622c048ffb322b306c002b3fe742a463" translate="yes" xml:space="preserve">
          <source>This behavior can be suppressed with the &lt;code&gt;--no-ff&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;--no-ff&lt;/code&gt; 옵션을 사용하면이 동작을 억제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ad430bc747d1916521d538bf94c1847176c4231" translate="yes" xml:space="preserve">
          <source>This behavior is the default when the start point is a remote-tracking branch. Set the branch.autoSetupMerge configuration variable to &lt;code&gt;false&lt;/code&gt; if you want &lt;code&gt;git switch&lt;/code&gt;, &lt;code&gt;git checkout&lt;/code&gt; and &lt;code&gt;git branch&lt;/code&gt; to always behave as if &lt;code&gt;--no-track&lt;/code&gt; were given. Set it to &lt;code&gt;always&lt;/code&gt; if you want this behavior when the start-point is either a local or remote-tracking branch.</source>
          <target state="translated">시작 지점이 원격 추적 분기 인 경우이 동작이 기본값입니다. 에 branch.autoSetupMerge 구성 변수 설정 &lt;code&gt;false&lt;/code&gt; 원하는 경우 &lt;code&gt;git switch&lt;/code&gt; , &lt;code&gt;git checkout&lt;/code&gt; 하고 &lt;code&gt;git branch&lt;/code&gt; 것처럼 항상 행동에 &lt;code&gt;--no-track&lt;/code&gt; 주어진합니다. 시작점이 로컬 또는 원격 추적 분기 일 때이 동작을 원하면 &lt;code&gt;always&lt;/code&gt; 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="02d843a8479501e1f56c84b63bc83f8438d9dc3a" translate="yes" xml:space="preserve">
          <source>This boolean config option controls whether the maintenance task with name &lt;code&gt;&amp;lt;task&amp;gt;&lt;/code&gt; is run when no &lt;code&gt;--task&lt;/code&gt; option is specified to &lt;code&gt;git maintenance run&lt;/code&gt;. These config values are ignored if a &lt;code&gt;--task&lt;/code&gt; option exists. By default, only &lt;code&gt;maintenance.gc.enabled&lt;/code&gt; is true.</source>
          <target state="translated">This boolean config option controls whether the maintenance task with name &lt;code&gt;&amp;lt;task&amp;gt;&lt;/code&gt; is run when no &lt;code&gt;--task&lt;/code&gt; option is specified to &lt;code&gt;git maintenance run&lt;/code&gt; . These config values are ignored if a &lt;code&gt;--task&lt;/code&gt; option exists. By default, only &lt;code&gt;maintenance.gc.enabled&lt;/code&gt; is true.</target>
        </trans-unit>
        <trans-unit id="e589ab09a449c7cf7000e50f249deca2b148281c" translate="yes" xml:space="preserve">
          <source>This boolean will enable &lt;code&gt;fsync()&lt;/code&gt; when writing object files.</source>
          <target state="translated">이 부울은 객체 파일을 쓸 때 &lt;code&gt;fsync()&lt;/code&gt; 를 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="2a9d8bb8cd3e4996e1654fca8257ad2030d24d70" translate="yes" xml:space="preserve">
          <source>This breakage is of course most of the time unrelated to the breakage we are trying to locate in the commit graph. But it prevents us to know if the interesting &quot;bad behavior&quot; is present or not.</source>
          <target state="translated">이 파손은 물론 대부분 커밋 그래프에서 찾으려고하는 파손과 관련이 없습니다. 그러나 흥미로운 &quot;나쁜 행동&quot;이 있는지 아닌지를 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a7656b1b8b17aa91ea330f8fbedd0a75097faed" translate="yes" xml:space="preserve">
          <source>This bug has also been shown to affect non-symlink cases of replacing a directory with a file when it comes to the internal structures of the untracked cache, but no case has been reported where this resulted in wrong &quot;git status&quot; output.</source>
          <target state="translated">이 버그는 또한 추적되지 않은 캐시의 내부 구조와 관련하여 디렉토리를 파일로 바꾸는 심볼릭 링크가 아닌 경우에 영향을주는 것으로 나타 났지만 이로 인해 잘못된 &quot;git status&quot;출력이 발생한 경우는보고되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="bbb14e9c1a32bd1658d34b41d317e78fe3e2cf7e" translate="yes" xml:space="preserve">
          <source>This cache is meant to speed up commands that involve determining untracked files such as &lt;code&gt;git status&lt;/code&gt;.</source>
          <target state="translated">이 캐시는 &lt;code&gt;git status&lt;/code&gt; 와 같은 추적되지 않은 파일을 결정하는 명령의 속도를 높이기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="5e9291bab46bd7ea7a2a21b7e8d51146482ff7a6" translate="yes" xml:space="preserve">
          <source>This calculates the same as &lt;code&gt;--bisect&lt;/code&gt;, except that refs in &lt;code&gt;refs/bisect/&lt;/code&gt; are not used, and except that this outputs text ready to be eval&amp;rsquo;ed by the shell. These lines will assign the name of the midpoint revision to the variable &lt;code&gt;bisect_rev&lt;/code&gt;, and the expected number of commits to be tested after &lt;code&gt;bisect_rev&lt;/code&gt; is tested to &lt;code&gt;bisect_nr&lt;/code&gt;, the expected number of commits to be tested if &lt;code&gt;bisect_rev&lt;/code&gt; turns out to be good to &lt;code&gt;bisect_good&lt;/code&gt;, the expected number of commits to be tested if &lt;code&gt;bisect_rev&lt;/code&gt; turns out to be bad to &lt;code&gt;bisect_bad&lt;/code&gt;, and the number of commits we are bisecting right now to &lt;code&gt;bisect_all&lt;/code&gt;.</source>
          <target state="translated">동일한 계산이 &lt;code&gt;--bisect&lt;/code&gt; 에서 심판이 제외 &lt;code&gt;refs/bisect/&lt;/code&gt; 사용되지 않으며,이 준비가 출력 텍스트 쉘 eval'ed되는 것을 제외. 이 라인은 변수에 중간 개정의 이름을 지정합니다 &lt;code&gt;bisect_rev&lt;/code&gt; 후 테스트하고, 커밋의 예상 수를 &lt;code&gt;bisect_rev&lt;/code&gt; 가 테스트되고 &lt;code&gt;bisect_nr&lt;/code&gt; 경우 커밋의 예상 번호를 테스트 할, &lt;code&gt;bisect_rev&lt;/code&gt; 가 좋은 것으로 판명 &lt;code&gt;bisect_good&lt;/code&gt; 의 경우 커밋의 예상 번호를 테스트 할 &lt;code&gt;bisect_rev&lt;/code&gt; 판명가 나쁜 것으로 &lt;code&gt;bisect_bad&lt;/code&gt; 및 커밋의 수는 우리가 바로 지금 양분되어 &lt;code&gt;bisect_all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d3cf717b036e3b0e81df34e24d7ea082a035f6a" translate="yes" xml:space="preserve">
          <source>This can allow you to make partial mirrors when running fetch; but is generally not recommended because history will be skipped and lost.</source>
          <target state="translated">페치를 실행할 때 부분 미러를 만들 수 있습니다. 기록은 건너 뛰고 손실되므로 일반적으로 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="636e119b451b3bd7ccaf26b7d43733789f26ed19" translate="yes" xml:space="preserve">
          <source>This can also be set up as the default behaviour by using the &lt;code&gt;worktree.guessRemote&lt;/code&gt; config option.</source>
          <target state="translated">&lt;code&gt;worktree.guessRemote&lt;/code&gt; 구성 옵션 을 사용하여 기본 동작으로 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa409f68e80081ea9a669e9f13a5d077543254ef" translate="yes" xml:space="preserve">
          <source>This can be &lt;code&gt;end&lt;/code&gt;, which is the default, &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt; or &lt;code&gt;before&lt;/code&gt;.</source>
          <target state="translated">이 값은 &lt;code&gt;end&lt;/code&gt; 일 수 있으며 기본값은 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;after&lt;/code&gt; 또는 &lt;code&gt;before&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0de02388f102cf8ff32d10ea0ea1542e4435ae39" translate="yes" xml:space="preserve">
          <source>This can be any options that the archiver backend understands. See next section.</source>
          <target state="translated">아카이버 백엔드가 이해하는 모든 옵션이 될 수 있습니다. 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8ebe928ea2c46867d2d30a22aa44b6d209b60b27" translate="yes" xml:space="preserve">
          <source>This can be combined with the gitweb configuration:</source>
          <target state="translated">이것은 gitweb 설정과 결합 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3e2aafd0fe68d162abd0214f2c4dbcf97a317242" translate="yes" xml:space="preserve">
          <source>This can be enabled by default with the configuration option mailinfo.scissors.</source>
          <target state="translated">mailinfo.scissors 구성 옵션을 사용하여 기본적으로 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90b17ef61d05f77323fefc823815f1b4d0ca5c24" translate="yes" xml:space="preserve">
          <source>This can be set to a comma-separated list of strings. When a curl trace is enabled (see &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; above), whenever a &quot;Cookies:&quot; header sent by the client is dumped, values of cookies whose key is in that list (case-sensitive) are redacted.</source>
          <target state="translated">쉼표로 구분 된 문자열 목록으로 설정할 수 있습니다. 컬 추적이 활성화되면 ( 위의 &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; 참조) 클라이언트가 보낸 &quot;Cookies :&quot;헤더가 덤프 될 때마다 키가 해당 목록에있는 쿠키 값 (대소 문자 구분)이 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="3d49143ca76086473ec42d2280fe45285788984b" translate="yes" xml:space="preserve">
          <source>This can be used to color the metadata of a blame line depending on age of the line.</source>
          <target state="translated">라인의 나이에 따라 비난 라인의 메타 데이터를 채색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f9fdab39f98d82a2bdc74c13a484288c9af48d4" translate="yes" xml:space="preserve">
          <source>This can be used to convert arguments to a command run in a subdirectory so that they can still be used after moving to the top-level of the repository. For example:</source>
          <target state="translated">서브 디렉토리에서 실행되는 명령으로 인수를 변환하여 저장소의 최상위 레벨로 이동 한 후에도 계속 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c4f04c6d6345aed6141f4d5502d056991a7840c" translate="yes" xml:space="preserve">
          <source>This can be used when you want to include further changes to the merge, or want to write your own merge commit message.</source>
          <target state="translated">병합에 대한 추가 변경 사항을 포함 시키거나 자신의 병합 커밋 메시지를 작성하려고 할 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14d1ead4268c0c0f3315fceadadaf2f291770d82" translate="yes" xml:space="preserve">
          <source>This can be used with the &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;tag&lt;/code&gt; commands.</source>
          <target state="translated">이것은 &lt;code&gt;dcommit&lt;/code&gt; , &lt;code&gt;rebase&lt;/code&gt; , &lt;code&gt;branch&lt;/code&gt; 및 &lt;code&gt;tag&lt;/code&gt; 명령 과 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9067f207a93cdcf6d90b3183367a4ae6097c31d6" translate="yes" xml:space="preserve">
          <source>This can be useful when you want to publish the tree from a commit without exposing its full history. You might want to do this to publish an open source branch of a project whose current tree is &quot;clean&quot;, but whose full history contains proprietary or otherwise encumbered bits of code.</source>
          <target state="translated">이것은 전체 히스토리를 공개하지 않고 커밋에서 트리를 공개하려는 경우에 유용 할 수 있습니다. 현재 트리가 &quot;깨끗&quot;하지만 전체 히스토리에 독점적이거나 복잡하지 않은 코드 비트가 포함 된 프로젝트의 오픈 소스 분기를 공개하기 위해이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ddcbb1d5b5e22f922e078b6b0d84fe1dcc0409b" translate="yes" xml:space="preserve">
          <source>This can happen, for example, if you:</source>
          <target state="translated">예를 들어 다음과 같은 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9140f80526c6eb06ff98ed4abf5c0d2e07067266" translate="yes" xml:space="preserve">
          <source>This can only resolve two heads (i.e. the current branch and another branch you pulled from) using a 3-way merge algorithm. It tries to carefully detect criss-cross merge ambiguities and is considered generally safe and fast.</source>
          <target state="translated">이 방법은 3 방향 병합 알고리즘을 사용하여 두 개의 헤드 (즉, 현재 분기 및 가져온 다른 분기) 만 해결할 수 있습니다. 십자 병합 모호성을 신중하게 감지하려고 시도하며 일반적으로 안전하고 빠른 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="10679b433b60fbaff0452d6d903b314fee5164d2" translate="yes" xml:space="preserve">
          <source>This can only resolve two heads using a 3-way merge algorithm. When there is more than one common ancestor that can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3-way merge. This has been reported to result in fewer merge conflicts without causing mismerges by tests done on actual merge commits taken from Linux 2.6 kernel development history. Additionally this can detect and handle merges involving renames, but currently cannot make use of detected copies. This is the default merge strategy when pulling or merging one branch.</source>
          <target state="translated">이 방법은 3 방향 병합 알고리즘을 사용하여 두 헤드 만 해결할 수 있습니다. 3 방향 병합에 사용할 수있는 공통 조상이 둘 이상있는 경우 공통 조상의 병합 된 트리를 작성하고이를 3 방향 병합의 참조 트리로 사용합니다. 이는 Linux 2.6 커널 개발 히스토리에서 가져온 실제 병합 커밋에서 수행 된 테스트로 인한 혼란을 유발하지 않으면 서 병합 충돌을 줄이는 것으로보고되었습니다. 또한 이름 변경과 관련된 병합을 감지하고 처리 할 수 ​​있지만 현재는 감지 된 사본을 사용할 수 없습니다. 하나의 브랜치를 가져 오거나 병합 할 때의 기본 병합 전략입니다.</target>
        </trans-unit>
        <trans-unit id="2cac39aeb86961e1363f7613dfed0033661ab943" translate="yes" xml:space="preserve">
          <source>This can speed up operations like &lt;code&gt;git diff&lt;/code&gt; and &lt;code&gt;git status&lt;/code&gt; especially on filesystems like NFS that have weak caching semantics and thus relatively high IO latencies. When enabled, Git will do the index comparison to the filesystem data in parallel, allowing overlapping IO&amp;rsquo;s. Defaults to true.</source>
          <target state="translated">이것은 캐싱 시맨틱이 약하고 따라서 상대적으로 높은 IO 대기 시간을 갖는 NFS와 같은 파일 시스템에서 특히 &lt;code&gt;git diff&lt;/code&gt; 및 &lt;code&gt;git status&lt;/code&gt; 와 같은 작업의 속도를 높일 수 있습니다 . 활성화되면 Git은 파일 시스템 데이터와 병렬로 인덱스를 비교하여 IO가 겹치게합니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="9202266152fd1a0a2194149286bebd74fe30a95c" translate="yes" xml:space="preserve">
          <source>This capability can be advertised multiple times. The first applicable refspec takes precedence. The left-hand of refspecs advertised with this capability must cover all refs reported by the list command. If no &lt;code&gt;refspec&lt;/code&gt; capability is advertised, there is an implied &lt;code&gt;refspec *:*&lt;/code&gt;.</source>
          <target state="translated">이 기능은 여러 번 보급 될 수 있습니다. 적용 가능한 첫 번째 참조 스펙이 우선합니다. 이 기능으로 광고 된 참조 사양의 왼쪽은 list 명령으로보고 된 모든 참조를 포함해야합니다. &lt;code&gt;refspec&lt;/code&gt; 기능이 알려지지 않은 경우 &lt;code&gt;refspec *:*&lt;/code&gt; 가 내포 됩니다.</target>
        </trans-unit>
        <trans-unit id="561397ab0857a5bada65e17ac4aabd661a6939b5" translate="yes" xml:space="preserve">
          <source>This chapter covers internal details of the Git implementation which probably only Git developers need to understand.</source>
          <target state="translated">이 장에서는 Git 개발자 만 이해해야하는 Git 구현에 대한 내부 세부 사항을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="9301665301f3e50c4417122a8411be226ea5b235" translate="yes" xml:space="preserve">
          <source>This command always gets all objects. Historically, there were three options &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-t&lt;/code&gt; for choosing which objects to download. They are now silently ignored.</source>
          <target state="translated">이 명령은 항상 모든 객체를 가져옵니다. 역사적 으로 다운로드 할 객체를 선택하기위한 세 가지 옵션 &lt;code&gt;-a&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-t&lt;/code&gt; 가있었습니다 . 이제는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5b8a59dc9ca3a3d6f247d36df5fb54708fa69494" translate="yes" xml:space="preserve">
          <source>This command applies the patch but does not create a commit. Use &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; to create commits from patches generated by &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; and/or received by email.</source>
          <target state="translated">이 명령은 패치를 적용하지만 커밋을 생성하지는 않습니다. 사용 &lt;a href=&quot;git-am&quot;&gt;자식-AM [1]&lt;/a&gt; 에 의해 생성 된 패치에서 커밋 생성하는 &lt;a href=&quot;git-format-patch&quot;&gt;자식 형식의 패치 [1]&lt;/a&gt; 및 / 또는 이메일로 접수합니다.</target>
        </trans-unit>
        <trans-unit id="1f849e1e7df08a5bb28860e4715d22e12f5d5d20" translate="yes" xml:space="preserve">
          <source>This command assists the developer in this process by recording conflicted automerge results and corresponding hand resolve results on the initial manual merge, and applying previously recorded hand resolutions to their corresponding automerge results.</source>
          <target state="translated">이 명령은 충돌 된 자동 병합 결과 및 해당 손 해결 결과를 초기 수동 병합에 기록하고 이전에 기록 된 손 해상도를 해당 자동 병합 결과에 적용하여이 프로세스에서 개발자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b823d02fd766a4ae4b81090ce369454e7da568d6" translate="yes" xml:space="preserve">
          <source>This command caches credentials in memory for use by future Git programs. The stored credentials never touch the disk, and are forgotten after a configurable timeout. The cache is accessible over a Unix domain socket, restricted to the current user by filesystem permissions.</source>
          <target state="translated">이 명령은 향후 Git 프로그램에서 사용할 수 있도록 자격 증명을 메모리에 캐시합니다. 저장된 자격 증명은 디스크를 건드리지 않으며 구성 가능한 시간 초과 후 잊어 버립니다. 캐시는 Unix 도메인 소켓을 통해 액세스 할 수 있으며 파일 시스템 권한으로 현재 사용자로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="4784337d21599fe7fcfddcd79392d8470207170e" translate="yes" xml:space="preserve">
          <source>This command can be performed multiple times before a commit. It only adds the content of the specified file(s) at the time the add command is run; if you want subsequent changes included in the next commit, then you must run &lt;code&gt;git add&lt;/code&gt; again to add the new content to the index.</source>
          <target state="translated">이 명령은 커밋 전에 여러 번 수행 할 수 있습니다. add 명령이 실행될 때 지정된 파일의 내용 만 추가합니다. 다음 커밋에 후속 변경 사항을 포함하려면 &lt;code&gt;git add&lt;/code&gt; 를 다시 실행 하여 새 내용을 인덱스에 추가 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c286ab165ab2a31532b621372beb627366820ec4" translate="yes" xml:space="preserve">
          <source>This command can be used where a &lt;code&gt;filemodify&lt;/code&gt; directive can appear, allowing it to be used in the middle of a commit. For a &lt;code&gt;filemodify&lt;/code&gt; using an inline directive, it can also appear right before the &lt;code&gt;data&lt;/code&gt; directive.</source>
          <target state="translated">이 명령은 &lt;code&gt;filemodify&lt;/code&gt; 지시문이 나타날 수 있는 곳에서 사용될 수 있으며 , 커밋 도중에 사용될 수 있습니다. 인라인 지시문을 사용 하는 파일 &lt;code&gt;filemodify&lt;/code&gt; 경우 &lt;code&gt;data&lt;/code&gt; 지시문 바로 앞에 나타날 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74e4352fd2289d447be4133ac0e6d68d162428a6" translate="yes" xml:space="preserve">
          <source>This command can run &lt;code&gt;applypatch-msg&lt;/code&gt;, &lt;code&gt;pre-applypatch&lt;/code&gt;, and &lt;code&gt;post-applypatch&lt;/code&gt; hooks. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more information.</source>
          <target state="translated">이 명령은 &lt;code&gt;applypatch-msg&lt;/code&gt; , &lt;code&gt;pre-applypatch&lt;/code&gt; 및 &lt;code&gt;post-applypatch&lt;/code&gt; 훅을 실행할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2e5610ce87e5d01d8f8246892b4f05f886b6ad5a" translate="yes" xml:space="preserve">
          <source>This command can run &lt;code&gt;commit-msg&lt;/code&gt;, &lt;code&gt;prepare-commit-msg&lt;/code&gt;, &lt;code&gt;pre-commit&lt;/code&gt;, &lt;code&gt;post-commit&lt;/code&gt; and &lt;code&gt;post-rewrite&lt;/code&gt; hooks. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more information.</source>
          <target state="translated">이 명령은 &lt;code&gt;commit-msg&lt;/code&gt; , &lt;code&gt;prepare-commit-msg&lt;/code&gt; , &lt;code&gt;pre-commit&lt;/code&gt; , &lt;code&gt;post-commit&lt;/code&gt; 및 &lt;code&gt;post-rewrite&lt;/code&gt; hooks를 실행할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6ba8d48bf258fdf0b61e4a3a7667022fd45b3e45" translate="yes" xml:space="preserve">
          <source>This command creates an empty Git repository - basically a &lt;code&gt;.git&lt;/code&gt; directory with subdirectories for &lt;code&gt;objects&lt;/code&gt;, &lt;code&gt;refs/heads&lt;/code&gt;, &lt;code&gt;refs/tags&lt;/code&gt;, and template files. An initial &lt;code&gt;HEAD&lt;/code&gt; file that references the HEAD of the master branch is also created.</source>
          <target state="translated">이 명령은 빈 Git 리포지토리 (기본적으로 &lt;code&gt;objects&lt;/code&gt; , 참조 &lt;code&gt;refs/heads&lt;/code&gt; , 참조 &lt;code&gt;refs/tags&lt;/code&gt; 및 템플릿 파일의 하위 디렉토리가 있는 &lt;code&gt;.git&lt;/code&gt; 디렉토리)를 만듭니다. 마스터 분기의 HEAD를 참조 하는 초기 &lt;code&gt;HEAD&lt;/code&gt; 파일도 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="f52be87adec196973421cd7319ee0f98c1860983" translate="yes" xml:space="preserve">
          <source>This command degenerates to download everything to complete the asked refs from the remote side when the local side does not have a common ancestor commit.</source>
          <target state="translated">이 명령은 로컬 측에 공통 조상 커밋이없는 경우 원격 측에서 요청 된 참조를 완료하기 위해 모든 것을 다운로드하도록 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="194b70091800ec19021441e8c1778ca9e02b53d5" translate="yes" xml:space="preserve">
          <source>This command ensures that the changes in the experimental branch are already in the current branch.</source>
          <target state="translated">이 명령은 실험 브랜치의 변경 사항이 이미 현재 브랜치에 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1b788d383418fe8b134f7630991a2d6359c7dd7c" translate="yes" xml:space="preserve">
          <source>This command finds new changes in p4 and imports them as Git commits.</source>
          <target state="translated">이 명령은 p4에서 새로운 변경 사항을 찾고 Git 커밋으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4b11fc8efec3bd343a83e9f1aa4620a514b9ab8e" translate="yes" xml:space="preserve">
          <source>This command formats the lines of its standard input into a table with multiple columns. Each input line occupies one cell of the table. It is used internally by other git commands to format output into columns.</source>
          <target state="translated">이 명령은 표준 입력 행을 여러 열이있는 테이블로 형식화합니다. 각 입력 라인은 테이블의 하나의 셀을 차지합니다. 출력을 열로 형식화하기 위해 다른 git 명령에 의해 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ade7fdc971ed1f0936fb8fbff7bb1574367ca37b" translate="yes" xml:space="preserve">
          <source>This command is extremely useful if the frontend does not know (or does not care to know) what files are currently on the branch, and therefore cannot generate the proper &lt;code&gt;filedelete&lt;/code&gt; commands to update the content.</source>
          <target state="translated">이 명령은 프론트 엔드가 현재 브랜치에있는 파일을 알지 못하거나 알지 못하는 경우에 매우 유용하므로 컨텐츠를 업데이트하기 위해 적절한 &lt;code&gt;filedelete&lt;/code&gt; 명령을 생성 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5f45dc9e63088b4d8e620891decbfdd6655de376" translate="yes" xml:space="preserve">
          <source>This command is intended mostly for internal use by scripts automatically invoking &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">이 명령은 주로 &lt;code&gt;git merge&lt;/code&gt; 를 자동으로 호출하는 스크립트에 의해 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3710225b15829bc8cbeb92895b81ff709286e645" translate="yes" xml:space="preserve">
          <source>This command is recursive by default.</source>
          <target state="translated">이 명령은 기본적으로 재귀 적입니다.</target>
        </trans-unit>
        <trans-unit id="6e8668d616c8790cb8d71e8720597de54ced7850" translate="yes" xml:space="preserve">
          <source>This command is used to combine all objects that do not currently reside in a &quot;pack&quot;, into a pack. It can also be used to re-organize existing packs into a single, more efficient pack.</source>
          <target state="translated">이 명령은 현재 &quot;팩&quot;에없는 모든 오브젝트를 팩으로 결합하는 데 사용됩니다. 또한 기존 팩을보다 효율적인 단일 팩으로 재구성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7cbc44be580e3c1734536d3564c4b9dc7e501fa" translate="yes" xml:space="preserve">
          <source>This command is used to solve the storage and performance problem by storing the refs in a single file, &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt;. When a ref is missing from the traditional &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory hierarchy, it is looked up in this file and used if found.</source>
          <target state="translated">이 명령은 참조를 단일 파일 &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; 에 저장하여 스토리지 및 성능 문제를 해결하는 데 사용됩니다 . 기존 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 디렉토리 계층 에서 참조가 누락 된 경우이 파일에서 참조가 발견되면 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="43f707239bbecf8d6bf96bbdb4b367abb8fd5357" translate="yes" xml:space="preserve">
          <source>This command is usually not invoked directly by the end user. The UI for the protocol is on the &lt;code&gt;git archive&lt;/code&gt; side, and the program pair is meant to be used to get an archive from a remote repository.</source>
          <target state="translated">이 명령은 일반적으로 최종 사용자가 직접 호출하지 않습니다. 프로토콜의 UI는 &lt;code&gt;git archive&lt;/code&gt; 측에 있으며 프로그램 쌍은 원격 저장소에서 아카이브를 가져 오는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="17d67b43408b7b4804e33e1e3b79dc1fbf03af1b" translate="yes" xml:space="preserve">
          <source>This command is usually not invoked directly by the end user. The UI for the protocol is on the &lt;code&gt;git fetch-pack&lt;/code&gt; side, and the program pair is meant to be used to pull updates from a remote repository. For push operations, see &lt;code&gt;git send-pack&lt;/code&gt;.</source>
          <target state="translated">이 명령은 일반적으로 최종 사용자가 직접 호출하지 않습니다. 프로토콜의 UI는 &lt;code&gt;git fetch-pack&lt;/code&gt; 쪽에 있으며 프로그램 쌍은 원격 저장소에서 업데이트를 가져 오는 데 사용됩니다. 푸시 조작에 대해서는 &lt;code&gt;git send-pack&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="36ac8b84f92c3cf141e5ae101adcc45178aae4c7" translate="yes" xml:space="preserve">
          <source>This command is usually not invoked directly by the end user. The UI for the protocol is on the &lt;code&gt;git send-pack&lt;/code&gt; side, and the program pair is meant to be used to push updates to remote repository. For pull operations, see &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt;.</source>
          <target state="translated">이 명령은 일반적으로 최종 사용자가 직접 호출하지 않습니다. 프로토콜의 UI는 &lt;code&gt;git send-pack&lt;/code&gt; 쪽에 있으며 프로그램 쌍은 업데이트를 원격 저장소로 푸시하는 데 사용됩니다. 풀 조작에 대해서는 &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8cac5b996748b602d2e8f0cf9273cee3d1c4d80" translate="yes" xml:space="preserve">
          <source>This command lets you check that intermediate commits are compilable. The todo list becomes like that:</source>
          <target state="translated">이 명령을 사용하면 중간 커밋이 컴파일 가능한지 확인할 수 있습니다. 할 일 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56bca57be11add071b8aeae38f6a28f443105856" translate="yes" xml:space="preserve">
          <source>This command manages the information recorded in the reflogs.</source>
          <target state="translated">이 명령은 참조 로그에 기록 된 정보를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="7c7ebb85111dd101dc1c2782f6e5cbc235a39c44" translate="yes" xml:space="preserve">
          <source>This command provides a way to interact with p4 repositories using Git.</source>
          <target state="translated">이 명령은 Git을 사용하여 p4 리포지토리와 상호 작용하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="637c92f99feb8b30861eeaee2e3273c64a9b5351" translate="yes" xml:space="preserve">
          <source>This command reads some patches or commit messages from either the &amp;lt;file&amp;gt; arguments or the standard input if no &amp;lt;file&amp;gt; is specified. If &lt;code&gt;--parse&lt;/code&gt; is specified, the output consists of the parsed trailers.</source>
          <target state="translated">이 명령은 &amp;lt;file&amp;gt; 인수 또는 &amp;lt;file&amp;gt;이 지정되지 않은 경우 표준 입력에서 일부 패치 또는 커밋 메시지를 읽습니다. 경우 &lt;code&gt;--parse&lt;/code&gt; 가 지정, 출력은 구문 분석 된 트레일러로 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a38646d64359b52991af1358c674765acf2c0c11" translate="yes" xml:space="preserve">
          <source>This command should not list any commits. Otherwise, check out &lt;code&gt;master&lt;/code&gt; and merge &lt;code&gt;maint&lt;/code&gt; into it.</source>
          <target state="translated">이 명령은 커밋을 나열하지 않아야합니다. 그렇지 않으면 &lt;code&gt;master&lt;/code&gt; 를 확인하고 &lt;code&gt;maint&lt;/code&gt; 을 병합 하십시오.</target>
        </trans-unit>
        <trans-unit id="6a853b09f1818b9d32f936bd42aa8a84af13b068" translate="yes" xml:space="preserve">
          <source>This command shows the differences between two versions of a patch series, or more generally, two commit ranges (ignoring merge commits).</source>
          <target state="translated">이 명령은 패치 시리즈의 두 버전 또는보다 일반적으로 두 커밋 범위 (병합 커밋 무시)의 차이점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="852903a68075d19a47d4520af94edde77996207f" translate="yes" xml:space="preserve">
          <source>This command stores credentials indefinitely on disk for use by future Git programs.</source>
          <target state="translated">이 명령은 향후 Git 프로그램에서 사용할 수 있도록 자격 증명을 디스크에 무기한 저장합니다.</target>
        </trans-unit>
        <trans-unit id="d143bf10d727fe2f5d0639ed85e199dd448d8bd2" translate="yes" xml:space="preserve">
          <source>This command updates the index using the current content found in the working tree, to prepare the content staged for the next commit. It typically adds the current content of existing paths as a whole, but with some options it can also be used to add content with only part of the changes made to the working tree files applied, or remove paths that do not exist in the working tree anymore.</source>
          <target state="translated">이 명령은 다음 커밋을 위해 준비된 내용을 준비하기 위해 작업 트리에있는 현재 내용을 사용하여 색인을 업데이트합니다. 일반적으로 기존 경로의 현재 내용을 전체적으로 추가하지만 일부 옵션을 사용하면 적용된 작업 트리 파일의 변경 내용 중 일부만 적용하거나 작업 트리에 존재하지 않는 경로를 제거하는 데 사용할 수도 있습니다 더 이상</target>
        </trans-unit>
        <trans-unit id="61eacd31ecbd262bdcbed11d9c6103318919d1be" translate="yes" xml:space="preserve">
          <source>This command uploads a mailbox generated with &lt;code&gt;git format-patch&lt;/code&gt; into an IMAP drafts folder. This allows patches to be sent as other email is when using mail clients that cannot read mailbox files directly. The command also works with any general mailbox in which emails have the fields &quot;From&quot;, &quot;Date&quot;, and &quot;Subject&quot; in that order.</source>
          <target state="translated">이 명령은 &lt;code&gt;git format-patch&lt;/code&gt; 로 생성 된 메일 함을 IMAP 초안 폴더에 업로드 합니다. 메일 함 파일을 직접 읽을 수없는 메일 클라이언트를 사용할 때 다른 이메일로 패치를 보낼 수 있습니다. 이 명령은 전자 메일에 &quot;보낸 사람&quot;, &quot;날짜&quot;및 &quot;제목&quot;필드가 순서대로있는 일반 사서함에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a3bcbdfcf8f3a072ac23f24cf310648f9691fb70" translate="yes" xml:space="preserve">
          <source>This command uses a binary search algorithm to find which commit in your project&amp;rsquo;s history introduced a bug. You use it by first telling it a &quot;bad&quot; commit that is known to contain the bug, and a &quot;good&quot; commit that is known to be before the bug was introduced. Then &lt;code&gt;git
bisect&lt;/code&gt; picks a commit between those two endpoints and asks you whether the selected commit is &quot;good&quot; or &quot;bad&quot;. It continues narrowing down the range until it finds the exact commit that introduced the change.</source>
          <target state="translated">이 명령은 이진 검색 알고리즘을 사용하여 프로젝트 기록에서 어떤 커밋에 버그가 발생했는지 확인합니다. 먼저 버그를 포함하는 것으로 알려진 &quot;나쁜&quot;커밋과 버그가 소개되기 전에 알려진 &quot;좋은&quot;커밋을 알려서이 도구를 사용합니다. 그런 다음 &lt;code&gt;git bisect&lt;/code&gt; 는이 두 끝점 사이에서 커밋을 선택하고 선택한 커밋이 &quot;양호&quot;인지 &quot;나쁜&quot;것인지 묻습니다. 변경을 도입 한 정확한 커밋을 찾을 때까지 범위를 계속 좁 힙니다.</target>
        </trans-unit>
        <trans-unit id="097f8af4b6f26b418927a5ca4b24d71746b1f843" translate="yes" xml:space="preserve">
          <source>This command uses the &lt;code&gt;diff.color.*&lt;/code&gt; and &lt;code&gt;pager.range-diff&lt;/code&gt; settings (the latter is on by default). See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">이 명령은 &lt;code&gt;diff.color.*&lt;/code&gt; 및 &lt;code&gt;pager.range-diff&lt;/code&gt; 설정을 사용합니다 (후자는 기본적으로 켜져 있음). &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="03bab6a03561ee7ff2e9bf92505bcdd5322bfb51" translate="yes" xml:space="preserve">
          <source>This command will fail with non-zero status upon error. Some exit codes are:</source>
          <target state="translated">이 명령은 오류시 0이 아닌 상태로 실패합니다. 일부 종료 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ed6af6e5518c122d94f4b8fea824fc7938bd5aa" translate="yes" xml:space="preserve">
          <source>This command will fetch changes from the remote branches to your remote-tracking branches &lt;code&gt;origin/*&lt;/code&gt;, and merge the default branch into the current branch.</source>
          <target state="translated">이 명령은 원격 브랜치에서 원격 추적 브랜치 &lt;code&gt;origin/*&lt;/code&gt; 로 변경 사항을 가져오고 기본 브랜치를 현재 브랜치로 병합합니다.</target>
        </trans-unit>
        <trans-unit id="99c24081605f25434a1fa0a51df82045bf4b7763" translate="yes" xml:space="preserve">
          <source>This command will save your changes away to the &lt;code&gt;stash&lt;/code&gt;, and reset your working tree and the index to match the tip of your current branch. Then you can make your fix as usual.</source>
          <target state="translated">이 명령은 변경 사항을 &lt;code&gt;stash&lt;/code&gt; 저장 하고 작업 트리와 색인을 현재 분기의 끝과 일치하도록 재설정합니다. 그런 다음 평소와 같이 수정을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb41b9bb98cbe715b8d6c0b50eb0b52309cdc91a" translate="yes" xml:space="preserve">
          <source>This commit will get blown away so a throw-away log message is OK.</source>
          <target state="translated">이 커밋은 사라져 버려 로그 아웃 메시지가 정상입니다.</target>
        </trans-unit>
        <trans-unit id="068d7057b3017084327709c3e61c2e224fb2a5f6" translate="yes" xml:space="preserve">
          <source>This commits all other changes in the index.</source>
          <target state="translated">이것은 인덱스의 다른 모든 변경 사항을 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="1d649ab8ff53024e7549864469811ccee0abf2e7" translate="yes" xml:space="preserve">
          <source>This commits your first edits in &lt;code&gt;branch1&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;branch1&lt;/code&gt; 에서 첫 번째 편집을 커밋합니다 .</target>
        </trans-unit>
        <trans-unit id="8bc13c84a009ea0d6abb173ac6100dc00ae7606a" translate="yes" xml:space="preserve">
          <source>This compares stage 2 (our branch), stage 3 (their branch) and the working tree file and outputs a combined diff, similar to the way &lt;code&gt;diff-tree&lt;/code&gt; shows a merge commit with these flags.</source>
          <target state="translated">이것은 단계 2 (우리의 분기), 단계 3 (그들의 분기) 및 작업 트리 파일을 비교하고 &lt;code&gt;diff-tree&lt;/code&gt; 가 이러한 플래그와의 병합 커밋을 표시하는 방식과 유사한 결합 된 diff를 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="d3fe164a17e549b712f12743eb90dc676fb8455c" translate="yes" xml:space="preserve">
          <source>This computation involves traversing all the reachable objects, i.e. it has the same cost as &lt;code&gt;git prune&lt;/code&gt;. It is primarily intended to fix corruption caused by garbage collecting using older versions of Git, which didn&amp;rsquo;t protect objects referred to by reflogs.</source>
          <target state="translated">이 계산에는 도달 가능한 모든 객체를 순회하는 것이 포함됩니다. 즉, &lt;code&gt;git prune&lt;/code&gt; 과 동일한 비용 을가 집니다. reflogs에 의해 참조되는 객체를 보호하지 않는 구 버전의 Git을 사용하여 가비지 수집으로 인한 손상을 수정하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9e7c3905269f2318ce8a27a07b91b053d9dd7129" translate="yes" xml:space="preserve">
          <source>This configuration can be specified multiple times in order to allow multiple notes refs to be included. In that case, it will behave similarly to multiple &lt;code&gt;--[no-]notes[=]&lt;/code&gt; options passed in. That is, a value of &lt;code&gt;true&lt;/code&gt; will show the default notes, a value of &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; will also show notes from that notes ref and a value of &lt;code&gt;false&lt;/code&gt; will negate previous configurations and not show notes.</source>
          <target state="translated">여러 음표 참조가 포함되도록이 구성을 여러 번 지정할 수 있습니다. 이 경우 전달 된 여러 &lt;code&gt;--[no-]notes[=]&lt;/code&gt; 옵션 과 유사하게 작동합니다 . 즉, &lt;code&gt;true&lt;/code&gt; 값은 기본 메모를 표시하고 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 값은 해당 메모의 메모를 표시합니다 ref 및 &lt;code&gt;false&lt;/code&gt; 값은 이전 구성을 무효화하고 메모를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6aa4372bde5e931f9e4e006e5a3cd0aea5ccf17" translate="yes" xml:space="preserve">
          <source>This configuration is used in two ways:</source>
          <target state="translated">이 구성은 두 가지 방식으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="06f31556dacb48424e7a1be662dd26364f785ce9" translate="yes" xml:space="preserve">
          <source>This configuration variable is useful in cases where you&amp;rsquo;d like to centrally configure your Git hooks instead of configuring them on a per-repository basis, or as a more flexible and centralized alternative to having an &lt;code&gt;init.templateDir&lt;/code&gt; where you&amp;rsquo;ve changed default hooks.</source>
          <target state="translated">이 구성 변수는 저장소별로 구성하는 대신 Git 후크를 중앙에서 구성하려는 경우 또는 기본 후크를 변경 한 &lt;code&gt;init.templateDir&lt;/code&gt; 대신에보다 유연하고 중앙화 된 대안으로 유용합니다 . .</target>
        </trans-unit>
        <trans-unit id="eed4a11499740f4bb5f61d3ce7354c5409f33bf3" translate="yes" xml:space="preserve">
          <source>This configures how whitespace is ignored when performing the move detection for &lt;code&gt;--color-moved&lt;/code&gt;. It can be set by the &lt;code&gt;diff.colorMovedWS&lt;/code&gt; configuration setting. These modes can be given as a comma separated list:</source>
          <target state="translated">&lt;code&gt;--color-moved&lt;/code&gt; 에 대한 이동 감지를 수행 할 때 공백이 무시되는 방식을 구성합니다 . &lt;code&gt;diff.colorMovedWS&lt;/code&gt; 구성 설정 으로 설정할 수 있습니다 . 이 모드는 쉼표로 구분 된 목록으로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b4ea1fd788cef298d939e77017eddec04b80461" translate="yes" xml:space="preserve">
          <source>This configures how whitespace is ignored when performing the move detection for &lt;code&gt;--color-moved&lt;/code&gt;. These modes can be given as a comma separated list:</source>
          <target state="translated">&lt;code&gt;--color-moved&lt;/code&gt; 에 대한 이동 감지를 수행 할 때 공백이 무시되는 방식을 구성합니다 . 이 모드는 쉼표로 구분 된 목록으로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77030a3f3e0bddf7aada34bc0939552bc0993e3c" translate="yes" xml:space="preserve">
          <source>This counts the number of unpacked object files and disk space consumed by them, to help you decide when it is a good time to repack.</source>
          <target state="translated">이것은 압축을 풀기 좋은시기를 결정하는 데 도움이되도록 압축 해제 된 오브젝트 파일 수와 디스크 공간이 소비하는 디스크 공간을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="3e67b0f2a3d6f811dcdec6a80edd2cc8d01b0b6b" translate="yes" xml:space="preserve">
          <source>This creates a &quot;lightweight&quot; tag. If you would also like to include a comment with the tag, and possibly sign it cryptographically, then you should create a tag object instead; see the &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; man page for details.</source>
          <target state="translated">&quot;가벼운&quot;태그가 생성됩니다. 태그에 주석을 포함하고 암호화로 서명하려면 태그 객체를 대신 만들어야합니다. 자세한 내용은 &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="687e61032de29ec5a828bf99d3854a432acd2a82" translate="yes" xml:space="preserve">
          <source>This creates a new directory &quot;myrepo&quot; containing a clone of Alice&amp;rsquo;s repository. The clone is on an equal footing with the original project, possessing its own copy of the original project&amp;rsquo;s history.</source>
          <target state="translated">그러면 Alice 저장소의 복제본이 포함 된 &quot;myrepo&quot;디렉토리가 새로 만들어집니다. 복제본은 원래 프로젝트 기록과 동일한 사본을 보유하고있는 원래 프로젝트와 동등한 위치에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2fd84fc2fa04021fed2cadb8707ca64b05a22fb" translate="yes" xml:space="preserve">
          <source>This creates a single &quot;pack file&quot; in .git/objects/pack/ containing all currently unpacked objects. You can then run</source>
          <target state="translated">이렇게하면 현재 압축이 풀린 모든 객체가 포함 된 .git / objects / pack /에 단일 &quot;팩 파일&quot;이 생성됩니다. 그런 다음 실행할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="bf43931e74b20a3da5197ed923f890fe71d72016" translate="yes" xml:space="preserve">
          <source>This default configuration is achieved by creating references to the remote branch heads under &lt;code&gt;refs/remotes/origin&lt;/code&gt; and by initializing &lt;code&gt;remote.origin.url&lt;/code&gt; and &lt;code&gt;remote.origin.fetch&lt;/code&gt; configuration variables.</source>
          <target state="translated">이 기본 구성은 &lt;code&gt;refs/remotes/origin&lt;/code&gt; 에서 원격 분기 헤드에 대한 참조를 작성 하고 &lt;code&gt;remote.origin.url&lt;/code&gt; 및 &lt;code&gt;remote.origin.fetch&lt;/code&gt; 구성 변수를 초기화하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="984768ad68337dfe2b0015e657c9f4f069afabc8" translate="yes" xml:space="preserve">
          <source>This defines two submodules, &lt;code&gt;libfoo&lt;/code&gt; and &lt;code&gt;libbar&lt;/code&gt;. These are expected to be checked out in the paths &lt;code&gt;include/foo&lt;/code&gt; and &lt;code&gt;include/bar&lt;/code&gt;, and for both submodules a URL is specified which can be used for cloning the submodules.</source>
          <target state="translated">여기에는 두 개의 서브 모듈 인 &lt;code&gt;libfoo&lt;/code&gt; 및 &lt;code&gt;libbar&lt;/code&gt; 가 정의 됩니다. 이들은 &lt;code&gt;include/foo&lt;/code&gt; 및 &lt;code&gt;include/bar&lt;/code&gt; 경로에서 체크 아웃 될 것으로 예상되며 , 두 서브 모듈 모두 서브 모듈 복제에 사용할 수있는 URL이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="57db5304522b1070a0df1071ce5df5d38ea7d002" translate="yes" xml:space="preserve">
          <source>This describes how Tony Luck uses Git in his role as maintainer of the IA64 architecture for the Linux kernel.</source>
          <target state="translated">여기에서는 Tony Luck이 Linux 커널의 IA64 아키텍처 관리자로서 Git을 어떻게 사용하는지 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c9e275f2996b22cd4415c594fae8f08a0dfe70e8" translate="yes" xml:space="preserve">
          <source>This determines the coloring scheme to be applied to blame output. It can be &lt;code&gt;repeatedLines&lt;/code&gt;, &lt;code&gt;highlightRecent&lt;/code&gt;, or &lt;code&gt;none&lt;/code&gt; which is the default.</source>
          <target state="translated">이것은 비난 출력에 적용될 채색 체계를 결정합니다. 그것은 될 수 &lt;code&gt;repeatedLines&lt;/code&gt; , &lt;code&gt;highlightRecent&lt;/code&gt; , 또는 &lt;code&gt;none&lt;/code&gt; 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="56ee29b22f07db9306c3380b74b5b0180828e415" translate="yes" xml:space="preserve">
          <source>This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/objects&quot; will be used instead.</source>
          <target state="translated">$ GIT_COMMON_DIR이 설정되고 대신 &quot;$ GIT_COMMON_DIR / objects&quot;가 사용되면이 디렉토리는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2072b137cd96280de0e098678b51f23a76dcd0dc" translate="yes" xml:space="preserve">
          <source>This disables potentially expensive checks to workaround broken symlinks checked into SVN by broken clients. Set this option to &quot;false&quot; if you track a SVN repository with many empty blobs that are not symlinks. This option may be changed while &lt;code&gt;git svn&lt;/code&gt; is running and take effect on the next revision fetched. If unset, &lt;code&gt;git svn&lt;/code&gt; assumes this option to be &quot;true&quot;.</source>
          <target state="translated">이로 인해 손상된 클라이언트가 SVN에 체크인 한 손상된 심볼릭 링크를 고칠 수있는 잠재적 인 검사가 비활성화됩니다. 심볼릭 링크가 아닌 빈 블롭이 많은 SVN 저장소를 추적하는 경우이 옵션을 &quot;false&quot;로 설정하십시오. 이 옵션은 &lt;code&gt;git svn&lt;/code&gt; 이 실행되는 동안 변경 될 수 있으며 가져온 다음 개정판에 적용됩니다. 설정하지 않으면 &lt;code&gt;git svn&lt;/code&gt; 은이 옵션을 &quot;true&quot;로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="006e62625e60aabc7f31fa591f6f9b4a3bd2a878" translate="yes" xml:space="preserve">
          <source>This document attempts to write down and motivate some of the workflow elements used for &lt;code&gt;git.git&lt;/code&gt; itself. Many ideas apply in general, though the full workflow is rarely required for smaller projects with fewer people involved.</source>
          <target state="translated">이 문서는 &lt;code&gt;git.git&lt;/code&gt; 자체에 사용 된 일부 워크 플로 요소를 작성하고 동기를 부여 합니다. 인원이 적은 소규모 프로젝트에는 전체 워크 플로우가 거의 필요하지 않지만 많은 아이디어가 일반적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8cd9193645885514540ac19f3167f508bebca422" translate="yes" xml:space="preserve">
          <source>This document presents a specification for a version 2 of Git&amp;rsquo;s wire protocol. Protocol v2 will improve upon v1 in the following ways:</source>
          <target state="translated">이 문서는 Git의 와이어 프로토콜 버전 2에 대한 사양을 제시합니다. 프로토콜 v2는 다음과 같은 방식으로 v1을 개선합니다.</target>
        </trans-unit>
        <trans-unit id="46bd1a26c48d1772be26d3d869cc4b6544004ea1" translate="yes" xml:space="preserve">
          <source>This document shows the &quot;raw&quot; syntax as seen by git. The shell and other UIs might require additional quoting to protect special characters and to avoid word splitting.</source>
          <target state="translated">이 문서는 git에서 볼 수있는 &quot;raw&quot;구문을 보여줍니다. 쉘 및 기타 UI에는 특수 문자를 보호하고 단어 분리를 피하기 위해 추가 인용이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a76f8971dde9f8810b677765aca0d70490d9f8fa" translate="yes" xml:space="preserve">
          <source>This document will serve as the master list for extensions. Any implementation wishing to define a new extension should make a note of it here, in order to claim the name.</source>
          <target state="translated">이 문서는 확장의 마스터 목록으로 사용됩니다. 새 확장명을 정의하려는 모든 구현은 이름을 주장하기 위해 여기에 메모해야합니다.</target>
        </trans-unit>
        <trans-unit id="d24a591988945bec7d040b25bd5a37c73014bcf3" translate="yes" xml:space="preserve">
          <source>This does not affect &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; or the &lt;code&gt;git-diff-*&lt;/code&gt; plumbing commands. Can be overridden on the command line with the &lt;code&gt;--color[=&amp;lt;when&amp;gt;]&lt;/code&gt; option.</source>
          <target state="translated">이것은 &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; 또는 &lt;code&gt;git-diff-*&lt;/code&gt; 배관 명령 에는 영향을 미치지 않습니다 . &lt;code&gt;--color[=&amp;lt;when&amp;gt;]&lt;/code&gt; 옵션 을 사용하여 명령 줄에서 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99af460532d2c9f72e65ed17f7464c8aa563e1f4" translate="yes" xml:space="preserve">
          <source>This does not force normalization of text files, but does ensure that text files that you introduce to the repository have their line endings normalized to LF when they are added, and that files that are already normalized in the repository stay normalized.</source>
          <target state="translated">이렇게하면 텍스트 파일이 정규화되지 않지만 리포지토리에 도입 한 텍스트 파일의 행 끝이 추가 될 때 LF로 정규화되고 리포지토리에서 이미 정규화 된 파일이 정규화 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="257328db317fb853114a41f8430f87cd826d08a0" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t interfere with interoperating with the Subversion repository you cloned from, but if you wish for your local Git repository to be able to interoperate with someone else&amp;rsquo;s local Git repository, either don&amp;rsquo;t use this option or you should both use it in the same local time zone.</source>
          <target state="translated">복제 한 Subversion 저장소와의 상호 운용을 방해하지는 않지만 로컬 Git 저장소가 다른 사람의 로컬 Git 저장소와 상호 운용되도록하려면이 옵션을 사용하지 마십시오. 동일한 현지 시간대.</target>
        </trans-unit>
        <trans-unit id="45497ef8f3614492732f059c04bc30af3c6593e9" translate="yes" xml:space="preserve">
          <source>This effectively runs &lt;code&gt;add --interactive&lt;/code&gt;, but bypasses the initial command menu and directly jumps to the &lt;code&gt;patch&lt;/code&gt; subcommand. See &amp;ldquo;Interactive mode&amp;rdquo; for details.</source>
          <target state="translated">&lt;code&gt;add --interactive&lt;/code&gt; 를 효과적으로 실행 하지만 초기 명령 메뉴를 무시하고 &lt;code&gt;patch&lt;/code&gt; 하위 명령으로 바로 이동합니다 . 자세한 내용은 &quot;대화식 모드&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="53c54ba0465bbf9916ac436659dbf61aedb86156" translate="yes" xml:space="preserve">
          <source>This enables parent rewriting, see &lt;code&gt;History Simplification&lt;/code&gt; above.</source>
          <target state="translated">이렇게하면 부모 재 작성이 가능 합니다. 위의 &lt;code&gt;History Simplification&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ccdf590466d01d04dcf6da8ad6a6bec9f02c4d8e" translate="yes" xml:space="preserve">
          <source>This environment allows the specification of an alternate index file. If not specified, the default of &lt;code&gt;$GIT_DIR/index&lt;/code&gt; is used.</source>
          <target state="translated">이 환경에서는 대체 인덱스 파일을 지정할 수 있습니다. 지정하지 않으면 &lt;code&gt;$GIT_DIR/index&lt;/code&gt; 의 기본값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2abd55a6650395bf249165e2f6568e98ab14958c" translate="yes" xml:space="preserve">
          <source>This environment variable allows the specification of an index version for new repositories. It won&amp;rsquo;t affect existing index files. By default index file version 2 or 3 is used. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; for more information.</source>
          <target state="translated">이 환경 변수를 사용하면 새 리포지토리에 대한 인덱스 버전을 지정할 수 있습니다. 기존 색인 파일에는 영향을 미치지 않습니다. 기본적으로 색인 파일 버전 2 또는 3이 사용됩니다. 자세한 내용은 &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2763e4fc7ba1973ac90184c067d20f9d0fda70a8" translate="yes" xml:space="preserve">
          <source>This environment variable overrides &lt;code&gt;$EDITOR&lt;/code&gt; and &lt;code&gt;$VISUAL&lt;/code&gt;. It is used by several Git commands when, on interactive mode, an editor is to be launched. See also &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt; and the &lt;code&gt;core.editor&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">이 환경 변수는 &lt;code&gt;$EDITOR&lt;/code&gt; 및 &lt;code&gt;$VISUAL&lt;/code&gt; 대체 합니다. 대화식 모드에서 편집기를 시작할 때 여러 Git 명령에서 사용됩니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]의 &lt;/a&gt;&lt;a href=&quot;git-var&quot;&gt;git-var [1]&lt;/a&gt; 및 &lt;code&gt;core.editor&lt;/code&gt; 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ddbc158f0dcc3c8ea52494b42fbb66d15e06e460" translate="yes" xml:space="preserve">
          <source>This environment variable overrides &lt;code&gt;$PAGER&lt;/code&gt;. If it is set to an empty string or to the value &quot;cat&quot;, Git will not launch a pager. See also the &lt;code&gt;core.pager&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">이 환경 변수는 &lt;code&gt;$PAGER&lt;/code&gt; 대체 합니다. 빈 문자열 또는 &quot;cat&quot;값으로 설정되면 Git은 호출기를 시작하지 않습니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 &lt;code&gt;core.pager&lt;/code&gt; 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85b43d9b9e3f28d79e0c1169949e722bd8f10c35" translate="yes" xml:space="preserve">
          <source>This environment variable overrides the configured Git editor when editing the todo list of an interactive rebase. See also linkit::git-rebase[1] and the &lt;code&gt;sequence.editor&lt;/code&gt; option in linkit::git-config[1].</source>
          <target state="translated">This environment variable overrides the configured Git editor when editing the todo list of an interactive rebase. See also linkit::git-rebase[1] and the &lt;code&gt;sequence.editor&lt;/code&gt; option in linkit::git-config[1].</target>
        </trans-unit>
        <trans-unit id="25ea93764f52eb3dcc477c86398962bd9bbded98" translate="yes" xml:space="preserve">
          <source>This event contains the command name for this git process and the hierarchy of commands from parent git processes.</source>
          <target state="translated">이 이벤트에는이 자식 프로세스의 명령 이름과 부모 자식 프로세스의 명령 계층이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f5d9f72db5c7ffa9776d5c71964338d54a2515a4" translate="yes" xml:space="preserve">
          <source>This event contains the complete argv received by main().</source>
          <target state="translated">이 이벤트에는 main ()이 수신 한 전체 argv가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2a4c1f111536d47e2687ea692bfe5bd399b4307d" translate="yes" xml:space="preserve">
          <source>This event contains the discovered full path of the git executable (on platforms that are configured to resolve it).</source>
          <target state="translated">이 이벤트에는 git 실행 파일의 발견 된 전체 경로가 포함되어 있습니다 (해결하도록 구성된 플랫폼에서).</target>
        </trans-unit>
        <trans-unit id="c8af8dbf59abf700f44d6449c7c951b54692bd2e" translate="yes" xml:space="preserve">
          <source>This event defines a repo-id and associates it with the root of the worktree.</source>
          <target state="translated">이 이벤트는 repo-id를 정의하고 작업 트리의 루트와 연관시킵니다.</target>
        </trans-unit>
        <trans-unit id="efbcacd1a490c688869fdd46397140e75919d7ab" translate="yes" xml:space="preserve">
          <source>This event describes a child process that is about to be spawned.</source>
          <target state="translated">이 이벤트는 생성 될 자식 프로세스를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8c8f935852467fd7c3b46787d77518dc3611a986" translate="yes" xml:space="preserve">
          <source>This event gives the version of the executable and the EVENT format. It should always be the first event in a trace session. The EVENT format version will be incremented if new event types are added, if existing fields are removed, or if there are significant changes in interpretation of existing events or fields. Smaller changes, such as adding a new field to an existing event, will not require an increment to the EVENT format version.</source>
          <target state="translated">이 이벤트는 실행 파일 버전과 EVENT 형식을 제공합니다. 항상 추적 세션에서 첫 번째 이벤트 여야합니다. EVENT 형식 버전은 새 이벤트 유형이 추가되거나 기존 필드가 제거되거나 기존 이벤트 또는 필드의 해석에 상당한 변경이있는 경우 증가합니다. 기존 이벤트에 새 필드를 추가하는 등의 작은 변경으로 EVENT 형식 버전을 증분 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ea085d0e611d87af89c62af2b70656c0016dc7e" translate="yes" xml:space="preserve">
          <source>This event is emitted by the Trace2 &lt;code&gt;atexit&lt;/code&gt; routine during final shutdown. It should be the last event emitted by the process.</source>
          <target state="translated">이 이벤트는 최종 종료 중에 Trace2 &lt;code&gt;atexit&lt;/code&gt; 루틴에 의해 생성됩니다 . 프로세스에서 생성 한 마지막 이벤트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0b20979b7d0436896a9e4dd619b31c2f047cbd64" translate="yes" xml:space="preserve">
          <source>This event is emitted when git calls &lt;code&gt;exit()&lt;/code&gt;.</source>
          <target state="translated">이 이벤트는 git가 &lt;code&gt;exit()&lt;/code&gt; 호출 할 때 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c63cb7135e802e553dc499a675da732d4f96c3a" translate="yes" xml:space="preserve">
          <source>This event is emitted when one of the &lt;code&gt;error()&lt;/code&gt;, &lt;code&gt;die()&lt;/code&gt;, or &lt;code&gt;usage()&lt;/code&gt; functions are called.</source>
          <target state="translated">이 이벤트는 &lt;code&gt;error()&lt;/code&gt; , &lt;code&gt;die()&lt;/code&gt; 또는 &lt;code&gt;usage()&lt;/code&gt; 함수 중 하나가 호출 될 때 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ebb8b872e605289564f67171a3133d84781ab210" translate="yes" xml:space="preserve">
          <source>This event is emitted when the program is terminated by a user signal. Depending on the platform, the signal event may prevent the &quot;atexit&quot; event from being generated.</source>
          <target state="translated">이 이벤트는 프로그램이 사용자 신호에 의해 종료 될 때 생성됩니다. 플랫폼에 따라 신호 이벤트로 인해 &quot;atexit&quot;이벤트가 생성되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ca8802f12c75856c4e7ea399ac7a1939e2a37eb" translate="yes" xml:space="preserve">
          <source>This event is generated after the current process has returned from the waitpid() and collected the exit information from the child.</source>
          <target state="translated">이 이벤트는 현재 프로세스가 waitpid ()에서 리턴되고 자식에서 종료 정보를 수집 한 후에 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="9fe6d803410a7d3a5cd4bc2114534352d230200b" translate="yes" xml:space="preserve">
          <source>This event is generated before git attempts to &lt;code&gt;exec()&lt;/code&gt; another command rather than starting a child process.</source>
          <target state="translated">이 이벤트는 자식 프로세스를 시작하지 않고 git이 다른 명령 을 &lt;code&gt;exec()&lt;/code&gt; 하려고 시도하기 전에 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="93caa8939f471f1240286ec30c6905ef3996f20e" translate="yes" xml:space="preserve">
          <source>This event is generated if the &lt;code&gt;exec()&lt;/code&gt; fails and control returns to the current git command.</source>
          <target state="translated">이 이벤트는 &lt;code&gt;exec()&lt;/code&gt; 가 실패하고 제어가 현재 git 명령으로 리턴되는 경우 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="15a0b5629f08a42566247fd3e8af69adc717eef8" translate="yes" xml:space="preserve">
          <source>This event is generated to log a global parameter, such as a config setting, command-line flag, or environment variable.</source>
          <target state="translated">This event is generated to log a global parameter, such as a config setting, command-line flag, or environment variable.</target>
        </trans-unit>
        <trans-unit id="814427d239ec02f31ac7bf0fb913766e18bfb53e" translate="yes" xml:space="preserve">
          <source>This event is generated to log a global parameter.</source>
          <target state="translated">이 이벤트는 전역 매개 변수를 기록하기 위해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="54b6cc61590e1e0eba249cc8ddd71ddff154355b" translate="yes" xml:space="preserve">
          <source>This event is generated to log a pre-formatted JSON string containing structured data.</source>
          <target state="translated">이 이벤트는 구조화 된 데이터를 포함하는 사전 형식화 된 JSON 문자열을 기록하기 위해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0ee97bbcf1fde0cf306363257efe6b7de578045e" translate="yes" xml:space="preserve">
          <source>This event is generated to log a thread- and region-local key/value pair.</source>
          <target state="translated">이 이벤트는 스레드 및 지역 로컬 키 / 값 쌍을 기록하기 위해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4caa8d05330c9e1126d8391705e312b0d8975d63" translate="yes" xml:space="preserve">
          <source>This event is generated when a thread exits. It is generated from &lt;strong&gt;within&lt;/strong&gt; the thread&amp;rsquo;s thread-proc (for TLS reasons).</source>
          <target state="translated">이 이벤트는 스레드가 종료 될 때 생성됩니다. 스레드의 thread-proc &lt;strong&gt;내&lt;/strong&gt; 에서 생성됩니다 (TLS 이유로).</target>
        </trans-unit>
        <trans-unit id="eba565beaf1b2269c764c147f5196869afe38bce" translate="yes" xml:space="preserve">
          <source>This event is generated when a thread is started. It is generated from &lt;strong&gt;within&lt;/strong&gt; the new thread&amp;rsquo;s thread-proc (for TLS reasons).</source>
          <target state="translated">이 이벤트는 스레드가 시작될 때 생성됩니다. 새 스레드의 thread-proc &lt;strong&gt;내&lt;/strong&gt; 에서 생성됩니다 (TLS 이유로).</target>
        </trans-unit>
        <trans-unit id="1684fe3e3862662b36c1dfb0c9bb20558e1f338a" translate="yes" xml:space="preserve">
          <source>This event is generated when entering a region.</source>
          <target state="translated">이 이벤트는 지역을 입력 할 때 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="809d72e4f54bac6c7054af4e990fa8c97e8c764d" translate="yes" xml:space="preserve">
          <source>This event is generated when leaving a region.</source>
          <target state="translated">이 이벤트는 지역을 떠날 때 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="1e6a7368deeb7ec580313fc82400f1c12d17672a" translate="yes" xml:space="preserve">
          <source>This event is present when an alias is expanded.</source>
          <target state="translated">이 이벤트는 별명이 확장 될 때 나타납니다.</target>
        </trans-unit>
        <trans-unit id="bca802363ffa9599d9e13df71e2f62ec1454e32f" translate="yes" xml:space="preserve">
          <source>This event is written to the git-trace2-discard sentinel file if there are too many files in the target trace directory (see the trace2.maxFiles config option).</source>
          <target state="translated">대상 추적 디렉토리에 파일이 너무 많으면이 이벤트가 git-trace2-discard 센티넬 파일에 기록됩니다 (trace2.maxFiles 구성 옵션 참조).</target>
        </trans-unit>
        <trans-unit id="8c2ad60a0d9356a6e908b18056fbac1c2b1d4129" translate="yes" xml:space="preserve">
          <source>This event, when present, describes the command variant This event may be emitted more than once.</source>
          <target state="translated">이 이벤트는 존재할 경우 명령 변형을 설명합니다.이 이벤트는 두 번 이상 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e7d09cee878b03064fb9d9484c73f3f00225826" translate="yes" xml:space="preserve">
          <source>This example also shows that thread names are assigned in a racy manner as each thread starts and allocates TLS storage.</source>
          <target state="translated">이 예제는 또한 각 스레드가 시작되고 TLS 스토리지를 할당 할 때 스레드 이름이 복잡한 방식으로 지정됨을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e296b28f1fcad64b66f85f9abe931f54fc5fbde0" translate="yes" xml:space="preserve">
          <source>This example imports a new remote &quot;p4/proj2&quot; into an existing Git repository:</source>
          <target state="translated">이 예에서는 새 원격 &quot;p4 / proj2&quot;를 기존 Git 저장소로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7cbbc9fac80d3f9e05217d26ad6f34ea5097abe6" translate="yes" xml:space="preserve">
          <source>This example shows that the index contained 3552 entries.</source>
          <target state="translated">이 예는 색인에 3552 개의 항목이 포함되어 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="af5672891a1be21669d22b688901415e2cf060c3" translate="yes" xml:space="preserve">
          <source>This expands to the object name of the delta base for the given object, if it is stored as a delta. Otherwise it expands to the null object name (all zeroes).</source>
          <target state="translated">이는 델타로 저장된 경우 지정된 오브젝트에 대한 델타베이스의 오브젝트 이름으로 확장됩니다. 그렇지 않으면 널 오브젝트 이름 (모두 0)으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="1a642986ccbacca12888668bff4ca6d3b1007b62" translate="yes" xml:space="preserve">
          <source>This explanation comes for &quot;free&quot; because there was no change. Similarly &lt;code&gt;C&lt;/code&gt; could be explained using &lt;code&gt;1&lt;/code&gt;, but that comes at some cost c&amp;gt;0 because of the modification:</source>
          <target state="translated">이 설명은 아무런 변화가 없었기 때문에 &quot;무료&quot;입니다. 마찬가지로 &lt;code&gt;C&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 을 사용하여 설명 할 수 있지만 수정으로 인해 비용이 c&amp;gt; 0입니다.</target>
        </trans-unit>
        <trans-unit id="86a0b58a904e042293eb0ea80455653f123e7d4e" translate="yes" xml:space="preserve">
          <source>This extended format can be useful if rename or copy detection is active, to allow you to see the original name of the file in different parents.</source>
          <target state="translated">이 확장 형식은 다른 부모에서 파일의 원래 이름을 볼 수 있도록 이름 바꾸기 또는 복사 감지가 활성화 된 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc95481325c82bdecdaa23291b735168b05af418" translate="yes" xml:space="preserve">
          <source>This extension does not change git&amp;rsquo;s behavior at all. It is useful only for testing format-1 compatibility.</source>
          <target state="translated">이 확장은 git의 동작을 전혀 변경하지 않습니다. 형식 1 호환성 테스트에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="24a20ccff9f7f9f91cdf61fb876086b44fc5be61" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis by setting repository&amp;rsquo;s &lt;code&gt;gitweb.pickaxe&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">이 기능은 리포지토리의 &lt;code&gt;gitweb.pickaxe&lt;/code&gt; 구성 변수 (부울) 를 설정하여 리포지토리별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fcd9d965aa29d51e3ab01e56c522e086b7f545b" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.avatar&lt;/code&gt; configuration variable.</source>
          <target state="translated">이 기능은 리포지토리의 &lt;code&gt;gitweb.avatar&lt;/code&gt; 구성 변수 를 통해 리포지토리별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da6908103a49ae5e820a33c13aadd5dfdd3e67a7" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.blame&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">이 기능은 리포지토리의 &lt;code&gt;gitweb.blame&lt;/code&gt; 구성 변수 (부울) 를 통해 리포지토리별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d6d167abae14ab18966eab440f954ed6085f29c" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.grep&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">이 기능은 리포지토리의 &lt;code&gt;gitweb.grep&lt;/code&gt; 구성 변수 (부울) 를 통해 리포지토리별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd4f802848cf6cbdc7682aeefb00472f2c444c9e" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.highlight&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">이 기능은 리포지토리의 &lt;code&gt;gitweb.highlight&lt;/code&gt; 구성 변수 (부울) 를 통해 리포지토리별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8e82652b1c51e397e7f1e31621e9084d5611fda" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.patches&lt;/code&gt; configuration variable (integer).</source>
          <target state="translated">이 기능은 저장소의 &lt;code&gt;gitweb.patches&lt;/code&gt; 구성 변수 (정수) 를 통해 저장소별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0528d6fc23cb2716835712f44b5daf955251062" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.remote_heads&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">이 기능은 저장소의 &lt;code&gt;gitweb.remote_heads&lt;/code&gt; 구성 변수 (부울) 를 통해 저장소별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58b983175f59d7aad97dac71b32251a2f4a8c4a0" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.showSizes&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">이 기능은 리포지토리의 &lt;code&gt;gitweb.showSizes&lt;/code&gt; 구성 변수 (부울) 를 통해 리포지토리별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee33afe943a28f48529ed67cc410ad185ea09f23" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.snapshot&lt;/code&gt; configuration variable, which contains a comma separated list of formats or &quot;none&quot; to disable snapshots. Unknown values are ignored.</source>
          <target state="translated">이 기능은 저장소의 &lt;code&gt;gitweb.snapshot&lt;/code&gt; 구성 변수 를 통해 저장소별로 구성 할 수 있습니다 . 여기에는 쉼표로 구분 된 형식 목록 또는 스냅 샷을 비활성화하는 &quot;없음&quot;이 포함됩니다. 알 수없는 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c2467a6f49bad0810d0f5e1c4a51888ceb4f5b0f" translate="yes" xml:space="preserve">
          <source>This feature can be configured on per-repository basis after setting $feature{&lt;code&gt;extra-branch-refs&lt;/code&gt;}{&lt;code&gt;override&lt;/code&gt;} to true, via repository&amp;rsquo;s &lt;code&gt;gitweb.extraBranchRefs&lt;/code&gt; configuration variable, which contains a space separated list of refs. An example:</source>
          <target state="translated">이 기능은 공백으로 구분 된 참조 목록을 포함하는 저장소의 &lt;code&gt;gitweb.extraBranchRefs&lt;/code&gt; 구성 변수 를 통해 $ feature { &lt;code&gt;extra-branch-refs&lt;/code&gt; } { &lt;code&gt;override&lt;/code&gt; }를 true로 설정 한 후 저장소별로 구성 할 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="83b4612ad81d70c9ed8920a4b451b69b8c3ee080" translate="yes" xml:space="preserve">
          <source>This feature is intended to speed up git operations for repos that have large working directories.</source>
          <target state="translated">이 기능은 큰 작업 디렉토리가있는 저장소의 git 작업 속도를 높이기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6b24b487d6d9654020073f6754733ecc051175ad" translate="yes" xml:space="preserve">
          <source>This feature is semi-deprecated. For scripting purpose, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt;&lt;code&gt;--porcelain&lt;/code&gt; and &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt;&lt;code&gt;--name-status&lt;/code&gt; are almost always superior alternatives, and users should look at &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt;&lt;code&gt;--short&lt;/code&gt; or &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--name-status&lt;/code&gt; for more user-friendly alternatives.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 스크립팅 목적으로 &lt;a href=&quot;git-status&quot;&gt;git-status [1] &lt;/a&gt; &lt;code&gt;--porcelain&lt;/code&gt; 및 &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1] &lt;/a&gt; &lt;code&gt;--name-status&lt;/code&gt; 는 거의 항상 우수한 대안이며 사용자는 &lt;a href=&quot;git-status&quot;&gt;git-status [1] &lt;/a&gt; &lt;code&gt;--short&lt;/code&gt; 또는 &lt;a href=&quot;git-diff&quot;&gt;git-&lt;/a&gt; 보다 사용자 친화적 인 대안을위한 diff [1] &lt;code&gt;--name-status&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0861edc399d3214fad2ecef2c8c7d8f9e28b4564" translate="yes" xml:space="preserve">
          <source>This feature is useful when an established project should be accepted despite early commits containing errors that can be safely ignored such as invalid committer email addresses. Note: corrupt objects cannot be skipped with this setting.</source>
          <target state="translated">이 기능은 유효하지 않은 커미터 이메일 주소와 같이 무시해도되는 오류가 포함 된 초기 커밋에도 불구하고 설정된 프로젝트를 수락해야 할 때 유용합니다. 참고 :이 설정으로는 손상된 개체를 건너 뛸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5474f37d061902594342fbe38be401770ea2769f" translate="yes" xml:space="preserve">
          <source>This feature works by recording the mtime of the working tree directories and then omitting reading directories and stat calls against files in those directories whose mtime hasn&amp;rsquo;t changed. For this to work the underlying operating system and file system must change the &lt;code&gt;st_mtime&lt;/code&gt; field of directories if files in the directory are added, modified or deleted.</source>
          <target state="translated">이 기능은 작업 트리 디렉토리의 mtime을 기록한 다음 mtime이 변경되지 않은 디렉토리의 파일에 대한 디렉토리 및 stat 호출 읽기를 생략하여 작동합니다. 이것이 작동하려면 기본 운영 체제 및 파일 시스템 이 디렉토리의 파일이 추가, 수정 또는 삭제 된 경우 디렉토리 의 &lt;code&gt;st_mtime&lt;/code&gt; 필드를 변경해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ef2541ade640bd800921de0e87cda6dd56d4d5f6" translate="yes" xml:space="preserve">
          <source>This fetches revisions from the SVN parent of the current HEAD and rebases the current (uncommitted to SVN) work against it.</source>
          <target state="translated">현재 HEAD의 SVN 상위에서 수정본을 가져오고 현재 SVN에 커밋되지 않은 작업을 리베이스합니다.</target>
        </trans-unit>
        <trans-unit id="e6f84c5c8c6a08793025b9538660cbd1c1faa637" translate="yes" xml:space="preserve">
          <source>This file contains the commit message of a commit in progress. If &lt;code&gt;git commit&lt;/code&gt; exits due to an error before creating a commit, any commit message that has been provided by the user (e.g., in an editor session) will be available in this file, but will be overwritten by the next invocation of &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">이 파일에는 진행중인 커밋의 커밋 메시지가 들어 있습니다. 경우 &lt;code&gt;git commit&lt;/code&gt; 커밋 만들기 전에 오류로 인해 종료, 어떤이 파일에 사용할 수 있습니다 (편집기 세션에서 예) 사용자가 제공 한 커밋 메시지 만의 다음의 호출을 덮어 씁니다 &lt;code&gt;git commit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2063696fd909d95d720efff6859f2846f7a33789" translate="yes" xml:space="preserve">
          <source>This file helps dumb transports discover what refs are available in this repository. If the repository is published for dumb transports, this file should be regenerated by &lt;code&gt;git update-server-info&lt;/code&gt; every time a tag or branch is created or modified. This is normally done from the &lt;code&gt;hooks/update&lt;/code&gt; hook, which is run by the &lt;code&gt;git-receive-pack&lt;/code&gt; command when you &lt;code&gt;git push&lt;/code&gt; into the repository.</source>
          <target state="translated">이 파일은 바보 전송이이 저장소에서 사용 가능한 참조를 발견하는 데 도움이됩니다. 저장소가 바보 전송 용으로 게시 된 경우이 파일은 태그 또는 분기를 만들거나 수정할 때마다 &lt;code&gt;git update-server-info&lt;/code&gt; 에 의해 재생성되어야합니다 . 이것은 일반적으로 &lt;code&gt;hooks/update&lt;/code&gt; 후크 에서 수행되며, 후크를 저장소로 &lt;code&gt;git push&lt;/code&gt; 할 때 &lt;code&gt;git-receive-pack&lt;/code&gt; 명령으로 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="3487083c7b98c66e39acc8f940f40c0e9ceac88f" translate="yes" xml:space="preserve">
          <source>This file is to help dumb transports discover what packs are available in this object store. Whenever a pack is added or removed, &lt;code&gt;git update-server-info&lt;/code&gt; should be run to keep this file up to date if the repository is published for dumb transports. &lt;code&gt;git repack&lt;/code&gt; does this by default.</source>
          <target state="translated">이 파일은 바보 전송이이 오브젝트 저장소에서 사용 가능한 팩을 발견하는 데 도움이됩니다. 팩이 추가되거나 제거 될 때마다 저장소가 벙어리 전송 용으로 게시 된 경우이 파일을 최신 상태로 유지하려면 &lt;code&gt;git update-server-info&lt;/code&gt; 를 실행해야합니다. &lt;code&gt;git repack&lt;/code&gt; 은 기본적으로 이것을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="cbe65e34529f44f10bf3c4bc531b3ef1a1689dfb" translate="yes" xml:space="preserve">
          <source>This file mainly serves as the mapping between the name and path of submodules in the superproject, such that the submodule&amp;rsquo;s Git directory can be located.</source>
          <target state="translated">이 파일은 주로 수퍼 프로젝트에서 하위 모듈의 이름과 경로 간의 매핑 역할을하여 하위 모듈의 Git 디렉토리를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="071050e2544b6fc3703fb63508bbfdc9243b46ab" translate="yes" xml:space="preserve">
          <source>This file records URLs to alternate object stores that this object store borrows objects from, to be used when the repository is fetched over HTTP.</source>
          <target state="translated">이 파일은 URL을 기록하여이 오브젝트 저장소가 오브젝트를 차용 한 대체 오브젝트 저장소에 URL을 기록하여 저장소가 HTTP를 통해 페치 될 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cc3397ff622f0d4d27f532099612807583041388" translate="yes" xml:space="preserve">
          <source>This file records fake commit ancestry information, to pretend the set of parents a commit has is different from how the commit was actually created. One record per line describes a commit and its fake parents by listing their 40-byte hexadecimal object names separated by a space and terminated by a newline.</source>
          <target state="translated">이 파일은 가짜 커밋 조상 정보를 기록하여 커밋이있는 부모 세트가 실제로 커밋이 생성 된 방식과 다른 척합니다. 라인 당 하나의 레코드는 40 바이트의 16 진 오브젝트 이름을 공백으로 구분하고 개행으로 종료하여 커밋 및 가짜 부모를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1873ba1c652fc3e8dae8a41ecd45dff2c995baaf" translate="yes" xml:space="preserve">
          <source>This file records paths to alternate object stores that this object store borrows objects from, one pathname per line. Note that not only native Git tools use it locally, but the HTTP fetcher also tries to use it remotely; this will usually work if you have relative paths (relative to the object database, not to the repository!) in your alternates file, but it will not work if you use absolute paths unless the absolute path in filesystem and web URL is the same. See also &lt;code&gt;objects/info/http-alternates&lt;/code&gt;.</source>
          <target state="translated">이 파일은이 오브젝트 저장소가 오브젝트를 빌려 오는 대체 오브젝트 저장소에 대한 경로를 한 줄에 하나씩 경로로 기록합니다. 기본 Git 도구는 로컬 Git 도구를 사용할뿐만 아니라 HTTP 페처도이를 원격으로 사용하려고합니다. 대체 파일에 상대 경로 (저장소가 아닌 객체 데이터베이스에 상대적인 경로)가있는 경우 일반적으로 작동하지만 파일 시스템과 웹 URL의 절대 경로가 동일하지 않으면 절대 경로를 사용하면 작동하지 않습니다. &lt;code&gt;objects/info/http-alternates&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="517ab2689bb34239adf0b92ebb2a70e736956866" translate="yes" xml:space="preserve">
          <source>This file stores sparse checkout patterns. See also: &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt;.</source>
          <target state="translated">이 파일은 드문 체크 아웃 패턴을 저장합니다. &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="39e8ca5394d81b30bccd145a749de9346fba2480" translate="yes" xml:space="preserve">
          <source>This file uses the following format:</source>
          <target state="translated">이 파일은 다음 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="53c1d1d0fe83b95fe57b9ac9f6f59413589df721" translate="yes" xml:space="preserve">
          <source>This file, by convention among Porcelains, stores the exclude pattern list. &lt;code&gt;.gitignore&lt;/code&gt; is the per-directory ignore file. &lt;code&gt;git status&lt;/code&gt;, &lt;code&gt;git add&lt;/code&gt;, &lt;code&gt;git rm&lt;/code&gt; and &lt;code&gt;git clean&lt;/code&gt; look at it but the core Git commands do not look at it. See also: &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;.</source>
          <target state="translated">이 파일은 도자기의 규칙에 따라 제외 패턴 목록을 저장합니다. &lt;code&gt;.gitignore&lt;/code&gt; 는 디렉토리 별 무시 파일입니다. &lt;code&gt;git status&lt;/code&gt; , &lt;code&gt;git add&lt;/code&gt; , &lt;code&gt;git rm&lt;/code&gt; 및 &lt;code&gt;git clean&lt;/code&gt; 이 그것을 보지만 핵심 Git 명령은 그것을 보지 않습니다. &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8956b9fdca3244ff8cd9467aefdc82ab275d878" translate="yes" xml:space="preserve">
          <source>This filter may be used if you only need to modify the environment in which the commit will be performed. Specifically, you might want to rewrite the author/committer name/email/time environment variables (see &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; for details).</source>
          <target state="translated">커밋이 수행 될 환경 만 수정해야하는 경우이 필터를 사용할 수 있습니다. 특히 작성자 / 커미터 이름 / 이메일 / 시간 환경 변수를 다시 작성할 수 있습니다 (자세한 내용은 &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="1f7d9b6979d573a6d61c7fc37aef6ce7f09ba079" translate="yes" xml:space="preserve">
          <source>This flag causes &lt;code&gt;git diff-tree --stdin&lt;/code&gt; to also show the commit message before the differences.</source>
          <target state="translated">이 플래그는 &lt;code&gt;git diff-tree --stdin&lt;/code&gt; 이 차이 전에 커밋 메시지를 표시하도록합니다.</target>
        </trans-unit>
        <trans-unit id="f18c1480999d4a64a19b051751a1dfdb3d01c394" translate="yes" xml:space="preserve">
          <source>This flag causes an object already in a local pack that has a .keep file to be ignored, even if it would have otherwise been packed.</source>
          <target state="translated">이 플래그는 .keep 파일이있는 로컬 팩에 이미있는 오브젝트가 다른 방식으로 압축되어 있어도 무시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="3b2c5aa43d85ae95c70f7126e1a8d471a0247285" translate="yes" xml:space="preserve">
          <source>This flag causes an object already in a pack to be ignored even if it would have otherwise been packed.</source>
          <target state="translated">이 플래그는 팩에 이미있는 오브젝트가 달리 패킹 된 경우에도 무시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="936ccdd465b71c76f59e3d7929f0e31e3a24c431" translate="yes" xml:space="preserve">
          <source>This flag causes an object already in the given pack to be ignored, even if it would have otherwise been packed. &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; is the pack file name without leading directory (e.g. &lt;code&gt;pack-123.pack&lt;/code&gt;). The option could be specified multiple times to keep multiple packs.</source>
          <target state="translated">이 플래그는 지정된 팩에 이미있는 오브젝트가 다른 방식으로 패킹 된 경우에도 무시되도록합니다. &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; 은 선행 디렉토리가없는 팩 파일 이름입니다 (예 : &lt;code&gt;pack-123.pack&lt;/code&gt; ). 여러 팩을 유지하기 위해 옵션을 여러 번 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fad47cb9db9729fbeb177e82626a6322dbefd6c" translate="yes" xml:space="preserve">
          <source>This flag causes an object that is borrowed from an alternate object store to be ignored even if it would have otherwise been packed.</source>
          <target state="translated">이 플래그는 대체 오브젝트 저장소에서 빌린 오브젝트가 다른 방식으로 압축되어 있어도 무시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="97fddffea713eaa9774ecf695b0619f959916c25" translate="yes" xml:space="preserve">
          <source>This flag causes combined diffs (used for merge commits) to list the name of the file from all parents. It thus only has effect when -c or --cc are specified, and is likely only useful if filename changes are detected (i.e. when either rename or copy detection have been requested).</source>
          <target state="translated">이 플래그는 결합 된 diff (병합 커밋에 사용)가 모든 부모의 파일 이름을 나열하게합니다. 따라서 -c 또는 --cc가 지정된 경우에만 효과가 있으며 파일 이름 변경이 감지 된 경우 (예 : 이름 바꾸기 또는 복사 감지가 요청 된 경우)에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7d04699c745135d6f14712a3d65005478838c3a7" translate="yes" xml:space="preserve">
          <source>This flag changes the way a merge commit is displayed (which means it is useful only when the command is given one &amp;lt;tree-ish&amp;gt;, or &lt;code&gt;--stdin&lt;/code&gt;). It shows the differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time (which is what the &lt;code&gt;-m&lt;/code&gt; option does). Furthermore, it lists only files which were modified from all parents.</source>
          <target state="translated">이 플래그는 병합 커밋이 표시되는 방식을 변경합니다 (즉, 명령에 &amp;lt;tree-ish&amp;gt; 또는 &lt;code&gt;--stdin&lt;/code&gt; 이 지정된 경우에만 유용함 ). 한 번에 하나씩 부모와 결과 사이에 쌍별 차이를 표시하는 대신 각 부모와 병합 결과의 차이점을 동시에 표시합니다 ( &lt;code&gt;-m&lt;/code&gt; 옵션의 기능). 또한 모든 상위에서 수정 된 파일 만 나열합니다.</target>
        </trans-unit>
        <trans-unit id="0d503f20848f4e1ff6c5e78038f4bce28f3422a3" translate="yes" xml:space="preserve">
          <source>This flag changes the way a merge commit patch is displayed, in a similar way to the &lt;code&gt;-c&lt;/code&gt; option. It implies the &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-p&lt;/code&gt; options and further compresses the patch output by omitting uninteresting hunks whose the contents in the parents have only two variants and the merge result picks one of them without modification. When all hunks are uninteresting, the commit itself and the commit log message is not shown, just like in any other &quot;empty diff&quot; case.</source>
          <target state="translated">이 플래그는 &lt;code&gt;-c&lt;/code&gt; 옵션 과 유사한 방식으로 병합 커밋 패치가 표시되는 방식을 변경합니다 . &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-p&lt;/code&gt; 옵션을 내포하고 부모의 내용에 두 가지 변형 만 있고 병합 결과가 수정없이 이들 중 하나를 선택하는 흥미없는 덩어리를 생략하여 패치 출력을 추가로 압축합니다. 모든 덩어리가 흥미롭지 않은 경우, 다른 &quot;빈 차이&quot;경우와 같이 커밋 자체와 커밋 로그 메시지가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4835250d6cbee97633146544cd1896afcc631099" translate="yes" xml:space="preserve">
          <source>This flag disables these checks, and can cause the remote repository to lose commits; use it with care.</source>
          <target state="translated">이 플래그는 이러한 검사를 비활성화하며 원격 저장소가 커밋을 잃을 수 있습니다. 조심해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cc5f19786a1b0eda7705eaaa80c372612ab5d782" translate="yes" xml:space="preserve">
          <source>This flag implies the &lt;code&gt;-c&lt;/code&gt; option and further compresses the patch output by omitting uninteresting hunks whose contents in the parents have only two variants and the merge result picks one of them without modification.</source>
          <target state="translated">이 플래그는 &lt;code&gt;-c&lt;/code&gt; 옵션을 암시하고 부모의 내용에 변형이 두 개 뿐이고 병합 결과가 수정없이 그 중 하나를 선택하는 흥미없는 덩어리를 생략하여 패치 출력을 추가로 압축합니다.</target>
        </trans-unit>
        <trans-unit id="03d7872e2a4e991418dc3ea26303b414cb645f27" translate="yes" xml:space="preserve">
          <source>This flag is passed to the &lt;code&gt;git apply&lt;/code&gt; program (see &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;) that applies the patch. Implies --apply.</source>
          <target state="translated">This flag is passed to the &lt;code&gt;git apply&lt;/code&gt; program (see &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;) that applies the patch. Implies --apply.</target>
        </trans-unit>
        <trans-unit id="6c9f2e241df42ed566896490c4c1723461343597" translate="yes" xml:space="preserve">
          <source>This flag is passed to the &lt;code&gt;git log&lt;/code&gt; program (see &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;) that generates the patches.</source>
          <target state="translated">이 플래그는 패치를 생성하는 &lt;code&gt;git log&lt;/code&gt; 프로그램 ( &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 참조)으로 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="7d74132f018d1e29c74648fc0cf6690a80cd700b" translate="yes" xml:space="preserve">
          <source>This flag makes the command not to report its progress on the standard error stream.</source>
          <target state="translated">이 플래그는 명령이 표준 오류 스트림에서 진행 상황을보고하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="c7300f914a6246e85c4558f9e03e3ac6bd2957c2" translate="yes" xml:space="preserve">
          <source>This flag makes the merge commits show the full diff like regular commits; for each merge parent, a separate log entry and diff is generated. An exception is that only diff against the first parent is shown when &lt;code&gt;--first-parent&lt;/code&gt; option is given; in that case, the output represents the changes the merge brought &lt;code&gt;into&lt;/code&gt; the then-current branch.</source>
          <target state="translated">이 플래그는 병합 커밋이 일반 커밋과 같이 전체 diff를 표시하도록합니다. 각 병합 상위에 대해 별도의 로그 항목과 diff가 생성됩니다. &lt;code&gt;--first-parent&lt;/code&gt; 옵션이 주어지면 첫 번째 부모에 대한 diff 만 표시됩니다 . 이 경우 출력은 병합 이 당시 분기 &lt;code&gt;into&lt;/code&gt; 가져온 변경 사항을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="824f1a5cbd322eac2edc9b61691e0afb5fb06c7c" translate="yes" xml:space="preserve">
          <source>This flag tells the command not to reuse existing object data at all, including non deltified object, forcing recompression of everything. This implies --no-reuse-delta. Useful only in the obscure case where wholesale enforcement of a different compression level on the packed data is desired.</source>
          <target state="translated">이 플래그는 명령에 명령되지 않은 객체를 포함하여 기존 객체 데이터를 전혀 재사용하지 않도록 지시하여 모든 것을 다시 압축합니다. 이것은 --re-reuse-delta를 의미합니다. 압축 된 데이터에 대해 다른 압축 수준의 도매 시행이 필요한 모호한 경우에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e554d11fed47fbadc588fbbd426a692640350799" translate="yes" xml:space="preserve">
          <source>This form can only be used in the middle of a &lt;code&gt;commit&lt;/code&gt;. The path names a directory entry within fast-import&amp;rsquo;s active commit. The path must be quoted in this case.</source>
          <target state="translated">이 형식은 &lt;code&gt;commit&lt;/code&gt; 도중에 만 사용할 수 있습니다 . 경로는 빠른 가져 오기의 활성 커밋 내의 디렉토리 항목 이름을 지정합니다. 이 경우 경로를 인용해야합니다.</target>
        </trans-unit>
        <trans-unit id="55cd46dfe4dc47146eb359f16ba2ab6440f5d33b" translate="yes" xml:space="preserve">
          <source>This form is to compare the given two paths on the filesystem. You can omit the &lt;code&gt;--no-index&lt;/code&gt; option when running the command in a working tree controlled by Git and at least one of the paths points outside the working tree, or when running the command outside a working tree controlled by Git. This form implies &lt;code&gt;--exit-code&lt;/code&gt;.</source>
          <target state="translated">이 형식은 파일 시스템에서 주어진 두 경로를 비교하는 것입니다. Git으로 제어되는 작업 트리에서 명령을 실행하고 경로 중 하나 이상이 작업 트리 외부를 가리 키거나 Git에서 제어하는 ​​작업 트리 외부에서 명령을 실행할 때 &lt;code&gt;--no-index&lt;/code&gt; 옵션을 생략 할 수 있습니다 . 이 형식은 &lt;code&gt;--exit-code&lt;/code&gt; 를 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="1a36c2e6e9bf305ffd5ef7a7e4c453ac93dfb865" translate="yes" xml:space="preserve">
          <source>This form is to view the changes on the branch containing and up to the second &amp;lt;commit&amp;gt;, starting at a common ancestor of both &amp;lt;commit&amp;gt;. &quot;git diff A...B&quot; is equivalent to &quot;git diff $(git merge-base A B) B&quot;. You can omit any one of &amp;lt;commit&amp;gt;, which has the same effect as using HEAD instead.</source>
          <target state="translated">이 양식은 두 &amp;lt;commit&amp;gt;의 공통 조상에서 시작하여 두 번째 &amp;lt;commit&amp;gt;을 포함하는 브랜치의 변경 사항을 보는 것입니다. &quot;git diff A ... B&quot;는 &quot;git diff $ (git merge-base AB) B&quot;와 같습니다. &amp;lt;commit&amp;gt; 중 하나를 생략하면 HEAD를 대신 사용하는 것과 동일한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="18011d68a19f669179582c8652eaff17f583329f" translate="yes" xml:space="preserve">
          <source>This form is to view the changes you have in your working tree relative to the named &amp;lt;commit&amp;gt;. You can use HEAD to compare it with the latest commit, or a branch name to compare with the tip of a different branch.</source>
          <target state="translated">이 양식은 이름이 지정된 &amp;lt;commit&amp;gt;과 관련하여 작업 트리에서 변경 한 내용을 보는 것입니다. HEAD를 사용하여 최신 커밋과 비교하거나 분기 이름을 다른 분기의 팁과 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c3233dc5774a7d1fc399a8b304cc732bba72d9f" translate="yes" xml:space="preserve">
          <source>This form is to view the changes you made relative to the index (staging area for the next commit). In other words, the differences are what you &lt;code&gt;could&lt;/code&gt; tell Git to further add to the index but you still haven&amp;rsquo;t. You can stage these changes by using &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;.</source>
          <target state="translated">이 양식은 인덱스 (다음 커밋의 스테이징 영역)와 관련하여 변경 한 내용을 확인하기위한 것입니다. 즉, 차이는 당신이 무엇을 &lt;code&gt;could&lt;/code&gt; 인덱스에 더 추가로 망할 놈의 말하지만 당신은 아직하지 않았습니다. &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 을 사용하여 이러한 변경 사항을 준비 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee8e76f95895702db36db495b0e53027904973c9" translate="yes" xml:space="preserve">
          <source>This form is to view the changes you staged for the next commit relative to the named &amp;lt;commit&amp;gt;. Typically you would want comparison with the latest commit, so if you do not give &amp;lt;commit&amp;gt;, it defaults to HEAD. If HEAD does not exist (e.g. unborn branches) and &amp;lt;commit&amp;gt; is not given, it shows all staged changes. --staged is a synonym of --cached.</source>
          <target state="translated">이 양식은 명명 된 &amp;lt;commit&amp;gt;을 기준으로 다음 커밋에 대해 준비한 변경 사항을 확인하기위한 것입니다. 일반적으로 최신 커밋과 비교를 원하므로 &amp;lt;commit&amp;gt;을 제공하지 않으면 기본값은 HEAD입니다. HEAD가 존재하지 않고 (예 : 태어나지 않은 지점) &amp;lt;commit&amp;gt;이 제공되지 않으면 모든 단계적 변경 사항이 표시됩니다. --staged는 --cached와 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="51dda6a69f38e64f972e32a62549822542d75887" translate="yes" xml:space="preserve">
          <source>This form is to view the differences between the raw contents of two blob objects.</source>
          <target state="translated">이 양식은 두 Blob 오브젝트의 원시 컨텐츠 간의 차이점을 확인하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="3140d31a73de32a89eb697f18f04aa202d7a5d8e" translate="yes" xml:space="preserve">
          <source>This form is to view the results of a merge commit. The first listed &amp;lt;commit&amp;gt; must be the merge itself; the remaining two or more commits should be its parents. A convenient way to produce the desired set of revisions is to use the ^@ suffix. For instance, if &lt;code&gt;master&lt;/code&gt; names a merge commit, &lt;code&gt;git diff master
master^@&lt;/code&gt; gives the same combined diff as &lt;code&gt;git show master&lt;/code&gt;.</source>
          <target state="translated">This form is to view the results of a merge commit. The first listed &amp;lt;commit&amp;gt; must be the merge itself; the remaining two or more commits should be its parents. A convenient way to produce the desired set of revisions is to use the ^@ suffix. For instance, if &lt;code&gt;master&lt;/code&gt; names a merge commit, &lt;code&gt;git diff master master^@&lt;/code&gt; gives the same combined diff as &lt;code&gt;git show master&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="395d78419362cad7438eb6eae46785d35953f019" translate="yes" xml:space="preserve">
          <source>This form resets the current branch head to &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; and possibly updates the index (resetting it to the tree of &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;) and the working tree depending on &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is omitted, defaults to &lt;code&gt;--mixed&lt;/code&gt;. The &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; must be one of the following:</source>
          <target state="translated">이 양식은 현재 분기 헤드를 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 으로 재설정하고 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 에 따라 색인 ( &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 의 트리로 재설정 ) 및 작업 트리를 업데이트합니다 . 경우 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 로, 기본적으로 생략 &lt;code&gt;--mixed&lt;/code&gt; 을 . &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 다음 중 하나 여야합니다 :</target>
        </trans-unit>
        <trans-unit id="90bcd35d4969f3a90ba2bd18f27a5c6eb93f333b" translate="yes" xml:space="preserve">
          <source>This form will use the first line matching the given POSIX regex. If &amp;lt;start&amp;gt; is a regex, it will search from the end of the previous &lt;code&gt;-L&lt;/code&gt; range, if any, otherwise from the start of file. If &amp;lt;start&amp;gt; is &amp;ldquo;^/regex/&amp;rdquo;, it will search from the start of file. If &amp;lt;end&amp;gt; is a regex, it will search starting at the line given by &amp;lt;start&amp;gt;.</source>
          <target state="translated">이 양식은 주어진 POSIX 정규식과 일치하는 첫 번째 줄을 사용합니다. &amp;lt;start&amp;gt;가 정규식 인 경우 이전 &lt;code&gt;-L&lt;/code&gt; 범위 의 끝 (있는 경우)에서 검색하고, 그렇지 않으면 파일 시작에서 검색합니다. &amp;lt;start&amp;gt;가&amp;ldquo;^ / regex /&amp;rdquo;인 경우 파일 시작 부분부터 검색합니다. &amp;lt;end&amp;gt;가 정규 표현식 인 경우 &amp;lt;start&amp;gt;에서 제공 한 줄부터 검색합니다.</target>
        </trans-unit>
        <trans-unit id="b42c261dd1828c15332725a480fa7095bcc76b2a" translate="yes" xml:space="preserve">
          <source>This format expects the first line of the file to contain the &quot;Cc:&quot; value and the &quot;Subject:&quot; of the message as the second line.</source>
          <target state="translated">이 형식에서는 파일의 첫 번째 줄에 메시지의 &quot;Cc :&quot;값과 &quot;Subject :&quot;가 두 번째 줄로 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="105520fc7842a24e43537a27759a074335828eb6" translate="yes" xml:space="preserve">
          <source>This format is identical to version &lt;code&gt;0&lt;/code&gt;, with the following exceptions:</source>
          <target state="translated">이 형식은 다음을 제외 하고 버전 &lt;code&gt;0&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="fd22347e6ce1cebbfe9140a8d5df54f1132eb3e9" translate="yes" xml:space="preserve">
          <source>This format is no longer produced by any Git command, but is and will continue to be supported by &lt;code&gt;update-index --index-info&lt;/code&gt;.</source>
          <target state="translated">이 형식은 더 이상 Git 명령으로 생성되지 않지만 &lt;code&gt;update-index --index-info&lt;/code&gt; 에서 계속 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="e1e42b99834dd201113f33eae88b5856f686096e" translate="yes" xml:space="preserve">
          <source>This format is to put higher order stages into the index file and matches &lt;code&gt;git ls-files --stage&lt;/code&gt; output.</source>
          <target state="translated">이 형식은 인덱스 파일에 고차 단계를 배치하고 &lt;code&gt;git ls-files --stage&lt;/code&gt; 출력 과 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="483caba3e82677e09e2d521ebba75089a90ce09e" translate="yes" xml:space="preserve">
          <source>This format is to stuff &lt;code&gt;git ls-tree&lt;/code&gt; output into the index.</source>
          <target state="translated">이 형식은 &lt;code&gt;git ls-tree&lt;/code&gt; 출력을 색인에 넣는 것입니다.</target>
        </trans-unit>
        <trans-unit id="078ec0cba6df63b2f2fc0bbcd069e250ea13b628" translate="yes" xml:space="preserve">
          <source>This format is used to refer to another commit in a commit message and is the same as &lt;code&gt;--pretty='format:%C(auto)%h (%s, %ad)'&lt;/code&gt;. By default, the date is formatted with &lt;code&gt;--date=short&lt;/code&gt; unless another &lt;code&gt;--date&lt;/code&gt; option is explicitly specified. As with any &lt;code&gt;format:&lt;/code&gt; with format placeholders, its output is not affected by other options like &lt;code&gt;--decorate&lt;/code&gt; and &lt;code&gt;--walk-reflogs&lt;/code&gt;.</source>
          <target state="translated">이 형식은 커밋 메시지에서 다른 커밋을 참조하는 데 사용되며 &lt;code&gt;--pretty='format:%C(auto)%h (%s, %ad)'&lt;/code&gt; 합니다. 기본적으로 다른 &lt;code&gt;--date&lt;/code&gt; 옵션을 지정 하지 않으면 날짜는 &lt;code&gt;--date=short&lt;/code&gt; 로 형식이 지정됩니다. 다른 &lt;code&gt;format:&lt;/code&gt; 과 마찬가지로 형식 자리 표시 자와 함께 출력은 &lt;code&gt;--decorate&lt;/code&gt; 및 &lt;code&gt;--walk-reflogs&lt;/code&gt; 와 같은 다른 옵션의 영향을받지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="742c78626a467f269e89b016f43c5e1a7be4cd88" translate="yes" xml:space="preserve">
          <source>This gets rid of the &lt;code&gt;git-svn-id:&lt;/code&gt; lines at the end of every commit.</source>
          <target state="translated">이것은 모든 커밋이 끝날 때 &lt;code&gt;git-svn-id:&lt;/code&gt; 행을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="2acaf36aea784a80df7509fcb8e38355c645c5a7" translate="yes" xml:space="preserve">
          <source>This gives a very controlled flow of fixes. If you notice that you have applied a fix to e.g. &lt;code&gt;master&lt;/code&gt; that is also required in &lt;code&gt;maint&lt;/code&gt;, you will need to cherry-pick it (using &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick[1]&lt;/a&gt;) downwards. This will happen a few times and is nothing to worry about unless you do it very frequently.</source>
          <target state="translated">이것은 매우 통제 된 수정 흐름을 제공합니다. &lt;code&gt;maint&lt;/code&gt; 에도 필요한 &lt;code&gt;master&lt;/code&gt; 에 수정을 적용한 것을 확인한 경우 , &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick [1]을&lt;/a&gt; 사용하여 아래쪽으로 체리를 선택해야합니다 . 이것은 몇 번 일어날 것이며 매우 자주하지 않으면 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f3884c08aac0f5d8941c7814b274c9743619a33" translate="yes" xml:space="preserve">
          <source>This happens if the &lt;code&gt;subsystem&lt;/code&gt; rebase had conflicts, or used &lt;code&gt;--interactive&lt;/code&gt; to omit, edit, squash, or fixup commits; or if the upstream used one of &lt;code&gt;commit --amend&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt;, or a full history rewriting command like &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;&lt;code&gt;filter-repo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이렇게하면 어떻게 &lt;code&gt;subsystem&lt;/code&gt; REBASE이 충돌을했다, 또는 사용 &lt;code&gt;--interactive&lt;/code&gt; 생략, 편집, 스쿼시, 또는 픽스 업 커밋에; 또는 업스트림에서 &lt;code&gt;commit --amend&lt;/code&gt; , &lt;code&gt;reset&lt;/code&gt; 또는 &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt; &lt;code&gt;filter-repo&lt;/code&gt; &lt;/a&gt; 와 같은 전체 기록 다시 쓰기 명령 중 하나를 사용한 경우 .</target>
        </trans-unit>
        <trans-unit id="53ac63807fcdbfc7e050fb3151d6b086f2e9a274" translate="yes" xml:space="preserve">
          <source>This happens if the &lt;code&gt;subsystem&lt;/code&gt; rebase was a simple rebase and had no conflicts.</source>
          <target state="translated">경우에 발생 &lt;code&gt;subsystem&lt;/code&gt; REBASE 간단한 REBASE이었고, 충돌이 없었다.</target>
        </trans-unit>
        <trans-unit id="d414984e9f8d7bfd782c8f2da36b80bcd80ea28e" translate="yes" xml:space="preserve">
          <source>This has a few user-visible effects and caveats:</source>
          <target state="translated">여기에는 몇 가지 사용자가 볼 수있는 효과와주의 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c876a37c9c7633e47e1a6a38b1f16f75e32a3ed" translate="yes" xml:space="preserve">
          <source>This has a very similar UI to &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;revert&lt;/code&gt;, and lets you add untracked paths to the index.</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;revert&lt;/code&gt; UI가 매우 유사 하며 추적되지 않은 경로를 색인에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33280cb105ee3b71902ce7b15c9592fd52f73e30" translate="yes" xml:space="preserve">
          <source>This has a very similar UI to &lt;code&gt;update&lt;/code&gt;, and the staged information for selected paths are reverted to that of the HEAD version. Reverting new paths makes them untracked.</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 할 UI가 매우 유사 하며 선택한 경로에 대한 준비된 정보가 HEAD 버전의 정보로 되돌아갑니다. 새로운 경로를 되 돌리면 추적되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d4512b846dcedcc9cf4704e69eaeda15e1830db" translate="yes" xml:space="preserve">
          <source>This has been requested by some kernel developers because some bugs called sporadic bugs do not appear in all the kernel builds because they are very dependent on the compiler output.</source>
          <target state="translated">이는 일부 커널 개발자가 요청한 것으로 산발적 버그라고하는 일부 버그는 컴파일러 출력에 크게 의존하기 때문에 모든 커널 빌드에 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b93781d2b5ee24d7b760545bc5177eb80e4c3e22" translate="yes" xml:space="preserve">
          <source>This has the advantage that it will be saved in your &lt;code&gt;CVS/Root&lt;/code&gt; files and you don&amp;rsquo;t need to worry about always setting the correct environment variable. SSH users restricted to &lt;code&gt;git-shell&lt;/code&gt; don&amp;rsquo;t need to override the default with CVS_SERVER (and shouldn&amp;rsquo;t) as &lt;code&gt;git-shell&lt;/code&gt; understands &lt;code&gt;cvs&lt;/code&gt; to mean &lt;code&gt;git-cvsserver&lt;/code&gt; and pretends that the other end runs the real &lt;code&gt;cvs&lt;/code&gt; better.</source>
          <target state="translated">이는 &lt;code&gt;CVS/Root&lt;/code&gt; 파일에 저장 되므로 항상 올바른 환경 변수 설정에 대해 걱정할 필요가 없다는 이점이 있습니다 . 제한 SSH 사용자 &lt;code&gt;git-shell&lt;/code&gt; CVS_SERVER에 기본값을 재정의해야 (그리고 안)하지 않는 &lt;code&gt;git-shell&lt;/code&gt; 이해 &lt;code&gt;cvs&lt;/code&gt; 평균에 &lt;code&gt;git-cvsserver&lt;/code&gt; 하고 다른 쪽 끝이 실제 실행되는 척 &lt;code&gt;cvs&lt;/code&gt; 더합니다.</target>
        </trans-unit>
        <trans-unit id="f27a3b2d1e595dbb21c1b28424b4a89305bcf439" translate="yes" xml:space="preserve">
          <source>This has two implications:</source>
          <target state="translated">여기에는 두 가지 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2d38b5ae6dea81df64d435d13a5c9c9c6e43a8c" translate="yes" xml:space="preserve">
          <source>This header line is followed by the following information at least once for each commit:</source>
          <target state="translated">이 헤더 행 다음에는 각 커밋마다 최소한 한 번 다음 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="aac19de1c954c0a5c2aba42bf1f288afbf74cabf" translate="yes" xml:space="preserve">
          <source>This helper uses specified file descriptors to connect to a remote Git server. This is not meant for end users but for programs and scripts calling git fetch, push or archive.</source>
          <target state="translated">이 도우미는 지정된 파일 설명자를 사용하여 원격 Git 서버에 연결합니다. 이것은 최종 사용자를위한 것이 아니라 git fetch, push 또는 archive를 호출하는 프로그램 및 스크립트를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="eafdc2cefff4153e88df550a24ce4b00606582ea" translate="yes" xml:space="preserve">
          <source>This hook can be used in conjunction with a corresponding pre-commit hook to save and restore any form of metadata associated with the working tree (e.g.: permissions/ownership, ACLS, etc). See contrib/hooks/setgitperms.perl for an example of how to do this.</source>
          <target state="translated">이 후크는 해당 사전 커밋 후크와 함께 사용하여 작업 트리와 관련된 모든 형식의 메타 데이터 (예 : 권한 / 소유권, ACLS 등)를 저장하고 복원 할 수 있습니다. 이를 수행하는 방법에 대한 예는 contrib / hooks / setgitperms.perl을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9fae8c19d5ced3830760d386f8db3473a746ea76" translate="yes" xml:space="preserve">
          <source>This hook can be used to perform repository validity checks, auto-display differences from the previous HEAD if different, or set working dir metadata properties.</source>
          <target state="translated">이 후크는 저장소 유효성 검사를 수행하거나, 이전 HEAD와 다른 경우 자동 표시 차이점을 수행하거나 작업 디렉토리 메타 데이터 특성을 설정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89a247d66f7dd9fd927ac160899ee7ad4eefe257" translate="yes" xml:space="preserve">
          <source>This hook can be used to prevent &lt;code&gt;forced&lt;/code&gt; update on certain refs by making sure that the object name is a commit object that is a descendant of the commit object named by the old object name. That is, to enforce a &quot;fast-forward only&quot; policy.</source>
          <target state="translated">이 후크는 오브젝트 이름이 이전 오브젝트 이름으로 명명 된 커미트 오브젝트의 자손 인 커미트 오브젝트인지 확인하여 특정 참조에서 &lt;code&gt;forced&lt;/code&gt; 업데이트 를 방지하는 데 사용될 수 있습니다 . 즉, &quot;빨리 감기&quot;정책을 시행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e2b4b08b5c7d529703ac2e4609fae5478174d015" translate="yes" xml:space="preserve">
          <source>This hook can be used, for example, to run &lt;code&gt;git update-server-info&lt;/code&gt; if the repository is packed and is served via a dumb transport.</source>
          <target state="translated">예를 들어 리포지토리가 압축되어 벙어리 전송을 통해 제공 되는 경우이 후크를 사용하여 &lt;code&gt;git update-server-info&lt;/code&gt; 를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec8359ca4fe68868d4a094d214fa5c736b07b686" translate="yes" xml:space="preserve">
          <source>This hook does not affect the outcome of &lt;code&gt;git receive-pack&lt;/code&gt;, as it is called after the real work is done.</source>
          <target state="translated">이 후크는 실제 작업이 완료된 후 호출되므로 &lt;code&gt;git receive-pack&lt;/code&gt; 의 결과에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4f1494681f56d1e644fae421a13f75381d1bf104" translate="yes" xml:space="preserve">
          <source>This hook executes once for the receive operation. It takes no arguments, but for each ref to be updated it receives on standard input a line of the format:</source>
          <target state="translated">이 후크는 수신 작업을 위해 한 번 실행됩니다. 인수는 없지만 각 참조가 업데이트 될 때마다 표준 입력에서 다음 형식의 행을 수신합니다.</target>
        </trans-unit>
        <trans-unit id="1c705c0b531046d9558421e4543f9aca35624390" translate="yes" xml:space="preserve">
          <source>This hook executes once for the receive operation. It takes no arguments, but gets the same information as the &lt;a href=&quot;#pre-receive&quot;&gt;&lt;em&gt;pre-receive&lt;/em&gt;&lt;/a&gt; hook does on its standard input.</source>
          <target state="translated">이 후크는 수신 작업을 위해 한 번 실행됩니다. 인수는 없지만 표준 입력 에서 &lt;a href=&quot;#pre-receive&quot;&gt;&lt;em&gt;사전 수신&lt;/em&gt;&lt;/a&gt; 후크 와 동일한 정보를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="98f6b796f54de07e8019b94d0f551840c498ad05" translate="yes" xml:space="preserve">
          <source>This hook executes once for the receive operation. It takes no arguments, but uses a pkt-line format protocol to communicate with &lt;code&gt;receive-pack&lt;/code&gt; to read commands, push-options and send results. In the following example for the protocol, the letter &lt;code&gt;S&lt;/code&gt; stands for &lt;code&gt;receive-pack&lt;/code&gt; and the letter &lt;code&gt;H&lt;/code&gt; stands for this hook.</source>
          <target state="translated">This hook executes once for the receive operation. It takes no arguments, but uses a pkt-line format protocol to communicate with &lt;code&gt;receive-pack&lt;/code&gt; to read commands, push-options and send results. In the following example for the protocol, the letter &lt;code&gt;S&lt;/code&gt; stands for &lt;code&gt;receive-pack&lt;/code&gt; and the letter &lt;code&gt;H&lt;/code&gt; stands for this hook.</target>
        </trans-unit>
        <trans-unit id="8f404b0d7afced029532dd1c0ce00c69033fa119" translate="yes" xml:space="preserve">
          <source>This hook is called before any refname is updated and before any fast-forward checks are performed.</source>
          <target state="translated">이 후크는 참조 이름이 업데이트되기 전에 그리고 빨리 감기 검사가 수행되기 전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6f4d4e6bc9f3d3e90e8224d9cc9d15607a5f159d" translate="yes" xml:space="preserve">
          <source>This hook is called by &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and can be used to prevent a push from taking place. The hook is called with two parameters which provide the name and location of the destination remote, if a named remote is not being used both values will be the same.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-push&quot;&gt;git-push [1]에&lt;/a&gt; 의해 호출되며 푸시 가 발생하지 않도록하는 데 사용될 수 있습니다. 후크는 대상 원격의 이름과 위치를 제공하는 두 개의 매개 변수와 함께 호출됩니다. 명명 된 원격을 사용하지 않는 경우 두 값이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b761c5f63f99b7c22c6e4ca4e1bd741b6a19c509" translate="yes" xml:space="preserve">
          <source>This hook is called by &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; and can be used to prevent a branch from getting rebased. The hook may be called with one or two parameters. The first parameter is the upstream from which the series was forked. The second parameter is the branch being rebased, and is not set when rebasing the current branch.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]에&lt;/a&gt; 의해 호출되며 브랜치가 리베이스되지 않도록하는 데 사용될 수 있습니다. 후크는 하나 또는 두 개의 매개 변수로 호출 될 수 있습니다. 첫 번째 매개 변수는 시리즈가 분기 된 업스트림입니다. 두 번째 매개 변수는 리베이스되는 브랜치이며 현재 브랜치를 리베이스 할 때 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc84f5afc2cc3712fb061152c42b83b5432e2d28" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;. It takes a single parameter, the name of the file that holds the proposed commit log message. Exiting with a non-zero status causes &lt;code&gt;git am&lt;/code&gt; to abort before applying the patch.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-am&quot;&gt;git-am [1]에&lt;/a&gt; 의해 호출됩니다 . 제안 된 커미트 로그 메시지를 보유하는 파일 이름 인 단일 매개 변수를 사용합니다. 0이 아닌 상태로 종료 하면 패치를 적용하기 전에 &lt;code&gt;git am&lt;/code&gt; 이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="109f1251e93ab76b92d28a05e1f40ca3ae3e2435" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;. It takes no parameter, and is invoked after the patch is applied and a commit is made.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-am&quot;&gt;git-am [1]에&lt;/a&gt; 의해 호출됩니다 . 매개 변수를 사용하지 않으며 패치가 적용되고 커미트 된 후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="31dd1042d3a6d88015bf6a789db56141bf61f664" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;. It takes no parameter, and is invoked after the patch is applied, but before a commit is made.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-am&quot;&gt;git-am [1]에&lt;/a&gt; 의해 호출됩니다 . 매개 변수를 사용하지 않으며 패치가 적용된 후, 그러나 커미트되기 전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4126a7ec7eb0a54d9b99d1f389fd70ce96c40950" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; and &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;, and can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes a single parameter, the name of the file that holds the proposed commit log message. Exiting with a non-zero status causes the command to abort.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 및 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]에&lt;/a&gt; 의해 호출되며 &lt;code&gt;--no-verify&lt;/code&gt; 옵션을 사용하여 무시할 수 있습니다 . 제안 된 커미트 로그 메시지를 보유하는 파일 이름 인 단일 매개 변수를 사용합니다. 0이 아닌 상태로 종료하면 명령이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="977ece26ae3c0446a7497462b09e90162737d6ca" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; right after preparing the default log message, and before the editor is started.</source>
          <target state="translated">이 후크는 기본 로그 메시지를 준비한 직후와 편집기가 시작되기 전에 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]에&lt;/a&gt; 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ae25bad855fc10ca5e955357c713cdbb31a472c" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;, and can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes no parameters, and is invoked before obtaining the proposed commit log message and making a commit. Exiting with a non-zero status from this script causes the &lt;code&gt;git commit&lt;/code&gt; command to abort before creating a commit.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]에&lt;/a&gt; 의해 호출되며 &lt;code&gt;--no-verify&lt;/code&gt; 옵션을 사용하여 무시할 수 있습니다 . 매개 변수가 없으며 제안 된 확약 로그 메시지를 확보하고 확약하기 전에 호출됩니다. 이 스크립트에서 0이 아닌 상태로 종료하면 &lt;code&gt;git commit&lt;/code&gt; 을 만들기 전에 git commit 명령이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="21226463d529e8f7d5082c27401d959f905ec4d1" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;. It takes no parameters, and is invoked after a commit is made.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]에&lt;/a&gt; 의해 호출됩니다 . 매개 변수를 사용하지 않으며 확약 후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0a4097349c79cead9de93e647cb9ba47cbed7c91" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;, and can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes no parameters, and is invoked after the merge has been carried out successfully and before obtaining the proposed commit log message to make a commit. Exiting with a non-zero status from this script causes the &lt;code&gt;git merge&lt;/code&gt; command to abort before creating a commit.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]에&lt;/a&gt; 의해 호출되며 &lt;code&gt;--no-verify&lt;/code&gt; 옵션을 사용하여 무시할 수 있습니다 . 매개 변수를 취하지 않으며 병합이 성공적으로 수행 된 후 그리고 커미트를 작성하기 위해 제안 된 커미트 로그 메시지를 얻기 전에 호출됩니다. 이 스크립트에서 0이 아닌 상태로 종료 하면 커밋을 만들기 전에 &lt;code&gt;git merge&lt;/code&gt; 명령이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="de911dadfd0a4abc2b13baa4ccbc2ae0aca9f055" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;, which happens when a &lt;code&gt;git pull&lt;/code&gt; is done on a local repository. The hook takes a single parameter, a status flag specifying whether or not the merge being done was a squash merge. This hook cannot affect the outcome of &lt;code&gt;git merge&lt;/code&gt; and is not executed, if the merge failed due to conflicts.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]에&lt;/a&gt; 의해 호출되는데 , 이는 로컬 리포지토리에서 &lt;code&gt;git pull&lt;/code&gt; 이 수행 될 때 발생 합니다. 후크는 단일 매개 변수, 수행중인 병합이 스쿼시 병합인지 여부를 지정하는 상태 플래그를 사용합니다. 이 후크는 &lt;code&gt;git merge&lt;/code&gt; 의 결과에 영향을 줄 수 없으며 충돌로 인해 병합이 실패한 경우에는 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76961cafe28e294daa6f1b287a02eb4fe4bf07aa" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository, and when the push tries to update the branch that is currently checked out and the &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; configuration variable is set to &lt;code&gt;updateInstead&lt;/code&gt;. Such a push by default is refused if the working tree and the index of the remote repository has any difference from the currently checked out commit; when both the working tree and the index match the current commit, they are updated to match the newly pushed tip of the branch. This hook is to be used to override the default behaviour.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; 이 &lt;code&gt;git push&lt;/code&gt; 에 반응 하고 리포지토리의 참조를 업데이트 할 때, 그리고 푸시가 현재 체크 아웃 된 브랜치 및 &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; 구성 변수 를 업데이트하려고 할 때 호출됩니다 . &lt;code&gt;updateInstead&lt;/code&gt; 로 설정되어 있습니다. 작업 트리와 원격 저장소의 색인이 현재 체크 아웃 된 커밋과 다른 경우 기본적으로 이러한 푸시는 거부됩니다. 작업 트리와 인덱스가 모두 현재 커밋과 일치하면 분기의 새로 푸시 된 팁과 일치하도록 업데이트됩니다. 이 후크는 기본 동작을 재정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5a56dac625f1205849f2b5f6e3619a708d3ea48e" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository. It executes on the remote repository once after all the refs have been updated.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; 이 &lt;code&gt;git push&lt;/code&gt; 에 반응 하고 리포지토리에서 참조를 업데이트 할 때 호출됩니다 . 모든 참조가 업데이트 된 후 원격 저장소에서 한 번 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="390ce0821ef413eec43c389641cce2dfc9687135" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository. Just before starting to update refs on the remote repository, the pre-receive hook is invoked. Its exit status determines the success or failure of the update.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; 이 &lt;code&gt;git push&lt;/code&gt; 에 반응 하고 리포지토리에서 참조를 업데이트 할 때 호출됩니다 . 원격 저장소에서 참조 업데이트를 시작하기 직전에 사전 수신 후크가 호출됩니다. 종료 상태에 따라 업데이트 성공 여부가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="f508c67d780c6e440d114ab5a4809e8db15887c6" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository. Just before updating the ref on the remote repository, the update hook is invoked. Its exit status determines the success or failure of the ref update.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; 이 &lt;code&gt;git push&lt;/code&gt; 에 반응 하고 리포지토리에서 참조를 업데이트 할 때 호출됩니다 . 원격 저장소에서 참조를 업데이트하기 직전에 업데이트 후크가 호출됩니다. 종료 상태에 따라 참조 업데이트의 성공 또는 실패가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="c165f7e2051fecf641e46f5c29ee35090d7d5f24" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt;. If the server has set the multi-valued config variable &lt;code&gt;receive.procReceiveRefs&lt;/code&gt;, and the commands sent to &lt;code&gt;receive-pack&lt;/code&gt; have matching reference names, these commands will be executed by this hook, instead of by the internal &lt;code&gt;execute_commands()&lt;/code&gt; function. This hook is responsible for updating the relevant references and reporting the results back to &lt;code&gt;receive-pack&lt;/code&gt;.</source>
          <target state="translated">This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt;. If the server has set the multi-valued config variable &lt;code&gt;receive.procReceiveRefs&lt;/code&gt; , and the commands sent to &lt;code&gt;receive-pack&lt;/code&gt; have matching reference names, these commands will be executed by this hook, instead of by the internal &lt;code&gt;execute_commands()&lt;/code&gt; function. This hook is responsible for updating the relevant references and reporting the results back to &lt;code&gt;receive-pack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c94fc31562e49c2e1f57905c2984b3787d6eb579" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt;. It takes a single parameter, the name of the file that holds the e-mail to be sent. Exiting with a non-zero status causes &lt;code&gt;git send-email&lt;/code&gt; to abort before sending any e-mails.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]에&lt;/a&gt; 의해 호출됩니다 . 전송할 전자 우편을 보유한 파일 이름 인 단일 매개 변수를 사용합니다. 0이 아닌 상태로 종료하면 &lt;code&gt;git send-email&lt;/code&gt; 을 보내기 전에 git send-email 이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="898dc345a1faef7e78cc6f07a48d416762cf9e72" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git gc --auto&lt;/code&gt; (see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;). It takes no parameter, and exiting with non-zero status from this script causes the &lt;code&gt;git gc --auto&lt;/code&gt; to abort.</source>
          <target state="translated">이 후크는 &lt;code&gt;git gc --auto&lt;/code&gt; 에 의해 호출됩니다 ( &lt;a href=&quot;git-gc&quot;&gt;git-gc [1] 참조&lt;/a&gt; ). 매개 변수가 &lt;code&gt;git gc --auto&lt;/code&gt; 스크립트에서 0이 아닌 상태로 종료하면 git gc --auto 가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="536d2f256146b81297af8f05d9ee07d3c788ff56" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git-p4 submit&lt;/code&gt;.</source>
          <target state="translated">This hook is invoked by &lt;code&gt;git-p4 submit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db96373c38bd1df6e078c9fa2b6d9e050d469bb3" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git-p4 submit&lt;/code&gt;. It takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevent &lt;code&gt;git-p4 submit&lt;/code&gt; from launching. It can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; command line option. Run &lt;code&gt;git-p4 submit --help&lt;/code&gt; for details.</source>
          <target state="translated">이 후크는 &lt;code&gt;git-p4 submit&lt;/code&gt; 에 의해 호출됩니다 . 표준 입력에서 매개 변수와 아무것도 사용하지 않습니다. 이 스크립트에서 0이 아닌 상태로 종료하면 &lt;code&gt;git-p4 submit&lt;/code&gt; 이 시작되지 않습니다. &lt;code&gt;--no-verify&lt;/code&gt; 명령 줄 옵션 으로 무시할 수 있습니다 . 자세한 내용은 &lt;code&gt;git-p4 submit --help&lt;/code&gt; 를 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="fa504b80ab7d4ab7fd02bb1c09f7267f7ffd0b87" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git-p4 submit&lt;/code&gt;. It takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevent &lt;code&gt;git-p4 submit&lt;/code&gt; from launching. Run &lt;code&gt;git-p4 submit --help&lt;/code&gt; for details.</source>
          <target state="translated">이 후크는 &lt;code&gt;git-p4 submit&lt;/code&gt; 에 의해 호출됩니다 . 매개 변수가 없으며 표준 입력에서 아무것도 가져 오지 않습니다. 이 스크립트에서 0이 아닌 상태로 종료하면 &lt;code&gt;git-p4 submit&lt;/code&gt; 이 시작되지 않습니다. 자세한 내용은 &lt;code&gt;git-p4 submit --help&lt;/code&gt; 를 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="e343164b203dd1de0ba3f9a30c792df16e0f19da" translate="yes" xml:space="preserve">
          <source>This hook is invoked by any Git command that performs reference updates. It executes whenever a reference transaction is prepared, committed or aborted and may thus get called multiple times.</source>
          <target state="translated">이 후크는 참조 업데이트를 수행하는 모든 Git 명령에 의해 호출됩니다. 참조 트랜잭션이 준비, 커밋 또는 중단 될 때마다 실행되므로 여러 번 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8569f58a670ba9d05dfd0c2191295df64e04e73" translate="yes" xml:space="preserve">
          <source>This hook is invoked by commands that rewrite commits (&lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; when called with &lt;code&gt;--amend&lt;/code&gt; and &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;; however, full-history (re)writing tools like &lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import[1]&lt;/a&gt; or &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt; typically do not call it!). Its first argument denotes the command it was invoked by: currently one of &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;. Further command-dependent arguments may be passed in the future.</source>
          <target state="translated">이 후크는 커밋을 다시 작성하는 명령 ( &lt;code&gt;--amend&lt;/code&gt; 및 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; 과 함께 호출되면 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 이지만 &lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import [1]&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo는&lt;/a&gt; 일반적으로 그것을 호출하지 않습니다!). 첫 번째 인수는 현재 &lt;code&gt;amend&lt;/code&gt; 또는 &lt;code&gt;rebase&lt;/code&gt; 중 하나에 의해 호출 된 명령을 나타냅니다 . 추후 명령 종속 인수가 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c8dde02f7fe4fac23930e917fd59c1d03fbfa8b" translate="yes" xml:space="preserve">
          <source>This hook is invoked when a &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; or &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; is run after having updated the worktree. The hook is given three parameters: the ref of the previous HEAD, the ref of the new HEAD (which may or may not have changed), and a flag indicating whether the checkout was a branch checkout (changing branches, flag=1) or a file checkout (retrieving a file from the index, flag=0). This hook cannot affect the outcome of &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt;, other than that the hook&amp;rsquo;s exit status becomes the exit status of these two commands.</source>
          <target state="translated">이 후크는 워크 트리를 업데이트 한 후 &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-switch&quot;&gt;git-switch [1]&lt;/a&gt; 가 실행될 때 호출됩니다 . 후크에는 이전 HEAD의 참조, 새 HEAD의 참조 (변경되었거나 변경되지 않았을 수 있음), 체크 아웃이 브랜치 체크 아웃 (브랜치 변경, 플래그 = 1)인지 여부를 나타내는 플래그가 제공됩니다. 파일 체크 아웃 (인덱스에서 파일 검색, flag = 0). 이 후크는 후크의 종료 상태가이 두 명령의 종료 상태가되는 것 외에는 &lt;code&gt;git switch&lt;/code&gt; 또는 &lt;code&gt;git checkout&lt;/code&gt; 의 결과에 영향을 줄 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7b20b75526e2af7ef8179932e884a838f68429b3" translate="yes" xml:space="preserve">
          <source>This hook is invoked when a &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; or &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; is run after having updated the worktree. The hook is given three parameters: the ref of the previous HEAD, the ref of the new HEAD (which may or may not have changed), and a flag indicating whether the checkout was a branch checkout (changing branches, flag=1) or a file checkout (retrieving a file from the index, flag=0). This hook cannot affect the outcome of &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt;.</source>
          <target state="translated">이 후크는 작업 트리 를 업데이트 한 후 &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-switch&quot;&gt;git-switch [1]&lt;/a&gt; 을 실행할 때 호출됩니다 . 후크에는 이전 HEAD의 참조, 새 HEAD의 참조 (변경되었거나 변경되지 않았을 수 있음) 및 체크 아웃이 분기 체크 아웃 (분기 변경, 플래그 = 1)인지를 나타내는 플래그 또는 파일 체크 아웃 (인덱스에서 파일 검색, 플래그 = 0) 이 후크는 &lt;code&gt;git switch&lt;/code&gt; 또는 &lt;code&gt;git checkout&lt;/code&gt; 결과에 영향을 줄 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fd3ae42761b9b86d30d029aa1493872ff1533f42" translate="yes" xml:space="preserve">
          <source>This hook is invoked when the configuration option &lt;code&gt;core.fsmonitor&lt;/code&gt; is set to &lt;code&gt;.git/hooks/fsmonitor-watchman&lt;/code&gt; or &lt;code&gt;.git/hooks/fsmonitor-watchmanv2&lt;/code&gt; depending on the version of the hook to use.</source>
          <target state="translated">구성 옵션의 경우에 후크가 호출됩니다 &lt;code&gt;core.fsmonitor&lt;/code&gt; 이 설정되어 &lt;code&gt;.git/hooks/fsmonitor-watchman&lt;/code&gt; 또는 &lt;code&gt;.git/hooks/fsmonitor-watchmanv2&lt;/code&gt; 사용에 후크의 버전에 따라.</target>
        </trans-unit>
        <trans-unit id="7b0692c459d4a723afc690b678a8556c7e5d3814" translate="yes" xml:space="preserve">
          <source>This hook is invoked when the configuration option &lt;code&gt;core.fsmonitor&lt;/code&gt; is set to &lt;code&gt;.git/hooks/fsmonitor-watchman&lt;/code&gt;. It takes two arguments, a version (currently 1) and the time in elapsed nanoseconds since midnight, January 1, 1970.</source>
          <target state="translated">이 후크는 구성 옵션 &lt;code&gt;core.fsmonitor&lt;/code&gt; 가 &lt;code&gt;.git/hooks/fsmonitor-watchman&lt;/code&gt; 으로 설정된 경우에 호출됩니다 . 1970 년 1 월 1 일 자정 이후 버전 (현재 1)과 경과 된 나노초 단위의 두 가지 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1ea8190ee0fad5a3aca31c578a724c322c0d57cb" translate="yes" xml:space="preserve">
          <source>This hook is invoked when the index is written in read-cache.c do_write_locked_index.</source>
          <target state="translated">이 후크는 인덱스가 read-cache.c do_write_locked_index에 기록 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bbcd7cc3d137fc9e83cb037a7ffe28a3a104cf5b" translate="yes" xml:space="preserve">
          <source>This hook is invoked with the environment variable &lt;code&gt;GIT_EDITOR=:&lt;/code&gt; if the command will not bring up an editor to modify the commit message.</source>
          <target state="translated">이 후크는 환경 변수 &lt;code&gt;GIT_EDITOR=:&lt;/code&gt; 로 명령이 커밋 메시지를 수정하기 위해 편집기를 불러 오지 않으면 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="ddc7ece9286909c0de44abe41d5a762b67552ed5" translate="yes" xml:space="preserve">
          <source>This hook is meant primarily for notification, and cannot affect the outcome of &lt;code&gt;git am&lt;/code&gt;.</source>
          <target state="translated">이 후크는 주로 알림을위한 것이며 &lt;code&gt;git am&lt;/code&gt; 의 결과에 영향을 줄 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="448e187d53f17c70cda00f92a3ee55c4bde07472" translate="yes" xml:space="preserve">
          <source>This hook is meant primarily for notification, and cannot affect the outcome of &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">이 후크는 주로 알림을위한 것이며 &lt;code&gt;git commit&lt;/code&gt; 결과에 영향을 줄 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="08260832c28c95684a1993d7203db5c6a733006a" translate="yes" xml:space="preserve">
          <source>This hook is meant primarily for notification, and cannot affect the outcome of &lt;code&gt;git receive-pack&lt;/code&gt;.</source>
          <target state="translated">이 후크는 주로 알림을위한 것이며 &lt;code&gt;git receive-pack&lt;/code&gt; 의 결과에 영향을 줄 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f1b9eafafbdf014b8c082347223fc7e3e439cd3c" translate="yes" xml:space="preserve">
          <source>This implies &lt;code&gt;--revs&lt;/code&gt;. In addition to the list of revision arguments read from the standard input, pretend as if all refs under &lt;code&gt;refs/&lt;/code&gt; are specified to be included.</source>
          <target state="translated">이것은 &lt;code&gt;--revs&lt;/code&gt; 를 의미 합니다 . 표준 입력에서 읽은 수정 인수 목록 외에도 &lt;code&gt;refs/&lt;/code&gt; 아래의 모든 참조 가 포함되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="00f6fe101136dac1c604175fe5bf787266d15317" translate="yes" xml:space="preserve">
          <source>This implies &lt;code&gt;--revs&lt;/code&gt;. When processing the list of revision arguments read from the standard input, limit the objects packed to those that are not already packed.</source>
          <target state="translated">이것은 &lt;code&gt;--revs&lt;/code&gt; 를 의미 합니다 . 표준 입력에서 읽은 수정 인수 목록을 처리 할 때 압축되지 않은 개체로 압축 된 개체를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="23abf25dbec44cc1a257bc71a457bb760d4a79eb" translate="yes" xml:space="preserve">
          <source>This implies the &lt;code&gt;--topo-order&lt;/code&gt; option by default, but the &lt;code&gt;--date-order&lt;/code&gt; option may also be specified.</source>
          <target state="translated">이는 기본적으로 &lt;code&gt;--topo-order&lt;/code&gt; 옵션을 의미 하지만 &lt;code&gt;--date-order&lt;/code&gt; 옵션도 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bafb6d097d43ca4ccca730edb887425acfba8b5" translate="yes" xml:space="preserve">
          <source>This imports the specified depot into &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; in an existing Git repository. The &lt;code&gt;--branch&lt;/code&gt; option can be used to specify a different branch to be used for the p4 content.</source>
          <target state="translated">지정된 저장소를 기존 Git 저장소의 &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; 로 가져옵니다 . &lt;code&gt;--branch&lt;/code&gt; 옵션은 P4 콘텐츠를 사용하는 다른 지점을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a7c7788d041aa1a2f51fc279f1f6f7da23ae666" translate="yes" xml:space="preserve">
          <source>This indicates that the helper is able to interact with the remote side using an explicit hash algorithm extension.</source>
          <target state="translated">이는 도우미가 명시 적 해시 알고리즘 확장을 사용하여 원격 측과 상호 작용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="505428074ae07b004fad59f4eaeb272274ac2c6b" translate="yes" xml:space="preserve">
          <source>This information can be used to determine what commit was the tip of a branch &quot;2 days ago&quot;.</source>
          <target state="translated">이 정보는 어떤 커밋이 &quot;2 일 전&quot;브랜치의 팁 이었는지 판별하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86187244d1368864bf6af8ccb054656e32b6a58b" translate="yes" xml:space="preserve">
          <source>This instructs git svn to recode pathnames to a given encoding. It can be used by windows users and by those who work in non-utf8 locales to avoid corrupted file names with non-ASCII characters. Valid encodings are the ones supported by Perl&amp;rsquo;s Encode module.</source>
          <target state="translated">이것은 git svn에게 경로명을 주어진 인코딩으로 코딩하도록 지시합니다. Windows 사용자와 비 UTF8 로케일에서 작업하는 사용자가 ASCII가 아닌 문자로 손상된 파일 이름을 피할 수 있습니다. 유효한 인코딩은 Perl의 Encode 모듈에서 지원되는 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="956c7627c61d83f78ef967d8ba93fedd722fb328" translate="yes" xml:space="preserve">
          <source>This integer config option controls how often the &lt;code&gt;commit-graph&lt;/code&gt; task should be run as part of &lt;code&gt;git maintenance run --auto&lt;/code&gt;. If zero, then the &lt;code&gt;commit-graph&lt;/code&gt; task will not run with the &lt;code&gt;--auto&lt;/code&gt; option. A negative value will force the task to run every time. Otherwise, a positive value implies the command should run when the number of reachable commits that are not in the commit-graph file is at least the value of &lt;code&gt;maintenance.commit-graph.auto&lt;/code&gt;. The default value is 100.</source>
          <target state="translated">이 정수 구성 옵션은 &lt;code&gt;commit-graph&lt;/code&gt; 작업이 &lt;code&gt;git maintenance run --auto&lt;/code&gt; 의 일부로 실행되어야 하는 빈도를 제어합니다 . 0이면 &lt;code&gt;commit-graph&lt;/code&gt; 작업이 &lt;code&gt;--auto&lt;/code&gt; 옵션으로 실행되지 않습니다 . 음수 값은 작업이 매번 실행되도록합니다. 그렇지 않으면 양수 값은 commit-graph 파일에없는 도달 가능한 커밋 수가 최소한 &lt;code&gt;maintenance.commit-graph.auto&lt;/code&gt; 값일 때 명령이 실행되어야 함을 의미합니다 . 기본값은 100입니다.</target>
        </trans-unit>
        <trans-unit id="0909b4167b1b6cfc93db8cafdc74248d3901c792" translate="yes" xml:space="preserve">
          <source>This is a deprecated synonym for &lt;code&gt;repack.writeBitmaps&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;repack.writeBitmaps&lt;/code&gt; 에 대한 더 이상 사용되지 않는 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="0663f3ff3f5e643bb58ee19e6a44fd14680c40d5" translate="yes" xml:space="preserve">
          <source>This is a login shell for SSH accounts to provide restricted Git access. It permits execution only of server-side Git commands implementing the pull/push functionality, plus custom commands present in a subdirectory named &lt;code&gt;git-shell-commands&lt;/code&gt; in the user&amp;rsquo;s home directory.</source>
          <target state="translated">SSH 계정이 제한된 Git 액세스를 제공하기위한 로그인 셸입니다. 풀 / 푸시 기능을 구현하는 서버 측 Git 명령과 사용자 홈 디렉토리의 &lt;code&gt;git-shell-commands&lt;/code&gt; 하위 디렉토리에있는 사용자 정의 명령 만 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb9b1700493e02e1c42808252a2a81a90b07f06f" translate="yes" xml:space="preserve">
          <source>This is a modified recursive strategy. When merging trees A and B, if B corresponds to a subtree of A, B is first adjusted to match the tree structure of A, instead of reading the trees at the same level. This adjustment is also done to the common ancestor tree.</source>
          <target state="translated">이것은 수정 된 재귀 전략입니다. 트리 A와 B를 병합 할 때 B가 A의 하위 트리에 해당하는 경우 동일한 레벨에서 트리를 읽는 대신 B가 A의 트리 구조와 일치하도록 먼저 조정됩니다. 이 조정은 공통 조상 트리에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ebc5555eb7976dd79439890cefef50e4fca7252" translate="yes" xml:space="preserve">
          <source>This is a multi-valued variable that defines reference prefixes to match the commands in &lt;code&gt;receive-pack&lt;/code&gt;. Commands matching the prefixes will be executed by an external hook &quot;proc-receive&quot;, instead of the internal &lt;code&gt;execute_commands&lt;/code&gt; function. If this variable is not defined, the &quot;proc-receive&quot; hook will never be used, and all commands will be executed by the internal &lt;code&gt;execute_commands&lt;/code&gt; function.</source>
          <target state="translated">이것은 &lt;code&gt;receive-pack&lt;/code&gt; 의 명령과 일치하는 참조 접두사를 정의하는 다중 값 변수입니다 . 접두사와 일치하는 명령은 내부 &lt;code&gt;execute_commands&lt;/code&gt; 함수 대신 외부 후크 &quot;proc-receive&quot;에 의해 실행됩니다 . 이 변수가 정의되어 있지 않으면 &quot;proc-receive&quot;후크가 사용되지 않으며 모든 명령은 내부 &lt;code&gt;execute_commands&lt;/code&gt; 함수에 의해 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="94478372a5a22fcace1286299ca604a903c0373f" translate="yes" xml:space="preserve">
          <source>This is a multi-valued variable, and an empty value can be used in a higher priority configuration file (e.g. &lt;code&gt;.git/config&lt;/code&gt; in a repository) to clear the values inherited from a lower priority configuration files (e.g. &lt;code&gt;$HOME/.gitconfig&lt;/code&gt;).</source>
          <target state="translated">이는 다중 값 변수이며, 우선 순위가 높은 구성 파일 (예 : 저장소의 &lt;code&gt;.git/config&lt;/code&gt; ) 에서 빈 값을 사용하여 우선 순위 가 낮은 구성 파일 (예 : &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; ) 에서 상속 된 값을 지울 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="9800795b0feafe785919ba7eb03d901a5af98b6d" translate="yes" xml:space="preserve">
          <source>This is a potentially &lt;em&gt;dangerous&lt;/em&gt; mode of operation. It rewrites history, which does not bode well when you published that history already. Do &lt;strong&gt;not&lt;/strong&gt; use this option unless you have read &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; carefully.</source>
          <target state="translated">이것은 잠재적으로 &lt;em&gt;위험한&lt;/em&gt; 작동 모드입니다. 기록을 다시 작성하므로 기록을 이미 게시했을 때 제대로 표시되지 않습니다. 마십시오 &lt;strong&gt;하지&lt;/strong&gt; 당신이 읽기가 없다면이 옵션을 사용하여 &lt;a href=&quot;git-rebase&quot;&gt;자식-REBASE [1]&lt;/a&gt; 을주의 깊게.</target>
        </trans-unit>
        <trans-unit id="7393bcbfeab09d874001a82423e807bb091915e9" translate="yes" xml:space="preserve">
          <source>This is a quick summary of the major commands; the previous chapters explain how these work in more detail.</source>
          <target state="translated">다음은 주요 명령에 대한 간략한 요약입니다. 이전 장에서는 이러한 기능이 어떻게 작동하는지 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e6b70a1472f7c00669a56c92197ed227d5be5866" translate="yes" xml:space="preserve">
          <source>This is a shorthand for &quot;--pretty=oneline --abbrev-commit&quot; used together.</source>
          <target state="translated">이것은 함께 사용되는 &quot;--pretty = oneline --abbrev-commit&quot;의 줄임말입니다.</target>
        </trans-unit>
        <trans-unit id="18c84bcba1b16c1ac1cf14d08c1c68d27e4599a1" translate="yes" xml:space="preserve">
          <source>This is a total waste of time and effort on a filesystem that orders data writes properly, but can be useful for filesystems that do not use journalling (traditional UNIX filesystems) or that only journal metadata and not file contents (OS X&amp;rsquo;s HFS+, or Linux ext3 with &quot;data=writeback&quot;).</source>
          <target state="translated">이는 데이터 쓰기를 올바르게 주문하는 파일 시스템에서 시간과 노력을 낭비하지만 저널링 (전통적인 UNIX 파일 시스템)을 사용하지 않거나 파일 내용이 아닌 저널 메타 데이터 만있는 파일 시스템 (OS X의 HFS + 또는 Linux)에 유용 할 수 있습니다. &quot;data = writeback&quot;이있는 ext3).</target>
        </trans-unit>
        <trans-unit id="554ab63db8a74b017dac093a21d0557d821484db" translate="yes" xml:space="preserve">
          <source>This is a toy format. The current time and time zone of this system is always copied into the identity string at the time it is being created by fast-import. There is no way to specify a different time or time zone.</source>
          <target state="translated">이것은 장난감 형식입니다. 이 시스템의 현재 시간 및 시간대는 빠른 가져 오기로 작성 될 때 항상 식별 문자열에 복사됩니다. 다른 시간대 나 시간대를 지정할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="bc30d84517d5f02b55a3811eba6ffba9e6c0e4f0" translate="yes" xml:space="preserve">
          <source>This is a work in progress.</source>
          <target state="translated">현재 진행중인 작업입니다.</target>
        </trans-unit>
        <trans-unit id="cdf94d586f4e34dd4d9c37fe3a3dd3a90ee94301" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;--group=committer&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;--group=committer&lt;/code&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="3e77feb91313add3d7aff3491329020f7cd2b88e" translate="yes" xml:space="preserve">
          <source>This is an easy way to check out a particular version without having to make up a name for the new branch. You can still create a new branch (or tag) for this version later if you decide to.</source>
          <target state="translated">이것은 새로운 브랜치의 이름을 만들지 않고도 특정 버전을 체크 아웃하는 쉬운 방법입니다. 원하는 경우 나중에이 버전에 대한 새 분기 (또는 태그)를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86d03a90949a936d437c536daea902a3352ca567" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;rebase&lt;/code&gt; is used in a workflow that treats the history at the remote as the shared canonical one, and treats the work done on the branch you are rebasing as the third-party work to be integrated, and you are temporarily assuming the role of the keeper of the canonical history during the rebase. As the keeper of the canonical history, you need to view the history from the remote as &lt;code&gt;ours&lt;/code&gt; (i.e. &quot;our shared canonical history&quot;), while what you did on your side branch as &lt;code&gt;theirs&lt;/code&gt; (i.e. &quot;one contributor&amp;rsquo;s work on top of it&quot;).</source>
          <target state="translated">이는 &lt;code&gt;rebase&lt;/code&gt; 가 원격의 기록을 공유 정식 기록으로 취급하고 분기에서 수행 한 작업을 통합 할 타사 작업으로 취급하고 일시적으로 역할을 가정하는 워크 플로우에서 사용 되기 때문 입니다. rebase 동안 정식 역사의 골키퍼. 정식 역사의 골키퍼로서, 당신은 원격에서 역사를 볼 필요가 &lt;code&gt;ours&lt;/code&gt; 당신이 당신의 곁가지에 무슨 짓을했는지 동안 (즉, &quot;공동의 정식 역사&quot;)와 같은 &lt;code&gt;theirs&lt;/code&gt; (즉, &quot;그 위에 하나 명의 기여의 작품&quot; ).</target>
        </trans-unit>
        <trans-unit id="95a20fc02bc3cd4094f682df1ea1f755e327d688" translate="yes" xml:space="preserve">
          <source>This is called a &lt;code&gt;hunk header&lt;/code&gt;. The &quot;TEXT&quot; portion is by default a line that begins with an alphabet, an underscore or a dollar sign; this matches what GNU &lt;code&gt;diff -p&lt;/code&gt; output uses. This default selection however is not suited for some contents, and you can use a customized pattern to make a selection.</source>
          <target state="translated">이것을 &lt;code&gt;hunk header&lt;/code&gt; 라고합니다 . &quot;TEXT&quot;부분은 기본적으로 알파벳, 밑줄 또는 달러 기호로 시작하는 줄입니다. 이것은 GNU &lt;code&gt;diff -p&lt;/code&gt; 출력이 사용 하는 것과 일치 합니다. 그러나이 기본 선택은 일부 내용에 적합하지 않으며 사용자 정의 패턴을 사용하여 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85de32d717921314245903361d4033db93188253" translate="yes" xml:space="preserve">
          <source>This is default name of common system-wide configuration file.</source>
          <target state="translated">이것은 일반적인 시스템 전체 구성 파일의 기본 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8fabc38be889239efec56b25dba57afb3b308b5b" translate="yes" xml:space="preserve">
          <source>This is default name of fallback system-wide configuration file. This file is used only if per-instance configuration variable is not found.</source>
          <target state="translated">대체 시스템 전체 구성 파일의 기본 이름입니다. 이 파일은 인스턴스 별 구성 변수를 찾을 수없는 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e13cac7eff842df90d7031a70a4150ab3a8cdbc2" translate="yes" xml:space="preserve">
          <source>This is default name of per-instance configuration file. The format of this file is described above.</source>
          <target state="translated">인스턴스 별 구성 파일의 기본 이름입니다. 이 파일의 형식은 위에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ac99b50de3702f5d543e44c6b1ddc55b08d7471" translate="yes" xml:space="preserve">
          <source>This is designed to be as compact as possible.</source>
          <target state="translated">가능한 한 작게 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="d4d30dfd1772dd73a7b51cd065bd14037d1044bf" translate="yes" xml:space="preserve">
          <source>This is done to prevent you from losing your work-in-progress changes, and mixing your random changes in an unrelated merge commit. To illustrate, suppose you start from what has been committed last to your repository:</source>
          <target state="translated">이는 진행중인 작업 변경 내용을 잃지 않고 관련없는 병합 커밋에서 임의의 변경 내용을 혼합하지 않도록하기 위해 수행됩니다. 예를 들어, 저장소에 마지막으로 커밋 된 것부터 시작한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c5483036881ec5a0c568843866e403149495194d" translate="yes" xml:space="preserve">
          <source>This is how you read a blob (actually, not only a blob, but any type of object). To know how the function &lt;code&gt;read_object_with_reference()&lt;/code&gt; actually works, find the source code for it (something like &lt;code&gt;git grep
read_object_with | grep &quot;:[a-z]&quot;&lt;/code&gt; in the Git repository), and read the source.</source>
          <target state="translated">이것은 당신이 블롭을 읽는 방법입니다 (실제로 블롭뿐만 아니라 모든 유형의 객체). &lt;code&gt;read_object_with_reference()&lt;/code&gt; 함수가 실제로 어떻게 작동하는지 알아 보려면 소스 코드 ( &lt;code&gt;git grep read_object_with | grep &quot;:[a-z]&quot;&lt;/code&gt; 와 같은 것)를 찾아 소스를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="d94f65e687e225292db2cabccebd8f5b3adaa1d5" translate="yes" xml:space="preserve">
          <source>This is ideally suited for read-only updates, i.e., pulling from Git repositories.</source>
          <target state="translated">이것은 읽기 전용 업데이트, 즉 Git 리포지토리에서 가져 오기에 이상적입니다.</target>
        </trans-unit>
        <trans-unit id="4f74abb17322f51c4e08c52446429282a69cbb4c" translate="yes" xml:space="preserve">
          <source>This is intended to be used by the test suite only. It allows to force the version for the generated pack index, and to force 64-bit index entries on objects located above the given offset.</source>
          <target state="translated">이것은 테스트 스위트에서만 사용하기위한 것입니다. 생성 된 팩 색인의 버전을 강제 실행하고 지정된 오프셋 위에있는 오브젝트에서 64 비트 색인 항목을 강제 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8180429180a5d33dfa16e7d2805d2ac9f53f061d" translate="yes" xml:space="preserve">
          <source>This is just to get you into the groove for the most libified part of Git: the revision walker.</source>
          <target state="translated">이것은 Git의 가장 수정 된 부분 인 개정 워커에 대한 홈으로 들어가기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="dce30f3fbb0be29025f159d55505215087cce86b" translate="yes" xml:space="preserve">
          <source>This is known to &lt;code&gt;range-diff&lt;/code&gt; as &quot;dual coloring&quot;. Use &lt;code&gt;--no-dual-color&lt;/code&gt; to revert to color all lines according to the outer diff markers (and completely ignore the inner diff when it comes to color).</source>
          <target state="translated">이것은 &quot;이중 채색&quot;으로 &lt;code&gt;range-diff&lt;/code&gt; 가 다른 것으로 알려져 있습니다. 외부 diff 마커에 따라 모든 선의 &lt;code&gt;--no-dual-color&lt;/code&gt; 을 되돌리려면 --no-dual-color 를 사용하십시오 (그리고 색상과 관련하여 내부 diff를 완전히 무시하십시오).</target>
        </trans-unit>
        <trans-unit id="51ecbd5eaeeeee461a4969f3b0cb27dc975ebc23" translate="yes" xml:space="preserve">
          <source>This is made much worse if many files have to be fixed to resolve conflicts. That&amp;rsquo;s why such merges are called &quot;evil merges&quot;. They can make regressions very difficult to track down. It can even be misleading to know the first bad commit if it happens to be such a merge, because people might think that the bug comes from bad conflict resolution when it comes from a semantic change in one branch.</source>
          <target state="translated">충돌을 해결하기 위해 많은 파일을 수정해야하는 경우 훨씬 더 나빠집니다. 이러한 합병을 &quot;이블 합병&quot;이라고합니다. 회귀 추적을 매우 어렵게 만들 수 있습니다. 사람들이 버그가 하나의 분기에서 의미 론적 변화에서 비롯된 경우 잘못된 충돌 해결에서 비롯된 것으로 생각할 수 있기 때문에 이러한 병합이 발생하는 경우 첫 번째 잘못된 커밋을 아는 것은 잘못된 결과 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2742189647afc1dbda2e1e2ecc6c9303cbb2d70b" translate="yes" xml:space="preserve">
          <source>This is meant to be used by higher level scripts to compute merge results outside of the index, and stuff the results back into the index. For this reason, the output from the command omits entries that match the &amp;lt;branch1&amp;gt; tree.</source>
          <target state="translated">이는 고급 스크립트에서 인덱스 외부의 병합 결과를 계산하고 결과를 다시 인덱스에 채우는 데 사용됩니다. 이러한 이유로 명령의 출력은 &amp;lt;branch1&amp;gt; 트리와 일치하는 항목을 생략합니다.</target>
        </trans-unit>
        <trans-unit id="9ccf843e585a34e60ae505f61685a10813c9c88a" translate="yes" xml:space="preserve">
          <source>This is most often done when you remembered what you just committed is incomplete, or you misspelled your commit message, or both. Leaves working tree as it was before &quot;reset&quot;.</source>
          <target state="translated">이것은 방금 커밋 한 내용이 불완전하거나 커밋 메시지의 철자가 틀리거나 두 가지 모두를 기억할 때 가장 자주 수행됩니다. &quot;재설정&quot;이전과 같이 작업 트리를 떠납니다.</target>
        </trans-unit>
        <trans-unit id="efff48b2c5bed4c5ab6435b6d058280a53664967" translate="yes" xml:space="preserve">
          <source>This is not a command the end user would want to run. Ever. This documentation is meant for people who are studying the Porcelain-ish scripts and/or are writing new ones.</source>
          <target state="translated">이것은 최종 사용자가 실행하고자하는 명령이 아닙니다. 이제까지. 이 문서는 도자기로 된 대본을 공부하거나 새로운 대본을 쓰는 사람들을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="4c9e09ba77ce1340a426d6ae669add42a4fe4542" translate="yes" xml:space="preserve">
          <source>This is not a real filter executed for each commit but a one time setup just before the loop. Therefore no commit-specific variables are defined yet. Functions or variables defined here can be used or modified in the following filter steps except the commit filter, for technical reasons.</source>
          <target state="translated">이것은 각 커밋에 대해 실행되는 실제 필터가 아니라 루프 직전에 한 번 설정됩니다. 따라서 확약 특정 변수가 아직 정의되지 않았습니다. 여기에 정의 된 함수 또는 변수는 기술적 인 이유로 커밋 필터를 제외한 다음 필터 단계에서 사용하거나 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad1d1c10cd51125ef48d021d8c7283be0413a66d" translate="yes" xml:space="preserve">
          <source>This is not hard to understand, as soon as you realize that Git simply never knows (or cares) about files that it is not told about explicitly. Git will never go &lt;strong&gt;looking&lt;/strong&gt; for files to compare, it expects you to tell it what the files are, and that&amp;rsquo;s what the index is there for.</source>
          <target state="translated">Git이 명시 적으로 알려지지 않은 파일에 대해 결코 알지 못한다는 것을 알게 되 자마자 이해하기 어렵지 않습니다. Git은 비교할 파일을 &lt;strong&gt;찾지&lt;/strong&gt; 않을 것입니다. 파일이 무엇인지 알려주기 때문에 인덱스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0273358cae89a5a683cca4bca340f2d1ab3cc600" translate="yes" xml:space="preserve">
          <source>This is only used by git-completion.bash to add or remove commands from the list of completed commands. Normally only porcelain commands and a few select others are completed. You can add more commands, separated by space, in this variable. Prefixing the command with &lt;code&gt;-&lt;/code&gt; will remove it from the existing list.</source>
          <target state="translated">완료된 명령 목록에서 명령을 추가하거나 제거하기 위해 git-completion.bash에서만 사용됩니다. 일반적으로 도자기 명령과 일부 다른 명령 만 완료됩니다. 이 변수에 공백으로 구분 된 명령을 더 추가 할 수 있습니다. 명령 앞에 &lt;code&gt;-&lt;/code&gt; 를 붙이면 기존 목록에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="fcaf558e1ca35a6c93dcb363081455cef6ced8a0" translate="yes" xml:space="preserve">
          <source>This is only valid for &amp;lt;end&amp;gt; and will specify a number of lines before or after the line given by &amp;lt;start&amp;gt;.</source>
          <target state="translated">이것은 &amp;lt;end&amp;gt;에만 유효하며 &amp;lt;start&amp;gt;에 의해 주어진 행 앞뒤에 많은 행을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1b0501180252ff128dca83458515deca695a7ecc" translate="yes" xml:space="preserve">
          <source>This is optional and is only searched when &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; is present in $GIT_DIR/config.</source>
          <target state="translated">이것은 선택 사항이며 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 가 $ GIT_DIR / config에 있을 때만 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="4306207006bf4fdd2134f4efea5f0d698d2c1f81" translate="yes" xml:space="preserve">
          <source>This is particularly true when passing in diff options. Currently some options like &lt;code&gt;--stat&lt;/code&gt; can, as an emergent effect, produce output that&amp;rsquo;s quite useless in the context of &lt;code&gt;range-diff&lt;/code&gt;. Future versions of &lt;code&gt;range-diff&lt;/code&gt; may learn to interpret such options in a manner specific to &lt;code&gt;range-diff&lt;/code&gt; (e.g. for &lt;code&gt;--stat&lt;/code&gt; producing human-readable output which summarizes how the diffstat changed).</source>
          <target state="translated">diff 옵션을 전달할 때 특히 그렇습니다. 현재 &lt;code&gt;--stat&lt;/code&gt; 와 같은 일부 옵션 은 출현 효과로 &lt;code&gt;range-diff&lt;/code&gt; 컨텍스트에서 매우 쓸모없는 출력을 생성 할 수 있습니다 . 향후 버전 &lt;code&gt;range-diff&lt;/code&gt; 에 방식으로 특정 이러한 옵션 해석을 배울 수 &lt;code&gt;range-diff&lt;/code&gt; (에 대한 예를 &lt;code&gt;--stat&lt;/code&gt; diffstat 변경 방법을 요약 사람이 읽을 수있는 출력을 생성).</target>
        </trans-unit>
        <trans-unit id="c2dfec9fbb580524d9c87ce7e3303a7b47cc295d" translate="yes" xml:space="preserve">
          <source>This is passed to both underlying git-fetch to squelch reporting of during transfer, and underlying git-merge to squelch output during merging.</source>
          <target state="translated">이것은 전송하는 동안 기본 git-fetch to squelch보고와 병합하는 동안 기본 git-merge to squelch 출력으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="3d17e8f742373c8bbf1871e58142a3d3c4b1c09b" translate="yes" xml:space="preserve">
          <source>This is per-repository enhancement / version of global prefix-based &lt;code&gt;@git_base_url_list&lt;/code&gt; gitweb configuration variable (see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;).</source>
          <target state="translated">전역 접두사 기반 &lt;code&gt;@git_base_url_list&lt;/code&gt; gitweb 구성 변수 의 저장소 별 향상 / 버전입니다 ( &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a7bcc6783fe2c533eb40b84879a83d32f4d95dc9" translate="yes" xml:space="preserve">
          <source>This is similar to --symbolic, but it omits input that are not refs (i.e. branch or tag names; or more explicitly disambiguating &quot;heads/master&quot; form, when you want to name the &quot;master&quot; branch when there is an unfortunately named tag &quot;master&quot;), and show them as full refnames (e.g. &quot;refs/heads/master&quot;).</source>
          <target state="translated">이것은 --symbolic과 비슷하지만 참조가 아닌 입력 (예 : 분기 또는 태그 이름) 또는 불행히도 명명 된 &quot;마스터&quot;분기의 이름을 지정하려는 경우 더 명확하게 &quot;헤드 / 마스터&quot;양식을 명시 적으로 생략합니다. 태그를 &quot;마스터&quot;로 지정하고 전체 참조 이름으로 표시합니다 (예 : &quot;refs / heads / master&quot;).</target>
        </trans-unit>
        <trans-unit id="4cae7dda407705febf1be1d8f0d77956238a429a" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;info/grafts&lt;/code&gt; but is internally used and maintained by shallow clone mechanism. See &lt;code&gt;--depth&lt;/code&gt; option to &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; and &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;. This file is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/shallow&quot; will be used instead.</source>
          <target state="translated">이것은 &lt;code&gt;info/grafts&lt;/code&gt; 와 비슷 하지만 내부적으로 얕은 복제 메커니즘에 의해 사용되고 유지됩니다. &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 및 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]에 대한 &lt;/a&gt; &lt;code&gt;--depth&lt;/code&gt; 옵션을 참조하십시오 . $ GIT_COMMON_DIR이 설정되고 대신 &quot;$ GIT_COMMON_DIR / shallow&quot;가 사용되면이 파일은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="44c5e44a5b0e8e88feba4a9ab4b3411e28cf0521" translate="yes" xml:space="preserve">
          <source>This is similar to the previous mode, but lets you use the interactive interface to show the &quot;diff&quot; output and choose which hunks to use in the result. See below for the description of &lt;code&gt;--patch&lt;/code&gt; option.</source>
          <target state="translated">이것은 이전 모드와 비슷하지만 대화식 인터페이스를 사용하여 &quot;diff&quot;출력을 표시하고 결과에 사용할 덩어리를 선택할 수 있습니다. &lt;code&gt;--patch&lt;/code&gt; 옵션 에 대한 설명은 아래를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d4677f97f18bb53a7088b838331f1fec5e57df8" translate="yes" xml:space="preserve">
          <source>This is synonymous to the earlier form (without the &quot;..&quot;) for viewing the changes between two arbitrary &amp;lt;commit&amp;gt;. If &amp;lt;commit&amp;gt; on one side is omitted, it will have the same effect as using HEAD instead.</source>
          <target state="translated">이것은 두 임의의 &amp;lt;commit&amp;gt; 사이의 변경 사항을보기위한 이전 양식 ( &quot;..&quot;없음)과 동의어입니다. 한쪽에서 &amp;lt;commit&amp;gt;을 생략하면 대신 HEAD를 사용하는 것과 동일한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4054020991b3f63ee43241d99b871a192e5f7888" translate="yes" xml:space="preserve">
          <source>This is synonymous to the previous form. If &amp;lt;commit&amp;gt; on one side is omitted, it will have the same effect as using HEAD instead.</source>
          <target state="translated">이것은 이전 양식과 동의어입니다. 한쪽의 &amp;lt;commit&amp;gt;을 생략하면 대신 HEAD를 사용하는 것과 동일한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="75478eb48b06b2098532610f52369c54c5a35766" translate="yes" xml:space="preserve">
          <source>This is the Git native format and is &lt;code&gt;&amp;lt;time&amp;gt; SP &amp;lt;offutc&amp;gt;&lt;/code&gt;. It is also fast-import&amp;rsquo;s default format, if --date-format was not specified.</source>
          <target state="translated">이것은 Git 기본 형식이며 &lt;code&gt;&amp;lt;time&amp;gt; SP &amp;lt;offutc&amp;gt;&lt;/code&gt; 입니다. --date-format이 지정되지 않은 경우 빠른 가져 오기의 기본 형식이기도합니다.</target>
        </trans-unit>
        <trans-unit id="6bd79ba5c8340a61cc49527317aae865e2230698" translate="yes" xml:space="preserve">
          <source>This is the filter for performing the commit. If this filter is specified, it will be called instead of the &lt;code&gt;git commit-tree&lt;/code&gt; command, with arguments of the form &quot;&amp;lt;TREE_ID&amp;gt; [(-p &amp;lt;PARENT_COMMIT_ID&amp;gt;)&amp;hellip;​]&quot; and the log message on stdin. The commit id is expected on stdout.</source>
          <target state="translated">커밋을 수행하기위한 필터입니다. 이 필터가 지정되면 &quot;&amp;lt;TREE_ID&amp;gt; [(-p &amp;lt;PARENT_COMMIT_ID&amp;gt;)&amp;hellip;]] 형식의 인수와 stdin의 로그 메시지와 함께 &lt;code&gt;git commit-tree&lt;/code&gt; 명령 대신 필터가 호출됩니다 . 커밋 ID는 stdout에서 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="ab02ed108f018595c9832dcfce47c6a593278667" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting tag names. When passed, it will be called for every tag ref that points to a rewritten object (or to a tag object which points to a rewritten object). The original tag name is passed via standard input, and the new tag name is expected on standard output.</source>
          <target state="translated">태그 이름을 다시 쓰는 필터입니다. 전달되면 다시 작성된 객체를 가리키는 모든 태그 참조 또는 다시 작성된 객체를 가리키는 태그 객체에 대해 호출됩니다. 원래 태그 이름은 표준 입력을 통해 전달되며 새 태그 이름은 표준 출력에 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="ec46b5cef98509f43f653471ea24de2e709b0b36" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the commit messages. The argument is evaluated in the shell with the original commit message on standard input; its standard output is used as the new commit message.</source>
          <target state="translated">커밋 메시지를 다시 쓰기위한 필터입니다. 인수는 표준 입력에서 원래 커밋 메시지와 함께 쉘에서 평가됩니다. 표준 출력은 새로운 커밋 메시지로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="baaf77805fbcb910ae11f451b39d9e38daaa6669" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the commit&amp;rsquo;s parent list. It will receive the parent string on stdin and shall output the new parent string on stdout. The parent string is in the format described in &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt;: empty for the initial commit, &quot;-p parent&quot; for a normal commit and &quot;-p parent1 -p parent2 -p parent3 &amp;hellip;​&quot; for a merge commit.</source>
          <target state="translated">커밋의 상위 목록을 다시 작성하기위한 필터입니다. stdin에서 상위 문자열을 수신하고 stdout에서 새 상위 문자열을 출력해야합니다. 부모 문자열은 &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]에&lt;/a&gt; 설명 된 형식으로되어 있습니다 : 초기 커밋의 경우 비어 있고, 일반 커밋의 경우 &quot;-p parent&quot;, 병합의 경우 &quot;-p parent1 -p parent2 -p parent3&amp;hellip; 범하다.</target>
        </trans-unit>
        <trans-unit id="ed6796eee1e84719fc79503aec05a2585b0a98ee" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the index. It is similar to the tree filter but does not check out the tree, which makes it much faster. Frequently used with &lt;code&gt;git rm --cached
--ignore-unmatch ...&lt;/code&gt;, see EXAMPLES below. For hairy cases, see &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">인덱스를 다시 쓰기위한 필터입니다. 트리 필터와 비슷하지만 트리를 체크 아웃하지 않으므로 훨씬 빠릅니다. &lt;code&gt;git rm --cached --ignore-unmatch ...&lt;/code&gt; 와 함께 자주 사용되며 , 아래 예를 참조하십시오. 털이 많은 경우 &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="84464b13412e29584cb64fc663c003212ddd470c" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the tree and its contents. The argument is evaluated in shell with the working directory set to the root of the checked out tree. The new tree is then used as-is (new files are auto-added, disappeared files are auto-removed - neither .gitignore files nor any other ignore rules &lt;strong&gt;HAVE ANY EFFECT&lt;/strong&gt;!).</source>
          <target state="translated">트리와 그 내용을 다시 작성하기위한 필터입니다. 인수는 작업 디렉토리가 체크 아웃 된 트리의 루트로 설정된 쉘에서 평가됩니다. 그런 다음 새 트리는 그대로 사용됩니다 (새 파일은 자동으로 추가되고 사라진 파일은 자동으로 제거됩니다. .gitignore 파일이나 다른 무시 규칙에는 &lt;strong&gt;영향이 없습니다&lt;/strong&gt; !).</target>
        </trans-unit>
        <trans-unit id="ac6e8f6a01875184858c8585102e8f6aa273aee7" translate="yes" xml:space="preserve">
          <source>This is the format defined by the initial version of git, including but not limited to the format of the repository directory, the repository configuration file, and the object and ref storage. Specifying the complete behavior of git is beyond the scope of this document.</source>
          <target state="translated">이것은 리포지토리 디렉토리, 리포지토리 구성 파일 및 객체 및 참조 스토리지의 형식을 포함하여 git의 초기 버전에 의해 정의 된 형식입니다. git의 완전한 동작을 지정하는 것은이 문서의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="53064adeec7c86c12f0de7129be2018180dbdde8" translate="yes" xml:space="preserve">
          <source>This is the instruction format to copy a byte range from the source object. It encodes the offset to copy from and the number of bytes to copy. Offset and size are in little-endian order.</source>
          <target state="translated">소스 객체에서 바이트 범위를 복사하기위한 명령어 형식입니다. 복사 할 오프셋과 복사 할 바이트 수를 인코딩합니다. 오프셋과 크기는 리틀 엔디안 순서입니다.</target>
        </trans-unit>
        <trans-unit id="7c56810b4cb2a212f096564a869dc50ed111eb3c" translate="yes" xml:space="preserve">
          <source>This is the instruction reserved for future expansion.</source>
          <target state="translated">이것은 향후 확장을 위해 예약 된 명령입니다.</target>
        </trans-unit>
        <trans-unit id="2ac15a186ae4c1add6605d649b034295db99bef1" translate="yes" xml:space="preserve">
          <source>This is the instruction to construct target object without the base object. The following data is appended to the target object. The first seven bits of the first octet determines the size of data in bytes. The size must be non-zero.</source>
          <target state="translated">기본 오브젝트없이 대상 오브젝트를 구성하는 지시 사항입니다. 다음 데이터가 대상 개체에 추가됩니다. 첫 번째 옥텟의 처음 7 비트는 바이트 단위의 데이터 크기를 결정합니다. 크기는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="109ca8035c1b87bb820c08a28a9de7b34fde1bb6" translate="yes" xml:space="preserve">
          <source>This is the opposite of &lt;code&gt;ours&lt;/code&gt;; note that, unlike &lt;code&gt;ours&lt;/code&gt;, there is no &lt;code&gt;theirs&lt;/code&gt; merge strategy to confuse this merge option with.</source>
          <target state="translated">이것은 &lt;code&gt;ours&lt;/code&gt; 의 반대입니다 . 달리 점에 유의 &lt;code&gt;ours&lt;/code&gt; , 더이없는 &lt;code&gt;theirs&lt;/code&gt; 이 병합 옵션을 혼동하는 병합 전략.</target>
        </trans-unit>
        <trans-unit id="a470bc42a7932d13fef06a087064186d12eef547" translate="yes" xml:space="preserve">
          <source>This is the preferred method.</source>
          <target state="translated">이것이 선호되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d5ae5cf60359e7831f40d915d7567f63dc115a19" translate="yes" xml:space="preserve">
          <source>This is the same &lt;code&gt;git read-tree&lt;/code&gt; command we have already seen, but it takes three trees, unlike previous examples. This reads the contents of each tree into different &lt;code&gt;stage&lt;/code&gt; in the index file (the first tree goes to stage 1, the second to stage 2, etc.). After reading three trees into three stages, the paths that are the same in all three stages are &lt;code&gt;collapsed&lt;/code&gt; into stage 0. Also paths that are the same in two of three stages are collapsed into stage 0, taking the SHA-1 from either stage 2 or stage 3, whichever is different from stage 1 (i.e. only one side changed from the common ancestor).</source>
          <target state="translated">이것은 우리가 이미 본 것과 동일한 &lt;code&gt;git read-tree&lt;/code&gt; 명령이지만, 이전 예제와 달리 3 개의 트리가 필요합니다. 인덱스 파일에서 각 트리의 내용을 다른 &lt;code&gt;stage&lt;/code&gt; 로 읽습니다 (첫 번째 트리는 1 단계로, 두 번째는 2 단계로 이동합니다). 세 개의 나무를 세 단계로 읽은 후 세 단계 모두에서 동일한 경로가 단계 0 으로 &lt;code&gt;collapsed&lt;/code&gt; 됩니다. 또한 세 단계 중 두 단계에서 동일한 경로가 단계 0으로 축소되어 두 단계 중 하나에서 SHA-1이 사용됩니다. 또는 1 단계와 다른 단계 3 (즉, 한쪽 만 공통 조상에서 변경됨).</target>
        </trans-unit>
        <trans-unit id="d9a78198f4c718b4aad0f141375d5823cd8e39e3" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;gitdir&lt;/code&gt; except that matching is done case-insensitively (e.g. on case-insensitive file systems)</source>
          <target state="translated">이것은 동일 &lt;code&gt;gitdir&lt;/code&gt; 그 일치를 제외하고 완료를 대문자와 소문자를 구별하지 않고로 (예를 들어, 대소 문자를 구분 파일 시스템)입니다</target>
        </trans-unit>
        <trans-unit id="6d8ef8c3ff85a1d3362ff60dea809d4867db08e2" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;raw&lt;/code&gt; except that no sanity checks on the numeric epoch and local offset are performed. This can be useful when trying to filter or import an existing history with e.g. bogus timezone values.</source>
          <target state="translated">이것은 숫자 epoch 및 로컬 오프셋에 대한 온 전성 검사가 수행되지 않는다는 점을 제외하면 &lt;code&gt;raw&lt;/code&gt; 와 동일 합니다. 이는 가짜 시간대 값과 같은 기존 기록을 필터링하거나 가져 오려고 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d8eaa3e252f616f4794342341d2f4ec065a52c7" translate="yes" xml:space="preserve">
          <source>This is the standard email format as described by RFC 2822.</source>
          <target state="translated">RFC 2822에 설명 된 표준 전자 메일 형식입니다.</target>
        </trans-unit>
        <trans-unit id="b1825adadaae31865a7ba56f02eeaa58bb1a595e" translate="yes" xml:space="preserve">
          <source>This is the standard helper program to use with &lt;code&gt;git merge-index&lt;/code&gt; to resolve a merge after the trivial merge done with &lt;code&gt;git read-tree -m&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git read-tree -m&lt;/code&gt; 으로 사소한 병합 후 병합을 해결하기 위해 &lt;code&gt;git merge-index&lt;/code&gt; 와 함께 사용하는 표준 도우미 프로그램 입니다.</target>
        </trans-unit>
        <trans-unit id="f4605ef17a6ae238fb7ad1359ce2fc3809a170d2" translate="yes" xml:space="preserve">
          <source>This is the state of the index file and the working file after &lt;code&gt;git merge&lt;/code&gt; returns control back to you, leaving the conflicting merge for you to resolve. Notice that the path &lt;code&gt;hello&lt;/code&gt; is still unmerged, and what you see with &lt;code&gt;git diff&lt;/code&gt; at this point is differences since stage 2 (i.e. your version).</source>
          <target state="translated">이것은 &lt;code&gt;git merge&lt;/code&gt; 가 제어권을 다시 돌려 준 후 인덱스 파일과 작업 파일의 상태입니다 . &lt;code&gt;hello&lt;/code&gt; 라는 경로 는 아직 병합되지 않았으며이 시점에서 &lt;code&gt;git diff&lt;/code&gt; 로 보는 것은 2 단계 이후의 차이점 (예 : 버전)입니다.</target>
        </trans-unit>
        <trans-unit id="885013fc19184ff3f87757857452f6badc7e664c" translate="yes" xml:space="preserve">
          <source>This is to emulate &lt;code&gt;git fetch&lt;/code&gt; run on the &lt;code&gt;mothership&lt;/code&gt; using &lt;code&gt;git
push&lt;/code&gt; that is run in the opposite direction in order to integrate the work done on &lt;code&gt;satellite&lt;/code&gt;, and is often necessary when you can only make connection in one way (i.e. satellite can ssh into mothership but mothership cannot initiate connection to satellite because the latter is behind a firewall or does not run sshd).</source>
          <target state="translated">이것은 &lt;code&gt;satellite&lt;/code&gt; 에서 수행 된 작업을 통합하기 위해 반대 방향으로 실행되는 &lt;code&gt;git push&lt;/code&gt; 를 사용 하여 &lt;code&gt;mothership&lt;/code&gt; 에서 &lt;code&gt;git fetch&lt;/code&gt; run 을 에뮬레이트 하는 것이며 , 한 가지 방식으로 만 연결할 수있는 경우 (예 : 위성이 모선으로 ssh 수 있음) 그러나 후자는 방화벽 뒤에 있거나 sshd를 실행하지 않기 때문에 모선은 위성에 연결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a0fbffa526980249cc459b3697ae082d2fb16d12" translate="yes" xml:space="preserve">
          <source>This is to view the changes between two arbitrary &amp;lt;commit&amp;gt;.</source>
          <target state="translated">이것은 임의의 두 &amp;lt;commit&amp;gt; 사이의 변경 사항을 보는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2ccd3734f230a6bccf87e0841ef19acfd1763ec7" translate="yes" xml:space="preserve">
          <source>This is used if &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; does not resolve the correct &lt;code&gt;-kb&lt;/code&gt; mode to use. If true, all unresolved files are sent to the client in mode &lt;code&gt;-kb&lt;/code&gt;. This causes the client to treat them as binary files, which suppresses any newline munging it otherwise might do. Alternatively, if it is set to &quot;guess&quot;, then the contents of the file are examined to decide if it is binary, similar to &lt;code&gt;core.autocrlf&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; 이 올바른 &lt;code&gt;-kb&lt;/code&gt; 모드를 사용할 수없는 경우 에 사용됩니다. true 인 경우, 해결되지 않은 모든 파일이 &lt;code&gt;-kb&lt;/code&gt; 모드에서 클라이언트로 전송됩니다 . 이로 인해 클라이언트는이 파일을 이진 파일로 취급하므로 줄 바꿈이 발생하지 않게 할 수 있습니다. 또는 &quot;추측&quot;으로 설정된 경우 파일의 내용을 검사하여 &lt;code&gt;core.autocrlf&lt;/code&gt; 와 유사하게 이진 파일인지 판별 합니다.</target>
        </trans-unit>
        <trans-unit id="414b7e001678a67515e35206eca5b23ff617a9b6" translate="yes" xml:space="preserve">
          <source>This is used to avoid unnecessary false hits when &lt;code&gt;git diff-files&lt;/code&gt; is run after &lt;code&gt;git read-tree&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git read-tree&lt;/code&gt; 이후에 git &lt;code&gt;git diff-files&lt;/code&gt; 이 실행될 때 불필요한 오타를 피하기 위해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1756049aad8be96bbdbe029ae5b31f810c9534b0" translate="yes" xml:space="preserve">
          <source>This is used to imply --all-progress whenever progress display is activated. Unlike --all-progress this flag doesn&amp;rsquo;t actually force any progress display by itself.</source>
          <target state="translated">진행률 표시가 활성화 될 때마다 --all-progress를 암시하는 데 사용됩니다. --all-progress와 달리이 플래그는 실제로 진행률 표시를 강제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa389947911fb92b7cae5947eac62679e5095362" translate="yes" xml:space="preserve">
          <source>This is used to reorder the filepairs according to the user&amp;rsquo;s (or project&amp;rsquo;s) taste, and is controlled by the -O option to the &lt;code&gt;git diff-*&lt;/code&gt; commands.</source>
          <target state="translated">이는 사용자 (또는 프로젝트의 취향)에 따라 파일 쌍을 재정렬하는 데 사용되며 &lt;code&gt;git diff-*&lt;/code&gt; 명령 의 -O 옵션에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="e4698ff07eb1e8e63a5c87a4e409437aeb77e0b4" translate="yes" xml:space="preserve">
          <source>This is useful because it makes it easy to choose a good commit to test when you want to avoid to test some of them for some reason (they may not compile for example).</source>
          <target state="translated">어떤 이유로 테스트하지 않기를 원할 때 테스트하기 위해 좋은 커밋을 쉽게 선택할 수 있기 때문에 유용합니다 (예 : 컴파일되지 않을 수 있음).</target>
        </trans-unit>
        <trans-unit id="8b37ac2c46d9c49011957ba8051eb182f97c074f" translate="yes" xml:space="preserve">
          <source>This is useful if F and G were flawed in some way, or should not be part of topicA. Note that the argument to --onto and the &amp;lt;upstream&amp;gt; parameter can be any valid commit-ish.</source>
          <target state="translated">이는 F와 G에 어떤 방식으로 결함이 있거나 주제 A의 일부가 아니어야하는 경우에 유용합니다. --onto 및 &amp;lt;upstream&amp;gt; 매개 변수에 대한 인수는 유효한 commit-ish 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5add7a300e88f092e0ef1b21363222f3ece44ad7" translate="yes" xml:space="preserve">
          <source>This is useful if remote side is git:// server accessed over some tunnel.</source>
          <target state="translated">이것은 원격 쪽이 일부 터널을 통해 액세스되는 git : // 서버 인 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d562e00428aacff2db14167eb0ecbc7ee7ea6370" translate="yes" xml:space="preserve">
          <source>This is useful if the branch on which you ran &lt;code&gt;git stash push&lt;/code&gt; has changed enough that &lt;code&gt;git stash apply&lt;/code&gt; fails due to conflicts. Since the stash entry is applied on top of the commit that was HEAD at the time &lt;code&gt;git stash&lt;/code&gt; was run, it restores the originally stashed state with no conflicts.</source>
          <target state="translated">이것은 &lt;code&gt;git stash push&lt;/code&gt; 를 실행 한 브랜치 가 충돌로 인해 &lt;code&gt;git stash apply&lt;/code&gt; 가 실패 할 정도로 충분히 변경된 경우에 유용합니다 . &lt;code&gt;git stash&lt;/code&gt; 가 실행될 때 HEAD였던 커밋 위에 stash 항목이 적용 되므로 충돌없이 원래의 stashed 상태를 복원합니다.</target>
        </trans-unit>
        <trans-unit id="30fcffaf45041b08cc97af9d1fa76a9ba0b33fa3" translate="yes" xml:space="preserve">
          <source>This is useful if you want to begin your message in a discussion thread with comments and suggestions on the message you are responding to, and to conclude it with a patch submission, separating the discussion and the beginning of the proposed commit log message with a scissors line.</source>
          <target state="translated">이것은 응답중인 메시지에 대한 의견과 제안으로 토론 스레드에서 메시지를 시작하고 패치 제출로 토론을 마무리하고 토론과 제안 된 커밋 로그 메시지의 시작을 가위로 분리하려는 경우에 유용합니다. 선.</target>
        </trans-unit>
        <trans-unit id="f93051fa336df47ab5f519702120e3efac9cd277" translate="yes" xml:space="preserve">
          <source>This is useful on systems where lstat() calls are very slow, such as CIFS/Microsoft Windows.</source>
          <target state="translated">CIFS / Microsoft Windows와 같이 lstat () 호출이 매우 느린 시스템에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6b9439a13a0f6c5a19da94d77f92d4a1ee7e5be6" translate="yes" xml:space="preserve">
          <source>This is useful when cherry-picking more than one commits' effect to your index in a row.</source>
          <target state="translated">이것은 인덱스에서 하나 이상의 커밋 효과를 연속적으로 선택하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ccb566ca825959d19feaead9d9434de1315351a7" translate="yes" xml:space="preserve">
          <source>This is useful when reverting more than one commits' effect to your index in a row.</source>
          <target state="translated">이것은 하나 이상의 커밋 효과를 인덱스의 인덱스로 되돌릴 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a6b3b2938023c6383383af34a5efd6428edcf530" translate="yes" xml:space="preserve">
          <source>This is useful when topicB does not depend on topicA.</source>
          <target state="translated">topicB가 topicA에 의존하지 않는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="804a7dc8302db74d34102cb378738f0047ef1777" translate="yes" xml:space="preserve">
          <source>This is usually not what an end user wants to run directly. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; instead.</source>
          <target state="translated">이것은 일반적으로 최종 사용자가 직접 실행하려는 것이 아닙니다. 대신 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="81deedcd021f1608f9f91f70a15e2349e22a39d7" translate="yes" xml:space="preserve">
          <source>This is what &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; generates. Most headers and MIME formatting are ignored.</source>
          <target state="translated">이것이 &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]가&lt;/a&gt; 생성하는 것입니다. 대부분의 헤더와 MIME 형식은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ca6a5c0a1684e36bc50c3e68cfccb9e6ebf59a4b" translate="yes" xml:space="preserve">
          <source>This is what causes Git to track the remote&amp;rsquo;s branches; you may modify or delete these configuration options by editing &lt;code&gt;.git/config&lt;/code&gt; with a text editor. (See the &quot;CONFIGURATION FILE&quot; section of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.)</source>
          <target state="translated">이것이 Git이 리모콘의 분기를 추적하게하는 원인입니다. 텍스트 편집기로 &lt;code&gt;.git/config&lt;/code&gt; 를 편집하여 이러한 구성 옵션을 수정하거나 삭제할 수 있습니다 . (자세한 내용은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 &quot;CONFIGURATION FILE&quot;섹션 을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="e49010e0ec73f433e7f19c2db7cbfd7081066732" translate="yes" xml:space="preserve">
          <source>This is why it is a bad idea to just chose the next best unskipped bisection commit when the first one has been skipped.</source>
          <target state="translated">그렇기 때문에 첫 번째 건너 뛰기를 건너 뛰었을 때 다음으로 최고의 건너 뛰기 이분법 커밋을 선택하는 것이 나쁜 생각입니다.</target>
        </trans-unit>
        <trans-unit id="b49b41d6b66c63a0b41c3cd8eb53b02ecb1e28e6" translate="yes" xml:space="preserve">
          <source>This leaves a copy of &lt;code&gt;next&lt;/code&gt; temporarily in FETCH_HEAD, and updates the remote-tracking branch &lt;code&gt;origin/next&lt;/code&gt;. The same can be done by invoking fetch and merge:</source>
          <target state="translated">이렇게하면 FETCH_HEAD에 일시적 으로 &lt;code&gt;next&lt;/code&gt; 복사본이 남고 원격 추적 분기 &lt;code&gt;origin/next&lt;/code&gt; 를 업데이트합니다 . 가져 오기 및 병합을 호출하여 동일한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51722bee7db4c41cee14b92ba092db0dce132718" translate="yes" xml:space="preserve">
          <source>This leaves a copy of &lt;code&gt;next&lt;/code&gt; temporarily in FETCH_HEAD, but does not update any remote-tracking branches. Using remote-tracking branches, the same can be done by invoking fetch and merge:</source>
          <target state="translated">그러면 FETCH_HEAD 에 &lt;code&gt;next&lt;/code&gt; 복사본이 임시로 남지만 원격 추적 분기는 업데이트되지 않습니다. 원격 추적 분기를 사용하면 가져 오기 및 병합을 호출하여 동일한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d3c273456c213d2f0eef245650834ea18d26a16" translate="yes" xml:space="preserve">
          <source>This lets you choose one path out of a &lt;code&gt;status&lt;/code&gt; like selection. After choosing the path, it presents the diff between the index and the working tree file and asks you if you want to stage the change of each hunk. You can select one of the following options and type return:</source>
          <target state="translated">이를 통해 선택 과 같은 &lt;code&gt;status&lt;/code&gt; 하나의 경로를 선택할 수 있습니다 . 경로를 선택한 후 인덱스와 작업 트리 파일 사이의 차이점을 표시하고 각 덩어리의 변경을 스테이징 할 것인지 묻습니다. 다음 옵션 중 하나를 선택하고 return을 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="060b46ed6fd409fbf360157d2f3c13ff3dcd2220" translate="yes" xml:space="preserve">
          <source>This lets you quit without do cleaning.</source>
          <target state="translated">이렇게하면 청소하지 않고 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa41c7db3702739cc1b230bda0b83b675d7b2671" translate="yes" xml:space="preserve">
          <source>This lets you review what will be committed (i.e. between HEAD and index).</source>
          <target state="translated">이를 통해 커밋 할 내용 (예 : HEAD와 인덱스)을 검토 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca3fd0a1256c2900c49910f1d037599eb216d4ff" translate="yes" xml:space="preserve">
          <source>This list should contain the URI of gitweb&amp;rsquo;s standard stylesheet. The default URI of gitweb stylesheet can be set at build time using the &lt;code&gt;GITWEB_CSS&lt;/code&gt; makefile variable. Its default value is &lt;code&gt;static/gitweb.css&lt;/code&gt; (or &lt;code&gt;static/gitweb.min.css&lt;/code&gt; if the &lt;code&gt;CSSMIN&lt;/code&gt; variable is defined, i.e. if CSS minifier is used during build).</source>
          <target state="translated">이리스트는 gitweb 표준 스타일 시트의 URI를 포함해야합니다. gitweb 스타일 시트의 기본 URI는 &lt;code&gt;GITWEB_CSS&lt;/code&gt; makefile 변수를 사용하여 빌드시 설정할 수 있습니다 . 기본값은 &lt;code&gt;static/gitweb.css&lt;/code&gt; (또는 &lt;code&gt;CSSMIN&lt;/code&gt; 변수가 정의 된 경우, 즉 빌드 중에 CSS 축소 &lt;code&gt;static/gitweb.min.css&lt;/code&gt; 경우 static / gitweb.min.css )입니다.</target>
        </trans-unit>
        <trans-unit id="87db555786bcad0bd342abfeced795a76cdcb852" translate="yes" xml:space="preserve">
          <source>This lists the commits reachable from the previous version of the &lt;code&gt;master&lt;/code&gt; branch head. This syntax can be used with any Git command that accepts a commit, not just with &lt;code&gt;git log&lt;/code&gt;. Some other examples:</source>
          <target state="translated">이것은 이전 버전의 &lt;code&gt;master&lt;/code&gt; 브랜치 헤드 에서 도달 할 수있는 커밋을 나열합니다 . 이 구문은 &lt;code&gt;git log&lt;/code&gt; 뿐만 아니라 커밋을 수락하는 모든 Git 명령과 함께 사용할 수 있습니다 . 다른 예 :</target>
        </trans-unit>
        <trans-unit id="9d19ff56a7106ea2437dd5210773dc60fd2828eb" translate="yes" xml:space="preserve">
          <source>This looks up the &amp;lt;file&amp;gt;(s) in the index and, if there are any merge entries, passes the SHA-1 hash for those files as arguments 1, 2, 3 (empty argument if no file), and &amp;lt;file&amp;gt; as argument 4. File modes for the three files are passed as arguments 5, 6 and 7.</source>
          <target state="translated">인덱스에서 &amp;lt;파일&amp;gt;을 찾고 병합 항목이있는 경우 해당 파일의 SHA-1 해시를 인수 1, 2, 3 (파일이없는 경우 빈 인수) 및 &amp;lt;파일&amp;gt;로 전달합니다. 세 파일의 파일 모드는 인수 5, 6 및 7로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6790f45ac4b6ed7e77775e3a5dfba68fc876105d" translate="yes" xml:space="preserve">
          <source>This makes a commit that records the modification to &lt;code&gt;Makefile&lt;/code&gt;. The changes staged for &lt;code&gt;hello.c&lt;/code&gt; and &lt;code&gt;hello.h&lt;/code&gt; are not included in the resulting commit. However, their changes are not lost &amp;mdash; they are still staged and merely held back. After the above sequence, if you do:</source>
          <target state="translated">이렇게하면 수정 사항을 &lt;code&gt;Makefile&lt;/code&gt; 에 기록하는 커미트가 작성 됩니다. &lt;code&gt;hello.c&lt;/code&gt; 및 &lt;code&gt;hello.h&lt;/code&gt; 에 대해 준비된 변경 사항 은 결과 커밋에 포함되지 않습니다. 그러나 변경 사항이 손실되지는 않습니다. 여전히 단계적이며 보류됩니다. 위의 순서 후에 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c23316330a20f8d3e00d74e273bc6ee3d02efbd7" translate="yes" xml:space="preserve">
          <source>This makes a new branch called &lt;code&gt;other&lt;/code&gt; from &lt;code&gt;master~5..master&lt;/code&gt; (i.e. if &lt;code&gt;master&lt;/code&gt; has linear history, it will take the last 5 commits).</source>
          <target state="translated">이것은 &lt;code&gt;master~5..master&lt;/code&gt; 에서 &lt;code&gt;other&lt;/code&gt; 라는 새로운 브랜치를 만듭니다 (즉, &lt;code&gt;master&lt;/code&gt; 에 선형 히스토리가있는 경우 마지막 5 개의 커밋이 필요함 ).</target>
        </trans-unit>
        <trans-unit id="b0ade35fb815795f98a8b6354752858acd9e1cfa" translate="yes" xml:space="preserve">
          <source>This makes sure that only the key/value pair for kernel.org is replaced.</source>
          <target state="translated">이를 통해 kernel.org의 키 / 값 쌍만 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="2d726c732ca5f310160366fecc16a8d1ede4f94c" translate="yes" xml:space="preserve">
          <source>This manual describes the convention used throughout Git CLI.</source>
          <target state="translated">이 매뉴얼은 Git CLI 전체에서 사용되는 규칙을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="40982f6c18ca56554ec412b18ace4f012d6c51fa" translate="yes" xml:space="preserve">
          <source>This manual is designed to be readable by someone with basic UNIX command-line skills, but no previous knowledge of Git.</source>
          <target state="translated">이 매뉴얼은 기본 UNIX 명령 줄 기술을 가지고 있지만 Git에 대한 사전 지식이없는 사람이 읽을 수 있도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="1b4c4400f56ace6af78ca50c928fe7f5cfe13be6" translate="yes" xml:space="preserve">
          <source>This manual page describes only the most frequently used options.</source>
          <target state="translated">이 매뉴얼 페이지는 가장 자주 사용되는 옵션에 대해서만 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c74c8f67468f674a4bbb6cadbdb326520214aafb" translate="yes" xml:space="preserve">
          <source>This manual page describes only the most frequently used options. See &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; for a complete list.</source>
          <target state="translated">이 매뉴얼 페이지는 가장 자주 사용되는 옵션에 대해서만 설명합니다. 전체 목록 은 &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="78fbc8bf0be13ddc4f9bce27ee4dc19783022a2b" translate="yes" xml:space="preserve">
          <source>This means &quot;show everything that is reachable from either one, but exclude anything that is reachable from both of them&quot;.</source>
          <target state="translated">이것은 &quot;둘 중 하나에서 도달 할 수있는 모든 것을 표시하지만 둘 다에서 도달 할 수있는 것은 제외&quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9f4c07f14694007bf95dcdb96bbfc3991db01ef3" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;git reset &amp;lt;pathspec&amp;gt;&lt;/code&gt; is the opposite of &lt;code&gt;git add
&amp;lt;pathspec&amp;gt;&lt;/code&gt;. This command is equivalent to &lt;code&gt;git restore [--source=&amp;lt;tree-ish&amp;gt;] --staged &amp;lt;pathspec&amp;gt;...&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git reset &amp;lt;pathspec&amp;gt;&lt;/code&gt; 이 &lt;code&gt;git add &amp;lt;pathspec&amp;gt;&lt;/code&gt; 과 반대되는 것을 의미합니다 . 이 명령은 &lt;code&gt;git restore [--source=&amp;lt;tree-ish&amp;gt;] --staged &amp;lt;pathspec&amp;gt;...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="138908f8222de2b4daf75b57b97dc896b1845167" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;git reset -p&lt;/code&gt; is the opposite of &lt;code&gt;git add -p&lt;/code&gt;, i.e. you can use it to selectively reset hunks. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">즉, &lt;code&gt;git reset -p&lt;/code&gt; 는 &lt;code&gt;git add -p&lt;/code&gt; 와 반대입니다 . 즉,이를 사용하여 덩어리를 선택적으로 재설정 할 수 있습니다. &lt;code&gt;--patch&lt;/code&gt; 모드 작동 방법을 알아 보려면 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 의 &quot;대화식 모드&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c231d7cedbd657513f91f60869397c2bef2f37d" translate="yes" xml:space="preserve">
          <source>This means that it is often &quot;cheaper&quot; if QA people or end users can do it.</source>
          <target state="translated">이는 품질 보증 담당자 나 최종 사용자가 할 수 있다면 종종 &quot;더 저렴&quot;하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0ff1dc064f7e1f4d0872498ac05a21ade168adc9" translate="yes" xml:space="preserve">
          <source>This means that test suites are good to prevent some bugs from being committed and they are also quite good to tell you that you have some bugs. But they are not so good to tell you where some bugs have been introduced. To tell you that efficiently, git bisect is needed.</source>
          <target state="translated">즉, 테스트 스위트는 일부 버그가 커밋되는 것을 방지하고 버그가 있음을 알려주는 것도 좋습니다. 그러나 버그가 어디에서 발생했는지 알려주는 것은 좋지 않습니다. 효율적으로 말하면 git bisect가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="388b9571e5f1264e3be3a08ce2827efedebdef31" translate="yes" xml:space="preserve">
          <source>This means that the best bisection commits are the commits where the following function is maximum:</source>
          <target state="translated">이는 최상의 bisection 커밋이 다음 함수가 최대 인 커밋임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="597961da0012b9cd684792dccd1c7471e5687e9f" translate="yes" xml:space="preserve">
          <source>This means that the trimmed &amp;lt;token&amp;gt; and &amp;lt;value&amp;gt; will be separated by &lt;code&gt;': '&lt;/code&gt; (one colon followed by one space).</source>
          <target state="translated">이것은 잘린 &amp;lt;token&amp;gt;과 &amp;lt;value&amp;gt;가 &lt;code&gt;': '&lt;/code&gt; (한 콜론 뒤에 하나의 공백) 으로 분리됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="38ea5711a664516b71bd0eeea932fd8ac8d7c412" translate="yes" xml:space="preserve">
          <source>This means that we get rid of the uninteresting commits in the DAG.</source>
          <target state="translated">이것은 우리가 DAG에서 흥미없는 커밋을 제거한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2454a8b57cbe01726a67b284a671cd468ecfe3a7" translate="yes" xml:space="preserve">
          <source>This means that you can do</source>
          <target state="translated">이것은 당신이 할 수 있음을 의미</target>
        </trans-unit>
        <trans-unit id="4bfb7f09c9f4811c3630d40fb2caf5f3310e564e" translate="yes" xml:space="preserve">
          <source>This means that you can use &lt;code&gt;git checkout -p&lt;/code&gt; to selectively discard edits from your current working tree. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">이것은 &lt;code&gt;git checkout -p&lt;/code&gt; 를 사용 하여 현재 작업 트리에서 편집 내용을 선택적으로 버릴 수 있음을 의미합니다 . &lt;code&gt;--patch&lt;/code&gt; 모드 작동 방법을 알아 보려면 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 의 &quot;대화식 모드&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2db1fd51873ef2a0afca87fc61387f5a8891e2a5" translate="yes" xml:space="preserve">
          <source>This merges the changes from Bob&amp;rsquo;s &quot;master&quot; branch into Alice&amp;rsquo;s current branch. If Alice has made her own changes in the meantime, then she may need to manually fix any conflicts.</source>
          <target state="translated">이것은 Bob의 &quot;마스터&quot;브랜치에서 Alice의 현재 브랜치로 변경 사항을 병합합니다. Alice가 그 동안 자체적으로 변경 한 경우 충돌을 수동으로 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cff3569519105ed116111cf73b4d626e89a75fc2" translate="yes" xml:space="preserve">
          <source>This merges the file listing in the directory cache index with the actual working directory list, and shows different combinations of the two.</source>
          <target state="translated">그러면 디렉토리 캐시 색인의 파일 목록이 실제 작업 디렉토리 목록과 병합되고이 둘의 다른 조합이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e550f0e6cba8953c27a9638529775caa0627f8ed" translate="yes" xml:space="preserve">
          <source>This might not be what you expect, i.e. you want to prune remote &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;, but also explicitly fetch tags from it, so when you fetch from it you delete all your local tags, most of which may not have come from the &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; remote in the first place.</source>
          <target state="translated">이것은 예상 한 것이 아닐 수도 있습니다. 예를 들어, 원격 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 을 프룬하고 명시 적으로 태그를 페치하려고합니다. 페치 할 때 로컬 태그를 모두 삭제하면 대부분 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 에서 비롯되었을 수 있습니다. &amp;gt; 처음에 원격.</target>
        </trans-unit>
        <trans-unit id="c165a1bf0e23a30271149315bd9959512cec8cbc" translate="yes" xml:space="preserve">
          <source>This mode differs from the default in one point: always follow all parents of a merge, even if it is TREESAME to one of them. Even if more than one side of the merge has commits that are included, this does not imply that the merge itself is! In the example, we get</source>
          <target state="translated">이 모드는 한 가지 점에서 기본값과 다릅니다. 병합 중 하나 인 경우에도 항상 병합의 모든 부모를 따르십시오. 병합의 둘 이상의 측면에 포함 된 커밋이 있더라도 병합 자체가 있음을 의미하지는 않습니다! 이 예에서 우리는</target>
        </trans-unit>
        <trans-unit id="06118fd3f101fa40f7bcb707d4305013c9a74e7d" translate="yes" xml:space="preserve">
          <source>This mode has become the default in Git 2.0.</source>
          <target state="translated">이 모드는 Git 2.0에서 기본값이되었습니다.</target>
        </trans-unit>
        <trans-unit id="9c35450959e8c97cb733c60205966cdb68e529c7" translate="yes" xml:space="preserve">
          <source>This mode is designed for repositories with very large indexes, and aims at reducing the time it takes to repeatedly write these indexes.</source>
          <target state="translated">이 모드는 인덱스가 매우 큰 리포지토리 용으로 설계되었으며 이러한 인덱스를 반복적으로 작성하는 데 걸리는 시간을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="660380648a3de0733323135a33a60c0126cae6f8" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;export&lt;/code&gt; capability, instructing Git to dump the internal marks table to &amp;lt;file&amp;gt; when complete. For details, read up on &lt;code&gt;--export-marks=&amp;lt;file&amp;gt;&lt;/code&gt; in &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export[1]&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;export&lt;/code&gt; 기능을 수정하여 Git에게 내부 마크 테이블을 &amp;lt;file&amp;gt;에 덤프하도록 지시합니다. 자세한 내용 은 &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export [1]의 &lt;/a&gt; &lt;code&gt;--export-marks=&amp;lt;file&amp;gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="59a5d5693433000c28979c8002984ee295ddd735" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;export&lt;/code&gt; capability, instructing Git to load the marks specified in &amp;lt;file&amp;gt; before processing any input. For details, read up on &lt;code&gt;--import-marks=&amp;lt;file&amp;gt;&lt;/code&gt; in &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export[1]&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;export&lt;/code&gt; 기능을 수정하여 Git에게 입력을 처리하기 전에 &amp;lt;file&amp;gt;에 지정된 마크를로드하도록 지시합니다. 자세한 내용 은 &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export [1]&lt;/a&gt; 에서 &lt;code&gt;--import-marks=&amp;lt;file&amp;gt;&lt;/code&gt; 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="29cca50076d9ab0c1672949be9f5cf285333ce65" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;export&lt;/code&gt; capability, instructing Git to pass &lt;code&gt;--signed-tags=verbatim&lt;/code&gt; to &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export[1]&lt;/a&gt;. In the absence of this capability, Git will use &lt;code&gt;--signed-tags=warn-strip&lt;/code&gt;.</source>
          <target state="translated">이것은 Git에게 &lt;code&gt;--signed-tags=verbatim&lt;/code&gt; 을 &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export [1]&lt;/a&gt; 로 전달하도록 지시 하는 &lt;code&gt;export&lt;/code&gt; 기능을 수정합니다 . 이 기능이 없으면 Git은 &lt;code&gt;--signed-tags=warn-strip&lt;/code&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="1cd76e4b36f80f26235450d81c7340212de49a9e" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;import&lt;/code&gt; capability. The fast-import commands &lt;code&gt;cat-blob&lt;/code&gt; and &lt;code&gt;ls&lt;/code&gt; can be used by remote-helpers to retrieve information about blobs and trees that already exist in fast-import&amp;rsquo;s memory. This requires a channel from fast-import to the remote-helper. If it is advertised in addition to &quot;import&quot;, Git establishes a pipe from fast-import to the remote-helper&amp;rsquo;s stdin. It follows that Git and fast-import are both connected to the remote-helper&amp;rsquo;s stdin. Because Git can send multiple commands to the remote-helper it is required that helpers that use &lt;code&gt;bidi-import&lt;/code&gt; buffer all &lt;code&gt;import&lt;/code&gt; commands of a batch before sending data to fast-import. This is to prevent mixing commands and fast-import responses on the helper&amp;rsquo;s stdin.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 기능 이 수정되었습니다 . &lt;code&gt;cat-blob&lt;/code&gt; 및 &lt;code&gt;ls&lt;/code&gt; 빠른 가져 오기 명령 은 원격 도우미가 빠른 가져 오기의 메모리에 이미 존재하는 Blob 및 트리에 대한 정보를 검색하는 데 사용할 수 있습니다. 빠른 가져 오기에서 원격 헬퍼로의 채널이 필요합니다. &quot;가져 오기&quot;와 함께 광고되면 Git은 빠른 가져 오기에서 원격 헬퍼의 stdin으로 파이프를 설정합니다. Git과 fast-import는 모두 원격 헬퍼의 stdin에 연결되어 있습니다. Git은 원격 도우미에 여러 명령을 보낼 수 있기 때문에 &lt;code&gt;bidi-import&lt;/code&gt; 버퍼 를 사용하는 도우미는 모두 &lt;code&gt;import&lt;/code&gt; 오기 가 필요합니다빠른 가져 오기로 데이터를 보내기 전에 배치 명령. 이것은 헬퍼의 stdin에서 믹싱 명령과 빠른 가져 오기 응답을 방지하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="18b230f7b58b67f5f52143b1696b5514cecb3bd1" translate="yes" xml:space="preserve">
          <source>This operation is safe even if Alice has uncommitted local changes. The range notation &quot;HEAD..FETCH_HEAD&quot; means &quot;show everything that is reachable from the FETCH_HEAD but exclude anything that is reachable from HEAD&quot;. Alice already knows everything that leads to her current state (HEAD), and reviews what Bob has in his state (FETCH_HEAD) that she has not seen with this command.</source>
          <target state="translated">Alice가 커밋되지 않은 로컬 변경 사항을 가지고 있어도이 작업은 안전합니다. 범위 표기법 &quot;HEAD..FETCH_HEAD&quot;는 &quot;FETCH_HEAD에서 도달 할 수 있지만 HEAD에서 도달 할 수있는 것은 제외&quot;를 의미합니다. Alice는 현재 상태 (HEAD)로 이어지는 모든 것을 이미 알고 있으며 Bob이이 명령으로 보지 못한 상태 (FETCH_HEAD)에있는 것을 검토합니다.</target>
        </trans-unit>
        <trans-unit id="4d6058894e90e81912f089323abaddf6ff7286d2" translate="yes" xml:space="preserve">
          <source>This option affects options that expect path name like &lt;code&gt;--git-dir&lt;/code&gt; and &lt;code&gt;--work-tree&lt;/code&gt; in that their interpretations of the path names would be made relative to the working directory caused by the &lt;code&gt;-C&lt;/code&gt; option. For example the following invocations are equivalent:</source>
          <target state="translated">이 옵션은 경로 이름 에 대한 해석이 &lt;code&gt;-C&lt;/code&gt; 옵션 에 의해 발생하는 작업 디렉토리를 기준으로 이루어 &lt;code&gt;--git-dir&lt;/code&gt; 및 &lt;code&gt;--work-tree&lt;/code&gt; 와 같은 경로 이름이 필요한 옵션에 영향을줍니다 . 예를 들어 다음 호출은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="2b42f3dc9742d00737d912066dfd2008f4af0874" translate="yes" xml:space="preserve">
          <source>This option allows you to say that you expect the history you are updating is what you rebased and want to replace. If the remote ref still points at the commit you specified, you can be sure that no other people did anything to the ref. It is like taking a &quot;lease&quot; on the ref without explicitly locking it, and the remote ref is updated only if the &quot;lease&quot; is still valid.</source>
          <target state="translated">이 옵션을 사용하면 업데이트중인 기록이 다시 기반으로하고 교체하려는 것으로 예상 할 수 있습니다. 원격 심판이 여전히 지정한 커밋을 가리키는 경우 다른 사람이 심판에게 아무것도하지 않았 음을 확신 할 수 있습니다. 그것은 명시 적으로 그것을 잠그지 않고 심판에 &quot;임대&quot;를 취하는 것과 같으며, 원격 심판은 &quot;임대&quot;가 여전히 유효한 경우에만 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="a3080455c3c310acd65dd25e9f3c439906791e33" translate="yes" xml:space="preserve">
          <source>This option bypasses the pre-commit and commit-msg hooks. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 사전 커미트 및 commit-msg 후크를 무시합니다. &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae0cb95b3299088da58c88ea10fd24e68d20bac1" translate="yes" xml:space="preserve">
          <source>This option bypasses the pre-merge and commit-msg hooks. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 pre-merge 및 commit-msg 후크를 무시합니다. &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22c10b3b137f37c4d219034c9b73126392cd066c" translate="yes" xml:space="preserve">
          <source>This option bypasses the pre-rebase hook. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 사전 재 연결 후크를 무시합니다. &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e7eb09891c6b3b929ffed676724fa916ce9b73e" translate="yes" xml:space="preserve">
          <source>This option can be either set to a boolean value or to &lt;code&gt;on-demand&lt;/code&gt;. Setting it to a boolean changes the behavior of fetch and pull to unconditionally recurse into submodules when set to true or to not recurse at all when set to false. When set to &lt;code&gt;on-demand&lt;/code&gt; (the default value), fetch and pull will only recurse into a populated submodule when its superproject retrieves a commit that updates the submodule&amp;rsquo;s reference.</source>
          <target state="translated">이 옵션은 부울 값 또는 &lt;code&gt;on-demand&lt;/code&gt; 설정할 수 있습니다 . 이를 부울로 설정하면 페치 및 풀 동작이 변경되어 true로 설정 될 때 서브 모듈로 무조건 재귀로 돌아가거나 false로 설정 될 때 전혀 재귀하지 않습니다. 시에 설정 &lt;code&gt;on-demand&lt;/code&gt; (기본값), 가져 오기 및 풀은 같이 Recurse 채워진 서브 모듈로의 superproject가 검색 할 때이 서브 모듈의 참조가 갱신 사항을 확정합니다.</target>
        </trans-unit>
        <trans-unit id="5d7a21f2665910c78fd7ff132552ce53899e84c0" translate="yes" xml:space="preserve">
          <source>This option can be used along with &lt;code&gt;--bisect-vars&lt;/code&gt;, in this case, after all the sorted commit objects, there will be the same text as if &lt;code&gt;--bisect-vars&lt;/code&gt; had been used alone.</source>
          <target state="translated">이 옵션은 &lt;code&gt;--bisect-vars&lt;/code&gt; 와 함께 사용할 수 있습니다 .이 경우 정렬 된 모든 커밋 객체 후에 &lt;code&gt;--bisect-vars&lt;/code&gt; 가 단독으로 사용 된 것과 동일한 텍스트가 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="93ff5c11faab29c493dcd0eb330b2a514a09e43b" translate="yes" xml:space="preserve">
          <source>This option can be used several times to provide several detection regexes.</source>
          <target state="translated">이 옵션은 여러 번 탐지 정규식을 제공하기 위해 여러 번 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9be17765d99ef763e2665079651c5e7b4e1ceec" translate="yes" xml:space="preserve">
          <source>This option can be used to control recursive fetching of this submodule. If this option is also present in the submodules entry in .git/config of the superproject, the setting there will override the one found in .gitmodules. Both settings can be overridden on the command line by using the &quot;--[no-]recurse-submodules&quot; option to &quot;git fetch&quot; and &quot;git pull&quot;.</source>
          <target state="translated">이 옵션은이 서브 모듈의 재귀 페치를 제어하는 ​​데 사용할 수 있습니다. 이 옵션이 수퍼 프로젝트의 .git / config에있는 서브 모듈 항목에도있는 경우, 설정은 .gitmodules에있는 설정보다 우선합니다. 명령 행에서 &quot;-[no-] recurse-submodules&quot;옵션을 사용하여 &quot;git fetch&quot;및 &quot;git pull&quot;을 사용하여 두 설정을 모두 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4813ba4c4b012e94932c2c7e77e5d37eb750ee7d" translate="yes" xml:space="preserve">
          <source>This option can be used to control recursive fetching of this submodule. It can be overridden by using the --[no-]recurse-submodules command-line option to &quot;git fetch&quot; and &quot;git pull&quot;. This setting will override that from in the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file.</source>
          <target state="translated">이 옵션은이 서브 모듈의 재귀 페치를 제어하는 ​​데 사용할 수 있습니다. -[no-] recurse-submodules 명령 줄 옵션을 사용하여 &quot;git fetch&quot;및 &quot;git pull&quot;을 재정의 할 수 있습니다. 이 설정은 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 파일의 설정을 무시 합니다.</target>
        </trans-unit>
        <trans-unit id="dc1c2b92ebab0226490f8de8ccd94e6df6f7955b" translate="yes" xml:space="preserve">
          <source>This option can be used to separate command-line options from the list of files, (useful when filenames might be mistaken for command-line options).</source>
          <target state="translated">이 옵션을 사용하면 파일 목록과 명령 줄 옵션을 구분할 수 있습니다 (파일 이름이 명령 줄 옵션으로 잘못 알려진 경우에 유용합니다).</target>
        </trans-unit>
        <trans-unit id="792e2c6acea003d2f54070521de0f6b1fb530a29" translate="yes" xml:space="preserve">
          <source>This option can be used to specify a shell command that will be called to automatically add or modify a trailer with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">이 옵션은 지정된 &amp;lt;토큰&amp;gt;으로 트레일러를 자동으로 추가하거나 수정하기 위해 호출 될 쉘 명령을 지정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3870831de784b5f9a3b27254aee6ab6f7a036b72" translate="yes" xml:space="preserve">
          <source>This option can only be used for one-shot imports as &lt;code&gt;git svn&lt;/code&gt; will not be able to fetch again without metadata. Additionally, if you lose your &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; files, &lt;code&gt;git svn&lt;/code&gt; will not be able to rebuild them.</source>
          <target state="translated">&lt;code&gt;git svn&lt;/code&gt; 은 메타 데이터없이 다시 가져올 수 없으므로이 옵션은 원샷 가져 오기에만 사용할 수 있습니다 . 또한 &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; 파일 을 잃어 버리면 &lt;code&gt;git svn&lt;/code&gt; 에서 파일 을 다시 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7745929fdc4d071dfa2f069450065a35fb03a357" translate="yes" xml:space="preserve">
          <source>This option can only be used together with --dry-run. By using this option the user can check if any of the given files would be ignored, no matter if they are already present in the work tree or not.</source>
          <target state="translated">이 옵션은 --dry-run과 함께 만 사용할 수 있습니다. 이 옵션을 사용하면 사용자는 파일이 이미 작업 트리에 있는지 여부에 관계없이 주어진 파일이 무시되는지 여부를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cd2090b6cd931e9fb6990b800f11805da77a460" translate="yes" xml:space="preserve">
          <source>This option cannot (currently) be used unless &lt;code&gt;--batch&lt;/code&gt; or &lt;code&gt;--batch-check&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;--batch&lt;/code&gt; 또는 &lt;code&gt;--batch-check&lt;/code&gt; 를 사용하지 않으면이 옵션을 현재 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0bf834f696ae0c2ea43d0e8666eab0cbfdcf28f1" translate="yes" xml:space="preserve">
          <source>This option cannot be used with --stdin.</source>
          <target state="translated">이 옵션은 --stdin과 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="882762ef26e2279478bc78603a1e7faf56dec8c3" translate="yes" xml:space="preserve">
          <source>This option controls if and under what conditions new commits of populated submodules should be fetched too. It can be used as a boolean option to completely disable recursion when set to &lt;code&gt;no&lt;/code&gt; or to unconditionally recurse into all populated submodules when set to &lt;code&gt;yes&lt;/code&gt;, which is the default when this option is used without any value. Use &lt;code&gt;on-demand&lt;/code&gt; to only recurse into a populated submodule when the superproject retrieves a commit that updates the submodule&amp;rsquo;s reference to a commit that isn&amp;rsquo;t already in the local submodule clone.</source>
          <target state="translated">이 옵션은 채워진 하위 모듈의 새 커밋도 가져와야하는 조건과 조건을 제어합니다. &lt;code&gt;no&lt;/code&gt; 로 설정되면 재귀를 완전히 비활성화 하거나 &lt;code&gt;yes&lt;/code&gt; 로 설정하면 채워진 모든 하위 모듈에 무조건 재귀를 수행하기 위해 부울 옵션으로 사용할 수 있습니다. 이 옵션은 값없이 사용되는 경우의 기본값입니다. 수퍼 프로젝트가 서브 모듈의 참조를 이미 로컬 서브 모듈 클론에없는 커밋으로 업데이트하는 커밋을 검색 할 때 &lt;code&gt;on-demand&lt;/code&gt; 서브 모듈로만 재귀를 보내려면 온 디맨드 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="402f84a0bd330441925cd57436b80c9379eb3ea0" translate="yes" xml:space="preserve">
          <source>This option controls if and under what conditions new commits of populated submodules should be fetched too. It can be used as a boolean option to completely disable recursion when set to &lt;code&gt;no&lt;/code&gt; or to unconditionally recurse into all populated submodules when set to &lt;code&gt;yes&lt;/code&gt;, which is the default when this option is used without any value. Use &lt;code&gt;on-demand&lt;/code&gt; to only recurse into a populated submodule when the superproject retrieves a commit that updates the submodule&amp;rsquo;s reference to a commit that isn&amp;rsquo;t already in the local submodule clone. By default, &lt;code&gt;on-demand&lt;/code&gt; is used, unless &lt;code&gt;fetch.recurseSubmodules&lt;/code&gt; is set (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">이 옵션은 채워진 하위 모듈의 새 커밋도 가져와야하는지 여부와 조건을 제어합니다. &lt;code&gt;no&lt;/code&gt; 로 설정하면 재귀를 완전히 비활성화 하거나 ,이 옵션이 값없이 사용되는 경우 기본값 인 &lt;code&gt;yes&lt;/code&gt; 로 설정하면 채워진 모든 하위 모듈로 무조건 재귀 하는 부울 옵션으로 사용할 수 있습니다 . 수퍼 프로젝트가 로컬 서브 모듈 복제본에 아직없는 커밋에 대한 서브 모듈의 참조를 업데이트하는 커밋을 검색 할 때만 &lt;code&gt;on-demand&lt;/code&gt; 을 사용 하여 채워진 서브 모듈로 재귀합니다. &lt;code&gt;fetch.recurseSubmodules&lt;/code&gt; 가 설정되어 있지 않으면 기본적으로 &lt;code&gt;on-demand&lt;/code&gt; 가 사용 됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="69bffdffaf64305a520ea61fd7a4110a4c5bf981" translate="yes" xml:space="preserve">
          <source>This option controls if new commits of all populated submodules should be fetched and updated, too (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;).</source>
          <target state="translated">이 옵션은 채워진 모든 하위 모듈의 새 커밋을 가져 와서 업데이트할지 여부를 제어합니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 및 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8666b4e7aa19effada757acd8dc6a366796aecc5" translate="yes" xml:space="preserve">
          <source>This option controls if new commits of populated submodules should be fetched, and if the working trees of active submodules should be updated, too (see &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;, &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;).</source>
          <target state="translated">이 옵션은 채워진 하위 모듈의 새 커밋을 가져와야하는지, 활성 하위 모듈의 작업 트리도 업데이트해야하는지 여부를 제어합니다 ( &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; , &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 및 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="99e48667fde8ec2632838629a22c3bc7308b3012" translate="yes" xml:space="preserve">
          <source>This option controls whether &lt;code&gt;git fetch&lt;/code&gt; (and the underlying fetch in &lt;code&gt;git pull&lt;/code&gt;) will recursively fetch into populated submodules. This option can be set either to a boolean value or to &lt;code&gt;on-demand&lt;/code&gt;. Setting it to a boolean changes the behavior of fetch and pull to recurse unconditionally into submodules when set to true or to not recurse at all when set to false. When set to &lt;code&gt;on-demand&lt;/code&gt;, fetch and pull will only recurse into a populated submodule when its superproject retrieves a commit that updates the submodule&amp;rsquo;s reference. Defaults to &lt;code&gt;on-demand&lt;/code&gt;, or to the value of &lt;code&gt;submodule.recurse&lt;/code&gt; if set.</source>
          <target state="translated">이 옵션은 &lt;code&gt;git fetch&lt;/code&gt; (및 &lt;code&gt;git pull&lt;/code&gt; 의 기본 가져 오기 )가 채워진 하위 모듈로 재귀 적으로 가져올 지 여부를 제어합니다 . 이 옵션은 부울 값 또는 &lt;code&gt;on-demand&lt;/code&gt; 로 설정할 수 있습니다 . 부울로 설정하면 fetch 및 pull의 동작이 true로 설정되면 무조건 하위 모듈로 재귀하거나 false로 설정하면 전혀 재귀하지 않습니다. &lt;code&gt;on-demand&lt;/code&gt; 로 설정되면 수퍼 프로젝트가 하위 모듈의 참조를 업데이트하는 커밋을 검색 할 때만 채워진 하위 모듈로 가져 오기 및 가져 오기가 반복됩니다. 기본값은 &lt;code&gt;on-demand&lt;/code&gt; 또는 설정된 경우 &lt;code&gt;submodule.recurse&lt;/code&gt; 값입니다 .</target>
        </trans-unit>
        <trans-unit id="30828ff428cc76245c5c17e5cbd61f4d3413d1c5" translate="yes" xml:space="preserve">
          <source>This option determines how the commit message will be cleaned up before being passed on to the commit machinery. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more details. In particular, if the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is given a value of &lt;code&gt;scissors&lt;/code&gt;, scissors will be appended to &lt;code&gt;MERGE_MSG&lt;/code&gt; before being passed on in the case of a conflict.</source>
          <target state="translated">이 옵션은 커미트 기계로 전달되기 전에 커미트 메시지를 정리하는 방법을 결정합니다. 자세한 내용은 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 을 참조하십시오. 특히 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 에 &lt;code&gt;scissors&lt;/code&gt; 값을 지정 하면 충돌시 가위가 전달되기 전에 &lt;code&gt;MERGE_MSG&lt;/code&gt; 에 가위가 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="286a93d0042817a6190102b1bfcb5df866579bac" translate="yes" xml:space="preserve">
          <source>This option determines how the merge message will be cleaned up before committing. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more details. In addition, if the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is given a value of &lt;code&gt;scissors&lt;/code&gt;, scissors will be appended to &lt;code&gt;MERGE_MSG&lt;/code&gt; before being passed on to the commit machinery in the case of a merge conflict.</source>
          <target state="translated">이 옵션은 커밋하기 전에 병합 메시지를 정리하는 방법을 결정합니다. 자세한 내용은 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 을 참조하십시오. 또한 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 값에 &lt;code&gt;scissors&lt;/code&gt; 가 지정 되면 병합 충돌시 커밋 기계로 전달되기 전에 가위가 &lt;code&gt;MERGE_MSG&lt;/code&gt; 에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="4d1960d5d8472d2a194e5ec10acd8959326f748a" translate="yes" xml:space="preserve">
          <source>This option determines how the supplied commit message should be cleaned up before committing. The &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; can be &lt;code&gt;strip&lt;/code&gt;, &lt;code&gt;whitespace&lt;/code&gt;, &lt;code&gt;verbatim&lt;/code&gt;, &lt;code&gt;scissors&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 커밋하기 전에 제공된 커밋 메시지를 정리하는 방법을 결정합니다. &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 가 될 수 &lt;code&gt;strip&lt;/code&gt; , &lt;code&gt;whitespace&lt;/code&gt; , &lt;code&gt;verbatim&lt;/code&gt; , &lt;code&gt;scissors&lt;/code&gt; 또는 &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5dab8a93409f72b36d8b46ab64625d688725721" translate="yes" xml:space="preserve">
          <source>This option does not (currently) work correctly when an object in the index is specified (e.g. &lt;code&gt;:link&lt;/code&gt; instead of &lt;code&gt;HEAD:link&lt;/code&gt;) rather than one in the tree.</source>
          <target state="translated">이 옵션은 인덱스의 객체 가 트리에서 하나가 아닌 (예 &lt;code&gt;:link&lt;/code&gt; &lt;code&gt;HEAD:link&lt;/code&gt; 대신 : link ) 지정된 경우 (현재) 올바르게 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d9ea124fbd7a15594b4c6836d821b0c2d1f565c3" translate="yes" xml:space="preserve">
          <source>This option forces conflicting hunks to be auto-resolved cleanly by favoring &lt;code&gt;our&lt;/code&gt; version. Changes from the other tree that do not conflict with our side are reflected in the merge result. For a binary file, the entire contents are taken from our side.</source>
          <target state="translated">심술쟁이 충돌이 옵션의 힘은 자동 해결 선호에 의해 깨끗하게 할 수 &lt;code&gt;our&lt;/code&gt; 버전. 우리 측과 충돌하지 않는 다른 트리의 변경 사항은 병합 결과에 반영됩니다. 바이너리 파일의 경우 전체 내용이 우리 측에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="03e43ead906b5a3ebd0febb15138c0f0fef70180" translate="yes" xml:space="preserve">
          <source>This option identifies the file status with the following tags (followed by a space) at the start of each line:</source>
          <target state="translated">이 옵션은 각 줄의 시작 부분에 다음 태그 (공백이 옴)로 파일 상태를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="11f1817b2bcb9580d82cb7eff477a970ee3352b6" translate="yes" xml:space="preserve">
          <source>This option is NOT recommended as it makes it difficult to track down old references to SVN revision numbers in existing documentation, bug reports, and archives. If you plan to eventually migrate from SVN to Git and are certain about dropping SVN history, consider &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt; instead. filter-repo also allows reformatting of metadata for ease-of-reading and rewriting authorship info for non-&quot;svn.authorsFile&quot; users.</source>
          <target state="translated">이 옵션은 기존 문서, 버그 보고서 및 아카이브에서 SVN 개정 번호에 대한 이전 참조를 추적하기 어렵 기 때문에 권장되지 않습니다. SVN에서 Git으로 마이그레이션하고 SVN 히스토리 삭제가 확실하다면 &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt; 를 고려하십시오 . filter-repo를 사용하면 &quot;svn.authorsFile&quot;이 아닌 사용자의 저작 정보를 쉽게 읽고 다시 쓸 수 있도록 메타 데이터를 다시 포맷 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78790ec840bc0471b6e620b0edc9dccd8cb32215" translate="yes" xml:space="preserve">
          <source>This option is a more advanced form of &lt;code&gt;subtree&lt;/code&gt; strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match.</source>
          <target state="translated">이 옵션은보다 발전된 형태의 &lt;code&gt;subtree&lt;/code&gt; 전략으로, 병합시 두 트리를 서로 일치시키기 위해 전략을 전환해야합니다. 대신 지정된 경로에 접두사를 두거나 처음부터 제거하여 두 나무의 모양을 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="7e1a0662099548eacf19f027d973ae52cc900bb4" translate="yes" xml:space="preserve">
          <source>This option is deprecated in favour of &lt;code&gt;git stash push&lt;/code&gt;. It differs from &quot;stash push&quot; in that it cannot take pathspec. Instead, all non-option arguments are concatenated to form the stash message.</source>
          <target state="translated">이 옵션은 &lt;code&gt;git stash push&lt;/code&gt; 대신 더 이상 사용되지 않습니다 . pathspec을 사용할 수 없다는 점에서 &quot;stash push&quot;와 다릅니다. 대신 옵션이 아닌 모든 인수가 연결되어 숨김 메시지를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="4caf0764823caa06aa3cb192d447e797c84f9905" translate="yes" xml:space="preserve">
          <source>This option is deprecated in favour of &lt;code&gt;git stash push&lt;/code&gt;. It differs from &quot;stash push&quot; in that it cannot take pathspecs. Instead, all non-option arguments are concatenated to form the stash message.</source>
          <target state="translated">이 옵션은 &lt;code&gt;git stash push&lt;/code&gt; 대신 사용되지 않습니다 . 경로 스펙을 사용할 수 없다는 점에서 &quot;스 태쉬 푸시&quot;와 다릅니다. 대신 옵션이 아닌 모든 인수가 연결되어 숨김 메시지를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="c02fef4ae69460732c7c3bd405bb6c17f43ad119" translate="yes" xml:space="preserve">
          <source>This option is equivalent to the &amp;lt;repository&amp;gt; argument. If both are specified, the command-line argument takes precedence.</source>
          <target state="translated">이 옵션은 &amp;lt;repository&amp;gt; 인수와 동일합니다. 둘 다 지정되면 명령 줄 인수가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="b7fdcf9707bc99b530bc435f0d474fdd1738b42d" translate="yes" xml:space="preserve">
          <source>This option is implicitly supplied if any other list-like option such as &lt;code&gt;--contains&lt;/code&gt; is provided. See the documentation for each of those options for details.</source>
          <target state="translated">&lt;code&gt;--contains&lt;/code&gt; 와 같은 다른 목록과 같은 옵션이 제공되면이 옵션이 내재적으로 제공 됩니다. 자세한 내용은 해당 옵션 각각에 대한 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="710c94d6943c052c3ce9d72b355d1824bacce0cd" translate="yes" xml:space="preserve">
          <source>This option is only applicable in non-verbose mode.</source>
          <target state="translated">이 옵션은 상세하지 않은 모드에서만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4cc49fd28601407189cb758fe5a41d5aaf8777ac" translate="yes" xml:space="preserve">
          <source>This option is only applicable when listing tags without annotation lines.</source>
          <target state="translated">이 옵션은 주석 행이없는 태그를 나열 할 때만 적용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ac28aa5e8f93911465d1aaa74ae4db50de2f286b" translate="yes" xml:space="preserve">
          <source>This option is only relevant if we are tracking branches (using one of the repository layout options --trunk, --tags, --branches, --stdlayout). For each tracked branch, try to find out where its revision was copied from, and set a suitable parent in the first Git commit for the branch. This is especially helpful when we&amp;rsquo;re tracking a directory that has been moved around within the repository. If this feature is disabled, the branches created by &lt;code&gt;git svn&lt;/code&gt; will all be linear and not share any history, meaning that there will be no information on where branches were branched off or merged. However, following long/convoluted histories can take a long time, so disabling this feature may speed up the cloning process. This feature is enabled by default, use --no-follow-parent to disable it.</source>
          <target state="translated">이 옵션은 저장소 레이아웃 옵션 --trunk, --tags, --branches, --stdlayout 중 하나를 사용하여 분기를 추적하는 경우에만 관련이 있습니다. 추적 된 각 브랜치에 대해 해당 리비전이 어디에서 복사되었는지 확인하고 브랜치의 첫 번째 Git 커밋에서 적합한 부모를 설정하십시오. 이는 저장소 내에서 이동 한 디렉토리를 추적 할 때 특히 유용합니다. 이 기능이 비활성화되면 &lt;code&gt;git svn&lt;/code&gt; 에 의해 생성 된 분기 는 모두 선형이며 기록을 공유하지 않으므로 분기가 분기되거나 병합 된 위치에 대한 정보가 없습니다. 그러나 길거나 복잡한 기록을 따르면 시간이 오래 걸릴 수 있으므로이 기능을 비활성화하면 복제 프로세스 속도가 빨라질 수 있습니다. 이 기능은 기본적으로 활성화되어 있습니다. --no-follow-parent를 사용하여 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="e12fdc170000781ad1c58dbca132db57e3472f94" translate="yes" xml:space="preserve">
          <source>This option is only used by Mac OS implementation of Git. When core.precomposeUnicode=true, Git reverts the unicode decomposition of filenames done by Mac OS. This is useful when sharing a repository between Mac OS and Linux or Windows. (Git for Windows 1.7.10 or higher is needed, or Git under cygwin 1.7). When false, file names are handled fully transparent by Git, which is backward compatible with older versions of Git.</source>
          <target state="translated">이 옵션은 Git의 Mac OS 구현에서만 사용됩니다. core.precomposeUnicode = true 인 경우 Git은 Mac OS에서 수행 한 파일 이름의 유니 코드 분해를 되돌립니다. 이것은 Mac OS와 Linux 또는 Windows간에 저장소를 공유 할 때 유용합니다. (Windows 1.7.10 이상의 Git 또는 cygwin 1.7의 Git이 필요합니다). False 인 경우 파일 이름은 Git에서 완전히 투명하게 처리되며 이전 버전의 Git과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="f6656985205e20f496a0b3074744f80ac096af4d" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;branch&lt;/code&gt;, &lt;code&gt;drop&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;show&lt;/code&gt; commands.</source>
          <target state="translated">이 옵션은 &lt;code&gt;apply&lt;/code&gt; , &lt;code&gt;branch&lt;/code&gt; , &lt;code&gt;drop&lt;/code&gt; , &lt;code&gt;pop&lt;/code&gt; , &lt;code&gt;show&lt;/code&gt; 명령 에만 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="ec6b30f54355307a9689dd1f0d561ef40fa56b3b" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;apply&lt;/code&gt;, &lt;code&gt;drop&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;save&lt;/code&gt;, &lt;code&gt;store&lt;/code&gt; commands.</source>
          <target state="translated">이 옵션은 &lt;code&gt;apply&lt;/code&gt; , &lt;code&gt;drop&lt;/code&gt; , &lt;code&gt;pop&lt;/code&gt; , &lt;code&gt;push&lt;/code&gt; , &lt;code&gt;save&lt;/code&gt; , &lt;code&gt;store&lt;/code&gt; 명령 에만 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="ca1fe023113c04188594b141d1e29c7346f8a146" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;pop&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; commands.</source>
          <target state="translated">이 옵션은 &lt;code&gt;pop&lt;/code&gt; 및 &lt;code&gt;apply&lt;/code&gt; 명령 에만 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="14a31933c42436b9e91daec147e769ddb8e06d57" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;save&lt;/code&gt; commands.</source>
          <target state="translated">이 옵션은 &lt;code&gt;push&lt;/code&gt; 및 &lt;code&gt;save&lt;/code&gt; 명령 에만 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="1938ed399d7f045d62945a278113dd2db5e4506d" translate="yes" xml:space="preserve">
          <source>This option is only valid for &lt;code&gt;push&lt;/code&gt; command.</source>
          <target state="translated">이 옵션은 &lt;code&gt;push&lt;/code&gt; 명령 에만 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="488a5b3855b8742f267f0b39339ad03e677bc10e" translate="yes" xml:space="preserve">
          <source>This option is only valid for add and update commands. Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.</source>
          <target state="translated">이 옵션은 추가 및 업데이트 명령에만 유효합니다. -q를 지정하지 않으면 표준 오류 스트림이 터미널에 연결될 때 기본적으로 진행 상태가보고됩니다. 이 플래그는 표준 오류 스트림이 터미널로 보내지지 않더라도 진행 상태를 강제합니다.</target>
        </trans-unit>
        <trans-unit id="564be2665790d0ee7a744865d472382d1cf20497" translate="yes" xml:space="preserve">
          <source>This option is only valid for add and update commands. These commands sometimes need to clone a remote repository. In this case, this option will be passed to the &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; command.</source>
          <target state="translated">이 옵션은 추가 및 업데이트 명령에만 유효합니다. 이 명령은 때때로 원격 저장소를 복제해야합니다. 이 경우이 옵션은 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 명령 으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="1175e1719609394666bffaa81ec16b8052e4a6b8" translate="yes" xml:space="preserve">
          <source>This option is only valid for add, deinit and update commands. When running add, allow adding an otherwise ignored submodule path. When running deinit the submodule working trees will be removed even if they contain local changes. When running update (only effective with the checkout procedure), throw away local changes in submodules when switching to a different commit; and always run a checkout operation in the submodule, even if the commit listed in the index of the containing repository matches the commit checked out in the submodule.</source>
          <target state="translated">이 옵션은 add, deinit 및 update 명령에만 유효합니다. add를 실행할 때 다르게 무시되는 서브 모듈 경로를 추가하십시오. deinit를 실행하면 서브 모듈 작업 트리가 로컬 변경 사항을 포함하더라도 제거됩니다. 업데이트를 실행할 때 (체크 아웃 절차에서만 유효) 다른 커밋으로 전환 할 때 하위 모듈에서 로컬 변경 사항을 버립니다. 포함 저장소의 색인에 나열된 커밋이 서브 모듈에서 체크 아웃 된 커밋과 일치하더라도 항상 서브 모듈에서 체크 아웃 조작을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="2de8d442aa39a274aaa4b758d62aa7d0adb622e3" translate="yes" xml:space="preserve">
          <source>This option is only valid for foreach, update, status and sync commands. Traverse submodules recursively. The operation is performed not only in the submodules of the current repo, but also in any nested submodules inside those submodules (and so on).</source>
          <target state="translated">이 옵션은 foreach, update, status 및 sync 명령에만 유효합니다. 서브 모듈을 재귀 적으로 트래버스합니다. 작업은 현재 리포지토리의 하위 모듈뿐만 아니라 해당 하위 모듈 내부의 중첩 된 하위 모듈 등에서도 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="d01c54f91ad08eb6d9511d7549b500d6b89b1500" translate="yes" xml:space="preserve">
          <source>This option is only valid for status and summary commands. These commands typically use the commit found in the submodule HEAD, but with this option, the commit stored in the index is used instead.</source>
          <target state="translated">이 옵션은 상태 및 요약 명령에만 유효합니다. 이러한 명령은 일반적으로 하위 모듈 HEAD에있는 커밋을 사용하지만이 옵션을 사용하면 인덱스에 저장된 커밋이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7ba21174d5319ba108a98df185e2c79d000e199b" translate="yes" xml:space="preserve">
          <source>This option is only valid for the add command. It sets the submodule&amp;rsquo;s name to the given string instead of defaulting to its path. The name must be valid as a directory name and may not end with a &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 add 명령에만 유효합니다. 서브 모듈의 이름을 기본 경로로 지정하지 않고 주어진 문자열로 설정합니다. 이름은 디렉토리 이름으로 유효해야하며 &lt;code&gt;/&lt;/code&gt; 로 끝나지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="87ff71824f0ae07bd73763f995cf49d0ad4b94cd" translate="yes" xml:space="preserve">
          <source>This option is only valid for the deinit command. Unregister all submodules in the working tree.</source>
          <target state="translated">이 옵션은 deinit 명령에만 유효합니다. 작업 트리에서 모든 하위 모듈을 등록 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="f24783ef5194da88d7aca04af04dd4876a0ce3ed" translate="yes" xml:space="preserve">
          <source>This option is only valid for the summary command. Limit the summary size (number of commits shown in total). Giving 0 will disable the summary; a negative number means unlimited (the default). This limit only applies to modified submodules. The size is always limited to 1 for added/deleted/typechanged submodules.</source>
          <target state="translated">이 옵션은 summary 명령에만 유효합니다. 요약 크기 (전체 커밋 수)를 제한하십시오. 0을 주면 요약이 비활성화됩니다. 음수는 무제한을 의미합니다 (기본값). 이 제한은 수정 된 하위 모듈에만 적용됩니다. 추가 / 삭제 / 유형 변경 하위 모듈의 경우 크기는 항상 1로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="ba7d2b303205764476dea6127f5143ab027381fd" translate="yes" xml:space="preserve">
          <source>This option is only valid for the summary command. This command compares the commit in the index with that in the submodule HEAD when this option is used.</source>
          <target state="translated">이 옵션은 요약 명령에만 유효합니다. 이 명령은이 옵션이 사용될 때 인덱스의 커밋을 서브 모듈 HEAD의 커밋과 비교합니다.</target>
        </trans-unit>
        <trans-unit id="0329e613a2d579c43cf813e4dcb872eed327d20c" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Checkout the commit recorded in the superproject on a detached HEAD in the submodule. This is the default behavior, the main use of this option is to override &lt;code&gt;submodule.$name.update&lt;/code&gt; when set to a value other than &lt;code&gt;checkout&lt;/code&gt;. If the key &lt;code&gt;submodule.$name.update&lt;/code&gt; is either not explicitly set or set to &lt;code&gt;checkout&lt;/code&gt;, this option is implicit.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 서브 모듈에서 분리 된 HEAD에서 수퍼 프로젝트에 기록 된 커밋을 확인하십시오. 이것이 기본 동작이며,이 옵션의 주요 용도는 &lt;code&gt;checkout&lt;/code&gt; 이외의 값으로 설정 될 때 &lt;code&gt;submodule.$name.update&lt;/code&gt; 를 대체 하는 것 입니다. 키 &lt;code&gt;submodule.$name.update&lt;/code&gt; 가 명시 적으로 설정되거나 &lt;code&gt;checkout&lt;/code&gt; 으로 설정되지 않은 경우이 옵션은 내재적입니다.</target>
        </trans-unit>
        <trans-unit id="7988d8bd0ba82c9f133c5f7cc525c2236228f253" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Clone new submodules in parallel with as many jobs. Defaults to the &lt;code&gt;submodule.fetchJobs&lt;/code&gt; option.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 많은 서브 작업과 동시에 새로운 서브 모듈을 복제하십시오. &lt;code&gt;submodule.fetchJobs&lt;/code&gt; 옵션이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="d378f847e736854044b7df06d860154da6a30cd4" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Clone only one branch during update: HEAD or one specified by --branch.</source>
          <target state="translated">이 옵션은 업데이트 명령에만 유효합니다. 업데이트 중에 HEAD 또는 --branch로 지정된 분기 하나만 복제합니다.</target>
        </trans-unit>
        <trans-unit id="de5e49243a4037b1b14e7038956130dc87de6d4f" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Don&amp;rsquo;t fetch new objects from the remote site.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 원격 사이트에서 새 객체를 가져 오지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f13e740e91a73f0a2574eefa11fc263894a39d8c" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Initialize all submodules for which &quot;git submodule init&quot; has not been called so far before updating.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. &quot;git submodule init&quot;가 지금까지 호출되지 않은 모든 서브 모듈을 업데이트하기 전에 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="78bb9a5b0867074719f5c17324b183ac216eed4e" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Instead of using the superproject&amp;rsquo;s recorded SHA-1 to update the submodule, use the status of the submodule&amp;rsquo;s remote-tracking branch. The remote used is branch&amp;rsquo;s remote (&lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt;), defaulting to &lt;code&gt;origin&lt;/code&gt;. The remote branch used defaults to &lt;code&gt;master&lt;/code&gt;, but the branch name may be overridden by setting the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; option in either &lt;code&gt;.gitmodules&lt;/code&gt; or &lt;code&gt;.git/config&lt;/code&gt; (with &lt;code&gt;.git/config&lt;/code&gt; taking precedence).</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 수퍼 프로젝트의 기록 된 SHA-1을 사용하여 서브 모듈을 업데이트하는 대신 서브 모듈의 원격 추적 브랜치 상태를 사용하십시오. 사용 된 원격은 분기의 원격 ( &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; )이며 기본값은 &lt;code&gt;origin&lt;/code&gt; 입니다. 원격 분기에 기본값을 사용하는 &lt;code&gt;master&lt;/code&gt; 하지만, 지점 이름이 설정에 의해 오버라이드 (override) 할 수있다 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; 옵션 중 하나에 &lt;code&gt;.gitmodules&lt;/code&gt; 또는 &lt;code&gt;.git/config&lt;/code&gt; 에 (와 &lt;code&gt;.git/config&lt;/code&gt; 에 복용 우선 순위).</target>
        </trans-unit>
        <trans-unit id="71febe80653ad4c9e80be61d4ea3dbe9011e0741" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Instead of using the superproject&amp;rsquo;s recorded SHA-1 to update the submodule, use the status of the submodule&amp;rsquo;s remote-tracking branch. The remote used is branch&amp;rsquo;s remote (&lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt;), defaulting to &lt;code&gt;origin&lt;/code&gt;. The remote branch used defaults to the remote &lt;code&gt;HEAD&lt;/code&gt;, but the branch name may be overridden by setting the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; option in either &lt;code&gt;.gitmodules&lt;/code&gt; or &lt;code&gt;.git/config&lt;/code&gt; (with &lt;code&gt;.git/config&lt;/code&gt; taking precedence).</source>
          <target state="translated">이 옵션은 업데이트 명령에만 유효합니다. 슈퍼 프로젝트의 기록 된 SHA-1을 사용하여 서브 모듈을 업데이트하는 대신 서브 모듈의 원격 추적 분기 상태를 사용하십시오. 사용되는 원격은 분기의 원격 ( &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; )이며 기본값은 &lt;code&gt;origin&lt;/code&gt; 입니다. 원격 브랜치는 원격으로 기본값을 사용 &lt;code&gt;HEAD&lt;/code&gt; 하지만, 지점 이름이 설정에 의해 오버라이드 (override) 할 수있다 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; 옵션 중 하나에 &lt;code&gt;.gitmodules&lt;/code&gt; 또는 &lt;code&gt;.git/config&lt;/code&gt; 에 (와 &lt;code&gt;.git/config&lt;/code&gt; 에 복용 우선 순위).</target>
        </trans-unit>
        <trans-unit id="c3d36d21960733622c3c4d0c9b1d02dde186ab4d" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Merge the commit recorded in the superproject into the current branch of the submodule. If this option is given, the submodule&amp;rsquo;s HEAD will not be detached. If a merge failure prevents this process, you will have to resolve the resulting conflicts within the submodule with the usual conflict resolution tools. If the key &lt;code&gt;submodule.$name.update&lt;/code&gt; is set to &lt;code&gt;merge&lt;/code&gt;, this option is implicit.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 수퍼 프로젝트에 기록 된 커밋을 서브 모듈의 현재 브랜치에 병합하십시오. 이 옵션을 지정하면 서브 모듈의 HEAD가 분리되지 않습니다. 병합 실패로 인해이 프로세스가 중단되면 일반적인 충돌 해결 도구를 사용하여 하위 모듈 내에서 발생하는 충돌을 해결해야합니다. 키 &lt;code&gt;submodule.$name.update&lt;/code&gt; 가 &lt;code&gt;merge&lt;/code&gt; 로 설정된 경우이 옵션은 내재적입니다.</target>
        </trans-unit>
        <trans-unit id="24320b0a3d3cc55ac6e67c5111e4d5b2024f7768" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Rebase the current branch onto the commit recorded in the superproject. If this option is given, the submodule&amp;rsquo;s HEAD will not be detached. If a merge failure prevents this process, you will have to resolve these failures with &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;. If the key &lt;code&gt;submodule.$name.update&lt;/code&gt; is set to &lt;code&gt;rebase&lt;/code&gt;, this option is implicit.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 현재 브랜치를 수퍼 프로젝트에 기록 된 커밋으로 리베이스하십시오. 이 옵션을 지정하면 서브 모듈의 HEAD가 분리되지 않습니다. 병합 실패가이 프로세스를 방해하면 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]로&lt;/a&gt; 이러한 실패를 해결해야합니다 . 키 &lt;code&gt;submodule.$name.update&lt;/code&gt; 가 &lt;code&gt;rebase&lt;/code&gt; 로 설정된 경우이 옵션은 내재적입니다.</target>
        </trans-unit>
        <trans-unit id="7010a654e778ac0c1da27a5e658bfb8f3af2d2b7" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. The initial clone of a submodule will use the recommended &lt;code&gt;submodule.&amp;lt;name&amp;gt;.shallow&lt;/code&gt; as provided by the &lt;code&gt;.gitmodules&lt;/code&gt; file by default. To ignore the suggestions use &lt;code&gt;--no-recommend-shallow&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 서브 모듈의 초기 복제는 권장 사용 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.shallow&lt;/code&gt; 에 의해 규정 된 &lt;code&gt;.gitmodules&lt;/code&gt; 에 기본적으로 파일. 제안을 무시하려면 &lt;code&gt;--no-recommend-shallow&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6d7b3753dd95003bf8a5d9061fa7c1fb4ce2aaa" translate="yes" xml:space="preserve">
          <source>This option is only valid when &quot;--rebase&quot; is used.</source>
          <target state="translated">이 옵션은 &quot;--rebase&quot;가 사용될 때만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="98847da95477508a8a5d1e566e92d9a686be8a10" translate="yes" xml:space="preserve">
          <source>This option is particularly useful in avoiding false positives when a merged branch contained broken or non-buildable commits, but the merge itself was OK.</source>
          <target state="translated">이 옵션은 병합 된 분기에 깨지거나 빌드 할 수없는 커밋이 포함되어 있지만 병합 자체는 정상일 때 오탐을 방지하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f287cb1cbdf50b2a99b97c922a7a8e625bb0e374" translate="yes" xml:space="preserve">
          <source>This option is passed through to &lt;code&gt;git pack-objects&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;git pack-objects&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="4fbc055bad10c535a2fe42cbab527b95ac43fb4e" translate="yes" xml:space="preserve">
          <source>This option is primarily to help users who are used to older versions of Git, whose &quot;git add &amp;lt;pathspec&amp;gt;&amp;hellip;​&quot; was a synonym for &quot;git add --no-all &amp;lt;pathspec&amp;gt;&amp;hellip;​&quot;, i.e. ignored removed files.</source>
          <target state="translated">이 옵션은 주로 &quot;git add &amp;lt;pathspec&amp;gt;&amp;hellip;&quot;과 같은 이전 버전의 Git에 익숙한 사용자가 &quot;git add --no-all &amp;lt;pathspec&amp;gt;&amp;hellip;&quot;과 동의어 인 경우, 즉 제거 된 파일을 무시하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="b78fb9017b343dcaa9f7e76e34c0b6aead88f71f" translate="yes" xml:space="preserve">
          <source>This option is similar to &lt;code&gt;--topo-order&lt;/code&gt; in the sense that no parent comes before all of its children, but otherwise commits are ordered according to their commit date.</source>
          <target state="translated">이 옵션은 부모가 모든 자식보다 먼저 나오지 않는다는 점에서 &lt;code&gt;--topo-order&lt;/code&gt; 와 비슷 하지만 커밋은 커밋 날짜에 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="45355afb761a7570eab836899016e010dbbaff37" translate="yes" xml:space="preserve">
          <source>This option is used internally to temporarily provide a non-negative default value for the --recurse-submodules option. All other methods of configuring fetch&amp;rsquo;s submodule recursion (such as settings in &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; and &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) override this option, as does specifying --[no-]recurse-submodules directly.</source>
          <target state="translated">이 옵션은 내부적으로 --recurse-submodules 옵션에 음이 아닌 기본값을 제공하기 위해 사용됩니다. 페치의 하위 모듈 재귀를 구성하는 다른 모든 방법 (예 : &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 및 &lt;a href=&quot;git-config&quot;&gt;git-config [1]의 설정&lt;/a&gt; )은-[no-] recurse-submodules를 직접 지정하는 것처럼이 옵션을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="37e6c888c3b366c4018908c683d3076036665dbd" translate="yes" xml:space="preserve">
          <source>This option is useful in the case where one is developing a feature on top of an upstream branch. While the feature is being worked on, the upstream branch may advance and it may not be the best idea to keep rebasing on top of the upstream but to keep the base commit as-is.</source>
          <target state="translated">이 옵션은 업스트림 브랜치에서 기능을 개발중인 경우에 유용합니다. 이 기능이 작동하는 동안 업스트림 브랜치는 진행될 수 있으며 업스트림 상단에 계속 기반을 두는 것이 아니라 기본 커밋을 그대로 유지하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="df85f593fd6f7620dd8216482ba39599038d6eaa" translate="yes" xml:space="preserve">
          <source>This option is valid for add and update commands. Create a &lt;code&gt;shallow&lt;/code&gt; clone with a history truncated to the specified number of revisions. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;</source>
          <target state="translated">이 옵션은 추가 및 업데이트 명령에 유효합니다. 지정된 수의 개정판으로 기록이 잘린 &lt;code&gt;shallow&lt;/code&gt; 복제본을 만듭니다 . &lt;a href=&quot;git-clone&quot;&gt;자식 클론&lt;/a&gt; 참조 [1]</target>
        </trans-unit>
        <trans-unit id="ebd5b9556122446be4baef760f1327190ef9a1e0" translate="yes" xml:space="preserve">
          <source>This option makes it possible to choose what action will be performed when there is already at least one trailer with the same &amp;lt;token&amp;gt; in the message.</source>
          <target state="translated">이 옵션을 사용하면 메시지에 &amp;lt;토큰&amp;gt;이 동일한 트레일러가 이미 하나 이상있을 때 수행 할 작업을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccc070d377579e85f01a8bc02ef61c868f5331ee" translate="yes" xml:space="preserve">
          <source>This option makes it possible to choose what action will be performed when there is not yet any trailer with the same &amp;lt;token&amp;gt; in the message.</source>
          <target state="translated">이 옵션을 사용하면 메시지에 &amp;lt;토큰&amp;gt;이 같은 예고편이 아직 없을 때 수행 할 작업을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f87ac9b403a45c29acabaf374d53994925318884" translate="yes" xml:space="preserve">
          <source>This option may be given up to three times, and specifies labels to be used in place of the corresponding file names in conflict reports. That is, &lt;code&gt;git merge-file -L x -L y -L z a b c&lt;/code&gt; generates output that looks like it came from files x, y and z instead of from files a, b and c.</source>
          <target state="translated">이 옵션은 최대 3 번까지 주어질 수 있으며 충돌 보고서에서 해당 파일 이름 대신 사용할 레이블을 지정합니다. 즉, &lt;code&gt;git merge-file -L x -L y -L z a b c&lt;/code&gt; 는 파일 a, b 및 c가 아닌 파일 x, y 및 z에서 나온 것처럼 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e631233708c2bfee4790b72e1f69b49f86a6c1ad" translate="yes" xml:space="preserve">
          <source>This option may be specified more than once.</source>
          <target state="translated">이 옵션은 두 번 이상 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad4bbf67e7b293924d5786bf652c9c00512dbaee" translate="yes" xml:space="preserve">
          <source>This option may be specified more than once; if so, Git will report commits reachable from any of the given commits.</source>
          <target state="translated">이 옵션은 두 번 이상 지정할 수 있습니다. 그렇다면 Git은 주어진 커밋에서 도달 가능한 커밋을보고합니다.</target>
        </trans-unit>
        <trans-unit id="02516672facfbf5a7b264eba6cd92c5455d92d79" translate="yes" xml:space="preserve">
          <source>This option may be specified multiple times.</source>
          <target state="translated">이 옵션은 여러 번 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b397b665066a62a5850aaf1e8487dea9e6d48e99" translate="yes" xml:space="preserve">
          <source>This option may be useful if you have CVS revision numbers stored in commit messages, bug-tracking systems, email archives, and the like.</source>
          <target state="translated">이 옵션은 커밋 메시지, 버그 추적 시스템, 전자 메일 아카이브 등에 CVS 개정 번호가 저장된 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f0fddd7193d3e6d239ce8fc4bc7fc077dbf4105" translate="yes" xml:space="preserve">
          <source>This option may be useful when the test you would perform in each step does not require a checked out tree.</source>
          <target state="translated">이 옵션은 각 단계에서 수행 할 테스트에 체크 아웃 된 트리가 필요하지 않을 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17ca02a4d5f28c7e8971b8d1a382a0b6bcfa0d17" translate="yes" xml:space="preserve">
          <source>This option overrides this restriction if the current value of the remote ref is the expected value. &quot;git push&quot; fails otherwise.</source>
          <target state="translated">원격 참조의 현재 값이 예상 값인 경우이 옵션은이 제한을 무시합니다. 그렇지 않으면 &quot;git push&quot;가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="8d166b9e59f19f7598d41e509f594cbcbd0ac7f1" translate="yes" xml:space="preserve">
          <source>This option provides an additional limit on top of &lt;code&gt;--window&lt;/code&gt;; the window size will dynamically scale down so as to not take up more than &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; bytes in memory. This is useful in repositories with a mix of large and small objects to not run out of memory with a large window, but still be able to take advantage of the large window for the smaller objects. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. &lt;code&gt;--window-memory=0&lt;/code&gt; makes memory usage unlimited. The default is taken from the &lt;code&gt;pack.windowMemory&lt;/code&gt; configuration variable.</source>
          <target state="translated">이 옵션은 &lt;code&gt;--window&lt;/code&gt; 위에 추가 제한을 제공합니다 . 메모리에서 &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; 바이트 이상을 차지하지 않도록 창 크기가 동적으로 축소됩니다 . 이 기능은 큰 개체와 작은 개체가 혼합 된 리포지토리에서 큰 창이있는 메모리가 부족하지 않지만 작은 개체의 경우 큰 창을 활용할 수 있습니다. 크기는 &quot;k&quot;, &quot;m&quot;또는 &quot;g&quot;로 접미사를 붙일 수 있습니다. &lt;code&gt;--window-memory=0&lt;/code&gt; 은 메모리 사용량을 무제한으로 만듭니다. 기본값은 &lt;code&gt;pack.windowMemory&lt;/code&gt; 구성 변수 에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="b37ac455915a6998f49ecb85f682ef29dfba0c63" translate="yes" xml:space="preserve">
          <source>This option provides an additional limit on top of &lt;code&gt;--window&lt;/code&gt;; the window size will dynamically scale down so as to not take up more than &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; bytes in memory. This is useful in repositories with a mix of large and small objects to not run out of memory with a large window, but still be able to take advantage of the large window for the smaller objects. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. &lt;code&gt;--window-memory=0&lt;/code&gt; makes memory usage unlimited. The default is taken from the &lt;code&gt;pack.windowMemory&lt;/code&gt; configuration variable. Note that the actual memory usage will be the limit multiplied by the number of threads used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;--window&lt;/code&gt; 위에 추가 제한을 제공합니다 . 메모리에서 &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; 바이트 이상을 차지하지 않도록 창 크기가 동적으로 축소됩니다 . 이 기능은 큰 개체와 작은 개체가 혼합 된 리포지토리에서 큰 창이있는 메모리가 부족하지 않지만 작은 개체의 경우 큰 창을 활용할 수 있습니다. 크기는 &quot;k&quot;, &quot;m&quot;또는 &quot;g&quot;로 접미사를 붙일 수 있습니다. &lt;code&gt;--window-memory=0&lt;/code&gt; 은 메모리 사용량을 무제한으로 만듭니다. 기본값은 &lt;code&gt;pack.windowMemory&lt;/code&gt; 구성 변수 에서 가져옵니다 . 실제 메모리 사용량은 &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]에&lt;/a&gt; 사용 된 스레드 수를 곱한 한도 입니다.</target>
        </trans-unit>
        <trans-unit id="16a6b7273f3cccefcfa42e33a667c568aaee0875" translate="yes" xml:space="preserve">
          <source>This option sets how the tag message is cleaned up. The &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; can be one of &lt;code&gt;verbatim&lt;/code&gt;, &lt;code&gt;whitespace&lt;/code&gt; and &lt;code&gt;strip&lt;/code&gt;. The &lt;code&gt;strip&lt;/code&gt; mode is default. The &lt;code&gt;verbatim&lt;/code&gt; mode does not change message at all, &lt;code&gt;whitespace&lt;/code&gt; removes just leading/trailing whitespace lines and &lt;code&gt;strip&lt;/code&gt; removes both whitespace and commentary.</source>
          <target state="translated">이 옵션은 태그 메시지를 정리하는 방법을 설정합니다. &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 중 하나가 될 수 &lt;code&gt;verbatim&lt;/code&gt; , &lt;code&gt;whitespace&lt;/code&gt; 및 &lt;code&gt;strip&lt;/code&gt; . &lt;code&gt;strip&lt;/code&gt; 모드는 기본값입니다. &lt;code&gt;verbatim&lt;/code&gt; 모드는 전혀 메시지를 변경하지 않는 &lt;code&gt;whitespace&lt;/code&gt; 단지 / 주요 라인과 공백을 후행 제거합니다 &lt;code&gt;strip&lt;/code&gt; 공백과 해설을 모두 제거합니다.</target>
        </trans-unit>
        <trans-unit id="1c04622cab5eac3fe5e20d1c189be97d2000ad23" translate="yes" xml:space="preserve">
          <source>This option takes the same values as the &lt;code&gt;trailer.ifexists&lt;/code&gt; configuration variable and it overrides what is specified by that option for trailers with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">이 옵션은 같은 값을 사용 &lt;code&gt;trailer.ifexists&lt;/code&gt; 의 구성 변수는 지정된 &amp;lt;토큰&amp;gt;와 트레일러에 대한 해당 옵션에 의해 지정됩니다 무엇보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="de59f6641e33166f78c75c60b985eacdf1d2a0ea" translate="yes" xml:space="preserve">
          <source>This option takes the same values as the &lt;code&gt;trailer.ifmissing&lt;/code&gt; configuration variable and it overrides what is specified by that option for trailers with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;trailer.ifmissing&lt;/code&gt; 구성 변수와 동일한 값을 사용하며 지정된 &amp;lt;token&amp;gt;을 가진 트레일러에 대해 해당 옵션으로 지정된 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="6b156d8c8a67e1eaa9c71b8c4e454e308c17c450" translate="yes" xml:space="preserve">
          <source>This option takes the same values as the &lt;code&gt;trailer.where&lt;/code&gt; configuration variable and it overrides what is specified by that option for trailers with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;trailer.where&lt;/code&gt; 구성 변수와 동일한 값을 가지며 지정된 &amp;lt;token&amp;gt;을 가진 트레일러에 대해 해당 옵션으로 지정된 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="7df9ff293572a5c1527bce59783d9544419daa5b" translate="yes" xml:space="preserve">
          <source>This option tells where a new trailer will be added.</source>
          <target state="translated">이 옵션은 새 트레일러가 추가 될 위치를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="b36c69b0196d300061790058cdc0665affb9915e" translate="yes" xml:space="preserve">
          <source>This option tells which characters are recognized as trailer separators. By default only &lt;code&gt;:&lt;/code&gt; is recognized as a trailer separator, except that &lt;code&gt;=&lt;/code&gt; is always accepted on the command line for compatibility with other git commands.</source>
          <target state="translated">이 옵션은 트레일러 구분 기호로 인식되는 문자를 알려줍니다. 기본적으로 &lt;code&gt;:&lt;/code&gt; 트레일러 구분 기호로 인식됩니다. 단, 다른 git 명령과의 호환성을 위해 명령 줄에서 &lt;code&gt;=&lt;/code&gt; 가 항상 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d89b4c86a97ff8d1caa3cc84d59173003c0040dc" translate="yes" xml:space="preserve">
          <source>This option will cause fast-export to issue a &quot;deleteall&quot; directive for each commit followed by a full list of all files in the commit (as opposed to just listing the files which are different from the commit&amp;rsquo;s first parent).</source>
          <target state="translated">이 옵션은 빠른 내보내기로 인해 각 커밋에 대해 &quot;deleteall&quot;지시문을 발행하고 커밋의 첫 번째 상위와 다른 파일을 나열하는 대신 커밋에있는 모든 파일의 전체 목록을 발행합니다.</target>
        </trans-unit>
        <trans-unit id="f143abcfc92e5721db51d7183ec9951b417133b6" translate="yes" xml:space="preserve">
          <source>This option will cause git-svn to attempt to automatically populate the svn:mergeinfo property in the SVN repository when possible. Currently, this can only be done when dcommitting non-fast-forward merges where all parents but the first have already been pushed into SVN.</source>
          <target state="translated">이 옵션은 git-svn이 가능한 경우 SVN 저장소에서 svn : mergeinfo 속성을 자동으로 채우도록 시도합니다. 현재 이것은 첫 번째 부모를 제외한 모든 부모가 이미 SVN으로 푸시 된 비 빨리 감기 병합을 dcommitting 할 때만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06697c041d5aacbd598da12e9917cf43b1b799c5" translate="yes" xml:space="preserve">
          <source>This option will cause the mapping from old to new objects to be loaded from named branch upon startup and saved as a new commit to that branch upon exit, enabling incremental of large trees. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; does not exist it will be created.</source>
          <target state="translated">이 옵션을 사용하면 시작시 기존 오브젝트에서 새 오브젝트로의 맵핑이 명명 된 브랜치에서로드되고 종료시 해당 브랜치에 새 커밋으로 저장되어 큰 트리를 증분시킬 수 있습니다. 경우 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 존재하지 않는 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="dac1adaa75a920f5808dd15e4e9468c4b8319529" translate="yes" xml:space="preserve">
          <source>This output format is compatible with what &lt;code&gt;--index-info --stdin&lt;/code&gt; of &lt;code&gt;git update-index&lt;/code&gt; expects.</source>
          <target state="translated">이 출력 형식은 &lt;code&gt;git update-index&lt;/code&gt; 의 &lt;code&gt;--index-info --stdin&lt;/code&gt; 이 기대 하는 것과 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="9b61a138f7f673e2e13a43bac58e20e6d27091cc" translate="yes" xml:space="preserve">
          <source>This outputs all the commit objects between the included and excluded commits, ordered by their distance to the included and excluded commits. Refs in &lt;code&gt;refs/bisect/&lt;/code&gt; are not used. The farthest from them is displayed first. (This is the only one displayed by &lt;code&gt;--bisect&lt;/code&gt;.)</source>
          <target state="translated">포함 및 제외 커밋까지의 거리 순서대로 포함 및 제외 커밋 사이의 모든 커밋 개체를 출력합니다. &lt;code&gt;refs/bisect/&lt;/code&gt; 참조는 사용되지 않습니다. 가장 먼 곳이 먼저 표시됩니다. &lt;code&gt;--bisect&lt;/code&gt; 에 의해 표시되는 유일한 항목 입니다.</target>
        </trans-unit>
        <trans-unit id="c6b16b352aa83127a9d9220754dcd31555c3879e" translate="yes" xml:space="preserve">
          <source>This outputs something like this (the actual commit object names would be different)</source>
          <target state="translated">이것은 다음과 같이 출력됩니다 (실제 커밋 객체 이름은 다를 수 있습니다)</target>
        </trans-unit>
        <trans-unit id="05fcf2a461c52cf42967559d01dbd73ffe108135" translate="yes" xml:space="preserve">
          <source>This overrides a previous &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; setting and reads the default merge tool will be read from the configured &lt;code&gt;merge.tool&lt;/code&gt; variable.</source>
          <target state="translated">이는 이전 &lt;code&gt;-g&lt;/code&gt; 또는 &lt;code&gt;--gui&lt;/code&gt; 설정을 무시 하고 구성된 &lt;code&gt;merge.tool&lt;/code&gt; 변수 에서 기본 병합 도구를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="cf7619d964802ced013b07a7c34a4262a7e0e3f4" translate="yes" xml:space="preserve">
          <source>This page can be displayed with &lt;code&gt;git help help&lt;/code&gt; or &lt;code&gt;git help --help&lt;/code&gt;</source>
          <target state="translated">이 페이지는 &lt;code&gt;git help help&lt;/code&gt; 또는 &lt;code&gt;git help --help&lt;/code&gt; 와 함께 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d990ef47ac594dcb10bc55890ec7a6963b3ffaed" translate="yes" xml:space="preserve">
          <source>This particular format is supplied as it&amp;rsquo;s short to implement and may be useful to a process that wants to create a new commit right now, without needing to use a working directory or &lt;code&gt;git update-index&lt;/code&gt;.</source>
          <target state="translated">이 특정 형식은 구현하기가 짧기 때문에 제공되며 작업 디렉토리 또는 &lt;code&gt;git update-index&lt;/code&gt; 를 사용할 필요없이 지금 새로운 커밋을 생성하려는 프로세스에 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ace4cf0777df858ca1c6440d5cccb2ed6637934" translate="yes" xml:space="preserve">
          <source>This prints the name of a commit they are both based on. You should now look up the tree objects of those commits, which you can easily do with</source>
          <target state="translated">커밋 이름을 출력합니다. 이제 커밋의 트리 객체를 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="65ce33f2a6f411ae54de75d77a4a5c5e2663fba3" translate="yes" xml:space="preserve">
          <source>This program computes which packs in your repository are redundant. The output is suitable for piping to &lt;code&gt;xargs rm&lt;/code&gt; if you are in the root of the repository.</source>
          <target state="translated">이 프로그램은 리포지토리의 어떤 팩이 중복되는지 계산합니다. 저장소의 루트에있는 경우 출력은 &lt;code&gt;xargs rm&lt;/code&gt; 으로 파이핑하는 데 적합 합니다.</target>
        </trans-unit>
        <trans-unit id="9dec60739fdc5804a4abedc6cf66847493211890" translate="yes" xml:space="preserve">
          <source>This program dumps the given revisions in a form suitable to be piped into &lt;code&gt;git fast-import&lt;/code&gt;.</source>
          <target state="translated">이 프로그램은 주어진 개정판을 &lt;code&gt;git fast-import&lt;/code&gt; 로 파이프하기에 적합한 형식으로 덤프합니다 .</target>
        </trans-unit>
        <trans-unit id="21943cdf9cd81593906492b86163eaa305da0be9" translate="yes" xml:space="preserve">
          <source>This program is usually not what the end user wants to run directly. Most end users want to use one of the existing frontend programs, which parses a specific type of foreign source and feeds the contents stored there to &lt;code&gt;git fast-import&lt;/code&gt;.</source>
          <target state="translated">이 프로그램은 일반적으로 최종 사용자가 직접 실행하려는 것이 아닙니다. 대부분의 최종 사용자는 기존 프론트 엔드 프로그램 중 하나를 사용하려고합니다.이 프로그램은 특정 유형의 외부 소스를 구문 분석하고 거기에 저장된 컨텐츠를 &lt;code&gt;git fast-import&lt;/code&gt; 에 공급 합니다.</target>
        </trans-unit>
        <trans-unit id="17acfb3fc2cc80c07ee41f3eeadca000eefd6ee0" translate="yes" xml:space="preserve">
          <source>This program searches the &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; for all objects that currently exist in a pack file as well as the independent object directories.</source>
          <target state="translated">이 프로그램은 &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; 에서 현재 팩 파일에 존재하는 모든 오브젝트와 독립 오브젝트 디렉토리를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="a85a25d731117b0f9fdffb50b50cd41a205c14dd" translate="yes" xml:space="preserve">
          <source>This public repository could further be mirrored, and that is how Git repositories at &lt;code&gt;kernel.org&lt;/code&gt; are managed.</source>
          <target state="translated">이 퍼블릭 리포지토리는 추가로 미러링 될 수 있으며, 이것이 &lt;code&gt;kernel.org&lt;/code&gt; 의 Git 리포지토리 가 관리되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="3f74cf126c451b6a68e67763c97a8253f485453b" translate="yes" xml:space="preserve">
          <source>This puts a Git archive of the named CVS module in the directory &amp;lt;destination&amp;gt;, which will be created if necessary.</source>
          <target state="translated">그러면 이름이 지정된 CVS 모듈의 Git 아카이브가 &amp;lt;destination&amp;gt; 디렉토리에 저장되며 필요한 경우 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="8831ce4f64ae931ef68e9c4eb0b8a48320fea478" translate="yes" xml:space="preserve">
          <source>This rebase can be performed using the &lt;code&gt;--rebase-merges&lt;/code&gt; option. It will generate a todo list looking like this:</source>
          <target state="translated">이 rebase는 &lt;code&gt;--rebase-merges&lt;/code&gt; 옵션을 사용하여 수행 할 수 있습니다 . 다음과 같은 할 일 목록을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5e2dd779ca9f11c05d6bae58c7d8a031f404dc72" translate="yes" xml:space="preserve">
          <source>This ref is unchanged since the last import or fetch, although the helper cannot necessarily determine what value that produced.</source>
          <target state="translated">헬퍼가 생성 한 값을 반드시 결정할 수는 없지만 마지막 가져 오기 또는 가져 오기 이후이 참조는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e48a6f59fc5d06bf39a026582c3a2674a30ee86" translate="yes" xml:space="preserve">
          <source>This remote helper is transparently used by Git when you use commands such as &quot;git fetch &amp;lt;URL&amp;gt;&quot;, &quot;git clone &amp;lt;URL&amp;gt;&quot;, , &quot;git push &amp;lt;URL&amp;gt;&quot; or &quot;git remote add &amp;lt;nick&amp;gt; &amp;lt;URL&amp;gt;&quot;, where &amp;lt;URL&amp;gt; begins with &lt;code&gt;ext::&lt;/code&gt;. Examples:</source>
          <target state="translated">이 원격 헬퍼는 &quot;git fetch &amp;lt;URL&amp;gt;&quot;, &quot;git clone &amp;lt;URL&amp;gt;&quot;,, &quot;git push &amp;lt;URL&amp;gt;&quot;또는 &quot;git remote add &amp;lt;nick&amp;gt; &amp;lt;URL&amp;gt;&quot;과 같은 명령을 사용할 때 Git에서 투명하게 사용됩니다. &amp;lt;URL&amp;gt;은 &lt;code&gt;ext::&lt;/code&gt; 시작합니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="76e69f76fb018209940d2bd178b055119cc99cef" translate="yes" xml:space="preserve">
          <source>This remote helper uses the specified &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; to connect to a remote Git server.</source>
          <target state="translated">이 원격 헬퍼는 지정된 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 를 사용하여 원격 Git 서버에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="08f3058ad626936f077bcdb5101be9917b27eae0" translate="yes" xml:space="preserve">
          <source>This removes the &lt;code&gt;WIP&lt;/code&gt; commit from the commit history, and sets your working tree to the state just before you made that snapshot.</source>
          <target state="translated">커밋 기록에서 &lt;code&gt;WIP&lt;/code&gt; 커밋을 제거하고 작업 트리를 해당 스냅 샷을 만들기 직전의 상태로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6cde691b95501235edce70baf30f3d475a6f05af" translate="yes" xml:space="preserve">
          <source>This removes the file from the index while keeping it in the working directory.</source>
          <target state="translated">작업 디렉토리에 파일을 유지하면서 색인에서 파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="f2e99bc05d5874bb5e940e93689126e6c4aa347e" translate="yes" xml:space="preserve">
          <source>This resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old development history of side branches. Note that this is different from the -Xours option to the &lt;code&gt;recursive&lt;/code&gt; merge strategy.</source>
          <target state="translated">이렇게하면 헤드 수를 확인할 수 있지만 병합의 결과 트리는 항상 현재 분기 헤드의 트리이므로 다른 모든 분기의 모든 변경 사항을 효과적으로 무시합니다. 사이드 브랜치의 오래된 개발 히스토리를 대체하는 데 사용됩니다. 이것은 -Xours 옵션과 &lt;code&gt;recursive&lt;/code&gt; 병합 전략 과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="053dd73bd0ed92de95c5b132a1b4a0308f96cd04" translate="yes" xml:space="preserve">
          <source>This resolves cases with more than two heads, but refuses to do a complex merge that needs manual resolution. It is primarily meant to be used for bundling topic branch heads together. This is the default merge strategy when pulling or merging more than one branch.</source>
          <target state="translated">이렇게하면 두 개 이상의 헤드가있는 케이스는 해결되지만 수동 해결이 필요한 복잡한 병합을 거부합니다. 주로 토픽 브랜치 헤드를 묶는 데 사용됩니다. 하나 이상의 브랜치를 가져 오거나 병합 할 때의 기본 병합 전략입니다.</target>
        </trans-unit>
        <trans-unit id="e1337ea8d65ee53d09143c99f1f587dd31c2d238" translate="yes" xml:space="preserve">
          <source>This results in:</source>
          <target state="translated">결과 :</target>
        </trans-unit>
        <trans-unit id="a3acfff86d0ac3c7e1c1af7dc1decad57125efa5" translate="yes" xml:space="preserve">
          <source>This runs &lt;code&gt;git fsck --unreachable&lt;/code&gt; using all the refs available in &lt;code&gt;refs/&lt;/code&gt;, optionally with additional set of objects specified on the command line, and prunes all unpacked objects unreachable from any of these head objects from the object database. In addition, it prunes the unpacked objects that are also found in packs by running &lt;code&gt;git prune-packed&lt;/code&gt;. It also removes entries from .git/shallow that are not reachable by any ref.</source>
          <target state="translated">이 명령은 &lt;code&gt;refs/&lt;/code&gt; 에서 사용 가능한 모든 &lt;code&gt;git fsck --unreachable&lt;/code&gt; 를 선택적으로 사용하여 git fsck --unreachable 을 실행 하고 , 선택적으로 명령 행에 지정된 추가 오브젝트 세트를 사용하여 오브젝트 데이터베이스에서 이러한 헤드 오브젝트에서 도달 할 수없는 모든 압축 해제 된 오브젝트를 프룬합니다. 또한 &lt;code&gt;git prune-packed&lt;/code&gt; 를 실행하여 팩에있는 압축 해제 된 객체를 제거 합니다. 또한 .git / shallow에서 참조에 도달 할 수없는 항목을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="66bb2cd044765c7338efb3b55d3b51e463e22970" translate="yes" xml:space="preserve">
          <source>This runs a virtual check-out and check-in of all three stages of a file when resolving a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See &quot;Merging branches with differing checkin/checkout attributes&quot; in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">이렇게하면 3 방향 병합을 해결할 때 파일의 3 단계 모두에 대한 가상 체크 아웃 및 체크인이 실행됩니다. 이 옵션은 다른 클린 필터 또는 라인 끝 정규화 규칙을 사용하여 분기를 병합 할 때 사용됩니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]의&lt;/a&gt; &quot;체크인 / 체크 아웃 속성이 다른 분기 병합&quot; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d37cfee1983b15d675f4e1a4163b8c978a492421" translate="yes" xml:space="preserve">
          <source>This says &quot;include everything in root, but nothing two levels below root.&quot;</source>
          <target state="translated">이것은 &quot;모든 것을 루트에 포함하지만 루트 아래 두 수준 아래는 포함하지 않습니다.&quot;라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="b3bd580b61f2b6d754a6c049f07ff919549d1439" translate="yes" xml:space="preserve">
          <source>This says &quot;include everything in root, but nothing two levels below root.&quot; If we then add the folder &lt;code&gt;A/B/C&lt;/code&gt; as a recursive pattern, the folders &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A/B&lt;/code&gt; are added as parent patterns. The resulting sparse-checkout file is now</source>
          <target state="translated">&quot;루트에는 모든 것을 포함하지만 루트 아래에 두 레벨은 포함되지 않습니다.&quot; 그런 다음 폴더 &lt;code&gt;A/B/C&lt;/code&gt; 를 재귀 패턴으로 추가하면 폴더 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;A/B&lt;/code&gt; 가 상위 패턴으로 추가됩니다. 결과 스파 스 체크 아웃 파일은 이제</target>
        </trans-unit>
        <trans-unit id="9f2fcd6a73ae4ce542d08fc5e7f799314e8e80fc" translate="yes" xml:space="preserve">
          <source>This script can be passed to &quot;git bisect run&quot; to find the commit that introduced a performance regression:</source>
          <target state="translated">이 스크립트는 &quot;git bisect run&quot;으로 전달되어 성능 회귀를 도입 한 커밋을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72c86095923977328df35910b245e776428b840b" translate="yes" xml:space="preserve">
          <source>This script is included in various scripts to supply routines to parse files under $GIT_DIR/remotes/ and $GIT_DIR/branches/ and configuration variables that are related to fetching, pulling and pushing.</source>
          <target state="translated">이 스크립트는 다양한 스크립트에 포함되어 $ GIT_DIR / remotes / 및 $ GIT_DIR / branches /에서 파일을 구문 분석하는 루틴과 페치, 풀 및 푸시와 관련된 구성 변수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a405ee4e7ff4cc67a738558081388543481850c0" translate="yes" xml:space="preserve">
          <source>This section can also be used by those who respond to &lt;code&gt;git
request-pull&lt;/code&gt; or pull-request on GitHub (www.github.com) to integrate the work of others into their history. A sub-area lieutenant for a repository will act both as a participant and as an integrator.</source>
          <target state="translated">이 섹션은 또한 GitHub (www.github.com)에서 &lt;code&gt;git request-pull&lt;/code&gt; 또는 pull-request에 응답하는 사람들이 다른 사람의 작업을 역사에 통합 할 수 있습니다. 리포지토리의 하위 영역 중위는 참가자 및 통합 자 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="53af582e47690e9820cb012bdcbccf97b8def7d3" translate="yes" xml:space="preserve">
          <source>This section explains how to configure some common webservers to run gitweb. In all cases, &lt;code&gt;/path/to/gitweb&lt;/code&gt; in the examples is the directory you ran installed gitweb in, and contains &lt;code&gt;gitweb_config.perl&lt;/code&gt;.</source>
          <target state="translated">이 섹션에서는 gitweb을 실행하기 위해 일반적인 웹 서버를 구성하는 방법에 대해 설명합니다. 모든 예 에서, 예제의 &lt;code&gt;/path/to/gitweb&lt;/code&gt; 은 gitweb을 설치 한 디렉토리이며 &lt;code&gt;gitweb_config.perl&lt;/code&gt; 을 포함 합니다 .</target>
        </trans-unit>
        <trans-unit id="79c0f1f15a38eae1b5cc2a5e381bfbc844ef9486" translate="yes" xml:space="preserve">
          <source>This section is only included if a packfile section is also included in the response.</source>
          <target state="translated">이 섹션은 팩 파일 섹션이 응답에 포함 된 경우에만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f3cd5eb5a3885e012dabb05171cc566728c1791b" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git archive --remote&lt;/code&gt;. It is disabled by default, but a repository can enable it by setting &lt;code&gt;daemon.uploadarch&lt;/code&gt; configuration item to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git archive --remote&lt;/code&gt; 를 제공합니다 . 기본적으로 비활성화되어 있지만 저장소는 &lt;code&gt;daemon.uploadarch&lt;/code&gt; 구성 항목을 &lt;code&gt;true&lt;/code&gt; 로 설정하여 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1fc9be9532fca80163bd11748e3553d0b5b85a4" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git fetch-pack&lt;/code&gt; and &lt;code&gt;git ls-remote&lt;/code&gt; clients. It is enabled by default, but a repository can disable it by setting &lt;code&gt;daemon.uploadpack&lt;/code&gt; configuration item to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git fetch-pack&lt;/code&gt; 및 &lt;code&gt;git ls-remote&lt;/code&gt; 클라이언트를 제공합니다. 기본적으로 사용 가능하지만 저장소는 &lt;code&gt;daemon.uploadpack&lt;/code&gt; 구성 항목을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 사용 불가능하게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce507c3877f92fc6c1de609ca683d1e2a4e1b26f" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git fetch-pack&lt;/code&gt; and &lt;code&gt;git ls-remote&lt;/code&gt; clients. It is enabled by default, but a repository can disable it by setting this configuration item to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git fetch-pack&lt;/code&gt; 및 &lt;code&gt;git ls-remote&lt;/code&gt; 클라이언트를 제공합니다. 기본적으로 사용 가능하지만 저장소는이 구성 항목을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 사용 불가능하게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f25bae0e6df9b1b4a76a588d485b17d422e56c18" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git send-pack&lt;/code&gt; clients, allowing anonymous push. It is disabled by default, as there is &lt;code&gt;no&lt;/code&gt; authentication in the protocol (in other words, anybody can push anything into the repository, including removal of refs). This is solely meant for a closed LAN setting where everybody is friendly. This service can be enabled by setting &lt;code&gt;daemon.receivepack&lt;/code&gt; configuration item to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git send-pack&lt;/code&gt; 클라이언트를 제공하여 익명 푸시를 허용합니다. 프로토콜에 인증 이 &lt;code&gt;no&lt;/code&gt; 기본적으로 비활성화되어 있습니다. 즉, 심판 제거를 포함하여 모든 것을 저장소에 푸시 할 수 있습니다. 이것은 모두가 친숙한 닫힌 LAN 설정만을위한 것입니다. &lt;code&gt;daemon.receivepack&lt;/code&gt; 구성 항목을 &lt;code&gt;true&lt;/code&gt; 로 설정 하여이 서비스를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b2859849402fde4d51ffe73c129c97d00cb6083" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git send-pack&lt;/code&gt; clients, allowing push. It is disabled by default for anonymous users, and enabled by default for users authenticated by the web server. It can be disabled by setting this item to &lt;code&gt;false&lt;/code&gt;, or enabled for all users, including anonymous users, by setting it to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git send-pack&lt;/code&gt; 클라이언트에 서비스를 제공 하여 푸시를 허용합니다. 익명 사용자의 경우 기본적으로 비활성화되어 있으며 웹 서버에서 인증 된 사용자의 경우 기본적으로 활성화되어 있습니다. 이 항목을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 비활성화 하거나 익명 사용자를 포함한 모든 사용자가 &lt;code&gt;true&lt;/code&gt; 로 설정하여 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d789007e515492a9cc42830b12a07ff1db6d084" translate="yes" xml:space="preserve">
          <source>This serves Git clients older than version 1.6.6 that are unable to use the upload pack service. When enabled, clients are able to read any file within the repository, including objects that are no longer reachable from a branch but are still present. It is enabled by default, but a repository can disable it by setting this configuration item to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">업로드 팩 서비스를 사용할 수없는 버전 1.6.6 이전의 Git 클라이언트에 서비스를 제공합니다. 사용 가능한 경우 클라이언트는 더 이상 지점에서 도달 할 수 없지만 여전히 존재하는 오브젝트를 포함하여 저장소 내의 모든 파일을 읽을 수 있습니다. 기본적으로 사용 가능하지만 저장소는이 구성 항목을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 사용 불가능하게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5456200c93d8963943eca093573a9d8938a4ea5f" translate="yes" xml:space="preserve">
          <source>This sets GIT_SVN_ID (instead of using the environment). This allows the user to override the default refname to fetch from when tracking a single URL. The &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;dcommit&lt;/code&gt; commands no longer require this switch as an argument.</source>
          <target state="translated">환경을 사용하는 대신 GIT_SVN_ID를 설정합니다. 이를 통해 사용자는 단일 URL을 추적 할 때 가져올 기본 참조 이름을 재정의 할 수 있습니다. &lt;code&gt;log&lt;/code&gt; 및 &lt;code&gt;dcommit&lt;/code&gt; 명령은 더 이상 인수로이 스위치를 필요로하지 않는다.</target>
        </trans-unit>
        <trans-unit id="acb244d7aa46a820614aa10decb4464bc8ecabb6" translate="yes" xml:space="preserve">
          <source>This setting can be disabled by the &lt;code&gt;--no-notes&lt;/code&gt; option, overridden by the &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; environment variable, and overridden by the &lt;code&gt;--notes=&amp;lt;ref&amp;gt;&lt;/code&gt; option.</source>
          <target state="translated">이 설정은 &lt;code&gt;--no-notes&lt;/code&gt; 옵션 으로 비활성화 하고 &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; 환경 변수로 재정의하고 &lt;code&gt;--notes=&amp;lt;ref&amp;gt;&lt;/code&gt; 옵션으로 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8f435ef26eec94bd5c23846a74c0f4d57a87c8f" translate="yes" xml:space="preserve">
          <source>This setting can be overridden by passing the &lt;code&gt;--strategy&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;--strategy&lt;/code&gt; 옵션 을 전달하면이 설정을 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d273f23cd160340c4f9b3fbc5a088c0fc2c32be" translate="yes" xml:space="preserve">
          <source>This setting can be overridden by the &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; environment variable.</source>
          <target state="translated">이 설정은 &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; 환경 변수 로 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b28435a905552ea063d5203034696b428fdc0b87" translate="yes" xml:space="preserve">
          <source>This setting can be overridden with the &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; environment variable, which must be a colon separated list of refs or globs.</source>
          <target state="translated">이 설정은 &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; 환경 변수 로 재정의 할 수 있습니다.이 변수는 콜론으로 구분 된 참조 또는 글로브 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="45473aa6b3903d5487aab6b473bcf528e266cdec" translate="yes" xml:space="preserve">
          <source>This setting can be overridden with the &lt;code&gt;GIT_NOTES_REWRITE_MODE&lt;/code&gt; environment variable.</source>
          <target state="translated">이 설정은 &lt;code&gt;GIT_NOTES_REWRITE_MODE&lt;/code&gt; 환경 변수 로 재정의 할 수 있습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
