<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="d8f5a662d30248028e58618a9cb324b38272bbd8" translate="yes" xml:space="preserve">
          <source>These commands all compare two sets of things; what is compared differs:</source>
          <target state="translated">이 명령은 모두 두 가지 세트를 비교합니다. 비교되는 내용이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6e07bfec6529e0e8049d6a168dde51eb0ed55268" translate="yes" xml:space="preserve">
          <source>These commands are to interact with foreign SCM and with other people via patch over e-mail.</source>
          <target state="translated">이 명령은 전자 우편을 통해 외부 SCM 및 다른 사람들과 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="008c5282b165f202ade67dc870d3522a81a841bd" translate="yes" xml:space="preserve">
          <source>These configuration variables control &lt;code&gt;internal&lt;/code&gt; gitweb behavior.</source>
          <target state="translated">이 구성 변수는 &lt;code&gt;internal&lt;/code&gt; gitweb 동작을 제어 합니다.</target>
        </trans-unit>
        <trans-unit id="94d243826a65ff43f06f691e3b2f877746c8e3a7" translate="yes" xml:space="preserve">
          <source>These configurations enable two things. First, each unix user (&lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt;) of the server will be able to browse through gitweb Git repositories found in &lt;code&gt;~/public_git/&lt;/code&gt; with the following url:</source>
          <target state="translated">이러한 구성은 두 가지를 가능하게합니다. 먼저 서버의 각 유닉스 사용자 ( &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; )는 &lt;code&gt;~/public_git/&lt;/code&gt; 에있는 gitweb Git 저장소를 다음 URL 로 찾아 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c188c162ef90ed4e72b2204b53fd7bbdf63ed82" translate="yes" xml:space="preserve">
          <source>These environment variables apply to &lt;code&gt;all&lt;/code&gt; core Git commands. Nb: it is worth noting that they may be used/overridden by SCMS sitting above Git so take care if using a foreign front-end.</source>
          <target state="translated">이러한 환경 변수는 &lt;code&gt;all&lt;/code&gt; 핵심 Git 명령에 적용됩니다 . Nb : Git 위에있는 SCMS에 의해 사용 / 재정의 될 수 있으므로 외국 프론트 엔드를 사용하는 경우주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="e4a9928c908043039dae5cc89a184941db222aba" translate="yes" xml:space="preserve">
          <source>These exclude patterns come from these places, in order:</source>
          <target state="translated">이러한 제외 패턴은 다음 위치에서 순서대로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="75ad982aca6a7add80092ae27820348741497d7e" translate="yes" xml:space="preserve">
          <source>These flag are passed to the &lt;code&gt;git apply&lt;/code&gt; program (see &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;) that applies the patch.</source>
          <target state="translated">이 플래그는 패치를 적용하는 &lt;code&gt;git apply&lt;/code&gt; 프로그램 ( &lt;a href=&quot;git-apply&quot;&gt;git-apply [1]&lt;/a&gt; 참조)으로 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="a66ecfa5cef3d43b11b6332452dde3bc34998a82" translate="yes" xml:space="preserve">
          <source>These flags are passed to &lt;code&gt;git am&lt;/code&gt; to easily change the dates of the rebased commits (see &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;).</source>
          <target state="translated">이 플래그는 리베이스 된 커밋의 날짜를 쉽게 변경하기 위해 &lt;code&gt;git am&lt;/code&gt; 에 전달됩니다 ( &lt;a href=&quot;git-am&quot;&gt;git-am [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6f1d3498209d5426cb1c8295c9947466ac12cab4" translate="yes" xml:space="preserve">
          <source>These flags are passed to the &lt;code&gt;git apply&lt;/code&gt; (see &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;) program that applies the patch.</source>
          <target state="translated">이 플래그는 패치를 적용하는 &lt;code&gt;git apply&lt;/code&gt; ( &lt;a href=&quot;git-apply&quot;&gt;git-apply [1] 참조&lt;/a&gt; ) 프로그램으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="17c5d825c714d7f669df648adc8ffa3b9865aa3a" translate="yes" xml:space="preserve">
          <source>These forms reset the index entries for all paths that match the &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; to their state at &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;. (It does not affect the working tree or the current branch.)</source>
          <target state="translated">이 형식은 &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; 과 일치하는 모든 경로의 인덱스 항목을 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 의 상태로 재설정합니다 . 작업 트리 또는 현재 분기에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84dfe82e69639d7dd0490e18b4061edc5e5f61bb" translate="yes" xml:space="preserve">
          <source>These general best practices are very helpful if you bisect often.</source>
          <target state="translated">이러한 일반적인 모범 사례는 자주 이등분하는 경우 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="db63350c8a27af092cfd256119dcf34d87e7125f" translate="yes" xml:space="preserve">
          <source>These instructions use the &lt;code&gt;git-cvsimport&lt;/code&gt; script which ships with git, but other importers may provide better results. See the note in &lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport[1]&lt;/a&gt; for other options.</source>
          <target state="translated">이 지침에서는 &lt;code&gt;git-cvsimport&lt;/code&gt; 과 함께 제공되는 git-cvsimport 스크립트를 사용 하지만 다른 수입 업체가 더 나은 결과를 제공 할 수 있습니다. 다른 옵션에 대해서는 &lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport [1]&lt;/a&gt; 의 참고 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4de4cd9ec9920076e498bf4f8c01b7cc0e7335b0" translate="yes" xml:space="preserve">
          <source>These messages are concerned with Git thread usage.</source>
          <target state="translated">이 메시지는 Git 스레드 사용과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8e5bd243ffdab655773f15dbcfc0554b819902f" translate="yes" xml:space="preserve">
          <source>These options are deprecated. Use the above --notes/--no-notes options instead.</source>
          <target state="translated">이 옵션은 더 이상 사용되지 않습니다. 위의 --notes /-no-notes 옵션을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="894173daf027c82b1254f620d2cbbddacd04b7fd" translate="yes" xml:space="preserve">
          <source>These options are ignored for historical reasons.</source>
          <target state="translated">이러한 옵션은 역사적 이유로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0608f735748e7710136ac2ca4b1a8fc7f8d0f8a8" translate="yes" xml:space="preserve">
          <source>These options are mostly targeted for packing of Git repositories.</source>
          <target state="translated">이 옵션은 대부분 Git 리포지토리 패킹을 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="44fc7c2eb5b5d3f683db2d8973767b7defab9c76" translate="yes" xml:space="preserve">
          <source>These options are passed to &lt;a href=&quot;git-send-pack&quot;&gt;git-send-pack[1]&lt;/a&gt;. A thin transfer significantly reduces the amount of sent data when the sender and receiver share many of the same objects in common. The default is &lt;code&gt;--thin&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;git-send-pack&quot;&gt;git-send-pack [1]&lt;/a&gt; 로 전달됩니다 . 발신자와 수신자가 동일한 많은 객체를 공통으로 공유 할 때 씬 전송은 전송 된 데이터의 양을 크게 줄입니다. 기본값은 &lt;code&gt;--thin&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0c86ff6978b6c3146e6796c4f36abf160da0176d" translate="yes" xml:space="preserve">
          <source>These options can be used in an initial &lt;code&gt;clone&lt;/code&gt;, along with the &lt;code&gt;sync&lt;/code&gt; options described above.</source>
          <target state="translated">이러한 옵션은 위에서 설명한 &lt;code&gt;sync&lt;/code&gt; 옵션 과 함께 초기 &lt;code&gt;clone&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ade32a888d52a4ba127b2e5cb51121d4b067e67" translate="yes" xml:space="preserve">
          <source>These options can be used in the initial &lt;code&gt;clone&lt;/code&gt; as well as in subsequent &lt;code&gt;sync&lt;/code&gt; operations.</source>
          <target state="translated">이 옵션은 초기 &lt;code&gt;clone&lt;/code&gt; 및 후속 &lt;code&gt;sync&lt;/code&gt; 작업 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f45787718e6c314237aec0cf2c5e63156df92c4" translate="yes" xml:space="preserve">
          <source>These options can be used to modify &lt;code&gt;git p4 rebase&lt;/code&gt; behavior.</source>
          <target state="translated">이 옵션은 &lt;code&gt;git p4 rebase&lt;/code&gt; 동작 을 수정하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="046bf3cadb648529c8cbf517d3ba66246fc697fc" translate="yes" xml:space="preserve">
          <source>These options can be used to modify &lt;code&gt;git p4 submit&lt;/code&gt; behavior.</source>
          <target state="translated">이 옵션은 &lt;code&gt;git p4 submit&lt;/code&gt; 동작 을 수정하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5bf9264c3d2f29d27aed45b38db366aee6362601" translate="yes" xml:space="preserve">
          <source>These options control layout (defaults to &lt;code&gt;column&lt;/code&gt;). Setting any of these implies &lt;code&gt;always&lt;/code&gt; if none of &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;, or &lt;code&gt;auto&lt;/code&gt; are specified.</source>
          <target state="translated">이 옵션은 레이아웃을 제어합니다 (기본값은 &lt;code&gt;column&lt;/code&gt; ). 이들의 설정을 의미 &lt;code&gt;always&lt;/code&gt; 하나도 경우 &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;never&lt;/code&gt; , 또는 &lt;code&gt;auto&lt;/code&gt; 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="510a1cbefb424a60db8479a49dd55a0966d6d945" translate="yes" xml:space="preserve">
          <source>These options control when the feature should be enabled (defaults to &lt;code&gt;never&lt;/code&gt;):</source>
          <target state="translated">이 옵션은 기능을 활성화해야하는시기를 제어합니다 (기본값은 &lt;code&gt;never&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="931e215644554fa9404627a014bfd3cf51399ea5" translate="yes" xml:space="preserve">
          <source>These options take effect whatever the value of the &lt;code&gt;core.splitIndex&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.</source>
          <target state="translated">이 옵션은 &lt;code&gt;core.splitIndex&lt;/code&gt; 구성 변수 의 값에 관계없이 적용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). 그러나 구성된 값이 다음에 인덱스를 읽을 때 적용되고 옵션의 의도 된 효과가 제거되므로 구성된 값에 대한 변경이 발생하면 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="932e8c22c29966222600cac9510425979eeabd1c" translate="yes" xml:space="preserve">
          <source>These options take effect whatever the value of the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.</source>
          <target state="translated">이러한 옵션은 &lt;code&gt;core.untrackedCache&lt;/code&gt; 구성 변수 의 값에 관계없이 적용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). 그러나 구성된 값이 다음에 인덱스를 읽을 때 적용되고 옵션의 의도 된 효과가 제거되므로 구성된 값에 대한 변경이 발생하면 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ff7024be4fc3bd9a63ff1aab42e5c2f33080a5ad" translate="yes" xml:space="preserve">
          <source>These parameters can also be set individually with &lt;code&gt;--stat-width=&amp;lt;width&amp;gt;&lt;/code&gt;, &lt;code&gt;--stat-name-width=&amp;lt;name-width&amp;gt;&lt;/code&gt; and &lt;code&gt;--stat-count=&amp;lt;count&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 매개 변수는 &lt;code&gt;--stat-width=&amp;lt;width&amp;gt;&lt;/code&gt; , &lt;code&gt;--stat-name-width=&amp;lt;name-width&amp;gt;&lt;/code&gt; 및 &lt;code&gt;--stat-count=&amp;lt;count&amp;gt;&lt;/code&gt; 로 개별적으로 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25d97f197e2ad468ea791c831ca2e71054c4e207" translate="yes" xml:space="preserve">
          <source>These remote-tracking references can be deleted as a one-off with either of:</source>
          <target state="translated">이러한 원격 추적 참조는 다음 중 하나를 사용하여 일회용으로 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4994737bcfd88cfa54486bc85e99d5152416b798" translate="yes" xml:space="preserve">
          <source>These rules make it easy for shell script based tools to parse reference names, pathname expansion by the shell when a reference name is used unquoted (by mistake), and also avoid ambiguities in certain reference name expressions (see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;):</source>
          <target state="translated">이 규칙을 사용하면 쉘 스크립트 기반 도구가 참조 이름을 쉽게 구문 분석하고 참조 이름을 인용 부호없이 사용할 때 쉘에 의한 경로 이름 확장을 쉽게 할 수 있으며 특정 참조 이름 표현식에서 모호성을 피할 수 있습니다 ( &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d2d3b8bc5c27c38dddb2f7c9e54b52668c820483" translate="yes" xml:space="preserve">
          <source>These services can be enabled/disabled using the per-repository configuration file:</source>
          <target state="translated">이러한 서비스는 저장소 별 구성 파일을 사용하여 활성화 / 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11be9ffec744e4c727f505822229118ed50ca097" translate="yes" xml:space="preserve">
          <source>These services can be globally enabled/disabled using the command-line options of this command. If finer-grained control is desired (e.g. to allow &lt;code&gt;git archive&lt;/code&gt; to be run against only in a few selected repositories the daemon serves), the per-repository configuration file can be used to enable or disable them.</source>
          <target state="translated">이 서비스는이 명령의 명령 줄 옵션을 사용하여 전체적으로 활성화 / 비활성화 할 수 있습니다. 보다 세부적인 제어가 필요한 경우 (예 : 데몬이 제공하는 선택된 일부 리포지토리에서만 &lt;code&gt;git archive&lt;/code&gt; 를 실행할 수 있도록 ) 리포지토리 당 구성 파일을 사용하여 활성화 또는 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e7a1043f71fa1813c0b5e398e97710f483944d9" translate="yes" xml:space="preserve">
          <source>These things may exist in a Git repository.</source>
          <target state="translated">이러한 것들이 Git 저장소에 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5c7f688db050c92cfc9bb2aa9d676e52849ec7b" translate="yes" xml:space="preserve">
          <source>These three branches all forked from a common commit, [master], whose commit message is &quot;Add 'git show-branch'&quot;. The &quot;fixes&quot; branch adds one commit &quot;Introduce &quot;reset type&quot; flag to &quot;git reset&quot;&quot;. The &quot;mhf&quot; branch adds many other commits. The current branch is &quot;master&quot;.</source>
          <target state="translated">이 세 가지 분기는 모두 커밋 메시지가 &quot;Add 'git show-branch'&quot;인 공통 커밋 [master]에서 분기되었습니다. &quot;fixes&quot;브랜치는 하나의 커밋 &quot;&quot;reset type &quot;플래그를&quot;git reset &quot;에 추가합니다.&quot; &quot;mhf&quot;브랜치는 다른 많은 커밋을 추가합니다. 현재 지점은 &quot;마스터&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="c6204a9318b7a0526e46b8696b2eb378d52ecf11" translate="yes" xml:space="preserve">
          <source>These two filters behave differently, and by default, a filter is taken as the former, massaging the contents into more convenient shape. A missing filter driver definition in the config, or a filter driver that exits with a non-zero status, is not an error but makes the filter a no-op passthru.</source>
          <target state="translated">이 두 필터는 다르게 동작하며 기본적으로 필터는 전자로 사용되어 내용을보다 편리한 모양으로 마사지합니다. 구성에서 누락 된 필터 드라이버 정의 또는 0이 아닌 상태로 종료되는 필터 드라이버는 오류가 아니라 필터를 무 작동 패스 스루로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e20e46dc24b79b5218925e423850545226b0898e" translate="yes" xml:space="preserve">
          <source>These two options affect how the objects contained in the pack are stored using delta compression. The objects are first internally sorted by type, size and optionally names and compared against the other objects within --window to see if using delta compression saves space. --depth limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object.</source>
          <target state="translated">이 두 옵션은 팩에 포함 된 오브젝트가 델타 압축을 사용하여 저장되는 방법에 영향을줍니다. 객체는 유형, 크기 및 선택적으로 이름별로 내부적으로 정렬되어 델타 압축을 사용하여 공간이 절약되는지 확인하기 위해 --window 내의 다른 객체와 비교됩니다. --depth는 최대 델타 깊이를 제한합니다. 델타 데이터를 필요한 오브젝트에 도달하기 위해 여러 번 적용해야하기 때문에 너무 깊게 만들면 언 패커 측 성능에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="de212a952b72f4cd05af023bbd056fa8307c4a9f" translate="yes" xml:space="preserve">
          <source>These two options affect how the objects contained in the pack are stored using delta compression. The objects are first internally sorted by type, size and optionally names and compared against the other objects within &lt;code&gt;--window&lt;/code&gt; to see if using delta compression saves space. &lt;code&gt;--depth&lt;/code&gt; limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object.</source>
          <target state="translated">이 두 옵션은 팩에 포함 된 오브젝트가 델타 압축을 사용하여 저장되는 방법에 영향을줍니다. 객체는 유형, 크기 및 선택적으로 이름별로 내부적으로 정렬되어 델타 압축을 사용하여 공간이 절약되는지 확인하기 위해 &lt;code&gt;--window&lt;/code&gt; 내의 다른 객체와 비교 됩니다. &lt;code&gt;--depth&lt;/code&gt; 는 최대 델타 깊이를 제한합니다. 델타 데이터를 필요한 오브젝트에 도달하기 위해 여러 번 적용해야하기 때문에 너무 깊게하면 언 패커 측 성능에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="6a0bfaec1ca5ad5a0f6710f22f7b4b78eecfef67" translate="yes" xml:space="preserve">
          <source>These two syntaxes are mostly equivalent, except the former implies --local option.</source>
          <target state="translated">이 두 구문은 전자가 --local 옵션을 암시하는 것을 제외하고는 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9270307e15adf00d482cdebd8e068750f310bc87" translate="yes" xml:space="preserve">
          <source>These two syntaxes are mostly equivalent, except when cloning, when the former implies --local option. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; for details.</source>
          <target state="translated">이 두 구문은 복제 할 때를 제외하고 전자가 --local 옵션을 암시 할 때를 제외하고는 거의 동일합니다. 자세한 내용은 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="469e074d32a553c54f69af6603803ffbfd2e6dda" translate="yes" xml:space="preserve">
          <source>These types of entries are generally created as a result of using &lt;code&gt;git
commit --amend&lt;/code&gt; or &lt;code&gt;git rebase&lt;/code&gt; and are the commits prior to the amend or rebase occurring. Since these changes are not part of the current project most users will want to expire them sooner, which is why the default is more aggressive than &lt;code&gt;gc.reflogExpire&lt;/code&gt;.</source>
          <target state="translated">이러한 유형의 항목은 일반적으로 &lt;code&gt;git commit --amend&lt;/code&gt; 또는 &lt;code&gt;git rebase&lt;/code&gt; 를 사용한 결과로 작성되며 수정 또는 rebase가 발생하기 전에 커밋됩니다. 이러한 변경 사항은 현재 프로젝트의 일부가 아니므로 대부분의 사용자는 더 빨리 만료하려고하므로 기본값이 &lt;code&gt;gc.reflogExpire&lt;/code&gt; 보다 더 공격적인 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="99a10a0726ee032ba80815c05eceb6d5a6ab2aa8" translate="yes" xml:space="preserve">
          <source>These variables control various optional help messages designed to aid new users. All &lt;code&gt;advice.*&lt;/code&gt; variables default to &lt;code&gt;true&lt;/code&gt;, and you can tell Git that you do not need help by setting these to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">이 변수는 새로운 사용자를 돕기 위해 설계된 다양한 선택적 도움말 메시지를 제어합니다. 모든 &lt;code&gt;advice.*&lt;/code&gt; 변수는 기본적으로 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있으며, Git에게 이것들을 &lt;code&gt;false&lt;/code&gt; 로 설정하면 도움이 필요 없다고 말할 수있다 .</target>
        </trans-unit>
        <trans-unit id="289bbff1e27f0cf157d5208bbfcb9f369ecc1504" translate="yes" xml:space="preserve">
          <source>These variables obviate the need for command-line options in some circumstances, allowing easier restricted usage through git-shell.</source>
          <target state="translated">이러한 변수는 일부 상황에서 명령 줄 옵션이 필요하지 않으므로 git-shell을 통해 사용을보다 쉽게 ​​제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48d5c4b33cae3d35014b5a5e266ea897c2a18c9f" translate="yes" xml:space="preserve">
          <source>These will display all commits which exist only on HEAD or on MERGE_HEAD, and which touch an unmerged file.</source>
          <target state="translated">HEAD 또는 MERGE_HEAD에만 존재하며 병합되지 않은 파일을 건 드리는 모든 커밋이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e9ab0d9bdf3f35b7d6ece2d3bc65f4fbb38bad38" translate="yes" xml:space="preserve">
          <source>They are both passed directly to &lt;code&gt;git diff-tree&lt;/code&gt;; see &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree[1]&lt;/a&gt; for more information.</source>
          <target state="translated">둘 다 &lt;code&gt;git diff-tree&lt;/code&gt; 로 직접 전달됩니다 . 자세한 내용은 &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="afa16f632fa562fed5a34ad41431101aacb568d7" translate="yes" xml:space="preserve">
          <source>They can include slash &lt;code&gt;/&lt;/code&gt; for hierarchical (directory) grouping, but no slash-separated component can begin with a dot &lt;code&gt;.&lt;/code&gt; or end with the sequence &lt;code&gt;.lock&lt;/code&gt;.</source>
          <target state="translated">슬래시 &lt;code&gt;/&lt;/code&gt; 계층 적 (디렉토리) 그룹화를 포함 할 수 있지만 슬래시로 분리 된 구성 요소는 dot로 시작할 수 없습니다 &lt;code&gt;.&lt;/code&gt; 또는 시퀀스 &lt;code&gt;.lock&lt;/code&gt; 으로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="48a933f433abac80f2e0e41b240081f7a399893c" translate="yes" xml:space="preserve">
          <source>They cannot be the single character &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">단일 문자 &lt;code&gt;@&lt;/code&gt; 일 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c798a840110b095cd0c31cb10cad16c17f5292dd" translate="yes" xml:space="preserve">
          <source>They cannot begin or end with a slash &lt;code&gt;/&lt;/code&gt; or contain multiple consecutive slashes (see the &lt;code&gt;--normalize&lt;/code&gt; option below for an exception to this rule)</source>
          <target state="translated">그들은 시작이나 끝 슬래시로 수 &lt;code&gt;/&lt;/code&gt; 또는 여러 개의 연속 슬래시를 포함합니다 (참조 &lt;code&gt;--normalize&lt;/code&gt; 이 규칙에 예외 아래 옵션)</target>
        </trans-unit>
        <trans-unit id="794c847c2b033448497ba9e6f46f59b7325ccd69" translate="yes" xml:space="preserve">
          <source>They cannot contain a &lt;code&gt;\&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\&lt;/code&gt; 를 포함 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c4cf89d0a711867dbdfa498e7e6b80fb04c020f3" translate="yes" xml:space="preserve">
          <source>They cannot contain a sequence &lt;code&gt;@{&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@{&lt;/code&gt; 시퀀스를 포함 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c781dcfcbfa7c545717cc72f3f25ac7fba039fd7" translate="yes" xml:space="preserve">
          <source>They cannot end with a dot &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">그들은 점으로 끝날 수 없습니다 &lt;code&gt;.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdf3c698f8591838633d63d5550c41009f5d53bb" translate="yes" xml:space="preserve">
          <source>They cannot have ASCII control characters (i.e. bytes whose values are lower than \040, or \177 &lt;code&gt;DEL&lt;/code&gt;), space, tilde &lt;code&gt;~&lt;/code&gt;, caret &lt;code&gt;^&lt;/code&gt;, or colon &lt;code&gt;:&lt;/code&gt; anywhere.</source>
          <target state="translated">ASCII 제어 문자 (예 : 값이 \ 040 또는 \ 177 &lt;code&gt;DEL&lt;/code&gt; 보다 작은 바이트 ), 공백, 틸드 &lt;code&gt;~&lt;/code&gt; , 캐럿 &lt;code&gt;^&lt;/code&gt; 또는 콜론 &lt;code&gt;:&lt;/code&gt; 어디서나 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9fa9a35ba99f055f59e5fb0fc3903845af8141d1" translate="yes" xml:space="preserve">
          <source>They cannot have question-mark &lt;code&gt;?&lt;/code&gt;, asterisk &lt;code&gt;*&lt;/code&gt;, or open bracket &lt;code&gt;[&lt;/code&gt; anywhere. See the &lt;code&gt;--refspec-pattern&lt;/code&gt; option below for an exception to this rule.</source>
          <target state="translated">그들은 물음표를 가질 수 &lt;code&gt;?&lt;/code&gt; , 별표 &lt;code&gt;*&lt;/code&gt; 또는 열린 괄호 &lt;code&gt;[&lt;/code&gt; 어디서나 사용 가능합니다. 이 규칙에 대한 예외는 아래 의 &lt;code&gt;--refspec-pattern&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="07233de88d34b821d099ea14e09099281360fa3d" translate="yes" xml:space="preserve">
          <source>They cannot have two consecutive dots &lt;code&gt;..&lt;/code&gt; anywhere.</source>
          <target state="translated">그들은 두 개의 연속 된 점을 가질 수 없습니다 &lt;code&gt;..&lt;/code&gt; 어디.</target>
        </trans-unit>
        <trans-unit id="08cc7b3818b658e36c5e9a0a0fcefabb2c9bd5ce" translate="yes" xml:space="preserve">
          <source>They must contain at least one &lt;code&gt;/&lt;/code&gt;. This enforces the presence of a category like &lt;code&gt;heads/&lt;/code&gt;, &lt;code&gt;tags/&lt;/code&gt; etc. but the actual names are not restricted. If the &lt;code&gt;--allow-onelevel&lt;/code&gt; option is used, this rule is waived.</source>
          <target state="translated">그들은 적어도 하나의 메시지 있어야합니다 &lt;code&gt;/&lt;/code&gt; 을 . 이것은 &lt;code&gt;heads/&lt;/code&gt; , &lt;code&gt;tags/&lt;/code&gt; 등과 같은 카테고리의 존재를 강제 하지만 실제 이름은 제한되지 않습니다. 는 IF &lt;code&gt;--allow-onelevel&lt;/code&gt; 은 옵션을 사용,이 규칙은 면제됩니다.</target>
        </trans-unit>
        <trans-unit id="9c66e1086c1b783565f285e9f8d345796e4a920b" translate="yes" xml:space="preserve">
          <source>Things get more complicated if the &lt;code&gt;subsystem&lt;/code&gt; changes do not exactly correspond to the ones before the rebase.</source>
          <target state="translated">&lt;code&gt;subsystem&lt;/code&gt; 변경 사항이 리베이스 이전의 서브 시스템 변경 사항과 정확히 일치하지 않으면 상황이 더 복잡해집니다 .</target>
        </trans-unit>
        <trans-unit id="877bd5e347693a4c90610529b809f198ae203a8a" translate="yes" xml:space="preserve">
          <source>Think about how to create a clear chapter dependency graph that will allow people to get to important topics without necessarily reading everything in between.</source>
          <target state="translated">사람들이 반드시 사이에있는 모든 것을 읽지 않고도 중요한 주제에 도달 할 수있는 명확한 장 종속성 그래프를 작성하는 방법에 대해 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="5f03012af2a22f62503c31e1e064eb23ddd2be46" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;key&lt;/code&gt; will be used instead of &amp;lt;token&amp;gt; in the trailer. At the end of this key, a separator can appear and then some space characters. By default the only valid separator is &lt;code&gt;:&lt;/code&gt;, but this can be changed using the &lt;code&gt;trailer.separators&lt;/code&gt; config variable.</source>
          <target state="translated">이 &lt;code&gt;key&lt;/code&gt; 는 예고편에서 &amp;lt;토큰&amp;gt; 대신 사용됩니다. 이 키의 끝에 구분 기호가 나타난 다음 일부 공백 문자가 나타날 수 있습니다. 기본적으로 유일하게 유효한 구분자는 &lt;code&gt;:&lt;/code&gt; 이지만 &lt;code&gt;trailer.separators&lt;/code&gt; config 변수를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ed9ef222233001104259cd6ab7e0ea2e028dedb" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;merge&lt;/code&gt; can also be done by &lt;code&gt;pulling from her own remote-tracking branch&lt;/code&gt;, like this:</source>
          <target state="translated">이 &lt;code&gt;merge&lt;/code&gt; 은 다음과 같이 &lt;code&gt;pulling from her own remote-tracking branch&lt;/code&gt; 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0007248c88629a35b9fa8e1cf4c8fdf299191526" translate="yes" xml:space="preserve">
          <source>This accepts all options that &lt;code&gt;git svn fetch&lt;/code&gt; and &lt;code&gt;git rebase&lt;/code&gt; accept. However, &lt;code&gt;--fetch-all&lt;/code&gt; only fetches from the current [svn-remote], and not all [svn-remote] definitions.</source>
          <target state="translated">이것은 &lt;code&gt;git svn fetch&lt;/code&gt; 및 &lt;code&gt;git rebase&lt;/code&gt; 가 허용 하는 모든 옵션을 허용합니다. 그러나 &lt;code&gt;--fetch-all&lt;/code&gt; 은 모든 [svn-remote] 정의가 아니라 현재 [svn-remote]에서만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c118365ba0290d763b2d4e635fbfbb09d23e73e6" translate="yes" xml:space="preserve">
          <source>This action is disabled by default for performance reasons.</source>
          <target state="translated">이 작업은 성능상의 이유로 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="692de83ae64c152ace96a6b22c40c6c7b5256f5f" translate="yes" xml:space="preserve">
          <source>This adds a link titled &quot;graphiclog&quot; after the &quot;summary&quot; link, leading to &lt;code&gt;git-browser&lt;/code&gt; script, passing &lt;code&gt;r=&amp;lt;project&amp;gt;&lt;/code&gt; as a query parameter.</source>
          <target state="translated">&quot;summary&quot;링크 뒤에 &quot;graphiclog&quot;라는 제목의 링크가 추가되어 &lt;code&gt;git-browser&lt;/code&gt; 스크립트가 생성되어 &lt;code&gt;r=&amp;lt;project&amp;gt;&lt;/code&gt; 를 쿼리 매개 변수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="9647e1f610a9d28b74cedc3ffa625f5d98628ec8" translate="yes" xml:space="preserve">
          <source>This algorithm extends the patience algorithm to &quot;support low-occurrence common elements&quot;.</source>
          <target state="translated">이 알고리즘은 인내심 알고리즘을 &quot;낮은 발생 공통 요소 지원&quot;으로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="5f9e4d22cfa1bc9f924abb0f51a443db2655b318" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;git svn&lt;/code&gt; to re-map repository URLs and UUIDs from mirrors created using SVN::Mirror (or svk) for metadata.</source>
          <target state="translated">이를 통해 &lt;code&gt;git svn&lt;/code&gt; 은 메타 데이터를 위해 SVN :: Mirror (또는 svk)를 사용하여 생성 된 미러에서 리포지토리 URL과 UUID를 다시 매핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb552885bcd7df779f362e35a229c9d935657c60" translate="yes" xml:space="preserve">
          <source>This allows one to specify a Perl regular expression that will cause skipping of all matching paths from checkout from SVN. The &lt;code&gt;--ignore-paths&lt;/code&gt; option should match for every &lt;code&gt;fetch&lt;/code&gt; (including automatic fetches due to &lt;code&gt;clone&lt;/code&gt;, &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, etc) on a given repository.</source>
          <target state="translated">이것은 SVN의 체크 아웃에서 모든 일치하는 경로를 건너 뛰게하는 Perl 정규식을 지정할 수있게합니다. &lt;code&gt;--ignore-paths&lt;/code&gt; 옵션은 모든에 대해 일치해야합니다 &lt;code&gt;fetch&lt;/code&gt; (로 인해 포함하여 자동 인출 &lt;code&gt;clone&lt;/code&gt; , &lt;code&gt;dcommit&lt;/code&gt; , &lt;code&gt;rebase&lt;/code&gt; 주어진 저장소에, 등).</target>
        </trans-unit>
        <trans-unit id="bf5d12ceb1111e8b06bd58f3985472091a1cae12" translate="yes" xml:space="preserve">
          <source>This allows one to specify a Perl regular expression that will cause the inclusion of only matching paths from checkout from SVN. The &lt;code&gt;--include-paths&lt;/code&gt; option should match for every &lt;code&gt;fetch&lt;/code&gt; (including automatic fetches due to &lt;code&gt;clone&lt;/code&gt;, &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, etc) on a given repository. &lt;code&gt;--ignore-paths&lt;/code&gt; takes precedence over &lt;code&gt;--include-paths&lt;/code&gt;.</source>
          <target state="translated">이를 통해 SVN에서 체크 아웃 할 때 일치하는 경로 만 포함시키는 Perl 정규식을 지정할 수 있습니다. &lt;code&gt;--include-paths&lt;/code&gt; 옵션은 모든에 대해 일치해야합니다 &lt;code&gt;fetch&lt;/code&gt; (로 인해 포함하여 자동 인출 &lt;code&gt;clone&lt;/code&gt; , &lt;code&gt;dcommit&lt;/code&gt; , &lt;code&gt;rebase&lt;/code&gt; 주어진 저장소에, 등). &lt;code&gt;--ignore-paths&lt;/code&gt; 가 &lt;code&gt;--include-paths&lt;/code&gt; 보다 우선 합니다 .</target>
        </trans-unit>
        <trans-unit id="c68f089f9144bc4bdc1d710532bfa75a569d11ed" translate="yes" xml:space="preserve">
          <source>This allows one to specify a prefix which is prepended to the names of remotes if trunk/branches/tags are specified. The prefix does not automatically include a trailing slash, so be sure you include one in the argument if that is what you want. If --branches/-b is specified, the prefix must include a trailing slash. Setting a prefix (with a trailing slash) is strongly encouraged in any case, as your SVN-tracking refs will then be located at &quot;refs/remotes/$prefix/&lt;strong&gt;&quot;, which is compatible with Git&amp;rsquo;s own remote-tracking ref layout (refs/remotes/$remote/&lt;/strong&gt;). Setting a prefix is also useful if you wish to track multiple projects that share a common repository. By default, the prefix is set to &lt;code&gt;origin/&lt;/code&gt;.</source>
          <target state="translated">이를 통해 트렁크 / 분기 / 태그가 지정된 경우 원격의 이름 앞에 붙는 접두사를 지정할 수 있습니다. 접두사는 자동으로 슬래시를 포함하지 않으므로 원하는 경우 인수에 하나를 포함시켜야합니다. --branches / -b를 지정하면 접두사 뒤에 슬래시가 포함되어야합니다. SVN 추적 참조가 &quot;refs / remotes / $ prefix / &lt;strong&gt;&quot;에 위치하므로 Git의 자체 원격 추적 참조 레이아웃 (refs)과 호환되므로&lt;/strong&gt; 접두사 (후행 슬래시 포함)를 설정하는 것이 좋습니다. &lt;strong&gt;/ remotes / $ remote /&lt;/strong&gt; ). 공통 저장소를 공유하는 여러 프로젝트를 추적하려는 경우 접 두부를 설정하는 것도 유용합니다. 기본적으로 접두사는 &lt;code&gt;origin/&lt;/code&gt; 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="99b10fdeae941de841a9ac73e39b7c06fcc2d978" translate="yes" xml:space="preserve">
          <source>This allows revision ranges for partial/cauterized history to be supported. $NUMBER, $NUMBER1:$NUMBER2 (numeric ranges), $NUMBER:HEAD, and BASE:$NUMBER are all supported.</source>
          <target state="translated">이를 통해 부분 / 소화 이력에 대한 수정 범위를 지원할 수 있습니다. $ NUMBER, $ NUMBER1 : $ NUMBER2 (숫자 범위), $ NUMBER : HEAD 및 BASE : $ NUMBER가 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f18b167effc162d347deb782b83eab22ac73f014" translate="yes" xml:space="preserve">
          <source>This allows users to create repositories from alternate URLs. For example, an administrator could run &lt;code&gt;git svn&lt;/code&gt; on the server locally (accessing via file://) but wish to distribute the repository with a public http:// or svn:// URL in the metadata so users of it will see the public URL.</source>
          <target state="translated">이를 통해 사용자는 대체 URL에서 리포지토리를 만들 수 있습니다. 예를 들어, 관리자 는 서버에서 로컬로 &lt;code&gt;git svn&lt;/code&gt; 을 실행 (file : //를 통해 액세스) 할 수 있지만 메타 데이터에 공개 http : // 또는 svn : // URL을 사용하여 리포지토리를 배포하여 사용자가 공개 URL.</target>
        </trans-unit>
        <trans-unit id="86c4c002dbb35b192dee2247feadc27722ad842a" translate="yes" xml:space="preserve">
          <source>This application is a CVS emulation layer for Git.</source>
          <target state="translated">이 애플리케이션은 Git의 CVS 에뮬레이션 레이어입니다.</target>
        </trans-unit>
        <trans-unit id="8feea1468fa1fae814e84f89aca492fad30e5da4" translate="yes" xml:space="preserve">
          <source>This applies modifications from a hot-fix branch before each test run, e.g. in case your build or test environment changed so that older revisions may need a fix which newer ones have already. (Make sure the hot-fix branch is based off a commit which is contained in all revisions which you are bisecting, so that the merge does not pull in too much, or use &lt;code&gt;git cherry-pick&lt;/code&gt; instead of &lt;code&gt;git merge&lt;/code&gt;.)</source>
          <target state="translated">예를 들어 빌드 또는 테스트 환경이 변경되어 이전 개정판에 이미 수정 된 수정본이 필요할 수있는 경우와 같이 각 테스트 실행 전에 핫픽스 브랜치의 수정 사항이 적용됩니다. (핫픽스 브랜치는 bisecting하는 모든 개정판에 포함 된 커밋을 기반으로하여 병합이 너무 많이 걸리지 않도록하거나 &lt;code&gt;git merge&lt;/code&gt; 대신 &lt;code&gt;git cherry-pick&lt;/code&gt; 을 사용해야 합니다.)</target>
        </trans-unit>
        <trans-unit id="889d1277201779cf18582f69129975a9bf60d357" translate="yes" xml:space="preserve">
          <source>This applies to files added to the source branch &lt;strong&gt;after&lt;/strong&gt; a daughter branch was created: if previously no commit was made on the daughter branch they will erroneously be added to the daughter branch in git.</source>
          <target state="translated">이는 딸 브랜치가 생성 된 &lt;strong&gt;후&lt;/strong&gt; 소스 브랜치에 추가 된 파일에 적용됩니다 . 이전에 딸 브랜치에서 커밋이 수행되지 않은 경우 git의 딸 브랜치에 잘못 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="cd519f993fc33ca56b2cb882b0ae5ba8b983012d" translate="yes" xml:space="preserve">
          <source>This argument will not be passed to &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt;. Instead it sets the vhost field in the git:// service request (to rest of the argument). Default is not to send vhost in such request (if sent).</source>
          <target state="translated">이 인수는 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 로 전달되지 않습니다 . 대신 git : // 서비스 요청에서 vhost 필드를 설정합니다 (인수의 나머지 부분). 기본적으로 이러한 요청에서 vhost를 보내지 않습니다 (전송 된 경우).</target>
        </trans-unit>
        <trans-unit id="9535ee34f2074fa8e689413e0518f1d3faf71e7d" translate="yes" xml:space="preserve">
          <source>This argument will not be passed to &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt;. Instead, it will cause the helper to start by sending git:// service requests to the remote side with the service field set to an appropriate value and the repository field set to rest of the argument. Default is not to send such a request.</source>
          <target state="translated">이 인수는 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 로 전달되지 않습니다 . 대신, 서비스 필드가 적절한 값으로 설정되고 저장소 필드가 인수의 나머지 부분으로 설정된 상태에서 git : // 서비스 요청을 원격으로 전송하여 헬퍼가 시작되도록합니다. 기본적으로 그러한 요청을 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b50cd8ffcdc46b4b68ae7776a2b00f1d1183b6dd" translate="yes" xml:space="preserve">
          <source>This asks for all the history reachable from the given commit but not from any branch, tag, or other reference. If you decide it&amp;rsquo;s something you want, you can always create a new reference to it, e.g.,</source>
          <target state="translated">이것은 주어진 커밋에서 도달 할 수있는 모든 히스토리를 요청하지만 브랜치, 태그 또는 다른 참조는 아닙니다. 원하는 것으로 결정하면 언제든지 새로운 참조를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7efa4dea1c9da210003e0c08e382eb543f66cbf7" translate="yes" xml:space="preserve">
          <source>This attribute controls the length of conflict markers left in the work tree file during a conflicted merge. Only setting to the value to a positive integer has any meaningful effect.</source>
          <target state="translated">이 속성은 충돌 병합 중에 작업 트리 파일에 남아있는 충돌 마커의 길이를 제어합니다. 값을 양의 정수로 설정하면 의미있는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4caef1788f338fb02906a32b34bfb366a7539a3a" translate="yes" xml:space="preserve">
          <source>This attribute enables and controls end-of-line normalization. When a text file is normalized, its line endings are converted to LF in the repository. To control what line ending style is used in the working directory, use the &lt;code&gt;eol&lt;/code&gt; attribute for a single file and the &lt;code&gt;core.eol&lt;/code&gt; configuration variable for all text files. Note that setting &lt;code&gt;core.autocrlf&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;input&lt;/code&gt; overrides &lt;code&gt;core.eol&lt;/code&gt; (see the definitions of those options in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">이 속성은 줄 끝 정규화를 활성화하고 제어합니다. 텍스트 파일이 정규화되면 저장소의 줄 끝이 LF로 변환됩니다. 작업 디렉토리에서 사용되는 줄 끝 스타일을 제어하려면 단일 파일에 &lt;code&gt;eol&lt;/code&gt; 속성을 사용하고 모든 텍스트 파일에 &lt;code&gt;core.eol&lt;/code&gt; 구성 변수를 사용하십시오. &lt;code&gt;core.autocrlf&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;input&lt;/code&gt; 설정하면 core.eol 이 재정의 &lt;code&gt;core.eol&lt;/code&gt; ( &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 해당 옵션 정의 참조 ).</target>
        </trans-unit>
        <trans-unit id="9abb1dada669f4b282e87943eaa4c10d9676f824" translate="yes" xml:space="preserve">
          <source>This attribute sets a specific line-ending style to be used in the working directory. It enables end-of-line conversion without any content checks, effectively setting the &lt;code&gt;text&lt;/code&gt; attribute. Note that setting this attribute on paths which are in the index with CRLF line endings may make the paths to be considered dirty. Adding the path to the index again will normalize the line endings in the index.</source>
          <target state="translated">이 속성은 작업 디렉토리에서 사용할 특정 줄 끝 스타일을 설정합니다. 내용 확인없이 줄 끝 변환을 가능하게하여 &lt;code&gt;text&lt;/code&gt; 속성을 효과적으로 설정 합니다. CRLF 줄 끝으로 색인에있는 경로에이 속성을 설정하면 경로가 더티로 간주 될 수 있습니다. 색인에 경로를 다시 추가하면 색인의 줄 끝이 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="a95f413f93d421b5f0b609911f7201baca2aa2de" translate="yes" xml:space="preserve">
          <source>This automatically updates the rev_map if needed (see &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; in the FILES section below for details).</source>
          <target state="translated">필요한 경우 rev_map이 자동으로 업데이트됩니다 (자세한 내용은 아래 파일 섹션의 &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; GIT_DIR / svn / ** /. rev_map. * 참조).</target>
        </trans-unit>
        <trans-unit id="756e07e0622c048ffb322b306c002b3fe742a463" translate="yes" xml:space="preserve">
          <source>This behavior can be suppressed with the &lt;code&gt;--no-ff&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;--no-ff&lt;/code&gt; 옵션을 사용하면이 동작을 억제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ad430bc747d1916521d538bf94c1847176c4231" translate="yes" xml:space="preserve">
          <source>This behavior is the default when the start point is a remote-tracking branch. Set the branch.autoSetupMerge configuration variable to &lt;code&gt;false&lt;/code&gt; if you want &lt;code&gt;git switch&lt;/code&gt;, &lt;code&gt;git checkout&lt;/code&gt; and &lt;code&gt;git branch&lt;/code&gt; to always behave as if &lt;code&gt;--no-track&lt;/code&gt; were given. Set it to &lt;code&gt;always&lt;/code&gt; if you want this behavior when the start-point is either a local or remote-tracking branch.</source>
          <target state="translated">시작 지점이 원격 추적 분기 인 경우이 동작이 기본값입니다. 에 branch.autoSetupMerge 구성 변수 설정 &lt;code&gt;false&lt;/code&gt; 원하는 경우 &lt;code&gt;git switch&lt;/code&gt; , &lt;code&gt;git checkout&lt;/code&gt; 하고 &lt;code&gt;git branch&lt;/code&gt; 것처럼 항상 행동에 &lt;code&gt;--no-track&lt;/code&gt; 주어진합니다. 시작점이 로컬 또는 원격 추적 분기 일 때이 동작을 원하면 &lt;code&gt;always&lt;/code&gt; 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e589ab09a449c7cf7000e50f249deca2b148281c" translate="yes" xml:space="preserve">
          <source>This boolean will enable &lt;code&gt;fsync()&lt;/code&gt; when writing object files.</source>
          <target state="translated">이 부울은 객체 파일을 쓸 때 &lt;code&gt;fsync()&lt;/code&gt; 를 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="2a9d8bb8cd3e4996e1654fca8257ad2030d24d70" translate="yes" xml:space="preserve">
          <source>This breakage is of course most of the time unrelated to the breakage we are trying to locate in the commit graph. But it prevents us to know if the interesting &quot;bad behavior&quot; is present or not.</source>
          <target state="translated">이 파손은 물론 대부분 커밋 그래프에서 찾으려고하는 파손과 관련이 없습니다. 그러나 흥미로운 &quot;나쁜 행동&quot;이 있는지 아닌지를 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a7656b1b8b17aa91ea330f8fbedd0a75097faed" translate="yes" xml:space="preserve">
          <source>This bug has also been shown to affect non-symlink cases of replacing a directory with a file when it comes to the internal structures of the untracked cache, but no case has been reported where this resulted in wrong &quot;git status&quot; output.</source>
          <target state="translated">이 버그는 또한 추적되지 않은 캐시의 내부 구조와 관련하여 디렉토리를 파일로 바꾸는 심볼릭 링크가 아닌 경우에 영향을주는 것으로 나타 났지만 이로 인해 잘못된 &quot;git status&quot;출력이 발생한 경우는보고되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="bbb14e9c1a32bd1658d34b41d317e78fe3e2cf7e" translate="yes" xml:space="preserve">
          <source>This cache is meant to speed up commands that involve determining untracked files such as &lt;code&gt;git status&lt;/code&gt;.</source>
          <target state="translated">이 캐시는 &lt;code&gt;git status&lt;/code&gt; 와 같은 추적되지 않은 파일을 결정하는 명령의 속도를 높이기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="5e9291bab46bd7ea7a2a21b7e8d51146482ff7a6" translate="yes" xml:space="preserve">
          <source>This calculates the same as &lt;code&gt;--bisect&lt;/code&gt;, except that refs in &lt;code&gt;refs/bisect/&lt;/code&gt; are not used, and except that this outputs text ready to be eval&amp;rsquo;ed by the shell. These lines will assign the name of the midpoint revision to the variable &lt;code&gt;bisect_rev&lt;/code&gt;, and the expected number of commits to be tested after &lt;code&gt;bisect_rev&lt;/code&gt; is tested to &lt;code&gt;bisect_nr&lt;/code&gt;, the expected number of commits to be tested if &lt;code&gt;bisect_rev&lt;/code&gt; turns out to be good to &lt;code&gt;bisect_good&lt;/code&gt;, the expected number of commits to be tested if &lt;code&gt;bisect_rev&lt;/code&gt; turns out to be bad to &lt;code&gt;bisect_bad&lt;/code&gt;, and the number of commits we are bisecting right now to &lt;code&gt;bisect_all&lt;/code&gt;.</source>
          <target state="translated">동일한 계산이 &lt;code&gt;--bisect&lt;/code&gt; 에서 심판이 제외 &lt;code&gt;refs/bisect/&lt;/code&gt; 사용되지 않으며,이 준비가 출력 텍스트 쉘 eval'ed되는 것을 제외. 이 라인은 변수에 중간 개정의 이름을 지정합니다 &lt;code&gt;bisect_rev&lt;/code&gt; 후 테스트하고, 커밋의 예상 수를 &lt;code&gt;bisect_rev&lt;/code&gt; 가 테스트되고 &lt;code&gt;bisect_nr&lt;/code&gt; 경우 커밋의 예상 번호를 테스트 할, &lt;code&gt;bisect_rev&lt;/code&gt; 가 좋은 것으로 판명 &lt;code&gt;bisect_good&lt;/code&gt; 의 경우 커밋의 예상 번호를 테스트 할 &lt;code&gt;bisect_rev&lt;/code&gt; 판명가 나쁜 것으로 &lt;code&gt;bisect_bad&lt;/code&gt; 및 커밋의 수는 우리가 바로 지금 양분되어 &lt;code&gt;bisect_all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d3cf717b036e3b0e81df34e24d7ea082a035f6a" translate="yes" xml:space="preserve">
          <source>This can allow you to make partial mirrors when running fetch; but is generally not recommended because history will be skipped and lost.</source>
          <target state="translated">페치를 실행할 때 부분 미러를 만들 수 있습니다. 기록은 건너 뛰고 손실되므로 일반적으로 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="636e119b451b3bd7ccaf26b7d43733789f26ed19" translate="yes" xml:space="preserve">
          <source>This can also be set up as the default behaviour by using the &lt;code&gt;worktree.guessRemote&lt;/code&gt; config option.</source>
          <target state="translated">&lt;code&gt;worktree.guessRemote&lt;/code&gt; 구성 옵션 을 사용하여 기본 동작으로 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa409f68e80081ea9a669e9f13a5d077543254ef" translate="yes" xml:space="preserve">
          <source>This can be &lt;code&gt;end&lt;/code&gt;, which is the default, &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt; or &lt;code&gt;before&lt;/code&gt;.</source>
          <target state="translated">이 값은 &lt;code&gt;end&lt;/code&gt; 일 수 있으며 기본값은 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;after&lt;/code&gt; 또는 &lt;code&gt;before&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0de02388f102cf8ff32d10ea0ea1542e4435ae39" translate="yes" xml:space="preserve">
          <source>This can be any options that the archiver backend understands. See next section.</source>
          <target state="translated">아카이버 백엔드가 이해하는 모든 옵션이 될 수 있습니다. 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8ebe928ea2c46867d2d30a22aa44b6d209b60b27" translate="yes" xml:space="preserve">
          <source>This can be combined with the gitweb configuration:</source>
          <target state="translated">이것은 gitweb 설정과 결합 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3e2aafd0fe68d162abd0214f2c4dbcf97a317242" translate="yes" xml:space="preserve">
          <source>This can be enabled by default with the configuration option mailinfo.scissors.</source>
          <target state="translated">mailinfo.scissors 구성 옵션을 사용하여 기본적으로 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90b17ef61d05f77323fefc823815f1b4d0ca5c24" translate="yes" xml:space="preserve">
          <source>This can be set to a comma-separated list of strings. When a curl trace is enabled (see &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; above), whenever a &quot;Cookies:&quot; header sent by the client is dumped, values of cookies whose key is in that list (case-sensitive) are redacted.</source>
          <target state="translated">쉼표로 구분 된 문자열 목록으로 설정할 수 있습니다. 컬 추적이 활성화되면 ( 위의 &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; 참조) 클라이언트가 보낸 &quot;Cookies :&quot;헤더가 덤프 될 때마다 키가 해당 목록에있는 쿠키 값 (대소 문자 구분)이 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="3d49143ca76086473ec42d2280fe45285788984b" translate="yes" xml:space="preserve">
          <source>This can be used to color the metadata of a blame line depending on age of the line.</source>
          <target state="translated">라인의 나이에 따라 비난 라인의 메타 데이터를 채색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f9fdab39f98d82a2bdc74c13a484288c9af48d4" translate="yes" xml:space="preserve">
          <source>This can be used to convert arguments to a command run in a subdirectory so that they can still be used after moving to the top-level of the repository. For example:</source>
          <target state="translated">서브 디렉토리에서 실행되는 명령으로 인수를 변환하여 저장소의 최상위 레벨로 이동 한 후에도 계속 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c4f04c6d6345aed6141f4d5502d056991a7840c" translate="yes" xml:space="preserve">
          <source>This can be used when you want to include further changes to the merge, or want to write your own merge commit message.</source>
          <target state="translated">병합에 대한 추가 변경 사항을 포함 시키거나 자신의 병합 커밋 메시지를 작성하려고 할 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14d1ead4268c0c0f3315fceadadaf2f291770d82" translate="yes" xml:space="preserve">
          <source>This can be used with the &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;tag&lt;/code&gt; commands.</source>
          <target state="translated">이것은 &lt;code&gt;dcommit&lt;/code&gt; , &lt;code&gt;rebase&lt;/code&gt; , &lt;code&gt;branch&lt;/code&gt; 및 &lt;code&gt;tag&lt;/code&gt; 명령 과 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9067f207a93cdcf6d90b3183367a4ae6097c31d6" translate="yes" xml:space="preserve">
          <source>This can be useful when you want to publish the tree from a commit without exposing its full history. You might want to do this to publish an open source branch of a project whose current tree is &quot;clean&quot;, but whose full history contains proprietary or otherwise encumbered bits of code.</source>
          <target state="translated">이것은 전체 히스토리를 공개하지 않고 커밋에서 트리를 공개하려는 경우에 유용 할 수 있습니다. 현재 트리가 &quot;깨끗&quot;하지만 전체 히스토리에 독점적이거나 복잡하지 않은 코드 비트가 포함 된 프로젝트의 오픈 소스 분기를 공개하기 위해이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ddcbb1d5b5e22f922e078b6b0d84fe1dcc0409b" translate="yes" xml:space="preserve">
          <source>This can happen, for example, if you:</source>
          <target state="translated">예를 들어 다음과 같은 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9140f80526c6eb06ff98ed4abf5c0d2e07067266" translate="yes" xml:space="preserve">
          <source>This can only resolve two heads (i.e. the current branch and another branch you pulled from) using a 3-way merge algorithm. It tries to carefully detect criss-cross merge ambiguities and is considered generally safe and fast.</source>
          <target state="translated">이 방법은 3 방향 병합 알고리즘을 사용하여 두 개의 헤드 (즉, 현재 분기 및 가져온 다른 분기) 만 해결할 수 있습니다. 십자 병합 모호성을 신중하게 감지하려고 시도하며 일반적으로 안전하고 빠른 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="10679b433b60fbaff0452d6d903b314fee5164d2" translate="yes" xml:space="preserve">
          <source>This can only resolve two heads using a 3-way merge algorithm. When there is more than one common ancestor that can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3-way merge. This has been reported to result in fewer merge conflicts without causing mismerges by tests done on actual merge commits taken from Linux 2.6 kernel development history. Additionally this can detect and handle merges involving renames, but currently cannot make use of detected copies. This is the default merge strategy when pulling or merging one branch.</source>
          <target state="translated">이 방법은 3 방향 병합 알고리즘을 사용하여 두 헤드 만 해결할 수 있습니다. 3 방향 병합에 사용할 수있는 공통 조상이 둘 이상있는 경우 공통 조상의 병합 된 트리를 작성하고이를 3 방향 병합의 참조 트리로 사용합니다. 이는 Linux 2.6 커널 개발 히스토리에서 가져온 실제 병합 커밋에서 수행 된 테스트로 인한 혼란을 유발하지 않으면 서 병합 충돌을 줄이는 것으로보고되었습니다. 또한 이름 변경과 관련된 병합을 감지하고 처리 할 수 ​​있지만 현재는 감지 된 사본을 사용할 수 없습니다. 하나의 브랜치를 가져 오거나 병합 할 때의 기본 병합 전략입니다.</target>
        </trans-unit>
        <trans-unit id="2cac39aeb86961e1363f7613dfed0033661ab943" translate="yes" xml:space="preserve">
          <source>This can speed up operations like &lt;code&gt;git diff&lt;/code&gt; and &lt;code&gt;git status&lt;/code&gt; especially on filesystems like NFS that have weak caching semantics and thus relatively high IO latencies. When enabled, Git will do the index comparison to the filesystem data in parallel, allowing overlapping IO&amp;rsquo;s. Defaults to true.</source>
          <target state="translated">이것은 캐싱 시맨틱이 약하고 따라서 상대적으로 높은 IO 대기 시간을 갖는 NFS와 같은 파일 시스템에서 특히 &lt;code&gt;git diff&lt;/code&gt; 및 &lt;code&gt;git status&lt;/code&gt; 와 같은 작업의 속도를 높일 수 있습니다 . 활성화되면 Git은 파일 시스템 데이터와 병렬로 인덱스를 비교하여 IO가 겹치게합니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="9202266152fd1a0a2194149286bebd74fe30a95c" translate="yes" xml:space="preserve">
          <source>This capability can be advertised multiple times. The first applicable refspec takes precedence. The left-hand of refspecs advertised with this capability must cover all refs reported by the list command. If no &lt;code&gt;refspec&lt;/code&gt; capability is advertised, there is an implied &lt;code&gt;refspec *:*&lt;/code&gt;.</source>
          <target state="translated">이 기능은 여러 번 보급 될 수 있습니다. 적용 가능한 첫 번째 참조 스펙이 우선합니다. 이 기능으로 광고 된 참조 사양의 왼쪽은 list 명령으로보고 된 모든 참조를 포함해야합니다. &lt;code&gt;refspec&lt;/code&gt; 기능이 알려지지 않은 경우 &lt;code&gt;refspec *:*&lt;/code&gt; 가 내포 됩니다.</target>
        </trans-unit>
        <trans-unit id="561397ab0857a5bada65e17ac4aabd661a6939b5" translate="yes" xml:space="preserve">
          <source>This chapter covers internal details of the Git implementation which probably only Git developers need to understand.</source>
          <target state="translated">이 장에서는 Git 개발자 만 이해해야하는 Git 구현에 대한 내부 세부 사항을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="9301665301f3e50c4417122a8411be226ea5b235" translate="yes" xml:space="preserve">
          <source>This command always gets all objects. Historically, there were three options &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-t&lt;/code&gt; for choosing which objects to download. They are now silently ignored.</source>
          <target state="translated">이 명령은 항상 모든 객체를 가져옵니다. 역사적 으로 다운로드 할 객체를 선택하기위한 세 가지 옵션 &lt;code&gt;-a&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-t&lt;/code&gt; 가있었습니다 . 이제는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5b8a59dc9ca3a3d6f247d36df5fb54708fa69494" translate="yes" xml:space="preserve">
          <source>This command applies the patch but does not create a commit. Use &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; to create commits from patches generated by &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; and/or received by email.</source>
          <target state="translated">이 명령은 패치를 적용하지만 커밋을 생성하지는 않습니다. 사용 &lt;a href=&quot;git-am&quot;&gt;자식-AM [1]&lt;/a&gt; 에 의해 생성 된 패치에서 커밋 생성하는 &lt;a href=&quot;git-format-patch&quot;&gt;자식 형식의 패치 [1]&lt;/a&gt; 및 / 또는 이메일로 접수합니다.</target>
        </trans-unit>
        <trans-unit id="1f849e1e7df08a5bb28860e4715d22e12f5d5d20" translate="yes" xml:space="preserve">
          <source>This command assists the developer in this process by recording conflicted automerge results and corresponding hand resolve results on the initial manual merge, and applying previously recorded hand resolutions to their corresponding automerge results.</source>
          <target state="translated">이 명령은 충돌 된 자동 병합 결과 및 해당 손 해결 결과를 초기 수동 병합에 기록하고 이전에 기록 된 손 해상도를 해당 자동 병합 결과에 적용하여이 프로세스에서 개발자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b823d02fd766a4ae4b81090ce369454e7da568d6" translate="yes" xml:space="preserve">
          <source>This command caches credentials in memory for use by future Git programs. The stored credentials never touch the disk, and are forgotten after a configurable timeout. The cache is accessible over a Unix domain socket, restricted to the current user by filesystem permissions.</source>
          <target state="translated">이 명령은 향후 Git 프로그램에서 사용할 수 있도록 자격 증명을 메모리에 캐시합니다. 저장된 자격 증명은 디스크를 건드리지 않으며 구성 가능한 시간 초과 후 잊어 버립니다. 캐시는 Unix 도메인 소켓을 통해 액세스 할 수 있으며 파일 시스템 권한으로 현재 사용자로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="4784337d21599fe7fcfddcd79392d8470207170e" translate="yes" xml:space="preserve">
          <source>This command can be performed multiple times before a commit. It only adds the content of the specified file(s) at the time the add command is run; if you want subsequent changes included in the next commit, then you must run &lt;code&gt;git add&lt;/code&gt; again to add the new content to the index.</source>
          <target state="translated">이 명령은 커밋 전에 여러 번 수행 할 수 있습니다. add 명령이 실행될 때 지정된 파일의 내용 만 추가합니다. 다음 커밋에 후속 변경 사항을 포함하려면 &lt;code&gt;git add&lt;/code&gt; 를 다시 실행 하여 새 내용을 인덱스에 추가 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c286ab165ab2a31532b621372beb627366820ec4" translate="yes" xml:space="preserve">
          <source>This command can be used where a &lt;code&gt;filemodify&lt;/code&gt; directive can appear, allowing it to be used in the middle of a commit. For a &lt;code&gt;filemodify&lt;/code&gt; using an inline directive, it can also appear right before the &lt;code&gt;data&lt;/code&gt; directive.</source>
          <target state="translated">이 명령은 &lt;code&gt;filemodify&lt;/code&gt; 지시문이 나타날 수 있는 곳에서 사용될 수 있으며 , 커밋 도중에 사용될 수 있습니다. 인라인 지시문을 사용 하는 파일 &lt;code&gt;filemodify&lt;/code&gt; 경우 &lt;code&gt;data&lt;/code&gt; 지시문 바로 앞에 나타날 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74e4352fd2289d447be4133ac0e6d68d162428a6" translate="yes" xml:space="preserve">
          <source>This command can run &lt;code&gt;applypatch-msg&lt;/code&gt;, &lt;code&gt;pre-applypatch&lt;/code&gt;, and &lt;code&gt;post-applypatch&lt;/code&gt; hooks. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more information.</source>
          <target state="translated">이 명령은 &lt;code&gt;applypatch-msg&lt;/code&gt; , &lt;code&gt;pre-applypatch&lt;/code&gt; 및 &lt;code&gt;post-applypatch&lt;/code&gt; 훅을 실행할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2e5610ce87e5d01d8f8246892b4f05f886b6ad5a" translate="yes" xml:space="preserve">
          <source>This command can run &lt;code&gt;commit-msg&lt;/code&gt;, &lt;code&gt;prepare-commit-msg&lt;/code&gt;, &lt;code&gt;pre-commit&lt;/code&gt;, &lt;code&gt;post-commit&lt;/code&gt; and &lt;code&gt;post-rewrite&lt;/code&gt; hooks. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more information.</source>
          <target state="translated">이 명령은 &lt;code&gt;commit-msg&lt;/code&gt; , &lt;code&gt;prepare-commit-msg&lt;/code&gt; , &lt;code&gt;pre-commit&lt;/code&gt; , &lt;code&gt;post-commit&lt;/code&gt; 및 &lt;code&gt;post-rewrite&lt;/code&gt; hooks를 실행할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6ba8d48bf258fdf0b61e4a3a7667022fd45b3e45" translate="yes" xml:space="preserve">
          <source>This command creates an empty Git repository - basically a &lt;code&gt;.git&lt;/code&gt; directory with subdirectories for &lt;code&gt;objects&lt;/code&gt;, &lt;code&gt;refs/heads&lt;/code&gt;, &lt;code&gt;refs/tags&lt;/code&gt;, and template files. An initial &lt;code&gt;HEAD&lt;/code&gt; file that references the HEAD of the master branch is also created.</source>
          <target state="translated">이 명령은 빈 Git 리포지토리 (기본적으로 &lt;code&gt;objects&lt;/code&gt; , 참조 &lt;code&gt;refs/heads&lt;/code&gt; , 참조 &lt;code&gt;refs/tags&lt;/code&gt; 및 템플릿 파일의 하위 디렉토리가 있는 &lt;code&gt;.git&lt;/code&gt; 디렉토리)를 만듭니다. 마스터 분기의 HEAD를 참조 하는 초기 &lt;code&gt;HEAD&lt;/code&gt; 파일도 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="f52be87adec196973421cd7319ee0f98c1860983" translate="yes" xml:space="preserve">
          <source>This command degenerates to download everything to complete the asked refs from the remote side when the local side does not have a common ancestor commit.</source>
          <target state="translated">이 명령은 로컬 측에 공통 조상 커밋이없는 경우 원격 측에서 요청 된 참조를 완료하기 위해 모든 것을 다운로드하도록 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="194b70091800ec19021441e8c1778ca9e02b53d5" translate="yes" xml:space="preserve">
          <source>This command ensures that the changes in the experimental branch are already in the current branch.</source>
          <target state="translated">이 명령은 실험 브랜치의 변경 사항이 이미 현재 브랜치에 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1b788d383418fe8b134f7630991a2d6359c7dd7c" translate="yes" xml:space="preserve">
          <source>This command finds new changes in p4 and imports them as Git commits.</source>
          <target state="translated">이 명령은 p4에서 새로운 변경 사항을 찾고 Git 커밋으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4b11fc8efec3bd343a83e9f1aa4620a514b9ab8e" translate="yes" xml:space="preserve">
          <source>This command formats the lines of its standard input into a table with multiple columns. Each input line occupies one cell of the table. It is used internally by other git commands to format output into columns.</source>
          <target state="translated">이 명령은 표준 입력 행을 여러 열이있는 테이블로 형식화합니다. 각 입력 라인은 테이블의 하나의 셀을 차지합니다. 출력을 열로 형식화하기 위해 다른 git 명령에 의해 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ade7fdc971ed1f0936fb8fbff7bb1574367ca37b" translate="yes" xml:space="preserve">
          <source>This command is extremely useful if the frontend does not know (or does not care to know) what files are currently on the branch, and therefore cannot generate the proper &lt;code&gt;filedelete&lt;/code&gt; commands to update the content.</source>
          <target state="translated">이 명령은 프론트 엔드가 현재 브랜치에있는 파일을 알지 못하거나 알지 못하는 경우에 매우 유용하므로 컨텐츠를 업데이트하기 위해 적절한 &lt;code&gt;filedelete&lt;/code&gt; 명령을 생성 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5f45dc9e63088b4d8e620891decbfdd6655de376" translate="yes" xml:space="preserve">
          <source>This command is intended mostly for internal use by scripts automatically invoking &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">이 명령은 주로 &lt;code&gt;git merge&lt;/code&gt; 를 자동으로 호출하는 스크립트에 의해 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3710225b15829bc8cbeb92895b81ff709286e645" translate="yes" xml:space="preserve">
          <source>This command is recursive by default.</source>
          <target state="translated">이 명령은 기본적으로 재귀 적입니다.</target>
        </trans-unit>
        <trans-unit id="6e8668d616c8790cb8d71e8720597de54ced7850" translate="yes" xml:space="preserve">
          <source>This command is used to combine all objects that do not currently reside in a &quot;pack&quot;, into a pack. It can also be used to re-organize existing packs into a single, more efficient pack.</source>
          <target state="translated">이 명령은 현재 &quot;팩&quot;에없는 모든 오브젝트를 팩으로 결합하는 데 사용됩니다. 또한 기존 팩을보다 효율적인 단일 팩으로 재구성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7cbc44be580e3c1734536d3564c4b9dc7e501fa" translate="yes" xml:space="preserve">
          <source>This command is used to solve the storage and performance problem by storing the refs in a single file, &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt;. When a ref is missing from the traditional &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory hierarchy, it is looked up in this file and used if found.</source>
          <target state="translated">이 명령은 참조를 단일 파일 &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; 에 저장하여 스토리지 및 성능 문제를 해결하는 데 사용됩니다 . 기존 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 디렉토리 계층 에서 참조가 누락 된 경우이 파일에서 참조가 발견되면 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="43f707239bbecf8d6bf96bbdb4b367abb8fd5357" translate="yes" xml:space="preserve">
          <source>This command is usually not invoked directly by the end user. The UI for the protocol is on the &lt;code&gt;git archive&lt;/code&gt; side, and the program pair is meant to be used to get an archive from a remote repository.</source>
          <target state="translated">이 명령은 일반적으로 최종 사용자가 직접 호출하지 않습니다. 프로토콜의 UI는 &lt;code&gt;git archive&lt;/code&gt; 측에 있으며 프로그램 쌍은 원격 저장소에서 아카이브를 가져 오는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="17d67b43408b7b4804e33e1e3b79dc1fbf03af1b" translate="yes" xml:space="preserve">
          <source>This command is usually not invoked directly by the end user. The UI for the protocol is on the &lt;code&gt;git fetch-pack&lt;/code&gt; side, and the program pair is meant to be used to pull updates from a remote repository. For push operations, see &lt;code&gt;git send-pack&lt;/code&gt;.</source>
          <target state="translated">이 명령은 일반적으로 최종 사용자가 직접 호출하지 않습니다. 프로토콜의 UI는 &lt;code&gt;git fetch-pack&lt;/code&gt; 쪽에 있으며 프로그램 쌍은 원격 저장소에서 업데이트를 가져 오는 데 사용됩니다. 푸시 조작에 대해서는 &lt;code&gt;git send-pack&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="36ac8b84f92c3cf141e5ae101adcc45178aae4c7" translate="yes" xml:space="preserve">
          <source>This command is usually not invoked directly by the end user. The UI for the protocol is on the &lt;code&gt;git send-pack&lt;/code&gt; side, and the program pair is meant to be used to push updates to remote repository. For pull operations, see &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt;.</source>
          <target state="translated">이 명령은 일반적으로 최종 사용자가 직접 호출하지 않습니다. 프로토콜의 UI는 &lt;code&gt;git send-pack&lt;/code&gt; 쪽에 있으며 프로그램 쌍은 업데이트를 원격 저장소로 푸시하는 데 사용됩니다. 풀 조작에 대해서는 &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8cac5b996748b602d2e8f0cf9273cee3d1c4d80" translate="yes" xml:space="preserve">
          <source>This command lets you check that intermediate commits are compilable. The todo list becomes like that:</source>
          <target state="translated">이 명령을 사용하면 중간 커밋이 컴파일 가능한지 확인할 수 있습니다. 할 일 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56bca57be11add071b8aeae38f6a28f443105856" translate="yes" xml:space="preserve">
          <source>This command manages the information recorded in the reflogs.</source>
          <target state="translated">이 명령은 참조 로그에 기록 된 정보를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="7c7ebb85111dd101dc1c2782f6e5cbc235a39c44" translate="yes" xml:space="preserve">
          <source>This command provides a way to interact with p4 repositories using Git.</source>
          <target state="translated">이 명령은 Git을 사용하여 p4 리포지토리와 상호 작용하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="637c92f99feb8b30861eeaee2e3273c64a9b5351" translate="yes" xml:space="preserve">
          <source>This command reads some patches or commit messages from either the &amp;lt;file&amp;gt; arguments or the standard input if no &amp;lt;file&amp;gt; is specified. If &lt;code&gt;--parse&lt;/code&gt; is specified, the output consists of the parsed trailers.</source>
          <target state="translated">이 명령은 &amp;lt;file&amp;gt; 인수 또는 &amp;lt;file&amp;gt;이 지정되지 않은 경우 표준 입력에서 일부 패치 또는 커밋 메시지를 읽습니다. 경우 &lt;code&gt;--parse&lt;/code&gt; 가 지정, 출력은 구문 분석 된 트레일러로 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a38646d64359b52991af1358c674765acf2c0c11" translate="yes" xml:space="preserve">
          <source>This command should not list any commits. Otherwise, check out &lt;code&gt;master&lt;/code&gt; and merge &lt;code&gt;maint&lt;/code&gt; into it.</source>
          <target state="translated">이 명령은 커밋을 나열하지 않아야합니다. 그렇지 않으면 &lt;code&gt;master&lt;/code&gt; 를 확인하고 &lt;code&gt;maint&lt;/code&gt; 을 병합 하십시오.</target>
        </trans-unit>
        <trans-unit id="6a853b09f1818b9d32f936bd42aa8a84af13b068" translate="yes" xml:space="preserve">
          <source>This command shows the differences between two versions of a patch series, or more generally, two commit ranges (ignoring merge commits).</source>
          <target state="translated">이 명령은 패치 시리즈의 두 버전 또는보다 일반적으로 두 커밋 범위 (병합 커밋 무시)의 차이점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="852903a68075d19a47d4520af94edde77996207f" translate="yes" xml:space="preserve">
          <source>This command stores credentials indefinitely on disk for use by future Git programs.</source>
          <target state="translated">이 명령은 향후 Git 프로그램에서 사용할 수 있도록 자격 증명을 디스크에 무기한 저장합니다.</target>
        </trans-unit>
        <trans-unit id="d143bf10d727fe2f5d0639ed85e199dd448d8bd2" translate="yes" xml:space="preserve">
          <source>This command updates the index using the current content found in the working tree, to prepare the content staged for the next commit. It typically adds the current content of existing paths as a whole, but with some options it can also be used to add content with only part of the changes made to the working tree files applied, or remove paths that do not exist in the working tree anymore.</source>
          <target state="translated">이 명령은 다음 커밋을 위해 준비된 내용을 준비하기 위해 작업 트리에있는 현재 내용을 사용하여 색인을 업데이트합니다. 일반적으로 기존 경로의 현재 내용을 전체적으로 추가하지만 일부 옵션을 사용하면 적용된 작업 트리 파일의 변경 내용 중 일부만 적용하거나 작업 트리에 존재하지 않는 경로를 제거하는 데 사용할 수도 있습니다 더 이상</target>
        </trans-unit>
        <trans-unit id="61eacd31ecbd262bdcbed11d9c6103318919d1be" translate="yes" xml:space="preserve">
          <source>This command uploads a mailbox generated with &lt;code&gt;git format-patch&lt;/code&gt; into an IMAP drafts folder. This allows patches to be sent as other email is when using mail clients that cannot read mailbox files directly. The command also works with any general mailbox in which emails have the fields &quot;From&quot;, &quot;Date&quot;, and &quot;Subject&quot; in that order.</source>
          <target state="translated">이 명령은 &lt;code&gt;git format-patch&lt;/code&gt; 로 생성 된 메일 함을 IMAP 초안 폴더에 업로드 합니다. 메일 함 파일을 직접 읽을 수없는 메일 클라이언트를 사용할 때 다른 이메일로 패치를 보낼 수 있습니다. 이 명령은 전자 메일에 &quot;보낸 사람&quot;, &quot;날짜&quot;및 &quot;제목&quot;필드가 순서대로있는 일반 사서함에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a3bcbdfcf8f3a072ac23f24cf310648f9691fb70" translate="yes" xml:space="preserve">
          <source>This command uses a binary search algorithm to find which commit in your project&amp;rsquo;s history introduced a bug. You use it by first telling it a &quot;bad&quot; commit that is known to contain the bug, and a &quot;good&quot; commit that is known to be before the bug was introduced. Then &lt;code&gt;git
bisect&lt;/code&gt; picks a commit between those two endpoints and asks you whether the selected commit is &quot;good&quot; or &quot;bad&quot;. It continues narrowing down the range until it finds the exact commit that introduced the change.</source>
          <target state="translated">이 명령은 이진 검색 알고리즘을 사용하여 프로젝트 기록에서 어떤 커밋에 버그가 발생했는지 확인합니다. 먼저 버그를 포함하는 것으로 알려진 &quot;나쁜&quot;커밋과 버그가 소개되기 전에 알려진 &quot;좋은&quot;커밋을 알려서이 도구를 사용합니다. 그런 다음 &lt;code&gt;git bisect&lt;/code&gt; 는이 두 끝점 사이에서 커밋을 선택하고 선택한 커밋이 &quot;양호&quot;인지 &quot;나쁜&quot;것인지 묻습니다. 변경을 도입 한 정확한 커밋을 찾을 때까지 범위를 계속 좁 힙니다.</target>
        </trans-unit>
        <trans-unit id="097f8af4b6f26b418927a5ca4b24d71746b1f843" translate="yes" xml:space="preserve">
          <source>This command uses the &lt;code&gt;diff.color.*&lt;/code&gt; and &lt;code&gt;pager.range-diff&lt;/code&gt; settings (the latter is on by default). See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">이 명령은 &lt;code&gt;diff.color.*&lt;/code&gt; 및 &lt;code&gt;pager.range-diff&lt;/code&gt; 설정을 사용합니다 (후자는 기본적으로 켜져 있음). &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="03bab6a03561ee7ff2e9bf92505bcdd5322bfb51" translate="yes" xml:space="preserve">
          <source>This command will fail with non-zero status upon error. Some exit codes are:</source>
          <target state="translated">이 명령은 오류시 0이 아닌 상태로 실패합니다. 일부 종료 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ed6af6e5518c122d94f4b8fea824fc7938bd5aa" translate="yes" xml:space="preserve">
          <source>This command will fetch changes from the remote branches to your remote-tracking branches &lt;code&gt;origin/*&lt;/code&gt;, and merge the default branch into the current branch.</source>
          <target state="translated">이 명령은 원격 브랜치에서 원격 추적 브랜치 &lt;code&gt;origin/*&lt;/code&gt; 로 변경 사항을 가져오고 기본 브랜치를 현재 브랜치로 병합합니다.</target>
        </trans-unit>
        <trans-unit id="99c24081605f25434a1fa0a51df82045bf4b7763" translate="yes" xml:space="preserve">
          <source>This command will save your changes away to the &lt;code&gt;stash&lt;/code&gt;, and reset your working tree and the index to match the tip of your current branch. Then you can make your fix as usual.</source>
          <target state="translated">이 명령은 변경 사항을 &lt;code&gt;stash&lt;/code&gt; 저장 하고 작업 트리와 색인을 현재 분기의 끝과 일치하도록 재설정합니다. 그런 다음 평소와 같이 수정을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb41b9bb98cbe715b8d6c0b50eb0b52309cdc91a" translate="yes" xml:space="preserve">
          <source>This commit will get blown away so a throw-away log message is OK.</source>
          <target state="translated">이 커밋은 사라져 버려 로그 아웃 메시지가 정상입니다.</target>
        </trans-unit>
        <trans-unit id="068d7057b3017084327709c3e61c2e224fb2a5f6" translate="yes" xml:space="preserve">
          <source>This commits all other changes in the index.</source>
          <target state="translated">이것은 인덱스의 다른 모든 변경 사항을 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="1d649ab8ff53024e7549864469811ccee0abf2e7" translate="yes" xml:space="preserve">
          <source>This commits your first edits in &lt;code&gt;branch1&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;branch1&lt;/code&gt; 에서 첫 번째 편집을 커밋합니다 .</target>
        </trans-unit>
        <trans-unit id="8bc13c84a009ea0d6abb173ac6100dc00ae7606a" translate="yes" xml:space="preserve">
          <source>This compares stage 2 (our branch), stage 3 (their branch) and the working tree file and outputs a combined diff, similar to the way &lt;code&gt;diff-tree&lt;/code&gt; shows a merge commit with these flags.</source>
          <target state="translated">이것은 단계 2 (우리의 분기), 단계 3 (그들의 분기) 및 작업 트리 파일을 비교하고 &lt;code&gt;diff-tree&lt;/code&gt; 가 이러한 플래그와의 병합 커밋을 표시하는 방식과 유사한 결합 된 diff를 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="d3fe164a17e549b712f12743eb90dc676fb8455c" translate="yes" xml:space="preserve">
          <source>This computation involves traversing all the reachable objects, i.e. it has the same cost as &lt;code&gt;git prune&lt;/code&gt;. It is primarily intended to fix corruption caused by garbage collecting using older versions of Git, which didn&amp;rsquo;t protect objects referred to by reflogs.</source>
          <target state="translated">이 계산에는 도달 가능한 모든 객체를 순회하는 것이 포함됩니다. 즉, &lt;code&gt;git prune&lt;/code&gt; 과 동일한 비용 을가 집니다. reflogs에 의해 참조되는 객체를 보호하지 않는 구 버전의 Git을 사용하여 가비지 수집으로 인한 손상을 수정하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9e7c3905269f2318ce8a27a07b91b053d9dd7129" translate="yes" xml:space="preserve">
          <source>This configuration can be specified multiple times in order to allow multiple notes refs to be included. In that case, it will behave similarly to multiple &lt;code&gt;--[no-]notes[=]&lt;/code&gt; options passed in. That is, a value of &lt;code&gt;true&lt;/code&gt; will show the default notes, a value of &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; will also show notes from that notes ref and a value of &lt;code&gt;false&lt;/code&gt; will negate previous configurations and not show notes.</source>
          <target state="translated">여러 음표 참조가 포함되도록이 구성을 여러 번 지정할 수 있습니다. 이 경우 전달 된 여러 &lt;code&gt;--[no-]notes[=]&lt;/code&gt; 옵션 과 유사하게 작동합니다 . 즉, &lt;code&gt;true&lt;/code&gt; 값은 기본 메모를 표시하고 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 값은 해당 메모의 메모를 표시합니다 ref 및 &lt;code&gt;false&lt;/code&gt; 값은 이전 구성을 무효화하고 메모를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6aa4372bde5e931f9e4e006e5a3cd0aea5ccf17" translate="yes" xml:space="preserve">
          <source>This configuration is used in two ways:</source>
          <target state="translated">이 구성은 두 가지 방식으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="06f31556dacb48424e7a1be662dd26364f785ce9" translate="yes" xml:space="preserve">
          <source>This configuration variable is useful in cases where you&amp;rsquo;d like to centrally configure your Git hooks instead of configuring them on a per-repository basis, or as a more flexible and centralized alternative to having an &lt;code&gt;init.templateDir&lt;/code&gt; where you&amp;rsquo;ve changed default hooks.</source>
          <target state="translated">이 구성 변수는 저장소별로 구성하는 대신 Git 후크를 중앙에서 구성하려는 경우 또는 기본 후크를 변경 한 &lt;code&gt;init.templateDir&lt;/code&gt; 대신에보다 유연하고 중앙화 된 대안으로 유용합니다 . .</target>
        </trans-unit>
        <trans-unit id="eed4a11499740f4bb5f61d3ce7354c5409f33bf3" translate="yes" xml:space="preserve">
          <source>This configures how whitespace is ignored when performing the move detection for &lt;code&gt;--color-moved&lt;/code&gt;. It can be set by the &lt;code&gt;diff.colorMovedWS&lt;/code&gt; configuration setting. These modes can be given as a comma separated list:</source>
          <target state="translated">&lt;code&gt;--color-moved&lt;/code&gt; 에 대한 이동 감지를 수행 할 때 공백이 무시되는 방식을 구성합니다 . &lt;code&gt;diff.colorMovedWS&lt;/code&gt; 구성 설정 으로 설정할 수 있습니다 . 이 모드는 쉼표로 구분 된 목록으로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b4ea1fd788cef298d939e77017eddec04b80461" translate="yes" xml:space="preserve">
          <source>This configures how whitespace is ignored when performing the move detection for &lt;code&gt;--color-moved&lt;/code&gt;. These modes can be given as a comma separated list:</source>
          <target state="translated">&lt;code&gt;--color-moved&lt;/code&gt; 에 대한 이동 감지를 수행 할 때 공백이 무시되는 방식을 구성합니다 . 이 모드는 쉼표로 구분 된 목록으로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77030a3f3e0bddf7aada34bc0939552bc0993e3c" translate="yes" xml:space="preserve">
          <source>This counts the number of unpacked object files and disk space consumed by them, to help you decide when it is a good time to repack.</source>
          <target state="translated">이것은 압축을 풀기 좋은시기를 결정하는 데 도움이되도록 압축 해제 된 오브젝트 파일 수와 디스크 공간이 소비하는 디스크 공간을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="3e67b0f2a3d6f811dcdec6a80edd2cc8d01b0b6b" translate="yes" xml:space="preserve">
          <source>This creates a &quot;lightweight&quot; tag. If you would also like to include a comment with the tag, and possibly sign it cryptographically, then you should create a tag object instead; see the &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; man page for details.</source>
          <target state="translated">&quot;가벼운&quot;태그가 생성됩니다. 태그에 주석을 포함하고 암호화로 서명하려면 태그 객체를 대신 만들어야합니다. 자세한 내용은 &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="687e61032de29ec5a828bf99d3854a432acd2a82" translate="yes" xml:space="preserve">
          <source>This creates a new directory &quot;myrepo&quot; containing a clone of Alice&amp;rsquo;s repository. The clone is on an equal footing with the original project, possessing its own copy of the original project&amp;rsquo;s history.</source>
          <target state="translated">그러면 Alice 저장소의 복제본이 포함 된 &quot;myrepo&quot;디렉토리가 새로 만들어집니다. 복제본은 원래 프로젝트 기록과 동일한 사본을 보유하고있는 원래 프로젝트와 동등한 위치에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2fd84fc2fa04021fed2cadb8707ca64b05a22fb" translate="yes" xml:space="preserve">
          <source>This creates a single &quot;pack file&quot; in .git/objects/pack/ containing all currently unpacked objects. You can then run</source>
          <target state="translated">이렇게하면 현재 압축이 풀린 모든 객체가 포함 된 .git / objects / pack /에 단일 &quot;팩 파일&quot;이 생성됩니다. 그런 다음 실행할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="bf43931e74b20a3da5197ed923f890fe71d72016" translate="yes" xml:space="preserve">
          <source>This default configuration is achieved by creating references to the remote branch heads under &lt;code&gt;refs/remotes/origin&lt;/code&gt; and by initializing &lt;code&gt;remote.origin.url&lt;/code&gt; and &lt;code&gt;remote.origin.fetch&lt;/code&gt; configuration variables.</source>
          <target state="translated">이 기본 구성은 &lt;code&gt;refs/remotes/origin&lt;/code&gt; 에서 원격 분기 헤드에 대한 참조를 작성 하고 &lt;code&gt;remote.origin.url&lt;/code&gt; 및 &lt;code&gt;remote.origin.fetch&lt;/code&gt; 구성 변수를 초기화하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="984768ad68337dfe2b0015e657c9f4f069afabc8" translate="yes" xml:space="preserve">
          <source>This defines two submodules, &lt;code&gt;libfoo&lt;/code&gt; and &lt;code&gt;libbar&lt;/code&gt;. These are expected to be checked out in the paths &lt;code&gt;include/foo&lt;/code&gt; and &lt;code&gt;include/bar&lt;/code&gt;, and for both submodules a URL is specified which can be used for cloning the submodules.</source>
          <target state="translated">여기에는 두 개의 서브 모듈 인 &lt;code&gt;libfoo&lt;/code&gt; 및 &lt;code&gt;libbar&lt;/code&gt; 가 정의 됩니다. 이들은 &lt;code&gt;include/foo&lt;/code&gt; 및 &lt;code&gt;include/bar&lt;/code&gt; 경로에서 체크 아웃 될 것으로 예상되며 , 두 서브 모듈 모두 서브 모듈 복제에 사용할 수있는 URL이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="57db5304522b1070a0df1071ce5df5d38ea7d002" translate="yes" xml:space="preserve">
          <source>This describes how Tony Luck uses Git in his role as maintainer of the IA64 architecture for the Linux kernel.</source>
          <target state="translated">여기에서는 Tony Luck이 Linux 커널의 IA64 아키텍처 관리자로서 Git을 어떻게 사용하는지 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c9e275f2996b22cd4415c594fae8f08a0dfe70e8" translate="yes" xml:space="preserve">
          <source>This determines the coloring scheme to be applied to blame output. It can be &lt;code&gt;repeatedLines&lt;/code&gt;, &lt;code&gt;highlightRecent&lt;/code&gt;, or &lt;code&gt;none&lt;/code&gt; which is the default.</source>
          <target state="translated">이것은 비난 출력에 적용될 채색 체계를 결정합니다. 그것은 될 수 &lt;code&gt;repeatedLines&lt;/code&gt; , &lt;code&gt;highlightRecent&lt;/code&gt; , 또는 &lt;code&gt;none&lt;/code&gt; 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="56ee29b22f07db9306c3380b74b5b0180828e415" translate="yes" xml:space="preserve">
          <source>This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/objects&quot; will be used instead.</source>
          <target state="translated">$ GIT_COMMON_DIR이 설정되고 대신 &quot;$ GIT_COMMON_DIR / objects&quot;가 사용되면이 디렉토리는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2072b137cd96280de0e098678b51f23a76dcd0dc" translate="yes" xml:space="preserve">
          <source>This disables potentially expensive checks to workaround broken symlinks checked into SVN by broken clients. Set this option to &quot;false&quot; if you track a SVN repository with many empty blobs that are not symlinks. This option may be changed while &lt;code&gt;git svn&lt;/code&gt; is running and take effect on the next revision fetched. If unset, &lt;code&gt;git svn&lt;/code&gt; assumes this option to be &quot;true&quot;.</source>
          <target state="translated">이로 인해 손상된 클라이언트가 SVN에 체크인 한 손상된 심볼릭 링크를 고칠 수있는 잠재적 인 검사가 비활성화됩니다. 심볼릭 링크가 아닌 빈 블롭이 많은 SVN 저장소를 추적하는 경우이 옵션을 &quot;false&quot;로 설정하십시오. 이 옵션은 &lt;code&gt;git svn&lt;/code&gt; 이 실행되는 동안 변경 될 수 있으며 가져온 다음 개정판에 적용됩니다. 설정하지 않으면 &lt;code&gt;git svn&lt;/code&gt; 은이 옵션을 &quot;true&quot;로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="006e62625e60aabc7f31fa591f6f9b4a3bd2a878" translate="yes" xml:space="preserve">
          <source>This document attempts to write down and motivate some of the workflow elements used for &lt;code&gt;git.git&lt;/code&gt; itself. Many ideas apply in general, though the full workflow is rarely required for smaller projects with fewer people involved.</source>
          <target state="translated">이 문서는 &lt;code&gt;git.git&lt;/code&gt; 자체에 사용 된 일부 워크 플로 요소를 작성하고 동기를 부여 합니다. 인원이 적은 소규모 프로젝트에는 전체 워크 플로우가 거의 필요하지 않지만 많은 아이디어가 일반적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8cd9193645885514540ac19f3167f508bebca422" translate="yes" xml:space="preserve">
          <source>This document presents a specification for a version 2 of Git&amp;rsquo;s wire protocol. Protocol v2 will improve upon v1 in the following ways:</source>
          <target state="translated">이 문서는 Git의 와이어 프로토콜 버전 2에 대한 사양을 제시합니다. 프로토콜 v2는 다음과 같은 방식으로 v1을 개선합니다.</target>
        </trans-unit>
        <trans-unit id="46bd1a26c48d1772be26d3d869cc4b6544004ea1" translate="yes" xml:space="preserve">
          <source>This document shows the &quot;raw&quot; syntax as seen by git. The shell and other UIs might require additional quoting to protect special characters and to avoid word splitting.</source>
          <target state="translated">이 문서는 git에서 볼 수있는 &quot;raw&quot;구문을 보여줍니다. 쉘 및 기타 UI에는 특수 문자를 보호하고 단어 분리를 피하기 위해 추가 인용이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a76f8971dde9f8810b677765aca0d70490d9f8fa" translate="yes" xml:space="preserve">
          <source>This document will serve as the master list for extensions. Any implementation wishing to define a new extension should make a note of it here, in order to claim the name.</source>
          <target state="translated">이 문서는 확장의 마스터 목록으로 사용됩니다. 새 확장명을 정의하려는 모든 구현은 이름을 주장하기 위해 여기에 메모해야합니다.</target>
        </trans-unit>
        <trans-unit id="d24a591988945bec7d040b25bd5a37c73014bcf3" translate="yes" xml:space="preserve">
          <source>This does not affect &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; or the &lt;code&gt;git-diff-*&lt;/code&gt; plumbing commands. Can be overridden on the command line with the &lt;code&gt;--color[=&amp;lt;when&amp;gt;]&lt;/code&gt; option.</source>
          <target state="translated">이것은 &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; 또는 &lt;code&gt;git-diff-*&lt;/code&gt; 배관 명령 에는 영향을 미치지 않습니다 . &lt;code&gt;--color[=&amp;lt;when&amp;gt;]&lt;/code&gt; 옵션 을 사용하여 명령 줄에서 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99af460532d2c9f72e65ed17f7464c8aa563e1f4" translate="yes" xml:space="preserve">
          <source>This does not force normalization of text files, but does ensure that text files that you introduce to the repository have their line endings normalized to LF when they are added, and that files that are already normalized in the repository stay normalized.</source>
          <target state="translated">이렇게하면 텍스트 파일이 정규화되지 않지만 리포지토리에 도입 한 텍스트 파일의 행 끝이 추가 될 때 LF로 정규화되고 리포지토리에서 이미 정규화 된 파일이 정규화 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="257328db317fb853114a41f8430f87cd826d08a0" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t interfere with interoperating with the Subversion repository you cloned from, but if you wish for your local Git repository to be able to interoperate with someone else&amp;rsquo;s local Git repository, either don&amp;rsquo;t use this option or you should both use it in the same local time zone.</source>
          <target state="translated">복제 한 Subversion 저장소와의 상호 운용을 방해하지는 않지만 로컬 Git 저장소가 다른 사람의 로컬 Git 저장소와 상호 운용되도록하려면이 옵션을 사용하지 마십시오. 동일한 현지 시간대.</target>
        </trans-unit>
        <trans-unit id="45497ef8f3614492732f059c04bc30af3c6593e9" translate="yes" xml:space="preserve">
          <source>This effectively runs &lt;code&gt;add --interactive&lt;/code&gt;, but bypasses the initial command menu and directly jumps to the &lt;code&gt;patch&lt;/code&gt; subcommand. See &amp;ldquo;Interactive mode&amp;rdquo; for details.</source>
          <target state="translated">&lt;code&gt;add --interactive&lt;/code&gt; 를 효과적으로 실행 하지만 초기 명령 메뉴를 무시하고 &lt;code&gt;patch&lt;/code&gt; 하위 명령으로 바로 이동합니다 . 자세한 내용은 &quot;대화식 모드&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="53c54ba0465bbf9916ac436659dbf61aedb86156" translate="yes" xml:space="preserve">
          <source>This enables parent rewriting, see &lt;code&gt;History Simplification&lt;/code&gt; above.</source>
          <target state="translated">이렇게하면 부모 재 작성이 가능 합니다. 위의 &lt;code&gt;History Simplification&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ccdf590466d01d04dcf6da8ad6a6bec9f02c4d8e" translate="yes" xml:space="preserve">
          <source>This environment allows the specification of an alternate index file. If not specified, the default of &lt;code&gt;$GIT_DIR/index&lt;/code&gt; is used.</source>
          <target state="translated">이 환경에서는 대체 인덱스 파일을 지정할 수 있습니다. 지정하지 않으면 &lt;code&gt;$GIT_DIR/index&lt;/code&gt; 의 기본값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2abd55a6650395bf249165e2f6568e98ab14958c" translate="yes" xml:space="preserve">
          <source>This environment variable allows the specification of an index version for new repositories. It won&amp;rsquo;t affect existing index files. By default index file version 2 or 3 is used. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; for more information.</source>
          <target state="translated">이 환경 변수를 사용하면 새 리포지토리에 대한 인덱스 버전을 지정할 수 있습니다. 기존 색인 파일에는 영향을 미치지 않습니다. 기본적으로 색인 파일 버전 2 또는 3이 사용됩니다. 자세한 내용은 &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2763e4fc7ba1973ac90184c067d20f9d0fda70a8" translate="yes" xml:space="preserve">
          <source>This environment variable overrides &lt;code&gt;$EDITOR&lt;/code&gt; and &lt;code&gt;$VISUAL&lt;/code&gt;. It is used by several Git commands when, on interactive mode, an editor is to be launched. See also &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt; and the &lt;code&gt;core.editor&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">이 환경 변수는 &lt;code&gt;$EDITOR&lt;/code&gt; 및 &lt;code&gt;$VISUAL&lt;/code&gt; 대체 합니다. 대화식 모드에서 편집기를 시작할 때 여러 Git 명령에서 사용됩니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]의 &lt;/a&gt;&lt;a href=&quot;git-var&quot;&gt;git-var [1]&lt;/a&gt; 및 &lt;code&gt;core.editor&lt;/code&gt; 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ddbc158f0dcc3c8ea52494b42fbb66d15e06e460" translate="yes" xml:space="preserve">
          <source>This environment variable overrides &lt;code&gt;$PAGER&lt;/code&gt;. If it is set to an empty string or to the value &quot;cat&quot;, Git will not launch a pager. See also the &lt;code&gt;core.pager&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">이 환경 변수는 &lt;code&gt;$PAGER&lt;/code&gt; 대체 합니다. 빈 문자열 또는 &quot;cat&quot;값으로 설정되면 Git은 호출기를 시작하지 않습니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 &lt;code&gt;core.pager&lt;/code&gt; 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="25ea93764f52eb3dcc477c86398962bd9bbded98" translate="yes" xml:space="preserve">
          <source>This event contains the command name for this git process and the hierarchy of commands from parent git processes.</source>
          <target state="translated">이 이벤트에는이 자식 프로세스의 명령 이름과 부모 자식 프로세스의 명령 계층이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f5d9f72db5c7ffa9776d5c71964338d54a2515a4" translate="yes" xml:space="preserve">
          <source>This event contains the complete argv received by main().</source>
          <target state="translated">이 이벤트에는 main ()이 수신 한 전체 argv가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2a4c1f111536d47e2687ea692bfe5bd399b4307d" translate="yes" xml:space="preserve">
          <source>This event contains the discovered full path of the git executable (on platforms that are configured to resolve it).</source>
          <target state="translated">이 이벤트에는 git 실행 파일의 발견 된 전체 경로가 포함되어 있습니다 (해결하도록 구성된 플랫폼에서).</target>
        </trans-unit>
        <trans-unit id="c8af8dbf59abf700f44d6449c7c951b54692bd2e" translate="yes" xml:space="preserve">
          <source>This event defines a repo-id and associates it with the root of the worktree.</source>
          <target state="translated">이 이벤트는 repo-id를 정의하고 작업 트리의 루트와 연관시킵니다.</target>
        </trans-unit>
        <trans-unit id="efbcacd1a490c688869fdd46397140e75919d7ab" translate="yes" xml:space="preserve">
          <source>This event describes a child process that is about to be spawned.</source>
          <target state="translated">이 이벤트는 생성 될 자식 프로세스를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8c8f935852467fd7c3b46787d77518dc3611a986" translate="yes" xml:space="preserve">
          <source>This event gives the version of the executable and the EVENT format. It should always be the first event in a trace session. The EVENT format version will be incremented if new event types are added, if existing fields are removed, or if there are significant changes in interpretation of existing events or fields. Smaller changes, such as adding a new field to an existing event, will not require an increment to the EVENT format version.</source>
          <target state="translated">이 이벤트는 실행 파일 버전과 EVENT 형식을 제공합니다. 항상 추적 세션에서 첫 번째 이벤트 여야합니다. EVENT 형식 버전은 새 이벤트 유형이 추가되거나 기존 필드가 제거되거나 기존 이벤트 또는 필드의 해석에 상당한 변경이있는 경우 증가합니다. 기존 이벤트에 새 필드를 추가하는 등의 작은 변경으로 EVENT 형식 버전을 증분 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ea085d0e611d87af89c62af2b70656c0016dc7e" translate="yes" xml:space="preserve">
          <source>This event is emitted by the Trace2 &lt;code&gt;atexit&lt;/code&gt; routine during final shutdown. It should be the last event emitted by the process.</source>
          <target state="translated">이 이벤트는 최종 종료 중에 Trace2 &lt;code&gt;atexit&lt;/code&gt; 루틴에 의해 생성됩니다 . 프로세스에서 생성 한 마지막 이벤트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0b20979b7d0436896a9e4dd619b31c2f047cbd64" translate="yes" xml:space="preserve">
          <source>This event is emitted when git calls &lt;code&gt;exit()&lt;/code&gt;.</source>
          <target state="translated">이 이벤트는 git가 &lt;code&gt;exit()&lt;/code&gt; 호출 할 때 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c63cb7135e802e553dc499a675da732d4f96c3a" translate="yes" xml:space="preserve">
          <source>This event is emitted when one of the &lt;code&gt;error()&lt;/code&gt;, &lt;code&gt;die()&lt;/code&gt;, or &lt;code&gt;usage()&lt;/code&gt; functions are called.</source>
          <target state="translated">이 이벤트는 &lt;code&gt;error()&lt;/code&gt; , &lt;code&gt;die()&lt;/code&gt; 또는 &lt;code&gt;usage()&lt;/code&gt; 함수 중 하나가 호출 될 때 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ebb8b872e605289564f67171a3133d84781ab210" translate="yes" xml:space="preserve">
          <source>This event is emitted when the program is terminated by a user signal. Depending on the platform, the signal event may prevent the &quot;atexit&quot; event from being generated.</source>
          <target state="translated">이 이벤트는 프로그램이 사용자 신호에 의해 종료 될 때 생성됩니다. 플랫폼에 따라 신호 이벤트로 인해 &quot;atexit&quot;이벤트가 생성되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ca8802f12c75856c4e7ea399ac7a1939e2a37eb" translate="yes" xml:space="preserve">
          <source>This event is generated after the current process has returned from the waitpid() and collected the exit information from the child.</source>
          <target state="translated">이 이벤트는 현재 프로세스가 waitpid ()에서 리턴되고 자식에서 종료 정보를 수집 한 후에 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="9fe6d803410a7d3a5cd4bc2114534352d230200b" translate="yes" xml:space="preserve">
          <source>This event is generated before git attempts to &lt;code&gt;exec()&lt;/code&gt; another command rather than starting a child process.</source>
          <target state="translated">이 이벤트는 자식 프로세스를 시작하지 않고 git이 다른 명령 을 &lt;code&gt;exec()&lt;/code&gt; 하려고 시도하기 전에 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="93caa8939f471f1240286ec30c6905ef3996f20e" translate="yes" xml:space="preserve">
          <source>This event is generated if the &lt;code&gt;exec()&lt;/code&gt; fails and control returns to the current git command.</source>
          <target state="translated">이 이벤트는 &lt;code&gt;exec()&lt;/code&gt; 가 실패하고 제어가 현재 git 명령으로 리턴되는 경우 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="814427d239ec02f31ac7bf0fb913766e18bfb53e" translate="yes" xml:space="preserve">
          <source>This event is generated to log a global parameter.</source>
          <target state="translated">이 이벤트는 전역 매개 변수를 기록하기 위해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="54b6cc61590e1e0eba249cc8ddd71ddff154355b" translate="yes" xml:space="preserve">
          <source>This event is generated to log a pre-formatted JSON string containing structured data.</source>
          <target state="translated">이 이벤트는 구조화 된 데이터를 포함하는 사전 형식화 된 JSON 문자열을 기록하기 위해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0ee97bbcf1fde0cf306363257efe6b7de578045e" translate="yes" xml:space="preserve">
          <source>This event is generated to log a thread- and region-local key/value pair.</source>
          <target state="translated">이 이벤트는 스레드 및 지역 로컬 키 / 값 쌍을 기록하기 위해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4caa8d05330c9e1126d8391705e312b0d8975d63" translate="yes" xml:space="preserve">
          <source>This event is generated when a thread exits. It is generated from &lt;strong&gt;within&lt;/strong&gt; the thread&amp;rsquo;s thread-proc (for TLS reasons).</source>
          <target state="translated">이 이벤트는 스레드가 종료 될 때 생성됩니다. 스레드의 thread-proc &lt;strong&gt;내&lt;/strong&gt; 에서 생성됩니다 (TLS 이유로).</target>
        </trans-unit>
        <trans-unit id="eba565beaf1b2269c764c147f5196869afe38bce" translate="yes" xml:space="preserve">
          <source>This event is generated when a thread is started. It is generated from &lt;strong&gt;within&lt;/strong&gt; the new thread&amp;rsquo;s thread-proc (for TLS reasons).</source>
          <target state="translated">이 이벤트는 스레드가 시작될 때 생성됩니다. 새 스레드의 thread-proc &lt;strong&gt;내&lt;/strong&gt; 에서 생성됩니다 (TLS 이유로).</target>
        </trans-unit>
        <trans-unit id="1684fe3e3862662b36c1dfb0c9bb20558e1f338a" translate="yes" xml:space="preserve">
          <source>This event is generated when entering a region.</source>
          <target state="translated">이 이벤트는 지역을 입력 할 때 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="809d72e4f54bac6c7054af4e990fa8c97e8c764d" translate="yes" xml:space="preserve">
          <source>This event is generated when leaving a region.</source>
          <target state="translated">이 이벤트는 지역을 떠날 때 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="1e6a7368deeb7ec580313fc82400f1c12d17672a" translate="yes" xml:space="preserve">
          <source>This event is present when an alias is expanded.</source>
          <target state="translated">이 이벤트는 별명이 확장 될 때 나타납니다.</target>
        </trans-unit>
        <trans-unit id="bca802363ffa9599d9e13df71e2f62ec1454e32f" translate="yes" xml:space="preserve">
          <source>This event is written to the git-trace2-discard sentinel file if there are too many files in the target trace directory (see the trace2.maxFiles config option).</source>
          <target state="translated">대상 추적 디렉토리에 파일이 너무 많으면이 이벤트가 git-trace2-discard 센티넬 파일에 기록됩니다 (trace2.maxFiles 구성 옵션 참조).</target>
        </trans-unit>
        <trans-unit id="8c2ad60a0d9356a6e908b18056fbac1c2b1d4129" translate="yes" xml:space="preserve">
          <source>This event, when present, describes the command variant This event may be emitted more than once.</source>
          <target state="translated">이 이벤트는 존재할 경우 명령 변형을 설명합니다.이 이벤트는 두 번 이상 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e7d09cee878b03064fb9d9484c73f3f00225826" translate="yes" xml:space="preserve">
          <source>This example also shows that thread names are assigned in a racy manner as each thread starts and allocates TLS storage.</source>
          <target state="translated">이 예제는 또한 각 스레드가 시작되고 TLS 스토리지를 할당 할 때 스레드 이름이 복잡한 방식으로 지정됨을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e296b28f1fcad64b66f85f9abe931f54fc5fbde0" translate="yes" xml:space="preserve">
          <source>This example imports a new remote &quot;p4/proj2&quot; into an existing Git repository:</source>
          <target state="translated">이 예에서는 새 원격 &quot;p4 / proj2&quot;를 기존 Git 저장소로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7cbbc9fac80d3f9e05217d26ad6f34ea5097abe6" translate="yes" xml:space="preserve">
          <source>This example shows that the index contained 3552 entries.</source>
          <target state="translated">이 예는 색인에 3552 개의 항목이 포함되어 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="af5672891a1be21669d22b688901415e2cf060c3" translate="yes" xml:space="preserve">
          <source>This expands to the object name of the delta base for the given object, if it is stored as a delta. Otherwise it expands to the null object name (all zeroes).</source>
          <target state="translated">이는 델타로 저장된 경우 지정된 오브젝트에 대한 델타베이스의 오브젝트 이름으로 확장됩니다. 그렇지 않으면 널 오브젝트 이름 (모두 0)으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="1a642986ccbacca12888668bff4ca6d3b1007b62" translate="yes" xml:space="preserve">
          <source>This explanation comes for &quot;free&quot; because there was no change. Similarly &lt;code&gt;C&lt;/code&gt; could be explained using &lt;code&gt;1&lt;/code&gt;, but that comes at some cost c&amp;gt;0 because of the modification:</source>
          <target state="translated">이 설명은 아무런 변화가 없었기 때문에 &quot;무료&quot;입니다. 마찬가지로 &lt;code&gt;C&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 을 사용하여 설명 할 수 있지만 수정으로 인해 비용이 c&amp;gt; 0입니다.</target>
        </trans-unit>
        <trans-unit id="86a0b58a904e042293eb0ea80455653f123e7d4e" translate="yes" xml:space="preserve">
          <source>This extended format can be useful if rename or copy detection is active, to allow you to see the original name of the file in different parents.</source>
          <target state="translated">이 확장 형식은 다른 부모에서 파일의 원래 이름을 볼 수 있도록 이름 바꾸기 또는 복사 감지가 활성화 된 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc95481325c82bdecdaa23291b735168b05af418" translate="yes" xml:space="preserve">
          <source>This extension does not change git&amp;rsquo;s behavior at all. It is useful only for testing format-1 compatibility.</source>
          <target state="translated">이 확장은 git의 동작을 전혀 변경하지 않습니다. 형식 1 호환성 테스트에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="24a20ccff9f7f9f91cdf61fb876086b44fc5be61" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis by setting repository&amp;rsquo;s &lt;code&gt;gitweb.pickaxe&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">이 기능은 리포지토리의 &lt;code&gt;gitweb.pickaxe&lt;/code&gt; 구성 변수 (부울) 를 설정하여 리포지토리별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fcd9d965aa29d51e3ab01e56c522e086b7f545b" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.avatar&lt;/code&gt; configuration variable.</source>
          <target state="translated">이 기능은 리포지토리의 &lt;code&gt;gitweb.avatar&lt;/code&gt; 구성 변수 를 통해 리포지토리별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da6908103a49ae5e820a33c13aadd5dfdd3e67a7" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.blame&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">이 기능은 리포지토리의 &lt;code&gt;gitweb.blame&lt;/code&gt; 구성 변수 (부울) 를 통해 리포지토리별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d6d167abae14ab18966eab440f954ed6085f29c" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.grep&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">이 기능은 리포지토리의 &lt;code&gt;gitweb.grep&lt;/code&gt; 구성 변수 (부울) 를 통해 리포지토리별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd4f802848cf6cbdc7682aeefb00472f2c444c9e" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.highlight&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">이 기능은 리포지토리의 &lt;code&gt;gitweb.highlight&lt;/code&gt; 구성 변수 (부울) 를 통해 리포지토리별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8e82652b1c51e397e7f1e31621e9084d5611fda" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.patches&lt;/code&gt; configuration variable (integer).</source>
          <target state="translated">이 기능은 저장소의 &lt;code&gt;gitweb.patches&lt;/code&gt; 구성 변수 (정수) 를 통해 저장소별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0528d6fc23cb2716835712f44b5daf955251062" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.remote_heads&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">이 기능은 저장소의 &lt;code&gt;gitweb.remote_heads&lt;/code&gt; 구성 변수 (부울) 를 통해 저장소별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58b983175f59d7aad97dac71b32251a2f4a8c4a0" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.showSizes&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">이 기능은 리포지토리의 &lt;code&gt;gitweb.showSizes&lt;/code&gt; 구성 변수 (부울) 를 통해 리포지토리별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee33afe943a28f48529ed67cc410ad185ea09f23" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.snapshot&lt;/code&gt; configuration variable, which contains a comma separated list of formats or &quot;none&quot; to disable snapshots. Unknown values are ignored.</source>
          <target state="translated">이 기능은 저장소의 &lt;code&gt;gitweb.snapshot&lt;/code&gt; 구성 변수 를 통해 저장소별로 구성 할 수 있습니다 . 여기에는 쉼표로 구분 된 형식 목록 또는 스냅 샷을 비활성화하는 &quot;없음&quot;이 포함됩니다. 알 수없는 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c2467a6f49bad0810d0f5e1c4a51888ceb4f5b0f" translate="yes" xml:space="preserve">
          <source>This feature can be configured on per-repository basis after setting $feature{&lt;code&gt;extra-branch-refs&lt;/code&gt;}{&lt;code&gt;override&lt;/code&gt;} to true, via repository&amp;rsquo;s &lt;code&gt;gitweb.extraBranchRefs&lt;/code&gt; configuration variable, which contains a space separated list of refs. An example:</source>
          <target state="translated">이 기능은 공백으로 구분 된 참조 목록을 포함하는 저장소의 &lt;code&gt;gitweb.extraBranchRefs&lt;/code&gt; 구성 변수 를 통해 $ feature { &lt;code&gt;extra-branch-refs&lt;/code&gt; } { &lt;code&gt;override&lt;/code&gt; }를 true로 설정 한 후 저장소별로 구성 할 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="83b4612ad81d70c9ed8920a4b451b69b8c3ee080" translate="yes" xml:space="preserve">
          <source>This feature is intended to speed up git operations for repos that have large working directories.</source>
          <target state="translated">이 기능은 큰 작업 디렉토리가있는 저장소의 git 작업 속도를 높이기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6b24b487d6d9654020073f6754733ecc051175ad" translate="yes" xml:space="preserve">
          <source>This feature is semi-deprecated. For scripting purpose, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt;&lt;code&gt;--porcelain&lt;/code&gt; and &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt;&lt;code&gt;--name-status&lt;/code&gt; are almost always superior alternatives, and users should look at &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt;&lt;code&gt;--short&lt;/code&gt; or &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--name-status&lt;/code&gt; for more user-friendly alternatives.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 스크립팅 목적으로 &lt;a href=&quot;git-status&quot;&gt;git-status [1] &lt;/a&gt; &lt;code&gt;--porcelain&lt;/code&gt; 및 &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1] &lt;/a&gt; &lt;code&gt;--name-status&lt;/code&gt; 는 거의 항상 우수한 대안이며 사용자는 &lt;a href=&quot;git-status&quot;&gt;git-status [1] &lt;/a&gt; &lt;code&gt;--short&lt;/code&gt; 또는 &lt;a href=&quot;git-diff&quot;&gt;git-&lt;/a&gt; 보다 사용자 친화적 인 대안을위한 diff [1] &lt;code&gt;--name-status&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0861edc399d3214fad2ecef2c8c7d8f9e28b4564" translate="yes" xml:space="preserve">
          <source>This feature is useful when an established project should be accepted despite early commits containing errors that can be safely ignored such as invalid committer email addresses. Note: corrupt objects cannot be skipped with this setting.</source>
          <target state="translated">이 기능은 유효하지 않은 커미터 이메일 주소와 같이 무시해도되는 오류가 포함 된 초기 커밋에도 불구하고 설정된 프로젝트를 수락해야 할 때 유용합니다. 참고 :이 설정으로는 손상된 개체를 건너 뛸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5474f37d061902594342fbe38be401770ea2769f" translate="yes" xml:space="preserve">
          <source>This feature works by recording the mtime of the working tree directories and then omitting reading directories and stat calls against files in those directories whose mtime hasn&amp;rsquo;t changed. For this to work the underlying operating system and file system must change the &lt;code&gt;st_mtime&lt;/code&gt; field of directories if files in the directory are added, modified or deleted.</source>
          <target state="translated">이 기능은 작업 트리 디렉토리의 mtime을 기록한 다음 mtime이 변경되지 않은 디렉토리의 파일에 대한 디렉토리 및 stat 호출 읽기를 생략하여 작동합니다. 이것이 작동하려면 기본 운영 체제 및 파일 시스템 이 디렉토리의 파일이 추가, 수정 또는 삭제 된 경우 디렉토리 의 &lt;code&gt;st_mtime&lt;/code&gt; 필드를 변경해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ef2541ade640bd800921de0e87cda6dd56d4d5f6" translate="yes" xml:space="preserve">
          <source>This fetches revisions from the SVN parent of the current HEAD and rebases the current (uncommitted to SVN) work against it.</source>
          <target state="translated">현재 HEAD의 SVN 상위에서 수정본을 가져오고 현재 SVN에 커밋되지 않은 작업을 리베이스합니다.</target>
        </trans-unit>
        <trans-unit id="e6f84c5c8c6a08793025b9538660cbd1c1faa637" translate="yes" xml:space="preserve">
          <source>This file contains the commit message of a commit in progress. If &lt;code&gt;git commit&lt;/code&gt; exits due to an error before creating a commit, any commit message that has been provided by the user (e.g., in an editor session) will be available in this file, but will be overwritten by the next invocation of &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">이 파일에는 진행중인 커밋의 커밋 메시지가 들어 있습니다. 경우 &lt;code&gt;git commit&lt;/code&gt; 커밋 만들기 전에 오류로 인해 종료, 어떤이 파일에 사용할 수 있습니다 (편집기 세션에서 예) 사용자가 제공 한 커밋 메시지 만의 다음의 호출을 덮어 씁니다 &lt;code&gt;git commit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2063696fd909d95d720efff6859f2846f7a33789" translate="yes" xml:space="preserve">
          <source>This file helps dumb transports discover what refs are available in this repository. If the repository is published for dumb transports, this file should be regenerated by &lt;code&gt;git update-server-info&lt;/code&gt; every time a tag or branch is created or modified. This is normally done from the &lt;code&gt;hooks/update&lt;/code&gt; hook, which is run by the &lt;code&gt;git-receive-pack&lt;/code&gt; command when you &lt;code&gt;git push&lt;/code&gt; into the repository.</source>
          <target state="translated">이 파일은 바보 전송이이 저장소에서 사용 가능한 참조를 발견하는 데 도움이됩니다. 저장소가 바보 전송 용으로 게시 된 경우이 파일은 태그 또는 분기를 만들거나 수정할 때마다 &lt;code&gt;git update-server-info&lt;/code&gt; 에 의해 재생성되어야합니다 . 이것은 일반적으로 &lt;code&gt;hooks/update&lt;/code&gt; 후크 에서 수행되며, 후크를 저장소로 &lt;code&gt;git push&lt;/code&gt; 할 때 &lt;code&gt;git-receive-pack&lt;/code&gt; 명령으로 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="3487083c7b98c66e39acc8f940f40c0e9ceac88f" translate="yes" xml:space="preserve">
          <source>This file is to help dumb transports discover what packs are available in this object store. Whenever a pack is added or removed, &lt;code&gt;git update-server-info&lt;/code&gt; should be run to keep this file up to date if the repository is published for dumb transports. &lt;code&gt;git repack&lt;/code&gt; does this by default.</source>
          <target state="translated">이 파일은 바보 전송이이 오브젝트 저장소에서 사용 가능한 팩을 발견하는 데 도움이됩니다. 팩이 추가되거나 제거 될 때마다 저장소가 벙어리 전송 용으로 게시 된 경우이 파일을 최신 상태로 유지하려면 &lt;code&gt;git update-server-info&lt;/code&gt; 를 실행해야합니다. &lt;code&gt;git repack&lt;/code&gt; 은 기본적으로 이것을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="cbe65e34529f44f10bf3c4bc531b3ef1a1689dfb" translate="yes" xml:space="preserve">
          <source>This file mainly serves as the mapping between the name and path of submodules in the superproject, such that the submodule&amp;rsquo;s Git directory can be located.</source>
          <target state="translated">이 파일은 주로 수퍼 프로젝트에서 하위 모듈의 이름과 경로 간의 매핑 역할을하여 하위 모듈의 Git 디렉토리를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="071050e2544b6fc3703fb63508bbfdc9243b46ab" translate="yes" xml:space="preserve">
          <source>This file records URLs to alternate object stores that this object store borrows objects from, to be used when the repository is fetched over HTTP.</source>
          <target state="translated">이 파일은 URL을 기록하여이 오브젝트 저장소가 오브젝트를 차용 한 대체 오브젝트 저장소에 URL을 기록하여 저장소가 HTTP를 통해 페치 될 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cc3397ff622f0d4d27f532099612807583041388" translate="yes" xml:space="preserve">
          <source>This file records fake commit ancestry information, to pretend the set of parents a commit has is different from how the commit was actually created. One record per line describes a commit and its fake parents by listing their 40-byte hexadecimal object names separated by a space and terminated by a newline.</source>
          <target state="translated">이 파일은 가짜 커밋 조상 정보를 기록하여 커밋이있는 부모 세트가 실제로 커밋이 생성 된 방식과 다른 척합니다. 라인 당 하나의 레코드는 40 바이트의 16 진 오브젝트 이름을 공백으로 구분하고 개행으로 종료하여 커밋 및 가짜 부모를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1873ba1c652fc3e8dae8a41ecd45dff2c995baaf" translate="yes" xml:space="preserve">
          <source>This file records paths to alternate object stores that this object store borrows objects from, one pathname per line. Note that not only native Git tools use it locally, but the HTTP fetcher also tries to use it remotely; this will usually work if you have relative paths (relative to the object database, not to the repository!) in your alternates file, but it will not work if you use absolute paths unless the absolute path in filesystem and web URL is the same. See also &lt;code&gt;objects/info/http-alternates&lt;/code&gt;.</source>
          <target state="translated">이 파일은이 오브젝트 저장소가 오브젝트를 빌려 오는 대체 오브젝트 저장소에 대한 경로를 한 줄에 하나씩 경로로 기록합니다. 기본 Git 도구는 로컬 Git 도구를 사용할뿐만 아니라 HTTP 페처도이를 원격으로 사용하려고합니다. 대체 파일에 상대 경로 (저장소가 아닌 객체 데이터베이스에 상대적인 경로)가있는 경우 일반적으로 작동하지만 파일 시스템과 웹 URL의 절대 경로가 동일하지 않으면 절대 경로를 사용하면 작동하지 않습니다. &lt;code&gt;objects/info/http-alternates&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="517ab2689bb34239adf0b92ebb2a70e736956866" translate="yes" xml:space="preserve">
          <source>This file stores sparse checkout patterns. See also: &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt;.</source>
          <target state="translated">이 파일은 드문 체크 아웃 패턴을 저장합니다. &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="39e8ca5394d81b30bccd145a749de9346fba2480" translate="yes" xml:space="preserve">
          <source>This file uses the following format:</source>
          <target state="translated">이 파일은 다음 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="53c1d1d0fe83b95fe57b9ac9f6f59413589df721" translate="yes" xml:space="preserve">
          <source>This file, by convention among Porcelains, stores the exclude pattern list. &lt;code&gt;.gitignore&lt;/code&gt; is the per-directory ignore file. &lt;code&gt;git status&lt;/code&gt;, &lt;code&gt;git add&lt;/code&gt;, &lt;code&gt;git rm&lt;/code&gt; and &lt;code&gt;git clean&lt;/code&gt; look at it but the core Git commands do not look at it. See also: &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;.</source>
          <target state="translated">이 파일은 도자기의 규칙에 따라 제외 패턴 목록을 저장합니다. &lt;code&gt;.gitignore&lt;/code&gt; 는 디렉토리 별 무시 파일입니다. &lt;code&gt;git status&lt;/code&gt; , &lt;code&gt;git add&lt;/code&gt; , &lt;code&gt;git rm&lt;/code&gt; 및 &lt;code&gt;git clean&lt;/code&gt; 이 그것을 보지만 핵심 Git 명령은 그것을 보지 않습니다. &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8956b9fdca3244ff8cd9467aefdc82ab275d878" translate="yes" xml:space="preserve">
          <source>This filter may be used if you only need to modify the environment in which the commit will be performed. Specifically, you might want to rewrite the author/committer name/email/time environment variables (see &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; for details).</source>
          <target state="translated">커밋이 수행 될 환경 만 수정해야하는 경우이 필터를 사용할 수 있습니다. 특히 작성자 / 커미터 이름 / 이메일 / 시간 환경 변수를 다시 작성할 수 있습니다 (자세한 내용은 &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="1f7d9b6979d573a6d61c7fc37aef6ce7f09ba079" translate="yes" xml:space="preserve">
          <source>This flag causes &lt;code&gt;git diff-tree --stdin&lt;/code&gt; to also show the commit message before the differences.</source>
          <target state="translated">이 플래그는 &lt;code&gt;git diff-tree --stdin&lt;/code&gt; 이 차이 전에 커밋 메시지를 표시하도록합니다.</target>
        </trans-unit>
        <trans-unit id="f18c1480999d4a64a19b051751a1dfdb3d01c394" translate="yes" xml:space="preserve">
          <source>This flag causes an object already in a local pack that has a .keep file to be ignored, even if it would have otherwise been packed.</source>
          <target state="translated">이 플래그는 .keep 파일이있는 로컬 팩에 이미있는 오브젝트가 다른 방식으로 압축되어 있어도 무시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="3b2c5aa43d85ae95c70f7126e1a8d471a0247285" translate="yes" xml:space="preserve">
          <source>This flag causes an object already in a pack to be ignored even if it would have otherwise been packed.</source>
          <target state="translated">이 플래그는 팩에 이미있는 오브젝트가 달리 패킹 된 경우에도 무시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="936ccdd465b71c76f59e3d7929f0e31e3a24c431" translate="yes" xml:space="preserve">
          <source>This flag causes an object already in the given pack to be ignored, even if it would have otherwise been packed. &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; is the pack file name without leading directory (e.g. &lt;code&gt;pack-123.pack&lt;/code&gt;). The option could be specified multiple times to keep multiple packs.</source>
          <target state="translated">이 플래그는 지정된 팩에 이미있는 오브젝트가 다른 방식으로 패킹 된 경우에도 무시되도록합니다. &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; 은 선행 디렉토리가없는 팩 파일 이름입니다 (예 : &lt;code&gt;pack-123.pack&lt;/code&gt; ). 여러 팩을 유지하기 위해 옵션을 여러 번 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fad47cb9db9729fbeb177e82626a6322dbefd6c" translate="yes" xml:space="preserve">
          <source>This flag causes an object that is borrowed from an alternate object store to be ignored even if it would have otherwise been packed.</source>
          <target state="translated">이 플래그는 대체 오브젝트 저장소에서 빌린 오브젝트가 다른 방식으로 압축되어 있어도 무시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="97fddffea713eaa9774ecf695b0619f959916c25" translate="yes" xml:space="preserve">
          <source>This flag causes combined diffs (used for merge commits) to list the name of the file from all parents. It thus only has effect when -c or --cc are specified, and is likely only useful if filename changes are detected (i.e. when either rename or copy detection have been requested).</source>
          <target state="translated">이 플래그는 결합 된 diff (병합 커밋에 사용)가 모든 부모의 파일 이름을 나열하게합니다. 따라서 -c 또는 --cc가 지정된 경우에만 효과가 있으며 파일 이름 변경이 감지 된 경우 (예 : 이름 바꾸기 또는 복사 감지가 요청 된 경우)에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7d04699c745135d6f14712a3d65005478838c3a7" translate="yes" xml:space="preserve">
          <source>This flag changes the way a merge commit is displayed (which means it is useful only when the command is given one &amp;lt;tree-ish&amp;gt;, or &lt;code&gt;--stdin&lt;/code&gt;). It shows the differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time (which is what the &lt;code&gt;-m&lt;/code&gt; option does). Furthermore, it lists only files which were modified from all parents.</source>
          <target state="translated">이 플래그는 병합 커밋이 표시되는 방식을 변경합니다 (즉, 명령에 &amp;lt;tree-ish&amp;gt; 또는 &lt;code&gt;--stdin&lt;/code&gt; 이 지정된 경우에만 유용함 ). 한 번에 하나씩 부모와 결과 사이에 쌍별 차이를 표시하는 대신 각 부모와 병합 결과의 차이점을 동시에 표시합니다 ( &lt;code&gt;-m&lt;/code&gt; 옵션의 기능). 또한 모든 상위에서 수정 된 파일 만 나열합니다.</target>
        </trans-unit>
        <trans-unit id="0d503f20848f4e1ff6c5e78038f4bce28f3422a3" translate="yes" xml:space="preserve">
          <source>This flag changes the way a merge commit patch is displayed, in a similar way to the &lt;code&gt;-c&lt;/code&gt; option. It implies the &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-p&lt;/code&gt; options and further compresses the patch output by omitting uninteresting hunks whose the contents in the parents have only two variants and the merge result picks one of them without modification. When all hunks are uninteresting, the commit itself and the commit log message is not shown, just like in any other &quot;empty diff&quot; case.</source>
          <target state="translated">이 플래그는 &lt;code&gt;-c&lt;/code&gt; 옵션 과 유사한 방식으로 병합 커밋 패치가 표시되는 방식을 변경합니다 . &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-p&lt;/code&gt; 옵션을 내포하고 부모의 내용에 두 가지 변형 만 있고 병합 결과가 수정없이 이들 중 하나를 선택하는 흥미없는 덩어리를 생략하여 패치 출력을 추가로 압축합니다. 모든 덩어리가 흥미롭지 않은 경우, 다른 &quot;빈 차이&quot;경우와 같이 커밋 자체와 커밋 로그 메시지가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4835250d6cbee97633146544cd1896afcc631099" translate="yes" xml:space="preserve">
          <source>This flag disables these checks, and can cause the remote repository to lose commits; use it with care.</source>
          <target state="translated">이 플래그는 이러한 검사를 비활성화하며 원격 저장소가 커밋을 잃을 수 있습니다. 조심해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cc5f19786a1b0eda7705eaaa80c372612ab5d782" translate="yes" xml:space="preserve">
          <source>This flag implies the &lt;code&gt;-c&lt;/code&gt; option and further compresses the patch output by omitting uninteresting hunks whose contents in the parents have only two variants and the merge result picks one of them without modification.</source>
          <target state="translated">이 플래그는 &lt;code&gt;-c&lt;/code&gt; 옵션을 암시하고 부모의 내용에 변형이 두 개 뿐이고 병합 결과가 수정없이 그 중 하나를 선택하는 흥미없는 덩어리를 생략하여 패치 출력을 추가로 압축합니다.</target>
        </trans-unit>
        <trans-unit id="6c9f2e241df42ed566896490c4c1723461343597" translate="yes" xml:space="preserve">
          <source>This flag is passed to the &lt;code&gt;git log&lt;/code&gt; program (see &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;) that generates the patches.</source>
          <target state="translated">이 플래그는 패치를 생성하는 &lt;code&gt;git log&lt;/code&gt; 프로그램 ( &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 참조)으로 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="7d74132f018d1e29c74648fc0cf6690a80cd700b" translate="yes" xml:space="preserve">
          <source>This flag makes the command not to report its progress on the standard error stream.</source>
          <target state="translated">이 플래그는 명령이 표준 오류 스트림에서 진행 상황을보고하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="c7300f914a6246e85c4558f9e03e3ac6bd2957c2" translate="yes" xml:space="preserve">
          <source>This flag makes the merge commits show the full diff like regular commits; for each merge parent, a separate log entry and diff is generated. An exception is that only diff against the first parent is shown when &lt;code&gt;--first-parent&lt;/code&gt; option is given; in that case, the output represents the changes the merge brought &lt;code&gt;into&lt;/code&gt; the then-current branch.</source>
          <target state="translated">이 플래그는 병합 커밋이 일반 커밋과 같이 전체 diff를 표시하도록합니다. 각 병합 상위에 대해 별도의 로그 항목과 diff가 생성됩니다. &lt;code&gt;--first-parent&lt;/code&gt; 옵션이 주어지면 첫 번째 부모에 대한 diff 만 표시됩니다 . 이 경우 출력은 병합 이 당시 분기 &lt;code&gt;into&lt;/code&gt; 가져온 변경 사항을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="824f1a5cbd322eac2edc9b61691e0afb5fb06c7c" translate="yes" xml:space="preserve">
          <source>This flag tells the command not to reuse existing object data at all, including non deltified object, forcing recompression of everything. This implies --no-reuse-delta. Useful only in the obscure case where wholesale enforcement of a different compression level on the packed data is desired.</source>
          <target state="translated">이 플래그는 명령에 명령되지 않은 객체를 포함하여 기존 객체 데이터를 전혀 재사용하지 않도록 지시하여 모든 것을 다시 압축합니다. 이것은 --re-reuse-delta를 의미합니다. 압축 된 데이터에 대해 다른 압축 수준의 도매 시행이 필요한 모호한 경우에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e554d11fed47fbadc588fbbd426a692640350799" translate="yes" xml:space="preserve">
          <source>This form can only be used in the middle of a &lt;code&gt;commit&lt;/code&gt;. The path names a directory entry within fast-import&amp;rsquo;s active commit. The path must be quoted in this case.</source>
          <target state="translated">이 형식은 &lt;code&gt;commit&lt;/code&gt; 도중에 만 사용할 수 있습니다 . 경로는 빠른 가져 오기의 활성 커밋 내의 디렉토리 항목 이름을 지정합니다. 이 경우 경로를 인용해야합니다.</target>
        </trans-unit>
        <trans-unit id="55cd46dfe4dc47146eb359f16ba2ab6440f5d33b" translate="yes" xml:space="preserve">
          <source>This form is to compare the given two paths on the filesystem. You can omit the &lt;code&gt;--no-index&lt;/code&gt; option when running the command in a working tree controlled by Git and at least one of the paths points outside the working tree, or when running the command outside a working tree controlled by Git. This form implies &lt;code&gt;--exit-code&lt;/code&gt;.</source>
          <target state="translated">이 형식은 파일 시스템에서 주어진 두 경로를 비교하는 것입니다. Git으로 제어되는 작업 트리에서 명령을 실행하고 경로 중 하나 이상이 작업 트리 외부를 가리 키거나 Git에서 제어하는 ​​작업 트리 외부에서 명령을 실행할 때 &lt;code&gt;--no-index&lt;/code&gt; 옵션을 생략 할 수 있습니다 . 이 형식은 &lt;code&gt;--exit-code&lt;/code&gt; 를 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="1a36c2e6e9bf305ffd5ef7a7e4c453ac93dfb865" translate="yes" xml:space="preserve">
          <source>This form is to view the changes on the branch containing and up to the second &amp;lt;commit&amp;gt;, starting at a common ancestor of both &amp;lt;commit&amp;gt;. &quot;git diff A...B&quot; is equivalent to &quot;git diff $(git merge-base A B) B&quot;. You can omit any one of &amp;lt;commit&amp;gt;, which has the same effect as using HEAD instead.</source>
          <target state="translated">이 양식은 두 &amp;lt;commit&amp;gt;의 공통 조상에서 시작하여 두 번째 &amp;lt;commit&amp;gt;을 포함하는 브랜치의 변경 사항을 보는 것입니다. &quot;git diff A ... B&quot;는 &quot;git diff $ (git merge-base AB) B&quot;와 같습니다. &amp;lt;commit&amp;gt; 중 하나를 생략하면 HEAD를 대신 사용하는 것과 동일한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="18011d68a19f669179582c8652eaff17f583329f" translate="yes" xml:space="preserve">
          <source>This form is to view the changes you have in your working tree relative to the named &amp;lt;commit&amp;gt;. You can use HEAD to compare it with the latest commit, or a branch name to compare with the tip of a different branch.</source>
          <target state="translated">이 양식은 이름이 지정된 &amp;lt;commit&amp;gt;과 관련하여 작업 트리에서 변경 한 내용을 보는 것입니다. HEAD를 사용하여 최신 커밋과 비교하거나 분기 이름을 다른 분기의 팁과 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c3233dc5774a7d1fc399a8b304cc732bba72d9f" translate="yes" xml:space="preserve">
          <source>This form is to view the changes you made relative to the index (staging area for the next commit). In other words, the differences are what you &lt;code&gt;could&lt;/code&gt; tell Git to further add to the index but you still haven&amp;rsquo;t. You can stage these changes by using &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;.</source>
          <target state="translated">이 양식은 인덱스 (다음 커밋의 스테이징 영역)와 관련하여 변경 한 내용을 확인하기위한 것입니다. 즉, 차이는 당신이 무엇을 &lt;code&gt;could&lt;/code&gt; 인덱스에 더 추가로 망할 놈의 말하지만 당신은 아직하지 않았습니다. &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 을 사용하여 이러한 변경 사항을 준비 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee8e76f95895702db36db495b0e53027904973c9" translate="yes" xml:space="preserve">
          <source>This form is to view the changes you staged for the next commit relative to the named &amp;lt;commit&amp;gt;. Typically you would want comparison with the latest commit, so if you do not give &amp;lt;commit&amp;gt;, it defaults to HEAD. If HEAD does not exist (e.g. unborn branches) and &amp;lt;commit&amp;gt; is not given, it shows all staged changes. --staged is a synonym of --cached.</source>
          <target state="translated">이 양식은 명명 된 &amp;lt;commit&amp;gt;을 기준으로 다음 커밋에 대해 준비한 변경 사항을 확인하기위한 것입니다. 일반적으로 최신 커밋과 비교를 원하므로 &amp;lt;commit&amp;gt;을 제공하지 않으면 기본값은 HEAD입니다. HEAD가 존재하지 않고 (예 : 태어나지 않은 지점) &amp;lt;commit&amp;gt;이 제공되지 않으면 모든 단계적 변경 사항이 표시됩니다. --staged는 --cached와 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="51dda6a69f38e64f972e32a62549822542d75887" translate="yes" xml:space="preserve">
          <source>This form is to view the differences between the raw contents of two blob objects.</source>
          <target state="translated">이 양식은 두 Blob 오브젝트의 원시 컨텐츠 간의 차이점을 확인하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="395d78419362cad7438eb6eae46785d35953f019" translate="yes" xml:space="preserve">
          <source>This form resets the current branch head to &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; and possibly updates the index (resetting it to the tree of &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;) and the working tree depending on &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is omitted, defaults to &lt;code&gt;--mixed&lt;/code&gt;. The &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; must be one of the following:</source>
          <target state="translated">이 양식은 현재 분기 헤드를 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 으로 재설정하고 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 에 따라 색인 ( &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 의 트리로 재설정 ) 및 작업 트리를 업데이트합니다 . 경우 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 로, 기본적으로 생략 &lt;code&gt;--mixed&lt;/code&gt; 을 . &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 다음 중 하나 여야합니다 :</target>
        </trans-unit>
        <trans-unit id="90bcd35d4969f3a90ba2bd18f27a5c6eb93f333b" translate="yes" xml:space="preserve">
          <source>This form will use the first line matching the given POSIX regex. If &amp;lt;start&amp;gt; is a regex, it will search from the end of the previous &lt;code&gt;-L&lt;/code&gt; range, if any, otherwise from the start of file. If &amp;lt;start&amp;gt; is &amp;ldquo;^/regex/&amp;rdquo;, it will search from the start of file. If &amp;lt;end&amp;gt; is a regex, it will search starting at the line given by &amp;lt;start&amp;gt;.</source>
          <target state="translated">이 양식은 주어진 POSIX 정규식과 일치하는 첫 번째 줄을 사용합니다. &amp;lt;start&amp;gt;가 정규식 인 경우 이전 &lt;code&gt;-L&lt;/code&gt; 범위 의 끝 (있는 경우)에서 검색하고, 그렇지 않으면 파일 시작에서 검색합니다. &amp;lt;start&amp;gt;가&amp;ldquo;^ / regex /&amp;rdquo;인 경우 파일 시작 부분부터 검색합니다. &amp;lt;end&amp;gt;가 정규 표현식 인 경우 &amp;lt;start&amp;gt;에서 제공 한 줄부터 검색합니다.</target>
        </trans-unit>
        <trans-unit id="b42c261dd1828c15332725a480fa7095bcc76b2a" translate="yes" xml:space="preserve">
          <source>This format expects the first line of the file to contain the &quot;Cc:&quot; value and the &quot;Subject:&quot; of the message as the second line.</source>
          <target state="translated">이 형식에서는 파일의 첫 번째 줄에 메시지의 &quot;Cc :&quot;값과 &quot;Subject :&quot;가 두 번째 줄로 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="105520fc7842a24e43537a27759a074335828eb6" translate="yes" xml:space="preserve">
          <source>This format is identical to version &lt;code&gt;0&lt;/code&gt;, with the following exceptions:</source>
          <target state="translated">이 형식은 다음을 제외 하고 버전 &lt;code&gt;0&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="fd22347e6ce1cebbfe9140a8d5df54f1132eb3e9" translate="yes" xml:space="preserve">
          <source>This format is no longer produced by any Git command, but is and will continue to be supported by &lt;code&gt;update-index --index-info&lt;/code&gt;.</source>
          <target state="translated">이 형식은 더 이상 Git 명령으로 생성되지 않지만 &lt;code&gt;update-index --index-info&lt;/code&gt; 에서 계속 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="e1e42b99834dd201113f33eae88b5856f686096e" translate="yes" xml:space="preserve">
          <source>This format is to put higher order stages into the index file and matches &lt;code&gt;git ls-files --stage&lt;/code&gt; output.</source>
          <target state="translated">이 형식은 인덱스 파일에 고차 단계를 배치하고 &lt;code&gt;git ls-files --stage&lt;/code&gt; 출력 과 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="483caba3e82677e09e2d521ebba75089a90ce09e" translate="yes" xml:space="preserve">
          <source>This format is to stuff &lt;code&gt;git ls-tree&lt;/code&gt; output into the index.</source>
          <target state="translated">이 형식은 &lt;code&gt;git ls-tree&lt;/code&gt; 출력을 색인에 넣는 것입니다.</target>
        </trans-unit>
        <trans-unit id="078ec0cba6df63b2f2fc0bbcd069e250ea13b628" translate="yes" xml:space="preserve">
          <source>This format is used to refer to another commit in a commit message and is the same as &lt;code&gt;--pretty='format:%C(auto)%h (%s, %ad)'&lt;/code&gt;. By default, the date is formatted with &lt;code&gt;--date=short&lt;/code&gt; unless another &lt;code&gt;--date&lt;/code&gt; option is explicitly specified. As with any &lt;code&gt;format:&lt;/code&gt; with format placeholders, its output is not affected by other options like &lt;code&gt;--decorate&lt;/code&gt; and &lt;code&gt;--walk-reflogs&lt;/code&gt;.</source>
          <target state="translated">이 형식은 커밋 메시지에서 다른 커밋을 참조하는 데 사용되며 &lt;code&gt;--pretty='format:%C(auto)%h (%s, %ad)'&lt;/code&gt; 합니다. 기본적으로 다른 &lt;code&gt;--date&lt;/code&gt; 옵션을 지정 하지 않으면 날짜는 &lt;code&gt;--date=short&lt;/code&gt; 로 형식이 지정됩니다. 다른 &lt;code&gt;format:&lt;/code&gt; 과 마찬가지로 형식 자리 표시 자와 함께 출력은 &lt;code&gt;--decorate&lt;/code&gt; 및 &lt;code&gt;--walk-reflogs&lt;/code&gt; 와 같은 다른 옵션의 영향을받지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="742c78626a467f269e89b016f43c5e1a7be4cd88" translate="yes" xml:space="preserve">
          <source>This gets rid of the &lt;code&gt;git-svn-id:&lt;/code&gt; lines at the end of every commit.</source>
          <target state="translated">이것은 모든 커밋이 끝날 때 &lt;code&gt;git-svn-id:&lt;/code&gt; 행을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="2acaf36aea784a80df7509fcb8e38355c645c5a7" translate="yes" xml:space="preserve">
          <source>This gives a very controlled flow of fixes. If you notice that you have applied a fix to e.g. &lt;code&gt;master&lt;/code&gt; that is also required in &lt;code&gt;maint&lt;/code&gt;, you will need to cherry-pick it (using &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick[1]&lt;/a&gt;) downwards. This will happen a few times and is nothing to worry about unless you do it very frequently.</source>
          <target state="translated">이것은 매우 통제 된 수정 흐름을 제공합니다. &lt;code&gt;maint&lt;/code&gt; 에도 필요한 &lt;code&gt;master&lt;/code&gt; 에 수정을 적용한 것을 확인한 경우 , &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick [1]을&lt;/a&gt; 사용하여 아래쪽으로 체리를 선택해야합니다 . 이것은 몇 번 일어날 것이며 매우 자주하지 않으면 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f3884c08aac0f5d8941c7814b274c9743619a33" translate="yes" xml:space="preserve">
          <source>This happens if the &lt;code&gt;subsystem&lt;/code&gt; rebase had conflicts, or used &lt;code&gt;--interactive&lt;/code&gt; to omit, edit, squash, or fixup commits; or if the upstream used one of &lt;code&gt;commit --amend&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt;, or a full history rewriting command like &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;&lt;code&gt;filter-repo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이렇게하면 어떻게 &lt;code&gt;subsystem&lt;/code&gt; REBASE이 충돌을했다, 또는 사용 &lt;code&gt;--interactive&lt;/code&gt; 생략, 편집, 스쿼시, 또는 픽스 업 커밋에; 또는 업스트림에서 &lt;code&gt;commit --amend&lt;/code&gt; , &lt;code&gt;reset&lt;/code&gt; 또는 &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt; &lt;code&gt;filter-repo&lt;/code&gt; &lt;/a&gt; 와 같은 전체 기록 다시 쓰기 명령 중 하나를 사용한 경우 .</target>
        </trans-unit>
        <trans-unit id="53ac63807fcdbfc7e050fb3151d6b086f2e9a274" translate="yes" xml:space="preserve">
          <source>This happens if the &lt;code&gt;subsystem&lt;/code&gt; rebase was a simple rebase and had no conflicts.</source>
          <target state="translated">경우에 발생 &lt;code&gt;subsystem&lt;/code&gt; REBASE 간단한 REBASE이었고, 충돌이 없었다.</target>
        </trans-unit>
        <trans-unit id="d414984e9f8d7bfd782c8f2da36b80bcd80ea28e" translate="yes" xml:space="preserve">
          <source>This has a few user-visible effects and caveats:</source>
          <target state="translated">여기에는 몇 가지 사용자가 볼 수있는 효과와주의 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c876a37c9c7633e47e1a6a38b1f16f75e32a3ed" translate="yes" xml:space="preserve">
          <source>This has a very similar UI to &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;revert&lt;/code&gt;, and lets you add untracked paths to the index.</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;revert&lt;/code&gt; UI가 매우 유사 하며 추적되지 않은 경로를 색인에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33280cb105ee3b71902ce7b15c9592fd52f73e30" translate="yes" xml:space="preserve">
          <source>This has a very similar UI to &lt;code&gt;update&lt;/code&gt;, and the staged information for selected paths are reverted to that of the HEAD version. Reverting new paths makes them untracked.</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 할 UI가 매우 유사 하며 선택한 경로에 대한 준비된 정보가 HEAD 버전의 정보로 되돌아갑니다. 새로운 경로를 되 돌리면 추적되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d4512b846dcedcc9cf4704e69eaeda15e1830db" translate="yes" xml:space="preserve">
          <source>This has been requested by some kernel developers because some bugs called sporadic bugs do not appear in all the kernel builds because they are very dependent on the compiler output.</source>
          <target state="translated">이는 일부 커널 개발자가 요청한 것으로 산발적 버그라고하는 일부 버그는 컴파일러 출력에 크게 의존하기 때문에 모든 커널 빌드에 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b93781d2b5ee24d7b760545bc5177eb80e4c3e22" translate="yes" xml:space="preserve">
          <source>This has the advantage that it will be saved in your &lt;code&gt;CVS/Root&lt;/code&gt; files and you don&amp;rsquo;t need to worry about always setting the correct environment variable. SSH users restricted to &lt;code&gt;git-shell&lt;/code&gt; don&amp;rsquo;t need to override the default with CVS_SERVER (and shouldn&amp;rsquo;t) as &lt;code&gt;git-shell&lt;/code&gt; understands &lt;code&gt;cvs&lt;/code&gt; to mean &lt;code&gt;git-cvsserver&lt;/code&gt; and pretends that the other end runs the real &lt;code&gt;cvs&lt;/code&gt; better.</source>
          <target state="translated">이는 &lt;code&gt;CVS/Root&lt;/code&gt; 파일에 저장 되므로 항상 올바른 환경 변수 설정에 대해 걱정할 필요가 없다는 이점이 있습니다 . 제한 SSH 사용자 &lt;code&gt;git-shell&lt;/code&gt; CVS_SERVER에 기본값을 재정의해야 (그리고 안)하지 않는 &lt;code&gt;git-shell&lt;/code&gt; 이해 &lt;code&gt;cvs&lt;/code&gt; 평균에 &lt;code&gt;git-cvsserver&lt;/code&gt; 하고 다른 쪽 끝이 실제 실행되는 척 &lt;code&gt;cvs&lt;/code&gt; 더합니다.</target>
        </trans-unit>
        <trans-unit id="f27a3b2d1e595dbb21c1b28424b4a89305bcf439" translate="yes" xml:space="preserve">
          <source>This has two implications:</source>
          <target state="translated">여기에는 두 가지 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2d38b5ae6dea81df64d435d13a5c9c9c6e43a8c" translate="yes" xml:space="preserve">
          <source>This header line is followed by the following information at least once for each commit:</source>
          <target state="translated">이 헤더 행 다음에는 각 커밋마다 최소한 한 번 다음 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="aac19de1c954c0a5c2aba42bf1f288afbf74cabf" translate="yes" xml:space="preserve">
          <source>This helper uses specified file descriptors to connect to a remote Git server. This is not meant for end users but for programs and scripts calling git fetch, push or archive.</source>
          <target state="translated">이 도우미는 지정된 파일 설명자를 사용하여 원격 Git 서버에 연결합니다. 이것은 최종 사용자를위한 것이 아니라 git fetch, push 또는 archive를 호출하는 프로그램 및 스크립트를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="eafdc2cefff4153e88df550a24ce4b00606582ea" translate="yes" xml:space="preserve">
          <source>This hook can be used in conjunction with a corresponding pre-commit hook to save and restore any form of metadata associated with the working tree (e.g.: permissions/ownership, ACLS, etc). See contrib/hooks/setgitperms.perl for an example of how to do this.</source>
          <target state="translated">이 후크는 해당 사전 커밋 후크와 함께 사용하여 작업 트리와 관련된 모든 형식의 메타 데이터 (예 : 권한 / 소유권, ACLS 등)를 저장하고 복원 할 수 있습니다. 이를 수행하는 방법에 대한 예는 contrib / hooks / setgitperms.perl을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9fae8c19d5ced3830760d386f8db3473a746ea76" translate="yes" xml:space="preserve">
          <source>This hook can be used to perform repository validity checks, auto-display differences from the previous HEAD if different, or set working dir metadata properties.</source>
          <target state="translated">이 후크는 저장소 유효성 검사를 수행하거나, 이전 HEAD와 다른 경우 자동 표시 차이점을 수행하거나 작업 디렉토리 메타 데이터 특성을 설정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89a247d66f7dd9fd927ac160899ee7ad4eefe257" translate="yes" xml:space="preserve">
          <source>This hook can be used to prevent &lt;code&gt;forced&lt;/code&gt; update on certain refs by making sure that the object name is a commit object that is a descendant of the commit object named by the old object name. That is, to enforce a &quot;fast-forward only&quot; policy.</source>
          <target state="translated">이 후크는 오브젝트 이름이 이전 오브젝트 이름으로 명명 된 커미트 오브젝트의 자손 인 커미트 오브젝트인지 확인하여 특정 참조에서 &lt;code&gt;forced&lt;/code&gt; 업데이트 를 방지하는 데 사용될 수 있습니다 . 즉, &quot;빨리 감기&quot;정책을 시행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e2b4b08b5c7d529703ac2e4609fae5478174d015" translate="yes" xml:space="preserve">
          <source>This hook can be used, for example, to run &lt;code&gt;git update-server-info&lt;/code&gt; if the repository is packed and is served via a dumb transport.</source>
          <target state="translated">예를 들어 리포지토리가 압축되어 벙어리 전송을 통해 제공 되는 경우이 후크를 사용하여 &lt;code&gt;git update-server-info&lt;/code&gt; 를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec8359ca4fe68868d4a094d214fa5c736b07b686" translate="yes" xml:space="preserve">
          <source>This hook does not affect the outcome of &lt;code&gt;git receive-pack&lt;/code&gt;, as it is called after the real work is done.</source>
          <target state="translated">이 후크는 실제 작업이 완료된 후 호출되므로 &lt;code&gt;git receive-pack&lt;/code&gt; 의 결과에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4f1494681f56d1e644fae421a13f75381d1bf104" translate="yes" xml:space="preserve">
          <source>This hook executes once for the receive operation. It takes no arguments, but for each ref to be updated it receives on standard input a line of the format:</source>
          <target state="translated">이 후크는 수신 작업을 위해 한 번 실행됩니다. 인수는 없지만 각 참조가 업데이트 될 때마다 표준 입력에서 다음 형식의 행을 수신합니다.</target>
        </trans-unit>
        <trans-unit id="1c705c0b531046d9558421e4543f9aca35624390" translate="yes" xml:space="preserve">
          <source>This hook executes once for the receive operation. It takes no arguments, but gets the same information as the &lt;a href=&quot;#pre-receive&quot;&gt;&lt;em&gt;pre-receive&lt;/em&gt;&lt;/a&gt; hook does on its standard input.</source>
          <target state="translated">이 후크는 수신 작업을 위해 한 번 실행됩니다. 인수는 없지만 표준 입력 에서 &lt;a href=&quot;#pre-receive&quot;&gt;&lt;em&gt;사전 수신&lt;/em&gt;&lt;/a&gt; 후크 와 동일한 정보를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="8f404b0d7afced029532dd1c0ce00c69033fa119" translate="yes" xml:space="preserve">
          <source>This hook is called before any refname is updated and before any fast-forward checks are performed.</source>
          <target state="translated">이 후크는 참조 이름이 업데이트되기 전에 그리고 빨리 감기 검사가 수행되기 전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6f4d4e6bc9f3d3e90e8224d9cc9d15607a5f159d" translate="yes" xml:space="preserve">
          <source>This hook is called by &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and can be used to prevent a push from taking place. The hook is called with two parameters which provide the name and location of the destination remote, if a named remote is not being used both values will be the same.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-push&quot;&gt;git-push [1]에&lt;/a&gt; 의해 호출되며 푸시 가 발생하지 않도록하는 데 사용될 수 있습니다. 후크는 대상 원격의 이름과 위치를 제공하는 두 개의 매개 변수와 함께 호출됩니다. 명명 된 원격을 사용하지 않는 경우 두 값이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b761c5f63f99b7c22c6e4ca4e1bd741b6a19c509" translate="yes" xml:space="preserve">
          <source>This hook is called by &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; and can be used to prevent a branch from getting rebased. The hook may be called with one or two parameters. The first parameter is the upstream from which the series was forked. The second parameter is the branch being rebased, and is not set when rebasing the current branch.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]에&lt;/a&gt; 의해 호출되며 브랜치가 리베이스되지 않도록하는 데 사용될 수 있습니다. 후크는 하나 또는 두 개의 매개 변수로 호출 될 수 있습니다. 첫 번째 매개 변수는 시리즈가 분기 된 업스트림입니다. 두 번째 매개 변수는 리베이스되는 브랜치이며 현재 브랜치를 리베이스 할 때 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc84f5afc2cc3712fb061152c42b83b5432e2d28" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;. It takes a single parameter, the name of the file that holds the proposed commit log message. Exiting with a non-zero status causes &lt;code&gt;git am&lt;/code&gt; to abort before applying the patch.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-am&quot;&gt;git-am [1]에&lt;/a&gt; 의해 호출됩니다 . 제안 된 커미트 로그 메시지를 보유하는 파일 이름 인 단일 매개 변수를 사용합니다. 0이 아닌 상태로 종료 하면 패치를 적용하기 전에 &lt;code&gt;git am&lt;/code&gt; 이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="109f1251e93ab76b92d28a05e1f40ca3ae3e2435" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;. It takes no parameter, and is invoked after the patch is applied and a commit is made.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-am&quot;&gt;git-am [1]에&lt;/a&gt; 의해 호출됩니다 . 매개 변수를 사용하지 않으며 패치가 적용되고 커미트 된 후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="31dd1042d3a6d88015bf6a789db56141bf61f664" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;. It takes no parameter, and is invoked after the patch is applied, but before a commit is made.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-am&quot;&gt;git-am [1]에&lt;/a&gt; 의해 호출됩니다 . 매개 변수를 사용하지 않으며 패치가 적용된 후, 그러나 커미트되기 전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4126a7ec7eb0a54d9b99d1f389fd70ce96c40950" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; and &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;, and can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes a single parameter, the name of the file that holds the proposed commit log message. Exiting with a non-zero status causes the command to abort.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 및 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]에&lt;/a&gt; 의해 호출되며 &lt;code&gt;--no-verify&lt;/code&gt; 옵션을 사용하여 무시할 수 있습니다 . 제안 된 커미트 로그 메시지를 보유하는 파일 이름 인 단일 매개 변수를 사용합니다. 0이 아닌 상태로 종료하면 명령이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="977ece26ae3c0446a7497462b09e90162737d6ca" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; right after preparing the default log message, and before the editor is started.</source>
          <target state="translated">이 후크는 기본 로그 메시지를 준비한 직후와 편집기가 시작되기 전에 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]에&lt;/a&gt; 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ae25bad855fc10ca5e955357c713cdbb31a472c" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;, and can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes no parameters, and is invoked before obtaining the proposed commit log message and making a commit. Exiting with a non-zero status from this script causes the &lt;code&gt;git commit&lt;/code&gt; command to abort before creating a commit.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]에&lt;/a&gt; 의해 호출되며 &lt;code&gt;--no-verify&lt;/code&gt; 옵션을 사용하여 무시할 수 있습니다 . 매개 변수가 없으며 제안 된 확약 로그 메시지를 확보하고 확약하기 전에 호출됩니다. 이 스크립트에서 0이 아닌 상태로 종료하면 &lt;code&gt;git commit&lt;/code&gt; 을 만들기 전에 git commit 명령이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="21226463d529e8f7d5082c27401d959f905ec4d1" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;. It takes no parameters, and is invoked after a commit is made.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]에&lt;/a&gt; 의해 호출됩니다 . 매개 변수를 사용하지 않으며 확약 후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0a4097349c79cead9de93e647cb9ba47cbed7c91" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;, and can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes no parameters, and is invoked after the merge has been carried out successfully and before obtaining the proposed commit log message to make a commit. Exiting with a non-zero status from this script causes the &lt;code&gt;git merge&lt;/code&gt; command to abort before creating a commit.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]에&lt;/a&gt; 의해 호출되며 &lt;code&gt;--no-verify&lt;/code&gt; 옵션을 사용하여 무시할 수 있습니다 . 매개 변수를 취하지 않으며 병합이 성공적으로 수행 된 후 그리고 커미트를 작성하기 위해 제안 된 커미트 로그 메시지를 얻기 전에 호출됩니다. 이 스크립트에서 0이 아닌 상태로 종료 하면 커밋을 만들기 전에 &lt;code&gt;git merge&lt;/code&gt; 명령이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="de911dadfd0a4abc2b13baa4ccbc2ae0aca9f055" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;, which happens when a &lt;code&gt;git pull&lt;/code&gt; is done on a local repository. The hook takes a single parameter, a status flag specifying whether or not the merge being done was a squash merge. This hook cannot affect the outcome of &lt;code&gt;git merge&lt;/code&gt; and is not executed, if the merge failed due to conflicts.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]에&lt;/a&gt; 의해 호출되는데 , 이는 로컬 리포지토리에서 &lt;code&gt;git pull&lt;/code&gt; 이 수행 될 때 발생 합니다. 후크는 단일 매개 변수, 수행중인 병합이 스쿼시 병합인지 여부를 지정하는 상태 플래그를 사용합니다. 이 후크는 &lt;code&gt;git merge&lt;/code&gt; 의 결과에 영향을 줄 수 없으며 충돌로 인해 병합이 실패한 경우에는 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76961cafe28e294daa6f1b287a02eb4fe4bf07aa" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository, and when the push tries to update the branch that is currently checked out and the &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; configuration variable is set to &lt;code&gt;updateInstead&lt;/code&gt;. Such a push by default is refused if the working tree and the index of the remote repository has any difference from the currently checked out commit; when both the working tree and the index match the current commit, they are updated to match the newly pushed tip of the branch. This hook is to be used to override the default behaviour.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; 이 &lt;code&gt;git push&lt;/code&gt; 에 반응 하고 리포지토리의 참조를 업데이트 할 때, 그리고 푸시가 현재 체크 아웃 된 브랜치 및 &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; 구성 변수 를 업데이트하려고 할 때 호출됩니다 . &lt;code&gt;updateInstead&lt;/code&gt; 로 설정되어 있습니다. 작업 트리와 원격 저장소의 색인이 현재 체크 아웃 된 커밋과 다른 경우 기본적으로 이러한 푸시는 거부됩니다. 작업 트리와 인덱스가 모두 현재 커밋과 일치하면 분기의 새로 푸시 된 팁과 일치하도록 업데이트됩니다. 이 후크는 기본 동작을 재정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5a56dac625f1205849f2b5f6e3619a708d3ea48e" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository. It executes on the remote repository once after all the refs have been updated.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; 이 &lt;code&gt;git push&lt;/code&gt; 에 반응 하고 리포지토리에서 참조를 업데이트 할 때 호출됩니다 . 모든 참조가 업데이트 된 후 원격 저장소에서 한 번 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="390ce0821ef413eec43c389641cce2dfc9687135" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository. Just before starting to update refs on the remote repository, the pre-receive hook is invoked. Its exit status determines the success or failure of the update.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; 이 &lt;code&gt;git push&lt;/code&gt; 에 반응 하고 리포지토리에서 참조를 업데이트 할 때 호출됩니다 . 원격 저장소에서 참조 업데이트를 시작하기 직전에 사전 수신 후크가 호출됩니다. 종료 상태에 따라 업데이트 성공 여부가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="f508c67d780c6e440d114ab5a4809e8db15887c6" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository. Just before updating the ref on the remote repository, the update hook is invoked. Its exit status determines the success or failure of the ref update.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; 이 &lt;code&gt;git push&lt;/code&gt; 에 반응 하고 리포지토리에서 참조를 업데이트 할 때 호출됩니다 . 원격 저장소에서 참조를 업데이트하기 직전에 업데이트 후크가 호출됩니다. 종료 상태에 따라 참조 업데이트의 성공 또는 실패가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="c94fc31562e49c2e1f57905c2984b3787d6eb579" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt;. It takes a single parameter, the name of the file that holds the e-mail to be sent. Exiting with a non-zero status causes &lt;code&gt;git send-email&lt;/code&gt; to abort before sending any e-mails.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]에&lt;/a&gt; 의해 호출됩니다 . 전송할 전자 우편을 보유한 파일 이름 인 단일 매개 변수를 사용합니다. 0이 아닌 상태로 종료하면 &lt;code&gt;git send-email&lt;/code&gt; 을 보내기 전에 git send-email 이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="898dc345a1faef7e78cc6f07a48d416762cf9e72" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git gc --auto&lt;/code&gt; (see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;). It takes no parameter, and exiting with non-zero status from this script causes the &lt;code&gt;git gc --auto&lt;/code&gt; to abort.</source>
          <target state="translated">이 후크는 &lt;code&gt;git gc --auto&lt;/code&gt; 에 의해 호출됩니다 ( &lt;a href=&quot;git-gc&quot;&gt;git-gc [1] 참조&lt;/a&gt; ). 매개 변수가 &lt;code&gt;git gc --auto&lt;/code&gt; 스크립트에서 0이 아닌 상태로 종료하면 git gc --auto 가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="fa504b80ab7d4ab7fd02bb1c09f7267f7ffd0b87" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git-p4 submit&lt;/code&gt;. It takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevent &lt;code&gt;git-p4 submit&lt;/code&gt; from launching. Run &lt;code&gt;git-p4 submit --help&lt;/code&gt; for details.</source>
          <target state="translated">이 후크는 &lt;code&gt;git-p4 submit&lt;/code&gt; 에 의해 호출됩니다 . 매개 변수가 없으며 표준 입력에서 아무것도 가져 오지 않습니다. 이 스크립트에서 0이 아닌 상태로 종료하면 &lt;code&gt;git-p4 submit&lt;/code&gt; 이 시작되지 않습니다. 자세한 내용은 &lt;code&gt;git-p4 submit --help&lt;/code&gt; 를 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="e8569f58a670ba9d05dfd0c2191295df64e04e73" translate="yes" xml:space="preserve">
          <source>This hook is invoked by commands that rewrite commits (&lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; when called with &lt;code&gt;--amend&lt;/code&gt; and &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;; however, full-history (re)writing tools like &lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import[1]&lt;/a&gt; or &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt; typically do not call it!). Its first argument denotes the command it was invoked by: currently one of &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;. Further command-dependent arguments may be passed in the future.</source>
          <target state="translated">이 후크는 커밋을 다시 작성하는 명령 ( &lt;code&gt;--amend&lt;/code&gt; 및 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; 과 함께 호출되면 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 이지만 &lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import [1]&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo는&lt;/a&gt; 일반적으로 그것을 호출하지 않습니다!). 첫 번째 인수는 현재 &lt;code&gt;amend&lt;/code&gt; 또는 &lt;code&gt;rebase&lt;/code&gt; 중 하나에 의해 호출 된 명령을 나타냅니다 . 추후 명령 종속 인수가 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b20b75526e2af7ef8179932e884a838f68429b3" translate="yes" xml:space="preserve">
          <source>This hook is invoked when a &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; or &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; is run after having updated the worktree. The hook is given three parameters: the ref of the previous HEAD, the ref of the new HEAD (which may or may not have changed), and a flag indicating whether the checkout was a branch checkout (changing branches, flag=1) or a file checkout (retrieving a file from the index, flag=0). This hook cannot affect the outcome of &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt;.</source>
          <target state="translated">이 후크는 작업 트리 를 업데이트 한 후 &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-switch&quot;&gt;git-switch [1]&lt;/a&gt; 을 실행할 때 호출됩니다 . 후크에는 이전 HEAD의 참조, 새 HEAD의 참조 (변경되었거나 변경되지 않았을 수 있음) 및 체크 아웃이 분기 체크 아웃 (분기 변경, 플래그 = 1)인지를 나타내는 플래그 또는 파일 체크 아웃 (인덱스에서 파일 검색, 플래그 = 0) 이 후크는 &lt;code&gt;git switch&lt;/code&gt; 또는 &lt;code&gt;git checkout&lt;/code&gt; 결과에 영향을 줄 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7b0692c459d4a723afc690b678a8556c7e5d3814" translate="yes" xml:space="preserve">
          <source>This hook is invoked when the configuration option &lt;code&gt;core.fsmonitor&lt;/code&gt; is set to &lt;code&gt;.git/hooks/fsmonitor-watchman&lt;/code&gt;. It takes two arguments, a version (currently 1) and the time in elapsed nanoseconds since midnight, January 1, 1970.</source>
          <target state="translated">이 후크는 구성 옵션 &lt;code&gt;core.fsmonitor&lt;/code&gt; 가 &lt;code&gt;.git/hooks/fsmonitor-watchman&lt;/code&gt; 으로 설정된 경우에 호출됩니다 . 1970 년 1 월 1 일 자정 이후 버전 (현재 1)과 경과 된 나노초 단위의 두 가지 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1ea8190ee0fad5a3aca31c578a724c322c0d57cb" translate="yes" xml:space="preserve">
          <source>This hook is invoked when the index is written in read-cache.c do_write_locked_index.</source>
          <target state="translated">이 후크는 인덱스가 read-cache.c do_write_locked_index에 기록 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bbcd7cc3d137fc9e83cb037a7ffe28a3a104cf5b" translate="yes" xml:space="preserve">
          <source>This hook is invoked with the environment variable &lt;code&gt;GIT_EDITOR=:&lt;/code&gt; if the command will not bring up an editor to modify the commit message.</source>
          <target state="translated">이 후크는 환경 변수 &lt;code&gt;GIT_EDITOR=:&lt;/code&gt; 로 명령이 커밋 메시지를 수정하기 위해 편집기를 불러 오지 않으면 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="ddc7ece9286909c0de44abe41d5a762b67552ed5" translate="yes" xml:space="preserve">
          <source>This hook is meant primarily for notification, and cannot affect the outcome of &lt;code&gt;git am&lt;/code&gt;.</source>
          <target state="translated">이 후크는 주로 알림을위한 것이며 &lt;code&gt;git am&lt;/code&gt; 의 결과에 영향을 줄 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="448e187d53f17c70cda00f92a3ee55c4bde07472" translate="yes" xml:space="preserve">
          <source>This hook is meant primarily for notification, and cannot affect the outcome of &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">이 후크는 주로 알림을위한 것이며 &lt;code&gt;git commit&lt;/code&gt; 결과에 영향을 줄 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="08260832c28c95684a1993d7203db5c6a733006a" translate="yes" xml:space="preserve">
          <source>This hook is meant primarily for notification, and cannot affect the outcome of &lt;code&gt;git receive-pack&lt;/code&gt;.</source>
          <target state="translated">이 후크는 주로 알림을위한 것이며 &lt;code&gt;git receive-pack&lt;/code&gt; 의 결과에 영향을 줄 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f1b9eafafbdf014b8c082347223fc7e3e439cd3c" translate="yes" xml:space="preserve">
          <source>This implies &lt;code&gt;--revs&lt;/code&gt;. In addition to the list of revision arguments read from the standard input, pretend as if all refs under &lt;code&gt;refs/&lt;/code&gt; are specified to be included.</source>
          <target state="translated">이것은 &lt;code&gt;--revs&lt;/code&gt; 를 의미 합니다 . 표준 입력에서 읽은 수정 인수 목록 외에도 &lt;code&gt;refs/&lt;/code&gt; 아래의 모든 참조 가 포함되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="00f6fe101136dac1c604175fe5bf787266d15317" translate="yes" xml:space="preserve">
          <source>This implies &lt;code&gt;--revs&lt;/code&gt;. When processing the list of revision arguments read from the standard input, limit the objects packed to those that are not already packed.</source>
          <target state="translated">이것은 &lt;code&gt;--revs&lt;/code&gt; 를 의미 합니다 . 표준 입력에서 읽은 수정 인수 목록을 처리 할 때 압축되지 않은 개체로 압축 된 개체를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="23abf25dbec44cc1a257bc71a457bb760d4a79eb" translate="yes" xml:space="preserve">
          <source>This implies the &lt;code&gt;--topo-order&lt;/code&gt; option by default, but the &lt;code&gt;--date-order&lt;/code&gt; option may also be specified.</source>
          <target state="translated">이는 기본적으로 &lt;code&gt;--topo-order&lt;/code&gt; 옵션을 의미 하지만 &lt;code&gt;--date-order&lt;/code&gt; 옵션도 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bafb6d097d43ca4ccca730edb887425acfba8b5" translate="yes" xml:space="preserve">
          <source>This imports the specified depot into &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; in an existing Git repository. The &lt;code&gt;--branch&lt;/code&gt; option can be used to specify a different branch to be used for the p4 content.</source>
          <target state="translated">지정된 저장소를 기존 Git 저장소의 &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; 로 가져옵니다 . &lt;code&gt;--branch&lt;/code&gt; 옵션은 P4 콘텐츠를 사용하는 다른 지점을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="505428074ae07b004fad59f4eaeb272274ac2c6b" translate="yes" xml:space="preserve">
          <source>This information can be used to determine what commit was the tip of a branch &quot;2 days ago&quot;.</source>
          <target state="translated">이 정보는 어떤 커밋이 &quot;2 일 전&quot;브랜치의 팁 이었는지 판별하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86187244d1368864bf6af8ccb054656e32b6a58b" translate="yes" xml:space="preserve">
          <source>This instructs git svn to recode pathnames to a given encoding. It can be used by windows users and by those who work in non-utf8 locales to avoid corrupted file names with non-ASCII characters. Valid encodings are the ones supported by Perl&amp;rsquo;s Encode module.</source>
          <target state="translated">이것은 git svn에게 경로명을 주어진 인코딩으로 코딩하도록 지시합니다. Windows 사용자와 비 UTF8 로케일에서 작업하는 사용자가 ASCII가 아닌 문자로 손상된 파일 이름을 피할 수 있습니다. 유효한 인코딩은 Perl의 Encode 모듈에서 지원되는 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="0909b4167b1b6cfc93db8cafdc74248d3901c792" translate="yes" xml:space="preserve">
          <source>This is a deprecated synonym for &lt;code&gt;repack.writeBitmaps&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;repack.writeBitmaps&lt;/code&gt; 에 대한 더 이상 사용되지 않는 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="0663f3ff3f5e643bb58ee19e6a44fd14680c40d5" translate="yes" xml:space="preserve">
          <source>This is a login shell for SSH accounts to provide restricted Git access. It permits execution only of server-side Git commands implementing the pull/push functionality, plus custom commands present in a subdirectory named &lt;code&gt;git-shell-commands&lt;/code&gt; in the user&amp;rsquo;s home directory.</source>
          <target state="translated">SSH 계정이 제한된 Git 액세스를 제공하기위한 로그인 셸입니다. 풀 / 푸시 기능을 구현하는 서버 측 Git 명령과 사용자 홈 디렉토리의 &lt;code&gt;git-shell-commands&lt;/code&gt; 하위 디렉토리에있는 사용자 정의 명령 만 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb9b1700493e02e1c42808252a2a81a90b07f06f" translate="yes" xml:space="preserve">
          <source>This is a modified recursive strategy. When merging trees A and B, if B corresponds to a subtree of A, B is first adjusted to match the tree structure of A, instead of reading the trees at the same level. This adjustment is also done to the common ancestor tree.</source>
          <target state="translated">이것은 수정 된 재귀 전략입니다. 트리 A와 B를 병합 할 때 B가 A의 하위 트리에 해당하는 경우 동일한 레벨에서 트리를 읽는 대신 B가 A의 트리 구조와 일치하도록 먼저 조정됩니다. 이 조정은 공통 조상 트리에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="94478372a5a22fcace1286299ca604a903c0373f" translate="yes" xml:space="preserve">
          <source>This is a multi-valued variable, and an empty value can be used in a higher priority configuration file (e.g. &lt;code&gt;.git/config&lt;/code&gt; in a repository) to clear the values inherited from a lower priority configuration files (e.g. &lt;code&gt;$HOME/.gitconfig&lt;/code&gt;).</source>
          <target state="translated">이는 다중 값 변수이며, 우선 순위가 높은 구성 파일 (예 : 저장소의 &lt;code&gt;.git/config&lt;/code&gt; ) 에서 빈 값을 사용하여 우선 순위 가 낮은 구성 파일 (예 : &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; ) 에서 상속 된 값을 지울 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="9800795b0feafe785919ba7eb03d901a5af98b6d" translate="yes" xml:space="preserve">
          <source>This is a potentially &lt;em&gt;dangerous&lt;/em&gt; mode of operation. It rewrites history, which does not bode well when you published that history already. Do &lt;strong&gt;not&lt;/strong&gt; use this option unless you have read &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; carefully.</source>
          <target state="translated">이것은 잠재적으로 &lt;em&gt;위험한&lt;/em&gt; 작동 모드입니다. 기록을 다시 작성하므로 기록을 이미 게시했을 때 제대로 표시되지 않습니다. 마십시오 &lt;strong&gt;하지&lt;/strong&gt; 당신이 읽기가 없다면이 옵션을 사용하여 &lt;a href=&quot;git-rebase&quot;&gt;자식-REBASE [1]&lt;/a&gt; 을주의 깊게.</target>
        </trans-unit>
        <trans-unit id="7393bcbfeab09d874001a82423e807bb091915e9" translate="yes" xml:space="preserve">
          <source>This is a quick summary of the major commands; the previous chapters explain how these work in more detail.</source>
          <target state="translated">다음은 주요 명령에 대한 간략한 요약입니다. 이전 장에서는 이러한 기능이 어떻게 작동하는지 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e6b70a1472f7c00669a56c92197ed227d5be5866" translate="yes" xml:space="preserve">
          <source>This is a shorthand for &quot;--pretty=oneline --abbrev-commit&quot; used together.</source>
          <target state="translated">이것은 함께 사용되는 &quot;--pretty = oneline --abbrev-commit&quot;의 줄임말입니다.</target>
        </trans-unit>
        <trans-unit id="18c84bcba1b16c1ac1cf14d08c1c68d27e4599a1" translate="yes" xml:space="preserve">
          <source>This is a total waste of time and effort on a filesystem that orders data writes properly, but can be useful for filesystems that do not use journalling (traditional UNIX filesystems) or that only journal metadata and not file contents (OS X&amp;rsquo;s HFS+, or Linux ext3 with &quot;data=writeback&quot;).</source>
          <target state="translated">이는 데이터 쓰기를 올바르게 주문하는 파일 시스템에서 시간과 노력을 낭비하지만 저널링 (전통적인 UNIX 파일 시스템)을 사용하지 않거나 파일 내용이 아닌 저널 메타 데이터 만있는 파일 시스템 (OS X의 HFS + 또는 Linux)에 유용 할 수 있습니다. &quot;data = writeback&quot;이있는 ext3).</target>
        </trans-unit>
        <trans-unit id="554ab63db8a74b017dac093a21d0557d821484db" translate="yes" xml:space="preserve">
          <source>This is a toy format. The current time and time zone of this system is always copied into the identity string at the time it is being created by fast-import. There is no way to specify a different time or time zone.</source>
          <target state="translated">이것은 장난감 형식입니다. 이 시스템의 현재 시간 및 시간대는 빠른 가져 오기로 작성 될 때 항상 식별 문자열에 복사됩니다. 다른 시간대 나 시간대를 지정할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="bc30d84517d5f02b55a3811eba6ffba9e6c0e4f0" translate="yes" xml:space="preserve">
          <source>This is a work in progress.</source>
          <target state="translated">현재 진행중인 작업입니다.</target>
        </trans-unit>
        <trans-unit id="3e77feb91313add3d7aff3491329020f7cd2b88e" translate="yes" xml:space="preserve">
          <source>This is an easy way to check out a particular version without having to make up a name for the new branch. You can still create a new branch (or tag) for this version later if you decide to.</source>
          <target state="translated">이것은 새로운 브랜치의 이름을 만들지 않고도 특정 버전을 체크 아웃하는 쉬운 방법입니다. 원하는 경우 나중에이 버전에 대한 새 분기 (또는 태그)를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86d03a90949a936d437c536daea902a3352ca567" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;rebase&lt;/code&gt; is used in a workflow that treats the history at the remote as the shared canonical one, and treats the work done on the branch you are rebasing as the third-party work to be integrated, and you are temporarily assuming the role of the keeper of the canonical history during the rebase. As the keeper of the canonical history, you need to view the history from the remote as &lt;code&gt;ours&lt;/code&gt; (i.e. &quot;our shared canonical history&quot;), while what you did on your side branch as &lt;code&gt;theirs&lt;/code&gt; (i.e. &quot;one contributor&amp;rsquo;s work on top of it&quot;).</source>
          <target state="translated">이는 &lt;code&gt;rebase&lt;/code&gt; 가 원격의 기록을 공유 정식 기록으로 취급하고 분기에서 수행 한 작업을 통합 할 타사 작업으로 취급하고 일시적으로 역할을 가정하는 워크 플로우에서 사용 되기 때문 입니다. rebase 동안 정식 역사의 골키퍼. 정식 역사의 골키퍼로서, 당신은 원격에서 역사를 볼 필요가 &lt;code&gt;ours&lt;/code&gt; 당신이 당신의 곁가지에 무슨 짓을했는지 동안 (즉, &quot;공동의 정식 역사&quot;)와 같은 &lt;code&gt;theirs&lt;/code&gt; (즉, &quot;그 위에 하나 명의 기여의 작품&quot; ).</target>
        </trans-unit>
        <trans-unit id="95a20fc02bc3cd4094f682df1ea1f755e327d688" translate="yes" xml:space="preserve">
          <source>This is called a &lt;code&gt;hunk header&lt;/code&gt;. The &quot;TEXT&quot; portion is by default a line that begins with an alphabet, an underscore or a dollar sign; this matches what GNU &lt;code&gt;diff -p&lt;/code&gt; output uses. This default selection however is not suited for some contents, and you can use a customized pattern to make a selection.</source>
          <target state="translated">이것을 &lt;code&gt;hunk header&lt;/code&gt; 라고합니다 . &quot;TEXT&quot;부분은 기본적으로 알파벳, 밑줄 또는 달러 기호로 시작하는 줄입니다. 이것은 GNU &lt;code&gt;diff -p&lt;/code&gt; 출력이 사용 하는 것과 일치 합니다. 그러나이 기본 선택은 일부 내용에 적합하지 않으며 사용자 정의 패턴을 사용하여 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85de32d717921314245903361d4033db93188253" translate="yes" xml:space="preserve">
          <source>This is default name of common system-wide configuration file.</source>
          <target state="translated">이것은 일반적인 시스템 전체 구성 파일의 기본 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8fabc38be889239efec56b25dba57afb3b308b5b" translate="yes" xml:space="preserve">
          <source>This is default name of fallback system-wide configuration file. This file is used only if per-instance configuration variable is not found.</source>
          <target state="translated">대체 시스템 전체 구성 파일의 기본 이름입니다. 이 파일은 인스턴스 별 구성 변수를 찾을 수없는 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e13cac7eff842df90d7031a70a4150ab3a8cdbc2" translate="yes" xml:space="preserve">
          <source>This is default name of per-instance configuration file. The format of this file is described above.</source>
          <target state="translated">인스턴스 별 구성 파일의 기본 이름입니다. 이 파일의 형식은 위에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ac99b50de3702f5d543e44c6b1ddc55b08d7471" translate="yes" xml:space="preserve">
          <source>This is designed to be as compact as possible.</source>
          <target state="translated">가능한 한 작게 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="d4d30dfd1772dd73a7b51cd065bd14037d1044bf" translate="yes" xml:space="preserve">
          <source>This is done to prevent you from losing your work-in-progress changes, and mixing your random changes in an unrelated merge commit. To illustrate, suppose you start from what has been committed last to your repository:</source>
          <target state="translated">이는 진행중인 작업 변경 내용을 잃지 않고 관련없는 병합 커밋에서 임의의 변경 내용을 혼합하지 않도록하기 위해 수행됩니다. 예를 들어, 저장소에 마지막으로 커밋 된 것부터 시작한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c5483036881ec5a0c568843866e403149495194d" translate="yes" xml:space="preserve">
          <source>This is how you read a blob (actually, not only a blob, but any type of object). To know how the function &lt;code&gt;read_object_with_reference()&lt;/code&gt; actually works, find the source code for it (something like &lt;code&gt;git grep
read_object_with | grep &quot;:[a-z]&quot;&lt;/code&gt; in the Git repository), and read the source.</source>
          <target state="translated">이것은 당신이 블롭을 읽는 방법입니다 (실제로 블롭뿐만 아니라 모든 유형의 객체). &lt;code&gt;read_object_with_reference()&lt;/code&gt; 함수가 실제로 어떻게 작동하는지 알아 보려면 소스 코드 ( &lt;code&gt;git grep read_object_with | grep &quot;:[a-z]&quot;&lt;/code&gt; 와 같은 것)를 찾아 소스를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="d94f65e687e225292db2cabccebd8f5b3adaa1d5" translate="yes" xml:space="preserve">
          <source>This is ideally suited for read-only updates, i.e., pulling from Git repositories.</source>
          <target state="translated">이것은 읽기 전용 업데이트, 즉 Git 리포지토리에서 가져 오기에 이상적입니다.</target>
        </trans-unit>
        <trans-unit id="4f74abb17322f51c4e08c52446429282a69cbb4c" translate="yes" xml:space="preserve">
          <source>This is intended to be used by the test suite only. It allows to force the version for the generated pack index, and to force 64-bit index entries on objects located above the given offset.</source>
          <target state="translated">이것은 테스트 스위트에서만 사용하기위한 것입니다. 생성 된 팩 색인의 버전을 강제 실행하고 지정된 오프셋 위에있는 오브젝트에서 64 비트 색인 항목을 강제 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8180429180a5d33dfa16e7d2805d2ac9f53f061d" translate="yes" xml:space="preserve">
          <source>This is just to get you into the groove for the most libified part of Git: the revision walker.</source>
          <target state="translated">이것은 Git의 가장 수정 된 부분 인 개정 워커에 대한 홈으로 들어가기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="dce30f3fbb0be29025f159d55505215087cce86b" translate="yes" xml:space="preserve">
          <source>This is known to &lt;code&gt;range-diff&lt;/code&gt; as &quot;dual coloring&quot;. Use &lt;code&gt;--no-dual-color&lt;/code&gt; to revert to color all lines according to the outer diff markers (and completely ignore the inner diff when it comes to color).</source>
          <target state="translated">이것은 &quot;이중 채색&quot;으로 &lt;code&gt;range-diff&lt;/code&gt; 가 다른 것으로 알려져 있습니다. 외부 diff 마커에 따라 모든 선의 &lt;code&gt;--no-dual-color&lt;/code&gt; 을 되돌리려면 --no-dual-color 를 사용하십시오 (그리고 색상과 관련하여 내부 diff를 완전히 무시하십시오).</target>
        </trans-unit>
        <trans-unit id="51ecbd5eaeeeee461a4969f3b0cb27dc975ebc23" translate="yes" xml:space="preserve">
          <source>This is made much worse if many files have to be fixed to resolve conflicts. That&amp;rsquo;s why such merges are called &quot;evil merges&quot;. They can make regressions very difficult to track down. It can even be misleading to know the first bad commit if it happens to be such a merge, because people might think that the bug comes from bad conflict resolution when it comes from a semantic change in one branch.</source>
          <target state="translated">충돌을 해결하기 위해 많은 파일을 수정해야하는 경우 훨씬 더 나빠집니다. 이러한 합병을 &quot;이블 합병&quot;이라고합니다. 회귀 추적을 매우 어렵게 만들 수 있습니다. 사람들이 버그가 하나의 분기에서 의미 론적 변화에서 비롯된 경우 잘못된 충돌 해결에서 비롯된 것으로 생각할 수 있기 때문에 이러한 병합이 발생하는 경우 첫 번째 잘못된 커밋을 아는 것은 잘못된 결과 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2742189647afc1dbda2e1e2ecc6c9303cbb2d70b" translate="yes" xml:space="preserve">
          <source>This is meant to be used by higher level scripts to compute merge results outside of the index, and stuff the results back into the index. For this reason, the output from the command omits entries that match the &amp;lt;branch1&amp;gt; tree.</source>
          <target state="translated">이는 고급 스크립트에서 인덱스 외부의 병합 결과를 계산하고 결과를 다시 인덱스에 채우는 데 사용됩니다. 이러한 이유로 명령의 출력은 &amp;lt;branch1&amp;gt; 트리와 일치하는 항목을 생략합니다.</target>
        </trans-unit>
        <trans-unit id="9ccf843e585a34e60ae505f61685a10813c9c88a" translate="yes" xml:space="preserve">
          <source>This is most often done when you remembered what you just committed is incomplete, or you misspelled your commit message, or both. Leaves working tree as it was before &quot;reset&quot;.</source>
          <target state="translated">이것은 방금 커밋 한 내용이 불완전하거나 커밋 메시지의 철자가 틀리거나 두 가지 모두를 기억할 때 가장 자주 수행됩니다. &quot;재설정&quot;이전과 같이 작업 트리를 떠납니다.</target>
        </trans-unit>
        <trans-unit id="efff48b2c5bed4c5ab6435b6d058280a53664967" translate="yes" xml:space="preserve">
          <source>This is not a command the end user would want to run. Ever. This documentation is meant for people who are studying the Porcelain-ish scripts and/or are writing new ones.</source>
          <target state="translated">이것은 최종 사용자가 실행하고자하는 명령이 아닙니다. 이제까지. 이 문서는 도자기로 된 대본을 공부하거나 새로운 대본을 쓰는 사람들을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="4c9e09ba77ce1340a426d6ae669add42a4fe4542" translate="yes" xml:space="preserve">
          <source>This is not a real filter executed for each commit but a one time setup just before the loop. Therefore no commit-specific variables are defined yet. Functions or variables defined here can be used or modified in the following filter steps except the commit filter, for technical reasons.</source>
          <target state="translated">이것은 각 커밋에 대해 실행되는 실제 필터가 아니라 루프 직전에 한 번 설정됩니다. 따라서 확약 특정 변수가 아직 정의되지 않았습니다. 여기에 정의 된 함수 또는 변수는 기술적 인 이유로 커밋 필터를 제외한 다음 필터 단계에서 사용하거나 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad1d1c10cd51125ef48d021d8c7283be0413a66d" translate="yes" xml:space="preserve">
          <source>This is not hard to understand, as soon as you realize that Git simply never knows (or cares) about files that it is not told about explicitly. Git will never go &lt;strong&gt;looking&lt;/strong&gt; for files to compare, it expects you to tell it what the files are, and that&amp;rsquo;s what the index is there for.</source>
          <target state="translated">Git이 명시 적으로 알려지지 않은 파일에 대해 결코 알지 못한다는 것을 알게 되 자마자 이해하기 어렵지 않습니다. Git은 비교할 파일을 &lt;strong&gt;찾지&lt;/strong&gt; 않을 것입니다. 파일이 무엇인지 알려주기 때문에 인덱스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0273358cae89a5a683cca4bca340f2d1ab3cc600" translate="yes" xml:space="preserve">
          <source>This is only used by git-completion.bash to add or remove commands from the list of completed commands. Normally only porcelain commands and a few select others are completed. You can add more commands, separated by space, in this variable. Prefixing the command with &lt;code&gt;-&lt;/code&gt; will remove it from the existing list.</source>
          <target state="translated">완료된 명령 목록에서 명령을 추가하거나 제거하기 위해 git-completion.bash에서만 사용됩니다. 일반적으로 도자기 명령과 일부 다른 명령 만 완료됩니다. 이 변수에 공백으로 구분 된 명령을 더 추가 할 수 있습니다. 명령 앞에 &lt;code&gt;-&lt;/code&gt; 를 붙이면 기존 목록에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="fcaf558e1ca35a6c93dcb363081455cef6ced8a0" translate="yes" xml:space="preserve">
          <source>This is only valid for &amp;lt;end&amp;gt; and will specify a number of lines before or after the line given by &amp;lt;start&amp;gt;.</source>
          <target state="translated">이것은 &amp;lt;end&amp;gt;에만 유효하며 &amp;lt;start&amp;gt;에 의해 주어진 행 앞뒤에 많은 행을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1b0501180252ff128dca83458515deca695a7ecc" translate="yes" xml:space="preserve">
          <source>This is optional and is only searched when &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; is present in $GIT_DIR/config.</source>
          <target state="translated">이것은 선택 사항이며 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 가 $ GIT_DIR / config에 있을 때만 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="4306207006bf4fdd2134f4efea5f0d698d2c1f81" translate="yes" xml:space="preserve">
          <source>This is particularly true when passing in diff options. Currently some options like &lt;code&gt;--stat&lt;/code&gt; can, as an emergent effect, produce output that&amp;rsquo;s quite useless in the context of &lt;code&gt;range-diff&lt;/code&gt;. Future versions of &lt;code&gt;range-diff&lt;/code&gt; may learn to interpret such options in a manner specific to &lt;code&gt;range-diff&lt;/code&gt; (e.g. for &lt;code&gt;--stat&lt;/code&gt; producing human-readable output which summarizes how the diffstat changed).</source>
          <target state="translated">diff 옵션을 전달할 때 특히 그렇습니다. 현재 &lt;code&gt;--stat&lt;/code&gt; 와 같은 일부 옵션 은 출현 효과로 &lt;code&gt;range-diff&lt;/code&gt; 컨텍스트에서 매우 쓸모없는 출력을 생성 할 수 있습니다 . 향후 버전 &lt;code&gt;range-diff&lt;/code&gt; 에 방식으로 특정 이러한 옵션 해석을 배울 수 &lt;code&gt;range-diff&lt;/code&gt; (에 대한 예를 &lt;code&gt;--stat&lt;/code&gt; diffstat 변경 방법을 요약 사람이 읽을 수있는 출력을 생성).</target>
        </trans-unit>
        <trans-unit id="c2dfec9fbb580524d9c87ce7e3303a7b47cc295d" translate="yes" xml:space="preserve">
          <source>This is passed to both underlying git-fetch to squelch reporting of during transfer, and underlying git-merge to squelch output during merging.</source>
          <target state="translated">이것은 전송하는 동안 기본 git-fetch to squelch보고와 병합하는 동안 기본 git-merge to squelch 출력으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="3d17e8f742373c8bbf1871e58142a3d3c4b1c09b" translate="yes" xml:space="preserve">
          <source>This is per-repository enhancement / version of global prefix-based &lt;code&gt;@git_base_url_list&lt;/code&gt; gitweb configuration variable (see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;).</source>
          <target state="translated">전역 접두사 기반 &lt;code&gt;@git_base_url_list&lt;/code&gt; gitweb 구성 변수 의 저장소 별 향상 / 버전입니다 ( &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a7bcc6783fe2c533eb40b84879a83d32f4d95dc9" translate="yes" xml:space="preserve">
          <source>This is similar to --symbolic, but it omits input that are not refs (i.e. branch or tag names; or more explicitly disambiguating &quot;heads/master&quot; form, when you want to name the &quot;master&quot; branch when there is an unfortunately named tag &quot;master&quot;), and show them as full refnames (e.g. &quot;refs/heads/master&quot;).</source>
          <target state="translated">이것은 --symbolic과 비슷하지만 참조가 아닌 입력 (예 : 분기 또는 태그 이름) 또는 불행히도 명명 된 &quot;마스터&quot;분기의 이름을 지정하려는 경우 더 명확하게 &quot;헤드 / 마스터&quot;양식을 명시 적으로 생략합니다. 태그를 &quot;마스터&quot;로 지정하고 전체 참조 이름으로 표시합니다 (예 : &quot;refs / heads / master&quot;).</target>
        </trans-unit>
        <trans-unit id="4cae7dda407705febf1be1d8f0d77956238a429a" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;info/grafts&lt;/code&gt; but is internally used and maintained by shallow clone mechanism. See &lt;code&gt;--depth&lt;/code&gt; option to &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; and &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;. This file is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/shallow&quot; will be used instead.</source>
          <target state="translated">이것은 &lt;code&gt;info/grafts&lt;/code&gt; 와 비슷 하지만 내부적으로 얕은 복제 메커니즘에 의해 사용되고 유지됩니다. &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 및 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]에 대한 &lt;/a&gt; &lt;code&gt;--depth&lt;/code&gt; 옵션을 참조하십시오 . $ GIT_COMMON_DIR이 설정되고 대신 &quot;$ GIT_COMMON_DIR / shallow&quot;가 사용되면이 파일은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="44c5e44a5b0e8e88feba4a9ab4b3411e28cf0521" translate="yes" xml:space="preserve">
          <source>This is similar to the previous mode, but lets you use the interactive interface to show the &quot;diff&quot; output and choose which hunks to use in the result. See below for the description of &lt;code&gt;--patch&lt;/code&gt; option.</source>
          <target state="translated">이것은 이전 모드와 비슷하지만 대화식 인터페이스를 사용하여 &quot;diff&quot;출력을 표시하고 결과에 사용할 덩어리를 선택할 수 있습니다. &lt;code&gt;--patch&lt;/code&gt; 옵션 에 대한 설명은 아래를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4054020991b3f63ee43241d99b871a192e5f7888" translate="yes" xml:space="preserve">
          <source>This is synonymous to the previous form. If &amp;lt;commit&amp;gt; on one side is omitted, it will have the same effect as using HEAD instead.</source>
          <target state="translated">이것은 이전 양식과 동의어입니다. 한쪽의 &amp;lt;commit&amp;gt;을 생략하면 대신 HEAD를 사용하는 것과 동일한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="75478eb48b06b2098532610f52369c54c5a35766" translate="yes" xml:space="preserve">
          <source>This is the Git native format and is &lt;code&gt;&amp;lt;time&amp;gt; SP &amp;lt;offutc&amp;gt;&lt;/code&gt;. It is also fast-import&amp;rsquo;s default format, if --date-format was not specified.</source>
          <target state="translated">이것은 Git 기본 형식이며 &lt;code&gt;&amp;lt;time&amp;gt; SP &amp;lt;offutc&amp;gt;&lt;/code&gt; 입니다. --date-format이 지정되지 않은 경우 빠른 가져 오기의 기본 형식이기도합니다.</target>
        </trans-unit>
        <trans-unit id="6bd79ba5c8340a61cc49527317aae865e2230698" translate="yes" xml:space="preserve">
          <source>This is the filter for performing the commit. If this filter is specified, it will be called instead of the &lt;code&gt;git commit-tree&lt;/code&gt; command, with arguments of the form &quot;&amp;lt;TREE_ID&amp;gt; [(-p &amp;lt;PARENT_COMMIT_ID&amp;gt;)&amp;hellip;​]&quot; and the log message on stdin. The commit id is expected on stdout.</source>
          <target state="translated">커밋을 수행하기위한 필터입니다. 이 필터가 지정되면 &quot;&amp;lt;TREE_ID&amp;gt; [(-p &amp;lt;PARENT_COMMIT_ID&amp;gt;)&amp;hellip;]] 형식의 인수와 stdin의 로그 메시지와 함께 &lt;code&gt;git commit-tree&lt;/code&gt; 명령 대신 필터가 호출됩니다 . 커밋 ID는 stdout에서 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="ab02ed108f018595c9832dcfce47c6a593278667" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting tag names. When passed, it will be called for every tag ref that points to a rewritten object (or to a tag object which points to a rewritten object). The original tag name is passed via standard input, and the new tag name is expected on standard output.</source>
          <target state="translated">태그 이름을 다시 쓰는 필터입니다. 전달되면 다시 작성된 객체를 가리키는 모든 태그 참조 또는 다시 작성된 객체를 가리키는 태그 객체에 대해 호출됩니다. 원래 태그 이름은 표준 입력을 통해 전달되며 새 태그 이름은 표준 출력에 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="ec46b5cef98509f43f653471ea24de2e709b0b36" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the commit messages. The argument is evaluated in the shell with the original commit message on standard input; its standard output is used as the new commit message.</source>
          <target state="translated">커밋 메시지를 다시 쓰기위한 필터입니다. 인수는 표준 입력에서 원래 커밋 메시지와 함께 쉘에서 평가됩니다. 표준 출력은 새로운 커밋 메시지로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="baaf77805fbcb910ae11f451b39d9e38daaa6669" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the commit&amp;rsquo;s parent list. It will receive the parent string on stdin and shall output the new parent string on stdout. The parent string is in the format described in &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt;: empty for the initial commit, &quot;-p parent&quot; for a normal commit and &quot;-p parent1 -p parent2 -p parent3 &amp;hellip;​&quot; for a merge commit.</source>
          <target state="translated">커밋의 상위 목록을 다시 작성하기위한 필터입니다. stdin에서 상위 문자열을 수신하고 stdout에서 새 상위 문자열을 출력해야합니다. 부모 문자열은 &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]에&lt;/a&gt; 설명 된 형식으로되어 있습니다 : 초기 커밋의 경우 비어 있고, 일반 커밋의 경우 &quot;-p parent&quot;, 병합의 경우 &quot;-p parent1 -p parent2 -p parent3&amp;hellip; 범하다.</target>
        </trans-unit>
        <trans-unit id="ed6796eee1e84719fc79503aec05a2585b0a98ee" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the index. It is similar to the tree filter but does not check out the tree, which makes it much faster. Frequently used with &lt;code&gt;git rm --cached
--ignore-unmatch ...&lt;/code&gt;, see EXAMPLES below. For hairy cases, see &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">인덱스를 다시 쓰기위한 필터입니다. 트리 필터와 비슷하지만 트리를 체크 아웃하지 않으므로 훨씬 빠릅니다. &lt;code&gt;git rm --cached --ignore-unmatch ...&lt;/code&gt; 와 함께 자주 사용되며 , 아래 예를 참조하십시오. 털이 많은 경우 &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="84464b13412e29584cb64fc663c003212ddd470c" translate="yes" xml:space="preserve">
          <source>This is the filter for rewriting the tree and its contents. The argument is evaluated in shell with the working directory set to the root of the checked out tree. The new tree is then used as-is (new files are auto-added, disappeared files are auto-removed - neither .gitignore files nor any other ignore rules &lt;strong&gt;HAVE ANY EFFECT&lt;/strong&gt;!).</source>
          <target state="translated">트리와 그 내용을 다시 작성하기위한 필터입니다. 인수는 작업 디렉토리가 체크 아웃 된 트리의 루트로 설정된 쉘에서 평가됩니다. 그런 다음 새 트리는 그대로 사용됩니다 (새 파일은 자동으로 추가되고 사라진 파일은 자동으로 제거됩니다. .gitignore 파일이나 다른 무시 규칙에는 &lt;strong&gt;영향이 없습니다&lt;/strong&gt; !).</target>
        </trans-unit>
        <trans-unit id="ac6e8f6a01875184858c8585102e8f6aa273aee7" translate="yes" xml:space="preserve">
          <source>This is the format defined by the initial version of git, including but not limited to the format of the repository directory, the repository configuration file, and the object and ref storage. Specifying the complete behavior of git is beyond the scope of this document.</source>
          <target state="translated">이것은 리포지토리 디렉토리, 리포지토리 구성 파일 및 객체 및 참조 스토리지의 형식을 포함하여 git의 초기 버전에 의해 정의 된 형식입니다. git의 완전한 동작을 지정하는 것은이 문서의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="53064adeec7c86c12f0de7129be2018180dbdde8" translate="yes" xml:space="preserve">
          <source>This is the instruction format to copy a byte range from the source object. It encodes the offset to copy from and the number of bytes to copy. Offset and size are in little-endian order.</source>
          <target state="translated">소스 객체에서 바이트 범위를 복사하기위한 명령어 형식입니다. 복사 할 오프셋과 복사 할 바이트 수를 인코딩합니다. 오프셋과 크기는 리틀 엔디안 순서입니다.</target>
        </trans-unit>
        <trans-unit id="7c56810b4cb2a212f096564a869dc50ed111eb3c" translate="yes" xml:space="preserve">
          <source>This is the instruction reserved for future expansion.</source>
          <target state="translated">이것은 향후 확장을 위해 예약 된 명령입니다.</target>
        </trans-unit>
        <trans-unit id="2ac15a186ae4c1add6605d649b034295db99bef1" translate="yes" xml:space="preserve">
          <source>This is the instruction to construct target object without the base object. The following data is appended to the target object. The first seven bits of the first octet determines the size of data in bytes. The size must be non-zero.</source>
          <target state="translated">기본 오브젝트없이 대상 오브젝트를 구성하는 지시 사항입니다. 다음 데이터가 대상 개체에 추가됩니다. 첫 번째 옥텟의 처음 7 비트는 바이트 단위의 데이터 크기를 결정합니다. 크기는 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="109ca8035c1b87bb820c08a28a9de7b34fde1bb6" translate="yes" xml:space="preserve">
          <source>This is the opposite of &lt;code&gt;ours&lt;/code&gt;; note that, unlike &lt;code&gt;ours&lt;/code&gt;, there is no &lt;code&gt;theirs&lt;/code&gt; merge strategy to confuse this merge option with.</source>
          <target state="translated">이것은 &lt;code&gt;ours&lt;/code&gt; 의 반대입니다 . 달리 점에 유의 &lt;code&gt;ours&lt;/code&gt; , 더이없는 &lt;code&gt;theirs&lt;/code&gt; 이 병합 옵션을 혼동하는 병합 전략.</target>
        </trans-unit>
        <trans-unit id="a470bc42a7932d13fef06a087064186d12eef547" translate="yes" xml:space="preserve">
          <source>This is the preferred method.</source>
          <target state="translated">이것이 선호되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d5ae5cf60359e7831f40d915d7567f63dc115a19" translate="yes" xml:space="preserve">
          <source>This is the same &lt;code&gt;git read-tree&lt;/code&gt; command we have already seen, but it takes three trees, unlike previous examples. This reads the contents of each tree into different &lt;code&gt;stage&lt;/code&gt; in the index file (the first tree goes to stage 1, the second to stage 2, etc.). After reading three trees into three stages, the paths that are the same in all three stages are &lt;code&gt;collapsed&lt;/code&gt; into stage 0. Also paths that are the same in two of three stages are collapsed into stage 0, taking the SHA-1 from either stage 2 or stage 3, whichever is different from stage 1 (i.e. only one side changed from the common ancestor).</source>
          <target state="translated">이것은 우리가 이미 본 것과 동일한 &lt;code&gt;git read-tree&lt;/code&gt; 명령이지만, 이전 예제와 달리 3 개의 트리가 필요합니다. 인덱스 파일에서 각 트리의 내용을 다른 &lt;code&gt;stage&lt;/code&gt; 로 읽습니다 (첫 번째 트리는 1 단계로, 두 번째는 2 단계로 이동합니다). 세 개의 나무를 세 단계로 읽은 후 세 단계 모두에서 동일한 경로가 단계 0 으로 &lt;code&gt;collapsed&lt;/code&gt; 됩니다. 또한 세 단계 중 두 단계에서 동일한 경로가 단계 0으로 축소되어 두 단계 중 하나에서 SHA-1이 사용됩니다. 또는 1 단계와 다른 단계 3 (즉, 한쪽 만 공통 조상에서 변경됨).</target>
        </trans-unit>
        <trans-unit id="d9a78198f4c718b4aad0f141375d5823cd8e39e3" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;code&gt;gitdir&lt;/code&gt; except that matching is done case-insensitively (e.g. on case-insensitive file systems)</source>
          <target state="translated">이것은 동일 &lt;code&gt;gitdir&lt;/code&gt; 그 일치를 제외하고 완료를 대문자와 소문자를 구별하지 않고로 (예를 들어, 대소 문자를 구분 파일 시스템)입니다</target>
        </trans-unit>
        <trans-unit id="3d8eaa3e252f616f4794342341d2f4ec065a52c7" translate="yes" xml:space="preserve">
          <source>This is the standard email format as described by RFC 2822.</source>
          <target state="translated">RFC 2822에 설명 된 표준 전자 메일 형식입니다.</target>
        </trans-unit>
        <trans-unit id="b1825adadaae31865a7ba56f02eeaa58bb1a595e" translate="yes" xml:space="preserve">
          <source>This is the standard helper program to use with &lt;code&gt;git merge-index&lt;/code&gt; to resolve a merge after the trivial merge done with &lt;code&gt;git read-tree -m&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git read-tree -m&lt;/code&gt; 으로 사소한 병합 후 병합을 해결하기 위해 &lt;code&gt;git merge-index&lt;/code&gt; 와 함께 사용하는 표준 도우미 프로그램 입니다.</target>
        </trans-unit>
        <trans-unit id="f4605ef17a6ae238fb7ad1359ce2fc3809a170d2" translate="yes" xml:space="preserve">
          <source>This is the state of the index file and the working file after &lt;code&gt;git merge&lt;/code&gt; returns control back to you, leaving the conflicting merge for you to resolve. Notice that the path &lt;code&gt;hello&lt;/code&gt; is still unmerged, and what you see with &lt;code&gt;git diff&lt;/code&gt; at this point is differences since stage 2 (i.e. your version).</source>
          <target state="translated">이것은 &lt;code&gt;git merge&lt;/code&gt; 가 제어권을 다시 돌려 준 후 인덱스 파일과 작업 파일의 상태입니다 . &lt;code&gt;hello&lt;/code&gt; 라는 경로 는 아직 병합되지 않았으며이 시점에서 &lt;code&gt;git diff&lt;/code&gt; 로 보는 것은 2 단계 이후의 차이점 (예 : 버전)입니다.</target>
        </trans-unit>
        <trans-unit id="885013fc19184ff3f87757857452f6badc7e664c" translate="yes" xml:space="preserve">
          <source>This is to emulate &lt;code&gt;git fetch&lt;/code&gt; run on the &lt;code&gt;mothership&lt;/code&gt; using &lt;code&gt;git
push&lt;/code&gt; that is run in the opposite direction in order to integrate the work done on &lt;code&gt;satellite&lt;/code&gt;, and is often necessary when you can only make connection in one way (i.e. satellite can ssh into mothership but mothership cannot initiate connection to satellite because the latter is behind a firewall or does not run sshd).</source>
          <target state="translated">이것은 &lt;code&gt;satellite&lt;/code&gt; 에서 수행 된 작업을 통합하기 위해 반대 방향으로 실행되는 &lt;code&gt;git push&lt;/code&gt; 를 사용 하여 &lt;code&gt;mothership&lt;/code&gt; 에서 &lt;code&gt;git fetch&lt;/code&gt; run 을 에뮬레이트 하는 것이며 , 한 가지 방식으로 만 연결할 수있는 경우 (예 : 위성이 모선으로 ssh 수 있음) 그러나 후자는 방화벽 뒤에 있거나 sshd를 실행하지 않기 때문에 모선은 위성에 연결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a0fbffa526980249cc459b3697ae082d2fb16d12" translate="yes" xml:space="preserve">
          <source>This is to view the changes between two arbitrary &amp;lt;commit&amp;gt;.</source>
          <target state="translated">이것은 임의의 두 &amp;lt;commit&amp;gt; 사이의 변경 사항을 보는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2ccd3734f230a6bccf87e0841ef19acfd1763ec7" translate="yes" xml:space="preserve">
          <source>This is used if &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; does not resolve the correct &lt;code&gt;-kb&lt;/code&gt; mode to use. If true, all unresolved files are sent to the client in mode &lt;code&gt;-kb&lt;/code&gt;. This causes the client to treat them as binary files, which suppresses any newline munging it otherwise might do. Alternatively, if it is set to &quot;guess&quot;, then the contents of the file are examined to decide if it is binary, similar to &lt;code&gt;core.autocrlf&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; 이 올바른 &lt;code&gt;-kb&lt;/code&gt; 모드를 사용할 수없는 경우 에 사용됩니다. true 인 경우, 해결되지 않은 모든 파일이 &lt;code&gt;-kb&lt;/code&gt; 모드에서 클라이언트로 전송됩니다 . 이로 인해 클라이언트는이 파일을 이진 파일로 취급하므로 줄 바꿈이 발생하지 않게 할 수 있습니다. 또는 &quot;추측&quot;으로 설정된 경우 파일의 내용을 검사하여 &lt;code&gt;core.autocrlf&lt;/code&gt; 와 유사하게 이진 파일인지 판별 합니다.</target>
        </trans-unit>
        <trans-unit id="414b7e001678a67515e35206eca5b23ff617a9b6" translate="yes" xml:space="preserve">
          <source>This is used to avoid unnecessary false hits when &lt;code&gt;git diff-files&lt;/code&gt; is run after &lt;code&gt;git read-tree&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git read-tree&lt;/code&gt; 이후에 git &lt;code&gt;git diff-files&lt;/code&gt; 이 실행될 때 불필요한 오타를 피하기 위해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1756049aad8be96bbdbe029ae5b31f810c9534b0" translate="yes" xml:space="preserve">
          <source>This is used to imply --all-progress whenever progress display is activated. Unlike --all-progress this flag doesn&amp;rsquo;t actually force any progress display by itself.</source>
          <target state="translated">진행률 표시가 활성화 될 때마다 --all-progress를 암시하는 데 사용됩니다. --all-progress와 달리이 플래그는 실제로 진행률 표시를 강제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa389947911fb92b7cae5947eac62679e5095362" translate="yes" xml:space="preserve">
          <source>This is used to reorder the filepairs according to the user&amp;rsquo;s (or project&amp;rsquo;s) taste, and is controlled by the -O option to the &lt;code&gt;git diff-*&lt;/code&gt; commands.</source>
          <target state="translated">이는 사용자 (또는 프로젝트의 취향)에 따라 파일 쌍을 재정렬하는 데 사용되며 &lt;code&gt;git diff-*&lt;/code&gt; 명령 의 -O 옵션에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="e4698ff07eb1e8e63a5c87a4e409437aeb77e0b4" translate="yes" xml:space="preserve">
          <source>This is useful because it makes it easy to choose a good commit to test when you want to avoid to test some of them for some reason (they may not compile for example).</source>
          <target state="translated">어떤 이유로 테스트하지 않기를 원할 때 테스트하기 위해 좋은 커밋을 쉽게 선택할 수 있기 때문에 유용합니다 (예 : 컴파일되지 않을 수 있음).</target>
        </trans-unit>
        <trans-unit id="8b37ac2c46d9c49011957ba8051eb182f97c074f" translate="yes" xml:space="preserve">
          <source>This is useful if F and G were flawed in some way, or should not be part of topicA. Note that the argument to --onto and the &amp;lt;upstream&amp;gt; parameter can be any valid commit-ish.</source>
          <target state="translated">이는 F와 G에 어떤 방식으로 결함이 있거나 주제 A의 일부가 아니어야하는 경우에 유용합니다. --onto 및 &amp;lt;upstream&amp;gt; 매개 변수에 대한 인수는 유효한 commit-ish 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5add7a300e88f092e0ef1b21363222f3ece44ad7" translate="yes" xml:space="preserve">
          <source>This is useful if remote side is git:// server accessed over some tunnel.</source>
          <target state="translated">이것은 원격 쪽이 일부 터널을 통해 액세스되는 git : // 서버 인 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d562e00428aacff2db14167eb0ecbc7ee7ea6370" translate="yes" xml:space="preserve">
          <source>This is useful if the branch on which you ran &lt;code&gt;git stash push&lt;/code&gt; has changed enough that &lt;code&gt;git stash apply&lt;/code&gt; fails due to conflicts. Since the stash entry is applied on top of the commit that was HEAD at the time &lt;code&gt;git stash&lt;/code&gt; was run, it restores the originally stashed state with no conflicts.</source>
          <target state="translated">이것은 &lt;code&gt;git stash push&lt;/code&gt; 를 실행 한 브랜치 가 충돌로 인해 &lt;code&gt;git stash apply&lt;/code&gt; 가 실패 할 정도로 충분히 변경된 경우에 유용합니다 . &lt;code&gt;git stash&lt;/code&gt; 가 실행될 때 HEAD였던 커밋 위에 stash 항목이 적용 되므로 충돌없이 원래의 stashed 상태를 복원합니다.</target>
        </trans-unit>
        <trans-unit id="30fcffaf45041b08cc97af9d1fa76a9ba0b33fa3" translate="yes" xml:space="preserve">
          <source>This is useful if you want to begin your message in a discussion thread with comments and suggestions on the message you are responding to, and to conclude it with a patch submission, separating the discussion and the beginning of the proposed commit log message with a scissors line.</source>
          <target state="translated">이것은 응답중인 메시지에 대한 의견과 제안으로 토론 스레드에서 메시지를 시작하고 패치 제출로 토론을 마무리하고 토론과 제안 된 커밋 로그 메시지의 시작을 가위로 분리하려는 경우에 유용합니다. 선.</target>
        </trans-unit>
        <trans-unit id="f93051fa336df47ab5f519702120e3efac9cd277" translate="yes" xml:space="preserve">
          <source>This is useful on systems where lstat() calls are very slow, such as CIFS/Microsoft Windows.</source>
          <target state="translated">CIFS / Microsoft Windows와 같이 lstat () 호출이 매우 느린 시스템에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6b9439a13a0f6c5a19da94d77f92d4a1ee7e5be6" translate="yes" xml:space="preserve">
          <source>This is useful when cherry-picking more than one commits' effect to your index in a row.</source>
          <target state="translated">이것은 인덱스에서 하나 이상의 커밋 효과를 연속적으로 선택하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ccb566ca825959d19feaead9d9434de1315351a7" translate="yes" xml:space="preserve">
          <source>This is useful when reverting more than one commits' effect to your index in a row.</source>
          <target state="translated">이것은 하나 이상의 커밋 효과를 인덱스의 인덱스로 되돌릴 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a6b3b2938023c6383383af34a5efd6428edcf530" translate="yes" xml:space="preserve">
          <source>This is useful when topicB does not depend on topicA.</source>
          <target state="translated">topicB가 topicA에 의존하지 않는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="804a7dc8302db74d34102cb378738f0047ef1777" translate="yes" xml:space="preserve">
          <source>This is usually not what an end user wants to run directly. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; instead.</source>
          <target state="translated">이것은 일반적으로 최종 사용자가 직접 실행하려는 것이 아닙니다. 대신 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="81deedcd021f1608f9f91f70a15e2349e22a39d7" translate="yes" xml:space="preserve">
          <source>This is what &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; generates. Most headers and MIME formatting are ignored.</source>
          <target state="translated">이것이 &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]가&lt;/a&gt; 생성하는 것입니다. 대부분의 헤더와 MIME 형식은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ca6a5c0a1684e36bc50c3e68cfccb9e6ebf59a4b" translate="yes" xml:space="preserve">
          <source>This is what causes Git to track the remote&amp;rsquo;s branches; you may modify or delete these configuration options by editing &lt;code&gt;.git/config&lt;/code&gt; with a text editor. (See the &quot;CONFIGURATION FILE&quot; section of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.)</source>
          <target state="translated">이것이 Git이 리모콘의 분기를 추적하게하는 원인입니다. 텍스트 편집기로 &lt;code&gt;.git/config&lt;/code&gt; 를 편집하여 이러한 구성 옵션을 수정하거나 삭제할 수 있습니다 . (자세한 내용은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 &quot;CONFIGURATION FILE&quot;섹션 을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="e49010e0ec73f433e7f19c2db7cbfd7081066732" translate="yes" xml:space="preserve">
          <source>This is why it is a bad idea to just chose the next best unskipped bisection commit when the first one has been skipped.</source>
          <target state="translated">그렇기 때문에 첫 번째 건너 뛰기를 건너 뛰었을 때 다음으로 최고의 건너 뛰기 이분법 커밋을 선택하는 것이 나쁜 생각입니다.</target>
        </trans-unit>
        <trans-unit id="51722bee7db4c41cee14b92ba092db0dce132718" translate="yes" xml:space="preserve">
          <source>This leaves a copy of &lt;code&gt;next&lt;/code&gt; temporarily in FETCH_HEAD, but does not update any remote-tracking branches. Using remote-tracking branches, the same can be done by invoking fetch and merge:</source>
          <target state="translated">그러면 FETCH_HEAD 에 &lt;code&gt;next&lt;/code&gt; 복사본이 임시로 남지만 원격 추적 분기는 업데이트되지 않습니다. 원격 추적 분기를 사용하면 가져 오기 및 병합을 호출하여 동일한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d3c273456c213d2f0eef245650834ea18d26a16" translate="yes" xml:space="preserve">
          <source>This lets you choose one path out of a &lt;code&gt;status&lt;/code&gt; like selection. After choosing the path, it presents the diff between the index and the working tree file and asks you if you want to stage the change of each hunk. You can select one of the following options and type return:</source>
          <target state="translated">이를 통해 선택 과 같은 &lt;code&gt;status&lt;/code&gt; 하나의 경로를 선택할 수 있습니다 . 경로를 선택한 후 인덱스와 작업 트리 파일 사이의 차이점을 표시하고 각 덩어리의 변경을 스테이징 할 것인지 묻습니다. 다음 옵션 중 하나를 선택하고 return을 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="060b46ed6fd409fbf360157d2f3c13ff3dcd2220" translate="yes" xml:space="preserve">
          <source>This lets you quit without do cleaning.</source>
          <target state="translated">이렇게하면 청소하지 않고 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa41c7db3702739cc1b230bda0b83b675d7b2671" translate="yes" xml:space="preserve">
          <source>This lets you review what will be committed (i.e. between HEAD and index).</source>
          <target state="translated">이를 통해 커밋 할 내용 (예 : HEAD와 인덱스)을 검토 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca3fd0a1256c2900c49910f1d037599eb216d4ff" translate="yes" xml:space="preserve">
          <source>This list should contain the URI of gitweb&amp;rsquo;s standard stylesheet. The default URI of gitweb stylesheet can be set at build time using the &lt;code&gt;GITWEB_CSS&lt;/code&gt; makefile variable. Its default value is &lt;code&gt;static/gitweb.css&lt;/code&gt; (or &lt;code&gt;static/gitweb.min.css&lt;/code&gt; if the &lt;code&gt;CSSMIN&lt;/code&gt; variable is defined, i.e. if CSS minifier is used during build).</source>
          <target state="translated">이리스트는 gitweb 표준 스타일 시트의 URI를 포함해야합니다. gitweb 스타일 시트의 기본 URI는 &lt;code&gt;GITWEB_CSS&lt;/code&gt; makefile 변수를 사용하여 빌드시 설정할 수 있습니다 . 기본값은 &lt;code&gt;static/gitweb.css&lt;/code&gt; (또는 &lt;code&gt;CSSMIN&lt;/code&gt; 변수가 정의 된 경우, 즉 빌드 중에 CSS 축소 &lt;code&gt;static/gitweb.min.css&lt;/code&gt; 경우 static / gitweb.min.css )입니다.</target>
        </trans-unit>
        <trans-unit id="87db555786bcad0bd342abfeced795a76cdcb852" translate="yes" xml:space="preserve">
          <source>This lists the commits reachable from the previous version of the &lt;code&gt;master&lt;/code&gt; branch head. This syntax can be used with any Git command that accepts a commit, not just with &lt;code&gt;git log&lt;/code&gt;. Some other examples:</source>
          <target state="translated">이것은 이전 버전의 &lt;code&gt;master&lt;/code&gt; 브랜치 헤드 에서 도달 할 수있는 커밋을 나열합니다 . 이 구문은 &lt;code&gt;git log&lt;/code&gt; 뿐만 아니라 커밋을 수락하는 모든 Git 명령과 함께 사용할 수 있습니다 . 다른 예 :</target>
        </trans-unit>
        <trans-unit id="9d19ff56a7106ea2437dd5210773dc60fd2828eb" translate="yes" xml:space="preserve">
          <source>This looks up the &amp;lt;file&amp;gt;(s) in the index and, if there are any merge entries, passes the SHA-1 hash for those files as arguments 1, 2, 3 (empty argument if no file), and &amp;lt;file&amp;gt; as argument 4. File modes for the three files are passed as arguments 5, 6 and 7.</source>
          <target state="translated">인덱스에서 &amp;lt;파일&amp;gt;을 찾고 병합 항목이있는 경우 해당 파일의 SHA-1 해시를 인수 1, 2, 3 (파일이없는 경우 빈 인수) 및 &amp;lt;파일&amp;gt;로 전달합니다. 세 파일의 파일 모드는 인수 5, 6 및 7로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6790f45ac4b6ed7e77775e3a5dfba68fc876105d" translate="yes" xml:space="preserve">
          <source>This makes a commit that records the modification to &lt;code&gt;Makefile&lt;/code&gt;. The changes staged for &lt;code&gt;hello.c&lt;/code&gt; and &lt;code&gt;hello.h&lt;/code&gt; are not included in the resulting commit. However, their changes are not lost &amp;mdash; they are still staged and merely held back. After the above sequence, if you do:</source>
          <target state="translated">이렇게하면 수정 사항을 &lt;code&gt;Makefile&lt;/code&gt; 에 기록하는 커미트가 작성 됩니다. &lt;code&gt;hello.c&lt;/code&gt; 및 &lt;code&gt;hello.h&lt;/code&gt; 에 대해 준비된 변경 사항 은 결과 커밋에 포함되지 않습니다. 그러나 변경 사항이 손실되지는 않습니다. 여전히 단계적이며 보류됩니다. 위의 순서 후에 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c23316330a20f8d3e00d74e273bc6ee3d02efbd7" translate="yes" xml:space="preserve">
          <source>This makes a new branch called &lt;code&gt;other&lt;/code&gt; from &lt;code&gt;master~5..master&lt;/code&gt; (i.e. if &lt;code&gt;master&lt;/code&gt; has linear history, it will take the last 5 commits).</source>
          <target state="translated">이것은 &lt;code&gt;master~5..master&lt;/code&gt; 에서 &lt;code&gt;other&lt;/code&gt; 라는 새로운 브랜치를 만듭니다 (즉, &lt;code&gt;master&lt;/code&gt; 에 선형 히스토리가있는 경우 마지막 5 개의 커밋이 필요함 ).</target>
        </trans-unit>
        <trans-unit id="b0ade35fb815795f98a8b6354752858acd9e1cfa" translate="yes" xml:space="preserve">
          <source>This makes sure that only the key/value pair for kernel.org is replaced.</source>
          <target state="translated">이를 통해 kernel.org의 키 / 값 쌍만 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="2d726c732ca5f310160366fecc16a8d1ede4f94c" translate="yes" xml:space="preserve">
          <source>This manual describes the convention used throughout Git CLI.</source>
          <target state="translated">이 매뉴얼은 Git CLI 전체에서 사용되는 규칙을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="40982f6c18ca56554ec412b18ace4f012d6c51fa" translate="yes" xml:space="preserve">
          <source>This manual is designed to be readable by someone with basic UNIX command-line skills, but no previous knowledge of Git.</source>
          <target state="translated">이 매뉴얼은 기본 UNIX 명령 줄 기술을 가지고 있지만 Git에 대한 사전 지식이없는 사람이 읽을 수 있도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="1b4c4400f56ace6af78ca50c928fe7f5cfe13be6" translate="yes" xml:space="preserve">
          <source>This manual page describes only the most frequently used options.</source>
          <target state="translated">이 매뉴얼 페이지는 가장 자주 사용되는 옵션에 대해서만 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c74c8f67468f674a4bbb6cadbdb326520214aafb" translate="yes" xml:space="preserve">
          <source>This manual page describes only the most frequently used options. See &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; for a complete list.</source>
          <target state="translated">이 매뉴얼 페이지는 가장 자주 사용되는 옵션에 대해서만 설명합니다. 전체 목록 은 &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="78fbc8bf0be13ddc4f9bce27ee4dc19783022a2b" translate="yes" xml:space="preserve">
          <source>This means &quot;show everything that is reachable from either one, but exclude anything that is reachable from both of them&quot;.</source>
          <target state="translated">이것은 &quot;둘 중 하나에서 도달 할 수있는 모든 것을 표시하지만 둘 다에서 도달 할 수있는 것은 제외&quot;를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9f4c07f14694007bf95dcdb96bbfc3991db01ef3" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;git reset &amp;lt;pathspec&amp;gt;&lt;/code&gt; is the opposite of &lt;code&gt;git add
&amp;lt;pathspec&amp;gt;&lt;/code&gt;. This command is equivalent to &lt;code&gt;git restore [--source=&amp;lt;tree-ish&amp;gt;] --staged &amp;lt;pathspec&amp;gt;...&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git reset &amp;lt;pathspec&amp;gt;&lt;/code&gt; 이 &lt;code&gt;git add &amp;lt;pathspec&amp;gt;&lt;/code&gt; 과 반대되는 것을 의미합니다 . 이 명령은 &lt;code&gt;git restore [--source=&amp;lt;tree-ish&amp;gt;] --staged &amp;lt;pathspec&amp;gt;...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="138908f8222de2b4daf75b57b97dc896b1845167" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;git reset -p&lt;/code&gt; is the opposite of &lt;code&gt;git add -p&lt;/code&gt;, i.e. you can use it to selectively reset hunks. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">즉, &lt;code&gt;git reset -p&lt;/code&gt; 는 &lt;code&gt;git add -p&lt;/code&gt; 와 반대입니다 . 즉,이를 사용하여 덩어리를 선택적으로 재설정 할 수 있습니다. &lt;code&gt;--patch&lt;/code&gt; 모드 작동 방법을 알아 보려면 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 의 &quot;대화식 모드&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c231d7cedbd657513f91f60869397c2bef2f37d" translate="yes" xml:space="preserve">
          <source>This means that it is often &quot;cheaper&quot; if QA people or end users can do it.</source>
          <target state="translated">이는 품질 보증 담당자 나 최종 사용자가 할 수 있다면 종종 &quot;더 저렴&quot;하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0ff1dc064f7e1f4d0872498ac05a21ade168adc9" translate="yes" xml:space="preserve">
          <source>This means that test suites are good to prevent some bugs from being committed and they are also quite good to tell you that you have some bugs. But they are not so good to tell you where some bugs have been introduced. To tell you that efficiently, git bisect is needed.</source>
          <target state="translated">즉, 테스트 스위트는 일부 버그가 커밋되는 것을 방지하고 버그가 있음을 알려주는 것도 좋습니다. 그러나 버그가 어디에서 발생했는지 알려주는 것은 좋지 않습니다. 효율적으로 말하면 git bisect가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="388b9571e5f1264e3be3a08ce2827efedebdef31" translate="yes" xml:space="preserve">
          <source>This means that the best bisection commits are the commits where the following function is maximum:</source>
          <target state="translated">이는 최상의 bisection 커밋이 다음 함수가 최대 인 커밋임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="597961da0012b9cd684792dccd1c7471e5687e9f" translate="yes" xml:space="preserve">
          <source>This means that the trimmed &amp;lt;token&amp;gt; and &amp;lt;value&amp;gt; will be separated by &lt;code&gt;': '&lt;/code&gt; (one colon followed by one space).</source>
          <target state="translated">이것은 잘린 &amp;lt;token&amp;gt;과 &amp;lt;value&amp;gt;가 &lt;code&gt;': '&lt;/code&gt; (한 콜론 뒤에 하나의 공백) 으로 분리됨을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="38ea5711a664516b71bd0eeea932fd8ac8d7c412" translate="yes" xml:space="preserve">
          <source>This means that we get rid of the uninteresting commits in the DAG.</source>
          <target state="translated">이것은 우리가 DAG에서 흥미없는 커밋을 제거한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2454a8b57cbe01726a67b284a671cd468ecfe3a7" translate="yes" xml:space="preserve">
          <source>This means that you can do</source>
          <target state="translated">이것은 당신이 할 수 있음을 의미</target>
        </trans-unit>
        <trans-unit id="4bfb7f09c9f4811c3630d40fb2caf5f3310e564e" translate="yes" xml:space="preserve">
          <source>This means that you can use &lt;code&gt;git checkout -p&lt;/code&gt; to selectively discard edits from your current working tree. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">이것은 &lt;code&gt;git checkout -p&lt;/code&gt; 를 사용 하여 현재 작업 트리에서 편집 내용을 선택적으로 버릴 수 있음을 의미합니다 . &lt;code&gt;--patch&lt;/code&gt; 모드 작동 방법을 알아 보려면 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 의 &quot;대화식 모드&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2db1fd51873ef2a0afca87fc61387f5a8891e2a5" translate="yes" xml:space="preserve">
          <source>This merges the changes from Bob&amp;rsquo;s &quot;master&quot; branch into Alice&amp;rsquo;s current branch. If Alice has made her own changes in the meantime, then she may need to manually fix any conflicts.</source>
          <target state="translated">이것은 Bob의 &quot;마스터&quot;브랜치에서 Alice의 현재 브랜치로 변경 사항을 병합합니다. Alice가 그 동안 자체적으로 변경 한 경우 충돌을 수동으로 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cff3569519105ed116111cf73b4d626e89a75fc2" translate="yes" xml:space="preserve">
          <source>This merges the file listing in the directory cache index with the actual working directory list, and shows different combinations of the two.</source>
          <target state="translated">그러면 디렉토리 캐시 색인의 파일 목록이 실제 작업 디렉토리 목록과 병합되고이 둘의 다른 조합이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e550f0e6cba8953c27a9638529775caa0627f8ed" translate="yes" xml:space="preserve">
          <source>This might not be what you expect, i.e. you want to prune remote &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;, but also explicitly fetch tags from it, so when you fetch from it you delete all your local tags, most of which may not have come from the &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; remote in the first place.</source>
          <target state="translated">이것은 예상 한 것이 아닐 수도 있습니다. 예를 들어, 원격 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 을 프룬하고 명시 적으로 태그를 페치하려고합니다. 페치 할 때 로컬 태그를 모두 삭제하면 대부분 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 에서 비롯되었을 수 있습니다. &amp;gt; 처음에 원격.</target>
        </trans-unit>
        <trans-unit id="c165a1bf0e23a30271149315bd9959512cec8cbc" translate="yes" xml:space="preserve">
          <source>This mode differs from the default in one point: always follow all parents of a merge, even if it is TREESAME to one of them. Even if more than one side of the merge has commits that are included, this does not imply that the merge itself is! In the example, we get</source>
          <target state="translated">이 모드는 한 가지 점에서 기본값과 다릅니다. 병합 중 하나 인 경우에도 항상 병합의 모든 부모를 따르십시오. 병합의 둘 이상의 측면에 포함 된 커밋이 있더라도 병합 자체가 있음을 의미하지는 않습니다! 이 예에서 우리는</target>
        </trans-unit>
        <trans-unit id="06118fd3f101fa40f7bcb707d4305013c9a74e7d" translate="yes" xml:space="preserve">
          <source>This mode has become the default in Git 2.0.</source>
          <target state="translated">이 모드는 Git 2.0에서 기본값이되었습니다.</target>
        </trans-unit>
        <trans-unit id="9c35450959e8c97cb733c60205966cdb68e529c7" translate="yes" xml:space="preserve">
          <source>This mode is designed for repositories with very large indexes, and aims at reducing the time it takes to repeatedly write these indexes.</source>
          <target state="translated">이 모드는 인덱스가 매우 큰 리포지토리 용으로 설계되었으며 이러한 인덱스를 반복적으로 작성하는 데 걸리는 시간을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="660380648a3de0733323135a33a60c0126cae6f8" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;export&lt;/code&gt; capability, instructing Git to dump the internal marks table to &amp;lt;file&amp;gt; when complete. For details, read up on &lt;code&gt;--export-marks=&amp;lt;file&amp;gt;&lt;/code&gt; in &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export[1]&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;export&lt;/code&gt; 기능을 수정하여 Git에게 내부 마크 테이블을 &amp;lt;file&amp;gt;에 덤프하도록 지시합니다. 자세한 내용 은 &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export [1]의 &lt;/a&gt; &lt;code&gt;--export-marks=&amp;lt;file&amp;gt;&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="59a5d5693433000c28979c8002984ee295ddd735" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;export&lt;/code&gt; capability, instructing Git to load the marks specified in &amp;lt;file&amp;gt; before processing any input. For details, read up on &lt;code&gt;--import-marks=&amp;lt;file&amp;gt;&lt;/code&gt; in &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export[1]&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;export&lt;/code&gt; 기능을 수정하여 Git에게 입력을 처리하기 전에 &amp;lt;file&amp;gt;에 지정된 마크를로드하도록 지시합니다. 자세한 내용 은 &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export [1]&lt;/a&gt; 에서 &lt;code&gt;--import-marks=&amp;lt;file&amp;gt;&lt;/code&gt; 을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="29cca50076d9ab0c1672949be9f5cf285333ce65" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;export&lt;/code&gt; capability, instructing Git to pass &lt;code&gt;--signed-tags=verbatim&lt;/code&gt; to &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export[1]&lt;/a&gt;. In the absence of this capability, Git will use &lt;code&gt;--signed-tags=warn-strip&lt;/code&gt;.</source>
          <target state="translated">이것은 Git에게 &lt;code&gt;--signed-tags=verbatim&lt;/code&gt; 을 &lt;a href=&quot;git-fast-export&quot;&gt;git-fast-export [1]&lt;/a&gt; 로 전달하도록 지시 하는 &lt;code&gt;export&lt;/code&gt; 기능을 수정합니다 . 이 기능이 없으면 Git은 &lt;code&gt;--signed-tags=warn-strip&lt;/code&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="1cd76e4b36f80f26235450d81c7340212de49a9e" translate="yes" xml:space="preserve">
          <source>This modifies the &lt;code&gt;import&lt;/code&gt; capability. The fast-import commands &lt;code&gt;cat-blob&lt;/code&gt; and &lt;code&gt;ls&lt;/code&gt; can be used by remote-helpers to retrieve information about blobs and trees that already exist in fast-import&amp;rsquo;s memory. This requires a channel from fast-import to the remote-helper. If it is advertised in addition to &quot;import&quot;, Git establishes a pipe from fast-import to the remote-helper&amp;rsquo;s stdin. It follows that Git and fast-import are both connected to the remote-helper&amp;rsquo;s stdin. Because Git can send multiple commands to the remote-helper it is required that helpers that use &lt;code&gt;bidi-import&lt;/code&gt; buffer all &lt;code&gt;import&lt;/code&gt; commands of a batch before sending data to fast-import. This is to prevent mixing commands and fast-import responses on the helper&amp;rsquo;s stdin.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 기능 이 수정되었습니다 . &lt;code&gt;cat-blob&lt;/code&gt; 및 &lt;code&gt;ls&lt;/code&gt; 빠른 가져 오기 명령 은 원격 도우미가 빠른 가져 오기의 메모리에 이미 존재하는 Blob 및 트리에 대한 정보를 검색하는 데 사용할 수 있습니다. 빠른 가져 오기에서 원격 헬퍼로의 채널이 필요합니다. &quot;가져 오기&quot;와 함께 광고되면 Git은 빠른 가져 오기에서 원격 헬퍼의 stdin으로 파이프를 설정합니다. Git과 fast-import는 모두 원격 헬퍼의 stdin에 연결되어 있습니다. Git은 원격 도우미에 여러 명령을 보낼 수 있기 때문에 &lt;code&gt;bidi-import&lt;/code&gt; 버퍼 를 사용하는 도우미는 모두 &lt;code&gt;import&lt;/code&gt; 오기 가 필요합니다빠른 가져 오기로 데이터를 보내기 전에 배치 명령. 이것은 헬퍼의 stdin에서 믹싱 명령과 빠른 가져 오기 응답을 방지하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="18b230f7b58b67f5f52143b1696b5514cecb3bd1" translate="yes" xml:space="preserve">
          <source>This operation is safe even if Alice has uncommitted local changes. The range notation &quot;HEAD..FETCH_HEAD&quot; means &quot;show everything that is reachable from the FETCH_HEAD but exclude anything that is reachable from HEAD&quot;. Alice already knows everything that leads to her current state (HEAD), and reviews what Bob has in his state (FETCH_HEAD) that she has not seen with this command.</source>
          <target state="translated">Alice가 커밋되지 않은 로컬 변경 사항을 가지고 있어도이 작업은 안전합니다. 범위 표기법 &quot;HEAD..FETCH_HEAD&quot;는 &quot;FETCH_HEAD에서 도달 할 수 있지만 HEAD에서 도달 할 수있는 것은 제외&quot;를 의미합니다. Alice는 현재 상태 (HEAD)로 이어지는 모든 것을 이미 알고 있으며 Bob이이 명령으로 보지 못한 상태 (FETCH_HEAD)에있는 것을 검토합니다.</target>
        </trans-unit>
        <trans-unit id="4d6058894e90e81912f089323abaddf6ff7286d2" translate="yes" xml:space="preserve">
          <source>This option affects options that expect path name like &lt;code&gt;--git-dir&lt;/code&gt; and &lt;code&gt;--work-tree&lt;/code&gt; in that their interpretations of the path names would be made relative to the working directory caused by the &lt;code&gt;-C&lt;/code&gt; option. For example the following invocations are equivalent:</source>
          <target state="translated">이 옵션은 경로 이름 에 대한 해석이 &lt;code&gt;-C&lt;/code&gt; 옵션 에 의해 발생하는 작업 디렉토리를 기준으로 이루어 &lt;code&gt;--git-dir&lt;/code&gt; 및 &lt;code&gt;--work-tree&lt;/code&gt; 와 같은 경로 이름이 필요한 옵션에 영향을줍니다 . 예를 들어 다음 호출은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="2b42f3dc9742d00737d912066dfd2008f4af0874" translate="yes" xml:space="preserve">
          <source>This option allows you to say that you expect the history you are updating is what you rebased and want to replace. If the remote ref still points at the commit you specified, you can be sure that no other people did anything to the ref. It is like taking a &quot;lease&quot; on the ref without explicitly locking it, and the remote ref is updated only if the &quot;lease&quot; is still valid.</source>
          <target state="translated">이 옵션을 사용하면 업데이트중인 기록이 다시 기반으로하고 교체하려는 것으로 예상 할 수 있습니다. 원격 심판이 여전히 지정한 커밋을 가리키는 경우 다른 사람이 심판에게 아무것도하지 않았 음을 확신 할 수 있습니다. 그것은 명시 적으로 그것을 잠그지 않고 심판에 &quot;임대&quot;를 취하는 것과 같으며, 원격 심판은 &quot;임대&quot;가 여전히 유효한 경우에만 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="a3080455c3c310acd65dd25e9f3c439906791e33" translate="yes" xml:space="preserve">
          <source>This option bypasses the pre-commit and commit-msg hooks. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 사전 커미트 및 commit-msg 후크를 무시합니다. &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae0cb95b3299088da58c88ea10fd24e68d20bac1" translate="yes" xml:space="preserve">
          <source>This option bypasses the pre-merge and commit-msg hooks. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 pre-merge 및 commit-msg 후크를 무시합니다. &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22c10b3b137f37c4d219034c9b73126392cd066c" translate="yes" xml:space="preserve">
          <source>This option bypasses the pre-rebase hook. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 사전 재 연결 후크를 무시합니다. &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e7eb09891c6b3b929ffed676724fa916ce9b73e" translate="yes" xml:space="preserve">
          <source>This option can be either set to a boolean value or to &lt;code&gt;on-demand&lt;/code&gt;. Setting it to a boolean changes the behavior of fetch and pull to unconditionally recurse into submodules when set to true or to not recurse at all when set to false. When set to &lt;code&gt;on-demand&lt;/code&gt; (the default value), fetch and pull will only recurse into a populated submodule when its superproject retrieves a commit that updates the submodule&amp;rsquo;s reference.</source>
          <target state="translated">이 옵션은 부울 값 또는 &lt;code&gt;on-demand&lt;/code&gt; 설정할 수 있습니다 . 이를 부울로 설정하면 페치 및 풀 동작이 변경되어 true로 설정 될 때 서브 모듈로 무조건 재귀로 돌아가거나 false로 설정 될 때 전혀 재귀하지 않습니다. 시에 설정 &lt;code&gt;on-demand&lt;/code&gt; (기본값), 가져 오기 및 풀은 같이 Recurse 채워진 서브 모듈로의 superproject가 검색 할 때이 서브 모듈의 참조가 갱신 사항을 확정합니다.</target>
        </trans-unit>
        <trans-unit id="5d7a21f2665910c78fd7ff132552ce53899e84c0" translate="yes" xml:space="preserve">
          <source>This option can be used along with &lt;code&gt;--bisect-vars&lt;/code&gt;, in this case, after all the sorted commit objects, there will be the same text as if &lt;code&gt;--bisect-vars&lt;/code&gt; had been used alone.</source>
          <target state="translated">이 옵션은 &lt;code&gt;--bisect-vars&lt;/code&gt; 와 함께 사용할 수 있습니다 .이 경우 정렬 된 모든 커밋 객체 후에 &lt;code&gt;--bisect-vars&lt;/code&gt; 가 단독으로 사용 된 것과 동일한 텍스트가 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="93ff5c11faab29c493dcd0eb330b2a514a09e43b" translate="yes" xml:space="preserve">
          <source>This option can be used several times to provide several detection regexes.</source>
          <target state="translated">이 옵션은 여러 번 탐지 정규식을 제공하기 위해 여러 번 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9be17765d99ef763e2665079651c5e7b4e1ceec" translate="yes" xml:space="preserve">
          <source>This option can be used to control recursive fetching of this submodule. If this option is also present in the submodules entry in .git/config of the superproject, the setting there will override the one found in .gitmodules. Both settings can be overridden on the command line by using the &quot;--[no-]recurse-submodules&quot; option to &quot;git fetch&quot; and &quot;git pull&quot;.</source>
          <target state="translated">이 옵션은이 서브 모듈의 재귀 페치를 제어하는 ​​데 사용할 수 있습니다. 이 옵션이 수퍼 프로젝트의 .git / config에있는 서브 모듈 항목에도있는 경우, 설정은 .gitmodules에있는 설정보다 우선합니다. 명령 행에서 &quot;-[no-] recurse-submodules&quot;옵션을 사용하여 &quot;git fetch&quot;및 &quot;git pull&quot;을 사용하여 두 설정을 모두 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4813ba4c4b012e94932c2c7e77e5d37eb750ee7d" translate="yes" xml:space="preserve">
          <source>This option can be used to control recursive fetching of this submodule. It can be overridden by using the --[no-]recurse-submodules command-line option to &quot;git fetch&quot; and &quot;git pull&quot;. This setting will override that from in the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file.</source>
          <target state="translated">이 옵션은이 서브 모듈의 재귀 페치를 제어하는 ​​데 사용할 수 있습니다. -[no-] recurse-submodules 명령 줄 옵션을 사용하여 &quot;git fetch&quot;및 &quot;git pull&quot;을 재정의 할 수 있습니다. 이 설정은 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 파일의 설정을 무시 합니다.</target>
        </trans-unit>
        <trans-unit id="dc1c2b92ebab0226490f8de8ccd94e6df6f7955b" translate="yes" xml:space="preserve">
          <source>This option can be used to separate command-line options from the list of files, (useful when filenames might be mistaken for command-line options).</source>
          <target state="translated">이 옵션을 사용하면 파일 목록과 명령 줄 옵션을 구분할 수 있습니다 (파일 이름이 명령 줄 옵션으로 잘못 알려진 경우에 유용합니다).</target>
        </trans-unit>
        <trans-unit id="792e2c6acea003d2f54070521de0f6b1fb530a29" translate="yes" xml:space="preserve">
          <source>This option can be used to specify a shell command that will be called to automatically add or modify a trailer with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">이 옵션은 지정된 &amp;lt;토큰&amp;gt;으로 트레일러를 자동으로 추가하거나 수정하기 위해 호출 될 쉘 명령을 지정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3870831de784b5f9a3b27254aee6ab6f7a036b72" translate="yes" xml:space="preserve">
          <source>This option can only be used for one-shot imports as &lt;code&gt;git svn&lt;/code&gt; will not be able to fetch again without metadata. Additionally, if you lose your &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; files, &lt;code&gt;git svn&lt;/code&gt; will not be able to rebuild them.</source>
          <target state="translated">&lt;code&gt;git svn&lt;/code&gt; 은 메타 데이터없이 다시 가져올 수 없으므로이 옵션은 원샷 가져 오기에만 사용할 수 있습니다 . 또한 &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; 파일 을 잃어 버리면 &lt;code&gt;git svn&lt;/code&gt; 에서 파일 을 다시 만들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7745929fdc4d071dfa2f069450065a35fb03a357" translate="yes" xml:space="preserve">
          <source>This option can only be used together with --dry-run. By using this option the user can check if any of the given files would be ignored, no matter if they are already present in the work tree or not.</source>
          <target state="translated">이 옵션은 --dry-run과 함께 만 사용할 수 있습니다. 이 옵션을 사용하면 사용자는 파일이 이미 작업 트리에 있는지 여부에 관계없이 주어진 파일이 무시되는지 여부를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cd2090b6cd931e9fb6990b800f11805da77a460" translate="yes" xml:space="preserve">
          <source>This option cannot (currently) be used unless &lt;code&gt;--batch&lt;/code&gt; or &lt;code&gt;--batch-check&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;--batch&lt;/code&gt; 또는 &lt;code&gt;--batch-check&lt;/code&gt; 를 사용하지 않으면이 옵션을 현재 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="882762ef26e2279478bc78603a1e7faf56dec8c3" translate="yes" xml:space="preserve">
          <source>This option controls if and under what conditions new commits of populated submodules should be fetched too. It can be used as a boolean option to completely disable recursion when set to &lt;code&gt;no&lt;/code&gt; or to unconditionally recurse into all populated submodules when set to &lt;code&gt;yes&lt;/code&gt;, which is the default when this option is used without any value. Use &lt;code&gt;on-demand&lt;/code&gt; to only recurse into a populated submodule when the superproject retrieves a commit that updates the submodule&amp;rsquo;s reference to a commit that isn&amp;rsquo;t already in the local submodule clone.</source>
          <target state="translated">이 옵션은 채워진 하위 모듈의 새 커밋도 가져와야하는 조건과 조건을 제어합니다. &lt;code&gt;no&lt;/code&gt; 로 설정되면 재귀를 완전히 비활성화 하거나 &lt;code&gt;yes&lt;/code&gt; 로 설정하면 채워진 모든 하위 모듈에 무조건 재귀를 수행하기 위해 부울 옵션으로 사용할 수 있습니다. 이 옵션은 값없이 사용되는 경우의 기본값입니다. 수퍼 프로젝트가 서브 모듈의 참조를 이미 로컬 서브 모듈 클론에없는 커밋으로 업데이트하는 커밋을 검색 할 때 &lt;code&gt;on-demand&lt;/code&gt; 서브 모듈로만 재귀를 보내려면 온 디맨드 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="69bffdffaf64305a520ea61fd7a4110a4c5bf981" translate="yes" xml:space="preserve">
          <source>This option controls if new commits of all populated submodules should be fetched and updated, too (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;).</source>
          <target state="translated">이 옵션은 채워진 모든 하위 모듈의 새 커밋을 가져 와서 업데이트할지 여부를 제어합니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 및 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="30828ff428cc76245c5c17e5cbd61f4d3413d1c5" translate="yes" xml:space="preserve">
          <source>This option determines how the commit message will be cleaned up before being passed on to the commit machinery. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more details. In particular, if the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is given a value of &lt;code&gt;scissors&lt;/code&gt;, scissors will be appended to &lt;code&gt;MERGE_MSG&lt;/code&gt; before being passed on in the case of a conflict.</source>
          <target state="translated">이 옵션은 커미트 기계로 전달되기 전에 커미트 메시지를 정리하는 방법을 결정합니다. 자세한 내용은 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 을 참조하십시오. 특히 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 에 &lt;code&gt;scissors&lt;/code&gt; 값을 지정 하면 충돌시 가위가 전달되기 전에 &lt;code&gt;MERGE_MSG&lt;/code&gt; 에 가위가 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="286a93d0042817a6190102b1bfcb5df866579bac" translate="yes" xml:space="preserve">
          <source>This option determines how the merge message will be cleaned up before committing. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more details. In addition, if the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is given a value of &lt;code&gt;scissors&lt;/code&gt;, scissors will be appended to &lt;code&gt;MERGE_MSG&lt;/code&gt; before being passed on to the commit machinery in the case of a merge conflict.</source>
          <target state="translated">이 옵션은 커밋하기 전에 병합 메시지를 정리하는 방법을 결정합니다. 자세한 내용은 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 을 참조하십시오. 또한 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 값에 &lt;code&gt;scissors&lt;/code&gt; 가 지정 되면 병합 충돌시 커밋 기계로 전달되기 전에 가위가 &lt;code&gt;MERGE_MSG&lt;/code&gt; 에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="4d1960d5d8472d2a194e5ec10acd8959326f748a" translate="yes" xml:space="preserve">
          <source>This option determines how the supplied commit message should be cleaned up before committing. The &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; can be &lt;code&gt;strip&lt;/code&gt;, &lt;code&gt;whitespace&lt;/code&gt;, &lt;code&gt;verbatim&lt;/code&gt;, &lt;code&gt;scissors&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 커밋하기 전에 제공된 커밋 메시지를 정리하는 방법을 결정합니다. &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 가 될 수 &lt;code&gt;strip&lt;/code&gt; , &lt;code&gt;whitespace&lt;/code&gt; , &lt;code&gt;verbatim&lt;/code&gt; , &lt;code&gt;scissors&lt;/code&gt; 또는 &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5dab8a93409f72b36d8b46ab64625d688725721" translate="yes" xml:space="preserve">
          <source>This option does not (currently) work correctly when an object in the index is specified (e.g. &lt;code&gt;:link&lt;/code&gt; instead of &lt;code&gt;HEAD:link&lt;/code&gt;) rather than one in the tree.</source>
          <target state="translated">이 옵션은 인덱스의 객체 가 트리에서 하나가 아닌 (예 &lt;code&gt;:link&lt;/code&gt; &lt;code&gt;HEAD:link&lt;/code&gt; 대신 : link ) 지정된 경우 (현재) 올바르게 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d9ea124fbd7a15594b4c6836d821b0c2d1f565c3" translate="yes" xml:space="preserve">
          <source>This option forces conflicting hunks to be auto-resolved cleanly by favoring &lt;code&gt;our&lt;/code&gt; version. Changes from the other tree that do not conflict with our side are reflected in the merge result. For a binary file, the entire contents are taken from our side.</source>
          <target state="translated">심술쟁이 충돌이 옵션의 힘은 자동 해결 선호에 의해 깨끗하게 할 수 &lt;code&gt;our&lt;/code&gt; 버전. 우리 측과 충돌하지 않는 다른 트리의 변경 사항은 병합 결과에 반영됩니다. 바이너리 파일의 경우 전체 내용이 우리 측에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="03e43ead906b5a3ebd0febb15138c0f0fef70180" translate="yes" xml:space="preserve">
          <source>This option identifies the file status with the following tags (followed by a space) at the start of each line:</source>
          <target state="translated">이 옵션은 각 줄의 시작 부분에 다음 태그 (공백이 옴)로 파일 상태를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="11f1817b2bcb9580d82cb7eff477a970ee3352b6" translate="yes" xml:space="preserve">
          <source>This option is NOT recommended as it makes it difficult to track down old references to SVN revision numbers in existing documentation, bug reports, and archives. If you plan to eventually migrate from SVN to Git and are certain about dropping SVN history, consider &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt; instead. filter-repo also allows reformatting of metadata for ease-of-reading and rewriting authorship info for non-&quot;svn.authorsFile&quot; users.</source>
          <target state="translated">이 옵션은 기존 문서, 버그 보고서 및 아카이브에서 SVN 개정 번호에 대한 이전 참조를 추적하기 어렵 기 때문에 권장되지 않습니다. SVN에서 Git으로 마이그레이션하고 SVN 히스토리 삭제가 확실하다면 &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt; 를 고려하십시오 . filter-repo를 사용하면 &quot;svn.authorsFile&quot;이 아닌 사용자의 저작 정보를 쉽게 읽고 다시 쓸 수 있도록 메타 데이터를 다시 포맷 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78790ec840bc0471b6e620b0edc9dccd8cb32215" translate="yes" xml:space="preserve">
          <source>This option is a more advanced form of &lt;code&gt;subtree&lt;/code&gt; strategy, where the strategy makes a guess on how two trees must be shifted to match with each other when merging. Instead, the specified path is prefixed (or stripped from the beginning) to make the shape of two trees to match.</source>
          <target state="translated">이 옵션은보다 발전된 형태의 &lt;code&gt;subtree&lt;/code&gt; 전략으로, 병합시 두 트리를 서로 일치시키기 위해 전략을 전환해야합니다. 대신 지정된 경로에 접두사를 두거나 처음부터 제거하여 두 나무의 모양을 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="4caf0764823caa06aa3cb192d447e797c84f9905" translate="yes" xml:space="preserve">
          <source>This option is deprecated in favour of &lt;code&gt;git stash push&lt;/code&gt;. It differs from &quot;stash push&quot; in that it cannot take pathspecs. Instead, all non-option arguments are concatenated to form the stash message.</source>
          <target state="translated">이 옵션은 &lt;code&gt;git stash push&lt;/code&gt; 대신 사용되지 않습니다 . 경로 스펙을 사용할 수 없다는 점에서 &quot;스 태쉬 푸시&quot;와 다릅니다. 대신 옵션이 아닌 모든 인수가 연결되어 숨김 메시지를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="c02fef4ae69460732c7c3bd405bb6c17f43ad119" translate="yes" xml:space="preserve">
          <source>This option is equivalent to the &amp;lt;repository&amp;gt; argument. If both are specified, the command-line argument takes precedence.</source>
          <target state="translated">이 옵션은 &amp;lt;repository&amp;gt; 인수와 동일합니다. 둘 다 지정되면 명령 줄 인수가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="b7fdcf9707bc99b530bc435f0d474fdd1738b42d" translate="yes" xml:space="preserve">
          <source>This option is implicitly supplied if any other list-like option such as &lt;code&gt;--contains&lt;/code&gt; is provided. See the documentation for each of those options for details.</source>
          <target state="translated">&lt;code&gt;--contains&lt;/code&gt; 와 같은 다른 목록과 같은 옵션이 제공되면이 옵션이 내재적으로 제공 됩니다. 자세한 내용은 해당 옵션 각각에 대한 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="710c94d6943c052c3ce9d72b355d1824bacce0cd" translate="yes" xml:space="preserve">
          <source>This option is only applicable in non-verbose mode.</source>
          <target state="translated">이 옵션은 상세하지 않은 모드에서만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4cc49fd28601407189cb758fe5a41d5aaf8777ac" translate="yes" xml:space="preserve">
          <source>This option is only applicable when listing tags without annotation lines.</source>
          <target state="translated">이 옵션은 주석 행이없는 태그를 나열 할 때만 적용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ac28aa5e8f93911465d1aaa74ae4db50de2f286b" translate="yes" xml:space="preserve">
          <source>This option is only relevant if we are tracking branches (using one of the repository layout options --trunk, --tags, --branches, --stdlayout). For each tracked branch, try to find out where its revision was copied from, and set a suitable parent in the first Git commit for the branch. This is especially helpful when we&amp;rsquo;re tracking a directory that has been moved around within the repository. If this feature is disabled, the branches created by &lt;code&gt;git svn&lt;/code&gt; will all be linear and not share any history, meaning that there will be no information on where branches were branched off or merged. However, following long/convoluted histories can take a long time, so disabling this feature may speed up the cloning process. This feature is enabled by default, use --no-follow-parent to disable it.</source>
          <target state="translated">이 옵션은 저장소 레이아웃 옵션 --trunk, --tags, --branches, --stdlayout 중 하나를 사용하여 분기를 추적하는 경우에만 관련이 있습니다. 추적 된 각 브랜치에 대해 해당 리비전이 어디에서 복사되었는지 확인하고 브랜치의 첫 번째 Git 커밋에서 적합한 부모를 설정하십시오. 이는 저장소 내에서 이동 한 디렉토리를 추적 할 때 특히 유용합니다. 이 기능이 비활성화되면 &lt;code&gt;git svn&lt;/code&gt; 에 의해 생성 된 분기 는 모두 선형이며 기록을 공유하지 않으므로 분기가 분기되거나 병합 된 위치에 대한 정보가 없습니다. 그러나 길거나 복잡한 기록을 따르면 시간이 오래 걸릴 수 있으므로이 기능을 비활성화하면 복제 프로세스 속도가 빨라질 수 있습니다. 이 기능은 기본적으로 활성화되어 있습니다. --no-follow-parent를 사용하여 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="e12fdc170000781ad1c58dbca132db57e3472f94" translate="yes" xml:space="preserve">
          <source>This option is only used by Mac OS implementation of Git. When core.precomposeUnicode=true, Git reverts the unicode decomposition of filenames done by Mac OS. This is useful when sharing a repository between Mac OS and Linux or Windows. (Git for Windows 1.7.10 or higher is needed, or Git under cygwin 1.7). When false, file names are handled fully transparent by Git, which is backward compatible with older versions of Git.</source>
          <target state="translated">이 옵션은 Git의 Mac OS 구현에서만 사용됩니다. core.precomposeUnicode = true 인 경우 Git은 Mac OS에서 수행 한 파일 이름의 유니 코드 분해를 되돌립니다. 이것은 Mac OS와 Linux 또는 Windows간에 저장소를 공유 할 때 유용합니다. (Windows 1.7.10 이상의 Git 또는 cygwin 1.7의 Git이 필요합니다). False 인 경우 파일 이름은 Git에서 완전히 투명하게 처리되며 이전 버전의 Git과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="488a5b3855b8742f267f0b39339ad03e677bc10e" translate="yes" xml:space="preserve">
          <source>This option is only valid for add and update commands. Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.</source>
          <target state="translated">이 옵션은 추가 및 업데이트 명령에만 유효합니다. -q를 지정하지 않으면 표준 오류 스트림이 터미널에 연결될 때 기본적으로 진행 상태가보고됩니다. 이 플래그는 표준 오류 스트림이 터미널로 보내지지 않더라도 진행 상태를 강제합니다.</target>
        </trans-unit>
        <trans-unit id="564be2665790d0ee7a744865d472382d1cf20497" translate="yes" xml:space="preserve">
          <source>This option is only valid for add and update commands. These commands sometimes need to clone a remote repository. In this case, this option will be passed to the &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; command.</source>
          <target state="translated">이 옵션은 추가 및 업데이트 명령에만 유효합니다. 이 명령은 때때로 원격 저장소를 복제해야합니다. 이 경우이 옵션은 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 명령 으로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="1175e1719609394666bffaa81ec16b8052e4a6b8" translate="yes" xml:space="preserve">
          <source>This option is only valid for add, deinit and update commands. When running add, allow adding an otherwise ignored submodule path. When running deinit the submodule working trees will be removed even if they contain local changes. When running update (only effective with the checkout procedure), throw away local changes in submodules when switching to a different commit; and always run a checkout operation in the submodule, even if the commit listed in the index of the containing repository matches the commit checked out in the submodule.</source>
          <target state="translated">이 옵션은 add, deinit 및 update 명령에만 유효합니다. add를 실행할 때 다르게 무시되는 서브 모듈 경로를 추가하십시오. deinit를 실행하면 서브 모듈 작업 트리가 로컬 변경 사항을 포함하더라도 제거됩니다. 업데이트를 실행할 때 (체크 아웃 절차에서만 유효) 다른 커밋으로 전환 할 때 하위 모듈에서 로컬 변경 사항을 버립니다. 포함 저장소의 색인에 나열된 커밋이 서브 모듈에서 체크 아웃 된 커밋과 일치하더라도 항상 서브 모듈에서 체크 아웃 조작을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="2de8d442aa39a274aaa4b758d62aa7d0adb622e3" translate="yes" xml:space="preserve">
          <source>This option is only valid for foreach, update, status and sync commands. Traverse submodules recursively. The operation is performed not only in the submodules of the current repo, but also in any nested submodules inside those submodules (and so on).</source>
          <target state="translated">이 옵션은 foreach, update, status 및 sync 명령에만 유효합니다. 서브 모듈을 재귀 적으로 트래버스합니다. 작업은 현재 리포지토리의 하위 모듈뿐만 아니라 해당 하위 모듈 내부의 중첩 된 하위 모듈 등에서도 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="d01c54f91ad08eb6d9511d7549b500d6b89b1500" translate="yes" xml:space="preserve">
          <source>This option is only valid for status and summary commands. These commands typically use the commit found in the submodule HEAD, but with this option, the commit stored in the index is used instead.</source>
          <target state="translated">이 옵션은 상태 및 요약 명령에만 유효합니다. 이러한 명령은 일반적으로 하위 모듈 HEAD에있는 커밋을 사용하지만이 옵션을 사용하면 인덱스에 저장된 커밋이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7ba21174d5319ba108a98df185e2c79d000e199b" translate="yes" xml:space="preserve">
          <source>This option is only valid for the add command. It sets the submodule&amp;rsquo;s name to the given string instead of defaulting to its path. The name must be valid as a directory name and may not end with a &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 add 명령에만 유효합니다. 서브 모듈의 이름을 기본 경로로 지정하지 않고 주어진 문자열로 설정합니다. 이름은 디렉토리 이름으로 유효해야하며 &lt;code&gt;/&lt;/code&gt; 로 끝나지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="87ff71824f0ae07bd73763f995cf49d0ad4b94cd" translate="yes" xml:space="preserve">
          <source>This option is only valid for the deinit command. Unregister all submodules in the working tree.</source>
          <target state="translated">이 옵션은 deinit 명령에만 유효합니다. 작업 트리에서 모든 하위 모듈을 등록 취소하십시오.</target>
        </trans-unit>
        <trans-unit id="f24783ef5194da88d7aca04af04dd4876a0ce3ed" translate="yes" xml:space="preserve">
          <source>This option is only valid for the summary command. Limit the summary size (number of commits shown in total). Giving 0 will disable the summary; a negative number means unlimited (the default). This limit only applies to modified submodules. The size is always limited to 1 for added/deleted/typechanged submodules.</source>
          <target state="translated">이 옵션은 summary 명령에만 유효합니다. 요약 크기 (전체 커밋 수)를 제한하십시오. 0을 주면 요약이 비활성화됩니다. 음수는 무제한을 의미합니다 (기본값). 이 제한은 수정 된 하위 모듈에만 적용됩니다. 추가 / 삭제 / 유형 변경 하위 모듈의 경우 크기는 항상 1로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="ba7d2b303205764476dea6127f5143ab027381fd" translate="yes" xml:space="preserve">
          <source>This option is only valid for the summary command. This command compares the commit in the index with that in the submodule HEAD when this option is used.</source>
          <target state="translated">이 옵션은 요약 명령에만 유효합니다. 이 명령은이 옵션이 사용될 때 인덱스의 커밋을 서브 모듈 HEAD의 커밋과 비교합니다.</target>
        </trans-unit>
        <trans-unit id="0329e613a2d579c43cf813e4dcb872eed327d20c" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Checkout the commit recorded in the superproject on a detached HEAD in the submodule. This is the default behavior, the main use of this option is to override &lt;code&gt;submodule.$name.update&lt;/code&gt; when set to a value other than &lt;code&gt;checkout&lt;/code&gt;. If the key &lt;code&gt;submodule.$name.update&lt;/code&gt; is either not explicitly set or set to &lt;code&gt;checkout&lt;/code&gt;, this option is implicit.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 서브 모듈에서 분리 된 HEAD에서 수퍼 프로젝트에 기록 된 커밋을 확인하십시오. 이것이 기본 동작이며,이 옵션의 주요 용도는 &lt;code&gt;checkout&lt;/code&gt; 이외의 값으로 설정 될 때 &lt;code&gt;submodule.$name.update&lt;/code&gt; 를 대체 하는 것 입니다. 키 &lt;code&gt;submodule.$name.update&lt;/code&gt; 가 명시 적으로 설정되거나 &lt;code&gt;checkout&lt;/code&gt; 으로 설정되지 않은 경우이 옵션은 내재적입니다.</target>
        </trans-unit>
        <trans-unit id="7988d8bd0ba82c9f133c5f7cc525c2236228f253" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Clone new submodules in parallel with as many jobs. Defaults to the &lt;code&gt;submodule.fetchJobs&lt;/code&gt; option.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 많은 서브 작업과 동시에 새로운 서브 모듈을 복제하십시오. &lt;code&gt;submodule.fetchJobs&lt;/code&gt; 옵션이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="de5e49243a4037b1b14e7038956130dc87de6d4f" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Don&amp;rsquo;t fetch new objects from the remote site.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 원격 사이트에서 새 객체를 가져 오지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f13e740e91a73f0a2574eefa11fc263894a39d8c" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Initialize all submodules for which &quot;git submodule init&quot; has not been called so far before updating.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. &quot;git submodule init&quot;가 지금까지 호출되지 않은 모든 서브 모듈을 업데이트하기 전에 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="78bb9a5b0867074719f5c17324b183ac216eed4e" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Instead of using the superproject&amp;rsquo;s recorded SHA-1 to update the submodule, use the status of the submodule&amp;rsquo;s remote-tracking branch. The remote used is branch&amp;rsquo;s remote (&lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt;), defaulting to &lt;code&gt;origin&lt;/code&gt;. The remote branch used defaults to &lt;code&gt;master&lt;/code&gt;, but the branch name may be overridden by setting the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; option in either &lt;code&gt;.gitmodules&lt;/code&gt; or &lt;code&gt;.git/config&lt;/code&gt; (with &lt;code&gt;.git/config&lt;/code&gt; taking precedence).</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 수퍼 프로젝트의 기록 된 SHA-1을 사용하여 서브 모듈을 업데이트하는 대신 서브 모듈의 원격 추적 브랜치 상태를 사용하십시오. 사용 된 원격은 분기의 원격 ( &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; )이며 기본값은 &lt;code&gt;origin&lt;/code&gt; 입니다. 원격 분기에 기본값을 사용하는 &lt;code&gt;master&lt;/code&gt; 하지만, 지점 이름이 설정에 의해 오버라이드 (override) 할 수있다 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.branch&lt;/code&gt; 옵션 중 하나에 &lt;code&gt;.gitmodules&lt;/code&gt; 또는 &lt;code&gt;.git/config&lt;/code&gt; 에 (와 &lt;code&gt;.git/config&lt;/code&gt; 에 복용 우선 순위).</target>
        </trans-unit>
        <trans-unit id="c3d36d21960733622c3c4d0c9b1d02dde186ab4d" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Merge the commit recorded in the superproject into the current branch of the submodule. If this option is given, the submodule&amp;rsquo;s HEAD will not be detached. If a merge failure prevents this process, you will have to resolve the resulting conflicts within the submodule with the usual conflict resolution tools. If the key &lt;code&gt;submodule.$name.update&lt;/code&gt; is set to &lt;code&gt;merge&lt;/code&gt;, this option is implicit.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 수퍼 프로젝트에 기록 된 커밋을 서브 모듈의 현재 브랜치에 병합하십시오. 이 옵션을 지정하면 서브 모듈의 HEAD가 분리되지 않습니다. 병합 실패로 인해이 프로세스가 중단되면 일반적인 충돌 해결 도구를 사용하여 하위 모듈 내에서 발생하는 충돌을 해결해야합니다. 키 &lt;code&gt;submodule.$name.update&lt;/code&gt; 가 &lt;code&gt;merge&lt;/code&gt; 로 설정된 경우이 옵션은 내재적입니다.</target>
        </trans-unit>
        <trans-unit id="24320b0a3d3cc55ac6e67c5111e4d5b2024f7768" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. Rebase the current branch onto the commit recorded in the superproject. If this option is given, the submodule&amp;rsquo;s HEAD will not be detached. If a merge failure prevents this process, you will have to resolve these failures with &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;. If the key &lt;code&gt;submodule.$name.update&lt;/code&gt; is set to &lt;code&gt;rebase&lt;/code&gt;, this option is implicit.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 현재 브랜치를 수퍼 프로젝트에 기록 된 커밋으로 리베이스하십시오. 이 옵션을 지정하면 서브 모듈의 HEAD가 분리되지 않습니다. 병합 실패가이 프로세스를 방해하면 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]로&lt;/a&gt; 이러한 실패를 해결해야합니다 . 키 &lt;code&gt;submodule.$name.update&lt;/code&gt; 가 &lt;code&gt;rebase&lt;/code&gt; 로 설정된 경우이 옵션은 내재적입니다.</target>
        </trans-unit>
        <trans-unit id="7010a654e778ac0c1da27a5e658bfb8f3af2d2b7" translate="yes" xml:space="preserve">
          <source>This option is only valid for the update command. The initial clone of a submodule will use the recommended &lt;code&gt;submodule.&amp;lt;name&amp;gt;.shallow&lt;/code&gt; as provided by the &lt;code&gt;.gitmodules&lt;/code&gt; file by default. To ignore the suggestions use &lt;code&gt;--no-recommend-shallow&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 update 명령에만 유효합니다. 서브 모듈의 초기 복제는 권장 사용 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.shallow&lt;/code&gt; 에 의해 규정 된 &lt;code&gt;.gitmodules&lt;/code&gt; 에 기본적으로 파일. 제안을 무시하려면 &lt;code&gt;--no-recommend-shallow&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6d7b3753dd95003bf8a5d9061fa7c1fb4ce2aaa" translate="yes" xml:space="preserve">
          <source>This option is only valid when &quot;--rebase&quot; is used.</source>
          <target state="translated">이 옵션은 &quot;--rebase&quot;가 사용될 때만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="f287cb1cbdf50b2a99b97c922a7a8e625bb0e374" translate="yes" xml:space="preserve">
          <source>This option is passed through to &lt;code&gt;git pack-objects&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;git pack-objects&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="4fbc055bad10c535a2fe42cbab527b95ac43fb4e" translate="yes" xml:space="preserve">
          <source>This option is primarily to help users who are used to older versions of Git, whose &quot;git add &amp;lt;pathspec&amp;gt;&amp;hellip;​&quot; was a synonym for &quot;git add --no-all &amp;lt;pathspec&amp;gt;&amp;hellip;​&quot;, i.e. ignored removed files.</source>
          <target state="translated">이 옵션은 주로 &quot;git add &amp;lt;pathspec&amp;gt;&amp;hellip;&quot;과 같은 이전 버전의 Git에 익숙한 사용자가 &quot;git add --no-all &amp;lt;pathspec&amp;gt;&amp;hellip;&quot;과 동의어 인 경우, 즉 제거 된 파일을 무시하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="b78fb9017b343dcaa9f7e76e34c0b6aead88f71f" translate="yes" xml:space="preserve">
          <source>This option is similar to &lt;code&gt;--topo-order&lt;/code&gt; in the sense that no parent comes before all of its children, but otherwise commits are ordered according to their commit date.</source>
          <target state="translated">이 옵션은 부모가 모든 자식보다 먼저 나오지 않는다는 점에서 &lt;code&gt;--topo-order&lt;/code&gt; 와 비슷 하지만 커밋은 커밋 날짜에 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="45355afb761a7570eab836899016e010dbbaff37" translate="yes" xml:space="preserve">
          <source>This option is used internally to temporarily provide a non-negative default value for the --recurse-submodules option. All other methods of configuring fetch&amp;rsquo;s submodule recursion (such as settings in &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; and &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) override this option, as does specifying --[no-]recurse-submodules directly.</source>
          <target state="translated">이 옵션은 내부적으로 --recurse-submodules 옵션에 음이 아닌 기본값을 제공하기 위해 사용됩니다. 페치의 하위 모듈 재귀를 구성하는 다른 모든 방법 (예 : &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 및 &lt;a href=&quot;git-config&quot;&gt;git-config [1]의 설정&lt;/a&gt; )은-[no-] recurse-submodules를 직접 지정하는 것처럼이 옵션을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="37e6c888c3b366c4018908c683d3076036665dbd" translate="yes" xml:space="preserve">
          <source>This option is useful in the case where one is developing a feature on top of an upstream branch. While the feature is being worked on, the upstream branch may advance and it may not be the best idea to keep rebasing on top of the upstream but to keep the base commit as-is.</source>
          <target state="translated">이 옵션은 업스트림 브랜치에서 기능을 개발중인 경우에 유용합니다. 이 기능이 작동하는 동안 업스트림 브랜치는 진행될 수 있으며 업스트림 상단에 계속 기반을 두는 것이 아니라 기본 커밋을 그대로 유지하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="df85f593fd6f7620dd8216482ba39599038d6eaa" translate="yes" xml:space="preserve">
          <source>This option is valid for add and update commands. Create a &lt;code&gt;shallow&lt;/code&gt; clone with a history truncated to the specified number of revisions. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;</source>
          <target state="translated">이 옵션은 추가 및 업데이트 명령에 유효합니다. 지정된 수의 개정판으로 기록이 잘린 &lt;code&gt;shallow&lt;/code&gt; 복제본을 만듭니다 . &lt;a href=&quot;git-clone&quot;&gt;자식 클론&lt;/a&gt; 참조 [1]</target>
        </trans-unit>
        <trans-unit id="ebd5b9556122446be4baef760f1327190ef9a1e0" translate="yes" xml:space="preserve">
          <source>This option makes it possible to choose what action will be performed when there is already at least one trailer with the same &amp;lt;token&amp;gt; in the message.</source>
          <target state="translated">이 옵션을 사용하면 메시지에 &amp;lt;토큰&amp;gt;이 동일한 트레일러가 이미 하나 이상있을 때 수행 할 작업을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccc070d377579e85f01a8bc02ef61c868f5331ee" translate="yes" xml:space="preserve">
          <source>This option makes it possible to choose what action will be performed when there is not yet any trailer with the same &amp;lt;token&amp;gt; in the message.</source>
          <target state="translated">이 옵션을 사용하면 메시지에 &amp;lt;토큰&amp;gt;이 같은 예고편이 아직 없을 때 수행 할 작업을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f87ac9b403a45c29acabaf374d53994925318884" translate="yes" xml:space="preserve">
          <source>This option may be given up to three times, and specifies labels to be used in place of the corresponding file names in conflict reports. That is, &lt;code&gt;git merge-file -L x -L y -L z a b c&lt;/code&gt; generates output that looks like it came from files x, y and z instead of from files a, b and c.</source>
          <target state="translated">이 옵션은 최대 3 번까지 주어질 수 있으며 충돌 보고서에서 해당 파일 이름 대신 사용할 레이블을 지정합니다. 즉, &lt;code&gt;git merge-file -L x -L y -L z a b c&lt;/code&gt; 는 파일 a, b 및 c가 아닌 파일 x, y 및 z에서 나온 것처럼 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e631233708c2bfee4790b72e1f69b49f86a6c1ad" translate="yes" xml:space="preserve">
          <source>This option may be specified more than once.</source>
          <target state="translated">이 옵션은 두 번 이상 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad4bbf67e7b293924d5786bf652c9c00512dbaee" translate="yes" xml:space="preserve">
          <source>This option may be specified more than once; if so, Git will report commits reachable from any of the given commits.</source>
          <target state="translated">이 옵션은 두 번 이상 지정할 수 있습니다. 그렇다면 Git은 주어진 커밋에서 도달 가능한 커밋을보고합니다.</target>
        </trans-unit>
        <trans-unit id="02516672facfbf5a7b264eba6cd92c5455d92d79" translate="yes" xml:space="preserve">
          <source>This option may be specified multiple times.</source>
          <target state="translated">이 옵션은 여러 번 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b397b665066a62a5850aaf1e8487dea9e6d48e99" translate="yes" xml:space="preserve">
          <source>This option may be useful if you have CVS revision numbers stored in commit messages, bug-tracking systems, email archives, and the like.</source>
          <target state="translated">이 옵션은 커밋 메시지, 버그 추적 시스템, 전자 메일 아카이브 등에 CVS 개정 번호가 저장된 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f0fddd7193d3e6d239ce8fc4bc7fc077dbf4105" translate="yes" xml:space="preserve">
          <source>This option may be useful when the test you would perform in each step does not require a checked out tree.</source>
          <target state="translated">이 옵션은 각 단계에서 수행 할 테스트에 체크 아웃 된 트리가 필요하지 않을 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17ca02a4d5f28c7e8971b8d1a382a0b6bcfa0d17" translate="yes" xml:space="preserve">
          <source>This option overrides this restriction if the current value of the remote ref is the expected value. &quot;git push&quot; fails otherwise.</source>
          <target state="translated">원격 참조의 현재 값이 예상 값인 경우이 옵션은이 제한을 무시합니다. 그렇지 않으면 &quot;git push&quot;가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="8d166b9e59f19f7598d41e509f594cbcbd0ac7f1" translate="yes" xml:space="preserve">
          <source>This option provides an additional limit on top of &lt;code&gt;--window&lt;/code&gt;; the window size will dynamically scale down so as to not take up more than &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; bytes in memory. This is useful in repositories with a mix of large and small objects to not run out of memory with a large window, but still be able to take advantage of the large window for the smaller objects. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. &lt;code&gt;--window-memory=0&lt;/code&gt; makes memory usage unlimited. The default is taken from the &lt;code&gt;pack.windowMemory&lt;/code&gt; configuration variable.</source>
          <target state="translated">이 옵션은 &lt;code&gt;--window&lt;/code&gt; 위에 추가 제한을 제공합니다 . 메모리에서 &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; 바이트 이상을 차지하지 않도록 창 크기가 동적으로 축소됩니다 . 이 기능은 큰 개체와 작은 개체가 혼합 된 리포지토리에서 큰 창이있는 메모리가 부족하지 않지만 작은 개체의 경우 큰 창을 활용할 수 있습니다. 크기는 &quot;k&quot;, &quot;m&quot;또는 &quot;g&quot;로 접미사를 붙일 수 있습니다. &lt;code&gt;--window-memory=0&lt;/code&gt; 은 메모리 사용량을 무제한으로 만듭니다. 기본값은 &lt;code&gt;pack.windowMemory&lt;/code&gt; 구성 변수 에서 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="b37ac455915a6998f49ecb85f682ef29dfba0c63" translate="yes" xml:space="preserve">
          <source>This option provides an additional limit on top of &lt;code&gt;--window&lt;/code&gt;; the window size will dynamically scale down so as to not take up more than &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; bytes in memory. This is useful in repositories with a mix of large and small objects to not run out of memory with a large window, but still be able to take advantage of the large window for the smaller objects. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. &lt;code&gt;--window-memory=0&lt;/code&gt; makes memory usage unlimited. The default is taken from the &lt;code&gt;pack.windowMemory&lt;/code&gt; configuration variable. Note that the actual memory usage will be the limit multiplied by the number of threads used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;--window&lt;/code&gt; 위에 추가 제한을 제공합니다 . 메모리에서 &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; 바이트 이상을 차지하지 않도록 창 크기가 동적으로 축소됩니다 . 이 기능은 큰 개체와 작은 개체가 혼합 된 리포지토리에서 큰 창이있는 메모리가 부족하지 않지만 작은 개체의 경우 큰 창을 활용할 수 있습니다. 크기는 &quot;k&quot;, &quot;m&quot;또는 &quot;g&quot;로 접미사를 붙일 수 있습니다. &lt;code&gt;--window-memory=0&lt;/code&gt; 은 메모리 사용량을 무제한으로 만듭니다. 기본값은 &lt;code&gt;pack.windowMemory&lt;/code&gt; 구성 변수 에서 가져옵니다 . 실제 메모리 사용량은 &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]에&lt;/a&gt; 사용 된 스레드 수를 곱한 한도 입니다.</target>
        </trans-unit>
        <trans-unit id="16a6b7273f3cccefcfa42e33a667c568aaee0875" translate="yes" xml:space="preserve">
          <source>This option sets how the tag message is cleaned up. The &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; can be one of &lt;code&gt;verbatim&lt;/code&gt;, &lt;code&gt;whitespace&lt;/code&gt; and &lt;code&gt;strip&lt;/code&gt;. The &lt;code&gt;strip&lt;/code&gt; mode is default. The &lt;code&gt;verbatim&lt;/code&gt; mode does not change message at all, &lt;code&gt;whitespace&lt;/code&gt; removes just leading/trailing whitespace lines and &lt;code&gt;strip&lt;/code&gt; removes both whitespace and commentary.</source>
          <target state="translated">이 옵션은 태그 메시지를 정리하는 방법을 설정합니다. &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 중 하나가 될 수 &lt;code&gt;verbatim&lt;/code&gt; , &lt;code&gt;whitespace&lt;/code&gt; 및 &lt;code&gt;strip&lt;/code&gt; . &lt;code&gt;strip&lt;/code&gt; 모드는 기본값입니다. &lt;code&gt;verbatim&lt;/code&gt; 모드는 전혀 메시지를 변경하지 않는 &lt;code&gt;whitespace&lt;/code&gt; 단지 / 주요 라인과 공백을 후행 제거합니다 &lt;code&gt;strip&lt;/code&gt; 공백과 해설을 모두 제거합니다.</target>
        </trans-unit>
        <trans-unit id="1c04622cab5eac3fe5e20d1c189be97d2000ad23" translate="yes" xml:space="preserve">
          <source>This option takes the same values as the &lt;code&gt;trailer.ifexists&lt;/code&gt; configuration variable and it overrides what is specified by that option for trailers with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">이 옵션은 같은 값을 사용 &lt;code&gt;trailer.ifexists&lt;/code&gt; 의 구성 변수는 지정된 &amp;lt;토큰&amp;gt;와 트레일러에 대한 해당 옵션에 의해 지정됩니다 무엇보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="de59f6641e33166f78c75c60b985eacdf1d2a0ea" translate="yes" xml:space="preserve">
          <source>This option takes the same values as the &lt;code&gt;trailer.ifmissing&lt;/code&gt; configuration variable and it overrides what is specified by that option for trailers with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;trailer.ifmissing&lt;/code&gt; 구성 변수와 동일한 값을 사용하며 지정된 &amp;lt;token&amp;gt;을 가진 트레일러에 대해 해당 옵션으로 지정된 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="6b156d8c8a67e1eaa9c71b8c4e454e308c17c450" translate="yes" xml:space="preserve">
          <source>This option takes the same values as the &lt;code&gt;trailer.where&lt;/code&gt; configuration variable and it overrides what is specified by that option for trailers with the specified &amp;lt;token&amp;gt;.</source>
          <target state="translated">이 옵션은 &lt;code&gt;trailer.where&lt;/code&gt; 구성 변수와 동일한 값을 가지며 지정된 &amp;lt;token&amp;gt;을 가진 트레일러에 대해 해당 옵션으로 지정된 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="7df9ff293572a5c1527bce59783d9544419daa5b" translate="yes" xml:space="preserve">
          <source>This option tells where a new trailer will be added.</source>
          <target state="translated">이 옵션은 새 트레일러가 추가 될 위치를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="b36c69b0196d300061790058cdc0665affb9915e" translate="yes" xml:space="preserve">
          <source>This option tells which characters are recognized as trailer separators. By default only &lt;code&gt;:&lt;/code&gt; is recognized as a trailer separator, except that &lt;code&gt;=&lt;/code&gt; is always accepted on the command line for compatibility with other git commands.</source>
          <target state="translated">이 옵션은 트레일러 구분 기호로 인식되는 문자를 알려줍니다. 기본적으로 &lt;code&gt;:&lt;/code&gt; 트레일러 구분 기호로 인식됩니다. 단, 다른 git 명령과의 호환성을 위해 명령 줄에서 &lt;code&gt;=&lt;/code&gt; 가 항상 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d89b4c86a97ff8d1caa3cc84d59173003c0040dc" translate="yes" xml:space="preserve">
          <source>This option will cause fast-export to issue a &quot;deleteall&quot; directive for each commit followed by a full list of all files in the commit (as opposed to just listing the files which are different from the commit&amp;rsquo;s first parent).</source>
          <target state="translated">이 옵션은 빠른 내보내기로 인해 각 커밋에 대해 &quot;deleteall&quot;지시문을 발행하고 커밋의 첫 번째 상위와 다른 파일을 나열하는 대신 커밋에있는 모든 파일의 전체 목록을 발행합니다.</target>
        </trans-unit>
        <trans-unit id="f143abcfc92e5721db51d7183ec9951b417133b6" translate="yes" xml:space="preserve">
          <source>This option will cause git-svn to attempt to automatically populate the svn:mergeinfo property in the SVN repository when possible. Currently, this can only be done when dcommitting non-fast-forward merges where all parents but the first have already been pushed into SVN.</source>
          <target state="translated">이 옵션은 git-svn이 가능한 경우 SVN 저장소에서 svn : mergeinfo 속성을 자동으로 채우도록 시도합니다. 현재 이것은 첫 번째 부모를 제외한 모든 부모가 이미 SVN으로 푸시 된 비 빨리 감기 병합을 dcommitting 할 때만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06697c041d5aacbd598da12e9917cf43b1b799c5" translate="yes" xml:space="preserve">
          <source>This option will cause the mapping from old to new objects to be loaded from named branch upon startup and saved as a new commit to that branch upon exit, enabling incremental of large trees. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; does not exist it will be created.</source>
          <target state="translated">이 옵션을 사용하면 시작시 기존 오브젝트에서 새 오브젝트로의 맵핑이 명명 된 브랜치에서로드되고 종료시 해당 브랜치에 새 커밋으로 저장되어 큰 트리를 증분시킬 수 있습니다. 경우 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 존재하지 않는 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="dac1adaa75a920f5808dd15e4e9468c4b8319529" translate="yes" xml:space="preserve">
          <source>This output format is compatible with what &lt;code&gt;--index-info --stdin&lt;/code&gt; of &lt;code&gt;git update-index&lt;/code&gt; expects.</source>
          <target state="translated">이 출력 형식은 &lt;code&gt;git update-index&lt;/code&gt; 의 &lt;code&gt;--index-info --stdin&lt;/code&gt; 이 기대 하는 것과 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="9b61a138f7f673e2e13a43bac58e20e6d27091cc" translate="yes" xml:space="preserve">
          <source>This outputs all the commit objects between the included and excluded commits, ordered by their distance to the included and excluded commits. Refs in &lt;code&gt;refs/bisect/&lt;/code&gt; are not used. The farthest from them is displayed first. (This is the only one displayed by &lt;code&gt;--bisect&lt;/code&gt;.)</source>
          <target state="translated">포함 및 제외 커밋까지의 거리 순서대로 포함 및 제외 커밋 사이의 모든 커밋 개체를 출력합니다. &lt;code&gt;refs/bisect/&lt;/code&gt; 참조는 사용되지 않습니다. 가장 먼 곳이 먼저 표시됩니다. &lt;code&gt;--bisect&lt;/code&gt; 에 의해 표시되는 유일한 항목 입니다.</target>
        </trans-unit>
        <trans-unit id="c6b16b352aa83127a9d9220754dcd31555c3879e" translate="yes" xml:space="preserve">
          <source>This outputs something like this (the actual commit object names would be different)</source>
          <target state="translated">이것은 다음과 같이 출력됩니다 (실제 커밋 객체 이름은 다를 수 있습니다)</target>
        </trans-unit>
        <trans-unit id="05fcf2a461c52cf42967559d01dbd73ffe108135" translate="yes" xml:space="preserve">
          <source>This overrides a previous &lt;code&gt;-g&lt;/code&gt; or &lt;code&gt;--gui&lt;/code&gt; setting and reads the default merge tool will be read from the configured &lt;code&gt;merge.tool&lt;/code&gt; variable.</source>
          <target state="translated">이는 이전 &lt;code&gt;-g&lt;/code&gt; 또는 &lt;code&gt;--gui&lt;/code&gt; 설정을 무시 하고 구성된 &lt;code&gt;merge.tool&lt;/code&gt; 변수 에서 기본 병합 도구를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="cf7619d964802ced013b07a7c34a4262a7e0e3f4" translate="yes" xml:space="preserve">
          <source>This page can be displayed with &lt;code&gt;git help help&lt;/code&gt; or &lt;code&gt;git help --help&lt;/code&gt;</source>
          <target state="translated">이 페이지는 &lt;code&gt;git help help&lt;/code&gt; 또는 &lt;code&gt;git help --help&lt;/code&gt; 와 함께 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d990ef47ac594dcb10bc55890ec7a6963b3ffaed" translate="yes" xml:space="preserve">
          <source>This particular format is supplied as it&amp;rsquo;s short to implement and may be useful to a process that wants to create a new commit right now, without needing to use a working directory or &lt;code&gt;git update-index&lt;/code&gt;.</source>
          <target state="translated">이 특정 형식은 구현하기가 짧기 때문에 제공되며 작업 디렉토리 또는 &lt;code&gt;git update-index&lt;/code&gt; 를 사용할 필요없이 지금 새로운 커밋을 생성하려는 프로세스에 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ace4cf0777df858ca1c6440d5cccb2ed6637934" translate="yes" xml:space="preserve">
          <source>This prints the name of a commit they are both based on. You should now look up the tree objects of those commits, which you can easily do with</source>
          <target state="translated">커밋 이름을 출력합니다. 이제 커밋의 트리 객체를 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="65ce33f2a6f411ae54de75d77a4a5c5e2663fba3" translate="yes" xml:space="preserve">
          <source>This program computes which packs in your repository are redundant. The output is suitable for piping to &lt;code&gt;xargs rm&lt;/code&gt; if you are in the root of the repository.</source>
          <target state="translated">이 프로그램은 리포지토리의 어떤 팩이 중복되는지 계산합니다. 저장소의 루트에있는 경우 출력은 &lt;code&gt;xargs rm&lt;/code&gt; 으로 파이핑하는 데 적합 합니다.</target>
        </trans-unit>
        <trans-unit id="9dec60739fdc5804a4abedc6cf66847493211890" translate="yes" xml:space="preserve">
          <source>This program dumps the given revisions in a form suitable to be piped into &lt;code&gt;git fast-import&lt;/code&gt;.</source>
          <target state="translated">이 프로그램은 주어진 개정판을 &lt;code&gt;git fast-import&lt;/code&gt; 로 파이프하기에 적합한 형식으로 덤프합니다 .</target>
        </trans-unit>
        <trans-unit id="21943cdf9cd81593906492b86163eaa305da0be9" translate="yes" xml:space="preserve">
          <source>This program is usually not what the end user wants to run directly. Most end users want to use one of the existing frontend programs, which parses a specific type of foreign source and feeds the contents stored there to &lt;code&gt;git fast-import&lt;/code&gt;.</source>
          <target state="translated">이 프로그램은 일반적으로 최종 사용자가 직접 실행하려는 것이 아닙니다. 대부분의 최종 사용자는 기존 프론트 엔드 프로그램 중 하나를 사용하려고합니다.이 프로그램은 특정 유형의 외부 소스를 구문 분석하고 거기에 저장된 컨텐츠를 &lt;code&gt;git fast-import&lt;/code&gt; 에 공급 합니다.</target>
        </trans-unit>
        <trans-unit id="17acfb3fc2cc80c07ee41f3eeadca000eefd6ee0" translate="yes" xml:space="preserve">
          <source>This program searches the &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; for all objects that currently exist in a pack file as well as the independent object directories.</source>
          <target state="translated">이 프로그램은 &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; 에서 현재 팩 파일에 존재하는 모든 오브젝트와 독립 오브젝트 디렉토리를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="a85a25d731117b0f9fdffb50b50cd41a205c14dd" translate="yes" xml:space="preserve">
          <source>This public repository could further be mirrored, and that is how Git repositories at &lt;code&gt;kernel.org&lt;/code&gt; are managed.</source>
          <target state="translated">이 퍼블릭 리포지토리는 추가로 미러링 될 수 있으며, 이것이 &lt;code&gt;kernel.org&lt;/code&gt; 의 Git 리포지토리 가 관리되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="3f74cf126c451b6a68e67763c97a8253f485453b" translate="yes" xml:space="preserve">
          <source>This puts a Git archive of the named CVS module in the directory &amp;lt;destination&amp;gt;, which will be created if necessary.</source>
          <target state="translated">그러면 이름이 지정된 CVS 모듈의 Git 아카이브가 &amp;lt;destination&amp;gt; 디렉토리에 저장되며 필요한 경우 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="8831ce4f64ae931ef68e9c4eb0b8a48320fea478" translate="yes" xml:space="preserve">
          <source>This rebase can be performed using the &lt;code&gt;--rebase-merges&lt;/code&gt; option. It will generate a todo list looking like this:</source>
          <target state="translated">이 rebase는 &lt;code&gt;--rebase-merges&lt;/code&gt; 옵션을 사용하여 수행 할 수 있습니다 . 다음과 같은 할 일 목록을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5e2dd779ca9f11c05d6bae58c7d8a031f404dc72" translate="yes" xml:space="preserve">
          <source>This ref is unchanged since the last import or fetch, although the helper cannot necessarily determine what value that produced.</source>
          <target state="translated">헬퍼가 생성 한 값을 반드시 결정할 수는 없지만 마지막 가져 오기 또는 가져 오기 이후이 참조는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e48a6f59fc5d06bf39a026582c3a2674a30ee86" translate="yes" xml:space="preserve">
          <source>This remote helper is transparently used by Git when you use commands such as &quot;git fetch &amp;lt;URL&amp;gt;&quot;, &quot;git clone &amp;lt;URL&amp;gt;&quot;, , &quot;git push &amp;lt;URL&amp;gt;&quot; or &quot;git remote add &amp;lt;nick&amp;gt; &amp;lt;URL&amp;gt;&quot;, where &amp;lt;URL&amp;gt; begins with &lt;code&gt;ext::&lt;/code&gt;. Examples:</source>
          <target state="translated">이 원격 헬퍼는 &quot;git fetch &amp;lt;URL&amp;gt;&quot;, &quot;git clone &amp;lt;URL&amp;gt;&quot;,, &quot;git push &amp;lt;URL&amp;gt;&quot;또는 &quot;git remote add &amp;lt;nick&amp;gt; &amp;lt;URL&amp;gt;&quot;과 같은 명령을 사용할 때 Git에서 투명하게 사용됩니다. &amp;lt;URL&amp;gt;은 &lt;code&gt;ext::&lt;/code&gt; 시작합니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="76e69f76fb018209940d2bd178b055119cc99cef" translate="yes" xml:space="preserve">
          <source>This remote helper uses the specified &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; to connect to a remote Git server.</source>
          <target state="translated">이 원격 헬퍼는 지정된 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 를 사용하여 원격 Git 서버에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="08f3058ad626936f077bcdb5101be9917b27eae0" translate="yes" xml:space="preserve">
          <source>This removes the &lt;code&gt;WIP&lt;/code&gt; commit from the commit history, and sets your working tree to the state just before you made that snapshot.</source>
          <target state="translated">커밋 기록에서 &lt;code&gt;WIP&lt;/code&gt; 커밋을 제거하고 작업 트리를 해당 스냅 샷을 만들기 직전의 상태로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6cde691b95501235edce70baf30f3d475a6f05af" translate="yes" xml:space="preserve">
          <source>This removes the file from the index while keeping it in the working directory.</source>
          <target state="translated">작업 디렉토리에 파일을 유지하면서 색인에서 파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="f2e99bc05d5874bb5e940e93689126e6c4aa347e" translate="yes" xml:space="preserve">
          <source>This resolves any number of heads, but the resulting tree of the merge is always that of the current branch head, effectively ignoring all changes from all other branches. It is meant to be used to supersede old development history of side branches. Note that this is different from the -Xours option to the &lt;code&gt;recursive&lt;/code&gt; merge strategy.</source>
          <target state="translated">이렇게하면 헤드 수를 확인할 수 있지만 병합의 결과 트리는 항상 현재 분기 헤드의 트리이므로 다른 모든 분기의 모든 변경 사항을 효과적으로 무시합니다. 사이드 브랜치의 오래된 개발 히스토리를 대체하는 데 사용됩니다. 이것은 -Xours 옵션과 &lt;code&gt;recursive&lt;/code&gt; 병합 전략 과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="053dd73bd0ed92de95c5b132a1b4a0308f96cd04" translate="yes" xml:space="preserve">
          <source>This resolves cases with more than two heads, but refuses to do a complex merge that needs manual resolution. It is primarily meant to be used for bundling topic branch heads together. This is the default merge strategy when pulling or merging more than one branch.</source>
          <target state="translated">이렇게하면 두 개 이상의 헤드가있는 케이스는 해결되지만 수동 해결이 필요한 복잡한 병합을 거부합니다. 주로 토픽 브랜치 헤드를 묶는 데 사용됩니다. 하나 이상의 브랜치를 가져 오거나 병합 할 때의 기본 병합 전략입니다.</target>
        </trans-unit>
        <trans-unit id="e1337ea8d65ee53d09143c99f1f587dd31c2d238" translate="yes" xml:space="preserve">
          <source>This results in:</source>
          <target state="translated">결과 :</target>
        </trans-unit>
        <trans-unit id="a3acfff86d0ac3c7e1c1af7dc1decad57125efa5" translate="yes" xml:space="preserve">
          <source>This runs &lt;code&gt;git fsck --unreachable&lt;/code&gt; using all the refs available in &lt;code&gt;refs/&lt;/code&gt;, optionally with additional set of objects specified on the command line, and prunes all unpacked objects unreachable from any of these head objects from the object database. In addition, it prunes the unpacked objects that are also found in packs by running &lt;code&gt;git prune-packed&lt;/code&gt;. It also removes entries from .git/shallow that are not reachable by any ref.</source>
          <target state="translated">이 명령은 &lt;code&gt;refs/&lt;/code&gt; 에서 사용 가능한 모든 &lt;code&gt;git fsck --unreachable&lt;/code&gt; 를 선택적으로 사용하여 git fsck --unreachable 을 실행 하고 , 선택적으로 명령 행에 지정된 추가 오브젝트 세트를 사용하여 오브젝트 데이터베이스에서 이러한 헤드 오브젝트에서 도달 할 수없는 모든 압축 해제 된 오브젝트를 프룬합니다. 또한 &lt;code&gt;git prune-packed&lt;/code&gt; 를 실행하여 팩에있는 압축 해제 된 객체를 제거 합니다. 또한 .git / shallow에서 참조에 도달 할 수없는 항목을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="66bb2cd044765c7338efb3b55d3b51e463e22970" translate="yes" xml:space="preserve">
          <source>This runs a virtual check-out and check-in of all three stages of a file when resolving a three-way merge. This option is meant to be used when merging branches with different clean filters or end-of-line normalization rules. See &quot;Merging branches with differing checkin/checkout attributes&quot; in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">이렇게하면 3 방향 병합을 해결할 때 파일의 3 단계 모두에 대한 가상 체크 아웃 및 체크인이 실행됩니다. 이 옵션은 다른 클린 필터 또는 라인 끝 정규화 규칙을 사용하여 분기를 병합 할 때 사용됩니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]의&lt;/a&gt; &quot;체크인 / 체크 아웃 속성이 다른 분기 병합&quot; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b3bd580b61f2b6d754a6c049f07ff919549d1439" translate="yes" xml:space="preserve">
          <source>This says &quot;include everything in root, but nothing two levels below root.&quot; If we then add the folder &lt;code&gt;A/B/C&lt;/code&gt; as a recursive pattern, the folders &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A/B&lt;/code&gt; are added as parent patterns. The resulting sparse-checkout file is now</source>
          <target state="translated">&quot;루트에는 모든 것을 포함하지만 루트 아래에 두 레벨은 포함되지 않습니다.&quot; 그런 다음 폴더 &lt;code&gt;A/B/C&lt;/code&gt; 를 재귀 패턴으로 추가하면 폴더 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;A/B&lt;/code&gt; 가 상위 패턴으로 추가됩니다. 결과 스파 스 체크 아웃 파일은 이제</target>
        </trans-unit>
        <trans-unit id="9f2fcd6a73ae4ce542d08fc5e7f799314e8e80fc" translate="yes" xml:space="preserve">
          <source>This script can be passed to &quot;git bisect run&quot; to find the commit that introduced a performance regression:</source>
          <target state="translated">이 스크립트는 &quot;git bisect run&quot;으로 전달되어 성능 회귀를 도입 한 커밋을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72c86095923977328df35910b245e776428b840b" translate="yes" xml:space="preserve">
          <source>This script is included in various scripts to supply routines to parse files under $GIT_DIR/remotes/ and $GIT_DIR/branches/ and configuration variables that are related to fetching, pulling and pushing.</source>
          <target state="translated">이 스크립트는 다양한 스크립트에 포함되어 $ GIT_DIR / remotes / 및 $ GIT_DIR / branches /에서 파일을 구문 분석하는 루틴과 페치, 풀 및 푸시와 관련된 구성 변수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a405ee4e7ff4cc67a738558081388543481850c0" translate="yes" xml:space="preserve">
          <source>This section can also be used by those who respond to &lt;code&gt;git
request-pull&lt;/code&gt; or pull-request on GitHub (www.github.com) to integrate the work of others into their history. A sub-area lieutenant for a repository will act both as a participant and as an integrator.</source>
          <target state="translated">이 섹션은 또한 GitHub (www.github.com)에서 &lt;code&gt;git request-pull&lt;/code&gt; 또는 pull-request에 응답하는 사람들이 다른 사람의 작업을 역사에 통합 할 수 있습니다. 리포지토리의 하위 영역 중위는 참가자 및 통합 자 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="53af582e47690e9820cb012bdcbccf97b8def7d3" translate="yes" xml:space="preserve">
          <source>This section explains how to configure some common webservers to run gitweb. In all cases, &lt;code&gt;/path/to/gitweb&lt;/code&gt; in the examples is the directory you ran installed gitweb in, and contains &lt;code&gt;gitweb_config.perl&lt;/code&gt;.</source>
          <target state="translated">이 섹션에서는 gitweb을 실행하기 위해 일반적인 웹 서버를 구성하는 방법에 대해 설명합니다. 모든 예 에서, 예제의 &lt;code&gt;/path/to/gitweb&lt;/code&gt; 은 gitweb을 설치 한 디렉토리이며 &lt;code&gt;gitweb_config.perl&lt;/code&gt; 을 포함 합니다 .</target>
        </trans-unit>
        <trans-unit id="79c0f1f15a38eae1b5cc2a5e381bfbc844ef9486" translate="yes" xml:space="preserve">
          <source>This section is only included if a packfile section is also included in the response.</source>
          <target state="translated">이 섹션은 팩 파일 섹션이 응답에 포함 된 경우에만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f3cd5eb5a3885e012dabb05171cc566728c1791b" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git archive --remote&lt;/code&gt;. It is disabled by default, but a repository can enable it by setting &lt;code&gt;daemon.uploadarch&lt;/code&gt; configuration item to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git archive --remote&lt;/code&gt; 를 제공합니다 . 기본적으로 비활성화되어 있지만 저장소는 &lt;code&gt;daemon.uploadarch&lt;/code&gt; 구성 항목을 &lt;code&gt;true&lt;/code&gt; 로 설정하여 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1fc9be9532fca80163bd11748e3553d0b5b85a4" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git fetch-pack&lt;/code&gt; and &lt;code&gt;git ls-remote&lt;/code&gt; clients. It is enabled by default, but a repository can disable it by setting &lt;code&gt;daemon.uploadpack&lt;/code&gt; configuration item to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git fetch-pack&lt;/code&gt; 및 &lt;code&gt;git ls-remote&lt;/code&gt; 클라이언트를 제공합니다. 기본적으로 사용 가능하지만 저장소는 &lt;code&gt;daemon.uploadpack&lt;/code&gt; 구성 항목을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 사용 불가능하게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce507c3877f92fc6c1de609ca683d1e2a4e1b26f" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git fetch-pack&lt;/code&gt; and &lt;code&gt;git ls-remote&lt;/code&gt; clients. It is enabled by default, but a repository can disable it by setting this configuration item to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git fetch-pack&lt;/code&gt; 및 &lt;code&gt;git ls-remote&lt;/code&gt; 클라이언트를 제공합니다. 기본적으로 사용 가능하지만 저장소는이 구성 항목을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 사용 불가능하게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f25bae0e6df9b1b4a76a588d485b17d422e56c18" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git send-pack&lt;/code&gt; clients, allowing anonymous push. It is disabled by default, as there is &lt;code&gt;no&lt;/code&gt; authentication in the protocol (in other words, anybody can push anything into the repository, including removal of refs). This is solely meant for a closed LAN setting where everybody is friendly. This service can be enabled by setting &lt;code&gt;daemon.receivepack&lt;/code&gt; configuration item to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git send-pack&lt;/code&gt; 클라이언트를 제공하여 익명 푸시를 허용합니다. 프로토콜에 인증 이 &lt;code&gt;no&lt;/code&gt; 기본적으로 비활성화되어 있습니다. 즉, 심판 제거를 포함하여 모든 것을 저장소에 푸시 할 수 있습니다. 이것은 모두가 친숙한 닫힌 LAN 설정만을위한 것입니다. &lt;code&gt;daemon.receivepack&lt;/code&gt; 구성 항목을 &lt;code&gt;true&lt;/code&gt; 로 설정 하여이 서비스를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b2859849402fde4d51ffe73c129c97d00cb6083" translate="yes" xml:space="preserve">
          <source>This serves &lt;code&gt;git send-pack&lt;/code&gt; clients, allowing push. It is disabled by default for anonymous users, and enabled by default for users authenticated by the web server. It can be disabled by setting this item to &lt;code&gt;false&lt;/code&gt;, or enabled for all users, including anonymous users, by setting it to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;git send-pack&lt;/code&gt; 클라이언트에 서비스를 제공 하여 푸시를 허용합니다. 익명 사용자의 경우 기본적으로 비활성화되어 있으며 웹 서버에서 인증 된 사용자의 경우 기본적으로 활성화되어 있습니다. 이 항목을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 비활성화 하거나 익명 사용자를 포함한 모든 사용자가 &lt;code&gt;true&lt;/code&gt; 로 설정하여 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d789007e515492a9cc42830b12a07ff1db6d084" translate="yes" xml:space="preserve">
          <source>This serves Git clients older than version 1.6.6 that are unable to use the upload pack service. When enabled, clients are able to read any file within the repository, including objects that are no longer reachable from a branch but are still present. It is enabled by default, but a repository can disable it by setting this configuration item to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">업로드 팩 서비스를 사용할 수없는 버전 1.6.6 이전의 Git 클라이언트에 서비스를 제공합니다. 사용 가능한 경우 클라이언트는 더 이상 지점에서 도달 할 수 없지만 여전히 존재하는 오브젝트를 포함하여 저장소 내의 모든 파일을 읽을 수 있습니다. 기본적으로 사용 가능하지만 저장소는이 구성 항목을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 사용 불가능하게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5456200c93d8963943eca093573a9d8938a4ea5f" translate="yes" xml:space="preserve">
          <source>This sets GIT_SVN_ID (instead of using the environment). This allows the user to override the default refname to fetch from when tracking a single URL. The &lt;code&gt;log&lt;/code&gt; and &lt;code&gt;dcommit&lt;/code&gt; commands no longer require this switch as an argument.</source>
          <target state="translated">환경을 사용하는 대신 GIT_SVN_ID를 설정합니다. 이를 통해 사용자는 단일 URL을 추적 할 때 가져올 기본 참조 이름을 재정의 할 수 있습니다. &lt;code&gt;log&lt;/code&gt; 및 &lt;code&gt;dcommit&lt;/code&gt; 명령은 더 이상 인수로이 스위치를 필요로하지 않는다.</target>
        </trans-unit>
        <trans-unit id="acb244d7aa46a820614aa10decb4464bc8ecabb6" translate="yes" xml:space="preserve">
          <source>This setting can be disabled by the &lt;code&gt;--no-notes&lt;/code&gt; option, overridden by the &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; environment variable, and overridden by the &lt;code&gt;--notes=&amp;lt;ref&amp;gt;&lt;/code&gt; option.</source>
          <target state="translated">이 설정은 &lt;code&gt;--no-notes&lt;/code&gt; 옵션 으로 비활성화 하고 &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; 환경 변수로 재정의하고 &lt;code&gt;--notes=&amp;lt;ref&amp;gt;&lt;/code&gt; 옵션으로 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8f435ef26eec94bd5c23846a74c0f4d57a87c8f" translate="yes" xml:space="preserve">
          <source>This setting can be overridden by passing the &lt;code&gt;--strategy&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;--strategy&lt;/code&gt; 옵션 을 전달하면이 설정을 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d273f23cd160340c4f9b3fbc5a088c0fc2c32be" translate="yes" xml:space="preserve">
          <source>This setting can be overridden by the &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; environment variable.</source>
          <target state="translated">이 설정은 &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; 환경 변수 로 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b28435a905552ea063d5203034696b428fdc0b87" translate="yes" xml:space="preserve">
          <source>This setting can be overridden with the &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; environment variable, which must be a colon separated list of refs or globs.</source>
          <target state="translated">이 설정은 &lt;code&gt;GIT_NOTES_DISPLAY_REF&lt;/code&gt; 환경 변수 로 재정의 할 수 있습니다.이 변수는 콜론으로 구분 된 참조 또는 글로브 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="45473aa6b3903d5487aab6b473bcf528e266cdec" translate="yes" xml:space="preserve">
          <source>This setting can be overridden with the &lt;code&gt;GIT_NOTES_REWRITE_MODE&lt;/code&gt; environment variable.</source>
          <target state="translated">이 설정은 &lt;code&gt;GIT_NOTES_REWRITE_MODE&lt;/code&gt; 환경 변수 로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39555b916eeeec115f6735665b5426bf964f4e52" translate="yes" xml:space="preserve">
          <source>This setting can be overridden with the &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; environment variable, which must be a colon separated list of refs or globs.</source>
          <target state="translated">이 설정은 &lt;code&gt;GIT_NOTES_REWRITE_REF&lt;/code&gt; 환경 변수 로 재정의 할 수 있으며 , 환경 변수는 콜론으로 구분 된 참조 또는 글로브 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d17d74e5aa80b06bd416eb43f1c510767efc6dc8" translate="yes" xml:space="preserve">
          <source>This setting defaults to &quot;refs/notes/commits&quot;, and it can be overridden by the &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; environment variable. See &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt;.</source>
          <target state="translated">이 설정은 기본적으로 &quot;refs / notes / commits&quot;이며 &lt;code&gt;GIT_NOTES_REF&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 . &lt;a href=&quot;git-notes&quot;&gt;git-notes [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="843f7e48b1e3c030c426060d83a399e29388c249" translate="yes" xml:space="preserve">
          <source>This setting forces Git to normalize line endings for this file on checkin and convert them to CRLF when the file is checked out.</source>
          <target state="translated">이 설정은 Git이 체크인시이 파일의 줄 끝을 정규화하고 파일이 체크 아웃 될 때 CRLF로 변환하도록합니다.</target>
        </trans-unit>
        <trans-unit id="8c7bb001c250cfdf4247d252deb09b8b2c2a2839" translate="yes" xml:space="preserve">
          <source>This setting forces Git to normalize line endings to LF on checkin and prevents conversion to CRLF when the file is checked out.</source>
          <target state="translated">이 설정은 Git이 체크인시 줄 끝을 LF로 정규화하고 파일이 체크 아웃 될 때 CRLF 로의 변환을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="886fc853da603148f91948f5793a0d1be70dc28a" translate="yes" xml:space="preserve">
          <source>This setting is automatically guessed by &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; when the repository was created. By default a repository that ends in &quot;/.git&quot; is assumed to be not bare (bare = false), while all other repositories are assumed to be bare (bare = true).</source>
          <target state="translated">이 설정은 리포지토리가 생성 될 때 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-init&quot;&gt;git-init [1]에&lt;/a&gt; 의해 자동으로 추측됩니다 . 기본적으로 &quot;/.git&quot;로 끝나는 리포지토리는 베어 (bare = false) 인 것으로 가정하고 다른 모든 리포지토리는 베어 (bare = true) 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a32da40367d476cb817ba2cfa99cb18bc04a7b3a" translate="yes" xml:space="preserve">
          <source>This setting overrides the default of the &lt;code&gt;--cleanup&lt;/code&gt; option in &lt;code&gt;git commit&lt;/code&gt;. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for details. Changing the default can be useful when you always want to keep lines that begin with comment character &lt;code&gt;#&lt;/code&gt; in your log message, in which case you would do &lt;code&gt;git config commit.cleanup whitespace&lt;/code&gt; (note that you will have to remove the help lines that begin with &lt;code&gt;#&lt;/code&gt; in the commit log template yourself, if you do this).</source>
          <target state="translated">이 설정 은 &lt;code&gt;git commit&lt;/code&gt; 의 &lt;code&gt;--cleanup&lt;/code&gt; 옵션 의 기본값보다 우선합니다 . 자세한 내용은 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 을 참조하십시오. 당신은 항상 주석 문자로 시작하는 라인을 유지하려는 경우 기본값을 변경하면 유용 할 수 있습니다 &lt;code&gt;#&lt;/code&gt; 당신이 할 것이 경우 로그 메시지를, &lt;code&gt;git config commit.cleanup whitespace&lt;/code&gt; (주 당신은 시작 도움말 라인을 제거해야 할 것 커밋 로그 템플릿에 &lt;code&gt;#&lt;/code&gt; 을 입력하면됩니다.</target>
        </trans-unit>
        <trans-unit id="e85001143ab4f6109a8db79b80d46592a3792b5e" translate="yes" xml:space="preserve">
          <source>This setting should be set to a comma-separated list of color and date settings, starting and ending with a color, the dates should be set from oldest to newest. The metadata will be colored given the colors if the line was introduced before the given timestamp, overwriting older timestamped colors.</source>
          <target state="translated">이 설정은 쉼표로 구분 된 색상 및 날짜 설정 목록으로 설정해야하며 색상으로 시작하고 끝나는 날짜는 가장 오래된 날짜부터 최신 날짜로 설정해야합니다. 주어진 타임 스탬프 이전에 라인이 도입 된 경우 메타 데이터에 색상이 지정되어 오래된 타임 스탬프 된 색상을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="1b39995bc064271da90ffd3401f4ace36766db6f" translate="yes" xml:space="preserve">
          <source>This setting writes a JSON-based format that is suited for machine interpretation. See &lt;code&gt;GIT_TRACE2&lt;/code&gt; for available trace output options and &lt;a href=&quot;api-trace2&quot;&gt;Trace2 documentation&lt;/a&gt; for full details.</source>
          <target state="translated">이 설정은 기계 해석에 적합한 JSON 기반 형식을 작성합니다. 사용 가능한 추적 출력 옵션 은 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 및 자세한 내용은 &lt;a href=&quot;api-trace2&quot;&gt;Trace2 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d727921c238e28668ffb0dd7e4775077e3d6b368" translate="yes" xml:space="preserve">
          <source>This should be a colon-separated list of absolute paths. If set, it is a list of directories that Git should not chdir up into while looking for a repository directory (useful for excluding slow-loading network directories). It will not exclude the current working directory or a GIT_DIR set on the command line or in the environment. Normally, Git has to read the entries in this list and resolve any symlink that might be present in order to compare them with the current directory. However, if even this access is slow, you can add an empty entry to the list to tell Git that the subsequent entries are not symlinks and needn&amp;rsquo;t be resolved; e.g., &lt;code&gt;GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink&lt;/code&gt;.</source>
          <target state="translated">콜론으로 구분 된 절대 경로 목록이어야합니다. 설정된 경우, 리포지토리 디렉토리를 찾는 동안 Git이 chdir하지 않아야하는 디렉토리 목록입니다 (느리게로드되는 네트워크 디렉토리 제외 제외). 현재 작업 디렉토리 또는 명령 행 또는 환경에 설정된 GIT_DIR을 제외하지 않습니다. 일반적으로 Git은이 목록의 항목을 읽고 현재 디렉토리와 비교하기 위해 존재할 수있는 symlink를 해결해야합니다. 그러나이 액세스조차 느리면 빈 항목을 목록에 추가하여 Git에 후속 항목이 심볼릭 링크가 아니므로 해결할 필요가 없음을 알릴 수 있습니다. 예를 들어, &lt;code&gt;GIT_CEILING_DIRECTORIES=/maybe/symlink::/very/slow/non/symlink&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02391ad98329bedcf2ddfbe7ebdef774e4e7cc67" translate="yes" xml:space="preserve">
          <source>This should help you to submit patches inline using KMail.</source>
          <target state="translated">KMail을 사용하여 인라인 패치를 제출하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="dc65a8c75ec971d079e04ac05264e8ee2fb908c8" translate="yes" xml:space="preserve">
          <source>This should make &quot;--pretty=oneline&quot; a whole lot more readable for people using 80-column terminals.</source>
          <target state="translated">이렇게하면 80 열 터미널을 사용하는 사람들이 &quot;--pretty = oneline&quot;을 훨씬 더 읽기 쉽게 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="cda899a68420b48633046b1cef20e4960b467a9e" translate="yes" xml:space="preserve">
          <source>This should make it easy to look up svn log messages when svn users refer to -r/--revision numbers.</source>
          <target state="translated">svn 사용자가 -r /-개정 번호를 참조 할 때 svn 로그 메시지를 쉽게 찾을 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3fce0b9f9a8369808848ec3f066c1735323bb111" translate="yes" xml:space="preserve">
          <source>This should not be confused with the &lt;code&gt;ours&lt;/code&gt; merge strategy, which does not even look at what the other tree contains at all. It discards everything the other tree did, declaring &lt;code&gt;our&lt;/code&gt; history contains all that happened in it.</source>
          <target state="translated">이것은 &lt;code&gt;ours&lt;/code&gt; 병합 전략 과 혼동되어서는 안되며 , 다른 트리가 무엇을 포함하고 있는지조차 보지 못합니다. 그것은 다른 나무가 한 모든 것을 버리고, &lt;code&gt;our&lt;/code&gt; 역사는 그 안에 일어난 모든 것을 포함 한다고 선언 합니다.</target>
        </trans-unit>
        <trans-unit id="70d0ce2d7e7f48cdf303b28228ad271bde0b97ac" translate="yes" xml:space="preserve">
          <source>This shows that our resolved version deleted &quot;Hello world&quot; from the first parent, deleted &quot;Goodbye&quot; from the second parent, and added &quot;Goodbye world&quot;, which was previously absent from both.</source>
          <target state="translated">이는 해결 된 버전이 첫 번째 상위에서 &quot;Hello world&quot;를 삭제하고 두 번째 상위에서 &quot;Goodbye&quot;를 삭제 한 후 이전에 둘 다 없었던 &quot;Goodbye world&quot;를 추가했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e0fbc89a9eb1f686d88b41839c951cd18b86bf5e" translate="yes" xml:space="preserve">
          <source>This shows that you can do without a run script if you write the test on a single line.</source>
          <target state="translated">테스트를 한 줄에 작성하면 실행 스크립트 없이도 할 수 있음이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f580a082428b40358ee35f346bb87b38bbd6e3f8" translate="yes" xml:space="preserve">
          <source>This shows the change between HEAD and index (i.e. what will be committed if you say &lt;code&gt;git commit&lt;/code&gt;), and between index and working tree files (i.e. what you could stage further before &lt;code&gt;git commit&lt;/code&gt; using &lt;code&gt;git add&lt;/code&gt;) for each path. A sample output looks like this:</source>
          <target state="translated">이것은 각 경로에 대한 HEAD와 인덱스 사이의 변경 (즉 , &lt;code&gt;git commit&lt;/code&gt; 이라고하면 커밋 될 것 )과 인덱스와 작업 트리 파일 사이 (즉, &lt;code&gt;git add&lt;/code&gt; 를 사용하여 git &lt;code&gt;git commit&lt;/code&gt; 전에 추가로 스테이징 할 수있는 것 )를 보여줍니다. 샘플 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cdedf9c4235065dcc3b6a065543c259879fefa6b" translate="yes" xml:space="preserve">
          <source>This shows the files and directories to be deleted and issues an &quot;Input ignore patterns&amp;gt;&amp;gt;&quot; prompt. You can input space-separated patterns to exclude files and directories from deletion. E.g. &quot;*.c *.h&quot; will excludes files end with &quot;.c&quot; and &quot;.h&quot; from deletion. When you are satisfied with the filtered result, press ENTER (empty) back to the main menu.</source>
          <target state="translated">삭제 될 파일 및 디렉토리가 표시되고 &quot;Input ignore patterns &amp;gt;&amp;gt;&quot;프롬프트가 표시됩니다. 공백으로 구분 된 패턴을 입력하여 파일 및 디렉토리를 삭제에서 제외 할 수 있습니다. 예를 들어 &quot;* .c * .h&quot;는 &quot;.c&quot;및 &quot;.h&quot;로 끝나는 파일을 삭제에서 제외합니다. 필터링 된 결과가 만족 스러우면 ENTER (빈)를 다시 기본 메뉴로 누르십시오.</target>
        </trans-unit>
        <trans-unit id="d76da1518821bfa115def32fd19d8e8b1e73d979" translate="yes" xml:space="preserve">
          <source>This shows the files and directories to be deleted and issues an &quot;Select items to delete&amp;gt;&amp;gt;&quot; prompt. When the prompt ends with double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; like this, you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. &quot;2-5 7,9&quot; to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining items are selected. E.g. &quot;7-&quot; to choose 7,8,9 from the list. You can say &lt;code&gt;*&lt;/code&gt; to choose everything. Also when you are satisfied with the filtered result, press ENTER (empty) back to the main menu.</source>
          <target state="translated">삭제 될 파일 및 디렉토리가 표시되고 &quot;삭제할 항목 선택 &amp;gt;&amp;gt;&quot;프롬프트가 표시됩니다. 프롬프트가 이와 같이 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 로 끝나는 경우 공백이나 쉼표로 연결된 둘 이상의 선택을 할 수 있습니다. 또한 범위를 말할 수 있습니다. 예를 들어 &quot;2-5 7,9&quot;는 목록에서 2,3,4,5,7,9를 선택합니다. 범위의 두 번째 숫자가 생략되면 나머지 모든 항목이 선택됩니다. 예를 들어 &quot;7-&quot;을 사용하여 목록에서 7,8,9를 선택하십시오. &lt;code&gt;*&lt;/code&gt; 라고 말하면 모든 것을 선택할 수 있습니다 . 필터링 된 결과가 만족 스러우면 ENTER (빈)를 다시 기본 메뉴로 누르십시오.</target>
        </trans-unit>
        <trans-unit id="53f59db63b45945049b0fe262d831991c1cb4a8d" translate="yes" xml:space="preserve">
          <source>This shows the status information and issues an &quot;Update&amp;gt;&amp;gt;&quot; prompt. When the prompt ends with double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, you can make more than one selection, concatenated with whitespace or comma. Also you can say ranges. E.g. &quot;2-5 7,9&quot; to choose 2,3,4,5,7,9 from the list. If the second number in a range is omitted, all remaining patches are taken. E.g. &quot;7-&quot; to choose 7,8,9 from the list. You can say &lt;code&gt;*&lt;/code&gt; to choose everything.</source>
          <target state="translated">상태 정보가 표시되고 &quot;Update &amp;gt;&amp;gt;&quot;프롬프트가 표시됩니다. 프롬프트가 double &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 으로 끝나면 공백이나 쉼표로 연결된 둘 이상의 선택을 할 수 있습니다. 또한 범위를 말할 수 있습니다. 예를 들어 &quot;2-5 7,9&quot;는 목록에서 2,3,4,5,7,9를 선택합니다. 범위의 두 번째 숫자를 생략하면 나머지 모든 패치가 사용됩니다. 예를 들어 &quot;7-&quot;을 사용하여 목록에서 7,8,9를 선택하십시오. &lt;code&gt;*&lt;/code&gt; 라고 말하면 모든 것을 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="728eb7da1f0f1bff86889f4ac114a7967bd3817f" translate="yes" xml:space="preserve">
          <source>This snapshot is now stored in a temporary staging area which Git calls the &quot;index&quot;. You can permanently store the contents of the index in the repository with &lt;code&gt;git commit&lt;/code&gt;:</source>
          <target state="translated">이 스냅 샷은 이제 Git이 &quot;인덱스&quot;라고하는 임시 준비 영역에 저장됩니다. &lt;code&gt;git commit&lt;/code&gt; 을 사용하여 저장소에 색인의 내용을 영구적으로 저장할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfa3a419f48a4609a0668c69a143f543612e713a" translate="yes" xml:space="preserve">
          <source>This solution is not 100% bulletproof, in the sense that if some project has a named ref (branch, tag) starting with &lt;code&gt;git/&lt;/code&gt;, then paths such as</source>
          <target state="translated">이 솔루션은 일부 프로젝트에 &lt;code&gt;git/&lt;/code&gt; 시작하는 명명 된 참조 (분기, 태그)가있는 경우 다음과 같은 경로 가 있다는 점에서 100 % 방탄이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="02da975953020f9ebbe3388889e8a8406f05d0c7" translate="yes" xml:space="preserve">
          <source>This step and the next one could be combined into a single step with &quot;checkout -b my2.6.14 v2.6.14&quot;.</source>
          <target state="translated">이 단계와 다음 단계는 &quot;checkout -b my2.6.14 v2.6.14&quot;를 사용하여 단일 단계로 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b0b980e437fd3274de63464aa9184e42833d899" translate="yes" xml:space="preserve">
          <source>This suffix is also accepted when spelled in uppercase, and means the same thing no matter the case.</source>
          <target state="translated">이 접미사는 대문자로 표기 할 때도 사용할 수 있으며 경우에 상관없이 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="01f381d8f83cae139b7e7ff06573574ebdbc8086" translate="yes" xml:space="preserve">
          <source>This supersedes the &lt;a href=&quot;#post-update&quot;&gt;&lt;em&gt;post-update&lt;/em&gt;&lt;/a&gt; hook in that it gets both old and new values of all the refs in addition to their names.</source>
          <target state="translated">이것은 이름뿐만 아니라 모든 심판의 오래된 값과 새로운 값을 모두 얻는다는 점에서 &lt;a href=&quot;#post-update&quot;&gt;&lt;em&gt;업데이트 후&lt;/em&gt;&lt;/a&gt; 후크를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="6339f7da558022ed0ae10f566dd01f30bb047e19" translate="yes" xml:space="preserve">
          <source>This synchronizes your public repository to match the named branch head (i.e. &lt;code&gt;master&lt;/code&gt; in this case) and objects reachable from them in your current repository.</source>
          <target state="translated">그러면 이름이 지정된 브랜치 헤드 ( 이 경우 &lt;code&gt;master&lt;/code&gt; )와 현재 저장소에서 액세스 할 수있는 오브젝트와 일치하도록 공용 저장소가 동기화 됩니다.</target>
        </trans-unit>
        <trans-unit id="0012e2584fc653cc03e6dda35ea11cbdc9f6c1a2" translate="yes" xml:space="preserve">
          <source>This syntax is only recognized if there are no slashes before the first colon. This helps differentiate a local path that contains a colon. For example the local path &lt;code&gt;foo:bar&lt;/code&gt; could be specified as an absolute path or &lt;code&gt;./foo:bar&lt;/code&gt; to avoid being misinterpreted as an ssh url.</source>
          <target state="translated">이 구문은 첫 번째 콜론 앞에 슬래시가없는 경우에만 인식됩니다. 이것은 콜론을 포함하는 로컬 경로를 구별하는 데 도움이됩니다. 예를 들어 로컬 경로 &lt;code&gt;foo:bar&lt;/code&gt; 를 절대 경로로 지정하거나 &lt;code&gt;./foo:bar&lt;/code&gt; 를 지정 하여 ssh url로 잘못 해석되지 않도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f5d9872e03f1e6dd55415fa2249d9c84ea6f738" translate="yes" xml:space="preserve">
          <source>This takes a text file each of whose lines is a shell glob pattern. Filepairs that match a glob pattern on an earlier line in the file are output before ones that match a later line, and filepairs that do not match any glob pattern are output last.</source>
          <target state="translated">이것은 각 줄이 쉘 글로브 패턴 인 텍스트 파일을 가져옵니다. 파일의 이전 행에서 glob 패턴과 일치하는 파일 쌍은 이후 행과 일치하는 파일 쌍보다 먼저 출력되고 glob 패턴과 일치하지 않는 파일 쌍은 마지막으로 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="b169549655fddd825e67d14c1591493d6ac0be03" translate="yes" xml:space="preserve">
          <source>This target is intended to be more of a summary (like GIT_TRACE) and less detailed than the other targets. It ignores thread, region, and data messages, for example.</source>
          <target state="translated">이 목표는 GIT_TRACE와 같은 요약 일뿐 아니라 다른 목표보다 상세하지 않습니다. 예를 들어 스레드, 영역 및 데이터 메시지는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="49bec15344e0cef74269dabec868d060f4c1b07d" translate="yes" xml:space="preserve">
          <source>This tells the bisect process that no commit after &lt;code&gt;v2.5&lt;/code&gt;, up to and including &lt;code&gt;v2.6&lt;/code&gt;, should be tested.</source>
          <target state="translated">이것은 &lt;code&gt;v2.5&lt;/code&gt; 이후의 커밋이 &lt;code&gt;v2.6&lt;/code&gt; 이하의 커밋을 테스트 하지 않아야한다는 bisect 프로세스를 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="1842bab1269e00a8bf77d06ee23570861225cc48" translate="yes" xml:space="preserve">
          <source>This tells the bisect process that the commits between &lt;code&gt;v2.5&lt;/code&gt; and &lt;code&gt;v2.6&lt;/code&gt; (inclusive) should be skipped.</source>
          <target state="translated">이것은 vsect 프로세스에 &lt;code&gt;v2.5&lt;/code&gt; 와 &lt;code&gt;v2.6&lt;/code&gt; 사이의 커밋을 건너 뛰어야한다는 것을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="fb42c5eea9f7afe3662a07fd6af3c3105ab04e8f" translate="yes" xml:space="preserve">
          <source>This tells you that the immediately following version of the file was &quot;newsha&quot;, and that the immediately preceding version was &quot;oldsha&quot;. You also know the commit messages that went with the change from oldsha to 4b9458b and with the change from 4b9458b to newsha.</source>
          <target state="translated">이것은 파일의 바로 다음 버전은 &quot;newsha&quot;이고 바로 이전 버전은 &quot;oldsha&quot;임을 나타냅니다. 또한 oldsha에서 4b9458b로 변경하고 4b9458b에서 newsha로 변경 한 커밋 메시지도 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f1179423f3ea23a6c9e525ef159db41c1155b6a" translate="yes" xml:space="preserve">
          <source>This transformation is used to detect renames and copies, and is controlled by the -M option (to detect renames) and the -C option (to detect copies as well) to the &lt;code&gt;git diff-*&lt;/code&gt; commands. If the input contained these filepairs:</source>
          <target state="translated">이 변환은 이름 변경 및 사본을 감지하는 데 사용되며 -M 옵션 (이름 변경을 감지) 및 -C 옵션 (사본도 감지)에 의해 &lt;code&gt;git diff-*&lt;/code&gt; 명령으로 제어됩니다. 입력에 이러한 파일 쌍이 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="573190bccf8f2a4ea6fc33eedd23b4b8fc3f90f8" translate="yes" xml:space="preserve">
          <source>This transformation is used to merge filepairs broken by diffcore-break, and not transformed into rename/copy by diffcore-rename, back into a single modification. This always runs when diffcore-break is used.</source>
          <target state="translated">이 변환은 diffcore-break로 분리 된 파일 쌍을 병합하는 데 사용되며 diffcore-rename으로 이름 바꾸기 / 복사로 변환되지 않고 단일 수정으로 다시 변환됩니다. diffcore-break가 사용될 때 항상 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="448726c2164ad1aa28f4d84dcd657bc466764287" translate="yes" xml:space="preserve">
          <source>This transformation limits the set of filepairs to those that change specified strings between the preimage and the postimage in a certain way. -S&amp;lt;block of text&amp;gt; and -G&amp;lt;regular expression&amp;gt; options are used to specify different ways these strings are sought.</source>
          <target state="translated">이 변환은 파일 쌍 세트를 특정 방식으로 사전 이미지와 사후 이미지 사이에 지정된 문자열을 변경하는 파일 쌍으로 제한합니다. -S &amp;lt;텍스트 블록&amp;gt; 및 -G &amp;lt;정규 표현식&amp;gt; 옵션은 이러한 문자열을 찾는 다른 방법을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eb01f7c28a2e42a179d9ca76727e0a7db6bb8dce" translate="yes" xml:space="preserve">
          <source>This transport can be used for both uploading and downloading, and requires you to have a log-in privilege over &lt;code&gt;ssh&lt;/code&gt; to the remote machine. It finds out the set of objects the other side lacks by exchanging the head commits both ends have and transfers (close to) minimum set of objects. It is by far the most efficient way to exchange Git objects between repositories.</source>
          <target state="translated">이 전송은 업로드 및 다운로드에 모두 사용될 수 있으며 원격 시스템에 대한 &lt;code&gt;ssh&lt;/code&gt; 를 통한 로그인 권한이 필요합니다 . 헤드 커밋을 교환하여 다른쪽에없는 개체 집합을 찾은 다음 최소 개체 집합에 가깝게 전송합니다. 리포지토리간에 Git 객체를 교환하는 가장 효율적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="1e93313475dc2966a9b364d25d3e63ddb92cd35d" translate="yes" xml:space="preserve">
          <source>This transport is the same as SSH transport but uses &lt;code&gt;sh&lt;/code&gt; to run both ends on the local machine instead of running other end on the remote machine via &lt;code&gt;ssh&lt;/code&gt;.</source>
          <target state="translated">이 전송은 SSH 전송과 동일하지만 &lt;code&gt;ssh&lt;/code&gt; 를 통해 원격 시스템에서 다른 쪽 끝을 실행하는 대신 &lt;code&gt;sh&lt;/code&gt; 를 사용 하여 로컬 시스템에서 양 끝을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="187c060b77919e40b0db07be6c4444d6bedf0f1f" translate="yes" xml:space="preserve">
          <source>This transport was designed for anonymous downloading. Like SSH transport, it finds out the set of objects the downstream side lacks and transfers (close to) minimum set of objects.</source>
          <target state="translated">이 전송은 익명 다운로드 용으로 설계되었습니다. SSH 전송과 마찬가지로 다운 스트림 측에없는 개체 집합을 찾아 최소 개체 집합에 가깝게 전송합니다.</target>
        </trans-unit>
        <trans-unit id="a843c4941e9eb68216876c91a59842ae7d058faa" translate="yes" xml:space="preserve">
          <source>This tutorial explains how to import a new project into Git, make changes to it, and share changes with other developers.</source>
          <target state="translated">이 튜토리얼에서는 새 프로젝트를 Git으로 가져 와서 변경하고 다른 개발자와 변경 사항을 공유하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="586b98337ae35b657ccc9687b72106b49b3b174b" translate="yes" xml:space="preserve">
          <source>This tutorial explains how to use the &quot;core&quot; Git commands to set up and work with a Git repository.</source>
          <target state="translated">이 튜토리얼에서는 &quot;core&quot;Git 명령을 사용하여 Git 저장소를 설정하고 작업하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4f3b7287fc4739a451de38537fb0637003a134c1" translate="yes" xml:space="preserve">
          <source>This tutorial should be enough to perform basic distributed revision control for your projects. However, to fully understand the depth and power of Git you need to understand two simple ideas on which it is based:</source>
          <target state="translated">이 학습서는 프로젝트에 대한 기본 분산 개정 제어를 수행하기에 충분해야합니다. 그러나 Git의 깊이와 힘을 완전히 이해하려면 그 기반이되는 두 가지 간단한 아이디어를 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="50b7797bad77b49520127714ff8a716873aad978" translate="yes" xml:space="preserve">
          <source>This updates (or creates, as necessary) branches &lt;code&gt;pu&lt;/code&gt; and &lt;code&gt;tmp&lt;/code&gt; in the local repository by fetching from the branches (respectively) &lt;code&gt;pu&lt;/code&gt; and &lt;code&gt;maint&lt;/code&gt; from the remote repository.</source>
          <target state="translated">이는 원격 저장소에서 분기 (각각) &lt;code&gt;pu&lt;/code&gt; 및 &lt;code&gt;maint&lt;/code&gt; 를 가져와 로컬 저장소에서 분기 &lt;code&gt;pu&lt;/code&gt; 및 &lt;code&gt;tmp&lt;/code&gt; 를 업데이트 (또는 필요에 따라 작성 ) 합니다.</target>
        </trans-unit>
        <trans-unit id="70ac0b727096d7231e8fdcdd112d1a04551c8ca8" translate="yes" xml:space="preserve">
          <source>This used to be the default, but not since Git 2.0 (&lt;code&gt;simple&lt;/code&gt; is the new default).</source>
          <target state="translated">이것은 기본값이지만 Git 2.0 이후는 아닙니다 ( &lt;code&gt;simple&lt;/code&gt; 것이 새로운 기본값입니다).</target>
        </trans-unit>
        <trans-unit id="fd75f35034e73b98112aaaf4198ee488b9e51804" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;--interactive&lt;/code&gt; machinery internally, but combining it with the &lt;code&gt;--interactive&lt;/code&gt; option explicitly is generally not a good idea unless you know what you are doing (see BUGS below).</source>
          <target state="translated">이것은 &lt;code&gt;--interactive&lt;/code&gt; 기계를 내부적으로 사용하지만 &lt;code&gt;--interactive&lt;/code&gt; 옵션과 명시 적으로 결합하는 것은 자신이 무엇을하고 있는지 알지 않는 한 일반적으로 좋은 생각이 아닙니다 (아래 버그 참조).</target>
        </trans-unit>
        <trans-unit id="665eaff82148d49a545a97a7903a8bf0d3754608" translate="yes" xml:space="preserve">
          <source>This uses the &lt;code&gt;--interactive&lt;/code&gt; machinery internally, but it can be run without an explicit &lt;code&gt;--interactive&lt;/code&gt;.</source>
          <target state="translated">내부적으로 &lt;code&gt;--interactive&lt;/code&gt; 기계를 사용 하지만 명시적인 &lt;code&gt;--interactive&lt;/code&gt; 없이 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a59444b879ae5151f30b1cffe08974240ac7bdc" translate="yes" xml:space="preserve">
          <source>This uses the same two-dot range notation we saw earlier with &lt;code&gt;git log&lt;/code&gt;.</source>
          <target state="translated">이것은 이전에 &lt;code&gt;git log&lt;/code&gt; 와 동일한 2 점 범위 표기법을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="94dc29f5a82c88ac8ea06389eebe7535e89a6fb1" translate="yes" xml:space="preserve">
          <source>This value is true by default in a repository that has a working directory associated with it, and false by default in a bare repository.</source>
          <target state="translated">이 값은 연관된 작업 디렉토리가있는 저장소에서 기본적으로 true이고 기본 저장소에서 기본적으로 false입니다.</target>
        </trans-unit>
        <trans-unit id="73a34f84ecc165ae3643b28ecca4c6c41f197412" translate="yes" xml:space="preserve">
          <source>This variable can be used to restrict the permission bits of tar archive entries. The default is 0002, which turns off the world write bit. The special value &quot;user&quot; indicates that the archiving user&amp;rsquo;s umask will be used instead. See umask(2) and &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt;.</source>
          <target state="translated">이 변수는 tar 아카이브 항목의 권한 비트를 제한하는 데 사용할 수 있습니다. 기본값은 0002이며 월드 쓰기 비트를 끕니다. 특수 값 &quot;user&quot;는 보관 사용자의 umask가 대신 사용됨을 나타냅니다. umask (2) 및 &lt;a href=&quot;git-archive&quot;&gt;git-archive [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="63a384d932515032afb2060852ce18cd5598c9ca" translate="yes" xml:space="preserve">
          <source>This variable can be used to restrict the permission bits of tar archive entries. The default is 0002, which turns off the world write bit. The special value &quot;user&quot; indicates that the archiving user&amp;rsquo;s umask will be used instead. See umask(2) for details. If &lt;code&gt;--remote&lt;/code&gt; is used then only the configuration of the remote repository takes effect.</source>
          <target state="translated">이 변수는 tar 아카이브 항목의 권한 비트를 제한하는 데 사용할 수 있습니다. 기본값은 0002이며 월드 쓰기 비트를 끕니다. 특수 값 &quot;user&quot;는 보관 사용자의 umask가 대신 사용됨을 나타냅니다. 자세한 내용은 umask (2)를 참조하십시오. 경우 &lt;code&gt;--remote&lt;/code&gt; 는 다음에 사용되는 원격 저장소의 구성만을 시행한다.</target>
        </trans-unit>
        <trans-unit id="0afce327e7d4311118de1c5dc2faa8fa7a291053" translate="yes" xml:space="preserve">
          <source>This variable controls the event target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">이 변수는 이벤트 대상 목적지를 제어합니다. &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . 다음 표는 가능한 값을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b3073c2a2c3930628fae47eb515e2fe5729910f0" translate="yes" xml:space="preserve">
          <source>This variable controls the normal target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">이 변수는 일반 대상 목적지를 제어합니다. &lt;code&gt;GIT_TRACE2&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . 다음 표는 가능한 값을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ab644894061fa15fc115b6d355d07c2965277303" translate="yes" xml:space="preserve">
          <source>This variable controls the performance target destination. It may be overridden by the &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; environment variable. The following table shows possible values.</source>
          <target state="translated">이 변수는 성능 목표 대상을 제어합니다. &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . 다음 표는 가능한 값을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="53008d90e6aae985c2e7839a77d7b54894ce429e" translate="yes" xml:space="preserve">
          <source>This variable controls the sort ordering of branches when displayed by &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;. Without the &quot;--sort=&amp;lt;value&amp;gt;&quot; option provided, the value of this variable will be used as the default. See &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt; field names for valid values.</source>
          <target state="translated">이 변수는 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]로&lt;/a&gt; 표시 될 때 분기의 정렬 순서를 제어합니다 . &quot;--sort = &amp;lt;value&amp;gt;&quot;옵션을 제공하지 않으면이 변수의 값이 기본값으로 사용됩니다. 유효한 값 은 &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt; 필드 이름을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ea1c7eb75a360c1f9f69915dbc32e427ddfb7ced" translate="yes" xml:space="preserve">
          <source>This variable controls the sort ordering of tags when displayed by &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;. Without the &quot;--sort=&amp;lt;value&amp;gt;&quot; option provided, the value of this variable will be used as the default.</source>
          <target state="translated">이 변수는 &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]로&lt;/a&gt; 표시 될 때 태그의 정렬 순서를 제어합니다 . &quot;--sort = &amp;lt;value&amp;gt;&quot;옵션을 제공하지 않으면이 변수의 값이 기본값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c2680b6925a4a160ca8f3fee892cc23ec9be5f4f" translate="yes" xml:space="preserve">
          <source>This variable determines the default value for variables such as &lt;code&gt;color.diff&lt;/code&gt; and &lt;code&gt;color.grep&lt;/code&gt; that control the use of color per command family. Its scope will expand as more commands learn configuration to set a default for the &lt;code&gt;--color&lt;/code&gt; option. Set it to &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;never&lt;/code&gt; if you prefer Git commands not to use color unless enabled explicitly with some other configuration or the &lt;code&gt;--color&lt;/code&gt; option. Set it to &lt;code&gt;always&lt;/code&gt; if you want all output not intended for machine consumption to use color, to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;auto&lt;/code&gt; (this is the default since Git 1.8.4) if you want such output to use color when written to the terminal.</source>
          <target state="translated">이 변수 는 명령 패밀리 당 색상 사용을 제어하는 &lt;code&gt;color.diff&lt;/code&gt; 및 &lt;code&gt;color.grep&lt;/code&gt; 와 같은 변수의 기본값을 결정합니다 . &lt;code&gt;--color&lt;/code&gt; 옵션 의 기본값을 설정하기 위해 더 많은 명령이 구성을 배우면 범위가 확장됩니다 . 로 설정하여 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;never&lt;/code&gt; 당신은 다른 구성이나 명시 적으로 활성화하지 않는 한 망할 놈의 색상을 사용하지 않는 명령을 선호하지 않는 경우 &lt;code&gt;--color&lt;/code&gt; 옵션을 선택합니다. 로 설정하여 &lt;code&gt;always&lt;/code&gt; 모든 출력에 사용하는 색상에 기계 소비를위한 것이 아닙니다하려는 경우 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;auto&lt;/code&gt; (이 망할 놈의 1.8.4 이후 기본값) 터미널에 기록 할 때 사용하는 색상에 같은 출력을 원하는 경우.</target>
        </trans-unit>
        <trans-unit id="2eb6f1e33d90fc7fb4373fa1793932292fbc650d" translate="yes" xml:space="preserve">
          <source>This variable is the same as &lt;code&gt;transfer.hideRefs&lt;/code&gt;, but applies only to &lt;code&gt;receive-pack&lt;/code&gt; (and so affects pushes, but not fetches). An attempt to update or delete a hidden ref by &lt;code&gt;git push&lt;/code&gt; is rejected.</source>
          <target state="translated">이 변수는 &lt;code&gt;transfer.hideRefs&lt;/code&gt; 와 동일 하지만 &lt;code&gt;receive-pack&lt;/code&gt; 에만 적용 되므로 푸시에는 영향을 주지만 페치에는 영향을 미치지 않습니다. &lt;code&gt;git push&lt;/code&gt; 에 의해 숨겨진 참조를 업데이트하거나 삭제하려는 시도 는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="763a368531eb9d8bc40e93c6334e049f21620c45" translate="yes" xml:space="preserve">
          <source>This variable is the same as &lt;code&gt;transfer.hideRefs&lt;/code&gt;, but applies only to &lt;code&gt;upload-pack&lt;/code&gt; (and so affects only fetches, not pushes). An attempt to fetch a hidden ref by &lt;code&gt;git fetch&lt;/code&gt; will fail. See also &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt;.</source>
          <target state="translated">이 변수는 &lt;code&gt;transfer.hideRefs&lt;/code&gt; 와 동일 하지만 &lt;code&gt;upload-pack&lt;/code&gt; 에만 적용 되므로 푸시는 아닌 페치에만 영향을 미칩니다. &lt;code&gt;git fetch&lt;/code&gt; 에 의해 숨겨진 참조를 가져 오려는 시도 는 실패합니다. &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="75aa35a44ffd767e8a239dc01347d150ce1e39ed" translate="yes" xml:space="preserve">
          <source>This variable matters only when using persistent web environments that serve multiple requests using single gitweb instance, like mod_perl, FastCGI or Plackup.</source>
          <target state="translated">이 변수는 mod_perl, FastCGI 또는 Plackup과 같은 단일 gitweb 인스턴스를 사용하여 여러 요청을 처리하는 영구 웹 환경을 사용하는 경우에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="c0526214b5c55d639fefd6a92d93b97ec2455930" translate="yes" xml:space="preserve">
          <source>This variable specifies a shell command through which the tar output generated by &lt;code&gt;git archive&lt;/code&gt; should be piped. The command is executed using the shell with the generated tar file on its standard input, and should produce the final output on its standard output. Any compression-level options will be passed to the command (e.g., &quot;-9&quot;). An output file with the same extension as &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; will be use this format if no other format is given.</source>
          <target state="translated">이 변수는 &lt;code&gt;git archive&lt;/code&gt; 에 의해 생성 된 tar 출력 이 파이프되어야 하는 쉘 명령을 지정합니다 . 명령은 표준 입력에서 생성 된 tar 파일과 함께 쉘을 사용하여 실행되며 표준 출력에서 ​​최종 출력을 생성해야합니다. 모든 압축 수준 옵션이 명령에 전달됩니다 (예 : &quot;-9&quot;). 다른 형식을 지정하지 않으면 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 과 동일한 확장자를 가진 출력 파일 이이 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="99ffcf0d1fc58b3934082bac9786637cf3a8cdad" translate="yes" xml:space="preserve">
          <source>This view is similar to &lt;code&gt;shortlog&lt;/code&gt; view.</source>
          <target state="translated">이보기는 &lt;code&gt;shortlog&lt;/code&gt; 보기 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="16ae6576174eeb48325f0bfa3042bcb20d29d417" translate="yes" xml:space="preserve">
          <source>This was not the case in the initial release of this feature in v2.13.0, which only matched the realpath version. Configuration that wants to be compatible with the initial release of this feature needs to either specify only the realpath version, or both versions.</source>
          <target state="translated">v2.13.0에서이 기능의 초기 릴리스에서는 실제 경로 버전과 만 일치하지 않았습니다. 이 기능의 초기 릴리스와 호환 되려는 구성은 실제 경로 버전 만 지정하거나 두 버전을 모두 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7c8d457b197b5558b7abfe068bcd1974205f94ad" translate="yes" xml:space="preserve">
          <source>This was optional in prior versions of git, but now it is the default. You can use &lt;code&gt;--no-utf8&lt;/code&gt; to override this.</source>
          <target state="translated">이전 버전의 git에서는 선택 사항 이었지만 이제는 기본값입니다. &lt;code&gt;--no-utf8&lt;/code&gt; 을 사용 하여이를 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="314df942d006c94c85d3e8c8bfe0a0b8ef8308d1" translate="yes" xml:space="preserve">
          <source>This will again prompt you for a message describing the change, and then record a new version of the project.</source>
          <target state="translated">변경 사항을 설명하는 메시지가 다시 표시되고 새 버전의 프로젝트가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="53cca56aaa41c3093032e1d720cb620b22717e06" translate="yes" xml:space="preserve">
          <source>This will cache the result of running &quot;exif&quot; on each blob indefinitely. If you change the textconv config variable for a diff driver, Git will automatically invalidate the cache entries and re-run the textconv filter. If you want to invalidate the cache manually (e.g., because your version of &quot;exif&quot; was updated and now produces better output), you can remove the cache manually with &lt;code&gt;git update-ref -d refs/notes/textconv/jpg&lt;/code&gt; (where &quot;jpg&quot; is the name of the diff driver, as in the example above).</source>
          <target state="translated">이것은 각 blob에서 &quot;exif&quot;를 실행 한 결과를 무기한 캐시합니다. diff 드라이버의 textconv 구성 변수를 변경하면 Git은 자동으로 캐시 항목을 무효화하고 textconv 필터를 다시 실행합니다. 캐시를 수동으로 무효화하려면 (예 : &quot;exif&quot;버전이 업데이트되어 더 나은 출력을 생성하기 때문에) &lt;code&gt;git update-ref -d refs/notes/textconv/jpg&lt;/code&gt; 를 사용 하여 캐시를 수동으로 제거 할 수 있습니다 (여기서 &quot; jpg &quot;는 위의 예와 같이 diff 드라이버의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3d17cc7dd2b4aac7e00ecd2628dbb99eefd074c7" translate="yes" xml:space="preserve">
          <source>This will cause Git to generate &lt;code&gt;Binary files differ&lt;/code&gt; (or a binary patch, if binary patches are enabled) instead of a regular diff.</source>
          <target state="translated">이로 인해 Git 은 일반 diff 대신 &lt;code&gt;Binary files differ&lt;/code&gt; 을 생성 합니다 (또는 이진 패치가 활성화 된 경우 이진 패치).</target>
        </trans-unit>
        <trans-unit id="dac66330b2bd98fcf90352c4cbeba694c8f4feb3" translate="yes" xml:space="preserve">
          <source>This will check out the currently cached copy of &lt;code&gt;Makefile&lt;/code&gt; into the file &lt;code&gt;.merged-Makefile&lt;/code&gt;.</source>
          <target state="translated">현재 캐시 된 &lt;code&gt;Makefile&lt;/code&gt; 사본을 &lt;code&gt;.merged-Makefile&lt;/code&gt; 파일로 체크 아웃합니다 .</target>
        </trans-unit>
        <trans-unit id="9acb73cd9d17d8ef0d5dfd6af35ea9d0a50c12ab" translate="yes" xml:space="preserve">
          <source>This will create a new commit which undoes the change in HEAD. You will be given a chance to edit the commit message for the new commit.</source>
          <target state="translated">HEAD의 변경을 취소하는 새로운 커밋이 생성됩니다. 새 커밋에 대한 커밋 메시지를 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85437cd96f5cff3dd194d542498fd954d1bf1e01" translate="yes" xml:space="preserve">
          <source>This will define a remote called &quot;origin&quot; in the resulting repository that lets you fetch and pull from the bundle. The $GIT_DIR/config file in R2 will have an entry like this:</source>
          <target state="translated">결과 저장소에서 &quot;origin&quot;이라는 원격을 정의하여 번들에서 가져 와서 가져올 수 있습니다. R2의 $ GIT_DIR / config 파일에는 다음과 같은 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2986121c6e711f05b2ed0ba772dedbd8c66503ff" translate="yes" xml:space="preserve">
          <source>This will error out if $REV is empty or not a valid revision.</source>
          <target state="translated">$ REV가 비어 있거나 유효한 개정이 아닌 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c8b7e8566771f37a03bc25eaec95675ffe82ba31" translate="yes" xml:space="preserve">
          <source>This will export the whole repository and import it into the existing empty repository. Except for reencoding commits that are not in UTF-8, it would be a one-to-one mirror.</source>
          <target state="translated">전체 저장소를 내보내고 기존의 빈 저장소로 가져옵니다. UTF-8이 아닌 커밋을 다시 인코딩하는 것을 제외하고는 일대일 미러입니다.</target>
        </trans-unit>
        <trans-unit id="5f851e29f67384fe2f487309701055635453a02c" translate="yes" xml:space="preserve">
          <source>This will list what commits you must have in order to extract from the bundle and will error out if you do not have them.</source>
          <target state="translated">이것은 번들에서 추출하기 위해 필요한 커밋을 나열하고없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7ed8616207d4b6e51bdcbe1e7b524863a0139782" translate="yes" xml:space="preserve">
          <source>This will open your editor with a list of steps to be taken to perform your rebase.</source>
          <target state="translated">리베이스를 수행하기 위해 수행 할 단계 목록이있는 편집기가 열립니다.</target>
        </trans-unit>
        <trans-unit id="e9e68cbb3d1c11da9ad7575ebecc630d58996f10" translate="yes" xml:space="preserve">
          <source>This will prompt you for a commit message. You&amp;rsquo;ve now stored the first version of your project in Git.</source>
          <target state="translated">커밋 메시지를 묻는 메시지가 나타납니다. 이제 Git에 프로젝트의 첫 번째 버전을 저장했습니다.</target>
        </trans-unit>
        <trans-unit id="9229da0c83ee0b71f5a22085b5f3b7e07e9ec55a" translate="yes" xml:space="preserve">
          <source>This will remove each of your commits from mywork, temporarily saving them as patches (in a directory named &lt;code&gt;.git/rebase-apply&lt;/code&gt;), update mywork to point at the latest version of origin, then apply each of the saved patches to the new mywork. The result will look like:</source>
          <target state="translated">이렇게하면 커밋이 mywork에서 제거되어 패치 ( &lt;code&gt;.git/rebase-apply&lt;/code&gt; 디렉토리에)로 임시 저장 되고 최신 버전의 원점을 가리 키도록 mywork를 업데이트 한 다음 저장된 각 패치를 새로운 mywork에 적용합니다 . 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c98be5284d00528a6b74a33ba778d044a767668" translate="yes" xml:space="preserve">
          <source>This will result in only b (a and c are cleared).</source>
          <target state="translated">결과적으로 b 만됩니다 (a와 c가 지워짐).</target>
        </trans-unit>
        <trans-unit id="0385ed25689cd3e1167020ff6e8ba549d1603871" translate="yes" xml:space="preserve">
          <source>This will set the property &lt;code&gt;svn:keywords&lt;/code&gt; to &lt;code&gt;FreeBSD=%H&lt;/code&gt; for the file &lt;code&gt;devel/py-tipper/Makefile&lt;/code&gt;.</source>
          <target state="translated">그러면 &lt;code&gt;devel/py-tipper/Makefile&lt;/code&gt; 파일에 대해 &lt;code&gt;svn:keywords&lt;/code&gt; 속성 이 &lt;code&gt;FreeBSD=%H&lt;/code&gt; 로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="61383e31770f578e5ee86310440dccd09a4e5008" translate="yes" xml:space="preserve">
          <source>This will show &quot;refs/heads/master&quot; but also &quot;refs/remote/other-repo/master&quot;, if such references exists.</source>
          <target state="translated">&quot;참조 / 헤드 / 마스터&quot;뿐만 아니라 &quot;참조 / 리모트 / 기타 / 리포 / 마스터&quot;도 표시됩니다 (해당 참조가있는 경우).</target>
        </trans-unit>
        <trans-unit id="23dd2de32c54566f1df1adf9f6794600102b9c2b" translate="yes" xml:space="preserve">
          <source>This will start to clean, and you must confirm one by one in order to delete items. Please note that this action is not as efficient as the above two actions.</source>
          <target state="translated">청소가 시작되고 항목을 삭제하려면 하나씩 확인해야합니다. 이 조치는 위의 두 조치보다 효율적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b7bbd24afc1c6a470a80ef47d5171b33809ea28" translate="yes" xml:space="preserve">
          <source>This works for any of the supported update procedures (&lt;code&gt;--checkout&lt;/code&gt;, &lt;code&gt;--rebase&lt;/code&gt;, etc.). The only change is the source of the target SHA-1. For example, &lt;code&gt;submodule update --remote --merge&lt;/code&gt; will merge upstream submodule changes into the submodules, while &lt;code&gt;submodule update
--merge&lt;/code&gt; will merge superproject gitlink changes into the submodules.</source>
          <target state="translated">지원되는 모든 업데이트 절차 ( &lt;code&gt;--checkout&lt;/code&gt; , &lt;code&gt;--rebase&lt;/code&gt; 등)에 적용됩니다. 유일한 변경 사항은 대상 SHA-1의 소스입니다. 예를 들어, &lt;code&gt;submodule update --remote --merge&lt;/code&gt; 동안, 서브 모듈로 상향 서브 모듈의 변경 내용을 병합 할 &lt;code&gt;submodule update --merge&lt;/code&gt; 서브 모듈에 superproject gitlink 변경을 병합합니다.</target>
        </trans-unit>
        <trans-unit id="5a2ee7840b76b59e3aede30738fb578b292bc5f3" translate="yes" xml:space="preserve">
          <source>This works similarly to &lt;code&gt;svn update&lt;/code&gt; or &lt;code&gt;git pull&lt;/code&gt; except that it preserves linear history with &lt;code&gt;git rebase&lt;/code&gt; instead of &lt;code&gt;git merge&lt;/code&gt; for ease of dcommitting with &lt;code&gt;git svn&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;svn update&lt;/code&gt; 또는 &lt;code&gt;git pull&lt;/code&gt; 과 유사하게 작동 하지만 &lt;code&gt;git svn&lt;/code&gt; 으로 쉽게 커밋 &lt;code&gt;git merge&lt;/code&gt; 있도록 git merge 대신 &lt;code&gt;git rebase&lt;/code&gt; 로 선형 히스토리를 유지한다는 점을 제외하고 .</target>
        </trans-unit>
        <trans-unit id="5bc6c0e59c3e651570d66e12101e9a57040fd659" translate="yes" xml:space="preserve">
          <source>This would leave only one merge commit when your topic branch is finally ready and merged into the master branch. This merge would require you to resolve the conflict, introduced by the commits marked with &lt;code&gt;*&lt;/code&gt;. However, this conflict is often the same conflict you resolved when you created the test merge you blew away. &lt;code&gt;git rerere&lt;/code&gt; helps you resolve this final conflicted merge using the information from your earlier hand resolve.</source>
          <target state="translated">그러면 토픽 브랜치가 준비되고 마스터 브랜치로 병합 될 때 하나의 병합 커밋 만 남게됩니다. 이 병합은 &lt;code&gt;*&lt;/code&gt; 로 표시된 커밋에 의해 도입 된 충돌을 해결해야합니다 . 그러나이 충돌은 종종 테스트 병합을 만들 때 해결 한 충돌과 동일합니다. &lt;code&gt;git rerere&lt;/code&gt; 를 사용하면 이전에 해결 한 정보를 사용하여이 최종 충돌 병합을 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcd6f908de988995d9fff4cafd75d14bc0785c1a" translate="yes" xml:space="preserve">
          <source>This would leave the merge result in &lt;code&gt;hello.c~2&lt;/code&gt; file, along with conflict markers if there are conflicts. After verifying the merge result makes sense, you can tell Git what the final merge result for this file is by:</source>
          <target state="translated">그러면 충돌이있는 경우 병합 결과 가 충돌 마커와 함께 &lt;code&gt;hello.c~2&lt;/code&gt; 파일 에 남습니다 . 병합 결과가 올바른지 확인한 후 Git에이 파일의 최종 병합 결과가 무엇인지 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf5b7c750a4b16617dfd7cff20be48990a9d7985" translate="yes" xml:space="preserve">
          <source>This:</source>
          <target state="translated">This:</target>
        </trans-unit>
        <trans-unit id="ee3cacca7314105556d3050112f523980e59f973" translate="yes" xml:space="preserve">
          <source>Those snapshots aren&amp;rsquo;t necessarily all arranged in a single line from oldest to newest; instead, work may simultaneously proceed along parallel lines of development, called &lt;a href=&quot;#def_branch&quot;&gt;branches&lt;/a&gt;, which may merge and diverge.</source>
          <target state="translated">이러한 스냅 샷이 반드시 가장 오래된 것부터 가장 오래된 것까지 한 줄로 배열 된 것은 아닙니다. 대신, &lt;a href=&quot;#def_branch&quot;&gt;분기&lt;/a&gt; 라고하는 병렬 개발 라인을 따라 작업이 동시에 진행되어 병합 및 분기 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a5a53a50d0fbac4f3a27d9d2d5853146557d940" translate="yes" xml:space="preserve">
          <source>Though not required, it&amp;rsquo;s a good idea to begin the commit message with a single short (less than 50 character) line summarizing the change, followed by a blank line and then a more thorough description. The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git. For example, &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; turns a commit into email, and it uses the title on the Subject line and the rest of the commit in the body.</source>
          <target state="translated">필수 사항은 아니지만 변경 내용을 요약하는 짧은 한 줄 (50 자 미만)로 커밋 메시지를 시작한 다음 빈 줄과 자세한 설명으로 시작하는 것이 좋습니다. 커밋 메시지의 첫 번째 빈 줄까지의 텍스트는 커밋 제목으로 취급되며 해당 제목은 Git 전체에서 사용됩니다. 예를 들어, &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; 은 커밋을 전자 메일로 변환하고 제목 줄의 제목과 본문의 나머지 커밋을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fdd6ea0498f5dbe48e6926bc8c91e77146fa2184" translate="yes" xml:space="preserve">
          <source>Though, according to Wikipedia &lt;a href=&quot;#3&quot;&gt;[3]&lt;/a&gt;:</source>
          <target state="translated">그러나 Wikipedia에 따르면 &lt;a href=&quot;#3&quot;&gt;[3]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="18c9e3ce5bbbf77af11ba41f4d7a7d9b7a1aaa55" translate="yes" xml:space="preserve">
          <source>Thread Events</source>
          <target state="translated">스레드 이벤트</target>
        </trans-unit>
        <trans-unit id="8850eee2783cf53d0af71d524467316d7d06a850" translate="yes" xml:space="preserve">
          <source>Thread messages added to a thread-proc.</source>
          <target state="translated">스레드 메시지가 스레드 프로세스에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="1501e9d814d273ed34cc6b50f1b5e25add4ac049" translate="yes" xml:space="preserve">
          <source>Three other shorthands exist, particularly useful for merge commits, for naming a set that is formed by a commit and its parent commits.</source>
          <target state="translated">커밋과 그 부모 커밋으로 구성된 집합의 이름을 지정하기 위해 특히 병합 커밋에 유용한 세 가지 다른 속기는 존재합니다.</target>
        </trans-unit>
        <trans-unit id="8e23a87c8354d34eb4b513798d76048267e22ae4" translate="yes" xml:space="preserve">
          <source>Three steps:</source>
          <target state="translated">세 단계 :</target>
        </trans-unit>
        <trans-unit id="cf3d01be00b3333c6ca36b4d1bb0a1a1c357a43f" translate="yes" xml:space="preserve">
          <source>Throw-away integration</source>
          <target state="translated">버림받은 통합</target>
        </trans-unit>
        <trans-unit id="c4780f4837eebde8ca1de31df251ef05e2361eb2" translate="yes" xml:space="preserve">
          <source>Thunderbird</source>
          <target state="translated">Thunderbird</target>
        </trans-unit>
        <trans-unit id="d5e84648e0355ba1080675ff57a3c64a03a76a7c" translate="yes" xml:space="preserve">
          <source>Thunderbird in particular is known to be problematic. Thunderbird users may wish to visit this web page for more information: &lt;a href=&quot;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&quot;&gt;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&lt;/a&gt;</source>
          <target state="translated">썬더 버드는 특히 문제가있는 것으로 알려져 있습니다. 썬더 버드 사용자는이 웹 페이지를 방문하여 자세한 정보를 얻을 수 있습니다. &lt;a href=&quot;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&quot;&gt;http://kb.mozillazine.org/Plain_text_e-mail_-_Thunderbird#Completely_plain_email&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="da473e9b687406079cfbc2672fddb50595865b5d" translate="yes" xml:space="preserve">
          <source>Thus we see that this tree has one file in it. The SHA-1 hash is a reference to that file&amp;rsquo;s data:</source>
          <target state="translated">따라서이 트리에는 하나의 파일이 있음을 알 수 있습니다. SHA-1 해시는 해당 파일의 데이터에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="309fb29079c2e5019b9d34cb235aee0452735a40" translate="yes" xml:space="preserve">
          <source>Thus you can, e.g., turn a library subdirectory into a repository of its own. Note the &lt;code&gt;--&lt;/code&gt; that separates &lt;code&gt;filter-branch&lt;/code&gt; options from revision options, and the &lt;code&gt;--all&lt;/code&gt; to rewrite all branches and tags.</source>
          <target state="translated">따라서 라이브러리 서브 디렉토리를 자체의 저장소로 전환 할 수 있습니다. 참고 &lt;code&gt;--&lt;/code&gt; 분리형의 것을 &lt;code&gt;filter-branch&lt;/code&gt; 개정 옵션 및에서 옵션을 &lt;code&gt;--all&lt;/code&gt; 은 모든 브랜치와 태그를 다시 작성합니다.</target>
        </trans-unit>
        <trans-unit id="d35ca4f0ad7715e9f69a7f979c2424eb99273503" translate="yes" xml:space="preserve">
          <source>Thus, the following command:</source>
          <target state="translated">따라서 다음 명령은</target>
        </trans-unit>
        <trans-unit id="77cc1ec67e1af48d92e062ee397960be200bdf58" translate="yes" xml:space="preserve">
          <source>Thus, we can provide O(log N) lookup time for any number of packfiles.</source>
          <target state="translated">따라서 여러 팩 파일에 대해 O (log N) 조회 시간을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae19d34e63a0724afdaaeabe3d0fe80af7f9e778" translate="yes" xml:space="preserve">
          <source>Time and date specified by the ISO 8601 standard, for example &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt;. The parser accepts a space instead of the &lt;code&gt;T&lt;/code&gt; character as well.</source>
          <target state="translated">ISO 8601 표준에 의해 지정된 시간과 날짜 (예 &lt;code&gt;2005-04-07T22:13:13&lt;/code&gt; . 파서는 &lt;code&gt;T&lt;/code&gt; 문자 대신 공백을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="0bac72478f018c225224e8417f521a2dad6209d3" translate="yes" xml:space="preserve">
          <source>Time zone values can be &quot;local&quot; (for local time zone that browser uses), &quot;utc&quot; (what gitweb uses when JavaScript or this feature is disabled), or numerical time zones in the form of &quot;+/-HHMM&quot;, such as &quot;+0200&quot;.</source>
          <target state="translated">시간대 값은 &quot;local&quot;(브라우저가 사용하는 현지 시간대), &quot;utc&quot;(JavaScript 또는이 기능이 비활성화 된 경우 gitweb이 사용하는 것) 또는 &quot;+/- HHMM&quot;형식의 숫자 시간대 일 수 있습니다. &quot;+0200&quot;으로</target>
        </trans-unit>
        <trans-unit id="396a560fd1658574279d941c34737eda5359f4fc" translate="yes" xml:space="preserve">
          <source>Timeout (in seconds) between the moment the connection is established and the client request is received (typically a rather low value, since that should be basically immediate).</source>
          <target state="translated">연결이 설정되는 순간과 클라이언트 요청이 수신되는 시점 사이의 시간 초과 (초) : 일반적으로 즉각적으로 이루어져야하기 때문에 다소 낮은 값입니다.</target>
        </trans-unit>
        <trans-unit id="0ae2f4dfeb0fa0aaf2833b3c271308d2190a4162" translate="yes" xml:space="preserve">
          <source>Timeout (in seconds) for specific client sub-requests. This includes the time it takes for the server to process the sub-request and the time spent waiting for the next client&amp;rsquo;s request.</source>
          <target state="translated">특정 클라이언트 하위 요청에 대한 시간 초과 (초) 여기에는 서버가 하위 요청을 처리하는 데 걸리는 시간과 다음 클라이언트의 요청을 기다리는 데 걸린 시간이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ad6b83abe0aada0e5e6aec8e7e7470429fd4ee37" translate="yes" xml:space="preserve">
          <source>Tips and tricks</source>
          <target state="translated">팁과 요령</target>
        </trans-unit>
        <trans-unit id="d7242682d2f91b131962f45ed3706e536d3cdcc6" translate="yes" xml:space="preserve">
          <source>To &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; more than two &lt;a href=&quot;#def_branch&quot;&gt;branches&lt;/a&gt;.</source>
          <target state="translated">두 &lt;a href=&quot;#def_branch&quot;&gt;개&lt;/a&gt; 이상의 지점 을 &lt;a href=&quot;#def_merge&quot;&gt;병합&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7c181af3380fe2a4df836df7796a5de6ef8d47c5" translate="yes" xml:space="preserve">
          <source>To access refs, it&amp;rsquo;s best not to look inside GIT_DIR directly. Instead use commands such as &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt; or &lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref[1]&lt;/a&gt; which will handle refs correctly.</source>
          <target state="translated">심판에 액세스하려면 GIT_DIR 내부를 직접 보지 않는 것이 가장 좋습니다. 대신 &lt;a href=&quot;git-update-ref&quot;&gt;ref를&lt;/a&gt; 올바르게 처리하는 &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]&lt;/a&gt; 또는 git-update-ref [1] 과 같은 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bdc5ec95e827bdeffd1f9aab0bef5dd1e05d0443" translate="yes" xml:space="preserve">
          <source>To achieve this, try to split your work into small steps from the very beginning. It is always easier to squash a few commits together than to split one big commit into several. Don&amp;rsquo;t be afraid of making too small or imperfect steps along the way. You can always go back later and edit the commits with &lt;code&gt;git rebase --interactive&lt;/code&gt; before you publish them. You can use &lt;code&gt;git stash push --keep-index&lt;/code&gt; to run the test suite independent of other uncommitted changes; see the EXAMPLES section of &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">이를 위해서는 처음부터 작은 단계로 작업을 분할하십시오. 하나의 큰 커밋을 여러 개의 커밋으로 나누는 것보다 몇 개의 커밋을 함께 스쿼시하는 것이 항상 쉽습니다. 길을 따라 너무 작거나 불완전한 발걸음을 내딛는 것을 두려워하지 마십시오. 커밋 하기 전에 언제든지 &lt;code&gt;git rebase --interactive&lt;/code&gt; 로 커밋을 편집하고 편집 할 수 있습니다. &lt;code&gt;git stash push --keep-index&lt;/code&gt; 를 사용하여 커밋되지 않은 다른 변경과 독립적으로 테스트 스위트를 실행할 수 있습니다 . &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; 의 예제 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0fad63887775e60c970096082173b077cbcda459" translate="yes" xml:space="preserve">
          <source>To actually match only values with an exclamation mark, you have to</source>
          <target state="translated">느낌표가있는 값만 실제로 일치 시키려면</target>
        </trans-unit>
        <trans-unit id="0fea0d3a69770ac7053eba17165f8f811c0d830f" translate="yes" xml:space="preserve">
          <source>To add a new proxy, without altering any of the existing ones, use</source>
          <target state="translated">기존 프록시를 변경하지 않고 새 프록시를 추가하려면</target>
        </trans-unit>
        <trans-unit id="6a37f3f129452efb4608e170beca8c23ff8dc189" translate="yes" xml:space="preserve">
          <source>To aid in debugging frontends fast-import ignores any line that begins with &lt;code&gt;#&lt;/code&gt; (ASCII pound/hash) up to and including the line ending &lt;code&gt;LF&lt;/code&gt;. A comment line may contain any sequence of bytes that does not contain an LF and therefore may be used to include any detailed debugging information that might be specific to the frontend and useful when inspecting a fast-import data stream.</source>
          <target state="translated">프론트 엔드 디버깅을 돕기 위해 빠른 가져 오기는 &lt;code&gt;#&lt;/code&gt; (ASCII 파운드 / 해시)로 시작하는 라인부터 &lt;code&gt;LF&lt;/code&gt; 까지 끝나는 라인을 무시합니다 . 주석 행은 LF를 포함하지 않는 임의의 바이트 시퀀스를 포함 할 수 있으므로 빠른 가져 오기 데이터 스트림을 검사 할 때 프론트 엔드에 고유하고 상세한 디버깅 정보를 포함하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="285359187a2aff04e4ea763b2f3e4bbaf641190b" translate="yes" xml:space="preserve">
          <source>To assist in this, Git also provides the tag object&amp;hellip;​</source>
          <target state="translated">이를 돕기 위해 Git은 태그 객체도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b0021f1eb05e23f63eb7ccc2f58c52546ee61585" translate="yes" xml:space="preserve">
          <source>To avoid deadlock, such frontends must completely consume any pending output from &lt;code&gt;progress&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;, &lt;code&gt;get-mark&lt;/code&gt;, and &lt;code&gt;cat-blob&lt;/code&gt; before performing writes to fast-import that might block.</source>
          <target state="translated">교착 상태를 피하려면 이러한 프론트 엔드 가 차단 될 수있는 빠른 가져 오기에 쓰기를 수행하기 전에 &lt;code&gt;progress&lt;/code&gt; , &lt;code&gt;ls&lt;/code&gt; , &lt;code&gt;get-mark&lt;/code&gt; 및 &lt;code&gt;cat-blob&lt;/code&gt; 에서 보류중인 출력을 완전히 소비해야합니다 .</target>
        </trans-unit>
        <trans-unit id="75e1daad195d404dc835c71216234df4a4676d4e" translate="yes" xml:space="preserve">
          <source>To avoid deleting a shared index file that is still used, its modification time is updated to the current time every time a new split index based on the shared index file is either created or read from.</source>
          <target state="translated">여전히 사용되는 공유 인덱스 파일을 삭제하지 않으려면 공유 인덱스 파일을 기반으로하는 새 분할 인덱스를 만들거나 읽을 때마다 수정 시간이 현재 시간으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="0b95bb4f949904cf33707d2a81be23c345f8e5aa" translate="yes" xml:space="preserve">
          <source>To avoid false positives (e.g. when a patch has been removed, and an unrelated patch has been added between two iterations of the same patch series), the cost matrix is extended to allow for that, by adding fixed-cost entries for wholesale deletes/adds.</source>
          <target state="translated">오 탐지 (예 : 패치가 제거되고 동일한 패치 시리즈의 두 반복간에 관련이없는 패치가 추가 된 경우)를 방지하기 위해 도매 삭제에 고정 비용 항목을 추가하여 비용 매트릭스를 확장 할 수 있습니다. 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0fd573776931ed5e5643654b60eb3896366ed973" translate="yes" xml:space="preserve">
          <source>To avoid interfering with other worktrees, it first enables the &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; setting and makes sure to set the &lt;code&gt;core.sparseCheckout&lt;/code&gt; setting in the worktree-specific config file.</source>
          <target state="translated">다른 작업 트리와의 간섭을 피하기 위해 먼저 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 설정을 활성화하고 작업 트리 특정 구성 파일에서 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 설정 을 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3c2082115575958e10a9c1afdaf9ab0c9127b12a" translate="yes" xml:space="preserve">
          <source>To avoid recording unrelated changes in the merge commit, &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt; will also abort if there are any changes registered in the index relative to the &lt;code&gt;HEAD&lt;/code&gt; commit. (Special narrow exceptions to this rule may exist depending on which merge strategy is in use, but generally, the index must match HEAD.)</source>
          <target state="translated">병합 커밋에서 관련없는 변경 사항을 기록하지 않기 위해 &lt;code&gt;HEAD&lt;/code&gt; 커밋과 관련하여 인덱스에 등록 된 변경 사항이있는 경우 &lt;code&gt;git pull&lt;/code&gt; 및 &lt;code&gt;git merge&lt;/code&gt; 도 중단됩니다 . 사용중인 병합 전략에 따라이 규칙에 대한 특별한 좁은 예외가있을 수 있지만 일반적으로 인덱스는 HEAD와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="3066556f3c40d15744968614a5fc8c1e23bf8a7b" translate="yes" xml:space="preserve">
          <source>To avoid typing long email addresses, point this to one or more email aliases files. You must also supply &lt;code&gt;sendemail.aliasFileType&lt;/code&gt;.</source>
          <target state="translated">긴 이메일 주소를 입력하지 않으려면 하나 이상의 이메일 별명 파일을 가리 킵니다. &lt;code&gt;sendemail.aliasFileType&lt;/code&gt; 도 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c4b87fbf313d264308ea989e0e3b9a4c3d776c25" translate="yes" xml:space="preserve">
          <source>To bootstrap the process, you can first create a bundle that does not have any basis. You can use a tag to remember up to what commit you last processed, in order to make it easy to later update the other repository with an incremental bundle:</source>
          <target state="translated">프로세스를 부트 스트랩하려면 먼저 기본이없는 번들을 작성할 수 있습니다. 나중에 증분 번들로 다른 저장소를 쉽게 업데이트 할 수 있도록 태그를 사용하여 마지막으로 처리 한 커밋까지 기억할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d8840568125195e79747db7654d577582e9ce27" translate="yes" xml:space="preserve">
          <source>To change which notes are shown by &lt;code&gt;git log&lt;/code&gt;, see the &quot;notes.displayRef&quot; configuration in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;git log&lt;/code&gt; 로 표시되는 메모를 변경하려면 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 의 &quot;notes.displayRef&quot;구성을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="97883ec3271fcc02269394ee0880b3655a6f452f" translate="yes" xml:space="preserve">
          <source>To check out commit &lt;code&gt;HEAD~3&lt;/code&gt; for temporary inspection or experiment without creating a new branch:</source>
          <target state="translated">새 분기를 만들지 않고 임시 검사 또는 실험을 위해 커밋 &lt;code&gt;HEAD~3&lt;/code&gt; 을 확인하려면 :</target>
        </trans-unit>
        <trans-unit id="d144f3be27bf6711b21fc83fdbf3f1e8ff9fc321" translate="yes" xml:space="preserve">
          <source>To commit a tree you have instantiated with &lt;code&gt;git write-tree&lt;/code&gt;, you&amp;rsquo;d create a &quot;commit&quot; object that refers to that tree and the history behind it&amp;mdash;​most notably the &quot;parent&quot; commits that preceded it in history.</source>
          <target state="translated">&lt;code&gt;git write-tree&lt;/code&gt; 로 인스턴스화 한 트리를 커밋하려면 해당 트리와 그 히스토리를 참조하는 &quot;커밋&quot;객체를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="05e44c536d85ee3801aa2c0d698cefa8d09c4c33" translate="yes" xml:space="preserve">
          <source>To completely remove a submodule, manually delete &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt;.</source>
          <target state="translated">서브 모듈을 완전히 제거하려면 &lt;code&gt;$GIT_DIR/modules/&amp;lt;name&amp;gt;/&lt;/code&gt; 수동으로 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="27c15a86c7e79c3805e163825e563ceb0da18b5a" translate="yes" xml:space="preserve">
          <source>To control which revisions to show, gitk supports most options applicable to the &lt;code&gt;git rev-list&lt;/code&gt; command. It also supports a few options applicable to the &lt;code&gt;git diff-*&lt;/code&gt; commands to control how the changes each commit introduces are shown. Finally, it supports some gitk-specific options.</source>
          <target state="translated">표시 할 개정을 제어하기 위해 gitk는 &lt;code&gt;git rev-list&lt;/code&gt; 명령에 적용 가능한 대부분의 옵션을 지원합니다 . 또한 &lt;code&gt;git diff-*&lt;/code&gt; 명령에 적용 할 수있는 몇 가지 옵션을 지원하여 각 커밋의 변경 내용 표시 방법을 제어합니다. 마지막으로, 일부 gitk 특정 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="777e371b82028c9765bc912013f44d79febb95a6" translate="yes" xml:space="preserve">
          <source>To cope with such a situation, after the inner &lt;code&gt;git bisect&lt;/code&gt; finds the next revision to test, the script can apply the patch before compiling, run the real test, and afterwards decide if the revision (possibly with the needed patch) passed the test and then rewind the tree to the pristine state. Finally the script should exit with the status of the real test to let the &lt;code&gt;git bisect run&lt;/code&gt; command loop determine the eventual outcome of the bisect session.</source>
          <target state="translated">이러한 상황에 대처하기 위해 내부 &lt;code&gt;git bisect&lt;/code&gt; 가 테스트 할 다음 개정을 찾은 후 스크립트는 컴파일하기 전에 패치를 적용하고 실제 테스트를 실행 한 후 수정 (필요한 패치로 가능)이 테스트를 통과했는지 여부를 결정하고 그런 다음 트리를 원래 상태로 되감습니다. 마지막으로 스크립트는 실제 테스트 상태와 함께 종료되어 &lt;code&gt;git bisect run&lt;/code&gt; 명령 루프가 bisect 세션의 최종 결과를 결정하도록합니다.</target>
        </trans-unit>
        <trans-unit id="8674c1ca562e6ecc34e19d2429ea897e7602bd28" translate="yes" xml:space="preserve">
          <source>To create your own local live copy of such a &quot;raw&quot; Git repository, you&amp;rsquo;d first create your own subdirectory for the project, and then copy the raw repository contents into the &lt;code&gt;.git&lt;/code&gt; directory. For example, to create your own copy of the Git repository, you&amp;rsquo;d do the following</source>
          <target state="translated">이러한 &quot;원시&quot;Git 저장소의 자체 로컬 라이브 사본을 작성하려면 먼저 프로젝트에 대한 자체 서브 디렉토리를 작성한 후 원시 저장소 컨텐츠를 &lt;code&gt;.git&lt;/code&gt; 디렉토리에 복사하십시오 . 예를 들어, Git 리포지토리의 자체 복사본을 만들려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="495be7922d2a293092e6f366efd8045104e01478" translate="yes" xml:space="preserve">
          <source>To define a custom merge driver &lt;code&gt;filfre&lt;/code&gt;, add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">사용자 정의 병합 드라이버 &lt;code&gt;filfre&lt;/code&gt; 를 정의하려면 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 (또는 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 파일)에 다음과 같이 섹션을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="369d97c17e3edbb633e139fcbb4d6a1ea94c1201" translate="yes" xml:space="preserve">
          <source>To define an external diff driver &lt;code&gt;jcdiff&lt;/code&gt;, add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">외부 diff 드라이버 &lt;code&gt;jcdiff&lt;/code&gt; 를 정의하려면 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 (또는 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 파일)에 다음과 같이 섹션을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="302897a013466c7a33ee45af87c508a98422abd4" translate="yes" xml:space="preserve">
          <source>To delete the entry for renames, do</source>
          <target state="translated">이름을 바꾸려면 해당 항목을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="f31f6b0ae1c80bea942e287ae0ab318c31ede1f4" translate="yes" xml:space="preserve">
          <source>To determine the location of the repository on disk, &lt;code&gt;git http-backend&lt;/code&gt; concatenates the environment variables PATH_INFO, which is set automatically by the web server, and GIT_PROJECT_ROOT, which must be set manually in the web server configuration. If GIT_PROJECT_ROOT is not set, &lt;code&gt;git http-backend&lt;/code&gt; reads PATH_TRANSLATED, which is also set automatically by the web server.</source>
          <target state="translated">디스크에서 저장소의 위치를 ​​판별하기 위해 &lt;code&gt;git http-backend&lt;/code&gt; 는 웹 서버에서 자동으로 설정 한 환경 변수 PATH_INFO와 웹 서버 구성에서 수동으로 설정해야하는 GIT_PROJECT_ROOT를 연결합니다. GIT_PROJECT_ROOT가 설정되어 있지 않은 경우, &lt;code&gt;git http-backend&lt;/code&gt; 는 PATH_TRANSLATED를 읽으며 웹 서버에 의해 자동으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b99f7180a07f9dbb13dde063c76c98dd5e2d7887" translate="yes" xml:space="preserve">
          <source>To disable features that accept parameters (are configurable), you need to set this element to empty list i.e. &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">매개 변수를 허용하는 기능을 비활성화하려면 (구성 가능)이 요소를 빈 목록 (예 : &lt;code&gt;[]&lt;/code&gt; ) 으로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="43f3c91605c9cb6d680c0ea9cf4c1bb2e77b4d9d" translate="yes" xml:space="preserve">
          <source>To disable interactive logins, displaying a greeting instead:</source>
          <target state="translated">대화 형 로그인을 비활성화하려면 인사말을 대신 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="2e78622c40c98dec97477af783b12ba20d12cc1a" translate="yes" xml:space="preserve">
          <source>To display the &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; man page, use &lt;code&gt;git help git&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 매뉴얼 페이지 를 표시하려면 &lt;code&gt;git help git&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa4dddf358b16e56494c90923230fd025e6f958d" translate="yes" xml:space="preserve">
          <source>To do automatic tag object dereferencing, use the &quot;-d&quot; or &quot;--dereference&quot; flag, so you can do</source>
          <target state="translated">자동 태그 객체 역 참조를 수행하려면 &quot;-d&quot;또는 &quot;--dereference&quot;플래그를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dc05ce874d6baee1eae11d94d6fd56f1e0a6d0ed" translate="yes" xml:space="preserve">
          <source>To do the merge, do</source>
          <target state="translated">병합을 수행하려면</target>
        </trans-unit>
        <trans-unit id="45ed93b09b65e276ec2ef33a1d9d7c3e10d14bfe" translate="yes" xml:space="preserve">
          <source>To do this, the current maintenance branch is copied to another branch named with the previous release version number (e.g. maint-X.Y.(Z-1) where X.Y.Z is the current release).</source>
          <target state="translated">이를 위해 현재 유지 보수 분기가 이전 릴리스 버전 번호로 이름 지정된 다른 분기 (예 : XYZ가 현재 릴리스 인 maint-XY (Z-1))로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="380aa6a091a04ad8bbf89399d1982760e370374e" translate="yes" xml:space="preserve">
          <source>To drop a commit, replace the command &quot;pick&quot; with &quot;drop&quot;, or just delete the matching line.</source>
          <target state="translated">커밋을 삭제하려면 &quot;pick&quot;명령을 &quot;drop&quot;으로 바꾸거나 일치하는 행을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="e05b8854f808624747710c5e1d641ee4dabaf30c" translate="yes" xml:space="preserve">
          <source>To elaborate, &quot;reading&quot; means checking for file existence, reading file attributes or file content. The working directory version may be present or absent. If present, its content may match against the index version or not. Writing is not affected by this bit, content safety is still first priority. Note that Git &lt;code&gt;can&lt;/code&gt; update working directory file, that is marked skip-worktree, if it is safe to do so (i.e. working directory version matches index version)</source>
          <target state="translated">자세히 설명하면 &quot;읽기&quot;는 파일 존재 여부 확인, 파일 속성 또는 파일 내용 읽기를 의미합니다. 작업 디렉토리 버전이 있거나 없을 수 있습니다. 존재하는 경우 해당 컨텐츠가 인덱스 버전과 일치하거나 일치하지 않을 수 있습니다. 쓰기는이 비트의 영향을받지 않으며 콘텐츠 안전이 여전히 최우선 순위입니다. 망할 놈의 것을 참고 &lt;code&gt;can&lt;/code&gt; 안전한 경우, 스킵 - worktree 표시되어 작업 디렉토리의 파일을 업데이트합니다 (즉, 디렉토리 버전을 작업하는 인덱스 버전과 일치)</target>
        </trans-unit>
        <trans-unit id="64ecd7272d648bbcdba5e527a1a80e43cb0705c5" translate="yes" xml:space="preserve">
          <source>To enable &lt;code&gt;git archive --remote&lt;/code&gt; and disable &lt;code&gt;git fetch&lt;/code&gt; against a repository, have the following in the configuration file in the repository (that is the file &lt;code&gt;config&lt;/code&gt; next to &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;refs&lt;/code&gt; and &lt;code&gt;objects&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;git archive --remote&lt;/code&gt; 를 활성화 하고 리포지토리에 대해 &lt;code&gt;git fetch&lt;/code&gt; 를 비활성화 하려면 리포지토리의 구성 파일 ( &lt;code&gt;HEAD&lt;/code&gt; , &lt;code&gt;refs&lt;/code&gt; 및 &lt;code&gt;objects&lt;/code&gt; 옆에 있는 파일 &lt;code&gt;config&lt;/code&gt; 다음 이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="af7d8457fff28a2087e0f74bc51d0468026a9bff" translate="yes" xml:space="preserve">
          <source>To enable a target, set the corresponding environment variable or system or global config value to one of the following:</source>
          <target state="translated">대상을 사용하려면 해당 환경 변수 또는 시스템 또는 전역 구성 값을 다음 중 하나로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="01e6eac26c3bbc386ab13c8cd6a9167801f24836" translate="yes" xml:space="preserve">
          <source>To enable anonymous read access but authenticated write access, require authorization for both the initial ref advertisement (which we detect as a push via the service parameter in the query string), and the receive-pack invocation itself:</source>
          <target state="translated">익명 읽기 액세스와 인증 된 쓰기 액세스를 사용하려면 초기 참조 광고 (조회 문자열에서 서비스 매개 변수를 통한 푸시로 감지) 및 수신 팩 호출 자체에 대한 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9bda367b82f8881561a1128afb27f36988891c35" translate="yes" xml:space="preserve">
          <source>To enable anonymous read access but authenticated write access:</source>
          <target state="translated">익명 읽기 액세스를 허용하지만 인증 된 쓰기 액세스를 활성화하려면</target>
        </trans-unit>
        <trans-unit id="050d5472dcd3f05f019f9a8129d0bb6d5e205df8" translate="yes" xml:space="preserve">
          <source>To enable blame, pickaxe search, and snapshot support (allowing &quot;tar.gz&quot; and &quot;zip&quot; snapshots), while allowing individual projects to turn them off, put the following in your GITWEB_CONFIG file:</source>
          <target state="translated">비난, 곡괭이 검색 및 스냅 샷 지원 ( &quot;tar.gz&quot;및 &quot;zip&quot;스냅 샷 허용)을 활성화하고 개별 프로젝트에서 끌 수 있도록하려면 GITWEB_CONFIG 파일에 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="fa7174e314ce7012972664ac5bcf82d4b390a6d5" translate="yes" xml:space="preserve">
          <source>To enable git-cvsserver access (which should generally have the &lt;code&gt;no-interactive-login&lt;/code&gt; example above as a prerequisite, as creating the git-shell-commands directory allows interactive logins):</source>
          <target state="translated">git-cvsserver 액세스를 활성화하려면 ( git-shell-commands 디렉토리를 만들면 &lt;code&gt;no-interactive-login&lt;/code&gt; 이 가능하므로 일반적으로 위 의 no-interactive-login 예제가 전제 조건으로 있어야 함) :</target>
        </trans-unit>
        <trans-unit id="69aa803d2928631745bb26ea6d720a34de175dd7" translate="yes" xml:space="preserve">
          <source>To enable that additional nice feature, when a bisection is started and when some good commits are not ancestors of the bad commit, we first compute the merge bases between the bad and the good commits and we chose these merge bases as the first commits that will be checked out and tested.</source>
          <target state="translated">추가 멋진 기능을 사용하기 위해, bisection이 시작될 때와 일부 좋은 commit이 bad commit의 조상이 아닌 경우, 먼저 bad와 good commit 사이의 병합 기준을 계산하고 이러한 병합 기준을 첫 번째 확약으로 선택합니다. 체크 아웃하고 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="ba44f6ad0a0230b79b3149aabc029b57fd7f22d9" translate="yes" xml:space="preserve">
          <source>To enable the sparse-checkout feature, run &lt;code&gt;git sparse-checkout init&lt;/code&gt; to initialize a simple sparse-checkout file and enable the &lt;code&gt;core.sparseCheckout&lt;/code&gt; config setting. Then, run &lt;code&gt;git sparse-checkout set&lt;/code&gt; to modify the patterns in the sparse-checkout file.</source>
          <target state="translated">스파 스 체크 아웃 기능을 활성화하려면 &lt;code&gt;git sparse-checkout init&lt;/code&gt; 를 실행 하여 간단한 스파 스 체크 아웃 파일을 초기화하고 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 구성 설정을 활성화하십시오 . 그런 다음 &lt;code&gt;git sparse-checkout set&lt;/code&gt; 를 실행 하여 sparse-checkout 파일의 패턴을 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="1318b73efc503f41a06d5d140c646ee25cf7e427" translate="yes" xml:space="preserve">
          <source>To exclude commits reachable from a commit, a prefix &lt;code&gt;^&lt;/code&gt; notation is used. E.g. &lt;code&gt;^r1 r2&lt;/code&gt; means commits reachable from &lt;code&gt;r2&lt;/code&gt; but exclude the ones reachable from &lt;code&gt;r1&lt;/code&gt; (i.e. &lt;code&gt;r1&lt;/code&gt; and its ancestors).</source>
          <target state="translated">커밋에서 도달 가능한 커밋을 제외하기 위해 접두사 &lt;code&gt;^&lt;/code&gt; 표기법이 사용됩니다. 예 &lt;code&gt;^r1 r2&lt;/code&gt; 수단의 커밋에서 도달 &lt;code&gt;r2&lt;/code&gt; 하지만 사람이에서 접근 제외 &lt;code&gt;r1&lt;/code&gt; (즉, &lt;code&gt;r1&lt;/code&gt; 과 그 조상).</target>
        </trans-unit>
        <trans-unit id="a12d809ea9b20c2b561957b059e3fe943cb6e440" translate="yes" xml:space="preserve">
          <source>To find out how the result can be used, just read on in &lt;code&gt;cmd_cat_file()&lt;/code&gt;:</source>
          <target state="translated">결과 사용 방법을 알아 보려면 &lt;code&gt;cmd_cat_file()&lt;/code&gt; 에서 계속 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="338cdf0c3d82152dc96e1eae9cd9922bf736e76c" translate="yes" xml:space="preserve">
          <source>To get a checkout with the Eclipse CVS client:</source>
          <target state="translated">Eclipse CVS 클라이언트로 체크 아웃하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="976f859125db1311d8f82bb8df703ef2ad537fd0" translate="yes" xml:space="preserve">
          <source>To get a reminder of the currently used terms, use</source>
          <target state="translated">현재 사용 된 용어를 상기시키기 위해</target>
        </trans-unit>
        <trans-unit id="68b714c59ff5898ff58433a2938d52aeb27df43e" translate="yes" xml:space="preserve">
          <source>To get started with gitweb, run &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; from a Git repository. This would configure and start your web server, and run web browser pointing to gitweb.</source>
          <target state="translated">gitweb을 시작하려면 Git 리포지토리에서 &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt; 을 실행하십시오 . 이것은 웹 서버를 구성하고 시작하고 gitweb을 가리키는 웹 브라우저를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="bf62a03860b36b4b6a615592146052d88035a5f4" translate="yes" xml:space="preserve">
          <source>To get the &quot;base&quot; for the merge, look up the common parent of two commits:</source>
          <target state="translated">병합의 &quot;기본&quot;을 얻으려면 두 커밋의 공통 부모를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="ec1f343ca45777aa33e95b7222bfb7658aa36062" translate="yes" xml:space="preserve">
          <source>To get the feature/bugfix into an integration branch, simply merge it. If the topic has evolved further in the meantime, merge again. (Note that you do not necessarily have to merge it to the oldest integration branch first. For example, you can first merge a bugfix to &lt;code&gt;next&lt;/code&gt;, give it some testing time, and merge to &lt;code&gt;maint&lt;/code&gt; when you know it is stable.)</source>
          <target state="translated">기능 / 버그 픽스를 통합 브랜치로 가져 오려면 간단히 병합하십시오. 그 동안 주제가 더 발전한 경우 다시 병합하십시오. (가장 오래된 통합 브랜치에 먼저 병합 할 필요는 없습니다. 예를 들어, 먼저 버그 수정을 &lt;code&gt;next&lt;/code&gt; 에 병합하고 , 테스트 시간을 제공하고, 안정적인 것으로 판단되면 &lt;code&gt;maint&lt;/code&gt; 에 병합 할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="60ae758b58fc83602f1720fb9cc2f0f4fb30b090" translate="yes" xml:space="preserve">
          <source>To give some hard figures, we used to have an average report-to-fix cycle of 142.6 hours (according to our somewhat weird bug-tracker which just measures wall-clock time). Since we moved to Git, we&amp;rsquo;ve lowered that to 16.2 hours. Primarily because we can stay on top of the bug fixing now, and because everyone&amp;rsquo;s jockeying to get to fix bugs (we&amp;rsquo;re quite proud of how lazy we are to let Git find the bugs for us). Each new release results in ~40% fewer bugs (almost certainly due to how we now feel about writing tests).</source>
          <target state="translated">어려운 수치를 제공하기 위해 평균 시계 수정주기는 ​​142.6 시간이었습니다 (벽 시계 시간을 측정하는 다소 이상한 버그 추적기에 따라). Git으로 옮긴 이후 16.2 시간으로 줄였습니다. 우리는 지금 버그 수정을 계속 할 수 있고 모든 사람들이 버그를 고치려고 애 쓰고 있기 때문에 (Git에서 버그를 찾게하는 것이 얼마나 게으른 지 자랑스럽게 생각합니다). 새로 출시 될 때마다 버그가 약 40 % 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="cc855cb566c405d222e3a3236275bbad376833c3" translate="yes" xml:space="preserve">
          <source>To help with that, &lt;code&gt;range&lt;/code&gt; uses the &lt;code&gt;--dual-color&lt;/code&gt; mode by default. In this mode, the diff of diffs will retain the original diff colors, and prefix the lines with -/+ markers that have their &lt;strong&gt;background&lt;/strong&gt; red or green, to make it more obvious that they describe how the diff itself changed.</source>
          <target state="translated">이를 돕기 위해 &lt;code&gt;range&lt;/code&gt; 는 기본적으로 &lt;code&gt;--dual-color&lt;/code&gt; 모드를 사용합니다 . 이 모드에서 diff diff는 원래 diff 색상을 유지하고 선이 &lt;strong&gt;배경이&lt;/strong&gt; 빨간색 또는 녹색 인 -/ + 마커로 접두어 diff 자체가 어떻게 바뀌 었는지 더 명확하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="096c5d9029f3f58b2af501ec17fb5d42ac0f73fe" translate="yes" xml:space="preserve">
          <source>To illustrate the difference between &lt;code&gt;-S&amp;lt;regex&amp;gt; --pickaxe-regex&lt;/code&gt; and &lt;code&gt;-G&amp;lt;regex&amp;gt;&lt;/code&gt;, consider a commit with the following diff in the same file:</source>
          <target state="translated">차이점을 설명하기 &lt;code&gt;-S&amp;lt;regex&amp;gt; --pickaxe-regex&lt;/code&gt; 과 &lt;code&gt;-G&amp;lt;regex&amp;gt;&lt;/code&gt; A는 동일한 파일에서 다음과 DIFF 커밋 고려해</target>
        </trans-unit>
        <trans-unit id="e67d6de21feaa90def83753eb253a23faea561fa" translate="yes" xml:space="preserve">
          <source>To illustrate, suppose you are in a situation where someone develops a &lt;code&gt;subsystem&lt;/code&gt; branch, and you are working on a &lt;code&gt;topic&lt;/code&gt; that is dependent on this &lt;code&gt;subsystem&lt;/code&gt;. You might end up with a history like the following:</source>
          <target state="translated">예를 들어, 누군가 &lt;code&gt;subsystem&lt;/code&gt; 브랜치를 개발 하고이 &lt;code&gt;subsystem&lt;/code&gt; 종속 된 &lt;code&gt;topic&lt;/code&gt; 에 대해 작업하고 있다고 가정하십시오 . 다음과 같은 기록으로 끝날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a98d25733140cb4450fff563f123b0d4cafeb9f9" translate="yes" xml:space="preserve">
          <source>To interrupt the rebase (just like an &quot;edit&quot; command would do, but without cherry-picking any commit first), use the &quot;break&quot; command.</source>
          <target state="translated">rebase를 중단 시키려면 ( &quot;edit&quot;명령과 같지만 먼저 commit을 선택하지 않고) &quot;break&quot;명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f6408dba3913ebdb903fdfce1d68f1906d3e56f0" translate="yes" xml:space="preserve">
          <source>To look at only non-zero stages, use &lt;code&gt;--unmerged&lt;/code&gt; flag:</source>
          <target state="translated">0이 아닌 단계 만 &lt;code&gt;--unmerged&lt;/code&gt; 플래그를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b273f729e50c3bb1996889c896c925cce764cd8" translate="yes" xml:space="preserve">
          <source>To make it readable, we can tell &lt;code&gt;git diff-files&lt;/code&gt; to output the differences as a patch, using the &lt;code&gt;-p&lt;/code&gt; flag:</source>
          <target state="translated">읽을 수 있도록 &lt;code&gt;-p&lt;/code&gt; 플래그를 사용하여 &lt;code&gt;git diff-files&lt;/code&gt; 가 패치로 차이점을 출력하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5411ef1231b1da2dbabaf49f4348af685832f2f7" translate="yes" xml:space="preserve">
          <source>To move the whole tree into a subdirectory, or remove it from there:</source>
          <target state="translated">전체 트리를 서브 디렉토리로 이동 시키거나 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="9fef1883cb2bb53007927c93e3d8f7431145efad" translate="yes" xml:space="preserve">
          <source>To perform a three-way merge, you start with the two commits you want to merge, find their closest common parent (a third commit), and compare the trees corresponding to these three commits.</source>
          <target state="translated">3 방향 병합을 수행하려면 병합하려는 두 커밋으로 시작하여 가장 가까운 공통 상위 (세 번째 커밋)를 찾은 다음이 세 커밋에 해당하는 트리를 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="a35f3e8a10774da4c0b0f3f87118660d7ef9889e" translate="yes" xml:space="preserve">
          <source>To place a higher stage entry to the index, the path should first be removed by feeding a mode=0 entry for the path, and then feeding necessary input lines in the third format.</source>
          <target state="translated">인덱스에 더 높은 단계 항목을 배치하려면 먼저 경로에 mode = 0 항목을 공급 한 다음 필요한 입력 행을 세 번째 형식으로 공급하여 경로를 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="26b0cbf1bc1090821ae6f59cac15f02ec7f562f8" translate="yes" xml:space="preserve">
          <source>To prepare for working on &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;, switch to it by updating the index and the files in the working tree, and by pointing &lt;code&gt;HEAD&lt;/code&gt; at the branch. Local modifications to the files in the working tree are kept, so that they can be committed to the &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 작업을 준비하려면 작업 트리에서 색인과 파일을 업데이트 하고 분기에서 &lt;code&gt;HEAD&lt;/code&gt; 를 가리켜 서 해당 지점으로 전환하십시오. 작업 트리의 파일에 대한 로컬 수정은 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 에 커밋 될 수 있도록 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="13739c43ac679e23fc4c2d09478ac31e5293cb15" translate="yes" xml:space="preserve">
          <source>To pretend you have a file at path with mode and sha1, say:</source>
          <target state="translated">mode 및 sha1을 사용하여 경로에 파일이 있다고 가정하려면 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="6785e6ba620455f331d4a09eb8363e2600eabf25" translate="yes" xml:space="preserve">
          <source>To prevent a $GIT_DIR/worktrees entry from being pruned (which can be useful in some situations, such as when the entry&amp;rsquo;s working tree is stored on a portable device), use the &lt;code&gt;git worktree lock&lt;/code&gt; command, which adds a file named &lt;code&gt;locked&lt;/code&gt; to the entry&amp;rsquo;s directory. The file contains the reason in plain text. For example, if a linked working tree&amp;rsquo;s &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; then a file named &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; will prevent the &lt;code&gt;test-next&lt;/code&gt; entry from being pruned. See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; for details.</source>
          <target state="translated">달러 (A $) GIT_DIR을 방지하기 위해 / (예 : 항목의 작업 트리가 휴대용 장치에 저장 될 때와 같은 일부 상황에서 유용 할 수 있습니다) 정리되는 항목, 사용 worktrees &lt;code&gt;git worktree lock&lt;/code&gt; 라는 이름의 파일 추가 명령, &lt;code&gt;locked&lt;/code&gt; 받는 사람을 항목의 디렉토리. 파일에는 이유가 일반 텍스트로 포함되어 있습니다. 링크 된 작업 트리의 예를 들어, &lt;code&gt;.git&lt;/code&gt; 파일 포인트가 &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; 다음라는 파일 &lt;code&gt;/path/main/.git/worktrees/test-next/locked&lt;/code&gt; 은 방지 할 수 있습니다 &lt;code&gt;test-next&lt;/code&gt; 정리되는 다음 항목. 자세한 내용은 &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="46ac404b2baca4d3a659bb0594db0c41828389ed" translate="yes" xml:space="preserve">
          <source>To prevent these unnecessary merge conflicts, Git can be told to run a virtual check-out and check-in of all three stages of a file when resolving a three-way merge by setting the &lt;code&gt;merge.renormalize&lt;/code&gt; configuration variable. This prevents changes caused by check-in conversion from causing spurious merge conflicts when a converted file is merged with an unconverted file.</source>
          <target state="translated">이러한 불필요한 병합 충돌을 방지하기 위해, Git은 &lt;code&gt;merge.renormalize&lt;/code&gt; 구성 변수를 설정하여 3 방향 병합을 해결할 때 파일의 3 단계 모두에서 가상 체크 아웃 및 체크인을 실행하도록 지시 할 수 있습니다 . 이렇게하면 변환 된 파일이 변환되지 않은 파일과 병합 될 때 체크인 변환으로 인한 변경으로 인해 가짜 병합 충돌이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="91d260766aee213709a415223ac206b93100d7d5" translate="yes" xml:space="preserve">
          <source>To prune objects not used by your repository or another that borrows from your repository via its &lt;code&gt;.git/objects/info/alternates&lt;/code&gt;:</source>
          <target state="translated">저장소 또는 &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; 를 통해 저장소에서 빌린 다른 오브젝트에서 사용하지 않는 오브젝트를 제거하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f63f42b98c259e7fd0384dd68939f7fc302c5eb" translate="yes" xml:space="preserve">
          <source>To prune references as part of your normal workflow without needing to remember to run that, set &lt;code&gt;fetch.prune&lt;/code&gt; globally, or &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; per-remote in the config. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">참조를 실행하지 않아도 정상 워크 플로우의 일부로 참조를 제거하려면 구성에서 &lt;code&gt;fetch.prune&lt;/code&gt; 을 전체적으로 설정 하거나 &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; 를 원격으로 설정하십시오. &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="68bfae2792009c9d944a67bd77b4854e1c8c4d3e" translate="yes" xml:space="preserve">
          <source>To put the loose objects into a pack, just run git repack:</source>
          <target state="translated">느슨한 객체를 팩에 넣으려면 git repack을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8344caf5b982f9b0d4dc99f7ff5aa708ff0b3592" translate="yes" xml:space="preserve">
          <source>To query the value for a given key, do</source>
          <target state="translated">주어진 키의 값을 쿼리하려면</target>
        </trans-unit>
        <trans-unit id="6d7c1598e59e901d58d9b961c14fa449c82ef069" translate="yes" xml:space="preserve">
          <source>To reapply a series of changes from a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; to a different base, and reset the &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt; of that branch to the result.</source>
          <target state="translated">&lt;a href=&quot;#def_branch&quot;&gt;분기&lt;/a&gt; 에서 다른베이스 로 일련의 변경 사항을 다시 적용하고 해당 분기 의 &lt;a href=&quot;#def_head&quot;&gt;헤드&lt;/a&gt; 를 결과로 재설정합니다 .</target>
        </trans-unit>
        <trans-unit id="25388a0bc929e9a0e4d2bb9d4d113e8444bb02a5" translate="yes" xml:space="preserve">
          <source>To remove a file from the index and from the working tree, use</source>
          <target state="translated">색인과 작업 트리에서 파일을 제거하려면</target>
        </trans-unit>
        <trans-unit id="c7850646e909d85f101794190a2e6f7a699e3e90" translate="yes" xml:space="preserve">
          <source>To remove commits authored by &quot;Darl McBribe&quot; from the history:</source>
          <target state="translated">히스토리에서 &quot;Darl McBribe&quot;가 작성한 커밋을 제거하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="65692943c43d72ea453917ea884fccf3994fb56e" translate="yes" xml:space="preserve">
          <source>To remove selection, prefix the input with &lt;code&gt;-&lt;/code&gt; like this:</source>
          <target state="translated">선택을 제거하려면, 입력과 앞에 &lt;code&gt;-&lt;/code&gt; 이 같은를 :</target>
        </trans-unit>
        <trans-unit id="9e91a512899aa79b93af123e6b1768a526248346" translate="yes" xml:space="preserve">
          <source>To repopulate the working directory with all files, use the &lt;code&gt;git sparse-checkout disable&lt;/code&gt; command.</source>
          <target state="translated">모든 파일로 작업 디렉토리를 다시 채우려면 &lt;code&gt;git sparse-checkout disable&lt;/code&gt; 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5c497720a7ab3ae3ef408305ef475289bc14a521" translate="yes" xml:space="preserve">
          <source>To reproduce the entire p4 history in Git, use the &lt;code&gt;@all&lt;/code&gt; modifier on the depot path:</source>
          <target state="translated">Git에서 전체 p4 히스토리를 재현하려면 저장소 경로 에서 &lt;code&gt;@all&lt;/code&gt; 수정자를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4609928d728916d052df2a3b481b65890e4b16e" translate="yes" xml:space="preserve">
          <source>To require authentication for both reads and writes, use a Location directive around the repository, or one of its parent directories:</source>
          <target state="translated">읽기 및 쓰기 모두에 대한 인증을 요구하려면 저장소 또는 해당 상위 디렉토리 중 하나에 Location 지시문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="10ebfb5ceb771c952eff2c39be3b852f1f654421" translate="yes" xml:space="preserve">
          <source>To require authentication for both reads and writes:</source>
          <target state="translated">읽기와 쓰기 모두에 대한 인증이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="847928f545abee25f9f8e4e2cc396a049af86735" translate="yes" xml:space="preserve">
          <source>To restore a file in the index to match the version in &lt;code&gt;HEAD&lt;/code&gt; (this is the same as using &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 의 버전과 일치하도록 색인의 파일을 복원하려면 ( &lt;a href=&quot;git-reset&quot;&gt;git-reset [1]&lt;/a&gt; 사용과 동일 )</target>
        </trans-unit>
        <trans-unit id="21366b05c441f538e6886570018737e901640e49" translate="yes" xml:space="preserve">
          <source>To restore all files in the current directory</source>
          <target state="translated">현재 디렉토리의 모든 파일을 복원하려면</target>
        </trans-unit>
        <trans-unit id="0ab7e14988a23edeb341648ca7b63377b3dd49d2" translate="yes" xml:space="preserve">
          <source>To restrict rewriting to only part of the history, specify a revision range in addition to the new branch name. The new branch name will point to the top-most revision that a &lt;code&gt;git rev-list&lt;/code&gt; of this range will print.</source>
          <target state="translated">기록의 일부로 만 다시 쓰기를 제한하려면 새 분기 이름 외에 개정 범위를 지정하십시오. 새 분기 이름은 이 범위 의 &lt;code&gt;git rev-list&lt;/code&gt; 가 인쇄 할 최상위 개정을 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="4d880d7fd779c619b85e62692eb083b5f59e932e" translate="yes" xml:space="preserve">
          <source>To rewrite commits E,F,G,H, use one of these:</source>
          <target state="translated">커밋 E, F, G, H를 다시 ​​쓰려면 다음 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="47b66273feb1f496168989ebee433bebb314fc85" translate="yes" xml:space="preserve">
          <source>To rewrite only commits D,E,F,G,H, but leave A, B and C alone, use:</source>
          <target state="translated">D, E, F, G, H 만 커밋하고 A, B 및 C는 그대로 두려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8c31d9c011b7c86062de888fb92cc01426b53584" translate="yes" xml:space="preserve">
          <source>To rewrite the repository to look as if &lt;code&gt;foodir/&lt;/code&gt; had been its project root, and discard all other history:</source>
          <target state="translated">&lt;code&gt;foodir/&lt;/code&gt; 가 프로젝트 루트 인 것처럼 보이도록 저장소를 다시 작성하고 다른 모든 히스토리를 삭제하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7c02b2b350476c8c24e25173b62f35a8ad0c0ae3" translate="yes" xml:space="preserve">
          <source>To see how submodule support works, create four example repositories that can be used later as a submodule:</source>
          <target state="translated">하위 모듈 지원 작동 방식을 보려면 나중에 하위 모듈로 사용할 수있는 네 가지 예제 리포지토리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="700bc56e5656b835e5cd7fa2e5386957dfc66eac" translate="yes" xml:space="preserve">
          <source>To see the currently remaining suspects in &lt;code&gt;gitk&lt;/code&gt;, issue the following command during the bisection process (the subcommand &lt;code&gt;view&lt;/code&gt; can be used as an alternative to &lt;code&gt;visualize&lt;/code&gt;):</source>
          <target state="translated">&lt;code&gt;gitk&lt;/code&gt; 에서 현재 남아있는 용의자를 보려면 이분법 프로세스 중에 다음 명령을 실행하십시오 (하위 명령 &lt;code&gt;view&lt;/code&gt; 는를 &lt;code&gt;visualize&lt;/code&gt; 하는 대안으로 사용할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="faa509deef7fcd4d518cc2cd2e577046b7eb747b" translate="yes" xml:space="preserve">
          <source>To see whether it has already been merged into the test or release branches, use:</source>
          <target state="translated">테스트 또는 릴리스 브랜치에 이미 병합되었는지 확인하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1e15ca1368deb202f467e491af7bfdb38f930af4" translate="yes" xml:space="preserve">
          <source>To serve gitweb at the same url, use a ScriptAliasMatch to only those URLs that &lt;code&gt;git http-backend&lt;/code&gt; can handle, and forward the rest to gitweb:</source>
          <target state="translated">동일한 URL에서 gitweb을 제공하려면 &lt;code&gt;git http-backend&lt;/code&gt; 가 처리 할 수 있는 URL에만 ScriptAliasMatch를 사용 하고 나머지는 gitweb에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="3b5c2b799f6b39d60aa882699fc88e3eb3a77175" translate="yes" xml:space="preserve">
          <source>To serve multiple repositories from different &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; in a single repository:</source>
          <target state="translated">단일 저장소 에서 다른 &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]의&lt;/a&gt; 여러 저장소를 제공하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="59fa97f902b7761eca14600ff37aff1758dec6bd" translate="yes" xml:space="preserve">
          <source>To set a commit (which typically is at the tip of another history) to be the parent of the current initial commit, in order to paste the other history behind the current history:</source>
          <target state="translated">다른 히스토리를 현재 히스토리 뒤에 붙여 넣기 위해 커미트 (일반적으로 다른 히스토리의 끝에 있음)를 현재 초기 커미트의 상위로 설정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d091c25539483b5c5b3db274eae656a5f768704a" translate="yes" xml:space="preserve">
          <source>To set the date used in future tag objects, set the environment variable GIT_COMMITTER_DATE (see the later discussion of possible values; the most common form is &quot;YYYY-MM-DD HH:MM&quot;).</source>
          <target state="translated">향후 태그 객체에 사용되는 날짜를 설정하려면 환경 변수 GIT_COMMITTER_DATE를 설정하십시오 (가능한 값에 대해서는 나중에 설명합니다. 가장 일반적인 형식은 &quot;YYYY-MM-DD HH : MM&quot;).</target>
        </trans-unit>
        <trans-unit id="0de4847876d8ab04ebb463613f39507d60c3b1a3" translate="yes" xml:space="preserve">
          <source>To set this up, first create your work tree by cloning Linus&amp;rsquo;s public tree:</source>
          <target state="translated">이를 설정하려면 먼저 Linus의 공용 트리를 복제하여 작업 트리를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="6fdb47a7575f286ad7a6b8b651d8470ef2c51c01" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as a regular, non-inetd service that handles repositories for multiple virtual hosts based on their IP addresses, start the daemon like this:</source>
          <target state="translated">&lt;code&gt;git daemon&lt;/code&gt; 을 IP 주소를 기반으로 여러 가상 호스트의 리포지토리를 처리하는 비정규 일반 서비스로 설정하려면 다음 과 같이 데몬을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="cd4e85b93c0b5a71d973a240463742c429d6ce10" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as an inetd service that handles any repository under the whitelisted set of directories, /pub/foo and /pub/bar, place an entry like the following into /etc/inetd all on one line:</source>
          <target state="translated">설정하려면 &lt;code&gt;git daemon&lt;/code&gt; 핸들 디렉토리 / 주점 / foo는의 허용 된 세트에서 모든 저장소 및 / 술집 / 바의 등 /에 다음과 같은 항목을 배치하는 것이 inetd를 서비스로 / 한 줄에 모든 inetd를</target>
        </trans-unit>
        <trans-unit id="d85d4c6ac447e3ea7881a95ee3354b641502c913" translate="yes" xml:space="preserve">
          <source>To set up &lt;code&gt;git daemon&lt;/code&gt; as an inetd service that handles repositories for different virtual hosts, &lt;code&gt;www.example.com&lt;/code&gt; and &lt;code&gt;www.example.org&lt;/code&gt;, place an entry like the following into &lt;code&gt;/etc/inetd&lt;/code&gt; all on one line:</source>
          <target state="translated">다른 가상 호스트 ( &lt;code&gt;www.example.com&lt;/code&gt; 및 &lt;code&gt;www.example.org&lt;/code&gt; )의 저장소를 처리하는 inetd 서비스로 &lt;code&gt;git daemon&lt;/code&gt; 을 설정하려면 &lt;code&gt;/etc/inetd&lt;/code&gt; 에 다음과 같은 항목을 모두 한 줄로 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="6d1dfa06a0b2e0253dac9a23d3e763ff2be4729c" translate="yes" xml:space="preserve">
          <source>To shelve changes instead of submitting, use &lt;code&gt;--shelve&lt;/code&gt; and &lt;code&gt;--update-shelve&lt;/code&gt;:</source>
          <target state="translated">제출하는 대신 변경 사항을 보류하려면 &lt;code&gt;--shelve&lt;/code&gt; 및 &lt;code&gt;--update-shelve&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b19251adc869dd31b98316a2df3ca3e146f58f68" translate="yes" xml:space="preserve">
          <source>To show all references called &quot;master&quot;, whether tags or heads or anything else, and regardless of how deep in the reference naming hierarchy they are, use:</source>
          <target state="translated">태그 또는 헤드 또는 기타 항목에 관계없이 &quot;마스터&quot;라는 모든 참조를 표시하고 참조 명명 계층 구조의 깊이에 관계없이 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="51ec81ccf2337a76aefa897308cd08d96e515614" translate="yes" xml:space="preserve">
          <source>To show only tags, or only proper branch heads, use &quot;--tags&quot; and/or &quot;--heads&quot; respectively (using both means that it shows tags and heads, but not other random references under the refs/ subdirectory).</source>
          <target state="translated">태그 또는 적절한 분기 헤드 만 표시하려면 &quot;--tags&quot;및 / 또는 &quot;--heads&quot;를 각각 사용하십시오 (두 태그를 모두 사용하면 태그 및 헤드가 표시되지만 refs / 하위 디렉토리 아래의 다른 임의 참조는 표시되지 않음).</target>
        </trans-unit>
        <trans-unit id="864f9f1ee17e37f4b3823291b8524eebd5879fc4" translate="yes" xml:space="preserve">
          <source>To show that as an example, let&amp;rsquo;s go back to the git-tutorial repository we used earlier, and create a branch in it. You do that by simply just saying that you want to check out a new branch:</source>
          <target state="translated">이를 예제로 보여주기 위해 앞에서 사용한 git-tutorial repository로 돌아가서 분기를 만듭니다. 새 지점을 확인하고 싶다고 말하면됩니다.</target>
        </trans-unit>
        <trans-unit id="acab411fa1b0a4e2f72e42b537e21a4bc08bf613" translate="yes" xml:space="preserve">
          <source>To simplify the discussion we will suppose that the untestable area is a simple string of commits and that it was created by a breakage introduced by one commit (let&amp;rsquo;s call it BBC for bisect breaking commit) and later fixed by another one (let&amp;rsquo;s call it BFC for bisect fixing commit).</source>
          <target state="translated">논의를 단순화하기 위해 우리는 테스트 할 수없는 영역이 단순한 커밋 문자열이고 한 커밋에 의해 도입 된 손상 (Brisct Break Commit을 위해 BBC라고 함)에서 나중에 다른 하나에 의해 수정되었다고 가정합니다 (BFC라고 함). 이등분 고정 커밋).</target>
        </trans-unit>
        <trans-unit id="975e3a9279c8287bca9f664bbcc61fee7baa93ca" translate="yes" xml:space="preserve">
          <source>To specify a branch other than the current one, use:</source>
          <target state="translated">현재 분기 이외의 분기를 지정하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b6b6e95c2c1acd4004bc280690d73f7c9df3e3b0" translate="yes" xml:space="preserve">
          <source>To specify a namespace, set the &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; environment variable to the namespace. For each ref namespace, Git stores the corresponding refs in a directory under &lt;code&gt;refs/namespaces/&lt;/code&gt;. For example, &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; will store refs under &lt;code&gt;refs/namespaces/foo/&lt;/code&gt;. You can also specify namespaces via the &lt;code&gt;--namespace&lt;/code&gt; option to &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;.</source>
          <target state="translated">네임 스페이스를 지정하려면 &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; 환경 변수를 네임 스페이스로 설정하십시오 . 각 참조 네임 스페이스에 대해 Git은 해당 참조를 &lt;code&gt;refs/namespaces/&lt;/code&gt; 아래의 디렉토리에 저장합니다 . 예를 들어 &lt;code&gt;GIT_NAMESPACE=foo&lt;/code&gt; 는 &lt;code&gt;refs/namespaces/foo/&lt;/code&gt; 아래에 ref 를 저장 합니다. &lt;code&gt;--namespace&lt;/code&gt; 옵션을 통해 &lt;a href=&quot;git&quot;&gt;git [1]에&lt;/a&gt; 네임 스페이스를 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d8e0463dddb070b083bcb1d31f0cd304bcae1a2" translate="yes" xml:space="preserve">
          <source>To specify a single commit or a range of commits, use:</source>
          <target state="translated">단일 커밋 또는 커밋 범위를 지정하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b6bdd73c5af990a9c308cb3582e6683a673000a9" translate="yes" xml:space="preserve">
          <source>To stop tracking a file that is currently tracked, use &lt;code&gt;git rm --cached&lt;/code&gt;.</source>
          <target state="translated">현재 추적되는 파일 추적을 중지하려면 &lt;code&gt;git rm --cached&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5aabd990937e7026d6c235ccca8da7a1bd54429f" translate="yes" xml:space="preserve">
          <source>To submit all changes that are in the current Git branch but not in the &lt;code&gt;p4/master&lt;/code&gt; branch, use:</source>
          <target state="translated">현재 Git 브랜치에 있지만 &lt;code&gt;p4/master&lt;/code&gt; 브랜치에는 없는 모든 변경 사항을 제출하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4d37523ff8334f7ae27e64b17d4088a430f024d8" translate="yes" xml:space="preserve">
          <source>To submit patches using GMail&amp;rsquo;s IMAP interface, first, edit your ~/.gitconfig to specify your account settings:</source>
          <target state="translated">GMail의 IMAP 인터페이스를 사용하여 패치를 제출하려면 먼저 ~ / .gitconfig를 편집하여 계정 설정을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="3829362b0206f78fb7e35755e5364f47036b822a" translate="yes" xml:space="preserve">
          <source>To support virtual hosting, an interpolated path template can be used to dynamically construct alternate paths. The template supports %H for the target hostname as supplied by the client but converted to all lowercase, %CH for the canonical hostname, %IP for the server&amp;rsquo;s IP address, %P for the port number, and %D for the absolute path of the named repository. After interpolation, the path is validated against the directory whitelist.</source>
          <target state="translated">가상 호스팅을 지원하기 위해 보간 경로 템플릿을 사용하여 대체 경로를 동적으로 구성 할 수 있습니다. 템플릿은 클라이언트가 제공 한 대상 호스트 이름에 대해 % H를 지원하지만 모든 소문자, 표준 호스트 이름에 대한 % CH, 서버의 IP 주소에 대한 % IP, 포트 번호에 대한 % P 및 절대 경로에 대한 % D로 변환됩니다. 명명 된 저장소 보간 후, 경로는 디렉토리 화이트리스트에 대해 검증됩니다.</target>
        </trans-unit>
        <trans-unit id="5c5bebcfb262219afa24ad57e1be9ff8017de145" translate="yes" xml:space="preserve">
          <source>To switch back to the previous branch before we switched to mytopic (i.e. &quot;master&quot; branch):</source>
          <target state="translated">mytopic (예 : &quot;마스터&quot;지점)으로 전환하기 전에 이전 지점으로 다시 전환하려면</target>
        </trans-unit>
        <trans-unit id="f604bfa9fc2a5e3a8b43aed4c26f0a58bfbd1e14" translate="yes" xml:space="preserve">
          <source>To tell Git that yes, you really do realize that certain files no longer exist, or that new files should be added, you should use the &lt;code&gt;--remove&lt;/code&gt; and &lt;code&gt;--add&lt;/code&gt; flags respectively.</source>
          <target state="translated">Git에게 특정 파일이 더 이상 존재하지 않거나 새로운 파일을 추가해야한다는 것을 실제로 인식하려면 &lt;code&gt;--remove&lt;/code&gt; 및 &lt;code&gt;--add&lt;/code&gt; 플래그를 각각 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f3c508cb95e621506ae6e931b2fdadcaba14a047" translate="yes" xml:space="preserve">
          <source>To test the interaction of several topics, merge them into a throw-away branch. You must never base any work on such a branch!</source>
          <target state="translated">여러 주제의 상호 작용을 테스트하려면 해당 주제를 폐기 지점으로 병합하십시오. 그러한 지점에 어떤 작업도하지 말아야합니다!</target>
        </trans-unit>
        <trans-unit id="ded44bb687bc8a448accbaa8cf09bc1b10b3ff71" translate="yes" xml:space="preserve">
          <source>To that end, it first finds pairs of commits from both commit ranges that correspond with each other. Two commits are said to correspond when the diff between their patches (i.e. the author information, the commit message and the commit diff) is reasonably small compared to the patches' size. See ``Algorithm`` below for details.</source>
          <target state="translated">이를 위해 먼저 서로 일치하는 두 커밋 범위에서 커밋 쌍을 찾습니다. 패치 사이의 차이 (즉, 작성자 정보, 커밋 메시지 및 커밋 차이)가 패치 크기에 비해 상당히 작을 때 두 개의 커밋이 해당한다고합니다. 자세한 내용은 아래의``알고리즘 ''을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="28b9a65cbb97d3af18835efd06d4d171278e0508" translate="yes" xml:space="preserve">
          <source>To throw away part of the development, i.e. to assign the &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt; to an earlier &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt;.</source>
          <target state="translated">개발의 일부를 버리는 것, 즉 &lt;a href=&quot;#def_head&quot;&gt;헤드&lt;/a&gt; 를 이전 &lt;a href=&quot;#def_revision&quot;&gt;개정판&lt;/a&gt; 에 할당 하는 것 .</target>
        </trans-unit>
        <trans-unit id="f2857b34f71a88c7afeb725363e4097e2e44ff45" translate="yes" xml:space="preserve">
          <source>To top it all off, even when users finally find working commands, they naturally want to share them. But they may be unaware that their repo didn&amp;rsquo;t have some special cases that someone else&amp;rsquo;s does. So, when someone else with a different repository runs the same commands, they get hit by the problems above. Or, the user just runs commands that really were vetted for special cases, but they run it on a different OS where it doesn&amp;rsquo;t work, as noted above.</source>
          <target state="translated">무엇보다도 사용자가 최종적으로 작업 명령을 찾더라도 자연스럽게 공유하기를 원합니다. 그러나 그들은 그들의 저장소에 다른 사람이하는 특별한 경우가 없다는 것을 알지 못할 수도 있습니다. 따라서 다른 리포지토리를 가진 다른 사람이 동일한 명령을 실행하면 위의 문제가 발생합니다. 또는 사용자는 특별한 경우에 실제로 심사 된 명령 만 실행하지만 위에서 언급 한대로 작동하지 않는 다른 OS에서 실행합니다.</target>
        </trans-unit>
        <trans-unit id="c4d2ca21938c992db0b3b75cacfc935366e6629e" translate="yes" xml:space="preserve">
          <source>To update and refresh only the files already checked out</source>
          <target state="translated">이미 체크 아웃 한 파일 만 업데이트하고 새로 고치려면</target>
        </trans-unit>
        <trans-unit id="a8c26a487a2f6627cb1ef2fcc7d8934daa7b62d0" translate="yes" xml:space="preserve">
          <source>To update and refresh only the files already checked out:</source>
          <target state="translated">이미 체크 아웃 한 파일 만 업데이트하고 새로 고치려면</target>
        </trans-unit>
        <trans-unit id="ec65c1043e980aa5b1f1a444793e6e405a4b07fd" translate="yes" xml:space="preserve">
          <source>To update the index with the contents of a new or modified file, use</source>
          <target state="translated">새 파일 또는 수정 된 파일의 내용으로 색인을 업데이트하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="693fe77a3dea0f3b3cf2c4a884d12237d7043db5" translate="yes" xml:space="preserve">
          <source>To update the resulting mine.git repository, you can fetch or pull after replacing the bundle stored at /home/me/tmp/file.bundle with incremental updates.</source>
          <target state="translated">결과로 생성 된 mine.git 저장소를 업데이트하려면 /home/me/tmp/file.bundle에 저장된 번들을 증분 업데이트로 교체 한 후 가져 오거나 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7804c7379482ba8df4ffa8604001ea71fae1937a" translate="yes" xml:space="preserve">
          <source>To use &quot;old&quot; and &quot;new&quot; instead of &quot;good&quot; and bad, you must run &lt;code&gt;git
bisect start&lt;/code&gt; without commits as argument and then run the following commands to add the commits:</source>
          <target state="translated">&quot;good&quot;과 bad 대신 &quot;old&quot;와 &quot;new&quot;를 사용하려면 커밋없이 &lt;code&gt;git bisect start&lt;/code&gt; 를 인수로 실행 한 후 다음 명령을 실행하여 커밋을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="288cf0a04f95ab8d9b3cedc9a80bcb75e1eb91a6" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;git send-email&lt;/code&gt; to send your patches through the GMail SMTP server, edit ~/.gitconfig to specify your account settings:</source>
          <target state="translated">&lt;code&gt;git send-email&lt;/code&gt; 을 사용 하여 GMail SMTP 서버를 통해 패치를 보내려면 ~ / .gitconfig를 편집하여 계정 설정을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="b24b5140a04c50c5ab1f6a8bf4b67a65e4b08446" translate="yes" xml:space="preserve">
          <source>To use a helper, you must first select one to use. Git currently includes the following helpers:</source>
          <target state="translated">도우미를 사용하려면 먼저 사용할 도우미를 선택해야합니다. 힘내는 현재 다음과 같은 도우미를 포함합니다 :</target>
        </trans-unit>
        <trans-unit id="00e4f18d69f51ffe1eea42af728cb3d7bb0059ec" translate="yes" xml:space="preserve">
          <source>To use the tool, imap.folder and either imap.tunnel or imap.host must be set to appropriate values.</source>
          <target state="translated">도구를 사용하려면 imap.folder 및 imap.tunnel 또는 imap.host가 적절한 값으로 설정되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8b51a494019812910be0a147154b59e9ef1b84fa" translate="yes" xml:space="preserve">
          <source>To use this mode effectively, you have to make sure &lt;code&gt;all&lt;/code&gt; the branches you would push out are ready to be pushed out before running &lt;code&gt;git push&lt;/code&gt;, as the whole point of this mode is to allow you to push all of the branches in one go. If you usually finish work on only one branch and push out the result, while other branches are unfinished, this mode is not for you. Also this mode is not suitable for pushing into a shared central repository, as other people may add new branches there, or update the tip of existing branches outside your control.</source>
          <target state="translated">이 모드를 효과적으로 사용하려면 &lt;code&gt;git push&lt;/code&gt; 를 실행하기 전에 푸시하려는 &lt;code&gt;all&lt;/code&gt; 분기를 푸시 할 준비가 되었는지 확인해야 합니다 . 이 모드의 핵심은 모든 분기를 한 번에 푸시 할 수 있기 때문입니다. 일반적으로 한 지점에서만 작업을 마치고 결과를 내보내는 반면 다른 지점은 완료되지 않은 경우이 모드는 적합하지 않습니다. 또한이 모드는 다른 사람이 새 분기를 추가하거나 기존 분기의 끝을 제어 할 수 없으므로 공유 중앙 저장소로 푸시하는 데 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0db2ead5af506998515a70d6693b9cc78c43968a" translate="yes" xml:space="preserve">
          <source>To verify that &lt;code&gt;master&lt;/code&gt; is indeed a superset of &lt;code&gt;maint&lt;/code&gt;, use git log:</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 가 실제로 &lt;code&gt;maint&lt;/code&gt; 의 상위 집합인지 확인하려면 git log를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="25e07c07376edb7f994c3289d03610c1335d5288" translate="yes" xml:space="preserve">
          <source>Todo list</source>
          <target state="translated">할 일 목록</target>
        </trans-unit>
        <trans-unit id="44e89f12173f1b11f3c33dfcf393dbeb53d74231" translate="yes" xml:space="preserve">
          <source>Toggle the pre-push hook (see &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;). The default is --verify, giving the hook a chance to prevent the push. With --no-verify, the hook is bypassed completely.</source>
          <target state="translated">프리 푸시 후크를 토글합니다 ( &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 참조 ). 기본값은 --verify이며 후크는 푸시를 방지 할 수 있습니다. --no-verify를 사용하면 후크가 완전히 바이 패스됩니다.</target>
        </trans-unit>
        <trans-unit id="e69b3ac557eee7192f98b057069c2f145301ef39" translate="yes" xml:space="preserve">
          <source>Topic branches</source>
          <target state="translated">토픽 브랜치</target>
        </trans-unit>
        <trans-unit id="99011a3381da15bff0042576b0bb55bb6ae9ffd0" translate="yes" xml:space="preserve">
          <source>TortoiseCVS</source>
          <target state="translated">TortoiseCVS</target>
        </trans-unit>
        <trans-unit id="9732ce69da01051c0a62cf40cfeb5063ebcf5c22" translate="yes" xml:space="preserve">
          <source>Trace the evolution of the line range given by &quot;&amp;lt;start&amp;gt;,&amp;lt;end&amp;gt;&quot; (or the function name regex &amp;lt;funcname&amp;gt;) within the &amp;lt;file&amp;gt;. You may not give any pathspec limiters. This is currently limited to a walk starting from a single revision, i.e., you may only give zero or one positive revision arguments, and &amp;lt;start&amp;gt; and &amp;lt;end&amp;gt; (or &amp;lt;funcname&amp;gt;) must exist in the starting revision. You can specify this option more than once. Implies &lt;code&gt;--patch&lt;/code&gt;. Patch output can be suppressed using &lt;code&gt;--no-patch&lt;/code&gt;, but other diff formats (namely &lt;code&gt;--raw&lt;/code&gt;, &lt;code&gt;--numstat&lt;/code&gt;, &lt;code&gt;--shortstat&lt;/code&gt;, &lt;code&gt;--dirstat&lt;/code&gt;, &lt;code&gt;--summary&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt;, &lt;code&gt;--name-status&lt;/code&gt;, &lt;code&gt;--check&lt;/code&gt;) are not currently implemented.</source>
          <target state="translated">&amp;lt;file&amp;gt; 내에서 &quot;&amp;lt;start&amp;gt;, &amp;lt;end&amp;gt;&quot;(또는 함수 이름 regex &amp;lt;funcname&amp;gt;)로 지정된 행 범위의 진화를 추적하십시오. 경로 스펙 리미터를 제공 할 수 없습니다. 현재는 단일 개정에서 시작하여 도보로 제한됩니다. 즉, 0 또는 하나의 긍정적 개정 인수 만 제공 할 수 있으며 &amp;lt;start&amp;gt; 및 &amp;lt;end&amp;gt; (또는 &amp;lt;funcname&amp;gt;)가 시작 개정에 있어야합니다. 이 옵션을 두 번 이상 지정할 수 있습니다. &lt;code&gt;--patch&lt;/code&gt; 를 의미 합니다. &lt;code&gt;--no-patch&lt;/code&gt; 를 사용하여 패치 출력을 억제 할 수 있지만 다른 diff 형식 (즉 &lt;code&gt;--raw&lt;/code&gt; , &lt;code&gt;--numstat&lt;/code&gt; , &lt;code&gt;--shortstat&lt;/code&gt; , &lt;code&gt;--dirstat&lt;/code&gt; , &lt;code&gt;--summary&lt;/code&gt; , &lt;code&gt;--name-only&lt;/code&gt; , &lt;code&gt;--name-status&lt;/code&gt; , &lt;code&gt;--check&lt;/code&gt; )은 현재 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="324f1031e6064bf946ba7ad7de400c92a706ee71" translate="yes" xml:space="preserve">
          <source>Trace2 api</source>
          <target state="translated">Trace2 API</target>
        </trans-unit>
        <trans-unit id="f39bab439a6977ac76a84295e79b079d44b7d908" translate="yes" xml:space="preserve">
          <source>Trace2 config settings are only read from the system and global config files; repository local and worktree config files and &lt;code&gt;-c&lt;/code&gt; command line arguments are not respected.</source>
          <target state="translated">Trace2 구성 설정은 시스템 및 전역 구성 파일에서만 읽습니다. 저장소 로컬 및 작업 트리 구성 파일과 &lt;code&gt;-c&lt;/code&gt; 명령 행 인수는 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34f4d5fb2d35b898a8c6180c70ae5079360dafe0" translate="yes" xml:space="preserve">
          <source>Trace2 defines the following set of Trace2 Targets. Format details are given in a later section.</source>
          <target state="translated">Trace2는 다음과 같은 Trace2 대상 집합을 정의합니다. 형식 세부 사항은 다음 섹션에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9cffe01770c87380a0c500c2ba4c5fe9919c83ec" translate="yes" xml:space="preserve">
          <source>Trace2 instrumentation throughout the Git code base sends Trace2 messages to the enabled Trace2 Targets. Targets transform these messages content into purpose-specific formats and write events to their data streams. In this manner, the Trace2 API can drive many different types of analysis.</source>
          <target state="translated">Git 코드베이스 전체의 Trace2 계측은 Trace2 메시지를 활성화 된 Trace2 대상으로 보냅니다. 대상은 이러한 메시지 컨텐츠를 목적 별 형식으로 변환하고 이벤트를 데이터 스트림에 씁니다. 이러한 방식으로 Trace2 API는 다양한 유형의 분석을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="952dc6d60a810a50f48d84409a5ca3162f18abfc" translate="yes" xml:space="preserve">
          <source>Trace2 is controlled using &lt;code&gt;trace2.&lt;/code&gt; config values in the system and global config files and &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variables. Trace2 does not read from repo local or worktree config files or respect &lt;code&gt;-c&lt;/code&gt; command line config settings.</source>
          <target state="translated">Trace2는 &lt;code&gt;trace2.&lt;/code&gt; 사용하여 제어됩니다 . 시스템 및 전역 구성 파일의 구성 값과 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 환경 변수. Trace2는 repo 로컬 또는 워크 트리 구성 파일에서 읽지 않거나 &lt;code&gt;-c&lt;/code&gt; 명령 행 구성 설정을 존중하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="20f68aac372bbc56e3b5b3e96aea0079529bedb9" translate="yes" xml:space="preserve">
          <source>Trace2 regions are similar to the existing trace_performance_enter() and trace_performance_leave() routines, but are thread safe and maintain per-thread stacks of timers.</source>
          <target state="translated">Trace2 영역은 기존 trace_performance_enter () 및 trace_performance_leave () 루틴과 유사하지만 스레드 안전하고 스레드 별 타이머 스택을 유지 관리합니다.</target>
        </trans-unit>
        <trans-unit id="8bded73626b8544423d59c1c5a0c1bfb684cb12e" translate="yes" xml:space="preserve">
          <source>Trace2 target formats</source>
          <target state="translated">Trace2 대상 형식</target>
        </trans-unit>
        <trans-unit id="e4cb4d4e7e519744d1375eb303304baebc567ae9" translate="yes" xml:space="preserve">
          <source>Trace2 targets</source>
          <target state="translated">Trace2 대상</target>
        </trans-unit>
        <trans-unit id="a0cfb1f78b98054b282b0aab138d8ea25f2c82bd" translate="yes" xml:space="preserve">
          <source>Tracking and contributing to an entire Subversion-managed project (complete with a trunk, tags and branches):</source>
          <target state="translated">전체 Subversion 관리 프로젝트 추적 및 기여 (트렁크, 태그 및 브랜치로 완료) :</target>
        </trans-unit>
        <trans-unit id="847895b0cdb93b975e4c930f95d66dabeb1e64d2" translate="yes" xml:space="preserve">
          <source>Tracking and contributing to the trunk of a Subversion-managed project (ignoring tags and branches):</source>
          <target state="translated">Subversion 관리 프로젝트의 트렁크 추적 및 기여 (태그 및 분기 무시) :</target>
        </trans-unit>
        <trans-unit id="667c19a45142471c0c20cc605b683a6a3152afb1" translate="yes" xml:space="preserve">
          <source>Traditionally, tips of branches and tags (collectively known as &lt;code&gt;refs&lt;/code&gt;) were stored one file per ref in a (sub)directory under &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory. While many branch tips tend to be updated often, most tags and some branch tips are never updated. When a repository has hundreds or thousands of tags, this one-file-per-ref format both wastes storage and hurts performance.</source>
          <target state="translated">전통적으로 브랜치 및 태그 (통칭하여 &lt;code&gt;refs&lt;/code&gt; )의 팁은 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 디렉토리 아래의 (하위) 디렉토리에 ref 당 하나의 파일로 저장되었습니다 . 많은 분기 팁이 자주 업데이트되는 경향이 있지만 대부분의 태그 및 일부 분기 팁은 업데이트되지 않습니다. 리포지토리에 수백 또는 수천 개의 태그가있는 경우이 참조 당 하나의 파일 형식은 스토리지를 낭비하고 성능을 저하시킵니다.</target>
        </trans-unit>
        <trans-unit id="a5cf7db57e9cf074478d171148671cc677faf56a" translate="yes" xml:space="preserve">
          <source>Trailing spaces are ignored unless they are quoted with backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;).</source>
          <target state="translated">후행 공백은 백 슬래시 ( &quot; &lt;code&gt;\&lt;/code&gt; &quot;) 로 인용하지 않으면 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="18baa50eee1aac68104e16bd4ad94c661cde3869" translate="yes" xml:space="preserve">
          <source>Transfer size: In its current form Git requires the whole working tree present. It does not allow partial trees to be transferred in fetch or clone. If the project you work on consists of multiple repositories tied together as submodules in a superproject, you can avoid fetching the working trees of the repositories you are not interested in.</source>
          <target state="translated">전송 크기 : 현재 형태로 Git에는 전체 작업 트리가 필요합니다. 부분 트리를 페치 또는 복제로 전송할 수 없습니다. 작업중인 프로젝트가 수퍼 프로젝트에서 하위 모듈로 묶여있는 여러 저장소로 구성된 경우 관심없는 저장소의 작업 트리를 가져 오는 것을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdf6a912dffd18ed6042052fce8610d96ce56a71" translate="yes" xml:space="preserve">
          <source>Transform stdin by substituting all the 40-character SHA-1 hexes (say $hex) with &quot;$hex ($rev_name)&quot;. When used with --name-only, substitute with &quot;$rev_name&quot;, omitting $hex altogether. Intended for the scripter&amp;rsquo;s use.</source>
          <target state="translated">모든 40 자 SHA-1 헥스 (예 : $ hex)를 &quot;$ hex ($ rev_name)&quot;로 대체하여 stdin을 변환하십시오. --name-only와 함께 사용하는 경우 $ hex를 생략하고 &quot;$ rev_name&quot;으로 대체하십시오. 스크립터의 사용을 목적으로합니다.</target>
        </trans-unit>
        <trans-unit id="fc873c381aea0c960eb3ebd47773defb66d7e124" translate="yes" xml:space="preserve">
          <source>Transmit &amp;lt;string&amp;gt; as a push option. As the push option must not contain LF or NUL characters, the string is not encoded.</source>
          <target state="translated">&amp;lt;string&amp;gt;을 푸시 옵션으로 전송하십시오. push 옵션은 LF 또는 NUL 문자를 포함하지 않아야하므로 문자열이 인코딩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32bd61986aca00f68612950bbcdb4915d3d0e846" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. The server&amp;rsquo;s handling of server options, including unknown ones, is server-specific. When multiple &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line.</source>
          <target state="translated">프로토콜 버전 2를 사용하여 통신 할 때 지정된 문자열을 서버로 전송하십시오. 주어진 문자열에는 NUL 또는 LF 문자가 포함되어서는 안됩니다. 알 수없는 옵션을 포함하여 서버의 서버 옵션 처리는 서버마다 다릅니다. 여러 개의 &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; 이 제공되면 모두 명령 줄에 나열된 순서대로 다른쪽으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="39635a03df29b9789e505a1038590e24ea96c9e9" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server when communicating using protocol version 2. The given string must not contain a NUL or LF character. When multiple &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line.</source>
          <target state="translated">프로토콜 버전 2를 사용하여 통신 할 때 지정된 문자열을 서버로 전송하십시오. 주어진 문자열에는 NUL 또는 LF 문자가 포함되어서는 안됩니다. 여러 개의 &lt;code&gt;--server-option=&amp;lt;option&amp;gt;&lt;/code&gt; 이 제공되면 모두 명령 줄에 나열된 순서대로 다른쪽으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="2995fbcc2c84443582483713456b482a39b63e37" translate="yes" xml:space="preserve">
          <source>Transmit the given string to the server, which passes them to the pre-receive as well as the post-receive hook. The given string must not contain a NUL or LF character. When multiple &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; are given, they are all sent to the other side in the order listed on the command line. When no &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; is given from the command line, the values of configuration variable &lt;code&gt;push.pushOption&lt;/code&gt; are used instead.</source>
          <target state="translated">주어진 문자열을 서버로 전송하여 수신 후 후크뿐만 아니라 수신 후 후크로 전달합니다. 주어진 문자열은 NUL 또는 LF 문자를 포함해서는 안됩니다. 여러 개의 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; 이 제공되면 모두 명령 행에 나열된 순서대로 다른쪽으로 전송됩니다. 어떠한 경우 &lt;code&gt;--push-option=&amp;lt;option&amp;gt;&lt;/code&gt; 커맨드 라인에서 제공되지 않는 구성 변수의 값 &lt;code&gt;push.pushOption&lt;/code&gt; 가 대신 사용된다.</target>
        </trans-unit>
        <trans-unit id="9960fbc3363c91bebbbc4dae3127f4935a1a22d6" translate="yes" xml:space="preserve">
          <source>Treat all files as text.</source>
          <target state="translated">모든 파일을 텍스트로 취급하십시오.</target>
        </trans-unit>
        <trans-unit id="a08e9c61e543dccc4a24afe7a10c95737cbb1ca7" translate="yes" xml:space="preserve">
          <source>Treat pathspecs literally (i.e. no globbing, no pathspec magic). This is equivalent to setting the &lt;code&gt;GIT_LITERAL_PATHSPECS&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">경로 스펙을 문자 그대로 처리하십시오 (예 : 글 로빙, 경로 스펙 마법 없음). 이것은 &lt;code&gt;GIT_LITERAL_PATHSPECS&lt;/code&gt; 환경 변수를 &lt;code&gt;1&lt;/code&gt; 로 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8024445062b4bb90b2e84a4da6e0bb207f37b5f4" translate="yes" xml:space="preserve">
          <source>Treat the &amp;lt;string&amp;gt; given to &lt;code&gt;-S&lt;/code&gt; as an extended POSIX regular expression to match.</source>
          <target state="translated">&lt;code&gt;-S&lt;/code&gt; 에 제공된 &amp;lt;string&amp;gt;을 확장 POSIX 정규식으로 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="72315ec1092243bb561e5b4697869abb3601099e" translate="yes" xml:space="preserve">
          <source>Treat the repository as a bare repository. If GIT_DIR environment is not set, it is set to the current working directory.</source>
          <target state="translated">저장소를 Bare 저장소로 취급하십시오. GIT_DIR 환경이 설정되지 않은 경우 현재 작업 디렉토리로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1dad3a3b77cbf00bf58d87ee853af6d3cddb344a" translate="yes" xml:space="preserve">
          <source>Treat the revision argument as a &amp;lt;revision range&amp;gt;, even if it is just a single commit (that would normally be treated as a &amp;lt;since&amp;gt;). Note that root commits included in the specified range are always formatted as creation patches, independently of this flag.</source>
          <target state="translated">개정 인수는 단일 커밋 일지라도 (보통 &amp;lt;since&amp;gt;로 취급 될지라도) &amp;lt;revision range&amp;gt;로 취급하십시오. 지정된 범위에 포함 된 루트 커밋은이 플래그와 관계없이 항상 생성 패치로 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="aa88eae97d6ad1936bc41000081122649aee8d74" translate="yes" xml:space="preserve">
          <source>Treats lines with the indicated type of whitespace change as unchanged for the sake of a three-way merge. Whitespace changes mixed with other changes to a line are not ignored. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;-b&lt;/code&gt;, &lt;code&gt;-w&lt;/code&gt;, &lt;code&gt;--ignore-space-at-eol&lt;/code&gt;, and &lt;code&gt;--ignore-cr-at-eol&lt;/code&gt;.</source>
          <target state="translated">3 방향 병합을 위해 표시된 유형의 공백 변경이있는 행을 변경되지 않은 것으로 취급합니다. 행에 대한 다른 변경 사항과 혼합 된 공백 변경 사항은 무시되지 않습니다. 참고 &lt;a href=&quot;git-diff&quot;&gt;자식 DIFF-[1] &lt;/a&gt; &lt;code&gt;-b&lt;/code&gt; , &lt;code&gt;-w&lt;/code&gt; , &lt;code&gt;--ignore-space-at-eol&lt;/code&gt; 및 &lt;code&gt;--ignore-cr-at-eol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ddd0e484558c1f8e50a8fe3c2dc7499225a9297" translate="yes" xml:space="preserve">
          <source>Tree Object</source>
          <target state="translated">트리 객체</target>
        </trans-unit>
        <trans-unit id="bce93b7f9d4c3064a3f582b574710500d7e5efb5" translate="yes" xml:space="preserve">
          <source>Tree and blob objects outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; will be treated the same way as if they were inside &lt;code&gt;refs/tags/*&lt;/code&gt;, any update of them will be rejected.</source>
          <target state="translated">&lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 외부의 Tree 및 blob 객체 는 &lt;code&gt;refs/tags/*&lt;/code&gt; 내부와 동일한 방식으로 처리되며 모든 업데이트는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="faed43d5018a65bdda1021ea817b81efdd882a1f" translate="yes" xml:space="preserve">
          <source>Tree objects as well as tag objects not pointing at commits, cannot be described. When describing blobs, the lightweight tags pointing at blobs are ignored, but the blob is still described as &amp;lt;committ-ish&amp;gt;:&amp;lt;path&amp;gt; despite the lightweight tag being favorable.</source>
          <target state="translated">커밋을 가리 키지 않는 태그 객체뿐만 아니라 트리 객체도 설명 할 수 없습니다. 블롭을 기술 할 때, 블롭을 가리키는 경량 태그는 무시되지만, 경량 태그가 유리하지만 블롭은 여전히 ​​&amp;lt;committ-ish&amp;gt; : &amp;lt;path&amp;gt;로 기술된다.</target>
        </trans-unit>
        <trans-unit id="d94a666a1561928de12071aa36f46464acd70f54" translate="yes" xml:space="preserve">
          <source>Tree to checkout from (when paths are given). If not specified, the index will be used.</source>
          <target state="translated">체크 아웃 할 트리 (경로가 제공 될 때). 지정하지 않으면 인덱스가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fef8232d1c67b8b3403ba454c8ae3c965dc5fb72" translate="yes" xml:space="preserve">
          <source>Trees (aka directories) use just 12 bytes of memory on top of the memory required for their entries (see &amp;ldquo;per active file&amp;rdquo; below). The cost of a tree is virtually 0, as its overhead amortizes out over the individual file entries.</source>
          <target state="translated">트리 (일명 디렉토리)는 항목에 필요한 메모리 위에 12 바이트의 메모리 만 사용합니다 (아래의 &quot;활성 파일 당&quot;참조). 오버 헤드가 개별 파일 항목을 넘어 서기 때문에 트리의 비용은 거의 0입니다.</target>
        </trans-unit>
        <trans-unit id="8797468d6463e4f71332170d9f50ca7fd321cc3a" translate="yes" xml:space="preserve">
          <source>Trivial merges are done by &lt;code&gt;git read-tree&lt;/code&gt; itself. Only conflicting paths will be in unmerged state when &lt;code&gt;git read-tree&lt;/code&gt; returns.</source>
          <target state="translated">사소한 병합은 &lt;code&gt;git read-tree&lt;/code&gt; 자체에 의해 수행됩니다 . &lt;code&gt;git read-tree&lt;/code&gt; 가 반환 되면 충돌하는 경로 만 병합되지 않은 상태가됩니다 .</target>
        </trans-unit>
        <trans-unit id="c14d8e783a9f521d30b73eb971eac8f82acc62a0" translate="yes" xml:space="preserve">
          <source>True merge</source>
          <target state="translated">진정한 병합</target>
        </trans-unit>
        <trans-unit id="33a579ffc0dccbff15be01734ea4138ea4e7635c" translate="yes" xml:space="preserve">
          <source>Trust</source>
          <target state="translated">Trust</target>
        </trans-unit>
        <trans-unit id="df8a0e781552ee165e12d7086194c5f37262dc36" translate="yes" xml:space="preserve">
          <source>Try to speed up the traversal using the pack bitmap index (if one is available). Note that when traversing with &lt;code&gt;--objects&lt;/code&gt;, trees and blobs will not have their associated path printed.</source>
          <target state="translated">팩 비트 맵 인덱스 (사용 가능한 경우)를 사용하여 순회 속도를 높이십시오. &lt;code&gt;--objects&lt;/code&gt; 로 순회 할 때 나무와 얼룩에는 연관된 경로가 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db494399fc91d335ea933090c261cf51f7615da6" translate="yes" xml:space="preserve">
          <source>Try to update from the upstream resulted in a lot of conflicts; you were not ready to spend a lot of time merging right now, so you decide to do that later.</source>
          <target state="translated">업스트림에서 업데이트하려고하면 많은 충돌이 발생했습니다. 지금 병합하는 데 많은 시간을 할애 할 준비가되지 않았으므로 나중에 그렇게하기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="3a12d2b4901990f4e580a360ff850809fe3f67b9" translate="yes" xml:space="preserve">
          <source>Turn off any previous &lt;code&gt;--filter=&lt;/code&gt; argument.</source>
          <target state="translated">이전 &lt;code&gt;--filter=&lt;/code&gt; 인수를 끄십시오 .</target>
        </trans-unit>
        <trans-unit id="34771065d121fc03fac8d38d540e254893826329" translate="yes" xml:space="preserve">
          <source>Turn off branch colors, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">구성 파일이 기본값으로 컬러 출력을 제공하더라도 분기 컬러를 끕니다. &lt;code&gt;--color=never&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6d9cbb32ce6c68e264cdb30b91e954cf183958d3" translate="yes" xml:space="preserve">
          <source>Turn off colored diff. It is the same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">컬러 차이를 끄십시오. &lt;code&gt;--color=never&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3d9b2354f095eeb41acddbf4f3d69d4ac5775813" translate="yes" xml:space="preserve">
          <source>Turn off colored diff. This can be used to override configuration settings. It is the same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">컬러 차이를 끄십시오. 구성 설정을 재정의하는 데 사용할 수 있습니다. &lt;code&gt;--color=never&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8ad464ef4a6c59cdcb2319e829113b9b9a0202fe" translate="yes" xml:space="preserve">
          <source>Turn off colored output, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">구성 파일이 기본값을 컬러 출력으로 설정하더라도 컬러 출력을 끕니다. &lt;code&gt;--color=never&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a3a997309d5fb6a6ca30f0f6201f278a284d8e1e" translate="yes" xml:space="preserve">
          <source>Turn off match highlighting, even when the configuration file gives the default to color output. Same as &lt;code&gt;--color=never&lt;/code&gt;.</source>
          <target state="translated">구성 파일이 기본값으로 컬러 출력을 제공하더라도 일치 강조 표시를 끕니다. &lt;code&gt;--color=never&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d4fab0f230de92fdcff08739247b39013a4dcf91" translate="yes" xml:space="preserve">
          <source>Turn off move detection. This can be used to override configuration settings. It is the same as &lt;code&gt;--color-moved=no&lt;/code&gt;.</source>
          <target state="translated">움직임 감지를 끕니다. 구성 설정을 재정의하는 데 사용할 수 있습니다. 그것과 동일 &lt;code&gt;--color-moved=no&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0eb0b106db412297afc722cb22850ad8fd89466" translate="yes" xml:space="preserve">
          <source>Turn off rename detection, even when the configuration file gives the default to do so.</source>
          <target state="translated">구성 파일이 기본값을 제공하더라도 이름 바꾸기 감지 기능을 끄십시오.</target>
        </trans-unit>
        <trans-unit id="4e867193eda90e02a99d5e3b2d3aff016424ee32" translate="yes" xml:space="preserve">
          <source>Turn off rename detection. This overrides the &lt;code&gt;merge.renames&lt;/code&gt; configuration variable. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--no-renames&lt;/code&gt;.</source>
          <target state="translated">이름 변경 감지 기능을 해제하십시오. 이는 &lt;code&gt;merge.renames&lt;/code&gt; 구성 변수를 대체합니다 . &lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--no-renames&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29eb4a9a74bb1156273caaa264fc85825c0572ef" translate="yes" xml:space="preserve">
          <source>Turn on rename detection, optionally setting the similarity threshold. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--find-renames&lt;/code&gt;.</source>
          <target state="translated">이름 변경 감지를 켜고 선택적으로 유사성 임계 값을 설정하십시오. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--find-renames&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a279dbfc86c680add56c7a5993ef6023dec20637" translate="yes" xml:space="preserve">
          <source>Turn on rename detection, optionally setting the similarity threshold. This is the default. This overrides the &lt;code&gt;merge.renames&lt;/code&gt; configuration variable. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--find-renames&lt;/code&gt;.</source>
          <target state="translated">이름 변경 감지를 켜고 선택적으로 유사성 임계 값을 설정하십시오. 이것이 기본값입니다. 이는 &lt;code&gt;merge.renames&lt;/code&gt; 구성 변수를 대체합니다 . &lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--find-renames&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9d077a66918e3017c929a4d5ef75e05f491a825" translate="yes" xml:space="preserve">
          <source>Turn on/off rename detection regardless of user configuration. See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--no-renames&lt;/code&gt;.</source>
          <target state="translated">사용자 구성에 관계없이 이름 바꾸기 감지를 켜거나 끕니다. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--no-renames&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff597cb2e8f500da1bb43f369ea55f0017801fbc" translate="yes" xml:space="preserve">
          <source>Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal.</source>
          <target state="translated">진행 상황을 명시 적으로 켜거나 끕니다. 어느 것도 지정하지 않으면 표준 오류가 터미널에 연결된 경우 진행률이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b63e204e5b5bb236923126ba202fed353f8079ec" translate="yes" xml:space="preserve">
          <source>Turn progress on/off explicitly. If neither is specified, progress is shown if standard error is connected to a terminal. Note that not all merge strategies may support progress reporting.</source>
          <target state="translated">진행 상황을 명시 적으로 켜거나 끕니다. 어느 것도 지정하지 않으면 표준 오류가 터미널에 연결된 경우 진행률이 표시됩니다. 모든 병합 전략이 진행률보고를 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae22b8d4ecb731b706e41a653df929373ee8e8e0" translate="yes" xml:space="preserve">
          <source>Turns off any previous &lt;code&gt;--filter=&lt;/code&gt; argument.</source>
          <target state="translated">이전 &lt;code&gt;--filter=&lt;/code&gt; 인수를 끕니다 .</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="aef2d842e6b781b12f96bc62f4ab607c12e12218" translate="yes" xml:space="preserve">
          <source>Two Tree Merge</source>
          <target state="translated">두 트리 병합</target>
        </trans-unit>
        <trans-unit id="6bda5442e87e811366b94ce6966009ecac6ac5dc" translate="yes" xml:space="preserve">
          <source>Two consecutive asterisks (&quot;&lt;code&gt;**&lt;/code&gt;&quot;) in patterns matched against full pathname may have special meaning:</source>
          <target state="translated">전체 경로 이름과 일치하는 패턴에서 두 개의 연속 별표 ( &quot; &lt;code&gt;**&lt;/code&gt; &quot;)는 특별한 의미를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e187ca5222f2f1c9a298321896225faf75c5697a" translate="yes" xml:space="preserve">
          <source>Two consecutive asterisks (&amp;ldquo;**&amp;rdquo;) in patterns matched against full pathname may have special meaning:</source>
          <target state="translated">전체 경로 이름과 일치하는 패턴에서 두 개의 연속 별표 (&amp;ldquo;**&amp;rdquo;)는 특별한 의미를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fce699584c34eaef39ec9c341ad51961e194a419" translate="yes" xml:space="preserve">
          <source>Two special values are supported: &lt;code&gt;off&lt;/code&gt; will simply close the corresponding standard handle, and if &lt;code&gt;GIT_REDIRECT_STDERR&lt;/code&gt; is &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;, standard error will be redirected to the same handle as standard output.</source>
          <target state="translated">두 가지 특수 값이 지원됩니다. &lt;code&gt;off&lt;/code&gt; 는 해당 표준 핸들을 닫고 &lt;code&gt;GIT_REDIRECT_STDERR&lt;/code&gt; 이 &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; 이면 표준 오류는 표준 출력과 동일한 핸들로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="34a739d621f3038babff4f0f681d077135e77a75" translate="yes" xml:space="preserve">
          <source>Two things are interesting here:</source>
          <target state="translated">두 가지 흥미로운 점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ced48512ad4d3cb13ca20b7cb1f2f8e4abd0bc9d" translate="yes" xml:space="preserve">
          <source>Tying it all together</source>
          <target state="translated">모두 함께 묶어</target>
        </trans-unit>
        <trans-unit id="3a87a5a93967e0c0facb5bdbedab0a6936494920" translate="yes" xml:space="preserve">
          <source>Type 5 is reserved for future expansion. Type 0 is invalid.</source>
          <target state="translated">유형 5는 향후 확장을 위해 예약되어 있습니다. 유형 0이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8e8d3184972cec12ef3bd94d7eec7947cbe4b53" translate="yes" xml:space="preserve">
          <source>Typical gitweb config files will only change starting (default) time zone, and leave other elements at their default values:</source>
          <target state="translated">일반적인 gitweb 설정 파일은 시작 (기본) 시간대 만 변경하고 다른 요소는 기본값으로 둡니다.</target>
        </trans-unit>
        <trans-unit id="3aa25a3911a2da2f000729dbc451ee040fee4a66" translate="yes" xml:space="preserve">
          <source>Typical usage is something like:</source>
          <target state="translated">일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db1f5b1028dc570d4bb8caccd45a45601a38210c" translate="yes" xml:space="preserve">
          <source>Typical use of git credential</source>
          <target state="translated">git 자격 증명의 일반적인 사용</target>
        </trans-unit>
        <trans-unit id="d63a8a509d39725ec5fc85189ba54ffbab2dd0bb" translate="yes" xml:space="preserve">
          <source>Typically it will be placed in a MUA&amp;rsquo;s drafts folder, edited to add timely commentary that should not go in the changelog after the three dashes, and then sent as a message whose body, in our example, starts with &quot;arch/arm config files were&amp;hellip;​&quot;. On the receiving end, readers can save interesting patches in a UNIX mailbox and apply them with &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;.</source>
          <target state="translated">일반적으로 MUA의 임시 보관함 폴더에 배치되고 세 개의 대시 후에 변경 로그에 포함되지 않아야하는 적절한 주석을 추가하도록 편집 된 다음 본문에서 &quot;arch / arm 구성 파일은 다음과 같이 시작됩니다. &amp;hellip; &quot;. 수신 측에서 독자는 흥미로운 패치를 UNIX 메일함에 저장하고 &lt;a href=&quot;git-am&quot;&gt;git-am [1]으로&lt;/a&gt; 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b51965ce078cc4b0d9ecb0a1b113a383a8700dc" translate="yes" xml:space="preserve">
          <source>Typically such a variable may look like this:</source>
          <target state="translated">일반적으로 이러한 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f47be9cc1e7fcec80fcc7e52dcbd486a27d2ee2" translate="yes" xml:space="preserve">
          <source>Typically this is run with a script calling Git&amp;rsquo;s imitation of the &lt;code&gt;merge&lt;/code&gt; command from the RCS package.</source>
          <target state="translated">일반적으로 이것은 RCS 패키지에서 &lt;code&gt;merge&lt;/code&gt; 명령 에 대한 Git의 모방을 호출하는 스크립트로 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="e4333d902cedfd0d4739277fdec621b3f9f09422" translate="yes" xml:space="preserve">
          <source>Typically this matches the real type of &amp;lt;object&amp;gt; but asking for a type that can trivially be dereferenced from the given &amp;lt;object&amp;gt; is also permitted. An example is to ask for a &quot;tree&quot; with &amp;lt;object&amp;gt; being a commit object that contains it, or to ask for a &quot;blob&quot; with &amp;lt;object&amp;gt; being a tag object that points at it.</source>
          <target state="translated">일반적으로 이것은 &amp;lt;object&amp;gt;의 실제 유형과 일치하지만 주어진 &amp;lt;object&amp;gt;에서 사소하게 역 참조 될 수있는 유형을 요구하는 것도 허용됩니다. 예를 들어 &amp;lt;object&amp;gt;가 포함 된 커밋 객체 인 &quot;tree&quot;를 요청하거나 &amp;lt;object&amp;gt;가이를 가리키는 태그 객체 인 &quot;blob&quot;를 요청하는 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b016c5601edd059fd8dc12bb8d8426b6525fff2" translate="yes" xml:space="preserve">
          <source>Typically you would first remove all tracked files from the working tree using this command:</source>
          <target state="translated">일반적으로 다음 명령을 사용하여 작업 트리에서 추적 된 모든 파일을 먼저 제거합니다.</target>
        </trans-unit>
        <trans-unit id="3a2ee6ee14f11a86e1818d26c21e9493d38718f1" translate="yes" xml:space="preserve">
          <source>Typically, parallel recursive and multi-remote fetches will be faster. By default fetches are performed sequentially, not in parallel.</source>
          <target state="translated">일반적으로 병렬 재귀 및 다중 원격 반입이 더 빠릅니다. 기본적으로 페치는 병렬이 아닌 순차적으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="94e92e77c127b9c8a314ec2c48c4916e008c6404" translate="yes" xml:space="preserve">
          <source>Typically, this is invoked as &lt;code&gt;git read-tree -m $H $M&lt;/code&gt;, where $H is the head commit of the current repository, and $M is the head of a foreign tree, which is simply ahead of $H (i.e. we are in a fast-forward situation).</source>
          <target state="translated">일반적으로 이것은 &lt;code&gt;git read-tree -m $H $M&lt;/code&gt; 으로 호출됩니다 . 여기서 $ H는 현재 저장소의 헤드 커밋이고 $ M은 외부 트리의 헤드입니다. 빠른 상황에 처해 있습니다).</target>
        </trans-unit>
        <trans-unit id="0ada5827188094ef6e82c28e45e078ca96f54ca4" translate="yes" xml:space="preserve">
          <source>U: file is unmerged (you must complete the merge before it can be committed)</source>
          <target state="translated">U : 파일이 병합 해제되었습니다 (커밋하기 전에 병합을 완료해야합니다)</target>
        </trans-unit>
        <trans-unit id="1a7a0d0dd35212ae4c8c4c873315c6e7e9351f3b" translate="yes" xml:space="preserve">
          <source>URI and label (title) for the Git logo link (or your site logo, if you chose to use different logo image). By default, these both refer to Git homepage, &lt;a href=&quot;https://git-scm.com&quot;&gt;https://git-scm.com&lt;/a&gt;; in the past, they pointed to Git documentation at &lt;a href=&quot;https://www.kernel.org&quot;&gt;https://www.kernel.org&lt;/a&gt;.</source>
          <target state="translated">Git 로고 링크 (또는 다른 로고 이미지를 사용하기로 선택한 경우 사이트 로고)의 URI 및 레이블 (제목). 기본적으로 이들은 둘 다 Git 홈페이지 &lt;a href=&quot;https://git-scm.com&quot;&gt;https://git-scm.com을 참조합니다&lt;/a&gt; . 과거에는 &lt;a href=&quot;https://www.kernel.org&quot;&gt;https://www.kernel.org의&lt;/a&gt; Git 문서를 가리 켰습니다 .</target>
        </trans-unit>
        <trans-unit id="8561702ffd22bbb5ccd1a81c9c8d8cc77f16fa7e" translate="yes" xml:space="preserve">
          <source>Un-sets the previously set type specifier (if one was previously set). This option requests that &lt;code&gt;git config&lt;/code&gt; not canonicalize the retrieved variable. &lt;code&gt;--no-type&lt;/code&gt; has no effect without &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; or &lt;code&gt;--&amp;lt;type&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이전에 설정 한 유형 지정자를 설정 해제합니다 (이전에 설정 한 경우). 이 옵션은 &lt;code&gt;git config&lt;/code&gt; 가 검색된 변수를 정규화 할 수 없도록 요청 합니다. &lt;code&gt;--no-type&lt;/code&gt; 은 &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;--&amp;lt;type&amp;gt;&lt;/code&gt; 없이는 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="911839695653d988872929c95814b8902e300040" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--pretty=oneline&lt;/code&gt;, the commit message is prefixed with this information on the same line. This option cannot be combined with &lt;code&gt;--reverse&lt;/code&gt;. See also &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt;.</source>
          <target state="translated">아래 &lt;code&gt;--pretty=oneline&lt;/code&gt; 의 메시지가 같은 줄에이 정보로 시작됩니다 커밋합니다. 이 옵션은 &lt;code&gt;--reverse&lt;/code&gt; 와 함께 사용할 수 없습니다 . &lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="64ba59969ba5a36d002d9a189101c624fcf7d3cc" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--pretty=reference&lt;/code&gt;, this information will not be shown at all.</source>
          <target state="translated">아래 &lt;code&gt;--pretty=reference&lt;/code&gt; 이 정보는 전혀 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c73a6e04cc57ad10ee4ae7284f559a5ae2a53d36" translate="yes" xml:space="preserve">
          <source>Under certain circumstances, some versions of &lt;code&gt;diff&lt;/code&gt; do not correctly detect a missing new-line at the end of the file. As a result, patches created by such &lt;code&gt;diff&lt;/code&gt; programs do not record incomplete lines correctly. This option adds support for applying such patches by working around this bug.</source>
          <target state="translated">특정 상황에서 일부 버전의 &lt;code&gt;diff&lt;/code&gt; 는 파일 끝에서 누락 된 줄 바꿈을 올바르게 감지하지 못합니다. 결과적으로 이러한 &lt;code&gt;diff&lt;/code&gt; 프로그램으로 작성된 패치는 불완전한 행을 올바르게 기록하지 않습니다. 이 옵션은이 버그를 해결하여 이러한 패치 적용에 대한 지원을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="67a27dbf5548d05ac63e85bd8b4c875d8f48c102" translate="yes" xml:space="preserve">
          <source>Understanding History: Commits</source>
          <target state="translated">역사 이해 : 커밋</target>
        </trans-unit>
        <trans-unit id="9334dba95d5dfb2042093dd9adbddea5f77c5eb4" translate="yes" xml:space="preserve">
          <source>Understanding history: History diagrams</source>
          <target state="translated">히스토리 이해 : 히스토리 다이어그램</target>
        </trans-unit>
        <trans-unit id="85bd1a7ea75afef7e0417cd2bf9d9f3cf13e5e08" translate="yes" xml:space="preserve">
          <source>Understanding history: What is a branch?</source>
          <target state="translated">역사 이해 : 지사는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6d61d96a492f996316f1e84e66cbfde933315e2c" translate="yes" xml:space="preserve">
          <source>Understanding history: commits, parents, and reachability</source>
          <target state="translated">역사 이해 : 커밋, 부모 및 접근성</target>
        </trans-unit>
        <trans-unit id="afa47a28efb9d6631a7be02ac359bed5256995ce" translate="yes" xml:space="preserve">
          <source>Undo a commit and redo</source>
          <target state="translated">커밋 실행 취소 및 다시 실행</target>
        </trans-unit>
        <trans-unit id="61cb90c052dfcd0fda883c6029d1d0fc0a0f4685" translate="yes" xml:space="preserve">
          <source>Undo a commit, making it a topic branch</source>
          <target state="translated">커밋을 취소하여 주제 분기로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="93d74feb000c815128d68a09c83733db43b69c15" translate="yes" xml:space="preserve">
          <source>Undo a merge or pull</source>
          <target state="translated">병합 취소 또는 풀</target>
        </trans-unit>
        <trans-unit id="4728c70cd06347b5f285fb3e7887387303b3968e" translate="yes" xml:space="preserve">
          <source>Undo a merge or pull inside a dirty working tree</source>
          <target state="translated">병합 작업을 취소하거나 더러운 작업 트리 내부로 가져 오기</target>
        </trans-unit>
        <trans-unit id="27b7abb5b90b7a2e8f00eaf74b6df8323ba7d926" translate="yes" xml:space="preserve">
          <source>Undo add</source>
          <target state="translated">추가 취소</target>
        </trans-unit>
        <trans-unit id="ca677a11d37ffdca5231911a194cc2fcdffc5a26" translate="yes" xml:space="preserve">
          <source>Undo commits permanently</source>
          <target state="translated">영구적으로 커밋 취소</target>
        </trans-unit>
        <trans-unit id="4180759bca2f04cde0ec69611cb0e0ec1cfe7139" translate="yes" xml:space="preserve">
          <source>Undoes the effects of &lt;code&gt;fetch&lt;/code&gt; back to the specified revision. This allows you to re-&lt;code&gt;fetch&lt;/code&gt; an SVN revision. Normally the contents of an SVN revision should never change and &lt;code&gt;reset&lt;/code&gt; should not be necessary. However, if SVN permissions change, or if you alter your --ignore-paths option, a &lt;code&gt;fetch&lt;/code&gt; may fail with &quot;not found in commit&quot; (file not previously visible) or &quot;checksum mismatch&quot; (missed a modification). If the problem file cannot be ignored forever (with --ignore-paths) the only way to repair the repo is to use &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 의 효과를 지정된 개정으로 되돌 립니다. SVN 개정판 을 다시 &lt;code&gt;fetch&lt;/code&gt; 수 있습니다 . 일반적으로 SVN 개정판의 내용은 변경 되지 않으며 &lt;code&gt;reset&lt;/code&gt; 할 필요가 없습니다. 그러나 SVN 권한이 변경되거나 --ignore-paths 옵션을 변경 하면 &quot;커밋에서 찾을 수 없음&quot;(이전에 표시되지 않은 파일) 또는 &quot;체크섬 불일치&quot;(수정이 누락 됨)와 함께 &lt;code&gt;fetch&lt;/code&gt; 가 실패 할 수 있습니다. 문제 파일을 --ignore-paths로 영원히 무시할 수없는 경우 repo를 복구하는 유일한 방법은 &lt;code&gt;reset&lt;/code&gt; 을 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="ac1f58f831611819b4114b80dd55e3ce540d5b23" translate="yes" xml:space="preserve">
          <source>Undoing a merge</source>
          <target state="translated">병합 취소</target>
        </trans-unit>
        <trans-unit id="f552d5a5802e3df6273c784214def9840b82f594" translate="yes" xml:space="preserve">
          <source>Unfortunately this system becomes inefficient once a project has a lot of objects. Try this on an old project:</source>
          <target state="translated">불행히도이 시스템은 프로젝트에 많은 객체가 있으면 비효율적입니다. 오래된 프로젝트에서 이것을 시도하십시오 :</target>
        </trans-unit>
        <trans-unit id="c7deb06b3e42a38e2b00598939aa39f8d24897bd" translate="yes" xml:space="preserve">
          <source>Unfortunately, the desired effect of cleaning up text files with mixed line endings and the undesired effect of corrupting binary files cannot be distinguished. In both cases CRLFs are removed in an irreversible way. For text files this is the right thing to do because CRLFs are line endings, while for binary files converting CRLFs corrupts data.</source>
          <target state="translated">불행하게도, 줄 끝이 혼합 된 텍스트 파일을 정리하는 원하는 효과와 이진 파일을 손상시키는 원하지 않는 효과는 구분할 수 없습니다. 두 경우 모두 CRLF는 되돌릴 수없는 방식으로 제거됩니다. 텍스트 파일의 경우 CRLF가 줄 끝이므로 이진 파일의 경우 CRLF를 변환하면 데이터가 손상되므로이 작업을 수행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6da1ce58d3a6c34c76807dc44593d7cd8c6563b6" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;--text&lt;/code&gt; is supplied patches of binary files without a textconv filter will be ignored.</source>
          <target state="translated">&lt;code&gt;--text&lt;/code&gt; 가 제공 되지 않으면 textconv 필터가없는 이진 파일의 패치는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="54cbf98b314812a07f65f95ae77e8608ddf0b26f" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-f&lt;/code&gt; is given, the &lt;code&gt;replace&lt;/code&gt; reference must not yet exist.</source>
          <target state="translated">&lt;code&gt;-f&lt;/code&gt; 를 지정 하지 않으면 &lt;code&gt;replace&lt;/code&gt; 참조가 아직 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="ec0a9816e3fe8947b4bfff6f5914c3288bed6fc9" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;-f&lt;/code&gt; is given, the named tag must not yet exist.</source>
          <target state="translated">&lt;code&gt;-f&lt;/code&gt; 를 지정 하지 않으면 이름 지정된 태그가 아직 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="7824ccb45f3d7be1fd07def25712792fbdf3f009" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;git blame&lt;/code&gt; and &lt;code&gt;git annotate&lt;/code&gt; in older versions of git, the extent of the annotation can be limited to both line ranges and revision ranges. The &lt;code&gt;-L&lt;/code&gt; option, which limits annotation to a range of lines, may be specified multiple times.</source>
          <target state="translated">이전 버전의 git에서 &lt;code&gt;git blame&lt;/code&gt; 및 &lt;code&gt;git annotate&lt;/code&gt; 와 달리 주석 의 범위는 선 범위와 개정 범위로 제한 될 수 있습니다. 주석을 여러 줄로 제한 하는 &lt;code&gt;-L&lt;/code&gt; 옵션은 여러 번 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fa5e3a4c28161d2ef67ee80d5624341cfa56be1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;git diff-files&lt;/code&gt;, which showed the difference between the index file and the working tree, &lt;code&gt;git diff-index&lt;/code&gt; shows the differences between a committed &lt;strong&gt;tree&lt;/strong&gt; and either the index file or the working tree. In other words, &lt;code&gt;git diff-index&lt;/code&gt; wants a tree to be diffed against, and before we did the commit, we couldn&amp;rsquo;t do that, because we didn&amp;rsquo;t have anything to diff against.</source>
          <target state="translated">인덱스 파일과 작업 트리의 차이점을 보여준 &lt;code&gt;git diff-files&lt;/code&gt; 와 달리 git diff- &lt;code&gt;git diff-index&lt;/code&gt; 는 커밋 된 &lt;strong&gt;트리&lt;/strong&gt; 와 인덱스 파일 또는 작업 트리 의 차이점을 보여줍니다 . 다시 말해, &lt;code&gt;git diff-index&lt;/code&gt; 는 트리를 비교 하기를 원하며 커밋을 수행하기 전에 비교할 수있는 항목이 없기 때문에이를 수행 할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="a75073ebd9356a7219cb30b4bb866c17ce8b906c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;gitk&lt;/code&gt;, &lt;code&gt;git gui&lt;/code&gt; focuses on commit generation and single file annotation and does not show project history. It does however supply menu actions to start a &lt;code&gt;gitk&lt;/code&gt; session from within &lt;code&gt;git gui&lt;/code&gt;.</source>
          <target state="translated">달리 &lt;code&gt;gitk&lt;/code&gt; 이 , &lt;code&gt;git gui&lt;/code&gt; 생성 및 단일 파일 주석을 커밋에 초점을 맞추고 프로젝트의 역사를 표시하지 않습니다. 그러나 &lt;code&gt;git gui&lt;/code&gt; 내에서 &lt;code&gt;gitk&lt;/code&gt; 세션 을 시작하기위한 메뉴 조치를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="cd17281830ac5a9aa50c0d768481eabf04240182" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;raw&lt;/code&gt; format above, the time zone/UTC offset information contained in an RFC 2822 date string is used to adjust the date value to UTC prior to storage. Therefore it is important that this information be as accurate as possible.</source>
          <target state="translated">위 의 &lt;code&gt;raw&lt;/code&gt; 형식 과 달리 RFC 2822 날짜 문자열에 포함 된 시간대 / UTC 오프셋 정보는 날짜 값을 저장하기 전에 UTC로 조정하는 데 사용됩니다. 따라서이 정보는 최대한 정확해야합니다.</target>
        </trans-unit>
        <trans-unit id="422977ffd462a03a6cbce65db58b07001eb2214f" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;rfc2822&lt;/code&gt; format, this format is very strict. Any variation in formatting will cause fast-import to reject the value.</source>
          <target state="translated">&lt;code&gt;rfc2822&lt;/code&gt; 형식 과 달리이 형식은 매우 엄격합니다. 서식이 다양하면 빠른 가져 오기에서 값을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="a5e8af576412d2facd9f39a0996da0da165c42ee" translate="yes" xml:space="preserve">
          <source>Unlike the Porcelain format, the filename information is always given and terminates the entry:</source>
          <target state="translated">Porcelain 형식과 달리 파일 이름 정보는 항상 제공되며 항목을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="b603b31236d9df1a4442c23c62ea6317f2525837" translate="yes" xml:space="preserve">
          <source>Unlike the longhand form, when Alice fetches from Bob using a remote repository shorthand set up with &lt;code&gt;git remote&lt;/code&gt;, what was fetched is stored in a remote-tracking branch, in this case &lt;code&gt;bob/master&lt;/code&gt;. So after this:</source>
          <target state="translated">Longhand 형식과 달리 Alice가 &lt;code&gt;git remote&lt;/code&gt; 로 설정된 원격 저장소 단축을 사용하여 Bob에서 가져 오면 가져온 항목이 원격 추적 분기 (이 경우 &lt;code&gt;bob/master&lt;/code&gt; )에 저장 됩니다. 그래서이 후 :</target>
        </trans-unit>
        <trans-unit id="cc8e9909209a90f3a790bc3005980e8527de79e5" translate="yes" xml:space="preserve">
          <source>Unlike the traditional &lt;code&gt;unified&lt;/code&gt; diff format, which shows two files A and B with a single column that has &lt;code&gt;-&lt;/code&gt; (minus &amp;mdash; appears in A but removed in B), &lt;code&gt;+&lt;/code&gt; (plus &amp;mdash; missing in A but added to B), or &lt;code&gt;&quot; &quot;&lt;/code&gt; (space &amp;mdash; unchanged) prefix, this format compares two or more files file1, file2,&amp;hellip;​ with one file X, and shows how X differs from each of fileN. One column for each of fileN is prepended to the output line to note how X&amp;rsquo;s line is different from it.</source>
          <target state="translated">기존과는 달리 &lt;code&gt;unified&lt;/code&gt; 이 하나의 컬럼은 diff 형식, 쇼 두 개의 파일 A와 B &lt;code&gt;-&lt;/code&gt; (빼기 - A의 표시되지만 B에서 제거) &lt;code&gt;+&lt;/code&gt; - (플러스에서 누락하지만 B에 추가), 또는 &lt;code&gt;&quot; &quot;&lt;/code&gt; ( 공백 &amp;mdash; 변경되지 않은) 접두사 인이 형식은 둘 이상의 파일 file1, file2,&amp;hellip;를 하나의 파일 X와 비교하고 X가 각 파일 N과 어떻게 다른지 보여줍니다. 각각의 fileN에 대해 하나의 열이 출력 행 앞에 추가되어 X의 행이 어떻게 다른지 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71233552f2a4fc77054593fac1f6899dd0308229" translate="yes" xml:space="preserve">
          <source>Unlike variables like &lt;code&gt;color.ui&lt;/code&gt; and &lt;code&gt;core.editor&lt;/code&gt; the &lt;code&gt;receive.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; and &lt;code&gt;fetch.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; variables will not fall back on the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; configuration if they aren&amp;rsquo;t set. To uniformly configure the same fsck settings in different circumstances all three of them they must all set to the same values.</source>
          <target state="translated">같은 변수와 달리 &lt;code&gt;color.ui&lt;/code&gt; 및 &lt;code&gt;core.editor&lt;/code&gt; &lt;code&gt;receive.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 와 &lt;code&gt;fetch.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 변수는 다시 떨어지지 않을 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 구성 그들은하지 않은 경우 세트. 서로 다른 환경에서 동일한 fsck 설정을 균일하게 구성하려면 세 가지 설정을 모두 동일한 값으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="00ee5ed7b48c819f6f323dbe1b9a72aef5a0c864" translate="yes" xml:space="preserve">
          <source>Unlike variables like &lt;code&gt;color.ui&lt;/code&gt; and &lt;code&gt;core.editor&lt;/code&gt; the &lt;code&gt;receive.fsck.skipList&lt;/code&gt; and &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; variables will not fall back on the &lt;code&gt;fsck.skipList&lt;/code&gt; configuration if they aren&amp;rsquo;t set. To uniformly configure the same fsck settings in different circumstances all three of them they must all set to the same values.</source>
          <target state="translated">같은 변수와 달리 &lt;code&gt;color.ui&lt;/code&gt; 및 &lt;code&gt;core.editor&lt;/code&gt; &lt;code&gt;receive.fsck.skipList&lt;/code&gt; 및 &lt;code&gt;fetch.fsck.skipList&lt;/code&gt; 변수는 다시 떨어지지 않을 &lt;code&gt;fsck.skipList&lt;/code&gt; 의 사람들이 설정되지 않은 경우 구성. 서로 다른 환경에서 동일한 fsck 설정을 균일하게 구성하려면 세 가지 설정을 모두 동일한 값으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8a3dffb4c65d7a1f27e907ef2a919885d1125ac9" translate="yes" xml:space="preserve">
          <source>Unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, any updates outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; will be accepted without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;), whether that&amp;rsquo;s swapping e.g. a tree object for a blob, or a commit for another commit that&amp;rsquo;s doesn&amp;rsquo;t have the previous commit as an ancestor etc.</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]으로 푸시&lt;/a&gt; 할 때와 달리 &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 외부의 업데이트 는 refspec (또는 &lt;code&gt;--force&lt;/code&gt; ) 에서 &lt;code&gt;+&lt;/code&gt; 없이 허용됩니다 . 또는 이전 커밋이 조상으로 포함되지 않은 다른 커밋에 대한 커밋</target>
        </trans-unit>
        <trans-unit id="2f2516ccb262ba2dda1eeb5218e911868837ce78" translate="yes" xml:space="preserve">
          <source>Unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, there is no configuration which&amp;rsquo;ll amend these rules, and nothing like a &lt;code&gt;pre-fetch&lt;/code&gt; hook analogous to the &lt;code&gt;pre-receive&lt;/code&gt; hook.</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]로 푸시&lt;/a&gt; 할 때와 달리 , 이러한 규칙을 수정하는 구성은 없으며, &lt;code&gt;pre-receive&lt;/code&gt; 후크와 유사한 &lt;code&gt;pre-fetch&lt;/code&gt; 후크 와 같은 것은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fb79f423670171900d7e94880e8d45907e9f995c" translate="yes" xml:space="preserve">
          <source>Unlock a working tree, allowing it to be pruned, moved or deleted.</source>
          <target state="translated">가지 치기, 이동 또는 삭제를 위해 작업중인 트리를 잠금 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="b00eee8b49227caba98e5d68033660ff6076ebcc" translate="yes" xml:space="preserve">
          <source>Unmerged entries have the following format; the first character is a &quot;u&quot; to distinguish from ordinary changed entries.</source>
          <target state="translated">병합되지 않은 항목의 형식은 다음과 같습니다. 첫 번째 문자는 일반적인 변경 항목과 구별하기위한 &quot;u&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="2c99cc569343579b221cd64026ecc62bb1c21d7b" translate="yes" xml:space="preserve">
          <source>Unpack objects from a packed archive</source>
          <target state="translated">압축 아카이브에서 객체 압축 풀기</target>
        </trans-unit>
        <trans-unit id="42e2a268d032a6abb00d4cbd80feaa1ecd7a75d6" translate="yes" xml:space="preserve">
          <source>Unreachable tags, commits, and trees will also be accessed to find the tips of dangling segments of history. Use &lt;code&gt;--no-dangling&lt;/code&gt; if you don&amp;rsquo;t care about this output and want to speed it up further.</source>
          <target state="translated">도달 할 수없는 태그, 커밋 및 트리도 액세스하여 기록 세그먼트에 매달려있는 팁을 찾습니다. 이 출력에 신경 쓰지 않고 속도를 높이려면 &lt;code&gt;--no-dangling&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8a4efd1d470fc3c5ede97084c82a35b9804122a" translate="yes" xml:space="preserve">
          <source>Unregister the given submodules, i.e. remove the whole &lt;code&gt;submodule.$name&lt;/code&gt; section from .git/config together with their work tree. Further calls to &lt;code&gt;git submodule update&lt;/code&gt;, &lt;code&gt;git submodule foreach&lt;/code&gt; and &lt;code&gt;git submodule sync&lt;/code&gt; will skip any unregistered submodules until they are initialized again, so use this command if you don&amp;rsquo;t want to have a local checkout of the submodule in your working tree anymore.</source>
          <target state="translated">주어진 서브 모듈의 등록을 해제하십시오 &lt;code&gt;submodule.$name&lt;/code&gt; 즉, 작업 트리와 함께 .git / config에서 전체 서브 모듈. $ name 섹션을 제거하십시오 . &lt;code&gt;git submodule update&lt;/code&gt; , &lt;code&gt;git submodule foreach&lt;/code&gt; 및 &lt;code&gt;git submodule sync&lt;/code&gt; 에 대한 추가 호출 은 다시 초기화 될 때까지 등록되지 않은 서브 모듈을 건너 뛰므로 더 이상 작업 트리에서 서브 모듈의 로컬 체크 아웃을 원하지 않으면이 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1431f68f359f8699975be39dca08302c67d68d9e" translate="yes" xml:space="preserve">
          <source>Unset</source>
          <target state="translated">Unset</target>
        </trans-unit>
        <trans-unit id="8ff954e80b42b18d3d0fcda602d94db1e46da2d4" translate="yes" xml:space="preserve">
          <source>Unsetting the &lt;code&gt;text&lt;/code&gt; attribute on a path tells Git not to attempt any end-of-line conversion upon checkin or checkout.</source>
          <target state="translated">경로 에서 &lt;code&gt;text&lt;/code&gt; 속성을 설정 해제하면 체크인 또는 체크 아웃시 줄 끝 변환을 시도하지 않도록 Git에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="7f84947907454dd0cb412d2a8e5d5e3b9c2382f0" translate="yes" xml:space="preserve">
          <source>Unsetting the variable, or setting it to empty, &quot;0&quot; or &quot;false&quot; (case insensitive) disables trace messages.</source>
          <target state="translated">변수를 설정 해제하거나 비어있는 &quot;0&quot;또는 &quot;false&quot;(대소 문자 구분)로 설정하면 추적 메시지가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c176eff9c64fa28a4b6af1aa296cc1394bbf7a80" translate="yes" xml:space="preserve">
          <source>Unshelve</source>
          <target state="translated">Unshelve</target>
        </trans-unit>
        <trans-unit id="9fde2b36ff30053ad23e6a695929873244cc0367" translate="yes" xml:space="preserve">
          <source>Unshelve options</source>
          <target state="translated">옵션 해제</target>
        </trans-unit>
        <trans-unit id="004e593b6690fb3d48f4f5a86eac1cd13b5b2234" translate="yes" xml:space="preserve">
          <source>Unshelving will take a shelved P4 changelist, and produce the equivalent git commit in the branch refs/remotes/p4-unshelved/&amp;lt;changelist&amp;gt;.</source>
          <target state="translated">Unshelving은 쉘프 P4 변경 목록을 가져와 분기 refs / remotes / p4-unshelved / &amp;lt;changelist&amp;gt;에서 동등한 git commit을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a6e7eb706e115cdaf88206be37eb67b232d007bc" translate="yes" xml:space="preserve">
          <source>Unspecified</source>
          <target state="translated">Unspecified</target>
        </trans-unit>
        <trans-unit id="78f88266b367e8b6e086054e91f1ebc89e168d16" translate="yes" xml:space="preserve">
          <source>Until Git version 2.20, and unlike when pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, any updates to &lt;code&gt;refs/tags/*&lt;/code&gt; would be accepted without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;). When fetching, we promiscuously considered all tag updates from a remote to be forced fetches. Since Git version 2.20, fetching to update &lt;code&gt;refs/tags/*&lt;/code&gt; works the same way as when pushing. I.e. any updates will be rejected without &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;).</source>
          <target state="translated">Git 버전 2.20까지, &lt;a href=&quot;git-push&quot;&gt;git-push [1]로 푸시&lt;/a&gt; 할 때와 달리 &lt;code&gt;refs/tags/*&lt;/code&gt; 에 대한 모든 업데이트 는 refspec (또는 &lt;code&gt;--force&lt;/code&gt; ) 에서 &lt;code&gt;+&lt;/code&gt; 없이 허용됩니다 . 페치 할 때, 원격에서 모든 태그 업데이트를 강제 페치로 간주했습니다. Git 버전 2.20부터 &lt;code&gt;refs/tags/*&lt;/code&gt; 를 업데이트하기 위해 가져 오는 것은 푸시 할 때와 같은 방식으로 작동합니다. 즉 , refspec (또는 &lt;code&gt;--force&lt;/code&gt; ) 에서 &lt;code&gt;+&lt;/code&gt; 없이 업데이트가 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="9514c500d61430538679eec9081979b274172cf9" translate="yes" xml:space="preserve">
          <source>Untracked cache</source>
          <target state="translated">추적되지 않은 캐시</target>
        </trans-unit>
        <trans-unit id="614ce4ff1bf92552970ab54ff766006d0da693f9" translate="yes" xml:space="preserve">
          <source>Untracked items have the following format:</source>
          <target state="translated">추적되지 않은 항목의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1eade895e693b4111455eda06a87af1097cf4d6c" translate="yes" xml:space="preserve">
          <source>Untyped &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;, e.g. the contents of a file.</source>
          <target state="translated">형식화되지 않은 &lt;a href=&quot;#def_object&quot;&gt;객체&lt;/a&gt; (예 : 파일의 내용)</target>
        </trans-unit>
        <trans-unit id="7b839a219907b09268c047c522a03961e96bd78b" translate="yes" xml:space="preserve">
          <source>Unused configuration variable. Used in Git versions 2.20 and 2.21 as an escape hatch to enable the legacy shellscript implementation of rebase. Now the built-in rewrite of it in C is always used. Setting this will emit a warning, to alert any remaining users that setting this now does nothing.</source>
          <target state="translated">사용하지 않은 구성 변수. Git 버전 2.20 및 2.21에서 이스케이프 해치로 사용되어 레거시 셸 스크립트 rebase 구현을 가능하게합니다. 이제 C에서 내장 재 작성이 항상 사용됩니다. 이를 설정하면 나머지 사용자에게 지금 설정해도 아무 것도 수행하지 않는다는 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ca31b4c795dcb03444e6d0c037dbcd47081c70a9" translate="yes" xml:space="preserve">
          <source>Update affected files from CVS repository before attempting export.</source>
          <target state="translated">내보내기를 시도하기 전에 CVS 저장소에서 영향을받는 파일을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="82e59b151c004802a1fa23ba3e75a68d14df0e2a" translate="yes" xml:space="preserve">
          <source>Update an existing shelved changelist with this commit. Implies --shelve. Repeat for multiple shelved changelists.</source>
          <target state="translated">이 커밋으로 기존 선반 변경 목록을 업데이트하십시오. --shelve를 의미합니다. 여러 개의 보류 된 변경 목록에 대해 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="5433caf2e572561b5bb38ff5e69b0263d08b90aa" translate="yes" xml:space="preserve">
          <source>Update and examine branches from the repository you cloned from:</source>
          <target state="translated">복제 한 저장소에서 분기를 업데이트하고 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="381f15e94e347f076ef71f417ee29b782a6dcc4d" translate="yes" xml:space="preserve">
          <source>Update auxiliary info file to help dumb servers</source>
          <target state="translated">바보 서버를 돕기 위해 보조 정보 파일 업데이트</target>
        </trans-unit>
        <trans-unit id="d94aecddb1a2d3c03afb4a7cf4e1bb3a0123c2c6" translate="yes" xml:space="preserve">
          <source>Update hook</source>
          <target state="translated">후크 업데이트</target>
        </trans-unit>
        <trans-unit id="e5f960e3f28d7d7ea59f8750682a356ae18535be" translate="yes" xml:space="preserve">
          <source>Update remote refs along with associated objects</source>
          <target state="translated">관련 객체와 함께 원격 참조 업데이트</target>
        </trans-unit>
        <trans-unit id="ee3315ea0cbb49ab6105a89db0964480184c3ce9" translate="yes" xml:space="preserve">
          <source>Update the Git repository with recent changes from p4, rebasing your work on top:</source>
          <target state="translated">p4의 최근 변경 사항으로 Git 리포지토리를 업데이트하고 작업 내용을 다시 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="5937294218e2d7b95b7b77414b52c326239ca8d5" translate="yes" xml:space="preserve">
          <source>Update the index by adding new files that are unknown to the index and files modified in the working tree, but ignore files that have been removed from the working tree. This option is a no-op when no &amp;lt;pathspec&amp;gt; is used.</source>
          <target state="translated">색인에 알려지지 않은 새 파일과 작업 트리에서 수정 된 파일을 추가하여 색인을 업데이트하지만 작업 트리에서 제거 된 파일은 무시하십시오. &amp;lt;pathspec&amp;gt;이 사용되지 않으면이 옵션은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94df66721f1bfd4990972c3f5f4a0d6b61f59f9e" translate="yes" xml:space="preserve">
          <source>Update the index just where it already has an entry matching &amp;lt;pathspec&amp;gt;. This removes as well as modifies index entries to match the working tree, but adds no new files.</source>
          <target state="translated">&amp;lt;pathspec&amp;gt;과 일치하는 항목이 이미있는 색인을 업데이트하십시오. 이렇게하면 작업 트리와 일치하도록 색인 항목이 제거 될뿐만 아니라 수정되지만 새 파일은 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03d173e098621e3730258998672da85e88b347b1" translate="yes" xml:space="preserve">
          <source>Update the index not only where the working tree has a file matching &amp;lt;pathspec&amp;gt; but also where the index already has an entry. This adds, modifies, and removes index entries to match the working tree.</source>
          <target state="translated">작업 트리에 &amp;lt;pathspec&amp;gt;과 일치하는 파일이있는 색인뿐만 아니라 색인에 이미 항목이있는 색인도 업데이트하십시오. 작업 트리와 일치하도록 인덱스 항목을 추가, 수정 및 제거합니다.</target>
        </trans-unit>
        <trans-unit id="1a6e291eaaa3e731de98429f7fb37fdac90f0a22" translate="yes" xml:space="preserve">
          <source>Update the object name stored in a ref safely</source>
          <target state="translated">참조에 저장된 객체 이름을 안전하게 업데이트</target>
        </trans-unit>
        <trans-unit id="00f0c8a1eac4ed2966a7d563ef87a6387d365dcf" translate="yes" xml:space="preserve">
          <source>Update the origin repository&amp;rsquo;s master branch with the dev branch, allowing non-fast-forward updates. &lt;strong&gt;This can leave unreferenced commits dangling in the origin repository.&lt;/strong&gt; Consider the following situation, where a fast-forward is not possible:</source>
          <target state="translated">원본 저장소의 마스터 분기를 dev 분기로 업데이트하여 빨리 감기가 아닌 업데이트를 허용합니다. &lt;strong&gt;이렇게하면 참조 리포지토리가 오리진 저장소에 매달려 있습니다. &lt;/strong&gt;빨리 감기가 불가능한 다음 상황을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b73d3968359117cfd051c2e81a709d1d9e1579b7" translate="yes" xml:space="preserve">
          <source>Update the reference to the value of the top reflog entry (i.e. &amp;lt;ref&amp;gt;@{0}) if the previous top entry was pruned. (This option is ignored for symbolic references.)</source>
          <target state="translated">이전 맨 위 항목이 제거 된 경우 맨 위 참조 항목 (예 : &amp;lt;ref&amp;gt; @ {0})의 값에 대한 참조를 업데이트하십시오. (이 옵션은 기호 참조의 경우 무시됩니다.)</target>
        </trans-unit>
        <trans-unit id="d7c08d3ae4fbcbbf6a3dc89cdba309659a4395bc" translate="yes" xml:space="preserve">
          <source>Update the reflog for &amp;lt;name&amp;gt; with &amp;lt;reason&amp;gt;. This is valid only when creating or updating a symbolic ref.</source>
          <target state="translated">&amp;lt;이름&amp;gt;에 대한 reflog를 &amp;lt;이유&amp;gt;로 업데이트하십시오. 이것은 기호 참조를 작성하거나 업데이트 할 때만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="d053e75e709458eca9f01e5c8910658ea18a25cf" translate="yes" xml:space="preserve">
          <source>Update the registered submodules to match what the superproject expects by cloning missing submodules, fetching missing commits in submodules and updating the working tree of the submodules. The &quot;updating&quot; can be done in several ways depending on command line options and the value of &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration variable. The command line option takes precedence over the configuration variable. If neither is given, a &lt;code&gt;checkout&lt;/code&gt; is performed. The &lt;code&gt;update&lt;/code&gt; procedures supported both from the command line as well as through the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration are:</source>
          <target state="translated">누락 된 서브 모듈을 복제하고, 서브 모듈에서 누락 된 커밋을 가져오고, 서브 모듈의 작업 트리를 업데이트하여 수퍼 프로젝트가 기대하는 것과 일치하도록 등록 된 서브 모듈을 업데이트하십시오. &quot;업데이트&quot;는 명령 행 옵션 및 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 구성 변수 의 값에 따라 여러 가지 방법으로 수행 할 수 있습니다 . 명령 행 옵션이 구성 변수보다 우선합니다. 둘 다 주어지지 않으면 &lt;code&gt;checkout&lt;/code&gt; 이 수행됩니다. &lt;code&gt;update&lt;/code&gt; 절차는 명령 줄에서뿐만 아니라 통해 모두 지원 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 구성은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="9a189cb9ecf6f808972788504f5218556d75488e" translate="yes" xml:space="preserve">
          <source>Update the remote-tracking branches for the repository you cloned from, then merge one of them into your current branch:</source>
          <target state="translated">복제 한 저장소의 원격 추적 분기를 업데이트 한 후 그 중 하나를 현재 분기로 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="b4a6a66956cae4a12a849cae6094fa1d9187d293" translate="yes" xml:space="preserve">
          <source>Update the remote-tracking branches:</source>
          <target state="translated">원격 추적 분기를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="f68dff1cbdca38d9a97763a1d9fd849e951b6a1b" translate="yes" xml:space="preserve">
          <source>Updates files in the working tree to match the version in the index or the specified tree. If no pathspec was given, &lt;code&gt;git checkout&lt;/code&gt; will also update &lt;code&gt;HEAD&lt;/code&gt; to set the specified branch as the current branch.</source>
          <target state="translated">작업 트리의 파일을 색인 또는 지정된 트리의 버전과 일치하도록 업데이트합니다. pathspec을 지정하지 않으면 &lt;code&gt;git checkout&lt;/code&gt; 은 &lt;code&gt;HEAD&lt;/code&gt; 를 업데이트 하여 지정된 분기를 현재 분기로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="091bf3e8c6fb28b8688a9117ac018615896df561" translate="yes" xml:space="preserve">
          <source>Updates remote refs using local refs, while sending objects necessary to complete the given refs.</source>
          <target state="translated">주어진 심판을 완료하는 데 필요한 객체를 보내는 동안 로컬 심판을 사용하여 원격 심판을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="91ca9b60db53a2ebedea4c579e08371ec4025869" translate="yes" xml:space="preserve">
          <source>Updating A with the resulting merge commit will fast-forward and your push will be accepted.</source>
          <target state="translated">병합 커밋 결과로 A를 업데이트하면 빨리 진행되고 푸시가 수락됩니다.</target>
        </trans-unit>
        <trans-unit id="b1b31935884de26d68d690781ac1ec814b3bc924" translate="yes" xml:space="preserve">
          <source>Updating a repository with git fetch</source>
          <target state="translated">git fetch로 리포지토리 업데이트</target>
        </trans-unit>
        <trans-unit id="c2ed1ab77aee7c3aaed70bc448641d662955a12f" translate="yes" xml:space="preserve">
          <source>Updating existing tests that assume GIT_TRACE format messages.</source>
          <target state="translated">GIT_TRACE 형식 메시지를 가정하는 기존 테스트를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="c5ded60beb1b0eb17cab63a8e09a8acd2261286e" translate="yes" xml:space="preserve">
          <source>Updating the index did something else too: it created a &lt;code&gt;.git/index&lt;/code&gt; file. This is the index that describes your current working tree, and something you should be very aware of. Again, you normally never worry about the index file itself, but you should be aware of the fact that you have not actually really &quot;checked in&quot; your files into Git so far, you&amp;rsquo;ve only &lt;strong&gt;told&lt;/strong&gt; Git about them.</source>
          <target state="translated">인덱스를 업데이트하면 다른 일이 발생했습니다. &lt;code&gt;.git/index&lt;/code&gt; 파일을 만들었습니다 . 이것은 현재 작업 트리를 설명하는 색인이며 매우 알고 있어야합니다. 다시 말하지만, 당신은 일반적으로 인덱스 파일 자체에 대해 걱정하지 않습니다,하지만 당신은 당신이 실제로 정말 힘내에 파일 지금까지, 당신은 단지 한 &quot;체크&quot;는 사실을 알고 있어야 &lt;strong&gt;했다&lt;/strong&gt; 그들에 대해 힘내.</target>
        </trans-unit>
        <trans-unit id="583381e5edf6e3ab467919c38286667f0916979d" translate="yes" xml:space="preserve">
          <source>Upon completion, &amp;lt;branch&amp;gt; will be the current branch.</source>
          <target state="translated">완료되면 &amp;lt;branch&amp;gt;가 현재 분기가됩니다.</target>
        </trans-unit>
        <trans-unit id="c956664b8da61af6d0e1bf33a6e1ff75cbe45ad1" translate="yes" xml:space="preserve">
          <source>Upon seeing an invalid object name in the input, pretend as if the bad input was not given.</source>
          <target state="translated">입력에서 유효하지 않은 오브젝트 이름을 볼 때 잘못된 입력이 제공되지 않은 것처럼 가장하십시오.</target>
        </trans-unit>
        <trans-unit id="d725441fc805b8226e9417fb2c8cf53ac8d791d5" translate="yes" xml:space="preserve">
          <source>Upstream branch to compare against. May be any valid commit, not just an existing branch name. Defaults to the configured upstream for the current branch.</source>
          <target state="translated">비교할 업스트림 브랜치 기존 브랜치 이름뿐만 아니라 유효한 커밋 일 수도 있습니다. 현재 분기에 대해 구성된 업스트림이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="f5808323e4ba717fc383cb75e63b6cf3a4e857e7" translate="yes" xml:space="preserve">
          <source>Upstream branch to search for equivalent commits. Defaults to the upstream branch of HEAD.</source>
          <target state="translated">동등한 커밋을 검색하는 업스트림 브랜치 HEAD의 업스트림 분기로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="309bc26d3c4c2649258f95c7069216bb2a7ac5f4" translate="yes" xml:space="preserve">
          <source>Upstream location from which commits are identified to submit to p4. By default, this is the most recent p4 commit reachable from &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">p4에 제출할 확약이 식별되는 업스트림 위치. 기본적으로 이것은 &lt;code&gt;HEAD&lt;/code&gt; 에서 도달 할 수있는 가장 최근의 p4 커밋 입니다.</target>
        </trans-unit>
        <trans-unit id="df28f1403e8348eae4829434034d1a95e5fe659d" translate="yes" xml:space="preserve">
          <source>Url translation</source>
          <target state="translated">URL 번역</target>
        </trans-unit>
        <trans-unit id="f51159e5f3b0adbeed98e188d040286280a5320b" translate="yes" xml:space="preserve">
          <source>Usage text</source>
          <target state="translated">사용법 텍스트</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="6039144c2dc6586b6f3f0cb7423bcc0b3de0d0c1" translate="yes" xml:space="preserve">
          <source>Use &quot;patience diff&quot; algorithm when generating patches.</source>
          <target state="translated">패치를 생성 할 때 &quot;환자 차이&quot;알고리즘을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1712fa1f1e6f89a27b7d3117ed39073a3258971d" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;dir&amp;gt; to store the resulting files, instead of the current working directory.</source>
          <target state="translated">현재 작업 디렉토리 대신 &amp;lt;dir&amp;gt;을 사용하여 결과 파일을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="89ed1ad2d65d4e1af42e685a9ee22c739e5d2c9b" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;message&amp;gt; instead of the branch names for the first line of the log message. For use with &lt;code&gt;--log&lt;/code&gt;.</source>
          <target state="translated">로그 메시지의 첫 번째 줄에 분기 이름 대신 &amp;lt;message&amp;gt;를 사용하십시오. &lt;code&gt;--log&lt;/code&gt; 와 함께 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8e6c324c4e7440184ef28eb2f6fc1fca5a4a325" translate="yes" xml:space="preserve">
          <source>Use &amp;lt;regex&amp;gt; to decide what a word is, instead of considering runs of non-whitespace to be a word. Also implies &lt;code&gt;--word-diff&lt;/code&gt; unless it was already enabled.</source>
          <target state="translated">공백이 아닌 단어를 단어로 간주하는 대신 &amp;lt;regex&amp;gt;를 사용하여 단어가 무엇인지 결정하십시오. 또한 이미 활성화되어 있지 않은 경우 &lt;code&gt;--word-diff&lt;/code&gt; 를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="f70b8a97f949594b729b07efce2ca59a63023925" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;!&lt;/code&gt; to not make the corresponding negated long option available.</source>
          <target state="translated">사용 &lt;code&gt;!&lt;/code&gt; 해당 부정 긴 옵션을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f7924a219e6794d45a36b15b2c44738227b795ff" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; to set the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; explicitly. e.g., &quot;git remote set-head origin master&quot; will set the symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; to &lt;code&gt;refs/remotes/origin/master&lt;/code&gt;. This will only work if &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; already exists; if not it must be fetched first.</source>
          <target state="translated">사용 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 기호-REF 설정 &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 명시 적으로. 예를 들어, &quot;git remote set-head origin master&quot;는 symbolic-ref &lt;code&gt;refs/remotes/origin/HEAD&lt;/code&gt; 를 &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; 로 설정 합니다. &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; 이미 존재하는 경우에만 작동 합니다. 그렇지 않은 경우 먼저 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="d950943422ee3b93275d1e4b1e510463e5b432e0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; to contact a running cache daemon (or start a new cache daemon if one is not started). Defaults to &lt;code&gt;$XDG_CACHE_HOME/git/credential/socket&lt;/code&gt; unless &lt;code&gt;~/.git-credential-cache/&lt;/code&gt; exists in which case &lt;code&gt;~/.git-credential-cache/socket&lt;/code&gt; is used instead. If your home directory is on a network-mounted filesystem, you may need to change this to a local filesystem. You must specify an absolute path.</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 를 사용 하여 실행중인 캐시 디먼에 접속하십시오 (또는 시작되지 않은 경우 새 캐시 디먼을 시작하십시오). &lt;code&gt;~/.git-credential-cache/&lt;/code&gt; 가 없으면 &lt;code&gt;~/.git-credential-cache/socket&lt;/code&gt; 이 대신 사용 되지 않는 한 기본값은 &lt;code&gt;$XDG_CACHE_HOME/git/credential/socket&lt;/code&gt; 입니다. 홈 디렉토리가 네트워크 마운트 파일 시스템에있는 경우이를 로컬 파일 시스템으로 변경해야합니다. 절대 경로를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="faabe60607ec900b5e4ad4f074b4870d8f9c10c6" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; to lookup and store credentials. The file will have its filesystem permissions set to prevent other users on the system from reading it, but will not be encrypted or otherwise protected. If not specified, credentials will be searched for from &lt;code&gt;~/.git-credentials&lt;/code&gt; and &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt;, and credentials will be written to &lt;code&gt;~/.git-credentials&lt;/code&gt; if it exists, or &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; if it exists and the former does not. See also &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;.</source>
          <target state="translated">자격 증명을 조회하고 저장 하려면 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 를 사용하십시오 . 파일의 파일 시스템 권한은 시스템의 다른 사용자가 읽을 수 없도록 설정되어 있지만 암호화되거나 보호되지는 않습니다. 지정하지 않으면 &lt;code&gt;~/.git-credentials&lt;/code&gt; 및 &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; 에서 신임 정보가 검색되고 &lt;code&gt;~/.git-credentials&lt;/code&gt; ( 존재하는 경우) 또는 &lt;code&gt;$XDG_CONFIG_HOME/git/credentials&lt;/code&gt; 존재하는 경우)에 신임 정보 가 기록됩니다. 전자는 그렇지 않습니다. &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aadb92eae500ef695bbe6a445720ce25246dd04e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;*&lt;/code&gt; to mean that this option should not be listed in the usage generated for the &lt;code&gt;-h&lt;/code&gt; argument. It&amp;rsquo;s shown for &lt;code&gt;--help-all&lt;/code&gt; as documented in &lt;a href=&quot;gitcli&quot;&gt;gitcli[7]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 를 사용 하여이 옵션이 &lt;code&gt;-h&lt;/code&gt; 인수에 대해 생성 된 사용법에 나열되어서는 안됨을 의미합니다 . &lt;a href=&quot;gitcli&quot;&gt;gitcli [7]에&lt;/a&gt; 설명 된대로 &lt;code&gt;--help-all&lt;/code&gt; 에 대해 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3bbcee2a044e9c08185b38acb1e1c57ceea88054" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;--no-guess&lt;/code&gt; to disable this.</source>
          <target state="translated">이를 비활성화 하려면 &lt;code&gt;--no-guess&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6deefc2a8fa6667ca14a90dee15faf81b1f0546a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;-o master&lt;/code&gt; for continuing an import that was initially done by the old cvs2git tool.</source>
          <target state="translated">이전 cvs2git 도구에서 처음 수행 한 가져 오기를 계속 하려면 &lt;code&gt;-o master&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a4527eec708654a210ce88433047c8e573fb91f2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;-r&lt;/code&gt; together with &lt;code&gt;-d&lt;/code&gt; to delete remote-tracking branches. Note, that it only makes sense to delete remote-tracking branches if they no longer exist in the remote repository or if &lt;code&gt;git fetch&lt;/code&gt; was configured not to fetch them again. See also the &lt;code&gt;prune&lt;/code&gt; subcommand of &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt; for a way to clean up all obsolete remote-tracking branches.</source>
          <target state="translated">원격 추적 분기를 삭제 하려면 &lt;code&gt;-r&lt;/code&gt; 을 &lt;code&gt;-d&lt;/code&gt; 와 함께 사용하십시오 . 원격 추적 분기가 더 이상 원격 저장소에 존재하지 않거나 &lt;code&gt;git fetch&lt;/code&gt; 가 다시 가져 오지 않도록 구성된 경우에만 원격 추적 분기를 삭제하는 것이 좋습니다 . 더 이상 사용되지 않는 모든 원격 추적 분기를 정리하는 방법 은 &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; 의 &lt;code&gt;prune&lt;/code&gt; 하위 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb7d25cab29167524de808a8da669505756898ee" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;=&lt;/code&gt; if the option takes an argument.</source>
          <target state="translated">옵션에 인수가 있으면 &lt;code&gt;=&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d247642d4c8609f74c2030daa3d24c7c82d2e46d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;?&lt;/code&gt; to mean that the option takes an optional argument. You probably want to use the &lt;code&gt;--stuck-long&lt;/code&gt; mode to be able to unambiguously parse the optional argument.</source>
          <target state="translated">사용 &lt;code&gt;?&lt;/code&gt; 옵션이 옵션 인수를 취한다는 것을 의미합니다. &lt;code&gt;--stuck-long&lt;/code&gt; 모드 를 사용 하여 선택적 인수를 명확하게 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7929eb6fd77d1ea35c9c481fc89518eafcc1cd45" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git bisect&lt;/code&gt; to get a short usage description, and &lt;code&gt;git bisect
help&lt;/code&gt; or &lt;code&gt;git bisect -h&lt;/code&gt; to get a long usage description.</source>
          <target state="translated">&lt;code&gt;git bisect&lt;/code&gt; 를 사용 하여 짧은 사용법 설명을 얻고 &lt;code&gt;git bisect help&lt;/code&gt; 또는 &lt;code&gt;git bisect -h&lt;/code&gt; 를 사용하여 긴 사용법 설명을 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="599c65a25784af23c9351ba6f4874c534a65a263" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git cherry origin&lt;/code&gt; to see which ones of your patches were accepted, and/or use &lt;code&gt;git rebase origin&lt;/code&gt; to port your unmerged changes forward to the updated upstream.</source>
          <target state="translated">&lt;code&gt;git cherry origin&lt;/code&gt; 을 사용 하여 어떤 패치가 수락되었는지 확인하거나 &lt;code&gt;git rebase origin&lt;/code&gt; 을 사용 하여 병합되지 않은 변경 사항을 업데이트 된 업스트림으로 포팅하십시오.</target>
        </trans-unit>
        <trans-unit id="f1986201248cbf297f2fb86d6f520b30d057ce7d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; or &lt;code&gt;git remote update&lt;/code&gt; to stay up to date.</source>
          <target state="translated">사용은 &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; 이나 &lt;code&gt;git remote update&lt;/code&gt; 최신 상태로 유지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="252ef42d37b56d31d5e5dc2525ae974052dfca91" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git format-patch origin&lt;/code&gt; to prepare patches for e-mail submission to your upstream and send it out. Go back to step 2. and continue.</source>
          <target state="translated">&lt;code&gt;git format-patch origin&lt;/code&gt; 을 사용 하여 전자 메일을 업스트림에 제출할 패치를 준비한 후 발송하십시오. 2 단계로 돌아가서 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="cd30f3ed950161de3f8267d9a18953af3c02784f" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git mergetool&lt;/code&gt; to run one of several merge utilities to resolve merge conflicts. It is typically run after &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git mergetool&lt;/code&gt; 을 사용 하여 여러 병합 유틸리티 중 하나를 실행하여 병합 충돌을 해결하십시오. 일반적으로 &lt;code&gt;git merge&lt;/code&gt; 후에 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="6b298c06fc405635f29d06efdf0f42592d8075f2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git rev-parse&lt;/code&gt; in option parsing mode (see PARSEOPT section below).</source>
          <target state="translated">옵션 구문 분석 모드에서 &lt;code&gt;git rev-parse&lt;/code&gt; 를 사용 하십시오 (아래 PARSEOPT 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="7c9820d48befbd19730095f238fb8a15824823ad" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git rev-parse&lt;/code&gt; in shell quoting mode (see SQ-QUOTE section below). In contrast to the &lt;code&gt;--sq&lt;/code&gt; option below, this mode does only quoting. Nothing else is done to command input.</source>
          <target state="translated">쉘 인용 모드에서 &lt;code&gt;git rev-parse&lt;/code&gt; 를 사용하십시오 (아래 SQ-QUOTE 섹션 참조). 아래 의 &lt;code&gt;--sq&lt;/code&gt; 옵션과 달리이 모드는 인용 만합니다 . 입력을 명령하기위한 다른 작업은 없습니다.</target>
        </trans-unit>
        <trans-unit id="4c4d44083fa5e2a6971987cf935297be30994f4c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stash&lt;/code&gt; when you want to record the current state of the working directory and the index, but want to go back to a clean working directory. The command saves your local modifications away and reverts the working directory to match the &lt;code&gt;HEAD&lt;/code&gt; commit.</source>
          <target state="translated">작업 디렉토리 및 색인의 현재 상태를 기록하지만 깨끗한 작업 디렉토리로 돌아가려면 &lt;code&gt;git stash&lt;/code&gt; 를 사용하십시오 . 이 명령은 로컬 수정 사항을 저장하고 &lt;code&gt;HEAD&lt;/code&gt; 커밋 과 일치하도록 작업 디렉토리를 되돌 립니다.</target>
        </trans-unit>
        <trans-unit id="41c11f9d8154a7d9c49ff48bc15e09cdeb4a9a5c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stripspace --strip-comments&lt;/code&gt; to obtain:</source>
          <target state="translated">사용 &lt;code&gt;git stripspace --strip-comments&lt;/code&gt; 얻을 :</target>
        </trans-unit>
        <trans-unit id="141b00818c5025cc15ff515d81283fc5705a8a4e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stripspace&lt;/code&gt; with no arguments to obtain:</source>
          <target state="translated">인수없이 &lt;code&gt;git stripspace&lt;/code&gt; 를 사용 하여 다음을 확보하십시오.</target>
        </trans-unit>
        <trans-unit id="ae0479a18945009a7ebac30bdfceaa72c61a99c4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ident&lt;/code&gt; in the &lt;code&gt;From:&lt;/code&gt; header of each commit email. If the author ident of the commit is not textually identical to the provided &lt;code&gt;ident&lt;/code&gt;, place a &lt;code&gt;From:&lt;/code&gt; header in the body of the message with the original author. If no &lt;code&gt;ident&lt;/code&gt; is given, use the committer ident.</source>
          <target state="translated">각 커밋 이메일 의 &lt;code&gt;From:&lt;/code&gt; 헤더에 &lt;code&gt;ident&lt;/code&gt; 를 사용하십시오 . 커밋의 작성자 ID가 제공된 &lt;code&gt;ident&lt;/code&gt; 와 텍스트 적으로 동일하지 않은 경우 원래 작성자와 함께 메시지 본문에 &lt;code&gt;From:&lt;/code&gt; 헤더를 배치하십시오. &lt;code&gt;ident&lt;/code&gt; 가 없으면 커미터 아이디를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8fb68f530aa46816206d7ea34908da4d297edef3" translate="yes" xml:space="preserve">
          <source>Use IPv4 addresses only, ignoring IPv6 addresses.</source>
          <target state="translated">IPv6 주소는 무시하고 IPv4 주소 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d89ac89f76f16a68a863b0d9f578ffd1a558d6b0" translate="yes" xml:space="preserve">
          <source>Use IPv6 addresses only, ignoring IPv4 addresses.</source>
          <target state="translated">IPv4 주소는 무시하고 IPv6 주소 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="23206ddfb8d01b68973d7bd9cccf799f208e3657" translate="yes" xml:space="preserve">
          <source>Use Message &amp;rarr; Insert file&amp;hellip;​ and insert the patch.</source>
          <target state="translated">메시지 &amp;rarr; 파일 삽입&amp;hellip;을 사용하고 패치를 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="1b7e380bb9ef947a64359e01f17ce54cd3bdece1" translate="yes" xml:space="preserve">
          <source>Use One Mark Per Commit</source>
          <target state="translated">커밋 당 하나의 마크 사용</target>
        </trans-unit>
        <trans-unit id="c24268aab2b43d4e294643c8fbcbd60d377e139b" translate="yes" xml:space="preserve">
          <source>Use POSIX extended/basic regexp for patterns. Default is to use basic regexp.</source>
          <target state="translated">패턴에 POSIX 확장 / 기본 정규식을 사용하십시오. 기본은 기본 정규 표현식을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="36e96e4a2fd002679f3b794b4968539810c5c2eb" translate="yes" xml:space="preserve">
          <source>Use Perl-compatible regular expressions for patterns.</source>
          <target state="translated">패턴에 Perl 호환 정규식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fd46ce4ee0de88bb1a4ebb0e0c6375d24c2fb065" translate="yes" xml:space="preserve">
          <source>Use SO_REUSEADDR when binding the listening socket. This allows the server to restart without waiting for old connections to time out.</source>
          <target state="translated">청취 소켓을 바인딩 할 때 SO_REUSEADDR을 사용하십시오. 따라서 이전 연결 시간이 초과 될 때까지 기다리지 않고 서버를 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f351ffbdfc957393f82f6653e37778e19987b350" translate="yes" xml:space="preserve">
          <source>Use Tag Fixup Branches</source>
          <target state="translated">태그 수정 지점 사용</target>
        </trans-unit>
        <trans-unit id="67640e675158aa473b8a69cc0cdb46fb8ed7283f" translate="yes" xml:space="preserve">
          <source>Use a &quot;stable&quot; sum of hashes as the patch ID. With this option:</source>
          <target state="translated">패치 ID로 &quot;안정한&quot;해시 합계를 사용하십시오. 이 옵션을 사용하면</target>
        </trans-unit>
        <trans-unit id="0ec5feaf620cc0230519584645c952a1ae99d83c" translate="yes" xml:space="preserve">
          <source>Use a client spec to find the list of interesting files in p4. See the &quot;CLIENT SPEC&quot; section below.</source>
          <target state="translated">클라이언트 사양을 사용하여 p4에서 흥미로운 파일 목록을 찾으십시오. 아래의 &quot;CLIENT SPEC&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cf410607b4d646fae6b37dffcb3f37fcc481f52b" translate="yes" xml:space="preserve">
          <source>Use a mergetool. &lt;code&gt;git mergetool&lt;/code&gt; to launch a graphical mergetool which will work you through the merge.</source>
          <target state="translated">mergetool을 사용하십시오. &lt;code&gt;git mergetool&lt;/code&gt; 을 사용하면 병합을 통해 그래픽 병합 도구를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7589df3d820308df2c8a838829de10cfbcf2077" translate="yes" xml:space="preserve">
          <source>Use a special line-based format intended for script consumption. Added/removed/unchanged runs are printed in the usual unified diff format, starting with a &lt;code&gt;+&lt;/code&gt;/&lt;code&gt;-&lt;/code&gt;/` ` character at the beginning of the line and extending to the end of the line. Newlines in the input are represented by a tilde &lt;code&gt;~&lt;/code&gt; on a line of its own.</source>
          <target state="translated">스크립트 사용을 위해 특수한 라인 기반 형식을 사용하십시오. 추가 / 제거 / 변경되지 않은 런은 줄의 시작 부분에 &lt;code&gt;+&lt;/code&gt; / &lt;code&gt;-&lt;/code&gt; /``문자로 시작하여 줄 끝까지 확장되는 일반적인 통합 diff 형식으로 인쇄됩니다 . 입력 의 줄 바꿈은 자체 줄에 물결표 ( &lt;code&gt;~&lt;/code&gt; ) 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="77b024aefcbc37a1627539595d18a928f0842816" translate="yes" xml:space="preserve">
          <source>Use a tarball as a starting point for a new repository.</source>
          <target state="translated">tarball을 새 저장소의 시작점으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="afac3b09febbe243aa11caf12f594c7284e7bf23" translate="yes" xml:space="preserve">
          <source>Use an &quot;unstable&quot; hash as the patch ID. With this option, the result produced is compatible with the patch-id value produced by git 1.9 and older. Users with pre-existing databases storing patch-ids produced by git 1.9 and older (who do not deal with reordered patches) may want to use this option.</source>
          <target state="translated">&quot;불안정한&quot;해시를 패치 ID로 사용하십시오. 이 옵션을 사용하면 생성 된 결과가 git 1.9 이상에서 생성 된 patch-id 값과 호환됩니다. git 1.9 이상에서 생성 된 패치 ID를 저장하는 기존 데이터베이스를 가진 사용자 (재주문 된 패치를 처리하지 않는)는이 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef4088fc09156b38070cb26da8281dc7bfd8c504" translate="yes" xml:space="preserve">
          <source>Use an atomic transaction for updating the refs. If any of the refs fails to update then the entire push will fail without changing any refs.</source>
          <target state="translated">심판을 업데이트하기 위해 원 자성 트랜잭션을 사용하십시오. 심판이 업데이트에 실패하면 심판을 변경하지 않고 전체 푸시가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="049c3e05f1b188c69413c7549059c67376f76ed1" translate="yes" xml:space="preserve">
          <source>Use an atomic transaction on the remote side if available. Either all refs are updated, or on error, no refs are updated. If the server does not support atomic pushes the push will fail.</source>
          <target state="translated">가능한 경우 원격 측에서 원자 트랜잭션을 사용하십시오. 모든 심판이 업데이트되거나 오류가 발생하면 심판이 업데이트되지 않습니다. 서버가 원자 푸시를 지원하지 않으면 푸시가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="e55fb404106de44576d9bc731a7fb4baf9a6337c" translate="yes" xml:space="preserve">
          <source>Use binary search to find the commit that introduced a bug</source>
          <target state="translated">이진 검색을 사용하여 버그가 발생한 커밋 찾기</target>
        </trans-unit>
        <trans-unit id="78ee9b127501691d305b39cc3fc13fc74a1d22a1" translate="yes" xml:space="preserve">
          <source>Use customized color for &lt;code&gt;git add --interactive&lt;/code&gt; and &lt;code&gt;git clean --interactive&lt;/code&gt; output. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; may be &lt;code&gt;prompt&lt;/code&gt;, &lt;code&gt;header&lt;/code&gt;, &lt;code&gt;help&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;, for four distinct types of normal output from interactive commands.</source>
          <target state="translated">&lt;code&gt;git add --interactive&lt;/code&gt; 및 &lt;code&gt;git clean --interactive&lt;/code&gt; 출력에 사용자 정의 색상을 사용하십시오 . &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 대화식 명령의 네 가지 고유 한 유형의 일반 출력에 대해 &lt;code&gt;prompt&lt;/code&gt; , &lt;code&gt;header&lt;/code&gt; , &lt;code&gt;help&lt;/code&gt; 또는 &lt;code&gt;error&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf3aeb7f00c3d69ade01b5cc321078d4f50948ae" translate="yes" xml:space="preserve">
          <source>Use customized color for &lt;code&gt;git log --decorate&lt;/code&gt; output. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;branch&lt;/code&gt;, &lt;code&gt;remoteBranch&lt;/code&gt;, &lt;code&gt;tag&lt;/code&gt;, &lt;code&gt;stash&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt; for local branches, remote-tracking branches, tags, stash and HEAD, respectively and &lt;code&gt;grafted&lt;/code&gt; for grafted commits.</source>
          <target state="translated">&lt;code&gt;git log --decorate&lt;/code&gt; 출력에 사용자 정의 색상을 사용하십시오 . &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 중 하나 &lt;code&gt;branch&lt;/code&gt; , &lt;code&gt;remoteBranch&lt;/code&gt; , &lt;code&gt;tag&lt;/code&gt; , &lt;code&gt;stash&lt;/code&gt; 또는 &lt;code&gt;HEAD&lt;/code&gt; 분기 태그 숨기고 HEAD 각각 원격 추적 로컬 브랜치에 대한 &lt;code&gt;grafted&lt;/code&gt; 그래프트 커밋한다.</target>
        </trans-unit>
        <trans-unit id="29ecef38edab0e1998d46583be9558cf2a562eff" translate="yes" xml:space="preserve">
          <source>Use customized color for branch coloration. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;current&lt;/code&gt; (the current branch), &lt;code&gt;local&lt;/code&gt; (a local branch), &lt;code&gt;remote&lt;/code&gt; (a remote-tracking branch in refs/remotes/), &lt;code&gt;upstream&lt;/code&gt; (upstream tracking branch), &lt;code&gt;plain&lt;/code&gt; (other refs).</source>
          <target state="translated">브랜치 착색에 사용자 정의 색상을 사용하십시오. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 &lt;code&gt;current&lt;/code&gt; (현재 분기), &lt;code&gt;local&lt;/code&gt; (로컬 분기), &lt;code&gt;remote&lt;/code&gt; (참조 / 원격 /의 원격 추적 분기), &lt;code&gt;upstream&lt;/code&gt; (업스트림 추적 분기), &lt;code&gt;plain&lt;/code&gt; (기타 참조) 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="fcdeebdb47ef8466da45d806c0dccf091f4447a0" translate="yes" xml:space="preserve">
          <source>Use customized color for diff colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; specifies which part of the patch to use the specified color, and is one of &lt;code&gt;context&lt;/code&gt; (context text - &lt;code&gt;plain&lt;/code&gt; is a historical synonym), &lt;code&gt;meta&lt;/code&gt; (metainformation), &lt;code&gt;frag&lt;/code&gt; (hunk header), &lt;code&gt;func&lt;/code&gt; (function in hunk header), &lt;code&gt;old&lt;/code&gt; (removed lines), &lt;code&gt;new&lt;/code&gt; (added lines), &lt;code&gt;commit&lt;/code&gt; (commit headers), &lt;code&gt;whitespace&lt;/code&gt; (highlighting whitespace errors), &lt;code&gt;oldMoved&lt;/code&gt; (deleted lines), &lt;code&gt;newMoved&lt;/code&gt; (added lines), &lt;code&gt;oldMovedDimmed&lt;/code&gt;, &lt;code&gt;oldMovedAlternative&lt;/code&gt;, &lt;code&gt;oldMovedAlternativeDimmed&lt;/code&gt;, &lt;code&gt;newMovedDimmed&lt;/code&gt;, &lt;code&gt;newMovedAlternative&lt;/code&gt;&lt;code&gt;newMovedAlternativeDimmed&lt;/code&gt; (See the &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; setting of &lt;code&gt;--color-moved&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; for details), &lt;code&gt;contextDimmed&lt;/code&gt;, &lt;code&gt;oldDimmed&lt;/code&gt;, &lt;code&gt;newDimmed&lt;/code&gt;, &lt;code&gt;contextBold&lt;/code&gt;, &lt;code&gt;oldBold&lt;/code&gt;, and &lt;code&gt;newBold&lt;/code&gt; (see &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff[1]&lt;/a&gt; for details).</source>
          <target state="translated">diff 착색을 위해 맞춤형 색상을 사용하십시오. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 패치에서 지정된 색상을 사용할 부분을 지정하며 &lt;code&gt;context&lt;/code&gt; (컨텍스트 텍스트- &lt;code&gt;plain&lt;/code&gt; 은 역사적 동의어 임), &lt;code&gt;meta&lt;/code&gt; (제조), &lt;code&gt;frag&lt;/code&gt; (행크 헤더), &lt;code&gt;func&lt;/code&gt; (행크 헤더의 함수) 중 하나입니다. &lt;code&gt;old&lt;/code&gt; (제거 된 줄), &lt;code&gt;new&lt;/code&gt; (추가 된 줄), &lt;code&gt;commit&lt;/code&gt; (커밋 헤더), &lt;code&gt;whitespace&lt;/code&gt; (공백 공백 오류), &lt;code&gt;oldMoved&lt;/code&gt; (삭제 된 줄), &lt;code&gt;newMoved&lt;/code&gt; (추가 된 줄), &lt;code&gt;oldMovedDimmed&lt;/code&gt; , &lt;code&gt;oldMovedAlternative&lt;/code&gt; , &lt;code&gt;oldMovedAlternativeDimmed&lt;/code&gt; , &lt;code&gt;newMovedDimmed&lt;/code&gt; , &lt;code&gt;newMovedAlternative&lt;/code&gt; &lt;code&gt;newMovedAlternativeDimmed&lt;/code&gt; (자세한 내용은 &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 에서 &lt;code&gt;--color-moved&lt;/code&gt; 의 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 설정 참조), &lt;code&gt;contextDimmed&lt;/code&gt; , &lt;code&gt;oldDimmed&lt;/code&gt; , &lt;code&gt;newDimmed&lt;/code&gt; , &lt;code&gt;contextBold&lt;/code&gt; , &lt;code&gt;oldBold&lt;/code&gt; 및 &lt;code&gt;newBold&lt;/code&gt; ( &lt;a href=&quot;git-range-diff&quot;&gt;git-range&lt;/a&gt; 참조 ) 1] 자세한 내용을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="799532fe06b09693cab5782f0c7b74d1305d2cb1" translate="yes" xml:space="preserve">
          <source>Use customized color for each remote keyword. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; may be &lt;code&gt;hint&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, &lt;code&gt;success&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt; which match the corresponding keyword.</source>
          <target state="translated">각 원격 키워드에 맞춤 색상을 사용하십시오. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 해당 키워드와 일치하는 &lt;code&gt;hint&lt;/code&gt; , &lt;code&gt;warning&lt;/code&gt; , &lt;code&gt;success&lt;/code&gt; 또는 &lt;code&gt;error&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8363e3bb3b19269f1bec63465f050d08c7400a8" translate="yes" xml:space="preserve">
          <source>Use customized color for grep colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; specifies which part of the line to use the specified color, and is one of</source>
          <target state="translated">grep 착색을 위해 사용자 정의 색상을 사용하십시오. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 지정된 색상을 사용할 줄 부분을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3d940f7a54cc13b6b8a420b163ce2b7e4ccedf38" translate="yes" xml:space="preserve">
          <source>Use customized color for hints.</source>
          <target state="translated">힌트에 사용자 정의 색상을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a7bc0186c1d40a59aee910eedb6524484cbce3a0" translate="yes" xml:space="preserve">
          <source>Use customized color for push errors.</source>
          <target state="translated">푸시 오류에는 사용자 정의 색상을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="efd1e4b094e6a540e69b42772ae161651f4648a2" translate="yes" xml:space="preserve">
          <source>Use customized color for status colorization. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;header&lt;/code&gt; (the header text of the status message), &lt;code&gt;added&lt;/code&gt; or &lt;code&gt;updated&lt;/code&gt; (files which are added but not committed), &lt;code&gt;changed&lt;/code&gt; (files which are changed but not added in the index), &lt;code&gt;untracked&lt;/code&gt; (files which are not tracked by Git), &lt;code&gt;branch&lt;/code&gt; (the current branch), &lt;code&gt;nobranch&lt;/code&gt; (the color the &lt;code&gt;no branch&lt;/code&gt; warning is shown in, defaulting to red), &lt;code&gt;localBranch&lt;/code&gt; or &lt;code&gt;remoteBranch&lt;/code&gt; (the local and remote branch names, respectively, when branch and tracking information is displayed in the status short-format), or &lt;code&gt;unmerged&lt;/code&gt; (files which have unmerged changes).</source>
          <target state="translated">상태 색상 지정에 사용자 정의 색상을 사용하십시오. &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 &lt;code&gt;header&lt;/code&gt; (상태 메시지의 헤더 텍스트), &lt;code&gt;added&lt;/code&gt; 또는 &lt;code&gt;updated&lt;/code&gt; (추가되었지만 커밋되지 않은 파일 ), &lt;code&gt;changed&lt;/code&gt; (인덱스에서 변경되었지만 추가되지 않은 파일 ), &lt;code&gt;untracked&lt;/code&gt; 되지 않은 파일 중 하나입니다. 힘내)에 의해 추적 &lt;code&gt;branch&lt;/code&gt; (현 지사) &lt;code&gt;nobranch&lt;/code&gt; (상기 컬러 &lt;code&gt;no branch&lt;/code&gt; 경고에 도시되며, 적색에 디폴트) &lt;code&gt;localBranch&lt;/code&gt; 또는 &lt;code&gt;remoteBranch&lt;/code&gt; 분기 및 추적 정보가 표시된다 (각각의 로컬 및 원격 지점 이름, 상태 짧은 형식) 또는 &lt;code&gt;unmerged&lt;/code&gt; (변경되지 않은 변경 사항이있는 파일).</target>
        </trans-unit>
        <trans-unit id="42006ecfd08deb9b3ff0a3f1d7240d8f715710f3" translate="yes" xml:space="preserve">
          <source>Use customized color when a push was rejected.</source>
          <target state="translated">푸시가 거부되면 사용자 정의 색상을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7714f2243f3ecb7a0c915a75f0d9677bee5cfddf" translate="yes" xml:space="preserve">
          <source>Use fixed strings for patterns (don&amp;rsquo;t interpret pattern as a regex).</source>
          <target state="translated">패턴에 고정 문자열을 사용하십시오 (패턴을 정규식으로 해석하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="be83392780575c9c0f338875e4ab41fca7ad0580" translate="yes" xml:space="preserve">
          <source>Use given directory for the location of Git objects. We check &lt;code&gt;&amp;lt;dir&amp;gt;/packs/multi-pack-index&lt;/code&gt; for the current MIDX file, and &lt;code&gt;&amp;lt;dir&amp;gt;/packs&lt;/code&gt; for the pack-files to index.</source>
          <target state="translated">Git 객체의 위치에 지정된 디렉토리를 사용하십시오. 우리는 확인 &lt;code&gt;&amp;lt;dir&amp;gt;/packs/multi-pack-index&lt;/code&gt; 현재 MIDX 파일 및 &lt;code&gt;&amp;lt;dir&amp;gt;/packs&lt;/code&gt; 인덱스 팩 - 파일.</target>
        </trans-unit>
        <trans-unit id="58e0e6d68f2b1086e2f61cc3ccf9bb473fce2cb1" translate="yes" xml:space="preserve">
          <source>Use given directory for the location of packfiles and commit-graph file. This parameter exists to specify the location of an alternate that only has the objects directory, not a full &lt;code&gt;.git&lt;/code&gt; directory. The commit-graph file is expected to be in the &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; directory and the packfiles are expected to be in &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt;.</source>
          <target state="translated">packfile 및 commit-graph 파일의 위치에 지정된 디렉토리를 사용하십시오. 이 매개 변수는 전체 &lt;code&gt;.git&lt;/code&gt; 디렉토리가 아닌 objects 디렉토리 만있는 대체의 위치를 ​​지정하기 위해 존재합니다 . 커밋 그래프 파일은 &lt;code&gt;&amp;lt;dir&amp;gt;/info&lt;/code&gt; 디렉토리에 있고 packfiles는 &lt;code&gt;&amp;lt;dir&amp;gt;/pack&lt;/code&gt; 에 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="9e22ac3ec044552fceb6f971a8409c3fc735d918" translate="yes" xml:space="preserve">
          <source>Use gmail as the smtp server</source>
          <target state="translated">Gmail을 SMTP 서버로 사용</target>
        </trans-unit>
        <trans-unit id="243e0ec42451f8d223cf0a086b6e0d020fe017bc" translate="yes" xml:space="preserve">
          <source>Use hash &lt;code&gt;#&lt;/code&gt; for comments that are either on their own line, or after the email address.</source>
          <target state="translated">자체 줄에 있거나 전자 메일 주소 뒤에있는 주석 에는 해시 &lt;code&gt;#&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe4290ca9cf2dcf165b3911c20fcc8115cf36b09" translate="yes" xml:space="preserve">
          <source>Use libcurl to communicate with the IMAP server, unless tunneling into it. Ignored if Git was built without the USE_CURL_FOR_IMAP_SEND option set.</source>
          <target state="translated">터널링하지 않는 한 libcurl을 사용하여 IMAP 서버와 통신하십시오. USE_CURL_FOR_IMAP_SEND 옵션을 설정하지 않고 Git을 빌드 한 경우 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b43e2a7c9e04ff83908291bc454ceb95c66f26d2" translate="yes" xml:space="preserve">
          <source>Use mailmap file to map author and committer names and email addresses to canonical real names and email addresses. See &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt;.</source>
          <target state="translated">메일 맵 파일을 사용하여 작성자 및 커미터 이름 및 이메일 주소를 표준 실제 이름 및 이메일 주소에 맵핑하십시오. &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="869311b9e64386ec94c4224dbda98ca212bcb863" translate="yes" xml:space="preserve">
          <source>Use merging strategies to rebase. When the recursive (default) merge strategy is used, this allows rebase to be aware of renames on the upstream side.</source>
          <target state="translated">합병 전략을 사용하여 리베이스하십시오. 재귀 (기본) 병합 전략을 사용하면 업스트림 측에서 이름을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="504dd078aaf1ec972f6af826bbe142e1450759fa" translate="yes" xml:space="preserve">
          <source>Use of &quot;topic branches&quot; solves these problems. The name is pretty self explanatory, with a caveat that comes from the &quot;merge upwards&quot; rule above:</source>
          <target state="translated">&quot;주제 분기&quot;를 사용하면 이러한 문제가 해결됩니다. 이름은 위의 &quot;위로 병합&quot;규칙에서 비롯된 경고와 함께 매우 자명 한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="2997460999cadfc1fcc5d52315d53b3d5efcd07d" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;dcommit&lt;/code&gt; is preferred to &lt;code&gt;set-tree&lt;/code&gt; (below).</source>
          <target state="translated">&lt;code&gt;set-tree&lt;/code&gt; (아래) 보다 &lt;code&gt;dcommit&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6b08c4843a60fcea417d6fa6b7562621b3124054" translate="yes" xml:space="preserve">
          <source>Use of this utility is encouraged in favor of directly accessing files under the &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;.git&lt;/code&gt; 디렉토리 에있는 파일에 직접 액세스하기 위해이 유틸리티를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3a96544176d9c64bcdfe76616987380a83e4f896" translate="yes" xml:space="preserve">
          <source>Use permissions reported by umask(2). The default, when &lt;code&gt;--shared&lt;/code&gt; is not specified.</source>
          <target state="translated">umask (2)에 의해보고 된 권한을 사용하십시오. &lt;code&gt;--shared&lt;/code&gt; 가 지정되지 않은 경우 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="7b2e5a64a2bb1a5fbe6304abee401e1d3f35a8f4" translate="yes" xml:space="preserve">
          <source>Use reflog to find a better common ancestor between &amp;lt;upstream&amp;gt; and &amp;lt;branch&amp;gt; when calculating which commits have been introduced by &amp;lt;branch&amp;gt;.</source>
          <target state="translated">&amp;lt;branch&amp;gt;에 의해 어떤 커밋이 도입되었는지 계산할 때 reflog를 사용하여 &amp;lt;upstream&amp;gt;과 &amp;lt;branch&amp;gt; 사이에 더 나은 공통 조상을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="b40e39ff3f77007104d997879dd735023a9dca06" translate="yes" xml:space="preserve">
          <source>Use revisions from revs-file instead of calling &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt; 을 호출하는 대신 revs-file의 개정판을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="efb298546ca010c6e357a2c3cc79d1b86fb2f356" translate="yes" xml:space="preserve">
          <source>Use the &quot;sparse&quot; algorithm to determine which objects to include in the pack, when combined with the &quot;--revs&quot; option. This algorithm only walks trees that appear in paths that introduce new objects. This can have significant performance benefits when computing a pack to send a small change. However, it is possible that extra objects are added to the pack-file if the included commits contain certain types of direct renames.</source>
          <target state="translated">&quot;--pars&quot;옵션과 결합 될 때 팩에 포함 할 오브젝트를 결정하려면 &quot;스파 스&quot;알고리즘을 사용하십시오. 이 알고리즘은 새로운 객체를 도입하는 경로에 나타나는 트리 만 걷는다. 이것은 작은 변화를 보내기 위해 팩을 계산할 때 상당한 성능 이점을 가질 수 있습니다. 그러나 포함 된 커밋에 특정 유형의 직접 이름 바꾸기가 포함되어 있으면 추가 객체가 팩 파일에 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0755f10a2fd51824d1737b45b49a4642d66873f8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--in-place&lt;/code&gt; option to edit a message file in place:</source>
          <target state="translated">&lt;code&gt;--in-place&lt;/code&gt; 옵션을 사용하여 메시지 파일을 적절 하게 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="55e7e1126d3aa0a5c8bf2360dfcd495bb1107882" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute only if you cannot store a file in UTF-8 encoding and if you want Git to be able to process the content as text.</source>
          <target state="translated">사용 &lt;code&gt;working-tree-encoding&lt;/code&gt; 이 UTF-8 인코딩으로 파일을 저장할 수없는 경우에만 속성을 원하는 경우 힘내 텍스트로 내용을 처리 할 수 있도록.</target>
        </trans-unit>
        <trans-unit id="b5ec705c3f1e9d70bd95302efbf5732684172042" translate="yes" xml:space="preserve">
          <source>Use the branch detection algorithm to find new paths in p4. It is documented below in &quot;BRANCH DETECTION&quot;.</source>
          <target state="translated">p4에서 새 경로를 찾으려면 분기 감지 알고리즘을 사용하십시오. 아래의 &quot;브랜치 감지&quot;에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="33ac56041ae34da6b3682a94d8a665913a47636a" translate="yes" xml:space="preserve">
          <source>Use the credential (e.g., access the URL with the username and password from step (2)), and see if it&amp;rsquo;s accepted.</source>
          <target state="translated">자격 증명을 사용합니다 (예 : 2 단계의 사용자 이름과 비밀번호로 URL에 액세스).</target>
        </trans-unit>
        <trans-unit id="4cfefdd524d37cf0c1fedc168c903048fc636bbd" translate="yes" xml:space="preserve">
          <source>Use the customized color for the part of git-blame output that is repeated meta information per line (such as commit id, author name, date and timezone). Defaults to cyan.</source>
          <target state="translated">커밋 ID, 작성자 이름, 날짜 및 시간대와 같이 줄당 메타 정보가 반복되는 git-blame 출력 부분에 사용자 정의 된 색상을 사용하십시오. 기본적으로 청록색입니다.</target>
        </trans-unit>
        <trans-unit id="a024bae6c0f6ae8fa68e77c95e0c4f95100aa970" translate="yes" xml:space="preserve">
          <source>Use the diff tool specified by &amp;lt;tool&amp;gt;. Valid values include emerge, kompare, meld, and vimdiff. Run &lt;code&gt;git difftool --tool-help&lt;/code&gt; for the list of valid &amp;lt;tool&amp;gt; settings.</source>
          <target state="translated">&amp;lt;tool&amp;gt;에 지정된 diff 도구를 사용하십시오. 유효한 값은 emerge, kompare, meld 및 vimdiff입니다. 유효한 &amp;lt;tool&amp;gt; 설정 목록을 보려면 &lt;code&gt;git difftool --tool-help&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="161588bc8b76efbad18d428ccf6e2f5e459908d1" translate="yes" xml:space="preserve">
          <source>Use the fast patchset import strategy. This can be significantly faster for large trees, but cannot handle directory renames or permissions changes. The default strategy is slow and safe.</source>
          <target state="translated">빠른 패치 세트 가져 오기 전략을 사용하십시오. 이는 큰 트리의 경우 훨씬 빠를 수 있지만 디렉토리 이름 변경 또는 권한 변경은 처리 할 수 ​​없습니다. 기본 전략은 느리고 안전합니다.</target>
        </trans-unit>
        <trans-unit id="89541b63bc820ad5c76ea37101a62452ee62e61c" translate="yes" xml:space="preserve">
          <source>Use the following attributes if your &lt;code&gt;*.ps1&lt;/code&gt; files are UTF-16 little endian encoded without BOM and you want Git to use Windows line endings in the working directory (use &lt;code&gt;UTF-16LE-BOM&lt;/code&gt; instead of &lt;code&gt;UTF-16LE&lt;/code&gt; if you want UTF-16 little endian with BOM). Please note, it is highly recommended to explicitly define the line endings with &lt;code&gt;eol&lt;/code&gt; if the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute is used to avoid ambiguity.</source>
          <target state="translated">귀하의 경우 다음과 같은 속성을 사용하여 &lt;code&gt;*.ps1&lt;/code&gt; 입니다 (사용 파일이 BOM없이 인코딩 UTF-16 리틀 엔디안이고, 당신이 망할 놈의 작업 디렉토리에서 윈도우 라인 엔딩을 사용하려면 &lt;code&gt;UTF-16LE-BOM&lt;/code&gt; 대신 &lt;code&gt;UTF-16LE&lt;/code&gt; 을 당신은 UTF-16를 원하는 경우 BOM이있는 리틀 엔디 언). &lt;code&gt;working-tree-encoding&lt;/code&gt; 속성을 사용하여 모호성을 피하는 경우 &lt;code&gt;eol&lt;/code&gt; 로 줄 끝을 명시 적으로 정의하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e5c2f58b6a6ebc713504e60181f4f0dd37da2d6d" translate="yes" xml:space="preserve">
          <source>Use the given &amp;lt;msg&amp;gt; as the commit message. If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs.</source>
          <target state="translated">주어진 &amp;lt;msg&amp;gt;를 커밋 메시지로 사용하십시오. 여러 개의 &lt;code&gt;-m&lt;/code&gt; 옵션이 제공되면 해당 값은 별도의 단락으로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="be3b9715415e0357d3d87d01aa8f812c871fb1e1" translate="yes" xml:space="preserve">
          <source>Use the given &lt;code&gt;msg&lt;/code&gt; as the commit message. This option disables the &lt;code&gt;--edit&lt;/code&gt; option.</source>
          <target state="translated">주어진 &lt;code&gt;msg&lt;/code&gt; 를 커밋 메시지로 사용하십시오 . 이 옵션은 &lt;code&gt;--edit&lt;/code&gt; 옵션을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="43103d879018fa15a44cefa9b3baec705e25165c" translate="yes" xml:space="preserve">
          <source>Use the given config file instead of the one specified by GIT_CONFIG.</source>
          <target state="translated">GIT_CONFIG가 지정한 설정 파일 대신 지정된 설정 파일을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6d07104b51b424f44cb0346a9ac8f4116b0f06d7" translate="yes" xml:space="preserve">
          <source>Use the given exclude pattern in addition to the standard ignore rules (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;).</source>
          <target state="translated">표준 무시 규칙 외에도 주어진 제외 패턴을 사용하십시오 ( &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9a12bbd112f0b48f03fdbbbb0b9c68268bedd960" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy. If there is no &lt;code&gt;-s&lt;/code&gt; option &lt;code&gt;git merge-recursive&lt;/code&gt; is used instead. This implies --merge.</source>
          <target state="translated">주어진 병합 전략을 사용하십시오. &lt;code&gt;-s&lt;/code&gt; 옵션 이 없으면 &lt;code&gt;git merge-recursive&lt;/code&gt; 가 대신 사용됩니다. 이것은 --merge를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="aad779cdebc63bc4b25eb19e46a7b214101b70ea" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy. Should only be used once. See the MERGE STRATEGIES section in &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; for details.</source>
          <target state="translated">주어진 병합 전략을 사용하십시오. 한 번만 사용해야합니다. 자세한 내용은 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt; 의 MERGE STRATEGIES 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0d697cccd6049781089822f14d706ae91b43a781" translate="yes" xml:space="preserve">
          <source>Use the given merge strategy; can be supplied more than once to specify them in the order they should be tried. If there is no &lt;code&gt;-s&lt;/code&gt; option, a built-in list of strategies is used instead (&lt;code&gt;git merge-recursive&lt;/code&gt; when merging a single head, &lt;code&gt;git merge-octopus&lt;/code&gt; otherwise).</source>
          <target state="translated">주어진 병합 전략을 사용하십시오. 시도해야하는 순서대로 지정하기 위해 두 번 이상 제공 될 수 있습니다. &lt;code&gt;-s&lt;/code&gt; 옵션 이없는 경우 기본 제공 전략 목록이 대신 사용됩니다 ( 단일 헤드를 병합 할 때는 &lt;code&gt;git merge-recursive&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;git merge-octopus&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e15a6801b533c61848133f0481a1499ec359e784" translate="yes" xml:space="preserve">
          <source>Use the given note message (instead of prompting). If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs. Lines starting with &lt;code&gt;#&lt;/code&gt; and empty lines other than a single line between paragraphs will be stripped out.</source>
          <target state="translated">프롬프트 대신 지정된 메모 메시지를 사용하십시오. 여러 개의 &lt;code&gt;-m&lt;/code&gt; 옵션이 제공되면 해당 값은 별도의 단락으로 연결됩니다. &lt;code&gt;#&lt;/code&gt; 으로 시작하고 단락 사이의 한 줄 이외의 빈 줄은 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2301e57be484e5bf3374c6061960726be52acd3f" translate="yes" xml:space="preserve">
          <source>Use the given tag message (instead of prompting). If multiple &lt;code&gt;-m&lt;/code&gt; options are given, their values are concatenated as separate paragraphs. Implies &lt;code&gt;-a&lt;/code&gt; if none of &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, or &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; is given.</source>
          <target state="translated">프롬프트 대신 지정된 태그 메시지를 사용하십시오. 여러 개의 &lt;code&gt;-m&lt;/code&gt; 옵션이 제공되면 해당 값은 별도의 단락으로 연결됩니다. &lt;code&gt;-a&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; 또는 &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 가 없으면 &lt;code&gt;-a&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="52a6c166f490dbb0be0d25b65f46015f7e67e623" translate="yes" xml:space="preserve">
          <source>Use the interactive patch selection interface to chose which changes to commit. See &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; for details.</source>
          <target state="translated">대화식 패치 선택 인터페이스를 사용하여 커밋 할 변경 사항을 선택하십시오. 자세한 내용은 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7db128e87ada4e1ec3f3340d8431acfc429f3677" translate="yes" xml:space="preserve">
          <source>Use the merge resolution program specified by &amp;lt;tool&amp;gt;. Valid values include emerge, gvimdiff, kdiff3, meld, vimdiff, and tortoisemerge. Run &lt;code&gt;git mergetool --tool-help&lt;/code&gt; for the list of valid &amp;lt;tool&amp;gt; settings.</source>
          <target state="translated">&amp;lt;tool&amp;gt;에서 지정한 병합 해결 프로그램을 사용하십시오. 유효한 값은 emerge, gvimdiff, kdiff3, meld, vimdiff 및 tortoisemerge입니다. 유효한 &amp;lt;tool&amp;gt; 설정 목록을 보려면 &lt;code&gt;git mergetool --tool-help&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="047156e36b9d6e8b2155d32a029545b1b026f10e" translate="yes" xml:space="preserve">
          <source>Use the multi-pack-index file to track multiple packfiles using a single index. See &lt;a href=&quot;multi-pack-index&quot;&gt;the multi-pack-index design document&lt;/a&gt;.</source>
          <target state="translated">다중 팩 색인 파일을 사용하여 단일 색인을 사용하여 여러 팩 파일을 추적하십시오. &lt;a href=&quot;multi-pack-index&quot;&gt;다중 팩 인덱스 디자인 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6bac5b4ccbcc396e691c8ba8f2af89d4f60c9270" translate="yes" xml:space="preserve">
          <source>Use the same output mode as &lt;a href=&quot;git-annotate&quot;&gt;git-annotate[1]&lt;/a&gt; (Default: off).</source>
          <target state="translated">&lt;a href=&quot;git-annotate&quot;&gt;git-annotate [1]&lt;/a&gt; 과 동일한 출력 모드를 사용하십시오 (기본값 : off).</target>
        </trans-unit>
        <trans-unit id="0ed67a2ecd3a9ee96ae4cd7dcb45f48a2cf84bf4" translate="yes" xml:space="preserve">
          <source>Use the selected commit message without launching an editor. For example, &lt;code&gt;git commit --amend --no-edit&lt;/code&gt; amends a commit without changing its commit message.</source>
          <target state="translated">편집기를 시작하지 않고 선택된 커밋 메시지를 사용하십시오. 예를 들어, &lt;code&gt;git commit --amend --no-edit&lt;/code&gt; 는 커밋 메시지를 변경하지 않고 커밋을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="8e65c034e7da87d64be153e02b39a8529bd16f67" translate="yes" xml:space="preserve">
          <source>Use the source ref that matches &lt;code&gt;master&lt;/code&gt; (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) to update the ref that matches &lt;code&gt;satellite/master&lt;/code&gt; (most probably &lt;code&gt;refs/remotes/satellite/master&lt;/code&gt;) in the &lt;code&gt;mothership&lt;/code&gt; repository; do the same for &lt;code&gt;dev&lt;/code&gt; and &lt;code&gt;satellite/dev&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 와 일치하는 소스 참조 (예 : &lt;code&gt;refs/heads/master&lt;/code&gt; )를 사용 하여 &lt;code&gt;mothership&lt;/code&gt; 저장소의 &lt;code&gt;satellite/master&lt;/code&gt; (대부분 &lt;code&gt;refs/remotes/satellite/master&lt;/code&gt; ) 와 일치하는 참조를 업데이트하십시오 . &lt;code&gt;dev&lt;/code&gt; 및 &lt;code&gt;satellite/dev&lt;/code&gt; 에 대해 동일한 작업을 수행하십시오 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
