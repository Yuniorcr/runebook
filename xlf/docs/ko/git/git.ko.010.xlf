<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="3dfacf796b68e98a60c628fed43445479dc82ce1" translate="yes" xml:space="preserve">
          <source>The fast-import mechanism used by &lt;code&gt;git p4&lt;/code&gt; creates one pack file for each invocation of &lt;code&gt;git p4 sync&lt;/code&gt;. Normally, Git garbage compression (&lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;) automatically compresses these to fewer pack files, but explicit invocation of &lt;code&gt;git repack -adf&lt;/code&gt; may improve performance.</source>
          <target state="translated">&lt;code&gt;git p4&lt;/code&gt; 에서 사용하는 빠른 가져 오기 메커니즘 은 &lt;code&gt;git p4 sync&lt;/code&gt; 호출마다 하나의 팩 파일을 작성 합니다 . 일반적으로 Git 가비지 압축 ( &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt; ) &lt;code&gt;git repack -adf&lt;/code&gt; 파일을 더 적은 팩 파일로 자동 압축하지만 git repack -adf를 명시 적으로 호출 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53e903dc94674f5b365dd31d16a6c2e334c714e3" translate="yes" xml:space="preserve">
          <source>The fetch and push protocols are not designed to prevent one side from stealing data from the other repository that was not intended to be shared. If you have private data that you need to protect from a malicious peer, your best option is to store it in another repository. This applies to both clients and servers. In particular, namespaces on a server are not effective for read access control; you should only grant read access to a namespace to clients that you would trust with read access to the entire repository.</source>
          <target state="translated">페치 및 푸시 프로토콜은 한 쪽이 공유하지 않을 다른 리포지토리의 데이터를 훔치지 않도록 설계되지 않았습니다. 악의적 인 피어로부터 보호해야하는 개인 데이터가있는 경우 가장 좋은 방법은 다른 리포지토리에 저장하는 것입니다. 이것은 클라이언트와 서버 모두에 적용됩니다. 특히 서버의 네임 스페이스는 읽기 액세스 제어에 효과적이지 않습니다. 전체 저장소에 대한 읽기 권한으로 신뢰할 수있는 클라이언트에게 네임 스페이스에 대한 읽기 권한 만 부여해야합니다.</target>
        </trans-unit>
        <trans-unit id="648bf821f46e9909499e1fbac0dd96a1ab871eb7" translate="yes" xml:space="preserve">
          <source>The fields (including the &lt;code&gt;-&amp;gt;&lt;/code&gt;) are separated from each other by a single space. If a filename contains whitespace or other nonprintable characters, that field will be quoted in the manner of a C string literal: surrounded by ASCII double quote (34) characters, and with interior special characters backslash-escaped.</source>
          <target state="translated">필드 ( &lt;code&gt;-&amp;gt;&lt;/code&gt; 포함 )는 단일 공백으로 구분됩니다. 파일 이름에 공백이나 인쇄 할 수없는 다른 문자가 포함 된 경우 해당 필드는 C 문자열 리터럴 방식으로 인용됩니다. ASCII 큰 따옴표 (34) 문자로 묶고 내부 특수 문자는 백 슬래시로 이스케이프 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3994e582754827987cb1dab035b29a73b90c4b3e" translate="yes" xml:space="preserve">
          <source>The file consists of sections and variables. A section begins with the name of the section in square brackets and continues until the next section begins. Section names are case-insensitive. Only alphanumeric characters, &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;.&lt;/code&gt; are allowed in section names. Each variable must belong to some section, which means that there must be a section header before the first setting of a variable.</source>
          <target state="translated">파일은 섹션과 변수로 구성됩니다. 섹션은 대괄호 안에 섹션 이름으로 시작하고 다음 섹션이 시작될 때까지 계속됩니다. 섹션 이름은 대소 문자를 구분하지 않습니다. 영숫자 만 &lt;code&gt;-&lt;/code&gt; 및 &lt;code&gt;.&lt;/code&gt; 섹션 이름에 허용됩니다. 각 변수는 일부 섹션에 속해야합니다. 즉, 변수의 첫 번째 설정 전에 섹션 헤더가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b77694751b662ffffe51a33dc2cd7f9b8be897f4" translate="yes" xml:space="preserve">
          <source>The file contains one subsection per submodule, and the subsection value is the name of the submodule. The name is set to the path where the submodule has been added unless it was customized with the &lt;code&gt;--name&lt;/code&gt; option of &lt;code&gt;git submodule add&lt;/code&gt;. Each submodule section also contains the following required keys:</source>
          <target state="translated">파일은 서브 모듈 당 하나의 서브 섹션을 포함하며 서브 섹션 값은 서브 모듈의 이름입니다. &lt;code&gt;git submodule add&lt;/code&gt; 의 &lt;code&gt;--name&lt;/code&gt; 옵션 으로 사용자 정의되지 않은 경우 이름은 서브 모듈이 추가 된 경로로 설정됩니다 . 각 하위 모듈 섹션에는 다음과 같은 필수 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7d8ebbce919f993c68a8bac80b9fbb16d92024e" translate="yes" xml:space="preserve">
          <source>The file format includes parameters for the object ID hash function, so a future change of hash algorithm does not require a change in format.</source>
          <target state="translated">파일 형식에는 오브젝트 ID 해시 함수에 대한 매개 변수가 포함되므로 향후 해시 알고리즘 변경시 형식 변경이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bb6e340dc566db02505e0c4003761a9d85c40c1" translate="yes" xml:space="preserve">
          <source>The file is concluded with a trailer:</source>
          <target state="translated">파일은 예고편으로 마무리됩니다.</target>
        </trans-unit>
        <trans-unit id="996f5fbcdb16f7d7ee85c3a6ae77d46a1781884a" translate="yes" xml:space="preserve">
          <source>The file parameters can point at the user&amp;rsquo;s working file (e.g. &lt;code&gt;new-file&lt;/code&gt; in &quot;git-diff-files&quot;), &lt;code&gt;/dev/null&lt;/code&gt; (e.g. &lt;code&gt;old-file&lt;/code&gt; when a new file is added), or a temporary file (e.g. &lt;code&gt;old-file&lt;/code&gt; in the index). &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; should not worry about unlinking the temporary file --- it is removed when &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; exits.</source>
          <target state="translated">파일 매개 변수는 사용자의 작업 파일에서 (예를 가리킬 수 있습니다 &lt;code&gt;new-file&lt;/code&gt; &quot;자식-DIFF-파일&quot;의을) &lt;code&gt;/dev/null&lt;/code&gt; (예를 들어 &lt;code&gt;old-file&lt;/code&gt; 새로운 파일이 추가된다), 또는 임시 파일을 (예를 들어 &lt;code&gt;old-file&lt;/code&gt; 색인에 파일 ). &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 는 임시 파일의 연결을 해제하지 않아도 됩니다. --- &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 가 종료 될 때 제거 됩니다.</target>
        </trans-unit>
        <trans-unit id="b979e5d416845ad4db7c29ab613bf67d05d7d448" translate="yes" xml:space="preserve">
          <source>The files are read in the order given above, with last value found taking precedence over values read earlier. When multiple values are taken then all values of a key from all files will be used.</source>
          <target state="translated">파일은 위에 주어진 순서대로 읽히고 마지막 값은 이전에 읽은 값보다 우선합니다. 여러 값을 가져 오면 모든 파일의 모든 키 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="22cd650e22be9431ebec70f16e27f0954b25a243" translate="yes" xml:space="preserve">
          <source>The files to read the patch from. &lt;code&gt;-&lt;/code&gt; can be used to read from the standard input.</source>
          <target state="translated">패치를 읽을 파일입니다. &lt;code&gt;-&lt;/code&gt; 표준 입력에서 읽는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc839d554b73db3187cb52551b31c221d5647965" translate="yes" xml:space="preserve">
          <source>The filter is expected to respond with a list of &quot;key=value&quot; pairs terminated with a flush packet. If the filter does not experience problems then the list must contain a &quot;success&quot; status. Right after these packets the filter is expected to send the content in zero or more pkt-line packets and a flush packet at the end. Finally, a second list of &quot;key=value&quot; pairs terminated with a flush packet is expected. The filter can change the status in the second list or keep the status as is with an empty list. Please note that the empty list must be terminated with a flush packet regardless.</source>
          <target state="translated">필터는 플러시 패킷으로 종료 된 &quot;key = value&quot;쌍 목록으로 응답합니다. 필터에 문제가 없으면 목록에 &quot;성공&quot;상태가 포함되어야합니다. 이러한 패킷 바로 뒤에 필터는 0 개 이상의 pkt-line 패킷으로 콘텐츠를 전송하고 마지막에는 플러시 패킷을 전송합니다. 마지막으로 플러시 패킷으로 종료 된 &quot;key = value&quot;쌍의 두 번째 목록이 예상됩니다. 필터는 두 번째 목록의 상태를 변경하거나 빈 목록으로 상태를 유지할 수 있습니다. 빈 목록은 플러시 패킷으로 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="48c7b9e769ad1a8ac7a03d8a91befba4e1dc75d4" translate="yes" xml:space="preserve">
          <source>The filter that will be applied when fetching from this promisor remote.</source>
          <target state="translated">이 Promisor Remote에서 가져올 때 적용되는 필터입니다.</target>
        </trans-unit>
        <trans-unit id="67e1cbcd0bc26ca591869ec55e18981d4a05f31d" translate="yes" xml:space="preserve">
          <source>The filters are applied in the order as listed below. The &amp;lt;command&amp;gt; argument is always evaluated in the shell context using the &lt;code&gt;eval&lt;/code&gt; command (with the notable exception of the commit filter, for technical reasons). Prior to that, the &lt;code&gt;$GIT_COMMIT&lt;/code&gt; environment variable will be set to contain the id of the commit being rewritten. Also, GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_AUTHOR_DATE, GIT_COMMITTER_NAME, GIT_COMMITTER_EMAIL, and GIT_COMMITTER_DATE are taken from the current commit and exported to the environment, in order to affect the author and committer identities of the replacement commit created by &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; after the filters have run.</source>
          <target state="translated">필터는 아래 나열된 순서대로 적용됩니다. &amp;lt;command&amp;gt; 인수는 &lt;code&gt;eval&lt;/code&gt; 명령을 사용하여 쉘 컨텍스트에서 항상 평가됩니다 (기술적 인 이유로 커밋 필터는 예외). 그 전에 &lt;code&gt;$GIT_COMMIT&lt;/code&gt; 환경 변수는 다시 작성되는 커밋의 ID를 포함하도록 설정됩니다. 또한 GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_AUTHOR_DATE, GIT_COMMITTER_NAME, GIT_COMMITTER_EMAIL 및 GIT_COMMITTER_DATE는 현재 커밋에서 가져 와서 환경으로 내 보내져 &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree&lt;/a&gt; 후 생성 된 교체 커밋의 작성자 및 커미터 신원에 영향을 미칩니다. 필터가 작동했습니다.</target>
        </trans-unit>
        <trans-unit id="96e6a8e11c595c66ed126e7ed94498b41b8ef74c" translate="yes" xml:space="preserve">
          <source>The final &quot;/&quot; is important. The exported name is literally just prefixed with the specified string. Contrast this with the following example.</source>
          <target state="translated">마지막 &quot;/&quot;가 중요합니다. 내 보낸 이름은 문자 그대로 지정된 문자열로 시작합니다. 이것을 다음 예제와 대조하십시오.</target>
        </trans-unit>
        <trans-unit id="5e71083855686454b686d549c1aa754044d9c24f" translate="yes" xml:space="preserve">
          <source>The final result will be a series of commits, one for each patch in the original mailbox, with authorship and commit log message each taken from the message containing each patch.</source>
          <target state="translated">최종 결과는 원래 메일 함의 각 패치마다 하나씩 일련의 커밋이되며 각 패치가 포함 된 메시지에서 각각 작성된 소유권 및 커밋 로그 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d06dc79919ba8d7d4e32bae22586b9e61ea6ab90" translate="yes" xml:space="preserve">
          <source>The first &quot;git bisect&quot; subcommand to use is &quot;git bisect start&quot; to start the search. Then bounds must be set to limit the commit space. This is done usually by giving one &quot;bad&quot; and at least one &quot;good&quot; commit. They can be passed in the initial call to &quot;git bisect start&quot; like this:</source>
          <target state="translated">사용할 첫 번째 &quot;git bisect&quot;하위 명령은 검색을 시작하는 &quot;git bisect start&quot;입니다. 그런 다음 확약 공간을 제한하도록 경계를 설정해야합니다. 이것은 일반적으로 하나의 &quot;나쁜&quot;및 하나 이상의 &quot;좋은&quot;커밋을 제공하여 수행됩니다. 다음과 같이 &quot;git bisect start&quot;에 대한 초기 호출에서 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d24667b8a3af4ae680279e90e5939ecc7d57754" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;N&lt;/code&gt; lines of the message.</source>
          <target state="translated">The first &lt;code&gt;N&lt;/code&gt; lines of the message.</target>
        </trans-unit>
        <trans-unit id="3dd96cc8c67fe6f3794e1faadfc16d4e75778490" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;code&gt;origin&lt;/code&gt;, just tells Git to fetch from the repository you originally cloned from. The second argument tells Git to fetch the branch named &lt;code&gt;todo&lt;/code&gt; from the remote repository, and to store it locally under the name &lt;code&gt;refs/heads/my-todo-work&lt;/code&gt;.</source>
          <target state="translated">첫 번째 인자 인 &lt;code&gt;origin&lt;/code&gt; 은 Git에게 원래 복제 한 저장소에서 가져 오도록 지시합니다. 두 번째 인수는 Git에게 원격 저장소에서 &lt;code&gt;todo&lt;/code&gt; 라는 브랜치를 가져 와서 &lt;code&gt;refs/heads/my-todo-work&lt;/code&gt; 라는 이름으로 로컬로 저장하도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="81bbac8df429c9294b949507806676c0327c9227" translate="yes" xml:space="preserve">
          <source>The first character given by this option will be the default character used when another separator is not specified in the config for this trailer.</source>
          <target state="translated">이 옵션이 제공하는 첫 번째 문자는이 트레일러 구성에서 다른 구분 기호를 지정하지 않은 경우 사용되는 기본 문자입니다.</target>
        </trans-unit>
        <trans-unit id="39b9ae2f52daae0742c9cd959c54a342268035c6" translate="yes" xml:space="preserve">
          <source>The first command fetches the &lt;code&gt;maint&lt;/code&gt; branch from the repository at &lt;code&gt;git://git.kernel.org/pub/scm/git/git.git&lt;/code&gt; and the second command uses &lt;code&gt;FETCH_HEAD&lt;/code&gt; to examine the branch with &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;. The fetched objects will eventually be removed by git&amp;rsquo;s built-in housekeeping (see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;).</source>
          <target state="translated">첫 번째 명령 은 &lt;code&gt;git://git.kernel.org/pub/scm/git/git.git&lt;/code&gt; 의 저장소에서 &lt;code&gt;maint&lt;/code&gt; 브랜치를 가져오고 두 번째 명령은 &lt;code&gt;FETCH_HEAD&lt;/code&gt; 를 사용 하여 &lt;a href=&quot;git-log&quot;&gt;git-log [1]으로&lt;/a&gt; 브랜치를 검사합니다 . 가져온 객체는 git의 내장 하우스 키핑에 의해 제거됩니다 ( &lt;a href=&quot;git-gc&quot;&gt;git-gc [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fc54aa6f7f46c36afb224191ab9ce02506aa2fd9" translate="yes" xml:space="preserve">
          <source>The first defense against such problems is backups. You can back up a Git directory using clone, or just using cp, tar, or any other backup mechanism.</source>
          <target state="translated">이러한 문제에 대한 첫 번째 방어책은 백업입니다. clone을 사용하거나 cp, tar 또는 기타 백업 메커니즘을 사용하여 Git 디렉토리를 백업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb17679ed2c14d3eecb0f1bd83c98beea1f4bea4" translate="yes" xml:space="preserve">
          <source>The first format is what gets used when &lt;code&gt;--stage&lt;/code&gt; is omitted or is not &lt;code&gt;--stage=all&lt;/code&gt;. The field tempname is the temporary file name holding the file content and path is the tracked path name in the index. Only the requested entries are output.</source>
          <target state="translated">첫 번째 형식은 &lt;code&gt;--stage&lt;/code&gt; 가 생략되거나 &lt;code&gt;--stage=all&lt;/code&gt; 이 아닐 때 사용되는 형식입니다 . tempname 필드는 파일 내용이 들어있는 임시 파일 이름이고 path는 색인에서 추적 된 경로 이름입니다. 요청 된 항목 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="e7e26fcb00a95d796be86027e9776fd349443123" translate="yes" xml:space="preserve">
          <source>The first is simple and appropriate if you do not have secure storage available for a password. It is generally configured by adding this to your config:</source>
          <target state="translated">첫 번째는 암호에 사용 가능한 보안 스토리지가없는 경우 간단하고 적절합니다. 일반적으로 이것을 구성에 추가하여 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="51f664b1e28dce07dd2c1ef3f2cc4ddb005556f4" translate="yes" xml:space="preserve">
          <source>The first issue is performance. Unlike any previous option, the &lt;code&gt;--simplify-merges&lt;/code&gt; option requires walking the entire commit history before returning a single result. This can make the option difficult to use for very large repositories.</source>
          <target state="translated">The first issue is performance. Unlike any previous option, the &lt;code&gt;--simplify-merges&lt;/code&gt; option requires walking the entire commit history before returning a single result. This can make the option difficult to use for very large repositories.</target>
        </trans-unit>
        <trans-unit id="561e4f0c34cc864db97b2078e570c6b7cf2ee83d" translate="yes" xml:space="preserve">
          <source>The first line of the input feeds 0 as the mode to remove the path; the SHA-1 does not matter as long as it is well formatted. Then the second and third line feeds stage 1 and stage 2 entries for that path. After the above, we would end up with this:</source>
          <target state="translated">입력의 첫 번째 라인은 경로를 제거하는 모드로 0을 공급합니다. SHA-1은 형식이 올바른 한 중요하지 않습니다. 그런 다음 두 번째 및 세 번째 행은 해당 경로의 1 단계 및 2 단계 항목을 공급합니다. 위의 후, 우리는 이것으로 끝날 것입니다 :</target>
        </trans-unit>
        <trans-unit id="d7a467221d570ce5d2e2454d168c252049fa7e64" translate="yes" xml:space="preserve">
          <source>The first number is the number of objects which are kept in individual files. The second is the amount of space taken up by those &quot;loose&quot; objects.</source>
          <target state="translated">첫 번째 숫자는 개별 파일에 보관 된 개체 수입니다. 두 번째는 &quot;느슨한&quot;객체가 차지하는 공간입니다.</target>
        </trans-unit>
        <trans-unit id="a3a16231598a15324fe96a0d30a2003f1c762045" translate="yes" xml:space="preserve">
          <source>The first paragraph of the message, which typically is a single line, is taken as the &quot;subject&quot; of the commit or the tag message. Instead of &lt;code&gt;contents:subject&lt;/code&gt;, field &lt;code&gt;subject&lt;/code&gt; can also be used to obtain same results. &lt;code&gt;:sanitize&lt;/code&gt; can be appended to &lt;code&gt;subject&lt;/code&gt; for subject line suitable for filename.</source>
          <target state="translated">The first paragraph of the message, which typically is a single line, is taken as the &quot;subject&quot; of the commit or the tag message. Instead of &lt;code&gt;contents:subject&lt;/code&gt; , field &lt;code&gt;subject&lt;/code&gt; can also be used to obtain same results. &lt;code&gt;:sanitize&lt;/code&gt; can be appended to &lt;code&gt;subject&lt;/code&gt; for subject line suitable for filename.</target>
        </trans-unit>
        <trans-unit id="1517f019c895db91a3158888218e464c0e667ed4" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the hook is the indicator for the working directory being updated. &quot;1&quot; meaning working directory was updated or &quot;0&quot; when the working directory was not updated.</source>
          <target state="translated">후크에 전달 된 첫 번째 매개 변수는 업데이트중인 작업 디렉토리의 표시기입니다. &quot;1&quot;은 작업 디렉토리가 업데이트되었음을 ​​의미하거나 작업 디렉토리가 업데이트되지 않은 경우 &quot;0&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="69f4b05a4b19ebccc10062a19a78b72d37ff6b60" translate="yes" xml:space="preserve">
          <source>The first rule takes precedence in the case of a single &amp;lt;commit&amp;gt;. To apply the second rule, i.e., format everything since the beginning of history up until &amp;lt;commit&amp;gt;, use the &lt;code&gt;--root&lt;/code&gt; option: &lt;code&gt;git format-patch
--root &amp;lt;commit&amp;gt;&lt;/code&gt;. If you want to format only &amp;lt;commit&amp;gt; itself, you can do this with &lt;code&gt;git format-patch -1 &amp;lt;commit&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">단일 &amp;lt;commit&amp;gt;의 경우 첫 번째 규칙이 우선합니다. 두 번째 규칙을 적용하려면, 즉 &amp;lt;commit&amp;gt;까지 히스토리가 시작된 이후의 모든 것을 포맷하려면 &lt;code&gt;--root&lt;/code&gt; 옵션을 사용하십시오 : &lt;code&gt;git format-patch --root &amp;lt;commit&amp;gt;&lt;/code&gt; . &amp;lt;commit&amp;gt; 자체 만 포맷하려면 &lt;code&gt;git format-patch -1 &amp;lt;commit&amp;gt;&lt;/code&gt; 으로 이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="088dfc95ab36375e45956a12e0a84d20b54cd1e3" translate="yes" xml:space="preserve">
          <source>The first step is trivial: when you want to tell Git about any changes to your working tree, you use the &lt;code&gt;git update-index&lt;/code&gt; program. That program normally just takes a list of filenames you want to update, but to avoid trivial mistakes, it refuses to add new entries to the index (or remove existing ones) unless you explicitly tell it that you&amp;rsquo;re adding a new entry with the &lt;code&gt;--add&lt;/code&gt; flag (or removing an entry with the &lt;code&gt;--remove&lt;/code&gt;) flag.</source>
          <target state="translated">첫 번째 단계는 간단합니다. 작업 트리의 변경 사항에 대해 Git에 알리려면 &lt;code&gt;git update-index&lt;/code&gt; 프로그램 을 사용하십시오 . 이 프로그램은 일반적으로 업데이트하려는 파일 이름 목록을 가져 오지만 사소한 실수를 피하기 위해 색인에 새 항목을 추가한다고 명시 적으로 명시하지 않는 한 색인에 새 항목을 추가하거나 기존 항목을 제거하지 않습니다. &lt;code&gt;--add&lt;/code&gt; 플래그 (또는 &lt;code&gt;--remove&lt;/code&gt; 를 사용 하여 항목 제거 ) 플래그.</target>
        </trans-unit>
        <trans-unit id="a1763915dd6826ebefd6dfcb3fd9fb79e61ff2f7" translate="yes" xml:space="preserve">
          <source>The first time that a commit shows up in the stream, it has various other information about it printed out with a one-word tag at the beginning of each line describing the extra commit information (author, email, committer, dates, summary, etc.).</source>
          <target state="translated">커밋이 처음으로 스트림에 표시되면 추가 커밋 정보 (작성자, 전자 메일, 커미터, 날짜, 요약 등)를 설명하는 각 줄의 시작 부분에 한 단어 태그로 인쇄 된 다양한 정보가 있습니다. ).</target>
        </trans-unit>
        <trans-unit id="33e2d00ff1c333999b37d340bc5ae3e8a3bfd826" translate="yes" xml:space="preserve">
          <source>The first time you run it, you will be prompted for your credentials. Enter the app-specific or your regular password as appropriate. If you have credential helper configured (see &lt;a href=&quot;git-credential&quot;&gt;git-credential[1]&lt;/a&gt;), the password will be saved in the credential store so you won&amp;rsquo;t have to type it the next time.</source>
          <target state="translated">처음 실행할 때 자격 증명을 묻는 메시지가 나타납니다. 앱 비밀번호 또는 일반 비밀번호를 적절히 입력하십시오. 자격 증명 도우미를 구성한 경우 ( &lt;a href=&quot;git-credential&quot;&gt;git-credential [1] 참조&lt;/a&gt; ) 자격 증명 저장소에 암호가 저장되므로 다음에 입력 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1c77b9db9c00c5ba7e83e0fb24758e48237c23ee" translate="yes" xml:space="preserve">
          <source>The first two lines indicate that it is showing the two branches with the titles of their top-of-the-tree commits, you are currently on &lt;code&gt;master&lt;/code&gt; branch (notice the asterisk &lt;code&gt;*&lt;/code&gt; character), and the first column for the later output lines is used to show commits contained in the &lt;code&gt;master&lt;/code&gt; branch, and the second column for the &lt;code&gt;mybranch&lt;/code&gt; branch. Three commits are shown along with their titles. All of them have non blank characters in the first column (&lt;code&gt;*&lt;/code&gt; shows an ordinary commit on the current branch, &lt;code&gt;-&lt;/code&gt; is a merge commit), which means they are now part of the &lt;code&gt;master&lt;/code&gt; branch. Only the &quot;Some work&quot; commit has the plus &lt;code&gt;+&lt;/code&gt; character in the second column, because &lt;code&gt;mybranch&lt;/code&gt; has not been merged to incorporate these commits from the master branch. The string inside brackets before the commit log message is a short name you can use to name the commit. In the above example, &lt;code&gt;master&lt;/code&gt; and &lt;code&gt;mybranch&lt;/code&gt; are branch heads. &lt;code&gt;master^&lt;/code&gt; is the first parent of &lt;code&gt;master&lt;/code&gt; branch head. Please see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; if you want to see more complex cases.</source>
          <target state="translated">처음 두 줄은 트리 상단 커밋의 제목과 함께 두 개의 분기를 표시하고 있음을 나타냅니다. 현재 &lt;code&gt;master&lt;/code&gt; 분기 (별표 &lt;code&gt;*&lt;/code&gt; 문자)에 있고 나중에 출력 줄의 첫 번째 열은 &lt;code&gt;master&lt;/code&gt; 브랜치에 포함 된 커밋 과 &lt;code&gt;mybranch&lt;/code&gt; 브랜치 의 두 번째 열 을 표시하는 데 사용됩니다 . 3 개의 커밋이 제목과 함께 표시됩니다. 그들 모두가 첫 번째 열에 비 공백 문자가 ( &lt;code&gt;*&lt;/code&gt; 보통의 현재 지점에 커밋 쇼, &lt;code&gt;-&lt;/code&gt; 그들은 지금의 일부 의미, 커밋 병합입니다) &lt;code&gt;master&lt;/code&gt; 분기. &quot;일부 작업&quot;커밋에만 &lt;code&gt;+&lt;/code&gt; &lt;code&gt;mybranch&lt;/code&gt; 가 병합되어 마스터 분기의 커밋을 통합하지 않았기 때문에 두 번째 열의 문자 커밋 로그 메시지 앞의 괄호 안의 문자열은 커밋 이름을 지정하는 데 사용할 수있는 짧은 이름입니다. 위의 예에서 &lt;code&gt;master&lt;/code&gt; 및 &lt;code&gt;mybranch&lt;/code&gt; 는 분기 헤드입니다. &lt;code&gt;master^&lt;/code&gt; 는 &lt;code&gt;master&lt;/code&gt; 브랜치 헤드 의 첫 번째 부모입니다 . 더 복잡한 사례를 보려면 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6b2c923c8cb34a6329089d3ed63e2b76d6f7ceed" translate="yes" xml:space="preserve">
          <source>The folder to drop the mails into, which is typically the Drafts folder. For example: &quot;INBOX.Drafts&quot;, &quot;INBOX/Drafts&quot; or &quot;[Gmail]/Drafts&quot;. Required.</source>
          <target state="translated">메일을 넣을 폴더 (보통 임시 보관함)입니다. 예 : &quot;INBOX.Drafts&quot;, &quot;INBOX / Drafts&quot;또는 &quot;[Gmail] / Drafts&quot;. 필수입니다.</target>
        </trans-unit>
        <trans-unit id="396ef1fe12b6dc07f4e5a4f66f87333df9fb56e3" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;update&lt;/code&gt; procedures are only available via the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration variable:</source>
          <target state="translated">다음 &lt;code&gt;update&lt;/code&gt; 절차는 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 구성 변수 를 통해서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="109e44e80a38f6553ddae4455bbabc5ec0d98180" translate="yes" xml:space="preserve">
          <source>The following Thunderbird extensions are needed: AboutConfig from &lt;a href=&quot;http://aboutconfig.mozdev.org/&quot;&gt;http://aboutconfig.mozdev.org/&lt;/a&gt; and External Editor from &lt;a href=&quot;http://globs.org/articles.php?lng=en&amp;amp;pg=8&quot;&gt;http://globs.org/articles.php?lng=en&amp;amp;pg=8&lt;/a&gt;</source>
          <target state="translated">다음 Thunderbird 확장이 필요합니다. &lt;a href=&quot;http://aboutconfig.mozdev.org/&quot;&gt;http://aboutconfig.mozdev.org/의&lt;/a&gt; AboutConfig 및 &lt;a href=&quot;http://globs.org/articles.php?lng=en&amp;amp;pg=8&quot;&gt;http://globs.org/articles.php?lng=en&amp;amp;pg=8의&lt;/a&gt; 외부 편집기</target>
        </trans-unit>
        <trans-unit id="f6722fafbaf6d78a6b809eec36e0605e28b20857" translate="yes" xml:space="preserve">
          <source>The following are helper commands used by the above; end users typically do not use them directly.</source>
          <target state="translated">다음은 위에서 사용한 도우미 명령입니다. 최종 사용자는 일반적으로 직접 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e785808b3cacaeabb63607758cc61e3471a646e6" translate="yes" xml:space="preserve">
          <source>The following browsers (or commands) are currently supported:</source>
          <target state="translated">현재 다음 브라우저 (또는 명령)가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7e10909a1942dd56a826033bd880f2f38314517d" translate="yes" xml:space="preserve">
          <source>The following command switches to the &quot;master&quot; branch:</source>
          <target state="translated">다음 명령은 &quot;마스터&quot;분기로 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="7a4f4c25f3029fcde1d4a38239fa9b13c5887156" translate="yes" xml:space="preserve">
          <source>The following command-line options change import semantics and may therefore not be passed as option:</source>
          <target state="translated">다음 명령 행 옵션은 가져 오기 시맨틱을 변경하므로 옵션으로 전달되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="932cde1c301ce345d40b274a1f81ff3e5be711e6" translate="yes" xml:space="preserve">
          <source>The following command-specific comments apply:</source>
          <target state="translated">다음과 같은 명령 별 설명이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d6f2de10386ef19748ad0fa0931b3359b3969227" translate="yes" xml:space="preserve">
          <source>The following config settings can be used to modify &lt;code&gt;git p4&lt;/code&gt; behavior. They all are in the &lt;code&gt;git-p4&lt;/code&gt; section.</source>
          <target state="translated">다음 구성 설정을 사용하여 &lt;code&gt;git p4&lt;/code&gt; 동작 을 수정할 수 있습니다 . 그것들은 모두 &lt;code&gt;git-p4&lt;/code&gt; 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f68ee79cc1f0c0e26a0c766d89a6823644298bab" translate="yes" xml:space="preserve">
          <source>The following configuration variables tell gitweb where to find files. The values of these variables are paths on the filesystem.</source>
          <target state="translated">다음 구성 변수는 gitweb에 파일을 찾을 위치를 알려줍니다. 이 변수의 값은 파일 시스템의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="446ebc694e2441273405a78869483ed3506272c8" translate="yes" xml:space="preserve">
          <source>The following date formats are supported. A frontend should select the format it will use for this import by passing the format name in the --date-format=&amp;lt;fmt&amp;gt; command-line option.</source>
          <target state="translated">다음 날짜 형식이 지원됩니다. 프런트 엔드는 --date-format = &amp;lt;fmt&amp;gt; 명령 줄 옵션에 형식 이름을 전달하여이 가져 오기에 사용할 형식을 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="e77a52167245e31f57d9305063355588365e98e5" translate="yes" xml:space="preserve">
          <source>The following description divides the low-level commands into commands that manipulate objects (in the repository, index, and working tree), commands that interrogate and compare objects, and commands that move objects and references between repositories.</source>
          <target state="translated">다음 설명에서는 저수준 명령을 개체 (리포지토리, 인덱스 및 작업 트리에서)를 조작하는 명령, 개체를 조사 및 비교하는 명령 및 개체와 참조를 리포지토리간에 이동하는 명령으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="0ccfcc7705084a20c6fb8eba32c2c2f3d02467cc" translate="yes" xml:space="preserve">
          <source>The following documentation pages are guides about Git concepts.</source>
          <target state="translated">The following documentation pages are guides about Git concepts.</target>
        </trans-unit>
        <trans-unit id="8ce90b7b29314319d9c33a8b52e106d84ec9670f" translate="yes" xml:space="preserve">
          <source>The following escape sequences (beside &lt;code&gt;\&quot;&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt;) are recognized: &lt;code&gt;\n&lt;/code&gt; for newline character (NL), &lt;code&gt;\t&lt;/code&gt; for horizontal tabulation (HT, TAB) and &lt;code&gt;\b&lt;/code&gt; for backspace (BS). Other char escape sequences (including octal escape sequences) are invalid.</source>
          <target state="translated">줄 바꿈 문자 (NL)의 경우 &lt;code&gt;\n&lt;/code&gt; , 가로 표 (HT, TAB)의 경우 &lt;code&gt;\t&lt;/code&gt; , 백 스페이스 (BS)의 경우 &lt;code&gt;\b&lt;/code&gt; 이스케이프 시퀀스 ( &lt;code&gt;\&quot;&lt;/code&gt; 및 &lt;code&gt;\\&lt;/code&gt; 옆 )가 인식 됩니다. 다른 문자 이스케이프 시퀀스 (8 진 포함) 이스케이프 시퀀스)가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11e92a0ce8b123a34278f747bf61153deb05c5a4" translate="yes" xml:space="preserve">
          <source>The following example shows three branches, &quot;master&quot;, &quot;fixes&quot; and &quot;mhf&quot;:</source>
          <target state="translated">다음 예는 &quot;master&quot;, &quot;fixes&quot;및 &quot;mhf&quot;의 세 가지 분기를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4297ab330b843af6f1af2259ff9a055a87b6bf37" translate="yes" xml:space="preserve">
          <source>The following features from &amp;lsquo;svn log&amp;rsquo; are supported:</source>
          <target state="translated">'svn log'의 다음 기능이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9b96392c24cd31061920293e2fd2511a8543969f" translate="yes" xml:space="preserve">
          <source>The following flags further affect the behavior when comparing commits (but not trees).</source>
          <target state="translated">다음 플래그는 커밋을 비교할 때 동작에 영향을 미칩니다 (트리는 아님).</target>
        </trans-unit>
        <trans-unit id="c98119f1eba9806e1383e47ef0aa9d751dbdff13" translate="yes" xml:space="preserve">
          <source>The following format are available:</source>
          <target state="translated">다음 형식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e633b53438db1ba002f1e1e7fca5cd2fc86227f" translate="yes" xml:space="preserve">
          <source>The following information is captured automatically:</source>
          <target state="translated">다음 정보가 자동으로 캡처됩니다.</target>
        </trans-unit>
        <trans-unit id="f25c21591a2ca83e23e48f87144d8a587685473b" translate="yes" xml:space="preserve">
          <source>The following information is requested from the user:</source>
          <target state="translated">사용자로부터 다음 정보를 요청합니다.</target>
        </trans-unit>
        <trans-unit id="5f08fc55d496958a337ddcb6a67febfb89f85554" translate="yes" xml:space="preserve">
          <source>The following key/value pairs are common to all events:</source>
          <target state="translated">다음 키 / 값 쌍은 모든 이벤트에 공통입니다.</target>
        </trans-unit>
        <trans-unit id="0a5e5ff367236dbd6bf5580d5af5e71ae090b770" translate="yes" xml:space="preserve">
          <source>The following options affect the way the simplification is performed:</source>
          <target state="translated">다음 옵션은 단순화 수행 방식에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="d99d5d2882d3fb95fadc56a0416699f5b886386d" translate="yes" xml:space="preserve">
          <source>The following options are available in either location:</source>
          <target state="translated">어느 위치에서나 다음 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e9dd1ef0925dcf9e09b1e6e501e8d0360e77eba" translate="yes" xml:space="preserve">
          <source>The following options are defined and (under suitable circumstances) set by Git if the remote helper has the &lt;code&gt;option&lt;/code&gt; capability.</source>
          <target state="translated">원격 도우미에 &lt;code&gt;option&lt;/code&gt; 기능 이있는 경우 다음 옵션이 정의되고 적절한 환경에서 Git에 의해 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad97d4ffb6c58a93bf3193a5402926d11d214aa1" translate="yes" xml:space="preserve">
          <source>The following options select the commits to be shown:</source>
          <target state="translated">다음 옵션은 표시 할 커밋을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="04bd1c24e8e494894e5123ce96e6c123a135b194" translate="yes" xml:space="preserve">
          <source>The following options:</source>
          <target state="translated">다음과 같은 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b3b3b2ba3a3d71942fecd2cbccdbee3fd847246" translate="yes" xml:space="preserve">
          <source>The following sequence attempts to backport a patch, bails out because the code the patch applies to has changed too much, and then tries again, this time exercising more care about matching up context lines.</source>
          <target state="translated">다음 순서는 패치를 백 포트하려고 시도하고 패치가 적용되는 코드가 너무 많이 변경 되었기 때문에 구제됩니다. 이번에는 컨텍스트 라인 일치에 대해 더 많은주의를 기울입니다.</target>
        </trans-unit>
        <trans-unit id="0fb6c7c3c1a2e6361aa6d0f3ddafd309ebc6378c" translate="yes" xml:space="preserve">
          <source>The following sequence checks out the &lt;code&gt;master&lt;/code&gt; branch, reverts the &lt;code&gt;Makefile&lt;/code&gt; to two revisions back, deletes &lt;code&gt;hello.c&lt;/code&gt; by mistake, and gets it back from the index.</source>
          <target state="translated">다음 순서는 &lt;code&gt;master&lt;/code&gt; 브랜치를 체크 아웃하고 &lt;code&gt;Makefile&lt;/code&gt; 을 두 개의 수정본으로 되돌리고 실수로 &lt;code&gt;hello.c&lt;/code&gt; 를 삭제 한 다음 인덱스에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b8a40037f7e020ad1f156eb7f08942ca8112c080" translate="yes" xml:space="preserve">
          <source>The following sequence switches to the &lt;code&gt;master&lt;/code&gt; branch, reverts the &lt;code&gt;Makefile&lt;/code&gt; to two revisions back, deletes hello.c by mistake, and gets it back from the index.</source>
          <target state="translated">다음 순서는 &lt;code&gt;master&lt;/code&gt; 브랜치로 전환하고 &lt;code&gt;Makefile&lt;/code&gt; 을 두 개의 수정본으로 되돌리고 실수로 hello.c를 삭제 한 다음 인덱스에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="75477915a08ed3777518303fe3302c5a880167a8" translate="yes" xml:space="preserve">
          <source>The following sequences have a special meaning:</source>
          <target state="translated">다음 순서는 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b07d72a39fdd44876a293ab8f917fa6a1014bd8c" translate="yes" xml:space="preserve">
          <source>The following subcommands are available:</source>
          <target state="translated">다음 부속 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55332124e1bbf00265c49abce68b19cb8696bb39" translate="yes" xml:space="preserve">
          <source>The following syntaxes may be used with them:</source>
          <target state="translated">다음과 같은 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9c489d8b69bf82a63ff4a237dd2bd772b8fb351" translate="yes" xml:space="preserve">
          <source>The following tables show what happens when there are unmerged entries:</source>
          <target state="translated">다음 표는 병합되지 않은 항목이있을 때 발생하는 상황을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3cc98c85c7406728df501340aea8c7fdc3f04d78" translate="yes" xml:space="preserve">
          <source>The following tips and tricks have been collected from various users of fast-import, and are offered here as suggestions.</source>
          <target state="translated">다음은 다양한 빠른 가져 오기 사용자로부터 얻은 팁과 요령이며 여기에서 제안으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="177a564b8e3982405afb3b516ab4bbb5063d1ee7" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=blob:limit=&amp;lt;n&amp;gt;[kmg]&lt;/code&gt; omits blobs larger than n bytes or units. n may be zero. The suffixes k, m, and g can be used to name units in KiB, MiB, or GiB. For example, &lt;code&gt;blob:limit=1k&lt;/code&gt; is the same as &lt;code&gt;blob:limit=1024&lt;/code&gt;.</source>
          <target state="translated">형태 &lt;code&gt;--filter=blob:limit=&amp;lt;n&amp;gt;[kmg]&lt;/code&gt; 를 생략 블롭 바이트 단위 N보다 크다. n은 0 일 수있다. 접미사 k, m 및 g를 사용하여 KiB, MiB 또는 GiB의 단위 이름을 지정할 수 있습니다. 예를 들어, &lt;code&gt;blob:limit=1k&lt;/code&gt; 는 &lt;code&gt;blob:limit=1024&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="94349f8d4383b34d05a696da3b05af67f12eec03" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=blob:none&lt;/code&gt; omits all blobs.</source>
          <target state="translated">양식 &lt;code&gt;--filter=blob:none&lt;/code&gt; 모든 모양을 생략합니다.</target>
        </trans-unit>
        <trans-unit id="39c705af761382dd23f074438f9b0e646bf492af" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=combine:&amp;lt;filter1&amp;gt;+&amp;lt;filter2&amp;gt;+&amp;hellip;​&amp;lt;filterN&amp;gt;&lt;/code&gt; can also be used to combined several filters, but this is harder than just repeating the &lt;code&gt;--filter&lt;/code&gt; flag and is usually not necessary. Filters are joined by &lt;code&gt;+&lt;/code&gt; and individual filters are %-encoded (i.e. URL-encoded). Besides the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; characters, the following characters are reserved and also must be encoded: &lt;code&gt;~!@#$^&amp;amp;*()[]{}\;&quot;,&amp;lt;&amp;gt;?&lt;/code&gt;&lt;code&gt;'`&lt;/code&gt; as well as all characters with ASCII code &amp;lt;= &lt;code&gt;0x20&lt;/code&gt;, which includes space and newline.</source>
          <target state="translated">양식 &lt;code&gt;--filter=combine:&amp;lt;filter1&amp;gt;+&amp;lt;filter2&amp;gt;+&amp;hellip;​&amp;lt;filterN&amp;gt;&lt;/code&gt; 또한 결합 된 여러 필터를 사용할 수 있지만, 열심히 단지 반복보다 수 &lt;code&gt;--filter&lt;/code&gt; 플래그를 일반적으로 필요하지 않습니다. 필터는 &lt;code&gt;+&lt;/code&gt; 로 결합되며 개별 필터는 %로 인코딩됩니다 (예 : URL 인코딩). &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; 문자 외에도 다음 문자가 예약되어 있으며 인코딩되어야합니다. &lt;code&gt;~!@#$^&amp;amp;*()[]{}\;&quot;,&amp;lt;&amp;gt;?&lt;/code&gt; &lt;code&gt;'`&lt;/code&gt; 및 ASCII 코드가있는 모든 문자 &amp;lt; = &lt;code&gt;0x20&lt;/code&gt; 에는 공백과 줄 바꿈이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d52505ec75878146eb9054dceb4728d58b485513" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=sparse:oid=&amp;lt;blob-ish&amp;gt;&lt;/code&gt; uses a sparse-checkout specification contained in the blob (or blob-expression) &lt;code&gt;&amp;lt;blob-ish&amp;gt;&lt;/code&gt; to omit blobs that would not be not required for a sparse checkout on the requested refs.</source>
          <target state="translated">형태 &lt;code&gt;--filter=sparse:oid=&amp;lt;blob-ish&amp;gt;&lt;/code&gt; 스파 스 결제 명세가 블롭 함유 사용 (또는 블로 표현) &lt;code&gt;&amp;lt;blob-ish&amp;gt;&lt;/code&gt; 을 생략 블롭 희소 결제에 필요한지지 않을 것이라고 요청 된 심판.</target>
        </trans-unit>
        <trans-unit id="ef46a11218e9457b2745a05e86c211527bd23b7c" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=tree:&amp;lt;depth&amp;gt;&lt;/code&gt; omits all blobs and trees whose depth from the root tree is &amp;gt;= &amp;lt;depth&amp;gt; (minimum depth if an object is located at multiple depths in the commits traversed). &amp;lt;depth&amp;gt;=0 will not include any trees or blobs unless included explicitly in the command-line (or standard input when --stdin is used). &amp;lt;depth&amp;gt;=1 will include only the tree and blobs which are referenced directly by a commit reachable from &amp;lt;commit&amp;gt; or an explicitly-given object. &amp;lt;depth&amp;gt;=2 is like &amp;lt;depth&amp;gt;=1 while also including trees and blobs one more level removed from an explicitly-given commit or tree.</source>
          <target state="translated">&lt;code&gt;--filter=tree:&amp;lt;depth&amp;gt;&lt;/code&gt; 형식 은 루트 트리에서 깊이가&amp;gt; = &amp;lt;depth&amp;gt; (객체가 커밋 된 여러 깊이에있는 경우 최소 깊이) 인 모든 블롭 및 트리를 생략합니다. &amp;lt;depth&amp;gt; = 0은 명령 줄에 명시 적으로 포함되지 않은 경우 (또는 --stdin을 사용할 경우 표준 입력) 트리 나 얼룩을 포함하지 않습니다. &amp;lt;depth&amp;gt; = 1은 &amp;lt;commit&amp;gt;에서 도달 할 수있는 커밋 또는 명시 적으로 제공된 객체에 의해 직접 참조되는 트리와 블로 브 만 포함합니다. &amp;lt;depth&amp;gt; = 2는 &amp;lt;depth&amp;gt; = 1과 같지만 명시 적으로 제공된 커밋 또는 트리에서 제거 된 한 단계 이상의 트리 및 얼룩도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="143c72f9a0abe1adb065cd1c00c0271a08c274c4" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-any&lt;/code&gt; will allow object traversal to continue if a missing object is encountered. Missing objects will silently be omitted from the results.</source>
          <target state="translated">&lt;code&gt;--missing=allow-any&lt;/code&gt; 형식 은 누락 된 객체가 발견되면 객체 순회가 계속되도록합니다. 누락 된 개체는 결과에서 자동으로 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="bdde6c336c8ea83ffd865ad36b93358c59c8c01f" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-any&lt;/code&gt; will allow object traversal to continue if a missing object is encountered. No fetch of a missing object will occur. Missing objects will silently be omitted from the results.</source>
          <target state="translated">The form &lt;code&gt;--missing=allow-any&lt;/code&gt; will allow object traversal to continue if a missing object is encountered. No fetch of a missing object will occur. Missing objects will silently be omitted from the results.</target>
        </trans-unit>
        <trans-unit id="4ac33b80327bef1bf98d899063defe39f6edf744" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will only allow object traversal to continue for EXPECTED promisor missing objects. No fetch of a missing object will occur. An unexpected missing object will raise an error.</source>
          <target state="translated">The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt; , but will only allow object traversal to continue for EXPECTED promisor missing objects. No fetch of a missing object will occur. An unexpected missing object will raise an error.</target>
        </trans-unit>
        <trans-unit id="280716e3ccf86616960848b089fdadef81ba797d" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing object will raise an error.</source>
          <target state="translated">&lt;code&gt;--missing=allow-promisor&lt;/code&gt; 형식 은 &lt;code&gt;allow-any&lt;/code&gt; 와 유사 하지만 예상 통과 유망 누락 객체에 대해 객체 순회 만 계속 허용합니다. 예상치 못한 누락 된 개체는 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="563d9e750d01dbe920d57035d16bed3d91b9aea6" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing objects will raise an error.</source>
          <target state="translated">&lt;code&gt;--missing=allow-promisor&lt;/code&gt; 형식 은 &lt;code&gt;allow-any&lt;/code&gt; 와 유사 하지만 예상 통과 유망 누락 객체에 대해 객체 순회 만 계속 허용합니다. 예상치 못한 누락 된 개체는 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="85974afd39adff2510445a34b40c988ae3340623" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=error&lt;/code&gt; requests that pack-objects stop with an error if a missing object is encountered. If the repository is a partial clone, an attempt to fetch missing objects will be made before declaring them missing. This is the default action.</source>
          <target state="translated">The form &lt;code&gt;--missing=error&lt;/code&gt; requests that pack-objects stop with an error if a missing object is encountered. If the repository is a partial clone, an attempt to fetch missing objects will be made before declaring them missing. This is the default action.</target>
        </trans-unit>
        <trans-unit id="28c618ed732782b866de4c7dcf716daa2ac64119" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=error&lt;/code&gt; requests that pack-objects stop with an error if a missing object is encountered. This is the default action.</source>
          <target state="translated">&lt;code&gt;--missing=error&lt;/code&gt; 양식 은 누락 된 객체가 발견되면 pack-objects가 오류와 함께 중지되도록 요청합니다. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="2ed32158adb2f2f236ac5307d5ba7c30f0630796" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=error&lt;/code&gt; requests that rev-list stop with an error if a missing object is encountered. This is the default action.</source>
          <target state="translated">&lt;code&gt;--missing=error&lt;/code&gt; 양식 은 누락 된 객체가 발견되면 rev-list가 오류와 함께 중지되도록 요청합니다. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="67e4b67693941fe412533d5210bde2a413de8fb1" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=print&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will also print a list of the missing objects. Object IDs are prefixed with a &amp;ldquo;?&amp;rdquo; character.</source>
          <target state="translated">&lt;code&gt;--missing=print&lt;/code&gt; 형식 은 &lt;code&gt;allow-any&lt;/code&gt; 와 유사 하지만 누락 된 개체의 목록도 인쇄합니다. 개체 ID 앞에는 &quot;?&quot;가 붙습니다. 캐릭터.</target>
        </trans-unit>
        <trans-unit id="09994cb2384da5eddbe0ae0a9a1ceca76d8c8bcc" translate="yes" xml:space="preserve">
          <source>The format of a &amp;lt;refspec&amp;gt; parameter is an optional plus &lt;code&gt;+&lt;/code&gt;, followed by the source &amp;lt;src&amp;gt;, followed by a colon &lt;code&gt;:&lt;/code&gt;, followed by the destination ref &amp;lt;dst&amp;gt;. The colon can be omitted when &amp;lt;dst&amp;gt; is empty. &amp;lt;src&amp;gt; is typically a ref, but it can also be a fully spelled hex object name.</source>
          <target state="translated">&amp;lt;refspec&amp;gt; 매개 변수의 형식은 선택적인 plus &lt;code&gt;+&lt;/code&gt; , 소스 &amp;lt;src&amp;gt;, 콜론 &lt;code&gt;:&lt;/code&gt; , 목적지 ref &amp;lt;dst&amp;gt;입니다. &amp;lt;dst&amp;gt;가 비어 있으면 콜론을 생략 할 수 있습니다. &amp;lt;src&amp;gt;는 일반적으로 ref이지만, 완전한 철자 16 진 오브젝트 이름 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="05c09db4c870e826391cf6ebde5a8cc33d2791f6" translate="yes" xml:space="preserve">
          <source>The format of these files is username followed by the encrypted password, for example:</source>
          <target state="translated">이러한 파일의 형식은 사용자 이름 뒤에 암호화 된 비밀번호가 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="65670970ee487305077ce344ca1fb6c36a889cee" translate="yes" xml:space="preserve">
          <source>The former lets your shell expand the fileglob, and you are asking the dot-C files in your working tree to be overwritten with the version in the index. The latter passes the &lt;code&gt;*.c&lt;/code&gt; to Git, and you are asking the paths in the index that match the pattern to be checked out to your working tree. After running &lt;code&gt;git add hello.c; rm hello.c&lt;/code&gt;, you will &lt;code&gt;not&lt;/code&gt; see &lt;code&gt;hello.c&lt;/code&gt; in your working tree with the former, but with the latter you will.</source>
          <target state="translated">전자는 쉘이 fileglob를 확장 할 수있게하여 작업 트리의 dot-C 파일을 색인의 버전으로 겹쳐 쓰도록 요청합니다. 후자는 &lt;code&gt;*.c&lt;/code&gt; 를 Git에 전달하고, 작업 트리에 체크 아웃 할 패턴과 일치하는 인덱스의 경로를 묻습니다. &lt;code&gt;git add hello.c; rm hello.c&lt;/code&gt; 실행 한 후 hello.c를 추가하십시오; rm hello.c , 작업 트리에서 &lt;code&gt;hello.c&lt;/code&gt; 를 이전 트리와 함께 볼 수는 &lt;code&gt;not&lt;/code&gt; 후자와 함께 볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="b363974f459c2a2b237a919650aa9dc9f75161d2" translate="yes" xml:space="preserve">
          <source>The frontend must specify the number of bytes of data.</source>
          <target state="translated">프론트 엔드는 데이터의 바이트 수를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="23957db0f038e6b4263285c2923ad6ce72a805ca" translate="yes" xml:space="preserve">
          <source>The full SHA-1 object name (40-byte hexadecimal string), or a leading substring that is unique within the repository. E.g. dae86e1950b1277e545cee180551750029cfe735 and dae86e both name the same commit object if there is no other object in your repository whose object name starts with dae86e.</source>
          <target state="translated">전체 SHA-1 오브젝트 이름 (40 바이트 16 진 문자열) 또는 저장소 내에서 고유 한 선행 서브 스트링 예를 들어 dae86e1950b1277e545cee180551750029cfe735와 dae86e는 저장소에 객체 이름이 dae86e로 시작하는 다른 객체가없는 경우 동일한 커밋 객체의 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ce332106cb9361add9aaf31aea030a425aeed7be" translate="yes" xml:space="preserve">
          <source>The full name is occasionally useful if, for example, there ever exists a tag and a branch with the same name.</source>
          <target state="translated">전체 이름은 예를 들어 같은 이름의 태그와 분기가있는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d24187cae372eb76b2a26570ccfd9def8c8abdf6" translate="yes" xml:space="preserve">
          <source>The full pattern set allows for arbitrary pattern matches and complicated inclusion/exclusion rules. These can result in O(N*M) pattern matches when updating the index, where N is the number of patterns and M is the number of paths in the index. To combat this performance issue, a more restricted pattern set is allowed when &lt;code&gt;core.spareCheckoutCone&lt;/code&gt; is enabled.</source>
          <target state="translated">전체 패턴 세트는 임의의 패턴 일치 및 복잡한 포함 / 제외 규칙을 허용합니다. 이로 인해 인덱스를 업데이트 할 때 O (N * M) 패턴 일치가 발생할 수 있습니다. 여기서 N은 패턴 수이고 M은 인덱스의 경로 수입니다. 이 성능 문제를 해결하기 위해 &lt;code&gt;core.spareCheckoutCone&lt;/code&gt; 이 활성화 된 경우보다 제한된 패턴 세트가 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="271f7ad4b6b86f815e34a99cf6372d6f7edf455d" translate="yes" xml:space="preserve">
          <source>The full pattern set allows for arbitrary pattern matches and complicated inclusion/exclusion rules. These can result in O(N*M) pattern matches when updating the index, where N is the number of patterns and M is the number of paths in the index. To combat this performance issue, a more restricted pattern set is allowed when &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; is enabled.</source>
          <target state="translated">The full pattern set allows for arbitrary pattern matches and complicated inclusion/exclusion rules. These can result in O(N*M) pattern matches when updating the index, where N is the number of patterns and M is the number of paths in the index. To combat this performance issue, a more restricted pattern set is allowed when &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; is enabled.</target>
        </trans-unit>
        <trans-unit id="6d3e98918a57498bee35c9ef416c5932bb448c1f" translate="yes" xml:space="preserve">
          <source>The full syntax for a p4 view is documented in &lt;code&gt;p4 help views&lt;/code&gt;. &lt;code&gt;git p4&lt;/code&gt; knows only a subset of the view syntax. It understands multi-line mappings, overlays with &lt;code&gt;+&lt;/code&gt;, exclusions with &lt;code&gt;-&lt;/code&gt; and double-quotes around whitespace. Of the possible wildcards, &lt;code&gt;git p4&lt;/code&gt; only handles &lt;code&gt;&amp;hellip;​&lt;/code&gt;, and only when it is at the end of the path. &lt;code&gt;git p4&lt;/code&gt; will complain if it encounters an unhandled wildcard.</source>
          <target state="translated">p4보기의 전체 구문은 &lt;code&gt;p4 help views&lt;/code&gt; 설명되어 있습니다 . &lt;code&gt;git p4&lt;/code&gt; 는 뷰 구문의 하위 집합 만 알고 있습니다. 여러 줄 매핑, &lt;code&gt;+&lt;/code&gt; 오버레이 , 공백 주위의 &lt;code&gt;-&lt;/code&gt; 및 큰 따옴표 제외를 이해 합니다. 가능한 와일드 카드, &lt;code&gt;git p4&lt;/code&gt; 만 핸들 &lt;code&gt;&amp;hellip;​&lt;/code&gt; , 그것은 경로 끝에 때만. &lt;code&gt;git p4&lt;/code&gt; 는 처리되지 않은 와일드 카드가 발생하면 불평합니다.</target>
        </trans-unit>
        <trans-unit id="18d1519c9cf5420b92be3f082cd6f0aa89c3d260" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;skip_commit&lt;/code&gt; is defined as follows:</source>
          <target state="translated">&lt;code&gt;skip_commit&lt;/code&gt; 함수 는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="af7dd50b5e9b3d3ec2ae519f399794527002dc23" translate="yes" xml:space="preserve">
          <source>The functions defined by the Trace2 API are declared and documented in &lt;code&gt;trace2.h&lt;/code&gt;. It defines the API functions and wrapper macros for Trace2.</source>
          <target state="translated">Trace2 API에 의해 정의 된 함수 선언에 설명되어 있습니다 &lt;code&gt;trace2.h&lt;/code&gt; . Trace2의 API 함수 및 랩퍼 매크로를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e5521fd46bed9d589b56b651d5f3ef04e9a3b2a8" translate="yes" xml:space="preserve">
          <source>The future of bisecting</source>
          <target state="translated">이등분의 미래</target>
        </trans-unit>
        <trans-unit id="2aa4427c10c7d5c13ef7bbb9898f5fea28090dd1" translate="yes" xml:space="preserve">
          <source>The general idea is this: we generate a cost matrix between the commits in both commit ranges, then solve the least-cost assignment.</source>
          <target state="translated">일반적인 아이디어는 다음과 같습니다. 두 커밋 범위에서 커밋간에 비용 매트릭스를 생성 한 다음 최소 비용 할당을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="0339eef2339eb8367ea8564b9ff6721cd9dea407" translate="yes" xml:space="preserve">
          <source>The git commit is created relative to the current origin revision (HEAD by default). A parent commit is created based on the origin, and then the unshelve commit is created based on that.</source>
          <target state="translated">git commit은 현재 원점 개정판 (기본적으로 HEAD)을 기준으로 작성됩니다. 원본 커밋을 기반으로 부모 커밋이 생성 된 다음이를 기반으로 unshelve 커밋이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a5bbcd1beb35762403be84a14e62e0a4eb5d5226" translate="yes" xml:space="preserve">
          <source>The git object database</source>
          <target state="translated">자식 객체 데이터베이스</target>
        </trans-unit>
        <trans-unit id="80d403b9b878573aec88e9c705123dc6feedf769" translate="yes" xml:space="preserve">
          <source>The gitweb CGI script for viewing Git repositories over the web uses a perl script fragment as its configuration file. You can set variables using &quot;&lt;code&gt;our $variable = value&lt;/code&gt;&quot;; text from a &quot;#&quot; character until the end of a line is ignored. See &lt;strong&gt;perlsyn&lt;/strong&gt;(1) for details.</source>
          <target state="translated">웹에서 Git 리포지토리를보기위한 gitweb CGI 스크립트는 구성 파일로 perl 스크립트 조각을 사용합니다. &quot; &lt;code&gt;our $variable = value&lt;/code&gt; &quot;;를 사용하여 변수를 설정할 수 있습니다 . &quot;#&quot;문자부터 줄 끝까지의 텍스트는 무시됩니다. 자세한 내용은 &lt;strong&gt;perlsyn&lt;/strong&gt; (1)을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a1a6c42c76028a67bf39dd75b77a2307812be731" translate="yes" xml:space="preserve">
          <source>The gitweb cgi script provides users an easy way to browse your project&amp;rsquo;s revisions, file contents and logs without having to install Git. Features like RSS/Atom feeds and blame/annotation details may optionally be enabled.</source>
          <target state="translated">gitweb cgi 스크립트는 Git을 설치하지 않고도 프로젝트 개정, 파일 내용 및 로그를 쉽게 탐색 할 수있는 방법을 제공합니다. RSS / Atom 피드 및 Blame / Annotation 세부 사항과 같은 기능을 선택적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eefcb42be74db518327d9c82beb9a165d884846e" translate="yes" xml:space="preserve">
          <source>The gitweb features that are configurable via &lt;code&gt;%feature&lt;/code&gt; hash are listed below. This should be a complete list, but ultimately the authoritative and complete list is in gitweb.cgi source code, with features described in the comments.</source>
          <target state="translated">&lt;code&gt;%feature&lt;/code&gt; 해시 를 통해 구성 할 수있는 gitweb 기능이 아래에 나열되어 있습니다. 이것은 완전한 목록이어야하지만 궁극적으로 권위 있고 완전한 목록은 gitweb.cgi 소스 코드에 있으며 주석에 설명 된 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bee84a897df9efb668b9aee969a1e660ed8af0a4" translate="yes" xml:space="preserve">
          <source>The gitweb.extraBranchRefs is actually a multi-valued configuration variable, so following example is also correct and the result is the same as of the snippet above:</source>
          <target state="translated">gitweb.extraBranchRefs는 실제로 다중 값 구성 변수이므로 다음 예제도 정확하며 결과는 위의 스 니펫과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ab9a5e4603e46ba18e0a4c5efe881c7ac8def35b" translate="yes" xml:space="preserve">
          <source>The given URL is recorded into &lt;code&gt;.gitmodules&lt;/code&gt; for use by subsequent users cloning the superproject. If the URL is given relative to the superproject&amp;rsquo;s repository, the presumption is the superproject and submodule repositories will be kept together in the same relative location, and only the superproject&amp;rsquo;s URL needs to be provided. git-submodule will correctly locate the submodule using the relative URL in &lt;code&gt;.gitmodules&lt;/code&gt;.</source>
          <target state="translated">주어진 URL은 수퍼 프로젝트를 복제하는 후속 사용자가 사용할 수 있도록 &lt;code&gt;.gitmodules&lt;/code&gt; 에 기록됩니다 . URL이 수퍼 프로젝트의 저장소와 관련하여 제공되는 경우 수퍼 프로젝트와 하위 모듈 저장소는 동일한 상대 위치에 함께 유지되며 수퍼 프로젝트의 URL 만 제공하면됩니다. git-submodule은 &lt;code&gt;.gitmodules&lt;/code&gt; 의 상대 URL을 사용하여 서브 모듈을 올바르게 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="1190edfebfe2406cf333713a0e461379865b033f" translate="yes" xml:space="preserve">
          <source>The goal of this tutorial is to introduce two fundamental pieces of Git&amp;rsquo;s architecture&amp;mdash;​the object database and the index file&amp;mdash;​and to provide the reader with everything necessary to understand the rest of the Git documentation.</source>
          <target state="translated">이 튜토리얼의 목적은 Git 아키텍처의 두 가지 기본 요소 인 객체 데이터베이스와 인덱스 파일을 소개하고 나머지 Git 문서를 이해하는 데 필요한 모든 것을 독자에게 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="880a291c14c1099392ebdd9b73ec08c93b7220d1" translate="yes" xml:space="preserve">
          <source>The hard case</source>
          <target state="translated">어려운 경우</target>
        </trans-unit>
        <trans-unit id="71b4cfb50bd8944708a6926991c13ef0bfbac07d" translate="yes" xml:space="preserve">
          <source>The hashes are 40 hex characters long. When Git upgrades to a new hash algorithm, this might need to be updated. (It should match whatever index-pack outputs after &quot;pack\t&quot; or &quot;keep\t&quot;.</source>
          <target state="translated">The hashes are 40 hex characters long. When Git upgrades to a new hash algorithm, this might need to be updated. (It should match whatever index-pack outputs after &quot;pack\t&quot; or &quot;keep\t&quot;.</target>
        </trans-unit>
        <trans-unit id="7d2a187748caf680c0e66173f60176ec60ea02ab" translate="yes" xml:space="preserve">
          <source>The header consists of 256 4-byte network byte order integers. N-th entry of this table records the number of objects in the corresponding pack, the first byte of whose object name is less than or equal to N. This is called the &lt;code&gt;first-level fan-out&lt;/code&gt; table.</source>
          <target state="translated">헤더는 256 4 바이트 네트워크 바이트 순서 정수로 구성됩니다. 이 테이블의 N 번째 항목은 해당 팩에있는 오브젝트의 수를 기록합니다. 첫 번째 바이트의 오브젝트 이름은 N보다 작거나 같습니다.이를 &lt;code&gt;first-level fan-out&lt;/code&gt; 테이블이라고합니다.</target>
        </trans-unit>
        <trans-unit id="0e2dd021a6a8dc94bfb40a62a04904f17b8f1dab" translate="yes" xml:space="preserve">
          <source>The header is followed by number of object entries, each of which looks like this:</source>
          <target state="translated">헤더 다음에는 여러 개의 객체 항목이 있으며 각 항목은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10743ced5c1563e940127b440ba806235a399ac8" translate="yes" xml:space="preserve">
          <source>The header is followed by sorted 24-byte entries, one entry per object in the pack. Each entry is:</source>
          <target state="translated">헤더 다음에는 팩의 오브젝트 당 하나의 항목으로 정렬 된 24 바이트 항목이 있습니다. 각 항목은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="03910dca7f1c0af7f3d0e6986f455aceaec86f05" translate="yes" xml:space="preserve">
          <source>The header of the email is configurable via command-line options. If not specified on the command line, the user will be prompted with a ReadLine enabled interface to provide the necessary information.</source>
          <target state="translated">이메일 헤더는 명령 행 옵션을 통해 구성 할 수 있습니다. 명령 행에 지정되지 않은 경우 필요한 정보를 제공하기 위해 ReadLine 사용 인터페이스가 프롬프트됩니다.</target>
        </trans-unit>
        <trans-unit id="53d28fdf80ee055eff1005765033449c285d4f79" translate="yes" xml:space="preserve">
          <source>The hook always runs after the automatic note copying (see &quot;notes.rewrite.&amp;lt;command&amp;gt;&quot; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) has happened, and thus has access to these notes.</source>
          <target state="translated">후크는 자동 노트 복사 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1]의&lt;/a&gt; &quot;notes.rewrite. &amp;lt;command&amp;gt;&quot;참조)가 발생한 후에 항상 실행 되므로 이러한 노트에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55997df4465d2b793292e1300e70ff2f9e1a3588" translate="yes" xml:space="preserve">
          <source>The hook executes once for each ref to be updated, and takes three parameters:</source>
          <target state="translated">후크는 각 참조가 업데이트 될 때마다 한 번씩 실행되며 세 개의 매개 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7918f32150a1e75fa34aeef2474d601c36b3a718" translate="yes" xml:space="preserve">
          <source>The hook is allowed to edit the changelist file and can be used to normalize the text into some project standard format. It can also be used to refuse the Submit after inspect the message file.</source>
          <target state="translated">The hook is allowed to edit the changelist file and can be used to normalize the text into some project standard format. It can also be used to refuse the Submit after inspect the message file.</target>
        </trans-unit>
        <trans-unit id="6422fdbff7a8b80abf6e11b9c756369981239875" translate="yes" xml:space="preserve">
          <source>The hook is allowed to edit the message file in place, and can be used to normalize the message into some project standard format. It can also be used to refuse the commit after inspecting the message file.</source>
          <target state="translated">후크는 메시지 파일을 제자리에서 편집 할 수 있으며 메시지를 일부 프로젝트 표준 형식으로 정규화하는 데 사용할 수 있습니다. 메시지 파일을 검사 한 후 커밋을 거부하는 데 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dd8785c8f6fdd3a8a45999afa9f773631b556f1" translate="yes" xml:space="preserve">
          <source>The hook receives a list of the rewritten commits on stdin, in the format</source>
          <target state="translated">후크는 stdin에서 다시 작성된 커밋 목록을 형식으로받습니다.</target>
        </trans-unit>
        <trans-unit id="ffb0d43685532aa46e893849969758ab23367451" translate="yes" xml:space="preserve">
          <source>The hook receives the commit with which the tip of the current branch is going to be updated. It can exit with a non-zero status to refuse the push (when it does so, it must not modify the index or the working tree). Or it can make any necessary changes to the working tree and to the index to bring them to the desired state when the tip of the current branch is updated to the new commit, and exit with a zero status.</source>
          <target state="translated">후크는 현재 분기의 팁이 업데이트 될 커밋을 수신합니다. 푸시를 거부하기 위해 0이 아닌 상태로 종료 할 수 있습니다 (그렇게 할 경우 인덱스 또는 작업 트리를 수정해서는 안 됨). 또는 현재 분기의 끝이 새 커밋으로 업데이트 될 때 작업 트리와 인덱스를 원하는 상태로 가져 와서 0으로 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e0236cadc345b5114c4c6984e7438ed153e1f2f" translate="yes" xml:space="preserve">
          <source>The hook should exit with non-zero status if it wants to disallow updating the named ref. Otherwise it should exit with zero.</source>
          <target state="translated">명명 된 참조를 업데이트하지 않으려면 후크가 0이 아닌 상태로 종료해야합니다. 그렇지 않으면 0으로 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="9739d79c49b82b53238e48aeefee9c342d93a499" translate="yes" xml:space="preserve">
          <source>The hook should output to stdout the list of all files in the working directory that may have changed since the requested time. The logic should be inclusive so that it does not miss any potential changes. The paths should be relative to the root of the working directory and be separated by a single NUL.</source>
          <target state="translated">요청 된 시간 이후 변경되었을 수있는 작업 디렉토리의 모든 파일 목록을 stdout하기 위해 후크가 출력되어야합니다. 잠재적 인 변경 사항을 놓치지 않도록 논리가 포괄적이어야합니다. 경로는 작업 디렉토리의 루트에 상대적이어야하며 단일 NUL로 구분되어야합니다.</target>
        </trans-unit>
        <trans-unit id="726cd696e8b088103d80193483306d60860caef4" translate="yes" xml:space="preserve">
          <source>The hook takes exactly one argument, which is the current state the given reference transaction is in:</source>
          <target state="translated">The hook takes exactly one argument, which is the current state the given reference transaction is in:</target>
        </trans-unit>
        <trans-unit id="022998a9843b7be307eb2d587f13704cf2ce86bd" translate="yes" xml:space="preserve">
          <source>The horizontal line of history A---Q is taken to be the first parent of each merge. The commits are:</source>
          <target state="translated">히스토리 A--Q의 수평선은 각 병합의 첫 번째 상위로 간주됩니다. 커밋은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41f47ff55448de90533c1d6461f6a54aa470a338" translate="yes" xml:space="preserve">
          <source>The human-readable name used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;author.name&lt;/code&gt; configuration settings.</source>
          <target state="translated">The human-readable name used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;author.name&lt;/code&gt; configuration settings.</target>
        </trans-unit>
        <trans-unit id="65a50b3e42cc3505776fea766e525fbf7e68884e" translate="yes" xml:space="preserve">
          <source>The human-readable name used in the committer identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;committer.name&lt;/code&gt; configuration settings.</source>
          <target state="translated">The human-readable name used in the committer identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;committer.name&lt;/code&gt; configuration settings.</target>
        </trans-unit>
        <trans-unit id="bdf0ebdfb4273a6fce7952dfa28834b6e411cd7f" translate="yes" xml:space="preserve">
          <source>The hypothetical proxy command entries actually have a postfix to discern what URL they apply to. Here is how to change the entry for kernel.org to &quot;ssh&quot;.</source>
          <target state="translated">가상 프록시 명령 항목에는 실제로 적용 할 URL을 식별하기위한 접미사가 있습니다. 다음은 kernel.org의 항목을 &quot;ssh&quot;로 변경하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="4399284bfb632a08cce3f3533db563320f49af23" translate="yes" xml:space="preserve">
          <source>The id of a tree object to diff against.</source>
          <target state="translated">비교할 트리 객체의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="0505b9e9f78e78efa1c8b76bc422638cba05b1b7" translate="yes" xml:space="preserve">
          <source>The id of a tree object.</source>
          <target state="translated">트리 객체의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="2e60e84271eec03fd28b067b32c84bb5fbe76999" translate="yes" xml:space="preserve">
          <source>The id of the tree object(s) to be read/merged.</source>
          <target state="translated">읽거나 병합 할 트리 개체의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="fb9074ec22bab96e3e97d4855db9bfaed224187c" translate="yes" xml:space="preserve">
          <source>The idea is that every 3 test for example, &quot;git bisect&quot; could ask the user to test a commit that has already been found to be &quot;good&quot; or &quot;bad&quot; (because one of its descendants or one of its ancestors has been found to be &quot;good&quot; or &quot;bad&quot; respectively). If it happens that a commit has been previously incorrectly classified then the bisection can be aborted early, hopefully before too many mistakes have been made. Then the user will have to look at what happened and then restart the bisection using a fixed bisect log.</source>
          <target state="translated">예를 들어, &quot;git bisect&quot;와 같은 3 가지 테스트마다 &quot;좋은&quot;또는 &quot;나쁜&quot;것으로 판명 된 커밋을 테스트하도록 요청할 수 있습니다 (자손 중 하나 또는 조상 중 하나가 발견 되었기 때문에) '좋은'또는 '나쁜' 커밋이 이전에 잘못 분류 된 경우 너무 많은 실수가 있기 전에 이분법이 일찍 중단 될 수 있습니다. 그런 다음 사용자는 발생한 상황을 확인한 다음 고정 된 이등분 로그를 사용하여 이분법을 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="b3a07b8c786a1b03697e9ded467b22cd2ece1ab4" translate="yes" xml:space="preserve">
          <source>The idea is to manually tell &lt;code&gt;git rebase&lt;/code&gt; &quot;where the old &lt;code&gt;subsystem&lt;/code&gt; ended and your &lt;code&gt;topic&lt;/code&gt; began&quot;, that is, what the old merge base between them was. You will have to find a way to name the last commit of the old &lt;code&gt;subsystem&lt;/code&gt;, for example:</source>
          <target state="translated">아이디어는 수동으로 &lt;code&gt;git rebase&lt;/code&gt; 에게 &quot;오래된 &lt;code&gt;subsystem&lt;/code&gt; 종료되고 &lt;code&gt;topic&lt;/code&gt; 시작된 위치&quot;, 즉 그들 사이의 기존 병합베이스가 무엇인지를 알려주는 것입니다. 예를 들어, 이전 &lt;code&gt;subsystem&lt;/code&gt; 의 마지막 커밋 이름을 지정하는 방법을 찾아야합니다 .</target>
        </trans-unit>
        <trans-unit id="1ff2a3a30d68d12ef6b058f357f43e3bd9cd4f0f" translate="yes" xml:space="preserve">
          <source>The idx files to verify.</source>
          <target state="translated">확인할 idx 파일</target>
        </trans-unit>
        <trans-unit id="fd29bd486dc43b124e6d98a808e18b86c2905ae4" translate="yes" xml:space="preserve">
          <source>The import checks out from CVS every revision of every file. Reportedly cvsimport can average some twenty revisions per second, so for a medium-sized project this should not take more than a couple of minutes. Larger projects or remote repositories may take longer.</source>
          <target state="translated">가져 오기는 모든 파일의 모든 개정판을 CVS에서 체크 아웃합니다. 보도에 따르면 cvsimport는 초당 평균 20 회의 수정을 수행 할 수 있으므로 중간 규모 프로젝트의 경우 몇 분 이상 걸리지 않아야합니다. 더 큰 프로젝트 또는 원격 저장소는 더 오래 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69f04e00f7076b8b130e67c7134e53f7f1076bf2" translate="yes" xml:space="preserve">
          <source>The import is incremental, so if you call it again next month it will fetch any CVS updates that have been made in the meantime. For this to work, you must not modify the imported branches; instead, create new branches for your own changes, and merge in the imported branches as necessary.</source>
          <target state="translated">가져 오기는 증분이므로 다음 달에 다시 호출하면 그 동안 작성된 CVS 업데이트를 가져옵니다. 이렇게하려면 가져온 분기를 수정하지 않아야합니다. 대신, 자신의 변경 사항에 대한 새 분기를 만들고 필요에 따라 가져온 분기를 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="807035ab1f5be4f0cb3563dc9b49740571ca0fa4" translate="yes" xml:space="preserve">
          <source>The index</source>
          <target state="translated">색인</target>
        </trans-unit>
        <trans-unit id="4284ed429265f3c1afc30e4fc09197d88352698c" translate="yes" xml:space="preserve">
          <source>The index and the working tree are adjusted as if you had previously run &lt;code&gt;git checkout &amp;lt;start_point&amp;gt;&lt;/code&gt;. This allows you to start a new history that records a set of paths similar to &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; by easily running &lt;code&gt;git commit -a&lt;/code&gt; to make the root commit.</source>
          <target state="translated">인덱스와 작업 트리는 이전에 &lt;code&gt;git checkout &amp;lt;start_point&amp;gt;&lt;/code&gt; 를 실행 한 것처럼 조정됩니다 . 이를 통해 &lt;code&gt;git commit -a&lt;/code&gt; 를 쉽게 실행 하여 루트 커밋을 만들어 &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 와 비슷한 경로 집합을 기록하는 새 기록을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0818281aa21612fb5fa362015c64c5645d861084" translate="yes" xml:space="preserve">
          <source>The index contains all the information necessary to generate a single (uniquely determined) tree object.</source>
          <target state="translated">색인에는 단일 (독특하게 결정된) 트리 오브젝트를 생성하는 데 필요한 모든 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3d9fb9e020c0d003a42d72f87f16ba2ba38226e6" translate="yes" xml:space="preserve">
          <source>The index enables fast comparisons between the tree object it defines and the working tree.</source>
          <target state="translated">인덱스를 사용하면 정의한 트리 개체와 작업 트리를 빠르게 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb65460c6179ccddcd4479166e9da44d8f5c40d8" translate="yes" xml:space="preserve">
          <source>The index file</source>
          <target state="translated">색인 파일</target>
        </trans-unit>
        <trans-unit id="181ab401ce7a15640077d5cb413c24fc6eb6a97e" translate="yes" xml:space="preserve">
          <source>The index file is a cache of the state of a directory tree, used to create commits, check out working directories, and hold the various trees involved in a merge.</source>
          <target state="translated">인덱스 파일은 디렉토리 트리 상태의 캐시로, 커밋을 생성하고 작업 디렉토리를 체크 아웃하며 병합과 관련된 다양한 트리를 보유하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a98935eae61bfe66b9928e790965f624bf2f8b5b" translate="yes" xml:space="preserve">
          <source>The index file is initialized with a list of all paths and, for each path, a blob object and a set of attributes. The blob object represents the contents of the file as of the head of the current branch. The attributes (last modified time, size, etc.) are taken from the corresponding file in the working tree. Subsequent changes to the working tree can be found by comparing these attributes. The index may be updated with new content, and new commits may be created from the content stored in the index.</source>
          <target state="translated">인덱스 파일은 모든 경로 목록과 각 경로에 대해 BLOB 개체 및 특성 집합으로 초기화됩니다. Blob 객체는 현재 분기의 헤드를 기준으로 파일의 내용을 나타냅니다. 속성 (마지막으로 수정 한 시간, 크기 등)은 작업 트리의 해당 파일에서 가져옵니다. 작업 트리에 대한 후속 변경 사항은이 속성을 비교하여 찾을 수 있습니다. 인덱스는 새로운 컨텐츠로 업데이트 될 수 있으며 인덱스에 저장된 컨텐츠에서 새로운 커밋이 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="803387e9a63472a3287bdc2446032cf6e023e1d9" translate="yes" xml:space="preserve">
          <source>The index is a binary file (generally kept in &lt;code&gt;.git/index&lt;/code&gt;) containing a sorted list of path names, each with permissions and the SHA-1 of a blob object; &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt; can show you the contents of the index:</source>
          <target state="translated">인덱스는 경로 이름의 정렬 된 목록을 포함 하는 이진 파일 (일반적으로 &lt;code&gt;.git/index&lt;/code&gt; 로 유지됨 )이며 각각은 권한과 BLOB 개체의 SHA-1을 갖습니다. &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files [1]&lt;/a&gt; 은 인덱스의 내용을 보여줄 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a9316182499a37d7c3626ac01aa8aab4c013b473" translate="yes" xml:space="preserve">
          <source>The index is also capable of storing multiple entries (called &quot;stages&quot;) for a given pathname. These stages are used to hold the various unmerged version of a file when a merge is in progress.</source>
          <target state="translated">색인은 또한 주어진 경로 이름에 대해 여러 항목 ( &quot;단계&quot;)을 저장할 수 있습니다. 이 단계는 병합이 진행될 때 병합되지 않은 다양한 버전의 파일을 보유하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="188f5a2d7cb942916f4771a1884b995e88b4142c" translate="yes" xml:space="preserve">
          <source>The index is thus a sort of temporary staging area, which is filled with a tree which you are in the process of working on.</source>
          <target state="translated">따라서 인덱스는 일종의 임시 준비 영역으로, 작업중인 트리로 채워져 있습니다.</target>
        </trans-unit>
        <trans-unit id="272f4c7f98ef3d0d8ac3fea3ee0b1455507c7b6c" translate="yes" xml:space="preserve">
          <source>The index is updated after successful completion, but the change must still be committed.</source>
          <target state="translated">성공적으로 완료된 후에는 색인이 업데이트되지만 변경 사항은 계속 커밋해야합니다.</target>
        </trans-unit>
        <trans-unit id="aaf3f3d73cad6f7ed8d83d0912688100fa696756" translate="yes" xml:space="preserve">
          <source>The index line includes the blob object names before and after the change. The &amp;lt;mode&amp;gt; is included if the file mode does not change; otherwise, separate lines indicate the old and the new mode.</source>
          <target state="translated">색인 줄에는 변경 전후의 얼룩 개체 이름이 포함됩니다. 파일 모드가 변경되지 않으면 &amp;lt;mode&amp;gt;가 포함됩니다. 그렇지 않으면 별도의 줄이 이전 및 새 모드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0c2192b5aebec33a414387c35e4e32f7ffc2561e" translate="yes" xml:space="preserve">
          <source>The index may contain unmerged entries because of a previous failed merge. By default, if you try to check out such an entry from the index, the checkout operation will fail and nothing will be checked out. Using &lt;code&gt;-f&lt;/code&gt; will ignore these unmerged entries. The contents from a specific side of the merge can be checked out of the index by using &lt;code&gt;--ours&lt;/code&gt; or &lt;code&gt;--theirs&lt;/code&gt;. With &lt;code&gt;-m&lt;/code&gt;, changes made to the working tree file can be discarded to re-create the original conflicted merge result.</source>
          <target state="translated">이전에 실패한 병합으로 인해 색인에 병합되지 않은 항목이 포함될 수 있습니다. 기본적으로 색인에서 이러한 항목을 체크 아웃하려고하면 체크 아웃 조작이 실패하고 체크 아웃되지 않습니다. &lt;code&gt;-f&lt;/code&gt; 를 사용하면 병합되지 않은 항목은 무시됩니다. 병합의 특정 측면에있는 내용은 &lt;code&gt;--ours&lt;/code&gt; 또는 &lt;code&gt;--theirs&lt;/code&gt; 를 사용하여 색인에서 확인할 수 있습니다 . 함께 &lt;code&gt;-m&lt;/code&gt; , 다시 만들 원래 충돌 병합 결과에 폐기 될 수 작업 트리 파일에 변경합니다.</target>
        </trans-unit>
        <trans-unit id="4d0d51f29d49355316c3cef38c96a8eb5dfc2a8a" translate="yes" xml:space="preserve">
          <source>The index must be in a fully merged state.</source>
          <target state="translated">인덱스는 완전히 병합 된 상태 여야합니다.</target>
        </trans-unit>
        <trans-unit id="76af7fc7918327fcfae98949c1f8a57aa6273691" translate="yes" xml:space="preserve">
          <source>The information &lt;code&gt;git rerere&lt;/code&gt; records is also used when running &lt;code&gt;git rebase&lt;/code&gt;. After blowing away the test merge and continuing development on the topic branch:</source>
          <target state="translated">정보 &lt;code&gt;git rerere&lt;/code&gt; 레코드는 &lt;code&gt;git rebase&lt;/code&gt; 를 실행할 때도 사용됩니다 . 테스트 병합을 날려 버리고 주제 분기에서 개발을 계속 한 후 :</target>
        </trans-unit>
        <trans-unit id="15901a24c7f8cf8a87522005a6e5af387df87a55" translate="yes" xml:space="preserve">
          <source>The information regarding a particular file, stored in the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;. An index entry can be unmerged, if a &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; was started, but not yet finished (i.e. if the index contains multiple versions of that file).</source>
          <target state="translated">&lt;a href=&quot;#def_index&quot;&gt;index에&lt;/a&gt; 저장된 특정 파일에 관한 정보 . &lt;a href=&quot;#def_merge&quot;&gt;병합&lt;/a&gt; 이 시작되었지만 아직 완료되지 않은 경우 (즉, 색인에 해당 파일의 여러 버전이 포함 된 경우) 색인 항목을 병합 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1b41d54924f3d005ef481db0b83a44bcb5b9a26" translate="yes" xml:space="preserve">
          <source>The initial &lt;code&gt;git svn clone&lt;/code&gt; can be quite time-consuming (especially for large Subversion repositories). If multiple people (or one person with multiple machines) want to use &lt;code&gt;git svn&lt;/code&gt; to interact with the same Subversion repository, you can do the initial &lt;code&gt;git svn clone&lt;/code&gt; to a repository on a server and have each person clone that repository with &lt;code&gt;git clone&lt;/code&gt;:</source>
          <target state="translated">초기 &lt;code&gt;git svn clone&lt;/code&gt; 은 특히 ​​많은 Subversion 저장소의 경우 시간이 오래 걸릴 수 있습니다. 여러 사람 (또는 여러 시스템을 가진 한 사람)이 &lt;code&gt;git svn&lt;/code&gt; 을 사용하여 동일한 Subversion 저장소와 상호 작용 하려는 경우 초기 &lt;code&gt;git svn clone&lt;/code&gt; 를 서버의 저장소에 수행하고 각 사람이 해당 저장소를 &lt;code&gt;git clone&lt;/code&gt; 으로 복제하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="086eba2d4da1f4350d7506d860bddbb6a3656718" translate="yes" xml:space="preserve">
          <source>The initial clone may be time-consuming for a large project, but you will only need to clone once.</source>
          <target state="translated">대규모 프로젝트의 경우 초기 복제에 시간이 오래 걸릴 수 있지만 한 번만 복제하면됩니다.</target>
        </trans-unit>
        <trans-unit id="de40e4660568a286f9924fcf84aa107b9295fcd9" translate="yes" xml:space="preserve">
          <source>The initial revision lays the foundation for almost everything Git has today, but is small enough to read in one sitting.</source>
          <target state="translated">초기 개정판은 오늘날 Git의 거의 모든 것을위한 토대를 마련하지만 한 번에 읽을 수있을 정도로 작습니다.</target>
        </trans-unit>
        <trans-unit id="c62040180edff3420ed3a70f2f1e520bccaa26ac" translate="yes" xml:space="preserve">
          <source>The insane thing. You really want to call the new version &quot;X&quot; too, &lt;code&gt;even though&lt;/code&gt; others have already seen the old one. So just use &lt;code&gt;git tag -f&lt;/code&gt; again, as if you hadn&amp;rsquo;t already published the old one.</source>
          <target state="translated">미친 것. 다른 사람들이 이미 이전 버전을 &lt;code&gt;even though&lt;/code&gt; 새 버전 &quot;X&quot;도 호출하려고합니다 . 따라서 이전 &lt;code&gt;git tag -f&lt;/code&gt; 아직 게시하지 않은 것처럼 git tag -f를 다시 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="861707a12241605e66eb9230fb32f3c54a08448e" translate="yes" xml:space="preserve">
          <source>The intent of this option is to pick and choose lines of the patch to apply, or even to modify the contents of lines to be staged. This can be quicker and more flexible than using the interactive hunk selector. However, it is easy to confuse oneself and create a patch that does not apply to the index. See EDITING PATCHES below.</source>
          <target state="translated">이 옵션의 목적은 적용 할 패치의 행을 선택하여 선택하거나 스테이징 할 행의 내용을 수정하는 것입니다. 이것은 대화식 덩어리 선택기를 사용하는 것보다 더 빠르고 유연 할 수 있습니다. 그러나 자신을 혼동하고 색인에 적용되지 않는 패치를 만드는 것은 쉽습니다. 아래의 패치 편집을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="44c76b656c6ccb35aba2b96c920b5e782121a3bc" translate="yes" xml:space="preserve">
          <source>The interactive backend drops commits by default that started empty and halts if it hits a commit that ended up empty. The &lt;code&gt;--keep-empty&lt;/code&gt; option exists for the interactive backend to allow it to keep commits that started empty.</source>
          <target state="translated">대화식 백엔드는 기본적으로 비어있는 시작된 커밋을 삭제하고 비어있는 커밋에 도달하면 중지됩니다. &lt;code&gt;--keep-empty&lt;/code&gt; 옵션은 빈 시작 커밋을 유지 할 수 있도록 대화 형 백엔드 존재합니다.</target>
        </trans-unit>
        <trans-unit id="c4d1b3aab1a5f39909af0bdb9766437575ff6138" translate="yes" xml:space="preserve">
          <source>The interactive mode is meant for this type of workflow:</source>
          <target state="translated">대화식 모드는 다음 유형의 워크 플로우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bed5d62a356c4ef72d5d10899b110555c8810a69" translate="yes" xml:space="preserve">
          <source>The interactive rebase command was originally designed to handle individual patch series. As such, it makes sense to exclude merge commits from the todo list, as the developer may have merged the then-current &lt;code&gt;master&lt;/code&gt; while working on the branch, only to rebase all the commits onto &lt;code&gt;master&lt;/code&gt; eventually (skipping the merge commits).</source>
          <target state="translated">대화식 rebase 명령은 원래 개별 패치 시리즈를 처리하도록 설계되었습니다. 따라서, 그것은 개발자가 당시 합병 한 수 있으므로, 할 일 목록에서 병합 커밋을 제외하는 것이 합리적 &lt;code&gt;master&lt;/code&gt; 브랜치에서 작업하는 동안 단지 위에 모든 커밋 리베이스하는, &lt;code&gt;master&lt;/code&gt; (병합 커밋 생략) 결국합니다.</target>
        </trans-unit>
        <trans-unit id="54aff08446e09f30da133e329eb3f3646033c66c" translate="yes" xml:space="preserve">
          <source>The interactive rebase will stop when a command fails (i.e. exits with non-0 status) to give you an opportunity to fix the problem. You can continue with &lt;code&gt;git rebase --continue&lt;/code&gt;.</source>
          <target state="translated">명령이 실패하면 (예 : 0이 아닌 상태로 종료) 대화식 리베이스가 중지되어 문제를 해결할 수있는 기회를 제공합니다. &lt;code&gt;git rebase --continue&lt;/code&gt; 로 계속 진행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a7f537099e4a0d8d8faba9c5e743d565b88b9dd" translate="yes" xml:space="preserve">
          <source>The interface (input, output, set of options and the semantics) to these low-level commands are meant to be a lot more stable than Porcelain level commands, because these commands are primarily for scripted use. The interface to Porcelain commands on the other hand are subject to change in order to improve the end user experience.</source>
          <target state="translated">이러한 하위 수준 명령에 대한 인터페이스 (입력, 출력, 옵션 집합 및 의미론)는 주로 스크립트 용도로 사용되므로 Porcelain 수준 명령보다 훨씬 안정적입니다. 반면에 Porcelain 명령에 대한 인터페이스는 최종 사용자 경험을 향상시키기 위해 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf907bc1bbd0905aa866d8781057341315704641" translate="yes" xml:space="preserve">
          <source>The internal block size to use when converting a revision specifier such as &lt;code&gt;@all&lt;/code&gt; into a list of specific change numbers. Instead of using a single call to &lt;code&gt;p4 changes&lt;/code&gt; to find the full list of changes for the conversion, there are a sequence of calls to &lt;code&gt;p4 changes -m&lt;/code&gt;, each of which requests one block of changes of the given size. The default block size is 500, which should usually be suitable.</source>
          <target state="translated">&lt;code&gt;@all&lt;/code&gt; 과 같은 개정 지정자 를 특정 변경 번호 목록 으로 변환 할 때 사용할 내부 블록 크기 입니다. &lt;code&gt;p4 changes&lt;/code&gt; 에 대한 단일 호출을 사용 하여 변환에 대한 전체 변경 사항 목록을 찾는 대신 , &lt;code&gt;p4 changes -m&lt;/code&gt; 에 대한 호출 순서가 있습니다. 각 호출 은 지정된 크기의 한 변경 블록을 요청합니다. 기본 블록 크기는 500이며 일반적으로 적합합니다.</target>
        </trans-unit>
        <trans-unit id="b58ee91a98701b75ecd0edc6713c67b3efbc3330" translate="yes" xml:space="preserve">
          <source>The internals are documented in the &lt;a href=&quot;api-index&quot;&gt;Git API documentation&lt;/a&gt;.</source>
          <target state="translated">내부는 &lt;a href=&quot;api-index&quot;&gt;Git API 문서에 문서화되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="52e0ef5f6de2b43e809ff876c18bbee69e575471" translate="yes" xml:space="preserve">
          <source>The key may contain any bytes except &lt;code&gt;=&lt;/code&gt;, newline, or NUL. The value may contain any bytes except newline or NUL.</source>
          <target state="translated">The key may contain any bytes except &lt;code&gt;=&lt;/code&gt; , newline, or NUL. The value may contain any bytes except newline or NUL.</target>
        </trans-unit>
        <trans-unit id="051387312310d89e1f2cd1a7644ba37793a94a7c" translate="yes" xml:space="preserve">
          <source>The known attack vectors are as follows:</source>
          <target state="translated">알려진 공격 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d0880a7ce92ec68d75b7997f1b8b330766294029" translate="yes" xml:space="preserve">
          <source>The lack of a central group of &quot;committers&quot; means there is less need for formal decisions about who is &quot;in&quot; and who is &quot;out&quot;.</source>
          <target state="translated">중앙 집중된 &quot;커미터&quot;그룹이 없다는 것은 &quot;내부&quot;와 &quot;외부&quot;에 대한 공식 결정이 덜 필요하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d217f82f775261a888c8090d4fd57de90a2943db" translate="yes" xml:space="preserve">
          <source>The last diff is empty, but no new commits have been made, and the head still doesn&amp;rsquo;t contain the new line:</source>
          <target state="translated">마지막 diff는 비어 있지만 새로운 커밋은 없었으며 헤드에는 여전히 새로운 줄이 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc6ae42476a6037281df209d5a37adfb042c084d" translate="yes" xml:space="preserve">
          <source>The last three commits (&lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;HEAD^&lt;/code&gt;, and &lt;code&gt;HEAD~2&lt;/code&gt;) were bad and you do not want to ever see them again. Do &lt;strong&gt;not&lt;/strong&gt; do this if you have already given these commits to somebody else. (See the &quot;RECOVERING FROM UPSTREAM REBASE&quot; section in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for the implications of doing so.)</source>
          <target state="translated">마지막 3 개의 커밋 ( &lt;code&gt;HEAD&lt;/code&gt; , &lt;code&gt;HEAD^&lt;/code&gt; 및 &lt;code&gt;HEAD~2&lt;/code&gt; )이 잘못되어 다시보고 싶지 않습니다. 마십시오 &lt;strong&gt;하지&lt;/strong&gt; 이미 다른 사람이 이러한 커밋을 제공 한 경우이 작업을 수행. ( 그렇게하는 의미에 대해서는 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]의&lt;/a&gt; &quot;UPSTREAM REBASE에서 복구&quot;섹션을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="9b2685798225cd4befed46a027cdbd30eb245ee2" translate="yes" xml:space="preserve">
          <source>The latest stash you created is stored in &lt;code&gt;refs/stash&lt;/code&gt;; older stashes are found in the reflog of this reference and can be named using the usual reflog syntax (e.g. &lt;code&gt;stash@{0}&lt;/code&gt; is the most recently created stash, &lt;code&gt;stash@{1}&lt;/code&gt; is the one before it, &lt;code&gt;stash@{2.hours.ago}&lt;/code&gt; is also possible). Stashes may also be referenced by specifying just the stash index (e.g. the integer &lt;code&gt;n&lt;/code&gt; is equivalent to &lt;code&gt;stash@{n}&lt;/code&gt;).</source>
          <target state="translated">가장 최근에 생성 한 숨김은 &lt;code&gt;refs/stash&lt;/code&gt; 에 저장됩니다 . 이전 스 &lt;code&gt;stash@{0}&lt;/code&gt; 는이 참조의 참조 로그에 있으며 일반적인 참조 로그 구문을 사용하여 이름을 지정할 수 있습니다 (예 : stash @ {0} 은 가장 최근에 생성 된 stash, &lt;code&gt;stash@{1}&lt;/code&gt; 은 그 이전의 &lt;code&gt;stash@{2.hours.ago}&lt;/code&gt; 도 가능합니다). 숨김 인덱스 만 지정하여 숨김을 참조 할 수도 있습니다 (예 : 정수 &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;stash@{n}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8bb7601b8118e6905d96f76a29452df6bc2ae98e" translate="yes" xml:space="preserve">
          <source>The latter is not available by default, unless configured.</source>
          <target state="translated">구성되지 않으면 후자는 기본적으로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9096be046e467fbce79d2a6fe63b310a7a8be174" translate="yes" xml:space="preserve">
          <source>The latter use of the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values can be overridden by giving the &lt;code&gt;--refmap=&amp;lt;refspec&amp;gt;&lt;/code&gt; parameter(s) on the command line.</source>
          <target state="translated">후자의 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 값 사용은 명령 행에 &lt;code&gt;--refmap=&amp;lt;refspec&amp;gt;&lt;/code&gt; 매개 변수 를 제공하여 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63c1787cad9f454d5a2a74665dcae083a7a8328f" translate="yes" xml:space="preserve">
          <source>The length of time, in milliseconds, for git-credential-store to retry when trying to lock the credentials file. Value 0 means not to retry at all; -1 means to try indefinitely. Default is 1000 (i.e., retry for 1s).</source>
          <target state="translated">자격 증명 파일을 잠그려고 할 때 git-credential-store가 재 시도하는 시간 (밀리 초)입니다. 값 0은 다시 시도하지 않음을 의미합니다. -1은 무기한 시도를 의미합니다. 기본값은 1000입니다 (즉, 1 초 동안 재시도).</target>
        </trans-unit>
        <trans-unit id="55ffd562f6b8b4abf7958d261df418cb81ead100" translate="yes" xml:space="preserve">
          <source>The length of time, in milliseconds, to retry when trying to lock an individual reference. Value 0 means not to retry at all; -1 means to try indefinitely. Default is 100 (i.e., retry for 100ms).</source>
          <target state="translated">개별 참조를 잠그려고 시도 할 때 재 시도하는 시간 (밀리 초)입니다. 값 0은 전혀 재 시도하지 않음을 의미합니다. -1은 무한정 시도하는 것을 의미합니다. 기본값은 100입니다 (즉, 100ms 동안 다시 시도).</target>
        </trans-unit>
        <trans-unit id="68a6d4f84896f5fe182696f59cffd1c668106a0a" translate="yes" xml:space="preserve">
          <source>The length of time, in milliseconds, to retry when trying to lock the &lt;code&gt;packed-refs&lt;/code&gt; file. Value 0 means not to retry at all; -1 means to try indefinitely. Default is 1000 (i.e., retry for 1 second).</source>
          <target state="translated">&lt;code&gt;packed-refs&lt;/code&gt; 파일 을 잠그려고 시도 할 때 재 시도하는 시간 (밀리 초) 입니다. 값 0은 전혀 재 시도하지 않음을 의미합니다. -1은 무한정 시도하는 것을 의미합니다. 기본값은 1000입니다 (즉, 1 초 동안 재시도).</target>
        </trans-unit>
        <trans-unit id="fff6cc41c6311b04938a1f36a103054a2f1d2e11" translate="yes" xml:space="preserve">
          <source>The list above is ordered by decreasing precedence; a URL that matches a config key&amp;rsquo;s path is preferred to one that matches its user name. For example, if the URL is &lt;code&gt;https://user@example.com/foo/bar&lt;/code&gt; a config key match of &lt;code&gt;https://example.com/foo&lt;/code&gt; will be preferred over a config key match of &lt;code&gt;https://user@example.com&lt;/code&gt;.</source>
          <target state="translated">위의 목록은 우선 순위를 낮추어 정렬됩니다. 구성 키의 경로와 일치하는 URL이 사용자 이름과 일치하는 URL보다 선호됩니다. 예를 들어 URL이 &lt;code&gt;https://user@example.com/foo/bar&lt;/code&gt; 인 경우 https : //user.example 의 구성 키 일치보다 &lt;code&gt;https://example.com/foo&lt;/code&gt; 의 구성 키 일치 가 선호됩니다 &lt;code&gt;https://user@example.com&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34cf6a4a25da733f5b8366288a8f31ad385fa0ee" translate="yes" xml:space="preserve">
          <source>The list of identifiers, and other information, of the objects in a &lt;a href=&quot;#def_pack&quot;&gt;pack&lt;/a&gt;, to assist in efficiently accessing the contents of a pack.</source>
          <target state="translated">&lt;a href=&quot;#def_pack&quot;&gt;팩&lt;/a&gt; 의 내용에 효율적으로 액세스 할 수 있도록 팩 에있는 객체의 식별자 목록 및 기타 정보 입니다.</target>
        </trans-unit>
        <trans-unit id="58413b6422259538de8b3cfc5351841a4fb3ade2" translate="yes" xml:space="preserve">
          <source>The list of mailbox files to read patches from. If you do not supply this argument, the command reads from the standard input. If you supply directories, they will be treated as Maildirs.</source>
          <target state="translated">패치를 읽을 메일 함 파일 목록. 이 인수를 제공하지 않으면 명령이 표준 입력에서 읽습니다. 디렉토리를 제공하면 Maildirs로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="811a0eecf6c6689902c9fc1e00fe667f20b10132" translate="yes" xml:space="preserve">
          <source>The list of remotes which are fetched by &quot;git remote update &amp;lt;group&amp;gt;&quot;. See &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;.</source>
          <target state="translated">&quot;git remote update &amp;lt;group&amp;gt;&quot;에 의해 페치 된 리모트 목록. &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3aadf5969931435dfd81a576572d271c1b7df1e4" translate="yes" xml:space="preserve">
          <source>The list you get with &quot;ls&quot; :-)</source>
          <target state="translated">&quot;ls&quot;로 얻는 목록 :-)</target>
        </trans-unit>
        <trans-unit id="2d5bfecbee3eeb5c71f69bd43de88bc34222a07d" translate="yes" xml:space="preserve">
          <source>The local offset is specified by &lt;code&gt;&amp;lt;offutc&amp;gt;&lt;/code&gt; as a positive or negative offset from UTC. For example EST (which is 5 hours behind UTC) would be expressed in &lt;code&gt;&amp;lt;tz&amp;gt;&lt;/code&gt; by &amp;ldquo;-0500&amp;rdquo; while UTC is &amp;ldquo;+0000&amp;rdquo;. The local offset does not affect &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt;; it is used only as an advisement to help formatting routines display the timestamp.</source>
          <target state="translated">로컬 오프셋은 &lt;code&gt;&amp;lt;offutc&amp;gt;&lt;/code&gt; 에서 UTC의 양수 또는 음수 오프셋으로 지정됩니다 . 예를 들어 EST (UTC보다 5 시간 늦음)는 &lt;code&gt;&amp;lt;tz&amp;gt;&lt;/code&gt; 에서 &quot;-0500&quot;으로 표시되고 UTC는 &quot;+0000&quot;입니다. 로컬 오프셋은 &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; 에 영향을 미치지 않습니다 . 형식화 루틴이 시간 소인을 표시하는 것을 돕기위한 조언으로 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ab508d82c7d8a4545e2bb32ec9ec4fb2386a14cb" translate="yes" xml:space="preserve">
          <source>The location of an augmenting mailmap file. The default mailmap, located in the root of the repository, is loaded first, then the mailmap file pointed to by this variable. The location of the mailmap file may be in a repository subdirectory, or somewhere outside of the repository itself. See &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;.</source>
          <target state="translated">기능 보강 메일 맵 파일의 위치입니다. 저장소의 루트에있는 기본 메일 맵이 먼저로드 된 다음이 변수가 가리키는 메일 맵 파일입니다. 메일 맵 파일의 위치는 저장소 하위 디렉토리에 있거나 저장소 자체 외부에있을 수 있습니다. 참조 &lt;a href=&quot;git-shortlog&quot;&gt;자식-shortlog [1]&lt;/a&gt; 와 &lt;a href=&quot;git-blame&quot;&gt;자식 비난 [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3bb0979c637e06c575b3f731f106ded5d4b916f" translate="yes" xml:space="preserve">
          <source>The location of per-instance and system-wide configuration files can be overridden using the following environment variables:</source>
          <target state="translated">인스턴스 별 및 시스템 전체 구성 파일의 위치는 다음 환경 변수를 사용하여 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9446c1e5cce4b2ece4fc10ff79540962e21c6551" translate="yes" xml:space="preserve">
          <source>The magic word &lt;code&gt;top&lt;/code&gt; (magic signature: &lt;code&gt;/&lt;/code&gt;) makes the pattern match from the root of the working tree, even when you are running the command from inside a subdirectory.</source>
          <target state="translated">magic word &lt;code&gt;top&lt;/code&gt; (magic signature : &lt;code&gt;/&lt;/code&gt; )은 하위 디렉토리 내부에서 명령을 실행하는 경우에도 작업 트리의 루트에서 패턴을 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="64ba77ac0581cbecc6b691422d0c5681817b2387" translate="yes" xml:space="preserve">
          <source>The main command loop has 6 subcommands (plus help and quit).</source>
          <target state="translated">기본 명령 루프에는 6 개의 하위 명령이 있습니다 (도움말 및 종료).</target>
        </trans-unit>
        <trans-unit id="0b0bee129956915b1cb776d4190a01b55932ed3c" translate="yes" xml:space="preserve">
          <source>The main command loop has 6 subcommands.</source>
          <target state="translated">기본 명령 루프에는 6 개의 하위 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="821ddd85eba2b4bc6e95a82521b10b32287622db" translate="yes" xml:space="preserve">
          <source>The main trunk is stored in the Git branch named &lt;code&gt;origin&lt;/code&gt;, and additional CVS branches are stored in Git branches with the same names. The most recent version of the main trunk is also left checked out on the &lt;code&gt;master&lt;/code&gt; branch, so you can start adding your own changes right away.</source>
          <target state="translated">기본 트렁크는 &lt;code&gt;origin&lt;/code&gt; 이라는 Git 브랜치에 저장 되고 추가 CVS 브랜치는 동일한 이름의 Git 브랜치에 저장됩니다. 기본 트렁크의 최신 버전도 &lt;code&gt;master&lt;/code&gt; 브랜치에서 체크 아웃 된 상태로 유지 되므로 직접 변경 사항을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f31023370321849385c22bc8ae521136bfffac45" translate="yes" xml:space="preserve">
          <source>The mapping of file names from the p4 depot path to Git, by default, involves removing the entire depot path. With this option, the full p4 depot path is retained in Git. For example, path &lt;code&gt;//depot/main/foo/bar.c&lt;/code&gt;, when imported from &lt;code&gt;//depot/main/&lt;/code&gt;, becomes &lt;code&gt;foo/bar.c&lt;/code&gt;. With &lt;code&gt;--keep-path&lt;/code&gt;, the Git path is instead &lt;code&gt;depot/main/foo/bar.c&lt;/code&gt;.</source>
          <target state="translated">기본적으로 p4 저장소 경로에서 Git으로 파일 이름을 맵핑하려면 전체 저장소 경로를 제거해야합니다. 이 옵션을 사용하면 전체 p4 저장소 경로가 Git에 유지됩니다. 예를 들어 &lt;code&gt;//depot/main/&lt;/code&gt; 에서 가져올 때 &lt;code&gt;//depot/main/foo/bar.c&lt;/code&gt; 경로 는 &lt;code&gt;foo/bar.c&lt;/code&gt; 가 됩니다. &lt;code&gt;--keep-path&lt;/code&gt; 사용 하면 Git 경로는 &lt;code&gt;depot/main/foo/bar.c&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="696795b724c116f40755fe0ffd2f815f95c8f529" translate="yes" xml:space="preserve">
          <source>The mark command is optional here as some frontends have chosen to generate the Git SHA-1 for the blob on their own, and feed that directly to &lt;code&gt;commit&lt;/code&gt;. This is typically more work than it&amp;rsquo;s worth however, as marks are inexpensive to store and easy to use.</source>
          <target state="translated">mark 명령은 여기서 일부 프론트 엔드가 자체적으로 Blob에 대한 Git SHA-1을 생성하고이를 직접 &lt;code&gt;commit&lt;/code&gt; 피드하기 때문에 선택 사항 입니다. 마크는 저장 비용이 저렴하고 사용하기 쉽기 때문에 일반적으로 가치보다 더 많은 작업입니다.</target>
        </trans-unit>
        <trans-unit id="154d6f76415eae422478f55f25c1ddb853a4e1ab" translate="yes" xml:space="preserve">
          <source>The maximum delta depth used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; when no maximum depth is given on the command line. Defaults to 50. Maximum value is 4095.</source>
          <target state="translated">명령 행에 최대 깊이가 지정되지 않은 경우 &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]에서&lt;/a&gt; 사용하는 최대 델타 깊이 . 기본값은 50입니다. 최대 값은 4095입니다.</target>
        </trans-unit>
        <trans-unit id="95e6e1cf49a26e9f67b2825bc0bd39addf27373a" translate="yes" xml:space="preserve">
          <source>The maximum length of the output filenames generated by the &lt;code&gt;format-patch&lt;/code&gt; command; defaults to 64. Can be overridden by the &lt;code&gt;--filename-max-length=&amp;lt;n&amp;gt;&lt;/code&gt; command line option.</source>
          <target state="translated">&lt;code&gt;format-patch&lt;/code&gt; 명령 으로 생성 된 출력 파일 이름의 최대 길이입니다 . 기본값은 64입니다. &lt;code&gt;--filename-max-length=&amp;lt;n&amp;gt;&lt;/code&gt; 명령 줄 옵션 으로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9325da9117f9b4afd884e4f7e837bf9ca641172e" translate="yes" xml:space="preserve">
          <source>The maximum memory in bytes used for caching deltas in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; before writing them out to a pack. This cache is used to speed up the writing object phase by not having to recompute the final delta result once the best match for all objects is found. Repacking large repositories on machines which are tight with memory might be badly impacted by this though, especially if this cache pushes the system into swapping. A value of 0 means no limit. The smallest size of 1 byte may be used to virtually disable this cache. Defaults to 256 MiB.</source>
          <target state="translated">&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt; 에서 델타를 팩에 쓰기 전에 캐싱하는 데 사용되는 최대 메모리 (바이트) 입니다. 이 캐시는 모든 객체에 대해 가장 일치하는 것이 발견되면 최종 델타 결과를 다시 계산하지 않아도되므로 쓰기 객체 단계의 속도를 높이는 데 사용됩니다. 메모리가 부족한 머신에서 큰 리포지토리를 리 패킹하면 특히이 캐시로 인해 시스템이 스와핑되는 경우 이로 인해 영향을받을 수 있습니다. 값이 0이면 제한이 없음을 의미합니다. 이 캐시를 실제로 비활성화하는 데 가장 작은 1 바이트 크기를 사용할 수 있습니다. 기본값은 256MiB입니다.</target>
        </trans-unit>
        <trans-unit id="a0015a1c1a155cb39bc99dd58a785f6e45fb6909" translate="yes" xml:space="preserve">
          <source>The maximum size of a delta, that is cached in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;. This cache is used to speed up the writing object phase by not having to recompute the final delta result once the best match for all objects is found. Defaults to 1000. Maximum value is 65535.</source>
          <target state="translated">델타의 최대 크기는 &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]에&lt;/a&gt; 캐시됩니다 . 이 캐시는 모든 객체에 대해 가장 일치하는 것이 발견되면 최종 델타 결과를 다시 계산하지 않아도되므로 쓰기 객체 단계의 속도를 높이는 데 사용됩니다. 기본값은 1000입니다. 최대 값은 65535입니다.</target>
        </trans-unit>
        <trans-unit id="d2696797b76aad16406d56dd354feaf085869327" translate="yes" xml:space="preserve">
          <source>The maximum size of a pack. This setting only affects packing to a file when repacking, i.e. the git:// protocol is unaffected. It can be overridden by the &lt;code&gt;--max-pack-size&lt;/code&gt; option of &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;. Reaching this limit results in the creation of multiple packfiles; which in turn prevents bitmaps from being created. The minimum size allowed is limited to 1 MiB. The default is unlimited. Common unit suffixes of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt; are supported.</source>
          <target state="translated">팩의 최대 크기입니다. 이 설정은 재 포장 할 때 파일로의 압축에만 영향을 미칩니다. 즉, git : // 프로토콜은 영향을받지 않습니다. &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt; 의 &lt;code&gt;--max-pack-size&lt;/code&gt; 옵션 으로 재정의 할 수 있습니다 . 이 한계에 도달하면 여러 팩 파일이 작성됩니다. 비트 맵이 생성되는 것을 방지합니다. 허용되는 최소 크기는 1MiB로 제한됩니다. 기본값은 무제한입니다. &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; 또는 &lt;code&gt;g&lt;/code&gt; 의 공통 단위 접미사 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="bb8ed32c533714ca4a8bb85ec574c3c5791f3a2f" translate="yes" xml:space="preserve">
          <source>The maximum size of memory that is consumed by each thread in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; for pack window memory when no limit is given on the command line. The value can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. When left unconfigured (or set explicitly to 0), there will be no limit.</source>
          <target state="translated">명령 행에 제한이없는 경우 팩 창 메모리에 대해 &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]의&lt;/a&gt; 각 스레드가 소비하는 최대 메모리 크기입니다 . 값은 &quot;k&quot;, &quot;m&quot;또는 &quot;g&quot;로 접미사를 붙일 수 있습니다. 구성되지 않은 상태로 두거나 명시 적으로 0으로 설정하면 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="565cc584b68c5b675a716ec7daae7fd9f3343784" translate="yes" xml:space="preserve">
          <source>The meaning of each part of feature configuration is described below:</source>
          <target state="translated">기능 구성의 각 부분의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c067af8c6826c60723d70b61f19783aa20b528e" translate="yes" xml:space="preserve">
          <source>The merge backend keeps intentionally empty commits by default (though with -i they are marked as empty in the todo list editor, or they can be dropped automatically with --no-keep-empty).</source>
          <target state="translated">The merge backend keeps intentionally empty commits by default (though with -i they are marked as empty in the todo list editor, or they can be dropped automatically with --no-keep-empty).</target>
        </trans-unit>
        <trans-unit id="35e3581a01e860cba15921ad7e00a74542d34f54" translate="yes" xml:space="preserve">
          <source>The merge backend works with a full copy of each relevant file, insulating it from these types of problems.</source>
          <target state="translated">The merge backend works with a full copy of each relevant file, insulating it from these types of problems.</target>
        </trans-unit>
        <trans-unit id="d2c94b31b25e0c09828d4438bdd636247e16e902" translate="yes" xml:space="preserve">
          <source>The merge backend works with the full commits on both sides of history and thus has no such limitations.</source>
          <target state="translated">The merge backend works with the full commits on both sides of history and thus has no such limitations.</target>
        </trans-unit>
        <trans-unit id="657f593653b8985b76ea363799992d9ccd8552d1" translate="yes" xml:space="preserve">
          <source>The merge driver can learn the pathname in which the merged result will be stored via placeholder &lt;code&gt;%P&lt;/code&gt;.</source>
          <target state="translated">병합 드라이버는 자리 표시 자 &lt;code&gt;%P&lt;/code&gt; 를 통해 병합 된 결과가 저장 될 경로 이름을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a4ee88dc1fd419e5903b5a6b97383e8c2a1fab9" translate="yes" xml:space="preserve">
          <source>The merge driver is expected to leave the result of the merge in the file named with &lt;code&gt;%A&lt;/code&gt; by overwriting it, and exit with zero status if it managed to merge them cleanly, or non-zero if there were conflicts.</source>
          <target state="translated">병합 드라이버는 병합 결과를 &lt;code&gt;%A&lt;/code&gt; 로 이름이 지정된 파일 에 겹쳐 써서 그대로두고, 완전히 병합 할 경우 상태가 0으로, 충돌이있는 경우 0이 아닌 상태로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="d39522f0982abae4a359335f63ed088d0f4a4c4e" translate="yes" xml:space="preserve">
          <source>The merge mechanism (&lt;code&gt;git merge&lt;/code&gt; and &lt;code&gt;git pull&lt;/code&gt; commands) allows the backend &lt;code&gt;merge strategies&lt;/code&gt; to be chosen with &lt;code&gt;-s&lt;/code&gt; option. Some strategies can also take their own options, which can be passed by giving &lt;code&gt;-X&amp;lt;option&amp;gt;&lt;/code&gt; arguments to &lt;code&gt;git merge&lt;/code&gt; and/or &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">병합 메커니즘 ( &lt;code&gt;git merge&lt;/code&gt; 및 &lt;code&gt;git pull&lt;/code&gt; 명령)을 사용하면 백엔드 &lt;code&gt;merge strategies&lt;/code&gt; 을 &lt;code&gt;-s&lt;/code&gt; 옵션 으로 선택할 수 있습니다 . 일부 전략은 자체 옵션을 사용할 수도 있습니다.이 &lt;code&gt;-X&amp;lt;option&amp;gt;&lt;/code&gt; 은 &lt;code&gt;git merge&lt;/code&gt; 및 / 또는 &lt;code&gt;git pull&lt;/code&gt; 에-X &amp;lt;option&amp;gt; 인수를 제공하여 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa594438c3581495b74bb79c047cb66382bd8b0d" translate="yes" xml:space="preserve">
          <source>The merge workflow works by copying branches between upstream and downstream. Upstream can merge contributions into the official history; downstream base their work on the official history.</source>
          <target state="translated">병합 워크 플로는 업스트림과 다운 스트림간에 분기를 복사하여 작동합니다. 업스트림은 기여를 공식 역사에 통합 할 수 있습니다. 공식적인 역사를 바탕으로 작업을 진행합니다.</target>
        </trans-unit>
        <trans-unit id="1df107645dfce75dc8613a8a0f6007cf8381d780" translate="yes" xml:space="preserve">
          <source>The merge-base command finds a common ancestor of the given commits, and always returns one or the other in the case where one is a descendant of the other; so the above output shows that e05db0fd actually is an ancestor of v1.5.0-rc1.</source>
          <target state="translated">merge-base 명령은 주어진 커밋의 공통 조상을 찾고 하나가 다른 하나의 자손 인 경우 항상 하나 또는 다른 하나를 반환합니다. 위의 출력은 e05db0fd가 실제로 v1.5.0-rc1의 조상임을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="91d3bf0b3d356085e2e60914fc9a13ad2e2b8ebf" translate="yes" xml:space="preserve">
          <source>The message in a commit or a tag object is &lt;code&gt;contents&lt;/code&gt;, from which &lt;code&gt;contents:&amp;lt;part&amp;gt;&lt;/code&gt; can be used to extract various parts out of:</source>
          <target state="translated">The message in a commit or a tag object is &lt;code&gt;contents&lt;/code&gt; , from which &lt;code&gt;contents:&amp;lt;part&amp;gt;&lt;/code&gt; can be used to extract various parts out of:</target>
        </trans-unit>
        <trans-unit id="19f5c4372c6fc154ead993a9f4b5a82da922524d" translate="yes" xml:space="preserve">
          <source>The message taken from file with &lt;code&gt;-F&lt;/code&gt; and command line with &lt;code&gt;-m&lt;/code&gt; are usually used as the tag message unmodified. This option lets you further edit the message taken from these sources.</source>
          <target state="translated">&lt;code&gt;-F&lt;/code&gt; 를 사용하여 파일에서 가져온 메시지 와 &lt;code&gt;-m&lt;/code&gt; 을 사용하는 명령 행 은 일반적으로 수정되지 않은 태그 메시지로 사용됩니다. 이 옵션을 사용하면 이러한 소스에서 가져온 메시지를 추가로 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e2b72f6afed427d21f4e345d320e470730d82f9" translate="yes" xml:space="preserve">
          <source>The message taken from file with &lt;code&gt;-F&lt;/code&gt;, command line with &lt;code&gt;-m&lt;/code&gt;, and from commit object with &lt;code&gt;-C&lt;/code&gt; are usually used as the commit log message unmodified. This option lets you further edit the message taken from these sources.</source>
          <target state="translated">&lt;code&gt;-F&lt;/code&gt; 로 파일에서 , &lt;code&gt;-m&lt;/code&gt; 으로 명령 행 및 &lt;code&gt;-C&lt;/code&gt; 로 커미트 오브젝트에서 가져온 메시지는 일반적으로 수정되지 않은 커미트 로그 메시지로 사용됩니다. 이 옵션을 사용하면 이러한 소스에서 가져온 메시지를 추가로 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae16f65784862fd6e529b736650355763df13327" translate="yes" xml:space="preserve">
          <source>The method by which a submodule is updated by &lt;code&gt;git submodule update&lt;/code&gt;, which is the only affected command, others such as &lt;code&gt;git checkout --recurse-submodules&lt;/code&gt; are unaffected. It exists for historical reasons, when &lt;code&gt;git submodule&lt;/code&gt; was the only command to interact with submodules; settings like &lt;code&gt;submodule.active&lt;/code&gt; and &lt;code&gt;pull.rebase&lt;/code&gt; are more specific. It is populated by &lt;code&gt;git submodule init&lt;/code&gt; from the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file. See description of &lt;code&gt;update&lt;/code&gt; command in &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;.</source>
          <target state="translated">영향을받는 유일한 명령 인 &lt;code&gt;git submodule update&lt;/code&gt; 에 의해 서브 모듈이 업데이트되는 방법 은 &lt;code&gt;git checkout --recurse-submodules&lt;/code&gt; 과 같은 다른 영향을받지 않습니다. &lt;code&gt;git submodule&lt;/code&gt; 이 하위 모듈과 상호 작용하는 유일한 명령이었던 역사적인 이유가 있습니다 . &lt;code&gt;submodule.active&lt;/code&gt; 및 &lt;code&gt;pull.rebase&lt;/code&gt; 와 같은 설정 이 더 구체적입니다. &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 파일 에서 &lt;code&gt;git submodule init&lt;/code&gt; 로 채워집니다 . &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; 의 &lt;code&gt;update&lt;/code&gt; 명령에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04ef06b50b9899f38b1e5f5c81eb00396b6d2328" translate="yes" xml:space="preserve">
          <source>The mode parameter is optional (defaults to &lt;code&gt;all&lt;/code&gt;), and is used to specify the handling of untracked files; when -u is not used, the default is &lt;code&gt;normal&lt;/code&gt;, i.e. show untracked files and directories.</source>
          <target state="translated">mode 매개 변수는 선택 사항이며 (기본값은 &lt;code&gt;all&lt;/code&gt; ) 추적되지 않은 파일 처리를 지정하는 데 사용됩니다. -u를 사용하지 않으면 기본값은 &lt;code&gt;normal&lt;/code&gt; 입니다 (예 : 추적되지 않은 파일 및 디렉토리 표시).</target>
        </trans-unit>
        <trans-unit id="daee71f2e966cf5f390a0401b9f0381f1242178c" translate="yes" xml:space="preserve">
          <source>The mode parameter is used to specify the handling of ignored files. It is optional: it defaults to &lt;code&gt;traditional&lt;/code&gt;.</source>
          <target state="translated">mode 매개 변수는 무시 된 파일 처리를 지정하는 데 사용됩니다. 선택 사항입니다. 기본값은 &lt;code&gt;traditional&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="789771a80f50eaf70002a855307c4e88ea3d25bd" translate="yes" xml:space="preserve">
          <source>The mode parameter is used to specify the handling of untracked files. It is optional: it defaults to &lt;code&gt;all&lt;/code&gt;, and if specified, it must be stuck to the option (e.g. &lt;code&gt;-uno&lt;/code&gt;, but not &lt;code&gt;-u no&lt;/code&gt;).</source>
          <target state="translated">mode 매개 변수는 추적되지 않은 파일 처리를 지정하는 데 사용됩니다. 에 기본값 : 그것은 선택 사항입니다 &lt;code&gt;all&lt;/code&gt; , 지정된 경우,이 옵션에 붙어 있어야합니다 (예 : &lt;code&gt;-uno&lt;/code&gt; ,하지만 &lt;code&gt;-u no&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d56062b3fd6eee94e49e5896b7d127ee25df01a1" translate="yes" xml:space="preserve">
          <source>The modifications stashed away by this command can be listed with &lt;code&gt;git stash list&lt;/code&gt;, inspected with &lt;code&gt;git stash show&lt;/code&gt;, and restored (potentially on top of a different commit) with &lt;code&gt;git stash apply&lt;/code&gt;. Calling &lt;code&gt;git stash&lt;/code&gt; without any arguments is equivalent to &lt;code&gt;git stash push&lt;/code&gt;. A stash is by default listed as &quot;WIP on &lt;code&gt;branchname&lt;/code&gt; &amp;hellip;​&quot;, but you can give a more descriptive message on the command line when you create one.</source>
          <target state="translated">이 명령으로 &lt;code&gt;git stash list&lt;/code&gt; 된 수정 사항은 git stash list 로 나열하고 git &lt;code&gt;git stash show&lt;/code&gt; 검사 하고 &lt;code&gt;git stash apply&lt;/code&gt; 로 잠재적으로 다른 커밋 위에 복원 할 수 있습니다 . 인수없이 &lt;code&gt;git stash&lt;/code&gt; 를 호출 하는 것은 &lt;code&gt;git stash push&lt;/code&gt; 와 같습니다 . 감춰는 &quot;에 WIP로 나열 디폴트로 &lt;code&gt;branchname&lt;/code&gt; ...&quot;하지만, 당신이 하나를 만들 때 명령 행에 더 자세한 설명 메시지를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e06fa83026ee56ec3b62a659fa5a44c6e4e4728d" translate="yes" xml:space="preserve">
          <source>The module path (only needed if httpd is Apache). (Default: /usr/lib/apache2/modules)</source>
          <target state="translated">모듈 경로 (httpd가 Apache 인 경우에만 필요) (기본값 : / usr / lib / apache2 / modules)</target>
        </trans-unit>
        <trans-unit id="08ed4170506fa174e84f549a0e3f26086c486529" translate="yes" xml:space="preserve">
          <source>The more complex forms are:</source>
          <target state="translated">더 복잡한 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d735293dee944ca58932a7261110828d307c793" translate="yes" xml:space="preserve">
          <source>The most common cause of dangling objects is that you&amp;rsquo;ve rebased a branch, or you have pulled from somebody else who rebased a branch&amp;mdash;​see &lt;a href=&quot;#cleaning-up-history&quot;&gt;Rewriting history and maintaining patch series&lt;/a&gt;. In that case, the old head of the original branch still exists, as does everything it pointed to. The branch pointer itself just doesn&amp;rsquo;t, since you replaced it with another one.</source>
          <target state="translated">매달린 오브젝트의 가장 일반적인 원인은 브랜치를 리베이스했거나 브랜치를 리베이스 한 다른 누군가로부터 가져온 것입니다 . &lt;a href=&quot;#cleaning-up-history&quot;&gt;히스토리 다시 작성 및 패치 시리즈 유지 보수를&lt;/a&gt; 참조하십시오 . 이 경우 원래 지점의 오래된 헤드는 여전히 똑같이 존재합니다. 분기 포인터 자체는 다른 포인터로 대체 되었기 때문에 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8bc143dd44c89f63596943262174b04211332773" translate="yes" xml:space="preserve">
          <source>The multi-pack-index (MIDX for short) stores a list of objects and their offsets into multiple packfiles. It contains:</source>
          <target state="translated">다중 팩 인덱스 (MIDX)는 객체 목록과 해당 오프셋을 여러 팩 파일에 저장합니다. 그것은 포함합니다 :</target>
        </trans-unit>
        <trans-unit id="4ca15f678a55a1443f2d701a54958e45ad8a0235" translate="yes" xml:space="preserve">
          <source>The multi-pack-index allows many packfiles, especially in a context where repacking is expensive (such as a very large repo), or unexpected maintenance time is unacceptable (such as a high-demand build machine). However, the multi-pack-index needs to be rewritten in full every time. We can extend the format to be incremental, so writes are fast. By storing a small &quot;tip&quot; multi-pack-index that points to large &quot;base&quot; MIDX files, we can keep writes fast while still reducing the number of binary searches required for object lookups.</source>
          <target state="translated">다중 팩 색인은 특히 재 포장이 비싸거나 (예 : 매우 큰 리포지토리) 예상치 못한 유지 보수 시간이 허용되지 않는 (예 : 수요가 많은 빌드 머신) 상황에서 많은 팩 파일을 허용합니다. 그러나 다중 팩 인덱스는 매번 다시 작성해야합니다. 형식을 증분으로 늘릴 수 있으므로 쓰기 속도가 빠릅니다. 큰 &quot;기본&quot;MIDX 파일을 가리키는 작은 &quot;팁&quot;다중 팩 인덱스를 저장하여 객체 조회에 필요한 이진 검색 수를 줄이면서 빠르게 기록을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d98c840529f1ab7c2fa3df48a823219f4ff9a17e" translate="yes" xml:space="preserve">
          <source>The multi-pack-index files refer to multiple pack-files and loose objects.</source>
          <target state="translated">다중 팩 인덱스 파일은 다중 팩 파일 및 느슨한 객체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1e0c8af9211e361d1a35789c37df84247f7ae9ac" translate="yes" xml:space="preserve">
          <source>The name and the e-mail address of the owner of the key that signed the push certificate.</source>
          <target state="translated">푸시 인증서에 서명 한 키 소유자의 이름 및 이메일 주소입니다.</target>
        </trans-unit>
        <trans-unit id="2551d22d5e60fb51293e5ef827d3f2d640624d55" translate="yes" xml:space="preserve">
          <source>The name of a commit at which to start the new branch; see &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; for details. Defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">새 브랜치를 시작할 커밋의 이름. 자세한 내용은 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; 을 참조하십시오. 기본값은 &lt;code&gt;HEAD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0efd5464958e1be85e38672256be6f6e17bc462a" translate="yes" xml:space="preserve">
          <source>The name of a local ref which can be considered &amp;ldquo;upstream&amp;rdquo; from the displayed ref. Respects &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt; and &lt;code&gt;:rstrip&lt;/code&gt; in the same way as &lt;code&gt;refname&lt;/code&gt; above. Additionally respects &lt;code&gt;:track&lt;/code&gt; to show &quot;[ahead N, behind M]&quot; and &lt;code&gt;:trackshort&lt;/code&gt; to show the terse version: &quot;&amp;gt;&quot; (ahead), &quot;&amp;lt;&quot; (behind), &quot;&amp;lt;&amp;gt;&quot; (ahead and behind), or &quot;=&quot; (in sync). &lt;code&gt;:track&lt;/code&gt; also prints &quot;[gone]&quot; whenever unknown upstream ref is encountered. Append &lt;code&gt;:track,nobracket&lt;/code&gt; to show tracking information without brackets (i.e &quot;ahead N, behind M&quot;).</source>
          <target state="translated">표시된 참조에서 &quot;업스트림&quot;으로 간주 될 수있는 로컬 참조의 이름입니다. 위의 &lt;code&gt;refname&lt;/code&gt; 과 동일한 방식으로 &lt;code&gt;:short&lt;/code&gt; , &lt;code&gt;:lstrip&lt;/code&gt; 및 &lt;code&gt;:rstrip&lt;/code&gt; 을 존중 합니다. 또한 &lt;code&gt;:track&lt;/code&gt; 은 &quot;[ahead N, behind M]&quot; 을 표시 하고 &lt;code&gt;:trackshort&lt;/code&gt; 는 &quot;&amp;gt;&quot;(ahead), &quot;&amp;lt;&quot;(behind), &quot;&amp;lt;&amp;gt;&quot;(ahead and behind) 또는 &quot; = &quot;(동기화). &lt;code&gt;:track&lt;/code&gt; 은 알 수없는 업스트림 참조가 발생할 때마다 &quot;[gone]&quot;을 인쇄합니다. Append &lt;code&gt;:track,nobracket&lt;/code&gt; 은 대괄호없이 추적 정보를 표시합니다 (예 : &quot;M 뒤에 M&quot;).</target>
        </trans-unit>
        <trans-unit id="285243cf13ade280f7038dfb92bbdaa7d26dec36" translate="yes" xml:space="preserve">
          <source>The name of a local ref which represents the &lt;code&gt;@{push}&lt;/code&gt; location for the displayed ref. Respects &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt;, &lt;code&gt;:rstrip&lt;/code&gt;, &lt;code&gt;:track&lt;/code&gt;, &lt;code&gt;:trackshort&lt;/code&gt;, &lt;code&gt;:remotename&lt;/code&gt;, and &lt;code&gt;:remoteref&lt;/code&gt; options as &lt;code&gt;upstream&lt;/code&gt; does. Produces an empty string if no &lt;code&gt;@{push}&lt;/code&gt; ref is configured.</source>
          <target state="translated">표시된 참조 의 &lt;code&gt;@{push}&lt;/code&gt; 위치를 나타내는 로컬 참조의 이름입니다 . 존중 &lt;code&gt;:short&lt;/code&gt; , &lt;code&gt;:lstrip&lt;/code&gt; , &lt;code&gt;:rstrip&lt;/code&gt; , &lt;code&gt;:track&lt;/code&gt; , &lt;code&gt;:trackshort&lt;/code&gt; , &lt;code&gt;:remotename&lt;/code&gt; , 그리고 &lt;code&gt;:remoteref&lt;/code&gt; 같은 옵션 &lt;code&gt;upstream&lt;/code&gt; 않습니다. &lt;code&gt;@{push}&lt;/code&gt; 참조가 구성 되지 않은 경우 빈 문자열을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="25973fbcb02049e23787d52ffa23363b0665166c" translate="yes" xml:space="preserve">
          <source>The name of a new directory to clone into. The &quot;humanish&quot; part of the source repository is used if no directory is explicitly given (&lt;code&gt;repo&lt;/code&gt; for &lt;code&gt;/path/to/repo.git&lt;/code&gt; and &lt;code&gt;foo&lt;/code&gt; for &lt;code&gt;host.xz:foo/.git&lt;/code&gt;). Cloning into an existing directory is only allowed if the directory is empty.</source>
          <target state="translated">복제 할 새 디렉토리의 이름입니다. 어떤 디렉토리이 명시 적으로 지정되지 않는 경우, 소스 저장소의 &quot;humanish&quot;부분이 사용됩니다 ( &lt;code&gt;repo&lt;/code&gt; 에 대한 &lt;code&gt;/path/to/repo.git&lt;/code&gt; 및 &lt;code&gt;foo&lt;/code&gt; 에 대한 &lt;code&gt;host.xz:foo/.git&lt;/code&gt; ). 기존 디렉토리로의 복제는 디렉토리가 비어있는 경우에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3c836d4cc86fbcc3a897aa8fab973465c40a1899" translate="yes" xml:space="preserve">
          <source>The name of an existing branch already in fast-import&amp;rsquo;s internal branch table. If fast-import doesn&amp;rsquo;t know the name, it&amp;rsquo;s treated as a SHA-1 expression.</source>
          <target state="translated">이미 빠른 가져 오기의 내부 분기 테이블에있는 기존 분기의 이름입니다. 빠른 가져 오기에서 이름을 모르면 SHA-1 표현식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="c21a579b2f8550495cd7f286a4f77b45b3df2f6e" translate="yes" xml:space="preserve">
          <source>The name of an existing branch to rename.</source>
          <target state="translated">이름을 바꿀 기존 지점의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b35cfa9e6735c6918643ac8769ab4e5dd81020f0" translate="yes" xml:space="preserve">
          <source>The name of an external credential helper, and any associated options. If the helper name is not an absolute path, then the string &lt;code&gt;git
credential-&lt;/code&gt; is prepended. The resulting string is executed by the shell (so, for example, setting this to &lt;code&gt;foo --option=bar&lt;/code&gt; will execute &lt;code&gt;git credential-foo --option=bar&lt;/code&gt; via the shell. See the manual of specific helpers for examples of their use.</source>
          <target state="translated">외부 자격 증명 도우미의 이름 및 관련 옵션 도우미 이름이 절대 경로가 아닌 경우 문자열 &lt;code&gt;git credential-&lt;/code&gt; 이 앞에 붙습니다. 결과 문자열은 쉘에 의해 실행되는 (그래서, 예를 들어,이 설정 &lt;code&gt;foo --option=bar&lt;/code&gt; 실행됩니다 &lt;code&gt;git credential-foo --option=bar&lt;/code&gt; 통해 쉘에게. 그 사용의 예는 특정 헬퍼의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7efaaad02f8c0d5eaaddaa5b6f8a8113410c8ef1" translate="yes" xml:space="preserve">
          <source>The name of one of the following can be used instead of a URL as &lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; argument:</source>
          <target state="translated">&lt;code&gt;&amp;lt;repository&amp;gt;&lt;/code&gt; 인수 로 URL 대신 다음 중 하나의 이름을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f54520854ea19fafb55997c9840c558f7f80fed9" translate="yes" xml:space="preserve">
          <source>The name of the &lt;code&gt;replace&lt;/code&gt; reference is the SHA-1 of the object that is replaced. The content of the &lt;code&gt;replace&lt;/code&gt; reference is the SHA-1 of the replacement object.</source>
          <target state="translated">&lt;code&gt;replace&lt;/code&gt; 참조 의 이름은 교체 된 개체의 SHA-1입니다. &lt;code&gt;replace&lt;/code&gt; 참조 의 내용은 교체 객체의 SHA-1입니다.</target>
        </trans-unit>
        <trans-unit id="117daad0c937bbfd67b26eaa98382dde664a6203" translate="yes" xml:space="preserve">
          <source>The name of the branch to create or delete. The new branch name must pass all checks defined by &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format[1]&lt;/a&gt;. Some of these checks may restrict the characters allowed in a branch name.</source>
          <target state="translated">만들거나 삭제할 지점의 이름입니다. 새로운 브랜치 이름은 &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format [1]에&lt;/a&gt; 의해 정의 된 모든 검사를 통과해야합니다 . 이러한 검사 중 일부는 지사 이름에 허용되는 문자를 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f40b450a4e1f94bf798289a960712dae0a6f632b" translate="yes" xml:space="preserve">
          <source>The name of the client can be given to &lt;code&gt;git p4&lt;/code&gt; in multiple ways. The variable &lt;code&gt;git-p4.client&lt;/code&gt; takes precedence if it exists. Otherwise, normal p4 mechanisms of determining the client are used: environment variable &lt;code&gt;P4CLIENT&lt;/code&gt;, a file referenced by &lt;code&gt;P4CONFIG&lt;/code&gt;, or the local host name.</source>
          <target state="translated">클라이언트의 이름은 &lt;code&gt;git p4&lt;/code&gt; 에 여러 가지 방법 으로 주어질 수 있습니다 . 변수 &lt;code&gt;git-p4.client&lt;/code&gt; 가있는 경우 우선권을 갖습니다. 그렇지 않으면, 클라이언트를 판별하는 일반적인 p4 메커니즘 (환경 변수 &lt;code&gt;P4CLIENT&lt;/code&gt; , &lt;code&gt;P4CONFIG&lt;/code&gt; 가 참조하는 파일 또는 로컬 호스트 이름)이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d25f4900ca4ac26428c337fc8a49a0fffaa87baa" translate="yes" xml:space="preserve">
          <source>The name of the current branch is stored in .git/HEAD.</source>
          <target state="translated">현재 브랜치의 이름은 .git / HEAD에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9192c74ec25457f29baaadaeb1d2b767ba20ddac" translate="yes" xml:space="preserve">
          <source>The name of the local ref being pushed, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix. In the case of deletion, the name of the local ref is omitted.</source>
          <target state="translated">푸시되는 로컬 참조의 이름에서 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 접두사를 뺀 것 입니다. 삭제시 로컬 참조 이름은 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="61c75d700127b0c70d569d247bca51622e343006" translate="yes" xml:space="preserve">
          <source>The name of the local ref being updated, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix.</source>
          <target state="translated">업데이트되는 로컬 참조의 이름에서 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 접두사를 뺀 것 입니다.</target>
        </trans-unit>
        <trans-unit id="40299b8374a45bc90296f421fddf5763cb8c6908" translate="yes" xml:space="preserve">
          <source>The name of the object to show. For a more complete list of ways to spell object names, see the &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">표시 할 객체의 이름입니다. 객체 이름을 철자하는 방법에 대한 전체 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]의&lt;/a&gt; &quot; SPECIFYING REVISIONS&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="15cfdda92a704493f44c3f6bda85fdb4fe25cc87" translate="yes" xml:space="preserve">
          <source>The name of the ref (the part after $GIT_DIR/). For a non-ambiguous short name of the ref append &lt;code&gt;:short&lt;/code&gt;. The option core.warnAmbiguousRefs is used to select the strict abbreviation mode. If &lt;code&gt;lstrip=&amp;lt;N&amp;gt;&lt;/code&gt; (&lt;code&gt;rstrip=&amp;lt;N&amp;gt;&lt;/code&gt;) is appended, strips &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; slash-separated path components from the front (back) of the refname (e.g. &lt;code&gt;%(refname:lstrip=2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;%(refname:rstrip=2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;refs&lt;/code&gt;). If &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; is a negative number, strip as many path components as necessary from the specified end to leave &lt;code&gt;-&amp;lt;N&amp;gt;&lt;/code&gt; path components (e.g. &lt;code&gt;%(refname:lstrip=-2)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;tags/foo&lt;/code&gt; and &lt;code&gt;%(refname:rstrip=-1)&lt;/code&gt; turns &lt;code&gt;refs/tags/foo&lt;/code&gt; into &lt;code&gt;refs&lt;/code&gt;). When the ref does not have enough components, the result becomes an empty string if stripping with positive &amp;lt;N&amp;gt;, or it becomes the full refname if stripping with negative &amp;lt;N&amp;gt;. Neither is an error.</source>
          <target state="translated">심판의 이름 ($ GIT_DIR / 다음 부분). ref append &lt;code&gt;:short&lt;/code&gt; 의 모호하지 않은 짧은 이름 . core.warnAmbiguousRefs 옵션은 엄격한 약어 모드를 선택하는 데 사용됩니다. 만약 &lt;code&gt;lstrip=&amp;lt;N&amp;gt;&lt;/code&gt; ( &lt;code&gt;rstrip=&amp;lt;N&amp;gt;&lt;/code&gt; )가 추가되어, 스트립 &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; refname의 앞 (뒤)로부터 슬래시 구분 경로 구성 요소 (예 &lt;code&gt;%(refname:lstrip=2)&lt;/code&gt; 온 &lt;code&gt;refs/tags/foo&lt;/code&gt; 에 &lt;code&gt;foo&lt;/code&gt; 에 와 &lt;code&gt;%(refname:rstrip=2)&lt;/code&gt; 회전 &lt;code&gt;refs/tags/foo&lt;/code&gt; 에 &lt;code&gt;refs&lt;/code&gt; ). 경우 &lt;code&gt;&amp;lt;N&amp;gt;&lt;/code&gt; 떠날 지정된 단부로부터 필요한만큼 경로 성분으로서 음극 번호, 스트립은 &lt;code&gt;-&amp;lt;N&amp;gt;&lt;/code&gt; 경로 구성 요소 (예 : &lt;code&gt;%(refname:lstrip=-2)&lt;/code&gt; 회전 &lt;code&gt;refs/tags/foo&lt;/code&gt; 로 &lt;code&gt;tags/foo&lt;/code&gt; 및 &lt;code&gt;%(refname:rstrip=-1)&lt;/code&gt; 온 &lt;code&gt;refs/tags/foo&lt;/code&gt; 로 &lt;code&gt;refs&lt;/code&gt; ). 참조에 충분한 구성 요소가 없으면 양수 &amp;lt;N&amp;gt;으로 스트립하면 결과가 빈 문자열이되거나 음수 &amp;lt;N&amp;gt;으로 스트립하면 전체 참조 이름이됩니다. 오류도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d3667dc69f3d60260150d30873ae903291e9c610" translate="yes" xml:space="preserve">
          <source>The name of the remote ref being fetched from, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix. In the case of deletion, the name of the remote ref is &quot;(none)&quot;.</source>
          <target state="translated">가져 오는 원격 참조의 이름에서 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 접두사를 뺀 값 입니다. 삭제의 경우 원격 참조의 이름은 &quot;(없음)&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="f1e1380262032f81dbdd04e4a724dd0dac2f66a0" translate="yes" xml:space="preserve">
          <source>The name of the remote ref being updated, minus its &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; prefix.</source>
          <target state="translated">업데이트중인 원격 참조의 이름에서 &lt;code&gt;refs/&amp;lt;type&amp;gt;/&lt;/code&gt; 접두사를 뺀 것 입니다.</target>
        </trans-unit>
        <trans-unit id="4541cb8cb079b50ad15e3d46e62cd66b37316e42" translate="yes" xml:space="preserve">
          <source>The name of the remote to create when cloning a repository. Defaults to &lt;code&gt;origin&lt;/code&gt;, and can be overridden by passing the &lt;code&gt;--origin&lt;/code&gt; command-line option to &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;.</source>
          <target state="translated">저장소를 복제 할 때 생성 할 원격지의 이름입니다. 기본값은 &lt;code&gt;origin&lt;/code&gt; 이며 &lt;code&gt;--origin&lt;/code&gt; 명령 줄 옵션을 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 에 전달하여 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf1208454bdf4c7c5a0ab602103e6dd838ca212a" translate="yes" xml:space="preserve">
          <source>The name of the repository in gitweb is the path to its &lt;code&gt;$GIT_DIR&lt;/code&gt; (its object database) relative to &lt;code&gt;$projectroot&lt;/code&gt;. Therefore the repository $repo can be found at &quot;$projectroot/$repo&quot;.</source>
          <target state="translated">gitweb에있는 저장소의 이름은 그것의 경로입니다 &lt;code&gt;$GIT_DIR&lt;/code&gt; 에 (의 객체 데이터베이스) 기준으로 &lt;code&gt;$projectroot&lt;/code&gt; . 따라서 $ repo 저장소는 &quot;$ projectroot / $ repo&quot;에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b6cc45302b6351d18e813818cde0845c0a5a22a" translate="yes" xml:space="preserve">
          <source>The name of the tag to create, delete, or describe. The new tag name must pass all checks defined by &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format[1]&lt;/a&gt;. Some of these checks may restrict the characters allowed in a tag name.</source>
          <target state="translated">작성, 삭제 또는 설명 할 태그의 이름입니다. 새 태그 이름은 &lt;a href=&quot;git-check-ref-format&quot;&gt;git-check-ref-format [1]에&lt;/a&gt; 의해 정의 된 모든 검사를 통과해야합니다 . 이러한 검사 중 일부는 태그 이름에 허용되는 문자를 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="964fd80a7ebc3b646125e059ac3c7f8c3a22061f" translate="yes" xml:space="preserve">
          <source>The named branches will be interpreted as if specified with the &lt;code&gt;-t&lt;/code&gt; option on the &lt;code&gt;git remote add&lt;/code&gt; command line.</source>
          <target state="translated">명명 된 브랜치는 &lt;code&gt;git remote add&lt;/code&gt; 명령 행 에서 &lt;code&gt;-t&lt;/code&gt; 옵션으로 지정된 것처럼 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="a7226417649eb7c8f42ca4934a290033c08aad1c" translate="yes" xml:space="preserve">
          <source>The names of objects to show (defaults to &lt;code&gt;HEAD&lt;/code&gt;). For a more complete list of ways to spell object names, see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">표시 할 객체의 이름입니다 (기본값은 &lt;code&gt;HEAD&lt;/code&gt; ). 객체 이름을 철자하는 방법에 대한 전체 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]의&lt;/a&gt; &quot; SPECIFYING REVISIONS&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="df439b2df93c9264d2652e8aa379f62f3b6ab5ac" translate="yes" xml:space="preserve">
          <source>The names of refs that are fetched, together with the object names they point at, are written to &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt;. This information may be used by scripts or other git commands, such as &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;.</source>
          <target state="translated">페치 된 참조 이름은 오브젝트 이름과 함께 &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; 에 기록됩니다 . 이 정보는 스크립트 또는 &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt; 과 같은 다른 git 명령에 의해 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b9c4b549f992b26edb42d00411780a65661d81d" translate="yes" xml:space="preserve">
          <source>The native transport (i.e. git:// URL) does no authentication and should be used with caution on unsecured networks.</source>
          <target state="translated">원시 전송 (예 : git : // URL)은 인증이 없으므로 보안되지 않은 네트워크에서는주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="86d32cda4c46d201605240981feec896fb3daceb" translate="yes" xml:space="preserve">
          <source>The new branch head will point to this commit. It may be given as a branch name, a commit-id, or a tag. If this option is omitted, the current HEAD will be used instead.</source>
          <target state="translated">새로운 지점장은이 커밋을 가리 킵니다. 브랜치 이름, 커밋 ID 또는 태그로 제공 될 수 있습니다. 이 옵션을 생략하면 현재 HEAD가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="597e47a48a8bd8b3528838dd5cebedeb7b241f60" translate="yes" xml:space="preserve">
          <source>The new name for an existing branch. The same restrictions as for &amp;lt;branchname&amp;gt; apply.</source>
          <target state="translated">기존 지점의 새 이름 &amp;lt;branchname&amp;gt;과 동일한 제한 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="05a068e20a6ba11ea4fd1dbaef65a93e78041978" translate="yes" xml:space="preserve">
          <source>The new stash entry records the modified states only for the files that match the pathspec. The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact.</source>
          <target state="translated">The new stash entry records the modified states only for the files that match the pathspec. The index entries and working tree files are then rolled back to the state in HEAD only for these files, too, leaving files that do not match the pathspec intact.</target>
        </trans-unit>
        <trans-unit id="ade318097a09c67b5bdaa6c1344cf2a281d7cac8" translate="yes" xml:space="preserve">
          <source>The next parameter is the pattern. This option has to be used for patterns starting with &lt;code&gt;-&lt;/code&gt; and should be used in scripts passing user input to grep. Multiple patterns are combined by &lt;code&gt;or&lt;/code&gt;.</source>
          <target state="translated">다음 매개 변수는 패턴입니다. 이 옵션은 &lt;code&gt;-&lt;/code&gt; 로 시작하는 패턴에 사용해야하며 grep에 사용자 입력을 전달하는 스크립트에 사용해야합니다. 여러 패턴이 &lt;code&gt;or&lt;/code&gt; 로 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="00f28e3b882b5553d45ceeb08082d3dcda522dd0" translate="yes" xml:space="preserve">
          <source>The next step of merging is to merge these three versions of the file, using 3-way merge. This is done by giving &lt;code&gt;git merge-one-file&lt;/code&gt; command as one of the arguments to &lt;code&gt;git merge-index&lt;/code&gt; command:</source>
          <target state="translated">병합의 다음 단계는 3 방향 병합을 사용하여이 세 가지 버전의 파일을 병합하는 것입니다. 이것은 &lt;code&gt;git merge-one-file&lt;/code&gt; 명령을 &lt;code&gt;git merge-index&lt;/code&gt; 명령 의 인수 중 하나로 제공하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="c203649e7405cacf1f66f3229b4d864ccf1b5f34" translate="yes" xml:space="preserve">
          <source>The nonce string the process asked the signer to include in the push certificate. If this does not match the value recorded on the &quot;nonce&quot; header in the push certificate, it may indicate that the certificate is a valid one that is being replayed from a separate &quot;git push&quot; session.</source>
          <target state="translated">프로세스에서 nonce 문자열은 서명자에게 푸시 인증서에 포함하도록 요청했습니다. 이것이 푸시 인증서의 &quot;nonce&quot;헤더에 기록 된 값과 일치하지 않으면 인증서가 별도의 &quot;git push&quot;세션에서 재생되는 유효한 인증서임을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a81eae6f204563324e9f0299e6e5a18af11339c2" translate="yes" xml:space="preserve">
          <source>The normal format target is a tradition printf format and similar to GIT_TRACE format. This format is enabled with the &lt;code&gt;GIT_TRACE2&lt;/code&gt; environment variable or the &lt;code&gt;trace2.normalTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">일반 형식 대상은 일반적인 printf 형식이며 GIT_TRACE 형식과 유사합니다. 이 형식은 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 환경 변수 또는 &lt;code&gt;trace2.normalTarget&lt;/code&gt; 시스템 또는 글로벌 구성 설정으로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="08867837836724d3f4c3cfbd7d03fa5d964eec62" translate="yes" xml:space="preserve">
          <source>The number of additional commits is the number of commits which would be displayed by &quot;git log v1.0.4..parent&quot;. The hash suffix is &quot;-g&quot; + unambiguous abbreviation for the tip commit of parent (which was &lt;code&gt;2414721b194453f058079d897d13c4e377f92dc6&lt;/code&gt;). The &quot;g&quot; prefix stands for &quot;git&quot; and is used to allow describing the version of a software depending on the SCM the software is managed with. This is useful in an environment where people may use different SCMs.</source>
          <target state="translated">추가 커밋 수는 &quot;git log v1.0.4..parent&quot;로 표시되는 커밋 수입니다. 해시 접미사는 &quot;-g&quot;+ 부모의 팁 커밋 ( &lt;code&gt;2414721b194453f058079d897d13c4e377f92dc6&lt;/code&gt; )에 대한 모호하지 않은 약어입니다 . &quot;g&quot;접두사는 &quot;git&quot;을 나타내며 소프트웨어가 관리되는 SCM에 따라 소프트웨어 버전을 설명하는 데 사용됩니다. 사람들이 다른 SCM을 사용할 수있는 환경에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="83386653d6009935020ea78a4c28a793cc5fa198" translate="yes" xml:space="preserve">
          <source>The number of curl sessions (counted across slots) to be kept across requests. They will not be ended with curl_easy_cleanup() until http_cleanup() is invoked. If USE_CURL_MULTI is not defined, this value will be capped at 1. Defaults to 1.</source>
          <target state="translated">요청간에 유지 될 컬 세션 수 (슬롯에 걸쳐 계산) http_cleanup ()이 호출 될 때까지 curl_easy_cleanup ()으로 끝나지 않습니다. USE_CURL_MULTI가 정의되지 않은 경우이 값은 1로 제한됩니다. 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="eb593ed0188a165abaa2fc9b58825ac993fcfa11" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing rename detection during a merge; if not specified, defaults to the value of diff.renameLimit. This setting has no effect if rename detection is turned off.</source>
          <target state="translated">병합 중에 이름 바꾸기 감지를 수행 할 때 고려할 파일 수입니다. 지정하지 않으면 기본값은 diff.renameLimit입니다. 이름 바꾸기 감지 기능이 해제되어 있으면이 설정이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b49ca7e6ecad75b8cf0b0ec3dcf469e017a13140" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing rename detection in &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;. Defaults to the value of diff.renameLimit.</source>
          <target state="translated">&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 및 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 에서 이름 바꾸기 감지를 수행 할 때 고려할 파일 수입니다 . 기본값은 diff.renameLimit입니다.</target>
        </trans-unit>
        <trans-unit id="62caddb975571c60931b3e5e41910f9ec3dfea6e" translate="yes" xml:space="preserve">
          <source>The number of files to consider when performing the copy/rename detection; equivalent to the &lt;code&gt;git diff&lt;/code&gt; option &lt;code&gt;-l&lt;/code&gt;. This setting has no effect if rename detection is turned off.</source>
          <target state="translated">복사 / 이름 바꾸기 감지를 수행 할 때 고려할 파일 수입니다. &lt;code&gt;git diff&lt;/code&gt; 옵션 &lt;code&gt;-l&lt;/code&gt; 과 같습니다 . 이름 바꾸기 감지 기능이 해제되어 있으면이 설정이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f40a726880d5eda55c8da498a0add02c8ea2a7b1" translate="yes" xml:space="preserve">
          <source>The number of push options given on the command line of &lt;code&gt;git push --push-option=...&lt;/code&gt; can be read from the environment variable &lt;code&gt;GIT_PUSH_OPTION_COUNT&lt;/code&gt;, and the options themselves are found in &lt;code&gt;GIT_PUSH_OPTION_0&lt;/code&gt;, &lt;code&gt;GIT_PUSH_OPTION_1&lt;/code&gt;,&amp;hellip;​ If it is negotiated to not use the push options phase, the environment variables will not be set. If the client selects to use push options, but doesn&amp;rsquo;t transmit any, the count variable will be set to zero, &lt;code&gt;GIT_PUSH_OPTION_COUNT=0&lt;/code&gt;.</source>
          <target state="translated">의 명령 행에서 주어진 푸시 옵션의 수는 &lt;code&gt;git push --push-option=...&lt;/code&gt; 환경 변수에서 읽을 수 &lt;code&gt;GIT_PUSH_OPTION_COUNT&lt;/code&gt; 하고, 옵션 자체에서 발견되는 &lt;code&gt;GIT_PUSH_OPTION_0&lt;/code&gt; , &lt;code&gt;GIT_PUSH_OPTION_1&lt;/code&gt; 이하지에 협상 경우 ... 푸시 옵션 단계를 사용하면 환경 변수가 설정되지 않습니다. 클라이언트가 푸시 옵션을 사용하도록 선택했지만 전송하지 않으면 카운트 변수는 0으로 설정됩니다 ( &lt;code&gt;GIT_PUSH_OPTION_COUNT=0&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="c5ad10bd3ab58adc794f2122271c46d58529bef4" translate="yes" xml:space="preserve">
          <source>The number of spaces between columns. One space by default.</source>
          <target state="translated">열 사이의 공백 수입니다. 기본적으로 하나의 공간.</target>
        </trans-unit>
        <trans-unit id="911462b0802b22317c5a57a0a0510dbf0c397a66" translate="yes" xml:space="preserve">
          <source>The number of submodules fetched at the same time. Defaults to the &lt;code&gt;submodule.fetchJobs&lt;/code&gt; option.</source>
          <target state="translated">동시에 가져온 서브 모듈의 수입니다. &lt;code&gt;submodule.fetchJobs&lt;/code&gt; 옵션이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="34de3b8749bfae0c14ff8d34783f05c9920748b5" translate="yes" xml:space="preserve">
          <source>The object can be a blob or a submodule commit. It implies the &lt;code&gt;-t&lt;/code&gt; option in &lt;code&gt;git-log&lt;/code&gt; to also find trees.</source>
          <target state="translated">오브젝트는 Blob 또는 서브 모듈 커밋 일 수 있습니다. &lt;code&gt;git-log&lt;/code&gt; 의 &lt;code&gt;-t&lt;/code&gt; 옵션을 사용하여 트리를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="2794f5933199b4937a09c41b8d049f6b88620c25" translate="yes" xml:space="preserve">
          <source>The object database contains objects of three main types: blobs, which hold file data; trees, which point to blobs and other trees to build up directory hierarchies; and commits, which each reference a single tree and some number of parent commits.</source>
          <target state="translated">오브젝트 데이터베이스에는 세 가지 주요 유형의 오브젝트가 있습니다. 파일 데이터를 보유하는 블롭; 디렉토리 계층을 구축하기위한 블롭 및 다른 트리를 가리키는 트리; 커밋-각각은 단일 트리와 몇 개의 부모 커밋을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="b5ea163b65a2243d9fc238d7c50700c517adc350" translate="yes" xml:space="preserve">
          <source>The object database is the rather elegant system used to store the history of your project&amp;mdash;​files, directories, and commits.</source>
          <target state="translated">객체 데이터베이스는 프로젝트 기록 (파일, 디렉토리 및 커밋)을 저장하는 데 사용되는 다소 우아한 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="db080c7937810b605e4381605a2e18077b89e3c0" translate="yes" xml:space="preserve">
          <source>The object name (aka SHA-1). For a non-ambiguous abbreviation of the object name append &lt;code&gt;:short&lt;/code&gt;. For an abbreviation of the object name with desired length append &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt;, where the minimum length is MINIMUM_ABBREV. The length may be exceeded to ensure unique object names.</source>
          <target state="translated">객체 이름 (일명 SHA-1). 객체 이름의 모호하지 않은 약어의 경우 append &lt;code&gt;:short&lt;/code&gt; . 원하는 길이를 추가 한 객체 이름의 약어 인 append &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt; 는 최소 길이가 MINIMUM_ABBREV입니다. 고유 한 객체 이름을 보장하기 위해 길이를 초과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b335d1a75376848bee9affb50a6203b316fcc02d" translate="yes" xml:space="preserve">
          <source>The object referenced by &amp;lt;src&amp;gt; is used to update the &amp;lt;dst&amp;gt; reference on the remote side. Whether this is allowed depends on where in &lt;code&gt;refs/*&lt;/code&gt; the &amp;lt;dst&amp;gt; reference lives as described in detail below, in those sections &quot;update&quot; means any modifications except deletes, which as noted after the next few sections are treated differently.</source>
          <target state="translated">&amp;lt;src&amp;gt;가 참조하는 객체는 원격 측에서 &amp;lt;dst&amp;gt; 참조를 업데이트하는 데 사용됩니다. 이것이 허용되는지 여부는 &lt;code&gt;refs/*&lt;/code&gt; 에서 &amp;lt;dst&amp;gt; 참조가 아래에 자세히 설명 된대로 존재 하는 위치에 따라 달라집니다. &quot;업데이트&quot;섹션에서 &quot;업데이트&quot;는 삭제를 제외한 모든 수정을 의미하며, 다음 섹션은 다르게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="afdbad7acf93ca3457880eb431fd58ab07141e11" translate="yes" xml:space="preserve">
          <source>The object table is actually a hashtable keyed on the object name (the unique SHA-1). This storage configuration allows fast-import to reuse an existing or already written object and avoid writing duplicates to the output packfile. Duplicate blobs are surprisingly common in an import, typically due to branch merges in the source.</source>
          <target state="translated">오브젝트 테이블은 실제로 오브젝트 이름 (고유 한 SHA-1)을 기반으로하는 해시 테이블입니다. 이 저장소 구성을 사용하면 빠른 가져 오기로 기존 또는 이미 작성된 객체를 재사용 할 수 있으며 출력 팩 파일에 복제본을 쓰지 않아도됩니다. 일반적으로 소스의 브랜치 병합으로 인해 가져 오기에서 중복 얼룩이 흔하게 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0b16e9c4d73790474d293fcd4d96547c235d7d1f" translate="yes" xml:space="preserve">
          <source>The object that the new tag will refer to, usually a commit. Defaults to HEAD.</source>
          <target state="translated">새 태그가 참조 할 객체, 일반적으로 커밋. 기본값은 HEAD입니다.</target>
        </trans-unit>
        <trans-unit id="5468420c6f62137502c6bb00574138b237765047" translate="yes" xml:space="preserve">
          <source>The object type may be a blob, representing the contents of a file, or another tree, representing the contents of a subdirectory. Since trees and blobs, like all other objects, are named by the SHA-1 hash of their contents, two trees have the same SHA-1 name if and only if their contents (including, recursively, the contents of all subdirectories) are identical. This allows Git to quickly determine the differences between two related tree objects, since it can ignore any entries with identical object names.</source>
          <target state="translated">객체 유형은 파일의 내용을 나타내는 블롭이거나 하위 디렉토리의 내용을 나타내는 다른 트리 일 수 있습니다. 다른 모든 객체와 마찬가지로 트리와 BLOB는 내용의 SHA-1 해시로 이름이 지정되므로 내용 (재귀 적으로 모든 하위 디렉토리의 내용 포함)이 동일한 경우에만 두 개의 트리가 동일한 SHA-1 이름을 갖습니다. . 이를 통해 Git은 동일한 객체 이름을 가진 항목을 무시할 수 있기 때문에 두 개의 관련 트리 객체 간의 차이점을 신속하게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abf9c48e6cb6157bcc4ecdd7fbfd1167ee2a4bc5" translate="yes" xml:space="preserve">
          <source>The object types in some more detail:</source>
          <target state="translated">객체 유형에 대한 자세한 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1aa11fdf087f0d8d0d32eb67b923b0efa29ecf46" translate="yes" xml:space="preserve">
          <source>The objects are output in the order in which they are found in the index file, which should be (in a correctly constructed file) sorted by object id.</source>
          <target state="translated">객체는 색인 파일에서 찾은 순서대로 출력되며,이 파일은 객체 ID별로 (정확하게 구성된 파일에서) 정렬되어야합니다.</target>
        </trans-unit>
        <trans-unit id="113c9617d3615ff46d1de3788621403d384bc970" translate="yes" xml:space="preserve">
          <source>The official repository of the &lt;code&gt;git gui&lt;/code&gt; project can be found at:</source>
          <target state="translated">&lt;code&gt;git gui&lt;/code&gt; 프로젝트 의 공식 저장소는 다음 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2925f4342d92a06228b4eeddfbffd0ada540f91" translate="yes" xml:space="preserve">
          <source>The one commit in this list that is not related to CMake may very well have been motivated by working on fixing all those bugs introduced by switching to CMake, but it addresses a different concern. To split this branch into two topic branches, the todo list could be edited like this:</source>
          <target state="translated">CMake와 관련이없는이 목록의 커밋은 CMake로 전환하여 발생하는 모든 버그를 수정하여 동기를 부여 받았을 수도 있지만 다른 문제를 해결합니다. 이 브랜치를 두 개의 토픽 브랜치로 나누기 위해 할 일 목록을 다음과 같이 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="680930999bd0e3bf9880124c135a89bca3a329f3" translate="yes" xml:space="preserve">
          <source>The oneline descriptions are purely for your pleasure; &lt;code&gt;git rebase&lt;/code&gt; will not look at them but at the commit names (&quot;deadbee&quot; and &quot;fa1afe1&quot; in this example), so do not delete or edit the names.</source>
          <target state="translated">oneline 설명은 순전히 당신의 즐거움을위한 것입니다. &lt;code&gt;git rebase&lt;/code&gt; 는 커밋 이름 (이 예제에서는 &quot;deadbee&quot;및 &quot;fa1afe1&quot;)을 보지 않으므로 이름을 삭제하거나 편집하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b174b5f513a45da66bee660cec63368b38af2a1f" translate="yes" xml:space="preserve">
          <source>The only difference between this command and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; is that they use slightly different output formats, and this command exists only for backward compatibility to support existing scripts, and provide a more familiar command name for people coming from other SCM systems.</source>
          <target state="translated">이 명령과 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; 의 유일한 차이점은 약간 다른 출력 형식을 사용한다는 점입니다.이 명령은 기존 스크립트를 지원하기 위해 이전 버전과의 호환성을 위해서만 존재하며 다른 SCM 시스템 사용자에게 친숙한 명령 이름을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="82fa629da6adc18439c1d9295d8f644e8391fd9b" translate="yes" xml:space="preserve">
          <source>The only safe place to make these changes is on the remote repository (i.e., the Git server), usually in the &lt;code&gt;pre-receive&lt;/code&gt; hook or in a continuous integration (CI) system. These are the locations in which policy can be enforced effectively.</source>
          <target state="translated">이러한 변경을 수행 할 수있는 유일한 안전한 장소는 일반적으로 &lt;code&gt;pre-receive&lt;/code&gt; 후크 또는 CI (연속 통합) 시스템 의 원격 저장소 (예 : Git 서버) 입니다. 정책을 효과적으로 시행 할 수있는 위치입니다.</target>
        </trans-unit>
        <trans-unit id="90482aceb580582ec33d188b8fb1bca29f8136a1" translate="yes" xml:space="preserve">
          <source>The option can have the following values, defaulting to &lt;code&gt;group&lt;/code&gt; if no value is given:</source>
          <target state="translated">이 옵션은 다음과 같은 값을 가질 수 있으며, 값이 제공되지 않으면 &lt;code&gt;group&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="72a352b7174eb63582b749d1295b267e0dae9887" translate="yes" xml:space="preserve">
          <source>The optional &amp;lt;limit&amp;gt; is useful in cases where your topic is based on other work that is not in upstream. Expanding on the previous example, this might look like:</source>
          <target state="translated">선택적인 &amp;lt;limit&amp;gt;는 주제가 업스트림이 아닌 다른 작업을 기반으로하는 경우에 유용합니다. 이전 예제에서 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4136e1c0c625091f77db10ec0b76e55e39fdb1b6" translate="yes" xml:space="preserve">
          <source>The optional &amp;lt;style&amp;gt; argument can be either &lt;code&gt;shallow&lt;/code&gt; or &lt;code&gt;deep&lt;/code&gt;. &lt;code&gt;shallow&lt;/code&gt; threading makes every mail a reply to the head of the series, where the head is chosen from the cover letter, the &lt;code&gt;--in-reply-to&lt;/code&gt;, and the first patch mail, in this order. &lt;code&gt;deep&lt;/code&gt; threading makes every mail a reply to the previous one.</source>
          <target state="translated">선택적 &amp;lt;style&amp;gt; 인수는 &lt;code&gt;shallow&lt;/code&gt; 또는 &lt;code&gt;deep&lt;/code&gt; 일 수 있습니다 . &lt;code&gt;shallow&lt;/code&gt; 스레딩은 모든 메일을 시리즈의 헤드에 대한 답장으로 만듭니다. 헤드는 표지, &lt;code&gt;--in-reply-to&lt;/code&gt; 및 첫 번째 패치 메일에서이 순서대로 선택됩니다. &lt;code&gt;deep&lt;/code&gt; 스레딩은 모든 메일을 이전 메일에 대한 회신으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="3dd98bdacd886ba292b303baaba2ecefebed8bab" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;encoding&lt;/code&gt; command indicates the encoding of the commit message. Most commits are UTF-8 and the encoding is omitted, but this allows importing commit messages into git without first reencoding them.</source>
          <target state="translated">선택적 &lt;code&gt;encoding&lt;/code&gt; 명령은 커밋 메시지의 인코딩을 나타냅니다. 대부분의 커밋은 UTF-8이며 인코딩은 생략되지만 커밋 메시지를 먼저 다시 인코딩하지 않고 git으로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1f596d4ea27770161ef3ea6df226eac8321e34f" translate="yes" xml:space="preserve">
          <source>The optional GPG signature of the tag.</source>
          <target state="translated">The optional GPG signature of the tag.</target>
        </trans-unit>
        <trans-unit id="b0ae75c1b10bf71d7e20ef9926e29585fa74a2e0" translate="yes" xml:space="preserve">
          <source>The optional argument &amp;lt;path&amp;gt; is the relative location for the cloned submodule to exist in the superproject. If &amp;lt;path&amp;gt; is not given, the canonical part of the source repository is used (&quot;repo&quot; for &quot;/path/to/repo.git&quot; and &quot;foo&quot; for &quot;host.xz:foo/.git&quot;). If &amp;lt;path&amp;gt; exists and is already a valid Git repository, then it is staged for commit without cloning. The &amp;lt;path&amp;gt; is also used as the submodule&amp;rsquo;s logical name in its configuration entries unless &lt;code&gt;--name&lt;/code&gt; is used to specify a logical name.</source>
          <target state="translated">선택적 인수 &amp;lt;path&amp;gt;는 복제 된 하위 모듈이 수퍼 프로젝트에 존재하는 상대 위치입니다. &amp;lt;path&amp;gt;를 지정하지 않으면 소스 저장소의 표준 부분이 사용됩니다 ( &quot;/path/to/repo.git&quot;의 경우 &quot;repo&quot;, &quot;host.xz : foo / .git&quot;의 경우 &quot;foo&quot;). &amp;lt;path&amp;gt;가 존재하고 이미 유효한 Git 리포지토리 인 경우 복제하지 않고 커밋을 위해 준비됩니다. &lt;code&gt;--name&lt;/code&gt; 을 사용하여 논리적 이름을 지정 하지 않으면 &amp;lt;path&amp;gt;는 구성 항목에서 하위 모듈의 논리적 이름으로도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="476c5c2c4870d6be72c4d31b42e1450136c51807" translate="yes" xml:space="preserve">
          <source>The optional configuration variable &lt;code&gt;core.excludesFile&lt;/code&gt; indicates a path to a file containing patterns of file names to exclude, similar to &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt;. Patterns in the exclude file are used in addition to those in &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt;.</source>
          <target state="translated">선택적 구성 변수 &lt;code&gt;core.excludesFile&lt;/code&gt; 은 &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; 와 유사하게 제외 할 파일 이름 패턴이 포함 된 파일의 경로를 나타냅니다 . 제외 파일의 패턴은 &lt;code&gt;$GIT_DIR/info/exclude&lt;/code&gt; 패턴과 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad80c43bd988ae6e6061dfab8a056d2afaee7691" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;--contains&lt;/code&gt;, &lt;code&gt;--no-contains&lt;/code&gt;, &lt;code&gt;--merged&lt;/code&gt; and &lt;code&gt;--no-merged&lt;/code&gt; serve four related but different purposes:</source>
          <target state="translated">옵션의 &lt;code&gt;--contains&lt;/code&gt; 는 , &lt;code&gt;--no-contains&lt;/code&gt; , &lt;code&gt;--merged&lt;/code&gt; 및 &lt;code&gt;--no-merged&lt;/code&gt; 사 관련이 있지만, 다른 용도로 사용</target>
        </trans-unit>
        <trans-unit id="081a3bdc8213b4774c97cebf32978af69c3476cb" translate="yes" xml:space="preserve">
          <source>The order of stages 1, 2 and 3 (hence the order of three &amp;lt;tree-ish&amp;gt; command-line arguments) are significant when you start a 3-way merge with an index file that is already populated. Here is an outline of how the algorithm works:</source>
          <target state="translated">단계 1, 2 및 3의 순서 (따라서 세 개의 &amp;lt;tree-ish&amp;gt; 명령 행 인수의 순서)는 이미 채워진 색인 파일과 3 방향 병합을 시작할 때 중요합니다. 다음은 알고리즘 작동 방식에 대한 개요입니다.</target>
        </trans-unit>
        <trans-unit id="3fb57cf5101f783ba73fc6eba17ed42ef2940627" translate="yes" xml:space="preserve">
          <source>The order of the flags used to matter, but not anymore.</source>
          <target state="translated">중요했던 플래그의 순서는 더 이상 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32a54a6aa8ff67e3d76c47c6fabd2affc1e5cbb5" translate="yes" xml:space="preserve">
          <source>The origin of lines is automatically followed across whole-file renames (currently there is no option to turn the rename-following off). To follow lines moved from one file to another, or to follow lines that were copied and pasted from another file, etc., see the &lt;code&gt;-C&lt;/code&gt; and &lt;code&gt;-M&lt;/code&gt; options.</source>
          <target state="translated">행의 원점은 전체 파일 이름 바꾸기에서 자동으로 따릅니다 (현재 이름 바꾸기를 끄는 옵션은 없습니다). 한 파일에서 다른 파일로 이동 한 행을 따르거나 다른 파일에서 복사하여 붙여 넣은 행을 따르려면 &lt;code&gt;-C&lt;/code&gt; 및 &lt;code&gt;-M&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b66619a4ae8f145d6aac4431781b08d6ac86597a" translate="yes" xml:space="preserve">
          <source>The origin revision can be changed with the &quot;--origin&quot; option.</source>
          <target state="translated">원점 수정은 &quot;--origin&quot;옵션으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="617fe8d1d55cfe9ccc09f76fcfa190410b239da3" translate="yes" xml:space="preserve">
          <source>The original format used by Greg Kroah-Hartman&amp;rsquo;s &lt;code&gt;send_lots_of_email.pl&lt;/code&gt; script</source>
          <target state="translated">Greg Kroah-Hartman의 &lt;code&gt;send_lots_of_email.pl&lt;/code&gt; 스크립트가 사용한 원래 형식</target>
        </trans-unit>
        <trans-unit id="a7a5cdcdcd4d6fcaaf02e53acebd8443c9b015da" translate="yes" xml:space="preserve">
          <source>The original job of &lt;code&gt;git rev-parse&lt;/code&gt; is now taken by the function &lt;code&gt;setup_revisions()&lt;/code&gt;, which parses the revisions and the common command-line options for the revision walker. This information is stored in the struct &lt;code&gt;rev_info&lt;/code&gt; for later consumption. You can do your own command-line option parsing after calling &lt;code&gt;setup_revisions()&lt;/code&gt;. After that, you have to call &lt;code&gt;prepare_revision_walk()&lt;/code&gt; for initialization, and then you can get the commits one by one with the function &lt;code&gt;get_revision()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git rev-parse&lt;/code&gt; 의 원래 작업 은 이제 &lt;code&gt;setup_revisions()&lt;/code&gt; 함수에 의해 수행됩니다.이 함수 는 개정 및 워커에 대한 공통 명령 행 옵션을 구문 분석합니다. 이 정보는 나중에 &lt;code&gt;rev_info&lt;/code&gt; 있도록 struct rev_info 에 저장됩니다 . &lt;code&gt;setup_revisions()&lt;/code&gt; 호출 한 후 고유 한 명령 행 옵션 구문 분석을 수행 할 수 있습니다 . 그 후, 당신은 전화로이 &lt;code&gt;prepare_revision_walk()&lt;/code&gt; 초기화, 다음은 함수에 의해 커밋 하나를 얻을 수 있습니다 &lt;code&gt;get_revision()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c9da327e28b59015cec84abd98a33aec635328d" translate="yes" xml:space="preserve">
          <source>The original tags are not deleted, but can be overwritten; use &quot;--tag-name-filter cat&quot; to simply update the tags. In this case, be very careful and make sure you have the old tags backed up in case the conversion has run afoul.</source>
          <target state="translated">원래 태그는 삭제되지 않지만 덮어 쓸 수 있습니다. 단순히 태그를 업데이트하려면 &quot;--tag-name-filter cat&quot;을 사용하십시오. 이 경우 전환에 문제가있는 경우를 대비하여 매우 신중하고 이전 태그를 백업해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c2cf73d4477ea65ac2368f08dedbcc07c9eafb4" translate="yes" xml:space="preserve">
          <source>The other nice thing with test suites, is that when you have one, you already know how to test for bad behavior. So you can use this knowledge to create a new test case for &quot;git bisect&quot; when it appears that there is a regression. So it will be easier to bisect the bug and fix it. And then you can add the test case you just created to your test suite.</source>
          <target state="translated">테스트 스위트의 또 다른 좋은 점은 하나가 있으면 나쁜 동작을 테스트하는 방법을 이미 알고 있다는 것입니다. 따라서이 지식을 사용하여 회귀가있는 경우 &quot;git bisect&quot;에 대한 새로운 테스트 사례를 만들 수 있습니다. 따라서 버그를 양분하고 수정하는 것이 더 쉬울 것입니다. 그런 다음 방금 생성 한 테스트 사례를 테스트 스위트에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94bda500b4b5c47f0218909469e6ab7f1eee52b6" translate="yes" xml:space="preserve">
          <source>The other way to drive the bisection process is to tell &quot;git bisect&quot; to launch a script or command at each bisection step to know if the current commit is &quot;good&quot; or &quot;bad&quot;. To do that, we use the &quot;git bisect run&quot; command. For example:</source>
          <target state="translated">bisection 프로세스를 구동하는 다른 방법은 &quot;git bisect&quot;에게 각 bisection 단계에서 스크립트 또는 명령을 실행하여 현재 커밋이 &quot;good&quot;또는 &quot;bad&quot;인지 알도록 지시하는 것입니다. 이를 위해 &quot;git bisect run&quot;명령을 사용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="013b9f528101f55f667633859403afae697697c4" translate="yes" xml:space="preserve">
          <source>The output format is modified to be machine-parsable (see below). If &lt;code&gt;--stdin&lt;/code&gt; is also given, input paths are separated with a NUL character instead of a linefeed character.</source>
          <target state="translated">출력 형식이 기계 구문 분석 가능하도록 수정되었습니다 (아래 참조). 경우 &lt;code&gt;--stdin&lt;/code&gt; 옵션은 또한 주어진 입력 경로는 널 문자 대신 개행 문자로 분리된다.</target>
        </trans-unit>
        <trans-unit id="4ebdc78d172a0b82e38a898aa2ae716344def4d5" translate="yes" xml:space="preserve">
          <source>The output format is modified to be machine-parsable. If &lt;code&gt;--stdin&lt;/code&gt; is also given, input paths are separated with a NUL character instead of a linefeed character.</source>
          <target state="translated">출력 형식이 기계 구문 분석 가능하도록 수정되었습니다. 경우 &lt;code&gt;--stdin&lt;/code&gt; 옵션은 또한 주어진 입력 경로는 널 문자 대신 개행 문자로 분리된다.</target>
        </trans-unit>
        <trans-unit id="885a3d9b027501a3f7ddd2554d827f984cacfcf5" translate="yes" xml:space="preserve">
          <source>The output format is similar to the Porcelain format, but it does not contain the actual lines from the file that is being annotated.</source>
          <target state="translated">출력 형식은 Porcelain 형식과 유사하지만 주석이 추가 된 파일의 실제 줄은 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="16ca2e6d144e9c4d47f91cfe57ded6c4b6f874af" translate="yes" xml:space="preserve">
          <source>The output from this command is designed to be used as a commit template comment. The default, long format, is designed to be human readable, verbose and descriptive. Its contents and format are subject to change at any time.</source>
          <target state="translated">이 명령의 출력은 커밋 템플릿 주석으로 사용되도록 설계되었습니다. 기본적으로 긴 형식은 사람이 읽을 수 있고 자세하며 설명이 가능하도록 설계되었습니다. 내용과 형식은 언제든지 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="467b04ab4f0f42e5eb4db50995625d7a06a04bbc" translate="yes" xml:space="preserve">
          <source>The output is in the format: &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;space&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;reference name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">출력은 &lt;code&gt;&amp;lt;SHA-1 ID&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;space&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;reference name&amp;gt;&lt;/code&gt; 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="297e105083265b9b5df9c784faa30006468bc5fd" translate="yes" xml:space="preserve">
          <source>The output is of the form: &amp;lt;path&amp;gt; COLON SP &amp;lt;attribute&amp;gt; COLON SP &amp;lt;info&amp;gt; LF</source>
          <target state="translated">출력은 &amp;lt;path&amp;gt; COLON SP &amp;lt;attribute&amp;gt; COLON SP &amp;lt;info&amp;gt; LF 형식입니다.</target>
        </trans-unit>
        <trans-unit id="00d47eecfb8e7c432b9a2a4461da0aa0b0a14445" translate="yes" xml:space="preserve">
          <source>The output is the new tag&amp;rsquo;s &amp;lt;object&amp;gt; identifier.</source>
          <target state="translated">출력은 새 태그의 &amp;lt;object&amp;gt; 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="c209f5f99a30592095be06f60778bfc6143218e8" translate="yes" xml:space="preserve">
          <source>The output of &quot;git fetch&quot; depends on the transport method used; this section describes the output when fetching over the Git protocol (either locally or via ssh) and Smart HTTP protocol.</source>
          <target state="translated">&quot;git fetch&quot;의 출력은 사용 된 전송 방법에 따라 다릅니다. 이 섹션에서는 Git 프로토콜 (로컬 또는 ssh를 통해) 및 Smart HTTP 프로토콜을 통해 가져올 때의 출력에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="249df455a76d6d8a4ee813f24ba8c68836888f67" translate="yes" xml:space="preserve">
          <source>The output of &quot;git push&quot; depends on the transport method used; this section describes the output when pushing over the Git protocol (either locally or via ssh).</source>
          <target state="translated">&quot;git push&quot;의 출력은 사용 된 전송 방법에 따라 다릅니다. 이 섹션에서는 로컬 또는 ssh를 통해 Git 프로토콜을 푸시 할 때의 출력에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2012a50a7ce95c41c81b087cc42352c50e07741b" translate="yes" xml:space="preserve">
          <source>The output of ls-refs is as follows:</source>
          <target state="translated">ls-refs의 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9897264787fe814346af61567793268dae2ec95" translate="yes" xml:space="preserve">
          <source>The output of the &lt;code&gt;range-diff&lt;/code&gt; command is subject to change. It is intended to be human-readable porcelain output, not something that can be used across versions of Git to get a textually stable &lt;code&gt;range-diff&lt;/code&gt; (as opposed to something like the &lt;code&gt;--stable&lt;/code&gt; option to &lt;a href=&quot;git-patch-id&quot;&gt;git-patch-id[1]&lt;/a&gt;). There&amp;rsquo;s also no equivalent of &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt; for &lt;code&gt;range-diff&lt;/code&gt;, the output is not intended to be machine-readable.</source>
          <target state="translated">&lt;code&gt;range-diff&lt;/code&gt; 명령 의 출력은 변경 될 수 있습니다. Git의 모든 버전에서 텍스트로 안정적인 &lt;code&gt;range-diff&lt;/code&gt; 를 얻는 데 사용할 수있는 것이 아니라 사람이 읽을 수있는 도자기 출력이되도록 고안되었습니다 ( &lt;a href=&quot;git-patch-id&quot;&gt;git-patch-id [-]에&lt;/a&gt; 대한 &lt;code&gt;--stable&lt;/code&gt; 옵션 과 반대 ) . &lt;code&gt;range-diff&lt;/code&gt; 에 대해 &lt;a href=&quot;git-apply&quot;&gt;git-apply [1]&lt;/a&gt; 에 해당하는 것도 없으며 , 출력은 기계 판독 가능하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="acccdb81223db3ebfe60a727e12d9a4ed87719fe" translate="yes" xml:space="preserve">
          <source>The output order is determined by the order of glob patterns in &amp;lt;orderfile&amp;gt;. All files with pathnames that match the first pattern are output first, all files with pathnames that match the second pattern (but not the first) are output next, and so on. All files with pathnames that do not match any pattern are output last, as if there was an implicit match-all pattern at the end of the file. If multiple pathnames have the same rank (they match the same pattern but no earlier patterns), their output order relative to each other is the normal order.</source>
          <target state="translated">출력 순서는 &amp;lt;orderfile&amp;gt;의 glob 패턴 순서에 따라 결정됩니다. 첫 번째 패턴과 일치하는 경로 이름을 가진 모든 파일이 먼저 출력되고 두 번째 패턴과 일치하는 경로 이름을 가진 모든 파일 (첫 번째는 아님)이 다음에 출력됩니다. 패턴 끝에 일치하지 않는 경로 이름을 가진 모든 파일은 파일 끝에 암시 적 일치 패턴이있는 것처럼 마지막에 출력됩니다. 여러 경로 이름이 동일한 순위를 갖는 경우 (동일한 패턴과 일치하지만 이전 패턴은 일치하지 않음) 서로에 대한 출력 순서는 정상적인 순서입니다.</target>
        </trans-unit>
        <trans-unit id="70ec2e58d64c53608a589a3f892a41e430e23c0e" translate="yes" xml:space="preserve">
          <source>The overall time needed to compute this algorithm is the time needed to compute n+m commit diffs and then n*m diffs of patches, plus the time needed to compute the least-cost assignment between n and m diffs. Git uses an implementation of the Jonker-Volgenant algorithm to solve the assignment problem, which has cubic runtime complexity. The matching found in this case will look like this:</source>
          <target state="translated">이 알고리즘을 계산하는 데 필요한 전체 시간은 n + m 커밋 차이를 계산 한 다음 n * m 패치를 계산하는 데 필요한 시간과 n과 m 차이 사이의 최소 비용 할당을 계산하는 데 필요한 시간입니다. Git은 Jonker-Volgenant 알고리즘의 구현을 사용하여 3 차 런타임 복잡성을 갖는 할당 문제를 해결합니다. 이 경우에 일치하는 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8c05a901b25f6434301621f82a267dcb0caae54" translate="yes" xml:space="preserve">
          <source>The p4 changes will be created as the user invoking &lt;code&gt;git p4 submit&lt;/code&gt;. The &lt;code&gt;--preserve-user&lt;/code&gt; option will cause ownership to be modified according to the author of the Git commit. This option requires admin privileges in p4, which can be granted using &lt;code&gt;p4 protect&lt;/code&gt;.</source>
          <target state="translated">사용자가 &lt;code&gt;git p4 submit&lt;/code&gt; 를 호출하면 p4 변경 사항이 작성됩니다 . &lt;code&gt;--preserve-user&lt;/code&gt; 옵션은 커밋 망할 놈의 저자에 따라 소유권이 변경되는 원인이됩니다. 이 옵션은 &lt;code&gt;p4 protect&lt;/code&gt; 를 사용하여 부여 할 수있는 p4의 관리자 권한이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="bc53387773cbb38b899a330a03a788e5288eab48" translate="yes" xml:space="preserve">
          <source>The p4 client specification is maintained with the &lt;code&gt;p4 client&lt;/code&gt; command and contains among other fields, a View that specifies how the depot is mapped into the client repository. The &lt;code&gt;clone&lt;/code&gt; and &lt;code&gt;sync&lt;/code&gt; commands can consult the client spec when given the &lt;code&gt;--use-client-spec&lt;/code&gt; option or when the useClientSpec variable is true. After &lt;code&gt;git p4 clone&lt;/code&gt;, the useClientSpec variable is automatically set in the repository configuration file. This allows future &lt;code&gt;git p4 submit&lt;/code&gt; commands to work properly; the submit command looks only at the variable and does not have a command-line option.</source>
          <target state="translated">p4 클라이언트 스펙은 &lt;code&gt;p4 client&lt;/code&gt; 명령으로 유지 보수되며 , 저장소가 클라이언트 저장소에 맵핑되는 방법을 지정하는보기 인 다른 필드를 포함합니다. &lt;code&gt;clone&lt;/code&gt; 및 &lt;code&gt;sync&lt;/code&gt; 주어진 경우 명령은 클라이언트 사양을 참조 할 수 &lt;code&gt;--use-client-spec&lt;/code&gt; 옵션 또는 때 useClientSpec 변수가 true를. &lt;code&gt;git p4 clone&lt;/code&gt; 후에 는 useClientSpec 변수가 저장소 구성 파일에 자동으로 설정됩니다. 이것은 미래의 &lt;code&gt;git p4 submit&lt;/code&gt; 명령이 올바르게 작동 하도록 합니다. submit 명령은 변수 만보고 명령 행 옵션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9fec68b06723905b09b9270262e6a13c1b490876" translate="yes" xml:space="preserve">
          <source>The p4 depot path argument to &lt;code&gt;git p4 sync&lt;/code&gt; and &lt;code&gt;git p4 clone&lt;/code&gt; can be one or more space-separated p4 depot paths, with an optional p4 revision specifier on the end:</source>
          <target state="translated">&lt;code&gt;git p4 sync&lt;/code&gt; 및 &lt;code&gt;git p4 clone&lt;/code&gt; 에 대한 p4 저장소 경로 인수 는 선택적 p4 개정 지정자가 끝에있는 하나 이상의 공백으로 분리 된 p4 저장소 경로 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d877dea1de89fdb5a15efd47a5debfe5403b96f4" translate="yes" xml:space="preserve">
          <source>The pack-indexes (.idx files) remain in the pack directory so we can delete the MIDX file, set core.midx to false, or downgrade without any loss of information.</source>
          <target state="translated">팩 인덱스 (.idx 파일)는 팩 디렉토리에 남아 있으므로 MIDX 파일을 삭제하거나 core.midx를 false로 설정하거나 정보 손실없이 다운 그레이드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="933f30be1e83e4fe09dc8528b693f5b5a75f065d" translate="yes" xml:space="preserve">
          <source>The packed archive format (.pack) is designed to be self-contained so that it can be unpacked without any further information. Therefore, each object that a delta depends upon must be present within the pack.</source>
          <target state="translated">압축 아카이브 형식 (.pack)은 추가 정보없이 압축을 풀 수 있도록 자체 포함되도록 설계되었습니다. 따라서 델타가 의존하는 각 오브젝트는 팩 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="75cd7427877d4a48fded775aaaba114771e37304" translate="yes" xml:space="preserve">
          <source>The packfile(s) created by fast-import do not encourage good disk access patterns. This is caused by fast-import writing the data in the order it is received on standard input, while Git typically organizes data within packfiles to make the most recent (current tip) data appear before historical data. Git also clusters commits together, speeding up revision traversal through better cache locality.</source>
          <target state="translated">빠른 가져 오기로 작성된 팩 파일은 양호한 디스크 액세스 패턴을 권장하지 않습니다. 이는 표준 입력에서 수신 한 순서대로 데이터를 빠르게 가져 오기 때문에 발생합니다. Git은 일반적으로 가장 최근 (현재의 팁) 데이터가 기록 데이터 앞에 나타나도록 팩 파일 내에 데이터를 구성합니다. 또한 Git은 클러스터를 함께 커밋하여 더 나은 캐시 위치를 통해 개정 순회를 가속화합니다.</target>
        </trans-unit>
        <trans-unit id="73715b9a828b5f7ca9623cd366d376d487c8e126" translate="yes" xml:space="preserve">
          <source>The partial clone feature records special &quot;promisor&quot; packs that may point to objects that are not stored locally, but available on request to a server. The multi-pack-index does not currently track these promisor packs.</source>
          <target state="translated">부분 복제 기능은 로컬에 저장되지 않았지만 요청시 서버에 사용 가능한 개체를 가리킬 수있는 특수 &quot;프로 미저&quot;팩을 기록합니다. 다중 팩 인덱스는 현재 이러한 유망 팩을 추적하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="608e992a19f0287b5b2e4cbdc92416d882bd253c" translate="yes" xml:space="preserve">
          <source>The password to use when logging in to the server.</source>
          <target state="translated">서버에 로그인 할 때 사용할 비밀번호입니다.</target>
        </trans-unit>
        <trans-unit id="f899bc9ba76fee3c960f01f1f955c5a4bf020e98" translate="yes" xml:space="preserve">
          <source>The patch extracted from e-mail.</source>
          <target state="translated">전자 우편에서 추출한 패치입니다.</target>
        </trans-unit>
        <trans-unit id="621265bbad5d0651c63283720f8a5ccddfdeeb61" translate="yes" xml:space="preserve">
          <source>The patch is expected to be inline, directly following the message. Any line that is of the form:</source>
          <target state="translated">패치는 메시지 바로 다음에 인라인이 될 것으로 예상됩니다. 다음과 같은 형식의 라인 :</target>
        </trans-unit>
        <trans-unit id="eedf9ed2547b7a76bcd6fb69785bf954af8d224f" translate="yes" xml:space="preserve">
          <source>The patch itself does not apply cleanly. That is &lt;code&gt;bad&lt;/code&gt; but does not have much to do with your MUA. You might want to rebase the patch with &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; before regenerating it in this case.</source>
          <target state="translated">패치 자체는 깨끗하게 적용되지 않습니다. 그것은 &lt;code&gt;bad&lt;/code&gt; MUA와 관련이 없습니다. 이 경우 패치를 다시 생성하기 전에 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]로&lt;/a&gt; 패치를 리베이스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9ecbf09d9172bac5285d567a6e1031058a01024" translate="yes" xml:space="preserve">
          <source>The patch produced by &lt;code&gt;git format-patch&lt;/code&gt; is in UNIX mailbox format, with a fixed &quot;magic&quot; time stamp to indicate that the file is output from format-patch rather than a real mailbox, like so:</source>
          <target state="translated">&lt;code&gt;git format-patch&lt;/code&gt; 에 의해 생성 된 패치 는 UNIX 메일 박스 형식이며, 고정 된 &quot;마법의&quot;타임 스탬프는 다음과 같이 파일이 실제 메일 상자가 아닌 format-patch에서 출력됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7072603eb0a607d061c366f3e4a9cba6cffbd377" translate="yes" xml:space="preserve">
          <source>The path can be either absolute or relative. A relative path is taken as relative to the directory where the hooks are run (see the &quot;DESCRIPTION&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;).</source>
          <target state="translated">경로는 절대적이거나 상대적 일 수 있습니다. 상대 경로는 후크가 실행되는 디렉토리를 기준으로합니다 ( &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 의 &quot;DESCRIPTION&quot;섹션 참조 ).</target>
        </trans-unit>
        <trans-unit id="6ccace0f35f0f4e5cab0e8cffbdf924135579b2e" translate="yes" xml:space="preserve">
          <source>The path has the attribute with special value &quot;false&quot;; this is specified by listing the name of the attribute prefixed with a dash &lt;code&gt;-&lt;/code&gt; in the attribute list.</source>
          <target state="translated">경로에는 특수 값이 &quot;false&quot;인 속성이 있습니다. 이것은 대시로 시작하는 속성의 이름을 나열하여 지정 &lt;code&gt;-&lt;/code&gt; 속성리스트에 있습니다.</target>
        </trans-unit>
        <trans-unit id="96cc920a42ed7b296307f756480841c1366430ee" translate="yes" xml:space="preserve">
          <source>The path has the attribute with special value &quot;true&quot;; this is specified by listing only the name of the attribute in the attribute list.</source>
          <target state="translated">경로에는 특수 값 &quot;true&quot;를 갖는 속성이 있습니다. 이것은 속성 목록에 속성 이름 만 나열하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="f3d259c7dde8e69cba5e131da2dcac58054c5102" translate="yes" xml:space="preserve">
          <source>The path has the attribute with specified string value; this is specified by listing the name of the attribute followed by an equal sign &lt;code&gt;=&lt;/code&gt; and its value in the attribute list.</source>
          <target state="translated">경로에는 지정된 문자열 값을 가진 속성이 있습니다. 이것은 속성 이름과 등호 &lt;code&gt;=&lt;/code&gt; 및 속성 값을 속성 목록에 나열하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="9a89a340b481b20bfabef5b1bcb5482c1e173e57" translate="yes" xml:space="preserve">
          <source>The path to a list of object names (i.e. one unabbreviated SHA-1 per line) that are known to be broken in a non-fatal way and should be ignored. On versions of Git 2.20 and later comments (&lt;code&gt;#&lt;/code&gt;), empty lines, and any leading and trailing whitespace is ignored. Everything but a SHA-1 per line will error out on older versions.</source>
          <target state="translated">치명적이지 않은 방식으로 손상되어 무시되는 것으로 알려진 개체 이름 목록 (즉, 줄당 하나의 SHA-1)에 대한 경로입니다. Git 2.20 및 이후 버전의 주석 ( &lt;code&gt;#&lt;/code&gt; ), 빈 줄 및 선행 및 후행 공백은 무시됩니다. 라인 당 SHA-1을 제외한 모든 것은 이전 버전에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="66bacdcfb6546645ce51a1173beecea036fe198b" translate="yes" xml:space="preserve">
          <source>The path to higher software quality is significantly improved software testing.</source>
          <target state="translated">소프트웨어 품질 향상의 길은 소프트웨어 테스트를 크게 개선하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a62f8e77f19dbb91947274f4224d3b2000deceef" translate="yes" xml:space="preserve">
          <source>The path with which the credential will be used. E.g., for accessing a remote https repository, this will be the repository&amp;rsquo;s path on the server.</source>
          <target state="translated">신임 정보가 사용될 경로입니다. 예를 들어 원격 https 리포지토리에 액세스하려면 서버의 리포지토리 경로가됩니다.</target>
        </trans-unit>
        <trans-unit id="75a6542b84624c1ec2a2753cb02bac2dc12deb38" translate="yes" xml:space="preserve">
          <source>The path within the &amp;lt;repository&amp;gt; that the action is performed on, for those actions that require it.</source>
          <target state="translated">조치가 필요한 &amp;lt;repository&amp;gt; 내의 경로.</target>
        </trans-unit>
        <trans-unit id="42c5355b2496aa717e00373f3c96e2614e271309" translate="yes" xml:space="preserve">
          <source>The pathname of a file containing previously stored cookie lines, which should be used in the Git http session, if they match the server. The file format of the file to read cookies from should be plain HTTP headers or the Netscape/Mozilla cookie file format (see &lt;code&gt;curl(1)&lt;/code&gt;). NOTE that the file specified with http.cookieFile is used only as input unless http.saveCookies is set.</source>
          <target state="translated">이전에 저장된 쿠키 행을 포함하는 파일의 경로 이름으로, 서버와 일치하는 경우 Git http 세션에서 사용해야합니다. 쿠키를 읽을 파일의 파일 형식은 일반 HTTP 헤더 또는 Netscape / Mozilla 쿠키 파일 형식이어야합니다 ( &lt;code&gt;curl(1)&lt;/code&gt; 참조 ). http.cookieFile로 지정된 파일은 http.saveCookies가 설정되어 있지 않으면 입력으로 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7529cc524422963391df3cb62b329f757e09e898" translate="yes" xml:space="preserve">
          <source>The pathname of a file that stores a client certificate to use to authenticate with an HTTPS proxy. Can be overridden by the &lt;code&gt;GIT_PROXY_SSL_CERT&lt;/code&gt; environment variable.</source>
          <target state="translated">The pathname of a file that stores a client certificate to use to authenticate with an HTTPS proxy. Can be overridden by the &lt;code&gt;GIT_PROXY_SSL_CERT&lt;/code&gt; environment variable.</target>
        </trans-unit>
        <trans-unit id="5cd72157b1a828f8662a88c728954dfe8fd532c2" translate="yes" xml:space="preserve">
          <source>The pathname of a file that stores a private key to use to authenticate with an HTTPS proxy. Can be overridden by the &lt;code&gt;GIT_PROXY_SSL_KEY&lt;/code&gt; environment variable.</source>
          <target state="translated">The pathname of a file that stores a private key to use to authenticate with an HTTPS proxy. Can be overridden by the &lt;code&gt;GIT_PROXY_SSL_KEY&lt;/code&gt; environment variable.</target>
        </trans-unit>
        <trans-unit id="cdb891f79fbec881d22446bf8cf74ef0a3e451e0" translate="yes" xml:space="preserve">
          <source>The paths mentioned in the output, unlike many other Git commands, are made relative to the current directory if you are working in a subdirectory (this is on purpose, to help cutting and pasting). See the status.relativePaths config option below.</source>
          <target state="translated">다른 Git 명령과 달리 출력에 언급 된 경로는 하위 디렉토리에서 작업하는 경우 현재 디렉토리를 기준으로 만들어집니다 (절삭 및 붙여 넣기를 돕기위한 것임). 아래 status.relativePaths 구성 옵션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ae851010ea42ad696931dec57e7a58d6d0655b81" translate="yes" xml:space="preserve">
          <source>The pathspecs are used to limit the world diff operates in. They remove the filepairs outside the specified sets of pathnames. E.g. If the input set of filepairs included:</source>
          <target state="translated">pathspec은 월드 diff가 작동하는 것을 제한하는 데 사용됩니다. 지정된 pathname 세트 외부의 파일 쌍을 제거합니다. 예를 들어 입력 파일 세트 세트가 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="a35fe6e03b5cf8e686f61a60362e87d3cf937722" translate="yes" xml:space="preserve">
          <source>The pattern &quot;foo/*&quot;, matches &quot;foo/test.json&quot; (a regular file), &quot;foo/bar&quot; (a directory), but it does not match &quot;foo/bar/hello.c&quot; (a regular file), as the asterisk in the pattern does not match &quot;bar/hello.c&quot; which has a slash in it.</source>
          <target state="translated">&quot;foo / *&quot;패턴은 &quot;foo / test.json&quot;(일반 파일), &quot;foo / bar&quot;(디렉토리)와 일치하지만 &quot;foo / bar / hello.c&quot;(일반 파일)와 일치하지 않습니다 ), 패턴의 별표가 슬래시가있는 &quot;bar / hello.c&quot;와 일치하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="472a6ff8d8e6e0153adf76e5ad83f89df7215b9f" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;doc/frotz&lt;/code&gt; and &lt;code&gt;/doc/frotz&lt;/code&gt; have the same effect in any &lt;code&gt;.gitignore&lt;/code&gt; file. In other words, a leading slash is not relevant if there is already a middle slash in the pattern.</source>
          <target state="translated">패턴 &lt;code&gt;doc/frotz&lt;/code&gt; 및 &lt;code&gt;/doc/frotz&lt;/code&gt; 어떤에서 같은 효과가 &lt;code&gt;.gitignore&lt;/code&gt; 의 파일을. 즉, 패턴에 중간 슬래시가있는 경우 선행 슬래시는 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f3e3da749b8fed6cc11585c7aa5dbe77eee53ad" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;foo/&lt;/code&gt; will match a directory &lt;code&gt;foo&lt;/code&gt; and paths underneath it, but will not match a regular file or a symbolic link &lt;code&gt;foo&lt;/code&gt; (this is consistent with the way how pathspec works in general in Git)</source>
          <target state="translated">패턴 &lt;code&gt;foo/&lt;/code&gt; 는 디렉토리 &lt;code&gt;foo&lt;/code&gt; 및 그 아래의 경로와 일치하지만 일반 파일 또는 기호 링크 &lt;code&gt;foo&lt;/code&gt; 와 일치하지 않습니다 (이것은 경로 스펙이 Git에서 일반적으로 작동하는 방식과 일치합니다)</target>
        </trans-unit>
        <trans-unit id="32166ee916b00891724c1bd52223b5e1e2d10da0" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;hello.*&lt;/code&gt; matches any file or folder whose name begins with &lt;code&gt;hello&lt;/code&gt;. If one wants to restrict this only to the directory and not in its subdirectories, one can prepend the pattern with a slash, i.e. &lt;code&gt;/hello.*&lt;/code&gt;; the pattern now matches &lt;code&gt;hello.txt&lt;/code&gt;, &lt;code&gt;hello.c&lt;/code&gt; but not &lt;code&gt;a/hello.java&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hello.*&lt;/code&gt; 패턴 은 이름이 &lt;code&gt;hello&lt;/code&gt; 로 시작하는 파일 또는 폴더와 일치합니다 . 서브 디렉토리가 아닌 디렉토리로만 제한하려는 경우 슬래시 (예 : &lt;code&gt;/hello.*&lt;/code&gt; )를 사용 하여 패턴을 추가 할 수 있습니다 . 패턴은 이제 &lt;code&gt;hello.txt&lt;/code&gt; , &lt;code&gt;hello.c&lt;/code&gt; 와 일치 하지만 &lt;code&gt;a/hello.java&lt;/code&gt; 와는 일치 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b35cb663783a3682a66157f3dc9fd508efdfceba" translate="yes" xml:space="preserve">
          <source>The pattern can contain standard globbing wildcards and two additional ones, &lt;code&gt;**/&lt;/code&gt; and &lt;code&gt;/**&lt;/code&gt;, that can match multiple path components. Please refer to &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt; for details. For convenience:</source>
          <target state="translated">이 패턴에는 표준 경로 지정 와일드 카드와 여러 경로 구성 요소와 일치 할 수있는 두 개의 추가 &lt;code&gt;**/&lt;/code&gt; 및 &lt;code&gt;/**&lt;/code&gt; 가 포함될 수 있습니다 . 자세한 내용은 &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; 를 참조하십시오. 편의상:</target>
        </trans-unit>
        <trans-unit id="ae88d32c3f9079756948f2fdc8ae4c4c2e834b93" translate="yes" xml:space="preserve">
          <source>The patterns given should not begin with &lt;code&gt;refs/heads&lt;/code&gt;, &lt;code&gt;refs/tags&lt;/code&gt;, or &lt;code&gt;refs/remotes&lt;/code&gt; when applied to &lt;code&gt;--branches&lt;/code&gt;, &lt;code&gt;--tags&lt;/code&gt;, or &lt;code&gt;--remotes&lt;/code&gt;, respectively, and they must begin with &lt;code&gt;refs/&lt;/code&gt; when applied to &lt;code&gt;--glob&lt;/code&gt; or &lt;code&gt;--all&lt;/code&gt;. If a trailing &lt;code&gt;/*&lt;/code&gt; is intended, it must be given explicitly.</source>
          <target state="translated">로 시작하지 않아야 주어진 패턴 &lt;code&gt;refs/heads&lt;/code&gt; , &lt;code&gt;refs/tags&lt;/code&gt; , 또는 &lt;code&gt;refs/remotes&lt;/code&gt; 에 적용 할 때 &lt;code&gt;--branches&lt;/code&gt; 는 , &lt;code&gt;--tags&lt;/code&gt; , 또는 &lt;code&gt;--remotes&lt;/code&gt; 는 각각, 그들은 시작해야 &lt;code&gt;refs/&lt;/code&gt; 에 적용 할 때 &lt;code&gt;--glob&lt;/code&gt; 또는 &lt;code&gt;--all&lt;/code&gt; . 후행 &lt;code&gt;/*&lt;/code&gt; 가 의도 된 경우 명시 적으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="86b0de7f6b1176e8c07c5aaa523447c3abd4915b" translate="yes" xml:space="preserve">
          <source>The performance format target (PERF) is a column-based format to replace GIT_TRACE_PERFORMANCE and is suitable for development and testing, possibly to complement tools like gprof. This format is enabled with the &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; environment variable or the &lt;code&gt;trace2.perfTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">PERF (Performance Format Target)는 GIT_TRACE_PERFORMANCE를 대체하는 열 기반 형식이며 개발 및 테스트에 적합하며 gprof와 같은 도구를 보완 할 수 있습니다. 이 형식은 &lt;code&gt;GIT_TRACE2_PERF&lt;/code&gt; 환경 변수 또는 &lt;code&gt;trace2.perfTarget&lt;/code&gt; 시스템 또는 글로벌 구성 설정으로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="506071bbd9d0908b14e8f015ca1b0ff23e4ec21e" translate="yes" xml:space="preserve">
          <source>The performance of git-filter-branch is glacially slow; its design makes it impossible for a backward-compatible implementation to ever be fast:</source>
          <target state="translated">git-filter-branch의 성능은 빙하 적으로 느립니다. 그것의 디자인은 이전 버전과 호환되는 구현이 빠를 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d698b970e30734158c98cc5647b57a259a47bb36" translate="yes" xml:space="preserve">
          <source>The person who put a piece of code into Git.</source>
          <target state="translated">코드 조각을 Git에 넣은 사람.</target>
        </trans-unit>
        <trans-unit id="81b84527afb0ae2e697e75bbd7638af25fa12741" translate="yes" xml:space="preserve">
          <source>The pickaxe search is described in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; (the description of &lt;code&gt;-S&amp;lt;string&amp;gt;&lt;/code&gt; option, which refers to pickaxe entry in &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore[7]&lt;/a&gt; for more details).</source>
          <target state="translated">곡괭이 검색은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; ( 자세한 내용 은 &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore [7]의&lt;/a&gt; 곡괭이 항목을 나타내는 &lt;code&gt;-S&amp;lt;string&amp;gt;&lt;/code&gt; 옵션에 대한 설명)에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="525e6a0e6ee3d9fa31ab39c46532aa0c693111e1" translate="yes" xml:space="preserve">
          <source>The placeholders are:</source>
          <target state="translated">자리 표시자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1651136b42ed906ec527c0b5bb6ead2e015774c3" translate="yes" xml:space="preserve">
          <source>The point of this helper is to reduce the number of times you must type your username or password. For example:</source>
          <target state="translated">이 도우미의 요점은 사용자 이름이나 암호를 입력해야하는 횟수를 줄이는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c89cea9d29e269d3d21a2bb103d39e43b1e539d2" translate="yes" xml:space="preserve">
          <source>The porcelain format</source>
          <target state="translated">도자기 형식</target>
        </trans-unit>
        <trans-unit id="26e08a1995b67cc0010521ba6bed170106483645" translate="yes" xml:space="preserve">
          <source>The porcelain format generally suppresses commit information that has already been seen. For example, two lines that are blamed to the same commit will both be shown, but the details for that commit will be shown only once. This is more efficient, but may require more state be kept by the reader. The &lt;code&gt;--line-porcelain&lt;/code&gt; option can be used to output full commit information for each line, allowing simpler (but less efficient) usage like:</source>
          <target state="translated">도자기 형식은 일반적으로 이미 본 커밋 정보를 억제합니다. 예를 들어, 동일한 커밋으로 비난 된 두 줄이 모두 표시되지만 해당 커밋에 대한 세부 정보는 한 번만 표시됩니다. 이것은 더 효율적이지만 독자가 더 많은 상태를 유지해야 할 수도 있습니다. &lt;code&gt;--line-porcelain&lt;/code&gt; 옵션은 전체 같은 간단한 (하지만 비효율적) 사용을 허용, 각 라인에 대한 정보를 커밋 출력에 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="20c54b7279b5d1b2be6928d44083be1fd00dfbb8" translate="yes" xml:space="preserve">
          <source>The porcelain format has a line per attribute. Attributes are listed with a label and value separated by a single space. Boolean attributes (like &lt;code&gt;bare&lt;/code&gt; and &lt;code&gt;detached&lt;/code&gt;) are listed as a label only, and are only present if and only if the value is true. The first attribute of a worktree is always &lt;code&gt;worktree&lt;/code&gt;, an empty line indicates the end of the record. For example:</source>
          <target state="translated">도자기 형식에는 속성 당 한 줄이 있습니다. 속성은 레이블과 값이 단일 공백으로 구분되어 나열됩니다. 부울 속성 ( &lt;code&gt;bare&lt;/code&gt; 및 &lt;code&gt;detached&lt;/code&gt; 등 )은 레이블로만 나열되며 값이 true 인 경우에만 나타납니다. 작업 트리의 첫 번째 속성은 항상 &lt;code&gt;worktree&lt;/code&gt; 이며 빈 줄은 레코드의 끝을 나타냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d78141a7bccc3a1873780a422f8d41a19ce92e1b" translate="yes" xml:space="preserve">
          <source>The porcelain format has a line per attribute. Attributes are listed with a label and value separated by a single space. Boolean attributes (like &lt;code&gt;bare&lt;/code&gt; and &lt;code&gt;detached&lt;/code&gt;) are listed as a label only, and are present only if the value is true. The first attribute of a working tree is always &lt;code&gt;worktree&lt;/code&gt;, an empty line indicates the end of the record. For example:</source>
          <target state="translated">The porcelain format has a line per attribute. Attributes are listed with a label and value separated by a single space. Boolean attributes (like &lt;code&gt;bare&lt;/code&gt; and &lt;code&gt;detached&lt;/code&gt; ) are listed as a label only, and are present only if the value is true. The first attribute of a working tree is always &lt;code&gt;worktree&lt;/code&gt; , an empty line indicates the end of the record. For example:</target>
        </trans-unit>
        <trans-unit id="a362940b066b853917862099c8e9ab263cba72b1" translate="yes" xml:space="preserve">
          <source>The port number to bind the gitweb httpd to. See &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;.</source>
          <target state="translated">gitweb httpd를 바인딩 할 포트 번호. &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cecf31c324042fa16f4839249194885b3982bae" translate="yes" xml:space="preserve">
          <source>The port number to bind the httpd to. (Default: 1234)</source>
          <target state="translated">httpd를 바인딩 할 포트 번호입니다. (기본값 : 1234)</target>
        </trans-unit>
        <trans-unit id="735bfd35b5b101e4c116696c3cd1ebf6bc58faa9" translate="yes" xml:space="preserve">
          <source>The possible options are:</source>
          <target state="translated">가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8bc0e360ec6eefb74bc5a1aed65f13e846b6d915" translate="yes" xml:space="preserve">
          <source>The preferred strategy for rolling out a version bump (whether whole repository or for a single file) is to teach git to read the new format, and allow writing the new format with a config switch or command line option (for experimentation or for those who do not care about backwards compatibility with older gits). Then after a long period to allow the reading capability to become common, we may switch to writing the new format by default.</source>
          <target state="translated">버전 범프 (전체 저장소 또는 단일 파일에 관계없이)를 롤아웃하는 데 선호되는 전략은 git에게 새 형식을 읽도록 설정하고 구성 스위치 또는 명령 줄 옵션으로 실험 또는 이전 gits와의 하위 호환성에 대해서는 신경 쓰지 마십시오. 그런 다음 읽기 기능이 일반화되도록 오랜 시간이 지난 후 기본적으로 새 형식 쓰기로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adf8f6f66c16d1ab5dcd5c39342b75931e439ba4" translate="yes" xml:space="preserve">
          <source>The prefix ability basically makes it trivial to use &lt;code&gt;git checkout-index&lt;/code&gt; as an &quot;export as tree&quot; function. Just read the desired tree into the index, and do:</source>
          <target state="translated">접두사 기능은 기본적으로 &lt;code&gt;git checkout-index&lt;/code&gt; 를 &quot;트리로 내보내기&quot;기능 으로 사용하는 것이 간단 합니다. 원하는 트리를 인덱스로 읽고 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0f1fc4f35ab6b79f4468bd7525c0542dc9193da5" translate="yes" xml:space="preserve">
          <source>The previously introduced &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; is just a wrapper for &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">이전에 소개 된 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 은 &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt; 의 래퍼 일뿐 입니다.</target>
        </trans-unit>
        <trans-unit id="675ae216ecd575fef2e1ffa9eadeda52bdab6e90" translate="yes" xml:space="preserve">
          <source>The primary problem with rewriting the history of a branch has to do with merging. Suppose somebody fetches your branch and merges it into their branch, with a result something like this:</source>
          <target state="translated">브랜치 히스토리를 재 작성할 때의 주요 문제점은 병합과 관련이 있습니다. 누군가가 분기를 가져 와서 분기로 병합한다고 가정하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ff3dc4a94f1f540e3dd725f6eef6c2d405d85a87" translate="yes" xml:space="preserve">
          <source>The primary tool we&amp;rsquo;ve been using to create commits is &lt;code&gt;git-commit
-a&lt;/code&gt;, which creates a commit including every change you&amp;rsquo;ve made to your working tree. But what if you want to commit changes only to certain files? Or only certain changes to certain files?</source>
          <target state="translated">커밋을 만드는 데 사용했던 기본 도구는 &lt;code&gt;git-commit -a&lt;/code&gt; 이며 작업 트리에 대한 모든 변경 사항을 포함하여 커밋을 만듭니다. 그러나 특정 파일에만 변경 사항을 커밋하려면 어떻게해야합니까? 아니면 특정 파일에 대한 특정 변경 사항 만 있습니까?</target>
        </trans-unit>
        <trans-unit id="bc32172ebad82b3a8531284b76fc91d0e2655fc8" translate="yes" xml:space="preserve">
          <source>The protection it offers over &lt;code&gt;--force&lt;/code&gt; is ensuring that subsequent changes your work wasn&amp;rsquo;t based on aren&amp;rsquo;t clobbered, but this is trivially defeated if some background process is updating refs in the background. We don&amp;rsquo;t have anything except the remote tracking info to go by as a heuristic for refs you&amp;rsquo;re expected to have seen &amp;amp; are willing to clobber.</source>
          <target state="translated">그것이 &lt;code&gt;--force&lt;/code&gt; 로 제공하는 보호는 작업이 기반으로하지 않은 후속 변경 사항이 방해받지 않도록 보장하지만 일부 백그라운드 프로세스가 백그라운드에서 참조를 업데이트하면 사소하게 무시됩니다. 원격 추적 정보 이외의 다른 정보는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c8ef7004934ae749808b9e22322b2c11275f98e4" translate="yes" xml:space="preserve">
          <source>The protocol names currently used by git are:</source>
          <target state="translated">현재 git에서 사용되는 프로토콜 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="19913c2c5a680884fd5ab271ea84dfe92e10bf53" translate="yes" xml:space="preserve">
          <source>The protocol over which the credential will be used (e.g., &lt;code&gt;https&lt;/code&gt;).</source>
          <target state="translated">신임 정보가 사용될 프로토콜 (예 : &lt;code&gt;https&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="27c53e4d1c63b3496c93b1976851fe0522937712" translate="yes" xml:space="preserve">
          <source>The provided options must not contain a NUL or LF character.</source>
          <target state="translated">제공된 옵션에는 NUL 또는 LF 문자가 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="5fb1f43ddd5fc4b8ac18d086f82e6f88c9ed5855" translate="yes" xml:space="preserve">
          <source>The purpose of gitignore files is to ensure that certain files not tracked by Git remain untracked.</source>
          <target state="translated">gitignore 파일의 목적은 Git이 추적하지 않는 특정 파일이 추적되지 않도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a2b9675d20ab3c1e80e15b296d660914f6ea2131" translate="yes" xml:space="preserve">
          <source>The purpose of the hook is to edit the message file in place, and it is not suppressed by the &lt;code&gt;--no-verify&lt;/code&gt; option. A non-zero exit means a failure of the hook and aborts the commit. It should not be used as replacement for pre-commit hook.</source>
          <target state="translated">후크의 목적은 메시지 파일을 제자리에서 편집하는 것이며 &lt;code&gt;--no-verify&lt;/code&gt; 옵션으로 억제되지 않습니다 . 0이 아닌 종료는 후크 실패를 의미하며 커밋을 중단합니다. 사전 커미트 후크를 대체하는 데 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="96e3995f595001b3f723f5fc30a3546a03e6b50b" translate="yes" xml:space="preserve">
          <source>The purpose of the hook is to edit the message file in place, and it is not supressed by the &lt;code&gt;--no-verify&lt;/code&gt; option. This hook is called even if &lt;code&gt;--prepare-p4-only&lt;/code&gt; is set.</source>
          <target state="translated">The purpose of the hook is to edit the message file in place, and it is not supressed by the &lt;code&gt;--no-verify&lt;/code&gt; option. This hook is called even if &lt;code&gt;--prepare-p4-only&lt;/code&gt; is set.</target>
        </trans-unit>
        <trans-unit id="383a661ab7ffdec395082f1f22f245f53263885b" translate="yes" xml:space="preserve">
          <source>The push URL of a remote repository. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">원격 저장소의 푸시 URL입니다. &lt;a href=&quot;git-push&quot;&gt;git-push [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8cd29a2b80ae7f4721c7a9c69324052af609357" translate="yes" xml:space="preserve">
          <source>The push done by the other person updated the branch that used to point at commit X to point at commit A. It is a fast-forward.</source>
          <target state="translated">다른 사람이 한 푸시는 커밋 X가 커밋 A를 가리 키도록 사용했던 브랜치를 업데이트했습니다.</target>
        </trans-unit>
        <trans-unit id="79a20eedac198c71849aef6d1fe1606ea1ee319f" translate="yes" xml:space="preserve">
          <source>The quilt series file.</source>
          <target state="translated">이불 시리즈 파일.</target>
        </trans-unit>
        <trans-unit id="eb2f9ed5ec284eab8396a9b582f3da5582d364ca" translate="yes" xml:space="preserve">
          <source>The raw output format from &quot;git-diff-index&quot;, &quot;git-diff-tree&quot;, &quot;git-diff-files&quot; and &quot;git diff --raw&quot; are very similar.</source>
          <target state="translated">&quot;git-diff-index&quot;, &quot;git-diff-tree&quot;, &quot;git-diff-files&quot;및 &quot;git diff --raw&quot;의 원시 출력 형식은 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="a6ab1028c44c2d54846a9217b4a7ad959d178f38" translate="yes" xml:space="preserve">
          <source>The reachability bitmap is currently paired directly with a single packfile, using the pack-order as the object order to hopefully compress the bitmaps well using run-length encoding. This could be extended to pair a reachability bitmap with a multi-pack-index. If the multi-pack-index is extended to store a &quot;stable object order&quot; (a function Order(hash) = integer that is constant for a given hash, even as the multi-pack-index is updated) then a reachability bitmap could point to a multi-pack-index and be updated independently.</source>
          <target state="translated">도달 가능성 비트 맵은 현재 실행 순서 인코딩을 사용하여 비트 맵을 잘 압축하기 위해 팩 순서를 객체 순서로 사용하여 단일 팩 파일과 직접 쌍을 이룹니다. 도달 가능성 비트 맵을 다중 팩 인덱스와 쌍으로 확장 할 수 있습니다. 멀티 팩 인덱스가 &quot;안정된 객체 순서&quot;(멀티 팩 인덱스가 업데이트 되더라도 주어진 해시에 대해 상수 인 함수 Order (hash) = 정수)를 저장하도록 확장되면 도달 가능성 비트 맵은 멀티 팩 인덱스를 가리키고 독립적으로 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="0aca04dff2f76e52dde4dcdd1542bfe4e1470100" translate="yes" xml:space="preserve">
          <source>The reason fast-import uses &lt;code&gt;:&lt;/code&gt; to denote a mark reference is this character is not legal in a Git branch name. The leading &lt;code&gt;:&lt;/code&gt; makes it easy to distinguish between the mark 42 (&lt;code&gt;:42&lt;/code&gt;) and the branch 42 (&lt;code&gt;42&lt;/code&gt; or &lt;code&gt;refs/heads/42&lt;/code&gt;), or an abbreviated SHA-1 which happened to consist only of base-10 digits.</source>
          <target state="translated">빠른 가져 오기가 &lt;code&gt;:&lt;/code&gt; 를 사용하여 마크 참조를 표시하는 이유 는이 문자가 Git 브랜치 이름에 적합하지 않기 때문입니다. 선행 &lt;code&gt;:&lt;/code&gt; 마크 42 ( &lt;code&gt;:42&lt;/code&gt; )와 분기 42 ( &lt;code&gt;42&lt;/code&gt; 또는 &lt;code&gt;refs/heads/42&lt;/code&gt; ) 또는 10 진수만으로 구성된 약어 SHA-1을 쉽게 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1aba410e8fcfe74102eea2fcf73898889acee3ed" translate="yes" xml:space="preserve">
          <source>The reason it doesn&amp;rsquo;t error out when provided without &lt;code&gt;--prune&lt;/code&gt; or its config versions is for flexibility of the configured versions, and to maintain a 1=1 mapping between what the command line flags do, and what the configuration versions do.</source>
          <target state="translated">&lt;code&gt;--prune&lt;/code&gt; 또는 구성 버전 없이 제공 될 때 오류가 발생하지 않는 이유 는 구성된 버전의 유연성과 명령 줄 플래그의 기능과 구성 버전의 기능간에 1 = 1 매핑을 유지하기 위함 입니다.</target>
        </trans-unit>
        <trans-unit id="b2defd752d90b2a93e28eb3efe0e516f3fc264fc" translate="yes" xml:space="preserve">
          <source>The rebase will stop where &lt;code&gt;pick&lt;/code&gt; has been replaced with &lt;code&gt;edit&lt;/code&gt; or when a step in the list fails to mechanically resolve conflicts and needs your help. When you are done editing and/or resolving conflicts you can continue with &lt;code&gt;git rebase --continue&lt;/code&gt;. If you decide that things are getting too hairy, you can always bail out with &lt;code&gt;git rebase
--abort&lt;/code&gt;. Even after the rebase is complete, you can still recover the original branch by using the &lt;a href=&quot;#reflogs&quot;&gt;reflog&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pick&lt;/code&gt; 이 &lt;code&gt;edit&lt;/code&gt; 으로 대체 되거나 목록의 단계가 충돌을 기계적으로 해결하지 못해 도움이 필요한 경우 rebase가 중지됩니다 . 충돌 편집 및 / 또는 해결이 끝나면 &lt;code&gt;git rebase --continue&lt;/code&gt; 를 계속할 수 있습니다 . 물건이 너무 털이 있다고 결정하면 언제든지 &lt;code&gt;git rebase --abort&lt;/code&gt; 구제 할 수 있습니다 . 리베이스가 완료된 후에도 &lt;a href=&quot;#reflogs&quot;&gt;reflog&lt;/a&gt; 를 사용하여 원래 분기를 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="939cf091c711a461fc7775d9278b48a4457f30c1" translate="yes" xml:space="preserve">
          <source>The ref namespace is hierarchical. Different subhierarchies are used for different purposes (e.g. the &lt;code&gt;refs/heads/&lt;/code&gt; hierarchy is used to represent local branches).</source>
          <target state="translated">ref 네임 스페이스는 계층 적입니다. 서로 다른 하위 계층이 서로 다른 목적으로 사용됩니다 (예 : 참조 &lt;code&gt;refs/heads/&lt;/code&gt; 계층이 로컬 분기를 나타내는 데 사용됨).</target>
        </trans-unit>
        <trans-unit id="d11d2f57237e560f1ae2f7da112ae694568b2d78" translate="yes" xml:space="preserve">
          <source>The ref which the given symbolic ref refers to. If not a symbolic ref, nothing is printed. Respects the &lt;code&gt;:short&lt;/code&gt;, &lt;code&gt;:lstrip&lt;/code&gt; and &lt;code&gt;:rstrip&lt;/code&gt; options in the same way as &lt;code&gt;refname&lt;/code&gt; above.</source>
          <target state="translated">주어진 기호 참조가 참조하는 참조. 기호 참조가 아닌 경우 아무것도 인쇄되지 않습니다. 위의 &lt;code&gt;refname&lt;/code&gt; 과 같은 방식으로 &lt;code&gt;:short&lt;/code&gt; , &lt;code&gt;:lstrip&lt;/code&gt; 및 &lt;code&gt;:rstrip&lt;/code&gt; 옵션을 존중합니다 .</target>
        </trans-unit>
        <trans-unit id="09256802b46aa557905f47df9fc0a1148d341199" translate="yes" xml:space="preserve">
          <source>The reflogs are kept by default for 30 days, after which they may be pruned. See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt; and &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; to learn how to control this pruning, and see the &quot;SPECIFYING REVISIONS&quot; section of &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; for details.</source>
          <target state="translated">reflog는 기본적으로 30 일 동안 유지되며 그 후에 정리 될 수 있습니다. 참조 &lt;a href=&quot;git-reflog&quot;&gt;자식-reflog [1]&lt;/a&gt; 와 &lt;a href=&quot;git-gc&quot;&gt;자식-GC [1]&lt;/a&gt; 의 &quot;개정 이력을 지정하기&quot;섹션이 가지 치기를 제어하고 참조하는 방법을 배울 수 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 세부 사항을.</target>
        </trans-unit>
        <trans-unit id="29e87ce112fa8f38582e71025c0e3c162626939f" translate="yes" xml:space="preserve">
          <source>The refname parameter is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 arguments are the object names for the refname before and after the update. Note that the hook is called before the refname is updated, so either sha1-old is 0{40} (meaning there is no such ref yet), or it should match what is recorded in refname.</source>
          <target state="translated">refname 매개 변수는 $ GIT_DIR에 상대적입니다. 예를 들어 마스터 헤드의 경우 &quot;refs / heads / master&quot;입니다. 두 sha1 인수는 업데이트 전후의 참조 이름에 대한 객체 이름입니다. 참조 이름이 업데이트되기 전에 후크가 호출되므로 sha1-old는 0 {40} (아직 그러한 참조가 없음을 의미 함)이거나 참조 이름에 기록 된 것과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="21810fe3549bedbdcfb85519d93701f4c1ec8042" translate="yes" xml:space="preserve">
          <source>The refname value is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 values before each refname are the object names for the refname before and after the update. Refs that were created will have sha1-old equal to 0{40}, while refs that were deleted will have sha1-new equal to 0{40}, otherwise sha1-old and sha1-new should be valid objects in the repository.</source>
          <target state="translated">참조 이름 값은 $ GIT_DIR에 상대적입니다. 예를 들어 마스터 헤드의 경우 &quot;refs / heads / master&quot;입니다. 각 참조 이름 앞의 두 sha1 값은 업데이트 전후의 참조 이름에 대한 객체 이름입니다. 작성된 참조는 sha1이 0 {40}이고, 삭제 된 참조는 sha1이 0 {40}과 같으며, 그렇지 않으면 sha1-old 및 sha1new는 저장소에서 유효한 오브젝트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="f7cd6bb7198b77eda24e90f3bdabb1a4fb56aeb0" translate="yes" xml:space="preserve">
          <source>The refname value is relative to $GIT_DIR; e.g. for the master head this is &quot;refs/heads/master&quot;. The two sha1 values before each refname are the object names for the refname before and after the update. Refs to be created will have sha1-old equal to 0{40}, while refs to be deleted will have sha1-new equal to 0{40}, otherwise sha1-old and sha1-new should be valid objects in the repository.</source>
          <target state="translated">참조 이름 값은 $ GIT_DIR에 상대적입니다. 예를 들어 마스터 헤드의 경우 &quot;refs / heads / master&quot;입니다. 각 참조 이름 앞의 두 sha1 값은 업데이트 전후의 참조 이름에 대한 객체 이름입니다. 생성 된 참조는 sha1-old는 0 {40}이고, 삭제 될 참조는 sha1-new는 0 {40}입니다. 그렇지 않으면 sha1-old 및 sha1-new는 리포지토리에서 유효한 객체 여야합니다.</target>
        </trans-unit>
        <trans-unit id="efb922792d6081ee214f4a8e1d665108721507f6" translate="yes" xml:space="preserve">
          <source>The refs are using the given hash algorithm. This keyword is only used if the server and client both support the object-format extension.</source>
          <target state="translated">The refs are using the given hash algorithm. This keyword is only used if the server and client both support the object-format extension.</target>
        </trans-unit>
        <trans-unit id="ce26e3499eea5a4c24942a8e072b3a9539557d0b" translate="yes" xml:space="preserve">
          <source>The regex can also be set via a diff driver or configuration option, see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; or &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;. Giving it explicitly overrides any diff driver or configuration setting. Diff drivers override configuration settings.</source>
          <target state="translated">정규식은 diff 드라이버 또는 구성 옵션을 통해 설정할 수도 있습니다 ( &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 또는 &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조)&lt;/a&gt; . 이를 제공하면 diff 드라이버 또는 구성 설정이 명시 적으로 무시됩니다. Diff 드라이버는 구성 설정보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="db9cbae31eee7dd0453a2f75d2431a49c7ce5a43" translate="yes" xml:space="preserve">
          <source>The regex must capture the source branch name in $1.</source>
          <target state="translated">정규식은 소스 분기 이름을 $ 1로 캡처해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f22e3781909efae9d373f9fa46942441b8a264c" translate="yes" xml:space="preserve">
          <source>The regular expression that the diff driver should use to recognize the hunk header. A built-in pattern may also be used. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">diff 드라이버가 덩어리 헤더를 인식하는 데 사용해야하는 정규식입니다. 내장 패턴을 사용할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4211f7342bdc098f581fc9d7939f84dc24cd9689" translate="yes" xml:space="preserve">
          <source>The regular expression that the diff driver should use to split words in a line. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">diff 드라이버가 단어를 한 줄로 나눌 때 사용해야하는 정규식입니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aa527c60a8440b01958ab1ade21254172db5c938" translate="yes" xml:space="preserve">
          <source>The remainder of the commit or the tag message that follows the &quot;subject&quot;.</source>
          <target state="translated">The remainder of the commit or the tag message that follows the &quot;subject&quot;.</target>
        </trans-unit>
        <trans-unit id="f0619f2eb83a7faf485cba23bd4bbef8fb0cb4dd" translate="yes" xml:space="preserve">
          <source>The remainder of the line, after stripping the spaces, is used as the help associated to the option.</source>
          <target state="translated">공백을 제거한 후 나머지 줄은 옵션과 관련된 도움말로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="19c5350e9da63f63a8abbccc7168a03dfd13ebac" translate="yes" xml:space="preserve">
          <source>The remaining features cannot be overridden on a per project basis.</source>
          <target state="translated">나머지 기능은 프로젝트별로 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="303228bfc99fc67a561e0782dc3e0ceb08c259bb" translate="yes" xml:space="preserve">
          <source>The remote branch name for a submodule, used by &lt;code&gt;git submodule
update --remote&lt;/code&gt;. Set this option to override the value found in the &lt;code&gt;.gitmodules&lt;/code&gt; file. See &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;git submodule update --remote&lt;/code&gt; 의해 사용되는 서브 모듈의 원격 브랜치 이름 . &lt;code&gt;.gitmodules&lt;/code&gt; 파일 에있는 값을 무시하려면이 옵션을 설정 하십시오. 자세한 내용은 &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; 및 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4fdf928f1cd746e7574e5e26895f63052b9e3300" translate="yes" xml:space="preserve">
          <source>The remote configuration is achieved using the &lt;code&gt;remote.origin.url&lt;/code&gt; and &lt;code&gt;remote.origin.fetch&lt;/code&gt; configuration variables. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">원격 구성은 &lt;code&gt;remote.origin.url&lt;/code&gt; 및 &lt;code&gt;remote.origin.fetch&lt;/code&gt; 구성 변수를 사용하여 수행됩니다 . ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e7b65b070cfabceee72964f903404025034f8258" translate="yes" xml:space="preserve">
          <source>The remote end did not report the successful update of the ref, perhaps because of a temporary error on the remote side, a break in the network connection, or other transient error.</source>
          <target state="translated">원격 측에서 원격 측의 일시적인 오류, 네트워크 연결 끊기 또는 기타 일시적인 오류로 인해 참조의 성공적인 업데이트를보고하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="53c927a78ca0c11dc61a2c100f0e02c446d49374" translate="yes" xml:space="preserve">
          <source>The remote end refused the update. Usually caused by a hook on the remote side, or because the remote repository has one of the following safety options in effect: &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; (for pushes to the checked out branch), &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; (for forced non-fast-forward updates), &lt;code&gt;receive.denyDeletes&lt;/code&gt; or &lt;code&gt;receive.denyDeleteCurrent&lt;/code&gt;. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">원격 끝이 업데이트를 거부했습니다. 일반적으로 원격 측의 후크로 인해 발생하거나 원격 저장소에 다음 안전 옵션 중 하나가 적용되어 있기 때문에 발생합니다. &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; (체크 아웃 된 분기로 푸시), &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; (비 빨리 감기 강제 업데이트의 경우) ), &lt;code&gt;receive.denyDeletes&lt;/code&gt; 또는 &lt;code&gt;receive.denyDeleteCurrent&lt;/code&gt; 입니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9422d899b3eadda77c8387091e37d96facb6c2f" translate="yes" xml:space="preserve">
          <source>The remote heads to update from. This is relative to $GIT_DIR (e.g. &quot;HEAD&quot;, &quot;refs/heads/master&quot;). When unspecified, update from all heads the remote side has.</source>
          <target state="translated">업데이트 할 원격 헤드 이는 $ GIT_DIR과 관련이 있습니다 (예 : &quot;HEAD&quot;, &quot;refs / heads / master&quot;). 지정되지 않은 경우 원격 측에있는 모든 헤드에서 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="0419c5b470511fe246bdc207ab1f44978b5929c7" translate="yes" xml:space="preserve">
          <source>The remote hostname for a network credential.</source>
          <target state="translated">네트워크 자격 증명의 원격 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="2acecc1c91d3ba6caf56ecf7245b62c949c434da" translate="yes" xml:space="preserve">
          <source>The remote hostname for a network credential. This includes the port number if one was specified (e.g., &quot;example.com:8088&quot;).</source>
          <target state="translated">The remote hostname for a network credential. This includes the port number if one was specified (e.g., &quot;example.com:8088&quot;).</target>
        </trans-unit>
        <trans-unit id="a7632b9807699f7e6cd146f3dd66e0428b068933" translate="yes" xml:space="preserve">
          <source>The remote ref that matches &amp;lt;src&amp;gt; is fetched, and if &amp;lt;dst&amp;gt; is not an empty string, an attempt is made to update the local ref that matches it.</source>
          <target state="translated">&amp;lt;src&amp;gt;와 일치하는 원격 참조가 페치되고 &amp;lt;dst&amp;gt;가 빈 문자열이 아닌 경우 일치하는 로컬 참조를 업데이트하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="282ef7eedc5a5bdee9740e04ed8375ea205f3da3" translate="yes" xml:space="preserve">
          <source>The remote refs to update.</source>
          <target state="translated">원격은 업데이트를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="1126548b6dd0a73d0e4b3cf8a47f765ced5296ec" translate="yes" xml:space="preserve">
          <source>The remote to push to by default. Overrides &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; for all branches, and is overridden by &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; for specific branches.</source>
          <target state="translated">기본적으로 푸시 할 리모콘입니다. 오버라이드 (override) &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 모든 지점에 대한, 그리고에 의해 무시되는 &lt;code&gt;branch.&amp;lt;name&amp;gt;.pushRemote&lt;/code&gt; 특정 지점에 대해.</target>
        </trans-unit>
        <trans-unit id="69cc315a656a6408b19c28c1250214347094ab33" translate="yes" xml:space="preserve">
          <source>The replaced object and the replacement object must be of the same type. This restriction can be bypassed using &lt;code&gt;-f&lt;/code&gt;.</source>
          <target state="translated">대체 된 오브젝트와 대체 오브젝트는 동일한 유형이어야합니다. 이 제한은 &lt;code&gt;-f&lt;/code&gt; 를 사용하여 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ad56792b1c232c0733d7ad92a2a6edfcbfd7d1e" translate="yes" xml:space="preserve">
          <source>The report does not tell you anything about lines which have been deleted or replaced; you need to use a tool such as &lt;code&gt;git diff&lt;/code&gt; or the &quot;pickaxe&quot; interface briefly mentioned in the following paragraph.</source>
          <target state="translated">보고서는 삭제되거나 교체 된 라인에 대해서는 아무 것도 알려주지 않습니다. 다음 단락에서 간략하게 언급 한 &lt;code&gt;git diff&lt;/code&gt; 또는 &quot;pickaxe&quot;인터페이스 와 같은 도구를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b4fd8af335028abdc88c8957e63b788cd43e89cc" translate="yes" xml:space="preserve">
          <source>The report of the commands of this hook should have the same order as the input. The exit status of the &lt;code&gt;proc-receive&lt;/code&gt; hook only determines the success or failure of the group of commands sent to it, unless atomic push is in use.</source>
          <target state="translated">The report of the commands of this hook should have the same order as the input. The exit status of the &lt;code&gt;proc-receive&lt;/code&gt; hook only determines the success or failure of the group of commands sent to it, unless atomic push is in use.</target>
        </trans-unit>
        <trans-unit id="2c986c29f6ffa22f2a8c706bbb75b7aeb4461294" translate="yes" xml:space="preserve">
          <source>The repository URL to be pulled from.</source>
          <target state="translated">가져올 리포지토리 URL입니다.</target>
        </trans-unit>
        <trans-unit id="944d2d5ccd37faa608b4a3dce165543a5adf2fbf" translate="yes" xml:space="preserve">
          <source>The repository the action will be performed on.</source>
          <target state="translated">조치가 수행 될 저장소입니다.</target>
        </trans-unit>
        <trans-unit id="0e7c4601cfd7634812fd5318d08d4f529fb59bef" translate="yes" xml:space="preserve">
          <source>The repository to get a tar archive from.</source>
          <target state="translated">tar 아카이브를 가져올 저장소입니다.</target>
        </trans-unit>
        <trans-unit id="bc81f7623489d466e462d3597d8dc6ebd3c462a1" translate="yes" xml:space="preserve">
          <source>The repository to sync from.</source>
          <target state="translated">동기화 할 저장소입니다.</target>
        </trans-unit>
        <trans-unit id="3d7b45c15d44961366710f29c0592cfbaf8293a2" translate="yes" xml:space="preserve">
          <source>The repository to sync into.</source>
          <target state="translated">동기화 할 저장소입니다.</target>
        </trans-unit>
        <trans-unit id="85a32286326310d42bba4488de0fbceb84f9845b" translate="yes" xml:space="preserve">
          <source>The repository to update.</source>
          <target state="translated">업데이트 할 저장소입니다.</target>
        </trans-unit>
        <trans-unit id="15ea4cb9c0b7ca59bf54604e4e274c258d2ab5d8" translate="yes" xml:space="preserve">
          <source>The response of &lt;code&gt;fetch&lt;/code&gt; is broken into a number of sections separated by delimiter packets (0001), with each section beginning with its section header.</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 응답은 구분자 패킷 (0001)으로 구분 된 여러 섹션으로 구분되며 각 섹션은 섹션 헤더로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="f5a3baabdc3717b14a2e7f02d6a5a2eab21baf8b" translate="yes" xml:space="preserve">
          <source>The response of &lt;code&gt;fetch&lt;/code&gt; is broken into a number of sections separated by delimiter packets (0001), with each section beginning with its section header. Most sections are sent only when the packfile is sent.</source>
          <target state="translated">The response of &lt;code&gt;fetch&lt;/code&gt; is broken into a number of sections separated by delimiter packets (0001), with each section beginning with its section header. Most sections are sent only when the packfile is sent.</target>
        </trans-unit>
        <trans-unit id="4f1a001f6b3f7c16917c0e0241e976b8717f870a" translate="yes" xml:space="preserve">
          <source>The rest of the documentation discusses &lt;code&gt;fsck.*&lt;/code&gt; for brevity, but the same applies for the corresponding &lt;code&gt;receive.fsck.*&lt;/code&gt; and &lt;code&gt;fetch.&amp;lt;msg-id&amp;gt;.*&lt;/code&gt;. variables.</source>
          <target state="translated">설명서의 나머지 부분에서는 간결성을 위해 &lt;code&gt;fsck.*&lt;/code&gt; 에 대해 설명 하지만 해당 &lt;code&gt;receive.fsck.*&lt;/code&gt; 및 &lt;code&gt;fetch.&amp;lt;msg-id&amp;gt;.*&lt;/code&gt; 에도 동일하게 적용됩니다 . 변수.</target>
        </trans-unit>
        <trans-unit id="ac10b74ced74e00c661f52e9250a42f47fd6add4" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;git merge-base --octopus A B C&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;, because &lt;code&gt;2&lt;/code&gt; is the best common ancestor of all commits.</source>
          <target state="translated">의 결과 &lt;code&gt;git merge-base --octopus A B C&lt;/code&gt; 이다 &lt;code&gt;2&lt;/code&gt; 때문에, &lt;code&gt;2&lt;/code&gt; 모든 커밋의 최선의 공통 조상이다.</target>
        </trans-unit>
        <trans-unit id="1e8fa948e18ddfaa21178042cd566eaada7aae80" translate="yes" xml:space="preserve">
          <source>The result of comparison is passed from these commands to what is internally called &quot;diffcore&quot;, in a format similar to what is output when the -p option is not used. E.g.</source>
          <target state="translated">비교 결과는 -p 옵션을 사용하지 않을 때 출력되는 것과 유사한 형식으로 이러한 명령에서 내부적으로 &quot;diffcore&quot;로 전달됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="d6478eddd3e6be6e1f0703d8450a597d1ea3dfe6" translate="yes" xml:space="preserve">
          <source>The result of such a bisection would be that we would find that H is the first bad commit, when in fact it&amp;rsquo;s B. So that would be wrong!</source>
          <target state="translated">그러한 이분법의 결과는 실제로 B 일 때 H가 첫 번째 잘못된 커밋임을 알게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="9ed4c9f58d5e6595458ce4cb4952fdfe7c07ce9b" translate="yes" xml:space="preserve">
          <source>The resulting command then has an &quot;operation&quot; argument appended to it (see below for details), and the result is executed by the shell.</source>
          <target state="translated">The resulting command then has an &quot;operation&quot; argument appended to it (see below for details), and the result is executed by the shell.</target>
        </trans-unit>
        <trans-unit id="baad8b31b0f95aa1296c5c88ad34816424f2926e" translate="yes" xml:space="preserve">
          <source>The resulting directory proj.git contains a &quot;bare&quot; git repository&amp;mdash;​it is just the contents of the &lt;code&gt;.git&lt;/code&gt; directory, without any files checked out around it.</source>
          <target state="translated">결과 디렉토리 proj.git에는 &quot;bare&quot;git 저장소가 있습니다. 파일을 체크 아웃하지 않고 &lt;code&gt;.git&lt;/code&gt; 디렉토리 의 내용 일뿐 입니다.</target>
        </trans-unit>
        <trans-unit id="31dc4b206e7be8ca9a78c4871cc58f03a5340e5b" translate="yes" xml:space="preserve">
          <source>The revision data is appended to the file if it already exists, for use when doing incremental imports.</source>
          <target state="translated">증분 가져 오기를 수행 할 때 사용할 수 있도록 수정본 데이터가 이미 존재하는 경우 파일에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="0ca811b30547ebe29846859e95a6c9147e8141b4" translate="yes" xml:space="preserve">
          <source>The rewrite rule guarantees that existing static files will be properly served, whereas any other URL will be passed to gitweb as PATH_INFO parameter.</source>
          <target state="translated">다시 쓰기 규칙은 기존 정적 파일이 올바르게 제공되는 반면 다른 URL은 PATH_INFO 매개 변수로 gitweb에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="7511d9248c0671ec876d283606ae9df0bea2f6b2" translate="yes" xml:space="preserve">
          <source>The ripple effect of a &quot;hard case&quot; recovery is especially bad: &lt;code&gt;everyone&lt;/code&gt; downstream from &lt;code&gt;topic&lt;/code&gt; will now have to perform a &quot;hard case&quot; recovery too!</source>
          <target state="translated">&quot;하드 케이스&quot;복구의 파급 효과는 특히 나쁩니다. 이제 &lt;code&gt;topic&lt;/code&gt; &lt;code&gt;everyone&lt;/code&gt; 다운 스트림 사용자도 &quot;하드 케이스&quot;복구를 수행해야합니다!</target>
        </trans-unit>
        <trans-unit id="93d5c7537e241865d860131eb6d72edc95c9d772" translate="yes" xml:space="preserve">
          <source>The root of the CVS archive. May be local (a simple path) or remote; currently, only the :local:, :ext: and :pserver: access methods are supported. If not given, &lt;code&gt;git cvsimport&lt;/code&gt; will try to read it from &lt;code&gt;CVS/Root&lt;/code&gt;. If no such file exists, it checks for the &lt;code&gt;CVSROOT&lt;/code&gt; environment variable.</source>
          <target state="translated">CVS 아카이브의 루트 로컬 (간단한 경로) 또는 원격 일 수 있습니다. 현재 : local :, : ext : 및 : pserver : 액세스 방법 만 지원됩니다. 지정하지 않으면 &lt;code&gt;git cvsimport&lt;/code&gt; 는 &lt;code&gt;CVS/Root&lt;/code&gt; 에서 읽습니다 . 그러한 파일이 없으면 &lt;code&gt;CVSROOT&lt;/code&gt; 환경 변수를 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="df41fdf293aec02e3dee1ead27003284471a1181" translate="yes" xml:space="preserve">
          <source>The root of the tree can be represented by an empty string as &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">트리의 루트는 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 로 빈 문자열로 표시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="557dc21e01559e09224bc25bcbd6a672b4e3d883" translate="yes" xml:space="preserve">
          <source>The rule to determine which remote branch to merge after fetching is a bit involved, in order not to break backward compatibility.</source>
          <target state="translated">이전 버전과의 호환성을 위반하지 않기 위해 페치 후 병합 할 원격 브랜치를 결정하는 규칙이 약간 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bbff5506f0bff9eed6d1a29f80ce8f838449bb56" translate="yes" xml:space="preserve">
          <source>The rules by which the pattern matches paths are the same as in &lt;code&gt;.gitignore&lt;/code&gt; files (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;), with a few exceptions:</source>
          <target state="translated">패턴이 경로와 일치하는 규칙은 &lt;code&gt;.gitignore&lt;/code&gt; 파일 ( &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; 참조 )과 동일하지만 몇 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="579e7c08387accae89723ba13e3ec53145837232" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;--merge&lt;/code&gt; option above, but changes the way the conflicting hunks are presented, overriding the &lt;code&gt;merge.conflictStyle&lt;/code&gt; configuration variable. Possible values are &quot;merge&quot; (default) and &quot;diff3&quot; (in addition to what is shown by &quot;merge&quot; style, shows the original contents).</source>
          <target state="translated">위의 &lt;code&gt;--merge&lt;/code&gt; 옵션 과 동일 하지만 충돌하는 덩어리가 표시되는 방식을 변경하여 &lt;code&gt;merge.conflictStyle&lt;/code&gt; 구성 변수를 재정의하십시오 . 가능한 값은 &quot;병합&quot;(기본값) 및 &quot;diff3&quot;입니다 ( &quot;병합&quot;스타일로 표시되는 것 외에 원래 내용 표시).</target>
        </trans-unit>
        <trans-unit id="1a11cc7f94381fe2de07d484775d2914bf62d241" translate="yes" xml:space="preserve">
          <source>The same as the previous one:</source>
          <target state="translated">이전과 동일</target>
        </trans-unit>
        <trans-unit id="ebdfbbadd1b4e3e4d3c390aed297730072348592" translate="yes" xml:space="preserve">
          <source>The same rewind and rebuild process may be followed for &lt;code&gt;pu&lt;/code&gt;. A public announcement is not necessary since &lt;code&gt;pu&lt;/code&gt; is a throw-away branch, as described above.</source>
          <target state="translated">&lt;code&gt;pu&lt;/code&gt; 에 대해 동일한 되감기 및 재구성 프로세스가 수행 될 수 있습니다 . &lt;code&gt;pu&lt;/code&gt; 는 위에서 설명한 것처럼 버림 지점 이므로 공개 발표가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="982acf1816c2fb0e10e67de1c939cdcea16cc699" translate="yes" xml:space="preserve">
          <source>The same rewind and rebuild process may be followed for &lt;code&gt;seen&lt;/code&gt;. A public announcement is not necessary since &lt;code&gt;seen&lt;/code&gt; is a throw-away branch, as described above.</source>
          <target state="translated">The same rewind and rebuild process may be followed for &lt;code&gt;seen&lt;/code&gt; . A public announcement is not necessary since &lt;code&gt;seen&lt;/code&gt; is a throw-away branch, as described above.</target>
        </trans-unit>
        <trans-unit id="30d931302d20c8d2d3f4d29cdb99720d08f56244" translate="yes" xml:space="preserve">
          <source>The same trailer as a v1 pack file:</source>
          <target state="translated">v1 팩 파일과 동일한 트레일러 :</target>
        </trans-unit>
        <trans-unit id="ef6e4cd5de79a2002e4df69090fc16d7024fe532" translate="yes" xml:space="preserve">
          <source>The sample &lt;code&gt;prepare-commit-msg&lt;/code&gt; hook that comes with Git removes the help message found in the commented portion of the commit template.</source>
          <target state="translated">Git과 함께 제공 되는 샘플 &lt;code&gt;prepare-commit-msg&lt;/code&gt; 훅은 커밋 템플릿의 주석 처리 된 부분에있는 도움말 메시지를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="0814a224cf6ffffca90b05b46ffd264f8d62f600" translate="yes" xml:space="preserve">
          <source>The sample hooks are all disabled by default. To enable one of the sample hooks rename it by removing its &lt;code&gt;.sample&lt;/code&gt; suffix.</source>
          <target state="translated">샘플 후크는 기본적으로 비활성화되어 있습니다. 샘플 후크 중 하나를 사용하려면 &lt;code&gt;.sample&lt;/code&gt; 접미 부를 제거하여 이름을 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="ee2f5fb52849fdcd69a62a399938c4c71ec4e36c" translate="yes" xml:space="preserve">
          <source>The sane thing. Just admit you screwed up, and use a different name. Others have already seen one tag-name, and if you keep the same name, you may be in the situation that two people both have &quot;version X&quot;, but they actually have &lt;code&gt;different&lt;/code&gt; &quot;X&quot;'s. So just call it &quot;X.1&quot; and be done with it.</source>
          <target state="translated">제정신 망했음을 인정하고 다른 이름을 사용하십시오. 다른 사람들은 이미 하나의 태그 이름을 보았고 같은 이름을 유지하면 두 사람이 모두 &quot;버전 X&quot;를 가지고 있지만 실제로는 &quot;X&quot; 가 &lt;code&gt;different&lt;/code&gt; 상황에있을 수 있습니다 . &quot;X.1&quot;이라고 부르고 완료하십시오.</target>
        </trans-unit>
        <trans-unit id="16a78cd21b6c709f016f4a17d2a1069e970db97c" translate="yes" xml:space="preserve">
          <source>The script expects you to provide the key roots where it can start the import from an &lt;code&gt;initial import&lt;/code&gt; or &lt;code&gt;tag&lt;/code&gt; type of Arch commit. It will follow and import new branches within the provided roots.</source>
          <target state="translated">스크립트는 &lt;code&gt;initial import&lt;/code&gt; 또는 &lt;code&gt;tag&lt;/code&gt; 유형의 Arch commit 에서 가져 오기를 시작할 수있는 핵심 루트를 제공 할 것으로 예상합니다 . 제공된 루트 내에서 새 분기를 따르고 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="793ca81ee99913a2e3edc7ca33209f79549422e8" translate="yes" xml:space="preserve">
          <source>The scriptlet sets &lt;code&gt;GIT_DIR&lt;/code&gt; and &lt;code&gt;GIT_OBJECT_DIRECTORY&lt;/code&gt; shell variables, but does &lt;strong&gt;not&lt;/strong&gt; export them to the environment.</source>
          <target state="translated">스크립틀릿은 설정 &lt;code&gt;GIT_DIR&lt;/code&gt; 및 &lt;code&gt;GIT_OBJECT_DIRECTORY&lt;/code&gt; 쉘 변수를하지만, 않습니다 &lt;strong&gt;없는&lt;/strong&gt; 환경에 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b53f7beee61a37b0174ea389f5f36080ff3c1b7" translate="yes" xml:space="preserve">
          <source>The second .gitignore prevents Git from ignoring &lt;code&gt;arch/foo/kernel/vmlinux.lds.S&lt;/code&gt;.</source>
          <target state="translated">두 번째 .gitignore는 Git이 &lt;code&gt;arch/foo/kernel/vmlinux.lds.S&lt;/code&gt; 를 무시하지 못하게 합니다.</target>
        </trans-unit>
        <trans-unit id="fc737587a80c0c07a4fffd3646c479ff0f86cddd" translate="yes" xml:space="preserve">
          <source>The second example demonstrates that you can abbreviate the object name to only the first several hexadecimal digits in most places.</source>
          <target state="translated">두 번째 예는 대부분의 장소에서 처음 몇 개의 16 진수로만 객체 이름을 약어로 표시 할 수 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2890a9def3fff903603dee47b68cd9b5af108707" translate="yes" xml:space="preserve">
          <source>The second format is what gets used when &lt;code&gt;--stage=all&lt;/code&gt;. The three stage temporary fields (stage1temp, stage2temp, stage3temp) list the name of the temporary file if there is a stage entry in the index or &lt;code&gt;.&lt;/code&gt; if there is no stage entry. Paths which only have a stage 0 entry will always be omitted from the output.</source>
          <target state="translated">두 번째 형식은 &lt;code&gt;--stage=all&lt;/code&gt; 일 때 사용됩니다 . 세 개의 스테이지 임시 필드 (stage1temp, stage2temp, stage3temp)는 색인 또는에 스테이지 항목이있는 경우 임시 파일의 이름을 나열합니다 &lt;code&gt;.&lt;/code&gt; 무대 진입이없는 경우 단계 0 항목 만있는 경로는 항상 출력에서 ​​생략됩니다.</target>
        </trans-unit>
        <trans-unit id="8a6f107e4f2dc8b17455f1349e940becb9fc3a6b" translate="yes" xml:space="preserve">
          <source>The second issue is one of auditing. When many contributors are working on the same repository, it is important which merge commits introduced a change into an important branch. The problematic merge &lt;code&gt;R&lt;/code&gt; above is not likely to be the merge commit that was used to merge into an important branch. Instead, the merge &lt;code&gt;N&lt;/code&gt; was used to merge &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; into the important branch. This commit may have information about why the change &lt;code&gt;X&lt;/code&gt; came to override the changes from &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; in its commit message.</source>
          <target state="translated">The second issue is one of auditing. When many contributors are working on the same repository, it is important which merge commits introduced a change into an important branch. The problematic merge &lt;code&gt;R&lt;/code&gt; above is not likely to be the merge commit that was used to merge into an important branch. Instead, the merge &lt;code&gt;N&lt;/code&gt; was used to merge &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;X&lt;/code&gt; into the important branch. This commit may have information about why the change &lt;code&gt;X&lt;/code&gt; came to override the changes from &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; in its commit message.</target>
        </trans-unit>
        <trans-unit id="86b87f951d8d8be1a02da6e062a3489256945d73" translate="yes" xml:space="preserve">
          <source>The second parameter passed to the hook is the indicator for whether or not the index was updated and the skip-worktree bit could have changed. &quot;1&quot; meaning skip-worktree bits could have been updated and &quot;0&quot; meaning they were not.</source>
          <target state="translated">후크에 전달 된 두 번째 매개 변수는 색인이 업데이트되었고 스킵 작업 트리 비트가 변경 될 수 있는지 여부에 대한 표시기입니다. &quot;1&quot;은 skip-worktree 비트가 업데이트 될 수 있음을 의미하고 &quot;0&quot;은 비트 워크가 업데이트되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b730007914036d9f0fb3ba6052d64853bae216ae" translate="yes" xml:space="preserve">
          <source>The second syntax (&quot;&lt;code&gt;git merge --abort&lt;/code&gt;&quot;) can only be run after the merge has resulted in conflicts. &lt;code&gt;git merge --abort&lt;/code&gt; will abort the merge process and try to reconstruct the pre-merge state. However, if there were uncommitted changes when the merge started (and especially if those changes were further modified after the merge was started), &lt;code&gt;git merge --abort&lt;/code&gt; will in some cases be unable to reconstruct the original (pre-merge) changes. Therefore:</source>
          <target state="translated">두 번째 구문 ( &quot; &lt;code&gt;git merge --abort&lt;/code&gt; &quot;)은 병합이 충돌 한 후에 만 ​​실행할 수 있습니다. &lt;code&gt;git merge --abort&lt;/code&gt; 는 병합 프로세스를 중단하고 병합 전 상태를 재구성하려고 시도합니다. 그러나 병합이 시작될 때 커밋되지 않은 변경 사항이 있었을 때 (특히 병합이 시작된 후 이러한 변경 사항이 추가로 수정 된 경우) &lt;code&gt;git merge --abort&lt;/code&gt; 는 원래 (병합 전) 변경 사항을 재구성 할 수없는 경우가 있습니다. 따라서:</target>
        </trans-unit>
        <trans-unit id="1f7dcee78b5872602756cd0d868ad6253db301fe" translate="yes" xml:space="preserve">
          <source>The second transformation in the chain is diffcore-break, and is controlled by the -B option to the &lt;code&gt;git diff-*&lt;/code&gt; commands. This is used to detect a filepair that represents &quot;complete rewrite&quot; and break such filepair into two filepairs that represent delete and create. E.g. If the input contained this filepair:</source>
          <target state="translated">체인의 두 번째 변환은 diffcore-break이며, &lt;code&gt;git diff-*&lt;/code&gt; 명령 에 대한 -B 옵션으로 제어됩니다 . &quot;완전한 다시 쓰기&quot;를 나타내는 파일 쌍을 감지하고 해당 파일 쌍을 삭제 및 작성을 나타내는 두 개의 파일 쌍으로 나눕니다. 예를 들어, 입력에이 파일 쌍이 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="5aa738048a0181b9705365955bd04c18156f9d33" translate="yes" xml:space="preserve">
          <source>The section &lt;code&gt;submodule.foo.*&lt;/code&gt; in the &lt;code&gt;.gitmodules&lt;/code&gt; file gives additional hints to Git&amp;rsquo;s porcelain layer. For example, the &lt;code&gt;submodule.foo.url&lt;/code&gt; setting specifies where to obtain the submodule.</source>
          <target state="translated">&lt;code&gt;.gitmodules&lt;/code&gt; 파일 의 &lt;code&gt;submodule.foo.*&lt;/code&gt; 섹션 은 Git의 도자기 레이어에 대한 추가 힌트를 제공합니다. 예를 들어, &lt;code&gt;submodule.foo.url&lt;/code&gt; 설정 은 서브 모듈 을 얻을 위치를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="addff8a92e5ddb901ae8a38330bc2dcce4be9fbb" translate="yes" xml:space="preserve">
          <source>The section or key is invalid (ret=1),</source>
          <target state="translated">섹션 또는 키가 유효하지 않습니다 (ret = 1).</target>
        </trans-unit>
        <trans-unit id="463ba2454fad2719570e32271a038c3acce699a7" translate="yes" xml:space="preserve">
          <source>The server MUST NOT send any &quot;unshallow&quot; lines for anything which the client has not indicated was shallow as a part of its request.</source>
          <target state="translated">서버는 클라이언트가 요청의 일부로 얕은 것으로 표시하지 않은 항목에 대해 &quot;얕지 않은&quot;행을 보내서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d868af4cbdec034778f61defdf53e9a4307fd341" translate="yes" xml:space="preserve">
          <source>The server MUST NOT send any refs which were not requested using &lt;code&gt;want-ref&lt;/code&gt; lines.</source>
          <target state="translated">서버는 &lt;code&gt;want-ref&lt;/code&gt; 라인을 사용하여 요청되지 않은 심판을 보내서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="446930d87bed0e82e29e329dd081708ba37057c2" translate="yes" xml:space="preserve">
          <source>The server can advertise the &lt;code&gt;agent&lt;/code&gt; capability with a value &lt;code&gt;X&lt;/code&gt; (in the form &lt;code&gt;agent=X&lt;/code&gt;) to notify the client that the server is running version &lt;code&gt;X&lt;/code&gt;. The client may optionally send its own agent string by including the &lt;code&gt;agent&lt;/code&gt; capability with a value &lt;code&gt;Y&lt;/code&gt; (in the form &lt;code&gt;agent=Y&lt;/code&gt;) in its request to the server (but it MUST NOT do so if the server did not advertise the agent capability). The &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; strings may contain any printable ASCII characters except space (i.e., the byte range 32 &amp;lt; x &amp;lt; 127), and are typically of the form &quot;package/version&quot; (e.g., &quot;git/1.8.3.1&quot;). The agent strings are purely informative for statistics and debugging purposes, and MUST NOT be used to programmatically assume the presence or absence of particular features.</source>
          <target state="translated">서버는 &lt;code&gt;agent&lt;/code&gt; 기능을 값 &lt;code&gt;X&lt;/code&gt; ( &lt;code&gt;agent=X&lt;/code&gt; 형식 )로 알리고 서버가 버전 &lt;code&gt;X&lt;/code&gt; 를 실행 중임을 클라이언트에 알릴 수 있습니다. 클라이언트는 요청 에 값 &lt;code&gt;Y&lt;/code&gt; ( &lt;code&gt;agent=Y&lt;/code&gt; 형식) 의 &lt;code&gt;agent&lt;/code&gt; 기능을 서버 에 포함 시켜서 자체 에이전트 문자열을 선택적으로 전송할 수 있습니다 (하지만 서버가 에이전트 기능을 알리지 않은 경우에는 안됩니다). &lt;code&gt;X&lt;/code&gt; 및 &lt;code&gt;Y&lt;/code&gt; 문자열은 공백 (예 : 바이트 범위 32 &amp;lt;x &amp;lt;127)을 제외한 인쇄 가능한 ASCII 문자를 포함 할 수 있으며 일반적으로 &quot;package / version&quot;형식 (예 : &quot;git / 1.8.3.1&quot;)입니다. 에이전트 문자열은 통계 및 디버깅 목적으로 만 정보를 제공하며 특정 기능의 존재 유무를 프로그래밍 방식으로 가정하는 데 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5d8f08f3df19bb2371d7bbd09e4f22512a514d87" translate="yes" xml:space="preserve">
          <source>The server can advertise the &lt;code&gt;object-format&lt;/code&gt; capability with a value &lt;code&gt;X&lt;/code&gt; (in the form &lt;code&gt;object-format=X&lt;/code&gt;) to notify the client that the server is able to deal with objects using hash algorithm X. If not specified, the server is assumed to only handle SHA-1. If the client would like to use a hash algorithm other than SHA-1, it should specify its object-format string.</source>
          <target state="translated">The server can advertise the &lt;code&gt;object-format&lt;/code&gt; capability with a value &lt;code&gt;X&lt;/code&gt; (in the form &lt;code&gt;object-format=X&lt;/code&gt; ) to notify the client that the server is able to deal with objects using hash algorithm X. If not specified, the server is assumed to only handle SHA-1. If the client would like to use a hash algorithm other than SHA-1, it should specify its object-format string.</target>
        </trans-unit>
        <trans-unit id="89c71d3c4f66b93dbf4d80cac3ad0ba90c74cbf8" translate="yes" xml:space="preserve">
          <source>The server may advertise a session ID that can be used to identify this process across multiple requests. The client may advertise its own session ID back to the server as well.</source>
          <target state="translated">서버는 여러 요청에서이 프로세스를 식별하는 데 사용할 수있는 세션 ID를 광고 할 수 있습니다. 클라이언트는 자신의 세션 ID를 서버에 다시 알릴 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dbb8fc2dd2ef1317864e26b0a2f75da26a1d7f0" translate="yes" xml:space="preserve">
          <source>The server sends a &quot;shallow obj-id&quot; line for each commit whose parents will not be sent in the following packfile.</source>
          <target state="translated">서버는 부모가 다음 팩 파일로 전송되지 않을 각 커밋에 대해 &quot;shallow obj-id&quot;행을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="15cbc52acb55c8a437e7a9fc2cb2ebb8c994afc3" translate="yes" xml:space="preserve">
          <source>The server sends an &quot;unshallow obj-id&quot; line for each commit which the client has indicated is shallow, but is no longer shallow as a result of the fetch (due to its parents being sent in the following packfile).</source>
          <target state="translated">서버는 클라이언트가 표시 한 각 커밋에 대해 &quot;unshallow obj-id&quot;행을 전송하지만, 페치 결과로 더 이상 얕은 것은 아닙니다 (부모가 다음 팩 파일로 전송 됨).</target>
        </trans-unit>
        <trans-unit id="3f482eecb5e3fca563243c0419eece540e0582ac" translate="yes" xml:space="preserve">
          <source>The server will respond with &quot;ACK obj-id&quot; for all of the object ids sent as have lines which are common.</source>
          <target state="translated">서버는 공통의 행이있는 것으로 전송 된 모든 객체 ID에 대해 &quot;ACK obj-id&quot;로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="543a974b0aa8c62d541ca2830198235b945cc003" translate="yes" xml:space="preserve">
          <source>The server will respond with &quot;NAK&quot; if none of the object ids sent as have lines were common.</source>
          <target state="translated">라인이있는 것으로 전송 된 오브젝트 ID가 공통되지 않은 경우 서버는 &quot;NAK&quot;로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="568256da628f1737b5310a22de9a07629ce73e0d" translate="yes" xml:space="preserve">
          <source>The server will respond with a &quot;ready&quot; line indicating that the server has found an acceptable common base and is ready to make and send a packfile (which will be found in the packfile section of the same response)</source>
          <target state="translated">서버는 &quot;준비된&quot;라인으로 응답하여 서버가 허용 가능한 공통 기반을 찾았고 팩 파일 (동일한 응답의 packfile 섹션에 있음)을 작성할 준비가되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="69ff3eec8c55e5a8095ea13f51e31e429dc845d6" translate="yes" xml:space="preserve">
          <source>The server will send a ref listing (&quot;&amp;lt;oid&amp;gt; &amp;lt;refname&amp;gt;&quot;) for each reference requested using &lt;code&gt;want-ref&lt;/code&gt; lines.</source>
          <target state="translated">서버는 &lt;code&gt;want-ref&lt;/code&gt; 행을 사용하여 요청 된 각 참조에 대해 참조 목록 ( &quot;&amp;lt;oid&amp;gt; &amp;lt;refname&amp;gt;&quot;)을 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="afb7e2ac1ca268d29d3dabe65a1485bc3c99ebf1" translate="yes" xml:space="preserve">
          <source>The server will then check to ensure that the client&amp;rsquo;s request is comprised of a valid command as well as valid capabilities which were advertised. If the request is valid the server will then execute the command. A server MUST wait till it has received the client&amp;rsquo;s entire request before issuing a response. The format of the response is determined by the command being executed, but in all cases a flush-pkt indicates the end of the response.</source>
          <target state="translated">그런 다음 서버는 클라이언트 요청이 유효한 명령뿐만 아니라 알려진 유효한 기능으로 구성되어 있는지 확인합니다. 요청이 유효하면 서버는 명령을 실행합니다. 서버는 응답을 발행하기 전에 클라이언트의 전체 요청을 수신 할 때까지 기다려야합니다. 응답의 형식은 실행중인 명령에 따라 결정되지만 flush-pkt는 응답의 끝을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="537b1e0777fad4eaaafbf4ccf5940ab37b1e2ed6" translate="yes" xml:space="preserve">
          <source>The shared index part, to be referenced by $GIT_DIR/index and other temporary index files. Only valid in split index mode.</source>
          <target state="translated">$ GIT_DIR / index 및 기타 임시 색인 파일에서 참조 할 공유 색인 부분. 분할 인덱스 모드에서만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="d11a14c0103fd18e1ebb96bcb7251e0f8abbce80" translate="yes" xml:space="preserve">
          <source>The shift magic first throws away the tree id and then the -p parameters. Note that this handles merges properly! In case Darl committed a merge between P1 and P2, it will be propagated properly and all children of the merge will become merge commits with P1,P2 as their parents instead of the merge commit.</source>
          <target state="translated">시프트 매직은 먼저 트리 ID와 -p 매개 변수를 모두 버립니다. 이 처리는 병합을 올바르게 처리합니다. Darl이 P1과 P2간에 병합을 커밋 한 경우 제대로 전파되고 병합의 모든 자식은 병합 커밋 대신 P1, P2를 부모로 병합 커밋이됩니다.</target>
        </trans-unit>
        <trans-unit id="e33b2d8b27401f604cb70ad4d214df90a2abf20c" translate="yes" xml:space="preserve">
          <source>The similarity index is the percentage of unchanged lines, and the dissimilarity index is the percentage of changed lines. It is a rounded down integer, followed by a percent sign. The similarity index value of 100% is thus reserved for two equal files, while 100% dissimilarity means that no line from the old file made it into the new one.</source>
          <target state="translated">유사성 지수는 변경되지 않은 라인의 백분율이며, 비 유사성 지수는 변경된 라인의 백분율입니다. 반올림 된 정수 다음에 백분율 기호가옵니다. 100 %의 유사성 색인 값은 두 개의 동일한 파일에 대해 예약되어 있으며 100 %의 유사하지 않음은 이전 파일의 행이 새 파일로 작성되지 않았 음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="09f0c715250f8ac9e78727d6768d66502facff83" translate="yes" xml:space="preserve">
          <source>The simplest commit to find is the HEAD commit, which we can find from .git/HEAD:</source>
          <target state="translated">가장 간단한 커밋은 HEAD 커밋이며, .git / HEAD에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="938f800e1b465bd0f07eb377492ba2456bfbed2c" translate="yes" xml:space="preserve">
          <source>The simplest way to do this is using &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and ssh; to update the remote branch named &lt;code&gt;master&lt;/code&gt; with the latest state of your branch named &lt;code&gt;master&lt;/code&gt;, run</source>
          <target state="translated">가장 간단한 방법은 &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 및 ssh; 라는 이름의 원격 지사 업데이트 &lt;code&gt;master&lt;/code&gt; 지사라는 이름의 최신 상태 &lt;code&gt;master&lt;/code&gt; , 실행</target>
        </trans-unit>
        <trans-unit id="a5eba655ac4b55a1106bdc6c6dbf2b0d1ad04c8a" translate="yes" xml:space="preserve">
          <source>The simplest way to mark a file as binary is to unset the diff attribute in the &lt;code&gt;.gitattributes&lt;/code&gt; file:</source>
          <target state="translated">파일을 바이너리로 표시하는 가장 간단한 방법은 &lt;code&gt;.gitattributes&lt;/code&gt; 파일 에서 diff 속성을 설정 해제하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="0f95b7ebe5f42d4f0766af1eda2b35efa6854fa9" translate="yes" xml:space="preserve">
          <source>The size in bytes of the commit or tag message.</source>
          <target state="translated">The size in bytes of the commit or tag message.</target>
        </trans-unit>
        <trans-unit id="99bb329f9f9a76ae9c81982693e8d5911709e87c" translate="yes" xml:space="preserve">
          <source>The size of the object (the same as &lt;code&gt;git cat-file -s&lt;/code&gt; reports). Append &lt;code&gt;:disk&lt;/code&gt; to get the size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the &lt;code&gt;CAVEATS&lt;/code&gt; section below.</source>
          <target state="translated">객체의 크기 ( &lt;code&gt;git cat-file -s&lt;/code&gt; reports 와 동일 ) &lt;code&gt;:disk&lt;/code&gt; 를 추가 하여 개체가 디스크에서 차지하는 크기 (바이트)를 가져옵니다. 아래 의 &lt;code&gt;CAVEATS&lt;/code&gt; 섹션 에서 온 디스크 크기에 대한 참고 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3527fa64b6fd749102c379b2fd96b0df5cd454cb" translate="yes" xml:space="preserve">
          <source>The size of the window used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; when no window size is given on the command line. Defaults to 10.</source>
          <target state="translated">창 크기가 사용 &lt;a href=&quot;git-pack-objects&quot;&gt;자식 팩 - 오브젝트 [1]&lt;/a&gt; 어떤 윈도우 사이즈는 명령 라인에 제공되지 않는 경우. 기본값은 10입니다.</target>
        </trans-unit>
        <trans-unit id="2372575566ae8c805d7580bdcbad6da1c4463611" translate="yes" xml:space="preserve">
          <source>The size, in bytes, of the object (the same as &lt;code&gt;cat-file -s&lt;/code&gt; reports).</source>
          <target state="translated">개체의 크기 (바이트) ( &lt;code&gt;cat-file -s&lt;/code&gt; 보고서 와 동일 )</target>
        </trans-unit>
        <trans-unit id="43c333a5a6bd3bca8b34d5163a7aa7b6d79d2d40" translate="yes" xml:space="preserve">
          <source>The size, in bytes, that the object takes up on disk. See the note about on-disk sizes in the &lt;code&gt;CAVEATS&lt;/code&gt; section below.</source>
          <target state="translated">객체가 디스크에서 차지하는 크기 (바이트)입니다. 아래 의 &lt;code&gt;CAVEATS&lt;/code&gt; 섹션 에서 온 디스크 크기에 대한 참고 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d544171c06a9cb39c4059f830c0a8558d3922c9" translate="yes" xml:space="preserve">
          <source>The slash &lt;code&gt;/&lt;/code&gt; is used as the directory separator. Separators may occur at the beginning, middle or end of the &lt;code&gt;.gitignore&lt;/code&gt; search pattern.</source>
          <target state="translated">슬래시 ( &lt;code&gt;/&lt;/code&gt; ) 는 디렉토리 구분 기호로 사용됩니다. 구분 기호는 &lt;code&gt;.gitignore&lt;/code&gt; 검색 패턴 의 시작, 중간 또는 끝에서 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e18b2266f1b1b9062e466bd05dd697dc8d44c68f" translate="yes" xml:space="preserve">
          <source>The smaller the changes in your commit, the most effective &quot;git bisect&quot; will be. And you will probably need &quot;git bisect&quot; less in the first place, as small changes are easier to review even if they are only reviewed by the committer.</source>
          <target state="translated">커밋의 변경 사항이 작을수록 가장 효과적인 &quot;git bisect&quot;가됩니다. 그리고 커미터에 의해서만 검토 되더라도 작은 변경 사항을 검토하기가 더 쉬우므로 처음에는 &quot;git bisect&quot;가 덜 필요할 것입니다.</target>
        </trans-unit>
        <trans-unit id="0dab2fe7462a5d0c0b797d08e789dbaaf7bfa1df" translate="yes" xml:space="preserve">
          <source>The smart HTTP server, &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend[1]&lt;/a&gt;, will pass GIT_NAMESPACE through to the backend programs; see &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend[1]&lt;/a&gt; for sample configuration to expose repository namespaces as repositories.</source>
          <target state="translated">스마트 HTTP 서버 인 &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend [1]&lt;/a&gt; 은 GIT_NAMESPACE를 백엔드 프로그램으로 전달합니다. 리포지토리 네임 스페이스를 리포지토리로 노출하는 샘플 구성 은 &lt;a href=&quot;git-http-backend&quot;&gt;git-http-backend [1]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ee3be6f644f850e9ae409b580b74ced862493f8" translate="yes" xml:space="preserve">
          <source>The solution, of course, is to make a merge that we can undo: merge into a throw-away branch.</source>
          <target state="translated">물론 해결책은 취소 할 수있는 병합을 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a1117f540255f9a5dcffa1baa25558f77657b0e" translate="yes" xml:space="preserve">
          <source>The special case of restarting an incremental import from the current branch value should be written as:</source>
          <target state="translated">현재 분기 값에서 증분 가져 오기를 다시 시작하는 특별한 경우는 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="3599d1b8b89ee48d0b633dcff9041c57284c3251" translate="yes" xml:space="preserve">
          <source>The special exit code 125 should be used when the current source code cannot be tested. If the script exits with this code, the current revision will be skipped (see &lt;code&gt;git bisect skip&lt;/code&gt; above). 125 was chosen as the highest sensible value to use for this purpose, because 126 and 127 are used by POSIX shells to signal specific error status (127 is for command not found, 126 is for command found but not executable&amp;mdash;​these details do not matter, as they are normal errors in the script, as far as &lt;code&gt;bisect run&lt;/code&gt; is concerned).</source>
          <target state="translated">현재 소스 코드를 테스트 할 수없는 경우 특수 종료 코드 125를 사용해야합니다. 스크립트가이 코드와 함께 종료되면 현재 개정판을 건너 뜁니다 ( 위의 &lt;code&gt;git bisect skip&lt;/code&gt; 참조). 126과 127은 POSIX 셸에서 특정 오류 상태를 알리기 위해 사용하기 때문에 125가이 목적에 사용할 수있는 가장 합리적인 값으로 선택되었습니다 (127은 명령을 찾을 수없고 126은 명령을 찾았지만 실행할 수 없음). &lt;code&gt;bisect run&lt;/code&gt; 과 관련 하여 스크립트에서 정상적인 오류 이므로 문제가 발생합니다).</target>
        </trans-unit>
        <trans-unit id="60ac8fe2a99f998c150bb7d9adc8dfbeed95a10d" translate="yes" xml:space="preserve">
          <source>The special null SHA-1 (40 zeros) specifies that the branch is to be removed.</source>
          <target state="translated">특수 null SHA-1 (40 개의 0)은 분기가 제거되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="a4c2fa6682338e4d7c45557107add1984be0213c" translate="yes" xml:space="preserve">
          <source>The special refspec &lt;code&gt;:&lt;/code&gt; (or &lt;code&gt;+:&lt;/code&gt; to allow non-fast-forward updates) directs Git to push &quot;matching&quot; branches: for every branch that exists on the local side, the remote side is updated if a branch of the same name already exists on the remote side.</source>
          <target state="translated">특별한 refspec &lt;code&gt;:&lt;/code&gt; (또는 &lt;code&gt;+:&lt;/code&gt; 빨리 감기가 아닌 업데이트를 허용하기 위해) Git은 &quot;일치하는&quot;분기를 푸시하도록 지시합니다. 로컬 측에 존재하는 모든 분기에 대해 동일한 이름의 분기가 이미 존재하면 원격 측이 업데이트됩니다 원격에서.</target>
        </trans-unit>
        <trans-unit id="f2f702d2704e1b64279419d712ca4460c3b7f78e" translate="yes" xml:space="preserve">
          <source>The special string &lt;code&gt;none&lt;/code&gt; can be used as the proxy command to specify that no proxy be used for a given domain pattern. This is useful for excluding servers inside a firewall from proxy use, while defaulting to a common proxy for external domains.</source>
          <target state="translated">지정된 문자열 패턴에 프록시를 사용하지 않도록 지정하기 위해 특수 문자열 &lt;code&gt;none&lt;/code&gt; 을 proxy 명령으로 사용할 수 없습니다. 이는 방화벽 내부의 서버를 프록시 사용에서 제외하고 외부 도메인의 공통 프록시로 기본 설정하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="65b859a3a4528b4a1eebafeebe9d2d28ac0eb085" translate="yes" xml:space="preserve">
          <source>The special symbol &quot;HEAD&quot; can always be used to refer to the current branch. In fact, Git uses a file named &lt;code&gt;HEAD&lt;/code&gt; in the &lt;code&gt;.git&lt;/code&gt; directory to remember which branch is current:</source>
          <target state="translated">특수 기호 &quot;HEAD&quot;는 항상 현재 분기를 나타내는 데 사용할 수 있습니다. 사실, 힘내라는 이름의 파일 사용 &lt;code&gt;HEAD&lt;/code&gt; 에 &lt;code&gt;.git&lt;/code&gt; 현재 어느 지점 기억해야 할 디렉토리를 :</target>
        </trans-unit>
        <trans-unit id="54b91d851f1b23aa70b29c0e74d2c28879b6de30" translate="yes" xml:space="preserve">
          <source>The ssh and git protocols additionally support ~username expansion:</source>
          <target state="translated">ssh 및 git 프로토콜은 ~ username 확장을 추가로 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ac6c6d73b5f6b7c3cef28dfe32da61495601bd7c" translate="yes" xml:space="preserve">
          <source>The standard actions are:</source>
          <target state="translated">표준 조치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a72f515f06e2719cd062e161d9ed80a61b68c92f" translate="yes" xml:space="preserve">
          <source>The standard email format as described by RFC 2822, for example &lt;code&gt;Thu, 07 Apr 2005 22:13:13 +0200&lt;/code&gt;.</source>
          <target state="translated">RFC 2822에 설명 된 표준 이메일 형식 (예 : &lt;code&gt;Thu, 07 Apr 2005 22:13:13 +0200&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8128f4cfe82d86e129a0094608260664c3bb1ba3" translate="yes" xml:space="preserve">
          <source>The standard helper program to use with git-merge-index</source>
          <target state="translated">git-merge-index와 함께 사용할 표준 도우미 프로그램</target>
        </trans-unit>
        <trans-unit id="4d34b021b617aa2bf3f93982ac428b041f085fbe" translate="yes" xml:space="preserve">
          <source>The starting point for the new branch. Specifying a &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; allows you to create a branch based on some other point in history than where HEAD currently points. (Or, in the case of &lt;code&gt;--detach&lt;/code&gt;, allows you to inspect and detach from some other point.)</source>
          <target state="translated">새로운 지점의 출발점. &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; 를 지정하면 HEAD가 현재 가리키는 위치 이외의 다른 기록 포인트를 기반으로 분기를 만들 수 있습니다. 또는 &lt;code&gt;--detach&lt;/code&gt; 의 경우 다른 지점을 검사하고 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="ca9ba47b83a1def4d8a6c769f2e642f061d5236a" translate="yes" xml:space="preserve">
          <source>The status of GPG verification of the push certificate, using the same mnemonic as used in &lt;code&gt;%G?&lt;/code&gt; format of &lt;code&gt;git log&lt;/code&gt; family of commands (see &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;%G?&lt;/code&gt; 사용 된 것과 동일한 니모닉을 사용하여 푸시 인증서의 GPG 확인 상태 ? &lt;code&gt;git log&lt;/code&gt; 명령 계열 형식 ( &lt;a href=&quot;git-log&quot;&gt;git-log [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c902748a09ab505851b0b39809c60f3db2027be9" translate="yes" xml:space="preserve">
          <source>The status of the fetch is output in tabular form, with each line representing the status of a single ref. Each line is of the form:</source>
          <target state="translated">페치 상태는 표 형식으로 출력되며 각 라인은 단일 심판의 상태를 나타냅니다. 각 줄의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7729563c964ef73ba71f39abfa320766ac0cea33" translate="yes" xml:space="preserve">
          <source>The status of the push is output in tabular form, with each line representing the status of a single ref. Each line is of the form:</source>
          <target state="translated">푸시 상태는 표 형식으로 출력되며 각 라인은 단일 심판의 상태를 나타냅니다. 각 줄의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e939f21e3282d453b1398071feb25115360b90b4" translate="yes" xml:space="preserve">
          <source>The status of up-to-date refs is shown only if --porcelain or --verbose option is used.</source>
          <target state="translated">최신 참조 상태는 --porcelain 또는 --verbose 옵션을 사용하는 경우에만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0ebfa7ce02ec5605e425e0cd98062f5bbd8f2510" translate="yes" xml:space="preserve">
          <source>The status of up-to-date refs is shown only if the --verbose option is used.</source>
          <target state="translated">최신 참조 상태는 --verbose 옵션이 사용 된 경우에만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a97643bd561fabe3d136679e4752cb73667ec062" translate="yes" xml:space="preserve">
          <source>The structured objects can further have their structure and connectivity to other objects verified. This is generally done with the &lt;code&gt;git fsck&lt;/code&gt; program, which generates a full dependency graph of all objects, and verifies their internal consistency (in addition to just verifying their superficial consistency through the hash).</source>
          <target state="translated">구조화 된 객체는 구조 및 다른 객체와의 연결성을 확인할 수 있습니다. 이것은 일반적으로 &lt;code&gt;git fsck&lt;/code&gt; 프로그램을 사용하여 수행됩니다.이 프로그램은 모든 객체의 전체 의존성 그래프를 생성하고 해시를 통해 표면 일관성을 확인하는 것 외에도 내부 일관성을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="af4ab93b8907c3bc82033e90c4bc6eedaac09e1c" translate="yes" xml:space="preserve">
          <source>The submit process invokes the editor before each p4 change is submitted. If this setting is true, though, the editing step is skipped.</source>
          <target state="translated">제출 프로세스는 각 p4 변경 사항이 제출되기 전에 편집기를 호출합니다. 그러나이 설정이 참이면 편집 단계를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="72386229ffdfc0f6ba847ccdd7620fcafabeae30" translate="yes" xml:space="preserve">
          <source>The submodule directories are there, but they&amp;rsquo;re empty:</source>
          <target state="translated">하위 모듈 디렉토리가 있지만 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="802b1c9a36cac97c548242e11fe5baa3275576f0" translate="yes" xml:space="preserve">
          <source>The submodule will never be considered modified (but will nonetheless show up in the output of status and commit when it has been staged).</source>
          <target state="translated">서브 모듈은 수정 된 것으로 간주되지 않습니다 (그러나 그럼에도 불구하고 스테이트 출력시 상태 출력 및 커밋에 표시됨).</target>
        </trans-unit>
        <trans-unit id="7180d60887d97b6ca57dd91c2b86681f019ca631" translate="yes" xml:space="preserve">
          <source>The submodule&amp;rsquo;s &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file would come into play when running &lt;code&gt;git push --recurse-submodules=check&lt;/code&gt; in the superproject, as this would check if the submodule has any changes not published to any remote. The remotes are configured in the submodule as usual in the &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file.</source>
          <target state="translated">서브 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 의 $ GIT_DIR / config 파일은 수퍼 &lt;code&gt;git push --recurse-submodules=check&lt;/code&gt; 에서 git push --recurse-submodules = check 를 실행할 때 서브 모듈이 원격에 게시되지 않은 변경 사항이 있는지 확인하므로 실행 됩니다. 리모트는 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 에서 평소와 같이 서브 모듈에서 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="2a87578b15befa74b2d27eca3216884ceb35493c" translate="yes" xml:space="preserve">
          <source>The suffix &lt;code&gt;@{push}&lt;/code&gt; reports the branch &quot;where we would push to&quot; if &lt;code&gt;git push&lt;/code&gt; were run while &lt;code&gt;branchname&lt;/code&gt; was checked out (or the current &lt;code&gt;HEAD&lt;/code&gt; if no branchname is specified). Since our push destination is in a remote repository, of course, we report the local tracking branch that corresponds to that branch (i.e., something in &lt;code&gt;refs/remotes/&lt;/code&gt;).</source>
          <target state="translated">접미사 &lt;code&gt;@{push}&lt;/code&gt; 는 &lt;code&gt;branchname&lt;/code&gt; 이 체크 아웃 된 상태에서 &lt;code&gt;git push&lt;/code&gt; 가 실행 된 경우 (또는 branchname이 지정되지 않은 경우 현재 &lt;code&gt;HEAD&lt;/code&gt; ) &quot;분기 할 위치&quot;분기를보고합니다 . 푸시 대상은 원격 저장소에 있기 때문에 해당 분기에 해당하는 로컬 추적 분기 (예 : &lt;code&gt;refs/remotes/&lt;/code&gt; )를보고합니다.</target>
        </trans-unit>
        <trans-unit id="c10fd9c6c93e1de11dbe32978aa15d853b4103fb" translate="yes" xml:space="preserve">
          <source>The suffix &lt;code&gt;@{upstream}&lt;/code&gt; to a branchname (short form &lt;code&gt;&amp;lt;branchname&amp;gt;@{u}&lt;/code&gt;) refers to the branch that the branch specified by branchname is set to build on top of (configured with &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt;). A missing branchname defaults to the current one. These suffixes are also accepted when spelled in uppercase, and they mean the same thing no matter the case.</source>
          <target state="translated">분기 이름 의 접미사 &lt;code&gt;@{upstream}&lt;/code&gt; (약식 &lt;code&gt;&amp;lt;branchname&amp;gt;@{u}&lt;/code&gt; )은 branchname으로 지정된 분기가 ( &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 및 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 구성된) 위에 빌드되도록 설정된 분기를 나타냅니다. &amp;lt;이름&amp;gt; .merge ). 누락 된 분기 이름은 기본적으로 현재 이름입니다. 이 접미어는 대문자로 표기 할 때도 허용되며 경우에 상관없이 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="35fca7d90e0c51050df5863335fd96cb674d847a" translate="yes" xml:space="preserve">
          <source>The symlink will either be absolute (beginning with a /), or relative to the tree root. For instance, if dir/link points to ../../foo, then &amp;lt;symlink&amp;gt; will be ../foo. &amp;lt;size&amp;gt; is the size of the symlink in bytes.</source>
          <target state="translated">심볼릭 링크는 절대적이거나 (/로 시작) 나무 루트에 상대적입니다. 예를 들어 dir / link가 ../../foo를 가리키는 경우 &amp;lt;symlink&amp;gt;는 ../foo가됩니다. &amp;lt;size&amp;gt;는 바이트 단위의 심볼릭 링크 크기입니다.</target>
        </trans-unit>
        <trans-unit id="1e32c77f2578ce3c979cd217827d9aa3c6897be9" translate="yes" xml:space="preserve">
          <source>The syntax is fairly flexible and permissive; whitespaces are mostly ignored. The &lt;code&gt;#&lt;/code&gt; and &lt;code&gt;;&lt;/code&gt; characters begin comments to the end of line, blank lines are ignored.</source>
          <target state="translated">구문은 상당히 유연하고 허용 적입니다. 공백은 대부분 무시됩니다. &lt;code&gt;#&lt;/code&gt; 와 &lt;code&gt;;&lt;/code&gt; 문자는 줄 끝에 주석을 시작하고 빈 줄은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e9a240786337cb206c43c416821000b9a6721022" translate="yes" xml:space="preserve">
          <source>The syntax of the configuration files is that of Perl, since these files are handled by sourcing them as fragments of Perl code (the language that gitweb itself is written in). Variables are typically set using the &lt;code&gt;our&lt;/code&gt; qualifier (as in &quot;&lt;code&gt;our $variable = &amp;lt;value&amp;gt;;&lt;/code&gt;&quot;) to avoid syntax errors if a new version of gitweb no longer uses a variable and therefore stops declaring it.</source>
          <target state="translated">구성 파일의 구문은 Perl의 구문입니다. 이러한 파일은 파일을 Perl 코드 (gitweb 자체가 작성하는 언어)의 조각으로 소싱하여 처리되기 때문입니다. 변수는 일반적으로 사용되지 설정된 &lt;code&gt;our&lt;/code&gt; ( &quot;과 규정을 &lt;code&gt;our $variable = &amp;lt;value&amp;gt;;&lt;/code&gt; gitweb의 새 버전이 더 이상 변수를 사용하며, 따라서 선언 멈 추면 않도록 문법 에러&quot;).</target>
        </trans-unit>
        <trans-unit id="85d5722bf15562fb833fe3c8f580a92fe2e2d3db" translate="yes" xml:space="preserve">
          <source>The tables below show what happens when running:</source>
          <target state="translated">아래 표는 실행시 발생하는 상황을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0ab961c529e0da6916842ede03d74fc7b0e0f90e" translate="yes" xml:space="preserve">
          <source>The tag &lt;code&gt;v2.6.18&lt;/code&gt; is short for &lt;code&gt;refs/tags/v2.6.18&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v2.6.18&lt;/code&gt; 태그 는 &lt;code&gt;refs/tags/v2.6.18&lt;/code&gt; 의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="e5173af0305c1d6df2de24b7ea317c256f65109e" translate="yes" xml:space="preserve">
          <source>The template directory will be one of the following (in order):</source>
          <target state="translated">템플릿 디렉토리는 다음 중 하나입니다 (순서대로).</target>
        </trans-unit>
        <trans-unit id="45d4fdaf8fe9ac583ec50051c8f5eb8c944a1ec1" translate="yes" xml:space="preserve">
          <source>The term &lt;a href=&quot;#def_pickaxe&quot;&gt;pickaxe&lt;/a&gt; refers to an option to the diffcore routines that help select changes that add or delete a given text string. With the &lt;code&gt;--pickaxe-all&lt;/code&gt; option, it can be used to view the full &lt;a href=&quot;#def_changeset&quot;&gt;changeset&lt;/a&gt; that introduced or removed, say, a particular line of text. See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_pickaxe&quot;&gt;pickaxe&lt;/a&gt; 라는 용어 는 주어진 텍스트 문자열을 추가하거나 삭제하는 변경 사항을 선택하는 데 도움이되는 diffcore 루틴에 대한 옵션을 나타냅니다. 으로 &lt;code&gt;--pickaxe-all&lt;/code&gt; 옵션, 전체 볼 수 있습니다 &lt;a href=&quot;#def_changeset&quot;&gt;변경 집합을&lt;/a&gt; 말한다, 텍스트의 특정 라인을 도입하거나 제거 할 것이다. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2ba0595fa8d197d8c3640c03007e070ceba5b47" translate="yes" xml:space="preserve">
          <source>The text conversion is generally a one-way conversion; in this example, we lose the actual image contents and focus just on the text data. This means that diffs generated by textconv are &lt;em&gt;not&lt;/em&gt; suitable for applying. For this reason, only &lt;code&gt;git diff&lt;/code&gt; and the &lt;code&gt;git log&lt;/code&gt; family of commands (i.e., log, whatchanged, show) will perform text conversion. &lt;code&gt;git
format-patch&lt;/code&gt; will never generate this output. If you want to send somebody a text-converted diff of a binary file (e.g., because it quickly conveys the changes you have made), you should generate it separately and send it as a comment &lt;em&gt;in addition to&lt;/em&gt; the usual binary diff that you might send.</source>
          <target state="translated">텍스트 변환은 일반적으로 단방향 변환입니다. 이 예에서는 실제 이미지 내용을 잃고 텍스트 데이터에만 집중합니다. 이것은 textconv에 의해 생성 된 diff가 적용하기에 적합 &lt;em&gt;하지 않음을&lt;/em&gt; 의미합니다 . 따라서 &lt;code&gt;git diff&lt;/code&gt; 및 &lt;code&gt;git log&lt;/code&gt; 명령 계열 (즉, log, whatchanged, show) 만 텍스트 변환을 수행합니다. &lt;code&gt;git format-patch&lt;/code&gt; 는이 출력을 생성하지 않습니다. 누군가에게 이진 파일의 텍스트로 변환 된 diff를 보내려면 (예를 들어, 변경 한 내용을 빠르게 전달하기 때문에),이 파일을 별도로 생성 하여 일반적인 바이너리 diff &lt;em&gt;외에&lt;/em&gt; 주석으로 보내야합니다. 보내다.</target>
        </trans-unit>
        <trans-unit id="eb234a21c48fd769b7576108683d04bf29f253cb" translate="yes" xml:space="preserve">
          <source>The third syntax (&quot;&lt;code&gt;git merge --continue&lt;/code&gt;&quot;) can only be run after the merge has resulted in conflicts.</source>
          <target state="translated">세 번째 구문 ( &quot; &lt;code&gt;git merge --continue&lt;/code&gt; &quot;)은 병합이 충돌 한 후에 만 ​​실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a25be90a41e318ce76ddb9737f9c1a04e1e950e3" translate="yes" xml:space="preserve">
          <source>The time between the first rc release and the final release is supposed to be used to test rc versions and fight bugs and especially regressions. And this time is more than 80% of the release cycle time. But this is not the end of the fight yet, as of course it continues after the release.</source>
          <target state="translated">첫 번째 rc 릴리스와 마지막 릴리스 사이의 시간은 rc 버전을 테스트하고 버그 및 특히 회귀와 싸우는 데 사용됩니다. 그리고이 시간은 릴리스주기 시간의 80 % 이상입니다. 그러나 이것은 아직 싸움의 끝이 아니며, 물론 석방 후에도 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="75271c1b7d85cdfdc3bad04249d4464b9c292a44" translate="yes" xml:space="preserve">
          <source>The time of the change is specified by &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; using the date format that was selected by the --date-format=&amp;lt;fmt&amp;gt; command-line option. See &amp;ldquo;Date Formats&amp;rdquo; above for the set of supported formats, and their syntax.</source>
          <target state="translated">변경 시간은 --date-format = &amp;lt;fmt&amp;gt; 명령 줄 옵션에서 선택한 날짜 형식을 사용하여 &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; 에 의해 지정됩니다 . 지원되는 형식 세트와 구문은 위의 &quot;날짜 형식&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="05b9a4ac37ff05623171d65150ac27013efa2fa0" translate="yes" xml:space="preserve">
          <source>The time of the event is specified by &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; as the number of seconds since the UNIX epoch (midnight, Jan 1, 1970, UTC) and is written as an ASCII decimal integer.</source>
          <target state="translated">이벤트 &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; 은 UNIX 시간 (1970 년 1 월 1 일 자정, UTC) 이후의 초 수로 &amp;lt;time&amp;gt; 으로 지정되며 ASCII 10 진수 정수로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="e85bdfa8e02113c7aa36696add629ec632f05440" translate="yes" xml:space="preserve">
          <source>The todo list presented by the deprecated &lt;code&gt;--preserve-merges --interactive&lt;/code&gt; does not represent the topology of the revision graph (use &lt;code&gt;--rebase-merges&lt;/code&gt; instead). Editing commits and rewording their commit messages should work fine, but attempts to reorder commits tend to produce counterintuitive results. Use &lt;code&gt;--rebase-merges&lt;/code&gt; in such scenarios instead.</source>
          <target state="translated">더 이상 사용되지 않는 &lt;code&gt;--preserve-merges --interactive&lt;/code&gt; 로 표시되는 할 일 목록 은 개정 그래프의 토폴로지를 나타내지 않습니다 ( 대신 &lt;code&gt;--rebase-merges&lt;/code&gt; 를 사용하십시오). 커밋을 편집하고 커밋 메시지를 바꾸면 커밋 순서를 바꾸려고 시도하면 반 직관적 인 결과를 얻는 경향이 있습니다. 사용 &lt;code&gt;--rebase-merges&lt;/code&gt; 대신 같은 시나리오를.</target>
        </trans-unit>
        <trans-unit id="0f8166907df228eb9266d7566c3cde991d9d39bd" translate="yes" xml:space="preserve">
          <source>The total number of paths.</source>
          <target state="translated">총 경로 수</target>
        </trans-unit>
        <trans-unit id="46c0269533706ef03961ed4548e480cdcfd7a84a" translate="yes" xml:space="preserve">
          <source>The trailer records 20-byte SHA-1 checksum of all of the above.</source>
          <target state="translated">트레일러는 위의 모든 것의 20 바이트 SHA-1 체크섬을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="b9ae27ef547547fea9cd9f5b91bb86a4c8f93238" translate="yes" xml:space="preserve">
          <source>The trailer records a pack checksum of all of the above.</source>
          <target state="translated">The trailer records a pack checksum of all of the above.</target>
        </trans-unit>
        <trans-unit id="9380254df0eb0e126f55d72177d625190ab23928" translate="yes" xml:space="preserve">
          <source>The transmission of the packfile begins immediately after the section header</source>
          <target state="translated">팩 파일의 전송은 섹션 헤더 바로 다음에 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="de285c430d2e1f897693d7ccc23434e1a3a5c103" translate="yes" xml:space="preserve">
          <source>The tree object is the tree we examined first, and this commit is unusual in that it lacks any parent.</source>
          <target state="translated">트리 객체는 우리가 먼저 검사 한 트리이며,이 커밋은 부모가 없다는 점에서 특이합니다.</target>
        </trans-unit>
        <trans-unit id="9178b43dc9b2907a6afd7a3693f2c6894ec0ecd9" translate="yes" xml:space="preserve">
          <source>The tree of actual checked out files. The working tree normally contains the contents of the &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; commit&amp;rsquo;s tree, plus any local changes that you have made but not yet committed.</source>
          <target state="translated">실제로 체크 아웃 된 파일의 트리입니다. 작업 트리에는 일반적으로 &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; 커밋 트리 의 내용과 함께 아직 커밋하지 않은 로컬 변경 내용이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="26b5c7d70f82997ceabb111adeeb911e4d89a340" translate="yes" xml:space="preserve">
          <source>The tree or commit to produce an archive for.</source>
          <target state="translated">아카이브를 생성하기위한 트리 또는 커밋.</target>
        </trans-unit>
        <trans-unit id="90f78952a054862b4ed6d79982e2eab2fc081a24" translate="yes" xml:space="preserve">
          <source>The twist is that if some file doesn&amp;rsquo;t match the index, we don&amp;rsquo;t have a backing store thing for it, and we use the magic &quot;all-zero&quot; sha1 to show that. So let&amp;rsquo;s say that you have edited &lt;code&gt;kernel/sched.c&lt;/code&gt;, but have not actually done a &lt;code&gt;git update-index&lt;/code&gt; on it yet - there is no &quot;object&quot; associated with the new state, and you get:</source>
          <target state="translated">일부 파일이 색인과 일치하지 않으면 백업 저장소가 없으며 마술 &quot;0&quot;sha1을 사용하여 표시합니다. 따라서 &lt;code&gt;kernel/sched.c&lt;/code&gt; 를 편집 했지만 실제로 &lt;code&gt;git update-index&lt;/code&gt; 를 아직 수행하지 않았다고 가정 해 봅시다 . 새로운 상태와 관련된 &quot;객체&quot;가 없으며 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="43d0ee9ad50c1c3c133c4c2ff3f216463ab119aa" translate="yes" xml:space="preserve">
          <source>The two options can be specified together to ask a command to work on both the index and the working tree.</source>
          <target state="translated">인덱스와 작업 트리 모두에서 작동하도록 명령을 요청하기 위해 두 옵션을 함께 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="293c342524c5d665ec090c34f37c73d153be74d5" translate="yes" xml:space="preserve">
          <source>The type of the object (&lt;code&gt;blob&lt;/code&gt;, &lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;tag&lt;/code&gt;).</source>
          <target state="translated">객체의 유형 ( &lt;code&gt;blob&lt;/code&gt; , &lt;code&gt;tree&lt;/code&gt; , &lt;code&gt;commit&lt;/code&gt; , &lt;code&gt;tag&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="35ca6d49608b210b7cf8be4b86261fa4bd55e249" translate="yes" xml:space="preserve">
          <source>The type of the object (the same as &lt;code&gt;cat-file -t&lt;/code&gt; reports).</source>
          <target state="translated">개체 유형 ( &lt;code&gt;cat-file -t&lt;/code&gt; 보고서 와 동일 )</target>
        </trans-unit>
        <trans-unit id="a4f9324e934e3998d2ea50e9e2c5152c5cb8ca76" translate="yes" xml:space="preserve">
          <source>The typical usage is to set just the &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; variables; the other options are provided for more complex use cases.</source>
          <target state="translated">The typical usage is to set just the &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; variables; the other options are provided for more complex use cases.</target>
        </trans-unit>
        <trans-unit id="4785efb96aaa5561500dccbb8420f79e52290b85" translate="yes" xml:space="preserve">
          <source>The underlying Git plumbing tools, such as &lt;code&gt;git ls-files&lt;/code&gt; and &lt;code&gt;git read-tree&lt;/code&gt;, read &lt;code&gt;gitignore&lt;/code&gt; patterns specified by command-line options, or from files specified by command-line options. Higher-level Git tools, such as &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git add&lt;/code&gt;, use patterns from the sources specified above.</source>
          <target state="translated">&lt;code&gt;git ls-files&lt;/code&gt; 및 &lt;code&gt;git read-tree&lt;/code&gt; 와 같은 기본 Git 배관 도구 는 명령 행 옵션으로 지정된 &lt;code&gt;gitignore&lt;/code&gt; 패턴을 읽 거나 명령 행 옵션으로 지정된 파일에서 읽습니다 . &lt;code&gt;git status&lt;/code&gt; 및 &lt;code&gt;git add&lt;/code&gt; 와 같은 상위 레벨 Git 도구는 위에 지정된 소스의 패턴을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c7717dd458d0c51efaa12d77d8ac91e6b1b7952a" translate="yes" xml:space="preserve">
          <source>The unique identifier of an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt;. The object name is usually represented by a 40 character hexadecimal string. Also colloquially called &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_object&quot;&gt;객체&lt;/a&gt; 의 고유 식별자입니다 . 오브젝트 이름은 일반적으로 40 자 16 진 문자열로 표시됩니다. 구어 적으로 &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; 이라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="190c2fffcaa0444f677f39ee7f8533684a0964b1" translate="yes" xml:space="preserve">
          <source>The unit of storage in Git. It is uniquely identified by the &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; of its contents. Consequently, an object cannot be changed.</source>
          <target state="translated">Git의 저장 단위. 내용 의 &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; 로 고유하게 식별됩니다 . 따라서 개체를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="39871fae2a5575ced5627a5aed0eb792e4c6cc2e" translate="yes" xml:space="preserve">
          <source>The untracked cache extension can be enabled by the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">추적되지 않은 캐시 확장은 &lt;code&gt;core.untrackedCache&lt;/code&gt; 구성 변수에 의해 활성화 될 수 있습니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cc7260429a75073116cdc4eb67dbd95326cbd29d" translate="yes" xml:space="preserve">
          <source>The upstream project is expected to have the commit named by &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; and the output asks it to integrate the changes you made since that commit, up to the commit named by &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt;, by visiting the repository named by &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">업스트림 프로젝트는 &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; 라는 커밋을 가질 것으로 예상되며 출력은 &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; 이라는 리포지토리를 방문하여 커밋 이후 변경 사항을 &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; 라는 커밋까지 통합하도록 요청합니다 .</target>
        </trans-unit>
        <trans-unit id="90c1df21766dd92e926e4168cc9d516f756c7832" translate="yes" xml:space="preserve">
          <source>The upstream reference is generally &lt;code&gt;refs/remotes/p4/master&lt;/code&gt;, but can be overridden using the &lt;code&gt;--origin=&lt;/code&gt; command-line option.</source>
          <target state="translated">업스트림 참조는 일반적으로 &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; 이지만 &lt;code&gt;--origin=&lt;/code&gt; 명령 줄 옵션을 사용하여 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26e6d639f86a47deca57ab3911edaae9c5141f38" translate="yes" xml:space="preserve">
          <source>The user wants to fast-forward to $M.</source>
          <target state="translated">사용자는 $ M으로 빨리 감기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="6df61c6f9e257fdbf1ce4a60fb1d73b618d329ca" translate="yes" xml:space="preserve">
          <source>The user&amp;rsquo;s color.status configuration is not respected; color will always be off.</source>
          <target state="translated">사용자의 color.status 구성은 존중되지 않습니다. 색상은 항상 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab6a20b222f27dba657bc91ae7970effd7a690ca" translate="yes" xml:space="preserve">
          <source>The user&amp;rsquo;s status.relativePaths configuration is not respected; paths shown will always be relative to the repository root.</source>
          <target state="translated">사용자의 status.relativePaths 구성은 존중되지 않습니다. 표시된 경로는 항상 저장소 루트를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="20126eaca194f3ace1deaba2aaa4133e6326b674" translate="yes" xml:space="preserve">
          <source>The user-provided shell commands will likely involve a pipeline of commands, resulting in the creation of many processes per commit. Creating and running another process takes a widely varying amount of time between operating systems, but on any platform it is very slow relative to invoking a function.</source>
          <target state="translated">사용자가 제공 한 셸 명령에는 명령 파이프 라인이 포함되어 커밋 당 많은 프로세스가 만들어집니다. 다른 프로세스를 작성하고 실행하는 데는 운영 체제마다 시간이 많이 걸리지 만 플랫폼에 관계없이 함수 호출에 비해 속도가 느립니다.</target>
        </trans-unit>
        <trans-unit id="b70cc2efdcbaf68bada34e0550746a0012d52bae" translate="yes" xml:space="preserve">
          <source>The username to use when logging in to the server.</source>
          <target state="translated">서버에 로그인 할 때 사용할 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ed02ee3239772cb9dc0f4dbf65c91bd756125cc7" translate="yes" xml:space="preserve">
          <source>The usual way to deal with this is to use &lt;code&gt;git revert&lt;/code&gt;. This preserves the history that the original change was made and was a valuable contribution, but also introduces a new commit that undoes those changes because the original had a problem. The commit message of the revert indicates the commit which was reverted and is usually edited to include an explanation as to why the revert was made.</source>
          <target state="translated">이를 처리하는 일반적인 방법은 &lt;code&gt;git revert&lt;/code&gt; 를 사용하는 것 입니다. 이것은 원래 변경이 이루어졌고 귀중한 공헌이었던 역사를 보존 할뿐만 아니라 원본에 문제가 있었기 때문에 이러한 변경을 취소하는 새로운 커밋을 도입합니다. 되돌리기의 커밋 메시지는 되 돌린 커밋을 나타내며 일반적으로 되돌리기가 이루어진 이유에 대한 설명을 포함하도록 편집됩니다.</target>
        </trans-unit>
        <trans-unit id="46c33e134557b27ccb1a85349808f80ba518bd84" translate="yes" xml:space="preserve">
          <source>The valid values for this option are: &lt;code&gt;add&lt;/code&gt; (this is the default) and &lt;code&gt;doNothing&lt;/code&gt;.</source>
          <target state="translated">이 옵션의 유효한 값은 &lt;code&gt;add&lt;/code&gt; (이것이 기본값 임) 및 &lt;code&gt;doNothing&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="17a990c606d2e2e22a8f755a1f843b57ef2f5ef2" translate="yes" xml:space="preserve">
          <source>The valid values for this option are: &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; (this is the default), &lt;code&gt;addIfDifferent&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt; or &lt;code&gt;doNothing&lt;/code&gt;.</source>
          <target state="translated">이 옵션의 유효한 값은 &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; (이것이 기본값 임), &lt;code&gt;addIfDifferent&lt;/code&gt; , &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;replace&lt;/code&gt; 또는 &lt;code&gt;doNothing&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="505e929c5c3b27eed17b03a2625718de5c7f7031" translate="yes" xml:space="preserve">
          <source>The value for a variable that takes a color is a list of colors (at most two, one for foreground and one for background) and attributes (as many as you want), separated by spaces.</source>
          <target state="translated">색상을 취하는 변수의 값은 공백으로 구분 된 색상 (최대 2 개, 전경 및 1) 및 속성 (원하는 수) 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e1d242fc18797a443a86ba553d48e3f3cae01e9a" translate="yes" xml:space="preserve">
          <source>The value for many variables that specify various sizes can be suffixed with &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt;,&amp;hellip;​ to mean &quot;scale the number by 1024&quot;, &quot;by 1024x1024&quot;, etc.</source>
          <target state="translated">다양한 크기를 지정하는 많은 변수의 값은 &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;M&lt;/code&gt; 으로 접미사를 붙일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1dedc58ec3c676ad597a786553123421e517365" translate="yes" xml:space="preserve">
          <source>The value is a list of three values: a default time zone (for if the client hasn&amp;rsquo;t selected some other time zone and saved it in a cookie), a name of cookie where to store selected time zone, and a CSS class used to mark up dates for manipulation. If you want to turn this feature off, set &quot;default&quot; to empty list: &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">이 값은 기본 시간대 (클라이언트가 다른 시간대를 선택하지 않고 쿠키에 저장 한 경우), 선택한 시간대를 저장할 쿠키 이름 및 사용 된 CSS 클래스의 세 가지 값 목록입니다. 조작 날짜를 표시합니다. 이 기능을 끄려면 &quot;default&quot;를 빈 목록으로 설정하십시오 : &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0462ada8e80b752f4ecad69fb2563ec0b8b930aa" translate="yes" xml:space="preserve">
          <source>The value of 'default' is a list of names of snapshot formats, defined in &lt;code&gt;%known_snapshot_formats&lt;/code&gt; hash, that you wish to offer. Supported formats include &quot;tgz&quot;, &quot;tbz2&quot;, &quot;txz&quot; (gzip/bzip2/xz compressed tar archive) and &quot;zip&quot;; please consult gitweb sources for a definitive list. By default only &quot;tgz&quot; is offered.</source>
          <target state="translated">'default'값은 제공하려는 &lt;code&gt;%known_snapshot_formats&lt;/code&gt; 해시에 정의 된 스냅 샷 형식의 이름 목록입니다 . 지원되는 형식은 &quot;tgz&quot;, &quot;tbz2&quot;, &quot;txz&quot;(gzip / bzip2 / xz 압축 tar 아카이브) 및 &quot;zip&quot;입니다. 결정적인 목록은 gitweb 소스를 참조하십시오. 기본적으로 &quot;tgz&quot;만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c34b53e9a12553098df9adad4c30762484ffde18" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; must be a valid refname in Git and therefore may contain forward slashes. As &lt;code&gt;LF&lt;/code&gt; is not valid in a Git refname, no quoting or escaping syntax is supported here.</source>
          <target state="translated">&lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 의 값은 Git에서 유효한 참조 이름 이어야하므로 슬래시를 포함 할 수 있습니다. 으로 &lt;code&gt;LF&lt;/code&gt; 가 힘내 refname에 유효하지 않은, 더 인용 또는 이스케이프 구문은 여기에 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b5a30f586808b1827fdb8f433a15c6c9d49f6ba" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; must be in canonical form. That is it must not:</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 의 값은 정식 형식이어야합니다. 그것은해서는 안됩니다 :</target>
        </trans-unit>
        <trans-unit id="dfb2ec984e9987b1b930824861a3abbf3e4aa29f" translate="yes" xml:space="preserve">
          <source>The value of this attribute specifies the character encoding that should be used by GUI tools (e.g. &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; and &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;) to display the contents of the relevant file. Note that due to performance considerations &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; does not use this attribute unless you manually enable per-file encodings in its options.</source>
          <target state="translated">이 속성의 값은 GUI 도구 (예 : &lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt; 및 &lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt; )가 관련 파일의 내용을 표시하는 데 사용해야하는 문자 인코딩을 지정 합니다. 성능 고려 사항으로 인해 &lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt; 은 옵션에서 파일 별 인코딩을 수동으로 활성화하지 않는 한이 속성을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4bdcd2a8dee01aee6c5f0f23e7e10ac25985aae6" translate="yes" xml:space="preserve">
          <source>The value of this key is the name of the promisor remote.</source>
          <target state="translated">이 키의 값은 Promisor Remote의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="49e3be97b83e2e2d47823db7b33592c5066364cc" translate="yes" xml:space="preserve">
          <source>The version parameter is used to specify the format version. This is optional and defaults to the original version &lt;code&gt;v1&lt;/code&gt; format.</source>
          <target state="translated">version 매개 변수는 형식 버전을 지정하는 데 사용됩니다. 이것은 선택 사항이며 기본값은 원래 버전 &lt;code&gt;v1&lt;/code&gt; 형식입니다.</target>
        </trans-unit>
        <trans-unit id="a720bc9826a296e909d26ea1e1addd2076945090" translate="yes" xml:space="preserve">
          <source>The victim sends &quot;have&quot; lines advertising the IDs of objects it has that are not explicitly intended to be shared but can be used to optimize the transfer if the peer also has them. The attacker chooses an object ID X to steal and sends a ref to X, but isn&amp;rsquo;t required to send the content of X because the victim already has it. Now the victim believes that the attacker has X, and it sends the content of X back to the attacker later. (This attack is most straightforward for a client to perform on a server, by creating a ref to X in the namespace the client has access to and then fetching it. The most likely way for a server to perform it on a client is to &quot;merge&quot; X into a public branch and hope that the user does additional work on this branch and pushes it back to the server without noticing the merge.)</source>
          <target state="translated">피해자는 명시 적으로 공유 할 의도는 없지만 피어가 가지고있는 경우 전송을 최적화하는 데 사용할 수있는 오브젝트의 ID를 알리는 &quot;have&quot;라인을 보냅니다. 공격자는 개체 ID X를 선택하여 도용하고 참조를 X에 보냅니다. 그러나 피해자가 이미 가지고 있기 때문에 X의 내용을 보낼 필요는 없습니다. 이제 피해자는 공격자가 X를 가지고 있다고 믿고 나중에 X의 내용을 공격자에게 다시 보냅니다. (이 공격은 클라이언트가 액세스 할 수있는 네임 스페이스에서 X에 대한 참조를 생성 한 후 가져 와서 클라이언트가 서버에서 수행 할 수있는 가장 간단한 방법입니다. X를 공개 브랜치로 병합하고 사용자가이 브랜치에서 추가 작업을 수행하고 병합을 알리지 않고 서버로 다시 밀어 넣기를 바랍니다.)</target>
        </trans-unit>
        <trans-unit id="bad569f9e07003c7e9ba90b91ff6d5e2d3ebab92" translate="yes" xml:space="preserve">
          <source>The virtual host configuration (in Apache configuration file) should look like this:</source>
          <target state="translated">Apache 구성 파일의 가상 호스트 구성은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="6258db9fdd3beac891e6dcfd7dedb19764ce413e" translate="yes" xml:space="preserve">
          <source>The way &lt;code&gt;git update-index&lt;/code&gt; handles files it is told about can be modified using the various options:</source>
          <target state="translated">&lt;code&gt;git update-index&lt;/code&gt; 가 파일을 처리 하는 방식 은 다양한 옵션을 사용하여 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fe1a87d113fe93088f754b0185b7bc1cb985816" translate="yes" xml:space="preserve">
          <source>The web browser can be specified using a configuration variable passed with the -c (or --config) command-line option, or the &lt;code&gt;web.browser&lt;/code&gt; configuration variable if the former is not used.</source>
          <target state="translated">웹 브라우저는 -c (또는 --config) 명령 줄 옵션과 함께 전달 된 구성 변수를 사용하거나 전자가 사용되지 않는 경우 &lt;code&gt;web.browser&lt;/code&gt; 구성 변수를 사용 하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae6c5b18c0fd18e4f577ab3723eb5808f05d9f12" translate="yes" xml:space="preserve">
          <source>The web browser can be specified using the configuration variable &lt;code&gt;help.browser&lt;/code&gt;, or &lt;code&gt;web.browser&lt;/code&gt; if the former is not set. If none of these config variables is set, the &lt;code&gt;git web--browse&lt;/code&gt; helper script (called by &lt;code&gt;git help&lt;/code&gt;) will pick a suitable default. See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt; for more information about this.</source>
          <target state="translated">The web browser can be specified using the configuration variable &lt;code&gt;help.browser&lt;/code&gt; , or &lt;code&gt;web.browser&lt;/code&gt; if the former is not set. If none of these config variables is set, the &lt;code&gt;git web--browse&lt;/code&gt; helper script (called by &lt;code&gt;git help&lt;/code&gt; ) will pick a suitable default. See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt; for more information about this.</target>
        </trans-unit>
        <trans-unit id="dc2adc08265063993fb836b81a622f1e26249d55" translate="yes" xml:space="preserve">
          <source>The web browser can be specified using the configuration variable &lt;code&gt;help.browser&lt;/code&gt;, or &lt;code&gt;web.browser&lt;/code&gt; if the former is not set. If none of these config variables is set, the &lt;code&gt;git web{litdd}browse&lt;/code&gt; helper script (called by &lt;code&gt;git help&lt;/code&gt;) will pick a suitable default. See git-web{litdd}browse[1] for more information about this.</source>
          <target state="translated">구성 변수 &lt;code&gt;help.browser&lt;/code&gt; 또는 &lt;code&gt;web.browser&lt;/code&gt; 를 설정하지 않은 경우 웹 브라우저를 지정할 수 있습니다 . 이러한 구성 변수가 설정되지 않은 경우 &lt;code&gt;git web{litdd}browse&lt;/code&gt; 도우미 스크립트 ( &lt;code&gt;git help&lt;/code&gt; 라고 함 )가 적절한 기본값을 선택합니다. 이에 대한 자세한 내용은 git-web {litdd} browse [1]를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d52f23a775c5f3aadffb0193202482a8a4b8d0b1" translate="yes" xml:space="preserve">
          <source>The web browser that should be used to view the gitweb page. This will be passed to the &lt;code&gt;git web--browse&lt;/code&gt; helper script along with the URL of the gitweb instance. See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt; for more information about this. If the script fails, the URL will be printed to stdout.</source>
          <target state="translated">The web browser that should be used to view the gitweb page. This will be passed to the &lt;code&gt;git web--browse&lt;/code&gt; helper script along with the URL of the gitweb instance. See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt; for more information about this. If the script fails, the URL will be printed to stdout.</target>
        </trans-unit>
        <trans-unit id="c38f40c77930468f76ac59e3f127231f37c11803" translate="yes" xml:space="preserve">
          <source>The web browser that should be used to view the gitweb page. This will be passed to the &lt;code&gt;git web{litdd}browse&lt;/code&gt; helper script along with the URL of the gitweb instance. See git-web{litdd}browse[1] for more information about this. If the script fails, the URL will be printed to stdout.</source>
          <target state="translated">gitweb 페이지를 보는 데 사용해야하는 웹 브라우저. 이것은 gitweb 인스턴스의 URL과 함께 &lt;code&gt;git web{litdd}browse&lt;/code&gt; 도우미 스크립트 로 전달됩니다 . 이에 대한 자세한 내용은 git-web {litdd} browse [1]를 참조하십시오. 스크립트가 실패하면 URL이 표준 출력으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="c7492cc5fa9e9927a227312bd1f1ea85a3766cb5" translate="yes" xml:space="preserve">
          <source>The width (in characters) of the &quot;Description&quot; column of the projects list. Longer descriptions will be truncated (trying to cut at word boundary); the full description is available in the &lt;code&gt;title&lt;/code&gt; attribute (usually shown on mouseover). The default is 25, which might be too small if you use long project descriptions.</source>
          <target state="translated">프로젝트 목록의 &quot;설명&quot;열의 너비 (문자)입니다. 더 긴 설명은 잘립니다 (단어 경계에서 자르려고 시도 함). 자세한 설명은 &lt;code&gt;title&lt;/code&gt; 속성 (일반적으로 마우스 오버에 표시)에서 사용할 수 있습니다 . 기본값은 25이며, 긴 프로젝트 설명을 사용하면 너무 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a9553b8b798d28f6c8fd9f09980f5b7959498e9" translate="yes" xml:space="preserve">
          <source>The window size parameter used in the delta compression algorithm used by &lt;code&gt;git gc --aggressive&lt;/code&gt;. This defaults to 250, which is a much more aggressive window size than the default &lt;code&gt;--window&lt;/code&gt; of 10.</source>
          <target state="translated">&lt;code&gt;git gc --aggressive&lt;/code&gt; 가 사용하는 델타 압축 알고리즘에 사용되는 창 크기 매개 변수 입니다. 기본값은 250으로, 기본 &lt;code&gt;--window&lt;/code&gt; 10 보다 훨씬 공격적인 창 크기 입니다.</target>
        </trans-unit>
        <trans-unit id="046739930d5e8946cdceaf820a70c4ac9ebc8d51" translate="yes" xml:space="preserve">
          <source>The working directory then reflects the contents that the project had when it was tagged v2.6.13, and &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; shows two branches, with an asterisk marking the currently checked-out branch:</source>
          <target state="translated">작업 디렉토리는 프로젝트가 v2.6.13으로 태그 될 때 가지고 있던 내용을 반영하고 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; 은 현재 체크 아웃 된 분기를 표시하는 별표와 함께 두 개의 분기를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c76d23bfcb6d4a63fd96acda23f8bee068090518" translate="yes" xml:space="preserve">
          <source>The worktree list command has two output formats. The default format shows the details on a single line with columns. For example:</source>
          <target state="translated">worktree list 명령에는 두 가지 출력 형식이 있습니다. 기본 형식은 열이있는 단일 행에 세부 사항을 표시합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ecaf7c5f30215b083ffbd406549425a7d1040c7d" translate="yes" xml:space="preserve">
          <source>Then &quot;&lt;code&gt;git merge topic&lt;/code&gt;&quot; will replay the changes made on the &lt;code&gt;topic&lt;/code&gt; branch since it diverged from &lt;code&gt;master&lt;/code&gt; (i.e., &lt;code&gt;E&lt;/code&gt;) until its current commit (&lt;code&gt;C&lt;/code&gt;) on top of &lt;code&gt;master&lt;/code&gt;, and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes.</source>
          <target state="translated">그런 다음 &quot; &lt;code&gt;git merge topic&lt;/code&gt; &quot;는에 변경 사항 재생됩니다 &lt;code&gt;topic&lt;/code&gt; 는에서 분기 이후 분기 &lt;code&gt;master&lt;/code&gt; (즉, &lt;code&gt;E&lt;/code&gt; 현재는 (커밋 될 때까지) &lt;code&gt;C&lt;/code&gt; 의 상단에) &lt;code&gt;master&lt;/code&gt; 의 이름과 함께 커밋, 새로운의 결과를 기록 부모 커밋 두 개와 변경 사항을 설명하는 사용자의 로그 메시지</target>
        </trans-unit>
        <trans-unit id="f3bf49c80f1bf671798b336ee7a6337eb982b2bc" translate="yes" xml:space="preserve">
          <source>Then &quot;&lt;code&gt;git pull&lt;/code&gt;&quot; will fetch and replay the changes from the remote &lt;code&gt;master&lt;/code&gt; branch since it diverged from the local &lt;code&gt;master&lt;/code&gt; (i.e., &lt;code&gt;E&lt;/code&gt;) until its current commit (&lt;code&gt;C&lt;/code&gt;) on top of &lt;code&gt;master&lt;/code&gt; and record the result in a new commit along with the names of the two parent commits and a log message from the user describing the changes.</source>
          <target state="translated">그런 다음 &quot; &lt;code&gt;git pull&lt;/code&gt; &quot;가져 오기 및 원격의 변경 재생됩니다 &lt;code&gt;master&lt;/code&gt; 는 지역에서 분기 이후 분기를 &lt;code&gt;master&lt;/code&gt; (즉, &lt;code&gt;E&lt;/code&gt; ) 현재 커밋 될 때까지 ( &lt;code&gt;C&lt;/code&gt; 위에) &lt;code&gt;master&lt;/code&gt; 과 함께 커밋하고 새에 결과를 기록 두 개의 상위 커밋 이름과 사용자가 변경 내용을 설명하는 로그 메시지.</target>
        </trans-unit>
        <trans-unit id="44f92500b7ae9560ae64e2f2fc4f1af900d3ff26" translate="yes" xml:space="preserve">
          <source>Then &quot;git bisect&quot; will checkout a commit of its choosing and ask the user to test it, like this:</source>
          <target state="translated">그런 다음 &quot;git bisect&quot;는 선택한 커밋을 체크 아웃하고 사용자에게 다음과 같이 테스트하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="e1ef052a3cd59f805d0ae45d1b9033a6a2faaa95" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;git bisect&lt;/code&gt; will respond with something like</source>
          <target state="translated">그런 다음 &lt;code&gt;git bisect&lt;/code&gt; 는 다음과 같이 응답합니다.</target>
        </trans-unit>
        <trans-unit id="307236a389d15c9e88cc574f3c2b3a0314992840" translate="yes" xml:space="preserve">
          <source>Then compile and test the chosen revision, and afterwards mark the revision as good or bad in the usual manner.</source>
          <target state="translated">그런 다음 선택한 개정을 컴파일하고 테스트 한 후 일반적인 방식으로 개정을 양호 또는 불량으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="876e252bd62eb2a97f748800c6625b2b00ccfdec" translate="yes" xml:space="preserve">
          <source>Then confirm that the bug persists in a repository created from that stream (many bugs will not, as they really do depend on the exact repository contents):</source>
          <target state="translated">그런 다음 해당 스트림에서 생성 된 리포지토리에 버그가 지속되는지 확인합니다 (정확한 리포지토리 내용에 따라 많은 버그가 발생하지 않음).</target>
        </trans-unit>
        <trans-unit id="87463a5d117dae6022935ddfd68f09bfbb9b0943" translate="yes" xml:space="preserve">
          <source>Then create the following script to get list of project in the format suitable for GITWEB_LIST build configuration variable (or &lt;code&gt;$projects_list&lt;/code&gt; variable in gitweb config):</source>
          <target state="translated">그런 다음 GITWEB_LIST 빌드 구성 변수 (또는 gitweb config의 &lt;code&gt;$projects_list&lt;/code&gt; 변수)에 적합한 형식으로 프로젝트 목록을 가져 오려면 다음 스크립트를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5a742d8577423cd13ed5705b5290de27ff73949" translate="yes" xml:space="preserve">
          <source>Then fixup &quot;master&quot; with &lt;code&gt;git rebase&lt;/code&gt;. Do NOT use &lt;code&gt;git merge&lt;/code&gt; or your history will not be compatible with a future &lt;code&gt;dcommit&lt;/code&gt;!</source>
          <target state="translated">그런 다음 &lt;code&gt;git rebase&lt;/code&gt; 로 &quot;master&quot;를 수정하십시오 . &lt;code&gt;git merge&lt;/code&gt; 를 사용하지 마십시오. 그러면 히스토리는 향후 &lt;code&gt;dcommit&lt;/code&gt; 과 호환되지 않습니다 !</target>
        </trans-unit>
        <trans-unit id="78318329e21f0014f75ba54a708b1f46ad0d023c" translate="yes" xml:space="preserve">
          <source>Then it compares the new skip-worktree value with the previous one. If skip-worktree turns from set to unset, it will add the corresponding file back. If it turns from unset to set, that file will be removed.</source>
          <target state="translated">그런 다음 새로운 skip-worktree 값과 이전 skip-worktree 값을 비교합니다. skip-worktree가 set에서 unset으로 바뀌면 해당 파일이 다시 추가됩니다. 설정되지 않은 상태에서 설정 상태로 바뀌면 해당 파일이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5e9c59419a3e5d8568740259a39319d49129c624" translate="yes" xml:space="preserve">
          <source>Then it examines &lt;code&gt;.gitattributes&lt;/code&gt; (which is in the parent directory), and finds that the first line matches, but &lt;code&gt;t/.gitattributes&lt;/code&gt; file already decided how &lt;code&gt;merge&lt;/code&gt;, &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; attributes should be given to this path, so it leaves &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; unset. Attribute &lt;code&gt;baz&lt;/code&gt; is set.</source>
          <target state="translated">그런 다음 &lt;code&gt;.gitattributes&lt;/code&gt; (부모 디렉토리에 있음)를 검사 하고 첫 번째 줄이 일치하는 것을 발견하지만 &lt;code&gt;t/.gitattributes&lt;/code&gt; 파일은 이미 &lt;code&gt;merge&lt;/code&gt; , &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 속성 이이 경로에 제공되어야 하는 방법을 결정 했기 때문에 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 를 남깁니다. 설정되지 않았습니다. 속성 &lt;code&gt;baz&lt;/code&gt; 가 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="1100f313a3d209e54bf3bc725a364711886dbfc4" translate="yes" xml:space="preserve">
          <source>Then modify, reorder, or eliminate patches as needed before applying them again with &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;git-am&quot;&gt;git-am [1]으로&lt;/a&gt; 패치를 다시 적용하기 전에 필요에 따라 패치를 수정, 재 배열 또는 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd43ef848f2d3c4afb2a44ae28c2a413397c1d96" translate="yes" xml:space="preserve">
          <source>Then provide your password via the pserver method, for example:</source>
          <target state="translated">그런 다음 pserver 메소드를 통해 비밀번호를 제공하십시오 (예 :</target>
        </trans-unit>
        <trans-unit id="a774f276f116b48d127c0c1418ef7aa2fe46b49b" translate="yes" xml:space="preserve">
          <source>Then simplify each commit &lt;code&gt;C&lt;/code&gt; to its replacement &lt;code&gt;C'&lt;/code&gt; in the final history according to the following rules:</source>
          <target state="translated">그런 다음 다음 규칙에 따라 각 커밋 &lt;code&gt;C&lt;/code&gt; 를 최종 히스토리에서 대체 &lt;code&gt;C'&lt;/code&gt; 로 단순화 하십시오.</target>
        </trans-unit>
        <trans-unit id="2f5d7fdcf8fcb013dcf3c597507de91a5cb0f77d" translate="yes" xml:space="preserve">
          <source>Then simply fork your topic branches from the stable remotes as explained earlier.</source>
          <target state="translated">그런 다음 앞에서 설명한대로 안정된 리모컨에서 주제 분기를 포크하면됩니다.</target>
        </trans-unit>
        <trans-unit id="b19a7b2e2b2e2252f0564256c9b87915d5db46d3" translate="yes" xml:space="preserve">
          <source>Then suppose you modify the last three commits:</source>
          <target state="translated">그런 다음 마지막 3 개의 커밋을 수정한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e69e2e34d497710c4127a780d2a5ed5c7d7fac83" translate="yes" xml:space="preserve">
          <source>Then there are two ways to get a smaller repository. A safer way is to clone, that keeps your original intact.</source>
          <target state="translated">그런 다음 더 작은 저장소를 얻는 두 가지 방법이 있습니다. 더 안전한 방법은 복제하여 원본을 그대로 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5c871054b486e3acaf28dc409c1ab3e693b4fc90" translate="yes" xml:space="preserve">
          <source>Then this &lt;code&gt;git p4 clone&lt;/code&gt; command:</source>
          <target state="translated">그런 다음이 &lt;code&gt;git p4 clone&lt;/code&gt; 명령 :</target>
        </trans-unit>
        <trans-unit id="db9b57b987ef397bc0b191d278e31ed2d827cb0a" translate="yes" xml:space="preserve">
          <source>Then you can disable sparse checkout. Sparse checkout support in &lt;code&gt;git read-tree&lt;/code&gt; and similar commands is disabled by default. You need to turn &lt;code&gt;core.sparseCheckout&lt;/code&gt; on in order to have sparse checkout support.</source>
          <target state="translated">그런 다음 스파 스 체크 아웃을 비활성화 할 수 있습니다. &lt;code&gt;git read-tree&lt;/code&gt; 및 유사한 명령 에서 스파 스 체크 아웃 지원은 기본적으로 비활성화되어 있습니다. 스파 스 체크 아웃을 지원하려면 &lt;code&gt;core.sparseCheckout&lt;/code&gt; 을 켜야 합니다.</target>
        </trans-unit>
        <trans-unit id="87a33f516a8ffec885e906dbb29e388a5f30ada0" translate="yes" xml:space="preserve">
          <source>Then you can pull and merge, leaving &lt;code&gt;frotz.c&lt;/code&gt; and &lt;code&gt;filfre.c&lt;/code&gt; changes still in the working tree.</source>
          <target state="translated">그런 다음 &lt;code&gt;frotz.c&lt;/code&gt; 및 &lt;code&gt;filfre.c&lt;/code&gt; 변경 사항을 작업 트리에 그대로두고 끌어서 병합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa280cd97c17d646b4ce0e60bbbcb27953b34fb3" translate="yes" xml:space="preserve">
          <source>Then you can push both the test and release trees using &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;:</source>
          <target state="translated">그런 다음 &lt;a href=&quot;git-push&quot;&gt;git-push [1]을&lt;/a&gt; 사용하여 테스트 트리와 릴리스 트리를 모두 푸시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9015e54306232b9477b76c544780cb6cb29e184c" translate="yes" xml:space="preserve">
          <source>Then you might want a &lt;code&gt;.mailmap&lt;/code&gt; file that looks like:</source>
          <target state="translated">그러면 다음과 같은 &lt;code&gt;.mailmap&lt;/code&gt; 파일 이 필요할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bdefcc2b7f4d341c71ca424367a0164c209ac375" translate="yes" xml:space="preserve">
          <source>Then you transfer file.bundle to the target machine B. Because this bundle does not require any existing object to be extracted, you can create a new repository on machine B by cloning from it:</source>
          <target state="translated">그런 다음 file.bundle을 대상 머신 B로 전송합니다.이 번들은 기존 오브젝트를 추출 할 필요가 없으므로 머신 B에서 복제하여 새 저장소를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e826c3727c0c79aa7b30f2352881ef1c5a35f171" translate="yes" xml:space="preserve">
          <source>Then you would define a &quot;filter.indent.clean&quot; and &quot;filter.indent.smudge&quot; configuration in your .git/config to specify a pair of commands to modify the contents of C programs when the source files are checked in (&quot;clean&quot; is run) and checked out (no change is made because the command is &quot;cat&quot;).</source>
          <target state="translated">그런 다음 .git / config에서 &quot;filter.indent.clean&quot;및 &quot;filter.indent.smudge&quot;구성을 정의하여 소스 파일이 체크인 될 때 ​​C 프로그램의 내용을 수정하는 명령 쌍을 지정합니다 ( &quot;clean &quot;가 실행 됨) 및 체크 아웃되었습니다 (명령이&quot;cat &quot;이므로 변경되지 않음).</target>
        </trans-unit>
        <trans-unit id="c6308f4c83137c8ddf705f0b33927bc3a2a2d3bf" translate="yes" xml:space="preserve">
          <source>Then, make that directory into a Git repository by running &lt;code&gt;git init&lt;/code&gt;, but this time, since its name is not the usual &lt;code&gt;.git&lt;/code&gt;, we do things slightly differently:</source>
          <target state="translated">그런 다음 &lt;code&gt;git init&lt;/code&gt; 를 실행하여 해당 디렉토리를 Git 저장소로 만드십시오 .하지만 이번에는 그 이름이 일반적인 &lt;code&gt;.git&lt;/code&gt; 이 아니기 때문에 약간 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4d45e0228f3dfbda52666260c02f45c435d7f13c" translate="yes" xml:space="preserve">
          <source>Then, use &lt;code&gt;git bisect &amp;lt;term-old&amp;gt;&lt;/code&gt; and &lt;code&gt;git bisect &amp;lt;term-new&amp;gt;&lt;/code&gt; instead of &lt;code&gt;git bisect good&lt;/code&gt; and &lt;code&gt;git bisect bad&lt;/code&gt; to mark commits.</source>
          <target state="translated">그런 다음 커밋을 표시하기 위해 &lt;code&gt;git bisect good&lt;/code&gt; 및 &lt;code&gt;git bisect bad&lt;/code&gt; 대신 &lt;code&gt;git bisect &amp;lt;term-old&amp;gt;&lt;/code&gt; 및 &lt;code&gt;git bisect &amp;lt;term-new&amp;gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4891bcd6061a60561c6585b63258de3d0b8b270b" translate="yes" xml:space="preserve">
          <source>Then, you can adjust your push URL to use &lt;code&gt;git@example_author&lt;/code&gt; or &lt;code&gt;git@example_committer&lt;/code&gt; instead of &lt;code&gt;git@example.org&lt;/code&gt; (e.g., &lt;code&gt;git remote set-url
git@example_author:org1/project1.git&lt;/code&gt;).</source>
          <target state="translated">그런 다음 &lt;code&gt;git@example.org&lt;/code&gt; 대신 &lt;code&gt;git@example_author&lt;/code&gt; 또는 &lt;code&gt;git@example_committer&lt;/code&gt; 를 사용하도록 푸시 URL을 조정할 수 있습니다 (예 : &lt;code&gt;git remote set-url git@example_author:org1/project1.git&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b100177b4f5d14520d5631ccbd2bc2ff52393e78" translate="yes" xml:space="preserve">
          <source>Then, you run this command:</source>
          <target state="translated">그런 다음이 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ebbdc2314a6104dc9178c4c9ed7835ad78f84727" translate="yes" xml:space="preserve">
          <source>Then, you would define a &quot;diff.tex.xfuncname&quot; configuration to specify a regular expression that matches a line that you would want to appear as the hunk header &quot;TEXT&quot;. Add a section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file) like this:</source>
          <target state="translated">그런 다음 &quot;diff.tex.xfuncname&quot;구성을 정의하여 헝크 헤더 &quot;TEXT&quot;로 표시 할 행과 일치하는 정규식을 지정하십시오. &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 (또는 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 파일)에 다음과 같이 섹션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d94c9456285c171a8f18dcac7b76fd1fccc9ff4" translate="yes" xml:space="preserve">
          <source>There are (number of parents + 1) &lt;code&gt;@&lt;/code&gt; characters in the chunk header for combined diff format.</source>
          <target state="translated">결합 된 diff 형식의 청크 헤더 에는 (부모 수 + 1) &lt;code&gt;@&lt;/code&gt; 문자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7e9cf96a6ce9ed5c513750352c4736c076b5145" translate="yes" xml:space="preserve">
          <source>There are CPP wrapper macros and ifdefs to hide most of these details. See &lt;code&gt;trace2.h&lt;/code&gt; for more details. The following discussion will only describe the simplified forms.</source>
          <target state="translated">CPP 랩퍼 매크로와 ifdef는 대부분의 세부 사항을 숨길 수 있습니다. 자세한 내용은 &lt;code&gt;trace2.h&lt;/code&gt; 를 참조하십시오. 다음 설명에서는 단순화 된 양식 만 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e4287f1e47cb2bfc1b9e5f25165aef43ceec9d6c" translate="yes" xml:space="preserve">
          <source>There are a few built-in low-level merge drivers defined that can be asked for via the &lt;code&gt;merge&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 속성 을 통해 요청할 수있는 몇 가지 기본 제공 저수준 병합 드라이버가 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12f3989319ea3c0cba3d029a62ee2c306fd0616b" translate="yes" xml:space="preserve">
          <source>There are a few built-in patterns to make this easier, and &lt;code&gt;tex&lt;/code&gt; is one of them, so you do not have to write the above in your configuration file (you still need to enable this with the attribute mechanism, via &lt;code&gt;.gitattributes&lt;/code&gt;). The following built in patterns are available:</source>
          <target state="translated">이것을 쉽게하기 위해 몇 가지 내장 패턴이 있으며 &lt;code&gt;tex&lt;/code&gt; 는 그중 하나이므로 구성 파일에 위의 내용을 쓸 필요가 없습니다 (여전히 &lt;code&gt;.gitattributes&lt;/code&gt; 를 통해 속성 메커니즘으로 이것을 활성화해야합니다 ). 다음과 같은 내장 패턴을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="336d04ab3583042f88f12edf2d051324b94f62a0" translate="yes" xml:space="preserve">
          <source>There are a few issues to resolve before we can completely switch to Trace2.</source>
          <target state="translated">Trace2로 완전히 전환하기 전에 해결해야 할 몇 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8e0813ee0029806de1de3d5b367acd9c0a0d07d" translate="yes" xml:space="preserve">
          <source>There are a few more behavioral differences that most folks would probably consider inconsequential but which are mentioned for completeness:</source>
          <target state="translated">There are a few more behavioral differences that most folks would probably consider inconsequential but which are mentioned for completeness:</target>
        </trans-unit>
        <trans-unit id="f553cccafe9fdfa62552e6e1af4be573be245c47" translate="yes" xml:space="preserve">
          <source>There are a few special-purpose refs that do not begin with &lt;code&gt;refs/&lt;/code&gt;. The most notable example is &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;refs/&lt;/code&gt; 시작하지 않는 몇 가지 특수 목적 ref가 있습니다. 가장 주목할만한 예는 &lt;code&gt;HEAD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cc9f53378dabd08666f7e5c5af2a717dbbd37e28" translate="yes" xml:space="preserve">
          <source>There are a number of factors which affect how much memory fast-import requires to perform an import. Like critical sections of core Git, fast-import uses its own memory allocators to amortize any overheads associated with malloc. In practice fast-import tends to amortize any malloc overheads to 0, due to its use of large block allocations.</source>
          <target state="translated">가져 오기를 수행하기 위해 빠른 가져 오기에 필요한 메모리 양에 영향을주는 여러 가지 요소가 있습니다. 핵심 Git의 중요한 섹션과 마찬가지로 빠른 가져 오기는 자체 메모리 할당자를 사용하여 malloc과 관련된 모든 오버 헤드를 상각합니다. 실제로 빠른 가져 오기는 큰 블록 할당을 사용하기 때문에 malloc 오버 헤드를 0으로 상각하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0b2b532209e8b05d8ee20f67e782301986fd65a" translate="yes" xml:space="preserve">
          <source>There are also cases where existing indexes written by git versions before 2.17 will reference directories that don&amp;rsquo;t exist anymore, potentially causing many &quot;could not open directory&quot; warnings to be printed on &quot;git status&quot;. These are new warnings for existing issues that were previously silently discarded.</source>
          <target state="translated">2.17 이전의 git 버전으로 작성된 기존 인덱스가 더 이상 존재하지 않는 디렉토리를 참조하여 &quot;git status&quot;에 많은 &quot;디렉토리를 열 수 없음&quot;경고가 표시되는 경우도 있습니다. 이전에 자동으로 삭제 된 기존 문제에 대한 새로운 경고입니다.</target>
        </trans-unit>
        <trans-unit id="aec0acb7fb7522f7c5da2df9b13975842cb9d1be" translate="yes" xml:space="preserve">
          <source>There are also more complex operations that can be performed. But beware that because the patch is applied only to the index and not the working tree, the working tree will appear to &quot;undo&quot; the change in the index. For example, introducing a new line into the index that is in neither the HEAD nor the working tree will stage the new line for commit, but the line will appear to be reverted in the working tree.</source>
          <target state="translated">수행 할 수있는 더 복잡한 작업도 있습니다. 그러나 패치는 작업 트리가 아닌 인덱스에만 적용되므로 작업 트리는 인덱스 변경을 &quot;실행 취소&quot;하는 것처럼 보입니다. 예를 들어, HEAD 나 작업 트리에없는 색인에 새 줄을 도입하면 커밋을 위해 새 줄을 스테이징하지만 작업 트리에서 줄이 되돌아 간 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="a266660a35cd18470141c43d8a3ffa2b3074c06a" translate="yes" xml:space="preserve">
          <source>There are also other situations that cause dangling objects. For example, a &quot;dangling blob&quot; may arise because you did a &lt;code&gt;git add&lt;/code&gt; of a file, but then, before you actually committed it and made it part of the bigger picture, you changed something else in that file and committed that &lt;strong&gt;updated&lt;/strong&gt; thing&amp;mdash;​the old state that you added originally ends up not being pointed to by any commit or tree, so it&amp;rsquo;s now a dangling blob object.</source>
          <target state="translated">매달린 물체를 일으키는 다른 상황도 있습니다. 예를 들어, &quot;매달려 BLOB는&quot;당신이했기 때문에 발생할 수있는 &lt;code&gt;git add&lt;/code&gt; 당신이 실제로 노력과 더 큰 그림의 일부가 만든 전에, 다음의 파일을하지만, 그 파일에 다른 뭔가를 변경 한 것을 최선을 다하고 &lt;strong&gt;업데이트&lt;/strong&gt; 쿄코 원래 추가 한 이전 상태는 커밋이나 트리가 가리 키지 않으므로 이제 매달려있는 얼룩 개체입니다.</target>
        </trans-unit>
        <trans-unit id="232088d916b340ecad3098c72c2ebccbe30b76e5" translate="yes" xml:space="preserve">
          <source>There are also several operations which should be avoided entirely, as they will make the patch impossible to apply:</source>
          <target state="translated">패치를 적용 할 수 없게하므로 완전히 피해야하는 여러 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eeb0752be9462c9bd2e54575f2023419e06b3d3b" translate="yes" xml:space="preserve">
          <source>There are also ways to automate the bisecting process if you have a test script that can tell a good from a bad commit. See &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; for more information about this and other &lt;code&gt;git
bisect&lt;/code&gt; features.</source>
          <target state="translated">잘못된 커밋에서 좋은 것을 알 수있는 테스트 스크립트가있는 경우 이등분 프로세스를 자동화하는 방법도 있습니다. 참조 &lt;a href=&quot;git-bisect&quot;&gt;자식-양분 [1]&lt;/a&gt; 및 기타에 대한 자세한 내용은 &lt;code&gt;git bisect&lt;/code&gt; 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="753d0dde7d0dbacd496fb113e3e96e5ea6d9494d" translate="yes" xml:space="preserve">
          <source>There are four different types of objects: &quot;blob&quot;, &quot;tree&quot;, &quot;commit&quot;, and &quot;tag&quot;.</source>
          <target state="translated">&quot;blob&quot;, &quot;tree&quot;, &quot;commit&quot;및 &quot;tag&quot;의 네 가지 유형의 개체가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3d0232ce28c94288cf502f722ca216e09b8c5b1" translate="yes" xml:space="preserve">
          <source>There are implementations of Git that do not leave usable values in some fields (e.g. JGit); by excluding these fields from the comparison, the &lt;code&gt;minimal&lt;/code&gt; mode may help interoperability when the same repository is used by these other systems at the same time.</source>
          <target state="translated">일부 필드에서 사용 가능한 값을 남기지 않는 Git 구현이 있습니다 (예 : JGit). 이러한 필드를 비교에서 제외함으로써 &lt;code&gt;minimal&lt;/code&gt; 모드는 다른 시스템에서 동일한 저장소를 동시에 사용할 때 상호 운용성을 도울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac26d523869587e187089ca0cfe8dfa88bde0428" translate="yes" xml:space="preserve">
          <source>There are many more; see the &quot;SPECIFYING REVISIONS&quot; section of the &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; man page for the complete list of ways to name revisions. Some examples:</source>
          <target state="translated">더 많은 것이 있습니다. 개정판 이름 지정 방법의 전체 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 매뉴얼 페이지 의 &quot;사양 수정&quot;섹션을 참조하십시오. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="caa64d4f477bb9cc6ae8b8763c8d93ec4bfb0cef" translate="yes" xml:space="preserve">
          <source>There are no facilities for helping users find what unwanted crud they should delete, which means they are much more likely to have incomplete or partial cleanups that sometimes result in confusion and people wasting time trying to understand. (For example, folks tend to just look for big files to delete instead of big directories or extensions, and once they do so, then sometime later folks using the new repository who are going through history will notice a build artifact directory that has some files but not others, or a cache of dependencies (node_modules or similar) which couldn&amp;rsquo;t have ever been functional since it&amp;rsquo;s missing some files.)</source>
          <target state="translated">사용자가 삭제해야하는 원치 않는 크 러드를 찾도록 도와주는 기능이 없기 때문에 때때로 불완전하거나 부분적으로 정리되어 혼동을 일으키고 사람들이 이해하려고 시간을 낭비하는 경우가 훨씬 많습니다. (예를 들어, 사람들은 큰 디렉토리 또는 확장명 대신 삭제할 큰 파일을 찾는 경향이 있으며 일단 그렇게되면 역사를 겪고있는 새로운 저장소를 사용하는 사람들은 나중에 일부 파일이있는 빌드 아티팩트 디렉토리를 보게됩니다 그러나 다른 파일이나 종속성 캐시 (node_modules 또는 이와 유사한)는 일부 파일이 없기 때문에 작동 할 수 없었습니다.)</target>
        </trans-unit>
        <trans-unit id="ce4a9f9a1026ea763732ff998a2bcfb7b60f26ca" translate="yes" xml:space="preserve">
          <source>There are no public Trace2 data structures.</source>
          <target state="translated">공개 Trace2 데이터 구조가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a1dbdef2a9d4fcde2fec24ad984bfc7ec6f3aa2" translate="yes" xml:space="preserve">
          <source>There are numerous other tools, such as StGit, which exist for the purpose of maintaining a patch series. These are outside of the scope of this manual.</source>
          <target state="translated">패치 시리즈를 유지하기 위해 존재하는 StGit과 같은 다른 많은 도구가 있습니다. 이것들은이 매뉴얼의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="306721e74c73edf4b4a1c2554be600724c25d3f0" translate="yes" xml:space="preserve">
          <source>There are other estimates saying that 80% of the cost related to software is about maintenance &lt;a href=&quot;#2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">소프트웨어와 관련된 비용의 80 %가 유지 보수에 관한 것이라고 다른 추정이 있습니다 &lt;a href=&quot;#2&quot;&gt;[2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7eccee0caa41472aded0ea349d3d3fa4831b32ab" translate="yes" xml:space="preserve">
          <source>There are other real-world examples of using update and post-update hooks found in the Documentation/howto directory.</source>
          <target state="translated">Documentation / howto 디렉토리에있는 업데이트 및 사후 업데이트 후크 사용에 대한 다른 실제 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddc4304f0c733f93eaa36c71971b210be6c86baa" translate="yes" xml:space="preserve">
          <source>There are several built-in formats, and you can define additional formats by setting a pretty.&amp;lt;name&amp;gt; config option to either another format name, or a &lt;code&gt;format:&lt;/code&gt; string, as described below (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Here are the details of the built-in formats:</source>
          <target state="translated">몇 가지 기본 제공 형식이 있으며 아래에 설명 된대로 pretty. &amp;lt;name&amp;gt; 구성 옵션을 다른 형식 이름 또는 &lt;code&gt;format:&lt;/code&gt; 문자열 로 설정하여 추가 형식을 정의 할 수 있습니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). 내장 형식의 세부 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="172e083c83bf7e6cbde177805c61722f6bdc0777" translate="yes" xml:space="preserve">
          <source>There are some numbers about bugs in general, like a NIST study in 2002 &lt;a href=&quot;#1&quot;&gt;[1]&lt;/a&gt; that said:</source>
          <target state="translated">2002 년 NIST 연구 &lt;a href=&quot;#1&quot;&gt;[1]&lt;/a&gt; 와 같이 일반적으로 버그에 관한 몇 가지 숫자 가있다 :</target>
        </trans-unit>
        <trans-unit id="1a73feb2f257a54073e6e874ef78ceeefd47d29e" translate="yes" xml:space="preserve">
          <source>There are some subtle differences how the backends behave.</source>
          <target state="translated">백엔드의 작동 방식에는 미묘한 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a41ebe77f2eb54fbd4f30714a2e14c8c1d436ea0" translate="yes" xml:space="preserve">
          <source>There are three commands with similar names: &lt;code&gt;git reset&lt;/code&gt;, &lt;code&gt;git restore&lt;/code&gt; and &lt;code&gt;git revert&lt;/code&gt;.</source>
          <target state="translated">비슷한 이름을 가진 &lt;code&gt;git reset&lt;/code&gt; , &lt;code&gt;git restore&lt;/code&gt; 및 &lt;code&gt;git revert&lt;/code&gt; 의 세 가지 명령이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27e17ed315eeb27fa67bd10d3870c4d2deb8a92d" translate="yes" xml:space="preserve">
          <source>There are three different approaches: use an add-on to turn off line wraps, configure Thunderbird to not mangle patches, or use an external editor to keep Thunderbird from mangling the patches.</source>
          <target state="translated">추가 기능을 사용하여 줄 바꿈 기능을 끄거나, 패치를 처리하지 않도록 Thunderbird를 구성하거나, 외부 편집기를 사용하여 패치를 관리하지 못하도록하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c553f5839a8296a42918c5ea6f6a2fcca19fa49" translate="yes" xml:space="preserve">
          <source>There are three main tools that can be used for this:</source>
          <target state="translated">이를 위해 사용할 수있는 세 가지 주요 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="86e24f426735724adb9ab7ea59c461905251e8e9" translate="yes" xml:space="preserve">
          <source>There are three ways to specify which refs to update on the remote end.</source>
          <target state="translated">원격 측에서 업데이트 할 참조를 지정하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5544b2d42620b4375dbc730230171fe04b9f972b" translate="yes" xml:space="preserve">
          <source>There are two different types of capabilities: normal capabilities, which can be used to convey information or alter the behavior of a request, and commands, which are the core actions that a client wants to perform (fetch, push, etc).</source>
          <target state="translated">두 가지 유형의 기능이 있습니다. 정보를 전달하거나 요청의 동작을 변경하는 데 사용할 수있는 일반 기능과 클라이언트가 수행하고자하는 핵심 작업 (페치, 푸시 등) 인 명령입니다.</target>
        </trans-unit>
        <trans-unit id="c2015c03c4c8786233c499c7815e06c17100a16b" translate="yes" xml:space="preserve">
          <source>There are two formats accepted for patch files:</source>
          <target state="translated">패치 파일에는 두 가지 형식이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9b5e9b84c7e0cf0cc62bfad7ffc7f5a42847bbc1" translate="yes" xml:space="preserve">
          <source>There are two kinds of fixes, discussed in the following subsections:</source>
          <target state="translated">다음 하위 섹션에서 설명하는 두 가지 수정 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="afe3df249e404830655fd820b0b8e96397ac9183" translate="yes" xml:space="preserve">
          <source>There are two main tools that can be used to include changes from one branch on another: &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; and &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt; 및 &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick [1]의&lt;/a&gt; 한 가지 브랜치 변경 사항을 포함하는 데 사용할 수있는 두 가지 주요 도구가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1432c9def859812f2dcccb492cbe2b422538cffb" translate="yes" xml:space="preserve">
          <source>There are two ways to specify which commits to operate on.</source>
          <target state="translated">작동 할 커밋을 지정하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="04a6eae6f43fc050171fa2270096884eaba0fee3" translate="yes" xml:space="preserve">
          <source>There is a difference between listing multiple &amp;lt;refspec&amp;gt; directly on &lt;em&gt;git pull&lt;/em&gt; command line and having multiple &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; entries in your configuration for a &amp;lt;repository&amp;gt; and running a &lt;em&gt;git pull&lt;/em&gt; command without any explicit &amp;lt;refspec&amp;gt; parameters. &amp;lt;refspec&amp;gt;s listed explicitly on the command line are always merged into the current branch after fetching. In other words, if you list more than one remote ref, &lt;em&gt;git pull&lt;/em&gt; will create an Octopus merge. On the other hand, if you do not list any explicit &amp;lt;refspec&amp;gt; parameter on the command line, &lt;em&gt;git pull&lt;/em&gt; will fetch all the &amp;lt;refspec&amp;gt;s it finds in the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; configuration and merge only the first &amp;lt;refspec&amp;gt; found into the current branch. This is because making an Octopus from remote refs is rarely done, while keeping track of multiple remote heads in one-go by fetching more than one is often useful.</source>
          <target state="translated">&lt;em&gt;git pull&lt;/em&gt; 명령 행 에 직접 여러 &amp;lt;refspec&amp;gt;을 나열 하고 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 에 대한 구성에 여러 remote. &amp;lt;repository&amp;gt; .fetch 항목을 갖는 것과 명시적인 &amp;lt;refspec&amp;gt; 매개 변수없이 &lt;em&gt;git pull&lt;/em&gt; 명령을 실행하는 것에는 차이가 있습니다. 명령 행에 명시 적으로 나열된 &amp;lt;refspec&amp;gt;은 페치 후에 항상 현재 분기로 병합됩니다. 즉, 하나 이상의 원격 참조를 나열하면 &lt;em&gt;git pull&lt;/em&gt; 이 Octopus 병합을 생성합니다. 반면에 명령 행에 명시 적 &amp;lt;refspec&amp;gt; 매개 변수를 나열하지 않으면 &lt;em&gt;git pull&lt;/em&gt; 은 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 에서 찾은 모든 &amp;lt;refspec&amp;gt;을 가져옵니다 . &amp;lt;repository&amp;gt; .fetch구성하고 현재 분기에있는 첫 번째 &amp;lt;refspec&amp;gt; 만 병합하십시오. 원격 참조에서 Octopus를 만드는 것은 거의 이루어지지 않기 때문에 여러 원격 헤드를 한 번에 가져 와서 여러 원격 헤드를 추적하는 것이 종종 유용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="08d27e369ae02f07111163548604defe0fd7ba02" translate="yes" xml:space="preserve">
          <source>There is a fourth official branch that is used slightly differently:</source>
          <target state="translated">약간 다르게 사용되는 네 번째 공식 지점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ab0818052937d36eff9b5a2767bc99b339b1151" translate="yes" xml:space="preserve">
          <source>There is a script in contrib/thunderbird-patch-inline which can help you include patches with Thunderbird in an easy way. To use it, do the steps above and then use the script as the external editor.</source>
          <target state="translated">contrib / thunderbird-patch-inline에는 Thunderbird 패치를 쉽게 포함시킬 수있는 스크립트가 있습니다. 이를 사용하려면 위 단계를 수행 한 다음 스크립트를 외부 편집기로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1232149fc68bcd969b013f8dcdb8f804dc24a0d6" translate="yes" xml:space="preserve">
          <source>There is a tradeoff of course: merges require a more careful branch management. The following subsections discuss the important points.</source>
          <target state="translated">물론 절충이 있습니다. 병합에는보다 신중한 지점 관리가 필요합니다. 다음 하위 섹션에서는 중요한 사항에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="dad64266cc32a47cdf74ec10317455f91f86159c" translate="yes" xml:space="preserve">
          <source>There is already a project called BBChop created by Ealdwulf Wuffinga on Github that does something like that using Bayesian Search Theory &lt;a href=&quot;#9&quot;&gt;[9]&lt;/a&gt;:</source>
          <target state="translated">같은 무언가를 Github에서에 일 둘프 Wuffinga 만든 BBChop라는 프로젝트가 이미 있다는 것을 사용하여 베이지안 검색 이론 &lt;a href=&quot;#9&quot;&gt;[9]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="72c8cb7314c2d9e687a4188f4607320887a3abaf" translate="yes" xml:space="preserve">
          <source>There is also a deprecated &lt;code&gt;[section.subsection]&lt;/code&gt; syntax. With this syntax, the subsection name is converted to lower-case and is also compared case sensitively. These subsection names follow the same restrictions as section names.</source>
          <target state="translated">더 이상 사용되지 않는 &lt;code&gt;[section.subsection]&lt;/code&gt; 구문도 있습니다. 이 구문을 사용하면 하위 섹션 이름이 소문자로 변환되고 대소 문자를 구분합니다. 이 하위 섹션 이름은 섹션 이름과 동일한 제한 사항을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="562a7aac41f0a6a2b8bd94c80ba1df49ae8c2861" translate="yes" xml:space="preserve">
          <source>There is also an alternate -z format recommended for machine parsing. In that format, the status field is the same, but some other things change. First, the &lt;code&gt;-&amp;gt;&lt;/code&gt; is omitted from rename entries and the field order is reversed (e.g &lt;code&gt;from -&amp;gt; to&lt;/code&gt; becomes &lt;code&gt;to from&lt;/code&gt;). Second, a NUL (ASCII 0) follows each filename, replacing space as a field separator and the terminating newline (but a space still separates the status field from the first filename). Third, filenames containing special characters are not specially formatted; no quoting or backslash-escaping is performed.</source>
          <target state="translated">기계 구문 분석에 권장되는 대체 -z 형식도 있습니다. 이 형식에서 상태 필드는 동일하지만 다른 사항이 변경됩니다. 먼저, &lt;code&gt;-&amp;gt;&lt;/code&gt; (예 바꾸기 항목 생략하고 필드 순서 반전 &lt;code&gt;from -&amp;gt; to&lt;/code&gt; 된다 &lt;code&gt;to from&lt;/code&gt; ). 둘째, NUL (ASCII 0)은 각 파일 이름 뒤에 공백을 필드 구분 기호와 종료 줄 바꿈으로 대체하지만 공백은 여전히 ​​상태 필드를 첫 번째 파일 이름과 분리합니다. 셋째, 특수 문자가 포함 된 파일 이름은 특별히 형식이 지정되지 않습니다. 인용 또는 백 슬래시 이스케이프가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23b53316aea0dd64f8f21ea0eae539235bf45a74" translate="yes" xml:space="preserve">
          <source>There is also an option to sort by versions, this can be done by using the fieldname &lt;code&gt;version:refname&lt;/code&gt; or its alias &lt;code&gt;v:refname&lt;/code&gt;.</source>
          <target state="translated">버전별로 정렬하는 옵션도 있습니다. fieldname &lt;code&gt;version:refname&lt;/code&gt; 또는 별명 &lt;code&gt;v:refname&lt;/code&gt; 을 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="490f0c7223e032436f3ed74187899d6766a21bb5" translate="yes" xml:space="preserve">
          <source>There is another common situation where you may encounter non-fast-forward rejection when you try to push, and it is possible even when you are pushing into a repository nobody else pushes into. After you push commit A yourself (in the first picture in this section), replace it with &quot;git commit --amend&quot; to produce commit B, and you try to push it out, because forgot that you have pushed A out already. In such a case, and only if you are certain that nobody in the meantime fetched your earlier commit A (and started building on top of it), you can run &quot;git push --force&quot; to overwrite it. In other words, &quot;git push --force&quot; is a method reserved for a case where you do mean to lose history.</source>
          <target state="translated">푸시하려고 할 때 빨리 감기를 거부 할 수있는 또 다른 일반적인 상황이 있으며, 아무도 밀어 넣지 않고 저장소로 밀어 넣을 때도 가능합니다. 커밋 A를 직접 푸시 한 후 (이 섹션의 첫 번째 그림에서) 커밋 B를 생성하기 위해 &quot;git commit --amend&quot;로 바꾸고, 이미 푸시 아웃 한 것을 잊었 기 때문에 밀어 내려고합니다. 이 경우, 그 동안 아무도 이전 커밋 A를 가져 오지 않고 그 위에 빌드를 시작한 사람이 아무도없는 경우에만 &quot;git push --force&quot;를 실행하여 덮어 쓸 수 있습니다. 즉, &quot;git push --force&quot;는 히스토리를 잃어 버리려는 경우를 위해 예약 된 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8a8fda27a5ab0014e2c03663c10e41e5858f14f1" translate="yes" xml:space="preserve">
          <source>There is another simplification mode available:</source>
          <target state="translated">There is another simplification mode available:</target>
        </trans-unit>
        <trans-unit id="76938def2c927fda8d1c815e17291d57380d4a8a" translate="yes" xml:space="preserve">
          <source>There is another tweak in the bisection algorithm that has not been described in the &quot;bisection algorithm&quot; above.</source>
          <target state="translated">이분법 알고리즘에는 위의 &quot;이분법 알고리즘&quot;에 설명되지 않은 또 다른 조정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cd697be600e420b39bb68cc6d967c4ceca70af4" translate="yes" xml:space="preserve">
          <source>There is no option for &lt;code&gt;git rm&lt;/code&gt; to remove from the index only the paths that have disappeared from the filesystem. However, depending on the use case, there are several ways that can be done.</source>
          <target state="translated">&lt;code&gt;git rm&lt;/code&gt; 이 파일 시스템에서 사라진 경로 만 인덱스에서 제거하는 옵션은 없습니다 . 그러나 사용 사례에 따라 수행 할 수있는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="60bcaa98facce6fa9b4916fcb4556840549eaf70" translate="yes" xml:space="preserve">
          <source>There is no other restriction on the replaced and replacement objects. Merge commits can be replaced by non-merge commits and vice versa.</source>
          <target state="translated">교체 및 교체 객체에 대한 다른 제한은 없습니다. 병합 커밋은 병합되지 않은 커밋으로 대체 할 수 있으며 그 반대도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5b920fe2651a1acef3f4de11b5f87d418bf37e32" translate="yes" xml:space="preserve">
          <source>There is now a new commit &lt;code&gt;e&lt;/code&gt;, but it is referenced only by &lt;code&gt;HEAD&lt;/code&gt;. We can of course add yet another commit in this state:</source>
          <target state="translated">이제 새로운 커밋 &lt;code&gt;e&lt;/code&gt; 가 있지만 &lt;code&gt;HEAD&lt;/code&gt; 에서만 참조됩니다 . 물론이 상태에서 또 다른 커밋을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e84a3494173a3e4e1765afc114a7bb8588db5e4e" translate="yes" xml:space="preserve">
          <source>There is one special case not mentioned above, which is treated differently. Normally, a merge results in a merge commit, with two parents, one pointing at each of the two lines of development that were merged.</source>
          <target state="translated">위에서 언급되지 않은 특별한 경우가 하나 있는데, 다르게 취급됩니다. 일반적으로 병합을 수행하면 병합 된 두 개의 개발 라인 각각을 가리키는 두 개의 부모가있는 병합 커밋이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9c233ac02212216497063926a3cd425b73c1b106" translate="yes" xml:space="preserve">
          <source>There may be other problems when using &lt;code&gt;git rev-list&lt;/code&gt; related to pending objects.</source>
          <target state="translated">보류중인 객체와 관련된 &lt;code&gt;git rev-list&lt;/code&gt; 를 사용할 때 다른 문제가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3cc97d3b58e95d007d294ed252208117b7ea36ad" translate="yes" xml:space="preserve">
          <source>There was a discussion at one point on the linux kernel mailing list of whether it was ok to always ask end user to bisect, and very good points were made to support the point of view that it is ok.</source>
          <target state="translated">리눅스 커널 메일 링리스트의 어느 시점에서 최종 사용자에게 항상 이등분을 요구하는 것이 좋았는지에 대한 토론이 있었고, 괜찮다는 관점을 지원하기 위해 매우 좋은 점이 만들어졌습니다.</target>
        </trans-unit>
        <trans-unit id="e31f2056d77b9761665b1e39804c963e7c7e3f73" translate="yes" xml:space="preserve">
          <source>Therefore if the refspec for the remote includes e.g. &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt;, or you manually run e.g. &lt;code&gt;git fetch
--prune &amp;lt;name&amp;gt; &quot;refs/tags/*:refs/tags/*&quot;&lt;/code&gt; it won&amp;rsquo;t be stale remote tracking branches that are deleted, but any local tag that doesn&amp;rsquo;t exist on the remote.</source>
          <target state="translated">따라서 원격에 대한 참조 사양에 &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; 가 포함 되어 있거나 수동으로 &lt;code&gt;git fetch --prune &amp;lt;name&amp;gt; &quot;refs/tags/*:refs/tags/*&quot;&lt;/code&gt; 하면 ' 삭제 된 오래된 원격 추적 분기는 아니지만 원격에 존재하지 않는 로컬 태그는 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="22e33781a4f63d74c967572b3d2d5742f6f5b3cf" translate="yes" xml:space="preserve">
          <source>These are applied in sequence. The set of filepairs &lt;code&gt;git diff-*&lt;/code&gt; commands find are used as the input to diffcore-break, and the output from diffcore-break is used as the input to the next transformation. The final result is then passed to the output routine and generates either diff-raw format (see Output format sections of the manual for &lt;code&gt;git diff-*&lt;/code&gt; commands) or diff-patch format.</source>
          <target state="translated">이들은 순차적으로 적용됩니다. &lt;code&gt;git diff-*&lt;/code&gt; diff- * 명령 find 파일 쌍 세트는 diffcore -break에 대한 입력으로 사용되며 diffcore-break의 출력은 다음 변환에 대한 입력으로 사용됩니다. 최종 결과는 출력 루틴으로 전달되고 diff-raw 형식 ( &lt;code&gt;git diff-*&lt;/code&gt; 명령 에 대한 매뉴얼의 출력 형식 섹션 참조 ) 또는 diff-patch 형식을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5e4c5d2d8cb413a7bc102a12d4b32266eb5dffbd" translate="yes" xml:space="preserve">
          <source>These are concerned with describing the specific Git command after the command line, config, and environment are inspected. e.g: &lt;code&gt;void trace2_cmd_name(const char *name)&lt;/code&gt;, &lt;code&gt;void trace2_cmd_mode(const char *mode)&lt;/code&gt;.</source>
          <target state="translated">이것들은 커맨드 라인, 구성 및 환경을 검사 한 후 특정 Git 명령을 설명하는 것과 관련이 있습니다. 예 : &lt;code&gt;void trace2_cmd_name(const char *name)&lt;/code&gt; , &lt;code&gt;void trace2_cmd_mode(const char *mode)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd918e1aed68e545e545890a5d457bd39124acbb" translate="yes" xml:space="preserve">
          <source>These are concerned with recording performance data over regions or spans of code. e.g: &lt;code&gt;void trace2_region_enter(const char *category, const char *label, const struct repository *repo)&lt;/code&gt;.</source>
          <target state="translated">이들은 영역 또는 코드 범위에 걸쳐 성능 데이터를 기록하는 것과 관련이 있습니다. 예 : &lt;code&gt;void trace2_region_enter(const char *category, const char *label, const struct repository *repo)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10ea7c6e4b3ea51596f6b19ba236a57b5e812041" translate="yes" xml:space="preserve">
          <source>These are concerned with the lifetime of the overall git process. e.g: &lt;code&gt;void trace2_initialize_clock()&lt;/code&gt;, &lt;code&gt;void trace2_initialize()&lt;/code&gt;, &lt;code&gt;int trace2_is_enabled()&lt;/code&gt;, &lt;code&gt;void trace2_cmd_start(int argc, const char **argv)&lt;/code&gt;.</source>
          <target state="translated">이것들은 전체 자식 프로세스의 수명과 관련이 있습니다. 예 : &lt;code&gt;void trace2_initialize_clock()&lt;/code&gt; , &lt;code&gt;void trace2_initialize()&lt;/code&gt; , &lt;code&gt;int trace2_is_enabled()&lt;/code&gt; , &lt;code&gt;void trace2_cmd_start(int argc, const char **argv)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3dce3473c941e3b3b27a31ac8449a2f1991a75d0" translate="yes" xml:space="preserve">
          <source>These are concerned with the various spawned child processes, including shell scripts, git commands, editors, pagers, and hooks.</source>
          <target state="translated">이들은 쉘 스크립트, git 명령, 편집기, 호출기 및 후크를 포함하여 다양한 생성 된 자식 프로세스와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="64d6caf87f558c78a882445d71ea9cd47be32d78" translate="yes" xml:space="preserve">
          <source>These are internal helper commands used by other commands; end users typically do not use them directly.</source>
          <target state="translated">이들은 다른 명령에서 사용되는 내부 도우미 명령입니다. 최종 사용자는 일반적으로 직접 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14e40973cf60a547a4fee511ff95c4f84a31a06f" translate="yes" xml:space="preserve">
          <source>These are only used with the &lt;code&gt;dcommit&lt;/code&gt; and &lt;code&gt;rebase&lt;/code&gt; commands.</source>
          <target state="translated">이들은 &lt;code&gt;dcommit&lt;/code&gt; 및 &lt;code&gt;rebase&lt;/code&gt; 명령 에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1f4226446a769c76931ca392e2a09f31777b3654" translate="yes" xml:space="preserve">
          <source>These are optional command-line options for init. Each of these flags can point to a relative repository path (--tags=project/tags) or a full url (--tags=https://foo.org/project/tags). You can specify more than one --tags and/or --branches options, in case your Subversion repository places tags or branches under multiple paths. The option --stdlayout is a shorthand way of setting trunk,tags,branches as the relative paths, which is the Subversion default. If any of the other options are given as well, they take precedence.</source>
          <target state="translated">이들은 init에 대한 선택적 명령 행 옵션입니다. 이러한 각 플래그는 상대 리포지토리 경로 (--tags = project / tags) 또는 전체 URL (--tags = https : //foo.org/project/tags)을 가리킬 수 있습니다. Subversion 저장소가 여러 경로 아래에 태그 또는 분기를 배치하는 경우 둘 이상의 --tags 및 / 또는 --branches 옵션을 지정할 수 있습니다. --stdlayout 옵션은 트렁크, 태그, 분기를 상대 경로로 설정하는 간단한 방법으로 Subversion 기본값입니다. 다른 옵션도 제공되면 우선권을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="ef89fe03d8c6b725e4e01a5ddca75169500d3912" translate="yes" xml:space="preserve">
          <source>These attributes affect how the contents stored in the repository are copied to the working tree files when commands such as &lt;code&gt;git switch&lt;/code&gt;, &lt;code&gt;git checkout&lt;/code&gt; and &lt;code&gt;git merge&lt;/code&gt; run. They also affect how Git stores the contents you prepare in the working tree in the repository upon &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">이러한 속성은 &lt;code&gt;git switch&lt;/code&gt; , &lt;code&gt;git checkout&lt;/code&gt; 및 &lt;code&gt;git merge&lt;/code&gt; 와 같은 명령이 실행될 때 리포지토리에 저장된 내용이 작업 트리 파일에 복사되는 방식에 영향을줍니다 . 또한 &lt;code&gt;git add&lt;/code&gt; 및 &lt;code&gt;git commit&lt;/code&gt; 시 작업 트리에서 준비한 내용을 저장소에 저장하는 방법에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="1e36f59cc4fba5296689c97860f8ef3c808cbf54" translate="yes" xml:space="preserve">
          <source>These can be easily kept up to date using &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;.</source>
          <target state="translated">이것들은 &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]을&lt;/a&gt; 사용하여 쉽게 최신 상태로 유지할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8f5a662d30248028e58618a9cb324b38272bbd8" translate="yes" xml:space="preserve">
          <source>These commands all compare two sets of things; what is compared differs:</source>
          <target state="translated">이 명령은 모두 두 가지 세트를 비교합니다. 비교되는 내용이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6e07bfec6529e0e8049d6a168dde51eb0ed55268" translate="yes" xml:space="preserve">
          <source>These commands are to interact with foreign SCM and with other people via patch over e-mail.</source>
          <target state="translated">이 명령은 전자 우편을 통해 외부 SCM 및 다른 사람들과 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="8e87e31fbdfcc66d2844293591fb44e9bb68be03" translate="yes" xml:space="preserve">
          <source>These config values are loaded from system, global, and local Git config, as available. If &lt;code&gt;git for-each-repo&lt;/code&gt; is run in a directory that is not a Git repository, then only the system and global config is used.</source>
          <target state="translated">이러한 구성 값은 사용 가능한 시스템, 전역 및 로컬 Git 구성에서로드됩니다. 경우 &lt;code&gt;git for-each-repo&lt;/code&gt; 만 시스템 및 글로벌 설정이 사용되는 Git 저장소 아닌 디렉토리에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="008c5282b165f202ade67dc870d3522a81a841bd" translate="yes" xml:space="preserve">
          <source>These configuration variables control &lt;code&gt;internal&lt;/code&gt; gitweb behavior.</source>
          <target state="translated">이 구성 변수는 &lt;code&gt;internal&lt;/code&gt; gitweb 동작을 제어 합니다.</target>
        </trans-unit>
        <trans-unit id="94d243826a65ff43f06f691e3b2f877746c8e3a7" translate="yes" xml:space="preserve">
          <source>These configurations enable two things. First, each unix user (&lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt;) of the server will be able to browse through gitweb Git repositories found in &lt;code&gt;~/public_git/&lt;/code&gt; with the following url:</source>
          <target state="translated">이러한 구성은 두 가지를 가능하게합니다. 먼저 서버의 각 유닉스 사용자 ( &lt;code&gt;&amp;lt;user&amp;gt;&lt;/code&gt; )는 &lt;code&gt;~/public_git/&lt;/code&gt; 에있는 gitweb Git 저장소를 다음 URL 로 찾아 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c188c162ef90ed4e72b2204b53fd7bbdf63ed82" translate="yes" xml:space="preserve">
          <source>These environment variables apply to &lt;code&gt;all&lt;/code&gt; core Git commands. Nb: it is worth noting that they may be used/overridden by SCMS sitting above Git so take care if using a foreign front-end.</source>
          <target state="translated">이러한 환경 변수는 &lt;code&gt;all&lt;/code&gt; 핵심 Git 명령에 적용됩니다 . Nb : Git 위에있는 SCMS에 의해 사용 / 재정의 될 수 있으므로 외국 프론트 엔드를 사용하는 경우주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="e4a9928c908043039dae5cc89a184941db222aba" translate="yes" xml:space="preserve">
          <source>These exclude patterns come from these places, in order:</source>
          <target state="translated">이러한 제외 패턴은 다음 위치에서 순서대로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="75ad982aca6a7add80092ae27820348741497d7e" translate="yes" xml:space="preserve">
          <source>These flag are passed to the &lt;code&gt;git apply&lt;/code&gt; program (see &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;) that applies the patch.</source>
          <target state="translated">이 플래그는 패치를 적용하는 &lt;code&gt;git apply&lt;/code&gt; 프로그램 ( &lt;a href=&quot;git-apply&quot;&gt;git-apply [1]&lt;/a&gt; 참조)으로 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="a66ecfa5cef3d43b11b6332452dde3bc34998a82" translate="yes" xml:space="preserve">
          <source>These flags are passed to &lt;code&gt;git am&lt;/code&gt; to easily change the dates of the rebased commits (see &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;).</source>
          <target state="translated">이 플래그는 리베이스 된 커밋의 날짜를 쉽게 변경하기 위해 &lt;code&gt;git am&lt;/code&gt; 에 전달됩니다 ( &lt;a href=&quot;git-am&quot;&gt;git-am [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6f1d3498209d5426cb1c8295c9947466ac12cab4" translate="yes" xml:space="preserve">
          <source>These flags are passed to the &lt;code&gt;git apply&lt;/code&gt; (see &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;) program that applies the patch.</source>
          <target state="translated">이 플래그는 패치를 적용하는 &lt;code&gt;git apply&lt;/code&gt; ( &lt;a href=&quot;git-apply&quot;&gt;git-apply [1] 참조&lt;/a&gt; ) 프로그램으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="17c5d825c714d7f669df648adc8ffa3b9865aa3a" translate="yes" xml:space="preserve">
          <source>These forms reset the index entries for all paths that match the &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; to their state at &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;. (It does not affect the working tree or the current branch.)</source>
          <target state="translated">이 형식은 &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; 과 일치하는 모든 경로의 인덱스 항목을 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 의 상태로 재설정합니다 . 작업 트리 또는 현재 분기에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84dfe82e69639d7dd0490e18b4061edc5e5f61bb" translate="yes" xml:space="preserve">
          <source>These general best practices are very helpful if you bisect often.</source>
          <target state="translated">이러한 일반적인 모범 사례는 자주 이등분하는 경우 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="db63350c8a27af092cfd256119dcf34d87e7125f" translate="yes" xml:space="preserve">
          <source>These instructions use the &lt;code&gt;git-cvsimport&lt;/code&gt; script which ships with git, but other importers may provide better results. See the note in &lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport[1]&lt;/a&gt; for other options.</source>
          <target state="translated">이 지침에서는 &lt;code&gt;git-cvsimport&lt;/code&gt; 과 함께 제공되는 git-cvsimport 스크립트를 사용 하지만 다른 수입 업체가 더 나은 결과를 제공 할 수 있습니다. 다른 옵션에 대해서는 &lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport [1]&lt;/a&gt; 의 참고 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4de4cd9ec9920076e498bf4f8c01b7cc0e7335b0" translate="yes" xml:space="preserve">
          <source>These messages are concerned with Git thread usage.</source>
          <target state="translated">이 메시지는 Git 스레드 사용과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8e5bd243ffdab655773f15dbcfc0554b819902f" translate="yes" xml:space="preserve">
          <source>These options are deprecated. Use the above --notes/--no-notes options instead.</source>
          <target state="translated">이 옵션은 더 이상 사용되지 않습니다. 위의 --notes /-no-notes 옵션을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="894173daf027c82b1254f620d2cbbddacd04b7fd" translate="yes" xml:space="preserve">
          <source>These options are ignored for historical reasons.</source>
          <target state="translated">이러한 옵션은 역사적 이유로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0608f735748e7710136ac2ca4b1a8fc7f8d0f8a8" translate="yes" xml:space="preserve">
          <source>These options are mostly targeted for packing of Git repositories.</source>
          <target state="translated">이 옵션은 대부분 Git 리포지토리 패킹을 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="44fc7c2eb5b5d3f683db2d8973767b7defab9c76" translate="yes" xml:space="preserve">
          <source>These options are passed to &lt;a href=&quot;git-send-pack&quot;&gt;git-send-pack[1]&lt;/a&gt;. A thin transfer significantly reduces the amount of sent data when the sender and receiver share many of the same objects in common. The default is &lt;code&gt;--thin&lt;/code&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;git-send-pack&quot;&gt;git-send-pack [1]&lt;/a&gt; 로 전달됩니다 . 발신자와 수신자가 동일한 많은 객체를 공통으로 공유 할 때 씬 전송은 전송 된 데이터의 양을 크게 줄입니다. 기본값은 &lt;code&gt;--thin&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="38ddfaeebf99ab2e211259f05e2350cca6be519d" translate="yes" xml:space="preserve">
          <source>These options are primarily useful when converting a repository from one hash algorithm to another; without them, fast-import will fail if it encounters a submodule because it has no way of writing the object ID into the new hash algorithm.</source>
          <target state="translated">These options are primarily useful when converting a repository from one hash algorithm to another; without them, fast-import will fail if it encounters a submodule because it has no way of writing the object ID into the new hash algorithm.</target>
        </trans-unit>
        <trans-unit id="0c86ff6978b6c3146e6796c4f36abf160da0176d" translate="yes" xml:space="preserve">
          <source>These options can be used in an initial &lt;code&gt;clone&lt;/code&gt;, along with the &lt;code&gt;sync&lt;/code&gt; options described above.</source>
          <target state="translated">이러한 옵션은 위에서 설명한 &lt;code&gt;sync&lt;/code&gt; 옵션 과 함께 초기 &lt;code&gt;clone&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ade32a888d52a4ba127b2e5cb51121d4b067e67" translate="yes" xml:space="preserve">
          <source>These options can be used in the initial &lt;code&gt;clone&lt;/code&gt; as well as in subsequent &lt;code&gt;sync&lt;/code&gt; operations.</source>
          <target state="translated">이 옵션은 초기 &lt;code&gt;clone&lt;/code&gt; 및 후속 &lt;code&gt;sync&lt;/code&gt; 작업 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f45787718e6c314237aec0cf2c5e63156df92c4" translate="yes" xml:space="preserve">
          <source>These options can be used to modify &lt;code&gt;git p4 rebase&lt;/code&gt; behavior.</source>
          <target state="translated">이 옵션은 &lt;code&gt;git p4 rebase&lt;/code&gt; 동작 을 수정하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="046bf3cadb648529c8cbf517d3ba66246fc697fc" translate="yes" xml:space="preserve">
          <source>These options can be used to modify &lt;code&gt;git p4 submit&lt;/code&gt; behavior.</source>
          <target state="translated">이 옵션은 &lt;code&gt;git p4 submit&lt;/code&gt; 동작 을 수정하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5bf9264c3d2f29d27aed45b38db366aee6362601" translate="yes" xml:space="preserve">
          <source>These options control layout (defaults to &lt;code&gt;column&lt;/code&gt;). Setting any of these implies &lt;code&gt;always&lt;/code&gt; if none of &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;, or &lt;code&gt;auto&lt;/code&gt; are specified.</source>
          <target state="translated">이 옵션은 레이아웃을 제어합니다 (기본값은 &lt;code&gt;column&lt;/code&gt; ). 이들의 설정을 의미 &lt;code&gt;always&lt;/code&gt; 하나도 경우 &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;never&lt;/code&gt; , 또는 &lt;code&gt;auto&lt;/code&gt; 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="510a1cbefb424a60db8479a49dd55a0966d6d945" translate="yes" xml:space="preserve">
          <source>These options control when the feature should be enabled (defaults to &lt;code&gt;never&lt;/code&gt;):</source>
          <target state="translated">이 옵션은 기능을 활성화해야하는시기를 제어합니다 (기본값은 &lt;code&gt;never&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="931e215644554fa9404627a014bfd3cf51399ea5" translate="yes" xml:space="preserve">
          <source>These options take effect whatever the value of the &lt;code&gt;core.splitIndex&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.</source>
          <target state="translated">이 옵션은 &lt;code&gt;core.splitIndex&lt;/code&gt; 구성 변수 의 값에 관계없이 적용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). 그러나 구성된 값이 다음에 인덱스를 읽을 때 적용되고 옵션의 의도 된 효과가 제거되므로 구성된 값에 대한 변경이 발생하면 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="932e8c22c29966222600cac9510425979eeabd1c" translate="yes" xml:space="preserve">
          <source>These options take effect whatever the value of the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.</source>
          <target state="translated">이러한 옵션은 &lt;code&gt;core.untrackedCache&lt;/code&gt; 구성 변수 의 값에 관계없이 적용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). 그러나 구성된 값이 다음에 인덱스를 읽을 때 적용되고 옵션의 의도 된 효과가 제거되므로 구성된 값에 대한 변경이 발생하면 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ff7024be4fc3bd9a63ff1aab42e5c2f33080a5ad" translate="yes" xml:space="preserve">
          <source>These parameters can also be set individually with &lt;code&gt;--stat-width=&amp;lt;width&amp;gt;&lt;/code&gt;, &lt;code&gt;--stat-name-width=&amp;lt;name-width&amp;gt;&lt;/code&gt; and &lt;code&gt;--stat-count=&amp;lt;count&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이러한 매개 변수는 &lt;code&gt;--stat-width=&amp;lt;width&amp;gt;&lt;/code&gt; , &lt;code&gt;--stat-name-width=&amp;lt;name-width&amp;gt;&lt;/code&gt; 및 &lt;code&gt;--stat-count=&amp;lt;count&amp;gt;&lt;/code&gt; 로 개별적으로 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25d97f197e2ad468ea791c831ca2e71054c4e207" translate="yes" xml:space="preserve">
          <source>These remote-tracking references can be deleted as a one-off with either of:</source>
          <target state="translated">이러한 원격 추적 참조는 다음 중 하나를 사용하여 일회용으로 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4994737bcfd88cfa54486bc85e99d5152416b798" translate="yes" xml:space="preserve">
          <source>These rules make it easy for shell script based tools to parse reference names, pathname expansion by the shell when a reference name is used unquoted (by mistake), and also avoid ambiguities in certain reference name expressions (see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;):</source>
          <target state="translated">이 규칙을 사용하면 쉘 스크립트 기반 도구가 참조 이름을 쉽게 구문 분석하고 참조 이름을 인용 부호없이 사용할 때 쉘에 의한 경로 이름 확장을 쉽게 할 수 있으며 특정 참조 이름 표현식에서 모호성을 피할 수 있습니다 ( &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d2d3b8bc5c27c38dddb2f7c9e54b52668c820483" translate="yes" xml:space="preserve">
          <source>These services can be enabled/disabled using the per-repository configuration file:</source>
          <target state="translated">이러한 서비스는 저장소 별 구성 파일을 사용하여 활성화 / 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11be9ffec744e4c727f505822229118ed50ca097" translate="yes" xml:space="preserve">
          <source>These services can be globally enabled/disabled using the command-line options of this command. If finer-grained control is desired (e.g. to allow &lt;code&gt;git archive&lt;/code&gt; to be run against only in a few selected repositories the daemon serves), the per-repository configuration file can be used to enable or disable them.</source>
          <target state="translated">이 서비스는이 명령의 명령 줄 옵션을 사용하여 전체적으로 활성화 / 비활성화 할 수 있습니다. 보다 세부적인 제어가 필요한 경우 (예 : 데몬이 제공하는 선택된 일부 리포지토리에서만 &lt;code&gt;git archive&lt;/code&gt; 를 실행할 수 있도록 ) 리포지토리 당 구성 파일을 사용하여 활성화 또는 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70e4323eda62161a4a47cb9a1d65be89828fd66d" translate="yes" xml:space="preserve">
          <source>These settings help tools pick the right format for output such as patches and result in files being checked out in the appropriate line ending for the platform.</source>
          <target state="translated">이러한 설정은 도구가 패치와 같은 출력에 적합한 형식을 선택하는 데 도움이되며 그 결과 플랫폼에 대한 적절한 행 끝에서 파일이 체크 아웃됩니다.</target>
        </trans-unit>
        <trans-unit id="6e7a1043f71fa1813c0b5e398e97710f483944d9" translate="yes" xml:space="preserve">
          <source>These things may exist in a Git repository.</source>
          <target state="translated">이러한 것들이 Git 저장소에 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5c7f688db050c92cfc9bb2aa9d676e52849ec7b" translate="yes" xml:space="preserve">
          <source>These three branches all forked from a common commit, [master], whose commit message is &quot;Add 'git show-branch'&quot;. The &quot;fixes&quot; branch adds one commit &quot;Introduce &quot;reset type&quot; flag to &quot;git reset&quot;&quot;. The &quot;mhf&quot; branch adds many other commits. The current branch is &quot;master&quot;.</source>
          <target state="translated">이 세 가지 분기는 모두 커밋 메시지가 &quot;Add 'git show-branch'&quot;인 공통 커밋 [master]에서 분기되었습니다. &quot;fixes&quot;브랜치는 하나의 커밋 &quot;&quot;reset type &quot;플래그를&quot;git reset &quot;에 추가합니다.&quot; &quot;mhf&quot;브랜치는 다른 많은 커밋을 추가합니다. 현재 지점은 &quot;마스터&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="c6204a9318b7a0526e46b8696b2eb378d52ecf11" translate="yes" xml:space="preserve">
          <source>These two filters behave differently, and by default, a filter is taken as the former, massaging the contents into more convenient shape. A missing filter driver definition in the config, or a filter driver that exits with a non-zero status, is not an error but makes the filter a no-op passthru.</source>
          <target state="translated">이 두 필터는 다르게 동작하며 기본적으로 필터는 전자로 사용되어 내용을보다 편리한 모양으로 마사지합니다. 구성에서 누락 된 필터 드라이버 정의 또는 0이 아닌 상태로 종료되는 필터 드라이버는 오류가 아니라 필터를 무 작동 패스 스루로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e20e46dc24b79b5218925e423850545226b0898e" translate="yes" xml:space="preserve">
          <source>These two options affect how the objects contained in the pack are stored using delta compression. The objects are first internally sorted by type, size and optionally names and compared against the other objects within --window to see if using delta compression saves space. --depth limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object.</source>
          <target state="translated">이 두 옵션은 팩에 포함 된 오브젝트가 델타 압축을 사용하여 저장되는 방법에 영향을줍니다. 객체는 유형, 크기 및 선택적으로 이름별로 내부적으로 정렬되어 델타 압축을 사용하여 공간이 절약되는지 확인하기 위해 --window 내의 다른 객체와 비교됩니다. --depth는 최대 델타 깊이를 제한합니다. 델타 데이터를 필요한 오브젝트에 도달하기 위해 여러 번 적용해야하기 때문에 너무 깊게 만들면 언 패커 측 성능에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="de212a952b72f4cd05af023bbd056fa8307c4a9f" translate="yes" xml:space="preserve">
          <source>These two options affect how the objects contained in the pack are stored using delta compression. The objects are first internally sorted by type, size and optionally names and compared against the other objects within &lt;code&gt;--window&lt;/code&gt; to see if using delta compression saves space. &lt;code&gt;--depth&lt;/code&gt; limits the maximum delta depth; making it too deep affects the performance on the unpacker side, because delta data needs to be applied that many times to get to the necessary object.</source>
          <target state="translated">이 두 옵션은 팩에 포함 된 오브젝트가 델타 압축을 사용하여 저장되는 방법에 영향을줍니다. 객체는 유형, 크기 및 선택적으로 이름별로 내부적으로 정렬되어 델타 압축을 사용하여 공간이 절약되는지 확인하기 위해 &lt;code&gt;--window&lt;/code&gt; 내의 다른 객체와 비교 됩니다. &lt;code&gt;--depth&lt;/code&gt; 는 최대 델타 깊이를 제한합니다. 델타 데이터를 필요한 오브젝트에 도달하기 위해 여러 번 적용해야하기 때문에 너무 깊게하면 언 패커 측 성능에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="6a0bfaec1ca5ad5a0f6710f22f7b4b78eecfef67" translate="yes" xml:space="preserve">
          <source>These two syntaxes are mostly equivalent, except the former implies --local option.</source>
          <target state="translated">이 두 구문은 전자가 --local 옵션을 암시하는 것을 제외하고는 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9270307e15adf00d482cdebd8e068750f310bc87" translate="yes" xml:space="preserve">
          <source>These two syntaxes are mostly equivalent, except when cloning, when the former implies --local option. See &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; for details.</source>
          <target state="translated">이 두 구문은 복제 할 때를 제외하고 전자가 --local 옵션을 암시 할 때를 제외하고는 거의 동일합니다. 자세한 내용은 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="469e074d32a553c54f69af6603803ffbfd2e6dda" translate="yes" xml:space="preserve">
          <source>These types of entries are generally created as a result of using &lt;code&gt;git
commit --amend&lt;/code&gt; or &lt;code&gt;git rebase&lt;/code&gt; and are the commits prior to the amend or rebase occurring. Since these changes are not part of the current project most users will want to expire them sooner, which is why the default is more aggressive than &lt;code&gt;gc.reflogExpire&lt;/code&gt;.</source>
          <target state="translated">이러한 유형의 항목은 일반적으로 &lt;code&gt;git commit --amend&lt;/code&gt; 또는 &lt;code&gt;git rebase&lt;/code&gt; 를 사용한 결과로 작성되며 수정 또는 rebase가 발생하기 전에 커밋됩니다. 이러한 변경 사항은 현재 프로젝트의 일부가 아니므로 대부분의 사용자는 더 빨리 만료하려고하므로 기본값이 &lt;code&gt;gc.reflogExpire&lt;/code&gt; 보다 더 공격적인 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="99a10a0726ee032ba80815c05eceb6d5a6ab2aa8" translate="yes" xml:space="preserve">
          <source>These variables control various optional help messages designed to aid new users. All &lt;code&gt;advice.*&lt;/code&gt; variables default to &lt;code&gt;true&lt;/code&gt;, and you can tell Git that you do not need help by setting these to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">이 변수는 새로운 사용자를 돕기 위해 설계된 다양한 선택적 도움말 메시지를 제어합니다. 모든 &lt;code&gt;advice.*&lt;/code&gt; 변수는 기본적으로 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있으며, Git에게 이것들을 &lt;code&gt;false&lt;/code&gt; 로 설정하면 도움이 필요 없다고 말할 수있다 .</target>
        </trans-unit>
        <trans-unit id="289bbff1e27f0cf157d5208bbfcb9f369ecc1504" translate="yes" xml:space="preserve">
          <source>These variables obviate the need for command-line options in some circumstances, allowing easier restricted usage through git-shell.</source>
          <target state="translated">이러한 변수는 일부 상황에서 명령 줄 옵션이 필요하지 않으므로 git-shell을 통해 사용을보다 쉽게 ​​제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48d5c4b33cae3d35014b5a5e266ea897c2a18c9f" translate="yes" xml:space="preserve">
          <source>These will display all commits which exist only on HEAD or on MERGE_HEAD, and which touch an unmerged file.</source>
          <target state="translated">HEAD 또는 MERGE_HEAD에만 존재하며 병합되지 않은 파일을 건 드리는 모든 커밋이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e9ab0d9bdf3f35b7d6ece2d3bc65f4fbb38bad38" translate="yes" xml:space="preserve">
          <source>They are both passed directly to &lt;code&gt;git diff-tree&lt;/code&gt;; see &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree[1]&lt;/a&gt; for more information.</source>
          <target state="translated">둘 다 &lt;code&gt;git diff-tree&lt;/code&gt; 로 직접 전달됩니다 . 자세한 내용은 &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="afa16f632fa562fed5a34ad41431101aacb568d7" translate="yes" xml:space="preserve">
          <source>They can include slash &lt;code&gt;/&lt;/code&gt; for hierarchical (directory) grouping, but no slash-separated component can begin with a dot &lt;code&gt;.&lt;/code&gt; or end with the sequence &lt;code&gt;.lock&lt;/code&gt;.</source>
          <target state="translated">슬래시 &lt;code&gt;/&lt;/code&gt; 계층 적 (디렉토리) 그룹화를 포함 할 수 있지만 슬래시로 분리 된 구성 요소는 dot로 시작할 수 없습니다 &lt;code&gt;.&lt;/code&gt; 또는 시퀀스 &lt;code&gt;.lock&lt;/code&gt; 으로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="48a933f433abac80f2e0e41b240081f7a399893c" translate="yes" xml:space="preserve">
          <source>They cannot be the single character &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">단일 문자 &lt;code&gt;@&lt;/code&gt; 일 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c798a840110b095cd0c31cb10cad16c17f5292dd" translate="yes" xml:space="preserve">
          <source>They cannot begin or end with a slash &lt;code&gt;/&lt;/code&gt; or contain multiple consecutive slashes (see the &lt;code&gt;--normalize&lt;/code&gt; option below for an exception to this rule)</source>
          <target state="translated">그들은 시작이나 끝 슬래시로 수 &lt;code&gt;/&lt;/code&gt; 또는 여러 개의 연속 슬래시를 포함합니다 (참조 &lt;code&gt;--normalize&lt;/code&gt; 이 규칙에 예외 아래 옵션)</target>
        </trans-unit>
        <trans-unit id="794c847c2b033448497ba9e6f46f59b7325ccd69" translate="yes" xml:space="preserve">
          <source>They cannot contain a &lt;code&gt;\&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;\&lt;/code&gt; 를 포함 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c4cf89d0a711867dbdfa498e7e6b80fb04c020f3" translate="yes" xml:space="preserve">
          <source>They cannot contain a sequence &lt;code&gt;@{&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@{&lt;/code&gt; 시퀀스를 포함 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c781dcfcbfa7c545717cc72f3f25ac7fba039fd7" translate="yes" xml:space="preserve">
          <source>They cannot end with a dot &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">그들은 점으로 끝날 수 없습니다 &lt;code&gt;.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdf3c698f8591838633d63d5550c41009f5d53bb" translate="yes" xml:space="preserve">
          <source>They cannot have ASCII control characters (i.e. bytes whose values are lower than \040, or \177 &lt;code&gt;DEL&lt;/code&gt;), space, tilde &lt;code&gt;~&lt;/code&gt;, caret &lt;code&gt;^&lt;/code&gt;, or colon &lt;code&gt;:&lt;/code&gt; anywhere.</source>
          <target state="translated">ASCII 제어 문자 (예 : 값이 \ 040 또는 \ 177 &lt;code&gt;DEL&lt;/code&gt; 보다 작은 바이트 ), 공백, 틸드 &lt;code&gt;~&lt;/code&gt; , 캐럿 &lt;code&gt;^&lt;/code&gt; 또는 콜론 &lt;code&gt;:&lt;/code&gt; 어디서나 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9fa9a35ba99f055f59e5fb0fc3903845af8141d1" translate="yes" xml:space="preserve">
          <source>They cannot have question-mark &lt;code&gt;?&lt;/code&gt;, asterisk &lt;code&gt;*&lt;/code&gt;, or open bracket &lt;code&gt;[&lt;/code&gt; anywhere. See the &lt;code&gt;--refspec-pattern&lt;/code&gt; option below for an exception to this rule.</source>
          <target state="translated">그들은 물음표를 가질 수 &lt;code&gt;?&lt;/code&gt; , 별표 &lt;code&gt;*&lt;/code&gt; 또는 열린 괄호 &lt;code&gt;[&lt;/code&gt; 어디서나 사용 가능합니다. 이 규칙에 대한 예외는 아래 의 &lt;code&gt;--refspec-pattern&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="07233de88d34b821d099ea14e09099281360fa3d" translate="yes" xml:space="preserve">
          <source>They cannot have two consecutive dots &lt;code&gt;..&lt;/code&gt; anywhere.</source>
          <target state="translated">그들은 두 개의 연속 된 점을 가질 수 없습니다 &lt;code&gt;..&lt;/code&gt; 어디.</target>
        </trans-unit>
        <trans-unit id="08cc7b3818b658e36c5e9a0a0fcefabb2c9bd5ce" translate="yes" xml:space="preserve">
          <source>They must contain at least one &lt;code&gt;/&lt;/code&gt;. This enforces the presence of a category like &lt;code&gt;heads/&lt;/code&gt;, &lt;code&gt;tags/&lt;/code&gt; etc. but the actual names are not restricted. If the &lt;code&gt;--allow-onelevel&lt;/code&gt; option is used, this rule is waived.</source>
          <target state="translated">그들은 적어도 하나의 메시지 있어야합니다 &lt;code&gt;/&lt;/code&gt; 을 . 이것은 &lt;code&gt;heads/&lt;/code&gt; , &lt;code&gt;tags/&lt;/code&gt; 등과 같은 카테고리의 존재를 강제 하지만 실제 이름은 제한되지 않습니다. 는 IF &lt;code&gt;--allow-onelevel&lt;/code&gt; 은 옵션을 사용,이 규칙은 면제됩니다.</target>
        </trans-unit>
        <trans-unit id="9c66e1086c1b783565f285e9f8d345796e4a920b" translate="yes" xml:space="preserve">
          <source>Things get more complicated if the &lt;code&gt;subsystem&lt;/code&gt; changes do not exactly correspond to the ones before the rebase.</source>
          <target state="translated">&lt;code&gt;subsystem&lt;/code&gt; 변경 사항이 리베이스 이전의 서브 시스템 변경 사항과 정확히 일치하지 않으면 상황이 더 복잡해집니다 .</target>
        </trans-unit>
        <trans-unit id="877bd5e347693a4c90610529b809f198ae203a8a" translate="yes" xml:space="preserve">
          <source>Think about how to create a clear chapter dependency graph that will allow people to get to important topics without necessarily reading everything in between.</source>
          <target state="translated">사람들이 반드시 사이에있는 모든 것을 읽지 않고도 중요한 주제에 도달 할 수있는 명확한 장 종속성 그래프를 작성하는 방법에 대해 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="5f03012af2a22f62503c31e1e064eb23ddd2be46" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;key&lt;/code&gt; will be used instead of &amp;lt;token&amp;gt; in the trailer. At the end of this key, a separator can appear and then some space characters. By default the only valid separator is &lt;code&gt;:&lt;/code&gt;, but this can be changed using the &lt;code&gt;trailer.separators&lt;/code&gt; config variable.</source>
          <target state="translated">이 &lt;code&gt;key&lt;/code&gt; 는 예고편에서 &amp;lt;토큰&amp;gt; 대신 사용됩니다. 이 키의 끝에 구분 기호가 나타난 다음 일부 공백 문자가 나타날 수 있습니다. 기본적으로 유일하게 유효한 구분자는 &lt;code&gt;:&lt;/code&gt; 이지만 &lt;code&gt;trailer.separators&lt;/code&gt; config 변수를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ed9ef222233001104259cd6ab7e0ea2e028dedb" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;merge&lt;/code&gt; can also be done by &lt;code&gt;pulling from her own remote-tracking branch&lt;/code&gt;, like this:</source>
          <target state="translated">이 &lt;code&gt;merge&lt;/code&gt; 은 다음과 같이 &lt;code&gt;pulling from her own remote-tracking branch&lt;/code&gt; 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0007248c88629a35b9fa8e1cf4c8fdf299191526" translate="yes" xml:space="preserve">
          <source>This accepts all options that &lt;code&gt;git svn fetch&lt;/code&gt; and &lt;code&gt;git rebase&lt;/code&gt; accept. However, &lt;code&gt;--fetch-all&lt;/code&gt; only fetches from the current [svn-remote], and not all [svn-remote] definitions.</source>
          <target state="translated">이것은 &lt;code&gt;git svn fetch&lt;/code&gt; 및 &lt;code&gt;git rebase&lt;/code&gt; 가 허용 하는 모든 옵션을 허용합니다. 그러나 &lt;code&gt;--fetch-all&lt;/code&gt; 은 모든 [svn-remote] 정의가 아니라 현재 [svn-remote]에서만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c118365ba0290d763b2d4e635fbfbb09d23e73e6" translate="yes" xml:space="preserve">
          <source>This action is disabled by default for performance reasons.</source>
          <target state="translated">이 작업은 성능상의 이유로 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="692de83ae64c152ace96a6b22c40c6c7b5256f5f" translate="yes" xml:space="preserve">
          <source>This adds a link titled &quot;graphiclog&quot; after the &quot;summary&quot; link, leading to &lt;code&gt;git-browser&lt;/code&gt; script, passing &lt;code&gt;r=&amp;lt;project&amp;gt;&lt;/code&gt; as a query parameter.</source>
          <target state="translated">&quot;summary&quot;링크 뒤에 &quot;graphiclog&quot;라는 제목의 링크가 추가되어 &lt;code&gt;git-browser&lt;/code&gt; 스크립트가 생성되어 &lt;code&gt;r=&amp;lt;project&amp;gt;&lt;/code&gt; 를 쿼리 매개 변수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="9647e1f610a9d28b74cedc3ffa625f5d98628ec8" translate="yes" xml:space="preserve">
          <source>This algorithm extends the patience algorithm to &quot;support low-occurrence common elements&quot;.</source>
          <target state="translated">이 알고리즘은 인내심 알고리즘을 &quot;낮은 발생 공통 요소 지원&quot;으로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="5f9e4d22cfa1bc9f924abb0f51a443db2655b318" translate="yes" xml:space="preserve">
          <source>This allows &lt;code&gt;git svn&lt;/code&gt; to re-map repository URLs and UUIDs from mirrors created using SVN::Mirror (or svk) for metadata.</source>
          <target state="translated">이를 통해 &lt;code&gt;git svn&lt;/code&gt; 은 메타 데이터를 위해 SVN :: Mirror (또는 svk)를 사용하여 생성 된 미러에서 리포지토리 URL과 UUID를 다시 매핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb552885bcd7df779f362e35a229c9d935657c60" translate="yes" xml:space="preserve">
          <source>This allows one to specify a Perl regular expression that will cause skipping of all matching paths from checkout from SVN. The &lt;code&gt;--ignore-paths&lt;/code&gt; option should match for every &lt;code&gt;fetch&lt;/code&gt; (including automatic fetches due to &lt;code&gt;clone&lt;/code&gt;, &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, etc) on a given repository.</source>
          <target state="translated">이것은 SVN의 체크 아웃에서 모든 일치하는 경로를 건너 뛰게하는 Perl 정규식을 지정할 수있게합니다. &lt;code&gt;--ignore-paths&lt;/code&gt; 옵션은 모든에 대해 일치해야합니다 &lt;code&gt;fetch&lt;/code&gt; (로 인해 포함하여 자동 인출 &lt;code&gt;clone&lt;/code&gt; , &lt;code&gt;dcommit&lt;/code&gt; , &lt;code&gt;rebase&lt;/code&gt; 주어진 저장소에, 등).</target>
        </trans-unit>
        <trans-unit id="bf5d12ceb1111e8b06bd58f3985472091a1cae12" translate="yes" xml:space="preserve">
          <source>This allows one to specify a Perl regular expression that will cause the inclusion of only matching paths from checkout from SVN. The &lt;code&gt;--include-paths&lt;/code&gt; option should match for every &lt;code&gt;fetch&lt;/code&gt; (including automatic fetches due to &lt;code&gt;clone&lt;/code&gt;, &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, etc) on a given repository. &lt;code&gt;--ignore-paths&lt;/code&gt; takes precedence over &lt;code&gt;--include-paths&lt;/code&gt;.</source>
          <target state="translated">이를 통해 SVN에서 체크 아웃 할 때 일치하는 경로 만 포함시키는 Perl 정규식을 지정할 수 있습니다. &lt;code&gt;--include-paths&lt;/code&gt; 옵션은 모든에 대해 일치해야합니다 &lt;code&gt;fetch&lt;/code&gt; (로 인해 포함하여 자동 인출 &lt;code&gt;clone&lt;/code&gt; , &lt;code&gt;dcommit&lt;/code&gt; , &lt;code&gt;rebase&lt;/code&gt; 주어진 저장소에, 등). &lt;code&gt;--ignore-paths&lt;/code&gt; 가 &lt;code&gt;--include-paths&lt;/code&gt; 보다 우선 합니다 .</target>
        </trans-unit>
        <trans-unit id="c68f089f9144bc4bdc1d710532bfa75a569d11ed" translate="yes" xml:space="preserve">
          <source>This allows one to specify a prefix which is prepended to the names of remotes if trunk/branches/tags are specified. The prefix does not automatically include a trailing slash, so be sure you include one in the argument if that is what you want. If --branches/-b is specified, the prefix must include a trailing slash. Setting a prefix (with a trailing slash) is strongly encouraged in any case, as your SVN-tracking refs will then be located at &quot;refs/remotes/$prefix/&lt;strong&gt;&quot;, which is compatible with Git&amp;rsquo;s own remote-tracking ref layout (refs/remotes/$remote/&lt;/strong&gt;). Setting a prefix is also useful if you wish to track multiple projects that share a common repository. By default, the prefix is set to &lt;code&gt;origin/&lt;/code&gt;.</source>
          <target state="translated">이를 통해 트렁크 / 분기 / 태그가 지정된 경우 원격의 이름 앞에 붙는 접두사를 지정할 수 있습니다. 접두사는 자동으로 슬래시를 포함하지 않으므로 원하는 경우 인수에 하나를 포함시켜야합니다. --branches / -b를 지정하면 접두사 뒤에 슬래시가 포함되어야합니다. SVN 추적 참조가 &quot;refs / remotes / $ prefix / &lt;strong&gt;&quot;에 위치하므로 Git의 자체 원격 추적 참조 레이아웃 (refs)과 호환되므로&lt;/strong&gt; 접두사 (후행 슬래시 포함)를 설정하는 것이 좋습니다. &lt;strong&gt;/ remotes / $ remote /&lt;/strong&gt; ). 공통 저장소를 공유하는 여러 프로젝트를 추적하려는 경우 접 두부를 설정하는 것도 유용합니다. 기본적으로 접두사는 &lt;code&gt;origin/&lt;/code&gt; 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="99b10fdeae941de841a9ac73e39b7c06fcc2d978" translate="yes" xml:space="preserve">
          <source>This allows revision ranges for partial/cauterized history to be supported. $NUMBER, $NUMBER1:$NUMBER2 (numeric ranges), $NUMBER:HEAD, and BASE:$NUMBER are all supported.</source>
          <target state="translated">이를 통해 부분 / 소화 이력에 대한 수정 범위를 지원할 수 있습니다. $ NUMBER, $ NUMBER1 : $ NUMBER2 (숫자 범위), $ NUMBER : HEAD 및 BASE : $ NUMBER가 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f18b167effc162d347deb782b83eab22ac73f014" translate="yes" xml:space="preserve">
          <source>This allows users to create repositories from alternate URLs. For example, an administrator could run &lt;code&gt;git svn&lt;/code&gt; on the server locally (accessing via file://) but wish to distribute the repository with a public http:// or svn:// URL in the metadata so users of it will see the public URL.</source>
          <target state="translated">이를 통해 사용자는 대체 URL에서 리포지토리를 만들 수 있습니다. 예를 들어, 관리자 는 서버에서 로컬로 &lt;code&gt;git svn&lt;/code&gt; 을 실행 (file : //를 통해 액세스) 할 수 있지만 메타 데이터에 공개 http : // 또는 svn : // URL을 사용하여 리포지토리를 배포하여 사용자가 공개 URL.</target>
        </trans-unit>
        <trans-unit id="86c4c002dbb35b192dee2247feadc27722ad842a" translate="yes" xml:space="preserve">
          <source>This application is a CVS emulation layer for Git.</source>
          <target state="translated">이 애플리케이션은 Git의 CVS 에뮬레이션 레이어입니다.</target>
        </trans-unit>
        <trans-unit id="8feea1468fa1fae814e84f89aca492fad30e5da4" translate="yes" xml:space="preserve">
          <source>This applies modifications from a hot-fix branch before each test run, e.g. in case your build or test environment changed so that older revisions may need a fix which newer ones have already. (Make sure the hot-fix branch is based off a commit which is contained in all revisions which you are bisecting, so that the merge does not pull in too much, or use &lt;code&gt;git cherry-pick&lt;/code&gt; instead of &lt;code&gt;git merge&lt;/code&gt;.)</source>
          <target state="translated">예를 들어 빌드 또는 테스트 환경이 변경되어 이전 개정판에 이미 수정 된 수정본이 필요할 수있는 경우와 같이 각 테스트 실행 전에 핫픽스 브랜치의 수정 사항이 적용됩니다. (핫픽스 브랜치는 bisecting하는 모든 개정판에 포함 된 커밋을 기반으로하여 병합이 너무 많이 걸리지 않도록하거나 &lt;code&gt;git merge&lt;/code&gt; 대신 &lt;code&gt;git cherry-pick&lt;/code&gt; 을 사용해야 합니다.)</target>
        </trans-unit>
        <trans-unit id="889d1277201779cf18582f69129975a9bf60d357" translate="yes" xml:space="preserve">
          <source>This applies to files added to the source branch &lt;strong&gt;after&lt;/strong&gt; a daughter branch was created: if previously no commit was made on the daughter branch they will erroneously be added to the daughter branch in git.</source>
          <target state="translated">이는 딸 브랜치가 생성 된 &lt;strong&gt;후&lt;/strong&gt; 소스 브랜치에 추가 된 파일에 적용됩니다 . 이전에 딸 브랜치에서 커밋이 수행되지 않은 경우 git의 딸 브랜치에 잘못 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="cd519f993fc33ca56b2cb882b0ae5ba8b983012d" translate="yes" xml:space="preserve">
          <source>This argument will not be passed to &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt;. Instead it sets the vhost field in the git:// service request (to rest of the argument). Default is not to send vhost in such request (if sent).</source>
          <target state="translated">이 인수는 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 로 전달되지 않습니다 . 대신 git : // 서비스 요청에서 vhost 필드를 설정합니다 (인수의 나머지 부분). 기본적으로 이러한 요청에서 vhost를 보내지 않습니다 (전송 된 경우).</target>
        </trans-unit>
        <trans-unit id="9535ee34f2074fa8e689413e0518f1d3faf71e7d" translate="yes" xml:space="preserve">
          <source>This argument will not be passed to &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt;. Instead, it will cause the helper to start by sending git:// service requests to the remote side with the service field set to an appropriate value and the repository field set to rest of the argument. Default is not to send such a request.</source>
          <target state="translated">이 인수는 &lt;code&gt;&amp;lt;command&amp;gt;&lt;/code&gt; 로 전달되지 않습니다 . 대신, 서비스 필드가 적절한 값으로 설정되고 저장소 필드가 인수의 나머지 부분으로 설정된 상태에서 git : // 서비스 요청을 원격으로 전송하여 헬퍼가 시작되도록합니다. 기본적으로 그러한 요청을 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b50cd8ffcdc46b4b68ae7776a2b00f1d1183b6dd" translate="yes" xml:space="preserve">
          <source>This asks for all the history reachable from the given commit but not from any branch, tag, or other reference. If you decide it&amp;rsquo;s something you want, you can always create a new reference to it, e.g.,</source>
          <target state="translated">이것은 주어진 커밋에서 도달 할 수있는 모든 히스토리를 요청하지만 브랜치, 태그 또는 다른 참조는 아닙니다. 원하는 것으로 결정하면 언제든지 새로운 참조를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7efa4dea1c9da210003e0c08e382eb543f66cbf7" translate="yes" xml:space="preserve">
          <source>This attribute controls the length of conflict markers left in the work tree file during a conflicted merge. Only setting to the value to a positive integer has any meaningful effect.</source>
          <target state="translated">이 속성은 충돌 병합 중에 작업 트리 파일에 남아있는 충돌 마커의 길이를 제어합니다. 값을 양의 정수로 설정하면 의미있는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4caef1788f338fb02906a32b34bfb366a7539a3a" translate="yes" xml:space="preserve">
          <source>This attribute enables and controls end-of-line normalization. When a text file is normalized, its line endings are converted to LF in the repository. To control what line ending style is used in the working directory, use the &lt;code&gt;eol&lt;/code&gt; attribute for a single file and the &lt;code&gt;core.eol&lt;/code&gt; configuration variable for all text files. Note that setting &lt;code&gt;core.autocrlf&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;input&lt;/code&gt; overrides &lt;code&gt;core.eol&lt;/code&gt; (see the definitions of those options in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">이 속성은 줄 끝 정규화를 활성화하고 제어합니다. 텍스트 파일이 정규화되면 저장소의 줄 끝이 LF로 변환됩니다. 작업 디렉토리에서 사용되는 줄 끝 스타일을 제어하려면 단일 파일에 &lt;code&gt;eol&lt;/code&gt; 속성을 사용하고 모든 텍스트 파일에 &lt;code&gt;core.eol&lt;/code&gt; 구성 변수를 사용하십시오. &lt;code&gt;core.autocrlf&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;input&lt;/code&gt; 설정하면 core.eol 이 재정의 &lt;code&gt;core.eol&lt;/code&gt; ( &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 해당 옵션 정의 참조 ).</target>
        </trans-unit>
        <trans-unit id="9abb1dada669f4b282e87943eaa4c10d9676f824" translate="yes" xml:space="preserve">
          <source>This attribute sets a specific line-ending style to be used in the working directory. It enables end-of-line conversion without any content checks, effectively setting the &lt;code&gt;text&lt;/code&gt; attribute. Note that setting this attribute on paths which are in the index with CRLF line endings may make the paths to be considered dirty. Adding the path to the index again will normalize the line endings in the index.</source>
          <target state="translated">이 속성은 작업 디렉토리에서 사용할 특정 줄 끝 스타일을 설정합니다. 내용 확인없이 줄 끝 변환을 가능하게하여 &lt;code&gt;text&lt;/code&gt; 속성을 효과적으로 설정 합니다. CRLF 줄 끝으로 색인에있는 경로에이 속성을 설정하면 경로가 더티로 간주 될 수 있습니다. 색인에 경로를 다시 추가하면 색인의 줄 끝이 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="a95f413f93d421b5f0b609911f7201baca2aa2de" translate="yes" xml:space="preserve">
          <source>This automatically updates the rev_map if needed (see &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; in the FILES section below for details).</source>
          <target state="translated">필요한 경우 rev_map이 자동으로 업데이트됩니다 (자세한 내용은 아래 파일 섹션의 &lt;code&gt;$GIT_DIR/svn/**/.rev_map.*&lt;/code&gt; GIT_DIR / svn / ** /. rev_map. * 참조).</target>
        </trans-unit>
        <trans-unit id="5ef9fc28040a2d8ac737cc9e8915d682487174d5" translate="yes" xml:space="preserve">
          <source>This avoids touching the disk, but removes the additional file. Your project may prefer to adopt a naming convention, such as all-lowercase names, to avoid this problem from occurring again; such a convention can be checked using a &lt;code&gt;pre-receive&lt;/code&gt; hook or as part of a continuous integration (CI) system.</source>
          <target state="translated">이렇게하면 디스크를 건드리지 않고 추가 파일이 제거됩니다. 이 문제가 다시 발생하지 않도록 프로젝트에서 모두 소문자 이름과 같은 명명 규칙을 채택 할 수 있습니다. 이러한 규칙은 &lt;code&gt;pre-receive&lt;/code&gt; 후크를 사용하거나 연속 통합 (CI) 시스템의 일부로 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="756e07e0622c048ffb322b306c002b3fe742a463" translate="yes" xml:space="preserve">
          <source>This behavior can be suppressed with the &lt;code&gt;--no-ff&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;--no-ff&lt;/code&gt; 옵션을 사용하면이 동작을 억제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ad430bc747d1916521d538bf94c1847176c4231" translate="yes" xml:space="preserve">
          <source>This behavior is the default when the start point is a remote-tracking branch. Set the branch.autoSetupMerge configuration variable to &lt;code&gt;false&lt;/code&gt; if you want &lt;code&gt;git switch&lt;/code&gt;, &lt;code&gt;git checkout&lt;/code&gt; and &lt;code&gt;git branch&lt;/code&gt; to always behave as if &lt;code&gt;--no-track&lt;/code&gt; were given. Set it to &lt;code&gt;always&lt;/code&gt; if you want this behavior when the start-point is either a local or remote-tracking branch.</source>
          <target state="translated">시작 지점이 원격 추적 분기 인 경우이 동작이 기본값입니다. 에 branch.autoSetupMerge 구성 변수 설정 &lt;code&gt;false&lt;/code&gt; 원하는 경우 &lt;code&gt;git switch&lt;/code&gt; , &lt;code&gt;git checkout&lt;/code&gt; 하고 &lt;code&gt;git branch&lt;/code&gt; 것처럼 항상 행동에 &lt;code&gt;--no-track&lt;/code&gt; 주어진합니다. 시작점이 로컬 또는 원격 추적 분기 일 때이 동작을 원하면 &lt;code&gt;always&lt;/code&gt; 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="a57c8928c46f18c8586890f640bdaceff3225ce7" translate="yes" xml:space="preserve">
          <source>This boolean config option controls whether some commands run &lt;code&gt;git maintenance run --auto&lt;/code&gt; after doing their normal work. Defaults to true.</source>
          <target state="translated">이 부울 구성 옵션은 일부 명령 이 정상적인 작업을 수행 한 후 &lt;code&gt;git maintenance run --auto&lt;/code&gt; 를 실행할지 여부를 제어합니다 . 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="02d843a8479501e1f56c84b63bc83f8438d9dc3a" translate="yes" xml:space="preserve">
          <source>This boolean config option controls whether the maintenance task with name &lt;code&gt;&amp;lt;task&amp;gt;&lt;/code&gt; is run when no &lt;code&gt;--task&lt;/code&gt; option is specified to &lt;code&gt;git maintenance run&lt;/code&gt;. These config values are ignored if a &lt;code&gt;--task&lt;/code&gt; option exists. By default, only &lt;code&gt;maintenance.gc.enabled&lt;/code&gt; is true.</source>
          <target state="translated">This boolean config option controls whether the maintenance task with name &lt;code&gt;&amp;lt;task&amp;gt;&lt;/code&gt; is run when no &lt;code&gt;--task&lt;/code&gt; option is specified to &lt;code&gt;git maintenance run&lt;/code&gt; . These config values are ignored if a &lt;code&gt;--task&lt;/code&gt; option exists. By default, only &lt;code&gt;maintenance.gc.enabled&lt;/code&gt; is true.</target>
        </trans-unit>
        <trans-unit id="e589ab09a449c7cf7000e50f249deca2b148281c" translate="yes" xml:space="preserve">
          <source>This boolean will enable &lt;code&gt;fsync()&lt;/code&gt; when writing object files.</source>
          <target state="translated">이 부울은 객체 파일을 쓸 때 &lt;code&gt;fsync()&lt;/code&gt; 를 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="2a9d8bb8cd3e4996e1654fca8257ad2030d24d70" translate="yes" xml:space="preserve">
          <source>This breakage is of course most of the time unrelated to the breakage we are trying to locate in the commit graph. But it prevents us to know if the interesting &quot;bad behavior&quot; is present or not.</source>
          <target state="translated">이 파손은 물론 대부분 커밋 그래프에서 찾으려고하는 파손과 관련이 없습니다. 그러나 흥미로운 &quot;나쁜 행동&quot;이 있는지 아닌지를 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a7656b1b8b17aa91ea330f8fbedd0a75097faed" translate="yes" xml:space="preserve">
          <source>This bug has also been shown to affect non-symlink cases of replacing a directory with a file when it comes to the internal structures of the untracked cache, but no case has been reported where this resulted in wrong &quot;git status&quot; output.</source>
          <target state="translated">이 버그는 또한 추적되지 않은 캐시의 내부 구조와 관련하여 디렉토리를 파일로 바꾸는 심볼릭 링크가 아닌 경우에 영향을주는 것으로 나타 났지만 이로 인해 잘못된 &quot;git status&quot;출력이 발생한 경우는보고되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="bbb14e9c1a32bd1658d34b41d317e78fe3e2cf7e" translate="yes" xml:space="preserve">
          <source>This cache is meant to speed up commands that involve determining untracked files such as &lt;code&gt;git status&lt;/code&gt;.</source>
          <target state="translated">이 캐시는 &lt;code&gt;git status&lt;/code&gt; 와 같은 추적되지 않은 파일을 결정하는 명령의 속도를 높이기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="5e9291bab46bd7ea7a2a21b7e8d51146482ff7a6" translate="yes" xml:space="preserve">
          <source>This calculates the same as &lt;code&gt;--bisect&lt;/code&gt;, except that refs in &lt;code&gt;refs/bisect/&lt;/code&gt; are not used, and except that this outputs text ready to be eval&amp;rsquo;ed by the shell. These lines will assign the name of the midpoint revision to the variable &lt;code&gt;bisect_rev&lt;/code&gt;, and the expected number of commits to be tested after &lt;code&gt;bisect_rev&lt;/code&gt; is tested to &lt;code&gt;bisect_nr&lt;/code&gt;, the expected number of commits to be tested if &lt;code&gt;bisect_rev&lt;/code&gt; turns out to be good to &lt;code&gt;bisect_good&lt;/code&gt;, the expected number of commits to be tested if &lt;code&gt;bisect_rev&lt;/code&gt; turns out to be bad to &lt;code&gt;bisect_bad&lt;/code&gt;, and the number of commits we are bisecting right now to &lt;code&gt;bisect_all&lt;/code&gt;.</source>
          <target state="translated">동일한 계산이 &lt;code&gt;--bisect&lt;/code&gt; 에서 심판이 제외 &lt;code&gt;refs/bisect/&lt;/code&gt; 사용되지 않으며,이 준비가 출력 텍스트 쉘 eval'ed되는 것을 제외. 이 라인은 변수에 중간 개정의 이름을 지정합니다 &lt;code&gt;bisect_rev&lt;/code&gt; 후 테스트하고, 커밋의 예상 수를 &lt;code&gt;bisect_rev&lt;/code&gt; 가 테스트되고 &lt;code&gt;bisect_nr&lt;/code&gt; 경우 커밋의 예상 번호를 테스트 할, &lt;code&gt;bisect_rev&lt;/code&gt; 가 좋은 것으로 판명 &lt;code&gt;bisect_good&lt;/code&gt; 의 경우 커밋의 예상 번호를 테스트 할 &lt;code&gt;bisect_rev&lt;/code&gt; 판명가 나쁜 것으로 &lt;code&gt;bisect_bad&lt;/code&gt; 및 커밋의 수는 우리가 바로 지금 양분되어 &lt;code&gt;bisect_all&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d3cf717b036e3b0e81df34e24d7ea082a035f6a" translate="yes" xml:space="preserve">
          <source>This can allow you to make partial mirrors when running fetch; but is generally not recommended because history will be skipped and lost.</source>
          <target state="translated">페치를 실행할 때 부분 미러를 만들 수 있습니다. 기록은 건너 뛰고 손실되므로 일반적으로 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="636e119b451b3bd7ccaf26b7d43733789f26ed19" translate="yes" xml:space="preserve">
          <source>This can also be set up as the default behaviour by using the &lt;code&gt;worktree.guessRemote&lt;/code&gt; config option.</source>
          <target state="translated">&lt;code&gt;worktree.guessRemote&lt;/code&gt; 구성 옵션 을 사용하여 기본 동작으로 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa409f68e80081ea9a669e9f13a5d077543254ef" translate="yes" xml:space="preserve">
          <source>This can be &lt;code&gt;end&lt;/code&gt;, which is the default, &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt; or &lt;code&gt;before&lt;/code&gt;.</source>
          <target state="translated">이 값은 &lt;code&gt;end&lt;/code&gt; 일 수 있으며 기본값은 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;after&lt;/code&gt; 또는 &lt;code&gt;before&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0de02388f102cf8ff32d10ea0ea1542e4435ae39" translate="yes" xml:space="preserve">
          <source>This can be any options that the archiver backend understands. See next section.</source>
          <target state="translated">아카이버 백엔드가 이해하는 모든 옵션이 될 수 있습니다. 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8ebe928ea2c46867d2d30a22aa44b6d209b60b27" translate="yes" xml:space="preserve">
          <source>This can be combined with the gitweb configuration:</source>
          <target state="translated">이것은 gitweb 설정과 결합 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3e2aafd0fe68d162abd0214f2c4dbcf97a317242" translate="yes" xml:space="preserve">
          <source>This can be enabled by default with the configuration option mailinfo.scissors.</source>
          <target state="translated">mailinfo.scissors 구성 옵션을 사용하여 기본적으로 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90b17ef61d05f77323fefc823815f1b4d0ca5c24" translate="yes" xml:space="preserve">
          <source>This can be set to a comma-separated list of strings. When a curl trace is enabled (see &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; above), whenever a &quot;Cookies:&quot; header sent by the client is dumped, values of cookies whose key is in that list (case-sensitive) are redacted.</source>
          <target state="translated">쉼표로 구분 된 문자열 목록으로 설정할 수 있습니다. 컬 추적이 활성화되면 ( 위의 &lt;code&gt;GIT_TRACE_CURL&lt;/code&gt; 참조) 클라이언트가 보낸 &quot;Cookies :&quot;헤더가 덤프 될 때마다 키가 해당 목록에있는 쿠키 값 (대소 문자 구분)이 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="3d49143ca76086473ec42d2280fe45285788984b" translate="yes" xml:space="preserve">
          <source>This can be used to color the metadata of a blame line depending on age of the line.</source>
          <target state="translated">라인의 나이에 따라 비난 라인의 메타 데이터를 채색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f9fdab39f98d82a2bdc74c13a484288c9af48d4" translate="yes" xml:space="preserve">
          <source>This can be used to convert arguments to a command run in a subdirectory so that they can still be used after moving to the top-level of the repository. For example:</source>
          <target state="translated">서브 디렉토리에서 실행되는 명령으로 인수를 변환하여 저장소의 최상위 레벨로 이동 한 후에도 계속 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7c4f04c6d6345aed6141f4d5502d056991a7840c" translate="yes" xml:space="preserve">
          <source>This can be used when you want to include further changes to the merge, or want to write your own merge commit message.</source>
          <target state="translated">병합에 대한 추가 변경 사항을 포함 시키거나 자신의 병합 커밋 메시지를 작성하려고 할 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14d1ead4268c0c0f3315fceadadaf2f291770d82" translate="yes" xml:space="preserve">
          <source>This can be used with the &lt;code&gt;dcommit&lt;/code&gt;, &lt;code&gt;rebase&lt;/code&gt;, &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;tag&lt;/code&gt; commands.</source>
          <target state="translated">이것은 &lt;code&gt;dcommit&lt;/code&gt; , &lt;code&gt;rebase&lt;/code&gt; , &lt;code&gt;branch&lt;/code&gt; 및 &lt;code&gt;tag&lt;/code&gt; 명령 과 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9067f207a93cdcf6d90b3183367a4ae6097c31d6" translate="yes" xml:space="preserve">
          <source>This can be useful when you want to publish the tree from a commit without exposing its full history. You might want to do this to publish an open source branch of a project whose current tree is &quot;clean&quot;, but whose full history contains proprietary or otherwise encumbered bits of code.</source>
          <target state="translated">이것은 전체 히스토리를 공개하지 않고 커밋에서 트리를 공개하려는 경우에 유용 할 수 있습니다. 현재 트리가 &quot;깨끗&quot;하지만 전체 히스토리에 독점적이거나 복잡하지 않은 코드 비트가 포함 된 프로젝트의 오픈 소스 분기를 공개하기 위해이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ddcbb1d5b5e22f922e078b6b0d84fe1dcc0409b" translate="yes" xml:space="preserve">
          <source>This can happen, for example, if you:</source>
          <target state="translated">예를 들어 다음과 같은 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9140f80526c6eb06ff98ed4abf5c0d2e07067266" translate="yes" xml:space="preserve">
          <source>This can only resolve two heads (i.e. the current branch and another branch you pulled from) using a 3-way merge algorithm. It tries to carefully detect criss-cross merge ambiguities and is considered generally safe and fast.</source>
          <target state="translated">이 방법은 3 방향 병합 알고리즘을 사용하여 두 개의 헤드 (즉, 현재 분기 및 가져온 다른 분기) 만 해결할 수 있습니다. 십자 병합 모호성을 신중하게 감지하려고 시도하며 일반적으로 안전하고 빠른 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="10679b433b60fbaff0452d6d903b314fee5164d2" translate="yes" xml:space="preserve">
          <source>This can only resolve two heads using a 3-way merge algorithm. When there is more than one common ancestor that can be used for 3-way merge, it creates a merged tree of the common ancestors and uses that as the reference tree for the 3-way merge. This has been reported to result in fewer merge conflicts without causing mismerges by tests done on actual merge commits taken from Linux 2.6 kernel development history. Additionally this can detect and handle merges involving renames, but currently cannot make use of detected copies. This is the default merge strategy when pulling or merging one branch.</source>
          <target state="translated">이 방법은 3 방향 병합 알고리즘을 사용하여 두 헤드 만 해결할 수 있습니다. 3 방향 병합에 사용할 수있는 공통 조상이 둘 이상있는 경우 공통 조상의 병합 된 트리를 작성하고이를 3 방향 병합의 참조 트리로 사용합니다. 이는 Linux 2.6 커널 개발 히스토리에서 가져온 실제 병합 커밋에서 수행 된 테스트로 인한 혼란을 유발하지 않으면 서 병합 충돌을 줄이는 것으로보고되었습니다. 또한 이름 변경과 관련된 병합을 감지하고 처리 할 수 ​​있지만 현재는 감지 된 사본을 사용할 수 없습니다. 하나의 브랜치를 가져 오거나 병합 할 때의 기본 병합 전략입니다.</target>
        </trans-unit>
        <trans-unit id="2cac39aeb86961e1363f7613dfed0033661ab943" translate="yes" xml:space="preserve">
          <source>This can speed up operations like &lt;code&gt;git diff&lt;/code&gt; and &lt;code&gt;git status&lt;/code&gt; especially on filesystems like NFS that have weak caching semantics and thus relatively high IO latencies. When enabled, Git will do the index comparison to the filesystem data in parallel, allowing overlapping IO&amp;rsquo;s. Defaults to true.</source>
          <target state="translated">이것은 캐싱 시맨틱이 약하고 따라서 상대적으로 높은 IO 대기 시간을 갖는 NFS와 같은 파일 시스템에서 특히 &lt;code&gt;git diff&lt;/code&gt; 및 &lt;code&gt;git status&lt;/code&gt; 와 같은 작업의 속도를 높일 수 있습니다 . 활성화되면 Git은 파일 시스템 데이터와 병렬로 인덱스를 비교하여 IO가 겹치게합니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="9202266152fd1a0a2194149286bebd74fe30a95c" translate="yes" xml:space="preserve">
          <source>This capability can be advertised multiple times. The first applicable refspec takes precedence. The left-hand of refspecs advertised with this capability must cover all refs reported by the list command. If no &lt;code&gt;refspec&lt;/code&gt; capability is advertised, there is an implied &lt;code&gt;refspec *:*&lt;/code&gt;.</source>
          <target state="translated">이 기능은 여러 번 보급 될 수 있습니다. 적용 가능한 첫 번째 참조 스펙이 우선합니다. 이 기능으로 광고 된 참조 사양의 왼쪽은 list 명령으로보고 된 모든 참조를 포함해야합니다. &lt;code&gt;refspec&lt;/code&gt; 기능이 알려지지 않은 경우 &lt;code&gt;refspec *:*&lt;/code&gt; 가 내포 됩니다.</target>
        </trans-unit>
        <trans-unit id="561397ab0857a5bada65e17ac4aabd661a6939b5" translate="yes" xml:space="preserve">
          <source>This chapter covers internal details of the Git implementation which probably only Git developers need to understand.</source>
          <target state="translated">이 장에서는 Git 개발자 만 이해해야하는 Git 구현에 대한 내부 세부 사항을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="9301665301f3e50c4417122a8411be226ea5b235" translate="yes" xml:space="preserve">
          <source>This command always gets all objects. Historically, there were three options &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-t&lt;/code&gt; for choosing which objects to download. They are now silently ignored.</source>
          <target state="translated">이 명령은 항상 모든 객체를 가져옵니다. 역사적 으로 다운로드 할 객체를 선택하기위한 세 가지 옵션 &lt;code&gt;-a&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-t&lt;/code&gt; 가있었습니다 . 이제는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5b8a59dc9ca3a3d6f247d36df5fb54708fa69494" translate="yes" xml:space="preserve">
          <source>This command applies the patch but does not create a commit. Use &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; to create commits from patches generated by &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; and/or received by email.</source>
          <target state="translated">이 명령은 패치를 적용하지만 커밋을 생성하지는 않습니다. 사용 &lt;a href=&quot;git-am&quot;&gt;자식-AM [1]&lt;/a&gt; 에 의해 생성 된 패치에서 커밋 생성하는 &lt;a href=&quot;git-format-patch&quot;&gt;자식 형식의 패치 [1]&lt;/a&gt; 및 / 또는 이메일로 접수합니다.</target>
        </trans-unit>
        <trans-unit id="1f849e1e7df08a5bb28860e4715d22e12f5d5d20" translate="yes" xml:space="preserve">
          <source>This command assists the developer in this process by recording conflicted automerge results and corresponding hand resolve results on the initial manual merge, and applying previously recorded hand resolutions to their corresponding automerge results.</source>
          <target state="translated">이 명령은 충돌 된 자동 병합 결과 및 해당 손 해결 결과를 초기 수동 병합에 기록하고 이전에 기록 된 손 해상도를 해당 자동 병합 결과에 적용하여이 프로세스에서 개발자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b823d02fd766a4ae4b81090ce369454e7da568d6" translate="yes" xml:space="preserve">
          <source>This command caches credentials in memory for use by future Git programs. The stored credentials never touch the disk, and are forgotten after a configurable timeout. The cache is accessible over a Unix domain socket, restricted to the current user by filesystem permissions.</source>
          <target state="translated">이 명령은 향후 Git 프로그램에서 사용할 수 있도록 자격 증명을 메모리에 캐시합니다. 저장된 자격 증명은 디스크를 건드리지 않으며 구성 가능한 시간 초과 후 잊어 버립니다. 캐시는 Unix 도메인 소켓을 통해 액세스 할 수 있으며 파일 시스템 권한으로 현재 사용자로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="4784337d21599fe7fcfddcd79392d8470207170e" translate="yes" xml:space="preserve">
          <source>This command can be performed multiple times before a commit. It only adds the content of the specified file(s) at the time the add command is run; if you want subsequent changes included in the next commit, then you must run &lt;code&gt;git add&lt;/code&gt; again to add the new content to the index.</source>
          <target state="translated">이 명령은 커밋 전에 여러 번 수행 할 수 있습니다. add 명령이 실행될 때 지정된 파일의 내용 만 추가합니다. 다음 커밋에 후속 변경 사항을 포함하려면 &lt;code&gt;git add&lt;/code&gt; 를 다시 실행 하여 새 내용을 인덱스에 추가 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c286ab165ab2a31532b621372beb627366820ec4" translate="yes" xml:space="preserve">
          <source>This command can be used where a &lt;code&gt;filemodify&lt;/code&gt; directive can appear, allowing it to be used in the middle of a commit. For a &lt;code&gt;filemodify&lt;/code&gt; using an inline directive, it can also appear right before the &lt;code&gt;data&lt;/code&gt; directive.</source>
          <target state="translated">이 명령은 &lt;code&gt;filemodify&lt;/code&gt; 지시문이 나타날 수 있는 곳에서 사용될 수 있으며 , 커밋 도중에 사용될 수 있습니다. 인라인 지시문을 사용 하는 파일 &lt;code&gt;filemodify&lt;/code&gt; 경우 &lt;code&gt;data&lt;/code&gt; 지시문 바로 앞에 나타날 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74e4352fd2289d447be4133ac0e6d68d162428a6" translate="yes" xml:space="preserve">
          <source>This command can run &lt;code&gt;applypatch-msg&lt;/code&gt;, &lt;code&gt;pre-applypatch&lt;/code&gt;, and &lt;code&gt;post-applypatch&lt;/code&gt; hooks. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more information.</source>
          <target state="translated">이 명령은 &lt;code&gt;applypatch-msg&lt;/code&gt; , &lt;code&gt;pre-applypatch&lt;/code&gt; 및 &lt;code&gt;post-applypatch&lt;/code&gt; 훅을 실행할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2e5610ce87e5d01d8f8246892b4f05f886b6ad5a" translate="yes" xml:space="preserve">
          <source>This command can run &lt;code&gt;commit-msg&lt;/code&gt;, &lt;code&gt;prepare-commit-msg&lt;/code&gt;, &lt;code&gt;pre-commit&lt;/code&gt;, &lt;code&gt;post-commit&lt;/code&gt; and &lt;code&gt;post-rewrite&lt;/code&gt; hooks. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more information.</source>
          <target state="translated">이 명령은 &lt;code&gt;commit-msg&lt;/code&gt; , &lt;code&gt;prepare-commit-msg&lt;/code&gt; , &lt;code&gt;pre-commit&lt;/code&gt; , &lt;code&gt;post-commit&lt;/code&gt; 및 &lt;code&gt;post-rewrite&lt;/code&gt; hooks를 실행할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6ba8d48bf258fdf0b61e4a3a7667022fd45b3e45" translate="yes" xml:space="preserve">
          <source>This command creates an empty Git repository - basically a &lt;code&gt;.git&lt;/code&gt; directory with subdirectories for &lt;code&gt;objects&lt;/code&gt;, &lt;code&gt;refs/heads&lt;/code&gt;, &lt;code&gt;refs/tags&lt;/code&gt;, and template files. An initial &lt;code&gt;HEAD&lt;/code&gt; file that references the HEAD of the master branch is also created.</source>
          <target state="translated">이 명령은 빈 Git 리포지토리 (기본적으로 &lt;code&gt;objects&lt;/code&gt; , 참조 &lt;code&gt;refs/heads&lt;/code&gt; , 참조 &lt;code&gt;refs/tags&lt;/code&gt; 및 템플릿 파일의 하위 디렉토리가 있는 &lt;code&gt;.git&lt;/code&gt; 디렉토리)를 만듭니다. 마스터 분기의 HEAD를 참조 하는 초기 &lt;code&gt;HEAD&lt;/code&gt; 파일도 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="283a3a39e231f6367045f912a15047dc4264c5e0" translate="yes" xml:space="preserve">
          <source>This command creates an empty Git repository - basically a &lt;code&gt;.git&lt;/code&gt; directory with subdirectories for &lt;code&gt;objects&lt;/code&gt;, &lt;code&gt;refs/heads&lt;/code&gt;, &lt;code&gt;refs/tags&lt;/code&gt;, and template files. An initial branch without any commits will be created (see the &lt;code&gt;--initial-branch&lt;/code&gt; option below for its name).</source>
          <target state="translated">이 명령은 빈 Git 저장소 (기본적으로 &lt;code&gt;objects&lt;/code&gt; , &lt;code&gt;refs/heads&lt;/code&gt; , &lt;code&gt;refs/tags&lt;/code&gt; 및 템플릿 파일에 대한 하위 디렉터리가 있는 &lt;code&gt;.git&lt;/code&gt; 디렉터리)를 만듭니다. 커밋이없는 초기 브랜치가 생성됩니다 ( 이름은 아래 &lt;code&gt;--initial-branch&lt;/code&gt; 옵션 참조).</target>
        </trans-unit>
        <trans-unit id="f52be87adec196973421cd7319ee0f98c1860983" translate="yes" xml:space="preserve">
          <source>This command degenerates to download everything to complete the asked refs from the remote side when the local side does not have a common ancestor commit.</source>
          <target state="translated">이 명령은 로컬 측에 공통 조상 커밋이없는 경우 원격 측에서 요청 된 참조를 완료하기 위해 모든 것을 다운로드하도록 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="194b70091800ec19021441e8c1778ca9e02b53d5" translate="yes" xml:space="preserve">
          <source>This command ensures that the changes in the experimental branch are already in the current branch.</source>
          <target state="translated">이 명령은 실험 브랜치의 변경 사항이 이미 현재 브랜치에 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1b788d383418fe8b134f7630991a2d6359c7dd7c" translate="yes" xml:space="preserve">
          <source>This command finds new changes in p4 and imports them as Git commits.</source>
          <target state="translated">이 명령은 p4에서 새로운 변경 사항을 찾고 Git 커밋으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4b11fc8efec3bd343a83e9f1aa4620a514b9ab8e" translate="yes" xml:space="preserve">
          <source>This command formats the lines of its standard input into a table with multiple columns. Each input line occupies one cell of the table. It is used internally by other git commands to format output into columns.</source>
          <target state="translated">이 명령은 표준 입력 행을 여러 열이있는 테이블로 형식화합니다. 각 입력 라인은 테이블의 하나의 셀을 차지합니다. 출력을 열로 형식화하기 위해 다른 git 명령에 의해 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ade7fdc971ed1f0936fb8fbff7bb1574367ca37b" translate="yes" xml:space="preserve">
          <source>This command is extremely useful if the frontend does not know (or does not care to know) what files are currently on the branch, and therefore cannot generate the proper &lt;code&gt;filedelete&lt;/code&gt; commands to update the content.</source>
          <target state="translated">이 명령은 프론트 엔드가 현재 브랜치에있는 파일을 알지 못하거나 알지 못하는 경우에 매우 유용하므로 컨텐츠를 업데이트하기 위해 적절한 &lt;code&gt;filedelete&lt;/code&gt; 명령을 생성 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5f45dc9e63088b4d8e620891decbfdd6655de376" translate="yes" xml:space="preserve">
          <source>This command is intended mostly for internal use by scripts automatically invoking &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">이 명령은 주로 &lt;code&gt;git merge&lt;/code&gt; 를 자동으로 호출하는 스크립트에 의해 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3710225b15829bc8cbeb92895b81ff709286e645" translate="yes" xml:space="preserve">
          <source>This command is recursive by default.</source>
          <target state="translated">이 명령은 기본적으로 재귀 적입니다.</target>
        </trans-unit>
        <trans-unit id="6e8668d616c8790cb8d71e8720597de54ced7850" translate="yes" xml:space="preserve">
          <source>This command is used to combine all objects that do not currently reside in a &quot;pack&quot;, into a pack. It can also be used to re-organize existing packs into a single, more efficient pack.</source>
          <target state="translated">이 명령은 현재 &quot;팩&quot;에없는 모든 오브젝트를 팩으로 결합하는 데 사용됩니다. 또한 기존 팩을보다 효율적인 단일 팩으로 재구성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7cbc44be580e3c1734536d3564c4b9dc7e501fa" translate="yes" xml:space="preserve">
          <source>This command is used to solve the storage and performance problem by storing the refs in a single file, &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt;. When a ref is missing from the traditional &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory hierarchy, it is looked up in this file and used if found.</source>
          <target state="translated">이 명령은 참조를 단일 파일 &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; 에 저장하여 스토리지 및 성능 문제를 해결하는 데 사용됩니다 . 기존 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 디렉토리 계층 에서 참조가 누락 된 경우이 파일에서 참조가 발견되면 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="43f707239bbecf8d6bf96bbdb4b367abb8fd5357" translate="yes" xml:space="preserve">
          <source>This command is usually not invoked directly by the end user. The UI for the protocol is on the &lt;code&gt;git archive&lt;/code&gt; side, and the program pair is meant to be used to get an archive from a remote repository.</source>
          <target state="translated">이 명령은 일반적으로 최종 사용자가 직접 호출하지 않습니다. 프로토콜의 UI는 &lt;code&gt;git archive&lt;/code&gt; 측에 있으며 프로그램 쌍은 원격 저장소에서 아카이브를 가져 오는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="17d67b43408b7b4804e33e1e3b79dc1fbf03af1b" translate="yes" xml:space="preserve">
          <source>This command is usually not invoked directly by the end user. The UI for the protocol is on the &lt;code&gt;git fetch-pack&lt;/code&gt; side, and the program pair is meant to be used to pull updates from a remote repository. For push operations, see &lt;code&gt;git send-pack&lt;/code&gt;.</source>
          <target state="translated">이 명령은 일반적으로 최종 사용자가 직접 호출하지 않습니다. 프로토콜의 UI는 &lt;code&gt;git fetch-pack&lt;/code&gt; 쪽에 있으며 프로그램 쌍은 원격 저장소에서 업데이트를 가져 오는 데 사용됩니다. 푸시 조작에 대해서는 &lt;code&gt;git send-pack&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="36ac8b84f92c3cf141e5ae101adcc45178aae4c7" translate="yes" xml:space="preserve">
          <source>This command is usually not invoked directly by the end user. The UI for the protocol is on the &lt;code&gt;git send-pack&lt;/code&gt; side, and the program pair is meant to be used to push updates to remote repository. For pull operations, see &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt;.</source>
          <target state="translated">이 명령은 일반적으로 최종 사용자가 직접 호출하지 않습니다. 프로토콜의 UI는 &lt;code&gt;git send-pack&lt;/code&gt; 쪽에 있으며 프로그램 쌍은 업데이트를 원격 저장소로 푸시하는 데 사용됩니다. 풀 조작에 대해서는 &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8cac5b996748b602d2e8f0cf9273cee3d1c4d80" translate="yes" xml:space="preserve">
          <source>This command lets you check that intermediate commits are compilable. The todo list becomes like that:</source>
          <target state="translated">이 명령을 사용하면 중간 커밋이 컴파일 가능한지 확인할 수 있습니다. 할 일 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56bca57be11add071b8aeae38f6a28f443105856" translate="yes" xml:space="preserve">
          <source>This command manages the information recorded in the reflogs.</source>
          <target state="translated">이 명령은 참조 로그에 기록 된 정보를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="7c7ebb85111dd101dc1c2782f6e5cbc235a39c44" translate="yes" xml:space="preserve">
          <source>This command provides a way to interact with p4 repositories using Git.</source>
          <target state="translated">이 명령은 Git을 사용하여 p4 리포지토리와 상호 작용하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="637c92f99feb8b30861eeaee2e3273c64a9b5351" translate="yes" xml:space="preserve">
          <source>This command reads some patches or commit messages from either the &amp;lt;file&amp;gt; arguments or the standard input if no &amp;lt;file&amp;gt; is specified. If &lt;code&gt;--parse&lt;/code&gt; is specified, the output consists of the parsed trailers.</source>
          <target state="translated">이 명령은 &amp;lt;file&amp;gt; 인수 또는 &amp;lt;file&amp;gt;이 지정되지 않은 경우 표준 입력에서 일부 패치 또는 커밋 메시지를 읽습니다. 경우 &lt;code&gt;--parse&lt;/code&gt; 가 지정, 출력은 구문 분석 된 트레일러로 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a38646d64359b52991af1358c674765acf2c0c11" translate="yes" xml:space="preserve">
          <source>This command should not list any commits. Otherwise, check out &lt;code&gt;master&lt;/code&gt; and merge &lt;code&gt;maint&lt;/code&gt; into it.</source>
          <target state="translated">이 명령은 커밋을 나열하지 않아야합니다. 그렇지 않으면 &lt;code&gt;master&lt;/code&gt; 를 확인하고 &lt;code&gt;maint&lt;/code&gt; 을 병합 하십시오.</target>
        </trans-unit>
        <trans-unit id="6a853b09f1818b9d32f936bd42aa8a84af13b068" translate="yes" xml:space="preserve">
          <source>This command shows the differences between two versions of a patch series, or more generally, two commit ranges (ignoring merge commits).</source>
          <target state="translated">이 명령은 패치 시리즈의 두 버전 또는보다 일반적으로 두 커밋 범위 (병합 커밋 무시)의 차이점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="852903a68075d19a47d4520af94edde77996207f" translate="yes" xml:space="preserve">
          <source>This command stores credentials indefinitely on disk for use by future Git programs.</source>
          <target state="translated">이 명령은 향후 Git 프로그램에서 사용할 수 있도록 자격 증명을 디스크에 무기한 저장합니다.</target>
        </trans-unit>
        <trans-unit id="d143bf10d727fe2f5d0639ed85e199dd448d8bd2" translate="yes" xml:space="preserve">
          <source>This command updates the index using the current content found in the working tree, to prepare the content staged for the next commit. It typically adds the current content of existing paths as a whole, but with some options it can also be used to add content with only part of the changes made to the working tree files applied, or remove paths that do not exist in the working tree anymore.</source>
          <target state="translated">이 명령은 다음 커밋을 위해 준비된 내용을 준비하기 위해 작업 트리에있는 현재 내용을 사용하여 색인을 업데이트합니다. 일반적으로 기존 경로의 현재 내용을 전체적으로 추가하지만 일부 옵션을 사용하면 적용된 작업 트리 파일의 변경 내용 중 일부만 적용하거나 작업 트리에 존재하지 않는 경로를 제거하는 데 사용할 수도 있습니다 더 이상</target>
        </trans-unit>
        <trans-unit id="61eacd31ecbd262bdcbed11d9c6103318919d1be" translate="yes" xml:space="preserve">
          <source>This command uploads a mailbox generated with &lt;code&gt;git format-patch&lt;/code&gt; into an IMAP drafts folder. This allows patches to be sent as other email is when using mail clients that cannot read mailbox files directly. The command also works with any general mailbox in which emails have the fields &quot;From&quot;, &quot;Date&quot;, and &quot;Subject&quot; in that order.</source>
          <target state="translated">이 명령은 &lt;code&gt;git format-patch&lt;/code&gt; 로 생성 된 메일 함을 IMAP 초안 폴더에 업로드 합니다. 메일 함 파일을 직접 읽을 수없는 메일 클라이언트를 사용할 때 다른 이메일로 패치를 보낼 수 있습니다. 이 명령은 전자 메일에 &quot;보낸 사람&quot;, &quot;날짜&quot;및 &quot;제목&quot;필드가 순서대로있는 일반 사서함에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a3bcbdfcf8f3a072ac23f24cf310648f9691fb70" translate="yes" xml:space="preserve">
          <source>This command uses a binary search algorithm to find which commit in your project&amp;rsquo;s history introduced a bug. You use it by first telling it a &quot;bad&quot; commit that is known to contain the bug, and a &quot;good&quot; commit that is known to be before the bug was introduced. Then &lt;code&gt;git
bisect&lt;/code&gt; picks a commit between those two endpoints and asks you whether the selected commit is &quot;good&quot; or &quot;bad&quot;. It continues narrowing down the range until it finds the exact commit that introduced the change.</source>
          <target state="translated">이 명령은 이진 검색 알고리즘을 사용하여 프로젝트 기록에서 어떤 커밋에 버그가 발생했는지 확인합니다. 먼저 버그를 포함하는 것으로 알려진 &quot;나쁜&quot;커밋과 버그가 소개되기 전에 알려진 &quot;좋은&quot;커밋을 알려서이 도구를 사용합니다. 그런 다음 &lt;code&gt;git bisect&lt;/code&gt; 는이 두 끝점 사이에서 커밋을 선택하고 선택한 커밋이 &quot;양호&quot;인지 &quot;나쁜&quot;것인지 묻습니다. 변경을 도입 한 정확한 커밋을 찾을 때까지 범위를 계속 좁 힙니다.</target>
        </trans-unit>
        <trans-unit id="097f8af4b6f26b418927a5ca4b24d71746b1f843" translate="yes" xml:space="preserve">
          <source>This command uses the &lt;code&gt;diff.color.*&lt;/code&gt; and &lt;code&gt;pager.range-diff&lt;/code&gt; settings (the latter is on by default). See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">이 명령은 &lt;code&gt;diff.color.*&lt;/code&gt; 및 &lt;code&gt;pager.range-diff&lt;/code&gt; 설정을 사용합니다 (후자는 기본적으로 켜져 있음). &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="03bab6a03561ee7ff2e9bf92505bcdd5322bfb51" translate="yes" xml:space="preserve">
          <source>This command will fail with non-zero status upon error. Some exit codes are:</source>
          <target state="translated">이 명령은 오류시 0이 아닌 상태로 실패합니다. 일부 종료 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ed6af6e5518c122d94f4b8fea824fc7938bd5aa" translate="yes" xml:space="preserve">
          <source>This command will fetch changes from the remote branches to your remote-tracking branches &lt;code&gt;origin/*&lt;/code&gt;, and merge the default branch into the current branch.</source>
          <target state="translated">이 명령은 원격 브랜치에서 원격 추적 브랜치 &lt;code&gt;origin/*&lt;/code&gt; 로 변경 사항을 가져오고 기본 브랜치를 현재 브랜치로 병합합니다.</target>
        </trans-unit>
        <trans-unit id="99c24081605f25434a1fa0a51df82045bf4b7763" translate="yes" xml:space="preserve">
          <source>This command will save your changes away to the &lt;code&gt;stash&lt;/code&gt;, and reset your working tree and the index to match the tip of your current branch. Then you can make your fix as usual.</source>
          <target state="translated">이 명령은 변경 사항을 &lt;code&gt;stash&lt;/code&gt; 저장 하고 작업 트리와 색인을 현재 분기의 끝과 일치하도록 재설정합니다. 그런 다음 평소와 같이 수정을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb41b9bb98cbe715b8d6c0b50eb0b52309cdc91a" translate="yes" xml:space="preserve">
          <source>This commit will get blown away so a throw-away log message is OK.</source>
          <target state="translated">이 커밋은 사라져 버려 로그 아웃 메시지가 정상입니다.</target>
        </trans-unit>
        <trans-unit id="068d7057b3017084327709c3e61c2e224fb2a5f6" translate="yes" xml:space="preserve">
          <source>This commits all other changes in the index.</source>
          <target state="translated">이것은 인덱스의 다른 모든 변경 사항을 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="1d649ab8ff53024e7549864469811ccee0abf2e7" translate="yes" xml:space="preserve">
          <source>This commits your first edits in &lt;code&gt;branch1&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;branch1&lt;/code&gt; 에서 첫 번째 편집을 커밋합니다 .</target>
        </trans-unit>
        <trans-unit id="8bc13c84a009ea0d6abb173ac6100dc00ae7606a" translate="yes" xml:space="preserve">
          <source>This compares stage 2 (our branch), stage 3 (their branch) and the working tree file and outputs a combined diff, similar to the way &lt;code&gt;diff-tree&lt;/code&gt; shows a merge commit with these flags.</source>
          <target state="translated">이것은 단계 2 (우리의 분기), 단계 3 (그들의 분기) 및 작업 트리 파일을 비교하고 &lt;code&gt;diff-tree&lt;/code&gt; 가 이러한 플래그와의 병합 커밋을 표시하는 방식과 유사한 결합 된 diff를 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="d3fe164a17e549b712f12743eb90dc676fb8455c" translate="yes" xml:space="preserve">
          <source>This computation involves traversing all the reachable objects, i.e. it has the same cost as &lt;code&gt;git prune&lt;/code&gt;. It is primarily intended to fix corruption caused by garbage collecting using older versions of Git, which didn&amp;rsquo;t protect objects referred to by reflogs.</source>
          <target state="translated">이 계산에는 도달 가능한 모든 객체를 순회하는 것이 포함됩니다. 즉, &lt;code&gt;git prune&lt;/code&gt; 과 동일한 비용 을가 집니다. reflogs에 의해 참조되는 객체를 보호하지 않는 구 버전의 Git을 사용하여 가비지 수집으로 인한 손상을 수정하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="241f3360b1ffda93090a6212a837542c91b1e09e" translate="yes" xml:space="preserve">
          <source>This config option controls whether or not the given &lt;code&gt;&amp;lt;task&amp;gt;&lt;/code&gt; runs during a &lt;code&gt;git maintenance run --schedule=&amp;lt;frequency&amp;gt;&lt;/code&gt; command. The value must be one of &quot;hourly&quot;, &quot;daily&quot;, or &quot;weekly&quot;.</source>
          <target state="translated">이 구성 옵션 은 &lt;code&gt;git maintenance run --schedule=&amp;lt;frequency&amp;gt;&lt;/code&gt; 명령 중에 지정된 &lt;code&gt;&amp;lt;task&amp;gt;&lt;/code&gt; 가 실행 되는지 여부를 제어합니다 . 값은 &quot;매시간&quot;, &quot;매일&quot;또는 &quot;매주&quot;중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9e7c3905269f2318ce8a27a07b91b053d9dd7129" translate="yes" xml:space="preserve">
          <source>This configuration can be specified multiple times in order to allow multiple notes refs to be included. In that case, it will behave similarly to multiple &lt;code&gt;--[no-]notes[=]&lt;/code&gt; options passed in. That is, a value of &lt;code&gt;true&lt;/code&gt; will show the default notes, a value of &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; will also show notes from that notes ref and a value of &lt;code&gt;false&lt;/code&gt; will negate previous configurations and not show notes.</source>
          <target state="translated">여러 음표 참조가 포함되도록이 구성을 여러 번 지정할 수 있습니다. 이 경우 전달 된 여러 &lt;code&gt;--[no-]notes[=]&lt;/code&gt; 옵션 과 유사하게 작동합니다 . 즉, &lt;code&gt;true&lt;/code&gt; 값은 기본 메모를 표시하고 &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 값은 해당 메모의 메모를 표시합니다 ref 및 &lt;code&gt;false&lt;/code&gt; 값은 이전 구성을 무효화하고 메모를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0675827ca8d724102e17a053585b958058551f3d" translate="yes" xml:space="preserve">
          <source>This configuration doesn&amp;rsquo;t have any effect on authenticating to remote services; for that, see &lt;code&gt;credential.username&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">이 구성은 원격 서비스에 대한 인증에 영향을주지 않습니다. 이에 대해서는 &lt;a href=&quot;git-config&quot;&gt;git-config [1]의 &lt;/a&gt; &lt;code&gt;credential.username&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e6aa4372bde5e931f9e4e006e5a3cd0aea5ccf17" translate="yes" xml:space="preserve">
          <source>This configuration is used in two ways:</source>
          <target state="translated">이 구성은 두 가지 방식으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="06f31556dacb48424e7a1be662dd26364f785ce9" translate="yes" xml:space="preserve">
          <source>This configuration variable is useful in cases where you&amp;rsquo;d like to centrally configure your Git hooks instead of configuring them on a per-repository basis, or as a more flexible and centralized alternative to having an &lt;code&gt;init.templateDir&lt;/code&gt; where you&amp;rsquo;ve changed default hooks.</source>
          <target state="translated">이 구성 변수는 저장소별로 구성하는 대신 Git 후크를 중앙에서 구성하려는 경우 또는 기본 후크를 변경 한 &lt;code&gt;init.templateDir&lt;/code&gt; 대신에보다 유연하고 중앙화 된 대안으로 유용합니다 . .</target>
        </trans-unit>
        <trans-unit id="eed4a11499740f4bb5f61d3ce7354c5409f33bf3" translate="yes" xml:space="preserve">
          <source>This configures how whitespace is ignored when performing the move detection for &lt;code&gt;--color-moved&lt;/code&gt;. It can be set by the &lt;code&gt;diff.colorMovedWS&lt;/code&gt; configuration setting. These modes can be given as a comma separated list:</source>
          <target state="translated">&lt;code&gt;--color-moved&lt;/code&gt; 에 대한 이동 감지를 수행 할 때 공백이 무시되는 방식을 구성합니다 . &lt;code&gt;diff.colorMovedWS&lt;/code&gt; 구성 설정 으로 설정할 수 있습니다 . 이 모드는 쉼표로 구분 된 목록으로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b4ea1fd788cef298d939e77017eddec04b80461" translate="yes" xml:space="preserve">
          <source>This configures how whitespace is ignored when performing the move detection for &lt;code&gt;--color-moved&lt;/code&gt;. These modes can be given as a comma separated list:</source>
          <target state="translated">&lt;code&gt;--color-moved&lt;/code&gt; 에 대한 이동 감지를 수행 할 때 공백이 무시되는 방식을 구성합니다 . 이 모드는 쉼표로 구분 된 목록으로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77030a3f3e0bddf7aada34bc0939552bc0993e3c" translate="yes" xml:space="preserve">
          <source>This counts the number of unpacked object files and disk space consumed by them, to help you decide when it is a good time to repack.</source>
          <target state="translated">이것은 압축을 풀기 좋은시기를 결정하는 데 도움이되도록 압축 해제 된 오브젝트 파일 수와 디스크 공간이 소비하는 디스크 공간을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="3e67b0f2a3d6f811dcdec6a80edd2cc8d01b0b6b" translate="yes" xml:space="preserve">
          <source>This creates a &quot;lightweight&quot; tag. If you would also like to include a comment with the tag, and possibly sign it cryptographically, then you should create a tag object instead; see the &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; man page for details.</source>
          <target state="translated">&quot;가벼운&quot;태그가 생성됩니다. 태그에 주석을 포함하고 암호화로 서명하려면 태그 객체를 대신 만들어야합니다. 자세한 내용은 &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="687e61032de29ec5a828bf99d3854a432acd2a82" translate="yes" xml:space="preserve">
          <source>This creates a new directory &quot;myrepo&quot; containing a clone of Alice&amp;rsquo;s repository. The clone is on an equal footing with the original project, possessing its own copy of the original project&amp;rsquo;s history.</source>
          <target state="translated">그러면 Alice 저장소의 복제본이 포함 된 &quot;myrepo&quot;디렉토리가 새로 만들어집니다. 복제본은 원래 프로젝트 기록과 동일한 사본을 보유하고있는 원래 프로젝트와 동등한 위치에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2fd84fc2fa04021fed2cadb8707ca64b05a22fb" translate="yes" xml:space="preserve">
          <source>This creates a single &quot;pack file&quot; in .git/objects/pack/ containing all currently unpacked objects. You can then run</source>
          <target state="translated">이렇게하면 현재 압축이 풀린 모든 객체가 포함 된 .git / objects / pack /에 단일 &quot;팩 파일&quot;이 생성됩니다. 그런 다음 실행할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="bf43931e74b20a3da5197ed923f890fe71d72016" translate="yes" xml:space="preserve">
          <source>This default configuration is achieved by creating references to the remote branch heads under &lt;code&gt;refs/remotes/origin&lt;/code&gt; and by initializing &lt;code&gt;remote.origin.url&lt;/code&gt; and &lt;code&gt;remote.origin.fetch&lt;/code&gt; configuration variables.</source>
          <target state="translated">이 기본 구성은 &lt;code&gt;refs/remotes/origin&lt;/code&gt; 에서 원격 분기 헤드에 대한 참조를 작성 하고 &lt;code&gt;remote.origin.url&lt;/code&gt; 및 &lt;code&gt;remote.origin.fetch&lt;/code&gt; 구성 변수를 초기화하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="984768ad68337dfe2b0015e657c9f4f069afabc8" translate="yes" xml:space="preserve">
          <source>This defines two submodules, &lt;code&gt;libfoo&lt;/code&gt; and &lt;code&gt;libbar&lt;/code&gt;. These are expected to be checked out in the paths &lt;code&gt;include/foo&lt;/code&gt; and &lt;code&gt;include/bar&lt;/code&gt;, and for both submodules a URL is specified which can be used for cloning the submodules.</source>
          <target state="translated">여기에는 두 개의 서브 모듈 인 &lt;code&gt;libfoo&lt;/code&gt; 및 &lt;code&gt;libbar&lt;/code&gt; 가 정의 됩니다. 이들은 &lt;code&gt;include/foo&lt;/code&gt; 및 &lt;code&gt;include/bar&lt;/code&gt; 경로에서 체크 아웃 될 것으로 예상되며 , 두 서브 모듈 모두 서브 모듈 복제에 사용할 수있는 URL이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="57db5304522b1070a0df1071ce5df5d38ea7d002" translate="yes" xml:space="preserve">
          <source>This describes how Tony Luck uses Git in his role as maintainer of the IA64 architecture for the Linux kernel.</source>
          <target state="translated">여기에서는 Tony Luck이 Linux 커널의 IA64 아키텍처 관리자로서 Git을 어떻게 사용하는지 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c9e275f2996b22cd4415c594fae8f08a0dfe70e8" translate="yes" xml:space="preserve">
          <source>This determines the coloring scheme to be applied to blame output. It can be &lt;code&gt;repeatedLines&lt;/code&gt;, &lt;code&gt;highlightRecent&lt;/code&gt;, or &lt;code&gt;none&lt;/code&gt; which is the default.</source>
          <target state="translated">이것은 비난 출력에 적용될 채색 체계를 결정합니다. 그것은 될 수 &lt;code&gt;repeatedLines&lt;/code&gt; , &lt;code&gt;highlightRecent&lt;/code&gt; , 또는 &lt;code&gt;none&lt;/code&gt; 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="56ee29b22f07db9306c3380b74b5b0180828e415" translate="yes" xml:space="preserve">
          <source>This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/objects&quot; will be used instead.</source>
          <target state="translated">$ GIT_COMMON_DIR이 설정되고 대신 &quot;$ GIT_COMMON_DIR / objects&quot;가 사용되면이 디렉토리는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2072b137cd96280de0e098678b51f23a76dcd0dc" translate="yes" xml:space="preserve">
          <source>This disables potentially expensive checks to workaround broken symlinks checked into SVN by broken clients. Set this option to &quot;false&quot; if you track a SVN repository with many empty blobs that are not symlinks. This option may be changed while &lt;code&gt;git svn&lt;/code&gt; is running and take effect on the next revision fetched. If unset, &lt;code&gt;git svn&lt;/code&gt; assumes this option to be &quot;true&quot;.</source>
          <target state="translated">이로 인해 손상된 클라이언트가 SVN에 체크인 한 손상된 심볼릭 링크를 고칠 수있는 잠재적 인 검사가 비활성화됩니다. 심볼릭 링크가 아닌 빈 블롭이 많은 SVN 저장소를 추적하는 경우이 옵션을 &quot;false&quot;로 설정하십시오. 이 옵션은 &lt;code&gt;git svn&lt;/code&gt; 이 실행되는 동안 변경 될 수 있으며 가져온 다음 개정판에 적용됩니다. 설정하지 않으면 &lt;code&gt;git svn&lt;/code&gt; 은이 옵션을 &quot;true&quot;로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="006e62625e60aabc7f31fa591f6f9b4a3bd2a878" translate="yes" xml:space="preserve">
          <source>This document attempts to write down and motivate some of the workflow elements used for &lt;code&gt;git.git&lt;/code&gt; itself. Many ideas apply in general, though the full workflow is rarely required for smaller projects with fewer people involved.</source>
          <target state="translated">이 문서는 &lt;code&gt;git.git&lt;/code&gt; 자체에 사용 된 일부 워크 플로 요소를 작성하고 동기를 부여 합니다. 인원이 적은 소규모 프로젝트에는 전체 워크 플로우가 거의 필요하지 않지만 많은 아이디어가 일반적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8cd9193645885514540ac19f3167f508bebca422" translate="yes" xml:space="preserve">
          <source>This document presents a specification for a version 2 of Git&amp;rsquo;s wire protocol. Protocol v2 will improve upon v1 in the following ways:</source>
          <target state="translated">이 문서는 Git의 와이어 프로토콜 버전 2에 대한 사양을 제시합니다. 프로토콜 v2는 다음과 같은 방식으로 v1을 개선합니다.</target>
        </trans-unit>
        <trans-unit id="46bd1a26c48d1772be26d3d869cc4b6544004ea1" translate="yes" xml:space="preserve">
          <source>This document shows the &quot;raw&quot; syntax as seen by git. The shell and other UIs might require additional quoting to protect special characters and to avoid word splitting.</source>
          <target state="translated">이 문서는 git에서 볼 수있는 &quot;raw&quot;구문을 보여줍니다. 쉘 및 기타 UI에는 특수 문자를 보호하고 단어 분리를 피하기 위해 추가 인용이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a76f8971dde9f8810b677765aca0d70490d9f8fa" translate="yes" xml:space="preserve">
          <source>This document will serve as the master list for extensions. Any implementation wishing to define a new extension should make a note of it here, in order to claim the name.</source>
          <target state="translated">이 문서는 확장의 마스터 목록으로 사용됩니다. 새 확장명을 정의하려는 모든 구현은 이름을 주장하기 위해 여기에 메모해야합니다.</target>
        </trans-unit>
        <trans-unit id="d24a591988945bec7d040b25bd5a37c73014bcf3" translate="yes" xml:space="preserve">
          <source>This does not affect &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; or the &lt;code&gt;git-diff-*&lt;/code&gt; plumbing commands. Can be overridden on the command line with the &lt;code&gt;--color[=&amp;lt;when&amp;gt;]&lt;/code&gt; option.</source>
          <target state="translated">이것은 &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; 또는 &lt;code&gt;git-diff-*&lt;/code&gt; 배관 명령 에는 영향을 미치지 않습니다 . &lt;code&gt;--color[=&amp;lt;when&amp;gt;]&lt;/code&gt; 옵션 을 사용하여 명령 줄에서 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="99af460532d2c9f72e65ed17f7464c8aa563e1f4" translate="yes" xml:space="preserve">
          <source>This does not force normalization of text files, but does ensure that text files that you introduce to the repository have their line endings normalized to LF when they are added, and that files that are already normalized in the repository stay normalized.</source>
          <target state="translated">이렇게하면 텍스트 파일이 정규화되지 않지만 리포지토리에 도입 한 텍스트 파일의 행 끝이 추가 될 때 LF로 정규화되고 리포지토리에서 이미 정규화 된 파일이 정규화 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="257328db317fb853114a41f8430f87cd826d08a0" translate="yes" xml:space="preserve">
          <source>This doesn&amp;rsquo;t interfere with interoperating with the Subversion repository you cloned from, but if you wish for your local Git repository to be able to interoperate with someone else&amp;rsquo;s local Git repository, either don&amp;rsquo;t use this option or you should both use it in the same local time zone.</source>
          <target state="translated">복제 한 Subversion 저장소와의 상호 운용을 방해하지는 않지만 로컬 Git 저장소가 다른 사람의 로컬 Git 저장소와 상호 운용되도록하려면이 옵션을 사용하지 마십시오. 동일한 현지 시간대.</target>
        </trans-unit>
        <trans-unit id="45497ef8f3614492732f059c04bc30af3c6593e9" translate="yes" xml:space="preserve">
          <source>This effectively runs &lt;code&gt;add --interactive&lt;/code&gt;, but bypasses the initial command menu and directly jumps to the &lt;code&gt;patch&lt;/code&gt; subcommand. See &amp;ldquo;Interactive mode&amp;rdquo; for details.</source>
          <target state="translated">&lt;code&gt;add --interactive&lt;/code&gt; 를 효과적으로 실행 하지만 초기 명령 메뉴를 무시하고 &lt;code&gt;patch&lt;/code&gt; 하위 명령으로 바로 이동합니다 . 자세한 내용은 &quot;대화식 모드&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="53c54ba0465bbf9916ac436659dbf61aedb86156" translate="yes" xml:space="preserve">
          <source>This enables parent rewriting, see &lt;code&gt;History Simplification&lt;/code&gt; above.</source>
          <target state="translated">이렇게하면 부모 재 작성이 가능 합니다. 위의 &lt;code&gt;History Simplification&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ccdf590466d01d04dcf6da8ad6a6bec9f02c4d8e" translate="yes" xml:space="preserve">
          <source>This environment allows the specification of an alternate index file. If not specified, the default of &lt;code&gt;$GIT_DIR/index&lt;/code&gt; is used.</source>
          <target state="translated">이 환경에서는 대체 인덱스 파일을 지정할 수 있습니다. 지정하지 않으면 &lt;code&gt;$GIT_DIR/index&lt;/code&gt; 의 기본값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2abd55a6650395bf249165e2f6568e98ab14958c" translate="yes" xml:space="preserve">
          <source>This environment variable allows the specification of an index version for new repositories. It won&amp;rsquo;t affect existing index files. By default index file version 2 or 3 is used. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; for more information.</source>
          <target state="translated">이 환경 변수를 사용하면 새 리포지토리에 대한 인덱스 버전을 지정할 수 있습니다. 기존 색인 파일에는 영향을 미치지 않습니다. 기본적으로 색인 파일 버전 2 또는 3이 사용됩니다. 자세한 내용은 &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2763e4fc7ba1973ac90184c067d20f9d0fda70a8" translate="yes" xml:space="preserve">
          <source>This environment variable overrides &lt;code&gt;$EDITOR&lt;/code&gt; and &lt;code&gt;$VISUAL&lt;/code&gt;. It is used by several Git commands when, on interactive mode, an editor is to be launched. See also &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt; and the &lt;code&gt;core.editor&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">이 환경 변수는 &lt;code&gt;$EDITOR&lt;/code&gt; 및 &lt;code&gt;$VISUAL&lt;/code&gt; 대체 합니다. 대화식 모드에서 편집기를 시작할 때 여러 Git 명령에서 사용됩니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]의 &lt;/a&gt;&lt;a href=&quot;git-var&quot;&gt;git-var [1]&lt;/a&gt; 및 &lt;code&gt;core.editor&lt;/code&gt; 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ddbc158f0dcc3c8ea52494b42fbb66d15e06e460" translate="yes" xml:space="preserve">
          <source>This environment variable overrides &lt;code&gt;$PAGER&lt;/code&gt;. If it is set to an empty string or to the value &quot;cat&quot;, Git will not launch a pager. See also the &lt;code&gt;core.pager&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">이 환경 변수는 &lt;code&gt;$PAGER&lt;/code&gt; 대체 합니다. 빈 문자열 또는 &quot;cat&quot;값으로 설정되면 Git은 호출기를 시작하지 않습니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 &lt;code&gt;core.pager&lt;/code&gt; 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f82f561bc1110497edce7ce36b1651b7ef0d8603" translate="yes" xml:space="preserve">
          <source>This environment variable overrides the configured Git editor when editing the todo list of an interactive rebase. See also &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; and the &lt;code&gt;sequence.editor&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">이 환경 변수는 대화 형 리베이스의 할 일 목록을 편집 할 때 구성된 Git 편집기를 재정의합니다. &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; 및 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 &lt;code&gt;sequence.editor&lt;/code&gt; 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85b43d9b9e3f28d79e0c1169949e722bd8f10c35" translate="yes" xml:space="preserve">
          <source>This environment variable overrides the configured Git editor when editing the todo list of an interactive rebase. See also linkit::git-rebase[1] and the &lt;code&gt;sequence.editor&lt;/code&gt; option in linkit::git-config[1].</source>
          <target state="translated">This environment variable overrides the configured Git editor when editing the todo list of an interactive rebase. See also linkit::git-rebase[1] and the &lt;code&gt;sequence.editor&lt;/code&gt; option in linkit::git-config[1].</target>
        </trans-unit>
        <trans-unit id="25ea93764f52eb3dcc477c86398962bd9bbded98" translate="yes" xml:space="preserve">
          <source>This event contains the command name for this git process and the hierarchy of commands from parent git processes.</source>
          <target state="translated">이 이벤트에는이 자식 프로세스의 명령 이름과 부모 자식 프로세스의 명령 계층이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f5d9f72db5c7ffa9776d5c71964338d54a2515a4" translate="yes" xml:space="preserve">
          <source>This event contains the complete argv received by main().</source>
          <target state="translated">이 이벤트에는 main ()이 수신 한 전체 argv가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2a4c1f111536d47e2687ea692bfe5bd399b4307d" translate="yes" xml:space="preserve">
          <source>This event contains the discovered full path of the git executable (on platforms that are configured to resolve it).</source>
          <target state="translated">이 이벤트에는 git 실행 파일의 발견 된 전체 경로가 포함되어 있습니다 (해결하도록 구성된 플랫폼에서).</target>
        </trans-unit>
        <trans-unit id="c8af8dbf59abf700f44d6449c7c951b54692bd2e" translate="yes" xml:space="preserve">
          <source>This event defines a repo-id and associates it with the root of the worktree.</source>
          <target state="translated">이 이벤트는 repo-id를 정의하고 작업 트리의 루트와 연관시킵니다.</target>
        </trans-unit>
        <trans-unit id="efbcacd1a490c688869fdd46397140e75919d7ab" translate="yes" xml:space="preserve">
          <source>This event describes a child process that is about to be spawned.</source>
          <target state="translated">이 이벤트는 생성 될 자식 프로세스를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8c8f935852467fd7c3b46787d77518dc3611a986" translate="yes" xml:space="preserve">
          <source>This event gives the version of the executable and the EVENT format. It should always be the first event in a trace session. The EVENT format version will be incremented if new event types are added, if existing fields are removed, or if there are significant changes in interpretation of existing events or fields. Smaller changes, such as adding a new field to an existing event, will not require an increment to the EVENT format version.</source>
          <target state="translated">이 이벤트는 실행 파일 버전과 EVENT 형식을 제공합니다. 항상 추적 세션에서 첫 번째 이벤트 여야합니다. EVENT 형식 버전은 새 이벤트 유형이 추가되거나 기존 필드가 제거되거나 기존 이벤트 또는 필드의 해석에 상당한 변경이있는 경우 증가합니다. 기존 이벤트에 새 필드를 추가하는 등의 작은 변경으로 EVENT 형식 버전을 증분 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ea085d0e611d87af89c62af2b70656c0016dc7e" translate="yes" xml:space="preserve">
          <source>This event is emitted by the Trace2 &lt;code&gt;atexit&lt;/code&gt; routine during final shutdown. It should be the last event emitted by the process.</source>
          <target state="translated">이 이벤트는 최종 종료 중에 Trace2 &lt;code&gt;atexit&lt;/code&gt; 루틴에 의해 생성됩니다 . 프로세스에서 생성 한 마지막 이벤트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0b20979b7d0436896a9e4dd619b31c2f047cbd64" translate="yes" xml:space="preserve">
          <source>This event is emitted when git calls &lt;code&gt;exit()&lt;/code&gt;.</source>
          <target state="translated">이 이벤트는 git가 &lt;code&gt;exit()&lt;/code&gt; 호출 할 때 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7857843019d5043272d37ee889b33f311c45158" translate="yes" xml:space="preserve">
          <source>This event is emitted when one of the &lt;code&gt;error()&lt;/code&gt;, &lt;code&gt;die()&lt;/code&gt;, &lt;code&gt;warning()&lt;/code&gt;, or &lt;code&gt;usage()&lt;/code&gt; functions are called.</source>
          <target state="translated">이 이벤트는 &lt;code&gt;error()&lt;/code&gt; , &lt;code&gt;die()&lt;/code&gt; , &lt;code&gt;warning()&lt;/code&gt; 또는 &lt;code&gt;usage()&lt;/code&gt; 함수 중 하나가 호출 될 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9c63cb7135e802e553dc499a675da732d4f96c3a" translate="yes" xml:space="preserve">
          <source>This event is emitted when one of the &lt;code&gt;error()&lt;/code&gt;, &lt;code&gt;die()&lt;/code&gt;, or &lt;code&gt;usage()&lt;/code&gt; functions are called.</source>
          <target state="translated">이 이벤트는 &lt;code&gt;error()&lt;/code&gt; , &lt;code&gt;die()&lt;/code&gt; 또는 &lt;code&gt;usage()&lt;/code&gt; 함수 중 하나가 호출 될 때 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ebb8b872e605289564f67171a3133d84781ab210" translate="yes" xml:space="preserve">
          <source>This event is emitted when the program is terminated by a user signal. Depending on the platform, the signal event may prevent the &quot;atexit&quot; event from being generated.</source>
          <target state="translated">이 이벤트는 프로그램이 사용자 신호에 의해 종료 될 때 생성됩니다. 플랫폼에 따라 신호 이벤트로 인해 &quot;atexit&quot;이벤트가 생성되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ca8802f12c75856c4e7ea399ac7a1939e2a37eb" translate="yes" xml:space="preserve">
          <source>This event is generated after the current process has returned from the waitpid() and collected the exit information from the child.</source>
          <target state="translated">이 이벤트는 현재 프로세스가 waitpid ()에서 리턴되고 자식에서 종료 정보를 수집 한 후에 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="9fe6d803410a7d3a5cd4bc2114534352d230200b" translate="yes" xml:space="preserve">
          <source>This event is generated before git attempts to &lt;code&gt;exec()&lt;/code&gt; another command rather than starting a child process.</source>
          <target state="translated">이 이벤트는 자식 프로세스를 시작하지 않고 git이 다른 명령 을 &lt;code&gt;exec()&lt;/code&gt; 하려고 시도하기 전에 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="93caa8939f471f1240286ec30c6905ef3996f20e" translate="yes" xml:space="preserve">
          <source>This event is generated if the &lt;code&gt;exec()&lt;/code&gt; fails and control returns to the current git command.</source>
          <target state="translated">이 이벤트는 &lt;code&gt;exec()&lt;/code&gt; 가 실패하고 제어가 현재 git 명령으로 리턴되는 경우 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="15a0b5629f08a42566247fd3e8af69adc717eef8" translate="yes" xml:space="preserve">
          <source>This event is generated to log a global parameter, such as a config setting, command-line flag, or environment variable.</source>
          <target state="translated">This event is generated to log a global parameter, such as a config setting, command-line flag, or environment variable.</target>
        </trans-unit>
        <trans-unit id="814427d239ec02f31ac7bf0fb913766e18bfb53e" translate="yes" xml:space="preserve">
          <source>This event is generated to log a global parameter.</source>
          <target state="translated">이 이벤트는 전역 매개 변수를 기록하기 위해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="54b6cc61590e1e0eba249cc8ddd71ddff154355b" translate="yes" xml:space="preserve">
          <source>This event is generated to log a pre-formatted JSON string containing structured data.</source>
          <target state="translated">이 이벤트는 구조화 된 데이터를 포함하는 사전 형식화 된 JSON 문자열을 기록하기 위해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0ee97bbcf1fde0cf306363257efe6b7de578045e" translate="yes" xml:space="preserve">
          <source>This event is generated to log a thread- and region-local key/value pair.</source>
          <target state="translated">이 이벤트는 스레드 및 지역 로컬 키 / 값 쌍을 기록하기 위해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4caa8d05330c9e1126d8391705e312b0d8975d63" translate="yes" xml:space="preserve">
          <source>This event is generated when a thread exits. It is generated from &lt;strong&gt;within&lt;/strong&gt; the thread&amp;rsquo;s thread-proc (for TLS reasons).</source>
          <target state="translated">이 이벤트는 스레드가 종료 될 때 생성됩니다. 스레드의 thread-proc &lt;strong&gt;내&lt;/strong&gt; 에서 생성됩니다 (TLS 이유로).</target>
        </trans-unit>
        <trans-unit id="eba565beaf1b2269c764c147f5196869afe38bce" translate="yes" xml:space="preserve">
          <source>This event is generated when a thread is started. It is generated from &lt;strong&gt;within&lt;/strong&gt; the new thread&amp;rsquo;s thread-proc (for TLS reasons).</source>
          <target state="translated">이 이벤트는 스레드가 시작될 때 생성됩니다. 새 스레드의 thread-proc &lt;strong&gt;내&lt;/strong&gt; 에서 생성됩니다 (TLS 이유로).</target>
        </trans-unit>
        <trans-unit id="1684fe3e3862662b36c1dfb0c9bb20558e1f338a" translate="yes" xml:space="preserve">
          <source>This event is generated when entering a region.</source>
          <target state="translated">이 이벤트는 지역을 입력 할 때 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="809d72e4f54bac6c7054af4e990fa8c97e8c764d" translate="yes" xml:space="preserve">
          <source>This event is generated when leaving a region.</source>
          <target state="translated">이 이벤트는 지역을 떠날 때 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="1e6a7368deeb7ec580313fc82400f1c12d17672a" translate="yes" xml:space="preserve">
          <source>This event is present when an alias is expanded.</source>
          <target state="translated">이 이벤트는 별명이 확장 될 때 나타납니다.</target>
        </trans-unit>
        <trans-unit id="bca802363ffa9599d9e13df71e2f62ec1454e32f" translate="yes" xml:space="preserve">
          <source>This event is written to the git-trace2-discard sentinel file if there are too many files in the target trace directory (see the trace2.maxFiles config option).</source>
          <target state="translated">대상 추적 디렉토리에 파일이 너무 많으면이 이벤트가 git-trace2-discard 센티넬 파일에 기록됩니다 (trace2.maxFiles 구성 옵션 참조).</target>
        </trans-unit>
        <trans-unit id="8c2ad60a0d9356a6e908b18056fbac1c2b1d4129" translate="yes" xml:space="preserve">
          <source>This event, when present, describes the command variant This event may be emitted more than once.</source>
          <target state="translated">이 이벤트는 존재할 경우 명령 변형을 설명합니다.이 이벤트는 두 번 이상 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e7d09cee878b03064fb9d9484c73f3f00225826" translate="yes" xml:space="preserve">
          <source>This example also shows that thread names are assigned in a racy manner as each thread starts and allocates TLS storage.</source>
          <target state="translated">이 예제는 또한 각 스레드가 시작되고 TLS 스토리지를 할당 할 때 스레드 이름이 복잡한 방식으로 지정됨을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e296b28f1fcad64b66f85f9abe931f54fc5fbde0" translate="yes" xml:space="preserve">
          <source>This example imports a new remote &quot;p4/proj2&quot; into an existing Git repository:</source>
          <target state="translated">이 예에서는 새 원격 &quot;p4 / proj2&quot;를 기존 Git 저장소로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7cbbc9fac80d3f9e05217d26ad6f34ea5097abe6" translate="yes" xml:space="preserve">
          <source>This example shows that the index contained 3552 entries.</source>
          <target state="translated">이 예는 색인에 3552 개의 항목이 포함되어 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="af5672891a1be21669d22b688901415e2cf060c3" translate="yes" xml:space="preserve">
          <source>This expands to the object name of the delta base for the given object, if it is stored as a delta. Otherwise it expands to the null object name (all zeroes).</source>
          <target state="translated">이는 델타로 저장된 경우 지정된 오브젝트에 대한 델타베이스의 오브젝트 이름으로 확장됩니다. 그렇지 않으면 널 오브젝트 이름 (모두 0)으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="1a642986ccbacca12888668bff4ca6d3b1007b62" translate="yes" xml:space="preserve">
          <source>This explanation comes for &quot;free&quot; because there was no change. Similarly &lt;code&gt;C&lt;/code&gt; could be explained using &lt;code&gt;1&lt;/code&gt;, but that comes at some cost c&amp;gt;0 because of the modification:</source>
          <target state="translated">이 설명은 아무런 변화가 없었기 때문에 &quot;무료&quot;입니다. 마찬가지로 &lt;code&gt;C&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 을 사용하여 설명 할 수 있지만 수정으로 인해 비용이 c&amp;gt; 0입니다.</target>
        </trans-unit>
        <trans-unit id="86a0b58a904e042293eb0ea80455653f123e7d4e" translate="yes" xml:space="preserve">
          <source>This extended format can be useful if rename or copy detection is active, to allow you to see the original name of the file in different parents.</source>
          <target state="translated">이 확장 형식은 다른 부모에서 파일의 원래 이름을 볼 수 있도록 이름 바꾸기 또는 복사 감지가 활성화 된 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc95481325c82bdecdaa23291b735168b05af418" translate="yes" xml:space="preserve">
          <source>This extension does not change git&amp;rsquo;s behavior at all. It is useful only for testing format-1 compatibility.</source>
          <target state="translated">이 확장은 git의 동작을 전혀 변경하지 않습니다. 형식 1 호환성 테스트에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="24a20ccff9f7f9f91cdf61fb876086b44fc5be61" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis by setting repository&amp;rsquo;s &lt;code&gt;gitweb.pickaxe&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">이 기능은 리포지토리의 &lt;code&gt;gitweb.pickaxe&lt;/code&gt; 구성 변수 (부울) 를 설정하여 리포지토리별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fcd9d965aa29d51e3ab01e56c522e086b7f545b" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.avatar&lt;/code&gt; configuration variable.</source>
          <target state="translated">이 기능은 리포지토리의 &lt;code&gt;gitweb.avatar&lt;/code&gt; 구성 변수 를 통해 리포지토리별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da6908103a49ae5e820a33c13aadd5dfdd3e67a7" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.blame&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">이 기능은 리포지토리의 &lt;code&gt;gitweb.blame&lt;/code&gt; 구성 변수 (부울) 를 통해 리포지토리별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d6d167abae14ab18966eab440f954ed6085f29c" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.grep&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">이 기능은 리포지토리의 &lt;code&gt;gitweb.grep&lt;/code&gt; 구성 변수 (부울) 를 통해 리포지토리별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd4f802848cf6cbdc7682aeefb00472f2c444c9e" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.highlight&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">이 기능은 리포지토리의 &lt;code&gt;gitweb.highlight&lt;/code&gt; 구성 변수 (부울) 를 통해 리포지토리별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8e82652b1c51e397e7f1e31621e9084d5611fda" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.patches&lt;/code&gt; configuration variable (integer).</source>
          <target state="translated">이 기능은 저장소의 &lt;code&gt;gitweb.patches&lt;/code&gt; 구성 변수 (정수) 를 통해 저장소별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0528d6fc23cb2716835712f44b5daf955251062" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.remote_heads&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">이 기능은 저장소의 &lt;code&gt;gitweb.remote_heads&lt;/code&gt; 구성 변수 (부울) 를 통해 저장소별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58b983175f59d7aad97dac71b32251a2f4a8c4a0" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.showSizes&lt;/code&gt; configuration variable (boolean).</source>
          <target state="translated">이 기능은 리포지토리의 &lt;code&gt;gitweb.showSizes&lt;/code&gt; 구성 변수 (부울) 를 통해 리포지토리별로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee33afe943a28f48529ed67cc410ad185ea09f23" translate="yes" xml:space="preserve">
          <source>This feature can be configured on a per-repository basis via repository&amp;rsquo;s &lt;code&gt;gitweb.snapshot&lt;/code&gt; configuration variable, which contains a comma separated list of formats or &quot;none&quot; to disable snapshots. Unknown values are ignored.</source>
          <target state="translated">이 기능은 저장소의 &lt;code&gt;gitweb.snapshot&lt;/code&gt; 구성 변수 를 통해 저장소별로 구성 할 수 있습니다 . 여기에는 쉼표로 구분 된 형식 목록 또는 스냅 샷을 비활성화하는 &quot;없음&quot;이 포함됩니다. 알 수없는 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c2467a6f49bad0810d0f5e1c4a51888ceb4f5b0f" translate="yes" xml:space="preserve">
          <source>This feature can be configured on per-repository basis after setting $feature{&lt;code&gt;extra-branch-refs&lt;/code&gt;}{&lt;code&gt;override&lt;/code&gt;} to true, via repository&amp;rsquo;s &lt;code&gt;gitweb.extraBranchRefs&lt;/code&gt; configuration variable, which contains a space separated list of refs. An example:</source>
          <target state="translated">이 기능은 공백으로 구분 된 참조 목록을 포함하는 저장소의 &lt;code&gt;gitweb.extraBranchRefs&lt;/code&gt; 구성 변수 를 통해 $ feature { &lt;code&gt;extra-branch-refs&lt;/code&gt; } { &lt;code&gt;override&lt;/code&gt; }를 true로 설정 한 후 저장소별로 구성 할 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="83b4612ad81d70c9ed8920a4b451b69b8c3ee080" translate="yes" xml:space="preserve">
          <source>This feature is intended to speed up git operations for repos that have large working directories.</source>
          <target state="translated">이 기능은 큰 작업 디렉토리가있는 저장소의 git 작업 속도를 높이기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6b24b487d6d9654020073f6754733ecc051175ad" translate="yes" xml:space="preserve">
          <source>This feature is semi-deprecated. For scripting purpose, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt;&lt;code&gt;--porcelain&lt;/code&gt; and &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt;&lt;code&gt;--name-status&lt;/code&gt; are almost always superior alternatives, and users should look at &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt;&lt;code&gt;--short&lt;/code&gt; or &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--name-status&lt;/code&gt; for more user-friendly alternatives.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 스크립팅 목적으로 &lt;a href=&quot;git-status&quot;&gt;git-status [1] &lt;/a&gt; &lt;code&gt;--porcelain&lt;/code&gt; 및 &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1] &lt;/a&gt; &lt;code&gt;--name-status&lt;/code&gt; 는 거의 항상 우수한 대안이며 사용자는 &lt;a href=&quot;git-status&quot;&gt;git-status [1] &lt;/a&gt; &lt;code&gt;--short&lt;/code&gt; 또는 &lt;a href=&quot;git-diff&quot;&gt;git-&lt;/a&gt; 보다 사용자 친화적 인 대안을위한 diff [1] &lt;code&gt;--name-status&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0861edc399d3214fad2ecef2c8c7d8f9e28b4564" translate="yes" xml:space="preserve">
          <source>This feature is useful when an established project should be accepted despite early commits containing errors that can be safely ignored such as invalid committer email addresses. Note: corrupt objects cannot be skipped with this setting.</source>
          <target state="translated">이 기능은 유효하지 않은 커미터 이메일 주소와 같이 무시해도되는 오류가 포함 된 초기 커밋에도 불구하고 설정된 프로젝트를 수락해야 할 때 유용합니다. 참고 :이 설정으로는 손상된 개체를 건너 뛸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5474f37d061902594342fbe38be401770ea2769f" translate="yes" xml:space="preserve">
          <source>This feature works by recording the mtime of the working tree directories and then omitting reading directories and stat calls against files in those directories whose mtime hasn&amp;rsquo;t changed. For this to work the underlying operating system and file system must change the &lt;code&gt;st_mtime&lt;/code&gt; field of directories if files in the directory are added, modified or deleted.</source>
          <target state="translated">이 기능은 작업 트리 디렉토리의 mtime을 기록한 다음 mtime이 변경되지 않은 디렉토리의 파일에 대한 디렉토리 및 stat 호출 읽기를 생략하여 작동합니다. 이것이 작동하려면 기본 운영 체제 및 파일 시스템 이 디렉토리의 파일이 추가, 수정 또는 삭제 된 경우 디렉토리 의 &lt;code&gt;st_mtime&lt;/code&gt; 필드를 변경해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ef2541ade640bd800921de0e87cda6dd56d4d5f6" translate="yes" xml:space="preserve">
          <source>This fetches revisions from the SVN parent of the current HEAD and rebases the current (uncommitted to SVN) work against it.</source>
          <target state="translated">현재 HEAD의 SVN 상위에서 수정본을 가져오고 현재 SVN에 커밋되지 않은 작업을 리베이스합니다.</target>
        </trans-unit>
        <trans-unit id="e6f84c5c8c6a08793025b9538660cbd1c1faa637" translate="yes" xml:space="preserve">
          <source>This file contains the commit message of a commit in progress. If &lt;code&gt;git commit&lt;/code&gt; exits due to an error before creating a commit, any commit message that has been provided by the user (e.g., in an editor session) will be available in this file, but will be overwritten by the next invocation of &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">이 파일에는 진행중인 커밋의 커밋 메시지가 들어 있습니다. 경우 &lt;code&gt;git commit&lt;/code&gt; 커밋 만들기 전에 오류로 인해 종료, 어떤이 파일에 사용할 수 있습니다 (편집기 세션에서 예) 사용자가 제공 한 커밋 메시지 만의 다음의 호출을 덮어 씁니다 &lt;code&gt;git commit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2063696fd909d95d720efff6859f2846f7a33789" translate="yes" xml:space="preserve">
          <source>This file helps dumb transports discover what refs are available in this repository. If the repository is published for dumb transports, this file should be regenerated by &lt;code&gt;git update-server-info&lt;/code&gt; every time a tag or branch is created or modified. This is normally done from the &lt;code&gt;hooks/update&lt;/code&gt; hook, which is run by the &lt;code&gt;git-receive-pack&lt;/code&gt; command when you &lt;code&gt;git push&lt;/code&gt; into the repository.</source>
          <target state="translated">이 파일은 바보 전송이이 저장소에서 사용 가능한 참조를 발견하는 데 도움이됩니다. 저장소가 바보 전송 용으로 게시 된 경우이 파일은 태그 또는 분기를 만들거나 수정할 때마다 &lt;code&gt;git update-server-info&lt;/code&gt; 에 의해 재생성되어야합니다 . 이것은 일반적으로 &lt;code&gt;hooks/update&lt;/code&gt; 후크 에서 수행되며, 후크를 저장소로 &lt;code&gt;git push&lt;/code&gt; 할 때 &lt;code&gt;git-receive-pack&lt;/code&gt; 명령으로 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="3487083c7b98c66e39acc8f940f40c0e9ceac88f" translate="yes" xml:space="preserve">
          <source>This file is to help dumb transports discover what packs are available in this object store. Whenever a pack is added or removed, &lt;code&gt;git update-server-info&lt;/code&gt; should be run to keep this file up to date if the repository is published for dumb transports. &lt;code&gt;git repack&lt;/code&gt; does this by default.</source>
          <target state="translated">이 파일은 바보 전송이이 오브젝트 저장소에서 사용 가능한 팩을 발견하는 데 도움이됩니다. 팩이 추가되거나 제거 될 때마다 저장소가 벙어리 전송 용으로 게시 된 경우이 파일을 최신 상태로 유지하려면 &lt;code&gt;git update-server-info&lt;/code&gt; 를 실행해야합니다. &lt;code&gt;git repack&lt;/code&gt; 은 기본적으로 이것을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="cbe65e34529f44f10bf3c4bc531b3ef1a1689dfb" translate="yes" xml:space="preserve">
          <source>This file mainly serves as the mapping between the name and path of submodules in the superproject, such that the submodule&amp;rsquo;s Git directory can be located.</source>
          <target state="translated">이 파일은 주로 수퍼 프로젝트에서 하위 모듈의 이름과 경로 간의 매핑 역할을하여 하위 모듈의 Git 디렉토리를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="071050e2544b6fc3703fb63508bbfdc9243b46ab" translate="yes" xml:space="preserve">
          <source>This file records URLs to alternate object stores that this object store borrows objects from, to be used when the repository is fetched over HTTP.</source>
          <target state="translated">이 파일은 URL을 기록하여이 오브젝트 저장소가 오브젝트를 차용 한 대체 오브젝트 저장소에 URL을 기록하여 저장소가 HTTP를 통해 페치 될 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cc3397ff622f0d4d27f532099612807583041388" translate="yes" xml:space="preserve">
          <source>This file records fake commit ancestry information, to pretend the set of parents a commit has is different from how the commit was actually created. One record per line describes a commit and its fake parents by listing their 40-byte hexadecimal object names separated by a space and terminated by a newline.</source>
          <target state="translated">이 파일은 가짜 커밋 조상 정보를 기록하여 커밋이있는 부모 세트가 실제로 커밋이 생성 된 방식과 다른 척합니다. 라인 당 하나의 레코드는 40 바이트의 16 진 오브젝트 이름을 공백으로 구분하고 개행으로 종료하여 커밋 및 가짜 부모를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1873ba1c652fc3e8dae8a41ecd45dff2c995baaf" translate="yes" xml:space="preserve">
          <source>This file records paths to alternate object stores that this object store borrows objects from, one pathname per line. Note that not only native Git tools use it locally, but the HTTP fetcher also tries to use it remotely; this will usually work if you have relative paths (relative to the object database, not to the repository!) in your alternates file, but it will not work if you use absolute paths unless the absolute path in filesystem and web URL is the same. See also &lt;code&gt;objects/info/http-alternates&lt;/code&gt;.</source>
          <target state="translated">이 파일은이 오브젝트 저장소가 오브젝트를 빌려 오는 대체 오브젝트 저장소에 대한 경로를 한 줄에 하나씩 경로로 기록합니다. 기본 Git 도구는 로컬 Git 도구를 사용할뿐만 아니라 HTTP 페처도이를 원격으로 사용하려고합니다. 대체 파일에 상대 경로 (저장소가 아닌 객체 데이터베이스에 상대적인 경로)가있는 경우 일반적으로 작동하지만 파일 시스템과 웹 URL의 절대 경로가 동일하지 않으면 절대 경로를 사용하면 작동하지 않습니다. &lt;code&gt;objects/info/http-alternates&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="517ab2689bb34239adf0b92ebb2a70e736956866" translate="yes" xml:space="preserve">
          <source>This file stores sparse checkout patterns. See also: &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt;.</source>
          <target state="translated">이 파일은 드문 체크 아웃 패턴을 저장합니다. &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="39e8ca5394d81b30bccd145a749de9346fba2480" translate="yes" xml:space="preserve">
          <source>This file uses the following format:</source>
          <target state="translated">이 파일은 다음 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="53c1d1d0fe83b95fe57b9ac9f6f59413589df721" translate="yes" xml:space="preserve">
          <source>This file, by convention among Porcelains, stores the exclude pattern list. &lt;code&gt;.gitignore&lt;/code&gt; is the per-directory ignore file. &lt;code&gt;git status&lt;/code&gt;, &lt;code&gt;git add&lt;/code&gt;, &lt;code&gt;git rm&lt;/code&gt; and &lt;code&gt;git clean&lt;/code&gt; look at it but the core Git commands do not look at it. See also: &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;.</source>
          <target state="translated">이 파일은 도자기의 규칙에 따라 제외 패턴 목록을 저장합니다. &lt;code&gt;.gitignore&lt;/code&gt; 는 디렉토리 별 무시 파일입니다. &lt;code&gt;git status&lt;/code&gt; , &lt;code&gt;git add&lt;/code&gt; , &lt;code&gt;git rm&lt;/code&gt; 및 &lt;code&gt;git clean&lt;/code&gt; 이 그것을 보지만 핵심 Git 명령은 그것을 보지 않습니다. &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8956b9fdca3244ff8cd9467aefdc82ab275d878" translate="yes" xml:space="preserve">
          <source>This filter may be used if you only need to modify the environment in which the commit will be performed. Specifically, you might want to rewrite the author/committer name/email/time environment variables (see &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; for details).</source>
          <target state="translated">커밋이 수행 될 환경 만 수정해야하는 경우이 필터를 사용할 수 있습니다. 특히 작성자 / 커미터 이름 / 이메일 / 시간 환경 변수를 다시 작성할 수 있습니다 (자세한 내용은 &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree [1]&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="1f7d9b6979d573a6d61c7fc37aef6ce7f09ba079" translate="yes" xml:space="preserve">
          <source>This flag causes &lt;code&gt;git diff-tree --stdin&lt;/code&gt; to also show the commit message before the differences.</source>
          <target state="translated">이 플래그는 &lt;code&gt;git diff-tree --stdin&lt;/code&gt; 이 차이 전에 커밋 메시지를 표시하도록합니다.</target>
        </trans-unit>
        <trans-unit id="f18c1480999d4a64a19b051751a1dfdb3d01c394" translate="yes" xml:space="preserve">
          <source>This flag causes an object already in a local pack that has a .keep file to be ignored, even if it would have otherwise been packed.</source>
          <target state="translated">이 플래그는 .keep 파일이있는 로컬 팩에 이미있는 오브젝트가 다른 방식으로 압축되어 있어도 무시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="3b2c5aa43d85ae95c70f7126e1a8d471a0247285" translate="yes" xml:space="preserve">
          <source>This flag causes an object already in a pack to be ignored even if it would have otherwise been packed.</source>
          <target state="translated">이 플래그는 팩에 이미있는 오브젝트가 달리 패킹 된 경우에도 무시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="936ccdd465b71c76f59e3d7929f0e31e3a24c431" translate="yes" xml:space="preserve">
          <source>This flag causes an object already in the given pack to be ignored, even if it would have otherwise been packed. &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; is the pack file name without leading directory (e.g. &lt;code&gt;pack-123.pack&lt;/code&gt;). The option could be specified multiple times to keep multiple packs.</source>
          <target state="translated">이 플래그는 지정된 팩에 이미있는 오브젝트가 다른 방식으로 패킹 된 경우에도 무시되도록합니다. &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; 은 선행 디렉토리가없는 팩 파일 이름입니다 (예 : &lt;code&gt;pack-123.pack&lt;/code&gt; ). 여러 팩을 유지하기 위해 옵션을 여러 번 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fad47cb9db9729fbeb177e82626a6322dbefd6c" translate="yes" xml:space="preserve">
          <source>This flag causes an object that is borrowed from an alternate object store to be ignored even if it would have otherwise been packed.</source>
          <target state="translated">이 플래그는 대체 오브젝트 저장소에서 빌린 오브젝트가 다른 방식으로 압축되어 있어도 무시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="97fddffea713eaa9774ecf695b0619f959916c25" translate="yes" xml:space="preserve">
          <source>This flag causes combined diffs (used for merge commits) to list the name of the file from all parents. It thus only has effect when -c or --cc are specified, and is likely only useful if filename changes are detected (i.e. when either rename or copy detection have been requested).</source>
          <target state="translated">이 플래그는 결합 된 diff (병합 커밋에 사용)가 모든 부모의 파일 이름을 나열하게합니다. 따라서 -c 또는 --cc가 지정된 경우에만 효과가 있으며 파일 이름 변경이 감지 된 경우 (예 : 이름 바꾸기 또는 복사 감지가 요청 된 경우)에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7d04699c745135d6f14712a3d65005478838c3a7" translate="yes" xml:space="preserve">
          <source>This flag changes the way a merge commit is displayed (which means it is useful only when the command is given one &amp;lt;tree-ish&amp;gt;, or &lt;code&gt;--stdin&lt;/code&gt;). It shows the differences from each of the parents to the merge result simultaneously instead of showing pairwise diff between a parent and the result one at a time (which is what the &lt;code&gt;-m&lt;/code&gt; option does). Furthermore, it lists only files which were modified from all parents.</source>
          <target state="translated">이 플래그는 병합 커밋이 표시되는 방식을 변경합니다 (즉, 명령에 &amp;lt;tree-ish&amp;gt; 또는 &lt;code&gt;--stdin&lt;/code&gt; 이 지정된 경우에만 유용함 ). 한 번에 하나씩 부모와 결과 사이에 쌍별 차이를 표시하는 대신 각 부모와 병합 결과의 차이점을 동시에 표시합니다 ( &lt;code&gt;-m&lt;/code&gt; 옵션의 기능). 또한 모든 상위에서 수정 된 파일 만 나열합니다.</target>
        </trans-unit>
        <trans-unit id="0d503f20848f4e1ff6c5e78038f4bce28f3422a3" translate="yes" xml:space="preserve">
          <source>This flag changes the way a merge commit patch is displayed, in a similar way to the &lt;code&gt;-c&lt;/code&gt; option. It implies the &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-p&lt;/code&gt; options and further compresses the patch output by omitting uninteresting hunks whose the contents in the parents have only two variants and the merge result picks one of them without modification. When all hunks are uninteresting, the commit itself and the commit log message is not shown, just like in any other &quot;empty diff&quot; case.</source>
          <target state="translated">이 플래그는 &lt;code&gt;-c&lt;/code&gt; 옵션 과 유사한 방식으로 병합 커밋 패치가 표시되는 방식을 변경합니다 . &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-p&lt;/code&gt; 옵션을 내포하고 부모의 내용에 두 가지 변형 만 있고 병합 결과가 수정없이 이들 중 하나를 선택하는 흥미없는 덩어리를 생략하여 패치 출력을 추가로 압축합니다. 모든 덩어리가 흥미롭지 않은 경우, 다른 &quot;빈 차이&quot;경우와 같이 커밋 자체와 커밋 로그 메시지가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4835250d6cbee97633146544cd1896afcc631099" translate="yes" xml:space="preserve">
          <source>This flag disables these checks, and can cause the remote repository to lose commits; use it with care.</source>
          <target state="translated">이 플래그는 이러한 검사를 비활성화하며 원격 저장소가 커밋을 잃을 수 있습니다. 조심해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cc5f19786a1b0eda7705eaaa80c372612ab5d782" translate="yes" xml:space="preserve">
          <source>This flag implies the &lt;code&gt;-c&lt;/code&gt; option and further compresses the patch output by omitting uninteresting hunks whose contents in the parents have only two variants and the merge result picks one of them without modification.</source>
          <target state="translated">이 플래그는 &lt;code&gt;-c&lt;/code&gt; 옵션을 암시하고 부모의 내용에 변형이 두 개 뿐이고 병합 결과가 수정없이 그 중 하나를 선택하는 흥미없는 덩어리를 생략하여 패치 출력을 추가로 압축합니다.</target>
        </trans-unit>
        <trans-unit id="03d7872e2a4e991418dc3ea26303b414cb645f27" translate="yes" xml:space="preserve">
          <source>This flag is passed to the &lt;code&gt;git apply&lt;/code&gt; program (see &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;) that applies the patch. Implies --apply.</source>
          <target state="translated">This flag is passed to the &lt;code&gt;git apply&lt;/code&gt; program (see &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;) that applies the patch. Implies --apply.</target>
        </trans-unit>
        <trans-unit id="6c9f2e241df42ed566896490c4c1723461343597" translate="yes" xml:space="preserve">
          <source>This flag is passed to the &lt;code&gt;git log&lt;/code&gt; program (see &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;) that generates the patches.</source>
          <target state="translated">이 플래그는 패치를 생성하는 &lt;code&gt;git log&lt;/code&gt; 프로그램 ( &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 참조)으로 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="7d74132f018d1e29c74648fc0cf6690a80cd700b" translate="yes" xml:space="preserve">
          <source>This flag makes the command not to report its progress on the standard error stream.</source>
          <target state="translated">이 플래그는 명령이 표준 오류 스트림에서 진행 상황을보고하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="c7300f914a6246e85c4558f9e03e3ac6bd2957c2" translate="yes" xml:space="preserve">
          <source>This flag makes the merge commits show the full diff like regular commits; for each merge parent, a separate log entry and diff is generated. An exception is that only diff against the first parent is shown when &lt;code&gt;--first-parent&lt;/code&gt; option is given; in that case, the output represents the changes the merge brought &lt;code&gt;into&lt;/code&gt; the then-current branch.</source>
          <target state="translated">이 플래그는 병합 커밋이 일반 커밋과 같이 전체 diff를 표시하도록합니다. 각 병합 상위에 대해 별도의 로그 항목과 diff가 생성됩니다. &lt;code&gt;--first-parent&lt;/code&gt; 옵션이 주어지면 첫 번째 부모에 대한 diff 만 표시됩니다 . 이 경우 출력은 병합 이 당시 분기 &lt;code&gt;into&lt;/code&gt; 가져온 변경 사항을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="824f1a5cbd322eac2edc9b61691e0afb5fb06c7c" translate="yes" xml:space="preserve">
          <source>This flag tells the command not to reuse existing object data at all, including non deltified object, forcing recompression of everything. This implies --no-reuse-delta. Useful only in the obscure case where wholesale enforcement of a different compression level on the packed data is desired.</source>
          <target state="translated">이 플래그는 명령에 명령되지 않은 객체를 포함하여 기존 객체 데이터를 전혀 재사용하지 않도록 지시하여 모든 것을 다시 압축합니다. 이것은 --re-reuse-delta를 의미합니다. 압축 된 데이터에 대해 다른 압축 수준의 도매 시행이 필요한 모호한 경우에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e554d11fed47fbadc588fbbd426a692640350799" translate="yes" xml:space="preserve">
          <source>This form can only be used in the middle of a &lt;code&gt;commit&lt;/code&gt;. The path names a directory entry within fast-import&amp;rsquo;s active commit. The path must be quoted in this case.</source>
          <target state="translated">이 형식은 &lt;code&gt;commit&lt;/code&gt; 도중에 만 사용할 수 있습니다 . 경로는 빠른 가져 오기의 활성 커밋 내의 디렉토리 항목 이름을 지정합니다. 이 경우 경로를 인용해야합니다.</target>
        </trans-unit>
        <trans-unit id="55cd46dfe4dc47146eb359f16ba2ab6440f5d33b" translate="yes" xml:space="preserve">
          <source>This form is to compare the given two paths on the filesystem. You can omit the &lt;code&gt;--no-index&lt;/code&gt; option when running the command in a working tree controlled by Git and at least one of the paths points outside the working tree, or when running the command outside a working tree controlled by Git. This form implies &lt;code&gt;--exit-code&lt;/code&gt;.</source>
          <target state="translated">이 형식은 파일 시스템에서 주어진 두 경로를 비교하는 것입니다. Git으로 제어되는 작업 트리에서 명령을 실행하고 경로 중 하나 이상이 작업 트리 외부를 가리 키거나 Git에서 제어하는 ​​작업 트리 외부에서 명령을 실행할 때 &lt;code&gt;--no-index&lt;/code&gt; 옵션을 생략 할 수 있습니다 . 이 형식은 &lt;code&gt;--exit-code&lt;/code&gt; 를 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="1a36c2e6e9bf305ffd5ef7a7e4c453ac93dfb865" translate="yes" xml:space="preserve">
          <source>This form is to view the changes on the branch containing and up to the second &amp;lt;commit&amp;gt;, starting at a common ancestor of both &amp;lt;commit&amp;gt;. &quot;git diff A...B&quot; is equivalent to &quot;git diff $(git merge-base A B) B&quot;. You can omit any one of &amp;lt;commit&amp;gt;, which has the same effect as using HEAD instead.</source>
          <target state="translated">이 양식은 두 &amp;lt;commit&amp;gt;의 공통 조상에서 시작하여 두 번째 &amp;lt;commit&amp;gt;을 포함하는 브랜치의 변경 사항을 보는 것입니다. &quot;git diff A ... B&quot;는 &quot;git diff $ (git merge-base AB) B&quot;와 같습니다. &amp;lt;commit&amp;gt; 중 하나를 생략하면 HEAD를 대신 사용하는 것과 동일한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c4bbf16a9eb9be23dc9fab9fed4d09670912ec0" translate="yes" xml:space="preserve">
          <source>This form is to view the changes on the branch containing and up to the second &amp;lt;commit&amp;gt;, starting at a common ancestor of both &amp;lt;commit&amp;gt;. &lt;code&gt;git diff A...B&lt;/code&gt; is equivalent to &lt;code&gt;git diff $(git merge-base A B) B&lt;/code&gt;. You can omit any one of &amp;lt;commit&amp;gt;, which has the same effect as using HEAD instead.</source>
          <target state="translated">이 양식은 두 &amp;lt;commit&amp;gt;의 공통 조상에서 시작하여 두 번째 &amp;lt;commit&amp;gt;까지 포함하는 분기의 변경 사항을보기위한 것입니다. &lt;code&gt;git diff A...B&lt;/code&gt; 는 &lt;code&gt;git diff $(git merge-base A B) B&lt;/code&gt; 합니다. 대신 HEAD를 사용하는 것과 동일한 효과가있는 &amp;lt;commit&amp;gt; 중 하나를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18011d68a19f669179582c8652eaff17f583329f" translate="yes" xml:space="preserve">
          <source>This form is to view the changes you have in your working tree relative to the named &amp;lt;commit&amp;gt;. You can use HEAD to compare it with the latest commit, or a branch name to compare with the tip of a different branch.</source>
          <target state="translated">이 양식은 이름이 지정된 &amp;lt;commit&amp;gt;과 관련하여 작업 트리에서 변경 한 내용을 보는 것입니다. HEAD를 사용하여 최신 커밋과 비교하거나 분기 이름을 다른 분기의 팁과 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c3233dc5774a7d1fc399a8b304cc732bba72d9f" translate="yes" xml:space="preserve">
          <source>This form is to view the changes you made relative to the index (staging area for the next commit). In other words, the differences are what you &lt;code&gt;could&lt;/code&gt; tell Git to further add to the index but you still haven&amp;rsquo;t. You can stage these changes by using &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;.</source>
          <target state="translated">이 양식은 인덱스 (다음 커밋의 스테이징 영역)와 관련하여 변경 한 내용을 확인하기위한 것입니다. 즉, 차이는 당신이 무엇을 &lt;code&gt;could&lt;/code&gt; 인덱스에 더 추가로 망할 놈의 말하지만 당신은 아직하지 않았습니다. &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 을 사용하여 이러한 변경 사항을 준비 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee8e76f95895702db36db495b0e53027904973c9" translate="yes" xml:space="preserve">
          <source>This form is to view the changes you staged for the next commit relative to the named &amp;lt;commit&amp;gt;. Typically you would want comparison with the latest commit, so if you do not give &amp;lt;commit&amp;gt;, it defaults to HEAD. If HEAD does not exist (e.g. unborn branches) and &amp;lt;commit&amp;gt; is not given, it shows all staged changes. --staged is a synonym of --cached.</source>
          <target state="translated">이 양식은 명명 된 &amp;lt;commit&amp;gt;을 기준으로 다음 커밋에 대해 준비한 변경 사항을 확인하기위한 것입니다. 일반적으로 최신 커밋과 비교를 원하므로 &amp;lt;commit&amp;gt;을 제공하지 않으면 기본값은 HEAD입니다. HEAD가 존재하지 않고 (예 : 태어나지 않은 지점) &amp;lt;commit&amp;gt;이 제공되지 않으면 모든 단계적 변경 사항이 표시됩니다. --staged는 --cached와 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="51dda6a69f38e64f972e32a62549822542d75887" translate="yes" xml:space="preserve">
          <source>This form is to view the differences between the raw contents of two blob objects.</source>
          <target state="translated">이 양식은 두 Blob 오브젝트의 원시 컨텐츠 간의 차이점을 확인하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="df8ee2cb26426eddf11d55337361b04a2e3c04bb" translate="yes" xml:space="preserve">
          <source>This form is to view the results of a merge commit. The first listed &amp;lt;commit&amp;gt; must be the merge itself; the remaining two or more commits should be its parents. A convenient way to produce the desired set of revisions is to use the &lt;code&gt;^@&lt;/code&gt; suffix. For instance, if &lt;code&gt;master&lt;/code&gt; names a merge commit, &lt;code&gt;git diff master
master^@&lt;/code&gt; gives the same combined diff as &lt;code&gt;git show master&lt;/code&gt;.</source>
          <target state="translated">이 양식은 병합 커밋의 결과를보기위한 것입니다. 첫 번째로 나열된 &amp;lt;commit&amp;gt;은 병합 자체 여야합니다. 나머지 두 개 이상의 커밋은 부모가되어야합니다. 원하는 개정 세트를 생성하는 편리한 방법은 &lt;code&gt;^@&lt;/code&gt; 접미사 를 사용하는 것 입니다. 예를 들어 &lt;code&gt;master&lt;/code&gt; 가 병합 커밋의 이름을 지정하면 &lt;code&gt;git diff master master^@&lt;/code&gt; 는 &lt;code&gt;git show master&lt;/code&gt; 와 동일한 결합 된 diff를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="3140d31a73de32a89eb697f18f04aa202d7a5d8e" translate="yes" xml:space="preserve">
          <source>This form is to view the results of a merge commit. The first listed &amp;lt;commit&amp;gt; must be the merge itself; the remaining two or more commits should be its parents. A convenient way to produce the desired set of revisions is to use the ^@ suffix. For instance, if &lt;code&gt;master&lt;/code&gt; names a merge commit, &lt;code&gt;git diff master
master^@&lt;/code&gt; gives the same combined diff as &lt;code&gt;git show master&lt;/code&gt;.</source>
          <target state="translated">This form is to view the results of a merge commit. The first listed &amp;lt;commit&amp;gt; must be the merge itself; the remaining two or more commits should be its parents. A convenient way to produce the desired set of revisions is to use the ^@ suffix. For instance, if &lt;code&gt;master&lt;/code&gt; names a merge commit, &lt;code&gt;git diff master master^@&lt;/code&gt; gives the same combined diff as &lt;code&gt;git show master&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="395d78419362cad7438eb6eae46785d35953f019" translate="yes" xml:space="preserve">
          <source>This form resets the current branch head to &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; and possibly updates the index (resetting it to the tree of &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;) and the working tree depending on &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is omitted, defaults to &lt;code&gt;--mixed&lt;/code&gt;. The &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; must be one of the following:</source>
          <target state="translated">이 양식은 현재 분기 헤드를 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 으로 재설정하고 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 에 따라 색인 ( &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 의 트리로 재설정 ) 및 작업 트리를 업데이트합니다 . 경우 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 로, 기본적으로 생략 &lt;code&gt;--mixed&lt;/code&gt; 을 . &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 다음 중 하나 여야합니다 :</target>
        </trans-unit>
        <trans-unit id="90bcd35d4969f3a90ba2bd18f27a5c6eb93f333b" translate="yes" xml:space="preserve">
          <source>This form will use the first line matching the given POSIX regex. If &amp;lt;start&amp;gt; is a regex, it will search from the end of the previous &lt;code&gt;-L&lt;/code&gt; range, if any, otherwise from the start of file. If &amp;lt;start&amp;gt; is &amp;ldquo;^/regex/&amp;rdquo;, it will search from the start of file. If &amp;lt;end&amp;gt; is a regex, it will search starting at the line given by &amp;lt;start&amp;gt;.</source>
          <target state="translated">이 양식은 주어진 POSIX 정규식과 일치하는 첫 번째 줄을 사용합니다. &amp;lt;start&amp;gt;가 정규식 인 경우 이전 &lt;code&gt;-L&lt;/code&gt; 범위 의 끝 (있는 경우)에서 검색하고, 그렇지 않으면 파일 시작에서 검색합니다. &amp;lt;start&amp;gt;가&amp;ldquo;^ / regex /&amp;rdquo;인 경우 파일 시작 부분부터 검색합니다. &amp;lt;end&amp;gt;가 정규 표현식 인 경우 &amp;lt;start&amp;gt;에서 제공 한 줄부터 검색합니다.</target>
        </trans-unit>
        <trans-unit id="215f3a05528763c5f39e5365947941ffab5eacc1" translate="yes" xml:space="preserve">
          <source>This form will use the first line matching the given POSIX regex. If &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; is a regex, it will search from the end of the previous &lt;code&gt;-L&lt;/code&gt; range, if any, otherwise from the start of file. If &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; is &lt;code&gt;^/regex/&lt;/code&gt;, it will search from the start of file. If &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; is a regex, it will search starting at the line given by &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 양식은 주어진 POSIX 정규식과 일치하는 첫 번째 줄을 사용합니다. 경우 &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; 정규식이며, 그 이전의 끝에서 찾을 것이다 &lt;code&gt;-L&lt;/code&gt; 그렇지 않으면 파일의 처음부터 (있는 경우) 범위. 경우 &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; 입니다 &lt;code&gt;^/regex/&lt;/code&gt; ,이 파일의 시작에서 검색합니다. 경우 &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; , 그것은에 의해 주어진 라인에서 시작 검색합니다 정규식입니다 &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b42c261dd1828c15332725a480fa7095bcc76b2a" translate="yes" xml:space="preserve">
          <source>This format expects the first line of the file to contain the &quot;Cc:&quot; value and the &quot;Subject:&quot; of the message as the second line.</source>
          <target state="translated">이 형식에서는 파일의 첫 번째 줄에 메시지의 &quot;Cc :&quot;값과 &quot;Subject :&quot;가 두 번째 줄로 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="105520fc7842a24e43537a27759a074335828eb6" translate="yes" xml:space="preserve">
          <source>This format is identical to version &lt;code&gt;0&lt;/code&gt;, with the following exceptions:</source>
          <target state="translated">이 형식은 다음을 제외 하고 버전 &lt;code&gt;0&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="fd22347e6ce1cebbfe9140a8d5df54f1132eb3e9" translate="yes" xml:space="preserve">
          <source>This format is no longer produced by any Git command, but is and will continue to be supported by &lt;code&gt;update-index --index-info&lt;/code&gt;.</source>
          <target state="translated">이 형식은 더 이상 Git 명령으로 생성되지 않지만 &lt;code&gt;update-index --index-info&lt;/code&gt; 에서 계속 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="e1e42b99834dd201113f33eae88b5856f686096e" translate="yes" xml:space="preserve">
          <source>This format is to put higher order stages into the index file and matches &lt;code&gt;git ls-files --stage&lt;/code&gt; output.</source>
          <target state="translated">이 형식은 인덱스 파일에 고차 단계를 배치하고 &lt;code&gt;git ls-files --stage&lt;/code&gt; 출력 과 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="483caba3e82677e09e2d521ebba75089a90ce09e" translate="yes" xml:space="preserve">
          <source>This format is to stuff &lt;code&gt;git ls-tree&lt;/code&gt; output into the index.</source>
          <target state="translated">이 형식은 &lt;code&gt;git ls-tree&lt;/code&gt; 출력을 색인에 넣는 것입니다.</target>
        </trans-unit>
        <trans-unit id="078ec0cba6df63b2f2fc0bbcd069e250ea13b628" translate="yes" xml:space="preserve">
          <source>This format is used to refer to another commit in a commit message and is the same as &lt;code&gt;--pretty='format:%C(auto)%h (%s, %ad)'&lt;/code&gt;. By default, the date is formatted with &lt;code&gt;--date=short&lt;/code&gt; unless another &lt;code&gt;--date&lt;/code&gt; option is explicitly specified. As with any &lt;code&gt;format:&lt;/code&gt; with format placeholders, its output is not affected by other options like &lt;code&gt;--decorate&lt;/code&gt; and &lt;code&gt;--walk-reflogs&lt;/code&gt;.</source>
          <target state="translated">이 형식은 커밋 메시지에서 다른 커밋을 참조하는 데 사용되며 &lt;code&gt;--pretty='format:%C(auto)%h (%s, %ad)'&lt;/code&gt; 합니다. 기본적으로 다른 &lt;code&gt;--date&lt;/code&gt; 옵션을 지정 하지 않으면 날짜는 &lt;code&gt;--date=short&lt;/code&gt; 로 형식이 지정됩니다. 다른 &lt;code&gt;format:&lt;/code&gt; 과 마찬가지로 형식 자리 표시 자와 함께 출력은 &lt;code&gt;--decorate&lt;/code&gt; 및 &lt;code&gt;--walk-reflogs&lt;/code&gt; 와 같은 다른 옵션의 영향을받지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="742c78626a467f269e89b016f43c5e1a7be4cd88" translate="yes" xml:space="preserve">
          <source>This gets rid of the &lt;code&gt;git-svn-id:&lt;/code&gt; lines at the end of every commit.</source>
          <target state="translated">이것은 모든 커밋이 끝날 때 &lt;code&gt;git-svn-id:&lt;/code&gt; 행을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="2acaf36aea784a80df7509fcb8e38355c645c5a7" translate="yes" xml:space="preserve">
          <source>This gives a very controlled flow of fixes. If you notice that you have applied a fix to e.g. &lt;code&gt;master&lt;/code&gt; that is also required in &lt;code&gt;maint&lt;/code&gt;, you will need to cherry-pick it (using &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick[1]&lt;/a&gt;) downwards. This will happen a few times and is nothing to worry about unless you do it very frequently.</source>
          <target state="translated">이것은 매우 통제 된 수정 흐름을 제공합니다. &lt;code&gt;maint&lt;/code&gt; 에도 필요한 &lt;code&gt;master&lt;/code&gt; 에 수정을 적용한 것을 확인한 경우 , &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick [1]을&lt;/a&gt; 사용하여 아래쪽으로 체리를 선택해야합니다 . 이것은 몇 번 일어날 것이며 매우 자주하지 않으면 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f3884c08aac0f5d8941c7814b274c9743619a33" translate="yes" xml:space="preserve">
          <source>This happens if the &lt;code&gt;subsystem&lt;/code&gt; rebase had conflicts, or used &lt;code&gt;--interactive&lt;/code&gt; to omit, edit, squash, or fixup commits; or if the upstream used one of &lt;code&gt;commit --amend&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt;, or a full history rewriting command like &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;&lt;code&gt;filter-repo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이렇게하면 어떻게 &lt;code&gt;subsystem&lt;/code&gt; REBASE이 충돌을했다, 또는 사용 &lt;code&gt;--interactive&lt;/code&gt; 생략, 편집, 스쿼시, 또는 픽스 업 커밋에; 또는 업스트림에서 &lt;code&gt;commit --amend&lt;/code&gt; , &lt;code&gt;reset&lt;/code&gt; 또는 &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt; &lt;code&gt;filter-repo&lt;/code&gt; &lt;/a&gt; 와 같은 전체 기록 다시 쓰기 명령 중 하나를 사용한 경우 .</target>
        </trans-unit>
        <trans-unit id="53ac63807fcdbfc7e050fb3151d6b086f2e9a274" translate="yes" xml:space="preserve">
          <source>This happens if the &lt;code&gt;subsystem&lt;/code&gt; rebase was a simple rebase and had no conflicts.</source>
          <target state="translated">경우에 발생 &lt;code&gt;subsystem&lt;/code&gt; REBASE 간단한 REBASE이었고, 충돌이 없었다.</target>
        </trans-unit>
        <trans-unit id="d414984e9f8d7bfd782c8f2da36b80bcd80ea28e" translate="yes" xml:space="preserve">
          <source>This has a few user-visible effects and caveats:</source>
          <target state="translated">여기에는 몇 가지 사용자가 볼 수있는 효과와주의 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c876a37c9c7633e47e1a6a38b1f16f75e32a3ed" translate="yes" xml:space="preserve">
          <source>This has a very similar UI to &lt;code&gt;update&lt;/code&gt; and &lt;code&gt;revert&lt;/code&gt;, and lets you add untracked paths to the index.</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 및 &lt;code&gt;revert&lt;/code&gt; UI가 매우 유사 하며 추적되지 않은 경로를 색인에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33280cb105ee3b71902ce7b15c9592fd52f73e30" translate="yes" xml:space="preserve">
          <source>This has a very similar UI to &lt;code&gt;update&lt;/code&gt;, and the staged information for selected paths are reverted to that of the HEAD version. Reverting new paths makes them untracked.</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 할 UI가 매우 유사 하며 선택한 경로에 대한 준비된 정보가 HEAD 버전의 정보로 되돌아갑니다. 새로운 경로를 되 돌리면 추적되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d4512b846dcedcc9cf4704e69eaeda15e1830db" translate="yes" xml:space="preserve">
          <source>This has been requested by some kernel developers because some bugs called sporadic bugs do not appear in all the kernel builds because they are very dependent on the compiler output.</source>
          <target state="translated">이는 일부 커널 개발자가 요청한 것으로 산발적 버그라고하는 일부 버그는 컴파일러 출력에 크게 의존하기 때문에 모든 커널 빌드에 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b93781d2b5ee24d7b760545bc5177eb80e4c3e22" translate="yes" xml:space="preserve">
          <source>This has the advantage that it will be saved in your &lt;code&gt;CVS/Root&lt;/code&gt; files and you don&amp;rsquo;t need to worry about always setting the correct environment variable. SSH users restricted to &lt;code&gt;git-shell&lt;/code&gt; don&amp;rsquo;t need to override the default with CVS_SERVER (and shouldn&amp;rsquo;t) as &lt;code&gt;git-shell&lt;/code&gt; understands &lt;code&gt;cvs&lt;/code&gt; to mean &lt;code&gt;git-cvsserver&lt;/code&gt; and pretends that the other end runs the real &lt;code&gt;cvs&lt;/code&gt; better.</source>
          <target state="translated">이는 &lt;code&gt;CVS/Root&lt;/code&gt; 파일에 저장 되므로 항상 올바른 환경 변수 설정에 대해 걱정할 필요가 없다는 이점이 있습니다 . 제한 SSH 사용자 &lt;code&gt;git-shell&lt;/code&gt; CVS_SERVER에 기본값을 재정의해야 (그리고 안)하지 않는 &lt;code&gt;git-shell&lt;/code&gt; 이해 &lt;code&gt;cvs&lt;/code&gt; 평균에 &lt;code&gt;git-cvsserver&lt;/code&gt; 하고 다른 쪽 끝이 실제 실행되는 척 &lt;code&gt;cvs&lt;/code&gt; 더합니다.</target>
        </trans-unit>
        <trans-unit id="f27a3b2d1e595dbb21c1b28424b4a89305bcf439" translate="yes" xml:space="preserve">
          <source>This has two implications:</source>
          <target state="translated">여기에는 두 가지 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2d38b5ae6dea81df64d435d13a5c9c9c6e43a8c" translate="yes" xml:space="preserve">
          <source>This header line is followed by the following information at least once for each commit:</source>
          <target state="translated">이 헤더 행 다음에는 각 커밋마다 최소한 한 번 다음 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="aac19de1c954c0a5c2aba42bf1f288afbf74cabf" translate="yes" xml:space="preserve">
          <source>This helper uses specified file descriptors to connect to a remote Git server. This is not meant for end users but for programs and scripts calling git fetch, push or archive.</source>
          <target state="translated">이 도우미는 지정된 파일 설명자를 사용하여 원격 Git 서버에 연결합니다. 이것은 최종 사용자를위한 것이 아니라 git fetch, push 또는 archive를 호출하는 프로그램 및 스크립트를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="eafdc2cefff4153e88df550a24ce4b00606582ea" translate="yes" xml:space="preserve">
          <source>This hook can be used in conjunction with a corresponding pre-commit hook to save and restore any form of metadata associated with the working tree (e.g.: permissions/ownership, ACLS, etc). See contrib/hooks/setgitperms.perl for an example of how to do this.</source>
          <target state="translated">이 후크는 해당 사전 커밋 후크와 함께 사용하여 작업 트리와 관련된 모든 형식의 메타 데이터 (예 : 권한 / 소유권, ACLS 등)를 저장하고 복원 할 수 있습니다. 이를 수행하는 방법에 대한 예는 contrib / hooks / setgitperms.perl을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9fae8c19d5ced3830760d386f8db3473a746ea76" translate="yes" xml:space="preserve">
          <source>This hook can be used to perform repository validity checks, auto-display differences from the previous HEAD if different, or set working dir metadata properties.</source>
          <target state="translated">이 후크는 저장소 유효성 검사를 수행하거나, 이전 HEAD와 다른 경우 자동 표시 차이점을 수행하거나 작업 디렉토리 메타 데이터 특성을 설정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89a247d66f7dd9fd927ac160899ee7ad4eefe257" translate="yes" xml:space="preserve">
          <source>This hook can be used to prevent &lt;code&gt;forced&lt;/code&gt; update on certain refs by making sure that the object name is a commit object that is a descendant of the commit object named by the old object name. That is, to enforce a &quot;fast-forward only&quot; policy.</source>
          <target state="translated">이 후크는 오브젝트 이름이 이전 오브젝트 이름으로 명명 된 커미트 오브젝트의 자손 인 커미트 오브젝트인지 확인하여 특정 참조에서 &lt;code&gt;forced&lt;/code&gt; 업데이트 를 방지하는 데 사용될 수 있습니다 . 즉, &quot;빨리 감기&quot;정책을 시행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e2b4b08b5c7d529703ac2e4609fae5478174d015" translate="yes" xml:space="preserve">
          <source>This hook can be used, for example, to run &lt;code&gt;git update-server-info&lt;/code&gt; if the repository is packed and is served via a dumb transport.</source>
          <target state="translated">예를 들어 리포지토리가 압축되어 벙어리 전송을 통해 제공 되는 경우이 후크를 사용하여 &lt;code&gt;git update-server-info&lt;/code&gt; 를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec8359ca4fe68868d4a094d214fa5c736b07b686" translate="yes" xml:space="preserve">
          <source>This hook does not affect the outcome of &lt;code&gt;git receive-pack&lt;/code&gt;, as it is called after the real work is done.</source>
          <target state="translated">이 후크는 실제 작업이 완료된 후 호출되므로 &lt;code&gt;git receive-pack&lt;/code&gt; 의 결과에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4f1494681f56d1e644fae421a13f75381d1bf104" translate="yes" xml:space="preserve">
          <source>This hook executes once for the receive operation. It takes no arguments, but for each ref to be updated it receives on standard input a line of the format:</source>
          <target state="translated">이 후크는 수신 작업을 위해 한 번 실행됩니다. 인수는 없지만 각 참조가 업데이트 될 때마다 표준 입력에서 다음 형식의 행을 수신합니다.</target>
        </trans-unit>
        <trans-unit id="1c705c0b531046d9558421e4543f9aca35624390" translate="yes" xml:space="preserve">
          <source>This hook executes once for the receive operation. It takes no arguments, but gets the same information as the &lt;a href=&quot;#pre-receive&quot;&gt;&lt;em&gt;pre-receive&lt;/em&gt;&lt;/a&gt; hook does on its standard input.</source>
          <target state="translated">이 후크는 수신 작업을 위해 한 번 실행됩니다. 인수는 없지만 표준 입력 에서 &lt;a href=&quot;#pre-receive&quot;&gt;&lt;em&gt;사전 수신&lt;/em&gt;&lt;/a&gt; 후크 와 동일한 정보를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="98f6b796f54de07e8019b94d0f551840c498ad05" translate="yes" xml:space="preserve">
          <source>This hook executes once for the receive operation. It takes no arguments, but uses a pkt-line format protocol to communicate with &lt;code&gt;receive-pack&lt;/code&gt; to read commands, push-options and send results. In the following example for the protocol, the letter &lt;code&gt;S&lt;/code&gt; stands for &lt;code&gt;receive-pack&lt;/code&gt; and the letter &lt;code&gt;H&lt;/code&gt; stands for this hook.</source>
          <target state="translated">This hook executes once for the receive operation. It takes no arguments, but uses a pkt-line format protocol to communicate with &lt;code&gt;receive-pack&lt;/code&gt; to read commands, push-options and send results. In the following example for the protocol, the letter &lt;code&gt;S&lt;/code&gt; stands for &lt;code&gt;receive-pack&lt;/code&gt; and the letter &lt;code&gt;H&lt;/code&gt; stands for this hook.</target>
        </trans-unit>
        <trans-unit id="8f404b0d7afced029532dd1c0ce00c69033fa119" translate="yes" xml:space="preserve">
          <source>This hook is called before any refname is updated and before any fast-forward checks are performed.</source>
          <target state="translated">이 후크는 참조 이름이 업데이트되기 전에 그리고 빨리 감기 검사가 수행되기 전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6f4d4e6bc9f3d3e90e8224d9cc9d15607a5f159d" translate="yes" xml:space="preserve">
          <source>This hook is called by &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and can be used to prevent a push from taking place. The hook is called with two parameters which provide the name and location of the destination remote, if a named remote is not being used both values will be the same.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-push&quot;&gt;git-push [1]에&lt;/a&gt; 의해 호출되며 푸시 가 발생하지 않도록하는 데 사용될 수 있습니다. 후크는 대상 원격의 이름과 위치를 제공하는 두 개의 매개 변수와 함께 호출됩니다. 명명 된 원격을 사용하지 않는 경우 두 값이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b761c5f63f99b7c22c6e4ca4e1bd741b6a19c509" translate="yes" xml:space="preserve">
          <source>This hook is called by &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; and can be used to prevent a branch from getting rebased. The hook may be called with one or two parameters. The first parameter is the upstream from which the series was forked. The second parameter is the branch being rebased, and is not set when rebasing the current branch.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]에&lt;/a&gt; 의해 호출되며 브랜치가 리베이스되지 않도록하는 데 사용될 수 있습니다. 후크는 하나 또는 두 개의 매개 변수로 호출 될 수 있습니다. 첫 번째 매개 변수는 시리즈가 분기 된 업스트림입니다. 두 번째 매개 변수는 리베이스되는 브랜치이며 현재 브랜치를 리베이스 할 때 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc84f5afc2cc3712fb061152c42b83b5432e2d28" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;. It takes a single parameter, the name of the file that holds the proposed commit log message. Exiting with a non-zero status causes &lt;code&gt;git am&lt;/code&gt; to abort before applying the patch.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-am&quot;&gt;git-am [1]에&lt;/a&gt; 의해 호출됩니다 . 제안 된 커미트 로그 메시지를 보유하는 파일 이름 인 단일 매개 변수를 사용합니다. 0이 아닌 상태로 종료 하면 패치를 적용하기 전에 &lt;code&gt;git am&lt;/code&gt; 이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="109f1251e93ab76b92d28a05e1f40ca3ae3e2435" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;. It takes no parameter, and is invoked after the patch is applied and a commit is made.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-am&quot;&gt;git-am [1]에&lt;/a&gt; 의해 호출됩니다 . 매개 변수를 사용하지 않으며 패치가 적용되고 커미트 된 후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="31dd1042d3a6d88015bf6a789db56141bf61f664" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;. It takes no parameter, and is invoked after the patch is applied, but before a commit is made.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-am&quot;&gt;git-am [1]에&lt;/a&gt; 의해 호출됩니다 . 매개 변수를 사용하지 않으며 패치가 적용된 후, 그러나 커미트되기 전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4126a7ec7eb0a54d9b99d1f389fd70ce96c40950" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; and &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;, and can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes a single parameter, the name of the file that holds the proposed commit log message. Exiting with a non-zero status causes the command to abort.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 및 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]에&lt;/a&gt; 의해 호출되며 &lt;code&gt;--no-verify&lt;/code&gt; 옵션을 사용하여 무시할 수 있습니다 . 제안 된 커미트 로그 메시지를 보유하는 파일 이름 인 단일 매개 변수를 사용합니다. 0이 아닌 상태로 종료하면 명령이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="977ece26ae3c0446a7497462b09e90162737d6ca" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; right after preparing the default log message, and before the editor is started.</source>
          <target state="translated">이 후크는 기본 로그 메시지를 준비한 직후와 편집기가 시작되기 전에 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]에&lt;/a&gt; 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ae25bad855fc10ca5e955357c713cdbb31a472c" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;, and can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes no parameters, and is invoked before obtaining the proposed commit log message and making a commit. Exiting with a non-zero status from this script causes the &lt;code&gt;git commit&lt;/code&gt; command to abort before creating a commit.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]에&lt;/a&gt; 의해 호출되며 &lt;code&gt;--no-verify&lt;/code&gt; 옵션을 사용하여 무시할 수 있습니다 . 매개 변수가 없으며 제안 된 확약 로그 메시지를 확보하고 확약하기 전에 호출됩니다. 이 스크립트에서 0이 아닌 상태로 종료하면 &lt;code&gt;git commit&lt;/code&gt; 을 만들기 전에 git commit 명령이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="21226463d529e8f7d5082c27401d959f905ec4d1" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;. It takes no parameters, and is invoked after a commit is made.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]에&lt;/a&gt; 의해 호출됩니다 . 매개 변수를 사용하지 않으며 확약 후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0a4097349c79cead9de93e647cb9ba47cbed7c91" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;, and can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes no parameters, and is invoked after the merge has been carried out successfully and before obtaining the proposed commit log message to make a commit. Exiting with a non-zero status from this script causes the &lt;code&gt;git merge&lt;/code&gt; command to abort before creating a commit.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]에&lt;/a&gt; 의해 호출되며 &lt;code&gt;--no-verify&lt;/code&gt; 옵션을 사용하여 무시할 수 있습니다 . 매개 변수를 취하지 않으며 병합이 성공적으로 수행 된 후 그리고 커미트를 작성하기 위해 제안 된 커미트 로그 메시지를 얻기 전에 호출됩니다. 이 스크립트에서 0이 아닌 상태로 종료 하면 커밋을 만들기 전에 &lt;code&gt;git merge&lt;/code&gt; 명령이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="de911dadfd0a4abc2b13baa4ccbc2ae0aca9f055" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;, which happens when a &lt;code&gt;git pull&lt;/code&gt; is done on a local repository. The hook takes a single parameter, a status flag specifying whether or not the merge being done was a squash merge. This hook cannot affect the outcome of &lt;code&gt;git merge&lt;/code&gt; and is not executed, if the merge failed due to conflicts.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]에&lt;/a&gt; 의해 호출되는데 , 이는 로컬 리포지토리에서 &lt;code&gt;git pull&lt;/code&gt; 이 수행 될 때 발생 합니다. 후크는 단일 매개 변수, 수행중인 병합이 스쿼시 병합인지 여부를 지정하는 상태 플래그를 사용합니다. 이 후크는 &lt;code&gt;git merge&lt;/code&gt; 의 결과에 영향을 줄 수 없으며 충돌로 인해 병합이 실패한 경우에는 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="76961cafe28e294daa6f1b287a02eb4fe4bf07aa" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository, and when the push tries to update the branch that is currently checked out and the &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; configuration variable is set to &lt;code&gt;updateInstead&lt;/code&gt;. Such a push by default is refused if the working tree and the index of the remote repository has any difference from the currently checked out commit; when both the working tree and the index match the current commit, they are updated to match the newly pushed tip of the branch. This hook is to be used to override the default behaviour.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; 이 &lt;code&gt;git push&lt;/code&gt; 에 반응 하고 리포지토리의 참조를 업데이트 할 때, 그리고 푸시가 현재 체크 아웃 된 브랜치 및 &lt;code&gt;receive.denyCurrentBranch&lt;/code&gt; 구성 변수 를 업데이트하려고 할 때 호출됩니다 . &lt;code&gt;updateInstead&lt;/code&gt; 로 설정되어 있습니다. 작업 트리와 원격 저장소의 색인이 현재 체크 아웃 된 커밋과 다른 경우 기본적으로 이러한 푸시는 거부됩니다. 작업 트리와 인덱스가 모두 현재 커밋과 일치하면 분기의 새로 푸시 된 팁과 일치하도록 업데이트됩니다. 이 후크는 기본 동작을 재정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5a56dac625f1205849f2b5f6e3619a708d3ea48e" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository. It executes on the remote repository once after all the refs have been updated.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; 이 &lt;code&gt;git push&lt;/code&gt; 에 반응 하고 리포지토리에서 참조를 업데이트 할 때 호출됩니다 . 모든 참조가 업데이트 된 후 원격 저장소에서 한 번 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="390ce0821ef413eec43c389641cce2dfc9687135" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository. Just before starting to update refs on the remote repository, the pre-receive hook is invoked. Its exit status determines the success or failure of the update.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; 이 &lt;code&gt;git push&lt;/code&gt; 에 반응 하고 리포지토리에서 참조를 업데이트 할 때 호출됩니다 . 원격 저장소에서 참조 업데이트를 시작하기 직전에 사전 수신 후크가 호출됩니다. 종료 상태에 따라 업데이트 성공 여부가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="f508c67d780c6e440d114ab5a4809e8db15887c6" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; when it reacts to &lt;code&gt;git push&lt;/code&gt; and updates reference(s) in its repository. Just before updating the ref on the remote repository, the update hook is invoked. Its exit status determines the success or failure of the ref update.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; 이 &lt;code&gt;git push&lt;/code&gt; 에 반응 하고 리포지토리에서 참조를 업데이트 할 때 호출됩니다 . 원격 저장소에서 참조를 업데이트하기 직전에 업데이트 후크가 호출됩니다. 종료 상태에 따라 참조 업데이트의 성공 또는 실패가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="c165f7e2051fecf641e46f5c29ee35090d7d5f24" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt;. If the server has set the multi-valued config variable &lt;code&gt;receive.procReceiveRefs&lt;/code&gt;, and the commands sent to &lt;code&gt;receive-pack&lt;/code&gt; have matching reference names, these commands will be executed by this hook, instead of by the internal &lt;code&gt;execute_commands()&lt;/code&gt; function. This hook is responsible for updating the relevant references and reporting the results back to &lt;code&gt;receive-pack&lt;/code&gt;.</source>
          <target state="translated">This hook is invoked by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt;. If the server has set the multi-valued config variable &lt;code&gt;receive.procReceiveRefs&lt;/code&gt; , and the commands sent to &lt;code&gt;receive-pack&lt;/code&gt; have matching reference names, these commands will be executed by this hook, instead of by the internal &lt;code&gt;execute_commands()&lt;/code&gt; function. This hook is responsible for updating the relevant references and reporting the results back to &lt;code&gt;receive-pack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c94fc31562e49c2e1f57905c2984b3787d6eb579" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt;. It takes a single parameter, the name of the file that holds the e-mail to be sent. Exiting with a non-zero status causes &lt;code&gt;git send-email&lt;/code&gt; to abort before sending any e-mails.</source>
          <target state="translated">이 후크는 &lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]에&lt;/a&gt; 의해 호출됩니다 . 전송할 전자 우편을 보유한 파일 이름 인 단일 매개 변수를 사용합니다. 0이 아닌 상태로 종료하면 &lt;code&gt;git send-email&lt;/code&gt; 을 보내기 전에 git send-email 이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="898dc345a1faef7e78cc6f07a48d416762cf9e72" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git gc --auto&lt;/code&gt; (see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;). It takes no parameter, and exiting with non-zero status from this script causes the &lt;code&gt;git gc --auto&lt;/code&gt; to abort.</source>
          <target state="translated">이 후크는 &lt;code&gt;git gc --auto&lt;/code&gt; 에 의해 호출됩니다 ( &lt;a href=&quot;git-gc&quot;&gt;git-gc [1] 참조&lt;/a&gt; ). 매개 변수가 &lt;code&gt;git gc --auto&lt;/code&gt; 스크립트에서 0이 아닌 상태로 종료하면 git gc --auto 가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="536d2f256146b81297af8f05d9ee07d3c788ff56" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git-p4 submit&lt;/code&gt;.</source>
          <target state="translated">This hook is invoked by &lt;code&gt;git-p4 submit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db96373c38bd1df6e078c9fa2b6d9e050d469bb3" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git-p4 submit&lt;/code&gt;. It takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevent &lt;code&gt;git-p4 submit&lt;/code&gt; from launching. It can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; command line option. Run &lt;code&gt;git-p4 submit --help&lt;/code&gt; for details.</source>
          <target state="translated">이 후크는 &lt;code&gt;git-p4 submit&lt;/code&gt; 에 의해 호출됩니다 . 표준 입력에서 매개 변수와 아무것도 사용하지 않습니다. 이 스크립트에서 0이 아닌 상태로 종료하면 &lt;code&gt;git-p4 submit&lt;/code&gt; 이 시작되지 않습니다. &lt;code&gt;--no-verify&lt;/code&gt; 명령 줄 옵션 으로 무시할 수 있습니다 . 자세한 내용은 &lt;code&gt;git-p4 submit --help&lt;/code&gt; 를 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="fa504b80ab7d4ab7fd02bb1c09f7267f7ffd0b87" translate="yes" xml:space="preserve">
          <source>This hook is invoked by &lt;code&gt;git-p4 submit&lt;/code&gt;. It takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevent &lt;code&gt;git-p4 submit&lt;/code&gt; from launching. Run &lt;code&gt;git-p4 submit --help&lt;/code&gt; for details.</source>
          <target state="translated">이 후크는 &lt;code&gt;git-p4 submit&lt;/code&gt; 에 의해 호출됩니다 . 매개 변수가 없으며 표준 입력에서 아무것도 가져 오지 않습니다. 이 스크립트에서 0이 아닌 상태로 종료하면 &lt;code&gt;git-p4 submit&lt;/code&gt; 이 시작되지 않습니다. 자세한 내용은 &lt;code&gt;git-p4 submit --help&lt;/code&gt; 를 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="e343164b203dd1de0ba3f9a30c792df16e0f19da" translate="yes" xml:space="preserve">
          <source>This hook is invoked by any Git command that performs reference updates. It executes whenever a reference transaction is prepared, committed or aborted and may thus get called multiple times.</source>
          <target state="translated">이 후크는 참조 업데이트를 수행하는 모든 Git 명령에 의해 호출됩니다. 참조 트랜잭션이 준비, 커밋 또는 중단 될 때마다 실행되므로 여러 번 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8569f58a670ba9d05dfd0c2191295df64e04e73" translate="yes" xml:space="preserve">
          <source>This hook is invoked by commands that rewrite commits (&lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; when called with &lt;code&gt;--amend&lt;/code&gt; and &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;; however, full-history (re)writing tools like &lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import[1]&lt;/a&gt; or &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo&lt;/a&gt; typically do not call it!). Its first argument denotes the command it was invoked by: currently one of &lt;code&gt;amend&lt;/code&gt; or &lt;code&gt;rebase&lt;/code&gt;. Further command-dependent arguments may be passed in the future.</source>
          <target state="translated">이 후크는 커밋을 다시 작성하는 명령 ( &lt;code&gt;--amend&lt;/code&gt; 및 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; 과 함께 호출되면 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 이지만 &lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import [1]&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;git-filter-repo는&lt;/a&gt; 일반적으로 그것을 호출하지 않습니다!). 첫 번째 인수는 현재 &lt;code&gt;amend&lt;/code&gt; 또는 &lt;code&gt;rebase&lt;/code&gt; 중 하나에 의해 호출 된 명령을 나타냅니다 . 추후 명령 종속 인수가 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c8dde02f7fe4fac23930e917fd59c1d03fbfa8b" translate="yes" xml:space="preserve">
          <source>This hook is invoked when a &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; or &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; is run after having updated the worktree. The hook is given three parameters: the ref of the previous HEAD, the ref of the new HEAD (which may or may not have changed), and a flag indicating whether the checkout was a branch checkout (changing branches, flag=1) or a file checkout (retrieving a file from the index, flag=0). This hook cannot affect the outcome of &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt;, other than that the hook&amp;rsquo;s exit status becomes the exit status of these two commands.</source>
          <target state="translated">이 후크는 워크 트리를 업데이트 한 후 &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-switch&quot;&gt;git-switch [1]&lt;/a&gt; 가 실행될 때 호출됩니다 . 후크에는 이전 HEAD의 참조, 새 HEAD의 참조 (변경되었거나 변경되지 않았을 수 있음), 체크 아웃이 브랜치 체크 아웃 (브랜치 변경, 플래그 = 1)인지 여부를 나타내는 플래그가 제공됩니다. 파일 체크 아웃 (인덱스에서 파일 검색, flag = 0). 이 후크는 후크의 종료 상태가이 두 명령의 종료 상태가되는 것 외에는 &lt;code&gt;git switch&lt;/code&gt; 또는 &lt;code&gt;git checkout&lt;/code&gt; 의 결과에 영향을 줄 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7b20b75526e2af7ef8179932e884a838f68429b3" translate="yes" xml:space="preserve">
          <source>This hook is invoked when a &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; or &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; is run after having updated the worktree. The hook is given three parameters: the ref of the previous HEAD, the ref of the new HEAD (which may or may not have changed), and a flag indicating whether the checkout was a branch checkout (changing branches, flag=1) or a file checkout (retrieving a file from the index, flag=0). This hook cannot affect the outcome of &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt;.</source>
          <target state="translated">이 후크는 작업 트리 를 업데이트 한 후 &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-switch&quot;&gt;git-switch [1]&lt;/a&gt; 을 실행할 때 호출됩니다 . 후크에는 이전 HEAD의 참조, 새 HEAD의 참조 (변경되었거나 변경되지 않았을 수 있음) 및 체크 아웃이 분기 체크 아웃 (분기 변경, 플래그 = 1)인지를 나타내는 플래그 또는 파일 체크 아웃 (인덱스에서 파일 검색, 플래그 = 0) 이 후크는 &lt;code&gt;git switch&lt;/code&gt; 또는 &lt;code&gt;git checkout&lt;/code&gt; 결과에 영향을 줄 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fd3ae42761b9b86d30d029aa1493872ff1533f42" translate="yes" xml:space="preserve">
          <source>This hook is invoked when the configuration option &lt;code&gt;core.fsmonitor&lt;/code&gt; is set to &lt;code&gt;.git/hooks/fsmonitor-watchman&lt;/code&gt; or &lt;code&gt;.git/hooks/fsmonitor-watchmanv2&lt;/code&gt; depending on the version of the hook to use.</source>
          <target state="translated">구성 옵션의 경우에 후크가 호출됩니다 &lt;code&gt;core.fsmonitor&lt;/code&gt; 이 설정되어 &lt;code&gt;.git/hooks/fsmonitor-watchman&lt;/code&gt; 또는 &lt;code&gt;.git/hooks/fsmonitor-watchmanv2&lt;/code&gt; 사용에 후크의 버전에 따라.</target>
        </trans-unit>
        <trans-unit id="7b0692c459d4a723afc690b678a8556c7e5d3814" translate="yes" xml:space="preserve">
          <source>This hook is invoked when the configuration option &lt;code&gt;core.fsmonitor&lt;/code&gt; is set to &lt;code&gt;.git/hooks/fsmonitor-watchman&lt;/code&gt;. It takes two arguments, a version (currently 1) and the time in elapsed nanoseconds since midnight, January 1, 1970.</source>
          <target state="translated">이 후크는 구성 옵션 &lt;code&gt;core.fsmonitor&lt;/code&gt; 가 &lt;code&gt;.git/hooks/fsmonitor-watchman&lt;/code&gt; 으로 설정된 경우에 호출됩니다 . 1970 년 1 월 1 일 자정 이후 버전 (현재 1)과 경과 된 나노초 단위의 두 가지 인수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1ea8190ee0fad5a3aca31c578a724c322c0d57cb" translate="yes" xml:space="preserve">
          <source>This hook is invoked when the index is written in read-cache.c do_write_locked_index.</source>
          <target state="translated">이 후크는 인덱스가 read-cache.c do_write_locked_index에 기록 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bbcd7cc3d137fc9e83cb037a7ffe28a3a104cf5b" translate="yes" xml:space="preserve">
          <source>This hook is invoked with the environment variable &lt;code&gt;GIT_EDITOR=:&lt;/code&gt; if the command will not bring up an editor to modify the commit message.</source>
          <target state="translated">이 후크는 환경 변수 &lt;code&gt;GIT_EDITOR=:&lt;/code&gt; 로 명령이 커밋 메시지를 수정하기 위해 편집기를 불러 오지 않으면 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="ddc7ece9286909c0de44abe41d5a762b67552ed5" translate="yes" xml:space="preserve">
          <source>This hook is meant primarily for notification, and cannot affect the outcome of &lt;code&gt;git am&lt;/code&gt;.</source>
          <target state="translated">이 후크는 주로 알림을위한 것이며 &lt;code&gt;git am&lt;/code&gt; 의 결과에 영향을 줄 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="448e187d53f17c70cda00f92a3ee55c4bde07472" translate="yes" xml:space="preserve">
          <source>This hook is meant primarily for notification, and cannot affect the outcome of &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">이 후크는 주로 알림을위한 것이며 &lt;code&gt;git commit&lt;/code&gt; 결과에 영향을 줄 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="08260832c28c95684a1993d7203db5c6a733006a" translate="yes" xml:space="preserve">
          <source>This hook is meant primarily for notification, and cannot affect the outcome of &lt;code&gt;git receive-pack&lt;/code&gt;.</source>
          <target state="translated">이 후크는 주로 알림을위한 것이며 &lt;code&gt;git receive-pack&lt;/code&gt; 의 결과에 영향을 줄 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f1b9eafafbdf014b8c082347223fc7e3e439cd3c" translate="yes" xml:space="preserve">
          <source>This implies &lt;code&gt;--revs&lt;/code&gt;. In addition to the list of revision arguments read from the standard input, pretend as if all refs under &lt;code&gt;refs/&lt;/code&gt; are specified to be included.</source>
          <target state="translated">이것은 &lt;code&gt;--revs&lt;/code&gt; 를 의미 합니다 . 표준 입력에서 읽은 수정 인수 목록 외에도 &lt;code&gt;refs/&lt;/code&gt; 아래의 모든 참조 가 포함되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="00f6fe101136dac1c604175fe5bf787266d15317" translate="yes" xml:space="preserve">
          <source>This implies &lt;code&gt;--revs&lt;/code&gt;. When processing the list of revision arguments read from the standard input, limit the objects packed to those that are not already packed.</source>
          <target state="translated">이것은 &lt;code&gt;--revs&lt;/code&gt; 를 의미 합니다 . 표준 입력에서 읽은 수정 인수 목록을 처리 할 때 압축되지 않은 개체로 압축 된 개체를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="23abf25dbec44cc1a257bc71a457bb760d4a79eb" translate="yes" xml:space="preserve">
          <source>This implies the &lt;code&gt;--topo-order&lt;/code&gt; option by default, but the &lt;code&gt;--date-order&lt;/code&gt; option may also be specified.</source>
          <target state="translated">이는 기본적으로 &lt;code&gt;--topo-order&lt;/code&gt; 옵션을 의미 하지만 &lt;code&gt;--date-order&lt;/code&gt; 옵션도 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bafb6d097d43ca4ccca730edb887425acfba8b5" translate="yes" xml:space="preserve">
          <source>This imports the specified depot into &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; in an existing Git repository. The &lt;code&gt;--branch&lt;/code&gt; option can be used to specify a different branch to be used for the p4 content.</source>
          <target state="translated">지정된 저장소를 기존 Git 저장소의 &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; 로 가져옵니다 . &lt;code&gt;--branch&lt;/code&gt; 옵션은 P4 콘텐츠를 사용하는 다른 지점을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a7c7788d041aa1a2f51fc279f1f6f7da23ae666" translate="yes" xml:space="preserve">
          <source>This indicates that the helper is able to interact with the remote side using an explicit hash algorithm extension.</source>
          <target state="translated">이는 도우미가 명시 적 해시 알고리즘 확장을 사용하여 원격 측과 상호 작용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="505428074ae07b004fad59f4eaeb272274ac2c6b" translate="yes" xml:space="preserve">
          <source>This information can be used to determine what commit was the tip of a branch &quot;2 days ago&quot;.</source>
          <target state="translated">이 정보는 어떤 커밋이 &quot;2 일 전&quot;브랜치의 팁 이었는지 판별하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86187244d1368864bf6af8ccb054656e32b6a58b" translate="yes" xml:space="preserve">
          <source>This instructs git svn to recode pathnames to a given encoding. It can be used by windows users and by those who work in non-utf8 locales to avoid corrupted file names with non-ASCII characters. Valid encodings are the ones supported by Perl&amp;rsquo;s Encode module.</source>
          <target state="translated">이것은 git svn에게 경로명을 주어진 인코딩으로 코딩하도록 지시합니다. Windows 사용자와 비 UTF8 로케일에서 작업하는 사용자가 ASCII가 아닌 문자로 손상된 파일 이름을 피할 수 있습니다. 유효한 인코딩은 Perl의 Encode 모듈에서 지원되는 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="956c7627c61d83f78ef967d8ba93fedd722fb328" translate="yes" xml:space="preserve">
          <source>This integer config option controls how often the &lt;code&gt;commit-graph&lt;/code&gt; task should be run as part of &lt;code&gt;git maintenance run --auto&lt;/code&gt;. If zero, then the &lt;code&gt;commit-graph&lt;/code&gt; task will not run with the &lt;code&gt;--auto&lt;/code&gt; option. A negative value will force the task to run every time. Otherwise, a positive value implies the command should run when the number of reachable commits that are not in the commit-graph file is at least the value of &lt;code&gt;maintenance.commit-graph.auto&lt;/code&gt;. The default value is 100.</source>
          <target state="translated">이 정수 구성 옵션은 &lt;code&gt;commit-graph&lt;/code&gt; 작업이 &lt;code&gt;git maintenance run --auto&lt;/code&gt; 의 일부로 실행되어야 하는 빈도를 제어합니다 . 0이면 &lt;code&gt;commit-graph&lt;/code&gt; 작업이 &lt;code&gt;--auto&lt;/code&gt; 옵션으로 실행되지 않습니다 . 음수 값은 작업이 매번 실행되도록합니다. 그렇지 않으면 양수 값은 commit-graph 파일에없는 도달 가능한 커밋 수가 최소한 &lt;code&gt;maintenance.commit-graph.auto&lt;/code&gt; 값일 때 명령이 실행되어야 함을 의미합니다 . 기본값은 100입니다.</target>
        </trans-unit>
        <trans-unit id="e64a7c2d6ae98d20c277e94177b42af973cafce0" translate="yes" xml:space="preserve">
          <source>This integer config option controls how often the &lt;code&gt;incremental-repack&lt;/code&gt; task should be run as part of &lt;code&gt;git maintenance run --auto&lt;/code&gt;. If zero, then the &lt;code&gt;incremental-repack&lt;/code&gt; task will not run with the &lt;code&gt;--auto&lt;/code&gt; option. A negative value will force the task to run every time. Otherwise, a positive value implies the command should run when the number of pack-files not in the multi-pack-index is at least the value of &lt;code&gt;maintenance.incremental-repack.auto&lt;/code&gt;. The default value is 10.</source>
          <target state="translated">이 정수 구성 옵션 은 &lt;code&gt;git maintenance run --auto&lt;/code&gt; 의 일부로 &lt;code&gt;incremental-repack&lt;/code&gt; 작업을 실행해야하는 빈도를 제어합니다 . 0이면 &lt;code&gt;incremental-repack&lt;/code&gt; 작업이 &lt;code&gt;--auto&lt;/code&gt; 옵션으로 실행되지 않습니다 . 음수 값은 작업이 매번 실행되도록합니다. 그렇지 않으면, 양수 값은 멀티 팩 인덱스에없는 팩 파일 수가 최소한 &lt;code&gt;maintenance.incremental-repack.auto&lt;/code&gt; 값일 때 명령이 실행되어야 함을 의미합니다 . 기본값은 10입니다.</target>
        </trans-unit>
        <trans-unit id="61993927f5b7a85ff06e34daa416caf3ce7cbe39" translate="yes" xml:space="preserve">
          <source>This integer config option controls how often the &lt;code&gt;loose-objects&lt;/code&gt; task should be run as part of &lt;code&gt;git maintenance run --auto&lt;/code&gt;. If zero, then the &lt;code&gt;loose-objects&lt;/code&gt; task will not run with the &lt;code&gt;--auto&lt;/code&gt; option. A negative value will force the task to run every time. Otherwise, a positive value implies the command should run when the number of loose objects is at least the value of &lt;code&gt;maintenance.loose-objects.auto&lt;/code&gt;. The default value is 100.</source>
          <target state="translated">이 정수 구성 옵션은 &lt;code&gt;loose-objects&lt;/code&gt; 태스크가 &lt;code&gt;git maintenance run --auto&lt;/code&gt; 의 일부로 실행되어야 하는 빈도를 제어합니다 . 0 인 경우 &lt;code&gt;loose-objects&lt;/code&gt; 작업은 &lt;code&gt;--auto&lt;/code&gt; 옵션으로 실행되지 않습니다 . 음수 값은 작업이 매번 실행되도록합니다. 그렇지 않으면 양수 값은 느슨한 객체 수가 최소한 &lt;code&gt;maintenance.loose-objects.auto&lt;/code&gt; 값일 때 명령이 실행되어야 함을 의미합니다 . 기본값은 100입니다.</target>
        </trans-unit>
        <trans-unit id="0909b4167b1b6cfc93db8cafdc74248d3901c792" translate="yes" xml:space="preserve">
          <source>This is a deprecated synonym for &lt;code&gt;repack.writeBitmaps&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;repack.writeBitmaps&lt;/code&gt; 에 대한 더 이상 사용되지 않는 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="0663f3ff3f5e643bb58ee19e6a44fd14680c40d5" translate="yes" xml:space="preserve">
          <source>This is a login shell for SSH accounts to provide restricted Git access. It permits execution only of server-side Git commands implementing the pull/push functionality, plus custom commands present in a subdirectory named &lt;code&gt;git-shell-commands&lt;/code&gt; in the user&amp;rsquo;s home directory.</source>
          <target state="translated">SSH 계정이 제한된 Git 액세스를 제공하기위한 로그인 셸입니다. 풀 / 푸시 기능을 구현하는 서버 측 Git 명령과 사용자 홈 디렉토리의 &lt;code&gt;git-shell-commands&lt;/code&gt; 하위 디렉토리에있는 사용자 정의 명령 만 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb9b1700493e02e1c42808252a2a81a90b07f06f" translate="yes" xml:space="preserve">
          <source>This is a modified recursive strategy. When merging trees A and B, if B corresponds to a subtree of A, B is first adjusted to match the tree structure of A, instead of reading the trees at the same level. This adjustment is also done to the common ancestor tree.</source>
          <target state="translated">이것은 수정 된 재귀 전략입니다. 트리 A와 B를 병합 할 때 B가 A의 하위 트리에 해당하는 경우 동일한 레벨에서 트리를 읽는 대신 B가 A의 트리 구조와 일치하도록 먼저 조정됩니다. 이 조정은 공통 조상 트리에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ebc5555eb7976dd79439890cefef50e4fca7252" translate="yes" xml:space="preserve">
          <source>This is a multi-valued variable that defines reference prefixes to match the commands in &lt;code&gt;receive-pack&lt;/code&gt;. Commands matching the prefixes will be executed by an external hook &quot;proc-receive&quot;, instead of the internal &lt;code&gt;execute_commands&lt;/code&gt; function. If this variable is not defined, the &quot;proc-receive&quot; hook will never be used, and all commands will be executed by the internal &lt;code&gt;execute_commands&lt;/code&gt; function.</source>
          <target state="translated">이것은 &lt;code&gt;receive-pack&lt;/code&gt; 의 명령과 일치하는 참조 접두사를 정의하는 다중 값 변수입니다 . 접두사와 일치하는 명령은 내부 &lt;code&gt;execute_commands&lt;/code&gt; 함수 대신 외부 후크 &quot;proc-receive&quot;에 의해 실행됩니다 . 이 변수가 정의되어 있지 않으면 &quot;proc-receive&quot;후크가 사용되지 않으며 모든 명령은 내부 &lt;code&gt;execute_commands&lt;/code&gt; 함수에 의해 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="94478372a5a22fcace1286299ca604a903c0373f" translate="yes" xml:space="preserve">
          <source>This is a multi-valued variable, and an empty value can be used in a higher priority configuration file (e.g. &lt;code&gt;.git/config&lt;/code&gt; in a repository) to clear the values inherited from a lower priority configuration files (e.g. &lt;code&gt;$HOME/.gitconfig&lt;/code&gt;).</source>
          <target state="translated">이는 다중 값 변수이며, 우선 순위가 높은 구성 파일 (예 : 저장소의 &lt;code&gt;.git/config&lt;/code&gt; ) 에서 빈 값을 사용하여 우선 순위 가 낮은 구성 파일 (예 : &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; ) 에서 상속 된 값을 지울 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="9800795b0feafe785919ba7eb03d901a5af98b6d" translate="yes" xml:space="preserve">
          <source>This is a potentially &lt;em&gt;dangerous&lt;/em&gt; mode of operation. It rewrites history, which does not bode well when you published that history already. Do &lt;strong&gt;not&lt;/strong&gt; use this option unless you have read &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; carefully.</source>
          <target state="translated">이것은 잠재적으로 &lt;em&gt;위험한&lt;/em&gt; 작동 모드입니다. 기록을 다시 작성하므로 기록을 이미 게시했을 때 제대로 표시되지 않습니다. 마십시오 &lt;strong&gt;하지&lt;/strong&gt; 당신이 읽기가 없다면이 옵션을 사용하여 &lt;a href=&quot;git-rebase&quot;&gt;자식-REBASE [1]&lt;/a&gt; 을주의 깊게.</target>
        </trans-unit>
        <trans-unit id="7393bcbfeab09d874001a82423e807bb091915e9" translate="yes" xml:space="preserve">
          <source>This is a quick summary of the major commands; the previous chapters explain how these work in more detail.</source>
          <target state="translated">다음은 주요 명령에 대한 간략한 요약입니다. 이전 장에서는 이러한 기능이 어떻게 작동하는지 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e6b70a1472f7c00669a56c92197ed227d5be5866" translate="yes" xml:space="preserve">
          <source>This is a shorthand for &quot;--pretty=oneline --abbrev-commit&quot; used together.</source>
          <target state="translated">이것은 함께 사용되는 &quot;--pretty = oneline --abbrev-commit&quot;의 줄임말입니다.</target>
        </trans-unit>
        <trans-unit id="18c84bcba1b16c1ac1cf14d08c1c68d27e4599a1" translate="yes" xml:space="preserve">
          <source>This is a total waste of time and effort on a filesystem that orders data writes properly, but can be useful for filesystems that do not use journalling (traditional UNIX filesystems) or that only journal metadata and not file contents (OS X&amp;rsquo;s HFS+, or Linux ext3 with &quot;data=writeback&quot;).</source>
          <target state="translated">이는 데이터 쓰기를 올바르게 주문하는 파일 시스템에서 시간과 노력을 낭비하지만 저널링 (전통적인 UNIX 파일 시스템)을 사용하지 않거나 파일 내용이 아닌 저널 메타 데이터 만있는 파일 시스템 (OS X의 HFS + 또는 Linux)에 유용 할 수 있습니다. &quot;data = writeback&quot;이있는 ext3).</target>
        </trans-unit>
        <trans-unit id="554ab63db8a74b017dac093a21d0557d821484db" translate="yes" xml:space="preserve">
          <source>This is a toy format. The current time and time zone of this system is always copied into the identity string at the time it is being created by fast-import. There is no way to specify a different time or time zone.</source>
          <target state="translated">이것은 장난감 형식입니다. 이 시스템의 현재 시간 및 시간대는 빠른 가져 오기로 작성 될 때 항상 식별 문자열에 복사됩니다. 다른 시간대 나 시간대를 지정할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="bc30d84517d5f02b55a3811eba6ffba9e6c0e4f0" translate="yes" xml:space="preserve">
          <source>This is a work in progress.</source>
          <target state="translated">현재 진행중인 작업입니다.</target>
        </trans-unit>
        <trans-unit id="cdf94d586f4e34dd4d9c37fe3a3dd3a90ee94301" translate="yes" xml:space="preserve">
          <source>This is an alias for &lt;code&gt;--group=committer&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;--group=committer&lt;/code&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="3e77feb91313add3d7aff3491329020f7cd2b88e" translate="yes" xml:space="preserve">
          <source>This is an easy way to check out a particular version without having to make up a name for the new branch. You can still create a new branch (or tag) for this version later if you decide to.</source>
          <target state="translated">이것은 새로운 브랜치의 이름을 만들지 않고도 특정 버전을 체크 아웃하는 쉬운 방법입니다. 원하는 경우 나중에이 버전에 대한 새 분기 (또는 태그)를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86d03a90949a936d437c536daea902a3352ca567" translate="yes" xml:space="preserve">
          <source>This is because &lt;code&gt;rebase&lt;/code&gt; is used in a workflow that treats the history at the remote as the shared canonical one, and treats the work done on the branch you are rebasing as the third-party work to be integrated, and you are temporarily assuming the role of the keeper of the canonical history during the rebase. As the keeper of the canonical history, you need to view the history from the remote as &lt;code&gt;ours&lt;/code&gt; (i.e. &quot;our shared canonical history&quot;), while what you did on your side branch as &lt;code&gt;theirs&lt;/code&gt; (i.e. &quot;one contributor&amp;rsquo;s work on top of it&quot;).</source>
          <target state="translated">이는 &lt;code&gt;rebase&lt;/code&gt; 가 원격의 기록을 공유 정식 기록으로 취급하고 분기에서 수행 한 작업을 통합 할 타사 작업으로 취급하고 일시적으로 역할을 가정하는 워크 플로우에서 사용 되기 때문 입니다. rebase 동안 정식 역사의 골키퍼. 정식 역사의 골키퍼로서, 당신은 원격에서 역사를 볼 필요가 &lt;code&gt;ours&lt;/code&gt; 당신이 당신의 곁가지에 무슨 짓을했는지 동안 (즉, &quot;공동의 정식 역사&quot;)와 같은 &lt;code&gt;theirs&lt;/code&gt; (즉, &quot;그 위에 하나 명의 기여의 작품&quot; ).</target>
        </trans-unit>
        <trans-unit id="95a20fc02bc3cd4094f682df1ea1f755e327d688" translate="yes" xml:space="preserve">
          <source>This is called a &lt;code&gt;hunk header&lt;/code&gt;. The &quot;TEXT&quot; portion is by default a line that begins with an alphabet, an underscore or a dollar sign; this matches what GNU &lt;code&gt;diff -p&lt;/code&gt; output uses. This default selection however is not suited for some contents, and you can use a customized pattern to make a selection.</source>
          <target state="translated">이것을 &lt;code&gt;hunk header&lt;/code&gt; 라고합니다 . &quot;TEXT&quot;부분은 기본적으로 알파벳, 밑줄 또는 달러 기호로 시작하는 줄입니다. 이것은 GNU &lt;code&gt;diff -p&lt;/code&gt; 출력이 사용 하는 것과 일치 합니다. 그러나이 기본 선택은 일부 내용에 적합하지 않으며 사용자 정의 패턴을 사용하여 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85de32d717921314245903361d4033db93188253" translate="yes" xml:space="preserve">
          <source>This is default name of common system-wide configuration file.</source>
          <target state="translated">이것은 일반적인 시스템 전체 구성 파일의 기본 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8fabc38be889239efec56b25dba57afb3b308b5b" translate="yes" xml:space="preserve">
          <source>This is default name of fallback system-wide configuration file. This file is used only if per-instance configuration variable is not found.</source>
          <target state="translated">대체 시스템 전체 구성 파일의 기본 이름입니다. 이 파일은 인스턴스 별 구성 변수를 찾을 수없는 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e13cac7eff842df90d7031a70a4150ab3a8cdbc2" translate="yes" xml:space="preserve">
          <source>This is default name of per-instance configuration file. The format of this file is described above.</source>
          <target state="translated">인스턴스 별 구성 파일의 기본 이름입니다. 이 파일의 형식은 위에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ac99b50de3702f5d543e44c6b1ddc55b08d7471" translate="yes" xml:space="preserve">
          <source>This is designed to be as compact as possible.</source>
          <target state="translated">가능한 한 작게 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="2fb3b65e8bdaca2feb11f7bb139eec49acdf4051" translate="yes" xml:space="preserve">
          <source>This is done to avoid disrupting the remote-tracking branches. The end users expect these refs to stay unmoved unless they initiate a fetch. With prefetch task, however, the objects necessary to complete a later real fetch would already be obtained, so the real fetch would go faster. In the ideal case, it will just become an update to a bunch of remote-tracking branches without any object transfer.</source>
          <target state="translated">이는 원격 추적 분기를 방해하지 않기 위해 수행됩니다. 최종 사용자는 가져 오기를 시작하지 않는 한 이러한 참조가 움직이지 않을 것으로 기대합니다. 그러나 프리 페치 작업을 사용하면 나중에 실제 가져 오기를 완료하는 데 필요한 개체를 이미 확보 할 수 있으므로 실제 가져 오기가 더 빨라집니다. 이상적인 경우에는 객체 전송없이 여러 원격 추적 분기에 대한 업데이트가됩니다.</target>
        </trans-unit>
        <trans-unit id="d4d30dfd1772dd73a7b51cd065bd14037d1044bf" translate="yes" xml:space="preserve">
          <source>This is done to prevent you from losing your work-in-progress changes, and mixing your random changes in an unrelated merge commit. To illustrate, suppose you start from what has been committed last to your repository:</source>
          <target state="translated">이는 진행중인 작업 변경 내용을 잃지 않고 관련없는 병합 커밋에서 임의의 변경 내용을 혼합하지 않도록하기 위해 수행됩니다. 예를 들어, 저장소에 마지막으로 커밋 된 것부터 시작한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c5483036881ec5a0c568843866e403149495194d" translate="yes" xml:space="preserve">
          <source>This is how you read a blob (actually, not only a blob, but any type of object). To know how the function &lt;code&gt;read_object_with_reference()&lt;/code&gt; actually works, find the source code for it (something like &lt;code&gt;git grep
read_object_with | grep &quot;:[a-z]&quot;&lt;/code&gt; in the Git repository), and read the source.</source>
          <target state="translated">이것은 당신이 블롭을 읽는 방법입니다 (실제로 블롭뿐만 아니라 모든 유형의 객체). &lt;code&gt;read_object_with_reference()&lt;/code&gt; 함수가 실제로 어떻게 작동하는지 알아 보려면 소스 코드 ( &lt;code&gt;git grep read_object_with | grep &quot;:[a-z]&quot;&lt;/code&gt; 와 같은 것)를 찾아 소스를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="d94f65e687e225292db2cabccebd8f5b3adaa1d5" translate="yes" xml:space="preserve">
          <source>This is ideally suited for read-only updates, i.e., pulling from Git repositories.</source>
          <target state="translated">이것은 읽기 전용 업데이트, 즉 Git 리포지토리에서 가져 오기에 이상적입니다.</target>
        </trans-unit>
        <trans-unit id="4f74abb17322f51c4e08c52446429282a69cbb4c" translate="yes" xml:space="preserve">
          <source>This is intended to be used by the test suite only. It allows to force the version for the generated pack index, and to force 64-bit index entries on objects located above the given offset.</source>
          <target state="translated">이것은 테스트 스위트에서만 사용하기위한 것입니다. 생성 된 팩 색인의 버전을 강제 실행하고 지정된 오프셋 위에있는 오브젝트에서 64 비트 색인 항목을 강제 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8180429180a5d33dfa16e7d2805d2ac9f53f061d" translate="yes" xml:space="preserve">
          <source>This is just to get you into the groove for the most libified part of Git: the revision walker.</source>
          <target state="translated">이것은 Git의 가장 수정 된 부분 인 개정 워커에 대한 홈으로 들어가기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="dce30f3fbb0be29025f159d55505215087cce86b" translate="yes" xml:space="preserve">
          <source>This is known to &lt;code&gt;range-diff&lt;/code&gt; as &quot;dual coloring&quot;. Use &lt;code&gt;--no-dual-color&lt;/code&gt; to revert to color all lines according to the outer diff markers (and completely ignore the inner diff when it comes to color).</source>
          <target state="translated">이것은 &quot;이중 채색&quot;으로 &lt;code&gt;range-diff&lt;/code&gt; 가 다른 것으로 알려져 있습니다. 외부 diff 마커에 따라 모든 선의 &lt;code&gt;--no-dual-color&lt;/code&gt; 을 되돌리려면 --no-dual-color 를 사용하십시오 (그리고 색상과 관련하여 내부 diff를 완전히 무시하십시오).</target>
        </trans-unit>
        <trans-unit id="51ecbd5eaeeeee461a4969f3b0cb27dc975ebc23" translate="yes" xml:space="preserve">
          <source>This is made much worse if many files have to be fixed to resolve conflicts. That&amp;rsquo;s why such merges are called &quot;evil merges&quot;. They can make regressions very difficult to track down. It can even be misleading to know the first bad commit if it happens to be such a merge, because people might think that the bug comes from bad conflict resolution when it comes from a semantic change in one branch.</source>
          <target state="translated">충돌을 해결하기 위해 많은 파일을 수정해야하는 경우 훨씬 더 나빠집니다. 이러한 합병을 &quot;이블 합병&quot;이라고합니다. 회귀 추적을 매우 어렵게 만들 수 있습니다. 사람들이 버그가 하나의 분기에서 의미 론적 변화에서 비롯된 경우 잘못된 충돌 해결에서 비롯된 것으로 생각할 수 있기 때문에 이러한 병합이 발생하는 경우 첫 번째 잘못된 커밋을 아는 것은 잘못된 결과 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2742189647afc1dbda2e1e2ecc6c9303cbb2d70b" translate="yes" xml:space="preserve">
          <source>This is meant to be used by higher level scripts to compute merge results outside of the index, and stuff the results back into the index. For this reason, the output from the command omits entries that match the &amp;lt;branch1&amp;gt; tree.</source>
          <target state="translated">이는 고급 스크립트에서 인덱스 외부의 병합 결과를 계산하고 결과를 다시 인덱스에 채우는 데 사용됩니다. 이러한 이유로 명령의 출력은 &amp;lt;branch1&amp;gt; 트리와 일치하는 항목을 생략합니다.</target>
        </trans-unit>
        <trans-unit id="9ccf843e585a34e60ae505f61685a10813c9c88a" translate="yes" xml:space="preserve">
          <source>This is most often done when you remembered what you just committed is incomplete, or you misspelled your commit message, or both. Leaves working tree as it was before &quot;reset&quot;.</source>
          <target state="translated">이것은 방금 커밋 한 내용이 불완전하거나 커밋 메시지의 철자가 틀리거나 두 가지 모두를 기억할 때 가장 자주 수행됩니다. &quot;재설정&quot;이전과 같이 작업 트리를 떠납니다.</target>
        </trans-unit>
        <trans-unit id="efff48b2c5bed4c5ab6435b6d058280a53664967" translate="yes" xml:space="preserve">
          <source>This is not a command the end user would want to run. Ever. This documentation is meant for people who are studying the Porcelain-ish scripts and/or are writing new ones.</source>
          <target state="translated">이것은 최종 사용자가 실행하고자하는 명령이 아닙니다. 이제까지. 이 문서는 도자기로 된 대본을 공부하거나 새로운 대본을 쓰는 사람들을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1a7ca68cf192059586c364ba5f318ecdbeb3a963" translate="yes" xml:space="preserve">
          <source>This is not a command the end user would want to run. Ever. This documentation is meant for people who are studying the plumbing scripts and/or are writing new ones.</source>
          <target state="translated">이것은 최종 사용자가 실행하려는 명령이 아닙니다. 이제까지. 이 문서는 배관 스크립트를 연구하고 있거나 새로운 스크립트를 작성하는 사람들을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="4c9e09ba77ce1340a426d6ae669add42a4fe4542" translate="yes" xml:space="preserve">
          <source>This is not a real filter executed for each commit but a one time setup just before the loop. Therefore no commit-specific variables are defined yet. Functions or variables defined here can be used or modified in the following filter steps except the commit filter, for technical reasons.</source>
          <target state="translated">이것은 각 커밋에 대해 실행되는 실제 필터가 아니라 루프 직전에 한 번 설정됩니다. 따라서 확약 특정 변수가 아직 정의되지 않았습니다. 여기에 정의 된 함수 또는 변수는 기술적 인 이유로 커밋 필터를 제외한 다음 필터 단계에서 사용하거나 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad1d1c10cd51125ef48d021d8c7283be0413a66d" translate="yes" xml:space="preserve">
          <source>This is not hard to understand, as soon as you realize that Git simply never knows (or cares) about files that it is not told about explicitly. Git will never go &lt;strong&gt;looking&lt;/strong&gt; for files to compare, it expects you to tell it what the files are, and that&amp;rsquo;s what the index is there for.</source>
          <target state="translated">Git이 명시 적으로 알려지지 않은 파일에 대해 결코 알지 못한다는 것을 알게 되 자마자 이해하기 어렵지 않습니다. Git은 비교할 파일을 &lt;strong&gt;찾지&lt;/strong&gt; 않을 것입니다. 파일이 무엇인지 알려주기 때문에 인덱스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0273358cae89a5a683cca4bca340f2d1ab3cc600" translate="yes" xml:space="preserve">
          <source>This is only used by git-completion.bash to add or remove commands from the list of completed commands. Normally only porcelain commands and a few select others are completed. You can add more commands, separated by space, in this variable. Prefixing the command with &lt;code&gt;-&lt;/code&gt; will remove it from the existing list.</source>
          <target state="translated">완료된 명령 목록에서 명령을 추가하거나 제거하기 위해 git-completion.bash에서만 사용됩니다. 일반적으로 도자기 명령과 일부 다른 명령 만 완료됩니다. 이 변수에 공백으로 구분 된 명령을 더 추가 할 수 있습니다. 명령 앞에 &lt;code&gt;-&lt;/code&gt; 를 붙이면 기존 목록에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="fcaf558e1ca35a6c93dcb363081455cef6ced8a0" translate="yes" xml:space="preserve">
          <source>This is only valid for &amp;lt;end&amp;gt; and will specify a number of lines before or after the line given by &amp;lt;start&amp;gt;.</source>
          <target state="translated">이것은 &amp;lt;end&amp;gt;에만 유효하며 &amp;lt;start&amp;gt;에 의해 주어진 행 앞뒤에 많은 행을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3d1897f588ce3866d7bd11a61c4f52eb7dec72ee" translate="yes" xml:space="preserve">
          <source>This is only valid for &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; and will specify a number of lines before or after the line given by &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;&amp;lt;end&amp;gt;&lt;/code&gt; 에만 유효하며 &lt;code&gt;&amp;lt;start&amp;gt;&lt;/code&gt; 에서 제공하는 줄 앞뒤에 줄 수를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="1b0501180252ff128dca83458515deca695a7ecc" translate="yes" xml:space="preserve">
          <source>This is optional and is only searched when &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; is present in $GIT_DIR/config.</source>
          <target state="translated">이것은 선택 사항이며 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 가 $ GIT_DIR / config에 있을 때만 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="4306207006bf4fdd2134f4efea5f0d698d2c1f81" translate="yes" xml:space="preserve">
          <source>This is particularly true when passing in diff options. Currently some options like &lt;code&gt;--stat&lt;/code&gt; can, as an emergent effect, produce output that&amp;rsquo;s quite useless in the context of &lt;code&gt;range-diff&lt;/code&gt;. Future versions of &lt;code&gt;range-diff&lt;/code&gt; may learn to interpret such options in a manner specific to &lt;code&gt;range-diff&lt;/code&gt; (e.g. for &lt;code&gt;--stat&lt;/code&gt; producing human-readable output which summarizes how the diffstat changed).</source>
          <target state="translated">diff 옵션을 전달할 때 특히 그렇습니다. 현재 &lt;code&gt;--stat&lt;/code&gt; 와 같은 일부 옵션 은 출현 효과로 &lt;code&gt;range-diff&lt;/code&gt; 컨텍스트에서 매우 쓸모없는 출력을 생성 할 수 있습니다 . 향후 버전 &lt;code&gt;range-diff&lt;/code&gt; 에 방식으로 특정 이러한 옵션 해석을 배울 수 &lt;code&gt;range-diff&lt;/code&gt; (에 대한 예를 &lt;code&gt;--stat&lt;/code&gt; diffstat 변경 방법을 요약 사람이 읽을 수있는 출력을 생성).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
