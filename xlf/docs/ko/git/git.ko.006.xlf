<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="b4b929406272978e9913bc69bd98a25fedb2b075" translate="yes" xml:space="preserve">
          <source>If generating diffs, detect and report renames for each commit. For following files across renames while traversing history, see &lt;code&gt;--follow&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file&amp;rsquo;s size). For example, &lt;code&gt;-M90%&lt;/code&gt; means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn&amp;rsquo;t changed. Without a &lt;code&gt;%&lt;/code&gt; sign, the number is to be read as a fraction, with a decimal point before it. I.e., &lt;code&gt;-M5&lt;/code&gt; becomes 0.5, and is thus the same as &lt;code&gt;-M50%&lt;/code&gt;. Similarly, &lt;code&gt;-M05&lt;/code&gt; is the same as &lt;code&gt;-M5%&lt;/code&gt;. To limit detection to exact renames, use &lt;code&gt;-M100%&lt;/code&gt;. The default similarity index is 50%.</source>
          <target state="translated">diff를 생성하는 경우 각 커밋에 대한 이름 변경을 감지하고보고하십시오. 히스토리를 순회하면서 이름을 &lt;code&gt;--follow&lt;/code&gt; 파일에 대해서는 --follow를 참조하십시오 . 경우 &lt;code&gt;n&lt;/code&gt; 을 지정, 그것은 유사성 지수 임계 값 (파일의 크기에 비해 추가 / 삭제의 예 양)입니다. 예를 들어, &lt;code&gt;-M90%&lt;/code&gt; 는 파일의 90 % 이상이 변경되지 않은 경우 Git이 삭제 / 추가 쌍을 이름 바꾸기로 간주해야 함을 의미합니다. &lt;code&gt;%&lt;/code&gt; 부호가 없으면 숫자는 소수점 앞에 소수점을 사용하여 분수로 읽습니다. 즉, &lt;code&gt;-M5&lt;/code&gt; 는 0.5가되므로 &lt;code&gt;-M50%&lt;/code&gt; 와 같습니다 . 마찬가지로 &lt;code&gt;-M05&lt;/code&gt; 는 -M5 &lt;code&gt;-M5%&lt;/code&gt; 와 동일 합니다. 정확한 이름 변경으로 탐지를 제한하려면 &lt;code&gt;-M100%&lt;/code&gt; 사용 하십시오.. 기본 유사성 지수는 50 %입니다.</target>
        </trans-unit>
        <trans-unit id="6bf34c88ee2af8f797d0000ddc97681383ffc8ba" translate="yes" xml:space="preserve">
          <source>If git fetch fails because the new head of a branch is not a descendant of the old head, you may force the update with:</source>
          <target state="translated">분기의 새 헤드가 이전 헤드의 후손이 아니기 때문에 git fetch가 실패하면 다음을 사용하여 업데이트를 강제 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e083719ea272a39b1421c558e4392c556db2e4ef" translate="yes" xml:space="preserve">
          <source>If given &lt;code&gt;--thread&lt;/code&gt;, &lt;code&gt;git-format-patch&lt;/code&gt; will generate &lt;code&gt;In-Reply-To&lt;/code&gt; and &lt;code&gt;References&lt;/code&gt; headers to make the second and subsequent patch mails appear as replies to the first mail; this also generates a &lt;code&gt;Message-Id&lt;/code&gt; header to reference.</source>
          <target state="translated">주어진 경우 &lt;code&gt;--thread&lt;/code&gt; , &lt;code&gt;git-format-patch&lt;/code&gt; 생성 &lt;code&gt;In-Reply-To&lt;/code&gt; 과 &lt;code&gt;References&lt;/code&gt; 두 번째 이후 패치 메일이 첫 번째 메일에 대한 응답으로 표시 할 헤더를; 또한 참조 할 &lt;code&gt;Message-Id&lt;/code&gt; 헤더를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="b8bcbf4a83fcf4f75c98a2212241bdcbc1331a73" translate="yes" xml:space="preserve">
          <source>If given, limit the search to paths matching at least one pattern. Both leading paths match and glob(7) patterns are supported.</source>
          <target state="translated">주어진 경우, 하나 이상의 패턴과 일치하는 경로로 검색을 제한하십시오. 선행 경로가 일치하고 glob (7) 패턴이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0f1d3c019382d162e2080cbdc28ed58b9e3bfa0a" translate="yes" xml:space="preserve">
          <source>If given, strings that substitute &lt;code&gt;%(fieldname)&lt;/code&gt; placeholders are quoted as string literals suitable for the specified host language. This is meant to produce a scriptlet that can directly be `eval`ed.</source>
          <target state="translated">주어진 경우, &lt;code&gt;%(fieldname)&lt;/code&gt; 자리 표시자를 대체 하는 문자열은 지정된 호스트 언어에 적합한 문자열 리터럴로 인용됩니다. 이것은 직접 평가할 수있는 스크립틀릿을 생성하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="fbaedaa3bd6d3e9940a1f51ae6f8f8f02a814640" translate="yes" xml:space="preserve">
          <source>If history is linear and HEAD is an ancestor of next, update the working tree and advance the HEAD pointer to match next. Otherwise, apply the changes introduced by those commits that are in next but not HEAD to the current branch, creating a new commit for each new change.</source>
          <target state="translated">히스토리가 선형이고 HEAD가 다음의 조상이면 작업 트리를 업데이트하고 HEAD 포인터를 다음과 일치하도록 진행하십시오. 그렇지 않으면 다음에 있지만 커밋되지 않은 커밋이 도입 한 변경 사항을 현재 분기에 적용하여 새 변경 사항마다 새 커밋을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c5f1ba7eca8a5dae95e4277b8eb6e331cbac924e" translate="yes" xml:space="preserve">
          <source>If it does not apply correctly, there can be various reasons.</source>
          <target state="translated">제대로 적용되지 않으면 여러 가지 이유가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50113fb63d9da87174eb94266585c5426270510c" translate="yes" xml:space="preserve">
          <source>If it does not support the requested operation (e.g., a read-only store), it should silently ignore the request.</source>
          <target state="translated">요청 된 작업 (예 : 읽기 전용 저장소)을 지원하지 않는 경우 요청을 자동으로 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="527b079607be5b2a4ead185d633224b57d83444a" translate="yes" xml:space="preserve">
          <source>If it exits with non-zero status, then the working tree will not be committed after applying the patch.</source>
          <target state="translated">0이 아닌 상태로 종료되면 패치를 적용한 후 작업 트리가 커밋되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="769efb2c6e10769ef0506d8fb6e30821bd41e6ea" translate="yes" xml:space="preserve">
          <source>If it happens that one merge base is bad, then the bisection process is stopped with a message like:</source>
          <target state="translated">하나의 병합 기반이 잘못되면 다음과 같은 메시지와 함께 이분법 프로세스가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="d7b7066e9f3ba640d6b7d345ddda270a80c2a559" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;after&lt;/code&gt;, then each new trailer will appear just after the last trailer with the same &amp;lt;token&amp;gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;after&lt;/code&gt; , 각각의 새로운 트레일러는 &amp;lt;토큰&amp;gt; 같은과 마지막 트레일러 후에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="f2bafbae3498cf1dc8b7c4f581b63d0bfa115d9a" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;before&lt;/code&gt;, then each new trailer will appear just before the first trailer with the same &amp;lt;token&amp;gt;.</source>
          <target state="translated">&lt;code&gt;before&lt;/code&gt; 인 경우 , 각각의 새 트레일러는 동일한 &amp;lt;토큰&amp;gt;을 가진 첫 번째 트레일러 바로 앞에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="76425e0a50de1913b3cc7557f216714041d9e64a" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;end&lt;/code&gt;, then each new trailer will appear at the end of the existing trailers.</source>
          <target state="translated">이 경우 &lt;code&gt;end&lt;/code&gt; 후, 각각의 새로운 트레일러는 기존 트레일러의 끝 부분에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="df34e468f7176e0de86a55be70b61c5f69c7697c" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;start&lt;/code&gt;, then each new trailer will appear at the start, instead of the end, of the existing trailers.</source>
          <target state="translated">그것이 &lt;code&gt;start&lt;/code&gt; 이면, 각각의 새로운 트레일러는 기존 트레일러의 끝이 아니라 시작에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4def1637480df26c3310f2a04dde58c55a8e6a6e" translate="yes" xml:space="preserve">
          <source>If it is set to true, git-fetch-pack will check all fetched objects. See &lt;code&gt;transfer.fsckObjects&lt;/code&gt; for what&amp;rsquo;s checked. Defaults to false. If not set, the value of &lt;code&gt;transfer.fsckObjects&lt;/code&gt; is used instead.</source>
          <target state="translated">그것이 true로 설정되면, git-fetch-pack은 가져온 모든 객체를 검사합니다. 확인 된 내용은 &lt;code&gt;transfer.fsckObjects&lt;/code&gt; 를 참조하십시오 . 기본값은 false입니다. 설정하지 않으면 &lt;code&gt;transfer.fsckObjects&lt;/code&gt; 값이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c85a90553a06232b5ee8a2aebb2a31cb696c1660" translate="yes" xml:space="preserve">
          <source>If it is set to true, git-receive-pack will check all received objects. See &lt;code&gt;transfer.fsckObjects&lt;/code&gt; for what&amp;rsquo;s checked. Defaults to false. If not set, the value of &lt;code&gt;transfer.fsckObjects&lt;/code&gt; is used instead.</source>
          <target state="translated">그것이 true로 설정되면, git-receive-pack은 모든 수신 된 객체를 검사합니다. 확인 된 내용은 &lt;code&gt;transfer.fsckObjects&lt;/code&gt; 를 참조하십시오 . 기본값은 false입니다. 설정하지 않으면 &lt;code&gt;transfer.fsckObjects&lt;/code&gt; 값이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f046c10bd7462cc956529dcbe0a86de2200086ed" translate="yes" xml:space="preserve">
          <source>If it turns out whatever you have done is worth keeping, you can always create a new name for it (without switching away):</source>
          <target state="translated">수행 한 작업이 유지해야 할 가치가있는 것으로 판명되면 언제든지 새 이름을 만들 수 있습니다 (전환하지 않고).</target>
        </trans-unit>
        <trans-unit id="4d0ff556eb63bcc0fd849ad26a1310c3a4323d31" translate="yes" xml:space="preserve">
          <source>If it&amp;rsquo;s not set, filesystem directory&amp;rsquo;s owner is used (via GECOS field, i.e. real name field from &lt;strong&gt;getpwuid&lt;/strong&gt;(3)) if &lt;code&gt;$projects_list&lt;/code&gt; is unset (gitweb scans &lt;code&gt;$projectroot&lt;/code&gt; for repositories); if &lt;code&gt;$projects_list&lt;/code&gt; points to file with list of repositories, then project owner defaults to value from this file for given repository.</source>
          <target state="translated">설정되지 않은 경우 &lt;code&gt;$projects_list&lt;/code&gt; 가 설정되어 있지 않으면 (gitweb 이 저장소에 대해 &lt;code&gt;$projectroot&lt;/code&gt; 를 스캔 함) 파일 시스템 디렉토리의 소유자가 사용됩니다 (GECOS 필드, 즉 &lt;strong&gt;getpwuid의&lt;/strong&gt; 실제 이름 필드 (3) 사용 ). &lt;code&gt;$projects_list&lt;/code&gt; 가 리포지토리 목록이있는 파일을 가리키는 경우 프로젝트 소유자는 지정된 리포지토리에 대해이 파일의 값을 기본값으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1cadf23ffce6eccc7a87c304031ef4b8e4d3adc6" translate="yes" xml:space="preserve">
          <source>If large offsets are required, we use another list of large offsets similar to version 2 pack-indexes.</source>
          <target state="translated">큰 오프셋이 필요한 경우 버전 2 팩 인덱스와 유사한 다른 큰 오프셋 목록을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="960d179c1e161024bf740912a06839844c1002e6" translate="yes" xml:space="preserve">
          <source>If left to accumulate, these stale references might make performance worse on big and busy repos that have a lot of branch churn, and e.g. make the output of commands like &lt;code&gt;git branch -a --contains
&amp;lt;commit&amp;gt;&lt;/code&gt; needlessly verbose, as well as impacting anything else that&amp;rsquo;ll work with the complete set of known references.</source>
          <target state="translated">누적 된 상태로 남겨둔 경우, 이러한 오래된 참조는 분기 이탈이 많은 크고 바쁜 &lt;code&gt;git branch -a --contains &amp;lt;commit&amp;gt;&lt;/code&gt; 에서 성능을 저하시킬 수 있습니다. 예를 들어 git branch -a 와 같은 명령의 출력을 만드는 것은 &amp;lt;commit&amp;gt;을 불필요하게 상세하게 포함하고 영향을 미칩니다 알려진 일련의 알려진 참조와 함께 작동하는 다른 것.</target>
        </trans-unit>
        <trans-unit id="703f6583148f1f4b148dcc92cca37187812e5840" translate="yes" xml:space="preserve">
          <source>If merge is called without any commit argument, merge the upstream branches configured for the current branch by using their last observed values stored in their remote-tracking branches. The values of the &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.merge&lt;/code&gt; that name the branches at the remote named by &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.remote&lt;/code&gt; are consulted, and then they are mapped via &lt;code&gt;remote.&amp;lt;remote&amp;gt;.fetch&lt;/code&gt; to their corresponding remote-tracking branches, and the tips of these tracking branches are merged.</source>
          <target state="translated">commit 인수없이 merge를 호출하면 원격 추적 분기에 저장된 마지막 관찰 된 값을 사용하여 현재 분기에 대해 구성된 업스트림 분기를 병합합니다. 의 값 &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.merge&lt;/code&gt; 원격으로 명명에 그 이름을 분기를 &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.remote&lt;/code&gt; 협의하고, 그 후에는로 매핑되는 &lt;code&gt;remote.&amp;lt;remote&amp;gt;.fetch&lt;/code&gt; 그들의 remote- 대응하는 추적 지점과 이러한 추적 지점의 팁이 병합되었습니다.</target>
        </trans-unit>
        <trans-unit id="115451ca901f83782dcbbcd683a49aed658e9f54" translate="yes" xml:space="preserve">
          <source>If more than one --branches (or --tags) option was given to the &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; command, you must provide the location of the branch (or tag) you wish to create in the SVN repository. &amp;lt;path&amp;gt; specifies which path to use to create the branch or tag and should match the pattern on the left-hand side of one of the configured branches or tags refspecs. You can see these refspecs with the commands</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; 또는 &lt;code&gt;clone&lt;/code&gt; 명령에 둘 이상의 --branches (또는 --tags) 옵션이 제공된 경우 SVN 저장소에서 작성하려는 분기 (또는 태그)의 위치를 ​​제공해야합니다. &amp;lt;path&amp;gt;는 분기 또는 태그를 작성하는 데 사용할 경로를 지정하며 구성된 분기 또는 태그 참조 스펙 중 하나의 왼쪽에있는 패턴과 일치해야합니다. 명령을 사용하여 이러한 참조 사양을 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="720d1ff370baad05fcb8565540994e450819ec63" translate="yes" xml:space="preserve">
          <source>If more than one suffixes match the same tagname, then that tagname will be sorted according to the suffix which starts at the earliest position in the tagname. If more than one different matching suffixes start at that earliest position, then that tagname will be sorted according to the longest of those suffixes. The sorting order between different suffixes is undefined if they are in multiple config files.</source>
          <target state="translated">둘 이상의 접미사가 동일한 태그 이름과 일치하면 해당 태그 이름은 태그 이름의 가장 빠른 위치에서 시작하는 접미사에 따라 정렬됩니다. 하나 이상의 서로 다른 일치하는 접미사가 가장 빠른 위치에서 시작되면 해당 접미사 중 가장 긴 접미사에 따라 태그 이름이 정렬됩니다. 다른 접미사 간의 정렬 순서는 여러 구성 파일에있는 경우 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3ac1856f1f0f57064ddb5057de6638c24881f47" translate="yes" xml:space="preserve">
          <source>If multiple tags were found during the walk then the tag which has the fewest commits different from the input commit-ish will be selected and output. Here fewest commits different is defined as the number of commits which would be shown by &lt;code&gt;git log tag..input&lt;/code&gt; will be the smallest number of commits possible.</source>
          <target state="translated">보행 중에 여러 태그가 발견되면 입력 커밋과 다른 커밋이 가장 적은 태그가 선택되어 출력됩니다. 여기에서 커밋 수가 가장 적은 것은 &lt;code&gt;git log tag..input&lt;/code&gt; 의해 표시되는 커밋 수로 정의됩니다. 입력 은 가능한 최소 커밋 수입니다.</target>
        </trans-unit>
        <trans-unit id="a7822ac9c32ce308a5503a1fdd5fe89ff6cb69d3" translate="yes" xml:space="preserve">
          <source>If neither of the above exist then &lt;code&gt;$XDG_CONFIG_HOME/git/gitk&lt;/code&gt; is created and used by default. If &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; is not set it defaults to &lt;code&gt;$HOME/.config&lt;/code&gt; in all cases.</source>
          <target state="translated">위의 어느 것도 존재하지 않으면 &lt;code&gt;$XDG_CONFIG_HOME/git/gitk&lt;/code&gt; 가 생성되어 기본적으로 사용됩니다. 경우 &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; 에 그것을 기본값으로 설정되지 않은 &lt;code&gt;$HOME/.config&lt;/code&gt; 모든 경우입니다.</target>
        </trans-unit>
        <trans-unit id="cd81c5109f07b879105adf39e250a5f3aca1a356" translate="yes" xml:space="preserve">
          <source>If neither was used, but &lt;code&gt;--date&lt;/code&gt; was given on the command line, show the timestamp in the format requested by &lt;code&gt;--date&lt;/code&gt;.</source>
          <target state="translated">둘 다 사용하지 않은,하지만 경우 &lt;code&gt;--date&lt;/code&gt; 이 명령 행에 주어졌다,에 의해 요구 된 형식의 타임 스탬프 보여 &lt;code&gt;--date&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="a3bb0635e00afaf46918027a40807c06a70ce207" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;pathspec&amp;gt; is given when &lt;code&gt;-A&lt;/code&gt; option is used, all files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories).</source>
          <target state="translated">&lt;code&gt;-A&lt;/code&gt; 옵션을 사용할 때 &amp;lt;pathspec&amp;gt;이 제공되지 않으면 전체 작업 트리의 모든 파일이 업데이트됩니다 (이전 버전의 Git은 현재 디렉토리 및 하위 디렉토리로 업데이트를 제한하는 데 사용됨).</target>
        </trans-unit>
        <trans-unit id="4b6e9bfea0c02571aea512af96edfe88c9715f04" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;pathspec&amp;gt; is given when &lt;code&gt;-u&lt;/code&gt; option is used, all tracked files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories).</source>
          <target state="translated">&lt;code&gt;-u&lt;/code&gt; 옵션을 사용할 때 &amp;lt;pathspec&amp;gt;을 지정하지 않으면 전체 작업 트리에서 추적 된 모든 파일이 업데이트됩니다 (이전 버전의 Git은 업데이트를 현재 디렉토리 및 하위 디렉토리로 제한하는 데 사용됨).</target>
        </trans-unit>
        <trans-unit id="4b6d20762b018937bfcb3d137cde943022a33140" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;--decorate-refs&lt;/code&gt; is given, pretend as if all refs were included. For each candidate, do not use it for decoration if it matches any patterns given to &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; or if it doesn&amp;rsquo;t match any of the patterns given to &lt;code&gt;--decorate-refs&lt;/code&gt;.</source>
          <target state="translated">어떤 경우 &lt;code&gt;--decorate-refs&lt;/code&gt; 주어지지 않는, 모든 심판이 포함 된 경우로 척. 그에게 주어진 어떤 패턴과 일치하는 경우 각 후보의 경우, 장식을 사용하지 않는 &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; 하거나 주어진 패턴과 일치하지 않는 경우 &lt;code&gt;--decorate-refs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7cc86d2479ae0db7a8477b9df1f3902cf870395" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;--decorate-refs&lt;/code&gt; is given, pretend as if all refs were included. For each candidate, do not use it for decoration if it matches any patterns given to &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; or if it doesn&amp;rsquo;t match any of the patterns given to &lt;code&gt;--decorate-refs&lt;/code&gt;. The &lt;code&gt;log.excludeDecoration&lt;/code&gt; config option allows excluding refs from the decorations, but an explicit &lt;code&gt;--decorate-refs&lt;/code&gt; pattern will override a match in &lt;code&gt;log.excludeDecoration&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--decorate-refs&lt;/code&gt; 가 지정 되지 않은 경우 모든 참조가 포함 된 것처럼 가장하십시오. 그에게 주어진 어떤 패턴과 일치하는 경우 각 후보의 경우, 장식을 사용하지 않는 &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; 하거나 주어진 패턴과 일치하지 않는 경우 &lt;code&gt;--decorate-refs&lt;/code&gt; . &lt;code&gt;log.excludeDecoration&lt;/code&gt; 의 설정 옵션은 장식에서 심판을 제외 할 수 있지만 명시 적 &lt;code&gt;--decorate-refs&lt;/code&gt; 패턴에 일치하는 우선합니다 &lt;code&gt;log.excludeDecoration&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="0c2ed2d5d960c224ec529b5f6156261c52081093" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;-b&lt;/code&gt; option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the &quot;*&quot;. This would tell us to use &lt;code&gt;hack&lt;/code&gt; as the local branch when branching off of &lt;code&gt;origin/hack&lt;/code&gt; (or &lt;code&gt;remotes/origin/hack&lt;/code&gt;, or even &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt;). If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted. You can explicitly give a name with &lt;code&gt;-b&lt;/code&gt; in such a case.</source>
          <target state="translated">&lt;code&gt;-b&lt;/code&gt; 옵션을 지정 하지 않으면 해당 분기에 대해 구성된 참조 사양의 로컬 부분을보고 &quot;*까지 초기 부분을 제거하여 새 분기의 이름이 원격 추적 분기에서 파생됩니다. &quot;. 이것은 &lt;code&gt;origin/hack&lt;/code&gt; (또는 &lt;code&gt;remotes/origin/hack&lt;/code&gt; 또는 &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt; )에서 분기 할 때 &lt;code&gt;hack&lt;/code&gt; 을 로컬 브랜치로 사용하도록 지시합니다 . 주어진 이름에 슬래시가 없거나 위의 추측 결과 빈 이름이 나오면 추측이 중단됩니다. 이 경우 명시 적으로 &lt;code&gt;-b&lt;/code&gt; 를 사용하여 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b362c22d46cf3c9ce26cb952c31ebfa05896260" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;-c&lt;/code&gt; option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the &quot;*&quot;. This would tell us to use &lt;code&gt;hack&lt;/code&gt; as the local branch when branching off of &lt;code&gt;origin/hack&lt;/code&gt; (or &lt;code&gt;remotes/origin/hack&lt;/code&gt;, or even &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt;). If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted. You can explicitly give a name with &lt;code&gt;-c&lt;/code&gt; in such a case.</source>
          <target state="translated">&lt;code&gt;-c&lt;/code&gt; 옵션을 지정 하지 않으면 해당 분기에 대해 구성된 참조 사양의 로컬 부분을보고 새 부분을 &quot;*까지 제거하여 새 분기의 이름이 원격 추적 분기에서 파생됩니다. &quot;. 이것은 &lt;code&gt;origin/hack&lt;/code&gt; (또는 &lt;code&gt;remotes/origin/hack&lt;/code&gt; 또는 &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt; )에서 분기 할 때 &lt;code&gt;hack&lt;/code&gt; 을 로컬 브랜치로 사용하도록 지시합니다 . 주어진 이름에 슬래시가 없거나 위의 추측 결과 빈 이름이 나오면 추측이 중단됩니다. 이 경우 명시 적으로 &lt;code&gt;-c&lt;/code&gt; 를 사용하여 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5eb9ed53cf409691a2adb1a958e7a2a354184a7" translate="yes" xml:space="preserve">
          <source>If no branch is specified and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; is used, then &lt;code&gt;git worktree add&lt;/code&gt; defaults to creating a new branch from HEAD. If &lt;code&gt;worktree.guessRemote&lt;/code&gt; is set to true, &lt;code&gt;worktree add&lt;/code&gt; tries to find a remote-tracking branch whose name uniquely matches the new branch name. If such a branch exists, it is checked out and set as &quot;upstream&quot; for the new branch. If no such match can be found, it falls back to creating a new branch from the current HEAD.</source>
          <target state="translated">분기가 지정되지 않고 &lt;code&gt;-b&lt;/code&gt; 또는 &lt;code&gt;-B&lt;/code&gt; 및 &lt;code&gt;--detach&lt;/code&gt; 가 사용 되지 않으면 &lt;code&gt;git worktree add&lt;/code&gt; 는 HEAD에서 새 분기를 작성하기 위해 기본값을 추가 합니다. &lt;code&gt;worktree.guessRemote&lt;/code&gt; 가 true로 설정된 경우 worktree &lt;code&gt;worktree add&lt;/code&gt; 는 새 분기 이름과 고유 한 이름을 가진 원격 추적 분기를 찾으려고 시도합니다. 그러한 분기가 존재하면 체크 아웃되고 새 분기에 대해 &quot;업스트림&quot;으로 설정됩니다. 일치하는 항목을 찾을 수 없으면 현재 HEAD에서 새 분기를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="cd840721ca4f2ba5f348ba0cdeddc96e7d47ba2a" translate="yes" xml:space="preserve">
          <source>If no command-line option is passed, the &lt;code&gt;help.format&lt;/code&gt; configuration variable will be checked. The following values are supported for this variable; they make &lt;code&gt;git help&lt;/code&gt; behave as their corresponding command- line option:</source>
          <target state="translated">명령 행 옵션이 전달되지 않으면 &lt;code&gt;help.format&lt;/code&gt; 구성 변수가 점검됩니다. 이 변수에 대해 다음 값이 지원됩니다. 그들은 &lt;code&gt;git help&lt;/code&gt; 가 해당 명령 행 옵션으로 동작하도록합니다.</target>
        </trans-unit>
        <trans-unit id="48f09dc10a5152e65a114506d3daba225636a70e" translate="yes" xml:space="preserve">
          <source>If no commit ID is found, &lt;code&gt;git get-tar-commit-id&lt;/code&gt; quietly exists with a return code of 1. This can happen if the archive had not been created using &lt;code&gt;git archive&lt;/code&gt; or if the first parameter of &lt;code&gt;git archive&lt;/code&gt; had been a tree ID instead of a commit ID or tag.</source>
          <target state="translated">어떤 경우 ID가 발견 커밋하지 &lt;code&gt;git get-tar-commit-id&lt;/code&gt; 조용히 아카이브를 사용하여 생성되지 않은 경우가 발생할 수 1의 리턴 코드로 존재 &lt;code&gt;git archive&lt;/code&gt; 또는 첫 번째 매개 변수 경우 &lt;code&gt;git archive&lt;/code&gt; 트리 ID 있었다 커밋 ID 또는 태그 대신.</target>
        </trans-unit>
        <trans-unit id="daf3aead6a5bfcff96ae9ec0da48e9d2be49b75e" translate="yes" xml:space="preserve">
          <source>If no commit is given from the command line, merge the remote-tracking branches that the current branch is configured to use as its upstream. See also the configuration section of this manual page.</source>
          <target state="translated">명령 줄에서 커밋이 제공되지 않으면 현재 분기가 업스트림으로 사용하도록 구성된 원격 추적 분기를 병합하십시오. 이 매뉴얼 페이지의 구성 섹션도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7188b50eb220f479115e7bb7b4e8a6b937273e6f" translate="yes" xml:space="preserve">
          <source>If no format is specified, the default format is &lt;code&gt;%(objectname)
%(objecttype) %(objectsize)&lt;/code&gt;.</source>
          <target state="translated">형식을 지정하지 않으면 기본 형식은 &lt;code&gt;%(objectname) %(objecttype) %(objectsize)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e72375796417844d20df5e1c264d965559c3c0c9" translate="yes" xml:space="preserve">
          <source>If no further options are given, all reading options will read all of these files that are available. If the global or the system-wide configuration file are not available they will be ignored. If the repository configuration file is not available or readable, &lt;code&gt;git config&lt;/code&gt; will exit with a non-zero error code. However, in neither case will an error message be issued.</source>
          <target state="translated">추가 옵션이 제공되지 않으면 모든 읽기 옵션에서 사용 가능한 모든 파일을 읽습니다. 글로벌 또는 시스템 전체 구성 파일을 사용할 수 없으면 무시됩니다. 저장소 구성 파일을 사용할 수 없거나 읽을 수없는 경우 &lt;code&gt;git config&lt;/code&gt; 는 0이 아닌 오류 코드와 함께 종료됩니다. 그러나 어떤 경우에도 오류 메시지가 발행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="542c100edd4ea5b59ab171a7795bc617673af483" translate="yes" xml:space="preserve">
          <source>If no objects are given, &lt;code&gt;git fsck&lt;/code&gt; defaults to using the index file, all SHA-1 references in &lt;code&gt;refs&lt;/code&gt; namespace, and all reflogs (unless --no-reflogs is given) as heads.</source>
          <target state="translated">객체가 제공되지 않으면 &lt;code&gt;git fsck&lt;/code&gt; 는 기본적으로 인덱스 파일, &lt;code&gt;refs&lt;/code&gt; 네임 스페이스의 모든 SHA-1 참조 및 모든 reflog (-no-reflogs가 제공되지 않은 경우)를 헤드로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3ac71fd77839914951c054588c999a4a8ef138ac" translate="yes" xml:space="preserve">
          <source>If no revisions are passed on the command line and either standard input is not a terminal or there is no current branch, &lt;code&gt;git shortlog&lt;/code&gt; will output a summary of the log read from standard input, without reference to the current repository.</source>
          <target state="translated">명령 행에 개정이 전달되지 않고 표준 입력이 터미널이 아니거나 현재 분기가없는 경우 &lt;code&gt;git shortlog&lt;/code&gt; 는 현재 저장소를 참조하지 않고 표준 입력에서 읽은 로그 요약을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="abf7234009b8e35c90eeb194fcd9fd8cfced1763" translate="yes" xml:space="preserve">
          <source>If no username is set for a network authentication, use this username by default. See credential.&amp;lt;context&amp;gt;.* below, and &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt;.</source>
          <target state="translated">네트워크 인증에 사용자 이름이 설정되어 있지 않으면이 사용자 이름을 기본적으로 사용하십시오. 아래의 credential. &amp;lt;context&amp;gt;. * 및 &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="68bd2465b7813ae05686685c60e9c1221c412754" translate="yes" xml:space="preserve">
          <source>If non-zero, all packs larger than this limit are kept when &lt;code&gt;git gc&lt;/code&gt; is run. This is very similar to &lt;code&gt;--keep-base-pack&lt;/code&gt; except that all packs that meet the threshold are kept, not just the base pack. Defaults to zero. Common unit suffixes of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt; are supported.</source>
          <target state="translated">0이 아닌 경우, &lt;code&gt;git gc&lt;/code&gt; 가 실행될 때이 한계보다 큰 모든 팩이 유지됩니다 . 이는 기본 팩뿐만 아니라 임계 값을 충족하는 모든 팩이 유지된다는 점을 제외하고 &lt;code&gt;--keep-base-pack&lt;/code&gt; 과 매우 유사합니다 . 기본값은 0입니다. &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; 또는 &lt;code&gt;g&lt;/code&gt; 의 공통 단위 접미사 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="80f929e50dc4409c5d26df44de311be2ffed8079" translate="yes" xml:space="preserve">
          <source>If none of &lt;code&gt;--stdin&lt;/code&gt;, &lt;code&gt;--all&lt;/code&gt;, or &lt;code&gt;--&lt;/code&gt; is used, the first argument will be treated as an attribute and the rest of the arguments as pathnames.</source>
          <target state="translated">&lt;code&gt;--stdin&lt;/code&gt; , &lt;code&gt;--all&lt;/code&gt; 또는 &lt;code&gt;--&lt;/code&gt; 을 사용 하지 않으면 첫 번째 인수는 속성으로 처리되고 나머지 인수는 경로 이름으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="af13390230f0ed2d9d7a8cd452e31841984f2fea" translate="yes" xml:space="preserve">
          <source>If not set (default), it means that this feature is disabled.</source>
          <target state="translated">설정하지 않으면 (기본값)이 기능이 비활성화 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="ffeb0befbf6f99dd0616072c3aff8f91a09da3dd" translate="yes" xml:space="preserve">
          <source>If not set explicitly with &lt;code&gt;--file&lt;/code&gt;, there are four files where &lt;code&gt;git config&lt;/code&gt; will search for configuration options:</source>
          <target state="translated">&lt;code&gt;--file&lt;/code&gt; 을 명시 적으로 설정하지 않으면 &lt;code&gt;git config&lt;/code&gt; 가 구성 옵션을 검색 하는 4 개의 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="42b0a7358d3a7018936abd1faefcf6d947a2a30c" translate="yes" xml:space="preserve">
          <source>If not set explicitly with &lt;code&gt;--file&lt;/code&gt;, there are two files where git-credential-store will search for credentials in order of precedence:</source>
          <target state="translated">&lt;code&gt;--file&lt;/code&gt; 을 명시 적으로 설정하지 않으면 git-credential-store가 우선 순위에 따라 자격 증명을 검색하는 두 개의 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dcc101d67cdfa1a1e655970a079699595239b44" translate="yes" xml:space="preserve">
          <source>If not set in the environment, the list of notes to copy depends on the &lt;code&gt;notes.rewrite.&amp;lt;command&amp;gt;&lt;/code&gt; and &lt;code&gt;notes.rewriteRef&lt;/code&gt; settings.</source>
          <target state="translated">환경에서 설정하지 않은 경우 복사 할 메모 목록은 &lt;code&gt;notes.rewrite.&amp;lt;command&amp;gt;&lt;/code&gt; 및 &lt;code&gt;notes.rewriteRef&lt;/code&gt; 설정 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="324a704070b71849b1d4e1ca6f933c2b17a7a16e" translate="yes" xml:space="preserve">
          <source>If not specified, the contents are restored from &lt;code&gt;HEAD&lt;/code&gt; if &lt;code&gt;--staged&lt;/code&gt; is given, otherwise from the index.</source>
          <target state="translated">지정되지 않은 경우 &lt;code&gt;--staged&lt;/code&gt; 가 제공 되면 &lt;code&gt;HEAD&lt;/code&gt; 에서 콘텐츠가 복원되고 그렇지 않으면 인덱스에서 복원됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9f85a49fbdf8e068a215ef9d6f0bd6bbfeb7a4e" translate="yes" xml:space="preserve">
          <source>If not specified, the default restore source for the working tree is the index, and the default restore source for the index is &lt;code&gt;HEAD&lt;/code&gt;. When both &lt;code&gt;--staged&lt;/code&gt; and &lt;code&gt;--worktree&lt;/code&gt; are specified, &lt;code&gt;--source&lt;/code&gt; must also be specified.</source>
          <target state="translated">지정되지 않은 경우 작업 트리의 기본 복원 소스는 색인이고 색인의 기본 복원 소스는 &lt;code&gt;HEAD&lt;/code&gt; 입니다. 모두가 때 &lt;code&gt;--staged&lt;/code&gt; 및 &lt;code&gt;--worktree&lt;/code&gt; 가 지정되어, &lt;code&gt;--source&lt;/code&gt; 는 도 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="56d3a4f46f938bb42b1fca6d786b8e7fc54bbe14" translate="yes" xml:space="preserve">
          <source>If nothing matches, &lt;code&gt;git show-ref&lt;/code&gt; will return an error code of 1, and in the case of verification, it will show an error message.</source>
          <target state="translated">일치하는 것이 없으면 &lt;code&gt;git show-ref&lt;/code&gt; 는 오류 코드 1을 반환하고 확인의 경우 오류 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b1f5a8844fabfc412b2762d5d95a3c4d967624ca" translate="yes" xml:space="preserve">
          <source>If one of &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, or &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; is passed, the command creates a &lt;code&gt;tag&lt;/code&gt; object, and requires a tag message. Unless &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; or &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; is given, an editor is started for the user to type in the tag message.</source>
          <target state="translated">&lt;code&gt;-a&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; 또는 &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 중 하나 가 전달되면 명령이 &lt;code&gt;tag&lt;/code&gt; 객체를 작성 하고 태그 메시지가 필요합니다. &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; 이 제공 되지 않으면 사용자가 태그 메시지를 입력 할 수있는 편집기가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="2202ccf1357459c2102fac8580d0b9c370cb2843" translate="yes" xml:space="preserve">
          <source>If one or more &amp;lt;file&amp;gt; parameters are given, the merge tool program will be run to resolve differences on each file (skipping those without conflicts). Specifying a directory will include all unresolved files in that path. If no &amp;lt;file&amp;gt; names are specified, &lt;code&gt;git mergetool&lt;/code&gt; will run the merge tool program on every file with merge conflicts.</source>
          <target state="translated">하나 이상의 &amp;lt;file&amp;gt; 매개 변수가 제공되면, 병합 도구 프로그램이 실행되어 각 파일의 차이점을 해결합니다 (충돌이없는 매개 변수 생략). 디렉토리를 지정하면 해당 경로에 해결되지 않은 모든 파일이 포함됩니다. &amp;lt;file&amp;gt; 이름이 지정되지 않으면 &lt;code&gt;git mergetool&lt;/code&gt; 은 병합 충돌이있는 모든 파일에서 병합 도구 프로그램을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="ce7c35e9da7a7a12641957ffb2984ef7917b0e3e" translate="yes" xml:space="preserve">
          <source>If one or more patterns are given, only refs are shown that match against at least one pattern, either using fnmatch(3) or literally, in the latter case matching completely or from the beginning up to a slash.</source>
          <target state="translated">하나 이상의 패턴이 제공되면 fnmatch (3)를 사용하거나 문자 그대로 후자의 경우 완전히 또는 처음부터 슬래시까지 일치하는 하나 이상의 패턴과 일치하는 참조 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d335af2a37a580d9863e5a06bbfa0d646026268f" translate="yes" xml:space="preserve">
          <source>If one wishes to use the ref &lt;code&gt;ref/notes/true&lt;/code&gt;, please use that literal instead.</source>
          <target state="translated">ref &lt;code&gt;ref/notes/true&lt;/code&gt; 를 사용하려면 대신 해당 리터럴을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c90c8ad16602dc9d2f205c9d917c69aa3c723c01" translate="yes" xml:space="preserve">
          <source>If only &amp;lt;infd&amp;gt; is given, it is assumed to be a bidirectional socket connected to remote Git server (git-upload-pack, git-receive-pack or git-upload-archive). If both &amp;lt;infd&amp;gt; and &amp;lt;outfd&amp;gt; are given, they are assumed to be pipes connected to a remote Git server (&amp;lt;infd&amp;gt; being the inbound pipe and &amp;lt;outfd&amp;gt; being the outbound pipe.</source>
          <target state="translated">&amp;lt;infd&amp;gt; 만 주어진 경우, 원격 Git 서버 (git-upload-pack, git-receive-pack 또는 git-upload-archive)에 연결된 양방향 소켓 인 것으로 가정합니다. &amp;lt;infd&amp;gt;와 &amp;lt;outfd&amp;gt;가 모두 주어지면, 원격 Git 서버에 연결된 파이프 (&amp;lt;infd&amp;gt;는 인바운드 파이프이고 &amp;lt;outfd&amp;gt;는 아웃 바운드 파이프 인 것으로 가정)입니다.</target>
        </trans-unit>
        <trans-unit id="ce722a3060a9ef1801cda4fdb7cc3661d10ec67c" translate="yes" xml:space="preserve">
          <source>If only 1 tree is specified, &lt;code&gt;git read-tree&lt;/code&gt; operates as if the user did not specify &lt;code&gt;-m&lt;/code&gt;, except that if the original index has an entry for a given pathname, and the contents of the path match with the tree being read, the stat info from the index is used. (In other words, the index&amp;rsquo;s stat()s take precedence over the merged tree&amp;rsquo;s).</source>
          <target state="translated">트리가 1 개만 지정된 경우, &lt;code&gt;git read-tree&lt;/code&gt; 는 사용자가 &lt;code&gt;-m&lt;/code&gt; 을 지정하지 않은 것처럼 작동합니다 . 단, 원래 색인에 지정된 경로 이름에 대한 항목이 있고 경로의 내용이 읽는 트리와 일치하는 경우는 예외입니다. 인덱스의 통계 정보가 사용됩니다. 즉, 인덱스의 stat ()가 병합 된 트리보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="ed44ceba40face622ee83aefe1801bafac3f799c" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;check-connectivity&lt;/code&gt; is requested, the helper must output &lt;code&gt;connectivity-ok&lt;/code&gt; if the clone is self-contained and connected.</source>
          <target state="translated">&lt;code&gt;check-connectivity&lt;/code&gt; 옵션 이 요청되면 클론이 자체 포함되어 연결되어 있으면 도우미가 &lt;code&gt;connectivity-ok&lt;/code&gt; 출력해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d94f0028bb24f94910f79bf2b787bad6af3cf852" translate="yes" xml:space="preserve">
          <source>If other people are pulling from your repository over dumb transport protocols (HTTP), you need to keep this repository &lt;code&gt;dumb transport friendly&lt;/code&gt;. After &lt;code&gt;git init&lt;/code&gt;, &lt;code&gt;$GIT_DIR/hooks/post-update.sample&lt;/code&gt; copied from the standard templates would contain a call to &lt;code&gt;git update-server-info&lt;/code&gt; but you need to manually enable the hook with &lt;code&gt;mv post-update.sample post-update&lt;/code&gt;. This makes sure &lt;code&gt;git update-server-info&lt;/code&gt; keeps the necessary files up to date.</source>
          <target state="translated">다른 사람이 바보 전송 프로토콜 (HTTP)을 통해 저장소에서 가져 오는 경우이 저장소 &lt;code&gt;dumb transport friendly&lt;/code&gt; 하게 유지해야합니다 . 후 &lt;code&gt;git init&lt;/code&gt; , &lt;code&gt;$GIT_DIR/hooks/post-update.sample&lt;/code&gt; 표준 템플릿에서 복사가의 호출에 포함됩니다 &lt;code&gt;git update-server-info&lt;/code&gt; 하지만 당신은 수동으로 후크 활성화해야 &lt;code&gt;mv post-update.sample post-update&lt;/code&gt; . 이것은 &lt;code&gt;git update-server-info&lt;/code&gt; 가 필요한 파일을 최신 상태로 유지하도록합니다.</target>
        </trans-unit>
        <trans-unit id="e17148a8f3d2ab81971460344696589bc00ec7fe" translate="yes" xml:space="preserve">
          <source>If provided, the results are limited to a subset of files matching one of the provided pathspecs.</source>
          <target state="translated">제공된 경우 결과는 제공된 경로 스펙 중 하나와 일치하는 파일의 서브 세트로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="c6bf36e1017847984a394e553be49b7f1e0149c6" translate="yes" xml:space="preserve">
          <source>If separate &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;committer&lt;/code&gt; commands are used in a &lt;code&gt;commit&lt;/code&gt; the timestamps may not match, as the system clock will be polled twice (once for each command). The only way to ensure that both author and committer identity information has the same timestamp is to omit &lt;code&gt;author&lt;/code&gt; (thus copying from &lt;code&gt;committer&lt;/code&gt;) or to use a date format other than &lt;code&gt;now&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;commit&lt;/code&gt; 에서 별도의 &lt;code&gt;author&lt;/code&gt; 및 &lt;code&gt;committer&lt;/code&gt; 명령을 사용 하면 시스템 시계가 두 번 폴링되므로 (각 명령마다 한 번씩) 타임 스탬프가 일치하지 않을 수 있습니다. 유일한 방법은 생략 할 수있다 저자 및 커미터 신원 정보가 동일한 타임 스탬프를 가지고 있는지 확인하기 위해 &lt;code&gt;author&lt;/code&gt; (따라서에서 복사 &lt;code&gt;committer&lt;/code&gt; ) 또는 이외의 날짜 형식을 사용하는 &lt;code&gt;now&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="866d5a5839fdc5ae41f48af4bbd37789bc250691" translate="yes" xml:space="preserve">
          <source>If set &lt;code&gt;--base=auto&lt;/code&gt; in cmdline, it will track base commit automatically, the base commit will be the merge base of tip commit of the remote-tracking branch and revision-range specified in cmdline. For a local branch, you need to track a remote branch by &lt;code&gt;git branch
--set-upstream-to&lt;/code&gt; before using this option.</source>
          <target state="translated">cmdline에서 &lt;code&gt;--base=auto&lt;/code&gt; 로 설정하면 기본 커밋이 자동으로 추적되고, 기본 커밋은 cmdline에 지정된 원격 추적 분기의 팁 커밋과 개정 범위의 병합 기반이됩니다. 로컬 지점의 경우이 옵션을 사용 &lt;code&gt;git branch --set-upstream-to&lt;/code&gt; 전에 git branch --set-upstream-to 로 원격 지점을 추적해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c4e55e2ff9b8cf62b34b50d7d6b4a09bd94fb5d9" translate="yes" xml:space="preserve">
          <source>If set to &quot;auto&quot;, &lt;code&gt;git-commit&lt;/code&gt; would select a character that is not the beginning character of any line in existing commit messages.</source>
          <target state="translated">&quot;auto&quot;로 설정하면 &lt;code&gt;git-commit&lt;/code&gt; 은 기존 커밋 메시지에서 줄의 시작 문자가 아닌 문자를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="3cb1da898d09757c537ab553b3fe27d9de1953ee" translate="yes" xml:space="preserve">
          <source>If set to &quot;warn&quot;, git rebase -i will print a warning if some commits are removed (e.g. a line was deleted), however the rebase will still proceed. If set to &quot;error&quot;, it will print the previous warning and stop the rebase, &lt;code&gt;git rebase --edit-todo&lt;/code&gt; can then be used to correct the error. If set to &quot;ignore&quot;, no checking is done. To drop a commit without warning or error, use the &lt;code&gt;drop&lt;/code&gt; command in the todo list. Defaults to &quot;ignore&quot;.</source>
          <target state="translated">&quot;warn&quot;으로 설정하면 git rebase -i는 일부 커밋이 제거되면 (예 : 라인이 삭제 된 경우) 경고를 표시하지만 rebase는 계속 진행됩니다. &quot;error&quot;로 설정하면 이전 경고를 인쇄하고 rebase를 중지합니다. &lt;code&gt;git rebase --edit-todo&lt;/code&gt; 를 사용하여 오류를 수정할 수 있습니다. &quot;무시&quot;로 설정하면 검사가 수행되지 않습니다. 경고 나 오류없이 커밋을 삭제하려면 할 일 목록에서 &lt;code&gt;drop&lt;/code&gt; 명령을 사용하십시오 . 기본값은 &quot;무시&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="ac8b0270c3c47d08febdcf04811ec5325e6bcef3" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;0&lt;/code&gt;, Git will complete any requested operation without performing any optional sub-operations that require taking a lock. For example, this will prevent &lt;code&gt;git status&lt;/code&gt; from refreshing the index as a side effect. This is useful for processes running in the background which do not want to cause lock contention with other operations on the repository. Defaults to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 으로 설정 되면 Git은 잠금이 필요한 선택적 하위 작업을 수행하지 않고 요청 된 작업을 완료합니다. 예를 들어, 이것은 &lt;code&gt;git status&lt;/code&gt; 가 색인으로 색인을 새로 고치는 것을 방지 합니다. 이는 백그라운드에서 실행중인 프로세스에서 저장소의 다른 조작으로 잠금 경합을 일으키지 않으려는 경우에 유용합니다. 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9d1e5156e1d430a4750260179109e036962ca85d" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;1&lt;/code&gt;, include broken or badly named refs when iterating over lists of refs. In a normal, non-corrupted repository, this does nothing. However, enabling it may help git to detect and abort some operations in the presence of broken refs. Git sets this variable automatically when performing destructive operations like &lt;a href=&quot;git-prune&quot;&gt;git-prune[1]&lt;/a&gt;. You should not need to set it yourself unless you want to be paranoid about making sure an operation has touched every ref (e.g., because you are cloning a repository to make a backup).</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 로 설정된 경우 심판 목록을 반복 할 때 파손되거나 잘못 명명 된 심판을 포함시킵니다. 손상되지 않은 정상적인 저장소에서는 아무 것도 수행하지 않습니다. 그러나이 기능을 활성화하면 ref가 깨진 참조가있는 경우 일부 작업을 감지하고 중단하는 데 도움이 될 수 있습니다. Git은 &lt;a href=&quot;git-prune&quot;&gt;git-prune [1]&lt;/a&gt; 과 같은 파괴적인 작업을 수행 할 때이 변수를 자동으로 설정합니다 . 작업이 모든 참조에 닿아 있는지 확인하지 않으려는 경우 (예 : 백업을 위해 리포지토리를 복제하기 때문에) 편집증을 원치 않는 한 직접 설정하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="721e268a3bbca2372f644ef6baf34d6bc14a8b54" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;false&lt;/code&gt;, behave as if the &lt;code&gt;--no-replace-objects&lt;/code&gt; option was given on the command line. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; and &lt;a href=&quot;git-replace&quot;&gt;git-replace[1]&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 로 설정 되면 &lt;code&gt;--no-replace-objects&lt;/code&gt; 옵션이 명령 행에 제공된 것처럼 작동합니다 . 자세한 내용은 &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 및 &lt;a href=&quot;git-replace&quot;&gt;git-replace [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0f2d027bcde6fa30d6f1d075f8f588cf0e958fbb" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;git diff&lt;/code&gt; does not show changes outside of the directory and show pathnames relative to the current directory.</source>
          <target state="translated">로 설정하면 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;git diff&lt;/code&gt; 외부 디렉토리의 변경을 표시하지 않고 쇼는 현재 디렉토리에 상대적인 경로 이름.</target>
        </trans-unit>
        <trans-unit id="5c80e3d63d134dccb3136c655fb06b3aa0219fb0" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;yes&lt;/code&gt;, print an ellipsis following an (abbreviated) SHA-1 value. This affects indications of detached HEADs (&lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;) and the raw diff output (&lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;). Printing an ellipsis in the cases mentioned is no longer considered adequate and support for it is likely to be removed in the foreseeable future (along with the variable).</source>
          <target state="translated">&lt;code&gt;yes&lt;/code&gt; 로 설정되면 (약칭 된) SHA-1 값 뒤에 줄임표를 인쇄하십시오. 이는 분리 된 HEAD ( &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; ) 및 원시 diff 출력 ( &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; )의 표시에 영향을줍니다 . 언급 된 사례에서 줄임표를 인쇄하는 것은 더 이상 적절한 것으로 간주되지 않으며 가까운 장래에 변수에 대한 지원이 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03e97ab625ba0ca85ff94dae74e07745d32e9ba5" translate="yes" xml:space="preserve">
          <source>If set to a colon-separated list of protocols, behave as if &lt;code&gt;protocol.allow&lt;/code&gt; is set to &lt;code&gt;never&lt;/code&gt;, and each of the listed protocols has &lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt; set to &lt;code&gt;always&lt;/code&gt; (overriding any existing configuration). In other words, any protocol not mentioned will be disallowed (i.e., this is a whitelist, not a blacklist). See the description of &lt;code&gt;protocol.allow&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for more details.</source>
          <target state="translated">콜론으로 구분 된 프로토콜 목록으로 설정된 경우 &lt;code&gt;protocol.allow&lt;/code&gt; 가 &lt;code&gt;never&lt;/code&gt; 로 설정되고 나열된 각 프로토콜에 &lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt; 가 &lt;code&gt;always&lt;/code&gt; 설정되어 있습니다 (기존 구성을 재정의 함). 즉, 언급되지 않은 프로토콜은 허용되지 않습니다 (즉, 블랙리스트가 아닌 화이트리스트입니다). 자세한 내용은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 &lt;code&gt;protocol.allow&lt;/code&gt; 에 대한 설명 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3efcc8bea067f2176f4b0bb44941378607e1ec05" translate="yes" xml:space="preserve">
          <source>If set to an algorithm, indicate that the caller wants to interact with the remote side using that algorithm.</source>
          <target state="translated">알고리즘으로 설정된 경우 호출자가 해당 알고리즘을 사용하여 원격 측과 상호 작용하기를 원함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d02bbac09e65cccb0fb85d779cd5ffdc25f0fea6" translate="yes" xml:space="preserve">
          <source>If set to either a valid &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; or a true value, moved lines in a diff are colored differently, for details of valid modes see &lt;code&gt;--color-moved&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. If simply set to true the default color mode will be used. When set to false, moved lines are not colored.</source>
          <target state="translated">유효한 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 또는 true 값으로 설정하면 diff에서 이동 한 행의 색상이 다르게 표시됩니다. 유효한 모드에 대한 자세한 내용은 &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]의 &lt;/a&gt; &lt;code&gt;--color-moved&lt;/code&gt; 를 참조하십시오 . 단순히 true로 설정하면 기본 색상 모드가 사용됩니다. false로 설정하면 이동 한 선이 색상으로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2017527381afe3327ef07745ea82e7ee1e2ae55" translate="yes" xml:space="preserve">
          <source>If set to true enable &lt;code&gt;--autosquash&lt;/code&gt; option by default.</source>
          <target state="translated">true로 설정하면 기본적으로 &lt;code&gt;--autosquash&lt;/code&gt; 옵션을 활성화 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7630a0d058d7490b6c2c7394afc94b9292f8389f" translate="yes" xml:space="preserve">
          <source>If set to true enable &lt;code&gt;--follow-tags&lt;/code&gt; option by default. You may override this configuration at time of push by specifying &lt;code&gt;--no-follow-tags&lt;/code&gt;.</source>
          <target state="translated">true로 설정하면 기본적으로 &lt;code&gt;--follow-tags&lt;/code&gt; 옵션을 활성화하십시오 . &lt;code&gt;--no-follow-tags&lt;/code&gt; 를 지정하여 푸시시이 구성을 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64fe3b4eafd82bc5365512adbc156f5096a46d37" translate="yes" xml:space="preserve">
          <source>If set to true or &quot;refuse&quot;, git-receive-pack will deny a ref update to the currently checked out branch of a non-bare repository. Such a push is potentially dangerous because it brings the HEAD out of sync with the index and working tree. If set to &quot;warn&quot;, print a warning of such a push to stderr, but allow the push to proceed. If set to false or &quot;ignore&quot;, allow such pushes with no message. Defaults to &quot;refuse&quot;.</source>
          <target state="translated">true 또는 &quot;refuse&quot;로 설정하면 git-receive-pack은 현재 베어지지 않은 저장소의 체크 아웃 된 분기에 대한 참조 업데이트를 거부합니다. 이러한 푸시는 HEAD가 인덱스 및 작업 트리와 동기화되지 않기 때문에 잠재적으로 위험합니다. &quot;경고&quot;로 설정된 경우 stderr에 대한 푸시에 대한 경고를 인쇄하되 계속 진행하십시오. false 또는 &quot;무시&quot;로 설정된 경우 메시지없이 푸시를 허용하십시오. 기본값은 &quot;거부&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="d09a3b8e56d92fdf26b71ac7a66610897ebf56ec" translate="yes" xml:space="preserve">
          <source>If set to true, .git/shallow can be updated when new refs require new shallow roots. Otherwise those refs are rejected.</source>
          <target state="translated">true로 설정하면 새 참조에 새 얕은 루트가 필요할 때 .git / shallow를 업데이트 할 수 있습니다. 그렇지 않으면 해당 심판은 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="54bb951308d4910fbcee8b759c22be8fe1cad2d9" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; will display the number of entries currently stashed away. Defaults to false.</source>
          <target state="translated">true로 설정하면 &lt;a href=&quot;git-status&quot;&gt;git-status [1]에&lt;/a&gt; 현재 숨겨져있는 항목 수가 표시됩니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="3713c634b09bf65bc394c012cee94ba42c596b9c" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; will insert a comment prefix before each output line (starting with &lt;code&gt;core.commentChar&lt;/code&gt;, i.e. &lt;code&gt;#&lt;/code&gt; by default). This was the behavior of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; in Git 1.8.4 and previous. Defaults to false.</source>
          <target state="translated">true로 설정하면 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 은 각 출력 행 앞에 주석 접두사를 삽입합니다 ( &lt;code&gt;core.commentChar&lt;/code&gt; 로 시작 , 기본적으로 &lt;code&gt;#&lt;/code&gt; ). 이것은 Git 1.8.4 이하에서 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 의 동작이었습니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="9b89821396e7eac11e5ad2faf8d7540e7c67829b" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;code&gt;git rebase&lt;/code&gt; will use abbreviated command names in the todo list resulting in something like this:</source>
          <target state="translated">true로 설정하면 &lt;code&gt;git rebase&lt;/code&gt; 는 할일 목록에 축약 된 명령 이름을 사용하여 다음과 같은 결과를냅니다 :</target>
        </trans-unit>
        <trans-unit id="a871da2391e5e77cb10a7b13bd4e3a7269114ee0" translate="yes" xml:space="preserve">
          <source>If set to true, do not allow checkout of paths that would be considered equivalent to &lt;code&gt;.git&lt;/code&gt; on an HFS+ filesystem. Defaults to &lt;code&gt;true&lt;/code&gt; on Mac OS, and &lt;code&gt;false&lt;/code&gt; elsewhere.</source>
          <target state="translated">true로 설정되면 HFS + 파일 시스템 에서 &lt;code&gt;.git&lt;/code&gt; 과 동등한 경로를 체크 아웃하지 마십시오 . Mac OS에서는 기본값이 &lt;code&gt;true&lt;/code&gt; 이고 다른 곳에서는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0b91b7e4dfffb3891da9de8dba8ed2d19154ae38" translate="yes" xml:space="preserve">
          <source>If set to true, do not allow checkout of paths that would cause problems with the NTFS filesystem, e.g. conflict with 8.3 &quot;short&quot; names. Defaults to &lt;code&gt;true&lt;/code&gt; on Windows, and &lt;code&gt;false&lt;/code&gt; elsewhere.</source>
          <target state="translated">true로 설정된 경우 NTFS 파일 시스템에 문제를 일으킬 수있는 경로를 체크 아웃하지 마십시오 (예 : 8.3 &quot;짧은&quot;이름과의 충돌). Windows에서는 기본값이 &lt;code&gt;true&lt;/code&gt; 이고 다른 곳에서는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="54ccdbeca4965b6fc3cb17a6075d84092d7309ba" translate="yes" xml:space="preserve">
          <source>If set to true, enable &lt;code&gt;--extended-regexp&lt;/code&gt; option by default. This option is ignored when the &lt;code&gt;grep.patternType&lt;/code&gt; option is set to a value other than &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">true로 설정되면 기본적으로 &lt;code&gt;--extended-regexp&lt;/code&gt; 옵션을 활성화하십시오 . &lt;code&gt;grep.patternType&lt;/code&gt; 옵션이 &lt;code&gt;default&lt;/code&gt; 이외의 값으로 설정된 경우이 옵션은 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="30887a5524c263667737b125eed1b7397b4d3c85" translate="yes" xml:space="preserve">
          <source>If set to true, enable &lt;code&gt;--full-name&lt;/code&gt; option by default.</source>
          <target state="translated">true로 설정되면 기본적으로 &lt;code&gt;--full-name&lt;/code&gt; 옵션을 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="a770bd77a59ee1eda1723cd39df7104106a40a38" translate="yes" xml:space="preserve">
          <source>If set to true, enable &lt;code&gt;-n&lt;/code&gt; option by default.</source>
          <target state="translated">true로 설정되면 기본적으로 &lt;code&gt;-n&lt;/code&gt; 옵션을 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ae1bc4fce8b6029e6cbb4c5d0167ebeeaacf37d" translate="yes" xml:space="preserve">
          <source>If set to true, enable the &lt;code&gt;--column&lt;/code&gt; option by default.</source>
          <target state="translated">true로 설정되면 기본적으로 &lt;code&gt;--column&lt;/code&gt; 옵션을 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f2144fe2d27e9e20f68c9036ebab8459a790815" translate="yes" xml:space="preserve">
          <source>If set to true, fall back to git grep --no-index if git grep is executed outside of a git repository. Defaults to false.</source>
          <target state="translated">true로 설정되면 git grep이 git 저장소 외부에서 실행되면 git grep --no-index로 돌아갑니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="25ad8c4a959eb80b90f95ddbc01fcd1f2b16d26e" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will deny a ref update that deletes the currently checked out branch of a non-bare repository.</source>
          <target state="translated">true로 설정하면 git-receive-pack은 현재 베어지지 않은 저장소의 체크 아웃 된 분기를 삭제하는 참조 업데이트를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="f7f0fff426d74ea17456c56eae07f347498018a4" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will deny a ref update that deletes the ref. Use this to prevent such a ref deletion via a push.</source>
          <target state="translated">true로 설정하면 git-receive-pack은 심판을 삭제하는 심판 업데이트를 거부합니다. 푸시를 통한 이러한 참조 삭제를 방지하려면이를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bc6468d5687d1713aadc8dfe39af8a6b8a9b584c" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will deny a ref update which is not a fast-forward. Use this to prevent such an update via a push, even if that push is forced. This configuration variable is set when initializing a shared repository.</source>
          <target state="translated">true로 설정하면 git-receive-pack은 빨리 감기가 아닌 참조 업데이트를 거부합니다. 푸시를 강제로 실행하더라도 푸시를 통한 업데이트를 방지하려면이 옵션을 사용하십시오. 이 구성 변수는 공유 저장소를 초기화 할 때 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="aa5f05e34699c4bff5b25fced7ce1653e77528d2" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will run git-update-server-info after receiving data from git-push and updating refs.</source>
          <target state="translated">true로 설정하면 git-receive-pack은 git-push로부터 데이터를 수신하고 참조를 업데이트 한 후 git-update-server-info를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="875b965a1988574b490477056983b56357db9a5f" translate="yes" xml:space="preserve">
          <source>If set to true, makes &lt;code&gt;git repack&lt;/code&gt; act as if &lt;code&gt;--delta-islands&lt;/code&gt; was passed. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">true로 설정하면 &lt;code&gt;git repack&lt;/code&gt; 이 &lt;code&gt;--delta-islands&lt;/code&gt; 가 전달 된 것처럼 작동 합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3a3fff86e688774493783e955a40569a2b6cd00b" translate="yes" xml:space="preserve">
          <source>If set to true, makes &lt;code&gt;git repack&lt;/code&gt; act as if &lt;code&gt;--pack-kept-objects&lt;/code&gt; was passed. See &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; for details. Defaults to &lt;code&gt;false&lt;/code&gt; normally, but &lt;code&gt;true&lt;/code&gt; if a bitmap index is being written (either via &lt;code&gt;--write-bitmap-index&lt;/code&gt; or &lt;code&gt;repack.writeBitmaps&lt;/code&gt;).</source>
          <target state="translated">true로 설정하면 &lt;code&gt;git repack&lt;/code&gt; 이 마치 &lt;code&gt;--pack-kept-objects&lt;/code&gt; 가 전달 된 것처럼 작동 합니다. 자세한 내용은 &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt; 을 참조하십시오. 디폴트는 &lt;code&gt;false&lt;/code&gt; 일반적이지만 &lt;code&gt;true&lt;/code&gt; 비트 맵 인덱스 (경유로 기재되는 경우 &lt;code&gt;--write-bitmap-index&lt;/code&gt; 또는 &lt;code&gt;repack.writeBitmaps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f4685adbf82f5fe84483ac0a4116dbb7a4fa6307" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;git diff&lt;/code&gt; does not show any source or destination prefix.</source>
          <target state="translated">설정하면 &lt;code&gt;git diff&lt;/code&gt; 는 소스 또는 대상 접두사를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="407c23ddaf3ebfe9c20e0dd5ae2fc627eb8b4502" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;git diff&lt;/code&gt; uses a prefix pair that is different from the standard &quot;a/&quot; and &quot;b/&quot; depending on what is being compared. When this configuration is in effect, reverse diff output also swaps the order of the prefixes:</source>
          <target state="translated">설정되면 &lt;code&gt;git diff&lt;/code&gt; 는 비교 대상에 따라 표준 &quot;a /&quot;및 &quot;b /&quot;와 다른 접두사 쌍을 사용합니다. 이 구성이 적용되면 역방향 diff 출력도 접두사의 순서를 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="ce70dfc2b2921383247fcc52103661d4583ff009" translate="yes" xml:space="preserve">
          <source>If set, by default &quot;git config&quot; reads from both &quot;config&quot; and &quot;config.worktree&quot; file from GIT_DIR in that order. In multiple working directory mode, &quot;config&quot; file is shared while &quot;config.worktree&quot; is per-working directory (i.e., it&amp;rsquo;s in GIT_COMMON_DIR/worktrees/&amp;lt;id&amp;gt;/config.worktree)</source>
          <target state="translated">설정하면 기본적으로 &quot;git config&quot;는 GIT_DIR의 &quot;config&quot;및 &quot;config.worktree&quot;파일을 순서대로 읽습니다. 다중 작업 디렉토리 모드에서 &quot;config&quot;파일은 공유되고 &quot;config.worktree&quot;는 작업 별 디렉토리입니다 (즉, GIT_COMMON_DIR / worktrees / &amp;lt;id&amp;gt; /config.worktree에 있음)</target>
        </trans-unit>
        <trans-unit id="8558e4c58eead00c8757e7213c096b3a4293d44c" translate="yes" xml:space="preserve">
          <source>If set, clients will attempt to communicate with a server using the specified protocol version. If the server does not support it, communication falls back to version 0. If unset, the default is &lt;code&gt;2&lt;/code&gt;. Supported versions:</source>
          <target state="translated">설정된 경우 클라이언트는 지정된 프로토콜 버전을 사용하여 서버와 통신을 시도합니다. 서버가 지원하지 않으면 통신은 버전 0으로 돌아갑니다 . 설정되지 않은 경우 기본값은 &lt;code&gt;2&lt;/code&gt; 입니다. 지원되는 버전 :</target>
        </trans-unit>
        <trans-unit id="b176f794890668142b94887636cc924076126a16" translate="yes" xml:space="preserve">
          <source>If set, keywords at the start of the line are highlighted. The keywords are &quot;error&quot;, &quot;warning&quot;, &quot;hint&quot; and &quot;success&quot;, and are matched case-insensitively. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;). If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">설정하면 줄의 시작 부분에 키워드가 강조 표시됩니다. 키워드는 &quot;오류&quot;, &quot;경고&quot;, &quot;힌트&quot;및 &quot;성공&quot;이며 대소 문자를 구분하지 않습니다. &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; (또는 &lt;code&gt;never&lt;/code&gt; ) 또는 &lt;code&gt;auto&lt;/code&gt; (또는 &lt;code&gt;true&lt;/code&gt; ) 로 설정 될 수 있습니다 . 설정하지 않으면 &lt;code&gt;color.ui&lt;/code&gt; 의 값 이 사용됩니다 ( 기본적으로 &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b183dd8c0ffee365fe58a6a334a19fb15f9512f0" translate="yes" xml:space="preserve">
          <source>If set, prints debugging information about various reads/writes.</source>
          <target state="translated">설정된 경우 다양한 읽기 / 쓰기에 대한 디버깅 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b8c5d5bfb05b8eec245d869376183965da454ecd" translate="yes" xml:space="preserve">
          <source>If set, provide a user defined default policy for all protocols which don&amp;rsquo;t explicitly have a policy (&lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt;). By default, if unset, known-safe protocols (http, https, git, ssh, file) have a default policy of &lt;code&gt;always&lt;/code&gt;, known-dangerous protocols (ext) have a default policy of &lt;code&gt;never&lt;/code&gt;, and all other protocols have a default policy of &lt;code&gt;user&lt;/code&gt;. Supported policies:</source>
          <target state="translated">설정된 경우 명시 적으로 정책이없는 모든 프로토콜에 대해 사용자 정의 기본 정책을 제공하십시오 ( &lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt; ). 기본적으로 설정되지 않은 알려진 안전한 프로토콜 (http, https, git, ssh, file)의 기본 정책은 &lt;code&gt;always&lt;/code&gt; 이고 알려진 위험한 프로토콜 (ext)의 기본 정책은 &lt;code&gt;never&lt;/code&gt; 이며 다른 모든 프로토콜에는 기본 정책이 있습니다 의 &lt;code&gt;user&lt;/code&gt; . 지원되는 정책 :</target>
        </trans-unit>
        <trans-unit id="8d4a6e984ec5e0aad11e32a678cf60da360c5f1c" translate="yes" xml:space="preserve">
          <source>If set, specifies the outgoing SMTP server option to use. Default value can be specified by the &lt;code&gt;sendemail.smtpServerOption&lt;/code&gt; configuration option.</source>
          <target state="translated">설정된 경우 사용할 발신 SMTP 서버 옵션을 지정합니다. &lt;code&gt;sendemail.smtpServerOption&lt;/code&gt; 구성 옵션으로 기본값을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fab27431c274f5a81ff1327c3c271e3371074f0" translate="yes" xml:space="preserve">
          <source>If set, specifies the outgoing SMTP server to use (e.g. &lt;code&gt;smtp.example.com&lt;/code&gt; or a raw IP address). Alternatively it can specify a full pathname of a sendmail-like program instead; the program must support the &lt;code&gt;-i&lt;/code&gt; option. Default value can be specified by the &lt;code&gt;sendemail.smtpServer&lt;/code&gt; configuration option; the built-in default is to search for &lt;code&gt;sendmail&lt;/code&gt; in &lt;code&gt;/usr/sbin&lt;/code&gt;, &lt;code&gt;/usr/lib&lt;/code&gt; and $PATH if such program is available, falling back to &lt;code&gt;localhost&lt;/code&gt; otherwise.</source>
          <target state="translated">설정된 경우 사용할 발신 SMTP 서버 (예 : &lt;code&gt;smtp.example.com&lt;/code&gt; 또는 원시 IP 주소)를 지정합니다. 대신 sendmail 같은 프로그램의 전체 경로 이름을 지정할 수도 있습니다. 프로그램은 &lt;code&gt;-i&lt;/code&gt; 옵션을 지원해야합니다 . &lt;code&gt;sendemail.smtpServer&lt;/code&gt; 구성 옵션으로 기본값을 지정할 수 있습니다 . 내장 된 기본값은 &lt;code&gt;/usr/sbin&lt;/code&gt; , &lt;code&gt;/usr/lib&lt;/code&gt; 및 $ PATH 에서 &lt;code&gt;sendmail&lt;/code&gt; 을 검색하는 것입니다. 이러한 프로그램을 사용할 수있는 경우 &lt;code&gt;localhost&lt;/code&gt; 로 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="95132676994fa7152c54abc8928412e3414f6991" translate="yes" xml:space="preserve">
          <source>If set, store cookies received during requests to the file specified by http.cookieFile. Has no effect if http.cookieFile is unset.</source>
          <target state="translated">설정된 경우 요청 중에받은 쿠키를 http.cookieFile에 지정된 파일에 저장하십시오. http.cookieFile이 설정되어 있지 않으면 아무런 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9802dde85fc0323285bb8c0402ffcc333cf47ed2" translate="yes" xml:space="preserve">
          <source>If set, the value of this variable is used as a command which will identify all files that may have changed since the requested date/time. This information is used to speed up git by avoiding unnecessary processing of files that have not changed. See the &quot;fsmonitor-watchman&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">설정된 경우이 변수의 값은 요청 된 날짜 / 시간 이후에 변경되었을 수있는 모든 파일을 식별하는 명령으로 사용됩니다. 이 정보는 변경되지 않은 파일의 불필요한 처리를 피함으로써 자식 속도를 높이는 데 사용됩니다. &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 의 &quot;fsmonitor-watchman&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9612a7f8efdd3501a24381e7aae358082b8ef892" translate="yes" xml:space="preserve">
          <source>If some &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; arguments are also passed on the command line, when a &lt;code&gt;trailer.&amp;lt;token&amp;gt;.command&lt;/code&gt; is configured, the command will also be executed for each of these arguments. And the &amp;lt;value&amp;gt; part of these arguments, if any, will be used to replace the &lt;code&gt;$ARG&lt;/code&gt; string in the command.</source>
          <target state="translated">예를 들어 &lt;code&gt;trailer.&amp;lt;token&amp;gt;.command&lt;/code&gt; 가 구성 되면 일부 &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 인수가 명령 행에 전달되면 이러한 각 인수에 대해 명령이 실행됩니다. 그리고 이러한 인수의 &amp;lt;value&amp;gt; 부분은 명령에서 &lt;code&gt;$ARG&lt;/code&gt; 문자열 을 대체하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="00679e1f1be4cb3b83ae3531e0f65d104df1ba84" translate="yes" xml:space="preserve">
          <source>If some files could not be added because of errors indexing them, do not abort the operation, but continue adding the others. The command shall still exit with non-zero status. The configuration variable &lt;code&gt;add.ignoreErrors&lt;/code&gt; can be set to true to make this the default behaviour.</source>
          <target state="translated">인덱싱 오류로 인해 일부 파일을 추가 할 수없는 경우 작업을 중단하지 말고 다른 파일을 계속 추가하십시오. 명령은 여전히 ​​0이 아닌 상태로 종료됩니다. 구성 변수 &lt;code&gt;add.ignoreErrors&lt;/code&gt; 를 true로 설정하여이를 기본 동작으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02424da36361565abc928c3cd12899bb91686b1d" translate="yes" xml:space="preserve">
          <source>If some of the merge bases are skipped, then the bisection process continues, but the following message is printed for each skipped merge base:</source>
          <target state="translated">일부 병합 기준을 건너 뛰면 이분법 프로세스는 계속되지만 건너 뛴 각 병합 기준에 대해 다음 메시지가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="c23bec329e1ab3f8ab844a76b3b2aad8e4c54310" translate="yes" xml:space="preserve">
          <source>If somebody got a release tag from you, you cannot just change the tag for them by updating your own one. This is a big security issue, in that people MUST be able to trust their tag-names. If you really want to do the insane thing, you need to just fess up to it, and tell people that you messed up. You can do that by making a very public announcement saying:</source>
          <target state="translated">누군가 릴리스 태그를받은 경우 자신의 태그를 업데이트하여 태그를 변경할 수는 없습니다. 사람들이 태그 이름을 신뢰할 수 있어야한다는 점에서 이는 큰 보안 문제입니다. 당신이 정말로 미쳤던 일을하고 싶다면, 당신은 그것을 속이고, 사람들에게 당신이 엉망이라고 말하면됩니다. 다음과 같이 매우 대중적인 발표를함으로써 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c1822b09998ebb74d19f39d240afd93e64789bf" translate="yes" xml:space="preserve">
          <source>If someone else administers the server, they should tell you what directory to put the repository in, and what &lt;code&gt;git://&lt;/code&gt; URL it will appear at. You can then skip to the section &quot;&lt;a href=&quot;#pushing-changes-to-a-public-repository&quot;&gt;Pushing changes to a public repository&lt;/a&gt;&quot;, below.</source>
          <target state="translated">다른 사람이 서버를 관리하는 경우 리포지토리를 넣을 디렉토리와 표시 할 &lt;code&gt;git://&lt;/code&gt; URL을 알려 주어야합니다 . 그런 다음 아래 &quot; &lt;a href=&quot;#pushing-changes-to-a-public-repository&quot;&gt;공개 리포지토리에 변경 내용 푸시&lt;/a&gt; &quot;섹션으로 건너 뛸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4199717fddcec6935af08019e365f779fa359364" translate="yes" xml:space="preserve">
          <source>If specified twice, show in addition the unified diff between what would be committed and the worktree files, i.e. the unstaged changes to tracked files.</source>
          <target state="translated">두 번 지정하면 커밋 된 파일과 작업 트리 파일 사이의 통합 된 차이 (예 : 추적 된 파일에 대한 단계적 변경 사항)를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="fcf7bcff6fb66a8267ebcd9b00a7e09f8cfe6596" translate="yes" xml:space="preserve">
          <source>If that version is broken, type</source>
          <target state="translated">해당 버전이 손상된 경우 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="c26c727c738ef7a0a9fa459f5d8c7e2c7478ba23" translate="yes" xml:space="preserve">
          <source>If the &quot;pattern&quot; URL does include a path component, then this too must match exactly: the context &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; will match a config entry for &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; (in addition to matching the config entry for &lt;code&gt;https://example.com&lt;/code&gt;) but will not match a config entry for &lt;code&gt;https://example.com/bar&lt;/code&gt;.</source>
          <target state="translated">은 &quot;패턴&quot;URL이 경로 구성 요소가 포함되어 있지 않습니다 경우,이 역시 정확히 일치해야합니다 : 문맥 &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; 을 위한 config 항목과 일치합니다 &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; (대한 설정 항목 일치 이외에 &lt;code&gt;https://example.com&lt;/code&gt; 을 하지만위한 config 항목과 일치하지 않습니다) &lt;code&gt;https://example.com/bar&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="c4d8f312459b1b390b1c7f9b1bd219e73052861c" translate="yes" xml:space="preserve">
          <source>If the &amp;lt;value&amp;gt; part of any trailer contains only whitespace, the whole trailer will be removed from the resulting message. This applies to existing trailers as well as new trailers.</source>
          <target state="translated">예고편의 &amp;lt;value&amp;gt; 부분에 공백 만 포함 된 경우 결과 메시지에서 전체 예고편이 제거됩니다. 이는 새로운 예고편뿐만 아니라 기존 예고편에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b64722d374d9ba94f59d4b75e0b20b3d04a38c9e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$GIT_DIR&lt;/code&gt; environment variable is set then it specifies a path to use instead of &lt;code&gt;./.git&lt;/code&gt; for the base of the repository.</source>
          <target state="translated">는 IF &lt;code&gt;$GIT_DIR&lt;/code&gt; 환경 변수가 설정되어 대신으로 사용할 수있는 경로를 지정 &lt;code&gt;./.git&lt;/code&gt; 저장소의 기지를.</target>
        </trans-unit>
        <trans-unit id="010f47d5eb5a20440d8f9779a052d1045e200486" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--anonymize&lt;/code&gt; option is given, git will attempt to remove all identifying information from the repository while still retaining enough of the original tree and history patterns to reproduce some bugs. The goal is that a git bug which is found on a private repository will persist in the anonymized repository, and the latter can be shared with git developers to help solve the bug.</source>
          <target state="translated">경우 &lt;code&gt;--anonymize&lt;/code&gt; 옵션이 주어, 자식은 여전히 몇 가지 버그를 재현하기 위해 원래의 나무와 역사 패턴을 충분히 유지하면서 저장소에서 모든 식별 정보를 제거하려고 시도합니다. 개인 저장소에서 발견되는 git 버그는 익명화 된 저장소에서 유지되며 버그 버그를 해결하기 위해 자식 개발자와 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4c6f80eebbd991a705883e3a7ddf7805d5a2ad9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--autosquash&lt;/code&gt; option is enabled by default using the configuration variable &lt;code&gt;rebase.autoSquash&lt;/code&gt;, this option can be used to override and disable this setting.</source>
          <target state="translated">경우 &lt;code&gt;--autosquash&lt;/code&gt; 옵션 구성 변수 사용 기본적으로 활성화되어 &lt;code&gt;rebase.autoSquash&lt;/code&gt; 을 ,이 옵션이 설정을 무시하고 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cf1db99e3ec777fa9fc759a96b9df8702668643" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--done&lt;/code&gt; command-line option or &lt;code&gt;feature done&lt;/code&gt; command is in use, the &lt;code&gt;done&lt;/code&gt; command is mandatory and marks the end of the stream.</source>
          <target state="translated">는 IF &lt;code&gt;--done&lt;/code&gt; 명령 줄 옵션 또는 &lt;code&gt;feature done&lt;/code&gt; 명령이 사용되면, &lt;code&gt;done&lt;/code&gt; 명령은 필수이며 표시 스트림의 끝을.</target>
        </trans-unit>
        <trans-unit id="a0c52682314428d0b2cfaeb79c7cb6ca41bbd107" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--include-untracked&lt;/code&gt; option is used, all untracked files are also stashed and then cleaned up with &lt;code&gt;git clean&lt;/code&gt;, leaving the working directory in a very clean state. If the &lt;code&gt;--all&lt;/code&gt; option is used instead then the ignored files are stashed and cleaned in addition to the untracked files.</source>
          <target state="translated">는 IF &lt;code&gt;--include-untracked&lt;/code&gt; 옵션을 사용, 모든 비 추적 파일은 은닉 된 후 함께 청소 &lt;code&gt;git clean&lt;/code&gt; 매우 깨끗한 상태로 작업 디렉토리를 떠나. 는 IF &lt;code&gt;--all&lt;/code&gt; 옵션은 다음 대신 사용되는 무시 파일을 은닉 및 비 추적 파일 외에도 세정합니다.</target>
        </trans-unit>
        <trans-unit id="bbfa929c9630d94c6f050152effe58514108dc44" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--index&lt;/code&gt; option is used, then tries to reinstate not only the working tree&amp;rsquo;s changes, but also the index&amp;rsquo;s ones. However, this can fail, when you have conflicts (which are stored in the index, where you therefore can no longer apply the changes as they were originally).</source>
          <target state="translated">경우 &lt;code&gt;--index&lt;/code&gt; 옵션을 사용하고 작업 트리의 변경뿐만 아니라 인덱스의 사람뿐만 아니라 복원을 시도합니다. 그러나 충돌이있는 경우 (인덱스에 저장되어 원래 변경 사항을 더 이상 적용 할 수없는 경우) 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3433648ddba23324bfe890535ea8fba49406cc9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--keep-index&lt;/code&gt; option is used, all changes already added to the index are left intact.</source>
          <target state="translated">는 IF &lt;code&gt;--keep-index&lt;/code&gt; 옵션을 사용, 이미 인덱스에 추가 된 모든 변경 내용은 그대로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0b71e8c338c336264145f9c00a25064d3a5d745" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--multiple&lt;/code&gt; option was specified, the different remotes will be fetched in parallel. If multiple submodules are fetched, they will be fetched in parallel. To control them independently, use the config settings &lt;code&gt;fetch.parallel&lt;/code&gt; and &lt;code&gt;submodule.fetchJobs&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;code&gt;--multiple&lt;/code&gt; 옵션을 지정하고, 다른 리모트는 병렬로 가져온 것입니다. 여러 개의 서브 모듈이 페치되면 병렬로 페치됩니다. 독립적으로 제어하려면 구성 설정 &lt;code&gt;fetch.parallel&lt;/code&gt; 및 &lt;code&gt;submodule.fetchJobs&lt;/code&gt; 를 사용 하십시오 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="86926b76e3db734e6c786d5fed43f678b858b280" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;DISPLAY&lt;/code&gt; environment variable is not set, &lt;code&gt;git log&lt;/code&gt; is used instead. You can also give command-line options such as &lt;code&gt;-p&lt;/code&gt; and &lt;code&gt;--stat&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DISPLAY&lt;/code&gt; 환경 변수가 설정되지 않은 경우 대신 &lt;code&gt;git log&lt;/code&gt; 가 사용됩니다. &lt;code&gt;-p&lt;/code&gt; 및 &lt;code&gt;--stat&lt;/code&gt; 와 같은 명령 줄 옵션을 제공 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d759f2e991e02f3a71fd36511a7699e5f49db70c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GIT_ASKPASS&lt;/code&gt; environment variable is set, the program specified by the variable is invoked. A suitable prompt is provided to the program on the command line, and the user&amp;rsquo;s input is read from its standard output.</source>
          <target state="translated">는 IF &lt;code&gt;GIT_ASKPASS&lt;/code&gt; 의 환경 변수가 설정되어 변수에 의해 지정된 프로그램이 호출됩니다. 명령 행에서 프로그램에 적합한 프롬프트가 제공되며 사용자 입력은 표준 출력에서 ​​읽습니다.</target>
        </trans-unit>
        <trans-unit id="4b682e3beccdc952b131cf46cc2adb457e7b0390" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GIT_DIR&lt;/code&gt; environment variable is set then it specifies a path to use instead of the default &lt;code&gt;.git&lt;/code&gt; for the base of the repository. The &lt;code&gt;--git-dir&lt;/code&gt; command-line option also sets this value.</source>
          <target state="translated">는 IF &lt;code&gt;GIT_DIR&lt;/code&gt; 의 환경 변수가 설정되어 그것은 기본 대신 사용하는 경로를 지정 &lt;code&gt;.git&lt;/code&gt; 저장소의 기지를. &lt;code&gt;--git-dir&lt;/code&gt; 명령 줄 옵션은이 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="643cae995a607334b36d06d83fbe3fb662a8bb45" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;done&lt;/code&gt; feature is not in use, treated as if EOF was read. This can be used to tell fast-import to finish early.</source>
          <target state="translated">는 IF &lt;code&gt;done&lt;/code&gt; 기능을 사용하지 않을 EOF 읽고 된 것처럼, 처리 하였다. 빠른 가져 오기로 일찍 완료하도록 지시하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18aa9d79f5a644e72e69f66c98e1e834c977b6b0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;filter&lt;/code&gt; feature is advertised, the following argument can be included in the client&amp;rsquo;s request:</source>
          <target state="translated">는 IF &lt;code&gt;filter&lt;/code&gt; 기능을 광고하고, 다음 인수는 클라이언트의 요청에 포함 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="338c6269ff70e3588bd2606af346bee907c22325" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;git credential&lt;/code&gt; knew about the password, this step may not have involved the user actually typing this password (the user may have typed a password to unlock the keychain instead, or no user interaction was done if the keychain was already unlocked) before it returned &lt;code&gt;password=secr3t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git credential&lt;/code&gt; 이 암호에 대해 알고 있다면 이 단계는 사용자가 실제로이 암호를 입력하는 것과 관련이 없을 수 있습니다 (사용자는 대신 암호를 입력하여 키 체인을 잠금 해제하거나 키 체인이 이미 잠금 해제 된 경우 사용자 상호 작용이 수행되지 않았을 수 있음) &lt;code&gt;password=secr3t&lt;/code&gt; 를 리턴 했습니다 .</target>
        </trans-unit>
        <trans-unit id="042e7419aeefb97aea8089e7aef725093dfeada4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;packfile-uris&lt;/code&gt; feature is advertised, the following argument can be included in the client&amp;rsquo;s request as well as the potential addition of the &lt;code&gt;packfile-uris&lt;/code&gt; section in the server&amp;rsquo;s response as explained below.</source>
          <target state="translated">는 IF &lt;code&gt;packfile-uris&lt;/code&gt; 기능이 광고되고, 다음 인수는 클라이언트의 요청뿐만 아니라 잠재적 추가로 포함 할 수있다 &lt;code&gt;packfile-uris&lt;/code&gt; 아래에 설명 된대로 서버의 응답 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1e7bad5825e1ca0d0f2641273cfd194a2b47fe7f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ref-in-want&lt;/code&gt; feature is advertised, the following argument can be included in the client&amp;rsquo;s request as well as the potential addition of the &lt;code&gt;wanted-refs&lt;/code&gt; section in the server&amp;rsquo;s response as explained below.</source>
          <target state="translated">는 IF &lt;code&gt;ref-in-want&lt;/code&gt; 기능을 광고하고, 다음 인수는 클라이언트의 요청뿐만 아니라 잠재적 추가로 포함 할 수 있습니다 &lt;code&gt;wanted-refs&lt;/code&gt; 아래에 설명 된대로 서버의 응답 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8ee9fffd993cfbf2d4a66bab484646e0aab5c31d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shallow&lt;/code&gt; feature is advertised the following arguments can be included in the clients request as well as the potential addition of the &lt;code&gt;shallow-info&lt;/code&gt; section in the server&amp;rsquo;s response as explained below.</source>
          <target state="translated">는 IF &lt;code&gt;shallow&lt;/code&gt; 기능은 클라이언트가의 잠재력 또한뿐만 아니라 요청에 다음 인수가 포함될 수 있습니다 보급 &lt;code&gt;shallow-info&lt;/code&gt; 아래에 설명 된대로 서버의 응답 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cc56c6c35649e4cbd1848d389261cbadfd34e234" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sideband-all&lt;/code&gt; feature is advertised, the following argument can be included in the client&amp;rsquo;s request:</source>
          <target state="translated">는 IF &lt;code&gt;sideband-all&lt;/code&gt; 기능을 광고하고, 다음 인수는 클라이언트의 요청에 포함 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5221b8fce1b302181f6152b9a7b516c793a8424a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;text&lt;/code&gt; attribute is unspecified, Git uses the &lt;code&gt;core.autocrlf&lt;/code&gt; configuration variable to determine if the file should be converted.</source>
          <target state="translated">경우 &lt;code&gt;text&lt;/code&gt; 속성이 지정되지 않은, 힘내는 사용 &lt;code&gt;core.autocrlf&lt;/code&gt; 파일을 변환해야하는지 결정하기 위해 구성 변수를.</target>
        </trans-unit>
        <trans-unit id="501d792e8a9528e67beb280aae4c4f6b3a3116f1" translate="yes" xml:space="preserve">
          <source>If the Git configuration variable clean.requireForce is not set to false, &lt;code&gt;git clean&lt;/code&gt; will refuse to delete files or directories unless given -f or -i. Git will refuse to modify untracked nested git repositories (directories with a .git subdirectory) unless a second -f is given.</source>
          <target state="translated">Git 구성 변수 clean.requireForce가 false로 설정되지 않은 경우, &lt;code&gt;git clean&lt;/code&gt; 은 -f 또는 -i를 지정하지 않으면 파일 또는 디렉토리 삭제를 거부합니다. Git은 두 번째 -f를 지정하지 않으면 추적되지 않은 중첩 된 git 저장소 (.git 서브 디렉토리가있는 디렉토리)를 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a08af52d1bb96063df69a1ba9c6458415ca2e42" translate="yes" xml:space="preserve">
          <source>If the HTTP transfer speed is less than &lt;code&gt;http.lowSpeedLimit&lt;/code&gt; for longer than &lt;code&gt;http.lowSpeedTime&lt;/code&gt; seconds, the transfer is aborted. Can be overridden by the &lt;code&gt;GIT_HTTP_LOW_SPEED_LIMIT&lt;/code&gt; and &lt;code&gt;GIT_HTTP_LOW_SPEED_TIME&lt;/code&gt; environment variables.</source>
          <target state="translated">는 HTTP 전송 속도가보다 작은 경우 &lt;code&gt;http.lowSpeedLimit&lt;/code&gt; 보다 오래 &lt;code&gt;http.lowSpeedTime&lt;/code&gt; 초, 전송이 중단됩니다. &lt;code&gt;GIT_HTTP_LOW_SPEED_LIMIT&lt;/code&gt; 및 &lt;code&gt;GIT_HTTP_LOW_SPEED_TIME&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c44d5cf7886c82987c35de787d30a82008f591b" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;approve&lt;/code&gt; or &lt;code&gt;reject&lt;/code&gt;, no output should be emitted.</source>
          <target state="translated">조치가 &lt;code&gt;approve&lt;/code&gt; 또는 &lt;code&gt;reject&lt;/code&gt; 인 경우 출력이 생성되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a7a299c18f6719e8e8b963c0bc834abd5de39626" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;approve&lt;/code&gt;, git-credential will send the description to any configured credential helpers, which may store the credential for later use.</source>
          <target state="translated">조치가 &lt;code&gt;approve&lt;/code&gt; 되면 git-credential은 설명을 구성된 자격 증명 헬퍼에게 보내면 나중에 사용할 수 있도록 자격 증명을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fc4d66ebd944d4cf73c3d3a8712c0dec288c62f" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;fill&lt;/code&gt;, git-credential will attempt to add &quot;username&quot; and &quot;password&quot; attributes to the description by reading config files, by contacting any configured credential helpers, or by prompting the user. The username and password attributes of the credential description are then printed to stdout together with the attributes already provided.</source>
          <target state="translated">작업이 &lt;code&gt;fill&lt;/code&gt; 인 경우 git-credential은 구성 파일을 읽거나 구성된 자격 증명 도우미에 연락하거나 사용자에게 프롬프트하여 설명에 &quot;username&quot;및 &quot;password&quot;특성을 추가하려고 시도합니다. 그런 다음 신임 정보의 사용자 이름 및 비밀번호 속성은 이미 제공된 속성과 함께 stdout으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="194451718843bfcaf463de902599c24ff69e0de0" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;reject&lt;/code&gt;, git-credential will send the description to any configured credential helpers, which may erase any stored credential matching the description.</source>
          <target state="translated">작업이 &lt;code&gt;reject&lt;/code&gt; 경우 git-credential은 설명을 구성된 자격 증명 헬퍼에게 보내면 설명과 일치하는 저장된 자격 증명이 지워질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8fc44b68b56d1ac1b923c6197e4ad961f9ec579" translate="yes" xml:space="preserve">
          <source>If the alias expansion is prefixed with an exclamation point, it will be treated as a shell command. For example, defining &lt;code&gt;alias.new = !gitk --all --not ORIG_HEAD&lt;/code&gt;, the invocation &lt;code&gt;git new&lt;/code&gt; is equivalent to running the shell command &lt;code&gt;gitk --all --not ORIG_HEAD&lt;/code&gt;. Note that shell commands will be executed from the top-level directory of a repository, which may not necessarily be the current directory. &lt;code&gt;GIT_PREFIX&lt;/code&gt; is set as returned by running &lt;code&gt;git rev-parse --show-prefix&lt;/code&gt; from the original current directory. See &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;.</source>
          <target state="translated">별명 확장 앞에 느낌표가 있으면 쉘 명령으로 취급됩니다. 예를 들어 &lt;code&gt;alias.new = !gitk --all --not ORIG_HEAD&lt;/code&gt; 정의 하면 &lt;code&gt;git new&lt;/code&gt; 호출 은 쉘 명령 &lt;code&gt;gitk --all --not ORIG_HEAD&lt;/code&gt; 를 실행하는 것과 같습니다 . 쉘 명령은 저장소의 최상위 디렉토리에서 실행되며, 반드시 현재 디렉토리 일 필요는 없습니다. &lt;code&gt;GIT_PREFIX&lt;/code&gt; 는 원래 현재 디렉토리에서 &lt;code&gt;git rev-parse --show-prefix&lt;/code&gt; 를 실행하여 반환 된 것으로 설정됩니다 . &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="81bb3cca543b16e19f5e2adb35c917e85fde2f7d" translate="yes" xml:space="preserve">
          <source>If the amount of memory estimated for &lt;code&gt;git repack&lt;/code&gt; to run smoothly is not available and &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; is not set, the largest pack will also be excluded (this is the equivalent of running &lt;code&gt;git gc&lt;/code&gt; with &lt;code&gt;--keep-base-pack&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;git repack&lt;/code&gt; 이 원활하게 실행 되는 것으로 추정되는 메모리 양을 사용할 수없고 &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; 가 설정되지 않은 경우 가장 큰 팩도 제외됩니다 (이것은 --git-c &lt;code&gt;--keep-base-pack&lt;/code&gt; &lt;code&gt;git gc&lt;/code&gt; 를 실행하는 것과 같습니다 ).</target>
        </trans-unit>
        <trans-unit id="28ae5c748411e761b0bfb160798c17e5330bf010" translate="yes" xml:space="preserve">
          <source>If the anonymized repository shows the bug, it may be worth sharing &lt;code&gt;anon-stream&lt;/code&gt; along with a regular bug report. Note that the anonymized stream compresses very well, so gzipping it is encouraged. If you want to examine the stream to see that it does not contain any private data, you can peruse it directly before sending. You may also want to try:</source>
          <target state="translated">익명화 된 저장소에 버그가 표시되면 일반 버그 보고서와 함께 &lt;code&gt;anon-stream&lt;/code&gt; 을 공유 할 가치가 있습니다 . 익명화 된 스트림은 매우 잘 압축되므로 gzipping하는 것이 좋습니다. 스트림에 개인 데이터가 포함되어 있지 않은지 확인하려면 전송하기 전에 스트림을 직접 살펴보십시오. 시도해 볼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="723ec66f7929012c8a6ac732a23c4db7a105b505" translate="yes" xml:space="preserve">
          <source>If the attribute &lt;code&gt;export-subst&lt;/code&gt; is set for a file then Git will expand several placeholders when adding this file to an archive. The expansion depends on the availability of a commit ID, i.e., if &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt; has been given a tree instead of a commit or a tag then no replacement will be done. The placeholders are the same as those for the option &lt;code&gt;--pretty=format:&lt;/code&gt; of &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, except that they need to be wrapped like this: &lt;code&gt;$Format:PLACEHOLDERS$&lt;/code&gt; in the file. E.g. the string &lt;code&gt;$Format:%H$&lt;/code&gt; will be replaced by the commit hash.</source>
          <target state="translated">&lt;code&gt;export-subst&lt;/code&gt; 속성 이 파일에 설정되어 있으면 Git은이 파일을 아카이브에 추가 할 때 여러 자리 표시자를 확장합니다. 확약은 확약 ID의 가용성에 따라 다릅니다. 즉, &lt;a href=&quot;git-archive&quot;&gt;git-archive [1]&lt;/a&gt; 에 확약 또는 태그 대신 트리가 제공된 경우 교체가 수행되지 않습니다. 플레이스 홀더는 &lt;code&gt;--pretty=format:&lt;/code&gt; of &lt;a href=&quot;git-log&quot;&gt;git-log [1] 옵션&lt;/a&gt; 과 동일하지만 파일에서 &lt;code&gt;$Format:PLACEHOLDERS$&lt;/code&gt; 와 같이 랩핑되어야한다는 점만 다릅니다 . 예를 들어 &lt;code&gt;$Format:%H$&lt;/code&gt; 문자열 은 커밋 해시로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="bd056a8735e1abbf79ce6a360a1a80c3f28cbbd6" translate="yes" xml:space="preserve">
          <source>If the attribute export-subst is set for a file then Git will expand several placeholders when adding this file to an archive. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">export-subst 속성이 파일에 설정되어 있으면 Git은이 파일을 아카이브에 추가 할 때 여러 자리 표시자를 확장합니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="da80064c2ffb4013d75c1676828faa86849266b6" translate="yes" xml:space="preserve">
          <source>If the bisection process is driven manually, you can use &quot;git bisect skip&quot; to do the same thing. (In fact the special exit code 125 makes &quot;git bisect run&quot; use &quot;git bisect skip&quot; in the background.)</source>
          <target state="translated">이분법 프로세스가 수동으로 구동되는 경우 &quot;git bisect skip&quot;을 사용하여 동일한 작업을 수행 할 수 있습니다. 실제로 특수 종료 코드 125는 &quot;git bisect run&quot;을 백그라운드에서 &quot;git bisect skip&quot;으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="92ad120c671c36b884538f372611cf38d29a6827" translate="yes" xml:space="preserve">
          <source>If the branch exists in multiple remotes and one of them is named by the &lt;code&gt;checkout.defaultRemote&lt;/code&gt; configuration variable, we&amp;rsquo;ll use that one for the purposes of disambiguation, even if the &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; isn&amp;rsquo;t unique across all remotes. Set it to e.g. &lt;code&gt;checkout.defaultRemote=origin&lt;/code&gt; to always checkout remote branches from there if &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is ambiguous but exists on the &lt;code&gt;origin&lt;/code&gt; remote. See also &lt;code&gt;checkout.defaultRemote&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">브랜치가 여러 리모트에 존재하고 그 중 하나가 &lt;code&gt;checkout.defaultRemote&lt;/code&gt; 구성 변수에 의해 이름이 지정된 경우, &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 가 모든 리모트에서 고유하지 않더라도 명확성을 목적으로 그 브랜치 를 사용합니다. &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 가 모호하지만 &lt;code&gt;origin&lt;/code&gt; 원격 에 존재하는 경우 항상 원격 지점을 체크 아웃하려면 &lt;code&gt;checkout.defaultRemote=origin&lt;/code&gt; 으로 설정하십시오 . 참조 &lt;code&gt;checkout.defaultRemote&lt;/code&gt; 는 에서 &lt;a href=&quot;git-config&quot;&gt;자식-설정 [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c39c5c03f65f2a5b7cc29c6c30fb330e225795da" translate="yes" xml:space="preserve">
          <source>If the changes are independent enough, Git will automatically complete the merge and commit the result (or reuse an existing commit in case of &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt;, see below). On the other hand, if there are conflicts&amp;mdash;​for example, if the same file is modified in two different ways in the remote branch and the local branch&amp;mdash;​then you are warned; the output may look something like this:</source>
          <target state="translated">변경 사항이 충분히 독립적이라면 Git은 자동으로 병합을 완료하고 결과를 커밋합니다 (또는 &lt;a href=&quot;#fast-forwards&quot;&gt;빨리 감기의&lt;/a&gt; 경우 기존 커밋을 재사용 하십시오 (아래 참조)). 반면에 원격 지점과 로컬 지점에서 동일한 파일이 서로 다른 두 가지 방식으로 수정 된 경우와 같이 충돌이있는 경우 경고가 표시됩니다. 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="288f48e57898c3a0706dea1db36d760600650737" translate="yes" xml:space="preserve">
          <source>If the changes don&amp;rsquo;t conflict, you&amp;rsquo;re done. If there are conflicts, markers will be left in the problematic files showing the conflict;</source>
          <target state="translated">변경 사항이 충돌하지 않으면 완료된 것입니다. 충돌이 발생하면 문제가있는 파일에 충돌이 있음을 나타내는 마커가 남습니다.</target>
        </trans-unit>
        <trans-unit id="0c9dca535f00f8f010f3f51cbdf5a64ba071ad26" translate="yes" xml:space="preserve">
          <source>If the checkout is done via rebase, local submodule commits are rebased as well.</source>
          <target state="translated">체크 아웃이 리베이스를 통해 수행되면 로컬 서브 모듈 커밋도 리베이스됩니다.</target>
        </trans-unit>
        <trans-unit id="da1ce847fd50c0ebce51907161b2297389c68a97" translate="yes" xml:space="preserve">
          <source>If the command contains the &lt;code&gt;$ARG&lt;/code&gt; string, this string will be replaced with the &amp;lt;value&amp;gt; part of an existing trailer with the same &amp;lt;token&amp;gt;, if any, before the command is launched.</source>
          <target state="translated">명령에 &lt;code&gt;$ARG&lt;/code&gt; 문자열이 포함 된 경우이 문자열은 명령이 시작되기 전에 동일한 &amp;lt;토큰&amp;gt;이있는 기존 트레일러의 &amp;lt;값&amp;gt; 부분으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="d68b3a0db25981cb416126191f5f7a8b40a5795b" translate="yes" xml:space="preserve">
          <source>If the commit is a merge commit, you must tell &lt;code&gt;git cvsexportcommit&lt;/code&gt; what parent the changeset should be done against.</source>
          <target state="translated">커밋이 병합 커밋 인 경우 &lt;code&gt;git cvsexportcommit&lt;/code&gt; 에게 변경 세트를 수행해야하는 상위 항목을 알려 주어야합니다.</target>
        </trans-unit>
        <trans-unit id="50eff6c32d5b1376396b813f799767464152ed15" translate="yes" xml:space="preserve">
          <source>If the commit is a merge, and if the pretty-format is not &lt;code&gt;oneline&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt; or &lt;code&gt;raw&lt;/code&gt;, an additional line is inserted before the &lt;code&gt;Author:&lt;/code&gt; line. This line begins with &quot;Merge: &quot; and the hashes of ancestral commits are printed, separated by spaces. Note that the listed commits may not necessarily be the list of the &lt;strong&gt;direct&lt;/strong&gt; parent commits if you have limited your view of history: for example, if you are only interested in changes related to a certain directory or file.</source>
          <target state="translated">커밋이 병합이고 pretty-format이 &lt;code&gt;oneline&lt;/code&gt; , &lt;code&gt;email&lt;/code&gt; 또는 &lt;code&gt;raw&lt;/code&gt; 가 아닌 경우 &lt;code&gt;Author:&lt;/code&gt; 행 앞에 추가 행이 삽입 됩니다. 이 줄은 &quot;Merge :&quot;로 시작하고 조상의 커밋 해시는 공백으로 구분되어 인쇄됩니다. 히스토리보기를 제한 한 경우 (예 : 특정 디렉토리 또는 파일과 관련된 변경에만 관심이있는 경우) 나열된 확약이 &lt;strong&gt;직접&lt;/strong&gt; 상위 확약 목록 일 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fb562926c30c7dcdbad03cee2dab579f6b030079" translate="yes" xml:space="preserve">
          <source>If the commit is done directly by using &lt;code&gt;git&lt;/code&gt; (as opposed to using &lt;code&gt;git-cvsserver&lt;/code&gt;) the update will need to happen on the next repository access by &lt;code&gt;git-cvsserver&lt;/code&gt;, independent of access method and requested operation.</source>
          <target state="translated">커밋이 &lt;code&gt;git&lt;/code&gt; 를 사용하여 직접 수행되는 경우 ( &lt;code&gt;git-cvsserver&lt;/code&gt; 사용하는 것과 달리 ) 액세스 방법 및 요청 된 작업에 관계 &lt;code&gt;git-cvsserver&lt;/code&gt; 의한 다음 저장소 액세스에서 업데이트가 발생해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f829bbddf6f6f452756492321328ac75e498d9d9" translate="yes" xml:space="preserve">
          <source>If the config option &lt;code&gt;uploadArchive.allowUnreachable&lt;/code&gt; is true, these rules are ignored, and clients may use arbitrary sha1 expressions. This is useful if you do not care about the privacy of unreachable objects, or if your object database is already publicly available for access via non-smart-http.</source>
          <target state="translated">구성 옵션 &lt;code&gt;uploadArchive.allowUnreachable&lt;/code&gt; 이 true 인 경우이 규칙은 무시되며 클라이언트는 임의의 sha1 표현식을 사용할 수 있습니다. 도달 할 수없는 객체의 프라이버시를 신경 쓰지 않거나 스마트 이외의 http를 통해 액세스 할 수있는 객체 데이터베이스가 이미있는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a1bf5bff98f507f37d5394622406355fb10d8518" translate="yes" xml:space="preserve">
          <source>If the config variable &lt;code&gt;status.relativePaths&lt;/code&gt; is set to false, then all paths shown are relative to the repository root, not to the current directory.</source>
          <target state="translated">구성 변수 &lt;code&gt;status.relativePaths&lt;/code&gt; 가 false로 설정되면 표시된 모든 경로는 현재 디렉토리가 아닌 저장소 루트를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="15abc3d7884a27f6ef940ec31e7ff01ecc03f9f0" translate="yes" xml:space="preserve">
          <source>If the configuration variable &lt;code&gt;instaweb.browser&lt;/code&gt; is not set, &lt;code&gt;web.browser&lt;/code&gt; will be used instead if it is defined. See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt; for more information about this.</source>
          <target state="translated">구성 변수 &lt;code&gt;instaweb.browser&lt;/code&gt; 가 설정되지 않은 경우 &lt;code&gt;web.browser&lt;/code&gt; 가 정의 된 경우 대신 사용됩니다. 이에 대한 자세한 내용은 &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse [1]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cd3ff15aa0e04d429d03e9f6131934c58fa371f6" translate="yes" xml:space="preserve">
          <source>If the configuration variable &lt;code&gt;instaweb.browser&lt;/code&gt; is not set, &lt;code&gt;web.browser&lt;/code&gt; will be used instead if it is defined. See git-web{litdd}browse[1] for more information about this.</source>
          <target state="translated">&lt;code&gt;instaweb.browser&lt;/code&gt; 구성 변수 가 설정되어 있지 않으면 &lt;code&gt;web.browser&lt;/code&gt; 가 대신 정의되어 사용됩니다. 이에 대한 자세한 내용은 git-web {litdd} browse [1]를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="63b229ee2ee5c7c387585f3ec858739b37c09980" translate="yes" xml:space="preserve">
          <source>If the current HEAD is the same as the parent of the cherry-pick&amp;rsquo;ed commit, then a fast forward to this commit will be performed.</source>
          <target state="translated">현재 HEAD가 cherry-pick의 커밋의 부모와 동일하면이 커밋으로 빨리 감기가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7ca0a51612928d164dbfccc37787084c17e98850" translate="yes" xml:space="preserve">
          <source>If the custom merge tool correctly indicates the success of a merge resolution with its exit code, then the configuration variable &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.trustExitCode&lt;/code&gt; can be set to &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;git mergetool&lt;/code&gt; will prompt the user to indicate the success of the resolution after the custom tool has exited.</source>
          <target state="translated">사용자 정의 병합 도구가 종료 코드로 병합 분석의 성공을 올바르게 표시하면 구성 변수 &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.trustExitCode&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정할 수 있습니다 . 그렇지 않으면 &lt;code&gt;git mergetool&lt;/code&gt; 은 사용자 정의 도구가 종료 된 후 사용자에게 해결 성공을 표시하라는 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="36390d22499feba94308c3d2a6c08dfbe3009ec3" translate="yes" xml:space="preserve">
          <source>If the exit status is non-zero, &lt;code&gt;git commit&lt;/code&gt; will abort.</source>
          <target state="translated">종료 상태가 0이 아닌 경우 &lt;code&gt;git commit&lt;/code&gt; 이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="ffb6fc6e4737a7b7be769bd191cc211dd325235f" translate="yes" xml:space="preserve">
          <source>If the file &lt;code&gt;.mailmap&lt;/code&gt; exists at the toplevel of the repository, or at the location pointed to by the mailmap.file or mailmap.blob configuration options, it is used to map author and committer names and email addresses to canonical real names and email addresses.</source>
          <target state="translated">&lt;code&gt;.mailmap&lt;/code&gt; 파일 이 저장소의 최상위 레벨에 있거나 mailmap.file 또는 mailmap.blob 구성 옵션이 가리키는 위치에있는 경우, 작성자 및 커미터 이름 및 이메일 주소를 표준 실제 이름 및 이메일 주소로 맵핑하는 데 사용됩니다. .</target>
        </trans-unit>
        <trans-unit id="7142e4ddc34f82f593252b78cfae14d3292c9524" translate="yes" xml:space="preserve">
          <source>If the file gc.log exists, then &lt;code&gt;git gc --auto&lt;/code&gt; will print its content and exit with status zero instead of running unless that file is more than &lt;code&gt;gc.logExpiry&lt;/code&gt; old. Default is &quot;1.day&quot;. See &lt;code&gt;gc.pruneExpire&lt;/code&gt; for more ways to specify its value.</source>
          <target state="translated">gc.log 파일이 존재하는 경우, &lt;code&gt;git gc --auto&lt;/code&gt; 는 파일이 &lt;code&gt;gc.logExpiry&lt;/code&gt; old 이상이 아닌 경우 내용을 인쇄하고 실행하는 대신 상태 0으로 종료 합니다. 기본값은 &quot;1. 일&quot;입니다. 값을 지정하는 자세한 방법 은 &lt;code&gt;gc.pruneExpire&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7333f3457fce187a5640d74385a1bbc89a0c5a97" translate="yes" xml:space="preserve">
          <source>If the filter command (a string value) is defined via &lt;code&gt;filter.&amp;lt;driver&amp;gt;.process&lt;/code&gt; then Git can process all blobs with a single filter invocation for the entire life of a single Git command. This is achieved by using the long-running process protocol (described in technical/long-running-process-protocol.txt).</source>
          <target state="translated">filter 명령 (문자열 값)이 &lt;code&gt;filter.&amp;lt;driver&amp;gt;.process&lt;/code&gt; 를 통해 정의 된 경우 Git은 단일 Git 명령의 전체 수명 동안 단일 필터 호출로 모든 Blob을 처리 할 수 ​​있습니다. 이는 장기 실행 프로세스 프로토콜 (technical / long-running-process-protocol.txt에 설명되어 있음)을 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="edaaa7b77ca9e9ee284b92c3f4abf94dbe583827" translate="yes" xml:space="preserve">
          <source>If the filter dies during the communication or does not adhere to the protocol then Git will stop the filter process and restart it with the next file that needs to be processed. Depending on the &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; flag Git will interpret that as error.</source>
          <target state="translated">통신 중 필터가 죽거나 프로토콜을 준수하지 않으면 Git은 필터 프로세스를 중지하고 처리해야 할 다음 파일로 필터를 다시 시작합니다. 에 따라 &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; 플래그 힘내 오류로 그 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="5e14f4a25e8ac87108268501a2fbb6eaeaabe84f" translate="yes" xml:space="preserve">
          <source>If the filter experiences an error during processing, then it can send the status &quot;error&quot; after the content was (partially or completely) sent.</source>
          <target state="translated">처리 중에 필터에 오류가 발생하면 컨텐츠가 (일부 또는 완전히) 전송 된 후 상태 &quot;오류&quot;를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bace70b57e96bff11ceac069e6098423752b6f8" translate="yes" xml:space="preserve">
          <source>If the filter supports the &quot;delay&quot; capability then it must support the &quot;list_available_blobs&quot; command. If Git sends this command, then the filter is expected to return a list of pathnames representing blobs that have been delayed earlier and are now available. The list must be terminated with a flush packet followed by a &quot;success&quot; status that is also terminated with a flush packet. If no blobs for the delayed paths are available, yet, then the filter is expected to block the response until at least one blob becomes available. The filter can tell Git that it has no more delayed blobs by sending an empty list. As soon as the filter responds with an empty list, Git stops asking. All blobs that Git has not received at this point are considered missing and will result in an error.</source>
          <target state="translated">If the filter supports the &quot;delay&quot; capability then it must support the &quot;list_available_blobs&quot; command. If Git sends this command, then the filter is expected to return a list of pathnames representing blobs that have been delayed earlier and are now available. The list must be terminated with a flush packet followed by a &quot;success&quot; status that is also terminated with a flush packet. If no blobs for the delayed paths are available, yet, then the filter is expected to block the response until at least one blob becomes available. The filter can tell Git that it has no more delayed blobs by sending an empty list. As soon as the filter responds with an empty list, Git stops asking. All blobs that Git has not received at this point are considered missing and will result in an error.</target>
        </trans-unit>
        <trans-unit id="03052ebbe356e67d3f76578abb0f90e9da0b94ac" translate="yes" xml:space="preserve">
          <source>If the filter supports the &quot;delay&quot; capability, then Git can send the flag &quot;can-delay&quot; after the filter command and pathname. This flag denotes that the filter can delay filtering the current blob (e.g. to compensate network latencies) by responding with no content but with the status &quot;delayed&quot; and a flush packet.</source>
          <target state="translated">필터가 &quot;지연&quot;기능을 지원하는 경우 Git은 필터 명령 및 경로 이름 뒤에 &quot;can-delay&quot;플래그를 보낼 수 있습니다. 이 플래그는 필터가 내용이 아니라 &quot;지연됨&quot;상태와 플러시 패킷으로 응답함으로써 현재 블롭 필터링을 지연시킬 수 있음을 나타냅니다 (예 : 네트워크 지연 시간 보상).</target>
        </trans-unit>
        <trans-unit id="13eec1f811a3745751e3462b5df9eab594af45cb" translate="yes" xml:space="preserve">
          <source>If the format is set to &quot;auto:foo&quot; and the pager is in use, format &quot;foo&quot; will be the used for the date format. Otherwise &quot;default&quot; will be used.</source>
          <target state="translated">형식이 &quot;auto : foo&quot;로 설정되어 있고 호출기가 사용중인 경우 날짜 형식에 &quot;foo&quot;형식이 사용됩니다. 그렇지 않으면 &quot;default&quot;가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7402fa03babc6cbdcbdc9c0c2d38f35b3f77eedb" translate="yes" xml:space="preserve">
          <source>If the given object refers to a blob, it will be described as &lt;code&gt;&amp;lt;commit-ish&amp;gt;:&amp;lt;path&amp;gt;&lt;/code&gt;, such that the blob can be found at &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; in the &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, which itself describes the first commit in which this blob occurs in a reverse revision walk from HEAD.</source>
          <target state="translated">지정된 객체의 Blob를 참조하는 경우,이를 설명한다 &lt;code&gt;&amp;lt;commit-ish&amp;gt;:&amp;lt;path&amp;gt;&lt;/code&gt; , 블롭이에서 발견 될 수 있도록 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 자체가 먼저 커밋 설명 이 블롭은 HEAD에서 리버스 리비전으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5e980dfa1f5a4a3edafff4113df2abbd7d17f577" translate="yes" xml:space="preserve">
          <source>If the helper string begins with &quot;!&quot;, it is considered a shell snippet, and everything after the &quot;!&quot; becomes the command.</source>
          <target state="translated">도우미 문자열이 &quot;!&quot;로 시작하면 쉘 스 니펫으로 간주되고 &quot;!&quot;뒤에 오는 모든 문자열로 간주됩니다. 명령이됩니다.</target>
        </trans-unit>
        <trans-unit id="228c738194bda1bc3c409314b8269609d7c41e0b" translate="yes" xml:space="preserve">
          <source>If the hook exits with non-zero status, none of the refs will be updated. If the hook exits with zero, updating of individual refs can still be prevented by the &lt;a href=&quot;#update&quot;&gt;&lt;em&gt;update&lt;/em&gt;&lt;/a&gt; hook.</source>
          <target state="translated">후크가 0이 아닌 상태로 종료되면 참조가 업데이트되지 않습니다. 제로와 후크가 종료되면, 개별 심판의 업데이트는 여전히 방지 할 수 &lt;a href=&quot;#update&quot;&gt;&lt;em&gt;업데이트&lt;/em&gt;&lt;/a&gt; 후크.</target>
        </trans-unit>
        <trans-unit id="8439515eb9b2d0e08bb52156ea070a5b55f21477" translate="yes" xml:space="preserve">
          <source>If the ignore-paths configuration key is set, and the command-line option is also given, both regular expressions will be used.</source>
          <target state="translated">ignore-paths 구성 키가 설정되고 명령 행 옵션도 제공되면 두 정규식이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e545fa5704075d5dfeae5601c6d9858dfebf0464" translate="yes" xml:space="preserve">
          <source>If the ignore-refs configuration key is set, and the command-line option is also given, both regular expressions will be used.</source>
          <target state="translated">ignore-refs 구성 키가 설정되고 명령 행 옵션도 제공되면 두 개의 정규식이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f1e0ea5f0e79a32b5a2b025af2eaf1eb5f6a9a8a" translate="yes" xml:space="preserve">
          <source>If the last path components in the working tree&amp;rsquo;s path is unique among working trees, it can be used to identify a working tree. For example if you only have two working trees, at &lt;code&gt;/abc/def/ghi&lt;/code&gt; and &lt;code&gt;/abc/def/ggg&lt;/code&gt;, then &lt;code&gt;ghi&lt;/code&gt; or &lt;code&gt;def/ghi&lt;/code&gt; is enough to point to the former working tree.</source>
          <target state="translated">작업 트리 경로의 마지막 경로 구성 요소가 작업 트리간에 고유 한 경우 작업 트리를 식별하는 데 사용할 수 있습니다. 예를 들어, 당신은 단지에서 두 개의 작업 나무가있는 경우 &lt;code&gt;/abc/def/ghi&lt;/code&gt; 및 &lt;code&gt;/abc/def/ggg&lt;/code&gt; , 다음 &lt;code&gt;ghi&lt;/code&gt; 또는 &lt;code&gt;def/ghi&lt;/code&gt; 이전 작업 트리를 차례로 충분하다.</target>
        </trans-unit>
        <trans-unit id="368e2e291b26f0dca547e5b1c9de986c75896687" translate="yes" xml:space="preserve">
          <source>If the last path components in the working tree&amp;rsquo;s path is unique among working trees, it can be used to identify worktrees. For example if you only have two working trees, at &quot;/abc/def/ghi&quot; and &quot;/abc/def/ggg&quot;, then &quot;ghi&quot; or &quot;def/ghi&quot; is enough to point to the former working tree.</source>
          <target state="translated">작업 트리 경로의 마지막 경로 구성 요소가 작업 트리 중에서 고유 한 경우 작업 트리를 식별하는 데 사용할 수 있습니다. 예를 들어, &quot;/ abc / def / ghi&quot;및 &quot;/ abc / def / ggg&quot;에 두 개의 작업 트리 만있는 경우 &quot;ghi&quot;또는 &quot;def / ghi&quot;이면 이전 작업 트리를 가리 키기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="a77fa7a1d051613196a1695412c9a05d33f69ded" translate="yes" xml:space="preserve">
          <source>If the local offset is not available in the source material, use &amp;ldquo;+0000&amp;rdquo;, or the most common local offset. For example many organizations have a CVS repository which has only ever been accessed by users who are located in the same location and time zone. In this case a reasonable offset from UTC could be assumed.</source>
          <target state="translated">소스 자료에서 로컬 오프셋을 사용할 수없는 경우 &quot;+0000&quot;또는 가장 일반적인 로컬 오프셋을 사용하십시오. 예를 들어 많은 조직에는 CVS 리포지토리가 있으며 동일한 위치와 시간대에있는 사용자 만 액세스 할 수 있습니다. 이 경우 UTC와의 합리적인 오프셋을 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="178f63f22948e35272dd2355f9864ebc5b092dbe" translate="yes" xml:space="preserve">
          <source>If the maintainer tells you that your patch no longer applies to the current upstream, you will have to rebase your topic (you cannot use a merge because you cannot format-patch merges):</source>
          <target state="translated">관리자가 패치가 더 이상 현재 업스트림에 적용되지 않는다고 알려 주면 주제를 리베이스해야합니다 (패치 병합을 포맷 할 수 없으므로 병합을 사용할 수 없음).</target>
        </trans-unit>
        <trans-unit id="9b0ae610cbbc854a9104beb55038f8e674b12699" translate="yes" xml:space="preserve">
          <source>If the merge cannot be carried out automatically, the conflicts need to be resolved and the result committed separately (see &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;). At that point, this hook will not be executed, but the &lt;code&gt;pre-commit&lt;/code&gt; hook will, if it is enabled.</source>
          <target state="translated">병합을 자동으로 수행 할 수 없으면 충돌을 해결하고 결과를 별도로 커밋해야합니다 ( &lt;a href=&quot;git-merge&quot;&gt;git-merge [1] 참조&lt;/a&gt; ). 이 시점에서이 후크는 실행되지 않지만 &lt;code&gt;pre-commit&lt;/code&gt; 후크 (활성화 된 경우)입니다.</target>
        </trans-unit>
        <trans-unit id="e1f358924aaa72264d85ec0ddf7ef92dd8191058" translate="yes" xml:space="preserve">
          <source>If the merge fails because it is not a fast-forward, then it is possible some fixes on &lt;code&gt;maint&lt;/code&gt; were missed in the feature release. This will not happen if the content of the branches was verified as described in the previous section.</source>
          <target state="translated">빨리 감기가 아니기 때문에 병합에 실패 하면 기능 릴리스에서 &lt;code&gt;maint&lt;/code&gt; 의 일부 수정 사항 이 누락되었을 수 있습니다. 분기의 내용이 이전 섹션에서 설명한대로 확인 된 경우에는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39e28c0246f221ccbae77af3a33cb0a2f4910f1f" translate="yes" xml:space="preserve">
          <source>If the number of objects fetched over the Git native transfer is below this limit, then the objects will be unpacked into loose object files. However if the number of received objects equals or exceeds this limit then the received pack will be stored as a pack, after adding any missing delta bases. Storing the pack from a push can make the push operation complete faster, especially on slow filesystems. If not set, the value of &lt;code&gt;transfer.unpackLimit&lt;/code&gt; is used instead.</source>
          <target state="translated">Git 기본 전송을 통해 페치 된 오브젝트 수가이 한계 미만이면 오브젝트가 느슨한 오브젝트 파일로 압축 해제됩니다. 그러나 수신 된 오브젝트 수가이 한계와 같거나 초과하면 누락 된 델타베이스를 추가 한 후 수신 된 팩이 팩으로 저장됩니다. 푸시에서 팩을 저장하면 특히 느린 파일 시스템에서 푸시 작업이 더 빨리 완료 될 수 있습니다. 설정하지 않으면 &lt;code&gt;transfer.unpackLimit&lt;/code&gt; 값이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba1c0757ead2b007fd4bc7bc8fe3299d5f283bd7" translate="yes" xml:space="preserve">
          <source>If the number of objects imported by &lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import[1]&lt;/a&gt; is below this limit, then the objects will be unpacked into loose object files. However if the number of imported objects equals or exceeds this limit then the pack will be stored as a pack. Storing the pack from a fast-import can make the import operation complete faster, especially on slow filesystems. If not set, the value of &lt;code&gt;transfer.unpackLimit&lt;/code&gt; is used instead.</source>
          <target state="translated">&lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import [1]&lt;/a&gt; 로 가져온 객체 수가이 제한보다 낮 으면 객체가 느슨한 객체 파일로 압축 해제됩니다. 그러나 반입 된 오브젝트 수가이 한계와 같거나 초과하면 팩은 팩으로 저장됩니다. 빠른 가져 오기에서 팩을 저장하면 특히 느린 파일 시스템에서 가져 오기 작업을 더 빠르게 완료 할 수 있습니다. 설정하지 않으면 &lt;code&gt;transfer.unpackLimit&lt;/code&gt; 값이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="66dbfca32684aa415437926e2128b562d1010471" translate="yes" xml:space="preserve">
          <source>If the number of objects received in a push is below this limit then the objects will be unpacked into loose object files. However if the number of received objects equals or exceeds this limit then the received pack will be stored as a pack, after adding any missing delta bases. Storing the pack from a push can make the push operation complete faster, especially on slow filesystems. If not set, the value of &lt;code&gt;transfer.unpackLimit&lt;/code&gt; is used instead.</source>
          <target state="translated">푸시에 수신 된 오브젝트 수가이 한계 미만이면 오브젝트가 느슨한 오브젝트 파일로 압축 해제됩니다. 그러나 수신 된 오브젝트 수가이 한계와 같거나 초과하면 누락 된 델타베이스를 추가 한 후 수신 된 팩이 팩으로 저장됩니다. 푸시에서 팩을 저장하면 특히 느린 파일 시스템에서 푸시 작업이 더 빨리 완료 될 수 있습니다. 설정하지 않으면 &lt;code&gt;transfer.unpackLimit&lt;/code&gt; 값이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e5106f465347ea1c1f64d4a4e406ce8334671d0b" translate="yes" xml:space="preserve">
          <source>If the object being copied out to a temporary file is a symbolic link the content of the link will be written to a normal file. It is up to the end-user or the Porcelain to make use of this information.</source>
          <target state="translated">임시 파일로 복사되는 객체가 심볼릭 링크 인 경우 링크의 내용이 일반 파일에 기록됩니다. 이 정보를 이용하는 것은 최종 사용자 또는 도자기의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="0199138006db8140692b7fdc79404759dcaa332d" translate="yes" xml:space="preserve">
          <source>If the object is stored as a delta on-disk, this expands to the 40-hex sha1 of the delta base object. Otherwise, expands to the null sha1 (40 zeroes). See &lt;code&gt;CAVEATS&lt;/code&gt; below.</source>
          <target state="translated">객체가 델타 온 디스크로 저장된 경우 이는 델타 기본 객체의 40- 헥스 sha1로 확장됩니다. 그렇지 않으면 널 sha1 (40 0)으로 확장됩니다. 참조 &lt;code&gt;CAVEATS&lt;/code&gt; 은 아래를.</target>
        </trans-unit>
        <trans-unit id="bd902b813b2d32a3c916d53036b9b4661bcff5a2" translate="yes" xml:space="preserve">
          <source>If the object storage directory is specified via the &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; environment variable then the sha1 directories are created underneath - otherwise the default &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; directory is used.</source>
          <target state="translated">오브젝트 스토리지 디렉토리가 &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; 환경 변수를 통해 지정 되면 sha1 디렉토리가 아래에 작성 됩니다. 그렇지 않으면 기본 &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; 디렉토리가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5445d9592417f6217da69d0d0ffe49e2288619f2" translate="yes" xml:space="preserve">
          <source>If the object storage directory is specified via this environment variable then the sha1 directories are created underneath - otherwise the default &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; directory is used.</source>
          <target state="translated">이 환경 변수를 통해 오브젝트 스토리지 디렉토리가 지정된 경우 sha1 디렉토리가 아래에 작성 됩니다. 그렇지 않으면 기본 &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; 디렉토리가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f2dc3f2759f3e631848eb5ab78d16a8be4a1f31" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;--all&lt;/code&gt; or &lt;code&gt;-a&lt;/code&gt; is given, all available commands are printed on the standard output.</source>
          <target state="translated">&lt;code&gt;--all&lt;/code&gt; 또는 &lt;code&gt;-a&lt;/code&gt; 옵션 이 제공되면 사용 가능한 모든 명령이 표준 출력에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="5db3d9ce81a9166e23fdfafcb7cf25752ff75423" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;--guide&lt;/code&gt; or &lt;code&gt;-g&lt;/code&gt; is given, a list of the useful Git guides is also printed on the standard output.</source>
          <target state="translated">&lt;code&gt;--guide&lt;/code&gt; 또는 &lt;code&gt;-g&lt;/code&gt; 옵션 이 제공되면 유용한 Git 안내서 목록도 표준 출력에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="401de2382d11b6e27d9e64da4738d460ce293134" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;--guides&lt;/code&gt; or &lt;code&gt;-g&lt;/code&gt; is given, a list of the Git concept guides is also printed on the standard output.</source>
          <target state="translated">&lt;code&gt;--guides&lt;/code&gt; 또는 &lt;code&gt;-g&lt;/code&gt; 옵션 이 제공되면 Git 개념 가이드 목록도 표준 출력에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="22d4a6b6cbe8c87e55028aafc6f2a3b165e3a3fa" translate="yes" xml:space="preserve">
          <source>If the patch contains any changes to submodules then &lt;code&gt;git apply&lt;/code&gt; treats these changes as follows.</source>
          <target state="translated">패치에 서브 모듈에 대한 변경 사항이 포함되어 있으면 &lt;code&gt;git apply&lt;/code&gt; 는 이러한 변경 사항을 다음과 같이 처리합니다.</target>
        </trans-unit>
        <trans-unit id="bc5f440658cbf7f8fc36476e96067d0db070086e" translate="yes" xml:space="preserve">
          <source>If the pattern does not start with either &lt;code&gt;~/&lt;/code&gt;, &lt;code&gt;./&lt;/code&gt; or &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**/&lt;/code&gt; will be automatically prepended. For example, the pattern &lt;code&gt;foo/bar&lt;/code&gt; becomes &lt;code&gt;**/foo/bar&lt;/code&gt; and would match &lt;code&gt;/any/path/to/foo/bar&lt;/code&gt;.</source>
          <target state="translated">패턴 중 하나로 시작하지 않으면 &lt;code&gt;~/&lt;/code&gt; , &lt;code&gt;./&lt;/code&gt; 또는 &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;**/&lt;/code&gt; 이 자동으로 앞에 추가됩니다. 예를 들어, 패턴 &lt;code&gt;foo/bar&lt;/code&gt; 는 &lt;code&gt;**/foo/bar&lt;/code&gt; 가 되고 &lt;code&gt;/any/path/to/foo/bar&lt;/code&gt; 와 일치 합니다 .</target>
        </trans-unit>
        <trans-unit id="cdf2b04ab13a298c669a989712845f14a413f23b" translate="yes" xml:space="preserve">
          <source>If the pattern ends with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt; will be automatically added. For example, the pattern &lt;code&gt;foo/&lt;/code&gt; becomes &lt;code&gt;foo/**&lt;/code&gt;. In other words, it matches &quot;foo&quot; and everything inside, recursively.</source>
          <target state="translated">패턴 끝이 경우 &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; 는 자동으로 추가됩니다. 예를 들어, 패턴 &lt;code&gt;foo/&lt;/code&gt; 는 &lt;code&gt;foo/**&lt;/code&gt; 가 됩니다. 다시 말해, &quot;foo&quot;와 내부의 모든 것을 재귀 적으로 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="ead2b404e5878a53eb56a401706bd4f86f5cdd4b" translate="yes" xml:space="preserve">
          <source>If the pattern ends with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt; will be automatically added. For example, the pattern &lt;code&gt;foo/&lt;/code&gt; becomes &lt;code&gt;foo/**&lt;/code&gt;. In other words, it matches all branches that begin with &lt;code&gt;foo/&lt;/code&gt;. This is useful if your branches are organized hierarchically and you would like to apply a configuration to all the branches in that hierarchy.</source>
          <target state="translated">패턴 끝이 경우 &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; 는 자동으로 추가됩니다. 예를 들어, 패턴 &lt;code&gt;foo/&lt;/code&gt; 는 &lt;code&gt;foo/**&lt;/code&gt; 가 됩니다. 즉, &lt;code&gt;foo/&lt;/code&gt; 시작하는 모든 분기와 일치합니다 . 분기가 계층 적으로 구성되어 있고 해당 계층의 모든 분기에 구성을 적용하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f1c8abd89592d50ca8ca62bbaec12c523f709263" translate="yes" xml:space="preserve">
          <source>If the pattern starts with &lt;code&gt;./&lt;/code&gt;, it is replaced with the directory containing the current config file.</source>
          <target state="translated">패턴이 &lt;code&gt;./&lt;/code&gt; 로 시작 하면 현재 구성 파일이 들어있는 디렉토리로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="f924b2c312a1632ec51dd0f0353e6842160ab641" translate="yes" xml:space="preserve">
          <source>If the pattern starts with &lt;code&gt;~/&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; will be substituted with the content of the environment variable &lt;code&gt;HOME&lt;/code&gt;.</source>
          <target state="translated">패턴이로 시작하면 &lt;code&gt;~/&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; 환경 변수의 내용으로 대체됩니다 &lt;code&gt;HOME&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25b5ae377df44f33ba840cf2411c6edf767c0d5b" translate="yes" xml:space="preserve">
          <source>If the pre-receive hook exits with a non-zero exit status no updates will be performed, and the update, post-receive and post-update hooks will not be invoked either. This can be useful to quickly bail out if the update is not to be supported.</source>
          <target state="translated">수신 전 후크가 0이 아닌 종료 상태로 종료되면 업데이트가 수행되지 않으며 업데이트, 수신 후 및 업데이트 후 후크도 호출되지 않습니다. 업데이트를 지원하지 않을 경우 신속하게 구제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0131da637807c8654fda6294e521f8e5e74d9c2b" translate="yes" xml:space="preserve">
          <source>If the problematic commit is the most recent commit, and you have not yet made that commit public, then you may just &lt;a href=&quot;#undoing-a-merge&quot;&gt;destroy it using &lt;code&gt;git reset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문제가있는 커밋이 가장 최근의 커밋이고 아직 해당 커밋을 공개하지 않은 &lt;a href=&quot;#undoing-a-merge&quot;&gt;경우 &lt;code&gt;git reset&lt;/code&gt; 을&lt;/a&gt; 사용하여 커밋을 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f275a1769b3300733689c93e8034126052b9dd7" translate="yes" xml:space="preserve">
          <source>If the project list is taken from a file (&lt;code&gt;$projects_list&lt;/code&gt; points to a file), forks are only recognized if they are listed after the main project in that file.</source>
          <target state="translated">프로젝트 목록을 파일에서 가져 오면 ( &lt;code&gt;$projects_list&lt;/code&gt; 는 파일을 가리킴) 포크는 해당 파일에서 기본 프로젝트 뒤에 나열된 경우에만 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="cabde5708a0c59fc40ce3c5aef7bb8948c87aab4" translate="yes" xml:space="preserve">
          <source>If the reference repository is on the local machine, automatically setup &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; to obtain objects from the reference repository. Using an already existing repository as an alternate will require fewer objects to be copied from the repository being cloned, reducing network and local storage costs. When using the &lt;code&gt;--reference-if-able&lt;/code&gt;, a non existing directory is skipped with a warning instead of aborting the clone.</source>
          <target state="translated">참조 리포지토리가 로컬 컴퓨터에있는 경우 &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; 를 자동으로 설정 하여 참조 리포지토리에서 개체를 가져옵니다. 이미 존재하는 리포지토리를 대체물로 사용하면 복제되는 리포지토리에서 적은 수의 객체를 복사해야하므로 네트워크 및 로컬 스토리지 비용이 줄어 듭니다. &lt;code&gt;--reference-if-able&lt;/code&gt; 을 사용할 때 기존 디렉토리가 아닌 디렉토리는 복제를 중단하는 대신 경고와 함께 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="5ea9c0fb462e839210565ca58d9885017561c1be" translate="yes" xml:space="preserve">
          <source>If the refspec is a globbing one, nothing is merged.</source>
          <target state="translated">참조 스펙이 globbing 하나이면 아무 것도 병합되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67d81d9e5d98e20a38ce258501ea936cdaf3477e" translate="yes" xml:space="preserve">
          <source>If the remote has enabled the options &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt;, &lt;code&gt;uploadpack.allowReachableSHA1InWant&lt;/code&gt;, or &lt;code&gt;uploadpack.allowAnySHA1InWant&lt;/code&gt;, they may alternatively be 40-hex sha1s present on the remote.</source>
          <target state="translated">원격에서 &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt; , &lt;code&gt;uploadpack.allowReachableSHA1InWant&lt;/code&gt; 또는 &lt;code&gt;uploadpack.allowAnySHA1InWant&lt;/code&gt; 옵션을 활성화 한 경우 원격에 40- 헥스 sha1이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43fe46812af3fc1b263ad2f17ddd0dcd8b849c57" translate="yes" xml:space="preserve">
          <source>If the remote is fetched successfully, add upstream (tracking) reference, used by argument-less &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; and other commands. For more information, see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">리모컨을 성공적으로 가져 오면 인수없는 &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt; 및 기타 명령 에서 사용하는 업스트림 (추적) 참조를 추가 합니다. 자세한 내용 은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]의 &lt;/a&gt; &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 및 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b40a2dab8bd4f0c4875755d97441dd96a4edce1" translate="yes" xml:space="preserve">
          <source>If the remote is fetched successfully, pull and add upstream (tracking) reference, used by argument-less &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; and other commands. For more information, see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">리모트가 성공적으로 페치되면 인수없는 &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt; 및 기타 명령 에서 사용하는 업스트림 (추적) 참조를 끌어 추가하십시오 . 자세한 내용 은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]의 &lt;/a&gt; &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 및 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc0cb0804e07bed75e0e991fffdc9aae616f339a" translate="yes" xml:space="preserve">
          <source>If the remote side supports it, annotated tags objects will be downloaded on the same connection as the other objects if the object the tag references is downloaded. The caller must otherwise determine the tags this option made available.</source>
          <target state="translated">원격 측에서 지원하는 경우 태그가 참조하는 객체를 다운로드하면 주석이 달린 태그 객체가 다른 객체와 동일한 연결로 다운로드됩니다. 그렇지 않으면 호출자는이 옵션을 사용 가능하게 한 태그를 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b72444ac7244fe67691159600db782df37b1532c" translate="yes" xml:space="preserve">
          <source>If the repository is bare, &lt;code&gt;--no-checkout&lt;/code&gt; is assumed.</source>
          <target state="translated">리포지토리가없는 경우 &lt;code&gt;--no-checkout&lt;/code&gt; 이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="36e50561f165c018ae6f119c2c6f3e5164508f60" translate="yes" xml:space="preserve">
          <source>If the repository is specified as a local path (e.g., &lt;code&gt;/path/to/repo&lt;/code&gt;), this is the default, and --local is essentially a no-op. If the repository is specified as a URL, then this flag is ignored (and we never use the local optimizations). Specifying &lt;code&gt;--no-local&lt;/code&gt; will override the default when &lt;code&gt;/path/to/repo&lt;/code&gt; is given, using the regular Git transport instead.</source>
          <target state="translated">저장소가 로컬 경로 (예 : &lt;code&gt;/path/to/repo&lt;/code&gt; )로 지정되면 이것이 기본값이며 --local은 기본적으로 no-op입니다. 리포지토리가 URL로 지정된 경우이 플래그는 무시되며 로컬 최적화를 사용하지 않습니다. &lt;code&gt;--no-local&lt;/code&gt; 을 지정 하면 대신 일반 Git 전송을 사용하여 &lt;code&gt;/path/to/repo&lt;/code&gt; 가 제공 될 때 기본값을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="9c19da211c253af2b7a5a65c4c24c5e8a4f73309" translate="yes" xml:space="preserve">
          <source>If the result content is empty then the filter is expected to respond with a &quot;success&quot; status and a flush packet to signal the empty content.</source>
          <target state="translated">결과 내용이 비어 있으면 필터는 &quot;성공&quot;상태 및 비우기 패킷으로 응답하여 빈 내용을 알립니다.</target>
        </trans-unit>
        <trans-unit id="87bdb08d6c6927271153931ec7c3dbb32bf0435b" translate="yes" xml:space="preserve">
          <source>If the server has found a suitable cut point and has decided to send a &quot;ready&quot; line, then the server can decide to (as an optimization) omit any &quot;ACK&quot; lines it would have sent during its response. This is because the server will have already determined the objects it plans to send to the client and no further negotiation is needed.</source>
          <target state="translated">서버가 적절한 컷 포인트를 발견하고 &quot;준비&quot;라인을 전송하기로 결정한 경우, 서버는 응답 중에 전송 한 &quot;ACK&quot;라인을 (최적화로) 생략하기로 결정할 수 있습니다. 서버가 클라이언트에 보낼 객체를 이미 결정 했으므로 추가 협상이 필요하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b994a26dfc45bfc84fb73ef67436c3f647661961" translate="yes" xml:space="preserve">
          <source>If the size of the incoming pack stream is larger than this limit, then git-receive-pack will error out, instead of accepting the pack file. If not set or set to 0, then the size is unlimited.</source>
          <target state="translated">수신 팩 스트림의 크기가이 한계보다 크면 팩 파일을 승인하는 대신 git-receive-pack이 오류를 발생시킵니다. 설정하지 않거나 0으로 설정하면 크기는 무제한입니다.</target>
        </trans-unit>
        <trans-unit id="ff78750ae83975fe12661694a886f60b06a8fa31" translate="yes" xml:space="preserve">
          <source>If the source material uses RFC 2822 style dates, the frontend should let fast-import handle the parsing and conversion (rather than attempting to do it itself) as the Git parser has been well tested in the wild.</source>
          <target state="translated">소스 자료가 RFC 2822 스타일 날짜를 사용하는 경우 프런트 엔드는 Git 파서가 제대로 테스트되었으므로 파싱 및 변환을 자체적으로 시도하지 않고 빨리 가져 오기로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="3c8cd70e721e8a0b9cd7092e81bbbfc31a3bd8bd" translate="yes" xml:space="preserve">
          <source>If the source repository is complete, convert a shallow repository to a complete one, removing all the limitations imposed by shallow repositories.</source>
          <target state="translated">소스 저장소가 완료된 경우 얕은 저장소를 완전한 저장소로 변환하여 얕은 저장소에 의해 부과 된 모든 제한 사항을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="9e6d3a4e3136a4838fe6f50fd9653c6cb56b6d6c" translate="yes" xml:space="preserve">
          <source>If the source repository is shallow, fetch as much as possible so that the current repository has the same history as the source repository.</source>
          <target state="translated">소스 저장소가 얕은 경우, 현재 저장소가 소스 저장소와 동일한 히스토리를 갖도록 가능한 한 많이 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="de8398976a760845a7849338955a9624333ab515" translate="yes" xml:space="preserve">
          <source>If the starting point is specified as &lt;code&gt;ref@{Nth}&lt;/code&gt;, show the index format.</source>
          <target state="translated">시작점이 &lt;code&gt;ref@{Nth}&lt;/code&gt; 로 지정 되면 색인 형식을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="6a2386c7d64f544644194a06f1f15e00500df35a" translate="yes" xml:space="preserve">
          <source>If the starting point was specified as &lt;code&gt;ref@{now}&lt;/code&gt;, show the timestamp format.</source>
          <target state="translated">시작점이 &lt;code&gt;ref@{now}&lt;/code&gt; 로 지정된 경우 타임 스탬프 형식을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="a401b7c4a3b36e61e5b713fb185191570664ec06" translate="yes" xml:space="preserve">
          <source>If the submodule has never been initialized, this is the only place where submodule configuration is found. It serves as the last fallback to specify where to obtain the submodule from.</source>
          <target state="translated">서브 모듈이 초기화되지 않은 경우, 이것은 서브 모듈 구성이있는 유일한 곳입니다. 서브 모듈을 얻을 수있는 곳을 지정하는 마지막 폴백 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="c93d30e9eb4c6197dacc1ad5f6b79e20616e783c" translate="yes" xml:space="preserve">
          <source>If the submodule is not yet initialized, and you just want to use the setting as stored in &lt;code&gt;.gitmodules&lt;/code&gt;, you can automatically initialize the submodule with the &lt;code&gt;--init&lt;/code&gt; option.</source>
          <target state="translated">하위 모듈이 아직 초기화되지 않았으며 &lt;code&gt;.gitmodules&lt;/code&gt; 에 저장된 설정을 사용하려는 경우 &lt;code&gt;--init&lt;/code&gt; 옵션을 사용 하여 하위 모듈을 자동으로 초기화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02845d91bbeb482c77721be199fb493e9af0747b" translate="yes" xml:space="preserve">
          <source>If the submodule is not yet initialized, then the configuration inside the submodule does not exist yet, so where to obtain the submodule from is configured here for example.</source>
          <target state="translated">서브 모듈이 아직 초기화되지 않은 경우 서브 모듈 내부의 구성이 아직 존재하지 않으므로 서브 모듈을 어디서 구할 수 있는지가 여기에 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="ae19e2f586d76eb404950c906a0e28fc48bd4144" translate="yes" xml:space="preserve">
          <source>If the target branch in refs/remotes/p4-unshelved already exists, the old one will be renamed.</source>
          <target state="translated">refs / remotes / p4-unshelved의 대상 분기가 이미 존재하면 이전 분기의 이름이 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="2f7883dbe6de00b83ac31c035cb47ace7f18b215" translate="yes" xml:space="preserve">
          <source>If the timestamp order of different files cross the revision order within the commit matching time window the order of commits may be wrong.</source>
          <target state="translated">다른 파일의 타임 스탬프 순서가 커밋 일치 시간 창 내에서 개정 순서를 넘으면 커밋 순서가 잘못 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e02bc5f839968fa2bd55c9715c548322d410f70" translate="yes" xml:space="preserve">
          <source>If the update is done via merge, the submodule conflicts are resolved and checked out.</source>
          <target state="translated">병합을 통해 업데이트가 수행되면 하위 모듈 충돌이 해결되고 체크 아웃됩니다.</target>
        </trans-unit>
        <trans-unit id="e429444552f2f76afd93b7eab781098fd53d76ab" translate="yes" xml:space="preserve">
          <source>If the upstream branch already contains a change you have made (e.g., because you mailed a patch which was applied upstream), then that commit will be skipped. For example, running &lt;code&gt;git rebase master&lt;/code&gt; on the following history (in which &lt;code&gt;A'&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; introduce the same set of changes, but have different committer information):</source>
          <target state="translated">업스트림 브랜치에 이미 변경 한 내용이 포함 된 경우 (예 : 업스트림으로 적용된 패치를 메일로 전송 한 경우) 해당 커밋은 건너 뜁니다. 예를 들어, 다음 히스토리 에서 &lt;code&gt;git rebase master&lt;/code&gt; 를 실행 하면 ( &lt;code&gt;A'&lt;/code&gt; 와 &lt;code&gt;A&lt;/code&gt; 는 동일한 변경 사항 세트를 도입하지만 커미터 정보는 다릅니다) :</target>
        </trans-unit>
        <trans-unit id="8dd2ebfbc7db6f2a970a9204f7e4fecacb05b440" translate="yes" xml:space="preserve">
          <source>If the user is driving it, then at each step of the search, the user will have to test the current commit and say if it is &quot;good&quot; or &quot;bad&quot; using the &quot;git bisect good&quot; or &quot;git bisect bad&quot; commands respectively that have been described above. For example:</source>
          <target state="translated">사용자가이를 검색하는 경우 검색의 각 단계에서 사용자는 현재 커밋을 테스트하고 &quot;git bisect good&quot;또는 &quot;git bisect bad&quot;명령을 사용하여 현재 커밋을 테스트해야합니다. 위에서 설명한 각각. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6929af54c2109d01f0c27eda6b64b41906b00393" translate="yes" xml:space="preserve">
          <source>If the user provides a --tag-name-filter that maps multiple tags to the same name, no warning or error is provided; git-filter-branch simply overwrites each tag in some undocumented pre-defined order resulting in only one tag at the end. (A git-filter-branch regression test requires this surprising behavior.)</source>
          <target state="translated">사용자가 여러 태그를 같은 이름으로 매핑하는 --tag-name-filter를 제공하면 경고 또는 오류가 제공되지 않습니다. git-filter-branch는 각 태그를 문서화되지 않은 사전 정의 된 순서로 덮어 쓰기하여 끝에 하나의 태그 만 생성합니다. git-filter-branch 회귀 테스트에는이 놀라운 동작이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="115afcefe8deea6713a6376b9b3612622ce5ff41" translate="yes" xml:space="preserve">
          <source>If the user running &lt;code&gt;git p4 submit&lt;/code&gt; does not exist in the p4 user map, &lt;code&gt;git p4&lt;/code&gt; exits. This option can be used to force submission regardless.</source>
          <target state="translated">&lt;code&gt;git p4 submit&lt;/code&gt; 을 실행하는 사용자 가 p4 사용자 맵에 존재하지 않으면 &lt;code&gt;git p4&lt;/code&gt; 가 종료됩니다. 이 옵션을 사용하여 제출을 강제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ce7fbc3c51757d8b6052ea0a42e4807120e305f" translate="yes" xml:space="preserve">
          <source>If the value is boolean, turns on or off pagination of the output of a particular Git subcommand when writing to a tty. Otherwise, turns on pagination for the subcommand using the pager specified by the value of &lt;code&gt;pager.&amp;lt;cmd&amp;gt;&lt;/code&gt;. If &lt;code&gt;--paginate&lt;/code&gt; or &lt;code&gt;--no-pager&lt;/code&gt; is specified on the command line, it takes precedence over this option. To disable pagination for all commands, set &lt;code&gt;core.pager&lt;/code&gt; or &lt;code&gt;GIT_PAGER&lt;/code&gt; to &lt;code&gt;cat&lt;/code&gt;.</source>
          <target state="translated">값이 부울 인 경우 tty에 쓸 때 특정 Git 부속 명령의 출력에 대한 페이지 매김을 켜거나 끕니다. 그렇지 않으면, &lt;code&gt;pager.&amp;lt;cmd&amp;gt;&lt;/code&gt; 값으로 지정된 페이저를 사용하여 부속 명령에 대한 페이지 매김을 설정하십시오 . 경우 &lt;code&gt;--paginate&lt;/code&gt; 또는 &lt;code&gt;--no-pager&lt;/code&gt; 명령 행에 지정되어,이 옵션보다 우선합니다. 모든 명령에 대해 페이지 매김을 비활성화하려면 &lt;code&gt;core.pager&lt;/code&gt; 또는 &lt;code&gt;GIT_PAGER&lt;/code&gt; 을 &lt;code&gt;cat&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d03e93ea222dab8f641cb8201b06b8ce56eb4397" translate="yes" xml:space="preserve">
          <source>If the variable is set to an integer value greater than 2 and lower than 10 (strictly) then Git will interpret this value as an open file descriptor and will try to write the trace messages into this file descriptor.</source>
          <target state="translated">변수가 2보다 크고 10보다 작은 정수 값으로 설정되면 (엄격히) Git은이 값을 열린 파일 디스크립터로 해석하고이 파일 디스크립터에 추적 메시지를 쓰려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="68e78b3aa184c7970e4ea72bcfa1c35c1841182d" translate="yes" xml:space="preserve">
          <source>If there are a large number of similarly-named remote repositories and you want to use a different format for them (such that the URLs you use will be rewritten into URLs that work), you can create a configuration section of the form:</source>
          <target state="translated">비슷한 이름의 원격 저장소가 많이 있고 다른 형식을 사용하려는 경우 (사용하는 URL이 작동하는 URL로 다시 작성되도록) 다음과 같은 형식의 구성 섹션을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1add756b76a7c17e78b77f722a60e35881bd1c18" translate="yes" xml:space="preserve">
          <source>If there are conflicts, the user should edit the result and delete one of the alternatives. When &lt;code&gt;--ours&lt;/code&gt;, &lt;code&gt;--theirs&lt;/code&gt;, or &lt;code&gt;--union&lt;/code&gt; option is in effect, however, these conflicts are resolved favouring lines from &lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt;, lines from &lt;code&gt;&amp;lt;other-file&amp;gt;&lt;/code&gt;, or lines from both respectively. The length of the conflict markers can be given with the &lt;code&gt;--marker-size&lt;/code&gt; option.</source>
          <target state="translated">충돌이있는 경우 결과를 편집하고 대체 방법 중 하나를 삭제해야합니다. 때 &lt;code&gt;--ours&lt;/code&gt; , &lt;code&gt;--theirs&lt;/code&gt; , 또는 &lt;code&gt;--union&lt;/code&gt; 옵션이 유효하지만, 이러한 충돌에서 라인을 선호 해결이다 &lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt; 에서 선 &lt;code&gt;&amp;lt;other-file&amp;gt;&lt;/code&gt; 모두 각각에서, 또는 라인. 충돌 마커의 길이는 &lt;code&gt;--marker-size&lt;/code&gt; 옵션 으로 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86762a48683c371a4cc7c3de1cb012419562ae87" translate="yes" xml:space="preserve">
          <source>If there are multiple branches, doing &lt;code&gt;git p4 sync&lt;/code&gt; will automatically use the &quot;BRANCH DETECTION&quot; algorithm to try to partition new changes into the right branch. This can be overridden with the &lt;code&gt;--branch&lt;/code&gt; option to specify just a single branch to update.</source>
          <target state="translated">분기가 여러 개인 경우, &lt;code&gt;git p4 sync&lt;/code&gt; 를 수행 하면 자동으로 &quot;BRANCH DETECTION&quot;알고리즘을 사용하여 새 변경 사항을 올바른 분기로 분할하려고합니다. &lt;code&gt;--branch&lt;/code&gt; 옵션으로 이를 재정 의하여 업데이트 할 단일 분기 만 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="618accc0d1d550b6b8ec069f55b5b09af649e985" translate="yes" xml:space="preserve">
          <source>If there are multiple instances of the &lt;code&gt;credential.helper&lt;/code&gt; configuration variable, each helper will be tried in turn, and may provide a username, password, or nothing. Once Git has acquired both a username and a password, no more helpers will be tried.</source>
          <target state="translated">&lt;code&gt;credential.helper&lt;/code&gt; 구성 변수의 인스턴스가 여러 개인 경우 각 헬퍼는 차례로 시도되며 사용자 이름, 비밀번호 또는 아무것도 제공하지 않을 수 있습니다. Git이 사용자 이름과 비밀번호를 모두 획득하면 더 이상 도우미가 시도되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="af9d46d5bd3ac828de63ddb9d4effe59327aaa5a" translate="yes" xml:space="preserve">
          <source>If there are other repositories that you also use frequently, you can create similar configuration options to save typing; for example,</source>
          <target state="translated">자주 사용하는 다른 리포지토리가있는 경우 유사한 구성 옵션을 만들어 입력을 저장할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="591918eb06b2723ac86bd0a089445e6e294cf8c5" translate="yes" xml:space="preserve">
          <source>If there exist packfiles in the pack directory not registered in the MIDX, then those packfiles are loaded into the &lt;code&gt;packed_git&lt;/code&gt; list and &lt;code&gt;packed_git_mru&lt;/code&gt; cache.</source>
          <target state="translated">MIDX에 등록되지 않은 pack 디렉토리에 packfile이있는 경우 해당 packfile은 &lt;code&gt;packed_git&lt;/code&gt; 목록 및 &lt;code&gt;packed_git_mru&lt;/code&gt; 캐시에 로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="03e18f44da1b610f354ea9baeb478307ccf925f8" translate="yes" xml:space="preserve">
          <source>If there is a separator at the beginning or middle (or both) of the pattern, then the pattern is relative to the directory level of the particular &lt;code&gt;.gitignore&lt;/code&gt; file itself. Otherwise the pattern may also match at any level below the &lt;code&gt;.gitignore&lt;/code&gt; level.</source>
          <target state="translated">패턴의 시작 또는 중간 (또는 둘 다)에 구분 기호가있는 경우 패턴은 특정 &lt;code&gt;.gitignore&lt;/code&gt; 파일 자체 의 디렉토리 레벨을 기준으로합니다 . 그렇지 않으면 패턴이 &lt;code&gt;.gitignore&lt;/code&gt; 레벨 아래의 어떤 레벨에서도 일치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="73c5dbd4863767291eb0584c1211aa56213f1838" translate="yes" xml:space="preserve">
          <source>If there is a separator at the end of the pattern then the pattern will only match directories, otherwise the pattern can match both files and directories.</source>
          <target state="translated">패턴 끝에 구분 기호가있는 경우 패턴은 디렉토리와 만 일치하고 그렇지 않으면 패턴은 파일과 디렉토리 모두와 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e5e3b6d9186f0b0d9ca9ea83f70b7fee637fea2" translate="yes" xml:space="preserve">
          <source>If there is a separator, then the key will be used instead of both the &amp;lt;token&amp;gt; and the default separator when adding the trailer.</source>
          <target state="translated">구분 기호가있는 경우 트레일러를 추가 할 때 &amp;lt;토큰&amp;gt;과 기본 구분 기호 대신 키가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="110096af5aaaf08aca8aad30cdfe6c3abec7eaf2" translate="yes" xml:space="preserve">
          <source>If there is no file or subtree at that path, &lt;code&gt;git fast-import&lt;/code&gt; will instead report</source>
          <target state="translated">해당 경로에 파일이나 하위 트리가 없으면 &lt;code&gt;git fast-import&lt;/code&gt; 는 대신보고합니다.</target>
        </trans-unit>
        <trans-unit id="1db0218c6ea3cc08d2d45a6158a3df08d714812b" translate="yes" xml:space="preserve">
          <source>If there is no parameter given by the user, use &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">사용자가 제공 한 매개 변수가 없으면 &lt;code&gt;&amp;lt;arg&amp;gt;&lt;/code&gt; 를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="08079a827cded7daddc3f36e473048d3482101ec" translate="yes" xml:space="preserve">
          <source>If there is only one &amp;lt;tree-ish&amp;gt; given, the commit is compared with its parents (see --stdin below).</source>
          <target state="translated">&amp;lt;tree-ish&amp;gt;가 하나만 있으면 커밋이 부모와 비교됩니다 (아래 --stdin 참조).</target>
        </trans-unit>
        <trans-unit id="f3b2c7580e6489ea5e91cbe02a9f524e00ba7a5a" translate="yes" xml:space="preserve">
          <source>If there were more commits on the &lt;em&gt;master&lt;/em&gt; branch after the merge, the merge commit itself would not be shown by &lt;em&gt;git show-branch&lt;/em&gt; by default. You would need to provide &lt;code&gt;--sparse&lt;/code&gt; option to make the merge commit visible in this case.</source>
          <target state="translated">병합 후 &lt;em&gt;마스터&lt;/em&gt; 브랜치 에 더 많은 커밋이 있으면 병합 커밋 자체는 기본적으로 &lt;em&gt;git show-branch에&lt;/em&gt; 의해 &lt;em&gt;표시&lt;/em&gt; 되지 않습니다 . 이 경우 병합 커밋을 표시하려면 &lt;code&gt;--sparse&lt;/code&gt; 옵션 을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0ab64f384f8b476963c3f64ac176ef68ee6de9f2" translate="yes" xml:space="preserve">
          <source>If there were uncommitted worktree changes present when the merge started, &lt;code&gt;git merge --abort&lt;/code&gt; will in some cases be unable to reconstruct these changes. It is therefore recommended to always commit or stash your changes before running &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">병합이 시작될 때 커밋되지 않은 작업 트리 변경이있는 경우 &lt;code&gt;git merge --abort&lt;/code&gt; 는 이러한 변경을 재구성 할 수없는 경우가 있습니다. 따라서 &lt;code&gt;git merge&lt;/code&gt; 를 실행하기 전에 항상 변경 사항을 커밋하거나 숨기는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="967d5740c3c32e83504fdb7318f7465d81e3c6cb" translate="yes" xml:space="preserve">
          <source>If this atom is used in the output string, input lines are split at the first whitespace boundary. All characters before that whitespace are considered to be the object name; characters after that first run of whitespace (i.e., the &quot;rest&quot; of the line) are output in place of the &lt;code&gt;%(rest)&lt;/code&gt; atom.</source>
          <target state="translated">이 아톰이 출력 문자열에 사용되면 입력 행이 첫 번째 공백 경계에서 분할됩니다. 공백 앞에있는 모든 문자는 객체 이름으로 간주됩니다. 공백이 처음 실행 된 후의 문자 (즉, 줄의 &quot;rest&quot;)는 &lt;code&gt;%(rest)&lt;/code&gt; 원자 대신에 출력됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b6208e01f164e5f8b5cfeffb592a9b059f78c4e" translate="yes" xml:space="preserve">
          <source>If this attribute is not set or has an invalid value, the value of the &lt;code&gt;gui.encoding&lt;/code&gt; configuration variable is used instead (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">이 속성이 설정되지 않았거나 유효하지 않은 값을 가지고 있으면 &lt;code&gt;gui.encoding&lt;/code&gt; 구성 변수 의 값이 대신 사용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d21856ae35021bd75d04c1b344656e77c3e714d8" translate="yes" xml:space="preserve">
          <source>If this config variable is set, diff generation is not performed using the internal diff machinery, but using the given command. Can be overridden with the &amp;lsquo;GIT_EXTERNAL_DIFF&amp;rsquo; environment variable. The command is called with parameters as described under &quot;git Diffs&quot; in &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;. Note: if you want to use an external diff program only on a subset of your files, you might want to use &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; instead.</source>
          <target state="translated">이 구성 변수가 설정되면 내부 diff 기계를 사용하지 않고 주어진 명령을 사용하여 diff 생성이 수행됩니다. 'GIT_EXTERNAL_DIFF'환경 변수로 대체 할 수 있습니다. 이 명령은 &lt;a href=&quot;git&quot;&gt;git [1]의&lt;/a&gt; &quot;git Diffs&quot;에 설명 된대로 매개 변수와 함께 호출됩니다 . 참고 : 파일의 서브 세트에만 외부 diff 프로그램을 사용하려면 대신 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c67dbd9b5b9d0c250d594cf0e82ea55d38dac133" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to &quot;1&quot;, then commands such as &lt;code&gt;git blame&lt;/code&gt; (in incremental mode), &lt;code&gt;git rev-list&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt;, &lt;code&gt;git check-attr&lt;/code&gt; and &lt;code&gt;git check-ignore&lt;/code&gt; will force a flush of the output stream after each record have been flushed. If this variable is set to &quot;0&quot;, the output of these commands will be done using completely buffered I/O. If this environment variable is not set, Git will choose buffered or record-oriented flushing based on whether stdout appears to be redirected to a file or not.</source>
          <target state="translated">이 환경 변수가 &quot;1&quot;로 설정되면 &lt;code&gt;git blame&lt;/code&gt; (증분 모드), &lt;code&gt;git rev-list&lt;/code&gt; , &lt;code&gt;git log&lt;/code&gt; , &lt;code&gt;git check-attr&lt;/code&gt; 및 &lt;code&gt;git check-ignore&lt;/code&gt; 와 같은 명령 은 각각의 출력 스트림을 강제로 플러시합니다. 레코드가 플러시되었습니다. 이 변수가 &quot;0&quot;으로 설정되면 이러한 명령의 출력은 완전히 버퍼링 된 I / O를 사용하여 수행됩니다. 이 환경 변수를 설정하지 않으면 Git은 stdout이 파일로 리디렉션되는지 여부에 따라 버퍼링 또는 레코드 지향 플러싱을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="3c510f35b5c52541d7f8ff48371ed312cadc959c" translate="yes" xml:space="preserve">
          <source>If this environment variable is set to &lt;code&gt;0&lt;/code&gt;, git will not prompt on the terminal (e.g., when asking for HTTP authentication).</source>
          <target state="translated">이 환경 변수가 &lt;code&gt;0&lt;/code&gt; 으로 설정 되면 git은 터미널에 프롬프트를 표시하지 않습니다 (예 : HTTP 인증을 요청할 때).</target>
        </trans-unit>
        <trans-unit id="f0e0816f1f387058c1f2d75f7ff32a01f9295472" translate="yes" xml:space="preserve">
          <source>If this environment variable is set, it overrides Git&amp;rsquo;s autodetection whether &lt;code&gt;GIT_SSH&lt;/code&gt;/&lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt;/&lt;code&gt;core.sshCommand&lt;/code&gt; refer to OpenSSH, plink or tortoiseplink. This variable overrides the config setting &lt;code&gt;ssh.variant&lt;/code&gt; that serves the same purpose.</source>
          <target state="translated">이 환경 변수가 설정되면 &lt;code&gt;GIT_SSH&lt;/code&gt; / &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; / &lt;code&gt;core.sshCommand&lt;/code&gt; 가 OpenSSH, plink 또는 tortoiseplink를 참조 하는지 여부에 따라 Git의 자동 감지를 무시합니다 . 이 변수 는 동일한 목적을 수행하는 구성 설정 &lt;code&gt;ssh.variant&lt;/code&gt; 를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="81f782a4dbe0e346a4da365c1a6b3a9cbeb4a6e2" translate="yes" xml:space="preserve">
          <source>If this environment variable is set, then Git commands which need to acquire passwords or passphrases (e.g. for HTTP or IMAP authentication) will call this program with a suitable prompt as command-line argument and read the password from its STDOUT. See also the &lt;code&gt;core.askPass&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">이 환경 변수가 설정되면 비밀번호 또는 비밀번호 문구 (예 : HTTP 또는 IMAP 인증)를 가져와야하는 Git 명령은 적절한 프롬프트를 명령 행 인수로 사용하여이 프로그램을 호출하고 STDOUT에서 비밀번호를 읽습니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 &lt;code&gt;core.askPass&lt;/code&gt; 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="372352ecb2d8c55afffa99890c0eb497f2b1382d" translate="yes" xml:space="preserve">
          <source>If this feature is enabled, gitweb considers projects in subdirectories of project root (basename) to be forks of existing projects. For each project &lt;code&gt;$projname.git&lt;/code&gt;, projects in the &lt;code&gt;$projname/&lt;/code&gt; directory and its subdirectories will not be shown in the main projects list. Instead, a '+' mark is shown next to &lt;code&gt;$projname&lt;/code&gt;, which links to a &quot;forks&quot; view that lists all the forks (all projects in &lt;code&gt;$projname/&lt;/code&gt; subdirectory). Additionally a &quot;forks&quot; view for a project is linked from project summary page.</source>
          <target state="translated">이 기능이 활성화되면 gitweb은 프로젝트 루트 (기본 이름)의 하위 디렉토리에있는 프로젝트를 기존 프로젝트의 포크로 간주합니다. 각 프로젝트 &lt;code&gt;$projname.git&lt;/code&gt; 에 대해 &lt;code&gt;$projname/&lt;/code&gt; 디렉토리 의 프로젝트 와 해당 서브 디렉토리는 기본 프로젝트 목록에 표시되지 않습니다. 대신 &lt;code&gt;$projname&lt;/code&gt; 옆에 '+'표시가 표시됩니다.이 표시는 모든 포크 ( &lt;code&gt;$projname/&lt;/code&gt; 하위 디렉토리의 모든 프로젝트)를 나열하는 &quot;포크&quot;보기로 연결됩니다 . 또한 프로젝트의 &quot;포크&quot;보기는 프로젝트 요약 페이지에서 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="728d51c620f0870eff1b0d62261ab6934369adf2" translate="yes" xml:space="preserve">
          <source>If this field has a true value then the given feature is overridable, which means that it can be configured (or enabled/disabled) on a per-repository basis.</source>
          <target state="translated">이 필드에 실제 값이 있으면 지정된 기능을 재정의 할 수 있습니다. 즉, 리포지토리별로 구성 (또는 활성화 / 비활성화) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="582826e66f53339e6d7b4dc6a0d6a2edeb312487" translate="yes" xml:space="preserve">
          <source>If this file exists, $GIT_COMMON_DIR (see &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;) will be set to the path specified in this file if it is not explicitly set. If the specified path is relative, it is relative to $GIT_DIR. The repository with commondir is incomplete without the repository pointed by &quot;commondir&quot;.</source>
          <target state="translated">이 파일이 존재하면 $ GIT_COMMON_DIR ( &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 참조 )이 명시 적으로 설정되지 않은 경우이 파일에 지정된 경로로 설정됩니다. 지정된 경로가 상대 경로이면 $ GIT_DIR에 상대 경로입니다. commondir이있는 저장소는 &quot;commondir&quot;이 가리키는 저장소가 없으면 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="1e44552a87aaa0e818702548719ba07ebc0f8696" translate="yes" xml:space="preserve">
          <source>If this file exists, the linked working tree may be on a portable device and not available. The presence of this file prevents &lt;code&gt;worktrees/&amp;lt;id&amp;gt;&lt;/code&gt; from being pruned either automatically or manually by &lt;code&gt;git worktree prune&lt;/code&gt;. The file may contain a string explaining why the repository is locked.</source>
          <target state="translated">이 파일이 존재하면 연결된 작업 트리가 휴대용 장치에 있고 사용하지 못할 수 있습니다. 이 파일이 있으면 &lt;code&gt;git worktree prune&lt;/code&gt; 에 의해 &lt;code&gt;worktrees/&amp;lt;id&amp;gt;&lt;/code&gt; 가 자동 또는 수동으로 제거되지 않습니다 . 파일에는 리포지토리가 잠긴 이유를 설명하는 문자열이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6849302064fdf0db00fe326dd1a92636c39a6d43" translate="yes" xml:space="preserve">
          <source>If this hook exits with a non-zero status, &lt;code&gt;git push&lt;/code&gt; will abort without pushing anything. Information about why the push is rejected may be sent to the user by writing to standard error.</source>
          <target state="translated">이 후크가 0이 아닌 상태로 종료되면 &lt;code&gt;git push&lt;/code&gt; 는 아무 것도 누르지 않고 중단됩니다. 푸시가 거부 된 이유에 대한 정보는 표준 오류에 기록하여 사용자에게 전송 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e422a5c19027398b3db2e62a2dfa8c2a2031ac5" translate="yes" xml:space="preserve">
          <source>If this is reinitialization, the repository will be moved to the specified path.</source>
          <target state="translated">다시 초기화하는 경우 리포지토리가 지정된 경로로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="ae49e42c53a829e13a69befb7e448cbf7a3ab5aa" translate="yes" xml:space="preserve">
          <source>If this is set to code reference, it will be run once for each request. You can set parts of configuration that change per session this way. For example, one might use the following code in a gitweb configuration file</source>
          <target state="translated">이것이 코드 참조로 설정되면 각 요청마다 한 번씩 실행됩니다. 이 방법으로 세션마다 변경되는 구성 부분을 설정할 수 있습니다. 예를 들어, gitweb 구성 파일에서 다음 코드를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2ecaf4f8ea5745cd5a451b94ab44dd28ff120dab" translate="yes" xml:space="preserve">
          <source>If this is set to true, the &lt;code&gt;git stash show&lt;/code&gt; command without an option will show diffstat of the stash entry. Defaults to true. See description of &lt;code&gt;show&lt;/code&gt; command in &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">이것이 true로 설정되면 , 옵션이없는 &lt;code&gt;git stash show&lt;/code&gt; 명령은 숨김 항목의 diffstat를 표시합니다. 기본값은 true입니다. &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; 의 &lt;code&gt;show&lt;/code&gt; 명령 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee4998fa7e703962f55f3297f84fc3b952ae4a7f" translate="yes" xml:space="preserve">
          <source>If this is set to true, the &lt;code&gt;git stash show&lt;/code&gt; command without an option will show the stash entry in patch form. Defaults to false. See description of &lt;code&gt;show&lt;/code&gt; command in &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">이것이 true로 설정되면 , 옵션없이 &lt;code&gt;git stash show&lt;/code&gt; 명령은 숨김 항목을 패치 형식으로 표시합니다. 기본값은 false입니다. &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; 의 &lt;code&gt;show&lt;/code&gt; 명령 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e98f4c395c1b49b1de4c0111925dea856a6d079" translate="yes" xml:space="preserve">
          <source>If this is set, add emails found in Signed-off-by: or Cc: lines to the cc list. Default is the value of &lt;code&gt;sendemail.signedoffbycc&lt;/code&gt; configuration value; if that is unspecified, default to --signed-off-by-cc.</source>
          <target state="translated">이것이 설정되어 있으면 Signed-off-by :: 또는 Cc : 줄에있는 전자 메일을 참조 목록에 추가하십시오. 기본값은 &lt;code&gt;sendemail.signedoffbycc&lt;/code&gt; 구성 값입니다. 지정하지 않으면 기본값은 --signed-off-by-cc입니다.</target>
        </trans-unit>
        <trans-unit id="6cf7f20765eaeb225b14832d24072d63179e161f" translate="yes" xml:space="preserve">
          <source>If this is set, do not add the From: address to the cc: list. Default is the value of &lt;code&gt;sendemail.suppressFrom&lt;/code&gt; configuration value; if that is unspecified, default to --no-suppress-from.</source>
          <target state="translated">이것이 설정된 경우, From : 주소를 cc : 목록에 추가하지 마십시오. 기본값은 &lt;code&gt;sendemail.suppressFrom&lt;/code&gt; 구성 값입니다. 지정하지 않으면 기본값은 --no-suppress-from입니다.</target>
        </trans-unit>
        <trans-unit id="048d4528d0951754849879e2b4b5802f6461c9fb" translate="yes" xml:space="preserve">
          <source>If this is set, each email will be sent as a reply to the previous email sent. If disabled with &quot;--no-chain-reply-to&quot;, all emails after the first will be sent as replies to the first email sent. When using this, it is recommended that the first file given be an overview of the entire patch series. Disabled by default, but the &lt;code&gt;sendemail.chainReplyTo&lt;/code&gt; configuration variable can be used to enable it.</source>
          <target state="translated">이것이 설정되면 각 이메일은 이전에 전송 된 이메일에 대한 응답으로 전송됩니다. &quot;-체인 없음 회신&quot;으로 비활성화하면 첫 번째 전자 메일 이후의 모든 전자 메일이 첫 번째 전자 메일에 대한 회신으로 전송됩니다. 이것을 사용할 때, 주어진 첫 번째 파일은 전체 패치 시리즈의 개요 일 것을 권장합니다. 기본적으로 비활성화되어 있지만 &lt;code&gt;sendemail.chainReplyTo&lt;/code&gt; 구성 변수를 사용하여 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4073ff276c4f44294d676470e6aaaeb5a46458f" translate="yes" xml:space="preserve">
          <source>If this is set, emails found in Cc: headers in the first patch of the series (typically the cover letter) are added to the cc list for each email set. Default is the value of &lt;code&gt;sendemail.cccover&lt;/code&gt; configuration value; if that is unspecified, default to --no-cc-cover.</source>
          <target state="translated">이것이 설정되면 시리즈의 첫 번째 패치에서 Cc : 헤더에있는 이메일 (일반적으로 표지)이 각 이메일 세트의 cc 목록에 추가됩니다. 기본값은 &lt;code&gt;sendemail.cccover&lt;/code&gt; 구성 값입니다. 지정하지 않으면 기본값은 --no-cc-cover입니다.</target>
        </trans-unit>
        <trans-unit id="c3505cfc9a16fb3a406321b32681f1c27b3f4828" translate="yes" xml:space="preserve">
          <source>If this is set, emails found in To: headers in the first patch of the series (typically the cover letter) are added to the to list for each email set. Default is the value of &lt;code&gt;sendemail.tocover&lt;/code&gt; configuration value; if that is unspecified, default to --no-to-cover.</source>
          <target state="translated">이것이 설정되면 시리즈의 첫 번째 패치에있는 To : 헤더에있는 이메일 (일반적으로 표지)이 각 이메일 세트의받는 사람 목록에 추가됩니다. 기본값은 &lt;code&gt;sendemail.tocover&lt;/code&gt; 구성 값입니다. 지정되지 않은 경우 기본값은 --no-to-cover입니다.</target>
        </trans-unit>
        <trans-unit id="bd074611e2ce23fe3651c7c21615bc5d5c90b653" translate="yes" xml:space="preserve">
          <source>If this is set, the In-Reply-To and References headers will be added to each email sent. Whether each mail refers to the previous email (&lt;code&gt;deep&lt;/code&gt; threading per &lt;code&gt;git format-patch&lt;/code&gt; wording) or to the first email (&lt;code&gt;shallow&lt;/code&gt; threading) is governed by &quot;--[no-]chain-reply-to&quot;.</source>
          <target state="translated">이것이 설정되면 In-Reply-To 및 References 헤더가 전송 된 각 이메일에 추가됩니다. 각 메일이 이전 이메일 ( &lt;code&gt;git format-patch&lt;/code&gt; wording 당 &lt;code&gt;deep&lt;/code&gt; 스레딩 ) 또는 첫 번째 이메일 ( &lt;code&gt;shallow&lt;/code&gt; 스레딩)을 참조하는지 여부 는 &quot;-[no-] chain-reply-to&quot;에 의해 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="83fefd231faf2237df4d2ca57ddb91f5733dd174" translate="yes" xml:space="preserve">
          <source>If this option is also present in the submodules entry in .git/config of the superproject, the setting there will override the one found in .gitmodules.</source>
          <target state="translated">이 옵션이 수퍼 프로젝트의 .git / config에있는 서브 모듈 항목에도있는 경우, 설정은 .gitmodules에있는 설정보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="b576cec09f399abde10801d9e3b482a3974a7942" translate="yes" xml:space="preserve">
          <source>If this option is set, &lt;code&gt;upload-pack&lt;/code&gt; will support partial clone and partial fetch object filtering.</source>
          <target state="translated">이 옵션을 설정하면 &lt;code&gt;upload-pack&lt;/code&gt; 은 부분 복제 및 부분 가져 오기 객체 필터링을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="46df2747ed059ec465747bf23f6d93b6698f2ce3" translate="yes" xml:space="preserve">
          <source>If this option is set, &lt;code&gt;upload-pack&lt;/code&gt; will support the &lt;code&gt;ref-in-want&lt;/code&gt; feature of the protocol version 2 &lt;code&gt;fetch&lt;/code&gt; command. This feature is intended for the benefit of load-balanced servers which may not have the same view of what OIDs their refs point to due to replication delay.</source>
          <target state="translated">이 옵션을 설정하면 &lt;code&gt;upload-pack&lt;/code&gt; 은 프로토콜 버전 2 &lt;code&gt;fetch&lt;/code&gt; 명령 의 &lt;code&gt;ref-in-want&lt;/code&gt; 기능을 지원합니다 . 이 기능은 복제 지연으로 인해 참조가 가리키는 OID와 동일한보기를 갖지 않을 수있는로드 균형 조정 서버의 이점을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="3691063a71adef86ec77db2886b5e8b672228551" translate="yes" xml:space="preserve">
          <source>If this option is set, when &lt;code&gt;upload-pack&lt;/code&gt; would run &lt;code&gt;git pack-objects&lt;/code&gt; to create a packfile for a client, it will run this shell command instead. The &lt;code&gt;pack-objects&lt;/code&gt; command and arguments it &lt;code&gt;would&lt;/code&gt; have run (including the &lt;code&gt;git pack-objects&lt;/code&gt; at the beginning) are appended to the shell command. The stdin and stdout of the hook are treated as if &lt;code&gt;pack-objects&lt;/code&gt; itself was run. I.e., &lt;code&gt;upload-pack&lt;/code&gt; will feed input intended for &lt;code&gt;pack-objects&lt;/code&gt; to the hook, and expects a completed packfile on stdout.</source>
          <target state="translated">이 옵션을 설정하면 &lt;code&gt;upload-pack&lt;/code&gt; 이 &lt;code&gt;git pack-objects&lt;/code&gt; 를 실행하여 클라이언트에 대한 팩 파일 을 만들 때 대신이 셸 명령을 실행합니다. &lt;code&gt;pack-objects&lt;/code&gt; 명령과 그 인수 &lt;code&gt;would&lt;/code&gt; 합니다 (를 포함하여 실행 한 &lt;code&gt;git pack-objects&lt;/code&gt; 시작 부분) 쉘 명령에 추가됩니다. 후크의 stdin 및 stdout은 &lt;code&gt;pack-objects&lt;/code&gt; 자체가 실행 된 것처럼 처리됩니다 . 즉, &lt;code&gt;upload-pack&lt;/code&gt; 은 &lt;code&gt;pack-objects&lt;/code&gt; 용 입력 을 후크에 공급하고 stdout에서 완료된 packfile을 기대합니다.</target>
        </trans-unit>
        <trans-unit id="043d313af4e6bae8eb0dfe37d6ed595c4f6e4603" translate="yes" xml:space="preserve">
          <source>If this option is specified and &lt;code&gt;git svn&lt;/code&gt; encounters an SVN committer name that does not exist in the authors-file, &lt;code&gt;git svn&lt;/code&gt; will abort operation. The user will then have to add the appropriate entry. Re-running the previous &lt;code&gt;git svn&lt;/code&gt; command after the authors-file is modified should continue operation.</source>
          <target state="translated">이 옵션이 지정되고 &lt;code&gt;git svn&lt;/code&gt; 이 authors 파일에 존재하지 않는 SVN 커미터 이름을 발견하면 &lt;code&gt;git svn&lt;/code&gt; 은 작업을 중단합니다. 그런 다음 사용자는 적절한 항목을 추가해야합니다. authors-file을 수정 한 후 이전 &lt;code&gt;git svn&lt;/code&gt; 명령을 다시 실행하면 작업이 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="68c99ad12996bd9192637a1c1520fb2b24def75b" translate="yes" xml:space="preserve">
          <source>If this option is specified, for each SVN committer name that does not exist in the authors file, the given file is executed with the committer name as the first argument. The program is expected to return a single line of the form &quot;Name &amp;lt;email&amp;gt;&quot; or &quot;Name &amp;lt;&amp;gt;&quot;, which will be treated as if included in the authors file.</source>
          <target state="translated">이 옵션을 지정하면 authors 파일에 존재하지 않는 각 SVN 커미터 이름에 대해 지정된 파일이 첫 번째 인수로 커미터 이름과 함께 실행됩니다. 프로그램은 &quot;이름 &amp;lt;이메일&amp;gt;&quot;또는 &quot;이름 &amp;lt;&amp;gt;&quot;형식의 단일 행을 반환해야하며 이는 작성자 파일에 포함 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="9706c1068d7b5bd67656b65aa296c50f3e651323" translate="yes" xml:space="preserve">
          <source>If this variable is not specified, it defaults to &lt;code&gt;normal&lt;/code&gt;. This variable can be overridden with the -u|--untracked-files option of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="translated">이 변수를 지정하지 않으면 기본값은 &lt;code&gt;normal&lt;/code&gt; 입니다. 이 변수는 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 및 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 의 -u | --untracked-files 옵션으로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9b0cae3fed40383cf5d614f1da46a2c524e4930e" translate="yes" xml:space="preserve">
          <source>If this variable is set to &quot;1&quot;, &quot;2&quot; or &quot;true&quot; (comparison is case insensitive), trace messages will be printed to stderr.</source>
          <target state="translated">이 변수가 &quot;1&quot;, &quot;2&quot;또는 &quot;true&quot;로 설정되면 (비교는 대소 문자를 구분하지 않음) 추적 메시지가 stderr에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="c1357386502b4e540a41766c550326b57fc0ea56" translate="yes" xml:space="preserve">
          <source>If this variable is set to a path, non-worktree files that are normally in $GIT_DIR will be taken from this path instead. Worktree-specific files such as HEAD or index are taken from $GIT_DIR. See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; and &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt; for details. This variable has lower precedence than other path variables such as GIT_INDEX_FILE, GIT_OBJECT_DIRECTORY&amp;hellip;​</source>
          <target state="translated">이 변수가 경로로 설정되면 일반적으로 $ GIT_DIR에있는 비 작업 트리 파일이이 경로에서 가져옵니다. HEAD 또는 인덱스와 같은 워크 트리 특정 파일은 $ GIT_DIR에서 가져옵니다. 자세한 내용은 &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt; 및 &lt;a href=&quot;git-worktree&quot;&gt;git-worktree [1]&lt;/a&gt; 을 참조하십시오. 이 변수는 GIT_INDEX_FILE, GIT_OBJECT_DIRECTORY와 같은 다른 경로 변수보다 우선 순위가 낮습니다.</target>
        </trans-unit>
        <trans-unit id="8249d2ab5516fac15cd6ed908f0ba3c1a12338b5" translate="yes" xml:space="preserve">
          <source>If this variable is set, &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; will use the specified command instead of &lt;code&gt;ssh&lt;/code&gt; when they need to connect to a remote system. The command is in the same form as the &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; environment variable and is overridden when the environment variable is set.</source>
          <target state="translated">이 변수가 설정되면 &lt;code&gt;git fetch&lt;/code&gt; 및 &lt;code&gt;git push&lt;/code&gt; 는 원격 시스템에 연결해야 할 때 &lt;code&gt;ssh&lt;/code&gt; 대신 지정된 명령 을 사용합니다. 명령은 &lt;code&gt;GIT_SSH_COMMAND&lt;/code&gt; 환경 변수와 동일한 형식 이며 환경 변수가 설정되면 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="e4e675f6ba8abd4a71f30087b18137ff3c23311f" translate="yes" xml:space="preserve">
          <source>If this variable is set, the default hash algorithm for new repositories will be set to this value. This value is currently ignored when cloning; the setting of the remote repository is used instead. The default is &quot;sha1&quot;. THIS VARIABLE IS EXPERIMENTAL! See &lt;code&gt;--object-format&lt;/code&gt; in &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt;.</source>
          <target state="translated">이 변수가 설정되면 새 리포지토리의 기본 해시 알고리즘이이 값으로 설정됩니다. 이 값은 현재 복제시 무시됩니다. 대신 원격 저장소의 설정이 사용됩니다. 기본값은 &quot;sha1&quot;입니다. 이 변수는 실험적입니다! &lt;a href=&quot;git-init&quot;&gt;git-init [1]의 &lt;/a&gt; &lt;code&gt;--object-format&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3af55b279f11e2f816fa42fab0cbda45b206e1ef" translate="yes" xml:space="preserve">
          <source>If timestamps of commits in the CVS repository are not stable enough to be used for ordering commits changes may show up in the wrong order.</source>
          <target state="translated">CVS 저장소의 커밋 타임 스탬프가 커밋 순서를 정하기에 충분히 안정적이지 않으면 변경 사항이 잘못된 순서로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51615abc07df5f5fedb19397be1e475bae29e04c" translate="yes" xml:space="preserve">
          <source>If true (default), a single editor instance will be spawned to edit files you have to edit (patches when &lt;code&gt;--annotate&lt;/code&gt; is used, and the summary when &lt;code&gt;--compose&lt;/code&gt; is used). If false, files will be edited one after the other, spawning a new editor each time.</source>
          <target state="translated">(기본값) true의 경우, 하나의 에디터 인스턴스가 편집이 편집 파일에 양산 될 것입니다 (패치 때 &lt;code&gt;--annotate&lt;/code&gt; 가 사용되며, 요약하면 &lt;code&gt;--compose&lt;/code&gt; 이 사용된다). false 인 경우 파일이 하나씩 편집되어 매번 새 편집기가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6c99dc0ffc12cab74a91d9cd9821ddfe241990c4" translate="yes" xml:space="preserve">
          <source>If true prevents displaying information about repository owner.</source>
          <target state="translated">true이면 저장소 소유자에 대한 정보가 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fad7b766b28596874c184072e4308f81cec3bb8e" translate="yes" xml:space="preserve">
          <source>If true the web server started by &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; will be bound to the local IP (127.0.0.1).</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]에&lt;/a&gt; 의해 시작된 웹 서버 는 로컬 IP (127.0.0.1)에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="24fc21f99a5940a5b287a59503e7df044758b9be" translate="yes" xml:space="preserve">
          <source>If true this repository is assumed to be &lt;code&gt;bare&lt;/code&gt; and has no working directory associated with it. If this is the case a number of commands that require a working directory will be disabled, such as &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; or &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;.</source>
          <target state="translated">true 인 경우이 저장소는 &lt;code&gt;bare&lt;/code&gt; 것으로 간주되며 연관된 작업 디렉토리가 없습니다. 이 경우 작업 디렉토리가 필요한 여러 명령 (예 : &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1])&lt;/a&gt; 이 비활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="18d14681f32fdc08f62b0e7a189d6a89008757fd" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;git gui blame&lt;/code&gt; uses &lt;code&gt;-C&lt;/code&gt; instead of &lt;code&gt;-C -C&lt;/code&gt; for original location detection. It makes blame significantly faster on huge repositories at the expense of less thorough copy detection.</source>
          <target state="translated">true 인 경우 &lt;code&gt;git gui blame&lt;/code&gt; 은 원래 위치 감지 에 &lt;code&gt;-C -C&lt;/code&gt; 대신 &lt;code&gt;-C&lt;/code&gt; 를 사용합니다 . 덜 철저한 사본 탐지를 희생시키면서 대규모 리포지토리에 대한 책임이 훨씬 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="a4dc06197e1e60c2601c1eee394ecb56132cf3c4" translate="yes" xml:space="preserve">
          <source>If true, Git will avoid using lstat() calls to detect if files have changed by setting the &quot;assume-unchanged&quot; bit for those tracked files which it has updated identically in both the index and working tree.</source>
          <target state="translated">true 인 경우, Git은 lstat () 호출을 사용하여 인덱스와 작업 트리에서 동일하게 업데이트 된 추적 된 파일에 대해 &quot;가정되지 않은&quot;비트를 설정하여 파일이 변경되었는지 감지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f52d8aadd1ed60dd80b38e7a96aadc385cabb931" translate="yes" xml:space="preserve">
          <source>If true, Git will warn you if the ref name you passed it is ambiguous and might match multiple refs in the repository. True by default.</source>
          <target state="translated">true 인 경우 Git은 전달한 참조 이름이 모호하고 저장소의 여러 참조와 일치 할 경우 경고합니다. 기본적으로 true입니다.</target>
        </trans-unit>
        <trans-unit id="b4f1cbcb9d6580097e1319f75786e1aefcc4a19a" translate="yes" xml:space="preserve">
          <source>If true, allow clients to use &lt;code&gt;git archive --remote&lt;/code&gt; to request any tree, whether reachable from the ref tips or not. See the discussion in the &quot;SECURITY&quot; section of &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive[1]&lt;/a&gt; for more details. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">참이면 클라이언트가 참조 팁에서 도달 가능한지 여부에 관계없이 클라이언트가 &lt;code&gt;git archive --remote&lt;/code&gt; 를 사용 하여 트리를 요청할 수 있습니다. 자세한 내용은 &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive [1]&lt;/a&gt; 의 &quot;보안&quot;섹션에있는 토론 을 참조하십시오. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9577d8134a35c2d555845d35ede1972ec309a7fc" translate="yes" xml:space="preserve">
          <source>If true, enable &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; for use by remote clients via &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive[1]&lt;/a&gt;. Defaults to false for user-defined formats, but true for the &quot;tar.gz&quot; and &quot;tgz&quot; formats.</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive [1]을&lt;/a&gt; 통해 원격 클라이언트가 사용하도록 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 을 활성화하십시오 . 사용자 정의 형식의 경우 기본값은 false이지만 &quot;tar.gz&quot;및 &quot;tgz&quot;형식의 경우 true입니다.</target>
        </trans-unit>
        <trans-unit id="5f15956c2db32b4b1b45dac474661942b8aa7008" translate="yes" xml:space="preserve">
          <source>If true, fetch will automatically behave as if the &lt;code&gt;--prune&lt;/code&gt; option was given on the command line. See also &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; and the PRUNING section of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">true이면 fetch는 &lt;code&gt;--prune&lt;/code&gt; 옵션이 명령 줄에 제공된 것처럼 자동으로 작동합니다 . &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; 및 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 의 PRUNING 섹션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d985f4709f0d26edc0babef707e65f833d349aa" translate="yes" xml:space="preserve">
          <source>If true, fetch will automatically behave as if the &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; refspec was provided when pruning, if not set already. This allows for setting both this option and &lt;code&gt;fetch.prune&lt;/code&gt; to maintain a 1=1 mapping to upstream refs. See also &lt;code&gt;remote.&amp;lt;name&amp;gt;.pruneTags&lt;/code&gt; and the PRUNING section of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">true 인 경우, 가져 오기는 정리되지 않은 경우 &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; refspec이 제공된 것처럼 자동으로 작동합니다 . 이를 통해이 옵션과 &lt;code&gt;fetch.prune&lt;/code&gt; 을 설정 하여 업스트림 참조에 1 = 1 매핑을 유지할 수 있습니다. &lt;code&gt;remote.&amp;lt;name&amp;gt;.pruneTags&lt;/code&gt; 및 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 의 PRUNING 섹션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2de6ae2b37da0c5dc299e33fe86fea1c6d9d4a0f" translate="yes" xml:space="preserve">
          <source>If true, git-am will call git-mailsplit for patches in mbox format with parameter &lt;code&gt;--keep-cr&lt;/code&gt;. In this case git-mailsplit will not remove &lt;code&gt;\r&lt;/code&gt; from lines ending with &lt;code&gt;\r\n&lt;/code&gt;. Can be overridden by giving &lt;code&gt;--no-keep-cr&lt;/code&gt; from the command line. See &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;, &lt;a href=&quot;git-mailsplit&quot;&gt;git-mailsplit[1]&lt;/a&gt;.</source>
          <target state="translated">true 인 경우 git-am은 매개 변수 &lt;code&gt;--keep-cr&lt;/code&gt; 을 사용하여 mbox 형식의 패치에 대해 git-mailsplit을 호출 합니다. 이 경우 git-mailsplit은 &lt;code&gt;\r\n&lt;/code&gt; 끝나는 줄에서 &lt;code&gt;\r&lt;/code&gt; 을 제거하지 않습니다 . 명령 줄에서 &lt;code&gt;--no-keep-cr&lt;/code&gt; 을 지정하여 재정의 할 수 있습니다 . 참조 &lt;a href=&quot;git-am&quot;&gt;자식-오전 [1]&lt;/a&gt; , &lt;a href=&quot;git-mailsplit&quot;&gt;자식-mailsplit [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e94bf962607289b1694c70432d3fab451c61737d" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt; assume &lt;code&gt;--abbrev-commit&lt;/code&gt;. You may override this option with &lt;code&gt;--no-abbrev-commit&lt;/code&gt;.</source>
          <target state="translated">true이면 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 및 &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt; 이 &lt;code&gt;--abbrev-commit&lt;/code&gt; 을 가정 합니다. 이 옵션을 &lt;code&gt;--no-abbrev-commit&lt;/code&gt; 으로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7c96ef3a79b38b8c56dee4db799ed4d172ce90c" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt; assume &lt;code&gt;--show-signature&lt;/code&gt;.</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 및 &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt; 이 &lt;code&gt;--show-signature&lt;/code&gt; 로 가정 합니다 .</target>
        </trans-unit>
        <trans-unit id="6cb33eaf81fb27f3c3d3ba0e81d6670ba0d0bfaf" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, and &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt; assume &lt;code&gt;--use-mailmap&lt;/code&gt;, otherwise assume &lt;code&gt;--no-use-mailmap&lt;/code&gt;. True by default.</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 및 &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt; 이 &lt;code&gt;--use-mailmap&lt;/code&gt; 을 , 그렇지 않으면 &lt;code&gt;--no-use-mailmap&lt;/code&gt; 을 가정 합니다. 기본적으로 true입니다.</target>
        </trans-unit>
        <trans-unit id="672cef13127670a717c7a3aa65681a15ad776d1b" translate="yes" xml:space="preserve">
          <source>If true, makes &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt; (and therefore &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;) act by default as if the --scissors option was provided on the command-line. When active, this features removes everything from the message body before a scissors line (i.e. consisting mainly of &quot;&amp;gt;8&quot;, &quot;8&amp;lt;&quot; and &quot;-&quot;).</source>
          <target state="translated">true 인 경우 --scissors 옵션이 명령 행에 제공된 것처럼 &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo [1]&lt;/a&gt; (및 &lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt; )가 기본적으로 작동합니다. 활성화되면이 기능은 가위 선 이전의 메시지 본문에서 모든 것을 제거합니다 (예 : 주로 &quot;&amp;gt; 8&quot;, &quot;8 &amp;lt;&quot;및 &quot;-&quot;로 구성).</target>
        </trans-unit>
        <trans-unit id="d25b510a17b04a17cfbdc40d0999d1586f4d5f91" translate="yes" xml:space="preserve">
          <source>If true, makes Git check if converting &lt;code&gt;CRLF&lt;/code&gt; is reversible when end-of-line conversion is active. Git will verify if a command modifies a file in the work tree either directly or indirectly. For example, committing a file followed by checking out the same file should yield the original file in the work tree. If this is not the case for the current setting of &lt;code&gt;core.autocrlf&lt;/code&gt;, Git will reject the file. The variable can be set to &quot;warn&quot;, in which case Git will only warn about an irreversible conversion but continue the operation.</source>
          <target state="translated">참이면 줄 끝 변환이 활성화되어있을 때 &lt;code&gt;CRLF&lt;/code&gt; 변환 이 되돌릴 수 있는지 Git에서 확인합니다 . Git은 명령이 작업 트리에서 파일을 직접 또는 간접적으로 수정하는지 확인합니다. 예를 들어, 파일을 커밋 한 다음 동일한 파일을 체크 아웃하면 작업 트리에 원본 파일이 생성됩니다. 이것이 &lt;code&gt;core.autocrlf&lt;/code&gt; 의 현재 설정이 아닌 경우 Git은 파일을 거부합니다. 변수는 &quot;경고&quot;로 설정 될 수 있으며,이 경우 Git은 되돌릴 수없는 변환에 대해서만 경고하지만 작업을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="3a6f979740fe111373346b7083b54b9e059af003" translate="yes" xml:space="preserve">
          <source>If true, omit the column with date of the most current commit on the projects list page. It can save a bit of I/O and a fork per repository.</source>
          <target state="translated">true 인 경우 프로젝트 목록 페이지에서 최신 커밋 날짜가있는 열을 생략하십시오. 리포지토리 당 약간의 I / O 및 포크를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e101a02df349b50a39b60288665a643391bcf24" translate="yes" xml:space="preserve">
          <source>If true, pushing to this remote will automatically behave as if the &lt;code&gt;--mirror&lt;/code&gt; option was given on the command line.</source>
          <target state="translated">true 인 경우이 리모콘을 누르면 &lt;code&gt;--mirror&lt;/code&gt; 옵션이 명령 행에 제공된 것처럼 자동으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="561edb27b58ccdfdecb1aae75865de22935f3cd3" translate="yes" xml:space="preserve">
          <source>If true, some gitweb features are disabled to prevent content in repositories from launching cross-site scripting (XSS) attacks. Set this to true if you don&amp;rsquo;t trust the content of your repositories. False by default (set to 0).</source>
          <target state="translated">true 인 경우 리포지토리의 콘텐츠가 XSS (Cross-Site Scripting) 공격을 시작하지 못하도록 일부 gitweb 기능이 비활성화됩니다. 리포지토리의 내용을 신뢰할 수없는 경우이를 true로 설정하십시오. 기본적으로 False입니다 (0으로 설정).</target>
        </trans-unit>
        <trans-unit id="698e5f4a0ab76eb97600c890fa9adac3c5e93fa4" translate="yes" xml:space="preserve">
          <source>If true, the initial commit will be shown as a big creation event. This is equivalent to a diff against an empty tree. Tools like &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; or &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;, which normally hide the root commit will now show it. True by default.</source>
          <target state="translated">true 인 경우 초기 커밋은 큰 생성 이벤트로 표시됩니다. 이것은 빈 트리에 대한 diff와 같습니다. 일반적으로 루트 커밋을 숨기는 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]&lt;/a&gt; 과 같은 도구 가 이제이를 표시합니다. 기본적으로 true입니다.</target>
        </trans-unit>
        <trans-unit id="7f4771e5273a3a0e51423699c29e2caf790623f9" translate="yes" xml:space="preserve">
          <source>If true, the server will look up the end-of-line conversion attributes for files to determine the &lt;code&gt;-k&lt;/code&gt; modes to use. If the attributes force Git to treat a file as text, the &lt;code&gt;-k&lt;/code&gt; mode will be left blank so CVS clients will treat it as text. If they suppress text conversion, the file will be set with &lt;code&gt;-kb&lt;/code&gt; mode, which suppresses any newline munging the client might otherwise do. If the attributes do not allow the file type to be determined, then &lt;code&gt;gitcvs.allBinary&lt;/code&gt; is used. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;.</source>
          <target state="translated">true 인 경우, 서버는 사용할 &lt;code&gt;-k&lt;/code&gt; 모드를 결정하기 위해 파일의 라인 끝 변환 속성을 찾습니다 . 속성으로 인해 Git이 파일을 텍스트로 취급하면, &lt;code&gt;-k&lt;/code&gt; 모드는 비워져 CVS 클라이언트는 파일을 텍스트 로 취급합니다. 텍스트 변환을 억제하면 파일이 &lt;code&gt;-kb&lt;/code&gt; 모드 로 설정되어 클라이언트가 수행 할 수있는 줄 바꿈을 억제합니다. 속성으로 파일 유형을 결정할 수 &lt;code&gt;gitcvs.allBinary&lt;/code&gt; 가 사용됩니다. &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="36ac6e641c359be495ff334484c92173e0b7c3c8" translate="yes" xml:space="preserve">
          <source>If true, the split-index feature of the index will be used. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;. False by default.</source>
          <target state="translated">참이면 인덱스의 분할 인덱스 기능이 사용됩니다. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]를&lt;/a&gt; 참조하십시오 . 기본적으로 False입니다.</target>
        </trans-unit>
        <trans-unit id="521397cd2bc3f328c7b75df2807813cd34103bfb" translate="yes" xml:space="preserve">
          <source>If true, then gc will rewrite the commit-graph file when &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; is run. When using &lt;code&gt;git gc --auto&lt;/code&gt; the commit-graph will be updated if housekeeping is required. Default is true. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt; for details.</source>
          <target state="translated">true이면, &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt; 이 실행될 때 gc는 commit-graph 파일을 다시 작성합니다 . &lt;code&gt;git gc --auto&lt;/code&gt; 를 사용할 때 커밋 그래프는 하우스 키핑이 필요한 경우 업데이트됩니다. 기본값은 true입니다. 자세한 내용은 &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="902fdcf00401d2e7de222ff42ce846a756cbb163" translate="yes" xml:space="preserve">
          <source>If true, then git will read the commit-graph file (if it exists) to parse the graph structure of commits. Defaults to true. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt; for more information.</source>
          <target state="translated">true이면, git은 commit-graph 파일 (존재하는 경우)을 읽어 commit의 그래프 구조를 구문 분석합니다. 기본값은 true입니다. 자세한 내용은 &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca076926e8bbfce2f59c8069a39ed42dca4bb470" translate="yes" xml:space="preserve">
          <source>If true, then git will use the changed-path Bloom filters in the commit-graph file (if it exists, and they are present). Defaults to true. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt; for more information.</source>
          <target state="translated">참이면 git은 commit-graph 파일에서 변경된 경로 Bloom 필터를 사용합니다 (존재하고있는 경우). 기본값은 true입니다. 자세한 내용은 &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="615bfb2827e0f7022b5822b60fa7f8c63365efe6" translate="yes" xml:space="preserve">
          <source>If true, this is equivalent to the --verify-signatures command line option. See &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; for details.</source>
          <target state="translated">true 인 경우 --verify-signatures 명령 줄 옵션과 같습니다. 자세한 내용은 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5ab6fd64e80cf040c0dbc59c3bda45e3cb1c29b3" translate="yes" xml:space="preserve">
          <source>If true, this remote will be skipped by default when updating using &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; or the &lt;code&gt;update&lt;/code&gt; subcommand of &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;.</source>
          <target state="translated">true 인 경우 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; 의 &lt;code&gt;update&lt;/code&gt; 부속 명령을 사용하여 업데이트 할 때이 원격은 기본적으로 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="537153cdd9a230b7ef7748cee5c002a80aec5646" translate="yes" xml:space="preserve">
          <source>If we compute the following non optimal function on it:</source>
          <target state="translated">다음과 같은 비 최적 함수를 계산하면 :</target>
        </trans-unit>
        <trans-unit id="b2bbf437e467ca2cfec5d122277b398062cce56a" translate="yes" xml:space="preserve">
          <source>If we examined all this history together in one repository, it will look like:</source>
          <target state="translated">하나의 저장소에서이 모든 히스토리를 함께 조사하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f77fa3523026c17c64002e6f77dd7e18ad8c7cf7" translate="yes" xml:space="preserve">
          <source>If we have moved away from commit &lt;code&gt;f&lt;/code&gt;, then we must first recover its object name (typically by using git reflog), and then we can create a reference to it. For example, to see the last two commits to which &lt;code&gt;HEAD&lt;/code&gt; referred, we can use either of these commands:</source>
          <target state="translated">commit &lt;code&gt;f&lt;/code&gt; 에서 멀어지면 먼저 객체 이름을 복구해야하며 (일반적으로 git reflog를 사용하여) 객체에 대한 참조를 만들 수 있습니다. 예를 들어 &lt;code&gt;HEAD&lt;/code&gt; 가 참조한 마지막 두 커밋을 보려면 다음 명령 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d5fb2a96e98dbf044763df4f4d84c289b1a7a1e" translate="yes" xml:space="preserve">
          <source>If we look at the way commits are created under the cover, we&amp;rsquo;ll see that there are more flexible ways creating commits.</source>
          <target state="translated">커버 아래에서 커밋이 생성되는 방식을 살펴보면 커밋을 만드는 더 유연한 방법이 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a7aed1833634138d2979858dc472c551054c3f5" translate="yes" xml:space="preserve">
          <source>If we need to talk about a particular commit, the character &quot;o&quot; may be replaced with another letter or number.</source>
          <target state="translated">특정 커밋에 대해 이야기해야 할 경우 문자 &quot;o&quot;는 다른 문자 나 숫자로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73117dc442919d58c7658111f0e65fc3ffc2d92d" translate="yes" xml:space="preserve">
          <source>If width is &lt;code&gt;0&lt;/code&gt; (zero) then indent the lines of the output without wrapping them.</source>
          <target state="translated">너비가 &lt;code&gt;0&lt;/code&gt; 이면 출력 줄을 줄 바꿈없이 들여 씁니다.</target>
        </trans-unit>
        <trans-unit id="a0f8f4ea612137fd1324a3c99aa8cca8319d30d8" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;+&lt;/code&gt; (plus sign) after &lt;code&gt;%&lt;/code&gt; of a placeholder, a line-feed is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string.</source>
          <target state="translated">플레이스 홀더의 &lt;code&gt;%&lt;/code&gt; 뒤에 &lt;code&gt;+&lt;/code&gt; (더하기 부호) 를 추가 하면 플레이스 홀더가 비어 있지 않은 문자열로 확장되는 경우에만 확장 직전에 라인 피드가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="f83e564943919127dff3b2d8ad2099402ce321cb" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;-&lt;/code&gt; (minus sign) after &lt;code&gt;%&lt;/code&gt; of a placeholder, all consecutive line-feeds immediately preceding the expansion are deleted if and only if the placeholder expands to an empty string.</source>
          <target state="translated">자리 표시 자 &lt;code&gt;%&lt;/code&gt; 뒤에 &lt;code&gt;-&lt;/code&gt; (빼기 부호) 를 추가 하면 자리 표시자가 빈 문자열로 확장되는 경우에만 확장 바로 앞의 모든 연속 줄 바꿈이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="a78fb3b12f14b3649d1e2f03162a9771701e268a" translate="yes" xml:space="preserve">
          <source>If you add a ` ` (space) after &lt;code&gt;%&lt;/code&gt; of a placeholder, a space is inserted immediately before the expansion if and only if the placeholder expands to a non-empty string.</source>
          <target state="translated">자리 표시 자 &lt;code&gt;%&lt;/code&gt; 뒤에``(공백)를 추가 하면 자리 표시자가 비어 있지 않은 문자열로 확장되는 경우에만 확장 바로 앞에 공백이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="2c694abd299e141b455acf195b0e2c24045c8fb9" translate="yes" xml:space="preserve">
          <source>If you allow overriding for the snapshot feature, you can specify which snapshot formats are globally disabled. You can also add any command-line options you want (such as setting the compression level). For instance, you can disable Zip compressed snapshots and set &lt;strong&gt;gzip&lt;/strong&gt;(1) to run at level 6 by adding the following lines to your gitweb configuration file:</source>
          <target state="translated">스냅 샷 기능에 대한 재정의를 허용하면 전역 적으로 비활성화 할 스냅 샷 형식을 지정할 수 있습니다. 압축 수준 설정과 같은 원하는 명령 줄 옵션을 추가 할 수도 있습니다. 예를 들어, gitweb 구성 파일에 다음 행을 추가하여 Zip 압축 스냅 샷을 비활성화하고 &lt;strong&gt;gzip&lt;/strong&gt; (1)을 레벨 6에서 실행하도록 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1eda80bb2b9aeb620d19886733f7a0a33613b07f" translate="yes" xml:space="preserve">
          <source>If you already use &lt;code&gt;mod_userdir&lt;/code&gt; in your virtual host or you don&amp;rsquo;t want to use the '~' as first character, just comment or remove the second rewrite rule, and uncomment one of the following according to what you want.</source>
          <target state="translated">가상 호스트에서 이미 &lt;code&gt;mod_userdir&lt;/code&gt; 을 사용하거나 '~'를 첫 문자로 사용하지 않으려면 두 번째 다시 쓰기 규칙에 주석을 달거나 제거하고 원하는 내용에 따라 다음 중 하나의 주석을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="28aab4433d981c882862a14d41ff2a1b6ecf68f5" translate="yes" xml:space="preserve">
          <source>If you also want to see complete diffs at each step, use</source>
          <target state="translated">각 단계에서 완전한 차이점을 보려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cc8e02bd7d5fd8efba31a3f28960e44c003964ed" translate="yes" xml:space="preserve">
          <source>If you and the maintainer both have accounts on the same machine, then you can just pull changes from each other&amp;rsquo;s repositories directly; commands that accept repository URLs as arguments will also accept a local directory name:</source>
          <target state="translated">관리자와 관리자가 모두 같은 컴퓨터에 계정을 가지고 있다면 서로의 리포지토리에서 직접 변경 사항을 가져올 수 있습니다. 저장소 URL을 인수로 허용하는 명령은 로컬 디렉토리 이름도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="41ebdd5e935074b399d696e8dc1f4204152e3f63" translate="yes" xml:space="preserve">
          <source>If you are a contributor that sends changes upstream in the form of emails, you should use topic branches as usual (see above). Then use &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; to generate the corresponding emails (highly recommended over manually formatting them because it makes the maintainer&amp;rsquo;s life easier).</source>
          <target state="translated">이메일 형태로 변경 사항을 업스트림으로 보내는 기고자 인 경우 평소와 같이 주제 분기를 사용해야합니다 (위 참조). 그런 다음 &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; 를 사용하여 해당 이메일을 생성하십시오 (관리자가보다 쉽게 ​​사용할 수 있으므로 수동으로 포맷하는 것보다 강력하게 권장 됨).</target>
        </trans-unit>
        <trans-unit id="f7586aada4dc4dabc26450bca6e988967f6c8334" translate="yes" xml:space="preserve">
          <source>If you are a maintainer and would like to merge other people&amp;rsquo;s topic branches to the integration branches, they will typically send a request to do so by mail. Such a request looks like</source>
          <target state="translated">관리자 인 경우 다른 사람의 주제 분기를 통합 분기에 병합하려는 경우 일반적으로 우편으로 요청을 보냅니다. 이러한 요청은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="6a4170b1f048a116a2a20a0123a6634648180f67" translate="yes" xml:space="preserve">
          <source>If you are coming from a CVS background, the style of cooperation suggested in the previous section may be new to you. You do not have to worry. Git supports the &quot;shared public repository&quot; style of cooperation you are probably more familiar with as well.</source>
          <target state="translated">CVS 배경에서 온다면 이전 섹션에서 제안한 협력 스타일이 새로운 것일 수 있습니다. 당신은 걱정할 필요가 없습니다. Git은 &quot;공유 공용 저장소&quot;스타일의 협업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d473d9569ed7194445a9c66a5a376371d037be9a" translate="yes" xml:space="preserve">
          <source>If you are creating a branch that you want to switch to immediately, it is easier to use the &quot;git switch&quot; command with its &lt;code&gt;-c&lt;/code&gt; option to do the same thing with a single command.</source>
          <target state="translated">즉시 전환하려는 분기를 작성하는 경우, &quot;git switch&quot;명령을 &lt;code&gt;-c&lt;/code&gt; 옵션과 함께 사용하여 단일 명령으로 동일한 작업을 수행하는 것이 더 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="882d5e43cce8c196ac8e463999e712ea9e114942" translate="yes" xml:space="preserve">
          <source>If you are following somebody else&amp;rsquo;s tree, you are most likely using remote-tracking branches (eg. &lt;code&gt;refs/remotes/origin/master&lt;/code&gt;). You usually want the tags from the other end.</source>
          <target state="translated">다른 사람의 나무를 따르는 경우 원격 추적 분기를 사용하는 것 같습니다 (예 : &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; ). 일반적으로 다른 쪽 끝의 태그를 원합니다.</target>
        </trans-unit>
        <trans-unit id="0f51d0b61f348c2beb156a534ba33bcb5f141385" translate="yes" xml:space="preserve">
          <source>If you are going to offer CVS access via pserver, add a line in /etc/inetd.conf like</source>
          <target state="translated">pserver를 통해 CVS 액세스를 제공하려는 경우 /etc/inetd.conf에 다음과 같은 행을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e1c58ac4057b121c58f1f5681f07adc3f2f06c66" translate="yes" xml:space="preserve">
          <source>If you are instead primarily interested in using Git to fetch a project, for example, to test the latest version, you may prefer to start with the first two chapters of &lt;a href=&quot;user-manual&quot;&gt;The Git User&amp;rsquo;s Manual&lt;/a&gt;.</source>
          <target state="translated">대신 Git을 사용하여 프로젝트를 가져 와서 최신 버전을 테스트하는 데 주로 관심이 있다면 &lt;a href=&quot;user-manual&quot;&gt;Git 사용 설명서의&lt;/a&gt; 첫 두 장으로 시작하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9ce35cf81da423ef90a67288a1d702b7e25d4c6b" translate="yes" xml:space="preserve">
          <source>If you are interested in more details of the revision walking process, just have a look at the first implementation of &lt;code&gt;cmd_log()&lt;/code&gt;; call &lt;code&gt;git show v1.3.0&lt;sub&gt;155^2&lt;/sub&gt;4&lt;/code&gt; and scroll down to that function (note that you no longer need to call &lt;code&gt;setup_pager()&lt;/code&gt; directly).</source>
          <target state="translated">수정 보행 프로세스에 대한 자세한 내용을 &lt;code&gt;cmd_log()&lt;/code&gt; 의 첫 번째 구현을 살펴보십시오 . &lt;code&gt;git show v1.3.0&lt;sub&gt;155^2&lt;/sub&gt;4&lt;/code&gt; 호출 하고 해당 함수까지 아래로 스크롤하십시오 (더 이상 &lt;code&gt;setup_pager()&lt;/code&gt; 직접 호출 할 필요는 없습니다 ).</target>
        </trans-unit>
        <trans-unit id="9ac179f42cb3351e666e44e39b35f145be521392" translate="yes" xml:space="preserve">
          <source>If you are interested in more details of the revision walking process, just have a look at the first implementation of &lt;code&gt;cmd_log()&lt;/code&gt;; call &lt;code&gt;git show v1.3.0~155^2~4&lt;/code&gt; and scroll down to that function (note that you no longer need to call &lt;code&gt;setup_pager()&lt;/code&gt; directly).</source>
          <target state="translated">리비전 워킹 프로세스에 대해 더 자세히 &lt;code&gt;cmd_log()&lt;/code&gt; 의 첫 번째 구현을 살펴보십시오 . 전화 &lt;code&gt;git show v1.3.0~155^2~4&lt;/code&gt; 및 그 기능에 아래로 스크롤 (참고 호출에 더 이상 필요하지 &lt;code&gt;setup_pager()&lt;/code&gt; 직접).</target>
        </trans-unit>
        <trans-unit id="a5b0f41c084141a75721908d0d5d7971792ac89f" translate="yes" xml:space="preserve">
          <source>If you are not absolutely sure that the intermediate revisions are consistent (they compile, pass the testsuite, etc.) you should use &lt;code&gt;git stash&lt;/code&gt; to stash away the not-yet-committed changes after each commit, test, and amend the commit if fixes are necessary.</source>
          <target state="translated">중간 개정이 일관성이 있는지 확실하지 않은 경우 (컴파일, 테스트 슈트 등 전달) &lt;code&gt;git stash&lt;/code&gt; 를 사용 하여 각 커밋, 테스트 후 수정되지 않은 경우 아직 커밋되지 않은 변경 사항을 제거해야합니다. 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f188b17d328d7a9e1b61bcc0d2e0defbbf399561" translate="yes" xml:space="preserve">
          <source>If you are only interested in changes of the currently initialized submodules with respect to the commit recorded in the index or the HEAD, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; and &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; will provide that information too (and can also report changes to a submodule&amp;rsquo;s work tree).</source>
          <target state="translated">인덱스 또는 HEAD에 기록 된 커밋과 관련하여 현재 초기화 된 서브 모듈의 변경에만 관심이있는 경우 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 및 &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 도 해당 정보를 제공합니다 (또한 변경 사항을 하위 모듈의 작업 트리).</target>
        </trans-unit>
        <trans-unit id="9fb9a58a453e5ac1de19a98e53575241a40d1da0" translate="yes" xml:space="preserve">
          <source>If you are paranoid, running &lt;code&gt;git verify-pack&lt;/code&gt; command would detect if you have a corrupt pack, but do not worry too much. Our programs are always perfect ;-).</source>
          <target state="translated">편집증이라면 &lt;code&gt;git verify-pack&lt;/code&gt; 명령을 실행 하면 손상된 팩이 있는지 감지하지만 너무 걱정하지 마십시오. 우리의 프로그램은 항상 완벽합니다 ;-).</target>
        </trans-unit>
        <trans-unit id="277e03057ecd44d387d6f501d21982d9ff59224b" translate="yes" xml:space="preserve">
          <source>If you are repacking very old imported data (e.g. older than the last year), consider expending some extra CPU time and supplying --window=50 (or higher) when you run &lt;code&gt;git repack&lt;/code&gt;. This will take longer, but will also produce a smaller packfile. You only need to expend the effort once, and everyone using your project will benefit from the smaller repository.</source>
          <target state="translated">아주 오래된 가져온 데이터를 다시 포장하는 경우 (예 : 작년보다 오래된) &lt;code&gt;git repack&lt;/code&gt; 을 실행할 때 추가 CPU 시간을 연장하고 --window = 50 (또는 그 이상)을 제공하는 것을 고려하십시오 . 시간이 오래 걸리지 만 더 작은 팩 파일이 생성됩니다. 한 번만 노력하면되므로 프로젝트를 사용하는 모든 사람은 소규모 저장소를 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c500814f6020ec6c3d1c5a9b455910ea7fc36da1" translate="yes" xml:space="preserve">
          <source>If you are using &quot;git bisect run&quot;, you can use the same manual fix up as above, and then start another &quot;git bisect run&quot; in the special branch. Or as the &quot;git bisect&quot; man page says, the script passed to &quot;git bisect run&quot; can apply a patch before it compiles and test the software &lt;a href=&quot;#8&quot;&gt;[8]&lt;/a&gt;. The patch should turn a current untestable commits into a testable one. So the testing will result in &quot;good&quot; or &quot;bad&quot; and &quot;git bisect&quot; will be able to find the first bad commit. And the script should not forget to remove the patch once the testing is done before exiting from the script.</source>
          <target state="translated">&quot;git bisect run&quot;을 사용하는 경우 위와 동일한 수동 수정을 사용한 다음 특수 분기에서 다른 &quot;git bisect run&quot;을 시작할 수 있습니다. 또는 &quot;git bisect&quot;매뉴얼 페이지에서 알 수 있듯이 &quot;git bisect run&quot;에 전달 된 스크립트는 소프트웨어를 컴파일하고 테스트하기 전에 패치를 적용 할 수 있습니다 &lt;a href=&quot;#8&quot;&gt;[8]&lt;/a&gt; . 패치는 현재 테스트 할 수없는 커밋을 테스트 가능한 커밋으로 바꿔야합니다. 따라서 테스트 결과 &quot;good&quot;또는 &quot;bad&quot;가 발생하고 &quot;git bisect&quot;는 첫 번째 잘못된 커밋을 찾을 수 있습니다. 스크립트는 스크립트에서 나가기 전에 테스트가 끝나면 패치를 제거하는 것을 잊지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="c6c0585fbbb0e19d850e67091effac179b4cf010" translate="yes" xml:space="preserve">
          <source>If you blow the index away entirely, you generally haven&amp;rsquo;t lost any information as long as you have the name of the tree that it described.</source>
          <target state="translated">색인을 완전히 없애 버린 경우 일반적으로 설명 된 트리의 이름이있는 한 정보가 손실되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d2eeeb68a563ca60a2c585f75afbad9b4a5940e" translate="yes" xml:space="preserve">
          <source>If you both have a test suite and use git bisect, then it becomes less important to check that all tests pass after each commit. Though of course it is probably a good idea to have some checks to avoid breaking too many things because it could make bisecting other bugs more difficult.</source>
          <target state="translated">둘 다 테스트 스위트가 있고 git bisect를 사용하는 경우 각 커밋 후에 모든 테스트가 통과하는지 확인하는 것이 중요하지 않습니다. 물론 너무 많은 것들을 깨뜨리지 않기 위해 몇 가지 검사를하는 것이 좋은 생각 일 것입니다. 다른 버그를 더 잘 분별하기 어렵 기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="7c966eb4fc191c72371d7ddd65b21062f03ccb57" translate="yes" xml:space="preserve">
          <source>If you can do that, you can now recreate the missing object with</source>
          <target state="translated">그렇게 할 수 있다면 다음과 같이 누락 된 개체를 다시 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c6e6ccfdc26bd491d9ed428be6d535f807a44d7" translate="yes" xml:space="preserve">
          <source>If you choose to wait for the repack, don&amp;rsquo;t try to run benchmarks or performance tests until repacking is completed. fast-import outputs suboptimal packfiles that are simply never seen in real use situations.</source>
          <target state="translated">재 포장을 기다리도록 선택한 경우 재 포장이 완료 될 때까지 벤치 마크 또는 성능 테스트를 실행하지 마십시오. 빠른 가져 오기는 실제 사용 상황에서는 절대 볼 수없는 차선책 팩 파일을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="db9a66177c2b117d0740a2ed1a511dcc1bea6811" translate="yes" xml:space="preserve">
          <source>If you decide that you&amp;rsquo;d rather see version 2.6.17, you can modify the current branch to point at v2.6.17 instead, with</source>
          <target state="translated">버전 2.6.17을보고자한다면 대신 현재 분기를 v2.6.17을 가리 키도록 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c943de9e92fabf055b174eed9b10ced62cf6d401" translate="yes" xml:space="preserve">
          <source>If you decide you want the history back, you can always create a new reference pointing to it, for example, a new branch:</source>
          <target state="translated">히스토리를 다시 사용하기로 결정한 경우 언제든지이를 가리키는 새 참조 (예 : 새 분기)를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f288af5e76ef5a4f231f5810c9960b284e03991" translate="yes" xml:space="preserve">
          <source>If you develop on a branch crazy-idea, then regret it, you can always delete the branch with</source>
          <target state="translated">미친 미친 아이디어에서 개발했다면 후회한다면 언제든지 다음과 같이 분기를 삭제할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6d7822c644d713e2101d339a30a68a502f988e1b" translate="yes" xml:space="preserve">
          <source>If you didn&amp;rsquo;t specify the CVSROOT/CVS_SERVER directly in the checkout command, automatically saving it in your &lt;code&gt;CVS/Root&lt;/code&gt; files, then you need to set them explicitly in your environment. CVSROOT should be set as per normal, but the directory should point at the appropriate Git repo. As above, for SSH clients &lt;code&gt;not&lt;/code&gt; restricted to &lt;code&gt;git-shell&lt;/code&gt;, CVS_SERVER should be set to &lt;code&gt;git-cvsserver&lt;/code&gt;.</source>
          <target state="translated">checkout 명령에서 CVSROOT / CVS_SERVER를 직접 지정하지 않고 &lt;code&gt;CVS/Root&lt;/code&gt; 파일 에 자동으로 저장 한 경우 환경에서 명시 적으로 설정해야합니다. CVSROOT는 정상적으로 설정해야하지만 디렉토리는 적절한 Git 저장소를 가리켜 야합니다. 위와 같이 SSH 클라이언트 가 &lt;code&gt;git-shell&lt;/code&gt; 로 제한 &lt;code&gt;not&lt;/code&gt; 경우 CVS_SERVER는 &lt;code&gt;git-cvsserver&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="467e5efa7fe7a25688df5c19177b2c4b9a971487" translate="yes" xml:space="preserve">
          <source>If you discover that you made a mistake in specifying the status of a revision, you can save the output of this command to a file, edit it to remove the incorrect entries, and then issue the following commands to return to a corrected state:</source>
          <target state="translated">개정 상태를 잘못 지정한 경우,이 명령의 출력을 파일로 저장하고 편집하여 잘못된 항목을 제거한 후 다음 명령을 실행하여 정정 된 상태로 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdb535b3114700ba9158b47e1cadbbb4ffee0391" translate="yes" xml:space="preserve">
          <source>If you do merge, note the following rule: &lt;code&gt;git svn dcommit&lt;/code&gt; will attempt to commit on top of the SVN commit named in</source>
          <target state="translated">병합하는 경우 다음 규칙에 유의하십시오. &lt;code&gt;git svn dcommit&lt;/code&gt; 은에서 명명 된 SVN 커밋 위에 커밋을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="d7d53a76c809507d4642710878a2561fe720cf02" translate="yes" xml:space="preserve">
          <source>If you do not have &lt;code&gt;mod_rewrite&lt;/code&gt; available to match against the query string, it is sufficient to just protect &lt;code&gt;git-receive-pack&lt;/code&gt; itself, like:</source>
          <target state="translated">쿼리 문자열과 비교할 수 있는 &lt;code&gt;mod_rewrite&lt;/code&gt; 가없는 경우 다음 과 같이 &lt;code&gt;git-receive-pack&lt;/code&gt; 자체를 보호하는 것으로 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="61817ad83cf40051c64b68562493dd77ca2fe6f8" translate="yes" xml:space="preserve">
          <source>If you do not have this configuration variable, the value of &lt;code&gt;i18n.commitEncoding&lt;/code&gt; is used instead.</source>
          <target state="translated">이 구성 변수가없는 경우 &lt;code&gt;i18n.commitEncoding&lt;/code&gt; 값이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="14f3fbb24beba0c7fa85b6385a5b3979968f4593" translate="yes" xml:space="preserve">
          <source>If you do not know the encoding of a file, then you can use the &lt;code&gt;file&lt;/code&gt; command to guess the encoding:</source>
          <target state="translated">파일의 인코딩을 모르는 경우 &lt;code&gt;file&lt;/code&gt; 명령을 사용 하여 인코딩을 추측 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="371074e4db6e9a2527bbe63c09ef576231a57ee5" translate="yes" xml:space="preserve">
          <source>If you do not want this feature on your server just remove the second rewrite rule.</source>
          <target state="translated">서버에서이 기능을 원하지 않으면 두 번째 다시 쓰기 규칙을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="b68a865397b0b847cde7a3d94bca4e3b8a2b1c61" translate="yes" xml:space="preserve">
          <source>If you do not want to lose your work (history from X to B) or the work by the other person (history from X to A), you would need to first fetch the history from the repository, create a history that contains changes done by both parties, and push the result back.</source>
          <target state="translated">작업 (X에서 B 로의 히스토리) 또는 다른 사람의 작업 (X에서 A 로의 히스토리)을 잃지 않으려면 먼저 저장소에서 히스토리를 가져 와서 변경 사항이 포함 된 히스토리를 작성해야합니다. 양 당사자에 의해 결과를 다시 밀어 넣습니다.</target>
        </trans-unit>
        <trans-unit id="86c596eda084e162303624098fd515841984d889" translate="yes" xml:space="preserve">
          <source>If you do this, then you should make a public announcement indicating that &lt;code&gt;next&lt;/code&gt; was rewound and rebuilt.</source>
          <target state="translated">이렇게하면 &lt;code&gt;next&lt;/code&gt; 이 되감기 고 재건 되었음을 알리는 공개 발표를해야 합니다.</target>
        </trans-unit>
        <trans-unit id="325a3c2222e4d4aaa5c937ccab45f34c95352c49" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to continue with that right away, a few other digressions that may be interesting at this point are:</source>
          <target state="translated">지금 당장 계속하고 싶지 않다면이 시점에서 흥미로운 몇 가지 다른 위반 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf36326b8dfc35954574299040bce7c304964cb4" translate="yes" xml:space="preserve">
          <source>If you enable PATH_INFO usage in gitweb by putting</source>
          <target state="translated">gitweb에서 PATH_INFO 사용을 활성화하면</target>
        </trans-unit>
        <trans-unit id="3e267e16654424679545d579a56c2fc25a567700" translate="yes" xml:space="preserve">
          <source>If you examine the file &lt;code&gt;.git/config&lt;/code&gt;, you will see that Git has added a new stanza:</source>
          <target state="translated">&lt;code&gt;.git/config&lt;/code&gt; 파일을 살펴보면 Git이 새로운 스탠자를 추가 한 것을 볼 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="adaf459f23d870ce117760016108b7b8ca67ba63" translate="yes" xml:space="preserve">
          <source>If you examine the resulting commit using gitk, you will see that it has two parents, one pointing to the top of the current branch, and one to the top of the other branch.</source>
          <target state="translated">gitk를 사용하여 결과 커밋을 검사하면 현재 분기의 상단을 가리키는 부모와 다른 분기의 상단을 가리키는 부모가 두 개 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f87315138be947ec0afa0ac1351920e4dfe2a0c2" translate="yes" xml:space="preserve">
          <source>If you find some reason to set this option to &lt;code&gt;false&lt;/code&gt;, other than one-off testing, you should report the behavior difference as a bug in Git (see &lt;a href=&quot;https://git-scm.com/community&quot;&gt;https://git-scm.com/community&lt;/a&gt; for details).</source>
          <target state="translated">일회성 테스트 이외 의이 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정 해야하는 이유가 있는 경우 동작 차이를 Git의 버그로보고해야합니다 (자세한 내용은 &lt;a href=&quot;https://git-scm.com/community&quot;&gt;https://git-scm.com/community&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="bbcb62743d9f0aa650833d05c94c3e3db4eb4e0d" translate="yes" xml:space="preserve">
          <source>If you find you forked off the wrong branch and want to move it &quot;back in time&quot;, use &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">잘못된 브랜치를 분리하고 &quot;시간으로&quot;이동 시키려면 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]을 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12cef549aa55079a651285c652b78bc4bc8af80c" translate="yes" xml:space="preserve">
          <source>If you find you need new features from the branch &lt;code&gt;other&lt;/code&gt; to continue working on your topic, merge &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;topic&lt;/code&gt;. (However, do not do this &quot;just habitually&quot;, see below.)</source>
          <target state="translated">당신이 지점에서 새로운 기능이 필요 발견하면 &lt;code&gt;other&lt;/code&gt; 사용자의 주제에 대한 작업을 계속할 병합 &lt;code&gt;other&lt;/code&gt; 에 &lt;code&gt;topic&lt;/code&gt; . (단, &quot;임상 적으로&quot;하지 마십시오. 아래를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="c89cdceb268014744fee40998409a87331a70cef" translate="yes" xml:space="preserve">
          <source>If you followed the last paragraph, you will now have many small topic branches, and occasionally wonder how they interact. Perhaps the result of merging them does not even work? But on the other hand, we want to avoid merging them anywhere &quot;stable&quot; because such merges cannot easily be undone.</source>
          <target state="translated">마지막 단락을 따르면 작은 주제 분기가 많이 생겨서 때로는 어떻게 상호 작용하는지 궁금해합니다. 아마도 병합 결과가 작동하지 않습니까? 그러나 다른 한편으로는 이러한 병합은 쉽게 취소 할 수 없기 때문에 &quot;안정된&quot;위치에 병합하는 것을 피하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="f8ccc691fa447494e794dd8643eee96c05ab0ca5" translate="yes" xml:space="preserve">
          <source>If you get stuck and decide to just give up and throw the whole mess away, you can always return to the pre-merge state with</source>
          <target state="translated">당신이 붙어서 그냥 엉망으로 전체 쓰레기를 버려하기로 결정하면, 당신은 항상 합병 전 상태로 돌아갈 수 있습니다</target>
        </trans-unit>
        <trans-unit id="8d7c02e3dd22e344be3301eb8a2278c07f5b614c" translate="yes" xml:space="preserve">
          <source>If you grasp the ideas in that initial commit, you should check out a more recent version and skim &lt;code&gt;cache.h&lt;/code&gt;, &lt;code&gt;object.h&lt;/code&gt; and &lt;code&gt;commit.h&lt;/code&gt;.</source>
          <target state="translated">초기 커밋에서 아이디어를 파악하면 최신 버전을 확인하고 &lt;code&gt;cache.h&lt;/code&gt; , &lt;code&gt;object.h&lt;/code&gt; 및 &lt;code&gt;commit.h&lt;/code&gt; 을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="b91c4875b14e285ca788a5bd5edf75dfcd9633ab" translate="yes" xml:space="preserve">
          <source>If you have a clone of git.git itself, the output of &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; can show you the authors for specific parts of the project.</source>
          <target state="translated">git.git 자체의 복제본이있는 경우 &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]&lt;/a&gt; 및 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; 의 출력으로 프로젝트의 특정 부분에 대한 작성자를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d76da65add1ab668fa52a438912f17a42719fc64" translate="yes" xml:space="preserve">
          <source>If you have a repository where all the branches of interest exist as subdirectories of a single depot path, you can use &lt;code&gt;--detect-branches&lt;/code&gt; when cloning or syncing to have &lt;code&gt;git p4&lt;/code&gt; automatically find subdirectories in p4, and to generate these as branches in Git.</source>
          <target state="translated">관심있는 모든 브랜치가 단일 저장소 경로의 서브 디렉토리로 존재하는 저장소가있는 경우, 복제 또는 동기화시 &lt;code&gt;--detect-branches&lt;/code&gt; 를 사용 하여 &lt;code&gt;git p4&lt;/code&gt; 가 p4에서 서브 디렉토리를 자동으로 찾고이를 Git에서 브랜치로 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a6081c46922db10b6bc6f47a7f76b221a6196d2" translate="yes" xml:space="preserve">
          <source>If you have a script that can tell if the current source code is good or bad, you can bisect by issuing the command:</source>
          <target state="translated">현재 소스 코드가 좋은지 나쁜지를 알 수있는 스크립트가있는 경우 다음 명령을 실행하여 이등분 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="863f4e57810f45268a83fecc8614e1be7d434564" translate="yes" xml:space="preserve">
          <source>If you have added attributes to a file that cause the canonical repository format for that file to change, such as adding a clean/smudge filter or text/eol/ident attributes, merging anything where the attribute is not in place would normally cause merge conflicts.</source>
          <target state="translated">정리 / 스머지 필터 또는 텍스트 / Eol / ident 속성 추가와 같이 해당 파일의 표준 저장소 형식이 변경되도록하는 속성을 파일에 추가 한 경우 속성이없는 위치를 병합하면 일반적으로 병합 충돌이 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="0176ab2e378e3df6f1e24b7af5113bcd1e2d5987" translate="yes" xml:space="preserve">
          <source>If you have an old Git that does not understand the version 2 &lt;code&gt;*.idx&lt;/code&gt; file, cloning or fetching over a non native protocol (e.g. &quot;http&quot;) that will copy both &lt;code&gt;*.pack&lt;/code&gt; file and corresponding &lt;code&gt;*.idx&lt;/code&gt; file from the other side may give you a repository that cannot be accessed with your older version of Git. If the &lt;code&gt;*.pack&lt;/code&gt; file is smaller than 2 GB, however, you can use &lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack[1]&lt;/a&gt; on the *.pack file to regenerate the &lt;code&gt;*.idx&lt;/code&gt; file.</source>
          <target state="translated">버전 2 &lt;code&gt;*.idx&lt;/code&gt; 파일을 이해하지 못하는 오래된 Git이있는 경우 &lt;code&gt;*.pack&lt;/code&gt; 파일과 해당 &lt;code&gt;*.idx&lt;/code&gt; 파일을 다른 쪽에서 복사하는 비 기본 프로토콜 (예 : &quot;http&quot;)을 통해 복제하거나 가져 오는 경우 이전 버전의 Git으로 액세스 할 수없는 저장소를 제공 할 수 있습니다. 는 IF &lt;code&gt;*.pack&lt;/code&gt; 의 파일 2 GB보다 작은, 그러나, 당신이 사용할 수있는 &lt;a href=&quot;git-index-pack&quot;&gt;자식 인덱스 팩 [1]를&lt;/a&gt; 재생성하기 위해 * .pack 파일을 &lt;code&gt;*.idx&lt;/code&gt; 파일을.</target>
        </trans-unit>
        <trans-unit id="1c4d7bfb0f77357b6cf0e14e83f75e3ad3892e2a" translate="yes" xml:space="preserve">
          <source>If you have an unfortunate branch that is named &lt;code&gt;hello.c&lt;/code&gt;, this step would be confused as an instruction to switch to that branch. You should instead write:</source>
          <target state="translated">&lt;code&gt;hello.c&lt;/code&gt; 라는 불행한 분기가있는 경우이 단계는 해당 분기로 전환하라는 지시로 혼동됩니다. 대신 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="6748330dc78a7c7da8f6ed8d92c497a5f2638cdd" translate="yes" xml:space="preserve">
          <source>If you have imported some changes from another VCS and would like to add tags for major releases of your work, it is useful to be able to specify the date to embed inside of the tag object; such data in the tag object affects, for example, the ordering of tags in the gitweb interface.</source>
          <target state="translated">다른 VCS에서 일부 변경 사항을 가져오고 작업의 주요 릴리스에 대한 태그를 추가하려는 경우 태그 오브젝트에 임베드 할 날짜를 지정할 수 있습니다. 태그 객체의 이러한 데이터는 예를 들어 gitweb 인터페이스의 태그 순서에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="d87d691ee6c65f8321e66034d85f79793605b8a9" translate="yes" xml:space="preserve">
          <source>If you have local modifications to one or more files that are different between the current branch and the branch to which you are switching, the command refuses to switch branches in order to preserve your modifications in context. However, with this option, a three-way merge between the current branch, your working tree contents, and the new branch is done, and you will be on the new branch.</source>
          <target state="translated">현재 분기와 전환하려는 분기간에 다른 하나 이상의 파일을 로컬로 수정 한 경우 명령은 컨텍스트에서 수정 사항을 보존하기 위해 분기 전환을 거부합니다. 그러나이 옵션을 사용하면 현재 분기, 작업 트리 내용 및 새 분기간에 3 방향 병합이 수행되고 새 분기에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="8478bf298413f91bee793cf9d5101299eaa200bd" translate="yes" xml:space="preserve">
          <source>If you have multifactor authentication setup on your gmail account, you will need to generate an app-specific password for use with &lt;code&gt;git send-email&lt;/code&gt;. Visit &lt;a href=&quot;https://security.google.com/settings/security/apppasswords&quot;&gt;https://security.google.com/settings/security/apppasswords&lt;/a&gt; to create it.</source>
          <target state="translated">Gmail 계정에 다단계 인증을 설정 한 경우 &lt;code&gt;git send-email&lt;/code&gt; 과 함께 사용하려면 앱 비밀번호를 생성해야합니다 . &lt;a href=&quot;https://security.google.com/settings/security/apppasswords&quot;&gt;https://security.google.com/settings/security/apppasswords&lt;/a&gt; 를 방문 하여 만드십시오.</target>
        </trans-unit>
        <trans-unit id="a8709177c278b5c18333d173ba933d08e65c6841" translate="yes" xml:space="preserve">
          <source>If you have some initial content (say, a tarball):</source>
          <target state="translated">초기 내용이 있다면 (예 : 타르볼) :</target>
        </trans-unit>
        <trans-unit id="495e5ec3bcea1de47c24c2073588d5c3b0cf061c" translate="yes" xml:space="preserve">
          <source>If you have these three &lt;code&gt;gitattributes&lt;/code&gt; file:</source>
          <target state="translated">다음 세 가지 &lt;code&gt;gitattributes&lt;/code&gt; 파일이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="8c8ea948fec03c8051df6ee29e66dada48224b15" translate="yes" xml:space="preserve">
          <source>If you have uncommitted changes in your submodule working tree, &lt;code&gt;git
submodule update&lt;/code&gt; will not overwrite them. Instead, you get the usual warning about not being able switch from a dirty branch.</source>
          <target state="translated">서브 모듈 작업 트리에서 커밋되지 않은 변경 사항이 있으면 &lt;code&gt;git submodule update&lt;/code&gt; 가 덮어 쓰지 않습니다. 대신 더티 브랜치에서 전환 할 수 없다는 일반적인 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4ccda3cb1e710a989feb173887174c1818fd9d4a" translate="yes" xml:space="preserve">
          <source>If you intend that your next commit should record all modifications of tracked files in the working tree and record all removals of files that have been removed from the working tree with &lt;code&gt;rm&lt;/code&gt; (as opposed to &lt;code&gt;git rm&lt;/code&gt;), use &lt;code&gt;git commit -a&lt;/code&gt;, as it will automatically notice and record all removals. You can also have a similar effect without committing by using &lt;code&gt;git add -u&lt;/code&gt;.</source>
          <target state="translated">다음 커밋이 작업 트리에서 추적 된 파일의 모든 수정 사항을 기록하고 &lt;code&gt;rm&lt;/code&gt; 을 사용하여 작업 트리에서 제거 된 모든 파일 제거를 기록 하려면 ( &lt;code&gt;git rm&lt;/code&gt; 과 반대 ) &lt;code&gt;git commit -a&lt;/code&gt; 를 사용하십시오. 모든 제거를 자동으로 인식하고 기록합니다. &lt;code&gt;git add -u&lt;/code&gt; 를 사용하여 커밋하지 않고도 비슷한 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5223949abb561108f8606da60ebd3c3b78a9872c" translate="yes" xml:space="preserve">
          <source>If you intend to set up a shared public repository that all developers can read/write, or if you want to use &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;, then you probably want to make a bare clone of the imported repository, and use the clone as the shared repository. See &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">모든 개발자가 읽고 쓸 수있는 공유 공용 저장소를 설정하려는 경우 또는 &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt; 을 사용하려는 경우 가져온 저장소의 베어 복제본을 작성하고 복제본을 다음과 같이 사용하려고합니다. 공유 리포지토리 &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e8fe75eb0be8caf3b1c84cce78f8d98c5c3831c" translate="yes" xml:space="preserve">
          <source>If you just have a few changes, the simplest way to submit them may just be to send them as patches in email:</source>
          <target state="translated">몇 가지 변경 사항이있는 경우 제출하는 가장 간단한 방법은 변경 사항을 이메일로 패치로 보내는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c3509063d9c8d28fc350d64af9974d7f7ad07d9f" translate="yes" xml:space="preserve">
          <source>If you just need to use Git as a revision control system you may prefer to start with &quot;A Tutorial Introduction to Git&quot; (&lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt;) or &lt;a href=&quot;user-manual&quot;&gt;the Git User Manual&lt;/a&gt;.</source>
          <target state="translated">수정 제어 시스템으로 Git을 사용해야하는 경우 &quot;Git에 대한 자습서 소개&quot;( &lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]&lt;/a&gt; ) 또는 &lt;a href=&quot;user-manual&quot;&gt;Git 사용자 매뉴얼로 시작하는 것이&lt;/a&gt; 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6a839fbf210e306e2136c31f2a968baa357075d1" translate="yes" xml:space="preserve">
          <source>If you just want to edit the commit message for a commit, replace the command &quot;pick&quot; with the command &quot;reword&quot;.</source>
          <target state="translated">커밋에 대한 커밋 메시지를 편집하려면 &quot;pick&quot;명령을 &quot;reword&quot;명령으로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="1a22bf44debddb2b1654740b48fdcb88c27e49eb" translate="yes" xml:space="preserve">
          <source>If you just want to get the newest copies of the integration branches, staying up to date is easy too:</source>
          <target state="translated">통합 분기의 최신 사본을 얻으려면 최신 상태를 유지하는 것도 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="5a13a90084d33cb33125eb2c50fff6e07ce8c0d9" translate="yes" xml:space="preserve">
          <source>If you just want to look at an old version of the file, without modifying the working directory, you can do that with &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;:</source>
          <target state="translated">작업 디렉토리를 수정하지 않고 파일의 이전 버전을 &lt;a href=&quot;git-show&quot;&gt;보려면 git-show [1]으로&lt;/a&gt; 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5af7e34f55f5a635b889f9cb9a1ef742b6e402c4" translate="yes" xml:space="preserve">
          <source>If you just want to run git as if it was started in &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; then use &lt;code&gt;git -C &amp;lt;path&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 에서 시작된 것처럼 git을 실행 하려면 &lt;code&gt;git -C &amp;lt;path&amp;gt;&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="68f30cb563d71e3909ec492d5d34c92facf1030b" translate="yes" xml:space="preserve">
          <source>If you just want to verify whether a given tagged version contains a given commit, you could use &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt;:</source>
          <target state="translated">주어진 태그 버전에 주어진 커밋이 포함되어 있는지 확인하려면 &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base [1]&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8a6261ebe4a4d52d4d9a2234a54f319605d4abc" translate="yes" xml:space="preserve">
          <source>If you keep your primary branches immediately under &lt;code&gt;refs/heads&lt;/code&gt;, and topic branches in subdirectories of it, having the following in the configuration file may help:</source>
          <target state="translated">기본 분기를 &lt;code&gt;refs/heads&lt;/code&gt; 바로 아래에 두고 하위 분기의 주제 분기를 구성하는 경우 구성 파일에 다음이 있으면 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="933889a0268ded50e3304543b4e7167783337a6d" translate="yes" xml:space="preserve">
          <source>If you know beforehand more than one good commit, you can narrow the bisect space down by specifying all of the good commits immediately after the bad commit when issuing the &lt;code&gt;bisect start&lt;/code&gt; command:</source>
          <target state="translated">사전에 둘 이상의 양호한 커밋을 알고있는 경우 &lt;code&gt;bisect start&lt;/code&gt; 명령을 실행할 때 잘못된 커밋 직후에 모든 올바른 커밋을 지정하여 bisect 공간을 좁힐 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d0efb22e26170e5f6a2a2c939fcf419b948a8aa" translate="yes" xml:space="preserve">
          <source>If you know up to what commit the intended recipient repository should have the necessary objects, you can use that knowledge to specify the basis, giving a cut-off point to limit the revisions and objects that go in the resulting bundle. The previous example used the lastR2bundle tag for this purpose, but you can use any other options that you would give to the &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; command. Here are more examples:</source>
          <target state="translated">의도 된 수신자 저장소에 필요한 오브젝트가 있어야하는 확약을 아는 경우 해당 지식을 사용하여 기준을 지정하여 결과 번들에 포함 된 개정 및 오브젝트를 제한하는 컷오프 지점을 제공 할 수 있습니다. 이전 예제에서는 이러한 목적으로 lastR2bundle 태그를 사용했지만 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 명령에 제공하는 다른 옵션을 사용할 수 있습니다 . 더 많은 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6178dcf6380091f437345048b81ae6acd9e3fdb2" translate="yes" xml:space="preserve">
          <source>If you leave out the commit name, &lt;code&gt;git grep&lt;/code&gt; will search any of the files it manages in your current directory. So</source>
          <target state="translated">커밋 이름을 생략하면 &lt;code&gt;git grep&lt;/code&gt; 은 현재 디렉토리에서 관리하는 파일을 검색합니다. 그래서</target>
        </trans-unit>
        <trans-unit id="1d3a773743dd2af35a158be46f7bad29aaa6f592" translate="yes" xml:space="preserve">
          <source>If you like to live dangerously, you can replace &lt;strong&gt;all&lt;/strong&gt; core.gitproxy by a new one with</source>
          <target state="translated">위험한 생활을 원한다면 &lt;strong&gt;모든&lt;/strong&gt; core.gitproxy를 새로운 것으로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bff9b22c3bcd9cedd5449471391b1cdf79647bb" translate="yes" xml:space="preserve">
          <source>If you make a commit and then find a mistake immediately after that, you can recover from it with &lt;code&gt;git reset&lt;/code&gt;.</source>
          <target state="translated">커밋을 한 다음 그 직후에 실수를 찾으면 &lt;code&gt;git reset&lt;/code&gt; 으로 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de1cbbe8d26471b895b54a3d07b205ed1595e0f4" translate="yes" xml:space="preserve">
          <source>If you make a commit that you later wish you hadn&amp;rsquo;t, there are two fundamentally different ways to fix the problem:</source>
          <target state="translated">나중에 원하지 않았던 커밋을하면 문제를 해결하는 근본적으로 다른 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="99ec09f13fb1346102b0f372f091bd234e630539" translate="yes" xml:space="preserve">
          <source>If you make it (very) clear that this branch is going to be deleted right after the testing, you can even publish this branch, for example to give the testers a chance to work with it, or other developers a chance to see if their in-progress work will be compatible. &lt;code&gt;git.git&lt;/code&gt; has such an official throw-away integration branch called &lt;code&gt;pu&lt;/code&gt;.</source>
          <target state="translated">테스트 직후에이 브랜치가 삭제 될 것임을 명확하게하면 (예 : 테스터에게 해당 브랜치와 함께 작업 할 수있는 기회를 제공하기 위해)이 브랜치를 게시하거나 다른 개발자에게 진행중인 작업이 호환됩니다. &lt;code&gt;git.git&lt;/code&gt; 에는 &lt;code&gt;pu&lt;/code&gt; 라는 공식적인 버림받은 통합 브랜치가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2711d396bb29a520681068259bdc58e0b9b32fcb" translate="yes" xml:space="preserve">
          <source>If you make it (very) clear that this branch is going to be deleted right after the testing, you can even publish this branch, for example to give the testers a chance to work with it, or other developers a chance to see if their in-progress work will be compatible. &lt;code&gt;git.git&lt;/code&gt; has such an official throw-away integration branch called &lt;code&gt;seen&lt;/code&gt;.</source>
          <target state="translated">이 브랜치가 테스트 직후 삭제 될 것임을 (매우) 명확하게 밝히면이 브랜치를 게시 할 수도 있습니다. 예를 들어 테스터에게 작업 할 수있는 기회를 제공하거나 다른 개발자에게 진행중인 작업이 호환됩니다. &lt;code&gt;git.git&lt;/code&gt; 에는 seen 이라는 공식 일회용 통합 브랜치가 &lt;code&gt;seen&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d532db8eaaa16fed286ca601d3c879ce0db79d29" translate="yes" xml:space="preserve">
          <source>If you make the decision to start your new branch at some other point in the history than the current &lt;code&gt;HEAD&lt;/code&gt;, you can do so by just telling &lt;code&gt;git checkout&lt;/code&gt; what the base of the checkout would be. In other words, if you have an earlier tag or branch, you&amp;rsquo;d just do</source>
          <target state="translated">현재 &lt;code&gt;HEAD&lt;/code&gt; 이외의 다른 지점에서 새 분기를 시작하기로 결정한 경우 &lt;code&gt;git checkout&lt;/code&gt; 에 결제 의 기준을 알려 주면 됩니다. 다시 말해, 이전에 태그 나 지점이 있다면</target>
        </trans-unit>
        <trans-unit id="9f31f9c748a9e0ffbef8f11bc85a6ff4ec5b3e8d" translate="yes" xml:space="preserve">
          <source>If you make the decision to start your new branch at some other point in the history than the current &lt;code&gt;HEAD&lt;/code&gt;, you can do so by just telling &lt;code&gt;git switch&lt;/code&gt; what the base of the checkout would be. In other words, if you have an earlier tag or branch, you&amp;rsquo;d just do</source>
          <target state="translated">현재 &lt;code&gt;HEAD&lt;/code&gt; 이외의 다른 지점에서 새 브랜치를 시작하기로 결정했다면 &lt;code&gt;git switch&lt;/code&gt; 에게 체크 아웃의 기반이 무엇인지 알려 주면 됩니다. 즉, 이전 태그 또는 분기가있는 경우</target>
        </trans-unit>
        <trans-unit id="ef318d408cfc2262e9ecdfec6313bac5c50bc49a" translate="yes" xml:space="preserve">
          <source>If you manually move a linked working tree, you need to update the &lt;code&gt;gitdir&lt;/code&gt; file in the entry&amp;rsquo;s directory. For example, if a linked working tree is moved to &lt;code&gt;/newpath/test-next&lt;/code&gt; and its &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt;, then update &lt;code&gt;/path/main/.git/worktrees/test-next/gitdir&lt;/code&gt; to reference &lt;code&gt;/newpath/test-next&lt;/code&gt; instead.</source>
          <target state="translated">연결된 작업 트리를 수동으로 이동하는 경우 항목 디렉토리에서 &lt;code&gt;gitdir&lt;/code&gt; 파일 을 업데이트해야합니다 . 예를 들어, 연결된 작업 트리가 &lt;code&gt;/newpath/test-next&lt;/code&gt; 로 이동 하고 해당 &lt;code&gt;.git&lt;/code&gt; 파일이 &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; 를 가리키는 경우 &lt;code&gt;/path/main/.git/worktrees/test-next/gitdir&lt;/code&gt; 대신 &lt;code&gt;/newpath/test-next&lt;/code&gt; 를 참조하는 test-next / gitdir .</target>
        </trans-unit>
        <trans-unit id="0359d10c71e55182679347b30eaf723b449ffc8c" translate="yes" xml:space="preserve">
          <source>If you manually move a linked working tree, you need to update the &lt;code&gt;gitdir&lt;/code&gt; file in the entry&amp;rsquo;s directory. For example, if a linked working tree is moved to &lt;code&gt;/newpath/test-next&lt;/code&gt; and its &lt;code&gt;.git&lt;/code&gt; file points to &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt;, then update &lt;code&gt;/path/main/.git/worktrees/test-next/gitdir&lt;/code&gt; to reference &lt;code&gt;/newpath/test-next&lt;/code&gt; instead. Better yet, run &lt;code&gt;git worktree repair&lt;/code&gt; to reestablish the connection automatically.</source>
          <target state="translated">연결된 작업 트리를 수동으로 이동하는 경우 항목의 디렉토리에서 &lt;code&gt;gitdir&lt;/code&gt; 파일 을 업데이트해야합니다 . 예를 들어 연결된 작업 트리가 &lt;code&gt;/newpath/test-next&lt;/code&gt; 로 이동 되고 해당 &lt;code&gt;.git&lt;/code&gt; 파일이 &lt;code&gt;/path/main/.git/worktrees/test-next&lt;/code&gt; 를 가리키는 경우 /path/main/.git/worktrees/ 를 업데이트 &lt;code&gt;/path/main/.git/worktrees/test-next/gitdir&lt;/code&gt; 을 참조하여 &lt;code&gt;/newpath/test-next&lt;/code&gt; 를 참조하십시오 . 더 좋은 방법은 &lt;code&gt;git worktree repair&lt;/code&gt; 를 실행 하여 자동으로 연결을 다시 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bb87bde3a880515ee52eb5a157ecf80cef103126" translate="yes" xml:space="preserve">
          <source>If you mistakenly drop or clear stash entries, they cannot be recovered through the normal safety mechanisms. However, you can try the following incantation to get a list of stash entries that are still in your repository, but not reachable any more:</source>
          <target state="translated">실수로 숨김 항목을 삭제하거나 지우면 일반적인 안전 메커니즘을 통해 복구 할 수 없습니다. 그러나 다음 주문을 시도하여 아직 저장소에 있지만 더 이상 연결할 수없는 숨김 항목 목록을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="110b0b8058519e9efd87b798163b83180b4fd090" translate="yes" xml:space="preserve">
          <source>If you need to add &lt;code&gt;Acked-by&lt;/code&gt; lines to, say, the last 10 commits (none of which is a merge), use this command:</source>
          <target state="translated">예를 들어, 마지막 10 개의 커밋 ( &lt;code&gt;Acked-by&lt;/code&gt; 중 하나는 병합되지 않음)에 Acked-by 행 을 추가 해야하는 경우 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a06310bf48a43d3f06d75e4fe748345a055d13a9" translate="yes" xml:space="preserve">
          <source>If you need to amend commits from deeper in your history, you can use &lt;a href=&quot;#interactive-rebase&quot;&gt;interactive rebase&amp;rsquo;s &lt;code&gt;edit&lt;/code&gt; instruction&lt;/a&gt;.</source>
          <target state="translated">히스토리에서 더 깊이 커밋을 수정해야하는 경우 &lt;a href=&quot;#interactive-rebase&quot;&gt;대화식 rebase의 &lt;code&gt;edit&lt;/code&gt; 명령을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f26f13a2edb916f980bf0b233ef42611b499ae1c" translate="yes" xml:space="preserve">
          <source>If you need to make any further adjustments, do so now, and then add any newly modified content to the index. Finally, commit your changes with:</source>
          <target state="translated">추가 조정이 필요한 경우 지금 수정 한 다음 새로 수정 된 내용을 색인에 추가하십시오. 마지막으로 다음을 사용하여 변경 사항을 커밋하십시오.</target>
        </trans-unit>
        <trans-unit id="b7346c069533043ab7106064793cec780b496e9d" translate="yes" xml:space="preserve">
          <source>If you need to pass multiple options, separate them with a comma.</source>
          <target state="translated">여러 옵션을 전달해야하는 경우 쉼표로 구분하십시오.</target>
        </trans-unit>
        <trans-unit id="809b912a9ed5d5a0eab31e3007d95029a30a63c6" translate="yes" xml:space="preserve">
          <source>If you need to reorder or edit a number of commits in a branch, it may be easier to use &lt;code&gt;git rebase -i&lt;/code&gt;, which allows you to reorder and squash commits, as well as marking them for individual editing during the rebase. See &lt;a href=&quot;#interactive-rebase&quot;&gt;Using interactive rebases&lt;/a&gt; for details, and &lt;a href=&quot;#reordering-patch-series&quot;&gt;Reordering or selecting from a patch series&lt;/a&gt; for alternatives.</source>
          <target state="translated">브랜치에서 여러 커밋을 재정렬하거나 편집 해야하는 경우 &lt;code&gt;git rebase -i&lt;/code&gt; 를 사용하면 커밋을 재정렬하고 스쿼시하고 리베이스 중에 개별 편집을 위해 표시 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;#interactive-rebase&quot;&gt;대화식 리베이스 사용&lt;/a&gt; 및 대안을 위해 &lt;a href=&quot;#reordering-patch-series&quot;&gt;패치 시리즈에서 재정렬 또는 선택을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="653cbb8173c66cbe6d9c641e8756d2055e0c1628" translate="yes" xml:space="preserve">
          <source>If you never pushed anything out, just re-tag it. Use &quot;-f&quot; to replace the old one. And you&amp;rsquo;re done.</source>
          <target state="translated">아무 것도 푸시하지 않은 경우 다시 태그를 지정하십시오. &quot;-f&quot;를 사용하여 이전 것을 바꿉니다. 그리고 당신은 끝났습니다.</target>
        </trans-unit>
        <trans-unit id="e0169e9e6701b28da91f9800a1f0eacd543a0e6b" translate="yes" xml:space="preserve">
          <source>If you now continue development as usual, and eventually merge &lt;code&gt;topic&lt;/code&gt; to &lt;code&gt;subsystem&lt;/code&gt;, the commits from &lt;code&gt;subsystem&lt;/code&gt; will remain duplicated forever:</source>
          <target state="translated">당신은 지금 평소와 같이 개발을 계속, 결국 병합 경우 &lt;code&gt;topic&lt;/code&gt; 로 &lt;code&gt;subsystem&lt;/code&gt; 에서 커밋 &lt;code&gt;subsystem&lt;/code&gt; 영원히 복제를 유지합니다 :</target>
        </trans-unit>
        <trans-unit id="d9ba20830393f58c8170e264c4d66d9dd0605070" translate="yes" xml:space="preserve">
          <source>If you now run</source>
          <target state="translated">지금 달리면</target>
        </trans-unit>
        <trans-unit id="ee95c7e5ff1bbdc349787f30139d15eef70dff52" translate="yes" xml:space="preserve">
          <source>If you only want to remove the local checkout of a submodule from your work tree without committing the removal, use &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;&lt;code&gt;deinit&lt;/code&gt; instead. Also see &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt; for details on submodule removal.</source>
          <target state="translated">제거를 커밋하지 않고 작업 트리에서 하위 모듈의 로컬 체크 아웃 만 제거하려면 대신 &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1] &lt;/a&gt; &lt;code&gt;deinit&lt;/code&gt; 를 사용하십시오. 서브 모듈 제거에 대한 자세한 내용 은 &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules [7]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="de4ecb2fda4e4a17fa4230cd7b06e657b6ab1e40" translate="yes" xml:space="preserve">
          <source>If you plan to publish this repository to be accessed over http, you should do &lt;code&gt;mv my-git.git/hooks/post-update.sample
my-git.git/hooks/post-update&lt;/code&gt; at this point. This makes sure that every time you push into this repository, &lt;code&gt;git update-server-info&lt;/code&gt; is run.</source>
          <target state="translated">http를 통해 액세스 할 수 있도록이 저장소를 공개하려는 &lt;code&gt;mv my-git.git/hooks/post-update.sample my-git.git/hooks/post-update&lt;/code&gt; 를 수행해야합니다. 이를 통해이 저장소에 푸시 할 때마다 &lt;code&gt;git update-server-info&lt;/code&gt; 가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="dce58b5a972f1c023066ee29ac3c991fde1e2420" translate="yes" xml:space="preserve">
          <source>If you present all of your changes as a single patch (or commit), they may find that it is too much to digest all at once.</source>
          <target state="translated">모든 변경 사항을 단일 패치 (또는 커밋)로 표시하면 한 번에 모두 다이제스트하기에는 너무 많은 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e4131986cf58f7abe3d9d87945a8e4a59143945" translate="yes" xml:space="preserve">
          <source>If you present them with the entire history of your work, complete with mistakes, corrections, and dead ends, they may be overwhelmed.</source>
          <target state="translated">당신이 그들에게 당신의 작품의 전체 역사를 제시하고, 실수, 수정, 막 다른 골목으로 완성한다면, 그들은 압도 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21ee16e384bb8d43949dac71aebc6ab455b71a15" translate="yes" xml:space="preserve">
          <source>If you provide a &lt;code&gt;directory&lt;/code&gt;, the command is run inside it. If this directory does not exist, it will be created.</source>
          <target state="translated">&lt;code&gt;directory&lt;/code&gt; 를 제공 하면 명령이 그 안에서 실행됩니다. 이 디렉토리가 존재하지 않으면 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="e318df70fba90a3c817f7eb76621f705fc69949d" translate="yes" xml:space="preserve">
          <source>If you pushed your change to a branch whose name is different from the one you have locally, e.g.</source>
          <target state="translated">이름이 로컬에있는 것과 다른 지점으로 변경을 푸시 한 경우 (예 :</target>
        </trans-unit>
        <trans-unit id="f36c21fb05ddb2d8eeea70a503cb3c797b4a7baa" translate="yes" xml:space="preserve">
          <source>If you really don&amp;rsquo;t want to clone it, for whatever reasons, check the following points instead (in this order). This is a very destructive approach, so &lt;strong&gt;make a backup&lt;/strong&gt; or go back to cloning it. You have been warned.</source>
          <target state="translated">어떤 이유로 든 복제하지 않으려면 대신 다음 순서대로 순서대로 확인하십시오. 이것은 매우 파괴적인 접근 방식이므로 &lt;strong&gt;백업을&lt;/strong&gt; 하거나 복제로 돌아갑니다. 경고를 받았습니다.</target>
        </trans-unit>
        <trans-unit id="3a0d5ef629f0a421a47e2200b4c6f6985f396b8e" translate="yes" xml:space="preserve">
          <source>If you really want to remove a submodule from the repository and commit that use &lt;a href=&quot;git-rm&quot;&gt;git-rm[1]&lt;/a&gt; instead. See &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt; for removal options.</source>
          <target state="translated">리포지토리에서 하위 모듈을 제거하고 커밋하려면 &lt;a href=&quot;git-rm&quot;&gt;git-rm [1]을&lt;/a&gt; 대신 사용하십시오. 제거 옵션에 대해서는 &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules [7]&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5e65b5631472cf01bf2ff6d1fb37eb4b5d6b41d" translate="yes" xml:space="preserve">
          <source>If you really want to use &lt;code&gt;konqueror&lt;/code&gt;, then you can use something like the following:</source>
          <target state="translated">실제로 &lt;code&gt;konqueror&lt;/code&gt; 를 사용 하려면 다음과 같은 것을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3a8dad6f18366292640cec2d899866b39003a2b" translate="yes" xml:space="preserve">
          <source>If you receive such a patch series (as maintainer, or perhaps as a reader of the mailing list it was sent to), save the mails to files, create a new topic branch and use &lt;code&gt;git am&lt;/code&gt; to import the commits:</source>
          <target state="translated">이러한 패치 시리즈 (관리자 또는 메일 링리스트의 독자로서)를 받으면, 메일을 파일에 저장하고 새 토픽 브랜치를 작성하고 &lt;code&gt;git am&lt;/code&gt; 을 사용 하여 커밋을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="8122cfb5e210d22279775f15b8524f8a454a6069" translate="yes" xml:space="preserve">
          <source>If you receive the SHA-1 name of a blob from one source, and its contents from another (possibly untrusted) source, you can still trust that those contents are correct as long as the SHA-1 name agrees. This is because the SHA-1 is designed so that it is infeasible to find different contents that produce the same hash.</source>
          <target state="translated">한 소스에서 Blob의 SHA-1 이름을 수신하고 다른 소스 (신뢰할 수없는) 소스에서 해당 컨텐츠를 수신하더라도 SHA-1 이름이 동의하는 한 해당 컨텐츠가 올바르다 고 여전히 신뢰할 수 있습니다. SHA-1은 동일한 해시를 생성하는 다른 컨텐츠를 찾을 수 없도록 설계 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="72b668cfa18e4e3a824ca9d20a1fa4e3cde95d1f" translate="yes" xml:space="preserve">
          <source>If you recognize such corruption early you can easily fix it by setting the conversion type explicitly in .gitattributes. Right after committing you still have the original file in your work tree and this file is not yet corrupted. You can explicitly tell Git that this file is binary and Git will handle the file appropriately.</source>
          <target state="translated">이러한 손상을 조기에 인식하면 변환 유형을 .gitattributes에 명시 적으로 설정하여 쉽게 수정할 수 있습니다. 커밋 한 후에도 여전히 작업 트리에 원본 파일이 있으며이 파일은 아직 손상되지 않았습니다. Git에게이 파일이 바이너리이고 Git이 파일을 적절하게 처리 할 것이라고 명시 적으로 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d44148625d48b9905fb64fc2d01c214d013573d" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git branch&lt;/code&gt; at this point, you&amp;rsquo;ll see that Git has temporarily moved you in &quot;(no branch)&quot;. HEAD is now detached from any branch and points directly to a commit (with commit id 65934) that is reachable from &quot;master&quot; but not from v2.6.18. Compile and test it, and see whether it crashes. Assume it does crash. Then:</source>
          <target state="translated">이 시점에서 &lt;code&gt;git branch&lt;/code&gt; 를 실행 하면 Git이 일시적으로 &quot;(분기 없음)&quot;으로 이동했음을 알 수 있습니다. HEAD는 이제 모든 브랜치에서 분리되며 v2.6.18이 아닌 &quot;마스터&quot;에서는 도달 할 수있는 커밋 (커밋 ID 65934)을 직접 가리 킵니다. 컴파일하고 테스트하여 충돌하는지 확인하십시오. 충돌한다고 가정하십시오. 그때:</target>
        </trans-unit>
        <trans-unit id="e4f37857c4f0244dcc0891e65a70e27a5bbdffad" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; later, the remote-tracking branches for the named &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; will be updated.</source>
          <target state="translated">나중에 &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; 를 실행 하면 이름이 지정된 &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; 의 원격 추적 분기 가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="086aebbf0140fb264a45c34927db290b089af7f6" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;git repack&lt;/code&gt; again at this point, it will say &quot;Nothing new to pack.&quot;. Once you continue your development and accumulate the changes, running &lt;code&gt;git repack&lt;/code&gt; again will create a new pack, that contains objects created since you packed your repository the last time. We recommend that you pack your project soon after the initial import (unless you are starting your project from scratch), and then run &lt;code&gt;git repack&lt;/code&gt; every once in a while, depending on how active your project is.</source>
          <target state="translated">이 시점에서 &lt;code&gt;git repack&lt;/code&gt; 을 다시 실행하면 &quot;Nothing new to pack&quot;이라고 표시됩니다. 개발을 계속하고 변경 사항을 누적하면 &lt;code&gt;git repack&lt;/code&gt; 을 다시 실행 하면 저장소를 마지막으로 압축 한 이후 생성 된 객체가 포함 된 새 팩이 생성됩니다. 처음 가져 오기 직후 (프로젝트를 처음부터 시작하지 않는 한) 프로젝트를 &lt;code&gt;git repack&lt;/code&gt; 한 다음 프로젝트의 활동 정도에 따라 가끔씩 git repack 을 실행 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f6784580fd898de2457fa8e4a33fffee5347973c" translate="yes" xml:space="preserve">
          <source>If you simply want to have CRLF line endings in your working directory regardless of the repository you are working with, you can set the config variable &quot;core.autocrlf&quot; without using any attributes.</source>
          <target state="translated">작업중인 저장소에 관계없이 작업 디렉토리에 CRLF 줄 끝을 표시하려는 경우 속성을 사용하지 않고 구성 변수 &quot;core.autocrlf&quot;를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c25024f01247f9dfa8226991c206d71987ca030" translate="yes" xml:space="preserve">
          <source>If you suspect that any of these issues may apply to the repository you want to import, consider using cvs2git:</source>
          <target state="translated">가져올 저장소에 이러한 문제가 발생할 수 있다고 생각되면 cvs2git 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d4145f8caae501b7db828bb5aa5f527a21b88535" translate="yes" xml:space="preserve">
          <source>If you think you have found a git bug, you can start by exporting an anonymized stream of the whole repository:</source>
          <target state="translated">git 버그를 발견했다고 생각되면 전체 저장소의 익명 스트림을 내 보내서 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="846aba2aee9d2174839c8e896f13afd75da487fc" translate="yes" xml:space="preserve">
          <source>If you tried a merge which resulted in complex conflicts and want to start over, you can recover with &lt;code&gt;git merge --abort&lt;/code&gt;.</source>
          <target state="translated">복잡한 충돌을 &lt;code&gt;git merge --abort&lt;/code&gt; 병합을 시도하고 다시 시작하려는 경우 git merge --abort로 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e65bb746f0318eba11b3455708b3d4c243b8cb3" translate="yes" xml:space="preserve">
          <source>If you tried a pull which resulted in complex conflicts and would want to start over, you can recover with &lt;code&gt;git reset&lt;/code&gt;.</source>
          <target state="translated">풀을 시도하여 복잡한 충돌이 발생하고 다시 시작하려는 경우 &lt;code&gt;git reset&lt;/code&gt; 으로 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a4f4230d5ba7e1273c96751869d78c8666680eb6" translate="yes" xml:space="preserve">
          <source>If you try and cheat and try to make git-filter-branch only work on files modified in a commit, then two things happen</source>
          <target state="translated">커밋에서 수정 된 파일에서만 git-filter-branch를 작동 시키려고하면 두 가지 일이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8c2ff328d40e63aa92549620e7b30dc7bd79b356" translate="yes" xml:space="preserve">
          <source>If you use any of the options marked &quot;Turns off &lt;code&gt;apply&lt;/code&gt;&quot; above, &lt;code&gt;git apply&lt;/code&gt; reads and outputs the requested information without actually applying the patch. Give this flag after those flags to also apply the patch.</source>
          <target state="translated">위에서 &quot;Turns off &lt;code&gt;apply&lt;/code&gt; &quot; 로 표시된 옵션을 사용하면 &lt;code&gt;git apply&lt;/code&gt; 는 실제로 패치를 적용하지 않고 요청 된 정보를 읽고 출력합니다. 패치를 적용하려면이 플래그 뒤에이 플래그를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="9ac6e5a034fc806d1c17415da5d8566070ff7060" translate="yes" xml:space="preserve">
          <source>If you use the rewrite rules from the example you &lt;strong&gt;might&lt;/strong&gt; also need something like the following in your gitweb configuration file (&lt;code&gt;/etc/gitweb.conf&lt;/code&gt; following example):</source>
          <target state="translated">예제에서 다시 쓰기 규칙을 사용하는 경우 gitweb 구성 파일 ( 예 : &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; 다음)에 다음 과 같은 것이 필요할 &lt;strong&gt;수도&lt;/strong&gt; 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b6c2f4a6c5d4d8aeea38b5e0c4e8e111c81122f" translate="yes" xml:space="preserve">
          <source>If you want a shared repository, you will need to make a bare clone of the imported directory, as described above. Then treat the imported directory as another development clone for purposes of merging incremental imports.</source>
          <target state="translated">공유 리포지토리를 원할 경우 위에서 설명한대로 가져온 디렉터리를 완전 복제해야합니다. 그런 다음 증분 가져 오기를 병합하기 위해 가져온 디렉토리를 다른 개발 복제본으로 취급하십시오.</target>
        </trans-unit>
        <trans-unit id="f7444f839f8aa37b3a95b6650647c55221c170f1" translate="yes" xml:space="preserve">
          <source>If you want command input to still be interpreted as usual by &lt;code&gt;git rev-parse&lt;/code&gt; before the output is shell quoted, see the &lt;code&gt;--sq&lt;/code&gt; option.</source>
          <target state="translated">출력을 쉘 인용하기 전에 &lt;code&gt;git rev-parse&lt;/code&gt; 에서 명령 입력을 평소대로 해석 하려면 &lt;code&gt;--sq&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54d050e248b6c4afcd2cdb81603440db07ba11e1" translate="yes" xml:space="preserve">
          <source>If you want to break the dependency of a repository cloned with &lt;code&gt;--shared&lt;/code&gt; on its source repository, you can simply run &lt;code&gt;git repack -a&lt;/code&gt; to copy all objects from the source repository into a pack in the cloned repository.</source>
          <target state="translated">소스 저장소에서 &lt;code&gt;--shared&lt;/code&gt; 로 복제 된 저장소의 종속성을 중단하려면 &lt;code&gt;git repack -a&lt;/code&gt; 를 실행 하여 소스 저장소의 모든 오브젝트를 복제 된 저장소의 팩으로 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="175eedbbcb252ccb8b65afc8343c53ee6468a326" translate="yes" xml:space="preserve">
          <source>If you want to check out &lt;code&gt;all&lt;/code&gt; C source files out of the index, you can say</source>
          <target state="translated">인덱스에서 &lt;code&gt;all&lt;/code&gt; C 소스 파일 을 체크 아웃하려면</target>
        </trans-unit>
        <trans-unit id="e8498bad4ba6680850d835a14e8199fc54c7601f" translate="yes" xml:space="preserve">
          <source>If you want to delete an entry for a multivar (like core.gitproxy above), you have to provide a regex matching the value of exactly one line.</source>
          <target state="translated">multivar의 항목을 삭제하려면 (위의 core.gitproxy와 같이) 정확히 한 줄의 값과 일치하는 정규식을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6ce9e2807ee6d14a7a74a4824bf5e00e758331b" translate="yes" xml:space="preserve">
          <source>If you want to enable (or disable) this feature, it is easier to use the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) than using the &lt;code&gt;--fsmonitor&lt;/code&gt; option to &lt;code&gt;git update-index&lt;/code&gt; in each repository, especially if you want to do so across all repositories you use, because you can set the configuration variable in your &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; just once and have it affect all repositories you touch.</source>
          <target state="translated">이 기능을 활성화하거나 비활성화 하려면 &lt;code&gt;--fsmonitor&lt;/code&gt; 옵션을 사용하여 각 리포지토리에서 &lt;code&gt;git update-index&lt;/code&gt; 를 git 하는 것보다 &lt;code&gt;core.fsmonitor&lt;/code&gt; 구성 변수 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 참조) 를 사용하는 것이 더 쉽습니다. &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 에서 구성 변수를 한 번만 설정하고 터치하는 모든 리포지토리에 영향을 줄 수 있기 때문에 사용하는 모든 리포지토리에서 그렇게하고 싶습니다 .</target>
        </trans-unit>
        <trans-unit id="fade353b5f9f7d0b204907810eaa983a2e094489" translate="yes" xml:space="preserve">
          <source>If you want to enable (or disable) this feature, it is easier to use the &lt;code&gt;core.untrackedCache&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) than using the &lt;code&gt;--untracked-cache&lt;/code&gt; option to &lt;code&gt;git update-index&lt;/code&gt; in each repository, especially if you want to do so across all repositories you use, because you can set the configuration variable to &lt;code&gt;true&lt;/code&gt; (or &lt;code&gt;false&lt;/code&gt;) in your &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; just once and have it affect all repositories you touch.</source>
          <target state="translated">이 기능을 활성화 또는 비활성화 하려면 &lt;code&gt;--untracked-cache&lt;/code&gt; 옵션을 사용하여 각 리포지토리에서 &lt;code&gt;git update-index&lt;/code&gt; 를 사용하는 것보다 &lt;code&gt;core.untrackedCache&lt;/code&gt; 구성 변수 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 참조) 를 사용하는 것이 더 쉽습니다 . 특히 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 에서 구성 변수를 &lt;code&gt;true&lt;/code&gt; (또는 &lt;code&gt;false&lt;/code&gt; )로 한 번만 설정하고 터치하는 모든 리포지토리에 영향을 줄 수 있기 때문에 사용하는 모든 리포지토리에서 수행하려는 경우 특히 그렇습니다 .</target>
        </trans-unit>
        <trans-unit id="58323cdd8a68e6e1cc6d62c47524db6593349b87" translate="yes" xml:space="preserve">
          <source>If you want to ensure that text files that any contributor introduces to the repository have their line endings normalized, you can set the &lt;code&gt;text&lt;/code&gt; attribute to &quot;auto&quot; for &lt;code&gt;all&lt;/code&gt; files.</source>
          <target state="translated">기고자가 저장소에 도입 한 텍스트 파일의 줄 끝이 정규화 되도록하려면 &lt;code&gt;all&lt;/code&gt; 파일에 대해 &lt;code&gt;text&lt;/code&gt; 속성을 &quot;auto&quot;로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46aa6af5bcc60a63656632720781ded6cb9a0464" translate="yes" xml:space="preserve">
          <source>If you want to fold two or more commits into one, replace the command &quot;pick&quot; for the second and subsequent commits with &quot;squash&quot; or &quot;fixup&quot;. If the commits had different authors, the folded commit will be attributed to the author of the first commit. The suggested commit message for the folded commit is the concatenation of the commit messages of the first commit and of those with the &quot;squash&quot; command, but omits the commit messages of commits with the &quot;fixup&quot; command.</source>
          <target state="translated">둘 이상의 커밋을 하나로 묶으려면 두 번째 및 이후의 커밋에 대한 &quot;pick&quot;명령을 &quot;squash&quot;또는 &quot;fixup&quot;으로 바꾸십시오. 커밋에 다른 작성자가있는 경우 접힌 커밋은 첫 번째 커밋의 작성자에 기인합니다. 폴딩 된 커밋에 대해 제안 된 커밋 메시지는 첫 번째 커밋과 &quot;squash&quot;명령이있는 커밋 메시지의 연결이지만 &quot;fixup&quot;명령으로 커밋의 커밋 메시지는 생략합니다.</target>
        </trans-unit>
        <trans-unit id="a1fc176bf758306e3705a3dd88ad77db4fb55698" translate="yes" xml:space="preserve">
          <source>If you want to have one URL for both gitweb and your &lt;code&gt;http://&lt;/code&gt; repositories, you can configure Apache like this:</source>
          <target state="translated">gitweb과 &lt;code&gt;http://&lt;/code&gt; 저장소 모두에 대해 하나의 URL을 원한다면 다음 과 같이 Apache를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23a694ff61b56e5a1054639701ce379b6eeb6564" translate="yes" xml:space="preserve">
          <source>If you want to know all the values for a multivar, do:</source>
          <target state="translated">multivar의 모든 값을 알고 싶다면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="be838b052e83d8fa0d4980781547923358bc58d3" translate="yes" xml:space="preserve">
          <source>If you want to make a change within a submodule and you have a detached head, then you should create or checkout a branch, make your changes, publish the change within the submodule, and then update the superproject to reference the new commit:</source>
          <target state="translated">서브 모듈 내에서 변경을 원하고 헤드가 분리 된 경우, 브랜치를 작성 또는 체크 아웃하고, 변경을 수행하고, 서브 모듈 내에서 변경 사항을 공개 한 후 수퍼 프로젝트를 업데이트하여 새 커밋을 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="f02c3e1c88ba7fbd299965b88348f8af1bb2eec2" translate="yes" xml:space="preserve">
          <source>If you want to make sure that the output actually names an object in your object database and/or can be used as a specific type of object you require, you can add the &lt;code&gt;^{type}&lt;/code&gt; peeling operator to the parameter. For example, &lt;code&gt;git rev-parse &quot;$VAR^{commit}&quot;&lt;/code&gt; will make sure &lt;code&gt;$VAR&lt;/code&gt; names an existing object that is a commit-ish (i.e. a commit, or an annotated tag that points at a commit). To make sure that &lt;code&gt;$VAR&lt;/code&gt; names an existing object of any type, &lt;code&gt;git rev-parse &quot;$VAR^{object}&quot;&lt;/code&gt; can be used.</source>
          <target state="translated">출력이 실제로 오브젝트 데이터베이스에서 오브젝트의 이름을 지정하고 /하거나 필요한 특정 오브젝트 유형으로 사용될 수 있도록하려면 &lt;code&gt;^{type}&lt;/code&gt; 필링 연산자를 매개 변수에 추가 할 수 있습니다 . 예를 들어, &lt;code&gt;git rev-parse &quot;$VAR^{commit}&quot;&lt;/code&gt; 은 &lt;code&gt;$VAR&lt;/code&gt; 이름을 커밋 대상인 기존 객체 (예 : 커밋 또는 커밋을 가리키는 주석이 달린 태그)로 지정합니다. &lt;code&gt;$VAR&lt;/code&gt; 이 모든 유형의 기존 객체 이름 을 지정하도록하기 위해 &lt;code&gt;git rev-parse &quot;$VAR^{object}&quot;&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="136531f3c928e37ad60b2649b3285deac4e99b46" translate="yes" xml:space="preserve">
          <source>If you want to refer to a git refspec that has characters that are not allowed by CVS, you have two options. First, it may just work to supply the git refspec directly to the appropriate CVS -r argument; some CVS clients don&amp;rsquo;t seem to do much sanity checking of the argument. Second, if that fails, you can use a special character escape mechanism that only uses characters that are valid in CVS tags. A sequence of 4 or 5 characters of the form (underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt;), dash (&lt;code&gt;&quot;-&quot;&lt;/code&gt;), one or two characters, and dash (&lt;code&gt;&quot;-&quot;&lt;/code&gt;)) can encode various characters based on the one or two letters: &lt;code&gt;&quot;s&quot;&lt;/code&gt; for slash (&lt;code&gt;&quot;/&quot;&lt;/code&gt;), &lt;code&gt;&quot;p&quot;&lt;/code&gt; for period (&lt;code&gt;&quot;.&quot;&lt;/code&gt;), &lt;code&gt;&quot;u&quot;&lt;/code&gt; for underscore (&lt;code&gt;&quot;_&quot;&lt;/code&gt;), or two hexadecimal digits for any byte value at all (typically an ASCII number, or perhaps a part of a UTF-8 encoded character).</source>
          <target state="translated">CVS에서 허용되지 않는 문자가있는 git refspec을 참조하려는 경우 두 가지 옵션이 있습니다. 먼저 git refspec을 적절한 CVS -r 인수에 직접 제공하는 것이 효과적 일 수 있습니다. 일부 CVS 클라이언트는 인수에 대한 온전한 검사를 수행하지 않는 것 같습니다. 두 번째로 실패하면 CVS 태그에서 유효한 문자 만 사용하는 특수 문자 이스케이프 메커니즘을 사용할 수 있습니다. 밑줄 ( &lt;code&gt;&quot;_&quot;&lt;/code&gt; ), 대시 ( &lt;code&gt;&quot;-&quot;&lt;/code&gt; ), 하나 또는 두 개의 문자 및 대시 ( &lt;code&gt;&quot;-&quot;&lt;/code&gt; ) 형식의 4 개 또는 5 개의 문자 시퀀스는 하나 또는 두 개의 문자를 기반으로 다양한 문자를 인코딩 할 수 있습니다. 슬래시는 &lt;code&gt;&quot;s&quot;&lt;/code&gt; ( &lt;code&gt;&quot;/&quot;&lt;/code&gt; ), 기간은 &lt;code&gt;&quot;p&quot;&lt;/code&gt; ( &lt;code&gt;&quot;.&quot;&lt;/code&gt; ), &lt;code&gt;&quot;u&quot;&lt;/code&gt; 밑줄 ( &lt;code&gt;&quot;_&quot;&lt;/code&gt; ) 또는 모든 바이트 값 (일반적으로 ASCII 번호 또는 UTF-8로 인코딩 된 문자의 일부)에 대한 두 개의 16 진수입니다.</target>
        </trans-unit>
        <trans-unit id="e8beaf63d7e0d62995b4c7a9252b3f2ea0574fab" translate="yes" xml:space="preserve">
          <source>If you want to replace many blobs, trees or commits that are part of a string of commits, you may just want to create a replacement string of commits and then only replace the commit at the tip of the target string of commits with the commit at the tip of the replacement string of commits.</source>
          <target state="translated">커밋 문자열의 일부인 많은 Blob, 트리 또는 커밋을 바꾸려면 커밋 대체 문자열을 만든 다음 대상 커밋 문자열 끝의 커밋을 커밋으로 바꿉니다. 대체 커밋 문자열의 끝.</target>
        </trans-unit>
        <trans-unit id="44f075cf045ec7b6bbf9c6b54de29b3e2085d2d6" translate="yes" xml:space="preserve">
          <source>If you want to restore &lt;code&gt;all&lt;/code&gt; C source files to match the version in the index, you can say</source>
          <target state="translated">인덱스의 버전과 일치하도록 &lt;code&gt;all&lt;/code&gt; C 소스 파일 을 복원하려는 경우 다음 과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bbbea69a50b6a93a6b75d0ba68d2bc45319d47b" translate="yes" xml:space="preserve">
          <source>If you want to rewrite URLs for push only, you can create a configuration section of the form:</source>
          <target state="translated">푸시 전용 URL을 다시 쓰려면 다음과 같은 형식의 구성 섹션을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="295a38729bbd2cc488fb271a44e4d101d6ee7a15" translate="yes" xml:space="preserve">
          <source>If you want to show differences between binary or specially-formatted blobs in your repository, you can choose to use either an external diff command, or to use textconv to convert them to a diff-able text format. Which method you choose depends on your exact situation.</source>
          <target state="translated">저장소에서 2 진 또는 특수 형식의 Blob 간의 차이점을 표시하려면 외부 diff 명령을 사용하거나 textconv를 사용하여이를 diff 가능한 텍스트 형식으로 변환하도록 선택할 수 있습니다. 선택하는 방법은 정확한 상황에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e3f3cfd8a6d2a1c0d741f6415c0be4ad8848457f" translate="yes" xml:space="preserve">
          <source>If you want to show other people your bisection process, you can get a log using for example:</source>
          <target state="translated">다른 사람에게 이분법 프로세스를 표시하려면 다음과 같이 로그를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07b554efbcde38cd3d8cb2b2cd3fe1b74a5f9d9d" translate="yes" xml:space="preserve">
          <source>If you want to start a disconnected history that records a set of paths that is totally different from the one of &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt;, then you should clear the index and the working tree right after creating the orphan branch by running &lt;code&gt;git rm -rf .&lt;/code&gt; from the top level of the working tree. Afterwards you will be ready to prepare your new files, repopulating the working tree, by copying them from elsewhere, extracting a tarball, etc.</source>
          <target state="translated">&lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 와 완전히 다른 경로 세트를 기록하는 연결이 끊긴 히스토리를 시작 하려면 &lt;code&gt;git rm -rf .&lt;/code&gt; 를 실행하여 고아 브랜치를 작성한 후 색인 및 작업 트리를 지우십시오 . 작업 트리의 최상위 레벨에서 그런 다음 새 파일을 준비하고, 작업 트리를 다른 곳에 복사하거나, 타르볼을 추출하는 등의 작업 트리를 다시 채울 준비가됩니다.</target>
        </trans-unit>
        <trans-unit id="5dc24ba332edd3d8bebaa76b808aacd296106da2" translate="yes" xml:space="preserve">
          <source>If you want to start a new branch from a remote branch of the same name:</source>
          <target state="translated">동일한 이름의 원격 브랜치에서 새 브랜치를 시작하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b533f775f69c9c29e40e15bb405c24bc01b04dac" translate="yes" xml:space="preserve">
          <source>If you want to use gitweb with several project roots you can edit your Apache virtual host and gitweb configuration files in the following way.</source>
          <target state="translated">gitweb을 여러 프로젝트 루트와 함께 사용하려면 다음과 같은 방법으로 Apache 가상 호스트 및 gitweb 구성 파일을 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cced0d77bb2b4a5861e7555078781fd81234d732" translate="yes" xml:space="preserve">
          <source>If you want to, you can use &lt;code&gt;git cat-file&lt;/code&gt; to look at those objects, but you&amp;rsquo;ll have to use the object name, not the filename of the object:</source>
          <target state="translated">원하는 경우 &lt;code&gt;git cat-file&lt;/code&gt; 을 사용 하여 해당 객체를 볼 수 있지만 객체의 파일 이름이 아닌 객체 이름을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9eff57ed3284da22d90930841774b80f0270e4be" translate="yes" xml:space="preserve">
          <source>If you wish the exclude patterns to affect only certain repositories (instead of every repository for a given project), you may instead put them in a file in your repository named &lt;code&gt;.git/info/exclude&lt;/code&gt;, or in any file specified by the &lt;code&gt;core.excludesFile&lt;/code&gt; configuration variable. Some Git commands can also take exclude patterns directly on the command line. See &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt; for the details.</source>
          <target state="translated">제외 패턴이 특정 프로젝트의 모든 저장소 대신 특정 저장소에만 영향을 미치도록하려면 대신 &lt;code&gt;.git/info/exclude&lt;/code&gt; 라는 저장소의 파일 또는 &lt;code&gt;core.excludesFile&lt;/code&gt; 지정한 파일에 파일을 넣을 수 있습니다 . excludesFile 구성 변수. 일부 Git 명령은 명령 행에서 직접 제외 패턴을 사용할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f3a956a01313129dd0835296263e6883d7abec99" translate="yes" xml:space="preserve">
          <source>If you wish to affect only a single repository (i.e., to assign attributes to files that are particular to one user&amp;rsquo;s workflow for that repository), then attributes should be placed in the &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; file. Attributes which should be version-controlled and distributed to other repositories (i.e., attributes of interest to all users) should go into &lt;code&gt;.gitattributes&lt;/code&gt; files. Attributes that should affect all repositories for a single user should be placed in a file specified by the &lt;code&gt;core.attributesFile&lt;/code&gt; configuration option (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). Its default value is $XDG_CONFIG_HOME/git/attributes. If $XDG_CONFIG_HOME is either not set or empty, $HOME/.config/git/attributes is used instead. Attributes for all users on a system should be placed in the &lt;code&gt;$(prefix)/etc/gitattributes&lt;/code&gt; file.</source>
          <target state="translated">단일 리포지토리에만 영향을 주려면 (즉, 해당 리포지토리의 한 사용자의 워크 플로에 특정한 파일에 속성을 할당하려는 경우) 속성은 &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; 파일에 배치해야 합니다. 버전 관리 및 다른 리포지토리에 배포해야하는 특성 (즉, 모든 사용자가 관심을 갖는 특성)은 &lt;code&gt;.gitattributes&lt;/code&gt; 파일 로 이동해야 합니다. 단일 사용자의 모든 저장소에 영향을 미치는 속성은 &lt;code&gt;core.attributesFile&lt;/code&gt; 구성 옵션에 의해 지정된 파일에 있어야합니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 참조) .). 기본값은 $ XDG_CONFIG_HOME / git / attributes입니다. $ XDG_CONFIG_HOME이 설정되거나 비어 있지 않으면 $ HOME / .config / git / attributes가 대신 사용됩니다. 시스템의 모든 사용자에 대한 속성은 &lt;code&gt;$(prefix)/etc/gitattributes&lt;/code&gt; 파일에 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="8bef77486a59978a04a1c46b2c068b3863595296" translate="yes" xml:space="preserve">
          <source>If you work with other people, you will need commands listed in the &lt;a href=&quot;#PARTICIPANT&quot;&gt;Individual Developer (Participant)&lt;/a&gt; section as well.</source>
          <target state="translated">다른 사람과 함께 작업하는 경우 &lt;a href=&quot;#PARTICIPANT&quot;&gt;개별 개발자 (참가자)&lt;/a&gt; 섹션에 나열된 명령도 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="4cb8198fe4b8e422fe561ded3cf681f52266950f" translate="yes" xml:space="preserve">
          <source>If you would like the daemon to exit early, forgetting all cached credentials before their timeout, you can issue an &lt;code&gt;exit&lt;/code&gt; action:</source>
          <target state="translated">데몬을 조기에 종료하고 시간 초과 전에 캐시 된 모든 자격 증명을 잊어 버리려면 &lt;code&gt;exit&lt;/code&gt; 조치를 발행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6fb92003fb885c97541d201047e1ea900190bac9" translate="yes" xml:space="preserve">
          <source>If you would like to use your own terms instead of &quot;bad&quot;/&quot;good&quot; or &quot;new&quot;/&quot;old&quot;, you can choose any names you like (except existing bisect subcommands like &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt;, &amp;hellip;​) by starting the bisection using</source>
          <target state="translated">&quot;bad&quot;/ &quot;good&quot;또는 &quot;new&quot;/ &quot;old&quot;대신 자신의 용어를 사용하려면 원하는 이름을 선택할 수 있습니다 ( &lt;code&gt;reset&lt;/code&gt; , &lt;code&gt;start&lt;/code&gt; 등의 기존 bisect 하위 명령 제외 ). 이등분</target>
        </trans-unit>
        <trans-unit id="ac9785fae40224d0d9d1a9569429bd18f0ceb511" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re releasing a new version of a software project, you may want to simultaneously make a changelog to include in the release announcement.</source>
          <target state="translated">새 버전의 소프트웨어 프로젝트를 배포하는 경우 릴리스 알림에 포함 할 변경 로그를 동시에 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cd2cc907ee3e17f5caea471b5027cb72158e075" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve been committing small enough changes, you may now have a good shot at reconstructing the contents of the in-between state 4b9458b.</source>
          <target state="translated">충분히 작은 변경 사항을 적용한 경우 중간 상태 4b9458b의 내용을 재구성하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5516e4c9c575f8921939c0e95aa6e39fac3c93e0" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve configured a web server that isn&amp;rsquo;t listed here for gitweb, please send in the instructions so they can be included in a future release.</source>
          <target state="translated">gitweb에 대해 여기에 나열되지 않은 웹 서버를 구성한 경우 이후 릴리스에 포함될 수 있도록 지침을 보내십시오.</target>
        </trans-unit>
        <trans-unit id="2ca9c9b64a14bae5a21173833d4a0e06ad289f34" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve messed up the working tree, but haven&amp;rsquo;t yet committed your mistake, you can return the entire working tree to the last committed state with</source>
          <target state="translated">작업 트리를 망 쳤지 만 아직 실수를 저 지르지 않은 경우 전체 작업 트리를 마지막 커밋 된 상태로 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="346e091fa815a370c1b9ad910c5cda575a1ee6ab" translate="yes" xml:space="preserve">
          <source>If your Gmail account is set to another language than English, the name of the &quot;Drafts&quot; folder will be localized.</source>
          <target state="translated">Gmail 계정이 영어가 아닌 다른 언어로 설정된 경우 &quot;Drafts&quot;폴더의 이름이 현지화됩니다.</target>
        </trans-unit>
        <trans-unit id="7bdd278937e1b543d6e4ef46f26f74578bcd1798" translate="yes" xml:space="preserve">
          <source>If your branch was based on &amp;lt;upstream&amp;gt; but &amp;lt;upstream&amp;gt; was rewound and your branch contains commits which were dropped, this option can be used with &lt;code&gt;--keep-base&lt;/code&gt; in order to drop those commits from your branch.</source>
          <target state="translated">브랜치가 &amp;lt;upstream&amp;gt;을 기반으로했지만 &amp;lt;upstream&amp;gt;이 리와인드되고 브랜치에 삭제 된 커밋이 포함 된 경우이 옵션을 &lt;code&gt;--keep-base&lt;/code&gt; 와 함께 사용 하여 브랜치에서 커밋을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="862f720d820aceb82a46583ae7c2b519ed5f9115" translate="yes" xml:space="preserve">
          <source>If your editor or some other system is running &lt;code&gt;git fetch&lt;/code&gt; in the background for you a way to mitigate this is to simply set up another remote:</source>
          <target state="translated">편집기 또는 다른 시스템이 백그라운드에서 &lt;code&gt;git fetch&lt;/code&gt; 를 실행중인 경우 이를 완화하는 방법은 다른 리모컨을 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="233e7aed3c7b3f81991c7f01f9bc6c69656e4a7c" translate="yes" xml:space="preserve">
          <source>If your repository contains one or more submodules, then submodules are populated based on interactions with the &lt;code&gt;git submodule&lt;/code&gt; command. Specifically, &lt;code&gt;git submodule init -- &amp;lt;path&amp;gt;&lt;/code&gt; will ensure the submodule at &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; is present, while &lt;code&gt;git submodule deinit [-f] -- &amp;lt;path&amp;gt;&lt;/code&gt; will remove the files for the submodule at &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; (including any untracked files, uncommitted changes, and unpushed history). Similar to how sparse-checkout removes files from the working tree but still leaves entries in the index, deinitialized submodules are removed from the working directory but still have an entry in the index.</source>
          <target state="translated">저장소에 하나 이상의 하위 모듈이 포함 된 경우 &lt;code&gt;git submodule&lt;/code&gt; 명령 과의 상호 작용을 기반으로 하위 모듈이 채워집니다 . 특히, &lt;code&gt;git submodule init -- &amp;lt;path&amp;gt;&lt;/code&gt; 에서 서브 모듈 보장한다 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 을 , 존재하는 동안 &lt;code&gt;git submodule deinit [-f] -- &amp;lt;path&amp;gt;&lt;/code&gt; 에서 서브 모듈의 파일을 제거 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; (모든 추적 된 파일을 포함 , 커밋되지 않은 변경 사항 및 푸시되지 않은 기록). sparse-checkout이 작업 트리에서 파일을 제거하지만 여전히 색인에 항목을 남기는 것과 유사하게, 초기화되지 않은 하위 모듈은 작업 디렉토리에서 제거되지만 여전히 색인에 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fc3997d817725ac54010e2c723e5760c4e0b90b" translate="yes" xml:space="preserve">
          <source>If your repository contains one or more submodules, then those submodules will appear based on which you initialized with the &lt;code&gt;git submodule&lt;/code&gt; command. If your sparse-checkout patterns exclude an initialized submodule, then that submodule will still appear in your working directory.</source>
          <target state="translated">저장소에 하나 이상의 하위 모듈이 포함 된 경우 &lt;code&gt;git submodule&lt;/code&gt; 명령으로 초기화 한 것을 기준으로 해당 하위 모듈이 나타납니다 . 스파 스 체크 아웃 패턴이 초기화 된 하위 모듈을 제외하더라도 해당 하위 모듈은 여전히 ​​작업 디렉토리에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="17a3911595f90d594aeea889e0f0755079e1efba" translate="yes" xml:space="preserve">
          <source>If, in the middle of a bisect session, you know that the suggested revision is not a good one to test (e.g. it fails to build and you know that the failure does not have anything to do with the bug you are chasing), you can manually select a nearby commit and test that one instead.</source>
          <target state="translated">bisect 세션 중간에 제안 된 개정판이 테스트하기에 적합하지 않다는 것을 알고있는 경우 (예 : 빌드하지 못하고 실패가 추적하는 버그와 관련이 없음을 알고있는 경우) 근처 커밋을 수동으로 선택하고 대신 커밋을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4eaf7ef623b220dfff5cf0aad12284c2791aab6b" translate="yes" xml:space="preserve">
          <source>Ignore carriage-return at the end of line when doing a comparison.</source>
          <target state="translated">비교할 때 줄 끝에서 캐리지 리턴을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="14129ef50a9ff92ecf5a9d9520de0a5438b9b27c" translate="yes" xml:space="preserve">
          <source>Ignore case differences between the patterns and the files.</source>
          <target state="translated">패턴과 파일의 대소 문자 차이를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="93adbe048de005f652abeded323ffca0e07802f9" translate="yes" xml:space="preserve">
          <source>Ignore changes in amount of whitespace. This ignores whitespace at line end, and considers all other sequences of one or more whitespace characters to be equivalent.</source>
          <target state="translated">공백 양의 변경을 무시하십시오. 이것은 줄 끝의 공백을 무시하고 하나 이상의 공백 문자의 다른 모든 시퀀스를 동등한 것으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="dceba3e490b99e465dabc6c0a6eb46378a762d2c" translate="yes" xml:space="preserve">
          <source>Ignore changes in whitespace at EOL.</source>
          <target state="translated">EOL에서 공백의 변경을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="0e8a5619a2125f597eccb060c4d8cfcacf8da768" translate="yes" xml:space="preserve">
          <source>Ignore changes made by the revision when assigning blame, as if the change never happened. Lines that were changed or added by an ignored commit will be blamed on the previous commit that changed that line or nearby lines. This option may be specified multiple times to ignore more than one revision. If the &lt;code&gt;blame.markIgnoredLines&lt;/code&gt; config option is set, then lines that were changed by an ignored commit and attributed to another commit will be marked with a &lt;code&gt;?&lt;/code&gt; in the blame output. If the &lt;code&gt;blame.markUnblamableLines&lt;/code&gt; config option is set, then those lines touched by an ignored commit that we could not attribute to another revision are marked with a &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="translated">변경 사항이 발생하지 않은 것처럼 비난을 할당 할 때 개정판의 변경 사항은 무시하십시오. 무시 된 커밋에 의해 변경되거나 추가 된 라인은 해당 라인 또는 근처의 라인을 변경 한 이전 커밋에서 비난을받습니다. 이 옵션은 여러 개정을 무시하도록 여러 번 지정할 수 있습니다. 는 IF &lt;code&gt;blame.markIgnoredLines&lt;/code&gt; 설정 옵션을 설정, 다음 커밋 무시하고 다른에 기인으로 표시됩니다 커밋에 의해 변경된 라인이 &lt;code&gt;?&lt;/code&gt; 책임 출력에서. 는 IF &lt;code&gt;blame.markUnblamableLines&lt;/code&gt; 설정 옵션을 설정 한 후 무시 감동 그 라인은 우리가 다른 개정 속성이 표시되어 수 없음을 확약 &lt;code&gt;*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="847c383f096e8b2857c23f7df697a300205d1cde" translate="yes" xml:space="preserve">
          <source>Ignore changes to submodules in the diff generation. &amp;lt;when&amp;gt; can be either &quot;none&quot;, &quot;untracked&quot;, &quot;dirty&quot; or &quot;all&quot;, which is the default. Using &quot;none&quot; will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the &lt;code&gt;ignore&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; or &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;. When &quot;untracked&quot; is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using &quot;dirty&quot; ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior until 1.7.0). Using &quot;all&quot; hides all changes to submodules.</source>
          <target state="translated">diff 생성에서 하위 모듈에 대한 변경은 무시하십시오. &amp;lt;when&amp;gt;은 &quot;없음&quot;, &quot;비 추적&quot;, &quot;더러운&quot;또는 &quot;모두&quot;(기본값) 일 수 있습니다. &quot;없음&quot;을 사용하면 추적되지 않거나 수정 된 파일을 포함하거나 해당 HEAD가 수퍼 프로젝트에 기록 된 커밋과 다르고 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 또는 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules&lt;/a&gt; 에서 &lt;code&gt;ignore&lt;/code&gt; 옵션의 설정을 대체하는 데 사용될 수있는 서브 모듈이 수정 된 것으로 간주됩니다 . 5] . &quot;추적되지 않은&quot;이 사용될 때 서브 모듈은 추적되지 않은 내용 만 포함 할 때 더티로 간주되지 않지만 여전히 수정 된 내용을 스캔합니다. &quot;dirty&quot;를 사용하면 하위 모듈의 작업 트리에 대한 모든 변경 사항이 무시됩니다.수퍼 프로젝트에 저장된 커밋에 대한 변경 사항 만 표시됩니다 (1.7.0까지의 동작). &quot;all&quot;을 사용하면 하위 모듈에 대한 모든 변경 사항이 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="0a92f8e585ade182f513a5692eb0bb44a7e837dd" translate="yes" xml:space="preserve">
          <source>Ignore changes to submodules when looking for changes. &amp;lt;when&amp;gt; can be either &quot;none&quot;, &quot;untracked&quot;, &quot;dirty&quot; or &quot;all&quot;, which is the default. Using &quot;none&quot; will consider the submodule modified when it either contains untracked or modified files or its HEAD differs from the commit recorded in the superproject and can be used to override any settings of the &lt;code&gt;ignore&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; or &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt;. When &quot;untracked&quot; is used submodules are not considered dirty when they only contain untracked content (but they are still scanned for modified content). Using &quot;dirty&quot; ignores all changes to the work tree of submodules, only changes to the commits stored in the superproject are shown (this was the behavior before 1.7.0). Using &quot;all&quot; hides all changes to submodules (and suppresses the output of submodule summaries when the config option &lt;code&gt;status.submoduleSummary&lt;/code&gt; is set).</source>
          <target state="translated">변경 사항을 찾을 때 서브 모듈에 대한 변경 사항을 무시하십시오. &amp;lt;when&amp;gt;은 &quot;없음&quot;, &quot;비 추적&quot;, &quot;더러운&quot;또는 &quot;모두&quot;(기본값) 일 수 있습니다. &quot;없음&quot;을 사용하면 추적되지 않거나 수정 된 파일을 포함하거나 해당 HEAD가 수퍼 프로젝트에 기록 된 커밋과 다르고 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 또는 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules&lt;/a&gt; 에서 &lt;code&gt;ignore&lt;/code&gt; 옵션의 설정을 대체하는 데 사용될 수있는 서브 모듈이 수정 된 것으로 간주됩니다 . 5]. &quot;추적되지 않은&quot;이 사용될 때 서브 모듈은 추적되지 않은 내용 만 포함 할 때 더티로 간주되지 않지만 여전히 수정 된 내용을 스캔합니다. &quot;dirty&quot;를 사용하면 서브 모듈의 작업 트리에 대한 모든 변경 사항이 무시되고, 수퍼 프로젝트에 저장된 커밋에 대한 변경 사항 만 표시됩니다 (이것은 1.7.0 이전의 동작이었습니다). &quot;all&quot;을 사용하면 서브 모듈에 대한 모든 변경 사항이 숨겨집니다 (config 옵션 &lt;code&gt;status.submoduleSummary&lt;/code&gt; 가 설정 되면 서브 모듈 요약의 출력이 억제 됩니다).</target>
        </trans-unit>
        <trans-unit id="f616e5a6b317fb9674ab4a6ecd11655583864222" translate="yes" xml:space="preserve">
          <source>Ignore changes whose lines are all blank.</source>
          <target state="translated">행이 모두 비어있는 변경 사항은 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="6b93913a06aa23ba136e18a208983b558968a818" translate="yes" xml:space="preserve">
          <source>Ignore refs for branches or tags matching the Perl regular expression. A &quot;negative look-ahead assertion&quot; like &lt;code&gt;^refs/remotes/origin/(?!tags/wanted-tag|wanted-branch).*$&lt;/code&gt; can be used to allow only certain refs.</source>
          <target state="translated">Perl 정규식과 일치하는 분기 또는 태그에 대한 참조는 무시하십시오. &lt;code&gt;^refs/remotes/origin/(?!tags/wanted-tag|wanted-branch).*$&lt;/code&gt; 와 같은 &quot;부정적인 미리보기 어설 션&quot; . * $ 는 특정 참조 만 허용하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cca615474ea8523b5665d433104181e17b949af0" translate="yes" xml:space="preserve">
          <source>Ignore revisions listed in &lt;code&gt;file&lt;/code&gt;, which must be in the same format as an &lt;code&gt;fsck.skipList&lt;/code&gt;. This option may be repeated, and these files will be processed after any files specified with the &lt;code&gt;blame.ignoreRevsFile&lt;/code&gt; config option. An empty file name, &lt;code&gt;&quot;&quot;&lt;/code&gt;, will clear the list of revs from previously processed files.</source>
          <target state="translated">&lt;code&gt;fsck.skipList&lt;/code&gt; 와 동일한 형식이어야하는 &lt;code&gt;file&lt;/code&gt; 나열된 개정을 무시하십시오 . 이 옵션은 반복 될 수 있으며 이러한 파일은 &lt;code&gt;blame.ignoreRevsFile&lt;/code&gt; 구성 옵션으로 지정된 파일 후에 처리됩니다 . 빈 파일 이름 &lt;code&gt;&quot;&quot;&lt;/code&gt; 은 이전에 처리 된 파일에서 개정 목록을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="0cee361918756e813fbfde1e81b931c608ea0bab" translate="yes" xml:space="preserve">
          <source>Ignore revisions listed in the file, one unabbreviated object name per line, in &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;. Whitespace and comments beginning with &lt;code&gt;#&lt;/code&gt; are ignored. This option may be repeated multiple times. Empty file names will reset the list of ignored revisions. This option will be handled before the command line option &lt;code&gt;--ignore-revs-file&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; 에서 파일에 나열된 개정판 (한 줄에 하나의 축약되지 않은 객체 이름)을 무시하십시오 . &lt;code&gt;#&lt;/code&gt; 으로 시작하는 공백과 주석은 무시됩니다. 이 옵션은 여러 번 반복 될 수 있습니다. 빈 파일 이름은 무시 된 개정 목록을 재설정합니다. 이 옵션은 명령 행 옵션 &lt;code&gt;--ignore-revs-file&lt;/code&gt; 전에 처리 됩니다 .</target>
        </trans-unit>
        <trans-unit id="ecf2829d6b1d696605f65878628b97d7705cf8bc" translate="yes" xml:space="preserve">
          <source>Ignore scissors lines (see &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt;).</source>
          <target state="translated">가위 선은 무시하십시오 ( &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2348d1bd6f42459d3ee1b173782de699bb2835d4" translate="yes" xml:space="preserve">
          <source>Ignore scissors lines. Useful for overriding mailinfo.scissors settings.</source>
          <target state="translated">가위 선은 무시하십시오. mailinfo.scissors 설정을 재정의하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="df44e8d5c0f3cfab7d419d47fcf746abf35ec612" translate="yes" xml:space="preserve">
          <source>Ignore whitespace differences when trying to reconcile differences. Currently, each backend implements an approximation of this behavior:</source>
          <target state="translated">차이를 조정하려고 할 때 공백 차이를 무시하십시오. 현재 각 백엔드는이 동작의 근사치를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b8c0493eeab50cd9f84c9bb7fb54695bfa5cd858" translate="yes" xml:space="preserve">
          <source>Ignore whitespace when comparing lines. This ignores differences even if one line has whitespace where the other line has none.</source>
          <target state="translated">행을 비교할 때 공백을 무시하십시오. 한 줄에 공백이 있고 다른 줄에는없는 경우에도 차이가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f41139f9e81b5ab318787773cf3063813dbcefdd" translate="yes" xml:space="preserve">
          <source>Ignore whitespace when comparing the parent&amp;rsquo;s version and the child&amp;rsquo;s to find where the lines came from.</source>
          <target state="translated">부모의 버전과 자식의 버전을 비교할 때 공백을 무시하고 행의 출처를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="67259bef7d0f56e262c4cda325ae4b91dc800c88" translate="yes" xml:space="preserve">
          <source>Ignored files are not listed, unless &lt;code&gt;--ignored&lt;/code&gt; option is in effect, in which case &lt;code&gt;XY&lt;/code&gt; are &lt;code&gt;!!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--ignored&lt;/code&gt; 옵션이 적용 되지 않으면 무시 된 파일이 나열되지 않습니다 .이 경우 &lt;code&gt;XY&lt;/code&gt; 는 &lt;code&gt;!!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a64e868764637ce6fa403b78bdbf74f10990fd5" translate="yes" xml:space="preserve">
          <source>Ignored items have the following format:</source>
          <target state="translated">무시 된 항목의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe5aad4a58f02d9cd03afd86649692db9ed515bd" translate="yes" xml:space="preserve">
          <source>Ignores missing files during a --refresh</source>
          <target state="translated">-새로 고침 중 누락 된 파일을 무시합니다</target>
        </trans-unit>
        <trans-unit id="87a5b84b90eaf9c6a4ea4cf7776f8cdbe987e92e" translate="yes" xml:space="preserve">
          <source>Ignoring files</source>
          <target state="translated">파일 무시</target>
        </trans-unit>
        <trans-unit id="d83f269a97cfa5cb2870ace661718351e9ef1d6f" translate="yes" xml:space="preserve">
          <source>Imagine that on top of the public commit P, you applied well-known patches X, Y and Z from somebody else, and then built your three-patch series A, B, C, the history would be like:</source>
          <target state="translated">공개 커밋 P 위에 다른 누군가로부터 잘 알려진 패치 X, Y 및 Z를 적용한 다음 3 패치 시리즈 A, B, C를 빌드했다고 가정하십시오. 이력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="220433d0f0fcbc1334d4126616d73a1ad095f039" translate="yes" xml:space="preserve">
          <source>Imagine that you built your work on your &lt;code&gt;master&lt;/code&gt; branch on top of the &lt;code&gt;v1.0&lt;/code&gt; release, and want it to be integrated to the project. First you push that change to your public repository for others to see:</source>
          <target state="translated">&lt;code&gt;v1.0&lt;/code&gt; 릴리스 위에 &lt;code&gt;master&lt;/code&gt; 브랜치에서 작업을 빌드 하고 프로젝트에 통합하려고한다고 가정하십시오. 먼저 다른 사람들이 볼 수 있도록 해당 변경 사항을 공용 저장소로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="d92dfaf42e4c06410357fc423fdf173e48ba5a6c" translate="yes" xml:space="preserve">
          <source>Imagine that you have to rebase what you have already published. You will have to bypass the &quot;must fast-forward&quot; rule in order to replace the history you originally published with the rebased history. If somebody else built on top of your original history while you are rebasing, the tip of the branch at the remote may advance with her commit, and blindly pushing with &lt;code&gt;--force&lt;/code&gt; will lose her work.</source>
          <target state="translated">이미 게시 한 내용을 리베이스해야한다고 상상해보십시오. 원래 게시 한 기록을 다시 기반 기록으로 바꾸려면 &quot;빨리 감기&quot;규칙을 무시해야합니다. 당신이 rebasing하는 동안 당신의 원래 역사 위에 다른 누군가가 건설한다면, 원격 지점의 끝이 그녀의 커밋과 함께 전진 할 수 있으며, 맹목적으로 &lt;code&gt;--force&lt;/code&gt; 를 밀면 그녀의 일을 잃을 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a9ff0ad91f2190aebd8f7874a38eff49a81d587" translate="yes" xml:space="preserve">
          <source>Imagine this history:</source>
          <target state="translated">이 역사를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="db144a77867a22b1db2aa0f495d3082ced7cfb54" translate="yes" xml:space="preserve">
          <source>Imitate &lt;code&gt;git clone&lt;/code&gt; but track only selected branches</source>
          <target state="translated">&lt;code&gt;git clone&lt;/code&gt; 모방 하지만 선택한 지점 만 추적</target>
        </trans-unit>
        <trans-unit id="4a694f013e1a15bee19331c0c7b9e3ce34840db9" translate="yes" xml:space="preserve">
          <source>Imitate a CVS server. See &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt;.</source>
          <target state="translated">CVS 서버를 모방합니다. &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="f1c03dca591efe03ac168cd03c30c9d29e88acc3" translate="yes" xml:space="preserve">
          <source>Import Now, Repack Later</source>
          <target state="translated">지금 가져 오기, 나중에 다시 포장</target>
        </trans-unit>
        <trans-unit id="b3e1462f677f3a661ca64753ac202708178b3a16" translate="yes" xml:space="preserve">
          <source>Import a GNU Arch repository into Git</source>
          <target state="translated">GNU Arch 리포지토리를 Git으로 가져 오기</target>
        </trans-unit>
        <trans-unit id="502aadd2b2c2382144812aea24a52e335147d4a4" translate="yes" xml:space="preserve">
          <source>Import all changes from both named depot paths into a single repository. Only files below these directories are included. There is not a subdirectory in Git for each &quot;proj1&quot; and &quot;proj2&quot;. You must use the &lt;code&gt;--destination&lt;/code&gt; option when specifying more than one depot path. The revision specifier must be specified identically on each depot path. If there are files in the depot paths with the same name, the path with the most recently updated version of the file is the one that appears in Git.</source>
          <target state="translated">이름이 지정된 두 저장소 경로의 모든 변경 사항을 단일 저장소로 가져 오십시오. 이 디렉토리 아래의 파일 만 포함됩니다. Git에는 각 &quot;proj1&quot;및 &quot;proj2&quot;에 대한 하위 디렉토리가 없습니다. 둘 이상의 저장소 경로를 지정할 때 &lt;code&gt;--destination&lt;/code&gt; 옵션을 사용해야합니다 . 개정 지정자는 각 저장소 경로에서 동일하게 지정되어야합니다. 저장소 경로에 이름이 같은 파일이 있으면 가장 최근에 업데이트 된 버전의 파일이있는 경로가 Git에 표시되는 경로입니다.</target>
        </trans-unit>
        <trans-unit id="90051e560d673faccfb0bfe61644ca104b05b719" translate="yes" xml:space="preserve">
          <source>Import all commits, including recent ones. cvsimport by default skips commits that have a timestamp less than 10 minutes ago.</source>
          <target state="translated">최근 커밋을 포함하여 모든 커밋을 가져옵니다. 기본적으로 cvsimport는 시간이 10 분 미만인 커밋을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="3ffbc41d8e969bcf6a3014a353f6e7a2bfd3e3ba" translate="yes" xml:space="preserve">
          <source>Import at most &lt;code&gt;n&lt;/code&gt; changes, rather than the entire range of changes included in the given revision specifier. A typical usage would be use &lt;code&gt;@all&lt;/code&gt; as the revision specifier, but then to use &lt;code&gt;--max-changes 1000&lt;/code&gt; to import only the last 1000 revisions rather than the entire revision history.</source>
          <target state="translated">지정된 수정 자에 포함 된 전체 변경 범위가 아닌 최대 &lt;code&gt;n&lt;/code&gt; 개의 변경 사항을 가져 옵니다. 일반적인 사용법은 &lt;code&gt;@all&lt;/code&gt; 을 개정 지정자로 사용하지만 &lt;code&gt;--max-changes 1000&lt;/code&gt; 을 사용 하여 전체 개정 내역이 아닌 마지막 1000 개정 만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a203d27ce8c09d6ab5f978bc976ed19c7da8bd29" translate="yes" xml:space="preserve">
          <source>Import changes into &amp;lt;ref&amp;gt; instead of refs/remotes/p4/master. If &amp;lt;ref&amp;gt; starts with refs/, it is used as is. Otherwise, if it does not start with p4/, that prefix is added.</source>
          <target state="translated">refs / remotes / p4 / master 대신 &amp;lt;ref&amp;gt;로 변경 사항을 가져옵니다. &amp;lt;ref&amp;gt;가 refs /로 시작하면 그대로 사용됩니다. 그렇지 않으면 p4 /로 시작하지 않으면 해당 접두사가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3446130415616c26cfbd9b0cb3b27c636fdfb1f4" translate="yes" xml:space="preserve">
          <source>Import exactly the p4 change numbers listed in &lt;code&gt;file&lt;/code&gt;, one per line. Normally, &lt;code&gt;git p4&lt;/code&gt; inspects the current p4 repository state and detects the changes it should import.</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 에 나열된 p4 변경 번호를 한 줄에 하나씩 정확하게 가져옵니다 . 일반적으로 &lt;code&gt;git p4&lt;/code&gt; 는 현재 p4 저장소 상태를 검사하고 가져와야 할 변경 사항을 감지합니다.</target>
        </trans-unit>
        <trans-unit id="051514630860e82d8e6dfeb8000cb04203f0530f" translate="yes" xml:space="preserve">
          <source>Import from and submit to Perforce repositories</source>
          <target state="translated">Perforce 리포지토리에서 가져 오기 및 제출</target>
        </trans-unit>
        <trans-unit id="bc1da86269dd0fa043570d9e0331c263ee1c8e9b" translate="yes" xml:space="preserve">
          <source>Import labels from p4 into Git.</source>
          <target state="translated">p4에서 Git으로 레이블을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="01c4fe3eff92a8abc6c7acba932cff943343d8ce" translate="yes" xml:space="preserve">
          <source>Import one commit for each change in the history of that depot path.</source>
          <target state="translated">해당 저장소 경로 히스토리의 각 변경 사항에 대해 하나의 커미트를 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="5fa6a825ca52ecc53990e4e3e6add862904fa4f4" translate="yes" xml:space="preserve">
          <source>Import one commit with all files in the &lt;code&gt;#head&lt;/code&gt; change under that tree.</source>
          <target state="translated">해당 트리 아래 의 &lt;code&gt;#head&lt;/code&gt; change 에있는 모든 파일과 함께 하나의 커밋을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="1a475e0c7f94606844ba9fa0d34742cd54c3d13c" translate="yes" xml:space="preserve">
          <source>Import only changes 1 through 6.</source>
          <target state="translated">1에서 6까지만 변경 사항을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e9848e9219c243527c0682e352e98364329421b1" translate="yes" xml:space="preserve">
          <source>Import p4 labels into git, as per --import-labels.</source>
          <target state="translated">--import-labels에 따라 p4 레이블을 git로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="34d234038bf4e799d075c2933026167918f64329" translate="yes" xml:space="preserve">
          <source>Import p4 labels.</source>
          <target state="translated">p4 레이블을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2f4ea105dee6a1ad94ce6623f490fbb875775ee0" translate="yes" xml:space="preserve">
          <source>Import-only: don&amp;rsquo;t perform a checkout after importing. This option ensures the working directory and index remain untouched and will not create them if they do not exist.</source>
          <target state="translated">가져 오기 전용 : 가져 오기 후 체크 아웃을 수행하지 마십시오. 이 옵션은 작업 디렉토리 및 색인을 그대로 유지하고 존재하지 않는 경우 작성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b6d6a30150a506f9b79caf45da5aecb76b0018e" translate="yes" xml:space="preserve">
          <source>Important</source>
          <target state="translated">Important</target>
        </trans-unit>
        <trans-unit id="a64c4afd3bd1cef7955450469801cfbdf061341b" translate="yes" xml:space="preserve">
          <source>Important note! If you have any local changes in these branches, then this merge will create a commit object in the history (with no local changes Git will simply do a &quot;fast-forward&quot; merge). Many people dislike the &quot;noise&quot; that this creates in the Linux history, so you should avoid doing this capriciously in the &lt;code&gt;release&lt;/code&gt; branch, as these noisy commits will become part of the permanent history when you ask Linus to pull from the release branch.</source>
          <target state="translated">중요 사항! 이러한 브랜치에 로컬 변경이있는 경우이 병합은 히스토리에 커밋 객체를 생성합니다 (로컬 변경없이 Git은 단순히 &quot;빨리 감기&quot;병합을 수행함). 많은 사람들이 이것이 리눅스 히스토리에서 생성되는 &quot;노이즈&quot;를 싫어하므로, 리노스가 &lt;code&gt;release&lt;/code&gt; 브랜치에서 가져 오도록 요청할 때 이러한 노이즈 커밋은 영구 히스토리의 일부가되므로 릴리스 브랜치 에서이를 신중하게 수행하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="a87b614cdbaa5301ddda5b9a1cda5205ccdf1bbc" translate="yes" xml:space="preserve">
          <source>Importing a cvs archive</source>
          <target state="translated">cvs 아카이브 가져 오기</target>
        </trans-unit>
        <trans-unit id="3e30801aed656938780d8d09defb05967bf70053" translate="yes" xml:space="preserve">
          <source>Importing a new project</source>
          <target state="translated">새 프로젝트 가져 오기</target>
        </trans-unit>
        <trans-unit id="7d3eb76e15d3e80f60fde0cbe9f4a9a66f1cc724" translate="yes" xml:space="preserve">
          <source>Importing or exporting patches:</source>
          <target state="translated">패치 가져 오기 또는 내보내기 :</target>
        </trans-unit>
        <trans-unit id="8c866a3a4bff8b0052306000b7abfebb33a38b38" translate="yes" xml:space="preserve">
          <source>Importing patches to a project</source>
          <target state="translated">프로젝트로 패치 가져 오기</target>
        </trans-unit>
        <trans-unit id="19051f1cf9bd70907beeecdf5147851f44537c38" translate="yes" xml:space="preserve">
          <source>Importing these tags as-is in Git is impossible without making at least one commit which &amp;ldquo;fixes up&amp;rdquo; the files to match the content of the tag. Use fast-import&amp;rsquo;s &lt;code&gt;reset&lt;/code&gt; command to reset a dummy branch outside of your normal branch space to the base commit for the tag, then commit one or more file fixup commits, and finally tag the dummy branch.</source>
          <target state="translated">태그의 내용과 일치하도록 파일을 &quot;수정&quot;하는 커밋을 하나 이상 만들지 않으면 Git에서 이러한 태그를 그대로 가져올 수 없습니다. fast-import의 &lt;code&gt;reset&lt;/code&gt; 명령을 사용 하여 일반 분기 공간 외부의 더미 분기를 태그의 기본 커밋으로 재설정 한 다음 하나 이상의 파일 수정 커밋을 커밋하고 마지막으로 더미 분기에 태그를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="ffa5110d0a0de3d5244ac22023669387afe15c4d" translate="yes" xml:space="preserve">
          <source>Imports a CVS repository into Git. It will either create a new repository, or incrementally import into an existing one.</source>
          <target state="translated">CVS 저장소를 Git으로 가져옵니다. 새 저장소를 작성하거나 기존 저장소로 점진적으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="189a5fab4172fe96418112b3abf1f29736c5a78f" translate="yes" xml:space="preserve">
          <source>Imports a project from one or more GNU Arch repositories. It will follow branches and repositories within the namespaces defined by the &amp;lt;archive/branch&amp;gt; parameters supplied. If it cannot find the remote branch a merge comes from it will just import it as a regular commit. If it can find it, it will mark it as a merge whenever possible (see discussion below).</source>
          <target state="translated">하나 이상의 GNU Arch 리포지토리에서 프로젝트를 가져옵니다. 제공된 &amp;lt;archive / branch&amp;gt; 매개 변수로 정의 된 네임 스페이스 내의 브랜치 및 저장소를 따릅니다. 원격 브랜치를 찾을 수 없으면 병합을 통해 일반 커밋으로 가져옵니다. 찾을 수 있으면 가능하면 병합으로 표시합니다 (아래 설명 참조).</target>
        </trans-unit>
        <trans-unit id="0e7ba011d44c49f30a4b102d2d50cfa93397d28b" translate="yes" xml:space="preserve">
          <source>Imports the full contents of the head revision from the given p4 depot path into a single commit in the Git branch &lt;code&gt;refs/remotes/p4/master&lt;/code&gt;.</source>
          <target state="translated">주어진 p4 저장소 경로에서 헤드 개정판의 전체 내용을 Git 브랜치 &lt;code&gt;refs/remotes/p4/master&lt;/code&gt; 의 단일 커밋으로 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="bc75793944c924c387fa08f2263917093a9e6ee9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;#def_SCM&quot;&gt;SCM&lt;/a&gt; jargon, &quot;cherry pick&quot; means to choose a subset of changes out of a series of changes (typically commits) and record them as a new series of changes on top of a different codebase. In Git, this is performed by the &quot;git cherry-pick&quot; command to extract the change introduced by an existing &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; and to record it based on the tip of the current &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; as a new commit.</source>
          <target state="translated">에서 &lt;a href=&quot;#def_SCM&quot;&gt;SCM&lt;/a&gt; 전문 용어 변경 (일반적으로 커밋)의 시리즈 중 변경의 일부를 선택하고 다른 코드베이스의 상단에 변화의 새로운 시리즈로 기록한다 &quot;는 의미 벚꽃 선택&quot;. Git에서는 &quot;git cherry-pick&quot;명령으로 기존 &lt;a href=&quot;#def_commit&quot;&gt;커밋이&lt;/a&gt; 도입 한 변경 사항을 추출 하고 현재 &lt;a href=&quot;#def_branch&quot;&gt;분기&lt;/a&gt; 의 끝을 기반으로 새 커밋으로 기록합니다.</target>
        </trans-unit>
        <trans-unit id="5a7b7bab83d67b10ed8bbe7275df22f645616a7a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--parseopt&lt;/code&gt; mode, &lt;code&gt;git rev-parse&lt;/code&gt; helps massaging options to bring to shell scripts the same facilities C builtins have. It works as an option normalizer (e.g. splits single switches aggregate values), a bit like &lt;code&gt;getopt(1)&lt;/code&gt; does.</source>
          <target state="translated">에서 &lt;code&gt;--parseopt&lt;/code&gt; 모드, &lt;code&gt;git rev-parse&lt;/code&gt; 스크립트를 C의 내장 명령은이 같은 시설 쉘을 가져다주는 옵션을 완화하는 데 도움이됩니다. &lt;code&gt;getopt(1)&lt;/code&gt; 과 비슷한 옵션 노멀 라이저 (예 : 단일 스위치 집계 값 분할 )로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a61808962b5b6bb1a272b1dd2c4e90c87c42eb63" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--sq-quote&lt;/code&gt; mode, &lt;code&gt;git rev-parse&lt;/code&gt; echoes on the standard output a single line suitable for &lt;code&gt;sh(1)&lt;/code&gt;&lt;code&gt;eval&lt;/code&gt;. This line is made by normalizing the arguments following &lt;code&gt;--sq-quote&lt;/code&gt;. Nothing other than quoting the arguments is done.</source>
          <target state="translated">에서는 &lt;code&gt;--sq-quote&lt;/code&gt; 모드 &lt;code&gt;git rev-parse&lt;/code&gt; 표준 출력에 적합한 단일 라인 에코 &lt;code&gt;sh(1)&lt;/code&gt; &lt;code&gt;eval&lt;/code&gt; . 이 줄은 &lt;code&gt;--sq-quote&lt;/code&gt; 다음의 인수를 정규화하여 만들어집니다 . 인수를 인용하는 것 외에는 아무것도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02025b63af6480e186ac72d3a5a618d5536d1d9c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--stdin&lt;/code&gt; mode, take lines in the format</source>
          <target state="translated">에서 &lt;code&gt;--stdin&lt;/code&gt; 옵션 모드 형식의 라인을</target>
        </trans-unit>
        <trans-unit id="46fb44ff2c3ae3502717728ebf0f15532f206b66" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;foo&lt;/code&gt; contains just &amp;ldquo;foo&amp;rdquo;.</source>
          <target state="translated">에서 , &lt;code&gt;foo&lt;/code&gt; 그냥 &quot;foo는&quot;이 포함되어 있습니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e95077ff33e18325bb9215a9cc5764269fc90de" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;dbDriver&lt;/code&gt; and &lt;code&gt;dbUser&lt;/code&gt; you can use the following variables:</source>
          <target state="translated">에서 &lt;code&gt;dbDriver&lt;/code&gt; 및 &lt;code&gt;dbUser&lt;/code&gt; 다음과 같은 변수를 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6c351c60eb0e6d6c6a7b2ff86bb73c9f63bc0dc3" translate="yes" xml:space="preserve">
          <source>In Git 1.7.0 or later, to cancel a conflicting merge, use &lt;code&gt;git reset --merge&lt;/code&gt;. &lt;strong&gt;Warning&lt;/strong&gt;: In older versions of Git, running &lt;code&gt;git pull&lt;/code&gt; with uncommitted changes is discouraged: while possible, it leaves you in a state that may be hard to back out of in the case of a conflict.</source>
          <target state="translated">Git 1.7.0 이상에서 충돌하는 병합을 취소하려면 &lt;code&gt;git reset --merge&lt;/code&gt; 를 사용하십시오 . &lt;strong&gt;경고&lt;/strong&gt; : 이전 버전의 Git에서는 커밋되지 않은 변경 사항으로 &lt;code&gt;git pull&lt;/code&gt; 을 실행 하지 않는 것이 좋습니다. 가능한 경우 충돌이 발생했을 때 되돌릴 수없는 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="e5fbbb479d61fa23b446f30021dbc9109422a0ad" translate="yes" xml:space="preserve">
          <source>In Git like in many other Version Control Systems (VCS), the different states of the data that is managed by the system are called commits. And, as VCS are mostly used to manage software source code, sometimes &quot;interesting&quot; changes of behavior in the software are introduced in some commits.</source>
          <target state="translated">다른 많은 VCS (Version Control Systems)와 마찬가지로 Git에서는 시스템이 관리하는 데이터의 다른 상태를 커밋이라고합니다. 또한 VCS는 주로 소프트웨어 소스 코드를 관리하는 데 사용되므로 소프트웨어의 &quot;흥미로운&quot;동작 변경이 일부 커밋에 도입되기도합니다.</target>
        </trans-unit>
        <trans-unit id="8b9196b57e8598c90aa9a79e64e11940ec4bed09" translate="yes" xml:space="preserve">
          <source>In Git&amp;rsquo;s context, synonym for &lt;a href=&quot;#def_object_name&quot;&gt;object name&lt;/a&gt;.</source>
          <target state="translated">Git의 맥락에서 &lt;a href=&quot;#def_object_name&quot;&gt;object name&lt;/a&gt; 과 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="644d8f376b3ac284860f081b25e96334d4db2911" translate="yes" xml:space="preserve">
          <source>In Git, there are two kinds of tags, a &quot;light&quot; one, and an &quot;annotated tag&quot;.</source>
          <target state="translated">Git에는 &quot;light&quot;태그와 &quot;annotated tag&quot;태그가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e877f57bcce771b4a2551649d22c402a8ae8603" translate="yes" xml:space="preserve">
          <source>In SVN, it is possible (though discouraged) to commit changes to a tag (because a tag is just a directory copy, thus technically the same as a branch). When cloning an SVN repository, &lt;code&gt;git svn&lt;/code&gt; cannot know if such a commit to a tag will happen in the future. Thus it acts conservatively and imports all SVN tags as branches, prefixing the tag name with &lt;code&gt;tags/&lt;/code&gt;.</source>
          <target state="translated">SVN에서는 태그가 변경 사항을 커밋 할 수 있습니다 (태그는 디렉토리 복사본이므로 기술적으로 브랜치와 동일하기 때문에). SVN 저장소를 복제 할 때 &lt;code&gt;git svn&lt;/code&gt; 은 앞으로 태그에 대한 커밋이 발생할지 알 수 없습니다. 따라서 보수적으로 작동하고 모든 SVN 태그를 분기로 가져오고 태그 이름 앞에 &lt;code&gt;tags/&lt;/code&gt; 붙입니다 .</target>
        </trans-unit>
        <trans-unit id="c215580302a5f52c2e27d45d0d7c1d84a4eccdbe" translate="yes" xml:space="preserve">
          <source>In Thunderbird 2: Edit..Preferences..Composition, wrap plain text messages at 0</source>
          <target state="translated">Thunderbird 2 : Edit..Preferences..Composition에서 일반 텍스트 메시지를 0으로 줄 바꿈</target>
        </trans-unit>
        <trans-unit id="f440374532f0b3d43494a1b042e56f8d4bce5f5d" translate="yes" xml:space="preserve">
          <source>In Thunderbird 3: Edit..Preferences..Advanced..Config Editor. Search for &quot;mail.wrap_long_lines&quot;. Toggle it to make sure it is set to &lt;code&gt;false&lt;/code&gt;. Also, search for &quot;mailnews.wraplength&quot; and set the value to 0.</source>
          <target state="translated">Thunderbird 3 : Edit..Preferences..Advanced..Config 편집기에서. &quot;mail.wrap_long_lines&quot;를 검색하십시오. &lt;code&gt;false&lt;/code&gt; 로 설정되도록 전환하십시오 . 또한 &quot;mailnews.wraplength&quot;를 검색하고 값을 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="17583a69f7262368825714769d6089546a690b45" translate="yes" xml:space="preserve">
          <source>In a fast-forward update from A to B, the set of commits that the original commit A built on top of is a subset of the commits the new commit B builds on top of. Hence, it does not lose any history.</source>
          <target state="translated">A에서 B로 빨리 감기에서, 원래 커밋 A가 위에있는 커밋 세트는 새 커밋 B가 위에 커밋하는 커밋의 하위 집합입니다. 따라서 역사를 잃지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d5b5c31f19f75af08174ee7bc83bae8bb6f0e50" translate="yes" xml:space="preserve">
          <source>In a normal repository, this tends to work automatically. The objects are mostly reachable from the branches and tags, and that&amp;rsquo;s what clients fetch. Any deltas we find on the server are likely to be between objects the client has or will have.</source>
          <target state="translated">일반 저장소에서는 자동으로 작동하는 경향이 있습니다. 객체는 대부분 브랜치와 태그에서 접근 할 수 있으며 클라이언트가 가져옵니다. 서버에서 찾은 델타는 클라이언트가 가지고 있거나 가질 수있는 객체 사이에있을 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="8fbcefe66dafd74525f6b8ab70d285c817dc5cf1" translate="yes" xml:space="preserve">
          <source>In a repository using the traditional SHA-1, pack checksums, index checksums, and object IDs (object names) mentioned below are all computed using SHA-1. Similarly, in SHA-256 repositories, these values are computed using SHA-256.</source>
          <target state="translated">기존 SHA-1을 사용하는 저장소에서 아래에 언급 된 팩 체크섬, 인덱스 체크섬 및 개체 ID (개체 이름)는 모두 SHA-1을 사용하여 계산됩니다. 마찬가지로 SHA-256 저장소에서 이러한 값은 SHA-256을 사용하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="566e8925a0c194716258bb9a397f522567172cf6" translate="yes" xml:space="preserve">
          <source>In a situation where topic consisted of three commits, and the maintainer applied two of them, the situation might look like:</source>
          <target state="translated">주제가 3 개의 커밋으로 구성되고 관리자가 2 개의 커밋을 적용한 경우 상황은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee8b5fc930f29435d4aa076d7196ceac4e277fb2" translate="yes" xml:space="preserve">
          <source>In a workflow employing relatively long lived topic branches, the developer sometimes needs to resolve the same conflicts over and over again until the topic branches are done (either merged to the &quot;release&quot; branch, or sent out and accepted upstream).</source>
          <target state="translated">비교적 오래 지속되는 주제 분기를 사용하는 워크 플로우에서 개발자는 주제 분기가 완료 될 때까지 ( &quot;릴리스&quot;분기로 병합되거나 업스트림으로 전송 및 승인 된) 동일한 충돌을 반복해서 해결해야하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7c91952cc20e93e498fb039cc3dfb4469b10f04" translate="yes" xml:space="preserve">
          <source>In addition there are a number of other widely deployed hosting, browsing and reviewing solutions such as:</source>
          <target state="translated">또한 다음과 같은 널리 배포 된 다른 호스팅, 탐색 및 검토 솔루션이 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="666628046a18a0e7af967b1de7c1a7d7baa813ae" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;--full-index&lt;/code&gt;, output a binary diff that can be applied with &lt;code&gt;git-apply&lt;/code&gt;. Implies &lt;code&gt;--patch&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--full-index&lt;/code&gt; 외에도 &lt;code&gt;git-apply&lt;/code&gt; 로 적용 할 수있는 이진 diff를 출력하십시오 . &lt;code&gt;--patch&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="3f6c767f6bc5922d93e508ae1661b26c77720a8f" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;-M&lt;/code&gt;, detect lines moved or copied from other files that were modified in the same commit. This is useful when you reorganize your program and move code around across files. When this option is given twice, the command additionally looks for copies from other files in the commit that creates the file. When this option is given three times, the command additionally looks for copies from other files in any commit.</source>
          <target state="translated">&lt;code&gt;-M&lt;/code&gt; 외에도 동일한 커밋에서 수정 된 다른 파일에서 이동 또는 복사 된 행을 감지합니다. 프로그램을 재구성하고 파일간에 코드를 이동할 때 유용합니다. 이 옵션이 두 번 제공되면 명령은 파일을 작성하는 커밋의 다른 파일에서 사본을 추가로 찾습니다. 이 옵션이 세 번 제공되면 명령은 커밋에서 다른 파일의 복사본을 추가로 찾습니다.</target>
        </trans-unit>
        <trans-unit id="1888d5f31940dfed593ca4ff2d62ba84db0ce760" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;.gitattributes&lt;/code&gt; (per-directory) and &lt;code&gt;.git/info/attributes&lt;/code&gt;, Git looks into this file for attributes (see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;). Path expansions are made the same way as for &lt;code&gt;core.excludesFile&lt;/code&gt;. Its default value is &lt;code&gt;$XDG_CONFIG_HOME/git/attributes&lt;/code&gt;. If &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; is either not set or empty, &lt;code&gt;$HOME/.config/git/attributes&lt;/code&gt; is used instead.</source>
          <target state="translated">뿐만 아니라 &lt;code&gt;.gitattributes&lt;/code&gt; (디렉토리 별) 및 &lt;code&gt;.git/info/attributes&lt;/code&gt; , 속성이 파일에 망할 놈의 외모 (참조 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes을 [5]&lt;/a&gt; ). 경로 확장은 &lt;code&gt;core.excludesFile&lt;/code&gt; 과 동일한 방식으로 이루어집니다 . 기본값은 &lt;code&gt;$XDG_CONFIG_HOME/git/attributes&lt;/code&gt; 입니다. 경우 &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; 하나 설정하거나 비어 있지 않은, &lt;code&gt;$HOME/.config/git/attributes&lt;/code&gt; 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a80ff33db6a243344cb7df3dd9b8d8d41e916e5f" translate="yes" xml:space="preserve">
          <source>In addition to HEAD, there are several other special names for commits:</source>
          <target state="translated">HEAD 외에도 커밋에 대한 몇 가지 다른 특수 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d952784176d6003ec5b2f9f790384bd9b8c8247" translate="yes" xml:space="preserve">
          <source>In addition to being the staging area for new commits, the index file is also populated from the object database when checking out a branch, and is used to hold the trees involved in a merge operation. See &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt; and the relevant man pages for details.</source>
          <target state="translated">새 커밋을위한 준비 영역 일뿐 아니라, 분기를 체크 아웃 할 때 인덱스 파일이 개체 데이터베이스에서 채워지고 병합 작업과 관련된 트리를 보유하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial [7]&lt;/a&gt; 및 관련 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e26ec25b7f02c15aecd179e2dad4bd1f6afe8d5c" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with at most the specified number of one-line descriptions from the actual commits that are being merged. Defaults to false, and true is a synonym for 20.</source>
          <target state="translated">분기 이름 외에도 병합되는 실제 커밋의 최대 한 줄 설명으로 로그 메시지를 채 웁니다. 기본값은 false이며 true는 20과 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="c5e07d7771d3e15091a04a68ed9a697dc979376c" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with one-line descriptions from at most &amp;lt;n&amp;gt; actual commits that are being merged. See also &lt;a href=&quot;git-fmt-merge-msg&quot;&gt;git-fmt-merge-msg[1]&lt;/a&gt;.</source>
          <target state="translated">분기 이름 외에도 병합중인 실제 커밋 최대 &amp;lt;n&amp;gt;에서 한 줄 설명으로 로그 메시지를 채 웁니다. &lt;a href=&quot;git-fmt-merge-msg&quot;&gt;git-fmt-merge-msg [1]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53e8184a4fded8ffd5d3887baaffe37015550f76" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with one-line descriptions from the actual commits that are being merged. At most &amp;lt;n&amp;gt; commits from each merge parent will be used (20 if &amp;lt;n&amp;gt; is omitted). This overrides the &lt;code&gt;merge.log&lt;/code&gt; configuration variable.</source>
          <target state="translated">분기 이름 외에도 병합되는 실제 커밋의 한 줄 설명으로 로그 메시지를 채 웁니다. 각 병합 상위의 최대 &amp;lt;n&amp;gt; 커밋이 사용됩니다 (&amp;lt;n&amp;gt;이 생략 된 경우 20). 이는 &lt;code&gt;merge.log&lt;/code&gt; 구성 변수를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="6235bcb46867554949f149e203ea63eff52ea516" translate="yes" xml:space="preserve">
          <source>In addition to branch names, populate the log message with the branch description text associated with them. Defaults to false.</source>
          <target state="translated">분기 이름 외에도 로그 메시지와 관련된 분기 설명 텍스트를 채 웁니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="f62e3d2f843321847fb42ac94f40312c54d52ccf" translate="yes" xml:space="preserve">
          <source>In addition to labelling blobs and commits with mark ids, also label tags. This is useful in conjunction with &lt;code&gt;--export-marks&lt;/code&gt; and &lt;code&gt;--import-marks&lt;/code&gt;, and is also useful (and necessary) for exporting of nested tags. It does not hurt other cases and would be the default, but many fast-import frontends are not prepared to accept tags with mark identifiers.</source>
          <target state="translated">마크 ID를 사용하여 Blob 및 커밋에 레이블을 지정하는 것 외에도 레이블 태그도 지정합니다. 이는 &lt;code&gt;--export-marks&lt;/code&gt; 및 &lt;code&gt;--import-marks&lt;/code&gt; 와 함께 유용하며 중첩 된 태그를 내보내는데도 유용합니다 (필요한 경우). 다른 경우에는 영향을 미치지 않으며 기본값이지만, 빠른 가져 오기 프런트 엔드는 마크 식별자가있는 태그를 수락 할 준비가되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22782295e6ea8ee2d620246684c55c016d61141f" translate="yes" xml:space="preserve">
          <source>In addition to objects reachable from any of our references, keep objects reachable from listed &amp;lt;head&amp;gt;s.</source>
          <target state="translated">참조에서 접근 할 수있는 객체 외에도 나열된 &amp;lt;head&amp;gt;에서 객체에 접근 할 수 있도록 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="99c28f63ba36fb0fcaa38897708f95d9a693e369" translate="yes" xml:space="preserve">
          <source>In addition to saving you keystrokes, &lt;code&gt;git pull&lt;/code&gt; also helps you by producing a default commit message documenting the branch and repository that you pulled from.</source>
          <target state="translated">키 입력을 저장하는 것 외에도 &lt;code&gt;git pull&lt;/code&gt; 은 가져온 브랜치 및 리포지토리를 설명하는 기본 커밋 메시지를 생성하여 도움을줍니다.</target>
        </trans-unit>
        <trans-unit id="7129d0d8ea665296c3d9391d29a173f1ab2fc5f1" translate="yes" xml:space="preserve">
          <source>In addition to searching in the tracked files in the working tree, search also in untracked files.</source>
          <target state="translated">작업 트리에서 추적 된 파일을 검색 할뿐만 아니라 추적되지 않은 파일도 검색합니다.</target>
        </trans-unit>
        <trans-unit id="d5b7aa3ae2fa07bc2a7838db49f832f9fd332a95" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; markers, it uses another &lt;code&gt;|||||||&lt;/code&gt; marker that is followed by the original text. You can tell that the original just stated a fact, and your side simply gave in to that statement and gave up, while the other side tried to have a more positive attitude. You can sometimes come up with a better resolution by viewing the original.</source>
          <target state="translated">또한받는 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;=======&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 마커는 다른 사용 &lt;code&gt;|||||||&lt;/code&gt; 원본 텍스트 뒤에 표시됩니다. 당신은 원본이 사실을 말했고, 당신의 입장은 단순히 그 진술을 포기하고 포기한 반면, 다른 쪽은 더 긍정적 인 태도를 가지려고 노력했다. 원본을보고 더 나은 해상도를 얻을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a9ee73184ef3bce8e3d7aa50aca9c03ee962a97" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; listed on the command line, read them from the standard input. If a &lt;code&gt;--&lt;/code&gt; separator is seen, stop reading commits and start reading paths to limit the result.</source>
          <target state="translated">명령 행에 나열된 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 외에도 표준 입력에서 읽습니다. 경우 &lt;code&gt;--&lt;/code&gt; 분리가 볼 수, 커밋 읽기를 중단하고 결과를 제한하는 경로를 읽기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="e57f382f37af963780a48b9b24f281a677f73e3f" translate="yes" xml:space="preserve">
          <source>In addition to the above settings, you can change whether TREESAME affects inclusion:</source>
          <target state="translated">위의 설정 외에도 TREESAME가 포함에 영향을 미치는지 여부를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15a1839e21183f6c87dd1989058c966575a3a5b3" translate="yes" xml:space="preserve">
          <source>In addition to the above two patterns, we also expect that all files in the root directory are included. If a recursive pattern is added, then all leading directories are added as parent patterns.</source>
          <target state="translated">위의 두 가지 패턴 외에도 루트 디렉토리의 모든 파일이 포함되어야합니다. 재귀 패턴이 추가되면 모든 선행 디렉토리가 상위 패턴으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5cdd7d140b9026d9dc5fc6d397fdc9a74057bb4e" translate="yes" xml:space="preserve">
          <source>In addition to the above, for commit and tag objects, the header field names (&lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;parent&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, and &lt;code&gt;tag&lt;/code&gt;) can be used to specify the value in the header field.</source>
          <target state="translated">위의 커밋 및 태그 객체의 경우 헤더 필드 이름 ( &lt;code&gt;tree&lt;/code&gt; , &lt;code&gt;parent&lt;/code&gt; , &lt;code&gt;object&lt;/code&gt; , &lt;code&gt;type&lt;/code&gt; 및 &lt;code&gt;tag&lt;/code&gt; )을 사용하여 헤더 필드에 값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cd22d754613826bc7df21407a063908e095a28b" translate="yes" xml:space="preserve">
          <source>In addition to the above, for commit and tag objects, the header field names (&lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;parent&lt;/code&gt;, &lt;code&gt;object&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt;, and &lt;code&gt;tag&lt;/code&gt;) can be used to specify the value in the header field. Fields &lt;code&gt;tree&lt;/code&gt; and &lt;code&gt;parent&lt;/code&gt; can also be used with modifier &lt;code&gt;:short&lt;/code&gt; and &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt; just like &lt;code&gt;objectname&lt;/code&gt;.</source>
          <target state="translated">위의 것 외에도 커밋 및 태그 객체의 경우 헤더 필드 이름 ( &lt;code&gt;tree&lt;/code&gt; , &lt;code&gt;parent&lt;/code&gt; , &lt;code&gt;object&lt;/code&gt; , &lt;code&gt;type&lt;/code&gt; 및 &lt;code&gt;tag&lt;/code&gt; )을 사용하여 헤더 필드의 값을 지정할 수 있습니다. 필드 &lt;code&gt;tree&lt;/code&gt; 및 &lt;code&gt;parent&lt;/code&gt; 는 &lt;code&gt;objectname&lt;/code&gt; 과 같이 수정 자 &lt;code&gt;:short&lt;/code&gt; 및 &lt;code&gt;:short=&amp;lt;length&amp;gt;&lt;/code&gt; 와 함께 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3da373db26873c5d2b59dd68ca741f2f25c73567" translate="yes" xml:space="preserve">
          <source>In addition to the commits shown in the default history, show each merge commit that is not TREESAME to its first parent but is TREESAME to a later parent.</source>
          <target state="translated">기본 기록에 표시된 커밋 외에도 첫 번째 부모에게는 TREESAME이 아니지만 이후 부모에게는 TREESAME 인 각 병합 커밋을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4a3a21fa25ba67eb3d7f9da7f4344fe1b071989c" translate="yes" xml:space="preserve">
          <source>In addition to the names of files that have been changed, also show the textual changes that are staged to be committed (i.e., like the output of &lt;code&gt;git diff --cached&lt;/code&gt;). If &lt;code&gt;-v&lt;/code&gt; is specified twice, then also show the changes in the working tree that have not yet been staged (i.e., like the output of &lt;code&gt;git diff&lt;/code&gt;).</source>
          <target state="translated">변경된 파일 이름 외에도 커밋되기 위해 준비된 텍스트 변경 사항도 표시합니다 (예 : &lt;code&gt;git diff --cached&lt;/code&gt; 출력 ). &lt;code&gt;-v&lt;/code&gt; 를 두 번 지정 하면 아직 준비되지 않은 작업 트리의 변경 사항도 표시됩니다 (예 : &lt;code&gt;git diff&lt;/code&gt; 출력 ).</target>
        </trans-unit>
        <trans-unit id="9d2884340103002807461c187c73c074fbbd3657" translate="yes" xml:space="preserve">
          <source>In addition to the object pointed by it, show the underlying ref pointed by it when showing a symbolic ref. Currently, upload-pack only shows the symref HEAD, so it will be the only one shown by ls-remote.</source>
          <target state="translated">객체가 가리키는 객체 외에도 상징적 참조를 표시 할 때 객체가 가리키는 기본 참조를 표시합니다. 현재 upload-pack은 symref HEAD 만 표시하므로 ls-remote가 표시하는 유일한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6c7a07603f44cd9719a4b680d9f7256b9473029e" translate="yes" xml:space="preserve">
          <source>In addition to the patches, generate a cover letter file containing the branch description, shortlog and the overall diffstat. You can fill in a description in the file before sending it out.</source>
          <target state="translated">패치 외에도 분기 설명, 짧은 로그 및 전체 diffstat를 포함하는 표지 파일을 생성하십시오. 파일을 보내기 전에 파일에 설명을 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="102ba20e10a0928862b597a4b85d8411aa7a16cb" translate="yes" xml:space="preserve">
          <source>In addition to the text-based messages available in &lt;code&gt;GIT_TRACE2&lt;/code&gt;, this setting writes a column-based format for understanding nesting regions. See &lt;code&gt;GIT_TRACE2&lt;/code&gt; for available trace output options and &lt;a href=&quot;api-trace2&quot;&gt;Trace2 documentation&lt;/a&gt; for full details.</source>
          <target state="translated">이 설정은 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 에서 사용 가능한 텍스트 기반 메시지 외에도 중첩 영역을 이해하기위한 열 기반 형식을 작성합니다. 사용 가능한 추적 출력 옵션 은 &lt;code&gt;GIT_TRACE2&lt;/code&gt; 및 자세한 내용은 &lt;a href=&quot;api-trace2&quot;&gt;Trace2 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="547bdce4dd37bfda9e1c54bdf493ad3c6de08ff9" translate="yes" xml:space="preserve">
          <source>In addition, any unrecognized string that has a &lt;code&gt;%&lt;/code&gt; in it is interpreted as if it has &lt;code&gt;tformat:&lt;/code&gt; in front of it. For example, these two are equivalent:</source>
          <target state="translated">또한 &lt;code&gt;%&lt;/code&gt; 가있는 인식 할 수없는 문자열 은 앞에 &lt;code&gt;tformat:&lt;/code&gt; 있는 것처럼 해석됩니다 . 예를 들어,이 두 가지는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="bc74e38407c657e1d62a835de829f2a0637ff932" translate="yes" xml:space="preserve">
          <source>In addition, if the variable is set to &lt;code&gt;af_unix:[&amp;lt;socket_type&amp;gt;:]&amp;lt;absolute-pathname&amp;gt;&lt;/code&gt;, Git will try to open the path as a Unix Domain Socket. The socket type can be either &lt;code&gt;stream&lt;/code&gt; or &lt;code&gt;dgram&lt;/code&gt;.</source>
          <target state="translated">또한 변수가 &lt;code&gt;af_unix:[&amp;lt;socket_type&amp;gt;:]&amp;lt;absolute-pathname&amp;gt;&lt;/code&gt; 으로 설정 되면 Git은 Unix 도메인 소켓으로 경로를 열려고 시도합니다. 소켓 유형은 &lt;code&gt;stream&lt;/code&gt; 또는 &lt;code&gt;dgram&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fdc73bece50193400c9954e5c33b0d5db46ea312" translate="yes" xml:space="preserve">
          <source>In addition, some Git commands (such as &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; and &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;) can also take revision parameters which denote other objects than commits, e.g. blobs (&quot;files&quot;) or trees (&quot;directories of files&quot;).</source>
          <target state="translated">또한 일부 Git 명령 (예 : &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 및 &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; )은 커밋 이외의 다른 객체를 나타내는 수정 매개 변수를 사용할 수도 있습니다 (예 : 얼룩 ( &quot;파일&quot;) 또는 트리 ( &quot;파일 디렉토리&quot;)) ).</target>
        </trans-unit>
        <trans-unit id="9c0114752cc3965279675b92f9d509a7719a899c" translate="yes" xml:space="preserve">
          <source>In addition, the date part is accepted in the following formats: &lt;code&gt;YYYY.MM.DD&lt;/code&gt;, &lt;code&gt;MM/DD/YYYY&lt;/code&gt; and &lt;code&gt;DD.MM.YYYY&lt;/code&gt;.</source>
          <target state="translated">또한 날짜 부분은 &lt;code&gt;YYYY.MM.DD&lt;/code&gt; , &lt;code&gt;MM/DD/YYYY&lt;/code&gt; 및 &lt;code&gt;DD.MM.YYYY&lt;/code&gt; 형식으로 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b090b5874a4f9cb2a75963ffefe67f7cff33a14b" translate="yes" xml:space="preserve">
          <source>In addition, the following pairs of options are incompatible:</source>
          <target state="translated">또한 다음 옵션 쌍은 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9eac4f7a75d08c8d5ecd2f93cae76dbdd2c65fb" translate="yes" xml:space="preserve">
          <source>In addition, there are a number of optional keys:</source>
          <target state="translated">또한 여러 개의 선택적 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3170175bde47695f8d16d1aa859fc39830538d4d" translate="yes" xml:space="preserve">
          <source>In all &quot;keep index&quot; cases, the index entry stays as in the original index file. If the entry is not up to date, &lt;code&gt;git read-tree&lt;/code&gt; keeps the copy in the work tree intact when operating under the -u flag.</source>
          <target state="translated">모든 &quot;인덱스 유지&quot;사례에서 인덱스 항목은 원본 인덱스 파일과 동일하게 유지됩니다. 항목이 최신이 아닌 경우, &lt;code&gt;git read-tree&lt;/code&gt; 는 -u 플래그로 작동 할 때 작업 트리의 사본을 그대로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="518e45973547d44ae8b0cf643cea7c8e1439a6f7" translate="yes" xml:space="preserve">
          <source>In all of these cases, the commands themselves first optionally limit the two sets of files by any pathspecs given on their command-lines, and compare corresponding paths in the two resulting sets of files.</source>
          <target state="translated">이러한 모든 경우에, 명령 자체는 먼저 명령 행에 제공된 경로 스펙에 의해 두 파일 세트를 선택적으로 제한하고 두 결과 파일 세트의 해당 경로를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="a976d8376129a573bbe9b45628bf2bdf5e1fe7e1" translate="yes" xml:space="preserve">
          <source>In an environment that restricts the users' access only to git commands over the wire, this hook can be used to implement access control without relying on filesystem ownership and group membership. See &lt;a href=&quot;git-shell&quot;&gt;git-shell[1]&lt;/a&gt; for how you might use the login shell to restrict the user&amp;rsquo;s access to only git commands.</source>
          <target state="translated">유선을 통해 git 명령에 대해서만 사용자의 액세스를 제한하는 환경에서이 후크는 파일 시스템 소유권 및 그룹 멤버쉽에 의존하지 않고 액세스 제어를 구현하는 데 사용될 수 있습니다. 로그인 쉘을 사용하여 git 명령으로 만 사용자의 액세스를 제한하는 방법 은 &lt;a href=&quot;git-shell&quot;&gt;git-shell [1]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9220471bbc29ec41ed13c216a79cb80f852ef698" translate="yes" xml:space="preserve">
          <source>In any case, a field name that refers to a field inapplicable to the object referred by the ref does not cause an error. It returns an empty string instead.</source>
          <target state="translated">어쨌든 ref가 참조하는 객체에 적용 할 수없는 필드를 나타내는 필드 이름은 오류를 발생시키지 않습니다. 대신 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3ed3c4a7faef04068c3d21c5e427f36b63dea04c" translate="yes" xml:space="preserve">
          <source>In both cases, all bytes are treated as-is (i.e., there is no quoting, and one cannot transmit a value with newline or NUL in it). The list of attributes is terminated by a blank line or end-of-file.</source>
          <target state="translated">두 경우 모두 모든 바이트는있는 그대로 처리됩니다 (즉, 인용문이 없으며 그 안에 개행 문자 나 NUL이있는 값을 전송할 수 없습니다). 속성 목록은 빈 줄이나 파일 끝으로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="55cc553818c07e93d42b2d9a9da22e8f0487ba9d" translate="yes" xml:space="preserve">
          <source>In both formats &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is any of the commit specification expressions also accepted by &lt;code&gt;from&lt;/code&gt; (see above).</source>
          <target state="translated">두 형식 모두에서 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 는 &lt;code&gt;from&lt;/code&gt; 에 의해 허용되는 커밋 사양 표현식 중 하나 입니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="9838d0f6a0615e5345bacba941fa3a7ae58fc03e" translate="yes" xml:space="preserve">
          <source>In both formats &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is the type of file entry, specified in octal. Git only supports the following modes:</source>
          <target state="translated">두 가지 형식 모두에서 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 는 8 진수로 지정된 파일 항목 유형입니다. Git은 다음 모드 만 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="e124f640b7099c2dfc555e83763a437b341aea9d" translate="yes" xml:space="preserve">
          <source>In both formats &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; is the complete path of the file to be added (if not already existing) or modified (if already existing).</source>
          <target state="translated">두 가지 형식 모두에서 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 는 추가하거나 (존재하지 않는 경우) 수정 (존재하는 경우) 할 파일의 전체 경로입니다.</target>
        </trans-unit>
        <trans-unit id="e22465a192b99fdb8a38ceb6e2163b1bb2a55eaa" translate="yes" xml:space="preserve">
          <source>In both formats RS (the record separator) is newline by default but will be the null byte if -z was passed on the command line. The temporary file names are always safe strings; they will never contain directory separators or whitespace characters. The path field is always relative to the current directory and the temporary file names are always relative to the top level directory.</source>
          <target state="translated">두 형식 모두 RS (레코드 구분 기호)는 기본적으로 줄 바꿈이지만 명령 줄에 -z가 전달되면 널 바이트가됩니다. 임시 파일 이름은 항상 안전한 문자열입니다. 디렉토리 구분 기호 나 공백 문자는 절대 포함하지 않습니다. 경로 필드는 항상 현재 디렉토리를 기준으로하며 임시 파일 이름은 항상 최상위 디렉토리를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="bbdfd88cae7c8d5fe4027454edb7c9f3a518f214" translate="yes" xml:space="preserve">
          <source>In both rename and copy detection, the same &quot;extent of changes&quot; algorithm used in diffcore-break is used to determine if two files are &quot;similar enough&quot;, and can be customized to use a similarity score different from the default of 50% by giving a number after the &quot;-M&quot; or &quot;-C&quot; option (e.g. &quot;-M8&quot; to tell it to use 8/10 = 80%).</source>
          <target state="translated">이름 바꾸기 및 복사 감지에서 diffcore-break에 사용 된 동일한 &quot;extent of changes&quot;알고리즘을 사용하여 두 파일이 &quot;충분히 유사한 지&quot;판별하고 기본값 50 %와 다른 유사성 점수를 사용하도록 사용자 정의 할 수 있습니다. &quot;-M&quot;또는 &quot;-C&quot;옵션 다음에 숫자를 지정합니다 (예 : 8/10 = 80 %를 사용하도록 &quot;-M8&quot;).</target>
        </trans-unit>
        <trans-unit id="cef1680a7a27c73f800aa2ae728f37bb9ebeed5c" translate="yes" xml:space="preserve">
          <source>In case &amp;lt;old&amp;gt; and &amp;lt;new&amp;gt; are the same, and &amp;lt;old&amp;gt; is a file under &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; or &lt;code&gt;$GIT_DIR/branches&lt;/code&gt;, the remote is converted to the configuration file format.</source>
          <target state="translated">&amp;lt;old&amp;gt;와 &amp;lt;new&amp;gt;가 동일하고 &amp;lt;old&amp;gt;가 &lt;code&gt;$GIT_DIR/remotes&lt;/code&gt; 또는 &lt;code&gt;$GIT_DIR/branches&lt;/code&gt; 아래에있는 파일 인 경우, 리모트는 구성 파일 형식으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="77e55c61e61a6a73beec771303a37403de7ae828" translate="yes" xml:space="preserve">
          <source>In case (some of) these environment variables are not set, the information is taken from the configuration items &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt;, or, if not present, the environment variable EMAIL, or, if that is not set, system user name and the hostname used for outgoing mail (taken from &lt;code&gt;/etc/mailname&lt;/code&gt; and falling back to the fully qualified hostname when that file does not exist).</source>
          <target state="translated">이러한 환경 변수 (일부)가 설정되지 않은 경우 정보는 구성 항목 &lt;code&gt;user.name&lt;/code&gt; 및 &lt;code&gt;user.email&lt;/code&gt; 에서 가져 오거나 존재하지 않는 경우 환경 변수 EMAIL 또는 설정되지 않은 경우 시스템 사용자 에서 가져옵니다. 보내는 메일에 사용되는 이름 및 호스트 이름 ( &lt;code&gt;/etc/mailname&lt;/code&gt; 에서 가져와 해당 파일이없는 경우 정규화 된 호스트 이름으로 대체 됨 )</target>
        </trans-unit>
        <trans-unit id="3736cf7c9e88d8830feeb4facce5d47bac7822e0" translate="yes" xml:space="preserve">
          <source>In case (some of) these environment variables are not set, the information is taken from the configuration items user.name and user.email, or, if not present, the environment variable EMAIL, or, if that is not set, system user name and the hostname used for outgoing mail (taken from &lt;code&gt;/etc/mailname&lt;/code&gt; and falling back to the fully qualified hostname when that file does not exist).</source>
          <target state="translated">이러한 환경 변수 중 일부가 설정되지 않은 경우 구성 항목 user.name 및 user.email 또는 환경 변수 EMAIL (설정되지 않은 경우 시스템 사용자)에서 정보를 가져옵니다. 발신 메일에 사용되는 이름 및 호스트 이름 ( &lt;code&gt;/etc/mailname&lt;/code&gt; 에서 가져와 해당 파일이 없을 때 정규화 된 호스트 이름으로 폴백 )</target>
        </trans-unit>
        <trans-unit id="fab172a52a0d96a15d352f159439993a534e8fe5" translate="yes" xml:space="preserve">
          <source>In case of conflict, &lt;code&gt;git rebase&lt;/code&gt; will stop at the first problematic commit and leave conflict markers in the tree. You can use &lt;code&gt;git diff&lt;/code&gt; to locate the markers (&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;) and make edits to resolve the conflict. For each file you edit, you need to tell Git that the conflict has been resolved, typically this would be done with</source>
          <target state="translated">충돌이 발생하는 경우, &lt;code&gt;git rebase&lt;/code&gt; 는 문제가있는 첫 번째 커밋에서 중지하고 충돌 마커를 트리에 남겨 둡니다. &lt;code&gt;git diff&lt;/code&gt; 를 사용 하여 마커 (&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;)를 찾고 편집하여 충돌을 해결할 수 있습니다. 편집하는 각 파일에 대해 Git에 충돌이 해결되었음을 알려야합니다.</target>
        </trans-unit>
        <trans-unit id="8de3ddb587a19db9387af113a7f3cb72b19328d0" translate="yes" xml:space="preserve">
          <source>In case of failure in the output of &lt;a href=&quot;git-rm&quot;&gt;git-rm[1]&lt;/a&gt;, show directions on how to proceed from the current state.</source>
          <target state="translated">&lt;a href=&quot;git-rm&quot;&gt;git-rm [1]&lt;/a&gt; 출력에 실패한 경우 현재 상태에서 진행하는 방법에 대한 지시 사항을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="1ca6e2b22c66fb3bb4920e7b16e070cab433e13d" translate="yes" xml:space="preserve">
          <source>In case the filter cannot or does not want to process the content as well as any future content for the lifetime of the Git process, then it is expected to respond with an &quot;abort&quot; status at any point in the protocol.</source>
          <target state="translated">필터가 Git 프로세스의 수명 동안 컨텐츠 및 향후 컨텐츠를 처리 할 수 ​​없거나 처리하지 않으려는 경우, 프로토콜의 어느 시점에서나 &quot;중단&quot;상태로 응답 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="a44b155f3278323b322b1edffc06fec805c87137" translate="yes" xml:space="preserve">
          <source>In case the filter cannot or does not want to process the content, it is expected to respond with an &quot;error&quot; status.</source>
          <target state="translated">필터가 내용을 처리 할 수 ​​없거나 처리하지 않으려는 경우 &quot;오류&quot;상태로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="063d2c577358a9002bf9810cc43ec764ca0682e1" translate="yes" xml:space="preserve">
          <source>In command synopses, the word &quot;tree-ish&quot; is sometimes used to designate such an argument.</source>
          <target state="translated">명령 시놉시스에서, &quot;tree-ish&quot;라는 단어는 때때로 그러한 주장을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0cb56babf143d18da14e8d5b38b880de0eb432ae" translate="yes" xml:space="preserve">
          <source>In compact output mode, specified with configuration variable fetch.output, if either entire &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; is found in the other string, it will be substituted with &lt;code&gt;*&lt;/code&gt; in the other string. For example, &lt;code&gt;master -&amp;gt; origin/master&lt;/code&gt; becomes &lt;code&gt;master -&amp;gt; origin/*&lt;/code&gt;.</source>
          <target state="translated">구성 변수 fetch.output으로 지정된 컴팩트 출력 모드에서 전체 &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; 가 다른 문자열에서 발견되면 다른 문자열에서 &lt;code&gt;*&lt;/code&gt; 로 대체됩니다 . 예를 들어 &lt;code&gt;master -&amp;gt; origin/master&lt;/code&gt; 는 &lt;code&gt;master -&amp;gt; origin/*&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="17a206b483cbd4faf3ff1c681d69d041ba456195" translate="yes" xml:space="preserve">
          <source>In contrast to a regular interactive rebase, there are &lt;code&gt;label&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt; and &lt;code&gt;merge&lt;/code&gt; commands in addition to &lt;code&gt;pick&lt;/code&gt; ones.</source>
          <target state="translated">일반 대화 REBASE 대조적으로, 거기 &lt;code&gt;label&lt;/code&gt; , &lt;code&gt;reset&lt;/code&gt; 및 &lt;code&gt;merge&lt;/code&gt; 에 추가 명령을 &lt;code&gt;pick&lt;/code&gt; 것들.</target>
        </trans-unit>
        <trans-unit id="a91f8ccdcda758152dfb84f7e032555a6abd0478" translate="yes" xml:space="preserve">
          <source>In contrast, a non-fast-forward update will lose history. For example, suppose you and somebody else started at the same commit X, and you built a history leading to commit B while the other person built a history leading to commit A. The history looks like this:</source>
          <target state="translated">반대로 빨리 감기가 아닌 업데이트는 기록을 잃게됩니다. 예를 들어, 당신과 다른 누군가가 동일한 커밋 X에서 시작했다고 가정하고 B가 커밋하는 히스토리를 작성하고 다른 사람이 커밋 A로 이어지는 히스토리를 빌드했다고 가정하십시오. 히스토리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="732c99dfb4118d47f73ec2f7f549a4abcdf7b217" translate="yes" xml:space="preserve">
          <source>In detecting regressions introduced through the merging of a branch, the merge commit will be identified as introduction of the bug and its ancestors will be ignored.</source>
          <target state="translated">분기 병합을 통해 발생한 회귀를 감지 할 때 병합 커밋은 버그의 도입으로 식별되고 해당 조상은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="07b2f985753911580a2527f5513df7870e7e2eaf" translate="yes" xml:space="preserve">
          <source>In editing files, git-filter-branch by design checks out each and every commit as it existed in the original repo. If your repo has 10\^5 files and 10\^5 commits, but each commit only modifies 5 files, then git-filter-branch will make you do 10\^10 modifications, despite only having (at most) 5*10^5 unique blobs.</source>
          <target state="translated">파일을 편집 할 때 git-filter-branch는 의도적으로 원래 저장소에 존재하는 모든 커밋을 체크 아웃합니다. 리포지토리에 10 \ ^ 5 개의 파일과 10 \ ^ 5 개의 커밋이 있지만 각 커밋이 5 개의 파일 만 수정하면 git-filter-branch는 (최대) 5 * 10 만 있음에도 불구하고 10 \ ^ 10 수정을 수행합니다. ^ 5 개의 독특한 얼룩.</target>
        </trans-unit>
        <trans-unit id="2e3fe33f9a577c2f8225b1f2426166ec832bed24" translate="yes" xml:space="preserve">
          <source>In editing files, git-filter-branch by design checks out each and every commit as it existed in the original repo. If your repo has &lt;code&gt;10^5&lt;/code&gt; files and &lt;code&gt;10^5&lt;/code&gt; commits, but each commit only modifies five files, then git-filter-branch will make you do &lt;code&gt;10^10&lt;/code&gt; modifications, despite only having (at most) &lt;code&gt;5*10^5&lt;/code&gt; unique blobs.</source>
          <target state="translated">파일을 편집 할 때 git-filter-branch는 원래 저장소에있는 커밋을 각각 확인합니다. repo에 &lt;code&gt;10^5&lt;/code&gt; 파일과 &lt;code&gt;10^5&lt;/code&gt; 커밋이 있지만 각 커밋은 5 개의 파일 만 수정하는 경우 git-filter-branch는 (최대) &lt;code&gt;5*10^5&lt;/code&gt; 고유 한 항목 만 있음에도 불구하고 &lt;code&gt;10^10&lt;/code&gt; 수정 을 수행 합니다. 얼룩.</target>
        </trans-unit>
        <trans-unit id="a532459a44f155e770ddc46e416638b81292d839" translate="yes" xml:space="preserve">
          <source>In either format, values can be specified in any form that Git recognizes as an object name. Commands in any other format or a repeated &amp;lt;ref&amp;gt; produce an error. Command meanings are:</source>
          <target state="translated">어느 형식이든 값을 Git이 객체 이름으로 인식하는 모든 형식으로 지정할 수 있습니다. 다른 형식의 명령이나 반복되는 &amp;lt;ref&amp;gt; 명령은 오류를 생성합니다. 명령 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c49e183be0df7128f7b7d238522888866505455" translate="yes" xml:space="preserve">
          <source>In fact development teams often maintain both a development branch and a maintenance branch, and it would be quite easy for them if &quot;git bisect&quot; just worked when they want to bisect a regression on the development branch that is not on the maintenance branch. They should be able to start bisecting using:</source>
          <target state="translated">실제로 개발 팀은 종종 개발 브랜치와 유지 관리 브랜치를 모두 유지 관리하며 유지 관리 브랜치가 아닌 개발 브랜치에서 회귀를 이등분하려고 할 때 &quot;git bisect&quot;가 제대로 작동하면 매우 쉽습니다. 다음을 사용하여 이등분을 시작할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="49c9270dc1d07096e092a06d8107784ae1248f61" translate="yes" xml:space="preserve">
          <source>In fact it&amp;rsquo;s invaluable because there are bugs i would never even &lt;code&gt;try&lt;/code&gt; to debug if it wasn&amp;rsquo;t for git bisect. In the past there were bug patterns that were immediately hopeless for me to debug - at best i could send the crash/bug signature to lkml and hope that someone else can think of something.</source>
          <target state="translated">사실 git bisect가 아닌 경우 디버깅을 &lt;code&gt;try&lt;/code&gt; 하지 않는 버그가 있기 때문에 매우 중요 합니다. 과거에는 즉시 디버그 할 수 없었던 버그 패턴이있었습니다. 기껏해야 충돌 / 버그 서명을 lkml에 보내고 다른 사람이 무언가를 생각할 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="4d0defa9e6e327fdaa3580beb798bb05e9bb4ad4" translate="yes" xml:space="preserve">
          <source>In fact it&amp;rsquo;s this last feature that &quot;sold&quot; it to the Git community, so it is now in the &quot;master&quot; branch of Git&amp;rsquo;s Git repository and it should be released in Git 1.6.5 in October or November 2009.</source>
          <target state="translated">실제로이 기능은 Git 커뮤니티에 &quot;판매 된&quot;마지막 기능이므로 이제 Git Git 저장소의 &quot;마스터&quot;브랜치에 있으며 2009 년 10 월 또는 11 월에 Git 1.6.5에 출시 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="a503332ebe0b76ca226cc7fab9355da1cbc846ca" translate="yes" xml:space="preserve">
          <source>In fact people are specially interested in commits that introduce a &quot;bad&quot; behavior, called a bug or a regression. They are interested in these commits because a commit (hopefully) contains a very small set of source code changes. And it&amp;rsquo;s much easier to understand and properly fix a problem when you only need to check a very small set of changes, than when you don&amp;rsquo;t know where look in the first place.</source>
          <target state="translated">실제로 사람들은 버그 나 회귀라고하는 &quot;나쁜&quot;행동을 일으키는 커밋에 특히 관심이 있습니다. 커밋은 (아마도) 아주 작은 소스 코드 변경 사항을 포함하기 때문에 이러한 커밋에 관심이 있습니다. 또한 처음 어디에서 보이는지 알지 못하는 경우보다 아주 작은 변경 사항 만 확인하면 문제를 이해하고 올바르게 수정하는 것이 훨씬 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="ef62eb9471b68497e696b504f306bae12d5b62ac" translate="yes" xml:space="preserve">
          <source>In fact the problem is that big software often has many different configuration options and that each test case should pass for each configuration after each commit. So if you have for each release: N configurations, M commits and T test cases, you should perform:</source>
          <target state="translated">실제로 문제는 큰 소프트웨어에는 종종 여러 가지 구성 옵션이 있으며 각 테스트 사례는 각 커밋 후에 각 구성에 대해 통과해야한다는 것입니다. 따라서 각 릴리스 (N 구성, M 커밋 및 T 테스트 사례)가있는 경우 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="99977c45d37760acd8d4612dba46dd63b60c39cd" translate="yes" xml:space="preserve">
          <source>In fact, &lt;code&gt;git bisect&lt;/code&gt; can be used to find the commit that changed &lt;strong&gt;any&lt;/strong&gt; property of your project; e.g., the commit that fixed a bug, or the commit that caused a benchmark&amp;rsquo;s performance to improve. To support this more general usage, the terms &quot;old&quot; and &quot;new&quot; can be used in place of &quot;good&quot; and &quot;bad&quot;, or you can choose your own terms. See section &quot;Alternate terms&quot; below for more information.</source>
          <target state="translated">사실, &lt;code&gt;git bisect&lt;/code&gt; (가) 그 변경 커밋 찾을 수 있습니다 &lt;strong&gt;어떤&lt;/strong&gt; 프로젝트의 속성, 예를 들어, 버그를 수정 한 커밋 또는 벤치 마크 성능을 향상시키는 커밋. 보다 일반적인 사용법을 지원하기 위해 &quot;오래된&quot;및 &quot;새로운&quot;이라는 용어를 &quot;좋은&quot;및 &quot;나쁜&quot;대신 사용하거나 원하는 용어를 선택할 수 있습니다. 자세한 내용은 아래의 &quot;대체 용어&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7071f9821fe5bdd2a61f333d551d92b1d1a7cc62" translate="yes" xml:space="preserve">
          <source>In fact, &lt;code&gt;git diff-index --cached&lt;/code&gt;&lt;strong&gt;should&lt;/strong&gt; always be entirely equivalent to actually doing a &lt;code&gt;git write-tree&lt;/code&gt; and comparing that. Except this one is much nicer for the case where you just want to check where you are.</source>
          <target state="translated">실제로 &lt;code&gt;git diff-index --cached&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 항상 실제로 &lt;code&gt;git write-tree&lt;/code&gt; 를 수행 하고 비교하는 것과 완전히 동일 &lt;strong&gt;해야&lt;/strong&gt; 합니다. 이것을 제외하고는 당신이 어디에 있는지 확인하고 싶을 때 훨씬 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4ed30cb15a7bebad154936439885b3df49088a74" translate="yes" xml:space="preserve">
          <source>In fact, as you did that, if you now look into your object directory, you&amp;rsquo;ll notice that Git will have added two new objects to the object database. If you did exactly the steps above, you should now be able to do</source>
          <target state="translated">실제로 그렇게했던 것처럼, 이제 객체 디렉토리를 살펴보면 Git이 객체 데이터베이스에 두 개의 새로운 객체를 추가 한 것을 알 수 있습니다. 위의 단계를 정확하게 수행했다면 이제 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c9492aea4e59a8249b05f0197902254019664286" translate="yes" xml:space="preserve">
          <source>In fact, if you have &lt;code&gt;master&lt;/code&gt; checked out, then this branch has been configured by &lt;code&gt;git clone&lt;/code&gt; to get changes from the HEAD branch of the origin repository. So often you can accomplish the above with just a simple</source>
          <target state="translated">실제로 &lt;code&gt;master&lt;/code&gt; 체크 아웃 한 경우이 분기는 &lt;code&gt;git clone&lt;/code&gt; 에 의해 오리진 저장소의 HEAD 분기에서 변경 사항을 가져 오도록 구성되었습니다 . 종종 간단한 방법으로 위의 내용을 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5bd224f8ecefe700eae1705d4f2a63ae227649f" translate="yes" xml:space="preserve">
          <source>In fact, in &lt;a href=&quot;#git-concepts&quot;&gt;Git concepts&lt;/a&gt; we shall see that everything stored in Git history, including file data and directory contents, is stored in an object with a name that is a hash of its contents.</source>
          <target state="translated">실제로 &lt;a href=&quot;#git-concepts&quot;&gt;Git 개념&lt;/a&gt; 에서는 파일 데이터 및 디렉토리 내용을 포함하여 Git 기록에 저장된 모든 내용이 해당 내용의 해시 이름을 가진 객체에 저장되어 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ce4601e5a5f52f186df099525d9504862a821c8" translate="yes" xml:space="preserve">
          <source>In fact, together with the &lt;code&gt;git rev-list&lt;/code&gt; program (which generates a list of revisions), &lt;code&gt;git diff-tree&lt;/code&gt; ends up being a veritable fount of changes. You can emulate &lt;code&gt;git log&lt;/code&gt;, &lt;code&gt;git log -p&lt;/code&gt;, etc. with a trivial script that pipes the output of &lt;code&gt;git rev-list&lt;/code&gt; to &lt;code&gt;git diff-tree --stdin&lt;/code&gt;, which was exactly how early versions of &lt;code&gt;git log&lt;/code&gt; were implemented.</source>
          <target state="translated">사실, &lt;code&gt;git rev-list&lt;/code&gt; 프로그램 ( 개정판 목록 을 생성 함)과 함께 &lt;code&gt;git diff-tree&lt;/code&gt; 는 실제로 변경 사항이 있습니다. 당신은 에뮬레이션 할 수 있습니다 &lt;code&gt;git log&lt;/code&gt; , &lt;code&gt;git log -p&lt;/code&gt; 사소한 스크립트 등, 그 파이프의 출력 &lt;code&gt;git rev-list&lt;/code&gt; 에 &lt;code&gt;git diff-tree --stdin&lt;/code&gt; 의 초기 버전 정확히 어떻게했다, &lt;code&gt;git log&lt;/code&gt; 구현되었다.</target>
        </trans-unit>
        <trans-unit id="da9de14a63db6e5a8e5a19a81e9a6160f95eb222" translate="yes" xml:space="preserve">
          <source>In fact, we can perform all the normal Git operations. But, let&amp;rsquo;s look at what happens when we then checkout &lt;code&gt;master&lt;/code&gt;:</source>
          <target state="translated">사실, 우리는 모든 정상적인 Git 작업을 수행 할 수 있습니다. 하지만 &lt;code&gt;master&lt;/code&gt; 를 체크 아웃 할 때 어떤 일이 발생하는지 봅시다 :</target>
        </trans-unit>
        <trans-unit id="728d90294e037628a986d3380572564cc895d389" translate="yes" xml:space="preserve">
          <source>In future versions we may learn to support patterns containing \0 for more search backends, until then we&amp;rsquo;ll die when the pattern type in question doesn&amp;rsquo;t support them.</source>
          <target state="translated">이후 버전에서는 더 많은 검색 백엔드에 대해 \ 0을 포함하는 패턴을 지원하는 방법을 배울 수 있습니다. 그때까지는 해당 패턴 유형이 지원하지 않으면 죽을 것입니다.</target>
        </trans-unit>
        <trans-unit id="674a2666658c40a25d4cd65b3ea28af975f1fa97" translate="yes" xml:space="preserve">
          <source>In general a client can request to speak protocol v2 by sending &lt;code&gt;version=2&lt;/code&gt; through the respective side-channel for the transport being used which inevitably sets &lt;code&gt;GIT_PROTOCOL&lt;/code&gt;. More information can be found in &lt;code&gt;pack-protocol.txt&lt;/code&gt; and &lt;code&gt;http-protocol.txt&lt;/code&gt;. In all cases the response from the server is the capability advertisement.</source>
          <target state="translated">일반적으로 클라이언트 는 &lt;code&gt;GIT_PROTOCOL&lt;/code&gt; 을 설정하는 사용중인 전송에 대해 각 사이드 채널을 통해 &lt;code&gt;version=2&lt;/code&gt; 를 전송하여 프로토콜 v2 말하기를 요청할 수 있습니다 . 자세한 정보는 &lt;code&gt;pack-protocol.txt&lt;/code&gt; 및 &lt;code&gt;http-protocol.txt&lt;/code&gt; 에서 찾을 수 있습니다 . 모든 경우에 서버의 응답은 기능 알림입니다.</target>
        </trans-unit>
        <trans-unit id="1aaa12db7c29bdac4538baf95940db6bed82a0b8" translate="yes" xml:space="preserve">
          <source>In general, URLs contain information about the transport protocol, the address of the remote server, and the path to the repository. Depending on the transport protocol, some of this information may be absent.</source>
          <target state="translated">일반적으로 URL에는 전송 프로토콜, 원격 서버 주소 및 리포지토리 경로에 대한 정보가 포함됩니다. 전송 프로토콜에 따라이 정보 중 일부가 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="811906db3a55c059a1cd7d72b959827c93f94a02" translate="yes" xml:space="preserve">
          <source>In general, all pseudo refs are per working tree and all refs starting with &quot;refs/&quot; are shared. Pseudo refs are ones like HEAD which are directly under GIT_DIR instead of inside GIT_DIR/refs. There is one exception to this: refs inside refs/bisect and refs/worktree is not shared.</source>
          <target state="translated">일반적으로 모든 의사 참조는 작업 트리 당이며 &quot;refs /&quot;로 시작하는 모든 참조는 공유됩니다. 의사 참조는 HEAD와 같은 것으로, GIT_DIR / refs 대신 GIT_DIR 바로 아래에 있습니다. 이에 대한 한 가지 예외가 있습니다. refs / bisect 내부의 refs 및 refs / worktree는 공유되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1959905d09bef6c12ae8c7983e3b002ca1126c5" translate="yes" xml:space="preserve">
          <source>In general, all pseudo refs are per working tree and all refs starting with &lt;code&gt;refs/&lt;/code&gt; are shared. Pseudo refs are ones like &lt;code&gt;HEAD&lt;/code&gt; which are directly under &lt;code&gt;$GIT_DIR&lt;/code&gt; instead of inside &lt;code&gt;$GIT_DIR/refs&lt;/code&gt;. There are exceptions, however: refs inside &lt;code&gt;refs/bisect&lt;/code&gt; and &lt;code&gt;refs/worktree&lt;/code&gt; are not shared.</source>
          <target state="translated">일반적으로 모든 의사 참조는 작업 트리마다 있으며 &lt;code&gt;refs/&lt;/code&gt; 로 시작하는 모든 참조 는 공유됩니다. 의사 참조는 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 내부가 아니라 &lt;code&gt;$GIT_DIR&lt;/code&gt; 바로 아래에있는 &lt;code&gt;HEAD&lt;/code&gt; 와 같은 것 입니다. 그러나 예외가 있습니다. refs &lt;code&gt;refs/bisect&lt;/code&gt; 및 &lt;code&gt;refs/worktree&lt;/code&gt; 내의 ref 는 공유되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e394e7bf320940c252fcc858f73aeff38e0e3c05" translate="yes" xml:space="preserve">
          <source>In general, it is better to enumerate existing objects with problems with &lt;code&gt;fsck.skipList&lt;/code&gt;, instead of listing the kind of breakages these problematic objects share to be ignored, as doing the latter will allow new instances of the same breakages go unnoticed.</source>
          <target state="translated">일반적으로 &lt;code&gt;fsck.skipList&lt;/code&gt; 와 관련된 문제가있는 기존 객체를 열거하는 것이 좋습니다. 문제가있는 객체가 무시할 종류의 파손을 나열하는 대신이를 무시하면 동일한 파손의 새 인스턴스가 눈에 띄지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="7dc03507399a3b4938c051e86309da2b5ba01f5b" translate="yes" xml:space="preserve">
          <source>In general, the interrogate commands do not touch the files in the working tree.</source>
          <target state="translated">일반적으로 질문 명령은 작업 트리의 파일을 건드리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0830c69bce9b1a4ab3ff9dbb3ca0e63e381af048" translate="yes" xml:space="preserve">
          <source>In general, using</source>
          <target state="translated">일반적으로</target>
        </trans-unit>
        <trans-unit id="37034b2d8b34e79ca4767d593d59ca39d0651fd5" translate="yes" xml:space="preserve">
          <source>In here all submodules except &lt;code&gt;baz&lt;/code&gt; (foo, bar, bob) are active. &lt;code&gt;foo&lt;/code&gt; due to its own active flag and all the others due to the submodule active pathspec, which specifies that any submodule starting with &lt;code&gt;b&lt;/code&gt; except &lt;code&gt;baz&lt;/code&gt; are also active, regardless of the presence of the .url field.</source>
          <target state="translated">여기에서 &lt;code&gt;baz&lt;/code&gt; (foo, bar, bob)를 제외한 모든 하위 모듈 이 활성화됩니다. &lt;code&gt;foo&lt;/code&gt; 에 의한 자체 활성 플래그 인한 서브 모듈로 시작 함을 지정하는 서브 모듈 활성 pathspec, 모든 다른 행 &lt;code&gt;b&lt;/code&gt; 제외 &lt;code&gt;baz&lt;/code&gt; 관계없이 .URL 필드의 존재, 또한 활성.</target>
        </trans-unit>
        <trans-unit id="f129c819372eb3b42173e4b2d9e114ef285b7635" translate="yes" xml:space="preserve">
          <source>In interactive commands, allow the user to provide one-letter input with a single key (i.e., without hitting enter). Currently this is used by the &lt;code&gt;--patch&lt;/code&gt; mode of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;, &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;, &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt;, &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;, &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt;, and &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;. Note that this setting is silently ignored if portable keystroke input is not available; requires the Perl module Term::ReadKey.</source>
          <target state="translated">대화식 명령에서 사용자는 단일 문자 입력으로 단일 키를 제공 할 수 있습니다 (예 : Enter 키를 누르지 않음). 현재 이것은 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; , &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; , &lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt; , &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; , &lt;a href=&quot;git-reset&quot;&gt;git-reset [1]&lt;/a&gt; 및 &lt;a href=&quot;git-stash&quot;&gt;git-stash &lt;/a&gt; &lt;code&gt;--patch&lt;/code&gt; 모드에서 사용됩니다 [1] . 휴대용 키 입력을 사용할 수없는 경우이 설정은 자동으로 무시됩니다. Perl 모듈 Term :: ReadKey가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1d1c8ed607ef3eefbb04beacb314688e02741550" translate="yes" xml:space="preserve">
          <source>In interactive mode, you can mark commits with the action &quot;edit&quot;. However, this does not necessarily mean that &lt;code&gt;git rebase&lt;/code&gt; expects the result of this edit to be exactly one commit. Indeed, you can undo the commit, or you can add other commits. This can be used to split a commit into two:</source>
          <target state="translated">대화식 모드에서 &quot;edit&quot;조치로 커미트를 표시 할 수 있습니다. 그러나 이것이 반드시 &lt;code&gt;git rebase&lt;/code&gt; 가이 편집의 결과가 정확히 하나의 커밋 일 것으로 기대 한다는 것을 의미하지는 않습니다 . 실제로 커밋을 취소하거나 다른 커밋을 추가 할 수 있습니다. 커밋을 두 개로 나누는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15b1add937944ed893f52c8ec0293a4127b76c00" translate="yes" xml:space="preserve">
          <source>In its first form, the command provides the content or the type of an object in the repository. The type is required unless &lt;code&gt;-t&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt; is used to find the object type, or &lt;code&gt;-s&lt;/code&gt; is used to find the object size, or &lt;code&gt;--textconv&lt;/code&gt; or &lt;code&gt;--filters&lt;/code&gt; is used (which imply type &quot;blob&quot;).</source>
          <target state="translated">첫 번째 형태로, 명령은 저장소에있는 오브젝트의 컨텐츠 또는 유형을 제공합니다. &lt;code&gt;-t&lt;/code&gt; 또는 &lt;code&gt;-p&lt;/code&gt; 를 사용하여 객체 유형을 찾거나 &lt;code&gt;-s&lt;/code&gt; 를 사용하여 객체 크기를 찾거나 &lt;code&gt;--textconv&lt;/code&gt; 또는 &lt;code&gt;--filters&lt;/code&gt; ( &quot;blob&quot;를 의미)를 사용 하지 않는 한 유형이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="1ce9842f8f482fa7cd77bb4bd4603b72b75e4e0b" translate="yes" xml:space="preserve">
          <source>In its most compact form, this instruction only takes up one byte (0x80) with both offset and size omitted, which will have default values zero. There is another exception: size zero is automatically converted to 0x10000.</source>
          <target state="translated">가장 간단한 형식으로,이 명령어는 오프셋과 크기가 생략 된 1 바이트 (0x80) 만 사용하며 기본값은 0입니다. 또 다른 예외가 있습니다. 크기 0은 자동으로 0x10000으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ed6a0138b63bece5f8693e0a03055de4444b4006" translate="yes" xml:space="preserve">
          <source>In its simplest form, &lt;code&gt;git worktree add &amp;lt;path&amp;gt;&lt;/code&gt; automatically creates a new branch whose name is the final component of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;, which is convenient if you plan to work on a new topic. For instance, &lt;code&gt;git
worktree add ../hotfix&lt;/code&gt; creates new branch &lt;code&gt;hotfix&lt;/code&gt; and checks it out at path &lt;code&gt;../hotfix&lt;/code&gt;. To instead work on an existing branch in a new working tree, use &lt;code&gt;git worktree add &amp;lt;path&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt;. On the other hand, if you just plan to make some experimental changes or do testing without disturbing existing development, it is often convenient to create a &lt;code&gt;throwaway&lt;/code&gt; working tree not associated with any branch. For instance, &lt;code&gt;git worktree add -d &amp;lt;path&amp;gt;&lt;/code&gt; creates a new working tree with a detached &lt;code&gt;HEAD&lt;/code&gt; at the same commit as the current branch.</source>
          <target state="translated">가장 간단한 형태로 &lt;code&gt;git worktree add &amp;lt;path&amp;gt;&lt;/code&gt; 는 이름이 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 의 최종 구성 요소 인 새 브랜치를 자동으로 생성 하므로 새 주제에 대해 작업 할 계획 인 경우 편리합니다. 예를 들어 &lt;code&gt;git worktree add ../hotfix&lt;/code&gt; 새 분기 &lt;code&gt;hotfix&lt;/code&gt; 생성 하고 &lt;code&gt;../hotfix&lt;/code&gt; 경로에서 확인합니다 . 대신 새 작업 트리의 기존 분기에서 작업하려면 &lt;code&gt;git worktree add &amp;lt;path&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt; . 반면에 기존 개발을 방해하지 않고 일부 실험적 변경을 수행하거나 테스트를 수행하려는 경우 분기와 관련이없는 &lt;code&gt;throwaway&lt;/code&gt; 작업 트리 를 만드는 것이 편리한 경우가 많습니다 . 예를 들어, &lt;code&gt;git worktree add -d &amp;lt;path&amp;gt;&lt;/code&gt; 현재 분기와 동일한 커밋에서 분리 된 &lt;code&gt;HEAD&lt;/code&gt; 로 새 작업 트리를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="70413e1dbdf33a9cdd6044f089c7e374f7b737c4" translate="yes" xml:space="preserve">
          <source>In mathematical terms, what we are looking for is some sort of a minimum cost bipartite matching; &lt;code&gt;1&lt;/code&gt; is matched to &lt;code&gt;C&lt;/code&gt; at some cost, etc. The underlying graph is in fact a complete bipartite graph; the cost we associate with every edge is the size of the diff between the two commits' patches. To explain also new commits, we introduce dummy nodes on both sides:</source>
          <target state="translated">수학적 용어로, 우리가 찾고있는 것은 일종의 최소 비용 이분법 일치입니다. &lt;code&gt;1&lt;/code&gt; 은 약간의 비용 등 으로 &lt;code&gt;C&lt;/code&gt; 와 일치합니다 . 기본 그래프는 사실상 완전한 이분 그래프입니다. 우리가 모든 에지와 연관시키는 비용은 두 커밋 패치 사이의 차이 크기입니다. 새로운 커밋도 설명하기 위해 양쪽에 더미 노드를 도입했습니다.</target>
        </trans-unit>
        <trans-unit id="abc4a2c282027431dbb87981bf40f5240785d9ef" translate="yes" xml:space="preserve">
          <source>In modern git, you can say this in a more direct way:</source>
          <target state="translated">현대 git에서는보다 직접적인 방법으로 이것을 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cd9dc714cc1317fe8fea12649b27b5eeab6e568" translate="yes" xml:space="preserve">
          <source>In most cases, this means the attributes given in the input will be repeated in the output, but Git may also modify the credential description, for example by removing the &lt;code&gt;path&lt;/code&gt; attribute when the protocol is HTTP(s) and &lt;code&gt;credential.useHttpPath&lt;/code&gt; is false.</source>
          <target state="translated">대부분의 경우 이는 입력에 제공된 속성이 출력에서 ​​반복되지만 Git이 자격 증명 설명을 수정할 수도 있음을 의미합니다 (예 : 프로토콜이 HTTP (s)이고 &lt;code&gt;credential.useHttpPath&lt;/code&gt; 가 false 일 때 &lt;code&gt;path&lt;/code&gt; 속성 을 제거하여 자격 증명 설명을 수정할 수 있음 ) .</target>
        </trans-unit>
        <trans-unit id="c12479d09bff69f421dbf9e45fddc92269d1f574" translate="yes" xml:space="preserve">
          <source>In most cases, users should run &lt;em&gt;git gc&lt;/em&gt;, which calls &lt;em&gt;git prune&lt;/em&gt;. See the section &quot;NOTES&quot;, below.</source>
          <target state="translated">대부분의 경우 사용자는 &lt;em&gt;git prune&lt;/em&gt; 을 호출 하는 &lt;em&gt;git gc를&lt;/em&gt; 실행해야합니다 . 아래의 &quot;노트&quot;섹션을 참조하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6d4e8e52070be526725731839d6ade7553803d5e" translate="yes" xml:space="preserve">
          <source>In most cases, users will not need to call &lt;code&gt;git prune&lt;/code&gt; directly, but should instead call &lt;code&gt;git gc&lt;/code&gt;, which handles pruning along with many other housekeeping tasks.</source>
          <target state="translated">대부분의 경우 사용자는 &lt;code&gt;git prune&lt;/code&gt; 을 직접 호출하지 않아도 되지만 대신 다른 많은 관리 작업과 함께 가지 치기를 처리하는 &lt;code&gt;git gc&lt;/code&gt; 를 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="7de19f518cc5353753469bfb19c4e4f93734f02e" translate="yes" xml:space="preserve">
          <source>In multiple working trees, some refs may be shared between all working trees and some refs are local. One example is &lt;code&gt;HEAD&lt;/code&gt; which is different for each working tree. This section is about the sharing rules and how to access refs of one working tree from another.</source>
          <target state="translated">여러 작업 트리에서 일부 참조는 모든 작업 트리간에 공유 될 수 있으며 일부 참조는 로컬입니다. 하나의 예는 각 작업 트리마다 다른 &lt;code&gt;HEAD&lt;/code&gt; 입니다. 이 섹션은 공유 규칙과 다른 작업 트리의 참조에 액세스하는 방법에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="fa1d2a97ebd3bb9e2d938b11b92fc4a8e0c826fa" translate="yes" xml:space="preserve">
          <source>In multiple working trees, some refs may be shared between all working trees, some refs are local. One example is HEAD is different for all working trees. This section is about the sharing rules and how to access refs of one working tree from another.</source>
          <target state="translated">여러 작업 트리에서 일부 참조는 모든 작업 트리간에 공유 될 수 있으며 일부 참조는 로컬입니다. 한 가지 예는 HEAD가 모든 작업 트리에서 다르다는 것입니다. 이 섹션은 공유 규칙과 다른 작업 트리의 참조에 액세스하는 방법에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="fef9e754382e4f5002bb7f83483631df5de227e1" translate="yes" xml:space="preserve">
          <source>In older Git versions it could be easily forgotten to commit new or modified files in a submodule, which silently leads to similar problems as not pushing the submodule changes. Starting with Git 1.7.0 both &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git diff&lt;/code&gt; in the superproject show submodules as modified when they contain new or modified files to protect against accidentally committing such a state. &lt;code&gt;git
diff&lt;/code&gt; will also add a &lt;code&gt;-dirty&lt;/code&gt; to the work tree side when generating patch output or used with the &lt;code&gt;--submodule&lt;/code&gt; option:</source>
          <target state="translated">이전 Git 버전에서는 하위 모듈에서 새 파일 또는 수정 된 파일을 커밋하는 것을 쉽게 잊어 버릴 수 있으며, 이로 인해 하위 모듈 변경 사항을 적용하지 않는 것과 유사한 문제가 발생합니다. Git 1.7.0부터 superproject의 &lt;code&gt;git status&lt;/code&gt; 및 &lt;code&gt;git diff&lt;/code&gt; 는 서브 파일이 새로운 상태 또는 수정 된 파일을 포함 할 때 수정 된 것으로 표시하여 이러한 상태를 실수로 커밋하는 것을 방지합니다. &lt;code&gt;git diff&lt;/code&gt; 는 패치 출력을 생성하거나 &lt;code&gt;--submodule&lt;/code&gt; 옵션 과 함께 사용할 때 작업 트리 측에 &lt;code&gt;-dirty&lt;/code&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="cea51be0687534aeac695491ce11f4552163d8c9" translate="yes" xml:space="preserve">
          <source>In order to allow extensions that add extra data to the MIDX, we organize the body into &quot;chunks&quot; and provide a lookup table at the beginning of the body. The header includes certain length values, such as the number of packs, the number of base MIDX files, hash lengths and types.</source>
          <target state="translated">MIDX에 추가 데이터를 추가하는 확장을 허용하기 위해 본문을 &quot;청크&quot;로 구성하고 본문 시작 부분에 조회 테이블을 제공합니다. 헤더에는 팩 수, 기본 MIDX 파일 수, 해시 길이 및 유형과 같은 특정 길이 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f6b8f2c2e89120a466dd40e221531b6adf7a10b9" translate="yes" xml:space="preserve">
          <source>In order to determine what URL to use to fetch from, the value of the configuration &lt;code&gt;remote.&amp;lt;origin&amp;gt;.url&lt;/code&gt; is consulted and if there is not any such variable, the value on the &lt;code&gt;URL:&lt;/code&gt; line in &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; is used.</source>
          <target state="translated">가져 오는 데 사용할 URL을 판별하기 위해 구성 &lt;code&gt;remote.&amp;lt;origin&amp;gt;.url&lt;/code&gt; 의 값을 참조하고 해당 변수가없는 경우 &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; 의 &lt;code&gt;URL:&lt;/code&gt; 행 값 &amp;gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1bb65c849d69cb9e41866b99d141938531c8bf39" translate="yes" xml:space="preserve">
          <source>In order to determine what remote branches to fetch (and optionally store in the remote-tracking branches) when the command is run without any refspec parameters on the command line, values of the configuration variable &lt;code&gt;remote.&amp;lt;origin&amp;gt;.fetch&lt;/code&gt; are consulted, and if there aren&amp;rsquo;t any, &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; is consulted and its &lt;code&gt;Pull:&lt;/code&gt; lines are used. In addition to the refspec formats described in the OPTIONS section, you can have a globbing refspec that looks like this:</source>
          <target state="translated">명령 행에서 refspec 매개 변수없이 명령을 실행할 때 가져올 원격 브랜치 (및 선택적으로 원격 추적 브랜치에 저장)를 판별하기 위해 구성 변수 &lt;code&gt;remote.&amp;lt;origin&amp;gt;.fetch&lt;/code&gt; 의 값을 참조합니다. 없는 경우 &lt;code&gt;$GIT_DIR/remotes/&amp;lt;origin&amp;gt;&lt;/code&gt; 을 참조하고 &lt;code&gt;Pull:&lt;/code&gt; 행을 사용합니다. OPTIONS 섹션에 설명 된 refspec 형식 외에도 다음과 같은 globbing refspec을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b571757e7fe93a92c37f6bdbb5b1d110de433e8f" translate="yes" xml:space="preserve">
          <source>In order to ensure a current tracking branch state, &lt;code&gt;update --remote&lt;/code&gt; fetches the submodule&amp;rsquo;s remote repository before calculating the SHA-1. If you don&amp;rsquo;t want to fetch, you should use &lt;code&gt;submodule update
--remote --no-fetch&lt;/code&gt;.</source>
          <target state="translated">현재 추적 분기 상태를 보장하기 위해 &lt;code&gt;update --remote&lt;/code&gt; 는 SHA-1을 계산하기 전에 하위 모듈의 원격 저장소를 가져옵니다. 가져 오지 않으려면 &lt;code&gt;submodule update --remote --no-fetch&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9ecc869f1231e06aba76a745114504d0b9155917" translate="yes" xml:space="preserve">
          <source>In order to have configuration specific to working trees, you can turn on &quot;worktreeConfig&quot; extension, e.g.:</source>
          <target state="translated">작업 트리에 특정한 구성을 갖기 위해 다음과 같이 &quot;worktreeConfig&quot;확장을 켤 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e42ca6d9de6de9f8c6bfadac339f32432bf0913" translate="yes" xml:space="preserve">
          <source>In order to have configuration specific to working trees, you can turn on the &lt;code&gt;worktreeConfig&lt;/code&gt; extension, e.g.:</source>
          <target state="translated">작업 트리에 특정한 구성을 갖기 위해 &lt;code&gt;worktreeConfig&lt;/code&gt; 확장을 켤 수 있습니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="eb76ce16c3a3c52ec0347fc95609ba6324ad6c16" translate="yes" xml:space="preserve">
          <source>In order to protect the privacy of objects that have been removed from history but may not yet have been pruned, &lt;code&gt;git-upload-archive&lt;/code&gt; avoids serving archives for commits and trees that are not reachable from the repository&amp;rsquo;s refs. However, because calculating object reachability is computationally expensive, &lt;code&gt;git-upload-archive&lt;/code&gt; implements a stricter but easier-to-check set of rules:</source>
          <target state="translated">히스토리에서 제거되었지만 아직 정리되지 않은 오브젝트의 프라이버시를 보호하기 위해 &lt;code&gt;git-upload-archive&lt;/code&gt; 는 저장소의 참조에서 도달 할 수없는 커밋 및 트리에 아카이브를 제공하지 않습니다. 그러나 객체 도달 가능성을 계산하는 것은 계산 비용이 많이 들기 때문에 &lt;code&gt;git-upload-archive&lt;/code&gt; 는 엄격하지만 확인하기 쉬운 규칙 세트를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="17696fe6311cd47e2efc1108f911bdeb8c2c0989" translate="yes" xml:space="preserve">
          <source>In order to set &quot;assume unchanged&quot; bit, use &lt;code&gt;--assume-unchanged&lt;/code&gt; option. To unset, use &lt;code&gt;--no-assume-unchanged&lt;/code&gt;. To see which files have the &quot;assume unchanged&quot; bit set, use &lt;code&gt;git ls-files -v&lt;/code&gt; (see &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt;).</source>
          <target state="translated">&quot;변경되지 않은 가정&quot;비트를 설정하려면 &lt;code&gt;--assume-unchanged&lt;/code&gt; 옵션을 사용하십시오. 설정을 해제하려면 &lt;code&gt;--no-assume-unchanged&lt;/code&gt; 를 사용하십시오 . &quot;변경되지 않은 것으로 가정&quot;비트 세트가있는 파일을 보려면 &lt;code&gt;git ls-files -v&lt;/code&gt; 를 사용 하십시오 ( &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="267b1e8e9ade7b3919e26586bb280b53787cfd98" translate="yes" xml:space="preserve">
          <source>In other messages Andreas says that they also use the &quot;best practices&quot; described above: small logical commits, topic branches, no evil merge,&amp;hellip;​ These practices all improve the bisectability of the commit graph, by making it easier and more useful to bisect.</source>
          <target state="translated">다른 메시지에서 Andreas는 작은 논리적 커밋, 토픽 브랜치, 사악한 병합이 아니라 위에서 설명한 &quot;모범 사례&quot;도 사용한다고 말합니다. 이러한 방식은 모두 커밋 그래프의 이등 성을 향상시킵니다. .</target>
        </trans-unit>
        <trans-unit id="cbba08cd602a94910294469b1bfe69221cf43d34" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;--merge&lt;/code&gt; does something like a &lt;code&gt;git read-tree -u -m &amp;lt;commit&amp;gt;&lt;/code&gt;, but carries forward unmerged index entries.</source>
          <target state="translated">즉, &lt;code&gt;--merge&lt;/code&gt; 는 &lt;code&gt;git read-tree -u -m &amp;lt;commit&amp;gt;&lt;/code&gt; 과 같은 작업을 수행하지만 병합되지 않은 인덱스 항목을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="2c3347c08edbf67732cb77724b9990f6671bac50" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;git diff-files&lt;/code&gt; always shows us the difference between what is recorded in the index, and what is currently in the working tree. That&amp;rsquo;s very useful.</source>
          <target state="translated">다시 말해, &lt;code&gt;git diff-files&lt;/code&gt; 는 항상 인덱스에 기록 된 것과 현재 작업 트리에있는 것과의 차이점을 보여줍니다. 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7466e77eb24cbec56937901c0950f635d6a29d08" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;git diff-index&lt;/code&gt; normally compares a tree against the working tree, but when given the &lt;code&gt;--cached&lt;/code&gt; flag, it is told to instead compare against just the index cache contents, and ignore the current working tree state entirely. Since we just wrote the index file to HEAD, doing &lt;code&gt;git diff-index --cached -p HEAD&lt;/code&gt; should thus return an empty set of differences, and that&amp;rsquo;s exactly what it does.</source>
          <target state="translated">즉, &lt;code&gt;git diff-index&lt;/code&gt; 는 일반적으로 트리를 작업 트리와 비교하지만 &lt;code&gt;--cached&lt;/code&gt; 플래그 가 주어지면 대신 인덱스 캐시 내용과 비교하고 현재 작업 트리 상태를 완전히 무시하도록 지시합니다. 우리는 방금 인덱스 파일을 HEAD에 썼기 때문에 &lt;code&gt;git diff-index --cached -p HEAD&lt;/code&gt; 를 수행하면 빈 차이 집합이 반환되어야합니다. 이것이 바로 그 일입니다.</target>
        </trans-unit>
        <trans-unit id="8c2ef787b7de3a9f3b5df9786c452fde9692465e" translate="yes" xml:space="preserve">
          <source>In other words, there is no need to worry about what exists only in the working tree. When you have local changes in a part of the project that is not involved in the merge, your changes do not interfere with the merge, and are kept intact. When they &lt;strong&gt;do&lt;/strong&gt; interfere, the merge does not even start (&lt;code&gt;git read-tree&lt;/code&gt; complains loudly and fails without modifying anything). In such a case, you can simply continue doing what you were in the middle of doing, and when your working tree is ready (i.e. you have finished your work-in-progress), attempt the merge again.</source>
          <target state="translated">다시 말해, 작업 트리에만 존재하는 것에 대해 걱정할 필요가 없습니다. 병합과 관련이없는 프로젝트 부분에 로컬 변경이 있으면 변경 내용이 병합을 방해하지 않으며 그대로 유지됩니다. 그들이 때 &lt;strong&gt;않는&lt;/strong&gt; 방해, 병합도 (시작되지 않습니다 &lt;code&gt;git read-tree&lt;/code&gt; 큰 소리로 불평 아무것도 수정하지 않고 실패). 이 경우 작업 도중에 있던 작업을 계속하고 작업 트리가 준비되면 (즉, 진행중인 작업을 완료 한 경우) 병합을 다시 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="5a674f35b2eda0a90a7f397ea7dadc5a212b7275" translate="yes" xml:space="preserve">
          <source>In other words, while a &quot;tree&quot; represents a particular directory state of a working directory, a &quot;commit&quot; represents that state in time, and explains how we got there.</source>
          <target state="translated">다시 말해, &quot;트리&quot;는 작업 디렉토리의 특정 디렉토리 상태를 나타내는 반면, &quot;커밋&quot;은 해당 상태를 시간으로 나타내며 어떻게 도착했는지를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="857191c898a7fbefd37c145d86f76b0005dd57eb" translate="yes" xml:space="preserve">
          <source>In other words, you can easily validate a whole archive by just sending out a single email that tells the people the name (SHA-1 hash) of the top commit, and digitally sign that email using something like GPG/PGP.</source>
          <target state="translated">즉, 사람들에게 최고 커밋의 이름 (SHA-1 해시)을 알려주는 단일 전자 메일을 전송하고 GPG / PGP와 같은 것을 사용하여 전자 메일에 디지털 서명함으로써 전체 보관 파일을 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e52122aac7e01b0550d02d6bfc5c4fbaa85b48ac" translate="yes" xml:space="preserve">
          <source>In our example of only two files, we did not have unchanged files so only &lt;code&gt;example&lt;/code&gt; resulted in collapsing. But in real-life large projects, when only a small number of files change in one commit, this &lt;code&gt;collapsing&lt;/code&gt; tends to trivially merge most of the paths fairly quickly, leaving only a handful of real changes in non-zero stages.</source>
          <target state="translated">두 개의 파일 만있는 &lt;code&gt;example&lt;/code&gt; 에서는 변경되지 않은 파일이 없으므로 예제 만 축소되었습니다. 그러나 실제 대규모 프로젝트에서는 한 번의 커밋에서 적은 수의 파일 만 변경되는 경우이 &lt;code&gt;collapsing&lt;/code&gt; 는 대부분의 경로를 상당히 빠르게 병합하여 0이 아닌 단계에서 소수의 실제 변경 사항 만 남겨 둡니다.</target>
        </trans-unit>
        <trans-unit id="a3569415a118c16e9c5d7e18e58096bbd8336f98" translate="yes" xml:space="preserve">
          <source>In our example, when you do the test merge, the manual resolution is recorded, and it will be reused when you do the actual merge later with the updated master and topic branch, as long as the recorded resolution is still applicable.</source>
          <target state="translated">이 예에서는 테스트 병합을 수행 할 때 수동 해상도가 기록되며, 기록 된 해상도가 여전히 적용 가능한 한 업데이트 된 마스터 및 토픽 브랜치에서 나중에 실제 병합을 수행 할 때 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8e5ca17ff33890ba6e129c741e431196f019fa29" translate="yes" xml:space="preserve">
          <source>In overlay mode, the command never removes files when restoring. In no-overlay mode, tracked files that do not appear in the &lt;code&gt;--source&lt;/code&gt; tree are removed, to make them match &lt;code&gt;&amp;lt;tree&amp;gt;&lt;/code&gt; exactly. The default is no-overlay mode.</source>
          <target state="translated">오버레이 모드에서 명령은 복원시 파일을 제거하지 않습니다. 오버레이 없음 모드에서는 &lt;code&gt;--source&lt;/code&gt; 트리에 나타나지 않는 추적 된 파일 이 제거되어 &lt;code&gt;&amp;lt;tree&amp;gt;&lt;/code&gt; 와 정확하게 일치합니다. 기본값은 오버레이 없음 모드입니다.</target>
        </trans-unit>
        <trans-unit id="5b1c0d5c1dcebbb2369ea9f003ec30402ee8a395" translate="yes" xml:space="preserve">
          <source>In particular, let&amp;rsquo;s not even check in the two files into Git yet, we&amp;rsquo;ll start off by adding another line to &lt;code&gt;hello&lt;/code&gt; first:</source>
          <target state="translated">특히 두 파일을 Git에 체크인하지 말고 먼저 &lt;code&gt;hello&lt;/code&gt; 에 다른 줄을 추가하여 시작하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="d0e454374a9a3ee3d6a441cd0674139a3f061022" translate="yes" xml:space="preserve">
          <source>In particular, the &lt;code&gt;refs&lt;/code&gt; subdirectory will contain two other subdirectories, named &lt;code&gt;heads&lt;/code&gt; and &lt;code&gt;tags&lt;/code&gt; respectively. They do exactly what their names imply: they contain references to any number of different &lt;code&gt;heads&lt;/code&gt; of development (aka &lt;code&gt;branches&lt;/code&gt;), and to any &lt;code&gt;tags&lt;/code&gt; that you have created to name specific versions in your repository.</source>
          <target state="translated">특히 &lt;code&gt;refs&lt;/code&gt; 서브 디렉토리에는 각각 &lt;code&gt;heads&lt;/code&gt; 및 &lt;code&gt;tags&lt;/code&gt; 라는 두 개의 다른 서브 디렉토리가 포함 됩니다. 그것들은 그들의 이름이 의미하는 바를 정확하게 수행합니다 : 그것들은 여러 가지 다른 개발 &lt;code&gt;heads&lt;/code&gt; (일명 &lt;code&gt;branches&lt;/code&gt; )와 저장소의 특정 버전을 명명하기 위해 생성 한 &lt;code&gt;tags&lt;/code&gt; 에 대한 참조를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="2037a0a7d55894c0e552cd3905604e14aef5f5cc" translate="yes" xml:space="preserve">
          <source>In practice, you can interleave and repeat steps 1 and 2 as many times as you want: in order to keep track of what you want committed at step 3, Git maintains a snapshot of the tree&amp;rsquo;s contents in a special staging area called &quot;the index.&quot;</source>
          <target state="translated">실제로 1 단계와 2 단계를 원하는만큼 인터리브하고 반복 할 수 있습니다. 3 단계에서 커밋하려는 내용을 추적하기 위해 Git은 &quot;인덱스&quot;라는 특수한 준비 영역에서 트리 내용의 스냅 샷을 유지합니다. &quot;</target>
        </trans-unit>
        <trans-unit id="f0e4ad3997791ffc68facd5c602055afb63229a5" translate="yes" xml:space="preserve">
          <source>In principle, a note is a regular Git blob, and any kind of (non-)format is accepted. You can binary-safely create notes from arbitrary files using &lt;code&gt;git hash-object&lt;/code&gt;:</source>
          <target state="translated">원칙적으로 메모는 일반적인 Git Blob이며 모든 종류의 (비) 형식이 허용됩니다. &lt;code&gt;git hash-object&lt;/code&gt; 를 사용하여 임의의 파일에서 이진으로 안전하게 메모를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4601fb728bee4aeccfe338414983070eaafe0d7b" translate="yes" xml:space="preserve">
          <source>In protocol v2 communication is command oriented. When first contacting a server a list of capabilities will advertised. Some of these capabilities will be commands which a client can request be executed. Once a command has completed, a client can reuse the connection and request that other commands be executed.</source>
          <target state="translated">프로토콜 v2에서 통신은 명령 지향적입니다. 서버에 처음 접속할 때 기능 목록이 광고됩니다. 이러한 기능 중 일부는 클라이언트가 요청할 수있는 명령입니다. 명령이 완료되면 클라이언트는 연결을 재사용하고 다른 명령의 실행을 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1e89ddf0408f3e3f9aa71b3da7906ab579cf106" translate="yes" xml:space="preserve">
          <source>In protocol v2 these special packets will have the following semantics:</source>
          <target state="translated">프로토콜 v2에서 이러한 특수 패킷은 다음 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0b2a25ba5b09240510379a9523ee7fbbaeebe9c6" translate="yes" xml:space="preserve">
          <source>In some cases it is possible that the new head will &lt;strong&gt;not&lt;/strong&gt; actually be a descendant of the old head. For example, the developer may have realized she made a serious mistake, and decided to backtrack, resulting in a situation like:</source>
          <target state="translated">경우에 따라 새 헤드가 실제로 이전 헤드의 후손 이 &lt;strong&gt;아닐&lt;/strong&gt; 수도 있습니다. 예를 들어, 개발자는 자신이 심각한 실수를 저지르고 역 추적하기로 결정하여 다음과 같은 상황이 발생했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="013d925394580efad8fc98d09cd78b65808be1a0" translate="yes" xml:space="preserve">
          <source>In some cases like for kernel development it can be worth developing complex scripts to be able to fully automate bisecting.</source>
          <target state="translated">커널 개발과 같은 경우에는 이등분을 완전히 자동화 할 수있는 복잡한 스크립트를 개발할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a49ce3de43e8ee8d78f327f1f504c6a86228a99" translate="yes" xml:space="preserve">
          <source>In some situations the reflog may not be able to save you. For example, suppose you delete a branch, then realize you need the history it contained. The reflog is also deleted; however, if you have not yet pruned the repository, then you may still be able to find the lost commits in the dangling objects that &lt;code&gt;git fsck&lt;/code&gt; reports. See &lt;a href=&quot;#dangling-objects&quot;&gt;Dangling objects&lt;/a&gt; for the details.</source>
          <target state="translated">경우에 따라 reflog가 저장하지 못할 수도 있습니다. 예를 들어, 분기를 삭제 한 다음 포함 된 히스토리가 필요하다고 가정하십시오. reflog도 삭제됩니다. 그러나 아직 리포지토리를 프룬 (prune)하지 않은 경우 여전히 &lt;code&gt;git fsck&lt;/code&gt; 가보고 하는 매달려있는 오브젝트에서 손실 된 커밋을 찾을 수 있습니다 . 자세한 내용은 &lt;a href=&quot;#dangling-objects&quot;&gt;댕글 링 개체&lt;/a&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="4f2c24901ef5f6fa3a7b78ff609de06af9cfd2f7" translate="yes" xml:space="preserve">
          <source>In sparse checkout mode, &lt;code&gt;git checkout -- &amp;lt;paths&amp;gt;&lt;/code&gt; would update only entries matched by &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt; and sparse patterns in &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt;. This option ignores the sparse patterns and adds back any files in &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">스파 스 체크 아웃 모드에서 &lt;code&gt;git checkout -- &amp;lt;paths&amp;gt;&lt;/code&gt; 는 &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt; 및 스파 스 패턴과 일치하는 항목 만 업데이트합니다 . 이 옵션은 희소 패턴을 무시하고 &lt;code&gt;&amp;lt;paths&amp;gt;&lt;/code&gt; 에있는 파일을 다시 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="91e2068ee07240a386da6a01584d7cb7bf48667f" translate="yes" xml:space="preserve">
          <source>In sparse checkout mode, by default is to only update entries matched by &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; and sparse patterns in $GIT_DIR/info/sparse-checkout. This option ignores the sparse patterns and unconditionally restores any files in &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">스파 스 체크 아웃 모드에서 기본적 으로 $ GIT_DIR / info / sparse-checkout에서 &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; 및 스파 스 패턴과 일치하는 항목 만 업데이트합니다 . 이 옵션은 희소 패턴을 무시하고 &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; 의 파일을 무조건 복원합니다 .</target>
        </trans-unit>
        <trans-unit id="9805e95abc4cc7297991de78ec147328f379f9f9" translate="yes" xml:space="preserve">
          <source>In such a case, &lt;code&gt;git merge-base origin/master topic&lt;/code&gt; would return the parent of B0 in the above picture, but B0^..D is &lt;strong&gt;not&lt;/strong&gt; the range of commits you would want to replay on top of B (it includes B0, which is not what you wrote; it is a commit the other side discarded when it moved its tip from B0 to B1).</source>
          <target state="translated">이 경우 &lt;code&gt;git merge-base origin/master topic&lt;/code&gt; 은 위 그림에서 B0의 부모를 반환하지만 B0 ^ .. D는 B 위에서 재생할 커밋 범위 가 &lt;strong&gt;아닙니다&lt;/strong&gt; (B0, 그것은 당신이 쓴 것이 아니며, 팁을 B0에서 B1로 옮길 때 버린 커밋입니다.)</target>
        </trans-unit>
        <trans-unit id="38c59b4cda1fb890b6373e0ee120752a69f46faf" translate="yes" xml:space="preserve">
          <source>In such a case, you can &quot;unwrap&quot; the tag yourself before feeding it to &lt;code&gt;git merge&lt;/code&gt;, or pass &lt;code&gt;--ff-only&lt;/code&gt; when you do not have any work on your own. e.g.</source>
          <target state="translated">이 경우 태그를 &lt;code&gt;git merge&lt;/code&gt; 에 공급하기 전에 직접 태그를 &quot;포장 &lt;code&gt;--ff-only&lt;/code&gt; 하거나 직접 작업이없는 경우 --ff- 만 전달할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="122c6a9f6232138a6047defa817d1eec04cb3f10" translate="yes" xml:space="preserve">
          <source>In such a case, you do not want to automatically follow the other person&amp;rsquo;s tags.</source>
          <target state="translated">이 경우 다른 사람의 태그를 자동으로 따르고 싶지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14b066e7c220e701d278a048087bd2ff212888b8" translate="yes" xml:space="preserve">
          <source>In such cases it can be very confusing to use the terms &quot;good&quot; and &quot;bad&quot; to refer to &quot;the state before the change&quot; and &quot;the state after the change&quot;. So instead, you can use the terms &quot;old&quot; and &quot;new&quot;, respectively, in place of &quot;good&quot; and &quot;bad&quot;. (But note that you cannot mix &quot;good&quot; and &quot;bad&quot; with &quot;old&quot; and &quot;new&quot; in a single session.)</source>
          <target state="translated">이러한 경우 &quot;좋은&quot;및 &quot;나쁜&quot;이라는 용어를 사용하여 &quot;변경 전 상태&quot;및 &quot;변경 후 상태&quot;를 나타내는 것은 매우 혼란 스러울 수 있습니다. 대신 &quot;good&quot;및 &quot;bad&quot;대신 &quot;old&quot;및 &quot;new&quot;라는 용어를 각각 사용할 수 있습니다. 단, 단일 세션에서 &quot;양호한&quot;및 &quot;나쁜&quot;을 &quot;이전&quot;및 &quot;신규&quot;와 혼합 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="abac94a936763ce45a21b8291dbe11f8fcd73ae6" translate="yes" xml:space="preserve">
          <source>In such cases, git-cherry shows a concise summary of what has yet to be applied:</source>
          <target state="translated">이러한 경우, git-cherry는 아직 적용되지 않은 것에 대한 간결한 요약을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="46cccce64f7cd9f50066dd3d9623630b5fee1925" translate="yes" xml:space="preserve">
          <source>In that case, &lt;code&gt;git pull&lt;/code&gt; can do the fetch and merge in one go, as follows.</source>
          <target state="translated">이 경우 &lt;code&gt;git pull&lt;/code&gt; 은 다음과 같이 가져 오기 및 병합을 한 번에 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52b267d7dd12ef4e2f7423310ff8cbe9ef5b3665" translate="yes" xml:space="preserve">
          <source>In that case, the fix is easy because &lt;code&gt;git rebase&lt;/code&gt; knows to skip changes that are already present in the new upstream (unless &lt;code&gt;--reapply-cherry-picks&lt;/code&gt; is given). So if you say (assuming you&amp;rsquo;re on &lt;code&gt;topic&lt;/code&gt;)</source>
          <target state="translated">이 경우 &lt;code&gt;git rebase&lt;/code&gt; 가 새 업스트림에 이미있는 변경 사항을 건너 뛰는 것을 알고 있기 때문에 수정이 쉽습니다 ( &lt;code&gt;--reapply-cherry-picks&lt;/code&gt; 가 제공 되지 않는 한 ). 그래서 (당신이 &lt;code&gt;topic&lt;/code&gt; 에 있다고 가정하면 )</target>
        </trans-unit>
        <trans-unit id="724c7d4dfedb54b8a53a948ec5bdabaee78995fb" translate="yes" xml:space="preserve">
          <source>In that case, the fix is easy because &lt;code&gt;git rebase&lt;/code&gt; knows to skip changes that are already present in the new upstream. So if you say (assuming you&amp;rsquo;re on &lt;code&gt;topic&lt;/code&gt;)</source>
          <target state="translated">이 경우 &lt;code&gt;git rebase&lt;/code&gt; 가 새로운 업스트림에 이미 존재하는 변경 사항을 건너 뛰는 것을 알고 있기 때문에 수정이 쉽습니다 . 당신이 말하면 (당신이 &lt;code&gt;topic&lt;/code&gt; 에 있다고 가정 )</target>
        </trans-unit>
        <trans-unit id="e2f5cdfecd5b61a82b453fde83701ee64b8d8237" translate="yes" xml:space="preserve">
          <source>In that case, you can still force Git to update to the new head, as described in the following section. However, note that in the situation above this may mean losing the commits labeled &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, unless you&amp;rsquo;ve already created a reference of your own pointing to them.</source>
          <target state="translated">이 경우 다음 섹션에 설명 된대로 여전히 Git이 새 헤드로 업데이트되도록 할 수 있습니다. 그러나 위의 상황에서 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 로 표시된 커밋을 잃어 버릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23201c1eda40e4016771870c9d54dd5324857456" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;git push&lt;/code&gt; command above we specify the name of the remote branch to update (&lt;code&gt;master&lt;/code&gt;). If we leave that out, &lt;code&gt;git push&lt;/code&gt; tries to update any branches in the remote repository that have the same name as a branch in the local repository. So the last &lt;code&gt;push&lt;/code&gt; can be done with either of:</source>
          <target state="translated">위의 &lt;code&gt;git push&lt;/code&gt; 명령에서 업데이트 할 원격 브랜치의 이름을 지정합니다 ( &lt;code&gt;master&lt;/code&gt; ). 이를 생략하면 &lt;code&gt;git push&lt;/code&gt; 는 로컬 저장소의 분기와 이름이 같은 원격 저장소의 분기를 업데이트하려고 시도합니다. 따라서 마지막 &lt;code&gt;push&lt;/code&gt; 는 다음 중 하나를 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="090c003198124abd0a59f9db99cb23a0a9d08a0d" translate="yes" xml:space="preserve">
          <source>In the above config only the submodule &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; are active, &lt;code&gt;bar&lt;/code&gt; due to (1) and &lt;code&gt;baz&lt;/code&gt; due to (3). &lt;code&gt;foo&lt;/code&gt; is inactive because (1) takes precedence over (3)</source>
          <target state="translated">전용 서브 모듈, 상기 구성에서 &lt;code&gt;bar&lt;/code&gt; 과 &lt;code&gt;baz&lt;/code&gt; 활성화되어, &lt;code&gt;bar&lt;/code&gt; (1)에 의한 &lt;code&gt;baz&lt;/code&gt; 때문에 (3)에 관한 것이다. (1)이 (3)보다 우선하기 때문에 &lt;code&gt;foo&lt;/code&gt; 가 비활성 상태입니다.</target>
        </trans-unit>
        <trans-unit id="f2615d435cf358760e53af78267e9744a2a4cd7e" translate="yes" xml:space="preserve">
          <source>In the above example output, the function signature was changed from both files (hence two &lt;code&gt;-&lt;/code&gt; removals from both file1 and file2, plus &lt;code&gt;++&lt;/code&gt; to mean one line that was added does not appear in either file1 or file2). Also eight other lines are the same from file1 but do not appear in file2 (hence prefixed with &lt;code&gt;+&lt;/code&gt;).</source>
          <target state="translated">(따라서 두 개의 상기 예제 출력에서, 함수 서명은 모두 파일에서 변경된 &lt;code&gt;-&lt;/code&gt; 파일 1과 파일 2 모두로부터 삭제 플러스 &lt;code&gt;++&lt;/code&gt; 어느 FILE1이나 파일 2에 나타나지 첨가 한 평균 선). 또한 8 개의 다른 행은 file1과 동일하지만 file2에 나타나지 않습니다 (따라서 접두사 &lt;code&gt;+&lt;/code&gt; 가 붙습니다 ).</target>
        </trans-unit>
        <trans-unit id="236d1518399c3b158b7b503f699f9dfd06244979" translate="yes" xml:space="preserve">
          <source>In the above example we have N = 8, so this will give:</source>
          <target state="translated">위의 예에서 N = 8이므로 다음과 같이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4faa5ab35bd05c089c7f00cb50d40bc6a34dd151" translate="yes" xml:space="preserve">
          <source>In the case where the input consists entirely of whitespace characters, no output will be produced.</source>
          <target state="translated">입력이 전체적으로 공백 문자로 구성된 경우 출력이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6722ed28b0a968c96593a6b207713cd0f24f7d3a" translate="yes" xml:space="preserve">
          <source>In the check-in codepath, the worktree file is first converted with &lt;code&gt;filter&lt;/code&gt; driver (if specified and corresponding driver defined), then the result is processed with &lt;code&gt;ident&lt;/code&gt; (if specified), and then finally with &lt;code&gt;text&lt;/code&gt; (again, if specified and applicable).</source>
          <target state="translated">체크인 코드 경로에서 작업 트리 파일은 먼저 &lt;code&gt;filter&lt;/code&gt; 드라이버 (지정된 경우 해당 드라이버가 정의 된 경우) 로 변환 된 다음 결과가 &lt;code&gt;ident&lt;/code&gt; (지정된 경우)로 처리 된 다음 &lt;code&gt;text&lt;/code&gt; (지정되고 적용 가능한 경우)로 처리됩니다. .</target>
        </trans-unit>
        <trans-unit id="41a87794ee334f48f97053e2010dfe2b224b3e78" translate="yes" xml:space="preserve">
          <source>In the check-out codepath, the blob content is first converted with &lt;code&gt;text&lt;/code&gt;, and then &lt;code&gt;ident&lt;/code&gt; and fed to &lt;code&gt;filter&lt;/code&gt;.</source>
          <target state="translated">체크 아웃 코드 경로에서 Blob 컨텐츠는 먼저 &lt;code&gt;text&lt;/code&gt; 로 변환 된 다음 &lt;code&gt;ident&lt;/code&gt; 및 &lt;code&gt;filter&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="113fa915b38684bf235e931affc2401ec6de4a63" translate="yes" xml:space="preserve">
          <source>In the cone mode case, the &lt;code&gt;git sparse-checkout list&lt;/code&gt; subcommand will list the directories that define the recursive patterns. For the example sparse-checkout file above, the output is as follows:</source>
          <target state="translated">cone 모드의 경우, &lt;code&gt;git sparse-checkout list&lt;/code&gt; 하위 명령은 재귀 패턴을 정의하는 디렉토리를 나열합니다. 위의 스파 스 체크 아웃 파일 예의 출력 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50d1a515997c60c54243bae252639aa03db105b6" translate="yes" xml:space="preserve">
          <source>In the default overlay mode, &lt;code&gt;git checkout&lt;/code&gt; never removes files from the index or the working tree. When specifying &lt;code&gt;--no-overlay&lt;/code&gt;, files that appear in the index and working tree, but not in &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; are removed, to make them match &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; exactly.</source>
          <target state="translated">기본 오버레이 모드에서 &lt;code&gt;git checkout&lt;/code&gt; 은 색인 또는 작업 트리에서 파일을 제거하지 않습니다. &lt;code&gt;--no-overlay&lt;/code&gt; 를 지정하면 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 가 아닌 인덱스 및 작업 트리에 나타나는 파일 이 제거되어 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 와 정확하게 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6cdd96542ff31058533f7beb40eadd124991c8c5" translate="yes" xml:space="preserve">
          <source>In the early days, Git (in the tradition of UNIX) was a bunch of programs which were extremely simple, and which you used in scripts, piping the output of one into another. This turned out to be good for initial development, since it was easier to test new things. However, recently many of these parts have become builtins, and some of the core has been &quot;libified&quot;, i.e. put into libgit.a for performance, portability reasons, and to avoid code duplication.</source>
          <target state="translated">초기에는 Git (UNIX 전통)은 매우 간단하고 스크립트에서 사용하여 서로 다른 출력을 파이프하는 프로그램이었습니다. 새로운 것을 테스트하는 것이 더 쉽기 때문에 초기 개발에 좋았습니다. 그러나 최근에는 이러한 많은 부분이 내장되어 있으며 일부 핵심 부분은 성능, 이식성 및 코드 중복을 피하기 위해 libgit.a에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="5c0100c9df6abb7d7f1348c7fe307c535cc01a6e" translate="yes" xml:space="preserve">
          <source>In the examples, the following &lt;code&gt;.gitattributes&lt;/code&gt; file is used:</source>
          <target state="translated">예제에서 다음 &lt;code&gt;.gitattributes&lt;/code&gt; 파일이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cc3fe53f7a76d1235b536b2f3e4aace1aeafd632" translate="yes" xml:space="preserve">
          <source>In the external editor window, read in the patch file and exit the editor normally.</source>
          <target state="translated">외부 편집기 창에서 패치 파일을 읽고 편집기를 정상적으로 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="8ef2e6de3f32f727ff12807f3683863dc57cb535" translate="yes" xml:space="preserve">
          <source>In the first form, it renames &amp;lt;source&amp;gt;, which must exist and be either a file, symlink or directory, to &amp;lt;destination&amp;gt;. In the second form, the last argument has to be an existing directory; the given sources will be moved into this directory.</source>
          <target state="translated">첫 번째 형식에서는 존재해야하며 파일, symlink 또는 디렉토리 중 하나 인 &amp;lt;source&amp;gt;의 이름을 &amp;lt;destination&amp;gt;으로 바꿉니다. 두 번째 형식에서 마지막 인수는 기존 디렉토리 여야합니다. 주어진 소스가이 디렉토리로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="76aeefd352a6b656fb05dc49a2aa92d1acbe97ce" translate="yes" xml:space="preserve">
          <source>In the first three forms, copy entries from &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; to the index. In the last form, set the current branch head (&lt;code&gt;HEAD&lt;/code&gt;) to &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;, optionally modifying index and working tree to match. The &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;/&lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; defaults to &lt;code&gt;HEAD&lt;/code&gt; in all forms.</source>
          <target state="translated">처음 세 양식에서 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 에서 색인으로 항목을 복사 하십시오. 마지막 양식에서 현재 분기 헤드 ( &lt;code&gt;HEAD&lt;/code&gt; )를 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 으로 설정 하고 선택적으로 색인 및 작업 트리를 일치하도록 수정하십시오. &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; / &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 기본값 &lt;code&gt;HEAD&lt;/code&gt; 를 모든 형태.</target>
        </trans-unit>
        <trans-unit id="ef10a113d8afc34781099a24e1e343890650a1e1" translate="yes" xml:space="preserve">
          <source>In the following example, the developer works on a topic branch that refactors the way buttons are defined, and on another topic branch that uses that refactoring to implement a &quot;Report a bug&quot; button. The output of &lt;code&gt;git log --graph --format=%s -5&lt;/code&gt; may look like this:</source>
          <target state="translated">다음 예제에서 개발자는 단추가 정의 된 방식을 리팩토링하는 토픽 브랜치 및 해당 리팩토링을 사용하여 &quot;버그보고&quot;버튼을 구현하는 다른 토픽 브랜치에서 작업합니다. 출력 &lt;code&gt;git log --graph --format=%s -5&lt;/code&gt; 과 같을 수있다 :</target>
        </trans-unit>
        <trans-unit id="e8d35f4a27576cd3ee599047c232398088d285ec" translate="yes" xml:space="preserve">
          <source>In the following, we list all defined capabilities and for each we list which commands a helper with that capability must provide.</source>
          <target state="translated">다음에는 정의 된 모든 기능과 각 기능에 대해 도우미가 제공해야하는 명령이 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c56abbab61e08007b56db2739d2660b32ff3baf6" translate="yes" xml:space="preserve">
          <source>In the following, we say that commit X is &quot;reachable&quot; from commit Y if commit X is an ancestor of commit Y. Equivalently, you could say that Y is a descendant of X, or that there is a chain of parents leading from commit Y to commit X.</source>
          <target state="translated">다음에서, 커밋 X가 커밋 Y의 조상이면 커밋 X가 커밋 Y에서 &quot;도달 가능&quot;하다고 말합니다. 마찬가지로, Y가 X의 자손이거나 커밋에서 이어지는 부모의 체인이 있다고 말할 수 있습니다 X를 커밋하려면 Y</target>
        </trans-unit>
        <trans-unit id="2ab0015fa4bf468aa51dfb7b06e67d10a59ee05a" translate="yes" xml:space="preserve">
          <source>In the following, we will always refer to the same example history to illustrate the differences between simplification settings. We assume that you are filtering for a file &lt;code&gt;foo&lt;/code&gt; in this commit graph:</source>
          <target state="translated">다음에서는 단순화 설정 간의 차이점을 설명하기 위해 항상 동일한 예제 기록을 참조합니다. 이 커밋 그래프에서 파일 &lt;code&gt;foo&lt;/code&gt; 를 필터링한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="1a1825758e9c1b0f3cada9dea61b97f18e404ba1" translate="yes" xml:space="preserve">
          <source>In the ideal world, you could have realized that the earlier commit did not belong to the new topic when you created and switched to &lt;code&gt;branch2&lt;/code&gt; (i.e. &lt;code&gt;git switch -c branch2 start&lt;/code&gt;), but nobody is perfect.</source>
          <target state="translated">이상적인 세계에서, 당신은 이전 커밋이 당신이 &lt;code&gt;branch2&lt;/code&gt; 를 생성하고 전환 할 때 (즉, &lt;code&gt;git switch -c branch2 start&lt;/code&gt; ) 새로운 토픽에 속하지 않았지만 아무도 완벽 하지 않다는 것을 깨달을 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="d370a0f8ed20ae4cd4e933b9beff011b3187e6ad" translate="yes" xml:space="preserve">
          <source>In the long form, the leading colon &lt;code&gt;:&lt;/code&gt; is followed by an open parenthesis &lt;code&gt;(&lt;/code&gt;, a comma-separated list of zero or more &quot;magic words&quot;, and a close parentheses &lt;code&gt;)&lt;/code&gt;, and the remainder is the pattern to match against the path.</source>
          <target state="translated">긴 형태에서, 최고의 콜론 &lt;code&gt;:&lt;/code&gt; 여는 괄호 뒤에 &lt;code&gt;(&lt;/code&gt; 0 개 이상의 &quot;마법의 단어&quot;, 그리고 가까운 괄호의 쉼표로 구분 된 목록 &lt;code&gt;)&lt;/code&gt; , 나머지는 경로에 대해 일치하는 패턴이다.</target>
        </trans-unit>
        <trans-unit id="ecbb466c633c8f376663d1974093b0b801e94fbc" translate="yes" xml:space="preserve">
          <source>In the main Thunderbird window, &lt;code&gt;before&lt;/code&gt; you open the compose window for the patch, use Tools&amp;rarr;about:config to set the following to the indicated values:</source>
          <target state="translated">기본 Thunderbird 창 에서 패치의 작성 창을 열기 &lt;code&gt;before&lt;/code&gt; 도구 &amp;rarr; about : config를 사용하여 다음을 표시된 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="3f70c7e45d5c392e715fb2023b23a65e5f20b82a" translate="yes" xml:space="preserve">
          <source>In the output from &lt;code&gt;git show-branch&lt;/code&gt;, &lt;code&gt;master&lt;/code&gt; should have everything &lt;code&gt;ko/master&lt;/code&gt; has, and &lt;code&gt;next&lt;/code&gt; should have everything &lt;code&gt;ko/next&lt;/code&gt; has, etc.</source>
          <target state="translated">의 출력에서 &lt;code&gt;git show-branch&lt;/code&gt; , &lt;code&gt;master&lt;/code&gt; 모든 것을해야한다 &lt;code&gt;ko/master&lt;/code&gt; 있으며, &lt;code&gt;next&lt;/code&gt; 모든 것을해야한다 &lt;code&gt;ko/next&lt;/code&gt; 이 등</target>
        </trans-unit>
        <trans-unit id="9fb474287214ed4886618f1399ff63bbd11f6810" translate="yes" xml:space="preserve">
          <source>In the pager (&lt;code&gt;less&lt;/code&gt;), just search for &quot;bundle&quot;, go a few lines back, and see that it is in commit 18449ab0. Now just copy this object name, and paste it into the command line</source>
          <target state="translated">호출기 ( &lt;code&gt;less&lt;/code&gt; )에서 &quot;bundle&quot;을 검색하고 몇 줄을 뒤로 이동하여 커밋 18449ab0에 있는지 확인하십시오. 이제이 오브젝트 이름을 복사하여 명령 행에 붙여 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="5fc7016d20b7cd82938bb283d4d8443cc61835c8" translate="yes" xml:space="preserve">
          <source>In the past, &lt;code&gt;.git/HEAD&lt;/code&gt; was a symbolic link pointing at &lt;code&gt;refs/heads/master&lt;/code&gt;. When we wanted to switch to another branch, we did &lt;code&gt;ln -sf refs/heads/newbranch .git/HEAD&lt;/code&gt;, and when we wanted to find out which branch we are on, we did &lt;code&gt;readlink .git/HEAD&lt;/code&gt;. But symbolic links are not entirely portable, so they are now deprecated and symbolic refs (as described above) are used by default.</source>
          <target state="translated">과거에는 &lt;code&gt;.git/HEAD&lt;/code&gt; 는 &lt;code&gt;refs/heads/master&lt;/code&gt; 를 가리키는 심볼릭 링크였습니다 . 우리가 다른 지점으로 전환하고 싶어 할 때, 우리는 한 &lt;code&gt;ln -sf refs/heads/newbranch .git/HEAD&lt;/code&gt; , 우리는 우리가있는 지점 발견하고 싶어 할 때, 우리는 한 &lt;code&gt;readlink .git/HEAD&lt;/code&gt; . 그러나 심볼릭 링크는 완전히 이식 가능하지 않으므로 이제 더 이상 사용되지 않으며 위에서 설명한 것처럼 심볼릭 참조가 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8dfab80b468101639bf9d627830b7559e865891a" translate="yes" xml:space="preserve">
          <source>In the previous example, when updating an existing branch, &lt;code&gt;git fetch&lt;/code&gt; checks to make sure that the most recent commit on the remote branch is a descendant of the most recent commit on your copy of the branch before updating your copy of the branch to point at the new commit. Git calls this process a &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt;.</source>
          <target state="translated">이전 예에서 기존 분기를 업데이트 할 때 &lt;code&gt;git fetch&lt;/code&gt; 는 원격 분기에서 가장 최근의 커밋이 지점의 복사본을 업데이트하기 전에 분기의 복사본에서 가장 최근의 커밋의 하위 항목인지 확인합니다. 새로운 커밋. 힘내이 프로세스를 &lt;a href=&quot;#fast-forwards&quot;&gt;빨리 진행이라고&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="39fc6243d8461e10163ad54b5cc61dfd9c9ca8f0" translate="yes" xml:space="preserve">
          <source>In the process of undoing a previous bad change, you may find it useful to check out an older version of a particular file using &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt;. The command</source>
          <target state="translated">이전의 잘못된 변경을 취소하는 과정에서 &lt;a href=&quot;git-restore&quot;&gt;git-restore [1]을&lt;/a&gt; 사용하여 특정 파일의 이전 버전을 체크 아웃하는 것이 유용 할 수 있습니다 . 명령</target>
        </trans-unit>
        <trans-unit id="ce5a30d6d89274fe8c4b93a655981ad3cb2875fa" translate="yes" xml:space="preserve">
          <source>In the process, it may discover conflicts. In that case it will stop and allow you to fix the conflicts; after fixing conflicts, use &lt;code&gt;git add&lt;/code&gt; to update the index with those contents, and then, instead of running &lt;code&gt;git commit&lt;/code&gt;, just run</source>
          <target state="translated">이 과정에서 충돌이 발견 될 수 있습니다. 이 경우 중지되고 충돌을 해결할 수 있습니다. 충돌을 수정 한 후 &lt;code&gt;git add&lt;/code&gt; 를 사용 하여 해당 내용으로 색인을 업데이트 한 다음 &lt;code&gt;git commit&lt;/code&gt; 을 실행하는 대신 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ecd16080120d9546efe5335b66c01332d8bc5340" translate="yes" xml:space="preserve">
          <source>In the second form, a list of objects (separated by linefeeds) is provided on stdin, and the SHA-1, type, and size of each object is printed on stdout. The output format can be overridden using the optional &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; argument. If either &lt;code&gt;--textconv&lt;/code&gt; or &lt;code&gt;--filters&lt;/code&gt; was specified, the input is expected to list the object names followed by the path name, separated by a single whitespace, so that the appropriate drivers can be determined.</source>
          <target state="translated">두 번째 형태로, 개체 목록 (줄 바꿈으로 구분)이 stdin에 제공되고 각 개체의 SHA-1, 유형 및 크기가 stdout에 인쇄됩니다. 선택적 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 인수를 사용하여 출력 형식을 재정의 할 수 있습니다 . 어느 경우 &lt;code&gt;--textconv&lt;/code&gt; 또는 &lt;code&gt;--filters&lt;/code&gt; 이 지정된 입력은 적절한 드라이버를 결정할 수 있도록하는 것이 단일 공백으로 분리 된 경로 이름 다음에 개체 이름을 나열 할 것으로 예상된다.</target>
        </trans-unit>
        <trans-unit id="909b0b19015ead3714bd1690a7877da1cf97f4fa" translate="yes" xml:space="preserve">
          <source>In the short-format, the status of each path is shown as one of these forms</source>
          <target state="translated">짧은 형식에서는 각 경로의 상태가 다음 형식 중 하나로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="abe3a521aeac4a8adcc3faf0711763fbfd40b505" translate="yes" xml:space="preserve">
          <source>In the simple form, each line in the file consists of the canonical real name of an author, whitespace, and an email address used in the commit (enclosed by &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;) to map to the name. For example:</source>
          <target state="translated">간단한 형식으로 파일의 각 줄은 저자의 정식 실제 이름, 공백 및 커밋 ( &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; 으로 묶음 )에서 이름에 매핑하는 데 사용되는 전자 메일 주소로 구성됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eecf34aeaad64fff7ea38378d33edc5335145626" translate="yes" xml:space="preserve">
          <source>In these cases you can tell Git the encoding of a file in the working directory with the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute. If a file with this attribute is added to Git, then Git re-encodes the content from the specified encoding to UTF-8. Finally, Git stores the UTF-8 encoded content in its internal data structure (called &quot;the index&quot;). On checkout the content is re-encoded back to the specified encoding.</source>
          <target state="translated">이 경우 &lt;code&gt;working-tree-encoding&lt;/code&gt; 속성을 사용 하여 작업 디렉토리의 파일 인코딩을 Git에 알릴 수 있습니다 . 이 속성을 가진 파일이 Git에 추가되면 Git은 지정된 인코딩에서 UTF-8로 컨텐츠를 다시 인코딩합니다. 마지막으로 Git은 UTF-8로 인코딩 된 콘텐츠를 내부 데이터 구조 ( &quot;인덱스&quot;라고 함)에 저장합니다. 체크 아웃시 컨텐츠는 지정된 인코딩으로 다시 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="5322604525a9aed1b9bf470c8d7df77aa5a14cc1" translate="yes" xml:space="preserve">
          <source>In these tables, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; are some different states of a file. For example, the first line of the first table means that if a file is in state &lt;code&gt;A&lt;/code&gt; in the working tree, in state &lt;code&gt;B&lt;/code&gt; in the index, in state &lt;code&gt;C&lt;/code&gt; in &lt;code&gt;HEAD&lt;/code&gt; and in state &lt;code&gt;D&lt;/code&gt; in the target, then &lt;code&gt;git reset --soft
target&lt;/code&gt; will leave the file in the working tree in state &lt;code&gt;A&lt;/code&gt; and in the index in state &lt;code&gt;B&lt;/code&gt;. It resets (i.e. moves) the &lt;code&gt;HEAD&lt;/code&gt; (i.e. the tip of the current branch, if you are on one) to &lt;code&gt;target&lt;/code&gt; (which has the file in state &lt;code&gt;D&lt;/code&gt;).</source>
          <target state="translated">이 표에서 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 및 &lt;code&gt;D&lt;/code&gt; 는 파일의 다른 상태입니다. 예를 들어, 첫 번째 테이블 수단의 첫 번째 행의 파일이 상태에있는 경우 그 상태에서 작업 트리에서 &lt;code&gt;B&lt;/code&gt; 상태에서, 인덱스 &lt;code&gt;C&lt;/code&gt; 에 &lt;code&gt;HEAD&lt;/code&gt; 와 상태에서 &lt;code&gt;D&lt;/code&gt; 대상의 다음 &lt;code&gt;git reset --soft target&lt;/code&gt; 은 파일을 상태 &lt;code&gt;A&lt;/code&gt; 의 작업 트리에 있고 상태 &lt;code&gt;B&lt;/code&gt; 의 색인에 그대로 둡니다 . &lt;code&gt;HEAD&lt;/code&gt; (즉, 현재 브랜치의 팁이있는 경우)를 &lt;code&gt;target&lt;/code&gt; (파일이있는 상태 )으로 재설정 (즉, 이동) &lt;code&gt;A&lt;/code&gt; &lt;code&gt;D&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="31d8ef3e97391069cf0655f41499162005f123c2" translate="yes" xml:space="preserve">
          <source>In these two shorthand notations, you can omit one end and let it default to HEAD. For example, &lt;code&gt;origin..&lt;/code&gt; is a shorthand for &lt;code&gt;origin..HEAD&lt;/code&gt; and asks &quot;What did I do since I forked from the origin branch?&quot; Similarly, &lt;code&gt;..origin&lt;/code&gt; is a shorthand for &lt;code&gt;HEAD..origin&lt;/code&gt; and asks &quot;What did the origin do since I forked from them?&quot; Note that &lt;code&gt;..&lt;/code&gt; would mean &lt;code&gt;HEAD..HEAD&lt;/code&gt; which is an empty range that is both reachable and unreachable from HEAD.</source>
          <target state="translated">이 두 가지 속기 표기법에서는 한쪽 끝을 생략하고 기본값을 HEAD로 설정할 수 있습니다. 예를 들어 &lt;code&gt;origin..&lt;/code&gt; 은 &lt;code&gt;origin..HEAD&lt;/code&gt; 의 축약 형이며 &quot;원점에서 분기 한 후 어떻게 했습니까?&quot; 마찬가지로, &lt;code&gt;..origin&lt;/code&gt; 을 위한 속기 &lt;code&gt;HEAD..origin&lt;/code&gt; 은 묻는다 &quot;나는 그들로부터 나눠서 기원은 어떻게 했는가?&quot; 있습니다 &lt;code&gt;..&lt;/code&gt; 의미 &lt;code&gt;HEAD..HEAD&lt;/code&gt; 도달 및 HEAD에서 도달 할 수없는 둘 다 빈 범위입니다.</target>
        </trans-unit>
        <trans-unit id="fda0649080e4ad73be213a95d0150567b39a9905" translate="yes" xml:space="preserve">
          <source>In this case Git will attempt to undo the old change while leaving intact any changes made since then. If more recent changes overlap with the changes to be reverted, then you will be asked to fix conflicts manually, just as in the case of &lt;a href=&quot;#resolving-a-merge&quot;&gt;resolving a merge&lt;/a&gt;.</source>
          <target state="translated">이 경우 Git은 변경 사항을 그대로 유지하면서 이전 변경 내용을 취소하려고 시도합니다. 더 최근의 변경 사항이 되돌릴 변경 사항과 겹치는 경우 &lt;a href=&quot;#resolving-a-merge&quot;&gt;병합&lt;/a&gt; 을 해결하는 경우와 마찬가지로 수동으로 충돌을 수정하라는 메시지가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7e31e9f418486f831893dd264d133713a86e996" translate="yes" xml:space="preserve">
          <source>In this case if you are bisecting manually, what you can do is create a special branch that starts just before the BBC. The first commit in this branch should be the BBC with the BFC squashed into it. And the other commits in the branch should be the commits between BBC and BFC rebased on the first commit of the branch and then the commit after BFC also rebased on.</source>
          <target state="translated">이 경우 수동으로 이등분하는 경우 BBC 직전에 시작하는 특수 분기를 만드는 것이 가능합니다. 이 지점의 첫 번째 커밋은 BFC가 찌그러진 BBC가되어야합니다. 그리고 브랜치의 다른 커밋은 브랜치의 첫 커밋에 기반한 BBC와 BFC 간의 커밋이어야하고, BFC가 다시 기반한 이후의 커밋이어야합니다.</target>
        </trans-unit>
        <trans-unit id="717fbe628e5024a7ab31b6335fd291caf38b26b3" translate="yes" xml:space="preserve">
          <source>In this case this creates a totally new commit that is not related to anything else. Normally you do this only &lt;strong&gt;once&lt;/strong&gt; for a project ever, and all later commits will be parented on top of an earlier commit.</source>
          <target state="translated">이 경우 다른 것과 관련이없는 완전히 새로운 커밋이 생성됩니다. 일반적으로 프로젝트에 대해 &lt;strong&gt;한 번만&lt;/strong&gt; 이 작업을 수행 하며 이후의 모든 커밋은 이전 커밋 위에 부모로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8d602afd53dc502b1f39532e44b808e7e4006de6" translate="yes" xml:space="preserve">
          <source>In this case we say that the HEAD is &quot;detached&quot;.</source>
          <target state="translated">이 경우 HEAD가 &quot;분리&quot;되었다고합니다.</target>
        </trans-unit>
        <trans-unit id="84d70e62f46cda65cca1be0dfe61a185714e74d6" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;git fetch&lt;/code&gt; will fail, and print out a warning.</source>
          <target state="translated">이 경우 &lt;code&gt;git fetch&lt;/code&gt; 는 실패하고 경고를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="ec2a36fb392a8671d4d7ad6f96adda81069f0cb4" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;git read-tree -m $H $M&lt;/code&gt; command makes sure that no local change is lost as the result of this &quot;merge&quot;. Here are the &quot;carry forward&quot; rules, where &quot;I&quot; denotes the index, &quot;clean&quot; means that index and work tree coincide, and &quot;exists&quot;/&quot;nothing&quot; refer to the presence of a path in the specified commit:</source>
          <target state="translated">이 경우, &lt;code&gt;git read-tree -m $H $M&lt;/code&gt; 명령은이 &quot;병합&quot;의 결과로 로컬 변경이 손실되지 않도록합니다. &quot;이월&quot;규칙은 다음과 같습니다. 여기서 &quot;I&quot;는 색인을 나타내고 &quot;정리&quot;는 색인과 작업 트리가 일치하고 &quot;존재&quot;/ &quot;없음&quot;은 지정된 커밋에 경로가 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="53de38de1c4937be3492ea2adad08075be0660b2" translate="yes" xml:space="preserve">
          <source>In this case, though, Git may not eventually be able to tell the first bad one between some first skipped commits and a later bad commit.</source>
          <target state="translated">그러나이 경우 Git은 처음으로 건너 뛴 커밋과 이후의 잘못된 커밋 사이에서 첫 번째 잘못된 것을 알지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc3568a850f36cf3d79c68cf0d9db0591ec5b81e" translate="yes" xml:space="preserve">
          <source>In this case, when &lt;code&gt;git bisect run&lt;/code&gt; finishes, bisect/bad will refer to a commit that has at least one parent whose reachable graph is fully traversable in the sense required by &lt;code&gt;git pack objects&lt;/code&gt;.</source>
          <target state="translated">이 경우, &lt;code&gt;git bisect run&lt;/code&gt; 이 완료되면 bisect / bad는 도달 가능한 그래프가 &lt;code&gt;git pack objects&lt;/code&gt; 필요한 의미로 완전히 통과 할 수있는 부모가 하나 이상있는 커밋을 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="052b0bf9d817f9d1efdbc01c640d54d8fda7ad16" translate="yes" xml:space="preserve">
          <source>In this example preload_index() was executed by the &lt;code&gt;main&lt;/code&gt; thread and started the &lt;code&gt;preload&lt;/code&gt; region. Seven threads, named &lt;code&gt;th01:preload_thread&lt;/code&gt; through &lt;code&gt;th07:preload_thread&lt;/code&gt;, were started. Events from each thread are atomically appended to the shared target stream as they occur so they may appear in random order with respect other threads. Finally, the main thread waits for the threads to finish and leaves the region.</source>
          <target state="translated">이 예제에서 preload_index ()는 &lt;code&gt;main&lt;/code&gt; 스레드에 의해 실행되었으며 프리 &lt;code&gt;preload&lt;/code&gt; 영역을 시작했습니다 . &lt;code&gt;th01:preload_thread&lt;/code&gt; ~ &lt;code&gt;th07:preload_thread&lt;/code&gt; 라는 7 개의 스레드 가 시작되었습니다. 각 스레드의 이벤트는 발생시 공유 대상 스트림에 원자 적으로 추가되므로 다른 스레드와 관련하여 임의의 순서로 나타날 수 있습니다. 마지막으로 주 스레드는 스레드가 완료 될 때까지 기다렸다가 영역을 떠납니다.</target>
        </trans-unit>
        <trans-unit id="8e1c791b90ef2153c52f59ff823e2b7a9d806696" translate="yes" xml:space="preserve">
          <source>In this example, &quot;origin&quot; is called a remote repository, or &quot;remote&quot; for short. The branches of this repository are called &quot;remote branches&quot; from our point of view. The remote-tracking branches listed above were created based on the remote branches at clone time and will be updated by &lt;code&gt;git fetch&lt;/code&gt; (hence &lt;code&gt;git pull&lt;/code&gt;) and &lt;code&gt;git push&lt;/code&gt;. See &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;Updating a repository with git fetch&lt;/a&gt; for details.</source>
          <target state="translated">이 예에서 &quot;origin&quot;은 원격 저장소 또는 &quot;원격&quot;이라고합니다. 이 저장소의 지점을 우리의 관점에서 &quot;원격 지점&quot;이라고합니다. 위에 나열된 원격 추적 분기는 복제시 원격 분기를 기반으로 작성되었으며 &lt;code&gt;git fetch&lt;/code&gt; (따라서 &lt;code&gt;git pull&lt;/code&gt; ) 및 &lt;code&gt;git push&lt;/code&gt; 로 업데이트됩니다 . 자세한 내용 &lt;a href=&quot;#Updating-a-repository-With-git-fetch&quot;&gt;은 git fetch로 리포지토리 업데이트&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="888891869abe63aa603e61303e6b4eda4f092540" translate="yes" xml:space="preserve">
          <source>In this example, scanning for untracked files ran from +0.012568 to +0.027149 (since the process started) and took 0.014581 seconds.</source>
          <target state="translated">이 예에서 추적되지 않은 파일 검색은 프로세스가 시작된 이후 +0.012568에서 +0.027149까지 실행되었으며 0.014581 초가 걸렸습니다.</target>
        </trans-unit>
        <trans-unit id="06524b5c41784cbbacde83bd5045f27a411dfe64" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;ko&lt;/code&gt; shorthand points at the Git maintainer&amp;rsquo;s repository at kernel.org, and looks like this:</source>
          <target state="translated">이 예제에서 &lt;code&gt;ko&lt;/code&gt; 축약 형은 kernel.org의 Git 관리자 저장소에 있으며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f509bc56ecf3e22348180170f4391a6c5749bec9" translate="yes" xml:space="preserve">
          <source>In this example, the preload region took 0.009122 seconds. The 7 threads took between 0.006069 and 0.008947 seconds to work on their portion of the index. Thread &quot;th01&quot; worked on 508 items at offset 0. Thread &quot;th02&quot; worked on 508 items at offset 2032. Thread &quot;th04&quot; worked on 508 items at offset 508.</source>
          <target state="translated">이 예에서, 예압 영역은 0.009122 초가 걸렸습니다. 7 개의 스레드는 0.006069와 0.008947 초 사이에서 인덱스의 일부를 처리했습니다. 스레드 &quot;th01&quot;은 오프셋 0의 508 개 항목에서 작동했습니다. 스레드 &quot;th02&quot;는 오프셋 2032의 508 개 항목에서 작동했습니다. 스레드 &quot;th04&quot;는 오프셋 508의 508 개 항목에서 작동했습니다.</target>
        </trans-unit>
        <trans-unit id="24b2f8c33beed03671571687642648d3c34d3255" translate="yes" xml:space="preserve">
          <source>In this example, the root-level directory &lt;code&gt;/pub&lt;/code&gt; will contain a subdirectory for each virtual host IP address supported. Repositories can still be accessed by hostname though, assuming they correspond to these IP addresses.</source>
          <target state="translated">이 예에서 루트 레벨 디렉토리 &lt;code&gt;/pub&lt;/code&gt; 는 지원되는 각 가상 호스트 IP 주소에 대한 서브 디렉토리를 포함합니다. 그러나 이러한 IP 주소에 해당한다고 가정하면 호스트 이름으로 리포지토리에 계속 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b3657f6aff85ab6f6a5a7f723164213b6e98109" translate="yes" xml:space="preserve">
          <source>In this example, the root-level directory &lt;code&gt;/pub&lt;/code&gt; will contain a subdirectory for each virtual host name supported. Further, both hosts advertise repositories simply as &lt;code&gt;git://www.example.com/software/repo.git&lt;/code&gt;. For pre-1.4.0 clients, a symlink from &lt;code&gt;/software&lt;/code&gt; into the appropriate default repository could be made as well.</source>
          <target state="translated">이 예에서 루트 레벨 디렉토리 &lt;code&gt;/pub&lt;/code&gt; 는 지원되는 각 가상 호스트 이름에 대한 서브 디렉토리를 포함합니다. 또한 두 호스트 모두 간단히 &lt;code&gt;git://www.example.com/software/repo.git&lt;/code&gt; 과 같이 리포지토리를 보급합니다 . 1.4.0 이전 클라이언트의 경우 &lt;code&gt;/software&lt;/code&gt; 에서 적절한 기본 리포지토리로 심볼릭 링크를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f73381570064f6ad92295b54ae4d9111ba415e0" translate="yes" xml:space="preserve">
          <source>In this example, there are 3 old and 3 new commits, where the developer removed the 3rd, added a new one before the first two, and modified the commit message of the 2nd commit as well its diff.</source>
          <target state="translated">이 예에는 3 개의 이전 커밋과 3 개의 새로운 커밋이 있으며, 여기서 개발자는 3 번째를 제거하고 처음 2 개 전에 새로운 것을 추가하고 2 번째 커밋의 커밋 메시지와 diff를 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="5f85b35b8b6aae26894cfdfbe33e3822a8120573" translate="yes" xml:space="preserve">
          <source>In this example, we passed &quot;grep &lt;code&gt;^SUBLEVEL = 25&lt;/code&gt; Makefile&quot; as parameter to &quot;git bisect run&quot;. This means that at each step, the grep command we passed will be launched. And if it exits with code 0 (that means success) then git bisect will mark the current state as &quot;good&quot;. If it exits with code 1 (or any code between 1 and 127 included, except the special code 125), then the current state will be marked as &quot;bad&quot;.</source>
          <target state="translated">이 예에서는 &quot;grep &lt;code&gt;^SUBLEVEL = 25&lt;/code&gt; Makefile&quot;을 매개 변수로 &quot;git bisect run&quot;에 전달했습니다. 이는 각 단계에서 전달한 grep 명령이 시작됨을 의미합니다. 그리고 코드 0 (성공을 의미 함)으로 종료되면 git bisect는 현재 상태를 &quot;good&quot;으로 표시합니다. 코드 1 (또는 특수 코드 125를 제외하고 포함 된 1에서 127 사이의 코드)로 종료되면 현재 상태가 &quot;나쁜&quot;으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="eee8776c9677f60ee6e97b993bed2ed1a91281bf" translate="yes" xml:space="preserve">
          <source>In this format, each line is output after a header; the header at the minimum has the first line which has:</source>
          <target state="translated">이 형식에서 각 줄은 헤더 다음에 출력됩니다. 헤더에는 최소한 다음과 같은 첫 번째 줄이 있습니다.</target>
        </trans-unit>
        <trans-unit id="991df4351922c60c45e086aff27d9273fe47de49" translate="yes" xml:space="preserve">
          <source>In this format, use 40 &quot;0&quot; to specify a zero value, and use the empty string to specify a missing value.</source>
          <target state="translated">이 형식에서는 40 &quot;0&quot;을 사용하여 0 값을 지정하고 빈 문자열을 사용하여 결 측값을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="b4a37ae142e5dfb709dfd08bf26fc04d26f39f66" translate="yes" xml:space="preserve">
          <source>In this mode, specific configuration stays in the path pointed by &lt;code&gt;git
rev-parse --git-path config.worktree&lt;/code&gt;. You can add or update configuration in this file with &lt;code&gt;git config --worktree&lt;/code&gt;. Older Git versions will refuse to access repositories with this extension.</source>
          <target state="translated">이 모드에서 특정 구성은 &lt;code&gt;git rev-parse --git-path config.worktree&lt;/code&gt; 가리키는 경로에 유지됩니다 . 이 파일에서 &lt;code&gt;git config --worktree&lt;/code&gt; 를 사용 하여 구성을 추가하거나 업데이트 할 수 있습니다 . 이전 Git 버전은이 확장을 사용하여 리포지토리에 대한 액세스를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="26cf2860c6712d39e5cbcd807f1756d9308dfdb3" translate="yes" xml:space="preserve">
          <source>In this mode, the index is split into two files, $GIT_DIR/index and $GIT_DIR/sharedindex.&amp;lt;SHA-1&amp;gt;. Changes are accumulated in $GIT_DIR/index, the split index, while the shared index file contains all index entries and stays unchanged.</source>
          <target state="translated">이 모드에서 인덱스는 $ GIT_DIR / index 및 $ GIT_DIR / sharedindex. &amp;lt;SHA-1&amp;gt;의 두 파일로 분할됩니다. 공유 인덱스 파일은 모든 인덱스 항목을 포함하고 변경되지 않은 상태로 유지하면서 분할 인덱스 $ GIT_DIR / index에 변경 사항이 누적됩니다.</target>
        </trans-unit>
        <trans-unit id="ffc9d6f506ae4dc0ef8e821987c60f58237503b7" translate="yes" xml:space="preserve">
          <source>In this mode, the server will not request authentication until the client actually starts the object negotiation phase of the push, rather than during the initial contact. For this reason, you must also enable the &lt;code&gt;http.receivepack&lt;/code&gt; config option in any repositories that should accept a push. The default behavior, if &lt;code&gt;http.receivepack&lt;/code&gt; is not set, is to reject any pushes by unauthenticated users; the initial request will therefore report &lt;code&gt;403 Forbidden&lt;/code&gt; to the client, without even giving an opportunity for authentication.</source>
          <target state="translated">이 모드에서 서버는 클라이언트가 실제로 초기 접촉 중에가 아니라 푸시의 개체 협상 단계를 시작할 때까지 인증을 요청하지 않습니다. 이러한 이유로 푸시를 허용해야하는 모든 저장소에서 &lt;code&gt;http.receivepack&lt;/code&gt; 구성 옵션을 활성화해야합니다 . &lt;code&gt;http.receivepack&lt;/code&gt; 이 설정되지 않은 경우 기본 동작 은 인증되지 않은 사용자의 푸시를 거부하는 것입니다. 따라서 초기 요청은 인증 기회를주지 않고 클라이언트에게 &lt;code&gt;403 Forbidden&lt;/code&gt; 을 보고 합니다.</target>
        </trans-unit>
        <trans-unit id="427d8f8d92a71761648b972f0beb3c2aad83aaaa" translate="yes" xml:space="preserve">
          <source>In this more general usage, you provide &lt;code&gt;git bisect&lt;/code&gt; with a &quot;new&quot; commit that has some property and an &quot;old&quot; commit that doesn&amp;rsquo;t have that property. Each time &lt;code&gt;git bisect&lt;/code&gt; checks out a commit, you test if that commit has the property. If it does, mark the commit as &quot;new&quot;; otherwise, mark it as &quot;old&quot;. When the bisection is done, &lt;code&gt;git bisect&lt;/code&gt; will report which commit introduced the property.</source>
          <target state="translated">이보다 일반적인 사용법에서는 &lt;code&gt;git bisect&lt;/code&gt; 에 일부 속성이있는 &quot;new&quot;커밋과 해당 속성이없는 &quot;old&quot;커밋을 제공합니다. &lt;code&gt;git bisect&lt;/code&gt; 가 커밋을 체크 아웃 할 때마다 해당 커밋에 속성이 있는지 테스트합니다. 그렇다면 커밋을 &quot;new&quot;로 표시하십시오. 그렇지 않으면 &quot;이전&quot;으로 표시하십시오. bisection이 완료되면 &lt;code&gt;git bisect&lt;/code&gt; 는 어떤 커밋이 속성을 도입했는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="c1e29a4968fef09e4ce2211e751712b57ac5f128" translate="yes" xml:space="preserve">
          <source>In this view, we see all of the important single-parent changes from &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;X&lt;/code&gt;. We also see the carefully-resolved merge &lt;code&gt;M&lt;/code&gt; and the not-so-carefully-resolved merge &lt;code&gt;R&lt;/code&gt;. This is usually enough information to determine why the commits &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; &quot;disappeared&quot; from history in the default view. However, there are a few issues with this approach.</source>
          <target state="translated">이보기에서는 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; 의 중요한 단일 부모 변경 사항을 모두 볼 수 있습니다. 우리는 또한 신중하게 해결 된 Merge &lt;code&gt;M&lt;/code&gt; 과 그다지 신중하게 해결되지 않은 Merge &lt;code&gt;R&lt;/code&gt; 을 볼 수 있습니다. 이는 일반적으로 커밋 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 가 기본보기의 기록에서 &quot;사라진&quot; 이유를 확인하는 데 충분한 정보 입니다. 그러나이 접근 방식에는 몇 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6da0601a9e7aee317ec7d6d594e01f938b779c4" translate="yes" xml:space="preserve">
          <source>In unusual scenarios, you may not be able to create files larger than a certain size on your filesystem, and this option can be used to tell the command to split the output packfile into multiple independent packfiles, each not larger than the given size. The size can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. The minimum size allowed is limited to 1 MiB. This option prevents the creation of a bitmap index. The default is unlimited, unless the config variable &lt;code&gt;pack.packSizeLimit&lt;/code&gt; is set.</source>
          <target state="translated">비정상적인 시나리오에서는 파일 시스템에서 특정 크기보다 큰 파일을 작성하지 못할 수 있으며이 옵션을 사용하여 출력 팩 파일을 지정된 크기보다 크지 않은 여러 개의 독립적 인 팩 파일로 분할하도록 명령에 지시 할 수 있습니다. 크기는 &quot;k&quot;, &quot;m&quot;또는 &quot;g&quot;로 접미사를 붙일 수 있습니다. 허용되는 최소 크기는 1MiB로 제한됩니다. 이 옵션은 비트 맵 인덱스 생성을 방지합니다. 구성 변수 &lt;code&gt;pack.packSizeLimit&lt;/code&gt; 가 설정되어 있지 않으면 기본값은 무제한 입니다.</target>
        </trans-unit>
        <trans-unit id="4e6119784d7cd9e9e9f521473e212223da8f242e" translate="yes" xml:space="preserve">
          <source>In versions of Git before 2.23.0 patterns containing \0 would be silently considered fixed. This was never documented, there were also odd and undocumented interactions between e.g. non-ASCII patterns containing \0 and &lt;code&gt;--ignore-case&lt;/code&gt;.</source>
          <target state="translated">\ 0을 포함하는 2.23.0 패턴 이전의 Git 버전에서는 자동으로 수정 된 것으로 간주됩니다. 이것은 문서화되지 않았으며, \ 0과 &lt;code&gt;--ignore-case&lt;/code&gt; 를 포함하는 비 ASCII 패턴 사이에 홀수 및 문서화되지 않은 상호 작용도있었습니다 .</target>
        </trans-unit>
        <trans-unit id="5da95a93eebb0b267da3b6f30d0296fee9bbc09f" translate="yes" xml:space="preserve">
          <source>Inactive branches are stored in a structure which uses 96 or 120 bytes (32 bit or 64 bit systems, respectively), plus the length of the branch name (typically under 200 bytes), per branch. fast-import will easily handle as many as 10,000 inactive branches in under 2 MiB of memory.</source>
          <target state="translated">비활성 분기는 분기당 96 또는 120 바이트 (각각 32 비트 또는 64 비트 시스템)와 분기 이름의 길이 (일반적으로 200 바이트 미만)를 사용하는 구조에 저장됩니다. 빠른 가져 오기는 2MiB 미만의 메모리에서 최대 10,000 개의 비활성 분기를 쉽게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="40bf5b4a4e7b04d6908a8f7645b8e99e811e42d8" translate="yes" xml:space="preserve">
          <source>Include Some Progress Messages</source>
          <target state="translated">일부 진행 메시지 포함</target>
        </trans-unit>
        <trans-unit id="d1a7a0c5683de418c5f98fc4beae70e15874a175" translate="yes" xml:space="preserve">
          <source>Include a line &amp;ldquo;log size &amp;lt;number&amp;gt;&amp;rdquo; in the output for each commit, where &amp;lt;number&amp;gt; is the length of that commit&amp;rsquo;s message in bytes. Intended to speed up tools that read log messages from &lt;code&gt;git log&lt;/code&gt; output by allowing them to allocate space in advance.</source>
          <target state="translated">각 커밋에 대한 출력에&amp;ldquo;log size &amp;lt;number&amp;gt;&amp;rdquo;행을 포함 시키십시오. 여기서 &amp;lt;number&amp;gt;는 커밋 메시지의 길이 (바이트)입니다. 공간을 미리 할당하여 &lt;code&gt;git log&lt;/code&gt; 출력 에서 로그 메시지를 읽는 도구의 속도 를 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="af14d11414c6ac75b39c95b283e5bcf0f4ccb002" translate="yes" xml:space="preserve">
          <source>Include additional statistics at the end of blame output.</source>
          <target state="translated">비난 출력의 끝에 추가 통계를 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="67b90ce59db96c9a579b89f0489d7d9769ae1702" translate="yes" xml:space="preserve">
          <source>Include all commits from the default mode, but also any merge commits that are not TREESAME to the first parent but are TREESAME to a later parent. This mode is helpful for showing the merge commits that &quot;first introduced&quot; a change to a branch.</source>
          <target state="translated">기본 모드의 모든 커밋을 포함하지만 TREESAME이 아닌 첫 번째 부모에 대해서는 TREESAME 인 병합 커밋도 포함합니다. 이 모드는 분기에 변경 사항을 &quot;처음 도입 한&quot;병합 커밋을 표시하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="47c5e0ca752d4a1deb14e562052c4b503ef081b0" translate="yes" xml:space="preserve">
          <source>Include commits that are reachable from &amp;lt;rev&amp;gt; (i.e. &amp;lt;rev&amp;gt; and its ancestors).</source>
          <target state="translated">&amp;lt;rev&amp;gt;에서 도달 할 수있는 커밋을 포함하십시오 (예 : &amp;lt;rev&amp;gt; 및 해당 조상).</target>
        </trans-unit>
        <trans-unit id="9605f416b0921199291f14b56df68cc8fe57350a" translate="yes" xml:space="preserve">
          <source>Include commits that are reachable from &amp;lt;rev2&amp;gt; but exclude those that are reachable from &amp;lt;rev1&amp;gt;. When either &amp;lt;rev1&amp;gt; or &amp;lt;rev2&amp;gt; is omitted, it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;rev2&amp;gt;에서 도달 할 수있는 커밋을 포함하지만 &amp;lt;rev1&amp;gt;에서 도달 할 수있는 커밋은 제외하십시오. &amp;lt;rev1&amp;gt; 또는 &amp;lt;rev2&amp;gt;가 생략되면 기본값은 &lt;code&gt;HEAD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ce2adffe692042c194b87264e9afec51300d7f42" translate="yes" xml:space="preserve">
          <source>Include commits that are reachable from either &amp;lt;rev1&amp;gt; or &amp;lt;rev2&amp;gt; but exclude those that are reachable from both. When either &amp;lt;rev1&amp;gt; or &amp;lt;rev2&amp;gt; is omitted, it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;rev1&amp;gt; 또는 &amp;lt;rev2&amp;gt;에서 도달 할 수있는 커밋을 포함하지만 둘 다에서 도달 할 수있는 커밋은 제외하십시오. &amp;lt;rev1&amp;gt; 또는 &amp;lt;rev2&amp;gt;가 생략되면 기본값은 &lt;code&gt;HEAD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a1236fce64f1fb93f2ef7dcc7912c2d79c1d22c1" translate="yes" xml:space="preserve">
          <source>Include cross-references to the glossary, where appropriate.</source>
          <target state="translated">적절한 경우 용어집에 대한 상호 참조를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="ac12c15729a8f56d7cafe2e8c1b0d7927d0e53f1" translate="yes" xml:space="preserve">
          <source>Include debugging information related to the movement of lines between files (see &lt;code&gt;-C&lt;/code&gt;) and lines moved within a file (see &lt;code&gt;-M&lt;/code&gt;). The first number listed is the score. This is the number of alphanumeric characters detected as having been moved between or within files. This must be above a certain threshold for &lt;code&gt;git blame&lt;/code&gt; to consider those lines of code to have been moved.</source>
          <target state="translated">파일 간 행 이동 ( &lt;code&gt;-C&lt;/code&gt; 참조 )과 파일 내에서 이동 한 행 ( &lt;code&gt;-M&lt;/code&gt; 참조)과 관련된 디버깅 정보를 포함 하십시오 . 첫 번째 숫자는 점수입니다. 파일 간 또는 파일 내에서 이동 한 것으로 감지 된 영숫자 수입니다. &lt;code&gt;git blame&lt;/code&gt; 이 이러한 코드 줄을 이동했다고 간주하려면 특정 임계 값보다 높아야 합니다.</target>
        </trans-unit>
        <trans-unit id="eac52c02432a2a159a563ec983012928139e33b8" translate="yes" xml:space="preserve">
          <source>Include objects in &lt;code&gt;.keep&lt;/code&gt; files when repacking. Note that we still do not delete &lt;code&gt;.keep&lt;/code&gt; packs after &lt;code&gt;pack-objects&lt;/code&gt; finishes. This means that we may duplicate objects, but this makes the option safe to use when there are concurrent pushes or fetches. This option is generally only useful if you are writing bitmaps with &lt;code&gt;-b&lt;/code&gt; or &lt;code&gt;repack.writeBitmaps&lt;/code&gt;, as it ensures that the bitmapped packfile has the necessary objects.</source>
          <target state="translated">재 포장 할 때 &lt;code&gt;.keep&lt;/code&gt; 파일에 객체를 포함 시킵니다 . &lt;code&gt;pack-objects&lt;/code&gt; 가 완료된 후에도 &lt;code&gt;.keep&lt;/code&gt; pack을 삭제하지는 않습니다 . 즉, 객체를 복제 할 수 있지만 동시 푸시 또는 페치가있을 때 옵션을 안전하게 사용할 수 있습니다. 이 옵션은 일반적으로 비트 맵 팩 파일에 필요한 객체가 있으므로 &lt;code&gt;-b&lt;/code&gt; 또는 &lt;code&gt;repack.writeBitmaps&lt;/code&gt; 로 비트 맵을 작성하는 경우에만 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="3b3acf7c7b624670bc98269d1db58c312d8f1ad9" translate="yes" xml:space="preserve">
          <source>Include patch text in the output.</source>
          <target state="translated">출력에 패치 텍스트를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="7f58d83c9ac95ca37a657dfc92f2d025971598c2" translate="yes" xml:space="preserve">
          <source>Include the output of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; in the commit message template when using an editor to prepare the commit message. Defaults to on, but can be used to override configuration variable commit.status.</source>
          <target state="translated">커밋 메시지를 준비하기 위해 편집기를 사용할 때 커밋 메시지 템플릿 에 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 의 출력을 포함시킵니다 . 기본값은 on이지만 구성 변수 commit.status를 재정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="798a42403927f2977bd316b8bb1bba46f3e2c944" translate="yes" xml:space="preserve">
          <source>Include unasked-for annotated tags if the object they reference was included in the resulting packfile. This can be useful to send new tags to native Git clients.</source>
          <target state="translated">참조하는 객체가 결과 팩 파일에 포함 된 경우 주석이 달린 태그가없는 태그를 포함시킵니다. 기본 Git 클라이언트에 새 태그를 보내는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5f574d342fa2383147936f6ccc821ddf1edb5ef" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt; command to add a new file or change the content of an existing file. This command has two different means of specifying the content of the file.</source>
          <target state="translated">새 파일을 추가하거나 기존 파일의 내용을 변경하기 위해 &lt;code&gt;commit&lt;/code&gt; 명령에 포함 됩니다. 이 명령에는 파일의 내용을 지정하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dfee16c07e63cf25f2958c656ce64f423b1c0b9" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt; command to remove a file or recursively delete an entire directory from the branch. If the file or directory removal makes its parent directory empty, the parent directory will be automatically removed too. This cascades up the tree until the first non-empty directory or the root is reached.</source>
          <target state="translated">&lt;code&gt;commit&lt;/code&gt; 명령에 포함되어 파일을 제거하거나 분기에서 전체 디렉토리를 반복적으로 삭제합니다. 파일 또는 디렉토리를 제거하면 상위 디렉토리가 비어 있으면 상위 디렉토리도 자동으로 제거됩니다. 이것은 비어 있지 않은 첫 번째 디렉토리 또는 루트에 도달 할 때까지 트리를 계단식으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="87d365412b703101b1d281d9e93e3f278251dd0d" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt; command to remove all files (and also all directories) from the branch. This command resets the internal branch structure to have no files in it, allowing the frontend to subsequently add all interesting files from scratch.</source>
          <target state="translated">분기에서 모든 파일 (및 모든 디렉토리)을 제거 하는 &lt;code&gt;commit&lt;/code&gt; 명령에 포함됩니다 . 이 명령은 내부 분기 구조에 파일이 없도록 재설정하여 프론트 엔드가 모든 흥미로운 파일을 처음부터 추가 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="28dccd9788a09aa2f373fa8c25c3b39e9406a080" translate="yes" xml:space="preserve">
          <source>Included in a &lt;code&gt;commit&lt;/code&gt;&lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; command to add a new note annotating a &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; or change this annotation contents. Internally it is similar to filemodify 100644 on &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; path (maybe split into subdirectories). It&amp;rsquo;s not advised to use any other commands to write to the &lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; tree except &lt;code&gt;filedeleteall&lt;/code&gt; to delete all existing notes in this tree. This command has two different means of specifying the content of the note.</source>
          <target state="translated">&lt;code&gt;commit&lt;/code&gt; &lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; 명령에 포함되어 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 를 주석 처리하는 새 메모를 추가 하거나이 주석 내용을 변경합니다. 내부적으로 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 경로의 filemodify 100644와 유사 합니다 (하위 디렉토리로 분할 될 수 있음). &lt;code&gt;filedeleteall&lt;/code&gt; 을 제외하고 &lt;code&gt;&amp;lt;notes_ref&amp;gt;&lt;/code&gt; 트리 에 쓰는 다른 명령을 사용 하여이 트리에있는 기존의 모든 노트를 삭제 하지 않는 것이 좋습니다 . 이 명령에는 메모 내용을 지정하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="db54974f7f0ad531e35648ba85b9388029b4d7ef" translate="yes" xml:space="preserve">
          <source>Includes</source>
          <target state="translated">Includes</target>
        </trans-unit>
        <trans-unit id="de153f024523e4c2c467ece94c841922a681ecff" translate="yes" xml:space="preserve">
          <source>Includes one additional ancestor commit. The additional ancestry link does not change the way the tree state is built at this commit. If the &lt;code&gt;from&lt;/code&gt; command is omitted when creating a new branch, the first &lt;code&gt;merge&lt;/code&gt; commit will be the first ancestor of the current commit, and the branch will start out with no files. An unlimited number of &lt;code&gt;merge&lt;/code&gt; commands per commit are permitted by fast-import, thereby establishing an n-way merge.</source>
          <target state="translated">하나의 추가 조상 커밋을 포함합니다. 추가 상위 링크는이 커밋에서 트리 상태가 구축되는 방식을 변경하지 않습니다. 는 IF &lt;code&gt;from&lt;/code&gt; 새로운 지점을 만들 때 명령이 생략 첫 번째 &lt;code&gt;merge&lt;/code&gt; 커밋 현재의 첫 조상이 커밋 될 것이며, 지점이없는 파일로 시작됩니다. 커밋 당 무제한의 &lt;code&gt;merge&lt;/code&gt; 명령이 빠른 가져 오기로 허용되므로 n-way 병합이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8623cf320c015aba351966293c038ddef6f53905" translate="yes" xml:space="preserve">
          <source>Incompatible options</source>
          <target state="translated">호환되지 않는 옵션</target>
        </trans-unit>
        <trans-unit id="9020a39adcad5a9de717e37976fa2cef184a1df6" translate="yes" xml:space="preserve">
          <source>Incorporates changes from a remote repository into the current branch. In its default mode, &lt;code&gt;git pull&lt;/code&gt; is shorthand for &lt;code&gt;git fetch&lt;/code&gt; followed by &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt;.</source>
          <target state="translated">원격 저장소에서 현재 분기로 변경 사항을 통합합니다. 기본 모드에서는 &lt;code&gt;git pull&lt;/code&gt; 위한 속기 &lt;code&gt;git fetch&lt;/code&gt; 다음에 &lt;code&gt;git merge FETCH_HEAD&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d61077e89adde5af7a04457989a77b3c48490ae" translate="yes" xml:space="preserve">
          <source>Incorporates changes from the named commits (since the time their histories diverged from the current branch) into the current branch. This command is used by &lt;code&gt;git pull&lt;/code&gt; to incorporate changes from another repository and can be used by hand to merge changes from one branch into another.</source>
          <target state="translated">이름이 지정된 커밋의 변경 사항 (이력이 현재 분기에서 분기 된 시점부터)을 현재 분기로 통합합니다. 이 명령은 &lt;code&gt;git pull&lt;/code&gt; 에서 다른 저장소의 변경 사항을 통합하는 데 사용되며 한 분기에서 다른 분기로 변경 사항을 병합하는 데 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="709702f7f984cb3913cdb163bc5d2fe003c81b05" translate="yes" xml:space="preserve">
          <source>Incremental output</source>
          <target state="translated">증분 출력</target>
        </trans-unit>
        <trans-unit id="571937052d91a812bc84d435a3200a79bb1a0ee1" translate="yes" xml:space="preserve">
          <source>Indeed untestable commits are often untestable because a breakage was introduced at one time, and that breakage was fixed only after many other commits were introduced.</source>
          <target state="translated">실제로 테스트 할 수없는 커밋은 한 번에 파손이 발생하여 테스트 할 수없는 경우가 많으며, 다른 많은 커밋이 도입 된 후에야 손상이 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="78699f384a94184571a61ab6b2f36f5cdf341b61" translate="yes" xml:space="preserve">
          <source>Indicate that only the objects wanted need to be fetched, not their dependents.</source>
          <target state="translated">종속물이 아닌 원하는 객체 만 가져와야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d063c49b2950871e5e846c69f89ed3fa8315be66" translate="yes" xml:space="preserve">
          <source>Indicate that these objects are being fetched from a promisor.</source>
          <target state="translated">이러한 개체가 약속에서 가져오고 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d4b8f31320c23f43d173d656edb4ca6c63551ac5" translate="yes" xml:space="preserve">
          <source>Indicates a blob object name.</source>
          <target state="translated">얼룩 개체 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6d441ed12cf0b86c55591d731de178963fe6c1ee" translate="yes" xml:space="preserve">
          <source>Indicates a commit object name.</source>
          <target state="translated">커밋 개체 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e89d58f77c5643f4921d84ac3c1216b6dc569e02" translate="yes" xml:space="preserve">
          <source>Indicates a commit or tag object name. A command that takes a &amp;lt;commit-ish&amp;gt; argument ultimately wants to operate on a &amp;lt;commit&amp;gt; object but automatically dereferences &amp;lt;tag&amp;gt; objects that point at a &amp;lt;commit&amp;gt;.</source>
          <target state="translated">커밋 또는 태그 객체 이름을 나타냅니다. &amp;lt;commit-ish&amp;gt; 인수를 사용하는 명령은 궁극적으로 &amp;lt;commit&amp;gt; 객체에서 작동하려고하지만 &amp;lt;commit&amp;gt;을 가리키는 &amp;lt;tag&amp;gt; 객체를 자동으로 역 참조합니다.</target>
        </trans-unit>
        <trans-unit id="31963740af1f01e0807009b4b0a81e30ade64f1a" translate="yes" xml:space="preserve">
          <source>Indicates a filename - almost always relative to the root of the tree structure &lt;code&gt;GIT_INDEX_FILE&lt;/code&gt; describes.</source>
          <target state="translated">파일 이름을 나타냅니다. 거의 항상 &lt;code&gt;GIT_INDEX_FILE&lt;/code&gt; 이 설명 하는 트리 구조의 루트에 상대적 입니다.</target>
        </trans-unit>
        <trans-unit id="c59be5c9a5ab736a07e28f031fa629ea1cac80d9" translate="yes" xml:space="preserve">
          <source>Indicates a tree object name.</source>
          <target state="translated">트리 개체 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0236f6573fabb077368d656582f35373ba9e33e6" translate="yes" xml:space="preserve">
          <source>Indicates a tree, commit or tag object name. A command that takes a &amp;lt;tree-ish&amp;gt; argument ultimately wants to operate on a &amp;lt;tree&amp;gt; object but automatically dereferences &amp;lt;commit&amp;gt; and &amp;lt;tag&amp;gt; objects that point at a &amp;lt;tree&amp;gt;.</source>
          <target state="translated">트리, 커밋 또는 태그 객체 이름을 나타냅니다. &amp;lt;tree-ish&amp;gt; 인수를 사용하는 명령은 궁극적으로 &amp;lt;tree&amp;gt; 객체에서 작동하려고하지만 &amp;lt;tree&amp;gt;를 가리키는 &amp;lt;commit&amp;gt; 및 &amp;lt;tag&amp;gt; 객체를 자동으로 역 참조합니다.</target>
        </trans-unit>
        <trans-unit id="73ecb0013f5389f15738299d7b0ca5b5c29b261f" translate="yes" xml:space="preserve">
          <source>Indicates that an object type is required. Currently one of: &lt;code&gt;blob&lt;/code&gt;, &lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;commit&lt;/code&gt;, or &lt;code&gt;tag&lt;/code&gt;.</source>
          <target state="translated">객체 유형이 필요함을 나타냅니다. 현재 &lt;code&gt;blob&lt;/code&gt; , &lt;code&gt;tree&lt;/code&gt; , &lt;code&gt;commit&lt;/code&gt; 또는 &lt;code&gt;tag&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="db4dbaff6f210d92fcd8a0947f8ffe2ad6166cf6" translate="yes" xml:space="preserve">
          <source>Indicates the object name for any type of object.</source>
          <target state="translated">모든 유형의 객체에 대한 객체 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c66f56b69efd11f38dd2949f22030f51d42bccb8" translate="yes" xml:space="preserve">
          <source>Individual developer (participant)</source>
          <target state="translated">개인 개발자 (참가자)</target>
        </trans-unit>
        <trans-unit id="dc704b04bf6fc4b099b66d2f7d86d56e0d061d7a" translate="yes" xml:space="preserve">
          <source>Individual developer (standalone)</source>
          <target state="translated">개별 개발자 (독립형)</target>
        </trans-unit>
        <trans-unit id="a964b0aa320ab2176eba7cb0319b97ea34b340ac" translate="yes" xml:space="preserve">
          <source>Individually replay all rebased commits instead of fast-forwarding over the unchanged ones. This ensures that the entire history of the rebased branch is composed of new commits.</source>
          <target state="translated">변경되지 않은 것을 빠르게 전달하는 대신 모든 재 기반 커밋을 개별적으로 재생합니다. 이를 통해 리베이스 브랜치의 전체 히스토리가 새 확약으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="0eb5ed506e4923c28d7f4a8aa69efe99b3ad75d1" translate="yes" xml:space="preserve">
          <source>Information</source>
          <target state="translated">Information</target>
        </trans-unit>
        <trans-unit id="9bceb94c72e397fee5b7ad78b8c9312ee6319e43" translate="yes" xml:space="preserve">
          <source>Information about what is to be pushed is provided on the hook&amp;rsquo;s standard input with lines of the form:</source>
          <target state="translated">푸시 대상에 대한 정보는 다음 형식의 행이있는 후크의 표준 입력에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="43d35f7b76c469225469fd7a04662a08053d1e63" translate="yes" xml:space="preserve">
          <source>Initial client request</source>
          <target state="translated">초기 고객 요청</target>
        </trans-unit>
        <trans-unit id="68fa16ffd48f366e4fa8d57fea78ff03fcab0191" translate="yes" xml:space="preserve">
          <source>Initialization</source>
          <target state="translated">Initialization</target>
        </trans-unit>
        <trans-unit id="1b499097655f7a7af4711e162d7e54be3deca803" translate="yes" xml:space="preserve">
          <source>Initialization happens in &lt;code&gt;main()&lt;/code&gt;. Behind the scenes, an &lt;code&gt;atexit&lt;/code&gt; and &lt;code&gt;signal&lt;/code&gt; handler are registered.</source>
          <target state="translated">초기화는 &lt;code&gt;main()&lt;/code&gt; 에서 발생합니다 . 장면 뒤에는 &lt;code&gt;atexit&lt;/code&gt; 과 &lt;code&gt;signal&lt;/code&gt; handler가 등록되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="42e32f1c6a8cf663f45361425590d312db136ea3" translate="yes" xml:space="preserve">
          <source>Initialize and modify the sparse-checkout</source>
          <target state="translated">스파 스 체크 아웃 초기화 및 수정</target>
        </trans-unit>
        <trans-unit id="5be83bd5256f93987e394207f3c5233baf2d713e" translate="yes" xml:space="preserve">
          <source>Initialize and modify the sparse-checkout configuration, which reduces the checkout to a set of paths given by a list of patterns.</source>
          <target state="translated">스파 스 체크 아웃 구성을 초기화하고 수정하여 체크 아웃을 패턴 목록으로 지정된 경로 세트로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="825b58a6f65001fb659dd3ff519bf4df985a29aa" translate="yes" xml:space="preserve">
          <source>Initialize the sparse-checkout file so the working directory starts with only the files in the root of the repository. The sparse-checkout file can be modified to grow the working directory as needed.</source>
          <target state="translated">스파 스 체크 아웃 파일을 초기화하여 작업 디렉토리가 저장소 루트의 파일로만 시작되도록하십시오. 스파 스 체크 아웃 파일은 필요에 따라 작업 디렉토리를 늘리도록 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e0eca47ea83eb468f0ac7fe2e029fd23bbe773e" translate="yes" xml:space="preserve">
          <source>Initialize the submodules recorded in the index (which were added and committed elsewhere) by setting &lt;code&gt;submodule.$name.url&lt;/code&gt; in .git/config. It uses the same setting from &lt;code&gt;.gitmodules&lt;/code&gt; as a template. If the URL is relative, it will be resolved using the default remote. If there is no default remote, the current repository will be assumed to be upstream.</source>
          <target state="translated">.git / config에서 &lt;code&gt;submodule.$name.url&lt;/code&gt; 을 설정하여 인덱스에 기록 된 서브 모듈 (다른 곳에서 추가되고 커밋 된)을 초기화하십시오 . &lt;code&gt;.gitmodules&lt;/code&gt; 의 템플릿 과 동일한 설정을 사용합니다 . 상대 URL 인 경우 기본 원격을 사용하여 해결됩니다. 기본 원격이없는 경우 현재 저장소는 업스트림 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="52f8f7589ec2fc901a83216cac5106872728a87d" translate="yes" xml:space="preserve">
          <source>Initialize, update or inspect submodules</source>
          <target state="translated">서브 모듈 초기화, 업데이트 또는 검사</target>
        </trans-unit>
        <trans-unit id="0d880d50dc463cd4220f01bcf54c48c1f2d57098" translate="yes" xml:space="preserve">
          <source>Initializes an empty Git repository with additional metadata directories for &lt;code&gt;git svn&lt;/code&gt;. The Subversion URL may be specified as a command-line argument, or as full URL arguments to -T/-t/-b. Optionally, the target directory to operate on can be specified as a second argument. Normally this command initializes the current directory.</source>
          <target state="translated">&lt;code&gt;git svn&lt;/code&gt; 에 대한 추가 메타 데이터 디렉토리를 사용하여 빈 Git 저장소를 초기화합니다 . Subversion URL은 명령 줄 인수 또는 -T / -t / -b에 대한 전체 URL 인수로 지정할 수 있습니다. 선택적으로 조작 할 대상 디렉토리를 두 ​​번째 인수로 지정할 수 있습니다. 일반적으로이 명령은 현재 디렉토리를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="01c2c8357a87e8a6148f1dd9a9c884aae5e4de53" translate="yes" xml:space="preserve">
          <source>Initially ignore any whitespace in the move detection, then group the moved code blocks only into a block if the change in whitespace is the same per line. This is incompatible with the other modes.</source>
          <target state="translated">이동 감지에서 공백을 처음 무시한 다음 공백 변경이 한 줄에 동일한 경우 이동 된 코드 블록을 블록으로 만 그룹화하십시오. 다른 모드와 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="229b7991e581f774e065f13c78dfa8719c8c393f" translate="yes" xml:space="preserve">
          <source>Inline data format</source>
          <target state="translated">인라인 데이터 형식</target>
        </trans-unit>
        <trans-unit id="7c7935726f449ea7185a4fe42a9ddf2d1c53a2e4" translate="yes" xml:space="preserve">
          <source>Input Format</source>
          <target state="translated">입력 형식</target>
        </trans-unit>
        <trans-unit id="1b77a7f4983f9ce773f466c761a7f6e9771bf925" translate="yes" xml:space="preserve">
          <source>Input format</source>
          <target state="translated">입력 형식</target>
        </trans-unit>
        <trans-unit id="789cc08a97020bab893e17ca6133192d1f9f1dac" translate="yes" xml:space="preserve">
          <source>Input is of the &quot;mboxrd&quot; format and &quot;^&amp;gt;+From &quot; line escaping is reversed.</source>
          <target state="translated">입력은 &quot;mboxrd&quot;형식이며 &quot;^&amp;gt; + From&quot;줄 이스케이프는 반대로됩니다.</target>
        </trans-unit>
        <trans-unit id="26242e7bd97bd8eebf44f9f25f143aed3a9bdc4d" translate="yes" xml:space="preserve">
          <source>Input/output format</source>
          <target state="translated">입출력 형식</target>
        </trans-unit>
        <trans-unit id="4038e1c7ebc07b210c228498bd5816f54233b768" translate="yes" xml:space="preserve">
          <source>Insert &lt;code&gt;progress&lt;/code&gt; statements every &amp;lt;n&amp;gt; objects, to be shown by &lt;code&gt;git fast-import&lt;/code&gt; during import.</source>
          <target state="translated">&lt;code&gt;git fast-import&lt;/code&gt; 동안 git fast-import 로 표시 될 &amp;lt;n&amp;gt; 객체마다 &lt;code&gt;progress&lt;/code&gt; 문을 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="39c559793b49987eea00aba844e216707b6e7dcc" translate="yes" xml:space="preserve">
          <source>Insert custom links to the action bar of all project pages. This allows you to link to third-party scripts integrating into gitweb.</source>
          <target state="translated">모든 프로젝트 페이지의 작업 표시 줄에 사용자 정의 링크를 삽입하십시오. 이를 통해 gitweb에 통합 된 타사 스크립트에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce8fd02283c353dc3cacd2d3e6c1eab64a1913a3" translate="yes" xml:space="preserve">
          <source>Inside double quotes, double quote &lt;code&gt;&quot;&lt;/code&gt; and backslash &lt;code&gt;\&lt;/code&gt; characters must be escaped: use &lt;code&gt;\&quot;&lt;/code&gt; for &lt;code&gt;&quot;&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt; for &lt;code&gt;\&lt;/code&gt;.</source>
          <target state="translated">큰 따옴표, 큰 따옴표 내부 &lt;code&gt;&quot;&lt;/code&gt; 와 백 슬래시 &lt;code&gt;\&lt;/code&gt; 문자는 이스케이프해야합니다 : 사용 &lt;code&gt;\&quot;&lt;/code&gt; 에 대한 &lt;code&gt;&quot;&lt;/code&gt; 과 &lt;code&gt;\\&lt;/code&gt; 를 들어 &lt;code&gt;\&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab67c68674bb4a9f1f690fac98c95aa9c2e1e750" translate="yes" xml:space="preserve">
          <source>Inspecting changes</source>
          <target state="translated">변경 사항 검사</target>
        </trans-unit>
        <trans-unit id="ecf21e44dd8609734c0bc387cabc376ab485d9f8" translate="yes" xml:space="preserve">
          <source>Inspection and Comparison</source>
          <target state="translated">검사 및 비교</target>
        </trans-unit>
        <trans-unit id="e0c3f2780ee983978068137722cf2d423843d21f" translate="yes" xml:space="preserve">
          <source>Inspects, updates and manages submodules.</source>
          <target state="translated">하위 모듈을 검사, 업데이트 및 관리합니다.</target>
        </trans-unit>
        <trans-unit id="d9fb6eb12bbc11fdad6f18ee5bfa79361ddad72b" translate="yes" xml:space="preserve">
          <source>Install the Toggle Word Wrap add-on that is available from &lt;a href=&quot;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&quot;&gt;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&lt;/a&gt; It adds a menu entry &quot;Enable Word Wrap&quot; in the composer&amp;rsquo;s &quot;Options&quot; menu that you can tick off. Now you can compose the message as you otherwise do (cut + paste, &lt;code&gt;git format-patch&lt;/code&gt; | &lt;code&gt;git imap-send&lt;/code&gt;, etc), but you have to insert line breaks manually in any text that you type.</source>
          <target state="translated">&lt;a href=&quot;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&quot;&gt;https://addons.mozilla.org/thunderbird/addon/toggle-word-wrap/&lt;/a&gt; 에서 제공되는 Toggle Word Wrap 애드온을 설치합니다 . 작곡가의 &quot;Options&quot;메뉴에 &quot;Enable Word Wrap&quot;메뉴 항목이 추가됩니다. 똑딱 거릴 수 있습니다. 이제 다른 방법으로 메시지를 작성할 수 있지만 (cut + paste, &lt;code&gt;git format-patch&lt;/code&gt; | &lt;code&gt;git imap-send&lt;/code&gt; 등) 입력하는 모든 텍스트에 줄 바꿈을 수동으로 삽입해야합니다.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="7fad939655efbad1612ce7f4867922684d56913b" translate="yes" xml:space="preserve">
          <source>Instantly browse your working repository in gitweb</source>
          <target state="translated">gitweb에서 작업 저장소를 즉시 탐색하십시오.</target>
        </trans-unit>
        <trans-unit id="53c902fb07156c6117155b6a0b0738c7ca12a6bf" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;git bisect visualize&lt;/code&gt; and then &lt;code&gt;git reset --hard
fb47ddb2db&lt;/code&gt;, you might just want to tell Git that you want to skip the current commit:</source>
          <target state="translated">&lt;code&gt;git bisect visualize&lt;/code&gt; 한 다음 &lt;code&gt;git reset --hard fb47ddb2db&lt;/code&gt; 대신 현재 커밋을 건너 뛰겠다 고 Git에 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="483617d942bddc8b6c044cd054e06089960e1981" translate="yes" xml:space="preserve">
          <source>Instead of a commit id on the command line (which is not expected in this case), &lt;code&gt;git http-fetch&lt;/code&gt; expects lines on stdin in the format</source>
          <target state="translated">명령 줄에 커밋 ID 대신 (이 경우에는 예상되지 않음) &lt;code&gt;git http-fetch&lt;/code&gt; 는 stdin의 행을 형식으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="78b5184ca479cbe7999ac4fee6c0be2a7fd5b77a" translate="yes" xml:space="preserve">
          <source>Instead of a commit id on the command line (which is not expected in this case), &lt;code&gt;git http-fetch&lt;/code&gt; fetches the packfile directly at the given URL and uses index-pack to generate corresponding .idx and .keep files. The hash is used to determine the name of the temporary file and is arbitrary. The output of index-pack is printed to stdout.</source>
          <target state="translated">명령 줄의 커밋 ID (이 경우에는 예상되지 않음) 대신 &lt;code&gt;git http-fetch&lt;/code&gt; 는 주어진 URL에서 직접 packfile을 가져 오고 index-pack을 사용하여 해당 .idx 및 .keep 파일을 생성합니다. 해시는 임시 파일의 이름을 결정하는 데 사용되며 임의적입니다. index-pack의 출력은 stdout에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="978fdd37a8d1d967862cc9e916d011571d6998cf" translate="yes" xml:space="preserve">
          <source>Instead of an absolute timestamp relative timestamps work as well, e.g. 2.weeks.ago is valid to address anything older than 2 weeks.</source>
          <target state="translated">절대 타임 스탬프 대신 상대적 타임 스탬프도 작동합니다. 예를 들어 2.weeks.ago는 2 주보다 오래된 모든 것을 처리하는 데 유효합니다.</target>
        </trans-unit>
        <trans-unit id="ad6345e758058b67dc8e001b3a11fe48b9b5f52b" translate="yes" xml:space="preserve">
          <source>Instead of applying the patch, output a condensed summary of information obtained from git diff extended headers, such as creations, renames and mode changes. Turns off &quot;apply&quot;.</source>
          <target state="translated">패치를 적용하는 대신, 생성, 이름 변경 및 모드 변경과 같은 git diff 확장 헤더에서 얻은 정보 요약 요약을 출력합니다. &quot;적용&quot;을 끕니다.</target>
        </trans-unit>
        <trans-unit id="5429abc21a21a789987424e6c0ab7612e06a85eb" translate="yes" xml:space="preserve">
          <source>Instead of applying the patch, output diffstat for the input. Turns off &quot;apply&quot;.</source>
          <target state="translated">패치를 적용하는 대신 입력에 대해 diffstat를 출력하십시오. &quot;적용&quot;을 끕니다.</target>
        </trans-unit>
        <trans-unit id="881bf52883e6605d5234b3f22aaf3b7b4afc6968" translate="yes" xml:space="preserve">
          <source>Instead of applying the patch, see if the patch is applicable to the current working tree and/or the index file and detects errors. Turns off &quot;apply&quot;.</source>
          <target state="translated">패치를 적용하는 대신 패치가 현재 작업 트리 및 / 또는 인덱스 파일에 적용 가능한지 확인하고 오류를 감지하십시오. &quot;적용&quot;을 끕니다.</target>
        </trans-unit>
        <trans-unit id="6e355f85b13671d925fde0c740a0dbae977bb0bc" translate="yes" xml:space="preserve">
          <source>Instead of basing a new branch on current HEAD (the default), use:</source>
          <target state="translated">현재 HEAD (기본값)를 기반으로 새 분기를 작성하는 대신 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="54f9cd044bb973ffe696d82cb4d71b8b1fd61c38" translate="yes" xml:space="preserve">
          <source>Instead of calling cvsps, read the provided cvsps output file. Useful for debugging or when cvsps is being handled outside cvsimport.</source>
          <target state="translated">cvsp를 호출하는 대신 제공된 cvsps 출력 파일을 읽으십시오. 디버깅 또는 cvsps가 cvsimport 외부에서 처리 될 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bb5ec3e62f50f37c713576e81a7468472cf1721e" translate="yes" xml:space="preserve">
          <source>Instead of checking out unmerged entries, copy out the files from named stage. &amp;lt;number&amp;gt; must be between 1 and 3. Note: --stage=all automatically implies --temp.</source>
          <target state="translated">병합되지 않은 항목을 체크 아웃하는 대신 명명 된 스테이지에서 파일을 복사하십시오. &amp;lt;number&amp;gt;는 1과 3 사이 여야합니다. 참고 : --stage = all은 자동으로 --temp를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="15d18d5e837d77d2ad93145197274038afcfa944" translate="yes" xml:space="preserve">
          <source>Instead of choosing a nearby commit by yourself, you can ask Git to do it for you by issuing the command:</source>
          <target state="translated">근처 커밋을 직접 선택하는 대신 다음 명령을 실행하여 Git에 요청합니다.</target>
        </trans-unit>
        <trans-unit id="071c6c805d6df82b0ae0937a6e3d6e7d94979975" translate="yes" xml:space="preserve">
          <source>Instead of comparing with the tip of &quot;test&quot; branch, compare with the tip of the current branch, but limit the comparison to the file &quot;test&quot;.</source>
          <target state="translated">&quot;테스트&quot;분기의 팁과 비교하는 대신 현재 분기의 팁과 비교하지만 &quot;test&quot;파일로 비교를 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="17207c6e7e5006477485c406ccec2ab95d9a0907" translate="yes" xml:space="preserve">
          <source>Instead of considering only the 10 most recent tags as candidates to describe the input commit-ish consider up to &amp;lt;n&amp;gt; candidates. Increasing &amp;lt;n&amp;gt; above 10 will take slightly longer but may produce a more accurate result. An &amp;lt;n&amp;gt; of 0 will cause only exact matches to be output.</source>
          <target state="translated">입력 커밋을 설명하기 위해 가장 최근 10 개의 태그 만 후보로 간주하는 대신 최대 &amp;lt;n&amp;gt; 개의 후보를 고려하십시오. &amp;lt;n&amp;gt;을 10보다 높이면 약간 더 오래 걸리지 만보다 정확한 결과를 얻을 수 있습니다. &amp;lt;n&amp;gt;이 0이면 정확히 일치하는 항목 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="3d51a8a573b601f04a9b432f10be7818f6056cab" translate="yes" xml:space="preserve">
          <source>Instead of copying the files to the working directory write the content to temporary files. The temporary name associations will be written to stdout.</source>
          <target state="translated">작업 디렉토리에 파일을 복사하는 대신 컨텐츠를 임시 파일에 작성하십시오. 임시 이름 연결은 stdout에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="aece37f2a7e1b433117b2533e4c10ff1af967895" translate="yes" xml:space="preserve">
          <source>Instead of explicitly specifying which refs to update, update all heads that locally exist.</source>
          <target state="translated">업데이트 할 참조를 명시 적으로 지정하는 대신 로컬에 존재하는 모든 헤드를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="c9dd00560176cb59ca6811a38f98f0a00cea59a2" translate="yes" xml:space="preserve">
          <source>Instead of finding the tag that predates the commit, find the tag that comes after the commit, and thus contains it. Automatically implies --tags.</source>
          <target state="translated">커밋 이전의 태그를 찾는 대신 커밋 뒤에 오는 태그를 찾아서 포함합니다. --tags를 자동으로 암시합니다.</target>
        </trans-unit>
        <trans-unit id="c3bcf62d531bd115333abb263736c08fc67412f8" translate="yes" xml:space="preserve">
          <source>Instead of having gitweb find repositories by scanning filesystem starting from $projectroot, you can provide a pre-generated list of visible projects by setting &lt;code&gt;$projects_list&lt;/code&gt; to point to a plain text file with a list of projects (with some additional info).</source>
          <target state="translated">$ projectroot에서 시작하는 파일 시스템을 스캔하여 gitweb이 저장소를 찾도록하는 대신 &lt;code&gt;$projects_list&lt;/code&gt; 를 설정하여 프로젝트 목록이 있는 일반 텍스트 파일을 가리 키도록 (일부 추가 정보 포함) 미리 생성 된 보이는 프로젝트 목록을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8a426e0ceafe99f9ee69973b04f605e2dee7cb4" translate="yes" xml:space="preserve">
          <source>Instead of incrementally packing the unpacked objects, pack everything referenced into a single pack. Especially useful when packing a repository that is used for private development. Use with &lt;code&gt;-d&lt;/code&gt;. This will clean up the objects that &lt;code&gt;git prune&lt;/code&gt; leaves behind, but &lt;code&gt;git fsck --full --dangling&lt;/code&gt; shows as dangling.</source>
          <target state="translated">압축을 푼 개체를 점진적으로 포장하는 대신 참조 된 모든 것을 단일 팩에 포장하십시오. 개인 개발에 사용되는 저장소를 포장 할 때 특히 유용합니다. &lt;code&gt;-d&lt;/code&gt; 와 함께 사용하십시오 . 이것은 &lt;code&gt;git prune&lt;/code&gt; 이 남겨둔 객체를 정리 하지만 &lt;code&gt;git fsck --full --dangling&lt;/code&gt; 은 매달려있는 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="f1ffab5966e331d53c3cb8a3d86f241f936c7bef" translate="yes" xml:space="preserve">
          <source>Instead of initializing the repository as a directory to either &lt;code&gt;$GIT_DIR&lt;/code&gt; or &lt;code&gt;./.git/&lt;/code&gt;, create a text file there containing the path to the actual repository. This file acts as filesystem-agnostic Git symbolic link to the repository.</source>
          <target state="translated">저장소를 &lt;code&gt;$GIT_DIR&lt;/code&gt; &lt;code&gt;./.git/&lt;/code&gt; 또는 ./.git/ 디렉토리로 초기화하는 대신 실제 저장소의 경로를 포함하는 텍스트 파일을 작성하십시오. 이 파일은 저장소에 대한 파일 시스템과 무관 한 Git 심볼릭 링크 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="f0ef88b9adcd939e8a3f3a231e5d0c4737f1545c" translate="yes" xml:space="preserve">
          <source>Instead of leaving conflicts in the file, resolve conflicts favouring our (or their or both) side of the lines.</source>
          <target state="translated">파일에 충돌을 남기지 말고 회선의 (또는 둘 모두) 선호하는 충돌을 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="ca8be3d7e71d110990923e82a424a61c61fcfea3" translate="yes" xml:space="preserve">
          <source>Instead of making a tar archive from the local repository, retrieve a tar archive from a remote repository. Note that the remote repository may place restrictions on which sha1 expressions may be allowed in &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt;. See &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive[1]&lt;/a&gt; for details.</source>
          <target state="translated">로컬 저장소에서 tar 아카이브를 작성하는 대신 원격 저장소에서 tar 아카이브를 검색하십시오. 원격 저장소는 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 에서 sha1 표현식이 허용 될 수있는 제한 사항을 지정할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;git-upload-archive&quot;&gt;git-upload-archive [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7f9313c2b37d59bfbfa07ff3336c61ac5f242846" translate="yes" xml:space="preserve">
          <source>Instead of multiple service names, multiple commands will be supported by a single service</source>
          <target state="translated">여러 서비스 이름 대신 단일 서비스에서 여러 명령이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9913e3351ae1177f0328b10cfa41d1a78100d839" translate="yes" xml:space="preserve">
          <source>Instead of naming each ref to push, specifies that all refs under &lt;code&gt;refs/&lt;/code&gt; (which includes but is not limited to &lt;code&gt;refs/heads/&lt;/code&gt;, &lt;code&gt;refs/remotes/&lt;/code&gt;, and &lt;code&gt;refs/tags/&lt;/code&gt;) be mirrored to the remote repository. Newly created local refs will be pushed to the remote end, locally updated refs will be force updated on the remote end, and deleted refs will be removed from the remote end. This is the default if the configuration option &lt;code&gt;remote.&amp;lt;remote&amp;gt;.mirror&lt;/code&gt; is set.</source>
          <target state="translated">각 참조의 이름을 푸시로 지정하는 대신, 참조 &lt;code&gt;refs/&lt;/code&gt; 아래의 모든 참조 ( &lt;code&gt;refs/heads/&lt;/code&gt; , &lt;code&gt;refs/remotes/&lt;/code&gt; 및 &lt;code&gt;refs/tags/&lt;/code&gt; 포함 )가 원격 저장소에 미러링되도록 지정합니다. 새로 생성 된 로컬 참조는 원격 끝으로 푸시되고 로컬로 업데이트 된 참조는 원격 끝에서 강제로 업데이트되며 삭제 된 참조는 원격 끝에서 제거됩니다. 구성 옵션 &lt;code&gt;remote.&amp;lt;remote&amp;gt;.mirror&lt;/code&gt; 가 설정된 경우 이것이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="9634150ab7e71bf3eb3f2b25ec8ede96c11d4e06" translate="yes" xml:space="preserve">
          <source>Instead of naming the commits using the path to reach them from heads (e.g. &quot;master~2&quot; to mean the grandparent of &quot;master&quot;), name them with the unique prefix of their object names.</source>
          <target state="translated">경로를 사용하여 커밋에 이름을 지정하는 대신 (예 : &quot;master&quot;의 조부모를 의미하는 &quot;master ~ 2&quot;) 개체 이름의 고유 접두사로 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="17b0b1c8040238e6478f5b3afd0b8cbc3b08f080" translate="yes" xml:space="preserve">
          <source>Instead of placing the cloned repository where it is supposed to be, place the cloned repository at the specified directory, then make a filesystem-agnostic Git symbolic link to there. The result is Git repository can be separated from working tree.</source>
          <target state="translated">복제 된 저장소를 원래 위치에 배치하는 대신 지정된 디렉토리에 복제 된 저장소를 배치 한 다음 파일 시스템에 무관 한 Git 기호 링크를 작성하십시오. 결과적으로 Git 저장소는 작업 트리와 분리 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22fb130092ca941fcb14aff3909ae71b595afba3" translate="yes" xml:space="preserve">
          <source>Instead of pointing the newly created HEAD to the branch pointed to by the cloned repository&amp;rsquo;s HEAD, point to &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; branch instead. In a non-bare repository, this is the branch that will be checked out. &lt;code&gt;--branch&lt;/code&gt; can also take tags and detaches the HEAD at that commit in the resulting repository.</source>
          <target state="translated">새로 작성된 HEAD를 복제 된 저장소의 HEAD가 가리키는 분기를 가리 키지 않고 대신 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 분기를 가리 킵니다 . Bare 이외의 저장소에서는 체크 아웃 할 분기입니다. &lt;code&gt;--branch&lt;/code&gt; 는 결과 저장소의 해당 커밋에서 태그를 가져와 HEAD를 분리 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="33ebce829b735e00e4c7bea8b4f644ee8c315aa6" translate="yes" xml:space="preserve">
          <source>Instead of printing both the SHA-1 and the name, print only the name. If given with --tags the usual tag prefix of &quot;tags/&quot; is also omitted from the name, matching the output of &lt;code&gt;git-describe&lt;/code&gt; more closely.</source>
          <target state="translated">SHA-1과 이름을 모두 인쇄하는 대신 이름 만 인쇄하십시오. --tags를 지정하면 &quot;tags /&quot;의 일반적인 태그 접두어도 이름에서 생략되어 &lt;code&gt;git-describe&lt;/code&gt; 의 출력과 더 밀접하게 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="064cb6e81b93b30bcf346d10dc97336e618d6fae" translate="yes" xml:space="preserve">
          <source>Instead of printing merge bases, print a minimal subset of the supplied commits with the same ancestors. In other words, among the commits given, list those which cannot be reached from any other. This mimics the behavior of &lt;code&gt;git show-branch --independent&lt;/code&gt;.</source>
          <target state="translated">병합베이스를 인쇄하는 대신 제공된 상위 커밋의 최소 서브 세트를 동일한 조상으로 인쇄하십시오. 다시 말해서, 주어진 커밋 중에서 다른 것으로부터 도달 할 수없는 것을 나열하십시오. 이것은 &lt;code&gt;git show-branch --independent&lt;/code&gt; 의 동작을 모방합니다 .</target>
        </trans-unit>
        <trans-unit id="323f56e14b223cf1dac7d6a09fb1d2d15675463d" translate="yes" xml:space="preserve">
          <source>Instead of printing the paths that are excluded, for each path that matches an exclude pattern, print the exclude pattern together with the path. (Matching an exclude pattern usually means the path is excluded, but if the pattern begins with &lt;code&gt;!&lt;/code&gt; then it is a negated pattern and matching it means the path is NOT excluded.)</source>
          <target state="translated">제외 된 경로를 인쇄하는 대신 제외 패턴과 일치하는 각 경로에 대해 경로와 함께 제외 패턴을 인쇄합니다. (제외 패턴 일치는 일반적으로 경로가 제외됨을 의미하지만 패턴이 &lt;code&gt;!&lt;/code&gt; 로 시작 하면 부정 패턴이고 일치하는 것은 경로가 제외되지 않음을 의미합니다.)</target>
        </trans-unit>
        <trans-unit id="a77a1e8325cae4bfdfe406c89eaae3fe4ca07d52" translate="yes" xml:space="preserve">
          <source>Instead of reading a list of objects on stdin, perform the requested batch operation on all objects in the repository and any alternate object stores (not just reachable objects). Requires &lt;code&gt;--batch&lt;/code&gt; or &lt;code&gt;--batch-check&lt;/code&gt; be specified. Note that the objects are visited in order sorted by their hashes.</source>
          <target state="translated">stdin에서 오브젝트 목록을 읽는 대신, 저장소 및 모든 대체 오브젝트 저장소 (연결 가능한 오브젝트뿐만 아니라)의 모든 오브젝트에서 요청 된 일괄 처리 조작을 수행하십시오. 필요 &lt;code&gt;--batch&lt;/code&gt; 또는 &lt;code&gt;--batch-check&lt;/code&gt; 지정. 객체는 해시별로 정렬 된 순서대로 방문합니다.</target>
        </trans-unit>
        <trans-unit id="d4a14000f7e28706a0e6c2e4729bb02543a4d281" translate="yes" xml:space="preserve">
          <source>Instead of reading tree object(s) into the index, just empty it.</source>
          <target state="translated">인덱스로 트리 객체를 읽는 대신 비우십시오.</target>
        </trans-unit>
        <trans-unit id="5828d05fd5c0a35f4392daf67536f9a77ece2b90" translate="yes" xml:space="preserve">
          <source>Instead of running &lt;code&gt;git repack&lt;/code&gt; you can also run &lt;code&gt;git gc
--aggressive&lt;/code&gt;, which will also optimize other things after an import (e.g. pack loose refs). As noted in the &quot;AGGRESSIVE&quot; section in &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; the &lt;code&gt;--aggressive&lt;/code&gt; option will find new deltas with the &lt;code&gt;-f&lt;/code&gt; option to &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;. For the reasons elaborated on above using &lt;code&gt;--aggressive&lt;/code&gt; after a fast-import is one of the few cases where it&amp;rsquo;s known to be worthwhile.</source>
          <target state="translated">&lt;code&gt;git repack&lt;/code&gt; 을 실행하는 대신 &lt;code&gt;git gc --aggressive&lt;/code&gt; 실행 하여 가져 오기 후 다른 항목을 최적화 할 수도 있습니다 (예 : 팩 느슨한 참조). 의 &quot;공격성&quot;부분에서 언급 한 바와 같이 &lt;a href=&quot;git-gc&quot;&gt;자식-GC [1] &lt;/a&gt; &lt;code&gt;--aggressive&lt;/code&gt; 옵션은 새로운 델타 찾을 &lt;code&gt;-f&lt;/code&gt; 에 옵션 &lt;a href=&quot;git-repack&quot;&gt;자식 - 재 포장 [1]&lt;/a&gt; . 빠른 가져 오기 후 &lt;code&gt;--aggressive&lt;/code&gt; 를 사용하여 위에서 자세히 설명한 이유 는 가치있는 것으로 알려진 몇 안되는 경우 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="27d7e1d82cdbf4a022b1041bc3a4b5c02db03622" translate="yes" xml:space="preserve">
          <source>Instead of running one of the known diff tools, &lt;code&gt;git difftool&lt;/code&gt; can be customized to run an alternative program by specifying the command line to invoke in a configuration variable &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt;.</source>
          <target state="translated">알려진 diff 도구 중 하나 를 실행하는 대신 구성 변수 &lt;code&gt;difftool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 에서 호출 할 명령 행을 지정하여 대체 프로그램을 실행하도록 &lt;code&gt;git difftool&lt;/code&gt; 을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a6ec50c9a1e350ef9a3f4f762c317cd2d6e8233" translate="yes" xml:space="preserve">
          <source>Instead of running one of the known merge tool programs, &lt;code&gt;git mergetool&lt;/code&gt; can be customized to run an alternative program by specifying the command line to invoke in a configuration variable &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt;.</source>
          <target state="translated">알려진 병합 도구 프로그램 중 하나 를 실행하는 대신 구성 변수 &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.cmd&lt;/code&gt; 에서 호출 할 명령 행을 지정하여 대체 프로그램을 실행 &lt;code&gt;git mergetool&lt;/code&gt; 을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09dffc4d1650e5ccccc05b0bf19a3e3e59eb7116" translate="yes" xml:space="preserve">
          <source>Instead of searching tracked files in the working tree, search blobs in the given trees.</source>
          <target state="translated">작업 트리에서 추적 된 파일을 검색하는 대신 지정된 트리에서 얼룩을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="31ae83b44368ffd8feca3b205d3db8ea7d6a3c5c" translate="yes" xml:space="preserve">
          <source>Instead of searching tracked files in the working tree, search blobs registered in the index file.</source>
          <target state="translated">작업 트리에서 추적 된 파일을 검색하는 대신 색인 파일에 등록 된 Blob을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="55e6c9aa38dceb73a0632da59bc95f69bdfc3cb4" translate="yes" xml:space="preserve">
          <source>Instead of showing every matched line, show only the names of files that contain (or do not contain) matches. For better compatibility with &lt;code&gt;git diff&lt;/code&gt;, &lt;code&gt;--name-only&lt;/code&gt; is a synonym for &lt;code&gt;--files-with-matches&lt;/code&gt;.</source>
          <target state="translated">일치하는 모든 행을 표시하는 대신 일치하는 파일이 있거나 포함되지 않은 파일 이름 만 표시하십시오. 더 나은 호환성을 위해 &lt;code&gt;git diff&lt;/code&gt; , &lt;code&gt;--name-only&lt;/code&gt; 동의어입니다 &lt;code&gt;--files-with-matches&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1fdcf67f0afaa931922f6239ba4fdd53758ce0d" translate="yes" xml:space="preserve">
          <source>Instead of showing every matched line, show the number of lines that match.</source>
          <target state="translated">일치하는 모든 줄을 표시하는 대신 일치하는 줄 수를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="9ddb49ffe2885e9ce52c33a63e80e23af2a075a9" translate="yes" xml:space="preserve">
          <source>Instead of showing the commit list, determine possible merge bases for the specified commits. All merge bases will be contained in all specified commits. This is different from how &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base[1]&lt;/a&gt; handles the case of three or more commits.</source>
          <target state="translated">커밋 목록을 표시하는 대신 지정된 커밋에 대해 가능한 병합 기준을 결정하십시오. 모든 병합 기준은 지정된 모든 커밋에 포함됩니다. 이것은 &lt;a href=&quot;git-merge-base&quot;&gt;git-merge-base [1]&lt;/a&gt; 이 3 개 이상의 커밋을 처리하는 방법과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="6ba3d7561fe60e77ce239084badd1d1856e50d97" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal commit object name, show only a partial prefix. Non default number of digits can be specified with &quot;--abbrev=&amp;lt;n&amp;gt;&quot; (which also modifies diff output, if it is displayed).</source>
          <target state="translated">전체 40 바이트 16 진 확약 오브젝트 이름을 표시하는 대신 부분 접 두부 만 표시하십시오. 기본이 아닌 숫자는 &quot;--abbrev = &amp;lt;n&amp;gt;&quot;으로 지정할 수 있습니다 (표시되는 경우 diff 출력도 수정 함).</target>
        </trans-unit>
        <trans-unit id="7d6a3b8755cc865088fd97c8d79f6b68eb4292bc" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal object lines, show only a partial prefix. Non default number of digits can be specified with --abbrev=&amp;lt;n&amp;gt;.</source>
          <target state="translated">전체 40 바이트 16 진 오브젝트 행을 표시하는 대신 부분 접 두부 만 표시하십시오. 기본 숫자가 아닌 숫자는 --abbrev = &amp;lt;n&amp;gt;으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58ecb5df7fcdb6c0e019f4aa574b567ad3276395" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show only a partial prefix. In diff-patch output format, &lt;code&gt;--full-index&lt;/code&gt; takes higher precedence, i.e. if &lt;code&gt;--full-index&lt;/code&gt; is specified, full blob names will be shown regardless of &lt;code&gt;--abbrev&lt;/code&gt;. Non default number of digits can be specified with &lt;code&gt;--abbrev=&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">diff-raw 형식 출력 및 diff-tree 헤더 행에 전체 40 바이트 16 진수 개체 이름을 표시하는 대신 부분 접두사 만 표시합니다. diff-patch 출력 형식에서 &lt;code&gt;--full-index&lt;/code&gt; 가 더 높은 우선 순위를 갖습니다. 즉, &lt;code&gt;--full-index&lt;/code&gt; 가 지정된 경우 &lt;code&gt;--abbrev&lt;/code&gt; 에 관계없이 전체 blob 이름이 표시됩니다 . &lt;code&gt;--abbrev=&amp;lt;n&amp;gt;&lt;/code&gt; 을 사용 하여 기본이 아닌 자릿수를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dcd3315e868be633e341c6b1fc6b217d4459f224" translate="yes" xml:space="preserve">
          <source>Instead of showing the full 40-byte hexadecimal object name in diff-raw format output and diff-tree header lines, show only a partial prefix. This is independent of the &lt;code&gt;--full-index&lt;/code&gt; option above, which controls the diff-patch output format. Non default number of digits can be specified with &lt;code&gt;--abbrev=&amp;lt;n&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">diff-raw 형식 출력 및 diff-tree 헤더 행에 전체 40 바이트 16 진 오브젝트 이름을 표시하는 대신 부분 접 두부 만 표시하십시오. 이것은 diff-patch 출력 형식을 제어하는 ​​위 의 &lt;code&gt;--full-index&lt;/code&gt; 옵션 과 독립적입니다 . 기본 숫자가 아닌 숫자는 &lt;code&gt;--abbrev=&amp;lt;n&amp;gt;&lt;/code&gt; 으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ac504d3062e8b5bad74846fd627b7807bedc4f2" translate="yes" xml:space="preserve">
          <source>Instead of showing the path names relative to the current working directory, show the full path names.</source>
          <target state="translated">현재 작업 디렉토리에 상대적인 경로 이름을 표시하는 대신 전체 경로 이름을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="5f0ed09aafafab46ef0c48e35d2b30851c21ae6a" translate="yes" xml:space="preserve">
          <source>Instead of staging files after each individual change, you can tell &lt;code&gt;git commit&lt;/code&gt; to notice the changes to the files whose contents are tracked in your working tree and do corresponding &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git rm&lt;/code&gt; for you. That is, this example does the same as the earlier example if there is no other change in your working tree:</source>
          <target state="translated">각 개별 변경 후 파일을 준비하는 대신 &lt;code&gt;git commit&lt;/code&gt; 에게 작업 트리에서 내용이 추적되는 파일의 변경 사항을 확인하고 해당 &lt;code&gt;git add&lt;/code&gt; 및 &lt;code&gt;git rm&lt;/code&gt; 을 수행 하도록 지시 할 수 있습니다. 즉,이 예제는 작업 트리에 다른 변경 사항이없는 경우 이전 예제와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a675a0b8f5c03b948f0d18f87a17852f45d21abd" translate="yes" xml:space="preserve">
          <source>Instead of stopping at the first failed merge, do all of them in one shot - continue with merging even when previous merges returned errors, and only return the error code after all the merges.</source>
          <target state="translated">첫 번째 실패한 병합에서 중지하는 대신 한 번에 모든 병합을 수행하십시오. 이전 병합에서 리턴 된 오류가 있어도 병합을 계속하고 모든 병합 후에 만 ​​오류 코드를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="de32bccd3ddde71a98cffd2de1232e1c99dfd513" translate="yes" xml:space="preserve">
          <source>Instead of submitting create a series of shelved changelists. After creating each shelve, the relevant files are reverted/deleted. If you have multiple commits pending multiple shelves will be created.</source>
          <target state="translated">제출하는 대신 일련의 보류 된 변경 목록을 작성하십시오. 각 선반을 생성 한 후 관련 파일이 복귀 / 삭제됩니다. 보류중인 커밋이 여러 개인 경우 여러 선반이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="140c71a8b471c44c130e5b1eee8b0237e8238e05" translate="yes" xml:space="preserve">
          <source>Instead of taking list of paths from the command line, read list of paths from the standard input. Paths are separated by LF (i.e. one path per line) by default.</source>
          <target state="translated">명령 행에서 경로 목록을 가져 오는 대신 표준 입력에서 경로 목록을 읽으십시오. 경로는 기본적으로 LF (예 : 한 줄에 하나의 경로)로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="f4ba2e4e1080efba3c28ca42286f9295fb7a6889" translate="yes" xml:space="preserve">
          <source>Instead of the commit subject, use some other information to describe each commit. &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; can be any string accepted by the &lt;code&gt;--format&lt;/code&gt; option of &lt;code&gt;git log&lt;/code&gt;, such as &lt;code&gt;* [%h] %s&lt;/code&gt;. (See the &quot;PRETTY FORMATS&quot; section of &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.)</source>
          <target state="translated">커밋 제목 대신 다른 정보를 사용하여 각 커밋을 설명하십시오. &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 은 &lt;code&gt;git log&lt;/code&gt; 의 &lt;code&gt;--format&lt;/code&gt; 옵션에 허용되는 모든 문자열 일 수 있습니다 ( 예 : &lt;code&gt;* [%h] %s&lt;/code&gt; . ( &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 의 &quot;PRETTY FORMATS&quot;섹션을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="a4e872330a2ee34ffbac6bb806a9bf43b1d76b3c" translate="yes" xml:space="preserve">
          <source>Instead of the content, show the object size identified by &amp;lt;object&amp;gt;.</source>
          <target state="translated">내용 대신 &amp;lt;object&amp;gt;로 식별 된 개체 크기를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="f066e23ab4bd2d63e94325b4a2a048945fb424e1" translate="yes" xml:space="preserve">
          <source>Instead of the content, show the object type identified by &amp;lt;object&amp;gt;.</source>
          <target state="translated">내용 대신 &amp;lt;object&amp;gt;로 식별 된 개체 유형을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="01b660ce7f25b8747605b72657d7e3925704df33" translate="yes" xml:space="preserve">
          <source>Instead of the default &quot;symref&quot; format for HEAD and other symbolic reference files, use symbolic links. This is sometimes needed to work with old scripts that expect HEAD to be a symbolic link.</source>
          <target state="translated">HEAD 및 기타 기호 참조 파일의 기본 &quot;symref&quot;형식 대신 기호 링크를 사용하십시오. HEAD가 심볼릭 링크가 될 것으로 예상되는 오래된 스크립트와 함께 작동하려면 때때로 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f146d5682a8b5a97d10d05b37274aa1ba3a49c07" translate="yes" xml:space="preserve">
          <source>Instead of the default 4 digits with leading zeros, different precision can be specified for the generated filenames.</source>
          <target state="translated">앞에 0이있는 기본 4 자리 대신 생성 된 파일 이름에 대해 다른 정밀도를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1d28ba0f9256454e559ca46e186461c224089ef" translate="yes" xml:space="preserve">
          <source>Instead of the first handful of characters, show the full pre- and post-image blob object names on the &quot;index&quot; line when generating patch format output.</source>
          <target state="translated">패치 형식 출력을 생성 할 때 첫 소수 문자 대신 &quot;인덱스&quot;줄에 전체 사전 및 사후 이미지 Blob 개체 이름을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="e3b6588aa8ce45f7528fa4adfa5f41dc47858a56" translate="yes" xml:space="preserve">
          <source>Instead of the normal operation, dump the shorthand alias names from the configured alias file(s), one per line in alphabetical order. Note, this only includes the alias name and not its expanded email addresses. See &lt;code&gt;sendemail.aliasesfile&lt;/code&gt; for more information about aliases.</source>
          <target state="translated">정상적인 조작 대신, 구성된 별명 파일에서 축약 별명 이름을 사전 순으로 한 줄에 하나씩 덤프하십시오. 여기에는 확장 된 전자 메일 주소가 아닌 별칭 이름 만 포함됩니다. 별명에 대한 자세한 정보는 &lt;code&gt;sendemail.aliasesfile&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="77a59d82290cfd961dc9ff35f15683facfa89709" translate="yes" xml:space="preserve">
          <source>Instead of the standard &lt;code&gt;[PATCH]&lt;/code&gt; prefix in the subject line, instead use &lt;code&gt;[&amp;lt;subject prefix&amp;gt;]&lt;/code&gt;. This allows for useful naming of a patch series, and can be combined with the &lt;code&gt;--numbered&lt;/code&gt; option.</source>
          <target state="translated">제목 줄에 표준 &lt;code&gt;[PATCH]&lt;/code&gt; 접두사 대신 &lt;code&gt;[&amp;lt;subject prefix&amp;gt;]&lt;/code&gt; 를 사용하십시오 . 이를 통해 패치 시리즈의 이름을 유용하게 지정할 수 있으며 &lt;code&gt;--numbered&lt;/code&gt; 옵션 과 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="440b20677cca3bad5d5589368544d09ff6997de8" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;, you can also choose just to update one branch at a time, and to store it locally under an arbitrary name:</source>
          <target state="translated">&lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; 을 사용하는 대신 한 번에 하나의 브랜치를 업데이트하고 임의의 이름으로 로컬로 저장하도록 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c80da0469d96c6db5cfae1c5b4b2cc65c570bdb0" translate="yes" xml:space="preserve">
          <source>Instead of using &lt;code&gt;.patch&lt;/code&gt; as the suffix for generated filenames, use specified suffix. A common alternative is &lt;code&gt;--suffix=.txt&lt;/code&gt;. Leaving this empty will remove the &lt;code&gt;.patch&lt;/code&gt; suffix.</source>
          <target state="translated">생성 된 파일 이름의 접미사로 &lt;code&gt;.patch&lt;/code&gt; 를 사용하는 대신 지정된 접미사를 사용하십시오. 일반적인 대안은 &lt;code&gt;--suffix=.txt&lt;/code&gt; 입니다. 이 항목을 비워두면 &lt;code&gt;.patch&lt;/code&gt; 접미사 가 제거 됩니다.</target>
        </trans-unit>
        <trans-unit id="f82d2e94f21038afaa9f1d66d3a9a0e365538f7c" translate="yes" xml:space="preserve">
          <source>Instead of using only the annotated tags, use any ref found in &lt;code&gt;refs/&lt;/code&gt; namespace. This option enables matching any known branch, remote-tracking branch, or lightweight tag.</source>
          <target state="translated">주석이 달린 태그 만 사용하는 대신 &lt;code&gt;refs/&lt;/code&gt; 네임 스페이스 에있는 ref를 사용하십시오 . 이 옵션을 사용하면 알려진 지점, 원격 추적 지점 또는 경량 태그를 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1177311a3949b6b80d45daef7bf2616b79441b65" translate="yes" xml:space="preserve">
          <source>Instead of using only the annotated tags, use any tag found in &lt;code&gt;refs/tags&lt;/code&gt; namespace. This option enables matching a lightweight (non-annotated) tag.</source>
          <target state="translated">주석이 달린 태그 만 사용하는 대신 &lt;code&gt;refs/tags&lt;/code&gt; 네임 스페이스 에있는 태그를 사용하십시오 . 이 옵션을 사용하면 주석이 달린 경량 태그를 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="525df652b887a2877266435635ef66426239fc1d" translate="yes" xml:space="preserve">
          <source>Instead of using the author date of the original commit, use the current time as the author date of the rebased commit. This option implies &lt;code&gt;--force-rebase&lt;/code&gt;.</source>
          <target state="translated">원래 커밋의 작성자 날짜를 사용하는 대신 현재 시간을 리베이스 커밋의 작성자 날짜로 사용합니다. 이 옵션은 &lt;code&gt;--force-rebase&lt;/code&gt; 를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="4860002e825b16be9527700d7d5e647a6362a7ef" translate="yes" xml:space="preserve">
          <source>Instead of using the current time as the committer date, use the author date of the commit being rebased as the committer date. This option implies &lt;code&gt;--force-rebase&lt;/code&gt;.</source>
          <target state="translated">현재 시간을 커미터 날짜로 사용하는 대신 커미터 날짜로 리베이스되는 커밋의 작성자 날짜를 사용합니다. 이 옵션은 &lt;code&gt;--force-rebase&lt;/code&gt; 를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="fa50874379be0d623d79d8af182cc42f83a49b1c" translate="yes" xml:space="preserve">
          <source>Instead of using the default 7 hexadecimal digits as the abbreviated object name, use &amp;lt;n&amp;gt; digits, or as many digits as needed to form a unique object name. An &amp;lt;n&amp;gt; of 0 will suppress long format, only showing the closest tag.</source>
          <target state="translated">기본 7 자리 16 진수를 축약 된 오브젝트 이름으로 사용하는 대신 &amp;lt;n&amp;gt; 숫자 또는 고유 오브젝트 이름을 형성하는 데 필요한만큼의 숫자를 사용하십시오. &amp;lt;n&amp;gt;이 0이면 긴 형식이 억제되고 가장 가까운 태그 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="183487409af3884cbc9c819c550a69752622875c" translate="yes" xml:space="preserve">
          <source>Instead of using the default 7+1 hexadecimal digits as the abbreviated object name, use &amp;lt;n&amp;gt;+1 digits. Note that 1 column is used for a caret to mark the boundary commit.</source>
          <target state="translated">축약 된 오브젝트 이름으로 기본 7 + 1 16 진 숫자를 사용하는 대신 &amp;lt;n&amp;gt; +1 숫자를 사용하십시오. 캐럿이 경계 커밋을 표시하는 데 1 개의 열이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ee5547b5d72f6d52e84d0986cad360b6f68e956a" translate="yes" xml:space="preserve">
          <source>Instead of using the remote name &lt;code&gt;origin&lt;/code&gt; to keep track of the upstream repository, use &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">업스트림 저장소를 추적하기 위해 원격 이름 &lt;code&gt;origin&lt;/code&gt; 을 사용하는 대신 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="acaf18a5ec5cac3fd2f3b3d56ba27133d9e16abf" translate="yes" xml:space="preserve">
          <source>Instead of using the tip of the current branch, compare with the tip of &quot;test&quot; branch.</source>
          <target state="translated">현재 분기의 팁을 사용하는 대신 &quot;테스트&quot;분기의 팁과 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="0e0bb2a4d944b8f5531055e279607820e676a94b" translate="yes" xml:space="preserve">
          <source>Instead of walking the commit ancestry chain, walk reflog entries from the most recent one to older ones. When this option is used you cannot specify commits to exclude (that is, &lt;code&gt;^commit&lt;/code&gt;, &lt;code&gt;commit1..commit2&lt;/code&gt;, and &lt;code&gt;commit1...commit2&lt;/code&gt; notations cannot be used).</source>
          <target state="translated">커밋 조상 체인을 걷는 대신, 가장 최근의 것부터 오래된 것까지 reflog 항목을 걷습니다. 이 옵션을 사용하면 제외 할 커밋을 지정할 수 없습니다 (즉, &lt;code&gt;^commit&lt;/code&gt; , &lt;code&gt;commit1..commit2&lt;/code&gt; 및 &lt;code&gt;commit1...commit2&lt;/code&gt; 표기법을 사용할 수 없음).</target>
        </trans-unit>
        <trans-unit id="00c411b0a21221afdc6e21c624bf253d7212e3a9" translate="yes" xml:space="preserve">
          <source>Instead of writing the results out to &lt;code&gt;$GIT_INDEX_FILE&lt;/code&gt;, write the resulting index in the named file. While the command is operating, the original index file is locked with the same mechanism as usual. The file must allow to be rename(2)ed into from a temporary file that is created next to the usual index file; typically this means it needs to be on the same filesystem as the index file itself, and you need write permission to the directories the index file and index output file are located in.</source>
          <target state="translated">결과를 &lt;code&gt;$GIT_INDEX_FILE&lt;/code&gt; 에 기록하는 대신 결과 색인을 명명 된 파일에 기록하십시오. 명령이 작동하는 동안 원래 색인 파일은 평소와 동일한 메커니즘으로 잠 깁니다. 파일은 일반적인 색인 파일 옆에 작성된 임시 파일에서 이름을 바꿀 수 있어야합니다 (2). 일반적으로 이는 색인 파일 자체와 동일한 파일 시스템에 있어야하며 색인 파일 및 색인 출력 파일이있는 디렉토리에 대한 쓰기 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ef06396aed739ff032fb1ddeda938ad4cf5e4280" translate="yes" xml:space="preserve">
          <source>Instruct Git to avoid trying to guess defaults for &lt;code&gt;user.email&lt;/code&gt; and &lt;code&gt;user.name&lt;/code&gt;, and instead retrieve the values only from the configuration. For example, if you have multiple email addresses and would like to use a different one for each repository, then with this configuration option set to &lt;code&gt;true&lt;/code&gt; in the global config along with a name, Git will prompt you to set up an email before making new commits in a newly cloned repository. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Git에게 &lt;code&gt;user.email&lt;/code&gt; 및 &lt;code&gt;user.name&lt;/code&gt; 의 기본값을 추측 하지 말고 대신 구성에서만 값을 검색 하지 않도록 지시 하십시오. 예를 들어, 이메일 주소가 여러 개이고 각 저장소에 대해 다른 주소를 사용하려는 경우 전역 구성에서 이름 과 함께이 구성 옵션을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 Git에서 새로 만들기 전에 이메일을 설정하라는 메시지를 표시합니다 새로 복제 된 저장소에서 커밋합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a592acd9f11ad3bff77a1878bfa756913e7df3fe" translate="yes" xml:space="preserve">
          <source>Instruction to add new data</source>
          <target state="translated">새로운 데이터를 추가하는 방법</target>
        </trans-unit>
        <trans-unit id="c222c271406b6a5c2fcfc84ba72b7981aee6b09e" translate="yes" xml:space="preserve">
          <source>Instruction to copy from base object</source>
          <target state="translated">기본 개체에서 복사하는 방법</target>
        </trans-unit>
        <trans-unit id="6131d2bc98a67fbf2df419d53c2a5951a56eb747" translate="yes" xml:space="preserve">
          <source>Instructs the remote helper that any subsequent input is part of a fast-import stream (generated by &lt;code&gt;git fast-export&lt;/code&gt;) containing objects which should be pushed to the remote.</source>
          <target state="translated">후속 입력이 원격으로 푸시되어야하는 오브젝트를 포함하는 &lt;code&gt;git fast-export&lt;/code&gt; 가져 오기 스트림 ( git fast-export에 의해 생성됨)의 일부임을 원격 헬퍼에게 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="563eacc97631ea8eeadfe6b54ffbd63455326490" translate="yes" xml:space="preserve">
          <source>Integer. Specifies desired depth of nested regions in the event output. Regions deeper than this value will be omitted. May be overridden by the &lt;code&gt;GIT_TRACE2_EVENT_NESTING&lt;/code&gt; environment variable. Defaults to 2.</source>
          <target state="translated">정수. 이벤트 출력에서 ​​원하는 중첩 영역 깊이를 지정합니다. 이 값보다 깊은 영역은 생략됩니다. &lt;code&gt;GIT_TRACE2_EVENT_NESTING&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . 기본값은 2입니다.</target>
        </trans-unit>
        <trans-unit id="f3e0144605c9578fc597fd7ff39de75aab2afefe" translate="yes" xml:space="preserve">
          <source>Integer. When writing trace files to a target directory, do not write additional traces if we would exceed this many files. Instead, write a sentinel file that will block further tracing to this directory. Defaults to 0, which disables this check.</source>
          <target state="translated">정수. 대상 파일에 추적 파일을 쓸 때이 파일을 초과 할 경우 추가 추적을 쓰지 마십시오. 대신이 디렉토리에 대한 추가 추적을 차단할 센티넬 파일을 작성하십시오. 기본값은 0이며,이 검사는 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="a6768cae9c51930f13c302375f3385c6c77b2104" translate="yes" xml:space="preserve">
          <source>Integrator</source>
          <target state="translated">Integrator</target>
        </trans-unit>
        <trans-unit id="e30f6e398ba3d7dd3d6ee2f7d0d8940d3116f2a5" translate="yes" xml:space="preserve">
          <source>Interacting with Others</source>
          <target state="translated">다른 사람들과 교류</target>
        </trans-unit>
        <trans-unit id="e9854d76872b55831675241f09e80f37f1939cea" translate="yes" xml:space="preserve">
          <source>Interaction between checkin/checkout attributes</source>
          <target state="translated">체크인 / 체크 아웃 속성 간의 상호 작용</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">대화식 모드</target>
        </trans-unit>
        <trans-unit id="fb0ea93fbb85b738df0bd31fcf1bc9eb5468d22b" translate="yes" xml:space="preserve">
          <source>Interactive use</source>
          <target state="translated">대화식 사용</target>
        </trans-unit>
        <trans-unit id="94db97a8381d05a800daa18ce0818d37326de61f" translate="yes" xml:space="preserve">
          <source>Interactively choose hunks of patch between the index and the work tree and add them to the index. This gives the user a chance to review the difference before adding modified contents to the index.</source>
          <target state="translated">색인과 작업 트리 사이에서 대화식으로 패치 덩어리를 선택하여 색인에 추가하십시오. 이를 통해 사용자는 수정 된 내용을 색인에 추가하기 전에 차이점을 검토 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfdd4f344b8dfb9b5f469d3e0a6945b89367454c" translate="yes" xml:space="preserve">
          <source>Interactively select hunks from the diff between HEAD and the working tree to be stashed. The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively. The selected changes are then rolled back from your worktree. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">HEAD와 작업 트리 사이의 차이에서 숨겨 질 덩어리를 대화식으로 선택합니다. 숨김 항목은 색인 상태가 저장소의 색인 상태와 동일하도록 구성되며 해당 작업 트리에는 대화식으로 선택한 변경 사항 만 포함됩니다. 그러면 선택한 변경 사항이 작업 트리에서 롤백됩니다. &lt;code&gt;--patch&lt;/code&gt; 모드 를 작동하는 방법을 알아 보려면 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 의 &quot;대화 형 모드&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="942e3b50f8575a931a7b62b4970978b40b59bcee" translate="yes" xml:space="preserve">
          <source>Interactively select hunks in the difference between the &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (or the index, if unspecified) and the working tree. The chosen hunks are then applied in reverse to the working tree (and if a &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; was specified, the index).</source>
          <target state="translated">&lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (또는 지정되지 않은 경우 인덱스)와 작업 트리 의 차이에서 대화식으로 덩어리를 선택 합니다. 선택한 덩어리는 작업 트리와 반대로 적용됩니다 ( &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 가 지정된 경우 인덱스).</target>
        </trans-unit>
        <trans-unit id="6b61a0bfaba36c21326a6cc1d8076250bbb8f781" translate="yes" xml:space="preserve">
          <source>Interactively select hunks in the difference between the index and &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; (defaults to &lt;code&gt;HEAD&lt;/code&gt;). The chosen hunks are applied in reverse to the index.</source>
          <target state="translated">인덱스와 &lt;code&gt;&amp;lt;tree-ish&amp;gt;&lt;/code&gt; 의 차이에서 대화식으로 덩어리를 선택합니다 (기본값은 &lt;code&gt;HEAD&lt;/code&gt; ). 선택한 덩어리는 색인과 반대로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="11c4e8d4b31fcec1faa8b21ab916ae6d7ecd6196" translate="yes" xml:space="preserve">
          <source>Interactively select hunks in the difference between the restore source and the restore location. See the &amp;ldquo;Interactive Mode&amp;rdquo; section of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; to learn how to operate the &lt;code&gt;--patch&lt;/code&gt; mode.</source>
          <target state="translated">복원 소스와 복원 위치의 차이에서 대화식으로 덩어리를 선택하십시오. &lt;code&gt;--patch&lt;/code&gt; 모드 작동 방법을 알아 보려면 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 의 &quot;대화식 모드&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37d460e42c18dd6a2f67dd6cfcf736b2dc4e3735" translate="yes" xml:space="preserve">
          <source>Internal detail of implementation. What is important is that if this field is not present then per-repository override for given feature is not supported.</source>
          <target state="translated">구현의 내부 세부 사항. 중요한 것은이 필드가 존재하지 않으면 주어진 기능에 대한 저장소 별 재정의가 지원되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fcd742802f00593c0aa9a5d67d6ee0045ea54dd6" translate="yes" xml:space="preserve">
          <source>Internal helper commands</source>
          <target state="translated">내부 도우미 명령</target>
        </trans-unit>
        <trans-unit id="99089329f972015329c6ab2c5f20f49ab1b0fb2e" translate="yes" xml:space="preserve">
          <source>Internal variable identifying the repository format and layout version.</source>
          <target state="translated">저장소 형식 및 레이아웃 버전을 식별하는 내부 변수입니다.</target>
        </trans-unit>
        <trans-unit id="d2a9fe262eee692f1042088fcd5412df8b02ed0e" translate="yes" xml:space="preserve">
          <source>Internal variable which enables various workarounds to enable Git to work better on filesystems that are not case sensitive, like APFS, HFS+, FAT, NTFS, etc. For example, if a directory listing finds &quot;makefile&quot; when Git expects &quot;Makefile&quot;, Git will assume it is really the same file, and continue to remember it as &quot;Makefile&quot;.</source>
          <target state="translated">APFS, HFS +, FAT, NTFS 등과 같이 대소 문자를 구분하지 않는 파일 시스템에서 Git이 더 잘 작동 할 수 있도록하는 다양한 해결 방법을 제공하는 내부 변수입니다. 파일이 실제로 같은 파일이라고 가정하고 &quot;Makefile&quot;로 계속 기억합니다.</target>
        </trans-unit>
        <trans-unit id="fd5dd045ecadbef7edb9976d5bf76d5e7548b5a7" translate="yes" xml:space="preserve">
          <source>Interpret &amp;lt;refname&amp;gt; as a reference name pattern for a refspec (as used with remote repositories). If this option is enabled, &amp;lt;refname&amp;gt; is allowed to contain a single &lt;code&gt;*&lt;/code&gt; in the refspec (e.g., &lt;code&gt;foo/bar*/baz&lt;/code&gt; or &lt;code&gt;foo/bar*baz/&lt;/code&gt; but not &lt;code&gt;foo/bar*/baz*&lt;/code&gt;).</source>
          <target state="translated">&amp;lt;refname&amp;gt;을 참조 스펙에 대한 참조 이름 패턴으로 해석하십시오 (원격 저장소와 함께 사용됨). 이 옵션을 활성화하면 &amp;lt;refname&amp;gt;은 참조 스펙에 단일 &lt;code&gt;*&lt;/code&gt; 를 포함 할 수 있습니다 (예 : &lt;code&gt;foo/bar*/baz&lt;/code&gt; 또는 &lt;code&gt;foo/bar*baz/&lt;/code&gt; 이지만 &lt;code&gt;foo/bar*/baz*&lt;/code&gt; 아님).</target>
        </trans-unit>
        <trans-unit id="670ef7722a61e3342fef6602c3dc04b50457ccb3" translate="yes" xml:space="preserve">
          <source>Interpret all preceding arguments as attributes and all following arguments as path names.</source>
          <target state="translated">앞의 모든 인수를 속성으로 해석하고 다음의 모든 인수를 경로 이름으로 해석하십시오.</target>
        </trans-unit>
        <trans-unit id="c75cadb4ae816991e0dd6b40f2cda63b6ea63eb7" translate="yes" xml:space="preserve">
          <source>Interrogation commands</source>
          <target state="translated">심문 명령</target>
        </trans-unit>
        <trans-unit id="f1e6fa1e2ddb5fcd808e3092148f74242800360f" translate="yes" xml:space="preserve">
          <source>Interrogators:</source>
          <target state="translated">Interrogators:</target>
        </trans-unit>
        <trans-unit id="8b0b6bf2544da29702a138cd7dd487472490ccff" translate="yes" xml:space="preserve">
          <source>Interrupt transfer after &amp;lt;n&amp;gt; seconds of inactivity.</source>
          <target state="translated">&amp;lt;n&amp;gt; 초 동안 활동이 없으면 인터럽트 전송.</target>
        </trans-unit>
        <trans-unit id="fb3e70f97505597e5558a144342f8608c6471e9a" translate="yes" xml:space="preserve">
          <source>Interruptability</source>
          <target state="translated">Interruptability</target>
        </trans-unit>
        <trans-unit id="9f1df172d790d81927bf10eb32b7a53862fd94a5" translate="yes" xml:space="preserve">
          <source>Interrupted workflow</source>
          <target state="translated">중단 된 워크 플로우</target>
        </trans-unit>
        <trans-unit id="b566252f7afe805214a7771e6b2a586b4e458c82" translate="yes" xml:space="preserve">
          <source>Introduction to &quot;git bisect&quot;</source>
          <target state="translated">&quot;git bisect&quot;소개</target>
        </trans-unit>
        <trans-unit id="273a20c96a580af6e0e1fc6c4491680cd6e13de6" translate="yes" xml:space="preserve">
          <source>Intuitiveness is not the goal here. Repeatability is. The reason for the &quot;no arguments means no work&quot; behavior is that from scripts you are supposed to be able to do:</source>
          <target state="translated">직관적 인 목표는 여기에 없습니다. 반복성은 &quot;인수 없음&quot;은 작동하지 않는 동작의 이유는 스크립트에서 수행 할 수 있어야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6a9b44369c96eafd66d755034e5ce80488ad8832" translate="yes" xml:space="preserve">
          <source>Invocation</source>
          <target state="translated">Invocation</target>
        </trans-unit>
        <trans-unit id="1d5f124f7b2f261867ec41e2c056658bb6e88c34" translate="yes" xml:space="preserve">
          <source>Invoke a text editor (see GIT_EDITOR in &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt;) to edit an introductory message for the patch series.</source>
          <target state="translated">텍스트 편집기 ( &lt;a href=&quot;git-var&quot;&gt;git-var [1]의&lt;/a&gt; GIT_EDITOR 참조)를 호출 하여 패치 시리즈에 대한 소개 메시지를 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="9ba2ef7b89376be98d487b046c212677da3221b4" translate="yes" xml:space="preserve">
          <source>Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The &lt;code&gt;--no-edit&lt;/code&gt; option can be used to accept the auto-generated message (this is generally discouraged).</source>
          <target state="translated">성공적인 자동 병합을 커미트하기 전에 편집기를 호출하여 자동 생성 된 병합 메시지를 추가로 편집하여 사용자가 병합을 설명하고 정당화 할 수 있습니다. &lt;code&gt;--no-edit&lt;/code&gt; 옵션 (이것은 일반적으로 권장하지 않습니다) 자동 생성 된 메시지를 수락 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a978683542367bbc42f0a41dd9d11a4a00c553d9" translate="yes" xml:space="preserve">
          <source>Invoke an editor before committing successful mechanical merge to further edit the auto-generated merge message, so that the user can explain and justify the merge. The &lt;code&gt;--no-edit&lt;/code&gt; option can be used to accept the auto-generated message (this is generally discouraged). The &lt;code&gt;--edit&lt;/code&gt; (or &lt;code&gt;-e&lt;/code&gt;) option is still useful if you are giving a draft message with the &lt;code&gt;-m&lt;/code&gt; option from the command line and want to edit it in the editor.</source>
          <target state="translated">성공적인 자동 병합을 커미트하기 전에 편집기를 호출하여 자동 생성 된 병합 메시지를 추가로 편집하여 사용자가 병합을 설명하고 정당화 할 수 있습니다. &lt;code&gt;--no-edit&lt;/code&gt; 옵션 (이것은 일반적으로 권장하지 않습니다) 자동 생성 된 메시지를 수락 할 수 있습니다. &lt;code&gt;--edit&lt;/code&gt; (또는 &lt;code&gt;-e&lt;/code&gt; 당신이 가진 초안 메시지를주는 경우) 옵션은 여전히 유용 &lt;code&gt;-m&lt;/code&gt; 명령 행에서 옵션을하고 편집기에서 편집을하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="ab51558f752b86c08b9c277e1cd35bd4f5da28bc" translate="yes" xml:space="preserve">
          <source>Invoke the sendemail-validate hook if present (see &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;).</source>
          <target state="translated">있는 경우 sendemail-validate 후크를 호출하십시오 ( &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6307458f7efb25e5d4237ad7a4e972e464f2ab54" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git archive --remote&lt;/code&gt; and sends a generated archive to the other end over the Git protocol.</source>
          <target state="translated">&lt;code&gt;git archive --remote&lt;/code&gt; 에 의해 호출되며 생성 된 아카이브를 Git 프로토콜을 통해 다른 쪽 끝으로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="4591feb10dd06f62e310d9c287cf3f981ce9babf" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git fetch-pack&lt;/code&gt;, learns what objects the other side is missing, and sends them after packing.</source>
          <target state="translated">&lt;code&gt;git fetch-pack&lt;/code&gt; 에 의해 호출되어 다른 쪽에서 누락 된 객체를 파악하고 패킹 후 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a7f91dd525c007f2b681e8a032a0618f9a34ea1c" translate="yes" xml:space="preserve">
          <source>Invoked by &lt;code&gt;git send-pack&lt;/code&gt; and updates the repository with the information fed from the remote end.</source>
          <target state="translated">&lt;code&gt;git send-pack&lt;/code&gt; 에 의해 호출되며 원격 엔드에서 제공된 정보로 저장소를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="d65563f7b9f547034dceec39b8ac04f9c683c150" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;git-receive-pack&lt;/code&gt; on a possibly remote repository, and updates it from the current repository, sending named refs.</source>
          <target state="translated">원격 저장소에서 &lt;code&gt;git-receive-pack&lt;/code&gt; 을 호출 하고 이름이 지정된 ref를 전송하여 현재 저장소에서 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="b53ca0a7337f2511de77389036559a87c502bc3d" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;git-upload-pack&lt;/code&gt; on a possibly remote repository and asks it to send objects missing from this repository, to update the named heads. The list of commits available locally is found out by scanning the local refs/ hierarchy and sent to &lt;code&gt;git-upload-pack&lt;/code&gt; running on the other end.</source>
          <target state="translated">원격 저장소에서 &lt;code&gt;git-upload-pack&lt;/code&gt; 을 호출 하고이 저장소에서 누락 된 객체를 보내 이름 지정된 헤드를 업데이트하도록 요청합니다. 로컬에서 사용 가능한 커밋 목록은 로컬 refs / 계층 구조를 스캔하여 찾아서 다른 쪽 끝에서 실행되는 &lt;code&gt;git-upload-pack&lt;/code&gt; 으로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="a31ffeaabebc608f725ad5aea0019f330d8c2ea7" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;git add -e&lt;/code&gt; or selecting &lt;code&gt;e&lt;/code&gt; from the interactive hunk selector will open a patch in your editor; after the editor exits, the result is applied to the index. You are free to make arbitrary changes to the patch, but note that some changes may have confusing results, or even result in a patch that cannot be applied. If you want to abort the operation entirely (i.e., stage nothing new in the index), simply delete all lines of the patch. The list below describes some common things you may see in a patch, and which editing operations make sense on them.</source>
          <target state="translated">&lt;code&gt;git add -e&lt;/code&gt; 를 호출 하거나 대화식 덩어리 선택기에서 &lt;code&gt;e&lt;/code&gt; 를 선택하면 편집기에서 패치가 열립니다. 편집기가 종료되면 결과가 색인에 적용됩니다. 패치를 임의로 변경할 수는 있지만 일부 변경 사항으로 인해 혼동되는 결과가 발생하거나 적용 할 수없는 패치가 발생할 수 있습니다. 작업을 완전히 중단하려면 (즉, 색인에서 새로운 것을 스테이징하지 않으려면) 패치의 모든 줄을 삭제하십시오. 아래 목록은 패치에서 볼 수있는 몇 가지 일반적인 사항과 그에 적합한 편집 작업에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7eda501750cd6c5e49ea1b4fd74542b592feab87" translate="yes" xml:space="preserve">
          <source>Involving QA people and if possible end users</source>
          <target state="translated">품질 보증 담당자 및 가능한 경우 최종 사용자</target>
        </trans-unit>
        <trans-unit id="4ddb9cd693a2e162ef85f6fbfe4abc845111ebb9" translate="yes" xml:space="preserve">
          <source>Is a synonym for &lt;code&gt;zebra&lt;/code&gt;. This may change to a more sensible mode in the future.</source>
          <target state="translated">&lt;code&gt;zebra&lt;/code&gt; 의 동의어입니다 . 앞으로 더 합리적인 모드로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f13daaae3d7fc7ba5d15c4ccfc54188d83d267e" translate="yes" xml:space="preserve">
          <source>Is used as suggested name when creating new branches using the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]을&lt;/a&gt; 사용하여 새 분기를 만들 때 제안 된 이름으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6f3229278b909458bc76fcc500cf44677191a296" translate="yes" xml:space="preserve">
          <source>Islands are configured via the &lt;code&gt;pack.island&lt;/code&gt; option, which can be specified multiple times. Each value is a left-anchored regular expressions matching refnames. For example:</source>
          <target state="translated">아일랜드는 &lt;code&gt;pack.island&lt;/code&gt; 옵션을 통해 구성되며 여러 번 지정할 수 있습니다. 각 값은 참조 이름과 일치하는 왼쪽 고정식입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30ce4cb25faae86427d8ac22e8f50a0a74f3f393" translate="yes" xml:space="preserve">
          <source>Issues</source>
          <target state="translated">Issues</target>
        </trans-unit>
        <trans-unit id="0120e142d77ed0c1102a3548e5e6ca12ae1c469b" translate="yes" xml:space="preserve">
          <source>Issues which are security relevant should be disclosed privately to the Git Security mailing list &amp;lt;&lt;a href=&quot;mailto:git-security@googlegroups.com&quot;&gt;git-security@googlegroups.com&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">보안 관련 문제는 Git 보안 메일 링리스트 &amp;lt; &lt;a href=&quot;mailto:git-security@googlegroups.com&quot;&gt;git-security@googlegroups.com&lt;/a&gt; &amp;gt;에 비공개로 공개해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7e6ca0d89968d14a4a145a03ebcf512ab164b2cf" translate="yes" xml:space="preserve">
          <source>Issuing a &lt;code&gt;filedeleteall&lt;/code&gt; followed by the needed &lt;code&gt;filemodify&lt;/code&gt; commands to set the correct content will produce the same results as sending only the needed &lt;code&gt;filemodify&lt;/code&gt; and &lt;code&gt;filedelete&lt;/code&gt; commands. The &lt;code&gt;filedeleteall&lt;/code&gt; approach may however require fast-import to use slightly more memory per active branch (less than 1 MiB for even most large projects); so frontends that can easily obtain only the affected paths for a commit are encouraged to do so.</source>
          <target state="translated">올바른 컨텐츠를 설정 하기 위해 &lt;code&gt;filedeleteall&lt;/code&gt; 다음에 필요한 &lt;code&gt;filemodify&lt;/code&gt; 명령을 발행 하면 필요한 &lt;code&gt;filemodify&lt;/code&gt; 및 &lt;code&gt;filedelete&lt;/code&gt; 명령 만 보내는 것과 동일한 결과가 생성됩니다 . 그러나 &lt;code&gt;filedeleteall&lt;/code&gt; 접근 방식은 활성 브랜치 당 약간 더 많은 메모리를 사용하기 위해 빠른 가져 오기가 필요할 수 있습니다 (대규모 프로젝트의 경우 1MiB 미만). 따라서 커밋에 영향을받는 경로 만 쉽게 얻을 수있는 프런트 엔드가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="bdf45bc4332be1bec5eceb55b9547e5441cbefc8" translate="yes" xml:space="preserve">
          <source>It adds the submodule&amp;rsquo;s clone path to the &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; file and adds this file to the index, ready to be committed.</source>
          <target state="translated">서브 모듈의 클론 경로를 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 파일에 추가하고이 파일을 인덱스에 추가하여 커밋 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c81521fe76c33a9e0c12152a7126a3168cdc6bc" translate="yes" xml:space="preserve">
          <source>It adds the submodule&amp;rsquo;s current commit ID to the index, ready to be committed.</source>
          <target state="translated">서브 모듈의 현재 커밋 ID를 인덱스에 추가하여 커밋 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d31bfc2387ea73611500553c1004cb0667d4f160" translate="yes" xml:space="preserve">
          <source>It affects the way a change that amounts to a total rewrite of a file not as a series of deletion and insertion mixed together with a very few lines that happen to match textually as the context, but as a single deletion of everything old followed by a single insertion of everything new, and the number &lt;code&gt;m&lt;/code&gt; controls this aspect of the -B option (defaults to 60%). &lt;code&gt;-B/70%&lt;/code&gt; specifies that less than 30% of the original should remain in the result for Git to consider it a total rewrite (i.e. otherwise the resulting patch will be a series of deletion and insertion mixed together with context lines).</source>
          <target state="translated">그것은 일련의 삭제 및 삽입이 아니라 텍스트와 문맥 상 텍스트로 일치하는 아주 적은 행과 함께 파일을 완전히 다시 작성하는 변경에 영향을 미칩니다. 새로운 모든 것을 한 번만 삽입하면 숫자 &lt;code&gt;m&lt;/code&gt; 은 -B 옵션의이 측면을 제어합니다 (기본값은 60 %). &lt;code&gt;-B/70%&lt;/code&gt; 는 Git이 원본을 30 % 미만으로 유지하여 결과를 총 재 작성으로 간주하도록 지정합니다 (그렇지 않으면 결과 패치는 컨텍스트 라인과 함께 일련의 삭제 및 삽입이됩니다).</target>
        </trans-unit>
        <trans-unit id="3769038328418f1b146bfedf460a0d4ea1eab91b" translate="yes" xml:space="preserve">
          <source>It also allows a &quot;ref&quot; file to be a symbolic pointer to another ref file by starting with the four-byte header sequence of &quot;ref:&quot;.</source>
          <target state="translated">또한 &quot;ref :&quot;의 4 바이트 헤더 시퀀스로 시작하여 &quot;ref&quot;파일이 다른 ref 파일에 대한 기호 포인터가되도록합니다.</target>
        </trans-unit>
        <trans-unit id="c1a8e562ae70e23b9286b736cb60f8fd411f796d" translate="yes" xml:space="preserve">
          <source>It can also be useful in scripts passed to &quot;git bisect run&quot; to &quot;exit 255&quot; if some very abnormal situation is detected.</source>
          <target state="translated">매우 비정상적인 상황이 감지되면 &quot;git bisect run&quot;으로 전달 된 스크립트에서 &quot;255를 종료&quot;하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79b5b9aab5919bae0a6145dab082f1d19cd80f67" translate="yes" xml:space="preserve">
          <source>It can be cumbersome to input the same credentials over and over. Git provides two methods to reduce this annoyance:</source>
          <target state="translated">동일한 자격 증명을 반복해서 입력하는 것은 번거로울 수 있습니다. 힘내는이 성가심을 줄이기 위해 두 가지 방법을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="4e1aaed29365e5e25e94340f3a0f563a3458fb95" translate="yes" xml:space="preserve">
          <source>It can be used to inspect the current working tree and refuse to make a commit if it does not pass certain test.</source>
          <target state="translated">현재 작업 트리를 검사하고 특정 테스트를 통과하지 못하면 커밋을 거부하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15367977bf1bc97e62677f2311accebdf50497b6" translate="yes" xml:space="preserve">
          <source>It can efficiently represent information about merge conflicts between different tree objects, allowing each pathname to be associated with sufficient information about the trees involved that you can create a three-way merge between them.</source>
          <target state="translated">서로 다른 트리 개체 간의 병합 충돌에 대한 정보를 효율적으로 나타낼 수 있으므로 각 경로 이름을 트리 간 병합을 만들 수있는 관련 트리에 대한 충분한 정보와 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61f59429096395b0e09a9585119ef97dbe0f3099" translate="yes" xml:space="preserve">
          <source>It cannot show more than 29 branches and commits at a time.</source>
          <target state="translated">한 번에 29 개 이상의 분기 및 커밋을 표시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="84908290c2ad8351819557b635db90afccbc35f1" translate="yes" xml:space="preserve">
          <source>It clones the submodule from &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; to the given &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; under the current directory and by default checks out the master branch.</source>
          <target state="translated">하위 디렉토리 를 &lt;code&gt;&amp;lt;repo&amp;gt;&lt;/code&gt; 에서 현재 디렉토리 아래의 지정된 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 로 복제하고 기본적으로 마스터 분기를 체크 아웃합니다.</target>
        </trans-unit>
        <trans-unit id="d2f2a22f8382dea93b62981d5e21e0c74a8c6b46" translate="yes" xml:space="preserve">
          <source>It could also be used to log the old..new status. However, it does not know the entire set of branches, so it would end up firing one e-mail per ref when used naively, though. The &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;post-receive&lt;/em&gt;&lt;/a&gt; hook is more suited to that.</source>
          <target state="translated">old..new 상태를 기록하는 데 사용될 수도 있습니다. 그러나 전체 브랜치 세트를 알지 못하므로 순진하게 사용될 때 참조 당 하나의 이메일을 발행하게됩니다. 는 &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;이후 수신&lt;/em&gt;&lt;/a&gt; 후크가 더 적합하다.</target>
        </trans-unit>
        <trans-unit id="784deb932c786d53caa1d9cefe7cd05964d957b0" translate="yes" xml:space="preserve">
          <source>It defaults to &lt;code&gt;blue,12 month ago,white,1 month ago,red&lt;/code&gt;, which colors everything older than one year blue, recent changes between one month and one year old are kept white, and lines introduced within the last month are colored red.</source>
          <target state="translated">1 년보다 오래된 모든 것을 채색 하는 &lt;code&gt;blue,12 month ago,white,1 month ago,red&lt;/code&gt; 기본 설정되며 , 1 개월과 1 년 사이의 최근 변경 사항은 흰색으로 유지되고 지난 달에 도입 된 선은 빨간색으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="91de163844ee67c93c1b1c843cc5bef0832c9f25" translate="yes" xml:space="preserve">
          <source>It does its best to do the safe thing, it will check that the files are unchanged and up to date in the CVS checkout, and it will not autocommit by default.</source>
          <target state="translated">안전한 작업을 수행하는 것이 가장 좋으며 CVS 체크 아웃에서 파일이 변경되지 않고 최신 상태인지 확인하며 기본적으로 자동 커밋되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92564150ed02a0207f639f4b1e8f897270e7157d" translate="yes" xml:space="preserve">
          <source>It does this by storing some additional data for each entry (such as the last modified time). This data is not displayed above, and is not stored in the created tree object, but it can be used to determine quickly which files in the working directory differ from what was stored in the index, and thus save Git from having to read all of the data from such files to look for changes.</source>
          <target state="translated">각 항목에 대한 추가 데이터 (예 : 마지막 수정 시간)를 저장하여이를 수행합니다. 이 데이터는 위에 표시되지 않고 작성된 트리 오브젝트에 저장되지 않지만 작업 디렉토리의 파일이 색인에 저장된 파일과 다른 파일을 신속하게 판별하여 Git을 모두 읽지 않아도되도록하는 데 사용할 수 있습니다. 변경 사항을 찾기 위해 해당 파일의 데이터</target>
        </trans-unit>
        <trans-unit id="af8ba1869bb0a79ae9cea38b1af5617b9069dca1" translate="yes" xml:space="preserve">
          <source>It enables git to work together with a file system monitor (see the &quot;fsmonitor-watchman&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;) that can inform it as to what files have been modified. This enables git to avoid having to lstat() every file to find modified files.</source>
          <target state="translated">git은 파일 시스템 모니터 ( &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 의 &quot;fsmonitor-watchman&quot;섹션 참조)와 함께 작동 하여 어떤 파일이 수정되었는지 알 수 있습니다. 이를 통해 git은 수정 된 파일을 찾기 위해 모든 파일을 lstat ()하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="af9f31199487ba705eebc5dd4bc13449d71955c8" translate="yes" xml:space="preserve">
          <source>It expects to be dealing with one project only. If it sees branches that have different roots, it will refuse to run. In that case, edit your &amp;lt;archive/branch&amp;gt; parameters to define clearly the scope of the import.</source>
          <target state="translated">하나의 프로젝트 만 처리 할 것으로 예상됩니다. 뿌리가 다른 가지가 보이면 달리기를 거부합니다. 이 경우 &amp;lt;archive / branch&amp;gt; 매개 변수를 편집하여 가져 오기 범위를 명확하게 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="d015f51d5305572fa694969daaad327b702a39d6" translate="yes" xml:space="preserve">
          <source>It helps to divide these functions into groups for discussion purposes.</source>
          <target state="translated">토론 목적으로 이러한 기능을 그룹으로 나누는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="cf8815ec8cef4d3d8f9a8adf49f25148a4887929" translate="yes" xml:space="preserve">
          <source>It is &lt;code&gt;&amp;lt;unix timestamp&amp;gt; &amp;lt;time zone offset&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;unix
timestamp&amp;gt;&lt;/code&gt; is the number of seconds since the UNIX epoch. &lt;code&gt;&amp;lt;time zone offset&amp;gt;&lt;/code&gt; is a positive or negative offset from UTC. For example CET (which is 1 hour ahead of UTC) is &lt;code&gt;+0100&lt;/code&gt;.</source>
          <target state="translated">그것은 인 &lt;code&gt;&amp;lt;unix timestamp&amp;gt; &amp;lt;time zone offset&amp;gt;&lt;/code&gt; 여기서 &lt;code&gt;&amp;lt;unix timestamp&amp;gt;&lt;/code&gt; 유닉스 에포크 초이다. &lt;code&gt;&amp;lt;time zone offset&amp;gt;&lt;/code&gt; 은 UTC의 양수 또는 음수 오프셋입니다. 예를 들어 CET (UTC보다 1 시간 &lt;code&gt;+0100&lt;/code&gt; )은 +0100 입니다.</target>
        </trans-unit>
        <trans-unit id="3f4ae55d14bc9f41dc555ac55a4684de8bea2c17" translate="yes" xml:space="preserve">
          <source>It is OK to include files which have not actually changed. All changes including newly-created and deleted files should be included. When files are renamed, both the old and the new name should be included.</source>
          <target state="translated">실제로 변경되지 않은 파일을 포함해도됩니다. 새로 생성되고 삭제 된 파일을 포함한 모든 변경 사항이 포함되어야합니다. 파일 이름이 바뀌면 이전 이름과 새 이름이 모두 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="854a36265382bec82daa5a74f777ff212834a549" translate="yes" xml:space="preserve">
          <source>It is a good idea to introduce yourself to Git with your name and public email address before doing any operation. The easiest way to do so is:</source>
          <target state="translated">작업을 수행하기 전에 이름과 공개 이메일 주소로 Git에 자신을 소개하는 것이 좋습니다. 가장 쉬운 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0dc733d75bf5327e08cfc3134be1a3042cbb2515" translate="yes" xml:space="preserve">
          <source>It is a rough equivalent for:</source>
          <target state="translated">대략적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95c229774b9b51315840e554d56265719cd8be5c" translate="yes" xml:space="preserve">
          <source>It is also a good idea when using any VCS to have only one small logical change in each commit.</source>
          <target state="translated">또한 VCS를 사용하여 각 커밋마다 하나의 작은 논리적 변경 만 가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6c5a3acbba80472c3128c6339cb1639b4bd8a27a" translate="yes" xml:space="preserve">
          <source>It is also permitted for a notes ref to point directly to a tree object, in which case the history of the notes can be read with &lt;code&gt;git log -p -g &amp;lt;refname&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">노트 참조가 트리 객체를 직접 가리킬 수도 있습니다.이 경우 노트의 히스토리를 &lt;code&gt;git log -p -g &amp;lt;refname&amp;gt;&lt;/code&gt; 으로 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b16dc4f2558875d3f67cc118d8aee343695acae5" translate="yes" xml:space="preserve">
          <source>It is also possible to fetch a subset of branches or tags by using a comma-separated list of names within braces. For example:</source>
          <target state="translated">중괄호 안에 쉼표로 구분 된 이름 목록을 사용하여 분기 또는 태그의 하위 집합을 가져올 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="12b7523072e662c296ea1a80ba59ec7ed5fcb7e4" translate="yes" xml:space="preserve">
          <source>It is also possible to introduce completely new merge commits from scratch by adding a command of the form &lt;code&gt;merge &amp;lt;merge-head&amp;gt;&lt;/code&gt;. This form will generate a tentative commit message and always open an editor to let the user edit it. This can be useful e.g. when a topic branch turns out to address more than a single concern and wants to be split into two or even more topic branches. Consider this todo list:</source>
          <target state="translated">&lt;code&gt;merge &amp;lt;merge-head&amp;gt;&lt;/code&gt; 형식의 명령을 추가하여 완전히 새로운 병합 커밋을 처음부터 도입 할 수도 있습니다 . 이 양식은 임시 커밋 메시지를 생성하고 사용자가 편집 할 수 있도록 항상 편집기를 엽니 다. 예를 들어 주제 분기가 하나 이상의 관심사를 해결하고 둘 이상의 주제 분기로 분할하려는 경우에 유용 할 수 있습니다. 이 할 일 목록을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e8d4e8a65d3b558ba4900bdd06798676f68d11ad" translate="yes" xml:space="preserve">
          <source>It is also possible to provide true CVS access to a Git repository, so that developers can still use CVS; see &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver[1]&lt;/a&gt; for details.</source>
          <target state="translated">개발자가 여전히 CVS를 사용할 수 있도록 Git 저장소에 대한 진정한 CVS 액세스를 제공 할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;git-cvsserver&quot;&gt;git-cvsserver [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3fcb2e34d6c27144258c45911fcc9298afaeeefa" translate="yes" xml:space="preserve">
          <source>It is also possible to replace commits further back in the history, but this is an advanced topic to be left for &lt;a href=&quot;#cleaning-up-history&quot;&gt;another chapter&lt;/a&gt;.</source>
          <target state="translated">히스토리에서 커밋을 다시 대체하는 것도 가능하지만 이것은 &lt;a href=&quot;#cleaning-up-history&quot;&gt;다른 장에서&lt;/a&gt; 남겨 두어야 할 고급 주제 입니다.</target>
        </trans-unit>
        <trans-unit id="14665d6ab0c5fa19cd26aec534fecd5dda3c4692" translate="yes" xml:space="preserve">
          <source>It is also run after &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;, unless the &lt;code&gt;--no-checkout&lt;/code&gt; (&lt;code&gt;-n&lt;/code&gt;) option is used. The first parameter given to the hook is the null-ref, the second the ref of the new HEAD and the flag is always 1. Likewise for &lt;code&gt;git worktree add&lt;/code&gt; unless &lt;code&gt;--no-checkout&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;--no-checkout&lt;/code&gt; ( &lt;code&gt;-n&lt;/code&gt; ) 옵션을 사용 하지 않으면 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 후에 실행 됩니다. 후크에 제공된 첫 번째 매개 변수는 널 참조이고, 두 번째는 새 HEAD의 참조이며 플래그는 항상 1 입니다. &lt;code&gt;--no-checkout&lt;/code&gt; 이 사용 되지 않는 한 &lt;code&gt;git worktree add&lt;/code&gt; 의 경우와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="2bf0b4701dd5a8615d5c5a4270f19ec18f43aa49" translate="yes" xml:space="preserve">
          <source>It is an error if &amp;lt;dst&amp;gt; matches more than one remote refs.</source>
          <target state="translated">&amp;lt;dst&amp;gt;가 둘 이상의 원격 참조와 일치하면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="47ed8fd8a6ccf512f8dd41b7de1bb50b3d494692" translate="yes" xml:space="preserve">
          <source>It is an error if &amp;lt;src&amp;gt; does not match exactly one of the local refs.</source>
          <target state="translated">&amp;lt;src&amp;gt;가 로컬 참조 중 하나와 정확히 일치하지 않으면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="08551e573ca80a9130c1ec33d2456a204ee6a838" translate="yes" xml:space="preserve">
          <source>It is an error to specify a ref that does not pass &quot;git check-ref-format&quot; scrutiny. Duplicated values are filtered.</source>
          <target state="translated">&quot;git check-ref-format&quot;검사를 통과하지 않은 참조를 지정하는 것은 오류입니다. 중복 된 값이 필터링됩니다.</target>
        </trans-unit>
        <trans-unit id="91dc5c05cc945b2e35d03a4d25f4568585356b02" translate="yes" xml:space="preserve">
          <source>It is assumed that any handshaking procedures have already been completed (such as sending service request for git://) before this helper is started.</source>
          <target state="translated">이 헬퍼가 시작되기 전에 핸드 셰이 킹 절차 (git : //에 대한 서비스 요청 전송 등)가 이미 완료된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="7a3002fc7973dbc26474a90f4bdcb162301b4e67" translate="yes" xml:space="preserve">
          <source>It is currently only possible to recreate the merge commits using the &lt;code&gt;recursive&lt;/code&gt; merge strategy; Different merge strategies can be used only via explicit &lt;code&gt;exec git merge -s &amp;lt;strategy&amp;gt; [...]&lt;/code&gt; commands.</source>
          <target state="translated">현재 &lt;code&gt;recursive&lt;/code&gt; 병합 전략을 사용하여 병합 커밋을 다시 만들 수만 있습니다 . 다른 병합 전략은 명시 적 &lt;code&gt;exec git merge -s &amp;lt;strategy&amp;gt; [...]&lt;/code&gt; 명령을 통해서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd70cf0a22a7ad38ee60197dd400f891cf0d57a3" translate="yes" xml:space="preserve">
          <source>It is expected that the content of the commit object you created while following the example above generates a different SHA-1 hash than the one shown above because the commit object records the time when it was created and the name of the person performing the commit.</source>
          <target state="translated">커밋 개체는 생성 된 시간과 커밋을 수행하는 사람의 이름을 기록하기 때문에 위의 예를 따르는 동안 생성 한 커밋 개체의 내용은 위에 표시된 것과 다른 SHA-1 해시를 생성 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="f78a88555b80a7cb6f279e6cf8551b4ade125a2a" translate="yes" xml:space="preserve">
          <source>It is followed by one or more extended header lines (this example shows a merge with two parents):</source>
          <target state="translated">그 뒤에 하나 이상의 확장 된 헤더 행이옵니다 (이 예에서는 두 부모와의 병합을 보여줍니다).</target>
        </trans-unit>
        <trans-unit id="4d181ca929d0bcae1d19e843f3c648e99a609d36" translate="yes" xml:space="preserve">
          <source>It is followed by one or more extended header lines:</source>
          <target state="translated">그 뒤에 하나 이상의 확장 된 헤더 행이옵니다.</target>
        </trans-unit>
        <trans-unit id="a6770fb3a63d614ebdc42bea002a81ec83ae2568" translate="yes" xml:space="preserve">
          <source>It is followed by two-line from-file/to-file header</source>
          <target state="translated">그 다음에 2 줄 From 파일 / to 파일 헤더가옵니다.</target>
        </trans-unit>
        <trans-unit id="31bbdf9a81fa3062a8106d3f0d5511057b4a5222" translate="yes" xml:space="preserve">
          <source>It is highly functional. However, not all methods are implemented, and for those methods that are implemented, not all switches are implemented.</source>
          <target state="translated">매우 기능적입니다. 그러나 모든 방법이 구현 된 것은 아니며 구현 된 방법에 대해 모든 스위치가 구현되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="13209c7d424e2b65e2d35ccb5123d7d58e26c1e7" translate="yes" xml:space="preserve">
          <source>It is important to realize that at this point nothing refers to commit &lt;code&gt;f&lt;/code&gt;. Eventually commit &lt;code&gt;f&lt;/code&gt; (and by extension commit &lt;code&gt;e&lt;/code&gt;) will be deleted by the routine Git garbage collection process, unless we create a reference before that happens. If we have not yet moved away from commit &lt;code&gt;f&lt;/code&gt;, any of these will create a reference to it:</source>
          <target state="translated">이 시점에서 아무것도 커밋 &lt;code&gt;f&lt;/code&gt; 를 의미하지 않는다는 것을 인식하는 것이 중요합니다 . 결과적으로 커밋 &lt;code&gt;f&lt;/code&gt; (및 확장 커밋 &lt;code&gt;e&lt;/code&gt; )는 발생하기 전에 참조를 만들지 않는 한 일상적인 Git 가비지 수집 프로세스에 의해 삭제됩니다. commit &lt;code&gt;f&lt;/code&gt; 에서 멀어지지 않았다면 , 이것들에 대한 참조가 생성 될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="15e77b99d56294dd4d998fab1260c89fc2b1f677" translate="yes" xml:space="preserve">
          <source>It is likely that you will be pulling from the same remote repository from time to time. As a short hand, you can store the remote repository URL in the local repository&amp;rsquo;s config file like this:</source>
          <target state="translated">때때로 동일한 원격 저장소에서 가져 오는 것 같습니다. 간단히 말해서 다음과 같이 원격 저장소 URL을 로컬 저장소의 구성 파일에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e468ce82ca7a37df3e0ccb7eddd0ee514020b622" translate="yes" xml:space="preserve">
          <source>It is likely that you will be working on more than one thing at a time. It is easy to manage those more-or-less independent tasks using branches with Git.</source>
          <target state="translated">한 번에 둘 이상의 작업을 수행 할 수 있습니다. Git이있는 브랜치를 사용하여 독립적 인 작업을 쉽게 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="cdfac588afc71ee687618e7ec3bc2f824e200606" translate="yes" xml:space="preserve">
          <source>It is not always easy for new developers to find their way through Git&amp;rsquo;s source code. This section gives you a little guidance to show where to start.</source>
          <target state="translated">새로운 개발자가 Git의 소스 코드를 통해 길을 찾는 것이 항상 쉬운 것은 아닙니다. 이 섹션에서는 어디서부터 시작해야하는지에 대한 간단한 지침을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="deded1cb8baf6033568ee8de4cb9cb55818cb450" translate="yes" xml:space="preserve">
          <source>It is not recommended to use this feature if you intend to export changes back to CVS again later with &lt;code&gt;git cvsexportcommit&lt;/code&gt;.</source>
          <target state="translated">나중에 &lt;code&gt;git cvsexportcommit&lt;/code&gt; 을 사용하여 변경 사항을 CVS로 다시 내보내려면이 기능을 사용하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="598d612724092a05c80fc92ca656e4e685e7e227" translate="yes" xml:space="preserve">
          <source>It is obviously a good idea not to have commits with changes that knowingly break things, even if some other commits later fix the breakage.</source>
          <target state="translated">다른 커밋이 나중에 파손을 수정하더라도 고의로 문제를 해결하는 변경 사항을 커밋하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8402ec5252190f6132c0772d2b1eafbec27785df" translate="yes" xml:space="preserve">
          <source>It is possible that a merge failure will prevent this process from being completely automatic. You will have to resolve any such merge failure and run &lt;code&gt;git rebase --continue&lt;/code&gt;. Another option is to bypass the commit that caused the merge failure with &lt;code&gt;git rebase --skip&lt;/code&gt;. To check out the original &amp;lt;branch&amp;gt; and remove the .git/rebase-apply working files, use the command &lt;code&gt;git rebase --abort&lt;/code&gt; instead.</source>
          <target state="translated">병합 실패로 인해이 프로세스가 완전히 자동으로 진행되지 않을 수 있습니다. 이러한 병합 실패를 해결하고 &lt;code&gt;git rebase --continue&lt;/code&gt; 을 실행해야합니다 . 또 다른 옵션은 &lt;code&gt;git rebase --skip&lt;/code&gt; 로 병합 실패를 일으킨 커밋을 무시하는 것 입니다. 원본 &amp;lt;branch&amp;gt;를 확인하고 .git / rebase-apply 작업 파일을 제거하려면 대신 &lt;code&gt;git rebase --abort&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ea7f2913c3e95cfd4ae5ff1f6d8aecb190ef204" translate="yes" xml:space="preserve">
          <source>It is possible to construct these old form repositories manually.</source>
          <target state="translated">이러한 이전 양식 저장소를 수동으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="548453998a9c855739e7eb9ec21e0581e0ed374b" translate="yes" xml:space="preserve">
          <source>It is possible to disable use of replacement references for any command using the &lt;code&gt;--no-replace-objects&lt;/code&gt; option just after &lt;code&gt;git&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git&lt;/code&gt; 바로 뒤에 &lt;code&gt;--no-replace-objects&lt;/code&gt; 옵션을 사용하여 명령에 대한 대체 참조 사용을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c06956dd566d0990dc7bdbc85eb39fd34edd8452" translate="yes" xml:space="preserve">
          <source>It is preceded with a &quot;git diff&quot; header that looks like this:</source>
          <target state="translated">다음과 같은 &quot;git diff&quot;헤더가 앞에옵니다 :</target>
        </trans-unit>
        <trans-unit id="fae83443f259566d0e3ea169c2bee02ad7796585" translate="yes" xml:space="preserve">
          <source>It is preceded with a &quot;git diff&quot; header, that looks like this (when the &lt;code&gt;-c&lt;/code&gt; option is used):</source>
          <target state="translated">&quot;git diff&quot;헤더가 앞에옵니다. ( &lt;code&gt;-c&lt;/code&gt; 옵션을 사용하는 경우) :</target>
        </trans-unit>
        <trans-unit id="41c2e2ee7c9260a90ac9d47c12dc86595dc670c7" translate="yes" xml:space="preserve">
          <source>It is purely performance optimization, originally intended for MacOS X, where recursive directory traversal is slow. Gitweb follows symbolic links, but it detects cycles, ignoring any duplicate files and directories.</source>
          <target state="translated">재귀 적 디렉토리 탐색 속도가 느린 MacOS X를위한 순수한 성능 최적화입니다. Gitweb은 심볼릭 링크를 따르지만 중복 파일과 디렉토리는 무시하고주기를 감지합니다.</target>
        </trans-unit>
        <trans-unit id="bcd29e9bb49344b0e527480d5a1209557826cefc" translate="yes" xml:space="preserve">
          <source>It is recommended that &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; always be encoded using UTF-8.</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 는 항상 UTF-8을 사용하여 인코딩하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="987c2f12e083069e2c3c6529da1c2b8427b5d901" translate="yes" xml:space="preserve">
          <source>It is safer if both &lt;code&gt;test.sh&lt;/code&gt; and &lt;code&gt;check_test_case.sh&lt;/code&gt; are outside the repository to prevent interactions between the bisect, make and test processes and the scripts.</source>
          <target state="translated">bisect, make 및 test 프로세스와 스크립트 간의 상호 작용을 방지하기 위해 &lt;code&gt;test.sh&lt;/code&gt; 와 &lt;code&gt;check_test_case.sh&lt;/code&gt; 가 모두 저장소 외부에있는 것이 더 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="07dbd897b2b790cda3e0cd6c93a27be05c0967a5" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to be able to checkout a commit that is not at the tip of any named branch, or even to create a new commit that is not referenced by a named branch. Let&amp;rsquo;s look at what happens when we checkout commit &lt;code&gt;b&lt;/code&gt; (here we show two ways this may be done):</source>
          <target state="translated">명명 된 분기의 끝에없는 커밋을 체크 아웃하거나 명명 된 분기에서 참조하지 않는 새 커밋을 만드는 것이 유용한 경우가 있습니다. 커밋 &lt;code&gt;b&lt;/code&gt; 를 체크 아웃 할 때 어떤 일이 발생하는지 살펴 보자 (여기서는 두 가지 방법이있다).</target>
        </trans-unit>
        <trans-unit id="19dd47dcbbf16a9cccaac6e901efe1eb6d41c6b4" translate="yes" xml:space="preserve">
          <source>It is still your responsibility to make sure that the email message sent by your email program meets the standards of your project. Many projects do not like patches to be attached. Some mail agents will transform patches (e.g. wrap lines, send them as format=flowed) in ways that make them fail. You will get angry flames ridiculing you if you don&amp;rsquo;t check this.</source>
          <target state="translated">이메일 프로그램에서 보낸 이메일 메시지가 프로젝트 표준을 충족하는지 확인하는 것은 여전히 ​​귀하의 책임입니다. 많은 프로젝트는 패치를 첨부하는 것을 좋아하지 않습니다. 일부 메일 에이전트는 패치를 변환 (예 : 줄 바꿈, 형식 = 흐름으로 전송)하여 실패하게 만듭니다. 이것을 확인하지 않으면 화염이 날 것입니다.</target>
        </trans-unit>
        <trans-unit id="446989de9f552ff7a375d76851b391396cb21747" translate="yes" xml:space="preserve">
          <source>It is unlikely that you would have any conflicts here &amp;hellip;​ but you might if you spent a while on this step and had also pulled new versions from upstream.</source>
          <target state="translated">여기서 충돌이 발생하지는 않지만 ...이 단계에서 잠시 시간을 보내고 업스트림에서 새 버전을 가져 왔을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d35217f8f6c81e1e684634a0bdd90859d19f06a" translate="yes" xml:space="preserve">
          <source>It is up to the user to ensure that no In-Reply-To header already exists when &lt;code&gt;git send-email&lt;/code&gt; is asked to add it (especially note that &lt;code&gt;git format-patch&lt;/code&gt; can be configured to do the threading itself). Failure to do so may not produce the expected result in the recipient&amp;rsquo;s MUA.</source>
          <target state="translated">&lt;code&gt;git send-email&lt;/code&gt; 에 헤더 를 추가하라는 요청 이있을 때 In-Reply-To 헤더가 없는지 확인하는 것은 사용자의 몫입니다 (특히 &lt;code&gt;git format-patch&lt;/code&gt; 는 스레딩 자체를 수행하도록 구성 될 수 있음). 그렇지 않으면 수신자의 MUA에서 예상되는 결과를 얻지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28ab82f4261b972bffcbd084fca6120764f529fe" translate="yes" xml:space="preserve">
          <source>It is useful when you&amp;rsquo;re looking for an exact block of code (like a struct), and want to know the history of that block since it first came into being: use the feature iteratively to feed the interesting block in the preimage back into &lt;code&gt;-S&lt;/code&gt;, and keep going until you get the very first version of the block.</source>
          <target state="translated">구조체와 같은 정확한 코드 블록을 찾고 처음 시작한 이후 해당 블록의 히스토리를 알고 싶을 때 유용합니다.이 기능을 반복적으로 사용하여 사전 이미지의 흥미로운 블록을 &lt;code&gt;-S&lt;/code&gt; 이고 블록의 첫 번째 버전을 얻을 때까지 계속 진행하십시오.</target>
        </trans-unit>
        <trans-unit id="212ba732375c1f9e18ce6b37fe943bc0a79e8a67" translate="yes" xml:space="preserve">
          <source>It is very important that the basis used be held by the destination. It is okay to err on the side of caution, causing the bundle file to contain objects already in the destination, as these are ignored when unpacking at the destination.</source>
          <target state="translated">사용 된 기준이 목적지에 의해 유지되는 것이 매우 중요합니다. 번들 파일에 대상에 이미있는 오브젝트가 포함되어 있으므로 대상 측에서 압축을 풀 때 무시되므로 번들을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f89d35d0ac276c4d31876791b9f069b985ca50ec" translate="yes" xml:space="preserve">
          <source>It may well be that among networking people, they may want to exchange the tags internal to their group, but in that workflow they are most likely tracking each other&amp;rsquo;s progress by having remote-tracking branches. Again, the heuristic to automatically follow such tags is a good thing.</source>
          <target state="translated">네트워킹 사람들 사이에서 그룹 내부의 태그를 교환하고 싶을 수도 있지만, 워크 플로에서 원격 추적 지점을 통해 서로의 진행 상황을 추적 할 가능성이 높습니다. 다시 말하지만, 이러한 태그를 자동으로 따르는 휴리스틱은 좋은 것입니다.</target>
        </trans-unit>
        <trans-unit id="b30dde80280e412c885fe09e1718d04b65bebbd4" translate="yes" xml:space="preserve">
          <source>It must be readable in order, from beginning to end, by someone intelligent with a basic grasp of the UNIX command line, but without any special knowledge of Git. If necessary, any other prerequisites should be specifically mentioned as they arise.</source>
          <target state="translated">유닉스 명령 줄에 대한 기본적인 지식이 있지만 Git에 대한 특별한 지식이없는 사람이 처음부터 끝까지 읽을 수 있어야한다. 필요한 경우, 다른 전제 조건을 구체적으로 언급해야합니다.</target>
        </trans-unit>
        <trans-unit id="105999ab02cc181d3d21d02fda72679e92aee0b2" translate="yes" xml:space="preserve">
          <source>It should be stressed that this hierarchy is purely &lt;strong&gt;informal&lt;/strong&gt;. There is nothing fundamental in Git that enforces the &quot;chain of patch flow&quot; this hierarchy implies. You do not have to pull from only one remote repository.</source>
          <target state="translated">이 계층은 순수하게 &lt;strong&gt;비공식적&lt;/strong&gt; 이라는 점을 강조해야합니다 . Git에는이 계층 구조가 의미하는 &quot;패치 흐름 체인&quot;을 적용하는 기본 사항이 없습니다. 하나의 원격 저장소 만 가져올 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7beffad8901e95a09a82e88d22525a3cad3065d8" translate="yes" xml:space="preserve">
          <source>It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, &lt;code&gt;binary&lt;/code&gt; would have been shown in place of &lt;code&gt;nothing&lt;/code&gt;). The other file, git-add--interactive.perl, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion).</source>
          <target state="translated">foo.png가 HEAD와 차이가 있음을 보여줍니다 (하지만 바이너리이므로 라인 수를 표시 할 수 없음). 인덱싱 된 복사본과 작업 트리 버전간에 차이가 없습니다 (작업 트리 버전도 다르면 &lt;code&gt;binary&lt;/code&gt; 가 표시되었을 것입니다). &lt;code&gt;nothing&lt;/code&gt; 대신 ). 다른 파일 인 git-add--interactive.perl에는 인덱스에있는 내용을 커밋하면 403 줄이 추가되고 35 줄이 삭제되지만 작업 트리 파일에는 추가 수정 사항이 있습니다 (하나는 추가되고 하나는 삭제됨).</target>
        </trans-unit>
        <trans-unit id="593ae3fc1288babccd02a202f40d492d26634f5a" translate="yes" xml:space="preserve">
          <source>It shows that foo.png has differences from HEAD (but that is binary so line count cannot be shown) and there is no difference between indexed copy and the working tree version (if the working tree version were also different, &lt;code&gt;binary&lt;/code&gt; would have been shown in place of &lt;code&gt;nothing&lt;/code&gt;). The other file, git-add{litdd}interactive.perl, has 403 lines added and 35 lines deleted if you commit what is in the index, but working tree file has further modifications (one addition and one deletion).</source>
          <target state="translated">그것은 foo.png가 HEAD와 차이가 있지만 (이진수이므로 줄 수를 표시 할 수 없음) 색인화 된 사본과 작업 트리 버전 사이에는 차이가 없습니다 (작업 트리 버전도 다르면 &lt;code&gt;binary&lt;/code&gt; 되었을 것입니다) &lt;code&gt;nothing&lt;/code&gt; 대신 ). 색인에있는 내용을 커밋하면 다른 파일 인 git-add {litdd} interactive.perl에 403 줄이 추가되고 35 줄이 삭제되지만 작업 트리 파일에는 추가 수정 (한 번의 추가 및 한 번의 삭제)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f22531fd9489cd1b4496c81c3454037c20af1a5" translate="yes" xml:space="preserve">
          <source>It takes a variable number of parameters, each of which is the name of ref that was actually updated.</source>
          <target state="translated">가변 개수의 매개 변수를 사용하며 각 매개 변수는 실제로 업데이트 된 ref의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8d1640303505dff202eb78d383641a82298beff2" translate="yes" xml:space="preserve">
          <source>It takes on the standard input the specification of the options to parse and understand, and echoes on the standard output a string suitable for &lt;code&gt;sh(1)&lt;/code&gt;&lt;code&gt;eval&lt;/code&gt; to replace the arguments with normalized ones. In case of error, it outputs usage on the standard error stream, and exits with code 129.</source>
          <target state="translated">표준 입력에서 구문 분석 및 이해하는 옵션의 스펙을 취하고 표준 출력 에서 인수를 정규화 된 인수로 대체 하기 위해 &lt;code&gt;sh(1)&lt;/code&gt; &lt;code&gt;eval&lt;/code&gt; 에 적합한 문자열을 에코 합니다. 오류가 발생하면 표준 오류 스트림에서 사용량을 출력하고 코드 129로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="9fc9d0adb73a5f351f66393e06f90ebbcd611062" translate="yes" xml:space="preserve">
          <source>It takes one to three parameters. The first is the name of the file that contains the commit log message. The second is the source of the commit message, and can be: &lt;code&gt;message&lt;/code&gt; (if a &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; option was given); &lt;code&gt;template&lt;/code&gt; (if a &lt;code&gt;-t&lt;/code&gt; option was given or the configuration option &lt;code&gt;commit.template&lt;/code&gt; is set); &lt;code&gt;merge&lt;/code&gt; (if the commit is a merge or a &lt;code&gt;.git/MERGE_MSG&lt;/code&gt; file exists); &lt;code&gt;squash&lt;/code&gt; (if a &lt;code&gt;.git/SQUASH_MSG&lt;/code&gt; file exists); or &lt;code&gt;commit&lt;/code&gt;, followed by a commit SHA-1 (if a &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt; or &lt;code&gt;--amend&lt;/code&gt; option was given).</source>
          <target state="translated">1 ~ 3 개의 매개 변수가 필요합니다. 첫 번째는 커밋 로그 메시지가 포함 된 파일 이름입니다. 두 번째는 커밋 메시지의 소스이며 다음과 같습니다. &lt;code&gt;message&lt;/code&gt; ( &lt;code&gt;-m&lt;/code&gt; 또는 &lt;code&gt;-F&lt;/code&gt; 옵션이 제공된 경우); &lt;code&gt;template&lt;/code&gt; ( &lt;code&gt;-t&lt;/code&gt; 옵션이 제공되었거나 구성 옵션 &lt;code&gt;commit.template&lt;/code&gt; 이 설정된 경우); &lt;code&gt;merge&lt;/code&gt; (커밋이 병합이거나 &lt;code&gt;.git/MERGE_MSG&lt;/code&gt; 파일이있는 경우); &lt;code&gt;squash&lt;/code&gt; ( &lt;code&gt;.git/SQUASH_MSG&lt;/code&gt; 파일이있는 경우); 또는 &lt;code&gt;commit&lt;/code&gt; 다음에 commit SHA-1 ( &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; 또는 &lt;code&gt;--amend&lt;/code&gt; 인 경우) 옵션이 제공되었습니다).</target>
        </trans-unit>
        <trans-unit id="ee62cbb1781a10ccff3a10f01577042e41951364" translate="yes" xml:space="preserve">
          <source>It tells you that it did an &quot;Automatic merge&quot;, which failed due to conflicts in &lt;code&gt;hello&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hello&lt;/code&gt; 의 충돌로 인해 실패한 &quot;자동 병합&quot;을 수행했음을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="31dbee78e4c488ce29554dd490d874937eb736b5" translate="yes" xml:space="preserve">
          <source>It used to be that the command defaulted to do &lt;code&gt;-x&lt;/code&gt; described above, and &lt;code&gt;-r&lt;/code&gt; was to disable it. Now the default is not to do &lt;code&gt;-x&lt;/code&gt; so this option is a no-op.</source>
          <target state="translated">이전에는 명령이 위에서 설명한 &lt;code&gt;-x&lt;/code&gt; 를 기본 으로 사용했으며 &lt;code&gt;-r&lt;/code&gt; 은 명령을 비활성화했습니다. 이제 기본값은 &lt;code&gt;-x&lt;/code&gt; 를 수행하지 않으므로이 옵션은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5579126502958d7cf2a79d1e6eb0f1ab9f1fb74" translate="yes" xml:space="preserve">
          <source>It uses &lt;code&gt;showbranch.default&lt;/code&gt; multi-valued configuration items if no &amp;lt;rev&amp;gt; or &amp;lt;glob&amp;gt; is given on the command line.</source>
          <target state="translated">그것은 사용 &lt;code&gt;showbranch.default&lt;/code&gt; 더 &amp;lt;REV&amp;gt; 또는 &amp;lt;글로브&amp;gt;이 명령 행에 주어지지 않으면 다치 구성 항목.</target>
        </trans-unit>
        <trans-unit id="c599d3ca0dc61039dd83109e0beef002f0abd196" translate="yes" xml:space="preserve">
          <source>It verifies that the directory has the magic file &quot;git-daemon-export-ok&quot;, and it will refuse to export any Git directory that hasn&amp;rsquo;t explicitly been marked for export this way (unless the &lt;code&gt;--export-all&lt;/code&gt; parameter is specified). If you pass some directory paths as &lt;code&gt;git daemon&lt;/code&gt; arguments, you can further restrict the offers to a whitelist comprising of those.</source>
          <target state="translated">디렉토리에 매직 파일 &quot;git-daemon-export-ok&quot;가 있는지 확인하고 &lt;code&gt;--export-all&lt;/code&gt; 매개 변수를 지정 하지 않는 한 명시 적으로 내보내기 용으로 표시되지 않은 Git 디렉토리의 내보내기를 거부 합니다. ). 일부 디렉토리 경로를 &lt;code&gt;git daemon&lt;/code&gt; 인수 로 전달 하면 해당 오퍼를 추가로 화이트리스트로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fd1b09d35c94e426d7de9278697f8281d2f9b0b" translate="yes" xml:space="preserve">
          <source>It verifies that the directory has the magic file &quot;git-daemon-export-ok&quot;, and it will refuse to export any Git directory that hasn&amp;rsquo;t explicitly been marked for export this way (unless the &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; environmental variable is set).</source>
          <target state="translated">디렉토리에 매직 파일 &quot;git-daemon-export-ok&quot;가 &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; 하고 GIT_HTTP_EXPORT_ALL 환경 변수가 설정 되지 않은 경우 명시 적으로 내 보내지 않은 Git 디렉토리의 내보내기를 거부합니다 .</target>
        </trans-unit>
        <trans-unit id="6a949f37aaca4177eee5df32a3761a98f4054a56" translate="yes" xml:space="preserve">
          <source>It was a tool of absolute last resort. I&amp;rsquo;d rather spend days looking at printk output than do a manual &lt;code&gt;patch bisection&lt;/code&gt;.</source>
          <target state="translated">절대 최후의 수단이었습니다. 수동 &lt;code&gt;patch bisection&lt;/code&gt; 보다 printk 출력을 보는 데 며칠을 보내고 싶습니다 .</target>
        </trans-unit>
        <trans-unit id="839ea1dcb179bd0fd1a734d84c9b044b60c7a423" translate="yes" xml:space="preserve">
          <source>It will be useful to have a Git repository to experiment with as you read this manual.</source>
          <target state="translated">이 매뉴얼을 읽을 때 Git 저장소를 시험해 보는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a1e588b366d6eee7b2a111ab040de25b982fdb3f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also possible for a push to fail in this way when other people have the right to push to the same repository. In that case, the correct solution is to retry the push after first updating your work: either by a pull, or by a fetch followed by a rebase; see the &lt;a href=&quot;#setting-up-a-shared-repository&quot;&gt;next section&lt;/a&gt; and &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt; for more.</source>
          <target state="translated">다른 사람이 동일한 저장소에 푸시 할 권한이있는 경우 이러한 방식으로 푸시가 실패 할 수도 있습니다. 이 경우 올바른 해결책은 작업을 처음 업데이트 한 후 푸시를 다시 시도하는 것입니다. 풀 (pull) 또는 페치 (fetch) 및 리베이스 (rebase); 자세한 내용은 &lt;a href=&quot;#setting-up-a-shared-repository&quot;&gt;다음 섹션&lt;/a&gt; 과 &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c8e637a625c72275676a912327970832afbb1fc7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s especially instructive to look at &quot;commit&quot; objects, since those tend to be small and fairly self-explanatory. In particular, if you follow the convention of having the top commit name in &lt;code&gt;.git/HEAD&lt;/code&gt;, you can do</source>
          <target state="translated">&quot;커밋&quot;객체는 작고 상당히 설명적인 경향이 있기 때문에 &quot;커밋&quot;객체를 보는 것이 특히 유익합니다. 특히 &lt;code&gt;.git/HEAD&lt;/code&gt; 에서 최상위 커밋 이름을 갖는 규칙을 따르는 경우 다음을 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ebca6c1346b961bb4e2f8a08e1112a09cf4c4143" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s far too easy to accidentally mix up old and new history. It&amp;rsquo;s still possible with any tool, but git-filter-branch almost invites it. If lucky, the only downside is users getting frustrated that they don&amp;rsquo;t know how to shrink their repo and remove the old stuff. If unlucky, they merge old and new history and end up with multiple &quot;copies&quot; of each commit, some of which have unwanted or sensitive files and others which don&amp;rsquo;t. This comes about in multiple different ways:</source>
          <target state="translated">실수로 오래된 것과 새로운 역사를 섞는 것은 너무 쉽습니다. 어떤 도구로도 가능하지만 git-filter-branch가 거의 초대합니다. 운이 좋으면 유일한 단점은 사용자가 레포를 축소하고 오래된 것을 제거하는 방법을 모른다는 좌절감을 느끼는 것입니다. 운이 좋지 않으면 구약과 새 기록을 병합하고 각 커밋의 여러 &quot;복사본&quot;으로 끝나며, 그 중 일부는 원하지 않거나 민감한 파일이 있고 그렇지 않은 파일도 있습니다. 이것은 여러 가지 방법으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7fb3124f269af4d6382e41b308c15a44d9e7c09f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not safe to run &lt;code&gt;git submodule update&lt;/code&gt; if you&amp;rsquo;ve made and committed changes within a submodule without checking out a branch first. They will be silently overwritten:</source>
          <target state="translated">분기를 먼저 체크 아웃하지 않고 서브 모듈 내에서 변경을 수행하고 커밋 한 경우 &lt;code&gt;git submodule update&lt;/code&gt; 를 실행하는 것은 안전하지 않습니다 . 그들은 자동으로 덮어 쓰기됩니다 :</target>
        </trans-unit>
        <trans-unit id="199b24a07e7c4f542f5c9b6cd233e68c58c149e6" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to push any type of object to any namespace outside of &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt;. In the case of tags and commits, these will be treated as if they were the commits inside &lt;code&gt;refs/heads/*&lt;/code&gt; for the purposes of whether the update is allowed.</source>
          <target state="translated">모든 유형의 객체를 &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 외부의 네임 스페이스로 푸시 할 수 있습니다 . 태그와 커밋의 경우 업데이트 허용 여부를 위해 &lt;code&gt;refs/heads/*&lt;/code&gt; 내부의 커밋 인 것처럼 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd25bf8e6a6252931a48d686e2c25ca4a7c9f16e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s probably not worth it to use this option on a given repository without running tailored performance benchmarks on it. It takes a lot more time, and the resulting space/delta optimization may or may not be worth it. Not using this at all is the right trade-off for most users and their repositories.</source>
          <target state="translated">맞춤형 성능 벤치 마크를 실행하지 않고 주어진 저장소에서이 옵션을 사용하는 것은 가치가 없습니다. 시간이 더 많이 걸리며 결과적으로 공간 / 델타 최적화는 그만한 가치가있을 수도 있고 그렇지 않을 수도 있습니다. 이것을 전혀 사용하지 않는 것은 대부분의 사용자와 그 저장소에 대한 올바른 균형입니다.</target>
        </trans-unit>
        <trans-unit id="6c2d9fe7b4d73e7c5f324adf6070448f4f753fb5" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s reasonable to e.g. configure &lt;code&gt;fetch.pruneTags=true&lt;/code&gt; in &lt;code&gt;~/.gitconfig&lt;/code&gt; to have tags pruned whenever &lt;code&gt;git fetch --prune&lt;/code&gt; is run, without making every invocation of &lt;code&gt;git fetch&lt;/code&gt; without &lt;code&gt;--prune&lt;/code&gt; an error.</source>
          <target state="translated">예를 들어 &lt;code&gt;~/.gitconfig&lt;/code&gt; 에서 &lt;code&gt;fetch.pruneTags=true&lt;/code&gt; 를 구성 하여 &lt;code&gt;git fetch --prune&lt;/code&gt; 이 실행될 때마다 태그 를 &lt;code&gt;--prune&lt;/code&gt; 오류 를 제거 하지 않고 &lt;code&gt;git fetch&lt;/code&gt; 를 호출 하지 않아도 됩니다.</target>
        </trans-unit>
        <trans-unit id="b2ec8a66f406e3cd9a737fd2597d771efa24775d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s usually much more common that you merge with somebody else than merging with your own branches, so it&amp;rsquo;s worth pointing out that Git makes that very easy too, and in fact, it&amp;rsquo;s not that different from doing a &lt;code&gt;git merge&lt;/code&gt;. In fact, a remote merge ends up being nothing more than &quot;fetch the work from a remote repository into a temporary tag&quot; followed by a &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">일반적으로 자신의 브랜치와 병합하는 것 이외의 다른 사람과 병합하는 것이 훨씬 일반적이므로 Git을 사용하면 매우 쉽게 수행 할 수 있으며 실제로 &lt;code&gt;git merge&lt;/code&gt; 를 수행하는 것과 크게 다르지 않습니다 . 실제로, 원격 병합은 &quot;원격 저장소에서 작업을 임시 태그로 가져 오기&quot;다음에 &lt;code&gt;git merge&lt;/code&gt; 에 지나지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="09aeea995eee0f7341283401be15ea3abb990fd5" translate="yes" xml:space="preserve">
          <source>Iterate over all refs that match &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; and show them according to the given &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt;, after sorting them according to the given set of &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; is given, stop after showing that many refs. The interpolated values in &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; can optionally be quoted as string literals in the specified host language allowing their direct evaluation in that language.</source>
          <target state="translated">&lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 과 일치하는 모든 참조를 반복 하고 주어진 &lt;code&gt;&amp;lt;key&amp;gt;&lt;/code&gt; 세트에 따라 정렬 한 후 주어진 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 에 따라 표시합니다 . 경우 &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; 주어, 많은 심판을 표시 한 후 중지합니다. &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 의 보간 된 값 은 지정된 호스트 언어에서 문자열 리터럴로 선택적으로 인용하여 해당 언어로 직접 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddf6f030820afdde653bed6b6ae7f0e48144f06d" translate="yes" xml:space="preserve">
          <source>Join two or more development histories together</source>
          <target state="translated">둘 이상의 개발 히스토리에 참여</target>
        </trans-unit>
        <trans-unit id="045fff3a75d61e019edb089792c9fca9353d7073" translate="yes" xml:space="preserve">
          <source>Just as the filesystem &lt;code&gt;.&lt;/code&gt; (period) refers to the current directory, using a &lt;code&gt;.&lt;/code&gt; as a repository name in Git (a dot-repository) is a relative path and means your current repository.</source>
          <target state="translated">파일 시스템과 같습니다 &lt;code&gt;.&lt;/code&gt; (마침표)는를 사용하여 현재 디렉토리를 나타냅니다 &lt;code&gt;.&lt;/code&gt; Git의 저장소 이름으로 (점 저장소)는 상대 경로이며 현재 저장소를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="dec0baabf794bebc3957d3bc4ac6d462cd46c778" translate="yes" xml:space="preserve">
          <source>Just doing &lt;code&gt;git checkout-index&lt;/code&gt; does nothing. You probably meant &lt;code&gt;git checkout-index -a&lt;/code&gt;. And if you want to force it, you want &lt;code&gt;git checkout-index -f -a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git checkout-index&lt;/code&gt; 만하면 아무것도하지 않습니다. 아마도 &lt;code&gt;git checkout-index -a&lt;/code&gt; 을 의미했을 것입니다 . 그리고 그것을 강제하고 싶다면 &lt;code&gt;git checkout-index -f -a&lt;/code&gt; 원합니다 .</target>
        </trans-unit>
        <trans-unit id="4909a5e9d012cc77cb3f33966c75c24bd556a2c1" translate="yes" xml:space="preserve">
          <source>Just in case you are doing something exotic, it should be noted that all of the &amp;lt;commit&amp;gt; in the above description, except in the last two forms that use &quot;..&quot; notations, can be any &amp;lt;tree&amp;gt;.</source>
          <target state="translated">당신이 이국적인 것을하고있는 경우를 위해서, &quot;..&quot;표기법을 사용하는 마지막 두 형태를 제외하고는 위의 설명에서 모든 &amp;lt;commit&amp;gt;은 모든 &amp;lt;tree&amp;gt;가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4be9ee55a1cb0649bc08a5f7fcba1609e56fcabe" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;push&lt;/code&gt;, a batch sequence of one or more &lt;code&gt;import&lt;/code&gt; is terminated with a blank line. For each batch of &lt;code&gt;import&lt;/code&gt;, the remote helper should produce a fast-import stream terminated by a &lt;code&gt;done&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;push&lt;/code&gt; 와 마찬가지로 하나 이상의 &lt;code&gt;import&lt;/code&gt; 의 일괄 처리 시퀀스 는 빈 줄로 종료됩니다. 각 &lt;code&gt;import&lt;/code&gt; 배치에 대해 원격 헬퍼는 &lt;code&gt;done&lt;/code&gt; 명령으로 종료 된 빠른 가져 오기 스트림을 생성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="586f68de6dc69eba27bb1d4e9d9bb6d0f56b4317" translate="yes" xml:space="preserve">
          <source>Just make sure to disable line wrapping in the email client (GMail&amp;rsquo;s web interface will wrap lines no matter what, so you need to use a real IMAP client).</source>
          <target state="translated">이메일 클라이언트에서 줄 바꿈 기능을 비활성화하십시오 (Gmail의 웹 인터페이스는 내용에 상관없이 줄 바꿈하므로 실제 IMAP 클라이언트를 사용해야합니다).</target>
        </trans-unit>
        <trans-unit id="40ff32435dadcaf90c9ed938f5946c67e774e649" translate="yes" xml:space="preserve">
          <source>Just make sure to disable line wrapping in the email client (Gmail&amp;rsquo;s web interface will wrap lines no matter what, so you need to use a real IMAP client).</source>
          <target state="translated">이메일 클라이언트에서 줄 바꿈을 사용하지 않도록 설정하세요 (Gmail의 웹 인터페이스는 어떤 경우에도 줄 바꿈하므로 실제 IMAP 클라이언트를 사용해야합니다).</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="b97e8895c584b11a83b65d2dacb8c53b7178dd19" translate="yes" xml:space="preserve">
          <source>KMail</source>
          <target state="translated">KMail</target>
        </trans-unit>
        <trans-unit id="2341c447151da84825db8427aea972cadd7288d2" translate="yes" xml:space="preserve">
          <source>Keep a list of repositories you work with regularly:</source>
          <target state="translated">정기적으로 작업하는 리포지토리 목록을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="2367d7104c669108a5a4faee96aaf23e4129a768" translate="yes" xml:space="preserve">
          <source>Keep changes in working tree while discarding some previous commits</source>
          <target state="translated">이전 커밋을 삭제하면서 작업 트리의 변경 사항을 유지하십시오</target>
        </trans-unit>
        <trans-unit id="efc112fed108eb2af53bef134295307559c52881" translate="yes" xml:space="preserve">
          <source>Keep downloaded pack.</source>
          <target state="translated">다운로드 한 팩을 보관하십시오.</target>
        </trans-unit>
        <trans-unit id="9b356018df37cea79789cf69374ce84ecae93c35" translate="yes" xml:space="preserve">
          <source>Keep in mind that the &lt;code&gt;*&lt;/code&gt; (asterisk) wildcard of the local ref (right of the &lt;code&gt;:&lt;/code&gt;) &lt;strong&gt;must&lt;/strong&gt; be the farthest right path component; however the remote wildcard may be anywhere as long as it&amp;rsquo;s an independent path component (surrounded by &lt;code&gt;/&lt;/code&gt; or EOL). This type of configuration is not automatically created by &lt;code&gt;init&lt;/code&gt; and should be manually entered with a text-editor or using &lt;code&gt;git config&lt;/code&gt;.</source>
          <target state="translated">로컬 참조 의 &lt;code&gt;*&lt;/code&gt; (별표) 와일드 카드 ( &lt;code&gt;:&lt;/code&gt; 의 오른쪽 ) &lt;strong&gt;는&lt;/strong&gt; 가장 먼 경로 구성 요소 &lt;strong&gt;여야합니다&lt;/strong&gt; . 그러나 원격 와일드 카드는 독립 경로 구성 요소 ( &lt;code&gt;/&lt;/code&gt; 또는 EOL로 둘러 싸인) 인 경우 어디에나있을 수 있습니다 . 이 유형의 구성은 &lt;code&gt;init&lt;/code&gt; 에 의해 자동으로 작성되지 않으며 텍스트 편집기 또는 &lt;code&gt;git config&lt;/code&gt; 를 사용하여 수동으로 입력해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f28d8482458ad8eaca4da9ce6d9f18435a267b61" translate="yes" xml:space="preserve">
          <source>Keep repeating the process: compile the tree, test it, and depending on whether it is good or bad run &lt;code&gt;git bisect good&lt;/code&gt; or &lt;code&gt;git bisect bad&lt;/code&gt; to ask for the next commit that needs testing.</source>
          <target state="translated">프로세스를 계속 반복하십시오 : 트리를 컴파일하고 테스트 한 다음 테스트가 필요한 다음 커밋을 요청하기에 &lt;code&gt;git bisect good&lt;/code&gt; 또는 &lt;code&gt;git bisect bad&lt;/code&gt; 좋은지 나쁜지 에 따라 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="4faf21022722c230f52c5287ce302764467e820e" translate="yes" xml:space="preserve">
          <source>Keep the commits that do not change anything from its parents in the result.</source>
          <target state="translated">결과에서 부모로부터 아무것도 변경하지 않는 커밋을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="ea4937dada87f98e69877594a5bd03ebc5a4fc74" translate="yes" xml:space="preserve">
          <source>Keep the current index contents, and read the contents of the named tree-ish under the directory at &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt;. The command will refuse to overwrite entries that already existed in the original index file.</source>
          <target state="translated">현재 색인 컨텐츠를 유지하고 &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; 의 디렉토리에서 명명 된 tree-ish의 컨텐츠를 읽으십시오 . 명령은 원래 색인 파일에 이미 존재하는 항목을 겹쳐 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d737c66ea055bf55ed844d15e52460a96096a67f" translate="yes" xml:space="preserve">
          <source>Keep the version from your branch in the work tree, but leave the path in the conflicted state for the user to sort out.</source>
          <target state="translated">작업 트리에서 분기의 버전을 유지하되 경로를 충돌 상태로 유지하여 사용자가 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="f9e507eaf43dc998f773c565be5cccbd49c418b4" translate="yes" xml:space="preserve">
          <source>Keep the working tree locked after creation. This is the equivalent of &lt;code&gt;git worktree lock&lt;/code&gt; after &lt;code&gt;git worktree add&lt;/code&gt;, but without a race condition.</source>
          <target state="translated">생성 후 작업 트리를 잠근 상태로 유지하십시오. 이것은 &lt;code&gt;git worktree add&lt;/code&gt; 후 git worktree &lt;code&gt;git worktree lock&lt;/code&gt; 과 동일 하지만 경쟁 조건이 없습니다.</target>
        </trans-unit>
        <trans-unit id="95e57eb6304d53fb35eb7b893fc3d7458db2c90c" translate="yes" xml:space="preserve">
          <source>Keep the working tree locked after creation. This is the equivalent of &lt;code&gt;git worktree lock&lt;/code&gt; after &lt;code&gt;git worktree add&lt;/code&gt;, but without race condition.</source>
          <target state="translated">작성 후 작업 트리를 잠근 상태로 유지하십시오. 이것은 &lt;code&gt;git worktree add&lt;/code&gt; 후 git worktree &lt;code&gt;git worktree lock&lt;/code&gt; 과 동일 하지만 경쟁 조건이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b288ae9d082d21fcccb8cbea92de9e2fd90c35f9" translate="yes" xml:space="preserve">
          <source>Keep unreachable objects in loose form. This implies &lt;code&gt;--revs&lt;/code&gt;.</source>
          <target state="translated">손이 닿지 않는 물건은 느슨한 형태로 보관하십시오. 이것은 &lt;code&gt;--revs&lt;/code&gt; 를 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="5fef7648dce54325886b4bd2e05123b8e3f3ba8b" translate="yes" xml:space="preserve">
          <source>Keep working in your primary repository. Your changes include modifications of your own, patches you receive via e-mails, and merges resulting from pulling the &quot;public&quot; repositories of your &quot;project lead&quot; and possibly your &quot;sub-subsystem maintainers&quot;.</source>
          <target state="translated">기본 저장소에서 계속 작업하십시오. 변경 사항에는 자신의 수정 사항, 전자 메일을 통해받는 패치 및 &quot;프로젝트 리드&quot;의 &quot;공용&quot;리포지토리 및 &quot;하위 서브 시스템 유지 관리자&quot;를 가져 와서 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="ca6eb7beb12ef44a32102578e1d606b2be688242" translate="yes" xml:space="preserve">
          <source>Keep working in your primary repository. Your changes include modifications of your own, patches you receive via e-mails, and merges resulting from pulling the &quot;public&quot; repositories of your &quot;subsystem maintainers&quot;.</source>
          <target state="translated">기본 저장소에서 계속 작업하십시오. 변경 사항에는 자신의 수정 사항, 전자 메일을 통해받는 패치 및 &quot;하위 시스템 관리자&quot;의 &quot;공용&quot;리포지토리를 가져 와서 병합되는 내용이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="04e2360cc7b28c2ccb26642bb98ceb0fcbba2f5a" translate="yes" xml:space="preserve">
          <source>Keeping a patch series up to date using git rebase</source>
          <target state="translated">git rebase를 사용하여 패치 시리즈를 최신 상태로 유지</target>
        </trans-unit>
        <trans-unit id="b81b785228a23fa6b75a5abffb474819b40a8136" translate="yes" xml:space="preserve">
          <source>Kill keywords: will extract files with &lt;code&gt;-kk&lt;/code&gt; from the CVS archive to avoid noisy changesets. Highly recommended, but off by default to preserve compatibility with early imported trees.</source>
          <target state="translated">키워드 삭제 : 노이즈가 많은 변경 세트를 피하기 위해 CVS 아카이브에서 &lt;code&gt;-kk&lt;/code&gt; 를 사용하여 파일을 추출합니다 . 초기 가져 오기 트리와의 호환성을 유지하려면 강력히 권장하지만 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="02658e782a0ecc008f0ca6ffc2a20f7bdbee96d7" translate="yes" xml:space="preserve">
          <source>Label for the &quot;home link&quot; at the top of all pages, leading to &lt;code&gt;$home_link&lt;/code&gt; (usually the main gitweb page, which contains the projects list). It is used as the first component of gitweb&amp;rsquo;s &quot;breadcrumb trail&quot;: &lt;code&gt;&amp;lt;home link&amp;gt; / &amp;lt;project&amp;gt; / &amp;lt;action&amp;gt;&lt;/code&gt;. Can be set at build time using the &lt;code&gt;GITWEB_HOME_LINK_STR&lt;/code&gt; variable. By default it is set to &quot;projects&quot;, as this link leads to the list of projects. Another popular choice is to set it to the name of site. Note that it is treated as raw HTML so it should not be set from untrusted sources.</source>
          <target state="translated">모든 페이지의 상단에있는 &quot;홈 링크&quot;에 대한 레이블로 &lt;code&gt;$home_link&lt;/code&gt; (일반적으로 프로젝트 목록을 포함하는 기본 gitweb 페이지)로 연결됩니다. gitweb의 &quot;breadcrumb trail&quot;의 첫 번째 구성 요소로 사용됩니다 : &lt;code&gt;&amp;lt;home link&amp;gt; / &amp;lt;project&amp;gt; / &amp;lt;action&amp;gt;&lt;/code&gt; . 빌드시 &lt;code&gt;GITWEB_HOME_LINK_STR&lt;/code&gt; 변수를 사용하여 설정할 수 있습니다 . 이 링크는 프로젝트 목록으로 연결되므로 기본적으로 &quot;프로젝트&quot;로 설정됩니다. 또 다른 인기있는 선택은 사이트 이름으로 설정하는 것입니다. 원시 HTML로 취급되므로 신뢰할 수없는 소스에서 설정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f135ec40c7a65e232b6284c7eadaae14bc4ec8e7" translate="yes" xml:space="preserve">
          <source>Labelling of conflicts markers</source>
          <target state="translated">충돌 마커의 라벨링</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
