<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="a1528f0aff1e31c1f36c8998ca335269e9595dd6" translate="yes" xml:space="preserve">
          <source>Prepend &amp;lt;root&amp;gt; to all filenames. If a &quot;-p&quot; argument was also passed, it is applied before prepending the new root.</source>
          <target state="translated">모든 파일 이름 앞에 &amp;lt;root&amp;gt;를 추가하십시오. &quot;-p&quot;인수도 전달 된 경우 새 루트 앞에 추가하기 전에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="04fbe49467d421955780154f308daccbf9dcf57a" translate="yes" xml:space="preserve">
          <source>Prepend &lt;code&gt;path&lt;/code&gt; to requested CVSROOT</source>
          <target state="translated">요청 된 CVSROOT의 &lt;code&gt;path&lt;/code&gt; 추가</target>
        </trans-unit>
        <trans-unit id="0347b26685846c1b1d2b4efcd87239056762e453" translate="yes" xml:space="preserve">
          <source>Prepend an additional prefix to every line of output.</source>
          <target state="translated">모든 출력 줄 앞에 추가 접두사를 붙입니다.</target>
        </trans-unit>
        <trans-unit id="965630002ec8181b6c5811ecd432fedf5278178d" translate="yes" xml:space="preserve">
          <source>Prepend comment character and blank to each line. Lines will automatically be terminated with a newline. On empty lines, only the comment character will be prepended.</source>
          <target state="translated">주석 문자를 추가하고 각 행을 비워 두십시오. 줄은 개행으로 자동 종료됩니다. 빈 줄에는 주석 문자 만 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="f16c17f5481a4b7eaab0eba6f32fe3b9bdb77e0a" translate="yes" xml:space="preserve">
          <source>Prepend the commit message with the provided prefix. Useful for patch series and the like.</source>
          <target state="translated">제공된 접두사로 커밋 메시지 앞에 추가하십시오. 패치 시리즈 등에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1cb847e80ec2973659a3bc43c24ba721cccfc0b9" translate="yes" xml:space="preserve">
          <source>Pretend as if all objects mentioned as ref tips of alternate repositories were listed on the command line. An alternate repository is any repository whose object directory is specified in &lt;code&gt;objects/info/alternates&lt;/code&gt;. The set of included objects may be modified by &lt;code&gt;core.alternateRefsCommand&lt;/code&gt;, etc. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">대체 저장소의 참조 팁으로 언급 된 모든 오브젝트가 명령 행에 나열된 것처럼 가장하십시오. 대체 저장소는 오브젝트 디렉토리가 &lt;code&gt;objects/info/alternates&lt;/code&gt; 에 지정된 저장소입니다 . 포함 된 객체 세트는 &lt;code&gt;core.alternateRefsCommand&lt;/code&gt; 등에 의해 수정 될 수 있습니다 . &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8790db7464ad43dc2580493a3a2b7fe9009b3b8" translate="yes" xml:space="preserve">
          <source>Pretend as if all objects mentioned by reflogs are listed on the command line as &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">reflogs에서 언급 한 모든 객체가 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 로 명령 행에 나열되는 것처럼 가장 합니다.</target>
        </trans-unit>
        <trans-unit id="1bc40db9cd0077507e159c30d2cc8ff273e4cf52" translate="yes" xml:space="preserve">
          <source>Pretend as if all the branches (tags, remote branches, resp.) are listed on the command line as &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; is given, limit refs to ones matching given shell glob. If pattern lacks &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;/*&lt;/code&gt; at the end is implied.</source>
          <target state="translated">모든 분기 (태그, 원격 분기 등)가 명령 줄에 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 으로 표시되는 것처럼 가장 합니다. 경우 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 주어, 사람에 제한 심판은 쉘 글로브를 부여 매칭. 패턴이 없으면 &lt;code&gt;?&lt;/code&gt; 끝에 , &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;[&lt;/code&gt; , &lt;code&gt;/*&lt;/code&gt; 가 내포되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a40d3b9ce3a70471c04394220cc5bbfab2baa7f5" translate="yes" xml:space="preserve">
          <source>Pretend as if all the refs in &lt;code&gt;refs/&lt;/code&gt;, along with &lt;code&gt;HEAD&lt;/code&gt;, are listed on the command line as &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;refs/&lt;/code&gt; 모든 참조 가 &lt;code&gt;HEAD&lt;/code&gt; 와 함께 명령 행에 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 로 표시되는 것처럼 가장하십시오 .</target>
        </trans-unit>
        <trans-unit id="1435ebeededb24db5ecef4374cafc152c655d0c5" translate="yes" xml:space="preserve">
          <source>Pretend as if all the refs in &lt;code&gt;refs/heads&lt;/code&gt; are listed on the command line as &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; is given, limit branches to ones matching given shell glob. If pattern lacks &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;/*&lt;/code&gt; at the end is implied.</source>
          <target state="translated">&lt;code&gt;refs/heads&lt;/code&gt; 모든 심판이 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 로 명령 행에 나열되는 것처럼 가장 합니다. 경우 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 주어, 사람에 제한 분기 쉘 글로브를 부여 매칭. 패턴이 없으면 &lt;code&gt;?&lt;/code&gt; 끝에 , &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;[&lt;/code&gt; , &lt;code&gt;/*&lt;/code&gt; 가 내포되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="873bc395593997376453ce378c315180f9e8037d" translate="yes" xml:space="preserve">
          <source>Pretend as if all the refs in &lt;code&gt;refs/remotes&lt;/code&gt; are listed on the command line as &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; is given, limit remote-tracking branches to ones matching given shell glob. If pattern lacks &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;/*&lt;/code&gt; at the end is implied.</source>
          <target state="translated">&lt;code&gt;refs/remotes&lt;/code&gt; 모든 심판이 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 로 명령 행에 나열되는 것처럼 가장 합니다. 경우 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 주어, 한계는 주어진 쉘 글롭 일치 것과 분기 원격 추적. 패턴이 없으면 &lt;code&gt;?&lt;/code&gt; 끝에 , &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;[&lt;/code&gt; , &lt;code&gt;/*&lt;/code&gt; 가 내포되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="779811bec709e50bc3c2986dda8163a1984c59e0" translate="yes" xml:space="preserve">
          <source>Pretend as if all the refs in &lt;code&gt;refs/tags&lt;/code&gt; are listed on the command line as &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; is given, limit tags to ones matching given shell glob. If pattern lacks &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;/*&lt;/code&gt; at the end is implied.</source>
          <target state="translated">&lt;code&gt;refs/tags&lt;/code&gt; 모든 심판이 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 로 명령 행에 나열되는 것처럼 가장 합니다. 경우 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 주어, 사람에 한계 태그는 쉘 글로브를 부여 매칭. 패턴이 없으면 &lt;code&gt;?&lt;/code&gt; 끝에 , &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;[&lt;/code&gt; , &lt;code&gt;/*&lt;/code&gt; 가 내포되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd8bdbdeb72b98a3e7d8a71774e4228e25fd4361" translate="yes" xml:space="preserve">
          <source>Pretend as if all the refs matching shell glob &lt;code&gt;&amp;lt;glob-pattern&amp;gt;&lt;/code&gt; are listed on the command line as &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;. Leading &lt;code&gt;refs/&lt;/code&gt;, is automatically prepended if missing. If pattern lacks &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;/*&lt;/code&gt; at the end is implied.</source>
          <target state="translated">쉘 glob &lt;code&gt;&amp;lt;glob-pattern&amp;gt;&lt;/code&gt; 과 일치하는 모든 참조가 명령 행에 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 으로 나열되는 것처럼 가장하십시오 . 선행 &lt;code&gt;refs/&lt;/code&gt; 는 누락 된 경우 자동으로 추가됩니다. 패턴이 없으면 &lt;code&gt;?&lt;/code&gt; 끝에 , &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;[&lt;/code&gt; , &lt;code&gt;/*&lt;/code&gt; 가 내포되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="46b1cc7966c168f121c45715956556d8413ae7ad" translate="yes" xml:space="preserve">
          <source>Pretend as if all trees and blobs used by the index are listed on the command line. Note that you probably want to use &lt;code&gt;--objects&lt;/code&gt;, too.</source>
          <target state="translated">색인에 사용 된 모든 트리 및 블롭이 명령 줄에 나열된 것처럼 가장합니다. &lt;code&gt;--objects&lt;/code&gt; 도 사용하고 싶을 것입니다 .</target>
        </trans-unit>
        <trans-unit id="909e45224d87696c85b1407d2ca55f9401b9de95" translate="yes" xml:space="preserve">
          <source>Pretend as if the bad bisection ref &lt;code&gt;refs/bisect/bad&lt;/code&gt; was listed and as if it was followed by &lt;code&gt;--not&lt;/code&gt; and the good bisection refs &lt;code&gt;refs/bisect/good-*&lt;/code&gt; on the command line.</source>
          <target state="translated">잘못된 이분법 &lt;code&gt;refs/bisect/bad&lt;/code&gt; 가 나열되고 명령 줄에서 &lt;code&gt;--not&lt;/code&gt; 이 뒤 따르고 좋은 이분법 refs &lt;code&gt;refs/bisect/good-*&lt;/code&gt; 가있는 것처럼 가장 합니다.</target>
        </trans-unit>
        <trans-unit id="cc70d02297620c66f8bef755f564908a1a4698d8" translate="yes" xml:space="preserve">
          <source>Pretend as if the bad bisection ref &lt;code&gt;refs/bisect/bad&lt;/code&gt; was listed and as if it was followed by &lt;code&gt;--not&lt;/code&gt; and the good bisection refs &lt;code&gt;refs/bisect/good-*&lt;/code&gt; on the command line. Cannot be combined with --first-parent.</source>
          <target state="translated">불량 이등분 참조 참조 &lt;code&gt;refs/bisect/bad&lt;/code&gt; 가 나열된 것처럼 보이고 &lt;code&gt;--not&lt;/code&gt; 다음에 이등분 섹션 참조 가 명령 줄에 &lt;code&gt;refs/bisect/good-*&lt;/code&gt; 로 표시됩니다. --first-parent와 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0a3604cb0b2f73cd8456355c098a4f83f14d6060" translate="yes" xml:space="preserve">
          <source>Pretty formats</source>
          <target state="translated">예쁜 형식</target>
        </trans-unit>
        <trans-unit id="1b76ed128a23a5286f4a7e2538cc00e5737e0416" translate="yes" xml:space="preserve">
          <source>Pretty-print the contents of &amp;lt;object&amp;gt; based on its type.</source>
          <target state="translated">유형에 따라 &amp;lt;object&amp;gt;의 내용을 예쁘게 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="a741501b13f29bc4f4975a183857a345cfe33bda" translate="yes" xml:space="preserve">
          <source>Pretty-print the contents of the commit logs in a given format, where &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; can be one of &lt;code&gt;oneline&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt;, &lt;code&gt;full&lt;/code&gt;, &lt;code&gt;fuller&lt;/code&gt;, &lt;code&gt;reference&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt;, &lt;code&gt;raw&lt;/code&gt;, &lt;code&gt;format:&amp;lt;string&amp;gt;&lt;/code&gt; and &lt;code&gt;tformat:&amp;lt;string&amp;gt;&lt;/code&gt;. When &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; is none of the above, and has &lt;code&gt;%placeholder&lt;/code&gt; in it, it acts as if &lt;code&gt;--pretty=tformat:&amp;lt;format&amp;gt;&lt;/code&gt; were given.</source>
          <target state="translated">커밋 로그의 내용을 주어진 형식으로 잘 인쇄하십시오. 여기서 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 은 &lt;code&gt;oneline&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;medium&lt;/code&gt; , &lt;code&gt;full&lt;/code&gt; , &lt;code&gt;fuller&lt;/code&gt; , &lt;code&gt;reference&lt;/code&gt; , &lt;code&gt;email&lt;/code&gt; , &lt;code&gt;raw&lt;/code&gt; , &lt;code&gt;format:&amp;lt;string&amp;gt;&lt;/code&gt; 및 &lt;code&gt;tformat:&amp;lt;string&amp;gt;&lt;/code&gt; 중 하나 일 수 있습니다. 경우 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 상기 전혀없고, 보유 &lt;code&gt;%placeholder&lt;/code&gt; 는 것처럼 작용, 그것에 &lt;code&gt;--pretty=tformat:&amp;lt;format&amp;gt;&lt;/code&gt; 받았다.</target>
        </trans-unit>
        <trans-unit id="7bd89feebefa381d47a4005ee3e7a70495146fc2" translate="yes" xml:space="preserve">
          <source>Print a list of diff tools that may be used with &lt;code&gt;--tool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--tool&lt;/code&gt; 과 함께 사용할 수있는 diff 도구 목록을 인쇄하십시오 .</target>
        </trans-unit>
        <trans-unit id="4427ae28c9b6c7b34bdd7b24aed9e7c7d30f57b8" translate="yes" xml:space="preserve">
          <source>Print a list of merge tools that may be used with &lt;code&gt;--tool&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--tool&lt;/code&gt; 과 함께 사용할 수있는 병합 도구 목록을 인쇄하십시오 .</target>
        </trans-unit>
        <trans-unit id="66756bdfb6c604999780ed06815c6e483a2bcdd8" translate="yes" xml:space="preserve">
          <source>Print a log message describing a merge of the &quot;master&quot; branch from the &quot;origin&quot; remote.</source>
          <target state="translated">&quot;원점&quot;리모트에서 &quot;마스터&quot;분기의 병합을 설명하는 로그 메시지를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="e170a2249107ead5e4f805939d3f7ece45fff682" translate="yes" xml:space="preserve">
          <source>Print a message to the terminal whenever Git is waiting for editor input from the user.</source>
          <target state="translated">Git이 사용자의 편집기 입력을 기다릴 때마다 터미널에 메시지를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="8080962c8d32b2cabab8eb19868e6e497af4f4fb" translate="yes" xml:space="preserve">
          <source>Print a number stating how many commits would have been listed, and suppress all other output. When used together with &lt;code&gt;--left-right&lt;/code&gt;, instead print the counts for left and right commits, separated by a tab. When used together with &lt;code&gt;--cherry-mark&lt;/code&gt;, omit patch equivalent commits from these counts and print the count for equivalent commits separated by a tab.</source>
          <target state="translated">나열된 커밋 수를 나타내는 숫자를 인쇄하고 다른 모든 출력을 억제하십시오. &lt;code&gt;--left-right&lt;/code&gt; 와 함께 사용하는 경우 대신 왼쪽과 오른쪽 커밋의 수를 탭으로 구분하여 인쇄하십시오. &lt;code&gt;--cherry-mark&lt;/code&gt; 와 함께 사용하면 이러한 카운트에서 패치 동등한 커밋을 생략하고 탭으로 구분 된 동등한 커밋에 대한 카운트를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="5c8fe4e870e195a4e0e71c8a37d1ceb1bdba9faa" translate="yes" xml:space="preserve">
          <source>Print a short usage message and exit.</source>
          <target state="translated">간단한 사용법 메시지를 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="1605c83b597410df01a57b6af3b5c08c7935c987" translate="yes" xml:space="preserve">
          <source>Print all commits to the standard output in mbox format, instead of creating a file for each one.</source>
          <target state="translated">각각에 대한 파일을 작성하는 대신 표준 출력에 대한 모든 커밋을 mbox 형식으로 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="bb80930a87afbf3e0cd1b6dbc46ac66a79700ef9" translate="yes" xml:space="preserve">
          <source>Print also the children of the commit (in the form &quot;commit child&amp;hellip;​&quot;). Also enables parent rewriting, see &lt;code&gt;History Simplification&lt;/code&gt; above.</source>
          <target state="translated">커밋의 자식도 인쇄합니다 ( &quot;커밋 자식&amp;hellip;&quot;형식으로). 부모 재 작성도 가능 합니다. 위의 &lt;code&gt;History Simplification&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd486c8f7fa4f0862a9438df255d9ef58e4cce2f" translate="yes" xml:space="preserve">
          <source>Print also the parents of the commit (in the form &quot;commit parent&amp;hellip;​&quot;). Also enables parent rewriting, see &lt;code&gt;History Simplification&lt;/code&gt; above.</source>
          <target state="translated">커밋의 부모도 인쇄하십시오 ( &quot;commit parent ...&quot;형식). 부모 재 작성도 가능 합니다. 위의 &lt;code&gt;History Simplification&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f770a9ba11cec50c667f92df6a9581699d1c849f" translate="yes" xml:space="preserve">
          <source>Print an empty line between matches from different files.</source>
          <target state="translated">다른 파일에서 일치하는 항목 사이에 빈 줄을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="dc6bbcf836701f45b1b031bc09ccba6ceff978b1" translate="yes" xml:space="preserve">
          <source>Print extra information on screen.</source>
          <target state="translated">화면에 추가 정보를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="f77fc6854808124fa4634165848ea2138881c54f" translate="yes" xml:space="preserve">
          <source>Print lines matching a pattern</source>
          <target state="translated">패턴과 일치하는 선 인쇄</target>
        </trans-unit>
        <trans-unit id="6fe4856d75dfab579fe9349a68cc2bed1d0dadcc" translate="yes" xml:space="preserve">
          <source>Print object information and contents for each object provided on stdin. May not be combined with any other options or arguments except &lt;code&gt;--textconv&lt;/code&gt; or &lt;code&gt;--filters&lt;/code&gt;, in which case the input lines also need to specify the path, separated by whitespace. See the section &lt;code&gt;BATCH OUTPUT&lt;/code&gt; below for details.</source>
          <target state="translated">stdin에 제공된 각 오브젝트에 대한 오브젝트 정보 및 내용을 인쇄하십시오. &lt;code&gt;--textconv&lt;/code&gt; 또는 &lt;code&gt;--filters&lt;/code&gt; 를 제외한 다른 옵션 또는 인수와 함께 사용할 수 없습니다 .이 경우 입력 행도 공백으로 구분하여 경로를 지정해야합니다. 자세한 내용은 아래의 &lt;code&gt;BATCH OUTPUT&lt;/code&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca4d7c5adc217a6aa2342c6778492ad7113796ff" translate="yes" xml:space="preserve">
          <source>Print object information for each object provided on stdin. May not be combined with any other options or arguments except &lt;code&gt;--textconv&lt;/code&gt; or &lt;code&gt;--filters&lt;/code&gt;, in which case the input lines also need to specify the path, separated by whitespace. See the section &lt;code&gt;BATCH OUTPUT&lt;/code&gt; below for details.</source>
          <target state="translated">stdin에 제공된 각 오브젝트에 대한 오브젝트 정보를 인쇄하십시오. &lt;code&gt;--textconv&lt;/code&gt; 또는 &lt;code&gt;--filters&lt;/code&gt; 를 제외한 다른 옵션 또는 인수와 함께 사용할 수 없습니다 .이 경우 입력 행도 공백으로 구분하여 경로를 지정해야합니다. 자세한 내용은 아래의 &lt;code&gt;BATCH OUTPUT&lt;/code&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="355c9197a67577b10c87d266b1fadda4f338ce43" translate="yes" xml:space="preserve">
          <source>Print objects that exist but that are never &lt;code&gt;directly&lt;/code&gt; used (default). &lt;code&gt;--no-dangling&lt;/code&gt; can be used to omit this information from the output.</source>
          <target state="translated">존재하지만 &lt;code&gt;directly&lt;/code&gt; 사용 되지 않은 개체를 인쇄합니다 (기본값). &lt;code&gt;--no-dangling&lt;/code&gt; 을 사용하여 출력에서이 정보를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b45348ee53d58a25f5424ead463a255068c26a3" translate="yes" xml:space="preserve">
          <source>Print only merge commits. This is exactly the same as &lt;code&gt;--min-parents=2&lt;/code&gt;.</source>
          <target state="translated">병합 커밋 만 인쇄합니다. 이것은 &lt;code&gt;--min-parents=2&lt;/code&gt; 와 정확히 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="fba7bfcdde0d986db48ca498619d9372ecc7d2c2" translate="yes" xml:space="preserve">
          <source>Print only the matched (non-empty) parts of a matching line, with each such part on a separate output line.</source>
          <target state="translated">일치하는 줄의 일치하는 (비어 있지 않은) 부분 만 인쇄하고 각 부분은 별도의 출력 줄에 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="a0fc3f1d0d97da65e736eae410fad9ae12d5c7be" translate="yes" xml:space="preserve">
          <source>Print out objects that exist but that aren&amp;rsquo;t reachable from any of the reference nodes.</source>
          <target state="translated">존재하지만 참조 노드에서 도달 할 수없는 객체를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="e099bc42258fcb131e0b9e1b48df8c89349bb7b8" translate="yes" xml:space="preserve">
          <source>Print out the ref name given on the command line by which each commit was reached.</source>
          <target state="translated">각 커밋에 도달 한 명령 줄에 지정된 참조 이름을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="dcb3dcb3ba78d15754773caa5f744c3c4effdf42" translate="yes" xml:space="preserve">
          <source>Print out the ref names of any commits that are shown by the log command. If &lt;code&gt;short&lt;/code&gt; is specified, the ref name prefixes &lt;code&gt;refs/heads/&lt;/code&gt;, &lt;code&gt;refs/tags/&lt;/code&gt; and &lt;code&gt;refs/remotes/&lt;/code&gt; will not be printed. If &lt;code&gt;full&lt;/code&gt; is specified, the full ref name (including prefix) will be printed. If &lt;code&gt;auto&lt;/code&gt; is specified, then if the output is going to a terminal, the ref names are shown as if &lt;code&gt;short&lt;/code&gt; were given, otherwise no ref names are shown. This is the same as the &lt;code&gt;--decorate&lt;/code&gt; option of the &lt;code&gt;git log&lt;/code&gt;.</source>
          <target state="translated">log 명령으로 표시되는 커밋의 참조 이름을 인쇄하십시오. 경우 &lt;code&gt;short&lt;/code&gt; 지정되어, 심판의 이름은 접두사 &lt;code&gt;refs/heads/&lt;/code&gt; , &lt;code&gt;refs/tags/&lt;/code&gt; 및 &lt;code&gt;refs/remotes/&lt;/code&gt; 인쇄되지 않습니다. 경우 &lt;code&gt;full&lt;/code&gt; 지정됩니다 (접두사 포함) 전체 심판 이름이 인쇄됩니다. 경우 &lt;code&gt;auto&lt;/code&gt; 지정된 출력 단자에가는 경우처럼, 다음의 REF 이름은 도시되지 않은 &lt;code&gt;short&lt;/code&gt; 주어진 그렇지 REF 이름을 나타낸다 더. 이것은 &lt;code&gt;git log&lt;/code&gt; 의 &lt;code&gt;--decorate&lt;/code&gt; 옵션과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="53ce43f1821ebff917f188f20f204c3e06f211d4" translate="yes" xml:space="preserve">
          <source>Print out the ref names of any commits that are shown. If &lt;code&gt;short&lt;/code&gt; is specified, the ref name prefixes &lt;code&gt;refs/heads/&lt;/code&gt;, &lt;code&gt;refs/tags/&lt;/code&gt; and &lt;code&gt;refs/remotes/&lt;/code&gt; will not be printed. If &lt;code&gt;full&lt;/code&gt; is specified, the full ref name (including prefix) will be printed. If &lt;code&gt;auto&lt;/code&gt; is specified, then if the output is going to a terminal, the ref names are shown as if &lt;code&gt;short&lt;/code&gt; were given, otherwise no ref names are shown. The default option is &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">표시된 커밋의 참조 이름을 인쇄하십시오. 경우 &lt;code&gt;short&lt;/code&gt; 지정되어, 심판의 이름은 접두사 &lt;code&gt;refs/heads/&lt;/code&gt; , &lt;code&gt;refs/tags/&lt;/code&gt; 및 &lt;code&gt;refs/remotes/&lt;/code&gt; 인쇄되지 않습니다. 경우 &lt;code&gt;full&lt;/code&gt; 지정됩니다 (접두사 포함) 전체 심판 이름이 인쇄됩니다. 경우 &lt;code&gt;auto&lt;/code&gt; 지정된 출력 단자에가는 경우처럼, 다음의 REF 이름은 도시되지 않은 &lt;code&gt;short&lt;/code&gt; 주어진 그렇지 REF 이름을 나타낸다 더. 기본 옵션은 &lt;code&gt;short&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2011b0d7f946e8a76de0461151323ce8a5c0f935" translate="yes" xml:space="preserve">
          <source>Print paths with conflicts that have not been autoresolved by rerere. This includes paths whose resolutions cannot be tracked by rerere, such as conflicting submodules.</source>
          <target state="translated">rerere로 자동 해결되지 않은 충돌이있는 경로를 인쇄하십시오. 여기에는 충돌하는 서브 모듈과 같이 해상도를 다시 추적 할 수없는 경로가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2cba919653a32310570084639bfa9ccc09fb9fa2" translate="yes" xml:space="preserve">
          <source>Print paths with conflicts whose merge resolution rerere will record.</source>
          <target state="translated">병합 해상도가 다시 기록되는 충돌이있는 경로를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="71b60883716e5c9ed5e8d89999bad00a8a7a60a2" translate="yes" xml:space="preserve">
          <source>Print sizes in human readable format</source>
          <target state="translated">사람이 읽을 수있는 형식으로 인쇄 크기</target>
        </trans-unit>
        <trans-unit id="7acdcc1d8a4a904a279ce2f15ace2f46f09a0e30" translate="yes" xml:space="preserve">
          <source>Print the commit object name from the revision in the $REV shell variable:</source>
          <target state="translated">$ REV 쉘 변수의 개정판에서 커미트 오브젝트 이름을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="395b30ff424b495b247b1df9486e5529542c8ab4" translate="yes" xml:space="preserve">
          <source>Print the contents of the commit in raw-format; each record is separated with a NUL character.</source>
          <target state="translated">커밋 내용을 원시 형식으로 인쇄하십시오. 각 레코드는 NUL 문자로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="a77cbdea967e7bc1835e082ef3a9add5606ab710" translate="yes" xml:space="preserve">
          <source>Print the contents of the commit object before validating it.</source>
          <target state="translated">확약하기 전에 확약 오브젝트의 내용을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="31d513cdd4715b4e34b1efb48c41837ed2726bf9" translate="yes" xml:space="preserve">
          <source>Print the contents of the tag object before validating it.</source>
          <target state="translated">태그 객체의 내용을 인쇄하기 전에 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="87753483ea6cbbd041325490c8537b3b3cada35c" translate="yes" xml:space="preserve">
          <source>Print the current notes ref. This provides an easy way to retrieve the current notes ref (e.g. from scripts).</source>
          <target state="translated">현재 메모를 인쇄합니다. 이를 통해 현재 메모 참조를 쉽게 검색 할 수 있습니다 (예 : 스크립트).</target>
        </trans-unit>
        <trans-unit id="e336397774a866fc04e04e67418c962536311ce3" translate="yes" xml:space="preserve">
          <source>Print the manpath (see &lt;code&gt;man(1)&lt;/code&gt;) for the man pages for this version of Git and exit.</source>
          <target state="translated">이 버전의 Git에 대한 매뉴얼 페이지에 대한 manpath ( &lt;code&gt;man(1)&lt;/code&gt; 참조)를 인쇄 하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="390fcf6665394474a4208236397a723ae5bbd841" translate="yes" xml:space="preserve">
          <source>Print the name of the current branch. In detached HEAD state, nothing is printed.</source>
          <target state="translated">현재 지점의 이름을 인쇄하십시오. 분리 된 HEAD 상태에서는 아무 것도 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="727d2c972108087f617ca9a52e1404312cb08db7" translate="yes" xml:space="preserve">
          <source>Print the name of the previous thing checked out:</source>
          <target state="translated">체크 아웃 한 이전 항목의 이름을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="3642aa2b7cf9b2dae48578e1bdc6f3fea172cd09" translate="yes" xml:space="preserve">
          <source>Print the object IDs of any object referenced by the listed commits. &lt;code&gt;--objects foo ^bar&lt;/code&gt; thus means &amp;ldquo;send me all object IDs which I need to download if I have the commit object &lt;code&gt;bar&lt;/code&gt; but not &lt;code&gt;foo&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">나열된 커밋이 참조하는 객체의 객체 ID를 인쇄하십시오. &lt;code&gt;--objects foo ^bar&lt;/code&gt; 는&amp;ldquo;커밋 객체 &lt;code&gt;bar&lt;/code&gt; 있지만 &lt;code&gt;foo&lt;/code&gt; 가 아닌 경우 다운로드해야하는 모든 객체 ID를 보내십시오&amp;rdquo;를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="38fa474c9535276a4f6e33490b7ff8dcbbdc81f4" translate="yes" xml:space="preserve">
          <source>Print the object name of the current commit:</source>
          <target state="translated">현재 커밋의 객체 이름을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="ee021a7e92899d06aae374f43dcf779c8609f3ff" translate="yes" xml:space="preserve">
          <source>Print the path where the Info files documenting this version of Git are installed and exit.</source>
          <target state="translated">이 버전의 Git을 문서화하는 Info 파일이 설치된 경로를 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="f91d6d93e8468421a09b4a14a734bbd616d1eaec" translate="yes" xml:space="preserve">
          <source>Print the path, without trailing slash, where Git&amp;rsquo;s HTML documentation is installed and exit.</source>
          <target state="translated">Git의 HTML 문서가 설치된 슬래시없이 경로를 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="c416409aca85a3200dcaeb96638cdf0bb7fd9f1e" translate="yes" xml:space="preserve">
          <source>Print the raw commit timestamp.</source>
          <target state="translated">원시 커밋 타임 스탬프를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="a639de23ccd7b17d5228ed28b0950d8dd10397fd" translate="yes" xml:space="preserve">
          <source>Print the raw gpg status output to standard error instead of the normal human-readable output.</source>
          <target state="translated">사람이 읽을 수있는 정상적인 출력 대신 원시 gpg 상태 출력을 표준 오류로 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="99ac22b00f0c79de0ff529dde835b6047cf02100" translate="yes" xml:space="preserve">
          <source>Print tree and blob ids in order of the commits. The tree and blob ids are printed after they are first referenced by a commit.</source>
          <target state="translated">커밋 순서대로 트리 및 BLOB ID를 인쇄하십시오. 트리 및 BLOB ID는 커밋에서 처음 참조한 후에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="3b22396fd69e4727d40157cf2f987d6e09d1fcff" translate="yes" xml:space="preserve">
          <source>Print usage information and exit</source>
          <target state="translated">사용 정보를 인쇄하고 종료</target>
        </trans-unit>
        <trans-unit id="8b0271d848c59df8398c3108bdeba41e38e8636a" translate="yes" xml:space="preserve">
          <source>Print version information and exit</source>
          <target state="translated">버전 정보 인쇄 및 종료</target>
        </trans-unit>
        <trans-unit id="85ec1b3fb97897b6ced8a489e132839db30e011a" translate="yes" xml:space="preserve">
          <source>Prints a Git logical variable.</source>
          <target state="translated">Git 논리 변수를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="913b5e2d55fda904bfce1ecac182bc7aaa60acd0" translate="yes" xml:space="preserve">
          <source>Prints a list of the Git concept guides on the standard output. This option overrides any given command or guide name.</source>
          <target state="translated">표준 출력에 Git 개념 가이드 목록을 인쇄합니다. 이 옵션은 주어진 명령 또는 가이드 이름을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="401d02aaba20f08ba2e39483d254996af7aae137" translate="yes" xml:space="preserve">
          <source>Prints a list of useful guides on the standard output. This option overrides any given command or guide name.</source>
          <target state="translated">표준 출력에 대한 유용한 안내서 목록을 인쇄합니다. 이 옵션은 지정된 명령 또는 안내서 이름을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="fb51737d6bf1a9b6afa9ffc69b82cbde8918bef7" translate="yes" xml:space="preserve">
          <source>Prints all the available commands on the standard output. This option overrides any given command or guide name.</source>
          <target state="translated">사용 가능한 모든 명령을 표준 출력에 인쇄합니다. 이 옵션은 지정된 명령 또는 안내서 이름을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="f5aac771b999435096d722ba3e59e6103d7d4c50" translate="yes" xml:space="preserve">
          <source>Prints information about the object at a path to a file descriptor previously arranged with the &lt;code&gt;--cat-blob-fd&lt;/code&gt; argument. This allows printing a blob from the active commit (with &lt;code&gt;cat-blob&lt;/code&gt;) or copying a blob or tree from a previous commit for use in the current one (with &lt;code&gt;filemodify&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;--cat-blob-fd&lt;/code&gt; 인수로 이전에 배열 된 파일 디스크립터의 경로에서 오브젝트에 대한 정보를 인쇄합니다 . 이를 통해 활성 커밋에서 얼룩을 인쇄하거나 ( &lt;code&gt;cat-blob&lt;/code&gt; 사용 ) 현재 커밋에서 사용하기 위해 이전 커밋에서 얼룩 또는 트리를 복사 할 수 있습니다 ( &lt;code&gt;filemodify&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="67f72d83deebf87ad84204db25d15bef66391fa1" translate="yes" xml:space="preserve">
          <source>Prints the Git suite version that the &lt;code&gt;git&lt;/code&gt; program came from.</source>
          <target state="translated">&lt;code&gt;git&lt;/code&gt; 프로그램 의 Git suite 버전을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="31cffb4ffe2a30a3dd8ff5b977f393cbba618dfd" translate="yes" xml:space="preserve">
          <source>Prints the synopsis and a list of the most commonly used commands. If the option &lt;code&gt;--all&lt;/code&gt; or &lt;code&gt;-a&lt;/code&gt; is given then all available commands are printed. If a Git command is named this option will bring up the manual page for that command.</source>
          <target state="translated">시놉시스와 가장 일반적으로 사용되는 명령 목록을 인쇄합니다. &lt;code&gt;--all&lt;/code&gt; 또는 &lt;code&gt;-a&lt;/code&gt; 옵션 이 제공 되면 사용 가능한 모든 명령이 인쇄됩니다. Git 명령의 이름이 지정되면이 옵션은 해당 명령에 대한 매뉴얼 페이지를 불러옵니다.</target>
        </trans-unit>
        <trans-unit id="866254572e1e21a744b0d521a136d91326c823cd" translate="yes" xml:space="preserve">
          <source>Problems related to branches:</source>
          <target state="translated">지점 관련 문제 :</target>
        </trans-unit>
        <trans-unit id="ca677c6e0873752e051f5b6dc5cfbc5f3713a96f" translate="yes" xml:space="preserve">
          <source>Problems related to tags:</source>
          <target state="translated">태그 관련 문제 :</target>
        </trans-unit>
        <trans-unit id="704eb4f9500e5abbbd40e21ecae0dbc6632f17d7" translate="yes" xml:space="preserve">
          <source>Problems related to timestamps:</source>
          <target state="translated">타임 스탬프 관련 문제 :</target>
        </trans-unit>
        <trans-unit id="face2a8f1265d0d2162b3bb8d6cc8c2e4f00bd1a" translate="yes" xml:space="preserve">
          <source>Problems with rewriting history</source>
          <target state="translated">기록 다시 작성 문제</target>
        </trans-unit>
        <trans-unit id="cb8ad1a0606d68ac22c37138a82e9dcd94bd7b47" translate="yes" xml:space="preserve">
          <source>Proceed even if the index or the working tree differs from &lt;code&gt;HEAD&lt;/code&gt;. Both the index and working tree are restored to match the switching target. If &lt;code&gt;--recurse-submodules&lt;/code&gt; is specified, submodule content is also restored to match the switching target. This is used to throw away local changes.</source>
          <target state="translated">색인 또는 작업 트리가 &lt;code&gt;HEAD&lt;/code&gt; 와 다른 경우에도 진행하십시오 . 인덱스와 작업 트리가 모두 전환 대상과 일치하도록 복원됩니다. 경우 &lt;code&gt;--recurse-submodules&lt;/code&gt; 지정된 서브 모듈 컨텐츠는 전환 대상과 일치하도록 복원된다. 로컬 변경 사항을 버리는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="81635a56ae860db0a8d1fccf460faed330395977" translate="yes" xml:space="preserve">
          <source>Process binary files as if they were text.</source>
          <target state="translated">바이너리 파일을 마치 텍스트처럼 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="c13073a8e5c76f53a6790b53a64799c267eda4e9" translate="yes" xml:space="preserve">
          <source>Process files in the order specified in the &amp;lt;orderfile&amp;gt;, which has one shell glob pattern per line. This overrides the &lt;code&gt;diff.orderFile&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). To cancel &lt;code&gt;diff.orderFile&lt;/code&gt;, use &lt;code&gt;-O/dev/null&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;orderfile&amp;gt;에 지정된 순서대로 파일을 처리하십시오. 행당 하나의 쉘 글로브 패턴이 있습니다. 이것은 &lt;code&gt;diff.orderFile&lt;/code&gt; 구성 변수를 대체합니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). 취소하려면 &lt;code&gt;diff.orderFile&lt;/code&gt; 사용 &lt;code&gt;-O/dev/null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efe0d70966f95f77c3e86b43812298f2ec9b000a" translate="yes" xml:space="preserve">
          <source>Process the reflogs of all references.</source>
          <target state="translated">모든 참조의 참조 로그를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="0782c5b7801790281dc0fb4b01651b8bfdcbc4f5" translate="yes" xml:space="preserve">
          <source>Processes all packs. Any filenames on the command line are ignored.</source>
          <target state="translated">모든 팩을 처리합니다. 명령 행의 모든 ​​파일 이름은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3c46a3f16a2a32b7eba71a8379b8360472d65d8d" translate="yes" xml:space="preserve">
          <source>Processes the specified option so that git fast-import behaves in a way that suits the frontend&amp;rsquo;s needs. Note that options specified by the frontend are overridden by any options the user may specify to git fast-import itself.</source>
          <target state="translated">git fast-import가 프론트 엔드의 요구에 맞는 방식으로 동작하도록 지정된 옵션을 처리합니다. 프런트 엔드에서 지정한 옵션은 사용자가 빠른 가져 오기 자체를 지정하도록 지정할 수있는 모든 옵션으로 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="2de3013c8cd324e1d7d27384810d30bdbff48678" translate="yes" xml:space="preserve">
          <source>Produce a merge commit message</source>
          <target state="translated">병합 커밋 메시지 생성</target>
        </trans-unit>
        <trans-unit id="221bd606329bfae672e0ecc9594988658e144e37" translate="yes" xml:space="preserve">
          <source>Produce machine-readable output. The output status line for each ref will be tab-separated and sent to stdout instead of stderr. The full symbolic names of the refs will be given.</source>
          <target state="translated">기계가 읽을 수있는 출력을 생성합니다. 각 심판의 출력 상태 라인은 탭으로 구분되어 stderr 대신 stdout으로 전송됩니다. 심판의 전체 상징 이름이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="fa20429458d99d060783732e4d2e8bf497560d29" translate="yes" xml:space="preserve">
          <source>Produce output in the same format as &lt;code&gt;git blame&lt;/code&gt;, but with SVN revision numbers instead of Git commit hashes. In this mode, changes that haven&amp;rsquo;t been committed to SVN (including local working-copy edits) are shown as revision 0.</source>
          <target state="translated">&lt;code&gt;git blame&lt;/code&gt; 과 같은 형식으로 출력 하지만 Git commit 해시 대신 SVN 개정 번호를 사용하십시오. 이 모드에서 SVN에 커밋되지 않은 변경 사항 (로컬 작업 복사 편집 포함)은 개정 0으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cb195c53f13c5c90951762ba09047296d46995e9" translate="yes" xml:space="preserve">
          <source>Produce the working tree and index state as if a real merge happened (except for the merge information), but do not actually make a commit, move the &lt;code&gt;HEAD&lt;/code&gt;, or record &lt;code&gt;$GIT_DIR/MERGE_HEAD&lt;/code&gt; (to cause the next &lt;code&gt;git commit&lt;/code&gt; command to create a merge commit). This allows you to create a single commit on top of the current branch whose effect is the same as merging another branch (or more in case of an octopus).</source>
          <target state="translated">실제 병합이 발생한 것처럼 (작업 정보를 제외하고) 작업 트리 및 인덱스 상태를 생성하지만 실제로 커밋을하지 않거나 &lt;code&gt;HEAD&lt;/code&gt; 를 이동 하거나 &lt;code&gt;$GIT_DIR/MERGE_HEAD&lt;/code&gt; 기록 하여 (다음 &lt;code&gt;git commit&lt;/code&gt; 명령으로 인해 병합 커밋). 이를 통해 현재 분기 위에 단일 커밋을 만들 수 있으며 그 효과는 다른 분기를 병합하는 것과 동일합니다 (또는 문어의 경우 더 많음).</target>
        </trans-unit>
        <trans-unit id="465a8ba2d1fbe9de5dbb0d6da6e9b4fc2bd5f63f" translate="yes" xml:space="preserve">
          <source>Produces a fast-import stream which imports the current value of the named ref. It may additionally import other refs as needed to construct the history efficiently. The script writes to a helper-specific private namespace. The value of the named ref should be written to a location in this namespace derived by applying the refspecs from the &quot;refspec&quot; capability to the name of the ref.</source>
          <target state="translated">명명 된 참조의 현재 값을 가져 오는 빠른 가져 오기 스트림을 생성합니다. 히스토리를 효율적으로 구성하는 데 필요한 다른 참조를 추가로 가져올 수 있습니다. 이 스크립트는 도우미 특정 개인 네임 스페이스에 씁니다. 이름이 지정된 참조의 값은 &quot;refspec&quot;기능의 참조 스펙을 참조 이름에 적용하여 파생 된이 네임 스페이스의 위치에 기록되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c940155095e7923b03e52693b949145b33288361" translate="yes" xml:space="preserve">
          <source>Progress status is reported on the standard error stream by default when it is attached to a terminal, unless --no-progress or --verbose is specified. --progress forces progress status even if the standard error stream is not directed to a terminal.</source>
          <target state="translated">--no-progress 또는 --verbose를 지정하지 않으면 표준 오류 스트림이 터미널에 연결될 때 기본적으로 진행 상태가보고됩니다. --progress는 표준 오류 스트림이 터미널로 보내지지 않더라도 진행 상태를 강제합니다.</target>
        </trans-unit>
        <trans-unit id="2dcc9cf9e59b81f490159a20a52344236fd5a3dc" translate="yes" xml:space="preserve">
          <source>Progress status is reported on the standard error stream by default when it is attached to a terminal, unless -q is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.</source>
          <target state="translated">-q를 지정하지 않으면 표준 오류 스트림이 터미널에 연결될 때 기본적으로 진행 상태가보고됩니다. 이 플래그는 표준 오류 스트림이 터미널로 보내지지 않더라도 진행 상태를 강제합니다.</target>
        </trans-unit>
        <trans-unit id="e5cc82042c92eacaa55f040bd35ecdec7afbf1c3" translate="yes" xml:space="preserve">
          <source>Progress status is reported on the standard error stream by default when it is attached to a terminal, unless &lt;code&gt;--quiet&lt;/code&gt; is specified. This flag enables progress reporting even if not attached to a terminal, regardless of &lt;code&gt;--quiet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--quiet&lt;/code&gt; 을 지정 하지 않으면 표준 오류 스트림이 터미널에 연결될 때 기본적으로 진행 상태가보고 됩니다. 이 플래그는 &lt;code&gt;--quiet&lt;/code&gt; 에 관계없이 터미널에 연결되지 않은 경우에도 진행률보고를 가능하게 합니다.</target>
        </trans-unit>
        <trans-unit id="84082a3e9b3738ac2cad5de1d40208e556f0b5a9" translate="yes" xml:space="preserve">
          <source>Progress status is reported on the standard error stream by default when it is attached to a terminal, unless &lt;code&gt;--quiet&lt;/code&gt; is specified. This flag forces progress status even if the standard error stream is not directed to a terminal.</source>
          <target state="translated">&lt;code&gt;--quiet&lt;/code&gt; 을 지정 하지 않으면 표준 오류 스트림이 터미널에 연결될 때 기본적으로 진행 상태가보고 됩니다. 이 플래그는 표준 오류 스트림이 터미널로 보내지지 않더라도 진행 상태를 강제합니다.</target>
        </trans-unit>
        <trans-unit id="8942c3e281f4b4272bf2fa19690b7dbfeb0da954" translate="yes" xml:space="preserve">
          <source>Progress status is reported on the standard error stream by default when it is attached to a terminal. This flag enables progress reporting even if not attached to a terminal. Can&amp;rsquo;t use &lt;code&gt;--progress&lt;/code&gt; together with &lt;code&gt;--porcelain&lt;/code&gt; or &lt;code&gt;--incremental&lt;/code&gt;.</source>
          <target state="translated">진행 상태는 표준 오류 스트림이 터미널에 연결될 때 기본적으로보고됩니다. 이 플래그는 터미널에 연결되지 않은 경우에도 진행보고를 가능하게합니다. &lt;code&gt;--progress&lt;/code&gt; 를 &lt;code&gt;--porcelain&lt;/code&gt; 또는 &lt;code&gt;--incremental&lt;/code&gt; 과 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3394ad842c4e27aba66aa2ba1a5a4056f7fb9719" translate="yes" xml:space="preserve">
          <source>Progress, informational, and error messages: The two backends provide slightly different progress and informational messages. Also, the apply backend writes error messages (such as &quot;Your files would be overwritten&amp;hellip;​&quot;) to stdout, while the merge backend writes them to stderr.</source>
          <target state="translated">진행률, 정보 및 오류 메시지 : 두 백엔드는 약간 다른 진행률 및 정보 메시지를 제공합니다. 또한 적용 백엔드는 오류 메시지 (예 : &quot;파일을 덮어 씁니다 ...&quot;)를 stdout에 기록하고 병합 백엔드는 stderr에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="a4a80ecee0b21f76717158fcc872d2fe8c9f70c9" translate="yes" xml:space="preserve">
          <source>Project list files should list one project per line, with each line having the following format</source>
          <target state="translated">프로젝트 목록 파일은 라인 당 하나의 프로젝트를 나열해야하며 각 라인은 다음 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="64ddeaf66879746d77d52edba9fc6b51c3b5494f" translate="yes" xml:space="preserve">
          <source>Project specific override is not supported.</source>
          <target state="translated">프로젝트 별 재정의는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="38cb6b6f38fc49666443f39245952417f433b632" translate="yes" xml:space="preserve">
          <source>Projects list file format</source>
          <target state="translated">프로젝트 목록 파일 형식</target>
        </trans-unit>
        <trans-unit id="99a6cf116ac91087c7f440f3f894b1353453be3c" translate="yes" xml:space="preserve">
          <source>Promisor packfiles are repacked separately: if there are packfiles that have an associated &quot;.promisor&quot; file, these packfiles will be repacked into another separate pack, and an empty &quot;.promisor&quot; file corresponding to the new separate pack will be written.</source>
          <target state="translated">Promisor 팩 파일은 별도로 재 포장됩니다. &quot;.promisor&quot;파일과 관련된 팩 파일이있는 경우이 팩 파일은 다른 별도 팩으로 재 포장되고 새 별도 팩에 해당하는 빈 &quot;.promisor&quot;파일이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="1e3e6d8a5678027c372d639c7caa1ae762739111" translate="yes" xml:space="preserve">
          <source>Prompt before each invocation of the diff tool.</source>
          <target state="translated">diff 도구를 호출하기 전에 프롬프트하십시오.</target>
        </trans-unit>
        <trans-unit id="011847e8f4535310d3585f3561b850f5eaa68bd2" translate="yes" xml:space="preserve">
          <source>Prompt before each invocation of the diff tool. This is the default behaviour; the option is provided to override any configuration settings.</source>
          <target state="translated">diff 도구를 호출하기 전에 프롬프트하십시오. 이것이 기본 동작입니다. 옵션은 모든 구성 설정을 무시하기 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="60f48217749656a50ce363c78d14fe3fba58b27e" translate="yes" xml:space="preserve">
          <source>Prompt before each invocation of the merge resolution program to give the user a chance to skip the path.</source>
          <target state="translated">병합 해결 프로그램을 호출 할 때마다 사용자에게 경로를 건너 뛸 수있는 프롬프트가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1bd1cfd1155b4114e14d09a7c37c4a191ca7ac30" translate="yes" xml:space="preserve">
          <source>Prompt before each invocation of the merge resolution program.</source>
          <target state="translated">병합 해결 프로그램을 호출하기 전에 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="353a353b6eb50b67e795967c32fb24f9eeb5d549" translate="yes" xml:space="preserve">
          <source>Protocol notes: If you are using anonymous access via pserver, just select that. Those using SSH access should choose the &lt;code&gt;ext&lt;/code&gt; protocol, and configure &lt;code&gt;ext&lt;/code&gt; access on the Preferences&amp;rarr;Team&amp;rarr;CVS&amp;rarr;ExtConnection pane. Set CVS_SERVER to &quot;&lt;code&gt;git cvsserver&lt;/code&gt;&quot;. Note that password support is not good when using &lt;code&gt;ext&lt;/code&gt;, you will definitely want to have SSH keys setup.</source>
          <target state="translated">프로토콜 노트 : pserver를 통한 익명 액세스를 사용하는 경우이를 선택하십시오. SSH 액세스를 사용하는 사용자는 &lt;code&gt;ext&lt;/code&gt; 프로토콜을 선택 하고 기본 설정 &amp;rarr; 팀 &amp;rarr; CVS &amp;rarr; ExtConnection 창에서 &lt;code&gt;ext&lt;/code&gt; 액세스를 구성 해야합니다 . CVS_SERVER를 &quot; &lt;code&gt;git cvsserver&lt;/code&gt; &quot;로 설정하십시오 . &lt;code&gt;ext&lt;/code&gt; 를 사용할 때 비밀번호 지원이 좋지 않으므로 SSH 키를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4e8bf93a6f67bf7687593a7faf3fef64759fa4d3" translate="yes" xml:space="preserve">
          <source>Protocol version 2 is stateless by default. This means that all commands must only last a single round and be stateless from the perspective of the server side, unless the client has requested a capability indicating that state should be maintained by the server. Clients MUST NOT require state management on the server side in order to function correctly. This permits simple round-robin load-balancing on the server side, without needing to worry about state management.</source>
          <target state="translated">프로토콜 버전 2는 기본적으로 상태 비 저장입니다. 이는 클라이언트가 서버에 의해 상태를 유지해야한다는 기능을 요청하지 않는 한 모든 명령은 단일 라운드 동안 지속되어야하며 서버 측 관점에서 비 상태 유지되어야합니다. 클라이언트가 올바르게 작동하기 위해 서버 측에서 상태 관리를 요구해서는 안됩니다. 이를 통해 상태 관리에 대해 걱정할 필요없이 서버 측에서 간단한 라운드 로빈로드 균형 조정이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a457f44dce93162338e37dcadcb5a7e148a161e8" translate="yes" xml:space="preserve">
          <source>Provide content or type and size information for repository objects</source>
          <target state="translated">저장소 오브젝트에 대한 컨텐츠 또는 유형 및 크기 정보 제공</target>
        </trans-unit>
        <trans-unit id="ce1130d2639274732ace3560e1b161a1f25e1593" translate="yes" xml:space="preserve">
          <source>Provide more progress information.</source>
          <target state="translated">더 많은 진행 정보를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="e90e088e3482417a8a9d0a613e03789c858721a1" translate="yes" xml:space="preserve">
          <source>Provides a default value for unspecified object filters (see: the below configuration variable). Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">지정되지 않은 개체 필터에 대한 기본값을 제공합니다 (아래 구성 변수 참조). 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ddd6c4f93ce8e6500d931f94e6b50cb8556ece89" translate="yes" xml:space="preserve">
          <source>Provides the default value for the &lt;code&gt;--from&lt;/code&gt; option to format-patch. Accepts a boolean value, or a name and email address. If false, format-patch defaults to &lt;code&gt;--no-from&lt;/code&gt;, using commit authors directly in the &quot;From:&quot; field of patch mails. If true, format-patch defaults to &lt;code&gt;--from&lt;/code&gt;, using your committer identity in the &quot;From:&quot; field of patch mails and including a &quot;From:&quot; field in the body of the patch mail if different. If set to a non-boolean value, format-patch uses that value instead of your committer identity. Defaults to false.</source>
          <target state="translated">&lt;code&gt;--from&lt;/code&gt; 옵션 의 기본값 을 format-patch로 제공합니다. 부울 값 또는 이름과 이메일 주소를 승인합니다. false 인 경우, 패치 메일의 &quot;보낸 사람 :&quot;필드에서 커밋 작성자를 사용하여 format-patch의 기본값은 &lt;code&gt;--no-from&lt;/code&gt; 입니다. true 인 경우 패치 메일의 &quot;보낸 사람 :&quot;필드에 커미터 ID를 사용하고 패치 메일 본문에 &quot;보낸 사람 :&quot;필드를 포함하는 format-patch의 기본값은 &lt;code&gt;--from&lt;/code&gt; 입니다. 부울이 아닌 값으로 설정하면 format-patch는 커미터 ID 대신 해당 값을 사용합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="07e705dc3eb04b1cd0e9d868ce2fbabc5a7b23e9" translate="yes" xml:space="preserve">
          <source>Provides the default value for the &lt;code&gt;--notes&lt;/code&gt; option to format-patch. Accepts a boolean value, or a ref which specifies where to get notes. If false, format-patch defaults to &lt;code&gt;--no-notes&lt;/code&gt;. If true, format-patch defaults to &lt;code&gt;--notes&lt;/code&gt;. If set to a non-boolean value, format-patch defaults to &lt;code&gt;--notes=&amp;lt;ref&amp;gt;&lt;/code&gt;, where &lt;code&gt;ref&lt;/code&gt; is the non-boolean value. Defaults to false.</source>
          <target state="translated">format-patch에 &lt;code&gt;--notes&lt;/code&gt; 옵션 의 기본값을 제공합니다 . 부울 값 또는 메모를 가져올 위치를 지정하는 참조를 승인합니다. false 인 경우 format-patch의 기본값은 &lt;code&gt;--no-notes&lt;/code&gt; 입니다. true 인 경우 format-patch의 기본값은 &lt;code&gt;--notes&lt;/code&gt; 입니다. 부울이 아닌 값으로 설정하면 format-patch의 기본값은 &lt;code&gt;--notes=&amp;lt;ref&amp;gt;&lt;/code&gt; 이며 여기서 &lt;code&gt;ref&lt;/code&gt; 는 부울이 아닌 값입니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="dae8413448109f25f13d1230fdfd21a6427a0a34" translate="yes" xml:space="preserve">
          <source>Provides the name of the object in the original source control system. fast-import will simply ignore this directive, but filter processes which operate on and modify the stream before feeding to fast-import may have uses for this information</source>
          <target state="translated">원래 소스 제어 시스템에서 오브젝트의 이름을 제공합니다. 빠른 가져 오기는이 지시문을 무시하지만, 빠른 가져 오기에 공급하기 전에 스트림에서 작동하고 스트림을 수정하는 필터 프로세스는이 정보를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="354f719eac7091e1c38104be699d2a68f56df045" translate="yes" xml:space="preserve">
          <source>Providing cvs access to a git repository</source>
          <target state="translated">자식 저장소에 cvs 액세스 제공</target>
        </trans-unit>
        <trans-unit id="9a84f98b698c9d5bcdfa443dee138e79368665d7" translate="yes" xml:space="preserve">
          <source>Providing usernames and passwords to Git</source>
          <target state="translated">Git에 사용자 이름 및 비밀번호 제공</target>
        </trans-unit>
        <trans-unit id="05a28ca41ca8e50984ed01529e7df3e3335567dc" translate="yes" xml:space="preserve">
          <source>Prune all unreachable objects from the object database</source>
          <target state="translated">개체 데이터베이스에서 연결할 수없는 개체를 모두 정리</target>
        </trans-unit>
        <trans-unit id="347c95991436ac84fd290ccf1ebe7a72eadc41e7" translate="yes" xml:space="preserve">
          <source>Prune any reflog entries that point to &quot;broken commits&quot;. A broken commit is a commit that is not reachable from any of the reference tips and that refers, directly or indirectly, to a missing commit, tree, or blob object.</source>
          <target state="translated">&quot;깨진 커밋&quot;을 가리키는 모든 reflog 항목을 제거하십시오. 커미트 커미트는 참조 팁에서 도달 할 수없고 누락 된 커미트, 트리 또는 Blob 오브젝트를 직접 또는 간접적으로 참조하는 커미트입니다.</target>
        </trans-unit>
        <trans-unit id="a7eae2a7a6ec9df449cef235306188bcb1fafe15" translate="yes" xml:space="preserve">
          <source>Prune entries older than &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; that are not reachable from the current tip of the branch. If this option is not specified, the expiration time is taken from the configuration setting &lt;code&gt;gc.reflogExpireUnreachable&lt;/code&gt;, which in turn defaults to 30 days. &lt;code&gt;--expire-unreachable=all&lt;/code&gt; prunes unreachable entries regardless of their age; &lt;code&gt;--expire-unreachable=never&lt;/code&gt; turns off early pruning of unreachable entries (but see &lt;code&gt;--expire&lt;/code&gt;).</source>
          <target state="translated">분기의 현재 팁에서 도달 할 수없는 &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; 보다 오래된 항목을 정리 하십시오. 이 옵션을 지정하지 않으면 만료 시간은 구성 설정 &lt;code&gt;gc.reflogExpireUnreachable&lt;/code&gt; 에서 가져 오며 기본값은 30 일입니다. &lt;code&gt;--expire-unreachable=all&lt;/code&gt; 연령에 관계없이 도달 할 수없는 항목을 제거합니다. &lt;code&gt;--expire-unreachable=never&lt;/code&gt; 도달 할 수없는 항목의 초기 정리를 해제 하지 않습니다 (그러나 &lt;code&gt;--expire&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f510204b241f9f833d70b40e365b78ba855d5d73" translate="yes" xml:space="preserve">
          <source>Prune entries older than the specified time. If this option is not specified, the expiration time is taken from the configuration setting &lt;code&gt;gc.reflogExpire&lt;/code&gt;, which in turn defaults to 90 days. &lt;code&gt;--expire=all&lt;/code&gt; prunes entries regardless of their age; &lt;code&gt;--expire=never&lt;/code&gt; turns off pruning of reachable entries (but see &lt;code&gt;--expire-unreachable&lt;/code&gt;).</source>
          <target state="translated">지정된 시간보다 오래된 항목을 정리합니다. 이 옵션을 지정하지 않으면 만료 시간은 구성 설정 &lt;code&gt;gc.reflogExpire&lt;/code&gt; 에서 가져 오며 기본값은 90 일입니다. &lt;code&gt;--expire=all&lt;/code&gt; 연령에 관계없이 항목을 제거합니다. &lt;code&gt;--expire=never&lt;/code&gt; 는 도달 가능한 항목의 정리를 해제 하지 않습니다 (그러나 &lt;code&gt;--expire-unreachable&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="9ca76117e69104a0e4e81d319f878c7014bb3c8a" translate="yes" xml:space="preserve">
          <source>Prune loose objects older than date (default is 2 weeks ago, overridable by the config variable &lt;code&gt;gc.pruneExpire&lt;/code&gt;). --prune=now prunes loose objects regardless of their age and increases the risk of corruption if another process is writing to the repository concurrently; see &quot;NOTES&quot; below. --prune is on by default.</source>
          <target state="translated">날짜보다 오래된 느슨한 객체를 제거 (기본값은 2 주 전, 구성 변수 &lt;code&gt;gc.pruneExpire&lt;/code&gt; 로 대체 가능 ) --prune = 이제 나이에 관계없이 느슨한 객체를 정리하고 다른 프로세스가 동시에 저장소에 쓰는 경우 손상 위험을 증가시킵니다. 아래의 &quot;노트&quot;를 참조하십시오. --prune은 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad1903147c3980cb00334e6e57ade6c895b0d197" translate="yes" xml:space="preserve">
          <source>Prune records of conflicted merges that occurred a long time ago. By default, unresolved conflicts older than 15 days and resolved conflicts older than 60 days are pruned. These defaults are controlled via the &lt;code&gt;gc.rerereUnresolved&lt;/code&gt; and &lt;code&gt;gc.rerereResolved&lt;/code&gt; configuration variables respectively.</source>
          <target state="translated">오래 전에 발생한 충돌 병합 기록을 정리합니다. 기본적으로 15 일보다 오래된 해결되지 않은 충돌과 60 일보다 오래된 해결 된 충돌은 제거됩니다. 이러한 기본값은 각각 &lt;code&gt;gc.rerereUnresolved&lt;/code&gt; 및 &lt;code&gt;gc.rerereResolved&lt;/code&gt; 구성 변수 를 통해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ae5dc95253bd1047251fe2f0130ef53d935cb16" translate="yes" xml:space="preserve">
          <source>Prune working tree information in $GIT_DIR/worktrees.</source>
          <target state="translated">$ GIT_DIR / worktrees에서 작업 트리 정보를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="b6aa433344bec7e7c38aefc927d7aa60d687c035" translate="yes" xml:space="preserve">
          <source>Prune working tree information in &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; 에서 작업 트리 정보를 정리합니다 .</target>
        </trans-unit>
        <trans-unit id="1daa62e08ce5be741f0f9512af6fe6aea569309c" translate="yes" xml:space="preserve">
          <source>Pruning</source>
          <target state="translated">Pruning</target>
        </trans-unit>
        <trans-unit id="9780740ad9404eab5bef283300816b2d37b6c371" translate="yes" xml:space="preserve">
          <source>Pruning tags with &lt;code&gt;--prune-tags&lt;/code&gt; also works when fetching a URL instead of a named remote. These will all prune tags not found on origin:</source>
          <target state="translated">&lt;code&gt;--prune-tags&lt;/code&gt; tags가 포함 된 잘라 내기 태그 는 명명 된 리모컨 대신 URL을 가져올 때도 작동합니다. 이것들은 모두 원산지에서 찾을 수없는 태그를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="5d67c6362cb385f7b2fd7440df4474229e4ced1c" translate="yes" xml:space="preserve">
          <source>Pseudorefs are a class of files under &lt;code&gt;$GIT_DIR&lt;/code&gt; which behave like refs for the purposes of rev-parse, but which are treated specially by git. Pseudorefs both have names that are all-caps, and always start with a line consisting of a &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; followed by whitespace. So, HEAD is not a pseudoref, because it is sometimes a symbolic ref. They might optionally contain some additional data. &lt;code&gt;MERGE_HEAD&lt;/code&gt; and &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; are examples. Unlike &lt;a href=&quot;#def_per_worktree_ref&quot;&gt;per-worktree refs&lt;/a&gt;, these files cannot be symbolic refs, and never have reflogs. They also cannot be updated through the normal ref update machinery. Instead, they are updated by directly writing to the files. However, they can be read as if they were refs, so &lt;code&gt;git rev-parse
MERGE_HEAD&lt;/code&gt; will work.</source>
          <target state="translated">유사 참조는 &lt;code&gt;$GIT_DIR&lt;/code&gt; GIT_DIR 아래의 파일 클래스로 , rev-parse를위한 참조처럼 동작하지만 git에 의해 특별하게 처리됩니다. 유사 참조는 모두 대문자 인 이름을 가지며 항상 &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; 과 공백 으로 구성된 줄로 시작 합니다. 따라서 HEAD는 의사 참조가 아니므로 의사 참조가 아닙니다. 선택적으로 일부 추가 데이터를 포함 할 수 있습니다. &lt;code&gt;MERGE_HEAD&lt;/code&gt; 및 &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; 가 예입니다. 작업 &lt;a href=&quot;#def_per_worktree_ref&quot;&gt;별 트리 참조&lt;/a&gt; 와 달리이 파일은 기호 참조가 될 수 없으며 참조 로그가 없습니다. 또한 일반적인 참조 업데이트 기계를 통해 업데이트 할 수 없습니다. 대신 파일에 직접 쓰면 업데이트됩니다. 그러나 심판 인 것처럼 읽을 수 있습니다. &lt;code&gt;git rev-parse MERGE_HEAD&lt;/code&gt; 가 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b7a4dc2e6290047f1f86721c32ae669785e9b742" translate="yes" xml:space="preserve">
          <source>Public Git repositories</source>
          <target state="translated">공공 Git 리포지토리</target>
        </trans-unit>
        <trans-unit id="8f3f20e99361b4469a543cafe71c660d905701e0" translate="yes" xml:space="preserve">
          <source>Public api</source>
          <target state="translated">공개 API</target>
        </trans-unit>
        <trans-unit id="661a1caa924e6377c910ab84f021b879aa1f3688" translate="yes" xml:space="preserve">
          <source>Public key of the https service. It may either be the filename of a PEM or DER encoded public key file or a string starting with &lt;code&gt;sha256//&lt;/code&gt; followed by the base64 encoded sha256 hash of the public key. See also libcurl &lt;code&gt;CURLOPT_PINNEDPUBLICKEY&lt;/code&gt;. git will exit with an error if this option is set but not supported by cURL.</source>
          <target state="translated">https 서비스의 공개 키 PEM 또는 DER로 인코딩 된 공개 키 파일의 파일 이름이거나 &lt;code&gt;sha256//&lt;/code&gt; 시작하고 그 뒤에 공개 키의 base64로 인코딩 된 sha256 해시가 있는 문자열 일 수 있습니다. libcurl &lt;code&gt;CURLOPT_PINNEDPUBLICKEY&lt;/code&gt; 도 참조 하십시오 . 이 옵션이 설정되었지만 cURL이 지원하지 않으면 git은 오류와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="fcd79d77a075207d5bb03627d6390daac4adccdf" translate="yes" xml:space="preserve">
          <source>Publishing the changes from your local (private) repository to your remote (public) repository requires a write privilege on the remote machine. You need to have an SSH account there to run a single command, &lt;code&gt;git-receive-pack&lt;/code&gt;.</source>
          <target state="translated">로컬 (개인) 저장소에서 원격 (공용) 저장소로 변경 사항을 공개하려면 원격 시스템에 대한 쓰기 권한이 필요합니다. 단일 명령 &lt;code&gt;git-receive-pack&lt;/code&gt; 을 실행하려면 SSH 계정이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9d5654eba7f3fb26678d0b33453ea83f3704835b" translate="yes" xml:space="preserve">
          <source>Publishing your work</source>
          <target state="translated">작품 게시</target>
        </trans-unit>
        <trans-unit id="5225d106493e2d5cee97f92acd212fcbe8379cc8" translate="yes" xml:space="preserve">
          <source>Pulling a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; means to &lt;a href=&quot;#def_fetch&quot;&gt;fetch&lt;/a&gt; it and &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; it. See also &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;.</source>
          <target state="translated">당기는 &lt;a href=&quot;#def_branch&quot;&gt;분기&lt;/a&gt; 수단은하기 &lt;a href=&quot;#def_fetch&quot;&gt;가져 오기&lt;/a&gt; 를하고 &lt;a href=&quot;#def_merge&quot;&gt;병합&lt;/a&gt; 을. &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ba996099ee22cf557dfd858fcdfe9998a7d87a8" translate="yes" xml:space="preserve">
          <source>Pulling down the submodules is a two-step process. First run &lt;code&gt;git submodule
init&lt;/code&gt; to add the submodule repository URLs to &lt;code&gt;.git/config&lt;/code&gt;:</source>
          <target state="translated">서브 모듈을 풀다운하는 것은 2 단계 프로세스입니다. 먼저 &lt;code&gt;git submodule init&lt;/code&gt; 를 실행 하여 서브 모듈 저장소 URL을 &lt;code&gt;.git/config&lt;/code&gt; 에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="67689e297cd4fdd92ebe641f7b6ed9bc63361f6b" translate="yes" xml:space="preserve">
          <source>Pulling into a dirty tree</source>
          <target state="translated">더러운 나무를 당겨</target>
        </trans-unit>
        <trans-unit id="678a9bfb35ce5da855b86526d846cbdc7583b760" translate="yes" xml:space="preserve">
          <source>Push &quot;matching&quot; branches to &lt;code&gt;origin&lt;/code&gt;. See &amp;lt;refspec&amp;gt; in the &lt;a href=&quot;#OPTIONS&quot;&gt;OPTIONS&lt;/a&gt; section above for a description of &quot;matching&quot; branches.</source>
          <target state="translated">&quot;일치하는&quot;분기를 &lt;code&gt;origin&lt;/code&gt; 밉니다 . &quot;일치하는&quot;브랜치에 대한 설명은 위 의 &lt;a href=&quot;#OPTIONS&quot;&gt;옵션&lt;/a&gt; 섹션 에서 &amp;lt;refspec&amp;gt;을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3d386bb2b306b430b8f1443632bcddb41f7fbbb" translate="yes" xml:space="preserve">
          <source>Push all branches (i.e. refs under &lt;code&gt;refs/heads/&lt;/code&gt;); cannot be used with other &amp;lt;refspec&amp;gt;.</source>
          <target state="translated">모든 분기 (예 : 참조 &lt;code&gt;refs/heads/&lt;/code&gt; 아래의 참조)를 푸시합니다 . 다른 &amp;lt;refspec&amp;gt;과 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ed05cac5fbf2fe13d768ad8d52cf3e6b3326c39" translate="yes" xml:space="preserve">
          <source>Push all the refs that would be pushed without this option, and also push annotated tags in &lt;code&gt;refs/tags&lt;/code&gt; that are missing from the remote but are pointing at commit-ish that are reachable from the refs being pushed. This can also be specified with configuration variable &lt;code&gt;push.followTags&lt;/code&gt;. For more information, see &lt;code&gt;push.followTags&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">이 옵션없이 푸시 될 모든 참조를 푸시하고, 원격에서 누락되었지만 푸시되는 참조에서 도달 할 수있는 커밋을 가리키는 참조 &lt;code&gt;refs/tags&lt;/code&gt; 에 주석이 달린 태그를 푸시합니다. 구성 변수 &lt;code&gt;push.followTags&lt;/code&gt; 로 지정할 수도 있습니다 . 자세한 내용 은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]의 &lt;/a&gt; &lt;code&gt;push.followTags&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="640e91962e4a94024fb44763555198cb451cbb5d" translate="yes" xml:space="preserve">
          <source>Push into another repository.</source>
          <target state="translated">다른 저장소로 푸시하십시오.</target>
        </trans-unit>
        <trans-unit id="fc1129a549e46f5ee09d052c0e625db078207268" translate="yes" xml:space="preserve">
          <source>Push into the public repository from your primary repository.</source>
          <target state="translated">기본 저장소에서 공용 저장소로 푸시하십시오.</target>
        </trans-unit>
        <trans-unit id="a011ac29541d686365501a5376539fc2a54082f8" translate="yes" xml:space="preserve">
          <source>Push into the public repository from your primary repository. Run &lt;code&gt;git repack&lt;/code&gt;, and possibly &lt;code&gt;git prune&lt;/code&gt; if the transport used for pulling from your repository supports packed repositories.</source>
          <target state="translated">기본 저장소에서 공용 저장소로 푸시하십시오. &lt;code&gt;git repack&lt;/code&gt; 을 실행 하고 저장소에서 가져 오기 위해 사용 된 전송이 압축 된 저장소를 지원하는 경우 &lt;code&gt;git prune&lt;/code&gt; 가능할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8251f9563aa908db5da52a9527e9f939a118d16" translate="yes" xml:space="preserve">
          <source>Push master, using file descriptor #7 to read data from git-receive-pack and file descriptor #8 to write data to same service.</source>
          <target state="translated">파일 디스크립터 # 7을 사용하여 git-receive-pack에서 데이터를 읽고 파일 디스크립터 # 8을 사용하여 동일한 서비스에 데이터를 쓰십시오.</target>
        </trans-unit>
        <trans-unit id="db6a77b6524cf46e0155fc78cb84e6ef6e8d26d4" translate="yes" xml:space="preserve">
          <source>Push objects over Git protocol to another repository</source>
          <target state="translated">Git 프로토콜을 통해 객체를 다른 저장소로 푸시</target>
        </trans-unit>
        <trans-unit id="e328f2dc0a129ee52c24984713b8e3e05193f873" translate="yes" xml:space="preserve">
          <source>Push objects over HTTP/DAV to another repository</source>
          <target state="translated">HTTP / DAV를 통해 객체를 다른 저장소로 푸시</target>
        </trans-unit>
        <trans-unit id="93e6fc3901865e79bc1dfa6c467266c7822bf760" translate="yes" xml:space="preserve">
          <source>Push the current branch to the remote ref matching &lt;code&gt;master&lt;/code&gt; in the &lt;code&gt;origin&lt;/code&gt; repository. This form is convenient to push the current branch without thinking about its local name.</source>
          <target state="translated">현재 브랜치를 &lt;code&gt;origin&lt;/code&gt; 저장소 의 원격 참조 일치 &lt;code&gt;master&lt;/code&gt; 로 푸시하십시오 . 이 형식은 현지 이름을 생각하지 않고 현재 분기를 밀어 넣기에 편리합니다.</target>
        </trans-unit>
        <trans-unit id="7221b3bad2db1abe78fb6e7112e947ec9066c484" translate="yes" xml:space="preserve">
          <source>Push your changes to the public repository, and announce it to the public.</source>
          <target state="translated">변경 사항을 공용 저장소로 푸시하고 공개로 알리십시오.</target>
        </trans-unit>
        <trans-unit id="44e2374abe889d292378278a32f8732ae3d0723a" translate="yes" xml:space="preserve">
          <source>Push your changes to your public repository, and ask your &quot;project lead&quot; and possibly your &quot;sub-subsystem maintainers&quot; to pull from it.</source>
          <target state="translated">변경 사항을 공용 저장소로 푸시하고 &quot;프로젝트 리더&quot;및 가능하면 &quot;하위 서브 시스템 관리자&quot;에게 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="64c3ecd283374b8e31c77b37f0b37ed07f7e3e67" translate="yes" xml:space="preserve">
          <source>Pushes the given local &amp;lt;src&amp;gt; commit or branch to the remote branch described by &amp;lt;dst&amp;gt;. A batch sequence of one or more &lt;code&gt;push&lt;/code&gt; commands is terminated with a blank line (if there is only one reference to push, a single &lt;code&gt;push&lt;/code&gt; command is followed by a blank line). For example, the following would be two batches of &lt;code&gt;push&lt;/code&gt;, the first asking the remote-helper to push the local ref &lt;code&gt;master&lt;/code&gt; to the remote ref &lt;code&gt;master&lt;/code&gt; and the local &lt;code&gt;HEAD&lt;/code&gt; to the remote &lt;code&gt;branch&lt;/code&gt;, and the second asking to push ref &lt;code&gt;foo&lt;/code&gt; to ref &lt;code&gt;bar&lt;/code&gt; (forced update requested by the &lt;code&gt;+&lt;/code&gt;).</source>
          <target state="translated">지정된 로컬 &amp;lt;src&amp;gt; 커밋 또는 분기를 &amp;lt;dst&amp;gt;에서 설명하는 원격 분기로 푸시합니다. 하나 이상의 &lt;code&gt;push&lt;/code&gt; 명령 의 배치 시퀀스는 빈 줄로 종료됩니다 (푸시에 대한 참조가 하나만있는 경우 단일 &lt;code&gt;push&lt;/code&gt; 명령 뒤에 빈 줄이옵니다). 예를 들어, 다음의 두 배치 될 &lt;code&gt;push&lt;/code&gt; (가) 제 로컬 심판 밀어 원격 헬퍼 묻는 &lt;code&gt;master&lt;/code&gt; 원격 심판에 &lt;code&gt;master&lt;/code&gt; 및 로컬 &lt;code&gt;HEAD&lt;/code&gt; 원격으로 &lt;code&gt;branch&lt;/code&gt; 하고, REF 푸시 요청 제 &lt;code&gt;foo&lt;/code&gt; 는 심판에 &lt;code&gt;bar&lt;/code&gt; ( &lt;code&gt;+&lt;/code&gt; 가 요청한 강제 업데이트 ).</target>
        </trans-unit>
        <trans-unit id="ca5456a5df7b11e9ef0d22090b33d4f3bd62ba82" translate="yes" xml:space="preserve">
          <source>Pushes which fail due to problems with the incoming pack, missing objects, or due to the &lt;code&gt;pre-receive&lt;/code&gt; hook will not leave any on-disk data. This is usually helpful to prevent repeated failed pushes from filling up your disk, but can make debugging more challenging.</source>
          <target state="translated">수신 팩 문제, 누락 된 객체 또는 &lt;code&gt;pre-receive&lt;/code&gt; 후크 로 인해 실패한 푸시 는 디스크상의 데이터를 남기지 않습니다. 이 방법은 일반적으로 반복되는 실패한 푸시로 인해 디스크가 가득 차는 것을 방지하는 데 도움이되지만 디버깅이 더 어려워 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd3f47195169191b06e6fb59aa660030c03d8082" translate="yes" xml:space="preserve">
          <source>Pushing a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; means to get the branch&amp;rsquo;s &lt;a href=&quot;#def_head_ref&quot;&gt;head ref&lt;/a&gt; from a remote &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;, find out if it is an ancestor to the branch&amp;rsquo;s local head ref, and in that case, putting all objects, which are &lt;a href=&quot;#def_reachable&quot;&gt;reachable&lt;/a&gt; from the local head ref, and which are missing from the remote repository, into the remote &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt;, and updating the remote head ref. If the remote &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt; is not an ancestor to the local head, the push fails.</source>
          <target state="translated">푸싱 &lt;a href=&quot;#def_branch&quot;&gt;브랜치&lt;/a&gt; 수단은 지점의 얻기 위해 &lt;a href=&quot;#def_head_ref&quot;&gt;머리를 심판&lt;/a&gt; 원격에서 &lt;a href=&quot;#def_repository&quot;&gt;저장소를&lt;/a&gt; ,이 지점의 로컬 헤드 심판에 조상이 있는지 확인하고, 그 경우, 모든 객체, 퍼팅 &lt;a href=&quot;#def_reachable&quot;&gt;도달&lt;/a&gt; 로컬 헤드 심판에서하고있는을 원격 저장소에서 원격 &lt;a href=&quot;#def_object_database&quot;&gt;오브젝트 데이터베이스&lt;/a&gt; 로 누락되고 원격 헤드 참조를 업데이트합니다. 원격 &lt;a href=&quot;#def_head&quot;&gt;헤드&lt;/a&gt; 가 로컬 헤드의 조상이 아닌 경우 푸시에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a1b201ad98b52436e58805968e041862b0e44b88" translate="yes" xml:space="preserve">
          <source>Pushing an empty &amp;lt;src&amp;gt; allows you to delete the &amp;lt;dst&amp;gt; ref from the remote repository. Deletions are always accepted without a leading &lt;code&gt;+&lt;/code&gt; in the refspec (or &lt;code&gt;--force&lt;/code&gt;), except when forbidden by configuration or hooks. See &lt;code&gt;receive.denyDeletes&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; and &lt;code&gt;pre-receive&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; in &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">빈 &amp;lt;src&amp;gt;를 누르면 원격 저장소에서 &amp;lt;dst&amp;gt; 참조를 삭제할 수 있습니다. 구성 또는 후크에 의해 금지 된 경우를 제외하고, 참조 스펙 (또는 &lt;code&gt;--force&lt;/code&gt; ) 에서 선행 &lt;code&gt;+&lt;/code&gt; 없이 삭제가 항상 허용 됩니다. 참조 &lt;code&gt;receive.denyDeletes&lt;/code&gt; 에서 &lt;a href=&quot;git-config&quot;&gt;자식-설정 [1]&lt;/a&gt; 및 &lt;code&gt;pre-receive&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt; 에 &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1b554604b5dbdc966cb242c709d8d9564fd3f48c" translate="yes" xml:space="preserve">
          <source>Pushing changes to a public repository</source>
          <target state="translated">공용 저장소로 변경 사항 푸시</target>
        </trans-unit>
        <trans-unit id="eedfa4fe862b4ad2f2d3d15f8505bb4e78d4fc1a" translate="yes" xml:space="preserve">
          <source>Put all the committers in the same group, and make the repository writable by that group:</source>
          <target state="translated">모든 커미터를 동일한 그룹에 배치하고 해당 그룹이 저장소를 쓰기 가능하게하십시오.</target>
        </trans-unit>
        <trans-unit id="c26397c67704ec958580d89b3087bf7a34700351" translate="yes" xml:space="preserve">
          <source>Put everything in the current head&amp;rsquo;s Documentation/ directory into &lt;code&gt;git-1.4.0-docs.zip&lt;/code&gt;, with the prefix &lt;code&gt;git-docs/&lt;/code&gt;.</source>
          <target state="translated">현재 헤드의 Documentation / 디렉토리에있는 모든 것을 &lt;code&gt;git-docs/&lt;/code&gt; 접두어를 사용하여 &lt;code&gt;git-1.4.0-docs.zip&lt;/code&gt; 에 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="ea705b3a47d1cdf9261daf67230a93968f6edd0b" translate="yes" xml:space="preserve">
          <source>QUERY_STRING</source>
          <target state="translated">QUERY_STRING</target>
        </trans-unit>
        <trans-unit id="c3149be9220a8ce116523f671437212f69f45ea5" translate="yes" xml:space="preserve">
          <source>Quarantine environment</source>
          <target state="translated">검역 환경</target>
        </trans-unit>
        <trans-unit id="ec85d37cf9d9f3d10289231d732a03bb25cc011c" translate="yes" xml:space="preserve">
          <source>Query p4 for labels associated with the depot paths, and add them as tags in Git. Limited usefulness as only imports labels associated with new changelists. Deprecated.</source>
          <target state="translated">저장소 경로와 연관된 레이블에 대해 p4를 조회하고 Git에서 태그로 추가하십시오. 새로운 변경 목록과 관련된 레이블 만 가져 오기 때문에 유용성이 제한됩니다. 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb46658e95579ef7659db1b1de8bbb537b0fac1e" translate="yes" xml:space="preserve">
          <source>Quick reference guides: &lt;a href=&quot;https://github.github.com/training-kit/&quot;&gt;GitHub Cheat Sheet&lt;/a&gt; | &lt;a href=&quot;https://ndpsoftware.com/git-cheatsheet.html&quot;&gt;Visual Git Cheat Sheet&lt;/a&gt;</source>
          <target state="translated">빠른 참조 가이드 : &lt;a href=&quot;https://github.github.com/training-kit/&quot;&gt;GitHub 치트 시트&lt;/a&gt; | &lt;a href=&quot;https://ndpsoftware.com/git-cheatsheet.html&quot;&gt;Visual Git 치트 시트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ce8d2336bc85bc6e5b624295904c32b955dda594" translate="yes" xml:space="preserve">
          <source>Quick reference guides: &lt;a href=&quot;https://github.github.com/training-kit/downloads/github-git-cheat-sheet.pdf&quot;&gt;GitHub Cheat Sheet&lt;/a&gt;&lt;small&gt;(PDF)&lt;/small&gt; | &lt;a href=&quot;https://ndpsoftware.com/git-cheatsheet.html&quot;&gt;Visual Git Cheat Sheet&lt;/a&gt;&lt;small&gt;(SVG | PNG)&lt;/small&gt;</source>
          <target state="translated">빠른 참조 안내서 : &lt;a href=&quot;https://github.github.com/training-kit/downloads/github-git-cheat-sheet.pdf&quot;&gt;GitHub 치트 시트 &lt;/a&gt;&lt;small&gt;(PDF)&lt;/small&gt; | &lt;a href=&quot;https://ndpsoftware.com/git-cheatsheet.html&quot;&gt;Visual Git 치트 시트 &lt;/a&gt;&lt;small&gt;(SVG | PNG)&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="3a11ac4a816649c90b2a876b8ed365a4f747816e" translate="yes" xml:space="preserve">
          <source>Quiet, suppress feedback messages.</source>
          <target state="translated">조용하고 피드백 메시지를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2ac9102b0a2f3eb9abc09cf4e1c41ec0575ff1e1" translate="yes" xml:space="preserve">
          <source>Quiet, suppress feedback messages. Implies &lt;code&gt;--no-progress&lt;/code&gt;.</source>
          <target state="translated">조용하고 피드백 메시지를 표시하지 않습니다. &lt;code&gt;--no-progress&lt;/code&gt; 를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="de1dab6bd571badbfbb3ddaa6f495be909332129" translate="yes" xml:space="preserve">
          <source>Quiet. If --refresh finds that the index needs an update, the default behavior is to error out. This option makes &lt;code&gt;git update-index&lt;/code&gt; continue anyway.</source>
          <target state="translated">조용한. --refresh에서 인덱스를 업데이트해야하는 경우 기본 동작은 오류입니다. 이 옵션은 &lt;code&gt;git update-index&lt;/code&gt; 를 계속 진행시킵니다.</target>
        </trans-unit>
        <trans-unit id="e1baedfd2936afaf34298be8c53a6f3520c17d3e" translate="yes" xml:space="preserve">
          <source>Quiet; do not warn about conflicts.</source>
          <target state="translated">조용한; 갈등에 대해 경고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e9770de83f70890562d92f9477d5315581d69261" translate="yes" xml:space="preserve">
          <source>Quite similarly, if &lt;code&gt;core.symlinks&lt;/code&gt; configuration variable is set to &lt;code&gt;false&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;), symbolic links are checked out as plain files, and this command does not modify a recorded file mode from symbolic link to regular file.</source>
          <target state="translated">마찬가지로 &lt;code&gt;core.symlinks&lt;/code&gt; 구성 변수가 &lt;code&gt;false&lt;/code&gt; 로 설정되면 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 참조) 기호 링크는 일반 파일로 체크 아웃 되며이 명령은 기호 링크에서 일반 파일로 기록 된 파일 모드를 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f0f61d9660842b035df0296041289cbf85b3ae28" translate="yes" xml:space="preserve">
          <source>Quote fields containing whitespace as if they were strings in C source code; i.e., surrounded by double-quotes and with backslash escapes. Use 40 &quot;0&quot; characters or the empty string to specify a zero value. To specify a missing value, omit the value and its preceding SP entirely.</source>
          <target state="translated">공백이 포함 된 필드를 마치 C 소스 코드의 문자열 인 것처럼 인용하십시오. 즉, 큰 따옴표로 묶고 백 슬래시 이스케이프 처리합니다. 40 개의 &quot;0&quot;문자 또는 빈 문자열을 사용하여 0 값을 지정하십시오. 결 측값을 지정하려면 값과 이전 SP를 완전히 생략하십시오.</target>
        </trans-unit>
        <trans-unit id="0550aeb8801a3ad8332244f3d277c748ecb56080" translate="yes" xml:space="preserve">
          <source>Quoted aliases and quoted addresses are not supported: lines that contain a &lt;code&gt;&quot;&lt;/code&gt; symbol are ignored.</source>
          <target state="translated">인용 된 별명 및 인용 된 주소는 지원되지 않습니다 . &lt;code&gt;&quot;&lt;/code&gt; 기호가 포함 된 행 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="06576556d1ad802f247cad11ae748be47b70cd9c" translate="yes" xml:space="preserve">
          <source>R</source>
          <target state="translated">R</target>
        </trans-unit>
        <trans-unit id="38354f3564dc690008158ec27147b7718eef20da" translate="yes" xml:space="preserve">
          <source>R: renaming of a file</source>
          <target state="translated">R : 파일 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="73ff05a9f629bff633fa7a0499495556f0f1a07f" translate="yes" xml:space="preserve">
          <source>README.html</source>
          <target state="translated">README.html</target>
        </trans-unit>
        <trans-unit id="986c96108f4514e08f8de60c616ff1d0727fd986" translate="yes" xml:space="preserve">
          <source>REMOTE_ADDR</source>
          <target state="translated">REMOTE_ADDR</target>
        </trans-unit>
        <trans-unit id="613cec3f00ac4a24def4b10bec39e10198b8d82e" translate="yes" xml:space="preserve">
          <source>REMOTE_USER</source>
          <target state="translated">REMOTE_USER</target>
        </trans-unit>
        <trans-unit id="a16e10b928e7c21c5b4ae3d47f9db3c0b6c782c3" translate="yes" xml:space="preserve">
          <source>REQUEST_METHOD</source>
          <target state="translated">REQUEST_METHOD</target>
        </trans-unit>
        <trans-unit id="697070f17a70b2490138caae401415ac7b401fbd" translate="yes" xml:space="preserve">
          <source>RFC 2822</source>
          <target state="translated">RFC 2822</target>
        </trans-unit>
        <trans-unit id="b34db1f303fd91c6e7039f452d5097c789b26cf1" translate="yes" xml:space="preserve">
          <source>Rather than checking out a branch to work on it, check out a commit for inspection and discardable experiments. This is the default behavior of &lt;code&gt;git checkout &amp;lt;commit&amp;gt;&lt;/code&gt; when &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; is not a branch name. See the &quot;DETACHED HEAD&quot; section below for details.</source>
          <target state="translated">작업 할 지점을 확인하는 대신 검사 및 폐기 가능한 실험에 대한 커밋을 확인하십시오. &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 이 분기 이름이 아닌 경우 &lt;code&gt;git checkout &amp;lt;commit&amp;gt;&lt;/code&gt; 의 기본 동작입니다 . 자세한 내용은 아래의 &quot;세부 헤드&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4e4bfd7d1a0190903bc19000a40525c987ff7008" translate="yes" xml:space="preserve">
          <source>Raw output format</source>
          <target state="translated">원시 출력 형식</target>
        </trans-unit>
        <trans-unit id="7b0a88cf0ceef9e929b45fca40ecfa70b119395a" translate="yes" xml:space="preserve">
          <source>Re-author p4 changes before submitting to p4. This option requires p4 admin privileges.</source>
          <target state="translated">p4에 제출하기 전에 p4 변경 사항을 다시 작성하십시오. 이 옵션에는 p4 관리자 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a3d5287f4feb36f53be9e482bea0b4f69488906a" translate="yes" xml:space="preserve">
          <source>Read &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more details about each hook.</source>
          <target state="translated">각 후크에 대한 자세한 내용은 &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="3c99ae2389e194940d6e9dae44358b0f59db22c3" translate="yes" xml:space="preserve">
          <source>Read a list of commits from stdin and commit them in reverse order. Only the leading sha1 is read from each line, so &lt;code&gt;git rev-list --pretty=oneline&lt;/code&gt; output can be used.</source>
          <target state="translated">stdin에서 커밋 목록을 읽고 역순으로 커밋합니다. 각 행에서 선행 sha1 만 읽으므로 &lt;code&gt;git rev-list --pretty=oneline&lt;/code&gt; 출력을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a81bd113ea455376c0709dc2b5dec2fbcc3eae4" translate="yes" xml:space="preserve">
          <source>Read a packed archive (.pack) from the standard input, expanding the objects contained within and writing them into the repository in &quot;loose&quot; (one object per file) format.</source>
          <target state="translated">표준 입력에서 압축 된 아카이브 (.pack)를 읽고 포함 된 오브젝트를 확장하고 &quot;느슨한&quot;(파일 당 하나의 오브젝트) 형식으로 저장소에 씁니다.</target>
        </trans-unit>
        <trans-unit id="cf4f210605880935e907e739e930d70c6c05f393" translate="yes" xml:space="preserve">
          <source>Read a patch from the standard input and compute the patch ID for it.</source>
          <target state="translated">표준 입력에서 패치를 읽고 패치 ID를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="118b284f547f2475f4692a5a06eacb1fa689da5d" translate="yes" xml:space="preserve">
          <source>Read a tar archive created by &lt;code&gt;git archive&lt;/code&gt; from the standard input and extract the commit ID stored in it. It reads only the first 1024 bytes of input, thus its runtime is not influenced by the size of the tar archive very much.</source>
          <target state="translated">표준 입력에서 &lt;code&gt;git archive&lt;/code&gt; archive로 작성된 tar 아카이브를 읽고 저장된 커밋 ID를 추출하십시오. 처음 1024 바이트의 입력 만 읽으므로 런타임은 tar 아카이브의 크기에 크게 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8323be41a83f5e8edd45cebf33794d8211b9a65a" translate="yes" xml:space="preserve">
          <source>Read additional exclude patterns that apply only to the directory and its subdirectories in &amp;lt;file&amp;gt;.</source>
          <target state="translated">&amp;lt;file&amp;gt;의 디렉토리 및 해당 서브 디렉토리에만 적용되는 추가 제외 패턴을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="ec538abd0ecb84f4afa31116a9fde4a7bfbfc841" translate="yes" xml:space="preserve">
          <source>Read contacts, one per line, from the standard input after exhausting contacts provided on the command-line.</source>
          <target state="translated">명령 행에 제공된 접점을 모두 사용한 후 표준 입력에서 접점을 한 줄에 하나씩 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="cc8be265c5565879cb19acef5a95bb650b329807" translate="yes" xml:space="preserve">
          <source>Read description of &lt;code&gt;%feature&lt;/code&gt; hash for detailed list, and descriptions. See also &quot;Configuring gitweb features&quot; section in &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;</source>
          <target state="translated">자세한 목록과 설명은 &lt;code&gt;%feature&lt;/code&gt; 해시에 대한 설명을 읽으십시오 . &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf의&lt;/a&gt; &quot;gitweb 기능 구성&quot;섹션도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="15ad57eb2da16d3087f86e421c960f711d5a7f97" translate="yes" xml:space="preserve">
          <source>Read exclude patterns from &amp;lt;file&amp;gt;; 1 per line.</source>
          <target state="translated">&amp;lt;file&amp;gt;에서 제외 패턴을 읽습니다. 한 줄에 1 개.</target>
        </trans-unit>
        <trans-unit id="f6c76b424f91b25c9b13ee14e1604c5d3fa96f28" translate="yes" xml:space="preserve">
          <source>Read file names from the standard input, one per line, instead of from the command-line.</source>
          <target state="translated">명령 줄 대신 표준 입력에서 한 줄에 하나씩 파일 이름을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="d0b5b313182b086a1f9af39ecd4467e46faca9cf" translate="yes" xml:space="preserve">
          <source>Read index information from stdin.</source>
          <target state="translated">stdin에서 색인 정보를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="80670c79001d8f8c9a5be5d38404bf833dac649e" translate="yes" xml:space="preserve">
          <source>Read its description.</source>
          <target state="translated">설명을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="46ab10e675175e0e453c98d42b078fb4b46c2856" translate="yes" xml:space="preserve">
          <source>Read pathnames from the standard input, one per line, instead of from the command-line.</source>
          <target state="translated">명령 줄 대신 표준 입력에서 한 줄에 하나씩 경로 이름을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="e51b79a68429169e8d905bac10a875d5d0bc0bbc" translate="yes" xml:space="preserve">
          <source>Read patterns from &amp;lt;file&amp;gt;, one per line.</source>
          <target state="translated">&amp;lt;파일&amp;gt;에서 한 줄에 하나씩 패턴을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="742eb52188cd86d4cd26b3ac213de9e008afe01b" translate="yes" xml:space="preserve">
          <source>Read refspecs, one per line, from stdin in addition to those provided as arguments. The &quot;tag &amp;lt;name&amp;gt;&quot; format is not supported.</source>
          <target state="translated">인수로 제공된 것 외에도 stdin에서 한 줄에 하나씩 refspec을 읽습니다. &quot;태그 &amp;lt;이름&amp;gt;&quot;형식은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fed49b353bd2e8ef2071f098ea90e8175a16e2cc" translate="yes" xml:space="preserve">
          <source>Read text, such as commit messages, notes, tags and branch descriptions, from the standard input and clean it in the manner used by Git.</source>
          <target state="translated">커밋 메시지, 노트, 태그 및 분기 설명과 같은 텍스트를 표준 입력에서 읽고 Git에서 사용하는 방식으로 정리하십시오.</target>
        </trans-unit>
        <trans-unit id="eceb0ad0aa215d85bc1cfa0886bd096a3daed30d" translate="yes" xml:space="preserve">
          <source>Read the &lt;code&gt;.idx&lt;/code&gt; file for a Git packfile (created with &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; or &lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack[1]&lt;/a&gt;) from the standard input, and dump its contents. The output consists of one object per line, with each line containing two or three space-separated columns:</source>
          <target state="translated">표준 입력에서 Git &lt;a href=&quot;git-pack-objects&quot;&gt;팩&lt;/a&gt; 파일 ( git-pack-objects [1] 또는 &lt;a href=&quot;git-index-pack&quot;&gt;git-index-pack [1]로 작성&lt;/a&gt; ) 의 &lt;code&gt;.idx&lt;/code&gt; 파일을 읽고 내용을 덤프하십시오. 출력은 한 줄에 하나의 객체로 구성되며 각 줄에는 두 개 또는 세 개의 공백으로 구분 된 열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ddd6a34883963a795d5ebc22563eef2cf30acd2b" translate="yes" xml:space="preserve">
          <source>Read the NUL-terminated &lt;code&gt;ls-tree -z&lt;/code&gt; output instead.</source>
          <target state="translated">대신 NUL 종료 &lt;code&gt;ls-tree -z&lt;/code&gt; 출력을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="3ea8fc0021add956f340de030bf6e8165a69896f" translate="yes" xml:space="preserve">
          <source>Read the commit log message from the given file. Use &lt;code&gt;-&lt;/code&gt; to read from the standard input. This can be given more than once and the content of each file becomes its own paragraph.</source>
          <target state="translated">주어진 파일에서 커밋 로그 메시지를 읽습니다. &lt;code&gt;-&lt;/code&gt; 를 사용 하여 표준 입력에서 읽습니다. 이것은 두 번 이상 주어질 수 있으며 각 파일의 내용은 자체 단락이됩니다.</target>
        </trans-unit>
        <trans-unit id="507fdedba9f69c5efbd0e8cf829abe30d4a7a120" translate="yes" xml:space="preserve">
          <source>Read the commit message to be used for the merge commit (in case one is created).</source>
          <target state="translated">병합 커밋에 사용될 커밋 메시지를 읽습니다 (만약 커밋 메시지가 생성 된 경우).</target>
        </trans-unit>
        <trans-unit id="9362ea89cc38e10989edc212ebc0bf489cc001f5" translate="yes" xml:space="preserve">
          <source>Read the commit-graph file and verify its contents against the object database. Used to check for corrupted data.</source>
          <target state="translated">커밋 그래프 파일을 읽고 그 내용을 객체 데이터베이스와 비교하여 확인하십시오. 손상된 데이터를 확인하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9e4092c6ffe69dbb6a8bf7641feea7e173111c93" translate="yes" xml:space="preserve">
          <source>Read the object from standard input instead of from a file.</source>
          <target state="translated">파일 대신 표준 입력에서 객체를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="16a5e93c91809d39b015e5b24abf65dd6438e038" translate="yes" xml:space="preserve">
          <source>Read the revision arguments from the standard input, instead of individual object names. The revision arguments are processed the same way as &lt;code&gt;git rev-list&lt;/code&gt; with the &lt;code&gt;--objects&lt;/code&gt; flag uses its &lt;code&gt;commit&lt;/code&gt; arguments to build the list of objects it outputs. The objects on the resulting list are packed. Besides revisions, &lt;code&gt;--not&lt;/code&gt; or &lt;code&gt;--shallow &amp;lt;SHA-1&amp;gt;&lt;/code&gt; lines are also accepted.</source>
          <target state="translated">개별 객체 이름 대신 표준 입력에서 개정 인수를 읽으십시오. 개정 인수는 &lt;code&gt;--objects&lt;/code&gt; 플래그를 사용하여 &lt;code&gt;git rev-list&lt;/code&gt; 와 동일한 방식으로 처리되어 &lt;code&gt;commit&lt;/code&gt; 인수를 사용하여 출력하는 객체 목록을 작성합니다. 결과 목록의 개체가 압축됩니다. 개정 외에도, &lt;code&gt;--not&lt;/code&gt; 또는 &lt;code&gt;--shallow &amp;lt;SHA-1&amp;gt;&lt;/code&gt; 라인도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f840070f6a18eee1c3de888e1eec475edd1cfa4" translate="yes" xml:space="preserve">
          <source>Read, modify and delete symbolic refs</source>
          <target state="translated">기호 참조 읽기, 수정 및 삭제</target>
        </trans-unit>
        <trans-unit id="356b6782c6512845fae8c2da14d692d4da174e8d" translate="yes" xml:space="preserve">
          <source>Reading from a named tree</source>
          <target state="translated">명명 된 나무에서 읽기</target>
        </trans-unit>
        <trans-unit id="7405316147ea4906cae4c658957705537066053b" translate="yes" xml:space="preserve">
          <source>Reading from the active commit</source>
          <target state="translated">활성 커밋에서 읽기</target>
        </trans-unit>
        <trans-unit id="d5df5dafb2331c4e6af80c2f8a0c26176a288dab" translate="yes" xml:space="preserve">
          <source>Reads a packed archive (.pack) from the specified file, and builds a pack index file (.idx) for it. The packed archive together with the pack index can then be placed in the objects/pack/ directory of a Git repository.</source>
          <target state="translated">지정된 파일에서 압축 된 아카이브 (.pack)를 읽고이를위한 팩 색인 파일 (.idx)을 빌드합니다. 팩 인덱스와 함께 압축 아카이브는 Git 저장소의 objects / pack / 디렉토리에 배치 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db9526754c129c75f60022c8e34e8db9d6855fac" translate="yes" xml:space="preserve">
          <source>Reads a single e-mail message from the standard input, and writes the commit log message in &amp;lt;msg&amp;gt; file, and the patches in &amp;lt;patch&amp;gt; file. The author name, e-mail and e-mail subject are written out to the standard output to be used by &lt;code&gt;git am&lt;/code&gt; to create a commit. It is usually not necessary to use this command directly. See &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; instead.</source>
          <target state="translated">표준 입력에서 단일 전자 메일 메시지를 읽고 커밋 로그 메시지를 &amp;lt;msg&amp;gt; 파일에 기록하고 패치를 &amp;lt;patch&amp;gt; 파일에 기록합니다. 작성자 이름, 전자 우편 및 전자 우편 제목은 표준 출력에 기록되어 커밋을 작성하기 위해 &lt;code&gt;git am&lt;/code&gt; 에서 사용됩니다 . 일반적으로이 명령을 직접 사용할 필요는 없습니다. 대신 &lt;a href=&quot;git-am&quot;&gt;git-am [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="91a54b1043f609f02e31617fc1ed3b549e2a4394" translate="yes" xml:space="preserve">
          <source>Reads a tag contents on standard input and creates a tag object that can also be used to sign other objects.</source>
          <target state="translated">표준 입력에서 태그 내용을 읽고 다른 객체에 서명하는 데 사용할 수있는 태그 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1988117fbbba1a52186c7874f472ad690b235ffc" translate="yes" xml:space="preserve">
          <source>Reads given idx file for packed Git archive created with the &lt;code&gt;git pack-objects&lt;/code&gt; command and verifies idx file and the corresponding pack file.</source>
          <target state="translated">&lt;code&gt;git pack-objects&lt;/code&gt; 명령으로 생성 된 압축 된 Git 아카이브에 대해 지정된 idx 파일을 읽고 idx 파일과 해당 팩 파일을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="befcf9896fcbea450fd9bee257995fb96286ee5a" translate="yes" xml:space="preserve">
          <source>Reads list of objects from the standard input, and writes either one or more packed archives with the specified base-name to disk, or a packed archive to the standard output.</source>
          <target state="translated">표준 입력에서 오브젝트 목록을 읽고 지정된 기본 이름을 가진 하나 이상의 압축 아카이브를 디스크에 또는 압축 아카이브를 표준 출력에 씁니다.</target>
        </trans-unit>
        <trans-unit id="d7a9d36099b1ff6ac5bd15dd14e16c269b0389b8" translate="yes" xml:space="preserve">
          <source>Reads standard input in non-recursive &lt;code&gt;ls-tree&lt;/code&gt; output format, and creates a tree object. The order of the tree entries is normalized by mktree so pre-sorting the input is not required. The object name of the tree object built is written to the standard output.</source>
          <target state="translated">비 재귀 &lt;code&gt;ls-tree&lt;/code&gt; 출력 형식으로 표준 입력을 읽고 트리 객체를 만듭니다. 트리 항목의 순서는 mktree에 의해 정규화되므로 입력을 사전 정렬 할 필요가 없습니다. 빌드 된 트리 개체의 개체 이름이 표준 출력에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="768de97d393241af581368bdb5b60add6bc4daa9" translate="yes" xml:space="preserve">
          <source>Reads the supplied diff output (i.e. &quot;a patch&quot;) and applies it to files. When running from a subdirectory in a repository, patched paths outside the directory are ignored. With the &lt;code&gt;--index&lt;/code&gt; option the patch is also applied to the index, and with the &lt;code&gt;--cached&lt;/code&gt; option the patch is only applied to the index. Without these options, the command applies the patch only to files, and does not require them to be in a Git repository.</source>
          <target state="translated">제공된 diff 출력 (예 : &quot;패치&quot;)을 읽고 파일에 적용합니다. 저장소의 서브 디렉토리에서 실행할 때 디렉토리 외부의 패치 된 경로는 무시됩니다. 으로 &lt;code&gt;--index&lt;/code&gt; 옵션 패치는 인덱스에 적용되고, 함께 &lt;code&gt;--cached&lt;/code&gt; 옵션 패치는 인덱스에 적용됩니다. 이러한 옵션이 없으면 명령은 파일에만 패치를 적용하며 Git 리포지토리에있을 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5173f184d3064943fb31ef4b9c751d1119e1685" translate="yes" xml:space="preserve">
          <source>Reads the tree information given by &amp;lt;tree-ish&amp;gt; into the index, but does not actually &lt;strong&gt;update&lt;/strong&gt; any of the files it &quot;caches&quot;. (see: &lt;a href=&quot;git-checkout-index&quot;&gt;git-checkout-index[1]&lt;/a&gt;)</source>
          <target state="translated">&amp;lt;tree-ish&amp;gt;가 제공 한 트리 정보를 인덱스로 읽지 만 실제로 &quot;캐시&quot;하는 파일은 &lt;strong&gt;업데이트&lt;/strong&gt; 하지 않습니다 . ( &lt;a href=&quot;git-checkout-index&quot;&gt;git-checkout-index [1] 참조&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="e432986c9c0bf1c0563c54e4546289b72e2b8f05" translate="yes" xml:space="preserve">
          <source>Reads three tree-ish, and output trivial merge results and conflicting stages to the standard output. This is similar to what three-way &lt;code&gt;git read-tree -m&lt;/code&gt; does, but instead of storing the results in the index, the command outputs the entries to the standard output.</source>
          <target state="translated">3 가지 트리 -ish를 읽고 사소한 병합 결과와 충돌하는 단계를 표준 출력으로 출력합니다. 이것은 3-way &lt;code&gt;git read-tree -m&lt;/code&gt; 과 유사 하지만 결과를 색인에 저장하는 대신 항목을 표준 출력으로 출력합니다.</target>
        </trans-unit>
        <trans-unit id="47a594db00e7ab66962cb542d6f07d66a982ad3f" translate="yes" xml:space="preserve">
          <source>Reads tree information into the index</source>
          <target state="translated">색인으로 트리 정보를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="cd01faf1694de2fbbfa60db859fa0d8c2fb7a091" translate="yes" xml:space="preserve">
          <source>Reapply all clean cherry-picks of any upstream commit instead of preemptively dropping them. (If these commits then become empty after rebasing, because they contain a subset of already upstream changes, the behavior towards them is controlled by the &lt;code&gt;--empty&lt;/code&gt; flag.)</source>
          <target state="translated">모든 업스트림 커밋의 모든 깨끗한 체리 픽을 선제 적으로 삭제하는 대신 다시 적용하십시오. (이미 업스트림 변경 사항의 하위 집합이 포함되어 있기 때문에 이러한 커밋이 리베이스 후 비어있게되면 &lt;code&gt;--empty&lt;/code&gt; 플래그로 동작을 제어합니다 .)</target>
        </trans-unit>
        <trans-unit id="209b43abaea4b5ac5dbb8b759ed99ebfaf6f9172" translate="yes" xml:space="preserve">
          <source>Reapply commits on top of another base tip</source>
          <target state="translated">다른 기본 팁 위에 다시 적용</target>
        </trans-unit>
        <trans-unit id="b5f89f19a4f1bfbd626812410183459baf015069" translate="yes" xml:space="preserve">
          <source>Reapply the sparsity pattern rules to paths in the working tree. Commands like merge or rebase can materialize paths to do their work (e.g. in order to show you a conflict), and other sparse-checkout commands might fail to sparsify an individual file (e.g. because it has unstaged changes or conflicts). In such cases, it can make sense to run &lt;code&gt;git sparse-checkout reapply&lt;/code&gt; later after cleaning up affected paths (e.g. resolving conflicts, undoing or committing changes, etc.).</source>
          <target state="translated">작업 트리의 경로에 희소성 패턴 규칙을 다시 적용합니다. merge 또는 rebase와 같은 명령은 작업을 수행하기 위해 경로를 구체화 할 수 있으며 (예 : 충돌을 표시하기 위해), 다른 sparse-checkout 명령은 개별 파일을 희소 화하지 못할 수 있습니다 (예 : 단계 화되지 않은 변경 또는 충돌이 있기 때문에). 이러한 경우 영향을받는 경로를 정리 한 후 나중에 &lt;code&gt;git sparse-checkout reapply&lt;/code&gt; 를 실행 하는 것이 좋습니다 (예 : 충돌 해결, 변경 취소 또는 커밋 등).</target>
        </trans-unit>
        <trans-unit id="95695a29b19740f8f73c24fedd25acfa8a46012d" translate="yes" xml:space="preserve">
          <source>Rebase</source>
          <target state="translated">Rebase</target>
        </trans-unit>
        <trans-unit id="f805426f874c522ca8e3397a261d025324269dce" translate="yes" xml:space="preserve">
          <source>Rebase all commits reachable from &amp;lt;branch&amp;gt;, instead of limiting them with an &amp;lt;upstream&amp;gt;. This allows you to rebase the root commit(s) on a branch. When used with --onto, it will skip changes already contained in &amp;lt;newbase&amp;gt; (instead of &amp;lt;upstream&amp;gt;) whereas without --onto it will operate on every change. When used together with both --onto and --preserve-merges, &lt;code&gt;all&lt;/code&gt; root commits will be rewritten to have &amp;lt;newbase&amp;gt; as parent instead.</source>
          <target state="translated">&amp;lt;업스트림&amp;gt;으로 제한하는 대신 &amp;lt;branch&amp;gt;에서 도달 가능한 모든 커밋을 리베이스하십시오. 이를 통해 브랜치에서 루트 커밋을 리베이스 할 수 있습니다. --onto와 함께 사용하면 &amp;lt;upbase&amp;gt; 대신 &amp;lt;newbase&amp;gt;에 이미 포함 된 변경 사항을 건너 뛰고 --onto를 사용하지 않으면 모든 변경에 대해 작동합니다. --onto 및 --preserve-merges와 함께 사용하면 &lt;code&gt;all&lt;/code&gt; 루트 커밋이 대신 &amp;lt;newbase&amp;gt;를 부모로 갖도록 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="e5565e2c078bf46f769d916c78f2140677ea9bef" translate="yes" xml:space="preserve">
          <source>Rebase options</source>
          <target state="translated">리베이스 옵션</target>
        </trans-unit>
        <trans-unit id="716069514beaa612afd8a844f284c8d0a6aabce4" translate="yes" xml:space="preserve">
          <source>Rebase vs. pull/merge</source>
          <target state="translated">리베이스 대 풀 / 병합</target>
        </trans-unit>
        <trans-unit id="5e20f7eeaec14e3dc573b7394eb6cd8341f1bca1" translate="yes" xml:space="preserve">
          <source>Rebase your current HEAD on the last commit you want to retain as-is. For example, if you want to reorder the last 5 commits, use:</source>
          <target state="translated">현재 HEAD를 그대로 유지하려는 마지막 커밋에 리베이스하십시오. 예를 들어, 마지막 5 개의 커밋을 재정렬하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7170c51391b558eaee43fbe3f7e40861483475fb" translate="yes" xml:space="preserve">
          <source>Rebasing (or any other form of rewriting) a branch that others have based work on is a bad idea: anyone downstream of it is forced to manually fix their history. This section explains how to do the fix from the downstream&amp;rsquo;s point of view. The real fix, however, would be to avoid rebasing the upstream in the first place.</source>
          <target state="translated">다른 사람이 작업 한 브랜치를 리베이스 (또는 다른 형태의 재 작성)하는 것은 나쁜 생각입니다. 다운 스트림의 모든 사람은 수동으로 히스토리를 수정해야합니다. 이 섹션에서는 다운 스트림 관점에서 수정을 수행하는 방법에 대해 설명합니다. 그러나 실제 수정은 처음부터 업스트림을 리베이스하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8f0767f1f4e33ddf301ed23c7f2cab0332acde8d" translate="yes" xml:space="preserve">
          <source>Rebasing interactively means that you have a chance to edit the commits which are rebased. You can reorder the commits, and you can remove them (weeding out bad or otherwise unwanted patches).</source>
          <target state="translated">대화식으로 리베이스한다는 것은 리베이스 된 커밋을 편집 할 수있는 기회를 의미합니다. 커밋을 재정렬하고 제거 할 수 있습니다 (나쁘거나 원치 않는 패치를 제거).</target>
        </trans-unit>
        <trans-unit id="451ba45ef5ba504d79efe1ccb8ef4e6b541d4b90" translate="yes" xml:space="preserve">
          <source>Rebasing merges</source>
          <target state="translated">리베이스 링 병합</target>
        </trans-unit>
        <trans-unit id="f41810dd94a2ab482398f10cf85665624d62733a" translate="yes" xml:space="preserve">
          <source>Recall that merge commits may have more than one parent; by default, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; follow the first parent listed in the commit, but you can also choose:</source>
          <target state="translated">병합 커밋에는 둘 이상의 부모가있을 수 있습니다. 기본적으로 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;~&lt;/code&gt; 는 커밋에 나열된 첫 번째 부모를 따르지만 다음을 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b37c74948935714b7fd73afa3de16cd064ee51d6" translate="yes" xml:space="preserve">
          <source>Recall that the commit which will be committed after we resolve this conflict will have two parents instead of the usual one: one parent will be HEAD, the tip of the current branch; the other will be the tip of the other branch, which is stored temporarily in MERGE_HEAD.</source>
          <target state="translated">우리가이 갈등을 해결 한 후에 커밋 될 커밋은 일반적인 부모 대신 두 부모가있을 것입니다 : 한 부모는 HEAD, 현재 지점의 끝; 다른 하나는 다른 분기의 끝이며 MERGE_HEAD에 임시 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9f6cd666ff59558e35fc1e4987f55228a4aa839c" translate="yes" xml:space="preserve">
          <source>Receive missing objects from another repository</source>
          <target state="translated">다른 저장소에서 누락 된 객체 수신</target>
        </trans-unit>
        <trans-unit id="3a1414f04e5ec5736bdcd32788841a475c616871" translate="yes" xml:space="preserve">
          <source>Receive what is pushed into the repository</source>
          <target state="translated">저장소에 푸시 된 내용을받습니다.</target>
        </trans-unit>
        <trans-unit id="ca8f48326e259b3e6bb0b952b7bb30d324f93b41" translate="yes" xml:space="preserve">
          <source>Recipe: Copy maint</source>
          <target state="translated">레시피 : 복사 메인</target>
        </trans-unit>
        <trans-unit id="53d4283d5e8f18dd173ab180112f372c62ec5838" translate="yes" xml:space="preserve">
          <source>Recipe: Push/pull: Merging remote topics</source>
          <target state="translated">레시피 : 푸시 / 풀 : 원격 토픽 병합</target>
        </trans-unit>
        <trans-unit id="1f8640f7861cc46b56a1e4b42e9ca596b559f6db" translate="yes" xml:space="preserve">
          <source>Recipe: Push/pull: Publishing branches/topics</source>
          <target state="translated">레시피 : 푸시 / 풀 : 분기 / 주제 게시</target>
        </trans-unit>
        <trans-unit id="3a17d2c389fe13fb57af10dbacfb6b3db024c7c4" translate="yes" xml:space="preserve">
          <source>Recipe: Push/pull: Staying up to date</source>
          <target state="translated">레시피 : 푸시 / 풀 : 최신 상태 유지</target>
        </trans-unit>
        <trans-unit id="02b6d43b8510b59229854c014a4620861f29d737" translate="yes" xml:space="preserve">
          <source>Recipe: Release tagging</source>
          <target state="translated">레시피 : 태그 해제</target>
        </trans-unit>
        <trans-unit id="9d28e02794d321eb00b6d5b97832a596837552b2" translate="yes" xml:space="preserve">
          <source>Recipe: Rewind and rebuild next</source>
          <target state="translated">레시피 : 다음 되감기 및 다시 빌드</target>
        </trans-unit>
        <trans-unit id="f8152ab6d8ec6437faa103dde674cb065aa68613" translate="yes" xml:space="preserve">
          <source>Recipe: Update maint to new release</source>
          <target state="translated">레시피 : 메인 릴리스를 새로운 릴리즈로 업데이트</target>
        </trans-unit>
        <trans-unit id="29ee8bda8dd5e0f017624c7f75aa875a53804d32" translate="yes" xml:space="preserve">
          <source>Recipe: Verify &lt;em&gt;master&lt;/em&gt; is a superset of &lt;em&gt;maint&lt;/em&gt;</source>
          <target state="translated">레시피 : 확인 &lt;em&gt;마스터&lt;/em&gt; 의 상위 집합입니다 &lt;em&gt;MAINT&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ffd09f97e74a882a55504c37b0826f564e6b1346" translate="yes" xml:space="preserve">
          <source>Recipe: format-patch/am: Importing patches</source>
          <target state="translated">레시피 : format-patch / am : 패치 가져 오기</target>
        </trans-unit>
        <trans-unit id="363c9c30e4fafba7e8fc9192a52c83213c41b8ac" translate="yes" xml:space="preserve">
          <source>Recipe: format-patch/am: Keeping topics up to date</source>
          <target state="translated">레시피 : format-patch / am : 주제를 최신 상태로 유지</target>
        </trans-unit>
        <trans-unit id="677a69c96c088fbfbe55531cae388f0a94e79290" translate="yes" xml:space="preserve">
          <source>Recipe: format-patch/am: Publishing branches/topics</source>
          <target state="translated">레시피 : format-patch / am : 분기 / 주제 게시</target>
        </trans-unit>
        <trans-unit id="7c405acad54185184a3b50d9aee58d7a13bab6ed" translate="yes" xml:space="preserve">
          <source>Recompress, remove unused cruft:</source>
          <target state="translated">재 압축하고 사용하지 않는 부스러기를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="257831ab2bd13a64966a7f962a9574ea39ef3108" translate="yes" xml:space="preserve">
          <source>Record changes to the repository</source>
          <target state="translated">저장소에 변경 사항 기록</target>
        </trans-unit>
        <trans-unit id="13168b3a0cbb28fba7cf06c3c640480d4de874bc" translate="yes" xml:space="preserve">
          <source>Record only the fact that the path will be added later. An entry for the path is placed in the index with no content. This is useful for, among other things, showing the unstaged content of such files with &lt;code&gt;git diff&lt;/code&gt; and committing them with &lt;code&gt;git commit
-a&lt;/code&gt;.</source>
          <target state="translated">경로가 나중에 추가된다는 사실 만 기록하십시오. 경로에 대한 항목은 내용이없는 색인에 배치됩니다. 이것은 특히 &lt;code&gt;git diff&lt;/code&gt; 를 사용 하여 이러한 파일의 스테이지되지 않은 내용을 표시하고 &lt;code&gt;git commit -a&lt;/code&gt; 커밋하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="908f8c6524a9d1fb52d4fa427c4917cc570c6355" translate="yes" xml:space="preserve">
          <source>Record that a mark refers to a given object without first creating any new object.</source>
          <target state="translated">마크는 먼저 새 객체를 만들지 않고 주어진 객체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="59ee078874bbbc459021c0c530f38bc7aaf471b2" translate="yes" xml:space="preserve">
          <source>Record that a mark refers to a given object without first creating any new object. Using --import-marks and referring to missing marks will cause fast-import to fail, so aliases can provide a way to set otherwise pruned commits to a valid value (e.g. the nearest non-pruned ancestor).</source>
          <target state="translated">마크는 먼저 새 객체를 만들지 않고 주어진 객체를 나타냅니다. --import-marks를 사용하고 누락 된 마크를 참조하면 빠른 가져 오기가 실패하므로 별칭을 사용하면 제거 된 커밋을 유효한 값 (예 : 가장 잘리지 않은 상위 ​​조상)으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6adcb873ab9c7cd434052b29bbda78059575713" translate="yes" xml:space="preserve">
          <source>Record the base tree information to identify the state the patch series applies to. See the BASE TREE INFORMATION section below for details. If &amp;lt;commit&amp;gt; is &quot;auto&quot;, a base commit is automatically chosen. The &lt;code&gt;--no-base&lt;/code&gt; option overrides a &lt;code&gt;format.useAutoBase&lt;/code&gt; configuration.</source>
          <target state="translated">패치 시리즈가 적용되는 상태를 식별하기 위해 기본 트리 정보를 기록하십시오. 자세한 내용은 아래의 기본 트리 정보 섹션을 참조하십시오. &amp;lt;commit&amp;gt;이 &quot;auto&quot;이면 기본 커밋이 자동으로 선택됩니다. &lt;code&gt;--no-base&lt;/code&gt; 옵션은 무시 &lt;code&gt;format.useAutoBase&lt;/code&gt; 의 구성.</target>
        </trans-unit>
        <trans-unit id="1df60f45066883b70333fa04c8ca0ea0ac9a963e" translate="yes" xml:space="preserve">
          <source>Record the pristine state as the first commit in the history.</source>
          <target state="translated">역사에서 첫 번째 커밋으로 원시 상태를 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="2779532bfc36fb35edea59aae8e6a7c58766f0fd" translate="yes" xml:space="preserve">
          <source>Records all changes made to the branch tip named &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 이라는 브랜치 팁에 대한 모든 변경 사항을 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="e26cb9a4392a1984a3c8c89ac8ba4d1939bfa972" translate="yes" xml:space="preserve">
          <source>Records all changes made to the tag named &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 태그의 모든 변경 사항을 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="b4426300ccfff51ab94cf09d14eb70cb666bb2d4" translate="yes" xml:space="preserve">
          <source>Records of changes made to refs are stored in this directory. See &lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref[1]&lt;/a&gt; for more information. This directory is ignored (except logs/HEAD) if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/logs&quot; will be used instead.</source>
          <target state="translated">심판에 대한 변경 기록은이 디렉토리에 저장됩니다. 자세한 내용은 &lt;a href=&quot;git-update-ref&quot;&gt;git-update-ref [1]&lt;/a&gt; 을 참조하십시오. $ GIT_COMMON_DIR이 설정되고 대신 &quot;$ GIT_COMMON_DIR / logs&quot;가 사용되는 경우이 디렉토리는 무시됩니다 (로그 / HEAD 제외).</target>
        </trans-unit>
        <trans-unit id="4dfb1dccefe8c5960e96ace8700ff3694a2adfa8" translate="yes" xml:space="preserve">
          <source>Records of conflicted merge you have not resolved are kept for this many days when &lt;code&gt;git rerere gc&lt;/code&gt; is run. You can also use more human-readable &quot;1.month.ago&quot;, etc. The default is 15 days. See &lt;a href=&quot;git-rerere&quot;&gt;git-rerere[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;git rerere gc&lt;/code&gt; 가 실행될 때 해결되지 않은 충돌 병합 레코드는 며칠 동안 유지됩니다 . 보다 읽기 쉬운 &quot;1.month.ago&quot;등을 사용할 수도 있습니다. 기본값은 15 일입니다. &lt;a href=&quot;git-rerere&quot;&gt;git-rerere [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0041a23358783dc658fb86af817bd1e3c4818754" translate="yes" xml:space="preserve">
          <source>Records of conflicted merge you resolved earlier are kept for this many days when &lt;code&gt;git rerere gc&lt;/code&gt; is run. You can also use more human-readable &quot;1.month.ago&quot;, etc. The default is 60 days. See &lt;a href=&quot;git-rerere&quot;&gt;git-rerere[1]&lt;/a&gt;.</source>
          <target state="translated">이전에 해결 한 충돌 병합 레코드는 &lt;code&gt;git rerere gc&lt;/code&gt; 가 실행될 때 며칠 동안 유지됩니다 . 보다 읽기 쉬운 &quot;1.month.ago&quot;등을 사용할 수도 있습니다. 기본값은 60 일입니다. &lt;a href=&quot;git-rerere&quot;&gt;git-rerere [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f27ef1289a3377cd529d96e1d59f394c9d2e51b" translate="yes" xml:space="preserve">
          <source>Recovering from repository corruption</source>
          <target state="translated">저장소 손상 복구</target>
        </trans-unit>
        <trans-unit id="45b084fa0ec2bcf4d8887dcc1ed74808ce39dd65" translate="yes" xml:space="preserve">
          <source>Recovering from upstream rebase</source>
          <target state="translated">업스트림 리베이스에서 복구</target>
        </trans-unit>
        <trans-unit id="a2b2e17c2700a078248ea4a8793fdeb963f1e774" translate="yes" xml:space="preserve">
          <source>Recovering lost changes</source>
          <target state="translated">손실 된 변경 사항 복구</target>
        </trans-unit>
        <trans-unit id="c9f9ed2d4080ff53397fc95e602ba0c0a8018150" translate="yes" xml:space="preserve">
          <source>Recovering stash entries that were cleared/dropped erroneously</source>
          <target state="translated">잘못 삭제 / 삭제 된 숨김 항목 복구</target>
        </trans-unit>
        <trans-unit id="07417b29bf5742eeb9def793a7c341803a4ae6cf" translate="yes" xml:space="preserve">
          <source>Recurse into sub-trees.</source>
          <target state="translated">하위 트리로 재귀.</target>
        </trans-unit>
        <trans-unit id="a6bbb82b51ea9a73ca0b0838d88a88a52f49ad15" translate="yes" xml:space="preserve">
          <source>Recursively calls ls-files on each active submodule in the repository. Currently there is only support for the --cached mode.</source>
          <target state="translated">저장소의 각 활성 서브 모듈에서 ls 파일을 재귀 적으로 호출합니다. 현재는 --cached 모드 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b71ca4a78b12182052bd243bd7fb2b5a8710c342" translate="yes" xml:space="preserve">
          <source>Recursively calls ls-files on each submodule in the repository. Currently there is only support for the --cached mode.</source>
          <target state="translated">리포지토리의 각 하위 모듈에서 ls 파일을 반복적으로 호출합니다. 현재는 --cached 모드 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="9594ad54e61dba1e097011c1262a0e12523ac73c" translate="yes" xml:space="preserve">
          <source>Recursively copies an existing file or subdirectory to a different location within the branch. The existing file or directory must exist. If the destination exists it will be completely replaced by the content copied from the source.</source>
          <target state="translated">기존 파일 또는 하위 디렉토리를 분기 내 다른 위치에 재귀 적으로 복사합니다. 기존 파일 또는 디렉토리가 존재해야합니다. 대상이 존재하면 소스에서 복사 한 내용으로 완전히 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="784c487e0b0ebf6146a806df2269e12c1733d014" translate="yes" xml:space="preserve">
          <source>Recursively finds and lists the svn:ignore property on directories. The output is suitable for appending to the $GIT_DIR/info/exclude file.</source>
          <target state="translated">디렉토리에서 svn : ignore 특성을 반복적으로 찾고 나열합니다. 출력은 $ GIT_DIR / info / exclude 파일에 추가하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="8a1182cccab09515529f5c8d920459a7ff2c3ff2" translate="yes" xml:space="preserve">
          <source>Recursively finds the svn:ignore property on directories and creates matching .gitignore files. The resulting files are staged to be committed, but are not committed. Use -r/--revision to refer to a specific revision.</source>
          <target state="translated">디렉토리에서 svn : ignore 특성을 반복적으로 찾고 일치하는 .gitignore 파일을 작성합니다. 결과 파일은 커밋되도록 준비되었지만 커밋되지는 않습니다. -r /-revision을 사용하여 특정 개정을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8cf2dd32a75d92cd5c31b8e357091014ef76d06b" translate="yes" xml:space="preserve">
          <source>Recursively search in each submodule that has been initialized and checked out in the repository. When used in combination with the &amp;lt;tree&amp;gt; option the prefix of all submodule output will be the name of the parent project&amp;rsquo;s &amp;lt;tree&amp;gt; object.</source>
          <target state="translated">저장소에서 초기화되고 체크 아웃 된 각 서브 모듈에서 반복적으로 검색하십시오. &amp;lt;tree&amp;gt; 옵션과 함께 사용하면 모든 하위 모듈 출력의 접두사가 상위 프로젝트의 &amp;lt;tree&amp;gt; 객체 이름이됩니다.</target>
        </trans-unit>
        <trans-unit id="c91703d456763a97cd487b639be20f9ff2ca1d31" translate="yes" xml:space="preserve">
          <source>Recursively search in each submodule that is active and checked out in the repository. When used in combination with the &amp;lt;tree&amp;gt; option the prefix of all submodule output will be the name of the parent project&amp;rsquo;s &amp;lt;tree&amp;gt; object. This option has no effect if &lt;code&gt;--no-index&lt;/code&gt; is given.</source>
          <target state="translated">활성 상태이고 저장소에서 체크 아웃 된 각 하위 모듈에서 반복적으로 검색합니다. &amp;lt;tree&amp;gt; 옵션과 함께 사용하면 모든 하위 모듈 출력의 접두사는 상위 프로젝트의 &amp;lt;tree&amp;gt; 개체의 이름이됩니다. 이 옵션은 &lt;code&gt;--no-index&lt;/code&gt; 가 주어지면 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c70c81b356beafd0eeca89b16d9fdcb5f7371848" translate="yes" xml:space="preserve">
          <source>Redirection to a file (&lt;code&gt;/path/name&lt;/code&gt;) or pipe (&lt;code&gt;|command&lt;/code&gt;) is not supported.</source>
          <target state="translated">파일 ( &lt;code&gt;/path/name&lt;/code&gt; ) 또는 파이프 ( &lt;code&gt;|command&lt;/code&gt; ) 로의 경로 재 지정 은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89381280eddd66ed8601a4438d83804ded19d6ef" translate="yes" xml:space="preserve">
          <source>Reencoding content requires resources that might slow down certain Git operations (e.g &lt;code&gt;git checkout&lt;/code&gt; or &lt;code&gt;git add&lt;/code&gt;).</source>
          <target state="translated">콘텐츠를 다시 인코딩하려면 특정 Git 작업을 늦출 수있는 리소스가 필요합니다 (예 : &lt;code&gt;git checkout&lt;/code&gt; 또는 &lt;code&gt;git add&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4d5f4726578da60b5802012abfa0452d24f12476" translate="yes" xml:space="preserve">
          <source>Reencoding content to non-UTF encodings can cause errors as the conversion might not be UTF-8 round trip safe. If you suspect your encoding to not be round trip safe, then add it to &lt;code&gt;core.checkRoundtripEncoding&lt;/code&gt; to make Git check the round trip encoding (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). SHIFT-JIS (Japanese character set) is known to have round trip issues with UTF-8 and is checked by default.</source>
          <target state="translated">UTF-8이 아닌 왕복 여행으로 변환 할 수 없으므로 내용을 비 UTF 인코딩으로 다시 인코딩하면 오류가 발생할 수 있습니다. 인코딩이 왕복 안전하지 않은 것으로 의심되면 &lt;code&gt;core.checkRoundtripEncoding&lt;/code&gt; 에 추가 하여 Git이 왕복 인코딩을 확인하도록합니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). SHIFT-JIS (일본어 문자 세트)는 UTF-8에서 왕복 문제가있는 것으로 알려져 있으며 기본적으로 선택되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f60624f9fc2a82abf8497341d9d81b9d0824e3d8" translate="yes" xml:space="preserve">
          <source>Ref list attributes</source>
          <target state="translated">참조 목록 속성</target>
        </trans-unit>
        <trans-unit id="b5e499a4b81055b1593e4e8b58d802dd0804b18d" translate="yes" xml:space="preserve">
          <source>Ref list keywords</source>
          <target state="translated">참조 목록 키워드</target>
        </trans-unit>
        <trans-unit id="042501eba486c2a8fe3dfeebed7e6a526acc65b2" translate="yes" xml:space="preserve">
          <source>Refer to trace2.h for details about all trace2 functions.</source>
          <target state="translated">모든 trace2 기능에 대한 자세한 내용은 trace2.h를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="8189e74b00341c8128de1c9b04b6630dfed40f88" translate="yes" xml:space="preserve">
          <source>Reference advertisement will be omitted unless explicitly requested</source>
          <target state="translated">명시 적으로 요청하지 않으면 참조 광고는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="219616f872f3c1f3f7c63db96c4bad5707f937ab" translate="yes" xml:space="preserve">
          <source>Reference logs, or &quot;reflogs&quot;, record when the tips of branches and other references were updated in the local repository. Reflogs are useful in various Git commands, to specify the old value of a reference. For example, &lt;code&gt;HEAD@{2}&lt;/code&gt; means &quot;where HEAD used to be two moves ago&quot;, &lt;code&gt;master@{one.week.ago}&lt;/code&gt; means &quot;where master used to point to one week ago in this local repository&quot;, and so on. See &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; for more details.</source>
          <target state="translated">참조 로그 또는 &quot;reflogs&quot;는 분기 및 기타 참조의 팁이 로컬 저장소에서 업데이트 된시기를 기록합니다. Reflogs는 다양한 Git 명령에서 이전 참조 값을 지정하는 데 유용합니다. 예를 들어, &lt;code&gt;HEAD@{2}&lt;/code&gt; 는 &quot;HEAD가 두 번 전에 이동 한 위치&quot;를 의미 하고 &lt;code&gt;master@{one.week.ago}&lt;/code&gt; 는 &quot;이 로컬 저장소에서 1 주일 전에 마스터가 사용 된 위치&quot;등을 의미합니다. 자세한 내용은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="fdc0add895cb5f66656ac926ee760b1a52ebfc92" translate="yes" xml:space="preserve">
          <source>References are stored in subdirectories of this directory. The &lt;code&gt;git prune&lt;/code&gt; command knows to preserve objects reachable from refs found in this directory and its subdirectories. This directory is ignored (except refs/bisect, refs/rewritten and refs/worktree) if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/refs&quot; will be used instead.</source>
          <target state="translated">참조는이 디렉토리의 하위 디렉토리에 저장됩니다. &lt;code&gt;git prune&lt;/code&gt; 명령은 심판로부터 도달 가능한 객체가이 디렉토리 및 하위 디렉토리에있는 보존 알고있다. $ GIT_COMMON_DIR이 설정되고 &quot;$ GIT_COMMON_DIR / refs&quot;가 대신 사용되는 경우이 디렉토리는 무시됩니다 (refs / bisect, refs / rewritten 및 refs / worktree 제외).</target>
        </trans-unit>
        <trans-unit id="a774e5bc9f4a8942d74474f466fea367c3f9fc07" translate="yes" xml:space="preserve">
          <source>References to commit objects at the head of each branch are stored in files under .git/refs/heads/.</source>
          <target state="translated">각 분기의 헤드에서 객체를 커밋하는 참조는 .git / refs / heads / 아래 파일에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="e8597d82d33701c292294d665408182c1ffb7098" translate="yes" xml:space="preserve">
          <source>Reflog: The two backends will use different wording when describing the changes made in the reflog, though both will make use of the word &quot;rebase&quot;.</source>
          <target state="translated">Reflog : 두 백엔드는 모두 &quot;rebase&quot;라는 단어를 사용하지만 reflog의 변경 사항을 설명 할 때 다른 표현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="586454a22a42afbc6e2564872cf76fa552b4a1a3" translate="yes" xml:space="preserve">
          <source>Reflogs</source>
          <target state="translated">Reflogs</target>
        </trans-unit>
        <trans-unit id="701486a68f3896a8a5368aead277807a6847151f" translate="yes" xml:space="preserve">
          <source>Refs</source>
          <target state="translated">Refs</target>
        </trans-unit>
        <trans-unit id="80074f188ddb96f7955691b6a7210a31a672772d" translate="yes" xml:space="preserve">
          <source>Refs are grouped into islands based on their &quot;names&quot;, and two regexes that produce the same name are considered to be in the same island. The names are computed from the regexes by concatenating any capture groups from the regex, with a &lt;code&gt;-&lt;/code&gt; dash in between. (And if there are no capture groups, then the name is the empty string, as in the above example.) This allows you to create arbitrary numbers of islands. Only up to 14 such capture groups are supported though.</source>
          <target state="translated">참조는 &quot;이름&quot;을 기준으로 섬으로 그룹화되며 동일한 이름을 생성하는 두 개의 정규 표현식은 같은 섬에있는 것으로 간주됩니다. 정규식에서 캡처 그룹을 연결하고 그 사이에 &lt;code&gt;-&lt;/code&gt; 대시를 붙여서 정규식에서 이름을 계산합니다 . (그리고 캡처 그룹이 없으면 위의 예와 같이 이름은 빈 문자열입니다.) 이렇게하면 임의의 수의 섬을 만들 수 있습니다. 이러한 캡처 그룹은 최대 14 개까지만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f06a362739f816b768319f27e61eb1dd6b36faf2" translate="yes" xml:space="preserve">
          <source>Refs that are per working tree can still be accessed from another working tree via two special paths, &lt;code&gt;main-worktree&lt;/code&gt; and &lt;code&gt;worktrees&lt;/code&gt;. The former gives access to per-working tree refs of the main working tree, while the latter to all linked working trees.</source>
          <target state="translated">작업 트리 당 참조는 두 개의 특수 경로 인 &lt;code&gt;main-worktree&lt;/code&gt; 및 &lt;code&gt;worktrees&lt;/code&gt; 를 통해 다른 작업 트리에서 계속 액세스 할 수 있습니다 . 전자는 기본 작업 트리의 작업 트리 참조에 대한 액세스를 제공하고 후자는 연결된 모든 작업 트리에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2bb2083cc2f447acfd0f5d16022129235ca5b2cc" translate="yes" xml:space="preserve">
          <source>Refs that are per working tree can still be accessed from another working tree via two special paths, main-worktree and worktrees. The former gives access to per-worktree refs of the main working tree, while the latter to all linked working trees.</source>
          <target state="translated">작업 트리 당 참조는 주 작업 트리와 작업 트리라는 두 가지 특수 경로를 통해 다른 작업 트리에서 계속 액세스 할 수 있습니다. 전자는 주 작업 트리의 작업 트리 별 참조에 액세스하고 후자는 모든 연결된 작업 트리에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="05e5994fa9181b6fad85ee509538c0ad6a6bc5c4" translate="yes" xml:space="preserve">
          <source>Refs that are per-&lt;a href=&quot;#def_working_tree&quot;&gt;worktree&lt;/a&gt;, rather than global. This is presently only &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; and any refs that start with &lt;code&gt;refs/bisect/&lt;/code&gt;, but might later include other unusual refs.</source>
          <target state="translated">행된있는 참고 문헌 &lt;a href=&quot;#def_working_tree&quot;&gt;worktree을&lt;/a&gt; 오히려 지구보다. 이것은 현재 &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; 이며 &lt;code&gt;refs/bisect/&lt;/code&gt; 시작하는 모든 심판 이지만 나중에 다른 특이한 심판을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="338d2a0e12d851337309cef01e7fe887153b0f55" translate="yes" xml:space="preserve">
          <source>Regardless of object type, all objects share the following characteristics: they are all deflated with zlib, and have a header that not only specifies their type, but also provides size information about the data in the object. It&amp;rsquo;s worth noting that the SHA-1 hash that is used to name the object is the hash of the original data plus this header, so &lt;code&gt;sha1sum&lt;/code&gt; 'file' does not match the object name for 'file'.</source>
          <target state="translated">객체 유형에 관계없이 모든 객체는 다음 특성을 공유합니다. 객체는 모두 zlib로 수축되고 유형을 지정하고 객체의 데이터에 대한 크기 정보를 제공하는 헤더를 갖습니다. 객체 이름을 지정하는 데 사용되는 SHA-1 해시는 원본 데이터와이 헤더의 해시이므로 &lt;code&gt;sha1sum&lt;/code&gt; 'file'은 'file'의 객체 이름과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f29e38b3ae41c972d05bd6fbd77326fc2768fcf" translate="yes" xml:space="preserve">
          <source>Regardless of object type, all objects share the following characteristics: they are all deflated with zlib, and have a header that not only specifies their type, but also provides size information about the data in the object. It&amp;rsquo;s worth noting that the SHA-1 hash that is used to name the object is the hash of the original data plus this header, so &lt;code&gt;sha1sum&lt;/code&gt;&lt;code&gt;file&lt;/code&gt; does not match the object name for &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">객체 유형에 관계없이 모든 객체는 다음과 같은 특성을 공유합니다. 모두 zlib로 압축되고 유형을 지정할뿐만 아니라 객체의 데이터에 대한 크기 정보를 제공하는 헤더가 있습니다. 그래서 객체의 이름을하는 데 사용되는 SHA-1 해시 원본 데이터 플러스이 헤더의 해시이라고 지적 그것의 가치 &lt;code&gt;sha1sum&lt;/code&gt; 의 &lt;code&gt;file&lt;/code&gt; 에 대한 개체 이름과 일치하지 않는 &lt;code&gt;file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="710a95e624a3349545888a56ed2557d883a0ebee" translate="yes" xml:space="preserve">
          <source>Region and Data Messages</source>
          <target state="translated">지역 및 데이터 메시지</target>
        </trans-unit>
        <trans-unit id="039711232507cd9753ddba093da2350b27e67dca" translate="yes" xml:space="preserve">
          <source>Regions</source>
          <target state="translated">Regions</target>
        </trans-unit>
        <trans-unit id="f60734f6521040c876486255fe253adea3ef4364" translate="yes" xml:space="preserve">
          <source>Regions can be use to time an interesting section of code.</source>
          <target state="translated">지역은 흥미로운 코드 섹션의 시간을 정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6931aebd376c6a517eae391382acbc891d72f65" translate="yes" xml:space="preserve">
          <source>Regions may be nested. This causes messages to be indented in the PERF target, for example. Elapsed times are relative to the start of the corresponding nesting level as expected. For example, if we add region message to:</source>
          <target state="translated">지역이 중첩 될 수 있습니다. 예를 들어 PERF 대상에서 메시지가 들여 쓰기됩니다. 경과 시간은 예상대로 해당 중첩 수준의 시작에 상대적입니다. 예를 들어 지역 메시지를 다음에 추가하면</target>
        </trans-unit>
        <trans-unit id="1595f1bb6d790a7a3e5eb6fb03765aabf279806d" translate="yes" xml:space="preserve">
          <source>Register file contents in the working tree to the index</source>
          <target state="translated">작업 트리의 파일 내용을 색인에 등록</target>
        </trans-unit>
        <trans-unit id="8a6eb409adc691aa11f00dc05c7a129c2f833328" translate="yes" xml:space="preserve">
          <source>Regressions are a big problem in the software industry. But it&amp;rsquo;s difficult to put some real numbers behind that claim.</source>
          <target state="translated">회귀는 소프트웨어 산업에서 큰 문제입니다. 그러나 그 주장 뒤에 실제 숫자를 붙이는 것은 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="4ab9d6c175961a8739069a73845c7f8b21150d86" translate="yes" xml:space="preserve">
          <source>Regressions: a big problem</source>
          <target state="translated">회귀 : 큰 문제</target>
        </trans-unit>
        <trans-unit id="2256cc6ee2a5d077491a8a63ef76ac743c25d2d2" translate="yes" xml:space="preserve">
          <source>Related links</source>
          <target state="translated">관련된 링크들</target>
        </trans-unit>
        <trans-unit id="b61e20d1d031c57060b03654349b1ab448029094" translate="yes" xml:space="preserve">
          <source>Relationship to the Existing Trace Api (api-trace.txt)</source>
          <target state="translated">기존 추적 API와의 관계 (api-trace.txt)</target>
        </trans-unit>
        <trans-unit id="a5807b40eca9f80054603fbc4a7d22e009d2c415" translate="yes" xml:space="preserve">
          <source>Relative and non-relative marks may be combined by interweaving --(no-)-relative-marks with the --(import|export)-marks= options.</source>
          <target state="translated">상대 및 비 상대 마크는-(no-) 상대 마크를-(import | export) -marks = 옵션과 결합하여 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31bc43768c6a353840de5e162fcf9b5cce4d9437" translate="yes" xml:space="preserve">
          <source>Relative to the tip of &lt;code&gt;topic&lt;/code&gt;: knowing that your &lt;code&gt;topic&lt;/code&gt; has three commits, the old tip of &lt;code&gt;subsystem&lt;/code&gt; must be &lt;code&gt;topic~3&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;topic&lt;/code&gt; 팁과 관련하여 : &lt;code&gt;topic&lt;/code&gt; 에 3 개의 커밋이 있다는 것을 알고 있으면 &lt;code&gt;subsystem&lt;/code&gt; 의 이전 팁은 &lt;code&gt;topic~3&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="98786341673b229d09cd6bac6df5f38262cac094" translate="yes" xml:space="preserve">
          <source>Remain silent even on nonexistent files</source>
          <target state="translated">존재하지 않는 파일에서도 침묵 유지</target>
        </trans-unit>
        <trans-unit id="cad2c2939c304ff819eff58f792783f6747c93cf" translate="yes" xml:space="preserve">
          <source>Remap all the path requests as relative to the given path. This is sort of &quot;Git root&quot; - if you run &lt;code&gt;git daemon&lt;/code&gt; with &lt;code&gt;--base-path=/srv/git&lt;/code&gt; on example.com, then if you later try to pull &lt;code&gt;git://example.com/hello.git&lt;/code&gt;, &lt;code&gt;git daemon&lt;/code&gt; will interpret the path as &lt;code&gt;/srv/git/hello.git&lt;/code&gt;.</source>
          <target state="translated">주어진 경로를 기준으로 모든 경로 요청을 다시 매핑하십시오. 이것은 일종의 &quot;망할 놈의 루트&quot;입니다 - 당신이 실행하는 경우 &lt;code&gt;git daemon&lt;/code&gt; 와 &lt;code&gt;--base-path=/srv/git&lt;/code&gt; 나중에 끌어하려고하면 다음 example.com에를 &lt;code&gt;git://example.com/hello.git&lt;/code&gt; , &lt;code&gt;git daemon&lt;/code&gt; 은 경로를 &lt;code&gt;/srv/git/hello.git&lt;/code&gt; 로 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="4a5c393fce9fb8dc0d691f13288d22c0e7f1b235" translate="yes" xml:space="preserve">
          <source>Remap to ancestor</source>
          <target state="translated">조상으로 다시 매핑</target>
        </trans-unit>
        <trans-unit id="8d0121936c456fcf3d222b828ee9077e2cc34843" translate="yes" xml:space="preserve">
          <source>Remember how we did the &lt;code&gt;git update-index&lt;/code&gt; on file &lt;code&gt;hello&lt;/code&gt; and then we changed &lt;code&gt;hello&lt;/code&gt; afterward, and could compare the new state of &lt;code&gt;hello&lt;/code&gt; with the state we saved in the index file?</source>
          <target state="translated">우리가 어떻게했는지 기억 &lt;code&gt;git update-index&lt;/code&gt; 파일에 &lt;code&gt;hello&lt;/code&gt; 하고 우리가 변경 &lt;code&gt;hello&lt;/code&gt; 이후, 그리고 새로운 상태 비교할 수 &lt;code&gt;hello&lt;/code&gt; 우리는 인덱스 파일에 저장되어있는 상태로?</target>
        </trans-unit>
        <trans-unit id="2cc52de1f31f7df8236151d526db4f676cdfb905" translate="yes" xml:space="preserve">
          <source>Remember, before running &lt;code&gt;git merge&lt;/code&gt;, our &lt;code&gt;master&lt;/code&gt; head was at &quot;Some fun.&quot; commit, while our &lt;code&gt;mybranch&lt;/code&gt; head was at &quot;Some work.&quot; commit.</source>
          <target state="translated">기억, 실행하기 전에 &lt;code&gt;git merge&lt;/code&gt; , 우리의 &lt;code&gt;master&lt;/code&gt; 머리에 있었다 &quot;일부 재미.&quot; 우리 반면, 커밋 &lt;code&gt;mybranch&lt;/code&gt; 로 머리에 있었다 &quot;일부 작동합니다.&quot; 범하다.</target>
        </trans-unit>
        <trans-unit id="3e534e3639a4dd02297fd7fd07ede8a71c71535e" translate="yes" xml:space="preserve">
          <source>Remote HEAD must resolve to an object that exists locally</source>
          <target state="translated">원격 HEAD는 로컬로 존재하는 오브젝트로 해석되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2033891925fe29daa47f6c451af0f18a87529563" translate="yes" xml:space="preserve">
          <source>Remote helper programs are invoked with one or (optionally) two arguments. The first argument specifies a remote repository as in Git; it is either the name of a configured remote or a URL. The second argument specifies a URL; it is usually of the form &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt;, but any arbitrary string is possible. The &lt;code&gt;GIT_DIR&lt;/code&gt; environment variable is set up for the remote helper and can be used to determine where to store additional data or from which directory to invoke auxiliary Git commands.</source>
          <target state="translated">원격 헬퍼 프로그램은 하나 또는 선택적으로 두 개의 인수로 호출됩니다. 첫 번째 인수는 Git에서와 같이 원격 저장소를 지정합니다. 구성된 리모트의 이름이거나 URL입니다. 두 번째 인수는 URL을 지정합니다. 일반적으로 &lt;code&gt;&amp;lt;transport&amp;gt;://&amp;lt;address&amp;gt;&lt;/code&gt; 형식 이지만 임의의 문자열이 가능합니다. &lt;code&gt;GIT_DIR&lt;/code&gt; 의 환경 변수는 원격 헬퍼 대해 설정되며 여기서 보조 힘내 명령을 호출하기위한 추가 데이터 또는 디렉토리를 저장하는 방법을 결정하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="8ee4f73d380c3c99d59209a069206bbd667c2977" translate="yes" xml:space="preserve">
          <source>Remote helper programs are normally not used directly by end users, but they are invoked by Git when it needs to interact with remote repositories Git does not support natively. A given helper will implement a subset of the capabilities documented here. When Git needs to interact with a repository using a remote helper, it spawns the helper as an independent process, sends commands to the helper&amp;rsquo;s standard input, and expects results from the helper&amp;rsquo;s standard output. Because a remote helper runs as an independent process from Git, there is no need to re-link Git to add a new helper, nor any need to link the helper with the implementation of Git.</source>
          <target state="translated">원격 도우미 프로그램은 일반적으로 최종 사용자가 직접 사용하지 않지만 Git은 원격 저장소와 상호 작용해야 할 때 Git에서 기본적으로 지원하지 않습니다. 지정된 도우미는 여기에 설명 된 기능의 하위 집합을 구현합니다. Git은 원격 헬퍼를 사용하여 리포지토리와 상호 작용해야하는 경우 헬퍼를 독립적 인 프로세스로 생성하고 명령을 헬퍼의 표준 입력으로 보내고 헬퍼의 표준 출력 결과를 기대합니다. 원격 헬퍼는 Git과 독립적 인 프로세스로 실행되므로 Git를 다시 연결하여 새로운 헬퍼를 추가하거나 헬퍼를 Git 구현과 연결할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f9d958435b39dd5e8519bc9a5ca0b414455c52e" translate="yes" xml:space="preserve">
          <source>Remotes</source>
          <target state="translated">Remotes</target>
        </trans-unit>
        <trans-unit id="1d36d5e98f5289fdb40f6238091d921b16cd3d1b" translate="yes" xml:space="preserve">
          <source>Remove &amp;lt;n&amp;gt; leading path components (separated by slashes) from traditional diff paths. E.g., with &lt;code&gt;-p2&lt;/code&gt;, a patch against &lt;code&gt;a/dir/file&lt;/code&gt; will be applied directly to &lt;code&gt;file&lt;/code&gt;. The default is 1.</source>
          <target state="translated">기존의 diff 경로에서 &amp;lt;n&amp;gt; 선행 경로 구성 요소 (슬래시로 구분)를 제거하십시오. 예를 들어, &lt;code&gt;-p2&lt;/code&gt; 를 사용 &lt;code&gt;a/dir/file&lt;/code&gt; 에 대한 패치 가 &lt;code&gt;file&lt;/code&gt; 에 직접 적용됩니다 . 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="536f22b2b28f4e056331357f5ffb90610418f296" translate="yes" xml:space="preserve">
          <source>Remove &amp;lt;ref&amp;gt; from remote repository. The specified branch cannot be the remote HEAD. If -d is specified the following other conditions must also be met:</source>
          <target state="translated">원격 저장소에서 &amp;lt;ref&amp;gt;를 제거하십시오. 지정된 분기는 원격 HEAD가 될 수 없습니다. -d를 지정하면 다음과 같은 다른 조건도 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d92b551b14c7ff24c92341cea4922fcb2c6e7df" translate="yes" xml:space="preserve">
          <source>Remove a matching credential, if any, from the helper&amp;rsquo;s storage.</source>
          <target state="translated">도우미의 저장소에서 일치하는 자격 증명을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="f5cc16ae24cf52b436071d42d9516387a59ce74f" translate="yes" xml:space="preserve">
          <source>Remove a single stash entry from the list of stash entries.</source>
          <target state="translated">숨김 항목 목록에서 단일 숨김 항목을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="9a577cbb08edd5d9773523cfc5cfe43dc9b03f45" translate="yes" xml:space="preserve">
          <source>Remove a single stash entry from the list of stash entries. When no &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is given, it removes the latest one. i.e. &lt;code&gt;stash@{0}&lt;/code&gt;, otherwise &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; must be a valid stash log reference of the form &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">숨김 항목 목록에서 단일 숨김 항목을 제거하십시오. &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 가 제공 되지 않으면 최신 항목이 제거됩니다. 즉, &lt;code&gt;stash@{0}&lt;/code&gt; 이면 &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 는 &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt; 형식의 유효한 숨김 로그 참조 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="729e5fd8775c30c358fedf9e611fd4f6f670b5e7" translate="yes" xml:space="preserve">
          <source>Remove a single stashed state from the stash list and apply it on top of the current working tree state, i.e., do the inverse operation of &lt;code&gt;git stash push&lt;/code&gt;. The working directory must match the index.</source>
          <target state="translated">숨김 목록에서 단일 숨김 상태를 제거하고 현재 작업 트리 상태 위에 적용하십시오 (예 : &lt;code&gt;git stash push&lt;/code&gt; 의 역 연산 수행) . 작업 디렉토리는 색인과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="d34ae9e19d54c7604c479f4c5964ccef00bd4a98" translate="yes" xml:space="preserve">
          <source>Remove a working tree. Only clean working trees (no untracked files and no modification in tracked files) can be removed. Unclean working trees or ones with submodules can be removed with &lt;code&gt;--force&lt;/code&gt;. The main working tree cannot be removed.</source>
          <target state="translated">작업 트리를 제거하십시오. 깨끗한 작업 트리 (추적되지 않은 파일 및 추적 된 파일의 수정 없음) 만 제거 할 수 있습니다. 부정한 작업 트리 또는 하위 모듈이있는 트리는 &lt;code&gt;--force&lt;/code&gt; 를 사용 하여 제거 할 수 있습니다 . 기본 작업 트리는 제거 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="df5a8d70d2380181bdc059d7c2ddc0a78e9d1412" translate="yes" xml:space="preserve">
          <source>Remove all lines matching the key from config file.</source>
          <target state="translated">구성 파일에서 키와 일치하는 모든 줄을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="9fc0230ddf082dc45699878be1634350de11665f" translate="yes" xml:space="preserve">
          <source>Remove all notes for non-existing/unreachable objects.</source>
          <target state="translated">존재하지 않거나 도달 할 수없는 물체에 대한 모든 메모를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="fc1b4600e49f3115828b9f3463a6567fd85094fb" translate="yes" xml:space="preserve">
          <source>Remove all the stash entries. Note that those entries will then be subject to pruning, and may be impossible to recover (see &lt;code&gt;Examples&lt;/code&gt; below for a possible strategy).</source>
          <target state="translated">모든 숨김 항목을 제거하십시오. 그런 다음 해당 항목은 정리 될 수 있으며 복구가 불가능할 수 있습니다 ( 가능한 전략은 아래 &lt;code&gt;Examples&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="353e52e76ff6a9350e8485da73b547859aa497ce" translate="yes" xml:space="preserve">
          <source>Remove any whitespace-continuation in trailers, so that each trailer appears on a line by itself with its full content.</source>
          <target state="translated">예고편에서 공백을 제거하여 각 예고편이 전체 내용과 함께 한 줄로 표시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="de112945ec414c57cddaca5199f29ee2fc05a979" translate="yes" xml:space="preserve">
          <source>Remove directories from the SVN tree if there are no files left behind. SVN can version empty directories, and they are not removed by default if there are no files left in them. Git cannot version empty directories. Enabling this flag will make the commit to SVN act like Git.</source>
          <target state="translated">파일이 남아 있지 않으면 SVN 트리에서 디렉토리를 제거하십시오. SVN은 빈 디렉토리의 버전을 지정할 수 있으며, 파일이 남아 있지 않으면 기본적으로 제거되지 않습니다. Git은 빈 디렉토리의 버전을 지정할 수 없습니다. 이 플래그를 활성화하면 SVN에 대한 커밋이 Git처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="cc02753459be831dfea1cd243efcfb50db2a59d3" translate="yes" xml:space="preserve">
          <source>Remove everything in body before a scissors line (e.g. &quot;-- &amp;gt;8 --&quot;). The line represents scissors and perforation marks, and is used to request the reader to cut the message at that line. If that line appears in the body of the message before the patch, everything before it (including the scissors line itself) is ignored when this option is used.</source>
          <target state="translated">가위 선 앞에있는 모든 부분을 제거합니다 (예 : &quot;-&amp;gt; 8-&quot;). 선은 가위와 천공 표시를 나타내며 독자에게 해당 줄에서 메시지를 자르도록 요청하는 데 사용됩니다. 패치 전 메시지 본문에 해당 줄이 나타나면이 옵션을 사용하면 그 앞에있는 모든 줄 (가위 줄 자체 포함)이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7e6c07487aafd5a1b8bbc132d0eb9f70eb39a580" translate="yes" xml:space="preserve">
          <source>Remove everything in body before a scissors line (see &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo[1]&lt;/a&gt;). Can be activated by default using the &lt;code&gt;mailinfo.scissors&lt;/code&gt; configuration variable.</source>
          <target state="translated">가위 선 앞에서 몸의 모든 것을 제거하십시오 ( &lt;a href=&quot;git-mailinfo&quot;&gt;git-mailinfo [1] 참조&lt;/a&gt; ). &lt;code&gt;mailinfo.scissors&lt;/code&gt; 구성 변수를 사용하여 기본적으로 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="399fc61abd5e53e0ff9fe12417324d78f931368d" translate="yes" xml:space="preserve">
          <source>Remove everything in body before a scissors line. A line that mainly consists of scissors (either &quot;&amp;gt;8&quot; or &quot;8&amp;lt;&quot;) and perforation (dash &quot;-&quot;) marks is called a scissors line, and is used to request the reader to cut the message at that line. If such a line appears in the body of the message before the patch, everything before it (including the scissors line itself) is ignored when this option is used.</source>
          <target state="translated">가위 선 전에 몸의 모든 것을 제거하십시오. 가위 ( &quot;&amp;gt; 8&quot;또는 &quot;8 &amp;lt;&quot;)와 천공 (대시 &quot;-&quot;) 표시로 주로 구성되는 줄을 가위 줄이라고하며 독자가 해당 줄에서 메시지를 자르도록 요청하는 데 사용됩니다. 패치 전에 메시지 본문에 이러한 줄이 나타나면이 옵션을 사용하면 그 앞에있는 모든 항목 (가위 줄 자체 포함)이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3b6a842b7003d3eacad12733ce8974d4d54219eb" translate="yes" xml:space="preserve">
          <source>Remove extra objects that are already in pack files</source>
          <target state="translated">이미 팩 파일에있는 추가 개체 제거</target>
        </trans-unit>
        <trans-unit id="17839ee8fd6b46f8390b41c3ab4800fda5ea86c3" translate="yes" xml:space="preserve">
          <source>Remove files from the index, or from the working tree and the index. &lt;code&gt;git rm&lt;/code&gt; will not remove a file from just your working directory. (There is no option to remove a file only from the working tree and yet keep it in the index; use &lt;code&gt;/bin/rm&lt;/code&gt; if you want to do that.) The files being removed have to be identical to the tip of the branch, and no updates to their contents can be staged in the index, though that default behavior can be overridden with the &lt;code&gt;-f&lt;/code&gt; option. When &lt;code&gt;--cached&lt;/code&gt; is given, the staged content has to match either the tip of the branch or the file on disk, allowing the file to be removed from just the index.</source>
          <target state="translated">색인 또는 작업 트리와 색인에서 파일을 제거하십시오. &lt;code&gt;git rm&lt;/code&gt; 은 작업 디렉토리에서만 파일을 제거하지 않습니다. (작업 트리에서만 파일을 제거하고 인덱스에 보관하는 옵션은 없습니다. 제거하려면 &lt;code&gt;/bin/rm&lt;/code&gt; 을 사용하십시오 .) 제거되는 파일은 분기의 끝과 같아야합니다. &lt;code&gt;-f&lt;/code&gt; 옵션을 사용하면 기본 동작을 무시할 수 있지만 해당 내용에 대한 업데이트는 색인에서 준비 할 수 없습니다 . 때 &lt;code&gt;--cached&lt;/code&gt; 가 주어진다는이 내용이 파일이 바로 인덱스에서 제거 할 수 있도록 분기의 팁 또는 디스크에있는 파일 중 하나와 일치하는 무대.</target>
        </trans-unit>
        <trans-unit id="3cb238ca5adf89378484ddf4d733eeac1d7298bc" translate="yes" xml:space="preserve">
          <source>Remove files from the working tree and from the index</source>
          <target state="translated">작업 트리 및 색인에서 파일 제거</target>
        </trans-unit>
        <trans-unit id="43b38708b726858c7f29029b5ed632fd4a969782" translate="yes" xml:space="preserve">
          <source>Remove files matching pathspec from the index, or from the working tree and the index. &lt;code&gt;git rm&lt;/code&gt; will not remove a file from just your working directory. (There is no option to remove a file only from the working tree and yet keep it in the index; use &lt;code&gt;/bin/rm&lt;/code&gt; if you want to do that.) The files being removed have to be identical to the tip of the branch, and no updates to their contents can be staged in the index, though that default behavior can be overridden with the &lt;code&gt;-f&lt;/code&gt; option. When &lt;code&gt;--cached&lt;/code&gt; is given, the staged content has to match either the tip of the branch or the file on disk, allowing the file to be removed from just the index.</source>
          <target state="translated">인덱스 또는 작업 트리 및 인덱스에서 pathspec과 일치하는 파일을 제거합니다. &lt;code&gt;git rm&lt;/code&gt; 은 작업 디렉토리에서만 파일을 제거하지 않습니다. (작업 트리에서만 파일을 제거하고 인덱스에 유지하는 옵션은 없습니다. 그렇게하려면 &lt;code&gt;/bin/rm&lt;/code&gt; 을 사용하십시오 .) 제거되는 파일은 분기의 끝 부분과 동일해야합니다. 기본 동작은 &lt;code&gt;-f&lt;/code&gt; 옵션 으로 재정의 할 수 있지만 해당 내용에 대한 업데이트는 색인에 포함될 수 없습니다 . 때 &lt;code&gt;--cached&lt;/code&gt; 가 주어진다는이 내용이 파일이 바로 인덱스에서 제거 할 수 있도록 분기의 팁 또는 디스크에있는 파일 중 하나와 일치하는 무대.</target>
        </trans-unit>
        <trans-unit id="f4bb9a18f09e2a84cc163ecae438e47b1c4edd13" translate="yes" xml:space="preserve">
          <source>Remove only files ignored by Git. This may be useful to rebuild everything from scratch, but keep manually created files.</source>
          <target state="translated">Git에서 무시한 파일 만 제거하십시오. 처음부터 모든 것을 다시 작성하는 데 유용하지만 수동으로 만든 파일은 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="db3de663ed677f594653d0d9e2ee65cde68df92e" translate="yes" xml:space="preserve">
          <source>Remove remote branches that don&amp;rsquo;t have a local counterpart. For example a remote branch &lt;code&gt;tmp&lt;/code&gt; will be removed if a local branch with the same name doesn&amp;rsquo;t exist any more. This also respects refspecs, e.g. &lt;code&gt;git push --prune remote refs/heads/*:refs/tmp/*&lt;/code&gt; would make sure that remote &lt;code&gt;refs/tmp/foo&lt;/code&gt; will be removed if &lt;code&gt;refs/heads/foo&lt;/code&gt; doesn&amp;rsquo;t exist.</source>
          <target state="translated">로컬 대응자가없는 원격 지점을 제거하십시오. 예를 들어 같은 이름의 로컬 브랜치가 더 이상 존재하지 않으면 원격 브랜치 &lt;code&gt;tmp&lt;/code&gt; 가 제거됩니다. 또한 &lt;code&gt;git push --prune remote refs/heads/*:refs/tmp/*&lt;/code&gt; 는 참조 스펙을 존중 합니다. &lt;code&gt;refs/heads/foo&lt;/code&gt; 가 존재하지 않으면 원격 &lt;code&gt;refs/tmp/foo&lt;/code&gt; 가 제거되도록 합니다.</target>
        </trans-unit>
        <trans-unit id="2919c677f0cd57d3ef223926e7768e681a692562" translate="yes" xml:space="preserve">
          <source>Remove the file from the index even when the working directory still has such a file. (Implies --remove.)</source>
          <target state="translated">작업 디렉토리에 여전히 해당 파일이있는 경우에도 색인에서 파일을 제거하십시오. (암호-제거)</target>
        </trans-unit>
        <trans-unit id="164a03cc0aa02b0fdd552e7429c1ea851b7d7d46" translate="yes" xml:space="preserve">
          <source>Remove the given section from the configuration file.</source>
          <target state="translated">구성 파일에서 지정된 섹션을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="499242d7995d63aad1acd16a991a3d6fcb048be8" translate="yes" xml:space="preserve">
          <source>Remove the line matching the key from config file.</source>
          <target state="translated">구성 파일에서 키와 일치하는 줄을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="9012d0fb42a36221745fbb3295fa2024a72211df" translate="yes" xml:space="preserve">
          <source>Remove the notes for given objects (defaults to HEAD). When giving zero or one object from the command line, this is equivalent to specifying an empty note message to the &lt;code&gt;edit&lt;/code&gt; subcommand.</source>
          <target state="translated">주어진 객체에 대한 메모를 제거합니다 (기본값은 HEAD). 명령 행에서 0 개 또는 하나의 오브젝트를 제공 할 때 이것은 &lt;code&gt;edit&lt;/code&gt; 부속 명령에 빈 메모 메시지를 지정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b516eb38e36b7b4419cbc8b6cb246b5741dd75c3" translate="yes" xml:space="preserve">
          <source>Remove the original refs backed up by git-filter-branch: say &lt;code&gt;git
for-each-ref --format=&quot;%(refname)&quot; refs/original/ | xargs -n 1 git
update-ref -d&lt;/code&gt;.</source>
          <target state="translated">git-filter-branch에 의해 백업 된 원래 참조를 제거하십시오. say &lt;code&gt;git for-each-ref --format=&quot;%(refname)&quot; refs/original/ | xargs -n 1 git update-ref -d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5271d5dabe5bf4126a68baa1d1f5cc6eedea4a6" translate="yes" xml:space="preserve">
          <source>Remove the remote named &amp;lt;name&amp;gt;. All remote-tracking branches and configuration settings for the remote are removed.</source>
          <target state="translated">이름이 &amp;lt;name&amp;gt; 인 원격을 제거하십시오. 원격에 대한 모든 원격 추적 분기 및 구성 설정이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="55f1c43ced88c466a9b48b12744508e7df191628" translate="yes" xml:space="preserve">
          <source>Remove the upstream information for &amp;lt;branchname&amp;gt;. If no branch is specified it defaults to the current branch.</source>
          <target state="translated">&amp;lt;branchname&amp;gt;에 대한 업스트림 정보를 제거하십시오. 분기가 지정되지 않은 경우 기본값은 현재 분기입니다.</target>
        </trans-unit>
        <trans-unit id="7dd660439147162be4964d5d4a2d3c419e5791f0" translate="yes" xml:space="preserve">
          <source>Remove unnecessary whitespace</source>
          <target state="translated">불필요한 공백 제거</target>
        </trans-unit>
        <trans-unit id="d76bb29e1084aa7b85896360764953783a4152de" translate="yes" xml:space="preserve">
          <source>Remove untracked files from the working tree</source>
          <target state="translated">작업 트리에서 추적되지 않은 파일 제거</target>
        </trans-unit>
        <trans-unit id="e317f2faafb831e4cbd09ebccd9fa3144e930ab8" translate="yes" xml:space="preserve">
          <source>Removed content is represented by lines beginning with &quot;-&quot;. You can prevent staging their removal by converting the &quot;-&quot; to a &quot; &quot; (space).</source>
          <target state="translated">제거 된 내용은 &quot;-&quot;로 시작하는 줄로 표시됩니다. &quot;-&quot;를 &quot;&quot;(공백)으로 변환하여 제거가 준비되지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="078d2cf1e943764a2f97b429a98d1c54fe3fc4b4" translate="yes" xml:space="preserve">
          <source>Removes all &lt;code&gt;*.txt&lt;/code&gt; files from the index that are under the &lt;code&gt;Documentation&lt;/code&gt; directory and any of its subdirectories.</source>
          <target state="translated">&lt;code&gt;Documentation&lt;/code&gt; 디렉토리 및 해당 서브 디렉토리 아래에있는 색인에서 모든 &lt;code&gt;*.txt&lt;/code&gt; 파일을 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="b7b4dacce459fd9e247be7781aa6ab7a83d66ed0" translate="yes" xml:space="preserve">
          <source>Removing files that have disappeared from the filesystem</source>
          <target state="translated">파일 시스템에서 사라진 파일 제거</target>
        </trans-unit>
        <trans-unit id="3225190bfc565c2a8dc8b2fcac1b38dcbf9dd0d7" translate="yes" xml:space="preserve">
          <source>Rename detection options for git-diff and git-diff-tree. The default is ('-M'); set it to ('-C') or ('-C', '-C') to also detect copies, or set it to () i.e. empty list if you don&amp;rsquo;t want to have renames detection.</source>
          <target state="translated">git-diff 및 git-diff-tree의 탐지 옵션 이름을 바꿉니다. 기본값은 ( '-M')입니다. 사본을 감지하려면 ( '-C') 또는 ( '-C', '-C')로 설정하거나 이름을 바꾸지 않으려면 빈 목록으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8ccf039fc07f889e68756c36ea6201967b32f105" translate="yes" xml:space="preserve">
          <source>Rename the given section to a new name.</source>
          <target state="translated">지정된 섹션의 이름을 새 이름으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="141bf3674e223333500e19c5eb60f38f2c848a7a" translate="yes" xml:space="preserve">
          <source>Rename the remote named &amp;lt;old&amp;gt; to &amp;lt;new&amp;gt;. All remote-tracking branches and configuration settings for the remote are updated.</source>
          <target state="translated">&amp;lt;old&amp;gt;라는 원격의 이름을 &amp;lt;new&amp;gt;로 바꿉니다. 원격에 대한 모든 원격 추적 분기 및 구성 설정이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="3dc385accd1a9a34d691dc85a7cf993a198b2f01" translate="yes" xml:space="preserve">
          <source>Renamed and copied directories are not detected by Git and hence not tracked when committing to SVN. I do not plan on adding support for this as it&amp;rsquo;s quite difficult and time-consuming to get working for all the possible corner cases (Git doesn&amp;rsquo;t do it, either). Committing renamed and copied files is fully supported if they&amp;rsquo;re similar enough for Git to detect them.</source>
          <target state="translated">이름이 바뀌고 복사 된 디렉토리는 Git에 의해 감지되지 않으므로 SVN에 커밋 할 때 추적되지 않습니다. 가능한 모든 모퉁이 사건에 대해 일하는 것은 상당히 어렵고 시간이 많이 걸리기 때문에 지원을 추가 할 계획은 없습니다 (Git 도하 지 않습니다). 이름이 바뀌고 복사 된 파일을 커밋하는 것은 Git이 탐지 할 수있을 정도로 비슷하다면 완전히 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4a51a71032e050546d92c69d4de0167dd63ce59a" translate="yes" xml:space="preserve">
          <source>Renamed or copied entries have the following format:</source>
          <target state="translated">이름이 바뀌거나 복사 된 항목의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="226701a0627a0c80ce4e0de29a5f8995d1cc94ec" translate="yes" xml:space="preserve">
          <source>Renames an existing file or subdirectory to a different location within the branch. The existing file or directory must exist. If the destination exists it will be replaced by the source directory.</source>
          <target state="translated">기존 파일 또는 하위 디렉토리의 이름을 분기 내의 다른 위치로 바꿉니다. 기존 파일 또는 디렉토리가 존재해야합니다. 대상이 존재하면 소스 디렉토리로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="7f74fd002fd53242d75fe672215f240c564dd1ec" translate="yes" xml:space="preserve">
          <source>Reordering and editing commits usually creates untested intermediate steps. You may want to check that your history editing did not break anything by running a test, or at least recompiling at intermediate points in history by using the &quot;exec&quot; command (shortcut &quot;x&quot;). You may do so by creating a todo list like this one:</source>
          <target state="translated">커밋 순서를 변경하고 편집하면 일반적으로 테스트되지 않은 중간 단계가 생성됩니다. 테스트를 실행하거나 최소한 &quot;exec&quot;명령 (바로 가기 &quot;x&quot;)을 사용하여 히스토리의 중간 지점에서 다시 컴파일하여 히스토리 편집이 아무 것도 깨지지 않았는지 확인할 수 있습니다. 다음과 같이 할 일 목록을 만들어서 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e58cc3e9504477ac39c3fae4556406d9e87fe8d4" translate="yes" xml:space="preserve">
          <source>Reordering file diffs that make up a patch does not affect the ID. In particular, two patches produced by comparing the same two trees with two different settings for &quot;-O&amp;lt;orderfile&amp;gt;&quot; result in the same patch ID signature, thereby allowing the computed result to be used as a key to index some meta-information about the change between the two trees;</source>
          <target state="translated">패치를 구성하는 파일 차이를 재정렬해도 ID에는 영향을 미치지 않습니다. 특히, 동일한 두 트리를 &quot;-O &amp;lt;orderfile&amp;gt;&quot;에 대한 두 개의 다른 설정과 비교하여 생성 된 두 개의 패치는 동일한 패치 ID 서명을 생성하므로 계산 된 결과를 일부 메타 정보를 색인화하는 키로 사용할 수 있습니다. 두 나무 사이의 변화;</target>
        </trans-unit>
        <trans-unit id="5727ab28a85a139867f62da8126eb9354b33a57a" translate="yes" xml:space="preserve">
          <source>Reordering or selecting from a patch series</source>
          <target state="translated">패치 시리즈 재정렬 또는 선택</target>
        </trans-unit>
        <trans-unit id="25df8871189ca5637ebc8cd7aea9cae824ef4545" translate="yes" xml:space="preserve">
          <source>Repacking Historical Data</source>
          <target state="translated">과거 데이터 재 포장</target>
        </trans-unit>
        <trans-unit id="456c003d09a0693bc8c7cb3458bf2ad8bbfc033f" translate="yes" xml:space="preserve">
          <source>Repair working tree administrative files, if possible, if they have become corrupted or outdated due to external factors.</source>
          <target state="translated">가능한 경우 작업 트리 관리 파일이 외부 요인으로 인해 손상되거나 오래된 경우 복구합니다.</target>
        </trans-unit>
        <trans-unit id="9421c86863fd32deff3fd89fb282f96023d8e85d" translate="yes" xml:space="preserve">
          <source>Repeat the last two steps until your working tree is clean.</source>
          <target state="translated">작업 트리가 깨끗해질 때까지 마지막 두 단계를 반복하십시오.</target>
        </trans-unit>
        <trans-unit id="834462c9f22bc02c77a9880295a7368517cb2349" translate="yes" xml:space="preserve">
          <source>Replace an existing tag with the given name (instead of failing)</source>
          <target state="translated">기존 태그를 지정된 이름으로 바꾸십시오 (실패 대신)</target>
        </trans-unit>
        <trans-unit id="7cf4729941401b21c05e226cfd4468a69f10bdc9" translate="yes" xml:space="preserve">
          <source>Replace each parent &lt;code&gt;P&lt;/code&gt; of &lt;code&gt;C'&lt;/code&gt; with its simplification &lt;code&gt;P'&lt;/code&gt;. In the process, drop parents that are ancestors of other parents or that are root commits TREESAME to an empty tree, and remove duplicates, but take care to never drop all parents that we are TREESAME to.</source>
          <target state="translated">&lt;code&gt;C'&lt;/code&gt; 의 각 부모 &lt;code&gt;P&lt;/code&gt; 를 단순화 &lt;code&gt;P'&lt;/code&gt; 로 바꿉니다 . 이 과정에서 다른 부모의 조상이거나 루트 인 루트 부모는 TREESAME를 빈 트리에 커밋하고 복제본을 제거하지만 TREESAME 인 부모를 모두 드롭하지 않도록주의하십시오.</target>
        </trans-unit>
        <trans-unit id="2f9605c49f9b2a3f616b81433e85ca64645d76b1" translate="yes" xml:space="preserve">
          <source>Replace the tip of the current branch by creating a new commit. The recorded tree is prepared as usual (including the effect of the &lt;code&gt;-i&lt;/code&gt; and &lt;code&gt;-o&lt;/code&gt; options and explicit pathspec), and the message from the original commit is used as the starting point, instead of an empty message, when no other message is specified from the command line via options such as &lt;code&gt;-m&lt;/code&gt;, &lt;code&gt;-F&lt;/code&gt;, &lt;code&gt;-c&lt;/code&gt;, etc. The new commit has the same parents and author as the current one (the &lt;code&gt;--reset-author&lt;/code&gt; option can countermand this).</source>
          <target state="translated">새 커밋을 만들어 현재 분기의 끝을 바꿉니다. 기록 된 트리는 평소와 같이 준비되며 ( &lt;code&gt;-i&lt;/code&gt; 및 &lt;code&gt;-o&lt;/code&gt; 옵션 및 명시 적 경로 스펙 의 영향 포함 ) 다른 메시지가 지정되지 않은 경우 원래 커밋의 메시지가 빈 메시지 대신 시작 지점으로 사용됩니다. &lt;code&gt;-m&lt;/code&gt; , &lt;code&gt;-F&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; 등의 옵션을 통해 명령 행에서 새 커밋은 현재 커밋과 동일한 부모 및 작성자를 갖습니다 ( &lt;code&gt;--reset-author&lt;/code&gt; 옵션으로이를 방지 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="f3cb9be6e266f94b26ae77ef70ae8b6ef0aebb1e" translate="yes" xml:space="preserve">
          <source>Replaced with long name (git-receive-pack, git-upload-pack, or git-upload-archive) of the service Git wants to invoke.</source>
          <target state="translated">Git이 호출하려는 서비스의 긴 이름 (git-receive-pack, git-upload-pack 또는 git-upload-archive)으로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="bb8b07a94b19262ae05804fd3dbbad7507b398f9" translate="yes" xml:space="preserve">
          <source>Replaced with name (receive-pack, upload-pack, or upload-archive) of the service Git wants to invoke.</source>
          <target state="translated">Git이 호출하고자하는 서비스의 이름 (receive-pack, upload-pack 또는 upload-archive)으로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="daa118b2fa4fcb83d5d989f3e2085ec4ffc46e78" translate="yes" xml:space="preserve">
          <source>Replacement references will be used by default by all Git commands except those doing reachability traversal (prune, pack transfer and fsck).</source>
          <target state="translated">대체 가능 참조는 도달 가능성 순회 (프룬, 팩 전송 및 fsck)를 제외한 모든 Git 명령에서 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1c7de5212a432b2bb1d31f5a918c389962b1d1aa" translate="yes" xml:space="preserve">
          <source>Report all removed objects.</source>
          <target state="translated">제거 된 모든 개체를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="7cf59cb5c9b7cd37a64d08b6f1df2d863445c6dc" translate="yes" xml:space="preserve">
          <source>Report bugs to the Git mailing list &amp;lt;&lt;a href=&quot;mailto:git@vger.kernel.org&quot;&gt;git@vger.kernel.org&lt;/a&gt;&amp;gt; where the development and maintenance is primarily done. You do not have to be subscribed to the list to send a message there. See the list archive at &lt;a href=&quot;https://lore.kernel.org/git&quot;&gt;https://lore.kernel.org/git&lt;/a&gt; for previous bug reports and other discussions.</source>
          <target state="translated">개발 및 유지 관리가 주로 수행 되는 Git 메일 링리스트 &amp;lt; &lt;a href=&quot;mailto:git@vger.kernel.org&quot;&gt;git@vger.kernel.org&lt;/a&gt; &amp;gt;에 버그를보고하십시오 . 메시지를 보내기 위해 목록에 가입하지 않아도됩니다. 이전 버그 보고서 및 기타 토론 은 &lt;a href=&quot;https://lore.kernel.org/git&quot;&gt;https://lore.kernel.org/git&lt;/a&gt; 의 목록 아카이브를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c34aa6a8d095f4c3d50ca22d6cbaa490bb7d9e6" translate="yes" xml:space="preserve">
          <source>Report in more detail:</source>
          <target state="translated">보다 자세하게보고하십시오 :</target>
        </trans-unit>
        <trans-unit id="00d1a1b2ba790dc8a5d0ef6f48b27324107dfa43" translate="yes" xml:space="preserve">
          <source>Report on the success or failure of the password. If the credential allowed the operation to complete successfully, then it can be marked with an &quot;approve&quot; action to tell &lt;code&gt;git
credential&lt;/code&gt; to reuse it in its next invocation. If the credential was rejected during the operation, use the &quot;reject&quot; action so that &lt;code&gt;git credential&lt;/code&gt; will ask for a new password in its next invocation. In either case, &lt;code&gt;git credential&lt;/code&gt; should be fed with the credential description obtained from step (2) (which also contain the ones provided in step (1)).</source>
          <target state="translated">암호의 성공 또는 실패에 대해보고하십시오. 자격 증명으로 작업을 성공적으로 완료 한 경우 &quot;승인&quot;작업으로 표시 하여 다음 호출에서 &lt;code&gt;git credential&lt;/code&gt; 을 다시 사용하도록 지시 할 수 있습니다. 조작 중에 신임 정보가 거부 된 경우 &quot;거부&quot;조치를 사용하여 &lt;code&gt;git credential&lt;/code&gt; 가 다음 호출에서 새 비밀번호를 요청하도록하십시오. 어느 경우 든, &lt;code&gt;git credential&lt;/code&gt; 은 단계 (2)에서 얻은 자격 증명 설명과 함께 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d2999561ae6989540b2fd61f56808ce48ec59875" translate="yes" xml:space="preserve">
          <source>Report progress to stderr.</source>
          <target state="translated">stderr에 진행 상황을보고하십시오.</target>
        </trans-unit>
        <trans-unit id="23ca6237e7b4d09b8d3d4523a8b69c6b949c38b4" translate="yes" xml:space="preserve">
          <source>Report progress to stderr. By default, only a message about the current patch being applied will be printed. This option will cause additional information to be reported.</source>
          <target state="translated">stderr에 진행 상황을보고하십시오. 기본적으로 현재 적용중인 패치에 대한 메시지 만 인쇄됩니다. 이 옵션을 사용하면 추가 정보가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="40a5b594b81a1c53f8bc61470ed2acd9caeb657d" translate="yes" xml:space="preserve">
          <source>Report root nodes.</source>
          <target state="translated">루트 노드를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="f3f7b1acaa97f30c6a4351eea727e4482f68baad" translate="yes" xml:space="preserve">
          <source>Report tags.</source>
          <target state="translated">보고서 태그.</target>
        </trans-unit>
        <trans-unit id="ca0ca9c619773e28411f3305d3cdb605dc8f7d58" translate="yes" xml:space="preserve">
          <source>Report the list of objects being walked locally and the list of objects successfully sent to the remote repository.</source>
          <target state="translated">로컬로 이동중인 개체 목록과 원격 저장소로 성공적으로 전송 된 개체 목록을보고하십시오.</target>
        </trans-unit>
        <trans-unit id="b0782f7c4e5f1bf3ea56caef9403677659089e74" translate="yes" xml:space="preserve">
          <source>Report the names of files as they are moved.</source>
          <target state="translated">파일이 이동 될 때 파일 이름을보고하십시오.</target>
        </trans-unit>
        <trans-unit id="3f95107453bf160f40698d26a88098aaa480cce8" translate="yes" xml:space="preserve">
          <source>Report what is being added and removed from index.</source>
          <target state="translated">색인에서 추가 및 제거되는 내용을보고하십시오.</target>
        </trans-unit>
        <trans-unit id="d567f68fa956f7f96b358a6cc234fa317f99710f" translate="yes" xml:space="preserve">
          <source>Report what is downloaded.</source>
          <target state="translated">다운로드 한 내용을보고하십시오.</target>
        </trans-unit>
        <trans-unit id="da402275b11a467df24029cc41a475356773c185" translate="yes" xml:space="preserve">
          <source>Reporting bugs</source>
          <target state="translated">버그보고</target>
        </trans-unit>
        <trans-unit id="c91e6e6a538a5087a64a99718ae975966b761c1e" translate="yes" xml:space="preserve">
          <source>Repositories</source>
          <target state="translated">Repositories</target>
        </trans-unit>
        <trans-unit id="cc18a74ca85a5fe1dba71937009d7cf5c036f7f7" translate="yes" xml:space="preserve">
          <source>Repositories and branches</source>
          <target state="translated">리포지토리 및 브랜치</target>
        </trans-unit>
        <trans-unit id="3fb88b595be10aadddb6789d4ff575757e80830d" translate="yes" xml:space="preserve">
          <source>Repository administration</source>
          <target state="translated">리포지토리 관리</target>
        </trans-unit>
        <trans-unit id="df92bd52a2917a26c9495edc89977fc3eba4e3de" translate="yes" xml:space="preserve">
          <source>Repository maintenance</source>
          <target state="translated">리포지토리 유지 관리</target>
        </trans-unit>
        <trans-unit id="9b33ca61629f451364a09b37b4533d1a6f2f1429" translate="yes" xml:space="preserve">
          <source>Repository specific configuration file.</source>
          <target state="translated">리포지토리 특정 구성 파일</target>
        </trans-unit>
        <trans-unit id="c748d884d06ef27fef856a77e77414daf14ef261" translate="yes" xml:space="preserve">
          <source>Repository specific configuration file. This file is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/config&quot; will be used instead.</source>
          <target state="translated">리포지토리 특정 구성 파일 $ GIT_COMMON_DIR이 설정되고 대신 &quot;$ GIT_COMMON_DIR / config&quot;가 사용되면이 파일은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7394e3ce9096d2546e81d264f6ebc4e2faebef57" translate="yes" xml:space="preserve">
          <source>Represents a repository accessed using the helper program &quot;git-ssl foo.example /bar&quot;. The type of request can be determined by the helper using environment variables (see above).</source>
          <target state="translated">헬퍼 프로그램 &quot;git-ssl foo.example / bar&quot;를 사용하여 액세스 한 저장소를 나타냅니다. 요청 유형은 환경 변수를 사용하여 도우미에 의해 결정될 수 있습니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="9c983b3418b85a3f9b204dd1418f6237fbf7bdab" translate="yes" xml:space="preserve">
          <source>Represents a repository with path /repo accessed using the helper program &quot;git-server-alias foo&quot;. The hostname for the remote server passed in the protocol stream will be &quot;foo&quot; (this allows multiple virtual Git servers to share a link-level address).</source>
          <target state="translated">헬퍼 프로그램 &quot;git-server-alias foo&quot;를 사용하여 액세스 한 경로 / repo가있는 저장소를 나타냅니다. 프로토콜 스트림에 전달 된 원격 서버의 호스트 이름은 &quot;foo&quot;입니다 (여러 가상 Git 서버가 링크 레벨 주소를 공유 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="1362aa2b16d7c974af6da4e16e1f2f2e57cebac0" translate="yes" xml:space="preserve">
          <source>Represents a repository with path /repo accessed using the helper program &quot;git-server-alias foo&quot;. The path to the repository and type of request are not passed on the command line but as part of the protocol stream, as usual with git:// protocol.</source>
          <target state="translated">헬퍼 프로그램 &quot;git-server-alias foo&quot;를 사용하여 액세스 한 경로 / repo가있는 저장소를 나타냅니다. 리포지토리의 경로와 요청 유형은 일반적으로 git : // 프로토콜에서와 같이 명령 줄에 전달되지 않고 프로토콜 스트림의 일부로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d09e808fea175aed6c0426870e406a54311c7cc5" translate="yes" xml:space="preserve">
          <source>Represents a repository with path &lt;code&gt;/repo with spaces&lt;/code&gt; accessed using the helper program &quot;git-server-alias foo&quot;. The hostname for the remote server passed in the protocol stream will be &quot;foo&quot; (this allows multiple virtual Git servers to share a link-level address).</source>
          <target state="translated">헬퍼 프로그램 &quot;git-server-alias foo&quot;를 사용하여 액세스 &lt;code&gt;/repo with spaces&lt;/code&gt; 있는 경로 / repo가 있는 저장소를 나타 냅니다. 프로토콜 스트림에 전달 된 원격 서버의 호스트 이름은 &quot;foo&quot;입니다 (여러 가상 Git 서버가 링크 레벨 주소를 공유 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="2efb065a9a5c22367444476c2d3425647648ecad" translate="yes" xml:space="preserve">
          <source>Represents repository with path /somerepo accessible over git protocol at abstract namespace address /git-server.</source>
          <target state="translated">추상 네임 스페이스 주소 / git-server에서 git 프로토콜을 통해 액세스 가능한 경로 / somerepo가있는 저장소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c8f4d396d0343dc3cd250d626642ac1b291769ac" translate="yes" xml:space="preserve">
          <source>Reproducing some bugs may require referencing particular commits or paths, which becomes challenging after refnames and paths have been anonymized. You can ask for a particular token to be left as-is or mapped to a new value. For example, if you have a bug which reproduces with &lt;code&gt;git rev-list sensitive -- secret.c&lt;/code&gt;, you can run:</source>
          <target state="translated">일부 버그를 재현하려면 특정 커밋 또는 경로를 참조해야 할 수 있으며, 이는 참조 이름과 경로가 익명화 된 후에 어려워집니다. 특정 토큰을 그대로 두거나 새 값에 매핑하도록 요청할 수 있습니다. 예를 들어 &lt;code&gt;git rev-list sensitive -- secret.c&lt;/code&gt; 재현되는 버그가있는 경우 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19e1ed64e856e6f12f5bac77f5299cded049014e" translate="yes" xml:space="preserve">
          <source>Request a single valid revision from the user, and set the &lt;code&gt;REVISION&lt;/code&gt; environment variable. In other aspects this option is similar to &lt;code&gt;argPrompt&lt;/code&gt;, and can be used together with it.</source>
          <target state="translated">사용자에게 유효한 단일 개정을 요청하고 &lt;code&gt;REVISION&lt;/code&gt; 환경 변수를 설정하십시오 . 다른 측면에서이 옵션은 &lt;code&gt;argPrompt&lt;/code&gt; 와 유사하며 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="197fbdc9cd47b824a513f297f7a38d2715e6a37f" translate="yes" xml:space="preserve">
          <source>Request a string argument from the user, and pass it to the tool through the &lt;code&gt;ARGS&lt;/code&gt; environment variable. Since requesting an argument implies confirmation, the &lt;code&gt;confirm&lt;/code&gt; option has no effect if this is enabled. If the option is set to &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;yes&lt;/code&gt;, or &lt;code&gt;1&lt;/code&gt;, the dialog uses a built-in generic prompt; otherwise the exact value of the variable is used.</source>
          <target state="translated">사용자에게 문자열 인수를 요청하고 &lt;code&gt;ARGS&lt;/code&gt; 환경 변수를 통해 도구에 전달하십시오 . 인수를 요청하면 확인이 필요하므로 &lt;code&gt;confirm&lt;/code&gt; 옵션이 활성화되어 있으면 적용되지 않습니다. 옵션이 &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;yes&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 로 설정되면 대화 상자는 기본 제공 일반 프롬프트를 사용합니다. 그렇지 않으면 변수의 정확한 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af76b31829a8dd5cf3635494d51216915adc4665" translate="yes" xml:space="preserve">
          <source>Request the helper to check connectivity of a clone.</source>
          <target state="translated">헬퍼에게 클론 연결을 확인하도록 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="c38d97d1cdb590002eb1b4ddac901b5b9f2b5245" translate="yes" xml:space="preserve">
          <source>Request the helper to perform a force update. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">도우미에게 강제 업데이트를 수행하도록 요청하십시오. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ca0eaa75282457b7cf284de87b05023d92c795d5" translate="yes" xml:space="preserve">
          <source>Requesting credentials</source>
          <target state="translated">자격 증명 요청</target>
        </trans-unit>
        <trans-unit id="c253c74295e6d26ab1e36992edc46329d8f4d039" translate="yes" xml:space="preserve">
          <source>Requests writing one file revision to the packfile. The revision is not connected to any commit; this connection must be formed in a subsequent &lt;code&gt;commit&lt;/code&gt; command by referencing the blob through an assigned mark.</source>
          <target state="translated">하나의 파일 개정판을 packfile에 쓰도록 요청합니다. 개정판은 커밋에 연결되지 않습니다. 이 연결은 할당 된 마크를 통해 블롭을 참조하여 후속 &lt;code&gt;commit&lt;/code&gt; 명령 에서 형성되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f1bfe97ddeff74e34e5c2b1e166cee78ba2487b9" translate="yes" xml:space="preserve">
          <source>Require that fast-import supports the specified feature, or abort if it does not.</source>
          <target state="translated">빠른 가져 오기가 지정된 기능을 지원하도록 요구하거나 지원하지 않으면 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="6316856b66b77d95afc0c3453708e583c5e94170" translate="yes" xml:space="preserve">
          <source>Require that the backend support the &lt;code&gt;get-mark&lt;/code&gt;, &lt;code&gt;cat-blob&lt;/code&gt;, or &lt;code&gt;ls&lt;/code&gt; command respectively. Versions of fast-import not supporting the specified command will exit with a message indicating so. This lets the import error out early with a clear message, rather than wasting time on the early part of an import before the unsupported command is detected.</source>
          <target state="translated">백엔드가 각각 &lt;code&gt;get-mark&lt;/code&gt; , &lt;code&gt;cat-blob&lt;/code&gt; 또는 &lt;code&gt;ls&lt;/code&gt; 명령을 지원해야합니다 . 지정된 명령을 지원하지 않는 빠른 가져 오기 버전은이를 나타내는 메시지와 함께 종료됩니다. 이를 통해 지원되지 않는 명령이 감지되기 ​​전에 가져 오기 초기에 시간을 낭비하지 않고 명확한 메시지로 가져 오기 오류를 조기에 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="237f6cde559246995a9ad3fe3a19f1f678ef3d45" translate="yes" xml:space="preserve">
          <source>Require that the backend support the &lt;code&gt;notemodify&lt;/code&gt; (N) subcommand to the &lt;code&gt;commit&lt;/code&gt; command. Versions of fast-import not supporting notes will exit with a message indicating so.</source>
          <target state="translated">백엔드 가 &lt;code&gt;commit&lt;/code&gt; 명령에 대해 &lt;code&gt;notemodify&lt;/code&gt; (N) 부속 명령을 지원해야합니다 . 메모를 지원하지 않는 빠른 가져 오기 버전은이를 나타내는 메시지와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="2bdd979f5fb070ff3c7f85169894f3f721c9ebce" translate="yes" xml:space="preserve">
          <source>Requires &lt;code&gt;--stdout&lt;/code&gt;. Omits certain objects (usually blobs) from the resulting packfile. See &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; for valid &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; forms.</source>
          <target state="translated">&lt;code&gt;--stdout&lt;/code&gt; 이 필요합니다 . 결과 팩 파일에서 특정 객체 (일반적으로 얼룩)를 생략합니다. 유효한 &lt;code&gt;&amp;lt;filter-spec&amp;gt;&lt;/code&gt; 양식 은 &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc9ece81e668f48ca0c9284b17719cfe0a863c67" translate="yes" xml:space="preserve">
          <source>Reserved characters are: &quot;%&quot; (used for encoding), &quot;+&quot; (can be used to encode SPACE), all whitespace characters as defined in Perl, including SP, TAB and LF, (used to separate fields in a record).</source>
          <target state="translated">예약 문자는 &quot;%&quot;(인코딩에 사용됨), &quot;+&quot;(SPACE를 인코딩하는 데 사용할 수 있음), SP, TAB 및 LF를 포함하여 Perl에 정의 된 모든 공백 문자 (레코드에서 필드를 구분하는 데 사용됨)입니다.</target>
        </trans-unit>
        <trans-unit id="b42218495bd708d0856afd1fabb98c3577f4ad60" translate="yes" xml:space="preserve">
          <source>Reserved instruction</source>
          <target state="translated">예약 된 지시</target>
        </trans-unit>
        <trans-unit id="ade58d6ef106ac4468b520e2f9f718942ef96589" translate="yes" xml:space="preserve">
          <source>Reset &amp;lt;branchname&amp;gt; to &amp;lt;startpoint&amp;gt;, even if &amp;lt;branchname&amp;gt; exists already. Without &lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;git branch&lt;/code&gt; refuses to change an existing branch. In combination with &lt;code&gt;-d&lt;/code&gt; (or &lt;code&gt;--delete&lt;/code&gt;), allow deleting the branch irrespective of its merged status. In combination with &lt;code&gt;-m&lt;/code&gt; (or &lt;code&gt;--move&lt;/code&gt;), allow renaming the branch even if the new branch name already exists, the same applies for &lt;code&gt;-c&lt;/code&gt; (or &lt;code&gt;--copy&lt;/code&gt;).</source>
          <target state="translated">&amp;lt;branchname&amp;gt;이 이미 존재하더라도 &amp;lt;branchname&amp;gt;을 &amp;lt;startpoint&amp;gt;로 재설정하십시오. 없이 &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;git branch&lt;/code&gt; 기존 지점을 변경 거부합니다. &lt;code&gt;-d&lt;/code&gt; (또는 &lt;code&gt;--delete&lt;/code&gt; ) 와 함께 병합 된 상태에 관계없이 분기를 삭제할 수 있습니다. &lt;code&gt;-m&lt;/code&gt; (또는 &lt;code&gt;--move&lt;/code&gt; ) 과 함께 새 분기 이름이 이미 존재하더라도 분기 이름을 바꾸도록 허용하면 &lt;code&gt;-c&lt;/code&gt; (또는 &lt;code&gt;--copy&lt;/code&gt; ) 에도 동일하게 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c000dded32d603bd2d66f7de30922c3049331d8" translate="yes" xml:space="preserve">
          <source>Reset a single file in the index</source>
          <target state="translated">색인에서 단일 파일 재설정</target>
        </trans-unit>
        <trans-unit id="b199a41a6acc73bab0e76970a8b89b9149933695" translate="yes" xml:space="preserve">
          <source>Reset an existing branch (or a new branch) to a specific revision. This command must be used to change a branch to a specific revision without making a commit on it.</source>
          <target state="translated">기존 분기 (또는 새 분기)를 특정 개정으로 재설정합니다. 커밋하지 않고 분기를 특정 개정으로 변경하려면이 명령을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3caab3d6f602d251b347bcf8cb43ce25777589d7" translate="yes" xml:space="preserve">
          <source>Reset current HEAD to the specified state</source>
          <target state="translated">현재 HEAD를 지정된 상태로 재설정</target>
        </trans-unit>
        <trans-unit id="7000155564e143a5ed7b021bd65e423555a02d6b" translate="yes" xml:space="preserve">
          <source>Reset the conflict resolutions which rerere has recorded for the current conflict in &amp;lt;pathspec&amp;gt;.</source>
          <target state="translated">&amp;lt;pathspec&amp;gt;에서 현재 충돌에 대해 다시 기록 된 충돌 해결을 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="4a789604fce06a1f57b66b342300476ce0a41423" translate="yes" xml:space="preserve">
          <source>Reset the metadata used by rerere if a merge resolution is to be aborted. Calling &lt;code&gt;git am [--skip|--abort]&lt;/code&gt; or &lt;code&gt;git rebase [--skip|--abort]&lt;/code&gt; will automatically invoke this command.</source>
          <target state="translated">병합 해결을 중단하려면 rerere에서 사용하는 메타 데이터를 재설정하십시오. 호출 &lt;code&gt;git am [--skip|--abort]&lt;/code&gt; 또는 &lt;code&gt;git rebase [--skip|--abort]&lt;/code&gt; 자동으로이 명령을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="e58c6724a36573568d9a717f014941c665fe0e5c" translate="yes" xml:space="preserve">
          <source>Reset, restore and revert</source>
          <target state="translated">재설정, 복원 및 되돌리기</target>
        </trans-unit>
        <trans-unit id="cfb6b4d825df9b6e5392392c169da218cc9ebb7e" translate="yes" xml:space="preserve">
          <source>Resets index entries and updates files in the working tree that are different between &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; and &lt;code&gt;HEAD&lt;/code&gt;. If a file that is different between &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; and &lt;code&gt;HEAD&lt;/code&gt; has local changes, reset is aborted.</source>
          <target state="translated">작업 트리에서 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 과 &lt;code&gt;HEAD&lt;/code&gt; 가 다른 색인 항목을 재설정하고 파일을 업데이트합니다 . &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 과 &lt;code&gt;HEAD&lt;/code&gt; 가 다른 파일에 로컬 변경이 있으면 재설정이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="37918ef314fe9073b027113123d9b71065a3aa0b" translate="yes" xml:space="preserve">
          <source>Resets the index and updates the files in the working tree that are different between &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; and &lt;code&gt;HEAD&lt;/code&gt;, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added). If a file that is different between &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; and the index has unstaged changes, reset is aborted.</source>
          <target state="translated">인덱스를 재설정하고 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 과 &lt;code&gt;HEAD&lt;/code&gt; 사이에 다른 작업 트리의 파일을 업데이트 하지만 인덱스와 작업 트리 사이에 다른 파일 (예 : 추가되지 않은 변경 사항)은 유지합니다. &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 과 인덱스 사이에 다른 파일 이 스테이지되지 않은 변경 사항을 갖는 경우 재설정이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="66814a725afb76705c792c5c5bff2effba54bba2" translate="yes" xml:space="preserve">
          <source>Resets the index and working tree. Any changes to tracked files in the working tree since &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; are discarded.</source>
          <target state="translated">색인 및 작업 트리를 재설정합니다. &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 이후 작업 트리에서 추적 된 파일에 대한 모든 변경 사항 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="018c5d5ee267c3048a66b8317e0b378d380cebd3" translate="yes" xml:space="preserve">
          <source>Resets the index but not the working tree (i.e., the changed files are preserved but not marked for commit) and reports what has not been updated. This is the default action.</source>
          <target state="translated">작업 트리가 아닌 색인을 재설정하고 (즉, 변경된 파일은 유지되지만 커밋으로 표시되지 않음) 업데이트되지 않은 내용을보고합니다. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="367477f47d978611bcd2955ee4ebc351a609da8a" translate="yes" xml:space="preserve">
          <source>Resolve &quot;$GIT_DIR/&amp;lt;path&amp;gt;&quot; and takes other path relocation variables such as $GIT_OBJECT_DIRECTORY, $GIT_INDEX_FILE&amp;hellip;​ into account. For example, if $GIT_OBJECT_DIRECTORY is set to /foo/bar then &quot;git rev-parse --git-path objects/abc&quot; returns /foo/bar/abc.</source>
          <target state="translated">&quot;$ GIT_DIR / &amp;lt;path&amp;gt;&quot;를 해결하고 $ GIT_OBJECT_DIRECTORY, $ GIT_INDEX_FILE&amp;hellip;과 같은 다른 경로 재배치 변수를 고려하십시오. 예를 들어 $ GIT_OBJECT_DIRECTORY가 / foo / bar로 설정된 경우 &quot;git rev-parse --git-path objects / abc&quot;는 / foo / bar / abc를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c8bb6fc86c763639a02a3bc6b6e1886e0912fa99" translate="yes" xml:space="preserve">
          <source>Resolve the conflicts. Git will mark the conflicts in the working tree. Edit the files into shape and &lt;code&gt;git add&lt;/code&gt; them to the index. Use &lt;code&gt;git commit&lt;/code&gt; or &lt;code&gt;git merge --continue&lt;/code&gt; to seal the deal. The latter command checks whether there is a (interrupted) merge in progress before calling &lt;code&gt;git commit&lt;/code&gt;.</source>
          <target state="translated">충돌을 해결하십시오. 힘내 작업 트리에서 충돌을 표시합니다. 파일을 모양으로 편집하고 &lt;code&gt;git add&lt;/code&gt; 을 색인에 추가하십시오 . &lt;code&gt;git commit&lt;/code&gt; 또는 &lt;code&gt;git merge --continue&lt;/code&gt; 사용 하여 거래를 봉인하십시오. 후자의 명령은 &lt;code&gt;git commit&lt;/code&gt; 을 호출하기 전에 진행중인 (중단 된) 병합이 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="40be4fe30543d88c430c41f2a76b60f305a6a06a" translate="yes" xml:space="preserve">
          <source>Resolving a merge</source>
          <target state="translated">병합 해결</target>
        </trans-unit>
        <trans-unit id="3aa5d718d6655d399867529b5e479166f7b70223" translate="yes" xml:space="preserve">
          <source>Respect &lt;code&gt;include.*&lt;/code&gt; directives in config files when looking up values. Defaults to &lt;code&gt;off&lt;/code&gt; when a specific file is given (e.g., using &lt;code&gt;--file&lt;/code&gt;, &lt;code&gt;--global&lt;/code&gt;, etc) and &lt;code&gt;on&lt;/code&gt; when searching all config files.</source>
          <target state="translated">값을 찾을 때 구성 파일의 &lt;code&gt;include.*&lt;/code&gt; 지시문을 존중하십시오 . 기본값은 &lt;code&gt;off&lt;/code&gt; (예를 들어, 사용하여 특정 파일이 주어 졌을 때 &lt;code&gt;--file&lt;/code&gt; , &lt;code&gt;--global&lt;/code&gt; 등)과 &lt;code&gt;on&lt;/code&gt; 모든 설정 파일을 검색 할 때.</target>
        </trans-unit>
        <trans-unit id="3821457277b56f085d69d5b77c2d88808f6181de" translate="yes" xml:space="preserve">
          <source>Respect any colors specified in the &lt;code&gt;--format&lt;/code&gt; option. The &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; field must be one of &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;, or &lt;code&gt;auto&lt;/code&gt; (if &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; is absent, behave as if &lt;code&gt;always&lt;/code&gt; was given).</source>
          <target state="translated">&lt;code&gt;--format&lt;/code&gt; 옵션에 지정된 색상을 존중하십시오 . &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; 필드 중 하나 여야합니다 &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;never&lt;/code&gt; , 또는 &lt;code&gt;auto&lt;/code&gt; (경우 &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; 결석, 어떻게 동작 인 것처럼 &lt;code&gt;always&lt;/code&gt; 주어졌다).</target>
        </trans-unit>
        <trans-unit id="19c837ff313a7ba1f889a299cee54a40a7c6f84b" translate="yes" xml:space="preserve">
          <source>Responses to commands</source>
          <target state="translated">명령에 대한 응답</target>
        </trans-unit>
        <trans-unit id="cc0464b7666785d6a76e9f773de6c54d764f7865" translate="yes" xml:space="preserve">
          <source>Restart the httpd instance and exit. Regenerate configuration files as necessary for spawning a new instance.</source>
          <target state="translated">httpd 인스턴스를 다시 시작하고 종료하십시오. 새 인스턴스를 생성하는 데 필요한 구성 파일을 재생성하십시오.</target>
        </trans-unit>
        <trans-unit id="8887a5fdf01dac377097b251a845eb9047ab1106" translate="yes" xml:space="preserve">
          <source>Restart the rebasing process after having resolved a merge conflict.</source>
          <target state="translated">병합 충돌을 해결 한 후 rebasing 프로세스를 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="d21d225ced39acf1075b76301dc02cbf10edbb3b" translate="yes" xml:space="preserve">
          <source>Restart the rebasing process by skipping the current patch.</source>
          <target state="translated">현재 패치를 건너 뛰어 rebasing 프로세스를 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="c1f6ec05a9a6600d16e6b449eaa642ea5102eab3" translate="yes" xml:space="preserve">
          <source>Restore specified paths in the working tree with some contents from a restore source. If a path is tracked but does not exist in the restore source, it will be removed to match the source.</source>
          <target state="translated">작업 트리에서 지정된 경로를 복원 소스의 일부 내용으로 복원하십시오. 경로가 추적되었지만 복원 소스에 존재하지 않으면 소스와 일치하도록 경로가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="264c55416cc1f357f0822f338666c6b7bdbad148" translate="yes" xml:space="preserve">
          <source>Restore the original branch and abort the patching operation.</source>
          <target state="translated">원래 분기를 복원하고 패치 작업을 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="96e0fd08d6591454dd62291fbfc1b15a5b3e040c" translate="yes" xml:space="preserve">
          <source>Restore the working tree files with the content from the given tree. It is common to specify the source tree by naming a commit, branch or tag associated with it.</source>
          <target state="translated">주어진 트리의 내용으로 작업 트리 파일을 복원합니다. 커밋, 브랜치 또는 관련 태그를 명명하여 소스 트리를 지정하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="37dff9bce765051722ec36426d7fa455df094071" translate="yes" xml:space="preserve">
          <source>Restore working tree files</source>
          <target state="translated">작업 트리 파일 복원</target>
        </trans-unit>
        <trans-unit id="69b489de455beab1530c19815d63b57591075bcd" translate="yes" xml:space="preserve">
          <source>Restores the &lt;code&gt;unmerged&lt;/code&gt; or &lt;code&gt;needs updating&lt;/code&gt; state of a file during a merge if it was cleared by accident.</source>
          <target state="translated">실수로 파일을 지운 경우 병합하는 동안 파일 의 &lt;code&gt;unmerged&lt;/code&gt; 상태 또는 &lt;code&gt;needs updating&lt;/code&gt; 상태를 복원 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9851dc086eda7e8d693a5cc6867fc0671874ff9d" translate="yes" xml:space="preserve">
          <source>Restrict delta matches based on &quot;islands&quot;. See DELTA ISLANDS below.</source>
          <target state="translated">&quot;섬&quot;을 기준으로 델타 일치를 제한하십시오. 아래의 델타 섬을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8b8a383fd6388c6ea73ba5d43ff2fb9ca48cf7d7" translate="yes" xml:space="preserve">
          <source>Restrict three-way merge by &lt;code&gt;git read-tree&lt;/code&gt; to happen only if there is no file-level merging required, instead of resolving merge for trivial cases and leaving conflicting files unresolved in the index.</source>
          <target state="translated">사소한 경우에 대한 병합을 해결하고 충돌하는 파일을 색인에서 해결하지 않고 파일 레벨 병합이 필요하지 않은 경우에만 &lt;code&gt;git read-tree&lt;/code&gt; 에 의한 3 방향 병합을 제한 하십시오.</target>
        </trans-unit>
        <trans-unit id="3872426d236e98107658a5fa4ce3ec35943effaa" translate="yes" xml:space="preserve">
          <source>Restricted login shell for Git-only SSH access</source>
          <target state="translated">Git 전용 SSH 액세스를위한 제한된 로그인 쉘</target>
        </trans-unit>
        <trans-unit id="8aededfb12d70887c4524cf03227b8b417c18d04" translate="yes" xml:space="preserve">
          <source>Result is different from the value produced by git 1.9 and older or produced when an &quot;unstable&quot; hash (see --unstable below) is configured - even when used on a diff output taken without any use of &quot;-O&amp;lt;orderfile&amp;gt;&quot;, thereby making existing databases storing such &quot;unstable&quot; or historical patch-ids unusable.</source>
          <target state="translated">결과는 git 1.9 이하에서 생성 된 값과 다르거 나 &quot;-안정된&quot;해시 (아래의-안정적 참조)를 구성 할 때 생성됩니다. &quot;-O &amp;lt;orderfile&amp;gt;&quot;을 사용하지 않고 diff 출력에 사용하는 경우에도 따라서 이러한 &quot;불안정한&quot;또는 히스토리 패치 ID를 저장하는 기존 데이터베이스를 사용할 수 없게합니다.</target>
        </trans-unit>
        <trans-unit id="dd0be3ab949b7f61e7a99aac2ba7a208d6ea3a63" translate="yes" xml:space="preserve">
          <source>Retrieve and store user credentials</source>
          <target state="translated">사용자 자격 증명 검색 및 저장</target>
        </trans-unit>
        <trans-unit id="5a212fd6a296588049eb570292b8fddf3b170728" translate="yes" xml:space="preserve">
          <source>Retrieves the URLs for a remote. Configurations for &lt;code&gt;insteadOf&lt;/code&gt; and &lt;code&gt;pushInsteadOf&lt;/code&gt; are expanded here. By default, only the first URL is listed.</source>
          <target state="translated">리모컨의 URL을 검색합니다. &lt;code&gt;insteadOf&lt;/code&gt; 및 &lt;code&gt;pushInsteadOf&lt;/code&gt; 에 대한 구성 이 여기에서 확장되었습니다. 기본적으로 첫 번째 URL 만 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="9396c18e702afc19006375ff866bd100e0e10678" translate="yes" xml:space="preserve">
          <source>Return a matching credential, if any exists.</source>
          <target state="translated">일치하는 자격 증명이 있으면 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0f444cb29e88624498c6ae42d5b37c68efa3bab0" translate="yes" xml:space="preserve">
          <source>Returns the commit in plain text mail format, suitable for applying with &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt;.</source>
          <target state="translated">커밋을 &lt;a href=&quot;git-am&quot;&gt;git-am [1]로&lt;/a&gt; 적용하기에 적합한 일반 텍스트 메일 형식으로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9253efc397e5de345aa951a00d2c23f86bf7df99" translate="yes" xml:space="preserve">
          <source>Returns the raw data for the file in given repository, at given path and revision. Links to this action are marked &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">지정된 경로 및 개정에서 지정된 저장소의 파일에 대한 원시 데이터를 리턴합니다. 이 조치에 대한 링크는 &lt;code&gt;raw&lt;/code&gt; 로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="5df164550e4b46ec040a3d56bf7256552cf4621c" translate="yes" xml:space="preserve">
          <source>Reuse recorded resolution of conflicted merges</source>
          <target state="translated">충돌 병합의 기록 된 해상도 재사용</target>
        </trans-unit>
        <trans-unit id="8616b41a55b6598a78826f975dbbf7f7f8695b39" translate="yes" xml:space="preserve">
          <source>Reverse CVS keyword expansion (e.g. $Revision: 1.2.3.4$ becomes $Revision$) in working CVS checkout before applying patch.</source>
          <target state="translated">패치를 적용하기 전에 CVS 체크 아웃 작업에서 역 CVS 키워드 확장 (예 : $ Revision : 1.2.3.4 $가 $ Revision $이 됨)</target>
        </trans-unit>
        <trans-unit id="09d255659c37629cf7ad5a71d93e459ba7907206" translate="yes" xml:space="preserve">
          <source>Reverses the meaning of the &lt;code&gt;^&lt;/code&gt; prefix (or lack thereof) for all following revision specifiers, up to the next &lt;code&gt;--not&lt;/code&gt;.</source>
          <target state="translated">다음의 모든 수정 자 지정자 에 대한 &lt;code&gt;^&lt;/code&gt; 접두사 (또는 그 부족) 의 의미를 다음 &lt;code&gt;--not&lt;/code&gt; 까지 되돌 립니다.</target>
        </trans-unit>
        <trans-unit id="f5ecc3a2c0ef8c576038e5331d800290aa1dbb34" translate="yes" xml:space="preserve">
          <source>Revert some existing commits</source>
          <target state="translated">기존 커밋을 되돌리기</target>
        </trans-unit>
        <trans-unit id="2d05a07b19af8782049520b85fa598b5aae8245a" translate="yes" xml:space="preserve">
          <source>Revert the changes done by commits from the fifth last commit in master (included) to the third last commit in master (included), but do not create any commit with the reverted changes. The revert only modifies the working tree and the index.</source>
          <target state="translated">마스터의 5 번째 마지막 커밋 (포함)에서 커밋이 수행 한 변경 사항을 마스터의 3 번째 마지막 커밋 (포함)으로 되돌 리지만 되 돌린 변경 내용으로 커밋을 만들지 마십시오. 되돌리기는 작업 트리와 색인 만 수정합니다.</target>
        </trans-unit>
        <trans-unit id="d36b73a7d31ce14514491b7bd667f4a3a39a76f3" translate="yes" xml:space="preserve">
          <source>Revert the changes specified by the fourth last commit in HEAD and create a new commit with the reverted changes.</source>
          <target state="translated">HEAD에서 네 번째 마지막 커밋으로 지정된 변경 사항을 되돌리고 되 돌린 변경 사항으로 새 커밋을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7816a94047b619334a2511ddb1fb3870ada25153" translate="yes" xml:space="preserve">
          <source>Reverting a merge commit declares that you will never want the tree changes brought in by the merge. As a result, later merges will only bring in tree changes introduced by commits that are not ancestors of the previously reverted merge. This may or may not be what you want.</source>
          <target state="translated">병합 커밋을 되 돌리면 병합으로 인한 트리 변경을 원하지 않을 것입니다. 결과적으로 나중에 병합하면 이전에 되 돌린 병합의 조상이 아닌 커밋이 도입 한 트리 변경 사항 만 가져옵니다. 이것은 당신이 원하는 것일 수도 아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1541e4f3b28e3bf9bf5cd6cdf1c6fa7c5066ac0" translate="yes" xml:space="preserve">
          <source>Review and edit each patch you&amp;rsquo;re about to send. Default is the value of &lt;code&gt;sendemail.annotate&lt;/code&gt;. See the CONFIGURATION section for &lt;code&gt;sendemail.multiEdit&lt;/code&gt;.</source>
          <target state="translated">보내려는 각 패치를 검토하고 편집하십시오. 기본값은 &lt;code&gt;sendemail.annotate&lt;/code&gt; 의 값입니다 . &lt;code&gt;sendemail.multiEdit&lt;/code&gt; 에 대해서는 구성 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b78ae7131226d816b60a3640c70615147c2668fc" translate="yes" xml:space="preserve">
          <source>Revision range summary</source>
          <target state="translated">개정 범위 요약</target>
        </trans-unit>
        <trans-unit id="0e507d58daf108f33aa81c2ab9d974a6ce0836d6" translate="yes" xml:space="preserve">
          <source>Revision shown. Defaults to HEAD.</source>
          <target state="translated">개정이 표시되었습니다. 기본값은 HEAD입니다.</target>
        </trans-unit>
        <trans-unit id="2dba79611a64646631612329658c566246fbc9f0" translate="yes" xml:space="preserve">
          <source>Revisions</source>
          <target state="translated">Revisions</target>
        </trans-unit>
        <trans-unit id="0b4be1f6169f38f3814188ca6321f0baef4e8d0e" translate="yes" xml:space="preserve">
          <source>Revisions come first and then paths. E.g. in &lt;code&gt;git diff v1.0 v2.0 arch/x86 include/asm-x86&lt;/code&gt;, &lt;code&gt;v1.0&lt;/code&gt; and &lt;code&gt;v2.0&lt;/code&gt; are revisions and &lt;code&gt;arch/x86&lt;/code&gt; and &lt;code&gt;include/asm-x86&lt;/code&gt; are paths.</source>
          <target state="translated">수정본이 먼저 나온 다음 경로입니다. 예를 들어 &lt;code&gt;git diff v1.0 v2.0 arch/x86 include/asm-x86&lt;/code&gt; , &lt;code&gt;v1.0&lt;/code&gt; 및 &lt;code&gt;v2.0&lt;/code&gt; 은 개정이며 &lt;code&gt;arch/x86&lt;/code&gt; 및 &lt;code&gt;include/asm-x86&lt;/code&gt; 은 경로입니다.</target>
        </trans-unit>
        <trans-unit id="7becdbbb2a8732024f87ab2931981f680230ef94" translate="yes" xml:space="preserve">
          <source>Rewind the master branch to get rid of those three commits.</source>
          <target state="translated">마스터 브랜치를 되 감아 서 세 가지 커밋을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="23707433283a99c49d086ac3b852fb7dc5a49bd7" translate="yes" xml:space="preserve">
          <source>Rewrite branches</source>
          <target state="translated">가지 다시 쓰기</target>
        </trans-unit>
        <trans-unit id="1f772054df9f197c59794505debe5263bced78f0" translate="yes" xml:space="preserve">
          <source>Rewrite the object IDs for the submodule specified by &amp;lt;name&amp;gt; from the values used in the from &amp;lt;file&amp;gt; to those used in the to &amp;lt;file&amp;gt;. The from marks should have been created by &lt;code&gt;git fast-export&lt;/code&gt;, and the to marks should have been created by &lt;code&gt;git fast-import&lt;/code&gt; when importing that same submodule.</source>
          <target state="translated">from &amp;lt;file&amp;gt;에 사용 된 값에서 &amp;lt;name&amp;gt;에 지정된 서브 모듈에 대한 오브젝트 ID를 to &amp;lt;file&amp;gt;에 사용 된 값으로 다시 작성하십시오. from 마크는 &lt;code&gt;git fast-export&lt;/code&gt; 에 의해 생성되어야하며 to 마크는 동일한 하위 모듈을 &lt;code&gt;git fast-import&lt;/code&gt; 때 git fast-import에 의해 생성되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="51c6d6dea3e502e9d6305607675f5d9cfa096787" translate="yes" xml:space="preserve">
          <source>Rewriting a single commit</source>
          <target state="translated">단일 커밋 재 작성</target>
        </trans-unit>
        <trans-unit id="f0b0b0c2a8ee1155d88307c80fb06e1df9172561" translate="yes" xml:space="preserve">
          <source>Rewriting history and maintaining patch series</source>
          <target state="translated">히스토리 재 작성 및 패치 시리즈 유지 보수</target>
        </trans-unit>
        <trans-unit id="b4a0f73cd12119000c1f6312d5dd619dd0ae5fda" translate="yes" xml:space="preserve">
          <source>Root of the Maildir to split. This directory should contain the cur, tmp and new subdirectories.</source>
          <target state="translated">분리 할 Maildir의 루트. 이 디렉토리에는 cur, tmp 및 new 서브 디렉토리가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="afeb98169e5519ad4e553da5035454587d62f649" translate="yes" xml:space="preserve">
          <source>Roughly speaking, there are two important workflows: merge and patch. The important difference is that the merge workflow can propagate full history, including merges, while patches cannot. Both workflows can be used in parallel: in &lt;code&gt;git.git&lt;/code&gt;, only subsystem maintainers use the merge workflow, while everyone else sends patches.</source>
          <target state="translated">대략적으로 말하면 병합과 패치라는 두 가지 중요한 작업 과정이 있습니다. 중요한 차이점은 병합 워크 플로는 병합을 포함하여 전체 기록을 전파 할 수 있지만 패치는 불가능하다는 것입니다. 두 워크 플로를 동시에 사용할 수 있습니다. &lt;code&gt;git.git&lt;/code&gt; 에서는 서브 시스템 관리자 만 병합 워크 플로를 사용하고 다른 모든 사람은 패치를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="4ad3e9112d465fbfd17a48a5928f94fb9df2be8b" translate="yes" xml:space="preserve">
          <source>Routines to help parsing remote repository access parameters</source>
          <target state="translated">원격 저장소 액세스 매개 변수를 구문 분석하는 데 도움이되는 루틴</target>
        </trans-unit>
        <trans-unit id="3495f8aaa83c51339b8e8d234a997810c199e605" translate="yes" xml:space="preserve">
          <source>Rule: Merge to downstream only at well-defined points</source>
          <target state="translated">규칙 : 잘 정의 된 지점에서만 다운 스트림으로 병합</target>
        </trans-unit>
        <trans-unit id="09660bd61221506e477e31f1dd27fab9f41227cb" translate="yes" xml:space="preserve">
          <source>Rule: Merge upwards</source>
          <target state="translated">규칙 : 위쪽으로 병합</target>
        </trans-unit>
        <trans-unit id="54160ff726068ad54950593ff8fc01c56330b6b4" translate="yes" xml:space="preserve">
          <source>Rule: Throw-away integration branches</source>
          <target state="translated">규칙 : 폐기 통합 분기</target>
        </trans-unit>
        <trans-unit id="2f47e21adb2d5e1ec4b0ccaaeca3d73a008017d2" translate="yes" xml:space="preserve">
          <source>Rule: Topic branches</source>
          <target state="translated">규칙 : 주제 분기</target>
        </trans-unit>
        <trans-unit id="fda6b71ba420bf88a3b35fd7a8c9d96c7d2ca360" translate="yes" xml:space="preserve">
          <source>Run 3-way file level merge for text files, but take lines from both versions, instead of leaving conflict markers. This tends to leave the added lines in the resulting file in random order and the user should verify the result. Do not use this if you do not understand the implications.</source>
          <target state="translated">텍스트 파일에 대해 3 방향 파일 수준 병합을 실행하지만 충돌 마커를 남기지 않고 두 버전에서 줄을 가져옵니다. 결과 파일에 추가 된 줄을 임의의 순서로 남겨 두는 경향이 있으므로 사용자는 결과를 확인해야합니다. 의미를 이해하지 못하는 경우에는 이것을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a160fe3e32ea42046eaaac9053e680c14caafda7" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;git fetch origin&lt;/code&gt; from the public repository of your upstream every once in a while. This does only the first half of &lt;code&gt;git pull&lt;/code&gt; but does not merge. The head of the public repository is stored in &lt;code&gt;.git/refs/remotes/origin/master&lt;/code&gt;.</source>
          <target state="translated">업스트림의 공용 저장소에서 &lt;code&gt;git fetch origin&lt;/code&gt; 을 실행하십시오 . 이것은 &lt;code&gt;git pull&lt;/code&gt; 의 처음 절반 만 수행하지만 병합하지는 않습니다. 공용 저장소의 헤드는 &lt;code&gt;.git/refs/remotes/origin/master&lt;/code&gt; 에 저장 됩니다.</target>
        </trans-unit>
        <trans-unit id="e5df7e2d67065569be056bdfd06fe71034940306" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;git gc --auto&lt;/code&gt; at the end to perform garbage collection if needed. This is enabled by default.</source>
          <target state="translated">필요한 경우 마지막에 &lt;code&gt;git gc --auto&lt;/code&gt; 를 실행 하여 가비지 수집을 수행하십시오. 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6039403ffea6ab0903949880e74c464732db7a11" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;git maintenance run --auto&lt;/code&gt; at the end to perform automatic repository maintenance if needed. (&lt;code&gt;--[no-]auto-gc&lt;/code&gt; is a synonym.) This is enabled by default.</source>
          <target state="translated">실행 &lt;code&gt;git maintenance run --auto&lt;/code&gt; 필요한 경우 자동으로 저장소 유지 관리 작업을 수행 끝에. ( &lt;code&gt;--[no-]auto-gc&lt;/code&gt; 는 동의어입니다.) 이것은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb6f5eee3c049cb1a6dcee0979306b460610b633" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;git-p4 submit --help&lt;/code&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;git-p4 submit --help&lt;/code&gt; 를 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="d4c2111aa7a129dccec5c5c0fa7a3c629e6b4b60" translate="yes" xml:space="preserve">
          <source>Run a merge for files needing merging</source>
          <target state="translated">병합이 필요한 파일에 대해 병합 실행</target>
        </trans-unit>
        <trans-unit id="56deae0bf4d8ef1e2306db4544bba762fbe034dc" translate="yes" xml:space="preserve">
          <source>Run a three-way file merge</source>
          <target state="translated">3 방향 파일 병합 실행</target>
        </trans-unit>
        <trans-unit id="454ceea0bbe28544bd004a32b164a804513700b9" translate="yes" xml:space="preserve">
          <source>Run as if git was started in &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; instead of the current working directory. When multiple &lt;code&gt;-C&lt;/code&gt; options are given, each subsequent non-absolute &lt;code&gt;-C &amp;lt;path&amp;gt;&lt;/code&gt; is interpreted relative to the preceding &lt;code&gt;-C
&amp;lt;path&amp;gt;&lt;/code&gt;. If &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; is present but empty, e.g. &lt;code&gt;-C &quot;&quot;&lt;/code&gt;, then the current working directory is left unchanged.</source>
          <target state="translated">현재 작업 디렉토리 대신 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 에서 git이 시작된 것처럼 실행하십시오 . 여러 개의 &lt;code&gt;-C&lt;/code&gt; 옵션이 제공 될 때 , 각각의 후속 비 절대 &lt;code&gt;-C &amp;lt;path&amp;gt;&lt;/code&gt; 는 앞의 &lt;code&gt;-C &amp;lt;path&amp;gt;&lt;/code&gt; 대해 해석 됩니다. 경우 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 존재하지만, 예를 들어, 비어 &lt;code&gt;-C &quot;&quot;&lt;/code&gt; , 현재 작업 디렉토리는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a57bdd6deda30e0d464ee7ac9f51bb6cd990f64" translate="yes" xml:space="preserve">
          <source>Run git-daemon to serve /pub/scm from inetd.</source>
          <target state="translated">git-daemon을 실행하여 inetd에서 / pub / scm을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="2b3f7399788c5a94c105f34c23c2a49d757c1096" translate="yes" xml:space="preserve">
          <source>Run git-daemon to serve /pub/scm from xinetd.</source>
          <target state="translated">git-daemon을 실행하여 xinetd에서 / pub / scm을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="29a03b5fc4e803018eee3893eddf1e9108c87d3d" translate="yes" xml:space="preserve">
          <source>Run interactively.</source>
          <target state="translated">대화식으로 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f367a056462dd8b9f00355ca4ea04e6dfae0f7a4" translate="yes" xml:space="preserve">
          <source>Run merge against all files in the index that need merging.</source>
          <target state="translated">병합해야하는 인덱스의 모든 파일에 대해 병합을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="234f84747fbb8e336dcf4106732f26a4c98fccdf" translate="yes" xml:space="preserve">
          <source>Run merge conflict resolution tools to resolve merge conflicts</source>
          <target state="translated">병합 충돌 해결 도구를 실행하여 병합 충돌 해결</target>
        </trans-unit>
        <trans-unit id="297b88341d487657ac7bfaea2e82d26521a04a34" translate="yes" xml:space="preserve">
          <source>Run tasks to optimize Git repository data</source>
          <target state="translated">작업을 실행하여 Git 저장소 데이터 최적화</target>
        </trans-unit>
        <trans-unit id="6f4bd94ff5f1951786b4d70e32a9fd3f734eea92" translate="yes" xml:space="preserve">
          <source>Run the command silently, without creating a window to display its output.</source>
          <target state="translated">출력을 표시하는 창을 작성하지 않고 명령을 자동으로 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="1bc8f86a1473f5767bf3c60c210d9437103d96b3" translate="yes" xml:space="preserve">
          <source>Run the tool only if a diff is selected in the GUI. It guarantees that &lt;code&gt;FILENAME&lt;/code&gt; is not empty.</source>
          <target state="translated">GUI에서 diff가 선택된 경우에만 도구를 실행하십시오. &lt;code&gt;FILENAME&lt;/code&gt; 이 비어 있지 않다는 것을 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="6a6c6a22304c9bf76fa5e2f3f8dca8cd7bf5e3ac" translate="yes" xml:space="preserve">
          <source>Run this script and save its output to a file. This file could then be used as projects list file, which means that you can set &lt;code&gt;$projects_list&lt;/code&gt; to its filename.</source>
          <target state="translated">이 스크립트를 실행하고 출력을 파일로 저장하십시오. 그런 다음이 파일을 프로젝트 목록 파일로 사용할 수 있습니다. 즉, &lt;code&gt;$projects_list&lt;/code&gt; 를 파일 이름으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4350cd9be7c2a6a88a109bf8474f97ce8036333" translate="yes" xml:space="preserve">
          <source>Run verbosely.</source>
          <target state="translated">자세하게 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="0580e4cb5c8782966251586e9fca0c52971499d2" translate="yes" xml:space="preserve">
          <source>Run verbosely. Does not affect the reporting of progress status to the standard error stream.</source>
          <target state="translated">자세하게 실행하십시오. 표준 오류 스트림에 진행 상태를보고하는 데 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6c2918d91700995262364e3455a1fa1e70615ff" translate="yes" xml:space="preserve">
          <source>Running &quot;git tag&quot; without arguments also lists all tags. The pattern is a shell wildcard (i.e., matched using fnmatch(3)). Multiple patterns may be given; if any of them matches, the tag is shown.</source>
          <target state="translated">인수없이 &quot;git tag&quot;를 실행하면 모든 태그가 나열됩니다. 패턴은 쉘 와일드 카드입니다 (즉, fnmatch (3)을 사용하여 일치). 여러 패턴이 제공 될 수 있습니다. 둘 중 하나라도 일치하면 태그가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a2ee2445637d31b2b0a87c4075e11372cbe6d8cc" translate="yes" xml:space="preserve">
          <source>Running &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;, &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, &lt;a href=&quot;git-diff-index&quot;&gt;git-diff-index[1]&lt;/a&gt;, &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree[1]&lt;/a&gt;, or &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt; with the &lt;code&gt;-p&lt;/code&gt; option produces patch text. You can customize the creation of patch text via the &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; and the &lt;code&gt;GIT_DIFF_OPTS&lt;/code&gt; environment variables (see &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;).</source>
          <target state="translated">실행 &lt;a href=&quot;git-diff&quot;&gt;자식-DIFF를 [1]&lt;/a&gt; , &lt;a href=&quot;git-log&quot;&gt;자식 로그 [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;자식 쇼 [1]&lt;/a&gt; , &lt;a href=&quot;git-diff-index&quot;&gt;자식-DIFF 인덱스 [1]&lt;/a&gt; , &lt;a href=&quot;git-diff-tree&quot;&gt;자식-DIFF 트리 [1]&lt;/a&gt; , 또는 &lt;a href=&quot;git-diff-files&quot;&gt;자식-DIFF-파일 [1]&lt;/a&gt; 와 &lt;code&gt;-p&lt;/code&gt; 옵션은 패치 텍스트를 생산하고 있습니다. &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 및 &lt;code&gt;GIT_DIFF_OPTS&lt;/code&gt; 환경 변수 를 통해 패치 텍스트 생성을 사용자 정의 할 수 있습니다 ( &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="803264f53d0e1d9dc0bb4982e51be37a05b958fa" translate="yes" xml:space="preserve">
          <source>Running &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;, &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, &lt;a href=&quot;git-diff-index&quot;&gt;git-diff-index[1]&lt;/a&gt;, &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree[1]&lt;/a&gt;, or &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt; with the &lt;code&gt;-p&lt;/code&gt; option produces patch text. You can customize the creation of patch text via the &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; and the &lt;code&gt;GIT_DIFF_OPTS&lt;/code&gt; environment variables.</source>
          <target state="translated">실행 &lt;a href=&quot;git-diff&quot;&gt;자식-DIFF를 [1]&lt;/a&gt; , &lt;a href=&quot;git-log&quot;&gt;자식 로그 [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;자식 쇼 [1]&lt;/a&gt; , &lt;a href=&quot;git-diff-index&quot;&gt;자식-DIFF 인덱스 [1]&lt;/a&gt; , &lt;a href=&quot;git-diff-tree&quot;&gt;자식-DIFF 트리 [1]&lt;/a&gt; , 또는 &lt;a href=&quot;git-diff-files&quot;&gt;자식-DIFF-파일 [1]&lt;/a&gt; 와 &lt;code&gt;-p&lt;/code&gt; 옵션은 패치 텍스트를 생산하고 있습니다. &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 및 &lt;code&gt;GIT_DIFF_OPTS&lt;/code&gt; 환경 변수 를 통해 패치 텍스트 작성을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79747aa96d21887b0b235c733b1bf62702e5f734" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;git gc&lt;/code&gt; manually should only be needed when adding objects to a repository without regularly running such porcelain commands, to do a one-off repository optimization, or e.g. to clean up a suboptimal mass-import. See the &quot;PACKFILE OPTIMIZATION&quot; section in &lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import[1]&lt;/a&gt; for more details on the import case.</source>
          <target state="translated">실행 &lt;code&gt;git gc&lt;/code&gt; 정기적으로 같은 도자기 명령을 실행하지 않고 저장소에 개체를 추가 할 때 수동으로 필요한 경우에만해야하는 것은 차선의 대량 수입을 정리하기 위해 일회성 저장소 최적화, 또는 예를 할 수 있습니다. 가져 오기 사례에 대한 자세한 내용 은 &lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import [1]&lt;/a&gt; 의 &quot;PACKFILE OPTIMIZATION&quot;섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5e2a5725ee1a3773dc9d930811a085d107277efd" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;git init&lt;/code&gt; in an existing repository is safe. It will not overwrite things that are already there. The primary reason for rerunning &lt;code&gt;git init&lt;/code&gt; is to pick up newly added templates (or to move the repository to another place if --separate-git-dir is given).</source>
          <target state="translated">기존 저장소에서 &lt;code&gt;git init&lt;/code&gt; 를 실행 하는 것이 안전합니다. 이미 존재하는 것을 덮어 쓰지 않습니다. &lt;code&gt;git init&lt;/code&gt; 를 다시 실행하는 주된 이유는 새로 추가 된 템플릿을 선택하거나 --separate-git-dir이 지정된 경우 리포지토리를 다른 위치로 옮기는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4a12225be5b345f509b740239e0b23dc61c4c69e" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;git merge&lt;/code&gt; or &lt;code&gt;git pull&lt;/code&gt; is NOT recommended on a branch you plan to &lt;code&gt;dcommit&lt;/code&gt; from because Subversion users cannot see any merges you&amp;rsquo;ve made. Furthermore, if you merge or pull from a Git branch that is a mirror of an SVN branch, &lt;code&gt;dcommit&lt;/code&gt; may commit to the wrong branch.</source>
          <target state="translated">Subversion 사용자는 병합을 볼 수 없기 때문에 &lt;code&gt;dcommit&lt;/code&gt; 하려는 분기에서 &lt;code&gt;git merge&lt;/code&gt; 또는 &lt;code&gt;git pull&lt;/code&gt; 을 실행 하지 않는 것이 좋습니다 . 또한 SVN 분기의 미러 인 Git 분기를 병합하거나 가져 오면 &lt;code&gt;dcommit&lt;/code&gt; 이 잘못된 분기를 커밋 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e5d95b0a65fda26d5c70bb844d87c3f30d59d6d" translate="yes" xml:space="preserve">
          <source>Running &lt;code&gt;git pack-refs&lt;/code&gt; in a repository renders it unclonable by Git versions prior to 1.5.1.2 over dumb transports such as HTTP. This variable determines whether &lt;code&gt;git gc&lt;/code&gt; runs &lt;code&gt;git pack-refs&lt;/code&gt;. This can be set to &lt;code&gt;notbare&lt;/code&gt; to enable it within all non-bare repos or it can be set to a boolean value. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">저장소에서 &lt;code&gt;git pack-refs&lt;/code&gt; 를 실행 하면 HTTP와 같은 멍청한 전송을 통해 1.5.1.2 이전의 Git 버전에서이를 복제 할 수 없습니다. 이 변수는 &lt;code&gt;git gc&lt;/code&gt; 가 &lt;code&gt;git pack-refs&lt;/code&gt; 를 실행 할지 여부를 결정합니다 . 이 항목은 맨손이 아닌 모든 repos 내에서 사용 하도록 &lt;code&gt;notbare&lt;/code&gt; 로 설정하거나 부울 값으로 설정할 수 있습니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7e986747909ca421bbba8ffb613702a034d33901" translate="yes" xml:space="preserve">
          <source>Running git-filter-branch with either --tags or --all in your &amp;lt;rev-list options&amp;gt;. In order to retain annotated tags as annotated, you must use --tag-name-filter (and must not have restored from refs/original/ in a previously botched rewrite).</source>
          <target state="translated">&amp;lt;rev-list 옵션&amp;gt;에서 --tags 또는 --all을 사용하여 git-filter-branch를 실행하십시오. 주석이 달린 태그를 주석이있는 상태로 유지하려면 --tag-name-filter를 사용해야합니다 (그리고 이전에 botched 재기록에서 refs / original /에서 복원되지 않아야 함).</target>
        </trans-unit>
        <trans-unit id="48b168cafbabe8dd5092d4e93800a7944e72448e" translate="yes" xml:space="preserve">
          <source>Running the &lt;code&gt;git rerere&lt;/code&gt; command immediately after a conflicted automerge records the conflicted working tree files, with the usual conflict markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; in them. Later, after you are done resolving the conflicts, running &lt;code&gt;git rerere&lt;/code&gt; again will record the resolved state of these files. Suppose you did this when you created the test merge of master into the topic branch.</source>
          <target state="translated">충돌 된 automerge 직후 &lt;code&gt;git rerere&lt;/code&gt; 명령을 실행하면 충돌하는 작업 트리 파일이 일반 충돌 마커 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;=======&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 와 함께 기록됩니다. 나중에 충돌을 해결 한 후 &lt;code&gt;git rerere&lt;/code&gt; 를 다시 실행 하면 이러한 파일의 해결 된 상태가 기록됩니다. 마스터의 테스트 병합을 토픽 브랜치에 작성할 때이를 수행했다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="59dc4b3f413e4c03677af110697445ae971ad5c3" translate="yes" xml:space="preserve">
          <source>Runs &lt;code&gt;git update-index&lt;/code&gt; itself on the paths whose index entries are different from those from the &lt;code&gt;HEAD&lt;/code&gt; commit.</source>
          <target state="translated">실행 &lt;code&gt;git update-index&lt;/code&gt; 인덱스 항목로부터와는 다른 경로에 자체 &lt;code&gt;HEAD&lt;/code&gt; 커밋.</target>
        </trans-unit>
        <trans-unit id="22e727ddf0d0e8f34303d3a3ff629cb6f10d1775" translate="yes" xml:space="preserve">
          <source>Runs &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;fetch&lt;/code&gt;. It will automatically create a directory based on the basename of the URL passed to it; or if a second argument is passed; it will create a directory and work within that. It accepts all arguments that the &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;fetch&lt;/code&gt; commands accept; with the exception of &lt;code&gt;--fetch-all&lt;/code&gt; and &lt;code&gt;--parent&lt;/code&gt;. After a repository is cloned, the &lt;code&gt;fetch&lt;/code&gt; command will be able to update revisions without affecting the working tree; and the &lt;code&gt;rebase&lt;/code&gt; command will be able to update the working tree with the latest changes.</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; 및 &lt;code&gt;fetch&lt;/code&gt; 를 실행 합니다 . 전달 된 URL의 기본 이름을 기반으로 디렉토리를 자동으로 작성합니다. 또는 두 번째 인수가 전달 된 경우 디렉토리를 생성하고 그 안에서 작동합니다. &lt;code&gt;init&lt;/code&gt; 및 &lt;code&gt;fetch&lt;/code&gt; 명령 이 허용하는 모든 인수를 허용합니다. &lt;code&gt;--fetch-all&lt;/code&gt; 및 &lt;code&gt;--parent&lt;/code&gt; 를 제외 하고 . 리포지토리가 복제 된 후 &lt;code&gt;fetch&lt;/code&gt; 명령은 작업 트리에 영향을주지 않으면 서 개정을 업데이트 할 수 있습니다. 그리고 &lt;code&gt;rebase&lt;/code&gt; 명령은 최신 변경 작업 트리를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="271b9f4ffa51b4716f220d02767212c2cbc90133" translate="yes" xml:space="preserve">
          <source>Runs a number of housekeeping tasks within the current repository, such as compressing file revisions (to reduce disk space and increase performance), removing unreachable objects which may have been created from prior invocations of &lt;code&gt;git add&lt;/code&gt;, packing refs, pruning reflog, rerere metadata or stale working trees. May also update ancillary indexes such as the commit-graph.</source>
          <target state="translated">파일 리포지토리 압축 (디스크 공간을 줄이고 성능을 향상시키기 위해), &lt;code&gt;git add&lt;/code&gt; 의 이전 호출에서 생성 된 도달 할 수없는 객체 제거 , ref 패킹, reflog 정리, 메타 데이터 다시 재생 과 같은 여러 저장소 관리 작업을 현재 저장소 내에서 실행합니다. 오래된 작업 나무. commit-graph와 같은 보조 인덱스를 업데이트 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="02aa629c8b16cd17a44f3a0efec2feed43937642" translate="yes" xml:space="preserve">
          <source>S</source>
          <target state="translated">S</target>
        </trans-unit>
        <trans-unit id="9aa5449df2c27f8c453076898c93afa895c00117" translate="yes" xml:space="preserve">
          <source>SCM</source>
          <target state="translated">SCM</target>
        </trans-unit>
        <trans-unit id="c571b86549e49bf223cf648388c46288c2241b5a" translate="yes" xml:space="preserve">
          <source>SHA-1</source>
          <target state="translated">SHA-1</target>
        </trans-unit>
        <trans-unit id="312e98fedb54c7d53ac4e72bc404817b90ff078b" translate="yes" xml:space="preserve">
          <source>SHA-1 identifiers of Git commit objects.</source>
          <target state="translated">Git 커밋 객체의 SHA-1 식별자.</target>
        </trans-unit>
        <trans-unit id="202b86696ac3129113c6d6b6693f7f6dc827b3d3" translate="yes" xml:space="preserve">
          <source>SHA-1 identifiers of Git tag objects.</source>
          <target state="translated">Git 태그 객체의 SHA-1 식별자.</target>
        </trans-unit>
        <trans-unit id="839226786b62bf95c9258e79140ac43890ceae07" translate="yes" xml:space="preserve">
          <source>SSH</source>
          <target state="translated">SSH</target>
        </trans-unit>
        <trans-unit id="1685ffa85727a883f0235855ad4fe17b10829246" translate="yes" xml:space="preserve">
          <source>SSH and File Transport</source>
          <target state="translated">SSH 및 파일 전송</target>
        </trans-unit>
        <trans-unit id="88179dba2afcc4bab1f73ecdf7a5b0b3ec852b33" translate="yes" xml:space="preserve">
          <source>SSH:</source>
          <target state="translated">SSH:</target>
        </trans-unit>
        <trans-unit id="4d1ffce8cc78d20fc8a69ac29d5637ff598777a6" translate="yes" xml:space="preserve">
          <source>SVN itself only stores times in UTC and nothing else. The regular svn client converts the UTC time to the local time (or based on the TZ= environment). This command has the same behaviour.</source>
          <target state="translated">SVN 자체는 시간을 UTC로만 저장하고 다른 것은 저장하지 않습니다. 일반 svn 클라이언트는 UTC 시간을 현지 시간으로 변환합니다 (또는 TZ = 환경 기준). 이 명령은 동작이 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2462783325d1946b85fa4d6ac9becc9ddef189e" translate="yes" xml:space="preserve">
          <source>Sadly, many merges aren&amp;rsquo;t trivial. If there are files that have been added, moved or removed, or if both branches have modified the same file, you will be left with an index tree that contains &quot;merge entries&quot; in it. Such an index tree can 'NOT' be written out to a tree object, and you will have to resolve any such merge clashes using other tools before you can write out the result.</source>
          <target state="translated">안타깝게도 많은 합병은 사소하지 않습니다. 추가, 이동 또는 제거 된 파일이 있거나 두 가지 모두 동일한 파일을 수정 한 경우 &quot;병합 항목&quot;이 포함 된 색인 트리가 남게됩니다. 이러한 인덱스 트리는 트리 개체에 'NOT'기록 될 수 없으며 결과를 기록하기 전에 다른 도구를 사용하여 이러한 병합 충돌을 해결해야합니다.</target>
        </trans-unit>
        <trans-unit id="a29b0686374a954376cc620b8979b45dec7b936c" translate="yes" xml:space="preserve">
          <source>Sadly, many merges aren&amp;rsquo;t trivial. If there are files that have been added, moved or removed, or if both branches have modified the same file, you will be left with an index tree that contains &quot;merge entries&quot; in it. Such an index tree can &lt;code&gt;NOT&lt;/code&gt; be written out to a tree object, and you will have to resolve any such merge clashes using other tools before you can write out the result.</source>
          <target state="translated">슬프게도 많은 병합이 사소한 것은 아닙니다. 추가, 이동 또는 제거 된 파일이 있거나 두 분기가 동일한 파일을 수정 한 경우 &quot;병합 항목&quot;이 포함 된 인덱스 트리가 남게됩니다. 이러한 인덱스 트리 할 수 &lt;code&gt;NOT&lt;/code&gt; 트리 객체에 기록 될, 당신은 당신이 결과를 기록 할 수 있습니다 전에 다른 도구를 사용하여 이러한 병합 충돌을 해결해야합니다.</target>
        </trans-unit>
        <trans-unit id="db6e7e410412f58574f766c3911f49badd42beca" translate="yes" xml:space="preserve">
          <source>Safety</source>
          <target state="translated">Safety</target>
        </trans-unit>
        <trans-unit id="c65f36deb58ec8692004d5f340eea1de5007232b" translate="yes" xml:space="preserve">
          <source>Salvage your data out of another SCM people love to hate</source>
          <target state="translated">사람들이 싫어하는 다른 SCM에서 데이터를 구하십시오</target>
        </trans-unit>
        <trans-unit id="7da4c768ec454f900a2b009758758bcc4c497617" translate="yes" xml:space="preserve">
          <source>Same as --mode but take mode encoded as a number. This is mainly used by other commands that have already parsed layout mode.</source>
          <target state="translated">--mode와 동일하지만 숫자로 인코딩 된 모드를 사용합니다. 주로 레이아웃 모드를 구문 분석 한 다른 명령에서 주로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2542706528d734cb50feb9bca7bdca378a008047" translate="yes" xml:space="preserve">
          <source>Same as --receive-pack=&amp;lt;git-receive-pack&amp;gt;.</source>
          <target state="translated">--receive-pack = &amp;lt;git-receive-pack&amp;gt;과 같습니다.</target>
        </trans-unit>
        <trans-unit id="70cac94413c3847bbe37b2e76044db02ae24aecd" translate="yes" xml:space="preserve">
          <source>Same as --upload-pack=&amp;lt;git-upload-pack&amp;gt;.</source>
          <target state="translated">--upload-pack = &amp;lt;git-upload-pack&amp;gt;과 같습니다.</target>
        </trans-unit>
        <trans-unit id="11461b23fcbc2ba6f710e4af2d4a469477579e7e" translate="yes" xml:space="preserve">
          <source>Same as -m, except that unmerged entries are discarded instead of failing. When used with &lt;code&gt;-u&lt;/code&gt;, updates leading to loss of working tree changes will not abort the operation.</source>
          <target state="translated">병합되지 않은 항목은 실패하는 대신 삭제된다는 점을 제외하고는 -m과 동일합니다. &lt;code&gt;-u&lt;/code&gt; 와 함께 사용하면 작업 트리 변경이 손실되는 업데이트로 인해 작업이 중단되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e08595bc7c109d0c181056c12a1b3a6619cb3279" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;--max-depth=-1&lt;/code&gt;; this is the default.</source>
          <target state="translated">&lt;code&gt;--max-depth=-1&lt;/code&gt; 과 동일 ; 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="fca1bc99780bb8b21bf845d99b40ff5d1d2ac6f4" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;--max-depth=0&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;code&gt;--max-depth=0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96a9581032de7bee365152ab2d305df909cefe47" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;--untracked-cache&lt;/code&gt;. Provided for backwards compatibility with older versions of Git where &lt;code&gt;--untracked-cache&lt;/code&gt; used to imply &lt;code&gt;--test-untracked-cache&lt;/code&gt; but this option would enable the extension unconditionally.</source>
          <target state="translated">&lt;code&gt;--untracked-cache&lt;/code&gt; 와 동일 합니다 . &lt;code&gt;--untracked-cache&lt;/code&gt; 가 &lt;code&gt;--test-untracked-cache&lt;/code&gt; untracked-cache 를 암시하는 데 사용되는 이전 버전의 Git과의 하위 호환성을 제공 하지만이 옵션은 무조건 확장을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="a5a8ba00c3dc1ba60d32f039cdc49baa9cb59855" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;--verify&lt;/code&gt; but shortens the object name to a unique prefix with at least &lt;code&gt;length&lt;/code&gt; characters. The minimum length is 4, the default is the effective value of the &lt;code&gt;core.abbrev&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;--verify&lt;/code&gt; 와 동일 하지만 객체 이름을 최소 &lt;code&gt;length&lt;/code&gt; 문자 를 가진 고유 접두어로 줄 입니다. 최소 길이는 4이며 기본값은 &lt;code&gt;core.abbrev&lt;/code&gt; 구성 변수 의 유효 값입니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="beb85fd3b6ce0903e1b1188af0e814b86495c278" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;-a&lt;/code&gt;, unless &lt;code&gt;-d&lt;/code&gt; is used. Then any unreachable objects in a previous pack become loose, unpacked objects, instead of being left in the old pack. Unreachable objects are never intentionally added to a pack, even when repacking. This option prevents unreachable objects from being immediately deleted by way of being left in the old pack and then removed. Instead, the loose unreachable objects will be pruned according to normal expiry rules with the next &lt;code&gt;git gc&lt;/code&gt; invocation. See &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;-d&lt;/code&gt; 를 사용 하지 않는 한 &lt;code&gt;-a&lt;/code&gt; 와 동일합니다 . 그런 다음 이전 팩에서 도달 할 수없는 객체는 이전 팩에 남아 있지 않고 느슨하고 포장이 풀린 객체가됩니다. 다시 포장 할 때에도 도달 할 수없는 객체는 의도적으로 팩에 추가되지 않습니다. 이 옵션은 연결할 수없는 개체가 이전 팩에 그대로 남아서 제거되는 것을 즉시 방지합니다. 대신, 다음 &lt;code&gt;git gc&lt;/code&gt; 호출 과 함께 일반적인 만기 규칙에 따라 도달 할 수없는 느슨한 오브젝트를 제거 합니다. &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff89956ed03482de99fb1d76b0d3426c3c4d4dbc" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;git gui citool&lt;/code&gt; (above).</source>
          <target state="translated">&lt;code&gt;git gui citool&lt;/code&gt; (위) 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="7f884bfa0e72398b065720ac608779bf0b3372aa" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;group&lt;/code&gt;, but make the repository readable by all users.</source>
          <target state="translated">&lt;code&gt;group&lt;/code&gt; 과 동일 하지만 모든 사용자가 저장소를 읽을 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="205ac751a2a286c261ce1f6df5fb256a7d0ade8e" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;strip&lt;/code&gt; except #commentary is not removed.</source>
          <target state="translated">#commentary가 제거되지 않은 것을 제외하고는 &lt;code&gt;strip&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="0f92cc3366a36ceb57ccdcea56b7f1a8684ec893" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;strip&lt;/code&gt; if the message is to be edited. Otherwise &lt;code&gt;whitespace&lt;/code&gt;.</source>
          <target state="translated">메시지를 편집 할 경우 &lt;code&gt;strip&lt;/code&gt; 과 동일 합니다. 그렇지 않으면 &lt;code&gt;whitespace&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a8e2d0cf73dc026e93d34c61a101205dcf767e79" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;whitespace&lt;/code&gt; except that everything from (and including) the line found below is truncated, if the message is to be edited. &quot;&lt;code&gt;#&lt;/code&gt;&quot; can be customized with core.commentChar.</source>
          <target state="translated">동일 &lt;code&gt;whitespace&lt;/code&gt; 메시지를 편집 할 경우 선이 아래의 발견 (등)에서 그 모든 것을 제외하고는 잘립니다. &quot; &lt;code&gt;#&lt;/code&gt; &quot;는 core.commentChar로 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe1030b7b6d63ee2bb092f0de364ad5810d90270" translate="yes" xml:space="preserve">
          <source>Same as above, but the format is inferred from the output file.</source>
          <target state="translated">위와 동일하지만 출력 파일에서 형식이 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="a3268177cdd166695f9afb4cfbb0a75c5f082adf" translate="yes" xml:space="preserve">
          <source>Same as above, but using the builtin tar.gz handling.</source>
          <target state="translated">위와 동일하지만 내장 tar.gz 처리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="316b1b6951145c81e2f6393678faa4164cbc2393" translate="yes" xml:space="preserve">
          <source>Same as above.</source>
          <target state="translated">같은 상기와.</target>
        </trans-unit>
        <trans-unit id="eceeb52d76c39f830be2caa3098c992d4c73cfa3" translate="yes" xml:space="preserve">
          <source>Same as the default mode, but does not prune some history.</source>
          <target state="translated">기본 모드와 동일하지만 일부 기록을 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db6a81d8b3d32523ab23e52ba20bfc5ab9af3c20" translate="yes" xml:space="preserve">
          <source>Save that patch to a file in UNIX mailbox format. Call it a.patch, say.</source>
          <target state="translated">해당 패치를 UNIX 메일 박스 형식의 파일로 저장하십시오. 그것을 패치라고 부르십시오.</target>
        </trans-unit>
        <trans-unit id="17bbcc9ad074be63eea942d50d7cda88e930f8d2" translate="yes" xml:space="preserve">
          <source>Save the process id in &lt;code&gt;file&lt;/code&gt;. Ignored when the daemon is run under &lt;code&gt;--inetd&lt;/code&gt;.</source>
          <target state="translated">프로세스 ID를 &lt;code&gt;file&lt;/code&gt; 에 저장하십시오 . &lt;code&gt;--inetd&lt;/code&gt; 에서 데몬이 실행될 때 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="15259adada7ee3df28dbdafd2e3ca8076b5f4a15" translate="yes" xml:space="preserve">
          <source>Save your local modifications to a new &lt;code&gt;stash entry&lt;/code&gt; and roll them back to HEAD (in the working tree and in the index). The &amp;lt;message&amp;gt; part is optional and gives the description along with the stashed state.</source>
          <target state="translated">로컬 수정 사항을 새 &lt;code&gt;stash entry&lt;/code&gt; 저장 하고 HEAD (작업 트리 및 색인)로 롤백하십시오. &amp;lt;message&amp;gt; 부분은 선택 사항이며 숨김 상태와 함께 설명을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ea6661dbb08a609142e04fb33fe9864a0d55a0fb" translate="yes" xml:space="preserve">
          <source>Saving a log and replaying it</source>
          <target state="translated">로그 저장 및 재생</target>
        </trans-unit>
        <trans-unit id="256f734933def8151aae2c73ad04adbfd2f5710e" translate="yes" xml:space="preserve">
          <source>Say you modify a branch with &lt;a href=&quot;#fixing-mistakes&quot;&gt;&lt;code&gt;git reset --hard&lt;/code&gt;&lt;/a&gt;, and then realize that the branch was the only reference you had to that point in history.</source>
          <target state="translated">&lt;a href=&quot;#fixing-mistakes&quot;&gt; &lt;code&gt;git reset --hard&lt;/code&gt; 를 사용&lt;/a&gt; 하여 브랜치를 수정하고 브랜치가 히스토리 에서 해당 지점에 대한 유일한 참조임을 인식하십시오.</target>
        </trans-unit>
        <trans-unit id="8f7159e28d007390950b554c8900463bad34bfe1" translate="yes" xml:space="preserve">
          <source>Scan &lt;code&gt;Documentation/&lt;/code&gt; for other stuff left out; in particular:</source>
          <target state="translated">다른 것들이 없는지 &lt;code&gt;Documentation/&lt;/code&gt; 스캔하십시오 ; 특히:</target>
        </trans-unit>
        <trans-unit id="deb6721d53898cf2febea6ade63b57224507999f" translate="yes" xml:space="preserve">
          <source>Scan email archives for other stuff left out</source>
          <target state="translated">다른 자료가 있는지 이메일 아카이브를 스캔하십시오.</target>
        </trans-unit>
        <trans-unit id="b53f30bf6406e325a3dfac40a2ba03843362a3a9" translate="yes" xml:space="preserve">
          <source>Scan man pages to see if any assume more background than this manual provides.</source>
          <target state="translated">매뉴얼 페이지를 스캔하여이 매뉴얼이 제공하는 것보다 더 많은 배경을 가지고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d1e8a9a092bccee1d0d707e7539fd2ea1ed01f5c" translate="yes" xml:space="preserve">
          <source>Scheme (e.g., &lt;code&gt;https&lt;/code&gt; in &lt;code&gt;https://example.com/&lt;/code&gt;). This field must match exactly between the config key and the URL.</source>
          <target state="translated">제도 (예를 들어, &lt;code&gt;https&lt;/code&gt; 에 &lt;code&gt;https://example.com/&lt;/code&gt; ). 이 필드는 구성 키와 URL이 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e05e395ff307d005e7e52d5a8d5532c4a364bbf" translate="yes" xml:space="preserve">
          <source>Search files in the current directory that is not managed by Git.</source>
          <target state="translated">Git이 관리하지 않는 현재 디렉토리에서 파일을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="b73a02f095e861ccf3246948d40c910baf6a01fe" translate="yes" xml:space="preserve">
          <source>Search for regressions:</source>
          <target state="translated">회귀 검색</target>
        </trans-unit>
        <trans-unit id="f6032042d4f48d36194af91f9c0f4e8546fac517" translate="yes" xml:space="preserve">
          <source>Search strategy</source>
          <target state="translated">검색 전략</target>
        </trans-unit>
        <trans-unit id="a28ca13aea7d9b0267664d0e0585dd1effd660f3" translate="yes" xml:space="preserve">
          <source>Second user-specific configuration file. If $XDG_CONFIG_HOME is not set or empty, &lt;code&gt;$HOME/.config/git/config&lt;/code&gt; will be used. Any single-valued variable set in this file will be overwritten by whatever is in &lt;code&gt;~/.gitconfig&lt;/code&gt;. It is a good idea not to create this file if you sometimes use older versions of Git, as support for this file was added fairly recently.</source>
          <target state="translated">두 번째 사용자 별 구성 파일 $ XDG_CONFIG_HOME이 설정되지 않거나 비어 있으면 &lt;code&gt;$HOME/.config/git/config&lt;/code&gt; 가 사용됩니다. 이 파일에 설정된 단일 값 변수는 &lt;code&gt;~/.gitconfig&lt;/code&gt; 에있는 내용으로 덮어 씁니다 . 이 파일에 대한 지원이 상당히 최근에 추가되었으므로 때때로 이전 버전의 Git을 사용하는 경우이 파일을 작성하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="08bcebdee7825304638fc52fdc68926c0d85826a" translate="yes" xml:space="preserve">
          <source>Second user-specific credentials file. If &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; is not set or empty, &lt;code&gt;$HOME/.config/git/credentials&lt;/code&gt; will be used. Any credentials stored in this file will not be used if &lt;code&gt;~/.git-credentials&lt;/code&gt; has a matching credential as well. It is a good idea not to create this file if you sometimes use older versions of Git that do not support it.</source>
          <target state="translated">두 번째 사용자 별 자격 증명 파일. 경우 &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; 설정하거나 비어 있지 않은, &lt;code&gt;$HOME/.config/git/credentials&lt;/code&gt; 사용됩니다. &lt;code&gt;~/.git-credentials&lt;/code&gt; 에 일치하는 자격 증명 이있는 경우이 파일에 저장된 자격 증명이 사용되지 않습니다 . 때때로 지원하지 않는 구 버전의 Git을 사용하는 경우이 파일을 작성하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b5c3361c98212e9d042aaaa5b0c10d9a1a465d8b" translate="yes" xml:space="preserve">
          <source>Second, repositories found in &lt;code&gt;/pub/scm/&lt;/code&gt; and &lt;code&gt;/var/git/&lt;/code&gt; will be accessible through &lt;code&gt;http://git.example.org/scm/&lt;/code&gt; and &lt;code&gt;http://git.example.org/var/&lt;/code&gt;. You can add as many project roots as you want by adding rewrite rules like the third and the fourth.</source>
          <target state="translated">둘째, &lt;code&gt;/pub/scm/&lt;/code&gt; 및 &lt;code&gt;/var/git/&lt;/code&gt; 는 &lt;code&gt;http://git.example.org/scm/&lt;/code&gt; 및 &lt;code&gt;http://git.example.org/var/&lt;/code&gt; 를 통해 액세스 할 수 있습니다 . 세 번째와 네 번째와 같은 다시 쓰기 규칙을 추가하여 원하는 수의 프로젝트 루트를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d5abfbb7006b1c4a1d7df3783d45b48d9d41d48" translate="yes" xml:space="preserve">
          <source>Seconds wait before reconnecting to smtp server. See also the &lt;code&gt;--relogin-delay&lt;/code&gt; option of &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt;.</source>
          <target state="translated">smtp 서버에 다시 연결하기 전에 대기합니다. &lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt; 의 &lt;code&gt;--relogin-delay&lt;/code&gt; 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="16adbe8ae2ec1d5ce021aca603249932e4af29cb" translate="yes" xml:space="preserve">
          <source>Sections can be further divided into subsections. To begin a subsection put its name in double quotes, separated by space from the section name, in the section header, like in the example below:</source>
          <target state="translated">섹션은 하위 섹션으로 더 나눌 수 있습니다. 하위 섹션을 시작하려면 아래 예제와 같이 섹션 헤더에서 이름을 공백으로 구분하여 큰 따옴표로 묶으십시오.</target>
        </trans-unit>
        <trans-unit id="f25ce1b8a399bd8621a57427a20039b4b13935db" translate="yes" xml:space="preserve">
          <source>Security</source>
          <target state="translated">Security</target>
        </trans-unit>
        <trans-unit id="cb670e82b44c131414fdd62cec2e2271a0c3e1ce" translate="yes" xml:space="preserve">
          <source>See &quot;Reset, restore and revert&quot; in &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; for the differences between the three commands.</source>
          <target state="translated">세 명령의 차이점에 대해서는 &lt;a href=&quot;git&quot;&gt;git [1]의&lt;/a&gt; &quot;재설정, 복원 및 되돌리기&quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="449a31d4b9b49095d0b90df41f056d43c8512f47" translate="yes" xml:space="preserve">
          <source>See &amp;ldquo;Responses To Commands&amp;rdquo; below for details about how to read this output safely.</source>
          <target state="translated">이 출력을 안전하게 읽는 방법에 대한 자세한 내용은 아래의 &quot;명령에 대한 응답&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="814949d103c65b43b61081c8789235b00c3553fa" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;api-trace2&quot;&gt;Trace2 documentation&lt;/a&gt; for full details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;api-trace2&quot;&gt;Trace2 설명서&lt;/a&gt; 를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="b53c26f4c249563ab9682d7689da982420c04631" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-add&quot;&gt;git-add [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa55cebc3f97b3ec5f8f25b42d230a3ac0a7871d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;</source>
          <target state="translated">참조 &lt;a href=&quot;git-config&quot;&gt;자식-설정을 [1]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="927ac170ac73e3dd929a2427d80cab2492ff1deb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for core variables and &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; for settings related to diff generation.</source>
          <target state="translated">핵심 변수에 대해서는 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 및 diff 생성과 관련된 설정에 대해서는 &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29e0897ca1f4dba055ef02d2ee4ea34bca59c450" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for more details on the configuration options mentioned above and &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; for more details on the refspec syntax.</source>
          <target state="translated">위에서 언급 한 구성 옵션에 대한 자세한 내용 은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 및 refspec 구문에 대한 자세한 내용은 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c85dd3188b261218c6ce78dddb7cf27f02c4e498" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; for the full list of supported options.</source>
          <target state="translated">지원되는 전체 옵션 목록은 &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="873eafed92c6d143cde4cdd22e9f2f62fb8eab44" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; for details, including how conflicts are presented and handled.</source>
          <target state="translated">충돌 표시 및 처리 방법을 포함하여 자세한 내용 은 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a1dbf552c05185bb952ce9cddaaca48b3f486c1e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; for some hints on resolving such conflicts.</source>
          <target state="translated">이러한 충돌을 해결하는 데 대한 힌트는 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="750a5c09f00fba2da655305aeb20c963fba7eb6e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; for options to generate new packs and replace existing ones.</source>
          <target state="translated">새 팩을 생성하고 기존 팩을 교체하는 옵션에 대해서는 &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f51d5b8b3fb6117dc301434a5ecd4dd13bfc3fc0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt; for description.</source>
          <target state="translated">설명은 &lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="55b7b7d87b2ef94a0c0800814d27411d440df3c7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt; for description. Note that this setting is not subject to the &lt;code&gt;identity&lt;/code&gt; mechanism.</source>
          <target state="translated">설명은 &lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt; 을 참조하십시오 . 이 설정에는 &lt;code&gt;identity&lt;/code&gt; 메커니즘이 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="356db06bc40009203665e547b41d48a6fe47dfb9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="816c081fd3a62310db506118ba38e561a6d69e40" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt; for the details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a58028451af0f9f542d0d8f8d9f591126508cad5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more general info on hook execution.</source>
          <target state="translated">후크 실행에 대한 일반적인 정보는 &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba609b5467f233e457aa9eddbdd4e4c279fc02c9" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt; for a detailed explanation of the syntax. You can also place .gitignore files in other directories in your working tree, and they will apply to those directories and their subdirectories. The &lt;code&gt;.gitignore&lt;/code&gt; files can be added to your repository like any other files (just run &lt;code&gt;git add
.gitignore&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt;, as usual), which is convenient when the exclude patterns (such as patterns matching build output files) would also make sense for other users who clone your repository.</source>
          <target state="translated">구문에 대한 자세한 설명은 &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; 를 참조하십시오 . 작업 트리의 다른 디렉토리에 .gitignore 파일을 배치 할 수 있으며 해당 디렉토리 및 해당 서브 디렉토리에 적용됩니다. &lt;code&gt;.gitignore&lt;/code&gt; 의 파일을 다른 파일처럼 저장소에 추가 할 수 있습니다 (다만 실행 &lt;code&gt;git add .gitignore&lt;/code&gt; 와 &lt;code&gt;git commit&lt;/code&gt; 평소처럼)도에 대한 이해 것 (예 : 빌드 출력 파일을 일치 패턴과 같은) 패턴을 제외 할 때 편리하다, 저장소를 복제하는 다른 사용자</target>
        </trans-unit>
        <trans-unit id="6c08679dcde5f574a046d2c372d4d13c77c14f09" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; for more information. The rule of thumb is do not make any assumption about whether a path belongs to $GIT_DIR or $GIT_COMMON_DIR when you need to directly access something inside $GIT_DIR. Use &lt;code&gt;git rev-parse --git-path&lt;/code&gt; to get the final path.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt; 를 참조하십시오. 경험상 $ GIT_DIR 내부에 직접 액세스해야 할 경우 경로가 $ GIT_DIR 또는 $ GIT_COMMON_DIR에 속하는지 여부를 가정하지 않습니다. 최종 경로를 얻으려면 &lt;code&gt;git rev-parse --git-path&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="68978af0c4229a0c7ad3871d3bd5d420a7abb9f0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; for more information. The rule of thumb is do not make any assumption about whether a path belongs to &lt;code&gt;$GIT_DIR&lt;/code&gt; or &lt;code&gt;$GIT_COMMON_DIR&lt;/code&gt; when you need to directly access something inside &lt;code&gt;$GIT_DIR&lt;/code&gt;. Use &lt;code&gt;git rev-parse --git-path&lt;/code&gt; to get the final path.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt; 를 참조하십시오. 엄지 손가락의 규칙은 경로에 속하는지 여부에 대한 가정을하지 않는 것입니다 &lt;code&gt;$GIT_DIR&lt;/code&gt; 또는 &lt;code&gt;$GIT_COMMON_DIR&lt;/code&gt; 당신이 내부 액세스 뭔가 직접 필요할 때 &lt;code&gt;$GIT_DIR&lt;/code&gt; . 사용 &lt;code&gt;git rev-parse --git-path&lt;/code&gt; 최종 경로를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a0cffbb9b88d8945c0266619dda8f84ab7a60d6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt; to get started, then see &lt;a href=&quot;giteveryday&quot;&gt;giteveryday[7]&lt;/a&gt; for a useful minimum set of commands. The &lt;a href=&quot;user-manual&quot;&gt;Git User&amp;rsquo;s Manual&lt;/a&gt; has a more in-depth introduction.</source>
          <target state="translated">참조 &lt;a href=&quot;gittutorial&quot;&gt;[7] gittutorial은&lt;/a&gt; 다음을 참조하십시오 시작하는 &lt;a href=&quot;giteveryday&quot;&gt;giteveryday [7]&lt;/a&gt; 명령 유용한 최소 세트를. &lt;a href=&quot;user-manual&quot;&gt;망할 놈의 사용 설명서는&lt;/a&gt; 좀 더 깊이있는 소개가 있습니다.</target>
        </trans-unit>
        <trans-unit id="edb8fa06792cc06c9610f82e7507e11aaf0b3a79" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;gitweb&quot;&gt;gitweb[1]&lt;/a&gt; for description.</source>
          <target state="translated">설명은 &lt;a href=&quot;gitweb&quot;&gt;gitweb [1]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="551344f7c6d18aeed126c268a4887b60ea41a732" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt; for description.</source>
          <target state="translated">설명은 &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b24fd2d7766898a78228977078b6f143b9eddd17" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;gitworkflows&quot;&gt;gitworkflows[7]&lt;/a&gt; for an overview of recommended workflows.</source>
          <target state="translated">권장되는 워크 플로우에 대한 개요는 &lt;a href=&quot;gitworkflows&quot;&gt;gitworkflows [7]&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5aaf5106e04565ca03205c2325b61134a265836" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://repo.or.cz/w/git.git/tree/HEAD:/gitweb/&quot;&gt;http://repo.or.cz/w/git.git/tree/HEAD:/gitweb/&lt;/a&gt; for gitweb source code, browsed using gitweb itself.</source>
          <target state="translated">gitweb 자체를 사용하여 탐색 한 gitweb 소스 코드는 &lt;a href=&quot;http://repo.or.cz/w/git.git/tree/HEAD:/gitweb/&quot;&gt;http://repo.or.cz/w/git.git/tree/HEAD:/gitweb/&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf4e44a1f9a750a558dfae089d3110695a154f52" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;multi-pack-index&quot;&gt;The Multi-Pack-Index Design Document&lt;/a&gt; and &lt;a href=&quot;pack-format&quot;&gt;The Multi-Pack-Index Format&lt;/a&gt; for more information on the multi-pack-index feature.</source>
          <target state="translated">참조 &lt;a href=&quot;multi-pack-index&quot;&gt;멀티 팩 - 인덱스 디자인 문서&lt;/a&gt; 및 &lt;a href=&quot;pack-format&quot;&gt;멀티 팩 - 인덱스 형식&lt;/a&gt; 멀티 팩 - 인덱스 기능에 대한 자세한 정보를.</target>
        </trans-unit>
        <trans-unit id="119e1af35250f977a84e7e9b44e17bab322217d6" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;filemodify&lt;/code&gt; above for a detailed description of &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 에 대한 자세한 설명은 위의 &lt;code&gt;filemodify&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5e5425cc0264ed1e0714353419a5218265f25cb" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;p4 help revisions&lt;/code&gt; for the full syntax of p4 revision specifiers.</source>
          <target state="translated">p4 개정 지정자의 전체 구문은 &lt;code&gt;p4 help revisions&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="349e8ba30a5911b964eb56ddd5398d0c455fca71" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;pull.rebase&lt;/code&gt;, &lt;code&gt;branch.&amp;lt;name&amp;gt;.rebase&lt;/code&gt; and &lt;code&gt;branch.autoSetupRebase&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; if you want to make &lt;code&gt;git pull&lt;/code&gt; always use &lt;code&gt;--rebase&lt;/code&gt; instead of merging.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 이 병합 대신 항상 &lt;code&gt;--rebase&lt;/code&gt; 를 사용 하도록하려면 &lt;a href=&quot;git-config&quot;&gt;git-config [1]의 &lt;/a&gt; &lt;code&gt;pull.rebase&lt;/code&gt; , &lt;code&gt;branch.&amp;lt;name&amp;gt;.rebase&lt;/code&gt; 및 &lt;code&gt;branch.autoSetupRebase&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6821589cea1a5f5eeaa157482f5875c8dd6c83e8" translate="yes" xml:space="preserve">
          <source>See OPTIONS for a list of currently defined options.</source>
          <target state="translated">현재 정의 된 옵션 목록은 옵션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a7e489653a4ac322711d151924724bebeaab7578" translate="yes" xml:space="preserve">
          <source>See REF LIST ATTRIBUTES for a list of currently defined attributes.</source>
          <target state="translated">현재 정의 된 속성의 목록은 참조 목록 속성을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3f21653c235501bb7bff551e983de8d0a4c4aca2" translate="yes" xml:space="preserve">
          <source>See REF LIST ATTRIBUTES for a list of currently defined attributes. See REF LIST KEYWORDS for a list of currently defined keywords.</source>
          <target state="translated">현재 정의 된 속성 목록은 REF LIST ATTRIBUTES를 참조하십시오. 현재 정의 된 키워드 목록은 REF LIST KEYWORDS를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="ed7577b94e1ee464c75f81cac37b66a6926c7436" translate="yes" xml:space="preserve">
          <source>See also &quot;Repositories&quot; and later subsections in &lt;a href=&quot;gitweb&quot;&gt;gitweb[1]&lt;/a&gt; manpage.</source>
          <target state="translated">&lt;a href=&quot;gitweb&quot;&gt;gitweb [1]&lt;/a&gt; 맨 페이지의 &quot;리포지토리&quot;및 이후 하위 섹션도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="52af4d47e0ed6dc8c81958e8938b6aa167c96389" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#FILES&quot;&gt;FILES&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dcd469ab484a6e7e06726ac525a02976b65d3216" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;#git-quick-start&quot;&gt;Git Quick Reference&lt;/a&gt; for a brief overview of Git commands, without any explanation.</source>
          <target state="translated">설명없이 Git 명령에 대한 간략한 개요 는 &lt;a href=&quot;#git-quick-start&quot;&gt;Git 빠른 참조&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="776296c90f2638f4facdccd84ed267d15501958e" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; for a more user-friendly way to do some of the most common operations on the index.</source>
          <target state="translated">인덱스에서 가장 일반적인 작업을 수행하는보다 사용자 친화적 인 방법 은 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d2d6e7dcb0c9c7bc63cd26813647bc47c39be07" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="07d3f2d4e9abbb86fc4947deaf4abd1a8839b08a" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;https://lore.kernel.org/git/7v64clg5u9.fsf@assigned-by-dhcp.cox.net/&quot;&gt;https://lore.kernel.org/git/7v64clg5u9.fsf@assigned-by-dhcp.cox.net/&lt;/a&gt; and &lt;a href=&quot;https://lore.kernel.org/git/7vy7ej9g38.fsf@gitster.siamese.dyndns.org/&quot;&gt;https://lore.kernel.org/git/7vy7ej9g38.fsf@gitster.siamese.dyndns.org/&lt;/a&gt; for further information.</source>
          <target state="translated">&lt;a href=&quot;https://lore.kernel.org/git/7v64clg5u9.fsf@assigned-by-dhcp.cox.net/&quot;&gt;https://lore.kernel.org/git/7v64clg5u9.fsf@assigned-by-dhcp.cox.net/&lt;/a&gt; 및 &lt;a href=&quot;https://lore.kernel.org/git/7vy7ej9g38.fsf@gitster.siamese.dyndns.org/&quot;&gt;https://lore.kernel.org/git/7vy7ej9g38.fsf@gitster.siamese.dyndns&lt;/a&gt; 도 참조 하십시오. 자세한 내용은 .org / 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1c13efbf0ce0a3c500629d1824fbdc470face67d" translate="yes" xml:space="preserve">
          <source>See also &lt;code&gt;%avatar_size&lt;/code&gt; with pixel sizes for icons and avatars (&quot;default&quot; is used for one-line like &quot;log&quot; and &quot;shortlog&quot;, &quot;double&quot; is used for two-line like &quot;commit&quot;, &quot;commitdiff&quot; or &quot;tag&quot;). If the default font sizes or lineheights are changed (e.g. via adding extra CSS stylesheet in &lt;code&gt;@stylesheets&lt;/code&gt;), it may be appropriate to change these values.</source>
          <target state="translated">아이콘 및 아바타의 픽셀 크기를 가진 &lt;code&gt;%avatar_size&lt;/code&gt; 참조 ( &quot;default&quot;는 &quot;log&quot;및 &quot;shortlog&quot;와 같은 한 줄에 사용되며, &quot;double&quot;은 &quot;commit&quot;, &quot;commitdiff&quot;또는 &quot;tag와 같은 두 줄에 사용됨) &quot;). 기본 글꼴 크기 또는 선 높이가 변경되면 (예 : &lt;code&gt;@stylesheets&lt;/code&gt; 에 CSS 스타일 시트를 추가하여 ) 이러한 값을 변경하는 것이 적절할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef4059c160d59845887bc762e1d3b94b36ac9cb5" translate="yes" xml:space="preserve">
          <source>See also &lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; and the PRUNING section of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;remote.&amp;lt;name&amp;gt;.prune&lt;/code&gt; 및 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 의 PRUNING 섹션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="97a52221a6fcfc08e94858dbbd32d431c7460334" translate="yes" xml:space="preserve">
          <source>See also INCOMPATIBLE OPTIONS below.</source>
          <target state="translated">아래의 호환되지 않는 옵션도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="da70e539ebd47fc0666afc11774bbce890e2d57d" translate="yes" xml:space="preserve">
          <source>See also REBASING MERGES and INCOMPATIBLE OPTIONS below.</source>
          <target state="translated">아래의 거부 거부 및 호환성 옵션도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e1cfc7a6ae7eb249f6af4e953ed0aa13e7a9f32c" translate="yes" xml:space="preserve">
          <source>See also more involved example in &quot;Controlling access to Git repositories&quot; subsection on &lt;a href=&quot;gitweb&quot;&gt;gitweb[1]&lt;/a&gt; manpage.</source>
          <target state="translated">&lt;a href=&quot;gitweb&quot;&gt;gitweb [1]&lt;/a&gt; 맨 페이지의 &quot;Git 리포지토리에 대한 액세스 제어&quot;하위 섹션의 관련 예제도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a90b35f1bca4c9661af072a420272419d14c9fa7" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;howto-index&quot;&gt;howto&lt;/a&gt; documents for some useful examples.</source>
          <target state="translated">유용한 예 는 &lt;a href=&quot;howto-index&quot;&gt;하우투&lt;/a&gt; 문서 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6727f96125b7533ade941bf6b96be91f1faec003" translate="yes" xml:space="preserve">
          <source>See also the &lt;code&gt;--amend&lt;/code&gt; option to &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]에&lt;/a&gt; 대한 &lt;code&gt;--amend&lt;/code&gt; 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d4e5e0e34b4d53289a1425851b494735221ec25" translate="yes" xml:space="preserve">
          <source>See also the &lt;code&gt;--negotiation-tip&lt;/code&gt; option for &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]에&lt;/a&gt; 대한 &lt;code&gt;--negotiation-tip&lt;/code&gt; 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="393dae9d9c5b724b3e92a8007628ecdf490bf229" translate="yes" xml:space="preserve">
          <source>See also the &lt;code&gt;fetch.negotiationAlgorithm&lt;/code&gt; configuration variable documented in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-config&quot;&gt;git-config [1]에&lt;/a&gt; 설명 된 &lt;code&gt;fetch.negotiationAlgorithm&lt;/code&gt; 구성 변수 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b34c3a53a35e7fde45b0dcf380dd07a6f67e09b3" translate="yes" xml:space="preserve">
          <source>See below for a detailed description of the &lt;code&gt;data&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 명령 에 대한 자세한 설명은 아래를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b157460c4f4c3bf67bdbeab995004fb808185e8" translate="yes" xml:space="preserve">
          <source>See the &quot;CONFIGURATION FILE&quot; section of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details on the configuration file. The file is plain text, so you can also edit it with your favorite editor.</source>
          <target state="translated">구성 파일에 대한 자세한 내용 은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 &quot;CONFIGURATION FILE&quot;섹션 을 참조하십시오. 파일은 일반 텍스트이므로 원하는 편집기로 편집 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1149bacaf9085ecc4180307d6ae05e8d61573cee" translate="yes" xml:space="preserve">
          <source>See the &quot;PRETTY FORMATS&quot; section for some additional details for each format. When &lt;code&gt;=&amp;lt;format&amp;gt;&lt;/code&gt; part is omitted, it defaults to &lt;code&gt;medium&lt;/code&gt;.</source>
          <target state="translated">각 형식에 대한 자세한 내용은 &quot;PRETTY FORMATS&quot;섹션을 참조하십시오. 경우 &lt;code&gt;=&amp;lt;format&amp;gt;&lt;/code&gt; 부분에, 디폴트 생략 &lt;code&gt;medium&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16b5734b1a38c0fca2aa75fc8f5afb5e38171b76" translate="yes" xml:space="preserve">
          <source>See the &quot;notes.rewrite.&amp;lt;command&amp;gt;&quot; configuration for a way to carry notes across commands that rewrite commits.</source>
          <target state="translated">커밋을 다시 쓰는 명령에서 메모를 전달하는 방법은 &quot;notes.rewrite. &amp;lt;command&amp;gt;&quot;구성을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="37c9890c0abc7db617d319f8c623b95994d12d01" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; and &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt; manpages for further usage notes.</source>
          <target state="translated">자세한 사용법 은 &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; 및 &lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt; 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="664aa71d1d2c6ad85c41bdce7b1df31a05aeb0c8" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; command to learn how to create and verify tag objects. (Note that &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; can also be used to create &quot;lightweight tags&quot;, which are not tag objects at all, but just simple references whose names begin with &lt;code&gt;refs/tags/&lt;/code&gt;).</source>
          <target state="translated">태그 객체를 생성하고 확인하는 방법 은 &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt; 명령을 참조하십시오 . ( &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt; 은 태그 객체가 아니라 &quot; &lt;code&gt;refs/tags/&lt;/code&gt; 시작하는 단순한 참조 인 &quot;경량 태그&quot;를 만드는 데에도 사용될 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="d438ee28fcc5eac2c57090871716c0835edb3fb6" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;https://git-scm.com/docs/howto/revert-a-faulty-merge&quot;&gt;revert-a-faulty-merge How-To&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://git-scm.com/docs/howto/revert-a-faulty-merge&quot;&gt;결함 복구 병합 사용법&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="36ef80def8fdcd62acbd00beaaea20020f8c5e10" translate="yes" xml:space="preserve">
          <source>See the &lt;code&gt;--pretty&lt;/code&gt; option in the &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; man page for more display options.</source>
          <target state="translated">더 많은 표시 옵션에 대해서는 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 매뉴얼 페이지 에서 &lt;code&gt;--pretty&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4059094394364c65c4e256eefa4143bc85285e53" translate="yes" xml:space="preserve">
          <source>See the &lt;code&gt;--tool=&amp;lt;tool&amp;gt;&lt;/code&gt; option above for more details.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;--tool=&amp;lt;tool&amp;gt;&lt;/code&gt; 의 --tool = &amp;lt;tool&amp;gt; 옵션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cdbbd93582a076d15bd34c470fc66d5137cf3c4d" translate="yes" xml:space="preserve">
          <source>See the &lt;code&gt;--trust-exit-code&lt;/code&gt; option above for more details.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;--trust-exit-code&lt;/code&gt; 의 --trust-exit-code 옵션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b8e91773464e68ddb68c67818ddc930117958012" translate="yes" xml:space="preserve">
          <source>See the &lt;code&gt;gc.auto&lt;/code&gt; option in the &quot;CONFIGURATION&quot; section below for how this heuristic works.</source>
          <target state="translated">이 휴리스틱 작동 방식은 아래 &quot;구성&quot;섹션에서 &lt;code&gt;gc.auto&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3aa11a07b044aa013b3901191823f51922a8ff20" translate="yes" xml:space="preserve">
          <source>See the &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; configuration variable below. When in use, it&amp;rsquo;ll affect how the auto pack limit works.</source>
          <target state="translated">아래의 &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; 구성 변수를 참조하십시오. 사용 중에는 자동 팩 제한 작동 방식에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="3053c5245151cb0daaf5d132e8a14e630a595774" translate="yes" xml:space="preserve">
          <source>See the &lt;code&gt;pathspec&lt;/code&gt; entry in &lt;a href=&quot;gitglossary&quot;&gt;gitglossary[7]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;gitglossary&quot;&gt;gitglossary [7]&lt;/a&gt; 의 &lt;code&gt;pathspec&lt;/code&gt; 항목을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="75fe9e67c24619f5763d970fe2b63e0643ff0b35" translate="yes" xml:space="preserve">
          <source>See the &lt;code&gt;pickaxe&lt;/code&gt; entry in &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore[7]&lt;/a&gt; for more information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore [7]&lt;/a&gt; 의 &lt;code&gt;pickaxe&lt;/code&gt; 항목 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="83948d6384607ede7321a1e18da150f9a73d4146" translate="yes" xml:space="preserve">
          <source>See the CONFIGURATION section for &lt;code&gt;sendemail.multiEdit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sendemail.multiEdit&lt;/code&gt; 에 대해서는 구성 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f7f0c85a1fe22d7a44e2019c11a92087c61176c9" translate="yes" xml:space="preserve">
          <source>See the PRUNING section below for more details.</source>
          <target state="translated">자세한 내용은 아래의 PRUNING 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="642ced677c18bf15d387f97024a58b4d20d0707e" translate="yes" xml:space="preserve">
          <source>See the PRUNING section of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; for what it&amp;rsquo;ll prune depending on various configuration.</source>
          <target state="translated">다양한 구성에 따라 정리되는 내용은 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 의 PRUNING 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b23758c15811b8a84155a82ad559efc97bcaf83" translate="yes" xml:space="preserve">
          <source>See the add subcommand for the definition of default remote.</source>
          <target state="translated">기본 원격 정의에 대해서는 add 부속 명령을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7b02d435af668a3154c5db21e5216702c6ccada1" translate="yes" xml:space="preserve">
          <source>See the documentation for the &lt;code&gt;--depth&lt;/code&gt; option in &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt; 의 &lt;code&gt;--depth&lt;/code&gt; 옵션 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8a5c36fc0819626b74533177ce4ae892455a3785" translate="yes" xml:space="preserve">
          <source>See the documentation for the &lt;code&gt;--window&lt;/code&gt; option in &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt; 의 &lt;code&gt;--window&lt;/code&gt; 옵션 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3fcb475ca761c4788b65bc17cc61cddb7ffeaae1" translate="yes" xml:space="preserve">
          <source>See the explanations of the &lt;code&gt;remote.&amp;lt;name&amp;gt;.url&lt;/code&gt;, &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt;, and &lt;code&gt;remote.&amp;lt;name&amp;gt;.push&lt;/code&gt; options in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 &lt;code&gt;remote.&amp;lt;name&amp;gt;.url&lt;/code&gt; , &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 및 &lt;code&gt;remote.&amp;lt;name&amp;gt;.push&lt;/code&gt; 옵션에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8f33051f0ff2a32371d05cfc9580039d116c83c4" translate="yes" xml:space="preserve">
          <source>See the file gitweb/INSTALL in the Git source tree and &lt;a href=&quot;gitweb&quot;&gt;gitweb[1]&lt;/a&gt; for instructions on details setting up a permanent installation with a CGI or Perl capable server.</source>
          <target state="translated">CGI 또는 Perl 가능 서버를 사용한 영구 설치 설정에 대한 자세한 내용 은 Git 소스 트리의 gitweb / INSTALL 파일과 &lt;a href=&quot;gitweb&quot;&gt;gitweb [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7471ce55c909897f892e3510360e845c3a8c6f7d" translate="yes" xml:space="preserve">
          <source>See the notes on the quarantine environment below.</source>
          <target state="translated">아래의 검역 환경에 대한 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="38b41ff72286b874a0f3db64c92581ef765256ff" translate="yes" xml:space="preserve">
          <source>See the references in the &quot;description&quot; section to get started using Git. The following is probably more detail than necessary for a first-time user.</source>
          <target state="translated">Git 사용을 시작하려면 &quot;설명&quot;섹션의 참조를 참조하십시오. 다음은 처음 사용하는 사용자에게 필요한 것보다 자세한 내용 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="3a308d2b2b8eed03e46d2f6cf143cfa2acb546c2" translate="yes" xml:space="preserve">
          <source>See the section describing &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; above for a discussion of the matching semantics.</source>
          <target state="translated">일치하는 의미에 대한 설명은 위의 &lt;code&gt;&amp;lt;refspec&amp;gt;...&lt;/code&gt; 을 설명하는 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff8a65e5a8b50b2cd32960f644c92d05159f0bd7" translate="yes" xml:space="preserve">
          <source>See the section on &quot;Quarantine Environment&quot; in &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; for some caveats.</source>
          <target state="translated">주의 사항에 대해서는 &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]의&lt;/a&gt; &quot;Quarantine Environment&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f11ef173da292966d44f74e581bfe70f66e03523" translate="yes" xml:space="preserve">
          <source>See what files &lt;code&gt;git submodule&lt;/code&gt; created:</source>
          <target state="translated">&lt;code&gt;git submodule&lt;/code&gt; 생성 한 파일보기 :</target>
        </trans-unit>
        <trans-unit id="9cf656c9a09d4ac0135f6d95a0f9e062689ebbd6" translate="yes" xml:space="preserve">
          <source>Select &quot;Create a new project &amp;rarr; From CVS checkout&quot;</source>
          <target state="translated">&quot;새 프로젝트 생성 &amp;rarr; CVS 체크 아웃&quot;을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="4295d4906e2ecc1e09bb3b7dd2f7bb2e8c0aa11e" translate="yes" xml:space="preserve">
          <source>Select file contents to include in the next commit, then make the commit:</source>
          <target state="translated">다음 커밋에 포함 할 파일 내용을 선택한 다음 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="5458b52d7bc655d716d7b187eb088a80fdb02862" translate="yes" xml:space="preserve">
          <source>Select non-matching lines.</source>
          <target state="translated">일치하지 않는 줄을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="8cb11cd07f748f144ab7c53fba5e088fa9457785" translate="yes" xml:space="preserve">
          <source>Select only files that are Added (&lt;code&gt;A&lt;/code&gt;), Copied (&lt;code&gt;C&lt;/code&gt;), Deleted (&lt;code&gt;D&lt;/code&gt;), Modified (&lt;code&gt;M&lt;/code&gt;), Renamed (&lt;code&gt;R&lt;/code&gt;), have their type (i.e. regular file, symlink, submodule, &amp;hellip;​) changed (&lt;code&gt;T&lt;/code&gt;), are Unmerged (&lt;code&gt;U&lt;/code&gt;), are Unknown (&lt;code&gt;X&lt;/code&gt;), or have had their pairing Broken (&lt;code&gt;B&lt;/code&gt;). Any combination of the filter characters (including none) can be used. When &lt;code&gt;*&lt;/code&gt; (All-or-none) is added to the combination, all paths are selected if there is any file that matches other criteria in the comparison; if there is no file that matches other criteria, nothing is selected.</source>
          <target state="translated">추가 된 파일 ( &lt;code&gt;A&lt;/code&gt; ), 복사 된 파일 ( &lt;code&gt;C&lt;/code&gt; ), 삭제 된 파일 ( &lt;code&gt;D&lt;/code&gt; ), 수정 된 파일 ( &lt;code&gt;M&lt;/code&gt; ), 이름이 변경된 파일 ( &lt;code&gt;R&lt;/code&gt; ) 만 해당 유형 (예 : 일반 파일, symlink, 하위 모듈,&amp;hellip;)이 변경된 파일 ( &lt;code&gt;T&lt;/code&gt; )을 선택하십시오. 병합되지 않음 ( &lt;code&gt;U&lt;/code&gt; ), 알 수 없음 ( &lt;code&gt;X&lt;/code&gt; ) 또는 페어링 이 끊겼 습니다 ( &lt;code&gt;B&lt;/code&gt; ). 필터 문자의 조합 (없음 포함)을 사용할 수 있습니다. 경우 &lt;code&gt;*&lt;/code&gt; 는 (전부 아니면 없음) 조합에 추가되는 모든 경로는 비교 다른 기준에 일치하는 파일이 존재하는 경우 선택되고; 다른 기준과 일치하는 파일이 없으면 아무것도 선택되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d25b5bb0ae1f31c2bf194221afe3b7c5ccd5c79" translate="yes" xml:space="preserve">
          <source>Select the specified commit after loading the graph. Default behavior is equivalent to specifying &lt;code&gt;--select-commit=HEAD&lt;/code&gt;.</source>
          <target state="translated">그래프를로드 한 후 지정된 커밋을 선택하십시오. 기본 동작은 &lt;code&gt;--select-commit=HEAD&lt;/code&gt; 를 지정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="57773e54b07c6d2a3694e83fd05fece4b0d947e7" translate="yes" xml:space="preserve">
          <source>Send a &quot;thin&quot; pack, which records objects in deltified form based on objects not included in the pack to reduce network traffic.</source>
          <target state="translated">네트워크 트래픽을 줄이기 위해 팩에 포함되지 않은 개체를 기반으로 개체를 축소 된 형태로 기록하는 &quot;씬&quot;팩을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="dba975b50e1dab9f5a9242dc7eff168b3f3c3097" translate="yes" xml:space="preserve">
          <source>Send a collection of patches as emails</source>
          <target state="translated">패치 모음을 이메일로 보내기</target>
        </trans-unit>
        <trans-unit id="68bbb0e77605fda568edfbf41010fd23ca67e845" translate="yes" xml:space="preserve">
          <source>Send a collection of patches from stdin to an IMAP folder</source>
          <target state="translated">stdin에서 IMAP 폴더로 패치 모음 보내기</target>
        </trans-unit>
        <trans-unit id="9e60bdff05a0f017374a45f7533dd42ce19f567b" translate="yes" xml:space="preserve">
          <source>Send archive back to git-archive</source>
          <target state="translated">아카이브를 git-archive로 다시 보내기</target>
        </trans-unit>
        <trans-unit id="06c77ce9ef53aee9301f7f13788f25846ac20a8c" translate="yes" xml:space="preserve">
          <source>Send emails even if safety checks would prevent it.</source>
          <target state="translated">안전 점검으로 인해 문제가 발생하더라도 이메일을 보내십시오.</target>
        </trans-unit>
        <trans-unit id="be63d2739b30ca972f203afdf956fffed1109d64" translate="yes" xml:space="preserve">
          <source>Send log messages to the specified destination. Note that this option does not imply --verbose, thus by default only error conditions will be logged. The &amp;lt;destination&amp;gt; must be one of:</source>
          <target state="translated">지정된 대상으로 로그 메시지를 보냅니다. 이 옵션은 --verbose를 의미하지 않으므로 기본적으로 오류 조건 만 기록됩니다. &amp;lt;대상&amp;gt;은 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="251405e1d50dced2d303a34b1887abbae618fd89" translate="yes" xml:space="preserve">
          <source>Send objects packed back to git-fetch-pack</source>
          <target state="translated">git-fetch-pack으로 다시 패킹 된 객체 보내기</target>
        </trans-unit>
        <trans-unit id="30587fd7018a9775c3e41757ae3e2ad3d70bd2fe" translate="yes" xml:space="preserve">
          <source>Send results to standard output instead of overwriting &lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt; 을 덮어 쓰지 않고 표준 출력으로 결과를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="3d06a389aa194b4adb3bdedb6cd48b760831d80a" translate="yes" xml:space="preserve">
          <source>Send the patch to yourself, exactly the way you would, except with To: and Cc: lines that do not contain the list and maintainer address.</source>
          <target state="translated">목록과 관리자 주소가 포함되지 않은 To : 및 Cc : 행을 제외하고는 원하는 방식으로 패치를 자신에게 보내십시오.</target>
        </trans-unit>
        <trans-unit id="ceafde86d6c97e1f3a1eee505d203dadbe2732aa" translate="yes" xml:space="preserve">
          <source>Sending</source>
          <target state="translated">Sending</target>
        </trans-unit>
        <trans-unit id="bbde4ea1647345dcea60ec05d6e174947edc5729" translate="yes" xml:space="preserve">
          <source>Sending &lt;strong&gt;SIGUSR1&lt;/strong&gt; to the &lt;code&gt;git fast-import&lt;/code&gt; process ends the current packfile early, simulating a &lt;code&gt;checkpoint&lt;/code&gt; command. The impatient operator can use this facility to peek at the objects and refs from an import in progress, at the cost of some added running time and worse compression.</source>
          <target state="translated">보내기 &lt;strong&gt;SIGUSR1을&lt;/strong&gt; 받는 &lt;code&gt;git fast-import&lt;/code&gt; 처리하는 것은 시뮬레이션, 초기 현재 packfile을 종료 &lt;code&gt;checkpoint&lt;/code&gt; 명령을 사용합니다. 참을성이없는 운전자는이 기능을 사용하여 실행 시간을 추가하고 압축률을 높이는 대신 진행중인 가져 오기를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69d9f7cb6992812d3ae67c5832e95e51eb94b31e" translate="yes" xml:space="preserve">
          <source>Sends missing objects to remote repository, and updates the remote branch.</source>
          <target state="translated">누락 된 개체를 원격 저장소로 보내고 원격 분기를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="23bbe7eedad5f66236da6f21a05fbf3a6d0c4e2b" translate="yes" xml:space="preserve">
          <source>Separate changes</source>
          <target state="translated">별도 변경</target>
        </trans-unit>
        <trans-unit id="eff8ac5c6bf46b60a389d5ad12d1eb060f7f80df" translate="yes" xml:space="preserve">
          <source>Separate out other information hidden behind NUL bytes (e.g. agent string as a capability and symrefs can be requested using &lt;code&gt;ls-refs&lt;/code&gt;)</source>
          <target state="translated">NUL 바이트 뒤에 숨겨진 다른 정보를 분리하십시오 (예 : 기능으로 에이전트 문자열 및 symref는 &lt;code&gt;ls-refs&lt;/code&gt; 를 사용하여 요청할 수 있음 )</target>
        </trans-unit>
        <trans-unit id="ece352ef8327b4eb0b177147a24a8ec2f1418b4f" translate="yes" xml:space="preserve">
          <source>Separate the commits with NULs instead of with new newlines.</source>
          <target state="translated">줄 바꿈 대신 커밋을 NUL로 구분하십시오.</target>
        </trans-unit>
        <trans-unit id="fbdab030c0f541b63a6720cb36f79b58a8a8ddb3" translate="yes" xml:space="preserve">
          <source>Separates pathspec from options for disambiguation purposes.</source>
          <target state="translated">명확성을 위해 옵션에서 pathspec을 분리합니다.</target>
        </trans-unit>
        <trans-unit id="b8e497aff8340b70a81417c3e01a367bc04c018c" translate="yes" xml:space="preserve">
          <source>Separating argument from the option</source>
          <target state="translated">옵션에서 인수 분리</target>
        </trans-unit>
        <trans-unit id="ad1ff98d9455414907920436d0228d1f33b8b9d5" translate="yes" xml:space="preserve">
          <source>Sequence &quot;%f&quot; on the filter command line is replaced with the name of the file the filter is working on. A filter might use this in keyword substitution. For example:</source>
          <target state="translated">필터 명령 줄의 시퀀스 &quot;% f&quot;는 필터가 작업중인 파일 이름으로 바뀝니다. 필터는 이것을 키워드 대체에 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0eabff0639877f6ba301a816aebe732d4b82d7eb" translate="yes" xml:space="preserve">
          <source>Sequencer subcommands</source>
          <target state="translated">시퀀서 부속 명령</target>
        </trans-unit>
        <trans-unit id="4f86f0b14605788e8e970dd961527f669911f656" translate="yes" xml:space="preserve">
          <source>Server Admin</source>
          <target state="translated">서버 관리자</target>
        </trans-unit>
        <trans-unit id="bf86016aaef42ea05ae67a04c37100e13cf311bf" translate="yes" xml:space="preserve">
          <source>Server side implementation of Git over HTTP</source>
          <target state="translated">HTTP를 통한 Git의 서버 측 구현</target>
        </trans-unit>
        <trans-unit id="448833463540a7335612a7134526ca62a325b6eb" translate="yes" xml:space="preserve">
          <source>Server-side syntax highlight support in &quot;blob&quot; view. It requires &lt;code&gt;$highlight_bin&lt;/code&gt; program to be available (see the description of this variable in the &quot;Configuration variables&quot; section above), and therefore is disabled by default.</source>
          <target state="translated">&quot;블롭&quot;보기에서 서버 측 구문 강조 지원. 그것은 필요 &lt;code&gt;$highlight_bin&lt;/code&gt; 프로그램을 사용할 수 (위의 &quot;구성 변수&quot;절에서이 변수의 설명을 참조), 따라서 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cbd584046863bc7b753e57e8681a98a87f36f0f" translate="yes" xml:space="preserve">
          <source>Services</source>
          <target state="translated">Services</target>
        </trans-unit>
        <trans-unit id="448ab73ba1c21e671e218fb91f2644c834f0c16f" translate="yes" xml:space="preserve">
          <source>Set</source>
          <target state="translated">Set</target>
        </trans-unit>
        <trans-unit id="3c9afc64e385fe9ff937f49ef33cea7eda6d2e43" translate="yes" xml:space="preserve">
          <source>Set &amp;lt;ref&amp;gt; to &amp;lt;newvalue&amp;gt; after verifying &amp;lt;oldvalue&amp;gt;, if given. Specify a zero &amp;lt;newvalue&amp;gt; to ensure the ref does not exist after the update and/or a zero &amp;lt;oldvalue&amp;gt; to make sure the ref does not exist before the update.</source>
          <target state="translated">제공된 경우 &amp;lt;oldvalue&amp;gt;를 확인한 후 &amp;lt;ref&amp;gt;를 &amp;lt;newvalue&amp;gt;로 설정하십시오. 업데이트 후 참조가 존재하지 않도록하려면 &amp;lt;newvalue&amp;gt;를 0으로 지정하고 업데이트 전에 참조가 존재하지 않도록하려면 &amp;lt;oldvalue&amp;gt;를 0으로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="ab50837f4221ee62152d0a56b00aa01e36d1c0b1" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;$maxload&lt;/code&gt; to undefined value (&lt;code&gt;undef&lt;/code&gt;) to turn this feature off. The default value is 300.</source>
          <target state="translated">이 기능을 해제하려면 &lt;code&gt;$maxload&lt;/code&gt; 를 정의되지 않은 값 ( &lt;code&gt;undef&lt;/code&gt; )으로 설정하십시오 . 기본값은 300입니다.</target>
        </trans-unit>
        <trans-unit id="b447103879e346ae5dca39d0e8955736e891677f" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;C'&lt;/code&gt; to &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;C'&lt;/code&gt; 를 &lt;code&gt;C&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c1de92d3e849c9a6ed15961e4d9552291b7de46" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;GIT_REFLOG_ACTION&lt;/code&gt; environment to a given string (typically the name of the program) unless it is already set. Whenever the script runs a &lt;code&gt;git&lt;/code&gt; command that updates refs, a reflog entry is created using the value of this string to leave the record of what command updated the ref.</source>
          <target state="translated">&lt;code&gt;GIT_REFLOG_ACTION&lt;/code&gt; 환경을 설정 하지 않은 경우 주어진 문자열 (일반적으로 프로그램 이름)로 설정하십시오. 스크립트가 refs를 업데이트 하는 &lt;code&gt;git&lt;/code&gt; 명령을 실행할 때 마다이 문자열의 값을 사용하여 reflog 항목이 작성되어 어떤 명령의 레코드가 ref를 업데이트했는지 남겨 둡니다.</target>
        </trans-unit>
        <trans-unit id="38478f04f07d7922d4b7c7c155fa10a2d176d8aa" translate="yes" xml:space="preserve">
          <source>Set a configuration variable in the newly-created repository; this takes effect immediately after the repository is initialized, but before the remote history is fetched or any files checked out. The key is in the same format as expected by &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; (e.g., &lt;code&gt;core.eol=true&lt;/code&gt;). If multiple values are given for the same key, each value will be written to the config file. This makes it safe, for example, to add additional fetch refspecs to the origin remote.</source>
          <target state="translated">새로 작성된 저장소에서 구성 변수를 설정하십시오. 이는 리포지토리가 초기화 된 직후, 원격 기록을 가져 오거나 파일을 체크 아웃하기 전에 적용됩니다. 키는 &lt;a href=&quot;git-config&quot;&gt;git-config [1]에서&lt;/a&gt; 예상 한 것과 같은 형식입니다 (예 : &lt;code&gt;core.eol=true&lt;/code&gt; ). 동일한 키에 여러 값이 제공되면 각 값이 구성 파일에 기록됩니다. 예를 들어, 원거리 리모트에 추가 페치 참조 스펙을 추가하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="467cb3791c7eb0e6e17b468939871379585bf0d6" translate="yes" xml:space="preserve">
          <source>Set a custom directory to store the resulting files instead of the current working directory. All directory components will be created.</source>
          <target state="translated">현재 작업 디렉토리 대신 결과 파일을 저장하도록 사용자 정의 디렉토리를 설정하십시오. 모든 디렉토리 구성 요소가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="d443ac1fac5648ce0c972e61ba93f9dfa28cd774" translate="yes" xml:space="preserve">
          <source>Set a policy to be used by protocol &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; with clone/fetch/push commands. See &lt;code&gt;protocol.allow&lt;/code&gt; above for the available policies.</source>
          <target state="translated">clone / fetch / push 명령과 함께 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 프로토콜에서 사용할 정책을 설정하십시오 . 사용 가능한 정책은 위의 &lt;code&gt;protocol.allow&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ffb09a5018db72662a7a10ef6bf79bb4e8417501" translate="yes" xml:space="preserve">
          <source>Set an alternative CVSROOT to use. This corresponds to the CVS -d parameter. Usually users will not want to set this, except if using CVS in an asymmetric fashion.</source>
          <target state="translated">사용할 대체 CVSROOT를 설정하십시오. 이것은 CVS -d 매개 변수에 해당합니다. 비대칭 방식으로 CVS를 사용하는 경우를 제외하고 사용자는 일반적으로이 설정을 원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb6b278f7896d8837cef70de53516ad86e9dbdad" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;GIT_DIR&lt;/code&gt; environment variable. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;GIT_DIR&lt;/code&gt; 환경 변수를 설정하십시오 . &lt;a href=&quot;git&quot;&gt;git [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca1b08676b4e36a73ebf5696b8b5a7e5e3fbf70c" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;noMetadata&lt;/code&gt; option in the [svn-remote] config. This option is not recommended, please read the &lt;code&gt;svn.noMetadata&lt;/code&gt; section of this manpage before using this option.</source>
          <target state="translated">[svn-remote] 설정에서 &lt;code&gt;noMetadata&lt;/code&gt; 옵션을 설정하십시오. 이 옵션은 권장되지 않습니다 .이 옵션을 사용하기 전에이 맨 페이지 의 &lt;code&gt;svn.noMetadata&lt;/code&gt; 섹션을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="29075e63ef31a9df87f17de44d7d1a90528328cf" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;rewriteRoot&lt;/code&gt; option in the [svn-remote] config.</source>
          <target state="translated">[svn-remote] 설정에서 &lt;code&gt;rewriteRoot&lt;/code&gt; 옵션을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c2f253f2802c51ea11c741dbafd4f8bda616e672" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;rewriteUUID&lt;/code&gt; option in the [svn-remote] config.</source>
          <target state="translated">설정 &lt;code&gt;rewriteUUID&lt;/code&gt; 에서 [SVN-원격] 설정에서 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="b54b27dbc703e4c4c112e37e3cc708e31cfd5c62" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;useSvmProps&lt;/code&gt; option in the [svn-remote] config.</source>
          <target state="translated">설정 &lt;code&gt;useSvmProps&lt;/code&gt; 의 에서 [SVN-원격] 설정에서 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="b1c79663eb36a223e3246a6761c3527b1fcb1cd9" translate="yes" xml:space="preserve">
          <source>Set the &lt;code&gt;useSvnsyncProps&lt;/code&gt; option in the [svn-remote] config.</source>
          <target state="translated">설정 &lt;code&gt;useSvnsyncProps&lt;/code&gt; 의 에서 [SVN-원격] 설정에서 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="96cb52718c720acae8e359f2c3854a795081e029" translate="yes" xml:space="preserve">
          <source>Set the Git namespace. See &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; for more details. Equivalent to setting the &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; environment variable.</source>
          <target state="translated">Git 네임 스페이스를 설정하십시오. 자세한 내용은 &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]&lt;/a&gt; 를 참조하십시오. &lt;code&gt;GIT_NAMESPACE&lt;/code&gt; 환경 변수 를 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7cb0d29338f1ad7db15e18be0474164e1bc21a46" translate="yes" xml:space="preserve">
          <source>Set the Git namespace; see &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; for details. The &lt;code&gt;--namespace&lt;/code&gt; command-line option also sets this value.</source>
          <target state="translated">Git 네임 스페이스를 설정하십시오. 자세한 내용은 &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]&lt;/a&gt; 를 참조하십시오. &lt;code&gt;--namespace&lt;/code&gt; 명령 줄 옵션은이 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ce505bfde263ccf76db605c3871e55681201849e" translate="yes" xml:space="preserve">
          <source>Set the commit message to be used for the merge commit (in case one is created).</source>
          <target state="translated">병합 커밋에 사용될 커밋 메시지를 설정합니다 (하나가 생성 된 경우).</target>
        </trans-unit>
        <trans-unit id="60dd95cbd8809da88fe2e4f3deab8c8cfda23f9c" translate="yes" xml:space="preserve">
          <source>Set the creation/deletion cost fudge factor to &lt;code&gt;&amp;lt;percent&amp;gt;&lt;/code&gt;. Defaults to 60. Try a larger value if &lt;code&gt;git range-diff&lt;/code&gt; erroneously considers a large change a total rewrite (deletion of one commit and addition of another), and a smaller one in the reverse case. See the ``Algorithm`` section below for an explanation why this is needed.</source>
          <target state="translated">작성 / 삭제 비용 퍼지 계수를 &lt;code&gt;&amp;lt;percent&amp;gt;&lt;/code&gt; 로 설정하십시오 . &lt;code&gt;git range-diff&lt;/code&gt; 가 전체 다시 쓰기 (한 커밋 및 다른 커밋 삭제 및 다른 커밋 삭제)를 크게 변경 한 것으로 간주 하면 더 큰 값을 시도 하고 반대의 경우 더 작은 값을 시도하십시오 . 이것이 필요한 이유에 대한 설명은 아래의``알고리즘 ''섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e4867b6a9e4fdc121bda203b5824a86f390dc42c" translate="yes" xml:space="preserve">
          <source>Set the default date-time mode for the &lt;code&gt;log&lt;/code&gt; command. Setting a value for log.date is similar to using &lt;code&gt;git log&lt;/code&gt;'s &lt;code&gt;--date&lt;/code&gt; option. See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;log&lt;/code&gt; 명령 의 기본 날짜-시간 모드를 설정하십시오 . log.date의 값을 설정하는 것은 &lt;code&gt;git log&lt;/code&gt; 의 &lt;code&gt;--date&lt;/code&gt; 옵션 을 사용하는 것과 유사합니다 . 자세한 내용은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="452331e44dbf8a551529f8aab3eb063db65f0f80" translate="yes" xml:space="preserve">
          <source>Set the default matching behavior. Using a value of &lt;code&gt;basic&lt;/code&gt;, &lt;code&gt;extended&lt;/code&gt;, &lt;code&gt;fixed&lt;/code&gt;, or &lt;code&gt;perl&lt;/code&gt; will enable the &lt;code&gt;--basic-regexp&lt;/code&gt;, &lt;code&gt;--extended-regexp&lt;/code&gt;, &lt;code&gt;--fixed-strings&lt;/code&gt;, or &lt;code&gt;--perl-regexp&lt;/code&gt; option accordingly, while the value &lt;code&gt;default&lt;/code&gt; will return to the default matching behavior.</source>
          <target state="translated">기본 일치 동작을 설정하십시오. 의 값을 사용하여 &lt;code&gt;basic&lt;/code&gt; , &lt;code&gt;extended&lt;/code&gt; , &lt;code&gt;fixed&lt;/code&gt; , 또는 &lt;code&gt;perl&lt;/code&gt; 활성화 할 것 &lt;code&gt;--basic-regexp&lt;/code&gt; , &lt;code&gt;--extended-regexp&lt;/code&gt; , &lt;code&gt;--fixed-strings&lt;/code&gt; , 또는 &lt;code&gt;--perl-regexp&lt;/code&gt; 값하면서, 그에 따라 옵션을 &lt;code&gt;default&lt;/code&gt; 받는 돌아갑니다 기본 일치 동작.</target>
        </trans-unit>
        <trans-unit id="0fa4faa1629ef6ce85f03023fc833f41e1dcd3a2" translate="yes" xml:space="preserve">
          <source>Set the execute permissions on the updated files.</source>
          <target state="translated">업데이트 된 파일에 대한 실행 권한을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8fcbe8639628c30552376de3870da0a1897ef81f" translate="yes" xml:space="preserve">
          <source>Set the length object names are abbreviated to. If unspecified or set to &quot;auto&quot;, an appropriate value is computed based on the approximate number of packed objects in your repository, which hopefully is enough for abbreviated object names to stay unique for some time. The minimum length is 4.</source>
          <target state="translated">길이 오브젝트 이름을 약자로 설정하십시오. 지정하지 않거나 &quot;auto&quot;로 설정하면 저장소에있는 대략적인 묶음 객체 수를 기반으로 적절한 값이 계산되는데, 이는 축약 된 객체 이름이 한동안 고유하게 유지되기에 충분합니다. 최소 길이는 4입니다.</target>
        </trans-unit>
        <trans-unit id="1c984f4d67f4b1c5f797e0985cdc839cd8173298" translate="yes" xml:space="preserve">
          <source>Set the method with which to authenticate against the HTTP proxy. This only takes effect if the configured proxy string contains a user name part (i.e. is of the form &lt;code&gt;user@host&lt;/code&gt; or &lt;code&gt;user@host:port&lt;/code&gt;). This can be overridden on a per-remote basis; see &lt;code&gt;remote.&amp;lt;name&amp;gt;.proxyAuthMethod&lt;/code&gt;. Both can be overridden by the &lt;code&gt;GIT_HTTP_PROXY_AUTHMETHOD&lt;/code&gt; environment variable. Possible values are:</source>
          <target state="translated">HTTP 프록시에 대해 인증 할 방법을 설정하십시오. 구성된 프록시 문자열에 사용자 이름 부분이 포함 된 경우 (예 : &lt;code&gt;user@host&lt;/code&gt; 또는 &lt;code&gt;user@host:port&lt;/code&gt; ) 에만 적용됩니다 . 원격으로이를 무시할 수 있습니다. &lt;code&gt;remote.&amp;lt;name&amp;gt;.proxyAuthMethod&lt;/code&gt; 를 참조하십시오 . 둘 다 &lt;code&gt;GIT_HTTP_PROXY_AUTHMETHOD&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4531ba21b83c7504310183413d920d4e527a579c" translate="yes" xml:space="preserve">
          <source>Set the name of placeholder files created by --preserve-empty-dirs. Default: &quot;.gitignore&quot;</source>
          <target state="translated">--preserve-empty-dirs로 작성된 자리 표시 자 파일의 이름을 설정하십시오. 기본값 : &quot;.gitignore&quot;</target>
        </trans-unit>
        <trans-unit id="9f6240dcaa583bb3021b3aca773ea9ba6bc9afa0" translate="yes" xml:space="preserve">
          <source>Set the path to the repository (&quot;.git&quot; directory). This can also be controlled by setting the &lt;code&gt;GIT_DIR&lt;/code&gt; environment variable. It can be an absolute path or relative path to current working directory.</source>
          <target state="translated">저장소 ( &quot;.git&quot;디렉토리)의 경로를 설정합니다. &lt;code&gt;GIT_DIR&lt;/code&gt; 환경 변수를 설정하여 제어 할 수도 있습니다 . 현재 작업 디렉토리에 대한 절대 경로 또는 상대 경로 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31570b84b8684acde4e9da43dbd6e7e3871cdd6e" translate="yes" xml:space="preserve">
          <source>Set the path to the repository. This can also be controlled by setting the &lt;code&gt;GIT_DIR&lt;/code&gt; environment variable. It can be an absolute path or relative path to current working directory.</source>
          <target state="translated">저장소 경로를 설정하십시오. &lt;code&gt;GIT_DIR&lt;/code&gt; 환경 변수를 설정하여 제어 할 수도 있습니다 . 현재 작업 디렉토리에 대한 절대 경로 또는 상대 경로 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="400ea02361b1fdf84359f8c82c5dbc03e0cfd801" translate="yes" xml:space="preserve">
          <source>Set the path to the root of the working tree. If &lt;code&gt;GIT_COMMON_DIR&lt;/code&gt; environment variable is set, core.worktree is ignored and not used for determining the root of working tree. This can be overridden by the &lt;code&gt;GIT_WORK_TREE&lt;/code&gt; environment variable and the &lt;code&gt;--work-tree&lt;/code&gt; command-line option. The value can be an absolute path or relative to the path to the .git directory, which is either specified by --git-dir or GIT_DIR, or automatically discovered. If --git-dir or GIT_DIR is specified but none of --work-tree, GIT_WORK_TREE and core.worktree is specified, the current working directory is regarded as the top level of your working tree.</source>
          <target state="translated">작업 트리의 루트 경로를 설정하십시오. 경우 &lt;code&gt;GIT_COMMON_DIR&lt;/code&gt; 의 환경 변수가 설정되어, core.worktree은 무시하고 나무를 작업의 루트를 결정하기 위해 사용되지 않습니다. 이것은 &lt;code&gt;GIT_WORK_TREE&lt;/code&gt; 환경 변수와 &lt;code&gt;--work-tree&lt;/code&gt; 명령 줄 옵션 으로 재정의 할 수 있습니다 . 이 값은 --git-dir 또는 GIT_DIR에 의해 지정되거나 자동으로 검색되는 .git 디렉토리의 경로에 대한 절대 경로이거나 상대 경로 일 수 있습니다. --git-dir 또는 GIT_DIR이 지정되었지만 --work-tree, GIT_WORK_TREE 및 core.worktree가 지정되지 않은 경우 현재 작업 디렉토리는 작업 트리의 최상위 레벨로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="e77cf9dbfa8bb073ac521b0115fcf267d700de96" translate="yes" xml:space="preserve">
          <source>Set the path to the root of the working tree. This can also be controlled by the &lt;code&gt;--work-tree&lt;/code&gt; command-line option and the core.worktree configuration variable.</source>
          <target state="translated">작업 트리의 루트 경로를 설정하십시오. &lt;code&gt;--work-tree&lt;/code&gt; 명령 줄 옵션과 core.worktree 구성 변수 로 제어 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d76dd27e6c2a8b0058c2a945baf951d7f68aa28" translate="yes" xml:space="preserve">
          <source>Set the path to the working tree. It can be an absolute path or a path relative to the current working directory. This can also be controlled by setting the GIT_WORK_TREE environment variable and the core.worktree configuration variable (see core.worktree in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for a more detailed discussion).</source>
          <target state="translated">작업 트리의 경로를 설정하십시오. 절대 경로이거나 현재 작업 디렉토리에 상대적인 경로 일 수 있습니다. 이는 GIT_WORK_TREE 환경 변수와 core.worktree 구성 변수를 설정하여 제어 할 수도 있습니다 (자세한 설명은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]의&lt;/a&gt; core.worktree 참조 ).</target>
        </trans-unit>
        <trans-unit id="ed921cb30a3554abcb258c374cc8879de4b6e735" translate="yes" xml:space="preserve">
          <source>Set the starting point at which to create the new commits to the merge base of &amp;lt;upstream&amp;gt; &amp;lt;branch&amp;gt;. Running &lt;code&gt;git rebase --keep-base &amp;lt;upstream&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt; is equivalent to running &lt;code&gt;git rebase --onto &amp;lt;upstream&amp;gt;&amp;hellip;​ &amp;lt;upstream&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">새 커밋을 생성 할 시작 지점을 &amp;lt;upstream&amp;gt; &amp;lt;branch&amp;gt;의 병합 기반으로 설정하십시오. 실행 &lt;code&gt;git rebase --keep-base &amp;lt;upstream&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt; 실행하는 것과 같습니다 &lt;code&gt;git rebase --onto &amp;lt;upstream&amp;gt;&amp;hellip;​ &amp;lt;upstream&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6b13ff409b582dcf430b9ece41f38914d244e47" translate="yes" xml:space="preserve">
          <source>Set this option to &lt;code&gt;false&lt;/code&gt; to disable the default heuristics that shift diff hunk boundaries to make patches easier to read.</source>
          <target state="translated">패치를보다 쉽게 ​​읽을 수 있도록 diff hunk 경계를 이동하는 기본 휴리스틱을 사용하지 않으려면 이 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="006b55776506e3606ed55b1bbce55137d0106c81" translate="yes" xml:space="preserve">
          <source>Set this option to true to make the diff driver cache the text conversion outputs. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">diff 드라이버가 텍스트 변환 출력을 캐시하게하려면이 옵션을 true로 설정하십시오. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ef5fd1abf8d8364854389e921b837341fb77c76d" translate="yes" xml:space="preserve">
          <source>Set this option to true to make the diff driver treat files as binary. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">diff 드라이버가 파일을 이진 파일로 취급하도록하려면이 옵션을 true로 설정하십시오. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ef3e5c6a12efe8e7150b1e7869bbdde3d0dce7a8" translate="yes" xml:space="preserve">
          <source>Set this variable to &lt;code&gt;false&lt;/code&gt; if you want to disable &lt;code&gt;pushNonFFCurrent&lt;/code&gt;, &lt;code&gt;pushNonFFMatching&lt;/code&gt;, &lt;code&gt;pushAlreadyExists&lt;/code&gt;, &lt;code&gt;pushFetchFirst&lt;/code&gt;, and &lt;code&gt;pushNeedsForce&lt;/code&gt; simultaneously.</source>
          <target state="translated">&lt;code&gt;pushNonFFCurrent&lt;/code&gt; , &lt;code&gt;pushNonFFMatching&lt;/code&gt; , &lt;code&gt;pushAlreadyExists&lt;/code&gt; , &lt;code&gt;pushFetchFirst&lt;/code&gt; 및 &lt;code&gt;pushNeedsForce&lt;/code&gt; 를 동시에 비활성화하려면 이 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="3942f1a8d8fbbbd45defb8fdf1e1532d95e95175" translate="yes" xml:space="preserve">
          <source>Set to 0 to prevent protocols used by fetch/push/clone which are configured to the &lt;code&gt;user&lt;/code&gt; state. This is useful to restrict recursive submodule initialization from an untrusted repository or for programs which feed potentially-untrusted URLS to git commands. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;user&lt;/code&gt; 상태 로 구성된 페치 / 푸시 / 복제에 사용되는 프로토콜을 방지하려면 0으로 설정하십시오 . 이는 신뢰할 수없는 저장소에서 재귀 서브 모듈 초기화를 제한하거나 잠재적으로 신뢰할 수없는 URL을 git 명령에 제공하는 프로그램에 유용합니다. 자세한 내용은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b65b88faf09ed3e78aacba5ecd3c0b74f296551e" translate="yes" xml:space="preserve">
          <source>Set to &lt;code&gt;change&lt;/code&gt; if you want changes in whitespace to be ignored by default. Set to one of: no, none, never, false if you want changes in whitespace to be significant.</source>
          <target state="translated">공백의 변경 사항을 기본적으로 무시 하려면 &lt;code&gt;change&lt;/code&gt; 하도록 설정하십시오 . 공백의 변경 사항을 중요하게하려면 no, none, never, false 중 하나로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="5365106003c727ad2992b276959d7e28e3f5d488" translate="yes" xml:space="preserve">
          <source>Set to &lt;code&gt;false&lt;/code&gt; to use the legacy shell script implementation of &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;. Is &lt;code&gt;true&lt;/code&gt; by default, which means use the built-in rewrite of it in C.</source>
          <target state="translated">&lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; 의 레거시 쉘 스크립트 구현을 사용하려면 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 . 가 &lt;code&gt;true&lt;/code&gt; 수단이 사용하는 기본적으로 내장에의 재 작성 C.에</target>
        </trans-unit>
        <trans-unit id="55c516b6a3b5abf93c689c87b62d882f67783e93" translate="yes" xml:space="preserve">
          <source>Set to a value</source>
          <target state="translated">값으로 설정</target>
        </trans-unit>
        <trans-unit id="126c88db7f15369f3dbc6085e635b28af0c85793" translate="yes" xml:space="preserve">
          <source>Set to false to enable &lt;code&gt;--no-show-forced-updates&lt;/code&gt; in &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; and &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; commands. Defaults to true.</source>
          <target state="translated">&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 및 &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt; 명령 에서 &lt;code&gt;--no-show-forced-updates&lt;/code&gt; 를 활성화하려면 false로 설정하십시오 . 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="361b59fb11064babad5acb39754e365b2c18e181" translate="yes" xml:space="preserve">
          <source>Set to long name (git-upload-pack, etc&amp;hellip;​) of service helper needs to invoke.</source>
          <target state="translated">서비스 헬퍼의 긴 이름 (git-upload-pack 등)을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="4bc0f158fa5fccd4891458dbb2fe87fd0c2639c2" translate="yes" xml:space="preserve">
          <source>Set to long name (upload-pack, etc&amp;hellip;​) of service helper needs to invoke.</source>
          <target state="translated">서비스 도우미의 긴 이름 (업로드 팩 등)으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e57cc917cd5904e6e25fccb477e015eebd2cea7f" translate="yes" xml:space="preserve">
          <source>Set to string value &quot;auto&quot;</source>
          <target state="translated">문자열 값 &quot;auto&quot;로 설정</target>
        </trans-unit>
        <trans-unit id="f9270f5e7d6f6a107dd8727f8e03989aa7e1e07f" translate="yes" xml:space="preserve">
          <source>Set to string value &quot;crlf&quot;</source>
          <target state="translated">문자열 값 &quot;crlf&quot;로 설정</target>
        </trans-unit>
        <trans-unit id="a22b46e67f1294009226c3e99f53a466328184f5" translate="yes" xml:space="preserve">
          <source>Set to string value &quot;lf&quot;</source>
          <target state="translated">문자열 값 &quot;lf&quot;로 설정</target>
        </trans-unit>
        <trans-unit id="7f3636e90ee07f52b1799adf7d20919a4160ef67" translate="yes" xml:space="preserve">
          <source>Set to true to enable --branch by default in &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt;. The option --no-branch takes precedence over this variable.</source>
          <target state="translated">&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 에서 기본적으로 --branch를 활성화하려면 true로 설정하십시오 . --no-branch 옵션이이 변수보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="01828a4204064cca5b2e88b220546dc5742bc0f1" translate="yes" xml:space="preserve">
          <source>Set to true to enable --short by default in &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt;. The option --no-short takes precedence over this variable.</source>
          <target state="translated">&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 에서 기본적으로 --short를 활성화하려면 true로 설정하십시오 . --no-short 옵션이이 변수보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="a2f50541fbb43557b6973a5064eb81647dcf94e2" translate="yes" xml:space="preserve">
          <source>Set to true to enable &lt;code&gt;--ahead-behind&lt;/code&gt; and false to enable &lt;code&gt;--no-ahead-behind&lt;/code&gt; by default in &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; for non-porcelain status formats. Defaults to true.</source>
          <target state="translated">비 도자기 상태 형식의 경우 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 에서 기본적으로 &lt;code&gt;--ahead-behind&lt;/code&gt; 를 활성화하려면 true로 설정 하고 &lt;code&gt;--no-ahead-behind&lt;/code&gt; 를 활성화하려면 false로 설정하십시오 . 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="96f0b77e868eff9d4ad63451b6702c714a9e3c67" translate="yes" xml:space="preserve">
          <source>Set to true to write a commit-graph after every &lt;code&gt;git fetch&lt;/code&gt; command that downloads a pack-file from a remote. Using the &lt;code&gt;--split&lt;/code&gt; option, most executions will create a very small commit-graph file on top of the existing commit-graph file(s). Occasionally, these files will merge and the write may take longer. Having an updated commit-graph file helps performance of many Git commands, including &lt;code&gt;git merge-base&lt;/code&gt;, &lt;code&gt;git push -f&lt;/code&gt;, and &lt;code&gt;git log --graph&lt;/code&gt;. Defaults to false, unless &lt;code&gt;feature.experimental&lt;/code&gt; is true.</source>
          <target state="translated">팩 파일을 원격에서 다운로드하는 모든 &lt;code&gt;git fetch&lt;/code&gt; 명령 후에 commit-graph를 쓰려면 true로 설정하십시오 . &lt;code&gt;--split&lt;/code&gt; 옵션을 사용하면 대부분의 실행에서 기존 커밋 그래프 파일 위에 매우 작은 커밋 그래프 파일이 생성됩니다. 간혹 이러한 파일이 병합되어 쓰기가 더 오래 걸릴 수 있습니다. 커밋 그래프 파일을 업데이트하면 &lt;code&gt;git merge-base&lt;/code&gt; , &lt;code&gt;git push -f&lt;/code&gt; 및 &lt;code&gt;git log --graph&lt;/code&gt; 를 포함한 많은 Git 명령의 성능을 향상 시킬 수 있습니다. &lt;code&gt;feature.experimental&lt;/code&gt; 이 true가 아닌 경우 기본값은 false 입니다.</target>
        </trans-unit>
        <trans-unit id="8209e9f5d9f75f909ebb340ce07c0375e1a57b1b" translate="yes" xml:space="preserve">
          <source>Set to true to write a commit-graph after every &lt;code&gt;git fetch&lt;/code&gt; command that downloads a pack-file from a remote. Using the &lt;code&gt;--split&lt;/code&gt; option, most executions will create a very small commit-graph file on top of the existing commit-graph file(s). Occasionally, these files will merge and the write may take longer. Having an updated commit-graph file helps performance of many Git commands, including &lt;code&gt;git merge-base&lt;/code&gt;, &lt;code&gt;git push -f&lt;/code&gt;, and &lt;code&gt;git log --graph&lt;/code&gt;. Defaults to false.</source>
          <target state="translated">원격에서 팩 파일을 다운로드하는 모든 &lt;code&gt;git fetch&lt;/code&gt; 명령 후에 커밋 그래프를 작성하려면 true로 설정합니다 . &lt;code&gt;--split&lt;/code&gt; 옵션을 사용하면 대부분의 실행은 기존 커밋 그래프 파일 위에 매우 작은 커밋 그래프 파일을 만듭니다. 간혹 이러한 파일이 병합되어 쓰기가 더 오래 걸릴 수 있습니다. 업데이트 된 커밋 그래프 파일이 있으면 &lt;code&gt;git merge-base&lt;/code&gt; , &lt;code&gt;git push -f&lt;/code&gt; , &lt;code&gt;git log --graph&lt;/code&gt; 를 포함한 많은 Git 명령의 성능에 도움이됩니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="6596cd35135fea85976308a2f017fa88ea4c3f97" translate="yes" xml:space="preserve">
          <source>Set up &amp;lt;branchname&amp;gt;'s tracking information so &amp;lt;upstream&amp;gt; is considered &amp;lt;branchname&amp;gt;'s upstream branch. If no &amp;lt;branchname&amp;gt; is specified, then it defaults to the current branch.</source>
          <target state="translated">&amp;lt;branchname&amp;gt;의 추적 정보를 설정하여 &amp;lt;upstream&amp;gt;이 &amp;lt;branchname&amp;gt;의 업스트림 분기로 간주되도록하십시오. &amp;lt;branchname&amp;gt;이 지정되지 않은 경우 기본값은 현재 분기입니다.</target>
        </trans-unit>
        <trans-unit id="a7d9f42de7103c698b8b04159cb04db5a6d63650" translate="yes" xml:space="preserve">
          <source>Set up a mirror of the source repository. This implies &lt;code&gt;--bare&lt;/code&gt;. Compared to &lt;code&gt;--bare&lt;/code&gt;, &lt;code&gt;--mirror&lt;/code&gt; not only maps local branches of the source to local branches of the target, it maps all refs (including remote-tracking branches, notes etc.) and sets up a refspec configuration such that all these refs are overwritten by a &lt;code&gt;git remote update&lt;/code&gt; in the target repository.</source>
          <target state="translated">소스 저장소의 미러를 설정하십시오. 이것은 &lt;code&gt;--bare&lt;/code&gt; 를 의미 합니다 . 비교하기 &lt;code&gt;--bare&lt;/code&gt; , &lt;code&gt;--mirror&lt;/code&gt; 뿐만 아니라 대상의 로컬 브랜치에 대한 소스의 로컬 브랜치 매핑 그것은 refspec 구성까지 이러한 모든 (분기 원격 추적 등 포함 노트) 심판 및 집합을 매핑이 심판은 모든 대상 리포지토리 의 &lt;code&gt;git remote update&lt;/code&gt; 로 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="7e96219d093661439598475221c87d2588db74a2" translate="yes" xml:space="preserve">
          <source>Sets default options for merging into branch &amp;lt;name&amp;gt;. The syntax and supported options are the same as those of &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;, but option values containing whitespace characters are currently not supported.</source>
          <target state="translated">분기 &amp;lt;name&amp;gt;에 병합하기위한 기본 옵션을 설정합니다. 구문 및 지원되는 옵션은 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt; 의 구문과 동일 하지만 공백 문자를 포함하는 옵션 값은 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae1bdc4ada17600e4b52aa414b8e4fd8124c824c" translate="yes" xml:space="preserve">
          <source>Sets default options for merging into branch &amp;lt;name&amp;gt;. The syntax and supported options are the same as those of &lt;code&gt;git merge&lt;/code&gt;, but option values containing whitespace characters are currently not supported.</source>
          <target state="translated">분기 &amp;lt;name&amp;gt;에 병합하기위한 기본 옵션을 설정합니다. 구문 및 지원되는 옵션은 &lt;code&gt;git merge&lt;/code&gt; 의 구문과 동일 하지만 공백 문자를 포함하는 옵션 값은 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d284647c4bbe7eed170d8bbd06667eb66997a29f" translate="yes" xml:space="preserve">
          <source>Sets location of common system-wide configuration file.</source>
          <target state="translated">공통 시스템 전체 구성 파일의 위치를 ​​설정합니다.</target>
        </trans-unit>
        <trans-unit id="b2395ce7c9c6f7832c2a162201b3e7779e8713ae" translate="yes" xml:space="preserve">
          <source>Sets location of fallback system-wide configuration file. This file is read only if per-instance one does not exist.</source>
          <target state="translated">대체 시스템 전체 구성 파일의 위치를 ​​설정합니다. 이 파일은 인스턴스 별 파일이없는 경우에만 읽습니다.</target>
        </trans-unit>
        <trans-unit id="80c7084a9261d496ded6a154cb1d21190935c2fb" translate="yes" xml:space="preserve">
          <source>Sets location of per-instance configuration file.</source>
          <target state="translated">인스턴스 별 구성 파일의 위치를 ​​설정합니다.</target>
        </trans-unit>
        <trans-unit id="e0e9d645e60e4880815c1beb8a485ff180b9df6b" translate="yes" xml:space="preserve">
          <source>Sets or deletes the default branch (i.e. the target of the symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt;) for the named remote. Having a default branch for a remote is not required, but allows the name of the remote to be specified in lieu of a specific branch. For example, if the default branch for &lt;code&gt;origin&lt;/code&gt; is set to &lt;code&gt;master&lt;/code&gt;, then &lt;code&gt;origin&lt;/code&gt; may be specified wherever you would normally specify &lt;code&gt;origin/master&lt;/code&gt;.</source>
          <target state="translated">명명 된 리모트 의 디폴트 브랜치 (즉, symbolic-ref &lt;code&gt;refs/remotes/&amp;lt;name&amp;gt;/HEAD&lt;/code&gt; 의 타겟)를 설정 또는 삭제합니다 . 리모트에 대한 기본 분기가 필요하지는 않지만 특정 분기 대신 리모트의 이름을 지정할 수 있습니다. 에 대한 기본 분기 예를 들어, &lt;code&gt;origin&lt;/code&gt; 으로 설정되어 &lt;code&gt;master&lt;/code&gt; , 다음 &lt;code&gt;origin&lt;/code&gt; 당신이 일반적으로 지정합니다 곳을 지정할 수 있습니다 &lt;code&gt;origin/master&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2e044e154b8bedcebccbb47c9cffea4e43f05f2" translate="yes" xml:space="preserve">
          <source>Sets service path (--upload-pack, --receive-pack etc.) for next connect. Remote helper may support this option, but must not rely on this option being set before connect request occurs.</source>
          <target state="translated">다음 연결을위한 서비스 경로 (--upload-pack, --receive-pack 등)를 설정합니다. 원격 도우미는이 옵션을 지원할 수 있지만 연결 요청이 발생하기 전에이 옵션이 설정되어 있지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="4daf5e09ce23fccb50e846fa35fe9d7420d00620" translate="yes" xml:space="preserve">
          <source>Sets the Subversion property given as the first argument, to the value given as the second argument for the file given as the third argument.</source>
          <target state="translated">첫 번째 인수로 지정된 Subversion 속성을 세 번째 인수로 지정된 파일의 두 번째 인수로 제공된 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7bdcb303e2640fa11b5be793f726d7f4d39f5dcd" translate="yes" xml:space="preserve">
          <source>Sets the URL of the specified submodule to &amp;lt;newurl&amp;gt;. Then, it will automatically synchronize the submodule&amp;rsquo;s new remote URL configuration.</source>
          <target state="translated">지정된 서브 모듈의 URL을 &amp;lt;newurl&amp;gt;로 설정합니다. 그런 다음 서브 모듈의 새로운 원격 URL 구성을 자동으로 동기화합니다.</target>
        </trans-unit>
        <trans-unit id="81149e7775b257084aed4c2f69389cf77384d49e" translate="yes" xml:space="preserve">
          <source>Sets the default for whether to confirm before sending. Must be one of &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;, &lt;code&gt;cc&lt;/code&gt;, &lt;code&gt;compose&lt;/code&gt;, or &lt;code&gt;auto&lt;/code&gt;. See &lt;code&gt;--confirm&lt;/code&gt; in the previous section for the meaning of these values.</source>
          <target state="translated">보내기 전에 확인 여부에 대한 기본값을 설정합니다. &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;never&lt;/code&gt; , &lt;code&gt;cc&lt;/code&gt; , &lt;code&gt;compose&lt;/code&gt; 또는 &lt;code&gt;auto&lt;/code&gt; 중 하나 여야합니다 . 이 값의 의미에 대해서는 이전 섹션의 &lt;code&gt;--confirm&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae96977bcaf8246e51bbdd562c9442e5f847dd67" translate="yes" xml:space="preserve">
          <source>Sets the default remote tracking branch for the submodule. The &lt;code&gt;--branch&lt;/code&gt; option allows the remote branch to be specified. The &lt;code&gt;--default&lt;/code&gt; option removes the submodule.&amp;lt;name&amp;gt;.branch configuration key, which causes the tracking branch to default to &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">하위 모듈의 기본 원격 추적 분기를 설정합니다. &lt;code&gt;--branch&lt;/code&gt; 옵션은 원격 지사가 지정할 수 있습니다. &lt;code&gt;--default&lt;/code&gt; 옵션은 서브 모듈. &amp;lt;이름&amp;gt; .branch 구성 키, 기본적으로 추적 가지 원인이 제거 &lt;code&gt;master&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdd403722db4f3bcc819e0b7e2bed5d2da744942" translate="yes" xml:space="preserve">
          <source>Sets the default remote tracking branch for the submodule. The &lt;code&gt;--branch&lt;/code&gt; option allows the remote branch to be specified. The &lt;code&gt;--default&lt;/code&gt; option removes the submodule.&amp;lt;name&amp;gt;.branch configuration key, which causes the tracking branch to default to the remote &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">하위 모듈에 대한 기본 원격 추적 분기를 설정합니다. &lt;code&gt;--branch&lt;/code&gt; 옵션은 원격 지사가 지정할 수 있습니다. &lt;code&gt;--default&lt;/code&gt; 옵션은 서브 모듈. &amp;lt;이름&amp;gt; .branch 구성 키, 원격 기본적으로 추적 가지 원인이 제거 &lt;code&gt;HEAD&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="0ebd0697d4e9cc9507469a589b214100fff93c18" translate="yes" xml:space="preserve">
          <source>Sets the default value of --ignore-submodules. Note that this affects only &lt;code&gt;git diff&lt;/code&gt; Porcelain, and not lower level &lt;code&gt;diff&lt;/code&gt; commands such as &lt;code&gt;git diff-files&lt;/code&gt;. &lt;code&gt;git checkout&lt;/code&gt; and &lt;code&gt;git switch&lt;/code&gt; also honor this setting when reporting uncommitted changes. Setting it to &lt;code&gt;all&lt;/code&gt; disables the submodule summary normally shown by &lt;code&gt;git commit&lt;/code&gt; and &lt;code&gt;git status&lt;/code&gt; when &lt;code&gt;status.submoduleSummary&lt;/code&gt; is set unless it is overridden by using the --ignore-submodules command-line option. The &lt;code&gt;git submodule&lt;/code&gt; commands are not affected by this setting.</source>
          <target state="translated">--ignore-submodules의 기본값을 설정합니다. 이것은 &lt;code&gt;git diff&lt;/code&gt; Porcelain 에만 영향을 미치며 &lt;code&gt;git diff-files&lt;/code&gt; 와 같은 하위 수준 &lt;code&gt;diff&lt;/code&gt; 명령 에는 영향을 미치지 않습니다 . 커밋되지 않은 변경 사항을보고 할 때 &lt;code&gt;git checkout&lt;/code&gt; 및 &lt;code&gt;git switch&lt;/code&gt; 도이 설정을 따릅니다. &lt;code&gt;all&lt;/code&gt; 로 설정 하면 &lt;code&gt;status.submoduleSummary&lt;/code&gt; 가 --ignore-submodules 명령 줄 옵션을 사용하여 재정의되지 않는 한 &lt;code&gt;git commit&lt;/code&gt; 및 &lt;code&gt;git status&lt;/code&gt; 로 일반적으로 표시되는 하위 모듈 요약이 비활성화 됩니다 . &lt;code&gt;git submodule&lt;/code&gt; 명령이 설정의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="223bc7be9fc4d628a9979e3c0b82abe9a693f525" translate="yes" xml:space="preserve">
          <source>Sets the git refspec against which the shelved P4 changelist is compared. Defaults to p4/master.</source>
          <target state="translated">쉘프 된 P4 변경 목록을 비교할 git refspec을 설정합니다. 기본값은 p4 / master입니다.</target>
        </trans-unit>
        <trans-unit id="b66175dc0e90d1aff6b86be51b6554732d676a1f" translate="yes" xml:space="preserve">
          <source>Sets the line ending type to use in the working directory for files that are marked as text (either by having the &lt;code&gt;text&lt;/code&gt; attribute set, or by having &lt;code&gt;text=auto&lt;/code&gt; and Git auto-detecting the contents as text). Alternatives are &lt;code&gt;lf&lt;/code&gt;, &lt;code&gt;crlf&lt;/code&gt; and &lt;code&gt;native&lt;/code&gt;, which uses the platform&amp;rsquo;s native line ending. The default value is &lt;code&gt;native&lt;/code&gt;. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for more information on end-of-line conversion. Note that this value is ignored if &lt;code&gt;core.autocrlf&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="translated">텍스트로 표시된 파일 ( &lt;code&gt;text&lt;/code&gt; 속성이 설정되어 있거나 &lt;code&gt;text=auto&lt;/code&gt; 및 Git이 내용을 텍스트로 자동 감지 함) 을 사용하여 작업 디렉토리에서 사용할 행 끝 유형을 설정 합니다. 대안은 플랫폼의 기본 줄 끝을 사용하는 &lt;code&gt;lf&lt;/code&gt; , &lt;code&gt;crlf&lt;/code&gt; 및 &lt;code&gt;native&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;native&lt;/code&gt; 입니다. 라인 끝 변환에 대한 자세한 내용 은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오. &lt;code&gt;core.autocrlf&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;input&lt;/code&gt; 으로 설정된 경우이 값이 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="767fb38cee626faf4bebc702c67f21f5034dd689" translate="yes" xml:space="preserve">
          <source>Sets the transport helper option &amp;lt;name&amp;gt; to &amp;lt;value&amp;gt;. Outputs a single line containing one of &lt;code&gt;ok&lt;/code&gt; (option successfully set), &lt;code&gt;unsupported&lt;/code&gt; (option not recognized) or &lt;code&gt;error &amp;lt;msg&amp;gt;&lt;/code&gt; (option &amp;lt;name&amp;gt; is supported but &amp;lt;value&amp;gt; is not valid for it). Options should be set before other commands, and may influence the behavior of those commands.</source>
          <target state="translated">전송 도우미 옵션 &amp;lt;name&amp;gt;을 &amp;lt;value&amp;gt;로 설정합니다. &lt;code&gt;ok&lt;/code&gt; (옵션이 성공적으로 설정 됨), &lt;code&gt;unsupported&lt;/code&gt; 않음 (옵션이 인식되지 않음) 또는 &lt;code&gt;error &amp;lt;msg&amp;gt;&lt;/code&gt; (&amp;lt;name&amp;gt; 옵션은 지원되지만 &amp;lt;value&amp;gt;는 유효하지 않음 ) 중 하나를 포함하는 단일 행을 출력합니다 . 옵션은 다른 명령보다 먼저 설정해야하며 해당 명령의 동작에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4361fe164802c15484e2158a7e066e93e95aef1a" translate="yes" xml:space="preserve">
          <source>Sets the version of hook that is to be used when calling fsmonitor. There are currently versions 1 and 2. When this is not set, version 2 will be tried first and if it fails then version 1 will be tried. Version 1 uses a timestamp as input to determine which files have changes since that time but some monitors like watchman have race conditions when used with a timestamp. Version 2 uses an opaque string so that the monitor can return something that can be used to determine what files have changed without race conditions.</source>
          <target state="translated">fsmonitor를 호출 할 때 사용할 후크 버전을 설정합니다. 현재 버전 1과 2가 있습니다. 이것이 설정되지 않은 경우 버전 2가 먼저 시도되고 실패하면 버전 1이 시도됩니다. 버전 1은 타임 스탬프를 입력으로 사용하여 그 시간 이후로 변경된 파일을 확인하지만 워치 맨과 같은 일부 모니터는 타임 스탬프와 함께 사용할 때 경쟁 조건이 있습니다. 버전 2는 불투명 한 문자열을 사용하므로 모니터는 경쟁 조건없이 변경된 파일을 확인하는 데 사용할 수있는 항목을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38552fb2c7ab669744831fa34346e5ff34c9ae00" translate="yes" xml:space="preserve">
          <source>Setting &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; will be picked up by &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;, but to accept pushes of such data set &lt;code&gt;receive.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; instead, or to clone or fetch it set &lt;code&gt;fetch.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">설정 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 에 의해 픽업 될 &lt;a href=&quot;git-fsck&quot;&gt;자식-fsck가 [1]&lt;/a&gt; 있지만, 이러한 데이터 세트의 푸시 수락 &lt;code&gt;receive.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 대신 또는 복제하는 또는 설정 페치 &lt;code&gt;fetch.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8d5bb1f4cfa6fbc6e58411c45908a4ed9f34950" translate="yes" xml:space="preserve">
          <source>Setting an unknown &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; value will cause fsck to die, but doing the same for &lt;code&gt;receive.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; and &lt;code&gt;fetch.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; will only cause git to warn.</source>
          <target state="translated">알 수없는 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 값을 설정하면 fsck가 종료되지만 &lt;code&gt;receive.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 및 &lt;code&gt;fetch.fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 에 대해 동일하게 수행하면 git이 경고 만합니다 .</target>
        </trans-unit>
        <trans-unit id="ec7eb0199cb3dbce5770abe0a0c2186f2bc8c0a6" translate="yes" xml:space="preserve">
          <source>Setting the &quot;binary&quot; attribute also unsets the &quot;text&quot; and &quot;diff&quot; attributes as above. Note that macro attributes can only be &quot;Set&quot;, though setting one might have the effect of setting or unsetting other attributes or even returning other attributes to the &quot;Unspecified&quot; state.</source>
          <target state="translated">&quot;binary&quot;속성을 설정하면 위와 같이 &quot;text&quot;및 &quot;diff&quot;속성도 설정 해제됩니다. 매크로 속성을 설정하면 다른 속성을 설정 또는 설정 해제하거나 다른 속성을 &quot;지정되지 않음&quot;상태로 되돌릴 수도 있지만 매크로 속성은 &quot;설정&quot;만 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0809d7ae8979681e24885ec19091ca517e2431a" translate="yes" xml:space="preserve">
          <source>Setting the &lt;code&gt;mergetool.keepBackup&lt;/code&gt; configuration variable to &lt;code&gt;false&lt;/code&gt; causes &lt;code&gt;git mergetool&lt;/code&gt; to automatically remove the backup as files are successfully merged.</source>
          <target state="translated">&lt;code&gt;mergetool.keepBackup&lt;/code&gt; 구성 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하면 파일이 성공적으로 병합 될 때 &lt;code&gt;git mergetool&lt;/code&gt; 이 자동으로 백업을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="6f0c93315d42b41cf980b4419425789cdaac4058" translate="yes" xml:space="preserve">
          <source>Setting the &lt;code&gt;text&lt;/code&gt; attribute on a path enables end-of-line normalization and marks the path as a text file. End-of-line conversion takes place without guessing the content type.</source>
          <target state="translated">경로에 &lt;code&gt;text&lt;/code&gt; 속성을 설정하면 줄 끝 정규화가 가능하고 경로가 텍스트 파일로 표시됩니다. 줄 끝 변환은 내용 유형을 추측하지 않고 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3d1285aa205a15a3a5aafcd8d0c8d4ab4efd4f97" translate="yes" xml:space="preserve">
          <source>Setting the environment variable &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; will tell gitweb to use the named file (i.e. in this example &lt;code&gt;/etc/gitweb.conf&lt;/code&gt;) as a configuration for gitweb. You don&amp;rsquo;t really need it in above example; it is required only if your configuration file is in different place than built-in (during compiling gitweb) &lt;code&gt;gitweb_config.perl&lt;/code&gt; or &lt;code&gt;/etc/gitweb.conf&lt;/code&gt;. See &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt; for details, especially information about precedence rules.</source>
          <target state="translated">환경 변수 &lt;code&gt;GITWEB_CONFIG&lt;/code&gt; 를 설정하면 gitweb이 명명 된 파일 (예 : &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; )을 gitweb의 구성으로 사용하도록 지시 합니다. 위의 예제에서는 실제로 필요하지 않습니다. 구성 파일이 내장 (gitweb 컴파일 중) &lt;code&gt;gitweb_config.perl&lt;/code&gt; 또는 &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; 와 다른 위치에있는 경우에만 필요합니다 . 우선 순위 규칙에 대한 자세한 내용 은 &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3d285efb6da308c8dd90713d0979acc9d8958228" translate="yes" xml:space="preserve">
          <source>Setting this to 0 disables not only automatic packing based on the number of loose objects, but any other heuristic &lt;code&gt;git gc --auto&lt;/code&gt; will otherwise use to determine if there&amp;rsquo;s work to do, such as &lt;code&gt;gc.autoPackLimit&lt;/code&gt;.</source>
          <target state="translated">이 값을 0으로 설정하면 느슨한 객체 수를 기준으로 자동 패킹을 비활성화 할 수있을뿐 아니라 다른 휴리스틱 &lt;code&gt;git gc --auto&lt;/code&gt; 는 &lt;code&gt;gc.autoPackLimit&lt;/code&gt; 과 같이 수행 할 작업이 있는지 판별하는 데 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="ab556d3ed86f8d66a38201c818a74d5378c14e11" translate="yes" xml:space="preserve">
          <source>Setting this to a value &amp;lt;vcs&amp;gt; will cause Git to interact with the remote with the git-remote-&amp;lt;vcs&amp;gt; helper.</source>
          <target state="translated">이것을 &amp;lt;vcs&amp;gt; 값으로 설정하면 Git은 git-remote- &amp;lt;vcs&amp;gt; 헬퍼와 리모트와 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="a78325706284f4930016d288e2c051f8a8fd0d2b" translate="yes" xml:space="preserve">
          <source>Setting this value to --no-tags disables automatic tag following when fetching from remote &amp;lt;name&amp;gt;. Setting it to --tags will fetch every tag from remote &amp;lt;name&amp;gt;, even if they are not reachable from remote branch heads. Passing these flags directly to &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; can override this setting. See options --tags and --no-tags of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">이 값을 --no-tags로 설정하면 원격 &amp;lt;name&amp;gt;에서 가져올 때 자동 태그 추적이 비활성화됩니다. --tags로 설정하면 원격 분기 헤드에서 도달 할 수없는 경우에도 원격 &amp;lt;name&amp;gt;에서 모든 태그를 가져옵니다. 이 플래그를 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]에&lt;/a&gt; 직접 전달하면 이 설정을 무시할 수 있습니다. &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 의 옵션 --tags 및 --no-tags를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="842c183b9c42b0c2525b9292639925b0e5a22ce0" translate="yes" xml:space="preserve">
          <source>Setting this variable to &quot;true&quot; is the same as setting the &lt;code&gt;text&lt;/code&gt; attribute to &quot;auto&quot; on all files and core.eol to &quot;crlf&quot;. Set to true if you want to have &lt;code&gt;CRLF&lt;/code&gt; line endings in your working directory and the repository has LF line endings. This variable can be set to &lt;code&gt;input&lt;/code&gt;, in which case no output conversion is performed.</source>
          <target state="translated">이 변수를 &quot;true&quot;로 설정하는 것은 모든 파일 에서 &lt;code&gt;text&lt;/code&gt; 속성을 &quot;auto&quot; 로 설정 하고 core.eol을 &quot;crlf&quot; 로 설정하는 것과 같습니다 . 작업 디렉토리에 &lt;code&gt;CRLF&lt;/code&gt; 줄 끝이 있고 저장소에 LF 줄 끝이 있으면 true로 설정하십시오 . 이 변수는 &lt;code&gt;input&lt;/code&gt; 으로 설정 될 수 있으며 ,이 경우 출력 변환이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f2485239ca9db9231d9dc605e4c20a0278342cb8" translate="yes" xml:space="preserve">
          <source>Setting this variable to &lt;code&gt;1&lt;/code&gt; will cause Git to treat all pathspecs as case-insensitive.</source>
          <target state="translated">이 변수를 &lt;code&gt;1&lt;/code&gt; 로 설정 하면 Git은 모든 경로 스펙을 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ca46b471bd9797687c8acd1761125db08a21576" translate="yes" xml:space="preserve">
          <source>Setting this variable to &lt;code&gt;1&lt;/code&gt; will cause Git to treat all pathspecs as glob patterns (aka &quot;glob&quot; magic).</source>
          <target state="translated">이 변수를 &lt;code&gt;1&lt;/code&gt; 로 설정 하면 Git은 모든 경로 스펙을 glob 패턴 (일명 &quot;glob&quot;매직)으로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="d6f6c7a0196e6bb7bea48f89270c29c4b30ce796" translate="yes" xml:space="preserve">
          <source>Setting this variable to &lt;code&gt;1&lt;/code&gt; will cause Git to treat all pathspecs as literal (aka &quot;literal&quot; magic).</source>
          <target state="translated">이 변수를 &lt;code&gt;1&lt;/code&gt; 로 설정 하면 Git은 모든 경로 스펙을 리터럴 (일명 &quot;리터럴&quot;매직)로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="5ca9aa98c8773f3ffdcfb04129c5f9a059aea952" translate="yes" xml:space="preserve">
          <source>Setting this variable to &lt;code&gt;1&lt;/code&gt; will cause Git to treat all pathspecs literally, rather than as glob patterns. For example, running &lt;code&gt;GIT_LITERAL_PATHSPECS=1 git log -- '*.c'&lt;/code&gt; will search for commits that touch the path &lt;code&gt;*.c&lt;/code&gt;, not any paths that the glob &lt;code&gt;*.c&lt;/code&gt; matches. You might want this if you are feeding literal paths to Git (e.g., paths previously given to you by &lt;code&gt;git ls-tree&lt;/code&gt;, &lt;code&gt;--raw&lt;/code&gt; diff output, etc).</source>
          <target state="translated">이 변수를 &lt;code&gt;1&lt;/code&gt; 로 설정 하면 Git은 글로브 패턴이 아닌 모든 경로 스펙을 문자 그대로 취급합니다. 예를 들어, &lt;code&gt;GIT_LITERAL_PATHSPECS=1 git log -- '*.c'&lt;/code&gt; 를 실행하면 glob &lt;code&gt;*.c&lt;/code&gt; 와 일치 하는 경로가 아니라 &lt;code&gt;*.c&lt;/code&gt; 경로를 터치하는 커밋을 검색합니다 . Git에 리터럴 경로 (예 : &lt;code&gt;git ls-tree&lt;/code&gt; , &lt;code&gt;--raw&lt;/code&gt; diff output 등으로 이전에 제공된 경로)를 제공하는 경우이 방법을 원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2a80c691de90ce5c2f5bcae0ddb71cd520d2404" translate="yes" xml:space="preserve">
          <source>Setting up a public repository</source>
          <target state="translated">공용 저장소 설정</target>
        </trans-unit>
        <trans-unit id="3d54bc92ce527cc2dc9817e011bfea7d52def59f" translate="yes" xml:space="preserve">
          <source>Setting up a shared repository</source>
          <target state="translated">공유 저장소 설정</target>
        </trans-unit>
        <trans-unit id="85d7095bad4cc89bf24fcc23e9812d88b70300be" translate="yes" xml:space="preserve">
          <source>Setup and Config</source>
          <target state="translated">설정 및 구성</target>
        </trans-unit>
        <trans-unit id="42bf423e8b49af69779df6afbd52c08e60ab95d8" translate="yes" xml:space="preserve">
          <source>Sharing and Updating Projects</source>
          <target state="translated">프로젝트 공유 및 업데이트</target>
        </trans-unit>
        <trans-unit id="5bd75d5b2b55f503aa568f15ed9baa9da5d8844b" translate="yes" xml:space="preserve">
          <source>Sharing development with others</source>
          <target state="translated">다른 사람들과 개발 공유</target>
        </trans-unit>
        <trans-unit id="7a899aac208ff2bb86fe5c7bc28489c4a1362bac" translate="yes" xml:space="preserve">
          <source>Sharing your changes</source>
          <target state="translated">변경 사항 공유</target>
        </trans-unit>
        <trans-unit id="bc5ae6560f23ddf791959b3443d3c0070e504dbd" translate="yes" xml:space="preserve">
          <source>Short (shortened to &lt;code&gt;$projects_list_description_width&lt;/code&gt; in the projects list page, which is 25 characters by default; see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;) single line description of a project (of a repository). Plain text file; HTML will be escaped. By default set to</source>
          <target state="translated">프로젝트 목록 페이지에서 &lt;code&gt;$projects_list_description_width&lt;/code&gt; 로 단축 ( 기본적으로 25 자, &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt; 참조 ) 프로젝트의 한 줄 설명 (저장소). 일반 텍스트 파일; HTML이 이스케이프됩니다. 기본적으로</target>
        </trans-unit>
        <trans-unit id="5d86956f14bde9ab427b7b6c31b677817dd478ab" translate="yes" xml:space="preserve">
          <source>Short Format</source>
          <target state="translated">짧은 형식</target>
        </trans-unit>
        <trans-unit id="838e7194f933ef4cd0297d8b96a9d80cda6328ea" translate="yes" xml:space="preserve">
          <source>Short for &lt;code&gt;--log-destination=syslog&lt;/code&gt;.</source>
          <target state="translated">에 대한 짧은 &lt;code&gt;--log-destination=syslog&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c9f02f4be5538f5a655964a6f76417ed0e96f8f" translate="yes" xml:space="preserve">
          <source>Shortcut for &lt;code&gt;--copy --force&lt;/code&gt;.</source>
          <target state="translated">에 대한 바로 가기 &lt;code&gt;--copy --force&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56f96ad104be0e60414a9d6fef2d8f4255f1054e" translate="yes" xml:space="preserve">
          <source>Shortcut for &lt;code&gt;--delete --force&lt;/code&gt;.</source>
          <target state="translated">에 대한 바로 가기 &lt;code&gt;--delete --force&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ae41f0ca95cbe8106d76bc74825f096a7f244ce" translate="yes" xml:space="preserve">
          <source>Shortcut for &lt;code&gt;--move --force&lt;/code&gt;.</source>
          <target state="translated">에 대한 바로 가기 &lt;code&gt;--move --force&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48b1cb87c7e9a2d1ef18425956f9eed09b368016" translate="yes" xml:space="preserve">
          <source>Shortcut version for a frequently used remote repository:</source>
          <target state="translated">자주 사용하는 원격 저장소의 바로 가기 버전 :</target>
        </trans-unit>
        <trans-unit id="e715fc3eabd70149ca3b2a0c4ae7d6c328c54848" translate="yes" xml:space="preserve">
          <source>Shortlog will attempt to parse each trailer value as a &lt;code&gt;name &amp;lt;email&amp;gt;&lt;/code&gt; identity. If successful, the mailmap is applied and the email is omitted unless the &lt;code&gt;--email&lt;/code&gt; option is specified. If the value cannot be parsed as an identity, it will be taken literally and completely.</source>
          <target state="translated">Shortlog는 각 트레일러 값을 &lt;code&gt;name &amp;lt;email&amp;gt;&lt;/code&gt; ID 로 구문 분석하려고 시도합니다 . 성공하면 mailmap이 적용되고 &lt;code&gt;--email&lt;/code&gt; 옵션이 지정 되지 않으면 이메일이 생략 됩니다. 값을 ID로 구문 분석 할 수없는 경우 문자 그대로 완전히 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6460a14591c54e9d0ad48cc5a6224ee494fca842" translate="yes" xml:space="preserve">
          <source>Show &amp;lt;eolinfo&amp;gt; and &amp;lt;eolattr&amp;gt; of files. &amp;lt;eolinfo&amp;gt; is the file content identification used by Git when the &quot;text&quot; attribute is &quot;auto&quot; (or not set and core.autocrlf is not false). &amp;lt;eolinfo&amp;gt; is either &quot;-text&quot;, &quot;none&quot;, &quot;lf&quot;, &quot;crlf&quot;, &quot;mixed&quot; or &quot;&quot;.</source>
          <target state="translated">파일의 &amp;lt;eolinfo&amp;gt; 및 &amp;lt;eolattr&amp;gt;을 표시하십시오. &amp;lt;eolinfo&amp;gt;는 &quot;text&quot;속성이 &quot;auto&quot;(또는 설정되어 있지 않고 core.autocrlf가 false가 아님) 인 경우 Git에서 사용하는 파일 내용 식별입니다. &amp;lt;eolinfo&amp;gt;는 &quot;-text&quot;, &quot;none&quot;, &quot;lf&quot;, &quot;crlf&quot;, &quot;mixed&quot;또는 &quot;&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6a8bdc54a2349a127936d3843203ecd6d2eac153" translate="yes" xml:space="preserve">
          <source>Show &amp;lt;num&amp;gt; leading and trailing lines, and place a line containing &lt;code&gt;--&lt;/code&gt; between contiguous groups of matches.</source>
          <target state="translated">&amp;lt;num&amp;gt; 선행 및 후행 줄을 표시하고 연속 된 일치 그룹 사이에 &lt;code&gt;--&lt;/code&gt; 를 포함하는 줄을 배치하십시오 .</target>
        </trans-unit>
        <trans-unit id="f867e00ffafd6cd49c4546fd923f10e52f747e26" translate="yes" xml:space="preserve">
          <source>Show &amp;lt;num&amp;gt; leading lines, and place a line containing &lt;code&gt;--&lt;/code&gt; between contiguous groups of matches.</source>
          <target state="translated">&amp;lt;num&amp;gt; 행을 표시하고 연속 된 일치 그룹 사이에 &lt;code&gt;--&lt;/code&gt; 을 포함하는 행을 배치하십시오 .</target>
        </trans-unit>
        <trans-unit id="a761d1fc7e4500bf5753e3c7e973fa02308ed552" translate="yes" xml:space="preserve">
          <source>Show &amp;lt;num&amp;gt; trailing lines, and place a line containing &lt;code&gt;--&lt;/code&gt; between contiguous groups of matches.</source>
          <target state="translated">&amp;lt;num&amp;gt; 후행을 표시하고 연속 된 일치 그룹 사이에 &lt;code&gt;--&lt;/code&gt; 를 포함하는 행을 배치하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec26d3779318f9118ffbcaac500e06b8c03b82aa" translate="yes" xml:space="preserve">
          <source>Show &lt;code&gt;$GIT_COMMON_DIR&lt;/code&gt; if defined, else &lt;code&gt;$GIT_DIR&lt;/code&gt;.</source>
          <target state="translated">보기 &lt;code&gt;$GIT_COMMON_DIR&lt;/code&gt; 다른 사람이 정의 된 경우에는 &lt;code&gt;$GIT_DIR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7091c2825a946a2f8e36c69c5a82c708d938854f" translate="yes" xml:space="preserve">
          <source>Show &lt;code&gt;$GIT_DIR&lt;/code&gt; if defined. Otherwise show the path to the .git directory. The path shown, when relative, is relative to the current working directory.</source>
          <target state="translated">정의 된 경우 &lt;code&gt;$GIT_DIR&lt;/code&gt; 표시하십시오 . 그렇지 않으면 .git 디렉토리의 경로를 표시하십시오. 상대 경로 인 경우 표시된 경로는 현재 작업 디렉토리에 상대적인 경로입니다.</target>
        </trans-unit>
        <trans-unit id="92bc441ca5dd76e30902fc3cfc432e05960c64fb" translate="yes" xml:space="preserve">
          <source>Show a Git logical variable</source>
          <target state="translated">Git 논리 변수 표시</target>
        </trans-unit>
        <trans-unit id="59a5fc6a75e992fe3955834b9f589f3efdf7f45b" translate="yes" xml:space="preserve">
          <source>Show a browser for the tree of the &lt;code&gt;maint&lt;/code&gt; branch. Files selected in the browser can be viewed with the internal blame viewer.</source>
          <target state="translated">&lt;code&gt;maint&lt;/code&gt; 분기 의 트리에 대한 브라우저를 표시하십시오 . 브라우저에서 선택한 파일은 내부 비난 뷰어로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51464c06cc3ed971f0047721a669b06e6f8dc753" translate="yes" xml:space="preserve">
          <source>Show a confirmation dialog before actually running the tool.</source>
          <target state="translated">실제로 도구를 실행하기 전에 확인 대화 상자를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="6f525616d2d7c1f4fb302645f1046a33897806da" translate="yes" xml:space="preserve">
          <source>Show a diffstat at the end of the merge. The diffstat is also controlled by the configuration option merge.stat.</source>
          <target state="translated">병합 끝에 diffstat를 표시하십시오. diffstat는 구성 옵션 merge.stat에 의해 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="328b16c9977fc386d8875a1c0557b3f9bae42a58" translate="yes" xml:space="preserve">
          <source>Show a diffstat of what changed upstream since the last rebase. The diffstat is also controlled by the configuration option rebase.stat.</source>
          <target state="translated">마지막 리베이스 이후 업스트림에서 변경된 내용의 차이를 보여줍니다. diffstat는 구성 옵션 rebase.stat에 의해 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="89145a6b6d57b54925b2a014779bdd41b63aab6d" translate="yes" xml:space="preserve">
          <source>Show a word diff, using the &amp;lt;mode&amp;gt; to delimit changed words. By default, words are delimited by whitespace; see &lt;code&gt;--word-diff-regex&lt;/code&gt; below. The &amp;lt;mode&amp;gt; defaults to &lt;code&gt;plain&lt;/code&gt;, and must be one of:</source>
          <target state="translated">&amp;lt;mode&amp;gt;를 사용하여 변경된 단어를 구분하여 단어 diff를 표시하십시오. 기본적으로 단어는 공백으로 구분됩니다. 아래의 &lt;code&gt;--word-diff-regex&lt;/code&gt; 를 참조하십시오. &amp;lt;mode&amp;gt;의 기본값은 &lt;code&gt;plain&lt;/code&gt; 이며 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="2104f8f059827e60ca6f3a921f9a667c9ac35df8" translate="yes" xml:space="preserve">
          <source>Show all available formats.</source>
          <target state="translated">사용 가능한 모든 형식을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="995122a1c6abd2724409485dae28721d5cc2418d" translate="yes" xml:space="preserve">
          <source>Show all branches, tags, or remote-tracking branches, respectively (i.e., refs found in &lt;code&gt;refs/heads&lt;/code&gt;, &lt;code&gt;refs/tags&lt;/code&gt;, or &lt;code&gt;refs/remotes&lt;/code&gt;, respectively).</source>
          <target state="translated">모든 브랜치, 태그 또는 원격 추적 브랜치를 각각 표시합니다 (예 : &lt;code&gt;refs/heads&lt;/code&gt; , &lt;code&gt;refs/tags&lt;/code&gt; 또는 &lt;code&gt;refs/remotes&lt;/code&gt; 각각에있는 참조).</target>
        </trans-unit>
        <trans-unit id="321f7678ea19c696fd3fd95db6c787353e8f0a5f" translate="yes" xml:space="preserve">
          <source>Show all commits since version &lt;code&gt;v2.6.12&lt;/code&gt; that changed any file in the &lt;code&gt;include/scsi&lt;/code&gt; or &lt;code&gt;drivers/scsi&lt;/code&gt; subdirectories</source>
          <target state="translated">&lt;code&gt;include/scsi&lt;/code&gt; 또는 &lt;code&gt;drivers/scsi&lt;/code&gt; 서브 디렉토리의 파일을 변경 한 버전 &lt;code&gt;v2.6.12&lt;/code&gt; 이후의 모든 커밋 표시</target>
        </trans-unit>
        <trans-unit id="d180629218690191e783f9ea37e5d26feab056b5" translate="yes" xml:space="preserve">
          <source>Show all refs (branches, tags, etc.).</source>
          <target state="translated">모든 심판 (지점, 태그 등)을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3e7cf0b7d79082307562ec61629e132b2c74285c" translate="yes" xml:space="preserve">
          <source>Show all refs found in &lt;code&gt;refs/&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;refs/&lt;/code&gt; 있는 모든 참조를 표시하십시오 .</target>
        </trans-unit>
        <trans-unit id="05ca74609707b569a39bc5511a1daaae1bd87257" translate="yes" xml:space="preserve">
          <source>Show all refs matching the shell glob pattern &lt;code&gt;pattern&lt;/code&gt;. If the pattern does not start with &lt;code&gt;refs/&lt;/code&gt;, this is automatically prepended. If the pattern does not contain a globbing character (&lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or &lt;code&gt;[&lt;/code&gt;), it is turned into a prefix match by appending &lt;code&gt;/*&lt;/code&gt;.</source>
          <target state="translated">쉘 글로브 패턴 &lt;code&gt;pattern&lt;/code&gt; 일치하는 모든 참조를 표시합니다 . 패턴이 &lt;code&gt;refs/&lt;/code&gt; 시작하지 않으면 자동으로 앞에 붙습니다. 패턴에 글 로빙 문자 ( &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;[&lt;/code&gt; ) 가 포함되어 있지 않으면 &lt;code&gt;/*&lt;/code&gt; 를 추가하여 접두사 일치로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="4fa56b2fc9907d1086b87e5377bf4476cff2c390" translate="yes" xml:space="preserve">
          <source>Show as patches the commits since version &lt;code&gt;v2.6.12&lt;/code&gt; that changed any file in the include/scsi or drivers/scsi subdirectories</source>
          <target state="translated">include / scsi 또는 drivers / scsi 서브 디렉토리의 파일을 변경 한 버전 &lt;code&gt;v2.6.12&lt;/code&gt; 이후의 커밋을 패치로 표시</target>
        </trans-unit>
        <trans-unit id="276551039d5a6f576b01b648390b28318eb26dab" translate="yes" xml:space="preserve">
          <source>Show at most 100 changes made to the file &lt;code&gt;Makefile&lt;/code&gt;. Instead of only looking for changes in the current branch look in all branches.</source>
          <target state="translated">&lt;code&gt;Makefile&lt;/code&gt; 파일에 대해 최대 100 개의 변경 사항을 표시하십시오 . 현재 지점의 변경 사항 만 찾는 대신 모든 지점을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="cc93fcf462d3cdf3d2aeea5e45651f27c396f5a0" translate="yes" xml:space="preserve">
          <source>Show blank SHA-1 for boundary commits. This can also be controlled via the &lt;code&gt;blame.blankboundary&lt;/code&gt; config option.</source>
          <target state="translated">경계 커밋에 대해 빈 SHA-1을 표시합니다. 이는 &lt;code&gt;blame.blankboundary&lt;/code&gt; 구성 옵션을 통해 제어 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eaa41db61e1f1bab3111c0b0f717c116280f3b36" translate="yes" xml:space="preserve">
          <source>Show blank commit object name for boundary commits in &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;. This option defaults to false.</source>
          <target state="translated">경계 커밋에 대한 빈 커밋 객체 이름을 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]에 표시하십시오&lt;/a&gt; . 이 옵션의 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="d4cb9ae41338f332d90c61100df1a02ed4371d7a" translate="yes" xml:space="preserve">
          <source>Show both remote-tracking branches and local branches.</source>
          <target state="translated">원격 추적 지점과 로컬 지점을 모두 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c2301bc581a2d36c1e5747eb8ae04fffb9591539" translate="yes" xml:space="preserve">
          <source>Show branches and their commits</source>
          <target state="translated">지점과 커밋 표시</target>
        </trans-unit>
        <trans-unit id="d55feca71232703b0c06113161bcc96210d9bd44" translate="yes" xml:space="preserve">
          <source>Show brief usage of interactive git-clean.</source>
          <target state="translated">대화식 git-clean의 간단한 사용법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="233374b02c6c18c443fd85da32c678488395ad01" translate="yes" xml:space="preserve">
          <source>Show cached files in the output (default)</source>
          <target state="translated">출력에 캐시 된 파일 표시 (기본값)</target>
        </trans-unit>
        <trans-unit id="ea36f7bdbf7d288541a5d87f6a09bd8649bf7e54" translate="yes" xml:space="preserve">
          <source>Show canonical names and email addresses of contacts</source>
          <target state="translated">연락처의 정식 이름 및 이메일 주소 표시</target>
        </trans-unit>
        <trans-unit id="cfb0dd7a634282eef7f2e441b5e77786240e4318" translate="yes" xml:space="preserve">
          <source>Show changes between commits, commit and working tree, etc</source>
          <target state="translated">커밋, 커밋 및 작업 트리 등의 변경 사항 표시</target>
        </trans-unit>
        <trans-unit id="5a1290ea3e3483a3f5ab5d9ff576cc5a9304f139" translate="yes" xml:space="preserve">
          <source>Show changes between the working tree and the index or a tree, changes between the index and a tree, changes between two trees, changes between two blob objects, or changes between two files on disk.</source>
          <target state="translated">작업 트리와 인덱스 또는 트리 간 변경 사항, 인덱스와 트리 간 변경 사항, 두 트리 간 변경 사항, 두 BLOB 개체 간 변경 사항 또는 디스크의 두 파일 간 변경 사항을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="6189a1046129b02814c474d03dabcd8ea53d41e7" translate="yes" xml:space="preserve">
          <source>Show changes between the working tree and the index or a tree, changes between the index and a tree, changes between two trees, changes resulting from a merge, changes between two blob objects, or changes between two files on disk.</source>
          <target state="translated">작업 트리와 인덱스 또는 트리 간의 변경 사항, 인덱스와 트리 간의 변경 사항, 두 트리 간의 변경 사항, 병합으로 인한 변경 사항, 두 Blob 개체 간의 변경 사항 또는 디스크에있는 두 파일 간의 변경 사항을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="29297be7cb8a5068699eafedd98e29f9ce3b8ef6" translate="yes" xml:space="preserve">
          <source>Show changes using common diff tools</source>
          <target state="translated">일반적인 diff 도구를 사용하여 변경 사항 표시</target>
        </trans-unit>
        <trans-unit id="e6231251cf44dee07a16dc6977218fd9c6ce32a0" translate="yes" xml:space="preserve">
          <source>Show colored diff. &lt;code&gt;--color&lt;/code&gt; (i.e. without &lt;code&gt;=&amp;lt;when&amp;gt;&lt;/code&gt;) is the same as &lt;code&gt;--color=always&lt;/code&gt;. &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; can be one of &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;, or &lt;code&gt;auto&lt;/code&gt;.</source>
          <target state="translated">유색 차이를 보여줍니다. &lt;code&gt;--color&lt;/code&gt; (즉, &lt;code&gt;=&amp;lt;when&amp;gt;&lt;/code&gt; 없는 )는 &lt;code&gt;--color=always&lt;/code&gt; 와 같습니다 . &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; 은 &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;never&lt;/code&gt; 또는 &lt;code&gt;auto&lt;/code&gt; 중 하나 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f57a0260693cc114a660b9cc49bd9ca37b9d97bc" translate="yes" xml:space="preserve">
          <source>Show colored diff. &lt;code&gt;--color&lt;/code&gt; (i.e. without &lt;code&gt;=&amp;lt;when&amp;gt;&lt;/code&gt;) is the same as &lt;code&gt;--color=always&lt;/code&gt;. &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; can be one of &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;never&lt;/code&gt;, or &lt;code&gt;auto&lt;/code&gt;. It can be changed by the &lt;code&gt;color.ui&lt;/code&gt; and &lt;code&gt;color.diff&lt;/code&gt; configuration settings.</source>
          <target state="translated">유색 차이를 보여줍니다. &lt;code&gt;--color&lt;/code&gt; (즉, &lt;code&gt;=&amp;lt;when&amp;gt;&lt;/code&gt; 없는 )는 &lt;code&gt;--color=always&lt;/code&gt; 와 같습니다 . &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; 은 &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;never&lt;/code&gt; 또는 &lt;code&gt;auto&lt;/code&gt; 중 하나 일 수 있습니다 . &lt;code&gt;color.ui&lt;/code&gt; 및 &lt;code&gt;color.diff&lt;/code&gt; 구성 설정 으로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1325c8ee6526284b9e19b2d177df5189d833f9f" translate="yes" xml:space="preserve">
          <source>Show colored matches. The value must be always (the default), never, or auto.</source>
          <target state="translated">컬러 경기를 표시합니다. 값은 항상 (기본값), 절대 또는 자동이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ae1799387849e3f0fc844a1cc566a09160bccbf5" translate="yes" xml:space="preserve">
          <source>Show commit logs</source>
          <target state="translated">커밋 로그 표시</target>
        </trans-unit>
        <trans-unit id="091e7ae4df5348623adddab90ca75314d19e3c27" translate="yes" xml:space="preserve">
          <source>Show commit summary between the given commit (defaults to HEAD) and working tree/index. For a submodule in question, a series of commits in the submodule between the given super project commit and the index or working tree (switched by &lt;code&gt;--cached&lt;/code&gt;) are shown. If the option &lt;code&gt;--files&lt;/code&gt; is given, show the series of commits in the submodule between the index of the super project and the working tree of the submodule (this option doesn&amp;rsquo;t allow to use the &lt;code&gt;--cached&lt;/code&gt; option or to provide an explicit commit).</source>
          <target state="translated">주어진 커밋 (기본값은 HEAD)과 작업 트리 / 인덱스 사이에 커밋 요약을 표시합니다. 문제가있는 서브 모듈의 경우, 주어진 수퍼 프로젝트 커밋과 인덱스 또는 작업 트리 ( &lt;code&gt;--cached&lt;/code&gt; 로 전환 ) 사이의 서브 모듈에있는 일련의 커밋 이 표시됩니다. &lt;code&gt;--files&lt;/code&gt; 옵션 이 주어지면, 수퍼 프로젝트의 색인과 서브 모듈의 작업 트리 사이의 서브 모듈에 일련의 커밋을 표시하십시오 (이 옵션은 &lt;code&gt;--cached&lt;/code&gt; 옵션 을 사용 하거나 명시 적을 제공하는 것을 허용하지 않습니다) 범하다).</target>
        </trans-unit>
        <trans-unit id="895d627a1559b0f7b8ffb93987e2fbd111bfab2e" translate="yes" xml:space="preserve">
          <source>Show commits more recent than a specific date.</source>
          <target state="translated">특정 날짜보다 최근 커밋을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="10992a126510a25dfd1dd64a15502560e4eb97fe" translate="yes" xml:space="preserve">
          <source>Show commits older than a specific date.</source>
          <target state="translated">특정 날짜보다 오래된 커밋을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="65509170881e19fa232abfecd80c1044bc1bc01b" translate="yes" xml:space="preserve">
          <source>Show conflicts in &quot;diff3&quot; style.</source>
          <target state="translated">&quot;diff3&quot;스타일로 충돌을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="a627c4be174c8a5ee15f7fc10aa836495b1089c5" translate="yes" xml:space="preserve">
          <source>Show deleted files in the output</source>
          <target state="translated">출력에서 삭제 된 파일 표시</target>
        </trans-unit>
        <trans-unit id="84454ab6d9a5866ee531cd5f7e98a88b4117a393" translate="yes" xml:space="preserve">
          <source>Show directions on how to proceed from the current state in the output of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt;, in the template shown when writing commit messages in &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;, and in the help message shown by &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; or &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; when switching branch.</source>
          <target state="translated">&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 에 커밋 메시지를 작성할 때 표시되는 템플릿 과 &lt;a href=&quot;git-switch&quot;&gt;git-switch [1]에&lt;/a&gt; 의해 표시된 도움말 메시지에서 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 의 출력에서 ​​현재 상태로 진행하는 방법에 대한 지시 사항을 표시 하십시오 . 또는 분기를 전환 할 때 &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5fc1f3cf9452e6039731a7a1df5dffca4ae78ea2" translate="yes" xml:space="preserve">
          <source>Show every object whose name begins with the given prefix. The &amp;lt;prefix&amp;gt; must be at least 4 hexadecimal digits long to avoid listing each and every object in the repository by mistake.</source>
          <target state="translated">이름이 주어진 접두사로 시작하는 모든 객체를 표시하십시오. 실수로 저장소의 각 오브젝트를 나열하지 않도록 &amp;lt;prefix&amp;gt;는 16 진수 이상의 4 자리 여야합니다.</target>
        </trans-unit>
        <trans-unit id="0d94de8daf12eebfa732214b2af1b9a367d2d94d" translate="yes" xml:space="preserve">
          <source>Show files on the filesystem that need to be removed due to file/directory conflicts for checkout-index to succeed.</source>
          <target state="translated">checkout-index가 성공하려면 파일 / 디렉토리 충돌로 인해 제거해야하는 파일 시스템의 파일을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="ad0ababacc675e26eaf1a0889c9c6ef14ce3769a" translate="yes" xml:space="preserve">
          <source>Show given paths which don&amp;rsquo;t match any pattern. This only makes sense when &lt;code&gt;--verbose&lt;/code&gt; is enabled, otherwise it would not be possible to distinguish between paths which match a pattern and those which don&amp;rsquo;t.</source>
          <target state="translated">패턴과 일치하지 않는 주어진 경로를 표시하십시오. &lt;code&gt;--verbose&lt;/code&gt; 가 활성화 된 경우에만 의미 가 있습니다. 그렇지 않으면 패턴과 일치하는 경로와 그렇지 않은 경로를 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="762aaa5ab5565ca8e2b3774059028eb53b59477c" translate="yes" xml:space="preserve">
          <source>Show help message.</source>
          <target state="translated">도움말 메시지를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="838b52958b292fca61c3a5108dd4ee2a3a75c971" translate="yes" xml:space="preserve">
          <source>Show ignored files as well.</source>
          <target state="translated">무시 된 파일도 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="e68b8eea48173094c49e93c786ee56fa7184a0b7" translate="yes" xml:space="preserve">
          <source>Show in a format designed for machine consumption.</source>
          <target state="translated">기계 소 비용으로 설계된 형식으로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="db93b492cc402222428883561395c8e5b81cce1c" translate="yes" xml:space="preserve">
          <source>Show information about files in the index and the working tree</source>
          <target state="translated">색인 및 작업 트리의 파일에 대한 정보 표시</target>
        </trans-unit>
        <trans-unit id="d2d64dc76cbd792285e7b6cfa7570beea5afa702" translate="yes" xml:space="preserve">
          <source>Show just what commits would be submitted to p4; do not change state in Git or p4.</source>
          <target state="translated">p4에 제출할 커밋을 보여줍니다. Git 또는 p4의 상태를 변경하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="76fafda4935f99c8dd9af522c6c8e19e60857b59" translate="yes" xml:space="preserve">
          <source>Show logs with difference each commit introduces</source>
          <target state="translated">커밋이 도입 한 차이와 함께 로그 표시</target>
        </trans-unit>
        <trans-unit id="aa7fe52bb648501db2c178df84cc787b4333ba17" translate="yes" xml:space="preserve">
          <source>Show long rev (Default: off).</source>
          <target state="translated">긴 개정 표시 (기본값 : 해제).</target>
        </trans-unit>
        <trans-unit id="5e7221f97ed7eacfd8cdc162cdb28622dbce9b38" translate="yes" xml:space="preserve">
          <source>Show modified files in the output</source>
          <target state="translated">출력에 수정 된 파일 표시</target>
        </trans-unit>
        <trans-unit id="68201a6a34d181c9493b1441e79fe99724faace5" translate="yes" xml:space="preserve">
          <source>Show no parents before all of its children are shown, and avoid showing commits on multiple lines of history intermixed.</source>
          <target state="translated">모든 자식이 표시되기 전에 부모를 표시하지 말고 여러 줄의 역사가 섞인 커밋을 표시하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8b60cbbf5a70ba9636b88509153ae8ade5e1cc90" translate="yes" xml:space="preserve">
          <source>Show no parents before all of its children are shown, but otherwise show commits in the author timestamp order.</source>
          <target state="translated">모든 자식이 표시되기 전에 부모를 표시하지 않지만 작성자 타임 스탬프 순서대로 커밋을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="fc0432ce52689cf9d25cd4a23e5fba4317479073" translate="yes" xml:space="preserve">
          <source>Show no parents before all of its children are shown, but otherwise show commits in the commit timestamp order.</source>
          <target state="translated">모든 자식이 표시되기 전에 부모를 표시하지 않으면 커밋 타임 스탬프 순서로 커밋을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="f771bb437a0a632ca38fbb772c5f1f11e2687b42" translate="yes" xml:space="preserve">
          <source>Show object size of blob (file) entries.</source>
          <target state="translated">얼룩 (파일) 항목의 객체 크기를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="8ab164ff8a8b9e0dee1e1b73990f42cea75d4c17" translate="yes" xml:space="preserve">
          <source>Show only commits in the specified revision range. When no &amp;lt;revision range&amp;gt; is specified, it defaults to &lt;code&gt;HEAD&lt;/code&gt; (i.e. the whole history leading to the current commit). &lt;code&gt;origin..HEAD&lt;/code&gt; specifies all the commits reachable from the current commit (i.e. &lt;code&gt;HEAD&lt;/code&gt;), but not from &lt;code&gt;origin&lt;/code&gt;. For a complete list of ways to spell &amp;lt;revision range&amp;gt;, see the &quot;Specifying Ranges&quot; section of &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">지정된 개정 범위의 커밋 만 표시합니다. &amp;lt;개정 범위&amp;gt;가 지정되지 않은 경우 기본값은 &lt;code&gt;HEAD&lt;/code&gt; (즉, 현재 커밋으로 이어지는 전체 기록)입니다. &lt;code&gt;origin..HEAD&lt;/code&gt; 는 현재 커밋 (예 : &lt;code&gt;HEAD&lt;/code&gt; ) 에서 도달 할 수 있지만 &lt;code&gt;origin&lt;/code&gt; 에서는 도달 할 수없는 모든 커밋을 지정합니다 . &amp;lt;개정 범위&amp;gt; 철자법의 전체 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 의 &quot;범위 지정&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="329dbdc2afc2b5cab87309e7fc9f29edaec58da0" translate="yes" xml:space="preserve">
          <source>Show only commits in the specified revision range. When no &amp;lt;revision range&amp;gt; is specified, it defaults to &lt;code&gt;HEAD&lt;/code&gt; (i.e. the whole history leading to the current commit). &lt;code&gt;origin..HEAD&lt;/code&gt; specifies all the commits reachable from the current commit (i.e. &lt;code&gt;HEAD&lt;/code&gt;), but not from &lt;code&gt;origin&lt;/code&gt;. For a complete list of ways to spell &amp;lt;revision range&amp;gt;, see the &lt;code&gt;Specifying Ranges&lt;/code&gt; section of &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">지정된 개정 범위의 커밋 만 표시합니다. &amp;lt;개정 범위&amp;gt;가 지정되지 않은 경우 기본값은 &lt;code&gt;HEAD&lt;/code&gt; (즉, 현재 커밋으로 이어지는 전체 기록)입니다. &lt;code&gt;origin..HEAD&lt;/code&gt; 는 현재 커밋 (예 : &lt;code&gt;HEAD&lt;/code&gt; ) 에서 도달 할 수 있지만 &lt;code&gt;origin&lt;/code&gt; 에서는 도달 할 수없는 모든 커밋을 지정합니다 . &amp;lt;개정 범위&amp;gt; 철자법의 전체 목록 은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 의 &lt;code&gt;Specifying Ranges&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c46a13d2904f8d6c610a867599fe01f9862dd57c" translate="yes" xml:space="preserve">
          <source>Show only commits that are enough to explain how the files that match the specified paths came to be. See &lt;code&gt;History Simplification&lt;/code&gt; below for details and other simplification modes.</source>
          <target state="translated">지정된 경로와 일치하는 파일이 어떻게 만들어 졌는지 설명하기에 충분한 커밋 만 표시하십시오. 자세한 내용 및 기타 단순화 모드는 아래의 &lt;code&gt;History Simplification&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="66430bcd7753c6221125437192d0fae1e7031a91" translate="yes" xml:space="preserve">
          <source>Show only commits which have at least (or at most) that many parent commits. In particular, &lt;code&gt;--max-parents=1&lt;/code&gt; is the same as &lt;code&gt;--no-merges&lt;/code&gt;, &lt;code&gt;--min-parents=2&lt;/code&gt; is the same as &lt;code&gt;--merges&lt;/code&gt;. &lt;code&gt;--max-parents=0&lt;/code&gt; gives all root commits and &lt;code&gt;--min-parents=3&lt;/code&gt; all octopus merges.</source>
          <target state="translated">많은 상위 커밋이있는 커밋 만 표시합니다. 특히에서 &lt;code&gt;--max-parents=1&lt;/code&gt; 과 동일 &lt;code&gt;--no-merges&lt;/code&gt; , &lt;code&gt;--min-parents=2&lt;/code&gt; 와 동일 &lt;code&gt;--merges&lt;/code&gt; . &lt;code&gt;--max-parents=0&lt;/code&gt; 은 모든 루트 커밋을 제공하고 &lt;code&gt;--min-parents=3&lt;/code&gt; 은 모든 문어 병합을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="af5969993dd03043080efc38142a1ed4316038eb" translate="yes" xml:space="preserve">
          <source>Show only ignored files in the output. When showing files in the index, print only those matched by an exclude pattern. When showing &quot;other&quot; files, show only those matched by an exclude pattern. Standard ignore rules are not automatically activated, therefore at least one of the &lt;code&gt;--exclude*&lt;/code&gt; options is required.</source>
          <target state="translated">출력에서 무시 된 파일 만 표시하십시오. 색인에 파일을 표시 할 때 제외 패턴과 일치하는 파일 만 인쇄하십시오. &quot;기타&quot;파일을 표시 할 때 제외 패턴과 일치하는 파일 만 표시하십시오. 표준 무시 규칙은 자동으로 활성화되지 않으므로 &lt;code&gt;--exclude*&lt;/code&gt; 옵션 중 하나 이상 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="002b0d2d59d3dcff4e51f5a87881355bfa57f547" translate="yes" xml:space="preserve">
          <source>Show only modification, rename, and copy, but not addition or deletion.</source>
          <target state="translated">수정, 이름 바꾸기 및 복사 만 표시하고 추가 또는 삭제는 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c49ead1d682188547c7f67234f6eb73a64f21cf" translate="yes" xml:space="preserve">
          <source>Show only names and status of changed files. See the description of the &lt;code&gt;--diff-filter&lt;/code&gt; option on what the status letters mean.</source>
          <target state="translated">변경된 파일의 이름과 상태 만 표시합니다. 상태 문자의 의미에 대해서는 &lt;code&gt;--diff-filter&lt;/code&gt; 옵션에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0ce605c7552a8aba98345c842476a27b2a9c28e4" translate="yes" xml:space="preserve">
          <source>Show only names and the nature of change, but not actual diff output.</source>
          <target state="translated">이름과 변경 특성 만 표시하지만 실제 diff 출력은 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="835669256cac48c4e209f28cd6e5b641f9186e51" translate="yes" xml:space="preserve">
          <source>Show only names of changed files.</source>
          <target state="translated">변경된 파일 이름 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="be1dc5236687c9842a30e8f5499d3363ce72f159" translate="yes" xml:space="preserve">
          <source>Show only the named tree entry itself, not its children.</source>
          <target state="translated">자식이 아닌 명명 된 트리 항목 자체 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="8c61ca2fb81ac3434e9edecd88dadef66a32e9a7" translate="yes" xml:space="preserve">
          <source>Show only unmerged branches in the &lt;code&gt;revPrompt&lt;/code&gt; subdialog. This is useful for tools similar to merge or rebase, but not for things like checkout or reset.</source>
          <target state="translated">&lt;code&gt;revPrompt&lt;/code&gt; 하위 대화 상자에 병합되지 않은 분기 만 표시하십시오 . 이는 병합 또는 리베이스와 유사한 도구에는 유용하지만 체크 아웃 또는 재설정과 같은 도구에는 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bcce9ca1424c944de6ae0083c8d4fdfea35ee963" translate="yes" xml:space="preserve">
          <source>Show other (i.e. untracked) files in the output</source>
          <target state="translated">출력에 다른 (즉, 추적되지 않은) 파일 표시</target>
        </trans-unit>
        <trans-unit id="b66aeda059663e06293f23a26a8d9280cb01bb39" translate="yes" xml:space="preserve">
          <source>Show packed archive index</source>
          <target state="translated">압축 아카이브 색인 표시</target>
        </trans-unit>
        <trans-unit id="867eafced11331f75ab644a43b8e1a6c8a1b09e5" translate="yes" xml:space="preserve">
          <source>Show progress reports on stderr as objects are considered. The &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt; text will be printed with each progress update.</source>
          <target state="translated">오브젝트가 고려 될 때 stderr에 진행 보고서를 표시하십시오. &lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt; 텍스트가 각각 진행 업데이트로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="f20a140b8853bef6c5df99f49ec5adde7b92f174" translate="yes" xml:space="preserve">
          <source>Show progress reports on stderr as patches are generated.</source>
          <target state="translated">패치가 생성 될 때 stderr에 진행 보고서를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="873f06beb8dcdfdf113f3a3696210210ae4585eb" translate="yes" xml:space="preserve">
          <source>Show progress.</source>
          <target state="translated">진행 상황을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0aa1726b9011fcb05b9b5a738460be2bb61ef6af" translate="yes" xml:space="preserve">
          <source>Show raw timestamp (Default: off).</source>
          <target state="translated">원시 타임 스탬프를 표시합니다 (기본값 : 해제).</target>
        </trans-unit>
        <trans-unit id="7167725b750724d1668f3392932bcc3766402e73" translate="yes" xml:space="preserve">
          <source>Show recursive diffs.</source>
          <target state="translated">재귀 diff를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="4a21113a85b9e00a6d43c59bc8a68e2e1734a7de" translate="yes" xml:space="preserve">
          <source>Show references matching one or more patterns. Patterns are matched from the end of the full name, and only complete parts are matched, e.g. &lt;code&gt;master&lt;/code&gt; matches &lt;code&gt;refs/heads/master&lt;/code&gt;, &lt;code&gt;refs/remotes/origin/master&lt;/code&gt;, &lt;code&gt;refs/tags/jedi/master&lt;/code&gt; but not &lt;code&gt;refs/heads/mymaster&lt;/code&gt; or &lt;code&gt;refs/remotes/master/jedi&lt;/code&gt;.</source>
          <target state="translated">하나 이상의 패턴과 일치하는 참조를 표시합니다. 전체 이름의 끝에서 패턴이 일치하고 &lt;code&gt;master&lt;/code&gt; 일치 &lt;code&gt;refs/heads/master&lt;/code&gt; , &lt;code&gt;refs/remotes/origin/master&lt;/code&gt; , &lt;code&gt;refs/tags/jedi/master&lt;/code&gt; 와 일치 하지만 &lt;code&gt;refs/heads/mymaster&lt;/code&gt; 또는 &lt;code&gt;refs/remotes/master/jedi&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5256f8d763cc4d210c603b98ae747ed57f6b9b37" translate="yes" xml:space="preserve">
          <source>Show repository only if this file exists (in repository). Only effective if this variable evaluates to true. Can be set when building gitweb by setting &lt;code&gt;GITWEB_EXPORT_OK&lt;/code&gt;. This path is relative to &lt;code&gt;GIT_DIR&lt;/code&gt;. git-daemon[1] uses &lt;code&gt;git-daemon-export-ok&lt;/code&gt;, unless started with &lt;code&gt;--export-all&lt;/code&gt;. By default this variable is not set, which means that this feature is turned off.</source>
          <target state="translated">이 파일이 존재하는 경우에만 (저장소에) 저장소를 표시하십시오. 이 변수가 true로 평가되는 경우에만 유효합니다. &lt;code&gt;GITWEB_EXPORT_OK&lt;/code&gt; 를 설정하여 gitweb을 빌드 할 때 설정할 수 있습니다 . 이 경로는 &lt;code&gt;GIT_DIR&lt;/code&gt; 에 상대적 입니다. git-daemon [1]은 &lt;code&gt;--export-all&lt;/code&gt; 로 시작하지 않는 한 &lt;code&gt;git-daemon-export-ok&lt;/code&gt; 를 사용합니다 . 기본적으로이 변수는 설정되어 있지 않으므로이 기능이 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="61630b8887fba0c6ae1f6471c93d4b1ac2d78421" translate="yes" xml:space="preserve">
          <source>Show staged contents' mode bits, object name and stage number in the output.</source>
          <target state="translated">출력에 스테이지 컨텐츠의 모드 비트, 오브젝트 이름 및 스테이지 번호를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="146391550f639861a0610768d29eef80cf7e2b56" translate="yes" xml:space="preserve">
          <source>Show the HEAD reference, even if it would normally be filtered out.</source>
          <target state="translated">일반적으로 필터링되는 경우에도 HEAD 참조를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="fea0b0dc87e518d09c89e0b3cebe67d85f5ef7a7" translate="yes" xml:space="preserve">
          <source>Show the absolute path of the root of the superproject&amp;rsquo;s working tree (if exists) that uses the current repository as its submodule. Outputs nothing if the current repository is not used as a submodule by any project.</source>
          <target state="translated">현재 저장소를 서브 모듈로 사용하는 수퍼 프로젝트의 작업 트리 루트 (있는 경우)의 절대 경로를 표시하십시오. 현재 저장소가 프로젝트에서 하위 모듈로 사용되지 않으면 아무것도 출력하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81d568ac49f075957202365490a4c231f9c1f3ac" translate="yes" xml:space="preserve">
          <source>Show the absolute path of the top-level directory of the working tree. If there is no working tree, report an error.</source>
          <target state="translated">작업 트리 최상위 디렉토리의 절대 경로를 표시하십시오. 작업 트리가 없으면 오류를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="d58575cff5ae50bf5388e0984f120c24ef0b57bb" translate="yes" xml:space="preserve">
          <source>Show the author email instead of author name (Default: off). This can also be controlled via the &lt;code&gt;blame.showEmail&lt;/code&gt; config option.</source>
          <target state="translated">저자 이름 대신 작성자 이메일을 표시합니다 (기본값 : 꺼짐). &lt;code&gt;blame.showEmail&lt;/code&gt; 구성 옵션을 통해 제어 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ecb96a53849cc4ea467a6d904be25f5e345a592" translate="yes" xml:space="preserve">
          <source>Show the author email instead of author name in &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;. This option defaults to false.</source>
          <target state="translated">&lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; 에 저자 이름 대신 저자 이메일을 표시하십시오 . 이 옵션의 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="4bcbe1ac6c4bdbbf9ea91698126aa20a057ccc2c" translate="yes" xml:space="preserve">
          <source>Show the branch and tracking info even in short-format.</source>
          <target state="translated">분기 및 추적 정보를 짧은 형식으로도 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="a7915b46ed412ee27d561c779d7568440c30d97c" translate="yes" xml:space="preserve">
          <source>Show the changes during the last two weeks to the file &lt;code&gt;gitk&lt;/code&gt;. The &quot;--&quot; is necessary to avoid confusion with the &lt;strong&gt;branch&lt;/strong&gt; named &lt;code&gt;gitk&lt;/code&gt;</source>
          <target state="translated">지난 2 주 동안 &lt;code&gt;gitk&lt;/code&gt; 파일에 대한 변경 사항을 표시하십시오 . &quot;-&quot;는 &lt;code&gt;gitk&lt;/code&gt; 라는 &lt;strong&gt;브랜치&lt;/strong&gt; 와의 혼동을 피하기 위해 필요합니다</target>
        </trans-unit>
        <trans-unit id="a8fc389f3fa0446576124b8d36bfb677216cd040" translate="yes" xml:space="preserve">
          <source>Show the changes during the last two weeks to the file &lt;code&gt;gitk&lt;/code&gt;. The &lt;code&gt;--&lt;/code&gt; is necessary to avoid confusion with the &lt;strong&gt;branch&lt;/strong&gt; named &lt;code&gt;gitk&lt;/code&gt;</source>
          <target state="translated">지난 2 주 동안 &lt;code&gt;gitk&lt;/code&gt; 파일에 대한 변경 사항을 표시하십시오 . 는 &lt;code&gt;--&lt;/code&gt; 와 혼동을 피하기 위해 필요한 &lt;strong&gt;지점&lt;/strong&gt; 이름 &lt;code&gt;gitk&lt;/code&gt; 이</target>
        </trans-unit>
        <trans-unit id="9eebb0dfcba472cb083099fa0a98ec8bef90962a" translate="yes" xml:space="preserve">
          <source>Show the changes recorded in the stash entry as a diff between the stashed contents and the commit back when the stash entry was first created. By default, the command shows the diffstat, but it will accept any format known to &lt;code&gt;git diff&lt;/code&gt; (e.g., &lt;code&gt;git stash show -p stash@{1}&lt;/code&gt; to view the second most recent entry in patch form). You can use stash.showStat and/or stash.showPatch config variables to change the default behavior.</source>
          <target state="translated">숨김 항목에 기록 된 변경 사항을 숨김 항목이 처음 생성되었을 때 숨김 된 내용과 커밋 된 내용 사이의 차이로 표시합니다. 기본적으로 명령은 diffstat를 표시하지만 &lt;code&gt;git diff&lt;/code&gt; 에 알려진 모든 형식을 허용합니다 (예 : 패치 형식에서 두 번째로 최근 항목을 보려면 &lt;code&gt;git stash show -p stash@{1}&lt;/code&gt; ). stash.showStat 및 / 또는 stash.showPatch 구성 변수를 사용하여 기본 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="877bab942fc51a3086fcc16e754d1712669dc82e" translate="yes" xml:space="preserve">
          <source>Show the changes recorded in the stash entry as a diff between the stashed contents and the commit back when the stash entry was first created. When no &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is given, it shows the latest one. By default, the command shows the diffstat, but it will accept any format known to &lt;code&gt;git diff&lt;/code&gt; (e.g., &lt;code&gt;git stash show -p stash@{1}&lt;/code&gt; to view the second most recent entry in patch form). You can use stash.showStat and/or stash.showPatch config variables to change the default behavior.</source>
          <target state="translated">숨김 항목에 처음 기록되었을 때 숨김 컨텐츠와 커밋 백 간의 차이로 숨김 항목에 기록 된 변경 사항을 표시하십시오. &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 가 제공 되지 않으면 가장 최근의 것이 표시됩니다. 기본적으로이 명령은 diffstat를 표시하지만 &lt;code&gt;git diff&lt;/code&gt; 로 알려진 형식 (예 : &lt;code&gt;git stash show -p stash@{1}&lt;/code&gt; 을 사용하여 가장 최근의 두 번째 항목을 패치 형식으로 표시) 을 승인합니다 . stash.showStat 및 / 또는 stash.showPatch 구성 변수를 사용하여 기본 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dc3c2578e3a9fa987c1a16be4e18cd8d21ed499" translate="yes" xml:space="preserve">
          <source>Show the changes since version &lt;code&gt;v2.6.12&lt;/code&gt; that changed any file in the include/scsi or drivers/scsi subdirectories</source>
          <target state="translated">include / scsi 또는 drivers / scsi 서브 디렉토리의 파일을 변경 한 버전 &lt;code&gt;v2.6.12&lt;/code&gt; 이후의 변경 사항 표시</target>
        </trans-unit>
        <trans-unit id="59882bbc15f62948be114af14833ad7f6dee5f50" translate="yes" xml:space="preserve">
          <source>Show the commit itself and the commit log message even if the diff itself is empty.</source>
          <target state="translated">diff 자체가 비어 있어도 커밋 자체와 커밋 로그 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="8a1797e0ff002e85bbdedc5376243381a92ddebf" translate="yes" xml:space="preserve">
          <source>Show the commit subjects next to the SHA1s.</source>
          <target state="translated">SHA1 옆에 커밋 제목을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="13a02f2303b4ed4a2167fcf812fcf1ac53740ea9" translate="yes" xml:space="preserve">
          <source>Show the commits that are in the &quot;test&quot; branch but not yet in the &quot;release&quot; branch, along with the list of paths each commit modifies.</source>
          <target state="translated">&quot;test&quot;브랜치에는 있지만 아직 &quot;release&quot;브랜치에는없는 커밋을 각 커밋이 수정하는 경로 목록과 함께 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="724ae33ae952d72a471b3d97f22a84d58cfd2176" translate="yes" xml:space="preserve">
          <source>Show the content as converted by the filters configured in the current working tree for the given &amp;lt;path&amp;gt; (i.e. smudge filters, end-of-line conversion, etc). In this case, &amp;lt;object&amp;gt; has to be of the form &amp;lt;tree-ish&amp;gt;:&amp;lt;path&amp;gt;, or :&amp;lt;path&amp;gt;.</source>
          <target state="translated">주어진 &amp;lt;path&amp;gt;에 대해 현재 작업 트리에 구성된 필터 (예 : 얼룩 필터, 라인 끝 변환 등)로 변환 된 내용을 표시합니다. 이 경우 &amp;lt;object&amp;gt;는 &amp;lt;tree-ish&amp;gt; : &amp;lt;path&amp;gt; 또는 : &amp;lt;path&amp;gt; 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="be70371f28252f06cf6503a94132408841f759d7" translate="yes" xml:space="preserve">
          <source>Show the content as transformed by a textconv filter. In this case, &amp;lt;object&amp;gt; has to be of the form &amp;lt;tree-ish&amp;gt;:&amp;lt;path&amp;gt;, or :&amp;lt;path&amp;gt; in order to apply the filter to the content recorded in the index at &amp;lt;path&amp;gt;.</source>
          <target state="translated">textconv 필터로 변환 된 내용을 표시하십시오. 이 경우 &amp;lt;path&amp;gt;의 색인에 기록 된 내용에 필터를 적용하려면 &amp;lt;object&amp;gt;의 형식이 &amp;lt;tree-ish&amp;gt; : &amp;lt;path&amp;gt; 또는 : &amp;lt;path&amp;gt; 여야합니다.</target>
        </trans-unit>
        <trans-unit id="78813d71262485f1cc698929fd8f6ed3ab93eba8" translate="yes" xml:space="preserve">
          <source>Show the contents of &lt;code&gt;Makefile&lt;/code&gt; in revision &lt;code&gt;v0.99.8&lt;/code&gt; and provide annotations for each line. Unlike the above example the file is read from the object database and not the working directory.</source>
          <target state="translated">개정판 &lt;code&gt;v0.99.8&lt;/code&gt; 에 &lt;code&gt;Makefile&lt;/code&gt; 의 내용을 표시하고 각 줄에 주석을 제공하십시오. 위의 예와 달리 파일은 작업 디렉토리가 아닌 오브젝트 데이터베이스에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="5c3c76e526574e694470512f190e4502f8d279a5" translate="yes" xml:space="preserve">
          <source>Show the contents of the file &lt;code&gt;Makefile&lt;/code&gt; in the current working directory, and provide annotations for both the original author of each line, and who moved the line to its current location. The uncommitted file is annotated, and uncommitted changes (if any) are explicitly attributed to &lt;code&gt;Not Yet Committed&lt;/code&gt;.</source>
          <target state="translated">현재 작업 디렉토리에 &lt;code&gt;Makefile&lt;/code&gt; 파일의 내용을 표시하고 각 줄의 원래 작성자와 해당 줄을 현재 위치로 이동 한 사람 모두에게 주석을 제공하십시오. 커밋되지 않은 파일이 주석하고, 커밋되지 않은 변경 (있는 경우)를 명시 적으로에 기인 &lt;code&gt;Not Yet Committed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e218b59d83785be7915643dfc5b6a7b490def489" translate="yes" xml:space="preserve">
          <source>Show the context between diff hunks, up to the specified number of lines, thereby fusing hunks that are close to each other. Defaults to &lt;code&gt;diff.interHunkContext&lt;/code&gt; or 0 if the config option is unset.</source>
          <target state="translated">diff hunk 사이에 지정된 행 수까지 컨텍스트를 표시하여 서로 가까운 hunk를 융합하십시오. 기본값은 &lt;code&gt;diff.interHunkContext&lt;/code&gt; 이거나 config 옵션이 설정되지 않은 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="738d68d4dedc5068c7659d3b55ae573e291dd6e6" translate="yes" xml:space="preserve">
          <source>Show the context between diff hunks, up to the specified number of lines, thereby fusing the hunks that are close to each other. This value serves as the default for the &lt;code&gt;--inter-hunk-context&lt;/code&gt; command line option.</source>
          <target state="translated">지정된 수의 줄까지 diff hunk 사이의 컨텍스트를 표시하여 서로 가까운 hunk를 융합하십시오. 이 값은 &lt;code&gt;--inter-hunk-context&lt;/code&gt; 명령 줄 옵션 의 기본값으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f70107eeb8997652e58a1d8572c279efb177133" translate="yes" xml:space="preserve">
          <source>Show the current patch in an interactive rebase or when rebase is stopped because of conflicts. This is the equivalent of &lt;code&gt;git show REBASE_HEAD&lt;/code&gt;.</source>
          <target state="translated">대화식 리베이스 또는 충돌로 인해 리베이스가 중지 된 경우 현재 패치를 표시합니다. 이것은 &lt;code&gt;git show REBASE_HEAD&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="70f379614ad3c3f540d932681a54d5c082f0dab9" translate="yes" xml:space="preserve">
          <source>Show the email address of each author.</source>
          <target state="translated">각 저자의 이메일 주소를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="7d75f0f1d94f4cb5fb2f3f4826ebeee8b6bd4db1" translate="yes" xml:space="preserve">
          <source>Show the entire e-mail message &quot;git am&quot; has stopped at, because of conflicts.</source>
          <target state="translated">충돌로 인해 전체 전자 메일 메시지 &quot;git am&quot;이 중지되었음을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="172de3da6fec23b745b3f7495e42b18d6ff2e3d5" translate="yes" xml:space="preserve">
          <source>Show the filename above the matches in that file instead of at the start of each shown line.</source>
          <target state="translated">표시된 각 줄의 시작 부분이 아니라 해당 파일에서 일치하는 파일 이름 위에 파일 이름을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="f95469ae696b3f00df813ab275db8edbf948a14b" translate="yes" xml:space="preserve">
          <source>Show the filename in the original commit. By default the filename is shown if there is any line that came from a file with a different name, due to rename detection.</source>
          <target state="translated">원래 커밋에 파일 이름을 표시하십시오. 이름 바꾸기 감지로 인해 다른 이름의 파일에서 나온 행이 있으면 기본적으로 파일 이름이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3e3d59b4bf16e3f56b771d2e4d942efd80dd4d82" translate="yes" xml:space="preserve">
          <source>Show the full 40-byte hexadecimal commit object name. This negates &lt;code&gt;--abbrev-commit&lt;/code&gt; and those options which imply it such as &quot;--oneline&quot;. It also overrides the &lt;code&gt;log.abbrevCommit&lt;/code&gt; variable.</source>
          <target state="translated">전체 40 바이트 16 진 확약 오브젝트 이름을 표시하십시오. 이것은 &lt;code&gt;--abbrev-commit&lt;/code&gt; 과 &quot;--oneline&quot;과 같은 옵션을 무시합니다. 또한 &lt;code&gt;log.abbrevCommit&lt;/code&gt; 변수를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="61ee0a84eb604c1f8a4a6a6caa87ed9b0aa485c5" translate="yes" xml:space="preserve">
          <source>Show the full 40-byte hexadecimal commit object name. This negates &lt;code&gt;--abbrev-commit&lt;/code&gt;, either explicit or implied by other options such as &quot;--oneline&quot;. It also overrides the &lt;code&gt;log.abbrevCommit&lt;/code&gt; variable.</source>
          <target state="translated">전체 40 바이트 16 진수 커밋 개체 이름을 표시합니다. 이것은 명시 적이거나 &quot;--oneline&quot;과 같은 다른 옵션에 의해 암시 된 &lt;code&gt;--abbrev-commit&lt;/code&gt; 을 부정 합니다. 또한 &lt;code&gt;log.abbrevCommit&lt;/code&gt; 변수를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="f9a9f3cf0d88f67dc0a2f911b2a17556553b49ba" translate="yes" xml:space="preserve">
          <source>Show the given destination prefix instead of &quot;b/&quot;.</source>
          <target state="translated">&quot;b /&quot;대신 지정된 대상 접두사를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="4a610521917af2112009fac9ef83beff567eff6c" translate="yes" xml:space="preserve">
          <source>Show the given source prefix instead of &quot;a/&quot;.</source>
          <target state="translated">&quot;a /&quot;대신 지정된 소스 접두사를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="77be67edff03e9adcf5b9f00110ef7e89bbf43f4" translate="yes" xml:space="preserve">
          <source>Show the line number in the original commit (Default: off).</source>
          <target state="translated">원래 커밋에 줄 번호를 표시하십시오 (기본값 : off).</target>
        </trans-unit>
        <trans-unit id="edc37494876d892fcb3f9e5ed21ef2bd5105c12c" translate="yes" xml:space="preserve">
          <source>Show the message at which &lt;code&gt;git am&lt;/code&gt; has stopped due to conflicts. If &lt;code&gt;raw&lt;/code&gt; is specified, show the raw contents of the e-mail message; if &lt;code&gt;diff&lt;/code&gt;, show the diff portion only. Defaults to &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">충돌로 인해 &lt;code&gt;git am&lt;/code&gt; 이 중지 된 메시지를 표시합니다 . &lt;code&gt;raw&lt;/code&gt; 가 지정된 경우 전자 메일 메시지의 원시 내용을 표시합니다. &lt;code&gt;diff&lt;/code&gt; 인 경우 diff 부분 만 표시합니다. 기본값은 &lt;code&gt;raw&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7fc90bd9d374d0e136811a02e380e22be094fea9" translate="yes" xml:space="preserve">
          <source>Show the notes (see &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt;) that annotate the commit, when showing the commit log message. This is the default for &lt;code&gt;git log&lt;/code&gt;, &lt;code&gt;git show&lt;/code&gt; and &lt;code&gt;git whatchanged&lt;/code&gt; commands when there is no &lt;code&gt;--pretty&lt;/code&gt;, &lt;code&gt;--format&lt;/code&gt;, or &lt;code&gt;--oneline&lt;/code&gt; option given on the command line.</source>
          <target state="translated">커밋 로그 메시지를 표시 할 때 커밋에 주석을 &lt;a href=&quot;git-notes&quot;&gt;달는&lt;/a&gt; 노트 ( git-notes [1] 참조 )를 표시하십시오. 이것은 명령 행에 &lt;code&gt;--pretty&lt;/code&gt; , &lt;code&gt;--format&lt;/code&gt; 또는 &lt;code&gt;--oneline&lt;/code&gt; 옵션 이 없을 때 &lt;code&gt;git log&lt;/code&gt; , &lt;code&gt;git show&lt;/code&gt; 및 &lt;code&gt;git whatchanged&lt;/code&gt; 명령 의 기본값입니다 .</target>
        </trans-unit>
        <trans-unit id="5d9c16ddef53da23b241c4981fec0a65a72c29ca" translate="yes" xml:space="preserve">
          <source>Show the notes for a given object (defaults to HEAD).</source>
          <target state="translated">주어진 개체에 대한 메모를 표시합니다 (기본값은 HEAD).</target>
        </trans-unit>
        <trans-unit id="f0bfdb6e91a5688fc1141d3407d575275f304926" translate="yes" xml:space="preserve">
          <source>Show the number of entries currently stashed away.</source>
          <target state="translated">현재 숨겨져있는 항목 수를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3c9a6685a00f511f81c04581bd599d8474c49f6d" translate="yes" xml:space="preserve">
          <source>Show the object format (hash algorithm) used for the repository for storage inside the &lt;code&gt;.git&lt;/code&gt; directory, input, or output. For input, multiple algorithms may be printed, space-separated. If not specified, the default is &quot;storage&quot;.</source>
          <target state="translated">&lt;code&gt;.git&lt;/code&gt; 디렉토리, 입력 또는 출력 내에 저장하기 위해 저장소에 사용 된 오브젝트 형식 (해시 알고리즘)을 표시하십시오 . 입력을 위해 여러 알고리즘이 인쇄되어 공백으로 분리 될 수 있습니다. 지정하지 않으면 기본값은 &quot;storage&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="2065145a8ccf699cb187c308bae854443dde9e61" translate="yes" xml:space="preserve">
          <source>Show the path to the shared index file in split index mode, or empty if not in split-index mode.</source>
          <target state="translated">분할 색인 모드에서 공유 색인 파일의 경로를 표시하거나 분할 색인 모드가 아닌 경우 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc95b34844d65ed902bda405925620eb3e5a1983" translate="yes" xml:space="preserve">
          <source>Show the porcelain format, but output commit information for each line, not just the first time a commit is referenced. Implies --porcelain.</source>
          <target state="translated">도자기 형식을 보여 주지만 커밋이 처음 참조 될 때만이 아니라 각 행에 대한 커밋 정보를 출력합니다. 도자기를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c81496056d90f54bdff08b7b7019335227bad0b2" translate="yes" xml:space="preserve">
          <source>Show the preceding line that contains the function name of the match, unless the matching line is a function name itself. The name is determined in the same way as &lt;code&gt;git diff&lt;/code&gt; works out patch hunk headers (see &lt;code&gt;Defining a custom hunk-header&lt;/code&gt; in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;).</source>
          <target state="translated">일치하는 행이 함수 이름 자체가 아닌 한, 일치하는 함수 이름이 포함 된 선행 행을 표시하십시오. 이름은 &lt;code&gt;git diff&lt;/code&gt; 가 패치 덩어리 헤더 를 처리하는 것과 같은 방식으로 결정됩니다 ( &lt;a href=&quot;gitattributes&quot;&gt;gitattributes&lt;/a&gt; 에서 &lt;code&gt;Defining a custom hunk-header&lt;/code&gt; 덩어리 헤더 정의 [5] 참조 ).</target>
        </trans-unit>
        <trans-unit id="114a9aa417c57ec620d43a64c520abeb8e1f3f29" translate="yes" xml:space="preserve">
          <source>Show the progress of checking files out.</source>
          <target state="translated">파일 체크 아웃 진행 상태를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e5e665e21c64d0029d8257ef6e137aa1376a6118" translate="yes" xml:space="preserve">
          <source>Show the remote-tracking branches.</source>
          <target state="translated">원격 추적 지점을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="b9c5b299181f4d64f3ea6e8b9c13b148fff537b5" translate="yes" xml:space="preserve">
          <source>Show the result incrementally in a format designed for machine consumption.</source>
          <target state="translated">기계 소비를 위해 설계된 형식으로 결과를 점진적으로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="c999f8cbf6fa5c24fdf8b2b9b5596b445f624a80" translate="yes" xml:space="preserve">
          <source>Show the status of the submodules. This will print the SHA-1 of the currently checked out commit for each submodule, along with the submodule path and the output of &lt;code&gt;git describe&lt;/code&gt; for the SHA-1. Each SHA-1 will possibly be prefixed with &lt;code&gt;-&lt;/code&gt; if the submodule is not initialized, &lt;code&gt;+&lt;/code&gt; if the currently checked out submodule commit does not match the SHA-1 found in the index of the containing repository and &lt;code&gt;U&lt;/code&gt; if the submodule has merge conflicts.</source>
          <target state="translated">서브 모듈의 상태를 표시하십시오. 그러면 서브 모듈 경로 및 SHA-1에 대한 &lt;code&gt;git describe&lt;/code&gt; 출력과 함께 각 서브 모듈에 대해 현재 체크 아웃 된 커밋의 SHA-1이 인쇄됩니다 . 각각의 SHA-1은 아마도로 시작됩니다 &lt;code&gt;-&lt;/code&gt; 서브 모듈이 초기화되어 있지 않은 경우, &lt;code&gt;+&lt;/code&gt; 현재 체크 아웃 된 서브 모듈이 일치하지 않는 커밋 경우 SHA-1이 포함 된 저장소와의 인덱스에있는 &lt;code&gt;U&lt;/code&gt; 서브 모듈이 병합 충돌이있는 경우.</target>
        </trans-unit>
        <trans-unit id="32335b1eb1c0a4fbecaf630b0ab1df57722da3d3" translate="yes" xml:space="preserve">
          <source>Show the surrounding text from the previous line containing a function name up to the one before the next function name, effectively showing the whole function in which the match was found.</source>
          <target state="translated">함수 이름이 포함 된 이전 행의 주변 텍스트를 다음 함수 이름 앞의 텍스트까지 표시하여 일치하는 항목을 찾은 전체 함수를 효과적으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9511319e5f4aea9984dc4693f8341e94527b78d9" translate="yes" xml:space="preserve">
          <source>Show the tree objects in the diff output.</source>
          <target state="translated">diff 출력에 트리 개체를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ee3926cd6bade9ce34cbcecec5eb956d896d053e" translate="yes" xml:space="preserve">
          <source>Show the tree objects in the diff output. This implies &lt;code&gt;-r&lt;/code&gt;.</source>
          <target state="translated">diff 출력에 트리 오브젝트를 표시하십시오. 이것은 &lt;code&gt;-r&lt;/code&gt; 을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="984ffa4d6fa814707b9db0fd0df1de10038cb7e9" translate="yes" xml:space="preserve">
          <source>Show the whole commit history, but skip any merges</source>
          <target state="translated">커밋 기록 전체를 표시하지만 병합을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="41ba3127797e7497aaa54b06768281c0f54c0178" translate="yes" xml:space="preserve">
          <source>Show the working tree status</source>
          <target state="translated">작업 트리 상태 표시</target>
        </trans-unit>
        <trans-unit id="4be15cef7828db991e29f252f2096ac52eaa87a1" translate="yes" xml:space="preserve">
          <source>Show three-way merge without touching index</source>
          <target state="translated">인덱스를 건드리지 않고 3 방향 병합 표시</target>
        </trans-unit>
        <trans-unit id="c011e03eeb56d943a760cc013e6f2e4eb1d425c0" translate="yes" xml:space="preserve">
          <source>Show tree entries even when going to recurse them. Has no effect if &lt;code&gt;-r&lt;/code&gt; was not passed. &lt;code&gt;-d&lt;/code&gt; implies &lt;code&gt;-t&lt;/code&gt;.</source>
          <target state="translated">반복 할 때에도 트리 항목을 표시합니다. &lt;code&gt;-r&lt;/code&gt; 이 전달되지 않으면 효과 가 없습니다. &lt;code&gt;-d&lt;/code&gt; 는 &lt;code&gt;-t&lt;/code&gt; 를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="0ebf2c3da3729666fcca774c5c0088e26b46bc94" translate="yes" xml:space="preserve">
          <source>Show unified diff between the HEAD commit and what would be committed at the bottom of the commit message template to help the user describe the commit by reminding what changes the commit has. Note that this diff output doesn&amp;rsquo;t have its lines prefixed with &lt;code&gt;#&lt;/code&gt;. This diff will not be a part of the commit message. See the &lt;code&gt;commit.verbose&lt;/code&gt; configuration variable in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">HEAD 커밋과 커밋 메시지 템플릿의 맨 아래에 커밋 된 내용 사이에 통합 된 차이점을 표시하여 커밋의 변경 사항을 상기시켜 사용자가 커밋을 설명 할 수 있도록합니다. 이 diff 출력에는 &lt;code&gt;#&lt;/code&gt; 앞에 접두사가 붙지 않습니다 . 이 diff는 커밋 메시지의 일부가 아닙니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 &lt;code&gt;commit.verbose&lt;/code&gt; 구성 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ec5cbecb883dc178104f40a9f6290a06e20fc1c" translate="yes" xml:space="preserve">
          <source>Show uniquely abbreviated commit object as fallback.</source>
          <target state="translated">고유하게 축약 된 확약 오브젝트를 대체로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="10c7ca24c353332c5b887c6b6a1d6dd7a457b5d5" translate="yes" xml:space="preserve">
          <source>Show unmerged files in the output (forces --stage)</source>
          <target state="translated">출력에 병합되지 않은 파일 표시 (forces --stage)</target>
        </trans-unit>
        <trans-unit id="b5d593f0c18fdb91296748ca1fac373587b954d6" translate="yes" xml:space="preserve">
          <source>Show untracked files.</source>
          <target state="translated">추적되지 않은 파일을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="26b08d61663ae392b69c5a69245f4edf21293755" translate="yes" xml:space="preserve">
          <source>Show various types of objects</source>
          <target state="translated">다양한 유형의 객체 표시</target>
        </trans-unit>
        <trans-unit id="21c5bff92d5285947c85ec0c1484f22db009a919" translate="yes" xml:space="preserve">
          <source>Show what revision and author last modified each line of a file</source>
          <target state="translated">파일의 각 줄을 마지막으로 수정 한 개정 및 작성자 표시</target>
        </trans-unit>
        <trans-unit id="966d3662ec6148441d1b868ba18110f8156c9e7e" translate="yes" xml:space="preserve">
          <source>Show what revision and author last modified each line of a file. The output of this mode is format-compatible with the output of &amp;lsquo;svn blame&amp;rsquo; by default. Like the SVN blame command, local uncommitted changes in the working tree are ignored; the version of the file in the HEAD revision is annotated. Unknown arguments are passed directly to &lt;code&gt;git blame&lt;/code&gt;.</source>
          <target state="translated">파일의 각 행을 마지막으로 수정 한 개정 및 작성자를 표시하십시오. 이 모드의 출력은 기본적으로 'svn blame'의 출력과 형식 호환됩니다. SVN blame 명령과 마찬가지로 작업 트리에서 커밋되지 않은 로컬 변경 사항은 무시됩니다. HEAD 개정판의 파일 버전에 주석이 달렸습니다. 알 수없는 인수는 &lt;code&gt;git blame&lt;/code&gt; 에 직접 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="bf9833b3864a606f143f671880d0d7c492524c3a" translate="yes" xml:space="preserve">
          <source>Show what would be done and clean files interactively. See &amp;ldquo;Interactive mode&amp;rdquo; for details.</source>
          <target state="translated">수행 할 작업을 표시하고 파일을 대화식으로 정리하십시오. 자세한 내용은 &quot;대화식 모드&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="df9413d989d45b2c0aaf57aba32e9c05293cab52" translate="yes" xml:space="preserve">
          <source>Show what would be done, without making any changes.</source>
          <target state="translated">변경하지 않고 수행 할 작업을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="be4ca0a0825cd627301347d0b898edf805764f04" translate="yes" xml:space="preserve">
          <source>Show whole surrounding functions of changes.</source>
          <target state="translated">변화의 전체 주변 기능을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="468ba140a3b94d2f9cd6ef93cfa9cab1327c9537" translate="yes" xml:space="preserve">
          <source>Show words as &lt;code&gt;[-removed-]&lt;/code&gt; and &lt;code&gt;{+added+}&lt;/code&gt;. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous.</source>
          <target state="translated">단어를 &lt;code&gt;[-removed-]&lt;/code&gt; 및 &lt;code&gt;{+added+}&lt;/code&gt; . 분리 문자가 입력에 표시되면 분리 문자를 이스케이프하려고 시도하지 않으므로 출력이 모호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="853a8e226495d515cddaf8f8812833ecd070bbe7" translate="yes" xml:space="preserve">
          <source>Showing commits unique to a given branch</source>
          <target state="translated">주어진 브랜치에 고유 한 커밋 표시</target>
        </trans-unit>
        <trans-unit id="96ca3a302ef6077a82014da5f00857782e6cb86a" translate="yes" xml:space="preserve">
          <source>Shown when &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; gives up trying to guess based on the source and destination refs what remote ref namespace the source belongs in, but where we can still suggest that the user push to either refs/heads/* or refs/tags/* based on the type of the source object.</source>
          <target state="translated">때 표시 &lt;a href=&quot;git-push&quot;&gt;자식 푸시 [1]&lt;/a&gt; 원격 심판 소스에 속하는 네임 스페이스 어떤 소스 및 대상 심판을 기준으로 생각하려고까지 제공하지만, 우리는 여전히 제안 할 수 있습니다 곳 중 심판 / 헤드 / * 또는 심판 / 태그 사용자 푸시 / *는 소스 객체의 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="75d7e8b680f4e534527cb3c486bef0af3659328c" translate="yes" xml:space="preserve">
          <source>Shown when &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; rejects an update that does not qualify for fast-forwarding (e.g., a tag.)</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 가 빨리 감기에 적합하지 않은 업데이트 (예 : 태그)를 거부 할 때 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a0a872703503f071b91634941e8be2dc5533cd1" translate="yes" xml:space="preserve">
          <source>Shown when &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; rejects an update that tries to overwrite a remote ref that points at an object that is not a commit-ish, or make the remote ref point at an object that is not a commit-ish.</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 가 커밋이 아닌 객체를 가리키는 원격 참조를 덮어 쓰거나 원격 참조가 커밋이 아닌 객체를 가리 키도록하는 업데이트를 거부 할 때 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b4c04c7663321c0bb15512a5590b839a243ed3d" translate="yes" xml:space="preserve">
          <source>Shown when &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; rejects an update that tries to overwrite a remote ref that points at an object we do not have.</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 가 가지고 있지 않은 객체를 가리키는 원격 참조를 덮어 쓰려는 업데이트를 거부 할 때 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="78b784f23e7ef12a1020b996b898b9ff902a30e8" translate="yes" xml:space="preserve">
          <source>Shown when &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; computes the ahead/behind counts for a local ref compared to its remote tracking ref, and that calculation takes longer than expected. Will not appear if &lt;code&gt;status.aheadBehind&lt;/code&gt; is false or the option &lt;code&gt;--no-ahead-behind&lt;/code&gt; is given.</source>
          <target state="translated">도시 때 &lt;a href=&quot;git-status&quot;&gt;자식 - 상태 [1]&lt;/a&gt; 의 원격 추적 (REF)과 비교하여 로컬 타이밍에서 카운트 뒤에 /를 전방을 계산하고, 그 계산이 예상보다 오래 걸린다. &lt;code&gt;status.aheadBehind&lt;/code&gt; 가 false이거나 &lt;code&gt;--no-ahead-behind&lt;/code&gt; 옵션이 제공 되면 나타나지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d338c5b596db1d1f3b4bc876559fe0665e8ac5fb" translate="yes" xml:space="preserve">
          <source>Shows &amp;lt;n&amp;gt; most recent ref-log entries for the given ref. If &amp;lt;base&amp;gt; is given, &amp;lt;n&amp;gt; entries going back from that entry. &amp;lt;base&amp;gt; can be specified as count or date. When no explicit &amp;lt;ref&amp;gt; parameter is given, it defaults to the current branch (or &lt;code&gt;HEAD&lt;/code&gt; if it is detached).</source>
          <target state="translated">주어진 심판에 대한 가장 최근의 심판 기록 항목을 &amp;lt;n&amp;gt; 보여줍니다. &amp;lt;base&amp;gt;가 제공되면 &amp;lt;n&amp;gt; 개의 항목이 해당 항목에서 되돌아옵니다. &amp;lt;base&amp;gt;는 개수 또는 날짜로 지정할 수 있습니다. 명시적인 &amp;lt;ref&amp;gt; 매개 변수가 제공되지 않으면 현재 분기 (또는 분리 된 경우 &lt;code&gt;HEAD&lt;/code&gt; )로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="145d28125d096ddf08f1e26c4d9787f99dd5cc7e" translate="yes" xml:space="preserve">
          <source>Shows all commits that are in any of local branches but not in any of remote-tracking branches for &lt;code&gt;origin&lt;/code&gt; (what you have that origin doesn&amp;rsquo;t).</source>
          <target state="translated">로컬 분기에 있지만 &lt;code&gt;origin&lt;/code&gt; 대한 원격 추적 분기에는없는 모든 커밋을 표시 합니다 (원본이없는 것).</target>
        </trans-unit>
        <trans-unit id="c51c52f011be107f5e19468bb7f02daf26af2024" translate="yes" xml:space="preserve">
          <source>Shows all commits that are in local master but not in any remote repository master branches.</source>
          <target state="translated">로컬 마스터에는 있지만 원격 저장소 마스터 분기에는없는 모든 커밋을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="10371d1293071dacd448b9fdd202c3afd277b14e" translate="yes" xml:space="preserve">
          <source>Shows commit logs and diff output each commit introduces.</source>
          <target state="translated">각 커밋이 소개하는 커밋 로그 및 diff 출력을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="476dac31e594be06f217fa896bee0115d58f6b4c" translate="yes" xml:space="preserve">
          <source>Shows history of the file or directory in a given repository path, starting from given revision (defaults to HEAD, i.e. default branch).</source>
          <target state="translated">지정된 리포지토리 (기본값은 HEAD, 즉 기본 분기)에서 시작하여 지정된 리포지토리 경로에 파일 또는 디렉토리의 기록을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="952b827e77460f64206eeaa3be7cd6994665a085" translate="yes" xml:space="preserve">
          <source>Shows how the function &lt;code&gt;main()&lt;/code&gt; in the file &lt;code&gt;main.c&lt;/code&gt; evolved over time.</source>
          <target state="translated">&lt;code&gt;main.c&lt;/code&gt; 파일의 &lt;code&gt;main()&lt;/code&gt; 함수 가 시간이 지남 에 따라 어떻게 진화 했는지 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="ce9fdc182e7532561a25c9e84afbf603141702a1" translate="yes" xml:space="preserve">
          <source>Shows information about a file or directory similar to what &amp;lsquo;svn info&amp;rsquo; provides. Does not currently support a -r/--revision argument. Use the --url option to output only the value of the &lt;code&gt;URL:&lt;/code&gt; field.</source>
          <target state="translated">'svn info'가 제공하는 것과 유사한 파일 또는 디렉토리에 대한 정보를 표시합니다. 현재 -r /-revision 인수를 지원하지 않습니다. &lt;code&gt;URL:&lt;/code&gt; 필드 의 값만 출력하려면 --url 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca1b824d0d56099189f69630ad24bacce78fa10f" translate="yes" xml:space="preserve">
          <source>Shows information about a specific commit in a repository. The &lt;code&gt;commit&lt;/code&gt; view shows information about commit in more detail, the &lt;code&gt;commitdiff&lt;/code&gt; action shows changeset for given commit.</source>
          <target state="translated">저장소의 특정 커밋에 대한 정보를 표시합니다. (가) &lt;code&gt;commit&lt;/code&gt; 뷰 프로그램 정보에 대해보다 상세히 커밋 &lt;code&gt;commitdiff&lt;/code&gt; 의 행동 프로그램은 주어진 커밋에 대한 변경 집합.</target>
        </trans-unit>
        <trans-unit id="ab228fa7c7d65eb09f46d0e73fe8d72b79bc229a" translate="yes" xml:space="preserve">
          <source>Shows log information (commit message or just commit subject) for a given branch (starting from given revision).</source>
          <target state="translated">주어진 브랜치에 대한 로그 정보 (커밋 메시지 또는 커밋 제목)를 표시합니다 (주어진 개정에서 시작).</target>
        </trans-unit>
        <trans-unit id="a3433f3c29ab88ea9167add81dd6a17e06d4de7e" translate="yes" xml:space="preserve">
          <source>Shows one or more objects (blobs, trees, tags and commits).</source>
          <target state="translated">하나 이상의 객체 (블롭, 트리, 태그 및 커밋)를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c89f1cda347c61bcda5c7bb78673af53b8dae0ad" translate="yes" xml:space="preserve">
          <source>Shows only commits that are NOT on the first branch given. This helps track topic branches by hiding any commit that is already in the main line of development. When given &quot;git show-branch --topics master topic1 topic2&quot;, this will show the revisions given by &quot;git rev-list ^master topic1 topic2&quot;</source>
          <target state="translated">주어진 첫 번째 분기에없는 커밋 만 표시합니다. 이는 기본 개발 라인에있는 커밋을 숨겨 주제 분기를 추적하는 데 도움이됩니다. &quot;git show-branch --topics master topic1 topic2&quot;가 주어지면 &quot;git rev-list ^ master topic1 topic2&quot;에 의해 제공된 개정이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ad855617a566df1f282b86f94f82b5d862a150d3" translate="yes" xml:space="preserve">
          <source>Shows the Subversion externals. Use -r/--revision to specify a specific revision.</source>
          <target state="translated">Subversion 외부를 표시합니다. -r /-revision을 사용하여 특정 개정을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="71ee8b01832959c514dd0597fe4e33b8eee16c88" translate="yes" xml:space="preserve">
          <source>Shows the blame (also called annotation) information for a file. On a per line basis it shows the revision in which that line was last changed and the user that committed the change. The incremental version (which if configured is used automatically when JavaScript is enabled) uses Ajax to incrementally add blame info to the contents of given file.</source>
          <target state="translated">파일에 대한 책임 (주석이라고도 함) 정보를 표시합니다. 행 단위로 해당 행이 마지막으로 변경된 개정 및 변경을 커밋 한 사용자가 표시됩니다. 인크 리 멘탈 버전 (JavaScript가 활성화 된 경우 자동으로 구성되는 경우)은 Ajax를 사용하여 지정된 파일의 컨텐츠에 비난 정보를 점진적으로 추가합니다.</target>
        </trans-unit>
        <trans-unit id="048347ade13621e5b8c85cb1ac7da77939e1ffa9" translate="yes" xml:space="preserve">
          <source>Shows the commit ancestry graph starting from the commits named with &amp;lt;rev&amp;gt;s or &amp;lt;glob&amp;gt;s (or all refs under refs/heads and/or refs/tags) semi-visually.</source>
          <target state="translated">&amp;lt;rev&amp;gt; s 또는 &amp;lt;glob&amp;gt; s (또는 refs / heads 및 / 또는 refs / tags 아래의 모든 ref)로 명명 된 커밋에서 시작하여 커밋 상위 그래프를 반 시각적으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d974b70c2c30c4540e25d821a52ee3e8a89faf35" translate="yes" xml:space="preserve">
          <source>Shows the commit logs.</source>
          <target state="translated">커밋 로그를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="afa4aeeb0e59c57a072646fb612e51228d9e8ce5" translate="yes" xml:space="preserve">
          <source>Shows the commits that changed &lt;code&gt;builtin/rev-list.c&lt;/code&gt;, including those commits that occurred before the file was given its present name.</source>
          <target state="translated">파일에 현재 이름이 부여되기 전에 발생한 커밋을 포함하여 &lt;code&gt;builtin/rev-list.c&lt;/code&gt; 를 변경 한 커밋을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="0d2116a149d849234c7b09c554d651b4894474fc" translate="yes" xml:space="preserve">
          <source>Shows the contents of the file &lt;code&gt;Documentation/README&lt;/code&gt; as they were current in the 10th last commit of the branch &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; 지점의 마지막 10 번째 커밋에서 현재의 &lt;code&gt;Documentation/README&lt;/code&gt; 파일의 내용을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="ccc9b587b1ac64f4516513aa59159ddedbb8a45f" translate="yes" xml:space="preserve">
          <source>Shows the difference between two revisions of the same file.</source>
          <target state="translated">동일한 파일의 두 개정판의 차이점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="8c5916992e873dd9df6491dab9446ed99d2ca43b" translate="yes" xml:space="preserve">
          <source>Shows the files and directories in a given repository path, at given revision. This is default command if no action is specified in the URL, and path is given.</source>
          <target state="translated">지정된 개정판에서 지정된 저장소 경로의 파일 및 디렉토리를 표시합니다. URL에 조치가 지정되지 않은 경우 기본 명령이며 경로가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="890a038d1a0efbf86457550ddb0f94462d132854" translate="yes" xml:space="preserve">
          <source>Shows the history including change diffs, but only from the &amp;ldquo;main branch&amp;rdquo; perspective, skipping commits that come from merged branches, and showing full diffs of changes introduced by the merges. This makes sense only when following a strict policy of merging all topic branches when staying on a single integration branch.</source>
          <target state="translated">변경 차이를 포함한 히스토리를 보여 주지만 &quot;메인 브랜치&quot;관점에서만, 병합 된 분기에서 온 커밋을 건너 뛰고, 병합에서 도입 된 전체 변경 사항을 보여줍니다. 이는 단일 통합 브랜치에 머무를 때 모든 토픽 브랜치를 병합하는 엄격한 정책을 따르는 경우에만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6e093f4d97154b146a36fee068be195950aadfd" translate="yes" xml:space="preserve">
          <source>Shows the subject of the commit pointed to by the tag &lt;code&gt;v1.0.0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v1.0.0&lt;/code&gt; 태그가 가리키는 커밋의 주제를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="9b44c59ff3bc267fd7a4cbc7d7224ea23d69056e" translate="yes" xml:space="preserve">
          <source>Shows the tag &lt;code&gt;v1.0.0&lt;/code&gt;, along with the object the tags points at.</source>
          <target state="translated">태그가 가리키는 객체와 함께 태그 &lt;code&gt;v1.0.0&lt;/code&gt; 을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="092526538596a5fe7b0994948947cb6672086546" translate="yes" xml:space="preserve">
          <source>Shows the tree pointed to by the tag &lt;code&gt;v1.0.0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v1.0.0&lt;/code&gt; 태그가 가리키는 트리를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="436f07afaaab4f38cb1e7cf08118570b5794b7ea" translate="yes" xml:space="preserve">
          <source>Side note: Unfortunately, people tend to fixate on the written-in-shell aspect and periodically ask if git-filter-branch could be rewritten in another language to fix the performance issues. Not only does that ignore the bigger intrinsic problems with the design, it&amp;rsquo;d help less than you&amp;rsquo;d expect: if git-filter-branch itself were not shell, then the convenience functions (map(), skip_commit(), etc) and the &lt;code&gt;--setup&lt;/code&gt; argument could no longer be executed once at the beginning of the program but would instead need to be prepended to every user filter (and thus re-executed with every commit).</source>
          <target state="translated">참고 사항 : 불행히도 사람들은 쉘로 작성된 측면을 수정하는 경향이 있으며 성능 문제를 해결하기 위해 git-filter-branch를 다른 언어로 다시 작성할 수 있는지 정기적으로 묻습니다. git-filter-branch 자체가 쉘이 아닌 경우 편의 함수 (map (), skip_commit () 등)는 디자인과 관련하여 더 큰 본질적인 문제를 무시할뿐만 아니라 예상보다 덜 도움이됩니다. 그리고 &lt;code&gt;--setup&lt;/code&gt; 인수는 더 이상 프로그램의 시작 부분에 한 번 실행되지 수 있지만, 대신 모든 사용자 필터 앞에 추가 할 (따라서 모든 확약 재실행)해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a31cdd9cba3408afdcd7a253a0ac442839b0979" translate="yes" xml:space="preserve">
          <source>Side note: it may be possible to do step 2 with about:config and the following settings but no one&amp;rsquo;s tried yet.</source>
          <target state="translated">참고 : about : config 및 다음 설정으로 2 단계를 수행 할 수 있지만 아직 시도한 사람은 없습니다.</target>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="ff3ca843a6395cdc7d40686539d66fc535a8aaed" translate="yes" xml:space="preserve">
          <source>Signals the end of options; the rest of the parameters are &amp;lt;pathspec&amp;gt; limiters.</source>
          <target state="translated">옵션의 끝을 알립니다. 나머지 매개 변수는 &amp;lt;pathspec&amp;gt; 리미터입니다.</target>
        </trans-unit>
        <trans-unit id="221dd464fe44b38e2417a0ae6570e07534a3d7ea" translate="yes" xml:space="preserve">
          <source>Signing annotated tags during import from within fast-import is not supported. Trying to include your own PGP/GPG signature is not recommended, as the frontend does not (easily) have access to the complete set of bytes which normally goes into such a signature. If signing is required, create lightweight tags from within fast-import with &lt;code&gt;reset&lt;/code&gt;, then create the annotated versions of those tags offline with the standard &lt;code&gt;git tag&lt;/code&gt; process.</source>
          <target state="translated">빠른 가져 오기 내에서 가져 오는 동안 주석이 달린 태그에 서명하는 것은 지원되지 않습니다. 프론트 엔드는 일반적으로 그러한 서명으로 들어가는 전체 바이트 세트에 액세스하지 않기 때문에 자신의 PGP / GPG 서명을 포함시키는 것은 권장되지 않습니다. 서명이 필요한 경우 &lt;code&gt;reset&lt;/code&gt; 을 사용하여 빠른 가져 오기 내에서 경량 태그 를 작성한 다음 표준 &lt;code&gt;git tag&lt;/code&gt; 프로세스를 사용하여 해당 태그의 주석이 달린 버전을 오프라인으로 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="e73ba37a846fd05171a6c58829f1ab0aa4e069d7" translate="yes" xml:space="preserve">
          <source>Silently overwrite ignored files from the merge result. This is the default behavior. Use &lt;code&gt;--no-overwrite-ignore&lt;/code&gt; to abort.</source>
          <target state="translated">병합 결과에서 무시 된 파일을 자동으로 덮어 씁니다. 이것이 기본 동작입니다. 중단 하려면 &lt;code&gt;--no-overwrite-ignore&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7ca941070a3e177fd03230132f7162630714492" translate="yes" xml:space="preserve">
          <source>Silently overwrite ignored files when switching branches. This is the default behavior. Use &lt;code&gt;--no-overwrite-ignore&lt;/code&gt; to abort the operation when the new branch contains ignored files.</source>
          <target state="translated">분기를 전환 할 때 무시 된 파일을 자동으로 덮어 씁니다. 이것이 기본 동작입니다. 새 분기에 무시 된 파일이 포함 된 경우 작업을 중단 하려면 &lt;code&gt;--no-overwrite-ignore&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ffd6334e8fa69c33df5ff56f9d3009483e17a61e" translate="yes" xml:space="preserve">
          <source>Similar to --depth, except it specifies the number of commits from the current shallow boundary instead of from the tip of each remote branch history.</source>
          <target state="translated">--depth와 비슷하지만 각 원격 분기 히스토리의 팁 대신 현재 얕은 경계에서 커밋 수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="16434785e2f2781f48016d9fab6f521e71729a0f" translate="yes" xml:space="preserve">
          <source>Similar to -u. But when re-coding, the charset specified here is used instead of the one specified by i18n.commitencoding or UTF-8.</source>
          <target state="translated">-u와 유사합니다. 그러나 다시 코딩 할 때 여기에 지정된 문자 세트는 i18n.commitencoding 또는 UTF-8에 지정된 문자 세트 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="35df8b1f29f7a7b94cf0adfb128190781a631c4c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;--create&lt;/code&gt; except that if &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; already exists, it will be reset to &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt;. This is a convenient shortcut for:</source>
          <target state="translated">&lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 가 이미 존재 하는 경우 &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; 로 재설정 된다는 점을 제외하고 &lt;code&gt;--create&lt;/code&gt; 와 유사합니다 . 다음과 같은 편리한 단축키입니다.</target>
        </trans-unit>
        <trans-unit id="a329dc4873c426988eca07322671d0e252450f5a" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;--file&lt;/code&gt; but use the given blob instead of a file. E.g. you can use &lt;code&gt;master:.gitmodules&lt;/code&gt; to read values from the file &lt;code&gt;.gitmodules&lt;/code&gt; in the master branch. See &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; for a more complete list of ways to spell blob names.</source>
          <target state="translated">유사합니다 &lt;code&gt;--file&lt;/code&gt; 하지만 파일 대신 주어진 방울을 사용합니다. 예를 들어 &lt;code&gt;master:.gitmodules&lt;/code&gt; 를 사용 하여 마스터 분기의 &lt;code&gt;.gitmodules&lt;/code&gt; 파일에서 값을 읽을 수 있습니다 . 블롭 이름을 철자하는 방법에 대한 전체 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]의&lt;/a&gt; &quot;수정 수정&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="96ae9e148f9a848728ba835436ff9b06a051bf18" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;--local&lt;/code&gt; except that &lt;code&gt;.git/config.worktree&lt;/code&gt; is read from or written to if &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; is present. If not it&amp;rsquo;s the same as &lt;code&gt;--local&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 가있는 경우 &lt;code&gt;.git/config.worktree&lt;/code&gt; 를 읽거나 쓰는 점을 제외하고 &lt;code&gt;--local&lt;/code&gt; 과 비슷합니다 . 그렇지 않은 경우 &lt;code&gt;--local&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="9921875dc5f741363cc389c12f0a866da77aa3f9" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;--objects-edge&lt;/code&gt;, but it tries harder to find excluded commits at the cost of increased time. This is used instead of &lt;code&gt;--objects-edge&lt;/code&gt; to build &amp;ldquo;thin&amp;rdquo; packs for shallow repositories.</source>
          <target state="translated">유사 &lt;code&gt;--objects-edge&lt;/code&gt; 하지만 시간이 증가의 비용을 제외 커밋을 찾기 위해 더 열심히하려고합니다. 얕은 리포지토리를위한 &quot;씬&quot;팩을 빌드하기 위해 &lt;code&gt;--objects-edge&lt;/code&gt; 대신 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="827a1dc116e1ce95f15ed3122df77ff565d151ab" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;--objects&lt;/code&gt;, but also print the IDs of excluded commits prefixed with a &amp;ldquo;-&amp;rdquo; character. This is used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; to build a &amp;ldquo;thin&amp;rdquo; pack, which records objects in deltified form based on objects contained in these excluded commits to reduce network traffic.</source>
          <target state="translated">유사 &lt;code&gt;--objects&lt;/code&gt; 뿐만 아니라 접두어 제외 커밋의 ID를 인쇄 &quot;-&quot;문자를. 이것은 &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt; 에서 &quot;thin&quot;팩을 작성하는 데 사용됩니다.이 팩은 네트워크 트래픽을 줄이기 위해 이러한 제외 된 커밋에 포함 된 객체를 기반으로 deltified 형식으로 객체를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="92613f50c8128533a943f904d4fab448ede98701" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;--show-origin&lt;/code&gt; in that it augments the output of all queried config options with the scope of that value (local, global, system, command).</source>
          <target state="translated">&lt;code&gt;--show-origin&lt;/code&gt; 과 유사하게 쿼리 된 모든 구성 옵션의 출력을 해당 값 (로컬, 글로벌, 시스템, 명령)의 범위로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="db4263bd2603c01331f2d853a8cad6132476aed7" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;--stat&lt;/code&gt;, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly. For binary files, outputs two &lt;code&gt;-&lt;/code&gt; instead of saying &lt;code&gt;0 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--stat&lt;/code&gt; 와 유사 하지만 더 기계 친화적으로 만들기 위해 추가 및 삭제 된 줄 수를 약어없이 10 진수 표기법과 경로 이름으로 표시합니다. 바이너리 파일의 경우, 두 개의 출력 &lt;code&gt;-&lt;/code&gt; 대신 말의 &lt;code&gt;0 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="507e19add19af137dd267ca439cffb2e494aaec7" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;--stat&lt;/code&gt;, but shows the number of added and deleted lines in decimal notation and the pathname without abbreviation, to make it more machine friendly. For binary files, outputs two &lt;code&gt;-&lt;/code&gt; instead of saying &lt;code&gt;0 0&lt;/code&gt;. Turns off &quot;apply&quot;.</source>
          <target state="translated">유사 &lt;code&gt;--stat&lt;/code&gt; 더 머신 친절하게,하지만 쇼 진수 표기법으로 추가 및 삭제 된 행의 수와 약어없이 경로 이름을. 바이너리 파일의 경우, 두 개의 출력 &lt;code&gt;-&lt;/code&gt; 대신 말의 &lt;code&gt;0 0&lt;/code&gt; . &quot;적용&quot;을 끕니다.</target>
        </trans-unit>
        <trans-unit id="cebb3f179c2f7afdfbf89dc9db3668db1b27ceee" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;-t&lt;/code&gt;, but use lowercase letters for files that are marked as &lt;code&gt;assume unchanged&lt;/code&gt; (see &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;).</source>
          <target state="translated">유사 &lt;code&gt;-t&lt;/code&gt; 으로 표시된 파일 만 사용 소문자 문자가 &lt;code&gt;assume unchanged&lt;/code&gt; (참조 &lt;a href=&quot;git-update-index&quot;&gt;자식 업데이트 색인을 [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c8a85313dff4970a1ca58c4ac403a9e5f1e1fd26" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;-t&lt;/code&gt;, but use lowercase letters for files that are marked as &lt;code&gt;fsmonitor valid&lt;/code&gt; (see &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; 와 유사 하지만 &lt;code&gt;fsmonitor valid&lt;/code&gt; 로 표시된 파일에 대해서는 소문자를 사용 하십시오 ( &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d753bc37a0732c319a3b637b8b9f6c853acf890c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;list&lt;/code&gt;, except that it is used if and only if the caller wants to the resulting ref list to prepare push commands. A helper supporting both push and fetch can use this to distinguish for which operation the output of &lt;code&gt;list&lt;/code&gt; is going to be used, possibly reducing the amount of work that needs to be performed.</source>
          <target state="translated">호출자가 푸시 명령을 준비하기 위해 결과 참조 목록을 원할 경우에만 사용된다는 점을 제외하고 &lt;code&gt;list&lt;/code&gt; 와 비슷 합니다. push 및 fetch를 모두 지원하는 도우미는이를 사용하여 &lt;code&gt;list&lt;/code&gt; 의 출력 이 사용될 작업을 구별하여 수행해야하는 작업량을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d877d80bc2ddec8772b0999fdcc01984ec807892" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;zebra&lt;/code&gt;, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. &lt;code&gt;dimmed_zebra&lt;/code&gt; is a deprecated synonym.</source>
          <target state="translated">&lt;code&gt;zebra&lt;/code&gt; 와 유사 하지만 이동 된 코드의 관심없는 부분에 대한 추가 디밍이 수행됩니다. 인접한 두 블록의 경계선은 흥미로운 것으로 간주되며 나머지는 흥미롭지 않습니다. &lt;code&gt;dimmed_zebra&lt;/code&gt; 는 더 이상 사용되지 않는 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="bf8bcfbd909889dac33d6d2f89b63bfd39d6ccea" translate="yes" xml:space="preserve">
          <source>Similar to Git&amp;rsquo;s &lt;code&gt;remote.&amp;lt;name&amp;gt;.pushurl&lt;/code&gt;, this key is designed to be used in cases where &lt;code&gt;url&lt;/code&gt; points to an SVN repository via a read-only transport, to provide an alternate read/write transport. It is assumed that both keys point to the same repository. Unlike &lt;code&gt;commiturl&lt;/code&gt;, &lt;code&gt;pushurl&lt;/code&gt; is a base path. If either &lt;code&gt;commiturl&lt;/code&gt; or &lt;code&gt;pushurl&lt;/code&gt; could be used, &lt;code&gt;commiturl&lt;/code&gt; takes precedence.</source>
          <target state="translated">Git의 &lt;code&gt;remote.&amp;lt;name&amp;gt;.pushurl&lt;/code&gt; 과 유사 하게이 키는 &lt;code&gt;url&lt;/code&gt; 이 읽기 전용 전송을 통해 SVN 저장소를 가리키는 경우 대체 읽기 / 쓰기 전송을 제공하기 위해 사용되도록 설계되었습니다 . 두 키가 동일한 리포지토리를 가리키는 것으로 가정합니다. 달리 &lt;code&gt;commiturl&lt;/code&gt; , &lt;code&gt;pushurl&lt;/code&gt; 는 기본 경로입니다. 어느 경우 &lt;code&gt;commiturl&lt;/code&gt; 또는 &lt;code&gt;pushurl&lt;/code&gt; 이 사용될 수 &lt;code&gt;commiturl&lt;/code&gt; 은 우선합니다.</target>
        </trans-unit>
        <trans-unit id="91682fd49c343f959bbb6403f6f6863feba84482" translate="yes" xml:space="preserve">
          <source>Similar to above:</source>
          <target state="translated">위와 비슷합니다 :</target>
        </trans-unit>
        <trans-unit id="e5c2486b9a7763634d7231fd9214964f9084de7d" translate="yes" xml:space="preserve">
          <source>Similar to the above, but Apache can be used to return static files that are stored on disk. On many systems this may be more efficient as Apache can ask the kernel to copy the file contents from the file system directly to the network:</source>
          <target state="translated">위와 비슷하지만 Apache를 사용하여 디스크에 저장된 정적 파일을 반환 할 수 있습니다. 많은 시스템에서 Apache가 커널에게 파일 시스템에서 파일 내용을 네트워크로 직접 복사하도록 요청할 수 있으므로이 방법이 더 효율적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5d7cb2c6d73b9150cefdf2e64e945bbe4a78cee" translate="yes" xml:space="preserve">
          <source>Similar to the apply backend, by default the merge backend drops commits that become empty unless -i/--interactive is specified (in which case it stops and asks the user what to do). The merge backend also has an --empty={drop,keep,ask} option for changing the behavior of handling commits that become empty.</source>
          <target state="translated">적용 백엔드와 유사하게, 기본적으로 병합 백엔드는 -i /-interactive가 지정되지 않는 한 비어있는 커밋을 삭제합니다 (이 경우 중지하고 사용자에게 수행 할 작업을 요청 함). 병합 백엔드에는 비어있는 커밋 처리 동작을 변경하기위한 --empty = {drop, keep, ask} 옵션도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d010174e63754716183c2af28e1291061e29078" translate="yes" xml:space="preserve">
          <source>Similar to the useSvmProps option; this is for users of the svnsync(1) command distributed with SVN 1.4.x and later.</source>
          <target state="translated">useSvmProps 옵션과 유사합니다. 이것은 SVN 1.4.x 이상과 함께 배포 된 svnsync (1) 명령 사용자를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="742718eb04c74d19e18742babbe16ee5d5955f76" translate="yes" xml:space="preserve">
          <source>Similar to the useSvmProps option; this is for users who need to remap the UUID manually. This may be useful in situations where the original UUID is not available via either useSvmProps or useSvnsyncProps.</source>
          <target state="translated">useSvmProps 옵션과 유사합니다. UUID를 수동으로 다시 매핑해야하는 사용자를위한 것입니다. useSvmProps 또는 useSvnsyncProps를 통해 원래 UUID를 사용할 수없는 상황에서 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b4ceb453e6bfcacc89ab013230d146d7c2efc84" translate="yes" xml:space="preserve">
          <source>Similar to two-line header for traditional &lt;code&gt;unified&lt;/code&gt; diff format, &lt;code&gt;/dev/null&lt;/code&gt; is used to signal created or deleted files.</source>
          <target state="translated">전통적인 &lt;code&gt;unified&lt;/code&gt; diff 형식의 2 줄 헤더와 유사하게 &lt;code&gt;/dev/null&lt;/code&gt; 은 생성되거나 삭제 된 파일을 알리는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9acea96e7cbe682e6caa9d2b57eedce27f5ebab4" translate="yes" xml:space="preserve">
          <source>Similarly, for a maintenance release, &lt;code&gt;maint&lt;/code&gt; is tracking the commits to be released. Therefore, in the steps above simply tag and push &lt;code&gt;maint&lt;/code&gt; rather than &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 유지 관리 릴리스의 경우 &lt;code&gt;maint&lt;/code&gt; 은 해제 될 커밋을 추적합니다. 따라서 위의 단계에서 &lt;code&gt;master&lt;/code&gt; 대신 &lt;code&gt;maint&lt;/code&gt; 를 태그하고 푸시하십시오 .</target>
        </trans-unit>
        <trans-unit id="8638660115fa0755b6d41e0f65af85c161534425" translate="yes" xml:space="preserve">
          <source>Similarly, if a linked working tree is moved without using &lt;code&gt;git worktree
move&lt;/code&gt;, the main working tree (or bare repository) will be unable to locate it. Running &lt;code&gt;repair&lt;/code&gt; within the recently-moved working tree will reestablish the connection. If multiple linked working trees are moved, running &lt;code&gt;repair&lt;/code&gt; from any working tree with each tree&amp;rsquo;s new &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; as an argument, will reestablish the connection to all the specified paths.</source>
          <target state="translated">마찬가지로 &lt;code&gt;git worktree move&lt;/code&gt; 를 사용하지 않고 연결된 작업 트리를 이동 하면 기본 작업 트리 (또는 베어 저장소)에서 찾을 수 없습니다. 최근 이동 한 작업 트리 내에서 &lt;code&gt;repair&lt;/code&gt; 실행 하면 연결이 다시 설정됩니다. 여러 개의 연결된 작업 트리가 이동되면 각 트리의 새 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 를 인수로 사용하여 작업 트리에서 &lt;code&gt;repair&lt;/code&gt; 를 실행 하면 지정된 모든 경로에 대한 연결이 다시 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7f4a6323889bb06df07efb39ac02d863fb790808" translate="yes" xml:space="preserve">
          <source>Similarly, no more helpers will be consulted once both username and password had been provided.</source>
          <target state="translated">마찬가지로 사용자 이름과 암호가 모두 제공되면 더 이상 도우미에게 문의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8cf6e3fc26d2562fdbc09f3e09e2deb878c7a85" translate="yes" xml:space="preserve">
          <source>Similarly, when moving files around, one can find that filenames with non-ascii or special characters end up in a different directory, one that includes a double quote character. (This is technically the same issue as above with quoting, but perhaps an interesting different way that it can and has manifested as a problem.)</source>
          <target state="translated">마찬가지로, 파일을 이동할 때 ASCII가 아닌 문자 나 특수 문자가있는 파일 이름은 큰 따옴표 문자가 포함 된 다른 디렉토리에있게됩니다. (이것은 기술적으로 위에서 인용 한 것과 같은 문제이지만 아마도 문제로 나타날 수 있고 흥미로운 다른 방법 일 것입니다.)</target>
        </trans-unit>
        <trans-unit id="47fa1a83138cf11ea34d19a92cc77db11eb4b97c" translate="yes" xml:space="preserve">
          <source>Similarly, when the &quot;recursive&quot; merge strategy runs, and finds that there are criss-cross merges and thus more than one merge base (which is fairly unusual, but it does happen), it will generate one temporary midway tree (or possibly even more, if you had lots of criss-crossing merges and more than two merge bases) as a temporary internal merge base, and again, those are real objects, but the end result will not end up pointing to them, so they end up &quot;dangling&quot; in your repository.</source>
          <target state="translated">마찬가지로 &quot;재귀 적&quot;병합 전략이 실행되고 십자형 병합이 있고 둘 이상의 병합 기반이있는 것을 발견하면 (이것은 매우 드문 일이지만 발생합니다) 임시 중간 중간 트리 (또는 가능할 수도 있음)를 생성합니다 또한 임시 내부 병합 기준으로 많은 교차 교차 병합과 2 개 이상의 병합 기준이있는 경우) 실제 객체이지만 최종 결과는이를 가리 키지 않으므로 &quot; 저장소에 매달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="50765cb4cf598285ffabcacb2eda47bdf85bbc67" translate="yes" xml:space="preserve">
          <source>Similarly, you need only trust the SHA-1 name of a top-level tree object to trust the contents of the entire directory that it refers to, and if you receive the SHA-1 name of a commit from a trusted source, then you can easily verify the entire history of commits reachable through parents of that commit, and all of those contents of the trees referred to by those commits.</source>
          <target state="translated">마찬가지로 최상위 트리 개체의 SHA-1 이름 만 신뢰하면 참조하는 전체 디렉토리의 내용을 신뢰하고 신뢰할 수있는 소스로부터 커밋의 SHA-1 이름을 수신하면 해당 커밋의 부모 및 해당 커밋이 참조하는 트리의 모든 내용을 통해 도달 가능한 커밋의 전체 기록을 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35267477ddadd32e54d2580eaf5f6347904aefaa" translate="yes" xml:space="preserve">
          <source>Simple UNIX mbox splitter program</source>
          <target state="translated">간단한 유닉스 mbox 스플리터 프로그램</target>
        </trans-unit>
        <trans-unit id="e6081dd40a736a561294c958c5f476bf808af40b" translate="yes" xml:space="preserve">
          <source>Simplifies the history to the simplest history explaining the final state of the tree. Simplest because it prunes some side branches if the end result is the same (i.e. merging branches with the same content)</source>
          <target state="translated">트리의 최종 상태를 설명하는 가장 간단한 히스토리로 히스토리를 단순화합니다. 최종 결과가 동일한 경우 일부 사이드 브랜치를 제거하므로 가장 간단합니다 (예 : 동일한 컨텐츠의 브랜치 병합)</target>
        </trans-unit>
        <trans-unit id="7d47a55c52a010c445880763e4c0c53ec8d956ef" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;dcommit&lt;/code&gt; uses rebase internally, any Git branches you &lt;code&gt;git push&lt;/code&gt; to before &lt;code&gt;dcommit&lt;/code&gt; on will require forcing an overwrite of the existing ref on the remote repository. This is generally considered bad practice, see the &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; documentation for details.</source>
          <target state="translated">&lt;code&gt;dcommit&lt;/code&gt; 은 내부적으로 rebase를 사용 하므로 dcommit 을 시작하기 전에 &lt;code&gt;git push&lt;/code&gt; 를 사용 하는 원격 Git 브랜치 는 원격 리포지토리의 기존 참조를 덮어 &lt;code&gt;dcommit&lt;/code&gt; 합니다. 이것은 일반적으로 나쁜 습관으로 간주됩니다. 자세한 내용은 &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d3cbf9539838f097e44d7366548fff10dd5a4bb6" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;git fast-import&lt;/code&gt; cannot tag trees, you will not be able to export the linux.git repository completely, as it contains a tag referencing a tree instead of a commit.</source>
          <target state="translated">때문에 &lt;code&gt;git fast-import&lt;/code&gt; 대신 커밋의 나무를 참조하는 태그가 포함로 할 수없는 태그 나무, 당신은 완전히 linux.git 저장소를 내보낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e8a0aceddf81ac41c98d5a8bdbe00960df868272" translate="yes" xml:space="preserve">
          <source>Since every developer&amp;rsquo;s repository has the same complete copy of the project history, no repository is special, and it is trivial for another developer to take over maintenance of a project, either by mutual agreement, or because a maintainer becomes unresponsive or difficult to work with.</source>
          <target state="translated">모든 개발자의 저장소에는 동일한 프로젝트 히스토리 사본이 있으므로 저장소는 특별하지 않으며 다른 개발자가 상호 합의에 의해 또는 유지 보수 담당자가 응답하지 않거나 작업하기가 어렵 기 때문에 프로젝트 유지 보수를 인수하는 것이 쉽지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="ff45ae2cc9973e736a0612a33b064d4efb949c7a" translate="yes" xml:space="preserve">
          <source>Since keeping up-to-date with both branches and tags on the remote is a common use-case the &lt;code&gt;--prune-tags&lt;/code&gt; option can be supplied along with &lt;code&gt;--prune&lt;/code&gt; to prune local tags that don&amp;rsquo;t exist on the remote, and force-update those tags that differ. Tag pruning can also be enabled with &lt;code&gt;fetch.pruneTags&lt;/code&gt; or &lt;code&gt;remote.&amp;lt;name&amp;gt;.pruneTags&lt;/code&gt; in the config. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">원격에서 브랜치와 태그를 모두 최신 상태로 유지하는 것이 일반적인 사용 사례 &lt;code&gt;--prune-tags&lt;/code&gt; 옵션을 &lt;code&gt;--prune&lt;/code&gt; 과 함께 제공 하여 원격에 존재하지 않는 로컬 태그를 제거 할 수 있습니다. 다른 태그를 강제 업데이트하십시오. 구성에서 &lt;code&gt;fetch.pruneTags&lt;/code&gt; 또는 &lt;code&gt;remote.&amp;lt;name&amp;gt;.pruneTags&lt;/code&gt; 를 사용하여 태그 제거를 활성화 할 수도 있습니다 . &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0932a869e1657064106036f8682ab82f7b34c539" translate="yes" xml:space="preserve">
          <source>Since object names are computed the same way in every repository, the same content stored in two repositories will always be stored under the same name.</source>
          <target state="translated">객체 이름은 모든 리포지토리에서 동일한 방식으로 계산되므로 두 리포지토리에 저장된 동일한 컨텐츠는 항상 동일한 이름으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="bea459735363a6dcc4076e4ad600cb49ce5e1876" translate="yes" xml:space="preserve">
          <source>Since submodules may have unpushed changes or untracked files, removing them could result in data loss. Thus, changing sparse inclusion/exclusion rules will not cause an already checked out submodule to be removed from the working copy. Said another way, just as &lt;code&gt;checkout&lt;/code&gt; will not cause submodules to be automatically removed or initialized even when switching between branches that remove or add submodules, using &lt;code&gt;sparse-checkout&lt;/code&gt; to reduce or expand the scope of &quot;interesting&quot; files will not cause submodules to be automatically deinitialized or initialized either.</source>
          <target state="translated">하위 모듈에 푸시되지 않은 변경 사항이나 추적되지 않은 파일이있을 수 있으므로 제거하면 데이터가 손실 될 수 있습니다. 따라서 스파 스 포함 / 제외 규칙을 변경해도 이미 체크 아웃 된 하위 모듈이 작업 복사본에서 제거되지는 않습니다. 다시 말하면, &lt;code&gt;checkout&lt;/code&gt; 인해 하위 모듈을 제거하거나 추가하는 분기간에 전환 할 때에도 하위 모듈이 자동으로 제거되거나 초기화되지 않는 것처럼 &lt;code&gt;sparse-checkout&lt;/code&gt; 을 사용하여 &quot;관심있는&quot;파일의 범위를 줄이거 나 확장해도 하위 모듈이 자동으로 발생하지 않습니다. 초기화되지 않았거나 초기화되었습니다.</target>
        </trans-unit>
        <trans-unit id="c6783a475fdc4e2463b00ffd216c9d8a1b41c5ce" translate="yes" xml:space="preserve">
          <source>Since the blob is entirely defined by its data, if two files in a directory tree (or in multiple different versions of the repository) have the same contents, they will share the same blob object. The object is totally independent of its location in the directory tree, and renaming a file does not change the object that file is associated with.</source>
          <target state="translated">BLOB는 데이터에 의해 완전히 정의되므로 디렉토리 트리 (또는 여러 다른 버전의 저장소)에있는 두 파일의 내용이 동일한 경우 동일한 Blob 오브젝트를 공유합니다. 객체는 디렉토리 트리에서의 위치와 완전히 독립적이며 파일 이름을 바꾸더라도 파일과 관련된 객체는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3fb22d6e6da288d244e8acdd9955bf43f0ad8d0" translate="yes" xml:space="preserve">
          <source>Since the current state of closing.txt is cached in the index file, it is listed as &quot;Changes to be committed&quot;. Since file.txt has changes in the working directory that aren&amp;rsquo;t reflected in the index, it is marked &quot;changed but not updated&quot;. At this point, running &quot;git commit&quot; would create a commit that added closing.txt (with its new contents), but that didn&amp;rsquo;t modify file.txt.</source>
          <target state="translated">닫기 .txt의 현재 상태가 인덱스 파일에 캐시되므로 &quot;커밋 변경 사항&quot;으로 표시됩니다. file.txt에는 작업 디렉토리에서 색인에 반영되지 않은 변경 사항이 있으므로 &quot;변경되었지만 업데이트되지 않음&quot;으로 표시됩니다. 이 시점에서 &quot;git commit&quot;을 실행하면 새 내용과 함께 closing.txt를 추가했지만 file.txt를 수정하지 않은 커밋이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="78b19ba60aba5b2f618c3990a75d2fca7411595a" translate="yes" xml:space="preserve">
          <source>Since the noMetadata, rewriteRoot, rewriteUUID, useSvnsyncProps and useSvmProps options all affect the metadata generated and used by &lt;code&gt;git svn&lt;/code&gt;; they &lt;strong&gt;must&lt;/strong&gt; be set in the configuration file before any history is imported and these settings should never be changed once they are set.</source>
          <target state="translated">noMetadata, rewriteRoot, rewriteUUID, useSvnsyncProps 및 useSvmProps 옵션은 모두 &lt;code&gt;git svn&lt;/code&gt; 에서 생성하고 사용하는 메타 데이터에 영향을줍니다 . 그들은 &lt;strong&gt;있어야&lt;/strong&gt; 어떤 역사를 가져 오기 전에 구성 파일에 설정하고이 설정되면이 설정은 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6c0fcca9337c1cb048efaf57760c6fdc1a7b6b6f" translate="yes" xml:space="preserve">
          <source>Singe line category of a project, used to group projects if &lt;code&gt;$projects_list_group_categories&lt;/code&gt; is enabled. By default (file and configuration variable absent), uncategorized projects are put in the &lt;code&gt;$project_list_default_category&lt;/code&gt; category. You can use the &lt;code&gt;gitweb.category&lt;/code&gt; repo configuration variable, but the file takes precedence.</source>
          <target state="translated">&lt;code&gt;$projects_list_group_categories&lt;/code&gt; 가 활성화 된 경우 프로젝트의 단일 라인 범주로 프로젝트를 그룹화하는 데 사용됩니다 . 기본적으로 (파일 및 구성 변수가 없음) 분류되지 않은 프로젝트는 &lt;code&gt;$project_list_default_category&lt;/code&gt; 범주에 배치됩니다. &lt;code&gt;gitweb.category&lt;/code&gt; repo 구성 변수를 사용할 수 있지만 파일이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="1622ee3a3548a98ace63f4a1f20c802cbd3d6865" translate="yes" xml:space="preserve">
          <source>Single Tree Merge</source>
          <target state="translated">단일 트리 병합</target>
        </trans-unit>
        <trans-unit id="68fe6fe857d1a576bbea2c5ba543ec91391124bd" translate="yes" xml:space="preserve">
          <source>Single URL for gitweb and for fetching</source>
          <target state="translated">gitweb과 페칭을위한 단일 URL</target>
        </trans-unit>
        <trans-unit id="c63aa67778ae9fde52963fd98eabefccd9f535ba" translate="yes" xml:space="preserve">
          <source>Size of the Git repository: In its current form Git scales up poorly for large repositories containing content that is not compressed by delta computation between trees. For example, you can use submodules to hold large binary assets and these repositories can be shallowly cloned such that you do not have a large history locally.</source>
          <target state="translated">Git 리포지토리의 크기 : 현재 형태에서 Git은 트리 간의 델타 계산에 의해 압축되지 않은 내용을 포함하는 큰 리포지토리에 대해 제대로 확장되지 않습니다. 예를 들어 하위 모듈을 사용하여 큰 이진 자산을 보유 할 수 있으며 이러한 리포지토리는 얕게 복제되어 로컬로 큰 기록이 없습니다.</target>
        </trans-unit>
        <trans-unit id="109e0b1e1d08be0f664fabdbefc14a841a52fd41" translate="yes" xml:space="preserve">
          <source>Skip &quot;branches&quot; and &quot;tags&quot; of first level directories</source>
          <target state="translated">첫 번째 레벨 디렉토리의 &quot;분기&quot;및 &quot;태그&quot;건너 뛰기</target>
        </trans-unit>
        <trans-unit id="89ac85d0525bb0b20e17b8b50eb25e661e2c2664" translate="yes" xml:space="preserve">
          <source>Skip &quot;doc*&quot; directory for every fetch</source>
          <target state="translated">가져올 때마다 &quot;doc *&quot;디렉토리를 건너 뛰십시오.</target>
        </trans-unit>
        <trans-unit id="160b3d2c26cf27627f75b323f1f2f273b38eb0f3" translate="yes" xml:space="preserve">
          <source>Skip &lt;code&gt;number&lt;/code&gt; commits before starting to show the commit output.</source>
          <target state="translated">커밋 출력 표시를 시작하기 전에 &lt;code&gt;number&lt;/code&gt; 커밋을 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="143f0d9f0b5891b48ad38fad90174c475ab3d608" translate="yes" xml:space="preserve">
          <source>Skip algorithm</source>
          <target state="translated">알고리즘 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="fd9da89bf39cfad867f423a79c66781ba5934141" translate="yes" xml:space="preserve">
          <source>Skip algorithm discussed</source>
          <target state="translated">알고리즘 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="e6458f822412c73c4c309bd3d568b1a062547077" translate="yes" xml:space="preserve">
          <source>Skip and remove all lines starting with comment character (default &lt;code&gt;#&lt;/code&gt;).</source>
          <target state="translated">주석 문자로 시작하는 모든 줄을 건너 뛰고 제거하십시오 (기본값 &lt;code&gt;#&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8d0905b7d9c2aadf471da8a0572104f192b6463b" translate="yes" xml:space="preserve">
          <source>Skip move or rename actions which would lead to an error condition. An error happens when a source is neither existing nor controlled by Git, or when it would overwrite an existing file unless &lt;code&gt;-f&lt;/code&gt; is given.</source>
          <target state="translated">오류 조건으로 이어질 이동 또는 이름 바꾸기 작업을 건너 뜁니다. 소스가 존재하지 않거나 Git에 의해 제어되지 않거나 &lt;code&gt;-f&lt;/code&gt; 를 지정 하지 않으면 기존 파일을 덮어 쓰는 경우 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="93791f01919fc21e7203f6ad13249cb4adbabc2c" translate="yes" xml:space="preserve">
          <source>Skip output of blob objects and instead refer to blobs via their original SHA-1 hash. This is useful when rewriting the directory structure or history of a repository without touching the contents of individual files. Note that the resulting stream can only be used by a repository which already contains the necessary objects.</source>
          <target state="translated">얼룩 개체의 출력을 건너 뛰고 대신 원래 SHA-1 해시를 통해 얼룩을 참조합니다. 개별 파일의 내용을 건드리지 않고 디렉토리 구조 또는 저장소의 히스토리를 다시 작성할 때 유용합니다. 결과 스트림은 필요한 오브젝트가 이미 포함 된 저장소에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3704502c09a46589e3fc638d0b7431bdbfb4de69" translate="yes" xml:space="preserve">
          <source>Skip paths matching the regex.</source>
          <target state="translated">정규식과 일치하는 경로를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="8024d787464bdc42cf9e1692fcecd2225427e388" translate="yes" xml:space="preserve">
          <source>Skip the current commit and continue with the rest of the sequence.</source>
          <target state="translated">현재 커밋을 건너 뛰고 나머지 시퀀스를 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="8b89cae0a7a7a1a500c597f44f79f240ec0b9f01" translate="yes" xml:space="preserve">
          <source>Skip the current patch. This is only meaningful when restarting an aborted patch.</source>
          <target state="translated">현재 패치를 건너 뜁니다. 중단 된 패치를 다시 시작할 때만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="37f2142ef251b529e2961f797b73a85bc8215244" translate="yes" xml:space="preserve">
          <source>Skip the first &amp;lt;nn&amp;gt; numbers, for example if -f3 is specified, start the numbering with 0004.</source>
          <target state="translated">첫 번째 &amp;lt;nn&amp;gt; 숫자를 건너 뜁니다 (예 : -f3이 지정된 경우 0004로 번호 매기기 시작).</target>
        </trans-unit>
        <trans-unit id="53b34cae8fb29a9d928b4eaf4c1d1171200a7cd2" translate="yes" xml:space="preserve">
          <source>Skip untracked files matching pattern. Note that pattern is a shell wildcard pattern. See EXCLUDE PATTERNS below for more information.</source>
          <target state="translated">추적되지 않은 파일 일치 패턴을 건너 뜁니다. 패턴은 쉘 와일드 카드 패턴입니다. 자세한 내용은 아래의 제외 패턴을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5c514bc7b54c5d446f341bd390aa604bcfe7a779" translate="yes" xml:space="preserve">
          <source>Skip-worktree bit</source>
          <target state="translated">스킵 워크 트리 비트</target>
        </trans-unit>
        <trans-unit id="1c6f4418b45f18f2276258a670ff4fb3ee82370c" translate="yes" xml:space="preserve">
          <source>Skip-worktree bit can be defined in one (long) sentence: When reading an entry, if it is marked as skip-worktree, then Git pretends its working directory version is up to date and read the index version instead.</source>
          <target state="translated">건너 뛰기 작업 트리 비트는 하나의 긴 문장으로 정의 할 수 있습니다. 항목을 읽을 때 건너 뛰기 작업 트리로 표시되면 Git은 작업 디렉토리 버전이 최신 인 것으로 가정하고 대신 인덱스 버전을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="497781ce21708a17d4e26d12bd089a723d673b06" translate="yes" xml:space="preserve">
          <source>So &quot;git bisect&quot; is designed to help find a &quot;first bad commit&quot;. And to be as efficient as possible, it tries to perform a binary search.</source>
          <target state="translated">따라서 &quot;git bisect&quot;는 &quot;첫 번째 잘못된 커밋&quot;을 찾는 데 도움이되도록 설계되었습니다. 그리고 가능한 효율적으로 이진 검색을 수행하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="2f63b69e28337cf529c035b03d9daaf28859996c" translate="yes" xml:space="preserve">
          <source>So &lt;code&gt;git diff&lt;/code&gt; is comparing against something other than the head. The thing that it&amp;rsquo;s comparing against is actually the index file, which is stored in .git/index in a binary format, but whose contents we can examine with ls-files:</source>
          <target state="translated">그래서 &lt;code&gt;git diff&lt;/code&gt; 머리가 아닌 다른 뭔가에 대해 비교된다. 비교하는 것은 실제로 이진 형식으로 .git / index에 저장되지만 ls-files로 내용을 검사 할 수있는 색인 파일입니다.</target>
        </trans-unit>
        <trans-unit id="87fbbf25154de6df0238ad0568533ed6007a8d44" translate="yes" xml:space="preserve">
          <source>So a good work-flow should be designed around the above points. That is making bisecting easier, more useful and standard.</source>
          <target state="translated">따라서 위의 점을 중심으로 좋은 작업 흐름을 설계해야합니다. 그것은 이등분을보다 쉽고 유용하며 표준으로 만들고 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe9010d034fcf65a3dd663b44598da34c322ed58" translate="yes" xml:space="preserve">
          <source>So be careful when using this with a refspec like &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt;, or any other refspec which might map references from multiple remotes to the same local namespace.</source>
          <target state="translated">따라서 이것을 &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; 와 같은 refspec과 함께 사용할 때 또는 여러 리모트에서 참조를 동일한 로컬 네임 스페이스에 맵핑 할 수있는 다른 refspec 과 함께 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b170fc73b3dfabca43a4cde5eef61bd350b47e1" translate="yes" xml:space="preserve">
          <source>So by default &lt;code&gt;git commit&lt;/code&gt; uses the index to create the commit, not the working tree; the &quot;-a&quot; option to commit tells it to first update the index with all changes in the working tree.</source>
          <target state="translated">따라서 기본적으로 &lt;code&gt;git commit&lt;/code&gt; 은 인덱스를 사용하여 작업 트리가 아닌 커밋을 만듭니다. 커밋하는 &quot;-a&quot;옵션은 먼저 작업 트리의 모든 변경 사항으로 인덱스를 업데이트하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="f86c14eb732dcf1c0bad37f2fc6a2cc528890e0c" translate="yes" xml:space="preserve">
          <source>So doing a &lt;code&gt;git diff-index --cached&lt;/code&gt; is basically very useful when you are asking yourself &quot;what have I already marked for being committed, and what&amp;rsquo;s the difference to a previous tree&quot;.</source>
          <target state="translated">&lt;code&gt;git diff-index --cached&lt;/code&gt; 를 수행하는 것은 &quot;내가 이미 커밋 된 것으로 표시 한 것과 이전 트리와의 차이점&quot;을 스스로에게 물어볼 때 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d45f632df019622532eb259f26fdc9a9f2411148" translate="yes" xml:space="preserve">
          <source>So for example when &lt;code&gt;--thread&lt;/code&gt; and &lt;code&gt;--no-chain-reply-to&lt;/code&gt; are specified, the second and subsequent patches will be replies to the first one like in the illustration below where &lt;code&gt;[PATCH v2 0/3]&lt;/code&gt; is in reply to &lt;code&gt;[PATCH 0/2]&lt;/code&gt;:</source>
          <target state="translated">예를 들어 &lt;code&gt;--thread&lt;/code&gt; 및 &lt;code&gt;--no-chain-reply-to&lt;/code&gt; 를 지정하면 두 번째 및 이후 패치는 아래 그림과 같이 &lt;code&gt;[PATCH v2 0/3]&lt;/code&gt; 이 &lt;code&gt;[PATCH 0/2]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8dac83a478835c1820a1dc8da47f73a69f302106" translate="yes" xml:space="preserve">
          <source>So git bisect is unconditional goodness - and feel free to quote that ;-)</source>
          <target state="translated">따라서 git bisect는 무조건적 선하심입니다.</target>
        </trans-unit>
        <trans-unit id="9a21b5de38126daf9f68802ae918237cb622de11" translate="yes" xml:space="preserve">
          <source>So if there is no bad merge base, the bisection process continues as usual after this step.</source>
          <target state="translated">따라서 잘못된 병합 기준이 없으면이 단계 후에도 정상적으로 이분법 프로세스가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="d61ad44b1ad1935830d69abe827279c6ac721854" translate="yes" xml:space="preserve">
          <source>So if we could just &quot;replace&quot; Z by Z' when we bisect, then we would not need to add anything to a script. It would just work for anyone in the project sharing the special branches and the replacements.</source>
          <target state="translated">따라서 이등분 할 때 Z를 Z로 '바꿀'수 있다면 스크립트에 아무것도 추가 할 필요가 없습니다. 특별한 브랜치와 교체를 공유하는 프로젝트의 모든 사람에게 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="6be137f4b3e3bebc88bcbf9a9fd9420c4009228f" translate="yes" xml:space="preserve">
          <source>So if you know how to create test cases and how to bisect, you will be subject to a virtuous circle:</source>
          <target state="translated">따라서 테스트 사례를 만드는 방법과 이등분하는 방법을 알고 있다면 선순환이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b28d1446f9340641647b1bfa92704042d040df77" translate="yes" xml:space="preserve">
          <source>So if you used &quot;git bisect skip&quot; (or the run script exited with special code 125) you could get a result like this:</source>
          <target state="translated">따라서 &quot;git bisect skip&quot;(또는 특수 코드 125로 종료 된 실행 스크립트)을 사용하면 다음과 같은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edcb1ada2530409c42369421497ba8e78619bff1" translate="yes" xml:space="preserve">
          <source>So in the above example the best bisection point is commit C.</source>
          <target state="translated">위의 예에서 가장 좋은이 분점은 커밋 C입니다.</target>
        </trans-unit>
        <trans-unit id="6fdeecf50af4098d1933aa89ebcede0a8177561f" translate="yes" xml:space="preserve">
          <source>So in the end this means that to find the best bisection commits we should maximize the function:</source>
          <target state="translated">결국 이것은 최고의 bisection commit을 찾으려면 함수를 최대화해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="58a2f1d134fdcd7a3743e88aa224e9253e6fbd42" translate="yes" xml:space="preserve">
          <source>So it is a fact that commits near an untestable commit have a high probability of being untestable themselves. And the best bisection commits are often found together too (due to the bisection algorithm).</source>
          <target state="translated">따라서 테스트 할 수없는 커밋 근처의 커밋은 테스트 할 수없는 확률이 높습니다. 그리고 최고의 이분법 커밋은 종종 (이분법 알고리즘으로 인해) 함께 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="aa016e179ca75d2a0eb71de197505264fa3225e9" translate="yes" xml:space="preserve">
          <source>So now we know how Git uses the object database to represent a project&amp;rsquo;s history:</source>
          <target state="translated">이제 Git이 오브젝트 데이터베이스를 사용하여 프로젝트 히스토리를 나타내는 방법을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="ce2a816c8c6bc197cebf7da353940391ec82e2e3" translate="yes" xml:space="preserve">
          <source>So now you know that the missing blob was the data for a file named &lt;code&gt;myfile&lt;/code&gt;. And chances are you can also identify the directory&amp;mdash;​let&amp;rsquo;s say it&amp;rsquo;s in &lt;code&gt;somedirectory&lt;/code&gt;. If you&amp;rsquo;re lucky the missing copy might be the same as the copy you have checked out in your working tree at &lt;code&gt;somedirectory/myfile&lt;/code&gt;; you can test whether that&amp;rsquo;s right with &lt;a href=&quot;git-hash-object&quot;&gt;git-hash-object[1]&lt;/a&gt;:</source>
          <target state="translated">이제 누락 된 얼룩이 &lt;code&gt;myfile&lt;/code&gt; 이라는 파일의 데이터라는 것을 알았습니다 . 또한 디렉토리를 식별 할 수도 있습니다. 디렉토리가 &lt;code&gt;somedirectory&lt;/code&gt; 에 있다고 가정 해 봅시다 . 운이 좋으면 누락 된 사본은 작업 트리에서 &lt;code&gt;somedirectory/myfile&lt;/code&gt; 의 체크 아웃 한 사본과 동일 할 수 있습니다 . &lt;a href=&quot;git-hash-object&quot;&gt;git-hash-object [1] 사용&lt;/a&gt; 하여 올바른지 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02795e1f800cead1112ee5200f5eaf14f8868f55" translate="yes" xml:space="preserve">
          <source>So of course it&amp;rsquo;s much better as it&amp;rsquo;s O(N * T) vs O(N * T * M) if you would test everything after each commit.</source>
          <target state="translated">물론 각 커밋 후에 모든 것을 테스트한다면 O (N * T) 대 O (N * T * M)이므로 훨씬 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bf839044c5c4761411ba28111f62e6182a819140" translate="yes" xml:space="preserve">
          <source>So only the W and B commits will be kept. Because commits X and Y will have been removed by rules a) and b) respectively, and because commits G are removed by rule b) too.</source>
          <target state="translated">따라서 W 및 B 커밋 만 유지됩니다. 커밋 X와 Y는 각각 규칙 a)와 b)에 의해 제거되고 커밋 G도 규칙 b)에 의해 제거되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2adeb678ade18152fba70f98a363a63cf540c6c1" translate="yes" xml:space="preserve">
          <source>So regressions are fought all the time by developers, and indeed it is well known that bugs should be fixed as soon as possible, so as soon as they are found. That&amp;rsquo;s why it is interesting to have good tools for this purpose.</source>
          <target state="translated">따라서 회귀는 개발자가 항상 싸워야하며 실제로 버그는 가능한 빨리 수정해야한다는 것이 잘 알려져 있습니다. 그렇기 때문에이 목적을 위해 좋은 도구를 사용하는 것이 흥미 롭습니다.</target>
        </trans-unit>
        <trans-unit id="e3329398bcdff474dec989568418215901207762" translate="yes" xml:space="preserve">
          <source>So test suites and &quot;git bisect&quot; are complementary tools that are very powerful and efficient when used together.</source>
          <target state="translated">따라서 테스트 스위트와 &quot;git bisect&quot;는 함께 사용할 때 매우 강력하고 효율적인 보완 도구입니다.</target>
        </trans-unit>
        <trans-unit id="af6a5f3f7d1b778946d7ea3d80d407ba283ecbfd" translate="yes" xml:space="preserve">
          <source>So the algorithm used by &quot;git bisect&quot; to find the best bisection commit when there are no skipped commits is the following:</source>
          <target state="translated">따라서 건너 뛴 커밋이 없을 때 최상의 bisection 커밋을 찾기 위해 &quot;git bisect&quot;에서 사용하는 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d52372a3732a9693c38928f4af80ece55caba390" translate="yes" xml:space="preserve">
          <source>So the current algorithm seems to be the best possible given what we initially supposed.</source>
          <target state="translated">따라서 현재의 알고리즘은 우리가 처음에 생각한 것을 고려할 때 가장 좋은 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="ff070bb5b96ce6bdea0ee7e21e6149356aab622c" translate="yes" xml:space="preserve">
          <source>So the ideal is usually to produce a series of patches such that:</source>
          <target state="translated">따라서 이상적인 것은 일반적으로 다음과 같은 일련의 패치를 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a9929fd0a7cc637ffed9aa6825e45ac8df015448" translate="yes" xml:space="preserve">
          <source>So to help people find commits that introduce a &quot;bad&quot; behavior, the &quot;git bisect&quot; set of commands was invented. And it follows of course that in &quot;git bisect&quot; parlance, commits where the &quot;interesting behavior&quot; is present are called &quot;bad&quot; commits, while other commits are called &quot;good&quot; commits. And a commit that introduce the behavior we are interested in is called a &quot;first bad commit&quot;. Note that there could be more than one &quot;first bad commit&quot; in the commit space we are searching.</source>
          <target state="translated">따라서 사람들이 &quot;나쁜&quot;행동을 유발하는 커밋을 찾을 수 있도록 &quot;git bisect&quot;명령 세트가 개발되었습니다. 그리고 &quot;git bisect&quot;용어에서 &quot;흥미로운 행동&quot;이 존재하는 커밋은 &quot;나쁜&quot;커밋이라고하고 다른 커밋은 &quot;좋은&quot;커밋이라고합니다. 그리고 우리가 관심있는 행동을 소개하는 커밋을 &quot;첫 번째 나쁜 커밋&quot;이라고합니다. 검색중인 커밋 공간에 둘 이상의 &quot;첫 번째 잘못된 커밋&quot;이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15c2cfea7209fe12c9a7f928eefdf57e7efd00f9" translate="yes" xml:space="preserve">
          <source>So to introduce some real trust in the system, the only thing you need to do is to digitally sign just 'one' special note, which includes the name of a top-level commit. Your digital signature shows others that you trust that commit, and the immutability of the history of commits tells others that they can trust the whole history.</source>
          <target state="translated">따라서 시스템에 대한 진정한 신뢰를 얻으려면 최상위 커밋 이름을 포함하는 '한 가지'특별한 메모에 디지털 서명 만하면됩니다. 당신의 디지털 서명은 당신이 그 커밋을 신뢰한다는 것을 다른 사람들에게 보여주고, 커밋 기록의 불변성은 다른 사람들에게 그들이 전체 역사를 신뢰할 수 있다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="30ae77f4affa991e80efc3f102be0a94e3ede52f" translate="yes" xml:space="preserve">
          <source>So to introduce some real trust in the system, the only thing you need to do is to digitally sign just &lt;code&gt;one&lt;/code&gt; special note, which includes the name of a top-level commit. Your digital signature shows others that you trust that commit, and the immutability of the history of commits tells others that they can trust the whole history.</source>
          <target state="translated">따라서 시스템에 대한 진정한 신뢰를 도입하려면 최상위 커밋의 이름을 포함하는 &lt;code&gt;one&lt;/code&gt; 특수 메모 에 디지털 서명 만하면 됩니다. 디지털 서명은 다른 사람에게 해당 커밋을 신뢰한다는 것을 보여주고, 커밋 기록의 불변성은 다른 사람에게 전체 기록을 신뢰할 수 있음을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="909741d50394835646e0e74eaab338b4f855de2e" translate="yes" xml:space="preserve">
          <source>So to populate the index with the two files you just created, you can do</source>
          <target state="translated">방금 만든 두 파일로 인덱스를 채우려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f597f374b45ae15a5bbfbd431d1e5af284187139" translate="yes" xml:space="preserve">
          <source>So using a PRNG with a bias to favor commits away from the good and bad commits looked like a good choice.</source>
          <target state="translated">따라서 좋은 커밋과 나쁜 커밋에서 커밋을 선호하는 편견과 함께 PRNG를 사용하는 것이 좋은 선택처럼 보였습니다.</target>
        </trans-unit>
        <trans-unit id="1d3965fc903eee9b8f55d2c4363ff10ff9b5318f" translate="yes" xml:space="preserve">
          <source>So very soon it will not be possible to completely test everything.</source>
          <target state="translated">곧 모든 것을 완전히 테스트하는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="c734302804af13b8fb3578fee7c8a382eab7f492" translate="yes" xml:space="preserve">
          <source>So we chose G, H, K or L as the best bisection point, which is better than F. Because if for example L is bad, then we will know not only that L, M and N are bad but also that G, H, I and J are not the first bad commit (since we suppose that there is only one first bad commit and it must be an ancestor of L).</source>
          <target state="translated">따라서 우리는 G, H, K 또는 L을 F보다 나은 최고의이 분점으로 선택했습니다. 예를 들어 L이 나쁘면 L, M 및 N이 나쁘다는 것뿐만 아니라 G, H도 알 수 있습니다. , I와 J는 첫 번째 나쁜 커밋이 아닙니다 (우리는 첫 번째 나쁜 커밋이 하나만 있고 L의 조상이어야한다고 가정하기 때문에).</target>
        </trans-unit>
        <trans-unit id="52135537297d21de1e1bab64c3c62387485ffd7b" translate="yes" xml:space="preserve">
          <source>So we would be left with only:</source>
          <target state="translated">따라서 우리는 다음과 같이 남게됩니다.</target>
        </trans-unit>
        <trans-unit id="9a854aba22b6e93e9800490c72e201394edc5390" translate="yes" xml:space="preserve">
          <source>So what are the tools used to fight regressions? They are nearly the same as those used to fight regular bugs. The only specific tools are test suites and tools similar as &quot;git bisect&quot;.</source>
          <target state="translated">그렇다면 회귀와 싸우는 데 사용되는 도구는 무엇입니까? 그것들은 일반적인 버그와 싸우는 데 사용되는 것과 거의 동일합니다. 유일한 툴은 테스트 스위트와 &quot;git bisect&quot;와 유사한 툴입니다.</target>
        </trans-unit>
        <trans-unit id="17175b38ddc3adc987023ab7708e71618fdb213f" translate="yes" xml:space="preserve">
          <source>So what our &lt;code&gt;git add&lt;/code&gt; did was store a new blob and then put a reference to it in the index file. If we modify the file again, we&amp;rsquo;ll see that the new modifications are reflected in the &lt;code&gt;git diff&lt;/code&gt; output:</source>
          <target state="translated">그래서 우리의 &lt;code&gt;git add&lt;/code&gt; 한 일은 새로운 덩어리를 저장하고 인덱스 파일에 대한 참조를 넣어했다. 파일을 다시 수정하면 새로운 수정 사항이 &lt;code&gt;git diff&lt;/code&gt; 출력에 반영됩니다 .</target>
        </trans-unit>
        <trans-unit id="c52a5d49814c75f968644da3c05f28677f66e5d9" translate="yes" xml:space="preserve">
          <source>So when a commit is marked as &quot;bad&quot; we know we can remove all the commits in the graph except those that are ancestors of the new &quot;bad&quot; commit. This means that:</source>
          <target state="translated">따라서 커밋이 &quot;나쁜&quot;것으로 표시되면 새로운 &quot;나쁜&quot;커밋의 조상 인 커밋을 제외한 모든 커밋을 그래프에서 제거 할 수 있습니다. 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2ab9a98e063e3527611545f584f2c39a22096906" translate="yes" xml:space="preserve">
          <source>So, look into &lt;code&gt;builtin/cat-file.c&lt;/code&gt;, search for &lt;code&gt;cmd_cat_file()&lt;/code&gt; and look what it does.</source>
          <target state="translated">따라서 &lt;code&gt;builtin/cat-file.c&lt;/code&gt; 를 찾아 &lt;code&gt;cmd_cat_file()&lt;/code&gt; 을 검색하고 그 기능을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="190b1ee6ab5b81f82f0d76cf355df1a21f43d2e3" translate="yes" xml:space="preserve">
          <source>So, think about something which you are interested in, say, &quot;how can I access a blob just knowing the object name of it?&quot;. The first step is to find a Git command with which you can do it. In this example, it is either &lt;code&gt;git show&lt;/code&gt; or &lt;code&gt;git cat-file&lt;/code&gt;.</source>
          <target state="translated">따라서 관심있는 대상에 대해 생각해보십시오. &quot;개체 이름 만 알고있는 Blob에 어떻게 액세스 할 수 있습니까?&quot; 첫 번째 단계는 Git 명령을 찾는 것입니다. 이 예제에서는 &lt;code&gt;git show&lt;/code&gt; 또는 &lt;code&gt;git cat-file&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1efaef427fd5b515b3e304fc27457e91eec84a25" translate="yes" xml:space="preserve">
          <source>So, we can use somebody else&amp;rsquo;s work from a remote repository, but how can &lt;strong&gt;you&lt;/strong&gt; prepare a repository to let other people pull from it?</source>
          <target state="translated">따라서 원격 저장소에서 다른 사람의 작업을 사용할 수 있지만 다른 사람이 가져 오도록 저장소를 어떻게 준비 할 &lt;strong&gt;수&lt;/strong&gt; 있습니까?</target>
        </trans-unit>
        <trans-unit id="1d69dd0a510947edc4fb12eee97c080f4a377f68" translate="yes" xml:space="preserve">
          <source>Software bugs, or errors, are so prevalent and so detrimental that they cost the U.S. economy an estimated $59.5 billion annually, or about 0.6 percent of the gross domestic product, according to a newly released study commissioned by the Department of Commerce&amp;rsquo;s National Institute of Standards and Technology (NIST). At the national level, over half of the costs are borne by software users and the remainder by software developers/vendors. The study also found that, although all errors cannot be removed, more than a third of these costs, or an estimated $22.2 billion, could be eliminated by an improved testing infrastructure that enables earlier and more effective identification and removal of software defects. These are the savings associated with finding an increased percentage (but not 100 percent) of errors closer to the development stages in which they are introduced. Currently, over half of all errors are not found until &quot;downstream&quot; in the development process or during post-sale software use.</source>
          <target state="translated">미 상무부의 국립 표준 연구소 (National Institute of Standards)가 의뢰 한 새로 발표 된 연구에 따르면, 소프트웨어 버그 또는 오류는 매우 널리 퍼져 해마다 미국 경제에 연간 약 595 억 달러, 또는 국내 총생산의 약 0.6 %가 소요되는 것으로 추정됩니다. 그리고 기술 (NIST). 국가 차원에서 비용의 절반 이상이 소프트웨어 사용자가 부담하고 나머지는 소프트웨어 개발자 / 공급 업체가 부담합니다. 또한 모든 오류를 제거 할 수는 없지만 소프트웨어 결함을보다 빠르고 정확하게 식별 및 제거 할 수있는 향상된 테스트 인프라를 통해 이러한 비용의 3 분의 1 이상 또는 약 222 억 달러가 제거 될 수 있음을 발견했습니다.이는 도입 단계에 근접한 증가 된 비율 (100 % 아님)의 오류를 찾는 데 따른 비용 절감입니다. 현재 개발 과정에서 또는 다운 이후 판매 소프트웨어 사용 중에 &quot;다운 스트림&quot;이 될 때까지 모든 오류의 절반 이상이 발견되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f90a777e081dbed9d193d82399cc2e3159bf44a3" translate="yes" xml:space="preserve">
          <source>Software developers already spend approximately 80 percent of development costs on identifying and correcting defects, and yet few products of any type other than software are shipped with such high levels of errors.</source>
          <target state="translated">소프트웨어 개발자는 이미 결함을 식별하고 수정하는 데 개발 비용의 약 80 %를 소비하지만 소프트웨어 이외의 다른 유형의 제품에는 이러한 수준의 오류가있는 제품은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="b27e803e858c897a720eecea15e5bd37677e07bf" translate="yes" xml:space="preserve">
          <source>Some Git commands take options that are only used for plumbing or that are deprecated, and such options are hidden from the default usage. This option gives the full list of options.</source>
          <target state="translated">일부 Git 명령은 배관에만 사용되거나 더 이상 사용되지 않는 옵션을 사용하며 이러한 옵션은 기본 사용법에서 숨겨집니다. 이 옵션은 전체 옵션 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="987ad55498ef51019e6595f32f9ee9a10fb74d21" translate="yes" xml:space="preserve">
          <source>Some actions require or allow to specify two revisions, and sometimes even two pathnames. In most general form such path_info (component) based gitweb URL looks like this:</source>
          <target state="translated">일부 작업에는 두 개의 수정본, 때로는 두 개의 경로 이름이 필요하거나 지정해야합니다. 가장 일반적인 형태로 이러한 path_info (구성 요소) 기반 gitweb URL은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e1994dd201b175192ea5080be05071ba824a420" translate="yes" xml:space="preserve">
          <source>Some atoms like %(align) and %(if) always require a matching %(end). We call them &quot;opening atoms&quot; and sometimes denote them as %($open).</source>
          <target state="translated">% (align) 및 % (if)와 같은 일부 원자는 항상 일치하는 % (end)를 필요로합니다. 우리는 이것을 &quot;개방 원자&quot;라고 부르며 때로는 % ($ open)로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b05a87bd0e5e1c61140759ab02c7e9f3bf4a2773" translate="yes" xml:space="preserve">
          <source>Some basic familiarity with Git is required. Having gone through &lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt; and &lt;a href=&quot;gitglossary&quot;&gt;gitglossary[7]&lt;/a&gt; should be sufficient.</source>
          <target state="translated">Git에 대한 기본 지식이 필요합니다. 겪었 데 &lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]&lt;/a&gt; 및 &lt;a href=&quot;gitglossary&quot;&gt;gitglossary [7]&lt;/a&gt; 에 충분해야한다.</target>
        </trans-unit>
        <trans-unit id="61fa4c6dc6ae1d559b0a8be1b0de50848c850d66" translate="yes" xml:space="preserve">
          <source>Some changes are so trivial that it is not necessary to create a separate branch and then merge into each of the test and release branches. For these changes, just apply directly to the &lt;code&gt;release&lt;/code&gt; branch, and then merge that into the &lt;code&gt;test&lt;/code&gt; branch.</source>
          <target state="translated">일부 변경 사항은 너무나 사소하므로 별도의 분기를 만든 다음 각 테스트 및 릴리스 분기에 병합 할 필요가 없습니다. 이러한 변경 사항은 &lt;code&gt;release&lt;/code&gt; 브랜치에 직접 적용한 다음 &lt;code&gt;test&lt;/code&gt; 브랜치에 병합하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="59b18808ec08d9ea8408e805bbd7fa2f7edcfa73" translate="yes" xml:space="preserve">
          <source>Some commands (e.g. svn and http interfaces) that interactively ask for a password can be told to use an external program given via the value of this variable. Can be overridden by the &lt;code&gt;GIT_ASKPASS&lt;/code&gt; environment variable. If not set, fall back to the value of the &lt;code&gt;SSH_ASKPASS&lt;/code&gt; environment variable or, failing that, a simple password prompt. The external program shall be given a suitable prompt as command-line argument and write the password on its STDOUT.</source>
          <target state="translated">대화식으로 비밀번호를 요청하는 일부 명령 (예 : svn 및 http 인터페이스)은이 변수의 값을 통해 제공되는 외부 프로그램을 사용하도록 지시 할 수 있습니다. &lt;code&gt;GIT_ASKPASS&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 . 설정하지 않으면 &lt;code&gt;SSH_ASKPASS&lt;/code&gt; 환경 변수 의 값으로 돌아가 거나 실패한 경우 간단한 비밀번호 프롬프트로 돌아갑니다 . 외부 프로그램은 명령 행 인수로 적합한 프롬프트를 제공 받아 STDOUT에 암호를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="c2234711ff3c27c62e0fc4ab53a0833622d8f13d" translate="yes" xml:space="preserve">
          <source>Some configuration variables control the way the &lt;code&gt;--trailer&lt;/code&gt; arguments are applied to each commit message and the way any existing trailer in the commit message is changed. They also make it possible to automatically add some trailers.</source>
          <target state="translated">일부 구성 변수는 &lt;code&gt;--trailer&lt;/code&gt; 인수가 각 커밋 메시지에 적용되는 방식과 커밋 메시지의 기존 트레일러가 변경되는 방식을 제어합니다 . 또한 일부 예고편을 자동으로 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="938be1fd3d7f894aaa8fcd897f4e95cd6aacc1b6" translate="yes" xml:space="preserve">
          <source>Some configuration variables have their default values (embedded in the CGI script) set during building gitweb &amp;mdash; if that is the case, this fact is put in their description. See gitweb&amp;rsquo;s &lt;code&gt;INSTALL&lt;/code&gt; file for instructions on building and installing gitweb.</source>
          <target state="translated">일부 구성 변수에는 gitweb을 빌드하는 동안 기본값 (CGI 스크립트에 포함)이 설정되어 있습니다.이 경우 해당 사실이 설명에 포함됩니다. gitweb 빌드 및 설치에 대한 지침 은 gitweb의 &lt;code&gt;INSTALL&lt;/code&gt; 파일을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d66e22fd5f2bbbc188c5b064782bc9e186f6b28" translate="yes" xml:space="preserve">
          <source>Some email servers (e.g. smtp.163.com) limit the number emails to be sent per session (connection) and this will lead to a failure when sending many messages. With this option, send-email will disconnect after sending $&amp;lt;num&amp;gt; messages and wait for a few seconds (see --relogin-delay) and reconnect, to work around such a limit. You may want to use some form of credential helper to avoid having to retype your password every time this happens. Defaults to the &lt;code&gt;sendemail.smtpBatchSize&lt;/code&gt; configuration variable.</source>
          <target state="translated">일부 전자 메일 서버 (예 : smtp.163.com)는 세션 당 전송되는 전자 메일 수 (연결)를 제한하므로 많은 메시지를 보낼 때 오류가 발생합니다. 이 옵션을 사용하면 $ &amp;lt;num&amp;gt; 메시지를 보낸 후 send-email의 연결이 끊어지고 몇 초 동안 기다린 후 (--relogin-delay 참조) 다시 연결하여 이러한 한계를 극복합니다. 이런 상황이 발생할 때마다 비밀번호를 다시 입력하지 않아도되도록 일종의 자격 증명 도우미를 사용할 수 있습니다. &lt;code&gt;sendemail.smtpBatchSize&lt;/code&gt; 구성 변수가 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="92168eb294cb53195c326d7cdc472c76b820a62e" translate="yes" xml:space="preserve">
          <source>Some features cannot be overridden per project. For those features the structure of appropriate &lt;code&gt;%feature&lt;/code&gt; hash element has a simpler form:</source>
          <target state="translated">프로젝트별로 일부 기능을 재정의 할 수 없습니다. 이러한 기능의 경우 적절한 &lt;code&gt;%feature&lt;/code&gt; 해시 요소 의 구조 는 더 간단한 형식입니다.</target>
        </trans-unit>
        <trans-unit id="7345fdef7f54471f79d673ac02c80817717e5d21" translate="yes" xml:space="preserve">
          <source>Some filesystems lose the executable bit when a file that is marked as executable is checked out, or checks out a non-executable file with executable bit on. &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; probe the filesystem to see if it handles the executable bit correctly and this variable is automatically set as necessary.</source>
          <target state="translated">실행 파일로 표시된 파일을 체크 아웃하거나 실행 파일이 켜져있는 비 실행 파일을 체크 아웃하면 일부 파일 시스템에서 실행 비트가 손실됩니다. &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt; 은 파일 시스템을 검사하여 실행 파일이 올바르게 처리되는지 확인하고이 변수는 필요에 따라 자동으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1c65f795a263fd4e4ffc8fd7edc082e1bb01009b" translate="yes" xml:space="preserve">
          <source>Some filters will generate empty commits that leave the tree untouched. This option instructs git-filter-branch to remove such commits if they have exactly one or zero non-pruned parents; merge commits will therefore remain intact. This option cannot be used together with &lt;code&gt;--commit-filter&lt;/code&gt;, though the same effect can be achieved by using the provided &lt;code&gt;git_commit_non_empty_tree&lt;/code&gt; function in a commit filter.</source>
          <target state="translated">일부 필터는 빈 커밋을 생성하여 트리를 그대로 둡니다. 이 옵션은 자르지 않은 부모가 정확히 하나 또는 0 인 경우 커밋을 제거하도록 git-filter-branch에 지시합니다. 따라서 병합 커밋은 그대로 유지됩니다. 이 옵션은 &lt;code&gt;--commit-filter&lt;/code&gt; 와 함께 사용할 수 없지만 커밋 필터에서 제공된 &lt;code&gt;git_commit_non_empty_tree&lt;/code&gt; 함수를 사용하여 동일한 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
