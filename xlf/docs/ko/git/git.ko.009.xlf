<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="172ca906089028fc890c646e25bab698db638084" translate="yes" xml:space="preserve">
          <source>Some functions have a &lt;code&gt;_fl()&lt;/code&gt; suffix to indicate that they take &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line-number&lt;/code&gt; arguments.</source>
          <target state="translated">일부 함수에는 &lt;code&gt;_fl()&lt;/code&gt; 접미사가있어 &lt;code&gt;file&lt;/code&gt; 및 &lt;code&gt;line-number&lt;/code&gt; 인수 를 사용함 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="cf5b41401ecbf41c583b9f31bc11f9978bf853cb" translate="yes" xml:space="preserve">
          <source>Some functions have a &lt;code&gt;_printf_fl()&lt;/code&gt; suffix to indicate that they also take a varargs argument.</source>
          <target state="translated">일부 함수에는 &lt;code&gt;_printf_fl()&lt;/code&gt; 접미사가있어 varargs 인수도 사용함 을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c20fab9f2e759692fa04bbce7cef5cc908557231" translate="yes" xml:space="preserve">
          <source>Some functions have a &lt;code&gt;_va_fl()&lt;/code&gt; suffix to indicate that they also take a &lt;code&gt;va_list&lt;/code&gt; argument.</source>
          <target state="translated">일부 함수에는 &lt;code&gt;_va_fl()&lt;/code&gt; 접미사가있어 &lt;code&gt;va_list&lt;/code&gt; 인수 도 사용함 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="eba90c7cd2e8efb76a00a6ef6fd10ba0e6c2d355" translate="yes" xml:space="preserve">
          <source>Some improvements to the algorithms inside &quot;git bisect&quot; are possible and some new features could help in some cases, but overall &quot;git bisect&quot; works already very well, is used a lot, and is already very useful. To back up that last claim, let&amp;rsquo;s give the final word to Ingo Molnar when he was asked by the author how much time does he think &quot;git bisect&quot; saves him when he uses it:</source>
          <target state="translated">&quot;git bisect&quot;내부의 알고리즘에 대한 일부 개선이 가능하고 일부 새로운 기능은 일부 경우에 도움이 될 수 있지만 전반적인 &quot;git bisect&quot;는 이미 잘 작동하고 많이 사용되며 이미 매우 유용합니다. 마지막 주장을 뒷받침하기 위해, 저자가 &quot;git bisect&quot;를 사용했을 때 얼마나 많은 시간을 절약한다고 생각하는지에 대한 질문을받은 Ingo Molnar에게 마지막 단어를 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="051a4238025a126fd35cea3d27808e1a33c19d81" translate="yes" xml:space="preserve">
          <source>Some key/value pairs are common to all events and some are event-specific.</source>
          <target state="translated">일부 키 / 값 쌍은 모든 이벤트에 공통적이며 일부는 이벤트에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="171887e25dc7a6bd359791fb5478731797724aa1" translate="yes" xml:space="preserve">
          <source>Some malformed strings may be accepted as valid dates. In some of these cases Git will still be able to obtain the correct date from the malformed string. There are also some types of malformed strings which Git will parse wrong, and yet consider valid. Seriously malformed strings will be rejected.</source>
          <target state="translated">일부 잘못된 문자열은 유효한 날짜로 허용 될 수 있습니다. 이러한 경우 중 일부는 Git이 잘못된 문자열에서 정확한 날짜를 얻을 수 있습니다. Git이 잘못 구문 분석하지만 유효한 것으로 간주하는 잘못된 형식의 문자열 유형도 있습니다. 형식이 잘못된 문자열은 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="783d5fee630f867a836aab31a09a1120dfa61932" translate="yes" xml:space="preserve">
          <source>Some more interesting work has been done in the upstream project, and &lt;code&gt;origin&lt;/code&gt; has advanced:</source>
          <target state="translated">업스트림 프로젝트에서 좀 더 흥미로운 작업이 이루어졌으며 &lt;code&gt;origin&lt;/code&gt; 가 발전했습니다.</target>
        </trans-unit>
        <trans-unit id="f3d95fe16308405a40d9c1590f99de534764e169" translate="yes" xml:space="preserve">
          <source>Some old repositories have tags without a tagger. The fast-import protocol was pretty strict about that, and did not allow that. So fake a tagger to be able to fast-import the output.</source>
          <target state="translated">일부 오래된 리포지토리에는 태그가없는 태그가 있습니다. 빠른 가져 오기 프로토콜은 그것에 대해 매우 엄격했으며 허용하지 않았습니다. 따라서 태그를 가짜로 만들어서 출력을 빠르게 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f1322ce775635ebc0b366d585bc7dbdc07c75d2" translate="yes" xml:space="preserve">
          <source>Some optional features and policies</source>
          <target state="translated">일부 선택적 기능 및 정책</target>
        </trans-unit>
        <trans-unit id="184f39eeceeacf637176614462d419ff5408c775" translate="yes" xml:space="preserve">
          <source>Some other SCM systems let the user create a tag from multiple files which are not from the same commit/changeset. Or to create tags which are a subset of the files available in the repository.</source>
          <target state="translated">일부 다른 SCM 시스템에서는 사용자가 동일한 커밋 / 변경 세트가 아닌 여러 파일에서 태그를 만들 수 있습니다. 또는 저장소에서 사용 가능한 파일의 서브 세트 인 태그를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="e0986df979670ad50493b8dd4aeecf085f900c18" translate="yes" xml:space="preserve">
          <source>Some other commands that also work on files in the working tree and/or in the index can take &lt;code&gt;--staged&lt;/code&gt; and/or &lt;code&gt;--worktree&lt;/code&gt;.</source>
          <target state="translated">작업 트리 및 / 또는 인덱스의 파일에서 작동하는 다른 명령은 &lt;code&gt;--staged&lt;/code&gt; 및 / 또는 &lt;code&gt;--worktree&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e825ac68d84922615f20a915d3c1eb9e9c71680" translate="yes" xml:space="preserve">
          <source>Some placeholders may depend on other options given to the revision traversal engine. For example, the &lt;code&gt;%g*&lt;/code&gt; reflog options will insert an empty string unless we are traversing reflog entries (e.g., by &lt;code&gt;git log -g&lt;/code&gt;). The &lt;code&gt;%d&lt;/code&gt; and &lt;code&gt;%D&lt;/code&gt; placeholders will use the &quot;short&quot; decoration format if &lt;code&gt;--decorate&lt;/code&gt; was not already provided on the command line.</source>
          <target state="translated">일부 자리 표시자는 수정 순회 엔진에 지정된 다른 옵션에 따라 달라질 수 있습니다. 예를 들어, &lt;code&gt;%g*&lt;/code&gt; reflog 옵션은 reflog 항목을 통과하지 않는 한 빈 문자열을 삽입합니다 (예 : &lt;code&gt;git log -g&lt;/code&gt; ). &lt;code&gt;%d&lt;/code&gt; 와 &lt;code&gt;%D&lt;/code&gt; 자리 경우 &quot;짧은&quot;장식 형식을 사용합니다 &lt;code&gt;--decorate&lt;/code&gt; 가 이미 명령 행에 제공되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b90f1a06edbdea1cb1ea924bb534bf207be4c8cd" translate="yes" xml:space="preserve">
          <source>Some special diff options allow diffing the working directory against any of these stages:</source>
          <target state="translated">일부 특수 diff 옵션을 사용하면 작업 디렉토리를 다음 단계와 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="379a99bc56f81a74676a3582df5345ad077361ae" translate="yes" xml:space="preserve">
          <source>Some workflows require that one or more branches of development on one machine be replicated on another machine, but the two machines cannot be directly connected, and therefore the interactive Git protocols (git, ssh, http) cannot be used.</source>
          <target state="translated">일부 워크 플로우에서는 한 머신의 하나 이상의 개발 브랜치를 다른 머신에서 복제해야하지만 두 머신을 직접 연결할 수 없으므로 대화식 Git 프로토콜 (git, ssh, http)을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4efa70b7553b32aea10bdaaf89e5cdb60eb1465e" translate="yes" xml:space="preserve">
          <source>Somebody asks you to pull, and the changes sound worthy of merging.</source>
          <target state="translated">누군가가 당신에게 물을 것을 요구하고, 그 변화는 합병 할 가치가있는 것으로 들립니다.</target>
        </trans-unit>
        <trans-unit id="75bb6efa7b5bca1608dd13b1f00b4537d22f7537" translate="yes" xml:space="preserve">
          <source>Somebody hands you a copy of a file, and asks which commits modified a file such that it contained the given content either before or after the commit. You can find out with this:</source>
          <target state="translated">누군가 당신에게 파일의 사본을 건네고, 커밋 전후에 주어진 내용을 포함하도록 파일을 수정 한 커밋을 요청합니다. 당신은 이것으로 알 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7ef51555538cdc5f80247933eec8146e7de62402" translate="yes" xml:space="preserve">
          <source>Someone can do a history rewrite, realize they messed up, restore from the backups in refs/original/, and then redo their git-filter-branch command. (The backup in refs/original/ is not a real backup; it dereferences tags first.)</source>
          <target state="translated">누군가는 기록을 다시 작성하고 엉망이 된 것을 알고 refs / original /의 백업에서 복원 한 다음 git-filter-branch 명령을 다시 실행할 수 있습니다. (refs / original /의 백업은 실제 백업이 아니므로 태그를 먼저 참조하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="8b7568eaac49251d7ecfa53edc4f2d50e2427376" translate="yes" xml:space="preserve">
          <source>Someone can have a set of &quot;working and tested filters&quot; which they document or provide to a coworker, who then runs them on a different OS where the same commands are not working/tested (some examples in the git-filter-branch manpage are also affected by this). BSD vs. GNU userland differences can really bite. If lucky, error messages are spewed. But just as likely, the commands either don&amp;rsquo;t do the filtering requested, or silently corrupt by making some unwanted change. The unwanted change may only affect a few commits, so it&amp;rsquo;s not necessarily obvious either. (The fact that problems won&amp;rsquo;t necessarily be obvious means they are likely to go unnoticed until the rewritten history is in use for quite a while, at which point it&amp;rsquo;s really hard to justify another flag-day for another rewrite.)</source>
          <target state="translated">누군가는 문서화하거나 동료에게 제공하는 &quot;작동 및 테스트 된 필터&quot;세트를 가질 수 있으며, 그런 다음 동일한 명령이 작동 / 테스트되지 않은 다른 OS에서 실행됩니다 (git-filter-branch 맨 페이지의 일부 예는 또한 이것에 의해 영향을받습니다). BSD와 GNU 사용자 영역의 차이점은 실제로 물릴 수 있습니다. 운이 좋으면 오류 메시지가 표시됩니다. 그러나 명령은 요청 된 필터링을 수행하지 않거나 원치 않는 변경을 수행하여 자동으로 손상됩니다. 원하지 않는 변경은 몇 가지 커밋에만 영향을 줄 수 있으므로 반드시 명확한 것은 아닙니다. (문제가 분명하지 않다는 사실은 재기록 된 역사가 꽤 오랫동안 사용되기 전까지는 눈에 띄지 않을 가능성이 있다는 것을 의미합니다.이 시점에서 또 다른 재기록을 위해 또 다른 국기의 날을 정당화하기는 정말로 어렵습니다.)</target>
        </trans-unit>
        <trans-unit id="f6f28be0bc03c39873befbc10c61feb3cd6f09d9" translate="yes" xml:space="preserve">
          <source>Sometime later when enough time has passed and testing done, you can pull the same branch into the &lt;code&gt;release&lt;/code&gt; tree ready to go upstream. This is where you see the value of keeping each patch (or patch series) in its own branch. It means that the patches can be moved into the &lt;code&gt;release&lt;/code&gt; tree in any order.</source>
          <target state="translated">나중에 충분한 시간이 지났고 테스트가 완료되면 동일한 분기를 &lt;code&gt;release&lt;/code&gt; 트리 로 가져와 업스트림으로 이동할 수 있습니다. 여기에서 각 패치 (또는 패치 시리즈)를 자체 분기에 유지하는 가치를 볼 수 있습니다. 즉, 패치 를 임의의 순서로 &lt;code&gt;release&lt;/code&gt; 트리 로 옮길 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3de282e58de418da244c9ed4c8dec9bb8a8937a" translate="yes" xml:space="preserve">
          <source>Sometimes it happens that the current state cannot be tested, for example if it does not compile because there was a bug preventing it at that time. This is what the special exit code 125 is for. It tells &quot;git bisect run&quot; that the current commit should be marked as untestable and that another one should be chosen and checked out.</source>
          <target state="translated">때로는 현재 상태를 테스트 할 수없는 경우가 있습니다. 예를 들어, 당시 버그를 방지하여 컴파일하지 않은 경우입니다. 이것이 특수 종료 코드 125의 목적입니다. &quot;git bisect run&quot;에 현재 커밋을 테스트 할 수없는 것으로 표시하고 다른 커밋을 선택하여 체크 아웃해야한다고 지시합니다.</target>
        </trans-unit>
        <trans-unit id="ab0983c0f5d9e7bd28c3834685713747f93c2919" translate="yes" xml:space="preserve">
          <source>Sometimes it is desirable to see the diff of a text-converted version of some binary files. For example, a word processor document can be converted to an ASCII text representation, and the diff of the text shown. Even though this conversion loses some information, the resulting diff is useful for human viewing (but cannot be applied directly).</source>
          <target state="translated">때때로 일부 바이너리 파일의 텍스트 변환 버전의 차이점을 보는 것이 바람직합니다. 예를 들어, 워드 프로세서 문서는 ASCII 텍스트 표현과 텍스트의 diff로 변환 될 수 있습니다. 이 변환에서 일부 정보가 손실 되더라도 diff는 사람이 보는 데 유용하지만 직접 적용 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="a66c6ccc61eb22dbd8fb180270521a352bb26eb7" translate="yes" xml:space="preserve">
          <source>Sometimes the thing fixed in b.2. cannot be amended to the not-quite perfect commit it fixes, because that commit is buried deeply in a patch series. That is exactly what interactive rebase is for: use it after plenty of &quot;a&quot;s and &quot;b&quot;s, by rearranging and editing commits, and squashing multiple commits into one.</source>
          <target state="translated">때때로 b.2에서 수정 된 것. 커밋은 패치 시리즈에 깊이 묻혀 있기 때문에 수정되지 않은 완벽한 커밋으로 수정할 수 없습니다. 이것이 바로 대화식 리베이스의 목적입니다. 커밋을 재 배열하고 편집하고 여러 커밋을 하나로 스 쿼싱하여 많은 &quot;a&quot;와 &quot;b&quot;후에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7d8c42c4820860471a909b97a129a9232304c94a" translate="yes" xml:space="preserve">
          <source>Sometimes what you want instead is a set of patches; for this you can use &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;:</source>
          <target state="translated">때때로 당신이 원하는 것은 대신 패치 세트입니다; 이를 위해 &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]을&lt;/a&gt; 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="abb396ee2420ccad29c3b6a0f48213b60cfe8e4f" translate="yes" xml:space="preserve">
          <source>Sometimes you are not looking for the commit that introduced a breakage, but rather for a commit that caused a change between some other &quot;old&quot; state and &quot;new&quot; state. For example, you might be looking for the commit that introduced a particular fix. Or you might be looking for the first commit in which the source-code filenames were finally all converted to your company&amp;rsquo;s naming standard. Or whatever.</source>
          <target state="translated">때로는 중단을 유발 한 커밋을 찾지 않고 다른 &quot;이전&quot;상태와 &quot;새로운&quot;상태 사이에서 변경을 일으키는 커밋을 찾고 있습니다. 예를 들어, 특정 수정 사항을 도입 한 커미트를 찾고있을 수 있습니다. 또는 소스 코드 파일 이름이 회사의 명명 표준으로 모두 변환 된 첫 번째 커밋을 찾고있을 것입니다. 또는 무엇이든.</target>
        </trans-unit>
        <trans-unit id="709d16fb784b306222cc9b75f2da6965fd037ce9" translate="yes" xml:space="preserve">
          <source>Sometimes you are only interested in parts of the history, for example the commits modifying a particular &amp;lt;path&amp;gt;. But there are two parts of &lt;code&gt;History Simplification&lt;/code&gt;, one part is selecting the commits and the other is how to do it, as there are various strategies to simplify the history.</source>
          <target state="translated">때로는 특정 &amp;lt;path&amp;gt;를 수정하는 커밋과 같이 기록의 일부에만 관심이 있습니다. 그러나 &lt;code&gt;History Simplification&lt;/code&gt; 에는 두 가지 부분이 있습니다 . 한 부분은 커밋을 선택하는 것이고 다른 하나는 기록을 단순화하는 다양한 전략이 있기 때문에이를 수행하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="3329bd14db714a1ebe54846da15c65686d4c297b" translate="yes" xml:space="preserve">
          <source>Sometimes you may wish to create a new branch &lt;code&gt;without&lt;/code&gt; actually checking it out and switching to it. If so, just use the command</source>
          <target state="translated">때로는 실제로 체크 아웃하고 전환 &lt;code&gt;without&lt;/code&gt; 새 브랜치를 생성하려고 할 수 있습니다 . 그렇다면 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9e0d77cc540587abb285618787352fd870a1def8" translate="yes" xml:space="preserve">
          <source>Sometimes you want to edit a commit deeper in your history. One approach is to use &lt;code&gt;git format-patch&lt;/code&gt; to create a series of patches and then reset the state to before the patches:</source>
          <target state="translated">때때로 당신은 당신의 역사에서 커밋을 더 깊이 편집하려고합니다. 한 가지 방법은 &lt;code&gt;git format-patch&lt;/code&gt; 를 사용하여 일련의 패치를 작성한 다음 상태를 패치 이전으로 재설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="17cc71829facf5cb6a6b321a2cbf6c64d2bc06da" translate="yes" xml:space="preserve">
          <source>Sometimes you would need to override a setting of an attribute for a path to &lt;code&gt;Unspecified&lt;/code&gt; state. This can be done by listing the name of the attribute prefixed with an exclamation point &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">때때로 경로에 대한 속성 설정을 &lt;code&gt;Unspecified&lt;/code&gt; 상태 로 대체해야 할 수도 있습니다 . 느낌표가 접두사로 붙은 속성 이름을 나열하면됩니다 &lt;code&gt;!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18f66cee3089e3b2788a7d42c7fbfe71e8e6eab6" translate="yes" xml:space="preserve">
          <source>Sometimes, more than one builtin is contained in one source file. For example, &lt;code&gt;cmd_whatchanged()&lt;/code&gt; and &lt;code&gt;cmd_log()&lt;/code&gt; both reside in &lt;code&gt;builtin/log.c&lt;/code&gt;, since they share quite a bit of code. In that case, the commands which are &lt;code&gt;not&lt;/code&gt; named like the &lt;code&gt;.c&lt;/code&gt; file in which they live have to be listed in &lt;code&gt;BUILT_INS&lt;/code&gt; in the &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">때때로 하나 이상의 소스 파일이 하나의 소스 파일에 포함되어 있습니다. 예를 들어, &lt;code&gt;cmd_whatchanged()&lt;/code&gt; 및 &lt;code&gt;cmd_log()&lt;/code&gt; 모두 약간의 코드를 공유하므로 &lt;code&gt;builtin/log.c&lt;/code&gt; 에 있습니다. 이 경우, &lt;code&gt;.c&lt;/code&gt; 파일 과 같이 이름 이 지정 &lt;code&gt;not&lt;/code&gt; 명령 은 &lt;code&gt;Makefile&lt;/code&gt; 의 &lt;code&gt;BUILT_INS&lt;/code&gt; 에 나열되어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="59356e5b6f2fcc25a08169f8960c8b579beeb31f" translate="yes" xml:space="preserve">
          <source>Sometimes, you do not know where to look for a feature. In many such cases, it helps to search through the output of &lt;code&gt;git log&lt;/code&gt;, and then &lt;code&gt;git show&lt;/code&gt; the corresponding commit.</source>
          <target state="translated">경우에 따라 기능을 찾을 위치를 모릅니다. 많은 경우, &lt;code&gt;git log&lt;/code&gt; 의 출력을 검색 한 다음 &lt;code&gt;git show&lt;/code&gt; 가 해당 커밋을 표시 하는 데 도움이됩니다 .</target>
        </trans-unit>
        <trans-unit id="94a8d6cf12f26243dde0f5140dd4760ee8881bb4" translate="yes" xml:space="preserve">
          <source>Sort based on the key given. Prefix &lt;code&gt;-&lt;/code&gt; to sort in descending order of the value. Supports &quot;version:refname&quot; or &quot;v:refname&quot; (tag names are treated as versions). The &quot;version:refname&quot; sort order can also be affected by the &quot;versionsort.suffix&quot; configuration variable. See &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt; for more sort options, but be aware keys like &lt;code&gt;committerdate&lt;/code&gt; that require access to the objects themselves will not work for refs whose objects have not yet been fetched from the remote, and will give a &lt;code&gt;missing object&lt;/code&gt; error.</source>
          <target state="translated">주어진 키를 기준으로 정렬하십시오. 접두사 &lt;code&gt;-&lt;/code&gt; 값의 내림차순으로 정렬합니다. &quot;version : refname&quot;또는 &quot;v : refname&quot;을 지원합니다 (태그 이름은 버전으로 취급 됨). &quot;version : refname&quot;정렬 순서는 &quot;versionsort.suffix&quot;구성 변수의 영향을받을 수도 있습니다. 정렬 옵션에 대한 자세한 내용은 &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt; 을 참조하십시오. 그러나 객체 자체에 액세스해야하는 &lt;code&gt;committerdate&lt;/code&gt; 와 같은 키 는 객체를 아직 원격에서 가져 오지 않은 참조에 대해서는 작동하지 않으며 &lt;code&gt;missing object&lt;/code&gt; 오류.</target>
        </trans-unit>
        <trans-unit id="4f8164295fbfdf007f932844e4ac7576dc2d1ee2" translate="yes" xml:space="preserve">
          <source>Sort based on the key given. Prefix &lt;code&gt;-&lt;/code&gt; to sort in descending order of the value. You may use the --sort=&amp;lt;key&amp;gt; option multiple times, in which case the last key becomes the primary key. Also supports &quot;version:refname&quot; or &quot;v:refname&quot; (tag names are treated as versions). The &quot;version:refname&quot; sort order can also be affected by the &quot;versionsort.suffix&quot; configuration variable. The keys supported are the same as those in &lt;code&gt;git for-each-ref&lt;/code&gt;. Sort order defaults to the value configured for the &lt;code&gt;tag.sort&lt;/code&gt; variable if it exists, or lexicographic order otherwise. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">주어진 키를 기준으로 정렬하십시오. 접두사 &lt;code&gt;-&lt;/code&gt; 값의 내림차순으로 정렬합니다. --sort = &amp;lt;key&amp;gt; 옵션을 여러 번 사용할 수 있으며,이 경우 마지막 키가 기본 키가됩니다. &quot;version : refname&quot;또는 &quot;v : refname&quot;도 지원합니다 (태그 이름은 버전으로 취급 됨). &quot;version : refname&quot;정렬 순서는 &quot;versionsort.suffix&quot;구성 변수의 영향을받을 수도 있습니다. 지원되는 키는 &lt;code&gt;git for-each-ref&lt;/code&gt; 의 키와 동일 합니다. 정렬 순서의 기본값은 &lt;code&gt;tag.sort&lt;/code&gt; 변수에 대해 구성된 값 (있는 경우), 그렇지 않으면 사전 순서입니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="235c15477db9421be496a9bdb61ee9fe5440e8e8" translate="yes" xml:space="preserve">
          <source>Sort based on the key given. Prefix &lt;code&gt;-&lt;/code&gt; to sort in descending order of the value. You may use the --sort=&amp;lt;key&amp;gt; option multiple times, in which case the last key becomes the primary key. The keys supported are the same as those in &lt;code&gt;git
for-each-ref&lt;/code&gt;. Sort order defaults to the value configured for the &lt;code&gt;branch.sort&lt;/code&gt; variable if exists, or to sorting based on the full refname (including &lt;code&gt;refs/...&lt;/code&gt; prefix). This lists detached HEAD (if present) first, then local branches and finally remote-tracking branches. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">주어진 키를 기준으로 정렬하십시오. 접두사 &lt;code&gt;-&lt;/code&gt; 값의 내림차순으로 정렬합니다. --sort = &amp;lt;key&amp;gt; 옵션을 여러 번 사용할 수 있으며,이 경우 마지막 키가 기본 키가됩니다. 지원되는 키는 &lt;code&gt;git for-each-ref&lt;/code&gt; 의 키와 동일 합니다. 정렬 순서의 기본값은 &lt;code&gt;branch.sort&lt;/code&gt; 변수에 대해 구성된 값 (있는 경우) 또는 전체 refname ( &lt;code&gt;refs/...&lt;/code&gt; 접두사 포함)을 기준으로 정렬 됩니다. 분리 된 HEAD (있는 경우)를 먼저 표시 한 다음 로컬 브랜치 및 원격 추적 브랜치를 나열합니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f1523e64bd22fd24a21f855bbd22c50e1efc550" translate="yes" xml:space="preserve">
          <source>Sort commits by date when possible.</source>
          <target state="translated">가능하면 날짜별로 커밋을 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="2c6b9826784b28663433b0a6dc2f2674e6b29a9a" translate="yes" xml:space="preserve">
          <source>Sort output according to the number of commits per author instead of author alphabetic order.</source>
          <target state="translated">작성자 알파벳 순서 대신 작성자 당 커밋 수에 따라 출력을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="97d057704ff7369f19e3dfc333c10a22925317f1" translate="yes" xml:space="preserve">
          <source>Sorting and filtering branches are case insensitive.</source>
          <target state="translated">분기 정렬 및 필터링은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ce7d777697e6536cabaa9eaf03abf69552dd696" translate="yes" xml:space="preserve">
          <source>Sorting and filtering refs are case insensitive.</source>
          <target state="translated">참조 정렬 및 필터링은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d38ff15fbd7490d8843677184f9c7afbcdf73ce" translate="yes" xml:space="preserve">
          <source>Sorting and filtering tags are case insensitive.</source>
          <target state="translated">태그 정렬 및 필터링은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74d012567bc749743b2f7f680471d74e8b0444d4" translate="yes" xml:space="preserve">
          <source>Source code management (tool).</source>
          <target state="translated">소스 코드 관리 (도구).</target>
        </trans-unit>
        <trans-unit id="36b1651cdc36dfe13b6c0271ea5052804f0ae0c9" translate="yes" xml:space="preserve">
          <source>Sparse checkout</source>
          <target state="translated">스파 스 체크 아웃</target>
        </trans-unit>
        <trans-unit id="7aaf15f27eda1de7eaf7b123729519d3afe58336" translate="yes" xml:space="preserve">
          <source>Specifically, the following are removed until none of them remain:</source>
          <target state="translated">특히 다음 중 하나도 남아 있지 않을 때까지 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="6fb30b05a9f660538f592f3613160c9d3d393240" translate="yes" xml:space="preserve">
          <source>Specified branch is an ancestor of the remote HEAD</source>
          <target state="translated">지정된 브랜치는 원격 HEAD의 조상입니다.</target>
        </trans-unit>
        <trans-unit id="095f9fffc528a2b593b5d023d80910beab9fba54" translate="yes" xml:space="preserve">
          <source>Specified branch resolves to an object that exists locally</source>
          <target state="translated">지정된 분기가 로컬로 존재하는 개체로 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="aa507335de58b83c95563636f96d43ebd2769930" translate="yes" xml:space="preserve">
          <source>Specifies a minimum trust level for signature verification. If this option is unset, then signature verification for merge operations require a key with at least &lt;code&gt;marginal&lt;/code&gt; trust. Other operations that perform signature verification require a key with at least &lt;code&gt;undefined&lt;/code&gt; trust. Setting this option overrides the required trust-level for all operations. Supported values, in increasing order of significance:</source>
          <target state="translated">Specifies a minimum trust level for signature verification. If this option is unset, then signature verification for merge operations require a key with at least &lt;code&gt;marginal&lt;/code&gt; trust. Other operations that perform signature verification require a key with at least &lt;code&gt;undefined&lt;/code&gt; trust. Setting this option overrides the required trust-level for all operations. Supported values, in increasing order of significance:</target>
        </trans-unit>
        <trans-unit id="8bd7d2d739debb36a1057aa4a730675102718bfe" translate="yes" xml:space="preserve">
          <source>Specifies a port different from the default port (SMTP servers typically listen to smtp port 25, but may also listen to submission port 587, or the common SSL smtp port 465); symbolic port names (e.g. &quot;submission&quot; instead of 587) are also accepted. The port can also be set with the &lt;code&gt;sendemail.smtpServerPort&lt;/code&gt; configuration variable.</source>
          <target state="translated">기본 포트와 다른 포트를 지정합니다 (SMTP 서버는 일반적으로 smtp 포트 25를 수신하지만 제출 포트 587 또는 공통 SSL smtp 포트 465를 수신 할 수도 있음). 기호 포트 이름 (예 : 587 대신 &quot;제출&quot;)도 허용됩니다. &lt;code&gt;sendemail.smtpServerPort&lt;/code&gt; 구성 변수를 사용하여 포트를 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07c63275a8584ac825542ccb56fd0f5b3bf25b5a" translate="yes" xml:space="preserve">
          <source>Specifies compression level for newly-compressed data in the generated pack. If not specified, pack compression level is determined first by pack.compression, then by core.compression, and defaults to -1, the zlib default, if neither is set. Add --no-reuse-object if you want to force a uniform compression level on all data no matter the source.</source>
          <target state="translated">생성 된 팩에서 새로 압축 된 데이터의 압축 레벨을 지정합니다. 지정하지 않으면 pack 압축 수준은 먼저 pack.compression에 의해 결정된 다음 core.compression에 의해 결정되며 기본값이 -1로 설정되어 있지 않으면 zlib 기본값입니다. 소스에 관계없이 모든 데이터에 균일 한 압축 수준을 적용하려면 --no-reuse-object를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="2e586cba19f8fbc5a10baac47fbd5c9e37781d67" translate="yes" xml:space="preserve">
          <source>Specifies how a merge is handled when the merged-in history is already a descendant of the current history. &lt;code&gt;--ff&lt;/code&gt; is the default unless merging an annotated (and possibly signed) tag that is not stored in its natural place in the &lt;code&gt;refs/tags/&lt;/code&gt; hierarchy, in which case &lt;code&gt;--no-ff&lt;/code&gt; is assumed.</source>
          <target state="translated">병합 된 기록이 이미 현재 기록의 후손 인 경우 병합이 처리되는 방법을 지정합니다. &lt;code&gt;--ff&lt;/code&gt; &lt;code&gt;refs/tags/&lt;/code&gt; 계층 구조 의 자연 위치에 저장되지 않은 주석이 달린 (및 부호있는) 태그를 병합하지 않는 한 --ff 는 기본값 이며,이 경우 &lt;code&gt;--no-ff&lt;/code&gt; 로 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="1e4cfa4b695628b655fba3d437b2ed50df8c7399" translate="yes" xml:space="preserve">
          <source>Specifies how many context lines should be used in calls to diff made by the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;. The default is &quot;5&quot;.</source>
          <target state="translated">&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]에&lt;/a&gt; 의한 diff 호출에 사용되어야하는 컨텍스트 라인 수를 지정합니다 . 기본값은 &quot;5&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="ee05d66bfede680eae8d8ce792188074b5498ff4" translate="yes" xml:space="preserve">
          <source>Specifies how many submodules are fetched/cloned at the same time. A positive integer allows up to that number of submodules fetched in parallel. A value of 0 will give some reasonable default. If unset, it defaults to 1.</source>
          <target state="translated">동시에 페치 / 복제되는 서브 모듈 수를 지정합니다. 양의 정수는 병렬로 페치 된 최대 수의 서브 모듈을 허용합니다. 값이 0이면 합리적인 기본값이 제공됩니다. 설정하지 않으면 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="316fa49ea084b12859b1b97d79b0376bed50442d" translate="yes" xml:space="preserve">
          <source>Specifies how the submodules obtain alternates when submodules are cloned. Possible values are &lt;code&gt;no&lt;/code&gt;, &lt;code&gt;superproject&lt;/code&gt;. By default &lt;code&gt;no&lt;/code&gt; is assumed, which doesn&amp;rsquo;t add references. When the value is set to &lt;code&gt;superproject&lt;/code&gt; the submodule to be cloned computes its alternates location relative to the superprojects alternate.</source>
          <target state="translated">서브 모듈이 복제 될 때 서브 모듈이 대체를 얻는 방법을 지정합니다. 가능한 값은 &lt;code&gt;no&lt;/code&gt; , &lt;code&gt;superproject&lt;/code&gt; 입니다. 기본적으로 &lt;code&gt;no&lt;/code&gt; 는 가정되며 참조를 추가하지 않습니다. 값이 &lt;code&gt;superproject&lt;/code&gt; 로 설정되면, 복제 될 서브 모듈은 수퍼 프로젝트 대체물에 대한 대체 위치를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b31fc36154a26e26a1c078ebba51ee8a4995b30b" translate="yes" xml:space="preserve">
          <source>Specifies how to treat errors with the alternates for a submodule as computed via &lt;code&gt;submodule.alternateLocation&lt;/code&gt;. Possible values are &lt;code&gt;ignore&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;die&lt;/code&gt;. Default is &lt;code&gt;die&lt;/code&gt;. Note that if set to &lt;code&gt;ignore&lt;/code&gt; or &lt;code&gt;info&lt;/code&gt;, and if there is an error with the computed alternate, the clone proceeds as if no alternate was specified.</source>
          <target state="translated">을 통해 산출 된 지정 방법 서브 모듈의 대체와 오류를 치료하는 &lt;code&gt;submodule.alternateLocation&lt;/code&gt; . 가능한 값은 &lt;code&gt;ignore&lt;/code&gt; , &lt;code&gt;info&lt;/code&gt; , &lt;code&gt;die&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;die&lt;/code&gt; 입니다. &lt;code&gt;ignore&lt;/code&gt; 또는 &lt;code&gt;info&lt;/code&gt; 로 설정 하고 계산 된 대체에 오류가있는 경우 대체가 지정되지 않은 것처럼 복제가 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="d91861558c562fdeaaf804d5a6651390fea90d33" translate="yes" xml:space="preserve">
          <source>Specifies if commands recurse into submodules by default. This applies to all commands that have a &lt;code&gt;--recurse-submodules&lt;/code&gt; option (&lt;code&gt;checkout&lt;/code&gt;, &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;pull&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;read-tree&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;restore&lt;/code&gt; and &lt;code&gt;switch&lt;/code&gt;) except &lt;code&gt;clone&lt;/code&gt; and &lt;code&gt;ls-files&lt;/code&gt;. Defaults to false. When set to true, it can be deactivated via the &lt;code&gt;--no-recurse-submodules&lt;/code&gt; option. Note that some Git commands lacking this option may call some of the above commands affected by &lt;code&gt;submodule.recurse&lt;/code&gt;; for instance &lt;code&gt;git remote update&lt;/code&gt; will call &lt;code&gt;git fetch&lt;/code&gt; but does not have a &lt;code&gt;--no-recurse-submodules&lt;/code&gt; option. For these commands a workaround is to temporarily change the configuration value by using &lt;code&gt;git -c submodule.recurse=0&lt;/code&gt;.</source>
          <target state="translated">Specifies if commands recurse into submodules by default. This applies to all commands that have a &lt;code&gt;--recurse-submodules&lt;/code&gt; option ( &lt;code&gt;checkout&lt;/code&gt; , &lt;code&gt;fetch&lt;/code&gt; , &lt;code&gt;grep&lt;/code&gt; , &lt;code&gt;pull&lt;/code&gt; , &lt;code&gt;push&lt;/code&gt; , &lt;code&gt;read-tree&lt;/code&gt; , &lt;code&gt;reset&lt;/code&gt; , &lt;code&gt;restore&lt;/code&gt; and &lt;code&gt;switch&lt;/code&gt; ) except &lt;code&gt;clone&lt;/code&gt; and &lt;code&gt;ls-files&lt;/code&gt; . Defaults to false. When set to true, it can be deactivated via the &lt;code&gt;--no-recurse-submodules&lt;/code&gt; option. Note that some Git commands lacking this option may call some of the above commands affected by &lt;code&gt;submodule.recurse&lt;/code&gt; ; for instance &lt;code&gt;git remote update&lt;/code&gt; will call &lt;code&gt;git fetch&lt;/code&gt; but does not have a &lt;code&gt;--no-recurse-submodules&lt;/code&gt; option. For these commands a workaround is to temporarily change the configuration value by using &lt;code&gt;git -c submodule.recurse=0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be724c0999a6ad4178618a1619dc5ee566f604f6" translate="yes" xml:space="preserve">
          <source>Specifies if commands recurse into submodules by default. This applies to all commands that have a &lt;code&gt;--recurse-submodules&lt;/code&gt; option, except &lt;code&gt;clone&lt;/code&gt;. Defaults to false.</source>
          <target state="translated">기본적으로 명령이 하위 모듈로 되풀이되는지 여부를 지정합니다. 이는 &lt;code&gt;clone&lt;/code&gt; 을 제외한 &lt;code&gt;--recurse-submodules&lt;/code&gt; 옵션 이있는 모든 명령에 적용됩니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="521e20e338253b67c65fe5992b9e53ef105e078a" translate="yes" xml:space="preserve">
          <source>Specifies intentionally untracked files to ignore</source>
          <target state="translated">Specifies intentionally untracked files to ignore</target>
        </trans-unit>
        <trans-unit id="4a0da697fa597c14275c00dd14541ab0c3dfd994" translate="yes" xml:space="preserve">
          <source>Specifies the Fully Qualified Domain Name (FQDN) used in the HELO/EHLO command to the SMTP server. Some servers require the FQDN to match your IP address. If not set, git send-email attempts to determine your FQDN automatically. Default is the value of &lt;code&gt;sendemail.smtpDomain&lt;/code&gt;.</source>
          <target state="translated">HELO / EHLO 명령에 사용 된 FQDN (정규화 된 도메인 이름)을 SMTP 서버에 지정합니다. 일부 서버는 FQDN이 IP 주소와 일치해야합니다. 설정하지 않으면 git send-email은 FQDN을 자동으로 확인하려고 시도합니다. 기본값은 &lt;code&gt;sendemail.smtpDomain&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="5037aaf03dca1f2f538183f1496bfc2b7e1efabf" translate="yes" xml:space="preserve">
          <source>Specifies the default encoding to use for displaying of file contents in &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt; and &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt;. It can be overridden by setting the &lt;code&gt;encoding&lt;/code&gt; attribute for relevant files (see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;). If this option is not set, the tools default to the locale encoding.</source>
          <target state="translated">&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt; 및 &lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt; 에 파일 내용을 표시하는 데 사용할 기본 인코딩을 지정합니다 . 관련 파일 의 &lt;code&gt;encoding&lt;/code&gt; 속성을 설정하여 재정의 할 수 있습니다 ( &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 참조 ). 이 옵션을 설정하지 않으면 도구는 기본적으로 로캘 인코딩으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9702444fd012da98ed5d8ff9c395c187404df9d9" translate="yes" xml:space="preserve">
          <source>Specifies the default value for the &lt;code&gt;--max-new-filters&lt;/code&gt; option of &lt;code&gt;git
commit-graph write&lt;/code&gt; (c.f., &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt;).</source>
          <target state="translated">Specifies the default value for the &lt;code&gt;--max-new-filters&lt;/code&gt; option of &lt;code&gt;git commit-graph write&lt;/code&gt; (c.f., &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="8d7b044fb5611f2bdd400a7d800ea730223f6289" translate="yes" xml:space="preserve">
          <source>Specifies the dictionary used for spell checking commit messages in the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;. When set to &quot;none&quot; spell checking is turned off.</source>
          <target state="translated">&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt; 에서 맞춤법 검사 커밋 메시지에 사용되는 사전을 지정합니다 . &quot;없음&quot;으로 설정하면 맞춤법 검사가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="d083f984efe9263940e7d58fa993a7931f1dd65f" translate="yes" xml:space="preserve">
          <source>Specifies the encoding used to output author names and commit summaries. Setting it to &lt;code&gt;none&lt;/code&gt; makes blame output unconverted data. For more information see the discussion about encoding in the &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; manual page.</source>
          <target state="translated">작성자 이름 및 커밋 요약을 출력하는 데 사용되는 인코딩을 지정합니다. &lt;code&gt;none&lt;/code&gt; 으로 설정하면 변환 되지 않은 데이터가 출력됩니다. 자세한 내용은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 매뉴얼 페이지 에서 인코딩에 대한 설명을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="a27599ead22294e56acfe0afc5fbf545479773f2" translate="yes" xml:space="preserve">
          <source>Specifies the format used to output dates in &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;. If unset the iso format is used. For supported values, see the discussion of the &lt;code&gt;--date&lt;/code&gt; option at &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">날짜를 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; 로 출력하는 데 사용되는 형식을 지정합니다 . 설정하지 않으면 iso 형식이 사용됩니다. 지원되는 값 은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 에서 &lt;code&gt;--date&lt;/code&gt; 옵션에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08d91dd5a7053d3bafb0000dd55ac78c15731e93" translate="yes" xml:space="preserve">
          <source>Specifies the format used to output dates. If --date is not provided, the value of the blame.date config variable is used. If the blame.date config variable is also not set, the iso format is used. For supported values, see the discussion of the --date option at &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">날짜를 출력하는 데 사용되는 형식을 지정합니다. --date를 제공하지 않으면 blame.date 구성 변수의 값이 사용됩니다. blame.date 구성 변수도 설정되지 않은 경우 iso 형식이 사용됩니다. 지원되는 값은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 에서 --date 옵션에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08b582fd23612321f471de0a5131383c71313dc1" translate="yes" xml:space="preserve">
          <source>Specifies the general prompt string to display at the top of the dialog, before subsections for &lt;code&gt;argPrompt&lt;/code&gt; and &lt;code&gt;revPrompt&lt;/code&gt;. The default value includes the actual command.</source>
          <target state="translated">&lt;code&gt;argPrompt&lt;/code&gt; 및 &lt;code&gt;revPrompt&lt;/code&gt; 의 하위 섹션 전에 대화 상자의 맨 위에 표시 할 일반 프롬프트 문자열을 지정합니다 . 기본값은 실제 명령을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a9e526c09a4c4719d9406e0b96ea75a516e14797" translate="yes" xml:space="preserve">
          <source>Specifies the maximal number of fetch operations to be run in parallel at a time (submodules, or remotes when the &lt;code&gt;--multiple&lt;/code&gt; option of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; is in effect).</source>
          <target state="translated">한 번에 병렬로 실행할 최대 페치 조작 수를 지정합니다 ( &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 의 &lt;code&gt;--multiple&lt;/code&gt; 옵션이 적용되는 경우 서브 모듈 또는 리모트 ).</target>
        </trans-unit>
        <trans-unit id="841aeff1992a5e30906fb04c48bd487428f81ede" translate="yes" xml:space="preserve">
          <source>Specifies the number of threads to spawn when loading the index. This is meant to reduce index load time on multiprocessor machines. Specifying 0 or &lt;code&gt;true&lt;/code&gt; will cause Git to auto-detect the number of CPU&amp;rsquo;s and set the number of threads accordingly. Specifying 1 or &lt;code&gt;false&lt;/code&gt; will disable multithreading. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">인덱스를로드 할 때 생성 할 스레드 수를 지정합니다. 이는 다중 프로세서 시스템에서 인덱스로드 시간을 줄이기위한 것입니다. 0 또는 &lt;code&gt;true&lt;/code&gt; 를 지정 하면 Git은 CPU 수를 자동 감지하고 그에 따라 스레드 수를 설정합니다. 1 또는 &lt;code&gt;false&lt;/code&gt; 를 지정 하면 멀티 스레딩이 비활성화됩니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a1edc546a8b44445b5552ac6cb04ae2f0f6c55a7" translate="yes" xml:space="preserve">
          <source>Specifies the number of threads to spawn when resolving deltas. This requires that index-pack be compiled with pthreads otherwise this option is ignored with a warning. This is meant to reduce packing time on multiprocessor machines. The required amount of memory for the delta search window is however multiplied by the number of threads. Specifying 0 will cause Git to auto-detect the number of CPU&amp;rsquo;s and use maximum 3 threads.</source>
          <target state="translated">델타를 해결할 때 생성 할 스레드 수를 지정합니다. 인덱스 팩을 pthreads로 컴파일해야합니다. 그렇지 않으면이 옵션은 경고와 함께 무시됩니다. 이는 다중 프로세서 시스템에서 포장 시간을 단축하기위한 것입니다. 그러나 델타 검색 창에 필요한 메모리 양에는 스레드 수가 곱해집니다. 0을 지정하면 Git은 CPU 수를 자동 감지하고 최대 3 개의 스레드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="62a88cce2e4d60d8d3773b73f0efea252799f6cf" translate="yes" xml:space="preserve">
          <source>Specifies the number of threads to spawn when searching for best delta matches. This requires that &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; be compiled with pthreads otherwise this option is ignored with a warning. This is meant to reduce packing time on multiprocessor machines. The required amount of memory for the delta search window is however multiplied by the number of threads. Specifying 0 will cause Git to auto-detect the number of CPU&amp;rsquo;s and set the number of threads accordingly.</source>
          <target state="translated">최상의 델타 일치를 검색 할 때 생성 할 스레드 수를 지정합니다. 이를 위해서는 &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt; 를 pthreads로 컴파일해야합니다. 그렇지 않으면이 옵션은 경고와 함께 무시됩니다. 이는 다중 프로세서 시스템에서 포장 시간을 단축하기위한 것입니다. 그러나 델타 검색 창에 필요한 메모리 양에는 스레드 수가 곱해집니다. 0을 지정하면 Git은 CPU 수를 자동 감지하고 그에 따라 스레드 수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b8f98a607312c9ba066372345125a9cb60221982" translate="yes" xml:space="preserve">
          <source>Specifies the number of threads to spawn when searching for best delta matches. This requires that pack-objects be compiled with pthreads otherwise this option is ignored with a warning. This is meant to reduce packing time on multiprocessor machines. The required amount of memory for the delta search window is however multiplied by the number of threads. Specifying 0 will cause Git to auto-detect the number of CPU&amp;rsquo;s and set the number of threads accordingly.</source>
          <target state="translated">최상의 델타 일치를 검색 할 때 생성 할 스레드 수를 지정합니다. 이를 위해서는 pack 객체를 pthread로 컴파일해야합니다. 그렇지 않으면이 옵션은 경고와 함께 무시됩니다. 이는 다중 프로세서 시스템에서 포장 시간을 단축하기위한 것입니다. 그러나 델타 검색 창에 필요한 메모리 양에는 스레드 수가 곱해집니다. 0을 지정하면 Git은 CPU 수를 자동 감지하고 그에 따라 스레드 수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a17b7410705517c5284c60d4c1158e205890521a" translate="yes" xml:space="preserve">
          <source>Specifies the number of times to retry a p4 command (notably, &lt;code&gt;p4 sync&lt;/code&gt;) if the network times out. The default value is 3. Set the value to 0 to disable retries or if your p4 version does not support retries (pre 2012.2).</source>
          <target state="translated">네트워크 시간이 초과 된 경우 p4 명령 (특히 &lt;code&gt;p4 sync&lt;/code&gt; ) 을 재 시도하는 횟수를 지정합니다 . 기본값은 3입니다. 재 시도를 비활성화하거나 p4 버전이 재 시도를 지원하지 않는 경우 (2012.2 이전) 값을 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0ebc03abb12118370c422382dc91c5979f3d39ba" translate="yes" xml:space="preserve">
          <source>Specifies the pathname to the file that contains patterns to describe paths that are not meant to be tracked, in addition to &lt;code&gt;.gitignore&lt;/code&gt; (per-directory) and &lt;code&gt;.git/info/exclude&lt;/code&gt;. Defaults to &lt;code&gt;$XDG_CONFIG_HOME/git/ignore&lt;/code&gt;. If &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; is either not set or empty, &lt;code&gt;$HOME/.config/git/ignore&lt;/code&gt; is used instead. See &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.gitignore&lt;/code&gt; (디렉토리 당) 및 &lt;code&gt;.git/info/exclude&lt;/code&gt; 외에도 추적하지 않을 경로를 설명하는 패턴이 포함 된 파일의 경로 이름을 지정합니다 . 기본값은 &lt;code&gt;$XDG_CONFIG_HOME/git/ignore&lt;/code&gt; 입니다. 경우 &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; 하나 설정하거나 비어 있지 않은, &lt;code&gt;$HOME/.config/git/ignore&lt;/code&gt; 대신 사용됩니다. &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d124e54be4e690b62098ac284ac76a08ab37106b" translate="yes" xml:space="preserve">
          <source>Specifies the radius of history context in days to show in &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; for the selected commit, when the &lt;code&gt;Show History
Context&lt;/code&gt; menu item is invoked from &lt;code&gt;git gui blame&lt;/code&gt;. If this variable is set to zero, the whole history is shown.</source>
          <target state="translated">일 지정 역사 컨텍스트의 반경에서 보여 &lt;a href=&quot;gitk&quot;&gt;gitk이 [1]&lt;/a&gt; 때, 커밋 선택에 대한 &lt;code&gt;Show History Context&lt;/code&gt; 메뉴 항목에서 호출 &lt;code&gt;git gui blame&lt;/code&gt; . 이 변수를 0으로 설정하면 전체 히스토리가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f11e5547d2e0c72dd049c0935b29638a6ee69cf3" translate="yes" xml:space="preserve">
          <source>Specifies the shell command line to execute when the corresponding item of the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;&lt;code&gt;Tools&lt;/code&gt; menu is invoked. This option is mandatory for every tool. The command is executed from the root of the working directory, and in the environment it receives the name of the tool as &lt;code&gt;GIT_GUITOOL&lt;/code&gt;, the name of the currently selected file as &lt;code&gt;FILENAME&lt;/code&gt;, and the name of the current branch as &lt;code&gt;CUR_BRANCH&lt;/code&gt; (if the head is detached, &lt;code&gt;CUR_BRANCH&lt;/code&gt; is empty).</source>
          <target state="translated">&lt;a href=&quot;git-gui&quot;&gt;git-gui [1] &lt;/a&gt; &lt;code&gt;Tools&lt;/code&gt; 메뉴 의 해당 항목 이 호출 될 때 실행할 쉘 명령 행을 지정합니다 . 이 옵션은 모든 도구에 필수입니다. 명령은 작업 디렉토리의 루트에서 실행되며 환경에서 도구 이름은 &lt;code&gt;GIT_GUITOOL&lt;/code&gt; , 현재 선택된 파일 이름은 &lt;code&gt;FILENAME&lt;/code&gt; , 현재 브랜치 이름은 &lt;code&gt;CUR_BRANCH&lt;/code&gt; (헤드가 분리, &lt;code&gt;CUR_BRANCH&lt;/code&gt; 가 비어 있습니다).</target>
        </trans-unit>
        <trans-unit id="b9843bcfef468e8924053c3490935a52737f70b4" translate="yes" xml:space="preserve">
          <source>Specifies the threshold to use in &lt;code&gt;git gui blame&lt;/code&gt; original location detection, measured in alphanumeric characters. See the &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; manual for more information on copy detection.</source>
          <target state="translated">영숫자 문자로 측정 된 &lt;code&gt;git gui blame&lt;/code&gt; 원래 위치 감지 에 사용할 임계 값을 지정합니다 . 복사 감지에 대한 자세한 내용은 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="35d941c623037130ce3eda15ee67700140f974b9" translate="yes" xml:space="preserve">
          <source>Specifies the title to use for the prompt dialog. The default is the tool name.</source>
          <target state="translated">프롬프트 대화 상자에 사용할 제목을 지정합니다. 기본값은 도구 이름입니다.</target>
        </trans-unit>
        <trans-unit id="52c4a2a4dc795a08ca1c6e643c489de2ec8bd5e5" translate="yes" xml:space="preserve">
          <source>Specifies whether the index file should include an &quot;End Of Index Entry&quot; section. This reduces index load time on multiprocessor machines but produces a message &quot;ignoring EOIE extension&quot; when reading the index using Git versions before 2.20. Defaults to &lt;code&gt;true&lt;/code&gt; if index.threads has been explicitly enabled, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">인덱스 파일에 &quot;Index of End Entry&quot;섹션을 포함해야하는지 여부를 지정합니다. 이렇게하면 다중 프로세서 시스템에서 인덱스로드 시간이 줄어들지 만 2.20 이전의 Git 버전을 사용하여 인덱스를 읽을 때 &quot;EOIE 확장명 무시&quot;메시지가 표시됩니다. index.threads가 명시 적으로 활성화 된 경우 기본값은 &lt;code&gt;true&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="525e2825828b98c76d10ccc05a720012cdd9968e" translate="yes" xml:space="preserve">
          <source>Specifies whether the index file should include an &quot;Index Entry Offset Table&quot; section. This reduces index load time on multiprocessor machines but produces a message &quot;ignoring IEOT extension&quot; when reading the index using Git versions before 2.20. Defaults to &lt;code&gt;true&lt;/code&gt; if index.threads has been explicitly enabled, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">색인 파일에 &quot;색인 항목 오프셋 테이블&quot;섹션이 포함되어야하는지 여부를 지정합니다. 이렇게하면 다중 프로세서 컴퓨터에서 인덱스로드 시간이 줄어들지 만 2.20 이전의 Git 버전을 사용하여 인덱스를 읽을 때 &quot;IEOT 확장명 무시&quot;메시지가 나타납니다. index.threads가 명시 적으로 활성화 된 경우 기본값은 &lt;code&gt;true&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8fdd8a31fc755f041d294b5f0a76be847216c212" translate="yes" xml:space="preserve">
          <source>Specifies which key format to use when signing with &lt;code&gt;--gpg-sign&lt;/code&gt;. Default is &quot;openpgp&quot; and another possible value is &quot;x509&quot;.</source>
          <target state="translated">&lt;code&gt;--gpg-sign&lt;/code&gt; 으로 서명 할 때 사용할 키 형식을 지정 합니다 . 기본값은 &quot;openpgp&quot;이고 다른 가능한 값은 &quot;x509&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="53399059f89e05e568d5d0da51714e4798f56246" translate="yes" xml:space="preserve">
          <source>Specifies which refs to fetch and which local refs to update. When no &amp;lt;refspec&amp;gt;s appear on the command line, the refs to fetch are read from &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; variables instead (see &lt;a href=&quot;#CRTB&quot;&gt;CONFIGURED REMOTE-TRACKING BRANCHES&lt;/a&gt; below).</source>
          <target state="translated">가져올 참조와 업데이트 할 로컬 참조를 지정합니다. 명령 행에 &amp;lt;refspec&amp;gt;이 나타나지 않으면, fetch 할 ref는 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 변수에서 대신 읽습니다 ( 아래의 &lt;a href=&quot;#CRTB&quot;&gt;REMOTE-TRACKING BRANCHES 구성&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="60264eae7c0d99030432a57153dd31a20ae2e753" translate="yes" xml:space="preserve">
          <source>Specifies which refs to fetch and which local refs to update. When no &amp;lt;refspec&amp;gt;s appear on the command line, the refs to fetch are read from &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; variables instead (see &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</source>
          <target state="translated">가져올 참조와 업데이트 할 로컬 참조를 지정합니다. 명령 행에 &amp;lt;refspec&amp;gt;이 나타나지 않으면, 대신 &lt;a href=&quot;git-fetch&quot;&gt;가져 오는&lt;/a&gt; 참조 는 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 변수 에서 읽습니다 ( git-fetch [1] 참조 ).</target>
        </trans-unit>
        <trans-unit id="1874860df7878b35e35c3f03f4fe16310c6f5c2f" translate="yes" xml:space="preserve">
          <source>Specifies which refs to fetch and which local refs to update. When no &amp;lt;refspec&amp;gt;s appear on the command line, the refs to fetch are read from &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; variables instead (see the section &quot;CONFIGURED REMOTE-TRACKING BRANCHES&quot; in &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</source>
          <target state="translated">Specifies which refs to fetch and which local refs to update. When no &amp;lt;refspec&amp;gt;s appear on the command line, the refs to fetch are read from &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; variables instead (see the section &quot;CONFIGURED REMOTE-TRACKING BRANCHES&quot; in &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="12c5a4fe1da6e3ddd052994379342b3963b9ece6" translate="yes" xml:space="preserve">
          <source>Specify a &quot;Bcc:&quot; value for each email. Default is the value of &lt;code&gt;sendemail.bcc&lt;/code&gt;.</source>
          <target state="translated">각 이메일에 대해 &quot;숨은 참조 :&quot;값을 지정하십시오. 기본값은 &lt;code&gt;sendemail.bcc&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="490afafb9292b82bc6ff88488dc739661601f0fb" translate="yes" xml:space="preserve">
          <source>Specify a (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair that should be applied as a trailer to the input messages. See the description of this command.</source>
          <target state="translated">입력 메시지에 예고편으로 적용해야하는 (&amp;lt;토큰&amp;gt;, &amp;lt;값&amp;gt;) 쌍을 지정하십시오. 이 명령에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fda787c4a6303bd8c4899e47b2fd75ed69b102b2" translate="yes" xml:space="preserve">
          <source>Specify a comma separate list of common whitespace problems to notice in the same format as the &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable.</source>
          <target state="translated">&lt;code&gt;core.whitespace&lt;/code&gt; 구성 변수 와 동일한 형식으로 확인할 일반적인 공백 문제의 쉼표로 구분 된 목록을 지정 하십시오.</target>
        </trans-unit>
        <trans-unit id="f01423252b19025369d9eaeaea940daec72c630e" translate="yes" xml:space="preserve">
          <source>Specify a command to execute once per patch file which should generate patch file specific &quot;Cc:&quot; entries. Output of this command must be single email address per line. Default is the value of &lt;code&gt;sendemail.ccCmd&lt;/code&gt; configuration value.</source>
          <target state="translated">패치 파일 특정 &quot;Cc :&quot;항목을 생성해야하는 패치 파일 당 한 번 실행할 명령을 지정하십시오. 이 명령의 출력은 한 줄에 하나의 이메일 주소 여야합니다. 기본값은 &lt;code&gt;sendemail.ccCmd&lt;/code&gt; 구성 값입니다.</target>
        </trans-unit>
        <trans-unit id="8a69aa64125bc041f34a0988fcc820e93ea1cefe" translate="yes" xml:space="preserve">
          <source>Specify a command to execute once per patch file which should generate patch file specific &quot;To:&quot; entries. Output of this command must be single email address per line. Default is the value of &lt;code&gt;sendemail.tocmd&lt;/code&gt; configuration value.</source>
          <target state="translated">패치 파일마다 &quot;To :&quot;항목을 생성해야하는 패치 파일 당 한 번 실행할 명령을 지정하십시오. 이 명령의 출력은 한 줄에 하나의 이메일 주소 여야합니다. 기본값은 &lt;code&gt;sendemail.tocmd&lt;/code&gt; 구성 값입니다.</target>
        </trans-unit>
        <trans-unit id="f6cbbfb6d081efa8553064ef51812c93149ccd37" translate="yes" xml:space="preserve">
          <source>Specify a custom command for viewing diffs. &lt;code&gt;git-difftool&lt;/code&gt; ignores the configured defaults and runs &lt;code&gt;$command $LOCAL $REMOTE&lt;/code&gt; when this option is specified. Additionally, &lt;code&gt;$BASE&lt;/code&gt; is set in the environment.</source>
          <target state="translated">diff를보기위한 사용자 정의 명령을 지정하십시오. &lt;code&gt;git-difftool&lt;/code&gt; 은 구성된 기본값을 무시 하고이 옵션이 지정되면 &lt;code&gt;$command $LOCAL $REMOTE&lt;/code&gt; 실행 합니다. 또한 &lt;code&gt;$BASE&lt;/code&gt; 는 환경에서 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f8f61e37f968bf27d42f1bb30c54e88a19aa0b4c" translate="yes" xml:space="preserve">
          <source>Specify a starting &quot;Cc:&quot; value for each email. Default is the value of &lt;code&gt;sendemail.cc&lt;/code&gt;.</source>
          <target state="translated">각 이메일의 시작 &quot;Cc :&quot;값을 지정하십시오. 기본값은 &lt;code&gt;sendemail.cc&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="d751165243a07b0d8cf01d157a40d624e1274cc2" translate="yes" xml:space="preserve">
          <source>Specify a web browser that may be used by some commands. Currently only &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; and &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt; may use it.</source>
          <target state="translated">일부 명령에서 사용할 수있는 웹 브라우저를 지정하십시오. 현재는 &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt; 및 &lt;a href=&quot;git-help&quot;&gt;git-help [1] 만&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3184d8ec3f5fc0c7b49c79eaaa392759be7aeb74" translate="yes" xml:space="preserve">
          <source>Specify an additional category of recipients to suppress the auto-cc of:</source>
          <target state="translated">받는 사람의 추가 범주를 지정하여 다음과 같은 자동 참조를 억제하십시오.</target>
        </trans-unit>
        <trans-unit id="6c3bb30f438f4e33cf02f17fe7e170959d2a5bad" translate="yes" xml:space="preserve">
          <source>Specify an external helper to be called when a username or password credential is needed; the helper may consult external storage to avoid prompting the user for the credentials. Note that multiple helpers may be defined. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for details.</source>
          <target state="translated">사용자 이름 또는 비밀번호 자격 증명이 필요할 때 호출 할 외부 도우미를 지정하십시오. 도우미는 사용자에게 자격 증명을 요구하지 않도록 외부 저장소를 참조 할 수 있습니다. 여러 헬퍼가 정의 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5898b8f989a6a4118fc60032ee65af46c3876839" translate="yes" xml:space="preserve">
          <source>Specify an external helper to be called when a username or password credential is needed; the helper may consult external storage to avoid prompting the user for the credentials. This is normally the name of a credential helper with possible arguments, but may also be an absolute path with arguments or, if preceded by &lt;code&gt;!&lt;/code&gt;, shell commands.</source>
          <target state="translated">Specify an external helper to be called when a username or password credential is needed; the helper may consult external storage to avoid prompting the user for the credentials. This is normally the name of a credential helper with possible arguments, but may also be an absolute path with arguments or, if preceded by &lt;code&gt;!&lt;/code&gt; , shell commands.</target>
        </trans-unit>
        <trans-unit id="88abf188bf279fdc57952e5f78070fe3d6b977d1" translate="yes" xml:space="preserve">
          <source>Specify an island name which gets to have its objects be packed first. This creates a kind of pseudo-pack at the front of one pack, so that the objects from the specified island are hopefully faster to copy into any pack that should be served to a user requesting these objects. In practice this means that the island specified should likely correspond to what is the most commonly cloned in the repo. See also &quot;DELTA ISLANDS&quot; in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;.</source>
          <target state="translated">객체를 먼저 포장 할 섬 이름을 지정하십시오. 이것은 하나의 팩의 전면에 일종의 유사 팩을 생성하므로 지정된 섬의 객체가 이러한 객체를 요청하는 사용자에게 제공되어야하는 팩으로 복사하는 것이 더 빠릅니다. 실제로 이것은 지정된 섬이 리포지토리에서 가장 일반적으로 복제 된 것과 일치해야 함을 의미합니다. &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]의&lt;/a&gt; &quot;DELTA ISLANDS&quot;도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f4ddca39682ecb94c54d4e5428623a9fabd67c0" translate="yes" xml:space="preserve">
          <source>Specify any of the options listed under OPTIONS that do not change stream semantic to suit the frontend&amp;rsquo;s needs. This command is optional and is not needed to perform an import.</source>
          <target state="translated">프론트 엔드의 요구에 맞게 스트림 의미를 변경하지 않는 OPTIONS 아래에 나열된 옵션을 지정하십시오. 이 명령은 선택 사항이며 가져 오기를 수행 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="126df40ac6c274763f2820bec126088754eb50a7" translate="yes" xml:space="preserve">
          <source>Specify authenticate method for authentication with IMAP server. If Git was built with the NO_CURL option, or if your curl version is older than 7.34.0, or if you&amp;rsquo;re running git-imap-send with the &lt;code&gt;--no-curl&lt;/code&gt; option, the only supported method is &lt;code&gt;CRAM-MD5&lt;/code&gt;. If this is not set then &lt;code&gt;git imap-send&lt;/code&gt; uses the basic IMAP plaintext LOGIN command.</source>
          <target state="translated">IMAP 서버 인증을위한 인증 방법을 지정하십시오. Git이 NO_CURL 옵션으로 빌드되었거나 curl 버전이 7.34.0보다 오래된 경우 또는 &lt;code&gt;--no-curl&lt;/code&gt; 옵션으로 git-imap-send를 실행 하는 경우 지원되는 유일한 방법은 &lt;code&gt;CRAM-MD5&lt;/code&gt; 입니다. 이것이 설정되어 있지 않으면 &lt;code&gt;git imap-send&lt;/code&gt; 는 기본 IMAP 평문 LOGIN 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="db15aaae21c1056154eef62ce5f5cbd5e82beaa7" translate="yes" xml:space="preserve">
          <source>Specify encoding of compose message. Default is the value of the &lt;code&gt;sendemail.composeencoding&lt;/code&gt;; if that is unspecified, UTF-8 is assumed.</source>
          <target state="translated">작성 메시지의 인코딩을 지정하십시오. 기본값은 &lt;code&gt;sendemail.composeencoding&lt;/code&gt; 의 값입니다 . 지정하지 않으면 UTF-8로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="bb2c4dacdd5136c6abef6fcc4de5e9c24a473010" translate="yes" xml:space="preserve">
          <source>Specify how differences in submodules are shown. When specifying &lt;code&gt;--submodule=short&lt;/code&gt; the &lt;code&gt;short&lt;/code&gt; format is used. This format just shows the names of the commits at the beginning and end of the range. When &lt;code&gt;--submodule&lt;/code&gt; or &lt;code&gt;--submodule=log&lt;/code&gt; is specified, the &lt;code&gt;log&lt;/code&gt; format is used. This format lists the commits in the range like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;&lt;code&gt;summary&lt;/code&gt; does. When &lt;code&gt;--submodule=diff&lt;/code&gt; is specified, the &lt;code&gt;diff&lt;/code&gt; format is used. This format shows an inline diff of the changes in the submodule contents between the commit range. Defaults to &lt;code&gt;diff.submodule&lt;/code&gt; or the &lt;code&gt;short&lt;/code&gt; format if the config option is unset.</source>
          <target state="translated">서브 모듈의 차이점을 표시하는 방법을 지정하십시오. &lt;code&gt;--submodule=short&lt;/code&gt; 를 지정 하면 &lt;code&gt;short&lt;/code&gt; 형식이 사용됩니다. 이 형식은 범위의 시작과 끝에서 커밋 이름을 보여줍니다. 때 &lt;code&gt;--submodule&lt;/code&gt; 또는 &lt;code&gt;--submodule=log&lt;/code&gt; 지정되면, &lt;code&gt;log&lt;/code&gt; 형식이 사용됩니다. 이 형식은 &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1] &lt;/a&gt; &lt;code&gt;summary&lt;/code&gt; 과 같은 범위의 커밋을 나열합니다 . 경우 &lt;code&gt;--submodule=diff&lt;/code&gt; 지정되면, &lt;code&gt;diff&lt;/code&gt; 포맷이 사용된다. 이 형식은 커밋 범위 사이의 하위 모듈 내용 변경 내용을 인라인으로 표시합니다. 기본적으로 &lt;code&gt;diff.submodule&lt;/code&gt; 또는 &lt;code&gt;short&lt;/code&gt; 구성 옵션이 설정되지 않은 경우 형식입니다.</target>
        </trans-unit>
        <trans-unit id="e212f603460a2824026571f0244622b2735e495f" translate="yes" xml:space="preserve">
          <source>Specify how multiple patterns are combined using Boolean expressions. &lt;code&gt;--or&lt;/code&gt; is the default operator. &lt;code&gt;--and&lt;/code&gt; has higher precedence than &lt;code&gt;--or&lt;/code&gt;. &lt;code&gt;-e&lt;/code&gt; has to be used for all patterns.</source>
          <target state="translated">부울 표현식을 사용하여 여러 패턴을 결합하는 방법을 지정하십시오. &lt;code&gt;--or&lt;/code&gt; 기본 연산자입니다. &lt;code&gt;--and&lt;/code&gt; 보다 우선 순위가있다 &lt;code&gt;--or&lt;/code&gt; . &lt;code&gt;-e&lt;/code&gt; 는 모든 패턴에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ffbe8c6ac43df98980b6107e62dec3dfa7156507" translate="yes" xml:space="preserve">
          <source>Specify how to handle &lt;code&gt;encoding&lt;/code&gt; header in commit objects. When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering such a commit object. With &lt;code&gt;yes&lt;/code&gt;, the commit message will be re-encoded into UTF-8. With &lt;code&gt;no&lt;/code&gt;, the original encoding will be preserved.</source>
          <target state="translated">커밋 개체에서 &lt;code&gt;encoding&lt;/code&gt; 헤더 를 처리 하는 방법을 지정하십시오 . &lt;code&gt;abort&lt;/code&gt; 요청할 때 (기본값)이 확약 오브젝트가 발생하면이 프로그램이 종료됩니다. 함께 &lt;code&gt;yes&lt;/code&gt; 의 메시지가 재 인코딩 UTF-8로 될 것입니다 커밋. 함께 &lt;code&gt;no&lt;/code&gt; 원래의 인코딩은 보존되지 않는다.</target>
        </trans-unit>
        <trans-unit id="37815a435af244972cccaee7f12b140bf366ab25" translate="yes" xml:space="preserve">
          <source>Specify how to handle signed tags. Since any transformation after the export can change the tag names (which can also happen when excluding revisions) the signatures will not match.</source>
          <target state="translated">서명 된 태그를 처리하는 방법을 지정하십시오. 내 보낸 후 변환하면 태그 이름을 변경할 수 있으므로 (수정을 제외 할 때도 발생할 수 있음) 서명이 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e5b9b1beb3e649edbd3450c18f18cbc2b0b3c2a" translate="yes" xml:space="preserve">
          <source>Specify how to handle tags whose tagged object is filtered out. Since revisions and files to export can be limited by path, tagged objects may be filtered completely.</source>
          <target state="translated">태그가 지정된 객체가 필터링 된 태그를 처리하는 방법을 지정하십시오. 내보낼 개정 및 파일은 경로별로 제한 될 수 있으므로 태그가 지정된 객체가 완전히 필터링 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58a10039b2ffb00f4c15d28cf7a59fdf8252b1ba" translate="yes" xml:space="preserve">
          <source>Specify layout mode. See configuration variable column.ui for option syntax in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">레이아웃 모드를 지정하십시오. &lt;a href=&quot;git-config&quot;&gt;git-config [1]의&lt;/a&gt; 옵션 구문에 대해서는 구성 변수 column.ui를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd9fc5283ae0d7709eafb7d7c044a946ec4a926f" translate="yes" xml:space="preserve">
          <source>Specify submit behavior when a conflict with p4 is found, as per --conflict. The default behavior is &lt;code&gt;ask&lt;/code&gt;.</source>
          <target state="translated">--conflict에 따라 p4와의 충돌이 발견되면 제출 동작을 지정하십시오. 기본 동작은 &lt;code&gt;ask&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6b47b0eac1308c340a251aaa9bc02b368f9e6ec9" translate="yes" xml:space="preserve">
          <source>Specify that the Git repository is to be shared amongst several users. This allows users belonging to the same group to push into that repository. When specified, the config variable &quot;core.sharedRepository&quot; is set so that files and directories under &lt;code&gt;$GIT_DIR&lt;/code&gt; are created with the requested permissions. When not specified, Git will use permissions reported by umask(2).</source>
          <target state="translated">여러 사용자가 Git 저장소를 공유하도록 지정하십시오. 이를 통해 동일한 그룹에 속한 사용자가 해당 저장소로 푸시 할 수 있습니다. 지정된 경우 &quot;core.sharedRepository&quot;구성 변수가 설정되어 &lt;code&gt;$GIT_DIR&lt;/code&gt; GIT_DIR 아래의 파일 및 디렉토리 가 요청 된 권한으로 작성됩니다. 지정하지 않으면 Git은 umask (2)에 의해보고 된 권한을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="553f83584ef890feb9fc0a5fa486ad4027a85d31" translate="yes" xml:space="preserve">
          <source>Specify that the p4 client spec should be used to identify p4 depot paths of interest. This is equivalent to specifying the option &lt;code&gt;--use-client-spec&lt;/code&gt;. See the &quot;CLIENT SPEC&quot; section above. This variable is a boolean, not the name of a p4 client.</source>
          <target state="translated">p4 클라이언트 스펙을 사용하여 관심있는 p4 저장소 경로를 식별하도록 지정하십시오. 이는 &lt;code&gt;--use-client-spec&lt;/code&gt; 옵션을 지정하는 것과 같습니다 . 위의 &quot;CLIENT SPEC&quot;섹션을 참조하십시오. 이 변수는 p4 클라이언트의 이름이 아닌 부울입니다.</target>
        </trans-unit>
        <trans-unit id="ee45839e9a36541472b0e6b0c79bb025ae2d044b" translate="yes" xml:space="preserve">
          <source>Specify the SVN username to perform the commit as. This option overrides the &lt;code&gt;username&lt;/code&gt; configuration property.</source>
          <target state="translated">커밋을 수행 할 SVN 사용자 이름을 지정하십시오. 이 옵션은 &lt;code&gt;username&lt;/code&gt; 구성 속성을 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ce5445a596c457d8087a3ba95eb2c606f830762e" translate="yes" xml:space="preserve">
          <source>Specify the [svn-remote &quot;&amp;lt;remote name&amp;gt;&quot;] section to use, this allows SVN multiple repositories to be tracked. Default: &quot;svn&quot;</source>
          <target state="translated">사용할 [svn-remote &quot;&amp;lt;remote name&amp;gt;&quot;] 섹션을 지정하면 SVN 다중 저장소를 추적 할 수 있습니다. 기본값 : &quot;svn&quot;</target>
        </trans-unit>
        <trans-unit id="9617526476bf00e3e1b98443975d22edd359d482" translate="yes" xml:space="preserve">
          <source>Specify the address where replies from recipients should go to. Use this if replies to messages should go to another address than what is specified with the --from parameter.</source>
          <target state="translated">수신자의 답장을받을 주소를 지정하십시오. 메시지에 대한 회신이 --from 매개 변수로 지정된 주소 이외의 다른 주소로 이동해야하는 경우이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ee03a68cf221fcf3ea580414a042d4bf2bb9f1e8" translate="yes" xml:space="preserve">
          <source>Specify the browser that will be used to display help in the &lt;code&gt;web&lt;/code&gt; format. See &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;web&lt;/code&gt; 형식으로 도움말을 표시하는 데 사용될 브라우저를 지정하십시오 . &lt;a href=&quot;git-help&quot;&gt;git-help [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="70ff10aa9e9d4bf715e29b8e032ab68c07b42b92" translate="yes" xml:space="preserve">
          <source>Specify the bundle version. Version 2 is the older format and can only be used with SHA-1 repositories; the newer version 3 contains capabilities that permit extensions. The default is the oldest supported format, based on the hash algorithm in use.</source>
          <target state="translated">Specify the bundle version. Version 2 is the older format and can only be used with SHA-1 repositories; the newer version 3 contains capabilities that permit extensions. The default is the oldest supported format, based on the hash algorithm in use.</target>
        </trans-unit>
        <trans-unit id="8aa86dc00b5d1ada804b541ee50aabffe17fa3ad" translate="yes" xml:space="preserve">
          <source>Specify the character used to indicate new, old or context lines in the generated patch. Normally they are &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; and ' ' respectively.</source>
          <target state="translated">생성 된 패치에서 신규, 기존 또는 컨텍스트 라인을 나타내는 데 사용되는 문자를 지정하십시오. 일반적으로 각각 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; 및 ''입니다.</target>
        </trans-unit>
        <trans-unit id="966a510a55d7cdd1c3c8b5ab55defa7916878e77" translate="yes" xml:space="preserve">
          <source>Specify the command to invoke the specified browser. The specified command is evaluated in shell with the URLs passed as arguments. (See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt;.)</source>
          <target state="translated">Specify the command to invoke the specified browser. The specified command is evaluated in shell with the URLs passed as arguments. (See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt;.)</target>
        </trans-unit>
        <trans-unit id="cb636a61044a94ec71c2c0e48db959f09a640e28" translate="yes" xml:space="preserve">
          <source>Specify the command to invoke the specified browser. The specified command is evaluated in shell with the URLs passed as arguments. (See git-web{litdd}browse[1].)</source>
          <target state="translated">지정된 브라우저를 호출하는 명령을 지정하십시오. 지정된 명령은 URL로 인수로 전달 된 쉘에서 평가됩니다. (git-web {litdd} browse [1]을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="f8ec599a595d519e45f7089bd76b8eb2f0cf86d7" translate="yes" xml:space="preserve">
          <source>Specify the command to invoke the specified diff tool.</source>
          <target state="translated">지정된 diff 도구를 호출하는 명령을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="045550ad84d88752a76cca9657a08fe5f6314875" translate="yes" xml:space="preserve">
          <source>Specify the command to invoke the specified diff tool. The specified command is evaluated in shell with the following variables available: &lt;code&gt;LOCAL&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff pre-image and &lt;code&gt;REMOTE&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff post-image.</source>
          <target state="translated">지정된 diff 도구를 호출하는 명령을 지정하십시오. 지정된 명령은 사용 가능한 다음 변수를 사용하여 쉘에서 평가됩니다. &lt;code&gt;LOCAL&lt;/code&gt; 은 diff pre-image 의 내용을 포함하는 임시 파일 이름으로 설정 되고 &lt;code&gt;REMOTE&lt;/code&gt; 는 diff post의 내용을 포함하는 임시 파일 이름으로 설정됩니다. -영상.</target>
        </trans-unit>
        <trans-unit id="a4e7d7e1334d2dbe270d234d60ef8777bddd17c9" translate="yes" xml:space="preserve">
          <source>Specify the command to invoke the specified man viewer. The specified command is evaluated in shell with the man page passed as argument. (See &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;.)</source>
          <target state="translated">지정된 man viewer를 호출하는 명령을 지정하십시오. 지정된 명령은 셸에서 man 페이지가 인수로 전달되어 평가됩니다. ( &lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="3a2ff684c7c448a4b91310593e49dad0e76d3118" translate="yes" xml:space="preserve">
          <source>Specify the command to invoke the specified merge tool. The specified command is evaluated in shell with the following variables available: &lt;code&gt;BASE&lt;/code&gt; is the name of a temporary file containing the common base of the files to be merged, if available; &lt;code&gt;LOCAL&lt;/code&gt; is the name of a temporary file containing the contents of the file on the current branch; &lt;code&gt;REMOTE&lt;/code&gt; is the name of a temporary file containing the contents of the file from the branch being merged; &lt;code&gt;MERGED&lt;/code&gt; contains the name of the file to which the merge tool should write the results of a successful merge.</source>
          <target state="translated">지정된 병합 도구를 호출하는 명령을 지정하십시오. 지정된 명령은 사용 가능한 다음 변수를 사용하여 쉘에서 평가됩니다. &lt;code&gt;BASE&lt;/code&gt; 는 사용 가능한 경우 병합 될 파일의 ​​공통 기반을 포함하는 임시 파일의 이름입니다. &lt;code&gt;LOCAL&lt;/code&gt; 은 현재 분기의 파일 내용을 포함하는 임시 파일의 이름입니다. &lt;code&gt;REMOTE&lt;/code&gt; 는 병합중인 브랜치의 파일 내용을 포함하는 임시 파일의 이름입니다. &lt;code&gt;MERGED&lt;/code&gt; 는 병합 도구가 성공적인 병합 결과를 작성해야하는 파일 이름을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="6a0cfc4c034bf82c50504b5853ea3a2048b66aa0" translate="yes" xml:space="preserve">
          <source>Specify the default pack index version. Valid values are 1 for legacy pack index used by Git versions prior to 1.5.2, and 2 for the new pack index with capabilities for packs larger than 4 GB as well as proper protection against the repacking of corrupted packs. Version 2 is the default. Note that version 2 is enforced and this config option ignored whenever the corresponding pack is larger than 2 GB.</source>
          <target state="translated">기본 팩 인덱스 버전을 지정하십시오. 유효한 값은 1.5.2 이전의 Git 버전에서 사용 된 레거시 팩 인덱스의 경우 1이고, 4GB보다 큰 팩의 기능이있는 새 팩 인덱스의 경우 2이며 손상된 팩의 재 포장에 대한 적절한 보호입니다. 버전 2가 기본값입니다. 버전 2가 적용되고 해당 팩이 2GB보다 클 때마다이 구성 옵션이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="237b5a9487d0a4c4f3b292963fb14ac9431d7354" translate="yes" xml:space="preserve">
          <source>Specify the directory from which templates will be copied. (See the &quot;TEMPLATE DIRECTORY&quot; section of &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt;.)</source>
          <target state="translated">템플리트를 복사 할 디렉토리를 지정하십시오. ( &lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt; 의 &quot;TEMPLATE DIRECTORY&quot;섹션을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="9e017dab9e6089dc4c6b8916eff9198d29b5fa5a" translate="yes" xml:space="preserve">
          <source>Specify the directory from which templates will be used. (See the &quot;TEMPLATE DIRECTORY&quot; section below.)</source>
          <target state="translated">템플리트를 사용할 디렉토리를 지정하십시오. 아래의 &quot;템플릿 디렉토리&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="10fbc8bd7f7f67034717ffef3bdc652592011a96" translate="yes" xml:space="preserve">
          <source>Specify the directory from which templates will be used; (See the &quot;TEMPLATE DIRECTORY&quot; section of &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt;.)</source>
          <target state="translated">템플리트를 사용할 디렉토리를 지정하십시오. ( &lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt; 의 &quot;TEMPLATE DIRECTORY&quot;섹션을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="6d06560706961e8be925ad5b0c5ec94cdc91c729" translate="yes" xml:space="preserve">
          <source>Specify the encryption to use, either &lt;code&gt;ssl&lt;/code&gt; or &lt;code&gt;tls&lt;/code&gt;. Any other value reverts to plain SMTP. Default is the value of &lt;code&gt;sendemail.smtpEncryption&lt;/code&gt;.</source>
          <target state="translated">사용할 암호화를 &lt;code&gt;ssl&lt;/code&gt; 또는 &lt;code&gt;tls&lt;/code&gt; 로 지정하십시오 . 다른 값은 일반 SMTP로 되돌아갑니다. 기본값은 &lt;code&gt;sendemail.smtpEncryption&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="4d476f2efa135b04b0d382124ae1d7eb2f09baec" translate="yes" xml:space="preserve">
          <source>Specify the envelope sender used to send the emails. This is useful if your default address is not the address that is subscribed to a list. In order to use the &lt;code&gt;From&lt;/code&gt; address, set the value to &quot;auto&quot;. If you use the sendmail binary, you must have suitable privileges for the -f parameter. Default is the value of the &lt;code&gt;sendemail.envelopeSender&lt;/code&gt; configuration variable; if that is unspecified, choosing the envelope sender is left to your MTA.</source>
          <target state="translated">이메일을 보내는 데 사용되는 봉투 발신자를 지정하십시오. 기본 주소가 목록에 등록 된 주소가 아닌 경우에 유용합니다. &lt;code&gt;From&lt;/code&gt; 주소 를 사용하려면 값을 &quot;auto&quot;로 설정하십시오. sendmail 바이너리를 사용하는 경우 -f 매개 변수에 대한 적절한 권한이 있어야합니다. 기본값은 &lt;code&gt;sendemail.envelopeSender&lt;/code&gt; 구성 변수 의 값입니다 . 지정하지 않으면 봉투 발신자를 선택하는 것이 MTA에 맡겨집니다.</target>
        </trans-unit>
        <trans-unit id="57154856f70bd26e9f32c73474da174dbb6a71bf" translate="yes" xml:space="preserve">
          <source>Specify the format in which differences in submodules are shown. The &quot;short&quot; format just shows the names of the commits at the beginning and end of the range. The &quot;log&quot; format lists the commits in the range like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;&lt;code&gt;summary&lt;/code&gt; does. The &quot;diff&quot; format shows an inline diff of the changed contents of the submodule. Defaults to &quot;short&quot;.</source>
          <target state="translated">서브 모듈의 차이점이 표시되는 형식을 지정하십시오. &quot;짧은&quot;형식은 범위의 시작과 끝에서 커밋 이름을 보여줍니다. &quot;log&quot;형식은 &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1] &lt;/a&gt; &lt;code&gt;summary&lt;/code&gt; 과 같은 범위의 커밋을 나열합니다 . &quot;diff&quot;형식은 서브 모듈의 변경된 내용의 인라인 diff를 보여줍니다. 기본값은 &quot;짧음&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="ee4e54ea6641c26749f683e2086f11110bfcb031" translate="yes" xml:space="preserve">
          <source>Specify the full path of &lt;code&gt;git-upload-pack&lt;/code&gt; on the remote host. This allows listing references from repositories accessed via SSH and where the SSH daemon does not use the PATH configured by the user.</source>
          <target state="translated">원격 호스트에서 &lt;code&gt;git-upload-pack&lt;/code&gt; 의 전체 경로를 지정하십시오 . 이를 통해 SSH를 통해 액세스 한 저장소 및 SSH 디먼이 사용자가 구성한 PATH를 사용하지 않는 저장소의 참조를 나열 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06ad205dd66ffad363b165c748636d60b7e9ddfc" translate="yes" xml:space="preserve">
          <source>Specify the given object format (hash algorithm) for the index file. The valid values are &lt;code&gt;sha1&lt;/code&gt; and (if enabled) &lt;code&gt;sha256&lt;/code&gt;. The default is the algorithm for the current repository (set by &lt;code&gt;extensions.objectFormat&lt;/code&gt;), or &lt;code&gt;sha1&lt;/code&gt; if no value is set or outside a repository..</source>
          <target state="translated">Specify the given object format (hash algorithm) for the index file. The valid values are &lt;code&gt;sha1&lt;/code&gt; and (if enabled) &lt;code&gt;sha256&lt;/code&gt; . The default is the algorithm for the current repository (set by &lt;code&gt;extensions.objectFormat&lt;/code&gt; ), or &lt;code&gt;sha1&lt;/code&gt; if no value is set or outside a repository..</target>
        </trans-unit>
        <trans-unit id="2b5df638fbdbefd14fe565482082a779d66f41cb" translate="yes" xml:space="preserve">
          <source>Specify the given object format (hash algorithm) for the pack. The valid values are &lt;code&gt;sha1&lt;/code&gt; and (if enabled) &lt;code&gt;sha256&lt;/code&gt;. The default is the algorithm for the current repository (set by &lt;code&gt;extensions.objectFormat&lt;/code&gt;), or &lt;code&gt;sha1&lt;/code&gt; if no value is set or outside a repository.</source>
          <target state="translated">Specify the given object format (hash algorithm) for the pack. The valid values are &lt;code&gt;sha1&lt;/code&gt; and (if enabled) &lt;code&gt;sha256&lt;/code&gt; . The default is the algorithm for the current repository (set by &lt;code&gt;extensions.objectFormat&lt;/code&gt; ), or &lt;code&gt;sha1&lt;/code&gt; if no value is set or outside a repository.</target>
        </trans-unit>
        <trans-unit id="14a57f9547f120982212f828efa3a309472cc768" translate="yes" xml:space="preserve">
          <source>Specify the given object format (hash algorithm) for the repository. The valid values are &lt;code&gt;sha1&lt;/code&gt; and (if enabled) &lt;code&gt;sha256&lt;/code&gt;. &lt;code&gt;sha1&lt;/code&gt; is the default.</source>
          <target state="translated">Specify the given object format (hash algorithm) for the repository. The valid values are &lt;code&gt;sha1&lt;/code&gt; and (if enabled) &lt;code&gt;sha256&lt;/code&gt; . &lt;code&gt;sha1&lt;/code&gt; is the default.</target>
        </trans-unit>
        <trans-unit id="642e4180256fc24e29fea6cad40cadddb83843bb" translate="yes" xml:space="preserve">
          <source>Specify the hash algorithm to use. The acceptable values are &lt;code&gt;sha1&lt;/code&gt; and &lt;code&gt;sha256&lt;/code&gt;. If not specified, &lt;code&gt;sha1&lt;/code&gt; is assumed. It is an error to specify this key unless &lt;code&gt;core.repositoryFormatVersion&lt;/code&gt; is 1.</source>
          <target state="translated">Specify the hash algorithm to use. The acceptable values are &lt;code&gt;sha1&lt;/code&gt; and &lt;code&gt;sha256&lt;/code&gt; . If not specified, &lt;code&gt;sha1&lt;/code&gt; is assumed. It is an error to specify this key unless &lt;code&gt;core.repositoryFormatVersion&lt;/code&gt; is 1.</target>
        </trans-unit>
        <trans-unit id="e05f34f2b12543d24deddf183d7f5563e4746b8d" translate="yes" xml:space="preserve">
          <source>Specify the initial subject of the email thread. Only necessary if --compose is also set. If --compose is not set, this will be prompted for.</source>
          <target state="translated">이메일 스레드의 초기 제목을 지정하십시오. --compose도 설정 한 경우에만 필요합니다. --compose가 설정되어 있지 않으면 프롬프트가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7f0e894272a77fe6a04290fbdb329a63eb87bf76" translate="yes" xml:space="preserve">
          <source>Specify the layout when list items in &lt;code&gt;git clean -i&lt;/code&gt;, which always shows files and directories in columns. See &lt;code&gt;column.ui&lt;/code&gt; for details.</source>
          <target state="translated">&lt;code&gt;git clean -i&lt;/code&gt; 에 목록 항목이있을 때 레이아웃을 지정하십시오. 항상 파일과 디렉토리를 열로 표시합니다. 자세한 내용은 &lt;code&gt;column.ui&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f7208179bdf36d6bc3e9b1d1f4f91288e1356b3f" translate="yes" xml:space="preserve">
          <source>Specify the location of the CVS checkout to use for the export. This option does not require GIT_DIR to be set before execution if the current directory is within a Git repository. The default is the value of &lt;code&gt;cvsexportcommit.cvsdir&lt;/code&gt;.</source>
          <target state="translated">내보내기에 사용할 CVS 체크 아웃 위치를 지정하십시오. 현재 디렉토리가 Git 저장소 내에있는 경우이 옵션을 실행하기 전에 GIT_DIR을 설정할 필요가 없습니다. 기본값은 &lt;code&gt;cvsexportcommit.cvsdir&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="4c1271576d0edb7f1f0d6c8d0d3f48964a9bd30e" translate="yes" xml:space="preserve">
          <source>Specify the most recent revision to keep. All later revisions are discarded.</source>
          <target state="translated">유지할 최신 개정판을 지정하십시오. 이후의 모든 개정은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="dbfd748a4216557f92920425eee493e6f587b7d2" translate="yes" xml:space="preserve">
          <source>Specify the name of a CVS checkout using the -w switch or execute it from the root of the CVS working copy. In the latter case GIT_DIR must be defined. See examples below.</source>
          <target state="translated">-w 스위치를 사용하여 CVS 체크 아웃 이름을 지정하거나 CVS 작업 사본의 루트에서 실행하십시오. 후자의 경우 GIT_DIR을 정의해야합니다. 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6f5685351080bbe842e1b77f6e72d7f56e71124e" translate="yes" xml:space="preserve">
          <source>Specify the path where the HTML documentation resides. File system paths and URLs are supported. HTML pages will be prefixed with this path when help is displayed in the &lt;code&gt;web&lt;/code&gt; format. This defaults to the documentation path of your Git installation.</source>
          <target state="translated">HTML 문서가있는 경로를 지정하십시오. 파일 시스템 경로 및 URL이 지원됩니다. &lt;code&gt;web&lt;/code&gt; 형식으로 도움말이 표시되면 HTML 페이지 앞에이 경로가 접두어로 표시됩니다 . 기본적으로 Git 설치의 문서 경로입니다.</target>
        </trans-unit>
        <trans-unit id="3939c032cc21518f83cfc7e855a79944401164b0" translate="yes" xml:space="preserve">
          <source>Specify the pathname of a file to use as the template for new commit messages.</source>
          <target state="translated">새 커밋 메시지의 템플리트로 사용할 파일의 경로 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="626310e55266a25c38521d0786f942652add8252" translate="yes" xml:space="preserve">
          <source>Specify the primary recipient of the emails generated. Generally, this will be the upstream maintainer of the project involved. Default is the value of the &lt;code&gt;sendemail.to&lt;/code&gt; configuration value; if that is unspecified, and --to-cmd is not specified, this will be prompted for.</source>
          <target state="translated">생성 된 이메일의 기본 수신자를 지정하십시오. 일반적으로 이것은 관련된 프로젝트의 업스트림 관리자가됩니다. 기본값은 &lt;code&gt;sendemail.to&lt;/code&gt; 구성 값입니다. 지정하지 않고 --to-cmd를 지정하지 않으면 프롬프트가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="904cbddb8fe90053f040a40b660f937c8ee221c5" translate="yes" xml:space="preserve">
          <source>Specify the program that will be used to browse your working repository in gitweb. See &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;.</source>
          <target state="translated">gitweb에서 작업 저장소를 탐색하는 데 사용될 프로그램을 지정하십시오. &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="87648a4a4b9f3684c45dea895b93d3728e0b89f7" translate="yes" xml:space="preserve">
          <source>Specify the programs that may be used to display help in the &lt;code&gt;man&lt;/code&gt; format. See &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;man&lt;/code&gt; 형식으로 도움말을 표시하는 데 사용할 수있는 프로그램을 지정하십시오 . &lt;a href=&quot;git-help&quot;&gt;git-help [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c051775f78daae77408669a949bcd688ddbd949c" translate="yes" xml:space="preserve">
          <source>Specify the restore location. If neither option is specified, by default the working tree is restored. Specifying &lt;code&gt;--staged&lt;/code&gt; will only restore the index. Specifying both restores both.</source>
          <target state="translated">복원 위치를 지정하십시오. 옵션을 지정하지 않으면 기본적으로 작업 트리가 복원됩니다. &lt;code&gt;--staged&lt;/code&gt; 를 지정 하면 인덱스 만 복원됩니다. 둘 다 지정하면 둘 다 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="95b7f682630cddb98a68355ef07c41860159997c" translate="yes" xml:space="preserve">
          <source>Specify the sender of the emails. If not specified on the command line, the value of the &lt;code&gt;sendemail.from&lt;/code&gt; configuration option is used. If neither the command-line option nor &lt;code&gt;sendemail.from&lt;/code&gt; are set, then the user will be prompted for the value. The default for the prompt will be the value of GIT_AUTHOR_IDENT, or GIT_COMMITTER_IDENT if that is not set, as returned by &quot;git var -l&quot;.</source>
          <target state="translated">이메일 발신자를 지정하십시오. 명령 행에 지정되지 않은 경우 &lt;code&gt;sendemail.from&lt;/code&gt; 구성 옵션 의 값 이 사용됩니다. 명령 줄 옵션이나 &lt;code&gt;sendemail.from&lt;/code&gt; 을 설정 하지 않으면 값을 입력하라는 메시지가 표시됩니다. 프롬프트의 기본값은 &quot;git var -l&quot;에 의해 리턴되는 GIT_AUTHOR_IDENT의 값이거나 설정되지 않은 경우 GIT_COMMITTER_IDENT입니다.</target>
        </trans-unit>
        <trans-unit id="8cba2f98ceccc0dae91e3c30287bb75513f4e951" translate="yes" xml:space="preserve">
          <source>Specify the style in which conflicted hunks are written out to working tree files upon merge. The default is &quot;merge&quot;, which shows a &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; conflict marker, changes made by one side, a &lt;code&gt;=======&lt;/code&gt; marker, changes made by the other side, and then a &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; marker. An alternate style, &quot;diff3&quot;, adds a &lt;code&gt;|||||||&lt;/code&gt; marker and the original text before the &lt;code&gt;=======&lt;/code&gt; marker.</source>
          <target state="translated">병합시 충돌하는 덩어리가 작업 트리 파일에 기록되는 스타일을 지정하십시오. 기본값은 &quot;병합&quot;으로, &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; 충돌 마커, 한 쪽의 변경 사항, &lt;code&gt;=======&lt;/code&gt; 마커, 다른 쪽의 변경 사항, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 마커. 대체 스타일 &quot;diff3&quot;은 &lt;code&gt;|||||||&lt;/code&gt; 마커와 &lt;code&gt;=======&lt;/code&gt; 마커 앞의 원본 텍스트 .</target>
        </trans-unit>
        <trans-unit id="d1c5be6270e8c898e52c9ccc68e940ca06ec404b" translate="yes" xml:space="preserve">
          <source>Specify the system that is used for large (binary) files. Please note that large file systems do not support the &lt;code&gt;git p4 submit&lt;/code&gt; command. Only Git LFS is implemented right now (see &lt;a href=&quot;https://git-lfs.github.com/&quot;&gt;https://git-lfs.github.com/&lt;/a&gt; for more information). Download and install the Git LFS command line extension to use this option and configure it like this:</source>
          <target state="translated">큰 (이진) 파일에 사용되는 시스템을 지정하십시오. 큰 파일 시스템은 &lt;code&gt;git p4 submit&lt;/code&gt; 명령을 지원하지 않습니다 . 현재 Git LFS 만 구현되어 있습니다 ( 자세한 내용 은 &lt;a href=&quot;https://git-lfs.github.com/&quot;&gt;https://git-lfs.github.com/&lt;/a&gt; 참조 ). 이 옵션을 사용하려면 Git LFS 명령 행 확장을 다운로드하여 설치하고 다음과 같이 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="d0eef78fea38d4df295115dcb10e8e7ee7e56973" translate="yes" xml:space="preserve">
          <source>Specify the terminal width. By default &lt;code&gt;git column&lt;/code&gt; will detect the terminal width, or fall back to 80 if it is unable to do so.</source>
          <target state="translated">터미널 너비를 지정하십시오. 기본적으로 &lt;code&gt;git column&lt;/code&gt; 은 터미널 너비를 감지하거나, 그렇지 않으면 80 으로 줄어 듭니다 .</target>
        </trans-unit>
        <trans-unit id="724bb2755b4bad5b8b472dcd4850810c5212797c" translate="yes" xml:space="preserve">
          <source>Specify the transfer encoding to be used to send the message over SMTP. 7bit will fail upon encountering a non-ASCII message. quoted-printable can be useful when the repository contains files that contain carriage returns, but makes the raw patch email file (as saved from a MUA) much harder to inspect manually. base64 is even more fool proof, but also even more opaque. auto will use 8bit when possible, and quoted-printable otherwise.</source>
          <target state="translated">SMTP를 통해 메시지를 보내는 데 사용할 전송 인코딩을 지정하십시오. 비 ASCII 메시지가 표시되면 7 비트가 실패합니다. quoted-printable은 저장소에 캐리지 리턴이 포함 된 파일이 포함되어 있지만 MUA에서 저장된 원시 패치 이메일 파일을 수동으로 검사하기가 훨씬 더 어려울 때 유용 할 수 있습니다. base64는 더 어리석은 증거이지만 더 불투명합니다. auto는 가능한 경우 8 비트를 사용하고 그렇지 않으면 인용 인쇄 가능합니다.</target>
        </trans-unit>
        <trans-unit id="9612f0c17aac603d9a46ca6cb5d976f3bf4c5bf3" translate="yes" xml:space="preserve">
          <source>Specify the type (default: &quot;blob&quot;).</source>
          <target state="translated">유형을 지정하십시오 (기본값 : &quot;blob&quot;).</target>
        </trans-unit>
        <trans-unit id="13769f1d436d268baed7051a7c066221785b088a" translate="yes" xml:space="preserve">
          <source>Specify the type of dates the frontend will supply to fast-import within &lt;code&gt;author&lt;/code&gt;, &lt;code&gt;committer&lt;/code&gt; and &lt;code&gt;tagger&lt;/code&gt; commands. See &amp;ldquo;Date Formats&amp;rdquo; below for details about which formats are supported, and their syntax.</source>
          <target state="translated">프론트 엔드 내에서 빠르게 수입에 알려 주어야합니다 날짜의 유형을 지정 &lt;code&gt;author&lt;/code&gt; , &lt;code&gt;committer&lt;/code&gt; 와 &lt;code&gt;tagger&lt;/code&gt; 명령을. 지원되는 형식 및 구문에 대한 자세한 내용은 아래의 &quot;날짜 형식&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="19ebff060f03d17e125a48bf86da29f25cd1bf35" translate="yes" xml:space="preserve">
          <source>Specify the version with which new index files should be initialized. This does not affect existing repositories. If &lt;code&gt;feature.manyFiles&lt;/code&gt; is enabled, then the default is 4.</source>
          <target state="translated">새 색인 파일을 초기화 할 버전을 지정하십시오. 기존 리포지토리에는 영향을 미치지 않습니다. &lt;code&gt;feature.manyFiles&lt;/code&gt; 가 사용 가능한 경우 기본값은 4입니다.</target>
        </trans-unit>
        <trans-unit id="1dcaca1644c579ca7480d7fe912a3d5f89533d59" translate="yes" xml:space="preserve">
          <source>Specify what action will be performed when there is already at least one trailer with the same &amp;lt;token&amp;gt; in the message. A setting provided with &lt;code&gt;--if-exists&lt;/code&gt; overrides all configuration variables and applies to all &lt;code&gt;--trailer&lt;/code&gt; options until the next occurrence of &lt;code&gt;--if-exists&lt;/code&gt; or &lt;code&gt;--no-if-exists&lt;/code&gt;. Possible actions are &lt;code&gt;addIfDifferent&lt;/code&gt;, &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt; and &lt;code&gt;doNothing&lt;/code&gt;.</source>
          <target state="translated">메시지에 &amp;lt;토큰&amp;gt;이 같은 트레일러가 이미 하나 이상있을 때 수행 할 작업을 지정하십시오. &lt;code&gt;--trailer&lt;/code&gt; &lt;code&gt;--if-exists&lt;/code&gt; 와 함께 제공되는 설정 은 모든 구성 변수를 무시 하고 다음 번 --if &lt;code&gt;--if-exists&lt;/code&gt; 또는 &lt;code&gt;--no-if-exists&lt;/code&gt; 가 나타날 때까지 모든 --trailer 옵션에 적용됩니다 . 가능한 조치는 &lt;code&gt;addIfDifferent&lt;/code&gt; , &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; , &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;replace&lt;/code&gt; 및 &lt;code&gt;doNothing&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0811642f4a0657e779f7ae4b567538044cd6208f" translate="yes" xml:space="preserve">
          <source>Specify what action will be performed when there is no other trailer with the same &amp;lt;token&amp;gt; in the message. A setting provided with &lt;code&gt;--if-missing&lt;/code&gt; overrides all configuration variables and applies to all &lt;code&gt;--trailer&lt;/code&gt; options until the next occurrence of &lt;code&gt;--if-missing&lt;/code&gt; or &lt;code&gt;--no-if-missing&lt;/code&gt;. Possible actions are &lt;code&gt;doNothing&lt;/code&gt; or &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">메시지에 &amp;lt;토큰&amp;gt;이 같은 다른 트레일러가 없을 때 수행 할 작업을 지정하십시오. &lt;code&gt;--trailer&lt;/code&gt; &lt;code&gt;--if-missing&lt;/code&gt; 과 함께 제공되는 설정 은 모든 구성 변수를 무시 하고 다음 번 --if &lt;code&gt;--if-missing&lt;/code&gt; 또는 &lt;code&gt;--no-if-missing&lt;/code&gt; 이 나타날 때까지 모든 --trailer 옵션에 적용됩니다 . 가능한 조치는 &lt;code&gt;doNothing&lt;/code&gt; 또는 &lt;code&gt;add&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4d686969af43bc9772a0a2bdde0f0d6918dfd1d4" translate="yes" xml:space="preserve">
          <source>Specify what destination ref to update with what source object. The format of a &amp;lt;refspec&amp;gt; parameter is an optional plus &lt;code&gt;+&lt;/code&gt;, followed by the source object &amp;lt;src&amp;gt;, followed by a colon &lt;code&gt;:&lt;/code&gt;, followed by the destination ref &amp;lt;dst&amp;gt;.</source>
          <target state="translated">어떤 소스 오브젝트로 업데이트 할 대상 참조를 지정하십시오. &amp;lt;refspec&amp;gt; 매개 변수의 형식은 선택적인 plus &lt;code&gt;+&lt;/code&gt; , 소스 오브젝트 &amp;lt;src&amp;gt;, 콜론 &lt;code&gt;:&lt;/code&gt; , 목적지 ref &amp;lt;dst&amp;gt;입니다.</target>
        </trans-unit>
        <trans-unit id="6138b51fead99efbf1d6930137f2b387251ef604" translate="yes" xml:space="preserve">
          <source>Specify where all new trailers will be added. A setting provided with &lt;code&gt;--where&lt;/code&gt; overrides all configuration variables and applies to all &lt;code&gt;--trailer&lt;/code&gt; options until the next occurrence of &lt;code&gt;--where&lt;/code&gt; or &lt;code&gt;--no-where&lt;/code&gt;. Possible values are &lt;code&gt;after&lt;/code&gt;, &lt;code&gt;before&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt; or &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="translated">모든 새 예고편을 추가 할 위치를 지정하십시오. 제공된 설정 &lt;code&gt;--where&lt;/code&gt; 는 모든 구성 변수를 무시하고 모든 적용 &lt;code&gt;--trailer&lt;/code&gt; 다음 발생까지 옵션 &lt;code&gt;--where&lt;/code&gt; 또는 &lt;code&gt;--no-where&lt;/code&gt; . 가능한 값은 &lt;code&gt;after&lt;/code&gt; , &lt;code&gt;before&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; 또는 &lt;code&gt;start&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9446eb9819e4ea522bac17e494630aff8d54bebb" translate="yes" xml:space="preserve">
          <source>Specify whether supported commands should output in columns. This variable consists of a list of tokens separated by spaces or commas:</source>
          <target state="translated">지원되는 명령이 열로 출력되어야하는지 여부를 지정하십시오. 이 변수는 공백 또는 쉼표로 구분 된 토큰 목록으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c44825f076cf0385d99447ca6f9388f9e5d821d6" translate="yes" xml:space="preserve">
          <source>Specify whether to output branch listing in &lt;code&gt;git branch&lt;/code&gt; in columns. See &lt;code&gt;column.ui&lt;/code&gt; for details.</source>
          <target state="translated">&lt;code&gt;git branch&lt;/code&gt; 의 분기 목록 을 열로 출력할지 여부를 지정하십시오 . 자세한 내용은 &lt;code&gt;column.ui&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eb8ddb4258375ad9322849684e1d07ab6e005bcd" translate="yes" xml:space="preserve">
          <source>Specify whether to output tag listing in &lt;code&gt;git tag&lt;/code&gt; in columns. See &lt;code&gt;column.ui&lt;/code&gt; for details.</source>
          <target state="translated">태그 목록을 &lt;code&gt;git tag&lt;/code&gt; 로 열로 출력할지 여부를 지정하십시오 . 자세한 내용은 &lt;code&gt;column.ui&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7607c69174b01d1bb15ae17f25fe8a2d96f9d58f" translate="yes" xml:space="preserve">
          <source>Specify whether to output untracked files in &lt;code&gt;git status&lt;/code&gt; in columns. See &lt;code&gt;column.ui&lt;/code&gt; for details.</source>
          <target state="translated">추적되지 않은 파일을 &lt;code&gt;git status&lt;/code&gt; 에서 열로 출력할지 여부를 지정하십시오 . 자세한 내용은 &lt;code&gt;column.ui&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b984e35657451690beb2903dd3dd6390cb372f55" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;--no-symlinks&lt;/code&gt; instructs &lt;code&gt;git difftool&lt;/code&gt; to create copies instead. &lt;code&gt;--no-symlinks&lt;/code&gt; is the default on Windows.</source>
          <target state="translated">&lt;code&gt;--no-symlinks&lt;/code&gt; 를 지정 하면 &lt;code&gt;git difftool&lt;/code&gt; 이 대신 사본을 작성 하도록 지시 합니다. &lt;code&gt;--no-symlinks&lt;/code&gt; 는 Windows의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="3b6b4914f3cbc4ad3df641c0c4177b0ed1427ac9" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;-b&lt;/code&gt; causes a new branch to be created as if &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; were called and then checked out. In this case you can use the &lt;code&gt;--track&lt;/code&gt; or &lt;code&gt;--no-track&lt;/code&gt; options, which will be passed to &lt;code&gt;git branch&lt;/code&gt;. As a convenience, &lt;code&gt;--track&lt;/code&gt; without &lt;code&gt;-b&lt;/code&gt; implies branch creation; see the description of &lt;code&gt;--track&lt;/code&gt; below.</source>
          <target state="translated">&lt;code&gt;-b&lt;/code&gt; 를 지정 하면 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; 이 호출 된 다음 체크 아웃 된 것처럼 새 분기가 작성됩니다 . 이 경우 &lt;code&gt;--track&lt;/code&gt; 또는 &lt;code&gt;--no-track&lt;/code&gt; 옵션을 사용할 수 있습니다.이 옵션은 &lt;code&gt;git branch&lt;/code&gt; 로 전달됩니다 . 편의상, &lt;code&gt;--track&lt;/code&gt; 없이 &lt;code&gt;-b&lt;/code&gt; 이 지점 생성을 의미한다; 아래 &lt;code&gt;--track&lt;/code&gt; 에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d1224dfe57ea23830be77ce6389d9ea1f14e370" translate="yes" xml:space="preserve">
          <source>Specifying ranges</source>
          <target state="translated">범위 지정</target>
        </trans-unit>
        <trans-unit id="c7c8ec2e47baa0d09987a0c4d6001b20abaaf2b4" translate="yes" xml:space="preserve">
          <source>Specifying references</source>
          <target state="translated">참조 지정</target>
        </trans-unit>
        <trans-unit id="393f3ea7b8cd86c4b234c1534e51343677169802" translate="yes" xml:space="preserve">
          <source>Specifying revisions</source>
          <target state="translated">개정판 지정</target>
        </trans-unit>
        <trans-unit id="313d53ccb2201ad1fa56898f5e4fcf52a12b8cf8" translate="yes" xml:space="preserve">
          <source>Specifying revisions and ranges for Git</source>
          <target state="translated">Specifying revisions and ranges for Git</target>
        </trans-unit>
        <trans-unit id="3c37f7a18e7a3b3fd20a0b124dbe1485c84e7ed4" translate="yes" xml:space="preserve">
          <source>Specifying several revisions means the set of commits reachable from any of the given commits.</source>
          <target state="translated">Specifying several revisions means the set of commits reachable from any of the given commits.</target>
        </trans-unit>
        <trans-unit id="b0e60ddbfcfcb7ed6ee3dbb9222a892aaa26a36d" translate="yes" xml:space="preserve">
          <source>Specifying the location of the &quot;.git&quot; directory using this option (or &lt;code&gt;GIT_DIR&lt;/code&gt; environment variable) turns off the repository discovery that tries to find a directory with &quot;.git&quot; subdirectory (which is how the repository and the top-level of the working tree are discovered), and tells Git that you are at the top level of the working tree. If you are not at the top-level directory of the working tree, you should tell Git where the top-level of the working tree is, with the &lt;code&gt;--work-tree=&amp;lt;path&amp;gt;&lt;/code&gt; option (or &lt;code&gt;GIT_WORK_TREE&lt;/code&gt; environment variable)</source>
          <target state="translated">Specifying the location of the &quot;.git&quot; directory using this option (or &lt;code&gt;GIT_DIR&lt;/code&gt; environment variable) turns off the repository discovery that tries to find a directory with &quot;.git&quot; subdirectory (which is how the repository and the top-level of the working tree are discovered), and tells Git that you are at the top level of the working tree. If you are not at the top-level directory of the working tree, you should tell Git where the top-level of the working tree is, with the &lt;code&gt;--work-tree=&amp;lt;path&amp;gt;&lt;/code&gt; option (or &lt;code&gt;GIT_WORK_TREE&lt;/code&gt; environment variable)</target>
        </trans-unit>
        <trans-unit id="c12054d536cbd9889e1a4db4d75b48d8a7f03cd2" translate="yes" xml:space="preserve">
          <source>Specifying the refs</source>
          <target state="translated">심판 지정</target>
        </trans-unit>
        <trans-unit id="31f2abfdb1a3e7bab64495f843d089d388ea45e0" translate="yes" xml:space="preserve">
          <source>Spend extra cycles to find renames, copies and complete rewrites (very expensive).</source>
          <target state="translated">추가주기를 사용하여 이름 변경, 복사 및 전체 재 작성을 찾을 수 있습니다 (매우 비쌉니다).</target>
        </trans-unit>
        <trans-unit id="6b695c34f0798ffd5026fe42cf041af8a841d861" translate="yes" xml:space="preserve">
          <source>Spend extra time to make sure the smallest possible diff is produced.</source>
          <target state="translated">가장 작은 diff가 만들어 지도록 여분의 시간을 보내십시오.</target>
        </trans-unit>
        <trans-unit id="8622c4dc8f748203e018cc0d2ec4e20b07c9830d" translate="yes" xml:space="preserve">
          <source>Split a commit apart into a sequence of commits</source>
          <target state="translated">커밋을 일련의 커밋으로 분리</target>
        </trans-unit>
        <trans-unit id="9da7a78d6cd0199fb3cad874edd1ba683b830e12" translate="yes" xml:space="preserve">
          <source>Split index</source>
          <target state="translated">분할 인덱스</target>
        </trans-unit>
        <trans-unit id="704e5487b89b9b30fcd9e576ab8763e642a1b938" translate="yes" xml:space="preserve">
          <source>Splits a mbox file or a Maildir into a list of files: &quot;0001&quot; &quot;0002&quot; .. in the specified directory so you can process them further from there.</source>
          <target state="translated">mbox 파일 또는 Maildir을 지정된 디렉토리에있는 파일 목록 &quot;0001&quot; &quot;0002&quot;..로 분할하여 거기서 더 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="30bc5e98fc4346f828d1d387cd6e1c89bab7df56" translate="yes" xml:space="preserve">
          <source>Splits mail messages in a mailbox into commit log message, authorship information and patches, and applies them to the current branch.</source>
          <target state="translated">사서함의 메일 메시지를 커밋 로그 메시지, 제작 정보 및 패치로 분할하여 현재 분기에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="05a6d55bcdcfd4539a8e45cc0dd3c2f28f1895ad" translate="yes" xml:space="preserve">
          <source>Splitting a (logically single) project into multiple repositories and tying them back together. This can be used to overcome current limitations of Git&amp;rsquo;s implementation to have finer grained access:</source>
          <target state="translated">(논리적으로 단일 한) 프로젝트를 여러 저장소로 나누고 다시 묶습니다. 이것은 Git 구현의 현재 제한을 극복하여 세분화 된 액세스를 갖도록 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dca5d29240b446b8bdd6f26fb0b4e46cb995769f" translate="yes" xml:space="preserve">
          <source>Splitting commits</source>
          <target state="translated">커밋 분할</target>
        </trans-unit>
        <trans-unit id="ab83ac1fcfed8f50260b11e517c47e9b533419b5" translate="yes" xml:space="preserve">
          <source>Splitting the CVS log into patch sets is done by &lt;code&gt;cvsps&lt;/code&gt;. At least version 2.1 is required.</source>
          <target state="translated">CVS 로그를 패치 세트로 분할하는 것은 &lt;code&gt;cvsps&lt;/code&gt; 에 의해 수행됩니다 . 버전 2.1 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a74a609811ea3b4041281496e2aa5c500ba6558b" translate="yes" xml:space="preserve">
          <source>Sq-quote</source>
          <target state="translated">Sq-quote</target>
        </trans-unit>
        <trans-unit id="d3e10219341e654fff6647b0dadeaeaf0534cae6" translate="yes" xml:space="preserve">
          <source>Squelch the progress indicator.</source>
          <target state="translated">진행 표시기를 que 치십시오.</target>
        </trans-unit>
        <trans-unit id="56175f21751e04201e148f2612c700747850548a" translate="yes" xml:space="preserve">
          <source>Start &lt;code&gt;git gui&lt;/code&gt; and arrange to make exactly one commit before exiting and returning to the shell. The interface is limited to only commit actions, slightly reducing the application&amp;rsquo;s startup time and simplifying the menubar.</source>
          <target state="translated">&lt;code&gt;git gui&lt;/code&gt; 를 시작 하고 종료하고 쉘로 돌아 가기 전에 정확히 하나의 커밋을 준비 하십시오 . 인터페이스는 커밋 작업만으로 제한되어 응용 프로그램의 시작 시간을 약간 줄이고 메뉴 표시 줄을 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="1ad6edca0ad31761798d28bd8f2bcba01ec6ebde" translate="yes" xml:space="preserve">
          <source>Start a blame viewer on the specified file on the given version (or working directory if not specified).</source>
          <target state="translated">지정된 버전 (또는 지정되지 않은 경우 작업 디렉토리)의 지정된 파일에서 Blame Viewer를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="27818282f52d064df23dffafcd6a743ee7870fc8" translate="yes" xml:space="preserve">
          <source>Start a new Git repository for an existing code base</source>
          <target state="translated">기존 코드 기반을위한 새로운 Git 리포지토리 시작</target>
        </trans-unit>
        <trans-unit id="dbad6a143691392b17e55eedf5d0cc7e518343d6" translate="yes" xml:space="preserve">
          <source>Start a transaction. In contrast to a non-transactional session, a transaction will automatically abort if the session ends without an explicit commit.</source>
          <target state="translated">Start a transaction. In contrast to a non-transactional session, a transaction will automatically abort if the session ends without an explicit commit.</target>
        </trans-unit>
        <trans-unit id="749535e22d531edd1c6d9e666c57e169bc2a2908" translate="yes" xml:space="preserve">
          <source>Start a tree browser showing all files in the specified commit. Files selected through the browser are opened in the blame viewer.</source>
          <target state="translated">지정된 커밋의 모든 파일을 보여주는 트리 브라우저를 시작하십시오. 브라우저를 통해 선택한 파일이 Blame Viewer에서 열립니다.</target>
        </trans-unit>
        <trans-unit id="4f65c13509b4c270214524b3ab095bad926fc4e3" translate="yes" xml:space="preserve">
          <source>Start an interactive rebase with &lt;code&gt;git rebase -i &amp;lt;commit&amp;gt;^&lt;/code&gt;, where &amp;lt;commit&amp;gt; is the commit you want to split. In fact, any commit range will do, as long as it contains that commit.</source>
          <target state="translated">&lt;code&gt;git rebase -i &amp;lt;commit&amp;gt;^&lt;/code&gt; 을 사용하여 대화식 리베이스를 시작하십시오. 여기서 &amp;lt;commit&amp;gt;은 분할하려는 커밋입니다. 실제로, 해당 커밋이 포함되어있는 한 모든 커밋 범위가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e89944344f3db8073a18706746155c852e5164e1" translate="yes" xml:space="preserve">
          <source>Start cleaning files and directories, and then quit.</source>
          <target state="translated">파일 및 디렉토리 정리를 시작한 다음 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="b87ef51ca99e7074691b94843e801ff9544539ca" translate="yes" xml:space="preserve">
          <source>Start development from a known tag</source>
          <target state="translated">알려진 태그에서 개발 시작</target>
        </trans-unit>
        <trans-unit id="57f8f31bd16af3371648ce77ae5076e70d2a7e21" translate="yes" xml:space="preserve">
          <source>Start it with the last commit you want to retain as-is:</source>
          <target state="translated">그대로 유지하려는 마지막 커밋으로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="2deb883b26612605cc58ed80bbd657e3f5419b69" translate="yes" xml:space="preserve">
          <source>Start numbering the patches at &amp;lt;n&amp;gt; instead of 1.</source>
          <target state="translated">1 대신 &amp;lt;n&amp;gt;에서 패치 번호를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="f25f51b92f6dabcbe2c2bbe2f01c2d471018dd10" translate="yes" xml:space="preserve">
          <source>Start off with just creating any random files that you want to maintain in your Git repository. We&amp;rsquo;ll start off with a few bad examples, just to get a feel for how this works:</source>
          <target state="translated">Git 리포지토리에서 유지하려는 임의의 파일을 만드는 것부터 시작하십시오. 우리는 이것이 어떻게 작동하는지에 대한 느낌을 얻기 위해 몇 가지 나쁜 예를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="93ea699c6796ebb7b82a3a5927dc702e8f1a7316" translate="yes" xml:space="preserve">
          <source>Start the httpd instance and exit. Regenerate configuration files as necessary for spawning a new instance.</source>
          <target state="translated">httpd 인스턴스를 시작하고 종료하십시오. 새 인스턴스를 생성하는 데 필요한 구성 파일을 재생성하십시오.</target>
        </trans-unit>
        <trans-unit id="4e8cde71c6f29e3b4dc0142edc8a7bdf1a0bc89b" translate="yes" xml:space="preserve">
          <source>Start the stream with a &lt;code&gt;feature done&lt;/code&gt; stanza, and terminate it with a &lt;code&gt;done&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;feature done&lt;/code&gt; 스탠자로 스트림을 시작하고 &lt;code&gt;done&lt;/code&gt; 명령으로 종료하십시오 .</target>
        </trans-unit>
        <trans-unit id="96e592387dc94e730df0ef669b5a78ed012d4c94" translate="yes" xml:space="preserve">
          <source>Starting a bisection</source>
          <target state="translated">이분법 시작</target>
        </trans-unit>
        <trans-unit id="b8f1956c80187223247d01b968f642bf0007a014" translate="yes" xml:space="preserve">
          <source>Starting point at which to create the new commits. If the --onto option is not specified, the starting point is &amp;lt;upstream&amp;gt;. May be any valid commit, and not just an existing branch name.</source>
          <target state="translated">새로운 커밋을 생성하는 시작점. --onto 옵션을 지정하지 않으면 시작 지점은 &amp;lt;업스트림&amp;gt;입니다. 기존 브랜치 이름뿐만 아니라 유효한 커밋 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2a5514cb8b0c290a6aeca31b2e191aff35672b1" translate="yes" xml:space="preserve">
          <source>Stash the changes in a dirty working directory away</source>
          <target state="translated">더티 작업 디렉토리에 변경 사항을 보관하십시오.</target>
        </trans-unit>
        <trans-unit id="9b5a6df7ffb5f85d09cbb9082f2a407aa81ca866" translate="yes" xml:space="preserve">
          <source>State directories: The two backends keep their state in different directories under .git/</source>
          <target state="translated">State directories: The two backends keep their state in different directories under .git/</target>
        </trans-unit>
        <trans-unit id="abb935cbc47e1b75159f277e4b22bfc5de7bbee9" translate="yes" xml:space="preserve">
          <source>Static configuration of usernames for a given authentication context.</source>
          <target state="translated">주어진 인증 컨텍스트에 대한 사용자 이름의 정적 구성.</target>
        </trans-unit>
        <trans-unit id="20520ab082263228efd3ab7ffc11e41906666da4" translate="yes" xml:space="preserve">
          <source>Status letters C and R are always followed by a score (denoting the percentage of similarity between the source and target of the move or copy). Status letter M may be followed by a score (denoting the percentage of dissimilarity) for file rewrites.</source>
          <target state="translated">상태 문자 C와 R은 항상 점수 뒤에옵니다 (이동 또는 사본의 소스와 대상 간의 유사성 비율을 나타냄). 상태 문자 M 다음에는 파일 다시 쓰기에 대한 점수 (유사 비율을 나타냄)가 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5910dfc64a273edb8d032604ca6d54bef3bf2f4e" translate="yes" xml:space="preserve">
          <source>Stop the httpd instance and exit. This does not generate any of the configuration files for spawning a new instance, nor does it close the browser.</source>
          <target state="translated">httpd 인스턴스를 중지하고 종료하십시오. 이렇게하면 새 인스턴스를 생성하기위한 구성 파일이 생성되지 않으며 브라우저가 닫히지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12d3bab755f474b20ad13c1ab918e01e5f4eb7c4" translate="yes" xml:space="preserve">
          <source>Stop when a given path disappears from the tree.</source>
          <target state="translated">주어진 경로가 트리에서 사라지면 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="7363904e3ee0fd364e644f2e1b28c12dd383e027" translate="yes" xml:space="preserve">
          <source>Storage format</source>
          <target state="translated">저장 형식</target>
        </trans-unit>
        <trans-unit id="9ff8274c9fcae633894b9e7ab1c37fd6e74f1f7a" translate="yes" xml:space="preserve">
          <source>Store Git commit times in the local time zone instead of UTC. This makes &lt;code&gt;git log&lt;/code&gt; (even without --date=local) show the same times that &lt;code&gt;svn log&lt;/code&gt; would in the local time zone.</source>
          <target state="translated">Git 커밋 시간을 UTC 대신 현지 시간대로 저장하십시오. 이것은 &lt;code&gt;git log&lt;/code&gt; (--date = local이 없어도)가 &lt;code&gt;svn log&lt;/code&gt; 가 현지 시간대 와 동일한 시간을 표시하게합니다 .</target>
        </trans-unit>
        <trans-unit id="c403801561a0441c1d742dd0499050f55d110cd9" translate="yes" xml:space="preserve">
          <source>Store a given stash created via &lt;code&gt;git stash create&lt;/code&gt; (which is a dangling merge commit) in the stash ref, updating the stash reflog. This is intended to be useful for scripts. It is probably not the command you want to use; see &quot;push&quot; above.</source>
          <target state="translated">&lt;code&gt;git stash create&lt;/code&gt; (매달린 병합 커밋)를 통해 생성 된 지정된 숨김을 숨김 참조에 저장하고 숨김 참조를 업데이트합니다. 스크립트에 유용합니다. 사용하려는 명령이 아닐 수도 있습니다. 위의 &quot;푸시&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b41300dc42c243e3949e2ecb7a4c10aea769103e" translate="yes" xml:space="preserve">
          <source>Store credentials indefinitely on disk. See &lt;a href=&quot;git-credential-store&quot;&gt;git-credential-store[1]&lt;/a&gt; for details.</source>
          <target state="translated">자격 증명을 디스크에 무기한 저장합니다. 자세한 내용은 &lt;a href=&quot;git-credential-store&quot;&gt;git-credential-store [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="03384c8a5477964f7bc214ed7cbcde0772bb7755" translate="yes" xml:space="preserve">
          <source>Store the credential, if applicable to the helper.</source>
          <target state="translated">Store the credential, if applicable to the helper.</target>
        </trans-unit>
        <trans-unit id="5597429620f06451a38a8e17b35a345310b01123" translate="yes" xml:space="preserve">
          <source>Store the fetched branch into a local branch before merging into the current branch:</source>
          <target state="translated">현재 브랜치에 병합하기 전에 페치 된 브랜치를 로컬 브랜치에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="687760eb98a14d7d5a6fbbba834cf9ccaaf83ea1" translate="yes" xml:space="preserve">
          <source>Store the files instead of deflating them.</source>
          <target state="translated">수축시키지 말고 파일을 보관하십시오.</target>
        </trans-unit>
        <trans-unit id="1512a579e2c05cbf63724a7c8d50327696297b00" translate="yes" xml:space="preserve">
          <source>Stores a set of &quot;objects&quot;, and an individual &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; is identified by its &lt;a href=&quot;#def_object_name&quot;&gt;object name&lt;/a&gt;. The objects usually live in &lt;code&gt;$GIT_DIR/objects/&lt;/code&gt;.</source>
          <target state="translated">&quot;객체&quot;세트를 저장하고 개별 &lt;a href=&quot;#def_object&quot;&gt;객체&lt;/a&gt; 는 해당 &lt;a href=&quot;#def_object_name&quot;&gt;객체 이름으로&lt;/a&gt; 식별됩니다 . 객체는 보통 &lt;code&gt;$GIT_DIR/objects/&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6349a625008b244d26dbb9000ad7480816812a5" translate="yes" xml:space="preserve">
          <source>Stores shorthands for URL and default refnames for use when interacting with remote repositories via &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; commands. See the REMOTES section in &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; for details. This mechanism is legacy and not likely to be found in modern repositories. This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/remotes&quot; will be used instead.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; , &lt;code&gt;git pull&lt;/code&gt; 및 &lt;code&gt;git push&lt;/code&gt; 명령을 통해 원격 리포지토리와 상호 작용할 때 사용할 URL 및 기본 참조 이름에 대한 속기를 저장 합니다. 자세한 내용은 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 의 REMOTES 섹션 을 참조하십시오. 이 메커니즘은 레거시이며 현대 리포지토리에서는 찾을 수 없습니다. $ GIT_COMMON_DIR이 설정되고 대신 &quot;$ GIT_COMMON_DIR / remotes&quot;가 사용되면이 디렉토리는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="39f2d5fc66110ba4ba0f8069c43a058a9f84529f" translate="yes" xml:space="preserve">
          <source>Storing multiple repositories as namespaces of a single repository avoids storing duplicate copies of the same objects, such as when storing multiple branches of the same source. The alternates mechanism provides similar support for avoiding duplicates, but alternates do not prevent duplication between new objects added to the repositories without ongoing maintenance, while namespaces do.</source>
          <target state="translated">여러 저장소를 단일 저장소의 네임 스페이스로 저장하면 동일한 소스의 여러 분기를 저장할 때와 같이 동일한 오브젝트의 중복 사본을 저장하지 않아도됩니다. 대체 메커니즘은 중복을 피하기위한 유사한 지원을 제공하지만 대체는 유지 보수없이 저장소에 추가 된 새 오브젝트 간의 복제를 막지 않지만 네임 스페이스는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca1c76454e0d7e7718b023221d2b0aad3d2a1aba" translate="yes" xml:space="preserve">
          <source>Stream Comments</source>
          <target state="translated">스트림 댓글</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="5ab8d5b6efb1646dea2e4ea7d3282e3cb65c24cb" translate="yes" xml:space="preserve">
          <source>String to be printed at the beginning of each line.</source>
          <target state="translated">각 줄의 시작 부분에 인쇄 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="382f9b3217a7726b3a52ca62702799f6d5434b48" translate="yes" xml:space="preserve">
          <source>String to be printed at the end of each line, including newline character.</source>
          <target state="translated">줄 바꿈 문자를 포함하여 각 줄의 끝에 인쇄 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ae0208ff14e492381101b38c4426143fc9d98dd6" translate="yes" xml:space="preserve">
          <source>String(s) &lt;code&gt;receive-pack&lt;/code&gt; and &lt;code&gt;upload-pack&lt;/code&gt; use to decide which refs to omit from their initial advertisements. Use more than one definition to specify multiple prefix strings. A ref that is under the hierarchies listed in the value of this variable is excluded, and is hidden when responding to &lt;code&gt;git push&lt;/code&gt; or &lt;code&gt;git
fetch&lt;/code&gt;. See &lt;code&gt;receive.hideRefs&lt;/code&gt; and &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; for program-specific versions of this config.</source>
          <target state="translated">String (s) &lt;code&gt;receive-pack&lt;/code&gt; 및 &lt;code&gt;upload-pack&lt;/code&gt; 은 초기 광고에서 생략 할 참조를 결정하는 데 사용됩니다. 여러 개의 접두사 문자열을 지정하려면 둘 이상의 정의를 사용하십시오. 이 변수의 값에 나열된 계층 구조 아래에있는 참조는 제외되며 &lt;code&gt;git push&lt;/code&gt; 또는 &lt;code&gt;git fetch&lt;/code&gt; 응답하면 숨겨집니다 . 이 구성의 프로그램 별 버전은 &lt;code&gt;receive.hideRefs&lt;/code&gt; 및 &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd5fa82aac351e4a1096fc62004ba110d66fe810" translate="yes" xml:space="preserve">
          <source>Strip leading and trailing empty lines, trailing whitespace, commentary and collapse consecutive empty lines.</source>
          <target state="translated">선행 및 후행 빈 줄 제거, 후행 공백, 주석 및 연속적인 빈 줄 축소.</target>
        </trans-unit>
        <trans-unit id="7c8cf84261f17414d41a19324152deb0638ecb13" translate="yes" xml:space="preserve">
          <source>Subcommands</source>
          <target state="translated">Subcommands</target>
        </trans-unit>
        <trans-unit id="2dacf65959849884a011f36f76a04eebea94c5ea" translate="yes" xml:space="preserve">
          <source>Submit</source>
          <target state="translated">Submit</target>
        </trans-unit>
        <trans-unit id="f3de51d87e152838b373a65e626718325c16a058" translate="yes" xml:space="preserve">
          <source>Submit only the specified commit or range of commits, instead of the full list of changes that are in the current Git branch.</source>
          <target state="translated">현재 Git 브랜치에있는 전체 변경 사항 목록 대신 지정된 커밋 또는 커밋 범위 만 제출하십시오.</target>
        </trans-unit>
        <trans-unit id="08c8f65685b697a18634ff4dd66ae0c7b7f8944c" translate="yes" xml:space="preserve">
          <source>Submit options</source>
          <target state="translated">옵션 제출</target>
        </trans-unit>
        <trans-unit id="3e96d88de40c1b4ce507f5624d2a7a2ae94fe14f" translate="yes" xml:space="preserve">
          <source>Submit variables</source>
          <target state="translated">변수 제출</target>
        </trans-unit>
        <trans-unit id="0213e9a40d8de329179170c49c9f0b36b9c8f25d" translate="yes" xml:space="preserve">
          <source>Submit your commits back to p4:</source>
          <target state="translated">커밋을 p4에 다시 제출하십시오.</target>
        </trans-unit>
        <trans-unit id="45b948a665e37752fe7a51975e7be3fc7f05181f" translate="yes" xml:space="preserve">
          <source>Submitting changes from a Git repository back to the p4 repository requires a separate p4 client workspace. This should be specified using the &lt;code&gt;P4CLIENT&lt;/code&gt; environment variable or the Git configuration variable &lt;code&gt;git-p4.client&lt;/code&gt;. The p4 client must exist, but the client root will be created and populated if it does not already exist.</source>
          <target state="translated">Git 저장소에서 p4 저장소로 변경 사항을 다시 제출하려면 별도의 p4 클라이언트 작업 공간이 필요합니다. 이것은 &lt;code&gt;P4CLIENT&lt;/code&gt; 환경 변수 또는 Git 구성 변수 &lt;code&gt;git-p4.client&lt;/code&gt; 를 사용하여 지정해야합니다 . p4 클라이언트가 존재해야하지만 클라이언트 루트가 없으면 클라이언트 루트가 작성되어 채워집니다.</target>
        </trans-unit>
        <trans-unit id="6fdf0bad4a57f28ad8887a6fe4e3d9618491f48f" translate="yes" xml:space="preserve">
          <source>Submitting patches to a project</source>
          <target state="translated">프로젝트에 패치 제출</target>
        </trans-unit>
        <trans-unit id="d2d7b7a6dabf5680ef6fc53443124ea60acd88af" translate="yes" xml:space="preserve">
          <source>Submitting requires a p4 client, which is not in the same location as the Git repository. Patches are applied, one at a time, to this p4 client and submitted from there.</source>
          <target state="translated">제출하려면 p4 클라이언트가 필요하며 Git 저장소와 동일한 위치에 있지 않습니다. 패치는 한 번에 하나씩이 p4 클라이언트에 적용되어 해당 p4 클라이언트에 제출됩니다.</target>
        </trans-unit>
        <trans-unit id="81d7b2b94000dc76db42f2c130ed58771103b34d" translate="yes" xml:space="preserve">
          <source>Submodule Rewriting</source>
          <target state="translated">Submodule Rewriting</target>
        </trans-unit>
        <trans-unit id="e107551e51d7866e29fbfac7f1a9d70e892a1c9c" translate="yes" xml:space="preserve">
          <source>Submodule operations can be configured using the following mechanisms (from highest to lowest precedence):</source>
          <target state="translated">다음과 같은 메커니즘을 사용하여 서브 모듈 작업을 구성 할 수 있습니다 (가장 높은 우선 순위에서 가장 낮은 우선 순위로).</target>
        </trans-unit>
        <trans-unit id="12d390f8025584ad2ceb29d8156199827eb766f2" translate="yes" xml:space="preserve">
          <source>Submodules</source>
          <target state="translated">Submodules</target>
        </trans-unit>
        <trans-unit id="8b3b72a48d6b77673f309811c21a1f34bda69f2a" translate="yes" xml:space="preserve">
          <source>Submodules are initialized and cloned using their default settings. This is equivalent to running &lt;code&gt;git submodule update --init --recursive &amp;lt;pathspec&amp;gt;&lt;/code&gt; immediately after the clone is finished. This option is ignored if the cloned repository does not have a worktree/checkout (i.e. if any of &lt;code&gt;--no-checkout&lt;/code&gt;/&lt;code&gt;-n&lt;/code&gt;, &lt;code&gt;--bare&lt;/code&gt;, or &lt;code&gt;--mirror&lt;/code&gt; is given)</source>
          <target state="translated">하위 모듈은 기본 설정을 사용하여 초기화 및 복제됩니다. 이것은 복제가 완료된 직후 &lt;code&gt;git submodule update --init --recursive &amp;lt;pathspec&amp;gt;&lt;/code&gt; 을 실행하는 것과 같습니다 . 복제 된 저장소에 작업 트리 / 체크 아웃이없는 경우 (예 : &lt;code&gt;--no-checkout&lt;/code&gt; / &lt;code&gt;-n&lt;/code&gt; , &lt;code&gt;--bare&lt;/code&gt; 또는 &lt;code&gt;--mirror&lt;/code&gt; 가 지정된 경우) 이 옵션은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f0558d8aae211aae78435cf5f18fbee56b357b16" translate="yes" xml:space="preserve">
          <source>Submodules can be used for at least two different use cases:</source>
          <target state="translated">서브 모듈은 두 가지 이상의 다른 사용 사례에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a4ac6e80eae220504fcac25436c9a1e818ef8b5" translate="yes" xml:space="preserve">
          <source>Submodules can take the following forms:</source>
          <target state="translated">서브 모듈은 다음과 같은 형식을 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ee6b51df0a5b53ba35723ec36f91cb14154873c" translate="yes" xml:space="preserve">
          <source>Submodules have more state and instead report M the submodule has a different HEAD than recorded in the index m the submodule has modified content ? the submodule has untracked files since modified content or untracked files in a submodule cannot be added via &lt;code&gt;git add&lt;/code&gt; in the superproject to prepare a commit.</source>
          <target state="translated">서브 모듈은 더 많은 상태를 가지고 대신 서브 모듈이 컨텐츠를 수정 한 인덱스에 기록 된 것과 다른 HEAD를 가지고 있다고보고한다. 커밋을 준비하기 위해 수퍼 프로젝트의 &lt;code&gt;git add&lt;/code&gt; 를 통해 서브 모듈에서 수정 된 컨텐츠 또는 추적되지 않은 파일을 추가 할 수 없으므로 서브 모듈에 추적되지 않은 파일이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a03a02ecd76c4aa6d233be9ed15c5b8f09cfe2e" translate="yes" xml:space="preserve">
          <source>Subsection names are case sensitive and can contain any characters except newline and the null byte. Doublequote &lt;code&gt;&quot;&lt;/code&gt; and backslash can be included by escaping them as &lt;code&gt;\&quot;&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt;, respectively. Backslashes preceding other characters are dropped when reading; for example, &lt;code&gt;\t&lt;/code&gt; is read as &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;\0&lt;/code&gt; is read as &lt;code&gt;0&lt;/code&gt; Section headers cannot span multiple lines. Variables may belong directly to a section or to a given subsection. You can have &lt;code&gt;[section]&lt;/code&gt; if you have &lt;code&gt;[section &quot;subsection&quot;]&lt;/code&gt;, but you don&amp;rsquo;t need to.</source>
          <target state="translated">서브 섹션 이름은 대소 문자를 구분하며 개행 및 널 바이트를 제외한 모든 문자를 포함 할 수 있습니다. 큰 따옴표 &lt;code&gt;&quot;&lt;/code&gt; 및 백 슬래시는 각각 &lt;code&gt;\&quot;&lt;/code&gt; 및 &lt;code&gt;\\&lt;/code&gt; 로 이스케이프하여 포함시킬 수 있습니다 . 읽을 때 다른 문자 앞에 오는 백 슬래시는 삭제됩니다. 예를 들어, &lt;code&gt;\t&lt;/code&gt; 로 판독 &lt;code&gt;t&lt;/code&gt; 및 &lt;code&gt;\0&lt;/code&gt; 으로 판독 &lt;code&gt;0&lt;/code&gt; 여러 줄 수없는 걸쳐 섹션 헤더. 변수는 섹션 또는 지정된 하위 섹션에 직접 속할 수 있습니다. 당신은 할 수 있습니다 &lt;code&gt;[section]&lt;/code&gt; 당신이있는 경우 &lt;code&gt;[section &quot;subsection&quot;]&lt;/code&gt; ,하지만 당신은 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="99e9a313960d39fea11c6c21bc5f471c5ed54f4e" translate="yes" xml:space="preserve">
          <source>Subsequent requests are then made directly to the service &lt;code&gt;$GIT_URL/git-upload-pack&lt;/code&gt;. (This works the same for git-receive-pack).</source>
          <target state="translated">그런 다음 후속 요청이 &lt;code&gt;$GIT_URL/git-upload-pack&lt;/code&gt; 서비스로 직접 이루어집니다 . 이것은 git-receive-pack과 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ecd7815bae661c84db8b72f60f38c2e3bca8ef1f" translate="yes" xml:space="preserve">
          <source>Subsequent updates to branches always create new files under &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory hierarchy.</source>
          <target state="translated">분기에 대한 후속 업데이트는 항상 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 디렉토리 계층 아래에 새 파일을 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="b2bf2538aec79c0d5fa040a786e252ac3772aa80" translate="yes" xml:space="preserve">
          <source>Substitute the character &quot;/&quot; in branch names with &amp;lt;subst&amp;gt;</source>
          <target state="translated">분기 이름에서 &quot;/&quot;문자를 &amp;lt;subst&amp;gt;로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="d44c96fa5a053386ed38d9e6a7cca3107588bf57" translate="yes" xml:space="preserve">
          <source>Successful execution (a zero exit status) of this hook does not ensure the ref will actually be updated, it is only a prerequisite. As such it is not a good idea to send notices (e.g. email) from this hook. Consider using the post-receive hook instead.</source>
          <target state="translated">이 후크의 성공적인 실행 (제로 종료 상태)은 심판이 실제로 업데이트되도록 보장하지 않으며, 이는 전제 조건 일뿐입니다. 따라서이 후크에서 통지 (예 : 이메일)를 보내는 것은 좋지 않습니다. 수신 후 후크를 대신 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="0454547376d4a4928bbfee6331b7c2a9fb4a2161" translate="yes" xml:space="preserve">
          <source>Such duplicates are generally frowned upon because they clutter up history, making it harder to follow. To clean things up, you need to transplant the commits on &lt;code&gt;topic&lt;/code&gt; to the new &lt;code&gt;subsystem&lt;/code&gt; tip, i.e., rebase &lt;code&gt;topic&lt;/code&gt;. This becomes a ripple effect: anyone downstream from &lt;code&gt;topic&lt;/code&gt; is forced to rebase too, and so on!</source>
          <target state="translated">이러한 복제본은 일반적으로 역사를 어지럽히 기 때문에 따르기가 어려워서 찌그러집니다. 정리하려면 &lt;code&gt;topic&lt;/code&gt; 에 대한 커밋을 새로운 &lt;code&gt;subsystem&lt;/code&gt; 팁 (예 : rebase &lt;code&gt;topic&lt;/code&gt; ) 에 이식해야합니다 . 이것은 파급 효과가된다 : &lt;code&gt;topic&lt;/code&gt; 하류에있는 사람 은 모두 리베이스해야한다.</target>
        </trans-unit>
        <trans-unit id="8866d8895f273e182aecc88b4155660c1e2db399" translate="yes" xml:space="preserve">
          <source>Summarize &lt;code&gt;git log&lt;/code&gt; output</source>
          <target state="translated">&lt;code&gt;git log&lt;/code&gt; 출력 요약</target>
        </trans-unit>
        <trans-unit id="ec1e3fb20faac142815eb47774b44cb84610e827" translate="yes" xml:space="preserve">
          <source>Summarizes &lt;code&gt;git log&lt;/code&gt; output in a format suitable for inclusion in release announcements. Each commit will be grouped by author and title.</source>
          <target state="translated">릴리스 알림에 포함하기에 적합한 형식으로 &lt;code&gt;git log&lt;/code&gt; 출력을 요약 합니다. 각 커밋은 저자와 제목별로 그룹화됩니다.</target>
        </trans-unit>
        <trans-unit id="5c7562d8e87120565b992b08061dcfabc4f3c861" translate="yes" xml:space="preserve">
          <source>Supplies raw data (for use as blob/file content, commit messages, or annotated tag messages) to fast-import. Data can be supplied using an exact byte count or delimited with a terminating line. Real frontends intended for production-quality conversions should always use the exact byte count format, as it is more robust and performs better. The delimited format is intended primarily for testing fast-import.</source>
          <target state="translated">빠른 가져 오기에 원시 데이터 (블롭 / 파일 내용, 커밋 메시지 또는 주석이 달린 태그 메시지로 사용)를 제공합니다. 정확한 바이트 수를 사용하거나 종료 라인으로 구분하여 데이터를 제공 할 수 있습니다. 프로덕션 품질 변환을위한 실제 프런트 엔드는보다 강력하고 성능이 우수하므로 항상 정확한 바이트 수 형식을 사용해야합니다. 구분 형식은 기본적으로 빠른 가져 오기를 테스트하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="e8dbb2eeb155ce2917c101c99bacbd864a5c427e" translate="yes" xml:space="preserve">
          <source>Support for these types of regular expressions is an optional compile-time dependency. If Git wasn&amp;rsquo;t compiled with support for them providing this option will cause it to die.</source>
          <target state="translated">이러한 유형의 정규식 지원은 선택적 컴파일 타임 종속성입니다. Git이이 옵션을 제공하는 것을 지원하도록 컴파일되지 않은 경우 죽게됩니다.</target>
        </trans-unit>
        <trans-unit id="8e97694d704a0343a9b684d493f12b44246fec5f" translate="yes" xml:space="preserve">
          <source>Support for this command is mandatory.</source>
          <target state="translated">이 명령에 대한 지원은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="e1b49c8e0d2e923baa9b1bdde89fd2d2c159197a" translate="yes" xml:space="preserve">
          <source>Supported commands: &lt;code&gt;connect&lt;/code&gt;.</source>
          <target state="translated">지원되는 명령 : &lt;code&gt;connect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0b920ef57768d484ba1cc526d81f954a574c57f" translate="yes" xml:space="preserve">
          <source>Supported commands: &lt;code&gt;list for-push&lt;/code&gt;, &lt;code&gt;export&lt;/code&gt;.</source>
          <target state="translated">지원되는 명령 : &lt;code&gt;list for-push&lt;/code&gt; , &lt;code&gt;export&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72ec6998fb5b35dff686188df85ab0e3ad151b49" translate="yes" xml:space="preserve">
          <source>Supported commands: &lt;code&gt;list for-push&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;.</source>
          <target state="translated">지원되는 명령 : &lt;code&gt;list for-push&lt;/code&gt; , &lt;code&gt;push&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5829938d9cd5455d30d44c2ed56081b81ad0e8b1" translate="yes" xml:space="preserve">
          <source>Supported commands: &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="translated">지원되는 명령 : &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;fetch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4005d18cc0bff6da83fb1c69518c92481df2684" translate="yes" xml:space="preserve">
          <source>Supported commands: &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;import&lt;/code&gt;.</source>
          <target state="translated">지원되는 명령 : &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;import&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff15abbc5988387a102f85b87106fa0f9a061a4c" translate="yes" xml:space="preserve">
          <source>Supported commands: &lt;code&gt;stateless-connect&lt;/code&gt;.</source>
          <target state="translated">지원되는 명령 : &lt;code&gt;stateless-connect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d7833eb7ee78a4c26a83fcc81c3d2e9095611eb" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;connect&quot; capability.</source>
          <target state="translated">헬퍼에 &quot;연결&quot;기능이있는 경우 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="3a93883be31e9529a29debf1107a5749f91adad7" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;export&quot; capability.</source>
          <target state="translated">헬퍼에 &quot;내보내기&quot;기능이있는 경우 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="18465219e925f5ab7417753a2928593ca3f010cd" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;fetch&quot; capability.</source>
          <target state="translated">헬퍼에 &quot;fetch&quot;기능이있는 경우 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6b3f007fcd47faeaf9e41420b8dd45804e011830" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;fetch&quot; or &quot;import&quot; capability.</source>
          <target state="translated">헬퍼에 &quot;fetch&quot;또는 &quot;import&quot;기능이있는 경우 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4aca0b5526d05a696e7b36938ee6f6c5a0ea9ae4" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;import&quot; capability.</source>
          <target state="translated">헬퍼에 &quot;가져 오기&quot;기능이있는 경우 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="e7ddf6d69b0131cf639e3107da22aa777a2105a4" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;option&quot; capability.</source>
          <target state="translated">헬퍼에 &quot;옵션&quot;기능이있는 경우 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c098533fa12e5c25ff58bd90a0ea089d5ecbd91f" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;push&quot; capability.</source>
          <target state="translated">도우미에 &quot;푸시&quot;기능이있는 경우 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="fb7b526ef7e22c9e1afe23a10d0bc8d29b1f28b6" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;push&quot; or &quot;export&quot; capability.</source>
          <target state="translated">헬퍼에 &quot;푸시&quot;또는 &quot;내보내기&quot;기능이있는 경우 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b4c51ee5ffb300c10c9d8c4078d940f537159814" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;stateless-connect&quot; capability.</source>
          <target state="translated">헬퍼에 &quot;stateless-connect&quot;기능이있는 경우 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="05ab661bd504730c5b7114057d0bdfc9f5d779d8" translate="yes" xml:space="preserve">
          <source>Supports file additions, removals, and commits that affect binary files.</source>
          <target state="translated">이진 파일에 영향을주는 파일 추가, 제거 및 커밋을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="837f71448f49e2e0d9f370a0f4924a3332c3ce70" translate="yes" xml:space="preserve">
          <source>Suppose a shared repository is set up in /pub/repo.git on the host foo.com. Then as an individual committer you can clone the shared repository over ssh with:</source>
          <target state="translated">공유 저장소가 호스트 foo.com의 /pub/repo.git에 설정되어 있다고 가정하십시오. 그런 다음 개별 커미터로 다음을 사용하여 ssh를 통해 공유 저장소를 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="776b1e3e664257166a794955fe1e330d0ed23c81" translate="yes" xml:space="preserve">
          <source>Suppose further that the two development lines merge cleanly at C, so no conflict resolution is required.</source>
          <target state="translated">두 개의 개발 라인이 C에서 깔끔하게 병합되므로 충돌 해결이 필요하지 않다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="e8f9a38765e97d2341920d57addc2939bc25d7eb" translate="yes" xml:space="preserve">
          <source>Suppose that Alice has started a new project with a Git repository in /home/alice/project, and that Bob, who has a home directory on the same machine, wants to contribute.</source>
          <target state="translated">Alice가 / home / alice / project에서 Git 저장소를 사용하여 새 프로젝트를 시작했으며 동일한 시스템에 홈 디렉토리가있는 Bob이 참여하려고한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="f0185bb1f9b382ec2ad8024131a049405c5d0a74" translate="yes" xml:space="preserve">
          <source>Suppose that in the meantime on the lower line of development somebody adds a new calling site for that function at commit Y. The commits from Z leading to B all assume the old semantics of that function and the callers and the callee are consistent with each other. There is no bug at B, either.</source>
          <target state="translated">개발의 하위 라인에 누군가가 커밋 Y에서 해당 함수에 대한 새로운 호출 사이트를 추가한다고 가정하십시오. Z에서 B로 이어지는 커밋은 모두 해당 함수의 오래된 의미를 가정하고 호출자와 호출 수신자는 서로 일치한다고 가정합니다 . B에도 버그가 없습니다.</target>
        </trans-unit>
        <trans-unit id="391a0e24d7cf4e807cbdc6c67d247a126500a7a1" translate="yes" xml:space="preserve">
          <source>Suppose that on the upper line of development, the meaning of one of the functions that exists at Z is changed at commit X. The commits from Z leading to A change both the function&amp;rsquo;s implementation and all calling sites that exist at Z, as well as new calling sites they add, to be consistent. There is no bug at A.</source>
          <target state="translated">개발의 상위 라인에서 Z에 존재하는 함수 중 하나의 의미가 커밋 X에서 변경된다고 가정합니다. Z에서 A로 이어지는 커밋은 함수의 구현과 Z에 존재하는 모든 호출 사이트뿐만 아니라 그들이 추가하는 새로운 호출 사이트, 일관성. A에는 버그가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4264938eda486beabd24f72d431c53e3aa7556fd" translate="yes" xml:space="preserve">
          <source>Suppose that you create a branch &lt;code&gt;mywork&lt;/code&gt; on a remote-tracking branch &lt;code&gt;origin&lt;/code&gt;, and create some commits on top of it:</source>
          <target state="translated">원격 추적 브랜치 &lt;code&gt;origin&lt;/code&gt; 에서 브랜치 &lt;code&gt;mywork&lt;/code&gt; 를 작성하고 그 위에 커밋을 작성한다고 가정 하십시오.</target>
        </trans-unit>
        <trans-unit id="3c9c906e2a1276113a369eaaabf56387154b9496" translate="yes" xml:space="preserve">
          <source>Suppose that you have created lots of logically separate changes and committed them together. Then, later you decide that it might be better to have each logical chunk associated with its own commit. You can use git reset to rewind history without changing the contents of your local files, and then successively use &lt;code&gt;git add -p&lt;/code&gt; to interactively select which hunks to include into each commit, using &lt;code&gt;git commit -c&lt;/code&gt; to pre-populate the commit message.</source>
          <target state="translated">논리적으로 분리 된 많은 변경 사항을 만들어 함께 커밋했다고 가정합니다. 그런 다음 나중에 각 논리적 청크를 자체 커밋과 연결하는 것이 더 나을 수도 있습니다. git reset-을 사용하여 로컬 파일의 내용을 변경하지 않고 기록을 되 감은 다음 &lt;code&gt;git add -p&lt;/code&gt; 를 사용 하여 커밋 메시지를 미리 채우려면 &lt;code&gt;git commit -c&lt;/code&gt; 를 사용하여 각 커밋에 포함 할 덩어리를 대화식으로 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="02fbd8fc87f2a350a49d8620ee0b30d4bf4e4abd" translate="yes" xml:space="preserve">
          <source>Suppose version 2.6.18 of your project worked, but the version at &quot;master&quot; crashes. Sometimes the best way to find the cause of such a regression is to perform a brute-force search through the project&amp;rsquo;s history to find the particular commit that caused the problem. The &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; command can help you do this:</source>
          <target state="translated">프로젝트의 버전 2.6.18이 작동했지만 &quot;마스터&quot;버전이 충돌한다고 가정합니다. 때로는 이러한 회귀의 원인을 찾는 가장 좋은 방법은 프로젝트 기록을 통해 무차별 검색을 수행하여 문제를 일으킨 특정 커밋을 찾는 것입니다. &lt;a href=&quot;git-bisect&quot;&gt;자식-양분 [1]&lt;/a&gt; 명령을 사용하면이 작업을 수행 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="fe43e13972d777424e11db2803667e644671ba7d" translate="yes" xml:space="preserve">
          <source>Suppose you are a contributor to a large project, and you want to add a complicated feature, and to present it to the other developers in a way that makes it easy for them to read your changes, verify that they are correct, and understand why you made each change.</source>
          <target state="translated">대규모 프로젝트에 기고하고 복잡한 기능을 추가하고 변경 사항을 쉽게 읽고 변경 사항이 올바른지 확인하고 이유를 이해하기 쉬운 방식으로 다른 개발자에게 제공하려고한다고 가정합니다. 당신은 각각을 변경했습니다.</target>
        </trans-unit>
        <trans-unit id="3acc0c164272600e31526ab46c74892c1aa07162" translate="yes" xml:space="preserve">
          <source>Suppose you are interrupted by an urgent fix request while you are in the middle of a large change. The files in your working tree are not in any shape to be committed yet, but you need to get to the other branch for a quick bugfix.</source>
          <target state="translated">대규모 변경 중에 긴급 수정 요청이 중단되었다고 가정합니다. 작업 트리의 파일은 아직 커밋되지 않았지만 빠른 버그 수정을 위해 다른 지점으로 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="206336da1c56023f89c7e12354f95287caca26a2" translate="yes" xml:space="preserve">
          <source>Suppose you are working on something and you commit it, and then you continue working a bit more, but now you think that what you have in your working tree should be in another branch that has nothing to do with what you committed previously. You can start a new branch and reset it while keeping the changes in your working tree.</source>
          <target state="translated">당신이 어떤 일을하고 있고 그것을 저지른 다음에 조금 더 계속 일한다고 가정 해 봅시다. 그러나 지금 당신은 당신의 작업 트리에있는 것이 이전에 커밋 한 것과 아무 관련이없는 다른 브랜치에 있어야한다고 생각합니다. 작업 트리에서 변경 사항을 유지하면서 새 분기를 시작하고 재설정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25caa4df3e00bbf0c1bcbf48ca3bbcb805b36ab6" translate="yes" xml:space="preserve">
          <source>Suppose you have added a file to your index, but later decide you do not want to add it to your commit. You can remove the file from the index while keeping your changes with git reset.</source>
          <target state="translated">인덱스에 파일을 추가했지만 나중에 커밋에 추가하지 않기로 결정했다고 가정하십시오. git reset으로 변경 사항을 유지하면서 인덱스에서 파일을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9419c8de1f4e3152ef10e8d631b17a6a8c4bb66f" translate="yes" xml:space="preserve">
          <source>Suppose you know that the commit e05db0fd fixed a certain problem. You&amp;rsquo;d like to find the earliest tagged release that contains that fix.</source>
          <target state="translated">커밋 e05db0fd가 특정 문제를 해결했다고 가정 해 봅시다. 해당 픽스가 포함 된 가장 빠른 태그 릴리스를 찾고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="c40ef08f6cb59edadae067c6870364980c310ebf" translate="yes" xml:space="preserve">
          <source>Suppose you specified &lt;code&gt;foo&lt;/code&gt; as the &amp;lt;paths&amp;gt;. We shall call commits that modify &lt;code&gt;foo&lt;/code&gt; !TREESAME, and the rest TREESAME. (In a diff filtered for &lt;code&gt;foo&lt;/code&gt;, they look different and equal, respectively.)</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 를 &amp;lt;paths&amp;gt;로 지정 했다고 가정하십시오 . &lt;code&gt;foo&lt;/code&gt; ! TREESAME 및 나머지 TREESAME 를 수정하는 커밋을 호출 합니다. ( &lt;code&gt;foo&lt;/code&gt; 로 필터링 된 diff에서는 각각 다르게 보이고 동일하게 보입니다.)</target>
        </trans-unit>
        <trans-unit id="cb2a200ea83c58efe22ad112266f5c75d08a4a2e" translate="yes" xml:space="preserve">
          <source>Suppose you want to check whether two branches point at the same point in history.</source>
          <target state="translated">두 분기가 히스토리에서 동일한 지점을 가리키는 지 확인하려고한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="a4ad635bf26628e292f1bfd04aa9f0a4ae18d146" translate="yes" xml:space="preserve">
          <source>Suppose you want to know how many commits you&amp;rsquo;ve made on &lt;code&gt;mybranch&lt;/code&gt; since it diverged from &lt;code&gt;origin&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;mybranch&lt;/code&gt; 가 &lt;code&gt;origin&lt;/code&gt; 에서 벗어난 이후 얼마나 많은 커밋을했는지 알고 싶다고 가정 해보십시오 .</target>
        </trans-unit>
        <trans-unit id="f9ddeae1484388d5dab75e34df1cfd67e52a3e70" translate="yes" xml:space="preserve">
          <source>Suppose you want to rebase the side branch starting at &quot;A&quot; to &quot;Q&quot;. Make sure that the current HEAD is &quot;B&quot;, and call</source>
          <target state="translated">&quot;A&quot;에서 &quot;Q&quot;로 시작하는 사이드 브랜치를 리베이스한다고 가정합니다. 현재 HEAD가 &quot;B&quot;인지 확인하고 전화하십시오.</target>
        </trans-unit>
        <trans-unit id="b5613771383533c24d3d428fdc1ae60e9fd438c4" translate="yes" xml:space="preserve">
          <source>Suppose you want to remove a file (containing confidential information or copyright violation) from all commits:</source>
          <target state="translated">모든 커밋에서 파일 (기밀 정보 또는 저작권 위반 포함)을 제거한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ff7d0768a57dca637d6eab253f0d487ae1222161" translate="yes" xml:space="preserve">
          <source>Suppose you would like to see all the commits reachable from the branch head named &lt;code&gt;master&lt;/code&gt; but not from any other head in your repository.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 라는 브랜치 헤드에서 도달 할 수 있지만 리포지토리의 다른 헤드에서는 도달 할 수없는 모든 커밋을보고 싶다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="9946995b81548e47df6c8b8392c1840733fdb964" translate="yes" xml:space="preserve">
          <source>Suppress all output, including the listing of updated refs, unless an error occurs. Progress is not reported to the standard error stream.</source>
          <target state="translated">오류가 발생하지 않는 한 업데이트 된 참조 목록을 포함하여 모든 출력을 억제하십시오. 진행률은 표준 오류 스트림에보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4b3a6cd7a8560fe90c65c121ee87d36135f6602" translate="yes" xml:space="preserve">
          <source>Suppress all progress reports.</source>
          <target state="translated">모든 진행률 보고서를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a819bd2ff05cd55161823638237268e190be312a" translate="yes" xml:space="preserve">
          <source>Suppress commit description and provide a commit count summary only.</source>
          <target state="translated">커밋 설명을 억제하고 커밋 수 요약 만 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="e799a643bdb9c82fda51c43573cb85b70de9e54e" translate="yes" xml:space="preserve">
          <source>Suppress commit summary message.</source>
          <target state="translated">커밋 요약 메시지를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a696049e271af3ebf56a00bfbec639053a19da0" translate="yes" xml:space="preserve">
          <source>Suppress diff output. Useful for commands like &lt;code&gt;git show&lt;/code&gt; that show the patch by default, or to cancel the effect of &lt;code&gt;--patch&lt;/code&gt;.</source>
          <target state="translated">diff 출력을 억제합니다. 기본적으로 패치를 표시하거나 &lt;code&gt;--patch&lt;/code&gt; 의 효과를 취소하는 &lt;code&gt;git show&lt;/code&gt; 같은 명령에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="93e56a37493c6ba4434b0b6ea5eb008e9221a320" translate="yes" xml:space="preserve">
          <source>Suppress the author name and timestamp from the output.</source>
          <target state="translated">출력에서 작성자 이름 및 시간 소인을 억제하십시오.</target>
        </trans-unit>
        <trans-unit id="f43798729bfff9f209d330c349626cb5165ac751" translate="yes" xml:space="preserve">
          <source>Swap two inputs; that is, show differences from index or on-disk file to tree contents.</source>
          <target state="translated">두 입력을 교환하십시오. 즉, 인덱스 또는 디스크상의 파일과 트리 내용의 차이점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e5e55f7f46ad773b6efc6aca47e818298efdba7d" translate="yes" xml:space="preserve">
          <source>Switch branches</source>
          <target state="translated">분기 전환</target>
        </trans-unit>
        <trans-unit id="c1c3479fb48988243819a9ed632d7db49472e85a" translate="yes" xml:space="preserve">
          <source>Switch branches or restore working tree files</source>
          <target state="translated">분기 전환 또는 작업 트리 파일 복원</target>
        </trans-unit>
        <trans-unit id="dfdb03e90173f2e2bacd7c02f01c4407ebc5e4a7" translate="yes" xml:space="preserve">
          <source>Switch to &lt;code&gt;topic/wip&lt;/code&gt; branch and keep working.</source>
          <target state="translated">&lt;code&gt;topic/wip&lt;/code&gt; 브랜치로 전환 하고 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="376cbb6cbd05a4fda1d6b5e220f115dcce8e44f1" translate="yes" xml:space="preserve">
          <source>Switch to a commit for inspection and discardable experiments. See the &quot;DETACHED HEAD&quot; section in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; for details.</source>
          <target state="translated">검사 및 폐기 가능한 실험을 위해 커밋으로 전환하십시오. 자세한 내용은 &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; 의 &quot;DETACHED HEAD&quot;섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0362a7c9eb4dad56855ff5dd55a91d5b93e6f9c7" translate="yes" xml:space="preserve">
          <source>Switch to a specified branch. The working tree and the index are updated to match the branch. All new commits will be added to the tip of this branch.</source>
          <target state="translated">지정된 분기로 전환하십시오. 작업 트리와 인덱스가 분기와 일치하도록 업데이트됩니다. 모든 새로운 커밋이이 브랜치의 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c4a37023c84f04e66def4788394f47d95de02383" translate="yes" xml:space="preserve">
          <source>Switching branches does not require a clean index and working tree (i.e. no differences compared to &lt;code&gt;HEAD&lt;/code&gt;). The operation is aborted however if the operation leads to loss of local changes, unless told otherwise with &lt;code&gt;--discard-changes&lt;/code&gt; or &lt;code&gt;--merge&lt;/code&gt;.</source>
          <target state="translated">스위칭 브랜치에는 깨끗한 인덱스와 작업 트리가 필요하지 않습니다 (즉 &lt;code&gt;HEAD&lt;/code&gt; 와 비교하여 차이가 없음 ). 그러나 &lt;code&gt;--discard-changes&lt;/code&gt; 또는 &lt;code&gt;--merge&lt;/code&gt; 로 달리 지시하지 않는 한 작업으로 인해 로컬 변경 내용이 손실되면 작업이 중단됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a44d54fe8d0fbe571632defb5e0f0bfcb635688" translate="yes" xml:space="preserve">
          <source>Symbolic identifiers</source>
          <target state="translated">기호 식별자</target>
        </trans-unit>
        <trans-unit id="edf50a81800d6af816fa28268463b4a137a670b4" translate="yes" xml:space="preserve">
          <source>Symbolic reference: instead of containing the &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; id itself, it is of the format 'ref: refs/some/thing' and when referenced, it recursively dereferences to this reference. '&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;' is a prime example of a symref. Symbolic references are manipulated with the &lt;a href=&quot;git-symbolic-ref&quot;&gt;git-symbolic-ref[1]&lt;/a&gt; command.</source>
          <target state="translated">상징적 참조 : &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; ID 자체 를 포함하는 대신 'ref : refs / some / thing'형식이며 참조 할 때이 참조를 재귀 적으로 역 참조합니다. ' &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; '는 symref의 주요 예입니다. 기호 참조는 &lt;a href=&quot;git-symbolic-ref&quot;&gt;git-symbolic-ref [1]&lt;/a&gt; 명령 으로 조작됩니다 .</target>
        </trans-unit>
        <trans-unit id="6dc4afea6b4b62629fc3af96ff8aeb71d81ce355" translate="yes" xml:space="preserve">
          <source>Symbolic reference: instead of containing the &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; id itself, it is of the format &lt;code&gt;ref: refs/some/thing&lt;/code&gt; and when referenced, it recursively dereferences to this reference. &lt;code&gt;&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;&lt;/code&gt; is a prime example of a symref. Symbolic references are manipulated with the &lt;a href=&quot;git-symbolic-ref&quot;&gt;git-symbolic-ref[1]&lt;/a&gt; command.</source>
          <target state="translated">기호 참조 : &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; ID 자체 를 포함하는 대신 &lt;code&gt;ref: refs/some/thing&lt;/code&gt; 형식 이며이 참조를 재귀 적으로 참조 해제합니다. &lt;code&gt;&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;&lt;/code&gt; 는 symref의 주요 예입니다. 기호 참조는 &lt;a href=&quot;git-symbolic-ref&quot;&gt;git-symbolic-ref [1]&lt;/a&gt; 명령 으로 조작됩니다 .</target>
        </trans-unit>
        <trans-unit id="7d980e6b3e0dc3c2265b8f39aea640f21a2c26c7" translate="yes" xml:space="preserve">
          <source>Symlinks in &lt;code&gt;$GIT_DIR&lt;/code&gt; are not resolved before matching.</source>
          <target state="translated">&lt;code&gt;$GIT_DIR&lt;/code&gt; GIT_DIR의 심볼릭 링크는 일치하기 전에 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="905f63092ff26517a7aa8083857b3c8af9707002" translate="yes" xml:space="preserve">
          <source>Sync</source>
          <target state="translated">Sync</target>
        </trans-unit>
        <trans-unit id="1cafa24e02c13e63ccc749c8cc50c089372b01c9" translate="yes" xml:space="preserve">
          <source>Sync options</source>
          <target state="translated">동기화 옵션</target>
        </trans-unit>
        <trans-unit id="a05ba5351cf72e05a13ed22352248517859a3ce9" translate="yes" xml:space="preserve">
          <source>Synchronizes submodules' remote URL configuration setting to the value specified in &lt;code&gt;.gitmodules&lt;/code&gt;. It will only affect those submodules which already have a URL entry in .git/config (that is the case when they are initialized or freshly added). This is useful when submodule URLs change upstream and you need to update your local repositories accordingly.</source>
          <target state="translated">하위 모듈의 원격 URL 구성 설정을 &lt;code&gt;.gitmodules&lt;/code&gt; 에 지정된 값으로 동기화합니다 . .git / config에 이미 URL 항목이있는 하위 모듈에만 영향을 미칩니다 (즉, 초기화되거나 새로 추가 된 경우). 하위 모듈 URL이 업스트림으로 변경되어 로컬 리포지토리를 적절히 업데이트해야 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3ac8d1a1aa5500a3e968826312a150affc9dc46d" translate="yes" xml:space="preserve">
          <source>Syncing repositories</source>
          <target state="translated">리포지토리 동기화</target>
        </trans-unit>
        <trans-unit id="566e604d58292e23d183e78e39f3823e9b42de23" translate="yes" xml:space="preserve">
          <source>Synonym for --dirstat=cumulative</source>
          <target state="translated">--dirstat = cumulative의 동의어</target>
        </trans-unit>
        <trans-unit id="f1c4d35b0c03f286600f7fb27eae33fe27989165" translate="yes" xml:space="preserve">
          <source>Synonym for --dirstat=files,param1,param2&amp;hellip;​</source>
          <target state="translated">--dirstat = files, param1, param2의 동의어&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="030318e98e2891ff258d5f1c486159aabe2ec3cd" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; (the noun).</source>
          <target state="translated">&lt;a href=&quot;#def_commit&quot;&gt;커밋의&lt;/a&gt; 동의어 (명사).</target>
        </trans-unit>
        <trans-unit id="98387ba9809590c01ed4197e28a198c994b76d39" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;a href=&quot;#def_object_name&quot;&gt;object name&lt;/a&gt;.</source>
          <target state="translated">동의어 &lt;a href=&quot;#def_object_name&quot;&gt;개체 이름&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05205baafaafa5f371ceb6761f66c9a9092bfca8" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; (for arch people).</source>
          <target state="translated">&lt;a href=&quot;#def_repository&quot;&gt;저장소의&lt;/a&gt; 동의어 (아치 사용자 용)</target>
        </trans-unit>
        <trans-unit id="bd983733ce10be3d6383ba3ae94c790c5998f587" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;code&gt;--date=relative&lt;/code&gt;.</source>
          <target state="translated">동의어 &lt;code&gt;--date=relative&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7204033ad0a3ce5a123aa68893dbb1ec2d44eb7f" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;code&gt;-p --raw&lt;/code&gt;.</source>
          <target state="translated">동의어 &lt;code&gt;-p --raw&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2c85a45d4841ec1bc0daa5da30d63888f50f751" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;code&gt;-p --stat&lt;/code&gt;.</source>
          <target state="translated">동의어 &lt;code&gt;-p --stat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4826ecc5c9ae249b105cc0f800bf317e1bf3ce71" translate="yes" xml:space="preserve">
          <source>Synonym to &lt;code&gt;--more=-1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--more=-1&lt;/code&gt; 과 동의어</target>
        </trans-unit>
        <trans-unit id="375d34b627071e9b56cd3502d59bf963af19d37c" translate="yes" xml:space="preserve">
          <source>Synonym to &lt;code&gt;merge.log&lt;/code&gt;; this is deprecated and will be removed in the future.</source>
          <target state="translated">&lt;code&gt;merge.log&lt;/code&gt; 와 동의어 ; 이것은 더 이상 사용되지 않으며 향후 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="d87db41828b59d9f281eb9d60b0fac7e88c656b9" translate="yes" xml:space="preserve">
          <source>Synonyms to --log and --no-log; these are deprecated and will be removed in the future.</source>
          <target state="translated">--log 및 --no-log와 동의어; 이들은 더 이상 사용되지 않으며 향후 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="c9c7aa6b4fd156059c823cdabeac32daf66bec16" translate="yes" xml:space="preserve">
          <source>Synonyms to --stat and --no-stat; these are deprecated and will be removed in the future.</source>
          <target state="translated">--stat 및 --no-stat의 동의어; 이들은 더 이상 사용되지 않으며 향후 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="121e826ad7717bacfd25c6cf738291790df9e550" translate="yes" xml:space="preserve">
          <source>Syntax is compatible with the file used by &lt;code&gt;git cvsimport&lt;/code&gt; but an empty email address can be supplied with &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">구문은 &lt;code&gt;git cvsimport&lt;/code&gt; 에서 사용하는 파일과 호환 되지만 빈 전자 메일 주소는 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 로 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd2d182068c3eb81ead850c75865e8ae2f054c99" translate="yes" xml:space="preserve">
          <source>System-wide configuration file.</source>
          <target state="translated">시스템 전체 구성 파일</target>
        </trans-unit>
        <trans-unit id="bb78aa3d24f5df42764064db56cde78ca1a563d8" translate="yes" xml:space="preserve">
          <source>T: change in the type of the file</source>
          <target state="translated">T : 파일 형식 변경</target>
        </trans-unit>
        <trans-unit id="a5e95b00d8bbc7641f64bca05aef94e0873eb866" translate="yes" xml:space="preserve">
          <source>THIS COMMAND IS EXPERIMENTAL. ITS BEHAVIOR, AND THE BEHAVIOR OF OTHER COMMANDS IN THE PRESENCE OF SPARSE-CHECKOUTS, WILL LIKELY CHANGE IN THE FUTURE.</source>
          <target state="translated">이 명령은 실험적입니다. 스파 스 체크 아웃의 존재에서 그 행동과 다른 명령의 행동은 미래에 거의 변하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="9667ca46bdeede85b6c2fc52e7779cc06938e375" translate="yes" xml:space="preserve">
          <source>THIS COMMAND IS EXPERIMENTAL. THE BEHAVIOR MAY CHANGE.</source>
          <target state="translated">이 명령은 실험적입니다. 행동이 바뀔 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da2da317615483c79a5e32887ba14bbfd135afb2" translate="yes" xml:space="preserve">
          <source>THIS OPTION IS EXPERIMENTAL! SHA-256 support is experimental and still in an early stage. A SHA-256 repository will in general not be able to share work with &quot;regular&quot; SHA-1 repositories. It should be assumed that, e.g., Git internal file formats in relation to SHA-256 repositories may change in backwards-incompatible ways. Only use &lt;code&gt;--object-format=sha256&lt;/code&gt; for testing purposes.</source>
          <target state="translated">THIS OPTION IS EXPERIMENTAL! SHA-256 support is experimental and still in an early stage. A SHA-256 repository will in general not be able to share work with &quot;regular&quot; SHA-1 repositories. It should be assumed that, e.g., Git internal file formats in relation to SHA-256 repositories may change in backwards-incompatible ways. Only use &lt;code&gt;--object-format=sha256&lt;/code&gt; for testing purposes.</target>
        </trans-unit>
        <trans-unit id="667949023cc3f454cb0d70e83c52143e1650458d" translate="yes" xml:space="preserve">
          <source>TRAILER:</source>
          <target state="translated">TRAILER:</target>
        </trans-unit>
        <trans-unit id="a2ba9a257606db8185ab32e1350e244ce43cc422" translate="yes" xml:space="preserve">
          <source>Tag Object</source>
          <target state="translated">태그 객체</target>
        </trans-unit>
        <trans-unit id="cb8b1e1903f812d19eec6ff05583389fd13d1603" translate="yes" xml:space="preserve">
          <source>Tag format</source>
          <target state="translated">태그 형식</target>
        </trans-unit>
        <trans-unit id="7e41343aeba4393f005c76977eda409bbd77862f" translate="yes" xml:space="preserve">
          <source>Tag names are automatically prefixed with &lt;code&gt;refs/tags/&lt;/code&gt; when stored in Git, so importing the CVS branch symbol &lt;code&gt;RELENG-1_0-FINAL&lt;/code&gt; would use just &lt;code&gt;RELENG-1_0-FINAL&lt;/code&gt; for &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;, and fast-import will write the corresponding ref as &lt;code&gt;refs/tags/RELENG-1_0-FINAL&lt;/code&gt;.</source>
          <target state="translated">태그 이름이 자동으로 접두어 &lt;code&gt;refs/tags/&lt;/code&gt; 그래서 CVS 가지 기호를 가져, 힘내에 저장 &lt;code&gt;RELENG-1_0-FINAL&lt;/code&gt; 단지 사용하는 것이 &lt;code&gt;RELENG-1_0-FINAL&lt;/code&gt; 에 대한 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; , 빠른 가져 오기는 해당 심판 쓸 것 &lt;code&gt;refs/tags/RELENG-1_0-FINAL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e6fe4e0ae7885e683d9ee3f683c218e6902b977" translate="yes" xml:space="preserve">
          <source>Tag objects (created with &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, or &lt;code&gt;-u&lt;/code&gt;) are called &quot;annotated&quot; tags; they contain a creation date, the tagger name and e-mail, a tagging message, and an optional GnuPG signature. Whereas a &quot;lightweight&quot; tag is simply a name for an object (usually a commit object).</source>
          <target state="translated">&lt;code&gt;-a&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; 또는 &lt;code&gt;-u&lt;/code&gt; 로 작성된 태그 객체를 &quot;주석&quot;태그라고합니다. 여기에는 생성 날짜, 태거 이름 및 전자 메일, 태깅 메시지 및 선택적 GnuPG 서명이 포함됩니다. &quot;가벼운&quot;태그는 단순히 객체 (일반적으로 커밋 객체)의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="71ea1d47718752d76e2ffd9d2603ad43ca73b3c9" translate="yes" xml:space="preserve">
          <source>Tagging a version</source>
          <target state="translated">버전 태그</target>
        </trans-unit>
        <trans-unit id="637cc41ee731974198f97641d9bdfb130460784b" translate="yes" xml:space="preserve">
          <source>Tags are expected to always point at the same version of a project, while heads are expected to advance as development progresses.</source>
          <target state="translated">태그는 항상 같은 버전의 프로젝트를 가리킬 것으로 예상되는 반면, 개발이 진행됨에 따라 헤드는 발전 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="888bc919d88641f62426fddc6b7cfc9f6452b8d3" translate="yes" xml:space="preserve">
          <source>Take an existing commit object, and reuse the log message and the authorship information (including the timestamp) when creating the commit.</source>
          <target state="translated">기존 커밋 개체를 가져 와서 커밋을 만들 때 로그 메시지와 제작 정보 (타임 스탬프 포함)를 재사용하십시오.</target>
        </trans-unit>
        <trans-unit id="69d5f1e03c82cbcd587369170c6624b0cf043d55" translate="yes" xml:space="preserve">
          <source>Take the commit message from the given file. This option disables the &lt;code&gt;--edit&lt;/code&gt; option.</source>
          <target state="translated">주어진 파일에서 커밋 메시지를 가져옵니다. 이 옵션은 &lt;code&gt;--edit&lt;/code&gt; 옵션을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="55362ac1695784c6e28770360066065f70c4271a" translate="yes" xml:space="preserve">
          <source>Take the commit message from the given file. Use &lt;code&gt;-&lt;/code&gt; to read the message from the standard input.</source>
          <target state="translated">주어진 파일에서 커밋 메시지를 가져옵니다. &lt;code&gt;-&lt;/code&gt; 를 사용 하여 표준 입력에서 메시지를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="e36d4d8811a867676a670c71431af6f45b8cdbfc" translate="yes" xml:space="preserve">
          <source>Take the configuration from the given file instead of .git/config. Using the &quot;--global&quot; option forces this to ~/.gitconfig. Using the &quot;--system&quot; option forces this to $(prefix)/etc/gitconfig.</source>
          <target state="translated">.git / config 대신 지정된 파일에서 구성을 가져옵니다. &quot;--global&quot;옵션을 사용하면 이것을 ~ / .gitconfig로 설정합니다. &quot;--system&quot;옵션을 사용하면 $ (prefix) / etc / gitconfig가됩니다.</target>
        </trans-unit>
        <trans-unit id="29a57524801de08e4acaf7aa5d5fef7d3a95fdaf" translate="yes" xml:space="preserve">
          <source>Take the given blob object (for example, another note) as the note message. (Use &lt;code&gt;git notes copy &amp;lt;object&amp;gt;&lt;/code&gt; instead to copy notes between objects.)</source>
          <target state="translated">지정된 Blob 객체 (예 : 다른 메모)를 메모 메시지로 사용하십시오. ( &lt;code&gt;git notes copy &amp;lt;object&amp;gt;&lt;/code&gt; 간에 메모를 복사 하려면 git notes copy &amp;lt;object&amp;gt; 를 사용하십시오 .)</target>
        </trans-unit>
        <trans-unit id="d362e00efeb54e4840d9ea63f1d18d0cce50b4f2" translate="yes" xml:space="preserve">
          <source>Take the list of merged objects from &amp;lt;file&amp;gt; instead of stdin.</source>
          <target state="translated">stdin 대신 &amp;lt;file&amp;gt;에서 병합 된 객체 목록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="85714dc37d705ec3059aca2b86357cf12078cff0" translate="yes" xml:space="preserve">
          <source>Take the list of refs from stdin, one per line. If there are refs specified on the command line in addition to this option, then the refs from stdin are processed after those on the command line.</source>
          <target state="translated">stdin의 참조 목록을 한 줄에 하나씩 가져옵니다. 이 옵션 외에 명령 행에 지정된 참조가있는 경우 stdin의 참조는 명령 행의 참조 이후에 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e793a474854bfcd7a2387829ec157d014acaec34" translate="yes" xml:space="preserve">
          <source>Take the note message from the given file. Use &lt;code&gt;-&lt;/code&gt; to read the note message from the standard input. Lines starting with &lt;code&gt;#&lt;/code&gt; and empty lines other than a single line between paragraphs will be stripped out.</source>
          <target state="translated">주어진 파일에서 메모 메시지를 가져옵니다. 표준 입력에서 메모 메시지를 읽으려면 &lt;code&gt;-&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;#&lt;/code&gt; 으로 시작하고 단락 사이의 한 줄 이외의 빈 줄은 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b415454b3e57aca4cd9775be68c013d0b1cba35f" translate="yes" xml:space="preserve">
          <source>Take the tag message from the given file. Use &lt;code&gt;-&lt;/code&gt; to read the message from the standard input. Implies &lt;code&gt;-a&lt;/code&gt; if none of &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, or &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; is given.</source>
          <target state="translated">주어진 파일에서 태그 메시지를 가져옵니다. &lt;code&gt;-&lt;/code&gt; 를 사용 하여 표준 입력에서 메시지를 읽습니다. &lt;code&gt;-a&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; 또는 &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 가 없으면 &lt;code&gt;-a&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="437fabd9a3b90a4e3feee997e0efd394e0e18037" translate="yes" xml:space="preserve">
          <source>Take the version from the current branch as the tentative merge result, and declare that the merge has conflicts. This is suitable for binary files that do not have a well-defined merge semantics.</source>
          <target state="translated">현재 분기의 버전을 임시 병합 결과로 가져 와서 병합이 충돌한다고 선언하십시오. 이는 잘 정의 된 병합 의미가없는 이진 파일에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="8adfe6e8bfbfb71c863cfc8d3c7f83de8a17ccfc" translate="yes" xml:space="preserve">
          <source>Takes the list of merged objects on stdin and produces a suitable commit message to be used for the merge commit, usually to be passed as the &lt;code&gt;&amp;lt;merge-message&amp;gt;&lt;/code&gt; argument of &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">stdin에서 병합 된 오브젝트 목록을 가져 와서 병합 커밋에 사용될 적절한 커밋 메시지를 생성합니다. 일반적 으로 &lt;code&gt;git merge&lt;/code&gt; 의 &lt;code&gt;&amp;lt;merge-message&amp;gt;&lt;/code&gt; 인수로 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="a792b2d24cbb9bea552de7c52e443e6ec570f86e" translate="yes" xml:space="preserve">
          <source>Takes the patches given on the command line and emails them out. Patches can be specified as files, directories (which will send all files in the directory), or directly as a revision list. In the last case, any format accepted by &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; can be passed to git send-email.</source>
          <target state="translated">명령 행에 제공된 패치를 가져 와서 이메일로 보냅니다. 패치는 파일, 디렉토리 (디렉토리의 모든 파일을 전송 함) 또는 직접 개정 목록으로 지정할 수 있습니다. 마지막으로, &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]에&lt;/a&gt; 의해 허용 된 모든 형식은 git send-email로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a0ff7754ecf08c3c8186e018764aeb2fd2691af" translate="yes" xml:space="preserve">
          <source>Talk to the IMAP server using git&amp;rsquo;s own IMAP routines instead of using libcurl. Ignored if Git was built with the NO_OPENSSL option set.</source>
          <target state="translated">libcurl 대신 git 자신의 IMAP 루틴을 사용하여 IMAP 서버와 대화하십시오. NO_OPENSSL 옵션 세트로 Git을 빌드 한 경우 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8452733fe9983e27bdd86ccd2806b4879b9eed76" translate="yes" xml:space="preserve">
          <source>Target of the home link on the top of all pages (the first part of view &quot;breadcrumbs&quot;). By default it is set to the absolute URI of a current page (to the value of &lt;code&gt;$my_uri&lt;/code&gt; variable, or to &quot;/&quot; if &lt;code&gt;$my_uri&lt;/code&gt; is undefined or is an empty string).</source>
          <target state="translated">모든 페이지 상단의 홈 링크 대상 (보기의 &quot;빵 부스러기&quot;). 기본적으로 현재 페이지의 절대 URI ( &lt;code&gt;$my_uri&lt;/code&gt; 변수 의 값 또는 &lt;code&gt;$my_uri&lt;/code&gt; 가 정의되지 않았거나 빈 문자열 인 경우 &quot;/&quot; )로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b83c8f8bfe5de4730b897d69d4046995d166efe4" translate="yes" xml:space="preserve">
          <source>Targets are defined using a VTable allowing easy extension to other formats in the future. This might be used to define a binary format, for example.</source>
          <target state="translated">대상은 향후 다른 형식으로 쉽게 확장 할 수있는 VTable을 사용하여 정의됩니다. 예를 들어 이진 형식을 정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b51ba0493561f3b3deddd8211a5a385cd8601db7" translate="yes" xml:space="preserve">
          <source>Technical discussion</source>
          <target state="translated">기술 토론</target>
        </trans-unit>
        <trans-unit id="7d2e519ddfe0c57b9b7de69eeaa388f193a9848e" translate="yes" xml:space="preserve">
          <source>Tell Git that canonical representation of files in the repository has changed over time (e.g. earlier commits record text files with CRLF line endings, but recent ones use LF line endings). In such a repository, Git can convert the data recorded in commits to a canonical form before performing a merge to reduce unnecessary conflicts. For more information, see section &quot;Merging branches with differing checkin/checkout attributes&quot; in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;.</source>
          <target state="translated">저장소에서 파일의 표준 표현은 시간이 지남에 따라 변경되었다고 알려주십시오 (예 : 이전에는 CRLF 줄 끝을 가진 레코드 텍스트 파일을 커밋하지만 최근 파일은 LF 줄 끝을 사용합니다). 이러한 리포지토리에서 Git은 병합을 수행하기 전에 커밋에 기록 된 데이터를 표준 형식으로 변환하여 불필요한 충돌을 줄입니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]의&lt;/a&gt; &quot;다른 체크인 / 체크 아웃 속성으로 분기 병합&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5b3a0f2444b1d5713e25e3bc88878530e280cdf" translate="yes" xml:space="preserve">
          <source>Tell Git to use it.</source>
          <target state="translated">Git에게 사용하도록 지시하십시오.</target>
        </trans-unit>
        <trans-unit id="bebd78f164bb96ec184a42572b9740f676dbf149" translate="yes" xml:space="preserve">
          <source>Tell cvsexportcommit that the current working directory is not only a Git checkout, but also the CVS checkout. Therefore, Git will reset the working directory to the parent commit before proceeding.</source>
          <target state="translated">cvsexportcommit에게 현재 작업 디렉토리가 Git 체크 아웃 일뿐만 아니라 CVS 체크 아웃임을 알려주십시오. 따라서 Git은 계속하기 전에 작업 디렉토리를 상위 커밋으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="ccc8867e7c10f12bec70f18c0ebdd4b98ffcfd5b" translate="yes" xml:space="preserve">
          <source>Tell git-credential-cache&amp;mdash;​daemon to ignore SIGHUP, instead of quitting.</source>
          <target state="translated">git-credential-cache에게 종료 대신 SIGHUP을 무시하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="500ee09ba16068aaf0936f5ee6b5ef58c4f8bd06" translate="yes" xml:space="preserve">
          <source>Tell the command to automatically stage files that have been modified and deleted, but new files you have not told Git about are not affected.</source>
          <target state="translated">수정 및 삭제 된 파일을 자동으로 스테이징하도록 명령에 지시하지만 Git에 알리지 않은 새 파일은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a69e5b7ab968a315154a9d1fd7cf0d147021841a" translate="yes" xml:space="preserve">
          <source>Telling Git about your changes.</source>
          <target state="translated">변경 사항에 대해 Git에 알리기</target>
        </trans-unit>
        <trans-unit id="52aedbe077c84f7c253f79171da85dc15b08fdf7" translate="yes" xml:space="preserve">
          <source>Telling Git your name</source>
          <target state="translated">Git에게 당신의 이름을 말</target>
        </trans-unit>
        <trans-unit id="47964a2a2b9ba19cb7edfe94ae99ae894e487ad7" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;git add&lt;/code&gt; to continue adding files when some files cannot be added due to indexing errors. Equivalent to the &lt;code&gt;--ignore-errors&lt;/code&gt; option of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;. &lt;code&gt;add.ignore-errors&lt;/code&gt; is deprecated, as it does not follow the usual naming convention for configuration variables.</source>
          <target state="translated">지시 &lt;code&gt;git add&lt;/code&gt; 일부 파일이 인덱싱 오류로 인해 추가 할 수없는 경우 파일을 계속 추가 할 수 있습니다. &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 의 &lt;code&gt;--ignore-errors&lt;/code&gt; 옵션과 동일합니다 . &lt;code&gt;add.ignore-errors&lt;/code&gt; 는 구성 변수에 대한 일반적인 명명 규칙을 따르지 않으므로 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e23c71acb4f3fb6cc5e3124fdbba41789615dcfa" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;git apply&lt;/code&gt; how to handle whitespaces, in the same way as the &lt;code&gt;--whitespace&lt;/code&gt; option. See &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;git apply&lt;/code&gt; 에게 &lt;code&gt;--whitespace&lt;/code&gt; 옵션 과 같은 방식으로 공백을 처리하는 방법을 적용 하도록 지시 합니다. &lt;a href=&quot;git-apply&quot;&gt;git-apply [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b4fd4c56fbd55fd6a4b61da1b1b25feb1363cb0" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;git branch&lt;/code&gt;, &lt;code&gt;git switch&lt;/code&gt; and &lt;code&gt;git checkout&lt;/code&gt; to set up new branches so that &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; will appropriately merge from the starting point branch. Note that even if this option is not set, this behavior can be chosen per-branch using the &lt;code&gt;--track&lt;/code&gt; and &lt;code&gt;--no-track&lt;/code&gt; options. The valid settings are: &lt;code&gt;false&lt;/code&gt; &amp;mdash; no automatic setup is done; &lt;code&gt;true&lt;/code&gt; &amp;mdash; automatic setup is done when the starting point is a remote-tracking branch; &lt;code&gt;always&lt;/code&gt; &amp;mdash; automatic setup is done when the starting point is either a local branch or remote-tracking branch. This option defaults to true.</source>
          <target state="translated">지시 &lt;code&gt;git branch&lt;/code&gt; , &lt;code&gt;git switch&lt;/code&gt; 와 &lt;code&gt;git checkout&lt;/code&gt; 수 있도록 새로운 지점을 설정하는 &lt;a href=&quot;git-pull&quot;&gt;자식 풀 [1]&lt;/a&gt; 적절하게 시작 지점 지점에서 병합합니다. 이 옵션을 설정하지 않아도 &lt;code&gt;--track&lt;/code&gt; 및 &lt;code&gt;--no-track&lt;/code&gt; 옵션을 사용하여 지점 별로이 동작을 선택할 수 있습니다. 유효한 설정은 다음과 같습니다. &lt;code&gt;false&lt;/code&gt; &amp;mdash; 자동 설정이 수행되지 않습니다. &lt;code&gt;true&lt;/code&gt; &amp;mdash; 시작점이 원격 추적 분기 인 경우 자동 설정이 수행됩니다. &lt;code&gt;always&lt;/code&gt; &amp;mdash; 시작 지점이 로컬 지점 또는 원격 추적 지점 인 경우 자동 설정이 수행됩니다. 이 옵션의 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="33792c2c707e004799933a452c481ccd3dd6df72" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;merge-recursive&lt;/code&gt; to use a different diff algorithm, which can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions). See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--diff-algorithm&lt;/code&gt;.</source>
          <target state="translated">어떤지 &lt;code&gt;merge-recursive&lt;/code&gt; (예컨대 고유 함수로부터 교정기 등) 중요 매칭 라인 인해 발생할 않도록 mismerges 도움 DIFF 다른 알고리즘을 사용한다. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--diff-algorithm&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="322e9bf79fc78c188017b38cca0390d8ca24df83" translate="yes" xml:space="preserve">
          <source>Tells Git if the executable bit of files in the working tree is to be honored.</source>
          <target state="translated">작업 트리에있는 파일의 실행 가능한 비트를 준수해야하는지 Git에 알립니다.</target>
        </trans-unit>
        <trans-unit id="e732c8317ebf66ceb1e3db1424bc67bd01187e09" translate="yes" xml:space="preserve">
          <source>Template directory</source>
          <target state="translated">템플릿 디렉토리</target>
        </trans-unit>
        <trans-unit id="ab43df8613b6388c0548cc8be9da228db8e98898" translate="yes" xml:space="preserve">
          <source>Temporarily setting aside work in progress</source>
          <target state="translated">진행중인 작업을 임시로 설정</target>
        </trans-unit>
        <trans-unit id="8e2754fc91f29834706af71cfa26258d56805769" translate="yes" xml:space="preserve">
          <source>Temporary files</source>
          <target state="translated">임시 파일</target>
        </trans-unit>
        <trans-unit id="9c01e9143498ee202aefdfaa27172587b4069975" translate="yes" xml:space="preserve">
          <source>Terminate entries with NUL, instead of LF. This implies the &lt;code&gt;--porcelain=v1&lt;/code&gt; output format if no other format is given.</source>
          <target state="translated">LF 대신 NUL로 항목을 종료하십시오. 다른 형식이 지정되지 않은 경우 &lt;code&gt;--porcelain=v1&lt;/code&gt; 출력 형식을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="07c6a191135373ac9d2aee0a3bde3b658792a63e" translate="yes" xml:space="preserve">
          <source>Terminate with error if there is no &lt;code&gt;done&lt;/code&gt; command at the end of the stream. This option might be useful for detecting errors that cause the frontend to terminate before it has started to write a stream.</source>
          <target state="translated">스트림 끝에 &lt;code&gt;done&lt;/code&gt; 명령 이 없으면 오류로 종료 하십시오. 이 옵션은 스트림 쓰기를 시작하기 전에 프런트 엔드가 종료되는 오류를 감지하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="cf10c8624337ce67bcf480537830a31a54a327a5" translate="yes" xml:space="preserve">
          <source>Test suites are very nice. But when they are used alone, they are supposed to be used so that all the tests are checked after each commit. This means that they are not very efficient, because many tests are run for no interesting result, and they suffer from combinatorial explosion.</source>
          <target state="translated">테스트 스위트는 매우 좋습니다. 그러나 그들이 단독으로 사용될 때, 그들은 모든 커밋 후에 모든 테스트가 확인되도록 사용되어야합니다. 이것은 많은 테스트가 흥미로운 결과를 위해 실행되지 않고 조합 폭발로 고통 받기 때문에 매우 효율적이지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c7039b793911c3e74e0619b364427be7bb23668d" translate="yes" xml:space="preserve">
          <source>Testing has been done using both the CLI CVS client, and the Eclipse CVS plugin. Most functionality works fine with both of these clients.</source>
          <target state="translated">테스트는 CLI CVS 클라이언트와 Eclipse CVS 플러그인을 모두 사용하여 수행되었습니다. 대부분의 기능은이 두 클라이언트 모두에서 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="499b8eda34fd3ef3837b1d2448aadbb6279371d8" translate="yes" xml:space="preserve">
          <source>Testing partial commits</source>
          <target state="translated">부분 커밋 테스트</target>
        </trans-unit>
        <trans-unit id="c5dcd73cdfef43c79255820898dee98a4377a12f" translate="yes" xml:space="preserve">
          <source>Text editor for use by Git commands. The value is meant to be interpreted by the shell when it is used. Examples: &lt;code&gt;~/bin/vi&lt;/code&gt;, &lt;code&gt;$SOME_ENVIRONMENT_VARIABLE&lt;/code&gt;, &lt;code&gt;&quot;C:\Program Files\Vim\gvim.exe&quot;
--nofork&lt;/code&gt;. The order of preference is the &lt;code&gt;$GIT_EDITOR&lt;/code&gt; environment variable, then &lt;code&gt;core.editor&lt;/code&gt; configuration, then &lt;code&gt;$VISUAL&lt;/code&gt;, then &lt;code&gt;$EDITOR&lt;/code&gt;, and then the default chosen at compile time, which is usually &lt;code&gt;vi&lt;/code&gt;.</source>
          <target state="translated">Git 명령에 사용되는 텍스트 편집기. 값은 사용될 때 쉘에 의해 해석됩니다. 예 : &lt;code&gt;~/bin/vi&lt;/code&gt; , &lt;code&gt;$SOME_ENVIRONMENT_VARIABLE&lt;/code&gt; , &lt;code&gt;&quot;C:\Program Files\Vim\gvim.exe&quot; --nofork&lt;/code&gt; . 우선 순위는 &lt;code&gt;$GIT_EDITOR&lt;/code&gt; 환경 변수, &lt;code&gt;core.editor&lt;/code&gt; 구성, &lt;code&gt;$VISUAL&lt;/code&gt; , &lt;code&gt;$EDITOR&lt;/code&gt; 및 컴파일시 선택된 기본값 (일반적으로 &lt;code&gt;vi&lt;/code&gt; ) 입니다.</target>
        </trans-unit>
        <trans-unit id="016aa532b4e9fa7fee1cc89b5c6aa348edd44f21" translate="yes" xml:space="preserve">
          <source>Text editor used by &lt;code&gt;git rebase -i&lt;/code&gt; for editing the rebase instruction file. The value is meant to be interpreted by the shell when it is used. It can be overridden by the &lt;code&gt;GIT_SEQUENCE_EDITOR&lt;/code&gt; environment variable. When not configured the default commit message editor is used instead.</source>
          <target state="translated">rebase 명령 파일을 편집하기 위해 &lt;code&gt;git rebase -i&lt;/code&gt; 에서 사용하는 텍스트 편집기 . 값은 사용될 때 쉘에 의해 해석됩니다. &lt;code&gt;GIT_SEQUENCE_EDITOR&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 . 구성하지 않으면 기본 커밋 메시지 편집기가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a8fe9598336f37cb9328ca8052e59b151a7933de" translate="yes" xml:space="preserve">
          <source>Text viewer for use by Git commands (e.g., &lt;code&gt;less&lt;/code&gt;). The value is meant to be interpreted by the shell. The order of preference is the &lt;code&gt;$GIT_PAGER&lt;/code&gt; environment variable, then &lt;code&gt;core.pager&lt;/code&gt; configuration, then &lt;code&gt;$PAGER&lt;/code&gt;, and then the default chosen at compile time (usually &lt;code&gt;less&lt;/code&gt;).</source>
          <target state="translated">Git 명령에 사용되는 텍스트 뷰어 (예 : &lt;code&gt;less&lt;/code&gt; ). 값은 쉘에 의해 해석됩니다. 우선 순위는 &lt;code&gt;$GIT_PAGER&lt;/code&gt; 환경 변수, &lt;code&gt;core.pager&lt;/code&gt; 구성, &lt;code&gt;$PAGER&lt;/code&gt; 및 컴파일 타임에 선택된 기본값 (보통은 &lt;code&gt;less&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="0bd1b0b7ad0ea4fe7d508b463e4e610ef00887b1" translate="yes" xml:space="preserve">
          <source>That is, a pattern followed by an attributes list, separated by whitespaces. Leading and trailing whitespaces are ignored. Lines that begin with &lt;code&gt;#&lt;/code&gt; are ignored. Patterns that begin with a double quote are quoted in C style. When the pattern matches the path in question, the attributes listed on the line are given to the path.</source>
          <target state="translated">즉, 공백으로 구분 된 패턴 뒤에 속성 목록이옵니다. 선행 및 후행 공백은 무시됩니다. &lt;code&gt;#&lt;/code&gt; 으로 시작하는 줄 은 무시됩니다. 큰 따옴표로 시작하는 패턴은 C 스타일로 인용됩니다. 패턴이 해당 경로와 일치하면 라인에 나열된 속성이 경로에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a2ed6bb3b9b6e451ccc6f660ef58cfb1d5aab73c" translate="yes" xml:space="preserve">
          <source>That is, from left to right:</source>
          <target state="translated">즉, 왼쪽에서 오른쪽으로 :</target>
        </trans-unit>
        <trans-unit id="8f093c96f9e4fd62eb55be18fd622f6079c4aad2" translate="yes" xml:space="preserve">
          <source>That is, from the left to the right:</source>
          <target state="translated">즉, 왼쪽에서 오른쪽으로</target>
        </trans-unit>
        <trans-unit id="11e8a09abfceb997eddb8423e1781ebd95db28e7" translate="yes" xml:space="preserve">
          <source>That is:</source>
          <target state="translated">그건:</target>
        </trans-unit>
        <trans-unit id="aa54aa26ef67ef77a7b5a4203a2f21478483f336" translate="yes" xml:space="preserve">
          <source>That means that even if you offer only read access (e.g. by using the pserver method), &lt;code&gt;git-cvsserver&lt;/code&gt; should have write access to the database to work reliably (otherwise you need to make sure that the database is up to date any time &lt;code&gt;git-cvsserver&lt;/code&gt; is executed).</source>
          <target state="translated">즉, 읽기 권한 만 제공하더라도 (예 : pserver 메소드 사용) &lt;code&gt;git-cvsserver&lt;/code&gt; 는 데이터베이스에 대한 쓰기 액세스 권한이 있어야 안정적으로 작업 할 수 있습니다 (그렇지 않으면 데이터베이스가 &lt;code&gt;git-cvsserver&lt;/code&gt; time 상태 일 때마다 최신 상태인지 확인해야 함) cvsserver 가 실행됩니다).</target>
        </trans-unit>
        <trans-unit id="452813997abf32b7a81b495ef3287ae8cfa66246" translate="yes" xml:space="preserve">
          <source>That means that if you do a &lt;code&gt;git read-tree -m &amp;lt;newtree&amp;gt;&lt;/code&gt; followed by a &lt;code&gt;git checkout-index -f -u -a&lt;/code&gt;, the &lt;code&gt;git checkout-index&lt;/code&gt; only checks out the stuff that really changed.</source>
          <target state="translated">즉, &lt;code&gt;git read-tree -m &amp;lt;newtree&amp;gt;&lt;/code&gt; 다음에 &lt;code&gt;git checkout-index -f -u -a&lt;/code&gt; 를 수행하면 &lt;code&gt;git checkout-index&lt;/code&gt; 는 실제로 변경된 항목 만 체크 아웃합니다.</target>
        </trans-unit>
        <trans-unit id="a1aaaec20914cfb53973b0431f384394f0c406ca" translate="yes" xml:space="preserve">
          <source>That puts the heads and tags for each fork in their own island (named &quot;1234&quot; or similar), and the pull refs for each go into their own &quot;1234-pull&quot;.</source>
          <target state="translated">그러면 각 포크의 헤드와 태그가 자체 섬 ( &quot;1234&quot;또는 이와 유사한 이름)에 배치되고 각각의 풀 참조는 자체 &quot;1234- 풀&quot;로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="767670eb6ab18d660b358046eb00166f0a64fef3" translate="yes" xml:space="preserve">
          <source>That will produce the diff between the tips of the two branches. If you&amp;rsquo;d prefer to find the diff from their common ancestor to test, you can use three dots instead of two:</source>
          <target state="translated">그러면 두 가지 끝 사이에 차이가 생깁니다. 테스트 할 공통 조상에서 diff를 찾으려면 두 개 대신 세 개의 점을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ab4548e0b841bbace5e0a92c23778ab654224e3" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why the &quot;git replace&quot; command was created. Technically it stores replacements &quot;refs&quot; in the &quot;refs/replace/&quot; hierarchy. These &quot;refs&quot; are like branches (that are stored in &quot;refs/heads/&quot;) or tags (that are stored in &quot;refs/tags&quot;), and that means that they can automatically be shared like branches or tags among developers.</source>
          <target state="translated">이것이 &quot;git replace&quot;명령이 작성된 이유입니다. 기술적으로 &quot;refs / replace /&quot;계층에 대체 &quot;refs&quot;를 저장합니다. 이러한 &quot;refs&quot;는 브랜치 ( &quot;refs / heads /&quot;에 저장 됨) 또는 태그 ( &quot;refs / tags&quot;에 저장 됨)와 비슷하며 개발자들 사이에서 브랜치 또는 태그처럼 자동으로 공유 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7f78784e12fead6a14f302d919d7dfe2a02b05b" translate="yes" xml:space="preserve">
          <source>The &quot;child_class&quot; field is a rough classification, such as &quot;editor&quot;, &quot;pager&quot;, &quot;transport/*&quot;, and &quot;hook&quot;. Unclassified children are classified with &quot;?&quot;.</source>
          <target state="translated">&quot;child_class&quot;필드는 &quot;editor&quot;, &quot;pager&quot;, &quot;transport / *&quot;및 &quot;hook&quot;과 같은 대략적인 분류입니다. 분류되지 않은 어린이는 &quot;?&quot;로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="fe5496d60fae83b54bfa30bb265cd284e395a597" translate="yes" xml:space="preserve">
          <source>The &quot;child_id&quot; field can be used to match this child_start with the corresponding child_exit event.</source>
          <target state="translated">&quot;child_id&quot;필드는이 child_start를 해당 child_exit 이벤트와 일치시키는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ee1a593683be8a9c62bf7139373ea713a6461c3" translate="yes" xml:space="preserve">
          <source>The &quot;commit&quot; object links a physical state of a tree with a description of how we got there and why. Use the &lt;code&gt;--pretty=raw&lt;/code&gt; option to &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; or &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; to examine your favorite commit:</source>
          <target state="translated">&quot;commit&quot;객체는 트리의 물리적 상태를 우리가 도착한 방법과 이유에 대한 설명과 연결합니다. &lt;code&gt;--pretty=raw&lt;/code&gt; 옵션을 사용하여 &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 을 사용하여 선호하는 커밋을 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="6db6601ce62b96f9f8fba54efac9ee5967a731f4" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; value consists of a list of triplets in the form &lt;code&gt;(&quot;&amp;lt;label&amp;gt;&quot;, &quot;&amp;lt;link&amp;gt;&quot;, &quot;&amp;lt;position&amp;gt;&quot;)&lt;/code&gt; where &quot;position&quot; is the label after which to insert the link, &quot;link&quot; is a format string where &lt;code&gt;%n&lt;/code&gt; expands to the project name, &lt;code&gt;%f&lt;/code&gt; to the project path within the filesystem (i.e. &quot;$projectroot/$project&quot;), &lt;code&gt;%h&lt;/code&gt; to the current hash ('h' gitweb parameter) and &lt;code&gt;%b&lt;/code&gt; to the current hash base ('hb' gitweb parameter); &lt;code&gt;%%&lt;/code&gt; expands to '%'.</source>
          <target state="translated">&quot;default&quot;값은 &lt;code&gt;(&quot;&amp;lt;label&amp;gt;&quot;, &quot;&amp;lt;link&amp;gt;&quot;, &quot;&amp;lt;position&amp;gt;&quot;)&lt;/code&gt; 형식의 트리플렛 목록으로 구성됩니다. 여기서 &quot;position&quot;은 &quot;link&quot;링크를 삽입 한 후의 레이블입니다. 포맷 문자열 &lt;code&gt;%n&lt;/code&gt; 프로젝트 이름으로 확장, &lt;code&gt;%f&lt;/code&gt; 파일 시스템 내의 프로젝트 경로 (즉, &quot;$ projectroot / $ 프로젝트&quot;), 행 &lt;code&gt;%h&lt;/code&gt; 현재 해시 ( 'H'gitweb 파라미터) 및 &lt;code&gt;%b&lt;/code&gt; 로는 현재 해시베이스 ( 'hb'gitweb 매개 변수); &lt;code&gt;%%&lt;/code&gt; 는 '%'로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="a92a8477d5d97d17f1c481b90522235992b0aec5" translate="yes" xml:space="preserve">
          <source>The &quot;delete&quot; subcommand deletes single entries from the reflog. Its argument must be an &lt;code&gt;exact&lt;/code&gt; entry (e.g. &quot;&lt;code&gt;git reflog delete
master@{2}&lt;/code&gt;&quot;). This subcommand is also typically not used directly by end users.</source>
          <target state="translated">&quot;delete&quot;부속 명령은 참조 로그에서 단일 항목을 삭제합니다. 인수는 &lt;code&gt;exact&lt;/code&gt; 항목 이어야합니다 (예 : &quot; &lt;code&gt;git reflog delete master@{2}&lt;/code&gt; &quot;). 이 하위 명령은 일반적으로 최종 사용자가 직접 사용하지도 않습니다.</target>
        </trans-unit>
        <trans-unit id="15cc724d6cfbdaca681c81ec6b39527ea7ba3e75" translate="yes" xml:space="preserve">
          <source>The &quot;downwards graduation&quot; discussed above cannot be done by actually merging downwards, however, since that would merge &lt;code&gt;all&lt;/code&gt; changes on the unstable branch into the stable one. Hence the following:</source>
          <target state="translated">위에서 논의한 &quot;아래로 눈금&quot;은 실제로 아래쪽으로 병합하여 수행 할 수 없습니다 . 불안정한 지점의 &lt;code&gt;all&lt;/code&gt; 변경 사항이 안정적인 지점으로 병합되기 때문입니다 . 따라서 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b681909e4d1085f8faa13044f43a355b4e9ca0a" translate="yes" xml:space="preserve">
          <source>The &quot;exec&quot; command launches the command in a shell (the one specified in &lt;code&gt;$SHELL&lt;/code&gt;, or the default shell if &lt;code&gt;$SHELL&lt;/code&gt; is not set), so you can use shell features (like &quot;cd&quot;, &quot;&amp;gt;&quot;, &quot;;&quot; &amp;hellip;​). The command is run from the root of the working tree.</source>
          <target state="translated">&quot;exec&quot;명령은 쉘 ( &lt;code&gt;$SHELL&lt;/code&gt; 지정된 명령 또는 &lt;code&gt;$SHELL&lt;/code&gt; 이 설정되지 않은 경우 기본 쉘) 에서 명령을 실행 하므로 쉘 기능 (예 : &quot;cd&quot;, &quot;&amp;gt;&quot;, &quot;;&quot;)을 사용할 수 있습니다. &amp;hellip;). 작업 트리의 루트에서 명령이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="3e27bb28ac33a3ed0da91ec19b0543d1741f2754" translate="yes" xml:space="preserve">
          <source>The &quot;exec_id&quot; field is a command-unique id and is only useful if the &lt;code&gt;exec()&lt;/code&gt; fails and a corresponding exec_result event is generated.</source>
          <target state="translated">&quot;exec_id&quot;필드는 명령 고유 ID이며 &lt;code&gt;exec()&lt;/code&gt; 가 실패하고 해당 exec_result 이벤트가 생성 된 경우에만 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="111dec81403753e6a7d49025386f92b4f5a7ce80" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; subcommand checks whether a ref has a reflog. It exits with zero status if the reflog exists, and non-zero status if it does not.</source>
          <target state="translated">&quot;exists&quot;부속 명령은 ref에 reflog가 있는지 점검합니다. reflog가 존재하면 상태가 0이고, 존재하지 않으면 0이 아닌 상태로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="b084a3a2964fff409a1c4bd5eaf3ff2af985bb46" translate="yes" xml:space="preserve">
          <source>The &quot;experimental&quot; branch is the one you just created, and the &quot;master&quot; branch is a default branch that was created for you automatically. The asterisk marks the branch you are currently on; type</source>
          <target state="translated">&quot;실험&quot;브랜치는 방금 만든 브랜치이며 &quot;마스터&quot;브랜치는 자동으로 생성 된 기본 브랜치입니다. 별표는 현재있는 지점을 표시합니다. 유형</target>
        </trans-unit>
        <trans-unit id="8a5c55e5646a8a6620c2e2207d5f34af5eadc4f2" translate="yes" xml:space="preserve">
          <source>The &quot;expire&quot; subcommand prunes older reflog entries. Entries older than &lt;code&gt;expire&lt;/code&gt; time, or entries older than &lt;code&gt;expire-unreachable&lt;/code&gt; time and not reachable from the current tip, are removed from the reflog. This is typically not used directly by end users &amp;mdash; instead, see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">&quot;expire&quot;부속 명령은 이전 reflog 항목을 제거합니다. &lt;code&gt;expire&lt;/code&gt; 시간이 지난 항목 또는 &lt;code&gt;expire-unreachable&lt;/code&gt; 시간이 지난 항목 과 현재 팁에서 도달 할 수 없는 항목 은 reflog에서 제거됩니다. 일반적으로 최종 사용자가 직접 사용하지는 않으며 &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51ddfbdb206861a134ce9d36a0cd6f8dcb912a92" translate="yes" xml:space="preserve">
          <source>The &quot;extent of changes&quot; parameter can be tweaked from the default 80% (that is, unless more than 80% of the original material is deleted, the broken pairs are merged back into a single modification) by giving a second number to -B option, like these:</source>
          <target state="translated">-B에 두 번째 숫자를 부여하여 &quot;변경 범위&quot;매개 변수를 기본값 80 %에서 조정할 수 있습니다 (즉, 원본 재질의 80 % 이상이 삭제되지 않는 경우 깨진 쌍이 단일 수정으로 다시 병합 됨). 다음과 같은 옵션 :</target>
        </trans-unit>
        <trans-unit id="4be913eb74285fc0f11c845775de3706d8e8ac4f" translate="yes" xml:space="preserve">
          <source>The &quot;git-diff-tree&quot; command begins its output by printing the hash of what is being compared. After that, all the commands print one output line per changed file.</source>
          <target state="translated">&quot;git-diff-tree&quot;명령은 비교 대상의 해시를 인쇄하여 출력을 시작합니다. 그 후, 모든 명령은 변경된 파일 당 하나의 출력 행을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="14e841537fdff67ebd6d58e11774065ab0f0ebfa" translate="yes" xml:space="preserve">
          <source>The &quot;indent&quot; filter is well-behaved in this regard: it will not modify input that is already correctly indented. In this case, the lack of a smudge filter means that the clean filter &lt;code&gt;must&lt;/code&gt; accept its own output without modifying it.</source>
          <target state="translated">&quot;들여 쓰기&quot;필터는 이와 관련하여 잘 작동합니다. 이미 올바르게 들여 쓰기 된 입력은 수정하지 않습니다. 이 경우 스미 지 필터가 없으면 클린 필터 &lt;code&gt;must&lt;/code&gt; 수정하지 않고 자체 출력을 수용 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="2a9f18fc49cc181471bfbc97a47a88e9bcc1179f" translate="yes" xml:space="preserve">
          <source>The &quot;index&quot; holds a snapshot of the content of the working tree, and it is this snapshot that is taken as the contents of the next commit. Thus after making any changes to the working tree, and before running the commit command, you must use the &lt;code&gt;add&lt;/code&gt; command to add any new or modified files to the index.</source>
          <target state="translated">&quot;인덱스&quot;에는 작업 트리의 내용에 대한 스냅 샷이 있으며 다음 커밋의 내용으로 사용되는 것이이 스냅 샷입니다. 따라서 작업 트리를 변경 한 후 commit 명령을 실행하기 전에 &lt;code&gt;add&lt;/code&gt; 명령을 사용하여 새 파일이나 수정 된 파일을 색인에 추가 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6b5b86b50febe55839cf4e73fade50a78b6b0a0e" translate="yes" xml:space="preserve">
          <source>The &quot;master&quot; branch that was created at the time you cloned is a copy of the HEAD in the repository that you cloned from. That repository may also have had other branches, though, and your local repository keeps branches which track each of those remote branches, called remote-tracking branches, which you can view using the &lt;code&gt;-r&lt;/code&gt; option to &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;:</source>
          <target state="translated">복제 할 때 작성된 &quot;마스터&quot;브랜치는 복제 한 저장소에있는 HEAD의 사본입니다. 그러나이 저장소에는 다른 분기가있을 수 있으며 로컬 저장소는 원격 추적 분기라고하는 각 원격 분기를 추적하는 분기를 유지합니다.이 추적은 &lt;code&gt;-r&lt;/code&gt; 옵션을 사용하여 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b0e05ae2162ea2794c2d7383fd67bd0eb622aa45" translate="yes" xml:space="preserve">
          <source>The &quot;name&quot; field is an arbitrary string to describe the command mode. For example, checkout can checkout a branch or an individual file. And these variations typically have different performance characteristics that are not comparable.</source>
          <target state="translated">&quot;name&quot;필드는 명령 모드를 설명하는 임의의 문자열입니다. 예를 들어, 체크 아웃은 분기 또는 개별 파일을 체크 아웃 할 수 있습니다. 이러한 변형은 일반적으로 비교할 수없는 다른 성능 특성을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd5002fa5ace7f79f3506e0a4b77fdeff5bda038" translate="yes" xml:space="preserve">
          <source>The &quot;non-cached&quot; mode takes a different approach, and is potentially the more useful of the two in that what it does can&amp;rsquo;t be emulated with a &lt;code&gt;git write-tree&lt;/code&gt; + &lt;code&gt;git diff-tree&lt;/code&gt;. Thus that&amp;rsquo;s the default mode. The non-cached version asks the question:</source>
          <target state="translated">&quot;캐시되지 않은&quot;모드는 다른 접근 방식을 취하며 &lt;code&gt;git write-tree&lt;/code&gt; + &lt;code&gt;git diff-tree&lt;/code&gt; 로 에뮬레이션 할 수 없다는 점에서 두 가지 중 더 유용합니다 . 이것이 기본 모드입니다. 캐시되지 않은 버전은 다음과 같은 질문을합니다.</target>
        </trans-unit>
        <trans-unit id="fb600e178320a3e93fbf20a6c6f69b12e2843e17" translate="yes" xml:space="preserve">
          <source>The &quot;pull&quot; command thus performs two operations: it fetches changes from a remote branch, then merges them into the current branch.</source>
          <target state="translated">따라서 &quot;pull&quot;명령은 두 가지 작업을 수행합니다. 원격 지점에서 변경 사항을 가져 와서 현재 지점으로 병합합니다.</target>
        </trans-unit>
        <trans-unit id="70b3edc9504f2665b7793306c4b0a620ef20dadb" translate="yes" xml:space="preserve">
          <source>The &quot;remote&quot; repository that is destination of a push operation. This parameter can be either a URL (see the section &lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt; below) or the name of a remote (see the section &lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt; below).</source>
          <target state="translated">푸시 조작의 대상인 &quot;원격&quot;저장소. 이 매개 변수는 URL ( 아래 &lt;a href=&quot;#URLS&quot;&gt;GIT URL&lt;/a&gt; 섹션 참조) 또는 리모컨 이름 ( 아래 섹션 &lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt; 섹션 참조) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0610be2d46404a8f9561c2512c45bc2650bc2b77" translate="yes" xml:space="preserve">
          <source>The &quot;remote&quot; repository that is the source of a fetch or pull operation. This parameter can be either a URL (see the section &lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt; below) or the name of a remote (see the section &lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt; below).</source>
          <target state="translated">페치 또는 풀 조작의 소스 인 &quot;원격&quot;저장소. 이 매개 변수는 URL ( 아래 &lt;a href=&quot;#URLS&quot;&gt;GIT URL&lt;/a&gt; 섹션 참조) 또는 리모컨 이름 ( 아래 섹션 &lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt; 섹션 참조) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="672e385879e10047919cb534a388204453fa9b9b" translate="yes" xml:space="preserve">
          <source>The &quot;remote&quot; repository to query. This parameter can be either a URL or the name of a remote (see the GIT URLS and REMOTES sections of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</source>
          <target state="translated">조회 할 &quot;원격&quot;저장소. 이 매개 변수는 URL이거나 원격의 이름 일 수 있습니다 ( &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 의 GIT URLS 및 REMOTES 섹션 참조 ).</target>
        </trans-unit>
        <trans-unit id="c6967bbb137406cb4cb1860aeca604a66e63b551" translate="yes" xml:space="preserve">
          <source>The &quot;show&quot; subcommand (which is also the default, in the absence of any subcommands) shows the log of the reference provided in the command-line (or &lt;code&gt;HEAD&lt;/code&gt;, by default). The reflog covers all recent actions, and in addition the &lt;code&gt;HEAD&lt;/code&gt; reflog records branch switching. &lt;code&gt;git reflog show&lt;/code&gt; is an alias for &lt;code&gt;git log -g --abbrev-commit
--pretty=oneline&lt;/code&gt;; see &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for more information.</source>
          <target state="translated">&quot;show&quot;하위 명령 (하위 명령이없는 경우 기본값 임)은 명령 줄에 제공된 참조 로그 (또는 기본적으로 &lt;code&gt;HEAD&lt;/code&gt; )를 표시합니다. reflog는 모든 최근 조치를 다루며 &lt;code&gt;HEAD&lt;/code&gt; reflog는 분기 전환을 기록합니다. &lt;code&gt;git reflog show&lt;/code&gt; 는 &lt;code&gt;git log -g --abbrev-commit --pretty=oneline&lt;/code&gt; 의 별칭입니다 . 자세한 내용은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9f44e4ac17ec1a545f86623659c266196a2646a2" translate="yes" xml:space="preserve">
          <source>The &quot;status&quot; command is a useful way to get a quick summary of the situation:</source>
          <target state="translated">&quot;status&quot;명령은 상황을 빠르게 요약 할 수있는 유용한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="97877392fd9cfcae446bf7fdee6a5be7af0d7e1e" translate="yes" xml:space="preserve">
          <source>The &quot;tar.gz&quot; and &quot;tgz&quot; formats are defined automatically and default to &lt;code&gt;gzip -cn&lt;/code&gt;. You may override them with custom commands.</source>
          <target state="translated">&quot;tar.gz&quot;및 &quot;tgz&quot;형식은 자동으로 정의되며 기본값은 &lt;code&gt;gzip -cn&lt;/code&gt; 입니다. 사용자 정의 명령으로이를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de5a671425f0a835fc1aa7cc9c82d529d93b1856" translate="yes" xml:space="preserve">
          <source>The &quot;tree&quot; object here refers to the new state of the tree:</source>
          <target state="translated">여기서 &quot;트리&quot;개체는 트리의 새로운 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e01253337b76bf7642cbcef035c48eb0188a2f7d" translate="yes" xml:space="preserve">
          <source>The &quot;value&quot; field may be an integer or a string.</source>
          <target state="translated">&quot;값&quot;필드는 정수 또는 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38b8f4a1de6f86897b3e2a50acc4b0dda41fe280" translate="yes" xml:space="preserve">
          <source>The &amp;lt;dataref&amp;gt; represents the blob, tree, or commit object at &amp;lt;path&amp;gt; and can be used in later &lt;code&gt;get-mark&lt;/code&gt;, &lt;code&gt;cat-blob&lt;/code&gt;, &lt;code&gt;filemodify&lt;/code&gt;, or &lt;code&gt;ls&lt;/code&gt; commands.</source>
          <target state="translated">&amp;lt;dataref&amp;gt;는 &amp;lt;path&amp;gt;의 blob, tree 또는 commit 객체를 나타내며 나중에 &lt;code&gt;get-mark&lt;/code&gt; , &lt;code&gt;cat-blob&lt;/code&gt; , &lt;code&gt;filemodify&lt;/code&gt; 또는 &lt;code&gt;ls&lt;/code&gt; 명령에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="118ecd88d0a05a5c1cb4a877b8fac543b0b9ad8d" translate="yes" xml:space="preserve">
          <source>The &amp;lt;dst&amp;gt; tells which ref on the remote side is updated with this push. Arbitrary expressions cannot be used here, an actual ref must be named. If &lt;code&gt;git push [&amp;lt;repository&amp;gt;]&lt;/code&gt; without any &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; argument is set to update some ref at the destination with &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; with &lt;code&gt;remote.&amp;lt;repository&amp;gt;.push&lt;/code&gt; configuration variable, &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; part can be omitted&amp;mdash;​such a push will update a ref that &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; normally updates without any &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; on the command line. Otherwise, missing &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; means to update the same ref as the &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;dst&amp;gt;는이 푸시로 업데이트 된 원격 측의 참조를 알려줍니다. 여기서는 임의의 표현식을 사용할 수 없으며 실제 참조 이름을 지정해야합니다. 만일 &lt;code&gt;git push [&amp;lt;repository&amp;gt;]&lt;/code&gt; 어떤없이 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 인수와 목적지 일부 REF를 업데이트하도록 설정 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 와 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.push&lt;/code&gt; 구성 변수 &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; 부분 omitted- 될 수 그러한 push는 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 가 일반적으로 명령 줄에 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 없이 업데이트되는 참조를 업데이트합니다 . 그렇지 않으면, 누락 &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; 는 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 와 동일한 참조를 업데이트하는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="a11f746174b65907575be3c7e94b2869a6db53ed" translate="yes" xml:space="preserve">
          <source>The &amp;lt;feature&amp;gt; part of the command may be any one of the following:</source>
          <target state="translated">명령의 &amp;lt;feature&amp;gt; 부분은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12c10723a00c71e41369dc4ab439f9bc656fc9a7" translate="yes" xml:space="preserve">
          <source>The &amp;lt;file&amp;gt; list given to the command can be exact pathnames, file glob patterns, or leading directory names. The command removes only the paths that are known to Git. Giving the name of a file that you have not told Git about does not remove that file.</source>
          <target state="translated">명령에 제공된 &amp;lt;file&amp;gt; 목록은 정확한 경로 이름, 파일 glob 패턴 또는 선행 디렉토리 이름 일 수 있습니다. 이 명령은 Git에 알려진 경로 만 제거합니다. Git에 알리지 않은 파일 이름을 제공해도 해당 파일은 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9a9d78d51370431396c79c2da7d525a4215ec53" translate="yes" xml:space="preserve">
          <source>The &amp;lt;paths&amp;gt; parameters, when given, are used to limit the diff to the named paths (you can give directory names and get diff for all files under them).</source>
          <target state="translated">&amp;lt;paths&amp;gt; 매개 변수는 주어진 경우 diff를 명명 된 경로로 제한하는 데 사용됩니다 (디렉토리 이름을 지정하고 그 아래의 모든 파일에 대해 diff를 얻을 수 있음).</target>
        </trans-unit>
        <trans-unit id="be0e9224a3c31468000ef31d0ee2d41289501c7f" translate="yes" xml:space="preserve">
          <source>The &amp;lt;src&amp;gt; is often the name of the branch you would want to push, but it can be any arbitrary &quot;SHA-1 expression&quot;, such as &lt;code&gt;master~4&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt; (see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;).</source>
          <target state="translated">&amp;lt;src&amp;gt;는 종종 푸시하려는 브랜치의 이름이지만 &lt;code&gt;master~4&lt;/code&gt; 또는 &lt;code&gt;HEAD&lt;/code&gt; 와 같은 임의의 &quot;SHA-1 표현식&quot;일 수 있습니다 ( &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="94b79c58bc3ec3bceec3b732165a2a52f94063c6" translate="yes" xml:space="preserve">
          <source>The &amp;lt;type&amp;gt; object &amp;lt;object&amp;gt;, is present in the database but never &lt;code&gt;directly&lt;/code&gt; used. A dangling commit could be a root node.</source>
          <target state="translated">&amp;lt;type&amp;gt; 오브젝트 &amp;lt;object&amp;gt;는 데이터베이스에 있지만 &lt;code&gt;directly&lt;/code&gt; 사용 되지는 않습니다 . 매달려있는 커밋은 루트 노드 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c165697ba8df58634f80c6f82752d5afcdee5578" translate="yes" xml:space="preserve">
          <source>The &amp;lt;type&amp;gt; object &amp;lt;object&amp;gt;, is referred to but isn&amp;rsquo;t present in the database.</source>
          <target state="translated">&amp;lt;type&amp;gt; 객체 &amp;lt;object&amp;gt;은 (는) 데이터베이스에 참조되어 있지만 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e6573bf54036812f2655d363c6262b69c0dca40" translate="yes" xml:space="preserve">
          <source>The &amp;lt;type&amp;gt; object &amp;lt;object&amp;gt;, isn&amp;rsquo;t actually referred to directly or indirectly in any of the trees or commits seen. This can mean that there&amp;rsquo;s another root node that you&amp;rsquo;re not specifying or that the tree is corrupt. If you haven&amp;rsquo;t missed a root node then you might as well delete unreachable nodes since they can&amp;rsquo;t be used.</source>
          <target state="translated">&amp;lt;type&amp;gt; 객체 &amp;lt;object&amp;gt;는 실제로 보이는 트리 나 커밋에서 직접 또는 간접적으로 참조되지 않습니다. 이것은 지정하지 않은 다른 루트 노드가 있거나 트리가 손상되었음을 의미 할 수 있습니다. 루트 노드를 놓치지 않았다면 도달 할 수없는 노드는 사용할 수 없으므로 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afa0888330a84b7e0fff615f1c9b8a57ecf94505" translate="yes" xml:space="preserve">
          <source>The 'git sh-i18n scriptlet is designed to be sourced (using &lt;code&gt;.&lt;/code&gt;) by Git&amp;rsquo;s porcelain programs implemented in shell script. It provides wrappers for the GNU &lt;code&gt;gettext&lt;/code&gt; and &lt;code&gt;eval_gettext&lt;/code&gt; functions accessible through the &lt;code&gt;gettext.sh&lt;/code&gt; script, and provides pass-through fallbacks on systems without GNU gettext.</source>
          <target state="translated">'git sh-i18n 스크립틀릿은 쉘 스크립트로 구현 된 Git의 도자기 프로그램에 의해 ( &lt;code&gt;.&lt;/code&gt; 를 사용하여 ) 제공되도록 설계되었습니다 . &lt;code&gt;gettext.sh&lt;/code&gt; 스크립트를 통해 액세스 할 수 있는 GNU &lt;code&gt;gettext&lt;/code&gt; 및 &lt;code&gt;eval_gettext&lt;/code&gt; 함수에 대한 랩퍼를 제공하고 GNU gettext가 없는 시스템에서 패스 스루 폴백을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="75c51ca5866a2731f86888419b9fb61d16567aec" translate="yes" xml:space="preserve">
          <source>The (fully qualified) refname from which to show notes when showing commit messages. The value of this variable can be set to a glob, in which case notes from all matching refs will be shown. You may also specify this configuration variable several times. A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.</source>
          <target state="translated">커밋 메시지를 표시 할 때 메모를 표시 할 정규화 된 refname입니다. 이 변수의 값은 glob로 설정 될 수 있으며,이 경우 일치하는 모든 참조의 노트가 표시됩니다. 이 구성 변수를 여러 번 지정할 수도 있습니다. 존재하지 않는 심판에 대해서는 경고가 표시되지만 어떤 심판과도 일치하지 않는 글롭은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1e4ce979f13cefaaddaddc6c3ce47e1170286daa" translate="yes" xml:space="preserve">
          <source>The (possibly remote) repository to clone from. See the &lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt; section below for more information on specifying repositories.</source>
          <target state="translated">복제 할 원격 저장소입니다. 참고 항목 &lt;a href=&quot;#URLS&quot;&gt;GIT 된 URL&lt;/a&gt; 저장소 지정에 대한 자세한 내용은 아래 절을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0958323d0ba18cc1a0d938e257756d1659d52ec9" translate="yes" xml:space="preserve">
          <source>The --exclude-existing form is a filter that does the inverse. It reads refs from stdin, one ref per line, and shows those that don&amp;rsquo;t exist in the local repository.</source>
          <target state="translated">--exclude-existing 형식은 반대로하는 필터입니다. stdin에서 refs, 한 줄에 하나의 ref를 읽고 로컬 저장소에없는 ref를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a043107d8410def266c54e81fdffaefcdaf6dd4c" translate="yes" xml:space="preserve">
          <source>The --smtp-server-option option must be repeated for each option you want to pass to the server. Likewise, different lines in the configuration files must be used for each option.</source>
          <target state="translated">서버에 전달하려는 각 옵션에 대해 --smtp-server-option 옵션을 반복해야합니다. 마찬가지로, 각 옵션마다 구성 파일의 다른 행을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b478196a2fb02489b622996c5ea9b31713647e4d" translate="yes" xml:space="preserve">
          <source>The .git location may be auto-discovered, or come from &lt;code&gt;$GIT_DIR&lt;/code&gt; environment variable. If the repository is auto discovered via a .git file (e.g. from submodules, or a linked worktree), the .git location would be the final location where the .git directory is, not where the .git file is.</source>
          <target state="translated">.git 위치는 자동 검색되거나 &lt;code&gt;$GIT_DIR&lt;/code&gt; 환경 변수 에서 제공 될 수 있습니다 . .git 파일을 통해 리포지토리가 자동으로 검색되면 (예 : 하위 모듈 또는 연결된 작업 트리에서) .git 위치는 .git 파일이 아닌 .git 디렉토리가있는 최종 위치가됩니다.</target>
        </trans-unit>
        <trans-unit id="489d70f8c8831a28cdf6bb81a4079dab3fec8b7e" translate="yes" xml:space="preserve">
          <source>The 40-hex object name of the object.</source>
          <target state="translated">개체의 40 진수 개체 이름입니다.</target>
        </trans-unit>
        <trans-unit id="edba0bac58d4604af8b0ccc3234ca39328b25c20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt; command can create a tar or zip archive from any version of a project; for example:</source>
          <target state="translated">&lt;a href=&quot;git-archive&quot;&gt;자식 아카이브 [1]&lt;/a&gt; 명령은 타르를 생성하거나 프로젝트의 모든 버전에서 보관할 수 지퍼; 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ff01ddb94fa5e45588517f77b5eb76be2068bf4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; command correctly handles history that includes merge commits. However, when the commit that it finds is a merge commit, the user may need to work harder than usual to figure out why that commit introduced a problem.</source>
          <target state="translated">&lt;a href=&quot;git-bisect&quot;&gt;자식-이등분 [1]&lt;/a&gt; 병합 커밋 명령을 포함하고 정확하게 기록 핸들. 그러나 찾은 커밋이 병합 커밋 인 경우 사용자는 커밋이 문제를 일으킨 이유를 파악하기 위해 평소보다 더 열심히 노력해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1047413b5c194a852bce97f1a7a5b5c064c8f0a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt; command can show the contents of any object, though the higher-level &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; is usually more useful.</source>
          <target state="translated">&lt;a href=&quot;git-cat-file&quot;&gt;자식 고양이 파일 [1]&lt;/a&gt; 높은 수준이지만 명령은 모든 개체의 내용을 표시 할 수 있습니다 &lt;a href=&quot;git-show&quot;&gt;자식 쇼 [1]&lt;/a&gt; 일반적으로 더 유용하다.</target>
        </trans-unit>
        <trans-unit id="0ea75322cb21a3c3c8fac48d1e6228de3fae3cce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; command allows constructing commits with arbitrary parents and trees.</source>
          <target state="translated">&lt;a href=&quot;git-commit-tree&quot;&gt;자식 커밋 트리 [1]&lt;/a&gt; 명령은 임의의 부모와 나무와 커밋을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efc26cd7227657520a6926ebb23db38544c357a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-describe&quot;&gt;git-describe[1]&lt;/a&gt; command does the opposite, naming the revision using a tag on which the given commit is based:</source>
          <target state="translated">&lt;a href=&quot;git-describe&quot;&gt;자식이-설명 [1]&lt;/a&gt; 명령이 주어진 기반 커밋 된 태그를 사용하여 수정 명명 반대을 수행</target>
        </trans-unit>
        <trans-unit id="9903942bbbf43f525c7cf036d25898c86f9d9d7c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt; command runs a number of self-consistency checks on the repository, and reports on any problems. This may take some time.</source>
          <target state="translated">&lt;a href=&quot;git-fsck&quot;&gt;자식 - fsck를 [1]&lt;/a&gt; 명령은 저장소에 자기 일관성 검사의 숫자를 실행하고, 문제에 대한 보고서. 시간이 좀 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff835519b77a7ea3e8c99474cee535ec38ab3bd6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt; command will sometimes complain about dangling objects. They are not a problem.</source>
          <target state="translated">&lt;a href=&quot;git-fsck&quot;&gt;자식 - fsck를 [1]&lt;/a&gt; 명령은 때때로 객체를 매달려에 대해 불평 할 것이다. 그들은 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d818a9097a56e35195bf0f4a41317be4c1298cc7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; command performs packing, pruning, and more for you, so is normally the only high-level command you need.</source>
          <target state="translated">&lt;a href=&quot;git-gc&quot;&gt;자식-GC [1]&lt;/a&gt; 명령 수행은 포장 치기, 그리고 더 많은 당신을 위해, 그래서 당신이 필요로하는 유일한 높은 수준의 명령이 일반적이다.</target>
        </trans-unit>
        <trans-unit id="7674cbc9fda493edc257e040882a4d3b2fee5da7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; command provides a simple way to start browsing the repository using gitweb. The default server when using instaweb is lighttpd.</source>
          <target state="translated">&lt;a href=&quot;git-instaweb&quot;&gt;자식-instaweb [1]&lt;/a&gt; 명령 gitweb를 사용하여 저장소를 탐색을 시작하는 간단한 방법을 제공한다. Instaweb을 사용할 때의 기본 서버는 lighttpd입니다.</target>
        </trans-unit>
        <trans-unit id="3d865565a2d1aab8d65d5524c33990e3ecd5eee4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; and &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; commands also provide special help for merges:</source>
          <target state="translated">&lt;a href=&quot;git-log&quot;&gt;자식 로그 [1]&lt;/a&gt; 및 &lt;a href=&quot;gitk&quot;&gt;gitk이 명령은 [1]&lt;/a&gt; 명령은 병합을위한 특별한 도움을 제공 :</target>
        </trans-unit>
        <trans-unit id="869571e8bf360d23843fed69fde509a99aec51ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; command can show lists of commits. On its own, it shows all commits reachable from the parent commit; but you can also make more specific requests:</source>
          <target state="translated">&lt;a href=&quot;git-log&quot;&gt;자식 로그 [1]&lt;/a&gt; 명령은 커밋의 목록을 표시 할 수 있습니다. 자체적으로 상위 커밋에서 도달 가능한 모든 커밋을 보여줍니다. 그러나 더 구체적인 요청을 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="49730fd39b9c73a554b2cce254c7d8e26a1047e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt; command is a low-level command that is occasionally useful for translating some name for a commit to the object name for that commit:</source>
          <target state="translated">&lt;a href=&quot;git-rev-parse&quot;&gt;자식 반전 파싱 [1]&lt;/a&gt; 명령 커밋에 대한 오브젝트 명에 커밋위한 몇몇 이름 번역을위한 때때로 유용 로우 레벨 명령이다 :</target>
        </trans-unit>
        <trans-unit id="d0ac1c8438cdf91fddee2ad5a2dd381f720a6756" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; command is available since Git 1.5.3. Users with Git 1.5.2 can look up the submodule commits in the repository and manually check them out; earlier versions won&amp;rsquo;t recognize the submodules at all.</source>
          <target state="translated">&lt;a href=&quot;git-submodule&quot;&gt;자식 - 서브 모듈 [1]&lt;/a&gt; 명령 힘내 1.5.3 때문에 가능하다. Git 1.5.2 사용자는 저장소에서 서브 모듈 커밋을 찾아 수동으로 체크 아웃 할 수 있습니다. 이전 버전에서는 하위 모듈을 전혀 인식하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="8ffc16af4f4197ccdbaaceb3fe6721dcc4562d83" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; command updates the index with information from the working directory. You generally update the index information by just specifying the filename you want to update, like so:</source>
          <target state="translated">&lt;a href=&quot;git-update-index&quot;&gt;자식 업데이트 인덱스 [1]&lt;/a&gt; 명령은 작업 디렉토리 정보로 인덱스를 업데이트합니다. 일반적으로 업데이트하려는 파일 이름을 지정하여 색인 정보를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="0eb5eb47b21a25e2f8cbcad63d82e49ed7b46c03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/newren/git-filter-repo/&quot;&gt;git filter-repo&lt;/a&gt; tool is an alternative to git-filter-branch which does not suffer from these performance problems or the safety problems (mentioned below). For those with existing tooling which relies upon git-filter-branch, &lt;code&gt;git filter-repo&lt;/code&gt; also provides &lt;a href=&quot;https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely&quot;&gt;filter-lamely&lt;/a&gt;, a drop-in git-filter-branch replacement (with a few caveats). While filter-lamely suffers from all the same safety issues as git-filter-branch, it at least ameliorates the performance issues a little.</source>
          <target state="translated">The &lt;a href=&quot;https://github.com/newren/git-filter-repo/&quot;&gt;git filter-repo&lt;/a&gt; tool is an alternative to git-filter-branch which does not suffer from these performance problems or the safety problems (mentioned below). For those with existing tooling which relies upon git-filter-branch, &lt;code&gt;git filter-repo&lt;/code&gt; also provides &lt;a href=&quot;https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely&quot;&gt;filter-lamely&lt;/a&gt;, a drop-in git-filter-branch replacement (with a few caveats). While filter-lamely suffers from all the same safety issues as git-filter-branch, it at least ameliorates the performance issues a little.</target>
        </trans-unit>
        <trans-unit id="20874526426e66810d4174f5227a378a8de7e91c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/newren/git-filter-repo/&quot;&gt;git filter-repo&lt;/a&gt; tool is an alternative to git-filter-branch which does not suffer from these performance problems or the safety problems (mentioned below). For those with existing tooling which relies upon git-filter-branch, &lt;code&gt;git repo-filter&lt;/code&gt; also provides &lt;a href=&quot;https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely&quot;&gt;filter-lamely&lt;/a&gt;, a drop-in git-filter-branch replacement (with a few caveats). While filter-lamely suffers from all the same safety issues as git-filter-branch, it at least ameliorates the performance issues a little.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/newren/git-filter-repo/&quot;&gt;자식 필터의 repo&lt;/a&gt; 도구는 이러한 성능 문제 나 안전 문제 (아래에서 설명)으로 고생하지 않는 자식 필터 - 지점의 대안입니다. 자식 필터 - 지점에 의존 기존 공구와 사람들을 위해, &lt;code&gt;git repo-filter&lt;/code&gt; 또한 제공하는 &lt;a href=&quot;https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely&quot;&gt;필터 lamely&lt;/a&gt; , (몇 가지주의와) 자식 필터 - 지점 드롭 인 교체. 필터는 거의 git-filter-branch와 동일한 모든 안전 문제를 겪지 만 최소한 성능 문제를 약간 개선합니다.</target>
        </trans-unit>
        <trans-unit id="ad21d56fce6cdd39ef4f92ed0708902d059eaafc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;user-manual&quot;&gt;Git User&amp;rsquo;s Manual&lt;/a&gt; provides a more comprehensive introduction to Git.</source>
          <target state="translated">&lt;a href=&quot;user-manual&quot;&gt;망할 놈의 사용 설명서는&lt;/a&gt; 힘내에 대한보다 포괄적 인 소개를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="89c784f1b1d17488cfe361d4581fd69d6d34303d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;user-manual#git-concepts&quot;&gt;Git concepts chapter of the user-manual&lt;/a&gt; and &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt; both provide introductions to the underlying Git architecture.</source>
          <target state="translated">&lt;a href=&quot;user-manual#git-concepts&quot;&gt;사용자 매뉴얼&lt;/a&gt; 및 &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial [7]&lt;/a&gt; 의 Git 개념 장은 기본 Git 아키텍처에 대한 소개를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5f7a0a0ce9975de955e97678d53d0386ebf8b091" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; file is used to define the skip-worktree reference bitmap. When Git updates the working directory, it updates the skip-worktree bits in the index based on this file. The files matching the patterns in the file will appear in the working directory, and the rest will not.</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; 파일은 스킵-worktree 참조 비트 맵을 정의하는 데 사용됩니다. Git은 작업 디렉토리를 업데이트 할 때이 파일을 기반으로 인덱스의 skip-worktree 비트를 업데이트합니다. 파일의 패턴과 일치하는 파일이 작업 디렉토리에 나타나고 나머지는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18927ccc4077efc9fa00280f487bf7ea52068011" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;any&amp;gt;&lt;/code&gt; part of the command may contain any sequence of bytes that does not contain &lt;code&gt;LF&lt;/code&gt;. The &lt;code&gt;LF&lt;/code&gt; after the command is optional. Callers may wish to process the output through a tool such as sed to remove the leading part of the line, for example:</source>
          <target state="translated">명령 의 &lt;code&gt;&amp;lt;any&amp;gt;&lt;/code&gt; 부분에는 &lt;code&gt;LF&lt;/code&gt; 가 포함되지 않은 바이트 시퀀스가 ​​포함될 수 있습니다 . &lt;code&gt;LF&lt;/code&gt; 명령 후에는 선택 사항입니다. 발신자는 sed와 같은 도구를 통해 출력을 처리하여 회선의 앞 부분을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38ecaff497a30523addb0d68ac2f3ff7d62121ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; can be a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) or the full 40-byte SHA-1 of a Git tag, commit, or tree object, preexisting or waiting to be written. The path is relative to the top level of the tree named by &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 일 수있는 기준 마크 ( &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ) 또는 전체 40 바이트의 SHA-1 힘내 태그가 이미 존재하거나 기입하도록 대기 커밋 또는 트리 오브젝트. 경로는 &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 로 명명 된 트리의 최상위 레벨을 기준으로합니다 .</target>
        </trans-unit>
        <trans-unit id="df9429d81584e26f1a55e7eff78d6952383c6adf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; can be either a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) set previously or a full 40-byte SHA-1 of a Git blob, preexisting or ready to be written.</source>
          <target state="translated">&lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 일 수있는 기준 마크 중 ( &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ) 또는 기존 기록 할 준비가 미리 설정하거나 전체 40 바이트의 SHA-1 힘내의 블롭.</target>
        </trans-unit>
        <trans-unit id="d38490ce2af2d9b14b21e7e25c13d2a1c79c408e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; part of the command may contain any of the options listed in the OPTIONS section that do not change import semantics, without the leading &lt;code&gt;--&lt;/code&gt; and is treated in the same way.</source>
          <target state="translated">&lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 명령의 일부 선도하지 않고, 수입의 의미를 변경하지 않는 옵션 섹션에 나열된 옵션 중 하나를 포함 할 수있다 &lt;code&gt;--&lt;/code&gt; 과 같은 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="73cfe0e2f7b7cccff976b7e355044194793ceedb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;pushurl&amp;gt;&lt;/code&gt; is used for pushes only. It is optional and defaults to &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;&amp;lt;pushurl&amp;gt;&lt;/code&gt; 만 밀어 사용된다. 선택 사항이며 기본값은 &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="226bf97de37dae89426f4bcaf2c8464c2aaac4ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;rev&amp;gt;^-[&amp;lt;n&amp;gt;]&lt;/code&gt; notation includes &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; but excludes the &amp;lt;n&amp;gt;th parent (i.e. a shorthand for &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt;), with &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1 if not given. This is typically useful for merge commits where you can just pass &lt;code&gt;&amp;lt;commit&amp;gt;^-&lt;/code&gt; to get all the commits in the branch that was merged in merge commit &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; (including &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; itself).</source>
          <target state="translated">&lt;code&gt;&amp;lt;rev&amp;gt;^-[&amp;lt;n&amp;gt;]&lt;/code&gt; 표기 포함 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 대상이지만 &amp;lt;N&amp;gt; 제 부모 (즉, 쉬트를위한 &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt; 로) &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1이면 주어지지 않았습니다. 이것은 일반적으로 &lt;code&gt;&amp;lt;commit&amp;gt;^-&lt;/code&gt; 를 전달 하여 병합 커밋 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 에 병합 된 분기의 모든 커밋 ( &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 자체 포함) 을 가져올 수있는 병합 커밋에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="382c52b269a126869d3f5e611e50db349c01a555" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; is just a good idea when you know the rest will be filenames; it will prevent problems with a filename of, for example, &lt;code&gt;-a&lt;/code&gt;. Using &lt;code&gt;--&lt;/code&gt; is probably a good policy in scripts.</source>
          <target state="translated">은 &lt;code&gt;--&lt;/code&gt; 당신이 나머지 파일 이름이 될 것입니다 알고 그냥 좋은 아이디어이다; 예를 들어 &lt;code&gt;-a&lt;/code&gt; 와 같은 파일 이름 문제를 방지합니다 . &lt;code&gt;--&lt;/code&gt; 사용 하는 것이 스크립트에서 좋은 정책 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="1a7c2f7d5b7ec8386e86076d812d974232af3082" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--cached&lt;/code&gt; option is used to ask a command that usually works on files in the working tree to &lt;strong&gt;only&lt;/strong&gt; work with the index. For example, &lt;code&gt;git grep&lt;/code&gt;, when used without a commit to specify from which commit to look for strings in, usually works on files in the working tree, but with the &lt;code&gt;--cached&lt;/code&gt; option, it looks for strings in the index.</source>
          <target state="translated">&lt;code&gt;--cached&lt;/code&gt; 옵션은 일반적으로 작업 트리에있는 파일에 작동하는 명령을 요청하는 데 사용됩니다 &lt;strong&gt;에만&lt;/strong&gt; 인덱스와 함께 일을. 예를 들어, &lt;code&gt;git grep&lt;/code&gt; 은 커밋없이 문자열을 찾을 커밋을 지정하면 일반적으로 작업 트리의 파일에서 작동하지만 &lt;code&gt;--cached&lt;/code&gt; 옵션을 사용하면 인덱스에서 문자열을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="93eb90d6c0bfdb16dcadbf4c72d38d80f8bf4451" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--dry-run&lt;/code&gt; option can be used to obtain a summary of what is included by any of the above for the next commit by giving the same set of parameters (options and paths).</source>
          <target state="translated">&lt;code&gt;--dry-run&lt;/code&gt; 옵션은 다음 매개 변수 (옵션 및 경로)의 동일한 세트를 제공하여 커밋 위의 모든으로 무엇이 포함되어 있는지의 요약 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45e26263ba79c46b47e35a4fe67d4d8f33b37e0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--env-filter&lt;/code&gt; option can be used to modify committer and/or author identity. For example, if you found out that your commits have the wrong identity due to a misconfigured user.email, you can make a correction, before publishing the project, like this:</source>
          <target state="translated">&lt;code&gt;--env-filter&lt;/code&gt; 옵션은 커미터 및 / 또는 저자의 정체성을 수정하는 데 사용할 수 있습니다. 예를 들어, 잘못 구성된 user.email로 인해 커밋에 잘못된 ID가있는 것을 발견 한 경우 프로젝트를 게시하기 전에 다음과 같이 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4b7635118d0a90fb277012f2d96d5181b61e4f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--index&lt;/code&gt; option is used to ask a command that usually works on files in the working tree to &lt;strong&gt;also&lt;/strong&gt; affect the index. For example, &lt;code&gt;git stash apply&lt;/code&gt; usually merges changes recorded in a stash entry to the working tree, but with the &lt;code&gt;--index&lt;/code&gt; option, it also merges changes to the index as well.</source>
          <target state="translated">&lt;code&gt;--index&lt;/code&gt; 옵션에 있음은 일반적으로 작업 트리에있는 파일에 작동하는 명령을 요청하는 데 사용됩니다 &lt;strong&gt;또한&lt;/strong&gt; 인덱스에 영향을 미칠합니다. 예를 들어, &lt;code&gt;git stash apply&lt;/code&gt; 는 일반적으로 숨김 항목에 기록 된 변경 사항을 작업 트리에 병합 하지만 &lt;code&gt;--index&lt;/code&gt; 옵션을 사용하면 변경 사항도 색인에 병합합니다.</target>
        </trans-unit>
        <trans-unit id="f5e672ca7275921f27bc57abfee8498efa38d837" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--numstat&lt;/code&gt; option gives the diffstat(1) information but is designed for easier machine consumption. An entry in &lt;code&gt;--numstat&lt;/code&gt; output looks like this:</source>
          <target state="translated">&lt;code&gt;--numstat&lt;/code&gt; 옵션은 diffstat (1) 정보를 제공하지만, 쉽게 기계 소비를 위해 설계되었습니다. &lt;code&gt;--numstat&lt;/code&gt; 출력 의 항목은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="824224d8413c92cfa07b10a7d5f109653a254225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--patch&lt;/code&gt; option implies &lt;code&gt;--keep-index&lt;/code&gt;. You can use &lt;code&gt;--no-keep-index&lt;/code&gt; to override this.</source>
          <target state="translated">&lt;code&gt;--patch&lt;/code&gt; 옵션은 의미 &lt;code&gt;--keep-index&lt;/code&gt; . 당신은 사용할 수 있습니다 &lt;code&gt;--no-keep-index&lt;/code&gt; 이 메소드를 오버라이드 (override) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd53bf0606653a9e38fc2f67928f722d519b8437" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--prune-tags&lt;/code&gt; option is equivalent to having &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; declared in the refspecs of the remote. This can lead to some seemingly strange interactions:</source>
          <target state="translated">&lt;code&gt;--prune-tags&lt;/code&gt; 옵션은 리모컨 의 참조 사양에 &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; 가 선언되어있는 것과 같습니다. 이것은 겉보기에 이상한 상호 작용으로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eedbb7a82985c4671f5041c09553972a9225fc17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--rebase-merges&lt;/code&gt; mode is similar in spirit to the deprecated &lt;code&gt;--preserve-merges&lt;/code&gt; but works with interactive rebases, where commits can be reordered, inserted and dropped at will.</source>
          <target state="translated">&lt;code&gt;--rebase-merges&lt;/code&gt; 모드는 사용되지 않는 정신에는 변함이있다 &lt;code&gt;--preserve-merges&lt;/code&gt; 하지만 커밋이 순서가 삽입 의지에 드롭 할 수있는 대화 형 rebases, 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8061f1189be4b513311a10997c4e6fc449baeaf4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--simplify-by-decoration&lt;/code&gt; option allows you to view only the big picture of the topology of the history, by omitting commits that are not referenced by tags. Commits are marked as !TREESAME (in other words, kept after history simplification rules described above) if (1) they are referenced by tags, or (2) they change the contents of the paths given on the command line. All other commits are marked as TREESAME (subject to be simplified away).</source>
          <target state="translated">&lt;code&gt;--simplify-by-decoration&lt;/code&gt; 옵션을 사용하면 태그에 의해 참조되지 않는 커밋을 생략하여, 역사의 토폴로지의 큰 그림을 볼 수 있습니다. 커밋은 (1) 태그로 참조되거나 (2) 명령 줄에 지정된 경로의 내용을 변경하는 경우! TREESAME (즉, 위에서 설명한 기록 단순화 규칙 후에 유지됨)로 표시됩니다. 다른 모든 커밋은 TREESAME로 표시됩니다 (간단히 삭제해야 함).</target>
        </trans-unit>
        <trans-unit id="16b8753fdc735c82bb8e4b4e3197e33fe132b018" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--summary&lt;/code&gt; option describes newly added, deleted, renamed and copied files. The &lt;code&gt;--stat&lt;/code&gt; option adds diffstat(1) graph to the output. These options can be combined with other options, such as &lt;code&gt;-p&lt;/code&gt;, and are meant for human consumption.</source>
          <target state="translated">&lt;code&gt;--summary&lt;/code&gt; 옵션은 새로 추가, 삭제, 파일 이름 및 복사에 대해 설명합니다. &lt;code&gt;--stat&lt;/code&gt; 옵션 출력 diffstat (1)의 그래프를 추가한다. 이러한 옵션은 &lt;code&gt;-p&lt;/code&gt; 와 같은 다른 옵션과 결합하여 사람이 소비 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="629d4eddaa3e0be951f311129548061d6a37661e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--threads&lt;/code&gt; option (and the grep.threads configuration) will be ignored when &lt;code&gt;--open-files-in-pager&lt;/code&gt; is used, forcing a single-threaded execution.</source>
          <target state="translated">The &lt;code&gt;--threads&lt;/code&gt; option (and the grep.threads configuration) will be ignored when &lt;code&gt;--open-files-in-pager&lt;/code&gt; is used, forcing a single-threaded execution.</target>
        </trans-unit>
        <trans-unit id="2fb3a538afbb18a8ca912f0cecf9a31cb6701775" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; option instructs &lt;code&gt;git config&lt;/code&gt; to ensure that incoming and outgoing values are canonicalize-able under the given &amp;lt;type&amp;gt;. If no &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; is given, no canonicalization will be performed. Callers may unset an existing &lt;code&gt;--type&lt;/code&gt; specifier with &lt;code&gt;--no-type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; 옵션을 지시 &lt;code&gt;git config&lt;/code&gt; 이 수신 및 발신 값이 주어진 &amp;lt;형&amp;gt;에서-수를 정규화를하고 있는지 확인할 수도 있습니다. 어떤 경우 &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; 주어지지 않는 어떤 정규화가 수행되지 않는다. 호출자는 &lt;code&gt;--no-type&lt;/code&gt; 으로 기존 &lt;code&gt;--type&lt;/code&gt; 지정자를 설정 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c9422891d35819a54a8ef0ba6d7016d122547ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-M&lt;/code&gt; and &lt;code&gt;-C&lt;/code&gt; options require O(n^2) processing time where n is the number of potential rename/copy targets. This option prevents rename/copy detection from running if the number of rename/copy targets exceeds the specified number.</source>
          <target state="translated">&lt;code&gt;-M&lt;/code&gt; 및 &lt;code&gt;-C&lt;/code&gt; 옵션 타겟 복사 / N 전위 바꾸기의 수이고 처리 시간 O (N ^ 2)을 필요로한다. 이 옵션은 이름 바꾸기 / 복사 대상 수가 지정된 수를 초과하는 경우 이름 바꾸기 / 복사 감지가 실행되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="73fff0c26b859dbfe915afb814a50fa7bc541c41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-C&lt;/code&gt; options have the exact same semantics as &lt;code&gt;-m&lt;/code&gt; and &lt;code&gt;-M&lt;/code&gt;, except instead of the branch being renamed it along with its config and reflog will be copied to a new name.</source>
          <target state="translated">&lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-C&lt;/code&gt; 옵션과 동일한 의미가 &lt;code&gt;-m&lt;/code&gt; 과 &lt;code&gt;-M&lt;/code&gt; 을 새 이름으로 복사됩니다의 설정 및 reflog와 함께 이름을 변경 분기되는 대신 제외시켰다.</target>
        </trans-unit>
        <trans-unit id="89a7df63322c3f15984d17c0e2db0a5d71e95aa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-m&lt;/code&gt; and &lt;code&gt;-F&lt;/code&gt; options can be given any number of times, in any order. The commit log message will be composed in the order in which the options are given.</source>
          <target state="translated">&lt;code&gt;-m&lt;/code&gt; 및 &lt;code&gt;-F&lt;/code&gt; 옵션은 임의의 순서로, 여러 번을 부여 할 수 있습니다. 커밋 로그 메시지는 옵션이 주어진 순서대로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f4502e6a26132411ed2e9fd1c43849a487e5e5a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-m&lt;/code&gt; option is mutually exclusive with &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt;, and &lt;code&gt;-F&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-m&lt;/code&gt; 옵션과 함께 사용할 수있다 &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; , 및 &lt;code&gt;-F&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38779d2c15d6e090718b82e6af2f8c359ec976d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.git-credentials&lt;/code&gt; file is stored in plaintext. Each credential is stored on its own line as a URL like:</source>
          <target state="translated">&lt;code&gt;.git-credentials&lt;/code&gt; 파일은 일반 텍스트로 저장됩니다. 각 자격 증명은 다음과 같은 URL로 자체 줄에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="905c63d14654cde00625cb5e82c7038bc34ea94e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.gitmodules&lt;/code&gt; file inside the superproject. A project usually uses this file to suggest defaults for the upstream collection of repositories for the mapping that is required between a submodule&amp;rsquo;s name and its path.</source>
          <target state="translated">&lt;code&gt;.gitmodules&lt;/code&gt; 는 superproject 내부 파일. 프로젝트는 일반적으로이 파일을 사용하여 서브 모듈의 이름과 경로 사이에 필요한 매핑의 업스트림 리포지토리 모음에 대한 기본값을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="0bb4fdb786947245a90430b5697a0e9422df1d21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.gitmodules&lt;/code&gt; file, located in the top-level directory of a Git working tree, is a text file with a syntax matching the requirements of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.gitmodules&lt;/code&gt; 의 망할 놈의 작업 트리의 최상위 디렉토리에있는 파일의 요구 사항과 일치하는 구문을 사용하여 텍스트 파일입니다 &lt;a href=&quot;git-config&quot;&gt;자식-설정 [1]을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5324d8792f18dd9ac59490b336e09b1bd43353e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.mailmap&lt;/code&gt; feature is used to coalesce together commits by the same person in the shortlog, where their name and/or email address was spelled differently.</source>
          <target state="translated">&lt;code&gt;.mailmap&lt;/code&gt; 기능은 자신의 이름 및 / 또는 이메일 주소가 다르게 철자 된 shortlog에서 같은 사람에 의해 병합 함께 커밋하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="73c3a5a96a8a6a48d412facd438733454a4a63a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; ref is set to point at the commit that introduced the change that is difficult to apply.</source>
          <target state="translated">&lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; 의 심판을 가리 키도록 설정되어 적용하기 어려운 변화를 도입하는 것이 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="df208c183263acdaf73c0a978db9f5c35380bc6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; environment variables and the &lt;code&gt;--date&lt;/code&gt; option support the following date formats:</source>
          <target state="translated">&lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; 의 환경 변수와 &lt;code&gt;--date&lt;/code&gt; 옵션 지원 다음과 같은 날짜 형식 :</target>
        </trans-unit>
        <trans-unit id="ad08232602558aa9979e8ccc7bf4df9612b12ec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; environment variables support the following date formats:</source>
          <target state="translated">&lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; 의 환경 변수는 다음과 같은 날짜 형식을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="9c24e5e1da9f8726ec7abe4516a017b9495c2fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; environmental variable may be passed to &lt;code&gt;git-http-backend&lt;/code&gt; to bypass the check for the &quot;git-daemon-export-ok&quot; file in each repository before allowing export of that repository.</source>
          <target state="translated">&lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; 환경 변수에 전달 될 수 &lt;code&gt;git-http-backend&lt;/code&gt; 그 저장소의 수출을 허용하기 전에 각 저장소에 &quot;자식 - 데몬 - 수출 - 확인&quot;파일에 대한 검사 우회.</target>
        </trans-unit>
        <trans-unit id="387cfeb550226cfd9e601b1b72a83920c3f36040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_HTTP_MAX_REQUEST_BUFFER&lt;/code&gt; environment variable (or the &lt;code&gt;http.maxRequestBuffer&lt;/code&gt; config variable) may be set to change the largest ref negotiation request that git will handle during a fetch; any fetch requiring a larger buffer will not succeed. This value should not normally need to be changed, but may be helpful if you are fetching from a repository with an extremely large number of refs. The value can be specified with a unit (e.g., &lt;code&gt;100M&lt;/code&gt; for 100 megabytes). The default is 10 megabytes.</source>
          <target state="translated">&lt;code&gt;GIT_HTTP_MAX_REQUEST_BUFFER&lt;/code&gt; 의 환경 변수 (또는 &lt;code&gt;http.maxRequestBuffer&lt;/code&gt; 설정 변수) 자식은 인출 중에 처리하는 것이 가장 REF 협상 요청을 변경하도록 설정 될 수있다; 더 큰 버퍼를 요구하는 페치는 성공하지 못합니다. 이 값은 일반적으로 변경하지 않아도되지만 참조 수가 많은 리포지토리에서 가져 오는 경우 유용 할 수 있습니다. 값은 단위로 지정할 수 있습니다 (예 : &lt;code&gt;100M&lt;/code&gt; B의 경우 100M ). 기본값은 10MB입니다.</target>
        </trans-unit>
        <trans-unit id="166eca4501cd90cd3b21f8df969c5ee397d12242" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_NO_REPLACE_OBJECTS&lt;/code&gt; environment variable can be set to achieve the same effect as the &lt;code&gt;--no-replace-objects&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;GIT_NO_REPLACE_OBJECTS&lt;/code&gt; 의 환경 변수는 동일한 효과를 달성하기 위해 설정 될 수있다 &lt;code&gt;--no-replace-objects&lt;/code&gt; 옵션.</target>
        </trans-unit>
        <trans-unit id="8bee9745a8d6377da5f35089625008b4042f0f35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_PUSH_CERT*&lt;/code&gt; environment variables can be inspected, just as in &lt;code&gt;pre-receive&lt;/code&gt; hook, after accepting a signed push.</source>
          <target state="translated">&lt;code&gt;GIT_PUSH_CERT*&lt;/code&gt; 환경 변수는 단지 같이 검사 될 수있는 &lt;code&gt;pre-receive&lt;/code&gt; 서명 푸시 접수 후, 후크.</target>
        </trans-unit>
        <trans-unit id="8bc6550bd201f7a8ce8611abf35f278e4b89d03c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; pointer stays the same.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 의 포인터는 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="652c0cf20ffd72216eb399a1f559569365b85933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after &lt;code&gt;&amp;lt;delim&amp;gt; LF&lt;/code&gt; is optional (it used to be required).</source>
          <target state="translated">&lt;code&gt;LF&lt;/code&gt; 후 &lt;code&gt;&amp;lt;delim&amp;gt; LF&lt;/code&gt; 선택적이며 (이것은 필요에 사용됨).</target>
        </trans-unit>
        <trans-unit id="c1bff9f88ec1fe482fd273291dfad27de492749b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; is optional (it used to be required) but recommended. Always including it makes debugging a fast-import stream easier as the next command always starts in column 0 of the next line, even if &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; did not end with an &lt;code&gt;LF&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; 이후 의 &lt;code&gt;LF&lt;/code&gt; 는 선택 사항이지만 (필요 했음) 권장됩니다. &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; 가 &lt;code&gt;LF&lt;/code&gt; 로 끝나지 않더라도 다음 명령이 항상 다음 행의 0 열에서 시작되므로 항상이를 포함하면 빠른 가져 오기 스트림 디버깅이 쉬워집니다 .</target>
        </trans-unit>
        <trans-unit id="ec7a854b1a4c70ca562f0584186eed412906ec8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after the command is optional (it used to be required).</source>
          <target state="translated">명령 뒤 의 &lt;code&gt;LF&lt;/code&gt; 는 선택 사항입니다 (필요 했음).</target>
        </trans-unit>
        <trans-unit id="9a136595a2c2895a25e4571b5fe242dd49c2174e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after the command is optional (it used to be required). Note that for reasons of backward compatibility, if the commit ends with a &lt;code&gt;data&lt;/code&gt; command (i.e. it has no &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt;, &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filedelete&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt;, &lt;code&gt;filedeleteall&lt;/code&gt; or &lt;code&gt;notemodify&lt;/code&gt; commands) then two &lt;code&gt;LF&lt;/code&gt; commands may appear at the end of the command instead of just one.</source>
          <target state="translated">명령 뒤 의 &lt;code&gt;LF&lt;/code&gt; 는 선택 사항입니다 (필요 했음). 이전 버전과의 호환성을 위해 커밋이 &lt;code&gt;data&lt;/code&gt; 명령으로 끝나는 경우 (즉 , &lt;code&gt;from&lt;/code&gt; , &lt;code&gt;merge&lt;/code&gt; , &lt;code&gt;filemodify&lt;/code&gt; , &lt;code&gt;filedelete&lt;/code&gt; , &lt;code&gt;filecopy&lt;/code&gt; , &lt;code&gt;filerename&lt;/code&gt; , &lt;code&gt;filedeleteall&lt;/code&gt; 또는 &lt;code&gt;notemodify&lt;/code&gt; 명령이없는 경우) 명령 끝에 두 개의 &lt;code&gt;LF&lt;/code&gt; 명령이 나타날 수 있습니다. 단 하나 대신.</target>
        </trans-unit>
        <trans-unit id="6afb1837ee3e8f65249dcb4905156711b603dd19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MERGE_HEAD&lt;/code&gt; ref is set to point to the other branch head.</source>
          <target state="translated">&lt;code&gt;MERGE_HEAD&lt;/code&gt; 의 심판이 다른 지점 머리에 포인트로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4dcd07a8427d3cae73e7340717a2be5da78b122e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;^0&lt;/code&gt; suffix is necessary as fast-import does not permit a branch to start from itself, and the branch is created in memory before the &lt;code&gt;from&lt;/code&gt; command is even read from the input. Adding &lt;code&gt;^0&lt;/code&gt; will force fast-import to resolve the commit through Git&amp;rsquo;s revision parsing library, rather than its internal branch table, thereby loading in the existing value of the branch.</source>
          <target state="translated">&lt;code&gt;^0&lt;/code&gt; 접미사는 빠른 가져 오기 자체에서 시작하는 지점을 허용하지 않는 한 필요하고, 전 분기 메모리에 생성 &lt;code&gt;from&lt;/code&gt; 명령도 입력에서 읽습니다. &lt;code&gt;^0&lt;/code&gt; 을 추가하면 내부 가져 오기 테이블이 아닌 Git의 개정 구문 분석 라이브러리를 통해 커밋을 해결하기 위해 빠른 가져 오기를 강제 실행하여 기존 분기 값으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="675155c0bc0c9682b02ea7dc72c6fe717f8d57df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;^r1 r2&lt;/code&gt; set operation appears so often that there is a shorthand for it. When you have two commits &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; (named according to the syntax explained in SPECIFYING REVISIONS above), you can ask for commits that are reachable from r2 excluding those that are reachable from r1 by &lt;code&gt;^r1 r2&lt;/code&gt; and it can be written as &lt;code&gt;r1..r2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;^r1 r2&lt;/code&gt; 설정 동작은 너무 자주 속기있을 것으로 보인다. 커밋 &lt;code&gt;r1&lt;/code&gt; 과 &lt;code&gt;r2&lt;/code&gt; 가 두 개인 경우 (위의 사양 수정에 설명 된 구문에 따라 이름이 지정됨), r1에서 &lt;code&gt;^r1 r2&lt;/code&gt; 까지 도달 할 수있는 커밋을 제외하고 r2에서 도달 할 수있는 커밋을 요청할 수 있으며 r1 으로 쓸 수 있습니다 &lt;code&gt;r1..r2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c300333c575f956c2060e4236a825e5a15abf118" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a/&lt;/code&gt; and &lt;code&gt;b/&lt;/code&gt; filenames are the same unless rename/copy is involved. Especially, even for a creation or a deletion, &lt;code&gt;/dev/null&lt;/code&gt; is &lt;code&gt;not&lt;/code&gt; used in place of the &lt;code&gt;a/&lt;/code&gt; or &lt;code&gt;b/&lt;/code&gt; filenames.</source>
          <target state="translated">&lt;code&gt;a/&lt;/code&gt; 및 &lt;code&gt;b/&lt;/code&gt; 파일 이름 바꾸기 / 복사본을 포함하지 않는 동일하다. 특히, 작성 또는 삭제 의 경우에도 &lt;code&gt;a/&lt;/code&gt; 또는 &lt;code&gt;b/&lt;/code&gt; 파일 이름 대신 &lt;code&gt;/dev/null&lt;/code&gt; 이 사용 &lt;code&gt;not&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49bd789d4ba6e2342461dc4954bea6426d4910cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;author.name&lt;/code&gt; and &lt;code&gt;committer.name&lt;/code&gt; and their corresponding email options override &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; if set and are overridden themselves by the environment variables.</source>
          <target state="translated">The &lt;code&gt;author.name&lt;/code&gt; and &lt;code&gt;committer.name&lt;/code&gt; and their corresponding email options override &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; if set and are overridden themselves by the environment variables.</target>
        </trans-unit>
        <trans-unit id="eab33dae66d0744b7d6024e6ba0526d3cbdb099d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;base commit&lt;/code&gt; is shown as &quot;base-commit: &quot; followed by the 40-hex of the commit object name. A &lt;code&gt;prerequisite patch&lt;/code&gt; is shown as &quot;prerequisite-patch-id: &quot; followed by the 40-hex &lt;code&gt;patch id&lt;/code&gt;, which can be obtained by passing the patch through the &lt;code&gt;git patch-id --stable&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;base commit&lt;/code&gt; 커밋 객체 이름의 40 진수 뒤에 &quot;베이스 커밋&quot;로 도시되어있다. &lt;code&gt;prerequisite patch&lt;/code&gt; 40 진수 다음 &quot;필수 패치-ID '로서 도시되어 &lt;code&gt;patch id&lt;/code&gt; 관통 패치를 통과시킴으로써 얻을 수 있고, &lt;code&gt;git patch-id --stable&lt;/code&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="4310c66d08d5e3db5f29a0976c449ecfedbc1c27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;category&lt;/code&gt; field may be used in a future enhancement to do category-based filtering.</source>
          <target state="translated">&lt;code&gt;category&lt;/code&gt; 필드는 장르 기반 필터링을 할 수있는 미래의 개선에 이용 될 수있다.</target>
        </trans-unit>
        <trans-unit id="957c03f80393df2f84f209da8b3d5d5b6c66e351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;commit walkers&lt;/code&gt; are sometimes also called &lt;code&gt;dumb transports&lt;/code&gt;, because they do not require any Git aware smart server like Git Native transport does. Any stock HTTP server that does not even support directory index would suffice. But you must prepare your repository with &lt;code&gt;git update-server-info&lt;/code&gt; to help dumb transport downloaders.</source>
          <target state="translated">&lt;code&gt;commit walkers&lt;/code&gt; 때때로라고 &lt;code&gt;dumb transports&lt;/code&gt; 망할 놈의 기본 전송이하는 것처럼 그들이 어떤 망할 놈의 인식 스마트 서버를 필요로하지 않기 때문에. 디렉토리 색인을 지원하지 않는 모든 기본 HTTP 서버로 충분합니다. 그러나 멍청한 전송 다운로더를 돕기 위해 &lt;code&gt;git update-server-info&lt;/code&gt; 로 저장소를 준비해야합니다 .</target>
        </trans-unit>
        <trans-unit id="16292719b3497b67052d324a828a5bf607c10cb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;committer&lt;/code&gt; command indicates who made this commit, and when they made it.</source>
          <target state="translated">&lt;code&gt;committer&lt;/code&gt; 명령은이 커밋했고, 그들이 그것을 만들 때 사람을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7e0ffba56fb259ff8ccb9999d0c02587815b0675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable allows you to define what &lt;code&gt;diff&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; should consider whitespace errors for all paths in the project (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). This attribute gives you finer control per path.</source>
          <target state="translated">&lt;code&gt;core.whitespace&lt;/code&gt; 의 구성 변수 당신이 무엇을 정의 할 수 있습니다 &lt;code&gt;diff&lt;/code&gt; 하고 &lt;code&gt;apply&lt;/code&gt; 고려해야 공백 프로젝트의 모든 경로에 대한 오류 (참조 &lt;a href=&quot;git-config&quot;&gt;자식-설정 [1]&lt;/a&gt; ). 이 속성은 경로마다 더 세밀한 제어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c4cf312c5837f50305786c4fff7bd921da0df1e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; command following &lt;code&gt;committer&lt;/code&gt; must supply the commit message (see below for &lt;code&gt;data&lt;/code&gt; command syntax). To import an empty commit message use a 0 length data. Commit messages are free-form and are not interpreted by Git. Currently they must be encoded in UTF-8, as fast-import does not permit other encodings to be specified.</source>
          <target state="translated">&lt;code&gt;committer&lt;/code&gt; 다음 의 &lt;code&gt;data&lt;/code&gt; 명령 은 커밋 메시지를 제공해야합니다 ( &lt;code&gt;data&lt;/code&gt; 명령 구문 은 아래 참조 ). 빈 커밋 메시지를 가져 오려면 길이가 0 인 데이터를 사용하십시오. 커밋 메시지는 자유 형식이며 Git이 해석하지 않습니다. 빠른 가져 오기에서는 다른 인코딩을 지정할 수 없으므로 현재 UTF-8로 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe1dcaff1f205cb554cce0caa7f556f5b3750431" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; command following &lt;code&gt;tagger&lt;/code&gt; must supply the annotated tag message (see below for &lt;code&gt;data&lt;/code&gt; command syntax). To import an empty tag message use a 0 length data. Tag messages are free-form and are not interpreted by Git. Currently they must be encoded in UTF-8, as fast-import does not permit other encodings to be specified.</source>
          <target state="translated">&lt;code&gt;tagger&lt;/code&gt; 다음 의 &lt;code&gt;data&lt;/code&gt; 명령 은 주석이 달린 태그 메시지를 제공해야합니다 ( &lt;code&gt;data&lt;/code&gt; 명령 구문 은 아래 참조 ). 빈 태그 메시지를 가져 오려면 길이가 0 인 데이터를 사용하십시오. 태그 메시지는 자유 형식이며 Git에서 해석하지 않습니다. 빠른 가져 오기에서는 다른 인코딩을 지정할 수 없으므로 현재 UTF-8로 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="463a929e2c19b7bbf028008ad9aa5a5763e6cf66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export-marks&lt;/code&gt; and &lt;code&gt;import-marks&lt;/code&gt; capabilities, if specified, affect this command in so far as they are passed on to &lt;code&gt;git fast-export&lt;/code&gt;, which then will load/store a table of marks for local objects. This can be used to implement for incremental operations.</source>
          <target state="translated">&lt;code&gt;export-marks&lt;/code&gt; 및 &lt;code&gt;import-marks&lt;/code&gt; 에 기능을 지정하는 경우, 지금까지 그들이 통과로이 명령에 영향을 &lt;code&gt;git fast-export&lt;/code&gt; 다음로드 / 지역 객체에 대한 마크의 테이블을 저장합니다. 증분 작업을 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b29369cc7c91f799f3a98b04ce067ccee4eaff48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extra-info&lt;/code&gt; is again command-dependent. If it is empty, the preceding SP is also omitted. Currently, no commands pass any &lt;code&gt;extra-info&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;extra-info&lt;/code&gt; 다시 명령 의존한다. 비어 있으면 앞의 SP도 생략됩니다. 현재 어떤 명령도 &lt;code&gt;extra-info&lt;/code&gt; 를 전달하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="42c3cfeeb6fb7d3b809e4b2424ab05b633a62a10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format:&amp;lt;string&amp;gt;&lt;/code&gt; format allows you to specify which information you want to show. It works a little bit like printf format, with the notable exception that you get a newline with &lt;code&gt;%n&lt;/code&gt; instead of &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;format:&amp;lt;string&amp;gt;&lt;/code&gt; 형식은 당신이 표시하려는 정보를 지정할 수 있습니다. &lt;code&gt;\n&lt;/code&gt; 대신 &lt;code&gt;%n&lt;/code&gt; 사용 하여 줄 바꿈을 얻는다는 점을 제외하면 printf 형식과 약간 비슷합니다 .</target>
        </trans-unit>
        <trans-unit id="6d12446e6ba50613ffa6591e4d86ab902d5b116f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; command is the same as in the &lt;code&gt;commit&lt;/code&gt; command; see above for details.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; (가)와 같이 명령은 동일 &lt;code&gt;commit&lt;/code&gt; 명령; 자세한 내용은 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d9bc1ff5b134d7635edcea3cd4e631a291483167" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; command is used to specify the commit to initialize this branch from. This revision will be the first ancestor of the new commit. The state of the tree built at this commit will begin with the state at the &lt;code&gt;from&lt;/code&gt; commit, and be altered by the content modifications in this commit.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 명령은이에서이 지점을 초기화하는 커밋 지정하는 데 사용됩니다. 이 개정판은 새로운 커밋의 첫 번째 조상이 될 것입니다. 이 커밋에서 빌드 된 트리의 상태는 &lt;code&gt;from&lt;/code&gt; 커밋 에서 상태로 시작 되며이 커밋의 내용 수정에 의해 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="75dab416c6ca16533650ccb3bdbb6f1c8c80e31e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git add&lt;/code&gt; command will not add ignored files by default. If any ignored files were explicitly specified on the command line, &lt;code&gt;git add&lt;/code&gt; will fail with a list of ignored files. Ignored files reached by directory recursion or filename globbing performed by Git (quote your globs before the shell) will be silently ignored. The &lt;code&gt;git add&lt;/code&gt; command can be used to add ignored files with the &lt;code&gt;-f&lt;/code&gt; (force) option.</source>
          <target state="translated">&lt;code&gt;git add&lt;/code&gt; 명령은 기본적으로 파일을 무시 추가하지 않습니다. 명령 행에 무시 된 파일이 명시 적으로 지정된 경우, &lt;code&gt;git add&lt;/code&gt; 는 무시 된 파일 목록과 함께 실패합니다. Git이 수행 한 디렉토리 재귀 또는 파일 이름 globbing (쉘 앞에 globs 인용)에 의해 무시 된 파일은 무시됩니다. &lt;code&gt;git add&lt;/code&gt; 명령이 함께 무시 파일을 추가 할 수 있습니다 &lt;code&gt;-f&lt;/code&gt; (강제) 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="9bd7293224a598d82d7fb9b059bf233156e9f91a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git bundle&lt;/code&gt; command packages objects and references in an archive at the originating machine, which can then be imported into another repository using &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt;, or &lt;code&gt;git clone&lt;/code&gt;, after moving the archive by some means (e.g., by sneakernet).</source>
          <target state="translated">&lt;code&gt;git bundle&lt;/code&gt; 다음 다른 사용 저장소로 가져올 수 발신 시스템에서 아카이브 명령 패키지 목적 및 참조 &lt;code&gt;git fetch&lt;/code&gt; , &lt;code&gt;git pull&lt;/code&gt; 또는 &lt;code&gt;git clone&lt;/code&gt; (체크를하면서 의해, 예) 일부에 의해 압축을 이동 한 후,.</target>
        </trans-unit>
        <trans-unit id="3d9620664b0c9d56c3287a812c3ff6b6d1c8717f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git diff-*&lt;/code&gt; family works by first comparing two sets of files:</source>
          <target state="translated">&lt;code&gt;git diff-*&lt;/code&gt; 첫번째 파일의 두 세트를 비교하여 가족 작품 :</target>
        </trans-unit>
        <trans-unit id="597ca1f538bf6e2f60b9e6f9e15d7129efb080fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git fetch&lt;/code&gt; operation always stores the head of the last fetched branch in FETCH_HEAD. For example, if you run &lt;code&gt;git fetch&lt;/code&gt; without specifying a local branch as the target of the operation</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 작업은 항상 FETCH_HEAD의 마지막 인출 지점의 머리를 저장합니다. 예를 들어, 로컬 분기를 작업 대상으로 지정하지 않고 &lt;code&gt;git fetch&lt;/code&gt; 를 실행하는 경우</target>
        </trans-unit>
        <trans-unit id="f809c0db2fabe1b716a044f1ae315c3eafe27e59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git fmt-merge-msg&lt;/code&gt; command can be used to give a good default for automated &lt;code&gt;git merge&lt;/code&gt; invocations. The automated message can include the branch description.</source>
          <target state="translated">&lt;code&gt;git fmt-merge-msg&lt;/code&gt; 명령은 자동화를위한 좋은 기본 제공하는 데 사용할 수있는 &lt;code&gt;git merge&lt;/code&gt; 호출을. 자동화 된 메시지에는 지사 설명이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dae50540309298598631c32bc4ba09615f81ee1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git gc --auto&lt;/code&gt; command will run the &lt;code&gt;pre-auto-gc&lt;/code&gt; hook. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;git gc --auto&lt;/code&gt; 명령은 실행 &lt;code&gt;pre-auto-gc&lt;/code&gt; 훅을. 자세한 내용은 &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cfc7fc175318cd6dff60f69f9572984dc7656815" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git grep&lt;/code&gt; command can search for strings in any version of your project, so</source>
          <target state="translated">&lt;code&gt;git grep&lt;/code&gt; 명령 때문에, 프로젝트의 모든 버전에서 문자열을 검색 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="10370106ed757f0fcfa619078db112558b3f4b4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git log&lt;/code&gt; command has a weakness: it must present commits in a list. When the history has lines of development that diverged and then merged back together, the order in which &lt;code&gt;git log&lt;/code&gt; presents those commits is meaningless.</source>
          <target state="translated">&lt;code&gt;git log&lt;/code&gt; 명령은 약점이있다 : 그것은 목록에 커밋을 제시해야합니다. 히스토리에 개발 라인이 분기되어 다시 병합 된 경우 &lt;code&gt;git log&lt;/code&gt; 가 해당 커밋을 표시 하는 순서 는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2918fcbf92a1ba7da67f920488e3f1571c6c776d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git pull&lt;/code&gt; command can also be given &lt;code&gt;.&lt;/code&gt; as the &quot;remote&quot; repository, in which case it just merges in a branch from the current repository; so the commands</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 명령도 제공 할 수있다 &lt;code&gt;.&lt;/code&gt; &quot;원격&quot;리포지토리로,이 경우에는 현재 리포지토리의 분기로 병합됩니다. 그래서 명령</target>
        </trans-unit>
        <trans-unit id="ae6be494d942d11be1fef84bf75e14340e42ba70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git sh-setup&lt;/code&gt; scriptlet is designed to be sourced (using &lt;code&gt;.&lt;/code&gt;) by other shell scripts to set up some variables pointing at the normal Git directories and a few helper shell functions.</source>
          <target state="translated">&lt;code&gt;git sh-setup&lt;/code&gt; 스크립틀릿은 (사용하여 공급하도록 설계되어 있습니다 &lt;code&gt;.&lt;/code&gt; 일반 망할 놈의 디렉토리와 몇 도우미 쉘 기능을 가리키는 몇 가지 변수를 설정하는 다른 쉘 스크립트에 의해).</target>
        </trans-unit>
        <trans-unit id="b8d00251834fb59fdb3aac3b6b6d2fd6617d8c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git status&lt;/code&gt; command can be used to obtain a summary of which files have changes that are staged for the next commit.</source>
          <target state="translated">&lt;code&gt;git status&lt;/code&gt; 명령은 파일을 다음 커밋을 위해 개최되는 변경 사항이있는 요약을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1114dd8f20b27292636eee44dbca10b695a7e192" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git submodule add &amp;lt;repo&amp;gt; &amp;lt;path&amp;gt;&lt;/code&gt; command does a couple of things:</source>
          <target state="translated">&lt;code&gt;git submodule add &amp;lt;repo&amp;gt; &amp;lt;path&amp;gt;&lt;/code&gt; 명령 않는 몇 가지 :</target>
        </trans-unit>
        <trans-unit id="851ad3692f8ce86e89fabf82d757953cfb293665" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git svn log&lt;/code&gt; command will not work on repositories using this, either. Using this conflicts with the &lt;code&gt;useSvmProps&lt;/code&gt; option for (hopefully) obvious reasons.</source>
          <target state="translated">&lt;code&gt;git svn log&lt;/code&gt; 명령 중 하나,이를 사용하여 저장소에서 작동하지 않습니다. 이것을 사용하는 것은 명백한 이유 때문에 &lt;code&gt;useSvmProps&lt;/code&gt; 옵션 과 충돌합니다 .</target>
        </trans-unit>
        <trans-unit id="54f2e5960f99dce6a894019f61b5f183cfaf541a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git switch&lt;/code&gt; command normally expects a branch head, but will also accept an arbitrary commit when invoked with --detach; for example, you can check out the commit referenced by a tag:</source>
          <target state="translated">&lt;code&gt;git switch&lt;/code&gt; 명령은 일반적으로 분기 머리를 기대하고, 또한 --detach 호출 할 때 임의의 커밋 받아 들일 것입니다; 예를 들어 태그가 참조하는 커밋을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5df4353714e03396f22186d308b555d9fc45aa0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git unpack-objects&lt;/code&gt; command can read the packed archive and expand the objects contained in the pack into &quot;one-file one-object&quot; format; this is typically done by the smart-pull commands when a pack is created on-the-fly for efficient network transport by their peers.</source>
          <target state="translated">&lt;code&gt;git unpack-objects&lt;/code&gt; 명령은 포장 된 압축 파일을 읽고 개체가 &quot;하나의 파일을 하나의 객체&quot;형식으로 팩에 포함 된 확장 할 수 있습니다; 이는 일반적으로 동료가 효율적인 네트워크 전송을 위해 팩을 즉석에서 만들 때 smart-pull 명령으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="472b18d3af19081ec08acbffb4a8b9828ded3de3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git write-tree&lt;/code&gt; command refuses to write a nonsensical tree, and it will complain about unmerged entries if it sees a single entry that is not stage 0.</source>
          <target state="translated">&lt;code&gt;git write-tree&lt;/code&gt; 명령은 무의미한 트리 쓰기를 거부하고 무대 0이 아닌 하나의 항목을 보는 경우가 병합되지 않은 항목에 대해 불평 할 것이다.</target>
        </trans-unit>
        <trans-unit id="57ed6fd41631cf164adf8f1a5f87022b80e95155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git-fetch&lt;/code&gt; command, with no arguments, will update all of the remote-tracking branches to the latest version found in the original repository. It will not touch any of your own branches&amp;mdash;​not even the &quot;master&quot; branch that was created for you on clone.</source>
          <target state="translated">&lt;code&gt;git-fetch&lt;/code&gt; 원래 저장소에있는 최신 버전으로 원격 추적 브랜치의 모든 업데이트됩니다, 인수없이 명령을. 클론에서 생성 한 &quot;마스터&quot;브랜치조차도 자신의 브랜치에 닿지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7a1f970e8485b643b6fd9d3ee5bf5ec87b44b17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gitlink&lt;/code&gt; entry contains the object name of the commit that the superproject expects the submodule&amp;rsquo;s working directory to be at.</source>
          <target state="translated">&lt;code&gt;gitlink&lt;/code&gt; 항목은이 superproject이 서브 모듈의 작업 디렉토리에있을 것으로 예상 것을 커밋의 객체 이름이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="59421f1cfeaef33b3d6dfff512008a45b2069f51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;help.browser&lt;/code&gt;, &lt;code&gt;web.browser&lt;/code&gt; and &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt; will also be checked if the &lt;code&gt;web&lt;/code&gt; format is chosen (either by command-line option or configuration variable). See &lt;code&gt;-w|--web&lt;/code&gt; in the OPTIONS section above and &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt;.</source>
          <target state="translated">The &lt;code&gt;help.browser&lt;/code&gt; , &lt;code&gt;web.browser&lt;/code&gt; and &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt; will also be checked if the &lt;code&gt;web&lt;/code&gt; format is chosen (either by command-line option or configuration variable). See &lt;code&gt;-w|--web&lt;/code&gt; in the OPTIONS section above and &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="20a22a2e8dd656430183eebd26fcd541802b3980" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;help.browser&lt;/code&gt;, &lt;code&gt;web.browser&lt;/code&gt; and &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt; will also be checked if the &lt;code&gt;web&lt;/code&gt; format is chosen (either by command-line option or configuration variable). See &lt;code&gt;-w|--web&lt;/code&gt; in the OPTIONS section above and git-web{litdd}browse[1].</source>
          <target state="translated">&lt;code&gt;help.browser&lt;/code&gt; , &lt;code&gt;web.browser&lt;/code&gt; 및 &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 경우 생성도 체크한다 &lt;code&gt;web&lt;/code&gt; 포맷이 선택된다 (어느 명령 행 옵션 또는 구성 변수). 참조 &lt;code&gt;-w|--web&lt;/code&gt; 와 자식 - 웹 {litdd} 찾아 [1] 위의 옵션 섹션입니다.</target>
        </trans-unit>
        <trans-unit id="d643b3df461bdc6854f7d047b7c0264699b4e1d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;includeIf&lt;/code&gt; sections allow you to include config directives from another source. These sections behave identically to each other with the exception that &lt;code&gt;includeIf&lt;/code&gt; sections may be ignored if their condition does not evaluate to true; see &quot;Conditional includes&quot; below.</source>
          <target state="translated">은 &lt;code&gt;include&lt;/code&gt; 하고 &lt;code&gt;includeIf&lt;/code&gt; 의 섹션은 다른 소스에서 설정 지시어를 포함 할 수 있습니다. 이러한 섹션 은 조건이 true로 평가되지 않으면 &lt;code&gt;includeIf&lt;/code&gt; 섹션이 무시 될 수 있다는 점을 제외하고 서로 동일하게 동작 합니다. 아래의 &quot;조건부 포함&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="25df8c5531688eabec317d8bad065a9bd5755f39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; command associates a label with the current HEAD when that command is executed. These labels are created as worktree-local refs (&lt;code&gt;refs/rewritten/&amp;lt;label&amp;gt;&lt;/code&gt;) that will be deleted when the rebase finishes. That way, rebase operations in multiple worktrees linked to the same repository do not interfere with one another. If the &lt;code&gt;label&lt;/code&gt; command fails, it is rescheduled immediately, with a helpful message how to proceed.</source>
          <target state="translated">&lt;code&gt;label&lt;/code&gt; 이 명령이 실행될 때 명령은 현재 HEAD와 레이블을 연결합니다. 이 레이블은 리베이스가 완료 될 때 삭제되는 작업 트리 로컬 참조 ( &lt;code&gt;refs/rewritten/&amp;lt;label&amp;gt;&lt;/code&gt; )로 작성 됩니다. 이렇게하면 동일한 리포지토리에 연결된 여러 작업 트리의 리베이스 작업이 서로 간섭하지 않습니다. 경우 &lt;code&gt;label&lt;/code&gt; 명령이 실패 진행 방법, 그것은 도움이 메시지와 함께 즉시 재조정된다.</target>
        </trans-unit>
        <trans-unit id="fcbbe57ad1bbeeeea536166f770fc1a1a385d28e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list&lt;/code&gt; command may produce a list of key-value pairs. The following keys are defined.</source>
          <target state="translated">The &lt;code&gt;list&lt;/code&gt; command may produce a list of key-value pairs. The following keys are defined.</target>
        </trans-unit>
        <trans-unit id="a21f07c748b4f824d325c5d844a166616c79a19e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list&lt;/code&gt; command produces a list of refs in which each ref may be followed by a list of attributes. The following ref list attributes are defined.</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; 명령 (REF)는 각 속성 목록 다음 될 수있는 심판의리스트를 생성한다. 다음과 같은 참조 목록 속성이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a1948673e2dc6e9b36baf9466260194608388c73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ls&lt;/code&gt; command can also be used where a &lt;code&gt;filemodify&lt;/code&gt; directive can appear, allowing it to be used in the middle of a commit.</source>
          <target state="translated">&lt;code&gt;ls&lt;/code&gt; 명령은 또한 어디에 사용할 수 있습니다 &lt;code&gt;filemodify&lt;/code&gt; 지시어는이 커밋의 중간에 사용할 수 있도록 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f751fdc4139000f76be8c4b7f0362d024d6ccd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maint&lt;/code&gt; branch should now be fast-forwarded to the newly released code so that maintenance fixes can be tracked for the current release:</source>
          <target state="translated">&lt;code&gt;maint&lt;/code&gt; 지점은 이제 유지 보수 수정은 현재 릴리스에 대해 추적 할 수 있도록 새로 출시 된 코드를 빠르게 전달해야합니다 :</target>
        </trans-unit>
        <trans-unit id="3d08be0d91fe4ba76005ea415ec8dd980a19baaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;man.viewer&lt;/code&gt; configuration variable will be checked if the &lt;code&gt;man&lt;/code&gt; format is chosen. The following values are currently supported:</source>
          <target state="translated">&lt;code&gt;man.viewer&lt;/code&gt; 의 경우 생성 구성 변수가 확인됩니다 &lt;code&gt;man&lt;/code&gt; 포맷이 선택됩니다. 현재 다음 값이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4d99fda454f21ad231a7b020da5a33fbc1590dfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;master&lt;/code&gt; branch is supposed to be a superset of &lt;code&gt;maint&lt;/code&gt;. If this condition does not hold, then &lt;code&gt;maint&lt;/code&gt; contains some commits that are not included on &lt;code&gt;master&lt;/code&gt;. The fixes represented by those commits will therefore not be included in your feature release.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 브랜치의 상위 집합이기로되어있다 &lt;code&gt;maint&lt;/code&gt; . 이 조건이 유지되지 않으면 &lt;code&gt;maint&lt;/code&gt; 에는 &lt;code&gt;master&lt;/code&gt; 에 포함되지 않은 커밋이 포함됩니다 . 따라서 해당 커밋으로 표시되는 수정 프로그램은 기능 릴리스에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60a9438818e32daade34327aac8510a028d0a280" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge.*.driver&lt;/code&gt; variable&amp;rsquo;s value is used to construct a command to run to merge ancestor&amp;rsquo;s version (&lt;code&gt;%O&lt;/code&gt;), current version (&lt;code&gt;%A&lt;/code&gt;) and the other branches' version (&lt;code&gt;%B&lt;/code&gt;). These three tokens are replaced with the names of temporary files that hold the contents of these versions when the command line is built. Additionally, %L will be replaced with the conflict marker size (see below).</source>
          <target state="translated">&lt;code&gt;merge.*.driver&lt;/code&gt; 변수 값이 병합 상위 버전 (에 실행할 명령 구성하는데 사용된다 &lt;code&gt;%O&lt;/code&gt; ) 현재 버전 ( &lt;code&gt;%A&lt;/code&gt; ) 다른 지점 '버전 ( &lt;code&gt;%B&lt;/code&gt; ). 이 세 개의 토큰은 명령 행이 빌드 될 때이 버전의 내용을 보유하는 임시 파일 이름으로 대체됩니다. 또한 % L은 충돌 마커 크기로 대체됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="8135860bcb3c213dc65a79f9d59c1c4cf76a9b52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge.*.name&lt;/code&gt; variable gives the driver a human-readable name.</source>
          <target state="translated">&lt;code&gt;merge.*.name&lt;/code&gt; 변수는 드라이버에 사람이 읽을 수있는 이름을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="531f58358e8d95bd1e04306b8f06edec09e06aba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge.*.recursive&lt;/code&gt; variable specifies what other merge driver to use when the merge driver is called for an internal merge between common ancestors, when there are more than one. When left unspecified, the driver itself is used for both internal merge and the final merge.</source>
          <target state="translated">&lt;code&gt;merge.*.recursive&lt;/code&gt; 하나 이상 존재하는 경우 변수의 내용을 지정 다른 병합 드라이버 병합 드라이버가 공통 조상과 내부 병합 호출 될 때 사용한다. 지정하지 않은 경우 드라이버 자체는 내부 병합 및 최종 병합에 모두 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e9e9f9df980dcf05008ee310843fafb365f76e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge&lt;/code&gt; command will merge the specified revision(s) into whatever is HEAD at that time. With &lt;code&gt;-C &amp;lt;original-commit&amp;gt;&lt;/code&gt;, the commit message of the specified merge commit will be used. When the &lt;code&gt;-C&lt;/code&gt; is changed to a lower-case &lt;code&gt;-c&lt;/code&gt;, the message will be opened in an editor after a successful merge so that the user can edit the message.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 명령은 그 시간에 HEAD 무엇이든 지정된 개정 (들)에 병합됩니다. 함께 &lt;code&gt;-C &amp;lt;original-commit&amp;gt;&lt;/code&gt; 의 병합은 특정의 메시지가 사용될 확약. &lt;code&gt;-C&lt;/code&gt; 가 소문자 &lt;code&gt;-c&lt;/code&gt; 로 변경 되면 병합이 성공한 후 편집기에서 메시지가 열리므로 사용자가 메시지를 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="103d9db55b62f87264ea4e2293c619e5e886c09f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode &amp;lt;mode&amp;gt;,&amp;lt;mode&amp;gt;..&amp;lt;mode&amp;gt;&lt;/code&gt; line appears only if at least one of the &amp;lt;mode&amp;gt; is different from the rest. Extended headers with information about detected contents movement (renames and copying detection) are designed to work with diff of two &amp;lt;tree-ish&amp;gt; and are not used by combined diff format.</source>
          <target state="translated">&lt;code&gt;mode &amp;lt;mode&amp;gt;,&amp;lt;mode&amp;gt;..&amp;lt;mode&amp;gt;&lt;/code&gt; &amp;lt;모드&amp;gt; 중 적어도 하나는 나머지 다른 경우 라인에만 나타난다. 감지 된 컨텐츠 이동 (이름 변경 및 복사 감지)에 대한 정보가있는 확장 헤더는 두 가지 &amp;lt;tree-ish&amp;gt;의 diff와 함께 작동하도록 설계되었으며 결합 된 diff 형식으로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2bdce5756dcfa3f7f3ee04d8a9aa0f072d4148cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p4-changelist&lt;/code&gt; hook is executed after the changelist message has been edited by the user. It can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes a single parameter, the name of the file that holds the proposed changelist text. Exiting with a non-zero status causes the command to abort.</source>
          <target state="translated">The &lt;code&gt;p4-changelist&lt;/code&gt; hook is executed after the changelist message has been edited by the user. It can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes a single parameter, the name of the file that holds the proposed changelist text. Exiting with a non-zero status causes the command to abort.</target>
        </trans-unit>
        <trans-unit id="faca035b6e964f3e1a2e62a14bd12a5a551dfc56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p4-post-changelist&lt;/code&gt; hook is invoked after the submit has successfully occured in P4. It takes no parameters and is meant primarily for notification and cannot affect the outcome of the git p4 submit action.</source>
          <target state="translated">The &lt;code&gt;p4-post-changelist&lt;/code&gt; hook is invoked after the submit has successfully occured in P4. It takes no parameters and is meant primarily for notification and cannot affect the outcome of the git p4 submit action.</target>
        </trans-unit>
        <trans-unit id="245bf1c27c1e24c16ea60d971116c678983044e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p4-pre-submit&lt;/code&gt; hook is executed if it exists and is executable. The hook takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevents &lt;code&gt;git-p4 submit&lt;/code&gt; from launching.</source>
          <target state="translated">&lt;code&gt;p4-pre-submit&lt;/code&gt; 이 존재하고 실행 가능한 경우 후크가 실행됩니다. 후크는 표준 입력에서 매개 변수를 사용하지 않습니다. 이 스크립트에서 0이 아닌 상태로 종료하면 &lt;code&gt;git-p4 submit&lt;/code&gt; 이 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b18899976ae8ddf5fa851e0121915b85076d95b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p4-pre-submit&lt;/code&gt; hook is executed if it exists and is executable. The hook takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevents &lt;code&gt;git-p4 submit&lt;/code&gt; from launching. It can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; command line option.</source>
          <target state="translated">The &lt;code&gt;p4-pre-submit&lt;/code&gt; hook is executed if it exists and is executable. The hook takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevents &lt;code&gt;git-p4 submit&lt;/code&gt; from launching. It can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; command line option.</target>
        </trans-unit>
        <trans-unit id="7d1a28ab3e2441205f479d6f2df8ea0d456e98e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p4-prepare-changelist&lt;/code&gt; hook is executed right after preparing the default changelist message and before the editor is started. It takes one parameter, the name of the file that contains the changelist text. Exiting with a non-zero status from the script will abort the process.</source>
          <target state="translated">The &lt;code&gt;p4-prepare-changelist&lt;/code&gt; hook is executed right after preparing the default changelist message and before the editor is started. It takes one parameter, the name of the file that contains the changelist text. Exiting with a non-zero status from the script will abort the process.</target>
        </trans-unit>
        <trans-unit id="55ac82e7ce6eab5b9d775518541be1b358e64d26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;post-update&lt;/code&gt; hook can tell what are the heads that were pushed, but it does not know what their original and updated values are, so it is a poor place to do log old..new. The &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;post-receive&lt;/em&gt;&lt;/a&gt; hook does get both original and updated values of the refs. You might consider it instead if you need them.</source>
          <target state="translated">&lt;code&gt;post-update&lt;/code&gt; 그래서 old..new 로그인 할 수있는 가난한 곳, 후크 밀렸다 머리 무엇인지 말할 수 있지만, 원래 및 업데이트 된 값이 무엇인지 알 수 없습니다. &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;후받을&lt;/em&gt;&lt;/a&gt; 후크는 심판의 모두 원본과 업데이트 된 값을 얻을 수 없습니다. 필요한 경우 대신 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b1878af31d43f94d962552d8195f8f92835c4ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pre-receive&lt;/code&gt; hook MUST NOT update any refs to point to quarantined objects. Other programs accessing the repository will not be able to see the objects (and if the pre-receive hook fails, those refs would become corrupted). For safety, any ref updates from within &lt;code&gt;pre-receive&lt;/code&gt; are automatically rejected.</source>
          <target state="translated">&lt;code&gt;pre-receive&lt;/code&gt; 후크 격리 된 개체에 포인트에 대한 심판을 업데이트 안된다. 저장소에 액세스하는 다른 프로그램은 오브젝트를 볼 수 없습니다 (사전 수신 후크가 실패하면 해당 참조가 손상됨). 안전을 위해 &lt;code&gt;pre-receive&lt;/code&gt; 내의 모든 참조 업데이트 는 자동으로 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="eb98cabc50bf16dce560817c25a1c4d64601cce6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pu&lt;/code&gt; branch will be updated even if it does not fast-forward, because it is prefixed with a plus sign; &lt;code&gt;tmp&lt;/code&gt; will not be.</source>
          <target state="translated">&lt;code&gt;pu&lt;/code&gt; 분기 그것는 더하기 기호로 시작되어 있기 때문에, 아니 빨리 감기 않는 경우에도 업데이트됩니다; &lt;code&gt;tmp&lt;/code&gt; 는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5f7235d0f9a5c833ca324eff7dc4ec19b6e7285" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pull&lt;/code&gt; command knows where to get updates from because of certain configuration variables that were set by the first &lt;code&gt;git clone&lt;/code&gt; command; see &lt;code&gt;git config -l&lt;/code&gt; and the &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; man page for details.</source>
          <target state="translated">&lt;code&gt;pull&lt;/code&gt; 명령 때문에 처음에 의해 설정된 특정 구성 변수의 업데이트를 구할 수있는 곳을 알고 &lt;code&gt;git clone&lt;/code&gt; 명령; 자세한 내용은 &lt;code&gt;git config -l&lt;/code&gt; 및 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9716ab4c9bb8eabfdb4d2f2052c2761838dfc4ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r1^!&lt;/code&gt; notation includes commit &lt;code&gt;r1&lt;/code&gt; but excludes all of its parents. By itself, this notation denotes the single commit &lt;code&gt;r1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r1^!&lt;/code&gt; 표기법에는 커밋 &lt;code&gt;r1&lt;/code&gt; 이 포함 되지만 모든 부모는 제외됩니다. 이 표기법 자체는 단일 커밋 &lt;code&gt;r1&lt;/code&gt; 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ec7b0d87246117fbc7ede1e9fb5e445953432dc9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r1^@&lt;/code&gt; notation means all parents of &lt;code&gt;r1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r1^@&lt;/code&gt; 표기는 모든 부모 의미 &lt;code&gt;r1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="906a6c33616cfaeeffbd4277ee44152fa9cd28f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;raw&lt;/code&gt; format shows the entire commit exactly as stored in the commit object. Notably, the hashes are displayed in full, regardless of whether --abbrev or --no-abbrev are used, and &lt;code&gt;parents&lt;/code&gt; information show the true parent commits, without taking grafts or history simplification into account. Note that this format affects the way commits are displayed, but not the way the diff is shown e.g. with &lt;code&gt;git log --raw&lt;/code&gt;. To get full object names in a raw diff format, use &lt;code&gt;--no-abbrev&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;raw&lt;/code&gt; 전체 정확히 같은 저장 형식 커밋 쇼 오브젝트 커밋. 특히 --abbrev 또는 --no-abbrev의 사용 여부에 관계없이 해시가 전체로 표시되며 그래프 또는 기록 단순화를 고려하지 않고 &lt;code&gt;parents&lt;/code&gt; 정보에 실제 부모 커밋이 표시됩니다. 이 형식은 커밋이 표시되는 방식에 영향을 미치지 만 &lt;code&gt;git log --raw&lt;/code&gt; 와 같이 diff가 표시되는 방식에는 영향을 미치지 않습니다 . 원시 diff 형식으로 전체 객체 이름을 얻으려면 &lt;code&gt;--no-abbrev&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e2ae08cd51826a72547a4936e1fee7033d540d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursive&lt;/code&gt; strategy can take the following options:</source>
          <target state="translated">&lt;code&gt;recursive&lt;/code&gt; 전략은 다음과 같은 옵션을 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2274cd304e0d47984767afeee4d877ca51fbdd54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refs/heads/*&lt;/code&gt; namespace will only accept commit objects, and updates only if they can be fast-forwarded.</source>
          <target state="translated">&lt;code&gt;refs/heads/*&lt;/code&gt; 가 될 수있는 경우에만 네임 스페이스 개체 만 커밋 받아 들일 것입니다 및 업데이트는 빠르게 전달.</target>
        </trans-unit>
        <trans-unit id="73d202d810478ee27aec0a92a74e6cf7efe8db45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refs/tags/*&lt;/code&gt; namespace will accept any kind of object (as commits, trees and blobs can be tagged), and any updates to them will be rejected.</source>
          <target state="translated">&lt;code&gt;refs/tags/*&lt;/code&gt; (커밋, 나무와 모양을 태그 할 수있는) 네임 스페이스는 모든 종류의 객체를 받아, 그들에 대한 업데이트가 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="8f1fa8b6ca43d585bbef39f492a9db57e9ecc9a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reset&lt;/code&gt; command can also be used to create lightweight (non-annotated) tags. For example:</source>
          <target state="translated">&lt;code&gt;reset&lt;/code&gt; 명령은 또한 경량 (비 주석) 태그를 만드는 데 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd2e909f258c6aa58fa07c5acaee67caeb1da10e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reset&lt;/code&gt; command resets the HEAD, index and worktree to the specified revision. It is similar to an &lt;code&gt;exec git reset --hard &amp;lt;label&amp;gt;&lt;/code&gt;, but refuses to overwrite untracked files. If the &lt;code&gt;reset&lt;/code&gt; command fails, it is rescheduled immediately, with a helpful message how to edit the todo list (this typically happens when a &lt;code&gt;reset&lt;/code&gt; command was inserted into the todo list manually and contains a typo).</source>
          <target state="translated">&lt;code&gt;reset&lt;/code&gt; 명령은 지정된 개정에 HEAD, 인덱스 및 worktree를 재설정합니다. 그것은과 유사 &lt;code&gt;exec git reset --hard &amp;lt;label&amp;gt;&lt;/code&gt; 하지만, 비 추적 파일을 덮어 거부합니다. 경우 &lt;code&gt;reset&lt;/code&gt; 명령이 실패, 그것은 도움이 메시지와 함께 즉시 재조정하는 방법을 편집 할 일 목록 (A 때 일반적으로 발생 &lt;code&gt;reset&lt;/code&gt; 명령을 수동으로 할 일 목록에 삽입 오타가 포함되었다).</target>
        </trans-unit>
        <trans-unit id="f2c26b231ec380ef2e111ace64d683b597b18aa2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;seen&lt;/code&gt; branch will be updated even if it does not fast-forward, because it is prefixed with a plus sign; &lt;code&gt;tmp&lt;/code&gt; will not be.</source>
          <target state="translated">The &lt;code&gt;seen&lt;/code&gt; branch will be updated even if it does not fast-forward, because it is prefixed with a plus sign; &lt;code&gt;tmp&lt;/code&gt; will not be.</target>
        </trans-unit>
        <trans-unit id="06cca2918a8a255dfff1d384369e4d4195e47f51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shortlog&lt;/code&gt; view is more compact; it shows one commit per line.</source>
          <target state="translated">&lt;code&gt;shortlog&lt;/code&gt; 의 보기는 더 컴팩트; 행당 하나의 커밋을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="49d7635e517e74681985e2d5acfe0d3faa2b57eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tagger&lt;/code&gt; command uses the same format as &lt;code&gt;committer&lt;/code&gt; within &lt;code&gt;commit&lt;/code&gt;; again see above for details.</source>
          <target state="translated">&lt;code&gt;tagger&lt;/code&gt; 명령과 같은 포맷 사용 &lt;code&gt;committer&lt;/code&gt; 내의 &lt;code&gt;commit&lt;/code&gt; ; 자세한 내용은 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c5d1574573f9cb9deb3517e06eb81c31c726f5b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;textconv&lt;/code&gt; config option is used to define a program for performing such a conversion. The program should take a single argument, the name of a file to convert, and produce the resulting text on stdout.</source>
          <target state="translated">&lt;code&gt;textconv&lt;/code&gt; 설정 옵션은 이러한 변환을 수행하기위한 프로그램을 정의하는 데 사용됩니다. 프로그램은 변환 할 파일 이름이라는 단일 인수를 가져 와서 stdout에서 결과 텍스트를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a024de933cb7ecb7f2684cd23c20dd59cced4c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tformat:&lt;/code&gt; format works exactly like &lt;code&gt;format:&lt;/code&gt;, except that it provides &quot;terminator&quot; semantics instead of &quot;separator&quot; semantics. In other words, each commit has the message terminator character (usually a newline) appended, rather than a separator placed between entries. This means that the final entry of a single-line format will be properly terminated with a new line, just as the &quot;oneline&quot; format does. For example:</source>
          <target state="translated">&lt;code&gt;tformat:&lt;/code&gt; 형식은 정확히 같은 작품 &lt;code&gt;format:&lt;/code&gt; , 대신 &quot;분리&quot;의미의 &quot;터미네이터&quot;의미를 제공하는 것을 제외하고. 즉, 각 커밋에는 항목 사이에 구분 기호가 아닌 메시지 종료 문자 (보통 줄 바꿈)가 추가됩니다. 즉, &quot;한 줄&quot;형식과 마찬가지로 한 줄 형식의 최종 항목이 새 줄로 올바르게 종료됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df62988b77ac61a631e6a3bd598e4269b439619e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; variables determine what ends up in the &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;committer&lt;/code&gt; field of commit objects. If you need the &lt;code&gt;author&lt;/code&gt; or &lt;code&gt;committer&lt;/code&gt; to be different, the &lt;code&gt;author.name&lt;/code&gt;, &lt;code&gt;author.email&lt;/code&gt;, &lt;code&gt;committer.name&lt;/code&gt; or &lt;code&gt;committer.email&lt;/code&gt; variables can be set. Also, all of these can be overridden by the &lt;code&gt;GIT_AUTHOR_NAME&lt;/code&gt;, &lt;code&gt;GIT_AUTHOR_EMAIL&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_NAME&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_EMAIL&lt;/code&gt; and &lt;code&gt;EMAIL&lt;/code&gt; environment variables.</source>
          <target state="translated">The &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; variables determine what ends up in the &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;committer&lt;/code&gt; field of commit objects. If you need the &lt;code&gt;author&lt;/code&gt; or &lt;code&gt;committer&lt;/code&gt; to be different, the &lt;code&gt;author.name&lt;/code&gt; , &lt;code&gt;author.email&lt;/code&gt; , &lt;code&gt;committer.name&lt;/code&gt; or &lt;code&gt;committer.email&lt;/code&gt; variables can be set. Also, all of these can be overridden by the &lt;code&gt;GIT_AUTHOR_NAME&lt;/code&gt; , &lt;code&gt;GIT_AUTHOR_EMAIL&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_NAME&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_EMAIL&lt;/code&gt; and &lt;code&gt;EMAIL&lt;/code&gt; environment variables.</target>
        </trans-unit>
        <trans-unit id="52696bbc1bd35a1c1c6d78b6535a11990db3bb34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; variables determine what ends up in the &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;committer&lt;/code&gt; field of commit objects. If you need the &lt;code&gt;author&lt;/code&gt; or &lt;code&gt;committer&lt;/code&gt; to be different, the &lt;code&gt;author.name&lt;/code&gt;, &lt;code&gt;author.email&lt;/code&gt;, &lt;code&gt;committer.name&lt;/code&gt; or &lt;code&gt;committer.email&lt;/code&gt; variables can be set. Also, all of these can be overridden by the &lt;code&gt;GIT_AUTHOR_NAME&lt;/code&gt;, &lt;code&gt;GIT_AUTHOR_EMAIL&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_NAME&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_EMAIL&lt;/code&gt; and &lt;code&gt;EMAIL&lt;/code&gt; environment variables. See &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;user.name&lt;/code&gt; 및 &lt;code&gt;user.email&lt;/code&gt; 변수는에 끝을 결정 &lt;code&gt;author&lt;/code&gt; 및 &lt;code&gt;committer&lt;/code&gt; 객체를 커밋의 필드. 당신이 필요한 경우 &lt;code&gt;author&lt;/code&gt; 또는 &lt;code&gt;committer&lt;/code&gt; 다른 것으로는 &lt;code&gt;author.name&lt;/code&gt; , &lt;code&gt;author.email&lt;/code&gt; , &lt;code&gt;committer.name&lt;/code&gt; 또는 &lt;code&gt;committer.email&lt;/code&gt; 변수를 설정할 수 있습니다. 또한 이들 모두는 &lt;code&gt;GIT_AUTHOR_NAME&lt;/code&gt; , &lt;code&gt;GIT_AUTHOR_EMAIL&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_NAME&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_EMAIL&lt;/code&gt; 및 &lt;code&gt;EMAIL&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . &lt;a href=&quot;git-commit-tree&quot;&gt;자식 커밋 트리&lt;/a&gt; 참조 [1] 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="e856d2a5737e8a442522cf9dc045cf46da5c837d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;worktree list&lt;/code&gt; command has two output formats. The default format shows the details on a single line with columns. For example:</source>
          <target state="translated">The &lt;code&gt;worktree list&lt;/code&gt; command has two output formats. The default format shows the details on a single line with columns. For example:</target>
        </trans-unit>
        <trans-unit id="16ffcc56d5f44fe2ccdfd792b9ad74a964b837f9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&amp;hellip;​&lt;/em&gt; (three-dot) Symmetric Difference Notation</source>
          <target state="translated">&lt;em&gt;...&lt;/em&gt; (세 점) 대칭 차이 표기</target>
        </trans-unit>
        <trans-unit id="3ca01d997f3f16d56fc54554bfe9b469c32c5dff" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;..&lt;/em&gt; (two-dot) Range Notation</source>
          <target state="translated">&lt;em&gt;..&lt;/em&gt; (두 점) 범위 표기법</target>
        </trans-unit>
        <trans-unit id="28292c9406d9116658f021a9e7e686e22523649d" translate="yes" xml:space="preserve">
          <source>The C rewrite is first included with Git version 2.22 (and Git for Windows version 2.19). This option serves as an escape hatch to re-enable the legacy version in case any bugs are found in the rewrite. This option and the shell script version of &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; will be removed in some future release.</source>
          <target state="translated">C 다시 쓰기는 Git 버전 2.22 (및 Git for Windows 버전 2.19)에 처음 포함됩니다. 이 옵션은 다시 쓰기에서 버그가 발견 될 경우 레거시 버전을 다시 활성화하는 이스케이프 해치 역할을합니다. 이 옵션과 &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; 의 쉘 스크립트 버전은 향후 릴리스에서 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="dbe462d7e2f126482bf0dec3d004def2c9c89bb6" translate="yes" xml:space="preserve">
          <source>The CVS module you want to import. Relative to &amp;lt;CVSROOT&amp;gt;. If not given, &lt;code&gt;git cvsimport&lt;/code&gt; tries to read it from &lt;code&gt;CVS/Repository&lt;/code&gt;.</source>
          <target state="translated">가져올 CVS 모듈 &amp;lt;CVSROOT&amp;gt;와 관련이 있습니다. 지정하지 않으면 &lt;code&gt;git cvsimport&lt;/code&gt; 는 &lt;code&gt;CVS/Repository&lt;/code&gt; 에서 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="d9fdb00c7bf3f2937ed399ea5a7eb5783533387f" translate="yes" xml:space="preserve">
          <source>The Event Format Target</source>
          <target state="translated">이벤트 형식 대상</target>
        </trans-unit>
        <trans-unit id="91f31eeacecff37ec38db2aff37269235d7422bb" translate="yes" xml:space="preserve">
          <source>The GIT_TRACE_&amp;lt;key&amp;gt; mechanism allows each &amp;lt;key&amp;gt; to write to a different file (in addition to just stderr).</source>
          <target state="translated">GIT_TRACE_ &amp;lt;key&amp;gt; 메커니즘을 사용하면 각 &amp;lt;key&amp;gt;가 다른 파일에 쓸 수 있습니다 (stderr뿐 아니라).</target>
        </trans-unit>
        <trans-unit id="eb9c24f633d0777727caf33c8ede260c0246d232" translate="yes" xml:space="preserve">
          <source>The GPG key ID of the key that signed the push certificate.</source>
          <target state="translated">푸시 인증서에 서명 한 키의 GPG 키 ID입니다.</target>
        </trans-unit>
        <trans-unit id="7fd047e9e0dcddc0ec24d2bfa4a8d0b4477b60c4" translate="yes" xml:space="preserve">
          <source>The Git Repository</source>
          <target state="translated">힘내 리포지토리</target>
        </trans-unit>
        <trans-unit id="ec69c4a3fd32f0743df23ab218ec13475fdae8cc" translate="yes" xml:space="preserve">
          <source>The Git configuration file contains a number of variables that affect the Git commands' behavior. The files &lt;code&gt;.git/config&lt;/code&gt; and optionally &lt;code&gt;config.worktree&lt;/code&gt; (see &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; below) in each repository are used to store the configuration for that repository, and &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; is used to store a per-user configuration as fallback values for the &lt;code&gt;.git/config&lt;/code&gt; file. The file &lt;code&gt;/etc/gitconfig&lt;/code&gt; can be used to store a system-wide default configuration.</source>
          <target state="translated">Git 구성 파일에는 Git 명령의 동작에 영향을주는 여러 변수가 포함되어 있습니다. 각 저장소의 &lt;code&gt;.git/config&lt;/code&gt; 및 선택적으로 &lt;code&gt;config.worktree&lt;/code&gt; 파일 (아래 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 참조)은 해당 저장소의 구성을 저장하는 데 사용되고 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 는 사용자 별 구성을 대체 값으로 저장하는 데 사용됩니다. &lt;code&gt;.git/config&lt;/code&gt; 파일. &lt;code&gt;/etc/gitconfig&lt;/code&gt; 파일 을 사용하여 시스템 전체 기본 구성을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57dbf68c8f67f403d793ac43faa2e8d1a6fb8f3b" translate="yes" xml:space="preserve">
          <source>The Git configuration file contains a number of variables that affect the Git commands' behavior. The files &lt;code&gt;.git/config&lt;/code&gt; and optionally &lt;code&gt;config.worktree&lt;/code&gt; (see the &quot;CONFIGURATION FILE&quot; section of &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt;) in each repository are used to store the configuration for that repository, and &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; is used to store a per-user configuration as fallback values for the &lt;code&gt;.git/config&lt;/code&gt; file. The file &lt;code&gt;/etc/gitconfig&lt;/code&gt; can be used to store a system-wide default configuration.</source>
          <target state="translated">The Git configuration file contains a number of variables that affect the Git commands' behavior. The files &lt;code&gt;.git/config&lt;/code&gt; and optionally &lt;code&gt;config.worktree&lt;/code&gt; (see the &quot;CONFIGURATION FILE&quot; section of &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt;) in each repository are used to store the configuration for that repository, and &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; is used to store a per-user configuration as fallback values for the &lt;code&gt;.git/config&lt;/code&gt; file. The file &lt;code&gt;/etc/gitconfig&lt;/code&gt; can be used to store a system-wide default configuration.</target>
        </trans-unit>
        <trans-unit id="c4676de1f2b8af7673ad60d0d802fc7e29d8da30" translate="yes" xml:space="preserve">
          <source>The Git object directory contains a &lt;code&gt;pack&lt;/code&gt; directory containing packfiles (with suffix &quot;.pack&quot;) and pack-indexes (with suffix &quot;.idx&quot;). The pack-indexes provide a way to lookup objects and navigate to their offset within the pack, but these must come in pairs with the packfiles. This pairing depends on the file names, as the pack-index differs only in suffix with its pack- file. While the pack-indexes provide fast lookup per packfile, this performance degrades as the number of packfiles increases, because abbreviations need to inspect every packfile and we are more likely to have a miss on our most-recently-used packfile. For some large repositories, repacking into a single packfile is not feasible due to storage space or excessive repack times.</source>
          <target state="translated">Git 객체 디렉토리에는 packfiles (접미사 &quot;.pack&quot;)와 pack-indexes (접미사 &quot;.idx&quot;) 가 들어있는 &lt;code&gt;pack&lt;/code&gt; 디렉토리가 있습니다. 팩 인덱스는 팩 내에서 객체를 조회하고 오프셋을 탐색하는 방법을 제공하지만 팩 파일과 쌍을 이루어야합니다. pack-index는 pack- 파일의 접미사 만 다르기 때문에이 쌍은 파일 이름에 따라 다릅니다. 팩 인덱스는 팩 파일 당 빠른 조회를 제공하지만 약어는 모든 팩 파일을 검사해야하고 가장 최근에 사용 된 팩 파일을 놓칠 가능성이 높기 때문에 팩 파일 수가 증가함에 따라 성능이 저하됩니다. 일부 큰 리포지토리의 경우 저장 공간이나 과도한 재 포장 시간으로 인해 단일 팩 파일로 재 포장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a2329c4ac9f08d776040ac221ffa562b7323c3f6" translate="yes" xml:space="preserve">
          <source>The Git protocol gives better performance and reliability, but on a host with a web server set up, HTTP exports may be simpler to set up.</source>
          <target state="translated">Git 프로토콜은 더 나은 성능과 안정성을 제공하지만 웹 서버가 설정된 호스트에서는 HTTP 내보내기를 설정하는 것이 더 간단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1179b23d825b14c0a26acd1779bd21e4b7a2880e" translate="yes" xml:space="preserve">
          <source>The Git remote to import this CVS repository into. Moves all CVS branches into remotes/&amp;lt;remote&amp;gt;/&amp;lt;branch&amp;gt; akin to the way &lt;code&gt;git clone&lt;/code&gt; uses &lt;code&gt;origin&lt;/code&gt; by default.</source>
          <target state="translated">이 CVS 저장소를 가져올 Git 원격. &lt;code&gt;git clone&lt;/code&gt; 이 기본적으로 &lt;code&gt;origin&lt;/code&gt; 을 사용 하는 방식과 유사하게 모든 CVS 분기를 remotes / &amp;lt;remote&amp;gt; / &amp;lt;branch&amp;gt;로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="bd47eb27f30e04cbdc75cd21789edadd8836d3bb" translate="yes" xml:space="preserve">
          <source>The Git repository browser</source>
          <target state="translated">Git 리포지토리 브라우저</target>
        </trans-unit>
        <trans-unit id="076055123196294023f50dc3852a8243be06956f" translate="yes" xml:space="preserve">
          <source>The Git repository browser. Shows branches, commit history and file differences. gitk is the utility started by &lt;code&gt;git gui&lt;/code&gt;'s Repository Visualize actions.</source>
          <target state="translated">Git 리포지토리 브라우저. 브랜치, 커밋 히스토리 및 파일 차이를 보여줍니다. gitk는 &lt;code&gt;git gui&lt;/code&gt; 의 Repository Visualize 액션에 의해 시작된 유틸리티 입니다.</target>
        </trans-unit>
        <trans-unit id="703dfd23887a83d4329e915dd0bcbd7608c6b6a7" translate="yes" xml:space="preserve">
          <source>The Git repository to import to. If the directory doesn&amp;rsquo;t exist, it will be created. Default is the current directory.</source>
          <target state="translated">가져올 Git 저장소. 디렉토리가 존재하지 않으면 작성됩니다. 기본값은 현재 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="6970e04ce98d2b4a3b2c6e8de2880e4a745e2c4f" translate="yes" xml:space="preserve">
          <source>The HEAD then refers to the SHA-1 of the commit instead of to a branch, and git branch shows that you are no longer on a branch:</source>
          <target state="translated">그러면 HEAD는 브랜치 대신 커밋의 SHA-1을 참조하고 git 브랜치는 더 이상 브랜치에 있지 않음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="895d60d2bce01273de11df4a950c78fe3184bcf0" translate="yes" xml:space="preserve">
          <source>The HTTP USER_AGENT string presented to an HTTP server. The default value represents the version of the client Git such as git/1.7.1. This option allows you to override this value to a more common value such as Mozilla/4.0. This may be necessary, for instance, if connecting through a firewall that restricts HTTP connections to a set of common USER_AGENT strings (but not including those like git/1.7.1). Can be overridden by the &lt;code&gt;GIT_HTTP_USER_AGENT&lt;/code&gt; environment variable.</source>
          <target state="translated">HTTP USER_AGENT 문자열이 HTTP 서버에 제공되었습니다. 기본값은 git / 1.7.1과 같은 클라이언트 Git의 버전을 나타냅니다. 이 옵션을 사용하면이 값을 Mozilla / 4.0과 같은보다 일반적인 값으로 대체 할 수 있습니다. 예를 들어, HTTP 연결을 공통 USER_AGENT 문자열 세트로 제한하는 방화벽을 통해 연결하는 경우 (git / 1.7.1과 같은 문자열은 제외) 필요할 수 있습니다. &lt;code&gt;GIT_HTTP_USER_AGENT&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00aa9820c66c0255936f6c8707aec2ad36a5c140" translate="yes" xml:space="preserve">
          <source>The HTTP daemon command-line that will be executed. Command-line options may be specified here, and the configuration file will be added at the end of the command-line. Currently apache2, lighttpd, mongoose, plackup, python and webrick are supported. (Default: lighttpd)</source>
          <target state="translated">실행될 HTTP 데몬 명령 줄. 여기서 명령 줄 옵션을 지정할 수 있으며 구성 파일은 명령 줄 끝에 추가됩니다. 현재 apache2, lighttpd, mongoose, plackup, python 및 webrick이 지원됩니다. (기본값 : lighttpd)</target>
        </trans-unit>
        <trans-unit id="adee6c32cf5372a9cc214e1cabc3f604f4a421cf" translate="yes" xml:space="preserve">
          <source>The HTTP daemon command-line to start gitweb on your working repository. See &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;.</source>
          <target state="translated">작업 저장소에서 gitweb을 시작하기위한 HTTP 데몬 명령 줄. &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a20118bebd861685578a19065b0fb24ab670ec89" translate="yes" xml:space="preserve">
          <source>The MIDX file format uses a chunk-based approach (similar to the commit-graph file) that allows optional data to be added.</source>
          <target state="translated">MIDX 파일 형식은 선택적인 데이터를 추가 할 수있는 청크 기반 접근 방식 (커밋 그래프 파일과 유사)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="64e372cd9f501c41226d338629f4adfe7884c507" translate="yes" xml:space="preserve">
          <source>The MIDX is stored in a file named &lt;code&gt;multi-pack-index&lt;/code&gt; in the .git/objects/pack directory. This could be stored in the pack directory of an alternate. It refers only to packfiles in that same directory.</source>
          <target state="translated">MIDX는 .git / objects / pack 디렉토리의 &lt;code&gt;multi-pack-index&lt;/code&gt; 라는 파일에 저장됩니다 . 이것은 대체의 pack 디렉토리에 저장 될 수 있습니다. 동일한 디렉토리에있는 팩 파일 만 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="be240040a2b303919e9f8b3f8c55bd2d4b871823" translate="yes" xml:space="preserve">
          <source>The MIDX keeps only one record per object ID. If an object appears in multiple packfiles, then the MIDX selects the copy in the most- recently modified packfile.</source>
          <target state="translated">MIDX는 객체 ID 당 하나의 레코드 만 유지합니다. 객체가 여러 팩 파일에 나타나는 경우 MIDX는 가장 최근에 수정 된 팩 파일에서 사본을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="d248ab48f510e2fbd4b16391dc71868ce2bb9eb7" translate="yes" xml:space="preserve">
          <source>The MUA corrupted your patch; &quot;am&quot; would complain that the patch does not apply. Look in the .git/rebase-apply/ subdirectory and see what &lt;code&gt;patch&lt;/code&gt; file contains and check for the common corruption patterns mentioned above.</source>
          <target state="translated">MUA가 패치를 손상 시켰습니다. &quot;am&quot;은 패치가 적용되지 않는다고 불평합니다. .git / rebase-apply / 서브 디렉토리에서 &lt;code&gt;patch&lt;/code&gt; 파일에 어떤 패치 파일이 포함되어 있는지 확인하고 위에서 언급 한 일반적인 손상 패턴을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="dcfedffa2e791a211c838c6711816e41fded8f05" translate="yes" xml:space="preserve">
          <source>The Normal Format Target</source>
          <target state="translated">일반 형식 대상</target>
        </trans-unit>
        <trans-unit id="500d32200a061b0c3eb8acb59a37b1ba3087273e" translate="yes" xml:space="preserve">
          <source>The Object Database</source>
          <target state="translated">객체 데이터베이스</target>
        </trans-unit>
        <trans-unit id="b3b387e6e23160b9001074a3b231e88c333277a0" translate="yes" xml:space="preserve">
          <source>The PERF target is intended for interactive performance analysis during development and is quite noisy.</source>
          <target state="translated">PERF 목표는 개발 중 대화 형 성능 분석을위한 것이며 시끄러운 소리입니다.</target>
        </trans-unit>
        <trans-unit id="716ba6c2a540215443944eab8349af10087e97bb" translate="yes" xml:space="preserve">
          <source>The Performance Format Target</source>
          <target state="translated">성능 형식 목표</target>
        </trans-unit>
        <trans-unit id="ca04878afc5a61720c26b830b963e827e884a4f1" translate="yes" xml:space="preserve">
          <source>The SSL version to use when negotiating an SSL connection, if you want to force the default. The available and default version depend on whether libcurl was built against NSS or OpenSSL and the particular configuration of the crypto library in use. Internally this sets the &lt;code&gt;CURLOPT_SSL_VERSION&lt;/code&gt; option; see the libcurl documentation for more details on the format of this option and for the ssl version supported. Actually the possible values of this option are:</source>
          <target state="translated">기본값을 강제로 적용하려는 경우 SSL 연결을 협상 할 때 사용할 SSL 버전입니다. 사용 가능한 기본 버전은 libcurl이 NSS 또는 OpenSSL을 기반으로 구축되었는지 여부와 사용중인 암호화 라이브러리의 특정 구성에 따라 다릅니다. 내부적으로 &lt;code&gt;CURLOPT_SSL_VERSION&lt;/code&gt; 옵션 이 설정됩니다 . 이 옵션의 형식과 지원되는 SSL 버전에 대한 자세한 내용은 libcurl 설명서를 참조하십시오. 실제로이 옵션의 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="018a79839a5b69e87551f5d2d8901721b830b6f5" translate="yes" xml:space="preserve">
          <source>The SSL version to use when negotiating an SSL connection, if you want to force the default. The available and default version depend on whether libcurl was built against NSS or OpenSSL and the particular configuration of the crypto library in use. Internally this sets the &lt;code&gt;CURLOPT_SSL_VERSION&lt;/code&gt; option; see the libcurl documentation for more details on the format of this option and for the ssl version supported. Currently the possible values of this option are:</source>
          <target state="translated">The SSL version to use when negotiating an SSL connection, if you want to force the default. The available and default version depend on whether libcurl was built against NSS or OpenSSL and the particular configuration of the crypto library in use. Internally this sets the &lt;code&gt;CURLOPT_SSL_VERSION&lt;/code&gt; option; see the libcurl documentation for more details on the format of this option and for the ssl version supported. Currently the possible values of this option are:</target>
        </trans-unit>
        <trans-unit id="6c8d77384dcf5927fceefc0c82e6aa35599c0a0b" translate="yes" xml:space="preserve">
          <source>The Trace2 API can be used to print debug, performance, and telemetry information to stderr or a file. The Trace2 feature is inactive unless explicitly enabled by enabling one or more Trace2 Targets.</source>
          <target state="translated">Trace2 API를 사용하여 디버그, 성능 및 원격 분석 정보를 stderr 또는 파일로 인쇄 할 수 있습니다. 하나 이상의 Trace2 대상을 활성화하여 명시 적으로 활성화하지 않으면 Trace2 기능이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="6bdbd91221731e97e635f28174406bd894d81047" translate="yes" xml:space="preserve">
          <source>The Trace2 API defines a set of high-level messages with known fields, such as (&lt;code&gt;start&lt;/code&gt;: &lt;code&gt;argv&lt;/code&gt;) and (&lt;code&gt;exit&lt;/code&gt;: {&lt;code&gt;exit-code&lt;/code&gt;, &lt;code&gt;elapsed-time&lt;/code&gt;}).</source>
          <target state="translated">Trace2 API는 ( &lt;code&gt;start&lt;/code&gt; : &lt;code&gt;argv&lt;/code&gt; ) 및 ( &lt;code&gt;exit&lt;/code&gt; : { &lt;code&gt;exit-code&lt;/code&gt; , &lt;code&gt;elapsed-time&lt;/code&gt; }) 과 같이 알려진 필드가있는 상위 레벨 메시지 세트를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="c8d932fd39b46f7d652bfdd2be6511ab09fc4671" translate="yes" xml:space="preserve">
          <source>The Trace2 API is intended to replace the existing (Trace1) printf-style tracing provided by the existing &lt;code&gt;GIT_TRACE&lt;/code&gt; and &lt;code&gt;GIT_TRACE_PERFORMANCE&lt;/code&gt; facilities. During initial implementation, Trace2 and Trace1 may operate in parallel.</source>
          <target state="translated">Trace2 API는 기존 &lt;code&gt;GIT_TRACE&lt;/code&gt; 및 &lt;code&gt;GIT_TRACE_PERFORMANCE&lt;/code&gt; 기능이 제공하는 기존 (Trace1) printf 스타일 추적을 대체하기위한 것 입니다. 초기 구현 중에 Trace2와 Trace1이 병렬로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5397d7e9698d7ad87ff097450bf8a8e1a772416" translate="yes" xml:space="preserve">
          <source>The Trace2 code also defines a set of private functions and data types in the &lt;code&gt;trace2/&lt;/code&gt; directory. These symbols are prefixed with &lt;code&gt;tr2_&lt;/code&gt; and should only be used by functions in &lt;code&gt;trace2.c&lt;/code&gt;.</source>
          <target state="translated">Trace2 코드는 &lt;code&gt;trace2/&lt;/code&gt; 디렉토리 에 개인 함수 및 데이터 유형 세트도 정의합니다 . 이 기호는 접두사가 &lt;code&gt;tr2_&lt;/code&gt; 이고 &lt;code&gt;trace2.c&lt;/code&gt; 의 함수 만 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8e231fe7d9a0eb53151c1a418399ded2fd9db9e8" translate="yes" xml:space="preserve">
          <source>The URL for a submodule. This variable is copied from the .gitmodules file to the git config via &lt;code&gt;git submodule init&lt;/code&gt;. The user can change the configured URL before obtaining the submodule via &lt;code&gt;git submodule update&lt;/code&gt;. If neither submodule.&amp;lt;name&amp;gt;.active or submodule.active are set, the presence of this variable is used as a fallback to indicate whether the submodule is of interest to git commands. See &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">하위 모듈의 URL입니다. 이 변수는 &lt;code&gt;git submodule init&lt;/code&gt; 를 통해 .gitmodules 파일에서 git config로 복사됩니다 . 사용자는 &lt;code&gt;git submodule update&lt;/code&gt; 를 통해 서브 모듈을 얻기 전에 구성된 URL을 변경할 수 있습니다 . submodule. &amp;lt;name&amp;gt; .active 또는 submodule.active가 설정되지 않은 경우이 변수의 존재는 하위 모듈이 git 명령에 관심이 있는지 여부를 나타내는 대체로 사용됩니다. 자세한 내용은 &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; 및 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="307f8458b88cd1196dc3047eb250fdb8e3348b46" translate="yes" xml:space="preserve">
          <source>The URL of a remote repository. See &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; or &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">원격 저장소의 URL입니다. 참조 &lt;a href=&quot;git-fetch&quot;&gt;[1] 자식 페치&lt;/a&gt; 또는 &lt;a href=&quot;git-push&quot;&gt;자식 푸시 [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92c06c873fe7803ddcdb456ba837dbd24d10b389" translate="yes" xml:space="preserve">
          <source>The URL to the remote repository.</source>
          <target state="translated">원격 저장소의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="846d99295948de526a5621f0a520c5a9a78af747" translate="yes" xml:space="preserve">
          <source>The Workflow</source>
          <target state="translated">워크 플로우</target>
        </trans-unit>
        <trans-unit id="91d8165377483e9123ecf4a3d5455b3b1999d185" translate="yes" xml:space="preserve">
          <source>The above can also be written as simply</source>
          <target state="translated">위의 내용은 간단하게 작성할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="13c712cb6756cc53fb3407886d0503d18cb537c0" translate="yes" xml:space="preserve">
          <source>The above command copies all branches from the remote refs/heads/ namespace and stores them to the local refs/remotes/origin/ namespace, unless the branch.&amp;lt;name&amp;gt;.fetch option is used to specify a non-default refspec.</source>
          <target state="translated">위의 명령은 기본 refspec을 지정하는 데 branch. &amp;lt;name&amp;gt; .fetch 옵션을 사용하지 않는 한 원격 refs / heads / 네임 스페이스에서 모든 브랜치를 복사하여 로컬 refs / remotes / origin / 네임 스페이스에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="61e1efd32cbb415eea7b734b98558317a6d1aac3" translate="yes" xml:space="preserve">
          <source>The above command would change the origin repository to</source>
          <target state="translated">위의 명령은 원본 저장소를</target>
        </trans-unit>
        <trans-unit id="cc504649b9359e7717badcdf0f10e04d6127c3a0" translate="yes" xml:space="preserve">
          <source>The above configuration expects your public repositories to live under &lt;code&gt;/pub/git&lt;/code&gt; and will serve them as &lt;code&gt;http://git.domain.org/dir-under-pub-git&lt;/code&gt;, both as clonable Git URL and as browseable gitweb interface. If you then start your &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; with &lt;code&gt;--base-path=/pub/git --export-all&lt;/code&gt; then you can even use the &lt;code&gt;git://&lt;/code&gt; URL with exactly the same path.</source>
          <target state="translated">위의 구성은 퍼블릭 리포지토리가 &lt;code&gt;/pub/git&lt;/code&gt; 아래에 있어야 하며 복제 가능한 Git URL과 탐색 가능한 gitweb 인터페이스 로 &lt;code&gt;http://git.domain.org/dir-under-pub-git&lt;/code&gt; 으로 제공됩니다. 그런 다음 시작하면 &lt;a href=&quot;git-daemon&quot;&gt;자식 - 데몬 [1]&lt;/a&gt; 로 &lt;code&gt;--base-path=/pub/git --export-all&lt;/code&gt; 당신도 사용할 수있는 &lt;code&gt;git://&lt;/code&gt; URL 정확히 같은 경로.</target>
        </trans-unit>
        <trans-unit id="baa5f35656f9b3f3ba646932132fa97233a197b9" translate="yes" xml:space="preserve">
          <source>The above is all you need to know to resolve a simple merge. But Git also provides more information to help resolve conflicts:</source>
          <target state="translated">위의 간단한 병합을 해결하기 위해 알아야 할 모든 것입니다. 그러나 Git은 충돌 해결에 도움이되는 추가 정보도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="70fce3bc08ea4ed40bcc99c52f88c26bd24f0b87" translate="yes" xml:space="preserve">
          <source>The above is the description of a Git merge at the lowest level, to help you understand what conceptually happens under the hood. In practice, nobody, not even Git itself, runs &lt;code&gt;git cat-file&lt;/code&gt; three times for this. There is a &lt;code&gt;git merge-index&lt;/code&gt; program that extracts the stages to temporary files and calls a &quot;merge&quot; script on it:</source>
          <target state="translated">위는 가장 낮은 수준에서 Git 병합에 대한 설명으로, 후드에서 개념적으로 발생하는 것을 이해하는 데 도움이됩니다. 실제로 Git 자체조차도 아무도 &lt;code&gt;git cat-file&lt;/code&gt; 을 세 번 실행하지 않습니다 . 임시 파일로 스테이지를 추출하고 그 위에 &quot;병합&quot;스크립트를 호출 하는 &lt;code&gt;git merge-index&lt;/code&gt; 프로그램이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb77c0d462477bf4637c28037a03befbbf605c33" translate="yes" xml:space="preserve">
          <source>The absolute path to the worktree in which the ref is checked out, if it is checked out in any linked worktree. Empty string otherwise.</source>
          <target state="translated">링크 된 워크 트리에서 체크 아웃 된 경우 참조가 체크 아웃 된 워크 트리의 절대 경로입니다. 그렇지 않으면 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="76cd9fb4bfcc53cf44ccfea4ed1923acc958405e" translate="yes" xml:space="preserve">
          <source>The accepted attributes are &lt;code&gt;bold&lt;/code&gt;, &lt;code&gt;dim&lt;/code&gt;, &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;blink&lt;/code&gt;, &lt;code&gt;reverse&lt;/code&gt;, &lt;code&gt;italic&lt;/code&gt;, and &lt;code&gt;strike&lt;/code&gt; (for crossed-out or &quot;strikethrough&quot; letters). The position of any attributes with respect to the colors (before, after, or in between), doesn&amp;rsquo;t matter. Specific attributes may be turned off by prefixing them with &lt;code&gt;no&lt;/code&gt; or &lt;code&gt;no-&lt;/code&gt; (e.g., &lt;code&gt;noreverse&lt;/code&gt;, &lt;code&gt;no-ul&lt;/code&gt;, etc).</source>
          <target state="translated">허용되는 속성은 &lt;code&gt;bold&lt;/code&gt; , &lt;code&gt;dim&lt;/code&gt; , &lt;code&gt;ul&lt;/code&gt; , &lt;code&gt;blink&lt;/code&gt; , &lt;code&gt;reverse&lt;/code&gt; , &lt;code&gt;italic&lt;/code&gt; 및 &lt;code&gt;strike&lt;/code&gt; (교차 문자 또는 &quot; 파업 문자&quot;)입니다. 색상 (전, 후 또는 사이)과 관련된 속성의 위치는 중요하지 않습니다. 접두사로 &lt;code&gt;no&lt;/code&gt; 또는 &lt;code&gt;no-&lt;/code&gt; 를 붙임으로써 특정 속성을 끌 수 있습니다 (예 : &lt;code&gt;noreverse&lt;/code&gt; , &lt;code&gt;no-ul&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="0bb8a69a5cde6b982a60a95e4956ebdf1a59fa5f" translate="yes" xml:space="preserve">
          <source>The accepted patterns in the cone pattern set are:</source>
          <target state="translated">원뿔 패턴 세트에서 허용되는 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec26e1bb6d1ddd903fea6ea4b1aec39f9a4bdff7" translate="yes" xml:space="preserve">
          <source>The action of fixing up manually what a failed automatic &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; left behind.</source>
          <target state="translated">실패한 자동 &lt;a href=&quot;#def_merge&quot;&gt;병합이&lt;/a&gt; 남은 것을 수동으로 수정하는 작업 .</target>
        </trans-unit>
        <trans-unit id="91929f919cdca3ddad9711d4446a1108e24ab05c" translate="yes" xml:space="preserve">
          <source>The action of updating all or part of the &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; with a &lt;a href=&quot;#def_tree_object&quot;&gt;tree object&lt;/a&gt; or &lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt; from the &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt;, and updating the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; and &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; if the whole working tree has been pointed at a new &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_working_tree&quot;&gt;작업 트리&lt;/a&gt; 의 전체 또는 일부가 새 &lt;a href=&quot;#def_branch&quot;&gt;분기를&lt;/a&gt; 가리키면 작업 트리의 전체 또는 일부를 &lt;a href=&quot;#def_object_database&quot;&gt;개체 데이터베이스&lt;/a&gt; 의 &lt;a href=&quot;#def_tree_object&quot;&gt;트리 개체&lt;/a&gt; 또는 &lt;a href=&quot;#def_blob_object&quot;&gt;얼룩&lt;/a&gt; 으로 업데이트하고 &lt;a href=&quot;#def_index&quot;&gt;인덱스&lt;/a&gt; 와 &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD를&lt;/a&gt; 업데이트하는 작업입니다 .</target>
        </trans-unit>
        <trans-unit id="bf91c6dac7e4978798d8310657f124dd799f4bf4" translate="yes" xml:space="preserve">
          <source>The action that will be run. Defaults to &lt;code&gt;projects_list&lt;/code&gt; if repo is not set, and to &lt;code&gt;summary&lt;/code&gt; otherwise.</source>
          <target state="translated">실행될 조치입니다. repo가 ​​설정되지 않은 경우 기본값은 &lt;code&gt;projects_list&lt;/code&gt; 이고 그렇지 않으면 &lt;code&gt;summary&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e262b52287502541a33fa85d5cf2fdae897da448" translate="yes" xml:space="preserve">
          <source>The active branch LRU, when coupled with the filename string pool and lazy loading of subtrees, allows fast-import to efficiently import projects with 2,000+ branches and 45,114+ files in a very limited memory footprint (less than 2.7 MiB per active branch).</source>
          <target state="translated">활성 브랜치 LRU는 파일 이름 문자열 풀 및 하위 트리의 느린로드와 결합 될 때 매우 제한된 메모리 풋 프린트 (활성 브랜치 당 2.7 MiB 미만)로 2,000 개 이상의 브랜치 및 45,114+ 개의 파일이있는 프로젝트를 빠르게 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b37048d4139b83b97c29aa7a22d2da66c283ae2" translate="yes" xml:space="preserve">
          <source>The actual configuration line should be on one line.</source>
          <target state="translated">실제 구성 줄은 한 줄에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b70c0ba474f3173fff896ac2745af10a69e6cc3b" translate="yes" xml:space="preserve">
          <source>The additional AliasMatch makes it so that</source>
          <target state="translated">추가 AliasMatch를 통해</target>
        </trans-unit>
        <trans-unit id="d6139a3bd26979c3a7767519a48aa9c385b73634" translate="yes" xml:space="preserve">
          <source>The advantage of doing this is that the history of &lt;code&gt;next&lt;/code&gt; will be clean. For example, some topics merged into &lt;code&gt;next&lt;/code&gt; may have initially looked promising, but were later found to be undesirable or premature. In such a case, the topic is reverted out of &lt;code&gt;next&lt;/code&gt; but the fact remains in the history that it was once merged and reverted. By recreating &lt;code&gt;next&lt;/code&gt;, you give another incarnation of such topics a clean slate to retry, and a feature release is a good point in history to do so.</source>
          <target state="translated">이 작업의 장점은 &lt;code&gt;next&lt;/code&gt; 역사가 깨끗 하다는 것입니다. 예를 들어, &lt;code&gt;next&lt;/code&gt; 병합 된 일부 주제 는 처음에는 유망 해 보였지만 나중에 바람직하지 않거나 조기에 발견되었습니다. 이 경우 주제는 &lt;code&gt;next&lt;/code&gt; 로 되돌아 가지만 사실은 한 번 병합되고 되돌아 간 역사에 남아 있습니다. 다시 만들어 &lt;code&gt;next&lt;/code&gt; , 다시 시도에 같은 주제의 또 다른 화신에게 백지를주고, 기능 해제 그렇게 할 역사에 좋은 지점입니다.</target>
        </trans-unit>
        <trans-unit id="2f1746fed6139a8489ee3d916322bdcbeb17e684" translate="yes" xml:space="preserve">
          <source>The advantage of using an external diff command is flexibility. You are not bound to find line-oriented changes, nor is it necessary for the output to resemble unified diff. You are free to locate and report changes in the most appropriate way for your data format.</source>
          <target state="translated">외부 diff 명령을 사용하면 얻을 수있는 이점은 유연성입니다. 라인 중심의 변경 사항을 찾아야하거나 출력이 통합 된 diff와 비슷할 필요도 없습니다. 데이터 형식에 가장 적합한 방식으로 변경 사항을 찾아보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37f935f00ace4f7aca8e441adbbf1abe0704a83a" translate="yes" xml:space="preserve">
          <source>The am backend drops any &quot;empty&quot; commits, regardless of whether the commit started empty (had no changes relative to its parent to start with) or ended empty (all changes were already applied upstream in other commits).</source>
          <target state="translated">am 백엔드는 커밋이 비어 있기 시작했거나 (부모에 대한 변경 사항이 없었 음) 비어 있었는지 (모든 변경 사항이 이미 다른 커밋에서 업스트림에 적용되었는지) 여부에 관계없이 &quot;빈&quot;커밋을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="dca841501c279516ee09991304a0c48e7701d81e" translate="yes" xml:space="preserve">
          <source>The apply backend has not traditionally called the post-commit hook, while the merge backend has. Both have called the post-checkout hook, though the merge backend has squelched its output. Further, both backends only call the post-checkout hook with the starting point commit of the rebase, not the intermediate commits nor the final commit. In each case, the calling of these hooks was by accident of implementation rather than by design (both backends were originally implemented as shell scripts and happened to invoke other commands like &lt;code&gt;git checkout&lt;/code&gt; or &lt;code&gt;git commit&lt;/code&gt; that would call the hooks). Both backends should have the same behavior, though it is not entirely clear which, if any, is correct. We will likely make rebase stop calling either of these hooks in the future.</source>
          <target state="translated">The apply backend has not traditionally called the post-commit hook, while the merge backend has. Both have called the post-checkout hook, though the merge backend has squelched its output. Further, both backends only call the post-checkout hook with the starting point commit of the rebase, not the intermediate commits nor the final commit. In each case, the calling of these hooks was by accident of implementation rather than by design (both backends were originally implemented as shell scripts and happened to invoke other commands like &lt;code&gt;git checkout&lt;/code&gt; or &lt;code&gt;git commit&lt;/code&gt; that would call the hooks). Both backends should have the same behavior, though it is not entirely clear which, if any, is correct. We will likely make rebase stop calling either of these hooks in the future.</target>
        </trans-unit>
        <trans-unit id="2d847a3833f639a38bf6461e5e337a484ba4ec15" translate="yes" xml:space="preserve">
          <source>The apply backend has safety problems with an ill-timed interrupt; if the user presses Ctrl-C at the wrong time to try to abort the rebase, the rebase can enter a state where it cannot be aborted with a subsequent &lt;code&gt;git rebase --abort&lt;/code&gt;. The merge backend does not appear to suffer from the same shortcoming. (See &lt;a href=&quot;https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/&quot;&gt;https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/&lt;/a&gt; for details.)</source>
          <target state="translated">The apply backend has safety problems with an ill-timed interrupt; if the user presses Ctrl-C at the wrong time to try to abort the rebase, the rebase can enter a state where it cannot be aborted with a subsequent &lt;code&gt;git rebase --abort&lt;/code&gt; . The merge backend does not appear to suffer from the same shortcoming. (See &lt;a href=&quot;https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/&quot;&gt;https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/&lt;/a&gt; for details.)</target>
        </trans-unit>
        <trans-unit id="dee2d136841d9fd2b1d297f54743df3833db5f0a" translate="yes" xml:space="preserve">
          <source>The apply backend unfortunately drops intentionally empty commits, i.e. commits that started empty, though these are rare in practice. It also drops commits that become empty and has no option for controlling this behavior.</source>
          <target state="translated">The apply backend unfortunately drops intentionally empty commits, i.e. commits that started empty, though these are rare in practice. It also drops commits that become empty and has no option for controlling this behavior.</target>
        </trans-unit>
        <trans-unit id="589a509b2859f73d9f2a04b58c811ba95394014f" translate="yes" xml:space="preserve">
          <source>The apply backend works by creating a sequence of patches (by calling &lt;code&gt;format-patch&lt;/code&gt; internally), and then applying the patches in sequence (calling &lt;code&gt;am&lt;/code&gt; internally). Patches are composed of multiple hunks, each with line numbers, a context region, and the actual changes. The line numbers have to be taken with some fuzz, since the other side will likely have inserted or deleted lines earlier in the file. The context region is meant to help find how to adjust the line numbers in order to apply the changes to the right lines. However, if multiple areas of the code have the same surrounding lines of context, the wrong one can be picked. There are real-world cases where this has caused commits to be reapplied incorrectly with no conflicts reported. Setting diff.context to a larger value may prevent such types of problems, but increases the chance of spurious conflicts (since it will require more lines of matching context to apply).</source>
          <target state="translated">The apply backend works by creating a sequence of patches (by calling &lt;code&gt;format-patch&lt;/code&gt; internally), and then applying the patches in sequence (calling &lt;code&gt;am&lt;/code&gt; internally). Patches are composed of multiple hunks, each with line numbers, a context region, and the actual changes. The line numbers have to be taken with some fuzz, since the other side will likely have inserted or deleted lines earlier in the file. The context region is meant to help find how to adjust the line numbers in order to apply the changes to the right lines. However, if multiple areas of the code have the same surrounding lines of context, the wrong one can be picked. There are real-world cases where this has caused commits to be reapplied incorrectly with no conflicts reported. Setting diff.context to a larger value may prevent such types of problems, but increases the chance of spurious conflicts (since it will require more lines of matching context to apply).</target>
        </trans-unit>
        <trans-unit id="013053835d145f0cc494db8211a188c9999bae09" translate="yes" xml:space="preserve">
          <source>The area where a pair of conflicting changes happened is marked with markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. The part before the &lt;code&gt;=======&lt;/code&gt; is typically your side, and the part afterwards is typically their side.</source>
          <target state="translated">충돌하는 한 쌍의 변경이 발생한 영역에는 마커 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;=======&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 가 표시됩니다 . &lt;code&gt;=======&lt;/code&gt; 앞의 부분 은 일반적으로 당신 편이고 , 그 이후의 부분은 일반적으로 그들의 편입니다.</target>
        </trans-unit>
        <trans-unit id="bbce7a566319a0fa5122538fad84df16b94a33f3" translate="yes" xml:space="preserve">
          <source>The argument to this option may be a glob on ref names, a ref, or the (possibly abbreviated) SHA-1 of a commit. Specifying a glob is equivalent to specifying this option multiple times, one for each matching ref name.</source>
          <target state="translated">이 옵션에 대한 논거는 심판 이름, 심판, 또는 커밋의 (약어) SHA-1에 대한 glob 일 수 있습니다. glob를 지정하는 것은 일치하는 각 ref 이름마다 하나씩이 옵션을 여러 번 지정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6083c463b2a8fa637d23cd99c59e9746cb6a7539" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;diff&lt;/code&gt; affects how Git generates diffs for particular files. It can tell Git whether to generate a textual patch for the path or to treat the path as a binary file. It can also affect what line is shown on the hunk header &lt;code&gt;@@ -k,l +n,m @@&lt;/code&gt; line, tell Git to use an external command to generate the diff, or ask Git to convert binary files to a text format before generating the diff.</source>
          <target state="translated">&lt;code&gt;diff&lt;/code&gt; 속성 은 Git이 특정 파일에 대해 diff를 생성하는 방법에 영향을줍니다. 경로에 대한 텍스트 패치를 생성할지 또는 경로를 이진 파일로 취급할지 Git에 알릴 수 있습니다. 또한 행크 헤더 &lt;code&gt;@@ -k,l +n,m @@&lt;/code&gt; 행 에 표시되는 행에 영향을 줄 수 있으며 , Git에 외부 명령을 사용하여 diff를 생성하도록 지시하거나, Git에 바이너리 파일을 텍스트 형식으로 변환하도록 요청하십시오. diff를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e3fef41e3a691b83ea57e915fd492f173e96b0ec" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;merge&lt;/code&gt; affects how three versions of a file are merged when a file-level merge is necessary during &lt;code&gt;git merge&lt;/code&gt;, and other commands such as &lt;code&gt;git revert&lt;/code&gt; and &lt;code&gt;git cherry-pick&lt;/code&gt;.</source>
          <target state="translated">속성 &lt;code&gt;merge&lt;/code&gt; 은 &lt;code&gt;git merge&lt;/code&gt; 동안 파일 레벨 병합 과 &lt;code&gt;git revert&lt;/code&gt; 및 &lt;code&gt;git cherry-pick&lt;/code&gt; 과 같은 다른 명령 이 필요할 때 파일의 세 가지 버전이 병합되는 방식에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="2fe7b4a122d21c0258f6159b6aeead7d915c58b4" translate="yes" xml:space="preserve">
          <source>The attributes allow a fine-grained control, how the line endings are converted. Here is an example that will make Git normalize .txt, .vcproj and .sh files, ensure that .vcproj files have CRLF and .sh files have LF in the working directory, and prevent .jpg files from being normalized regardless of their content.</source>
          <target state="translated">이 속성을 사용하면 줄 끝이 변환되는 방식을 세밀하게 제어 할 수 있습니다. 다음은 Git을 .txt, .vcproj 및 .sh 파일을 정규화하고 .vcproj 파일에 CRLF가 있고 .sh 파일에 작업 디렉토리에 LF가 있는지 확인하고 내용에 관계없이 .jpg 파일이 정규화되는 것을 방지하는 예제입니다.</target>
        </trans-unit>
        <trans-unit id="d53ffa6d811b54f0c7bdf879ab5abd1f6c7675e8" translate="yes" xml:space="preserve">
          <source>The author and committer names are by convention some form of a personal name (that is, the name by which other humans refer to you), although Git does not enforce or require any particular form. Arbitrary Unicode may be used, subject to the constraints listed above. This name has no effect on authentication; for that, see the &lt;code&gt;credential.username&lt;/code&gt; variable in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">The author and committer names are by convention some form of a personal name (that is, the name by which other humans refer to you), although Git does not enforce or require any particular form. Arbitrary Unicode may be used, subject to the constraints listed above. This name has no effect on authentication; for that, see the &lt;code&gt;credential.username&lt;/code&gt; variable in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0849ab3d36b0ce6d3f6183dc21f6e83ad1520176" translate="yes" xml:space="preserve">
          <source>The author name and email address to use when no author information can be found in the patch description.</source>
          <target state="translated">패치 정보에서 저자 정보가 없을 때 사용할 저자 이름과 이메일 주소.</target>
        </trans-unit>
        <trans-unit id="b012a2641006f12bad01716515743698d7deabe2" translate="yes" xml:space="preserve">
          <source>The author of a piece of code.</source>
          <target state="translated">코드 조각의 저자.</target>
        </trans-unit>
        <trans-unit id="147440e8e5aa984c82659720dc655a2dca5add95" translate="yes" xml:space="preserve">
          <source>The backend process sets GIT_COMMITTER_NAME to &lt;code&gt;$REMOTE_USER&lt;/code&gt; and GIT_COMMITTER_EMAIL to &lt;code&gt;${REMOTE_USER}@http.${REMOTE_ADDR}&lt;/code&gt;, ensuring that any reflogs created by &lt;code&gt;git-receive-pack&lt;/code&gt; contain some identifying information of the remote user who performed the push.</source>
          <target state="translated">백엔드 프로세스는 GIT_COMMITTER_NAME을 &lt;code&gt;$REMOTE_USER&lt;/code&gt; , GIT_COMMITTER_EMAIL을 &lt;code&gt;${REMOTE_USER}@http.${REMOTE_ADDR}&lt;/code&gt; 으로 설정하여 &lt;code&gt;git-receive-pack&lt;/code&gt; 으로 작성된 모든 reflog 에 푸시를 수행 한 원격 사용자의 식별 정보가 포함되도록합니다.</target>
        </trans-unit>
        <trans-unit id="21e5e59ef58a1f64125adda00de18248644f6705" translate="yes" xml:space="preserve">
          <source>The base object could also be deltified if it&amp;rsquo;s in the same pack. Ref-delta can also refer to an object outside the pack (i.e. the so-called &quot;thin pack&quot;). When stored on disk however, the pack should be self contained to avoid cyclic dependency.</source>
          <target state="translated">기본 팩이 동일한 팩에있는 경우 기본 객체를 제거 할 수도 있습니다. Ref-delta는 또한 팩 외부의 물체 (즉, &quot;얇은 팩&quot;)를 지칭 할 수도 있습니다. 그러나 디스크에 저장 될 때 팩은 주기적 종속성을 피하기 위해 자체 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1877d075d52f12eee201f2607da0c072a35f24bc" translate="yes" xml:space="preserve">
          <source>The base tree information block is used for maintainers or third party testers to know the exact state the patch series applies to. It consists of the &lt;code&gt;base commit&lt;/code&gt;, which is a well-known commit that is part of the stable part of the project history everybody else works off of, and zero or more &lt;code&gt;prerequisite patches&lt;/code&gt;, which are well-known patches in flight that is not yet part of the &lt;code&gt;base commit&lt;/code&gt; that need to be applied on top of &lt;code&gt;base commit&lt;/code&gt; in topological order before the patches can be applied.</source>
          <target state="translated">기본 트리 정보 블록은 유지 관리자 또는 타사 테스터가 패치 시리즈가 적용되는 정확한 상태를 알기 위해 사용됩니다. 그것은 구성 &lt;code&gt;base commit&lt;/code&gt; 잘 알려진 그 다른 프로젝트 역사 모두의 안정적인 부분의 일부의 오프 작동 커밋이다, 0 개 이상의 &lt;code&gt;prerequisite patches&lt;/code&gt; 아직없는 비행 패치를 잘 알려져있다, 패치를 적용하기 전에 &lt;code&gt;base commit&lt;/code&gt; 위에 토폴로지 순서 로 적용해야하는 &lt;code&gt;base commit&lt;/code&gt; 일부 .</target>
        </trans-unit>
        <trans-unit id="dc39b1b9637026dfb15dfa743421fbe1dc2277e7" translate="yes" xml:space="preserve">
          <source>The basic colors accepted are &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;black&lt;/code&gt;, &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;green&lt;/code&gt;, &lt;code&gt;yellow&lt;/code&gt;, &lt;code&gt;blue&lt;/code&gt;, &lt;code&gt;magenta&lt;/code&gt;, &lt;code&gt;cyan&lt;/code&gt; and &lt;code&gt;white&lt;/code&gt;. The first color given is the foreground; the second is the background.</source>
          <target state="translated">허용되는 기본 색상은 &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;black&lt;/code&gt; , &lt;code&gt;red&lt;/code&gt; , &lt;code&gt;green&lt;/code&gt; , &lt;code&gt;yellow&lt;/code&gt; , &lt;code&gt;blue&lt;/code&gt; , &lt;code&gt;magenta&lt;/code&gt; , &lt;code&gt;cyan&lt;/code&gt; 및 &lt;code&gt;white&lt;/code&gt; 입니다. 주어진 첫 번째 색상은 전경입니다. 두 번째는 배경입니다.</target>
        </trans-unit>
        <trans-unit id="440eb92d2667463744ad365910f079c5b0c24b8b" translate="yes" xml:space="preserve">
          <source>The basic colors accepted are &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;black&lt;/code&gt;, &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;green&lt;/code&gt;, &lt;code&gt;yellow&lt;/code&gt;, &lt;code&gt;blue&lt;/code&gt;, &lt;code&gt;magenta&lt;/code&gt;, &lt;code&gt;cyan&lt;/code&gt; and &lt;code&gt;white&lt;/code&gt;. The first color given is the foreground; the second is the background. All the basic colors except &lt;code&gt;normal&lt;/code&gt; have a bright variant that can be speficied by prefixing the color with &lt;code&gt;bright&lt;/code&gt;, like &lt;code&gt;brightred&lt;/code&gt;.</source>
          <target state="translated">The basic colors accepted are &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;black&lt;/code&gt; , &lt;code&gt;red&lt;/code&gt; , &lt;code&gt;green&lt;/code&gt; , &lt;code&gt;yellow&lt;/code&gt; , &lt;code&gt;blue&lt;/code&gt; , &lt;code&gt;magenta&lt;/code&gt; , &lt;code&gt;cyan&lt;/code&gt; and &lt;code&gt;white&lt;/code&gt; . The first color given is the foreground; the second is the background. All the basic colors except &lt;code&gt;normal&lt;/code&gt; have a bright variant that can be speficied by prefixing the color with &lt;code&gt;bright&lt;/code&gt; , like &lt;code&gt;brightred&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4e1b119ab89bbecfc6f0f5d854268dcecbb088f" translate="yes" xml:space="preserve">
          <source>The basic form described in DESCRIPTION with a Git directory, a working directory, a &lt;code&gt;gitlink&lt;/code&gt;, and a &lt;code&gt;.gitmodules&lt;/code&gt; entry.</source>
          <target state="translated">Git 디렉토리, 작업 디렉토리, &lt;code&gt;gitlink&lt;/code&gt; 및 &lt;code&gt;.gitmodules&lt;/code&gt; 항목 과 함께 DESCRIPTION에 설명 된 기본 양식 .</target>
        </trans-unit>
        <trans-unit id="b21f7863c055f0aa6938a038ffa25acf7017fe84" translate="yes" xml:space="preserve">
          <source>The basic greedy diff algorithm. Currently, this is the default.</source>
          <target state="translated">욕심 많은 기본 알고리즘. 현재는 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="ebbd31d9dd00322abaa4bb83a8b03f787c70d43c" translate="yes" xml:space="preserve">
          <source>The basic requirements:</source>
          <target state="translated">기본 요구 사항 :</target>
        </trans-unit>
        <trans-unit id="675f96a5f033def81701bda4e874ec2fbad8a388" translate="yes" xml:space="preserve">
          <source>The below documentation is the same as what&amp;rsquo;s found in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;:</source>
          <target state="translated">아래 문서는 &lt;a href=&quot;git-config&quot;&gt;git-config [1]에&lt;/a&gt; 있는 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f55762f9996c39bda184001319965b733714f313" translate="yes" xml:space="preserve">
          <source>The best way to get one is by using the &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; command to download a copy of an existing repository. If you don&amp;rsquo;t already have a project in mind, here are some interesting examples:</source>
          <target state="translated">하나를 얻는 가장 좋은 방법은 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 명령을 사용하여 기존 리포지토리의 복사본을 다운로드하는 것입니다. 아직 프로젝트를 염두에 두지 않은 경우 몇 가지 흥미로운 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2b6c88cac94cf24687d4ba9657759c1ab28582a" translate="yes" xml:space="preserve">
          <source>The best way to see how this works is using the &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; command; running gitk now on a Git repository and looking for merge commits will help understand how Git organizes history.</source>
          <target state="translated">이것이 어떻게 작동하는지 확인하는 가장 좋은 방법은 &lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt; 명령을 사용하는 것입니다. Git 저장소에서 gitk를 실행하고 병합 커밋을 찾으면 Git이 히스토리를 구성하는 방법을 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="8130ad227eb2e1ffe8f116dc4280c5919bb4cd97" translate="yes" xml:space="preserve">
          <source>The branch &lt;code&gt;test&lt;/code&gt; is short for &lt;code&gt;refs/heads/test&lt;/code&gt;.</source>
          <target state="translated">분기 &lt;code&gt;test&lt;/code&gt; 는 &lt;code&gt;refs/heads/test&lt;/code&gt; 약자입니다 .</target>
        </trans-unit>
        <trans-unit id="420b2dd61e4562065a5bd273fcdbaecde70d1742" translate="yes" xml:space="preserve">
          <source>The branch LRU builtin to fast-import tends to behave very well, and the cost of activating an inactive branch is so low that bouncing around between branches has virtually no impact on import performance.</source>
          <target state="translated">빠른 가져 오기에 내장 된 지점 LRU는 매우 잘 작동하는 경향이 있으며, 비활성 지점 활성화 비용이 너무 낮아서 지점 간 반송이 가져 오기 성능에 사실상 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58be5b6cbe7d7c0a923608fe1415c68702e2aa84" translate="yes" xml:space="preserve">
          <source>The chain of operation</source>
          <target state="translated">운영 체인</target>
        </trans-unit>
        <trans-unit id="cb0b83bdafd60672fc0fb681d6c09ff33adfb7dc" translate="yes" xml:space="preserve">
          <source>The changes are still visible in the submodule&amp;rsquo;s reflog.</source>
          <target state="translated">변경 사항은 여전히 ​​서브 모듈의 reflog에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e18a17400a7fdeb34351715eb209f43bb56b69d6" translate="yes" xml:space="preserve">
          <source>The clone command creates a new directory named after the project (&lt;code&gt;git&lt;/code&gt; or &lt;code&gt;linux&lt;/code&gt; in the examples above). After you cd into this directory, you will see that it contains a copy of the project files, called the &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt;, together with a special top-level directory named &lt;code&gt;.git&lt;/code&gt;, which contains all the information about the history of the project.</source>
          <target state="translated">clone 명령은 프로젝트의 이름을 딴 새 디렉토리를 만듭니다 ( 위 예에서는 &lt;code&gt;git&lt;/code&gt; 또는 &lt;code&gt;linux&lt;/code&gt; ). 이 디렉토리로 들어가면 &lt;a href=&quot;#def_working_tree&quot;&gt;작업 트리&lt;/a&gt; 라는 프로젝트 파일의 사본과 &lt;code&gt;.git&lt;/code&gt; 이라는 특수 최상위 디렉토리 와 프로젝트 히스토리에 대한 모든 정보가 들어있는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b1ff6b6614bf65ff7cf18fa7ac8ca0c73c31da4" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;git commit -a&lt;/code&gt; first looks at your working tree, notices that you have modified hello.c and removed goodbye.c, and performs necessary &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git rm&lt;/code&gt; for you.</source>
          <target state="translated">&lt;code&gt;git commit -a&lt;/code&gt; 명령 은 먼저 작업 트리를보고 hello.c를 수정하고 goodbye.c를 제거한 것을 확인하고 필요한 &lt;code&gt;git add&lt;/code&gt; 및 &lt;code&gt;git rm&lt;/code&gt; 을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="95cb34ce247ae47a8a7d5a122ee875bb99decb40" translate="yes" xml:space="preserve">
          <source>The command allows for creation and fast-forwarding of sha1 refs (heads/tags) on the remote end (strictly speaking, it is the local end &lt;code&gt;git-receive-pack&lt;/code&gt; runs, but to the user who is sitting at the send-pack end, it is updating the remote. Confused?)</source>
          <target state="translated">이 명령을 사용하면 원격 엔드에서 sha1 참조 (헤드 / 태그)를 작성하고 빨리 전달할 수 있습니다 (엄격히 말해서 로컬 엔드 &lt;code&gt;git-receive-pack&lt;/code&gt; 실행이지만 send-pack 엔드에 앉아있는 사용자에게는 리모컨 업데이트 중입니다. 혼란 스럽습니까?)</target>
        </trans-unit>
        <trans-unit id="2b42e9d45bef456324952e5870d272017a1a991c" translate="yes" xml:space="preserve">
          <source>The command also looks at &lt;code&gt;core.trustctime&lt;/code&gt; configuration variable. It can be useful when the inode change time is regularly modified by something outside Git (file system crawlers and backup systems use ctime for marking files processed) (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">이 명령은 &lt;code&gt;core.trustctime&lt;/code&gt; 구성 변수도 확인합니다. inode 변경 시간이 Git 외부의 파일에 의해 정기적으로 수정 될 때 유용합니다 (파일 시스템 크롤러 및 백업 시스템은 ctime을 사용하여 처리 된 파일을 표시 함) ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b2d2a0a5d3ee3b745ff8e27d667799782d3fee27" translate="yes" xml:space="preserve">
          <source>The command by default does not allow an update that is not a fast-forward to prevent such loss of history.</source>
          <target state="translated">기본적으로이 명령은 이러한 기록 손실을 방지하기 위해 빨리 감기가 아닌 업데이트를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57bd298a9fbda93bedda739fa9a93ffd1fbe53dd" translate="yes" xml:space="preserve">
          <source>The command by default packs all tags and refs that are already packed, and leaves other refs alone. This is because branches are expected to be actively developed and packing their tips does not help performance. This option causes branch tips to be packed as well. Useful for a repository with many branches of historical interests.</source>
          <target state="translated">기본적으로이 명령은 이미 압축 된 모든 태그와 참조를 압축하고 다른 참조는 그대로 둡니다. 이는 브랜치가 적극적으로 개발되고 팁을 포장하는 것이 성능에 도움이되지 않기 때문입니다. 이 옵션을 사용하면 분기 팁도 포장됩니다. 많은 역사적 관심 분야가있는 저장소에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="affc62639786f9435bc3e40b781bdaefab9bf88f" translate="yes" xml:space="preserve">
          <source>The command can also be used to restore the content in the index with &lt;code&gt;--staged&lt;/code&gt;, or restore both the working tree and the index with &lt;code&gt;--staged --worktree&lt;/code&gt;.</source>
          <target state="translated">또한이 명령으로 인덱스의 내용을 복원 할 수 있습니다 &lt;code&gt;--staged&lt;/code&gt; , 또는 작업 트리와 인덱스를 모두 복원 &lt;code&gt;--staged --worktree&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="033264e01f6eaf7651e64aee25dc83cea3397f0e" translate="yes" xml:space="preserve">
          <source>The command finds the most recent tag that is reachable from a commit. If the tag points to the commit, then only the tag is shown. Otherwise, it suffixes the tag name with the number of additional commits on top of the tagged object and the abbreviated object name of the most recent commit. The result is a &quot;human-readable&quot; object name which can also be used to identify the commit to other git commands.</source>
          <target state="translated">이 명령은 커밋에서 도달 할 수있는 가장 최근 태그를 찾습니다. 태그가 커밋을 가리키는 경우 태그 만 표시됩니다. 그렇지 않으면 태그 된 객체 위에 추가 커밋 수와 가장 최근의 커밋의 약식 객체 이름으로 태그 이름에 접미사를 붙입니다. 결과는 다른 사람 명령에 대한 커밋을 식별하는 데 사용될 수있는 &quot;사람이 읽을 수있는&quot;객체 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3ab56fbe7068ffbc29e1e09d644dcd93a3d4ced5" translate="yes" xml:space="preserve">
          <source>The command honors &lt;code&gt;color.status&lt;/code&gt; (or &lt;code&gt;status.color&lt;/code&gt; &amp;mdash; they mean the same thing and the latter is kept for backward compatibility) and &lt;code&gt;color.status.&amp;lt;slot&amp;gt;&lt;/code&gt; configuration variables to colorize its output.</source>
          <target state="translated">이 명령은 &lt;code&gt;color.status&lt;/code&gt; (또는 &lt;code&gt;status.color&lt;/code&gt; - 동일한 것을 의미하며 후자는 이전 버전과의 호환성을 위해 유지됨) 및 &lt;code&gt;color.status.&amp;lt;slot&amp;gt;&lt;/code&gt; 구성 변수를 사용하여 출력을 채색합니다.</target>
        </trans-unit>
        <trans-unit id="426f574eb4223ad0c1806f2471b371a9ce2ce62b" translate="yes" xml:space="preserve">
          <source>The command honors &lt;code&gt;core.filemode&lt;/code&gt; configuration variable. If your repository is on a filesystem whose executable bits are unreliable, this should be set to &lt;code&gt;false&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). This causes the command to ignore differences in file modes recorded in the index and the file mode on the filesystem if they differ only on executable bit. On such an unfortunate filesystem, you may need to use &lt;code&gt;git update-index --chmod=&lt;/code&gt;.</source>
          <target state="translated">이 명령은 &lt;code&gt;core.filemode&lt;/code&gt; 구성 변수를 사용합니다. 저장소가 실행 가능 비트가 신뢰할 수없는 파일 시스템에있는 경우 이는 &lt;code&gt;false&lt;/code&gt; 로 설정해야합니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). 이로 인해 명령 비트가 실행 가능 비트에서만 다른 경우 색인에 기록 된 파일 모드와 파일 시스템의 파일 모드의 차이점을 무시합니다. 이러한 불행한 파일 시스템에서는 &lt;code&gt;git update-index --chmod=&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1c1fbeab69cdf1a35e381ef7eff39e0ef873ae8e" translate="yes" xml:space="preserve">
          <source>The command is kept primarily for historical reasons; fingers of many people who learned Git long before &lt;code&gt;git log&lt;/code&gt; was invented by reading Linux kernel mailing list are trained to type it.</source>
          <target state="translated">명령은 주로 역사적 이유로 유지됩니다. 리눅스 커널 메일 링리스트를 읽어서 &lt;code&gt;git log&lt;/code&gt; 가 발명 되기 오래 전에 Git을 배운 많은 사람들의 손가락이 그것을 입력하도록 훈련 받았다.</target>
        </trans-unit>
        <trans-unit id="078766939aed50311c1dcee68ff982a08734592e" translate="yes" xml:space="preserve">
          <source>The command line for those commands that support taking submodules as part of their pathspecs. Most commands have a boolean flag &lt;code&gt;--recurse-submodules&lt;/code&gt; which specify whether to recurse into submodules. Examples are &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;checkout&lt;/code&gt;. Some commands take enums, such as &lt;code&gt;fetch&lt;/code&gt; and &lt;code&gt;push&lt;/code&gt;, where you can specify how submodules are affected.</source>
          <target state="translated">서브 모듈을 경로 스펙의 일부로 가져 오는 것을 지원하는 명령의 명령 행. 대부분의 명령에는 부울 플래그 &lt;code&gt;--recurse-submodules&lt;/code&gt; 가 있으며,이 플래그 는 하위 모듈로의 재귀 여부를 지정합니다. 예는 &lt;code&gt;grep&lt;/code&gt; 및 &lt;code&gt;checkout&lt;/code&gt; 입니다. &lt;code&gt;fetch&lt;/code&gt; 및 &lt;code&gt;push&lt;/code&gt; 와 같은 일부 명령은 하위 모듈의 영향을 지정할 수있는 열거 형 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0c67f633874ba0fbe1af2a193c1c589167c2ab4d" translate="yes" xml:space="preserve">
          <source>The command looks at &lt;code&gt;core.ignorestat&lt;/code&gt; configuration variable. See &lt;code&gt;Using &quot;assume unchanged&quot; bit&lt;/code&gt; section above.</source>
          <target state="translated">이 명령은 &lt;code&gt;core.ignorestat&lt;/code&gt; 구성 변수를 확인합니다. 위의 &lt;code&gt;Using &quot;assume unchanged&quot; bit&lt;/code&gt; 섹션 사용을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f7f0d79e587cabe73eebce8a6424fb5cae3c144" translate="yes" xml:space="preserve">
          <source>The command looks at &lt;code&gt;core.ignorestat&lt;/code&gt; configuration variable. When this is true, paths updated with &lt;code&gt;git update-index paths...&lt;/code&gt; and paths updated with other Git commands that update both index and working tree (e.g. &lt;code&gt;git apply --index&lt;/code&gt;, &lt;code&gt;git checkout-index -u&lt;/code&gt;, and &lt;code&gt;git read-tree -u&lt;/code&gt;) are automatically marked as &quot;assume unchanged&quot;. Note that &quot;assume unchanged&quot; bit is &lt;strong&gt;not&lt;/strong&gt; set if &lt;code&gt;git update-index --refresh&lt;/code&gt; finds the working tree file matches the index (use &lt;code&gt;git update-index --really-refresh&lt;/code&gt; if you want to mark them as &quot;assume unchanged&quot;).</source>
          <target state="translated">이 명령은 &lt;code&gt;core.ignorestat&lt;/code&gt; 구성 변수를 확인합니다. 이것이 사실이면, &lt;code&gt;git update-index paths...&lt;/code&gt; 업데이트 된 경로와 인덱스와 작업 트리를 모두 업데이트하는 다른 Git 명령으로 업데이트 된 경로 (예 : &lt;code&gt;git apply --index&lt;/code&gt; , &lt;code&gt;git checkout-index -u&lt;/code&gt; 및 &lt;code&gt;git read-tree -u&lt;/code&gt; )는 &quot;변경되지 않은 것으로 가정&quot;으로 자동 표시됩니다. 비트가 &quot;변하지 가정&quot;주의 &lt;strong&gt;하지&lt;/strong&gt; 경우 설정 &lt;code&gt;git update-index --refresh&lt;/code&gt; (사용 작업 트리 파일을 발견 인덱스 일치 &lt;code&gt;git update-index --really-refresh&lt;/code&gt; 하면 &quot;변하지 가정&quot;로 표시 할 경우).</target>
        </trans-unit>
        <trans-unit id="719021beca97cba355f40567331ed4531fab91cd" translate="yes" xml:space="preserve">
          <source>The command loop shows the list of subcommands available, and gives a prompt &quot;What now&amp;gt; &quot;. In general, when the prompt ends with a single &lt;code&gt;&amp;gt;&lt;/code&gt;, you can pick only one of the choices given and type return, like this:</source>
          <target state="translated">명령 루프는 사용 가능한 하위 명령 목록을 표시하고 &quot;지금 무엇&amp;gt;&quot;프롬프트를 표시합니다. 일반적으로 프롬프트가 단일 &lt;code&gt;&amp;gt;&lt;/code&gt; 로 끝나는 경우 다음과 같이 주어진 선택 중 하나만 선택하고 return을 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="653e31d7d7203bdc451cd54eed957012f41434d3" translate="yes" xml:space="preserve">
          <source>The command refuses to process new mailboxes until the current operation is finished, so if you decide to start over from scratch, run &lt;code&gt;git am --abort&lt;/code&gt; before running the command with mailbox names.</source>
          <target state="translated">명령은 현재 작업이 완료 될 때까지 새 메일 함을 처리하지 않으므로 처음부터 다시 시작하기로 결정한 경우, 메일 함 이름으로 명령을 실행하기 전에 &lt;code&gt;git am --abort&lt;/code&gt; 를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="024617064e80c5362385868f7a76ff908e5b8451" translate="yes" xml:space="preserve">
          <source>The command removes only the paths that are known to Git.</source>
          <target state="translated">The command removes only the paths that are known to Git.</target>
        </trans-unit>
        <trans-unit id="ddc41d8aed51eb71b1c7af7000815eb2a4b359d3" translate="yes" xml:space="preserve">
          <source>The command stream is terminated by a blank line. In some cases (indicated in the documentation of the relevant commands), this blank line is followed by a payload in some other protocol (e.g., the pack protocol), while in others it indicates the end of input.</source>
          <target state="translated">명령 스트림은 빈 줄로 종료됩니다. 경우에 따라 (관련 명령의 문서에 표시됨)이 빈 줄 뒤에 다른 프로토콜 (예 : 팩 프로토콜)의 페이로드가 오는 반면, 다른 경우에는 입력 끝을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9f45aa4005fcc34aa135332c57403a61747c3270" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; command to control what is shown and how, and options applicable to the &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; command to control how the changes each commit introduces are shown.</source>
          <target state="translated">The command takes options applicable to the &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; command to control what is shown and how, and options applicable to the &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; command to control how the changes each commit introduces are shown.</target>
        </trans-unit>
        <trans-unit id="d1cdce0d3b2e7df2146074a7208b9f02c1bab1a7" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;code&gt;git diff-tree&lt;/code&gt; command to control how the changes the commit introduces are shown.</source>
          <target state="translated">이 명령은 &lt;code&gt;git diff-tree&lt;/code&gt; 명령에 적용 가능한 옵션을 사용 하여 커밋이 도입 한 변경 사항이 표시되는 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="35fc48f2de1638c3a16917e24656f5cccec37735" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;code&gt;git log&lt;/code&gt; command to control what is shown and how. See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">이 명령은 &lt;code&gt;git log&lt;/code&gt; 명령에 적용 가능한 옵션을 사용하여 표시되는 내용과 방법을 제어합니다. &lt;a href=&quot;git-log&quot;&gt;git-log [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="704cfc598be528aca39957bda30b48a4e32947ac" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;code&gt;git rev-list&lt;/code&gt; command to control what is shown and how, and options applicable to the &lt;code&gt;git diff-*&lt;/code&gt; commands to control how the changes each commit introduces are shown.</source>
          <target state="translated">이 명령은 &lt;code&gt;git rev-list&lt;/code&gt; 명령에 적용 가능한 옵션을 사용하여 표시되는 내용과 방법 을 제어 하고 &lt;code&gt;git diff-*&lt;/code&gt; 명령에 적용 가능한 옵션을 사용하여 각 커밋의 변경 내용이 표시되는 방식을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="05dd6533643357a7eb4c0a33aa8aafdf86be046c" translate="yes" xml:space="preserve">
          <source>The command takes various subcommands, and different options depending on the subcommand:</source>
          <target state="translated">이 명령은 다양한 하위 명령과 하위 명령에 따라 다른 옵션을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5dfb0879d1b00c6726b4c473489aecee6c7360c1" translate="yes" xml:space="preserve">
          <source>The command that the diff driver should call to generate the text-converted version of a file. The result of the conversion is used to generate a human-readable diff. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">diff 드라이버가 텍스트 변환 버전의 파일을 생성하기 위해 호출해야하는 명령입니다. 변환 결과는 사람이 읽을 수있는 diff를 생성하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="76561fd073c2b7875043b506e4a6c918bbf27fef" translate="yes" xml:space="preserve">
          <source>The command usually removes loose refs under &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; hierarchy after packing them. This option tells it not to.</source>
          <target state="translated">이 명령은 보통 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 계층 구조 에서 느슨한 참조를 압축 한 후 제거 합니다. 이 옵션은하지 말라고 지시합니다.</target>
        </trans-unit>
        <trans-unit id="77170493947dd63f2044149c05ae4eb27dc0d118" translate="yes" xml:space="preserve">
          <source>The command usually shows percentage progress. This flag suppresses it.</source>
          <target state="translated">이 명령은 일반적으로 백분율 진행률을 보여줍니다. 이 플래그는 억제합니다.</target>
        </trans-unit>
        <trans-unit id="3df5350b5d92a4c7df677ed19aeefaf4fd05338a" translate="yes" xml:space="preserve">
          <source>The command which is used to convert the content of a blob object to a worktree file upon checkout. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">체크 아웃시 Blob 오브젝트의 컨텐츠를 작업 트리 파일로 변환하는 데 사용되는 명령입니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e78c7e2042e4de22f48dc29ab38867e1c8242106" translate="yes" xml:space="preserve">
          <source>The command which is used to convert the content of a worktree file to a blob upon checkin. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">체크인시 작업 트리 파일의 컨텐츠를 Blob으로 변환하는 데 사용되는 명령입니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a6711f072ffccd6a7948d8fcfc289d0284bd97d1" translate="yes" xml:space="preserve">
          <source>The command will only rewrite the &lt;code&gt;positive&lt;/code&gt; refs mentioned in the command line (e.g. if you pass &lt;code&gt;a..b&lt;/code&gt;, only &lt;code&gt;b&lt;/code&gt; will be rewritten). If you specify no filters, the commits will be recommitted without any changes, which would normally have no effect. Nevertheless, this may be useful in the future for compensating for some Git bugs or such, therefore such a usage is permitted.</source>
          <target state="translated">명령은 명령 행에 언급 된 &lt;code&gt;positive&lt;/code&gt; 만 다시 작성합니다 (예 : &lt;code&gt;a..b&lt;/code&gt; 를 전달하면 &lt;code&gt;b&lt;/code&gt; 만 다시 작성 됨). 필터를 지정하지 않으면 변경 사항없이 커밋이 다시 커밋되며 일반적으로 적용되지 않습니다. 그럼에도 불구하고, 이것은 미래에 일부 Git 버그 등을 보상하는 데 유용 할 수 있으므로 이러한 사용이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="6c1d44a42d537aa236fa8b0c18f8ebc1e0d665b8" translate="yes" xml:space="preserve">
          <source>The command writes the commit object name of the common ancestor to the standard output, so we captured its output to a variable, because we will be using it in the next step. By the way, the common ancestor commit is the &quot;Initial commit&quot; commit in this case. You can tell it by:</source>
          <target state="translated">이 명령은 공통 조상의 커밋 객체 이름을 표준 출력에 기록하므로 다음 단계에서 사용할 것이므로 출력을 변수로 캡처했습니다. 그런데이 경우 공통 조상 커밋은 &quot;초기 커밋&quot;커밋입니다. 당신은 그것을 말할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="277f50b8984fb8f1e24e58a015e232c719b0136b" translate="yes" xml:space="preserve">
          <source>The command&amp;rsquo;s second form creates a new branch head named &amp;lt;branchname&amp;gt; which points to the current &lt;code&gt;HEAD&lt;/code&gt;, or &amp;lt;start-point&amp;gt; if given. As a special case, for &amp;lt;start-point&amp;gt;, you may use &lt;code&gt;&quot;A...B&quot;&lt;/code&gt; as a shortcut for the merge base of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; if there is exactly one merge base. You can leave out at most one of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, in which case it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">이 명령의 두 번째 형식은 현재 &lt;code&gt;HEAD&lt;/code&gt; 를 가리키는 &amp;lt;branchname&amp;gt;이라는 새 분기 헤드를 작성 하거나 지정된 경우 &amp;lt;start-point&amp;gt;를 작성합니다. 특별한 경우로 &amp;lt;start-point&amp;gt;의 경우 정확히 하나의 병합 기준이있는 경우 &lt;code&gt;&quot;A...B&quot;&lt;/code&gt; 를 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 병합 기준에 대한 바로 가기로 사용할 수 있습니다 . &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 중 하나만 남겨 둘 수 있으며 ,이 경우 기본값은 &lt;code&gt;HEAD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0384db43c537c0cba33bbce02fa39c058435bd6c" translate="yes" xml:space="preserve">
          <source>The command-line flag --exclude-from=&amp;lt;file&amp;gt; specifies a file containing a list of patterns. Patterns are ordered in the same order they appear in the file.</source>
          <target state="translated">명령 줄 플래그 --exclude-from = &amp;lt;file&amp;gt;은 패턴 목록이 포함 된 파일을 지정합니다. 패턴은 파일에 나타나는 것과 같은 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="84de3c7a7b3ba54b91bb57a464ea60b526231897" translate="yes" xml:space="preserve">
          <source>The command-line flag --exclude-per-directory=&amp;lt;name&amp;gt; specifies a name of the file in each directory &lt;code&gt;git ls-files&lt;/code&gt; examines, normally &lt;code&gt;.gitignore&lt;/code&gt;. Files in deeper directories take precedence. Patterns are ordered in the same order they appear in the files.</source>
          <target state="translated">명령 행 플래그 --exclude-per-directory = &amp;lt;name&amp;gt;은 &lt;code&gt;git ls-files&lt;/code&gt; 가 검사하는 각 디렉토리의 파일 이름을 지정 합니다 (일반적으로 &lt;code&gt;.gitignore&lt;/code&gt; ) . 더 깊은 디렉토리의 파일이 우선합니다. 패턴은 파일에 나타나는 것과 같은 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="de25d36c95ea6a374c3001c57d5c8bbae6052f57" translate="yes" xml:space="preserve">
          <source>The command-line flag --exclude=&amp;lt;pattern&amp;gt; specifies a single pattern. Patterns are ordered in the same order they appear in the command line.</source>
          <target state="translated">명령 줄 플래그 --exclude = &amp;lt;pattern&amp;gt;은 단일 패턴을 지정합니다. 패턴은 명령 행에 나타나는 것과 동일한 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="57163e2560363b464673a4a43dc95a7ad9f9ef3b" translate="yes" xml:space="preserve">
          <source>The commit &quot;D&quot; is called a &quot;merge base&quot; for branch &quot;main&quot; and &quot;dev&quot; because it&amp;rsquo;s the best common ancestor for these branches for a merge.</source>
          <target state="translated">커밋 &quot;D&quot;는 &quot;main&quot;및 &quot;dev&quot;브랜치의 &quot;병합베이스&quot;라고하며,이 브랜치의 병합에 대한 가장 일반적인 조상이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f185c14cbc82f3e4dae044b7f66a7608424887fa" translate="yes" xml:space="preserve">
          <source>The commit author name is taken from the &quot;From: &quot; line of the message, and commit author date is taken from the &quot;Date: &quot; line of the message. The &quot;Subject: &quot; line is used as the title of the commit, after stripping common prefix &quot;[PATCH &amp;lt;anything&amp;gt;]&quot;. The &quot;Subject: &quot; line is supposed to concisely describe what the commit is about in one line of text.</source>
          <target state="translated">커밋 작성자 이름은 메시지의 &quot;보낸 사람 :&quot;줄에서 가져오고 커밋 작성자 날짜는 메시지의 &quot;날짜 :&quot;줄에서 가져옵니다. &quot;Subject :&quot;행은 공통 접두사 &quot;[PATCH &amp;lt;anything&amp;gt;]&quot;을 제거한 후 커밋 제목으로 사용됩니다. &quot;제목 :&quot;줄은 한 줄의 텍스트에서 커밋에 대해 간결하게 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f12acdb07fb960bc2fd1e07b27cc4a2b35ad054" translate="yes" xml:space="preserve">
          <source>The commit list format can be changed by setting the configuration option rebase.instructionFormat. A customized instruction format will automatically have the long commit hash prepended to the format.</source>
          <target state="translated">구성 옵션 rebase.instructionFormat을 설정하여 커밋 목록 형식을 변경할 수 있습니다. 사용자 정의 된 명령 형식은 긴 커밋 해시가 형식 앞에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="56b4186deed0365516ca63a760921d1d85d5abd6" translate="yes" xml:space="preserve">
          <source>The commit log message extracted from e-mail, usually except the title line which comes from e-mail Subject.</source>
          <target state="translated">전자 메일에서 추출 된 커밋 로그 메시지 (일반적으로 전자 메일 제목에서 나오는 제목 줄 제외).</target>
        </trans-unit>
        <trans-unit id="448543278984728d32d400e55fc12701ecc9668d" translate="yes" xml:space="preserve">
          <source>The commit log message, author name and author email are taken from the e-mail, and after minimally decoding MIME transfer encoding, re-coded in the charset specified by i18n.commitencoding (defaulting to UTF-8) by transliterating them. This used to be optional but now it is the default.</source>
          <target state="translated">커밋 로그 메시지, 작성자 이름 및 저자 이메일은 전자 메일에서 가져오고 MIME 전송 인코딩을 최소한으로 디코딩 한 후 음역을 통해 i18n.commitencoding (기본값 UTF-8)으로 지정된 문자 세트로 다시 코딩됩니다. 이것은 선택 사항 이었지만 이제는 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="682ec5a16062666d3ac4c15995f4c320f0569ce3" translate="yes" xml:space="preserve">
          <source>The commit message is formed by the title taken from the &quot;Subject: &quot;, a blank line and the body of the message up to where the patch begins. Excess whitespace at the end of each line is automatically stripped.</source>
          <target state="translated">커밋 메시지는 &quot;Subject :&quot;에서 가져온 제목, 빈 줄 및 패치가 시작되는 위치까지 메시지 본문으로 구성됩니다. 각 줄 끝의 초과 공백은 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9d14a63335261988fcede52b815289c8a87983a5" translate="yes" xml:space="preserve">
          <source>The commit message is supplied either directly with the &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; option, or indirectly from the tag or commit when the second tree-ish denotes such an object, or it is requested by invoking an editor (see &lt;code&gt;--edit&lt;/code&gt; option below).</source>
          <target state="translated">커밋 메시지는 &lt;code&gt;-m&lt;/code&gt; 또는 &lt;code&gt;-F&lt;/code&gt; 옵션 과 함께 직접 제공되거나 두 번째 tree-ish가 그러한 객체를 나타낼 때 커밋 또는 커밋에서 간접적으로 제공되거나 편집기를 호출하여 요청합니다 (아래 &lt;code&gt;--edit&lt;/code&gt; 옵션 참조). .</target>
        </trans-unit>
        <trans-unit id="50413d61f19e8e0d39eb4098c01c599c7c407f25" translate="yes" xml:space="preserve">
          <source>The commit object names shown above would be different for you, but they should match the HEAD commit object names of your repositories. You can check it by running &lt;code&gt;git ls-remote ../a&lt;/code&gt;.</source>
          <target state="translated">위에 표시된 커밋 개체 이름은 사용자마다 다르지만 리포지토리의 HEAD 커밋 개체 이름과 일치해야합니다. &lt;code&gt;git ls-remote ../a&lt;/code&gt; 를 실행하여 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b7bb35b4ae403135d95400938252724b91ca0d2" translate="yes" xml:space="preserve">
          <source>The commit objects record the encoding used for the log message in their encoding header; this option can be used to tell the command to re-code the commit log message in the encoding preferred by the user. For non plumbing commands this defaults to UTF-8. Note that if an object claims to be encoded in &lt;code&gt;X&lt;/code&gt; and we are outputting in &lt;code&gt;X&lt;/code&gt;, we will output the object verbatim; this means that invalid sequences in the original commit may be copied to the output.</source>
          <target state="translated">커밋 개체는 로그 메시지에 사용 된 인코딩을 인코딩 헤더에 기록합니다. 이 옵션을 사용하면 커밋 로그 메시지를 사용자가 선호하는 인코딩으로 다시 코딩하도록 명령에 지시 할 수 있습니다. 배관이 아닌 명령의 경우 기본값은 UTF-8입니다. 참고 오브젝트 청구항에서 부호화되는 경우, &lt;code&gt;X&lt;/code&gt; 및 우리가 출력되는 &lt;code&gt;X&lt;/code&gt; 우리가 그대로 출력 객체 것이다; 이는 원래 커밋의 잘못된 시퀀스가 ​​출력으로 복사 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8a40378090f508382eab3e21e0b4382b3bab0ad4" translate="yes" xml:space="preserve">
          <source>The commit, equivalent to what other systems call a &quot;changeset&quot; or &quot;version&quot;, represents a step in the project&amp;rsquo;s history, and each parent represents an immediately preceding step. Commits with more than one parent represent merges of independent lines of development.</source>
          <target state="translated">다른 시스템이 &quot;changeset&quot;또는 &quot;version&quot;이라고 부르는 것과 동일한 커밋은 프로젝트 히스토리의 단계를 나타내며 각 상위는 직전 단계를 나타냅니다. 둘 이상의 부모가있는 커밋은 독립적 인 개발 라인의 병합을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7d3d64efc4f4511458592fa6c8a58dcfb8579da7" translate="yes" xml:space="preserve">
          <source>The commits are guaranteed to be listed in the order that they were processed by rebase.</source>
          <target state="translated">커밋은 rebase에 의해 처리 된 순서대로 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="00a94582df69c83885533dbdc944c957c3a549e0" translate="yes" xml:space="preserve">
          <source>The commits marked with &lt;code&gt;*&lt;/code&gt; touch the same area in the same file; you need to resolve the conflicts when creating the commit marked with &lt;code&gt;+&lt;/code&gt;. Then you can test the result to make sure your work-in-progress still works with what is in the latest master.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 로 표시된 커밋 은 같은 파일에서 같은 영역을 터치합니다. &lt;code&gt;+&lt;/code&gt; 로 표시된 커밋을 만들 때 충돌을 해결해야합니다 . 그런 다음 결과를 테스트하여 진행중인 작업이 최신 마스터의 작업과 계속 작동하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3fd88845d0ae86224cb7a800b3122f1cf56cb03" translate="yes" xml:space="preserve">
          <source>The commits that were previously saved into the temporary area are then reapplied to the current branch, one by one, in order. Note that any commits in HEAD which introduce the same textual changes as a commit in HEAD..&amp;lt;upstream&amp;gt; are omitted (i.e., a patch already accepted upstream with a different commit message or timestamp will be skipped).</source>
          <target state="translated">이전에 임시 영역에 저장된 커밋은 순서대로 현재 분기에 하나씩 다시 적용됩니다. HEAD .. &amp;lt;upstream&amp;gt;에서 커밋과 동일한 텍스트 변경을 도입하는 HEAD에서 커밋은 생략됩니다 (즉, 다른 커밋 메시지 또는 타임 스탬프가있는 업스트림에서 이미 승인 된 패치는 생략 됨).</target>
        </trans-unit>
        <trans-unit id="18d247bf08e46b2d89a403ce14a86d7b99503646" translate="yes" xml:space="preserve">
          <source>The complete message in a commit and tag object is &lt;code&gt;contents&lt;/code&gt;. Its first line is &lt;code&gt;contents:subject&lt;/code&gt;, where subject is the concatenation of all lines of the commit message up to the first blank line. The next line is &lt;code&gt;contents:body&lt;/code&gt;, where body is all of the lines after the first blank line. The optional GPG signature is &lt;code&gt;contents:signature&lt;/code&gt;. The first &lt;code&gt;N&lt;/code&gt; lines of the message is obtained using &lt;code&gt;contents:lines=N&lt;/code&gt;. Additionally, the trailers as interpreted by &lt;a href=&quot;git-interpret-trailers&quot;&gt;git-interpret-trailers[1]&lt;/a&gt; are obtained as &lt;code&gt;trailers&lt;/code&gt; (or by using the historical alias &lt;code&gt;contents:trailers&lt;/code&gt;). Non-trailer lines from the trailer block can be omitted with &lt;code&gt;trailers:only&lt;/code&gt;. Whitespace-continuations can be removed from trailers so that each trailer appears on a line by itself with its full content with &lt;code&gt;trailers:unfold&lt;/code&gt;. Both can be used together as &lt;code&gt;trailers:unfold,only&lt;/code&gt;.</source>
          <target state="translated">커밋 및 태그 객체의 전체 메시지는 &lt;code&gt;contents&lt;/code&gt; 입니다. 첫 번째 행은 &lt;code&gt;contents:subject&lt;/code&gt; 입니다 . 여기서 subject는 커밋 메시지의 모든 행을 첫 번째 빈 행으로 연결합니다. 다음 줄은 &lt;code&gt;contents:body&lt;/code&gt; 입니다 . 여기서 body는 첫 번째 빈 줄 다음의 모든 줄입니다. 선택적인 GPG 서명은 &lt;code&gt;contents:signature&lt;/code&gt; 입니다. 메시지 의 첫 &lt;code&gt;N&lt;/code&gt; 줄은 &lt;code&gt;contents:lines=N&lt;/code&gt; 을 사용하여 얻습니다 . 또한, &lt;a href=&quot;git-interpret-trailers&quot;&gt;git-interpret-trailers [1]에&lt;/a&gt; 의해 해석 된 트레일러 는 &lt;code&gt;trailers&lt;/code&gt; (또는 역사적인 별명 &lt;code&gt;contents:trailers&lt;/code&gt; 을 사용하여 트레일러) 로 얻습니다 .). 트레일러 블록의 비 트레일러 라인은 &lt;code&gt;trailers:only&lt;/code&gt; 로 생략 할 수 있습니다 . 각 트레일러와의 전체 내용으로 한 줄에 단독으로 나타나도록 공백-연속성을 트레일러에서 제거 할 수 있습니다 &lt;code&gt;trailers:unfold&lt;/code&gt; . 둘 다 &lt;code&gt;trailers:unfold,only&lt;/code&gt; 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0cfefd9783776d68186cc88921bf5543257f8ee9" translate="yes" xml:space="preserve">
          <source>The complete series produces the same end result as your own (probably much messier!) development process did.</source>
          <target state="translated">전체 시리즈는 자신의 (아마도 더 지저분한) 개발 프로세스와 동일한 최종 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="94ed81b46eb91e159691e77d6f1f3c669ea0f93b" translate="yes" xml:space="preserve">
          <source>The condition starts with a keyword followed by a colon and some data whose format and meaning depends on the keyword. Supported keywords are:</source>
          <target state="translated">조건은 키워드로 시작하고 콜론과 형식 및 의미에 따라 일부 데이터가 키워드에 따라 달라집니다. 지원되는 키워드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b796e8b15faa41177d638a7b320c951a662a1b91" translate="yes" xml:space="preserve">
          <source>The config settings that start with &lt;code&gt;feature.&lt;/code&gt; modify the defaults of a group of other config settings. These groups are created by the Git developer community as recommended defaults and are subject to change. In particular, new config options may be added with different defaults.</source>
          <target state="translated">&lt;code&gt;feature.&lt;/code&gt; 시작하는 구성 설정입니다 . 다른 구성 설정 그룹의 기본값을 수정하십시오. 이 그룹은 Git 개발자 커뮤니티에서 권장되는 기본값으로 생성되며 변경 될 수 있습니다. 특히 새로운 구성 옵션이 다른 기본값으로 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fd18e355006d4a8cb0ab9547d6ae9db29a772ac" translate="yes" xml:space="preserve">
          <source>The config variable &lt;code&gt;ssh.variant&lt;/code&gt; can be set to override this detection. Valid values are &lt;code&gt;ssh&lt;/code&gt; (to use OpenSSH options), &lt;code&gt;plink&lt;/code&gt;, &lt;code&gt;putty&lt;/code&gt;, &lt;code&gt;tortoiseplink&lt;/code&gt;, &lt;code&gt;simple&lt;/code&gt; (no options except the host and remote command). The default auto-detection can be explicitly requested using the value &lt;code&gt;auto&lt;/code&gt;. Any other value is treated as &lt;code&gt;ssh&lt;/code&gt;. This setting can also be overridden via the environment variable &lt;code&gt;GIT_SSH_VARIANT&lt;/code&gt;.</source>
          <target state="translated">구성 변수 &lt;code&gt;ssh.variant&lt;/code&gt; 는이 탐지를 무시하도록 설정할 수 있습니다. 유효한 값은 &lt;code&gt;ssh&lt;/code&gt; (OpenSSH 옵션 사용), &lt;code&gt;plink&lt;/code&gt; , &lt;code&gt;putty&lt;/code&gt; , &lt;code&gt;tortoiseplink&lt;/code&gt; , &lt;code&gt;simple&lt;/code&gt; (호스트 및 원격 명령을 제외한 옵션은 없음)입니다. 기본 자동 감지 기능은 명시 적으로 값을 사용하여 요청 할 수 있습니다 &lt;code&gt;auto&lt;/code&gt; . 다른 값은 &lt;code&gt;ssh&lt;/code&gt; 로 취급됩니다 . 이 설정은 환경 변수 &lt;code&gt;GIT_SSH_VARIANT&lt;/code&gt; 를 통해 무시할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82dcb1f42fdd78b7a73229a297c6923dd8af63df" translate="yes" xml:space="preserve">
          <source>The configuration file &lt;code&gt;$GIT_DIR/config&lt;/code&gt; in the superproject. Git only recurses into active submodules (see &quot;ACTIVE SUBMODULES&quot; section below).</source>
          <target state="translated">수퍼 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 의 구성 파일 $ GIT_DIR / config . 힘내는 활성 하위 모듈로만 되풀이됩니다 (아래의 &quot;활성 하위 모듈&quot;섹션 참조).</target>
        </trans-unit>
        <trans-unit id="774734ca6d9570e50bffe1b21770dfa34405f67a" translate="yes" xml:space="preserve">
          <source>The configuration file is used to override the default settings that were built into gitweb at the time the &lt;code&gt;gitweb.cgi&lt;/code&gt; script was generated.</source>
          <target state="translated">구성 파일은 &lt;code&gt;gitweb.cgi&lt;/code&gt; 스크립트가 생성 될 때 gitweb에 내장 된 기본 설정을 재정의하는 데 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="b47107ae705aecdb184ade3561dff30a01436bf4" translate="yes" xml:space="preserve">
          <source>The configuration inside the submodule. This includes &lt;code&gt;$GIT_DIR/config&lt;/code&gt; in the submodule, but also settings in the tree such as a &lt;code&gt;.gitattributes&lt;/code&gt; or &lt;code&gt;.gitignore&lt;/code&gt; files that specify behavior of commands inside the submodule.</source>
          <target state="translated">서브 모듈 내부의 구성. 여기에는 서브 모듈에 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 가 포함 되지만 서브 모듈 내부의 명령 동작을 지정 하는 &lt;code&gt;.gitattributes&lt;/code&gt; 또는 &lt;code&gt;.gitignore&lt;/code&gt; 파일 과 같은 트리의 설정도 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f6d6d393008f1bcb3935ac97c688c0c97bcd837" translate="yes" xml:space="preserve">
          <source>The configuration of submodules</source>
          <target state="translated">서브 모듈의 구성</target>
        </trans-unit>
        <trans-unit id="386a88f6456b2a92a88834767dd0b8e7846f5609" translate="yes" xml:space="preserve">
          <source>The configuration variables &lt;code&gt;$projects_list_group_categories&lt;/code&gt; and &lt;code&gt;$project_list_default_category&lt;/code&gt; are described in &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;</source>
          <target state="translated">구성 변수 &lt;code&gt;$projects_list_group_categories&lt;/code&gt; 및 &lt;code&gt;$project_list_default_category&lt;/code&gt; 는 &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7bf08d06e6b6627f964eab6068d66314f0702240" translate="yes" xml:space="preserve">
          <source>The configuration variables are used by both the Git plumbing and the porcelains. The variables are divided into sections, wherein the fully qualified variable name of the variable itself is the last dot-separated segment and the section name is everything before the last dot. The variable names are case-insensitive, allow only alphanumeric characters and &lt;code&gt;-&lt;/code&gt;, and must start with an alphabetic character. Some variables may appear multiple times; we say then that the variable is multivalued.</source>
          <target state="translated">구성 변수는 Git 배관과 도자기 모두에서 사용됩니다. 변수는 섹션으로 나뉩니다. 여기서 변수 자체의 정규화 된 변수 이름은 마지막 점으로 구분 된 세그먼트이고 섹션 이름은 마지막 점 이전의 모든 것입니다. 변수 이름은 대소 문자를 구분하지 않으며 영숫자 및 &lt;code&gt;-&lt;/code&gt; 만 허용하며 알파벳 문자로 시작해야합니다. 일부 변수는 여러 번 나타날 수 있습니다. 그런 다음 변수가 다중 값이라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="9ba005fddfd40c1aca4a3afcc24f0bfe0be0d141" translate="yes" xml:space="preserve">
          <source>The configuration variables described below configure some of gitweb links: their target and their look (text or image), and where to find page prerequisites (stylesheet, favicon, images, scripts). Usually they are left at their default values, with the possible exception of &lt;code&gt;@stylesheets&lt;/code&gt; variable.</source>
          <target state="translated">아래에 설명 된 구성 변수는 대상 및 모양 (텍스트 또는 이미지) 및 페이지 전제 조건 (스타일 시트, 즐겨 찾기 아이콘, 이미지, 스크립트)을 찾을 수있는 gitweb 링크의 일부를 구성합니다. 일반적으로 &lt;code&gt;@stylesheets&lt;/code&gt; 변수를 제외하고 기본값으로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="352cabf788111a2af3c96521f974380812252a38" translate="yes" xml:space="preserve">
          <source>The configuration variables described below control how gitweb finds Git repositories, and how repositories are displayed and accessed.</source>
          <target state="translated">아래 설명 된 구성 변수는 gitweb이 Git 리포지토리를 찾는 방법과 리포지토리가 표시되고 액세스되는 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="3f43fd6b4f50ff73ead39001e9e7b24eaf91129d" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;@{-&amp;lt;n&amp;gt;}&lt;/code&gt; means the &amp;lt;n&amp;gt;th branch/commit checked out before the current one.</source>
          <target state="translated">구문 &lt;code&gt;@{-&amp;lt;n&amp;gt;}&lt;/code&gt; 은 현재 분기 전에 체크 아웃 된 &amp;lt;n&amp;gt; 분기 / 커밋을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="532c17d263ea0447251201d507a716aaf6f28f2e" translate="yes" xml:space="preserve">
          <source>The content to be committed can be specified in several ways:</source>
          <target state="translated">커밋 할 내용은 여러 가지 방법으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3c1db69a05b050bddfd156a5df9e51b55df4af8" translate="yes" xml:space="preserve">
          <source>The contents of the actual line is output after the above header, prefixed by a TAB. This is to allow adding more header elements later.</source>
          <target state="translated">실제 행의 내용은 TAB 접두사가 붙은 위의 헤더 다음에 출력됩니다. 나중에 더 많은 헤더 요소를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07ff8c430a66890255703acd59c46fb9590b9dc8" translate="yes" xml:space="preserve">
          <source>The contents of the blob objects are uninterpreted sequences of bytes. There is no encoding translation at the core level.</source>
          <target state="translated">Blob 객체의 내용은 해석되지 않은 바이트 시퀀스입니다. 핵심 수준에는 인코딩 변환이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b5efb2fc6b2c2f5d21112887ebec33fa1322cd1" translate="yes" xml:space="preserve">
          <source>The contents of the included file are inserted immediately, as if they had been found at the location of the include directive. If the value of the variable is a relative path, the path is considered to be relative to the configuration file in which the include directive was found. See below for examples.</source>
          <target state="translated">포함 지시문의 위치에서 찾은 것처럼 포함 된 파일의 내용이 즉시 삽입됩니다. 변수 값이 상대 경로 인 경우 경로는 include 지시문이 발견 된 구성 파일에 상대적인 것으로 간주됩니다. 예는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8e2acace54c1bc95e05b068c1615156bf7369b0d" translate="yes" xml:space="preserve">
          <source>The core Git is often called &quot;plumbing&quot;, with the prettier user interfaces on top of it called &quot;porcelain&quot;. You may not want to use the plumbing directly very often, but it can be good to know what the plumbing does when the porcelain isn&amp;rsquo;t flushing.</source>
          <target state="translated">핵심 Git은 종종 &quot;배관 (Plumbing)&quot;으로 불리며, 그 위에 &quot;포세린 (porcelain)&quot;이라는 더 아름다운 사용자 인터페이스가 있습니다. 배관을 자주 직접 사용하고 싶지 않을 수도 있지만, 도자기가 플러시되지 않을 때 배관이 무엇을하는지 아는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bdff9728a51893f686262a6a471251953f8ca49c" translate="yes" xml:space="preserve">
          <source>The core.multiPackIndex config setting must be on to consume MIDX files.</source>
          <target state="translated">MIDX 파일을 사용하려면 core.multiPackIndex 구성 설정이 켜져 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4fd34d18ba310e6b91e875c3fcf517fe13b68829" translate="yes" xml:space="preserve">
          <source>The cost matrix is populated thusly: for each pair of commits, both diffs are generated and the &quot;diff of diffs&quot; is generated, with 3 context lines, then the number of lines in that diff is used as cost.</source>
          <target state="translated">비용 매트릭스는 이렇게 채워집니다. 각 커밋 쌍에 대해 두 개의 diff가 생성되고 &quot;diff of diffs&quot;가 3 개의 컨텍스트 라인으로 생성 된 다음 해당 diff의 라인 수가 비용으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="588bd7a488f6b8b596aae7dca46a3809b4412eb0" translate="yes" xml:space="preserve">
          <source>The cost of an edge &lt;code&gt;o--C&lt;/code&gt; is the size of &lt;code&gt;C&lt;/code&gt;'s diff, modified by a fudge factor that should be smaller than 100%. The cost of an edge &lt;code&gt;o--o&lt;/code&gt; is free. The fudge factor is necessary because even if &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; have nothing in common, they may still share a few empty lines and such, possibly making the assignment &lt;code&gt;1--C&lt;/code&gt;, &lt;code&gt;o--o&lt;/code&gt; slightly cheaper than &lt;code&gt;1--o&lt;/code&gt;, &lt;code&gt;o--C&lt;/code&gt; even if &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; have nothing in common. With the fudge factor we require a much larger common part to consider patches as corresponding.</source>
          <target state="translated">모서리 &lt;code&gt;o--C&lt;/code&gt; 의 비용은 &lt;code&gt;C&lt;/code&gt; 의 diff 크기이며 퍼지 팩터로 수정하여 100 %보다 작아야합니다. 가장자리의 비용 &lt;code&gt;o--o&lt;/code&gt; 무료입니다. 퍼지 팩터는 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;C&lt;/code&gt; 에 공통점이없는 경우에도 여전히 몇 개의 빈 줄을 공유 할 수 있으므로 &lt;code&gt;1--C&lt;/code&gt; , &lt;code&gt;o--o&lt;/code&gt; 는 &lt;code&gt;1--o&lt;/code&gt; , &lt;code&gt;o--C&lt;/code&gt; 보다 약간 저렴합니다. &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;C&lt;/code&gt; 에 공통점이없는 경우에도 -C . 퍼지 계수를 사용하면 패치를 해당하는 것으로 간주하기 위해 훨씬 큰 공통 부분이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4d1179f527fe5d2769266ab8147ad92b0a56c021" translate="yes" xml:space="preserve">
          <source>The credential is split into a set of named attributes, with one attribute per line. Each attribute is specified by a key-value pair, separated by an &lt;code&gt;=&lt;/code&gt; (equals) sign, followed by a newline.</source>
          <target state="translated">The credential is split into a set of named attributes, with one attribute per line. Each attribute is specified by a key-value pair, separated by an &lt;code&gt;=&lt;/code&gt; (equals) sign, followed by a newline.</target>
        </trans-unit>
        <trans-unit id="1995b336f91a29b5d0cf1cb6bf6d7c2407fa802c" translate="yes" xml:space="preserve">
          <source>The credential is split into a set of named attributes, with one attribute per line. Each attribute is specified by a key-value pair, separated by an &lt;code&gt;=&lt;/code&gt; (equals) sign, followed by a newline. The key may contain any bytes except &lt;code&gt;=&lt;/code&gt;, newline, or NUL. The value may contain any bytes except newline or NUL. In both cases, all bytes are treated as-is (i.e., there is no quoting, and one cannot transmit a value with newline or NUL in it). The list of attributes is terminated by a blank line or end-of-file. Git understands the following attributes:</source>
          <target state="translated">자격 증명은 한 줄에 하나의 속성이있는 명명 된 속성 집합으로 분할됩니다. 각 속성은 키-값 쌍으로 지정되며 &lt;code&gt;=&lt;/code&gt; (등호) 기호로 구분되고 줄 바꿈이 뒤 따릅니다. 키에는 &lt;code&gt;=&lt;/code&gt; , 개행 또는 NUL을 제외한 모든 바이트가 포함될 수 있습니다 . 값은 개행 또는 NUL을 제외한 모든 바이트를 포함 할 수 있습니다. 두 경우 모두, 모든 바이트는있는 그대로 처리됩니다 (즉, 인용 부호가없고 그 안에 개행 문자 나 NUL이있는 값을 전송할 수 없습니다). 속성 목록은 빈 줄 또는 파일 끝으로 종료됩니다. Git은 다음 속성을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="332163de0b53725f6a8fdbb5dfbee2d72f5e952f" translate="yes" xml:space="preserve">
          <source>The credential&amp;rsquo;s password, if we are asking it to be stored.</source>
          <target state="translated">자격 증명 암호 (저장하도록 요청하는 경우)</target>
        </trans-unit>
        <trans-unit id="b2af82f2f4002bb109eae365a3025f169b56089c" translate="yes" xml:space="preserve">
          <source>The credential&amp;rsquo;s username, if we already have one (e.g., from a URL, from the user, or from a previously run helper).</source>
          <target state="translated">자격 증명의 사용자 이름 (예 : URL, 사용자 또는 이전에 실행 한 도우미)이 이미있는 경우</target>
        </trans-unit>
        <trans-unit id="4208e146b9bfac727faabb9820edc29c027631a0" translate="yes" xml:space="preserve">
          <source>The credential&amp;rsquo;s username, if we already have one (e.g., from a URL, the configuration, the user, or from a previously run helper).</source>
          <target state="translated">The credential&amp;rsquo;s username, if we already have one (e.g., from a URL, the configuration, the user, or from a previously run helper).</target>
        </trans-unit>
        <trans-unit id="327d8af868005c380ff04a569542ec1ad381deca" translate="yes" xml:space="preserve">
          <source>The current &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;. In more detail: Your &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; is normally derived from the state of the tree referred to by HEAD. HEAD is a reference to one of the &lt;a href=&quot;#def_head&quot;&gt;heads&lt;/a&gt; in your repository, except when using a &lt;a href=&quot;#def_detached_HEAD&quot;&gt;detached HEAD&lt;/a&gt;, in which case it directly references an arbitrary commit.</source>
          <target state="translated">현재 &lt;a href=&quot;#def_branch&quot;&gt;지점&lt;/a&gt; . 더 자세하게 : &lt;a href=&quot;#def_working_tree&quot;&gt;작업 트리는&lt;/a&gt; 일반적으로 HEAD가 참조하는 트리의 상태에서 파생됩니다. HEAD는 &lt;a href=&quot;#def_detached_HEAD&quot;&gt;분리 된 HEAD를&lt;/a&gt; 사용하는 경우를 제외하고 저장소 의 &lt;a href=&quot;#def_head&quot;&gt;헤드&lt;/a&gt; 중 하나에 대한 참조 이며,이 경우 임의 커밋을 직접 참조합니다.</target>
        </trans-unit>
        <trans-unit id="6a22129f9e2c1c598b41ac7718060a19c57ba2df" translate="yes" xml:space="preserve">
          <source>The current branch and &lt;code&gt;HEAD&lt;/code&gt; pointer stay at the last commit successfully made.</source>
          <target state="translated">현재 브랜치 및 &lt;code&gt;HEAD&lt;/code&gt; 포인터는 마지막으로 커밋 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0f49d1c21e2564ca60f22933641a619ec1965bd6" translate="yes" xml:space="preserve">
          <source>The current branch is reset to &amp;lt;upstream&amp;gt;, or &amp;lt;newbase&amp;gt; if the --onto option was supplied. This has the exact same effect as &lt;code&gt;git reset --hard &amp;lt;upstream&amp;gt;&lt;/code&gt; (or &amp;lt;newbase&amp;gt;). ORIG_HEAD is set to point at the tip of the branch before the reset.</source>
          <target state="translated">--onto 옵션이 제공된 경우 현재 분기는 &amp;lt;upstream&amp;gt; 또는 &amp;lt;newbase&amp;gt;로 재설정됩니다. 이것은 &lt;code&gt;git reset --hard &amp;lt;upstream&amp;gt;&lt;/code&gt; (또는 &amp;lt;newbase&amp;gt;) 와 동일한 효과를 갖습니다. ORIG_HEAD는 재설정 전 분기의 끝을 가리 키도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="485fe33a04a6d00e71aec5bce139a108011107ac" translate="yes" xml:space="preserve">
          <source>The current command-line parameters used for each variant are as follows:</source>
          <target state="translated">각 변형에 사용되는 현재 명령 줄 매개 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f1d20a076d93bfe14eb345a4d54fe76b72904bc4" translate="yes" xml:space="preserve">
          <source>The current index and work tree is derived from $H, but the user may have local changes in them since $H.</source>
          <target state="translated">현재 색인 및 작업 트리는 $ H에서 파생되지만 사용자는 $ H 이후로 로컬 변경이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bc299cda3bedfdcbabc4a6883d29c81bf74d5df" translate="yes" xml:space="preserve">
          <source>The current index file for the repository. It is usually not found in a bare repository.</source>
          <target state="translated">저장소의 현재 색인 파일 일반적으로 베어 저장소에는 없습니다.</target>
        </trans-unit>
        <trans-unit id="6561295b83003ebae9a9c6ca19e06cdfe7bf9b70" translate="yes" xml:space="preserve">
          <source>The currently defined format versions are:</source>
          <target state="translated">현재 정의 된 형식 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66a8472981ef80b1cce56bd59cf5f4d97c11f9f9" translate="yes" xml:space="preserve">
          <source>The currently supported hooks are described below.</source>
          <target state="translated">현재 지원되는 후크는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8715361e5840de7b556e67eacf990927a206b328" translate="yes" xml:space="preserve">
          <source>The custom diff driver command. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">사용자 정의 diff 드라이버 명령 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1e530b24daf8e53e45f57000d6a6174670a1f6d2" translate="yes" xml:space="preserve">
          <source>The data content for the file has not been supplied yet. The frontend wants to supply it as part of this modify command.</source>
          <target state="translated">파일의 데이터 내용이 아직 제공되지 않았습니다. 프론트 엔드는이 수정 명령의 일부로이를 제공하려고합니다.</target>
        </trans-unit>
        <trans-unit id="f92713104ec45ad60b839fa902e6ffedd1e05a41" translate="yes" xml:space="preserve">
          <source>The data content for the file was already supplied by a prior &lt;code&gt;blob&lt;/code&gt; command. The frontend just needs to connect it.</source>
          <target state="translated">파일의 데이터 내용은 이미 이전 &lt;code&gt;blob&lt;/code&gt; 명령으로 제공되었습니다 . 프론트 엔드 만 연결하면됩니다.</target>
        </trans-unit>
        <trans-unit id="abeb69d3d4bae2cc1a5a16e58850f1c93c17369b" translate="yes" xml:space="preserve">
          <source>The data content for the note has not been supplied yet. The frontend wants to supply it as part of this modify command.</source>
          <target state="translated">메모의 데이터 내용이 아직 제공되지 않았습니다. 프론트 엔드는이 수정 명령의 일부로이를 제공하려고합니다.</target>
        </trans-unit>
        <trans-unit id="81c47d0a0bfa5328ac109608aa42a36ac0ca6a45" translate="yes" xml:space="preserve">
          <source>The data content for the note was already supplied by a prior &lt;code&gt;blob&lt;/code&gt; command. The frontend just needs to connect it to the commit that is to be annotated.</source>
          <target state="translated">노트의 데이터 컨텐츠는 이미 이전 &lt;code&gt;blob&lt;/code&gt; 명령으로 제공되었습니다 . 프론트 엔드는 주석을 달 수있는 커밋에 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="d1c68865b9a230a071410342b903f7a0e48271ba" translate="yes" xml:space="preserve">
          <source>The data that follows the keyword &lt;code&gt;gitdir:&lt;/code&gt; is used as a glob pattern. If the location of the .git directory matches the pattern, the include condition is met.</source>
          <target state="translated">키워드 &lt;code&gt;gitdir:&lt;/code&gt; 다음에 오는 데이터 는 glob 패턴으로 사용됩니다. .git 디렉토리의 위치가 패턴과 일치하면 포함 조건이 충족됩니다.</target>
        </trans-unit>
        <trans-unit id="c1597312d460a92e79d09c37c305ec85acdf7d09" translate="yes" xml:space="preserve">
          <source>The data that follows the keyword &lt;code&gt;onbranch:&lt;/code&gt; is taken to be a pattern with standard globbing wildcards and two additional ones, &lt;code&gt;**/&lt;/code&gt; and &lt;code&gt;/**&lt;/code&gt;, that can match multiple path components. If we are in a worktree where the name of the branch that is currently checked out matches the pattern, the include condition is met.</source>
          <target state="translated">&lt;code&gt;onbranch:&lt;/code&gt; 키워드 뒤에 오는 데이터는 표준 경로 지정 와일드 카드와 여러 경로 구성 요소와 일치 할 수있는 두 개의 추가 &lt;code&gt;**/&lt;/code&gt; 및 &lt;code&gt;/**&lt;/code&gt; 가있는 패턴으로 간주 됩니다. 현재 체크 아웃 된 분기 이름이 패턴과 일치하는 작업 트리에있는 경우 포함 조건이 충족됩니다.</target>
        </trans-unit>
        <trans-unit id="7c053d7b296d35ca64db938819dea858103dc6da" translate="yes" xml:space="preserve">
          <source>The data transfer of the packfile is always multiplexed, using the same semantics of the &lt;code&gt;side-band-64k&lt;/code&gt; capability from protocol version 1. This means that each packet, during the packfile data stream, is made up of a leading 4-byte pkt-line length (typical of the pkt-line format), followed by a 1-byte stream code, followed by the actual data.</source>
          <target state="translated">팩 파일의 데이터 전송은 항상 프로토콜 버전 1 의 &lt;code&gt;side-band-64k&lt;/code&gt; 기능 과 동일한 의미를 사용하여 멀티플렉싱됩니다 . 이는 팩 파일 데이터 스트림 동안 각 패킷이 선행 4 바이트 pkt- 행 길이 (일반적으로 pkt-line 형식), 1 바이트 스트림 코드, 실제 데이터가 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="c2900c14cd751c2ba06b33eb8d53cbdb905b94a4" translate="yes" xml:space="preserve">
          <source>The database cannot be reliably regenerated in a consistent form after the branch it is tracking has changed. Example: For merged branches, &lt;code&gt;git-cvsserver&lt;/code&gt; only tracks one branch of development, and after a &lt;code&gt;git merge&lt;/code&gt; an incrementally updated database may track a different branch than a database regenerated from scratch, causing inconsistent CVS revision numbers. &lt;code&gt;git-cvsserver&lt;/code&gt; has no way of knowing which branch it would have picked if it had been run incrementally pre-merge. So if you have to fully or partially (from old backup) regenerate the database, you should be suspicious of pre-existing CVS sandboxes.</source>
          <target state="translated">추적중인 분기가 변경된 후에는 데이터베이스를 일관된 형태로 안정적으로 재생성 할 수 없습니다. 예 : 병합 된 브랜치의 경우, &lt;code&gt;git-cvsserver&lt;/code&gt; 는 하나의 개발 브랜치 만 추적하며, &lt;code&gt;git merge&lt;/code&gt; 후 증분 업데이트 된 데이터베이스는 처음부터 다시 생성 된 데이터베이스와 다른 브랜치를 추적하여 CVS 개정 번호가 일치하지 않을 수 있습니다. &lt;code&gt;git-cvsserver&lt;/code&gt; 는 점진적으로 사전 병합 된 경우 어떤 분기를 선택했는지 알 방법이 없습니다. 따라서 (이전 백업에서) 데이터베이스를 완전히 또는 부분적으로 재생성해야하는 경우 기존 CVS 샌드 박스가 의심됩니다.</target>
        </trans-unit>
        <trans-unit id="44d2a77b29a1133933d2693560e181324cc0bf34" translate="yes" xml:space="preserve">
          <source>The database has an object whose hash doesn&amp;rsquo;t match the object database value. This indicates a serious data integrity problem.</source>
          <target state="translated">데이터베이스에 해시가 개체 데이터베이스 값과 일치하지 않는 개체가 있습니다. 이는 심각한 데이터 무결성 문제를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9944b3cc77c01bf0f8e3a227e6281fac295bdf59" translate="yes" xml:space="preserve">
          <source>The date used for the author identity when creating commit or tag objects, or when writing reflogs. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for valid formats.</source>
          <target state="translated">The date used for the author identity when creating commit or tag objects, or when writing reflogs. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for valid formats.</target>
        </trans-unit>
        <trans-unit id="ab2821bcf3a61c45db1fdab7123e1f2d0deeb254" translate="yes" xml:space="preserve">
          <source>The date used for the committer identity when creating commit or tag objects, or when writing reflogs. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for valid formats.</source>
          <target state="translated">The date used for the committer identity when creating commit or tag objects, or when writing reflogs. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for valid formats.</target>
        </trans-unit>
        <trans-unit id="28234e35fb4524e90d740d3154dc66c02cb1f7a2" translate="yes" xml:space="preserve">
          <source>The default &amp;lt;ref&amp;gt; is &quot;master&quot;.</source>
          <target state="translated">기본 &amp;lt;ref&amp;gt;는 &quot;master&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="c033f0ddddff0b7a496ef058316bfe1c29b59dcb" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; that is merged into the branch in question (or the branch in question is rebased onto). It is configured via branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge. If the upstream branch of 'A' is 'origin/B' sometimes we say &quot;'A' is tracking 'origin/B'&quot;.</source>
          <target state="translated">해당 &lt;a href=&quot;#def_branch&quot;&gt;브랜치&lt;/a&gt; 에 병합 된 기본 브랜치 (또는 해당 브랜치가 기반) branch. &amp;lt;name&amp;gt; .remote 및 branch. &amp;lt;name&amp;gt; .merge를 통해 구성됩니다. 'A'의 업스트림 분기가 'origin / B'인 경우 ''A '는'origin / B '를 추적합니다'라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="0e2c938aad423666052c9b862a31c7bd282b15cb" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; that is merged into the branch in question (or the branch in question is rebased onto). It is configured via branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge. If the upstream branch of &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;origin/B&lt;/code&gt; sometimes we say &quot;&lt;code&gt;A&lt;/code&gt; is tracking &lt;code&gt;origin/B&lt;/code&gt;&quot;.</source>
          <target state="translated">해당 &lt;a href=&quot;#def_branch&quot;&gt;브랜치&lt;/a&gt; 에 병합 된 기본 브랜치 (또는 해당 브랜치가 기반) branch. &amp;lt;name&amp;gt; .remote 및 branch. &amp;lt;name&amp;gt; .merge를 통해 구성됩니다. &lt;code&gt;A&lt;/code&gt; 의 업스트림 분기 가 &lt;code&gt;origin/B&lt;/code&gt; 경우 &quot; &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;origin/B&lt;/code&gt; 추적합니다 &quot;라고 말합니다 .</target>
        </trans-unit>
        <trans-unit id="2a57474834373f0012a2eee4dc03542456f6b683" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;applypatch-msg&lt;/code&gt; hook, when enabled, runs the &lt;code&gt;commit-msg&lt;/code&gt; hook, if the latter is enabled.</source>
          <target state="translated">활성화 된 경우 기본 &lt;code&gt;applypatch-msg&lt;/code&gt; 후크는 &lt;code&gt;commit-msg&lt;/code&gt; 후크를 실행 합니다 (후자가 활성화 된 경우).</target>
        </trans-unit>
        <trans-unit id="1004092b458b148233da1997202a081689268a8e" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;commit-msg&lt;/code&gt; hook, when enabled, detects duplicate &quot;Signed-off-by&quot; lines, and aborts the commit if one is found.</source>
          <target state="translated">사용 가능한 경우 기본 &lt;code&gt;commit-msg&lt;/code&gt; 훅은 중복 된 &quot;Signed-off-by&quot;라인을 감지하고 커밋이 발견되면 중단합니다.</target>
        </trans-unit>
        <trans-unit id="54e7a2ab7a7ead4c100931e31ff4408636c3868d" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;post-receive&lt;/code&gt; hook is empty, but there is a sample script &lt;code&gt;post-receive-email&lt;/code&gt; provided in the &lt;code&gt;contrib/hooks&lt;/code&gt; directory in Git distribution, which implements sending commit emails.</source>
          <target state="translated">기본 &lt;code&gt;post-receive&lt;/code&gt; 후크는 비어 있지만 Git 분배 의 &lt;code&gt;contrib/hooks&lt;/code&gt; 디렉토리에 샘플 스크립트 &lt;code&gt;post-receive-email&lt;/code&gt; 제공되어 커미트 이메일 전송을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a71e842d9eb90ca6731ba585809c1f8c19eb80f6" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-applypatch&lt;/code&gt; hook, when enabled, runs the &lt;code&gt;pre-commit&lt;/code&gt; hook, if the latter is enabled.</source>
          <target state="translated">활성화 된 기본 &lt;code&gt;pre-applypatch&lt;/code&gt; 후크는 &lt;code&gt;pre-commit&lt;/code&gt; 후크를 활성화합니다 (후자가 활성화 된 경우).</target>
        </trans-unit>
        <trans-unit id="b4266565542333c335464dc9285134a4a9b31011" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-commit&lt;/code&gt; hook, when enabled&amp;mdash;​and with the &lt;code&gt;hooks.allownonascii&lt;/code&gt; config option unset or set to false&amp;mdash;​prevents the use of non-ASCII filenames.</source>
          <target state="translated">활성화되어 있고 &lt;code&gt;hooks.allownonascii&lt;/code&gt; 구성 옵션이 설정되지 않았거나 false로 설정된 기본 &lt;code&gt;pre-commit&lt;/code&gt; 후크는 ASCII가 아닌 파일 이름을 사용하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="c591fe93d0021a0c7991225b1a062c31f35ddd16" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-commit&lt;/code&gt; hook, when enabled, catches introduction of lines with trailing whitespaces and aborts the commit when such a line is found.</source>
          <target state="translated">사용 가능한 경우 기본 &lt;code&gt;pre-commit&lt;/code&gt; 후크는 후행 공백이있는 라인의 도입을 포착하고 해당 라인이 발견되면 커미트를 중단합니다.</target>
        </trans-unit>
        <trans-unit id="5c24125124251d23fec260bbe8f20bf4ce1ae496" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-merge-commit&lt;/code&gt; hook, when enabled, runs the &lt;code&gt;pre-commit&lt;/code&gt; hook, if the latter is enabled.</source>
          <target state="translated">기본 &lt;code&gt;pre-merge-commit&lt;/code&gt; 후크 (사용 가능한 경우)는 &lt;code&gt;pre-commit&lt;/code&gt; 후크 ( 사용 가능한 경우)를 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="c0f0841a2790ebd8e4684a32dafde265e2735139" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;update&lt;/code&gt; hook, when enabled&amp;mdash;​and with &lt;code&gt;hooks.allowunannotated&lt;/code&gt; config option unset or set to false&amp;mdash;​prevents unannotated tags to be pushed.</source>
          <target state="translated">활성화되어 있고 &lt;code&gt;hooks.allowunannotated&lt;/code&gt; 구성 옵션이 설정되지 않았거나 false로 설정된 기본 &lt;code&gt;update&lt;/code&gt; 후크 는 주석이없는 태그가 푸시되는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="e99caaee535fa5770d85355802dd91eb002c650f" translate="yes" xml:space="preserve">
          <source>The default behavior of this command when no &amp;lt;refspec&amp;gt; is given can be configured by setting the &lt;code&gt;push&lt;/code&gt; option of the remote, or the &lt;code&gt;push.default&lt;/code&gt; configuration variable.</source>
          <target state="translated">&amp;lt;refspec&amp;gt;을 지정하지 않은 경우이 명령의 기본 동작은 리모콘 의 &lt;code&gt;push&lt;/code&gt; 옵션 또는 &lt;code&gt;push.default&lt;/code&gt; 구성 변수 를 설정하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04fb2222b71daf513a74198926f20b6eb1c65e53" translate="yes" xml:space="preserve">
          <source>The default can be changed by the &lt;code&gt;commit.cleanup&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;commit.cleanup&lt;/code&gt; 구성 변수에 의해 기본값을 변경할 수 있습니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6d2b951210087bf6a12979c879cea7654da192ce" translate="yes" xml:space="preserve">
          <source>The default can be changed using the status.showUntrackedFiles configuration variable documented in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">기본값은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]에&lt;/a&gt; 설명 된 status.showUntrackedFiles 구성 변수를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4804356dda86c0d39019920e2a204580a3348e0" translate="yes" xml:space="preserve">
          <source>The default configuration with no configuration file at all may work perfectly well for some installations. Still, a configuration file is useful for customizing or tweaking the behavior of gitweb in many ways, and some optional features will not be present unless explicitly enabled using the configurable &lt;code&gt;%features&lt;/code&gt; variable (see also &quot;Configuring gitweb features&quot; section below).</source>
          <target state="translated">구성 파일이 전혀없는 기본 구성은 일부 설치에서 완벽하게 작동 할 수 있습니다. 그래도 구성 파일은 여러 가지 방법으로 gitweb의 동작을 사용자 정의하거나 조정하는 데 유용하며 구성 가능한 &lt;code&gt;%features&lt;/code&gt; 변수를 사용하여 명시 적으로 활성화하지 않으면 일부 선택적 기능이 나타나지 않습니다 (아래 &quot;gitweb 기능 구성&quot;섹션 참조).</target>
        </trans-unit>
        <trans-unit id="ba35598baf99b4759b4ac8e8e152046ad84f4f70" translate="yes" xml:space="preserve">
          <source>The default destination is &lt;code&gt;syslog&lt;/code&gt; if &lt;code&gt;--inetd&lt;/code&gt; or &lt;code&gt;--detach&lt;/code&gt; is specified, otherwise &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--inetd&lt;/code&gt; 또는 &lt;code&gt;--detach&lt;/code&gt; 가 지정된 경우 기본 대상은 &lt;code&gt;syslog&lt;/code&gt; 이고 , 그렇지 않으면 &lt;code&gt;stderr&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="08a91820da4ab8ff0557091a83e78baf95e62cbc" translate="yes" xml:space="preserve">
          <source>The default development &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;. Whenever you create a Git &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;, a branch named &quot;master&quot; is created, and becomes the active branch. In most cases, this contains the local development, though that is purely by convention and is not required.</source>
          <target state="translated">기본 개발 &lt;a href=&quot;#def_branch&quot;&gt;지점&lt;/a&gt; . Git &lt;a href=&quot;#def_repository&quot;&gt;저장소&lt;/a&gt; 를 생성 할 때마다 &quot;master&quot;라는 브랜치가 생성되고 활성 브랜치가됩니다. 대부분의 경우 여기에는 로컬 개발이 포함되어 있지만 이는 순전히 규칙에 의한 것이며 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9cfb0587d78b80316db2bf990e0689e616d2c4e9" translate="yes" xml:space="preserve">
          <source>The default diff tool to use when &lt;code&gt;--gui&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;--gui&lt;/code&gt; 를 지정할 때 사용할 기본 diff 도구 입니다.</target>
        </trans-unit>
        <trans-unit id="2106f60990b064f5f08c291bb6d584e30eb4aef6" translate="yes" xml:space="preserve">
          <source>The default diff tool to use.</source>
          <target state="translated">사용할 기본 diff 도구입니다.</target>
        </trans-unit>
        <trans-unit id="ef7818a768aaedb1852c90af2f69c6d87d81a9be" translate="yes" xml:space="preserve">
          <source>The default for format-patch is to output a signature containing the Git version number. Use this variable to change that default. Set this variable to the empty string (&quot;&quot;) to suppress signature generation.</source>
          <target state="translated">format-patch의 기본값은 Git 버전 번호가 포함 된 서명을 출력하는 것입니다. 이 변수를 사용하여 해당 기본값을 변경하십시오. 서명 생성을 억제하려면이 변수를 빈 문자열 ( &quot;&quot;)로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="04f69f6bfbe685cc6892bfe73707b968c4b7e627" translate="yes" xml:space="preserve">
          <source>The default for format-patch is to output files with the &lt;code&gt;[PATCH]&lt;/code&gt; subject prefix. Use this variable to change that prefix.</source>
          <target state="translated">format-patch의 기본값은 &lt;code&gt;[PATCH]&lt;/code&gt; 제목 접두어로 파일을 출력하는 것입니다 . 이 변수를 사용하여 해당 접 두부를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="9305a301a407a477c0982cd809ad589540305e9b" translate="yes" xml:space="preserve">
          <source>The default for format-patch is to output files with the suffix &lt;code&gt;.patch&lt;/code&gt;. Use this variable to change that suffix (make sure to include the dot if you want it).</source>
          <target state="translated">format-patch의 기본값은 접미사가 &lt;code&gt;.patch&lt;/code&gt; 인 파일을 출력하는 것입니다 . 이 변수를 사용하여 해당 접미사를 변경하십시오 (원하는 경우 점을 포함 시키십시오).</target>
        </trans-unit>
        <trans-unit id="82f6ff06915abbfaa5bafadf3e71c6515eea8a49" translate="yes" xml:space="preserve">
          <source>The default for the patch directory is patches or the value of the &lt;code&gt;$QUILT_PATCHES&lt;/code&gt; environment variable.</source>
          <target state="translated">패치 디렉토리의 기본값은 패치 또는 &lt;code&gt;$QUILT_PATCHES&lt;/code&gt; 환경 변수 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="63e417c4ba57abb65259188be896bb91267bad84" translate="yes" xml:space="preserve">
          <source>The default for the series file is &amp;lt;patches&amp;gt;/series or the value of the &lt;code&gt;$QUILT_SERIES&lt;/code&gt; environment variable.</source>
          <target state="translated">시리즈 파일의 기본값은 &amp;lt;patches&amp;gt; / series 또는 &lt;code&gt;$QUILT_SERIES&lt;/code&gt; 환경 변수 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="43b413a4d69c795f1a4cc6e5069d43aa254cba9e" translate="yes" xml:space="preserve">
          <source>The default format does not show what the original said in the conflicting area. You cannot tell how many lines are deleted and replaced with Barbie&amp;rsquo;s remark on your side. The only thing you can tell is that your side wants to say it is hard and you&amp;rsquo;d prefer to go shopping, while the other side wants to claim it is easy.</source>
          <target state="translated">기본 형식은 충돌 영역에서 원본이 말한 내용을 표시하지 않습니다. 몇 줄이 삭제되고 바비의 말로 바뀔 수 있는지 알 수 없습니다. 당신이 말할 수있는 유일한 것은 당신의 측이 어렵다고 말하고 싶어하고 당신이 쇼핑하러 가고 싶어하는 반면, 다른 쪽은 쉽다고 주장하기를 원한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2c9ac4b5e02925d5a2242fa228d32b0af91d581b" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;--no-notes&lt;/code&gt;, unless the &lt;code&gt;format.notes&lt;/code&gt; configuration is set.</source>
          <target state="translated">&lt;code&gt;format.notes&lt;/code&gt; 구성이 설정되어 있지 않으면 기본값은 &lt;code&gt;--no-notes&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e210eb7dbec89858b8e72d64e2d379a9aada6a48" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;--no-thread&lt;/code&gt;, unless the &lt;code&gt;format.thread&lt;/code&gt; configuration is set. If &lt;code&gt;--thread&lt;/code&gt; is specified without a style, it defaults to the style specified by &lt;code&gt;format.thread&lt;/code&gt; if any, or else &lt;code&gt;shallow&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;format.thread&lt;/code&gt; 구성이 설정되어 있지 않으면 기본값은 &lt;code&gt;--no-thread&lt;/code&gt; 입니다. 경우 &lt;code&gt;--thread&lt;/code&gt; 는 스타일없이 지정에 의해 지정된 스타일을 기본값 &lt;code&gt;format.thread&lt;/code&gt; 있는 경우, 또는 다른 &lt;code&gt;shallow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9abe1131612b105426f13be17707662aa8662d23" translate="yes" xml:space="preserve">
          <source>The default is false, except &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; will probe and set core.ignoreCase true if appropriate when the repository is created.</source>
          <target state="translated">&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt; 이 저장소를 만들 때 적절한 경우 core.ignoreCase를 검사하고 true로 설정한다는 점을 제외하고 기본값은 false 입니다.</target>
        </trans-unit>
        <trans-unit id="fcf73b7882b6e3d265136d0071b137412decce56" translate="yes" xml:space="preserve">
          <source>The default is not to print any annotation lines. If no number is given to &lt;code&gt;-n&lt;/code&gt;, only the first line is printed. If the tag is not annotated, the commit message is displayed instead.</source>
          <target state="translated">기본값은 주석 행을 인쇄하지 않는 것입니다. &lt;code&gt;-n&lt;/code&gt; 에 숫자가 제공되지 않으면 첫 번째 행만 인쇄됩니다. 태그에 주석을 달지 않으면 커밋 메시지가 대신 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="19baf950afb8f746e54b7299adf6fbd6966f659a" translate="yes" xml:space="preserve">
          <source>The default is to diff against our branch (-2) and the cleanly resolved paths. The option -0 can be given to omit diff output for unmerged entries and just show &quot;Unmerged&quot;.</source>
          <target state="translated">디폴트는 브랜치 (-2)와 깨끗하게 해결 된 경로와 다른 것입니다. 옵션 -0을 사용하면 병합되지 않은 항목에 대한 diff 출력을 생략하고 &quot;Unmerged&quot;만 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70f152ab57d660d365ae81763277f72b2d86f307" translate="yes" xml:space="preserve">
          <source>The default is true (when core.filemode is not specified in the config file).</source>
          <target state="translated">기본값은 true입니다 (config 파일에 core.filemode가 지정되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="03228e9bc81b32ffbccac2430f1d794dd7591d2a" translate="yes" xml:space="preserve">
          <source>The default is true, except &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; will probe and set core.symlinks false if appropriate when the repository is created.</source>
          <target state="translated">&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt; 이 리포지토리 생성시 적절한 경우 core.symlinks를 검사하고 설정하는 것을 제외하고 기본값은 true 입니다.</target>
        </trans-unit>
        <trans-unit id="72445c1104c1c11ef748913a9c6e570e5a73c947" translate="yes" xml:space="preserve">
          <source>The default location of the CVS checkout to use for the export.</source>
          <target state="translated">내보내기에 사용할 CVS 체크 아웃의 기본 위치입니다.</target>
        </trans-unit>
        <trans-unit id="116262510e324641581bf8e5fe54c44cc1ec58f5" translate="yes" xml:space="preserve">
          <source>The default merge strategy to use when pulling a single branch.</source>
          <target state="translated">단일 분기를 가져올 때 사용할 기본 병합 전략입니다.</target>
        </trans-unit>
        <trans-unit id="a808540aa8de08b00cb350dbc14ab54e33fa8faf" translate="yes" xml:space="preserve">
          <source>The default merge strategy to use when pulling multiple branches at once.</source>
          <target state="translated">한 번에 여러 분기를 가져올 때 사용할 기본 병합 전략입니다.</target>
        </trans-unit>
        <trans-unit id="e2e648395119cc70a2e9e998b6f3d4c60294fc12" translate="yes" xml:space="preserve">
          <source>The default mode for format-patch to determine which parts of the cover letter will be populated using the branch&amp;rsquo;s description. See the &lt;code&gt;--cover-from-description&lt;/code&gt; option in &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">분기의 설명을 사용하여 표지의 어떤 부분을 채울지 결정하는 format-patch의 기본 모드입니다. &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; 의 &lt;code&gt;--cover-from-description&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="063faead523251f77be0529092965c3429cc8003" translate="yes" xml:space="preserve">
          <source>The default module path for &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; to use instead of /usr/lib/apache2/modules. Only used if httpd is Apache.</source>
          <target state="translated">/ usr / lib / apache2 / modules 대신 &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt; 의 기본 모듈 경로 . httpd가 Apache 인 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="91f8aff2bf27bb7f60525104a4a75d78c7ffe52b" translate="yes" xml:space="preserve">
          <source>The default notes merge strategy is &quot;manual&quot;, which checks out conflicting notes in a special work tree for resolving notes conflicts (&lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt;), and instructs the user to resolve the conflicts in that work tree. When done, the user can either finalize the merge with &lt;code&gt;git notes merge --commit&lt;/code&gt;, or abort the merge with &lt;code&gt;git notes merge --abort&lt;/code&gt;.</source>
          <target state="translated">기본 메모 병합 전략은 &quot;수동&quot;으로, 메모 충돌 해결을 위해 특수 작업 트리에서 충돌하는 메모를 확인하고 ( &lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt; ) 해당 작업 트리에서 충돌을 해결하도록 사용자에게 지시합니다. 완료되면 사용자는 &lt;code&gt;git notes merge --commit&lt;/code&gt; 으로 병합을 완료하거나 git notes merge --abort로 병합을 중단 &lt;code&gt;git notes merge --abort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d49acb565d9b642605b0a997d7ebc3213ecdde25" translate="yes" xml:space="preserve">
          <source>The default pretty format for log/show/whatchanged command, See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;.</source>
          <target state="translated">log / show / whatchanged 명령의 기본 pretty 형식은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; , &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c642123af45071133c151f29614b42c5bfc1ffac" translate="yes" xml:space="preserve">
          <source>The default program to execute on the remote side when fetching. See option --upload-pack of &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt;.</source>
          <target state="translated">가져올 때 원격에서 실행할 기본 프로그램입니다. &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack [1]&lt;/a&gt; 의 --upload-pack 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02bc1378d0d05db5e7ff2ca7062e80f4098e5579" translate="yes" xml:space="preserve">
          <source>The default program to execute on the remote side when pushing. See option --receive-pack of &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">밀 때 원격에서 실행할 기본 프로그램입니다. &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 의 --receive-pack 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1520b8813a02e6817b17665a2200c8c1eb73489c" translate="yes" xml:space="preserve">
          <source>The default remote is the remote of the remote-tracking branch of the current branch. If no such remote-tracking branch exists or the HEAD is detached, &quot;origin&quot; is assumed to be the default remote. If the superproject doesn&amp;rsquo;t have a default remote configured the superproject is its own authoritative upstream and the current working directory is used instead.</source>
          <target state="translated">기본 원격은 현재 지점의 원격 추적 분기의 원격입니다. 이러한 원격 추적 분기가 없거나 HEAD가 분리 된 경우 &quot;원본&quot;이 기본 원격으로 간주됩니다. 수퍼 프로젝트에 기본 원격이 구성되어 있지 않은 경우 수퍼 프로젝트는 자체 권위있는 업스트림이며 현재 작업 디렉토리가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0d78370864f4fde80869e4efb080139612c8d161" translate="yes" xml:space="preserve">
          <source>The default set of &quot;refspec&quot; for &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;. See &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 의 기본 &quot;refspec&quot;세트 . &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e7461b63dbe3a9bd4be74e77260f6121d70becf" translate="yes" xml:space="preserve">
          <source>The default set of &quot;refspec&quot; for &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 의 기본 &quot;refspec&quot;세트 . &lt;a href=&quot;git-push&quot;&gt;git-push [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b1d55965a766c32086046542d13a0c5cafb5d20" translate="yes" xml:space="preserve">
          <source>The default set of branches for &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt;. See &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt; 의 기본 분기 세트입니다 . &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f8a6ecfdcb232e0e35afa31c75a9bb76e3ba014" translate="yes" xml:space="preserve">
          <source>The default template directory includes some directory structure, suggested &quot;exclude patterns&quot; (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;), and sample hook files.</source>
          <target state="translated">기본 템플리트 디렉토리에는 일부 디렉토리 구조, 제안 된 &quot;제외 패턴&quot;( &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; 참조 ) 및 샘플 후크 파일이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5c5dda91be7317473d73b4f4f28156d762d8905f" translate="yes" xml:space="preserve">
          <source>The default threading style for &lt;code&gt;git format-patch&lt;/code&gt;. Can be a boolean value, or &lt;code&gt;shallow&lt;/code&gt; or &lt;code&gt;deep&lt;/code&gt;. &lt;code&gt;shallow&lt;/code&gt; threading makes every mail a reply to the head of the series, where the head is chosen from the cover letter, the &lt;code&gt;--in-reply-to&lt;/code&gt;, and the first patch mail, in this order. &lt;code&gt;deep&lt;/code&gt; threading makes every mail a reply to the previous one. A true boolean value is the same as &lt;code&gt;shallow&lt;/code&gt;, and a false value disables threading.</source>
          <target state="translated">&lt;code&gt;git format-patch&lt;/code&gt; 의 기본 스레딩 스타일입니다 . 부울 값이거나 &lt;code&gt;shallow&lt;/code&gt; 또는 &lt;code&gt;deep&lt;/code&gt; 일 수 있습니다 . &lt;code&gt;shallow&lt;/code&gt; 스레딩은 모든 메일을 시리즈의 헤드에 대한 회신으로 만듭니다. 여기서 헤드는 표지, &lt;code&gt;--in-reply-to&lt;/code&gt; 및 첫 번째 패치 메일에서이 순서대로 선택됩니다. &lt;code&gt;deep&lt;/code&gt; 스레딩은 모든 메일을 이전 메일에 대한 회신으로 만듭니다. true 부울 값은 &lt;code&gt;shallow&lt;/code&gt; 과 동일 하며 false 값은 스레딩을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="0eb7f832f6b33a6020eb8629fee287c4b15b4801" translate="yes" xml:space="preserve">
          <source>The default upstream &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. Most projects have at least one upstream project which they track. By default 'origin' is used for that purpose. New upstream updates will be fetched into &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;remote-tracking branches&lt;/a&gt; named origin/name-of-upstream-branch, which you can see using &lt;code&gt;git branch -r&lt;/code&gt;.</source>
          <target state="translated">기본 업스트림 &lt;a href=&quot;#def_repository&quot;&gt;저장소&lt;/a&gt; . 대부분의 프로젝트에는 추적 할 하나 이상의 업스트림 프로젝트가 있습니다. 기본적으로 'origin'이 해당 목적으로 사용됩니다. 새로운 업스트림 업데이트는 origin / name-of-upstream-branch라는 &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;원격 추적 분기&lt;/a&gt; 로 가져 &lt;code&gt;git branch -r&lt;/code&gt; 사용하여 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f838be44da45fd1828d0b46b391485ccd56187e" translate="yes" xml:space="preserve">
          <source>The default upstream &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. Most projects have at least one upstream project which they track. By default &lt;code&gt;origin&lt;/code&gt; is used for that purpose. New upstream updates will be fetched into &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;remote-tracking branches&lt;/a&gt; named origin/name-of-upstream-branch, which you can see using &lt;code&gt;git branch -r&lt;/code&gt;.</source>
          <target state="translated">기본 업스트림 &lt;a href=&quot;#def_repository&quot;&gt;저장소&lt;/a&gt; . 대부분의 프로젝트에는 추적 할 하나 이상의 업스트림 프로젝트가 있습니다. 기본적으로 해당 용도로 &lt;code&gt;origin&lt;/code&gt; 이 사용됩니다. 새로운 업스트림 업데이트는 origin / name-of-upstream-branch라는 &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;원격 추적 분기&lt;/a&gt; 로 가져 &lt;code&gt;git branch -r&lt;/code&gt; 사용하여 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66087a54aa582dff2f539d6f92ec2461ac3012fd" translate="yes" xml:space="preserve">
          <source>The default value for --window is 10 and --depth is 50. The maximum depth is 4095.</source>
          <target state="translated">--window의 기본값은 10이고 --depth는 50입니다. 최대 깊이는 4095입니다.</target>
        </trans-unit>
        <trans-unit id="90d3816cdd271ff4f563d74700f0c34c9ae7702c" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;$projectroot&lt;/code&gt; is &lt;code&gt;/pub/git&lt;/code&gt;. You can change it during building gitweb via &lt;code&gt;GITWEB_PROJECTROOT&lt;/code&gt; build configuration variable.</source>
          <target state="translated">&lt;code&gt;$projectroot&lt;/code&gt; 의 기본값 은 &lt;code&gt;/pub/git&lt;/code&gt; 입니다. &lt;code&gt;GITWEB_PROJECTROOT&lt;/code&gt; 빌드 구성 변수 를 통해 gitweb을 빌드 하는 동안이를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78bcbc1a976cbafa1db494161487aec966c7436d" translate="yes" xml:space="preserve">
          <source>The default value is either &lt;code&gt;static/gitweb.js&lt;/code&gt;, or &lt;code&gt;static/gitweb.min.js&lt;/code&gt; if the &lt;code&gt;JSMIN&lt;/code&gt; build variable was defined, i.e. if JavaScript minifier was used at build time. &lt;strong&gt;Note&lt;/strong&gt; that this single file is generated from multiple individual JavaScript &quot;modules&quot;.</source>
          <target state="translated">&lt;code&gt;JSMIN&lt;/code&gt; 빌드 변수가 정의 된 경우 (예 : 빌드시 JavaScript minifier가 사용 된 경우) 기본값은 &lt;code&gt;static/gitweb.js&lt;/code&gt; 또는 &lt;code&gt;static/gitweb.min.js&lt;/code&gt; 입니다. &lt;strong&gt;참고&lt;/strong&gt; 이 하나의 파일이 여러 개인 자바 스크립트 &quot;모듈&quot;에서 생성됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="88fcf9aad2af8490af6dabfabbb5732019a6c8e1" translate="yes" xml:space="preserve">
          <source>The default value of this variable is determined by the &lt;code&gt;GITWEB_LIST&lt;/code&gt; makefile variable at installation time. If this variable is empty, gitweb will fall back to scanning the &lt;code&gt;$projectroot&lt;/code&gt; directory for repositories.</source>
          <target state="translated">이 변수의 기본값 은 설치시 &lt;code&gt;GITWEB_LIST&lt;/code&gt; makefile 변수에 의해 결정됩니다 . 이 변수가 비어 있으면 gitweb은 &lt;code&gt;$projectroot&lt;/code&gt; 디렉토리에서 리포지토리 를 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="da622b41696b803144c5254aad9443c84211d515" translate="yes" xml:space="preserve">
          <source>The default value of this variable is determined by the build-time configuration variable &lt;code&gt;GITWEB_PROJECT_MAXDEPTH&lt;/code&gt;, which defaults to 2007.</source>
          <target state="translated">이 변수의 기본값은 빌드 시간 구성 변수 &lt;code&gt;GITWEB_PROJECT_MAXDEPTH&lt;/code&gt; 에 의해 결정되며 기본값은 2007입니다.</target>
        </trans-unit>
        <trans-unit id="777a0a86855d35a436d0a0e990f3b787a636cb43" translate="yes" xml:space="preserve">
          <source>The defined extensions are:</source>
          <target state="translated">정의 된 확장자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2309a4e043845fb6e7e786e69af3d5ed57221f3f" translate="yes" xml:space="preserve">
          <source>The definition of a diff driver is done in &lt;code&gt;gitconfig&lt;/code&gt;, not &lt;code&gt;gitattributes&lt;/code&gt; file, so strictly speaking this manual page is a wrong place to talk about it. However&amp;hellip;​</source>
          <target state="translated">diff 드라이버의 정의는 &lt;code&gt;gitattributes&lt;/code&gt; 파일이 아닌 &lt;code&gt;gitconfig&lt;/code&gt; 에서 수행 되므로이 매뉴얼 페이지를 엄격하게 말하면 잘못된 위치입니다. 그러나&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="05fbc211f0bbdc85a5cbba915fe02006f8119e9e" translate="yes" xml:space="preserve">
          <source>The definition of a merge driver is done in the &lt;code&gt;.git/config&lt;/code&gt; file, not in the &lt;code&gt;gitattributes&lt;/code&gt; file, so strictly speaking this manual page is a wrong place to talk about it. However&amp;hellip;​</source>
          <target state="translated">병합 드라이버의 정의는 &lt;code&gt;gitattributes&lt;/code&gt; 파일이 아닌 &lt;code&gt;.git/config&lt;/code&gt; 파일에서 수행 되므로이 매뉴얼 페이지를 엄격하게 말하면 잘못된 위치입니다. 그러나&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="096c7fcd9c9053c9edd8c72ca9c95b04e65c3409" translate="yes" xml:space="preserve">
          <source>The deletion removes the superproject&amp;rsquo;s tracking data, which are both the &lt;code&gt;gitlink&lt;/code&gt; entry and the section in the &lt;code&gt;.gitmodules&lt;/code&gt; file. The submodule&amp;rsquo;s working directory is removed from the file system, but the Git directory is kept around as it to make it possible to checkout past commits without requiring fetching from another repository.</source>
          <target state="translated">삭제하면 &lt;code&gt;gitlink&lt;/code&gt; 항목과 &lt;code&gt;.gitmodules&lt;/code&gt; 파일 의 섹션 인 수퍼 프로젝트의 추적 데이터가 제거 됩니다. 서브 모듈의 작업 디렉토리는 파일 시스템에서 제거되지만 Git 디렉토리는 다른 저장소에서 가져 오지 않고도 과거의 커밋을 체크 아웃 할 수 있도록 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="c4fe2a741691af413a8b078592b8e6a937844e84" translate="yes" xml:space="preserve">
          <source>The delta data is a sequence of instructions to reconstruct an object from the base object. If the base object is deltified, it must be converted to canonical form first. Each instruction appends more and more data to the target object until it&amp;rsquo;s complete. There are two supported instructions so far: one for copy a byte range from the source object and one for inserting new data embedded in the instruction itself.</source>
          <target state="translated">델타 데이터는 기본 객체에서 객체를 재구성하기위한 일련의 명령어입니다. 기본 개체가 deltified이면 먼저 정식 형식으로 변환해야합니다. 각 명령어는 완료 될 때까지 대상 객체에 더 많은 데이터를 추가합니다. 지금까지 지원되는 명령어는 소스 객체에서 바이트 범위를 복사하는 명령어와 명령어 자체에 포함 된 새 데이터를 삽입하는 명령어입니다.</target>
        </trans-unit>
        <trans-unit id="892bc72de2972bd5305c51b8962327a3cfb2518f" translate="yes" xml:space="preserve">
          <source>The depth parameter used in the delta compression algorithm used by &lt;code&gt;git gc --aggressive&lt;/code&gt;. This defaults to 50, which is the default for the &lt;code&gt;--depth&lt;/code&gt; option when &lt;code&gt;--aggressive&lt;/code&gt; isn&amp;rsquo;t in use.</source>
          <target state="translated">&lt;code&gt;git gc --aggressive&lt;/code&gt; 가 사용하는 델타 압축 알고리즘에 사용되는 깊이 매개 변수 입니다. 기본값은 50으로, &lt;code&gt;--aggressive&lt;/code&gt; 를 사용하지 않는 경우 &lt;code&gt;--depth&lt;/code&gt; 옵션 의 기본값입니다 .</target>
        </trans-unit>
        <trans-unit id="71588492154c20723b86643e523c1d2b33771cc9" translate="yes" xml:space="preserve">
          <source>The design of fast-import allows it to import large projects in a minimum amount of memory usage and processing time. Assuming the frontend is able to keep up with fast-import and feed it a constant stream of data, import times for projects holding 10+ years of history and containing 100,000+ individual commits are generally completed in just 1-2 hours on quite modest (~$2,000 USD) hardware.</source>
          <target state="translated">빠른 가져 오기의 설계를 통해 최소한의 메모리 사용 및 처리 시간으로 대규모 프로젝트를 가져올 수 있습니다. 프론트 엔드가 빠른 가져 오기를 유지하고 일정한 데이터 스트림을 제공 할 수 있다고 가정하면 10 년 이상의 역사를 유지하고 100,000 개 이상의 개별 커밋을 포함하는 프로젝트의 가져 오기 시간은 일반적으로 아주 완만 한 1-2 시간 안에 완료됩니다 ( ~ $ 2,000 USD) 하드웨어.</target>
        </trans-unit>
        <trans-unit id="cfd00b61765196c337cd6805a450f0ea641f8da0" translate="yes" xml:space="preserve">
          <source>The details of the credential will be provided on the helper&amp;rsquo;s stdin stream. The exact format is the same as the input/output format of the &lt;code&gt;git credential&lt;/code&gt; plumbing command (see the section &lt;code&gt;INPUT/OUTPUT
FORMAT&lt;/code&gt; in &lt;a href=&quot;git-credential&quot;&gt;git-credential[1]&lt;/a&gt; for a detailed specification).</source>
          <target state="translated">The details of the credential will be provided on the helper&amp;rsquo;s stdin stream. The exact format is the same as the input/output format of the &lt;code&gt;git credential&lt;/code&gt; plumbing command (see the section &lt;code&gt;INPUT/OUTPUT FORMAT&lt;/code&gt; in &lt;a href=&quot;git-credential&quot;&gt;git-credential[1]&lt;/a&gt; for a detailed specification).</target>
        </trans-unit>
        <trans-unit id="c420d947d2d5939e423cde725977f1dbb1cf946b" translate="yes" xml:space="preserve">
          <source>The developer might want to rebase those commits to a newer &lt;code&gt;master&lt;/code&gt; while keeping the branch topology, for example when the first topic branch is expected to be integrated into &lt;code&gt;master&lt;/code&gt; much earlier than the second one, say, to resolve merge conflicts with changes to the DownloadButton class that made it into &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">개발자는 새에 그 커밋을 리베이스 할 수 있습니다 &lt;code&gt;master&lt;/code&gt; 첫 번째 주제 분기가 통합 될 것으로 예상되는 경우, 예를 들어, 분기 토폴로지를 유지하면서 &lt;code&gt;master&lt;/code&gt; 훨씬 이전에 두 번째, 말보다 DownloadButton 변경으로 해결 병합 충돌, 그것을 &lt;code&gt;master&lt;/code&gt; 로 만든 클래스 .</target>
        </trans-unit>
        <trans-unit id="38adb1a4eb1052b4c27e8f4f4a52ae35ba0619ad" translate="yes" xml:space="preserve">
          <source>The diff above shows the differences between the working-tree version of file.txt and the stage 2 and stage 3 versions. So instead of preceding each line by a single &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, it now uses two columns: the first column is used for differences between the first parent and the working directory copy, and the second for differences between the second parent and the working directory copy. (See the &quot;COMBINED DIFF FORMAT&quot; section of &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt; for a details of the format.)</source>
          <target state="translated">위의 diff는 file.txt의 작업 트리 버전과 2 단계 및 3 단계 버전의 차이점을 보여줍니다. 따라서 각 행 앞에 단일 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 를 사용 하는 대신 이제 두 개의 열을 사용합니다. 첫 번째 열은 첫 번째 상위와 작업 디렉토리 사본의 차이점에 사용되고 두 번째 열은 두 번째 상위와 작업 디렉토리 사본의 차이점에 사용됩니다. . 형식 에 대한 자세한 내용은 &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1]&lt;/a&gt; 의 &quot;COMBINED DIFF FORMAT&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="330f16adb7b4cb162abae538c3471400c6f3dfa4" translate="yes" xml:space="preserve">
          <source>The diff commands &lt;code&gt;git diff-index&lt;/code&gt;, &lt;code&gt;git diff-files&lt;/code&gt;, and &lt;code&gt;git diff-tree&lt;/code&gt; can be told to manipulate differences they find in unconventional ways before showing &lt;code&gt;diff&lt;/code&gt; output. The manipulation is collectively called &quot;diffcore transformation&quot;. This short note describes what they are and how to use them to produce &lt;code&gt;diff&lt;/code&gt; output that is easier to understand than the conventional kind.</source>
          <target state="translated">diff 명령 &lt;code&gt;git diff-index&lt;/code&gt; , &lt;code&gt;git diff-files&lt;/code&gt; 및 &lt;code&gt;git diff-tree&lt;/code&gt; 는 &lt;code&gt;diff&lt;/code&gt; 출력을 표시하기 전에 기존 방식으로 발견 된 차이를 조작하도록 지시 할 수 있습니다 . 조작을 통칭하여 &quot;diffcore 변환&quot;이라고합니다. 이 짧은 노트 는 기존의 것보다 이해하기 쉬운 &lt;code&gt;diff&lt;/code&gt; 출력 을 생성하기 위해 그것들이 무엇인지 그리고 어떻게 사용하는지 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="4e50a3e21215031cd44c450ab91735643c2d6198" translate="yes" xml:space="preserve">
          <source>The diffcore mechanism is fed a list of such comparison results (each of which is called &quot;filepair&quot;, although at this point each of them talks about a single file), and transforms such a list into another list. There are currently 5 such transformations:</source>
          <target state="translated">diffcore 메커니즘에는 이러한 비교 결과 목록이 제공되며 (각각 &quot;단일 파일에 대해 말하지만&quot;파일 쌍 &quot;이라고 함) 이러한 목록을 다른 목록으로 변환합니다. 현재 5 가지의 그러한 변환이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5ccc68add0025f283e287a514f59373a91910067" translate="yes" xml:space="preserve">
          <source>The directory holding the sha1 objects is missing.</source>
          <target state="translated">sha1 오브젝트를 보유한 디렉토리가 누락되었습니다.</target>
        </trans-unit>
        <trans-unit id="3e56ce3070b6d1fe8bc11b5262f83540c8411c39" translate="yes" xml:space="preserve">
          <source>The directory to find the quilt patches.</source>
          <target state="translated">퀼트 패치를 찾을 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="0bb0f16c4fefb50922eb2b1990a8580cecff19f2" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is with:</source>
          <target state="translated">가장 쉬운 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="114ebd710b84299f5cb327f93e8be01e979eae23" translate="yes" xml:space="preserve">
          <source>The easy case</source>
          <target state="translated">쉬운 경우</target>
        </trans-unit>
        <trans-unit id="ae6685a0ed898fdf61a802d261028cc9079a0958" translate="yes" xml:space="preserve">
          <source>The editor used to edit the commit log message will be chosen from the &lt;code&gt;GIT_EDITOR&lt;/code&gt; environment variable, the core.editor configuration variable, the &lt;code&gt;VISUAL&lt;/code&gt; environment variable, or the &lt;code&gt;EDITOR&lt;/code&gt; environment variable (in that order). See &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt; for details.</source>
          <target state="translated">커밋 로그 메시지를 편집하는 데 사용되는 편집기는 &lt;code&gt;GIT_EDITOR&lt;/code&gt; 환경 변수, core.editor 구성 변수, &lt;code&gt;VISUAL&lt;/code&gt; 환경 변수 또는 &lt;code&gt;EDITOR&lt;/code&gt; 환경 변수 (순서대로)에서 선택됩니다. 자세한 내용은 &lt;a href=&quot;git-var&quot;&gt;git-var [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0e4dbd523803a96213d55b1fc234d8888f00a89f" translate="yes" xml:space="preserve">
          <source>The effect of the &lt;code&gt;git add&lt;/code&gt; was to add one entry to the index file:</source>
          <target state="translated">&lt;code&gt;git add&lt;/code&gt; 의 효과 는 인덱스 파일에 하나의 항목을 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8c668b981ec948c02063906a293d8a4332dec951" translate="yes" xml:space="preserve">
          <source>The effect of this is best shown by way of comparing to &lt;code&gt;--full-history&lt;/code&gt; with parent rewriting. The example turns into:</source>
          <target state="translated">이것의 효과는 부모 재 작성과 &lt;code&gt;--full-history&lt;/code&gt; 와 비교하여 가장 잘 나타납니다 . 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f01b79da1b24a8459870505ceabc7acd5dc253cb" translate="yes" xml:space="preserve">
          <source>The effective value of &quot;core.notesRef&quot; (possibly overridden by GIT_NOTES_REF) is also implicitly added to the list of refs to be displayed.</source>
          <target state="translated">&quot;core.notesRef&quot;의 유효 값 (GIT_NOTES_REF로 재정의 됨)도 표시 될 참조 목록에 내재적으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="47170c140110158e7cecc3842f11a773c4cf2ae7" translate="yes" xml:space="preserve">
          <source>The effects of this are mostly persistent, e.g. when packs and loose objects are coalesced into one another pack the existing deltas in that pack might get re-used, but there are also various cases where we might pick a sub-optimal delta from a newer pack instead.</source>
          <target state="translated">팩과 느슨한 객체가 서로 다른 팩으로 병합 될 때, 그 팩의 기존 델타가 재사용 될 수 있지만, 새로운 팩터에서 차선의 델타를 선택할 수있는 경우도 있습니다. 대신 팩.</target>
        </trans-unit>
        <trans-unit id="bf28d97f6ba9304b5153752f84c8628b03d2d10b" translate="yes" xml:space="preserve">
          <source>The email address used in the author and committer identities if no other relevant environment variable or configuration setting has been set.</source>
          <target state="translated">The email address used in the author and committer identities if no other relevant environment variable or configuration setting has been set.</target>
        </trans-unit>
        <trans-unit id="92e306fa99dcf31c1372828d693f49a0c8b3dc6a" translate="yes" xml:space="preserve">
          <source>The email address used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.email&lt;/code&gt; and &lt;code&gt;author.email&lt;/code&gt; configuration settings.</source>
          <target state="translated">The email address used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.email&lt;/code&gt; and &lt;code&gt;author.email&lt;/code&gt; configuration settings.</target>
        </trans-unit>
        <trans-unit id="7e46e2a5bb8fdd59d614c9b7aa9560522ab90daa" translate="yes" xml:space="preserve">
          <source>The email address used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.email&lt;/code&gt; and &lt;code&gt;committer.email&lt;/code&gt; configuration settings.</source>
          <target state="translated">The email address used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.email&lt;/code&gt; and &lt;code&gt;committer.email&lt;/code&gt; configuration settings.</target>
        </trans-unit>
        <trans-unit id="e05ce4cdee1f111bdf6e1a5c14e6220d9920c4e2" translate="yes" xml:space="preserve">
          <source>The equivalence test is based on the diff, after removing whitespace and line numbers. git-cherry therefore detects when commits have been &quot;copied&quot; by means of &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick[1]&lt;/a&gt;, &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; or &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">동등성 테스트는 공백과 줄 번호를 제거한 후 diff를 기준으로합니다. git-cherry는 커밋이 &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick [1]&lt;/a&gt; , &lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]에&lt;/a&gt; 의해 &quot;복사&quot;된시기를 감지 합니다.</target>
        </trans-unit>
        <trans-unit id="1c5c570f3616a5224dd6e91327ceb211453e9ddc" translate="yes" xml:space="preserve">
          <source>The error event may be emitted more than once. The format string allows post-processors to group errors by type without worrying about specific error arguments.</source>
          <target state="translated">오류 이벤트가 두 번 이상 발생할 수 있습니다. 형식 문자열을 사용하면 포스트 프로세서가 특정 오류 인수에 대한 걱정없이 유형별로 오류를 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c5c3dbbaebe5825bdfa9c22deed2d10f337e86e" translate="yes" xml:space="preserve">
          <source>The event format target is a JSON-based format of event data suitable for telemetry analysis. This format is enabled with the &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; environment variable or the &lt;code&gt;trace2.eventTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">이벤트 형식 대상은 원격 분석에 적합한 JSON 기반의 이벤트 데이터 형식입니다. 이 형식은 &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; 환경 변수 또는 &lt;code&gt;trace2.eventTarget&lt;/code&gt; 시스템 또는 글로벌 구성 설정으로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="bb53cc945a6f48ddfeb31dcd9983e9640d488cf9" translate="yes" xml:space="preserve">
          <source>The ever-versatile &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; command can also be used to examine tree objects, but &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt; will give you more details:</source>
          <target state="translated">다양한 기능을 갖춘 &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 명령을 사용하여 트리 객체를 검사 할 수도 있지만 &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]&lt;/a&gt; 은 다음과 같은 세부 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2cae5c144ae6a6f552f7dcee7bbaf0209258a3bd" translate="yes" xml:space="preserve">
          <source>The example configuration presented here is guaranteed to be backwards and forward compatible.</source>
          <target state="translated">여기에 제시된 예제 구성은 이전 버전과 이전 버전과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="77578078110fe9093d1036dd58aeebc2db7df1b8" translate="yes" xml:space="preserve">
          <source>The exit code from this hook invocation is ignored, however a non-zero exit code will generate an error message.</source>
          <target state="translated">이 후크 호출의 종료 코드는 무시되지만 0이 아닌 종료 코드는 오류 메시지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1e405cb397afa437170eea29059b03dcf97426f6" translate="yes" xml:space="preserve">
          <source>The exit code from this hook invocation is ignored; the only thing left for &lt;code&gt;git-receive-pack&lt;/code&gt; to do at that point is to exit itself anyway.</source>
          <target state="translated">이 후크 호출의 종료 코드는 무시됩니다. &lt;code&gt;git-receive-pack&lt;/code&gt; 이 그 시점에서해야 할 유일한 일은 어쨌든 자체를 종료하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5a81c04e486b5c66b0be7554a6e91773cfd1a9a9" translate="yes" xml:space="preserve">
          <source>The exit status determines whether git will use the data from the hook to limit its search. On error, it will fall back to verifying all files and folders.</source>
          <target state="translated">종료 상태는 git이 후크의 데이터를 사용하여 검색을 제한할지 여부를 결정합니다. 오류가 발생하면 모든 파일 및 폴더 확인으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="bfebe1cb22dde824ad5950ca41e165ed720dc31c" translate="yes" xml:space="preserve">
          <source>The exit status of the hook is ignored for any state except for the &quot;prepared&quot; state. In the &quot;prepared&quot; state, a non-zero exit status will cause the transaction to be aborted. The hook will not be called with &quot;aborted&quot; state in that case.</source>
          <target state="translated">The exit status of the hook is ignored for any state except for the &quot;prepared&quot; state. In the &quot;prepared&quot; state, a non-zero exit status will cause the transaction to be aborted. The hook will not be called with &quot;aborted&quot; state in that case.</target>
        </trans-unit>
        <trans-unit id="863cf74b97781c15eaa4bf39c81be105821817bd" translate="yes" xml:space="preserve">
          <source>The exit value of this program is negative on error, and the number of conflicts otherwise (truncated to 127 if there are more than that many conflicts). If the merge was clean, the exit value is 0.</source>
          <target state="translated">오류가 발생하면이 프로그램의 종료 값이 음수이고, 그렇지 않으면 충돌 수가 발생합니다 (충돌이 많은 경우 127로 잘림). 병합이 깨끗하면 종료 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="600e0ed5040d09634bf101b6adc431e3349d2258" translate="yes" xml:space="preserve">
          <source>The expected use case of this is to write supporting explanation for the commit that does not belong to the commit log message proper, and include it with the patch submission. While one can simply write these explanations after &lt;code&gt;format-patch&lt;/code&gt; has run but before sending, keeping them as Git notes allows them to be maintained between versions of the patch series (but see the discussion of the &lt;code&gt;notes.rewrite&lt;/code&gt; configuration options in &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; to use this workflow).</source>
          <target state="translated">예상되는 사용 사례는 커밋 로그 메시지에 속하지 않은 커밋에 대한 지원 설명을 작성하고 패치 제출에 포함시키는 것입니다. &lt;code&gt;format-patch&lt;/code&gt; 를 실행 한 후 , 보내기 전에 이러한 설명을 간단하게 작성할 수 있지만, Git 메모를 유지하면 패치 시리즈 버전간에 유지 관리 할 수 ​​있습니다 (하지만 &lt;code&gt;notes.rewrite&lt;/code&gt; 구성 옵션에 대한 설명은 &lt;a href=&quot;git-notes&quot;&gt;git-notes [ 1]&lt;/a&gt; 이 워크 플로를 사용합니다).</target>
        </trans-unit>
        <trans-unit id="7c7921a0c6ea4cec42a427f589011997d35e15f9" translate="yes" xml:space="preserve">
          <source>The external command can optionally write a single line to its standard output to be sent to the requestor as an error message when it declines the service.</source>
          <target state="translated">외부 명령은 선택적으로 서비스를 거부 할 때 요청자에게 오류 메시지로 전송되도록 단일 출력을 표준 출력에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34c4f9db557882c9df4177a31e00a543de8934c9" translate="yes" xml:space="preserve">
          <source>The extra &lt;code&gt;NUL&lt;/code&gt; before the preimage path in renamed case is to allow scripts that read the output to tell if the current record being read is a single-path record or a rename/copy record without reading ahead. After reading added and deleted lines, reading up to &lt;code&gt;NUL&lt;/code&gt; would yield the pathname, but if that is &lt;code&gt;NUL&lt;/code&gt;, the record will show two paths.</source>
          <target state="translated">이름이 바뀐 경우 사전 이미지 경로 앞 의 추가 &lt;code&gt;NUL&lt;/code&gt; 은 출력을 읽는 스크립트가 현재 읽고있는 레코드가 단일 경로 레코드인지 또는 미리 읽지 않고 이름 바꾸기 / 복사 레코드인지를 알리는 것입니다. 추가 및 삭제 된 행을 읽은 후 &lt;code&gt;NUL&lt;/code&gt; 까지 읽으면 경로 이름이 생성되지만 &lt;code&gt;NUL&lt;/code&gt; 인 경우 레코드에 두 개의 경로가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1b54438722ed3844a0702f9ed09c56d6aef28ee2" translate="yes" xml:space="preserve">
          <source>The fast-import backend itself can import into an empty repository (one that has already been initialized by &lt;code&gt;git init&lt;/code&gt;) or incrementally update an existing populated repository. Whether or not incremental imports are supported from a particular foreign source depends on the frontend program in use.</source>
          <target state="translated">빠른 가져 오기 백엔드 자체는 비어있는 저장소 ( &lt;code&gt;git init&lt;/code&gt; 로 이미 초기화 된 저장소 )로 가져 오거나 기존의 채워진 저장소를 증분 업데이트 할 수 있습니다. 특정 외부 소스에서 증분 가져 오기를 지원하는지 여부는 사용중인 프론트 엔드 프로그램에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3dfacf796b68e98a60c628fed43445479dc82ce1" translate="yes" xml:space="preserve">
          <source>The fast-import mechanism used by &lt;code&gt;git p4&lt;/code&gt; creates one pack file for each invocation of &lt;code&gt;git p4 sync&lt;/code&gt;. Normally, Git garbage compression (&lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;) automatically compresses these to fewer pack files, but explicit invocation of &lt;code&gt;git repack -adf&lt;/code&gt; may improve performance.</source>
          <target state="translated">&lt;code&gt;git p4&lt;/code&gt; 에서 사용하는 빠른 가져 오기 메커니즘 은 &lt;code&gt;git p4 sync&lt;/code&gt; 호출마다 하나의 팩 파일을 작성 합니다 . 일반적으로 Git 가비지 압축 ( &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt; ) &lt;code&gt;git repack -adf&lt;/code&gt; 파일을 더 적은 팩 파일로 자동 압축하지만 git repack -adf를 명시 적으로 호출 하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53e903dc94674f5b365dd31d16a6c2e334c714e3" translate="yes" xml:space="preserve">
          <source>The fetch and push protocols are not designed to prevent one side from stealing data from the other repository that was not intended to be shared. If you have private data that you need to protect from a malicious peer, your best option is to store it in another repository. This applies to both clients and servers. In particular, namespaces on a server are not effective for read access control; you should only grant read access to a namespace to clients that you would trust with read access to the entire repository.</source>
          <target state="translated">페치 및 푸시 프로토콜은 한 쪽이 공유하지 않을 다른 리포지토리의 데이터를 훔치지 않도록 설계되지 않았습니다. 악의적 인 피어로부터 보호해야하는 개인 데이터가있는 경우 가장 좋은 방법은 다른 리포지토리에 저장하는 것입니다. 이것은 클라이언트와 서버 모두에 적용됩니다. 특히 서버의 네임 스페이스는 읽기 액세스 제어에 효과적이지 않습니다. 전체 저장소에 대한 읽기 권한으로 신뢰할 수있는 클라이언트에게 네임 스페이스에 대한 읽기 권한 만 부여해야합니다.</target>
        </trans-unit>
        <trans-unit id="648bf821f46e9909499e1fbac0dd96a1ab871eb7" translate="yes" xml:space="preserve">
          <source>The fields (including the &lt;code&gt;-&amp;gt;&lt;/code&gt;) are separated from each other by a single space. If a filename contains whitespace or other nonprintable characters, that field will be quoted in the manner of a C string literal: surrounded by ASCII double quote (34) characters, and with interior special characters backslash-escaped.</source>
          <target state="translated">필드 ( &lt;code&gt;-&amp;gt;&lt;/code&gt; 포함 )는 단일 공백으로 구분됩니다. 파일 이름에 공백이나 인쇄 할 수없는 다른 문자가 포함 된 경우 해당 필드는 C 문자열 리터럴 방식으로 인용됩니다. ASCII 큰 따옴표 (34) 문자로 묶고 내부 특수 문자는 백 슬래시로 이스케이프 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3994e582754827987cb1dab035b29a73b90c4b3e" translate="yes" xml:space="preserve">
          <source>The file consists of sections and variables. A section begins with the name of the section in square brackets and continues until the next section begins. Section names are case-insensitive. Only alphanumeric characters, &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;.&lt;/code&gt; are allowed in section names. Each variable must belong to some section, which means that there must be a section header before the first setting of a variable.</source>
          <target state="translated">파일은 섹션과 변수로 구성됩니다. 섹션은 대괄호 안에 섹션 이름으로 시작하고 다음 섹션이 시작될 때까지 계속됩니다. 섹션 이름은 대소 문자를 구분하지 않습니다. 영숫자 만 &lt;code&gt;-&lt;/code&gt; 및 &lt;code&gt;.&lt;/code&gt; 섹션 이름에 허용됩니다. 각 변수는 일부 섹션에 속해야합니다. 즉, 변수의 첫 번째 설정 전에 섹션 헤더가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b77694751b662ffffe51a33dc2cd7f9b8be897f4" translate="yes" xml:space="preserve">
          <source>The file contains one subsection per submodule, and the subsection value is the name of the submodule. The name is set to the path where the submodule has been added unless it was customized with the &lt;code&gt;--name&lt;/code&gt; option of &lt;code&gt;git submodule add&lt;/code&gt;. Each submodule section also contains the following required keys:</source>
          <target state="translated">파일은 서브 모듈 당 하나의 서브 섹션을 포함하며 서브 섹션 값은 서브 모듈의 이름입니다. &lt;code&gt;git submodule add&lt;/code&gt; 의 &lt;code&gt;--name&lt;/code&gt; 옵션 으로 사용자 정의되지 않은 경우 이름은 서브 모듈이 추가 된 경로로 설정됩니다 . 각 하위 모듈 섹션에는 다음과 같은 필수 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7d8ebbce919f993c68a8bac80b9fbb16d92024e" translate="yes" xml:space="preserve">
          <source>The file format includes parameters for the object ID hash function, so a future change of hash algorithm does not require a change in format.</source>
          <target state="translated">파일 형식에는 오브젝트 ID 해시 함수에 대한 매개 변수가 포함되므로 향후 해시 알고리즘 변경시 형식 변경이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bb6e340dc566db02505e0c4003761a9d85c40c1" translate="yes" xml:space="preserve">
          <source>The file is concluded with a trailer:</source>
          <target state="translated">파일은 예고편으로 마무리됩니다.</target>
        </trans-unit>
        <trans-unit id="996f5fbcdb16f7d7ee85c3a6ae77d46a1781884a" translate="yes" xml:space="preserve">
          <source>The file parameters can point at the user&amp;rsquo;s working file (e.g. &lt;code&gt;new-file&lt;/code&gt; in &quot;git-diff-files&quot;), &lt;code&gt;/dev/null&lt;/code&gt; (e.g. &lt;code&gt;old-file&lt;/code&gt; when a new file is added), or a temporary file (e.g. &lt;code&gt;old-file&lt;/code&gt; in the index). &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; should not worry about unlinking the temporary file --- it is removed when &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; exits.</source>
          <target state="translated">파일 매개 변수는 사용자의 작업 파일에서 (예를 가리킬 수 있습니다 &lt;code&gt;new-file&lt;/code&gt; &quot;자식-DIFF-파일&quot;의을) &lt;code&gt;/dev/null&lt;/code&gt; (예를 들어 &lt;code&gt;old-file&lt;/code&gt; 새로운 파일이 추가된다), 또는 임시 파일을 (예를 들어 &lt;code&gt;old-file&lt;/code&gt; 색인에 파일 ). &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 는 임시 파일의 연결을 해제하지 않아도 됩니다. --- &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 가 종료 될 때 제거 됩니다.</target>
        </trans-unit>
        <trans-unit id="b979e5d416845ad4db7c29ab613bf67d05d7d448" translate="yes" xml:space="preserve">
          <source>The files are read in the order given above, with last value found taking precedence over values read earlier. When multiple values are taken then all values of a key from all files will be used.</source>
          <target state="translated">파일은 위에 주어진 순서대로 읽히고 마지막 값은 이전에 읽은 값보다 우선합니다. 여러 값을 가져 오면 모든 파일의 모든 키 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="22cd650e22be9431ebec70f16e27f0954b25a243" translate="yes" xml:space="preserve">
          <source>The files to read the patch from. &lt;code&gt;-&lt;/code&gt; can be used to read from the standard input.</source>
          <target state="translated">패치를 읽을 파일입니다. &lt;code&gt;-&lt;/code&gt; 표준 입력에서 읽는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc839d554b73db3187cb52551b31c221d5647965" translate="yes" xml:space="preserve">
          <source>The filter is expected to respond with a list of &quot;key=value&quot; pairs terminated with a flush packet. If the filter does not experience problems then the list must contain a &quot;success&quot; status. Right after these packets the filter is expected to send the content in zero or more pkt-line packets and a flush packet at the end. Finally, a second list of &quot;key=value&quot; pairs terminated with a flush packet is expected. The filter can change the status in the second list or keep the status as is with an empty list. Please note that the empty list must be terminated with a flush packet regardless.</source>
          <target state="translated">필터는 플러시 패킷으로 종료 된 &quot;key = value&quot;쌍 목록으로 응답합니다. 필터에 문제가 없으면 목록에 &quot;성공&quot;상태가 포함되어야합니다. 이러한 패킷 바로 뒤에 필터는 0 개 이상의 pkt-line 패킷으로 콘텐츠를 전송하고 마지막에는 플러시 패킷을 전송합니다. 마지막으로 플러시 패킷으로 종료 된 &quot;key = value&quot;쌍의 두 번째 목록이 예상됩니다. 필터는 두 번째 목록의 상태를 변경하거나 빈 목록으로 상태를 유지할 수 있습니다. 빈 목록은 플러시 패킷으로 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="48c7b9e769ad1a8ac7a03d8a91befba4e1dc75d4" translate="yes" xml:space="preserve">
          <source>The filter that will be applied when fetching from this promisor remote.</source>
          <target state="translated">이 Promisor Remote에서 가져올 때 적용되는 필터입니다.</target>
        </trans-unit>
        <trans-unit id="67e1cbcd0bc26ca591869ec55e18981d4a05f31d" translate="yes" xml:space="preserve">
          <source>The filters are applied in the order as listed below. The &amp;lt;command&amp;gt; argument is always evaluated in the shell context using the &lt;code&gt;eval&lt;/code&gt; command (with the notable exception of the commit filter, for technical reasons). Prior to that, the &lt;code&gt;$GIT_COMMIT&lt;/code&gt; environment variable will be set to contain the id of the commit being rewritten. Also, GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_AUTHOR_DATE, GIT_COMMITTER_NAME, GIT_COMMITTER_EMAIL, and GIT_COMMITTER_DATE are taken from the current commit and exported to the environment, in order to affect the author and committer identities of the replacement commit created by &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; after the filters have run.</source>
          <target state="translated">필터는 아래 나열된 순서대로 적용됩니다. &amp;lt;command&amp;gt; 인수는 &lt;code&gt;eval&lt;/code&gt; 명령을 사용하여 쉘 컨텍스트에서 항상 평가됩니다 (기술적 인 이유로 커밋 필터는 예외). 그 전에 &lt;code&gt;$GIT_COMMIT&lt;/code&gt; 환경 변수는 다시 작성되는 커밋의 ID를 포함하도록 설정됩니다. 또한 GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_AUTHOR_DATE, GIT_COMMITTER_NAME, GIT_COMMITTER_EMAIL 및 GIT_COMMITTER_DATE는 현재 커밋에서 가져 와서 환경으로 내 보내져 &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree&lt;/a&gt; 후 생성 된 교체 커밋의 작성자 및 커미터 신원에 영향을 미칩니다. 필터가 작동했습니다.</target>
        </trans-unit>
        <trans-unit id="96e6a8e11c595c66ed126e7ed94498b41b8ef74c" translate="yes" xml:space="preserve">
          <source>The final &quot;/&quot; is important. The exported name is literally just prefixed with the specified string. Contrast this with the following example.</source>
          <target state="translated">마지막 &quot;/&quot;가 중요합니다. 내 보낸 이름은 문자 그대로 지정된 문자열로 시작합니다. 이것을 다음 예제와 대조하십시오.</target>
        </trans-unit>
        <trans-unit id="5e71083855686454b686d549c1aa754044d9c24f" translate="yes" xml:space="preserve">
          <source>The final result will be a series of commits, one for each patch in the original mailbox, with authorship and commit log message each taken from the message containing each patch.</source>
          <target state="translated">최종 결과는 원래 메일 함의 각 패치마다 하나씩 일련의 커밋이되며 각 패치가 포함 된 메시지에서 각각 작성된 소유권 및 커밋 로그 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d06dc79919ba8d7d4e32bae22586b9e61ea6ab90" translate="yes" xml:space="preserve">
          <source>The first &quot;git bisect&quot; subcommand to use is &quot;git bisect start&quot; to start the search. Then bounds must be set to limit the commit space. This is done usually by giving one &quot;bad&quot; and at least one &quot;good&quot; commit. They can be passed in the initial call to &quot;git bisect start&quot; like this:</source>
          <target state="translated">사용할 첫 번째 &quot;git bisect&quot;하위 명령은 검색을 시작하는 &quot;git bisect start&quot;입니다. 그런 다음 확약 공간을 제한하도록 경계를 설정해야합니다. 이것은 일반적으로 하나의 &quot;나쁜&quot;및 하나 이상의 &quot;좋은&quot;커밋을 제공하여 수행됩니다. 다음과 같이 &quot;git bisect start&quot;에 대한 초기 호출에서 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d24667b8a3af4ae680279e90e5939ecc7d57754" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;N&lt;/code&gt; lines of the message.</source>
          <target state="translated">The first &lt;code&gt;N&lt;/code&gt; lines of the message.</target>
        </trans-unit>
        <trans-unit id="3dd96cc8c67fe6f3794e1faadfc16d4e75778490" translate="yes" xml:space="preserve">
          <source>The first argument, &lt;code&gt;origin&lt;/code&gt;, just tells Git to fetch from the repository you originally cloned from. The second argument tells Git to fetch the branch named &lt;code&gt;todo&lt;/code&gt; from the remote repository, and to store it locally under the name &lt;code&gt;refs/heads/my-todo-work&lt;/code&gt;.</source>
          <target state="translated">첫 번째 인자 인 &lt;code&gt;origin&lt;/code&gt; 은 Git에게 원래 복제 한 저장소에서 가져 오도록 지시합니다. 두 번째 인수는 Git에게 원격 저장소에서 &lt;code&gt;todo&lt;/code&gt; 라는 브랜치를 가져 와서 &lt;code&gt;refs/heads/my-todo-work&lt;/code&gt; 라는 이름으로 로컬로 저장하도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="81bbac8df429c9294b949507806676c0327c9227" translate="yes" xml:space="preserve">
          <source>The first character given by this option will be the default character used when another separator is not specified in the config for this trailer.</source>
          <target state="translated">이 옵션이 제공하는 첫 번째 문자는이 트레일러 구성에서 다른 구분 기호를 지정하지 않은 경우 사용되는 기본 문자입니다.</target>
        </trans-unit>
        <trans-unit id="39b9ae2f52daae0742c9cd959c54a342268035c6" translate="yes" xml:space="preserve">
          <source>The first command fetches the &lt;code&gt;maint&lt;/code&gt; branch from the repository at &lt;code&gt;git://git.kernel.org/pub/scm/git/git.git&lt;/code&gt; and the second command uses &lt;code&gt;FETCH_HEAD&lt;/code&gt; to examine the branch with &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;. The fetched objects will eventually be removed by git&amp;rsquo;s built-in housekeeping (see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;).</source>
          <target state="translated">첫 번째 명령 은 &lt;code&gt;git://git.kernel.org/pub/scm/git/git.git&lt;/code&gt; 의 저장소에서 &lt;code&gt;maint&lt;/code&gt; 브랜치를 가져오고 두 번째 명령은 &lt;code&gt;FETCH_HEAD&lt;/code&gt; 를 사용 하여 &lt;a href=&quot;git-log&quot;&gt;git-log [1]으로&lt;/a&gt; 브랜치를 검사합니다 . 가져온 객체는 git의 내장 하우스 키핑에 의해 제거됩니다 ( &lt;a href=&quot;git-gc&quot;&gt;git-gc [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fc54aa6f7f46c36afb224191ab9ce02506aa2fd9" translate="yes" xml:space="preserve">
          <source>The first defense against such problems is backups. You can back up a Git directory using clone, or just using cp, tar, or any other backup mechanism.</source>
          <target state="translated">이러한 문제에 대한 첫 번째 방어책은 백업입니다. clone을 사용하거나 cp, tar 또는 기타 백업 메커니즘을 사용하여 Git 디렉토리를 백업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb17679ed2c14d3eecb0f1bd83c98beea1f4bea4" translate="yes" xml:space="preserve">
          <source>The first format is what gets used when &lt;code&gt;--stage&lt;/code&gt; is omitted or is not &lt;code&gt;--stage=all&lt;/code&gt;. The field tempname is the temporary file name holding the file content and path is the tracked path name in the index. Only the requested entries are output.</source>
          <target state="translated">첫 번째 형식은 &lt;code&gt;--stage&lt;/code&gt; 가 생략되거나 &lt;code&gt;--stage=all&lt;/code&gt; 이 아닐 때 사용되는 형식입니다 . tempname 필드는 파일 내용이 들어있는 임시 파일 이름이고 path는 색인에서 추적 된 경로 이름입니다. 요청 된 항목 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="e7e26fcb00a95d796be86027e9776fd349443123" translate="yes" xml:space="preserve">
          <source>The first is simple and appropriate if you do not have secure storage available for a password. It is generally configured by adding this to your config:</source>
          <target state="translated">첫 번째는 암호에 사용 가능한 보안 스토리지가없는 경우 간단하고 적절합니다. 일반적으로 이것을 구성에 추가하여 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="51f664b1e28dce07dd2c1ef3f2cc4ddb005556f4" translate="yes" xml:space="preserve">
          <source>The first issue is performance. Unlike any previous option, the &lt;code&gt;--simplify-merges&lt;/code&gt; option requires walking the entire commit history before returning a single result. This can make the option difficult to use for very large repositories.</source>
          <target state="translated">The first issue is performance. Unlike any previous option, the &lt;code&gt;--simplify-merges&lt;/code&gt; option requires walking the entire commit history before returning a single result. This can make the option difficult to use for very large repositories.</target>
        </trans-unit>
        <trans-unit id="561e4f0c34cc864db97b2078e570c6b7cf2ee83d" translate="yes" xml:space="preserve">
          <source>The first line of the input feeds 0 as the mode to remove the path; the SHA-1 does not matter as long as it is well formatted. Then the second and third line feeds stage 1 and stage 2 entries for that path. After the above, we would end up with this:</source>
          <target state="translated">입력의 첫 번째 라인은 경로를 제거하는 모드로 0을 공급합니다. SHA-1은 형식이 올바른 한 중요하지 않습니다. 그런 다음 두 번째 및 세 번째 행은 해당 경로의 1 단계 및 2 단계 항목을 공급합니다. 위의 후, 우리는 이것으로 끝날 것입니다 :</target>
        </trans-unit>
        <trans-unit id="d7a467221d570ce5d2e2454d168c252049fa7e64" translate="yes" xml:space="preserve">
          <source>The first number is the number of objects which are kept in individual files. The second is the amount of space taken up by those &quot;loose&quot; objects.</source>
          <target state="translated">첫 번째 숫자는 개별 파일에 보관 된 개체 수입니다. 두 번째는 &quot;느슨한&quot;객체가 차지하는 공간입니다.</target>
        </trans-unit>
        <trans-unit id="a3a16231598a15324fe96a0d30a2003f1c762045" translate="yes" xml:space="preserve">
          <source>The first paragraph of the message, which typically is a single line, is taken as the &quot;subject&quot; of the commit or the tag message. Instead of &lt;code&gt;contents:subject&lt;/code&gt;, field &lt;code&gt;subject&lt;/code&gt; can also be used to obtain same results. &lt;code&gt;:sanitize&lt;/code&gt; can be appended to &lt;code&gt;subject&lt;/code&gt; for subject line suitable for filename.</source>
          <target state="translated">The first paragraph of the message, which typically is a single line, is taken as the &quot;subject&quot; of the commit or the tag message. Instead of &lt;code&gt;contents:subject&lt;/code&gt; , field &lt;code&gt;subject&lt;/code&gt; can also be used to obtain same results. &lt;code&gt;:sanitize&lt;/code&gt; can be appended to &lt;code&gt;subject&lt;/code&gt; for subject line suitable for filename.</target>
        </trans-unit>
        <trans-unit id="1517f019c895db91a3158888218e464c0e667ed4" translate="yes" xml:space="preserve">
          <source>The first parameter passed to the hook is the indicator for the working directory being updated. &quot;1&quot; meaning working directory was updated or &quot;0&quot; when the working directory was not updated.</source>
          <target state="translated">후크에 전달 된 첫 번째 매개 변수는 업데이트중인 작업 디렉토리의 표시기입니다. &quot;1&quot;은 작업 디렉토리가 업데이트되었음을 ​​의미하거나 작업 디렉토리가 업데이트되지 않은 경우 &quot;0&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="69f4b05a4b19ebccc10062a19a78b72d37ff6b60" translate="yes" xml:space="preserve">
          <source>The first rule takes precedence in the case of a single &amp;lt;commit&amp;gt;. To apply the second rule, i.e., format everything since the beginning of history up until &amp;lt;commit&amp;gt;, use the &lt;code&gt;--root&lt;/code&gt; option: &lt;code&gt;git format-patch
--root &amp;lt;commit&amp;gt;&lt;/code&gt;. If you want to format only &amp;lt;commit&amp;gt; itself, you can do this with &lt;code&gt;git format-patch -1 &amp;lt;commit&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">단일 &amp;lt;commit&amp;gt;의 경우 첫 번째 규칙이 우선합니다. 두 번째 규칙을 적용하려면, 즉 &amp;lt;commit&amp;gt;까지 히스토리가 시작된 이후의 모든 것을 포맷하려면 &lt;code&gt;--root&lt;/code&gt; 옵션을 사용하십시오 : &lt;code&gt;git format-patch --root &amp;lt;commit&amp;gt;&lt;/code&gt; . &amp;lt;commit&amp;gt; 자체 만 포맷하려면 &lt;code&gt;git format-patch -1 &amp;lt;commit&amp;gt;&lt;/code&gt; 으로 이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="088dfc95ab36375e45956a12e0a84d20b54cd1e3" translate="yes" xml:space="preserve">
          <source>The first step is trivial: when you want to tell Git about any changes to your working tree, you use the &lt;code&gt;git update-index&lt;/code&gt; program. That program normally just takes a list of filenames you want to update, but to avoid trivial mistakes, it refuses to add new entries to the index (or remove existing ones) unless you explicitly tell it that you&amp;rsquo;re adding a new entry with the &lt;code&gt;--add&lt;/code&gt; flag (or removing an entry with the &lt;code&gt;--remove&lt;/code&gt;) flag.</source>
          <target state="translated">첫 번째 단계는 간단합니다. 작업 트리의 변경 사항에 대해 Git에 알리려면 &lt;code&gt;git update-index&lt;/code&gt; 프로그램 을 사용하십시오 . 이 프로그램은 일반적으로 업데이트하려는 파일 이름 목록을 가져 오지만 사소한 실수를 피하기 위해 색인에 새 항목을 추가한다고 명시 적으로 명시하지 않는 한 색인에 새 항목을 추가하거나 기존 항목을 제거하지 않습니다. &lt;code&gt;--add&lt;/code&gt; 플래그 (또는 &lt;code&gt;--remove&lt;/code&gt; 를 사용 하여 항목 제거 ) 플래그.</target>
        </trans-unit>
        <trans-unit id="a1763915dd6826ebefd6dfcb3fd9fb79e61ff2f7" translate="yes" xml:space="preserve">
          <source>The first time that a commit shows up in the stream, it has various other information about it printed out with a one-word tag at the beginning of each line describing the extra commit information (author, email, committer, dates, summary, etc.).</source>
          <target state="translated">커밋이 처음으로 스트림에 표시되면 추가 커밋 정보 (작성자, 전자 메일, 커미터, 날짜, 요약 등)를 설명하는 각 줄의 시작 부분에 한 단어 태그로 인쇄 된 다양한 정보가 있습니다. ).</target>
        </trans-unit>
        <trans-unit id="33e2d00ff1c333999b37d340bc5ae3e8a3bfd826" translate="yes" xml:space="preserve">
          <source>The first time you run it, you will be prompted for your credentials. Enter the app-specific or your regular password as appropriate. If you have credential helper configured (see &lt;a href=&quot;git-credential&quot;&gt;git-credential[1]&lt;/a&gt;), the password will be saved in the credential store so you won&amp;rsquo;t have to type it the next time.</source>
          <target state="translated">처음 실행할 때 자격 증명을 묻는 메시지가 나타납니다. 앱 비밀번호 또는 일반 비밀번호를 적절히 입력하십시오. 자격 증명 도우미를 구성한 경우 ( &lt;a href=&quot;git-credential&quot;&gt;git-credential [1] 참조&lt;/a&gt; ) 자격 증명 저장소에 암호가 저장되므로 다음에 입력 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1c77b9db9c00c5ba7e83e0fb24758e48237c23ee" translate="yes" xml:space="preserve">
          <source>The first two lines indicate that it is showing the two branches with the titles of their top-of-the-tree commits, you are currently on &lt;code&gt;master&lt;/code&gt; branch (notice the asterisk &lt;code&gt;*&lt;/code&gt; character), and the first column for the later output lines is used to show commits contained in the &lt;code&gt;master&lt;/code&gt; branch, and the second column for the &lt;code&gt;mybranch&lt;/code&gt; branch. Three commits are shown along with their titles. All of them have non blank characters in the first column (&lt;code&gt;*&lt;/code&gt; shows an ordinary commit on the current branch, &lt;code&gt;-&lt;/code&gt; is a merge commit), which means they are now part of the &lt;code&gt;master&lt;/code&gt; branch. Only the &quot;Some work&quot; commit has the plus &lt;code&gt;+&lt;/code&gt; character in the second column, because &lt;code&gt;mybranch&lt;/code&gt; has not been merged to incorporate these commits from the master branch. The string inside brackets before the commit log message is a short name you can use to name the commit. In the above example, &lt;code&gt;master&lt;/code&gt; and &lt;code&gt;mybranch&lt;/code&gt; are branch heads. &lt;code&gt;master^&lt;/code&gt; is the first parent of &lt;code&gt;master&lt;/code&gt; branch head. Please see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; if you want to see more complex cases.</source>
          <target state="translated">처음 두 줄은 트리 상단 커밋의 제목과 함께 두 개의 분기를 표시하고 있음을 나타냅니다. 현재 &lt;code&gt;master&lt;/code&gt; 분기 (별표 &lt;code&gt;*&lt;/code&gt; 문자)에 있고 나중에 출력 줄의 첫 번째 열은 &lt;code&gt;master&lt;/code&gt; 브랜치에 포함 된 커밋 과 &lt;code&gt;mybranch&lt;/code&gt; 브랜치 의 두 번째 열 을 표시하는 데 사용됩니다 . 3 개의 커밋이 제목과 함께 표시됩니다. 그들 모두가 첫 번째 열에 비 공백 문자가 ( &lt;code&gt;*&lt;/code&gt; 보통의 현재 지점에 커밋 쇼, &lt;code&gt;-&lt;/code&gt; 그들은 지금의 일부 의미, 커밋 병합입니다) &lt;code&gt;master&lt;/code&gt; 분기. &quot;일부 작업&quot;커밋에만 &lt;code&gt;+&lt;/code&gt; &lt;code&gt;mybranch&lt;/code&gt; 가 병합되어 마스터 분기의 커밋을 통합하지 않았기 때문에 두 번째 열의 문자 커밋 로그 메시지 앞의 괄호 안의 문자열은 커밋 이름을 지정하는 데 사용할 수있는 짧은 이름입니다. 위의 예에서 &lt;code&gt;master&lt;/code&gt; 및 &lt;code&gt;mybranch&lt;/code&gt; 는 분기 헤드입니다. &lt;code&gt;master^&lt;/code&gt; 는 &lt;code&gt;master&lt;/code&gt; 브랜치 헤드 의 첫 번째 부모입니다 . 더 복잡한 사례를 보려면 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6b2c923c8cb34a6329089d3ed63e2b76d6f7ceed" translate="yes" xml:space="preserve">
          <source>The folder to drop the mails into, which is typically the Drafts folder. For example: &quot;INBOX.Drafts&quot;, &quot;INBOX/Drafts&quot; or &quot;[Gmail]/Drafts&quot;. Required.</source>
          <target state="translated">메일을 넣을 폴더 (보통 임시 보관함)입니다. 예 : &quot;INBOX.Drafts&quot;, &quot;INBOX / Drafts&quot;또는 &quot;[Gmail] / Drafts&quot;. 필수입니다.</target>
        </trans-unit>
        <trans-unit id="396ef1fe12b6dc07f4e5a4f66f87333df9fb56e3" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;update&lt;/code&gt; procedures are only available via the &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; configuration variable:</source>
          <target state="translated">다음 &lt;code&gt;update&lt;/code&gt; 절차는 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.update&lt;/code&gt; 구성 변수 를 통해서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="109e44e80a38f6553ddae4455bbabc5ec0d98180" translate="yes" xml:space="preserve">
          <source>The following Thunderbird extensions are needed: AboutConfig from &lt;a href=&quot;http://aboutconfig.mozdev.org/&quot;&gt;http://aboutconfig.mozdev.org/&lt;/a&gt; and External Editor from &lt;a href=&quot;http://globs.org/articles.php?lng=en&amp;amp;pg=8&quot;&gt;http://globs.org/articles.php?lng=en&amp;amp;pg=8&lt;/a&gt;</source>
          <target state="translated">다음 Thunderbird 확장이 필요합니다. &lt;a href=&quot;http://aboutconfig.mozdev.org/&quot;&gt;http://aboutconfig.mozdev.org/의&lt;/a&gt; AboutConfig 및 &lt;a href=&quot;http://globs.org/articles.php?lng=en&amp;amp;pg=8&quot;&gt;http://globs.org/articles.php?lng=en&amp;amp;pg=8의&lt;/a&gt; 외부 편집기</target>
        </trans-unit>
        <trans-unit id="f6722fafbaf6d78a6b809eec36e0605e28b20857" translate="yes" xml:space="preserve">
          <source>The following are helper commands used by the above; end users typically do not use them directly.</source>
          <target state="translated">다음은 위에서 사용한 도우미 명령입니다. 최종 사용자는 일반적으로 직접 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e10909a1942dd56a826033bd880f2f38314517d" translate="yes" xml:space="preserve">
          <source>The following command switches to the &quot;master&quot; branch:</source>
          <target state="translated">다음 명령은 &quot;마스터&quot;분기로 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="7a4f4c25f3029fcde1d4a38239fa9b13c5887156" translate="yes" xml:space="preserve">
          <source>The following command-line options change import semantics and may therefore not be passed as option:</source>
          <target state="translated">다음 명령 행 옵션은 가져 오기 시맨틱을 변경하므로 옵션으로 전달되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="932cde1c301ce345d40b274a1f81ff3e5be711e6" translate="yes" xml:space="preserve">
          <source>The following command-specific comments apply:</source>
          <target state="translated">다음과 같은 명령 별 설명이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d6f2de10386ef19748ad0fa0931b3359b3969227" translate="yes" xml:space="preserve">
          <source>The following config settings can be used to modify &lt;code&gt;git p4&lt;/code&gt; behavior. They all are in the &lt;code&gt;git-p4&lt;/code&gt; section.</source>
          <target state="translated">다음 구성 설정을 사용하여 &lt;code&gt;git p4&lt;/code&gt; 동작 을 수정할 수 있습니다 . 그것들은 모두 &lt;code&gt;git-p4&lt;/code&gt; 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f68ee79cc1f0c0e26a0c766d89a6823644298bab" translate="yes" xml:space="preserve">
          <source>The following configuration variables tell gitweb where to find files. The values of these variables are paths on the filesystem.</source>
          <target state="translated">다음 구성 변수는 gitweb에 파일을 찾을 위치를 알려줍니다. 이 변수의 값은 파일 시스템의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="446ebc694e2441273405a78869483ed3506272c8" translate="yes" xml:space="preserve">
          <source>The following date formats are supported. A frontend should select the format it will use for this import by passing the format name in the --date-format=&amp;lt;fmt&amp;gt; command-line option.</source>
          <target state="translated">다음 날짜 형식이 지원됩니다. 프런트 엔드는 --date-format = &amp;lt;fmt&amp;gt; 명령 줄 옵션에 형식 이름을 전달하여이 가져 오기에 사용할 형식을 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="e77a52167245e31f57d9305063355588365e98e5" translate="yes" xml:space="preserve">
          <source>The following description divides the low-level commands into commands that manipulate objects (in the repository, index, and working tree), commands that interrogate and compare objects, and commands that move objects and references between repositories.</source>
          <target state="translated">다음 설명에서는 저수준 명령을 개체 (리포지토리, 인덱스 및 작업 트리에서)를 조작하는 명령, 개체를 조사 및 비교하는 명령 및 개체와 참조를 리포지토리간에 이동하는 명령으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="0ccfcc7705084a20c6fb8eba32c2c2f3d02467cc" translate="yes" xml:space="preserve">
          <source>The following documentation pages are guides about Git concepts.</source>
          <target state="translated">The following documentation pages are guides about Git concepts.</target>
        </trans-unit>
        <trans-unit id="8ce90b7b29314319d9c33a8b52e106d84ec9670f" translate="yes" xml:space="preserve">
          <source>The following escape sequences (beside &lt;code&gt;\&quot;&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt;) are recognized: &lt;code&gt;\n&lt;/code&gt; for newline character (NL), &lt;code&gt;\t&lt;/code&gt; for horizontal tabulation (HT, TAB) and &lt;code&gt;\b&lt;/code&gt; for backspace (BS). Other char escape sequences (including octal escape sequences) are invalid.</source>
          <target state="translated">줄 바꿈 문자 (NL)의 경우 &lt;code&gt;\n&lt;/code&gt; , 가로 표 (HT, TAB)의 경우 &lt;code&gt;\t&lt;/code&gt; , 백 스페이스 (BS)의 경우 &lt;code&gt;\b&lt;/code&gt; 이스케이프 시퀀스 ( &lt;code&gt;\&quot;&lt;/code&gt; 및 &lt;code&gt;\\&lt;/code&gt; 옆 )가 인식 됩니다. 다른 문자 이스케이프 시퀀스 (8 진 포함) 이스케이프 시퀀스)가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11e92a0ce8b123a34278f747bf61153deb05c5a4" translate="yes" xml:space="preserve">
          <source>The following example shows three branches, &quot;master&quot;, &quot;fixes&quot; and &quot;mhf&quot;:</source>
          <target state="translated">다음 예는 &quot;master&quot;, &quot;fixes&quot;및 &quot;mhf&quot;의 세 가지 분기를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4297ab330b843af6f1af2259ff9a055a87b6bf37" translate="yes" xml:space="preserve">
          <source>The following features from &amp;lsquo;svn log&amp;rsquo; are supported:</source>
          <target state="translated">'svn log'의 다음 기능이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9b96392c24cd31061920293e2fd2511a8543969f" translate="yes" xml:space="preserve">
          <source>The following flags further affect the behavior when comparing commits (but not trees).</source>
          <target state="translated">다음 플래그는 커밋을 비교할 때 동작에 영향을 미칩니다 (트리는 아님).</target>
        </trans-unit>
        <trans-unit id="c98119f1eba9806e1383e47ef0aa9d751dbdff13" translate="yes" xml:space="preserve">
          <source>The following format are available:</source>
          <target state="translated">다음 형식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f08fc55d496958a337ddcb6a67febfb89f85554" translate="yes" xml:space="preserve">
          <source>The following key/value pairs are common to all events:</source>
          <target state="translated">다음 키 / 값 쌍은 모든 이벤트에 공통입니다.</target>
        </trans-unit>
        <trans-unit id="0a5e5ff367236dbd6bf5580d5af5e71ae090b770" translate="yes" xml:space="preserve">
          <source>The following options affect the way the simplification is performed:</source>
          <target state="translated">다음 옵션은 단순화 수행 방식에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="d99d5d2882d3fb95fadc56a0416699f5b886386d" translate="yes" xml:space="preserve">
          <source>The following options are available in either location:</source>
          <target state="translated">어느 위치에서나 다음 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e9dd1ef0925dcf9e09b1e6e501e8d0360e77eba" translate="yes" xml:space="preserve">
          <source>The following options are defined and (under suitable circumstances) set by Git if the remote helper has the &lt;code&gt;option&lt;/code&gt; capability.</source>
          <target state="translated">원격 도우미에 &lt;code&gt;option&lt;/code&gt; 기능 이있는 경우 다음 옵션이 정의되고 적절한 환경에서 Git에 의해 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad97d4ffb6c58a93bf3193a5402926d11d214aa1" translate="yes" xml:space="preserve">
          <source>The following options select the commits to be shown:</source>
          <target state="translated">다음 옵션은 표시 할 커밋을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="04bd1c24e8e494894e5123ce96e6c123a135b194" translate="yes" xml:space="preserve">
          <source>The following options:</source>
          <target state="translated">다음과 같은 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b3b3b2ba3a3d71942fecd2cbccdbee3fd847246" translate="yes" xml:space="preserve">
          <source>The following sequence attempts to backport a patch, bails out because the code the patch applies to has changed too much, and then tries again, this time exercising more care about matching up context lines.</source>
          <target state="translated">다음 순서는 패치를 백 포트하려고 시도하고 패치가 적용되는 코드가 너무 많이 변경 되었기 때문에 구제됩니다. 이번에는 컨텍스트 라인 일치에 대해 더 많은주의를 기울입니다.</target>
        </trans-unit>
        <trans-unit id="0fb6c7c3c1a2e6361aa6d0f3ddafd309ebc6378c" translate="yes" xml:space="preserve">
          <source>The following sequence checks out the &lt;code&gt;master&lt;/code&gt; branch, reverts the &lt;code&gt;Makefile&lt;/code&gt; to two revisions back, deletes &lt;code&gt;hello.c&lt;/code&gt; by mistake, and gets it back from the index.</source>
          <target state="translated">다음 순서는 &lt;code&gt;master&lt;/code&gt; 브랜치를 체크 아웃하고 &lt;code&gt;Makefile&lt;/code&gt; 을 두 개의 수정본으로 되돌리고 실수로 &lt;code&gt;hello.c&lt;/code&gt; 를 삭제 한 다음 인덱스에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b8a40037f7e020ad1f156eb7f08942ca8112c080" translate="yes" xml:space="preserve">
          <source>The following sequence switches to the &lt;code&gt;master&lt;/code&gt; branch, reverts the &lt;code&gt;Makefile&lt;/code&gt; to two revisions back, deletes hello.c by mistake, and gets it back from the index.</source>
          <target state="translated">다음 순서는 &lt;code&gt;master&lt;/code&gt; 브랜치로 전환하고 &lt;code&gt;Makefile&lt;/code&gt; 을 두 개의 수정본으로 되돌리고 실수로 hello.c를 삭제 한 다음 인덱스에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="75477915a08ed3777518303fe3302c5a880167a8" translate="yes" xml:space="preserve">
          <source>The following sequences have a special meaning:</source>
          <target state="translated">다음 순서는 특별한 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b07d72a39fdd44876a293ab8f917fa6a1014bd8c" translate="yes" xml:space="preserve">
          <source>The following subcommands are available:</source>
          <target state="translated">다음 부속 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55332124e1bbf00265c49abce68b19cb8696bb39" translate="yes" xml:space="preserve">
          <source>The following syntaxes may be used with them:</source>
          <target state="translated">다음과 같은 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9c489d8b69bf82a63ff4a237dd2bd772b8fb351" translate="yes" xml:space="preserve">
          <source>The following tables show what happens when there are unmerged entries:</source>
          <target state="translated">다음 표는 병합되지 않은 항목이있을 때 발생하는 상황을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3cc98c85c7406728df501340aea8c7fdc3f04d78" translate="yes" xml:space="preserve">
          <source>The following tips and tricks have been collected from various users of fast-import, and are offered here as suggestions.</source>
          <target state="translated">다음은 다양한 빠른 가져 오기 사용자로부터 얻은 팁과 요령이며 여기에서 제안으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="177a564b8e3982405afb3b516ab4bbb5063d1ee7" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=blob:limit=&amp;lt;n&amp;gt;[kmg]&lt;/code&gt; omits blobs larger than n bytes or units. n may be zero. The suffixes k, m, and g can be used to name units in KiB, MiB, or GiB. For example, &lt;code&gt;blob:limit=1k&lt;/code&gt; is the same as &lt;code&gt;blob:limit=1024&lt;/code&gt;.</source>
          <target state="translated">형태 &lt;code&gt;--filter=blob:limit=&amp;lt;n&amp;gt;[kmg]&lt;/code&gt; 를 생략 블롭 바이트 단위 N보다 크다. n은 0 일 수있다. 접미사 k, m 및 g를 사용하여 KiB, MiB 또는 GiB의 단위 이름을 지정할 수 있습니다. 예를 들어, &lt;code&gt;blob:limit=1k&lt;/code&gt; 는 &lt;code&gt;blob:limit=1024&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="94349f8d4383b34d05a696da3b05af67f12eec03" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=blob:none&lt;/code&gt; omits all blobs.</source>
          <target state="translated">양식 &lt;code&gt;--filter=blob:none&lt;/code&gt; 모든 모양을 생략합니다.</target>
        </trans-unit>
        <trans-unit id="39c705af761382dd23f074438f9b0e646bf492af" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=combine:&amp;lt;filter1&amp;gt;+&amp;lt;filter2&amp;gt;+&amp;hellip;​&amp;lt;filterN&amp;gt;&lt;/code&gt; can also be used to combined several filters, but this is harder than just repeating the &lt;code&gt;--filter&lt;/code&gt; flag and is usually not necessary. Filters are joined by &lt;code&gt;+&lt;/code&gt; and individual filters are %-encoded (i.e. URL-encoded). Besides the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt; characters, the following characters are reserved and also must be encoded: &lt;code&gt;~!@#$^&amp;amp;*()[]{}\;&quot;,&amp;lt;&amp;gt;?&lt;/code&gt;&lt;code&gt;'`&lt;/code&gt; as well as all characters with ASCII code &amp;lt;= &lt;code&gt;0x20&lt;/code&gt;, which includes space and newline.</source>
          <target state="translated">양식 &lt;code&gt;--filter=combine:&amp;lt;filter1&amp;gt;+&amp;lt;filter2&amp;gt;+&amp;hellip;​&amp;lt;filterN&amp;gt;&lt;/code&gt; 또한 결합 된 여러 필터를 사용할 수 있지만, 열심히 단지 반복보다 수 &lt;code&gt;--filter&lt;/code&gt; 플래그를 일반적으로 필요하지 않습니다. 필터는 &lt;code&gt;+&lt;/code&gt; 로 결합되며 개별 필터는 %로 인코딩됩니다 (예 : URL 인코딩). &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; 문자 외에도 다음 문자가 예약되어 있으며 인코딩되어야합니다. &lt;code&gt;~!@#$^&amp;amp;*()[]{}\;&quot;,&amp;lt;&amp;gt;?&lt;/code&gt; &lt;code&gt;'`&lt;/code&gt; 및 ASCII 코드가있는 모든 문자 &amp;lt; = &lt;code&gt;0x20&lt;/code&gt; 에는 공백과 줄 바꿈이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d52505ec75878146eb9054dceb4728d58b485513" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=sparse:oid=&amp;lt;blob-ish&amp;gt;&lt;/code&gt; uses a sparse-checkout specification contained in the blob (or blob-expression) &lt;code&gt;&amp;lt;blob-ish&amp;gt;&lt;/code&gt; to omit blobs that would not be not required for a sparse checkout on the requested refs.</source>
          <target state="translated">형태 &lt;code&gt;--filter=sparse:oid=&amp;lt;blob-ish&amp;gt;&lt;/code&gt; 스파 스 결제 명세가 블롭 함유 사용 (또는 블로 표현) &lt;code&gt;&amp;lt;blob-ish&amp;gt;&lt;/code&gt; 을 생략 블롭 희소 결제에 필요한지지 않을 것이라고 요청 된 심판.</target>
        </trans-unit>
        <trans-unit id="ef46a11218e9457b2745a05e86c211527bd23b7c" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--filter=tree:&amp;lt;depth&amp;gt;&lt;/code&gt; omits all blobs and trees whose depth from the root tree is &amp;gt;= &amp;lt;depth&amp;gt; (minimum depth if an object is located at multiple depths in the commits traversed). &amp;lt;depth&amp;gt;=0 will not include any trees or blobs unless included explicitly in the command-line (or standard input when --stdin is used). &amp;lt;depth&amp;gt;=1 will include only the tree and blobs which are referenced directly by a commit reachable from &amp;lt;commit&amp;gt; or an explicitly-given object. &amp;lt;depth&amp;gt;=2 is like &amp;lt;depth&amp;gt;=1 while also including trees and blobs one more level removed from an explicitly-given commit or tree.</source>
          <target state="translated">&lt;code&gt;--filter=tree:&amp;lt;depth&amp;gt;&lt;/code&gt; 형식 은 루트 트리에서 깊이가&amp;gt; = &amp;lt;depth&amp;gt; (객체가 커밋 된 여러 깊이에있는 경우 최소 깊이) 인 모든 블롭 및 트리를 생략합니다. &amp;lt;depth&amp;gt; = 0은 명령 줄에 명시 적으로 포함되지 않은 경우 (또는 --stdin을 사용할 경우 표준 입력) 트리 나 얼룩을 포함하지 않습니다. &amp;lt;depth&amp;gt; = 1은 &amp;lt;commit&amp;gt;에서 도달 할 수있는 커밋 또는 명시 적으로 제공된 객체에 의해 직접 참조되는 트리와 블로 브 만 포함합니다. &amp;lt;depth&amp;gt; = 2는 &amp;lt;depth&amp;gt; = 1과 같지만 명시 적으로 제공된 커밋 또는 트리에서 제거 된 한 단계 이상의 트리 및 얼룩도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="143c72f9a0abe1adb065cd1c00c0271a08c274c4" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-any&lt;/code&gt; will allow object traversal to continue if a missing object is encountered. Missing objects will silently be omitted from the results.</source>
          <target state="translated">&lt;code&gt;--missing=allow-any&lt;/code&gt; 형식 은 누락 된 객체가 발견되면 객체 순회가 계속되도록합니다. 누락 된 개체는 결과에서 자동으로 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="bdde6c336c8ea83ffd865ad36b93358c59c8c01f" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-any&lt;/code&gt; will allow object traversal to continue if a missing object is encountered. No fetch of a missing object will occur. Missing objects will silently be omitted from the results.</source>
          <target state="translated">The form &lt;code&gt;--missing=allow-any&lt;/code&gt; will allow object traversal to continue if a missing object is encountered. No fetch of a missing object will occur. Missing objects will silently be omitted from the results.</target>
        </trans-unit>
        <trans-unit id="4ac33b80327bef1bf98d899063defe39f6edf744" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will only allow object traversal to continue for EXPECTED promisor missing objects. No fetch of a missing object will occur. An unexpected missing object will raise an error.</source>
          <target state="translated">The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt; , but will only allow object traversal to continue for EXPECTED promisor missing objects. No fetch of a missing object will occur. An unexpected missing object will raise an error.</target>
        </trans-unit>
        <trans-unit id="280716e3ccf86616960848b089fdadef81ba797d" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing object will raise an error.</source>
          <target state="translated">&lt;code&gt;--missing=allow-promisor&lt;/code&gt; 형식 은 &lt;code&gt;allow-any&lt;/code&gt; 와 유사 하지만 예상 통과 유망 누락 객체에 대해 객체 순회 만 계속 허용합니다. 예상치 못한 누락 된 개체는 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="563d9e750d01dbe920d57035d16bed3d91b9aea6" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=allow-promisor&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will only allow object traversal to continue for EXPECTED promisor missing objects. Unexpected missing objects will raise an error.</source>
          <target state="translated">&lt;code&gt;--missing=allow-promisor&lt;/code&gt; 형식 은 &lt;code&gt;allow-any&lt;/code&gt; 와 유사 하지만 예상 통과 유망 누락 객체에 대해 객체 순회 만 계속 허용합니다. 예상치 못한 누락 된 개체는 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="85974afd39adff2510445a34b40c988ae3340623" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=error&lt;/code&gt; requests that pack-objects stop with an error if a missing object is encountered. If the repository is a partial clone, an attempt to fetch missing objects will be made before declaring them missing. This is the default action.</source>
          <target state="translated">The form &lt;code&gt;--missing=error&lt;/code&gt; requests that pack-objects stop with an error if a missing object is encountered. If the repository is a partial clone, an attempt to fetch missing objects will be made before declaring them missing. This is the default action.</target>
        </trans-unit>
        <trans-unit id="28c618ed732782b866de4c7dcf716daa2ac64119" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=error&lt;/code&gt; requests that pack-objects stop with an error if a missing object is encountered. This is the default action.</source>
          <target state="translated">&lt;code&gt;--missing=error&lt;/code&gt; 양식 은 누락 된 객체가 발견되면 pack-objects가 오류와 함께 중지되도록 요청합니다. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="2ed32158adb2f2f236ac5307d5ba7c30f0630796" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=error&lt;/code&gt; requests that rev-list stop with an error if a missing object is encountered. This is the default action.</source>
          <target state="translated">&lt;code&gt;--missing=error&lt;/code&gt; 양식 은 누락 된 객체가 발견되면 rev-list가 오류와 함께 중지되도록 요청합니다. 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="67e4b67693941fe412533d5210bde2a413de8fb1" translate="yes" xml:space="preserve">
          <source>The form &lt;code&gt;--missing=print&lt;/code&gt; is like &lt;code&gt;allow-any&lt;/code&gt;, but will also print a list of the missing objects. Object IDs are prefixed with a &amp;ldquo;?&amp;rdquo; character.</source>
          <target state="translated">&lt;code&gt;--missing=print&lt;/code&gt; 형식 은 &lt;code&gt;allow-any&lt;/code&gt; 와 유사 하지만 누락 된 개체의 목록도 인쇄합니다. 개체 ID 앞에는 &quot;?&quot;가 붙습니다. 캐릭터.</target>
        </trans-unit>
        <trans-unit id="09994cb2384da5eddbe0ae0a9a1ceca76d8c8bcc" translate="yes" xml:space="preserve">
          <source>The format of a &amp;lt;refspec&amp;gt; parameter is an optional plus &lt;code&gt;+&lt;/code&gt;, followed by the source &amp;lt;src&amp;gt;, followed by a colon &lt;code&gt;:&lt;/code&gt;, followed by the destination ref &amp;lt;dst&amp;gt;. The colon can be omitted when &amp;lt;dst&amp;gt; is empty. &amp;lt;src&amp;gt; is typically a ref, but it can also be a fully spelled hex object name.</source>
          <target state="translated">&amp;lt;refspec&amp;gt; 매개 변수의 형식은 선택적인 plus &lt;code&gt;+&lt;/code&gt; , 소스 &amp;lt;src&amp;gt;, 콜론 &lt;code&gt;:&lt;/code&gt; , 목적지 ref &amp;lt;dst&amp;gt;입니다. &amp;lt;dst&amp;gt;가 비어 있으면 콜론을 생략 할 수 있습니다. &amp;lt;src&amp;gt;는 일반적으로 ref이지만, 완전한 철자 16 진 오브젝트 이름 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="05c09db4c870e826391cf6ebde5a8cc33d2791f6" translate="yes" xml:space="preserve">
          <source>The format of these files is username followed by the encrypted password, for example:</source>
          <target state="translated">이러한 파일의 형식은 사용자 이름 뒤에 암호화 된 비밀번호가 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="65670970ee487305077ce344ca1fb6c36a889cee" translate="yes" xml:space="preserve">
          <source>The former lets your shell expand the fileglob, and you are asking the dot-C files in your working tree to be overwritten with the version in the index. The latter passes the &lt;code&gt;*.c&lt;/code&gt; to Git, and you are asking the paths in the index that match the pattern to be checked out to your working tree. After running &lt;code&gt;git add hello.c; rm hello.c&lt;/code&gt;, you will &lt;code&gt;not&lt;/code&gt; see &lt;code&gt;hello.c&lt;/code&gt; in your working tree with the former, but with the latter you will.</source>
          <target state="translated">전자는 쉘이 fileglob를 확장 할 수있게하여 작업 트리의 dot-C 파일을 색인의 버전으로 겹쳐 쓰도록 요청합니다. 후자는 &lt;code&gt;*.c&lt;/code&gt; 를 Git에 전달하고, 작업 트리에 체크 아웃 할 패턴과 일치하는 인덱스의 경로를 묻습니다. &lt;code&gt;git add hello.c; rm hello.c&lt;/code&gt; 실행 한 후 hello.c를 추가하십시오; rm hello.c , 작업 트리에서 &lt;code&gt;hello.c&lt;/code&gt; 를 이전 트리와 함께 볼 수는 &lt;code&gt;not&lt;/code&gt; 후자와 함께 볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="b363974f459c2a2b237a919650aa9dc9f75161d2" translate="yes" xml:space="preserve">
          <source>The frontend must specify the number of bytes of data.</source>
          <target state="translated">프론트 엔드는 데이터의 바이트 수를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="23957db0f038e6b4263285c2923ad6ce72a805ca" translate="yes" xml:space="preserve">
          <source>The full SHA-1 object name (40-byte hexadecimal string), or a leading substring that is unique within the repository. E.g. dae86e1950b1277e545cee180551750029cfe735 and dae86e both name the same commit object if there is no other object in your repository whose object name starts with dae86e.</source>
          <target state="translated">전체 SHA-1 오브젝트 이름 (40 바이트 16 진 문자열) 또는 저장소 내에서 고유 한 선행 서브 스트링 예를 들어 dae86e1950b1277e545cee180551750029cfe735와 dae86e는 저장소에 객체 이름이 dae86e로 시작하는 다른 객체가없는 경우 동일한 커밋 객체의 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ce332106cb9361add9aaf31aea030a425aeed7be" translate="yes" xml:space="preserve">
          <source>The full name is occasionally useful if, for example, there ever exists a tag and a branch with the same name.</source>
          <target state="translated">전체 이름은 예를 들어 같은 이름의 태그와 분기가있는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d24187cae372eb76b2a26570ccfd9def8c8abdf6" translate="yes" xml:space="preserve">
          <source>The full pattern set allows for arbitrary pattern matches and complicated inclusion/exclusion rules. These can result in O(N*M) pattern matches when updating the index, where N is the number of patterns and M is the number of paths in the index. To combat this performance issue, a more restricted pattern set is allowed when &lt;code&gt;core.spareCheckoutCone&lt;/code&gt; is enabled.</source>
          <target state="translated">전체 패턴 세트는 임의의 패턴 일치 및 복잡한 포함 / 제외 규칙을 허용합니다. 이로 인해 인덱스를 업데이트 할 때 O (N * M) 패턴 일치가 발생할 수 있습니다. 여기서 N은 패턴 수이고 M은 인덱스의 경로 수입니다. 이 성능 문제를 해결하기 위해 &lt;code&gt;core.spareCheckoutCone&lt;/code&gt; 이 활성화 된 경우보다 제한된 패턴 세트가 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="271f7ad4b6b86f815e34a99cf6372d6f7edf455d" translate="yes" xml:space="preserve">
          <source>The full pattern set allows for arbitrary pattern matches and complicated inclusion/exclusion rules. These can result in O(N*M) pattern matches when updating the index, where N is the number of patterns and M is the number of paths in the index. To combat this performance issue, a more restricted pattern set is allowed when &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; is enabled.</source>
          <target state="translated">The full pattern set allows for arbitrary pattern matches and complicated inclusion/exclusion rules. These can result in O(N*M) pattern matches when updating the index, where N is the number of patterns and M is the number of paths in the index. To combat this performance issue, a more restricted pattern set is allowed when &lt;code&gt;core.sparseCheckoutCone&lt;/code&gt; is enabled.</target>
        </trans-unit>
        <trans-unit id="6d3e98918a57498bee35c9ef416c5932bb448c1f" translate="yes" xml:space="preserve">
          <source>The full syntax for a p4 view is documented in &lt;code&gt;p4 help views&lt;/code&gt;. &lt;code&gt;git p4&lt;/code&gt; knows only a subset of the view syntax. It understands multi-line mappings, overlays with &lt;code&gt;+&lt;/code&gt;, exclusions with &lt;code&gt;-&lt;/code&gt; and double-quotes around whitespace. Of the possible wildcards, &lt;code&gt;git p4&lt;/code&gt; only handles &lt;code&gt;&amp;hellip;​&lt;/code&gt;, and only when it is at the end of the path. &lt;code&gt;git p4&lt;/code&gt; will complain if it encounters an unhandled wildcard.</source>
          <target state="translated">p4보기의 전체 구문은 &lt;code&gt;p4 help views&lt;/code&gt; 설명되어 있습니다 . &lt;code&gt;git p4&lt;/code&gt; 는 뷰 구문의 하위 집합 만 알고 있습니다. 여러 줄 매핑, &lt;code&gt;+&lt;/code&gt; 오버레이 , 공백 주위의 &lt;code&gt;-&lt;/code&gt; 및 큰 따옴표 제외를 이해 합니다. 가능한 와일드 카드, &lt;code&gt;git p4&lt;/code&gt; 만 핸들 &lt;code&gt;&amp;hellip;​&lt;/code&gt; , 그것은 경로 끝에 때만. &lt;code&gt;git p4&lt;/code&gt; 는 처리되지 않은 와일드 카드가 발생하면 불평합니다.</target>
        </trans-unit>
        <trans-unit id="18d1519c9cf5420b92be3f082cd6f0aa89c3d260" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;skip_commit&lt;/code&gt; is defined as follows:</source>
          <target state="translated">&lt;code&gt;skip_commit&lt;/code&gt; 함수 는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="af7dd50b5e9b3d3ec2ae519f399794527002dc23" translate="yes" xml:space="preserve">
          <source>The functions defined by the Trace2 API are declared and documented in &lt;code&gt;trace2.h&lt;/code&gt;. It defines the API functions and wrapper macros for Trace2.</source>
          <target state="translated">Trace2 API에 의해 정의 된 함수 선언에 설명되어 있습니다 &lt;code&gt;trace2.h&lt;/code&gt; . Trace2의 API 함수 및 랩퍼 매크로를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e5521fd46bed9d589b56b651d5f3ef04e9a3b2a8" translate="yes" xml:space="preserve">
          <source>The future of bisecting</source>
          <target state="translated">이등분의 미래</target>
        </trans-unit>
        <trans-unit id="2aa4427c10c7d5c13ef7bbb9898f5fea28090dd1" translate="yes" xml:space="preserve">
          <source>The general idea is this: we generate a cost matrix between the commits in both commit ranges, then solve the least-cost assignment.</source>
          <target state="translated">일반적인 아이디어는 다음과 같습니다. 두 커밋 범위에서 커밋간에 비용 매트릭스를 생성 한 다음 최소 비용 할당을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="0339eef2339eb8367ea8564b9ff6721cd9dea407" translate="yes" xml:space="preserve">
          <source>The git commit is created relative to the current origin revision (HEAD by default). A parent commit is created based on the origin, and then the unshelve commit is created based on that.</source>
          <target state="translated">git commit은 현재 원점 개정판 (기본적으로 HEAD)을 기준으로 작성됩니다. 원본 커밋을 기반으로 부모 커밋이 생성 된 다음이를 기반으로 unshelve 커밋이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a5bbcd1beb35762403be84a14e62e0a4eb5d5226" translate="yes" xml:space="preserve">
          <source>The git object database</source>
          <target state="translated">자식 객체 데이터베이스</target>
        </trans-unit>
        <trans-unit id="80d403b9b878573aec88e9c705123dc6feedf769" translate="yes" xml:space="preserve">
          <source>The gitweb CGI script for viewing Git repositories over the web uses a perl script fragment as its configuration file. You can set variables using &quot;&lt;code&gt;our $variable = value&lt;/code&gt;&quot;; text from a &quot;#&quot; character until the end of a line is ignored. See &lt;strong&gt;perlsyn&lt;/strong&gt;(1) for details.</source>
          <target state="translated">웹에서 Git 리포지토리를보기위한 gitweb CGI 스크립트는 구성 파일로 perl 스크립트 조각을 사용합니다. &quot; &lt;code&gt;our $variable = value&lt;/code&gt; &quot;;를 사용하여 변수를 설정할 수 있습니다 . &quot;#&quot;문자부터 줄 끝까지의 텍스트는 무시됩니다. 자세한 내용은 &lt;strong&gt;perlsyn&lt;/strong&gt; (1)을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a1a6c42c76028a67bf39dd75b77a2307812be731" translate="yes" xml:space="preserve">
          <source>The gitweb cgi script provides users an easy way to browse your project&amp;rsquo;s revisions, file contents and logs without having to install Git. Features like RSS/Atom feeds and blame/annotation details may optionally be enabled.</source>
          <target state="translated">gitweb cgi 스크립트는 Git을 설치하지 않고도 프로젝트 개정, 파일 내용 및 로그를 쉽게 탐색 할 수있는 방법을 제공합니다. RSS / Atom 피드 및 Blame / Annotation 세부 사항과 같은 기능을 선택적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eefcb42be74db518327d9c82beb9a165d884846e" translate="yes" xml:space="preserve">
          <source>The gitweb features that are configurable via &lt;code&gt;%feature&lt;/code&gt; hash are listed below. This should be a complete list, but ultimately the authoritative and complete list is in gitweb.cgi source code, with features described in the comments.</source>
          <target state="translated">&lt;code&gt;%feature&lt;/code&gt; 해시 를 통해 구성 할 수있는 gitweb 기능이 아래에 나열되어 있습니다. 이것은 완전한 목록이어야하지만 궁극적으로 권위 있고 완전한 목록은 gitweb.cgi 소스 코드에 있으며 주석에 설명 된 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bee84a897df9efb668b9aee969a1e660ed8af0a4" translate="yes" xml:space="preserve">
          <source>The gitweb.extraBranchRefs is actually a multi-valued configuration variable, so following example is also correct and the result is the same as of the snippet above:</source>
          <target state="translated">gitweb.extraBranchRefs는 실제로 다중 값 구성 변수이므로 다음 예제도 정확하며 결과는 위의 스 니펫과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ab9a5e4603e46ba18e0a4c5efe881c7ac8def35b" translate="yes" xml:space="preserve">
          <source>The given URL is recorded into &lt;code&gt;.gitmodules&lt;/code&gt; for use by subsequent users cloning the superproject. If the URL is given relative to the superproject&amp;rsquo;s repository, the presumption is the superproject and submodule repositories will be kept together in the same relative location, and only the superproject&amp;rsquo;s URL needs to be provided. git-submodule will correctly locate the submodule using the relative URL in &lt;code&gt;.gitmodules&lt;/code&gt;.</source>
          <target state="translated">주어진 URL은 수퍼 프로젝트를 복제하는 후속 사용자가 사용할 수 있도록 &lt;code&gt;.gitmodules&lt;/code&gt; 에 기록됩니다 . URL이 수퍼 프로젝트의 저장소와 관련하여 제공되는 경우 수퍼 프로젝트와 하위 모듈 저장소는 동일한 상대 위치에 함께 유지되며 수퍼 프로젝트의 URL 만 제공하면됩니다. git-submodule은 &lt;code&gt;.gitmodules&lt;/code&gt; 의 상대 URL을 사용하여 서브 모듈을 올바르게 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="1190edfebfe2406cf333713a0e461379865b033f" translate="yes" xml:space="preserve">
          <source>The goal of this tutorial is to introduce two fundamental pieces of Git&amp;rsquo;s architecture&amp;mdash;​the object database and the index file&amp;mdash;​and to provide the reader with everything necessary to understand the rest of the Git documentation.</source>
          <target state="translated">이 튜토리얼의 목적은 Git 아키텍처의 두 가지 기본 요소 인 객체 데이터베이스와 인덱스 파일을 소개하고 나머지 Git 문서를 이해하는 데 필요한 모든 것을 독자에게 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="880a291c14c1099392ebdd9b73ec08c93b7220d1" translate="yes" xml:space="preserve">
          <source>The hard case</source>
          <target state="translated">어려운 경우</target>
        </trans-unit>
        <trans-unit id="71b4cfb50bd8944708a6926991c13ef0bfbac07d" translate="yes" xml:space="preserve">
          <source>The hashes are 40 hex characters long. When Git upgrades to a new hash algorithm, this might need to be updated. (It should match whatever index-pack outputs after &quot;pack\t&quot; or &quot;keep\t&quot;.</source>
          <target state="translated">The hashes are 40 hex characters long. When Git upgrades to a new hash algorithm, this might need to be updated. (It should match whatever index-pack outputs after &quot;pack\t&quot; or &quot;keep\t&quot;.</target>
        </trans-unit>
        <trans-unit id="7d2a187748caf680c0e66173f60176ec60ea02ab" translate="yes" xml:space="preserve">
          <source>The header consists of 256 4-byte network byte order integers. N-th entry of this table records the number of objects in the corresponding pack, the first byte of whose object name is less than or equal to N. This is called the &lt;code&gt;first-level fan-out&lt;/code&gt; table.</source>
          <target state="translated">헤더는 256 4 바이트 네트워크 바이트 순서 정수로 구성됩니다. 이 테이블의 N 번째 항목은 해당 팩에있는 오브젝트의 수를 기록합니다. 첫 번째 바이트의 오브젝트 이름은 N보다 작거나 같습니다.이를 &lt;code&gt;first-level fan-out&lt;/code&gt; 테이블이라고합니다.</target>
        </trans-unit>
        <trans-unit id="0e2dd021a6a8dc94bfb40a62a04904f17b8f1dab" translate="yes" xml:space="preserve">
          <source>The header is followed by number of object entries, each of which looks like this:</source>
          <target state="translated">헤더 다음에는 여러 개의 객체 항목이 있으며 각 항목은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10743ced5c1563e940127b440ba806235a399ac8" translate="yes" xml:space="preserve">
          <source>The header is followed by sorted 24-byte entries, one entry per object in the pack. Each entry is:</source>
          <target state="translated">헤더 다음에는 팩의 오브젝트 당 하나의 항목으로 정렬 된 24 바이트 항목이 있습니다. 각 항목은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="03910dca7f1c0af7f3d0e6986f455aceaec86f05" translate="yes" xml:space="preserve">
          <source>The header of the email is configurable via command-line options. If not specified on the command line, the user will be prompted with a ReadLine enabled interface to provide the necessary information.</source>
          <target state="translated">이메일 헤더는 명령 행 옵션을 통해 구성 할 수 있습니다. 명령 행에 지정되지 않은 경우 필요한 정보를 제공하기 위해 ReadLine 사용 인터페이스가 프롬프트됩니다.</target>
        </trans-unit>
        <trans-unit id="53d28fdf80ee055eff1005765033449c285d4f79" translate="yes" xml:space="preserve">
          <source>The hook always runs after the automatic note copying (see &quot;notes.rewrite.&amp;lt;command&amp;gt;&quot; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) has happened, and thus has access to these notes.</source>
          <target state="translated">후크는 자동 노트 복사 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1]의&lt;/a&gt; &quot;notes.rewrite. &amp;lt;command&amp;gt;&quot;참조)가 발생한 후에 항상 실행 되므로 이러한 노트에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55997df4465d2b793292e1300e70ff2f9e1a3588" translate="yes" xml:space="preserve">
          <source>The hook executes once for each ref to be updated, and takes three parameters:</source>
          <target state="translated">후크는 각 참조가 업데이트 될 때마다 한 번씩 실행되며 세 개의 매개 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7918f32150a1e75fa34aeef2474d601c36b3a718" translate="yes" xml:space="preserve">
          <source>The hook is allowed to edit the changelist file and can be used to normalize the text into some project standard format. It can also be used to refuse the Submit after inspect the message file.</source>
          <target state="translated">The hook is allowed to edit the changelist file and can be used to normalize the text into some project standard format. It can also be used to refuse the Submit after inspect the message file.</target>
        </trans-unit>
        <trans-unit id="6422fdbff7a8b80abf6e11b9c756369981239875" translate="yes" xml:space="preserve">
          <source>The hook is allowed to edit the message file in place, and can be used to normalize the message into some project standard format. It can also be used to refuse the commit after inspecting the message file.</source>
          <target state="translated">후크는 메시지 파일을 제자리에서 편집 할 수 있으며 메시지를 일부 프로젝트 표준 형식으로 정규화하는 데 사용할 수 있습니다. 메시지 파일을 검사 한 후 커밋을 거부하는 데 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dd8785c8f6fdd3a8a45999afa9f773631b556f1" translate="yes" xml:space="preserve">
          <source>The hook receives a list of the rewritten commits on stdin, in the format</source>
          <target state="translated">후크는 stdin에서 다시 작성된 커밋 목록을 형식으로받습니다.</target>
        </trans-unit>
        <trans-unit id="ffb0d43685532aa46e893849969758ab23367451" translate="yes" xml:space="preserve">
          <source>The hook receives the commit with which the tip of the current branch is going to be updated. It can exit with a non-zero status to refuse the push (when it does so, it must not modify the index or the working tree). Or it can make any necessary changes to the working tree and to the index to bring them to the desired state when the tip of the current branch is updated to the new commit, and exit with a zero status.</source>
          <target state="translated">후크는 현재 분기의 팁이 업데이트 될 커밋을 수신합니다. 푸시를 거부하기 위해 0이 아닌 상태로 종료 할 수 있습니다 (그렇게 할 경우 인덱스 또는 작업 트리를 수정해서는 안 됨). 또는 현재 분기의 끝이 새 커밋으로 업데이트 될 때 작업 트리와 인덱스를 원하는 상태로 가져 와서 0으로 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e0236cadc345b5114c4c6984e7438ed153e1f2f" translate="yes" xml:space="preserve">
          <source>The hook should exit with non-zero status if it wants to disallow updating the named ref. Otherwise it should exit with zero.</source>
          <target state="translated">명명 된 참조를 업데이트하지 않으려면 후크가 0이 아닌 상태로 종료해야합니다. 그렇지 않으면 0으로 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="9739d79c49b82b53238e48aeefee9c342d93a499" translate="yes" xml:space="preserve">
          <source>The hook should output to stdout the list of all files in the working directory that may have changed since the requested time. The logic should be inclusive so that it does not miss any potential changes. The paths should be relative to the root of the working directory and be separated by a single NUL.</source>
          <target state="translated">요청 된 시간 이후 변경되었을 수있는 작업 디렉토리의 모든 파일 목록을 stdout하기 위해 후크가 출력되어야합니다. 잠재적 인 변경 사항을 놓치지 않도록 논리가 포괄적이어야합니다. 경로는 작업 디렉토리의 루트에 상대적이어야하며 단일 NUL로 구분되어야합니다.</target>
        </trans-unit>
        <trans-unit id="726cd696e8b088103d80193483306d60860caef4" translate="yes" xml:space="preserve">
          <source>The hook takes exactly one argument, which is the current state the given reference transaction is in:</source>
          <target state="translated">The hook takes exactly one argument, which is the current state the given reference transaction is in:</target>
        </trans-unit>
        <trans-unit id="022998a9843b7be307eb2d587f13704cf2ce86bd" translate="yes" xml:space="preserve">
          <source>The horizontal line of history A---Q is taken to be the first parent of each merge. The commits are:</source>
          <target state="translated">히스토리 A--Q의 수평선은 각 병합의 첫 번째 상위로 간주됩니다. 커밋은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41f47ff55448de90533c1d6461f6a54aa470a338" translate="yes" xml:space="preserve">
          <source>The human-readable name used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;author.name&lt;/code&gt; configuration settings.</source>
          <target state="translated">The human-readable name used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;author.name&lt;/code&gt; configuration settings.</target>
        </trans-unit>
        <trans-unit id="65a50b3e42cc3505776fea766e525fbf7e68884e" translate="yes" xml:space="preserve">
          <source>The human-readable name used in the committer identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;committer.name&lt;/code&gt; configuration settings.</source>
          <target state="translated">The human-readable name used in the committer identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;committer.name&lt;/code&gt; configuration settings.</target>
        </trans-unit>
        <trans-unit id="bdf0ebdfb4273a6fce7952dfa28834b6e411cd7f" translate="yes" xml:space="preserve">
          <source>The hypothetical proxy command entries actually have a postfix to discern what URL they apply to. Here is how to change the entry for kernel.org to &quot;ssh&quot;.</source>
          <target state="translated">가상 프록시 명령 항목에는 실제로 적용 할 URL을 식별하기위한 접미사가 있습니다. 다음은 kernel.org의 항목을 &quot;ssh&quot;로 변경하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="4399284bfb632a08cce3f3533db563320f49af23" translate="yes" xml:space="preserve">
          <source>The id of a tree object to diff against.</source>
          <target state="translated">비교할 트리 객체의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="0505b9e9f78e78efa1c8b76bc422638cba05b1b7" translate="yes" xml:space="preserve">
          <source>The id of a tree object.</source>
          <target state="translated">트리 객체의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="2e60e84271eec03fd28b067b32c84bb5fbe76999" translate="yes" xml:space="preserve">
          <source>The id of the tree object(s) to be read/merged.</source>
          <target state="translated">읽거나 병합 할 트리 개체의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="fb9074ec22bab96e3e97d4855db9bfaed224187c" translate="yes" xml:space="preserve">
          <source>The idea is that every 3 test for example, &quot;git bisect&quot; could ask the user to test a commit that has already been found to be &quot;good&quot; or &quot;bad&quot; (because one of its descendants or one of its ancestors has been found to be &quot;good&quot; or &quot;bad&quot; respectively). If it happens that a commit has been previously incorrectly classified then the bisection can be aborted early, hopefully before too many mistakes have been made. Then the user will have to look at what happened and then restart the bisection using a fixed bisect log.</source>
          <target state="translated">예를 들어, &quot;git bisect&quot;와 같은 3 가지 테스트마다 &quot;좋은&quot;또는 &quot;나쁜&quot;것으로 판명 된 커밋을 테스트하도록 요청할 수 있습니다 (자손 중 하나 또는 조상 중 하나가 발견 되었기 때문에) '좋은'또는 '나쁜' 커밋이 이전에 잘못 분류 된 경우 너무 많은 실수가 있기 전에 이분법이 일찍 중단 될 수 있습니다. 그런 다음 사용자는 발생한 상황을 확인한 다음 고정 된 이등분 로그를 사용하여 이분법을 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="b3a07b8c786a1b03697e9ded467b22cd2ece1ab4" translate="yes" xml:space="preserve">
          <source>The idea is to manually tell &lt;code&gt;git rebase&lt;/code&gt; &quot;where the old &lt;code&gt;subsystem&lt;/code&gt; ended and your &lt;code&gt;topic&lt;/code&gt; began&quot;, that is, what the old merge base between them was. You will have to find a way to name the last commit of the old &lt;code&gt;subsystem&lt;/code&gt;, for example:</source>
          <target state="translated">아이디어는 수동으로 &lt;code&gt;git rebase&lt;/code&gt; 에게 &quot;오래된 &lt;code&gt;subsystem&lt;/code&gt; 종료되고 &lt;code&gt;topic&lt;/code&gt; 시작된 위치&quot;, 즉 그들 사이의 기존 병합베이스가 무엇인지를 알려주는 것입니다. 예를 들어, 이전 &lt;code&gt;subsystem&lt;/code&gt; 의 마지막 커밋 이름을 지정하는 방법을 찾아야합니다 .</target>
        </trans-unit>
        <trans-unit id="1ff2a3a30d68d12ef6b058f357f43e3bd9cd4f0f" translate="yes" xml:space="preserve">
          <source>The idx files to verify.</source>
          <target state="translated">확인할 idx 파일</target>
        </trans-unit>
        <trans-unit id="fd29bd486dc43b124e6d98a808e18b86c2905ae4" translate="yes" xml:space="preserve">
          <source>The import checks out from CVS every revision of every file. Reportedly cvsimport can average some twenty revisions per second, so for a medium-sized project this should not take more than a couple of minutes. Larger projects or remote repositories may take longer.</source>
          <target state="translated">가져 오기는 모든 파일의 모든 개정판을 CVS에서 체크 아웃합니다. 보도에 따르면 cvsimport는 초당 평균 20 회의 수정을 수행 할 수 있으므로 중간 규모 프로젝트의 경우 몇 분 이상 걸리지 않아야합니다. 더 큰 프로젝트 또는 원격 저장소는 더 오래 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69f04e00f7076b8b130e67c7134e53f7f1076bf2" translate="yes" xml:space="preserve">
          <source>The import is incremental, so if you call it again next month it will fetch any CVS updates that have been made in the meantime. For this to work, you must not modify the imported branches; instead, create new branches for your own changes, and merge in the imported branches as necessary.</source>
          <target state="translated">가져 오기는 증분이므로 다음 달에 다시 호출하면 그 동안 작성된 CVS 업데이트를 가져옵니다. 이렇게하려면 가져온 분기를 수정하지 않아야합니다. 대신, 자신의 변경 사항에 대한 새 분기를 만들고 필요에 따라 가져온 분기를 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="807035ab1f5be4f0cb3563dc9b49740571ca0fa4" translate="yes" xml:space="preserve">
          <source>The index</source>
          <target state="translated">색인</target>
        </trans-unit>
        <trans-unit id="4284ed429265f3c1afc30e4fc09197d88352698c" translate="yes" xml:space="preserve">
          <source>The index and the working tree are adjusted as if you had previously run &lt;code&gt;git checkout &amp;lt;start_point&amp;gt;&lt;/code&gt;. This allows you to start a new history that records a set of paths similar to &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; by easily running &lt;code&gt;git commit -a&lt;/code&gt; to make the root commit.</source>
          <target state="translated">인덱스와 작업 트리는 이전에 &lt;code&gt;git checkout &amp;lt;start_point&amp;gt;&lt;/code&gt; 를 실행 한 것처럼 조정됩니다 . 이를 통해 &lt;code&gt;git commit -a&lt;/code&gt; 를 쉽게 실행 하여 루트 커밋을 만들어 &lt;code&gt;&amp;lt;start_point&amp;gt;&lt;/code&gt; 와 비슷한 경로 집합을 기록하는 새 기록을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0818281aa21612fb5fa362015c64c5645d861084" translate="yes" xml:space="preserve">
          <source>The index contains all the information necessary to generate a single (uniquely determined) tree object.</source>
          <target state="translated">색인에는 단일 (독특하게 결정된) 트리 오브젝트를 생성하는 데 필요한 모든 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3d9fb9e020c0d003a42d72f87f16ba2ba38226e6" translate="yes" xml:space="preserve">
          <source>The index enables fast comparisons between the tree object it defines and the working tree.</source>
          <target state="translated">인덱스를 사용하면 정의한 트리 개체와 작업 트리를 빠르게 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb65460c6179ccddcd4479166e9da44d8f5c40d8" translate="yes" xml:space="preserve">
          <source>The index file</source>
          <target state="translated">색인 파일</target>
        </trans-unit>
        <trans-unit id="181ab401ce7a15640077d5cb413c24fc6eb6a97e" translate="yes" xml:space="preserve">
          <source>The index file is a cache of the state of a directory tree, used to create commits, check out working directories, and hold the various trees involved in a merge.</source>
          <target state="translated">인덱스 파일은 디렉토리 트리 상태의 캐시로, 커밋을 생성하고 작업 디렉토리를 체크 아웃하며 병합과 관련된 다양한 트리를 보유하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a98935eae61bfe66b9928e790965f624bf2f8b5b" translate="yes" xml:space="preserve">
          <source>The index file is initialized with a list of all paths and, for each path, a blob object and a set of attributes. The blob object represents the contents of the file as of the head of the current branch. The attributes (last modified time, size, etc.) are taken from the corresponding file in the working tree. Subsequent changes to the working tree can be found by comparing these attributes. The index may be updated with new content, and new commits may be created from the content stored in the index.</source>
          <target state="translated">인덱스 파일은 모든 경로 목록과 각 경로에 대해 BLOB 개체 및 특성 집합으로 초기화됩니다. Blob 객체는 현재 분기의 헤드를 기준으로 파일의 내용을 나타냅니다. 속성 (마지막으로 수정 한 시간, 크기 등)은 작업 트리의 해당 파일에서 가져옵니다. 작업 트리에 대한 후속 변경 사항은이 속성을 비교하여 찾을 수 있습니다. 인덱스는 새로운 컨텐츠로 업데이트 될 수 있으며 인덱스에 저장된 컨텐츠에서 새로운 커밋이 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="803387e9a63472a3287bdc2446032cf6e023e1d9" translate="yes" xml:space="preserve">
          <source>The index is a binary file (generally kept in &lt;code&gt;.git/index&lt;/code&gt;) containing a sorted list of path names, each with permissions and the SHA-1 of a blob object; &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files[1]&lt;/a&gt; can show you the contents of the index:</source>
          <target state="translated">인덱스는 경로 이름의 정렬 된 목록을 포함 하는 이진 파일 (일반적으로 &lt;code&gt;.git/index&lt;/code&gt; 로 유지됨 )이며 각각은 권한과 BLOB 개체의 SHA-1을 갖습니다. &lt;a href=&quot;git-ls-files&quot;&gt;git-ls-files [1]&lt;/a&gt; 은 인덱스의 내용을 보여줄 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a9316182499a37d7c3626ac01aa8aab4c013b473" translate="yes" xml:space="preserve">
          <source>The index is also capable of storing multiple entries (called &quot;stages&quot;) for a given pathname. These stages are used to hold the various unmerged version of a file when a merge is in progress.</source>
          <target state="translated">색인은 또한 주어진 경로 이름에 대해 여러 항목 ( &quot;단계&quot;)을 저장할 수 있습니다. 이 단계는 병합이 진행될 때 병합되지 않은 다양한 버전의 파일을 보유하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="188f5a2d7cb942916f4771a1884b995e88b4142c" translate="yes" xml:space="preserve">
          <source>The index is thus a sort of temporary staging area, which is filled with a tree which you are in the process of working on.</source>
          <target state="translated">따라서 인덱스는 일종의 임시 준비 영역으로, 작업중인 트리로 채워져 있습니다.</target>
        </trans-unit>
        <trans-unit id="272f4c7f98ef3d0d8ac3fea3ee0b1455507c7b6c" translate="yes" xml:space="preserve">
          <source>The index is updated after successful completion, but the change must still be committed.</source>
          <target state="translated">성공적으로 완료된 후에는 색인이 업데이트되지만 변경 사항은 계속 커밋해야합니다.</target>
        </trans-unit>
        <trans-unit id="aaf3f3d73cad6f7ed8d83d0912688100fa696756" translate="yes" xml:space="preserve">
          <source>The index line includes the blob object names before and after the change. The &amp;lt;mode&amp;gt; is included if the file mode does not change; otherwise, separate lines indicate the old and the new mode.</source>
          <target state="translated">색인 줄에는 변경 전후의 얼룩 개체 이름이 포함됩니다. 파일 모드가 변경되지 않으면 &amp;lt;mode&amp;gt;가 포함됩니다. 그렇지 않으면 별도의 줄이 이전 및 새 모드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0c2192b5aebec33a414387c35e4e32f7ffc2561e" translate="yes" xml:space="preserve">
          <source>The index may contain unmerged entries because of a previous failed merge. By default, if you try to check out such an entry from the index, the checkout operation will fail and nothing will be checked out. Using &lt;code&gt;-f&lt;/code&gt; will ignore these unmerged entries. The contents from a specific side of the merge can be checked out of the index by using &lt;code&gt;--ours&lt;/code&gt; or &lt;code&gt;--theirs&lt;/code&gt;. With &lt;code&gt;-m&lt;/code&gt;, changes made to the working tree file can be discarded to re-create the original conflicted merge result.</source>
          <target state="translated">이전에 실패한 병합으로 인해 색인에 병합되지 않은 항목이 포함될 수 있습니다. 기본적으로 색인에서 이러한 항목을 체크 아웃하려고하면 체크 아웃 조작이 실패하고 체크 아웃되지 않습니다. &lt;code&gt;-f&lt;/code&gt; 를 사용하면 병합되지 않은 항목은 무시됩니다. 병합의 특정 측면에있는 내용은 &lt;code&gt;--ours&lt;/code&gt; 또는 &lt;code&gt;--theirs&lt;/code&gt; 를 사용하여 색인에서 확인할 수 있습니다 . 함께 &lt;code&gt;-m&lt;/code&gt; , 다시 만들 원래 충돌 병합 결과에 폐기 될 수 작업 트리 파일에 변경합니다.</target>
        </trans-unit>
        <trans-unit id="4d0d51f29d49355316c3cef38c96a8eb5dfc2a8a" translate="yes" xml:space="preserve">
          <source>The index must be in a fully merged state.</source>
          <target state="translated">인덱스는 완전히 병합 된 상태 여야합니다.</target>
        </trans-unit>
        <trans-unit id="76af7fc7918327fcfae98949c1f8a57aa6273691" translate="yes" xml:space="preserve">
          <source>The information &lt;code&gt;git rerere&lt;/code&gt; records is also used when running &lt;code&gt;git rebase&lt;/code&gt;. After blowing away the test merge and continuing development on the topic branch:</source>
          <target state="translated">정보 &lt;code&gt;git rerere&lt;/code&gt; 레코드는 &lt;code&gt;git rebase&lt;/code&gt; 를 실행할 때도 사용됩니다 . 테스트 병합을 날려 버리고 주제 분기에서 개발을 계속 한 후 :</target>
        </trans-unit>
        <trans-unit id="15901a24c7f8cf8a87522005a6e5af387df87a55" translate="yes" xml:space="preserve">
          <source>The information regarding a particular file, stored in the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt;. An index entry can be unmerged, if a &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; was started, but not yet finished (i.e. if the index contains multiple versions of that file).</source>
          <target state="translated">&lt;a href=&quot;#def_index&quot;&gt;index에&lt;/a&gt; 저장된 특정 파일에 관한 정보 . &lt;a href=&quot;#def_merge&quot;&gt;병합&lt;/a&gt; 이 시작되었지만 아직 완료되지 않은 경우 (즉, 색인에 해당 파일의 여러 버전이 포함 된 경우) 색인 항목을 병합 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1b41d54924f3d005ef481db0b83a44bcb5b9a26" translate="yes" xml:space="preserve">
          <source>The initial &lt;code&gt;git svn clone&lt;/code&gt; can be quite time-consuming (especially for large Subversion repositories). If multiple people (or one person with multiple machines) want to use &lt;code&gt;git svn&lt;/code&gt; to interact with the same Subversion repository, you can do the initial &lt;code&gt;git svn clone&lt;/code&gt; to a repository on a server and have each person clone that repository with &lt;code&gt;git clone&lt;/code&gt;:</source>
          <target state="translated">초기 &lt;code&gt;git svn clone&lt;/code&gt; 은 특히 ​​많은 Subversion 저장소의 경우 시간이 오래 걸릴 수 있습니다. 여러 사람 (또는 여러 시스템을 가진 한 사람)이 &lt;code&gt;git svn&lt;/code&gt; 을 사용하여 동일한 Subversion 저장소와 상호 작용 하려는 경우 초기 &lt;code&gt;git svn clone&lt;/code&gt; 를 서버의 저장소에 수행하고 각 사람이 해당 저장소를 &lt;code&gt;git clone&lt;/code&gt; 으로 복제하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="086eba2d4da1f4350d7506d860bddbb6a3656718" translate="yes" xml:space="preserve">
          <source>The initial clone may be time-consuming for a large project, but you will only need to clone once.</source>
          <target state="translated">대규모 프로젝트의 경우 초기 복제에 시간이 오래 걸릴 수 있지만 한 번만 복제하면됩니다.</target>
        </trans-unit>
        <trans-unit id="de40e4660568a286f9924fcf84aa107b9295fcd9" translate="yes" xml:space="preserve">
          <source>The initial revision lays the foundation for almost everything Git has today, but is small enough to read in one sitting.</source>
          <target state="translated">초기 개정판은 오늘날 Git의 거의 모든 것을위한 토대를 마련하지만 한 번에 읽을 수있을 정도로 작습니다.</target>
        </trans-unit>
        <trans-unit id="c62040180edff3420ed3a70f2f1e520bccaa26ac" translate="yes" xml:space="preserve">
          <source>The insane thing. You really want to call the new version &quot;X&quot; too, &lt;code&gt;even though&lt;/code&gt; others have already seen the old one. So just use &lt;code&gt;git tag -f&lt;/code&gt; again, as if you hadn&amp;rsquo;t already published the old one.</source>
          <target state="translated">미친 것. 다른 사람들이 이미 이전 버전을 &lt;code&gt;even though&lt;/code&gt; 새 버전 &quot;X&quot;도 호출하려고합니다 . 따라서 이전 &lt;code&gt;git tag -f&lt;/code&gt; 아직 게시하지 않은 것처럼 git tag -f를 다시 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="861707a12241605e66eb9230fb32f3c54a08448e" translate="yes" xml:space="preserve">
          <source>The intent of this option is to pick and choose lines of the patch to apply, or even to modify the contents of lines to be staged. This can be quicker and more flexible than using the interactive hunk selector. However, it is easy to confuse oneself and create a patch that does not apply to the index. See EDITING PATCHES below.</source>
          <target state="translated">이 옵션의 목적은 적용 할 패치의 행을 선택하여 선택하거나 스테이징 할 행의 내용을 수정하는 것입니다. 이것은 대화식 덩어리 선택기를 사용하는 것보다 더 빠르고 유연 할 수 있습니다. 그러나 자신을 혼동하고 색인에 적용되지 않는 패치를 만드는 것은 쉽습니다. 아래의 패치 편집을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="44c76b656c6ccb35aba2b96c920b5e782121a3bc" translate="yes" xml:space="preserve">
          <source>The interactive backend drops commits by default that started empty and halts if it hits a commit that ended up empty. The &lt;code&gt;--keep-empty&lt;/code&gt; option exists for the interactive backend to allow it to keep commits that started empty.</source>
          <target state="translated">대화식 백엔드는 기본적으로 비어있는 시작된 커밋을 삭제하고 비어있는 커밋에 도달하면 중지됩니다. &lt;code&gt;--keep-empty&lt;/code&gt; 옵션은 빈 시작 커밋을 유지 할 수 있도록 대화 형 백엔드 존재합니다.</target>
        </trans-unit>
        <trans-unit id="c4d1b3aab1a5f39909af0bdb9766437575ff6138" translate="yes" xml:space="preserve">
          <source>The interactive mode is meant for this type of workflow:</source>
          <target state="translated">대화식 모드는 다음 유형의 워크 플로우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bed5d62a356c4ef72d5d10899b110555c8810a69" translate="yes" xml:space="preserve">
          <source>The interactive rebase command was originally designed to handle individual patch series. As such, it makes sense to exclude merge commits from the todo list, as the developer may have merged the then-current &lt;code&gt;master&lt;/code&gt; while working on the branch, only to rebase all the commits onto &lt;code&gt;master&lt;/code&gt; eventually (skipping the merge commits).</source>
          <target state="translated">대화식 rebase 명령은 원래 개별 패치 시리즈를 처리하도록 설계되었습니다. 따라서, 그것은 개발자가 당시 합병 한 수 있으므로, 할 일 목록에서 병합 커밋을 제외하는 것이 합리적 &lt;code&gt;master&lt;/code&gt; 브랜치에서 작업하는 동안 단지 위에 모든 커밋 리베이스하는, &lt;code&gt;master&lt;/code&gt; (병합 커밋 생략) 결국합니다.</target>
        </trans-unit>
        <trans-unit id="54aff08446e09f30da133e329eb3f3646033c66c" translate="yes" xml:space="preserve">
          <source>The interactive rebase will stop when a command fails (i.e. exits with non-0 status) to give you an opportunity to fix the problem. You can continue with &lt;code&gt;git rebase --continue&lt;/code&gt;.</source>
          <target state="translated">명령이 실패하면 (예 : 0이 아닌 상태로 종료) 대화식 리베이스가 중지되어 문제를 해결할 수있는 기회를 제공합니다. &lt;code&gt;git rebase --continue&lt;/code&gt; 로 계속 진행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a7f537099e4a0d8d8faba9c5e743d565b88b9dd" translate="yes" xml:space="preserve">
          <source>The interface (input, output, set of options and the semantics) to these low-level commands are meant to be a lot more stable than Porcelain level commands, because these commands are primarily for scripted use. The interface to Porcelain commands on the other hand are subject to change in order to improve the end user experience.</source>
          <target state="translated">이러한 하위 수준 명령에 대한 인터페이스 (입력, 출력, 옵션 집합 및 의미론)는 주로 스크립트 용도로 사용되므로 Porcelain 수준 명령보다 훨씬 안정적입니다. 반면에 Porcelain 명령에 대한 인터페이스는 최종 사용자 경험을 향상시키기 위해 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf907bc1bbd0905aa866d8781057341315704641" translate="yes" xml:space="preserve">
          <source>The internal block size to use when converting a revision specifier such as &lt;code&gt;@all&lt;/code&gt; into a list of specific change numbers. Instead of using a single call to &lt;code&gt;p4 changes&lt;/code&gt; to find the full list of changes for the conversion, there are a sequence of calls to &lt;code&gt;p4 changes -m&lt;/code&gt;, each of which requests one block of changes of the given size. The default block size is 500, which should usually be suitable.</source>
          <target state="translated">&lt;code&gt;@all&lt;/code&gt; 과 같은 개정 지정자 를 특정 변경 번호 목록 으로 변환 할 때 사용할 내부 블록 크기 입니다. &lt;code&gt;p4 changes&lt;/code&gt; 에 대한 단일 호출을 사용 하여 변환에 대한 전체 변경 사항 목록을 찾는 대신 , &lt;code&gt;p4 changes -m&lt;/code&gt; 에 대한 호출 순서가 있습니다. 각 호출 은 지정된 크기의 한 변경 블록을 요청합니다. 기본 블록 크기는 500이며 일반적으로 적합합니다.</target>
        </trans-unit>
        <trans-unit id="b58ee91a98701b75ecd0edc6713c67b3efbc3330" translate="yes" xml:space="preserve">
          <source>The internals are documented in the &lt;a href=&quot;api-index&quot;&gt;Git API documentation&lt;/a&gt;.</source>
          <target state="translated">내부는 &lt;a href=&quot;api-index&quot;&gt;Git API 문서에 문서화되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="52e0ef5f6de2b43e809ff876c18bbee69e575471" translate="yes" xml:space="preserve">
          <source>The key may contain any bytes except &lt;code&gt;=&lt;/code&gt;, newline, or NUL. The value may contain any bytes except newline or NUL.</source>
          <target state="translated">The key may contain any bytes except &lt;code&gt;=&lt;/code&gt; , newline, or NUL. The value may contain any bytes except newline or NUL.</target>
        </trans-unit>
        <trans-unit id="051387312310d89e1f2cd1a7644ba37793a94a7c" translate="yes" xml:space="preserve">
          <source>The known attack vectors are as follows:</source>
          <target state="translated">알려진 공격 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d0880a7ce92ec68d75b7997f1b8b330766294029" translate="yes" xml:space="preserve">
          <source>The lack of a central group of &quot;committers&quot; means there is less need for formal decisions about who is &quot;in&quot; and who is &quot;out&quot;.</source>
          <target state="translated">중앙 집중된 &quot;커미터&quot;그룹이 없다는 것은 &quot;내부&quot;와 &quot;외부&quot;에 대한 공식 결정이 덜 필요하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d217f82f775261a888c8090d4fd57de90a2943db" translate="yes" xml:space="preserve">
          <source>The last diff is empty, but no new commits have been made, and the head still doesn&amp;rsquo;t contain the new line:</source>
          <target state="translated">마지막 diff는 비어 있지만 새로운 커밋은 없었으며 헤드에는 여전히 새로운 줄이 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc6ae42476a6037281df209d5a37adfb042c084d" translate="yes" xml:space="preserve">
          <source>The last three commits (&lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;HEAD^&lt;/code&gt;, and &lt;code&gt;HEAD~2&lt;/code&gt;) were bad and you do not want to ever see them again. Do &lt;strong&gt;not&lt;/strong&gt; do this if you have already given these commits to somebody else. (See the &quot;RECOVERING FROM UPSTREAM REBASE&quot; section in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for the implications of doing so.)</source>
          <target state="translated">마지막 3 개의 커밋 ( &lt;code&gt;HEAD&lt;/code&gt; , &lt;code&gt;HEAD^&lt;/code&gt; 및 &lt;code&gt;HEAD~2&lt;/code&gt; )이 잘못되어 다시보고 싶지 않습니다. 마십시오 &lt;strong&gt;하지&lt;/strong&gt; 이미 다른 사람이 이러한 커밋을 제공 한 경우이 작업을 수행. ( 그렇게하는 의미에 대해서는 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]의&lt;/a&gt; &quot;UPSTREAM REBASE에서 복구&quot;섹션을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="9b2685798225cd4befed46a027cdbd30eb245ee2" translate="yes" xml:space="preserve">
          <source>The latest stash you created is stored in &lt;code&gt;refs/stash&lt;/code&gt;; older stashes are found in the reflog of this reference and can be named using the usual reflog syntax (e.g. &lt;code&gt;stash@{0}&lt;/code&gt; is the most recently created stash, &lt;code&gt;stash@{1}&lt;/code&gt; is the one before it, &lt;code&gt;stash@{2.hours.ago}&lt;/code&gt; is also possible). Stashes may also be referenced by specifying just the stash index (e.g. the integer &lt;code&gt;n&lt;/code&gt; is equivalent to &lt;code&gt;stash@{n}&lt;/code&gt;).</source>
          <target state="translated">가장 최근에 생성 한 숨김은 &lt;code&gt;refs/stash&lt;/code&gt; 에 저장됩니다 . 이전 스 &lt;code&gt;stash@{0}&lt;/code&gt; 는이 참조의 참조 로그에 있으며 일반적인 참조 로그 구문을 사용하여 이름을 지정할 수 있습니다 (예 : stash @ {0} 은 가장 최근에 생성 된 stash, &lt;code&gt;stash@{1}&lt;/code&gt; 은 그 이전의 &lt;code&gt;stash@{2.hours.ago}&lt;/code&gt; 도 가능합니다). 숨김 인덱스 만 지정하여 숨김을 참조 할 수도 있습니다 (예 : 정수 &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;stash@{n}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8bb7601b8118e6905d96f76a29452df6bc2ae98e" translate="yes" xml:space="preserve">
          <source>The latter is not available by default, unless configured.</source>
          <target state="translated">구성되지 않으면 후자는 기본적으로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9096be046e467fbce79d2a6fe63b310a7a8be174" translate="yes" xml:space="preserve">
          <source>The latter use of the &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; values can be overridden by giving the &lt;code&gt;--refmap=&amp;lt;refspec&amp;gt;&lt;/code&gt; parameter(s) on the command line.</source>
          <target state="translated">후자의 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 값 사용은 명령 행에 &lt;code&gt;--refmap=&amp;lt;refspec&amp;gt;&lt;/code&gt; 매개 변수 를 제공하여 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55ffd562f6b8b4abf7958d261df418cb81ead100" translate="yes" xml:space="preserve">
          <source>The length of time, in milliseconds, to retry when trying to lock an individual reference. Value 0 means not to retry at all; -1 means to try indefinitely. Default is 100 (i.e., retry for 100ms).</source>
          <target state="translated">개별 참조를 잠그려고 시도 할 때 재 시도하는 시간 (밀리 초)입니다. 값 0은 전혀 재 시도하지 않음을 의미합니다. -1은 무한정 시도하는 것을 의미합니다. 기본값은 100입니다 (즉, 100ms 동안 다시 시도).</target>
        </trans-unit>
        <trans-unit id="68a6d4f84896f5fe182696f59cffd1c668106a0a" translate="yes" xml:space="preserve">
          <source>The length of time, in milliseconds, to retry when trying to lock the &lt;code&gt;packed-refs&lt;/code&gt; file. Value 0 means not to retry at all; -1 means to try indefinitely. Default is 1000 (i.e., retry for 1 second).</source>
          <target state="translated">&lt;code&gt;packed-refs&lt;/code&gt; 파일 을 잠그려고 시도 할 때 재 시도하는 시간 (밀리 초) 입니다. 값 0은 전혀 재 시도하지 않음을 의미합니다. -1은 무한정 시도하는 것을 의미합니다. 기본값은 1000입니다 (즉, 1 초 동안 재시도).</target>
        </trans-unit>
        <trans-unit id="fff6cc41c6311b04938a1f36a103054a2f1d2e11" translate="yes" xml:space="preserve">
          <source>The list above is ordered by decreasing precedence; a URL that matches a config key&amp;rsquo;s path is preferred to one that matches its user name. For example, if the URL is &lt;code&gt;https://user@example.com/foo/bar&lt;/code&gt; a config key match of &lt;code&gt;https://example.com/foo&lt;/code&gt; will be preferred over a config key match of &lt;code&gt;https://user@example.com&lt;/code&gt;.</source>
          <target state="translated">위의 목록은 우선 순위를 낮추어 정렬됩니다. 구성 키의 경로와 일치하는 URL이 사용자 이름과 일치하는 URL보다 선호됩니다. 예를 들어 URL이 &lt;code&gt;https://user@example.com/foo/bar&lt;/code&gt; 인 경우 https : //user.example 의 구성 키 일치보다 &lt;code&gt;https://example.com/foo&lt;/code&gt; 의 구성 키 일치 가 선호됩니다 &lt;code&gt;https://user@example.com&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34cf6a4a25da733f5b8366288a8f31ad385fa0ee" translate="yes" xml:space="preserve">
          <source>The list of identifiers, and other information, of the objects in a &lt;a href=&quot;#def_pack&quot;&gt;pack&lt;/a&gt;, to assist in efficiently accessing the contents of a pack.</source>
          <target state="translated">&lt;a href=&quot;#def_pack&quot;&gt;팩&lt;/a&gt; 의 내용에 효율적으로 액세스 할 수 있도록 팩 에있는 객체의 식별자 목록 및 기타 정보 입니다.</target>
        </trans-unit>
        <trans-unit id="58413b6422259538de8b3cfc5351841a4fb3ade2" translate="yes" xml:space="preserve">
          <source>The list of mailbox files to read patches from. If you do not supply this argument, the command reads from the standard input. If you supply directories, they will be treated as Maildirs.</source>
          <target state="translated">패치를 읽을 메일 함 파일 목록. 이 인수를 제공하지 않으면 명령이 표준 입력에서 읽습니다. 디렉토리를 제공하면 Maildirs로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="811a0eecf6c6689902c9fc1e00fe667f20b10132" translate="yes" xml:space="preserve">
          <source>The list of remotes which are fetched by &quot;git remote update &amp;lt;group&amp;gt;&quot;. See &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;.</source>
          <target state="translated">&quot;git remote update &amp;lt;group&amp;gt;&quot;에 의해 페치 된 리모트 목록. &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3aadf5969931435dfd81a576572d271c1b7df1e4" translate="yes" xml:space="preserve">
          <source>The list you get with &quot;ls&quot; :-)</source>
          <target state="translated">&quot;ls&quot;로 얻는 목록 :-)</target>
        </trans-unit>
        <trans-unit id="2d5bfecbee3eeb5c71f69bd43de88bc34222a07d" translate="yes" xml:space="preserve">
          <source>The local offset is specified by &lt;code&gt;&amp;lt;offutc&amp;gt;&lt;/code&gt; as a positive or negative offset from UTC. For example EST (which is 5 hours behind UTC) would be expressed in &lt;code&gt;&amp;lt;tz&amp;gt;&lt;/code&gt; by &amp;ldquo;-0500&amp;rdquo; while UTC is &amp;ldquo;+0000&amp;rdquo;. The local offset does not affect &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt;; it is used only as an advisement to help formatting routines display the timestamp.</source>
          <target state="translated">로컬 오프셋은 &lt;code&gt;&amp;lt;offutc&amp;gt;&lt;/code&gt; 에서 UTC의 양수 또는 음수 오프셋으로 지정됩니다 . 예를 들어 EST (UTC보다 5 시간 늦음)는 &lt;code&gt;&amp;lt;tz&amp;gt;&lt;/code&gt; 에서 &quot;-0500&quot;으로 표시되고 UTC는 &quot;+0000&quot;입니다. 로컬 오프셋은 &lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; 에 영향을 미치지 않습니다 . 형식화 루틴이 시간 소인을 표시하는 것을 돕기위한 조언으로 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ab508d82c7d8a4545e2bb32ec9ec4fb2386a14cb" translate="yes" xml:space="preserve">
          <source>The location of an augmenting mailmap file. The default mailmap, located in the root of the repository, is loaded first, then the mailmap file pointed to by this variable. The location of the mailmap file may be in a repository subdirectory, or somewhere outside of the repository itself. See &lt;a href=&quot;git-shortlog&quot;&gt;git-shortlog[1]&lt;/a&gt; and &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;.</source>
          <target state="translated">기능 보강 메일 맵 파일의 위치입니다. 저장소의 루트에있는 기본 메일 맵이 먼저로드 된 다음이 변수가 가리키는 메일 맵 파일입니다. 메일 맵 파일의 위치는 저장소 하위 디렉토리에 있거나 저장소 자체 외부에있을 수 있습니다. 참조 &lt;a href=&quot;git-shortlog&quot;&gt;자식-shortlog [1]&lt;/a&gt; 와 &lt;a href=&quot;git-blame&quot;&gt;자식 비난 [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3bb0979c637e06c575b3f731f106ded5d4b916f" translate="yes" xml:space="preserve">
          <source>The location of per-instance and system-wide configuration files can be overridden using the following environment variables:</source>
          <target state="translated">인스턴스 별 및 시스템 전체 구성 파일의 위치는 다음 환경 변수를 사용하여 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9446c1e5cce4b2ece4fc10ff79540962e21c6551" translate="yes" xml:space="preserve">
          <source>The magic word &lt;code&gt;top&lt;/code&gt; (magic signature: &lt;code&gt;/&lt;/code&gt;) makes the pattern match from the root of the working tree, even when you are running the command from inside a subdirectory.</source>
          <target state="translated">magic word &lt;code&gt;top&lt;/code&gt; (magic signature : &lt;code&gt;/&lt;/code&gt; )은 하위 디렉토리 내부에서 명령을 실행하는 경우에도 작업 트리의 루트에서 패턴을 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="64ba77ac0581cbecc6b691422d0c5681817b2387" translate="yes" xml:space="preserve">
          <source>The main command loop has 6 subcommands (plus help and quit).</source>
          <target state="translated">기본 명령 루프에는 6 개의 하위 명령이 있습니다 (도움말 및 종료).</target>
        </trans-unit>
        <trans-unit id="0b0bee129956915b1cb776d4190a01b55932ed3c" translate="yes" xml:space="preserve">
          <source>The main command loop has 6 subcommands.</source>
          <target state="translated">기본 명령 루프에는 6 개의 하위 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="821ddd85eba2b4bc6e95a82521b10b32287622db" translate="yes" xml:space="preserve">
          <source>The main trunk is stored in the Git branch named &lt;code&gt;origin&lt;/code&gt;, and additional CVS branches are stored in Git branches with the same names. The most recent version of the main trunk is also left checked out on the &lt;code&gt;master&lt;/code&gt; branch, so you can start adding your own changes right away.</source>
          <target state="translated">기본 트렁크는 &lt;code&gt;origin&lt;/code&gt; 이라는 Git 브랜치에 저장 되고 추가 CVS 브랜치는 동일한 이름의 Git 브랜치에 저장됩니다. 기본 트렁크의 최신 버전도 &lt;code&gt;master&lt;/code&gt; 브랜치에서 체크 아웃 된 상태로 유지 되므로 직접 변경 사항을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f31023370321849385c22bc8ae521136bfffac45" translate="yes" xml:space="preserve">
          <source>The mapping of file names from the p4 depot path to Git, by default, involves removing the entire depot path. With this option, the full p4 depot path is retained in Git. For example, path &lt;code&gt;//depot/main/foo/bar.c&lt;/code&gt;, when imported from &lt;code&gt;//depot/main/&lt;/code&gt;, becomes &lt;code&gt;foo/bar.c&lt;/code&gt;. With &lt;code&gt;--keep-path&lt;/code&gt;, the Git path is instead &lt;code&gt;depot/main/foo/bar.c&lt;/code&gt;.</source>
          <target state="translated">기본적으로 p4 저장소 경로에서 Git으로 파일 이름을 맵핑하려면 전체 저장소 경로를 제거해야합니다. 이 옵션을 사용하면 전체 p4 저장소 경로가 Git에 유지됩니다. 예를 들어 &lt;code&gt;//depot/main/&lt;/code&gt; 에서 가져올 때 &lt;code&gt;//depot/main/foo/bar.c&lt;/code&gt; 경로 는 &lt;code&gt;foo/bar.c&lt;/code&gt; 가 됩니다. &lt;code&gt;--keep-path&lt;/code&gt; 사용 하면 Git 경로는 &lt;code&gt;depot/main/foo/bar.c&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="696795b724c116f40755fe0ffd2f815f95c8f529" translate="yes" xml:space="preserve">
          <source>The mark command is optional here as some frontends have chosen to generate the Git SHA-1 for the blob on their own, and feed that directly to &lt;code&gt;commit&lt;/code&gt;. This is typically more work than it&amp;rsquo;s worth however, as marks are inexpensive to store and easy to use.</source>
          <target state="translated">mark 명령은 여기서 일부 프론트 엔드가 자체적으로 Blob에 대한 Git SHA-1을 생성하고이를 직접 &lt;code&gt;commit&lt;/code&gt; 피드하기 때문에 선택 사항 입니다. 마크는 저장 비용이 저렴하고 사용하기 쉽기 때문에 일반적으로 가치보다 더 많은 작업입니다.</target>
        </trans-unit>
        <trans-unit id="154d6f76415eae422478f55f25c1ddb853a4e1ab" translate="yes" xml:space="preserve">
          <source>The maximum delta depth used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; when no maximum depth is given on the command line. Defaults to 50. Maximum value is 4095.</source>
          <target state="translated">명령 행에 최대 깊이가 지정되지 않은 경우 &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]에서&lt;/a&gt; 사용하는 최대 델타 깊이 . 기본값은 50입니다. 최대 값은 4095입니다.</target>
        </trans-unit>
        <trans-unit id="9325da9117f9b4afd884e4f7e837bf9ca641172e" translate="yes" xml:space="preserve">
          <source>The maximum memory in bytes used for caching deltas in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; before writing them out to a pack. This cache is used to speed up the writing object phase by not having to recompute the final delta result once the best match for all objects is found. Repacking large repositories on machines which are tight with memory might be badly impacted by this though, especially if this cache pushes the system into swapping. A value of 0 means no limit. The smallest size of 1 byte may be used to virtually disable this cache. Defaults to 256 MiB.</source>
          <target state="translated">&lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt; 에서 델타를 팩에 쓰기 전에 캐싱하는 데 사용되는 최대 메모리 (바이트) 입니다. 이 캐시는 모든 객체에 대해 가장 일치하는 것이 발견되면 최종 델타 결과를 다시 계산하지 않아도되므로 쓰기 객체 단계의 속도를 높이는 데 사용됩니다. 메모리가 부족한 머신에서 큰 리포지토리를 리 패킹하면 특히이 캐시로 인해 시스템이 스와핑되는 경우 이로 인해 영향을받을 수 있습니다. 값이 0이면 제한이 없음을 의미합니다. 이 캐시를 실제로 비활성화하는 데 가장 작은 1 바이트 크기를 사용할 수 있습니다. 기본값은 256MiB입니다.</target>
        </trans-unit>
        <trans-unit id="a0015a1c1a155cb39bc99dd58a785f6e45fb6909" translate="yes" xml:space="preserve">
          <source>The maximum size of a delta, that is cached in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;. This cache is used to speed up the writing object phase by not having to recompute the final delta result once the best match for all objects is found. Defaults to 1000. Maximum value is 65535.</source>
          <target state="translated">델타의 최대 크기는 &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]에&lt;/a&gt; 캐시됩니다 . 이 캐시는 모든 객체에 대해 가장 일치하는 것이 발견되면 최종 델타 결과를 다시 계산하지 않아도되므로 쓰기 객체 단계의 속도를 높이는 데 사용됩니다. 기본값은 1000입니다. 최대 값은 65535입니다.</target>
        </trans-unit>
        <trans-unit id="d2696797b76aad16406d56dd354feaf085869327" translate="yes" xml:space="preserve">
          <source>The maximum size of a pack. This setting only affects packing to a file when repacking, i.e. the git:// protocol is unaffected. It can be overridden by the &lt;code&gt;--max-pack-size&lt;/code&gt; option of &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;. Reaching this limit results in the creation of multiple packfiles; which in turn prevents bitmaps from being created. The minimum size allowed is limited to 1 MiB. The default is unlimited. Common unit suffixes of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt; are supported.</source>
          <target state="translated">팩의 최대 크기입니다. 이 설정은 재 포장 할 때 파일로의 압축에만 영향을 미칩니다. 즉, git : // 프로토콜은 영향을받지 않습니다. &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt; 의 &lt;code&gt;--max-pack-size&lt;/code&gt; 옵션 으로 재정의 할 수 있습니다 . 이 한계에 도달하면 여러 팩 파일이 작성됩니다. 비트 맵이 생성되는 것을 방지합니다. 허용되는 최소 크기는 1MiB로 제한됩니다. 기본값은 무제한입니다. &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; 또는 &lt;code&gt;g&lt;/code&gt; 의 공통 단위 접미사 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="bb8ed32c533714ca4a8bb85ec574c3c5791f3a2f" translate="yes" xml:space="preserve">
          <source>The maximum size of memory that is consumed by each thread in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; for pack window memory when no limit is given on the command line. The value can be suffixed with &quot;k&quot;, &quot;m&quot;, or &quot;g&quot;. When left unconfigured (or set explicitly to 0), there will be no limit.</source>
          <target state="translated">명령 행에 제한이없는 경우 팩 창 메모리에 대해 &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]의&lt;/a&gt; 각 스레드가 소비하는 최대 메모리 크기입니다 . 값은 &quot;k&quot;, &quot;m&quot;또는 &quot;g&quot;로 접미사를 붙일 수 있습니다. 구성되지 않은 상태로 두거나 명시 적으로 0으로 설정하면 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="565cc584b68c5b675a716ec7daae7fd9f3343784" translate="yes" xml:space="preserve">
          <source>The meaning of each part of feature configuration is described below:</source>
          <target state="translated">기능 구성의 각 부분의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c067af8c6826c60723d70b61f19783aa20b528e" translate="yes" xml:space="preserve">
          <source>The merge backend keeps intentionally empty commits by default (though with -i they are marked as empty in the todo list editor, or they can be dropped automatically with --no-keep-empty).</source>
          <target state="translated">The merge backend keeps intentionally empty commits by default (though with -i they are marked as empty in the todo list editor, or they can be dropped automatically with --no-keep-empty).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
