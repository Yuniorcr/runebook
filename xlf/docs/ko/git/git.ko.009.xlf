<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="41ba3127797e7497aaa54b06768281c0f54c0178" translate="yes" xml:space="preserve">
          <source>Show the working tree status</source>
          <target state="translated">작업 트리 상태 표시</target>
        </trans-unit>
        <trans-unit id="4be15cef7828db991e29f252f2096ac52eaa87a1" translate="yes" xml:space="preserve">
          <source>Show three-way merge without touching index</source>
          <target state="translated">인덱스를 건드리지 않고 3 방향 병합 표시</target>
        </trans-unit>
        <trans-unit id="c011e03eeb56d943a760cc013e6f2e4eb1d425c0" translate="yes" xml:space="preserve">
          <source>Show tree entries even when going to recurse them. Has no effect if &lt;code&gt;-r&lt;/code&gt; was not passed. &lt;code&gt;-d&lt;/code&gt; implies &lt;code&gt;-t&lt;/code&gt;.</source>
          <target state="translated">반복 할 때에도 트리 항목을 표시합니다. &lt;code&gt;-r&lt;/code&gt; 이 전달되지 않으면 효과 가 없습니다. &lt;code&gt;-d&lt;/code&gt; 는 &lt;code&gt;-t&lt;/code&gt; 를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="0ebf2c3da3729666fcca774c5c0088e26b46bc94" translate="yes" xml:space="preserve">
          <source>Show unified diff between the HEAD commit and what would be committed at the bottom of the commit message template to help the user describe the commit by reminding what changes the commit has. Note that this diff output doesn&amp;rsquo;t have its lines prefixed with &lt;code&gt;#&lt;/code&gt;. This diff will not be a part of the commit message. See the &lt;code&gt;commit.verbose&lt;/code&gt; configuration variable in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">HEAD 커밋과 커밋 메시지 템플릿의 맨 아래에 커밋 된 내용 사이에 통합 된 차이점을 표시하여 커밋의 변경 사항을 상기시켜 사용자가 커밋을 설명 할 수 있도록합니다. 이 diff 출력에는 &lt;code&gt;#&lt;/code&gt; 앞에 접두사가 붙지 않습니다 . 이 diff는 커밋 메시지의 일부가 아닙니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 &lt;code&gt;commit.verbose&lt;/code&gt; 구성 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ec5cbecb883dc178104f40a9f6290a06e20fc1c" translate="yes" xml:space="preserve">
          <source>Show uniquely abbreviated commit object as fallback.</source>
          <target state="translated">고유하게 축약 된 확약 오브젝트를 대체로 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="10c7ca24c353332c5b887c6b6a1d6dd7a457b5d5" translate="yes" xml:space="preserve">
          <source>Show unmerged files in the output (forces --stage)</source>
          <target state="translated">출력에 병합되지 않은 파일 표시 (forces --stage)</target>
        </trans-unit>
        <trans-unit id="b5d593f0c18fdb91296748ca1fac373587b954d6" translate="yes" xml:space="preserve">
          <source>Show untracked files.</source>
          <target state="translated">추적되지 않은 파일을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="26b08d61663ae392b69c5a69245f4edf21293755" translate="yes" xml:space="preserve">
          <source>Show various types of objects</source>
          <target state="translated">다양한 유형의 객체 표시</target>
        </trans-unit>
        <trans-unit id="21c5bff92d5285947c85ec0c1484f22db009a919" translate="yes" xml:space="preserve">
          <source>Show what revision and author last modified each line of a file</source>
          <target state="translated">파일의 각 줄을 마지막으로 수정 한 개정 및 작성자 표시</target>
        </trans-unit>
        <trans-unit id="966d3662ec6148441d1b868ba18110f8156c9e7e" translate="yes" xml:space="preserve">
          <source>Show what revision and author last modified each line of a file. The output of this mode is format-compatible with the output of &amp;lsquo;svn blame&amp;rsquo; by default. Like the SVN blame command, local uncommitted changes in the working tree are ignored; the version of the file in the HEAD revision is annotated. Unknown arguments are passed directly to &lt;code&gt;git blame&lt;/code&gt;.</source>
          <target state="translated">파일의 각 행을 마지막으로 수정 한 개정 및 작성자를 표시하십시오. 이 모드의 출력은 기본적으로 'svn blame'의 출력과 형식 호환됩니다. SVN blame 명령과 마찬가지로 작업 트리에서 커밋되지 않은 로컬 변경 사항은 무시됩니다. HEAD 개정판의 파일 버전에 주석이 달렸습니다. 알 수없는 인수는 &lt;code&gt;git blame&lt;/code&gt; 에 직접 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="bf9833b3864a606f143f671880d0d7c492524c3a" translate="yes" xml:space="preserve">
          <source>Show what would be done and clean files interactively. See &amp;ldquo;Interactive mode&amp;rdquo; for details.</source>
          <target state="translated">수행 할 작업을 표시하고 파일을 대화식으로 정리하십시오. 자세한 내용은 &quot;대화식 모드&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="df9413d989d45b2c0aaf57aba32e9c05293cab52" translate="yes" xml:space="preserve">
          <source>Show what would be done, without making any changes.</source>
          <target state="translated">변경하지 않고 수행 할 작업을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="596b94f13704cef1df2f70e0b5afc140a351ff74" translate="yes" xml:space="preserve">
          <source>Show whole function as context lines for each change. The function names are determined in the same way as &lt;code&gt;git diff&lt;/code&gt; works out patch hunk headers (see &lt;code&gt;Defining a custom hunk-header&lt;/code&gt; in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;).</source>
          <target state="translated">각 변경 사항에 대한 전체 기능을 컨텍스트 라인으로 표시합니다. 함수 이름은 &lt;code&gt;git diff&lt;/code&gt; 가 패치 &lt;a href=&quot;gitattributes&quot;&gt;헝크 &lt;/a&gt; &lt;code&gt;Defining a custom hunk-header&lt;/code&gt; 를 작동 하는 것과 같은 방식으로 결정됩니다 ( gitattributes [5] 에서 사용자 정의 헝크 헤더 정의 참조 ).</target>
        </trans-unit>
        <trans-unit id="be4ca0a0825cd627301347d0b898edf805764f04" translate="yes" xml:space="preserve">
          <source>Show whole surrounding functions of changes.</source>
          <target state="translated">변화의 전체 주변 기능을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="468ba140a3b94d2f9cd6ef93cfa9cab1327c9537" translate="yes" xml:space="preserve">
          <source>Show words as &lt;code&gt;[-removed-]&lt;/code&gt; and &lt;code&gt;{+added+}&lt;/code&gt;. Makes no attempts to escape the delimiters if they appear in the input, so the output may be ambiguous.</source>
          <target state="translated">단어를 &lt;code&gt;[-removed-]&lt;/code&gt; 및 &lt;code&gt;{+added+}&lt;/code&gt; . 분리 문자가 입력에 표시되면 분리 문자를 이스케이프하려고 시도하지 않으므로 출력이 모호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="853a8e226495d515cddaf8f8812833ecd070bbe7" translate="yes" xml:space="preserve">
          <source>Showing commits unique to a given branch</source>
          <target state="translated">주어진 브랜치에 고유 한 커밋 표시</target>
        </trans-unit>
        <trans-unit id="96ca3a302ef6077a82014da5f00857782e6cb86a" translate="yes" xml:space="preserve">
          <source>Shown when &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; gives up trying to guess based on the source and destination refs what remote ref namespace the source belongs in, but where we can still suggest that the user push to either refs/heads/* or refs/tags/* based on the type of the source object.</source>
          <target state="translated">때 표시 &lt;a href=&quot;git-push&quot;&gt;자식 푸시 [1]&lt;/a&gt; 원격 심판 소스에 속하는 네임 스페이스 어떤 소스 및 대상 심판을 기준으로 생각하려고까지 제공하지만, 우리는 여전히 제안 할 수 있습니다 곳 중 심판 / 헤드 / * 또는 심판 / 태그 사용자 푸시 / *는 소스 객체의 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="732728a3dd494eca2577139ba51741f23db676b1" translate="yes" xml:space="preserve">
          <source>Shown when &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; rejects a forced update of a branch when its remote-tracking ref has updates that we do not have locally.</source>
          <target state="translated">원격 추적 참조에 로컬에없는 업데이트가있는 경우 &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 이 분기의 강제 업데이트를 거부 할 때 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="75d7e8b680f4e534527cb3c486bef0af3659328c" translate="yes" xml:space="preserve">
          <source>Shown when &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; rejects an update that does not qualify for fast-forwarding (e.g., a tag.)</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 가 빨리 감기에 적합하지 않은 업데이트 (예 : 태그)를 거부 할 때 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a0a872703503f071b91634941e8be2dc5533cd1" translate="yes" xml:space="preserve">
          <source>Shown when &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; rejects an update that tries to overwrite a remote ref that points at an object that is not a commit-ish, or make the remote ref point at an object that is not a commit-ish.</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 가 커밋이 아닌 객체를 가리키는 원격 참조를 덮어 쓰거나 원격 참조가 커밋이 아닌 객체를 가리 키도록하는 업데이트를 거부 할 때 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b4c04c7663321c0bb15512a5590b839a243ed3d" translate="yes" xml:space="preserve">
          <source>Shown when &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; rejects an update that tries to overwrite a remote ref that points at an object we do not have.</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 가 가지고 있지 않은 객체를 가리키는 원격 참조를 덮어 쓰려는 업데이트를 거부 할 때 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="78b784f23e7ef12a1020b996b898b9ff902a30e8" translate="yes" xml:space="preserve">
          <source>Shown when &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; computes the ahead/behind counts for a local ref compared to its remote tracking ref, and that calculation takes longer than expected. Will not appear if &lt;code&gt;status.aheadBehind&lt;/code&gt; is false or the option &lt;code&gt;--no-ahead-behind&lt;/code&gt; is given.</source>
          <target state="translated">도시 때 &lt;a href=&quot;git-status&quot;&gt;자식 - 상태 [1]&lt;/a&gt; 의 원격 추적 (REF)과 비교하여 로컬 타이밍에서 카운트 뒤에 /를 전방을 계산하고, 그 계산이 예상보다 오래 걸린다. &lt;code&gt;status.aheadBehind&lt;/code&gt; 가 false이거나 &lt;code&gt;--no-ahead-behind&lt;/code&gt; 옵션이 제공 되면 나타나지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d338c5b596db1d1f3b4bc876559fe0665e8ac5fb" translate="yes" xml:space="preserve">
          <source>Shows &amp;lt;n&amp;gt; most recent ref-log entries for the given ref. If &amp;lt;base&amp;gt; is given, &amp;lt;n&amp;gt; entries going back from that entry. &amp;lt;base&amp;gt; can be specified as count or date. When no explicit &amp;lt;ref&amp;gt; parameter is given, it defaults to the current branch (or &lt;code&gt;HEAD&lt;/code&gt; if it is detached).</source>
          <target state="translated">주어진 심판에 대한 가장 최근의 심판 기록 항목을 &amp;lt;n&amp;gt; 보여줍니다. &amp;lt;base&amp;gt;가 제공되면 &amp;lt;n&amp;gt; 개의 항목이 해당 항목에서 되돌아옵니다. &amp;lt;base&amp;gt;는 개수 또는 날짜로 지정할 수 있습니다. 명시적인 &amp;lt;ref&amp;gt; 매개 변수가 제공되지 않으면 현재 분기 (또는 분리 된 경우 &lt;code&gt;HEAD&lt;/code&gt; )로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="145d28125d096ddf08f1e26c4d9787f99dd5cc7e" translate="yes" xml:space="preserve">
          <source>Shows all commits that are in any of local branches but not in any of remote-tracking branches for &lt;code&gt;origin&lt;/code&gt; (what you have that origin doesn&amp;rsquo;t).</source>
          <target state="translated">로컬 분기에 있지만 &lt;code&gt;origin&lt;/code&gt; 대한 원격 추적 분기에는없는 모든 커밋을 표시 합니다 (원본이없는 것).</target>
        </trans-unit>
        <trans-unit id="c51c52f011be107f5e19468bb7f02daf26af2024" translate="yes" xml:space="preserve">
          <source>Shows all commits that are in local master but not in any remote repository master branches.</source>
          <target state="translated">로컬 마스터에는 있지만 원격 저장소 마스터 분기에는없는 모든 커밋을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="10371d1293071dacd448b9fdd202c3afd277b14e" translate="yes" xml:space="preserve">
          <source>Shows commit logs and diff output each commit introduces.</source>
          <target state="translated">각 커밋이 소개하는 커밋 로그 및 diff 출력을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="476dac31e594be06f217fa896bee0115d58f6b4c" translate="yes" xml:space="preserve">
          <source>Shows history of the file or directory in a given repository path, starting from given revision (defaults to HEAD, i.e. default branch).</source>
          <target state="translated">지정된 리포지토리 (기본값은 HEAD, 즉 기본 분기)에서 시작하여 지정된 리포지토리 경로에 파일 또는 디렉토리의 기록을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="952b827e77460f64206eeaa3be7cd6994665a085" translate="yes" xml:space="preserve">
          <source>Shows how the function &lt;code&gt;main()&lt;/code&gt; in the file &lt;code&gt;main.c&lt;/code&gt; evolved over time.</source>
          <target state="translated">&lt;code&gt;main.c&lt;/code&gt; 파일의 &lt;code&gt;main()&lt;/code&gt; 함수 가 시간이 지남 에 따라 어떻게 진화 했는지 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="ce9fdc182e7532561a25c9e84afbf603141702a1" translate="yes" xml:space="preserve">
          <source>Shows information about a file or directory similar to what &amp;lsquo;svn info&amp;rsquo; provides. Does not currently support a -r/--revision argument. Use the --url option to output only the value of the &lt;code&gt;URL:&lt;/code&gt; field.</source>
          <target state="translated">'svn info'가 제공하는 것과 유사한 파일 또는 디렉토리에 대한 정보를 표시합니다. 현재 -r /-revision 인수를 지원하지 않습니다. &lt;code&gt;URL:&lt;/code&gt; 필드 의 값만 출력하려면 --url 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca1b824d0d56099189f69630ad24bacce78fa10f" translate="yes" xml:space="preserve">
          <source>Shows information about a specific commit in a repository. The &lt;code&gt;commit&lt;/code&gt; view shows information about commit in more detail, the &lt;code&gt;commitdiff&lt;/code&gt; action shows changeset for given commit.</source>
          <target state="translated">저장소의 특정 커밋에 대한 정보를 표시합니다. (가) &lt;code&gt;commit&lt;/code&gt; 뷰 프로그램 정보에 대해보다 상세히 커밋 &lt;code&gt;commitdiff&lt;/code&gt; 의 행동 프로그램은 주어진 커밋에 대한 변경 집합.</target>
        </trans-unit>
        <trans-unit id="ab228fa7c7d65eb09f46d0e73fe8d72b79bc229a" translate="yes" xml:space="preserve">
          <source>Shows log information (commit message or just commit subject) for a given branch (starting from given revision).</source>
          <target state="translated">주어진 브랜치에 대한 로그 정보 (커밋 메시지 또는 커밋 제목)를 표시합니다 (주어진 개정에서 시작).</target>
        </trans-unit>
        <trans-unit id="a3433f3c29ab88ea9167add81dd6a17e06d4de7e" translate="yes" xml:space="preserve">
          <source>Shows one or more objects (blobs, trees, tags and commits).</source>
          <target state="translated">하나 이상의 객체 (블롭, 트리, 태그 및 커밋)를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c89f1cda347c61bcda5c7bb78673af53b8dae0ad" translate="yes" xml:space="preserve">
          <source>Shows only commits that are NOT on the first branch given. This helps track topic branches by hiding any commit that is already in the main line of development. When given &quot;git show-branch --topics master topic1 topic2&quot;, this will show the revisions given by &quot;git rev-list ^master topic1 topic2&quot;</source>
          <target state="translated">주어진 첫 번째 분기에없는 커밋 만 표시합니다. 이는 기본 개발 라인에있는 커밋을 숨겨 주제 분기를 추적하는 데 도움이됩니다. &quot;git show-branch --topics master topic1 topic2&quot;가 주어지면 &quot;git rev-list ^ master topic1 topic2&quot;에 의해 제공된 개정이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ad855617a566df1f282b86f94f82b5d862a150d3" translate="yes" xml:space="preserve">
          <source>Shows the Subversion externals. Use -r/--revision to specify a specific revision.</source>
          <target state="translated">Subversion 외부를 표시합니다. -r /-revision을 사용하여 특정 개정을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="71ee8b01832959c514dd0597fe4e33b8eee16c88" translate="yes" xml:space="preserve">
          <source>Shows the blame (also called annotation) information for a file. On a per line basis it shows the revision in which that line was last changed and the user that committed the change. The incremental version (which if configured is used automatically when JavaScript is enabled) uses Ajax to incrementally add blame info to the contents of given file.</source>
          <target state="translated">파일에 대한 책임 (주석이라고도 함) 정보를 표시합니다. 행 단위로 해당 행이 마지막으로 변경된 개정 및 변경을 커밋 한 사용자가 표시됩니다. 인크 리 멘탈 버전 (JavaScript가 활성화 된 경우 자동으로 구성되는 경우)은 Ajax를 사용하여 지정된 파일의 컨텐츠에 비난 정보를 점진적으로 추가합니다.</target>
        </trans-unit>
        <trans-unit id="048347ade13621e5b8c85cb1ac7da77939e1ffa9" translate="yes" xml:space="preserve">
          <source>Shows the commit ancestry graph starting from the commits named with &amp;lt;rev&amp;gt;s or &amp;lt;glob&amp;gt;s (or all refs under refs/heads and/or refs/tags) semi-visually.</source>
          <target state="translated">&amp;lt;rev&amp;gt; s 또는 &amp;lt;glob&amp;gt; s (또는 refs / heads 및 / 또는 refs / tags 아래의 모든 ref)로 명명 된 커밋에서 시작하여 커밋 상위 그래프를 반 시각적으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d974b70c2c30c4540e25d821a52ee3e8a89faf35" translate="yes" xml:space="preserve">
          <source>Shows the commit logs.</source>
          <target state="translated">커밋 로그를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="afa4aeeb0e59c57a072646fb612e51228d9e8ce5" translate="yes" xml:space="preserve">
          <source>Shows the commits that changed &lt;code&gt;builtin/rev-list.c&lt;/code&gt;, including those commits that occurred before the file was given its present name.</source>
          <target state="translated">파일에 현재 이름이 부여되기 전에 발생한 커밋을 포함하여 &lt;code&gt;builtin/rev-list.c&lt;/code&gt; 를 변경 한 커밋을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="0d2116a149d849234c7b09c554d651b4894474fc" translate="yes" xml:space="preserve">
          <source>Shows the contents of the file &lt;code&gt;Documentation/README&lt;/code&gt; as they were current in the 10th last commit of the branch &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; 지점의 마지막 10 번째 커밋에서 현재의 &lt;code&gt;Documentation/README&lt;/code&gt; 파일의 내용을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="ccc9b587b1ac64f4516513aa59159ddedbb8a45f" translate="yes" xml:space="preserve">
          <source>Shows the difference between two revisions of the same file.</source>
          <target state="translated">동일한 파일의 두 개정판의 차이점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="8c5916992e873dd9df6491dab9446ed99d2ca43b" translate="yes" xml:space="preserve">
          <source>Shows the files and directories in a given repository path, at given revision. This is default command if no action is specified in the URL, and path is given.</source>
          <target state="translated">지정된 개정판에서 지정된 저장소 경로의 파일 및 디렉토리를 표시합니다. URL에 조치가 지정되지 않은 경우 기본 명령이며 경로가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="890a038d1a0efbf86457550ddb0f94462d132854" translate="yes" xml:space="preserve">
          <source>Shows the history including change diffs, but only from the &amp;ldquo;main branch&amp;rdquo; perspective, skipping commits that come from merged branches, and showing full diffs of changes introduced by the merges. This makes sense only when following a strict policy of merging all topic branches when staying on a single integration branch.</source>
          <target state="translated">변경 차이를 포함한 히스토리를 보여 주지만 &quot;메인 브랜치&quot;관점에서만, 병합 된 분기에서 온 커밋을 건너 뛰고, 병합에서 도입 된 전체 변경 사항을 보여줍니다. 이는 단일 통합 브랜치에 머무를 때 모든 토픽 브랜치를 병합하는 엄격한 정책을 따르는 경우에만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6e093f4d97154b146a36fee068be195950aadfd" translate="yes" xml:space="preserve">
          <source>Shows the subject of the commit pointed to by the tag &lt;code&gt;v1.0.0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v1.0.0&lt;/code&gt; 태그가 가리키는 커밋의 주제를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="9b44c59ff3bc267fd7a4cbc7d7224ea23d69056e" translate="yes" xml:space="preserve">
          <source>Shows the tag &lt;code&gt;v1.0.0&lt;/code&gt;, along with the object the tags points at.</source>
          <target state="translated">태그가 가리키는 객체와 함께 태그 &lt;code&gt;v1.0.0&lt;/code&gt; 을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="092526538596a5fe7b0994948947cb6672086546" translate="yes" xml:space="preserve">
          <source>Shows the tree pointed to by the tag &lt;code&gt;v1.0.0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v1.0.0&lt;/code&gt; 태그가 가리키는 트리를 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="436f07afaaab4f38cb1e7cf08118570b5794b7ea" translate="yes" xml:space="preserve">
          <source>Side note: Unfortunately, people tend to fixate on the written-in-shell aspect and periodically ask if git-filter-branch could be rewritten in another language to fix the performance issues. Not only does that ignore the bigger intrinsic problems with the design, it&amp;rsquo;d help less than you&amp;rsquo;d expect: if git-filter-branch itself were not shell, then the convenience functions (map(), skip_commit(), etc) and the &lt;code&gt;--setup&lt;/code&gt; argument could no longer be executed once at the beginning of the program but would instead need to be prepended to every user filter (and thus re-executed with every commit).</source>
          <target state="translated">참고 사항 : 불행히도 사람들은 쉘로 작성된 측면을 수정하는 경향이 있으며 성능 문제를 해결하기 위해 git-filter-branch를 다른 언어로 다시 작성할 수 있는지 정기적으로 묻습니다. git-filter-branch 자체가 쉘이 아닌 경우 편의 함수 (map (), skip_commit () 등)는 디자인과 관련하여 더 큰 본질적인 문제를 무시할뿐만 아니라 예상보다 덜 도움이됩니다. 그리고 &lt;code&gt;--setup&lt;/code&gt; 인수는 더 이상 프로그램의 시작 부분에 한 번 실행되지 수 있지만, 대신 모든 사용자 필터 앞에 추가 할 (따라서 모든 확약 재실행)해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a31cdd9cba3408afdcd7a253a0ac442839b0979" translate="yes" xml:space="preserve">
          <source>Side note: it may be possible to do step 2 with about:config and the following settings but no one&amp;rsquo;s tried yet.</source>
          <target state="translated">참고 : about : config 및 다음 설정으로 2 단계를 수행 할 수 있지만 아직 시도한 사람은 없습니다.</target>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="ff3ca843a6395cdc7d40686539d66fc535a8aaed" translate="yes" xml:space="preserve">
          <source>Signals the end of options; the rest of the parameters are &amp;lt;pathspec&amp;gt; limiters.</source>
          <target state="translated">옵션의 끝을 알립니다. 나머지 매개 변수는 &amp;lt;pathspec&amp;gt; 리미터입니다.</target>
        </trans-unit>
        <trans-unit id="221dd464fe44b38e2417a0ae6570e07534a3d7ea" translate="yes" xml:space="preserve">
          <source>Signing annotated tags during import from within fast-import is not supported. Trying to include your own PGP/GPG signature is not recommended, as the frontend does not (easily) have access to the complete set of bytes which normally goes into such a signature. If signing is required, create lightweight tags from within fast-import with &lt;code&gt;reset&lt;/code&gt;, then create the annotated versions of those tags offline with the standard &lt;code&gt;git tag&lt;/code&gt; process.</source>
          <target state="translated">빠른 가져 오기 내에서 가져 오는 동안 주석이 달린 태그에 서명하는 것은 지원되지 않습니다. 프론트 엔드는 일반적으로 그러한 서명으로 들어가는 전체 바이트 세트에 액세스하지 않기 때문에 자신의 PGP / GPG 서명을 포함시키는 것은 권장되지 않습니다. 서명이 필요한 경우 &lt;code&gt;reset&lt;/code&gt; 을 사용하여 빠른 가져 오기 내에서 경량 태그 를 작성한 다음 표준 &lt;code&gt;git tag&lt;/code&gt; 프로세스를 사용하여 해당 태그의 주석이 달린 버전을 오프라인으로 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="e73ba37a846fd05171a6c58829f1ab0aa4e069d7" translate="yes" xml:space="preserve">
          <source>Silently overwrite ignored files from the merge result. This is the default behavior. Use &lt;code&gt;--no-overwrite-ignore&lt;/code&gt; to abort.</source>
          <target state="translated">병합 결과에서 무시 된 파일을 자동으로 덮어 씁니다. 이것이 기본 동작입니다. 중단 하려면 &lt;code&gt;--no-overwrite-ignore&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7ca941070a3e177fd03230132f7162630714492" translate="yes" xml:space="preserve">
          <source>Silently overwrite ignored files when switching branches. This is the default behavior. Use &lt;code&gt;--no-overwrite-ignore&lt;/code&gt; to abort the operation when the new branch contains ignored files.</source>
          <target state="translated">분기를 전환 할 때 무시 된 파일을 자동으로 덮어 씁니다. 이것이 기본 동작입니다. 새 분기에 무시 된 파일이 포함 된 경우 작업을 중단 하려면 &lt;code&gt;--no-overwrite-ignore&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ffd6334e8fa69c33df5ff56f9d3009483e17a61e" translate="yes" xml:space="preserve">
          <source>Similar to --depth, except it specifies the number of commits from the current shallow boundary instead of from the tip of each remote branch history.</source>
          <target state="translated">--depth와 비슷하지만 각 원격 분기 히스토리의 팁 대신 현재 얕은 경계에서 커밋 수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="16434785e2f2781f48016d9fab6f521e71729a0f" translate="yes" xml:space="preserve">
          <source>Similar to -u. But when re-coding, the charset specified here is used instead of the one specified by i18n.commitencoding or UTF-8.</source>
          <target state="translated">-u와 유사합니다. 그러나 다시 코딩 할 때 여기에 지정된 문자 세트는 i18n.commitencoding 또는 UTF-8에 지정된 문자 세트 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="35df8b1f29f7a7b94cf0adfb128190781a631c4c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;--create&lt;/code&gt; except that if &lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; already exists, it will be reset to &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt;. This is a convenient shortcut for:</source>
          <target state="translated">&lt;code&gt;&amp;lt;new-branch&amp;gt;&lt;/code&gt; 가 이미 존재 하는 경우 &lt;code&gt;&amp;lt;start-point&amp;gt;&lt;/code&gt; 로 재설정 된다는 점을 제외하고 &lt;code&gt;--create&lt;/code&gt; 와 유사합니다 . 다음과 같은 편리한 단축키입니다.</target>
        </trans-unit>
        <trans-unit id="a329dc4873c426988eca07322671d0e252450f5a" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;--file&lt;/code&gt; but use the given blob instead of a file. E.g. you can use &lt;code&gt;master:.gitmodules&lt;/code&gt; to read values from the file &lt;code&gt;.gitmodules&lt;/code&gt; in the master branch. See &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; for a more complete list of ways to spell blob names.</source>
          <target state="translated">유사합니다 &lt;code&gt;--file&lt;/code&gt; 하지만 파일 대신 주어진 방울을 사용합니다. 예를 들어 &lt;code&gt;master:.gitmodules&lt;/code&gt; 를 사용 하여 마스터 분기의 &lt;code&gt;.gitmodules&lt;/code&gt; 파일에서 값을 읽을 수 있습니다 . 블롭 이름을 철자하는 방법에 대한 전체 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]의&lt;/a&gt; &quot;수정 수정&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="96ae9e148f9a848728ba835436ff9b06a051bf18" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;--local&lt;/code&gt; except that &lt;code&gt;.git/config.worktree&lt;/code&gt; is read from or written to if &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; is present. If not it&amp;rsquo;s the same as &lt;code&gt;--local&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 가있는 경우 &lt;code&gt;.git/config.worktree&lt;/code&gt; 를 읽거나 쓰는 점을 제외하고 &lt;code&gt;--local&lt;/code&gt; 과 비슷합니다 . 그렇지 않은 경우 &lt;code&gt;--local&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="9921875dc5f741363cc389c12f0a866da77aa3f9" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;--objects-edge&lt;/code&gt;, but it tries harder to find excluded commits at the cost of increased time. This is used instead of &lt;code&gt;--objects-edge&lt;/code&gt; to build &amp;ldquo;thin&amp;rdquo; packs for shallow repositories.</source>
          <target state="translated">유사 &lt;code&gt;--objects-edge&lt;/code&gt; 하지만 시간이 증가의 비용을 제외 커밋을 찾기 위해 더 열심히하려고합니다. 얕은 리포지토리를위한 &quot;씬&quot;팩을 빌드하기 위해 &lt;code&gt;--objects-edge&lt;/code&gt; 대신 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="827a1dc116e1ce95f15ed3122df77ff565d151ab" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;--objects&lt;/code&gt;, but also print the IDs of excluded commits prefixed with a &amp;ldquo;-&amp;rdquo; character. This is used by &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; to build a &amp;ldquo;thin&amp;rdquo; pack, which records objects in deltified form based on objects contained in these excluded commits to reduce network traffic.</source>
          <target state="translated">유사 &lt;code&gt;--objects&lt;/code&gt; 뿐만 아니라 접두어 제외 커밋의 ID를 인쇄 &quot;-&quot;문자를. 이것은 &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt; 에서 &quot;thin&quot;팩을 작성하는 데 사용됩니다.이 팩은 네트워크 트래픽을 줄이기 위해 이러한 제외 된 커밋에 포함 된 객체를 기반으로 deltified 형식으로 객체를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="92613f50c8128533a943f904d4fab448ede98701" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;--show-origin&lt;/code&gt; in that it augments the output of all queried config options with the scope of that value (local, global, system, command).</source>
          <target state="translated">&lt;code&gt;--show-origin&lt;/code&gt; 과 유사하게 쿼리 된 모든 구성 옵션의 출력을 해당 값 (로컬, 글로벌, 시스템, 명령)의 범위로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="db4263bd2603c01331f2d853a8cad6132476aed7" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;--stat&lt;/code&gt;, but shows number of added and deleted lines in decimal notation and pathname without abbreviation, to make it more machine friendly. For binary files, outputs two &lt;code&gt;-&lt;/code&gt; instead of saying &lt;code&gt;0 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--stat&lt;/code&gt; 와 유사 하지만 더 기계 친화적으로 만들기 위해 추가 및 삭제 된 줄 수를 약어없이 10 진수 표기법과 경로 이름으로 표시합니다. 바이너리 파일의 경우, 두 개의 출력 &lt;code&gt;-&lt;/code&gt; 대신 말의 &lt;code&gt;0 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="507e19add19af137dd267ca439cffb2e494aaec7" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;--stat&lt;/code&gt;, but shows the number of added and deleted lines in decimal notation and the pathname without abbreviation, to make it more machine friendly. For binary files, outputs two &lt;code&gt;-&lt;/code&gt; instead of saying &lt;code&gt;0 0&lt;/code&gt;. Turns off &quot;apply&quot;.</source>
          <target state="translated">유사 &lt;code&gt;--stat&lt;/code&gt; 더 머신 친절하게,하지만 쇼 진수 표기법으로 추가 및 삭제 된 행의 수와 약어없이 경로 이름을. 바이너리 파일의 경우, 두 개의 출력 &lt;code&gt;-&lt;/code&gt; 대신 말의 &lt;code&gt;0 0&lt;/code&gt; . &quot;적용&quot;을 끕니다.</target>
        </trans-unit>
        <trans-unit id="cebb3f179c2f7afdfbf89dc9db3668db1b27ceee" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;-t&lt;/code&gt;, but use lowercase letters for files that are marked as &lt;code&gt;assume unchanged&lt;/code&gt; (see &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;).</source>
          <target state="translated">유사 &lt;code&gt;-t&lt;/code&gt; 으로 표시된 파일 만 사용 소문자 문자가 &lt;code&gt;assume unchanged&lt;/code&gt; (참조 &lt;a href=&quot;git-update-index&quot;&gt;자식 업데이트 색인을 [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c8a85313dff4970a1ca58c4ac403a9e5f1e1fd26" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;-t&lt;/code&gt;, but use lowercase letters for files that are marked as &lt;code&gt;fsmonitor valid&lt;/code&gt; (see &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;-t&lt;/code&gt; 와 유사 하지만 &lt;code&gt;fsmonitor valid&lt;/code&gt; 로 표시된 파일에 대해서는 소문자를 사용 하십시오 ( &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d753bc37a0732c319a3b637b8b9f6c853acf890c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;list&lt;/code&gt;, except that it is used if and only if the caller wants to the resulting ref list to prepare push commands. A helper supporting both push and fetch can use this to distinguish for which operation the output of &lt;code&gt;list&lt;/code&gt; is going to be used, possibly reducing the amount of work that needs to be performed.</source>
          <target state="translated">호출자가 푸시 명령을 준비하기 위해 결과 참조 목록을 원할 경우에만 사용된다는 점을 제외하고 &lt;code&gt;list&lt;/code&gt; 와 비슷 합니다. push 및 fetch를 모두 지원하는 도우미는이를 사용하여 &lt;code&gt;list&lt;/code&gt; 의 출력 이 사용될 작업을 구별하여 수행해야하는 작업량을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d877d80bc2ddec8772b0999fdcc01984ec807892" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;zebra&lt;/code&gt;, but additional dimming of uninteresting parts of moved code is performed. The bordering lines of two adjacent blocks are considered interesting, the rest is uninteresting. &lt;code&gt;dimmed_zebra&lt;/code&gt; is a deprecated synonym.</source>
          <target state="translated">&lt;code&gt;zebra&lt;/code&gt; 와 유사 하지만 이동 된 코드의 관심없는 부분에 대한 추가 디밍이 수행됩니다. 인접한 두 블록의 경계선은 흥미로운 것으로 간주되며 나머지는 흥미롭지 않습니다. &lt;code&gt;dimmed_zebra&lt;/code&gt; 는 더 이상 사용되지 않는 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="bf8bcfbd909889dac33d6d2f89b63bfd39d6ccea" translate="yes" xml:space="preserve">
          <source>Similar to Git&amp;rsquo;s &lt;code&gt;remote.&amp;lt;name&amp;gt;.pushurl&lt;/code&gt;, this key is designed to be used in cases where &lt;code&gt;url&lt;/code&gt; points to an SVN repository via a read-only transport, to provide an alternate read/write transport. It is assumed that both keys point to the same repository. Unlike &lt;code&gt;commiturl&lt;/code&gt;, &lt;code&gt;pushurl&lt;/code&gt; is a base path. If either &lt;code&gt;commiturl&lt;/code&gt; or &lt;code&gt;pushurl&lt;/code&gt; could be used, &lt;code&gt;commiturl&lt;/code&gt; takes precedence.</source>
          <target state="translated">Git의 &lt;code&gt;remote.&amp;lt;name&amp;gt;.pushurl&lt;/code&gt; 과 유사 하게이 키는 &lt;code&gt;url&lt;/code&gt; 이 읽기 전용 전송을 통해 SVN 저장소를 가리키는 경우 대체 읽기 / 쓰기 전송을 제공하기 위해 사용되도록 설계되었습니다 . 두 키가 동일한 리포지토리를 가리키는 것으로 가정합니다. 달리 &lt;code&gt;commiturl&lt;/code&gt; , &lt;code&gt;pushurl&lt;/code&gt; 는 기본 경로입니다. 어느 경우 &lt;code&gt;commiturl&lt;/code&gt; 또는 &lt;code&gt;pushurl&lt;/code&gt; 이 사용될 수 &lt;code&gt;commiturl&lt;/code&gt; 은 우선합니다.</target>
        </trans-unit>
        <trans-unit id="91682fd49c343f959bbb6403f6f6863feba84482" translate="yes" xml:space="preserve">
          <source>Similar to above:</source>
          <target state="translated">위와 비슷합니다 :</target>
        </trans-unit>
        <trans-unit id="e5c2486b9a7763634d7231fd9214964f9084de7d" translate="yes" xml:space="preserve">
          <source>Similar to the above, but Apache can be used to return static files that are stored on disk. On many systems this may be more efficient as Apache can ask the kernel to copy the file contents from the file system directly to the network:</source>
          <target state="translated">위와 비슷하지만 Apache를 사용하여 디스크에 저장된 정적 파일을 반환 할 수 있습니다. 많은 시스템에서 Apache가 커널에게 파일 시스템에서 파일 내용을 네트워크로 직접 복사하도록 요청할 수 있으므로이 방법이 더 효율적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5d7cb2c6d73b9150cefdf2e64e945bbe4a78cee" translate="yes" xml:space="preserve">
          <source>Similar to the apply backend, by default the merge backend drops commits that become empty unless -i/--interactive is specified (in which case it stops and asks the user what to do). The merge backend also has an --empty={drop,keep,ask} option for changing the behavior of handling commits that become empty.</source>
          <target state="translated">적용 백엔드와 유사하게, 기본적으로 병합 백엔드는 -i /-interactive가 지정되지 않는 한 비어있는 커밋을 삭제합니다 (이 경우 중지하고 사용자에게 수행 할 작업을 요청 함). 병합 백엔드에는 비어있는 커밋 처리 동작을 변경하기위한 --empty = {drop, keep, ask} 옵션도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d010174e63754716183c2af28e1291061e29078" translate="yes" xml:space="preserve">
          <source>Similar to the useSvmProps option; this is for users of the svnsync(1) command distributed with SVN 1.4.x and later.</source>
          <target state="translated">useSvmProps 옵션과 유사합니다. 이것은 SVN 1.4.x 이상과 함께 배포 된 svnsync (1) 명령 사용자를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="742718eb04c74d19e18742babbe16ee5d5955f76" translate="yes" xml:space="preserve">
          <source>Similar to the useSvmProps option; this is for users who need to remap the UUID manually. This may be useful in situations where the original UUID is not available via either useSvmProps or useSvnsyncProps.</source>
          <target state="translated">useSvmProps 옵션과 유사합니다. UUID를 수동으로 다시 매핑해야하는 사용자를위한 것입니다. useSvmProps 또는 useSvnsyncProps를 통해 원래 UUID를 사용할 수없는 상황에서 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b4ceb453e6bfcacc89ab013230d146d7c2efc84" translate="yes" xml:space="preserve">
          <source>Similar to two-line header for traditional &lt;code&gt;unified&lt;/code&gt; diff format, &lt;code&gt;/dev/null&lt;/code&gt; is used to signal created or deleted files.</source>
          <target state="translated">전통적인 &lt;code&gt;unified&lt;/code&gt; diff 형식의 2 줄 헤더와 유사하게 &lt;code&gt;/dev/null&lt;/code&gt; 은 생성되거나 삭제 된 파일을 알리는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9acea96e7cbe682e6caa9d2b57eedce27f5ebab4" translate="yes" xml:space="preserve">
          <source>Similarly, for a maintenance release, &lt;code&gt;maint&lt;/code&gt; is tracking the commits to be released. Therefore, in the steps above simply tag and push &lt;code&gt;maint&lt;/code&gt; rather than &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 유지 관리 릴리스의 경우 &lt;code&gt;maint&lt;/code&gt; 은 해제 될 커밋을 추적합니다. 따라서 위의 단계에서 &lt;code&gt;master&lt;/code&gt; 대신 &lt;code&gt;maint&lt;/code&gt; 를 태그하고 푸시하십시오 .</target>
        </trans-unit>
        <trans-unit id="8638660115fa0755b6d41e0f65af85c161534425" translate="yes" xml:space="preserve">
          <source>Similarly, if a linked working tree is moved without using &lt;code&gt;git worktree
move&lt;/code&gt;, the main working tree (or bare repository) will be unable to locate it. Running &lt;code&gt;repair&lt;/code&gt; within the recently-moved working tree will reestablish the connection. If multiple linked working trees are moved, running &lt;code&gt;repair&lt;/code&gt; from any working tree with each tree&amp;rsquo;s new &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; as an argument, will reestablish the connection to all the specified paths.</source>
          <target state="translated">마찬가지로 &lt;code&gt;git worktree move&lt;/code&gt; 를 사용하지 않고 연결된 작업 트리를 이동 하면 기본 작업 트리 (또는 베어 저장소)에서 찾을 수 없습니다. 최근 이동 한 작업 트리 내에서 &lt;code&gt;repair&lt;/code&gt; 실행 하면 연결이 다시 설정됩니다. 여러 개의 연결된 작업 트리가 이동되면 각 트리의 새 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 를 인수로 사용하여 작업 트리에서 &lt;code&gt;repair&lt;/code&gt; 를 실행 하면 지정된 모든 경로에 대한 연결이 다시 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7f4a6323889bb06df07efb39ac02d863fb790808" translate="yes" xml:space="preserve">
          <source>Similarly, no more helpers will be consulted once both username and password had been provided.</source>
          <target state="translated">마찬가지로 사용자 이름과 암호가 모두 제공되면 더 이상 도우미에게 문의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f0c6b86e38dcc0fc8a2626ab2d3596fb5907fb83" translate="yes" xml:space="preserve">
          <source>Similarly, storing binary dependencies (e.g., shared libraries or JAR files) or build products in the repository is generally not recommended. Dependencies and build products are best stored on an artifact or package server with only references, URLs, and hashes stored in the repository.</source>
          <target state="translated">마찬가지로 이진 종속성 (예 : 공유 라이브러리 또는 JAR 파일)을 저장하거나 저장소에 제품을 빌드하는 것은 일반적으로 권장되지 않습니다. 종속성 및 빌드 제품은 참조, URL 및 해시 만 저장소에 저장된 아티팩트 또는 패키지 서버에 저장하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c8cf6e3fc26d2562fdbc09f3e09e2deb878c7a85" translate="yes" xml:space="preserve">
          <source>Similarly, when moving files around, one can find that filenames with non-ascii or special characters end up in a different directory, one that includes a double quote character. (This is technically the same issue as above with quoting, but perhaps an interesting different way that it can and has manifested as a problem.)</source>
          <target state="translated">마찬가지로, 파일을 이동할 때 ASCII가 아닌 문자 나 특수 문자가있는 파일 이름은 큰 따옴표 문자가 포함 된 다른 디렉토리에있게됩니다. (이것은 기술적으로 위에서 인용 한 것과 같은 문제이지만 아마도 문제로 나타날 수 있고 흥미로운 다른 방법 일 것입니다.)</target>
        </trans-unit>
        <trans-unit id="47fa1a83138cf11ea34d19a92cc77db11eb4b97c" translate="yes" xml:space="preserve">
          <source>Similarly, when the &quot;recursive&quot; merge strategy runs, and finds that there are criss-cross merges and thus more than one merge base (which is fairly unusual, but it does happen), it will generate one temporary midway tree (or possibly even more, if you had lots of criss-crossing merges and more than two merge bases) as a temporary internal merge base, and again, those are real objects, but the end result will not end up pointing to them, so they end up &quot;dangling&quot; in your repository.</source>
          <target state="translated">마찬가지로 &quot;재귀 적&quot;병합 전략이 실행되고 십자형 병합이 있고 둘 이상의 병합 기반이있는 것을 발견하면 (이것은 매우 드문 일이지만 발생합니다) 임시 중간 중간 트리 (또는 가능할 수도 있음)를 생성합니다 또한 임시 내부 병합 기준으로 많은 교차 교차 병합과 2 개 이상의 병합 기준이있는 경우) 실제 객체이지만 최종 결과는이를 가리 키지 않으므로 &quot; 저장소에 매달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="50765cb4cf598285ffabcacb2eda47bdf85bbc67" translate="yes" xml:space="preserve">
          <source>Similarly, you need only trust the SHA-1 name of a top-level tree object to trust the contents of the entire directory that it refers to, and if you receive the SHA-1 name of a commit from a trusted source, then you can easily verify the entire history of commits reachable through parents of that commit, and all of those contents of the trees referred to by those commits.</source>
          <target state="translated">마찬가지로 최상위 트리 개체의 SHA-1 이름 만 신뢰하면 참조하는 전체 디렉토리의 내용을 신뢰하고 신뢰할 수있는 소스로부터 커밋의 SHA-1 이름을 수신하면 해당 커밋의 부모 및 해당 커밋이 참조하는 트리의 모든 내용을 통해 도달 가능한 커밋의 전체 기록을 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35267477ddadd32e54d2580eaf5f6347904aefaa" translate="yes" xml:space="preserve">
          <source>Simple UNIX mbox splitter program</source>
          <target state="translated">간단한 유닉스 mbox 스플리터 프로그램</target>
        </trans-unit>
        <trans-unit id="e6081dd40a736a561294c958c5f476bf808af40b" translate="yes" xml:space="preserve">
          <source>Simplifies the history to the simplest history explaining the final state of the tree. Simplest because it prunes some side branches if the end result is the same (i.e. merging branches with the same content)</source>
          <target state="translated">트리의 최종 상태를 설명하는 가장 간단한 히스토리로 히스토리를 단순화합니다. 최종 결과가 동일한 경우 일부 사이드 브랜치를 제거하므로 가장 간단합니다 (예 : 동일한 컨텐츠의 브랜치 병합)</target>
        </trans-unit>
        <trans-unit id="7d47a55c52a010c445880763e4c0c53ec8d956ef" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;dcommit&lt;/code&gt; uses rebase internally, any Git branches you &lt;code&gt;git push&lt;/code&gt; to before &lt;code&gt;dcommit&lt;/code&gt; on will require forcing an overwrite of the existing ref on the remote repository. This is generally considered bad practice, see the &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; documentation for details.</source>
          <target state="translated">&lt;code&gt;dcommit&lt;/code&gt; 은 내부적으로 rebase를 사용 하므로 dcommit 을 시작하기 전에 &lt;code&gt;git push&lt;/code&gt; 를 사용 하는 원격 Git 브랜치 는 원격 리포지토리의 기존 참조를 덮어 &lt;code&gt;dcommit&lt;/code&gt; 합니다. 이것은 일반적으로 나쁜 습관으로 간주됩니다. 자세한 내용은 &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d3cbf9539838f097e44d7366548fff10dd5a4bb6" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;git fast-import&lt;/code&gt; cannot tag trees, you will not be able to export the linux.git repository completely, as it contains a tag referencing a tree instead of a commit.</source>
          <target state="translated">때문에 &lt;code&gt;git fast-import&lt;/code&gt; 대신 커밋의 나무를 참조하는 태그가 포함로 할 수없는 태그 나무, 당신은 완전히 linux.git 저장소를 내보낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e8a0aceddf81ac41c98d5a8bdbe00960df868272" translate="yes" xml:space="preserve">
          <source>Since every developer&amp;rsquo;s repository has the same complete copy of the project history, no repository is special, and it is trivial for another developer to take over maintenance of a project, either by mutual agreement, or because a maintainer becomes unresponsive or difficult to work with.</source>
          <target state="translated">모든 개발자의 저장소에는 동일한 프로젝트 히스토리 사본이 있으므로 저장소는 특별하지 않으며 다른 개발자가 상호 합의에 의해 또는 유지 보수 담당자가 응답하지 않거나 작업하기가 어렵 기 때문에 프로젝트 유지 보수를 인수하는 것이 쉽지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="ff45ae2cc9973e736a0612a33b064d4efb949c7a" translate="yes" xml:space="preserve">
          <source>Since keeping up-to-date with both branches and tags on the remote is a common use-case the &lt;code&gt;--prune-tags&lt;/code&gt; option can be supplied along with &lt;code&gt;--prune&lt;/code&gt; to prune local tags that don&amp;rsquo;t exist on the remote, and force-update those tags that differ. Tag pruning can also be enabled with &lt;code&gt;fetch.pruneTags&lt;/code&gt; or &lt;code&gt;remote.&amp;lt;name&amp;gt;.pruneTags&lt;/code&gt; in the config. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">원격에서 브랜치와 태그를 모두 최신 상태로 유지하는 것이 일반적인 사용 사례 &lt;code&gt;--prune-tags&lt;/code&gt; 옵션을 &lt;code&gt;--prune&lt;/code&gt; 과 함께 제공 하여 원격에 존재하지 않는 로컬 태그를 제거 할 수 있습니다. 다른 태그를 강제 업데이트하십시오. 구성에서 &lt;code&gt;fetch.pruneTags&lt;/code&gt; 또는 &lt;code&gt;remote.&amp;lt;name&amp;gt;.pruneTags&lt;/code&gt; 를 사용하여 태그 제거를 활성화 할 수도 있습니다 . &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0932a869e1657064106036f8682ab82f7b34c539" translate="yes" xml:space="preserve">
          <source>Since object names are computed the same way in every repository, the same content stored in two repositories will always be stored under the same name.</source>
          <target state="translated">객체 이름은 모든 리포지토리에서 동일한 방식으로 계산되므로 두 리포지토리에 저장된 동일한 컨텐츠는 항상 동일한 이름으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="bea459735363a6dcc4076e4ad600cb49ce5e1876" translate="yes" xml:space="preserve">
          <source>Since submodules may have unpushed changes or untracked files, removing them could result in data loss. Thus, changing sparse inclusion/exclusion rules will not cause an already checked out submodule to be removed from the working copy. Said another way, just as &lt;code&gt;checkout&lt;/code&gt; will not cause submodules to be automatically removed or initialized even when switching between branches that remove or add submodules, using &lt;code&gt;sparse-checkout&lt;/code&gt; to reduce or expand the scope of &quot;interesting&quot; files will not cause submodules to be automatically deinitialized or initialized either.</source>
          <target state="translated">하위 모듈에 푸시되지 않은 변경 사항이나 추적되지 않은 파일이있을 수 있으므로 제거하면 데이터가 손실 될 수 있습니다. 따라서 스파 스 포함 / 제외 규칙을 변경해도 이미 체크 아웃 된 하위 모듈이 작업 복사본에서 제거되지는 않습니다. 다시 말하면, &lt;code&gt;checkout&lt;/code&gt; 인해 하위 모듈을 제거하거나 추가하는 분기간에 전환 할 때에도 하위 모듈이 자동으로 제거되거나 초기화되지 않는 것처럼 &lt;code&gt;sparse-checkout&lt;/code&gt; 을 사용하여 &quot;관심있는&quot;파일의 범위를 줄이거 나 확장해도 하위 모듈이 자동으로 발생하지 않습니다. 초기화되지 않았거나 초기화되었습니다.</target>
        </trans-unit>
        <trans-unit id="c6783a475fdc4e2463b00ffd216c9d8a1b41c5ce" translate="yes" xml:space="preserve">
          <source>Since the blob is entirely defined by its data, if two files in a directory tree (or in multiple different versions of the repository) have the same contents, they will share the same blob object. The object is totally independent of its location in the directory tree, and renaming a file does not change the object that file is associated with.</source>
          <target state="translated">BLOB는 데이터에 의해 완전히 정의되므로 디렉토리 트리 (또는 여러 다른 버전의 저장소)에있는 두 파일의 내용이 동일한 경우 동일한 Blob 오브젝트를 공유합니다. 객체는 디렉토리 트리에서의 위치와 완전히 독립적이며 파일 이름을 바꾸더라도 파일과 관련된 객체는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3fb22d6e6da288d244e8acdd9955bf43f0ad8d0" translate="yes" xml:space="preserve">
          <source>Since the current state of closing.txt is cached in the index file, it is listed as &quot;Changes to be committed&quot;. Since file.txt has changes in the working directory that aren&amp;rsquo;t reflected in the index, it is marked &quot;changed but not updated&quot;. At this point, running &quot;git commit&quot; would create a commit that added closing.txt (with its new contents), but that didn&amp;rsquo;t modify file.txt.</source>
          <target state="translated">닫기 .txt의 현재 상태가 인덱스 파일에 캐시되므로 &quot;커밋 변경 사항&quot;으로 표시됩니다. file.txt에는 작업 디렉토리에서 색인에 반영되지 않은 변경 사항이 있으므로 &quot;변경되었지만 업데이트되지 않음&quot;으로 표시됩니다. 이 시점에서 &quot;git commit&quot;을 실행하면 새 내용과 함께 closing.txt를 추가했지만 file.txt를 수정하지 않은 커밋이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="78b19ba60aba5b2f618c3990a75d2fca7411595a" translate="yes" xml:space="preserve">
          <source>Since the noMetadata, rewriteRoot, rewriteUUID, useSvnsyncProps and useSvmProps options all affect the metadata generated and used by &lt;code&gt;git svn&lt;/code&gt;; they &lt;strong&gt;must&lt;/strong&gt; be set in the configuration file before any history is imported and these settings should never be changed once they are set.</source>
          <target state="translated">noMetadata, rewriteRoot, rewriteUUID, useSvnsyncProps 및 useSvmProps 옵션은 모두 &lt;code&gt;git svn&lt;/code&gt; 에서 생성하고 사용하는 메타 데이터에 영향을줍니다 . 그들은 &lt;strong&gt;있어야&lt;/strong&gt; 어떤 역사를 가져 오기 전에 구성 파일에 설정하고이 설정되면이 설정은 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6c0fcca9337c1cb048efaf57760c6fdc1a7b6b6f" translate="yes" xml:space="preserve">
          <source>Singe line category of a project, used to group projects if &lt;code&gt;$projects_list_group_categories&lt;/code&gt; is enabled. By default (file and configuration variable absent), uncategorized projects are put in the &lt;code&gt;$project_list_default_category&lt;/code&gt; category. You can use the &lt;code&gt;gitweb.category&lt;/code&gt; repo configuration variable, but the file takes precedence.</source>
          <target state="translated">&lt;code&gt;$projects_list_group_categories&lt;/code&gt; 가 활성화 된 경우 프로젝트의 단일 라인 범주로 프로젝트를 그룹화하는 데 사용됩니다 . 기본적으로 (파일 및 구성 변수가 없음) 분류되지 않은 프로젝트는 &lt;code&gt;$project_list_default_category&lt;/code&gt; 범주에 배치됩니다. &lt;code&gt;gitweb.category&lt;/code&gt; repo 구성 변수를 사용할 수 있지만 파일이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="1622ee3a3548a98ace63f4a1f20c802cbd3d6865" translate="yes" xml:space="preserve">
          <source>Single Tree Merge</source>
          <target state="translated">단일 트리 병합</target>
        </trans-unit>
        <trans-unit id="68fe6fe857d1a576bbea2c5ba543ec91391124bd" translate="yes" xml:space="preserve">
          <source>Single URL for gitweb and for fetching</source>
          <target state="translated">gitweb과 페칭을위한 단일 URL</target>
        </trans-unit>
        <trans-unit id="c63aa67778ae9fde52963fd98eabefccd9f535ba" translate="yes" xml:space="preserve">
          <source>Size of the Git repository: In its current form Git scales up poorly for large repositories containing content that is not compressed by delta computation between trees. For example, you can use submodules to hold large binary assets and these repositories can be shallowly cloned such that you do not have a large history locally.</source>
          <target state="translated">Git 리포지토리의 크기 : 현재 형태에서 Git은 트리 간의 델타 계산에 의해 압축되지 않은 내용을 포함하는 큰 리포지토리에 대해 제대로 확장되지 않습니다. 예를 들어 하위 모듈을 사용하여 큰 이진 자산을 보유 할 수 있으며 이러한 리포지토리는 얕게 복제되어 로컬로 큰 기록이 없습니다.</target>
        </trans-unit>
        <trans-unit id="109e0b1e1d08be0f664fabdbefc14a841a52fd41" translate="yes" xml:space="preserve">
          <source>Skip &quot;branches&quot; and &quot;tags&quot; of first level directories</source>
          <target state="translated">첫 번째 레벨 디렉토리의 &quot;분기&quot;및 &quot;태그&quot;건너 뛰기</target>
        </trans-unit>
        <trans-unit id="89ac85d0525bb0b20e17b8b50eb25e661e2c2664" translate="yes" xml:space="preserve">
          <source>Skip &quot;doc*&quot; directory for every fetch</source>
          <target state="translated">가져올 때마다 &quot;doc *&quot;디렉토리를 건너 뛰십시오.</target>
        </trans-unit>
        <trans-unit id="160b3d2c26cf27627f75b323f1f2f273b38eb0f3" translate="yes" xml:space="preserve">
          <source>Skip &lt;code&gt;number&lt;/code&gt; commits before starting to show the commit output.</source>
          <target state="translated">커밋 출력 표시를 시작하기 전에 &lt;code&gt;number&lt;/code&gt; 커밋을 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="143f0d9f0b5891b48ad38fad90174c475ab3d608" translate="yes" xml:space="preserve">
          <source>Skip algorithm</source>
          <target state="translated">알고리즘 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="fd9da89bf39cfad867f423a79c66781ba5934141" translate="yes" xml:space="preserve">
          <source>Skip algorithm discussed</source>
          <target state="translated">알고리즘 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="e6458f822412c73c4c309bd3d568b1a062547077" translate="yes" xml:space="preserve">
          <source>Skip and remove all lines starting with comment character (default &lt;code&gt;#&lt;/code&gt;).</source>
          <target state="translated">주석 문자로 시작하는 모든 줄을 건너 뛰고 제거하십시오 (기본값 &lt;code&gt;#&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8d0905b7d9c2aadf471da8a0572104f192b6463b" translate="yes" xml:space="preserve">
          <source>Skip move or rename actions which would lead to an error condition. An error happens when a source is neither existing nor controlled by Git, or when it would overwrite an existing file unless &lt;code&gt;-f&lt;/code&gt; is given.</source>
          <target state="translated">오류 조건으로 이어질 이동 또는 이름 바꾸기 작업을 건너 뜁니다. 소스가 존재하지 않거나 Git에 의해 제어되지 않거나 &lt;code&gt;-f&lt;/code&gt; 를 지정 하지 않으면 기존 파일을 덮어 쓰는 경우 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="93791f01919fc21e7203f6ad13249cb4adbabc2c" translate="yes" xml:space="preserve">
          <source>Skip output of blob objects and instead refer to blobs via their original SHA-1 hash. This is useful when rewriting the directory structure or history of a repository without touching the contents of individual files. Note that the resulting stream can only be used by a repository which already contains the necessary objects.</source>
          <target state="translated">얼룩 개체의 출력을 건너 뛰고 대신 원래 SHA-1 해시를 통해 얼룩을 참조합니다. 개별 파일의 내용을 건드리지 않고 디렉토리 구조 또는 저장소의 히스토리를 다시 작성할 때 유용합니다. 결과 스트림은 필요한 오브젝트가 이미 포함 된 저장소에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3704502c09a46589e3fc638d0b7431bdbfb4de69" translate="yes" xml:space="preserve">
          <source>Skip paths matching the regex.</source>
          <target state="translated">정규식과 일치하는 경로를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="8024d787464bdc42cf9e1692fcecd2225427e388" translate="yes" xml:space="preserve">
          <source>Skip the current commit and continue with the rest of the sequence.</source>
          <target state="translated">현재 커밋을 건너 뛰고 나머지 시퀀스를 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="8b89cae0a7a7a1a500c597f44f79f240ec0b9f01" translate="yes" xml:space="preserve">
          <source>Skip the current patch. This is only meaningful when restarting an aborted patch.</source>
          <target state="translated">현재 패치를 건너 뜁니다. 중단 된 패치를 다시 시작할 때만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="37f2142ef251b529e2961f797b73a85bc8215244" translate="yes" xml:space="preserve">
          <source>Skip the first &amp;lt;nn&amp;gt; numbers, for example if -f3 is specified, start the numbering with 0004.</source>
          <target state="translated">첫 번째 &amp;lt;nn&amp;gt; 숫자를 건너 뜁니다 (예 : -f3이 지정된 경우 0004로 번호 매기기 시작).</target>
        </trans-unit>
        <trans-unit id="53b34cae8fb29a9d928b4eaf4c1d1171200a7cd2" translate="yes" xml:space="preserve">
          <source>Skip untracked files matching pattern. Note that pattern is a shell wildcard pattern. See EXCLUDE PATTERNS below for more information.</source>
          <target state="translated">추적되지 않은 파일 일치 패턴을 건너 뜁니다. 패턴은 쉘 와일드 카드 패턴입니다. 자세한 내용은 아래의 제외 패턴을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5c514bc7b54c5d446f341bd390aa604bcfe7a779" translate="yes" xml:space="preserve">
          <source>Skip-worktree bit</source>
          <target state="translated">스킵 워크 트리 비트</target>
        </trans-unit>
        <trans-unit id="1c6f4418b45f18f2276258a670ff4fb3ee82370c" translate="yes" xml:space="preserve">
          <source>Skip-worktree bit can be defined in one (long) sentence: When reading an entry, if it is marked as skip-worktree, then Git pretends its working directory version is up to date and read the index version instead.</source>
          <target state="translated">건너 뛰기 작업 트리 비트는 하나의 긴 문장으로 정의 할 수 있습니다. 항목을 읽을 때 건너 뛰기 작업 트리로 표시되면 Git은 작업 디렉토리 버전이 최신 인 것으로 가정하고 대신 인덱스 버전을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="497781ce21708a17d4e26d12bd089a723d673b06" translate="yes" xml:space="preserve">
          <source>So &quot;git bisect&quot; is designed to help find a &quot;first bad commit&quot;. And to be as efficient as possible, it tries to perform a binary search.</source>
          <target state="translated">따라서 &quot;git bisect&quot;는 &quot;첫 번째 잘못된 커밋&quot;을 찾는 데 도움이되도록 설계되었습니다. 그리고 가능한 효율적으로 이진 검색을 수행하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="2f63b69e28337cf529c035b03d9daaf28859996c" translate="yes" xml:space="preserve">
          <source>So &lt;code&gt;git diff&lt;/code&gt; is comparing against something other than the head. The thing that it&amp;rsquo;s comparing against is actually the index file, which is stored in .git/index in a binary format, but whose contents we can examine with ls-files:</source>
          <target state="translated">그래서 &lt;code&gt;git diff&lt;/code&gt; 머리가 아닌 다른 뭔가에 대해 비교된다. 비교하는 것은 실제로 이진 형식으로 .git / index에 저장되지만 ls-files로 내용을 검사 할 수있는 색인 파일입니다.</target>
        </trans-unit>
        <trans-unit id="87fbbf25154de6df0238ad0568533ed6007a8d44" translate="yes" xml:space="preserve">
          <source>So a good work-flow should be designed around the above points. That is making bisecting easier, more useful and standard.</source>
          <target state="translated">따라서 위의 점을 중심으로 좋은 작업 흐름을 설계해야합니다. 그것은 이등분을보다 쉽고 유용하며 표준으로 만들고 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe9010d034fcf65a3dd663b44598da34c322ed58" translate="yes" xml:space="preserve">
          <source>So be careful when using this with a refspec like &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt;, or any other refspec which might map references from multiple remotes to the same local namespace.</source>
          <target state="translated">따라서 이것을 &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; 와 같은 refspec과 함께 사용할 때 또는 여러 리모트에서 참조를 동일한 로컬 네임 스페이스에 맵핑 할 수있는 다른 refspec 과 함께 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b170fc73b3dfabca43a4cde5eef61bd350b47e1" translate="yes" xml:space="preserve">
          <source>So by default &lt;code&gt;git commit&lt;/code&gt; uses the index to create the commit, not the working tree; the &quot;-a&quot; option to commit tells it to first update the index with all changes in the working tree.</source>
          <target state="translated">따라서 기본적으로 &lt;code&gt;git commit&lt;/code&gt; 은 인덱스를 사용하여 작업 트리가 아닌 커밋을 만듭니다. 커밋하는 &quot;-a&quot;옵션은 먼저 작업 트리의 모든 변경 사항으로 인덱스를 업데이트하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="f86c14eb732dcf1c0bad37f2fc6a2cc528890e0c" translate="yes" xml:space="preserve">
          <source>So doing a &lt;code&gt;git diff-index --cached&lt;/code&gt; is basically very useful when you are asking yourself &quot;what have I already marked for being committed, and what&amp;rsquo;s the difference to a previous tree&quot;.</source>
          <target state="translated">&lt;code&gt;git diff-index --cached&lt;/code&gt; 를 수행하는 것은 &quot;내가 이미 커밋 된 것으로 표시 한 것과 이전 트리와의 차이점&quot;을 스스로에게 물어볼 때 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d45f632df019622532eb259f26fdc9a9f2411148" translate="yes" xml:space="preserve">
          <source>So for example when &lt;code&gt;--thread&lt;/code&gt; and &lt;code&gt;--no-chain-reply-to&lt;/code&gt; are specified, the second and subsequent patches will be replies to the first one like in the illustration below where &lt;code&gt;[PATCH v2 0/3]&lt;/code&gt; is in reply to &lt;code&gt;[PATCH 0/2]&lt;/code&gt;:</source>
          <target state="translated">예를 들어 &lt;code&gt;--thread&lt;/code&gt; 및 &lt;code&gt;--no-chain-reply-to&lt;/code&gt; 를 지정하면 두 번째 및 이후 패치는 아래 그림과 같이 &lt;code&gt;[PATCH v2 0/3]&lt;/code&gt; 이 &lt;code&gt;[PATCH 0/2]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8dac83a478835c1820a1dc8da47f73a69f302106" translate="yes" xml:space="preserve">
          <source>So git bisect is unconditional goodness - and feel free to quote that ;-)</source>
          <target state="translated">따라서 git bisect는 무조건적 선하심입니다.</target>
        </trans-unit>
        <trans-unit id="9a21b5de38126daf9f68802ae918237cb622de11" translate="yes" xml:space="preserve">
          <source>So if there is no bad merge base, the bisection process continues as usual after this step.</source>
          <target state="translated">따라서 잘못된 병합 기준이 없으면이 단계 후에도 정상적으로 이분법 프로세스가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="d61ad44b1ad1935830d69abe827279c6ac721854" translate="yes" xml:space="preserve">
          <source>So if we could just &quot;replace&quot; Z by Z' when we bisect, then we would not need to add anything to a script. It would just work for anyone in the project sharing the special branches and the replacements.</source>
          <target state="translated">따라서 이등분 할 때 Z를 Z로 '바꿀'수 있다면 스크립트에 아무것도 추가 할 필요가 없습니다. 특별한 브랜치와 교체를 공유하는 프로젝트의 모든 사람에게 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="6be137f4b3e3bebc88bcbf9a9fd9420c4009228f" translate="yes" xml:space="preserve">
          <source>So if you know how to create test cases and how to bisect, you will be subject to a virtuous circle:</source>
          <target state="translated">따라서 테스트 사례를 만드는 방법과 이등분하는 방법을 알고 있다면 선순환이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b28d1446f9340641647b1bfa92704042d040df77" translate="yes" xml:space="preserve">
          <source>So if you used &quot;git bisect skip&quot; (or the run script exited with special code 125) you could get a result like this:</source>
          <target state="translated">따라서 &quot;git bisect skip&quot;(또는 특수 코드 125로 종료 된 실행 스크립트)을 사용하면 다음과 같은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edcb1ada2530409c42369421497ba8e78619bff1" translate="yes" xml:space="preserve">
          <source>So in the above example the best bisection point is commit C.</source>
          <target state="translated">위의 예에서 가장 좋은이 분점은 커밋 C입니다.</target>
        </trans-unit>
        <trans-unit id="6fdeecf50af4098d1933aa89ebcede0a8177561f" translate="yes" xml:space="preserve">
          <source>So in the end this means that to find the best bisection commits we should maximize the function:</source>
          <target state="translated">결국 이것은 최고의 bisection commit을 찾으려면 함수를 최대화해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="58a2f1d134fdcd7a3743e88aa224e9253e6fbd42" translate="yes" xml:space="preserve">
          <source>So it is a fact that commits near an untestable commit have a high probability of being untestable themselves. And the best bisection commits are often found together too (due to the bisection algorithm).</source>
          <target state="translated">따라서 테스트 할 수없는 커밋 근처의 커밋은 테스트 할 수없는 확률이 높습니다. 그리고 최고의 이분법 커밋은 종종 (이분법 알고리즘으로 인해) 함께 발견됩니다.</target>
        </trans-unit>
        <trans-unit id="aa016e179ca75d2a0eb71de197505264fa3225e9" translate="yes" xml:space="preserve">
          <source>So now we know how Git uses the object database to represent a project&amp;rsquo;s history:</source>
          <target state="translated">이제 Git이 오브젝트 데이터베이스를 사용하여 프로젝트 히스토리를 나타내는 방법을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="ce2a816c8c6bc197cebf7da353940391ec82e2e3" translate="yes" xml:space="preserve">
          <source>So now you know that the missing blob was the data for a file named &lt;code&gt;myfile&lt;/code&gt;. And chances are you can also identify the directory&amp;mdash;​let&amp;rsquo;s say it&amp;rsquo;s in &lt;code&gt;somedirectory&lt;/code&gt;. If you&amp;rsquo;re lucky the missing copy might be the same as the copy you have checked out in your working tree at &lt;code&gt;somedirectory/myfile&lt;/code&gt;; you can test whether that&amp;rsquo;s right with &lt;a href=&quot;git-hash-object&quot;&gt;git-hash-object[1]&lt;/a&gt;:</source>
          <target state="translated">이제 누락 된 얼룩이 &lt;code&gt;myfile&lt;/code&gt; 이라는 파일의 데이터라는 것을 알았습니다 . 또한 디렉토리를 식별 할 수도 있습니다. 디렉토리가 &lt;code&gt;somedirectory&lt;/code&gt; 에 있다고 가정 해 봅시다 . 운이 좋으면 누락 된 사본은 작업 트리에서 &lt;code&gt;somedirectory/myfile&lt;/code&gt; 의 체크 아웃 한 사본과 동일 할 수 있습니다 . &lt;a href=&quot;git-hash-object&quot;&gt;git-hash-object [1] 사용&lt;/a&gt; 하여 올바른지 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02795e1f800cead1112ee5200f5eaf14f8868f55" translate="yes" xml:space="preserve">
          <source>So of course it&amp;rsquo;s much better as it&amp;rsquo;s O(N * T) vs O(N * T * M) if you would test everything after each commit.</source>
          <target state="translated">물론 각 커밋 후에 모든 것을 테스트한다면 O (N * T) 대 O (N * T * M)이므로 훨씬 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bf839044c5c4761411ba28111f62e6182a819140" translate="yes" xml:space="preserve">
          <source>So only the W and B commits will be kept. Because commits X and Y will have been removed by rules a) and b) respectively, and because commits G are removed by rule b) too.</source>
          <target state="translated">따라서 W 및 B 커밋 만 유지됩니다. 커밋 X와 Y는 각각 규칙 a)와 b)에 의해 제거되고 커밋 G도 규칙 b)에 의해 제거되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2adeb678ade18152fba70f98a363a63cf540c6c1" translate="yes" xml:space="preserve">
          <source>So regressions are fought all the time by developers, and indeed it is well known that bugs should be fixed as soon as possible, so as soon as they are found. That&amp;rsquo;s why it is interesting to have good tools for this purpose.</source>
          <target state="translated">따라서 회귀는 개발자가 항상 싸워야하며 실제로 버그는 가능한 빨리 수정해야한다는 것이 잘 알려져 있습니다. 그렇기 때문에이 목적을 위해 좋은 도구를 사용하는 것이 흥미 롭습니다.</target>
        </trans-unit>
        <trans-unit id="e3329398bcdff474dec989568418215901207762" translate="yes" xml:space="preserve">
          <source>So test suites and &quot;git bisect&quot; are complementary tools that are very powerful and efficient when used together.</source>
          <target state="translated">따라서 테스트 스위트와 &quot;git bisect&quot;는 함께 사용할 때 매우 강력하고 효율적인 보완 도구입니다.</target>
        </trans-unit>
        <trans-unit id="af6a5f3f7d1b778946d7ea3d80d407ba283ecbfd" translate="yes" xml:space="preserve">
          <source>So the algorithm used by &quot;git bisect&quot; to find the best bisection commit when there are no skipped commits is the following:</source>
          <target state="translated">따라서 건너 뛴 커밋이 없을 때 최상의 bisection 커밋을 찾기 위해 &quot;git bisect&quot;에서 사용하는 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d52372a3732a9693c38928f4af80ece55caba390" translate="yes" xml:space="preserve">
          <source>So the current algorithm seems to be the best possible given what we initially supposed.</source>
          <target state="translated">따라서 현재의 알고리즘은 우리가 처음에 생각한 것을 고려할 때 가장 좋은 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="ff070bb5b96ce6bdea0ee7e21e6149356aab622c" translate="yes" xml:space="preserve">
          <source>So the ideal is usually to produce a series of patches such that:</source>
          <target state="translated">따라서 이상적인 것은 일반적으로 다음과 같은 일련의 패치를 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a9929fd0a7cc637ffed9aa6825e45ac8df015448" translate="yes" xml:space="preserve">
          <source>So to help people find commits that introduce a &quot;bad&quot; behavior, the &quot;git bisect&quot; set of commands was invented. And it follows of course that in &quot;git bisect&quot; parlance, commits where the &quot;interesting behavior&quot; is present are called &quot;bad&quot; commits, while other commits are called &quot;good&quot; commits. And a commit that introduce the behavior we are interested in is called a &quot;first bad commit&quot;. Note that there could be more than one &quot;first bad commit&quot; in the commit space we are searching.</source>
          <target state="translated">따라서 사람들이 &quot;나쁜&quot;행동을 유발하는 커밋을 찾을 수 있도록 &quot;git bisect&quot;명령 세트가 개발되었습니다. 그리고 &quot;git bisect&quot;용어에서 &quot;흥미로운 행동&quot;이 존재하는 커밋은 &quot;나쁜&quot;커밋이라고하고 다른 커밋은 &quot;좋은&quot;커밋이라고합니다. 그리고 우리가 관심있는 행동을 소개하는 커밋을 &quot;첫 번째 나쁜 커밋&quot;이라고합니다. 검색중인 커밋 공간에 둘 이상의 &quot;첫 번째 잘못된 커밋&quot;이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15c2cfea7209fe12c9a7f928eefdf57e7efd00f9" translate="yes" xml:space="preserve">
          <source>So to introduce some real trust in the system, the only thing you need to do is to digitally sign just 'one' special note, which includes the name of a top-level commit. Your digital signature shows others that you trust that commit, and the immutability of the history of commits tells others that they can trust the whole history.</source>
          <target state="translated">따라서 시스템에 대한 진정한 신뢰를 얻으려면 최상위 커밋 이름을 포함하는 '한 가지'특별한 메모에 디지털 서명 만하면됩니다. 당신의 디지털 서명은 당신이 그 커밋을 신뢰한다는 것을 다른 사람들에게 보여주고, 커밋 기록의 불변성은 다른 사람들에게 그들이 전체 역사를 신뢰할 수 있다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="30ae77f4affa991e80efc3f102be0a94e3ede52f" translate="yes" xml:space="preserve">
          <source>So to introduce some real trust in the system, the only thing you need to do is to digitally sign just &lt;code&gt;one&lt;/code&gt; special note, which includes the name of a top-level commit. Your digital signature shows others that you trust that commit, and the immutability of the history of commits tells others that they can trust the whole history.</source>
          <target state="translated">따라서 시스템에 대한 진정한 신뢰를 도입하려면 최상위 커밋의 이름을 포함하는 &lt;code&gt;one&lt;/code&gt; 특수 메모 에 디지털 서명 만하면 됩니다. 디지털 서명은 다른 사람에게 해당 커밋을 신뢰한다는 것을 보여주고, 커밋 기록의 불변성은 다른 사람에게 전체 기록을 신뢰할 수 있음을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="909741d50394835646e0e74eaab338b4f855de2e" translate="yes" xml:space="preserve">
          <source>So to populate the index with the two files you just created, you can do</source>
          <target state="translated">방금 만든 두 파일로 인덱스를 채우려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f597f374b45ae15a5bbfbd431d1e5af284187139" translate="yes" xml:space="preserve">
          <source>So using a PRNG with a bias to favor commits away from the good and bad commits looked like a good choice.</source>
          <target state="translated">따라서 좋은 커밋과 나쁜 커밋에서 커밋을 선호하는 편견과 함께 PRNG를 사용하는 것이 좋은 선택처럼 보였습니다.</target>
        </trans-unit>
        <trans-unit id="1d3965fc903eee9b8f55d2c4363ff10ff9b5318f" translate="yes" xml:space="preserve">
          <source>So very soon it will not be possible to completely test everything.</source>
          <target state="translated">곧 모든 것을 완전히 테스트하는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="c734302804af13b8fb3578fee7c8a382eab7f492" translate="yes" xml:space="preserve">
          <source>So we chose G, H, K or L as the best bisection point, which is better than F. Because if for example L is bad, then we will know not only that L, M and N are bad but also that G, H, I and J are not the first bad commit (since we suppose that there is only one first bad commit and it must be an ancestor of L).</source>
          <target state="translated">따라서 우리는 G, H, K 또는 L을 F보다 나은 최고의이 분점으로 선택했습니다. 예를 들어 L이 나쁘면 L, M 및 N이 나쁘다는 것뿐만 아니라 G, H도 알 수 있습니다. , I와 J는 첫 번째 나쁜 커밋이 아닙니다 (우리는 첫 번째 나쁜 커밋이 하나만 있고 L의 조상이어야한다고 가정하기 때문에).</target>
        </trans-unit>
        <trans-unit id="52135537297d21de1e1bab64c3c62387485ffd7b" translate="yes" xml:space="preserve">
          <source>So we would be left with only:</source>
          <target state="translated">따라서 우리는 다음과 같이 남게됩니다.</target>
        </trans-unit>
        <trans-unit id="9a854aba22b6e93e9800490c72e201394edc5390" translate="yes" xml:space="preserve">
          <source>So what are the tools used to fight regressions? They are nearly the same as those used to fight regular bugs. The only specific tools are test suites and tools similar as &quot;git bisect&quot;.</source>
          <target state="translated">그렇다면 회귀와 싸우는 데 사용되는 도구는 무엇입니까? 그것들은 일반적인 버그와 싸우는 데 사용되는 것과 거의 동일합니다. 유일한 툴은 테스트 스위트와 &quot;git bisect&quot;와 유사한 툴입니다.</target>
        </trans-unit>
        <trans-unit id="17175b38ddc3adc987023ab7708e71618fdb213f" translate="yes" xml:space="preserve">
          <source>So what our &lt;code&gt;git add&lt;/code&gt; did was store a new blob and then put a reference to it in the index file. If we modify the file again, we&amp;rsquo;ll see that the new modifications are reflected in the &lt;code&gt;git diff&lt;/code&gt; output:</source>
          <target state="translated">그래서 우리의 &lt;code&gt;git add&lt;/code&gt; 한 일은 새로운 덩어리를 저장하고 인덱스 파일에 대한 참조를 넣어했다. 파일을 다시 수정하면 새로운 수정 사항이 &lt;code&gt;git diff&lt;/code&gt; 출력에 반영됩니다 .</target>
        </trans-unit>
        <trans-unit id="c52a5d49814c75f968644da3c05f28677f66e5d9" translate="yes" xml:space="preserve">
          <source>So when a commit is marked as &quot;bad&quot; we know we can remove all the commits in the graph except those that are ancestors of the new &quot;bad&quot; commit. This means that:</source>
          <target state="translated">따라서 커밋이 &quot;나쁜&quot;것으로 표시되면 새로운 &quot;나쁜&quot;커밋의 조상 인 커밋을 제외한 모든 커밋을 그래프에서 제거 할 수 있습니다. 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2ab9a98e063e3527611545f584f2c39a22096906" translate="yes" xml:space="preserve">
          <source>So, look into &lt;code&gt;builtin/cat-file.c&lt;/code&gt;, search for &lt;code&gt;cmd_cat_file()&lt;/code&gt; and look what it does.</source>
          <target state="translated">따라서 &lt;code&gt;builtin/cat-file.c&lt;/code&gt; 를 찾아 &lt;code&gt;cmd_cat_file()&lt;/code&gt; 을 검색하고 그 기능을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="190b1ee6ab5b81f82f0d76cf355df1a21f43d2e3" translate="yes" xml:space="preserve">
          <source>So, think about something which you are interested in, say, &quot;how can I access a blob just knowing the object name of it?&quot;. The first step is to find a Git command with which you can do it. In this example, it is either &lt;code&gt;git show&lt;/code&gt; or &lt;code&gt;git cat-file&lt;/code&gt;.</source>
          <target state="translated">따라서 관심있는 대상에 대해 생각해보십시오. &quot;개체 이름 만 알고있는 Blob에 어떻게 액세스 할 수 있습니까?&quot; 첫 번째 단계는 Git 명령을 찾는 것입니다. 이 예제에서는 &lt;code&gt;git show&lt;/code&gt; 또는 &lt;code&gt;git cat-file&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1efaef427fd5b515b3e304fc27457e91eec84a25" translate="yes" xml:space="preserve">
          <source>So, we can use somebody else&amp;rsquo;s work from a remote repository, but how can &lt;strong&gt;you&lt;/strong&gt; prepare a repository to let other people pull from it?</source>
          <target state="translated">따라서 원격 저장소에서 다른 사람의 작업을 사용할 수 있지만 다른 사람이 가져 오도록 저장소를 어떻게 준비 할 &lt;strong&gt;수&lt;/strong&gt; 있습니까?</target>
        </trans-unit>
        <trans-unit id="1d69dd0a510947edc4fb12eee97c080f4a377f68" translate="yes" xml:space="preserve">
          <source>Software bugs, or errors, are so prevalent and so detrimental that they cost the U.S. economy an estimated $59.5 billion annually, or about 0.6 percent of the gross domestic product, according to a newly released study commissioned by the Department of Commerce&amp;rsquo;s National Institute of Standards and Technology (NIST). At the national level, over half of the costs are borne by software users and the remainder by software developers/vendors. The study also found that, although all errors cannot be removed, more than a third of these costs, or an estimated $22.2 billion, could be eliminated by an improved testing infrastructure that enables earlier and more effective identification and removal of software defects. These are the savings associated with finding an increased percentage (but not 100 percent) of errors closer to the development stages in which they are introduced. Currently, over half of all errors are not found until &quot;downstream&quot; in the development process or during post-sale software use.</source>
          <target state="translated">미 상무부의 국립 표준 연구소 (National Institute of Standards)가 의뢰 한 새로 발표 된 연구에 따르면, 소프트웨어 버그 또는 오류는 매우 널리 퍼져 해마다 미국 경제에 연간 약 595 억 달러, 또는 국내 총생산의 약 0.6 %가 소요되는 것으로 추정됩니다. 그리고 기술 (NIST). 국가 차원에서 비용의 절반 이상이 소프트웨어 사용자가 부담하고 나머지는 소프트웨어 개발자 / 공급 업체가 부담합니다. 또한 모든 오류를 제거 할 수는 없지만 소프트웨어 결함을보다 빠르고 정확하게 식별 및 제거 할 수있는 향상된 테스트 인프라를 통해 이러한 비용의 3 분의 1 이상 또는 약 222 억 달러가 제거 될 수 있음을 발견했습니다.이는 도입 단계에 근접한 증가 된 비율 (100 % 아님)의 오류를 찾는 데 따른 비용 절감입니다. 현재 개발 과정에서 또는 다운 이후 판매 소프트웨어 사용 중에 &quot;다운 스트림&quot;이 될 때까지 모든 오류의 절반 이상이 발견되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f90a777e081dbed9d193d82399cc2e3159bf44a3" translate="yes" xml:space="preserve">
          <source>Software developers already spend approximately 80 percent of development costs on identifying and correcting defects, and yet few products of any type other than software are shipped with such high levels of errors.</source>
          <target state="translated">소프트웨어 개발자는 이미 결함을 식별하고 수정하는 데 개발 비용의 약 80 %를 소비하지만 소프트웨어 이외의 다른 유형의 제품에는 이러한 수준의 오류가있는 제품은 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="b27e803e858c897a720eecea15e5bd37677e07bf" translate="yes" xml:space="preserve">
          <source>Some Git commands take options that are only used for plumbing or that are deprecated, and such options are hidden from the default usage. This option gives the full list of options.</source>
          <target state="translated">일부 Git 명령은 배관에만 사용되거나 더 이상 사용되지 않는 옵션을 사용하며 이러한 옵션은 기본 사용법에서 숨겨집니다. 이 옵션은 전체 옵션 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="987ad55498ef51019e6595f32f9ee9a10fb74d21" translate="yes" xml:space="preserve">
          <source>Some actions require or allow to specify two revisions, and sometimes even two pathnames. In most general form such path_info (component) based gitweb URL looks like this:</source>
          <target state="translated">일부 작업에는 두 개의 수정본, 때로는 두 개의 경로 이름이 필요하거나 지정해야합니다. 가장 일반적인 형태로 이러한 path_info (구성 요소) 기반 gitweb URL은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e1994dd201b175192ea5080be05071ba824a420" translate="yes" xml:space="preserve">
          <source>Some atoms like %(align) and %(if) always require a matching %(end). We call them &quot;opening atoms&quot; and sometimes denote them as %($open).</source>
          <target state="translated">% (align) 및 % (if)와 같은 일부 원자는 항상 일치하는 % (end)를 필요로합니다. 우리는 이것을 &quot;개방 원자&quot;라고 부르며 때로는 % ($ open)로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b05a87bd0e5e1c61140759ab02c7e9f3bf4a2773" translate="yes" xml:space="preserve">
          <source>Some basic familiarity with Git is required. Having gone through &lt;a href=&quot;gittutorial&quot;&gt;gittutorial[7]&lt;/a&gt; and &lt;a href=&quot;gitglossary&quot;&gt;gitglossary[7]&lt;/a&gt; should be sufficient.</source>
          <target state="translated">Git에 대한 기본 지식이 필요합니다. 겪었 데 &lt;a href=&quot;gittutorial&quot;&gt;gittutorial [7]&lt;/a&gt; 및 &lt;a href=&quot;gitglossary&quot;&gt;gitglossary [7]&lt;/a&gt; 에 충분해야한다.</target>
        </trans-unit>
        <trans-unit id="61fa4c6dc6ae1d559b0a8be1b0de50848c850d66" translate="yes" xml:space="preserve">
          <source>Some changes are so trivial that it is not necessary to create a separate branch and then merge into each of the test and release branches. For these changes, just apply directly to the &lt;code&gt;release&lt;/code&gt; branch, and then merge that into the &lt;code&gt;test&lt;/code&gt; branch.</source>
          <target state="translated">일부 변경 사항은 너무나 사소하므로 별도의 분기를 만든 다음 각 테스트 및 릴리스 분기에 병합 할 필요가 없습니다. 이러한 변경 사항은 &lt;code&gt;release&lt;/code&gt; 브랜치에 직접 적용한 다음 &lt;code&gt;test&lt;/code&gt; 브랜치에 병합하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="59b18808ec08d9ea8408e805bbd7fa2f7edcfa73" translate="yes" xml:space="preserve">
          <source>Some commands (e.g. svn and http interfaces) that interactively ask for a password can be told to use an external program given via the value of this variable. Can be overridden by the &lt;code&gt;GIT_ASKPASS&lt;/code&gt; environment variable. If not set, fall back to the value of the &lt;code&gt;SSH_ASKPASS&lt;/code&gt; environment variable or, failing that, a simple password prompt. The external program shall be given a suitable prompt as command-line argument and write the password on its STDOUT.</source>
          <target state="translated">대화식으로 비밀번호를 요청하는 일부 명령 (예 : svn 및 http 인터페이스)은이 변수의 값을 통해 제공되는 외부 프로그램을 사용하도록 지시 할 수 있습니다. &lt;code&gt;GIT_ASKPASS&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 . 설정하지 않으면 &lt;code&gt;SSH_ASKPASS&lt;/code&gt; 환경 변수 의 값으로 돌아가 거나 실패한 경우 간단한 비밀번호 프롬프트로 돌아갑니다 . 외부 프로그램은 명령 행 인수로 적합한 프롬프트를 제공 받아 STDOUT에 암호를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="c2234711ff3c27c62e0fc4ab53a0833622d8f13d" translate="yes" xml:space="preserve">
          <source>Some configuration variables control the way the &lt;code&gt;--trailer&lt;/code&gt; arguments are applied to each commit message and the way any existing trailer in the commit message is changed. They also make it possible to automatically add some trailers.</source>
          <target state="translated">일부 구성 변수는 &lt;code&gt;--trailer&lt;/code&gt; 인수가 각 커밋 메시지에 적용되는 방식과 커밋 메시지의 기존 트레일러가 변경되는 방식을 제어합니다 . 또한 일부 예고편을 자동으로 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="938be1fd3d7f894aaa8fcd897f4e95cd6aacc1b6" translate="yes" xml:space="preserve">
          <source>Some configuration variables have their default values (embedded in the CGI script) set during building gitweb &amp;mdash; if that is the case, this fact is put in their description. See gitweb&amp;rsquo;s &lt;code&gt;INSTALL&lt;/code&gt; file for instructions on building and installing gitweb.</source>
          <target state="translated">일부 구성 변수에는 gitweb을 빌드하는 동안 기본값 (CGI 스크립트에 포함)이 설정되어 있습니다.이 경우 해당 사실이 설명에 포함됩니다. gitweb 빌드 및 설치에 대한 지침 은 gitweb의 &lt;code&gt;INSTALL&lt;/code&gt; 파일을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d66e22fd5f2bbbc188c5b064782bc9e186f6b28" translate="yes" xml:space="preserve">
          <source>Some email servers (e.g. smtp.163.com) limit the number emails to be sent per session (connection) and this will lead to a failure when sending many messages. With this option, send-email will disconnect after sending $&amp;lt;num&amp;gt; messages and wait for a few seconds (see --relogin-delay) and reconnect, to work around such a limit. You may want to use some form of credential helper to avoid having to retype your password every time this happens. Defaults to the &lt;code&gt;sendemail.smtpBatchSize&lt;/code&gt; configuration variable.</source>
          <target state="translated">일부 전자 메일 서버 (예 : smtp.163.com)는 세션 당 전송되는 전자 메일 수 (연결)를 제한하므로 많은 메시지를 보낼 때 오류가 발생합니다. 이 옵션을 사용하면 $ &amp;lt;num&amp;gt; 메시지를 보낸 후 send-email의 연결이 끊어지고 몇 초 동안 기다린 후 (--relogin-delay 참조) 다시 연결하여 이러한 한계를 극복합니다. 이런 상황이 발생할 때마다 비밀번호를 다시 입력하지 않아도되도록 일종의 자격 증명 도우미를 사용할 수 있습니다. &lt;code&gt;sendemail.smtpBatchSize&lt;/code&gt; 구성 변수가 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="92168eb294cb53195c326d7cdc472c76b820a62e" translate="yes" xml:space="preserve">
          <source>Some features cannot be overridden per project. For those features the structure of appropriate &lt;code&gt;%feature&lt;/code&gt; hash element has a simpler form:</source>
          <target state="translated">프로젝트별로 일부 기능을 재정의 할 수 없습니다. 이러한 기능의 경우 적절한 &lt;code&gt;%feature&lt;/code&gt; 해시 요소 의 구조 는 더 간단한 형식입니다.</target>
        </trans-unit>
        <trans-unit id="7345fdef7f54471f79d673ac02c80817717e5d21" translate="yes" xml:space="preserve">
          <source>Some filesystems lose the executable bit when a file that is marked as executable is checked out, or checks out a non-executable file with executable bit on. &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; probe the filesystem to see if it handles the executable bit correctly and this variable is automatically set as necessary.</source>
          <target state="translated">실행 파일로 표시된 파일을 체크 아웃하거나 실행 파일이 켜져있는 비 실행 파일을 체크 아웃하면 일부 파일 시스템에서 실행 비트가 손실됩니다. &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt; 은 파일 시스템을 검사하여 실행 파일이 올바르게 처리되는지 확인하고이 변수는 필요에 따라 자동으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1c65f795a263fd4e4ffc8fd7edc082e1bb01009b" translate="yes" xml:space="preserve">
          <source>Some filters will generate empty commits that leave the tree untouched. This option instructs git-filter-branch to remove such commits if they have exactly one or zero non-pruned parents; merge commits will therefore remain intact. This option cannot be used together with &lt;code&gt;--commit-filter&lt;/code&gt;, though the same effect can be achieved by using the provided &lt;code&gt;git_commit_non_empty_tree&lt;/code&gt; function in a commit filter.</source>
          <target state="translated">일부 필터는 빈 커밋을 생성하여 트리를 그대로 둡니다. 이 옵션은 자르지 않은 부모가 정확히 하나 또는 0 인 경우 커밋을 제거하도록 git-filter-branch에 지시합니다. 따라서 병합 커밋은 그대로 유지됩니다. 이 옵션은 &lt;code&gt;--commit-filter&lt;/code&gt; 와 함께 사용할 수 없지만 커밋 필터에서 제공된 &lt;code&gt;git_commit_non_empty_tree&lt;/code&gt; 함수를 사용하여 동일한 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="172ca906089028fc890c646e25bab698db638084" translate="yes" xml:space="preserve">
          <source>Some functions have a &lt;code&gt;_fl()&lt;/code&gt; suffix to indicate that they take &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line-number&lt;/code&gt; arguments.</source>
          <target state="translated">일부 함수에는 &lt;code&gt;_fl()&lt;/code&gt; 접미사가있어 &lt;code&gt;file&lt;/code&gt; 및 &lt;code&gt;line-number&lt;/code&gt; 인수 를 사용함 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="cf5b41401ecbf41c583b9f31bc11f9978bf853cb" translate="yes" xml:space="preserve">
          <source>Some functions have a &lt;code&gt;_printf_fl()&lt;/code&gt; suffix to indicate that they also take a varargs argument.</source>
          <target state="translated">일부 함수에는 &lt;code&gt;_printf_fl()&lt;/code&gt; 접미사가있어 varargs 인수도 사용함 을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c20fab9f2e759692fa04bbce7cef5cc908557231" translate="yes" xml:space="preserve">
          <source>Some functions have a &lt;code&gt;_va_fl()&lt;/code&gt; suffix to indicate that they also take a &lt;code&gt;va_list&lt;/code&gt; argument.</source>
          <target state="translated">일부 함수에는 &lt;code&gt;_va_fl()&lt;/code&gt; 접미사가있어 &lt;code&gt;va_list&lt;/code&gt; 인수 도 사용함 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="eba90c7cd2e8efb76a00a6ef6fd10ba0e6c2d355" translate="yes" xml:space="preserve">
          <source>Some improvements to the algorithms inside &quot;git bisect&quot; are possible and some new features could help in some cases, but overall &quot;git bisect&quot; works already very well, is used a lot, and is already very useful. To back up that last claim, let&amp;rsquo;s give the final word to Ingo Molnar when he was asked by the author how much time does he think &quot;git bisect&quot; saves him when he uses it:</source>
          <target state="translated">&quot;git bisect&quot;내부의 알고리즘에 대한 일부 개선이 가능하고 일부 새로운 기능은 일부 경우에 도움이 될 수 있지만 전반적인 &quot;git bisect&quot;는 이미 잘 작동하고 많이 사용되며 이미 매우 유용합니다. 마지막 주장을 뒷받침하기 위해, 저자가 &quot;git bisect&quot;를 사용했을 때 얼마나 많은 시간을 절약한다고 생각하는지에 대한 질문을받은 Ingo Molnar에게 마지막 단어를 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="051a4238025a126fd35cea3d27808e1a33c19d81" translate="yes" xml:space="preserve">
          <source>Some key/value pairs are common to all events and some are event-specific.</source>
          <target state="translated">일부 키 / 값 쌍은 모든 이벤트에 공통적이며 일부는 이벤트에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="171887e25dc7a6bd359791fb5478731797724aa1" translate="yes" xml:space="preserve">
          <source>Some malformed strings may be accepted as valid dates. In some of these cases Git will still be able to obtain the correct date from the malformed string. There are also some types of malformed strings which Git will parse wrong, and yet consider valid. Seriously malformed strings will be rejected.</source>
          <target state="translated">일부 잘못된 문자열은 유효한 날짜로 허용 될 수 있습니다. 이러한 경우 중 일부는 Git이 잘못된 문자열에서 정확한 날짜를 얻을 수 있습니다. Git이 잘못 구문 분석하지만 유효한 것으로 간주하는 잘못된 형식의 문자열 유형도 있습니다. 형식이 잘못된 문자열은 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="783d5fee630f867a836aab31a09a1120dfa61932" translate="yes" xml:space="preserve">
          <source>Some more interesting work has been done in the upstream project, and &lt;code&gt;origin&lt;/code&gt; has advanced:</source>
          <target state="translated">업스트림 프로젝트에서 좀 더 흥미로운 작업이 이루어졌으며 &lt;code&gt;origin&lt;/code&gt; 가 발전했습니다.</target>
        </trans-unit>
        <trans-unit id="f3d95fe16308405a40d9c1590f99de534764e169" translate="yes" xml:space="preserve">
          <source>Some old repositories have tags without a tagger. The fast-import protocol was pretty strict about that, and did not allow that. So fake a tagger to be able to fast-import the output.</source>
          <target state="translated">일부 오래된 리포지토리에는 태그가없는 태그가 있습니다. 빠른 가져 오기 프로토콜은 그것에 대해 매우 엄격했으며 허용하지 않았습니다. 따라서 태그를 가짜로 만들어서 출력을 빠르게 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f1322ce775635ebc0b366d585bc7dbdc07c75d2" translate="yes" xml:space="preserve">
          <source>Some optional features and policies</source>
          <target state="translated">일부 선택적 기능 및 정책</target>
        </trans-unit>
        <trans-unit id="184f39eeceeacf637176614462d419ff5408c775" translate="yes" xml:space="preserve">
          <source>Some other SCM systems let the user create a tag from multiple files which are not from the same commit/changeset. Or to create tags which are a subset of the files available in the repository.</source>
          <target state="translated">일부 다른 SCM 시스템에서는 사용자가 동일한 커밋 / 변경 세트가 아닌 여러 파일에서 태그를 만들 수 있습니다. 또는 저장소에서 사용 가능한 파일의 서브 세트 인 태그를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="e0986df979670ad50493b8dd4aeecf085f900c18" translate="yes" xml:space="preserve">
          <source>Some other commands that also work on files in the working tree and/or in the index can take &lt;code&gt;--staged&lt;/code&gt; and/or &lt;code&gt;--worktree&lt;/code&gt;.</source>
          <target state="translated">작업 트리 및 / 또는 인덱스의 파일에서 작동하는 다른 명령은 &lt;code&gt;--staged&lt;/code&gt; 및 / 또는 &lt;code&gt;--worktree&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e825ac68d84922615f20a915d3c1eb9e9c71680" translate="yes" xml:space="preserve">
          <source>Some placeholders may depend on other options given to the revision traversal engine. For example, the &lt;code&gt;%g*&lt;/code&gt; reflog options will insert an empty string unless we are traversing reflog entries (e.g., by &lt;code&gt;git log -g&lt;/code&gt;). The &lt;code&gt;%d&lt;/code&gt; and &lt;code&gt;%D&lt;/code&gt; placeholders will use the &quot;short&quot; decoration format if &lt;code&gt;--decorate&lt;/code&gt; was not already provided on the command line.</source>
          <target state="translated">일부 자리 표시자는 수정 순회 엔진에 지정된 다른 옵션에 따라 달라질 수 있습니다. 예를 들어, &lt;code&gt;%g*&lt;/code&gt; reflog 옵션은 reflog 항목을 통과하지 않는 한 빈 문자열을 삽입합니다 (예 : &lt;code&gt;git log -g&lt;/code&gt; ). &lt;code&gt;%d&lt;/code&gt; 와 &lt;code&gt;%D&lt;/code&gt; 자리 경우 &quot;짧은&quot;장식 형식을 사용합니다 &lt;code&gt;--decorate&lt;/code&gt; 가 이미 명령 행에 제공되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b90f1a06edbdea1cb1ea924bb534bf207be4c8cd" translate="yes" xml:space="preserve">
          <source>Some special diff options allow diffing the working directory against any of these stages:</source>
          <target state="translated">일부 특수 diff 옵션을 사용하면 작업 디렉토리를 다음 단계와 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="379a99bc56f81a74676a3582df5345ad077361ae" translate="yes" xml:space="preserve">
          <source>Some workflows require that one or more branches of development on one machine be replicated on another machine, but the two machines cannot be directly connected, and therefore the interactive Git protocols (git, ssh, http) cannot be used.</source>
          <target state="translated">일부 워크 플로우에서는 한 머신의 하나 이상의 개발 브랜치를 다른 머신에서 복제해야하지만 두 머신을 직접 연결할 수 없으므로 대화식 Git 프로토콜 (git, ssh, http)을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4efa70b7553b32aea10bdaaf89e5cdb60eb1465e" translate="yes" xml:space="preserve">
          <source>Somebody asks you to pull, and the changes sound worthy of merging.</source>
          <target state="translated">누군가가 당신에게 물을 것을 요구하고, 그 변화는 합병 할 가치가있는 것으로 들립니다.</target>
        </trans-unit>
        <trans-unit id="75bb6efa7b5bca1608dd13b1f00b4537d22f7537" translate="yes" xml:space="preserve">
          <source>Somebody hands you a copy of a file, and asks which commits modified a file such that it contained the given content either before or after the commit. You can find out with this:</source>
          <target state="translated">누군가 당신에게 파일의 사본을 건네고, 커밋 전후에 주어진 내용을 포함하도록 파일을 수정 한 커밋을 요청합니다. 당신은 이것으로 알 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7ef51555538cdc5f80247933eec8146e7de62402" translate="yes" xml:space="preserve">
          <source>Someone can do a history rewrite, realize they messed up, restore from the backups in refs/original/, and then redo their git-filter-branch command. (The backup in refs/original/ is not a real backup; it dereferences tags first.)</source>
          <target state="translated">누군가는 기록을 다시 작성하고 엉망이 된 것을 알고 refs / original /의 백업에서 복원 한 다음 git-filter-branch 명령을 다시 실행할 수 있습니다. (refs / original /의 백업은 실제 백업이 아니므로 태그를 먼저 참조하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="8b7568eaac49251d7ecfa53edc4f2d50e2427376" translate="yes" xml:space="preserve">
          <source>Someone can have a set of &quot;working and tested filters&quot; which they document or provide to a coworker, who then runs them on a different OS where the same commands are not working/tested (some examples in the git-filter-branch manpage are also affected by this). BSD vs. GNU userland differences can really bite. If lucky, error messages are spewed. But just as likely, the commands either don&amp;rsquo;t do the filtering requested, or silently corrupt by making some unwanted change. The unwanted change may only affect a few commits, so it&amp;rsquo;s not necessarily obvious either. (The fact that problems won&amp;rsquo;t necessarily be obvious means they are likely to go unnoticed until the rewritten history is in use for quite a while, at which point it&amp;rsquo;s really hard to justify another flag-day for another rewrite.)</source>
          <target state="translated">누군가는 문서화하거나 동료에게 제공하는 &quot;작동 및 테스트 된 필터&quot;세트를 가질 수 있으며, 그런 다음 동일한 명령이 작동 / 테스트되지 않은 다른 OS에서 실행됩니다 (git-filter-branch 맨 페이지의 일부 예는 또한 이것에 의해 영향을받습니다). BSD와 GNU 사용자 영역의 차이점은 실제로 물릴 수 있습니다. 운이 좋으면 오류 메시지가 표시됩니다. 그러나 명령은 요청 된 필터링을 수행하지 않거나 원치 않는 변경을 수행하여 자동으로 손상됩니다. 원하지 않는 변경은 몇 가지 커밋에만 영향을 줄 수 있으므로 반드시 명확한 것은 아닙니다. (문제가 분명하지 않다는 사실은 재기록 된 역사가 꽤 오랫동안 사용되기 전까지는 눈에 띄지 않을 가능성이 있다는 것을 의미합니다.이 시점에서 또 다른 재기록을 위해 또 다른 국기의 날을 정당화하기는 정말로 어렵습니다.)</target>
        </trans-unit>
        <trans-unit id="f6f28be0bc03c39873befbc10c61feb3cd6f09d9" translate="yes" xml:space="preserve">
          <source>Sometime later when enough time has passed and testing done, you can pull the same branch into the &lt;code&gt;release&lt;/code&gt; tree ready to go upstream. This is where you see the value of keeping each patch (or patch series) in its own branch. It means that the patches can be moved into the &lt;code&gt;release&lt;/code&gt; tree in any order.</source>
          <target state="translated">나중에 충분한 시간이 지났고 테스트가 완료되면 동일한 분기를 &lt;code&gt;release&lt;/code&gt; 트리 로 가져와 업스트림으로 이동할 수 있습니다. 여기에서 각 패치 (또는 패치 시리즈)를 자체 분기에 유지하는 가치를 볼 수 있습니다. 즉, 패치 를 임의의 순서로 &lt;code&gt;release&lt;/code&gt; 트리 로 옮길 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3de282e58de418da244c9ed4c8dec9bb8a8937a" translate="yes" xml:space="preserve">
          <source>Sometimes it happens that the current state cannot be tested, for example if it does not compile because there was a bug preventing it at that time. This is what the special exit code 125 is for. It tells &quot;git bisect run&quot; that the current commit should be marked as untestable and that another one should be chosen and checked out.</source>
          <target state="translated">때로는 현재 상태를 테스트 할 수없는 경우가 있습니다. 예를 들어, 당시 버그를 방지하여 컴파일하지 않은 경우입니다. 이것이 특수 종료 코드 125의 목적입니다. &quot;git bisect run&quot;에 현재 커밋을 테스트 할 수없는 것으로 표시하고 다른 커밋을 선택하여 체크 아웃해야한다고 지시합니다.</target>
        </trans-unit>
        <trans-unit id="ab0983c0f5d9e7bd28c3834685713747f93c2919" translate="yes" xml:space="preserve">
          <source>Sometimes it is desirable to see the diff of a text-converted version of some binary files. For example, a word processor document can be converted to an ASCII text representation, and the diff of the text shown. Even though this conversion loses some information, the resulting diff is useful for human viewing (but cannot be applied directly).</source>
          <target state="translated">때때로 일부 바이너리 파일의 텍스트 변환 버전의 차이점을 보는 것이 바람직합니다. 예를 들어, 워드 프로세서 문서는 ASCII 텍스트 표현과 텍스트의 diff로 변환 될 수 있습니다. 이 변환에서 일부 정보가 손실 되더라도 diff는 사람이 보는 데 유용하지만 직접 적용 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="a66c6ccc61eb22dbd8fb180270521a352bb26eb7" translate="yes" xml:space="preserve">
          <source>Sometimes the thing fixed in b.2. cannot be amended to the not-quite perfect commit it fixes, because that commit is buried deeply in a patch series. That is exactly what interactive rebase is for: use it after plenty of &quot;a&quot;s and &quot;b&quot;s, by rearranging and editing commits, and squashing multiple commits into one.</source>
          <target state="translated">때때로 b.2에서 수정 된 것. 커밋은 패치 시리즈에 깊이 묻혀 있기 때문에 수정되지 않은 완벽한 커밋으로 수정할 수 없습니다. 이것이 바로 대화식 리베이스의 목적입니다. 커밋을 재 배열하고 편집하고 여러 커밋을 하나로 스 쿼싱하여 많은 &quot;a&quot;와 &quot;b&quot;후에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7d8c42c4820860471a909b97a129a9232304c94a" translate="yes" xml:space="preserve">
          <source>Sometimes what you want instead is a set of patches; for this you can use &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;:</source>
          <target state="translated">때때로 당신이 원하는 것은 대신 패치 세트입니다; 이를 위해 &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]을&lt;/a&gt; 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="abb396ee2420ccad29c3b6a0f48213b60cfe8e4f" translate="yes" xml:space="preserve">
          <source>Sometimes you are not looking for the commit that introduced a breakage, but rather for a commit that caused a change between some other &quot;old&quot; state and &quot;new&quot; state. For example, you might be looking for the commit that introduced a particular fix. Or you might be looking for the first commit in which the source-code filenames were finally all converted to your company&amp;rsquo;s naming standard. Or whatever.</source>
          <target state="translated">때로는 중단을 유발 한 커밋을 찾지 않고 다른 &quot;이전&quot;상태와 &quot;새로운&quot;상태 사이에서 변경을 일으키는 커밋을 찾고 있습니다. 예를 들어, 특정 수정 사항을 도입 한 커미트를 찾고있을 수 있습니다. 또는 소스 코드 파일 이름이 회사의 명명 표준으로 모두 변환 된 첫 번째 커밋을 찾고있을 것입니다. 또는 무엇이든.</target>
        </trans-unit>
        <trans-unit id="709d16fb784b306222cc9b75f2da6965fd037ce9" translate="yes" xml:space="preserve">
          <source>Sometimes you are only interested in parts of the history, for example the commits modifying a particular &amp;lt;path&amp;gt;. But there are two parts of &lt;code&gt;History Simplification&lt;/code&gt;, one part is selecting the commits and the other is how to do it, as there are various strategies to simplify the history.</source>
          <target state="translated">때로는 특정 &amp;lt;path&amp;gt;를 수정하는 커밋과 같이 기록의 일부에만 관심이 있습니다. 그러나 &lt;code&gt;History Simplification&lt;/code&gt; 에는 두 가지 부분이 있습니다 . 한 부분은 커밋을 선택하는 것이고 다른 하나는 기록을 단순화하는 다양한 전략이 있기 때문에이를 수행하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="3329bd14db714a1ebe54846da15c65686d4c297b" translate="yes" xml:space="preserve">
          <source>Sometimes you may wish to create a new branch &lt;code&gt;without&lt;/code&gt; actually checking it out and switching to it. If so, just use the command</source>
          <target state="translated">때로는 실제로 체크 아웃하고 전환 &lt;code&gt;without&lt;/code&gt; 새 브랜치를 생성하려고 할 수 있습니다 . 그렇다면 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9e0d77cc540587abb285618787352fd870a1def8" translate="yes" xml:space="preserve">
          <source>Sometimes you want to edit a commit deeper in your history. One approach is to use &lt;code&gt;git format-patch&lt;/code&gt; to create a series of patches and then reset the state to before the patches:</source>
          <target state="translated">때때로 당신은 당신의 역사에서 커밋을 더 깊이 편집하려고합니다. 한 가지 방법은 &lt;code&gt;git format-patch&lt;/code&gt; 를 사용하여 일련의 패치를 작성한 다음 상태를 패치 이전으로 재설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="17cc71829facf5cb6a6b321a2cbf6c64d2bc06da" translate="yes" xml:space="preserve">
          <source>Sometimes you would need to override a setting of an attribute for a path to &lt;code&gt;Unspecified&lt;/code&gt; state. This can be done by listing the name of the attribute prefixed with an exclamation point &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">때때로 경로에 대한 속성 설정을 &lt;code&gt;Unspecified&lt;/code&gt; 상태 로 대체해야 할 수도 있습니다 . 느낌표가 접두사로 붙은 속성 이름을 나열하면됩니다 &lt;code&gt;!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18f66cee3089e3b2788a7d42c7fbfe71e8e6eab6" translate="yes" xml:space="preserve">
          <source>Sometimes, more than one builtin is contained in one source file. For example, &lt;code&gt;cmd_whatchanged()&lt;/code&gt; and &lt;code&gt;cmd_log()&lt;/code&gt; both reside in &lt;code&gt;builtin/log.c&lt;/code&gt;, since they share quite a bit of code. In that case, the commands which are &lt;code&gt;not&lt;/code&gt; named like the &lt;code&gt;.c&lt;/code&gt; file in which they live have to be listed in &lt;code&gt;BUILT_INS&lt;/code&gt; in the &lt;code&gt;Makefile&lt;/code&gt;.</source>
          <target state="translated">때때로 하나 이상의 소스 파일이 하나의 소스 파일에 포함되어 있습니다. 예를 들어, &lt;code&gt;cmd_whatchanged()&lt;/code&gt; 및 &lt;code&gt;cmd_log()&lt;/code&gt; 모두 약간의 코드를 공유하므로 &lt;code&gt;builtin/log.c&lt;/code&gt; 에 있습니다. 이 경우, &lt;code&gt;.c&lt;/code&gt; 파일 과 같이 이름 이 지정 &lt;code&gt;not&lt;/code&gt; 명령 은 &lt;code&gt;Makefile&lt;/code&gt; 의 &lt;code&gt;BUILT_INS&lt;/code&gt; 에 나열되어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="59356e5b6f2fcc25a08169f8960c8b579beeb31f" translate="yes" xml:space="preserve">
          <source>Sometimes, you do not know where to look for a feature. In many such cases, it helps to search through the output of &lt;code&gt;git log&lt;/code&gt;, and then &lt;code&gt;git show&lt;/code&gt; the corresponding commit.</source>
          <target state="translated">경우에 따라 기능을 찾을 위치를 모릅니다. 많은 경우, &lt;code&gt;git log&lt;/code&gt; 의 출력을 검색 한 다음 &lt;code&gt;git show&lt;/code&gt; 가 해당 커밋을 표시 하는 데 도움이됩니다 .</target>
        </trans-unit>
        <trans-unit id="94a8d6cf12f26243dde0f5140dd4760ee8881bb4" translate="yes" xml:space="preserve">
          <source>Sort based on the key given. Prefix &lt;code&gt;-&lt;/code&gt; to sort in descending order of the value. Supports &quot;version:refname&quot; or &quot;v:refname&quot; (tag names are treated as versions). The &quot;version:refname&quot; sort order can also be affected by the &quot;versionsort.suffix&quot; configuration variable. See &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt; for more sort options, but be aware keys like &lt;code&gt;committerdate&lt;/code&gt; that require access to the objects themselves will not work for refs whose objects have not yet been fetched from the remote, and will give a &lt;code&gt;missing object&lt;/code&gt; error.</source>
          <target state="translated">주어진 키를 기준으로 정렬하십시오. 접두사 &lt;code&gt;-&lt;/code&gt; 값의 내림차순으로 정렬합니다. &quot;version : refname&quot;또는 &quot;v : refname&quot;을 지원합니다 (태그 이름은 버전으로 취급 됨). &quot;version : refname&quot;정렬 순서는 &quot;versionsort.suffix&quot;구성 변수의 영향을받을 수도 있습니다. 정렬 옵션에 대한 자세한 내용은 &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt; 을 참조하십시오. 그러나 객체 자체에 액세스해야하는 &lt;code&gt;committerdate&lt;/code&gt; 와 같은 키 는 객체를 아직 원격에서 가져 오지 않은 참조에 대해서는 작동하지 않으며 &lt;code&gt;missing object&lt;/code&gt; 오류.</target>
        </trans-unit>
        <trans-unit id="4f8164295fbfdf007f932844e4ac7576dc2d1ee2" translate="yes" xml:space="preserve">
          <source>Sort based on the key given. Prefix &lt;code&gt;-&lt;/code&gt; to sort in descending order of the value. You may use the --sort=&amp;lt;key&amp;gt; option multiple times, in which case the last key becomes the primary key. Also supports &quot;version:refname&quot; or &quot;v:refname&quot; (tag names are treated as versions). The &quot;version:refname&quot; sort order can also be affected by the &quot;versionsort.suffix&quot; configuration variable. The keys supported are the same as those in &lt;code&gt;git for-each-ref&lt;/code&gt;. Sort order defaults to the value configured for the &lt;code&gt;tag.sort&lt;/code&gt; variable if it exists, or lexicographic order otherwise. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">주어진 키를 기준으로 정렬하십시오. 접두사 &lt;code&gt;-&lt;/code&gt; 값의 내림차순으로 정렬합니다. --sort = &amp;lt;key&amp;gt; 옵션을 여러 번 사용할 수 있으며,이 경우 마지막 키가 기본 키가됩니다. &quot;version : refname&quot;또는 &quot;v : refname&quot;도 지원합니다 (태그 이름은 버전으로 취급 됨). &quot;version : refname&quot;정렬 순서는 &quot;versionsort.suffix&quot;구성 변수의 영향을받을 수도 있습니다. 지원되는 키는 &lt;code&gt;git for-each-ref&lt;/code&gt; 의 키와 동일 합니다. 정렬 순서의 기본값은 &lt;code&gt;tag.sort&lt;/code&gt; 변수에 대해 구성된 값 (있는 경우), 그렇지 않으면 사전 순서입니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="235c15477db9421be496a9bdb61ee9fe5440e8e8" translate="yes" xml:space="preserve">
          <source>Sort based on the key given. Prefix &lt;code&gt;-&lt;/code&gt; to sort in descending order of the value. You may use the --sort=&amp;lt;key&amp;gt; option multiple times, in which case the last key becomes the primary key. The keys supported are the same as those in &lt;code&gt;git
for-each-ref&lt;/code&gt;. Sort order defaults to the value configured for the &lt;code&gt;branch.sort&lt;/code&gt; variable if exists, or to sorting based on the full refname (including &lt;code&gt;refs/...&lt;/code&gt; prefix). This lists detached HEAD (if present) first, then local branches and finally remote-tracking branches. See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">주어진 키를 기준으로 정렬하십시오. 접두사 &lt;code&gt;-&lt;/code&gt; 값의 내림차순으로 정렬합니다. --sort = &amp;lt;key&amp;gt; 옵션을 여러 번 사용할 수 있으며,이 경우 마지막 키가 기본 키가됩니다. 지원되는 키는 &lt;code&gt;git for-each-ref&lt;/code&gt; 의 키와 동일 합니다. 정렬 순서의 기본값은 &lt;code&gt;branch.sort&lt;/code&gt; 변수에 대해 구성된 값 (있는 경우) 또는 전체 refname ( &lt;code&gt;refs/...&lt;/code&gt; 접두사 포함)을 기준으로 정렬 됩니다. 분리 된 HEAD (있는 경우)를 먼저 표시 한 다음 로컬 브랜치 및 원격 추적 브랜치를 나열합니다. &lt;a href=&quot;git-config&quot;&gt;git-config [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f1523e64bd22fd24a21f855bbd22c50e1efc550" translate="yes" xml:space="preserve">
          <source>Sort commits by date when possible.</source>
          <target state="translated">가능하면 날짜별로 커밋을 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="2c6b9826784b28663433b0a6dc2f2674e6b29a9a" translate="yes" xml:space="preserve">
          <source>Sort output according to the number of commits per author instead of author alphabetic order.</source>
          <target state="translated">작성자 알파벳 순서 대신 작성자 당 커밋 수에 따라 출력을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="97d057704ff7369f19e3dfc333c10a22925317f1" translate="yes" xml:space="preserve">
          <source>Sorting and filtering branches are case insensitive.</source>
          <target state="translated">분기 정렬 및 필터링은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ce7d777697e6536cabaa9eaf03abf69552dd696" translate="yes" xml:space="preserve">
          <source>Sorting and filtering refs are case insensitive.</source>
          <target state="translated">참조 정렬 및 필터링은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d38ff15fbd7490d8843677184f9c7afbcdf73ce" translate="yes" xml:space="preserve">
          <source>Sorting and filtering tags are case insensitive.</source>
          <target state="translated">태그 정렬 및 필터링은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74d012567bc749743b2f7f680471d74e8b0444d4" translate="yes" xml:space="preserve">
          <source>Source code management (tool).</source>
          <target state="translated">소스 코드 관리 (도구).</target>
        </trans-unit>
        <trans-unit id="36b1651cdc36dfe13b6c0271ea5052804f0ae0c9" translate="yes" xml:space="preserve">
          <source>Sparse checkout</source>
          <target state="translated">스파 스 체크 아웃</target>
        </trans-unit>
        <trans-unit id="7aaf15f27eda1de7eaf7b123729519d3afe58336" translate="yes" xml:space="preserve">
          <source>Specifically, the following are removed until none of them remain:</source>
          <target state="translated">특히 다음 중 하나도 남아 있지 않을 때까지 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="6fb30b05a9f660538f592f3613160c9d3d393240" translate="yes" xml:space="preserve">
          <source>Specified branch is an ancestor of the remote HEAD</source>
          <target state="translated">지정된 브랜치는 원격 HEAD의 조상입니다.</target>
        </trans-unit>
        <trans-unit id="095f9fffc528a2b593b5d023d80910beab9fba54" translate="yes" xml:space="preserve">
          <source>Specified branch resolves to an object that exists locally</source>
          <target state="translated">지정된 분기가 로컬로 존재하는 개체로 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="aa507335de58b83c95563636f96d43ebd2769930" translate="yes" xml:space="preserve">
          <source>Specifies a minimum trust level for signature verification. If this option is unset, then signature verification for merge operations require a key with at least &lt;code&gt;marginal&lt;/code&gt; trust. Other operations that perform signature verification require a key with at least &lt;code&gt;undefined&lt;/code&gt; trust. Setting this option overrides the required trust-level for all operations. Supported values, in increasing order of significance:</source>
          <target state="translated">Specifies a minimum trust level for signature verification. If this option is unset, then signature verification for merge operations require a key with at least &lt;code&gt;marginal&lt;/code&gt; trust. Other operations that perform signature verification require a key with at least &lt;code&gt;undefined&lt;/code&gt; trust. Setting this option overrides the required trust-level for all operations. Supported values, in increasing order of significance:</target>
        </trans-unit>
        <trans-unit id="8bd7d2d739debb36a1057aa4a730675102718bfe" translate="yes" xml:space="preserve">
          <source>Specifies a port different from the default port (SMTP servers typically listen to smtp port 25, but may also listen to submission port 587, or the common SSL smtp port 465); symbolic port names (e.g. &quot;submission&quot; instead of 587) are also accepted. The port can also be set with the &lt;code&gt;sendemail.smtpServerPort&lt;/code&gt; configuration variable.</source>
          <target state="translated">기본 포트와 다른 포트를 지정합니다 (SMTP 서버는 일반적으로 smtp 포트 25를 수신하지만 제출 포트 587 또는 공통 SSL smtp 포트 465를 수신 할 수도 있음). 기호 포트 이름 (예 : 587 대신 &quot;제출&quot;)도 허용됩니다. &lt;code&gt;sendemail.smtpServerPort&lt;/code&gt; 구성 변수를 사용하여 포트를 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07c63275a8584ac825542ccb56fd0f5b3bf25b5a" translate="yes" xml:space="preserve">
          <source>Specifies compression level for newly-compressed data in the generated pack. If not specified, pack compression level is determined first by pack.compression, then by core.compression, and defaults to -1, the zlib default, if neither is set. Add --no-reuse-object if you want to force a uniform compression level on all data no matter the source.</source>
          <target state="translated">생성 된 팩에서 새로 압축 된 데이터의 압축 레벨을 지정합니다. 지정하지 않으면 pack 압축 수준은 먼저 pack.compression에 의해 결정된 다음 core.compression에 의해 결정되며 기본값이 -1로 설정되어 있지 않으면 zlib 기본값입니다. 소스에 관계없이 모든 데이터에 균일 한 압축 수준을 적용하려면 --no-reuse-object를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="2e586cba19f8fbc5a10baac47fbd5c9e37781d67" translate="yes" xml:space="preserve">
          <source>Specifies how a merge is handled when the merged-in history is already a descendant of the current history. &lt;code&gt;--ff&lt;/code&gt; is the default unless merging an annotated (and possibly signed) tag that is not stored in its natural place in the &lt;code&gt;refs/tags/&lt;/code&gt; hierarchy, in which case &lt;code&gt;--no-ff&lt;/code&gt; is assumed.</source>
          <target state="translated">병합 된 기록이 이미 현재 기록의 후손 인 경우 병합이 처리되는 방법을 지정합니다. &lt;code&gt;--ff&lt;/code&gt; &lt;code&gt;refs/tags/&lt;/code&gt; 계층 구조 의 자연 위치에 저장되지 않은 주석이 달린 (및 부호있는) 태그를 병합하지 않는 한 --ff 는 기본값 이며,이 경우 &lt;code&gt;--no-ff&lt;/code&gt; 로 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="1e4cfa4b695628b655fba3d437b2ed50df8c7399" translate="yes" xml:space="preserve">
          <source>Specifies how many context lines should be used in calls to diff made by the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;. The default is &quot;5&quot;.</source>
          <target state="translated">&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]에&lt;/a&gt; 의한 diff 호출에 사용되어야하는 컨텍스트 라인 수를 지정합니다 . 기본값은 &quot;5&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="ee05d66bfede680eae8d8ce792188074b5498ff4" translate="yes" xml:space="preserve">
          <source>Specifies how many submodules are fetched/cloned at the same time. A positive integer allows up to that number of submodules fetched in parallel. A value of 0 will give some reasonable default. If unset, it defaults to 1.</source>
          <target state="translated">동시에 페치 / 복제되는 서브 모듈 수를 지정합니다. 양의 정수는 병렬로 페치 된 최대 수의 서브 모듈을 허용합니다. 값이 0이면 합리적인 기본값이 제공됩니다. 설정하지 않으면 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="316fa49ea084b12859b1b97d79b0376bed50442d" translate="yes" xml:space="preserve">
          <source>Specifies how the submodules obtain alternates when submodules are cloned. Possible values are &lt;code&gt;no&lt;/code&gt;, &lt;code&gt;superproject&lt;/code&gt;. By default &lt;code&gt;no&lt;/code&gt; is assumed, which doesn&amp;rsquo;t add references. When the value is set to &lt;code&gt;superproject&lt;/code&gt; the submodule to be cloned computes its alternates location relative to the superprojects alternate.</source>
          <target state="translated">서브 모듈이 복제 될 때 서브 모듈이 대체를 얻는 방법을 지정합니다. 가능한 값은 &lt;code&gt;no&lt;/code&gt; , &lt;code&gt;superproject&lt;/code&gt; 입니다. 기본적으로 &lt;code&gt;no&lt;/code&gt; 는 가정되며 참조를 추가하지 않습니다. 값이 &lt;code&gt;superproject&lt;/code&gt; 로 설정되면, 복제 될 서브 모듈은 수퍼 프로젝트 대체물에 대한 대체 위치를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b31fc36154a26e26a1c078ebba51ee8a4995b30b" translate="yes" xml:space="preserve">
          <source>Specifies how to treat errors with the alternates for a submodule as computed via &lt;code&gt;submodule.alternateLocation&lt;/code&gt;. Possible values are &lt;code&gt;ignore&lt;/code&gt;, &lt;code&gt;info&lt;/code&gt;, &lt;code&gt;die&lt;/code&gt;. Default is &lt;code&gt;die&lt;/code&gt;. Note that if set to &lt;code&gt;ignore&lt;/code&gt; or &lt;code&gt;info&lt;/code&gt;, and if there is an error with the computed alternate, the clone proceeds as if no alternate was specified.</source>
          <target state="translated">을 통해 산출 된 지정 방법 서브 모듈의 대체와 오류를 치료하는 &lt;code&gt;submodule.alternateLocation&lt;/code&gt; . 가능한 값은 &lt;code&gt;ignore&lt;/code&gt; , &lt;code&gt;info&lt;/code&gt; , &lt;code&gt;die&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;die&lt;/code&gt; 입니다. &lt;code&gt;ignore&lt;/code&gt; 또는 &lt;code&gt;info&lt;/code&gt; 로 설정 하고 계산 된 대체에 오류가있는 경우 대체가 지정되지 않은 것처럼 복제가 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="d91861558c562fdeaaf804d5a6651390fea90d33" translate="yes" xml:space="preserve">
          <source>Specifies if commands recurse into submodules by default. This applies to all commands that have a &lt;code&gt;--recurse-submodules&lt;/code&gt; option (&lt;code&gt;checkout&lt;/code&gt;, &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;pull&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;read-tree&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt;, &lt;code&gt;restore&lt;/code&gt; and &lt;code&gt;switch&lt;/code&gt;) except &lt;code&gt;clone&lt;/code&gt; and &lt;code&gt;ls-files&lt;/code&gt;. Defaults to false. When set to true, it can be deactivated via the &lt;code&gt;--no-recurse-submodules&lt;/code&gt; option. Note that some Git commands lacking this option may call some of the above commands affected by &lt;code&gt;submodule.recurse&lt;/code&gt;; for instance &lt;code&gt;git remote update&lt;/code&gt; will call &lt;code&gt;git fetch&lt;/code&gt; but does not have a &lt;code&gt;--no-recurse-submodules&lt;/code&gt; option. For these commands a workaround is to temporarily change the configuration value by using &lt;code&gt;git -c submodule.recurse=0&lt;/code&gt;.</source>
          <target state="translated">Specifies if commands recurse into submodules by default. This applies to all commands that have a &lt;code&gt;--recurse-submodules&lt;/code&gt; option ( &lt;code&gt;checkout&lt;/code&gt; , &lt;code&gt;fetch&lt;/code&gt; , &lt;code&gt;grep&lt;/code&gt; , &lt;code&gt;pull&lt;/code&gt; , &lt;code&gt;push&lt;/code&gt; , &lt;code&gt;read-tree&lt;/code&gt; , &lt;code&gt;reset&lt;/code&gt; , &lt;code&gt;restore&lt;/code&gt; and &lt;code&gt;switch&lt;/code&gt; ) except &lt;code&gt;clone&lt;/code&gt; and &lt;code&gt;ls-files&lt;/code&gt; . Defaults to false. When set to true, it can be deactivated via the &lt;code&gt;--no-recurse-submodules&lt;/code&gt; option. Note that some Git commands lacking this option may call some of the above commands affected by &lt;code&gt;submodule.recurse&lt;/code&gt; ; for instance &lt;code&gt;git remote update&lt;/code&gt; will call &lt;code&gt;git fetch&lt;/code&gt; but does not have a &lt;code&gt;--no-recurse-submodules&lt;/code&gt; option. For these commands a workaround is to temporarily change the configuration value by using &lt;code&gt;git -c submodule.recurse=0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be724c0999a6ad4178618a1619dc5ee566f604f6" translate="yes" xml:space="preserve">
          <source>Specifies if commands recurse into submodules by default. This applies to all commands that have a &lt;code&gt;--recurse-submodules&lt;/code&gt; option, except &lt;code&gt;clone&lt;/code&gt;. Defaults to false.</source>
          <target state="translated">기본적으로 명령이 하위 모듈로 되풀이되는지 여부를 지정합니다. 이는 &lt;code&gt;clone&lt;/code&gt; 을 제외한 &lt;code&gt;--recurse-submodules&lt;/code&gt; 옵션 이있는 모든 명령에 적용됩니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="521e20e338253b67c65fe5992b9e53ef105e078a" translate="yes" xml:space="preserve">
          <source>Specifies intentionally untracked files to ignore</source>
          <target state="translated">Specifies intentionally untracked files to ignore</target>
        </trans-unit>
        <trans-unit id="4a0da697fa597c14275c00dd14541ab0c3dfd994" translate="yes" xml:space="preserve">
          <source>Specifies the Fully Qualified Domain Name (FQDN) used in the HELO/EHLO command to the SMTP server. Some servers require the FQDN to match your IP address. If not set, git send-email attempts to determine your FQDN automatically. Default is the value of &lt;code&gt;sendemail.smtpDomain&lt;/code&gt;.</source>
          <target state="translated">HELO / EHLO 명령에 사용 된 FQDN (정규화 된 도메인 이름)을 SMTP 서버에 지정합니다. 일부 서버는 FQDN이 IP 주소와 일치해야합니다. 설정하지 않으면 git send-email은 FQDN을 자동으로 확인하려고 시도합니다. 기본값은 &lt;code&gt;sendemail.smtpDomain&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="5037aaf03dca1f2f538183f1496bfc2b7e1efabf" translate="yes" xml:space="preserve">
          <source>Specifies the default encoding to use for displaying of file contents in &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt; and &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt;. It can be overridden by setting the &lt;code&gt;encoding&lt;/code&gt; attribute for relevant files (see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;). If this option is not set, the tools default to the locale encoding.</source>
          <target state="translated">&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt; 및 &lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt; 에 파일 내용을 표시하는 데 사용할 기본 인코딩을 지정합니다 . 관련 파일 의 &lt;code&gt;encoding&lt;/code&gt; 속성을 설정하여 재정의 할 수 있습니다 ( &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 참조 ). 이 옵션을 설정하지 않으면 도구는 기본적으로 로캘 인코딩으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9702444fd012da98ed5d8ff9c395c187404df9d9" translate="yes" xml:space="preserve">
          <source>Specifies the default value for the &lt;code&gt;--max-new-filters&lt;/code&gt; option of &lt;code&gt;git
commit-graph write&lt;/code&gt; (c.f., &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt;).</source>
          <target state="translated">Specifies the default value for the &lt;code&gt;--max-new-filters&lt;/code&gt; option of &lt;code&gt;git commit-graph write&lt;/code&gt; (c.f., &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="8d7b044fb5611f2bdd400a7d800ea730223f6289" translate="yes" xml:space="preserve">
          <source>Specifies the dictionary used for spell checking commit messages in the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;. When set to &quot;none&quot; spell checking is turned off.</source>
          <target state="translated">&lt;a href=&quot;git-gui&quot;&gt;git-gui [1]&lt;/a&gt; 에서 맞춤법 검사 커밋 메시지에 사용되는 사전을 지정합니다 . &quot;없음&quot;으로 설정하면 맞춤법 검사가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="d083f984efe9263940e7d58fa993a7931f1dd65f" translate="yes" xml:space="preserve">
          <source>Specifies the encoding used to output author names and commit summaries. Setting it to &lt;code&gt;none&lt;/code&gt; makes blame output unconverted data. For more information see the discussion about encoding in the &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; manual page.</source>
          <target state="translated">작성자 이름 및 커밋 요약을 출력하는 데 사용되는 인코딩을 지정합니다. &lt;code&gt;none&lt;/code&gt; 으로 설정하면 변환 되지 않은 데이터가 출력됩니다. 자세한 내용은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 매뉴얼 페이지 에서 인코딩에 대한 설명을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="a27599ead22294e56acfe0afc5fbf545479773f2" translate="yes" xml:space="preserve">
          <source>Specifies the format used to output dates in &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;. If unset the iso format is used. For supported values, see the discussion of the &lt;code&gt;--date&lt;/code&gt; option at &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">날짜를 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; 로 출력하는 데 사용되는 형식을 지정합니다 . 설정하지 않으면 iso 형식이 사용됩니다. 지원되는 값 은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 에서 &lt;code&gt;--date&lt;/code&gt; 옵션에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08d91dd5a7053d3bafb0000dd55ac78c15731e93" translate="yes" xml:space="preserve">
          <source>Specifies the format used to output dates. If --date is not provided, the value of the blame.date config variable is used. If the blame.date config variable is also not set, the iso format is used. For supported values, see the discussion of the --date option at &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">날짜를 출력하는 데 사용되는 형식을 지정합니다. --date를 제공하지 않으면 blame.date 구성 변수의 값이 사용됩니다. blame.date 구성 변수도 설정되지 않은 경우 iso 형식이 사용됩니다. 지원되는 값은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 에서 --date 옵션에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="08b582fd23612321f471de0a5131383c71313dc1" translate="yes" xml:space="preserve">
          <source>Specifies the general prompt string to display at the top of the dialog, before subsections for &lt;code&gt;argPrompt&lt;/code&gt; and &lt;code&gt;revPrompt&lt;/code&gt;. The default value includes the actual command.</source>
          <target state="translated">&lt;code&gt;argPrompt&lt;/code&gt; 및 &lt;code&gt;revPrompt&lt;/code&gt; 의 하위 섹션 전에 대화 상자의 맨 위에 표시 할 일반 프롬프트 문자열을 지정합니다 . 기본값은 실제 명령을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a9e526c09a4c4719d9406e0b96ea75a516e14797" translate="yes" xml:space="preserve">
          <source>Specifies the maximal number of fetch operations to be run in parallel at a time (submodules, or remotes when the &lt;code&gt;--multiple&lt;/code&gt; option of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; is in effect).</source>
          <target state="translated">한 번에 병렬로 실행할 최대 페치 조작 수를 지정합니다 ( &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 의 &lt;code&gt;--multiple&lt;/code&gt; 옵션이 적용되는 경우 서브 모듈 또는 리모트 ).</target>
        </trans-unit>
        <trans-unit id="841aeff1992a5e30906fb04c48bd487428f81ede" translate="yes" xml:space="preserve">
          <source>Specifies the number of threads to spawn when loading the index. This is meant to reduce index load time on multiprocessor machines. Specifying 0 or &lt;code&gt;true&lt;/code&gt; will cause Git to auto-detect the number of CPU&amp;rsquo;s and set the number of threads accordingly. Specifying 1 or &lt;code&gt;false&lt;/code&gt; will disable multithreading. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">인덱스를로드 할 때 생성 할 스레드 수를 지정합니다. 이는 다중 프로세서 시스템에서 인덱스로드 시간을 줄이기위한 것입니다. 0 또는 &lt;code&gt;true&lt;/code&gt; 를 지정 하면 Git은 CPU 수를 자동 감지하고 그에 따라 스레드 수를 설정합니다. 1 또는 &lt;code&gt;false&lt;/code&gt; 를 지정 하면 멀티 스레딩이 비활성화됩니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a1edc546a8b44445b5552ac6cb04ae2f0f6c55a7" translate="yes" xml:space="preserve">
          <source>Specifies the number of threads to spawn when resolving deltas. This requires that index-pack be compiled with pthreads otherwise this option is ignored with a warning. This is meant to reduce packing time on multiprocessor machines. The required amount of memory for the delta search window is however multiplied by the number of threads. Specifying 0 will cause Git to auto-detect the number of CPU&amp;rsquo;s and use maximum 3 threads.</source>
          <target state="translated">델타를 해결할 때 생성 할 스레드 수를 지정합니다. 인덱스 팩을 pthreads로 컴파일해야합니다. 그렇지 않으면이 옵션은 경고와 함께 무시됩니다. 이는 다중 프로세서 시스템에서 포장 시간을 단축하기위한 것입니다. 그러나 델타 검색 창에 필요한 메모리 양에는 스레드 수가 곱해집니다. 0을 지정하면 Git은 CPU 수를 자동 감지하고 최대 3 개의 스레드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="62a88cce2e4d60d8d3773b73f0efea252799f6cf" translate="yes" xml:space="preserve">
          <source>Specifies the number of threads to spawn when searching for best delta matches. This requires that &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; be compiled with pthreads otherwise this option is ignored with a warning. This is meant to reduce packing time on multiprocessor machines. The required amount of memory for the delta search window is however multiplied by the number of threads. Specifying 0 will cause Git to auto-detect the number of CPU&amp;rsquo;s and set the number of threads accordingly.</source>
          <target state="translated">최상의 델타 일치를 검색 할 때 생성 할 스레드 수를 지정합니다. 이를 위해서는 &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt; 를 pthreads로 컴파일해야합니다. 그렇지 않으면이 옵션은 경고와 함께 무시됩니다. 이는 다중 프로세서 시스템에서 포장 시간을 단축하기위한 것입니다. 그러나 델타 검색 창에 필요한 메모리 양에는 스레드 수가 곱해집니다. 0을 지정하면 Git은 CPU 수를 자동 감지하고 그에 따라 스레드 수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b8f98a607312c9ba066372345125a9cb60221982" translate="yes" xml:space="preserve">
          <source>Specifies the number of threads to spawn when searching for best delta matches. This requires that pack-objects be compiled with pthreads otherwise this option is ignored with a warning. This is meant to reduce packing time on multiprocessor machines. The required amount of memory for the delta search window is however multiplied by the number of threads. Specifying 0 will cause Git to auto-detect the number of CPU&amp;rsquo;s and set the number of threads accordingly.</source>
          <target state="translated">최상의 델타 일치를 검색 할 때 생성 할 스레드 수를 지정합니다. 이를 위해서는 pack 객체를 pthread로 컴파일해야합니다. 그렇지 않으면이 옵션은 경고와 함께 무시됩니다. 이는 다중 프로세서 시스템에서 포장 시간을 단축하기위한 것입니다. 그러나 델타 검색 창에 필요한 메모리 양에는 스레드 수가 곱해집니다. 0을 지정하면 Git은 CPU 수를 자동 감지하고 그에 따라 스레드 수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a17b7410705517c5284c60d4c1158e205890521a" translate="yes" xml:space="preserve">
          <source>Specifies the number of times to retry a p4 command (notably, &lt;code&gt;p4 sync&lt;/code&gt;) if the network times out. The default value is 3. Set the value to 0 to disable retries or if your p4 version does not support retries (pre 2012.2).</source>
          <target state="translated">네트워크 시간이 초과 된 경우 p4 명령 (특히 &lt;code&gt;p4 sync&lt;/code&gt; ) 을 재 시도하는 횟수를 지정합니다 . 기본값은 3입니다. 재 시도를 비활성화하거나 p4 버전이 재 시도를 지원하지 않는 경우 (2012.2 이전) 값을 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0ebc03abb12118370c422382dc91c5979f3d39ba" translate="yes" xml:space="preserve">
          <source>Specifies the pathname to the file that contains patterns to describe paths that are not meant to be tracked, in addition to &lt;code&gt;.gitignore&lt;/code&gt; (per-directory) and &lt;code&gt;.git/info/exclude&lt;/code&gt;. Defaults to &lt;code&gt;$XDG_CONFIG_HOME/git/ignore&lt;/code&gt;. If &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; is either not set or empty, &lt;code&gt;$HOME/.config/git/ignore&lt;/code&gt; is used instead. See &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.gitignore&lt;/code&gt; (디렉토리 당) 및 &lt;code&gt;.git/info/exclude&lt;/code&gt; 외에도 추적하지 않을 경로를 설명하는 패턴이 포함 된 파일의 경로 이름을 지정합니다 . 기본값은 &lt;code&gt;$XDG_CONFIG_HOME/git/ignore&lt;/code&gt; 입니다. 경우 &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; 하나 설정하거나 비어 있지 않은, &lt;code&gt;$HOME/.config/git/ignore&lt;/code&gt; 대신 사용됩니다. &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d124e54be4e690b62098ac284ac76a08ab37106b" translate="yes" xml:space="preserve">
          <source>Specifies the radius of history context in days to show in &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; for the selected commit, when the &lt;code&gt;Show History
Context&lt;/code&gt; menu item is invoked from &lt;code&gt;git gui blame&lt;/code&gt;. If this variable is set to zero, the whole history is shown.</source>
          <target state="translated">일 지정 역사 컨텍스트의 반경에서 보여 &lt;a href=&quot;gitk&quot;&gt;gitk이 [1]&lt;/a&gt; 때, 커밋 선택에 대한 &lt;code&gt;Show History Context&lt;/code&gt; 메뉴 항목에서 호출 &lt;code&gt;git gui blame&lt;/code&gt; . 이 변수를 0으로 설정하면 전체 히스토리가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f11e5547d2e0c72dd049c0935b29638a6ee69cf3" translate="yes" xml:space="preserve">
          <source>Specifies the shell command line to execute when the corresponding item of the &lt;a href=&quot;git-gui&quot;&gt;git-gui[1]&lt;/a&gt;&lt;code&gt;Tools&lt;/code&gt; menu is invoked. This option is mandatory for every tool. The command is executed from the root of the working directory, and in the environment it receives the name of the tool as &lt;code&gt;GIT_GUITOOL&lt;/code&gt;, the name of the currently selected file as &lt;code&gt;FILENAME&lt;/code&gt;, and the name of the current branch as &lt;code&gt;CUR_BRANCH&lt;/code&gt; (if the head is detached, &lt;code&gt;CUR_BRANCH&lt;/code&gt; is empty).</source>
          <target state="translated">&lt;a href=&quot;git-gui&quot;&gt;git-gui [1] &lt;/a&gt; &lt;code&gt;Tools&lt;/code&gt; 메뉴 의 해당 항목 이 호출 될 때 실행할 쉘 명령 행을 지정합니다 . 이 옵션은 모든 도구에 필수입니다. 명령은 작업 디렉토리의 루트에서 실행되며 환경에서 도구 이름은 &lt;code&gt;GIT_GUITOOL&lt;/code&gt; , 현재 선택된 파일 이름은 &lt;code&gt;FILENAME&lt;/code&gt; , 현재 브랜치 이름은 &lt;code&gt;CUR_BRANCH&lt;/code&gt; (헤드가 분리, &lt;code&gt;CUR_BRANCH&lt;/code&gt; 가 비어 있습니다).</target>
        </trans-unit>
        <trans-unit id="b9843bcfef468e8924053c3490935a52737f70b4" translate="yes" xml:space="preserve">
          <source>Specifies the threshold to use in &lt;code&gt;git gui blame&lt;/code&gt; original location detection, measured in alphanumeric characters. See the &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; manual for more information on copy detection.</source>
          <target state="translated">영숫자 문자로 측정 된 &lt;code&gt;git gui blame&lt;/code&gt; 원래 위치 감지 에 사용할 임계 값을 지정합니다 . 복사 감지에 대한 자세한 내용은 &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="35d941c623037130ce3eda15ee67700140f974b9" translate="yes" xml:space="preserve">
          <source>Specifies the title to use for the prompt dialog. The default is the tool name.</source>
          <target state="translated">프롬프트 대화 상자에 사용할 제목을 지정합니다. 기본값은 도구 이름입니다.</target>
        </trans-unit>
        <trans-unit id="52c4a2a4dc795a08ca1c6e643c489de2ec8bd5e5" translate="yes" xml:space="preserve">
          <source>Specifies whether the index file should include an &quot;End Of Index Entry&quot; section. This reduces index load time on multiprocessor machines but produces a message &quot;ignoring EOIE extension&quot; when reading the index using Git versions before 2.20. Defaults to &lt;code&gt;true&lt;/code&gt; if index.threads has been explicitly enabled, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">인덱스 파일에 &quot;Index of End Entry&quot;섹션을 포함해야하는지 여부를 지정합니다. 이렇게하면 다중 프로세서 시스템에서 인덱스로드 시간이 줄어들지 만 2.20 이전의 Git 버전을 사용하여 인덱스를 읽을 때 &quot;EOIE 확장명 무시&quot;메시지가 표시됩니다. index.threads가 명시 적으로 활성화 된 경우 기본값은 &lt;code&gt;true&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="525e2825828b98c76d10ccc05a720012cdd9968e" translate="yes" xml:space="preserve">
          <source>Specifies whether the index file should include an &quot;Index Entry Offset Table&quot; section. This reduces index load time on multiprocessor machines but produces a message &quot;ignoring IEOT extension&quot; when reading the index using Git versions before 2.20. Defaults to &lt;code&gt;true&lt;/code&gt; if index.threads has been explicitly enabled, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">색인 파일에 &quot;색인 항목 오프셋 테이블&quot;섹션이 포함되어야하는지 여부를 지정합니다. 이렇게하면 다중 프로세서 컴퓨터에서 인덱스로드 시간이 줄어들지 만 2.20 이전의 Git 버전을 사용하여 인덱스를 읽을 때 &quot;IEOT 확장명 무시&quot;메시지가 나타납니다. index.threads가 명시 적으로 활성화 된 경우 기본값은 &lt;code&gt;true&lt;/code&gt; 이고, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8fdd8a31fc755f041d294b5f0a76be847216c212" translate="yes" xml:space="preserve">
          <source>Specifies which key format to use when signing with &lt;code&gt;--gpg-sign&lt;/code&gt;. Default is &quot;openpgp&quot; and another possible value is &quot;x509&quot;.</source>
          <target state="translated">&lt;code&gt;--gpg-sign&lt;/code&gt; 으로 서명 할 때 사용할 키 형식을 지정 합니다 . 기본값은 &quot;openpgp&quot;이고 다른 가능한 값은 &quot;x509&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="53399059f89e05e568d5d0da51714e4798f56246" translate="yes" xml:space="preserve">
          <source>Specifies which refs to fetch and which local refs to update. When no &amp;lt;refspec&amp;gt;s appear on the command line, the refs to fetch are read from &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; variables instead (see &lt;a href=&quot;#CRTB&quot;&gt;CONFIGURED REMOTE-TRACKING BRANCHES&lt;/a&gt; below).</source>
          <target state="translated">가져올 참조와 업데이트 할 로컬 참조를 지정합니다. 명령 행에 &amp;lt;refspec&amp;gt;이 나타나지 않으면, fetch 할 ref는 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 변수에서 대신 읽습니다 ( 아래의 &lt;a href=&quot;#CRTB&quot;&gt;REMOTE-TRACKING BRANCHES 구성&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="60264eae7c0d99030432a57153dd31a20ae2e753" translate="yes" xml:space="preserve">
          <source>Specifies which refs to fetch and which local refs to update. When no &amp;lt;refspec&amp;gt;s appear on the command line, the refs to fetch are read from &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; variables instead (see &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</source>
          <target state="translated">가져올 참조와 업데이트 할 로컬 참조를 지정합니다. 명령 행에 &amp;lt;refspec&amp;gt;이 나타나지 않으면, 대신 &lt;a href=&quot;git-fetch&quot;&gt;가져 오는&lt;/a&gt; 참조 는 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; 변수 에서 읽습니다 ( git-fetch [1] 참조 ).</target>
        </trans-unit>
        <trans-unit id="1874860df7878b35e35c3f03f4fe16310c6f5c2f" translate="yes" xml:space="preserve">
          <source>Specifies which refs to fetch and which local refs to update. When no &amp;lt;refspec&amp;gt;s appear on the command line, the refs to fetch are read from &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; variables instead (see the section &quot;CONFIGURED REMOTE-TRACKING BRANCHES&quot; in &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</source>
          <target state="translated">Specifies which refs to fetch and which local refs to update. When no &amp;lt;refspec&amp;gt;s appear on the command line, the refs to fetch are read from &lt;code&gt;remote.&amp;lt;repository&amp;gt;.fetch&lt;/code&gt; variables instead (see the section &quot;CONFIGURED REMOTE-TRACKING BRANCHES&quot; in &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="12c5a4fe1da6e3ddd052994379342b3963b9ece6" translate="yes" xml:space="preserve">
          <source>Specify a &quot;Bcc:&quot; value for each email. Default is the value of &lt;code&gt;sendemail.bcc&lt;/code&gt;.</source>
          <target state="translated">각 이메일에 대해 &quot;숨은 참조 :&quot;값을 지정하십시오. 기본값은 &lt;code&gt;sendemail.bcc&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="490afafb9292b82bc6ff88488dc739661601f0fb" translate="yes" xml:space="preserve">
          <source>Specify a (&amp;lt;token&amp;gt;, &amp;lt;value&amp;gt;) pair that should be applied as a trailer to the input messages. See the description of this command.</source>
          <target state="translated">입력 메시지에 예고편으로 적용해야하는 (&amp;lt;토큰&amp;gt;, &amp;lt;값&amp;gt;) 쌍을 지정하십시오. 이 명령에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fda787c4a6303bd8c4899e47b2fd75ed69b102b2" translate="yes" xml:space="preserve">
          <source>Specify a comma separate list of common whitespace problems to notice in the same format as the &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable.</source>
          <target state="translated">&lt;code&gt;core.whitespace&lt;/code&gt; 구성 변수 와 동일한 형식으로 확인할 일반적인 공백 문제의 쉼표로 구분 된 목록을 지정 하십시오.</target>
        </trans-unit>
        <trans-unit id="f01423252b19025369d9eaeaea940daec72c630e" translate="yes" xml:space="preserve">
          <source>Specify a command to execute once per patch file which should generate patch file specific &quot;Cc:&quot; entries. Output of this command must be single email address per line. Default is the value of &lt;code&gt;sendemail.ccCmd&lt;/code&gt; configuration value.</source>
          <target state="translated">패치 파일 특정 &quot;Cc :&quot;항목을 생성해야하는 패치 파일 당 한 번 실행할 명령을 지정하십시오. 이 명령의 출력은 한 줄에 하나의 이메일 주소 여야합니다. 기본값은 &lt;code&gt;sendemail.ccCmd&lt;/code&gt; 구성 값입니다.</target>
        </trans-unit>
        <trans-unit id="8a69aa64125bc041f34a0988fcc820e93ea1cefe" translate="yes" xml:space="preserve">
          <source>Specify a command to execute once per patch file which should generate patch file specific &quot;To:&quot; entries. Output of this command must be single email address per line. Default is the value of &lt;code&gt;sendemail.tocmd&lt;/code&gt; configuration value.</source>
          <target state="translated">패치 파일마다 &quot;To :&quot;항목을 생성해야하는 패치 파일 당 한 번 실행할 명령을 지정하십시오. 이 명령의 출력은 한 줄에 하나의 이메일 주소 여야합니다. 기본값은 &lt;code&gt;sendemail.tocmd&lt;/code&gt; 구성 값입니다.</target>
        </trans-unit>
        <trans-unit id="f6cbbfb6d081efa8553064ef51812c93149ccd37" translate="yes" xml:space="preserve">
          <source>Specify a custom command for viewing diffs. &lt;code&gt;git-difftool&lt;/code&gt; ignores the configured defaults and runs &lt;code&gt;$command $LOCAL $REMOTE&lt;/code&gt; when this option is specified. Additionally, &lt;code&gt;$BASE&lt;/code&gt; is set in the environment.</source>
          <target state="translated">diff를보기위한 사용자 정의 명령을 지정하십시오. &lt;code&gt;git-difftool&lt;/code&gt; 은 구성된 기본값을 무시 하고이 옵션이 지정되면 &lt;code&gt;$command $LOCAL $REMOTE&lt;/code&gt; 실행 합니다. 또한 &lt;code&gt;$BASE&lt;/code&gt; 는 환경에서 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f8f61e37f968bf27d42f1bb30c54e88a19aa0b4c" translate="yes" xml:space="preserve">
          <source>Specify a starting &quot;Cc:&quot; value for each email. Default is the value of &lt;code&gt;sendemail.cc&lt;/code&gt;.</source>
          <target state="translated">각 이메일의 시작 &quot;Cc :&quot;값을 지정하십시오. 기본값은 &lt;code&gt;sendemail.cc&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="d751165243a07b0d8cf01d157a40d624e1274cc2" translate="yes" xml:space="preserve">
          <source>Specify a web browser that may be used by some commands. Currently only &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; and &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt; may use it.</source>
          <target state="translated">일부 명령에서 사용할 수있는 웹 브라우저를 지정하십시오. 현재는 &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt; 및 &lt;a href=&quot;git-help&quot;&gt;git-help [1] 만&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3184d8ec3f5fc0c7b49c79eaaa392759be7aeb74" translate="yes" xml:space="preserve">
          <source>Specify an additional category of recipients to suppress the auto-cc of:</source>
          <target state="translated">받는 사람의 추가 범주를 지정하여 다음과 같은 자동 참조를 억제하십시오.</target>
        </trans-unit>
        <trans-unit id="853dca472e65277cdebf40417680870445848b28" translate="yes" xml:space="preserve">
          <source>Specify an alternate suffix for the bugreport name, to create a file named &lt;code&gt;git-bugreport-&amp;lt;formatted suffix&amp;gt;&lt;/code&gt;. This should take the form of a strftime(3) format string; the current local time will be used.</source>
          <target state="translated">버그 보고서 이름에 대한 대체 접미사를 지정하여 &lt;code&gt;git-bugreport-&amp;lt;formatted suffix&amp;gt;&lt;/code&gt; 라는 파일을 만듭니다 . 이것은 strftime (3) 형식 문자열의 형식을 취해야합니다. 현재 현지 시간이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6c3bb30f438f4e33cf02f17fe7e170959d2a5bad" translate="yes" xml:space="preserve">
          <source>Specify an external helper to be called when a username or password credential is needed; the helper may consult external storage to avoid prompting the user for the credentials. Note that multiple helpers may be defined. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for details.</source>
          <target state="translated">사용자 이름 또는 비밀번호 자격 증명이 필요할 때 호출 할 외부 도우미를 지정하십시오. 도우미는 사용자에게 자격 증명을 요구하지 않도록 외부 저장소를 참조 할 수 있습니다. 여러 헬퍼가 정의 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5898b8f989a6a4118fc60032ee65af46c3876839" translate="yes" xml:space="preserve">
          <source>Specify an external helper to be called when a username or password credential is needed; the helper may consult external storage to avoid prompting the user for the credentials. This is normally the name of a credential helper with possible arguments, but may also be an absolute path with arguments or, if preceded by &lt;code&gt;!&lt;/code&gt;, shell commands.</source>
          <target state="translated">Specify an external helper to be called when a username or password credential is needed; the helper may consult external storage to avoid prompting the user for the credentials. This is normally the name of a credential helper with possible arguments, but may also be an absolute path with arguments or, if preceded by &lt;code&gt;!&lt;/code&gt; , shell commands.</target>
        </trans-unit>
        <trans-unit id="88abf188bf279fdc57952e5f78070fe3d6b977d1" translate="yes" xml:space="preserve">
          <source>Specify an island name which gets to have its objects be packed first. This creates a kind of pseudo-pack at the front of one pack, so that the objects from the specified island are hopefully faster to copy into any pack that should be served to a user requesting these objects. In practice this means that the island specified should likely correspond to what is the most commonly cloned in the repo. See also &quot;DELTA ISLANDS&quot; in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt;.</source>
          <target state="translated">객체를 먼저 포장 할 섬 이름을 지정하십시오. 이것은 하나의 팩의 전면에 일종의 유사 팩을 생성하므로 지정된 섬의 객체가 이러한 객체를 요청하는 사용자에게 제공되어야하는 팩으로 복사하는 것이 더 빠릅니다. 실제로 이것은 지정된 섬이 리포지토리에서 가장 일반적으로 복제 된 것과 일치해야 함을 의미합니다. &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]의&lt;/a&gt; &quot;DELTA ISLANDS&quot;도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f4ddca39682ecb94c54d4e5428623a9fabd67c0" translate="yes" xml:space="preserve">
          <source>Specify any of the options listed under OPTIONS that do not change stream semantic to suit the frontend&amp;rsquo;s needs. This command is optional and is not needed to perform an import.</source>
          <target state="translated">프론트 엔드의 요구에 맞게 스트림 의미를 변경하지 않는 OPTIONS 아래에 나열된 옵션을 지정하십시오. 이 명령은 선택 사항이며 가져 오기를 수행 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="126df40ac6c274763f2820bec126088754eb50a7" translate="yes" xml:space="preserve">
          <source>Specify authenticate method for authentication with IMAP server. If Git was built with the NO_CURL option, or if your curl version is older than 7.34.0, or if you&amp;rsquo;re running git-imap-send with the &lt;code&gt;--no-curl&lt;/code&gt; option, the only supported method is &lt;code&gt;CRAM-MD5&lt;/code&gt;. If this is not set then &lt;code&gt;git imap-send&lt;/code&gt; uses the basic IMAP plaintext LOGIN command.</source>
          <target state="translated">IMAP 서버 인증을위한 인증 방법을 지정하십시오. Git이 NO_CURL 옵션으로 빌드되었거나 curl 버전이 7.34.0보다 오래된 경우 또는 &lt;code&gt;--no-curl&lt;/code&gt; 옵션으로 git-imap-send를 실행 하는 경우 지원되는 유일한 방법은 &lt;code&gt;CRAM-MD5&lt;/code&gt; 입니다. 이것이 설정되어 있지 않으면 &lt;code&gt;git imap-send&lt;/code&gt; 는 기본 IMAP 평문 LOGIN 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="db15aaae21c1056154eef62ce5f5cbd5e82beaa7" translate="yes" xml:space="preserve">
          <source>Specify encoding of compose message. Default is the value of the &lt;code&gt;sendemail.composeencoding&lt;/code&gt;; if that is unspecified, UTF-8 is assumed.</source>
          <target state="translated">작성 메시지의 인코딩을 지정하십시오. 기본값은 &lt;code&gt;sendemail.composeencoding&lt;/code&gt; 의 값입니다 . 지정하지 않으면 UTF-8로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="bb2c4dacdd5136c6abef6fcc4de5e9c24a473010" translate="yes" xml:space="preserve">
          <source>Specify how differences in submodules are shown. When specifying &lt;code&gt;--submodule=short&lt;/code&gt; the &lt;code&gt;short&lt;/code&gt; format is used. This format just shows the names of the commits at the beginning and end of the range. When &lt;code&gt;--submodule&lt;/code&gt; or &lt;code&gt;--submodule=log&lt;/code&gt; is specified, the &lt;code&gt;log&lt;/code&gt; format is used. This format lists the commits in the range like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;&lt;code&gt;summary&lt;/code&gt; does. When &lt;code&gt;--submodule=diff&lt;/code&gt; is specified, the &lt;code&gt;diff&lt;/code&gt; format is used. This format shows an inline diff of the changes in the submodule contents between the commit range. Defaults to &lt;code&gt;diff.submodule&lt;/code&gt; or the &lt;code&gt;short&lt;/code&gt; format if the config option is unset.</source>
          <target state="translated">서브 모듈의 차이점을 표시하는 방법을 지정하십시오. &lt;code&gt;--submodule=short&lt;/code&gt; 를 지정 하면 &lt;code&gt;short&lt;/code&gt; 형식이 사용됩니다. 이 형식은 범위의 시작과 끝에서 커밋 이름을 보여줍니다. 때 &lt;code&gt;--submodule&lt;/code&gt; 또는 &lt;code&gt;--submodule=log&lt;/code&gt; 지정되면, &lt;code&gt;log&lt;/code&gt; 형식이 사용됩니다. 이 형식은 &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1] &lt;/a&gt; &lt;code&gt;summary&lt;/code&gt; 과 같은 범위의 커밋을 나열합니다 . 경우 &lt;code&gt;--submodule=diff&lt;/code&gt; 지정되면, &lt;code&gt;diff&lt;/code&gt; 포맷이 사용된다. 이 형식은 커밋 범위 사이의 하위 모듈 내용 변경 내용을 인라인으로 표시합니다. 기본적으로 &lt;code&gt;diff.submodule&lt;/code&gt; 또는 &lt;code&gt;short&lt;/code&gt; 구성 옵션이 설정되지 않은 경우 형식입니다.</target>
        </trans-unit>
        <trans-unit id="e212f603460a2824026571f0244622b2735e495f" translate="yes" xml:space="preserve">
          <source>Specify how multiple patterns are combined using Boolean expressions. &lt;code&gt;--or&lt;/code&gt; is the default operator. &lt;code&gt;--and&lt;/code&gt; has higher precedence than &lt;code&gt;--or&lt;/code&gt;. &lt;code&gt;-e&lt;/code&gt; has to be used for all patterns.</source>
          <target state="translated">부울 표현식을 사용하여 여러 패턴을 결합하는 방법을 지정하십시오. &lt;code&gt;--or&lt;/code&gt; 기본 연산자입니다. &lt;code&gt;--and&lt;/code&gt; 보다 우선 순위가있다 &lt;code&gt;--or&lt;/code&gt; . &lt;code&gt;-e&lt;/code&gt; 는 모든 패턴에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ffbe8c6ac43df98980b6107e62dec3dfa7156507" translate="yes" xml:space="preserve">
          <source>Specify how to handle &lt;code&gt;encoding&lt;/code&gt; header in commit objects. When asking to &lt;code&gt;abort&lt;/code&gt; (which is the default), this program will die when encountering such a commit object. With &lt;code&gt;yes&lt;/code&gt;, the commit message will be re-encoded into UTF-8. With &lt;code&gt;no&lt;/code&gt;, the original encoding will be preserved.</source>
          <target state="translated">커밋 개체에서 &lt;code&gt;encoding&lt;/code&gt; 헤더 를 처리 하는 방법을 지정하십시오 . &lt;code&gt;abort&lt;/code&gt; 요청할 때 (기본값)이 확약 오브젝트가 발생하면이 프로그램이 종료됩니다. 함께 &lt;code&gt;yes&lt;/code&gt; 의 메시지가 재 인코딩 UTF-8로 될 것입니다 커밋. 함께 &lt;code&gt;no&lt;/code&gt; 원래의 인코딩은 보존되지 않는다.</target>
        </trans-unit>
        <trans-unit id="37815a435af244972cccaee7f12b140bf366ab25" translate="yes" xml:space="preserve">
          <source>Specify how to handle signed tags. Since any transformation after the export can change the tag names (which can also happen when excluding revisions) the signatures will not match.</source>
          <target state="translated">서명 된 태그를 처리하는 방법을 지정하십시오. 내 보낸 후 변환하면 태그 이름을 변경할 수 있으므로 (수정을 제외 할 때도 발생할 수 있음) 서명이 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e5b9b1beb3e649edbd3450c18f18cbc2b0b3c2a" translate="yes" xml:space="preserve">
          <source>Specify how to handle tags whose tagged object is filtered out. Since revisions and files to export can be limited by path, tagged objects may be filtered completely.</source>
          <target state="translated">태그가 지정된 객체가 필터링 된 태그를 처리하는 방법을 지정하십시오. 내보낼 개정 및 파일은 경로별로 제한 될 수 있으므로 태그가 지정된 객체가 완전히 필터링 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58a10039b2ffb00f4c15d28cf7a59fdf8252b1ba" translate="yes" xml:space="preserve">
          <source>Specify layout mode. See configuration variable column.ui for option syntax in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">레이아웃 모드를 지정하십시오. &lt;a href=&quot;git-config&quot;&gt;git-config [1]의&lt;/a&gt; 옵션 구문에 대해서는 구성 변수 column.ui를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd9fc5283ae0d7709eafb7d7c044a946ec4a926f" translate="yes" xml:space="preserve">
          <source>Specify submit behavior when a conflict with p4 is found, as per --conflict. The default behavior is &lt;code&gt;ask&lt;/code&gt;.</source>
          <target state="translated">--conflict에 따라 p4와의 충돌이 발견되면 제출 동작을 지정하십시오. 기본 동작은 &lt;code&gt;ask&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6b47b0eac1308c340a251aaa9bc02b368f9e6ec9" translate="yes" xml:space="preserve">
          <source>Specify that the Git repository is to be shared amongst several users. This allows users belonging to the same group to push into that repository. When specified, the config variable &quot;core.sharedRepository&quot; is set so that files and directories under &lt;code&gt;$GIT_DIR&lt;/code&gt; are created with the requested permissions. When not specified, Git will use permissions reported by umask(2).</source>
          <target state="translated">여러 사용자가 Git 저장소를 공유하도록 지정하십시오. 이를 통해 동일한 그룹에 속한 사용자가 해당 저장소로 푸시 할 수 있습니다. 지정된 경우 &quot;core.sharedRepository&quot;구성 변수가 설정되어 &lt;code&gt;$GIT_DIR&lt;/code&gt; GIT_DIR 아래의 파일 및 디렉토리 가 요청 된 권한으로 작성됩니다. 지정하지 않으면 Git은 umask (2)에 의해보고 된 권한을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="553f83584ef890feb9fc0a5fa486ad4027a85d31" translate="yes" xml:space="preserve">
          <source>Specify that the p4 client spec should be used to identify p4 depot paths of interest. This is equivalent to specifying the option &lt;code&gt;--use-client-spec&lt;/code&gt;. See the &quot;CLIENT SPEC&quot; section above. This variable is a boolean, not the name of a p4 client.</source>
          <target state="translated">p4 클라이언트 스펙을 사용하여 관심있는 p4 저장소 경로를 식별하도록 지정하십시오. 이는 &lt;code&gt;--use-client-spec&lt;/code&gt; 옵션을 지정하는 것과 같습니다 . 위의 &quot;CLIENT SPEC&quot;섹션을 참조하십시오. 이 변수는 p4 클라이언트의 이름이 아닌 부울입니다.</target>
        </trans-unit>
        <trans-unit id="ee45839e9a36541472b0e6b0c79bb025ae2d044b" translate="yes" xml:space="preserve">
          <source>Specify the SVN username to perform the commit as. This option overrides the &lt;code&gt;username&lt;/code&gt; configuration property.</source>
          <target state="translated">커밋을 수행 할 SVN 사용자 이름을 지정하십시오. 이 옵션은 &lt;code&gt;username&lt;/code&gt; 구성 속성을 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ce5445a596c457d8087a3ba95eb2c606f830762e" translate="yes" xml:space="preserve">
          <source>Specify the [svn-remote &quot;&amp;lt;remote name&amp;gt;&quot;] section to use, this allows SVN multiple repositories to be tracked. Default: &quot;svn&quot;</source>
          <target state="translated">사용할 [svn-remote &quot;&amp;lt;remote name&amp;gt;&quot;] 섹션을 지정하면 SVN 다중 저장소를 추적 할 수 있습니다. 기본값 : &quot;svn&quot;</target>
        </trans-unit>
        <trans-unit id="9617526476bf00e3e1b98443975d22edd359d482" translate="yes" xml:space="preserve">
          <source>Specify the address where replies from recipients should go to. Use this if replies to messages should go to another address than what is specified with the --from parameter.</source>
          <target state="translated">수신자의 답장을받을 주소를 지정하십시오. 메시지에 대한 회신이 --from 매개 변수로 지정된 주소 이외의 다른 주소로 이동해야하는 경우이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ee03a68cf221fcf3ea580414a042d4bf2bb9f1e8" translate="yes" xml:space="preserve">
          <source>Specify the browser that will be used to display help in the &lt;code&gt;web&lt;/code&gt; format. See &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;web&lt;/code&gt; 형식으로 도움말을 표시하는 데 사용될 브라우저를 지정하십시오 . &lt;a href=&quot;git-help&quot;&gt;git-help [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="70ff10aa9e9d4bf715e29b8e032ab68c07b42b92" translate="yes" xml:space="preserve">
          <source>Specify the bundle version. Version 2 is the older format and can only be used with SHA-1 repositories; the newer version 3 contains capabilities that permit extensions. The default is the oldest supported format, based on the hash algorithm in use.</source>
          <target state="translated">Specify the bundle version. Version 2 is the older format and can only be used with SHA-1 repositories; the newer version 3 contains capabilities that permit extensions. The default is the oldest supported format, based on the hash algorithm in use.</target>
        </trans-unit>
        <trans-unit id="8aa86dc00b5d1ada804b541ee50aabffe17fa3ad" translate="yes" xml:space="preserve">
          <source>Specify the character used to indicate new, old or context lines in the generated patch. Normally they are &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; and ' ' respectively.</source>
          <target state="translated">생성 된 패치에서 신규, 기존 또는 컨텍스트 라인을 나타내는 데 사용되는 문자를 지정하십시오. 일반적으로 각각 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; 및 ''입니다.</target>
        </trans-unit>
        <trans-unit id="966a510a55d7cdd1c3c8b5ab55defa7916878e77" translate="yes" xml:space="preserve">
          <source>Specify the command to invoke the specified browser. The specified command is evaluated in shell with the URLs passed as arguments. (See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt;.)</source>
          <target state="translated">Specify the command to invoke the specified browser. The specified command is evaluated in shell with the URLs passed as arguments. (See &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt;.)</target>
        </trans-unit>
        <trans-unit id="cb636a61044a94ec71c2c0e48db959f09a640e28" translate="yes" xml:space="preserve">
          <source>Specify the command to invoke the specified browser. The specified command is evaluated in shell with the URLs passed as arguments. (See git-web{litdd}browse[1].)</source>
          <target state="translated">지정된 브라우저를 호출하는 명령을 지정하십시오. 지정된 명령은 URL로 인수로 전달 된 쉘에서 평가됩니다. (git-web {litdd} browse [1]을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="f8ec599a595d519e45f7089bd76b8eb2f0cf86d7" translate="yes" xml:space="preserve">
          <source>Specify the command to invoke the specified diff tool.</source>
          <target state="translated">지정된 diff 도구를 호출하는 명령을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="045550ad84d88752a76cca9657a08fe5f6314875" translate="yes" xml:space="preserve">
          <source>Specify the command to invoke the specified diff tool. The specified command is evaluated in shell with the following variables available: &lt;code&gt;LOCAL&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff pre-image and &lt;code&gt;REMOTE&lt;/code&gt; is set to the name of the temporary file containing the contents of the diff post-image.</source>
          <target state="translated">지정된 diff 도구를 호출하는 명령을 지정하십시오. 지정된 명령은 사용 가능한 다음 변수를 사용하여 쉘에서 평가됩니다. &lt;code&gt;LOCAL&lt;/code&gt; 은 diff pre-image 의 내용을 포함하는 임시 파일 이름으로 설정 되고 &lt;code&gt;REMOTE&lt;/code&gt; 는 diff post의 내용을 포함하는 임시 파일 이름으로 설정됩니다. -영상.</target>
        </trans-unit>
        <trans-unit id="a4e7d7e1334d2dbe270d234d60ef8777bddd17c9" translate="yes" xml:space="preserve">
          <source>Specify the command to invoke the specified man viewer. The specified command is evaluated in shell with the man page passed as argument. (See &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;.)</source>
          <target state="translated">지정된 man viewer를 호출하는 명령을 지정하십시오. 지정된 명령은 셸에서 man 페이지가 인수로 전달되어 평가됩니다. ( &lt;a href=&quot;git-help&quot;&gt;git-help [1]&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="3a2ff684c7c448a4b91310593e49dad0e76d3118" translate="yes" xml:space="preserve">
          <source>Specify the command to invoke the specified merge tool. The specified command is evaluated in shell with the following variables available: &lt;code&gt;BASE&lt;/code&gt; is the name of a temporary file containing the common base of the files to be merged, if available; &lt;code&gt;LOCAL&lt;/code&gt; is the name of a temporary file containing the contents of the file on the current branch; &lt;code&gt;REMOTE&lt;/code&gt; is the name of a temporary file containing the contents of the file from the branch being merged; &lt;code&gt;MERGED&lt;/code&gt; contains the name of the file to which the merge tool should write the results of a successful merge.</source>
          <target state="translated">지정된 병합 도구를 호출하는 명령을 지정하십시오. 지정된 명령은 사용 가능한 다음 변수를 사용하여 쉘에서 평가됩니다. &lt;code&gt;BASE&lt;/code&gt; 는 사용 가능한 경우 병합 될 파일의 ​​공통 기반을 포함하는 임시 파일의 이름입니다. &lt;code&gt;LOCAL&lt;/code&gt; 은 현재 분기의 파일 내용을 포함하는 임시 파일의 이름입니다. &lt;code&gt;REMOTE&lt;/code&gt; 는 병합중인 브랜치의 파일 내용을 포함하는 임시 파일의 이름입니다. &lt;code&gt;MERGED&lt;/code&gt; 는 병합 도구가 성공적인 병합 결과를 작성해야하는 파일 이름을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="6a0cfc4c034bf82c50504b5853ea3a2048b66aa0" translate="yes" xml:space="preserve">
          <source>Specify the default pack index version. Valid values are 1 for legacy pack index used by Git versions prior to 1.5.2, and 2 for the new pack index with capabilities for packs larger than 4 GB as well as proper protection against the repacking of corrupted packs. Version 2 is the default. Note that version 2 is enforced and this config option ignored whenever the corresponding pack is larger than 2 GB.</source>
          <target state="translated">기본 팩 인덱스 버전을 지정하십시오. 유효한 값은 1.5.2 이전의 Git 버전에서 사용 된 레거시 팩 인덱스의 경우 1이고, 4GB보다 큰 팩의 기능이있는 새 팩 인덱스의 경우 2이며 손상된 팩의 재 포장에 대한 적절한 보호입니다. 버전 2가 기본값입니다. 버전 2가 적용되고 해당 팩이 2GB보다 클 때마다이 구성 옵션이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="237b5a9487d0a4c4f3b292963fb14ac9431d7354" translate="yes" xml:space="preserve">
          <source>Specify the directory from which templates will be copied. (See the &quot;TEMPLATE DIRECTORY&quot; section of &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt;.)</source>
          <target state="translated">템플리트를 복사 할 디렉토리를 지정하십시오. ( &lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt; 의 &quot;TEMPLATE DIRECTORY&quot;섹션을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="9e017dab9e6089dc4c6b8916eff9198d29b5fa5a" translate="yes" xml:space="preserve">
          <source>Specify the directory from which templates will be used. (See the &quot;TEMPLATE DIRECTORY&quot; section below.)</source>
          <target state="translated">템플리트를 사용할 디렉토리를 지정하십시오. 아래의 &quot;템플릿 디렉토리&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="10fbc8bd7f7f67034717ffef3bdc652592011a96" translate="yes" xml:space="preserve">
          <source>Specify the directory from which templates will be used; (See the &quot;TEMPLATE DIRECTORY&quot; section of &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt;.)</source>
          <target state="translated">템플리트를 사용할 디렉토리를 지정하십시오. ( &lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt; 의 &quot;TEMPLATE DIRECTORY&quot;섹션을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="6d06560706961e8be925ad5b0c5ec94cdc91c729" translate="yes" xml:space="preserve">
          <source>Specify the encryption to use, either &lt;code&gt;ssl&lt;/code&gt; or &lt;code&gt;tls&lt;/code&gt;. Any other value reverts to plain SMTP. Default is the value of &lt;code&gt;sendemail.smtpEncryption&lt;/code&gt;.</source>
          <target state="translated">사용할 암호화를 &lt;code&gt;ssl&lt;/code&gt; 또는 &lt;code&gt;tls&lt;/code&gt; 로 지정하십시오 . 다른 값은 일반 SMTP로 되돌아갑니다. 기본값은 &lt;code&gt;sendemail.smtpEncryption&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="4d476f2efa135b04b0d382124ae1d7eb2f09baec" translate="yes" xml:space="preserve">
          <source>Specify the envelope sender used to send the emails. This is useful if your default address is not the address that is subscribed to a list. In order to use the &lt;code&gt;From&lt;/code&gt; address, set the value to &quot;auto&quot;. If you use the sendmail binary, you must have suitable privileges for the -f parameter. Default is the value of the &lt;code&gt;sendemail.envelopeSender&lt;/code&gt; configuration variable; if that is unspecified, choosing the envelope sender is left to your MTA.</source>
          <target state="translated">이메일을 보내는 데 사용되는 봉투 발신자를 지정하십시오. 기본 주소가 목록에 등록 된 주소가 아닌 경우에 유용합니다. &lt;code&gt;From&lt;/code&gt; 주소 를 사용하려면 값을 &quot;auto&quot;로 설정하십시오. sendmail 바이너리를 사용하는 경우 -f 매개 변수에 대한 적절한 권한이 있어야합니다. 기본값은 &lt;code&gt;sendemail.envelopeSender&lt;/code&gt; 구성 변수 의 값입니다 . 지정하지 않으면 봉투 발신자를 선택하는 것이 MTA에 맡겨집니다.</target>
        </trans-unit>
        <trans-unit id="57154856f70bd26e9f32c73474da174dbb6a71bf" translate="yes" xml:space="preserve">
          <source>Specify the format in which differences in submodules are shown. The &quot;short&quot; format just shows the names of the commits at the beginning and end of the range. The &quot;log&quot; format lists the commits in the range like &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;&lt;code&gt;summary&lt;/code&gt; does. The &quot;diff&quot; format shows an inline diff of the changed contents of the submodule. Defaults to &quot;short&quot;.</source>
          <target state="translated">서브 모듈의 차이점이 표시되는 형식을 지정하십시오. &quot;짧은&quot;형식은 범위의 시작과 끝에서 커밋 이름을 보여줍니다. &quot;log&quot;형식은 &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1] &lt;/a&gt; &lt;code&gt;summary&lt;/code&gt; 과 같은 범위의 커밋을 나열합니다 . &quot;diff&quot;형식은 서브 모듈의 변경된 내용의 인라인 diff를 보여줍니다. 기본값은 &quot;짧음&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="ee4e54ea6641c26749f683e2086f11110bfcb031" translate="yes" xml:space="preserve">
          <source>Specify the full path of &lt;code&gt;git-upload-pack&lt;/code&gt; on the remote host. This allows listing references from repositories accessed via SSH and where the SSH daemon does not use the PATH configured by the user.</source>
          <target state="translated">원격 호스트에서 &lt;code&gt;git-upload-pack&lt;/code&gt; 의 전체 경로를 지정하십시오 . 이를 통해 SSH를 통해 액세스 한 저장소 및 SSH 디먼이 사용자가 구성한 PATH를 사용하지 않는 저장소의 참조를 나열 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06ad205dd66ffad363b165c748636d60b7e9ddfc" translate="yes" xml:space="preserve">
          <source>Specify the given object format (hash algorithm) for the index file. The valid values are &lt;code&gt;sha1&lt;/code&gt; and (if enabled) &lt;code&gt;sha256&lt;/code&gt;. The default is the algorithm for the current repository (set by &lt;code&gt;extensions.objectFormat&lt;/code&gt;), or &lt;code&gt;sha1&lt;/code&gt; if no value is set or outside a repository..</source>
          <target state="translated">Specify the given object format (hash algorithm) for the index file. The valid values are &lt;code&gt;sha1&lt;/code&gt; and (if enabled) &lt;code&gt;sha256&lt;/code&gt; . The default is the algorithm for the current repository (set by &lt;code&gt;extensions.objectFormat&lt;/code&gt; ), or &lt;code&gt;sha1&lt;/code&gt; if no value is set or outside a repository..</target>
        </trans-unit>
        <trans-unit id="2b5df638fbdbefd14fe565482082a779d66f41cb" translate="yes" xml:space="preserve">
          <source>Specify the given object format (hash algorithm) for the pack. The valid values are &lt;code&gt;sha1&lt;/code&gt; and (if enabled) &lt;code&gt;sha256&lt;/code&gt;. The default is the algorithm for the current repository (set by &lt;code&gt;extensions.objectFormat&lt;/code&gt;), or &lt;code&gt;sha1&lt;/code&gt; if no value is set or outside a repository.</source>
          <target state="translated">Specify the given object format (hash algorithm) for the pack. The valid values are &lt;code&gt;sha1&lt;/code&gt; and (if enabled) &lt;code&gt;sha256&lt;/code&gt; . The default is the algorithm for the current repository (set by &lt;code&gt;extensions.objectFormat&lt;/code&gt; ), or &lt;code&gt;sha1&lt;/code&gt; if no value is set or outside a repository.</target>
        </trans-unit>
        <trans-unit id="14a57f9547f120982212f828efa3a309472cc768" translate="yes" xml:space="preserve">
          <source>Specify the given object format (hash algorithm) for the repository. The valid values are &lt;code&gt;sha1&lt;/code&gt; and (if enabled) &lt;code&gt;sha256&lt;/code&gt;. &lt;code&gt;sha1&lt;/code&gt; is the default.</source>
          <target state="translated">Specify the given object format (hash algorithm) for the repository. The valid values are &lt;code&gt;sha1&lt;/code&gt; and (if enabled) &lt;code&gt;sha256&lt;/code&gt; . &lt;code&gt;sha1&lt;/code&gt; is the default.</target>
        </trans-unit>
        <trans-unit id="642e4180256fc24e29fea6cad40cadddb83843bb" translate="yes" xml:space="preserve">
          <source>Specify the hash algorithm to use. The acceptable values are &lt;code&gt;sha1&lt;/code&gt; and &lt;code&gt;sha256&lt;/code&gt;. If not specified, &lt;code&gt;sha1&lt;/code&gt; is assumed. It is an error to specify this key unless &lt;code&gt;core.repositoryFormatVersion&lt;/code&gt; is 1.</source>
          <target state="translated">Specify the hash algorithm to use. The acceptable values are &lt;code&gt;sha1&lt;/code&gt; and &lt;code&gt;sha256&lt;/code&gt; . If not specified, &lt;code&gt;sha1&lt;/code&gt; is assumed. It is an error to specify this key unless &lt;code&gt;core.repositoryFormatVersion&lt;/code&gt; is 1.</target>
        </trans-unit>
        <trans-unit id="e05f34f2b12543d24deddf183d7f5563e4746b8d" translate="yes" xml:space="preserve">
          <source>Specify the initial subject of the email thread. Only necessary if --compose is also set. If --compose is not set, this will be prompted for.</source>
          <target state="translated">이메일 스레드의 초기 제목을 지정하십시오. --compose도 설정 한 경우에만 필요합니다. --compose가 설정되어 있지 않으면 프롬프트가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7f0e894272a77fe6a04290fbdb329a63eb87bf76" translate="yes" xml:space="preserve">
          <source>Specify the layout when list items in &lt;code&gt;git clean -i&lt;/code&gt;, which always shows files and directories in columns. See &lt;code&gt;column.ui&lt;/code&gt; for details.</source>
          <target state="translated">&lt;code&gt;git clean -i&lt;/code&gt; 에 목록 항목이있을 때 레이아웃을 지정하십시오. 항상 파일과 디렉토리를 열로 표시합니다. 자세한 내용은 &lt;code&gt;column.ui&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f7208179bdf36d6bc3e9b1d1f4f91288e1356b3f" translate="yes" xml:space="preserve">
          <source>Specify the location of the CVS checkout to use for the export. This option does not require GIT_DIR to be set before execution if the current directory is within a Git repository. The default is the value of &lt;code&gt;cvsexportcommit.cvsdir&lt;/code&gt;.</source>
          <target state="translated">내보내기에 사용할 CVS 체크 아웃 위치를 지정하십시오. 현재 디렉토리가 Git 저장소 내에있는 경우이 옵션을 실행하기 전에 GIT_DIR을 설정할 필요가 없습니다. 기본값은 &lt;code&gt;cvsexportcommit.cvsdir&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="4c1271576d0edb7f1f0d6c8d0d3f48964a9bd30e" translate="yes" xml:space="preserve">
          <source>Specify the most recent revision to keep. All later revisions are discarded.</source>
          <target state="translated">유지할 최신 개정판을 지정하십시오. 이후의 모든 개정은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="dbfd748a4216557f92920425eee493e6f587b7d2" translate="yes" xml:space="preserve">
          <source>Specify the name of a CVS checkout using the -w switch or execute it from the root of the CVS working copy. In the latter case GIT_DIR must be defined. See examples below.</source>
          <target state="translated">-w 스위치를 사용하여 CVS 체크 아웃 이름을 지정하거나 CVS 작업 사본의 루트에서 실행하십시오. 후자의 경우 GIT_DIR을 정의해야합니다. 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6f5685351080bbe842e1b77f6e72d7f56e71124e" translate="yes" xml:space="preserve">
          <source>Specify the path where the HTML documentation resides. File system paths and URLs are supported. HTML pages will be prefixed with this path when help is displayed in the &lt;code&gt;web&lt;/code&gt; format. This defaults to the documentation path of your Git installation.</source>
          <target state="translated">HTML 문서가있는 경로를 지정하십시오. 파일 시스템 경로 및 URL이 지원됩니다. &lt;code&gt;web&lt;/code&gt; 형식으로 도움말이 표시되면 HTML 페이지 앞에이 경로가 접두어로 표시됩니다 . 기본적으로 Git 설치의 문서 경로입니다.</target>
        </trans-unit>
        <trans-unit id="3939c032cc21518f83cfc7e855a79944401164b0" translate="yes" xml:space="preserve">
          <source>Specify the pathname of a file to use as the template for new commit messages.</source>
          <target state="translated">새 커밋 메시지의 템플리트로 사용할 파일의 경로 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="626310e55266a25c38521d0786f942652add8252" translate="yes" xml:space="preserve">
          <source>Specify the primary recipient of the emails generated. Generally, this will be the upstream maintainer of the project involved. Default is the value of the &lt;code&gt;sendemail.to&lt;/code&gt; configuration value; if that is unspecified, and --to-cmd is not specified, this will be prompted for.</source>
          <target state="translated">생성 된 이메일의 기본 수신자를 지정하십시오. 일반적으로 이것은 관련된 프로젝트의 업스트림 관리자가됩니다. 기본값은 &lt;code&gt;sendemail.to&lt;/code&gt; 구성 값입니다. 지정하지 않고 --to-cmd를 지정하지 않으면 프롬프트가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="904cbddb8fe90053f040a40b660f937c8ee221c5" translate="yes" xml:space="preserve">
          <source>Specify the program that will be used to browse your working repository in gitweb. See &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;.</source>
          <target state="translated">gitweb에서 작업 저장소를 탐색하는 데 사용될 프로그램을 지정하십시오. &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="87648a4a4b9f3684c45dea895b93d3728e0b89f7" translate="yes" xml:space="preserve">
          <source>Specify the programs that may be used to display help in the &lt;code&gt;man&lt;/code&gt; format. See &lt;a href=&quot;git-help&quot;&gt;git-help[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;man&lt;/code&gt; 형식으로 도움말을 표시하는 데 사용할 수있는 프로그램을 지정하십시오 . &lt;a href=&quot;git-help&quot;&gt;git-help [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c051775f78daae77408669a949bcd688ddbd949c" translate="yes" xml:space="preserve">
          <source>Specify the restore location. If neither option is specified, by default the working tree is restored. Specifying &lt;code&gt;--staged&lt;/code&gt; will only restore the index. Specifying both restores both.</source>
          <target state="translated">복원 위치를 지정하십시오. 옵션을 지정하지 않으면 기본적으로 작업 트리가 복원됩니다. &lt;code&gt;--staged&lt;/code&gt; 를 지정 하면 인덱스 만 복원됩니다. 둘 다 지정하면 둘 다 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="95b7f682630cddb98a68355ef07c41860159997c" translate="yes" xml:space="preserve">
          <source>Specify the sender of the emails. If not specified on the command line, the value of the &lt;code&gt;sendemail.from&lt;/code&gt; configuration option is used. If neither the command-line option nor &lt;code&gt;sendemail.from&lt;/code&gt; are set, then the user will be prompted for the value. The default for the prompt will be the value of GIT_AUTHOR_IDENT, or GIT_COMMITTER_IDENT if that is not set, as returned by &quot;git var -l&quot;.</source>
          <target state="translated">이메일 발신자를 지정하십시오. 명령 행에 지정되지 않은 경우 &lt;code&gt;sendemail.from&lt;/code&gt; 구성 옵션 의 값 이 사용됩니다. 명령 줄 옵션이나 &lt;code&gt;sendemail.from&lt;/code&gt; 을 설정 하지 않으면 값을 입력하라는 메시지가 표시됩니다. 프롬프트의 기본값은 &quot;git var -l&quot;에 의해 리턴되는 GIT_AUTHOR_IDENT의 값이거나 설정되지 않은 경우 GIT_COMMITTER_IDENT입니다.</target>
        </trans-unit>
        <trans-unit id="8cba2f98ceccc0dae91e3c30287bb75513f4e951" translate="yes" xml:space="preserve">
          <source>Specify the style in which conflicted hunks are written out to working tree files upon merge. The default is &quot;merge&quot;, which shows a &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; conflict marker, changes made by one side, a &lt;code&gt;=======&lt;/code&gt; marker, changes made by the other side, and then a &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; marker. An alternate style, &quot;diff3&quot;, adds a &lt;code&gt;|||||||&lt;/code&gt; marker and the original text before the &lt;code&gt;=======&lt;/code&gt; marker.</source>
          <target state="translated">병합시 충돌하는 덩어리가 작업 트리 파일에 기록되는 스타일을 지정하십시오. 기본값은 &quot;병합&quot;으로, &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; 충돌 마커, 한 쪽의 변경 사항, &lt;code&gt;=======&lt;/code&gt; 마커, 다른 쪽의 변경 사항, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 마커. 대체 스타일 &quot;diff3&quot;은 &lt;code&gt;|||||||&lt;/code&gt; 마커와 &lt;code&gt;=======&lt;/code&gt; 마커 앞의 원본 텍스트 .</target>
        </trans-unit>
        <trans-unit id="d1c5be6270e8c898e52c9ccc68e940ca06ec404b" translate="yes" xml:space="preserve">
          <source>Specify the system that is used for large (binary) files. Please note that large file systems do not support the &lt;code&gt;git p4 submit&lt;/code&gt; command. Only Git LFS is implemented right now (see &lt;a href=&quot;https://git-lfs.github.com/&quot;&gt;https://git-lfs.github.com/&lt;/a&gt; for more information). Download and install the Git LFS command line extension to use this option and configure it like this:</source>
          <target state="translated">큰 (이진) 파일에 사용되는 시스템을 지정하십시오. 큰 파일 시스템은 &lt;code&gt;git p4 submit&lt;/code&gt; 명령을 지원하지 않습니다 . 현재 Git LFS 만 구현되어 있습니다 ( 자세한 내용 은 &lt;a href=&quot;https://git-lfs.github.com/&quot;&gt;https://git-lfs.github.com/&lt;/a&gt; 참조 ). 이 옵션을 사용하려면 Git LFS 명령 행 확장을 다운로드하여 설치하고 다음과 같이 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="d0eef78fea38d4df295115dcb10e8e7ee7e56973" translate="yes" xml:space="preserve">
          <source>Specify the terminal width. By default &lt;code&gt;git column&lt;/code&gt; will detect the terminal width, or fall back to 80 if it is unable to do so.</source>
          <target state="translated">터미널 너비를 지정하십시오. 기본적으로 &lt;code&gt;git column&lt;/code&gt; 은 터미널 너비를 감지하거나, 그렇지 않으면 80 으로 줄어 듭니다 .</target>
        </trans-unit>
        <trans-unit id="724bb2755b4bad5b8b472dcd4850810c5212797c" translate="yes" xml:space="preserve">
          <source>Specify the transfer encoding to be used to send the message over SMTP. 7bit will fail upon encountering a non-ASCII message. quoted-printable can be useful when the repository contains files that contain carriage returns, but makes the raw patch email file (as saved from a MUA) much harder to inspect manually. base64 is even more fool proof, but also even more opaque. auto will use 8bit when possible, and quoted-printable otherwise.</source>
          <target state="translated">SMTP를 통해 메시지를 보내는 데 사용할 전송 인코딩을 지정하십시오. 비 ASCII 메시지가 표시되면 7 비트가 실패합니다. quoted-printable은 저장소에 캐리지 리턴이 포함 된 파일이 포함되어 있지만 MUA에서 저장된 원시 패치 이메일 파일을 수동으로 검사하기가 훨씬 더 어려울 때 유용 할 수 있습니다. base64는 더 어리석은 증거이지만 더 불투명합니다. auto는 가능한 경우 8 비트를 사용하고 그렇지 않으면 인용 인쇄 가능합니다.</target>
        </trans-unit>
        <trans-unit id="9612f0c17aac603d9a46ca6cb5d976f3bf4c5bf3" translate="yes" xml:space="preserve">
          <source>Specify the type (default: &quot;blob&quot;).</source>
          <target state="translated">유형을 지정하십시오 (기본값 : &quot;blob&quot;).</target>
        </trans-unit>
        <trans-unit id="13769f1d436d268baed7051a7c066221785b088a" translate="yes" xml:space="preserve">
          <source>Specify the type of dates the frontend will supply to fast-import within &lt;code&gt;author&lt;/code&gt;, &lt;code&gt;committer&lt;/code&gt; and &lt;code&gt;tagger&lt;/code&gt; commands. See &amp;ldquo;Date Formats&amp;rdquo; below for details about which formats are supported, and their syntax.</source>
          <target state="translated">프론트 엔드 내에서 빠르게 수입에 알려 주어야합니다 날짜의 유형을 지정 &lt;code&gt;author&lt;/code&gt; , &lt;code&gt;committer&lt;/code&gt; 와 &lt;code&gt;tagger&lt;/code&gt; 명령을. 지원되는 형식 및 구문에 대한 자세한 내용은 아래의 &quot;날짜 형식&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="19ebff060f03d17e125a48bf86da29f25cd1bf35" translate="yes" xml:space="preserve">
          <source>Specify the version with which new index files should be initialized. This does not affect existing repositories. If &lt;code&gt;feature.manyFiles&lt;/code&gt; is enabled, then the default is 4.</source>
          <target state="translated">새 색인 파일을 초기화 할 버전을 지정하십시오. 기존 리포지토리에는 영향을 미치지 않습니다. &lt;code&gt;feature.manyFiles&lt;/code&gt; 가 사용 가능한 경우 기본값은 4입니다.</target>
        </trans-unit>
        <trans-unit id="1dcaca1644c579ca7480d7fe912a3d5f89533d59" translate="yes" xml:space="preserve">
          <source>Specify what action will be performed when there is already at least one trailer with the same &amp;lt;token&amp;gt; in the message. A setting provided with &lt;code&gt;--if-exists&lt;/code&gt; overrides all configuration variables and applies to all &lt;code&gt;--trailer&lt;/code&gt; options until the next occurrence of &lt;code&gt;--if-exists&lt;/code&gt; or &lt;code&gt;--no-if-exists&lt;/code&gt;. Possible actions are &lt;code&gt;addIfDifferent&lt;/code&gt;, &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt;, &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt; and &lt;code&gt;doNothing&lt;/code&gt;.</source>
          <target state="translated">메시지에 &amp;lt;토큰&amp;gt;이 같은 트레일러가 이미 하나 이상있을 때 수행 할 작업을 지정하십시오. &lt;code&gt;--trailer&lt;/code&gt; &lt;code&gt;--if-exists&lt;/code&gt; 와 함께 제공되는 설정 은 모든 구성 변수를 무시 하고 다음 번 --if &lt;code&gt;--if-exists&lt;/code&gt; 또는 &lt;code&gt;--no-if-exists&lt;/code&gt; 가 나타날 때까지 모든 --trailer 옵션에 적용됩니다 . 가능한 조치는 &lt;code&gt;addIfDifferent&lt;/code&gt; , &lt;code&gt;addIfDifferentNeighbor&lt;/code&gt; , &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;replace&lt;/code&gt; 및 &lt;code&gt;doNothing&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0811642f4a0657e779f7ae4b567538044cd6208f" translate="yes" xml:space="preserve">
          <source>Specify what action will be performed when there is no other trailer with the same &amp;lt;token&amp;gt; in the message. A setting provided with &lt;code&gt;--if-missing&lt;/code&gt; overrides all configuration variables and applies to all &lt;code&gt;--trailer&lt;/code&gt; options until the next occurrence of &lt;code&gt;--if-missing&lt;/code&gt; or &lt;code&gt;--no-if-missing&lt;/code&gt;. Possible actions are &lt;code&gt;doNothing&lt;/code&gt; or &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">메시지에 &amp;lt;토큰&amp;gt;이 같은 다른 트레일러가 없을 때 수행 할 작업을 지정하십시오. &lt;code&gt;--trailer&lt;/code&gt; &lt;code&gt;--if-missing&lt;/code&gt; 과 함께 제공되는 설정 은 모든 구성 변수를 무시 하고 다음 번 --if &lt;code&gt;--if-missing&lt;/code&gt; 또는 &lt;code&gt;--no-if-missing&lt;/code&gt; 이 나타날 때까지 모든 --trailer 옵션에 적용됩니다 . 가능한 조치는 &lt;code&gt;doNothing&lt;/code&gt; 또는 &lt;code&gt;add&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4d686969af43bc9772a0a2bdde0f0d6918dfd1d4" translate="yes" xml:space="preserve">
          <source>Specify what destination ref to update with what source object. The format of a &amp;lt;refspec&amp;gt; parameter is an optional plus &lt;code&gt;+&lt;/code&gt;, followed by the source object &amp;lt;src&amp;gt;, followed by a colon &lt;code&gt;:&lt;/code&gt;, followed by the destination ref &amp;lt;dst&amp;gt;.</source>
          <target state="translated">어떤 소스 오브젝트로 업데이트 할 대상 참조를 지정하십시오. &amp;lt;refspec&amp;gt; 매개 변수의 형식은 선택적인 plus &lt;code&gt;+&lt;/code&gt; , 소스 오브젝트 &amp;lt;src&amp;gt;, 콜론 &lt;code&gt;:&lt;/code&gt; , 목적지 ref &amp;lt;dst&amp;gt;입니다.</target>
        </trans-unit>
        <trans-unit id="6138b51fead99efbf1d6930137f2b387251ef604" translate="yes" xml:space="preserve">
          <source>Specify where all new trailers will be added. A setting provided with &lt;code&gt;--where&lt;/code&gt; overrides all configuration variables and applies to all &lt;code&gt;--trailer&lt;/code&gt; options until the next occurrence of &lt;code&gt;--where&lt;/code&gt; or &lt;code&gt;--no-where&lt;/code&gt;. Possible values are &lt;code&gt;after&lt;/code&gt;, &lt;code&gt;before&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt; or &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="translated">모든 새 예고편을 추가 할 위치를 지정하십시오. 제공된 설정 &lt;code&gt;--where&lt;/code&gt; 는 모든 구성 변수를 무시하고 모든 적용 &lt;code&gt;--trailer&lt;/code&gt; 다음 발생까지 옵션 &lt;code&gt;--where&lt;/code&gt; 또는 &lt;code&gt;--no-where&lt;/code&gt; . 가능한 값은 &lt;code&gt;after&lt;/code&gt; , &lt;code&gt;before&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; 또는 &lt;code&gt;start&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9446eb9819e4ea522bac17e494630aff8d54bebb" translate="yes" xml:space="preserve">
          <source>Specify whether supported commands should output in columns. This variable consists of a list of tokens separated by spaces or commas:</source>
          <target state="translated">지원되는 명령이 열로 출력되어야하는지 여부를 지정하십시오. 이 변수는 공백 또는 쉼표로 구분 된 토큰 목록으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c44825f076cf0385d99447ca6f9388f9e5d821d6" translate="yes" xml:space="preserve">
          <source>Specify whether to output branch listing in &lt;code&gt;git branch&lt;/code&gt; in columns. See &lt;code&gt;column.ui&lt;/code&gt; for details.</source>
          <target state="translated">&lt;code&gt;git branch&lt;/code&gt; 의 분기 목록 을 열로 출력할지 여부를 지정하십시오 . 자세한 내용은 &lt;code&gt;column.ui&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eb8ddb4258375ad9322849684e1d07ab6e005bcd" translate="yes" xml:space="preserve">
          <source>Specify whether to output tag listing in &lt;code&gt;git tag&lt;/code&gt; in columns. See &lt;code&gt;column.ui&lt;/code&gt; for details.</source>
          <target state="translated">태그 목록을 &lt;code&gt;git tag&lt;/code&gt; 로 열로 출력할지 여부를 지정하십시오 . 자세한 내용은 &lt;code&gt;column.ui&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7607c69174b01d1bb15ae17f25fe8a2d96f9d58f" translate="yes" xml:space="preserve">
          <source>Specify whether to output untracked files in &lt;code&gt;git status&lt;/code&gt; in columns. See &lt;code&gt;column.ui&lt;/code&gt; for details.</source>
          <target state="translated">추적되지 않은 파일을 &lt;code&gt;git status&lt;/code&gt; 에서 열로 출력할지 여부를 지정하십시오 . 자세한 내용은 &lt;code&gt;column.ui&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="339267ba6eec9ae3e501f35791863aebe871608d" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;--no-force-if-includes&lt;/code&gt; disables this behavior.</source>
          <target state="translated">&lt;code&gt;--no-force-if-includes&lt;/code&gt; 를 지정 하면이 동작이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="b984e35657451690beb2903dd3dd6390cb372f55" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;--no-symlinks&lt;/code&gt; instructs &lt;code&gt;git difftool&lt;/code&gt; to create copies instead. &lt;code&gt;--no-symlinks&lt;/code&gt; is the default on Windows.</source>
          <target state="translated">&lt;code&gt;--no-symlinks&lt;/code&gt; 를 지정 하면 &lt;code&gt;git difftool&lt;/code&gt; 이 대신 사본을 작성 하도록 지시 합니다. &lt;code&gt;--no-symlinks&lt;/code&gt; 는 Windows의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="3b6b4914f3cbc4ad3df641c0c4177b0ed1427ac9" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;-b&lt;/code&gt; causes a new branch to be created as if &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; were called and then checked out. In this case you can use the &lt;code&gt;--track&lt;/code&gt; or &lt;code&gt;--no-track&lt;/code&gt; options, which will be passed to &lt;code&gt;git branch&lt;/code&gt;. As a convenience, &lt;code&gt;--track&lt;/code&gt; without &lt;code&gt;-b&lt;/code&gt; implies branch creation; see the description of &lt;code&gt;--track&lt;/code&gt; below.</source>
          <target state="translated">&lt;code&gt;-b&lt;/code&gt; 를 지정 하면 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; 이 호출 된 다음 체크 아웃 된 것처럼 새 분기가 작성됩니다 . 이 경우 &lt;code&gt;--track&lt;/code&gt; 또는 &lt;code&gt;--no-track&lt;/code&gt; 옵션을 사용할 수 있습니다.이 옵션은 &lt;code&gt;git branch&lt;/code&gt; 로 전달됩니다 . 편의상, &lt;code&gt;--track&lt;/code&gt; 없이 &lt;code&gt;-b&lt;/code&gt; 이 지점 생성을 의미한다; 아래 &lt;code&gt;--track&lt;/code&gt; 에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d1224dfe57ea23830be77ce6389d9ea1f14e370" translate="yes" xml:space="preserve">
          <source>Specifying ranges</source>
          <target state="translated">범위 지정</target>
        </trans-unit>
        <trans-unit id="c7c8ec2e47baa0d09987a0c4d6001b20abaaf2b4" translate="yes" xml:space="preserve">
          <source>Specifying references</source>
          <target state="translated">참조 지정</target>
        </trans-unit>
        <trans-unit id="393f3ea7b8cd86c4b234c1534e51343677169802" translate="yes" xml:space="preserve">
          <source>Specifying revisions</source>
          <target state="translated">개정판 지정</target>
        </trans-unit>
        <trans-unit id="313d53ccb2201ad1fa56898f5e4fcf52a12b8cf8" translate="yes" xml:space="preserve">
          <source>Specifying revisions and ranges for Git</source>
          <target state="translated">Specifying revisions and ranges for Git</target>
        </trans-unit>
        <trans-unit id="3c37f7a18e7a3b3fd20a0b124dbe1485c84e7ed4" translate="yes" xml:space="preserve">
          <source>Specifying several revisions means the set of commits reachable from any of the given commits.</source>
          <target state="translated">Specifying several revisions means the set of commits reachable from any of the given commits.</target>
        </trans-unit>
        <trans-unit id="b0e60ddbfcfcb7ed6ee3dbb9222a892aaa26a36d" translate="yes" xml:space="preserve">
          <source>Specifying the location of the &quot;.git&quot; directory using this option (or &lt;code&gt;GIT_DIR&lt;/code&gt; environment variable) turns off the repository discovery that tries to find a directory with &quot;.git&quot; subdirectory (which is how the repository and the top-level of the working tree are discovered), and tells Git that you are at the top level of the working tree. If you are not at the top-level directory of the working tree, you should tell Git where the top-level of the working tree is, with the &lt;code&gt;--work-tree=&amp;lt;path&amp;gt;&lt;/code&gt; option (or &lt;code&gt;GIT_WORK_TREE&lt;/code&gt; environment variable)</source>
          <target state="translated">Specifying the location of the &quot;.git&quot; directory using this option (or &lt;code&gt;GIT_DIR&lt;/code&gt; environment variable) turns off the repository discovery that tries to find a directory with &quot;.git&quot; subdirectory (which is how the repository and the top-level of the working tree are discovered), and tells Git that you are at the top level of the working tree. If you are not at the top-level directory of the working tree, you should tell Git where the top-level of the working tree is, with the &lt;code&gt;--work-tree=&amp;lt;path&amp;gt;&lt;/code&gt; option (or &lt;code&gt;GIT_WORK_TREE&lt;/code&gt; environment variable)</target>
        </trans-unit>
        <trans-unit id="c12054d536cbd9889e1a4db4d75b48d8a7f03cd2" translate="yes" xml:space="preserve">
          <source>Specifying the refs</source>
          <target state="translated">심판 지정</target>
        </trans-unit>
        <trans-unit id="31f2abfdb1a3e7bab64495f843d089d388ea45e0" translate="yes" xml:space="preserve">
          <source>Spend extra cycles to find renames, copies and complete rewrites (very expensive).</source>
          <target state="translated">추가주기를 사용하여 이름 변경, 복사 및 전체 재 작성을 찾을 수 있습니다 (매우 비쌉니다).</target>
        </trans-unit>
        <trans-unit id="6b695c34f0798ffd5026fe42cf041af8a841d861" translate="yes" xml:space="preserve">
          <source>Spend extra time to make sure the smallest possible diff is produced.</source>
          <target state="translated">가장 작은 diff가 만들어 지도록 여분의 시간을 보내십시오.</target>
        </trans-unit>
        <trans-unit id="8622c4dc8f748203e018cc0d2ec4e20b07c9830d" translate="yes" xml:space="preserve">
          <source>Split a commit apart into a sequence of commits</source>
          <target state="translated">커밋을 일련의 커밋으로 분리</target>
        </trans-unit>
        <trans-unit id="9da7a78d6cd0199fb3cad874edd1ba683b830e12" translate="yes" xml:space="preserve">
          <source>Split index</source>
          <target state="translated">분할 인덱스</target>
        </trans-unit>
        <trans-unit id="704e5487b89b9b30fcd9e576ab8763e642a1b938" translate="yes" xml:space="preserve">
          <source>Splits a mbox file or a Maildir into a list of files: &quot;0001&quot; &quot;0002&quot; .. in the specified directory so you can process them further from there.</source>
          <target state="translated">mbox 파일 또는 Maildir을 지정된 디렉토리에있는 파일 목록 &quot;0001&quot; &quot;0002&quot;..로 분할하여 거기서 더 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="30bc5e98fc4346f828d1d387cd6e1c89bab7df56" translate="yes" xml:space="preserve">
          <source>Splits mail messages in a mailbox into commit log message, authorship information and patches, and applies them to the current branch.</source>
          <target state="translated">사서함의 메일 메시지를 커밋 로그 메시지, 제작 정보 및 패치로 분할하여 현재 분기에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="05a6d55bcdcfd4539a8e45cc0dd3c2f28f1895ad" translate="yes" xml:space="preserve">
          <source>Splitting a (logically single) project into multiple repositories and tying them back together. This can be used to overcome current limitations of Git&amp;rsquo;s implementation to have finer grained access:</source>
          <target state="translated">(논리적으로 단일 한) 프로젝트를 여러 저장소로 나누고 다시 묶습니다. 이것은 Git 구현의 현재 제한을 극복하여 세분화 된 액세스를 갖도록 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dca5d29240b446b8bdd6f26fb0b4e46cb995769f" translate="yes" xml:space="preserve">
          <source>Splitting commits</source>
          <target state="translated">커밋 분할</target>
        </trans-unit>
        <trans-unit id="ab83ac1fcfed8f50260b11e517c47e9b533419b5" translate="yes" xml:space="preserve">
          <source>Splitting the CVS log into patch sets is done by &lt;code&gt;cvsps&lt;/code&gt;. At least version 2.1 is required.</source>
          <target state="translated">CVS 로그를 패치 세트로 분할하는 것은 &lt;code&gt;cvsps&lt;/code&gt; 에 의해 수행됩니다 . 버전 2.1 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a74a609811ea3b4041281496e2aa5c500ba6558b" translate="yes" xml:space="preserve">
          <source>Sq-quote</source>
          <target state="translated">Sq-quote</target>
        </trans-unit>
        <trans-unit id="d3e10219341e654fff6647b0dadeaeaf0534cae6" translate="yes" xml:space="preserve">
          <source>Squelch the progress indicator.</source>
          <target state="translated">진행 표시기를 que 치십시오.</target>
        </trans-unit>
        <trans-unit id="56175f21751e04201e148f2612c700747850548a" translate="yes" xml:space="preserve">
          <source>Start &lt;code&gt;git gui&lt;/code&gt; and arrange to make exactly one commit before exiting and returning to the shell. The interface is limited to only commit actions, slightly reducing the application&amp;rsquo;s startup time and simplifying the menubar.</source>
          <target state="translated">&lt;code&gt;git gui&lt;/code&gt; 를 시작 하고 종료하고 쉘로 돌아 가기 전에 정확히 하나의 커밋을 준비 하십시오 . 인터페이스는 커밋 작업만으로 제한되어 응용 프로그램의 시작 시간을 약간 줄이고 메뉴 표시 줄을 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="1ad6edca0ad31761798d28bd8f2bcba01ec6ebde" translate="yes" xml:space="preserve">
          <source>Start a blame viewer on the specified file on the given version (or working directory if not specified).</source>
          <target state="translated">지정된 버전 (또는 지정되지 않은 경우 작업 디렉토리)의 지정된 파일에서 Blame Viewer를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="27818282f52d064df23dffafcd6a743ee7870fc8" translate="yes" xml:space="preserve">
          <source>Start a new Git repository for an existing code base</source>
          <target state="translated">기존 코드 기반을위한 새로운 Git 리포지토리 시작</target>
        </trans-unit>
        <trans-unit id="dbad6a143691392b17e55eedf5d0cc7e518343d6" translate="yes" xml:space="preserve">
          <source>Start a transaction. In contrast to a non-transactional session, a transaction will automatically abort if the session ends without an explicit commit.</source>
          <target state="translated">Start a transaction. In contrast to a non-transactional session, a transaction will automatically abort if the session ends without an explicit commit.</target>
        </trans-unit>
        <trans-unit id="6c5dfb3420a1367f99c30e1b35e7bdbb889d1205" translate="yes" xml:space="preserve">
          <source>Start a transaction. In contrast to a non-transactional session, a transaction will automatically abort if the session ends without an explicit commit. This command may create a new empty transaction when the current one has been committed or aborted already.</source>
          <target state="translated">거래를 시작하십시오. 트랜잭션이 아닌 세션과 달리 명시 적 커밋없이 세션이 종료되면 트랜잭션이 자동으로 중단됩니다. 이 명령은 현재 트랜잭션이 이미 커밋되거나 중단되었을 때 새로운 빈 트랜잭션을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="749535e22d531edd1c6d9e666c57e169bc2a2908" translate="yes" xml:space="preserve">
          <source>Start a tree browser showing all files in the specified commit. Files selected through the browser are opened in the blame viewer.</source>
          <target state="translated">지정된 커밋의 모든 파일을 보여주는 트리 브라우저를 시작하십시오. 브라우저를 통해 선택한 파일이 Blame Viewer에서 열립니다.</target>
        </trans-unit>
        <trans-unit id="4f65c13509b4c270214524b3ab095bad926fc4e3" translate="yes" xml:space="preserve">
          <source>Start an interactive rebase with &lt;code&gt;git rebase -i &amp;lt;commit&amp;gt;^&lt;/code&gt;, where &amp;lt;commit&amp;gt; is the commit you want to split. In fact, any commit range will do, as long as it contains that commit.</source>
          <target state="translated">&lt;code&gt;git rebase -i &amp;lt;commit&amp;gt;^&lt;/code&gt; 을 사용하여 대화식 리베이스를 시작하십시오. 여기서 &amp;lt;commit&amp;gt;은 분할하려는 커밋입니다. 실제로, 해당 커밋이 포함되어있는 한 모든 커밋 범위가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e89944344f3db8073a18706746155c852e5164e1" translate="yes" xml:space="preserve">
          <source>Start cleaning files and directories, and then quit.</source>
          <target state="translated">파일 및 디렉토리 정리를 시작한 다음 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="b87ef51ca99e7074691b94843e801ff9544539ca" translate="yes" xml:space="preserve">
          <source>Start development from a known tag</source>
          <target state="translated">알려진 태그에서 개발 시작</target>
        </trans-unit>
        <trans-unit id="57f8f31bd16af3371648ce77ae5076e70d2a7e21" translate="yes" xml:space="preserve">
          <source>Start it with the last commit you want to retain as-is:</source>
          <target state="translated">그대로 유지하려는 마지막 커밋으로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="2deb883b26612605cc58ed80bbd657e3f5419b69" translate="yes" xml:space="preserve">
          <source>Start numbering the patches at &amp;lt;n&amp;gt; instead of 1.</source>
          <target state="translated">1 대신 &amp;lt;n&amp;gt;에서 패치 번호를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="f25f51b92f6dabcbe2c2bbe2f01c2d471018dd10" translate="yes" xml:space="preserve">
          <source>Start off with just creating any random files that you want to maintain in your Git repository. We&amp;rsquo;ll start off with a few bad examples, just to get a feel for how this works:</source>
          <target state="translated">Git 리포지토리에서 유지하려는 임의의 파일을 만드는 것부터 시작하십시오. 우리는 이것이 어떻게 작동하는지에 대한 느낌을 얻기 위해 몇 가지 나쁜 예를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="b174f856568aac4ebedeecc136cb3af25d3888bc" translate="yes" xml:space="preserve">
          <source>Start running maintenance on the current repository. This performs the same config updates as the &lt;code&gt;register&lt;/code&gt; subcommand, then updates the background scheduler to run &lt;code&gt;git maintenance run --scheduled&lt;/code&gt; on an hourly basis.</source>
          <target state="translated">현재 저장소에서 유지 관리 실행을 시작합니다. 이것은 &lt;code&gt;register&lt;/code&gt; 하위 명령 과 동일한 구성 업데이트를 수행 한 다음 백그라운드 스케줄러를 업데이트하여 시간 단위로 &lt;code&gt;git maintenance run --scheduled&lt;/code&gt; 를 실행 합니다.</target>
        </trans-unit>
        <trans-unit id="93ea699c6796ebb7b82a3a5927dc702e8f1a7316" translate="yes" xml:space="preserve">
          <source>Start the httpd instance and exit. Regenerate configuration files as necessary for spawning a new instance.</source>
          <target state="translated">httpd 인스턴스를 시작하고 종료하십시오. 새 인스턴스를 생성하는 데 필요한 구성 파일을 재생성하십시오.</target>
        </trans-unit>
        <trans-unit id="4e8cde71c6f29e3b4dc0142edc8a7bdf1a0bc89b" translate="yes" xml:space="preserve">
          <source>Start the stream with a &lt;code&gt;feature done&lt;/code&gt; stanza, and terminate it with a &lt;code&gt;done&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;feature done&lt;/code&gt; 스탠자로 스트림을 시작하고 &lt;code&gt;done&lt;/code&gt; 명령으로 종료하십시오 .</target>
        </trans-unit>
        <trans-unit id="96e592387dc94e730df0ef669b5a78ed012d4c94" translate="yes" xml:space="preserve">
          <source>Starting a bisection</source>
          <target state="translated">이분법 시작</target>
        </trans-unit>
        <trans-unit id="b8f1956c80187223247d01b968f642bf0007a014" translate="yes" xml:space="preserve">
          <source>Starting point at which to create the new commits. If the --onto option is not specified, the starting point is &amp;lt;upstream&amp;gt;. May be any valid commit, and not just an existing branch name.</source>
          <target state="translated">새로운 커밋을 생성하는 시작점. --onto 옵션을 지정하지 않으면 시작 지점은 &amp;lt;업스트림&amp;gt;입니다. 기존 브랜치 이름뿐만 아니라 유효한 커밋 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2a5514cb8b0c290a6aeca31b2e191aff35672b1" translate="yes" xml:space="preserve">
          <source>Stash the changes in a dirty working directory away</source>
          <target state="translated">더티 작업 디렉토리에 변경 사항을 보관하십시오.</target>
        </trans-unit>
        <trans-unit id="9b5a6df7ffb5f85d09cbb9082f2a407aa81ca866" translate="yes" xml:space="preserve">
          <source>State directories: The two backends keep their state in different directories under .git/</source>
          <target state="translated">State directories: The two backends keep their state in different directories under .git/</target>
        </trans-unit>
        <trans-unit id="abb935cbc47e1b75159f277e4b22bfc5de7bbee9" translate="yes" xml:space="preserve">
          <source>Static configuration of usernames for a given authentication context.</source>
          <target state="translated">주어진 인증 컨텍스트에 대한 사용자 이름의 정적 구성.</target>
        </trans-unit>
        <trans-unit id="20520ab082263228efd3ab7ffc11e41906666da4" translate="yes" xml:space="preserve">
          <source>Status letters C and R are always followed by a score (denoting the percentage of similarity between the source and target of the move or copy). Status letter M may be followed by a score (denoting the percentage of dissimilarity) for file rewrites.</source>
          <target state="translated">상태 문자 C와 R은 항상 점수 뒤에옵니다 (이동 또는 사본의 소스와 대상 간의 유사성 비율을 나타냄). 상태 문자 M 다음에는 파일 다시 쓰기에 대한 점수 (유사 비율을 나타냄)가 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5910dfc64a273edb8d032604ca6d54bef3bf2f4e" translate="yes" xml:space="preserve">
          <source>Stop the httpd instance and exit. This does not generate any of the configuration files for spawning a new instance, nor does it close the browser.</source>
          <target state="translated">httpd 인스턴스를 중지하고 종료하십시오. 이렇게하면 새 인스턴스를 생성하기위한 구성 파일이 생성되지 않으며 브라우저가 닫히지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12d3bab755f474b20ad13c1ab918e01e5f4eb7c4" translate="yes" xml:space="preserve">
          <source>Stop when a given path disappears from the tree.</source>
          <target state="translated">주어진 경로가 트리에서 사라지면 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="7363904e3ee0fd364e644f2e1b28c12dd383e027" translate="yes" xml:space="preserve">
          <source>Storage format</source>
          <target state="translated">저장 형식</target>
        </trans-unit>
        <trans-unit id="9ff8274c9fcae633894b9e7ab1c37fd6e74f1f7a" translate="yes" xml:space="preserve">
          <source>Store Git commit times in the local time zone instead of UTC. This makes &lt;code&gt;git log&lt;/code&gt; (even without --date=local) show the same times that &lt;code&gt;svn log&lt;/code&gt; would in the local time zone.</source>
          <target state="translated">Git 커밋 시간을 UTC 대신 현지 시간대로 저장하십시오. 이것은 &lt;code&gt;git log&lt;/code&gt; (--date = local이 없어도)가 &lt;code&gt;svn log&lt;/code&gt; 가 현지 시간대 와 동일한 시간을 표시하게합니다 .</target>
        </trans-unit>
        <trans-unit id="c403801561a0441c1d742dd0499050f55d110cd9" translate="yes" xml:space="preserve">
          <source>Store a given stash created via &lt;code&gt;git stash create&lt;/code&gt; (which is a dangling merge commit) in the stash ref, updating the stash reflog. This is intended to be useful for scripts. It is probably not the command you want to use; see &quot;push&quot; above.</source>
          <target state="translated">&lt;code&gt;git stash create&lt;/code&gt; (매달린 병합 커밋)를 통해 생성 된 지정된 숨김을 숨김 참조에 저장하고 숨김 참조를 업데이트합니다. 스크립트에 유용합니다. 사용하려는 명령이 아닐 수도 있습니다. 위의 &quot;푸시&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b41300dc42c243e3949e2ecb7a4c10aea769103e" translate="yes" xml:space="preserve">
          <source>Store credentials indefinitely on disk. See &lt;a href=&quot;git-credential-store&quot;&gt;git-credential-store[1]&lt;/a&gt; for details.</source>
          <target state="translated">자격 증명을 디스크에 무기한 저장합니다. 자세한 내용은 &lt;a href=&quot;git-credential-store&quot;&gt;git-credential-store [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="03384c8a5477964f7bc214ed7cbcde0772bb7755" translate="yes" xml:space="preserve">
          <source>Store the credential, if applicable to the helper.</source>
          <target state="translated">Store the credential, if applicable to the helper.</target>
        </trans-unit>
        <trans-unit id="5597429620f06451a38a8e17b35a345310b01123" translate="yes" xml:space="preserve">
          <source>Store the fetched branch into a local branch before merging into the current branch:</source>
          <target state="translated">현재 브랜치에 병합하기 전에 페치 된 브랜치를 로컬 브랜치에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="687760eb98a14d7d5a6fbbba834cf9ccaaf83ea1" translate="yes" xml:space="preserve">
          <source>Store the files instead of deflating them.</source>
          <target state="translated">수축시키지 말고 파일을 보관하십시오.</target>
        </trans-unit>
        <trans-unit id="1512a579e2c05cbf63724a7c8d50327696297b00" translate="yes" xml:space="preserve">
          <source>Stores a set of &quot;objects&quot;, and an individual &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; is identified by its &lt;a href=&quot;#def_object_name&quot;&gt;object name&lt;/a&gt;. The objects usually live in &lt;code&gt;$GIT_DIR/objects/&lt;/code&gt;.</source>
          <target state="translated">&quot;객체&quot;세트를 저장하고 개별 &lt;a href=&quot;#def_object&quot;&gt;객체&lt;/a&gt; 는 해당 &lt;a href=&quot;#def_object_name&quot;&gt;객체 이름으로&lt;/a&gt; 식별됩니다 . 객체는 보통 &lt;code&gt;$GIT_DIR/objects/&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6349a625008b244d26dbb9000ad7480816812a5" translate="yes" xml:space="preserve">
          <source>Stores shorthands for URL and default refnames for use when interacting with remote repositories via &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; commands. See the REMOTES section in &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; for details. This mechanism is legacy and not likely to be found in modern repositories. This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/remotes&quot; will be used instead.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; , &lt;code&gt;git pull&lt;/code&gt; 및 &lt;code&gt;git push&lt;/code&gt; 명령을 통해 원격 리포지토리와 상호 작용할 때 사용할 URL 및 기본 참조 이름에 대한 속기를 저장 합니다. 자세한 내용은 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 의 REMOTES 섹션 을 참조하십시오. 이 메커니즘은 레거시이며 현대 리포지토리에서는 찾을 수 없습니다. $ GIT_COMMON_DIR이 설정되고 대신 &quot;$ GIT_COMMON_DIR / remotes&quot;가 사용되면이 디렉토리는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="39f2d5fc66110ba4ba0f8069c43a058a9f84529f" translate="yes" xml:space="preserve">
          <source>Storing multiple repositories as namespaces of a single repository avoids storing duplicate copies of the same objects, such as when storing multiple branches of the same source. The alternates mechanism provides similar support for avoiding duplicates, but alternates do not prevent duplication between new objects added to the repositories without ongoing maintenance, while namespaces do.</source>
          <target state="translated">여러 저장소를 단일 저장소의 네임 스페이스로 저장하면 동일한 소스의 여러 분기를 저장할 때와 같이 동일한 오브젝트의 중복 사본을 저장하지 않아도됩니다. 대체 메커니즘은 중복을 피하기위한 유사한 지원을 제공하지만 대체는 유지 보수없이 저장소에 추가 된 새 오브젝트 간의 복제를 막지 않지만 네임 스페이스는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca1c76454e0d7e7718b023221d2b0aad3d2a1aba" translate="yes" xml:space="preserve">
          <source>Stream Comments</source>
          <target state="translated">스트림 댓글</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="5ab8d5b6efb1646dea2e4ea7d3282e3cb65c24cb" translate="yes" xml:space="preserve">
          <source>String to be printed at the beginning of each line.</source>
          <target state="translated">각 줄의 시작 부분에 인쇄 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="382f9b3217a7726b3a52ca62702799f6d5434b48" translate="yes" xml:space="preserve">
          <source>String to be printed at the end of each line, including newline character.</source>
          <target state="translated">줄 바꿈 문자를 포함하여 각 줄의 끝에 인쇄 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ae0208ff14e492381101b38c4426143fc9d98dd6" translate="yes" xml:space="preserve">
          <source>String(s) &lt;code&gt;receive-pack&lt;/code&gt; and &lt;code&gt;upload-pack&lt;/code&gt; use to decide which refs to omit from their initial advertisements. Use more than one definition to specify multiple prefix strings. A ref that is under the hierarchies listed in the value of this variable is excluded, and is hidden when responding to &lt;code&gt;git push&lt;/code&gt; or &lt;code&gt;git
fetch&lt;/code&gt;. See &lt;code&gt;receive.hideRefs&lt;/code&gt; and &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; for program-specific versions of this config.</source>
          <target state="translated">String (s) &lt;code&gt;receive-pack&lt;/code&gt; 및 &lt;code&gt;upload-pack&lt;/code&gt; 은 초기 광고에서 생략 할 참조를 결정하는 데 사용됩니다. 여러 개의 접두사 문자열을 지정하려면 둘 이상의 정의를 사용하십시오. 이 변수의 값에 나열된 계층 구조 아래에있는 참조는 제외되며 &lt;code&gt;git push&lt;/code&gt; 또는 &lt;code&gt;git fetch&lt;/code&gt; 응답하면 숨겨집니다 . 이 구성의 프로그램 별 버전은 &lt;code&gt;receive.hideRefs&lt;/code&gt; 및 &lt;code&gt;uploadpack.hideRefs&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd5fa82aac351e4a1096fc62004ba110d66fe810" translate="yes" xml:space="preserve">
          <source>Strip leading and trailing empty lines, trailing whitespace, commentary and collapse consecutive empty lines.</source>
          <target state="translated">선행 및 후행 빈 줄 제거, 후행 공백, 주석 및 연속적인 빈 줄 축소.</target>
        </trans-unit>
        <trans-unit id="7c8cf84261f17414d41a19324152deb0638ecb13" translate="yes" xml:space="preserve">
          <source>Subcommands</source>
          <target state="translated">Subcommands</target>
        </trans-unit>
        <trans-unit id="2dacf65959849884a011f36f76a04eebea94c5ea" translate="yes" xml:space="preserve">
          <source>Submit</source>
          <target state="translated">Submit</target>
        </trans-unit>
        <trans-unit id="f3de51d87e152838b373a65e626718325c16a058" translate="yes" xml:space="preserve">
          <source>Submit only the specified commit or range of commits, instead of the full list of changes that are in the current Git branch.</source>
          <target state="translated">현재 Git 브랜치에있는 전체 변경 사항 목록 대신 지정된 커밋 또는 커밋 범위 만 제출하십시오.</target>
        </trans-unit>
        <trans-unit id="08c8f65685b697a18634ff4dd66ae0c7b7f8944c" translate="yes" xml:space="preserve">
          <source>Submit options</source>
          <target state="translated">옵션 제출</target>
        </trans-unit>
        <trans-unit id="3e96d88de40c1b4ce507f5624d2a7a2ae94fe14f" translate="yes" xml:space="preserve">
          <source>Submit variables</source>
          <target state="translated">변수 제출</target>
        </trans-unit>
        <trans-unit id="0213e9a40d8de329179170c49c9f0b36b9c8f25d" translate="yes" xml:space="preserve">
          <source>Submit your commits back to p4:</source>
          <target state="translated">커밋을 p4에 다시 제출하십시오.</target>
        </trans-unit>
        <trans-unit id="45b948a665e37752fe7a51975e7be3fc7f05181f" translate="yes" xml:space="preserve">
          <source>Submitting changes from a Git repository back to the p4 repository requires a separate p4 client workspace. This should be specified using the &lt;code&gt;P4CLIENT&lt;/code&gt; environment variable or the Git configuration variable &lt;code&gt;git-p4.client&lt;/code&gt;. The p4 client must exist, but the client root will be created and populated if it does not already exist.</source>
          <target state="translated">Git 저장소에서 p4 저장소로 변경 사항을 다시 제출하려면 별도의 p4 클라이언트 작업 공간이 필요합니다. 이것은 &lt;code&gt;P4CLIENT&lt;/code&gt; 환경 변수 또는 Git 구성 변수 &lt;code&gt;git-p4.client&lt;/code&gt; 를 사용하여 지정해야합니다 . p4 클라이언트가 존재해야하지만 클라이언트 루트가 없으면 클라이언트 루트가 작성되어 채워집니다.</target>
        </trans-unit>
        <trans-unit id="6fdf0bad4a57f28ad8887a6fe4e3d9618491f48f" translate="yes" xml:space="preserve">
          <source>Submitting patches to a project</source>
          <target state="translated">프로젝트에 패치 제출</target>
        </trans-unit>
        <trans-unit id="d2d7b7a6dabf5680ef6fc53443124ea60acd88af" translate="yes" xml:space="preserve">
          <source>Submitting requires a p4 client, which is not in the same location as the Git repository. Patches are applied, one at a time, to this p4 client and submitted from there.</source>
          <target state="translated">제출하려면 p4 클라이언트가 필요하며 Git 저장소와 동일한 위치에 있지 않습니다. 패치는 한 번에 하나씩이 p4 클라이언트에 적용되어 해당 p4 클라이언트에 제출됩니다.</target>
        </trans-unit>
        <trans-unit id="81d7b2b94000dc76db42f2c130ed58771103b34d" translate="yes" xml:space="preserve">
          <source>Submodule Rewriting</source>
          <target state="translated">Submodule Rewriting</target>
        </trans-unit>
        <trans-unit id="e107551e51d7866e29fbfac7f1a9d70e892a1c9c" translate="yes" xml:space="preserve">
          <source>Submodule operations can be configured using the following mechanisms (from highest to lowest precedence):</source>
          <target state="translated">다음과 같은 메커니즘을 사용하여 서브 모듈 작업을 구성 할 수 있습니다 (가장 높은 우선 순위에서 가장 낮은 우선 순위로).</target>
        </trans-unit>
        <trans-unit id="12d390f8025584ad2ceb29d8156199827eb766f2" translate="yes" xml:space="preserve">
          <source>Submodules</source>
          <target state="translated">Submodules</target>
        </trans-unit>
        <trans-unit id="8b3b72a48d6b77673f309811c21a1f34bda69f2a" translate="yes" xml:space="preserve">
          <source>Submodules are initialized and cloned using their default settings. This is equivalent to running &lt;code&gt;git submodule update --init --recursive &amp;lt;pathspec&amp;gt;&lt;/code&gt; immediately after the clone is finished. This option is ignored if the cloned repository does not have a worktree/checkout (i.e. if any of &lt;code&gt;--no-checkout&lt;/code&gt;/&lt;code&gt;-n&lt;/code&gt;, &lt;code&gt;--bare&lt;/code&gt;, or &lt;code&gt;--mirror&lt;/code&gt; is given)</source>
          <target state="translated">하위 모듈은 기본 설정을 사용하여 초기화 및 복제됩니다. 이것은 복제가 완료된 직후 &lt;code&gt;git submodule update --init --recursive &amp;lt;pathspec&amp;gt;&lt;/code&gt; 을 실행하는 것과 같습니다 . 복제 된 저장소에 작업 트리 / 체크 아웃이없는 경우 (예 : &lt;code&gt;--no-checkout&lt;/code&gt; / &lt;code&gt;-n&lt;/code&gt; , &lt;code&gt;--bare&lt;/code&gt; 또는 &lt;code&gt;--mirror&lt;/code&gt; 가 지정된 경우) 이 옵션은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f0558d8aae211aae78435cf5f18fbee56b357b16" translate="yes" xml:space="preserve">
          <source>Submodules can be used for at least two different use cases:</source>
          <target state="translated">서브 모듈은 두 가지 이상의 다른 사용 사례에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a4ac6e80eae220504fcac25436c9a1e818ef8b5" translate="yes" xml:space="preserve">
          <source>Submodules can take the following forms:</source>
          <target state="translated">서브 모듈은 다음과 같은 형식을 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ee6b51df0a5b53ba35723ec36f91cb14154873c" translate="yes" xml:space="preserve">
          <source>Submodules have more state and instead report M the submodule has a different HEAD than recorded in the index m the submodule has modified content ? the submodule has untracked files since modified content or untracked files in a submodule cannot be added via &lt;code&gt;git add&lt;/code&gt; in the superproject to prepare a commit.</source>
          <target state="translated">서브 모듈은 더 많은 상태를 가지고 대신 서브 모듈이 컨텐츠를 수정 한 인덱스에 기록 된 것과 다른 HEAD를 가지고 있다고보고한다. 커밋을 준비하기 위해 수퍼 프로젝트의 &lt;code&gt;git add&lt;/code&gt; 를 통해 서브 모듈에서 수정 된 컨텐츠 또는 추적되지 않은 파일을 추가 할 수 없으므로 서브 모듈에 추적되지 않은 파일이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a0210b026ef5dd9e5a7bf71f7146151a0e187886" translate="yes" xml:space="preserve">
          <source>Subprocess behavior</source>
          <target state="translated">하위 프로세스 동작</target>
        </trans-unit>
        <trans-unit id="2a03a02ecd76c4aa6d233be9ed15c5b8f09cfe2e" translate="yes" xml:space="preserve">
          <source>Subsection names are case sensitive and can contain any characters except newline and the null byte. Doublequote &lt;code&gt;&quot;&lt;/code&gt; and backslash can be included by escaping them as &lt;code&gt;\&quot;&lt;/code&gt; and &lt;code&gt;\\&lt;/code&gt;, respectively. Backslashes preceding other characters are dropped when reading; for example, &lt;code&gt;\t&lt;/code&gt; is read as &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;\0&lt;/code&gt; is read as &lt;code&gt;0&lt;/code&gt; Section headers cannot span multiple lines. Variables may belong directly to a section or to a given subsection. You can have &lt;code&gt;[section]&lt;/code&gt; if you have &lt;code&gt;[section &quot;subsection&quot;]&lt;/code&gt;, but you don&amp;rsquo;t need to.</source>
          <target state="translated">서브 섹션 이름은 대소 문자를 구분하며 개행 및 널 바이트를 제외한 모든 문자를 포함 할 수 있습니다. 큰 따옴표 &lt;code&gt;&quot;&lt;/code&gt; 및 백 슬래시는 각각 &lt;code&gt;\&quot;&lt;/code&gt; 및 &lt;code&gt;\\&lt;/code&gt; 로 이스케이프하여 포함시킬 수 있습니다 . 읽을 때 다른 문자 앞에 오는 백 슬래시는 삭제됩니다. 예를 들어, &lt;code&gt;\t&lt;/code&gt; 로 판독 &lt;code&gt;t&lt;/code&gt; 및 &lt;code&gt;\0&lt;/code&gt; 으로 판독 &lt;code&gt;0&lt;/code&gt; 여러 줄 수없는 걸쳐 섹션 헤더. 변수는 섹션 또는 지정된 하위 섹션에 직접 속할 수 있습니다. 당신은 할 수 있습니다 &lt;code&gt;[section]&lt;/code&gt; 당신이있는 경우 &lt;code&gt;[section &quot;subsection&quot;]&lt;/code&gt; ,하지만 당신은 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="99e9a313960d39fea11c6c21bc5f471c5ed54f4e" translate="yes" xml:space="preserve">
          <source>Subsequent requests are then made directly to the service &lt;code&gt;$GIT_URL/git-upload-pack&lt;/code&gt;. (This works the same for git-receive-pack).</source>
          <target state="translated">그런 다음 후속 요청이 &lt;code&gt;$GIT_URL/git-upload-pack&lt;/code&gt; 서비스로 직접 이루어집니다 . 이것은 git-receive-pack과 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ecd7815bae661c84db8b72f60f38c2e3bca8ef1f" translate="yes" xml:space="preserve">
          <source>Subsequent updates to branches always create new files under &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; directory hierarchy.</source>
          <target state="translated">분기에 대한 후속 업데이트는 항상 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 디렉토리 계층 아래에 새 파일을 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="b2bf2538aec79c0d5fa040a786e252ac3772aa80" translate="yes" xml:space="preserve">
          <source>Substitute the character &quot;/&quot; in branch names with &amp;lt;subst&amp;gt;</source>
          <target state="translated">분기 이름에서 &quot;/&quot;문자를 &amp;lt;subst&amp;gt;로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="d44c96fa5a053386ed38d9e6a7cca3107588bf57" translate="yes" xml:space="preserve">
          <source>Successful execution (a zero exit status) of this hook does not ensure the ref will actually be updated, it is only a prerequisite. As such it is not a good idea to send notices (e.g. email) from this hook. Consider using the post-receive hook instead.</source>
          <target state="translated">이 후크의 성공적인 실행 (제로 종료 상태)은 심판이 실제로 업데이트되도록 보장하지 않으며, 이는 전제 조건 일뿐입니다. 따라서이 후크에서 통지 (예 : 이메일)를 보내는 것은 좋지 않습니다. 수신 후 후크를 대신 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="52bf3100936199d5e28b505c941092c719fac3ba" translate="yes" xml:space="preserve">
          <source>Such a shell command can be specified by starting the option value with an exclamation point. If your password or token were stored in the &lt;code&gt;GIT_TOKEN&lt;/code&gt;, you could run the following command to set your credential helper:</source>
          <target state="translated">이러한 쉘 명령은 느낌표로 옵션 값을 시작하여 지정할 수 있습니다. 비밀번호 또는 토큰이 &lt;code&gt;GIT_TOKEN&lt;/code&gt; 에 저장된 경우 다음 명령을 실행하여 자격 증명 도우미를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0454547376d4a4928bbfee6331b7c2a9fb4a2161" translate="yes" xml:space="preserve">
          <source>Such duplicates are generally frowned upon because they clutter up history, making it harder to follow. To clean things up, you need to transplant the commits on &lt;code&gt;topic&lt;/code&gt; to the new &lt;code&gt;subsystem&lt;/code&gt; tip, i.e., rebase &lt;code&gt;topic&lt;/code&gt;. This becomes a ripple effect: anyone downstream from &lt;code&gt;topic&lt;/code&gt; is forced to rebase too, and so on!</source>
          <target state="translated">이러한 복제본은 일반적으로 역사를 어지럽히 기 때문에 따르기가 어려워서 찌그러집니다. 정리하려면 &lt;code&gt;topic&lt;/code&gt; 에 대한 커밋을 새로운 &lt;code&gt;subsystem&lt;/code&gt; 팁 (예 : rebase &lt;code&gt;topic&lt;/code&gt; ) 에 이식해야합니다 . 이것은 파급 효과가된다 : &lt;code&gt;topic&lt;/code&gt; 하류에있는 사람 은 모두 리베이스해야한다.</target>
        </trans-unit>
        <trans-unit id="8866d8895f273e182aecc88b4155660c1e2db399" translate="yes" xml:space="preserve">
          <source>Summarize &lt;code&gt;git log&lt;/code&gt; output</source>
          <target state="translated">&lt;code&gt;git log&lt;/code&gt; 출력 요약</target>
        </trans-unit>
        <trans-unit id="ec1e3fb20faac142815eb47774b44cb84610e827" translate="yes" xml:space="preserve">
          <source>Summarizes &lt;code&gt;git log&lt;/code&gt; output in a format suitable for inclusion in release announcements. Each commit will be grouped by author and title.</source>
          <target state="translated">릴리스 알림에 포함하기에 적합한 형식으로 &lt;code&gt;git log&lt;/code&gt; 출력을 요약 합니다. 각 커밋은 저자와 제목별로 그룹화됩니다.</target>
        </trans-unit>
        <trans-unit id="5c7562d8e87120565b992b08061dcfabc4f3c861" translate="yes" xml:space="preserve">
          <source>Supplies raw data (for use as blob/file content, commit messages, or annotated tag messages) to fast-import. Data can be supplied using an exact byte count or delimited with a terminating line. Real frontends intended for production-quality conversions should always use the exact byte count format, as it is more robust and performs better. The delimited format is intended primarily for testing fast-import.</source>
          <target state="translated">빠른 가져 오기에 원시 데이터 (블롭 / 파일 내용, 커밋 메시지 또는 주석이 달린 태그 메시지로 사용)를 제공합니다. 정확한 바이트 수를 사용하거나 종료 라인으로 구분하여 데이터를 제공 할 수 있습니다. 프로덕션 품질 변환을위한 실제 프런트 엔드는보다 강력하고 성능이 우수하므로 항상 정확한 바이트 수 형식을 사용해야합니다. 구분 형식은 기본적으로 빠른 가져 오기를 테스트하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="e8dbb2eeb155ce2917c101c99bacbd864a5c427e" translate="yes" xml:space="preserve">
          <source>Support for these types of regular expressions is an optional compile-time dependency. If Git wasn&amp;rsquo;t compiled with support for them providing this option will cause it to die.</source>
          <target state="translated">이러한 유형의 정규식 지원은 선택적 컴파일 타임 종속성입니다. Git이이 옵션을 제공하는 것을 지원하도록 컴파일되지 않은 경우 죽게됩니다.</target>
        </trans-unit>
        <trans-unit id="8e97694d704a0343a9b684d493f12b44246fec5f" translate="yes" xml:space="preserve">
          <source>Support for this command is mandatory.</source>
          <target state="translated">이 명령에 대한 지원은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="e1b49c8e0d2e923baa9b1bdde89fd2d2c159197a" translate="yes" xml:space="preserve">
          <source>Supported commands: &lt;code&gt;connect&lt;/code&gt;.</source>
          <target state="translated">지원되는 명령 : &lt;code&gt;connect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0b920ef57768d484ba1cc526d81f954a574c57f" translate="yes" xml:space="preserve">
          <source>Supported commands: &lt;code&gt;list for-push&lt;/code&gt;, &lt;code&gt;export&lt;/code&gt;.</source>
          <target state="translated">지원되는 명령 : &lt;code&gt;list for-push&lt;/code&gt; , &lt;code&gt;export&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72ec6998fb5b35dff686188df85ab0e3ad151b49" translate="yes" xml:space="preserve">
          <source>Supported commands: &lt;code&gt;list for-push&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;.</source>
          <target state="translated">지원되는 명령 : &lt;code&gt;list for-push&lt;/code&gt; , &lt;code&gt;push&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5829938d9cd5455d30d44c2ed56081b81ad0e8b1" translate="yes" xml:space="preserve">
          <source>Supported commands: &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;fetch&lt;/code&gt;.</source>
          <target state="translated">지원되는 명령 : &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;fetch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4005d18cc0bff6da83fb1c69518c92481df2684" translate="yes" xml:space="preserve">
          <source>Supported commands: &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;import&lt;/code&gt;.</source>
          <target state="translated">지원되는 명령 : &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;import&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff15abbc5988387a102f85b87106fa0f9a061a4c" translate="yes" xml:space="preserve">
          <source>Supported commands: &lt;code&gt;stateless-connect&lt;/code&gt;.</source>
          <target state="translated">지원되는 명령 : &lt;code&gt;stateless-connect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d7833eb7ee78a4c26a83fcc81c3d2e9095611eb" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;connect&quot; capability.</source>
          <target state="translated">헬퍼에 &quot;연결&quot;기능이있는 경우 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="3a93883be31e9529a29debf1107a5749f91adad7" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;export&quot; capability.</source>
          <target state="translated">헬퍼에 &quot;내보내기&quot;기능이있는 경우 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="18465219e925f5ab7417753a2928593ca3f010cd" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;fetch&quot; capability.</source>
          <target state="translated">헬퍼에 &quot;fetch&quot;기능이있는 경우 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6b3f007fcd47faeaf9e41420b8dd45804e011830" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;fetch&quot; or &quot;import&quot; capability.</source>
          <target state="translated">헬퍼에 &quot;fetch&quot;또는 &quot;import&quot;기능이있는 경우 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4aca0b5526d05a696e7b36938ee6f6c5a0ea9ae4" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;import&quot; capability.</source>
          <target state="translated">헬퍼에 &quot;가져 오기&quot;기능이있는 경우 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="e7ddf6d69b0131cf639e3107da22aa777a2105a4" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;option&quot; capability.</source>
          <target state="translated">헬퍼에 &quot;옵션&quot;기능이있는 경우 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c098533fa12e5c25ff58bd90a0ea089d5ecbd91f" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;push&quot; capability.</source>
          <target state="translated">도우미에 &quot;푸시&quot;기능이있는 경우 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="fb7b526ef7e22c9e1afe23a10d0bc8d29b1f28b6" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;push&quot; or &quot;export&quot; capability.</source>
          <target state="translated">헬퍼에 &quot;푸시&quot;또는 &quot;내보내기&quot;기능이있는 경우 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b4c51ee5ffb300c10c9d8c4078d940f537159814" translate="yes" xml:space="preserve">
          <source>Supported if the helper has the &quot;stateless-connect&quot; capability.</source>
          <target state="translated">헬퍼에 &quot;stateless-connect&quot;기능이있는 경우 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="05ab661bd504730c5b7114057d0bdfc9f5d779d8" translate="yes" xml:space="preserve">
          <source>Supports file additions, removals, and commits that affect binary files.</source>
          <target state="translated">이진 파일에 영향을주는 파일 추가, 제거 및 커밋을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="837f71448f49e2e0d9f370a0f4924a3332c3ce70" translate="yes" xml:space="preserve">
          <source>Suppose a shared repository is set up in /pub/repo.git on the host foo.com. Then as an individual committer you can clone the shared repository over ssh with:</source>
          <target state="translated">공유 저장소가 호스트 foo.com의 /pub/repo.git에 설정되어 있다고 가정하십시오. 그런 다음 개별 커미터로 다음을 사용하여 ssh를 통해 공유 저장소를 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="776b1e3e664257166a794955fe1e330d0ed23c81" translate="yes" xml:space="preserve">
          <source>Suppose further that the two development lines merge cleanly at C, so no conflict resolution is required.</source>
          <target state="translated">두 개의 개발 라인이 C에서 깔끔하게 병합되므로 충돌 해결이 필요하지 않다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="e8f9a38765e97d2341920d57addc2939bc25d7eb" translate="yes" xml:space="preserve">
          <source>Suppose that Alice has started a new project with a Git repository in /home/alice/project, and that Bob, who has a home directory on the same machine, wants to contribute.</source>
          <target state="translated">Alice가 / home / alice / project에서 Git 저장소를 사용하여 새 프로젝트를 시작했으며 동일한 시스템에 홈 디렉토리가있는 Bob이 참여하려고한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="f0185bb1f9b382ec2ad8024131a049405c5d0a74" translate="yes" xml:space="preserve">
          <source>Suppose that in the meantime on the lower line of development somebody adds a new calling site for that function at commit Y. The commits from Z leading to B all assume the old semantics of that function and the callers and the callee are consistent with each other. There is no bug at B, either.</source>
          <target state="translated">개발의 하위 라인에 누군가가 커밋 Y에서 해당 함수에 대한 새로운 호출 사이트를 추가한다고 가정하십시오. Z에서 B로 이어지는 커밋은 모두 해당 함수의 오래된 의미를 가정하고 호출자와 호출 수신자는 서로 일치한다고 가정합니다 . B에도 버그가 없습니다.</target>
        </trans-unit>
        <trans-unit id="391a0e24d7cf4e807cbdc6c67d247a126500a7a1" translate="yes" xml:space="preserve">
          <source>Suppose that on the upper line of development, the meaning of one of the functions that exists at Z is changed at commit X. The commits from Z leading to A change both the function&amp;rsquo;s implementation and all calling sites that exist at Z, as well as new calling sites they add, to be consistent. There is no bug at A.</source>
          <target state="translated">개발의 상위 라인에서 Z에 존재하는 함수 중 하나의 의미가 커밋 X에서 변경된다고 가정합니다. Z에서 A로 이어지는 커밋은 함수의 구현과 Z에 존재하는 모든 호출 사이트뿐만 아니라 그들이 추가하는 새로운 호출 사이트, 일관성. A에는 버그가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4264938eda486beabd24f72d431c53e3aa7556fd" translate="yes" xml:space="preserve">
          <source>Suppose that you create a branch &lt;code&gt;mywork&lt;/code&gt; on a remote-tracking branch &lt;code&gt;origin&lt;/code&gt;, and create some commits on top of it:</source>
          <target state="translated">원격 추적 브랜치 &lt;code&gt;origin&lt;/code&gt; 에서 브랜치 &lt;code&gt;mywork&lt;/code&gt; 를 작성하고 그 위에 커밋을 작성한다고 가정 하십시오.</target>
        </trans-unit>
        <trans-unit id="3c9c906e2a1276113a369eaaabf56387154b9496" translate="yes" xml:space="preserve">
          <source>Suppose that you have created lots of logically separate changes and committed them together. Then, later you decide that it might be better to have each logical chunk associated with its own commit. You can use git reset to rewind history without changing the contents of your local files, and then successively use &lt;code&gt;git add -p&lt;/code&gt; to interactively select which hunks to include into each commit, using &lt;code&gt;git commit -c&lt;/code&gt; to pre-populate the commit message.</source>
          <target state="translated">논리적으로 분리 된 많은 변경 사항을 만들어 함께 커밋했다고 가정합니다. 그런 다음 나중에 각 논리적 청크를 자체 커밋과 연결하는 것이 더 나을 수도 있습니다. git reset-을 사용하여 로컬 파일의 내용을 변경하지 않고 기록을 되 감은 다음 &lt;code&gt;git add -p&lt;/code&gt; 를 사용 하여 커밋 메시지를 미리 채우려면 &lt;code&gt;git commit -c&lt;/code&gt; 를 사용하여 각 커밋에 포함 할 덩어리를 대화식으로 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="02fbd8fc87f2a350a49d8620ee0b30d4bf4e4abd" translate="yes" xml:space="preserve">
          <source>Suppose version 2.6.18 of your project worked, but the version at &quot;master&quot; crashes. Sometimes the best way to find the cause of such a regression is to perform a brute-force search through the project&amp;rsquo;s history to find the particular commit that caused the problem. The &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; command can help you do this:</source>
          <target state="translated">프로젝트의 버전 2.6.18이 작동했지만 &quot;마스터&quot;버전이 충돌한다고 가정합니다. 때로는 이러한 회귀의 원인을 찾는 가장 좋은 방법은 프로젝트 기록을 통해 무차별 검색을 수행하여 문제를 일으킨 특정 커밋을 찾는 것입니다. &lt;a href=&quot;git-bisect&quot;&gt;자식-양분 [1]&lt;/a&gt; 명령을 사용하면이 작업을 수행 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="fe43e13972d777424e11db2803667e644671ba7d" translate="yes" xml:space="preserve">
          <source>Suppose you are a contributor to a large project, and you want to add a complicated feature, and to present it to the other developers in a way that makes it easy for them to read your changes, verify that they are correct, and understand why you made each change.</source>
          <target state="translated">대규모 프로젝트에 기고하고 복잡한 기능을 추가하고 변경 사항을 쉽게 읽고 변경 사항이 올바른지 확인하고 이유를 이해하기 쉬운 방식으로 다른 개발자에게 제공하려고한다고 가정합니다. 당신은 각각을 변경했습니다.</target>
        </trans-unit>
        <trans-unit id="3acc0c164272600e31526ab46c74892c1aa07162" translate="yes" xml:space="preserve">
          <source>Suppose you are interrupted by an urgent fix request while you are in the middle of a large change. The files in your working tree are not in any shape to be committed yet, but you need to get to the other branch for a quick bugfix.</source>
          <target state="translated">대규모 변경 중에 긴급 수정 요청이 중단되었다고 가정합니다. 작업 트리의 파일은 아직 커밋되지 않았지만 빠른 버그 수정을 위해 다른 지점으로 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="206336da1c56023f89c7e12354f95287caca26a2" translate="yes" xml:space="preserve">
          <source>Suppose you are working on something and you commit it, and then you continue working a bit more, but now you think that what you have in your working tree should be in another branch that has nothing to do with what you committed previously. You can start a new branch and reset it while keeping the changes in your working tree.</source>
          <target state="translated">당신이 어떤 일을하고 있고 그것을 저지른 다음에 조금 더 계속 일한다고 가정 해 봅시다. 그러나 지금 당신은 당신의 작업 트리에있는 것이 이전에 커밋 한 것과 아무 관련이없는 다른 브랜치에 있어야한다고 생각합니다. 작업 트리에서 변경 사항을 유지하면서 새 분기를 시작하고 재설정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25caa4df3e00bbf0c1bcbf48ca3bbcb805b36ab6" translate="yes" xml:space="preserve">
          <source>Suppose you have added a file to your index, but later decide you do not want to add it to your commit. You can remove the file from the index while keeping your changes with git reset.</source>
          <target state="translated">인덱스에 파일을 추가했지만 나중에 커밋에 추가하지 않기로 결정했다고 가정하십시오. git reset으로 변경 사항을 유지하면서 인덱스에서 파일을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9419c8de1f4e3152ef10e8d631b17a6a8c4bb66f" translate="yes" xml:space="preserve">
          <source>Suppose you know that the commit e05db0fd fixed a certain problem. You&amp;rsquo;d like to find the earliest tagged release that contains that fix.</source>
          <target state="translated">커밋 e05db0fd가 특정 문제를 해결했다고 가정 해 봅시다. 해당 픽스가 포함 된 가장 빠른 태그 릴리스를 찾고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="c40ef08f6cb59edadae067c6870364980c310ebf" translate="yes" xml:space="preserve">
          <source>Suppose you specified &lt;code&gt;foo&lt;/code&gt; as the &amp;lt;paths&amp;gt;. We shall call commits that modify &lt;code&gt;foo&lt;/code&gt; !TREESAME, and the rest TREESAME. (In a diff filtered for &lt;code&gt;foo&lt;/code&gt;, they look different and equal, respectively.)</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 를 &amp;lt;paths&amp;gt;로 지정 했다고 가정하십시오 . &lt;code&gt;foo&lt;/code&gt; ! TREESAME 및 나머지 TREESAME 를 수정하는 커밋을 호출 합니다. ( &lt;code&gt;foo&lt;/code&gt; 로 필터링 된 diff에서는 각각 다르게 보이고 동일하게 보입니다.)</target>
        </trans-unit>
        <trans-unit id="cb2a200ea83c58efe22ad112266f5c75d08a4a2e" translate="yes" xml:space="preserve">
          <source>Suppose you want to check whether two branches point at the same point in history.</source>
          <target state="translated">두 분기가 히스토리에서 동일한 지점을 가리키는 지 확인하려고한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="a4ad635bf26628e292f1bfd04aa9f0a4ae18d146" translate="yes" xml:space="preserve">
          <source>Suppose you want to know how many commits you&amp;rsquo;ve made on &lt;code&gt;mybranch&lt;/code&gt; since it diverged from &lt;code&gt;origin&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;mybranch&lt;/code&gt; 가 &lt;code&gt;origin&lt;/code&gt; 에서 벗어난 이후 얼마나 많은 커밋을했는지 알고 싶다고 가정 해보십시오 .</target>
        </trans-unit>
        <trans-unit id="f9ddeae1484388d5dab75e34df1cfd67e52a3e70" translate="yes" xml:space="preserve">
          <source>Suppose you want to rebase the side branch starting at &quot;A&quot; to &quot;Q&quot;. Make sure that the current HEAD is &quot;B&quot;, and call</source>
          <target state="translated">&quot;A&quot;에서 &quot;Q&quot;로 시작하는 사이드 브랜치를 리베이스한다고 가정합니다. 현재 HEAD가 &quot;B&quot;인지 확인하고 전화하십시오.</target>
        </trans-unit>
        <trans-unit id="b5613771383533c24d3d428fdc1ae60e9fd438c4" translate="yes" xml:space="preserve">
          <source>Suppose you want to remove a file (containing confidential information or copyright violation) from all commits:</source>
          <target state="translated">모든 커밋에서 파일 (기밀 정보 또는 저작권 위반 포함)을 제거한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ff7d0768a57dca637d6eab253f0d487ae1222161" translate="yes" xml:space="preserve">
          <source>Suppose you would like to see all the commits reachable from the branch head named &lt;code&gt;master&lt;/code&gt; but not from any other head in your repository.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 라는 브랜치 헤드에서 도달 할 수 있지만 리포지토리의 다른 헤드에서는 도달 할 수없는 모든 커밋을보고 싶다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="9946995b81548e47df6c8b8392c1840733fdb964" translate="yes" xml:space="preserve">
          <source>Suppress all output, including the listing of updated refs, unless an error occurs. Progress is not reported to the standard error stream.</source>
          <target state="translated">오류가 발생하지 않는 한 업데이트 된 참조 목록을 포함하여 모든 출력을 억제하십시오. 진행률은 표준 오류 스트림에보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4b3a6cd7a8560fe90c65c121ee87d36135f6602" translate="yes" xml:space="preserve">
          <source>Suppress all progress reports.</source>
          <target state="translated">모든 진행률 보고서를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a819bd2ff05cd55161823638237268e190be312a" translate="yes" xml:space="preserve">
          <source>Suppress commit description and provide a commit count summary only.</source>
          <target state="translated">커밋 설명을 억제하고 커밋 수 요약 만 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="e799a643bdb9c82fda51c43573cb85b70de9e54e" translate="yes" xml:space="preserve">
          <source>Suppress commit summary message.</source>
          <target state="translated">커밋 요약 메시지를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a696049e271af3ebf56a00bfbec639053a19da0" translate="yes" xml:space="preserve">
          <source>Suppress diff output. Useful for commands like &lt;code&gt;git show&lt;/code&gt; that show the patch by default, or to cancel the effect of &lt;code&gt;--patch&lt;/code&gt;.</source>
          <target state="translated">diff 출력을 억제합니다. 기본적으로 패치를 표시하거나 &lt;code&gt;--patch&lt;/code&gt; 의 효과를 취소하는 &lt;code&gt;git show&lt;/code&gt; 같은 명령에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="93e56a37493c6ba4434b0b6ea5eb008e9221a320" translate="yes" xml:space="preserve">
          <source>Suppress the author name and timestamp from the output.</source>
          <target state="translated">출력에서 작성자 이름 및 시간 소인을 억제하십시오.</target>
        </trans-unit>
        <trans-unit id="f43798729bfff9f209d330c349626cb5165ac751" translate="yes" xml:space="preserve">
          <source>Swap two inputs; that is, show differences from index or on-disk file to tree contents.</source>
          <target state="translated">두 입력을 교환하십시오. 즉, 인덱스 또는 디스크상의 파일과 트리 내용의 차이점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e5e55f7f46ad773b6efc6aca47e818298efdba7d" translate="yes" xml:space="preserve">
          <source>Switch branches</source>
          <target state="translated">분기 전환</target>
        </trans-unit>
        <trans-unit id="c1c3479fb48988243819a9ed632d7db49472e85a" translate="yes" xml:space="preserve">
          <source>Switch branches or restore working tree files</source>
          <target state="translated">분기 전환 또는 작업 트리 파일 복원</target>
        </trans-unit>
        <trans-unit id="dfdb03e90173f2e2bacd7c02f01c4407ebc5e4a7" translate="yes" xml:space="preserve">
          <source>Switch to &lt;code&gt;topic/wip&lt;/code&gt; branch and keep working.</source>
          <target state="translated">&lt;code&gt;topic/wip&lt;/code&gt; 브랜치로 전환 하고 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="376cbb6cbd05a4fda1d6b5e220f115dcce8e44f1" translate="yes" xml:space="preserve">
          <source>Switch to a commit for inspection and discardable experiments. See the &quot;DETACHED HEAD&quot; section in &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; for details.</source>
          <target state="translated">검사 및 폐기 가능한 실험을 위해 커밋으로 전환하십시오. 자세한 내용은 &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; 의 &quot;DETACHED HEAD&quot;섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0362a7c9eb4dad56855ff5dd55a91d5b93e6f9c7" translate="yes" xml:space="preserve">
          <source>Switch to a specified branch. The working tree and the index are updated to match the branch. All new commits will be added to the tip of this branch.</source>
          <target state="translated">지정된 분기로 전환하십시오. 작업 트리와 인덱스가 분기와 일치하도록 업데이트됩니다. 모든 새로운 커밋이이 브랜치의 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c4a37023c84f04e66def4788394f47d95de02383" translate="yes" xml:space="preserve">
          <source>Switching branches does not require a clean index and working tree (i.e. no differences compared to &lt;code&gt;HEAD&lt;/code&gt;). The operation is aborted however if the operation leads to loss of local changes, unless told otherwise with &lt;code&gt;--discard-changes&lt;/code&gt; or &lt;code&gt;--merge&lt;/code&gt;.</source>
          <target state="translated">스위칭 브랜치에는 깨끗한 인덱스와 작업 트리가 필요하지 않습니다 (즉 &lt;code&gt;HEAD&lt;/code&gt; 와 비교하여 차이가 없음 ). 그러나 &lt;code&gt;--discard-changes&lt;/code&gt; 또는 &lt;code&gt;--merge&lt;/code&gt; 로 달리 지시하지 않는 한 작업으로 인해 로컬 변경 내용이 손실되면 작업이 중단됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a44d54fe8d0fbe571632defb5e0f0bfcb635688" translate="yes" xml:space="preserve">
          <source>Symbolic identifiers</source>
          <target state="translated">기호 식별자</target>
        </trans-unit>
        <trans-unit id="edf50a81800d6af816fa28268463b4a137a670b4" translate="yes" xml:space="preserve">
          <source>Symbolic reference: instead of containing the &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; id itself, it is of the format 'ref: refs/some/thing' and when referenced, it recursively dereferences to this reference. '&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;' is a prime example of a symref. Symbolic references are manipulated with the &lt;a href=&quot;git-symbolic-ref&quot;&gt;git-symbolic-ref[1]&lt;/a&gt; command.</source>
          <target state="translated">상징적 참조 : &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; ID 자체 를 포함하는 대신 'ref : refs / some / thing'형식이며 참조 할 때이 참조를 재귀 적으로 역 참조합니다. ' &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; '는 symref의 주요 예입니다. 기호 참조는 &lt;a href=&quot;git-symbolic-ref&quot;&gt;git-symbolic-ref [1]&lt;/a&gt; 명령 으로 조작됩니다 .</target>
        </trans-unit>
        <trans-unit id="6dc4afea6b4b62629fc3af96ff8aeb71d81ce355" translate="yes" xml:space="preserve">
          <source>Symbolic reference: instead of containing the &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; id itself, it is of the format &lt;code&gt;ref: refs/some/thing&lt;/code&gt; and when referenced, it recursively dereferences to this reference. &lt;code&gt;&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;&lt;/code&gt; is a prime example of a symref. Symbolic references are manipulated with the &lt;a href=&quot;git-symbolic-ref&quot;&gt;git-symbolic-ref[1]&lt;/a&gt; command.</source>
          <target state="translated">기호 참조 : &lt;a href=&quot;#def_SHA1&quot;&gt;SHA-1&lt;/a&gt; ID 자체 를 포함하는 대신 &lt;code&gt;ref: refs/some/thing&lt;/code&gt; 형식 이며이 참조를 재귀 적으로 참조 해제합니다. &lt;code&gt;&lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt;&lt;/code&gt; 는 symref의 주요 예입니다. 기호 참조는 &lt;a href=&quot;git-symbolic-ref&quot;&gt;git-symbolic-ref [1]&lt;/a&gt; 명령 으로 조작됩니다 .</target>
        </trans-unit>
        <trans-unit id="7d980e6b3e0dc3c2265b8f39aea640f21a2c26c7" translate="yes" xml:space="preserve">
          <source>Symlinks in &lt;code&gt;$GIT_DIR&lt;/code&gt; are not resolved before matching.</source>
          <target state="translated">&lt;code&gt;$GIT_DIR&lt;/code&gt; GIT_DIR의 심볼릭 링크는 일치하기 전에 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="905f63092ff26517a7aa8083857b3c8af9707002" translate="yes" xml:space="preserve">
          <source>Sync</source>
          <target state="translated">Sync</target>
        </trans-unit>
        <trans-unit id="1cafa24e02c13e63ccc749c8cc50c089372b01c9" translate="yes" xml:space="preserve">
          <source>Sync options</source>
          <target state="translated">동기화 옵션</target>
        </trans-unit>
        <trans-unit id="a05ba5351cf72e05a13ed22352248517859a3ce9" translate="yes" xml:space="preserve">
          <source>Synchronizes submodules' remote URL configuration setting to the value specified in &lt;code&gt;.gitmodules&lt;/code&gt;. It will only affect those submodules which already have a URL entry in .git/config (that is the case when they are initialized or freshly added). This is useful when submodule URLs change upstream and you need to update your local repositories accordingly.</source>
          <target state="translated">하위 모듈의 원격 URL 구성 설정을 &lt;code&gt;.gitmodules&lt;/code&gt; 에 지정된 값으로 동기화합니다 . .git / config에 이미 URL 항목이있는 하위 모듈에만 영향을 미칩니다 (즉, 초기화되거나 새로 추가 된 경우). 하위 모듈 URL이 업스트림으로 변경되어 로컬 리포지토리를 적절히 업데이트해야 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3ac8d1a1aa5500a3e968826312a150affc9dc46d" translate="yes" xml:space="preserve">
          <source>Syncing repositories</source>
          <target state="translated">리포지토리 동기화</target>
        </trans-unit>
        <trans-unit id="566e604d58292e23d183e78e39f3823e9b42de23" translate="yes" xml:space="preserve">
          <source>Synonym for --dirstat=cumulative</source>
          <target state="translated">--dirstat = cumulative의 동의어</target>
        </trans-unit>
        <trans-unit id="f1c4d35b0c03f286600f7fb27eae33fe27989165" translate="yes" xml:space="preserve">
          <source>Synonym for --dirstat=files,param1,param2&amp;hellip;​</source>
          <target state="translated">--dirstat = files, param1, param2의 동의어&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="030318e98e2891ff258d5f1c486159aabe2ec3cd" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; (the noun).</source>
          <target state="translated">&lt;a href=&quot;#def_commit&quot;&gt;커밋의&lt;/a&gt; 동의어 (명사).</target>
        </trans-unit>
        <trans-unit id="98387ba9809590c01ed4197e28a198c994b76d39" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;a href=&quot;#def_object_name&quot;&gt;object name&lt;/a&gt;.</source>
          <target state="translated">동의어 &lt;a href=&quot;#def_object_name&quot;&gt;개체 이름&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05205baafaafa5f371ceb6761f66c9a9092bfca8" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; (for arch people).</source>
          <target state="translated">&lt;a href=&quot;#def_repository&quot;&gt;저장소의&lt;/a&gt; 동의어 (아치 사용자 용)</target>
        </trans-unit>
        <trans-unit id="bd983733ce10be3d6383ba3ae94c790c5998f587" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;code&gt;--date=relative&lt;/code&gt;.</source>
          <target state="translated">동의어 &lt;code&gt;--date=relative&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7204033ad0a3ce5a123aa68893dbb1ec2d44eb7f" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;code&gt;-p --raw&lt;/code&gt;.</source>
          <target state="translated">동의어 &lt;code&gt;-p --raw&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2c85a45d4841ec1bc0daa5da30d63888f50f751" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;code&gt;-p --stat&lt;/code&gt;.</source>
          <target state="translated">동의어 &lt;code&gt;-p --stat&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4826ecc5c9ae249b105cc0f800bf317e1bf3ce71" translate="yes" xml:space="preserve">
          <source>Synonym to &lt;code&gt;--more=-1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--more=-1&lt;/code&gt; 과 동의어</target>
        </trans-unit>
        <trans-unit id="375d34b627071e9b56cd3502d59bf963af19d37c" translate="yes" xml:space="preserve">
          <source>Synonym to &lt;code&gt;merge.log&lt;/code&gt;; this is deprecated and will be removed in the future.</source>
          <target state="translated">&lt;code&gt;merge.log&lt;/code&gt; 와 동의어 ; 이것은 더 이상 사용되지 않으며 향후 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="d87db41828b59d9f281eb9d60b0fac7e88c656b9" translate="yes" xml:space="preserve">
          <source>Synonyms to --log and --no-log; these are deprecated and will be removed in the future.</source>
          <target state="translated">--log 및 --no-log와 동의어; 이들은 더 이상 사용되지 않으며 향후 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="c9c7aa6b4fd156059c823cdabeac32daf66bec16" translate="yes" xml:space="preserve">
          <source>Synonyms to --stat and --no-stat; these are deprecated and will be removed in the future.</source>
          <target state="translated">--stat 및 --no-stat의 동의어; 이들은 더 이상 사용되지 않으며 향후 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="36c0630a340d2960affa1c4d2360b0e2c06793fb" translate="yes" xml:space="preserve">
          <source>Synopsis</source>
          <target state="translated">Synopsis</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="121e826ad7717bacfd25c6cf738291790df9e550" translate="yes" xml:space="preserve">
          <source>Syntax is compatible with the file used by &lt;code&gt;git cvsimport&lt;/code&gt; but an empty email address can be supplied with &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">구문은 &lt;code&gt;git cvsimport&lt;/code&gt; 에서 사용하는 파일과 호환 되지만 빈 전자 메일 주소는 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 로 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd2d182068c3eb81ead850c75865e8ae2f054c99" translate="yes" xml:space="preserve">
          <source>System-wide configuration file.</source>
          <target state="translated">시스템 전체 구성 파일</target>
        </trans-unit>
        <trans-unit id="bb78aa3d24f5df42764064db56cde78ca1a563d8" translate="yes" xml:space="preserve">
          <source>T: change in the type of the file</source>
          <target state="translated">T : 파일 형식 변경</target>
        </trans-unit>
        <trans-unit id="a5e95b00d8bbc7641f64bca05aef94e0873eb866" translate="yes" xml:space="preserve">
          <source>THIS COMMAND IS EXPERIMENTAL. ITS BEHAVIOR, AND THE BEHAVIOR OF OTHER COMMANDS IN THE PRESENCE OF SPARSE-CHECKOUTS, WILL LIKELY CHANGE IN THE FUTURE.</source>
          <target state="translated">이 명령은 실험적입니다. 스파 스 체크 아웃의 존재에서 그 행동과 다른 명령의 행동은 미래에 거의 변하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="9667ca46bdeede85b6c2fc52e7779cc06938e375" translate="yes" xml:space="preserve">
          <source>THIS COMMAND IS EXPERIMENTAL. THE BEHAVIOR MAY CHANGE.</source>
          <target state="translated">이 명령은 실험적입니다. 행동이 바뀔 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da2da317615483c79a5e32887ba14bbfd135afb2" translate="yes" xml:space="preserve">
          <source>THIS OPTION IS EXPERIMENTAL! SHA-256 support is experimental and still in an early stage. A SHA-256 repository will in general not be able to share work with &quot;regular&quot; SHA-1 repositories. It should be assumed that, e.g., Git internal file formats in relation to SHA-256 repositories may change in backwards-incompatible ways. Only use &lt;code&gt;--object-format=sha256&lt;/code&gt; for testing purposes.</source>
          <target state="translated">THIS OPTION IS EXPERIMENTAL! SHA-256 support is experimental and still in an early stage. A SHA-256 repository will in general not be able to share work with &quot;regular&quot; SHA-1 repositories. It should be assumed that, e.g., Git internal file formats in relation to SHA-256 repositories may change in backwards-incompatible ways. Only use &lt;code&gt;--object-format=sha256&lt;/code&gt; for testing purposes.</target>
        </trans-unit>
        <trans-unit id="667949023cc3f454cb0d70e83c52143e1650458d" translate="yes" xml:space="preserve">
          <source>TRAILER:</source>
          <target state="translated">TRAILER:</target>
        </trans-unit>
        <trans-unit id="a2ba9a257606db8185ab32e1350e244ce43cc422" translate="yes" xml:space="preserve">
          <source>Tag Object</source>
          <target state="translated">태그 객체</target>
        </trans-unit>
        <trans-unit id="cb8b1e1903f812d19eec6ff05583389fd13d1603" translate="yes" xml:space="preserve">
          <source>Tag format</source>
          <target state="translated">태그 형식</target>
        </trans-unit>
        <trans-unit id="7e41343aeba4393f005c76977eda409bbd77862f" translate="yes" xml:space="preserve">
          <source>Tag names are automatically prefixed with &lt;code&gt;refs/tags/&lt;/code&gt; when stored in Git, so importing the CVS branch symbol &lt;code&gt;RELENG-1_0-FINAL&lt;/code&gt; would use just &lt;code&gt;RELENG-1_0-FINAL&lt;/code&gt; for &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt;, and fast-import will write the corresponding ref as &lt;code&gt;refs/tags/RELENG-1_0-FINAL&lt;/code&gt;.</source>
          <target state="translated">태그 이름이 자동으로 접두어 &lt;code&gt;refs/tags/&lt;/code&gt; 그래서 CVS 가지 기호를 가져, 힘내에 저장 &lt;code&gt;RELENG-1_0-FINAL&lt;/code&gt; 단지 사용하는 것이 &lt;code&gt;RELENG-1_0-FINAL&lt;/code&gt; 에 대한 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; , 빠른 가져 오기는 해당 심판 쓸 것 &lt;code&gt;refs/tags/RELENG-1_0-FINAL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e6fe4e0ae7885e683d9ee3f683c218e6902b977" translate="yes" xml:space="preserve">
          <source>Tag objects (created with &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, or &lt;code&gt;-u&lt;/code&gt;) are called &quot;annotated&quot; tags; they contain a creation date, the tagger name and e-mail, a tagging message, and an optional GnuPG signature. Whereas a &quot;lightweight&quot; tag is simply a name for an object (usually a commit object).</source>
          <target state="translated">&lt;code&gt;-a&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; 또는 &lt;code&gt;-u&lt;/code&gt; 로 작성된 태그 객체를 &quot;주석&quot;태그라고합니다. 여기에는 생성 날짜, 태거 이름 및 전자 메일, 태깅 메시지 및 선택적 GnuPG 서명이 포함됩니다. &quot;가벼운&quot;태그는 단순히 객체 (일반적으로 커밋 객체)의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="71ea1d47718752d76e2ffd9d2603ad43ca73b3c9" translate="yes" xml:space="preserve">
          <source>Tagging a version</source>
          <target state="translated">버전 태그</target>
        </trans-unit>
        <trans-unit id="637cc41ee731974198f97641d9bdfb130460784b" translate="yes" xml:space="preserve">
          <source>Tags are expected to always point at the same version of a project, while heads are expected to advance as development progresses.</source>
          <target state="translated">태그는 항상 같은 버전의 프로젝트를 가리킬 것으로 예상되는 반면, 개발이 진행됨에 따라 헤드는 발전 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="888bc919d88641f62426fddc6b7cfc9f6452b8d3" translate="yes" xml:space="preserve">
          <source>Take an existing commit object, and reuse the log message and the authorship information (including the timestamp) when creating the commit.</source>
          <target state="translated">기존 커밋 개체를 가져 와서 커밋을 만들 때 로그 메시지와 제작 정보 (타임 스탬프 포함)를 재사용하십시오.</target>
        </trans-unit>
        <trans-unit id="69d5f1e03c82cbcd587369170c6624b0cf043d55" translate="yes" xml:space="preserve">
          <source>Take the commit message from the given file. This option disables the &lt;code&gt;--edit&lt;/code&gt; option.</source>
          <target state="translated">주어진 파일에서 커밋 메시지를 가져옵니다. 이 옵션은 &lt;code&gt;--edit&lt;/code&gt; 옵션을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="55362ac1695784c6e28770360066065f70c4271a" translate="yes" xml:space="preserve">
          <source>Take the commit message from the given file. Use &lt;code&gt;-&lt;/code&gt; to read the message from the standard input.</source>
          <target state="translated">주어진 파일에서 커밋 메시지를 가져옵니다. &lt;code&gt;-&lt;/code&gt; 를 사용 하여 표준 입력에서 메시지를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="e36d4d8811a867676a670c71431af6f45b8cdbfc" translate="yes" xml:space="preserve">
          <source>Take the configuration from the given file instead of .git/config. Using the &quot;--global&quot; option forces this to ~/.gitconfig. Using the &quot;--system&quot; option forces this to $(prefix)/etc/gitconfig.</source>
          <target state="translated">.git / config 대신 지정된 파일에서 구성을 가져옵니다. &quot;--global&quot;옵션을 사용하면 이것을 ~ / .gitconfig로 설정합니다. &quot;--system&quot;옵션을 사용하면 $ (prefix) / etc / gitconfig가됩니다.</target>
        </trans-unit>
        <trans-unit id="29a57524801de08e4acaf7aa5d5fef7d3a95fdaf" translate="yes" xml:space="preserve">
          <source>Take the given blob object (for example, another note) as the note message. (Use &lt;code&gt;git notes copy &amp;lt;object&amp;gt;&lt;/code&gt; instead to copy notes between objects.)</source>
          <target state="translated">지정된 Blob 객체 (예 : 다른 메모)를 메모 메시지로 사용하십시오. ( &lt;code&gt;git notes copy &amp;lt;object&amp;gt;&lt;/code&gt; 간에 메모를 복사 하려면 git notes copy &amp;lt;object&amp;gt; 를 사용하십시오 .)</target>
        </trans-unit>
        <trans-unit id="d362e00efeb54e4840d9ea63f1d18d0cce50b4f2" translate="yes" xml:space="preserve">
          <source>Take the list of merged objects from &amp;lt;file&amp;gt; instead of stdin.</source>
          <target state="translated">stdin 대신 &amp;lt;file&amp;gt;에서 병합 된 객체 목록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="85714dc37d705ec3059aca2b86357cf12078cff0" translate="yes" xml:space="preserve">
          <source>Take the list of refs from stdin, one per line. If there are refs specified on the command line in addition to this option, then the refs from stdin are processed after those on the command line.</source>
          <target state="translated">stdin의 참조 목록을 한 줄에 하나씩 가져옵니다. 이 옵션 외에 명령 행에 지정된 참조가있는 경우 stdin의 참조는 명령 행의 참조 이후에 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e793a474854bfcd7a2387829ec157d014acaec34" translate="yes" xml:space="preserve">
          <source>Take the note message from the given file. Use &lt;code&gt;-&lt;/code&gt; to read the note message from the standard input. Lines starting with &lt;code&gt;#&lt;/code&gt; and empty lines other than a single line between paragraphs will be stripped out.</source>
          <target state="translated">주어진 파일에서 메모 메시지를 가져옵니다. 표준 입력에서 메모 메시지를 읽으려면 &lt;code&gt;-&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;#&lt;/code&gt; 으로 시작하고 단락 사이의 한 줄 이외의 빈 줄은 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b415454b3e57aca4cd9775be68c013d0b1cba35f" translate="yes" xml:space="preserve">
          <source>Take the tag message from the given file. Use &lt;code&gt;-&lt;/code&gt; to read the message from the standard input. Implies &lt;code&gt;-a&lt;/code&gt; if none of &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, or &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; is given.</source>
          <target state="translated">주어진 파일에서 태그 메시지를 가져옵니다. &lt;code&gt;-&lt;/code&gt; 를 사용 하여 표준 입력에서 메시지를 읽습니다. &lt;code&gt;-a&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; 또는 &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 가 없으면 &lt;code&gt;-a&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="437fabd9a3b90a4e3feee997e0efd394e0e18037" translate="yes" xml:space="preserve">
          <source>Take the version from the current branch as the tentative merge result, and declare that the merge has conflicts. This is suitable for binary files that do not have a well-defined merge semantics.</source>
          <target state="translated">현재 분기의 버전을 임시 병합 결과로 가져 와서 병합이 충돌한다고 선언하십시오. 이는 잘 정의 된 병합 의미가없는 이진 파일에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="8adfe6e8bfbfb71c863cfc8d3c7f83de8a17ccfc" translate="yes" xml:space="preserve">
          <source>Takes the list of merged objects on stdin and produces a suitable commit message to be used for the merge commit, usually to be passed as the &lt;code&gt;&amp;lt;merge-message&amp;gt;&lt;/code&gt; argument of &lt;code&gt;git merge&lt;/code&gt;.</source>
          <target state="translated">stdin에서 병합 된 오브젝트 목록을 가져 와서 병합 커밋에 사용될 적절한 커밋 메시지를 생성합니다. 일반적 으로 &lt;code&gt;git merge&lt;/code&gt; 의 &lt;code&gt;&amp;lt;merge-message&amp;gt;&lt;/code&gt; 인수로 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="a792b2d24cbb9bea552de7c52e443e6ec570f86e" translate="yes" xml:space="preserve">
          <source>Takes the patches given on the command line and emails them out. Patches can be specified as files, directories (which will send all files in the directory), or directly as a revision list. In the last case, any format accepted by &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; can be passed to git send-email.</source>
          <target state="translated">명령 행에 제공된 패치를 가져 와서 이메일로 보냅니다. 패치는 파일, 디렉토리 (디렉토리의 모든 파일을 전송 함) 또는 직접 개정 목록으로 지정할 수 있습니다. 마지막으로, &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]에&lt;/a&gt; 의해 허용 된 모든 형식은 git send-email로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a0ff7754ecf08c3c8186e018764aeb2fd2691af" translate="yes" xml:space="preserve">
          <source>Talk to the IMAP server using git&amp;rsquo;s own IMAP routines instead of using libcurl. Ignored if Git was built with the NO_OPENSSL option set.</source>
          <target state="translated">libcurl 대신 git 자신의 IMAP 루틴을 사용하여 IMAP 서버와 대화하십시오. NO_OPENSSL 옵션 세트로 Git을 빌드 한 경우 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8452733fe9983e27bdd86ccd2806b4879b9eed76" translate="yes" xml:space="preserve">
          <source>Target of the home link on the top of all pages (the first part of view &quot;breadcrumbs&quot;). By default it is set to the absolute URI of a current page (to the value of &lt;code&gt;$my_uri&lt;/code&gt; variable, or to &quot;/&quot; if &lt;code&gt;$my_uri&lt;/code&gt; is undefined or is an empty string).</source>
          <target state="translated">모든 페이지 상단의 홈 링크 대상 (보기의 &quot;빵 부스러기&quot;). 기본적으로 현재 페이지의 절대 URI ( &lt;code&gt;$my_uri&lt;/code&gt; 변수 의 값 또는 &lt;code&gt;$my_uri&lt;/code&gt; 가 정의되지 않았거나 빈 문자열 인 경우 &quot;/&quot; )로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b83c8f8bfe5de4730b897d69d4046995d166efe4" translate="yes" xml:space="preserve">
          <source>Targets are defined using a VTable allowing easy extension to other formats in the future. This might be used to define a binary format, for example.</source>
          <target state="translated">대상은 향후 다른 형식으로 쉽게 확장 할 수있는 VTable을 사용하여 정의됩니다. 예를 들어 이진 형식을 정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="090ec5f560fc50377fcd95e5cda128e91b276e98" translate="yes" xml:space="preserve">
          <source>Tasks</source>
          <target state="translated">Tasks</target>
        </trans-unit>
        <trans-unit id="b51ba0493561f3b3deddd8211a5a385cd8601db7" translate="yes" xml:space="preserve">
          <source>Technical discussion</source>
          <target state="translated">기술 토론</target>
        </trans-unit>
        <trans-unit id="7d2e519ddfe0c57b9b7de69eeaa388f193a9848e" translate="yes" xml:space="preserve">
          <source>Tell Git that canonical representation of files in the repository has changed over time (e.g. earlier commits record text files with CRLF line endings, but recent ones use LF line endings). In such a repository, Git can convert the data recorded in commits to a canonical form before performing a merge to reduce unnecessary conflicts. For more information, see section &quot;Merging branches with differing checkin/checkout attributes&quot; in &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;.</source>
          <target state="translated">저장소에서 파일의 표준 표현은 시간이 지남에 따라 변경되었다고 알려주십시오 (예 : 이전에는 CRLF 줄 끝을 가진 레코드 텍스트 파일을 커밋하지만 최근 파일은 LF 줄 끝을 사용합니다). 이러한 리포지토리에서 Git은 병합을 수행하기 전에 커밋에 기록 된 데이터를 표준 형식으로 변환하여 불필요한 충돌을 줄입니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]의&lt;/a&gt; &quot;다른 체크인 / 체크 아웃 속성으로 분기 병합&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5b3a0f2444b1d5713e25e3bc88878530e280cdf" translate="yes" xml:space="preserve">
          <source>Tell Git to use it.</source>
          <target state="translated">Git에게 사용하도록 지시하십시오.</target>
        </trans-unit>
        <trans-unit id="bebd78f164bb96ec184a42572b9740f676dbf149" translate="yes" xml:space="preserve">
          <source>Tell cvsexportcommit that the current working directory is not only a Git checkout, but also the CVS checkout. Therefore, Git will reset the working directory to the parent commit before proceeding.</source>
          <target state="translated">cvsexportcommit에게 현재 작업 디렉토리가 Git 체크 아웃 일뿐만 아니라 CVS 체크 아웃임을 알려주십시오. 따라서 Git은 계속하기 전에 작업 디렉토리를 상위 커밋으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="ccc8867e7c10f12bec70f18c0ebdd4b98ffcfd5b" translate="yes" xml:space="preserve">
          <source>Tell git-credential-cache&amp;mdash;​daemon to ignore SIGHUP, instead of quitting.</source>
          <target state="translated">git-credential-cache에게 종료 대신 SIGHUP을 무시하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="500ee09ba16068aaf0936f5ee6b5ef58c4f8bd06" translate="yes" xml:space="preserve">
          <source>Tell the command to automatically stage files that have been modified and deleted, but new files you have not told Git about are not affected.</source>
          <target state="translated">수정 및 삭제 된 파일을 자동으로 스테이징하도록 명령에 지시하지만 Git에 알리지 않은 새 파일은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a69e5b7ab968a315154a9d1fd7cf0d147021841a" translate="yes" xml:space="preserve">
          <source>Telling Git about your changes.</source>
          <target state="translated">변경 사항에 대해 Git에 알리기</target>
        </trans-unit>
        <trans-unit id="52aedbe077c84f7c253f79171da85dc15b08fdf7" translate="yes" xml:space="preserve">
          <source>Telling Git your name</source>
          <target state="translated">Git에게 당신의 이름을 말</target>
        </trans-unit>
        <trans-unit id="47964a2a2b9ba19cb7edfe94ae99ae894e487ad7" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;git add&lt;/code&gt; to continue adding files when some files cannot be added due to indexing errors. Equivalent to the &lt;code&gt;--ignore-errors&lt;/code&gt; option of &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;. &lt;code&gt;add.ignore-errors&lt;/code&gt; is deprecated, as it does not follow the usual naming convention for configuration variables.</source>
          <target state="translated">지시 &lt;code&gt;git add&lt;/code&gt; 일부 파일이 인덱싱 오류로 인해 추가 할 수없는 경우 파일을 계속 추가 할 수 있습니다. &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 의 &lt;code&gt;--ignore-errors&lt;/code&gt; 옵션과 동일합니다 . &lt;code&gt;add.ignore-errors&lt;/code&gt; 는 구성 변수에 대한 일반적인 명명 규칙을 따르지 않으므로 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e23c71acb4f3fb6cc5e3124fdbba41789615dcfa" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;git apply&lt;/code&gt; how to handle whitespaces, in the same way as the &lt;code&gt;--whitespace&lt;/code&gt; option. See &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;git apply&lt;/code&gt; 에게 &lt;code&gt;--whitespace&lt;/code&gt; 옵션 과 같은 방식으로 공백을 처리하는 방법을 적용 하도록 지시 합니다. &lt;a href=&quot;git-apply&quot;&gt;git-apply [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b4fd4c56fbd55fd6a4b61da1b1b25feb1363cb0" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;git branch&lt;/code&gt;, &lt;code&gt;git switch&lt;/code&gt; and &lt;code&gt;git checkout&lt;/code&gt; to set up new branches so that &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; will appropriately merge from the starting point branch. Note that even if this option is not set, this behavior can be chosen per-branch using the &lt;code&gt;--track&lt;/code&gt; and &lt;code&gt;--no-track&lt;/code&gt; options. The valid settings are: &lt;code&gt;false&lt;/code&gt; &amp;mdash; no automatic setup is done; &lt;code&gt;true&lt;/code&gt; &amp;mdash; automatic setup is done when the starting point is a remote-tracking branch; &lt;code&gt;always&lt;/code&gt; &amp;mdash; automatic setup is done when the starting point is either a local branch or remote-tracking branch. This option defaults to true.</source>
          <target state="translated">지시 &lt;code&gt;git branch&lt;/code&gt; , &lt;code&gt;git switch&lt;/code&gt; 와 &lt;code&gt;git checkout&lt;/code&gt; 수 있도록 새로운 지점을 설정하는 &lt;a href=&quot;git-pull&quot;&gt;자식 풀 [1]&lt;/a&gt; 적절하게 시작 지점 지점에서 병합합니다. 이 옵션을 설정하지 않아도 &lt;code&gt;--track&lt;/code&gt; 및 &lt;code&gt;--no-track&lt;/code&gt; 옵션을 사용하여 지점 별로이 동작을 선택할 수 있습니다. 유효한 설정은 다음과 같습니다. &lt;code&gt;false&lt;/code&gt; &amp;mdash; 자동 설정이 수행되지 않습니다. &lt;code&gt;true&lt;/code&gt; &amp;mdash; 시작점이 원격 추적 분기 인 경우 자동 설정이 수행됩니다. &lt;code&gt;always&lt;/code&gt; &amp;mdash; 시작 지점이 로컬 지점 또는 원격 추적 지점 인 경우 자동 설정이 수행됩니다. 이 옵션의 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="33792c2c707e004799933a452c481ccd3dd6df72" translate="yes" xml:space="preserve">
          <source>Tells &lt;code&gt;merge-recursive&lt;/code&gt; to use a different diff algorithm, which can help avoid mismerges that occur due to unimportant matching lines (such as braces from distinct functions). See also &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;&lt;code&gt;--diff-algorithm&lt;/code&gt;.</source>
          <target state="translated">어떤지 &lt;code&gt;merge-recursive&lt;/code&gt; (예컨대 고유 함수로부터 교정기 등) 중요 매칭 라인 인해 발생할 않도록 mismerges 도움 DIFF 다른 알고리즘을 사용한다. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1] &lt;/a&gt; &lt;code&gt;--diff-algorithm&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="322e9bf79fc78c188017b38cca0390d8ca24df83" translate="yes" xml:space="preserve">
          <source>Tells Git if the executable bit of files in the working tree is to be honored.</source>
          <target state="translated">작업 트리에있는 파일의 실행 가능한 비트를 준수해야하는지 Git에 알립니다.</target>
        </trans-unit>
        <trans-unit id="e732c8317ebf66ceb1e3db1424bc67bd01187e09" translate="yes" xml:space="preserve">
          <source>Template directory</source>
          <target state="translated">템플릿 디렉토리</target>
        </trans-unit>
        <trans-unit id="ab43df8613b6388c0548cc8be9da228db8e98898" translate="yes" xml:space="preserve">
          <source>Temporarily setting aside work in progress</source>
          <target state="translated">진행중인 작업을 임시로 설정</target>
        </trans-unit>
        <trans-unit id="8e2754fc91f29834706af71cfa26258d56805769" translate="yes" xml:space="preserve">
          <source>Temporary files</source>
          <target state="translated">임시 파일</target>
        </trans-unit>
        <trans-unit id="9c01e9143498ee202aefdfaa27172587b4069975" translate="yes" xml:space="preserve">
          <source>Terminate entries with NUL, instead of LF. This implies the &lt;code&gt;--porcelain=v1&lt;/code&gt; output format if no other format is given.</source>
          <target state="translated">LF 대신 NUL로 항목을 종료하십시오. 다른 형식이 지정되지 않은 경우 &lt;code&gt;--porcelain=v1&lt;/code&gt; 출력 형식을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="07c6a191135373ac9d2aee0a3bde3b658792a63e" translate="yes" xml:space="preserve">
          <source>Terminate with error if there is no &lt;code&gt;done&lt;/code&gt; command at the end of the stream. This option might be useful for detecting errors that cause the frontend to terminate before it has started to write a stream.</source>
          <target state="translated">스트림 끝에 &lt;code&gt;done&lt;/code&gt; 명령 이 없으면 오류로 종료 하십시오. 이 옵션은 스트림 쓰기를 시작하기 전에 프런트 엔드가 종료되는 오류를 감지하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="cf10c8624337ce67bcf480537830a31a54a327a5" translate="yes" xml:space="preserve">
          <source>Test suites are very nice. But when they are used alone, they are supposed to be used so that all the tests are checked after each commit. This means that they are not very efficient, because many tests are run for no interesting result, and they suffer from combinatorial explosion.</source>
          <target state="translated">테스트 스위트는 매우 좋습니다. 그러나 그들이 단독으로 사용될 때, 그들은 모든 커밋 후에 모든 테스트가 확인되도록 사용되어야합니다. 이것은 많은 테스트가 흥미로운 결과를 위해 실행되지 않고 조합 폭발로 고통 받기 때문에 매우 효율적이지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c7039b793911c3e74e0619b364427be7bb23668d" translate="yes" xml:space="preserve">
          <source>Testing has been done using both the CLI CVS client, and the Eclipse CVS plugin. Most functionality works fine with both of these clients.</source>
          <target state="translated">테스트는 CLI CVS 클라이언트와 Eclipse CVS 플러그인을 모두 사용하여 수행되었습니다. 대부분의 기능은이 두 클라이언트 모두에서 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="499b8eda34fd3ef3837b1d2448aadbb6279371d8" translate="yes" xml:space="preserve">
          <source>Testing partial commits</source>
          <target state="translated">부분 커밋 테스트</target>
        </trans-unit>
        <trans-unit id="c5dcd73cdfef43c79255820898dee98a4377a12f" translate="yes" xml:space="preserve">
          <source>Text editor for use by Git commands. The value is meant to be interpreted by the shell when it is used. Examples: &lt;code&gt;~/bin/vi&lt;/code&gt;, &lt;code&gt;$SOME_ENVIRONMENT_VARIABLE&lt;/code&gt;, &lt;code&gt;&quot;C:\Program Files\Vim\gvim.exe&quot;
--nofork&lt;/code&gt;. The order of preference is the &lt;code&gt;$GIT_EDITOR&lt;/code&gt; environment variable, then &lt;code&gt;core.editor&lt;/code&gt; configuration, then &lt;code&gt;$VISUAL&lt;/code&gt;, then &lt;code&gt;$EDITOR&lt;/code&gt;, and then the default chosen at compile time, which is usually &lt;code&gt;vi&lt;/code&gt;.</source>
          <target state="translated">Git 명령에 사용되는 텍스트 편집기. 값은 사용될 때 쉘에 의해 해석됩니다. 예 : &lt;code&gt;~/bin/vi&lt;/code&gt; , &lt;code&gt;$SOME_ENVIRONMENT_VARIABLE&lt;/code&gt; , &lt;code&gt;&quot;C:\Program Files\Vim\gvim.exe&quot; --nofork&lt;/code&gt; . 우선 순위는 &lt;code&gt;$GIT_EDITOR&lt;/code&gt; 환경 변수, &lt;code&gt;core.editor&lt;/code&gt; 구성, &lt;code&gt;$VISUAL&lt;/code&gt; , &lt;code&gt;$EDITOR&lt;/code&gt; 및 컴파일시 선택된 기본값 (일반적으로 &lt;code&gt;vi&lt;/code&gt; ) 입니다.</target>
        </trans-unit>
        <trans-unit id="016aa532b4e9fa7fee1cc89b5c6aa348edd44f21" translate="yes" xml:space="preserve">
          <source>Text editor used by &lt;code&gt;git rebase -i&lt;/code&gt; for editing the rebase instruction file. The value is meant to be interpreted by the shell when it is used. It can be overridden by the &lt;code&gt;GIT_SEQUENCE_EDITOR&lt;/code&gt; environment variable. When not configured the default commit message editor is used instead.</source>
          <target state="translated">rebase 명령 파일을 편집하기 위해 &lt;code&gt;git rebase -i&lt;/code&gt; 에서 사용하는 텍스트 편집기 . 값은 사용될 때 쉘에 의해 해석됩니다. &lt;code&gt;GIT_SEQUENCE_EDITOR&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 . 구성하지 않으면 기본 커밋 메시지 편집기가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a8fe9598336f37cb9328ca8052e59b151a7933de" translate="yes" xml:space="preserve">
          <source>Text viewer for use by Git commands (e.g., &lt;code&gt;less&lt;/code&gt;). The value is meant to be interpreted by the shell. The order of preference is the &lt;code&gt;$GIT_PAGER&lt;/code&gt; environment variable, then &lt;code&gt;core.pager&lt;/code&gt; configuration, then &lt;code&gt;$PAGER&lt;/code&gt;, and then the default chosen at compile time (usually &lt;code&gt;less&lt;/code&gt;).</source>
          <target state="translated">Git 명령에 사용되는 텍스트 뷰어 (예 : &lt;code&gt;less&lt;/code&gt; ). 값은 쉘에 의해 해석됩니다. 우선 순위는 &lt;code&gt;$GIT_PAGER&lt;/code&gt; 환경 변수, &lt;code&gt;core.pager&lt;/code&gt; 구성, &lt;code&gt;$PAGER&lt;/code&gt; 및 컴파일 타임에 선택된 기본값 (보통은 &lt;code&gt;less&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="0bd1b0b7ad0ea4fe7d508b463e4e610ef00887b1" translate="yes" xml:space="preserve">
          <source>That is, a pattern followed by an attributes list, separated by whitespaces. Leading and trailing whitespaces are ignored. Lines that begin with &lt;code&gt;#&lt;/code&gt; are ignored. Patterns that begin with a double quote are quoted in C style. When the pattern matches the path in question, the attributes listed on the line are given to the path.</source>
          <target state="translated">즉, 공백으로 구분 된 패턴 뒤에 속성 목록이옵니다. 선행 및 후행 공백은 무시됩니다. &lt;code&gt;#&lt;/code&gt; 으로 시작하는 줄 은 무시됩니다. 큰 따옴표로 시작하는 패턴은 C 스타일로 인용됩니다. 패턴이 해당 경로와 일치하면 라인에 나열된 속성이 경로에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a2ed6bb3b9b6e451ccc6f660ef58cfb1d5aab73c" translate="yes" xml:space="preserve">
          <source>That is, from left to right:</source>
          <target state="translated">즉, 왼쪽에서 오른쪽으로 :</target>
        </trans-unit>
        <trans-unit id="8f093c96f9e4fd62eb55be18fd622f6079c4aad2" translate="yes" xml:space="preserve">
          <source>That is, from the left to the right:</source>
          <target state="translated">즉, 왼쪽에서 오른쪽으로</target>
        </trans-unit>
        <trans-unit id="11e8a09abfceb997eddb8423e1781ebd95db28e7" translate="yes" xml:space="preserve">
          <source>That is:</source>
          <target state="translated">그건:</target>
        </trans-unit>
        <trans-unit id="aa54aa26ef67ef77a7b5a4203a2f21478483f336" translate="yes" xml:space="preserve">
          <source>That means that even if you offer only read access (e.g. by using the pserver method), &lt;code&gt;git-cvsserver&lt;/code&gt; should have write access to the database to work reliably (otherwise you need to make sure that the database is up to date any time &lt;code&gt;git-cvsserver&lt;/code&gt; is executed).</source>
          <target state="translated">즉, 읽기 권한 만 제공하더라도 (예 : pserver 메소드 사용) &lt;code&gt;git-cvsserver&lt;/code&gt; 는 데이터베이스에 대한 쓰기 액세스 권한이 있어야 안정적으로 작업 할 수 있습니다 (그렇지 않으면 데이터베이스가 &lt;code&gt;git-cvsserver&lt;/code&gt; time 상태 일 때마다 최신 상태인지 확인해야 함) cvsserver 가 실행됩니다).</target>
        </trans-unit>
        <trans-unit id="452813997abf32b7a81b495ef3287ae8cfa66246" translate="yes" xml:space="preserve">
          <source>That means that if you do a &lt;code&gt;git read-tree -m &amp;lt;newtree&amp;gt;&lt;/code&gt; followed by a &lt;code&gt;git checkout-index -f -u -a&lt;/code&gt;, the &lt;code&gt;git checkout-index&lt;/code&gt; only checks out the stuff that really changed.</source>
          <target state="translated">즉, &lt;code&gt;git read-tree -m &amp;lt;newtree&amp;gt;&lt;/code&gt; 다음에 &lt;code&gt;git checkout-index -f -u -a&lt;/code&gt; 를 수행하면 &lt;code&gt;git checkout-index&lt;/code&gt; 는 실제로 변경된 항목 만 체크 아웃합니다.</target>
        </trans-unit>
        <trans-unit id="a1aaaec20914cfb53973b0431f384394f0c406ca" translate="yes" xml:space="preserve">
          <source>That puts the heads and tags for each fork in their own island (named &quot;1234&quot; or similar), and the pull refs for each go into their own &quot;1234-pull&quot;.</source>
          <target state="translated">그러면 각 포크의 헤드와 태그가 자체 섬 ( &quot;1234&quot;또는 이와 유사한 이름)에 배치되고 각각의 풀 참조는 자체 &quot;1234- 풀&quot;로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="767670eb6ab18d660b358046eb00166f0a64fef3" translate="yes" xml:space="preserve">
          <source>That will produce the diff between the tips of the two branches. If you&amp;rsquo;d prefer to find the diff from their common ancestor to test, you can use three dots instead of two:</source>
          <target state="translated">그러면 두 가지 끝 사이에 차이가 생깁니다. 테스트 할 공통 조상에서 diff를 찾으려면 두 개 대신 세 개의 점을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ab4548e0b841bbace5e0a92c23778ab654224e3" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s why the &quot;git replace&quot; command was created. Technically it stores replacements &quot;refs&quot; in the &quot;refs/replace/&quot; hierarchy. These &quot;refs&quot; are like branches (that are stored in &quot;refs/heads/&quot;) or tags (that are stored in &quot;refs/tags&quot;), and that means that they can automatically be shared like branches or tags among developers.</source>
          <target state="translated">이것이 &quot;git replace&quot;명령이 작성된 이유입니다. 기술적으로 &quot;refs / replace /&quot;계층에 대체 &quot;refs&quot;를 저장합니다. 이러한 &quot;refs&quot;는 브랜치 ( &quot;refs / heads /&quot;에 저장 됨) 또는 태그 ( &quot;refs / tags&quot;에 저장 됨)와 비슷하며 개발자들 사이에서 브랜치 또는 태그처럼 자동으로 공유 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7f78784e12fead6a14f302d919d7dfe2a02b05b" translate="yes" xml:space="preserve">
          <source>The &quot;child_class&quot; field is a rough classification, such as &quot;editor&quot;, &quot;pager&quot;, &quot;transport/*&quot;, and &quot;hook&quot;. Unclassified children are classified with &quot;?&quot;.</source>
          <target state="translated">&quot;child_class&quot;필드는 &quot;editor&quot;, &quot;pager&quot;, &quot;transport / *&quot;및 &quot;hook&quot;과 같은 대략적인 분류입니다. 분류되지 않은 어린이는 &quot;?&quot;로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="fe5496d60fae83b54bfa30bb265cd284e395a597" translate="yes" xml:space="preserve">
          <source>The &quot;child_id&quot; field can be used to match this child_start with the corresponding child_exit event.</source>
          <target state="translated">&quot;child_id&quot;필드는이 child_start를 해당 child_exit 이벤트와 일치시키는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ee1a593683be8a9c62bf7139373ea713a6461c3" translate="yes" xml:space="preserve">
          <source>The &quot;commit&quot; object links a physical state of a tree with a description of how we got there and why. Use the &lt;code&gt;--pretty=raw&lt;/code&gt; option to &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; or &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; to examine your favorite commit:</source>
          <target state="translated">&quot;commit&quot;객체는 트리의 물리적 상태를 우리가 도착한 방법과 이유에 대한 설명과 연결합니다. &lt;code&gt;--pretty=raw&lt;/code&gt; 옵션을 사용하여 &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 을 사용하여 선호하는 커밋을 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="6db6601ce62b96f9f8fba54efac9ee5967a731f4" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; value consists of a list of triplets in the form &lt;code&gt;(&quot;&amp;lt;label&amp;gt;&quot;, &quot;&amp;lt;link&amp;gt;&quot;, &quot;&amp;lt;position&amp;gt;&quot;)&lt;/code&gt; where &quot;position&quot; is the label after which to insert the link, &quot;link&quot; is a format string where &lt;code&gt;%n&lt;/code&gt; expands to the project name, &lt;code&gt;%f&lt;/code&gt; to the project path within the filesystem (i.e. &quot;$projectroot/$project&quot;), &lt;code&gt;%h&lt;/code&gt; to the current hash ('h' gitweb parameter) and &lt;code&gt;%b&lt;/code&gt; to the current hash base ('hb' gitweb parameter); &lt;code&gt;%%&lt;/code&gt; expands to '%'.</source>
          <target state="translated">&quot;default&quot;값은 &lt;code&gt;(&quot;&amp;lt;label&amp;gt;&quot;, &quot;&amp;lt;link&amp;gt;&quot;, &quot;&amp;lt;position&amp;gt;&quot;)&lt;/code&gt; 형식의 트리플렛 목록으로 구성됩니다. 여기서 &quot;position&quot;은 &quot;link&quot;링크를 삽입 한 후의 레이블입니다. 포맷 문자열 &lt;code&gt;%n&lt;/code&gt; 프로젝트 이름으로 확장, &lt;code&gt;%f&lt;/code&gt; 파일 시스템 내의 프로젝트 경로 (즉, &quot;$ projectroot / $ 프로젝트&quot;), 행 &lt;code&gt;%h&lt;/code&gt; 현재 해시 ( 'H'gitweb 파라미터) 및 &lt;code&gt;%b&lt;/code&gt; 로는 현재 해시베이스 ( 'hb'gitweb 매개 변수); &lt;code&gt;%%&lt;/code&gt; 는 '%'로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="a92a8477d5d97d17f1c481b90522235992b0aec5" translate="yes" xml:space="preserve">
          <source>The &quot;delete&quot; subcommand deletes single entries from the reflog. Its argument must be an &lt;code&gt;exact&lt;/code&gt; entry (e.g. &quot;&lt;code&gt;git reflog delete
master@{2}&lt;/code&gt;&quot;). This subcommand is also typically not used directly by end users.</source>
          <target state="translated">&quot;delete&quot;부속 명령은 참조 로그에서 단일 항목을 삭제합니다. 인수는 &lt;code&gt;exact&lt;/code&gt; 항목 이어야합니다 (예 : &quot; &lt;code&gt;git reflog delete master@{2}&lt;/code&gt; &quot;). 이 하위 명령은 일반적으로 최종 사용자가 직접 사용하지도 않습니다.</target>
        </trans-unit>
        <trans-unit id="15cc724d6cfbdaca681c81ec6b39527ea7ba3e75" translate="yes" xml:space="preserve">
          <source>The &quot;downwards graduation&quot; discussed above cannot be done by actually merging downwards, however, since that would merge &lt;code&gt;all&lt;/code&gt; changes on the unstable branch into the stable one. Hence the following:</source>
          <target state="translated">위에서 논의한 &quot;아래로 눈금&quot;은 실제로 아래쪽으로 병합하여 수행 할 수 없습니다 . 불안정한 지점의 &lt;code&gt;all&lt;/code&gt; 변경 사항이 안정적인 지점으로 병합되기 때문입니다 . 따라서 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b681909e4d1085f8faa13044f43a355b4e9ca0a" translate="yes" xml:space="preserve">
          <source>The &quot;exec&quot; command launches the command in a shell (the one specified in &lt;code&gt;$SHELL&lt;/code&gt;, or the default shell if &lt;code&gt;$SHELL&lt;/code&gt; is not set), so you can use shell features (like &quot;cd&quot;, &quot;&amp;gt;&quot;, &quot;;&quot; &amp;hellip;​). The command is run from the root of the working tree.</source>
          <target state="translated">&quot;exec&quot;명령은 쉘 ( &lt;code&gt;$SHELL&lt;/code&gt; 지정된 명령 또는 &lt;code&gt;$SHELL&lt;/code&gt; 이 설정되지 않은 경우 기본 쉘) 에서 명령을 실행 하므로 쉘 기능 (예 : &quot;cd&quot;, &quot;&amp;gt;&quot;, &quot;;&quot;)을 사용할 수 있습니다. &amp;hellip;). 작업 트리의 루트에서 명령이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="3e27bb28ac33a3ed0da91ec19b0543d1741f2754" translate="yes" xml:space="preserve">
          <source>The &quot;exec_id&quot; field is a command-unique id and is only useful if the &lt;code&gt;exec()&lt;/code&gt; fails and a corresponding exec_result event is generated.</source>
          <target state="translated">&quot;exec_id&quot;필드는 명령 고유 ID이며 &lt;code&gt;exec()&lt;/code&gt; 가 실패하고 해당 exec_result 이벤트가 생성 된 경우에만 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="111dec81403753e6a7d49025386f92b4f5a7ce80" translate="yes" xml:space="preserve">
          <source>The &quot;exists&quot; subcommand checks whether a ref has a reflog. It exits with zero status if the reflog exists, and non-zero status if it does not.</source>
          <target state="translated">&quot;exists&quot;부속 명령은 ref에 reflog가 있는지 점검합니다. reflog가 존재하면 상태가 0이고, 존재하지 않으면 0이 아닌 상태로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="b084a3a2964fff409a1c4bd5eaf3ff2af985bb46" translate="yes" xml:space="preserve">
          <source>The &quot;experimental&quot; branch is the one you just created, and the &quot;master&quot; branch is a default branch that was created for you automatically. The asterisk marks the branch you are currently on; type</source>
          <target state="translated">&quot;실험&quot;브랜치는 방금 만든 브랜치이며 &quot;마스터&quot;브랜치는 자동으로 생성 된 기본 브랜치입니다. 별표는 현재있는 지점을 표시합니다. 유형</target>
        </trans-unit>
        <trans-unit id="8a5c55e5646a8a6620c2e2207d5f34af5eadc4f2" translate="yes" xml:space="preserve">
          <source>The &quot;expire&quot; subcommand prunes older reflog entries. Entries older than &lt;code&gt;expire&lt;/code&gt; time, or entries older than &lt;code&gt;expire-unreachable&lt;/code&gt; time and not reachable from the current tip, are removed from the reflog. This is typically not used directly by end users &amp;mdash; instead, see &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">&quot;expire&quot;부속 명령은 이전 reflog 항목을 제거합니다. &lt;code&gt;expire&lt;/code&gt; 시간이 지난 항목 또는 &lt;code&gt;expire-unreachable&lt;/code&gt; 시간이 지난 항목 과 현재 팁에서 도달 할 수 없는 항목 은 reflog에서 제거됩니다. 일반적으로 최종 사용자가 직접 사용하지는 않으며 &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51ddfbdb206861a134ce9d36a0cd6f8dcb912a92" translate="yes" xml:space="preserve">
          <source>The &quot;extent of changes&quot; parameter can be tweaked from the default 80% (that is, unless more than 80% of the original material is deleted, the broken pairs are merged back into a single modification) by giving a second number to -B option, like these:</source>
          <target state="translated">-B에 두 번째 숫자를 부여하여 &quot;변경 범위&quot;매개 변수를 기본값 80 %에서 조정할 수 있습니다 (즉, 원본 재질의 80 % 이상이 삭제되지 않는 경우 깨진 쌍이 단일 수정으로 다시 병합 됨). 다음과 같은 옵션 :</target>
        </trans-unit>
        <trans-unit id="4be913eb74285fc0f11c845775de3706d8e8ac4f" translate="yes" xml:space="preserve">
          <source>The &quot;git-diff-tree&quot; command begins its output by printing the hash of what is being compared. After that, all the commands print one output line per changed file.</source>
          <target state="translated">&quot;git-diff-tree&quot;명령은 비교 대상의 해시를 인쇄하여 출력을 시작합니다. 그 후, 모든 명령은 변경된 파일 당 하나의 출력 행을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="14e841537fdff67ebd6d58e11774065ab0f0ebfa" translate="yes" xml:space="preserve">
          <source>The &quot;indent&quot; filter is well-behaved in this regard: it will not modify input that is already correctly indented. In this case, the lack of a smudge filter means that the clean filter &lt;code&gt;must&lt;/code&gt; accept its own output without modifying it.</source>
          <target state="translated">&quot;들여 쓰기&quot;필터는 이와 관련하여 잘 작동합니다. 이미 올바르게 들여 쓰기 된 입력은 수정하지 않습니다. 이 경우 스미 지 필터가 없으면 클린 필터 &lt;code&gt;must&lt;/code&gt; 수정하지 않고 자체 출력을 수용 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="2a9f18fc49cc181471bfbc97a47a88e9bcc1179f" translate="yes" xml:space="preserve">
          <source>The &quot;index&quot; holds a snapshot of the content of the working tree, and it is this snapshot that is taken as the contents of the next commit. Thus after making any changes to the working tree, and before running the commit command, you must use the &lt;code&gt;add&lt;/code&gt; command to add any new or modified files to the index.</source>
          <target state="translated">&quot;인덱스&quot;에는 작업 트리의 내용에 대한 스냅 샷이 있으며 다음 커밋의 내용으로 사용되는 것이이 스냅 샷입니다. 따라서 작업 트리를 변경 한 후 commit 명령을 실행하기 전에 &lt;code&gt;add&lt;/code&gt; 명령을 사용하여 새 파일이나 수정 된 파일을 색인에 추가 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6b5b86b50febe55839cf4e73fade50a78b6b0a0e" translate="yes" xml:space="preserve">
          <source>The &quot;master&quot; branch that was created at the time you cloned is a copy of the HEAD in the repository that you cloned from. That repository may also have had other branches, though, and your local repository keeps branches which track each of those remote branches, called remote-tracking branches, which you can view using the &lt;code&gt;-r&lt;/code&gt; option to &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;:</source>
          <target state="translated">복제 할 때 작성된 &quot;마스터&quot;브랜치는 복제 한 저장소에있는 HEAD의 사본입니다. 그러나이 저장소에는 다른 분기가있을 수 있으며 로컬 저장소는 원격 추적 분기라고하는 각 원격 분기를 추적하는 분기를 유지합니다.이 추적은 &lt;code&gt;-r&lt;/code&gt; 옵션을 사용하여 &lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b0e05ae2162ea2794c2d7383fd67bd0eb622aa45" translate="yes" xml:space="preserve">
          <source>The &quot;name&quot; field is an arbitrary string to describe the command mode. For example, checkout can checkout a branch or an individual file. And these variations typically have different performance characteristics that are not comparable.</source>
          <target state="translated">&quot;name&quot;필드는 명령 모드를 설명하는 임의의 문자열입니다. 예를 들어, 체크 아웃은 분기 또는 개별 파일을 체크 아웃 할 수 있습니다. 이러한 변형은 일반적으로 비교할 수없는 다른 성능 특성을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd5002fa5ace7f79f3506e0a4b77fdeff5bda038" translate="yes" xml:space="preserve">
          <source>The &quot;non-cached&quot; mode takes a different approach, and is potentially the more useful of the two in that what it does can&amp;rsquo;t be emulated with a &lt;code&gt;git write-tree&lt;/code&gt; + &lt;code&gt;git diff-tree&lt;/code&gt;. Thus that&amp;rsquo;s the default mode. The non-cached version asks the question:</source>
          <target state="translated">&quot;캐시되지 않은&quot;모드는 다른 접근 방식을 취하며 &lt;code&gt;git write-tree&lt;/code&gt; + &lt;code&gt;git diff-tree&lt;/code&gt; 로 에뮬레이션 할 수 없다는 점에서 두 가지 중 더 유용합니다 . 이것이 기본 모드입니다. 캐시되지 않은 버전은 다음과 같은 질문을합니다.</target>
        </trans-unit>
        <trans-unit id="fb600e178320a3e93fbf20a6c6f69b12e2843e17" translate="yes" xml:space="preserve">
          <source>The &quot;pull&quot; command thus performs two operations: it fetches changes from a remote branch, then merges them into the current branch.</source>
          <target state="translated">따라서 &quot;pull&quot;명령은 두 가지 작업을 수행합니다. 원격 지점에서 변경 사항을 가져 와서 현재 지점으로 병합합니다.</target>
        </trans-unit>
        <trans-unit id="70b3edc9504f2665b7793306c4b0a620ef20dadb" translate="yes" xml:space="preserve">
          <source>The &quot;remote&quot; repository that is destination of a push operation. This parameter can be either a URL (see the section &lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt; below) or the name of a remote (see the section &lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt; below).</source>
          <target state="translated">푸시 조작의 대상인 &quot;원격&quot;저장소. 이 매개 변수는 URL ( 아래 &lt;a href=&quot;#URLS&quot;&gt;GIT URL&lt;/a&gt; 섹션 참조) 또는 리모컨 이름 ( 아래 섹션 &lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt; 섹션 참조) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0610be2d46404a8f9561c2512c45bc2650bc2b77" translate="yes" xml:space="preserve">
          <source>The &quot;remote&quot; repository that is the source of a fetch or pull operation. This parameter can be either a URL (see the section &lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt; below) or the name of a remote (see the section &lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt; below).</source>
          <target state="translated">페치 또는 풀 조작의 소스 인 &quot;원격&quot;저장소. 이 매개 변수는 URL ( 아래 &lt;a href=&quot;#URLS&quot;&gt;GIT URL&lt;/a&gt; 섹션 참조) 또는 리모컨 이름 ( 아래 섹션 &lt;a href=&quot;#REMOTES&quot;&gt;REMOTES&lt;/a&gt; 섹션 참조) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="672e385879e10047919cb534a388204453fa9b9b" translate="yes" xml:space="preserve">
          <source>The &quot;remote&quot; repository to query. This parameter can be either a URL or the name of a remote (see the GIT URLS and REMOTES sections of &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;).</source>
          <target state="translated">조회 할 &quot;원격&quot;저장소. 이 매개 변수는 URL이거나 원격의 이름 일 수 있습니다 ( &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 의 GIT URLS 및 REMOTES 섹션 참조 ).</target>
        </trans-unit>
        <trans-unit id="c6967bbb137406cb4cb1860aeca604a66e63b551" translate="yes" xml:space="preserve">
          <source>The &quot;show&quot; subcommand (which is also the default, in the absence of any subcommands) shows the log of the reference provided in the command-line (or &lt;code&gt;HEAD&lt;/code&gt;, by default). The reflog covers all recent actions, and in addition the &lt;code&gt;HEAD&lt;/code&gt; reflog records branch switching. &lt;code&gt;git reflog show&lt;/code&gt; is an alias for &lt;code&gt;git log -g --abbrev-commit
--pretty=oneline&lt;/code&gt;; see &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for more information.</source>
          <target state="translated">&quot;show&quot;하위 명령 (하위 명령이없는 경우 기본값 임)은 명령 줄에 제공된 참조 로그 (또는 기본적으로 &lt;code&gt;HEAD&lt;/code&gt; )를 표시합니다. reflog는 모든 최근 조치를 다루며 &lt;code&gt;HEAD&lt;/code&gt; reflog는 분기 전환을 기록합니다. &lt;code&gt;git reflog show&lt;/code&gt; 는 &lt;code&gt;git log -g --abbrev-commit --pretty=oneline&lt;/code&gt; 의 별칭입니다 . 자세한 내용은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9f44e4ac17ec1a545f86623659c266196a2646a2" translate="yes" xml:space="preserve">
          <source>The &quot;status&quot; command is a useful way to get a quick summary of the situation:</source>
          <target state="translated">&quot;status&quot;명령은 상황을 빠르게 요약 할 수있는 유용한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="97877392fd9cfcae446bf7fdee6a5be7af0d7e1e" translate="yes" xml:space="preserve">
          <source>The &quot;tar.gz&quot; and &quot;tgz&quot; formats are defined automatically and default to &lt;code&gt;gzip -cn&lt;/code&gt;. You may override them with custom commands.</source>
          <target state="translated">&quot;tar.gz&quot;및 &quot;tgz&quot;형식은 자동으로 정의되며 기본값은 &lt;code&gt;gzip -cn&lt;/code&gt; 입니다. 사용자 정의 명령으로이를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de5a671425f0a835fc1aa7cc9c82d529d93b1856" translate="yes" xml:space="preserve">
          <source>The &quot;tree&quot; object here refers to the new state of the tree:</source>
          <target state="translated">여기서 &quot;트리&quot;개체는 트리의 새로운 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e01253337b76bf7642cbcef035c48eb0188a2f7d" translate="yes" xml:space="preserve">
          <source>The &quot;value&quot; field may be an integer or a string.</source>
          <target state="translated">&quot;값&quot;필드는 정수 또는 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38b8f4a1de6f86897b3e2a50acc4b0dda41fe280" translate="yes" xml:space="preserve">
          <source>The &amp;lt;dataref&amp;gt; represents the blob, tree, or commit object at &amp;lt;path&amp;gt; and can be used in later &lt;code&gt;get-mark&lt;/code&gt;, &lt;code&gt;cat-blob&lt;/code&gt;, &lt;code&gt;filemodify&lt;/code&gt;, or &lt;code&gt;ls&lt;/code&gt; commands.</source>
          <target state="translated">&amp;lt;dataref&amp;gt;는 &amp;lt;path&amp;gt;의 blob, tree 또는 commit 객체를 나타내며 나중에 &lt;code&gt;get-mark&lt;/code&gt; , &lt;code&gt;cat-blob&lt;/code&gt; , &lt;code&gt;filemodify&lt;/code&gt; 또는 &lt;code&gt;ls&lt;/code&gt; 명령에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="118ecd88d0a05a5c1cb4a877b8fac543b0b9ad8d" translate="yes" xml:space="preserve">
          <source>The &amp;lt;dst&amp;gt; tells which ref on the remote side is updated with this push. Arbitrary expressions cannot be used here, an actual ref must be named. If &lt;code&gt;git push [&amp;lt;repository&amp;gt;]&lt;/code&gt; without any &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; argument is set to update some ref at the destination with &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; with &lt;code&gt;remote.&amp;lt;repository&amp;gt;.push&lt;/code&gt; configuration variable, &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; part can be omitted&amp;mdash;​such a push will update a ref that &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; normally updates without any &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; on the command line. Otherwise, missing &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; means to update the same ref as the &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;dst&amp;gt;는이 푸시로 업데이트 된 원격 측의 참조를 알려줍니다. 여기서는 임의의 표현식을 사용할 수 없으며 실제 참조 이름을 지정해야합니다. 만일 &lt;code&gt;git push [&amp;lt;repository&amp;gt;]&lt;/code&gt; 어떤없이 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 인수와 목적지 일부 REF를 업데이트하도록 설정 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 와 &lt;code&gt;remote.&amp;lt;repository&amp;gt;.push&lt;/code&gt; 구성 변수 &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; 부분 omitted- 될 수 그러한 push는 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 가 일반적으로 명령 줄에 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 없이 업데이트되는 참조를 업데이트합니다 . 그렇지 않으면, 누락 &lt;code&gt;:&amp;lt;dst&amp;gt;&lt;/code&gt; 는 &lt;code&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 와 동일한 참조를 업데이트하는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="a11f746174b65907575be3c7e94b2869a6db53ed" translate="yes" xml:space="preserve">
          <source>The &amp;lt;feature&amp;gt; part of the command may be any one of the following:</source>
          <target state="translated">명령의 &amp;lt;feature&amp;gt; 부분은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12c10723a00c71e41369dc4ab439f9bc656fc9a7" translate="yes" xml:space="preserve">
          <source>The &amp;lt;file&amp;gt; list given to the command can be exact pathnames, file glob patterns, or leading directory names. The command removes only the paths that are known to Git. Giving the name of a file that you have not told Git about does not remove that file.</source>
          <target state="translated">명령에 제공된 &amp;lt;file&amp;gt; 목록은 정확한 경로 이름, 파일 glob 패턴 또는 선행 디렉토리 이름 일 수 있습니다. 이 명령은 Git에 알려진 경로 만 제거합니다. Git에 알리지 않은 파일 이름을 제공해도 해당 파일은 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9a9d78d51370431396c79c2da7d525a4215ec53" translate="yes" xml:space="preserve">
          <source>The &amp;lt;paths&amp;gt; parameters, when given, are used to limit the diff to the named paths (you can give directory names and get diff for all files under them).</source>
          <target state="translated">&amp;lt;paths&amp;gt; 매개 변수는 주어진 경우 diff를 명명 된 경로로 제한하는 데 사용됩니다 (디렉토리 이름을 지정하고 그 아래의 모든 파일에 대해 diff를 얻을 수 있음).</target>
        </trans-unit>
        <trans-unit id="be0e9224a3c31468000ef31d0ee2d41289501c7f" translate="yes" xml:space="preserve">
          <source>The &amp;lt;src&amp;gt; is often the name of the branch you would want to push, but it can be any arbitrary &quot;SHA-1 expression&quot;, such as &lt;code&gt;master~4&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt; (see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;).</source>
          <target state="translated">&amp;lt;src&amp;gt;는 종종 푸시하려는 브랜치의 이름이지만 &lt;code&gt;master~4&lt;/code&gt; 또는 &lt;code&gt;HEAD&lt;/code&gt; 와 같은 임의의 &quot;SHA-1 표현식&quot;일 수 있습니다 ( &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="94b79c58bc3ec3bceec3b732165a2a52f94063c6" translate="yes" xml:space="preserve">
          <source>The &amp;lt;type&amp;gt; object &amp;lt;object&amp;gt;, is present in the database but never &lt;code&gt;directly&lt;/code&gt; used. A dangling commit could be a root node.</source>
          <target state="translated">&amp;lt;type&amp;gt; 오브젝트 &amp;lt;object&amp;gt;는 데이터베이스에 있지만 &lt;code&gt;directly&lt;/code&gt; 사용 되지는 않습니다 . 매달려있는 커밋은 루트 노드 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c165697ba8df58634f80c6f82752d5afcdee5578" translate="yes" xml:space="preserve">
          <source>The &amp;lt;type&amp;gt; object &amp;lt;object&amp;gt;, is referred to but isn&amp;rsquo;t present in the database.</source>
          <target state="translated">&amp;lt;type&amp;gt; 객체 &amp;lt;object&amp;gt;은 (는) 데이터베이스에 참조되어 있지만 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e6573bf54036812f2655d363c6262b69c0dca40" translate="yes" xml:space="preserve">
          <source>The &amp;lt;type&amp;gt; object &amp;lt;object&amp;gt;, isn&amp;rsquo;t actually referred to directly or indirectly in any of the trees or commits seen. This can mean that there&amp;rsquo;s another root node that you&amp;rsquo;re not specifying or that the tree is corrupt. If you haven&amp;rsquo;t missed a root node then you might as well delete unreachable nodes since they can&amp;rsquo;t be used.</source>
          <target state="translated">&amp;lt;type&amp;gt; 객체 &amp;lt;object&amp;gt;는 실제로 보이는 트리 나 커밋에서 직접 또는 간접적으로 참조되지 않습니다. 이것은 지정하지 않은 다른 루트 노드가 있거나 트리가 손상되었음을 의미 할 수 있습니다. 루트 노드를 놓치지 않았다면 도달 할 수없는 노드는 사용할 수 없으므로 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afa0888330a84b7e0fff615f1c9b8a57ecf94505" translate="yes" xml:space="preserve">
          <source>The 'git sh-i18n scriptlet is designed to be sourced (using &lt;code&gt;.&lt;/code&gt;) by Git&amp;rsquo;s porcelain programs implemented in shell script. It provides wrappers for the GNU &lt;code&gt;gettext&lt;/code&gt; and &lt;code&gt;eval_gettext&lt;/code&gt; functions accessible through the &lt;code&gt;gettext.sh&lt;/code&gt; script, and provides pass-through fallbacks on systems without GNU gettext.</source>
          <target state="translated">'git sh-i18n 스크립틀릿은 쉘 스크립트로 구현 된 Git의 도자기 프로그램에 의해 ( &lt;code&gt;.&lt;/code&gt; 를 사용하여 ) 제공되도록 설계되었습니다 . &lt;code&gt;gettext.sh&lt;/code&gt; 스크립트를 통해 액세스 할 수 있는 GNU &lt;code&gt;gettext&lt;/code&gt; 및 &lt;code&gt;eval_gettext&lt;/code&gt; 함수에 대한 랩퍼를 제공하고 GNU gettext가 없는 시스템에서 패스 스루 폴백을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="75c51ca5866a2731f86888419b9fb61d16567aec" translate="yes" xml:space="preserve">
          <source>The (fully qualified) refname from which to show notes when showing commit messages. The value of this variable can be set to a glob, in which case notes from all matching refs will be shown. You may also specify this configuration variable several times. A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.</source>
          <target state="translated">커밋 메시지를 표시 할 때 메모를 표시 할 정규화 된 refname입니다. 이 변수의 값은 glob로 설정 될 수 있으며,이 경우 일치하는 모든 참조의 노트가 표시됩니다. 이 구성 변수를 여러 번 지정할 수도 있습니다. 존재하지 않는 심판에 대해서는 경고가 표시되지만 어떤 심판과도 일치하지 않는 글롭은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1e4ce979f13cefaaddaddc6c3ce47e1170286daa" translate="yes" xml:space="preserve">
          <source>The (possibly remote) repository to clone from. See the &lt;a href=&quot;#URLS&quot;&gt;GIT URLS&lt;/a&gt; section below for more information on specifying repositories.</source>
          <target state="translated">복제 할 원격 저장소입니다. 참고 항목 &lt;a href=&quot;#URLS&quot;&gt;GIT 된 URL&lt;/a&gt; 저장소 지정에 대한 자세한 내용은 아래 절을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0958323d0ba18cc1a0d938e257756d1659d52ec9" translate="yes" xml:space="preserve">
          <source>The --exclude-existing form is a filter that does the inverse. It reads refs from stdin, one ref per line, and shows those that don&amp;rsquo;t exist in the local repository.</source>
          <target state="translated">--exclude-existing 형식은 반대로하는 필터입니다. stdin에서 refs, 한 줄에 하나의 ref를 읽고 로컬 저장소에없는 ref를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="dba5b453028e9c1f44e735e38e787a98b0046edc" translate="yes" xml:space="preserve">
          <source>The --no-signoff option can be used to countermand an earlier --signoff option on the command line.</source>
          <target state="translated">--no-signoff 옵션은 명령 줄에서 이전의 --signoff 옵션에 대응하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a043107d8410def266c54e81fdffaefcdaf6dd4c" translate="yes" xml:space="preserve">
          <source>The --smtp-server-option option must be repeated for each option you want to pass to the server. Likewise, different lines in the configuration files must be used for each option.</source>
          <target state="translated">서버에 전달하려는 각 옵션에 대해 --smtp-server-option 옵션을 반복해야합니다. 마찬가지로, 각 옵션마다 구성 파일의 다른 행을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b478196a2fb02489b622996c5ea9b31713647e4d" translate="yes" xml:space="preserve">
          <source>The .git location may be auto-discovered, or come from &lt;code&gt;$GIT_DIR&lt;/code&gt; environment variable. If the repository is auto discovered via a .git file (e.g. from submodules, or a linked worktree), the .git location would be the final location where the .git directory is, not where the .git file is.</source>
          <target state="translated">.git 위치는 자동 검색되거나 &lt;code&gt;$GIT_DIR&lt;/code&gt; 환경 변수 에서 제공 될 수 있습니다 . .git 파일을 통해 리포지토리가 자동으로 검색되면 (예 : 하위 모듈 또는 연결된 작업 트리에서) .git 위치는 .git 파일이 아닌 .git 디렉토리가있는 최종 위치가됩니다.</target>
        </trans-unit>
        <trans-unit id="489d70f8c8831a28cdf6bb81a4079dab3fec8b7e" translate="yes" xml:space="preserve">
          <source>The 40-hex object name of the object.</source>
          <target state="translated">개체의 40 진수 개체 이름입니다.</target>
        </trans-unit>
        <trans-unit id="edba0bac58d4604af8b0ccc3234ca39328b25c20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt; command can create a tar or zip archive from any version of a project; for example:</source>
          <target state="translated">&lt;a href=&quot;git-archive&quot;&gt;자식 아카이브 [1]&lt;/a&gt; 명령은 타르를 생성하거나 프로젝트의 모든 버전에서 보관할 수 지퍼; 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ff01ddb94fa5e45588517f77b5eb76be2068bf4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt; command correctly handles history that includes merge commits. However, when the commit that it finds is a merge commit, the user may need to work harder than usual to figure out why that commit introduced a problem.</source>
          <target state="translated">&lt;a href=&quot;git-bisect&quot;&gt;자식-이등분 [1]&lt;/a&gt; 병합 커밋 명령을 포함하고 정확하게 기록 핸들. 그러나 찾은 커밋이 병합 커밋 인 경우 사용자는 커밋이 문제를 일으킨 이유를 파악하기 위해 평소보다 더 열심히 노력해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1047413b5c194a852bce97f1a7a5b5c064c8f0a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt; command can show the contents of any object, though the higher-level &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; is usually more useful.</source>
          <target state="translated">&lt;a href=&quot;git-cat-file&quot;&gt;자식 고양이 파일 [1]&lt;/a&gt; 높은 수준이지만 명령은 모든 개체의 내용을 표시 할 수 있습니다 &lt;a href=&quot;git-show&quot;&gt;자식 쇼 [1]&lt;/a&gt; 일반적으로 더 유용하다.</target>
        </trans-unit>
        <trans-unit id="0ea75322cb21a3c3c8fac48d1e6228de3fae3cce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; command allows constructing commits with arbitrary parents and trees.</source>
          <target state="translated">&lt;a href=&quot;git-commit-tree&quot;&gt;자식 커밋 트리 [1]&lt;/a&gt; 명령은 임의의 부모와 나무와 커밋을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efc26cd7227657520a6926ebb23db38544c357a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-describe&quot;&gt;git-describe[1]&lt;/a&gt; command does the opposite, naming the revision using a tag on which the given commit is based:</source>
          <target state="translated">&lt;a href=&quot;git-describe&quot;&gt;자식이-설명 [1]&lt;/a&gt; 명령이 주어진 기반 커밋 된 태그를 사용하여 수정 명명 반대을 수행</target>
        </trans-unit>
        <trans-unit id="9903942bbbf43f525c7cf036d25898c86f9d9d7c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt; command runs a number of self-consistency checks on the repository, and reports on any problems. This may take some time.</source>
          <target state="translated">&lt;a href=&quot;git-fsck&quot;&gt;자식 - fsck를 [1]&lt;/a&gt; 명령은 저장소에 자기 일관성 검사의 숫자를 실행하고, 문제에 대한 보고서. 시간이 좀 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff835519b77a7ea3e8c99474cee535ec38ab3bd6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt; command will sometimes complain about dangling objects. They are not a problem.</source>
          <target state="translated">&lt;a href=&quot;git-fsck&quot;&gt;자식 - fsck를 [1]&lt;/a&gt; 명령은 때때로 객체를 매달려에 대해 불평 할 것이다. 그들은 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d818a9097a56e35195bf0f4a41317be4c1298cc7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt; command performs packing, pruning, and more for you, so is normally the only high-level command you need.</source>
          <target state="translated">&lt;a href=&quot;git-gc&quot;&gt;자식-GC [1]&lt;/a&gt; 명령 수행은 포장 치기, 그리고 더 많은 당신을 위해, 그래서 당신이 필요로하는 유일한 높은 수준의 명령이 일반적이다.</target>
        </trans-unit>
        <trans-unit id="7674cbc9fda493edc257e040882a4d3b2fee5da7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; command provides a simple way to start browsing the repository using gitweb. The default server when using instaweb is lighttpd.</source>
          <target state="translated">&lt;a href=&quot;git-instaweb&quot;&gt;자식-instaweb [1]&lt;/a&gt; 명령 gitweb를 사용하여 저장소를 탐색을 시작하는 간단한 방법을 제공한다. Instaweb을 사용할 때의 기본 서버는 lighttpd입니다.</target>
        </trans-unit>
        <trans-unit id="3d865565a2d1aab8d65d5524c33990e3ecd5eee4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; and &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; commands also provide special help for merges:</source>
          <target state="translated">&lt;a href=&quot;git-log&quot;&gt;자식 로그 [1]&lt;/a&gt; 및 &lt;a href=&quot;gitk&quot;&gt;gitk이 명령은 [1]&lt;/a&gt; 명령은 병합을위한 특별한 도움을 제공 :</target>
        </trans-unit>
        <trans-unit id="869571e8bf360d23843fed69fde509a99aec51ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; command can show lists of commits. On its own, it shows all commits reachable from the parent commit; but you can also make more specific requests:</source>
          <target state="translated">&lt;a href=&quot;git-log&quot;&gt;자식 로그 [1]&lt;/a&gt; 명령은 커밋의 목록을 표시 할 수 있습니다. 자체적으로 상위 커밋에서 도달 가능한 모든 커밋을 보여줍니다. 그러나 더 구체적인 요청을 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="49730fd39b9c73a554b2cce254c7d8e26a1047e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt; command is a low-level command that is occasionally useful for translating some name for a commit to the object name for that commit:</source>
          <target state="translated">&lt;a href=&quot;git-rev-parse&quot;&gt;자식 반전 파싱 [1]&lt;/a&gt; 명령 커밋에 대한 오브젝트 명에 커밋위한 몇몇 이름 번역을위한 때때로 유용 로우 레벨 명령이다 :</target>
        </trans-unit>
        <trans-unit id="d0ac1c8438cdf91fddee2ad5a2dd381f720a6756" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; command is available since Git 1.5.3. Users with Git 1.5.2 can look up the submodule commits in the repository and manually check them out; earlier versions won&amp;rsquo;t recognize the submodules at all.</source>
          <target state="translated">&lt;a href=&quot;git-submodule&quot;&gt;자식 - 서브 모듈 [1]&lt;/a&gt; 명령 힘내 1.5.3 때문에 가능하다. Git 1.5.2 사용자는 저장소에서 서브 모듈 커밋을 찾아 수동으로 체크 아웃 할 수 있습니다. 이전 버전에서는 하위 모듈을 전혀 인식하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="8ffc16af4f4197ccdbaaceb3fe6721dcc4562d83" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; command updates the index with information from the working directory. You generally update the index information by just specifying the filename you want to update, like so:</source>
          <target state="translated">&lt;a href=&quot;git-update-index&quot;&gt;자식 업데이트 인덱스 [1]&lt;/a&gt; 명령은 작업 디렉토리 정보로 인덱스를 업데이트합니다. 일반적으로 업데이트하려는 파일 이름을 지정하여 색인 정보를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="0eb5eb47b21a25e2f8cbcad63d82e49ed7b46c03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/newren/git-filter-repo/&quot;&gt;git filter-repo&lt;/a&gt; tool is an alternative to git-filter-branch which does not suffer from these performance problems or the safety problems (mentioned below). For those with existing tooling which relies upon git-filter-branch, &lt;code&gt;git filter-repo&lt;/code&gt; also provides &lt;a href=&quot;https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely&quot;&gt;filter-lamely&lt;/a&gt;, a drop-in git-filter-branch replacement (with a few caveats). While filter-lamely suffers from all the same safety issues as git-filter-branch, it at least ameliorates the performance issues a little.</source>
          <target state="translated">The &lt;a href=&quot;https://github.com/newren/git-filter-repo/&quot;&gt;git filter-repo&lt;/a&gt; tool is an alternative to git-filter-branch which does not suffer from these performance problems or the safety problems (mentioned below). For those with existing tooling which relies upon git-filter-branch, &lt;code&gt;git filter-repo&lt;/code&gt; also provides &lt;a href=&quot;https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely&quot;&gt;filter-lamely&lt;/a&gt;, a drop-in git-filter-branch replacement (with a few caveats). While filter-lamely suffers from all the same safety issues as git-filter-branch, it at least ameliorates the performance issues a little.</target>
        </trans-unit>
        <trans-unit id="20874526426e66810d4174f5227a378a8de7e91c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/newren/git-filter-repo/&quot;&gt;git filter-repo&lt;/a&gt; tool is an alternative to git-filter-branch which does not suffer from these performance problems or the safety problems (mentioned below). For those with existing tooling which relies upon git-filter-branch, &lt;code&gt;git repo-filter&lt;/code&gt; also provides &lt;a href=&quot;https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely&quot;&gt;filter-lamely&lt;/a&gt;, a drop-in git-filter-branch replacement (with a few caveats). While filter-lamely suffers from all the same safety issues as git-filter-branch, it at least ameliorates the performance issues a little.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/newren/git-filter-repo/&quot;&gt;자식 필터의 repo&lt;/a&gt; 도구는 이러한 성능 문제 나 안전 문제 (아래에서 설명)으로 고생하지 않는 자식 필터 - 지점의 대안입니다. 자식 필터 - 지점에 의존 기존 공구와 사람들을 위해, &lt;code&gt;git repo-filter&lt;/code&gt; 또한 제공하는 &lt;a href=&quot;https://github.com/newren/git-filter-repo/blob/master/contrib/filter-repo-demos/filter-lamely&quot;&gt;필터 lamely&lt;/a&gt; , (몇 가지주의와) 자식 필터 - 지점 드롭 인 교체. 필터는 거의 git-filter-branch와 동일한 모든 안전 문제를 겪지 만 최소한 성능 문제를 약간 개선합니다.</target>
        </trans-unit>
        <trans-unit id="ad21d56fce6cdd39ef4f92ed0708902d059eaafc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;user-manual&quot;&gt;Git User&amp;rsquo;s Manual&lt;/a&gt; provides a more comprehensive introduction to Git.</source>
          <target state="translated">&lt;a href=&quot;user-manual&quot;&gt;망할 놈의 사용 설명서는&lt;/a&gt; 힘내에 대한보다 포괄적 인 소개를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="89c784f1b1d17488cfe361d4581fd69d6d34303d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;user-manual#git-concepts&quot;&gt;Git concepts chapter of the user-manual&lt;/a&gt; and &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt; both provide introductions to the underlying Git architecture.</source>
          <target state="translated">&lt;a href=&quot;user-manual#git-concepts&quot;&gt;사용자 매뉴얼&lt;/a&gt; 및 &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial [7]&lt;/a&gt; 의 Git 개념 장은 기본 Git 아키텍처에 대한 소개를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5f7a0a0ce9975de955e97678d53d0386ebf8b091" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; file is used to define the skip-worktree reference bitmap. When Git updates the working directory, it updates the skip-worktree bits in the index based on this file. The files matching the patterns in the file will appear in the working directory, and the rest will not.</source>
          <target state="translated">&lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; 파일은 스킵-worktree 참조 비트 맵을 정의하는 데 사용됩니다. Git은 작업 디렉토리를 업데이트 할 때이 파일을 기반으로 인덱스의 skip-worktree 비트를 업데이트합니다. 파일의 패턴과 일치하는 파일이 작업 디렉토리에 나타나고 나머지는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18927ccc4077efc9fa00280f487bf7ea52068011" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;any&amp;gt;&lt;/code&gt; part of the command may contain any sequence of bytes that does not contain &lt;code&gt;LF&lt;/code&gt;. The &lt;code&gt;LF&lt;/code&gt; after the command is optional. Callers may wish to process the output through a tool such as sed to remove the leading part of the line, for example:</source>
          <target state="translated">명령 의 &lt;code&gt;&amp;lt;any&amp;gt;&lt;/code&gt; 부분에는 &lt;code&gt;LF&lt;/code&gt; 가 포함되지 않은 바이트 시퀀스가 ​​포함될 수 있습니다 . &lt;code&gt;LF&lt;/code&gt; 명령 후에는 선택 사항입니다. 발신자는 sed와 같은 도구를 통해 출력을 처리하여 회선의 앞 부분을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38ecaff497a30523addb0d68ac2f3ff7d62121ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; can be a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) or the full 40-byte SHA-1 of a Git tag, commit, or tree object, preexisting or waiting to be written. The path is relative to the top level of the tree named by &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 일 수있는 기준 마크 ( &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ) 또는 전체 40 바이트의 SHA-1 힘내 태그가 이미 존재하거나 기입하도록 대기 커밋 또는 트리 오브젝트. 경로는 &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 로 명명 된 트리의 최상위 레벨을 기준으로합니다 .</target>
        </trans-unit>
        <trans-unit id="df9429d81584e26f1a55e7eff78d6952383c6adf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; can be either a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) set previously or a full 40-byte SHA-1 of a Git blob, preexisting or ready to be written.</source>
          <target state="translated">&lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 일 수있는 기준 마크 중 ( &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ) 또는 기존 기록 할 준비가 미리 설정하거나 전체 40 바이트의 SHA-1 힘내의 블롭.</target>
        </trans-unit>
        <trans-unit id="d38490ce2af2d9b14b21e7e25c13d2a1c79c408e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; part of the command may contain any of the options listed in the OPTIONS section that do not change import semantics, without the leading &lt;code&gt;--&lt;/code&gt; and is treated in the same way.</source>
          <target state="translated">&lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 명령의 일부 선도하지 않고, 수입의 의미를 변경하지 않는 옵션 섹션에 나열된 옵션 중 하나를 포함 할 수있다 &lt;code&gt;--&lt;/code&gt; 과 같은 방식으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="73cfe0e2f7b7cccff976b7e355044194793ceedb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;pushurl&amp;gt;&lt;/code&gt; is used for pushes only. It is optional and defaults to &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;&amp;lt;pushurl&amp;gt;&lt;/code&gt; 만 밀어 사용된다. 선택 사항이며 기본값은 &lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="226bf97de37dae89426f4bcaf2c8464c2aaac4ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;rev&amp;gt;^-[&amp;lt;n&amp;gt;]&lt;/code&gt; notation includes &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; but excludes the &amp;lt;n&amp;gt;th parent (i.e. a shorthand for &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt;), with &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1 if not given. This is typically useful for merge commits where you can just pass &lt;code&gt;&amp;lt;commit&amp;gt;^-&lt;/code&gt; to get all the commits in the branch that was merged in merge commit &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; (including &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; itself).</source>
          <target state="translated">&lt;code&gt;&amp;lt;rev&amp;gt;^-[&amp;lt;n&amp;gt;]&lt;/code&gt; 표기 포함 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 대상이지만 &amp;lt;N&amp;gt; 제 부모 (즉, 쉬트를위한 &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt; 로) &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1이면 주어지지 않았습니다. 이것은 일반적으로 &lt;code&gt;&amp;lt;commit&amp;gt;^-&lt;/code&gt; 를 전달 하여 병합 커밋 &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 에 병합 된 분기의 모든 커밋 ( &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt; 자체 포함) 을 가져올 수있는 병합 커밋에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="382c52b269a126869d3f5e611e50db349c01a555" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; is just a good idea when you know the rest will be filenames; it will prevent problems with a filename of, for example, &lt;code&gt;-a&lt;/code&gt;. Using &lt;code&gt;--&lt;/code&gt; is probably a good policy in scripts.</source>
          <target state="translated">은 &lt;code&gt;--&lt;/code&gt; 당신이 나머지 파일 이름이 될 것입니다 알고 그냥 좋은 아이디어이다; 예를 들어 &lt;code&gt;-a&lt;/code&gt; 와 같은 파일 이름 문제를 방지합니다 . &lt;code&gt;--&lt;/code&gt; 사용 하는 것이 스크립트에서 좋은 정책 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="1a7c2f7d5b7ec8386e86076d812d974232af3082" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--cached&lt;/code&gt; option is used to ask a command that usually works on files in the working tree to &lt;strong&gt;only&lt;/strong&gt; work with the index. For example, &lt;code&gt;git grep&lt;/code&gt;, when used without a commit to specify from which commit to look for strings in, usually works on files in the working tree, but with the &lt;code&gt;--cached&lt;/code&gt; option, it looks for strings in the index.</source>
          <target state="translated">&lt;code&gt;--cached&lt;/code&gt; 옵션은 일반적으로 작업 트리에있는 파일에 작동하는 명령을 요청하는 데 사용됩니다 &lt;strong&gt;에만&lt;/strong&gt; 인덱스와 함께 일을. 예를 들어, &lt;code&gt;git grep&lt;/code&gt; 은 커밋없이 문자열을 찾을 커밋을 지정하면 일반적으로 작업 트리의 파일에서 작동하지만 &lt;code&gt;--cached&lt;/code&gt; 옵션을 사용하면 인덱스에서 문자열을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="93eb90d6c0bfdb16dcadbf4c72d38d80f8bf4451" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--dry-run&lt;/code&gt; option can be used to obtain a summary of what is included by any of the above for the next commit by giving the same set of parameters (options and paths).</source>
          <target state="translated">&lt;code&gt;--dry-run&lt;/code&gt; 옵션은 다음 매개 변수 (옵션 및 경로)의 동일한 세트를 제공하여 커밋 위의 모든으로 무엇이 포함되어 있는지의 요약 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45e26263ba79c46b47e35a4fe67d4d8f33b37e0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--env-filter&lt;/code&gt; option can be used to modify committer and/or author identity. For example, if you found out that your commits have the wrong identity due to a misconfigured user.email, you can make a correction, before publishing the project, like this:</source>
          <target state="translated">&lt;code&gt;--env-filter&lt;/code&gt; 옵션은 커미터 및 / 또는 저자의 정체성을 수정하는 데 사용할 수 있습니다. 예를 들어, 잘못 구성된 user.email로 인해 커밋에 잘못된 ID가있는 것을 발견 한 경우 프로젝트를 게시하기 전에 다음과 같이 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4b7635118d0a90fb277012f2d96d5181b61e4f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--index&lt;/code&gt; option is used to ask a command that usually works on files in the working tree to &lt;strong&gt;also&lt;/strong&gt; affect the index. For example, &lt;code&gt;git stash apply&lt;/code&gt; usually merges changes recorded in a stash entry to the working tree, but with the &lt;code&gt;--index&lt;/code&gt; option, it also merges changes to the index as well.</source>
          <target state="translated">&lt;code&gt;--index&lt;/code&gt; 옵션에 있음은 일반적으로 작업 트리에있는 파일에 작동하는 명령을 요청하는 데 사용됩니다 &lt;strong&gt;또한&lt;/strong&gt; 인덱스에 영향을 미칠합니다. 예를 들어, &lt;code&gt;git stash apply&lt;/code&gt; 는 일반적으로 숨김 항목에 기록 된 변경 사항을 작업 트리에 병합 하지만 &lt;code&gt;--index&lt;/code&gt; 옵션을 사용하면 변경 사항도 색인에 병합합니다.</target>
        </trans-unit>
        <trans-unit id="f5e672ca7275921f27bc57abfee8498efa38d837" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--numstat&lt;/code&gt; option gives the diffstat(1) information but is designed for easier machine consumption. An entry in &lt;code&gt;--numstat&lt;/code&gt; output looks like this:</source>
          <target state="translated">&lt;code&gt;--numstat&lt;/code&gt; 옵션은 diffstat (1) 정보를 제공하지만, 쉽게 기계 소비를 위해 설계되었습니다. &lt;code&gt;--numstat&lt;/code&gt; 출력 의 항목은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="824224d8413c92cfa07b10a7d5f109653a254225" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--patch&lt;/code&gt; option implies &lt;code&gt;--keep-index&lt;/code&gt;. You can use &lt;code&gt;--no-keep-index&lt;/code&gt; to override this.</source>
          <target state="translated">&lt;code&gt;--patch&lt;/code&gt; 옵션은 의미 &lt;code&gt;--keep-index&lt;/code&gt; . 당신은 사용할 수 있습니다 &lt;code&gt;--no-keep-index&lt;/code&gt; 이 메소드를 오버라이드 (override) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd53bf0606653a9e38fc2f67928f722d519b8437" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--prune-tags&lt;/code&gt; option is equivalent to having &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; declared in the refspecs of the remote. This can lead to some seemingly strange interactions:</source>
          <target state="translated">&lt;code&gt;--prune-tags&lt;/code&gt; 옵션은 리모컨 의 참조 사양에 &lt;code&gt;refs/tags/*:refs/tags/*&lt;/code&gt; 가 선언되어있는 것과 같습니다. 이것은 겉보기에 이상한 상호 작용으로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eedbb7a82985c4671f5041c09553972a9225fc17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--rebase-merges&lt;/code&gt; mode is similar in spirit to the deprecated &lt;code&gt;--preserve-merges&lt;/code&gt; but works with interactive rebases, where commits can be reordered, inserted and dropped at will.</source>
          <target state="translated">&lt;code&gt;--rebase-merges&lt;/code&gt; 모드는 사용되지 않는 정신에는 변함이있다 &lt;code&gt;--preserve-merges&lt;/code&gt; 하지만 커밋이 순서가 삽입 의지에 드롭 할 수있는 대화 형 rebases, 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8061f1189be4b513311a10997c4e6fc449baeaf4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--simplify-by-decoration&lt;/code&gt; option allows you to view only the big picture of the topology of the history, by omitting commits that are not referenced by tags. Commits are marked as !TREESAME (in other words, kept after history simplification rules described above) if (1) they are referenced by tags, or (2) they change the contents of the paths given on the command line. All other commits are marked as TREESAME (subject to be simplified away).</source>
          <target state="translated">&lt;code&gt;--simplify-by-decoration&lt;/code&gt; 옵션을 사용하면 태그에 의해 참조되지 않는 커밋을 생략하여, 역사의 토폴로지의 큰 그림을 볼 수 있습니다. 커밋은 (1) 태그로 참조되거나 (2) 명령 줄에 지정된 경로의 내용을 변경하는 경우! TREESAME (즉, 위에서 설명한 기록 단순화 규칙 후에 유지됨)로 표시됩니다. 다른 모든 커밋은 TREESAME로 표시됩니다 (간단히 삭제해야 함).</target>
        </trans-unit>
        <trans-unit id="16b8753fdc735c82bb8e4b4e3197e33fe132b018" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--summary&lt;/code&gt; option describes newly added, deleted, renamed and copied files. The &lt;code&gt;--stat&lt;/code&gt; option adds diffstat(1) graph to the output. These options can be combined with other options, such as &lt;code&gt;-p&lt;/code&gt;, and are meant for human consumption.</source>
          <target state="translated">&lt;code&gt;--summary&lt;/code&gt; 옵션은 새로 추가, 삭제, 파일 이름 및 복사에 대해 설명합니다. &lt;code&gt;--stat&lt;/code&gt; 옵션 출력 diffstat (1)의 그래프를 추가한다. 이러한 옵션은 &lt;code&gt;-p&lt;/code&gt; 와 같은 다른 옵션과 결합하여 사람이 소비 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="629d4eddaa3e0be951f311129548061d6a37661e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--threads&lt;/code&gt; option (and the grep.threads configuration) will be ignored when &lt;code&gt;--open-files-in-pager&lt;/code&gt; is used, forcing a single-threaded execution.</source>
          <target state="translated">The &lt;code&gt;--threads&lt;/code&gt; option (and the grep.threads configuration) will be ignored when &lt;code&gt;--open-files-in-pager&lt;/code&gt; is used, forcing a single-threaded execution.</target>
        </trans-unit>
        <trans-unit id="2fb3a538afbb18a8ca912f0cecf9a31cb6701775" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; option instructs &lt;code&gt;git config&lt;/code&gt; to ensure that incoming and outgoing values are canonicalize-able under the given &amp;lt;type&amp;gt;. If no &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; is given, no canonicalization will be performed. Callers may unset an existing &lt;code&gt;--type&lt;/code&gt; specifier with &lt;code&gt;--no-type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; 옵션을 지시 &lt;code&gt;git config&lt;/code&gt; 이 수신 및 발신 값이 주어진 &amp;lt;형&amp;gt;에서-수를 정규화를하고 있는지 확인할 수도 있습니다. 어떤 경우 &lt;code&gt;--type=&amp;lt;type&amp;gt;&lt;/code&gt; 주어지지 않는 어떤 정규화가 수행되지 않는다. 호출자는 &lt;code&gt;--no-type&lt;/code&gt; 으로 기존 &lt;code&gt;--type&lt;/code&gt; 지정자를 설정 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c9422891d35819a54a8ef0ba6d7016d122547ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-M&lt;/code&gt; and &lt;code&gt;-C&lt;/code&gt; options require O(n^2) processing time where n is the number of potential rename/copy targets. This option prevents rename/copy detection from running if the number of rename/copy targets exceeds the specified number.</source>
          <target state="translated">&lt;code&gt;-M&lt;/code&gt; 및 &lt;code&gt;-C&lt;/code&gt; 옵션 타겟 복사 / N 전위 바꾸기의 수이고 처리 시간 O (N ^ 2)을 필요로한다. 이 옵션은 이름 바꾸기 / 복사 대상 수가 지정된 수를 초과하는 경우 이름 바꾸기 / 복사 감지가 실행되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="73fff0c26b859dbfe915afb814a50fa7bc541c41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-C&lt;/code&gt; options have the exact same semantics as &lt;code&gt;-m&lt;/code&gt; and &lt;code&gt;-M&lt;/code&gt;, except instead of the branch being renamed it along with its config and reflog will be copied to a new name.</source>
          <target state="translated">&lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-C&lt;/code&gt; 옵션과 동일한 의미가 &lt;code&gt;-m&lt;/code&gt; 과 &lt;code&gt;-M&lt;/code&gt; 을 새 이름으로 복사됩니다의 설정 및 reflog와 함께 이름을 변경 분기되는 대신 제외시켰다.</target>
        </trans-unit>
        <trans-unit id="89a7df63322c3f15984d17c0e2db0a5d71e95aa3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-m&lt;/code&gt; and &lt;code&gt;-F&lt;/code&gt; options can be given any number of times, in any order. The commit log message will be composed in the order in which the options are given.</source>
          <target state="translated">&lt;code&gt;-m&lt;/code&gt; 및 &lt;code&gt;-F&lt;/code&gt; 옵션은 임의의 순서로, 여러 번을 부여 할 수 있습니다. 커밋 로그 메시지는 옵션이 주어진 순서대로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f4502e6a26132411ed2e9fd1c43849a487e5e5a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-m&lt;/code&gt; option is mutually exclusive with &lt;code&gt;-c&lt;/code&gt;, &lt;code&gt;-C&lt;/code&gt;, and &lt;code&gt;-F&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-m&lt;/code&gt; 옵션과 함께 사용할 수있다 &lt;code&gt;-c&lt;/code&gt; , &lt;code&gt;-C&lt;/code&gt; , 및 &lt;code&gt;-F&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38779d2c15d6e090718b82e6af2f8c359ec976d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.git-credentials&lt;/code&gt; file is stored in plaintext. Each credential is stored on its own line as a URL like:</source>
          <target state="translated">&lt;code&gt;.git-credentials&lt;/code&gt; 파일은 일반 텍스트로 저장됩니다. 각 자격 증명은 다음과 같은 URL로 자체 줄에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="905c63d14654cde00625cb5e82c7038bc34ea94e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.gitmodules&lt;/code&gt; file inside the superproject. A project usually uses this file to suggest defaults for the upstream collection of repositories for the mapping that is required between a submodule&amp;rsquo;s name and its path.</source>
          <target state="translated">&lt;code&gt;.gitmodules&lt;/code&gt; 는 superproject 내부 파일. 프로젝트는 일반적으로이 파일을 사용하여 서브 모듈의 이름과 경로 사이에 필요한 매핑의 업스트림 리포지토리 모음에 대한 기본값을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="0bb4fdb786947245a90430b5697a0e9422df1d21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.gitmodules&lt;/code&gt; file, located in the top-level directory of a Git working tree, is a text file with a syntax matching the requirements of &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.gitmodules&lt;/code&gt; 의 망할 놈의 작업 트리의 최상위 디렉토리에있는 파일의 요구 사항과 일치하는 구문을 사용하여 텍스트 파일입니다 &lt;a href=&quot;git-config&quot;&gt;자식-설정 [1]을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5324d8792f18dd9ac59490b336e09b1bd43353e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.mailmap&lt;/code&gt; feature is used to coalesce together commits by the same person in the shortlog, where their name and/or email address was spelled differently.</source>
          <target state="translated">&lt;code&gt;.mailmap&lt;/code&gt; 기능은 자신의 이름 및 / 또는 이메일 주소가 다르게 철자 된 shortlog에서 같은 사람에 의해 병합 함께 커밋하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="73c3a5a96a8a6a48d412facd438733454a4a63a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; ref is set to point at the commit that introduced the change that is difficult to apply.</source>
          <target state="translated">&lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; 의 심판을 가리 키도록 설정되어 적용하기 어려운 변화를 도입하는 것이 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="df208c183263acdaf73c0a978db9f5c35380bc6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; environment variables and the &lt;code&gt;--date&lt;/code&gt; option support the following date formats:</source>
          <target state="translated">&lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; 의 환경 변수와 &lt;code&gt;--date&lt;/code&gt; 옵션 지원 다음과 같은 날짜 형식 :</target>
        </trans-unit>
        <trans-unit id="ad08232602558aa9979e8ccc7bf4df9612b12ec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; environment variables support the following date formats:</source>
          <target state="translated">&lt;code&gt;GIT_AUTHOR_DATE&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_DATE&lt;/code&gt; 의 환경 변수는 다음과 같은 날짜 형식을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="9c24e5e1da9f8726ec7abe4516a017b9495c2fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; environmental variable may be passed to &lt;code&gt;git-http-backend&lt;/code&gt; to bypass the check for the &quot;git-daemon-export-ok&quot; file in each repository before allowing export of that repository.</source>
          <target state="translated">&lt;code&gt;GIT_HTTP_EXPORT_ALL&lt;/code&gt; 환경 변수에 전달 될 수 &lt;code&gt;git-http-backend&lt;/code&gt; 그 저장소의 수출을 허용하기 전에 각 저장소에 &quot;자식 - 데몬 - 수출 - 확인&quot;파일에 대한 검사 우회.</target>
        </trans-unit>
        <trans-unit id="387cfeb550226cfd9e601b1b72a83920c3f36040" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_HTTP_MAX_REQUEST_BUFFER&lt;/code&gt; environment variable (or the &lt;code&gt;http.maxRequestBuffer&lt;/code&gt; config variable) may be set to change the largest ref negotiation request that git will handle during a fetch; any fetch requiring a larger buffer will not succeed. This value should not normally need to be changed, but may be helpful if you are fetching from a repository with an extremely large number of refs. The value can be specified with a unit (e.g., &lt;code&gt;100M&lt;/code&gt; for 100 megabytes). The default is 10 megabytes.</source>
          <target state="translated">&lt;code&gt;GIT_HTTP_MAX_REQUEST_BUFFER&lt;/code&gt; 의 환경 변수 (또는 &lt;code&gt;http.maxRequestBuffer&lt;/code&gt; 설정 변수) 자식은 인출 중에 처리하는 것이 가장 REF 협상 요청을 변경하도록 설정 될 수있다; 더 큰 버퍼를 요구하는 페치는 성공하지 못합니다. 이 값은 일반적으로 변경하지 않아도되지만 참조 수가 많은 리포지토리에서 가져 오는 경우 유용 할 수 있습니다. 값은 단위로 지정할 수 있습니다 (예 : &lt;code&gt;100M&lt;/code&gt; B의 경우 100M ). 기본값은 10MB입니다.</target>
        </trans-unit>
        <trans-unit id="166eca4501cd90cd3b21f8df969c5ee397d12242" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_NO_REPLACE_OBJECTS&lt;/code&gt; environment variable can be set to achieve the same effect as the &lt;code&gt;--no-replace-objects&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;GIT_NO_REPLACE_OBJECTS&lt;/code&gt; 의 환경 변수는 동일한 효과를 달성하기 위해 설정 될 수있다 &lt;code&gt;--no-replace-objects&lt;/code&gt; 옵션.</target>
        </trans-unit>
        <trans-unit id="8bee9745a8d6377da5f35089625008b4042f0f35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GIT_PUSH_CERT*&lt;/code&gt; environment variables can be inspected, just as in &lt;code&gt;pre-receive&lt;/code&gt; hook, after accepting a signed push.</source>
          <target state="translated">&lt;code&gt;GIT_PUSH_CERT*&lt;/code&gt; 환경 변수는 단지 같이 검사 될 수있는 &lt;code&gt;pre-receive&lt;/code&gt; 서명 푸시 접수 후, 후크.</target>
        </trans-unit>
        <trans-unit id="8bc6550bd201f7a8ce8611abf35f278e4b89d03c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; pointer stays the same.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 의 포인터는 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="652c0cf20ffd72216eb399a1f559569365b85933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after &lt;code&gt;&amp;lt;delim&amp;gt; LF&lt;/code&gt; is optional (it used to be required).</source>
          <target state="translated">&lt;code&gt;LF&lt;/code&gt; 후 &lt;code&gt;&amp;lt;delim&amp;gt; LF&lt;/code&gt; 선택적이며 (이것은 필요에 사용됨).</target>
        </trans-unit>
        <trans-unit id="c1bff9f88ec1fe482fd273291dfad27de492749b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; is optional (it used to be required) but recommended. Always including it makes debugging a fast-import stream easier as the next command always starts in column 0 of the next line, even if &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; did not end with an &lt;code&gt;LF&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; 이후 의 &lt;code&gt;LF&lt;/code&gt; 는 선택 사항이지만 (필요 했음) 권장됩니다. &lt;code&gt;&amp;lt;raw&amp;gt;&lt;/code&gt; 가 &lt;code&gt;LF&lt;/code&gt; 로 끝나지 않더라도 다음 명령이 항상 다음 행의 0 열에서 시작되므로 항상이를 포함하면 빠른 가져 오기 스트림 디버깅이 쉬워집니다 .</target>
        </trans-unit>
        <trans-unit id="ec7a854b1a4c70ca562f0584186eed412906ec8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after the command is optional (it used to be required).</source>
          <target state="translated">명령 뒤 의 &lt;code&gt;LF&lt;/code&gt; 는 선택 사항입니다 (필요 했음).</target>
        </trans-unit>
        <trans-unit id="9a136595a2c2895a25e4571b5fe242dd49c2174e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LF&lt;/code&gt; after the command is optional (it used to be required). Note that for reasons of backward compatibility, if the commit ends with a &lt;code&gt;data&lt;/code&gt; command (i.e. it has no &lt;code&gt;from&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt;, &lt;code&gt;filemodify&lt;/code&gt;, &lt;code&gt;filedelete&lt;/code&gt;, &lt;code&gt;filecopy&lt;/code&gt;, &lt;code&gt;filerename&lt;/code&gt;, &lt;code&gt;filedeleteall&lt;/code&gt; or &lt;code&gt;notemodify&lt;/code&gt; commands) then two &lt;code&gt;LF&lt;/code&gt; commands may appear at the end of the command instead of just one.</source>
          <target state="translated">명령 뒤 의 &lt;code&gt;LF&lt;/code&gt; 는 선택 사항입니다 (필요 했음). 이전 버전과의 호환성을 위해 커밋이 &lt;code&gt;data&lt;/code&gt; 명령으로 끝나는 경우 (즉 , &lt;code&gt;from&lt;/code&gt; , &lt;code&gt;merge&lt;/code&gt; , &lt;code&gt;filemodify&lt;/code&gt; , &lt;code&gt;filedelete&lt;/code&gt; , &lt;code&gt;filecopy&lt;/code&gt; , &lt;code&gt;filerename&lt;/code&gt; , &lt;code&gt;filedeleteall&lt;/code&gt; 또는 &lt;code&gt;notemodify&lt;/code&gt; 명령이없는 경우) 명령 끝에 두 개의 &lt;code&gt;LF&lt;/code&gt; 명령이 나타날 수 있습니다. 단 하나 대신.</target>
        </trans-unit>
        <trans-unit id="6afb1837ee3e8f65249dcb4905156711b603dd19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MERGE_HEAD&lt;/code&gt; ref is set to point to the other branch head.</source>
          <target state="translated">&lt;code&gt;MERGE_HEAD&lt;/code&gt; 의 심판이 다른 지점 머리에 포인트로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4dcd07a8427d3cae73e7340717a2be5da78b122e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;^0&lt;/code&gt; suffix is necessary as fast-import does not permit a branch to start from itself, and the branch is created in memory before the &lt;code&gt;from&lt;/code&gt; command is even read from the input. Adding &lt;code&gt;^0&lt;/code&gt; will force fast-import to resolve the commit through Git&amp;rsquo;s revision parsing library, rather than its internal branch table, thereby loading in the existing value of the branch.</source>
          <target state="translated">&lt;code&gt;^0&lt;/code&gt; 접미사는 빠른 가져 오기 자체에서 시작하는 지점을 허용하지 않는 한 필요하고, 전 분기 메모리에 생성 &lt;code&gt;from&lt;/code&gt; 명령도 입력에서 읽습니다. &lt;code&gt;^0&lt;/code&gt; 을 추가하면 내부 가져 오기 테이블이 아닌 Git의 개정 구문 분석 라이브러리를 통해 커밋을 해결하기 위해 빠른 가져 오기를 강제 실행하여 기존 분기 값으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="675155c0bc0c9682b02ea7dc72c6fe717f8d57df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;^r1 r2&lt;/code&gt; set operation appears so often that there is a shorthand for it. When you have two commits &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; (named according to the syntax explained in SPECIFYING REVISIONS above), you can ask for commits that are reachable from r2 excluding those that are reachable from r1 by &lt;code&gt;^r1 r2&lt;/code&gt; and it can be written as &lt;code&gt;r1..r2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;^r1 r2&lt;/code&gt; 설정 동작은 너무 자주 속기있을 것으로 보인다. 커밋 &lt;code&gt;r1&lt;/code&gt; 과 &lt;code&gt;r2&lt;/code&gt; 가 두 개인 경우 (위의 사양 수정에 설명 된 구문에 따라 이름이 지정됨), r1에서 &lt;code&gt;^r1 r2&lt;/code&gt; 까지 도달 할 수있는 커밋을 제외하고 r2에서 도달 할 수있는 커밋을 요청할 수 있으며 r1 으로 쓸 수 있습니다 &lt;code&gt;r1..r2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c300333c575f956c2060e4236a825e5a15abf118" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a/&lt;/code&gt; and &lt;code&gt;b/&lt;/code&gt; filenames are the same unless rename/copy is involved. Especially, even for a creation or a deletion, &lt;code&gt;/dev/null&lt;/code&gt; is &lt;code&gt;not&lt;/code&gt; used in place of the &lt;code&gt;a/&lt;/code&gt; or &lt;code&gt;b/&lt;/code&gt; filenames.</source>
          <target state="translated">&lt;code&gt;a/&lt;/code&gt; 및 &lt;code&gt;b/&lt;/code&gt; 파일 이름 바꾸기 / 복사본을 포함하지 않는 동일하다. 특히, 작성 또는 삭제 의 경우에도 &lt;code&gt;a/&lt;/code&gt; 또는 &lt;code&gt;b/&lt;/code&gt; 파일 이름 대신 &lt;code&gt;/dev/null&lt;/code&gt; 이 사용 &lt;code&gt;not&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49bd789d4ba6e2342461dc4954bea6426d4910cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;author.name&lt;/code&gt; and &lt;code&gt;committer.name&lt;/code&gt; and their corresponding email options override &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; if set and are overridden themselves by the environment variables.</source>
          <target state="translated">The &lt;code&gt;author.name&lt;/code&gt; and &lt;code&gt;committer.name&lt;/code&gt; and their corresponding email options override &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; if set and are overridden themselves by the environment variables.</target>
        </trans-unit>
        <trans-unit id="eab33dae66d0744b7d6024e6ba0526d3cbdb099d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;base commit&lt;/code&gt; is shown as &quot;base-commit: &quot; followed by the 40-hex of the commit object name. A &lt;code&gt;prerequisite patch&lt;/code&gt; is shown as &quot;prerequisite-patch-id: &quot; followed by the 40-hex &lt;code&gt;patch id&lt;/code&gt;, which can be obtained by passing the patch through the &lt;code&gt;git patch-id --stable&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;base commit&lt;/code&gt; 커밋 객체 이름의 40 진수 뒤에 &quot;베이스 커밋&quot;로 도시되어있다. &lt;code&gt;prerequisite patch&lt;/code&gt; 40 진수 다음 &quot;필수 패치-ID '로서 도시되어 &lt;code&gt;patch id&lt;/code&gt; 관통 패치를 통과시킴으로써 얻을 수 있고, &lt;code&gt;git patch-id --stable&lt;/code&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="4310c66d08d5e3db5f29a0976c449ecfedbc1c27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;category&lt;/code&gt; field may be used in a future enhancement to do category-based filtering.</source>
          <target state="translated">&lt;code&gt;category&lt;/code&gt; 필드는 장르 기반 필터링을 할 수있는 미래의 개선에 이용 될 수있다.</target>
        </trans-unit>
        <trans-unit id="957c03f80393df2f84f209da8b3d5d5b6c66e351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;commit walkers&lt;/code&gt; are sometimes also called &lt;code&gt;dumb transports&lt;/code&gt;, because they do not require any Git aware smart server like Git Native transport does. Any stock HTTP server that does not even support directory index would suffice. But you must prepare your repository with &lt;code&gt;git update-server-info&lt;/code&gt; to help dumb transport downloaders.</source>
          <target state="translated">&lt;code&gt;commit walkers&lt;/code&gt; 때때로라고 &lt;code&gt;dumb transports&lt;/code&gt; 망할 놈의 기본 전송이하는 것처럼 그들이 어떤 망할 놈의 인식 스마트 서버를 필요로하지 않기 때문에. 디렉토리 색인을 지원하지 않는 모든 기본 HTTP 서버로 충분합니다. 그러나 멍청한 전송 다운로더를 돕기 위해 &lt;code&gt;git update-server-info&lt;/code&gt; 로 저장소를 준비해야합니다 .</target>
        </trans-unit>
        <trans-unit id="57e6853fd5f38ab3b9956fdbd165ff0d3edf841f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;commit-graph&lt;/code&gt; job updates the &lt;code&gt;commit-graph&lt;/code&gt; files incrementally, then verifies that the written data is correct. The incremental write is safe to run alongside concurrent Git processes since it will not expire &lt;code&gt;.graph&lt;/code&gt; files that were in the previous &lt;code&gt;commit-graph-chain&lt;/code&gt; file. They will be deleted by a later run based on the expiration delay.</source>
          <target state="translated">&lt;code&gt;commit-graph&lt;/code&gt; 작업은 업데이트 &lt;code&gt;commit-graph&lt;/code&gt; 기록 된 데이터가 올바른지 후, 점진적를 검증 파일을. 증분 쓰기는 이전 &lt;code&gt;commit-graph-chain&lt;/code&gt; 파일에 있던 &lt;code&gt;.graph&lt;/code&gt; 파일이 만료되지 않으므로 동시 Git 프로세스와 함께 실행하는 것이 안전 합니다. 만료 지연에 따라 나중에 실행하면 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="16292719b3497b67052d324a828a5bf607c10cb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;committer&lt;/code&gt; command indicates who made this commit, and when they made it.</source>
          <target state="translated">&lt;code&gt;committer&lt;/code&gt; 명령은이 커밋했고, 그들이 그것을 만들 때 사람을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7e0ffba56fb259ff8ccb9999d0c02587815b0675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;core.whitespace&lt;/code&gt; configuration variable allows you to define what &lt;code&gt;diff&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt; should consider whitespace errors for all paths in the project (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). This attribute gives you finer control per path.</source>
          <target state="translated">&lt;code&gt;core.whitespace&lt;/code&gt; 의 구성 변수 당신이 무엇을 정의 할 수 있습니다 &lt;code&gt;diff&lt;/code&gt; 하고 &lt;code&gt;apply&lt;/code&gt; 고려해야 공백 프로젝트의 모든 경로에 대한 오류 (참조 &lt;a href=&quot;git-config&quot;&gt;자식-설정 [1]&lt;/a&gt; ). 이 속성은 경로마다 더 세밀한 제어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="87733ffb501fc648521ef5d05fe00a159aefa171" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;credential.helper&lt;/code&gt; configuration option can also take an arbitrary shell command that produces the credential protocol on standard output. This is useful when passing credentials into a container, for example.</source>
          <target state="translated">&lt;code&gt;credential.helper&lt;/code&gt; 의 구성 옵션은 표준 출력에 자격 증명 프로토콜을 생성하는 임의의 쉘 명령을 할 수 있습니다. 예를 들어 자격 증명을 컨테이너에 전달할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c4cf312c5837f50305786c4fff7bd921da0df1e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; command following &lt;code&gt;committer&lt;/code&gt; must supply the commit message (see below for &lt;code&gt;data&lt;/code&gt; command syntax). To import an empty commit message use a 0 length data. Commit messages are free-form and are not interpreted by Git. Currently they must be encoded in UTF-8, as fast-import does not permit other encodings to be specified.</source>
          <target state="translated">&lt;code&gt;committer&lt;/code&gt; 다음 의 &lt;code&gt;data&lt;/code&gt; 명령 은 커밋 메시지를 제공해야합니다 ( &lt;code&gt;data&lt;/code&gt; 명령 구문 은 아래 참조 ). 빈 커밋 메시지를 가져 오려면 길이가 0 인 데이터를 사용하십시오. 커밋 메시지는 자유 형식이며 Git이 해석하지 않습니다. 빠른 가져 오기에서는 다른 인코딩을 지정할 수 없으므로 현재 UTF-8로 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe1dcaff1f205cb554cce0caa7f556f5b3750431" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; command following &lt;code&gt;tagger&lt;/code&gt; must supply the annotated tag message (see below for &lt;code&gt;data&lt;/code&gt; command syntax). To import an empty tag message use a 0 length data. Tag messages are free-form and are not interpreted by Git. Currently they must be encoded in UTF-8, as fast-import does not permit other encodings to be specified.</source>
          <target state="translated">&lt;code&gt;tagger&lt;/code&gt; 다음 의 &lt;code&gt;data&lt;/code&gt; 명령 은 주석이 달린 태그 메시지를 제공해야합니다 ( &lt;code&gt;data&lt;/code&gt; 명령 구문 은 아래 참조 ). 빈 태그 메시지를 가져 오려면 길이가 0 인 데이터를 사용하십시오. 태그 메시지는 자유 형식이며 Git에서 해석하지 않습니다. 빠른 가져 오기에서는 다른 인코딩을 지정할 수 없으므로 현재 UTF-8로 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="463a929e2c19b7bbf028008ad9aa5a5763e6cf66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;export-marks&lt;/code&gt; and &lt;code&gt;import-marks&lt;/code&gt; capabilities, if specified, affect this command in so far as they are passed on to &lt;code&gt;git fast-export&lt;/code&gt;, which then will load/store a table of marks for local objects. This can be used to implement for incremental operations.</source>
          <target state="translated">&lt;code&gt;export-marks&lt;/code&gt; 및 &lt;code&gt;import-marks&lt;/code&gt; 에 기능을 지정하는 경우, 지금까지 그들이 통과로이 명령에 영향을 &lt;code&gt;git fast-export&lt;/code&gt; 다음로드 / 지역 객체에 대한 마크의 테이블을 저장합니다. 증분 작업을 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b29369cc7c91f799f3a98b04ce067ccee4eaff48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extra-info&lt;/code&gt; is again command-dependent. If it is empty, the preceding SP is also omitted. Currently, no commands pass any &lt;code&gt;extra-info&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;extra-info&lt;/code&gt; 다시 명령 의존한다. 비어 있으면 앞의 SP도 생략됩니다. 현재 어떤 명령도 &lt;code&gt;extra-info&lt;/code&gt; 를 전달하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="42c3cfeeb6fb7d3b809e4b2424ab05b633a62a10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format:&amp;lt;string&amp;gt;&lt;/code&gt; format allows you to specify which information you want to show. It works a little bit like printf format, with the notable exception that you get a newline with &lt;code&gt;%n&lt;/code&gt; instead of &lt;code&gt;\n&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;format:&amp;lt;string&amp;gt;&lt;/code&gt; 형식은 당신이 표시하려는 정보를 지정할 수 있습니다. &lt;code&gt;\n&lt;/code&gt; 대신 &lt;code&gt;%n&lt;/code&gt; 사용 하여 줄 바꿈을 얻는다는 점을 제외하면 printf 형식과 약간 비슷합니다 .</target>
        </trans-unit>
        <trans-unit id="6d12446e6ba50613ffa6591e4d86ab902d5b116f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; command is the same as in the &lt;code&gt;commit&lt;/code&gt; command; see above for details.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; (가)와 같이 명령은 동일 &lt;code&gt;commit&lt;/code&gt; 명령; 자세한 내용은 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d9bc1ff5b134d7635edcea3cd4e631a291483167" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;from&lt;/code&gt; command is used to specify the commit to initialize this branch from. This revision will be the first ancestor of the new commit. The state of the tree built at this commit will begin with the state at the &lt;code&gt;from&lt;/code&gt; commit, and be altered by the content modifications in this commit.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 명령은이에서이 지점을 초기화하는 커밋 지정하는 데 사용됩니다. 이 개정판은 새로운 커밋의 첫 번째 조상이 될 것입니다. 이 커밋에서 빌드 된 트리의 상태는 &lt;code&gt;from&lt;/code&gt; 커밋 에서 상태로 시작 되며이 커밋의 내용 수정에 의해 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="75dab416c6ca16533650ccb3bdbb6f1c8c80e31e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git add&lt;/code&gt; command will not add ignored files by default. If any ignored files were explicitly specified on the command line, &lt;code&gt;git add&lt;/code&gt; will fail with a list of ignored files. Ignored files reached by directory recursion or filename globbing performed by Git (quote your globs before the shell) will be silently ignored. The &lt;code&gt;git add&lt;/code&gt; command can be used to add ignored files with the &lt;code&gt;-f&lt;/code&gt; (force) option.</source>
          <target state="translated">&lt;code&gt;git add&lt;/code&gt; 명령은 기본적으로 파일을 무시 추가하지 않습니다. 명령 행에 무시 된 파일이 명시 적으로 지정된 경우, &lt;code&gt;git add&lt;/code&gt; 는 무시 된 파일 목록과 함께 실패합니다. Git이 수행 한 디렉토리 재귀 또는 파일 이름 globbing (쉘 앞에 globs 인용)에 의해 무시 된 파일은 무시됩니다. &lt;code&gt;git add&lt;/code&gt; 명령이 함께 무시 파일을 추가 할 수 있습니다 &lt;code&gt;-f&lt;/code&gt; (강제) 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="9bd7293224a598d82d7fb9b059bf233156e9f91a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git bundle&lt;/code&gt; command packages objects and references in an archive at the originating machine, which can then be imported into another repository using &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt;, or &lt;code&gt;git clone&lt;/code&gt;, after moving the archive by some means (e.g., by sneakernet).</source>
          <target state="translated">&lt;code&gt;git bundle&lt;/code&gt; 다음 다른 사용 저장소로 가져올 수 발신 시스템에서 아카이브 명령 패키지 목적 및 참조 &lt;code&gt;git fetch&lt;/code&gt; , &lt;code&gt;git pull&lt;/code&gt; 또는 &lt;code&gt;git clone&lt;/code&gt; (체크를하면서 의해, 예) 일부에 의해 압축을 이동 한 후,.</target>
        </trans-unit>
        <trans-unit id="3d9620664b0c9d56c3287a812c3ff6b6d1c8717f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git diff-*&lt;/code&gt; family works by first comparing two sets of files:</source>
          <target state="translated">&lt;code&gt;git diff-*&lt;/code&gt; 첫번째 파일의 두 세트를 비교하여 가족 작품 :</target>
        </trans-unit>
        <trans-unit id="597ca1f538bf6e2f60b9e6f9e15d7129efb080fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git fetch&lt;/code&gt; operation always stores the head of the last fetched branch in FETCH_HEAD. For example, if you run &lt;code&gt;git fetch&lt;/code&gt; without specifying a local branch as the target of the operation</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 작업은 항상 FETCH_HEAD의 마지막 인출 지점의 머리를 저장합니다. 예를 들어, 로컬 분기를 작업 대상으로 지정하지 않고 &lt;code&gt;git fetch&lt;/code&gt; 를 실행하는 경우</target>
        </trans-unit>
        <trans-unit id="f809c0db2fabe1b716a044f1ae315c3eafe27e59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git fmt-merge-msg&lt;/code&gt; command can be used to give a good default for automated &lt;code&gt;git merge&lt;/code&gt; invocations. The automated message can include the branch description.</source>
          <target state="translated">&lt;code&gt;git fmt-merge-msg&lt;/code&gt; 명령은 자동화를위한 좋은 기본 제공하는 데 사용할 수있는 &lt;code&gt;git merge&lt;/code&gt; 호출을. 자동화 된 메시지에는 지사 설명이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dae50540309298598631c32bc4ba09615f81ee1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git gc --auto&lt;/code&gt; command will run the &lt;code&gt;pre-auto-gc&lt;/code&gt; hook. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;git gc --auto&lt;/code&gt; 명령은 실행 &lt;code&gt;pre-auto-gc&lt;/code&gt; 훅을. 자세한 내용은 &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cfc7fc175318cd6dff60f69f9572984dc7656815" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git grep&lt;/code&gt; command can search for strings in any version of your project, so</source>
          <target state="translated">&lt;code&gt;git grep&lt;/code&gt; 명령 때문에, 프로젝트의 모든 버전에서 문자열을 검색 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="10370106ed757f0fcfa619078db112558b3f4b4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git log&lt;/code&gt; command has a weakness: it must present commits in a list. When the history has lines of development that diverged and then merged back together, the order in which &lt;code&gt;git log&lt;/code&gt; presents those commits is meaningless.</source>
          <target state="translated">&lt;code&gt;git log&lt;/code&gt; 명령은 약점이있다 : 그것은 목록에 커밋을 제시해야합니다. 히스토리에 개발 라인이 분기되어 다시 병합 된 경우 &lt;code&gt;git log&lt;/code&gt; 가 해당 커밋을 표시 하는 순서 는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5c380959946a83eda94454025f0a10c3629cc163" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git maintenance&lt;/code&gt; command is designed to simplify the repository maintenance patterns while minimizing user wait time during Git commands. A variety of configuration options are available to allow customizing this process. The default maintenance options focus on operations that complete quickly, even on large repositories.</source>
          <target state="translated">&lt;code&gt;git maintenance&lt;/code&gt; 명령이 망할 놈의 명령 동안 사용자 대기 시간을 최소화하면서 저장소 유지 보수 패턴을 단순화하도록 설계되었습니다. 이 프로세스를 사용자 정의 할 수 있도록 다양한 구성 옵션을 사용할 수 있습니다. 기본 유지 관리 옵션은 대규모 저장소에서도 빠르게 완료되는 작업에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="00ff38dfc73bcfa62c1ff676ccda2e6392a71376" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git maintenance&lt;/code&gt; command provides flexibility for how to optimize the Git repository.</source>
          <target state="translated">&lt;code&gt;git maintenance&lt;/code&gt; 명령은 Git 저장소를 최적화하는 방법에 대한 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2918fcbf92a1ba7da67f920488e3f1571c6c776d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git pull&lt;/code&gt; command can also be given &lt;code&gt;.&lt;/code&gt; as the &quot;remote&quot; repository, in which case it just merges in a branch from the current repository; so the commands</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 명령도 제공 할 수있다 &lt;code&gt;.&lt;/code&gt; &quot;원격&quot;리포지토리로,이 경우에는 현재 리포지토리의 분기로 병합됩니다. 그래서 명령</target>
        </trans-unit>
        <trans-unit id="ae6be494d942d11be1fef84bf75e14340e42ba70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git sh-setup&lt;/code&gt; scriptlet is designed to be sourced (using &lt;code&gt;.&lt;/code&gt;) by other shell scripts to set up some variables pointing at the normal Git directories and a few helper shell functions.</source>
          <target state="translated">&lt;code&gt;git sh-setup&lt;/code&gt; 스크립틀릿은 (사용하여 공급하도록 설계되어 있습니다 &lt;code&gt;.&lt;/code&gt; 일반 망할 놈의 디렉토리와 몇 도우미 쉘 기능을 가리키는 몇 가지 변수를 설정하는 다른 쉘 스크립트에 의해).</target>
        </trans-unit>
        <trans-unit id="b8d00251834fb59fdb3aac3b6b6d2fd6617d8c54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git status&lt;/code&gt; command can be used to obtain a summary of which files have changes that are staged for the next commit.</source>
          <target state="translated">&lt;code&gt;git status&lt;/code&gt; 명령은 파일을 다음 커밋을 위해 개최되는 변경 사항이있는 요약을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1114dd8f20b27292636eee44dbca10b695a7e192" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git submodule add &amp;lt;repo&amp;gt; &amp;lt;path&amp;gt;&lt;/code&gt; command does a couple of things:</source>
          <target state="translated">&lt;code&gt;git submodule add &amp;lt;repo&amp;gt; &amp;lt;path&amp;gt;&lt;/code&gt; 명령 않는 몇 가지 :</target>
        </trans-unit>
        <trans-unit id="851ad3692f8ce86e89fabf82d757953cfb293665" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git svn log&lt;/code&gt; command will not work on repositories using this, either. Using this conflicts with the &lt;code&gt;useSvmProps&lt;/code&gt; option for (hopefully) obvious reasons.</source>
          <target state="translated">&lt;code&gt;git svn log&lt;/code&gt; 명령 중 하나,이를 사용하여 저장소에서 작동하지 않습니다. 이것을 사용하는 것은 명백한 이유 때문에 &lt;code&gt;useSvmProps&lt;/code&gt; 옵션 과 충돌합니다 .</target>
        </trans-unit>
        <trans-unit id="54f2e5960f99dce6a894019f61b5f183cfaf541a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git switch&lt;/code&gt; command normally expects a branch head, but will also accept an arbitrary commit when invoked with --detach; for example, you can check out the commit referenced by a tag:</source>
          <target state="translated">&lt;code&gt;git switch&lt;/code&gt; 명령은 일반적으로 분기 머리를 기대하고, 또한 --detach 호출 할 때 임의의 커밋 받아 들일 것입니다; 예를 들어 태그가 참조하는 커밋을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5df4353714e03396f22186d308b555d9fc45aa0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git unpack-objects&lt;/code&gt; command can read the packed archive and expand the objects contained in the pack into &quot;one-file one-object&quot; format; this is typically done by the smart-pull commands when a pack is created on-the-fly for efficient network transport by their peers.</source>
          <target state="translated">&lt;code&gt;git unpack-objects&lt;/code&gt; 명령은 포장 된 압축 파일을 읽고 개체가 &quot;하나의 파일을 하나의 객체&quot;형식으로 팩에 포함 된 확장 할 수 있습니다; 이는 일반적으로 동료가 효율적인 네트워크 전송을 위해 팩을 즉석에서 만들 때 smart-pull 명령으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="472b18d3af19081ec08acbffb4a8b9828ded3de3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git write-tree&lt;/code&gt; command refuses to write a nonsensical tree, and it will complain about unmerged entries if it sees a single entry that is not stage 0.</source>
          <target state="translated">&lt;code&gt;git write-tree&lt;/code&gt; 명령은 무의미한 트리 쓰기를 거부하고 무대 0이 아닌 하나의 항목을 보는 경우가 병합되지 않은 항목에 대해 불평 할 것이다.</target>
        </trans-unit>
        <trans-unit id="57ed6fd41631cf164adf8f1a5f87022b80e95155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;git-fetch&lt;/code&gt; command, with no arguments, will update all of the remote-tracking branches to the latest version found in the original repository. It will not touch any of your own branches&amp;mdash;​not even the &quot;master&quot; branch that was created for you on clone.</source>
          <target state="translated">&lt;code&gt;git-fetch&lt;/code&gt; 원래 저장소에있는 최신 버전으로 원격 추적 브랜치의 모든 업데이트됩니다, 인수없이 명령을. 클론에서 생성 한 &quot;마스터&quot;브랜치조차도 자신의 브랜치에 닿지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7a1f970e8485b643b6fd9d3ee5bf5ec87b44b17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gitlink&lt;/code&gt; entry contains the object name of the commit that the superproject expects the submodule&amp;rsquo;s working directory to be at.</source>
          <target state="translated">&lt;code&gt;gitlink&lt;/code&gt; 항목은이 superproject이 서브 모듈의 작업 디렉토리에있을 것으로 예상 것을 커밋의 객체 이름이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="59421f1cfeaef33b3d6dfff512008a45b2069f51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;help.browser&lt;/code&gt;, &lt;code&gt;web.browser&lt;/code&gt; and &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt; will also be checked if the &lt;code&gt;web&lt;/code&gt; format is chosen (either by command-line option or configuration variable). See &lt;code&gt;-w|--web&lt;/code&gt; in the OPTIONS section above and &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt;.</source>
          <target state="translated">The &lt;code&gt;help.browser&lt;/code&gt; , &lt;code&gt;web.browser&lt;/code&gt; and &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt; will also be checked if the &lt;code&gt;web&lt;/code&gt; format is chosen (either by command-line option or configuration variable). See &lt;code&gt;-w|--web&lt;/code&gt; in the OPTIONS section above and &lt;a href=&quot;git-web--browse&quot;&gt;git-web--browse[1]&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="20a22a2e8dd656430183eebd26fcd541802b3980" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;help.browser&lt;/code&gt;, &lt;code&gt;web.browser&lt;/code&gt; and &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt; will also be checked if the &lt;code&gt;web&lt;/code&gt; format is chosen (either by command-line option or configuration variable). See &lt;code&gt;-w|--web&lt;/code&gt; in the OPTIONS section above and git-web{litdd}browse[1].</source>
          <target state="translated">&lt;code&gt;help.browser&lt;/code&gt; , &lt;code&gt;web.browser&lt;/code&gt; 및 &lt;code&gt;browser.&amp;lt;tool&amp;gt;.path&lt;/code&gt; 경우 생성도 체크한다 &lt;code&gt;web&lt;/code&gt; 포맷이 선택된다 (어느 명령 행 옵션 또는 구성 변수). 참조 &lt;code&gt;-w|--web&lt;/code&gt; 와 자식 - 웹 {litdd} 찾아 [1] 위의 옵션 섹션입니다.</target>
        </trans-unit>
        <trans-unit id="d643b3df461bdc6854f7d047b7c0264699b4e1d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;includeIf&lt;/code&gt; sections allow you to include config directives from another source. These sections behave identically to each other with the exception that &lt;code&gt;includeIf&lt;/code&gt; sections may be ignored if their condition does not evaluate to true; see &quot;Conditional includes&quot; below.</source>
          <target state="translated">은 &lt;code&gt;include&lt;/code&gt; 하고 &lt;code&gt;includeIf&lt;/code&gt; 의 섹션은 다른 소스에서 설정 지시어를 포함 할 수 있습니다. 이러한 섹션 은 조건이 true로 평가되지 않으면 &lt;code&gt;includeIf&lt;/code&gt; 섹션이 무시 될 수 있다는 점을 제외하고 서로 동일하게 동작 합니다. 아래의 &quot;조건부 포함&quot;을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a487e4b33c7059a362fff4a5ad146cea89086e35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;incremental-repack&lt;/code&gt; job repacks the object directory using the &lt;code&gt;multi-pack-index&lt;/code&gt; feature. In order to prevent race conditions with concurrent Git commands, it follows a two-step process. First, it calls &lt;code&gt;git multi-pack-index expire&lt;/code&gt; to delete pack-files unreferenced by the &lt;code&gt;multi-pack-index&lt;/code&gt; file. Second, it calls &lt;code&gt;git multi-pack-index repack&lt;/code&gt; to select several small pack-files and repack them into a bigger one, and then update the &lt;code&gt;multi-pack-index&lt;/code&gt; entries that refer to the small pack-files to refer to the new pack-file. This prepares those small pack-files for deletion upon the next run of &lt;code&gt;git multi-pack-index expire&lt;/code&gt;. The selection of the small pack-files is such that the expected size of the big pack-file is at least the batch size; see the &lt;code&gt;--batch-size&lt;/code&gt; option for the &lt;code&gt;repack&lt;/code&gt; subcommand in &lt;a href=&quot;git-multi-pack-index&quot;&gt;git-multi-pack-index[1]&lt;/a&gt;. The default batch-size is zero, which is a special case that attempts to repack all pack-files into a single pack-file.</source>
          <target state="translated">&lt;code&gt;incremental-repack&lt;/code&gt; 작업은 사용하여 객체 디렉토리 재조합합니다 &lt;code&gt;multi-pack-index&lt;/code&gt; 기능을. 동시 Git 명령으로 경쟁 조건을 방지하기 위해 2 단계 프로세스를 따릅니다. 먼저 &lt;code&gt;git multi-pack-index expire&lt;/code&gt; 를 호출 하여 &lt;code&gt;multi-pack-index&lt;/code&gt; 파일이 참조하지 않는 팩 파일을 삭제 합니다. 둘째, &lt;code&gt;git multi-pack-index repack&lt;/code&gt; 을 호출 하여 여러 개의 작은 팩 파일을 선택하고 더 큰 파일로 다시 압축 한 다음 새 팩을 참조하기 위해 작은 팩 파일을 참조 하는 &lt;code&gt;multi-pack-index&lt;/code&gt; 항목 을 업데이트합니다. -파일. 이렇게하면 다음 &lt;code&gt;git multi-pack-index expire&lt;/code&gt; 시 삭제할 작은 팩 파일이 준비 됩니다.. 작은 팩 파일의 선택은 큰 팩 파일의 예상 크기가 최소한 배치 크기가되도록하는 것입니다. &lt;a href=&quot;git-multi-pack-index&quot;&gt;git-multi-pack-index [1]&lt;/a&gt; 의 &lt;code&gt;repack&lt;/code&gt; 하위 명령에 대한 &lt;code&gt;--batch-size&lt;/code&gt; 옵션을 참조하십시오 . 기본 배치 크기는 0이며, 이는 모든 팩 파일을 단일 팩 파일로 다시 압축하려는 특수한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="25df8c5531688eabec317d8bad065a9bd5755f39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;label&lt;/code&gt; command associates a label with the current HEAD when that command is executed. These labels are created as worktree-local refs (&lt;code&gt;refs/rewritten/&amp;lt;label&amp;gt;&lt;/code&gt;) that will be deleted when the rebase finishes. That way, rebase operations in multiple worktrees linked to the same repository do not interfere with one another. If the &lt;code&gt;label&lt;/code&gt; command fails, it is rescheduled immediately, with a helpful message how to proceed.</source>
          <target state="translated">&lt;code&gt;label&lt;/code&gt; 이 명령이 실행될 때 명령은 현재 HEAD와 레이블을 연결합니다. 이 레이블은 리베이스가 완료 될 때 삭제되는 작업 트리 로컬 참조 ( &lt;code&gt;refs/rewritten/&amp;lt;label&amp;gt;&lt;/code&gt; )로 작성 됩니다. 이렇게하면 동일한 리포지토리에 연결된 여러 작업 트리의 리베이스 작업이 서로 간섭하지 않습니다. 경우 &lt;code&gt;label&lt;/code&gt; 명령이 실패 진행 방법, 그것은 도움이 메시지와 함께 즉시 재조정된다.</target>
        </trans-unit>
        <trans-unit id="fcbbe57ad1bbeeeea536166f770fc1a1a385d28e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list&lt;/code&gt; command may produce a list of key-value pairs. The following keys are defined.</source>
          <target state="translated">The &lt;code&gt;list&lt;/code&gt; command may produce a list of key-value pairs. The following keys are defined.</target>
        </trans-unit>
        <trans-unit id="a21f07c748b4f824d325c5d844a166616c79a19e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;list&lt;/code&gt; command produces a list of refs in which each ref may be followed by a list of attributes. The following ref list attributes are defined.</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; 명령 (REF)는 각 속성 목록 다음 될 수있는 심판의리스트를 생성한다. 다음과 같은 참조 목록 속성이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="6043952fda08c25ccc481f9a80740c9002ea5cf7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loose-objects&lt;/code&gt; job cleans up loose objects and places them into pack-files. In order to prevent race conditions with concurrent Git commands, it follows a two-step process. First, it deletes any loose objects that already exist in a pack-file; concurrent Git processes will examine the pack-file for the object data instead of the loose object. Second, it creates a new pack-file (starting with &quot;loose-&quot;) containing a batch of loose objects. The batch size is limited to 50 thousand objects to prevent the job from taking too long on a repository with many loose objects. The &lt;code&gt;gc&lt;/code&gt; task writes unreachable objects as loose objects to be cleaned up by a later step only if they are not re-added to a pack-file; for this reason it is not advisable to enable both the &lt;code&gt;loose-objects&lt;/code&gt; and &lt;code&gt;gc&lt;/code&gt; tasks at the same time.</source>
          <target state="translated">&lt;code&gt;loose-objects&lt;/code&gt; 작업 은 느슨한 개체를 정리하여 팩 파일에 배치합니다. 동시 Git 명령으로 경쟁 조건을 방지하기 위해 2 단계 프로세스를 따릅니다. 첫째, 팩 파일에 이미 존재하는 모든 느슨한 개체를 삭제합니다. 동시 Git 프로세스는 느슨한 개체 대신 개체 데이터에 대한 팩 파일을 검사합니다. 둘째, 느슨한 개체의 배치를 포함하는 새 팩 파일 ( &quot;loose-&quot;로 시작)을 만듭니다. 느슨한 개체가 많은 저장소에서 작업이 너무 오래 걸리는 것을 방지하기 위해 일괄 처리 크기는 5 만 개체로 제한됩니다. &lt;code&gt;gc&lt;/code&gt; 가 다시 추가 팩 파일에없는 경우에만 느슨한 객체가 이후의 단계로 정리하는대로 작업은 도달 할 수없는 객체를 기록; 이러한 이유로 &lt;code&gt;loose-objects&lt;/code&gt; 모두 활성화하는 것은 바람직하지 않습니다.및 &lt;code&gt;gc&lt;/code&gt; 작업을 동시에 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a1948673e2dc6e9b36baf9466260194608388c73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ls&lt;/code&gt; command can also be used where a &lt;code&gt;filemodify&lt;/code&gt; directive can appear, allowing it to be used in the middle of a commit.</source>
          <target state="translated">&lt;code&gt;ls&lt;/code&gt; 명령은 또한 어디에 사용할 수 있습니다 &lt;code&gt;filemodify&lt;/code&gt; 지시어는이 커밋의 중간에 사용할 수 있도록 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f751fdc4139000f76be8c4b7f0362d024d6ccd7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;maint&lt;/code&gt; branch should now be fast-forwarded to the newly released code so that maintenance fixes can be tracked for the current release:</source>
          <target state="translated">&lt;code&gt;maint&lt;/code&gt; 지점은 이제 유지 보수 수정은 현재 릴리스에 대해 추적 할 수 있도록 새로 출시 된 코드를 빠르게 전달해야합니다 :</target>
        </trans-unit>
        <trans-unit id="3d08be0d91fe4ba76005ea415ec8dd980a19baaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;man.viewer&lt;/code&gt; configuration variable will be checked if the &lt;code&gt;man&lt;/code&gt; format is chosen. The following values are currently supported:</source>
          <target state="translated">&lt;code&gt;man.viewer&lt;/code&gt; 의 경우 생성 구성 변수가 확인됩니다 &lt;code&gt;man&lt;/code&gt; 포맷이 선택됩니다. 현재 다음 값이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4d99fda454f21ad231a7b020da5a33fbc1590dfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;master&lt;/code&gt; branch is supposed to be a superset of &lt;code&gt;maint&lt;/code&gt;. If this condition does not hold, then &lt;code&gt;maint&lt;/code&gt; contains some commits that are not included on &lt;code&gt;master&lt;/code&gt;. The fixes represented by those commits will therefore not be included in your feature release.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 브랜치의 상위 집합이기로되어있다 &lt;code&gt;maint&lt;/code&gt; . 이 조건이 유지되지 않으면 &lt;code&gt;maint&lt;/code&gt; 에는 &lt;code&gt;master&lt;/code&gt; 에 포함되지 않은 커밋이 포함됩니다 . 따라서 해당 커밋으로 표시되는 수정 프로그램은 기능 릴리스에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="60a9438818e32daade34327aac8510a028d0a280" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge.*.driver&lt;/code&gt; variable&amp;rsquo;s value is used to construct a command to run to merge ancestor&amp;rsquo;s version (&lt;code&gt;%O&lt;/code&gt;), current version (&lt;code&gt;%A&lt;/code&gt;) and the other branches' version (&lt;code&gt;%B&lt;/code&gt;). These three tokens are replaced with the names of temporary files that hold the contents of these versions when the command line is built. Additionally, %L will be replaced with the conflict marker size (see below).</source>
          <target state="translated">&lt;code&gt;merge.*.driver&lt;/code&gt; 변수 값이 병합 상위 버전 (에 실행할 명령 구성하는데 사용된다 &lt;code&gt;%O&lt;/code&gt; ) 현재 버전 ( &lt;code&gt;%A&lt;/code&gt; ) 다른 지점 '버전 ( &lt;code&gt;%B&lt;/code&gt; ). 이 세 개의 토큰은 명령 행이 빌드 될 때이 버전의 내용을 보유하는 임시 파일 이름으로 대체됩니다. 또한 % L은 충돌 마커 크기로 대체됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="8135860bcb3c213dc65a79f9d59c1c4cf76a9b52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge.*.name&lt;/code&gt; variable gives the driver a human-readable name.</source>
          <target state="translated">&lt;code&gt;merge.*.name&lt;/code&gt; 변수는 드라이버에 사람이 읽을 수있는 이름을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="531f58358e8d95bd1e04306b8f06edec09e06aba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge.*.recursive&lt;/code&gt; variable specifies what other merge driver to use when the merge driver is called for an internal merge between common ancestors, when there are more than one. When left unspecified, the driver itself is used for both internal merge and the final merge.</source>
          <target state="translated">&lt;code&gt;merge.*.recursive&lt;/code&gt; 하나 이상 존재하는 경우 변수의 내용을 지정 다른 병합 드라이버 병합 드라이버가 공통 조상과 내부 병합 호출 될 때 사용한다. 지정하지 않은 경우 드라이버 자체는 내부 병합 및 최종 병합에 모두 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e9e9f9df980dcf05008ee310843fafb365f76e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;merge&lt;/code&gt; command will merge the specified revision(s) into whatever is HEAD at that time. With &lt;code&gt;-C &amp;lt;original-commit&amp;gt;&lt;/code&gt;, the commit message of the specified merge commit will be used. When the &lt;code&gt;-C&lt;/code&gt; is changed to a lower-case &lt;code&gt;-c&lt;/code&gt;, the message will be opened in an editor after a successful merge so that the user can edit the message.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 명령은 그 시간에 HEAD 무엇이든 지정된 개정 (들)에 병합됩니다. 함께 &lt;code&gt;-C &amp;lt;original-commit&amp;gt;&lt;/code&gt; 의 병합은 특정의 메시지가 사용될 확약. &lt;code&gt;-C&lt;/code&gt; 가 소문자 &lt;code&gt;-c&lt;/code&gt; 로 변경 되면 병합이 성공한 후 편집기에서 메시지가 열리므로 사용자가 메시지를 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="103d9db55b62f87264ea4e2293c619e5e886c09f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode &amp;lt;mode&amp;gt;,&amp;lt;mode&amp;gt;..&amp;lt;mode&amp;gt;&lt;/code&gt; line appears only if at least one of the &amp;lt;mode&amp;gt; is different from the rest. Extended headers with information about detected contents movement (renames and copying detection) are designed to work with diff of two &amp;lt;tree-ish&amp;gt; and are not used by combined diff format.</source>
          <target state="translated">&lt;code&gt;mode &amp;lt;mode&amp;gt;,&amp;lt;mode&amp;gt;..&amp;lt;mode&amp;gt;&lt;/code&gt; &amp;lt;모드&amp;gt; 중 적어도 하나는 나머지 다른 경우 라인에만 나타난다. 감지 된 컨텐츠 이동 (이름 변경 및 복사 감지)에 대한 정보가있는 확장 헤더는 두 가지 &amp;lt;tree-ish&amp;gt;의 diff와 함께 작동하도록 설계되었으며 결합 된 diff 형식으로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2bdce5756dcfa3f7f3ee04d8a9aa0f072d4148cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p4-changelist&lt;/code&gt; hook is executed after the changelist message has been edited by the user. It can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes a single parameter, the name of the file that holds the proposed changelist text. Exiting with a non-zero status causes the command to abort.</source>
          <target state="translated">The &lt;code&gt;p4-changelist&lt;/code&gt; hook is executed after the changelist message has been edited by the user. It can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; option. It takes a single parameter, the name of the file that holds the proposed changelist text. Exiting with a non-zero status causes the command to abort.</target>
        </trans-unit>
        <trans-unit id="faca035b6e964f3e1a2e62a14bd12a5a551dfc56" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p4-post-changelist&lt;/code&gt; hook is invoked after the submit has successfully occured in P4. It takes no parameters and is meant primarily for notification and cannot affect the outcome of the git p4 submit action.</source>
          <target state="translated">The &lt;code&gt;p4-post-changelist&lt;/code&gt; hook is invoked after the submit has successfully occured in P4. It takes no parameters and is meant primarily for notification and cannot affect the outcome of the git p4 submit action.</target>
        </trans-unit>
        <trans-unit id="548bbc8c1c0a7906deaf13e9ebab02c10ef8f504" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p4-post-changelist&lt;/code&gt; hook is invoked after the submit has successfully occurred in P4. It takes no parameters and is meant primarily for notification and cannot affect the outcome of the git p4 submit action.</source>
          <target state="translated">&lt;code&gt;p4-post-changelist&lt;/code&gt; 이 성공적으로 P4 발생했습니다 제출하면 후크가 호출됩니다. 매개 변수를 취하지 않으며 주로 알림을위한 것이며 git p4 제출 작업의 결과에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="245bf1c27c1e24c16ea60d971116c678983044e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p4-pre-submit&lt;/code&gt; hook is executed if it exists and is executable. The hook takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevents &lt;code&gt;git-p4 submit&lt;/code&gt; from launching.</source>
          <target state="translated">&lt;code&gt;p4-pre-submit&lt;/code&gt; 이 존재하고 실행 가능한 경우 후크가 실행됩니다. 후크는 표준 입력에서 매개 변수를 사용하지 않습니다. 이 스크립트에서 0이 아닌 상태로 종료하면 &lt;code&gt;git-p4 submit&lt;/code&gt; 이 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b18899976ae8ddf5fa851e0121915b85076d95b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p4-pre-submit&lt;/code&gt; hook is executed if it exists and is executable. The hook takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevents &lt;code&gt;git-p4 submit&lt;/code&gt; from launching. It can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; command line option.</source>
          <target state="translated">The &lt;code&gt;p4-pre-submit&lt;/code&gt; hook is executed if it exists and is executable. The hook takes no parameters and nothing from standard input. Exiting with non-zero status from this script prevents &lt;code&gt;git-p4 submit&lt;/code&gt; from launching. It can be bypassed with the &lt;code&gt;--no-verify&lt;/code&gt; command line option.</target>
        </trans-unit>
        <trans-unit id="7d1a28ab3e2441205f479d6f2df8ea0d456e98e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p4-prepare-changelist&lt;/code&gt; hook is executed right after preparing the default changelist message and before the editor is started. It takes one parameter, the name of the file that contains the changelist text. Exiting with a non-zero status from the script will abort the process.</source>
          <target state="translated">The &lt;code&gt;p4-prepare-changelist&lt;/code&gt; hook is executed right after preparing the default changelist message and before the editor is started. It takes one parameter, the name of the file that contains the changelist text. Exiting with a non-zero status from the script will abort the process.</target>
        </trans-unit>
        <trans-unit id="55ac82e7ce6eab5b9d775518541be1b358e64d26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;post-update&lt;/code&gt; hook can tell what are the heads that were pushed, but it does not know what their original and updated values are, so it is a poor place to do log old..new. The &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;post-receive&lt;/em&gt;&lt;/a&gt; hook does get both original and updated values of the refs. You might consider it instead if you need them.</source>
          <target state="translated">&lt;code&gt;post-update&lt;/code&gt; 그래서 old..new 로그인 할 수있는 가난한 곳, 후크 밀렸다 머리 무엇인지 말할 수 있지만, 원래 및 업데이트 된 값이 무엇인지 알 수 없습니다. &lt;a href=&quot;#post-receive&quot;&gt;&lt;em&gt;후받을&lt;/em&gt;&lt;/a&gt; 후크는 심판의 모두 원본과 업데이트 된 값을 얻을 수 없습니다. 필요한 경우 대신 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b1878af31d43f94d962552d8195f8f92835c4ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pre-receive&lt;/code&gt; hook MUST NOT update any refs to point to quarantined objects. Other programs accessing the repository will not be able to see the objects (and if the pre-receive hook fails, those refs would become corrupted). For safety, any ref updates from within &lt;code&gt;pre-receive&lt;/code&gt; are automatically rejected.</source>
          <target state="translated">&lt;code&gt;pre-receive&lt;/code&gt; 후크 격리 된 개체에 포인트에 대한 심판을 업데이트 안된다. 저장소에 액세스하는 다른 프로그램은 오브젝트를 볼 수 없습니다 (사전 수신 후크가 실패하면 해당 참조가 손상됨). 안전을 위해 &lt;code&gt;pre-receive&lt;/code&gt; 내의 모든 참조 업데이트 는 자동으로 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="99b94c570c1df1ebad0373a1bf1d41698acbbe49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefetch&lt;/code&gt; task updates the object directory with the latest objects from all registered remotes. For each remote, a &lt;code&gt;git fetch&lt;/code&gt; command is run. The refmap is custom to avoid updating local or remote branches (those in &lt;code&gt;refs/heads&lt;/code&gt; or &lt;code&gt;refs/remotes&lt;/code&gt;). Instead, the remote refs are stored in &lt;code&gt;refs/prefetch/&amp;lt;remote&amp;gt;/&lt;/code&gt;. Also, tags are not updated.</source>
          <target state="translated">&lt;code&gt;prefetch&lt;/code&gt; 작업은 등록 된 모든 리모컨의 최신 객체와 객체 디렉토리를 업데이트합니다. 각 원격에 대해 &lt;code&gt;git fetch&lt;/code&gt; 명령이 실행됩니다. refmap은 로컬 또는 원격 분기 ( &lt;code&gt;refs/heads&lt;/code&gt; 또는 &lt;code&gt;refs/remotes&lt;/code&gt; 에 있는 분기)를 업데이트하지 않도록 사용자 지정됩니다 . 대신 원격 참조는 &lt;code&gt;refs/prefetch/&amp;lt;remote&amp;gt;/&lt;/code&gt; 에 저장 됩니다. 또한 태그는 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb98cabc50bf16dce560817c25a1c4d64601cce6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pu&lt;/code&gt; branch will be updated even if it does not fast-forward, because it is prefixed with a plus sign; &lt;code&gt;tmp&lt;/code&gt; will not be.</source>
          <target state="translated">&lt;code&gt;pu&lt;/code&gt; 분기 그것는 더하기 기호로 시작되어 있기 때문에, 아니 빨리 감기 않는 경우에도 업데이트됩니다; &lt;code&gt;tmp&lt;/code&gt; 는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5f7235d0f9a5c833ca324eff7dc4ec19b6e7285" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pull&lt;/code&gt; command knows where to get updates from because of certain configuration variables that were set by the first &lt;code&gt;git clone&lt;/code&gt; command; see &lt;code&gt;git config -l&lt;/code&gt; and the &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; man page for details.</source>
          <target state="translated">&lt;code&gt;pull&lt;/code&gt; 명령 때문에 처음에 의해 설정된 특정 구성 변수의 업데이트를 구할 수있는 곳을 알고 &lt;code&gt;git clone&lt;/code&gt; 명령; 자세한 내용은 &lt;code&gt;git config -l&lt;/code&gt; 및 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9716ab4c9bb8eabfdb4d2f2052c2761838dfc4ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r1^!&lt;/code&gt; notation includes commit &lt;code&gt;r1&lt;/code&gt; but excludes all of its parents. By itself, this notation denotes the single commit &lt;code&gt;r1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r1^!&lt;/code&gt; 표기법에는 커밋 &lt;code&gt;r1&lt;/code&gt; 이 포함 되지만 모든 부모는 제외됩니다. 이 표기법 자체는 단일 커밋 &lt;code&gt;r1&lt;/code&gt; 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ec7b0d87246117fbc7ede1e9fb5e445953432dc9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;r1^@&lt;/code&gt; notation means all parents of &lt;code&gt;r1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;r1^@&lt;/code&gt; 표기는 모든 부모 의미 &lt;code&gt;r1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="906a6c33616cfaeeffbd4277ee44152fa9cd28f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;raw&lt;/code&gt; format shows the entire commit exactly as stored in the commit object. Notably, the hashes are displayed in full, regardless of whether --abbrev or --no-abbrev are used, and &lt;code&gt;parents&lt;/code&gt; information show the true parent commits, without taking grafts or history simplification into account. Note that this format affects the way commits are displayed, but not the way the diff is shown e.g. with &lt;code&gt;git log --raw&lt;/code&gt;. To get full object names in a raw diff format, use &lt;code&gt;--no-abbrev&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;raw&lt;/code&gt; 전체 정확히 같은 저장 형식 커밋 쇼 오브젝트 커밋. 특히 --abbrev 또는 --no-abbrev의 사용 여부에 관계없이 해시가 전체로 표시되며 그래프 또는 기록 단순화를 고려하지 않고 &lt;code&gt;parents&lt;/code&gt; 정보에 실제 부모 커밋이 표시됩니다. 이 형식은 커밋이 표시되는 방식에 영향을 미치지 만 &lt;code&gt;git log --raw&lt;/code&gt; 와 같이 diff가 표시되는 방식에는 영향을 미치지 않습니다 . 원시 diff 형식으로 전체 객체 이름을 얻으려면 &lt;code&gt;--no-abbrev&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e2ae08cd51826a72547a4936e1fee7033d540d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recursive&lt;/code&gt; strategy can take the following options:</source>
          <target state="translated">&lt;code&gt;recursive&lt;/code&gt; 전략은 다음과 같은 옵션을 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2274cd304e0d47984767afeee4d877ca51fbdd54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refs/heads/*&lt;/code&gt; namespace will only accept commit objects, and updates only if they can be fast-forwarded.</source>
          <target state="translated">&lt;code&gt;refs/heads/*&lt;/code&gt; 가 될 수있는 경우에만 네임 스페이스 개체 만 커밋 받아 들일 것입니다 및 업데이트는 빠르게 전달.</target>
        </trans-unit>
        <trans-unit id="73d202d810478ee27aec0a92a74e6cf7efe8db45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;refs/tags/*&lt;/code&gt; namespace will accept any kind of object (as commits, trees and blobs can be tagged), and any updates to them will be rejected.</source>
          <target state="translated">&lt;code&gt;refs/tags/*&lt;/code&gt; (커밋, 나무와 모양을 태그 할 수있는) 네임 스페이스는 모든 종류의 객체를 받아, 그들에 대한 업데이트가 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="5e33461f3097b7e2978ea28d8c31efc6ebcd9fc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register&lt;/code&gt; subcomand will also set the &lt;code&gt;maintenance.strategy&lt;/code&gt; config value to &lt;code&gt;incremental&lt;/code&gt;, if this value is not previously set. The &lt;code&gt;incremental&lt;/code&gt; strategy uses the following schedule for each maintenance task:</source>
          <target state="translated">&lt;code&gt;register&lt;/code&gt; subcomand도 설정한다 &lt;code&gt;maintenance.strategy&lt;/code&gt; 용 으로 설정 값을 &lt;code&gt;incremental&lt;/code&gt; 이 값이 미리 설정되어 있지 않은 경우. &lt;code&gt;incremental&lt;/code&gt; 전략은 각각의 유지 보수 작업에 대한 다음과 같은 일정을 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="8f1fa8b6ca43d585bbef39f492a9db57e9ecc9a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reset&lt;/code&gt; command can also be used to create lightweight (non-annotated) tags. For example:</source>
          <target state="translated">&lt;code&gt;reset&lt;/code&gt; 명령은 또한 경량 (비 주석) 태그를 만드는 데 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd2e909f258c6aa58fa07c5acaee67caeb1da10e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reset&lt;/code&gt; command resets the HEAD, index and worktree to the specified revision. It is similar to an &lt;code&gt;exec git reset --hard &amp;lt;label&amp;gt;&lt;/code&gt;, but refuses to overwrite untracked files. If the &lt;code&gt;reset&lt;/code&gt; command fails, it is rescheduled immediately, with a helpful message how to edit the todo list (this typically happens when a &lt;code&gt;reset&lt;/code&gt; command was inserted into the todo list manually and contains a typo).</source>
          <target state="translated">&lt;code&gt;reset&lt;/code&gt; 명령은 지정된 개정에 HEAD, 인덱스 및 worktree를 재설정합니다. 그것은과 유사 &lt;code&gt;exec git reset --hard &amp;lt;label&amp;gt;&lt;/code&gt; 하지만, 비 추적 파일을 덮어 거부합니다. 경우 &lt;code&gt;reset&lt;/code&gt; 명령이 실패, 그것은 도움이 메시지와 함께 즉시 재조정하는 방법을 편집 할 일 목록 (A 때 일반적으로 발생 &lt;code&gt;reset&lt;/code&gt; 명령을 수동으로 할 일 목록에 삽입 오타가 포함되었다).</target>
        </trans-unit>
        <trans-unit id="f2c26b231ec380ef2e111ace64d683b597b18aa2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;seen&lt;/code&gt; branch will be updated even if it does not fast-forward, because it is prefixed with a plus sign; &lt;code&gt;tmp&lt;/code&gt; will not be.</source>
          <target state="translated">The &lt;code&gt;seen&lt;/code&gt; branch will be updated even if it does not fast-forward, because it is prefixed with a plus sign; &lt;code&gt;tmp&lt;/code&gt; will not be.</target>
        </trans-unit>
        <trans-unit id="06cca2918a8a255dfff1d384369e4d4195e47f51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shortlog&lt;/code&gt; view is more compact; it shows one commit per line.</source>
          <target state="translated">&lt;code&gt;shortlog&lt;/code&gt; 의 보기는 더 컴팩트; 행당 하나의 커밋을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="49d7635e517e74681985e2d5acfe0d3faa2b57eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tagger&lt;/code&gt; command uses the same format as &lt;code&gt;committer&lt;/code&gt; within &lt;code&gt;commit&lt;/code&gt;; again see above for details.</source>
          <target state="translated">&lt;code&gt;tagger&lt;/code&gt; 명령과 같은 포맷 사용 &lt;code&gt;committer&lt;/code&gt; 내의 &lt;code&gt;commit&lt;/code&gt; ; 자세한 내용은 위를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c5d1574573f9cb9deb3517e06eb81c31c726f5b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;textconv&lt;/code&gt; config option is used to define a program for performing such a conversion. The program should take a single argument, the name of a file to convert, and produce the resulting text on stdout.</source>
          <target state="translated">&lt;code&gt;textconv&lt;/code&gt; 설정 옵션은 이러한 변환을 수행하기위한 프로그램을 정의하는 데 사용됩니다. 프로그램은 변환 할 파일 이름이라는 단일 인수를 가져 와서 stdout에서 결과 텍스트를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a024de933cb7ecb7f2684cd23c20dd59cced4c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tformat:&lt;/code&gt; format works exactly like &lt;code&gt;format:&lt;/code&gt;, except that it provides &quot;terminator&quot; semantics instead of &quot;separator&quot; semantics. In other words, each commit has the message terminator character (usually a newline) appended, rather than a separator placed between entries. This means that the final entry of a single-line format will be properly terminated with a new line, just as the &quot;oneline&quot; format does. For example:</source>
          <target state="translated">&lt;code&gt;tformat:&lt;/code&gt; 형식은 정확히 같은 작품 &lt;code&gt;format:&lt;/code&gt; , 대신 &quot;분리&quot;의미의 &quot;터미네이터&quot;의미를 제공하는 것을 제외하고. 즉, 각 커밋에는 항목 사이에 구분 기호가 아닌 메시지 종료 문자 (보통 줄 바꿈)가 추가됩니다. 즉, &quot;한 줄&quot;형식과 마찬가지로 한 줄 형식의 최종 항목이 새 줄로 올바르게 종료됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df62988b77ac61a631e6a3bd598e4269b439619e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; variables determine what ends up in the &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;committer&lt;/code&gt; field of commit objects. If you need the &lt;code&gt;author&lt;/code&gt; or &lt;code&gt;committer&lt;/code&gt; to be different, the &lt;code&gt;author.name&lt;/code&gt;, &lt;code&gt;author.email&lt;/code&gt;, &lt;code&gt;committer.name&lt;/code&gt; or &lt;code&gt;committer.email&lt;/code&gt; variables can be set. Also, all of these can be overridden by the &lt;code&gt;GIT_AUTHOR_NAME&lt;/code&gt;, &lt;code&gt;GIT_AUTHOR_EMAIL&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_NAME&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_EMAIL&lt;/code&gt; and &lt;code&gt;EMAIL&lt;/code&gt; environment variables.</source>
          <target state="translated">The &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; variables determine what ends up in the &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;committer&lt;/code&gt; field of commit objects. If you need the &lt;code&gt;author&lt;/code&gt; or &lt;code&gt;committer&lt;/code&gt; to be different, the &lt;code&gt;author.name&lt;/code&gt; , &lt;code&gt;author.email&lt;/code&gt; , &lt;code&gt;committer.name&lt;/code&gt; or &lt;code&gt;committer.email&lt;/code&gt; variables can be set. Also, all of these can be overridden by the &lt;code&gt;GIT_AUTHOR_NAME&lt;/code&gt; , &lt;code&gt;GIT_AUTHOR_EMAIL&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_NAME&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_EMAIL&lt;/code&gt; and &lt;code&gt;EMAIL&lt;/code&gt; environment variables.</target>
        </trans-unit>
        <trans-unit id="52696bbc1bd35a1c1c6d78b6535a11990db3bb34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;user.name&lt;/code&gt; and &lt;code&gt;user.email&lt;/code&gt; variables determine what ends up in the &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;committer&lt;/code&gt; field of commit objects. If you need the &lt;code&gt;author&lt;/code&gt; or &lt;code&gt;committer&lt;/code&gt; to be different, the &lt;code&gt;author.name&lt;/code&gt;, &lt;code&gt;author.email&lt;/code&gt;, &lt;code&gt;committer.name&lt;/code&gt; or &lt;code&gt;committer.email&lt;/code&gt; variables can be set. Also, all of these can be overridden by the &lt;code&gt;GIT_AUTHOR_NAME&lt;/code&gt;, &lt;code&gt;GIT_AUTHOR_EMAIL&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_NAME&lt;/code&gt;, &lt;code&gt;GIT_COMMITTER_EMAIL&lt;/code&gt; and &lt;code&gt;EMAIL&lt;/code&gt; environment variables. See &lt;a href=&quot;git-commit-tree&quot;&gt;git-commit-tree[1]&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;user.name&lt;/code&gt; 및 &lt;code&gt;user.email&lt;/code&gt; 변수는에 끝을 결정 &lt;code&gt;author&lt;/code&gt; 및 &lt;code&gt;committer&lt;/code&gt; 객체를 커밋의 필드. 당신이 필요한 경우 &lt;code&gt;author&lt;/code&gt; 또는 &lt;code&gt;committer&lt;/code&gt; 다른 것으로는 &lt;code&gt;author.name&lt;/code&gt; , &lt;code&gt;author.email&lt;/code&gt; , &lt;code&gt;committer.name&lt;/code&gt; 또는 &lt;code&gt;committer.email&lt;/code&gt; 변수를 설정할 수 있습니다. 또한 이들 모두는 &lt;code&gt;GIT_AUTHOR_NAME&lt;/code&gt; , &lt;code&gt;GIT_AUTHOR_EMAIL&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_NAME&lt;/code&gt; , &lt;code&gt;GIT_COMMITTER_EMAIL&lt;/code&gt; 및 &lt;code&gt;EMAIL&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . &lt;a href=&quot;git-commit-tree&quot;&gt;자식 커밋 트리&lt;/a&gt; 참조 [1] 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="e856d2a5737e8a442522cf9dc045cf46da5c837d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;worktree list&lt;/code&gt; command has two output formats. The default format shows the details on a single line with columns. For example:</source>
          <target state="translated">The &lt;code&gt;worktree list&lt;/code&gt; command has two output formats. The default format shows the details on a single line with columns. For example:</target>
        </trans-unit>
        <trans-unit id="16ffcc56d5f44fe2ccdfd792b9ad74a964b837f9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;&amp;hellip;​&lt;/em&gt; (three-dot) Symmetric Difference Notation</source>
          <target state="translated">&lt;em&gt;...&lt;/em&gt; (세 점) 대칭 차이 표기</target>
        </trans-unit>
        <trans-unit id="3ca01d997f3f16d56fc54554bfe9b469c32c5dff" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;..&lt;/em&gt; (two-dot) Range Notation</source>
          <target state="translated">&lt;em&gt;..&lt;/em&gt; (두 점) 범위 표기법</target>
        </trans-unit>
        <trans-unit id="28292c9406d9116658f021a9e7e686e22523649d" translate="yes" xml:space="preserve">
          <source>The C rewrite is first included with Git version 2.22 (and Git for Windows version 2.19). This option serves as an escape hatch to re-enable the legacy version in case any bugs are found in the rewrite. This option and the shell script version of &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; will be removed in some future release.</source>
          <target state="translated">C 다시 쓰기는 Git 버전 2.22 (및 Git for Windows 버전 2.19)에 처음 포함됩니다. 이 옵션은 다시 쓰기에서 버그가 발견 될 경우 레거시 버전을 다시 활성화하는 이스케이프 해치 역할을합니다. 이 옵션과 &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; 의 쉘 스크립트 버전은 향후 릴리스에서 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="dbe462d7e2f126482bf0dec3d004def2c9c89bb6" translate="yes" xml:space="preserve">
          <source>The CVS module you want to import. Relative to &amp;lt;CVSROOT&amp;gt;. If not given, &lt;code&gt;git cvsimport&lt;/code&gt; tries to read it from &lt;code&gt;CVS/Repository&lt;/code&gt;.</source>
          <target state="translated">가져올 CVS 모듈 &amp;lt;CVSROOT&amp;gt;와 관련이 있습니다. 지정하지 않으면 &lt;code&gt;git cvsimport&lt;/code&gt; 는 &lt;code&gt;CVS/Repository&lt;/code&gt; 에서 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="d9fdb00c7bf3f2937ed399ea5a7eb5783533387f" translate="yes" xml:space="preserve">
          <source>The Event Format Target</source>
          <target state="translated">이벤트 형식 대상</target>
        </trans-unit>
        <trans-unit id="91f31eeacecff37ec38db2aff37269235d7422bb" translate="yes" xml:space="preserve">
          <source>The GIT_TRACE_&amp;lt;key&amp;gt; mechanism allows each &amp;lt;key&amp;gt; to write to a different file (in addition to just stderr).</source>
          <target state="translated">GIT_TRACE_ &amp;lt;key&amp;gt; 메커니즘을 사용하면 각 &amp;lt;key&amp;gt;가 다른 파일에 쓸 수 있습니다 (stderr뿐 아니라).</target>
        </trans-unit>
        <trans-unit id="eb9c24f633d0777727caf33c8ede260c0246d232" translate="yes" xml:space="preserve">
          <source>The GPG key ID of the key that signed the push certificate.</source>
          <target state="translated">푸시 인증서에 서명 한 키의 GPG 키 ID입니다.</target>
        </trans-unit>
        <trans-unit id="7fd047e9e0dcddc0ec24d2bfa4a8d0b4477b60c4" translate="yes" xml:space="preserve">
          <source>The Git Repository</source>
          <target state="translated">힘내 리포지토리</target>
        </trans-unit>
        <trans-unit id="ec69c4a3fd32f0743df23ab218ec13475fdae8cc" translate="yes" xml:space="preserve">
          <source>The Git configuration file contains a number of variables that affect the Git commands' behavior. The files &lt;code&gt;.git/config&lt;/code&gt; and optionally &lt;code&gt;config.worktree&lt;/code&gt; (see &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; below) in each repository are used to store the configuration for that repository, and &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; is used to store a per-user configuration as fallback values for the &lt;code&gt;.git/config&lt;/code&gt; file. The file &lt;code&gt;/etc/gitconfig&lt;/code&gt; can be used to store a system-wide default configuration.</source>
          <target state="translated">Git 구성 파일에는 Git 명령의 동작에 영향을주는 여러 변수가 포함되어 있습니다. 각 저장소의 &lt;code&gt;.git/config&lt;/code&gt; 및 선택적으로 &lt;code&gt;config.worktree&lt;/code&gt; 파일 (아래 &lt;code&gt;extensions.worktreeConfig&lt;/code&gt; 참조)은 해당 저장소의 구성을 저장하는 데 사용되고 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 는 사용자 별 구성을 대체 값으로 저장하는 데 사용됩니다. &lt;code&gt;.git/config&lt;/code&gt; 파일. &lt;code&gt;/etc/gitconfig&lt;/code&gt; 파일 을 사용하여 시스템 전체 기본 구성을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57dbf68c8f67f403d793ac43faa2e8d1a6fb8f3b" translate="yes" xml:space="preserve">
          <source>The Git configuration file contains a number of variables that affect the Git commands' behavior. The files &lt;code&gt;.git/config&lt;/code&gt; and optionally &lt;code&gt;config.worktree&lt;/code&gt; (see the &quot;CONFIGURATION FILE&quot; section of &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt;) in each repository are used to store the configuration for that repository, and &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; is used to store a per-user configuration as fallback values for the &lt;code&gt;.git/config&lt;/code&gt; file. The file &lt;code&gt;/etc/gitconfig&lt;/code&gt; can be used to store a system-wide default configuration.</source>
          <target state="translated">The Git configuration file contains a number of variables that affect the Git commands' behavior. The files &lt;code&gt;.git/config&lt;/code&gt; and optionally &lt;code&gt;config.worktree&lt;/code&gt; (see the &quot;CONFIGURATION FILE&quot; section of &lt;a href=&quot;git-worktree&quot;&gt;git-worktree[1]&lt;/a&gt;) in each repository are used to store the configuration for that repository, and &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; is used to store a per-user configuration as fallback values for the &lt;code&gt;.git/config&lt;/code&gt; file. The file &lt;code&gt;/etc/gitconfig&lt;/code&gt; can be used to store a system-wide default configuration.</target>
        </trans-unit>
        <trans-unit id="c4676de1f2b8af7673ad60d0d802fc7e29d8da30" translate="yes" xml:space="preserve">
          <source>The Git object directory contains a &lt;code&gt;pack&lt;/code&gt; directory containing packfiles (with suffix &quot;.pack&quot;) and pack-indexes (with suffix &quot;.idx&quot;). The pack-indexes provide a way to lookup objects and navigate to their offset within the pack, but these must come in pairs with the packfiles. This pairing depends on the file names, as the pack-index differs only in suffix with its pack- file. While the pack-indexes provide fast lookup per packfile, this performance degrades as the number of packfiles increases, because abbreviations need to inspect every packfile and we are more likely to have a miss on our most-recently-used packfile. For some large repositories, repacking into a single packfile is not feasible due to storage space or excessive repack times.</source>
          <target state="translated">Git 객체 디렉토리에는 packfiles (접미사 &quot;.pack&quot;)와 pack-indexes (접미사 &quot;.idx&quot;) 가 들어있는 &lt;code&gt;pack&lt;/code&gt; 디렉토리가 있습니다. 팩 인덱스는 팩 내에서 객체를 조회하고 오프셋을 탐색하는 방법을 제공하지만 팩 파일과 쌍을 이루어야합니다. pack-index는 pack- 파일의 접미사 만 다르기 때문에이 쌍은 파일 이름에 따라 다릅니다. 팩 인덱스는 팩 파일 당 빠른 조회를 제공하지만 약어는 모든 팩 파일을 검사해야하고 가장 최근에 사용 된 팩 파일을 놓칠 가능성이 높기 때문에 팩 파일 수가 증가함에 따라 성능이 저하됩니다. 일부 큰 리포지토리의 경우 저장 공간이나 과도한 재 포장 시간으로 인해 단일 팩 파일로 재 포장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a2329c4ac9f08d776040ac221ffa562b7323c3f6" translate="yes" xml:space="preserve">
          <source>The Git protocol gives better performance and reliability, but on a host with a web server set up, HTTP exports may be simpler to set up.</source>
          <target state="translated">Git 프로토콜은 더 나은 성능과 안정성을 제공하지만 웹 서버가 설정된 호스트에서는 HTTP 내보내기를 설정하는 것이 더 간단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1179b23d825b14c0a26acd1779bd21e4b7a2880e" translate="yes" xml:space="preserve">
          <source>The Git remote to import this CVS repository into. Moves all CVS branches into remotes/&amp;lt;remote&amp;gt;/&amp;lt;branch&amp;gt; akin to the way &lt;code&gt;git clone&lt;/code&gt; uses &lt;code&gt;origin&lt;/code&gt; by default.</source>
          <target state="translated">이 CVS 저장소를 가져올 Git 원격. &lt;code&gt;git clone&lt;/code&gt; 이 기본적으로 &lt;code&gt;origin&lt;/code&gt; 을 사용 하는 방식과 유사하게 모든 CVS 분기를 remotes / &amp;lt;remote&amp;gt; / &amp;lt;branch&amp;gt;로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="bd47eb27f30e04cbdc75cd21789edadd8836d3bb" translate="yes" xml:space="preserve">
          <source>The Git repository browser</source>
          <target state="translated">Git 리포지토리 브라우저</target>
        </trans-unit>
        <trans-unit id="076055123196294023f50dc3852a8243be06956f" translate="yes" xml:space="preserve">
          <source>The Git repository browser. Shows branches, commit history and file differences. gitk is the utility started by &lt;code&gt;git gui&lt;/code&gt;'s Repository Visualize actions.</source>
          <target state="translated">Git 리포지토리 브라우저. 브랜치, 커밋 히스토리 및 파일 차이를 보여줍니다. gitk는 &lt;code&gt;git gui&lt;/code&gt; 의 Repository Visualize 액션에 의해 시작된 유틸리티 입니다.</target>
        </trans-unit>
        <trans-unit id="703dfd23887a83d4329e915dd0bcbd7608c6b6a7" translate="yes" xml:space="preserve">
          <source>The Git repository to import to. If the directory doesn&amp;rsquo;t exist, it will be created. Default is the current directory.</source>
          <target state="translated">가져올 Git 저장소. 디렉토리가 존재하지 않으면 작성됩니다. 기본값은 현재 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="6970e04ce98d2b4a3b2c6e8de2880e4a745e2c4f" translate="yes" xml:space="preserve">
          <source>The HEAD then refers to the SHA-1 of the commit instead of to a branch, and git branch shows that you are no longer on a branch:</source>
          <target state="translated">그러면 HEAD는 브랜치 대신 커밋의 SHA-1을 참조하고 git 브랜치는 더 이상 브랜치에 있지 않음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="895d60d2bce01273de11df4a950c78fe3184bcf0" translate="yes" xml:space="preserve">
          <source>The HTTP USER_AGENT string presented to an HTTP server. The default value represents the version of the client Git such as git/1.7.1. This option allows you to override this value to a more common value such as Mozilla/4.0. This may be necessary, for instance, if connecting through a firewall that restricts HTTP connections to a set of common USER_AGENT strings (but not including those like git/1.7.1). Can be overridden by the &lt;code&gt;GIT_HTTP_USER_AGENT&lt;/code&gt; environment variable.</source>
          <target state="translated">HTTP USER_AGENT 문자열이 HTTP 서버에 제공되었습니다. 기본값은 git / 1.7.1과 같은 클라이언트 Git의 버전을 나타냅니다. 이 옵션을 사용하면이 값을 Mozilla / 4.0과 같은보다 일반적인 값으로 대체 할 수 있습니다. 예를 들어, HTTP 연결을 공통 USER_AGENT 문자열 세트로 제한하는 방화벽을 통해 연결하는 경우 (git / 1.7.1과 같은 문자열은 제외) 필요할 수 있습니다. &lt;code&gt;GIT_HTTP_USER_AGENT&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00aa9820c66c0255936f6c8707aec2ad36a5c140" translate="yes" xml:space="preserve">
          <source>The HTTP daemon command-line that will be executed. Command-line options may be specified here, and the configuration file will be added at the end of the command-line. Currently apache2, lighttpd, mongoose, plackup, python and webrick are supported. (Default: lighttpd)</source>
          <target state="translated">실행될 HTTP 데몬 명령 줄. 여기서 명령 줄 옵션을 지정할 수 있으며 구성 파일은 명령 줄 끝에 추가됩니다. 현재 apache2, lighttpd, mongoose, plackup, python 및 webrick이 지원됩니다. (기본값 : lighttpd)</target>
        </trans-unit>
        <trans-unit id="adee6c32cf5372a9cc214e1cabc3f604f4a421cf" translate="yes" xml:space="preserve">
          <source>The HTTP daemon command-line to start gitweb on your working repository. See &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;.</source>
          <target state="translated">작업 저장소에서 gitweb을 시작하기위한 HTTP 데몬 명령 줄. &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a20118bebd861685578a19065b0fb24ab670ec89" translate="yes" xml:space="preserve">
          <source>The MIDX file format uses a chunk-based approach (similar to the commit-graph file) that allows optional data to be added.</source>
          <target state="translated">MIDX 파일 형식은 선택적인 데이터를 추가 할 수있는 청크 기반 접근 방식 (커밋 그래프 파일과 유사)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="64e372cd9f501c41226d338629f4adfe7884c507" translate="yes" xml:space="preserve">
          <source>The MIDX is stored in a file named &lt;code&gt;multi-pack-index&lt;/code&gt; in the .git/objects/pack directory. This could be stored in the pack directory of an alternate. It refers only to packfiles in that same directory.</source>
          <target state="translated">MIDX는 .git / objects / pack 디렉토리의 &lt;code&gt;multi-pack-index&lt;/code&gt; 라는 파일에 저장됩니다 . 이것은 대체의 pack 디렉토리에 저장 될 수 있습니다. 동일한 디렉토리에있는 팩 파일 만 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="be240040a2b303919e9f8b3f8c55bd2d4b871823" translate="yes" xml:space="preserve">
          <source>The MIDX keeps only one record per object ID. If an object appears in multiple packfiles, then the MIDX selects the copy in the most- recently modified packfile.</source>
          <target state="translated">MIDX는 객체 ID 당 하나의 레코드 만 유지합니다. 객체가 여러 팩 파일에 나타나는 경우 MIDX는 가장 최근에 수정 된 팩 파일에서 사본을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="d248ab48f510e2fbd4b16391dc71868ce2bb9eb7" translate="yes" xml:space="preserve">
          <source>The MUA corrupted your patch; &quot;am&quot; would complain that the patch does not apply. Look in the .git/rebase-apply/ subdirectory and see what &lt;code&gt;patch&lt;/code&gt; file contains and check for the common corruption patterns mentioned above.</source>
          <target state="translated">MUA가 패치를 손상 시켰습니다. &quot;am&quot;은 패치가 적용되지 않는다고 불평합니다. .git / rebase-apply / 서브 디렉토리에서 &lt;code&gt;patch&lt;/code&gt; 파일에 어떤 패치 파일이 포함되어 있는지 확인하고 위에서 언급 한 일반적인 손상 패턴을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="dcfedffa2e791a211c838c6711816e41fded8f05" translate="yes" xml:space="preserve">
          <source>The Normal Format Target</source>
          <target state="translated">일반 형식 대상</target>
        </trans-unit>
        <trans-unit id="500d32200a061b0c3eb8acb59a37b1ba3087273e" translate="yes" xml:space="preserve">
          <source>The Object Database</source>
          <target state="translated">객체 데이터베이스</target>
        </trans-unit>
        <trans-unit id="b3b387e6e23160b9001074a3b231e88c333277a0" translate="yes" xml:space="preserve">
          <source>The PERF target is intended for interactive performance analysis during development and is quite noisy.</source>
          <target state="translated">PERF 목표는 개발 중 대화 형 성능 분석을위한 것이며 시끄러운 소리입니다.</target>
        </trans-unit>
        <trans-unit id="716ba6c2a540215443944eab8349af10087e97bb" translate="yes" xml:space="preserve">
          <source>The Performance Format Target</source>
          <target state="translated">성능 형식 목표</target>
        </trans-unit>
        <trans-unit id="ca04878afc5a61720c26b830b963e827e884a4f1" translate="yes" xml:space="preserve">
          <source>The SSL version to use when negotiating an SSL connection, if you want to force the default. The available and default version depend on whether libcurl was built against NSS or OpenSSL and the particular configuration of the crypto library in use. Internally this sets the &lt;code&gt;CURLOPT_SSL_VERSION&lt;/code&gt; option; see the libcurl documentation for more details on the format of this option and for the ssl version supported. Actually the possible values of this option are:</source>
          <target state="translated">기본값을 강제로 적용하려는 경우 SSL 연결을 협상 할 때 사용할 SSL 버전입니다. 사용 가능한 기본 버전은 libcurl이 NSS 또는 OpenSSL을 기반으로 구축되었는지 여부와 사용중인 암호화 라이브러리의 특정 구성에 따라 다릅니다. 내부적으로 &lt;code&gt;CURLOPT_SSL_VERSION&lt;/code&gt; 옵션 이 설정됩니다 . 이 옵션의 형식과 지원되는 SSL 버전에 대한 자세한 내용은 libcurl 설명서를 참조하십시오. 실제로이 옵션의 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="018a79839a5b69e87551f5d2d8901721b830b6f5" translate="yes" xml:space="preserve">
          <source>The SSL version to use when negotiating an SSL connection, if you want to force the default. The available and default version depend on whether libcurl was built against NSS or OpenSSL and the particular configuration of the crypto library in use. Internally this sets the &lt;code&gt;CURLOPT_SSL_VERSION&lt;/code&gt; option; see the libcurl documentation for more details on the format of this option and for the ssl version supported. Currently the possible values of this option are:</source>
          <target state="translated">The SSL version to use when negotiating an SSL connection, if you want to force the default. The available and default version depend on whether libcurl was built against NSS or OpenSSL and the particular configuration of the crypto library in use. Internally this sets the &lt;code&gt;CURLOPT_SSL_VERSION&lt;/code&gt; option; see the libcurl documentation for more details on the format of this option and for the ssl version supported. Currently the possible values of this option are:</target>
        </trans-unit>
        <trans-unit id="6c8d77384dcf5927fceefc0c82e6aa35599c0a0b" translate="yes" xml:space="preserve">
          <source>The Trace2 API can be used to print debug, performance, and telemetry information to stderr or a file. The Trace2 feature is inactive unless explicitly enabled by enabling one or more Trace2 Targets.</source>
          <target state="translated">Trace2 API를 사용하여 디버그, 성능 및 원격 분석 정보를 stderr 또는 파일로 인쇄 할 수 있습니다. 하나 이상의 Trace2 대상을 활성화하여 명시 적으로 활성화하지 않으면 Trace2 기능이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="6bdbd91221731e97e635f28174406bd894d81047" translate="yes" xml:space="preserve">
          <source>The Trace2 API defines a set of high-level messages with known fields, such as (&lt;code&gt;start&lt;/code&gt;: &lt;code&gt;argv&lt;/code&gt;) and (&lt;code&gt;exit&lt;/code&gt;: {&lt;code&gt;exit-code&lt;/code&gt;, &lt;code&gt;elapsed-time&lt;/code&gt;}).</source>
          <target state="translated">Trace2 API는 ( &lt;code&gt;start&lt;/code&gt; : &lt;code&gt;argv&lt;/code&gt; ) 및 ( &lt;code&gt;exit&lt;/code&gt; : { &lt;code&gt;exit-code&lt;/code&gt; , &lt;code&gt;elapsed-time&lt;/code&gt; }) 과 같이 알려진 필드가있는 상위 레벨 메시지 세트를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="c8d932fd39b46f7d652bfdd2be6511ab09fc4671" translate="yes" xml:space="preserve">
          <source>The Trace2 API is intended to replace the existing (Trace1) printf-style tracing provided by the existing &lt;code&gt;GIT_TRACE&lt;/code&gt; and &lt;code&gt;GIT_TRACE_PERFORMANCE&lt;/code&gt; facilities. During initial implementation, Trace2 and Trace1 may operate in parallel.</source>
          <target state="translated">Trace2 API는 기존 &lt;code&gt;GIT_TRACE&lt;/code&gt; 및 &lt;code&gt;GIT_TRACE_PERFORMANCE&lt;/code&gt; 기능이 제공하는 기존 (Trace1) printf 스타일 추적을 대체하기위한 것 입니다. 초기 구현 중에 Trace2와 Trace1이 병렬로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5397d7e9698d7ad87ff097450bf8a8e1a772416" translate="yes" xml:space="preserve">
          <source>The Trace2 code also defines a set of private functions and data types in the &lt;code&gt;trace2/&lt;/code&gt; directory. These symbols are prefixed with &lt;code&gt;tr2_&lt;/code&gt; and should only be used by functions in &lt;code&gt;trace2.c&lt;/code&gt;.</source>
          <target state="translated">Trace2 코드는 &lt;code&gt;trace2/&lt;/code&gt; 디렉토리 에 개인 함수 및 데이터 유형 세트도 정의합니다 . 이 기호는 접두사가 &lt;code&gt;tr2_&lt;/code&gt; 이고 &lt;code&gt;trace2.c&lt;/code&gt; 의 함수 만 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8e231fe7d9a0eb53151c1a418399ded2fd9db9e8" translate="yes" xml:space="preserve">
          <source>The URL for a submodule. This variable is copied from the .gitmodules file to the git config via &lt;code&gt;git submodule init&lt;/code&gt;. The user can change the configured URL before obtaining the submodule via &lt;code&gt;git submodule update&lt;/code&gt;. If neither submodule.&amp;lt;name&amp;gt;.active or submodule.active are set, the presence of this variable is used as a fallback to indicate whether the submodule is of interest to git commands. See &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; and &lt;a href=&quot;gitmodules&quot;&gt;gitmodules[5]&lt;/a&gt; for details.</source>
          <target state="translated">하위 모듈의 URL입니다. 이 변수는 &lt;code&gt;git submodule init&lt;/code&gt; 를 통해 .gitmodules 파일에서 git config로 복사됩니다 . 사용자는 &lt;code&gt;git submodule update&lt;/code&gt; 를 통해 서브 모듈을 얻기 전에 구성된 URL을 변경할 수 있습니다 . submodule. &amp;lt;name&amp;gt; .active 또는 submodule.active가 설정되지 않은 경우이 변수의 존재는 하위 모듈이 git 명령에 관심이 있는지 여부를 나타내는 대체로 사용됩니다. 자세한 내용은 &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; 및 &lt;a href=&quot;gitmodules&quot;&gt;gitmodules [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="307f8458b88cd1196dc3047eb250fdb8e3348b46" translate="yes" xml:space="preserve">
          <source>The URL of a remote repository. See &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; or &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">원격 저장소의 URL입니다. 참조 &lt;a href=&quot;git-fetch&quot;&gt;[1] 자식 페치&lt;/a&gt; 또는 &lt;a href=&quot;git-push&quot;&gt;자식 푸시 [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92c06c873fe7803ddcdb456ba837dbd24d10b389" translate="yes" xml:space="preserve">
          <source>The URL to the remote repository.</source>
          <target state="translated">원격 저장소의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="846d99295948de526a5621f0a520c5a9a78af747" translate="yes" xml:space="preserve">
          <source>The Workflow</source>
          <target state="translated">워크 플로우</target>
        </trans-unit>
        <trans-unit id="91d8165377483e9123ecf4a3d5455b3b1999d185" translate="yes" xml:space="preserve">
          <source>The above can also be written as simply</source>
          <target state="translated">위의 내용은 간단하게 작성할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="13c712cb6756cc53fb3407886d0503d18cb537c0" translate="yes" xml:space="preserve">
          <source>The above command copies all branches from the remote refs/heads/ namespace and stores them to the local refs/remotes/origin/ namespace, unless the branch.&amp;lt;name&amp;gt;.fetch option is used to specify a non-default refspec.</source>
          <target state="translated">위의 명령은 기본 refspec을 지정하는 데 branch. &amp;lt;name&amp;gt; .fetch 옵션을 사용하지 않는 한 원격 refs / heads / 네임 스페이스에서 모든 브랜치를 복사하여 로컬 refs / remotes / origin / 네임 스페이스에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="61e1efd32cbb415eea7b734b98558317a6d1aac3" translate="yes" xml:space="preserve">
          <source>The above command would change the origin repository to</source>
          <target state="translated">위의 명령은 원본 저장소를</target>
        </trans-unit>
        <trans-unit id="cc504649b9359e7717badcdf0f10e04d6127c3a0" translate="yes" xml:space="preserve">
          <source>The above configuration expects your public repositories to live under &lt;code&gt;/pub/git&lt;/code&gt; and will serve them as &lt;code&gt;http://git.domain.org/dir-under-pub-git&lt;/code&gt;, both as clonable Git URL and as browseable gitweb interface. If you then start your &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; with &lt;code&gt;--base-path=/pub/git --export-all&lt;/code&gt; then you can even use the &lt;code&gt;git://&lt;/code&gt; URL with exactly the same path.</source>
          <target state="translated">위의 구성은 퍼블릭 리포지토리가 &lt;code&gt;/pub/git&lt;/code&gt; 아래에 있어야 하며 복제 가능한 Git URL과 탐색 가능한 gitweb 인터페이스 로 &lt;code&gt;http://git.domain.org/dir-under-pub-git&lt;/code&gt; 으로 제공됩니다. 그런 다음 시작하면 &lt;a href=&quot;git-daemon&quot;&gt;자식 - 데몬 [1]&lt;/a&gt; 로 &lt;code&gt;--base-path=/pub/git --export-all&lt;/code&gt; 당신도 사용할 수있는 &lt;code&gt;git://&lt;/code&gt; URL 정확히 같은 경로.</target>
        </trans-unit>
        <trans-unit id="baa5f35656f9b3f3ba646932132fa97233a197b9" translate="yes" xml:space="preserve">
          <source>The above is all you need to know to resolve a simple merge. But Git also provides more information to help resolve conflicts:</source>
          <target state="translated">위의 간단한 병합을 해결하기 위해 알아야 할 모든 것입니다. 그러나 Git은 충돌 해결에 도움이되는 추가 정보도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="70fce3bc08ea4ed40bcc99c52f88c26bd24f0b87" translate="yes" xml:space="preserve">
          <source>The above is the description of a Git merge at the lowest level, to help you understand what conceptually happens under the hood. In practice, nobody, not even Git itself, runs &lt;code&gt;git cat-file&lt;/code&gt; three times for this. There is a &lt;code&gt;git merge-index&lt;/code&gt; program that extracts the stages to temporary files and calls a &quot;merge&quot; script on it:</source>
          <target state="translated">위는 가장 낮은 수준에서 Git 병합에 대한 설명으로, 후드에서 개념적으로 발생하는 것을 이해하는 데 도움이됩니다. 실제로 Git 자체조차도 아무도 &lt;code&gt;git cat-file&lt;/code&gt; 을 세 번 실행하지 않습니다 . 임시 파일로 스테이지를 추출하고 그 위에 &quot;병합&quot;스크립트를 호출 하는 &lt;code&gt;git merge-index&lt;/code&gt; 프로그램이 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb77c0d462477bf4637c28037a03befbbf605c33" translate="yes" xml:space="preserve">
          <source>The absolute path to the worktree in which the ref is checked out, if it is checked out in any linked worktree. Empty string otherwise.</source>
          <target state="translated">링크 된 워크 트리에서 체크 아웃 된 경우 참조가 체크 아웃 된 워크 트리의 절대 경로입니다. 그렇지 않으면 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="76cd9fb4bfcc53cf44ccfea4ed1923acc958405e" translate="yes" xml:space="preserve">
          <source>The accepted attributes are &lt;code&gt;bold&lt;/code&gt;, &lt;code&gt;dim&lt;/code&gt;, &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;blink&lt;/code&gt;, &lt;code&gt;reverse&lt;/code&gt;, &lt;code&gt;italic&lt;/code&gt;, and &lt;code&gt;strike&lt;/code&gt; (for crossed-out or &quot;strikethrough&quot; letters). The position of any attributes with respect to the colors (before, after, or in between), doesn&amp;rsquo;t matter. Specific attributes may be turned off by prefixing them with &lt;code&gt;no&lt;/code&gt; or &lt;code&gt;no-&lt;/code&gt; (e.g., &lt;code&gt;noreverse&lt;/code&gt;, &lt;code&gt;no-ul&lt;/code&gt;, etc).</source>
          <target state="translated">허용되는 속성은 &lt;code&gt;bold&lt;/code&gt; , &lt;code&gt;dim&lt;/code&gt; , &lt;code&gt;ul&lt;/code&gt; , &lt;code&gt;blink&lt;/code&gt; , &lt;code&gt;reverse&lt;/code&gt; , &lt;code&gt;italic&lt;/code&gt; 및 &lt;code&gt;strike&lt;/code&gt; (교차 문자 또는 &quot; 파업 문자&quot;)입니다. 색상 (전, 후 또는 사이)과 관련된 속성의 위치는 중요하지 않습니다. 접두사로 &lt;code&gt;no&lt;/code&gt; 또는 &lt;code&gt;no-&lt;/code&gt; 를 붙임으로써 특정 속성을 끌 수 있습니다 (예 : &lt;code&gt;noreverse&lt;/code&gt; , &lt;code&gt;no-ul&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="0bb8a69a5cde6b982a60a95e4956ebdf1a59fa5f" translate="yes" xml:space="preserve">
          <source>The accepted patterns in the cone pattern set are:</source>
          <target state="translated">원뿔 패턴 세트에서 허용되는 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec26e1bb6d1ddd903fea6ea4b1aec39f9a4bdff7" translate="yes" xml:space="preserve">
          <source>The action of fixing up manually what a failed automatic &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; left behind.</source>
          <target state="translated">실패한 자동 &lt;a href=&quot;#def_merge&quot;&gt;병합이&lt;/a&gt; 남은 것을 수동으로 수정하는 작업 .</target>
        </trans-unit>
        <trans-unit id="91929f919cdca3ddad9711d4446a1108e24ab05c" translate="yes" xml:space="preserve">
          <source>The action of updating all or part of the &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; with a &lt;a href=&quot;#def_tree_object&quot;&gt;tree object&lt;/a&gt; or &lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt; from the &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt;, and updating the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; and &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; if the whole working tree has been pointed at a new &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_working_tree&quot;&gt;작업 트리&lt;/a&gt; 의 전체 또는 일부가 새 &lt;a href=&quot;#def_branch&quot;&gt;분기를&lt;/a&gt; 가리키면 작업 트리의 전체 또는 일부를 &lt;a href=&quot;#def_object_database&quot;&gt;개체 데이터베이스&lt;/a&gt; 의 &lt;a href=&quot;#def_tree_object&quot;&gt;트리 개체&lt;/a&gt; 또는 &lt;a href=&quot;#def_blob_object&quot;&gt;얼룩&lt;/a&gt; 으로 업데이트하고 &lt;a href=&quot;#def_index&quot;&gt;인덱스&lt;/a&gt; 와 &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD를&lt;/a&gt; 업데이트하는 작업입니다 .</target>
        </trans-unit>
        <trans-unit id="bf91c6dac7e4978798d8310657f124dd799f4bf4" translate="yes" xml:space="preserve">
          <source>The action that will be run. Defaults to &lt;code&gt;projects_list&lt;/code&gt; if repo is not set, and to &lt;code&gt;summary&lt;/code&gt; otherwise.</source>
          <target state="translated">실행될 조치입니다. repo가 ​​설정되지 않은 경우 기본값은 &lt;code&gt;projects_list&lt;/code&gt; 이고 그렇지 않으면 &lt;code&gt;summary&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="e262b52287502541a33fa85d5cf2fdae897da448" translate="yes" xml:space="preserve">
          <source>The active branch LRU, when coupled with the filename string pool and lazy loading of subtrees, allows fast-import to efficiently import projects with 2,000+ branches and 45,114+ files in a very limited memory footprint (less than 2.7 MiB per active branch).</source>
          <target state="translated">활성 브랜치 LRU는 파일 이름 문자열 풀 및 하위 트리의 느린로드와 결합 될 때 매우 제한된 메모리 풋 프린트 (활성 브랜치 당 2.7 MiB 미만)로 2,000 개 이상의 브랜치 및 45,114+ 개의 파일이있는 프로젝트를 빠르게 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b37048d4139b83b97c29aa7a22d2da66c283ae2" translate="yes" xml:space="preserve">
          <source>The actual configuration line should be on one line.</source>
          <target state="translated">실제 구성 줄은 한 줄에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b70c0ba474f3173fff896ac2745af10a69e6cc3b" translate="yes" xml:space="preserve">
          <source>The additional AliasMatch makes it so that</source>
          <target state="translated">추가 AliasMatch를 통해</target>
        </trans-unit>
        <trans-unit id="d6139a3bd26979c3a7767519a48aa9c385b73634" translate="yes" xml:space="preserve">
          <source>The advantage of doing this is that the history of &lt;code&gt;next&lt;/code&gt; will be clean. For example, some topics merged into &lt;code&gt;next&lt;/code&gt; may have initially looked promising, but were later found to be undesirable or premature. In such a case, the topic is reverted out of &lt;code&gt;next&lt;/code&gt; but the fact remains in the history that it was once merged and reverted. By recreating &lt;code&gt;next&lt;/code&gt;, you give another incarnation of such topics a clean slate to retry, and a feature release is a good point in history to do so.</source>
          <target state="translated">이 작업의 장점은 &lt;code&gt;next&lt;/code&gt; 역사가 깨끗 하다는 것입니다. 예를 들어, &lt;code&gt;next&lt;/code&gt; 병합 된 일부 주제 는 처음에는 유망 해 보였지만 나중에 바람직하지 않거나 조기에 발견되었습니다. 이 경우 주제는 &lt;code&gt;next&lt;/code&gt; 로 되돌아 가지만 사실은 한 번 병합되고 되돌아 간 역사에 남아 있습니다. 다시 만들어 &lt;code&gt;next&lt;/code&gt; , 다시 시도에 같은 주제의 또 다른 화신에게 백지를주고, 기능 해제 그렇게 할 역사에 좋은 지점입니다.</target>
        </trans-unit>
        <trans-unit id="2f1746fed6139a8489ee3d916322bdcbeb17e684" translate="yes" xml:space="preserve">
          <source>The advantage of using an external diff command is flexibility. You are not bound to find line-oriented changes, nor is it necessary for the output to resemble unified diff. You are free to locate and report changes in the most appropriate way for your data format.</source>
          <target state="translated">외부 diff 명령을 사용하면 얻을 수있는 이점은 유연성입니다. 라인 중심의 변경 사항을 찾아야하거나 출력이 통합 된 diff와 비슷할 필요도 없습니다. 데이터 형식에 가장 적합한 방식으로 변경 사항을 찾아보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37f935f00ace4f7aca8e441adbbf1abe0704a83a" translate="yes" xml:space="preserve">
          <source>The am backend drops any &quot;empty&quot; commits, regardless of whether the commit started empty (had no changes relative to its parent to start with) or ended empty (all changes were already applied upstream in other commits).</source>
          <target state="translated">am 백엔드는 커밋이 비어 있기 시작했거나 (부모에 대한 변경 사항이 없었 음) 비어 있었는지 (모든 변경 사항이 이미 다른 커밋에서 업스트림에 적용되었는지) 여부에 관계없이 &quot;빈&quot;커밋을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="dca841501c279516ee09991304a0c48e7701d81e" translate="yes" xml:space="preserve">
          <source>The apply backend has not traditionally called the post-commit hook, while the merge backend has. Both have called the post-checkout hook, though the merge backend has squelched its output. Further, both backends only call the post-checkout hook with the starting point commit of the rebase, not the intermediate commits nor the final commit. In each case, the calling of these hooks was by accident of implementation rather than by design (both backends were originally implemented as shell scripts and happened to invoke other commands like &lt;code&gt;git checkout&lt;/code&gt; or &lt;code&gt;git commit&lt;/code&gt; that would call the hooks). Both backends should have the same behavior, though it is not entirely clear which, if any, is correct. We will likely make rebase stop calling either of these hooks in the future.</source>
          <target state="translated">The apply backend has not traditionally called the post-commit hook, while the merge backend has. Both have called the post-checkout hook, though the merge backend has squelched its output. Further, both backends only call the post-checkout hook with the starting point commit of the rebase, not the intermediate commits nor the final commit. In each case, the calling of these hooks was by accident of implementation rather than by design (both backends were originally implemented as shell scripts and happened to invoke other commands like &lt;code&gt;git checkout&lt;/code&gt; or &lt;code&gt;git commit&lt;/code&gt; that would call the hooks). Both backends should have the same behavior, though it is not entirely clear which, if any, is correct. We will likely make rebase stop calling either of these hooks in the future.</target>
        </trans-unit>
        <trans-unit id="2d847a3833f639a38bf6461e5e337a484ba4ec15" translate="yes" xml:space="preserve">
          <source>The apply backend has safety problems with an ill-timed interrupt; if the user presses Ctrl-C at the wrong time to try to abort the rebase, the rebase can enter a state where it cannot be aborted with a subsequent &lt;code&gt;git rebase --abort&lt;/code&gt;. The merge backend does not appear to suffer from the same shortcoming. (See &lt;a href=&quot;https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/&quot;&gt;https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/&lt;/a&gt; for details.)</source>
          <target state="translated">The apply backend has safety problems with an ill-timed interrupt; if the user presses Ctrl-C at the wrong time to try to abort the rebase, the rebase can enter a state where it cannot be aborted with a subsequent &lt;code&gt;git rebase --abort&lt;/code&gt; . The merge backend does not appear to suffer from the same shortcoming. (See &lt;a href=&quot;https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/&quot;&gt;https://lore.kernel.org/git/20200207132152.GC2868@szeder.dev/&lt;/a&gt; for details.)</target>
        </trans-unit>
        <trans-unit id="dee2d136841d9fd2b1d297f54743df3833db5f0a" translate="yes" xml:space="preserve">
          <source>The apply backend unfortunately drops intentionally empty commits, i.e. commits that started empty, though these are rare in practice. It also drops commits that become empty and has no option for controlling this behavior.</source>
          <target state="translated">The apply backend unfortunately drops intentionally empty commits, i.e. commits that started empty, though these are rare in practice. It also drops commits that become empty and has no option for controlling this behavior.</target>
        </trans-unit>
        <trans-unit id="589a509b2859f73d9f2a04b58c811ba95394014f" translate="yes" xml:space="preserve">
          <source>The apply backend works by creating a sequence of patches (by calling &lt;code&gt;format-patch&lt;/code&gt; internally), and then applying the patches in sequence (calling &lt;code&gt;am&lt;/code&gt; internally). Patches are composed of multiple hunks, each with line numbers, a context region, and the actual changes. The line numbers have to be taken with some fuzz, since the other side will likely have inserted or deleted lines earlier in the file. The context region is meant to help find how to adjust the line numbers in order to apply the changes to the right lines. However, if multiple areas of the code have the same surrounding lines of context, the wrong one can be picked. There are real-world cases where this has caused commits to be reapplied incorrectly with no conflicts reported. Setting diff.context to a larger value may prevent such types of problems, but increases the chance of spurious conflicts (since it will require more lines of matching context to apply).</source>
          <target state="translated">The apply backend works by creating a sequence of patches (by calling &lt;code&gt;format-patch&lt;/code&gt; internally), and then applying the patches in sequence (calling &lt;code&gt;am&lt;/code&gt; internally). Patches are composed of multiple hunks, each with line numbers, a context region, and the actual changes. The line numbers have to be taken with some fuzz, since the other side will likely have inserted or deleted lines earlier in the file. The context region is meant to help find how to adjust the line numbers in order to apply the changes to the right lines. However, if multiple areas of the code have the same surrounding lines of context, the wrong one can be picked. There are real-world cases where this has caused commits to be reapplied incorrectly with no conflicts reported. Setting diff.context to a larger value may prevent such types of problems, but increases the chance of spurious conflicts (since it will require more lines of matching context to apply).</target>
        </trans-unit>
        <trans-unit id="013053835d145f0cc494db8211a188c9999bae09" translate="yes" xml:space="preserve">
          <source>The area where a pair of conflicting changes happened is marked with markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;=======&lt;/code&gt;, and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. The part before the &lt;code&gt;=======&lt;/code&gt; is typically your side, and the part afterwards is typically their side.</source>
          <target state="translated">충돌하는 한 쌍의 변경이 발생한 영역에는 마커 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;=======&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 가 표시됩니다 . &lt;code&gt;=======&lt;/code&gt; 앞의 부분 은 일반적으로 당신 편이고 , 그 이후의 부분은 일반적으로 그들의 편입니다.</target>
        </trans-unit>
        <trans-unit id="bbce7a566319a0fa5122538fad84df16b94a33f3" translate="yes" xml:space="preserve">
          <source>The argument to this option may be a glob on ref names, a ref, or the (possibly abbreviated) SHA-1 of a commit. Specifying a glob is equivalent to specifying this option multiple times, one for each matching ref name.</source>
          <target state="translated">이 옵션에 대한 논거는 심판 이름, 심판, 또는 커밋의 (약어) SHA-1에 대한 glob 일 수 있습니다. glob를 지정하는 것은 일치하는 각 ref 이름마다 하나씩이 옵션을 여러 번 지정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6083c463b2a8fa637d23cd99c59e9746cb6a7539" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;diff&lt;/code&gt; affects how Git generates diffs for particular files. It can tell Git whether to generate a textual patch for the path or to treat the path as a binary file. It can also affect what line is shown on the hunk header &lt;code&gt;@@ -k,l +n,m @@&lt;/code&gt; line, tell Git to use an external command to generate the diff, or ask Git to convert binary files to a text format before generating the diff.</source>
          <target state="translated">&lt;code&gt;diff&lt;/code&gt; 속성 은 Git이 특정 파일에 대해 diff를 생성하는 방법에 영향을줍니다. 경로에 대한 텍스트 패치를 생성할지 또는 경로를 이진 파일로 취급할지 Git에 알릴 수 있습니다. 또한 행크 헤더 &lt;code&gt;@@ -k,l +n,m @@&lt;/code&gt; 행 에 표시되는 행에 영향을 줄 수 있으며 , Git에 외부 명령을 사용하여 diff를 생성하도록 지시하거나, Git에 바이너리 파일을 텍스트 형식으로 변환하도록 요청하십시오. diff를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e3fef41e3a691b83ea57e915fd492f173e96b0ec" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;merge&lt;/code&gt; affects how three versions of a file are merged when a file-level merge is necessary during &lt;code&gt;git merge&lt;/code&gt;, and other commands such as &lt;code&gt;git revert&lt;/code&gt; and &lt;code&gt;git cherry-pick&lt;/code&gt;.</source>
          <target state="translated">속성 &lt;code&gt;merge&lt;/code&gt; 은 &lt;code&gt;git merge&lt;/code&gt; 동안 파일 레벨 병합 과 &lt;code&gt;git revert&lt;/code&gt; 및 &lt;code&gt;git cherry-pick&lt;/code&gt; 과 같은 다른 명령 이 필요할 때 파일의 세 가지 버전이 병합되는 방식에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="2fe7b4a122d21c0258f6159b6aeead7d915c58b4" translate="yes" xml:space="preserve">
          <source>The attributes allow a fine-grained control, how the line endings are converted. Here is an example that will make Git normalize .txt, .vcproj and .sh files, ensure that .vcproj files have CRLF and .sh files have LF in the working directory, and prevent .jpg files from being normalized regardless of their content.</source>
          <target state="translated">이 속성을 사용하면 줄 끝이 변환되는 방식을 세밀하게 제어 할 수 있습니다. 다음은 Git을 .txt, .vcproj 및 .sh 파일을 정규화하고 .vcproj 파일에 CRLF가 있고 .sh 파일에 작업 디렉토리에 LF가 있는지 확인하고 내용에 관계없이 .jpg 파일이 정규화되는 것을 방지하는 예제입니다.</target>
        </trans-unit>
        <trans-unit id="d53ffa6d811b54f0c7bdf879ab5abd1f6c7675e8" translate="yes" xml:space="preserve">
          <source>The author and committer names are by convention some form of a personal name (that is, the name by which other humans refer to you), although Git does not enforce or require any particular form. Arbitrary Unicode may be used, subject to the constraints listed above. This name has no effect on authentication; for that, see the &lt;code&gt;credential.username&lt;/code&gt; variable in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">The author and committer names are by convention some form of a personal name (that is, the name by which other humans refer to you), although Git does not enforce or require any particular form. Arbitrary Unicode may be used, subject to the constraints listed above. This name has no effect on authentication; for that, see the &lt;code&gt;credential.username&lt;/code&gt; variable in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0849ab3d36b0ce6d3f6183dc21f6e83ad1520176" translate="yes" xml:space="preserve">
          <source>The author name and email address to use when no author information can be found in the patch description.</source>
          <target state="translated">패치 정보에서 저자 정보가 없을 때 사용할 저자 이름과 이메일 주소.</target>
        </trans-unit>
        <trans-unit id="b012a2641006f12bad01716515743698d7deabe2" translate="yes" xml:space="preserve">
          <source>The author of a piece of code.</source>
          <target state="translated">코드 조각의 저자.</target>
        </trans-unit>
        <trans-unit id="147440e8e5aa984c82659720dc655a2dca5add95" translate="yes" xml:space="preserve">
          <source>The backend process sets GIT_COMMITTER_NAME to &lt;code&gt;$REMOTE_USER&lt;/code&gt; and GIT_COMMITTER_EMAIL to &lt;code&gt;${REMOTE_USER}@http.${REMOTE_ADDR}&lt;/code&gt;, ensuring that any reflogs created by &lt;code&gt;git-receive-pack&lt;/code&gt; contain some identifying information of the remote user who performed the push.</source>
          <target state="translated">백엔드 프로세스는 GIT_COMMITTER_NAME을 &lt;code&gt;$REMOTE_USER&lt;/code&gt; , GIT_COMMITTER_EMAIL을 &lt;code&gt;${REMOTE_USER}@http.${REMOTE_ADDR}&lt;/code&gt; 으로 설정하여 &lt;code&gt;git-receive-pack&lt;/code&gt; 으로 작성된 모든 reflog 에 푸시를 수행 한 원격 사용자의 식별 정보가 포함되도록합니다.</target>
        </trans-unit>
        <trans-unit id="6488cea0d1ed89be90f43d74ec74b5b3ce12a473" translate="yes" xml:space="preserve">
          <source>The background maintenance schedule runs &lt;code&gt;git maintenance run&lt;/code&gt; processes on an hourly basis. Each run executes the &quot;hourly&quot; tasks. At midnight, that process also executes the &quot;daily&quot; tasks. At midnight on the first day of the week, that process also executes the &quot;weekly&quot; tasks. A single process iterates over each registered repository, performing the scheduled tasks for that frequency. Depending on the number of registered repositories and their sizes, this process may take longer than an hour. In this case, multiple &lt;code&gt;git maintenance run&lt;/code&gt; commands may run on the same repository at the same time, colliding on the object database lock. This results in one of the two tasks not running.</source>
          <target state="translated">백그라운드 유지 관리 일정은 &lt;code&gt;git maintenance run&lt;/code&gt; 프로세스를 매시간 실행 합니다. 각 실행은 &quot;시간별&quot;작업을 실행합니다. 자정에 해당 프로세스는 &quot;일일&quot;작업도 실행합니다. 주의 첫날 자정에 해당 프로세스는 &quot;주간&quot;작업도 실행합니다. 단일 프로세스가 등록 된 각 저장소를 반복하여 해당 빈도에 대해 예약 된 작업을 수행합니다. 등록 된 리포지토리 수와 크기에 따라이 프로세스는 1 시간 이상 걸릴 수 있습니다. 이 경우 여러 &lt;code&gt;git maintenance run&lt;/code&gt; 명령이 동일한 저장소에서 동시에 실행되어 개체 데이터베이스 잠금과 충돌 할 수 있습니다. 이로 인해 두 작업 중 하나가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21e5e59ef58a1f64125adda00de18248644f6705" translate="yes" xml:space="preserve">
          <source>The base object could also be deltified if it&amp;rsquo;s in the same pack. Ref-delta can also refer to an object outside the pack (i.e. the so-called &quot;thin pack&quot;). When stored on disk however, the pack should be self contained to avoid cyclic dependency.</source>
          <target state="translated">기본 팩이 동일한 팩에있는 경우 기본 객체를 제거 할 수도 있습니다. Ref-delta는 또한 팩 외부의 물체 (즉, &quot;얇은 팩&quot;)를 지칭 할 수도 있습니다. 그러나 디스크에 저장 될 때 팩은 주기적 종속성을 피하기 위해 자체 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1877d075d52f12eee201f2607da0c072a35f24bc" translate="yes" xml:space="preserve">
          <source>The base tree information block is used for maintainers or third party testers to know the exact state the patch series applies to. It consists of the &lt;code&gt;base commit&lt;/code&gt;, which is a well-known commit that is part of the stable part of the project history everybody else works off of, and zero or more &lt;code&gt;prerequisite patches&lt;/code&gt;, which are well-known patches in flight that is not yet part of the &lt;code&gt;base commit&lt;/code&gt; that need to be applied on top of &lt;code&gt;base commit&lt;/code&gt; in topological order before the patches can be applied.</source>
          <target state="translated">기본 트리 정보 블록은 유지 관리자 또는 타사 테스터가 패치 시리즈가 적용되는 정확한 상태를 알기 위해 사용됩니다. 그것은 구성 &lt;code&gt;base commit&lt;/code&gt; 잘 알려진 그 다른 프로젝트 역사 모두의 안정적인 부분의 일부의 오프 작동 커밋이다, 0 개 이상의 &lt;code&gt;prerequisite patches&lt;/code&gt; 아직없는 비행 패치를 잘 알려져있다, 패치를 적용하기 전에 &lt;code&gt;base commit&lt;/code&gt; 위에 토폴로지 순서 로 적용해야하는 &lt;code&gt;base commit&lt;/code&gt; 일부 .</target>
        </trans-unit>
        <trans-unit id="dc39b1b9637026dfb15dfa743421fbe1dc2277e7" translate="yes" xml:space="preserve">
          <source>The basic colors accepted are &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;black&lt;/code&gt;, &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;green&lt;/code&gt;, &lt;code&gt;yellow&lt;/code&gt;, &lt;code&gt;blue&lt;/code&gt;, &lt;code&gt;magenta&lt;/code&gt;, &lt;code&gt;cyan&lt;/code&gt; and &lt;code&gt;white&lt;/code&gt;. The first color given is the foreground; the second is the background.</source>
          <target state="translated">허용되는 기본 색상은 &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;black&lt;/code&gt; , &lt;code&gt;red&lt;/code&gt; , &lt;code&gt;green&lt;/code&gt; , &lt;code&gt;yellow&lt;/code&gt; , &lt;code&gt;blue&lt;/code&gt; , &lt;code&gt;magenta&lt;/code&gt; , &lt;code&gt;cyan&lt;/code&gt; 및 &lt;code&gt;white&lt;/code&gt; 입니다. 주어진 첫 번째 색상은 전경입니다. 두 번째는 배경입니다.</target>
        </trans-unit>
        <trans-unit id="7566284af8c415df7ee8fe07fa92e83ad558993b" translate="yes" xml:space="preserve">
          <source>The basic colors accepted are &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;black&lt;/code&gt;, &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;green&lt;/code&gt;, &lt;code&gt;yellow&lt;/code&gt;, &lt;code&gt;blue&lt;/code&gt;, &lt;code&gt;magenta&lt;/code&gt;, &lt;code&gt;cyan&lt;/code&gt; and &lt;code&gt;white&lt;/code&gt;. The first color given is the foreground; the second is the background. All the basic colors except &lt;code&gt;normal&lt;/code&gt; have a bright variant that can be specified by prefixing the color with &lt;code&gt;bright&lt;/code&gt;, like &lt;code&gt;brightred&lt;/code&gt;.</source>
          <target state="translated">허용되는 기본 색상은 &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;black&lt;/code&gt; , &lt;code&gt;red&lt;/code&gt; , &lt;code&gt;green&lt;/code&gt; , &lt;code&gt;yellow&lt;/code&gt; , &lt;code&gt;blue&lt;/code&gt; , &lt;code&gt;magenta&lt;/code&gt; , &lt;code&gt;cyan&lt;/code&gt; 및 &lt;code&gt;white&lt;/code&gt; 입니다. 주어진 첫 번째 색상은 전경입니다. 두 번째는 배경입니다. &lt;code&gt;normal&lt;/code&gt; 색상을 제외한 모든 기본 색상 에는 &lt;code&gt;brightred&lt;/code&gt; 와 같이 &lt;code&gt;bright&lt;/code&gt; 색상을 접두사로 지정하여 지정할 수있는 밝은 변형이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="440eb92d2667463744ad365910f079c5b0c24b8b" translate="yes" xml:space="preserve">
          <source>The basic colors accepted are &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;black&lt;/code&gt;, &lt;code&gt;red&lt;/code&gt;, &lt;code&gt;green&lt;/code&gt;, &lt;code&gt;yellow&lt;/code&gt;, &lt;code&gt;blue&lt;/code&gt;, &lt;code&gt;magenta&lt;/code&gt;, &lt;code&gt;cyan&lt;/code&gt; and &lt;code&gt;white&lt;/code&gt;. The first color given is the foreground; the second is the background. All the basic colors except &lt;code&gt;normal&lt;/code&gt; have a bright variant that can be speficied by prefixing the color with &lt;code&gt;bright&lt;/code&gt;, like &lt;code&gt;brightred&lt;/code&gt;.</source>
          <target state="translated">The basic colors accepted are &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;black&lt;/code&gt; , &lt;code&gt;red&lt;/code&gt; , &lt;code&gt;green&lt;/code&gt; , &lt;code&gt;yellow&lt;/code&gt; , &lt;code&gt;blue&lt;/code&gt; , &lt;code&gt;magenta&lt;/code&gt; , &lt;code&gt;cyan&lt;/code&gt; and &lt;code&gt;white&lt;/code&gt; . The first color given is the foreground; the second is the background. All the basic colors except &lt;code&gt;normal&lt;/code&gt; have a bright variant that can be speficied by prefixing the color with &lt;code&gt;bright&lt;/code&gt; , like &lt;code&gt;brightred&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4e1b119ab89bbecfc6f0f5d854268dcecbb088f" translate="yes" xml:space="preserve">
          <source>The basic form described in DESCRIPTION with a Git directory, a working directory, a &lt;code&gt;gitlink&lt;/code&gt;, and a &lt;code&gt;.gitmodules&lt;/code&gt; entry.</source>
          <target state="translated">Git 디렉토리, 작업 디렉토리, &lt;code&gt;gitlink&lt;/code&gt; 및 &lt;code&gt;.gitmodules&lt;/code&gt; 항목 과 함께 DESCRIPTION에 설명 된 기본 양식 .</target>
        </trans-unit>
        <trans-unit id="b21f7863c055f0aa6938a038ffa25acf7017fe84" translate="yes" xml:space="preserve">
          <source>The basic greedy diff algorithm. Currently, this is the default.</source>
          <target state="translated">욕심 많은 기본 알고리즘. 현재는 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="ebbd31d9dd00322abaa4bb83a8b03f787c70d43c" translate="yes" xml:space="preserve">
          <source>The basic requirements:</source>
          <target state="translated">기본 요구 사항 :</target>
        </trans-unit>
        <trans-unit id="675f96a5f033def81701bda4e874ec2fbad8a388" translate="yes" xml:space="preserve">
          <source>The below documentation is the same as what&amp;rsquo;s found in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;:</source>
          <target state="translated">아래 문서는 &lt;a href=&quot;git-config&quot;&gt;git-config [1]에&lt;/a&gt; 있는 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f55762f9996c39bda184001319965b733714f313" translate="yes" xml:space="preserve">
          <source>The best way to get one is by using the &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; command to download a copy of an existing repository. If you don&amp;rsquo;t already have a project in mind, here are some interesting examples:</source>
          <target state="translated">하나를 얻는 가장 좋은 방법은 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 명령을 사용하여 기존 리포지토리의 복사본을 다운로드하는 것입니다. 아직 프로젝트를 염두에 두지 않은 경우 몇 가지 흥미로운 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2b6c88cac94cf24687d4ba9657759c1ab28582a" translate="yes" xml:space="preserve">
          <source>The best way to see how this works is using the &lt;a href=&quot;gitk&quot;&gt;gitk[1]&lt;/a&gt; command; running gitk now on a Git repository and looking for merge commits will help understand how Git organizes history.</source>
          <target state="translated">이것이 어떻게 작동하는지 확인하는 가장 좋은 방법은 &lt;a href=&quot;gitk&quot;&gt;gitk [1]&lt;/a&gt; 명령을 사용하는 것입니다. Git 저장소에서 gitk를 실행하고 병합 커밋을 찾으면 Git이 히스토리를 구성하는 방법을 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="8130ad227eb2e1ffe8f116dc4280c5919bb4cd97" translate="yes" xml:space="preserve">
          <source>The branch &lt;code&gt;test&lt;/code&gt; is short for &lt;code&gt;refs/heads/test&lt;/code&gt;.</source>
          <target state="translated">분기 &lt;code&gt;test&lt;/code&gt; 는 &lt;code&gt;refs/heads/test&lt;/code&gt; 약자입니다 .</target>
        </trans-unit>
        <trans-unit id="420b2dd61e4562065a5bd273fcdbaecde70d1742" translate="yes" xml:space="preserve">
          <source>The branch LRU builtin to fast-import tends to behave very well, and the cost of activating an inactive branch is so low that bouncing around between branches has virtually no impact on import performance.</source>
          <target state="translated">빠른 가져 오기에 내장 된 지점 LRU는 매우 잘 작동하는 경향이 있으며, 비활성 지점 활성화 비용이 너무 낮아서 지점 간 반송이 가져 오기 성능에 사실상 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58be5b6cbe7d7c0a923608fe1415c68702e2aa84" translate="yes" xml:space="preserve">
          <source>The chain of operation</source>
          <target state="translated">운영 체인</target>
        </trans-unit>
        <trans-unit id="cb0b83bdafd60672fc0fb681d6c09ff33adfb7dc" translate="yes" xml:space="preserve">
          <source>The changes are still visible in the submodule&amp;rsquo;s reflog.</source>
          <target state="translated">변경 사항은 여전히 ​​서브 모듈의 reflog에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e18a17400a7fdeb34351715eb209f43bb56b69d6" translate="yes" xml:space="preserve">
          <source>The clone command creates a new directory named after the project (&lt;code&gt;git&lt;/code&gt; or &lt;code&gt;linux&lt;/code&gt; in the examples above). After you cd into this directory, you will see that it contains a copy of the project files, called the &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt;, together with a special top-level directory named &lt;code&gt;.git&lt;/code&gt;, which contains all the information about the history of the project.</source>
          <target state="translated">clone 명령은 프로젝트의 이름을 딴 새 디렉토리를 만듭니다 ( 위 예에서는 &lt;code&gt;git&lt;/code&gt; 또는 &lt;code&gt;linux&lt;/code&gt; ). 이 디렉토리로 들어가면 &lt;a href=&quot;#def_working_tree&quot;&gt;작업 트리&lt;/a&gt; 라는 프로젝트 파일의 사본과 &lt;code&gt;.git&lt;/code&gt; 이라는 특수 최상위 디렉토리 와 프로젝트 히스토리에 대한 모든 정보가 들어있는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b1ff6b6614bf65ff7cf18fa7ac8ca0c73c31da4" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;git commit -a&lt;/code&gt; first looks at your working tree, notices that you have modified hello.c and removed goodbye.c, and performs necessary &lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git rm&lt;/code&gt; for you.</source>
          <target state="translated">&lt;code&gt;git commit -a&lt;/code&gt; 명령 은 먼저 작업 트리를보고 hello.c를 수정하고 goodbye.c를 제거한 것을 확인하고 필요한 &lt;code&gt;git add&lt;/code&gt; 및 &lt;code&gt;git rm&lt;/code&gt; 을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="95cb34ce247ae47a8a7d5a122ee875bb99decb40" translate="yes" xml:space="preserve">
          <source>The command allows for creation and fast-forwarding of sha1 refs (heads/tags) on the remote end (strictly speaking, it is the local end &lt;code&gt;git-receive-pack&lt;/code&gt; runs, but to the user who is sitting at the send-pack end, it is updating the remote. Confused?)</source>
          <target state="translated">이 명령을 사용하면 원격 엔드에서 sha1 참조 (헤드 / 태그)를 작성하고 빨리 전달할 수 있습니다 (엄격히 말해서 로컬 엔드 &lt;code&gt;git-receive-pack&lt;/code&gt; 실행이지만 send-pack 엔드에 앉아있는 사용자에게는 리모컨 업데이트 중입니다. 혼란 스럽습니까?)</target>
        </trans-unit>
        <trans-unit id="2b42e9d45bef456324952e5870d272017a1a991c" translate="yes" xml:space="preserve">
          <source>The command also looks at &lt;code&gt;core.trustctime&lt;/code&gt; configuration variable. It can be useful when the inode change time is regularly modified by something outside Git (file system crawlers and backup systems use ctime for marking files processed) (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">이 명령은 &lt;code&gt;core.trustctime&lt;/code&gt; 구성 변수도 확인합니다. inode 변경 시간이 Git 외부의 파일에 의해 정기적으로 수정 될 때 유용합니다 (파일 시스템 크롤러 및 백업 시스템은 ctime을 사용하여 처리 된 파일을 표시 함) ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b2d2a0a5d3ee3b745ff8e27d667799782d3fee27" translate="yes" xml:space="preserve">
          <source>The command by default does not allow an update that is not a fast-forward to prevent such loss of history.</source>
          <target state="translated">기본적으로이 명령은 이러한 기록 손실을 방지하기 위해 빨리 감기가 아닌 업데이트를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57bd298a9fbda93bedda739fa9a93ffd1fbe53dd" translate="yes" xml:space="preserve">
          <source>The command by default packs all tags and refs that are already packed, and leaves other refs alone. This is because branches are expected to be actively developed and packing their tips does not help performance. This option causes branch tips to be packed as well. Useful for a repository with many branches of historical interests.</source>
          <target state="translated">기본적으로이 명령은 이미 압축 된 모든 태그와 참조를 압축하고 다른 참조는 그대로 둡니다. 이는 브랜치가 적극적으로 개발되고 팁을 포장하는 것이 성능에 도움이되지 않기 때문입니다. 이 옵션을 사용하면 분기 팁도 포장됩니다. 많은 역사적 관심 분야가있는 저장소에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="affc62639786f9435bc3e40b781bdaefab9bf88f" translate="yes" xml:space="preserve">
          <source>The command can also be used to restore the content in the index with &lt;code&gt;--staged&lt;/code&gt;, or restore both the working tree and the index with &lt;code&gt;--staged --worktree&lt;/code&gt;.</source>
          <target state="translated">또한이 명령으로 인덱스의 내용을 복원 할 수 있습니다 &lt;code&gt;--staged&lt;/code&gt; , 또는 작업 트리와 인덱스를 모두 복원 &lt;code&gt;--staged --worktree&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="033264e01f6eaf7651e64aee25dc83cea3397f0e" translate="yes" xml:space="preserve">
          <source>The command finds the most recent tag that is reachable from a commit. If the tag points to the commit, then only the tag is shown. Otherwise, it suffixes the tag name with the number of additional commits on top of the tagged object and the abbreviated object name of the most recent commit. The result is a &quot;human-readable&quot; object name which can also be used to identify the commit to other git commands.</source>
          <target state="translated">이 명령은 커밋에서 도달 할 수있는 가장 최근 태그를 찾습니다. 태그가 커밋을 가리키는 경우 태그 만 표시됩니다. 그렇지 않으면 태그 된 객체 위에 추가 커밋 수와 가장 최근의 커밋의 약식 객체 이름으로 태그 이름에 접미사를 붙입니다. 결과는 다른 사람 명령에 대한 커밋을 식별하는 데 사용될 수있는 &quot;사람이 읽을 수있는&quot;객체 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3ab56fbe7068ffbc29e1e09d644dcd93a3d4ced5" translate="yes" xml:space="preserve">
          <source>The command honors &lt;code&gt;color.status&lt;/code&gt; (or &lt;code&gt;status.color&lt;/code&gt; &amp;mdash; they mean the same thing and the latter is kept for backward compatibility) and &lt;code&gt;color.status.&amp;lt;slot&amp;gt;&lt;/code&gt; configuration variables to colorize its output.</source>
          <target state="translated">이 명령은 &lt;code&gt;color.status&lt;/code&gt; (또는 &lt;code&gt;status.color&lt;/code&gt; - 동일한 것을 의미하며 후자는 이전 버전과의 호환성을 위해 유지됨) 및 &lt;code&gt;color.status.&amp;lt;slot&amp;gt;&lt;/code&gt; 구성 변수를 사용하여 출력을 채색합니다.</target>
        </trans-unit>
        <trans-unit id="426f574eb4223ad0c1806f2471b371a9ce2ce62b" translate="yes" xml:space="preserve">
          <source>The command honors &lt;code&gt;core.filemode&lt;/code&gt; configuration variable. If your repository is on a filesystem whose executable bits are unreliable, this should be set to &lt;code&gt;false&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). This causes the command to ignore differences in file modes recorded in the index and the file mode on the filesystem if they differ only on executable bit. On such an unfortunate filesystem, you may need to use &lt;code&gt;git update-index --chmod=&lt;/code&gt;.</source>
          <target state="translated">이 명령은 &lt;code&gt;core.filemode&lt;/code&gt; 구성 변수를 사용합니다. 저장소가 실행 가능 비트가 신뢰할 수없는 파일 시스템에있는 경우 이는 &lt;code&gt;false&lt;/code&gt; 로 설정해야합니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). 이로 인해 명령 비트가 실행 가능 비트에서만 다른 경우 색인에 기록 된 파일 모드와 파일 시스템의 파일 모드의 차이점을 무시합니다. 이러한 불행한 파일 시스템에서는 &lt;code&gt;git update-index --chmod=&lt;/code&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1c1fbeab69cdf1a35e381ef7eff39e0ef873ae8e" translate="yes" xml:space="preserve">
          <source>The command is kept primarily for historical reasons; fingers of many people who learned Git long before &lt;code&gt;git log&lt;/code&gt; was invented by reading Linux kernel mailing list are trained to type it.</source>
          <target state="translated">명령은 주로 역사적 이유로 유지됩니다. 리눅스 커널 메일 링리스트를 읽어서 &lt;code&gt;git log&lt;/code&gt; 가 발명 되기 오래 전에 Git을 배운 많은 사람들의 손가락이 그것을 입력하도록 훈련 받았다.</target>
        </trans-unit>
        <trans-unit id="078766939aed50311c1dcee68ff982a08734592e" translate="yes" xml:space="preserve">
          <source>The command line for those commands that support taking submodules as part of their pathspecs. Most commands have a boolean flag &lt;code&gt;--recurse-submodules&lt;/code&gt; which specify whether to recurse into submodules. Examples are &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;checkout&lt;/code&gt;. Some commands take enums, such as &lt;code&gt;fetch&lt;/code&gt; and &lt;code&gt;push&lt;/code&gt;, where you can specify how submodules are affected.</source>
          <target state="translated">서브 모듈을 경로 스펙의 일부로 가져 오는 것을 지원하는 명령의 명령 행. 대부분의 명령에는 부울 플래그 &lt;code&gt;--recurse-submodules&lt;/code&gt; 가 있으며,이 플래그 는 하위 모듈로의 재귀 여부를 지정합니다. 예는 &lt;code&gt;grep&lt;/code&gt; 및 &lt;code&gt;checkout&lt;/code&gt; 입니다. &lt;code&gt;fetch&lt;/code&gt; 및 &lt;code&gt;push&lt;/code&gt; 와 같은 일부 명령은 하위 모듈의 영향을 지정할 수있는 열거 형 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0c67f633874ba0fbe1af2a193c1c589167c2ab4d" translate="yes" xml:space="preserve">
          <source>The command looks at &lt;code&gt;core.ignorestat&lt;/code&gt; configuration variable. See &lt;code&gt;Using &quot;assume unchanged&quot; bit&lt;/code&gt; section above.</source>
          <target state="translated">이 명령은 &lt;code&gt;core.ignorestat&lt;/code&gt; 구성 변수를 확인합니다. 위의 &lt;code&gt;Using &quot;assume unchanged&quot; bit&lt;/code&gt; 섹션 사용을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f7f0d79e587cabe73eebce8a6424fb5cae3c144" translate="yes" xml:space="preserve">
          <source>The command looks at &lt;code&gt;core.ignorestat&lt;/code&gt; configuration variable. When this is true, paths updated with &lt;code&gt;git update-index paths...&lt;/code&gt; and paths updated with other Git commands that update both index and working tree (e.g. &lt;code&gt;git apply --index&lt;/code&gt;, &lt;code&gt;git checkout-index -u&lt;/code&gt;, and &lt;code&gt;git read-tree -u&lt;/code&gt;) are automatically marked as &quot;assume unchanged&quot;. Note that &quot;assume unchanged&quot; bit is &lt;strong&gt;not&lt;/strong&gt; set if &lt;code&gt;git update-index --refresh&lt;/code&gt; finds the working tree file matches the index (use &lt;code&gt;git update-index --really-refresh&lt;/code&gt; if you want to mark them as &quot;assume unchanged&quot;).</source>
          <target state="translated">이 명령은 &lt;code&gt;core.ignorestat&lt;/code&gt; 구성 변수를 확인합니다. 이것이 사실이면, &lt;code&gt;git update-index paths...&lt;/code&gt; 업데이트 된 경로와 인덱스와 작업 트리를 모두 업데이트하는 다른 Git 명령으로 업데이트 된 경로 (예 : &lt;code&gt;git apply --index&lt;/code&gt; , &lt;code&gt;git checkout-index -u&lt;/code&gt; 및 &lt;code&gt;git read-tree -u&lt;/code&gt; )는 &quot;변경되지 않은 것으로 가정&quot;으로 자동 표시됩니다. 비트가 &quot;변하지 가정&quot;주의 &lt;strong&gt;하지&lt;/strong&gt; 경우 설정 &lt;code&gt;git update-index --refresh&lt;/code&gt; (사용 작업 트리 파일을 발견 인덱스 일치 &lt;code&gt;git update-index --really-refresh&lt;/code&gt; 하면 &quot;변하지 가정&quot;로 표시 할 경우).</target>
        </trans-unit>
        <trans-unit id="719021beca97cba355f40567331ed4531fab91cd" translate="yes" xml:space="preserve">
          <source>The command loop shows the list of subcommands available, and gives a prompt &quot;What now&amp;gt; &quot;. In general, when the prompt ends with a single &lt;code&gt;&amp;gt;&lt;/code&gt;, you can pick only one of the choices given and type return, like this:</source>
          <target state="translated">명령 루프는 사용 가능한 하위 명령 목록을 표시하고 &quot;지금 무엇&amp;gt;&quot;프롬프트를 표시합니다. 일반적으로 프롬프트가 단일 &lt;code&gt;&amp;gt;&lt;/code&gt; 로 끝나는 경우 다음과 같이 주어진 선택 중 하나만 선택하고 return을 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="653e31d7d7203bdc451cd54eed957012f41434d3" translate="yes" xml:space="preserve">
          <source>The command refuses to process new mailboxes until the current operation is finished, so if you decide to start over from scratch, run &lt;code&gt;git am --abort&lt;/code&gt; before running the command with mailbox names.</source>
          <target state="translated">명령은 현재 작업이 완료 될 때까지 새 메일 함을 처리하지 않으므로 처음부터 다시 시작하기로 결정한 경우, 메일 함 이름으로 명령을 실행하기 전에 &lt;code&gt;git am --abort&lt;/code&gt; 를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="024617064e80c5362385868f7a76ff908e5b8451" translate="yes" xml:space="preserve">
          <source>The command removes only the paths that are known to Git.</source>
          <target state="translated">The command removes only the paths that are known to Git.</target>
        </trans-unit>
        <trans-unit id="ddc41d8aed51eb71b1c7af7000815eb2a4b359d3" translate="yes" xml:space="preserve">
          <source>The command stream is terminated by a blank line. In some cases (indicated in the documentation of the relevant commands), this blank line is followed by a payload in some other protocol (e.g., the pack protocol), while in others it indicates the end of input.</source>
          <target state="translated">명령 스트림은 빈 줄로 종료됩니다. 경우에 따라 (관련 명령의 문서에 표시됨)이 빈 줄 뒤에 다른 프로토콜 (예 : 팩 프로토콜)의 페이로드가 오는 반면, 다른 경우에는 입력 끝을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9f45aa4005fcc34aa135332c57403a61747c3270" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; command to control what is shown and how, and options applicable to the &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; command to control how the changes each commit introduces are shown.</source>
          <target state="translated">The command takes options applicable to the &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; command to control what is shown and how, and options applicable to the &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; command to control how the changes each commit introduces are shown.</target>
        </trans-unit>
        <trans-unit id="d1cdce0d3b2e7df2146074a7208b9f02c1bab1a7" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;code&gt;git diff-tree&lt;/code&gt; command to control how the changes the commit introduces are shown.</source>
          <target state="translated">이 명령은 &lt;code&gt;git diff-tree&lt;/code&gt; 명령에 적용 가능한 옵션을 사용 하여 커밋이 도입 한 변경 사항이 표시되는 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="35fc48f2de1638c3a16917e24656f5cccec37735" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;code&gt;git log&lt;/code&gt; command to control what is shown and how. See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;.</source>
          <target state="translated">이 명령은 &lt;code&gt;git log&lt;/code&gt; 명령에 적용 가능한 옵션을 사용하여 표시되는 내용과 방법을 제어합니다. &lt;a href=&quot;git-log&quot;&gt;git-log [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="704cfc598be528aca39957bda30b48a4e32947ac" translate="yes" xml:space="preserve">
          <source>The command takes options applicable to the &lt;code&gt;git rev-list&lt;/code&gt; command to control what is shown and how, and options applicable to the &lt;code&gt;git diff-*&lt;/code&gt; commands to control how the changes each commit introduces are shown.</source>
          <target state="translated">이 명령은 &lt;code&gt;git rev-list&lt;/code&gt; 명령에 적용 가능한 옵션을 사용하여 표시되는 내용과 방법 을 제어 하고 &lt;code&gt;git diff-*&lt;/code&gt; 명령에 적용 가능한 옵션을 사용하여 각 커밋의 변경 내용이 표시되는 방식을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="05dd6533643357a7eb4c0a33aa8aafdf86be046c" translate="yes" xml:space="preserve">
          <source>The command takes various subcommands, and different options depending on the subcommand:</source>
          <target state="translated">이 명령은 다양한 하위 명령과 하위 명령에 따라 다른 옵션을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5dfb0879d1b00c6726b4c473489aecee6c7360c1" translate="yes" xml:space="preserve">
          <source>The command that the diff driver should call to generate the text-converted version of a file. The result of the conversion is used to generate a human-readable diff. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">diff 드라이버가 텍스트 변환 버전의 파일을 생성하기 위해 호출해야하는 명령입니다. 변환 결과는 사람이 읽을 수있는 diff를 생성하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="76561fd073c2b7875043b506e4a6c918bbf27fef" translate="yes" xml:space="preserve">
          <source>The command usually removes loose refs under &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; hierarchy after packing them. This option tells it not to.</source>
          <target state="translated">이 명령은 보통 &lt;code&gt;$GIT_DIR/refs&lt;/code&gt; 계층 구조 에서 느슨한 참조를 압축 한 후 제거 합니다. 이 옵션은하지 말라고 지시합니다.</target>
        </trans-unit>
        <trans-unit id="77170493947dd63f2044149c05ae4eb27dc0d118" translate="yes" xml:space="preserve">
          <source>The command usually shows percentage progress. This flag suppresses it.</source>
          <target state="translated">이 명령은 일반적으로 백분율 진행률을 보여줍니다. 이 플래그는 억제합니다.</target>
        </trans-unit>
        <trans-unit id="3df5350b5d92a4c7df677ed19aeefaf4fd05338a" translate="yes" xml:space="preserve">
          <source>The command which is used to convert the content of a blob object to a worktree file upon checkout. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">체크 아웃시 Blob 오브젝트의 컨텐츠를 작업 트리 파일로 변환하는 데 사용되는 명령입니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e78c7e2042e4de22f48dc29ab38867e1c8242106" translate="yes" xml:space="preserve">
          <source>The command which is used to convert the content of a worktree file to a blob upon checkin. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">체크인시 작업 트리 파일의 컨텐츠를 Blob으로 변환하는 데 사용되는 명령입니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a6711f072ffccd6a7948d8fcfc289d0284bd97d1" translate="yes" xml:space="preserve">
          <source>The command will only rewrite the &lt;code&gt;positive&lt;/code&gt; refs mentioned in the command line (e.g. if you pass &lt;code&gt;a..b&lt;/code&gt;, only &lt;code&gt;b&lt;/code&gt; will be rewritten). If you specify no filters, the commits will be recommitted without any changes, which would normally have no effect. Nevertheless, this may be useful in the future for compensating for some Git bugs or such, therefore such a usage is permitted.</source>
          <target state="translated">명령은 명령 행에 언급 된 &lt;code&gt;positive&lt;/code&gt; 만 다시 작성합니다 (예 : &lt;code&gt;a..b&lt;/code&gt; 를 전달하면 &lt;code&gt;b&lt;/code&gt; 만 다시 작성 됨). 필터를 지정하지 않으면 변경 사항없이 커밋이 다시 커밋되며 일반적으로 적용되지 않습니다. 그럼에도 불구하고, 이것은 미래에 일부 Git 버그 등을 보상하는 데 유용 할 수 있으므로 이러한 사용이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="6c1d44a42d537aa236fa8b0c18f8ebc1e0d665b8" translate="yes" xml:space="preserve">
          <source>The command writes the commit object name of the common ancestor to the standard output, so we captured its output to a variable, because we will be using it in the next step. By the way, the common ancestor commit is the &quot;Initial commit&quot; commit in this case. You can tell it by:</source>
          <target state="translated">이 명령은 공통 조상의 커밋 객체 이름을 표준 출력에 기록하므로 다음 단계에서 사용할 것이므로 출력을 변수로 캡처했습니다. 그런데이 경우 공통 조상 커밋은 &quot;초기 커밋&quot;커밋입니다. 당신은 그것을 말할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="277f50b8984fb8f1e24e58a015e232c719b0136b" translate="yes" xml:space="preserve">
          <source>The command&amp;rsquo;s second form creates a new branch head named &amp;lt;branchname&amp;gt; which points to the current &lt;code&gt;HEAD&lt;/code&gt;, or &amp;lt;start-point&amp;gt; if given. As a special case, for &amp;lt;start-point&amp;gt;, you may use &lt;code&gt;&quot;A...B&quot;&lt;/code&gt; as a shortcut for the merge base of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; if there is exactly one merge base. You can leave out at most one of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, in which case it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">이 명령의 두 번째 형식은 현재 &lt;code&gt;HEAD&lt;/code&gt; 를 가리키는 &amp;lt;branchname&amp;gt;이라는 새 분기 헤드를 작성 하거나 지정된 경우 &amp;lt;start-point&amp;gt;를 작성합니다. 특별한 경우로 &amp;lt;start-point&amp;gt;의 경우 정확히 하나의 병합 기준이있는 경우 &lt;code&gt;&quot;A...B&quot;&lt;/code&gt; 를 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 병합 기준에 대한 바로 가기로 사용할 수 있습니다 . &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 중 하나만 남겨 둘 수 있으며 ,이 경우 기본값은 &lt;code&gt;HEAD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0384db43c537c0cba33bbce02fa39c058435bd6c" translate="yes" xml:space="preserve">
          <source>The command-line flag --exclude-from=&amp;lt;file&amp;gt; specifies a file containing a list of patterns. Patterns are ordered in the same order they appear in the file.</source>
          <target state="translated">명령 줄 플래그 --exclude-from = &amp;lt;file&amp;gt;은 패턴 목록이 포함 된 파일을 지정합니다. 패턴은 파일에 나타나는 것과 같은 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="84de3c7a7b3ba54b91bb57a464ea60b526231897" translate="yes" xml:space="preserve">
          <source>The command-line flag --exclude-per-directory=&amp;lt;name&amp;gt; specifies a name of the file in each directory &lt;code&gt;git ls-files&lt;/code&gt; examines, normally &lt;code&gt;.gitignore&lt;/code&gt;. Files in deeper directories take precedence. Patterns are ordered in the same order they appear in the files.</source>
          <target state="translated">명령 행 플래그 --exclude-per-directory = &amp;lt;name&amp;gt;은 &lt;code&gt;git ls-files&lt;/code&gt; 가 검사하는 각 디렉토리의 파일 이름을 지정 합니다 (일반적으로 &lt;code&gt;.gitignore&lt;/code&gt; ) . 더 깊은 디렉토리의 파일이 우선합니다. 패턴은 파일에 나타나는 것과 같은 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="de25d36c95ea6a374c3001c57d5c8bbae6052f57" translate="yes" xml:space="preserve">
          <source>The command-line flag --exclude=&amp;lt;pattern&amp;gt; specifies a single pattern. Patterns are ordered in the same order they appear in the command line.</source>
          <target state="translated">명령 줄 플래그 --exclude = &amp;lt;pattern&amp;gt;은 단일 패턴을 지정합니다. 패턴은 명령 행에 나타나는 것과 동일한 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="57163e2560363b464673a4a43dc95a7ad9f9ef3b" translate="yes" xml:space="preserve">
          <source>The commit &quot;D&quot; is called a &quot;merge base&quot; for branch &quot;main&quot; and &quot;dev&quot; because it&amp;rsquo;s the best common ancestor for these branches for a merge.</source>
          <target state="translated">커밋 &quot;D&quot;는 &quot;main&quot;및 &quot;dev&quot;브랜치의 &quot;병합베이스&quot;라고하며,이 브랜치의 병합에 대한 가장 일반적인 조상이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f185c14cbc82f3e4dae044b7f66a7608424887fa" translate="yes" xml:space="preserve">
          <source>The commit author name is taken from the &quot;From: &quot; line of the message, and commit author date is taken from the &quot;Date: &quot; line of the message. The &quot;Subject: &quot; line is used as the title of the commit, after stripping common prefix &quot;[PATCH &amp;lt;anything&amp;gt;]&quot;. The &quot;Subject: &quot; line is supposed to concisely describe what the commit is about in one line of text.</source>
          <target state="translated">커밋 작성자 이름은 메시지의 &quot;보낸 사람 :&quot;줄에서 가져오고 커밋 작성자 날짜는 메시지의 &quot;날짜 :&quot;줄에서 가져옵니다. &quot;Subject :&quot;행은 공통 접두사 &quot;[PATCH &amp;lt;anything&amp;gt;]&quot;을 제거한 후 커밋 제목으로 사용됩니다. &quot;제목 :&quot;줄은 한 줄의 텍스트에서 커밋에 대해 간결하게 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f12acdb07fb960bc2fd1e07b27cc4a2b35ad054" translate="yes" xml:space="preserve">
          <source>The commit list format can be changed by setting the configuration option rebase.instructionFormat. A customized instruction format will automatically have the long commit hash prepended to the format.</source>
          <target state="translated">구성 옵션 rebase.instructionFormat을 설정하여 커밋 목록 형식을 변경할 수 있습니다. 사용자 정의 된 명령 형식은 긴 커밋 해시가 형식 앞에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="56b4186deed0365516ca63a760921d1d85d5abd6" translate="yes" xml:space="preserve">
          <source>The commit log message extracted from e-mail, usually except the title line which comes from e-mail Subject.</source>
          <target state="translated">전자 메일에서 추출 된 커밋 로그 메시지 (일반적으로 전자 메일 제목에서 나오는 제목 줄 제외).</target>
        </trans-unit>
        <trans-unit id="448543278984728d32d400e55fc12701ecc9668d" translate="yes" xml:space="preserve">
          <source>The commit log message, author name and author email are taken from the e-mail, and after minimally decoding MIME transfer encoding, re-coded in the charset specified by i18n.commitencoding (defaulting to UTF-8) by transliterating them. This used to be optional but now it is the default.</source>
          <target state="translated">커밋 로그 메시지, 작성자 이름 및 저자 이메일은 전자 메일에서 가져오고 MIME 전송 인코딩을 최소한으로 디코딩 한 후 음역을 통해 i18n.commitencoding (기본값 UTF-8)으로 지정된 문자 세트로 다시 코딩됩니다. 이것은 선택 사항 이었지만 이제는 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="682ec5a16062666d3ac4c15995f4c320f0569ce3" translate="yes" xml:space="preserve">
          <source>The commit message is formed by the title taken from the &quot;Subject: &quot;, a blank line and the body of the message up to where the patch begins. Excess whitespace at the end of each line is automatically stripped.</source>
          <target state="translated">커밋 메시지는 &quot;Subject :&quot;에서 가져온 제목, 빈 줄 및 패치가 시작되는 위치까지 메시지 본문으로 구성됩니다. 각 줄 끝의 초과 공백은 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="9d14a63335261988fcede52b815289c8a87983a5" translate="yes" xml:space="preserve">
          <source>The commit message is supplied either directly with the &lt;code&gt;-m&lt;/code&gt; or &lt;code&gt;-F&lt;/code&gt; option, or indirectly from the tag or commit when the second tree-ish denotes such an object, or it is requested by invoking an editor (see &lt;code&gt;--edit&lt;/code&gt; option below).</source>
          <target state="translated">커밋 메시지는 &lt;code&gt;-m&lt;/code&gt; 또는 &lt;code&gt;-F&lt;/code&gt; 옵션 과 함께 직접 제공되거나 두 번째 tree-ish가 그러한 객체를 나타낼 때 커밋 또는 커밋에서 간접적으로 제공되거나 편집기를 호출하여 요청합니다 (아래 &lt;code&gt;--edit&lt;/code&gt; 옵션 참조). .</target>
        </trans-unit>
        <trans-unit id="50413d61f19e8e0d39eb4098c01c599c7c407f25" translate="yes" xml:space="preserve">
          <source>The commit object names shown above would be different for you, but they should match the HEAD commit object names of your repositories. You can check it by running &lt;code&gt;git ls-remote ../a&lt;/code&gt;.</source>
          <target state="translated">위에 표시된 커밋 개체 이름은 사용자마다 다르지만 리포지토리의 HEAD 커밋 개체 이름과 일치해야합니다. &lt;code&gt;git ls-remote ../a&lt;/code&gt; 를 실행하여 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b7bb35b4ae403135d95400938252724b91ca0d2" translate="yes" xml:space="preserve">
          <source>The commit objects record the encoding used for the log message in their encoding header; this option can be used to tell the command to re-code the commit log message in the encoding preferred by the user. For non plumbing commands this defaults to UTF-8. Note that if an object claims to be encoded in &lt;code&gt;X&lt;/code&gt; and we are outputting in &lt;code&gt;X&lt;/code&gt;, we will output the object verbatim; this means that invalid sequences in the original commit may be copied to the output.</source>
          <target state="translated">커밋 개체는 로그 메시지에 사용 된 인코딩을 인코딩 헤더에 기록합니다. 이 옵션을 사용하면 커밋 로그 메시지를 사용자가 선호하는 인코딩으로 다시 코딩하도록 명령에 지시 할 수 있습니다. 배관이 아닌 명령의 경우 기본값은 UTF-8입니다. 참고 오브젝트 청구항에서 부호화되는 경우, &lt;code&gt;X&lt;/code&gt; 및 우리가 출력되는 &lt;code&gt;X&lt;/code&gt; 우리가 그대로 출력 객체 것이다; 이는 원래 커밋의 잘못된 시퀀스가 ​​출력으로 복사 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8a40378090f508382eab3e21e0b4382b3bab0ad4" translate="yes" xml:space="preserve">
          <source>The commit, equivalent to what other systems call a &quot;changeset&quot; or &quot;version&quot;, represents a step in the project&amp;rsquo;s history, and each parent represents an immediately preceding step. Commits with more than one parent represent merges of independent lines of development.</source>
          <target state="translated">다른 시스템이 &quot;changeset&quot;또는 &quot;version&quot;이라고 부르는 것과 동일한 커밋은 프로젝트 히스토리의 단계를 나타내며 각 상위는 직전 단계를 나타냅니다. 둘 이상의 부모가있는 커밋은 독립적 인 개발 라인의 병합을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7d3d64efc4f4511458592fa6c8a58dcfb8579da7" translate="yes" xml:space="preserve">
          <source>The commits are guaranteed to be listed in the order that they were processed by rebase.</source>
          <target state="translated">커밋은 rebase에 의해 처리 된 순서대로 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="00a94582df69c83885533dbdc944c957c3a549e0" translate="yes" xml:space="preserve">
          <source>The commits marked with &lt;code&gt;*&lt;/code&gt; touch the same area in the same file; you need to resolve the conflicts when creating the commit marked with &lt;code&gt;+&lt;/code&gt;. Then you can test the result to make sure your work-in-progress still works with what is in the latest master.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 로 표시된 커밋 은 같은 파일에서 같은 영역을 터치합니다. &lt;code&gt;+&lt;/code&gt; 로 표시된 커밋을 만들 때 충돌을 해결해야합니다 . 그런 다음 결과를 테스트하여 진행중인 작업이 최신 마스터의 작업과 계속 작동하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3fd88845d0ae86224cb7a800b3122f1cf56cb03" translate="yes" xml:space="preserve">
          <source>The commits that were previously saved into the temporary area are then reapplied to the current branch, one by one, in order. Note that any commits in HEAD which introduce the same textual changes as a commit in HEAD..&amp;lt;upstream&amp;gt; are omitted (i.e., a patch already accepted upstream with a different commit message or timestamp will be skipped).</source>
          <target state="translated">이전에 임시 영역에 저장된 커밋은 순서대로 현재 분기에 하나씩 다시 적용됩니다. HEAD .. &amp;lt;upstream&amp;gt;에서 커밋과 동일한 텍스트 변경을 도입하는 HEAD에서 커밋은 생략됩니다 (즉, 다른 커밋 메시지 또는 타임 스탬프가있는 업스트림에서 이미 승인 된 패치는 생략 됨).</target>
        </trans-unit>
        <trans-unit id="18d247bf08e46b2d89a403ce14a86d7b99503646" translate="yes" xml:space="preserve">
          <source>The complete message in a commit and tag object is &lt;code&gt;contents&lt;/code&gt;. Its first line is &lt;code&gt;contents:subject&lt;/code&gt;, where subject is the concatenation of all lines of the commit message up to the first blank line. The next line is &lt;code&gt;contents:body&lt;/code&gt;, where body is all of the lines after the first blank line. The optional GPG signature is &lt;code&gt;contents:signature&lt;/code&gt;. The first &lt;code&gt;N&lt;/code&gt; lines of the message is obtained using &lt;code&gt;contents:lines=N&lt;/code&gt;. Additionally, the trailers as interpreted by &lt;a href=&quot;git-interpret-trailers&quot;&gt;git-interpret-trailers[1]&lt;/a&gt; are obtained as &lt;code&gt;trailers&lt;/code&gt; (or by using the historical alias &lt;code&gt;contents:trailers&lt;/code&gt;). Non-trailer lines from the trailer block can be omitted with &lt;code&gt;trailers:only&lt;/code&gt;. Whitespace-continuations can be removed from trailers so that each trailer appears on a line by itself with its full content with &lt;code&gt;trailers:unfold&lt;/code&gt;. Both can be used together as &lt;code&gt;trailers:unfold,only&lt;/code&gt;.</source>
          <target state="translated">커밋 및 태그 객체의 전체 메시지는 &lt;code&gt;contents&lt;/code&gt; 입니다. 첫 번째 행은 &lt;code&gt;contents:subject&lt;/code&gt; 입니다 . 여기서 subject는 커밋 메시지의 모든 행을 첫 번째 빈 행으로 연결합니다. 다음 줄은 &lt;code&gt;contents:body&lt;/code&gt; 입니다 . 여기서 body는 첫 번째 빈 줄 다음의 모든 줄입니다. 선택적인 GPG 서명은 &lt;code&gt;contents:signature&lt;/code&gt; 입니다. 메시지 의 첫 &lt;code&gt;N&lt;/code&gt; 줄은 &lt;code&gt;contents:lines=N&lt;/code&gt; 을 사용하여 얻습니다 . 또한, &lt;a href=&quot;git-interpret-trailers&quot;&gt;git-interpret-trailers [1]에&lt;/a&gt; 의해 해석 된 트레일러 는 &lt;code&gt;trailers&lt;/code&gt; (또는 역사적인 별명 &lt;code&gt;contents:trailers&lt;/code&gt; 을 사용하여 트레일러) 로 얻습니다 .). 트레일러 블록의 비 트레일러 라인은 &lt;code&gt;trailers:only&lt;/code&gt; 로 생략 할 수 있습니다 . 각 트레일러와의 전체 내용으로 한 줄에 단독으로 나타나도록 공백-연속성을 트레일러에서 제거 할 수 있습니다 &lt;code&gt;trailers:unfold&lt;/code&gt; . 둘 다 &lt;code&gt;trailers:unfold,only&lt;/code&gt; 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0cfefd9783776d68186cc88921bf5543257f8ee9" translate="yes" xml:space="preserve">
          <source>The complete series produces the same end result as your own (probably much messier!) development process did.</source>
          <target state="translated">전체 시리즈는 자신의 (아마도 더 지저분한) 개발 프로세스와 동일한 최종 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="94ed81b46eb91e159691e77d6f1f3c669ea0f93b" translate="yes" xml:space="preserve">
          <source>The condition starts with a keyword followed by a colon and some data whose format and meaning depends on the keyword. Supported keywords are:</source>
          <target state="translated">조건은 키워드로 시작하고 콜론과 형식 및 의미에 따라 일부 데이터가 키워드에 따라 달라집니다. 지원되는 키워드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b796e8b15faa41177d638a7b320c951a662a1b91" translate="yes" xml:space="preserve">
          <source>The config settings that start with &lt;code&gt;feature.&lt;/code&gt; modify the defaults of a group of other config settings. These groups are created by the Git developer community as recommended defaults and are subject to change. In particular, new config options may be added with different defaults.</source>
          <target state="translated">&lt;code&gt;feature.&lt;/code&gt; 시작하는 구성 설정입니다 . 다른 구성 설정 그룹의 기본값을 수정하십시오. 이 그룹은 Git 개발자 커뮤니티에서 권장되는 기본값으로 생성되며 변경 될 수 있습니다. 특히 새로운 구성 옵션이 다른 기본값으로 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fd18e355006d4a8cb0ab9547d6ae9db29a772ac" translate="yes" xml:space="preserve">
          <source>The config variable &lt;code&gt;ssh.variant&lt;/code&gt; can be set to override this detection. Valid values are &lt;code&gt;ssh&lt;/code&gt; (to use OpenSSH options), &lt;code&gt;plink&lt;/code&gt;, &lt;code&gt;putty&lt;/code&gt;, &lt;code&gt;tortoiseplink&lt;/code&gt;, &lt;code&gt;simple&lt;/code&gt; (no options except the host and remote command). The default auto-detection can be explicitly requested using the value &lt;code&gt;auto&lt;/code&gt;. Any other value is treated as &lt;code&gt;ssh&lt;/code&gt;. This setting can also be overridden via the environment variable &lt;code&gt;GIT_SSH_VARIANT&lt;/code&gt;.</source>
          <target state="translated">구성 변수 &lt;code&gt;ssh.variant&lt;/code&gt; 는이 탐지를 무시하도록 설정할 수 있습니다. 유효한 값은 &lt;code&gt;ssh&lt;/code&gt; (OpenSSH 옵션 사용), &lt;code&gt;plink&lt;/code&gt; , &lt;code&gt;putty&lt;/code&gt; , &lt;code&gt;tortoiseplink&lt;/code&gt; , &lt;code&gt;simple&lt;/code&gt; (호스트 및 원격 명령을 제외한 옵션은 없음)입니다. 기본 자동 감지 기능은 명시 적으로 값을 사용하여 요청 할 수 있습니다 &lt;code&gt;auto&lt;/code&gt; . 다른 값은 &lt;code&gt;ssh&lt;/code&gt; 로 취급됩니다 . 이 설정은 환경 변수 &lt;code&gt;GIT_SSH_VARIANT&lt;/code&gt; 를 통해 무시할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82dcb1f42fdd78b7a73229a297c6923dd8af63df" translate="yes" xml:space="preserve">
          <source>The configuration file &lt;code&gt;$GIT_DIR/config&lt;/code&gt; in the superproject. Git only recurses into active submodules (see &quot;ACTIVE SUBMODULES&quot; section below).</source>
          <target state="translated">수퍼 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 의 구성 파일 $ GIT_DIR / config . 힘내는 활성 하위 모듈로만 되풀이됩니다 (아래의 &quot;활성 하위 모듈&quot;섹션 참조).</target>
        </trans-unit>
        <trans-unit id="774734ca6d9570e50bffe1b21770dfa34405f67a" translate="yes" xml:space="preserve">
          <source>The configuration file is used to override the default settings that were built into gitweb at the time the &lt;code&gt;gitweb.cgi&lt;/code&gt; script was generated.</source>
          <target state="translated">구성 파일은 &lt;code&gt;gitweb.cgi&lt;/code&gt; 스크립트가 생성 될 때 gitweb에 내장 된 기본 설정을 재정의하는 데 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="b47107ae705aecdb184ade3561dff30a01436bf4" translate="yes" xml:space="preserve">
          <source>The configuration inside the submodule. This includes &lt;code&gt;$GIT_DIR/config&lt;/code&gt; in the submodule, but also settings in the tree such as a &lt;code&gt;.gitattributes&lt;/code&gt; or &lt;code&gt;.gitignore&lt;/code&gt; files that specify behavior of commands inside the submodule.</source>
          <target state="translated">서브 모듈 내부의 구성. 여기에는 서브 모듈에 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 가 포함 되지만 서브 모듈 내부의 명령 동작을 지정 하는 &lt;code&gt;.gitattributes&lt;/code&gt; 또는 &lt;code&gt;.gitignore&lt;/code&gt; 파일 과 같은 트리의 설정도 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f6d6d393008f1bcb3935ac97c688c0c97bcd837" translate="yes" xml:space="preserve">
          <source>The configuration of submodules</source>
          <target state="translated">서브 모듈의 구성</target>
        </trans-unit>
        <trans-unit id="386a88f6456b2a92a88834767dd0b8e7846f5609" translate="yes" xml:space="preserve">
          <source>The configuration variables &lt;code&gt;$projects_list_group_categories&lt;/code&gt; and &lt;code&gt;$project_list_default_category&lt;/code&gt; are described in &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;</source>
          <target state="translated">구성 변수 &lt;code&gt;$projects_list_group_categories&lt;/code&gt; 및 &lt;code&gt;$project_list_default_category&lt;/code&gt; 는 &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7bf08d06e6b6627f964eab6068d66314f0702240" translate="yes" xml:space="preserve">
          <source>The configuration variables are used by both the Git plumbing and the porcelains. The variables are divided into sections, wherein the fully qualified variable name of the variable itself is the last dot-separated segment and the section name is everything before the last dot. The variable names are case-insensitive, allow only alphanumeric characters and &lt;code&gt;-&lt;/code&gt;, and must start with an alphabetic character. Some variables may appear multiple times; we say then that the variable is multivalued.</source>
          <target state="translated">구성 변수는 Git 배관과 도자기 모두에서 사용됩니다. 변수는 섹션으로 나뉩니다. 여기서 변수 자체의 정규화 된 변수 이름은 마지막 점으로 구분 된 세그먼트이고 섹션 이름은 마지막 점 이전의 모든 것입니다. 변수 이름은 대소 문자를 구분하지 않으며 영숫자 및 &lt;code&gt;-&lt;/code&gt; 만 허용하며 알파벳 문자로 시작해야합니다. 일부 변수는 여러 번 나타날 수 있습니다. 그런 다음 변수가 다중 값이라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="9ba005fddfd40c1aca4a3afcc24f0bfe0be0d141" translate="yes" xml:space="preserve">
          <source>The configuration variables described below configure some of gitweb links: their target and their look (text or image), and where to find page prerequisites (stylesheet, favicon, images, scripts). Usually they are left at their default values, with the possible exception of &lt;code&gt;@stylesheets&lt;/code&gt; variable.</source>
          <target state="translated">아래에 설명 된 구성 변수는 대상 및 모양 (텍스트 또는 이미지) 및 페이지 전제 조건 (스타일 시트, 즐겨 찾기 아이콘, 이미지, 스크립트)을 찾을 수있는 gitweb 링크의 일부를 구성합니다. 일반적으로 &lt;code&gt;@stylesheets&lt;/code&gt; 변수를 제외하고 기본값으로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="352cabf788111a2af3c96521f974380812252a38" translate="yes" xml:space="preserve">
          <source>The configuration variables described below control how gitweb finds Git repositories, and how repositories are displayed and accessed.</source>
          <target state="translated">아래 설명 된 구성 변수는 gitweb이 Git 리포지토리를 찾는 방법과 리포지토리가 표시되고 액세스되는 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="3f43fd6b4f50ff73ead39001e9e7b24eaf91129d" translate="yes" xml:space="preserve">
          <source>The construct &lt;code&gt;@{-&amp;lt;n&amp;gt;}&lt;/code&gt; means the &amp;lt;n&amp;gt;th branch/commit checked out before the current one.</source>
          <target state="translated">구문 &lt;code&gt;@{-&amp;lt;n&amp;gt;}&lt;/code&gt; 은 현재 분기 전에 체크 아웃 된 &amp;lt;n&amp;gt; 분기 / 커밋을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="532c17d263ea0447251201d507a716aaf6f28f2e" translate="yes" xml:space="preserve">
          <source>The content to be committed can be specified in several ways:</source>
          <target state="translated">커밋 할 내용은 여러 가지 방법으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3c1db69a05b050bddfd156a5df9e51b55df4af8" translate="yes" xml:space="preserve">
          <source>The contents of the actual line is output after the above header, prefixed by a TAB. This is to allow adding more header elements later.</source>
          <target state="translated">실제 행의 내용은 TAB 접두사가 붙은 위의 헤더 다음에 출력됩니다. 나중에 더 많은 헤더 요소를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07ff8c430a66890255703acd59c46fb9590b9dc8" translate="yes" xml:space="preserve">
          <source>The contents of the blob objects are uninterpreted sequences of bytes. There is no encoding translation at the core level.</source>
          <target state="translated">Blob 객체의 내용은 해석되지 않은 바이트 시퀀스입니다. 핵심 수준에는 인코딩 변환이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b5efb2fc6b2c2f5d21112887ebec33fa1322cd1" translate="yes" xml:space="preserve">
          <source>The contents of the included file are inserted immediately, as if they had been found at the location of the include directive. If the value of the variable is a relative path, the path is considered to be relative to the configuration file in which the include directive was found. See below for examples.</source>
          <target state="translated">포함 지시문의 위치에서 찾은 것처럼 포함 된 파일의 내용이 즉시 삽입됩니다. 변수 값이 상대 경로 인 경우 경로는 include 지시문이 발견 된 구성 파일에 상대적인 것으로 간주됩니다. 예는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8e2acace54c1bc95e05b068c1615156bf7369b0d" translate="yes" xml:space="preserve">
          <source>The core Git is often called &quot;plumbing&quot;, with the prettier user interfaces on top of it called &quot;porcelain&quot;. You may not want to use the plumbing directly very often, but it can be good to know what the plumbing does when the porcelain isn&amp;rsquo;t flushing.</source>
          <target state="translated">핵심 Git은 종종 &quot;배관 (Plumbing)&quot;으로 불리며, 그 위에 &quot;포세린 (porcelain)&quot;이라는 더 아름다운 사용자 인터페이스가 있습니다. 배관을 자주 직접 사용하고 싶지 않을 수도 있지만, 도자기가 플러시되지 않을 때 배관이 무엇을하는지 아는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bdff9728a51893f686262a6a471251953f8ca49c" translate="yes" xml:space="preserve">
          <source>The core.multiPackIndex config setting must be on to consume MIDX files.</source>
          <target state="translated">MIDX 파일을 사용하려면 core.multiPackIndex 구성 설정이 켜져 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4fd34d18ba310e6b91e875c3fcf517fe13b68829" translate="yes" xml:space="preserve">
          <source>The cost matrix is populated thusly: for each pair of commits, both diffs are generated and the &quot;diff of diffs&quot; is generated, with 3 context lines, then the number of lines in that diff is used as cost.</source>
          <target state="translated">비용 매트릭스는 이렇게 채워집니다. 각 커밋 쌍에 대해 두 개의 diff가 생성되고 &quot;diff of diffs&quot;가 3 개의 컨텍스트 라인으로 생성 된 다음 해당 diff의 라인 수가 비용으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="588bd7a488f6b8b596aae7dca46a3809b4412eb0" translate="yes" xml:space="preserve">
          <source>The cost of an edge &lt;code&gt;o--C&lt;/code&gt; is the size of &lt;code&gt;C&lt;/code&gt;'s diff, modified by a fudge factor that should be smaller than 100%. The cost of an edge &lt;code&gt;o--o&lt;/code&gt; is free. The fudge factor is necessary because even if &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; have nothing in common, they may still share a few empty lines and such, possibly making the assignment &lt;code&gt;1--C&lt;/code&gt;, &lt;code&gt;o--o&lt;/code&gt; slightly cheaper than &lt;code&gt;1--o&lt;/code&gt;, &lt;code&gt;o--C&lt;/code&gt; even if &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; have nothing in common. With the fudge factor we require a much larger common part to consider patches as corresponding.</source>
          <target state="translated">모서리 &lt;code&gt;o--C&lt;/code&gt; 의 비용은 &lt;code&gt;C&lt;/code&gt; 의 diff 크기이며 퍼지 팩터로 수정하여 100 %보다 작아야합니다. 가장자리의 비용 &lt;code&gt;o--o&lt;/code&gt; 무료입니다. 퍼지 팩터는 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;C&lt;/code&gt; 에 공통점이없는 경우에도 여전히 몇 개의 빈 줄을 공유 할 수 있으므로 &lt;code&gt;1--C&lt;/code&gt; , &lt;code&gt;o--o&lt;/code&gt; 는 &lt;code&gt;1--o&lt;/code&gt; , &lt;code&gt;o--C&lt;/code&gt; 보다 약간 저렴합니다. &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;C&lt;/code&gt; 에 공통점이없는 경우에도 -C . 퍼지 계수를 사용하면 패치를 해당하는 것으로 간주하기 위해 훨씬 큰 공통 부분이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4d1179f527fe5d2769266ab8147ad92b0a56c021" translate="yes" xml:space="preserve">
          <source>The credential is split into a set of named attributes, with one attribute per line. Each attribute is specified by a key-value pair, separated by an &lt;code&gt;=&lt;/code&gt; (equals) sign, followed by a newline.</source>
          <target state="translated">The credential is split into a set of named attributes, with one attribute per line. Each attribute is specified by a key-value pair, separated by an &lt;code&gt;=&lt;/code&gt; (equals) sign, followed by a newline.</target>
        </trans-unit>
        <trans-unit id="1995b336f91a29b5d0cf1cb6bf6d7c2407fa802c" translate="yes" xml:space="preserve">
          <source>The credential is split into a set of named attributes, with one attribute per line. Each attribute is specified by a key-value pair, separated by an &lt;code&gt;=&lt;/code&gt; (equals) sign, followed by a newline. The key may contain any bytes except &lt;code&gt;=&lt;/code&gt;, newline, or NUL. The value may contain any bytes except newline or NUL. In both cases, all bytes are treated as-is (i.e., there is no quoting, and one cannot transmit a value with newline or NUL in it). The list of attributes is terminated by a blank line or end-of-file. Git understands the following attributes:</source>
          <target state="translated">자격 증명은 한 줄에 하나의 속성이있는 명명 된 속성 집합으로 분할됩니다. 각 속성은 키-값 쌍으로 지정되며 &lt;code&gt;=&lt;/code&gt; (등호) 기호로 구분되고 줄 바꿈이 뒤 따릅니다. 키에는 &lt;code&gt;=&lt;/code&gt; , 개행 또는 NUL을 제외한 모든 바이트가 포함될 수 있습니다 . 값은 개행 또는 NUL을 제외한 모든 바이트를 포함 할 수 있습니다. 두 경우 모두, 모든 바이트는있는 그대로 처리됩니다 (즉, 인용 부호가없고 그 안에 개행 문자 나 NUL이있는 값을 전송할 수 없습니다). 속성 목록은 빈 줄 또는 파일 끝으로 종료됩니다. Git은 다음 속성을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="332163de0b53725f6a8fdbb5dfbee2d72f5e952f" translate="yes" xml:space="preserve">
          <source>The credential&amp;rsquo;s password, if we are asking it to be stored.</source>
          <target state="translated">자격 증명 암호 (저장하도록 요청하는 경우)</target>
        </trans-unit>
        <trans-unit id="b2af82f2f4002bb109eae365a3025f169b56089c" translate="yes" xml:space="preserve">
          <source>The credential&amp;rsquo;s username, if we already have one (e.g., from a URL, from the user, or from a previously run helper).</source>
          <target state="translated">자격 증명의 사용자 이름 (예 : URL, 사용자 또는 이전에 실행 한 도우미)이 이미있는 경우</target>
        </trans-unit>
        <trans-unit id="4208e146b9bfac727faabb9820edc29c027631a0" translate="yes" xml:space="preserve">
          <source>The credential&amp;rsquo;s username, if we already have one (e.g., from a URL, the configuration, the user, or from a previously run helper).</source>
          <target state="translated">The credential&amp;rsquo;s username, if we already have one (e.g., from a URL, the configuration, the user, or from a previously run helper).</target>
        </trans-unit>
        <trans-unit id="327d8af868005c380ff04a569542ec1ad381deca" translate="yes" xml:space="preserve">
          <source>The current &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;. In more detail: Your &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; is normally derived from the state of the tree referred to by HEAD. HEAD is a reference to one of the &lt;a href=&quot;#def_head&quot;&gt;heads&lt;/a&gt; in your repository, except when using a &lt;a href=&quot;#def_detached_HEAD&quot;&gt;detached HEAD&lt;/a&gt;, in which case it directly references an arbitrary commit.</source>
          <target state="translated">현재 &lt;a href=&quot;#def_branch&quot;&gt;지점&lt;/a&gt; . 더 자세하게 : &lt;a href=&quot;#def_working_tree&quot;&gt;작업 트리는&lt;/a&gt; 일반적으로 HEAD가 참조하는 트리의 상태에서 파생됩니다. HEAD는 &lt;a href=&quot;#def_detached_HEAD&quot;&gt;분리 된 HEAD를&lt;/a&gt; 사용하는 경우를 제외하고 저장소 의 &lt;a href=&quot;#def_head&quot;&gt;헤드&lt;/a&gt; 중 하나에 대한 참조 이며,이 경우 임의 커밋을 직접 참조합니다.</target>
        </trans-unit>
        <trans-unit id="6a22129f9e2c1c598b41ac7718060a19c57ba2df" translate="yes" xml:space="preserve">
          <source>The current branch and &lt;code&gt;HEAD&lt;/code&gt; pointer stay at the last commit successfully made.</source>
          <target state="translated">현재 브랜치 및 &lt;code&gt;HEAD&lt;/code&gt; 포인터는 마지막으로 커밋 된 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0f49d1c21e2564ca60f22933641a619ec1965bd6" translate="yes" xml:space="preserve">
          <source>The current branch is reset to &amp;lt;upstream&amp;gt;, or &amp;lt;newbase&amp;gt; if the --onto option was supplied. This has the exact same effect as &lt;code&gt;git reset --hard &amp;lt;upstream&amp;gt;&lt;/code&gt; (or &amp;lt;newbase&amp;gt;). ORIG_HEAD is set to point at the tip of the branch before the reset.</source>
          <target state="translated">--onto 옵션이 제공된 경우 현재 분기는 &amp;lt;upstream&amp;gt; 또는 &amp;lt;newbase&amp;gt;로 재설정됩니다. 이것은 &lt;code&gt;git reset --hard &amp;lt;upstream&amp;gt;&lt;/code&gt; (또는 &amp;lt;newbase&amp;gt;) 와 동일한 효과를 갖습니다. ORIG_HEAD는 재설정 전 분기의 끝을 가리 키도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="485fe33a04a6d00e71aec5bce139a108011107ac" translate="yes" xml:space="preserve">
          <source>The current command-line parameters used for each variant are as follows:</source>
          <target state="translated">각 변형에 사용되는 현재 명령 줄 매개 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f1d20a076d93bfe14eb345a4d54fe76b72904bc4" translate="yes" xml:space="preserve">
          <source>The current index and work tree is derived from $H, but the user may have local changes in them since $H.</source>
          <target state="translated">현재 색인 및 작업 트리는 $ H에서 파생되지만 사용자는 $ H 이후로 로컬 변경이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bc299cda3bedfdcbabc4a6883d29c81bf74d5df" translate="yes" xml:space="preserve">
          <source>The current index file for the repository. It is usually not found in a bare repository.</source>
          <target state="translated">저장소의 현재 색인 파일 일반적으로 베어 저장소에는 없습니다.</target>
        </trans-unit>
        <trans-unit id="6561295b83003ebae9a9c6ca19e06cdfe7bf9b70" translate="yes" xml:space="preserve">
          <source>The currently defined format versions are:</source>
          <target state="translated">현재 정의 된 형식 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66a8472981ef80b1cce56bd59cf5f4d97c11f9f9" translate="yes" xml:space="preserve">
          <source>The currently supported hooks are described below.</source>
          <target state="translated">현재 지원되는 후크는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8715361e5840de7b556e67eacf990927a206b328" translate="yes" xml:space="preserve">
          <source>The custom diff driver command. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">사용자 정의 diff 드라이버 명령 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1e530b24daf8e53e45f57000d6a6174670a1f6d2" translate="yes" xml:space="preserve">
          <source>The data content for the file has not been supplied yet. The frontend wants to supply it as part of this modify command.</source>
          <target state="translated">파일의 데이터 내용이 아직 제공되지 않았습니다. 프론트 엔드는이 수정 명령의 일부로이를 제공하려고합니다.</target>
        </trans-unit>
        <trans-unit id="f92713104ec45ad60b839fa902e6ffedd1e05a41" translate="yes" xml:space="preserve">
          <source>The data content for the file was already supplied by a prior &lt;code&gt;blob&lt;/code&gt; command. The frontend just needs to connect it.</source>
          <target state="translated">파일의 데이터 내용은 이미 이전 &lt;code&gt;blob&lt;/code&gt; 명령으로 제공되었습니다 . 프론트 엔드 만 연결하면됩니다.</target>
        </trans-unit>
        <trans-unit id="abeb69d3d4bae2cc1a5a16e58850f1c93c17369b" translate="yes" xml:space="preserve">
          <source>The data content for the note has not been supplied yet. The frontend wants to supply it as part of this modify command.</source>
          <target state="translated">메모의 데이터 내용이 아직 제공되지 않았습니다. 프론트 엔드는이 수정 명령의 일부로이를 제공하려고합니다.</target>
        </trans-unit>
        <trans-unit id="81c47d0a0bfa5328ac109608aa42a36ac0ca6a45" translate="yes" xml:space="preserve">
          <source>The data content for the note was already supplied by a prior &lt;code&gt;blob&lt;/code&gt; command. The frontend just needs to connect it to the commit that is to be annotated.</source>
          <target state="translated">노트의 데이터 컨텐츠는 이미 이전 &lt;code&gt;blob&lt;/code&gt; 명령으로 제공되었습니다 . 프론트 엔드는 주석을 달 수있는 커밋에 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="d1c68865b9a230a071410342b903f7a0e48271ba" translate="yes" xml:space="preserve">
          <source>The data that follows the keyword &lt;code&gt;gitdir:&lt;/code&gt; is used as a glob pattern. If the location of the .git directory matches the pattern, the include condition is met.</source>
          <target state="translated">키워드 &lt;code&gt;gitdir:&lt;/code&gt; 다음에 오는 데이터 는 glob 패턴으로 사용됩니다. .git 디렉토리의 위치가 패턴과 일치하면 포함 조건이 충족됩니다.</target>
        </trans-unit>
        <trans-unit id="c1597312d460a92e79d09c37c305ec85acdf7d09" translate="yes" xml:space="preserve">
          <source>The data that follows the keyword &lt;code&gt;onbranch:&lt;/code&gt; is taken to be a pattern with standard globbing wildcards and two additional ones, &lt;code&gt;**/&lt;/code&gt; and &lt;code&gt;/**&lt;/code&gt;, that can match multiple path components. If we are in a worktree where the name of the branch that is currently checked out matches the pattern, the include condition is met.</source>
          <target state="translated">&lt;code&gt;onbranch:&lt;/code&gt; 키워드 뒤에 오는 데이터는 표준 경로 지정 와일드 카드와 여러 경로 구성 요소와 일치 할 수있는 두 개의 추가 &lt;code&gt;**/&lt;/code&gt; 및 &lt;code&gt;/**&lt;/code&gt; 가있는 패턴으로 간주 됩니다. 현재 체크 아웃 된 분기 이름이 패턴과 일치하는 작업 트리에있는 경우 포함 조건이 충족됩니다.</target>
        </trans-unit>
        <trans-unit id="7c053d7b296d35ca64db938819dea858103dc6da" translate="yes" xml:space="preserve">
          <source>The data transfer of the packfile is always multiplexed, using the same semantics of the &lt;code&gt;side-band-64k&lt;/code&gt; capability from protocol version 1. This means that each packet, during the packfile data stream, is made up of a leading 4-byte pkt-line length (typical of the pkt-line format), followed by a 1-byte stream code, followed by the actual data.</source>
          <target state="translated">팩 파일의 데이터 전송은 항상 프로토콜 버전 1 의 &lt;code&gt;side-band-64k&lt;/code&gt; 기능 과 동일한 의미를 사용하여 멀티플렉싱됩니다 . 이는 팩 파일 데이터 스트림 동안 각 패킷이 선행 4 바이트 pkt- 행 길이 (일반적으로 pkt-line 형식), 1 바이트 스트림 코드, 실제 데이터가 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="c2900c14cd751c2ba06b33eb8d53cbdb905b94a4" translate="yes" xml:space="preserve">
          <source>The database cannot be reliably regenerated in a consistent form after the branch it is tracking has changed. Example: For merged branches, &lt;code&gt;git-cvsserver&lt;/code&gt; only tracks one branch of development, and after a &lt;code&gt;git merge&lt;/code&gt; an incrementally updated database may track a different branch than a database regenerated from scratch, causing inconsistent CVS revision numbers. &lt;code&gt;git-cvsserver&lt;/code&gt; has no way of knowing which branch it would have picked if it had been run incrementally pre-merge. So if you have to fully or partially (from old backup) regenerate the database, you should be suspicious of pre-existing CVS sandboxes.</source>
          <target state="translated">추적중인 분기가 변경된 후에는 데이터베이스를 일관된 형태로 안정적으로 재생성 할 수 없습니다. 예 : 병합 된 브랜치의 경우, &lt;code&gt;git-cvsserver&lt;/code&gt; 는 하나의 개발 브랜치 만 추적하며, &lt;code&gt;git merge&lt;/code&gt; 후 증분 업데이트 된 데이터베이스는 처음부터 다시 생성 된 데이터베이스와 다른 브랜치를 추적하여 CVS 개정 번호가 일치하지 않을 수 있습니다. &lt;code&gt;git-cvsserver&lt;/code&gt; 는 점진적으로 사전 병합 된 경우 어떤 분기를 선택했는지 알 방법이 없습니다. 따라서 (이전 백업에서) 데이터베이스를 완전히 또는 부분적으로 재생성해야하는 경우 기존 CVS 샌드 박스가 의심됩니다.</target>
        </trans-unit>
        <trans-unit id="44d2a77b29a1133933d2693560e181324cc0bf34" translate="yes" xml:space="preserve">
          <source>The database has an object whose hash doesn&amp;rsquo;t match the object database value. This indicates a serious data integrity problem.</source>
          <target state="translated">데이터베이스에 해시가 개체 데이터베이스 값과 일치하지 않는 개체가 있습니다. 이는 심각한 데이터 무결성 문제를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9944b3cc77c01bf0f8e3a227e6281fac295bdf59" translate="yes" xml:space="preserve">
          <source>The date used for the author identity when creating commit or tag objects, or when writing reflogs. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for valid formats.</source>
          <target state="translated">The date used for the author identity when creating commit or tag objects, or when writing reflogs. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for valid formats.</target>
        </trans-unit>
        <trans-unit id="ab2821bcf3a61c45db1fdab7123e1f2d0deeb254" translate="yes" xml:space="preserve">
          <source>The date used for the committer identity when creating commit or tag objects, or when writing reflogs. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for valid formats.</source>
          <target state="translated">The date used for the committer identity when creating commit or tag objects, or when writing reflogs. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for valid formats.</target>
        </trans-unit>
        <trans-unit id="28234e35fb4524e90d740d3154dc66c02cb1f7a2" translate="yes" xml:space="preserve">
          <source>The default &amp;lt;ref&amp;gt; is &quot;master&quot;.</source>
          <target state="translated">기본 &amp;lt;ref&amp;gt;는 &quot;master&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="c033f0ddddff0b7a496ef058316bfe1c29b59dcb" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; that is merged into the branch in question (or the branch in question is rebased onto). It is configured via branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge. If the upstream branch of 'A' is 'origin/B' sometimes we say &quot;'A' is tracking 'origin/B'&quot;.</source>
          <target state="translated">해당 &lt;a href=&quot;#def_branch&quot;&gt;브랜치&lt;/a&gt; 에 병합 된 기본 브랜치 (또는 해당 브랜치가 기반) branch. &amp;lt;name&amp;gt; .remote 및 branch. &amp;lt;name&amp;gt; .merge를 통해 구성됩니다. 'A'의 업스트림 분기가 'origin / B'인 경우 ''A '는'origin / B '를 추적합니다'라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="0e2c938aad423666052c9b862a31c7bd282b15cb" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; that is merged into the branch in question (or the branch in question is rebased onto). It is configured via branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge. If the upstream branch of &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;origin/B&lt;/code&gt; sometimes we say &quot;&lt;code&gt;A&lt;/code&gt; is tracking &lt;code&gt;origin/B&lt;/code&gt;&quot;.</source>
          <target state="translated">해당 &lt;a href=&quot;#def_branch&quot;&gt;브랜치&lt;/a&gt; 에 병합 된 기본 브랜치 (또는 해당 브랜치가 기반) branch. &amp;lt;name&amp;gt; .remote 및 branch. &amp;lt;name&amp;gt; .merge를 통해 구성됩니다. &lt;code&gt;A&lt;/code&gt; 의 업스트림 분기 가 &lt;code&gt;origin/B&lt;/code&gt; 경우 &quot; &lt;code&gt;A&lt;/code&gt; 는 &lt;code&gt;origin/B&lt;/code&gt; 추적합니다 &quot;라고 말합니다 .</target>
        </trans-unit>
        <trans-unit id="2a57474834373f0012a2eee4dc03542456f6b683" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;applypatch-msg&lt;/code&gt; hook, when enabled, runs the &lt;code&gt;commit-msg&lt;/code&gt; hook, if the latter is enabled.</source>
          <target state="translated">활성화 된 경우 기본 &lt;code&gt;applypatch-msg&lt;/code&gt; 후크는 &lt;code&gt;commit-msg&lt;/code&gt; 후크를 실행 합니다 (후자가 활성화 된 경우).</target>
        </trans-unit>
        <trans-unit id="1004092b458b148233da1997202a081689268a8e" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;commit-msg&lt;/code&gt; hook, when enabled, detects duplicate &quot;Signed-off-by&quot; lines, and aborts the commit if one is found.</source>
          <target state="translated">사용 가능한 경우 기본 &lt;code&gt;commit-msg&lt;/code&gt; 훅은 중복 된 &quot;Signed-off-by&quot;라인을 감지하고 커밋이 발견되면 중단합니다.</target>
        </trans-unit>
        <trans-unit id="ec637f4377b8067b441e5ba8f9153d34270f7f0f" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;commit-msg&lt;/code&gt; hook, when enabled, detects duplicate &lt;code&gt;Signed-off-by&lt;/code&gt; trailers, and aborts the commit if one is found.</source>
          <target state="translated">활성화 된 경우 기본 &lt;code&gt;commit-msg&lt;/code&gt; 후크는 중복 된 &lt;code&gt;Signed-off-by&lt;/code&gt; 트레일러를 감지 하고 발견되면 커밋을 중단합니다.</target>
        </trans-unit>
        <trans-unit id="54e7a2ab7a7ead4c100931e31ff4408636c3868d" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;post-receive&lt;/code&gt; hook is empty, but there is a sample script &lt;code&gt;post-receive-email&lt;/code&gt; provided in the &lt;code&gt;contrib/hooks&lt;/code&gt; directory in Git distribution, which implements sending commit emails.</source>
          <target state="translated">기본 &lt;code&gt;post-receive&lt;/code&gt; 후크는 비어 있지만 Git 분배 의 &lt;code&gt;contrib/hooks&lt;/code&gt; 디렉토리에 샘플 스크립트 &lt;code&gt;post-receive-email&lt;/code&gt; 제공되어 커미트 이메일 전송을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a71e842d9eb90ca6731ba585809c1f8c19eb80f6" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-applypatch&lt;/code&gt; hook, when enabled, runs the &lt;code&gt;pre-commit&lt;/code&gt; hook, if the latter is enabled.</source>
          <target state="translated">활성화 된 기본 &lt;code&gt;pre-applypatch&lt;/code&gt; 후크는 &lt;code&gt;pre-commit&lt;/code&gt; 후크를 활성화합니다 (후자가 활성화 된 경우).</target>
        </trans-unit>
        <trans-unit id="b4266565542333c335464dc9285134a4a9b31011" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-commit&lt;/code&gt; hook, when enabled&amp;mdash;​and with the &lt;code&gt;hooks.allownonascii&lt;/code&gt; config option unset or set to false&amp;mdash;​prevents the use of non-ASCII filenames.</source>
          <target state="translated">활성화되어 있고 &lt;code&gt;hooks.allownonascii&lt;/code&gt; 구성 옵션이 설정되지 않았거나 false로 설정된 기본 &lt;code&gt;pre-commit&lt;/code&gt; 후크는 ASCII가 아닌 파일 이름을 사용하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="c591fe93d0021a0c7991225b1a062c31f35ddd16" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-commit&lt;/code&gt; hook, when enabled, catches introduction of lines with trailing whitespaces and aborts the commit when such a line is found.</source>
          <target state="translated">사용 가능한 경우 기본 &lt;code&gt;pre-commit&lt;/code&gt; 후크는 후행 공백이있는 라인의 도입을 포착하고 해당 라인이 발견되면 커미트를 중단합니다.</target>
        </trans-unit>
        <trans-unit id="5c24125124251d23fec260bbe8f20bf4ce1ae496" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;pre-merge-commit&lt;/code&gt; hook, when enabled, runs the &lt;code&gt;pre-commit&lt;/code&gt; hook, if the latter is enabled.</source>
          <target state="translated">기본 &lt;code&gt;pre-merge-commit&lt;/code&gt; 후크 (사용 가능한 경우)는 &lt;code&gt;pre-commit&lt;/code&gt; 후크 ( 사용 가능한 경우)를 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="c0f0841a2790ebd8e4684a32dafde265e2735139" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;update&lt;/code&gt; hook, when enabled&amp;mdash;​and with &lt;code&gt;hooks.allowunannotated&lt;/code&gt; config option unset or set to false&amp;mdash;​prevents unannotated tags to be pushed.</source>
          <target state="translated">활성화되어 있고 &lt;code&gt;hooks.allowunannotated&lt;/code&gt; 구성 옵션이 설정되지 않았거나 false로 설정된 기본 &lt;code&gt;update&lt;/code&gt; 후크 는 주석이없는 태그가 푸시되는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="d309c8d9323df973a9380612e8ce1c6c75650d93" translate="yes" xml:space="preserve">
          <source>The default behavior can be set via the &lt;code&gt;checkout.guess&lt;/code&gt; configuration variable.</source>
          <target state="translated">기본 동작은 &lt;code&gt;checkout.guess&lt;/code&gt; 구성 변수 를 통해 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e99caaee535fa5770d85355802dd91eb002c650f" translate="yes" xml:space="preserve">
          <source>The default behavior of this command when no &amp;lt;refspec&amp;gt; is given can be configured by setting the &lt;code&gt;push&lt;/code&gt; option of the remote, or the &lt;code&gt;push.default&lt;/code&gt; configuration variable.</source>
          <target state="translated">&amp;lt;refspec&amp;gt;을 지정하지 않은 경우이 명령의 기본 동작은 리모콘 의 &lt;code&gt;push&lt;/code&gt; 옵션 또는 &lt;code&gt;push.default&lt;/code&gt; 구성 변수 를 설정하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04fb2222b71daf513a74198926f20b6eb1c65e53" translate="yes" xml:space="preserve">
          <source>The default can be changed by the &lt;code&gt;commit.cleanup&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;commit.cleanup&lt;/code&gt; 구성 변수에 의해 기본값을 변경할 수 있습니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6d2b951210087bf6a12979c879cea7654da192ce" translate="yes" xml:space="preserve">
          <source>The default can be changed using the status.showUntrackedFiles configuration variable documented in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">기본값은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]에&lt;/a&gt; 설명 된 status.showUntrackedFiles 구성 변수를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4804356dda86c0d39019920e2a204580a3348e0" translate="yes" xml:space="preserve">
          <source>The default configuration with no configuration file at all may work perfectly well for some installations. Still, a configuration file is useful for customizing or tweaking the behavior of gitweb in many ways, and some optional features will not be present unless explicitly enabled using the configurable &lt;code&gt;%features&lt;/code&gt; variable (see also &quot;Configuring gitweb features&quot; section below).</source>
          <target state="translated">구성 파일이 전혀없는 기본 구성은 일부 설치에서 완벽하게 작동 할 수 있습니다. 그래도 구성 파일은 여러 가지 방법으로 gitweb의 동작을 사용자 정의하거나 조정하는 데 유용하며 구성 가능한 &lt;code&gt;%features&lt;/code&gt; 변수를 사용하여 명시 적으로 활성화하지 않으면 일부 선택적 기능이 나타나지 않습니다 (아래 &quot;gitweb 기능 구성&quot;섹션 참조).</target>
        </trans-unit>
        <trans-unit id="ba35598baf99b4759b4ac8e8e152046ad84f4f70" translate="yes" xml:space="preserve">
          <source>The default destination is &lt;code&gt;syslog&lt;/code&gt; if &lt;code&gt;--inetd&lt;/code&gt; or &lt;code&gt;--detach&lt;/code&gt; is specified, otherwise &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--inetd&lt;/code&gt; 또는 &lt;code&gt;--detach&lt;/code&gt; 가 지정된 경우 기본 대상은 &lt;code&gt;syslog&lt;/code&gt; 이고 , 그렇지 않으면 &lt;code&gt;stderr&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="08a91820da4ab8ff0557091a83e78baf95e62cbc" translate="yes" xml:space="preserve">
          <source>The default development &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;. Whenever you create a Git &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;, a branch named &quot;master&quot; is created, and becomes the active branch. In most cases, this contains the local development, though that is purely by convention and is not required.</source>
          <target state="translated">기본 개발 &lt;a href=&quot;#def_branch&quot;&gt;지점&lt;/a&gt; . Git &lt;a href=&quot;#def_repository&quot;&gt;저장소&lt;/a&gt; 를 생성 할 때마다 &quot;master&quot;라는 브랜치가 생성되고 활성 브랜치가됩니다. 대부분의 경우 여기에는 로컬 개발이 포함되어 있지만 이는 순전히 규칙에 의한 것이며 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9cfb0587d78b80316db2bf990e0689e616d2c4e9" translate="yes" xml:space="preserve">
          <source>The default diff tool to use when &lt;code&gt;--gui&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;--gui&lt;/code&gt; 를 지정할 때 사용할 기본 diff 도구 입니다.</target>
        </trans-unit>
        <trans-unit id="2106f60990b064f5f08c291bb6d584e30eb4aef6" translate="yes" xml:space="preserve">
          <source>The default diff tool to use.</source>
          <target state="translated">사용할 기본 diff 도구입니다.</target>
        </trans-unit>
        <trans-unit id="ef7818a768aaedb1852c90af2f69c6d87d81a9be" translate="yes" xml:space="preserve">
          <source>The default for format-patch is to output a signature containing the Git version number. Use this variable to change that default. Set this variable to the empty string (&quot;&quot;) to suppress signature generation.</source>
          <target state="translated">format-patch의 기본값은 Git 버전 번호가 포함 된 서명을 출력하는 것입니다. 이 변수를 사용하여 해당 기본값을 변경하십시오. 서명 생성을 억제하려면이 변수를 빈 문자열 ( &quot;&quot;)로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="04f69f6bfbe685cc6892bfe73707b968c4b7e627" translate="yes" xml:space="preserve">
          <source>The default for format-patch is to output files with the &lt;code&gt;[PATCH]&lt;/code&gt; subject prefix. Use this variable to change that prefix.</source>
          <target state="translated">format-patch의 기본값은 &lt;code&gt;[PATCH]&lt;/code&gt; 제목 접두어로 파일을 출력하는 것입니다 . 이 변수를 사용하여 해당 접 두부를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="9305a301a407a477c0982cd809ad589540305e9b" translate="yes" xml:space="preserve">
          <source>The default for format-patch is to output files with the suffix &lt;code&gt;.patch&lt;/code&gt;. Use this variable to change that suffix (make sure to include the dot if you want it).</source>
          <target state="translated">format-patch의 기본값은 접미사가 &lt;code&gt;.patch&lt;/code&gt; 인 파일을 출력하는 것입니다 . 이 변수를 사용하여 해당 접미사를 변경하십시오 (원하는 경우 점을 포함 시키십시오).</target>
        </trans-unit>
        <trans-unit id="82f6ff06915abbfaa5bafadf3e71c6515eea8a49" translate="yes" xml:space="preserve">
          <source>The default for the patch directory is patches or the value of the &lt;code&gt;$QUILT_PATCHES&lt;/code&gt; environment variable.</source>
          <target state="translated">패치 디렉토리의 기본값은 패치 또는 &lt;code&gt;$QUILT_PATCHES&lt;/code&gt; 환경 변수 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="63e417c4ba57abb65259188be896bb91267bad84" translate="yes" xml:space="preserve">
          <source>The default for the series file is &amp;lt;patches&amp;gt;/series or the value of the &lt;code&gt;$QUILT_SERIES&lt;/code&gt; environment variable.</source>
          <target state="translated">시리즈 파일의 기본값은 &amp;lt;patches&amp;gt; / series 또는 &lt;code&gt;$QUILT_SERIES&lt;/code&gt; 환경 변수 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="43b413a4d69c795f1a4cc6e5069d43aa254cba9e" translate="yes" xml:space="preserve">
          <source>The default format does not show what the original said in the conflicting area. You cannot tell how many lines are deleted and replaced with Barbie&amp;rsquo;s remark on your side. The only thing you can tell is that your side wants to say it is hard and you&amp;rsquo;d prefer to go shopping, while the other side wants to claim it is easy.</source>
          <target state="translated">기본 형식은 충돌 영역에서 원본이 말한 내용을 표시하지 않습니다. 몇 줄이 삭제되고 바비의 말로 바뀔 수 있는지 알 수 없습니다. 당신이 말할 수있는 유일한 것은 당신의 측이 어렵다고 말하고 싶어하고 당신이 쇼핑하러 가고 싶어하는 반면, 다른 쪽은 쉽다고 주장하기를 원한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2c9ac4b5e02925d5a2242fa228d32b0af91d581b" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;--no-notes&lt;/code&gt;, unless the &lt;code&gt;format.notes&lt;/code&gt; configuration is set.</source>
          <target state="translated">&lt;code&gt;format.notes&lt;/code&gt; 구성이 설정되어 있지 않으면 기본값은 &lt;code&gt;--no-notes&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e210eb7dbec89858b8e72d64e2d379a9aada6a48" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;--no-thread&lt;/code&gt;, unless the &lt;code&gt;format.thread&lt;/code&gt; configuration is set. If &lt;code&gt;--thread&lt;/code&gt; is specified without a style, it defaults to the style specified by &lt;code&gt;format.thread&lt;/code&gt; if any, or else &lt;code&gt;shallow&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;format.thread&lt;/code&gt; 구성이 설정되어 있지 않으면 기본값은 &lt;code&gt;--no-thread&lt;/code&gt; 입니다. 경우 &lt;code&gt;--thread&lt;/code&gt; 는 스타일없이 지정에 의해 지정된 스타일을 기본값 &lt;code&gt;format.thread&lt;/code&gt; 있는 경우, 또는 다른 &lt;code&gt;shallow&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9abe1131612b105426f13be17707662aa8662d23" translate="yes" xml:space="preserve">
          <source>The default is false, except &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; will probe and set core.ignoreCase true if appropriate when the repository is created.</source>
          <target state="translated">&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt; 이 저장소를 만들 때 적절한 경우 core.ignoreCase를 검사하고 true로 설정한다는 점을 제외하고 기본값은 false 입니다.</target>
        </trans-unit>
        <trans-unit id="fcf73b7882b6e3d265136d0071b137412decce56" translate="yes" xml:space="preserve">
          <source>The default is not to print any annotation lines. If no number is given to &lt;code&gt;-n&lt;/code&gt;, only the first line is printed. If the tag is not annotated, the commit message is displayed instead.</source>
          <target state="translated">기본값은 주석 행을 인쇄하지 않는 것입니다. &lt;code&gt;-n&lt;/code&gt; 에 숫자가 제공되지 않으면 첫 번째 행만 인쇄됩니다. 태그에 주석을 달지 않으면 커밋 메시지가 대신 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="19baf950afb8f746e54b7299adf6fbd6966f659a" translate="yes" xml:space="preserve">
          <source>The default is to diff against our branch (-2) and the cleanly resolved paths. The option -0 can be given to omit diff output for unmerged entries and just show &quot;Unmerged&quot;.</source>
          <target state="translated">디폴트는 브랜치 (-2)와 깨끗하게 해결 된 경로와 다른 것입니다. 옵션 -0을 사용하면 병합되지 않은 항목에 대한 diff 출력을 생략하고 &quot;Unmerged&quot;만 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70f152ab57d660d365ae81763277f72b2d86f307" translate="yes" xml:space="preserve">
          <source>The default is true (when core.filemode is not specified in the config file).</source>
          <target state="translated">기본값은 true입니다 (config 파일에 core.filemode가 지정되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="03228e9bc81b32ffbccac2430f1d794dd7591d2a" translate="yes" xml:space="preserve">
          <source>The default is true, except &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt; or &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; will probe and set core.symlinks false if appropriate when the repository is created.</source>
          <target state="translated">&lt;a href=&quot;git-clone&quot;&gt;git-clone [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt; 이 리포지토리 생성시 적절한 경우 core.symlinks를 검사하고 설정하는 것을 제외하고 기본값은 true 입니다.</target>
        </trans-unit>
        <trans-unit id="72445c1104c1c11ef748913a9c6e570e5a73c947" translate="yes" xml:space="preserve">
          <source>The default location of the CVS checkout to use for the export.</source>
          <target state="translated">내보내기에 사용할 CVS 체크 아웃의 기본 위치입니다.</target>
        </trans-unit>
        <trans-unit id="116262510e324641581bf8e5fe54c44cc1ec58f5" translate="yes" xml:space="preserve">
          <source>The default merge strategy to use when pulling a single branch.</source>
          <target state="translated">단일 분기를 가져올 때 사용할 기본 병합 전략입니다.</target>
        </trans-unit>
        <trans-unit id="a808540aa8de08b00cb350dbc14ab54e33fa8faf" translate="yes" xml:space="preserve">
          <source>The default merge strategy to use when pulling multiple branches at once.</source>
          <target state="translated">한 번에 여러 분기를 가져올 때 사용할 기본 병합 전략입니다.</target>
        </trans-unit>
        <trans-unit id="e2e648395119cc70a2e9e998b6f3d4c60294fc12" translate="yes" xml:space="preserve">
          <source>The default mode for format-patch to determine which parts of the cover letter will be populated using the branch&amp;rsquo;s description. See the &lt;code&gt;--cover-from-description&lt;/code&gt; option in &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">분기의 설명을 사용하여 표지의 어떤 부분을 채울지 결정하는 format-patch의 기본 모드입니다. &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; 의 &lt;code&gt;--cover-from-description&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="063faead523251f77be0529092965c3429cc8003" translate="yes" xml:space="preserve">
          <source>The default module path for &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt; to use instead of /usr/lib/apache2/modules. Only used if httpd is Apache.</source>
          <target state="translated">/ usr / lib / apache2 / modules 대신 &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt; 의 기본 모듈 경로 . httpd가 Apache 인 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="91f8aff2bf27bb7f60525104a4a75d78c7ffe52b" translate="yes" xml:space="preserve">
          <source>The default notes merge strategy is &quot;manual&quot;, which checks out conflicting notes in a special work tree for resolving notes conflicts (&lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt;), and instructs the user to resolve the conflicts in that work tree. When done, the user can either finalize the merge with &lt;code&gt;git notes merge --commit&lt;/code&gt;, or abort the merge with &lt;code&gt;git notes merge --abort&lt;/code&gt;.</source>
          <target state="translated">기본 메모 병합 전략은 &quot;수동&quot;으로, 메모 충돌 해결을 위해 특수 작업 트리에서 충돌하는 메모를 확인하고 ( &lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt; ) 해당 작업 트리에서 충돌을 해결하도록 사용자에게 지시합니다. 완료되면 사용자는 &lt;code&gt;git notes merge --commit&lt;/code&gt; 으로 병합을 완료하거나 git notes merge --abort로 병합을 중단 &lt;code&gt;git notes merge --abort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d49acb565d9b642605b0a997d7ebc3213ecdde25" translate="yes" xml:space="preserve">
          <source>The default pretty format for log/show/whatchanged command, See &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged[1]&lt;/a&gt;.</source>
          <target state="translated">log / show / whatchanged 명령의 기본 pretty 형식은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; , &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; , &lt;a href=&quot;git-whatchanged&quot;&gt;git-whatchanged [1]을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c642123af45071133c151f29614b42c5bfc1ffac" translate="yes" xml:space="preserve">
          <source>The default program to execute on the remote side when fetching. See option --upload-pack of &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt;.</source>
          <target state="translated">가져올 때 원격에서 실행할 기본 프로그램입니다. &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack [1]&lt;/a&gt; 의 --upload-pack 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02bc1378d0d05db5e7ff2ca7062e80f4098e5579" translate="yes" xml:space="preserve">
          <source>The default program to execute on the remote side when pushing. See option --receive-pack of &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">밀 때 원격에서 실행할 기본 프로그램입니다. &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 의 --receive-pack 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1520b8813a02e6817b17665a2200c8c1eb73489c" translate="yes" xml:space="preserve">
          <source>The default remote is the remote of the remote-tracking branch of the current branch. If no such remote-tracking branch exists or the HEAD is detached, &quot;origin&quot; is assumed to be the default remote. If the superproject doesn&amp;rsquo;t have a default remote configured the superproject is its own authoritative upstream and the current working directory is used instead.</source>
          <target state="translated">기본 원격은 현재 지점의 원격 추적 분기의 원격입니다. 이러한 원격 추적 분기가 없거나 HEAD가 분리 된 경우 &quot;원본&quot;이 기본 원격으로 간주됩니다. 수퍼 프로젝트에 기본 원격이 구성되어 있지 않은 경우 수퍼 프로젝트는 자체 권위있는 업스트림이며 현재 작업 디렉토리가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0d78370864f4fde80869e4efb080139612c8d161" translate="yes" xml:space="preserve">
          <source>The default set of &quot;refspec&quot; for &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;. See &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 의 기본 &quot;refspec&quot;세트 . &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e7461b63dbe3a9bd4be74e77260f6121d70becf" translate="yes" xml:space="preserve">
          <source>The default set of &quot;refspec&quot; for &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;. See &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 의 기본 &quot;refspec&quot;세트 . &lt;a href=&quot;git-push&quot;&gt;git-push [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b1d55965a766c32086046542d13a0c5cafb5d20" translate="yes" xml:space="preserve">
          <source>The default set of branches for &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt;. See &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt; 의 기본 분기 세트입니다 . &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f8a6ecfdcb232e0e35afa31c75a9bb76e3ba014" translate="yes" xml:space="preserve">
          <source>The default template directory includes some directory structure, suggested &quot;exclude patterns&quot; (see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;), and sample hook files.</source>
          <target state="translated">기본 템플리트 디렉토리에는 일부 디렉토리 구조, 제안 된 &quot;제외 패턴&quot;( &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]&lt;/a&gt; 참조 ) 및 샘플 후크 파일이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5c5dda91be7317473d73b4f4f28156d762d8905f" translate="yes" xml:space="preserve">
          <source>The default threading style for &lt;code&gt;git format-patch&lt;/code&gt;. Can be a boolean value, or &lt;code&gt;shallow&lt;/code&gt; or &lt;code&gt;deep&lt;/code&gt;. &lt;code&gt;shallow&lt;/code&gt; threading makes every mail a reply to the head of the series, where the head is chosen from the cover letter, the &lt;code&gt;--in-reply-to&lt;/code&gt;, and the first patch mail, in this order. &lt;code&gt;deep&lt;/code&gt; threading makes every mail a reply to the previous one. A true boolean value is the same as &lt;code&gt;shallow&lt;/code&gt;, and a false value disables threading.</source>
          <target state="translated">&lt;code&gt;git format-patch&lt;/code&gt; 의 기본 스레딩 스타일입니다 . 부울 값이거나 &lt;code&gt;shallow&lt;/code&gt; 또는 &lt;code&gt;deep&lt;/code&gt; 일 수 있습니다 . &lt;code&gt;shallow&lt;/code&gt; 스레딩은 모든 메일을 시리즈의 헤드에 대한 회신으로 만듭니다. 여기서 헤드는 표지, &lt;code&gt;--in-reply-to&lt;/code&gt; 및 첫 번째 패치 메일에서이 순서대로 선택됩니다. &lt;code&gt;deep&lt;/code&gt; 스레딩은 모든 메일을 이전 메일에 대한 회신으로 만듭니다. true 부울 값은 &lt;code&gt;shallow&lt;/code&gt; 과 동일 하며 false 값은 스레딩을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="0eb7f832f6b33a6020eb8629fee287c4b15b4801" translate="yes" xml:space="preserve">
          <source>The default upstream &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. Most projects have at least one upstream project which they track. By default 'origin' is used for that purpose. New upstream updates will be fetched into &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;remote-tracking branches&lt;/a&gt; named origin/name-of-upstream-branch, which you can see using &lt;code&gt;git branch -r&lt;/code&gt;.</source>
          <target state="translated">기본 업스트림 &lt;a href=&quot;#def_repository&quot;&gt;저장소&lt;/a&gt; . 대부분의 프로젝트에는 추적 할 하나 이상의 업스트림 프로젝트가 있습니다. 기본적으로 'origin'이 해당 목적으로 사용됩니다. 새로운 업스트림 업데이트는 origin / name-of-upstream-branch라는 &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;원격 추적 분기&lt;/a&gt; 로 가져 &lt;code&gt;git branch -r&lt;/code&gt; 사용하여 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f838be44da45fd1828d0b46b391485ccd56187e" translate="yes" xml:space="preserve">
          <source>The default upstream &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. Most projects have at least one upstream project which they track. By default &lt;code&gt;origin&lt;/code&gt; is used for that purpose. New upstream updates will be fetched into &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;remote-tracking branches&lt;/a&gt; named origin/name-of-upstream-branch, which you can see using &lt;code&gt;git branch -r&lt;/code&gt;.</source>
          <target state="translated">기본 업스트림 &lt;a href=&quot;#def_repository&quot;&gt;저장소&lt;/a&gt; . 대부분의 프로젝트에는 추적 할 하나 이상의 업스트림 프로젝트가 있습니다. 기본적으로 해당 용도로 &lt;code&gt;origin&lt;/code&gt; 이 사용됩니다. 새로운 업스트림 업데이트는 origin / name-of-upstream-branch라는 &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;원격 추적 분기&lt;/a&gt; 로 가져 &lt;code&gt;git branch -r&lt;/code&gt; 사용하여 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66087a54aa582dff2f539d6f92ec2461ac3012fd" translate="yes" xml:space="preserve">
          <source>The default value for --window is 10 and --depth is 50. The maximum depth is 4095.</source>
          <target state="translated">--window의 기본값은 10이고 --depth는 50입니다. 최대 깊이는 4095입니다.</target>
        </trans-unit>
        <trans-unit id="90d3816cdd271ff4f563d74700f0c34c9ae7702c" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;$projectroot&lt;/code&gt; is &lt;code&gt;/pub/git&lt;/code&gt;. You can change it during building gitweb via &lt;code&gt;GITWEB_PROJECTROOT&lt;/code&gt; build configuration variable.</source>
          <target state="translated">&lt;code&gt;$projectroot&lt;/code&gt; 의 기본값 은 &lt;code&gt;/pub/git&lt;/code&gt; 입니다. &lt;code&gt;GITWEB_PROJECTROOT&lt;/code&gt; 빌드 구성 변수 를 통해 gitweb을 빌드 하는 동안이를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78bcbc1a976cbafa1db494161487aec966c7436d" translate="yes" xml:space="preserve">
          <source>The default value is either &lt;code&gt;static/gitweb.js&lt;/code&gt;, or &lt;code&gt;static/gitweb.min.js&lt;/code&gt; if the &lt;code&gt;JSMIN&lt;/code&gt; build variable was defined, i.e. if JavaScript minifier was used at build time. &lt;strong&gt;Note&lt;/strong&gt; that this single file is generated from multiple individual JavaScript &quot;modules&quot;.</source>
          <target state="translated">&lt;code&gt;JSMIN&lt;/code&gt; 빌드 변수가 정의 된 경우 (예 : 빌드시 JavaScript minifier가 사용 된 경우) 기본값은 &lt;code&gt;static/gitweb.js&lt;/code&gt; 또는 &lt;code&gt;static/gitweb.min.js&lt;/code&gt; 입니다. &lt;strong&gt;참고&lt;/strong&gt; 이 하나의 파일이 여러 개인 자바 스크립트 &quot;모듈&quot;에서 생성됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="88fcf9aad2af8490af6dabfabbb5732019a6c8e1" translate="yes" xml:space="preserve">
          <source>The default value of this variable is determined by the &lt;code&gt;GITWEB_LIST&lt;/code&gt; makefile variable at installation time. If this variable is empty, gitweb will fall back to scanning the &lt;code&gt;$projectroot&lt;/code&gt; directory for repositories.</source>
          <target state="translated">이 변수의 기본값 은 설치시 &lt;code&gt;GITWEB_LIST&lt;/code&gt; makefile 변수에 의해 결정됩니다 . 이 변수가 비어 있으면 gitweb은 &lt;code&gt;$projectroot&lt;/code&gt; 디렉토리에서 리포지토리 를 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="da622b41696b803144c5254aad9443c84211d515" translate="yes" xml:space="preserve">
          <source>The default value of this variable is determined by the build-time configuration variable &lt;code&gt;GITWEB_PROJECT_MAXDEPTH&lt;/code&gt;, which defaults to 2007.</source>
          <target state="translated">이 변수의 기본값은 빌드 시간 구성 변수 &lt;code&gt;GITWEB_PROJECT_MAXDEPTH&lt;/code&gt; 에 의해 결정되며 기본값은 2007입니다.</target>
        </trans-unit>
        <trans-unit id="777a0a86855d35a436d0a0e990f3b787a636cb43" translate="yes" xml:space="preserve">
          <source>The defined extensions are:</source>
          <target state="translated">정의 된 확장자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2309a4e043845fb6e7e786e69af3d5ed57221f3f" translate="yes" xml:space="preserve">
          <source>The definition of a diff driver is done in &lt;code&gt;gitconfig&lt;/code&gt;, not &lt;code&gt;gitattributes&lt;/code&gt; file, so strictly speaking this manual page is a wrong place to talk about it. However&amp;hellip;​</source>
          <target state="translated">diff 드라이버의 정의는 &lt;code&gt;gitattributes&lt;/code&gt; 파일이 아닌 &lt;code&gt;gitconfig&lt;/code&gt; 에서 수행 되므로이 매뉴얼 페이지를 엄격하게 말하면 잘못된 위치입니다. 그러나&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="05fbc211f0bbdc85a5cbba915fe02006f8119e9e" translate="yes" xml:space="preserve">
          <source>The definition of a merge driver is done in the &lt;code&gt;.git/config&lt;/code&gt; file, not in the &lt;code&gt;gitattributes&lt;/code&gt; file, so strictly speaking this manual page is a wrong place to talk about it. However&amp;hellip;​</source>
          <target state="translated">병합 드라이버의 정의는 &lt;code&gt;gitattributes&lt;/code&gt; 파일이 아닌 &lt;code&gt;.git/config&lt;/code&gt; 파일에서 수행 되므로이 매뉴얼 페이지를 엄격하게 말하면 잘못된 위치입니다. 그러나&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="096c7fcd9c9053c9edd8c72ca9c95b04e65c3409" translate="yes" xml:space="preserve">
          <source>The deletion removes the superproject&amp;rsquo;s tracking data, which are both the &lt;code&gt;gitlink&lt;/code&gt; entry and the section in the &lt;code&gt;.gitmodules&lt;/code&gt; file. The submodule&amp;rsquo;s working directory is removed from the file system, but the Git directory is kept around as it to make it possible to checkout past commits without requiring fetching from another repository.</source>
          <target state="translated">삭제하면 &lt;code&gt;gitlink&lt;/code&gt; 항목과 &lt;code&gt;.gitmodules&lt;/code&gt; 파일 의 섹션 인 수퍼 프로젝트의 추적 데이터가 제거 됩니다. 서브 모듈의 작업 디렉토리는 파일 시스템에서 제거되지만 Git 디렉토리는 다른 저장소에서 가져 오지 않고도 과거의 커밋을 체크 아웃 할 수 있도록 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="c4fe2a741691af413a8b078592b8e6a937844e84" translate="yes" xml:space="preserve">
          <source>The delta data is a sequence of instructions to reconstruct an object from the base object. If the base object is deltified, it must be converted to canonical form first. Each instruction appends more and more data to the target object until it&amp;rsquo;s complete. There are two supported instructions so far: one for copy a byte range from the source object and one for inserting new data embedded in the instruction itself.</source>
          <target state="translated">델타 데이터는 기본 객체에서 객체를 재구성하기위한 일련의 명령어입니다. 기본 개체가 deltified이면 먼저 정식 형식으로 변환해야합니다. 각 명령어는 완료 될 때까지 대상 객체에 더 많은 데이터를 추가합니다. 지금까지 지원되는 명령어는 소스 객체에서 바이트 범위를 복사하는 명령어와 명령어 자체에 포함 된 새 데이터를 삽입하는 명령어입니다.</target>
        </trans-unit>
        <trans-unit id="892bc72de2972bd5305c51b8962327a3cfb2518f" translate="yes" xml:space="preserve">
          <source>The depth parameter used in the delta compression algorithm used by &lt;code&gt;git gc --aggressive&lt;/code&gt;. This defaults to 50, which is the default for the &lt;code&gt;--depth&lt;/code&gt; option when &lt;code&gt;--aggressive&lt;/code&gt; isn&amp;rsquo;t in use.</source>
          <target state="translated">&lt;code&gt;git gc --aggressive&lt;/code&gt; 가 사용하는 델타 압축 알고리즘에 사용되는 깊이 매개 변수 입니다. 기본값은 50으로, &lt;code&gt;--aggressive&lt;/code&gt; 를 사용하지 않는 경우 &lt;code&gt;--depth&lt;/code&gt; 옵션 의 기본값입니다 .</target>
        </trans-unit>
        <trans-unit id="71588492154c20723b86643e523c1d2b33771cc9" translate="yes" xml:space="preserve">
          <source>The design of fast-import allows it to import large projects in a minimum amount of memory usage and processing time. Assuming the frontend is able to keep up with fast-import and feed it a constant stream of data, import times for projects holding 10+ years of history and containing 100,000+ individual commits are generally completed in just 1-2 hours on quite modest (~$2,000 USD) hardware.</source>
          <target state="translated">빠른 가져 오기의 설계를 통해 최소한의 메모리 사용 및 처리 시간으로 대규모 프로젝트를 가져올 수 있습니다. 프론트 엔드가 빠른 가져 오기를 유지하고 일정한 데이터 스트림을 제공 할 수 있다고 가정하면 10 년 이상의 역사를 유지하고 100,000 개 이상의 개별 커밋을 포함하는 프로젝트의 가져 오기 시간은 일반적으로 아주 완만 한 1-2 시간 안에 완료됩니다 ( ~ $ 2,000 USD) 하드웨어.</target>
        </trans-unit>
        <trans-unit id="cfd00b61765196c337cd6805a450f0ea641f8da0" translate="yes" xml:space="preserve">
          <source>The details of the credential will be provided on the helper&amp;rsquo;s stdin stream. The exact format is the same as the input/output format of the &lt;code&gt;git credential&lt;/code&gt; plumbing command (see the section &lt;code&gt;INPUT/OUTPUT
FORMAT&lt;/code&gt; in &lt;a href=&quot;git-credential&quot;&gt;git-credential[1]&lt;/a&gt; for a detailed specification).</source>
          <target state="translated">The details of the credential will be provided on the helper&amp;rsquo;s stdin stream. The exact format is the same as the input/output format of the &lt;code&gt;git credential&lt;/code&gt; plumbing command (see the section &lt;code&gt;INPUT/OUTPUT FORMAT&lt;/code&gt; in &lt;a href=&quot;git-credential&quot;&gt;git-credential[1]&lt;/a&gt; for a detailed specification).</target>
        </trans-unit>
        <trans-unit id="c420d947d2d5939e423cde725977f1dbb1cf946b" translate="yes" xml:space="preserve">
          <source>The developer might want to rebase those commits to a newer &lt;code&gt;master&lt;/code&gt; while keeping the branch topology, for example when the first topic branch is expected to be integrated into &lt;code&gt;master&lt;/code&gt; much earlier than the second one, say, to resolve merge conflicts with changes to the DownloadButton class that made it into &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">개발자는 새에 그 커밋을 리베이스 할 수 있습니다 &lt;code&gt;master&lt;/code&gt; 첫 번째 주제 분기가 통합 될 것으로 예상되는 경우, 예를 들어, 분기 토폴로지를 유지하면서 &lt;code&gt;master&lt;/code&gt; 훨씬 이전에 두 번째, 말보다 DownloadButton 변경으로 해결 병합 충돌, 그것을 &lt;code&gt;master&lt;/code&gt; 로 만든 클래스 .</target>
        </trans-unit>
        <trans-unit id="38adb1a4eb1052b4c27e8f4f4a52ae35ba0619ad" translate="yes" xml:space="preserve">
          <source>The diff above shows the differences between the working-tree version of file.txt and the stage 2 and stage 3 versions. So instead of preceding each line by a single &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;, it now uses two columns: the first column is used for differences between the first parent and the working directory copy, and the second for differences between the second parent and the working directory copy. (See the &quot;COMBINED DIFF FORMAT&quot; section of &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files[1]&lt;/a&gt; for a details of the format.)</source>
          <target state="translated">위의 diff는 file.txt의 작업 트리 버전과 2 단계 및 3 단계 버전의 차이점을 보여줍니다. 따라서 각 행 앞에 단일 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 를 사용 하는 대신 이제 두 개의 열을 사용합니다. 첫 번째 열은 첫 번째 상위와 작업 디렉토리 사본의 차이점에 사용되고 두 번째 열은 두 번째 상위와 작업 디렉토리 사본의 차이점에 사용됩니다. . 형식 에 대한 자세한 내용은 &lt;a href=&quot;git-diff-files&quot;&gt;git-diff-files [1]&lt;/a&gt; 의 &quot;COMBINED DIFF FORMAT&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="330f16adb7b4cb162abae538c3471400c6f3dfa4" translate="yes" xml:space="preserve">
          <source>The diff commands &lt;code&gt;git diff-index&lt;/code&gt;, &lt;code&gt;git diff-files&lt;/code&gt;, and &lt;code&gt;git diff-tree&lt;/code&gt; can be told to manipulate differences they find in unconventional ways before showing &lt;code&gt;diff&lt;/code&gt; output. The manipulation is collectively called &quot;diffcore transformation&quot;. This short note describes what they are and how to use them to produce &lt;code&gt;diff&lt;/code&gt; output that is easier to understand than the conventional kind.</source>
          <target state="translated">diff 명령 &lt;code&gt;git diff-index&lt;/code&gt; , &lt;code&gt;git diff-files&lt;/code&gt; 및 &lt;code&gt;git diff-tree&lt;/code&gt; 는 &lt;code&gt;diff&lt;/code&gt; 출력을 표시하기 전에 기존 방식으로 발견 된 차이를 조작하도록 지시 할 수 있습니다 . 조작을 통칭하여 &quot;diffcore 변환&quot;이라고합니다. 이 짧은 노트 는 기존의 것보다 이해하기 쉬운 &lt;code&gt;diff&lt;/code&gt; 출력 을 생성하기 위해 그것들이 무엇인지 그리고 어떻게 사용하는지 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="4e50a3e21215031cd44c450ab91735643c2d6198" translate="yes" xml:space="preserve">
          <source>The diffcore mechanism is fed a list of such comparison results (each of which is called &quot;filepair&quot;, although at this point each of them talks about a single file), and transforms such a list into another list. There are currently 5 such transformations:</source>
          <target state="translated">diffcore 메커니즘에는 이러한 비교 결과 목록이 제공되며 (각각 &quot;단일 파일에 대해 말하지만&quot;파일 쌍 &quot;이라고 함) 이러한 목록을 다른 목록으로 변환합니다. 현재 5 가지의 그러한 변환이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5ccc68add0025f283e287a514f59373a91910067" translate="yes" xml:space="preserve">
          <source>The directory holding the sha1 objects is missing.</source>
          <target state="translated">sha1 오브젝트를 보유한 디렉토리가 누락되었습니다.</target>
        </trans-unit>
        <trans-unit id="3e56ce3070b6d1fe8bc11b5262f83540c8411c39" translate="yes" xml:space="preserve">
          <source>The directory to find the quilt patches.</source>
          <target state="translated">퀼트 패치를 찾을 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="238b3f49c4473bd1c995d19f9ef691e0ca16752f" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is to use a credential helper via the &lt;code&gt;credential.helper&lt;/code&gt; configuration. Most systems provide a standard choice to integrate with the system credential manager. For example, Git for Windows provides the &lt;code&gt;wincred&lt;/code&gt; credential manager, macOS has the &lt;code&gt;osxkeychain&lt;/code&gt; credential manager, and Unix systems with a standard desktop environment can use the &lt;code&gt;libsecret&lt;/code&gt; credential manager. All of these store credentials in an encrypted store to keep your passwords or tokens secure.</source>
          <target state="translated">가장 쉬운 방법은 &lt;code&gt;credential.helper&lt;/code&gt; 구성을 통해 자격 증명 도우미를 사용하는 것 입니다. 대부분의 시스템은 시스템 자격 증명 관리자와 통합하기위한 표준 선택을 제공합니다. 예를 들어 Git for Windows는 &lt;code&gt;wincred&lt;/code&gt; 자격 증명 관리자를 제공하고 macOS에는 &lt;code&gt;osxkeychain&lt;/code&gt; 자격 증명 관리자가 있으며 표준 데스크톱 환경이있는 Unix 시스템은 &lt;code&gt;libsecret&lt;/code&gt; 자격 증명 관리자를 사용할 수 있습니다 . 이러한 모든 저장소 자격 증명은 암호화 된 저장소에 저장되어 암호 또는 토큰을 안전하게 유지합니다.</target>
        </trans-unit>
        <trans-unit id="0bb0f16c4fefb50922eb2b1990a8580cecff19f2" translate="yes" xml:space="preserve">
          <source>The easiest way to do this is with:</source>
          <target state="translated">가장 쉬운 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="114ebd710b84299f5cb327f93e8be01e979eae23" translate="yes" xml:space="preserve">
          <source>The easy case</source>
          <target state="translated">쉬운 경우</target>
        </trans-unit>
        <trans-unit id="ae6685a0ed898fdf61a802d261028cc9079a0958" translate="yes" xml:space="preserve">
          <source>The editor used to edit the commit log message will be chosen from the &lt;code&gt;GIT_EDITOR&lt;/code&gt; environment variable, the core.editor configuration variable, the &lt;code&gt;VISUAL&lt;/code&gt; environment variable, or the &lt;code&gt;EDITOR&lt;/code&gt; environment variable (in that order). See &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt; for details.</source>
          <target state="translated">커밋 로그 메시지를 편집하는 데 사용되는 편집기는 &lt;code&gt;GIT_EDITOR&lt;/code&gt; 환경 변수, core.editor 구성 변수, &lt;code&gt;VISUAL&lt;/code&gt; 환경 변수 또는 &lt;code&gt;EDITOR&lt;/code&gt; 환경 변수 (순서대로)에서 선택됩니다. 자세한 내용은 &lt;a href=&quot;git-var&quot;&gt;git-var [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0e4dbd523803a96213d55b1fc234d8888f00a89f" translate="yes" xml:space="preserve">
          <source>The effect of the &lt;code&gt;git add&lt;/code&gt; was to add one entry to the index file:</source>
          <target state="translated">&lt;code&gt;git add&lt;/code&gt; 의 효과 는 인덱스 파일에 하나의 항목을 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8c668b981ec948c02063906a293d8a4332dec951" translate="yes" xml:space="preserve">
          <source>The effect of this is best shown by way of comparing to &lt;code&gt;--full-history&lt;/code&gt; with parent rewriting. The example turns into:</source>
          <target state="translated">이것의 효과는 부모 재 작성과 &lt;code&gt;--full-history&lt;/code&gt; 와 비교하여 가장 잘 나타납니다 . 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f01b79da1b24a8459870505ceabc7acd5dc253cb" translate="yes" xml:space="preserve">
          <source>The effective value of &quot;core.notesRef&quot; (possibly overridden by GIT_NOTES_REF) is also implicitly added to the list of refs to be displayed.</source>
          <target state="translated">&quot;core.notesRef&quot;의 유효 값 (GIT_NOTES_REF로 재정의 됨)도 표시 될 참조 목록에 내재적으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="47170c140110158e7cecc3842f11a773c4cf2ae7" translate="yes" xml:space="preserve">
          <source>The effects of this are mostly persistent, e.g. when packs and loose objects are coalesced into one another pack the existing deltas in that pack might get re-used, but there are also various cases where we might pick a sub-optimal delta from a newer pack instead.</source>
          <target state="translated">팩과 느슨한 객체가 서로 다른 팩으로 병합 될 때, 그 팩의 기존 델타가 재사용 될 수 있지만, 새로운 팩터에서 차선의 델타를 선택할 수있는 경우도 있습니다. 대신 팩.</target>
        </trans-unit>
        <trans-unit id="bf28d97f6ba9304b5153752f84c8628b03d2d10b" translate="yes" xml:space="preserve">
          <source>The email address used in the author and committer identities if no other relevant environment variable or configuration setting has been set.</source>
          <target state="translated">The email address used in the author and committer identities if no other relevant environment variable or configuration setting has been set.</target>
        </trans-unit>
        <trans-unit id="92e306fa99dcf31c1372828d693f49a0c8b3dc6a" translate="yes" xml:space="preserve">
          <source>The email address used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.email&lt;/code&gt; and &lt;code&gt;author.email&lt;/code&gt; configuration settings.</source>
          <target state="translated">The email address used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.email&lt;/code&gt; and &lt;code&gt;author.email&lt;/code&gt; configuration settings.</target>
        </trans-unit>
        <trans-unit id="7e46e2a5bb8fdd59d614c9b7aa9560522ab90daa" translate="yes" xml:space="preserve">
          <source>The email address used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.email&lt;/code&gt; and &lt;code&gt;committer.email&lt;/code&gt; configuration settings.</source>
          <target state="translated">The email address used in the author identity when creating commit or tag objects, or when writing reflogs. Overrides the &lt;code&gt;user.email&lt;/code&gt; and &lt;code&gt;committer.email&lt;/code&gt; configuration settings.</target>
        </trans-unit>
        <trans-unit id="e05ce4cdee1f111bdf6e1a5c14e6220d9920c4e2" translate="yes" xml:space="preserve">
          <source>The equivalence test is based on the diff, after removing whitespace and line numbers. git-cherry therefore detects when commits have been &quot;copied&quot; by means of &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick[1]&lt;/a&gt;, &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; or &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">동등성 테스트는 공백과 줄 번호를 제거한 후 diff를 기준으로합니다. git-cherry는 커밋이 &lt;a href=&quot;git-cherry-pick&quot;&gt;git-cherry-pick [1]&lt;/a&gt; , &lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]에&lt;/a&gt; 의해 &quot;복사&quot;된시기를 감지 합니다.</target>
        </trans-unit>
        <trans-unit id="1c5c570f3616a5224dd6e91327ceb211453e9ddc" translate="yes" xml:space="preserve">
          <source>The error event may be emitted more than once. The format string allows post-processors to group errors by type without worrying about specific error arguments.</source>
          <target state="translated">오류 이벤트가 두 번 이상 발생할 수 있습니다. 형식 문자열을 사용하면 포스트 프로세서가 특정 오류 인수에 대한 걱정없이 유형별로 오류를 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c5c3dbbaebe5825bdfa9c22deed2d10f337e86e" translate="yes" xml:space="preserve">
          <source>The event format target is a JSON-based format of event data suitable for telemetry analysis. This format is enabled with the &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; environment variable or the &lt;code&gt;trace2.eventTarget&lt;/code&gt; system or global config setting.</source>
          <target state="translated">이벤트 형식 대상은 원격 분석에 적합한 JSON 기반의 이벤트 데이터 형식입니다. 이 형식은 &lt;code&gt;GIT_TRACE2_EVENT&lt;/code&gt; 환경 변수 또는 &lt;code&gt;trace2.eventTarget&lt;/code&gt; 시스템 또는 글로벌 구성 설정으로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="bb53cc945a6f48ddfeb31dcd9983e9640d488cf9" translate="yes" xml:space="preserve">
          <source>The ever-versatile &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; command can also be used to examine tree objects, but &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt; will give you more details:</source>
          <target state="translated">다양한 기능을 갖춘 &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 명령을 사용하여 트리 객체를 검사 할 수도 있지만 &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]&lt;/a&gt; 은 다음과 같은 세부 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2cae5c144ae6a6f552f7dcee7bbaf0209258a3bd" translate="yes" xml:space="preserve">
          <source>The example configuration presented here is guaranteed to be backwards and forward compatible.</source>
          <target state="translated">여기에 제시된 예제 구성은 이전 버전과 이전 버전과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="a825d1fa42cf64b4befab7c11786e411935cba6b" translate="yes" xml:space="preserve">
          <source>The examples in this FAQ assume a standard POSIX shell, like &lt;code&gt;bash&lt;/code&gt; or &lt;code&gt;dash&lt;/code&gt;, and a user, A U Thor, who has the account &lt;code&gt;author&lt;/code&gt; on the hosting provider &lt;code&gt;git.example.org&lt;/code&gt;.</source>
          <target state="translated">이 FAQ의 예제는 &lt;code&gt;bash&lt;/code&gt; 또는 &lt;code&gt;dash&lt;/code&gt; 와 같은 표준 POSIX 셸 과 호스팅 제공 업체 &lt;code&gt;git.example.org&lt;/code&gt; 에 계정 &lt;code&gt;author&lt;/code&gt; 가있는 사용자 AU Thor를 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="77578078110fe9093d1036dd58aeebc2db7df1b8" translate="yes" xml:space="preserve">
          <source>The exit code from this hook invocation is ignored, however a non-zero exit code will generate an error message.</source>
          <target state="translated">이 후크 호출의 종료 코드는 무시되지만 0이 아닌 종료 코드는 오류 메시지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1e405cb397afa437170eea29059b03dcf97426f6" translate="yes" xml:space="preserve">
          <source>The exit code from this hook invocation is ignored; the only thing left for &lt;code&gt;git-receive-pack&lt;/code&gt; to do at that point is to exit itself anyway.</source>
          <target state="translated">이 후크 호출의 종료 코드는 무시됩니다. &lt;code&gt;git-receive-pack&lt;/code&gt; 이 그 시점에서해야 할 유일한 일은 어쨌든 자체를 종료하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5a81c04e486b5c66b0be7554a6e91773cfd1a9a9" translate="yes" xml:space="preserve">
          <source>The exit status determines whether git will use the data from the hook to limit its search. On error, it will fall back to verifying all files and folders.</source>
          <target state="translated">종료 상태는 git이 후크의 데이터를 사용하여 검색을 제한할지 여부를 결정합니다. 오류가 발생하면 모든 파일 및 폴더 확인으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="bfebe1cb22dde824ad5950ca41e165ed720dc31c" translate="yes" xml:space="preserve">
          <source>The exit status of the hook is ignored for any state except for the &quot;prepared&quot; state. In the &quot;prepared&quot; state, a non-zero exit status will cause the transaction to be aborted. The hook will not be called with &quot;aborted&quot; state in that case.</source>
          <target state="translated">The exit status of the hook is ignored for any state except for the &quot;prepared&quot; state. In the &quot;prepared&quot; state, a non-zero exit status will cause the transaction to be aborted. The hook will not be called with &quot;aborted&quot; state in that case.</target>
        </trans-unit>
        <trans-unit id="863cf74b97781c15eaa4bf39c81be105821817bd" translate="yes" xml:space="preserve">
          <source>The exit value of this program is negative on error, and the number of conflicts otherwise (truncated to 127 if there are more than that many conflicts). If the merge was clean, the exit value is 0.</source>
          <target state="translated">오류가 발생하면이 프로그램의 종료 값이 음수이고, 그렇지 않으면 충돌 수가 발생합니다 (충돌이 많은 경우 127로 잘림). 병합이 깨끗하면 종료 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="600e0ed5040d09634bf101b6adc431e3349d2258" translate="yes" xml:space="preserve">
          <source>The expected use case of this is to write supporting explanation for the commit that does not belong to the commit log message proper, and include it with the patch submission. While one can simply write these explanations after &lt;code&gt;format-patch&lt;/code&gt; has run but before sending, keeping them as Git notes allows them to be maintained between versions of the patch series (but see the discussion of the &lt;code&gt;notes.rewrite&lt;/code&gt; configuration options in &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt; to use this workflow).</source>
          <target state="translated">예상되는 사용 사례는 커밋 로그 메시지에 속하지 않은 커밋에 대한 지원 설명을 작성하고 패치 제출에 포함시키는 것입니다. &lt;code&gt;format-patch&lt;/code&gt; 를 실행 한 후 , 보내기 전에 이러한 설명을 간단하게 작성할 수 있지만, Git 메모를 유지하면 패치 시리즈 버전간에 유지 관리 할 수 ​​있습니다 (하지만 &lt;code&gt;notes.rewrite&lt;/code&gt; 구성 옵션에 대한 설명은 &lt;a href=&quot;git-notes&quot;&gt;git-notes [ 1]&lt;/a&gt; 이 워크 플로를 사용합니다).</target>
        </trans-unit>
        <trans-unit id="7c7921a0c6ea4cec42a427f589011997d35e15f9" translate="yes" xml:space="preserve">
          <source>The external command can optionally write a single line to its standard output to be sent to the requestor as an error message when it declines the service.</source>
          <target state="translated">외부 명령은 선택적으로 서비스를 거부 할 때 요청자에게 오류 메시지로 전송되도록 단일 출력을 표준 출력에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34c4f9db557882c9df4177a31e00a543de8934c9" translate="yes" xml:space="preserve">
          <source>The extra &lt;code&gt;NUL&lt;/code&gt; before the preimage path in renamed case is to allow scripts that read the output to tell if the current record being read is a single-path record or a rename/copy record without reading ahead. After reading added and deleted lines, reading up to &lt;code&gt;NUL&lt;/code&gt; would yield the pathname, but if that is &lt;code&gt;NUL&lt;/code&gt;, the record will show two paths.</source>
          <target state="translated">이름이 바뀐 경우 사전 이미지 경로 앞 의 추가 &lt;code&gt;NUL&lt;/code&gt; 은 출력을 읽는 스크립트가 현재 읽고있는 레코드가 단일 경로 레코드인지 또는 미리 읽지 않고 이름 바꾸기 / 복사 레코드인지를 알리는 것입니다. 추가 및 삭제 된 행을 읽은 후 &lt;code&gt;NUL&lt;/code&gt; 까지 읽으면 경로 이름이 생성되지만 &lt;code&gt;NUL&lt;/code&gt; 인 경우 레코드에 두 개의 경로가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1b54438722ed3844a0702f9ed09c56d6aef28ee2" translate="yes" xml:space="preserve">
          <source>The fast-import backend itself can import into an empty repository (one that has already been initialized by &lt;code&gt;git init&lt;/code&gt;) or incrementally update an existing populated repository. Whether or not incremental imports are supported from a particular foreign source depends on the frontend program in use.</source>
          <target state="translated">빠른 가져 오기 백엔드 자체는 비어있는 저장소 ( &lt;code&gt;git init&lt;/code&gt; 로 이미 초기화 된 저장소 )로 가져 오거나 기존의 채워진 저장소를 증분 업데이트 할 수 있습니다. 특정 외부 소스에서 증분 가져 오기를 지원하는지 여부는 사용중인 프론트 엔드 프로그램에 따라 다릅니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
