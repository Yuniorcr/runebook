<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="0fd6fc8780530397776c0cf559158e39eae45ebc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%e&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%e&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d208e73c219f2a298b483dd445a8f8be92b61514" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%f&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%f&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e96bcf2b717882aabe1fe5b69eb3986c489d2f7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%gD&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%gD&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7e15967b6c4666115c7ba72d77caca8e7fa57fe4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%gE&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%gE&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="66683808f295955e554e9106cb002100a80ce95f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%gN&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%gN&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2ec91c9364e05c861d7f50c6c986259f5074f50b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%gd&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%gd&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="87858a985253d9ad4b06f968f875cac0b8c808d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%ge&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%ge&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="811ecb17dad8e445289f8e7592e5c057af87a7a5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%gn&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%gn&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="21864b2d89934a256a942cff7b98f2084be5fae0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%gs&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%gs&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dc8fee0497dd508d7115654102964957a3ac91bf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%h&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%h&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ca198b3dcbb1a33a7469fe36d7d37c1fc4acca6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%m&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%m&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="391f81332693d8589e68f4d4c914387c4b09417a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%n&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%n&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="12128aa5c18831df537f79d120dcf453a3a82256" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%p&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%p&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1950e93b86335b0feb046f066edd6e1e1b613ee1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%s&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%s&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09784658ff8e2ded38c766050508d5defbcfb302" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%t&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%t&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="db93689bd2c4086a1a76799710a8caa1e5e633db" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%w([&amp;lt;w&amp;gt;[,&amp;lt;i1&amp;gt;[,&amp;lt;i2&amp;gt;]]])&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%w([&amp;lt;w&amp;gt;[,&amp;lt;i1&amp;gt;[,&amp;lt;i2&amp;gt;]]])&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c890ad8994a324ca9385b760f55473a9e56bb29e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;%x00&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;%x00&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="32612fbb9a38d2ef016dbcf8dfa00aa9d1f92a54" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;describeOutput&amp;gt;&lt;/em&gt;, e.g. &lt;em&gt;v1.7.4.2-679-g3bee7fb&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;describeOutput&amp;gt;&lt;/em&gt; , 예 : &lt;em&gt;v1.7.4.2-679-g3bee7fb&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a8bd55b9b4c0b3e70f528a0b5d43e8149074d66f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;refname&amp;gt;&lt;/em&gt;, e.g. &lt;em&gt;master&lt;/em&gt;, &lt;em&gt;heads/master&lt;/em&gt;, &lt;em&gt;refs/heads/master&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;refname&amp;gt;&lt;/em&gt; , 예 : &lt;em&gt;master&lt;/em&gt; , &lt;em&gt;heads / master&lt;/em&gt; , &lt;em&gt;refs / heads / master&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f3a741e156a801b10a13dd720cc4c28610da2e23" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;refname&amp;gt;@{&amp;lt;n&amp;gt;}&lt;/em&gt;, e.g. &lt;em&gt;master@{1}&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;refname&amp;gt; @ {&amp;lt;n&amp;gt;}&lt;/em&gt; , 예 : &lt;em&gt;master @ {1}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5447b4106b2fc5b9503369d6ffeff019de63d322" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;:&amp;lt;path&amp;gt;&lt;/em&gt;, e.g. &lt;em&gt;HEAD:README&lt;/em&gt;, &lt;em&gt;master:./README&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt; : &amp;lt;path&amp;gt;&lt;/em&gt; , 예 : &lt;em&gt;HEAD : README&lt;/em&gt; , &lt;em&gt;master : ./ README&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1a95fdbc4b52aba363140cdf760b8b7b31fd659e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c4c4d99491bc88cd96a215c0d7870e6b9247fbb8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;^!&lt;/em&gt;, e.g. &lt;em&gt;HEAD^!&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt; ^! &lt;/em&gt;예 : &lt;em&gt;HEAD ^!&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d88a75edc6dde79893a34f055b129b4fce3f9c95" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;^-&amp;lt;n&amp;gt;&lt;/em&gt;, e.g. &lt;em&gt;HEAD^-, HEAD^-2&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt; ^-&amp;lt;n&amp;gt;&lt;/em&gt; , 예 : &lt;em&gt;HEAD ^-, HEAD ^ -2&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd6b4f3754d927108daf1980f82d26e72059bad7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;^@&lt;/em&gt;, e.g. &lt;em&gt;HEAD^@&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt; ^ @&lt;/em&gt; , 예 : &lt;em&gt;HEAD ^ @&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="24af80679bf977e641a791d973d768cd824252cf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;^[&amp;lt;n&amp;gt;]&lt;/em&gt;, e.g. &lt;em&gt;HEAD^, v1.5.1^0&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt; ^ [&amp;lt;n&amp;gt;]&lt;/em&gt; , 예 : &lt;em&gt;HEAD ^, v1.5.1 ^ 0&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="41dcbb8437aef9023684ce8c5c99f7accf930e7b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;^{&amp;lt;type&amp;gt;}&lt;/em&gt;, e.g. &lt;em&gt;v0.99.8^{commit}&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt; ^ {&amp;lt;type&amp;gt;}&lt;/em&gt; , 예 : &lt;em&gt;v0.99.8 ^ {commit}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4f8c067bc9fae03ed7be61bf2de69f79b4f23892" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;^{/&amp;lt;text&amp;gt;}&lt;/em&gt;, e.g. &lt;em&gt;HEAD^{/fix nasty bug}&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt; ^ {/ &amp;lt;text&amp;gt;}&lt;/em&gt; , 예 : &lt;em&gt;HEAD ^ {/ fix nasty bug}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="38cc5071aeb99a9118ca376f1944b38b66cac00e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;^{}&lt;/em&gt;, e.g. &lt;em&gt;v0.99.8^{}&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt; ^ {}&lt;/em&gt; , 예 : &lt;em&gt;v0.99.8 ^ {}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7e4d4df7091670340f697e194f19a68188eb74ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev&amp;gt;~[&amp;lt;n&amp;gt;]&lt;/em&gt;, e.g. &lt;em&gt;HEAD~, master~3&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev&amp;gt; ~ [&amp;lt;n&amp;gt;]&lt;/em&gt; , 예 : &lt;em&gt;HEAD ~, master ~ 3&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9df87b98598343ae206414b84b7ba21a719e6945" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev1&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev1&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="217c859144416ad739418e62347b5d523ccbaf25" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;rev1&amp;gt;...&amp;lt;rev2&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;rev1&amp;gt;...&amp;lt;rev2&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0fa5ceec7cd768a74031e2043be9619bd700f8d1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&amp;lt;sha1&amp;gt;&lt;/em&gt;, e.g. &lt;em&gt;dae86e1950b1277e545cee180551750029cfe735&lt;/em&gt;, &lt;em&gt;dae86e&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&amp;lt;sha1&amp;gt;&lt;/em&gt; , 예 : &lt;em&gt;dae86e1950b1277e545cee180551750029cfe735&lt;/em&gt; , &lt;em&gt;dae86e&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f65a058f32edc962d6bcb22998fdc1ddb656915a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;0xxx&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;0xxx&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="07710133768558b61a0c7e37c9c07783b0c0af3e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;:/&amp;lt;text&amp;gt;&lt;/em&gt;, e.g. &lt;em&gt;:/fix nasty bug&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;: / &amp;lt;text&amp;gt;&lt;/em&gt; , 예 &lt;em&gt;: : / fix 험악한 버그&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1c533bd4b9eb4cd60c235b4af7122202bc2dff3f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;:[&amp;lt;n&amp;gt;:]&amp;lt;path&amp;gt;&lt;/em&gt;, e.g. &lt;em&gt;:0:README&lt;/em&gt;, &lt;em&gt;:README&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;: [&amp;lt;n&amp;gt; :] &amp;lt;경로&amp;gt;&lt;/em&gt; 예 &lt;em&gt;: : 0 : README&lt;/em&gt; , &lt;em&gt;: README&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="86cfb2993d0ee4862b6d30e20fc03af834fab9da" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;@&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;@&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b5592cce6d8e5854157f5b37be8b8a1e6af0379b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;@{&amp;lt;n&amp;gt;}&lt;/em&gt;, e.g. &lt;em&gt;@{1}&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;@ {&amp;lt;n&amp;gt;}&lt;/em&gt; , 예 : &lt;em&gt;@ {1}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="728371c67640f54e1e6e290952fb2e8d9066787a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;@{-&amp;lt;n&amp;gt;}&lt;/em&gt;, e.g. &lt;em&gt;@{-1}&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;@ {-&amp;lt;n&amp;gt;}&lt;/em&gt; , 예 : &lt;em&gt;@ {-1}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf6a4bb1a502cdd1a279d16a904af761503de4dd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;EMAIL&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;EMAIL&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="247da2407e255bdcc6d3712952ca60e956baecb3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;[&amp;lt;branchname&amp;gt;]@{push}&lt;/em&gt;, e.g. &lt;em&gt;master@{push}&lt;/em&gt;, &lt;em&gt;@{push}&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;[&amp;lt;branchname&amp;gt;] @ {push}&lt;/em&gt; , 예 : &lt;em&gt;master @ {push}&lt;/em&gt; , &lt;em&gt;@ {push}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="26594d935b9f7e632538381b6fe05c6a1687068d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;[&amp;lt;branchname&amp;gt;]@{upstream}&lt;/em&gt;, e.g. &lt;em&gt;master@{upstream}&lt;/em&gt;, &lt;em&gt;@{u}&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;[&amp;lt;branchname&amp;gt;] @ {upstream}&lt;/em&gt; , 예 : &lt;em&gt;master @ {upstream}&lt;/em&gt; , &lt;em&gt;@ {u}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ab93d7ba46a986eb7c3e1438226dabd9ac82e9fe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;[&amp;lt;refname&amp;gt;]@{&amp;lt;date&amp;gt;}&lt;/em&gt;, e.g. &lt;em&gt;master@{yesterday}&lt;/em&gt;, &lt;em&gt;HEAD@{5 minutes ago}&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;[&amp;lt;refname&amp;gt;] @ {&amp;lt;date&amp;gt;}&lt;/em&gt; , 예 : &lt;em&gt;master @ {yesterday}&lt;/em&gt; , &lt;em&gt;HEAD @ {5 분 전}&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1cd4bcb44e7191f2eb44cda4db023938a79831a4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;^&amp;lt;rev&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;^&amp;lt;rev&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a478c982ab96d7b3cd7b2394477937eea1ef5707" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;^&amp;lt;rev&amp;gt;&lt;/em&gt; (caret) Notation</source>
          <target state="translated">&lt;em&gt;^ &amp;lt;rev&amp;gt;&lt;/em&gt; (캐럿) 표기법</target>
        </trans-unit>
        <trans-unit id="6c5258bbe828a82728cc4ed33fa5b2a769a9f041" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;add&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;add&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5fb4eac9e523986275eaea65ae4aaa925a3134ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;all&lt;/em&gt; (or &lt;em&gt;world&lt;/em&gt; or &lt;em&gt;everybody&lt;/em&gt;)</source>
          <target state="translated">&lt;em&gt;모두&lt;/em&gt; (또는 &lt;em&gt;세계&lt;/em&gt; 또는 &lt;em&gt;모두&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="baa6f8f1c17b745f4aa5b2be2a362fd0f8e9285f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;bidi-import&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;bidi-import&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ed7df5ebe1d79a304627a7aadaf5a0927046cea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;blame&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;blame&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6de763113a8d904122c702f6cefd7c219b580297" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;branch&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;branch&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6636ab201288b670023e22d0d9e34461025f1b2e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;capabilities&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;capabilities&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="79d9992bbf3dbb43b35277a95f1b9108ef1ed550" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;check-connectivity&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;check-connectivity&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="24d6101ef4a291c6beaf056fefdaccc2e424c5c1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;clear&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;clear&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ddae6bcc795d419b1ffc77a3d17a0e4276f7f575" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;clone&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;clone&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8eddd1a18b6fc33d327779d06d93e03222940e1d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;commit-diff&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;commit-diff&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0ff51f08bd660342a0c1c80b89197cdaa755aca" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;connect&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;connect&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bde2aabfe3d70165e234e4b00b2409c5fcd036c9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;connect&lt;/em&gt; &amp;lt;service&amp;gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;&amp;lt;서비스&amp;gt; &lt;em&gt;연결&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7c2320287db9afbf32136b4aeb8b8c3be4276dec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;create-ignore&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;create-ignore&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd4c4c97f36b2b62de11c34b4a27a2c761742b55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;cvs server&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이력서 서버&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e49a24547f58bd02d543075f89ceed8c90d6d7d1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;dcommit&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;dcommit&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29a1329a0153d69adbf79d22da2d86026099cd1a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;diff&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;diff&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dadae45c2e0ed49ab92c21e51924b9c5c51ce2a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;disable&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;disable&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b451ef329785424729c63e2a3017984d3e643c1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;export-marks&lt;/em&gt; &amp;lt;file&amp;gt;</source>
          <target state="translated">&lt;em&gt;수출 마크&lt;/em&gt; &amp;lt;파일&amp;gt;</target>
        </trans-unit>
        <trans-unit id="35b45d112a98b2ca1521e95769372073007c885a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;export&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;export&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="069adc38be838320ed1d0aece7752fcbc214a54a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fetch&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;fetch&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42d558b04f07f16944ece2169a0e3c3823b9025f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fetch&lt;/em&gt; &amp;lt;sha1&amp;gt; &amp;lt;name&amp;gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;&amp;lt;sha1&amp;gt; &amp;lt;name&amp;gt; &lt;em&gt;가져 오기&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="89dcac1ec2e46569b3edf183125a808da46f4c6f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;find-rev&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;find-rev&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1073814f068a39c89b0eede6d041e1faf4e59ac8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;forget&lt;/em&gt; &amp;lt;pathspec&amp;gt;</source>
          <target state="translated">&lt;em&gt;잊지&lt;/em&gt; &amp;lt;pathspec&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6f8f3fbb6ffe3b51991811f0c6531319170fdb21" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;gc&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;gc&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4af622a2a4f28a61d7a9f24cb930fffc6ba76491" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;get-url&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;get-url&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3a9d6d2f21ff1ec0d69ee63760f22a3c5cbb084b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; (-p|--patch) [&amp;lt;tree-ish&amp;gt;] [--] [&amp;lt;pathspec&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;자식 체크 아웃&lt;/em&gt; (-p | --patch) [&amp;lt;tree-ish&amp;gt;] [-] [&amp;lt;pathspec&amp;gt;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="228e3a4db67759d57c887f137171bceae52a6f8a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; --detach [&amp;lt;branch&amp;gt;]</source>
          <target state="translated">&lt;em&gt;git checkout&lt;/em&gt; --detach [&amp;lt;분기&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="d8ead8dfc114c4f20b9d6ce6d106f2bc2ef44cf5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; -b|-B &amp;lt;new_branch&amp;gt; [&amp;lt;start point&amp;gt;]</source>
          <target state="translated">&lt;em&gt;자식 체크 아웃&lt;/em&gt; -b | -B &amp;lt;new_branch&amp;gt; [&amp;lt;시작점&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="e4b2375b489fba132766f1463af8f72171dbc00f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; [&amp;lt;branch&amp;gt;]</source>
          <target state="translated">&lt;em&gt;자식 체크 아웃&lt;/em&gt; [&amp;lt;branch&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="9e1ee40d06e7050bf76fabde96c6e18bcdee66c1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; [--detach] &amp;lt;commit&amp;gt;</source>
          <target state="translated">&lt;em&gt;자식 체크 아웃&lt;/em&gt; [--detach] &amp;lt;commit&amp;gt;</target>
        </trans-unit>
        <trans-unit id="617a45295c12feb378bd11060f09979d655ab681" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; [-f|--ours|--theirs|-m|--conflict=&amp;lt;style&amp;gt;] [&amp;lt;tree-ish&amp;gt;] --pathspec-from-file=&amp;lt;file&amp;gt; [--pathspec-file-nul]</source>
          <target state="translated">&lt;em&gt;git checkout&lt;/em&gt; [-f | --ours | --theirs | -m | --conflict = &amp;lt;style&amp;gt;] [&amp;lt;tree-ish&amp;gt;] --pathspec-from-file = &amp;lt;file&amp;gt; [--pathspec-file- 널]</target>
        </trans-unit>
        <trans-unit id="f1d51fb50a15426c11b22d89a456ad62c37302f5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git checkout&lt;/em&gt; [-f|--ours|--theirs|-m|--conflict=&amp;lt;style&amp;gt;] [&amp;lt;tree-ish&amp;gt;] [--] &amp;lt;pathspec&amp;gt;&amp;hellip;​</source>
          <target state="translated">&lt;em&gt;자식 체크 아웃&lt;/em&gt; [-f | --ours | --theirs | -m | --conflict = &amp;lt;style&amp;gt;] [&amp;lt;tree-ish&amp;gt;] [-] &amp;lt;pathspec&amp;gt;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="8c3a4a5dff582db446092ec31dff7ac07f6c56f2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git daemon&lt;/em&gt; as inetd server</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;inetd 서버로서의 &lt;em&gt;git 데몬&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="644cb16bb367018811de44ec6a0f22813d106722" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git daemon&lt;/em&gt; as inetd server for virtual hosts</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;가상 호스트를위한 inetd 서버로서의 &lt;em&gt;git 데몬&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56394bb621be1c3ea64a9da0cc7c453f78c851ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git daemon&lt;/em&gt; as regular daemon for virtual hosts</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;가상 호스트의 일반 &lt;em&gt;데몬&lt;/em&gt; 으로서 &lt;em&gt;git 데몬&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eb95273e719d9bbb038ef063d4fe7199f2a7aaf4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;blob&amp;gt; &amp;lt;blob&amp;gt;</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;옵션&amp;gt;] &amp;lt;blob&amp;gt; &amp;lt;blob&amp;gt;</target>
        </trans-unit>
        <trans-unit id="1c0820ca6bb0780c196ed7a86287e4ecc94f9478" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;commit&amp;gt; &amp;lt;commit&amp;gt; [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;옵션&amp;gt;] &amp;lt;commit&amp;gt; &amp;lt;commit&amp;gt; [-] [&amp;lt;path&amp;gt;&amp;hellip;]</target>
        </trans-unit>
        <trans-unit id="1c00f2330de34632f28ea25bd937ad87e604196a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;commit&amp;gt; &amp;lt;commit&amp;gt;&amp;hellip;​ &amp;lt;commit&amp;gt; [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;옵션&amp;gt;] &amp;lt;커밋&amp;gt; &amp;lt;커밋&amp;gt;&amp;hellip; &amp;lt;커밋&amp;gt; [-] [&amp;lt;경로&amp;gt;&amp;hellip;]</target>
        </trans-unit>
        <trans-unit id="0bddd1875bfd788184caf49193c3ba66e07b6e07" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;commit&amp;gt; [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;옵션&amp;gt;] &amp;lt;커밋&amp;gt; [-] [&amp;lt;경로&amp;gt;&amp;hellip;]</target>
        </trans-unit>
        <trans-unit id="41d3be1f649e59b3792c69f12f6776a563b79a47" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;commit&amp;gt;..&amp;lt;commit&amp;gt; [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;옵션&amp;gt;] &amp;lt;commit&amp;gt; .. &amp;lt;commit&amp;gt; [-] [&amp;lt;경로&amp;gt;&amp;hellip;]</target>
        </trans-unit>
        <trans-unit id="bf5568faf67d40bb88542b7b67ef397df7105ffc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] &amp;lt;commit&amp;gt;...&amp;lt;commit&amp;gt; [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;옵션&amp;gt;] &amp;lt;commit&amp;gt; ... &amp;lt;commit&amp;gt; [-] [&amp;lt;path&amp;gt;&amp;hellip;]</target>
        </trans-unit>
        <trans-unit id="e447147bf3a29d6c97f55baf3c69e97f18f8eee8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] --cached [&amp;lt;commit&amp;gt;] [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;옵션&amp;gt;]-캐시 된 [&amp;lt;커밋&amp;gt;] [-] [&amp;lt;경로&amp;gt;&amp;hellip;]</target>
        </trans-unit>
        <trans-unit id="61d1c1e990e80e06e13a4eafe5a8bc5038d40599" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] --no-index [--] &amp;lt;path&amp;gt; &amp;lt;path&amp;gt;</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;옵션&amp;gt;] --no-index [-] &amp;lt;경로&amp;gt; &amp;lt;경로&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6d86328721afc22cd489583dfba8df6685359245" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;options&amp;gt;] [--] [&amp;lt;path&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git diff&lt;/em&gt; [&amp;lt;옵션&amp;gt;] [-] [&amp;lt;경로&amp;gt;&amp;hellip;]</target>
        </trans-unit>
        <trans-unit id="e3453c9e134e20e25559107f3911fd6230cd8bc6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git push&lt;/em&gt; uses a pair of commands, &lt;em&gt;git send-pack&lt;/em&gt; on your local machine, and &lt;em&gt;git-receive-pack&lt;/em&gt; on the remote machine. The communication between the two over the network internally uses an SSH connection.</source>
          <target state="translated">&lt;em&gt;git push&lt;/em&gt; 는 한 쌍의 명령, 로컬 컴퓨터의 &lt;em&gt;git send-pack&lt;/em&gt; 및 원격 컴퓨터의 &lt;em&gt;git-receive-pack&lt;/em&gt; 을 사용합니다. 네트워크를 통한 둘 사이의 통신은 내부적으로 SSH 연결을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fcf93dc31f705fddbb9194212d483f563999e11e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git receive-pack &amp;lt;argument&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;git receive-pack &amp;lt;인수&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc127848493f760fe053476520e3d12a67e1a15a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git reset&lt;/em&gt; (--patch | -p) [&amp;lt;tree-ish&amp;gt;] [--] [&amp;lt;pathspec&amp;gt;&amp;hellip;​]</source>
          <target state="translated">&lt;em&gt;git reset&lt;/em&gt; (--patch | -p) [&amp;lt;tree-ish&amp;gt;] [-] [&amp;lt;pathspec&amp;gt;&amp;hellip;]</target>
        </trans-unit>
        <trans-unit id="e0143ed9ababaeb97962f5daf71b285ee855acf6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git reset&lt;/em&gt; [&amp;lt;mode&amp;gt;] [&amp;lt;commit&amp;gt;]</source>
          <target state="translated">&lt;em&gt;자식 재설정&lt;/em&gt; [&amp;lt;모드&amp;gt;] [&amp;lt;커밋&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="9c8b6cc4b08d5db74f9966c865d7bdbc3e8057ff" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git reset&lt;/em&gt; [-q] [&amp;lt;tree-ish&amp;gt;] [--] &amp;lt;pathspec&amp;gt;&amp;hellip;​</source>
          <target state="translated">&lt;em&gt;git reset&lt;/em&gt; [-q] [&amp;lt;tree-ish&amp;gt;] [-] &amp;lt;pathspec&amp;gt;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="3db1e64e46be79d2a9c84117847b63d5ab92c79c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git reset&lt;/em&gt; [-q] [--pathspec-from-file=&amp;lt;file&amp;gt; [--pathspec-file-nul]] [&amp;lt;tree-ish&amp;gt;]</source>
          <target state="translated">&lt;em&gt;git reset&lt;/em&gt; [-q] [--pathspec-from-file = &amp;lt;file&amp;gt; [--pathspec-file-nul]] [&amp;lt;tree-ish&amp;gt;]</target>
        </trans-unit>
        <trans-unit id="0c6a869ee4e5a3eb64f1df2a1d1670adf970a316" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git upload-archive &amp;lt;argument&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;자식 업로드 아카이브 &amp;lt;인수&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e2be43a079baf397e7d9b3bb2f1f647a64854d22" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;git upload-pack &amp;lt;argument&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;git upload-pack &amp;lt;인수&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6b0677a6a48058174b9c4662c9d2ba987db8c81" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;group&lt;/em&gt; (or &lt;em&gt;true&lt;/em&gt;)</source>
          <target state="translated">&lt;em&gt;그룹&lt;/em&gt; (또는 &lt;em&gt;true&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="55040b4473f65b2a2bbdfd28a71977476093b889" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;import-marks&lt;/em&gt; &amp;lt;file&amp;gt;</source>
          <target state="translated">&lt;em&gt;수입 마크&lt;/em&gt; &amp;lt;파일&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e41133af30f1b5a3e614609c0efa62b0bd14788f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;import&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;import&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c7615a0bee74b428678cd3952d9a38bbd50138b2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;import&lt;/em&gt; &amp;lt;name&amp;gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;&amp;lt;이름&amp;gt; &lt;em&gt;가져 오기&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="026584f5175b5bbc2ceb1f268e18940c0011aaec" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;info&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;info&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6e0a5f718f14de716a46db8b2404578b5920000d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;init&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;init&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="286e2b7b70dbf3ef029c4799f2f0e629b0a5aef4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;list for-push&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;푸시 목록&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="be49361f1b70e440beb1d6cf2176c292c8e2abc7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;list&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;list&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a100b4c5979c283ac452823f58dbcc9e5048c7b8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;log&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;log&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="971c241f477dec4b57be5fc29faa14ab335706fa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;mkdirs&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;mkdirs&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="35b67dffbe62b7476ce92342433b831e27d5bcee" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;no-private-update&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;no-private-update&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a174c76dea793f056b89a441f20182238b3e3cd6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;object-format&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;object-format&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b76f729b2c8dd001b33a3965716abefb37454800" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option atomic&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;옵션 원자&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;허위&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="c33bb338d193ab16d7a0168b421e3b698bb0bcbe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option check-connectivity&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;옵션 점검 연결성&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;허위&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="9c99d5f55da3961c68109a0e1d9a50e706a2120b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option cloning&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;옵션 복제&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;허위&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="04bd7fa50536660a2d31774812bb98fb7a2abdff" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option deepen-relative {'true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;옵션 심화 상대 { 'true&lt;/em&gt; | &lt;em&gt;허위&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="a98d1a36ae5cdad2003ea22f14ad851505cf3847" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option depth&lt;/em&gt; &amp;lt;depth&amp;gt;</source>
          <target state="translated">&lt;em&gt;옵션 깊이&lt;/em&gt; &amp;lt;깊이&amp;gt;</target>
        </trans-unit>
        <trans-unit id="82d6797af0a212ad278e2948eaeaaf74a72f680a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option followtags&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;옵션 followtags&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;허위&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="9986eedd79cb9f9b7c70d2aedda0729823cac02a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option force&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;옵션 강제&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;허위&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="111ea29454b6330909016c9e45b9b66754df6b19" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option from-promisor&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;옵션 from-promisor&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;허위&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="800dda6c88e8893c227fca8a8c94622ca67dc810" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option no-dependents&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;옵션 비 의존성&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;허위&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="6d34f6b09c919f1b1416585cad7a0c757ef7810f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option object-format&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|algorithm}</source>
          <target state="translated">&lt;em&gt;옵션 object-format&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | algorithm}</target>
        </trans-unit>
        <trans-unit id="7ea5bd740df1ec70168c7a478ecd00a132039f43" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option progress&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;옵션 진행률&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;허위&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="5dc4a2e0bb9f6060bdad740b788ef15fe9ea07c9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option pushcert&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;옵션 pushcert&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;허위&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="59d5978dddebb71223de8e8f6a60d2e3e72c7a65" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option servpath &amp;lt;c-style-quoted-path&amp;gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;servpath 옵션 &amp;lt;c-style-quoted-path&amp;gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4ca7ff603e79015944d1670c4c4f6181601659ca" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option update-shallow&lt;/em&gt; {&lt;em&gt;true&lt;/em&gt;|&lt;em&gt;false&lt;/em&gt;}</source>
          <target state="translated">&lt;em&gt;옵션 update-shallow&lt;/em&gt; { &lt;em&gt;true&lt;/em&gt; | &lt;em&gt;허위&lt;/em&gt; }</target>
        </trans-unit>
        <trans-unit id="0786067c699d96aadca89509b296234c78e51c6b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option verbosity&lt;/em&gt; &amp;lt;n&amp;gt;</source>
          <target state="translated">&lt;em&gt;옵션 상세 정보&lt;/em&gt; &amp;lt;n&amp;gt;</target>
        </trans-unit>
        <trans-unit id="04c59238310bfcf16cbbb35553d54bbfdca9360e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;option&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="44f8139502701251329b628c8aa5e94fd7edfce3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;option&lt;/em&gt; &amp;lt;name&amp;gt; &amp;lt;value&amp;gt;</source>
          <target state="translated">&lt;em&gt;옵션&lt;/em&gt; &amp;lt;이름&amp;gt; &amp;lt;값&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ba27d70f1550f4f882b78e61655d5157efb6f50e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;propget&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;propget&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6756585c61f2a32bab572f78fd3126b296699695" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;proplist&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;proplist&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0e4008412d95ecd817c12ca15c192c575f546de4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;propset&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;propset&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4498ec3238e0f1d50b74e6af30a09c8f3309ba7d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;prune&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;prune&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd31fb337461755bb5e3e31aef446948ecaa910d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;push&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;push&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="11c969a81bfce4fd2324388518d5f5e17de0b527" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;push&lt;/em&gt; +&amp;lt;src&amp;gt;:&amp;lt;dst&amp;gt;</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;+ &amp;lt;src&amp;gt; : &amp;lt;dst&amp;gt;를 &lt;em&gt;누릅니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9117e882f570b9772bf4876578e36a25fc34732b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;qgit(1)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;qgit(1)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f7c74e3d1e10b38ac6169dc067698ef1a6ff4448" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;reapply&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;reapply&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50ee056d4ddb76ef51f00483fe7dba34b51a449f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;rebase&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;rebase&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18ea2b05c8f3c06fde58d0420744f0ca61045b90" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;refspec&lt;/em&gt; &amp;lt;refspec&amp;gt;</source>
          <target state="translated">&lt;em&gt;refspec&lt;/em&gt; &amp;lt;refspec&amp;gt;</target>
        </trans-unit>
        <trans-unit id="dd596b5091e1eb8368f579278c36824b713bc311" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;remaining&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;remaining&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d3ac08fba984c4fe2e39dbd6a9e3de5fb185a1f5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;remove&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;remove&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b73121d3aa4f1dd8fa730929ede8f4b312f32337" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;rename&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;rename&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d13cdb6fdbae20acc2c43402406d81568a2499c7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;reset&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;reset&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e4c4fda591f60696add6ae66730f4d8ec836d261" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;rm&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;rm&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e477dd12e9e0460380eeba036cb09372c938695d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set-branches&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set-branches&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e65afe49a6eeb7cf02d2f6043f28b8a4ff342bf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set-head&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set-head&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="35f6993e8ee5f31dec406f06a31e049f29878752" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set-tree&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set-tree&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7eda17e1c12e721d23988d4fc5e20726a9c47abd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set-url&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set-url&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8687e363ac98f906ebed1b843dd4f64a34e3c7f4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;set&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;set&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6870a5d4b2985453a855890d8d72edfc3d70811" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;show-externals&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;show-externals&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4fe1dc07bdefa3cf58064ba55fde45829ca1f136" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;show-ignore&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;show-ignore&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd0e49781a98f7911b34f1aee38b44f2e869f16f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;show&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;show&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0cc68266a42e8384ff3fa58baf8c34f3646c37ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;signed-tags&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;signed-tags&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b86cead65159d3e086c70f8b7b59218a58d3147e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;stateless-connect&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;stateless-connect&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c4b47d3b1f6acb81c114d964233185b4c02ac419" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;stateless-connect&lt;/em&gt; &amp;lt;service&amp;gt;</source>
          <target state="translated">&lt;em&gt;stateless-connect&lt;/em&gt; &amp;lt;서비스&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cbef19eb270f01c4c2c82d2d02a006f9e49ea17d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;status&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;status&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc5dcfd7fa2c24a533fa19007091483ece18fad4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;tag&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;tag&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="96d7bc00171f5fd2b09f66cf504ac0023cca30dc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;tig(1)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;tig(1)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="139a3f1d23eafefa18ee2425482ff51b6f467d67" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;umask&lt;/em&gt; (or &lt;em&gt;false&lt;/em&gt;)</source>
          <target state="translated">&lt;em&gt;umask&lt;/em&gt; (또는 &lt;em&gt;false&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="9c0e9959206cb6877a60069410fa385eb4f78805" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;unchanged&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;unchanged&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2ecf8aa641ca5e9e706fa0d63103b28681ce2dc6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;unset&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;unset&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c1802e8d4ef28dec4be0233820e8c05c3d927de" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;unspecified&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;unspecified&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b312ee3f358f78767b6a06231fbf44287808e9ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;update&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;update&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5aed0d22d6992ee80ec4d657f0cd95ab429e2ec9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;verify&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;verify&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f49b6f6188963904d82e1623f3020436895b7e2c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;write&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;write&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8172ae9dcfb804bff8895259fe3102a0316b0619" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; The latter form is just a short-hand of &lt;code&gt;git checkout topic&lt;/code&gt; followed by &lt;code&gt;git rebase master&lt;/code&gt;. When rebase exits &lt;code&gt;topic&lt;/code&gt; will remain the checked-out branch.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 후자의 형식은 &lt;code&gt;git checkout topic&lt;/code&gt; 의 약어 이며 &lt;code&gt;git rebase master&lt;/code&gt; 입니다. 리베이스 종료시 &lt;code&gt;topic&lt;/code&gt; 은 체크 아웃 된 분기로 유지 됩니다 .</target>
        </trans-unit>
        <trans-unit id="b03388fb9a3fc2d66d455eba38ee0aa1f510dfbe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; the changes introduced by the commits, and which are not reverted by subsequent commits, will still be in the rewritten branch. If you want to throw out &lt;code&gt;changes&lt;/code&gt; together with the commits, you should use the interactive mode of &lt;code&gt;git rebase&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;주&lt;/strong&gt; 이후의 커밋으로 복귀하지 않는 커밋에 의해 도입 된 변화, 그리고 여전히 다시 지점에있을 것입니다. 커밋과 함께 &lt;code&gt;changes&lt;/code&gt; 제거 하려면 대화식 &lt;code&gt;git rebase&lt;/code&gt; 모드를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="34561b8d811663906f33af73652542d0fcde7357" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: &lt;code&gt;$my_url&lt;/code&gt;, &lt;code&gt;$my_uri&lt;/code&gt;, and &lt;code&gt;$base_url&lt;/code&gt; are overwritten with their default values before every request, so if you want to change them, be sure to set this variable to true or a code reference effecting the desired changes.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 모든 요청 전에 &lt;code&gt;$my_url&lt;/code&gt; , &lt;code&gt;$my_uri&lt;/code&gt; 및 &lt;code&gt;$base_url&lt;/code&gt; 은 기본값으로 덮어 쓰므로 변경하려면이 변수를 true 또는 원하는 변경에 영향을주는 코드 참조로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="09aea3b60370a4f963c3a85b4699f5aaace7982e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Do &lt;strong&gt;not&lt;/strong&gt; use this option unless you have read the note for &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;'s &lt;code&gt;--reference&lt;/code&gt;, &lt;code&gt;--shared&lt;/code&gt;, and &lt;code&gt;--dissociate&lt;/code&gt; options carefully.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 음주 &lt;strong&gt;하지&lt;/strong&gt; 당신이 메모 읽게하지 않는 한이 옵션을 사용하여 &lt;a href=&quot;git-clone&quot;&gt;자식 - 클론 [1]&lt;/a&gt; 의 &lt;code&gt;--reference&lt;/code&gt; , &lt;code&gt;--shared&lt;/code&gt; 및 &lt;code&gt;--dissociate&lt;/code&gt; 신중하게 옵션을.</target>
        </trans-unit>
        <trans-unit id="7c9dfe7ce0f5b8ee96b2cbc1652fb8a81531cced" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This command honors &lt;code&gt;.git/info/grafts&lt;/code&gt; file and refs in the &lt;code&gt;refs/replace/&lt;/code&gt; namespace. If you have any grafts or replacement refs defined, running this command will make them permanent.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 명령은 &lt;code&gt;.git/info/grafts&lt;/code&gt; 파일과 &lt;code&gt;refs/replace/&lt;/code&gt; 네임 스페이스 의 ref를 존중 합니다. 그래프트 또는 교체 참조가 정의 된 경우이 명령을 실행하면 영구적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d30c68c37350410fb672027924f29f5f9ab1c98c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This command is temporarily disabled if your libcurl is older than 7.16, as the combination has been reported not to work and sometimes corrupts repository.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 명령은 libcurl이 7.16보다 오래된 경우 조합이 작동하지 않는 것으로보고되어 리포지토리가 손상되는 경우가 있으므로 일시적으로 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="f74ae839c695329bca37194e38c0f34b77fadce9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: This is intended for cleaning metadata, prefer the &lt;code&gt;--whitespace=fix&lt;/code&gt; mode of &lt;a href=&quot;git-apply&quot;&gt;git-apply[1]&lt;/a&gt; for correcting whitespace of patches or files in the repository.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 이것은 메타 데이터를 정리하기위한 것으로, 리포지토리에서 패치 또는 파일의 공백을 수정 &lt;a href=&quot;git-apply&quot;&gt;하려면 git-apply [1]&lt;/a&gt; 의 &lt;code&gt;--whitespace=fix&lt;/code&gt; 모드를 선호하십시오 .</target>
        </trans-unit>
        <trans-unit id="585c6ddedc01781dae2a49fca690af8a9afad0a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: for a file to be highlighted, its syntax type must be detected and that syntax must be supported by &quot;highlight&quot;. The default syntax detection is minimal, and there are many supported syntax types with no detection by default. There are three options for adding syntax detection. The first and second priority are &lt;code&gt;%highlight_basename&lt;/code&gt; and &lt;code&gt;%highlight_ext&lt;/code&gt;, which detect based on basename (the full filename, for example &quot;Makefile&quot;) and extension (for example &quot;sh&quot;). The keys of these hashes are the basename and extension, respectively, and the value for a given key is the name of the syntax to be passed via &lt;code&gt;--syntax &amp;lt;syntax&amp;gt;&lt;/code&gt; to &quot;highlight&quot;. The last priority is the &quot;highlight&quot; configuration of &lt;code&gt;Shebang&lt;/code&gt; regular expressions to detect the language based on the first line in the file, (for example, matching the line &quot;#!/bin/bash&quot;). See the highlight documentation and the default config at /etc/highlight/filetypes.conf for more details.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 파일을 강조 표시하려면 구문 유형을 감지하고 해당 구문을 &quot;강조 표시&quot;로 지원해야합니다. 기본 구문 감지는 최소이며 기본적으로 감지되지 않은 지원되는 구문 유형이 많이 있습니다. 구문 탐지를 추가하기위한 세 가지 옵션이 있습니다. 첫 번째 및 두 번째 우선 순위는 &lt;code&gt;%highlight_basename&lt;/code&gt; 및 &lt;code&gt;%highlight_ext&lt;/code&gt; 이며, 기본 이름 (예 : &quot;Makefile&quot;과 같은 전체 파일 이름) 및 확장자 (예 : &quot;sh&quot;)를 기반으로 감지합니다. 이러한 해시의 키는 각각 기본 이름과 확장명이며, 주어진 키의 값은 &lt;code&gt;--syntax &amp;lt;syntax&amp;gt;&lt;/code&gt; 를 통해 &quot;highlight&quot; 로 전달되는 구문의 이름입니다 . 마지막 우선 순위는 &quot;하이라이트&quot;입니다 &lt;code&gt;Shebang&lt;/code&gt; 의 구성파일의 첫 번째 줄을 기준으로 언어를 감지하는 정규식 (예 : &quot;#! / bin / bash&quot;줄과 일치) 자세한 내용은 주요 내용 및 /etc/highlight/filetypes.conf의 기본 구성을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9b9b27f31414016f32b35409236f195a9797bba5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: see the NOTE for the &lt;code&gt;--reference&lt;/code&gt; option.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;--reference&lt;/code&gt; 옵션에 대한 &lt;strong&gt;참고&lt;/strong&gt; 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5918a0077865239a25fcfe555ed0525b81a0cce2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: see the NOTE for the &lt;code&gt;--shared&lt;/code&gt; option, and also the &lt;code&gt;--dissociate&lt;/code&gt; option.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : &lt;code&gt;--shared&lt;/code&gt; 옵션 및 &lt;code&gt;--dissociate&lt;/code&gt; 옵션에 대한 &lt;strong&gt;참고&lt;/strong&gt; 사항을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb7c79db74439daa322af5432c4cb38d74b773b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: this is a possibly dangerous operation; do &lt;strong&gt;not&lt;/strong&gt; use it unless you understand the implications (see &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for details).</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 이것은 위험한 작업 일 수 있습니다. 의미를 이해 하지 &lt;strong&gt;않으면&lt;/strong&gt; 사용 하지 &lt;strong&gt;마십시오&lt;/strong&gt; (자세한 내용은 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="fd8f10a91cc32941d397d3cbd72284f0494472a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: this is a possibly dangerous operation; do &lt;strong&gt;not&lt;/strong&gt; use it unless you understand what it does. If you clone your repository using this option and then delete branches (or use any other Git command that makes any existing commit unreferenced) in the source repository, some objects may become unreferenced (or dangling). These objects may be removed by normal Git operations (such as &lt;code&gt;git commit&lt;/code&gt;) which automatically call &lt;code&gt;git gc --auto&lt;/code&gt;. (See &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.) If these objects are removed and were referenced by the cloned repository, then the cloned repository will become corrupt.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 이것은 위험한 작업 일 수 있습니다. 자신이하는 일을 이해 하지 &lt;strong&gt;않으면&lt;/strong&gt; 사용 하지 &lt;strong&gt;마십시오&lt;/strong&gt; . 이 옵션을 사용하여 리포지토리를 복제 한 다음 소스 리포지토리에서 분기를 삭제하거나 기존 커밋을 참조하지 않는 다른 Git 명령을 사용하면 일부 개체가 참조되지 않거나 매달릴 수 있습니다. 이러한 객체는 &lt;code&gt;git gc --auto&lt;/code&gt; 를 자동으로 호출 하는 일반적인 Git 작업 ( &lt;code&gt;git commit&lt;/code&gt; 등)으로 제거 할 수 있습니다 . ( &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt; 참조 ) 이러한 객체가 제거되고 복제 된 저장소에서 참조 된 경우 복제 된 저장소가 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="712e882beefd494ed11253317cebeacda8705864" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: this is a possibly dangerous operation; do &lt;strong&gt;not&lt;/strong&gt; use it unless you understand what it does. If you clone your repository using this option and then delete branches (or use any other Git command that makes any existing commit unreferenced) in the source repository, some objects may become unreferenced (or dangling). These objects may be removed by normal Git operations (such as &lt;code&gt;git commit&lt;/code&gt;) which automatically call &lt;code&gt;git maintenance run --auto&lt;/code&gt;. (See &lt;a href=&quot;git-maintenance&quot;&gt;git-maintenance[1]&lt;/a&gt;.) If these objects are removed and were referenced by the cloned repository, then the cloned repository will become corrupt.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 이것은 위험 할 수있는 작업입니다. 당신이 그것이 무엇을하는지 이해하지 않는 한 그것을 사용 하지 &lt;strong&gt;마십시오&lt;/strong&gt; . 이 옵션을 사용하여 리포지토리를 복제 한 다음 소스 리포지토리에서 브랜치를 삭제 (또는 기존 커밋을 참조되지 않도록하는 다른 Git 명령 사용)하면 일부 개체가 참조되지 않거나 매달려있을 수 있습니다. 이러한 객체는 &lt;code&gt;git maintenance run --auto&lt;/code&gt; 를 자동으로 호출 하는 일반 Git 작업 (예 : &lt;code&gt;git commit&lt;/code&gt; )에 의해 제거 될 수 있습니다 . ( &lt;a href=&quot;git-maintenance&quot;&gt;git-maintenance [1]&lt;/a&gt; 참조 ) 이러한 객체가 제거되고 복제 된 저장소에서 참조 된 경우 복제 된 저장소가 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="7c66780d5bfd012adc7033c6c0a4c5d63ded1f14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; gitk (unlike &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;) currently only understands this option if you specify it &quot;glued together&quot; with its argument. Do &lt;strong&gt;not&lt;/strong&gt; put a space after &lt;code&gt;-L&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; gitk ( &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 과 달리 )는 현재이 옵션을 인수와 함께 &quot;접착&quot;하도록 지정한 경우에만이 옵션을 이해합니다. 마십시오 &lt;strong&gt;하지&lt;/strong&gt; 뒤에 공백을 넣어 &lt;code&gt;-L&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55897d0bbd0f3ca4e5eda8d2fd483ad8d798dcb2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that no feature is overridable by default.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; 어떤 기능이 기본적으로 재정의 없음을.</target>
        </trans-unit>
        <trans-unit id="02ea3f041b0ba373c69cf48b5644925866c5ecea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that rename and especially copy detection can be quite CPU-intensive. Note also that non Git tools can have problems with patches generated with options mentioned above, especially when they involve file copies ('-C') or criss-cross renames ('-B').</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; 그 이름 바꾸기를 특히 감지 꽤 CPU를 많이 사용할 수 있습니다 복사합니다. Git 이외의 도구는 특히 파일 복사 ( '-C') 또는 십자 이름 바꾸기 ( '-B')와 관련된 경우 위에서 언급 한 옵션으로 생성 된 패치에 문제가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="902c07c8249a8df193537556ae95a34d36a6294b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that this requires to be set for each request, so either &lt;code&gt;$per_request_config&lt;/code&gt; must be false, or the above must be put in code referenced by &lt;code&gt;$per_request_config&lt;/code&gt;;</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; 이 각 요청에 대해 설정하는 데 필요한 그러니 &lt;code&gt;$per_request_config&lt;/code&gt; 거짓이거나 위가 참조하는 코드에 넣어해야 &lt;code&gt;$per_request_config&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="e45e1902bb87b0712f0e2420e234000a3f2ef680" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Also you can have a plain text file &lt;code&gt;.git&lt;/code&gt; at the root of your working tree, containing &lt;code&gt;gitdir: &amp;lt;path&amp;gt;&lt;/code&gt; to point at the real directory that has the repository. This mechanism is often used for a working tree of a submodule checkout, to allow you in the containing superproject to &lt;code&gt;git checkout&lt;/code&gt; a branch that does not have the submodule. The &lt;code&gt;checkout&lt;/code&gt; has to remove the entire submodule working tree, without losing the submodule repository.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 또한 작업 트리의 루트에 일반 텍스트 파일 &lt;code&gt;.git&lt;/code&gt; 을 가질 수 있으며 &lt;code&gt;gitdir: &amp;lt;path&amp;gt;&lt;/code&gt; 를 포함 하여 저장소가있는 실제 디렉토리를 가리 킵니다. 이 메커니즘은 하위 모듈 체크 아웃의 작업 트리에 종종 사용되며, 포함하는 수퍼 프로젝트에서 하위 모듈 이없는 분기를 &lt;code&gt;git checkout&lt;/code&gt; 할 수 있습니다 . &lt;code&gt;checkout&lt;/code&gt; 서브 모듈의 저장소를 잃지 않고, 전체 서브 모듈 작업 트리를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71fa00b64eae5b5c3890d9bb37bfa403b32cff82" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: there is also a legacy &lt;code&gt;$stylesheet&lt;/code&gt; configuration variable, which was used by older gitweb. If &lt;code&gt;$stylesheet&lt;/code&gt; variable is defined, only CSS stylesheet given by this variable is used by gitweb.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 기존 gitweb에서 사용 된 레거시 &lt;code&gt;$stylesheet&lt;/code&gt; 구성 변수도 있습니다. 경우 &lt;code&gt;$stylesheet&lt;/code&gt; 변수가 정의되고,이 변수에 의해 주어진에만 CSS 스타일 시트 gitweb에 의해 사용된다.</target>
        </trans-unit>
        <trans-unit id="22d7c2a95cf98eb3222f8ef736d4c5d7e8f5f3e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notice&lt;/strong&gt; that in this case you don&amp;rsquo;t need special settings for &lt;code&gt;@stylesheets&lt;/code&gt;, &lt;code&gt;$my_uri&lt;/code&gt; and &lt;code&gt;$home_link&lt;/code&gt;, but you lose &quot;dumb client&quot; access to your project .git dirs (described in &quot;Single URL for gitweb and for fetching&quot; section). A possible workaround for the latter is the following: in your project root dir (e.g. &lt;code&gt;/pub/git&lt;/code&gt;) have the projects named &lt;strong&gt;without&lt;/strong&gt; a .git extension (e.g. &lt;code&gt;/pub/git/project&lt;/code&gt; instead of &lt;code&gt;/pub/git/project.git&lt;/code&gt;) and configure Apache as follows:</source>
          <target state="translated">&lt;strong&gt;공지 사항&lt;/strong&gt; 이 경우에 당신을위한 특별한 설정이 필요하지 않습니다 &lt;code&gt;@stylesheets&lt;/code&gt; , &lt;code&gt;$my_uri&lt;/code&gt; 및 &lt;code&gt;$home_link&lt;/code&gt; ,하지만 당신은 당신의 프로젝트 .git의 DIRS에 &quot;바보 클라이언트&quot;액세스 상실 ( &quot;gitweb과 인출에 대한 단일 URL&quot;에 설명을 섹션) . 후자의 가능한 해결 방법은 다음과 같습니다. 프로젝트 루트 디렉토리 (예 : &lt;code&gt;/pub/git&lt;/code&gt; ) 에서 .git 확장자 &lt;strong&gt;없이&lt;/strong&gt; 프로젝트 이름을 지정하십시오 (예 : &lt;code&gt;/pub/git/project.git&lt;/code&gt; 대신 &lt;code&gt;/pub/git/project&lt;/code&gt; ) 다음과 같이 Apache를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="07043eaeaff4821b6e3d2bf0596ce3d880d9918c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Parent:&lt;/strong&gt; All files immediately inside a directory are included.</source>
          <target state="translated">&lt;strong&gt;상위 :&lt;/strong&gt; 디렉토리 내부의 모든 파일이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="32959a6518e6c4e84b5303e691c25180330dfdcb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Recursive:&lt;/strong&gt; All paths inside a directory are included.</source>
          <target state="translated">&lt;strong&gt;재귀 :&lt;/strong&gt; 디렉토리 내의 모든 경로가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e44ad2e7b5c600612a0a8797303bea45f315c6d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt; for certain situations the import leads to incorrect results. Please see the section &lt;a href=&quot;#issues&quot;&gt;ISSUES&lt;/a&gt; for further reference.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 특정 상황에서는 가져 오기 결과가 올바르지 않습니다. 자세한 내용은 &lt;a href=&quot;#issues&quot;&gt;ISSUES&lt;/a&gt; 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a9194839c57ad7da4a8bab5e0d40ab32351d35b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING:&lt;/strong&gt;&lt;code&gt;git cvsimport&lt;/code&gt; uses cvsps version 2, which is considered deprecated; it does not work with cvsps version 3 and later. If you are performing a one-shot import of a CVS repository consider using &lt;a href=&quot;http://cvs2svn.tigris.org/cvs2git.html&quot;&gt;cvs2git&lt;/a&gt; or &lt;a href=&quot;http://www.catb.org/esr/cvs-fast-export/&quot;&gt;cvs-fast-export&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;경고 : &lt;/strong&gt; &lt;code&gt;git cvsimport&lt;/code&gt; 는 cvsps 버전 2를 사용하는데, 이는 더 이상 사용되지 않는 것으로 간주됩니다. cvsps 버전 3 이상에서는 작동하지 않습니다. CVS 저장소의 원샷 가져 오기를 수행하는 경우 &lt;a href=&quot;http://cvs2svn.tigris.org/cvs2git.html&quot;&gt;cvs2git&lt;/a&gt; 또는 &lt;a href=&quot;http://www.catb.org/esr/cvs-fast-export/&quot;&gt;cvs-fast-export&lt;/a&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="56bcd3ed1b5437dcaa0e279477dd7d4ed74ad36f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt;! The rewritten history will have different object names for all the objects and will not converge with the original branch. You will not be able to easily push and distribute the rewritten branch on top of the original branch. Please do not use this command if you do not know the full implications, and avoid using it anyway, if a simple single commit would suffice to fix your problem. (See the &quot;RECOVERING FROM UPSTREAM REBASE&quot; section in &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt; for further information about rewriting published history.)</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; ! 다시 작성된 기록은 모든 개체에 대해 다른 개체 이름을 가지며 원래 분기와 수렴되지 않습니다. 다시 작성된 분기를 원래 분기 위에 쉽게 푸시 및 배포 할 수 없습니다. 전체적인 의미를 모르는 경우이 명령을 사용하지 말고 간단한 단일 커밋으로 문제를 해결하기에 충분하다면 사용하지 마십시오. 게시 된 기록을 다시 작성하는 방법에 대한 자세한 내용은 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]의&lt;/a&gt; &quot;UPSTREAM REBASE에서 복구&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c57eef2952dcc7cbcb3f3594949c7f400ccd82e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Running &lt;code&gt;git merge&lt;/code&gt; with non-trivial uncommitted changes is discouraged: while possible, it may leave you in a state that is hard to back out of in the case of a conflict.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 사소한 커밋되지 않은 변경 사항으로 &lt;code&gt;git merge&lt;/code&gt; 를 실행하는 것은 권장되지 않습니다. 가능한 경우 충돌이 발생할 경우 되돌릴 수없는 상태가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bab61eb53176449e25c2c82f172b82cb13ffb9d" translate="yes" xml:space="preserve">
          <source>?</source>
          <target state="translated">?</target>
        </trans-unit>
        <trans-unit id="2e41f73876997d3719c74ffacd713f8bedda0ef1" translate="yes" xml:space="preserve">
          <source>@diff_opts</source>
          <target state="translated">@diff_opts</target>
        </trans-unit>
        <trans-unit id="ece9251682dfe6d86397776eeae7c5bceec968bb" translate="yes" xml:space="preserve">
          <source>@extra_breadcrumbs</source>
          <target state="translated">@extra_breadcrumbs</target>
        </trans-unit>
        <trans-unit id="d642d6b3afbdc1fe579a545767dd08c49fb22d26" translate="yes" xml:space="preserve">
          <source>@git_base_url_list</source>
          <target state="translated">@git_base_url_list</target>
        </trans-unit>
        <trans-unit id="d1cb9d322cf309d895cfe28288e26547a4f2023b" translate="yes" xml:space="preserve">
          <source>@stylesheets</source>
          <target state="translated">@stylesheets</target>
        </trans-unit>
        <trans-unit id="17f8f0c63a0ac553bacb3cc13b4bba7ffe3a1b0c" translate="yes" xml:space="preserve">
          <source>A &quot;blob&quot; is just file data, which we can also examine with cat-file:</source>
          <target state="translated">&quot;blob&quot;은 파일 데이터 일 뿐이며 cat-file로 검사 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="48346c16ecaa075a67739766a897040a2f3413ba" translate="yes" xml:space="preserve">
          <source>A &quot;blob&quot; object is nothing but a binary blob of data. It doesn&amp;rsquo;t refer to anything else or have attributes of any kind.</source>
          <target state="translated">&quot;블롭 (blob)&quot;객체는 이진 블롭 데이터 일뿐입니다. 그것은 다른 것을 언급하거나 어떤 종류의 속성도 가지고 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78bff4978d5abc6efec633665a6a6e240b98928c" translate="yes" xml:space="preserve">
          <source>A &quot;branch&quot; is an active line of development. The most recent &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; on a branch is referred to as the tip of that branch. The tip of the branch is referenced by a branch &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;, which moves forward as additional development is done on the branch. A single Git &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; can track an arbitrary number of branches, but your &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; is associated with just one of them (the &quot;current&quot; or &quot;checked out&quot; branch), and &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; points to that branch.</source>
          <target state="translated">&quot;분기&quot;는 활발한 개발 라인입니다. 지점에서 가장 최근의 &lt;a href=&quot;#def_commit&quot;&gt;커밋&lt;/a&gt; 을 해당 지점의 팁이라고합니다. 브랜치의 팁은 브랜치 &lt;a href=&quot;#def_head&quot;&gt;헤드&lt;/a&gt; 에서 참조되며, 브랜치 헤드 에서 추가 개발이 완료되면 앞으로 나아갑니다. 단일 Git &lt;a href=&quot;#def_repository&quot;&gt;리포지토리&lt;/a&gt; 는 임의의 수의 분기를 추적 할 수 있지만 &lt;a href=&quot;#def_working_tree&quot;&gt;작업 트리는&lt;/a&gt; 이들 중 하나 ( &quot;현재&quot;또는 &quot;체크 아웃 된&quot;분기)에만 연결되며 &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; 는 해당 분기를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="a01578f0bd22457eb0af668d78f12e9483b4aa95" translate="yes" xml:space="preserve">
          <source>A &quot;combined diff&quot; format looks like this:</source>
          <target state="translated">&quot;결합 된 diff&quot;형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3fd53e12d383c6d235aea40bfa1170ca1c16d64c" translate="yes" xml:space="preserve">
          <source>A &quot;light&quot; tag is technically nothing more than a branch, except we put it in the &lt;code&gt;.git/refs/tags/&lt;/code&gt; subdirectory instead of calling it a &lt;code&gt;head&lt;/code&gt;. So the simplest form of tag involves nothing more than</source>
          <target state="translated">&quot;light&quot;태그는 기술적으로 브랜치에 지나지 않습니다. 단 , &lt;code&gt;head&lt;/code&gt; 라고 부르지 않고 &lt;code&gt;.git/refs/tags/&lt;/code&gt; 서브 디렉토리에 넣는 것 외에는 다릅니다 . 가장 간단한 형태의 태그는</target>
        </trans-unit>
        <trans-unit id="79a6a59906f3a3c6cb0aaa94c5e091d6ff4d2697" translate="yes" xml:space="preserve">
          <source>A &quot;patch ID&quot; is nothing but a sum of SHA-1 of the file diffs associated with a patch, with whitespace and line numbers ignored. As such, it&amp;rsquo;s &quot;reasonably stable&quot;, but at the same time also reasonably unique, i.e., two patches that have the same &quot;patch ID&quot; are almost guaranteed to be the same thing.</source>
          <target state="translated">&quot;패치 ID&quot;는 공백과 줄 번호를 무시하고 패치와 관련된 파일 diff의 SHA-1의 합계에 지나지 않습니다. 따라서 &quot;합리적으로 안정적&quot;이지만 동시에 합리적으로 고유합니다. 즉, 동일한 &quot;패치 ID&quot;를 갖는 두 개의 패치는 거의 동일한 것으로 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="12c2193bcd0be75dda12f0549bb6c953d953abdc" translate="yes" xml:space="preserve">
          <source>A &quot;proxy command&quot; to execute (as &lt;code&gt;command host port&lt;/code&gt;) instead of establishing direct connection to the remote server when using the Git protocol for fetching. If the variable value is in the &quot;COMMAND for DOMAIN&quot; format, the command is applied only on hostnames ending with the specified domain string. This variable may be set multiple times and is matched in the given order; the first match wins.</source>
          <target state="translated">페치에 Git 프로토콜을 사용할 때 원격 서버에 직접 연결하는 대신 ( &lt;code&gt;command host port&lt;/code&gt; ) 실행하는 &quot;프록시 명령&quot; 입니다. 변수 값이 &quot;COMMAND for DOMAIN&quot;형식 인 경우 명령은 지정된 도메인 문자열로 끝나는 호스트 이름에만 적용됩니다. 이 변수는 여러 번 설정 될 수 있으며 주어진 순서대로 일치합니다. 첫 경기가 이깁니다.</target>
        </trans-unit>
        <trans-unit id="b4f3117f71091d9312b93d71f6f1f95e92690216" translate="yes" xml:space="preserve">
          <source>A &quot;refspec&quot; is used by &lt;a href=&quot;#def_fetch&quot;&gt;fetch&lt;/a&gt; and &lt;a href=&quot;#def_push&quot;&gt;push&lt;/a&gt; to describe the mapping between remote &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; and local ref.</source>
          <target state="translated">&quot;refspec&quot;은 원격 &lt;a href=&quot;#def_ref&quot;&gt;참조&lt;/a&gt; 와 로컬 참조 간의 매핑을 설명하기 위해 &lt;a href=&quot;#def_fetch&quot;&gt;페치&lt;/a&gt; 및 &lt;a href=&quot;#def_push&quot;&gt;푸시&lt;/a&gt; 에서 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d877d63b6b5e9d7da0337dffb75c191c08f97905" translate="yes" xml:space="preserve">
          <source>A &quot;release&quot; tree into which tested patches are moved for final sanity checking, and as a vehicle to send them upstream to Linus (by sending him a &quot;please pull&quot; request.)</source>
          <target state="translated">테스트 된 패치가 최종 온 전성 검사를 위해 이동되고 패치를 Linus에 업스트림으로 보내기위한 수단으로 &quot;릴리스&quot;트리입니다 ( &quot;당김&quot;요청을 보냄).</target>
        </trans-unit>
        <trans-unit id="5ff4d6ad0b357610ea5d99a54033d43fa5c5c86c" translate="yes" xml:space="preserve">
          <source>A &quot;test&quot; tree into which patches are initially placed so that they can get some exposure when integrated with other ongoing development. This tree is available to Andrew for pulling into -mm whenever he wants.</source>
          <target state="translated">패치가 처음에 배치되는 &quot;테스트&quot;트리로, 진행중인 다른 개발과 통합 될 때 약간 노출 될 수 있습니다. 이 트리는 Andrew가 원할 때마다 -mm을 가져 오기 위해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1289678cb38397cef5e65878a2c6bc1fc5330f7" translate="yes" xml:space="preserve">
          <source>A &amp;lt;refspec&amp;gt; may contain a &lt;code&gt;*&lt;/code&gt; in its &amp;lt;src&amp;gt; to indicate a simple pattern match. Such a refspec functions like a glob that matches any ref with the same prefix. A pattern &amp;lt;refspec&amp;gt; must have a &lt;code&gt;*&lt;/code&gt; in both the &amp;lt;src&amp;gt; and &amp;lt;dst&amp;gt;. It will map refs to the destination by replacing the &lt;code&gt;*&lt;/code&gt; with the contents matched from the source.</source>
          <target state="translated">&amp;lt;refspec&amp;gt;은 간단한 패턴 일치를 나타 내기 위해 &amp;lt;src&amp;gt;에 &lt;code&gt;*&lt;/code&gt; 를 포함 할 수 있습니다 . 이러한 refspec은 동일한 접두사를 가진 모든 ref와 일치하는 glob처럼 작동합니다. &amp;lt;refspec&amp;gt; 패턴 은 &amp;lt;src&amp;gt; 및 &amp;lt;dst&amp;gt; 모두에 &lt;code&gt;*&lt;/code&gt; 가 있어야합니다 . &lt;code&gt;*&lt;/code&gt; 를 소스에서 일치하는 내용 으로 대체하여 참조를 대상에 매핑 합니다.</target>
        </trans-unit>
        <trans-unit id="f3ec64c5418b4e1b2393cccdbc573a28510a5c03" translate="yes" xml:space="preserve">
          <source>A 1-based counter incremented by one for every path.</source>
          <target state="translated">모든 경로에 대해 1 씩 증가하는 1 기반 카운터.</target>
        </trans-unit>
        <trans-unit id="0615d3cb94994b8c99f6c3eb1d8a16fe3788d798" translate="yes" xml:space="preserve">
          <source>A 256-entry fan-out table just like v1.</source>
          <target state="translated">v1과 같은 256 개 항목 팬 아웃 테이블.</target>
        </trans-unit>
        <trans-unit id="b5bb9a8b1ee368142624185fa1ae5c67aeb898ce" translate="yes" xml:space="preserve">
          <source>A 4-byte magic number &lt;code&gt;\377tOc&lt;/code&gt; which is an unreasonable fanout[0] value.</source>
          <target state="translated">4 바이트 매직 번호 &lt;code&gt;\377tOc&lt;/code&gt; 로, 팬 아웃 [0] 값이 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="7a1ce6a5d795c5121faecb5f38bcdfbcd91b2ab7" translate="yes" xml:space="preserve">
          <source>A 4-byte version number (= 2)</source>
          <target state="translated">4 바이트 버전 번호 (= 2)</target>
        </trans-unit>
        <trans-unit id="8bede587e880e37efdb2a5ef16eda4ba90c67697" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_blob_object&quot;&gt;&quot;blob&quot; object&lt;/a&gt; is used to store file data.</source>
          <target state="translated">&lt;a href=&quot;#def_blob_object&quot;&gt;&quot;블롭&quot;객체는&lt;/a&gt; 저장소 파일에 데이터를 저장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d54288b35ef53475c72a23d4daf82b2c03c4a8f0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_commit_object&quot;&gt;&quot;commit&quot; object&lt;/a&gt; ties such directory hierarchies together into a &lt;a href=&quot;#def_DAG&quot;&gt;directed acyclic graph&lt;/a&gt; of revisions&amp;mdash;​each commit contains the object name of exactly one tree designating the directory hierarchy at the time of the commit. In addition, a commit refers to &quot;parent&quot; commit objects that describe the history of how we arrived at that directory hierarchy.</source>
          <target state="translated">&lt;a href=&quot;#def_commit_object&quot;&gt;&quot;커밋&quot;객체&lt;/a&gt; 함께에 관계 같은 디렉토리 계층 &lt;a href=&quot;#def_DAG&quot;&gt;감독 비순환 그래프&lt;/a&gt; 각 커밋 revisions-의는 커밋시에 디렉토리 계층을 지정 정확히 하나의 트리의 객체 이름이 포함되어 있습니다. 또한 커밋은 해당 디렉토리 계층에 도달 한 방법에 대한 기록을 설명하는 &quot;부모&quot;커밋 개체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8530617aaaf740a14961ad3389fd991b174e36b0" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt; contains a (possibly empty) list of the logical predecessor(s) in the line of development, i.e. its parents.</source>
          <target state="translated">A는 &lt;a href=&quot;#def_commit_object&quot;&gt;객체가 커밋&lt;/a&gt; 즉 부모, 개발의 라인에 논리 이전의 (비어) 목록 (들)이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb0f59568c969c04ae2919aa1276ec43b776c9bd" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt; or an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; that can be recursively dereferenced to a commit object. The following are all commit-ishes: a commit object, a &lt;a href=&quot;#def_tag_object&quot;&gt;tag object&lt;/a&gt; that points to a commit object, a tag object that points to a tag object that points to a commit object, etc.</source>
          <target state="translated">A는 &lt;a href=&quot;#def_commit_object&quot;&gt;객체 커밋&lt;/a&gt; 또는 &lt;a href=&quot;#def_object&quot;&gt;개체를&lt;/a&gt; 재귀 적으로 역 참조 할 수있는 개체를 커밋합니다. 커밋 개체, 커밋 개체 를 가리키는 &lt;a href=&quot;#def_tag_object&quot;&gt;태그&lt;/a&gt; 개체, 커밋 개체 를 가리키는 태그 개체 등의 커밋은 모두 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e6389313e21c94c3cd1f531678dbaff3d7f4b17f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_ref&quot;&gt;named reference&lt;/a&gt; to the &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; at the tip of a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;. Heads are stored in a file in &lt;code&gt;$GIT_DIR/refs/heads/&lt;/code&gt; directory, except when using packed refs. (See &lt;a href=&quot;git-pack-refs&quot;&gt;git-pack-refs[1]&lt;/a&gt;.)</source>
          <target state="translated">&lt;a href=&quot;#def_branch&quot;&gt;브랜치&lt;/a&gt; 끝에 있는 &lt;a href=&quot;#def_commit&quot;&gt;커밋&lt;/a&gt; 에 대한 &lt;a href=&quot;#def_ref&quot;&gt;명명 된 참조&lt;/a&gt; . 압축 된 참조를 사용하는 경우를 제외하고 &lt;code&gt;$GIT_DIR/refs/heads/&lt;/code&gt; 는 $ GIT_DIR / refs / heads / 디렉토리 의 파일에 저장됩니다 . ( &lt;a href=&quot;git-pack-refs&quot;&gt;git-pack-refs [1]&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="0b389d584563a677fb26744bbc70caa1d1f76e96" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; that is used to follow changes from another &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. It typically looks like 'refs/remotes/foo/bar' (indicating that it tracks a branch named 'bar' in a remote named 'foo'), and matches the right-hand-side of a configured fetch &lt;a href=&quot;#def_refspec&quot;&gt;refspec&lt;/a&gt;. A remote-tracking branch should not contain direct modifications or have local commits made to it.</source>
          <target state="translated">&lt;a href=&quot;#def_ref&quot;&gt;심판이&lt;/a&gt; 서로 변화에 따라하는 데 사용되는 &lt;a href=&quot;#def_repository&quot;&gt;저장소를&lt;/a&gt; . 일반적으로 'refs / remotes / foo / bar'처럼 보이고 ( 'foo'라는 원격에서 'bar'라는 브랜치를 추적 함을 나타냄) 구성된 페치 &lt;a href=&quot;#def_refspec&quot;&gt;refspec&lt;/a&gt; 의 오른쪽을 찾습니다 . 원격 추적 분기에는 직접 수정 사항이 포함되거나 로컬 커밋이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="ace242fdc7f696a4feaa54f7241c321210896890" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; that is used to follow changes from another &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;. It typically looks like &lt;code&gt;refs/remotes/foo/bar&lt;/code&gt; (indicating that it tracks a branch named &lt;code&gt;bar&lt;/code&gt; in a remote named &lt;code&gt;foo&lt;/code&gt;), and matches the right-hand-side of a configured fetch &lt;a href=&quot;#def_refspec&quot;&gt;refspec&lt;/a&gt;. A remote-tracking branch should not contain direct modifications or have local commits made to it.</source>
          <target state="translated">&lt;a href=&quot;#def_ref&quot;&gt;심판이&lt;/a&gt; 서로 변화에 따라하는 데 사용되는 &lt;a href=&quot;#def_repository&quot;&gt;저장소를&lt;/a&gt; . 그것은 일반적으로 보이는 &lt;code&gt;refs/remotes/foo/bar&lt;/code&gt; (이 명명 된 지점 추적 나타내는 &lt;code&gt;bar&lt;/code&gt; 원격 이름에 &lt;code&gt;foo&lt;/code&gt; 는 ) 및 인출하여 구성된의 오른쪽 일치 &lt;a href=&quot;#def_refspec&quot;&gt;refspec를&lt;/a&gt; . 원격 추적 분기에는 직접 수정 사항이 포함되거나 로컬 커밋이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="bbf1d644e82a336ab047afaf23e6c38f6d2319f7" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; under &lt;code&gt;refs/tags/&lt;/code&gt; namespace that points to an object of an arbitrary type (typically a tag points to either a &lt;a href=&quot;#def_tag_object&quot;&gt;tag&lt;/a&gt; or a &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt;). In contrast to a &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;, a tag is not updated by the &lt;code&gt;commit&lt;/code&gt; command. A Git tag has nothing to do with a Lisp tag (which would be called an &lt;a href=&quot;#def_object_type&quot;&gt;object type&lt;/a&gt; in Git&amp;rsquo;s context). A tag is most typically used to mark a particular point in the commit ancestry &lt;a href=&quot;#def_chain&quot;&gt;chain&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;refs/tags/&lt;/code&gt; 네임 스페이스 아래 의 &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; 는 임의의 유형의 객체를 가리 킵니다 (일반적으로 태그는 &lt;a href=&quot;#def_tag_object&quot;&gt;태그&lt;/a&gt; 또는 &lt;a href=&quot;#def_commit_object&quot;&gt;커밋 객체를&lt;/a&gt; 가리 킵니다 ). &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt; 와 달리 &lt;code&gt;commit&lt;/code&gt; 명령 으로 태그가 업데이트되지 않습니다 . Git 태그는 Lisp 태그 ( Git 컨텍스트에서 &lt;a href=&quot;#def_object_type&quot;&gt;객체 유형&lt;/a&gt; 이라고 함)와 관련이 없습니다 . 태그는 가장 일반적으로 확약 &lt;a href=&quot;#def_chain&quot;&gt;체인&lt;/a&gt; 에서 특정 지점을 표시하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc46cfe77ce6b43ff04fe1e7aebea708602c159d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; that holds the history of a separate project inside another repository (the latter of which is called &lt;a href=&quot;#def_superproject&quot;&gt;superproject&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#def_repository&quot;&gt;저장소&lt;/a&gt; 다른 저장소 내부에 별도의 프로젝트 (후자의 호출의 이력 보유 &lt;a href=&quot;#def_superproject&quot;&gt;superproject을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6438f4d0a1f63f0722cdeaf18b4e76a69d1faf0a" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; that references repositories of other projects in its working tree as &lt;a href=&quot;#def_submodule&quot;&gt;submodules&lt;/a&gt;. The superproject knows about the names of (but does not hold copies of) commit objects of the contained submodules.</source>
          <target state="translated">&lt;a href=&quot;#def_repository&quot;&gt;저장소&lt;/a&gt; 등의 작업 트리에서 다른 프로젝트의 참조 저장소가 &lt;a href=&quot;#def_submodule&quot;&gt;서브 모듈&lt;/a&gt; . 수퍼 프로젝트는 포함 된 서브 모듈의 커밋 객체의 이름을 알고 있지만 사본을 보유하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c5fd39e912fa9dd55cd15e3992de80c831bb2a4" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; which is used to track the same project but resides somewhere else. To communicate with remotes, see &lt;a href=&quot;#def_fetch&quot;&gt;fetch&lt;/a&gt; or &lt;a href=&quot;#def_push&quot;&gt;push&lt;/a&gt;.</source>
          <target state="translated">동일한 프로젝트를 추적하는 데 사용되지만 다른 곳에 상주 하는 &lt;a href=&quot;#def_repository&quot;&gt;저장소&lt;/a&gt; 입니다. 리모컨과 통신하려면 &lt;a href=&quot;#def_fetch&quot;&gt;가져 오기&lt;/a&gt; 또는 &lt;a href=&quot;#def_push&quot;&gt;푸시를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="328013b8812fa91caece6ff64eff68b5bce54efc" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_shallow_clone&quot;&gt;shallow clone&lt;/a&gt; is created by specifying the &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;&lt;code&gt;--depth&lt;/code&gt; switch. The depth can later be changed with the &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;&lt;code&gt;--depth&lt;/code&gt; switch, or full history restored with &lt;code&gt;--unshallow&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_shallow_clone&quot;&gt;얕은 클론&lt;/a&gt; 시방하여 만든 &lt;a href=&quot;git-clone&quot;&gt;자식 클론 [1] &lt;/a&gt; &lt;code&gt;--depth&lt;/code&gt; 스위치. 나중에 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1] &lt;/a&gt; &lt;code&gt;--depth&lt;/code&gt; 스위치로 깊이를 변경 하거나 &lt;code&gt;--unshallow&lt;/code&gt; 로 전체 히스토리를 복원 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f6e57120855e95e9e182d5d994eedc42293e0e9" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_shallow_clone&quot;&gt;shallow clone&lt;/a&gt;, with its truncated history, is useful when one is interested only in recent history of a project and getting full history from the upstream is expensive.</source>
          <target state="translated">&lt;a href=&quot;#def_shallow_clone&quot;&gt;얕은 클론은&lt;/a&gt; 하나의 프로젝트의 최근 역사에만 관심 상류가 비싸다에서 전체 역사를 얻는 경우, 그 잘린 역사를 가진 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5a5040a665f644abaf265d1f9e647b81d27b4cfd" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_tag_object&quot;&gt;&quot;tag&quot; object&lt;/a&gt; symbolically identifies and can be used to sign other objects. It contains the object name and type of another object, a symbolic name (of course!) and, optionally, a signature.</source>
          <target state="translated">&lt;a href=&quot;#def_tag_object&quot;&gt;&quot;태그&quot;개체의&lt;/a&gt; 상징적 식별하고 다른 개체에 서명하는 데 사용할 수 있습니다. 여기에는 다른 객체의 객체 이름과 유형, 기호 이름 (물론!) 및 선택적으로 서명이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="300bf6998ca24b2549892a071c929ed803f223bb" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_tree_object&quot;&gt;&quot;tree&quot; object&lt;/a&gt; ties one or more &quot;blob&quot; objects into a directory structure. In addition, a tree object can refer to other tree objects, thus creating a directory hierarchy.</source>
          <target state="translated">&lt;a href=&quot;#def_tree_object&quot;&gt;&quot;트리&quot;객체&lt;/a&gt; 디렉토리 구조에 관계 하나 이상의 &quot;블롭&quot;객체. 또한 트리 객체는 다른 트리 객체를 참조하여 디렉토리 계층을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7b0ce7b8c7522d74c7f9ad5ab8411731aaf299c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_tree_object&quot;&gt;tree object&lt;/a&gt; or an &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; that can be recursively dereferenced to a tree object. Dereferencing a &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt; yields the tree object corresponding to the &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt;'s top &lt;a href=&quot;#def_directory&quot;&gt;directory&lt;/a&gt;. The following are all tree-ishes: a &lt;a href=&quot;#def_commit-ish&quot;&gt;commit-ish&lt;/a&gt;, a tree object, a &lt;a href=&quot;#def_tag_object&quot;&gt;tag object&lt;/a&gt; that points to a tree object, a tag object that points to a tag object that points to a tree object, etc.</source>
          <target state="translated">&lt;a href=&quot;#def_tree_object&quot;&gt;트리 객체&lt;/a&gt; 또는 &lt;a href=&quot;#def_object&quot;&gt;객체&lt;/a&gt; 재귀 트리 객체 참조를 취소 할 수 있습니다. &lt;a href=&quot;#def_commit_object&quot;&gt;커밋 객체를&lt;/a&gt; 역 참조 하면 &lt;a href=&quot;#def_revision&quot;&gt;개정판&lt;/a&gt; 의 최상위 &lt;a href=&quot;#def_directory&quot;&gt;디렉토리에&lt;/a&gt; 해당하는 트리 객체가 생성 됩니다. &lt;a href=&quot;#def_commit-ish&quot;&gt;커밋&lt;/a&gt; -ish , 트리 객체, 트리 객체 를 가리키는 &lt;a href=&quot;#def_tag_object&quot;&gt;태그&lt;/a&gt; 객체, 트리 객체 를 가리키는 태그 객체 를 가리키는 태그 객체 등 은 모두 트리-아이시 입니다.</target>
        </trans-unit>
        <trans-unit id="6766aaa194eae4342acb9b6eb8fe5dbb99ba5e2c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; is clean, if it corresponds to the &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt; referenced by the current &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;. Also see &quot;&lt;a href=&quot;#def_dirty&quot;&gt;dirty&lt;/a&gt;&quot;.</source>
          <target state="translated">&lt;a href=&quot;#def_working_tree&quot;&gt;작업 트리&lt;/a&gt; 가에 해당하는 경우, 깨끗한 &lt;a href=&quot;#def_revision&quot;&gt;개정&lt;/a&gt; 전류에 의해 참조 된 &lt;a href=&quot;#def_head&quot;&gt;머리&lt;/a&gt; . &quot; &lt;a href=&quot;#def_dirty&quot;&gt;더티&lt;/a&gt; &quot; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="910148d563c361f2f9ac9396584595cbecacd2d1" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt; is said to be &quot;dirty&quot; if it contains modifications which have not been &lt;a href=&quot;#def_commit&quot;&gt;committed&lt;/a&gt; to the current &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_working_tree&quot;&gt;작업 트리&lt;/a&gt; 가되지 않은 수정이 포함 된 경우 &quot;더러운&quot;이라고합니다 &lt;a href=&quot;#def_commit&quot;&gt;최선을 다하고&lt;/a&gt; 현재에 &lt;a href=&quot;#def_branch&quot;&gt;지점을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cef23a772a587d1dc5174a039d5d2a56a2421b3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; string must use UNIX-style directory separators (forward slash &lt;code&gt;/&lt;/code&gt;), may contain any byte other than &lt;code&gt;LF&lt;/code&gt;, and must not start with double quote (&lt;code&gt;&quot;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 문자열 (슬래시 UNIX 스타일 디렉토리 구분 기호를 사용해야합니다 &lt;code&gt;/&lt;/code&gt; 이외의 바이트 포함 할 수있다) &lt;code&gt;LF&lt;/code&gt; 를 하고, 큰 따옴표 (로 시작할 수 없습니다 &lt;code&gt;&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="25aaa39fff8a33da0ed231c681da2d1cc8f12d2e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; specification can be either a single pattern, or a pair of such patterns separated by a colon &quot;:&quot; (this means that a ref name cannot have a colon in it). A single pattern &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is just a shorthand for &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 명세서 단일 패턴, 혹은 패턴의 쌍 콜론으로 구분 될 수 있습니다 &quot;&quot;(a REF 이름 그것에 결장을 가질 수 있음이 수단). 단일 패턴 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 은 &lt;code&gt;&amp;lt;name&amp;gt;:&amp;lt;name&amp;gt;&lt;/code&gt; 의 약어입니다 .</target>
        </trans-unit>
        <trans-unit id="5e4a35cc1f6ad4a24fbad41012f4dee139cf11ca" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;-&lt;/code&gt; character in the column N means that the line appears in fileN but it does not appear in the result. A &lt;code&gt;+&lt;/code&gt; character in the column N means that the line appears in the result, and fileN does not have that line (in other words, the line was added, from the point of view of that parent).</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 열 N 수단에 문자가있는 줄은 fileN에 표시하지만 결과에 표시되지 않습니다. &lt;code&gt;+&lt;/code&gt; 의 광고가 결과에 나타날 fileN 그 라인이 없다는 열 N 수단에 문자 (즉에서, 라인은 부모의 관점에서 첨가 하였다).</target>
        </trans-unit>
        <trans-unit id="2f763d8aeb342898c485136e58023ca41a911c41" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;fetch&lt;/code&gt; request can take the following arguments:</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 요청은 다음 인수를 취할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cdc49de55f827e970a03efc67dad77118b50f2b5" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;filecopy&lt;/code&gt; command takes effect immediately. Once the source location has been copied to the destination any future commands applied to the source location will not impact the destination of the copy.</source>
          <target state="translated">&lt;code&gt;filecopy&lt;/code&gt; 명령은 즉시 적용됩니다. 소스 위치가 대상에 복사되면 소스 위치에 적용된 이후의 명령은 사본의 대상에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b84f934e1b33bd4484622bc003d74b0f10abf36" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;filerename&lt;/code&gt; command takes effect immediately. Once the source location has been renamed to the destination any future commands applied to the source location will create new files there and not impact the destination of the rename.</source>
          <target state="translated">&lt;code&gt;filerename&lt;/code&gt; 의 명령은 즉시 적용됩니다. 소스 위치의 이름이 대상으로 바뀌면 소스 위치에 적용된 이후의 명령으로 새 파일이 만들어지고 이름을 바꾸는 대상에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e7ce3d61d685b39ad1b7df023b9aae5356d34434" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;filter&lt;/code&gt; attribute can be set to a string value that names a filter driver specified in the configuration.</source>
          <target state="translated">&lt;code&gt;filter&lt;/code&gt; 특성은 필터 드라이버 구성에서 지정된 이름에있는 스트링 값으로 설정 될 수있다.</target>
        </trans-unit>
        <trans-unit id="ca1b84b3e4f681759dcd049b031dfc1f3c0de5ed" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;gitattributes&lt;/code&gt; file is a simple text file that gives &lt;code&gt;attributes&lt;/code&gt; to pathnames.</source>
          <target state="translated">&lt;code&gt;gitattributes&lt;/code&gt; 의 파일을 제공하는 간단한 텍스트 파일 &lt;code&gt;attributes&lt;/code&gt; 경로 이름에 있습니다.</target>
        </trans-unit>
        <trans-unit id="d66ea4477ef0ba53ddd8e40294e2410ce0649ca9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;gitignore&lt;/code&gt; file specifies intentionally untracked files that Git should ignore. Files already tracked by Git are not affected; see the NOTES below for details.</source>
          <target state="translated">&lt;code&gt;gitignore&lt;/code&gt; 의 파일이 망할 놈의 무시하도록 의도적으로 비 추적 파일을 지정합니다. Git이 이미 추적 한 파일은 영향을받지 않습니다. 자세한 내용은 아래 참고를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6e637494c00a4030e3a229e0cf561d46671742b0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;map&lt;/code&gt; function is available that takes an &quot;original sha1 id&quot; argument and outputs a &quot;rewritten sha1 id&quot; if the commit has been already rewritten, and &quot;original sha1 id&quot; otherwise; the &lt;code&gt;map&lt;/code&gt; function can return several ids on separate lines if your commit filter emitted multiple commits.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 함수는 달리 &quot;원래 SHA1 ID를&quot;는 &quot;일본어 SHA1 ID를&quot;인수를 취하고 이미 재 기입 된 경우 커밋 &quot;재기록 SHA1 ID&quot;를 출력하고, 그 유효하다; &lt;code&gt;map&lt;/code&gt; 커밋 필터가 여러 커밋을 방출하는 경우 기능은 별도의 줄에 여러 개의 ID를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0c17077eaabfda4b09416a4110316c7774b1c6b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;mark&lt;/code&gt; command may optionally appear, requesting fast-import to save a reference to the newly created commit for future use by the frontend (see below for format). It is very common for frontends to mark every commit they create, thereby allowing future branch creation from any imported commit.</source>
          <target state="translated">프론트 엔드에서 나중에 사용하기 위해 새로 작성된 커밋에 대한 참조를 저장하기 위해 빠른 가져 오기를 요청 하는 &lt;code&gt;mark&lt;/code&gt; 명령이 선택적으로 나타날 수 있습니다 (아래 형식 참조). 프런트 엔드가 생성하는 모든 커밋을 표시하는 것은 매우 일반적이므로 가져온 커밋에서 향후 분기를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b43e35048f39cc98d8056bd70595785c095f7f4" translate="yes" xml:space="preserve">
          <source>A CVS server emulator for Git</source>
          <target state="translated">Git 용 CVS 서버 에뮬레이터</target>
        </trans-unit>
        <trans-unit id="3e3ff03f4c98647bf647b09b5bdb954580631a8b" translate="yes" xml:space="preserve">
          <source>A Git Glossary</source>
          <target state="translated">Git 용어집</target>
        </trans-unit>
        <trans-unit id="73c6af424b5233a47f9e018124045fddd95ea342" translate="yes" xml:space="preserve">
          <source>A Git core tutorial for developers</source>
          <target state="translated">개발자를위한 Git 핵심 튜토리얼</target>
        </trans-unit>
        <trans-unit id="499e3b350610a0a7f42474bdeb7c1c19319ba58c" translate="yes" xml:space="preserve">
          <source>A Git project normally consists of a working directory with a &quot;.git&quot; subdirectory at the top level. The .git directory contains, among other things, a compressed object database representing the complete history of the project, an &quot;index&quot; file which links that history to the current contents of the working tree, and named pointers into that history such as tags and branch heads.</source>
          <target state="translated">Git 프로젝트는 일반적으로 최상위 레벨에 &quot;.git&quot;서브 디렉토리가있는 작업 디렉토리로 구성됩니다. .git 디렉토리에는 프로젝트의 전체 히스토리를 나타내는 압축 된 오브젝트 데이터베이스, 해당 히스토리를 작업 트리의 현재 컨텐츠에 링크하는 &quot;인덱스&quot;파일 및 태그 및 분기 헤드.</target>
        </trans-unit>
        <trans-unit id="25a40623b731bcb70270f3faeba427fe44362569" translate="yes" xml:space="preserve">
          <source>A Git repository comes in two different flavours:</source>
          <target state="translated">Git 저장소는 다음과 같은 두 가지 맛으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d81aa8115ce6f03214fb303ff61bdf68ead1b6d0" translate="yes" xml:space="preserve">
          <source>A GnuPG signed tag object will be created when &lt;code&gt;-s&lt;/code&gt; or &lt;code&gt;-u
&amp;lt;keyid&amp;gt;&lt;/code&gt; is used. When &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; is not used, the committer identity for the current user is used to find the GnuPG key for signing. The configuration variable &lt;code&gt;gpg.program&lt;/code&gt; is used to specify custom GnuPG binary.</source>
          <target state="translated">&lt;code&gt;-s&lt;/code&gt; 또는 &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 를 사용 하면 GnuPG 서명 태그 객체가 생성 됩니다. 때 &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 사용되지 않는, 현재 사용자의 커미터 ID는 서명에 대한 GnuPG는 키를 찾는 데 사용됩니다. 구성 변수 &lt;code&gt;gpg.program&lt;/code&gt; 은 사용자 정의 GnuPG 바이너리를 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="79ace8057741243c07f0a9c439ea72cf149ebea7" translate="yes" xml:space="preserve">
          <source>A POSIX Extended Regular Expression used to determine what is a &quot;word&quot; when performing word-by-word difference calculations. Character sequences that match the regular expression are &quot;words&quot;, all other characters are &lt;strong&gt;ignorable&lt;/strong&gt; whitespace.</source>
          <target state="translated">단어 별 차이 계산을 수행 할 때 &quot;워드&quot;가 무엇인지 확인하는 데 사용되는 POSIX 확장 정규식입니다. 정규식과 일치하는 문자 시퀀스는 &quot;단어&quot;이며 다른 모든 문자는 &lt;strong&gt;무시할 수있는&lt;/strong&gt; 공백입니다.</target>
        </trans-unit>
        <trans-unit id="d4b36e18a0d1a006f1ac7d7980a588087d5b430d" translate="yes" xml:space="preserve">
          <source>A Tcl/Tk based graphical interface to review modified files, stage them into the index, enter a commit message and record the new commit onto the current branch. This interface is an alternative to the less interactive &lt;code&gt;git commit&lt;/code&gt; program.</source>
          <target state="translated">Tcl / Tk 기반 그래픽 인터페이스는 수정 된 파일을 검토하고, 색인으로 파일을 스테이징하고, 커밋 메시지를 입력하고 현재 커밋에 새 커밋을 기록합니다. 이 인터페이스는 대화식이 아닌 &lt;code&gt;git commit&lt;/code&gt; 프로그램 의 대안 입니다.</target>
        </trans-unit>
        <trans-unit id="4b96204f8a09a4e60b67d30c184c76ab3aa13246" translate="yes" xml:space="preserve">
          <source>A Tcl/Tk based graphical user interface to Git. &lt;code&gt;git gui&lt;/code&gt; focuses on allowing users to make changes to their repository by making new commits, amending existing ones, creating branches, performing local merges, and fetching/pushing to remote repositories.</source>
          <target state="translated">Git에 대한 Tcl / Tk 기반 그래픽 사용자 인터페이스. &lt;code&gt;git gui&lt;/code&gt; 는 새로운 커밋, 기존 커밋 수정, 브랜치 생성, 로컬 병합 수행 및 원격 리포지토리에 대한 페치 / 푸시를 통해 사용자가 리포지토리를 변경할 수 있도록하는 데 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="24909c1b0660496a6bde046217501091c32d35a8" translate="yes" xml:space="preserve">
          <source>A URL identifying the server. Use an &lt;code&gt;imap://&lt;/code&gt; prefix for non-secure connections and an &lt;code&gt;imaps://&lt;/code&gt; prefix for secure connections. Ignored when imap.tunnel is set, but required otherwise.</source>
          <target state="translated">서버를 식별하는 URL 비보안 연결 에는 &lt;code&gt;imap://&lt;/code&gt; 접두사를 사용하고 보안 연결에는 &lt;code&gt;imaps://&lt;/code&gt; 접두사를 사용하십시오. imap.tunnel이 설정되면 무시되지만 그렇지 않으면 필요합니다.</target>
        </trans-unit>
        <trans-unit id="11e4f1c46822a29c15a31d1976020e3202745e04" translate="yes" xml:space="preserve">
          <source>A URL of the form &lt;code&gt;&amp;lt;transport&amp;gt;::&amp;lt;address&amp;gt;&lt;/code&gt; explicitly instructs Git to invoke &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; with &lt;code&gt;&amp;lt;address&amp;gt;&lt;/code&gt; as the second argument. If such a URL is encountered directly on the command line, the first argument is &lt;code&gt;&amp;lt;address&amp;gt;&lt;/code&gt;, and if it is encountered in a configured remote, the first argument is the name of that remote.</source>
          <target state="translated">형태의 URL은 &lt;code&gt;&amp;lt;transport&amp;gt;::&amp;lt;address&amp;gt;&lt;/code&gt; 명시 적으로 망할 놈의 지시 호출 &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; 와 &lt;code&gt;&amp;lt;address&amp;gt;&lt;/code&gt; 두 번째 인수로. 이러한 URL이 명령 행에서 직접 발견되면 첫 번째 인수는 &lt;code&gt;&amp;lt;address&amp;gt;&lt;/code&gt; 이고 구성된 원격지에서 발견되는 경우 첫 번째 인수는 해당 리모트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="bd88b7183354ef38e42a5694ea11c6ad40c90a63" translate="yes" xml:space="preserve">
          <source>A bare repository is normally an appropriately named &lt;a href=&quot;#def_directory&quot;&gt;directory&lt;/a&gt; with a &lt;code&gt;.git&lt;/code&gt; suffix that does not have a locally checked-out copy of any of the files under revision control. That is, all of the Git administrative and control files that would normally be present in the hidden &lt;code&gt;.git&lt;/code&gt; sub-directory are directly present in the &lt;code&gt;repository.git&lt;/code&gt; directory instead, and no other files are present and checked out. Usually publishers of public repositories make bare repositories available.</source>
          <target state="translated">베어 리포지토리는 일반적으로 &lt;code&gt;.git&lt;/code&gt; 접미사가 있는 적절한 이름을 가진 &lt;a href=&quot;#def_directory&quot;&gt;디렉토리&lt;/a&gt; 로, 버전 관리 대상 파일의 로컬에서 체크 아웃 된 복사본이 없습니다. 즉, 일반적으로 숨겨진 &lt;code&gt;.git&lt;/code&gt; 하위 디렉토리에 존재하는 모든 Git 관리 및 제어 파일은 대신 &lt;code&gt;repository.git&lt;/code&gt; 디렉토리 에 직접 존재하며 다른 파일은 존재하지 않고 체크 아웃되지 않습니다. 일반적으로 공용 리포지토리 게시자는 베어 리포지토리를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fab59df7bed21e1355a3a3fdd6c1ee8b01aad2ba" translate="yes" xml:space="preserve">
          <source>A birds-eye view of Git&amp;rsquo;s source code</source>
          <target state="translated">Git 소스 코드의 조감도</target>
        </trans-unit>
        <trans-unit id="23e4eeef8aa3fdcfbc58a9b30e01464d317f5146" translate="yes" xml:space="preserve">
          <source>A bit more elaborate report on tags, demonstrating that the format may be an entire script:</source>
          <target state="translated">형식이 전체 스크립트 일 수 있음을 보여주는 태그에 대한 좀 더 정교한 보고서</target>
        </trans-unit>
        <trans-unit id="146b6a7f060c34e94845d66a1242bb6c9a7f4e58" translate="yes" xml:space="preserve">
          <source>A blank line matches no files, so it can serve as a separator for readability.</source>
          <target state="translated">빈 줄은 파일과 일치하지 않으므로 가독성을 위해 구분 기호로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="556a519047d3c2b7e5ab74e824666155b316bdbf" translate="yes" xml:space="preserve">
          <source>A boolean or int to specify the level of verbose with &lt;code&gt;git commit&lt;/code&gt;. See &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;.</source>
          <target state="translated">부울 또는 INT는와 상세 수준을 지정하는 &lt;code&gt;git commit&lt;/code&gt; . &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="df9e4313a71ccb8b0351ad99469fa4eb3f3f9ac9" translate="yes" xml:space="preserve">
          <source>A boolean that controls whether to generate a cover-letter when format-patch is invoked, but in addition can be set to &quot;auto&quot;, to generate a cover-letter only when there&amp;rsquo;s more than one patch. Default is false.</source>
          <target state="translated">format-patch가 호출 될 때 표지 문자를 생성할지 여부를 제어하는 ​​부울 (boolean). 또한 &quot;auto&quot;로 설정하여 패치가 둘 이상인 경우에만 표지를 생성 할 수 있습니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="5594a28e2c0e4043dd1d1bbbff86fb17f935ca8e" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in hints (e.g. when a push failed, see &lt;code&gt;advice.*&lt;/code&gt; for a list). May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the error output goes to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">힌트에서 색상을 활성화 / 비활성화하는 부울입니다 (예 : 푸시에 실패한 경우 &lt;code&gt;advice.*&lt;/code&gt; 참조하십시오 . * 목록). &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; (또는 &lt;code&gt;never&lt;/code&gt; ) 또는 &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt; ) 로 설정 될 수 있으며 ,이 경우 색상은 오류 출력이 터미널에 전달 될 때만 사용됩니다. 설정하지 않으면 &lt;code&gt;color.ui&lt;/code&gt; 의 값 이 사용됩니다 ( 기본적으로 &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2fbf675a2936dcecf3b1a2336c5df4b332604e58" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in push errors. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the error output goes to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">푸시 오류에서 색상을 활성화 / 비활성화하는 부울입니다. &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; (또는 &lt;code&gt;never&lt;/code&gt; ) 또는 &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt; ) 로 설정 될 수 있으며 ,이 경우 색상은 오류 출력이 터미널에 전달 될 때만 사용됩니다. 설정하지 않으면 &lt;code&gt;color.ui&lt;/code&gt; 의 값 이 사용됩니다 ( 기본적으로 &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="423a3d788dfbe4bee04a423e0b36c0319dcd4d83" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in the output of &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt;. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the output is to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">&lt;a href=&quot;git-branch&quot;&gt;git-branch [1]&lt;/a&gt; 의 출력에서 ​​색상을 활성화 / 비활성화하는 부울 입니다. &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; (또는 &lt;code&gt;never&lt;/code&gt; ) 또는 &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt; ) 로 설정 될 수 있으며 ,이 경우 색상이 출력이 터미널에있을 때만 사용됩니다. 설정하지 않으면 &lt;code&gt;color.ui&lt;/code&gt; 의 값 이 사용됩니다 ( 기본적으로 &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6f2e2c7e2ba4cb7674d5cd8117d8f0b42a85dae9" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in the output of &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt;. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the output is to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">&lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt; 의 출력에서 ​​색상을 활성화 / 비활성화하는 부울 입니다. &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; (또는 &lt;code&gt;never&lt;/code&gt; ) 또는 &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt; ) 로 설정 될 수 있으며 ,이 경우 색상이 출력이 터미널에있을 때만 사용됩니다. 설정하지 않으면 &lt;code&gt;color.ui&lt;/code&gt; 의 값 이 사용됩니다 ( 기본적으로 &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fd3e78cce49781de5f532bd4c5e0796c9098f940" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color in the output of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt;. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the output is to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">&lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 의 출력에서 ​​색상을 활성화 / 비활성화하는 부울 입니다. &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; (또는 &lt;code&gt;never&lt;/code&gt; ) 또는 &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt; ) 로 설정 될 수 있으며 ,이 경우 색상이 출력이 터미널에있을 때만 사용됩니다. 설정하지 않으면 &lt;code&gt;color.ui&lt;/code&gt; 의 값 이 사용됩니다 ( 기본적으로 &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="297391e190582ac1cb26cf2a45a94d7b84f1e151" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable color when pushes are rejected. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;), in which case colors are used only when the error output goes to a terminal. If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">푸시가 거부 될 때 색상을 활성화 / 비활성화하는 부울입니다. &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; (또는 &lt;code&gt;never&lt;/code&gt; ) 또는 &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt; ) 로 설정 될 수 있으며 ,이 경우 색상은 오류 출력이 터미널에 전달 될 때만 사용됩니다. 설정하지 않으면 &lt;code&gt;color.ui&lt;/code&gt; 의 값 이 사용됩니다 ( 기본적으로 &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7bd8faf8bbae108bc3e3db709a35680c5dec839a" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable colored output when the pager is in use (default is true).</source>
          <target state="translated">호출기가 사용 중일 때 컬러 출력을 활성화 / 비활성화하는 부울입니다 (기본값은 true).</target>
        </trans-unit>
        <trans-unit id="d29f1ced583e3f5a70811c52e97c2481cc279f73" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable inclusion of status information in the commit message template when using an editor to prepare the commit message. Defaults to true.</source>
          <target state="translated">편집기를 사용하여 커밋 메시지를 준비 할 때 커밋 메시지 템플릿에 상태 정보 포함을 활성화 / 비활성화하는 부울입니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="c2d858807e8af6ae2203a74b627cef96e1757782" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable the use of html encoding when sending a patch. An html encoded patch will be bracketed with &amp;lt;pre&amp;gt; and have a content type of text/html. Ironically, enabling this option causes Thunderbird to send the patch as a plain/text, format=fixed email. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">패치를 보낼 때 html 인코딩 사용을 활성화 / 비활성화하는 부울입니다. html로 인코딩 된 패치는 &amp;lt;pre&amp;gt;로 묶고 컨텐츠 유형은 text / html입니다. 아이러니하게도이 옵션을 활성화하면 Thunderbird가 일반 / 텍스트 형식 = 고정 전자 메일로 패치를 보냅니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a3f4c2eeab634e1e21aa0984b28bad1eef24f55b" translate="yes" xml:space="preserve">
          <source>A boolean to enable/disable verification of the server certificate used by the SSL/TLS connection. Default is &lt;code&gt;true&lt;/code&gt;. Ignored when imap.tunnel is set.</source>
          <target state="translated">SSL / TLS 연결에 사용되는 서버 인증서의 검증을 활성화 / 비활성화하는 부울입니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다. imap.tunnel이 설정되면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2ba56edef0f759e6a6fb72f98e61ae0b81ab53f7" translate="yes" xml:space="preserve">
          <source>A boolean to inhibit the standard behavior of printing a space before each empty output line. Defaults to false.</source>
          <target state="translated">빈 출력 라인 앞에 공백을 인쇄하는 표준 동작을 억제하는 부울입니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="aa4f8a419cff5bc7a9aa83bbb22ddc4383ad75de" translate="yes" xml:space="preserve">
          <source>A boolean to make git-clean do nothing unless given -f, -i or -n. Defaults to true.</source>
          <target state="translated">git-clean을 만드는 부울은 -f, -i 또는 -n을 지정하지 않으면 아무 작업도 수행하지 않습니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="8ac4f1587b4bbb5651120aa9065e93380285e902" translate="yes" xml:space="preserve">
          <source>A boolean to specify whether all commits should be GPG signed. Use of this option when doing operations such as rebase can result in a large number of commits being signed. It may be convenient to use an agent to avoid typing your GPG passphrase several times.</source>
          <target state="translated">모든 커밋을 GPG 서명해야하는지 여부를 지정하는 부울입니다. rebase와 같은 작업을 수행 할 때이 옵션을 사용하면 많은 수의 커밋이 서명 될 수 있습니다. GPG 암호 문구를 여러 번 입력하지 않도록 에이전트를 사용하는 것이 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="285446918c9332ac6592ad772bc51e35d0bb94c4" translate="yes" xml:space="preserve">
          <source>A boolean to specify whether all tags should be GPG signed. Use of this option when running in an automated script can result in a large number of tags being signed. It is therefore convenient to use an agent to avoid typing your gpg passphrase several times. Note that this option doesn&amp;rsquo;t affect tag signing behavior enabled by &quot;-u &amp;lt;keyid&amp;gt;&quot; or &quot;--local-user=&amp;lt;keyid&amp;gt;&quot; options.</source>
          <target state="translated">모든 태그를 GPG 서명해야하는지 여부를 지정하는 부울입니다. 자동화 된 스크립트에서 실행할 때이 옵션을 사용하면 많은 수의 태그가 서명 될 수 있습니다. 따라서 gpg 암호 문구를 여러 번 입력하지 않도록 에이전트를 사용하는 것이 편리합니다. 이 옵션은 &quot;-u &amp;lt;keyid&amp;gt;&quot;또는 &quot;--local-user = &amp;lt;keyid&amp;gt;&quot;옵션으로 활성화 된 태그 서명 동작에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8196128852a99f0296cb3a9178bf0edc9d5e344a" translate="yes" xml:space="preserve">
          <source>A boolean to specify whether annotated tags created should be GPG signed. If &lt;code&gt;--annotate&lt;/code&gt; is specified on the command line, it takes precedence over this option.</source>
          <target state="translated">작성된 주석이 달린 태그를 GPG 서명해야하는지 여부를 지정하는 부울입니다. 명령 줄에 &lt;code&gt;--annotate&lt;/code&gt; 를 지정 하면 이 옵션보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="e95ae970d328003d484aaeb100825d3fb66dda25" translate="yes" xml:space="preserve">
          <source>A boolean value which lets you enable the &lt;code&gt;--base=auto&lt;/code&gt; option of format-patch by default.</source>
          <target state="translated">기본적으로 format-patch 의 &lt;code&gt;--base=auto&lt;/code&gt; 옵션 을 활성화 할 수있는 부울 값입니다 .</target>
        </trans-unit>
        <trans-unit id="a980cf709aa06b2fd9c4272bf89b914aa272bf0a" translate="yes" xml:space="preserve">
          <source>A boolean value which lets you enable the &lt;code&gt;--base=auto&lt;/code&gt; option of format-patch by default. Can also be set to &quot;whenAble&quot; to allow enabling &lt;code&gt;--base=auto&lt;/code&gt; if a suitable base is available, but to skip adding base info otherwise without the format dying.</source>
          <target state="translated">기본적으로 format-patch 의 &lt;code&gt;--base=auto&lt;/code&gt; 옵션 을 활성화 할 수있는 부울 값입니다 . 또한 &quot;whenAble&quot;로 설정하여 적합한베이스를 사용할 수있는 경우 &lt;code&gt;--base=auto&lt;/code&gt; 를 활성화 할 수 있지만 그렇지 않으면 형식이 죽지 않고베이스 정보 추가를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98939eb557a27a368986b34536ff6c8cd4c36abd" translate="yes" xml:space="preserve">
          <source>A boolean value which lets you enable the &lt;code&gt;-s/--signoff&lt;/code&gt; option of format-patch by default. &lt;strong&gt;Note:&lt;/strong&gt; Adding the Signed-off-by: line to a patch should be a conscious act and means that you certify you have the rights to submit this work under the same open source license. Please see the &lt;code&gt;SubmittingPatches&lt;/code&gt; document for further discussion.</source>
          <target state="translated">기본적으로 format-patch 의 &lt;code&gt;-s/--signoff&lt;/code&gt; 옵션 을 활성화 할 수있는 부울 값입니다 . &lt;strong&gt;참고 :&lt;/strong&gt; Signed-off-by :: 행을 패치에 추가하는 것은 의식적인 행동이어야하며 동일한 오픈 소스 라이센스 하에서이 작품을 제출할 권한이 있음을 증명합니다. 자세한 내용은 &lt;code&gt;SubmittingPatches&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="52843a970e21e2ecc8fa28c4ccdfeaf085918760" translate="yes" xml:space="preserve">
          <source>A boolean which can enable or disable sequence numbers in patch subjects. It defaults to &quot;auto&quot; which enables it only if there is more than one patch. It can be enabled or disabled for all messages by setting it to &quot;true&quot; or &quot;false&quot;. See --numbered option in &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">패치 주제에서 시퀀스 번호를 활성화 또는 비활성화 할 수있는 부울입니다. 기본적으로 &quot;auto&quot;로 설정되어 패치가 둘 이상있는 경우에만 활성화됩니다. &quot;true&quot;또는 &quot;false&quot;로 설정하여 모든 메시지에 대해 활성화 또는 비활성화 할 수 있습니다. &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]의&lt;/a&gt; --numbered 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4eaf2f30624eb10b8aee0a4842fe24fd9d5d1733" translate="yes" xml:space="preserve">
          <source>A boolean which disables using of EPSV ftp command by curl. This can helpful with some &quot;poor&quot; ftp servers which don&amp;rsquo;t support EPSV mode. Can be overridden by the &lt;code&gt;GIT_CURL_FTP_NO_EPSV&lt;/code&gt; environment variable. Default is false (curl will use EPSV).</source>
          <target state="translated">curl에 의한 EPSV ftp 명령 사용을 비활성화하는 부울입니다. EPSV 모드를 지원하지 않는 일부 &quot;불량한&quot;ftp 서버에서 유용합니다. &lt;code&gt;GIT_CURL_FTP_NO_EPSV&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 . 기본값은 false입니다 (컬은 EPSV를 사용함).</target>
        </trans-unit>
        <trans-unit id="a40656baca50661122d33e0890da13d751ed316a" translate="yes" xml:space="preserve">
          <source>A built-in pattern is provided for all languages listed in the previous section.</source>
          <target state="translated">이전 섹션에 나열된 모든 언어에 대해 기본 제공 패턴이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="302353030177edeeb70686cd4f5139eb1acdd092" translate="yes" xml:space="preserve">
          <source>A bundle from a recipient repository&amp;rsquo;s point of view is just like a regular repository which it fetches or pulls from. You can, for example, map references when fetching:</source>
          <target state="translated">수신자 저장소 관점의 번들은 가져 오거나 가져 오는 일반 저장소와 같습니다. 예를 들어 페치를 할 때 참조를 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a5fcdefb11694692ac802e09961aef7e73e5df0" translate="yes" xml:space="preserve">
          <source>A caveat is that older reflog entries in your repository may be expired by &lt;code&gt;git gc&lt;/code&gt;. If B0 no longer appears in the reflog of the remote-tracking branch &lt;code&gt;origin/master&lt;/code&gt;, the &lt;code&gt;--fork-point&lt;/code&gt; mode obviously cannot find it and fails, avoiding to give a random and useless result (such as the parent of B0, like the same command without the &lt;code&gt;--fork-point&lt;/code&gt; option gives).</source>
          <target state="translated">주의 사항은 저장소의 오래된 reflog 항목이 &lt;code&gt;git gc&lt;/code&gt; 에 의해 만료 될 수 있다는 것 입니다. B0이 더 이상 원격 추적 분기 &lt;code&gt;origin/master&lt;/code&gt; 의 참조 &lt;code&gt;--fork-point&lt;/code&gt; 모드는 분명히 그것을 찾을 수없고 실패하여 임의의 쓸모없는 결과 (예 : &lt;code&gt;--fork-point&lt;/code&gt; 옵션이 없는 동일한 명령이 제공됩니다).</target>
        </trans-unit>
        <trans-unit id="e9b2d53c7c7f7197e6449bea92bdc1e149be79ae" translate="yes" xml:space="preserve">
          <source>A changelist that contains only excluded files will be imported as an empty commit if this boolean option is set to true.</source>
          <target state="translated">이 부울 옵션을 true로 설정하면 제외 된 파일 만 포함 된 변경 목록을 빈 커밋으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1fded59f54db89df8b3f442b60da3137cb35cf1c" translate="yes" xml:space="preserve">
          <source>A collection of &lt;a href=&quot;#def_ref&quot;&gt;refs&lt;/a&gt; together with an &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt; containing all objects which are &lt;a href=&quot;#def_reachable&quot;&gt;reachable&lt;/a&gt; from the refs, possibly accompanied by meta data from one or more &lt;a href=&quot;#def_porcelain&quot;&gt;porcelains&lt;/a&gt;. A repository can share an object database with other repositories via &lt;a href=&quot;#def_alternate_object_database&quot;&gt;alternates mechanism&lt;/a&gt;.</source>
          <target state="translated">컬렉션 &lt;a href=&quot;#def_ref&quot;&gt;심판&lt;/a&gt; 함께 갖는 &lt;a href=&quot;#def_object_database&quot;&gt;객체 데이터베이스&lt;/a&gt; 모든 개체 함유 &lt;a href=&quot;#def_reachable&quot;&gt;도달&lt;/a&gt; 심판관로부터는 아마도 하나 이상의 메타 데이터의 동반 &lt;a href=&quot;#def_porcelain&quot;&gt;도재&lt;/a&gt; . 저장소는 &lt;a href=&quot;#def_alternate_object_database&quot;&gt;대체 메커니즘을&lt;/a&gt; 통해 다른 저장소와 오브젝트 데이터베이스를 공유 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df01e27bf740894293c8642767b5b6f6ba2bfe1f" translate="yes" xml:space="preserve">
          <source>A collection of files with stat information, whose contents are stored as objects. The index is a stored version of your &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt;. Truth be told, it can also contain a second, and even a third version of a working tree, which are used when &lt;a href=&quot;#def_merge&quot;&gt;merging&lt;/a&gt;.</source>
          <target state="translated">통계 정보가 포함 된 파일 모음으로, 내용이 객체로 저장됩니다. 색인은 &lt;a href=&quot;#def_working_tree&quot;&gt;작업 트리&lt;/a&gt; 의 저장된 버전입니다 . 사실, &lt;a href=&quot;#def_merge&quot;&gt;병합&lt;/a&gt; 할 때 사용되는 작업 트리의 두 번째 버전, 심지어 세 번째 버전도 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52a6e96629904ef8963fcbbd33f5c0e5160e4b14" translate="yes" xml:space="preserve">
          <source>A colon &lt;code&gt;:&lt;/code&gt; is used as in &lt;code&gt;srcref:dstref&lt;/code&gt; to mean &quot;use srcref&amp;rsquo;s value and store it in dstref&quot; in fetch and push operations. It may also be used to select a specific object such as with 'git cat-file': &quot;git cat-file blob v1.3.3:refs.c&quot;.</source>
          <target state="translated">콜론 &lt;code&gt;:&lt;/code&gt; 은 &lt;code&gt;srcref:dstref&lt;/code&gt; 에서와 같이 페치 및 푸시 작업에서 &quot;srcref의 값을 사용하고 dstref에 저장&quot;을 의미합니다. 'git cat-file': &quot;git cat-file blob v1.3.3 : refs.c&quot;와 같은 특정 개체를 선택하는 데 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fa4235099cacbb93254de4106a73880e13a4bbc" translate="yes" xml:space="preserve">
          <source>A colon, followed by a slash, followed by a text, names a commit whose commit message matches the specified regular expression. This name returns the youngest matching commit which is reachable from any ref, including HEAD. The regular expression can match any part of the commit message. To match messages starting with a string, one can use e.g. &lt;code&gt;:/^foo&lt;/code&gt;. The special sequence &lt;code&gt;:/!&lt;/code&gt; is reserved for modifiers to what is matched. &lt;code&gt;:/!-foo&lt;/code&gt; performs a negative match, while &lt;code&gt;:/!!foo&lt;/code&gt; matches a literal &lt;code&gt;!&lt;/code&gt; character, followed by &lt;code&gt;foo&lt;/code&gt;. Any other sequence beginning with &lt;code&gt;:/!&lt;/code&gt; is reserved for now. Depending on the given text, the shell&amp;rsquo;s word splitting rules might require additional quoting.</source>
          <target state="translated">콜론, 슬래시, 텍스트 뒤에는 커밋 메시지가 지정된 정규식과 일치하는 커밋의 이름이 지정됩니다. 이 이름은 HEAD를 포함한 모든 심판에서 도달 할 수있는 가장 일치하는 커밋을 반환합니다. 정규식은 커밋 메시지의 모든 부분과 일치 할 수 있습니다. 문자열로 시작하는 메시지를 일치시키기 위해 eg &lt;code&gt;:/^foo&lt;/code&gt; 사용할 수 있습니다 . 특별한 순서 &lt;code&gt;:/!&lt;/code&gt; 일치하는 수정자를 위해 예약되어 있습니다. &lt;code&gt;:/!-foo&lt;/code&gt; 는 음의 일치를 수행하지만 &lt;code&gt;:/!!foo&lt;/code&gt; 는 리터럴과 일치합니다 &lt;code&gt;!&lt;/code&gt; 문자 뒤에 &lt;code&gt;foo&lt;/code&gt; 가 옵니다 . &lt;code&gt;:/!&lt;/code&gt; 로 시작하는 다른 시퀀스지금 예약되어 있습니다. 주어진 텍스트에 따라 쉘의 단어 분리 규칙에 추가 인용이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13756e35429ac459169fe4f0ae98f0d2e3c822ed" translate="yes" xml:space="preserve">
          <source>A colon, optionally followed by a stage number (0 to 3) and a colon, followed by a path, names a blob object in the index at the given path. A missing stage number (and the colon that follows it) names a stage 0 entry. During a merge, stage 1 is the common ancestor, stage 2 is the target branch&amp;rsquo;s version (typically the current branch), and stage 3 is the version from the branch which is being merged.</source>
          <target state="translated">선택적으로 스테이지 번호 (0-3)와 콜론, 경로가 오는 콜론은 색인에서 지정된 경로의 BLOB 오브젝트를 명명합니다. 누락 된 단계 번호 (및 뒤에 오는 콜론)는 단계 0 항목의 이름을 지정합니다. 병합하는 동안 1 단계는 공통 조상이고 2 단계는 대상 분기의 버전 (일반적으로 현재 분기)이며 3 단계는 병합중인 분기의 버전입니다.</target>
        </trans-unit>
        <trans-unit id="8caa5f563f7545c6d876e685c6213fbb94df9ad3" translate="yes" xml:space="preserve">
          <source>A comma and/or whitespace separated list of encodings that Git performs UTF-8 round trip checks on if they are used in an &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute (see &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;). The default value is &lt;code&gt;SHIFT-JIS&lt;/code&gt;.</source>
          <target state="translated">Git이 UTF-8 왕복 검사를 수행하는 쉼표 및 / 또는 공백으로 구분 된 인코딩 목록이 &lt;code&gt;working-tree-encoding&lt;/code&gt; 속성에 사용되는지 확인 합니다 ( &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 참조 ). 기본값은 &lt;code&gt;SHIFT-JIS&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9b2d1e893ce7e09a76d55d9b9450e681bcdfc845" translate="yes" xml:space="preserve">
          <source>A comma separated list of &lt;code&gt;--dirstat&lt;/code&gt; parameters specifying the default behavior of the &lt;code&gt;--dirstat&lt;/code&gt; option to &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; and friends. The defaults can be overridden on the command line (using &lt;code&gt;--dirstat=&amp;lt;param1,param2,...&amp;gt;&lt;/code&gt;). The fallback defaults (when not changed by &lt;code&gt;diff.dirstat&lt;/code&gt;) are &lt;code&gt;changes,noncumulative,3&lt;/code&gt;. The following parameters are available:</source>
          <target state="translated">&lt;code&gt;--dirstat&lt;/code&gt; 옵션 의 기본 동작 을 &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 및 friends로 지정 하는 쉼표로 구분 된 &lt;code&gt;--dirstat&lt;/code&gt; 매개 변수 목록입니다 . &lt;code&gt;--dirstat=&amp;lt;param1,param2,...&amp;gt;&lt;/code&gt; 사용하여 명령 줄에서 기본값을 재정의 할 수 있습니다 . 대체 기본값 ( &lt;code&gt;diff.dirstat&lt;/code&gt; 에 의해 변경되지 않은 경우 )은 &lt;code&gt;changes,noncumulative,3&lt;/code&gt; noncumulative , 3 입니다. 다음과 같은 파라미터를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90c61024b3e6d8b4fd7db663d99f9e656029c4cd" translate="yes" xml:space="preserve">
          <source>A comma separated list of common whitespace problems to notice. &lt;code&gt;git diff&lt;/code&gt; will use &lt;code&gt;color.diff.whitespace&lt;/code&gt; to highlight them, and &lt;code&gt;git apply --whitespace=error&lt;/code&gt; will consider them as errors. You can prefix &lt;code&gt;-&lt;/code&gt; to disable any of them (e.g. &lt;code&gt;-trailing-space&lt;/code&gt;):</source>
          <target state="translated">쉼표로 구분 된 일반적인 공백 문제 목록입니다. &lt;code&gt;git diff&lt;/code&gt; 는 &lt;code&gt;color.diff.whitespace&lt;/code&gt; 를 사용 하여 강조 표시하고 &lt;code&gt;git apply --whitespace=error&lt;/code&gt; 는 오류 로 간주합니다. 접두사 &lt;code&gt;-&lt;/code&gt; 를 사용하여 이들 중 하나를 비활성화 할 수 있습니다 (예 : &lt;code&gt;-trailing-space&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b1f12d6e1196c6283625769763bfec7de0f553d4" translate="yes" xml:space="preserve">
          <source>A comma-separated list of &quot;important&quot; environment variables that should be recorded in the trace2 output. For example, &lt;code&gt;GIT_HTTP_USER_AGENT,GIT_CONFIG&lt;/code&gt; would cause the trace2 output to contain events listing the overrides for HTTP user agent and the location of the Git configuration file (assuming any are set). May be overriden by the &lt;code&gt;GIT_TRACE2_ENV_VARS&lt;/code&gt; environment variable. Unset by default.</source>
          <target state="translated">trace2 출력에 기록되어야하는 &quot;중요한&quot;환경 변수의 쉼표로 구분 된 목록입니다. 예를 들어, &lt;code&gt;GIT_HTTP_USER_AGENT,GIT_CONFIG&lt;/code&gt; 는 trace2 출력에 HTTP 사용자 에이전트에 대한 재정의 및 Git 구성 파일의 위치를 ​​나열하는 이벤트를 포함하게됩니다 (설정된 것으로 가정). &lt;code&gt;GIT_TRACE2_ENV_VARS&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . 기본적으로 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb282cbfbc43caeda403e67d10ddbed3e0b9cd80" translate="yes" xml:space="preserve">
          <source>A comma-separated list of patterns of &quot;important&quot; config settings that should be recorded in the trace2 output. For example, &lt;code&gt;core.*,remote.*.url&lt;/code&gt; would cause the trace2 output to contain events listing each configured remote. May be overridden by the &lt;code&gt;GIT_TRACE2_CONFIG_PARAMS&lt;/code&gt; environment variable. Unset by default.</source>
          <target state="translated">trace2 출력에 기록해야하는 &quot;중요한&quot;구성 설정 패턴을 쉼표로 구분 한 목록입니다. 예를 들어 &lt;code&gt;core.*,remote.*.url&lt;/code&gt; 을 사용하면 trace2 출력에 구성된 각 원격을 나열하는 이벤트가 포함됩니다. &lt;code&gt;GIT_TRACE2_CONFIG_PARAMS&lt;/code&gt; 환경 변수 로 대체 될 수 있습니다 . 기본적으로 설정 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fab91cb4daf1c47222fcbb845cf8839d9381cfa" translate="yes" xml:space="preserve">
          <source>A commit comment is read from stdin. If a changelog entry is not provided via &quot;&amp;lt;&quot; redirection, &lt;code&gt;git commit-tree&lt;/code&gt; will just wait for one to be entered and terminated with ^D.</source>
          <target state="translated">커밋 주석은 stdin에서 읽습니다. &quot;&amp;lt;&quot;경로 재 지정을 통해 변경 로그 항목을 제공하지 않으면 &lt;code&gt;git commit-tree&lt;/code&gt; 는 하나만 입력하고 ^ D로 종료 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="3c1dc52f2c7f4f92de3fbbe4920a9bf34ad24479" translate="yes" xml:space="preserve">
          <source>A commit encapsulates:</source>
          <target state="translated">커밋은 다음을 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="acc26f5acfd22e9eac8779b8f191ce6307d46b3a" translate="yes" xml:space="preserve">
          <source>A commit is usually created by &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;, which creates a commit whose parent is normally the current HEAD, and whose tree is taken from the content currently stored in the index.</source>
          <target state="translated">커밋은 일반적으로 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 에 의해 생성됩니다.이 커밋은 일반적으로 부모가 현재 HEAD이고 트리가 현재 인덱스에 저장된 내용에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cdd78b04bea05d29acf58eb590016b304b9a695a" translate="yes" xml:space="preserve">
          <source>A commit object may have any number of parents. With exactly one parent, it is an ordinary commit. Having more than one parent makes the commit a merge between several lines of history. Initial (root) commits have no parents.</source>
          <target state="translated">커밋 개체에는 여러 부모가있을 수 있습니다. 정확히 하나의 부모가 있으면 일반적인 커밋입니다. 부모가 둘 이상 있으면 커밋이 여러 줄의 행을 병합합니다. 초기 (루트) 커밋에는 부모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f73e034726177d0d1de0cc7cb0b4640f70795d7d" translate="yes" xml:space="preserve">
          <source>A commit&amp;rsquo;s reachable set is the commit itself and the commits in its ancestry chain.</source>
          <target state="translated">커밋의 도달 가능한 집합은 커밋 자체와 상위 체인의 커밋입니다.</target>
        </trans-unit>
        <trans-unit id="9f0c7cb4b676d44b852130363daf17e0059e5d35" translate="yes" xml:space="preserve">
          <source>A common idiom to check &quot;fast-forward-ness&quot; between two commits A and B is (or at least used to be) to compute the merge base between A and B, and check if it is the same as A, in which case, A is an ancestor of B. You will see this idiom used often in older scripts.</source>
          <target state="translated">두 커밋 A와 B 사이의 &quot;빨리 감기&quot;를 확인하는 일반적인 관용구는 A와 B 사이의 병합 기준을 계산하고 A와 같은지 확인하는 것입니다. A는 B의 조상입니다.이 관용구는 이전 스크립트에서 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="efeda38b74e243af3941ca4cb1afcb6d50536c89" translate="yes" xml:space="preserve">
          <source>A common perception of maintenance is that it is merely fixing bugs. However, studies and surveys over the years have indicated that the majority, over 80%, of the maintenance effort is used for non-corrective actions (Pigosky 1997). This perception is perpetuated by users submitting problem reports that in reality are functionality enhancements to the system.</source>
          <target state="translated">유지 관리에 대한 일반적인 인식은 단지 버그를 수정하는 것입니다. 그러나 수년에 걸친 연구와 조사에 따르면 유지 보수 노력의 80 % 이상이 비 수정 조치에 사용되는 것으로 나타났습니다 (Pigosky 1997). 이 인식은 사용자가 실제로 시스템의 기능 향상이라는 문제 보고서를 제출함으로써 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="197af13fb9a6e5b93cb17a698b162888ff484ba7" translate="yes" xml:space="preserve">
          <source>A common problem users face when looking at simplified history is that a commit they know changed a file somehow does not appear in the file&amp;rsquo;s simplified history. Let&amp;rsquo;s demonstrate a new example and show how options such as &lt;code&gt;--full-history&lt;/code&gt; and &lt;code&gt;--simplify-merges&lt;/code&gt; works in that case:</source>
          <target state="translated">단순화 된 히스토리를 볼 때 사용자가 직면하는 일반적인 문제는 파일을 변경 한 것으로 알고있는 커밋이 파일의 단순화 된 히스토리에 나타나지 않는다는 것입니다. 새로운 예를 보여 &lt;code&gt;--simplify-merges&lt;/code&gt; 경우 &lt;code&gt;--full-history&lt;/code&gt; 및 --simplify-merges 와 같은 옵션이 어떻게 작동하는지 보여 드리겠습니다 .</target>
        </trans-unit>
        <trans-unit id="5edc728da69ffd96fd56c998aef47f3f04d15f9f" translate="yes" xml:space="preserve">
          <source>A common shorthand for &lt;code&gt;git diff-files -p&lt;/code&gt; is to just write &lt;code&gt;git
diff&lt;/code&gt;, which will do the same thing.</source>
          <target state="translated">의 일반적인 속기 &lt;code&gt;git diff-files -p&lt;/code&gt; 바로 쓰기이다 &lt;code&gt;git diff&lt;/code&gt; 같은 일을 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="14a9ba1b1e1a8bc290e55e84eb3c20bc97ffb373" translate="yes" xml:space="preserve">
          <source>A common working pattern is to fetch the latest changes from the p4 depot and merge them with local uncommitted changes. Often, the p4 repository is the ultimate location for all code, thus a rebase workflow makes sense. This command does &lt;code&gt;git p4 sync&lt;/code&gt; followed by &lt;code&gt;git rebase&lt;/code&gt; to move local commits on top of updated p4 changes.</source>
          <target state="translated">일반적인 작업 패턴은 p4 저장소에서 최신 변경 사항을 가져 와서 커미트되지 않은 로컬 변경 사항과 병합하는 것입니다. p4 리포지토리는 모든 코드의 최종 위치이므로 종종 리베이스 워크 플로가 적합합니다. 이 명령은 &lt;code&gt;git p4 sync&lt;/code&gt; 다음에 &lt;code&gt;git rebase&lt;/code&gt; 를 수행하여 업데이트 된 p4 변경 사항 위에 로컬 커밋을 이동합니다.</target>
        </trans-unit>
        <trans-unit id="a4fa8348285318059dfacd14294d170b4fc808f0" translate="yes" xml:space="preserve">
          <source>A complete 40 byte or abbreviated commit SHA-1 in hex.</source>
          <target state="translated">완전한 40 바이트 또는 약식 커밋 SHA-1 (16 진수)</target>
        </trans-unit>
        <trans-unit id="02926b5c0160f21e1aa42320ded7f690bec583ac" translate="yes" xml:space="preserve">
          <source>A configuration identity. When given, causes values in the &lt;code&gt;sendemail.&amp;lt;identity&amp;gt;&lt;/code&gt; subsection to take precedence over values in the &lt;code&gt;sendemail&lt;/code&gt; section. The default identity is the value of &lt;code&gt;sendemail.identity&lt;/code&gt;.</source>
          <target state="translated">구성 ID 지정된 경우 &lt;code&gt;sendemail.&amp;lt;identity&amp;gt;&lt;/code&gt; 하위 섹션의 값이 &lt;code&gt;sendemail&lt;/code&gt; 섹션의 값보다 우선 합니다. 기본 아이디는 &lt;code&gt;sendemail.identity&lt;/code&gt; 값입니다 .</target>
        </trans-unit>
        <trans-unit id="35d1e222ae59833da8390e3205af99d5791ad8cb" translate="yes" xml:space="preserve">
          <source>A conflict occurs if both &lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;other-file&amp;gt;&lt;/code&gt; have changes in a common segment of lines. If a conflict is found, &lt;code&gt;git merge-file&lt;/code&gt; normally outputs a warning and brackets the conflict with lines containing &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; and &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; markers. A typical conflict will look like this:</source>
          <target state="translated">&lt;code&gt;&amp;lt;current-file&amp;gt;&lt;/code&gt; 과 &lt;code&gt;&amp;lt;other-file&amp;gt;&lt;/code&gt; 둘 다 공통 행 세그먼트에서 변경 사항이있는 경우 충돌이 발생합니다 . 충돌이 발견되면 &lt;code&gt;git merge-file&lt;/code&gt; 은 일반적으로 경고를 출력하고 &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; 및 &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 마커를 포함하는 행과 충돌을 괄호로 묶습니다. 일반적인 충돌은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07bd76c9e5bd5a5c306cd10ddbfbe3c7ac2875c0" translate="yes" xml:space="preserve">
          <source>A convenience alias for &lt;code&gt;--only-trailers --only-input
--unfold&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--only-trailers --only-input --unfold&lt;/code&gt; 의 편의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="97978af293e3af436b507f6dc4b9076f9f973577" translate="yes" xml:space="preserve">
          <source>A debug option to help with future &quot;partial clone&quot; development. This option specifies how missing objects are handled.</source>
          <target state="translated">향후 &quot;부분 복제&quot;개발에 도움이되는 디버그 옵션입니다. 이 옵션은 누락 된 개체를 처리하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="26d7d5495841c41cd87cf2e545d3c8aff9d18129" translate="yes" xml:space="preserve">
          <source>A default username, if one is not provided in the URL.</source>
          <target state="translated">URL에 제공되지 않은 경우 기본 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="cba5596219f17f93a98404ea4497b915ef344a8c" translate="yes" xml:space="preserve">
          <source>A delimiter string is used to mark the end of the data. fast-import will compute the length by searching for the delimiter. This format is primarily useful for testing and is not recommended for real data.</source>
          <target state="translated">분리 문자열은 데이터의 끝을 표시하는 데 사용됩니다. 빠른 가져 오기는 구분자를 검색하여 길이를 계산합니다. 이 형식은 주로 테스트에 유용하며 실제 데이터에는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21e88086f294c6f14da1c8f79767c0e47b61a6a2" translate="yes" xml:space="preserve">
          <source>A developer working as a participant in a group project needs to learn how to communicate with others, and uses these commands in addition to the ones needed by a standalone developer.</source>
          <target state="translated">그룹 프로젝트에서 참가자로 일하는 개발자는 다른 사람과 의사 소통하는 방법을 배우고 독립형 개발자가 필요로하는 명령 외에 이러한 명령을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa00f0c6fcff7a20980dde937b6f2c6eff19948d" translate="yes" xml:space="preserve">
          <source>A directory to add to the whitelist of allowed directories. Unless --strict-paths is specified this will also include subdirectories of each named directory.</source>
          <target state="translated">허용 된 디렉토리의 화이트리스트에 추가 할 디렉토리입니다. --strict-paths를 지정하지 않으면 각 명명 된 디렉토리의 하위 디렉토리도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a72583fc1f6c7369768db5e1d7fb0e226e0f4e70" translate="yes" xml:space="preserve">
          <source>A double-dot &lt;code&gt;..&lt;/code&gt; is often used as in &lt;code&gt;ref1..ref2&lt;/code&gt;, and in some contexts this notation means &lt;code&gt;^ref1 ref2&lt;/code&gt; (i.e. not in &lt;code&gt;ref1&lt;/code&gt; and in &lt;code&gt;ref2&lt;/code&gt;).</source>
          <target state="translated">이중 점 &lt;code&gt;..&lt;/code&gt; 은 종종 &lt;code&gt;ref1..ref2&lt;/code&gt; 에서와 같이 사용되며 , 일부 상황에서이 표기법은 &lt;code&gt;^ref1 ref2&lt;/code&gt; (즉, &lt;code&gt;ref1&lt;/code&gt; 및 &lt;code&gt;ref2&lt;/code&gt; 에 없음 )를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8cdb3523eaeda3961c032ea5c0f58f6c364cd9b3" translate="yes" xml:space="preserve">
          <source>A dumb server that does not do on-the-fly pack generations must have some auxiliary information files in $GIT_DIR/info and $GIT_OBJECT_DIRECTORY/info directories to help clients discover what references and packs the server has. This command generates such auxiliary files.</source>
          <target state="translated">온더 플라이 팩 생성을 수행하지 않는 바보 서버에는 클라이언트가 서버에있는 참조 및 팩을 발견 할 수 있도록 $ GIT_DIR / info 및 $ GIT_OBJECT_DIRECTORY / info 디렉토리에 보조 정보 파일이 있어야합니다. 이 명령은 이러한 보조 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3e6068affbbe0ff6a579ff1d24351f9cddf70755" translate="yes" xml:space="preserve">
          <source>A fairly central person acting as the integrator in a group project receives changes made by others, reviews and integrates them and publishes the result for others to use, using these commands in addition to the ones needed by participants.</source>
          <target state="translated">그룹 프로젝트에서 통합 자 역할을하는 상당히 중심적인 사람은 다른 사람이 변경 한 내용을 받아 검토하고 통합 한 후 참가자가 필요로하는 명령 외에이 명령을 사용하여 다른 사람이 사용할 결과를 게시합니다.</target>
        </trans-unit>
        <trans-unit id="62b9ceab10a1cb84bc6e55a7f4299b34b10f0e2f" translate="yes" xml:space="preserve">
          <source>A fast-forward is a special type of &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; where you have a &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt; and you are &quot;merging&quot; another &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;'s changes that happen to be a descendant of what you have. In such a case, you do not make a new &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt;&lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; but instead just update to his revision. This will happen frequently on a &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;remote-tracking branch&lt;/a&gt; of a remote &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;.</source>
          <target state="translated">빨리 감기는 &lt;a href=&quot;#def_revision&quot;&gt;개정이&lt;/a&gt; 있고 가지고있는 &lt;a href=&quot;#def_branch&quot;&gt;분기&lt;/a&gt; 의 변경 사항을 &quot;병합&quot; 하는 특수한 &lt;a href=&quot;#def_merge&quot;&gt;병합&lt;/a&gt; 유형입니다 . 이 경우 새 &lt;a href=&quot;#def_merge&quot;&gt;병합 &lt;/a&gt;&lt;a href=&quot;#def_commit&quot;&gt;커밋&lt;/a&gt; 을 수행하지 않고 수정본으로 업데이트하십시오. 이것은 원격 &lt;a href=&quot;#def_repository&quot;&gt;저장소&lt;/a&gt; 의 원격 &lt;a href=&quot;#def_remote_tracking_branch&quot;&gt;추적 분기&lt;/a&gt; 에서 자주 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="f1639e68ef8005bf8b9fd0a9765a95c3e36366d5" translate="yes" xml:space="preserve">
          <source>A fast-forward looks something like this:</source>
          <target state="translated">빨리 감기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b2e7c39642f6628198b3a6330b5201dad9a7aff7" translate="yes" xml:space="preserve">
          <source>A fatal error was encountered.</source>
          <target state="translated">치명적인 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="0b2eaf514674a6a55b836d451eca54479349bb70" translate="yes" xml:space="preserve">
          <source>A feature release is created from the &lt;code&gt;master&lt;/code&gt; branch, since &lt;code&gt;master&lt;/code&gt; tracks the commits that should go into the next feature release.</source>
          <target state="translated">특징 자료는에서 만든 &lt;code&gt;master&lt;/code&gt; 하기 때문에, 지점 &lt;code&gt;master&lt;/code&gt; 다음 기능 릴리스에 가야 커밋을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="74ba6f95b54ef3076dd734e20033705f91d3f8bd" translate="yes" xml:space="preserve">
          <source>A few configuration variables (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) can make it easy to push both branches to your public tree. (See &lt;a href=&quot;#setting-up-a-public-repository&quot;&gt;Setting up a public repository&lt;/a&gt;.)</source>
          <target state="translated">몇 가지 구성 변수 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; )를 사용하면 두 분기를 모두 공개 트리로 쉽게 푸시 할 수 있습니다. &lt;a href=&quot;#setting-up-a-public-repository&quot;&gt;공용 저장소 설정을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b328fdc14f23c3b282a30f44ac30ff04e6b3868" translate="yes" xml:space="preserve">
          <source>A few more notes on matching via &lt;code&gt;gitdir&lt;/code&gt; and &lt;code&gt;gitdir/i&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;gitdir&lt;/code&gt; 및 &lt;code&gt;gitdir/i&lt;/code&gt; 를 통한 일치에 대한 몇 가지 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="74c1c3db8333ea0856e57a216b0202a880b8b0fd" translate="yes" xml:space="preserve">
          <source>A field name to sort on. Prefix &lt;code&gt;-&lt;/code&gt; to sort in descending order of the value. When unspecified, &lt;code&gt;refname&lt;/code&gt; is used. You may use the --sort=&amp;lt;key&amp;gt; option multiple times, in which case the last key becomes the primary key.</source>
          <target state="translated">정렬 할 필드 이름입니다. 접두사 &lt;code&gt;-&lt;/code&gt; 값의 내림차순으로 정렬합니다. 지정하지 &lt;code&gt;refname&lt;/code&gt; 이 사용됩니다. --sort = &amp;lt;key&amp;gt; 옵션을 여러 번 사용할 수 있으며,이 경우 마지막 키가 기본 키가됩니다.</target>
        </trans-unit>
        <trans-unit id="13fa2104992d30057f7ee2ca78ba1b9cc1b33c21" translate="yes" xml:space="preserve">
          <source>A filter driver consists of a &lt;code&gt;clean&lt;/code&gt; command and a &lt;code&gt;smudge&lt;/code&gt; command, either of which can be left unspecified. Upon checkout, when the &lt;code&gt;smudge&lt;/code&gt; command is specified, the command is fed the blob object from its standard input, and its standard output is used to update the worktree file. Similarly, the &lt;code&gt;clean&lt;/code&gt; command is used to convert the contents of worktree file upon checkin. By default these commands process only a single blob and terminate. If a long running &lt;code&gt;process&lt;/code&gt; filter is used in place of &lt;code&gt;clean&lt;/code&gt; and/or &lt;code&gt;smudge&lt;/code&gt; filters, then Git can process all blobs with a single filter command invocation for the entire life of a single Git command, for example &lt;code&gt;git add --all&lt;/code&gt;. If a long running &lt;code&gt;process&lt;/code&gt; filter is configured then it always takes precedence over a configured single blob filter. See section below for the description of the protocol used to communicate with a &lt;code&gt;process&lt;/code&gt; filter.</source>
          <target state="translated">필터 드라이버는 &lt;code&gt;clean&lt;/code&gt; 명령과 &lt;code&gt;smudge&lt;/code&gt; 명령으로 구성되며 , 둘 중 하나는 지정하지 않아도됩니다. 체크 아웃시 &lt;code&gt;smudge&lt;/code&gt; 명령이 지정되면 명령에 표준 입력에서 Blob 오브젝트가 제공되고 표준 출력이 작업 트리 파일을 업데이트하는 데 사용됩니다. 마찬가지로 &lt;code&gt;clean&lt;/code&gt; 명령은 체크인시 작업 트리 파일의 내용을 변환하는 데 사용됩니다. 기본적으로이 명령은 단일 얼룩 만 처리하고 종료합니다. &lt;code&gt;clean&lt;/code&gt; 필터 및 / 또는 &lt;code&gt;smudge&lt;/code&gt; 필터 대신 장기 실행 &lt;code&gt;process&lt;/code&gt; 필터를 사용하는 경우 Git은 단일 Git 명령의 전체 수명 동안 단일 필터 명령 호출로 모든 블롭을 처리 할 수 ​​있습니다. &lt;code&gt;git add --all&lt;/code&gt; . 장시간 실행되는 &lt;code&gt;process&lt;/code&gt; 필터가 구성된 경우 항상 구성된 단일 블롭 필터보다 우선합니다. &lt;code&gt;process&lt;/code&gt; 필터 와 통신하는 데 사용되는 프로토콜에 대한 설명은 아래 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a399e6db3987e04a0a954aa555198a880460b1b3" translate="yes" xml:space="preserve">
          <source>A format string, as specified in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, to be used for the todo list during an interactive rebase. The format will automatically have the long commit hash prepended to the format.</source>
          <target state="translated">&lt;a href=&quot;git-log&quot;&gt;git-log [1]에&lt;/a&gt; 지정된대로 대화식 리베이스 중에 할일 목록에 사용되는 형식 문자열 입니다. 형식은 긴 커밋 해시가 형식 앞에 자동으로 붙습니다.</target>
        </trans-unit>
        <trans-unit id="3ef0d2618bd1f2707924d8265b8cbc81cb0f4df7" translate="yes" xml:space="preserve">
          <source>A formatted and hyperlinked copy of the latest Git documentation can be viewed at &lt;a href=&quot;https://git.github.io/htmldocs/git.html&quot;&gt;https://git.github.io/htmldocs/git.html&lt;/a&gt; or &lt;a href=&quot;index&quot;&gt;https://git-scm.com/docs&lt;/a&gt;.</source>
          <target state="translated">최신 Git 문서의 형식이 지정된 하이퍼 링크 사본은 &lt;a href=&quot;https://git.github.io/htmldocs/git.html&quot;&gt;https://git.github.io/htmldocs/git.html&lt;/a&gt; 또는 &lt;a href=&quot;index&quot;&gt;https://git-scm.com/docs&lt;/a&gt; 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1611e58cf3ba6bbcadd845b19a6529d9c8709a09" translate="yes" xml:space="preserve">
          <source>A freshly cloned repository contains a single branch head, by default named &quot;master&quot;, with the working directory initialized to the state of the project referred to by that branch head.</source>
          <target state="translated">새로 복제 된 저장소에는 기본적으로 &quot;master&quot;라는 단일 분기 헤드가 있으며 작업 디렉토리는 해당 분기 헤드가 참조하는 프로젝트 상태로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="9361f96571e895bc96ccb37b799d33736e1313bd" translate="yes" xml:space="preserve">
          <source>A frontend set up this way can use &lt;code&gt;progress&lt;/code&gt;, &lt;code&gt;get-mark&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;, and &lt;code&gt;cat-blob&lt;/code&gt; commands to read information from the import in progress.</source>
          <target state="translated">이 방법으로 설정된 프론트 엔드는 &lt;code&gt;progress&lt;/code&gt; , &lt;code&gt;get-mark&lt;/code&gt; , &lt;code&gt;ls&lt;/code&gt; 및 &lt;code&gt;cat-blob&lt;/code&gt; 명령을 사용하여 진행중인 가져 오기에서 정보를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ec35e8b31b58ee10f23bf6c56b94488c655953e" translate="yes" xml:space="preserve">
          <source>A general note on safety: supplying this option without an expected value, i.e. as &lt;code&gt;--force-with-lease&lt;/code&gt; or &lt;code&gt;--force-with-lease=&amp;lt;refname&amp;gt;&lt;/code&gt; interacts very badly with anything that implicitly runs &lt;code&gt;git fetch&lt;/code&gt; on the remote to be pushed to in the background, e.g. &lt;code&gt;git fetch origin&lt;/code&gt; on your repository in a cronjob.</source>
          <target state="translated">안전에 대한 일반적인 참고 사항 : &lt;code&gt;--force-with-lease&lt;/code&gt; 또는 &lt;code&gt;--force-with-lease=&amp;lt;refname&amp;gt;&lt;/code&gt; 과 같이 예상 값없이이 옵션을 제공 하면 원격에서 &lt;code&gt;git fetch&lt;/code&gt; 를 암시 적으로 실행하는 모든 항목과 cronjob의 저장소에서 &lt;code&gt;git fetch origin&lt;/code&gt; 을 백그라운드로 푸시합니다 .</target>
        </trans-unit>
        <trans-unit id="0ed755acace2a48ffeeff6fb565baf90507fd745" translate="yes" xml:space="preserve">
          <source>A git repository can support multiple working trees, allowing you to check out more than one branch at a time. With &lt;code&gt;git worktree add&lt;/code&gt; a new working tree is associated with the repository. This new working tree is called a &quot;linked working tree&quot; as opposed to the &quot;main working tree&quot; prepared by &quot;git init&quot; or &quot;git clone&quot;. A repository has one main working tree (if it&amp;rsquo;s not a bare repository) and zero or more linked working trees. When you are done with a linked working tree, remove it with &lt;code&gt;git worktree remove&lt;/code&gt;.</source>
          <target state="translated">git 저장소는 여러 작업 트리를 지원할 수 있으므로 한 번에 둘 이상의 브랜치를 체크 아웃 할 수 있습니다. 와 &lt;code&gt;git worktree add&lt;/code&gt; 새로운 작업 트리가 저장소와 연결되어 있습니다. 이 새로운 작업 트리는 &quot;git init&quot;또는 &quot;git clone&quot;에 의해 준비된 &quot;주 작업 트리&quot;와 반대로 &quot;링크 된 작업 트리&quot;라고합니다. 저장소에는 하나의 기본 작업 트리 (베어링 저장소가 아닌 경우)와 0 개 이상의 연결된 작업 트리가 있습니다. 연결된 작업 트리가 완료되면 &lt;code&gt;git worktree remove&lt;/code&gt; 로 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="f741e1b0eda9fb3d26b53c2f7cc5921496de9343" translate="yes" xml:space="preserve">
          <source>A git repository can support multiple working trees, allowing you to check out more than one branch at a time. With &lt;code&gt;git worktree add&lt;/code&gt; a new working tree is associated with the repository. This new working tree is called a &quot;linked working tree&quot; as opposed to the &quot;main working tree&quot; prepared by &lt;a href=&quot;git-init&quot;&gt;git-init[1]&lt;/a&gt; or &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;. A repository has one main working tree (if it&amp;rsquo;s not a bare repository) and zero or more linked working trees. When you are done with a linked working tree, remove it with &lt;code&gt;git worktree remove&lt;/code&gt;.</source>
          <target state="translated">git 저장소는 여러 작업 트리를 지원할 수 있으므로 한 번에 둘 이상의 브랜치를 확인할 수 있습니다. &lt;code&gt;git worktree add&lt;/code&gt; 사용하면 새 작업 트리가 저장소와 연결됩니다. 이 새로운 작업 트리는 &lt;a href=&quot;git-init&quot;&gt;git-init [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]에&lt;/a&gt; 의해 준비된 &quot;주 작업 트리&quot;와 반대로 &quot;연결된 작업 트리&quot;라고합니다 . 저장소에는 하나의 기본 작업 트리 (베어 저장소가 아닌 경우)와 0 개 이상의 연결된 작업 트리가 있습니다. 연결된 작업 트리를 완료하면 &lt;code&gt;git worktree remove&lt;/code&gt; 를 사용 하여 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb35f01e2c3f5716f9ff7a011caefd2667f92277" translate="yes" xml:space="preserve">
          <source>A glob pattern that matches branch or tag names under refs/. For example, if you have many topic branches under refs/heads/topic, giving &lt;code&gt;topic/*&lt;/code&gt; would show all of them.</source>
          <target state="translated">refs / 아래의 브랜치 또는 태그 이름과 일치하는 글로브 패턴입니다. 예를 들어 refs / heads / topic 아래에 토픽 브랜치가 많은 경우 &lt;code&gt;topic/*&lt;/code&gt; 을 지정 하면 모든 브랜치 가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="190546c0fc74bb90a9365e134f633644e2a48fc0" translate="yes" xml:space="preserve">
          <source>A globbing refspec must have a non-empty RHS (i.e. must store what were fetched in remote-tracking branches), and its LHS and RHS must end with &lt;code&gt;/*&lt;/code&gt;. The above specifies that all remote branches are tracked using remote-tracking branches in &lt;code&gt;refs/remotes/origin/&lt;/code&gt; hierarchy under the same name.</source>
          <target state="translated">globbing refspec은 비어 있지 않은 RHS를 가져야하며 (즉, 원격 추적 브랜치에서 가져온 것을 저장해야 함) LHS 및 RHS는 &lt;code&gt;/*&lt;/code&gt; 로 끝나야합니다 . 위의 내용은 모든 원격 분기가 동일한 이름 으로 &lt;code&gt;refs/remotes/origin/&lt;/code&gt; 계층의 원격 추적 분기를 사용하여 추적되도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="45b9d757fdd2ed971a566d8afcb44af578620a00" translate="yes" xml:space="preserve">
          <source>A good place to start is with the contents of the initial commit, with:</source>
          <target state="translated">시작하기에 좋은 곳은 다음과 같이 초기 커밋의 내용입니다.</target>
        </trans-unit>
        <trans-unit id="9d5629e7ec2db5ea11dbadd12ca8d2c545f75144" translate="yes" xml:space="preserve">
          <source>A handy way to push the current branch to the same name on the remote.</source>
          <target state="translated">현재 분기를 원격에서 동일한 이름으로 푸시하는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8420ab633ffe4ffea61082096882d33b9782db25" translate="yes" xml:space="preserve">
          <source>A header appears at the beginning and consists of the following:</source>
          <target state="translated">머리글은 처음에 나타나며 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="bd26c474482563b0a0cde7feb34691662847c30b" translate="yes" xml:space="preserve">
          <source>A helper advertising the capability &lt;code&gt;refspec refs/heads/*:refs/svn/origin/branches/*&lt;/code&gt; is saying that, when it is asked to &lt;code&gt;import refs/heads/topic&lt;/code&gt;, the stream it outputs will update the &lt;code&gt;refs/svn/origin/branches/topic&lt;/code&gt; ref.</source>
          <target state="translated">&lt;code&gt;refspec refs/heads/*:refs/svn/origin/branches/*&lt;/code&gt; 기능을 광고하는 도우미 는 &lt;code&gt;import refs/heads/topic&lt;/code&gt; 요청 하면 출력 스트림이 &lt;code&gt;refs/svn/origin/branches/topic&lt;/code&gt; 참조</target>
        </trans-unit>
        <trans-unit id="a8a80004c991a3f9b4309875108440f77b31093a" translate="yes" xml:space="preserve">
          <source>A html file (HTML fragment) which is included on the gitweb project &quot;summary&quot; page inside &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; block element. You can use it for longer description of a project, to provide links (for example to project&amp;rsquo;s homepage), etc. This is recognized only if XSS prevention is off (&lt;code&gt;$prevent_xss&lt;/code&gt; is false, see &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf[5]&lt;/a&gt;); a way to include a README safely when XSS prevention is on may be worked out in the future.</source>
          <target state="translated">&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 블록 요소 내의 gitweb 프로젝트 &quot;요약&quot;페이지에 포함 된 html 파일 (HTML 조각) . 프로젝트의 더 긴 설명, 링크 (예 : 프로젝트의 홈페이지) 등을 제공하는 데 사용할 수 있습니다. 이는 XSS 방지가 해제 된 경우에만 인식됩니다 ( &lt;code&gt;$prevent_xss&lt;/code&gt; 가 false이면 &lt;a href=&quot;gitweb.conf&quot;&gt;gitweb.conf [5]&lt;/a&gt; 참조 ). XSS 방지 기능이 켜져있을 때 README를 안전하게 포함시키는 방법은 향후에 해결 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fd437060459f74aebbd18b9e1cd799a77abb2e3" translate="yes" xml:space="preserve">
          <source>A human-readable explanation. In the case of successfully fetched refs, no explanation is needed. For a failed ref, the reason for failure is described.</source>
          <target state="translated">사람이 읽을 수있는 설명. 성공적으로 가져온 참조의 경우 설명이 필요하지 않습니다. 실패한 심판의 경우 실패 이유가 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="41f2620460bac465215c8ebb35f39e6332181467" translate="yes" xml:space="preserve">
          <source>A human-readable explanation. In the case of successfully pushed refs, no explanation is needed. For a failed ref, the reason for failure is described.</source>
          <target state="translated">사람이 읽을 수있는 설명. 심판을 성공적으로 푸시 한 경우에는 설명이 필요하지 않습니다. 실패한 심판의 경우 실패 이유가 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="7a9b8dd4dd7232e67cd2ac62d96fc72ced1418df" translate="yes" xml:space="preserve">
          <source>A leading &quot;&lt;code&gt;**&lt;/code&gt;&quot; followed by a slash means match in all directories. For example, &quot;&lt;code&gt;**/foo&lt;/code&gt;&quot; matches file or directory &quot;&lt;code&gt;foo&lt;/code&gt;&quot; anywhere, the same as pattern &quot;&lt;code&gt;foo&lt;/code&gt;&quot;. &quot;&lt;code&gt;**/foo/bar&lt;/code&gt;&quot; matches file or directory &quot;&lt;code&gt;bar&lt;/code&gt;&quot; anywhere that is directly under directory &quot;&lt;code&gt;foo&lt;/code&gt;&quot;.</source>
          <target state="translated">슬래시가 앞에 오는 &quot; &lt;code&gt;**&lt;/code&gt; &quot;는 모든 디렉토리에서 일치 함을 의미합니다. 예를 들어, &quot; &lt;code&gt;**/foo&lt;/code&gt; &quot; 는 패턴 &quot; &lt;code&gt;foo&lt;/code&gt; &quot; 와 동일하게 파일 또는 디렉토리 &quot; &lt;code&gt;foo&lt;/code&gt; &quot; 와 일치합니다 . &quot; &lt;code&gt;**/foo/bar&lt;/code&gt; &quot;파일 또는 디렉터리 &quot;일치 &lt;code&gt;bar&lt;/code&gt; 에 직접 디렉토리&quot;아래 &quot;어디 &lt;code&gt;foo&lt;/code&gt; 는 &quot;.</target>
        </trans-unit>
        <trans-unit id="97f6b7568cdd7cd0d826aa05b6dbc1219066bda8" translate="yes" xml:space="preserve">
          <source>A leading &amp;ldquo;&lt;strong&gt;&amp;rdquo; followed by a slash means match in all directories. For example, &amp;ldquo;&lt;/strong&gt;/foo&amp;rdquo; matches file or directory &amp;ldquo;foo&amp;rdquo; anywhere, the same as pattern &amp;ldquo;foo&amp;rdquo;. &amp;ldquo;**/foo/bar&amp;rdquo; matches file or directory &amp;ldquo;bar&amp;rdquo; anywhere that is directly under directory &amp;ldquo;foo&amp;rdquo;.</source>
          <target state="translated">&lt;strong&gt;슬래시가 앞에 오는&lt;/strong&gt; &quot; &lt;strong&gt;&quot;는 모든 디렉토리에서 일치 함을 의미합니다. &lt;/strong&gt;&lt;strong&gt;예를 들어, &quot;&lt;/strong&gt; / foo&quot;는 패턴 &quot;foo&quot;와 동일하게 파일 또는 디렉토리 &quot;foo&quot;와 일치합니다. &amp;ldquo;** / foo / bar&amp;rdquo;는&amp;ldquo;foo&amp;rdquo;디렉토리 바로 아래에있는 파일 또는 디렉토리&amp;ldquo;bar&amp;rdquo;와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2c8f962f2c5484e8e35937a88a5b10524899265d" translate="yes" xml:space="preserve">
          <source>A line starting with # serves as a comment. Put a backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;) in front of the first hash for patterns that begin with a hash.</source>
          <target state="translated">#으로 시작하는 줄은 주석 역할을합니다. 해시로 시작하는 패턴의 경우 첫 번째 해시 앞에 백 슬래시 ( &quot; &lt;code&gt;\&lt;/code&gt; &quot;)를 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="93ea1d2be8a3f17ecb8e1b8c1df7c56dd65b653c" translate="yes" xml:space="preserve">
          <source>A line that defines a value can be continued to the next line by ending it with a &lt;code&gt;\&lt;/code&gt;; the backquote and the end-of-line are stripped. Leading whitespaces after &lt;code&gt;name =&lt;/code&gt;, the remainder of the line after the first comment character &lt;code&gt;#&lt;/code&gt; or &lt;code&gt;;&lt;/code&gt;, and trailing whitespaces of the line are discarded unless they are enclosed in double quotes. Internal whitespaces within the value are retained verbatim.</source>
          <target state="translated">값을 정의하는 행은 &lt;code&gt;\&lt;/code&gt; 로 끝나서 다음 행으로 계속 될 수 있습니다 . backquote 및 줄 끝이 제거됩니다. &lt;code&gt;name =&lt;/code&gt; 다음의 선행 공백 , 첫 번째 주석 문자 다음의 행의 나머지 &lt;code&gt;#&lt;/code&gt; 또는 &lt;code&gt;;&lt;/code&gt; 행의 후행 공백은 큰 따옴표로 묶지 않으면 무시됩니다. 값 내의 내부 공백은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="e045379bf9ceca1c017025a4aa6255f96ea8439c" translate="yes" xml:space="preserve">
          <source>A list of SSL ciphers to use when negotiating an SSL connection. The available ciphers depend on whether libcurl was built against NSS or OpenSSL and the particular configuration of the crypto library in use. Internally this sets the &lt;code&gt;CURLOPT_SSL_CIPHER_LIST&lt;/code&gt; option; see the libcurl documentation for more details on the format of this list.</source>
          <target state="translated">SSL 연결을 협상 할 때 사용할 SSL 암호 목록입니다. 사용 가능한 암호는 libcurl이 NSS 또는 OpenSSL에 대해 빌드되었는지 여부와 사용중인 암호화 라이브러리의 특정 구성에 따라 다릅니다. 내부적으로 &lt;code&gt;CURLOPT_SSL_CIPHER_LIST&lt;/code&gt; 옵션 이 설정됩니다 . 이 목록의 형식에 대한 자세한 내용은 libcurl 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6c29c3e295aee253a56f78c75eca16ee4e34a579" translate="yes" xml:space="preserve">
          <source>A list of arguments, acceptable to &lt;code&gt;git rev-parse&lt;/code&gt; and &lt;code&gt;git rev-list&lt;/code&gt; (and containing a named ref, see SPECIFYING REFERENCES below), that specifies the specific objects and references to transport. For example, &lt;code&gt;master~10..master&lt;/code&gt; causes the current master reference to be packaged along with all objects added since its 10th ancestor commit. There is no explicit limit to the number of references and objects that may be packaged.</source>
          <target state="translated">&lt;code&gt;git rev-parse&lt;/code&gt; 및 &lt;code&gt;git rev-list&lt;/code&gt; 에 허용되는 인수 목록 (명명 된 ref를 포함하면 아래의 SPECIFYING REFERENCES 참조)은 전송에 대한 특정 객체 및 참조를 지정합니다. 예를 들어 &lt;code&gt;master~10..master&lt;/code&gt; 는 현재 마스터 참조가 10 번째 상위 커밋 이후 추가 된 모든 객체와 함께 패키지되도록합니다. 패키징 될 수있는 참조 및 객체의 수에는 명시적인 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="420b50217489bdf5f6fb9acc6b31c779455eb7fa" translate="yes" xml:space="preserve">
          <source>A list of arguments, acceptable to &lt;code&gt;git rev-parse&lt;/code&gt; and &lt;code&gt;git rev-list&lt;/code&gt;, that specifies the specific objects and references to export. For example, &lt;code&gt;master~10..master&lt;/code&gt; causes the current master reference to be exported along with all objects added since its 10th ancestor commit and (unless the --reference-excluded-parents option is specified) all files common to master~9 and master~10.</source>
          <target state="translated">&lt;code&gt;git rev-parse&lt;/code&gt; 및 &lt;code&gt;git rev-list&lt;/code&gt; 에 허용되는 인수 목록으로 , 내보낼 특정 객체 및 참조를 지정합니다. 예를 들어 &lt;code&gt;master~10..master&lt;/code&gt; 는 10 번째 상위 커밋 이후에 추가 된 모든 객체와 함께 ----- excluded-parents 옵션을 지정하지 않는 한 master ~ 9 및 마스터 ~ 10.</target>
        </trans-unit>
        <trans-unit id="fb05e036e321c60d20fab2990848c796c4fdcdc0" translate="yes" xml:space="preserve">
          <source>A list of colors, separated by commas, that can be used to draw history lines in &lt;code&gt;git log --graph&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git log --graph&lt;/code&gt; 에 히스토리 라인을 그리는 데 사용할 수있는 쉼표로 구분 된 색상 목록 .</target>
        </trans-unit>
        <trans-unit id="bf5bc7dd64f11fdc046f9ab831535ad5346e3642" translate="yes" xml:space="preserve">
          <source>A list of metadata for the ith object ID including:</source>
          <target state="translated">i 번째 객체 ID의 메타 데이터 목록은 다음을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="71a1660072afab5f192d304c6526e11a86c64fed" translate="yes" xml:space="preserve">
          <source>A list of objects, where each &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; in the list contains a reference to its successor (for example, the successor of a &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; could be one of its &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt;).</source>
          <target state="translated">목록의 각 &lt;a href=&quot;#def_object&quot;&gt;객체&lt;/a&gt; 가 후속 작업에 대한 참조를 포함하는 객체 목록입니다 (예 : &lt;a href=&quot;#def_commit&quot;&gt;커밋&lt;/a&gt; 의 후속 작업은 &lt;a href=&quot;#def_parent&quot;&gt;부모&lt;/a&gt; 중 하나 일 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="b5ed6b3e420a3426ad69e7d40c511b1585c55951" translate="yes" xml:space="preserve">
          <source>A list of packfile names.</source>
          <target state="translated">팩 파일 이름의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="eacf8acfc6a510356f2536425e15b68215e037b6" translate="yes" xml:space="preserve">
          <source>A list of references used to limit the references reported as available. This is principally of use to &lt;code&gt;git fetch&lt;/code&gt;, which expects to receive only those references asked for and not necessarily everything in the pack (in this case, &lt;code&gt;git bundle&lt;/code&gt; acts like &lt;code&gt;git fetch-pack&lt;/code&gt;).</source>
          <target state="translated">사용 가능한 것으로보고 된 참조를 제한하는 데 사용되는 참조 목록입니다. 이것은 주로 &lt;code&gt;git fetch&lt;/code&gt; 에 사용 되는 것으로, 요청 된 참조 만 받고 팩의 모든 내용을 수신 할 필요는 없습니다 (이 경우 &lt;code&gt;git bundle&lt;/code&gt; 은 &lt;code&gt;git fetch-pack&lt;/code&gt; 과 동일 함 ).</target>
        </trans-unit>
        <trans-unit id="97e674656171c048f36512c6e555d0bf166acfba" translate="yes" xml:space="preserve">
          <source>A listing will be written to stdout providing the association of temporary file names to tracked path names. The listing format has two variations:</source>
          <target state="translated">임시 파일 이름과 추적 경로 이름의 연관성을 제공하는 목록이 stdout에 작성됩니다. 리스팅 형식에는 두 가지 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f1fa860bd3075a2f2e7d9bfa6fd3e508ce503b8" translate="yes" xml:space="preserve">
          <source>A long running filter demo implementation can be found in &lt;code&gt;contrib/long-running-filter/example.pl&lt;/code&gt; located in the Git core repository. If you develop your own long running filter process then the &lt;code&gt;GIT_TRACE_PACKET&lt;/code&gt; environment variables can be very helpful for debugging (see &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt;).</source>
          <target state="translated">장기 실행 필터 데모 구현은 Git 코어 저장소에 있는 &lt;code&gt;contrib/long-running-filter/example.pl&lt;/code&gt; 에서 찾을 수 있습니다 . 자체 장기 실행 필터 프로세스를 개발하는 경우 &lt;code&gt;GIT_TRACE_PACKET&lt;/code&gt; 환경 변수가 디버깅에 매우 유용 할 수 있습니다 ( &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0c85a74fa5c3962acf646f43bc3d679fdbcbb049" translate="yes" xml:space="preserve">
          <source>A mapping will override any user information from P4. Mappings for multiple P4 user can be defined.</source>
          <target state="translated">매핑은 P4의 모든 사용자 정보를 무시합니다. 여러 P4 사용자에 대한 매핑을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f830620e3507664edd811855851325f3aba696d1" translate="yes" xml:space="preserve">
          <source>A mark reference, &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;idnum&amp;gt;&lt;/code&gt; is the mark number.</source>
          <target state="translated">마크 참조 &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; . 여기서 &lt;code&gt;&amp;lt;idnum&amp;gt;&lt;/code&gt; 은 마크 번호입니다.</target>
        </trans-unit>
        <trans-unit id="baabb9591c6356cfbcbcedc1f1f1f517fd26280b" translate="yes" xml:space="preserve">
          <source>A merge is made by combining the changes made in &lt;code&gt;branchname&lt;/code&gt; and the changes made up to the latest commit in your current branch since their histories forked. The work tree is overwritten by the result of the merge when this combining is done cleanly, or overwritten by a half-merged results when this combining results in conflicts. Therefore, if you have uncommitted changes touching the same files as the ones impacted by the merge, Git will refuse to proceed. Most of the time, you will want to commit your changes before you can merge, and if you don&amp;rsquo;t, then &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt; can take these changes away while you&amp;rsquo;re doing the merge, and reapply them afterwards.</source>
          <target state="translated">병합은 &lt;code&gt;branchname&lt;/code&gt; 에서 작성된 변경 사항과 히스토리가 분기 된 이후 현재 분기의 최신 커미트에 작성된 변경 사항을 결합하여 수행 됩니다. 이 결합이 완전히 완료되면 병합 결과로 작업 트리를 겹쳐 쓰거나이 결합으로 인해 충돌이 발생하면 반 병합 결과로 겹쳐 씁니다. 따라서 병합으로 인해 영향을받는 것과 동일한 파일을 커밋하지 않은 변경 사항이 있으면 Git은 진행을 거부합니다. 대부분의 경우, 병합하기 전에 변경 사항을 커밋하고, 그렇지 않으면 병합하는 동안 &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]&lt;/a&gt; 가 이러한 변경 사항을 제거하고 나중에 다시 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4d489b543f60fc98d2a6018d75091a747eea01a" translate="yes" xml:space="preserve">
          <source>A merged version reconciling the changes from all branches to be merged is committed, and your &lt;code&gt;HEAD&lt;/code&gt;, index, and working tree are updated to it. It is possible to have modifications in the working tree as long as they do not overlap; the update will preserve them.</source>
          <target state="translated">병합 할 모든 브랜치의 변경 사항을 조정하는 병합 된 버전이 커밋되고 &lt;code&gt;HEAD&lt;/code&gt; , 인덱스 및 작업 트리가 업데이트됩니다. 작업 트리가 겹치지 않는 한 수정 작업을 수행 할 수 있습니다. 업데이트는 그것들을 보존 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="556c7318c2e7e187ba3d844ceeba1d7c90165db2" translate="yes" xml:space="preserve">
          <source>A minimal repository browser and Git tool output highlighter written in C using Ncurses.</source>
          <target state="translated">Ncurses를 사용하여 C로 작성된 최소 저장소 브라우저 및 Git 도구 출력 형광펜.</target>
        </trans-unit>
        <trans-unit id="0f82fb44f773fe4ef6363789a0bed7a920af8c57" translate="yes" xml:space="preserve">
          <source>A minor issue, but users who have a goal to update all names and emails in a repository may be led to --env-filter which will only update authors and committers, missing taggers.</source>
          <target state="translated">사소한 문제이지만 리포지토리의 모든 이름과 전자 메일을 업데이트하려는 목표를 가진 사용자는 --env-filter가 발생하여 태그 작성자가없는 작성자 및 커미터 만 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="ee7974b838cbb4f29c64d1d141d31a017781be24" translate="yes" xml:space="preserve">
          <source>A more detailed explanation follows.</source>
          <target state="translated">더 자세한 설명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1294d206b2b9b4a7e8a2c5b691b195e05326798f" translate="yes" xml:space="preserve">
          <source>A naive color-coded diff of diffs is actually a bit hard to read, though, as it colors the entire lines red or green. The line that added &quot;What is unexpected&quot; in the old commit, for example, is completely red, even if the intent of the old commit was to add something.</source>
          <target state="translated">순진한 색으로 구분 된 diff의 diff는 전체 줄을 빨간색 또는 녹색으로 표시하기 때문에 실제로 읽기가 약간 어렵습니다. 예를 들어, 이전 커밋의 의도가 무언가를 추가하려는 경우에도 이전 커밋에 &quot;What is unexpected&quot;가 추가 된 줄은 완전히 빨간색입니다.</target>
        </trans-unit>
        <trans-unit id="f995936d742d7948d27ea58d580269673915afeb" translate="yes" xml:space="preserve">
          <source>A name referring to a list of repositories as the value of remotes.&amp;lt;group&amp;gt; in the configuration file. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">구성 파일에서 remotes. &amp;lt;group&amp;gt;의 값으로 저장소 목록을 참조하는 이름. ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="285bedb08cb2a07c72d29f3452de603f4eff78e2" translate="yes" xml:space="preserve">
          <source>A name that begins with &lt;code&gt;refs/&lt;/code&gt; (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) that points to an &lt;a href=&quot;#def_object_name&quot;&gt;object name&lt;/a&gt; or another ref (the latter is called a &lt;a href=&quot;#def_symref&quot;&gt;symbolic ref&lt;/a&gt;). For convenience, a ref can sometimes be abbreviated when used as an argument to a Git command; see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; for details. Refs are stored in the &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;refs/&lt;/code&gt; 시작하는 이름 (예 : &lt;code&gt;refs/heads/master&lt;/code&gt; )은 &lt;a href=&quot;#def_object_name&quot;&gt;객체 이름&lt;/a&gt; 또는 다른 ref 를 가리 킵니다 (후자는 &lt;a href=&quot;#def_symref&quot;&gt;symbolic ref&lt;/a&gt; 라고 함 ). 편의상 Git 명령에 대한 인수로 사용될 때 ref가 약어로 표시 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 를 참조하십시오. 참조는 &lt;a href=&quot;#def_repository&quot;&gt;저장소에&lt;/a&gt; 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="7703b2466f10a68f3b1c01b58b3d6c6dd1bbbf9e" translate="yes" xml:space="preserve">
          <source>A newly created object is stored in its own file. The objects are splayed over 256 subdirectories using the first two characters of the sha1 object name to keep the number of directory entries in &lt;code&gt;objects&lt;/code&gt; itself to a manageable number. Objects found here are often called &lt;code&gt;unpacked&lt;/code&gt; (or &lt;code&gt;loose&lt;/code&gt;) objects.</source>
          <target state="translated">새로 만든 개체는 자체 파일에 저장됩니다. sha1 객체 이름의 처음 두 문자를 사용하여 256 개 이상의 하위 디렉토리를 통해 &lt;code&gt;objects&lt;/code&gt; 자체를 재생하여 객체 자체 의 디렉토리 항목 수를 관리 가능한 수로 유지합니다. 여기에있는 개체는 종종 &lt;code&gt;unpacked&lt;/code&gt; (또는 &lt;code&gt;loose&lt;/code&gt; ) 개체 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="4642a2b17c96a073cdb3a7085d71034eb452a227" translate="yes" xml:space="preserve">
          <source>A non-ambiguous short name of the objects name. The option core.warnAmbiguousRefs is used to select the strict abbreviation mode.</source>
          <target state="translated">객체 이름의 모호하지 않은 짧은 이름입니다. core.warnAmbiguousRefs 옵션은 엄격한 약어 모드를 선택하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="969533e24645fc570f9e6901a33806920e5cb706" translate="yes" xml:space="preserve">
          <source>A note on commit messages: Though not required, it&amp;rsquo;s a good idea to begin the commit message with a single short (less than 50 character) line summarizing the change, followed by a blank line and then a more thorough description. The text up to the first blank line in a commit message is treated as the commit title, and that title is used throughout Git. For example, &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; turns a commit into email, and it uses the title on the Subject line and the rest of the commit in the body.</source>
          <target state="translated">커밋 메시지에 대한 참고 사항 : 필수 사항은 아니지만 변경 내용을 요약하는 짧은 한 줄 (50 자 미만)로 커밋 메시지를 시작한 다음 빈 줄과 자세한 설명으로 시작하는 것이 좋습니다. 커밋 메시지의 첫 번째 빈 줄까지의 텍스트는 커밋 제목으로 취급되며 해당 제목은 Git 전체에서 사용됩니다. 예를 들어, &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; 은 커밋을 전자 메일로 변환하고 제목 줄의 제목과 본문의 나머지 커밋을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4dfc512a94e79667c45c7af73a6fa69e373a158c" translate="yes" xml:space="preserve">
          <source>A number controlling how many seconds to delay before showing optional progress indicators. Defaults to 2.</source>
          <target state="translated">선택적 진행률 표시기를 표시하기 전에 지연 시간 (초)을 제어하는 ​​숫자입니다. 기본값은 2입니다.</target>
        </trans-unit>
        <trans-unit id="678367292507a434e0e80079657b6dfcb1357dad" translate="yes" xml:space="preserve">
          <source>A number controlling the amount of output shown by the recursive merge strategy. Overrides merge.verbosity. See &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;</source>
          <target state="translated">재귀 병합 전략으로 표시되는 출력량을 제어하는 ​​숫자입니다. merge.verbosity를 대체합니다. &lt;a href=&quot;git-merge&quot;&gt;자식 병합&lt;/a&gt; 참조 [1]</target>
        </trans-unit>
        <trans-unit id="5b6753b358cd59601b720b7e321e301f821aeaac" translate="yes" xml:space="preserve">
          <source>A number of commands are useful for keeping track of what you&amp;rsquo;re about to commit:</source>
          <target state="translated">커밋하려는 내용을 추적하는 데 많은 명령이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9a527e05c01a1cd1e2fbbfb008d8a0a9991b3e36" translate="yes" xml:space="preserve">
          <source>A number of other receive.* config options are available to tweak its behavior, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">다른 receive. * 구성 옵션을 사용하여 동작을 조정할 수 있습니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b2735235afad8c3de74567bf475c2f66e22a1a38" translate="yes" xml:space="preserve">
          <source>A one-shot pull is a sign that a commit history is now crossing the boundary between one circle of people (e.g. &quot;people who are primarily interested in the networking part of the kernel&quot;) who may have their own set of tags (e.g. &quot;this is the third release candidate from the networking group to be proposed for general consumption with 2.6.21 release&quot;) to another circle of people (e.g. &quot;people who integrate various subsystem improvements&quot;). The latter are usually not interested in the detailed tags used internally in the former group (that is what &quot;internal&quot; means). That is why it is desirable not to follow tags automatically in this case.</source>
          <target state="translated">A one-shot pull is a sign that a commit history is now crossing the boundary between one circle of people (e.g. &quot;people who are primarily interested in the networking part of the kernel&quot;) who may have their own set of tags (e.g. &quot;this is the third release candidate from the networking group to be proposed for general consumption with 2.6.21 release&quot;) to another circle of people (e.g. &quot;people who integrate various subsystem improvements&quot;). The latter are usually not interested in the detailed tags used internally in the former group (that is what &quot;internal&quot; means). That is why it is desirable not to follow tags automatically in this case.</target>
        </trans-unit>
        <trans-unit id="9cabaac84bf06e47bfc060c7436d54129d5c9635" translate="yes" xml:space="preserve">
          <source>A pack index file (.idx) is generated for fast, random access to the objects in the pack. Placing both the index file (.idx) and the packed archive (.pack) in the pack/ subdirectory of $GIT_OBJECT_DIRECTORY (or any of the directories on $GIT_ALTERNATE_OBJECT_DIRECTORIES) enables Git to read from the pack archive.</source>
          <target state="translated">팩 색인 파일 (.idx)은 팩의 객체에 빠르고 무작위로 액세스 할 수 있도록 생성됩니다. $ GIT_OBJECT_DIRECTORY (또는 $ GIT_ALTERNATE_OBJECT_DIRECTORIES)의 pack / 서브 디렉토리 (또는 $ GIT_ALTERNATE_OBJECT_DIRECTORIES)의 디렉토리에 인덱스 파일 (.idx)과 압축 아카이브 (.pack)를 모두 배치하면 Git이 팩 아카이브에서 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="397ffaa6c68ed0147644cba4450a6f826844c8cb" translate="yes" xml:space="preserve">
          <source>A pack is a collection of objects, individually compressed, with delta compression applied, stored in a single file, with an associated index file.</source>
          <target state="translated">팩은 델타 압축이 적용된 개별 개체 모음으로, 관련 인덱스 파일과 함께 단일 파일에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="f35f65ed82291bd06ac4c67bd1644d87a71cb117" translate="yes" xml:space="preserve">
          <source>A packed archive can express the base object of a delta as either a 20-byte object name or as an offset in the stream, but ancient versions of Git don&amp;rsquo;t understand the latter. By default, &lt;code&gt;git pack-objects&lt;/code&gt; only uses the former format for better compatibility. This option allows the command to use the latter format for compactness. Depending on the average delta chain length, this option typically shrinks the resulting packfile by 3-5 per-cent.</source>
          <target state="translated">압축 된 아카이브는 델타의 기본 개체를 20 바이트 개체 이름 또는 스트림의 오프셋으로 표현할 수 있지만 고대 버전의 Git은 후자를 이해하지 못합니다. 기본적으로 &lt;code&gt;git pack-objects&lt;/code&gt; 는 호환성 향상을 위해 이전 형식 만 사용합니다. 이 옵션을 사용하면 명령이 압축을 위해 후자의 형식을 사용할 수 있습니다. 평균 델타 체인 길이에 따라이 옵션은 일반적으로 결과 팩 파일을 3-5 % 줄입니다.</target>
        </trans-unit>
        <trans-unit id="60fd37e1abf8d7c37fbc7d9812df5fcd79af795e" translate="yes" xml:space="preserve">
          <source>A packed archive is an efficient way to transfer a set of objects between two repositories as well as an access efficient archival format. In a packed archive, an object is either stored as a compressed whole or as a difference from some other object. The latter is often called a delta.</source>
          <target state="translated">압축 아카이브는 액세스 효율적인 아카이브 형식뿐만 아니라 두 저장소간에 오브젝트 세트를 전송하는 효율적인 방법입니다. 압축 된 아카이브에서 오브젝트는 압축 된 전체 또는 다른 오브젝트와의 차이로 저장됩니다. 후자는 종종 델타라고합니다.</target>
        </trans-unit>
        <trans-unit id="bf032ee74744146d5a15b7c697cecedcaf0b0c4f" translate="yes" xml:space="preserve">
          <source>A paragraph in the commit log message. This can be given more than once and each &amp;lt;message&amp;gt; becomes its own paragraph.</source>
          <target state="translated">커밋 로그 메시지의 단락. 이것은 두 번 이상 주어질 수 있으며 각 &amp;lt;message&amp;gt;는 자체 단락이됩니다.</target>
        </trans-unit>
        <trans-unit id="8ae6bc184aa1a805bb37320ee63c3bc2d3ceedc5" translate="yes" xml:space="preserve">
          <source>A particularly useful way is to see if an added file has lines created by copy-and-paste from existing files. Sometimes this indicates that the developer was being sloppy and did not refactor the code properly. You can first find the commit that introduced the file with:</source>
          <target state="translated">특히 유용한 방법은 추가 된 파일에 기존 파일에서 복사하여 붙여 넣기하여 만든 행이 있는지 확인하는 것입니다. 때때로 이것은 개발자가 조잡하고 코드를 올바르게 리팩토링하지 않았 음을 나타냅니다. 먼저 다음을 사용하여 파일을 소개 한 커밋을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70409c2f17849d4a005f3c1893f70bfb2726cd34" translate="yes" xml:space="preserve">
          <source>A path can use C-style string quoting; this is accepted in all cases and mandatory if the filename starts with double quote or contains &lt;code&gt;LF&lt;/code&gt;. In C-style quoting, the complete name should be surrounded with double quotes, and any &lt;code&gt;LF&lt;/code&gt;, backslash, or double quote characters must be escaped by preceding them with a backslash (e.g., &lt;code&gt;&quot;path/with\n, \\ and \&quot; in it&quot;&lt;/code&gt;).</source>
          <target state="translated">경로는 C 스타일 문자열 인용을 사용할 수 있습니다. 파일 이름이 큰 따옴표로 시작하거나 &lt;code&gt;LF&lt;/code&gt; 를 포함하는 경우 모든 경우에 허용되며 필수 입니다. C 스타일 인용에서 완전한 이름은 큰 따옴표로 묶어야하며 &lt;code&gt;LF&lt;/code&gt; , 백 슬래시 또는 큰 따옴표 문자 앞에는 백 슬래시를 붙여야합니다 (예 : &lt;code&gt;&quot;path/with\n, \\ and \&quot; in it&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bd2947c5ab63d63637e419f1d545864acc22513b" translate="yes" xml:space="preserve">
          <source>A path to which the &lt;code&gt;diff&lt;/code&gt; attribute is set is treated as text, even when they contain byte values that normally never appear in text files, such as NUL.</source>
          <target state="translated">&lt;code&gt;diff&lt;/code&gt; 속성이 설정 되는 경로 는 NUL과 같이 텍스트 파일에 일반적으로 나타나지 않는 바이트 값을 포함하더라도 텍스트로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="c497cf3cb539fc75cfa79107d99052fa1c172747" translate="yes" xml:space="preserve">
          <source>A path to which the &lt;code&gt;diff&lt;/code&gt; attribute is unset will generate &lt;code&gt;Binary files differ&lt;/code&gt; (or a binary patch, if binary patches are enabled).</source>
          <target state="translated">&lt;code&gt;diff&lt;/code&gt; 속성이 설정되지 않은 경로 는 &lt;code&gt;Binary files differ&lt;/code&gt; 생성 합니다 (또는 이진 패치가 활성화 된 경우 이진 패치).</target>
        </trans-unit>
        <trans-unit id="88c800d486d5ce3a0265a47a1feb9f3c335f6f77" translate="yes" xml:space="preserve">
          <source>A path to which the &lt;code&gt;diff&lt;/code&gt; attribute is unspecified first gets its contents inspected, and if it looks like text and is smaller than core.bigFileThreshold, it is treated as text. Otherwise it would generate &lt;code&gt;Binary files differ&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;diff&lt;/code&gt; 속성이 지정되지 않은 경로 는 먼저 내용을 검사하며 텍스트처럼 보이고 core.bigFileThreshold보다 작은 경우 텍스트로 처리됩니다. 그렇지 않으면 &lt;code&gt;Binary files differ&lt;/code&gt; 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="1de5fce3d256d15d9371f68eb7be9e8c39bff70d" translate="yes" xml:space="preserve">
          <source>A pathspec that begins with a colon &lt;code&gt;:&lt;/code&gt; has special meaning. In the short form, the leading colon &lt;code&gt;:&lt;/code&gt; is followed by zero or more &quot;magic signature&quot; letters (which optionally is terminated by another colon &lt;code&gt;:&lt;/code&gt;), and the remainder is the pattern to match against the path. The &quot;magic signature&quot; consists of ASCII symbols that are neither alphanumeric, glob, regex special characters nor colon. The optional colon that terminates the &quot;magic signature&quot; can be omitted if the pattern begins with a character that does not belong to &quot;magic signature&quot; symbol set and is not a colon.</source>
          <target state="translated">콜론으로 시작하는 pathspec는 &lt;code&gt;:&lt;/code&gt; 특별한 의미가 있습니다. 짧은 형태에서, 최고의 콜론 &lt;code&gt;:&lt;/code&gt; 제로 또는 (선택적으로 다른 콜론 종료 더 &quot;마법 서명&quot;문자 뒤에 &lt;code&gt;:&lt;/code&gt; ), 나머지는 경로에 대해 일치하는 패턴이다. &quot;마법 서명&quot;은 영숫자, glob, 정규식 특수 문자 또는 콜론이 아닌 ASCII 기호로 구성됩니다. 패턴이 &quot;magic signature&quot;기호 세트에 속하지 않고 콜론이 아닌 문자로 시작하는 경우 &quot;magic signature&quot;를 종료하는 선택적 콜론은 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dbd2b8e2f5a79d8f4767d53dab7382344add01a" translate="yes" xml:space="preserve">
          <source>A pathspec with only a colon means &quot;there is no pathspec&quot;. This form should not be combined with other pathspec.</source>
          <target state="translated">콜론 만있는 pathspec은 &quot;pathspec이 없음&quot;을 의미합니다. 이 형식은 다른 경로 사양과 결합해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="905a72351f89ce389bbe3fe0bc52dfbff0e65e1a" translate="yes" xml:space="preserve">
          <source>A pattern specified on the command line with --exclude or read from the file specified with --exclude-from is relative to the top of the directory tree. A pattern read from a file specified by --exclude-per-directory is relative to the directory that the pattern file appears in.</source>
          <target state="translated">--exclude-from으로 지정된 파일에서 --exclude 또는 read로 명령 줄에 지정된 패턴은 디렉토리 트리의 상단에 상대적입니다. --exclude-per-directory로 지정된 파일에서 읽은 패턴은 패턴 파일이 나타나는 디렉토리와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="543c0b6dffa14304d5bbca9c7badb06a27012480" translate="yes" xml:space="preserve">
          <source>A plain file &lt;code&gt;.git&lt;/code&gt; at the root of a working tree that points at the directory that is the real repository.</source>
          <target state="translated">실제 저장소 인 디렉토리를 가리키는 작업 트리의 루트에있는 일반 파일 &lt;code&gt;.git&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d67f2fd432760e7725d26e3c634fda7223350a3d" translate="yes" xml:space="preserve">
          <source>A portable graphical interface to Git</source>
          <target state="translated">Git의 휴대용 그래픽 인터페이스</target>
        </trans-unit>
        <trans-unit id="de9f6646a7f195313b665f81866ba2d97ea2d1a5" translate="yes" xml:space="preserve">
          <source>A project will often generate files that you do 'not' want to track with Git. This typically includes files generated by a build process or temporary backup files made by your editor. Of course, 'not' tracking files with Git is just a matter of 'not' calling &lt;code&gt;git add&lt;/code&gt; on them. But it quickly becomes annoying to have these untracked files lying around; e.g. they make &lt;code&gt;git add .&lt;/code&gt; practically useless, and they keep showing up in the output of &lt;code&gt;git status&lt;/code&gt;.</source>
          <target state="translated">프로젝트는 종종 Git으로 추적하고 싶지 않은 파일을 생성합니다. 일반적으로 빌드 프로세스에서 생성 된 파일 또는 편집기에서 만든 임시 백업 파일이 포함됩니다. 물론 Git으로 파일을 추적하는 'not'은 단순히 &lt;code&gt;git add&lt;/code&gt; 를 호출하지 않는 것입니다. 그러나 이러한 추적되지 않은 파일을 둘러싼다는 것은 곧 성가신 일입니다. 예를 들어 그들은 &lt;code&gt;git add .&lt;/code&gt; 실제로 쓸모가 없으며 &lt;code&gt;git status&lt;/code&gt; 출력에 계속 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="257e75db65122bff5f846fed19aa444a60cd8028" translate="yes" xml:space="preserve">
          <source>A project will often generate files that you do &lt;code&gt;not&lt;/code&gt; want to track with Git. This typically includes files generated by a build process or temporary backup files made by your editor. Of course, &lt;code&gt;not&lt;/code&gt; tracking files with Git is just a matter of &lt;code&gt;not&lt;/code&gt; calling &lt;code&gt;git add&lt;/code&gt; on them. But it quickly becomes annoying to have these untracked files lying around; e.g. they make &lt;code&gt;git add .&lt;/code&gt; practically useless, and they keep showing up in the output of &lt;code&gt;git status&lt;/code&gt;.</source>
          <target state="translated">프로젝트는 종종 Git으로 추적하고 싶지 &lt;code&gt;not&lt;/code&gt; 파일을 생성합니다 . 여기에는 일반적으로 빌드 프로세스에서 생성 된 파일 또는 편집기에서 만든 임시 백업 파일이 포함됩니다. 물론, &lt;code&gt;not&lt;/code&gt; 망할 놈의 파일을 추적 단지의 문제입니다 &lt;code&gt;not&lt;/code&gt; 호출 &lt;code&gt;git add&lt;/code&gt; 그들에 있습니다. 그러나 이러한 추적되지 않은 파일이 주변에 놓여 있으면 금방 짜증이납니다. 예를 들어 그들은 &lt;code&gt;git add .&lt;/code&gt; 거의 쓸모없고 &lt;code&gt;git status&lt;/code&gt; 출력에 계속 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="6db2ee1a1d750a2aa19ca518ec09fb893a88a85d" translate="yes" xml:space="preserve">
          <source>A range of commits could also be removed with rebase. If we have the following situation:</source>
          <target state="translated">rebase를 사용하여 커밋 범위를 제거 할 수도 있습니다. 다음과 같은 상황이 발생하면</target>
        </trans-unit>
        <trans-unit id="a9d115fddbdf7f10bd3b9f771bde1590c6813bbd" translate="yes" xml:space="preserve">
          <source>A really simple TCP Git daemon that normally listens on port &quot;DEFAULT_GIT_PORT&quot; aka 9418. It waits for a connection asking for a service, and will serve that service if it is enabled.</source>
          <target state="translated">일반적으로 포트 &quot;DEFAULT_GIT_PORT&quot;(일명 9418)에서 수신 대기하는 매우 간단한 TCP Git 데몬입니다. 서비스를 요청하는 연결을 기다리고 해당 서비스가 활성화 된 경우 서비스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3eaf62e43457d050db3acd458814891c29242983" translate="yes" xml:space="preserve">
          <source>A really simple server for Git repositories</source>
          <target state="translated">Git 리포지토리를위한 정말 간단한 서버</target>
        </trans-unit>
        <trans-unit id="d9323a3a61d783f2901a029c1a9555370896ed64" translate="yes" xml:space="preserve">
          <source>A recommended practice to deal with a repository with too many refs is to pack its refs with &lt;code&gt;--all&lt;/code&gt; once, and occasionally run &lt;code&gt;git pack-refs&lt;/code&gt;. Tags are by definition stationary and are not expected to change. Branch heads will be packed with the initial &lt;code&gt;pack-refs --all&lt;/code&gt;, but only the currently active branch heads will become unpacked, and the next &lt;code&gt;pack-refs&lt;/code&gt; (without &lt;code&gt;--all&lt;/code&gt;) will leave them unpacked.</source>
          <target state="translated">너무 많은 참조가있는 저장소를 처리하는 권장 방법은 참조를 &lt;code&gt;--all&lt;/code&gt; 한 번 &lt;code&gt;git pack-refs&lt;/code&gt; 하고 때로는 git pack-refs를 실행하는 것 입니다. 태그는 정의에 따라 고정되어 있으며 변경되지 않습니다. 브랜치 헤드는 초기 &lt;code&gt;pack-refs --all&lt;/code&gt; 로 포장 되지만 현재 활성화 된 브랜치 헤드 만 포장이 풀리고 다음 &lt;code&gt;pack-refs&lt;/code&gt; ( &lt;code&gt;--all&lt;/code&gt; 제외)는 포장을 풀게됩니다.</target>
        </trans-unit>
        <trans-unit id="69fd7125bed2f55c76f0826ae0ec95817fbc826b" translate="yes" xml:space="preserve">
          <source>A recommended work cycle for a &quot;subsystem maintainer&quot; who works on that project and has an own &quot;public repository&quot; goes like this:</source>
          <target state="translated">해당 프로젝트에서 작업하고 자체 &quot;공용 저장소&quot;가있는 &quot;하위 시스템 관리자&quot;에 권장되는 작업주기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4fc51d6ef6719c059d48b71f7162885a19b6d5bb" translate="yes" xml:space="preserve">
          <source>A recommended work cycle for an &quot;individual developer&quot; who does not have a &quot;public&quot; repository is somewhat different. It goes like this:</source>
          <target state="translated">&quot;공개&quot;저장소가없는 &quot;개별 개발자&quot;의 권장 작업주기는 다소 다릅니다. 다음과 같이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="d5352ae383650a2fe850c6303d60d8b60b542b21" translate="yes" xml:space="preserve">
          <source>A recommended workflow for a &quot;project lead&quot; goes like this:</source>
          <target state="translated">&quot;프로젝트 리더&quot;에 권장되는 워크 플로우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="265a7c950336ee05f26938c5f28759002d86d93b" translate="yes" xml:space="preserve">
          <source>A ref followed by the suffix &lt;code&gt;@&lt;/code&gt; with a date specification enclosed in a brace pair (e.g. &lt;code&gt;{yesterday}&lt;/code&gt;, &lt;code&gt;{1 month 2 weeks 3 days 1 hour 1 second ago}&lt;/code&gt; or &lt;code&gt;{1979-02-26 18:30:00}&lt;/code&gt;) specifies the value of the ref at a prior point in time. This suffix may only be used immediately following a ref name and the ref must have an existing log (&lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt;). Note that this looks up the state of your &lt;strong&gt;local&lt;/strong&gt; ref at a given time; e.g., what was in your local &lt;code&gt;master&lt;/code&gt; branch last week. If you want to look at commits made during certain times, see &lt;code&gt;--since&lt;/code&gt; and &lt;code&gt;--until&lt;/code&gt;.</source>
          <target state="translated">괄호 쌍으로 묶인 날짜 스펙이 있는 접미사 &lt;code&gt;@&lt;/code&gt; 뒤에 오는 접미사 (예 : &lt;code&gt;{yesterday}&lt;/code&gt; , &lt;code&gt;{1 month 2 weeks 3 days 1 hour 1 second ago}&lt;/code&gt; 또는 &lt;code&gt;{1979-02-26 18:30:00}&lt;/code&gt; ) 이전 시점에서의 심판의 가치. 이 접미사는 참조 이름 바로 뒤에 만 사용할 수 있으며 참조에는 기존 로그 ( &lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt; ) 가 있어야합니다 . 주어진 시간에 &lt;strong&gt;지역&lt;/strong&gt; 심판 의 상태를 찾습니다 . 예를 들어, 지난 주에 지역 &lt;code&gt;master&lt;/code&gt; 지점 에 있었던 것 . 당신이 특정 시간 동안 만들어진 커밋보고 싶을 경우, 참조 &lt;code&gt;--since&lt;/code&gt; 및 &lt;code&gt;--until&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="51716c72ef284c873d21cfca784e510780211d59" translate="yes" xml:space="preserve">
          <source>A ref followed by the suffix &lt;code&gt;@&lt;/code&gt; with an ordinal specification enclosed in a brace pair (e.g. &lt;code&gt;{1}&lt;/code&gt;, &lt;code&gt;{15}&lt;/code&gt;) specifies the n-th prior value of that ref. For example &lt;code&gt;master@{1}&lt;/code&gt; is the immediate prior value of &lt;code&gt;master&lt;/code&gt; while &lt;code&gt;master@{5}&lt;/code&gt; is the 5th prior value of &lt;code&gt;master&lt;/code&gt;. This suffix may only be used immediately following a ref name and the ref must have an existing log (&lt;code&gt;$GIT_DIR/logs/&amp;lt;refname&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">괄호 쌍 (예 : &lt;code&gt;{1}&lt;/code&gt; , &lt;code&gt;{15}&lt;/code&gt; )으로 묶인 서수 지정이 있는 접미사 &lt;code&gt;@&lt;/code&gt; 뒤에 오는 참조 는 해당 참조의 n 번째 이전 값을 지정합니다. 예를 들어 &lt;code&gt;master@{1}&lt;/code&gt; 의 바로 이전 값 &lt;code&gt;master&lt;/code&gt; 하면서 &lt;code&gt;master@{5}&lt;/code&gt; 의 5 이전 값 &lt;code&gt;master&lt;/code&gt; . 이 접미사는 참조 이름 바로 뒤에 만 사용할 수 있으며 참조에는 기존 로그 ( &lt;code&gt;$GIT_DIR/logs/&amp;lt;refname&amp;gt;&lt;/code&gt; ) 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c828d8d799658a52963b92e85f92230ddce05633" translate="yes" xml:space="preserve">
          <source>A reference is used in Git to specify branches and tags. A branch head is stored in the &lt;code&gt;refs/heads&lt;/code&gt; hierarchy, while a tag is stored in the &lt;code&gt;refs/tags&lt;/code&gt; hierarchy of the ref namespace (typically in &lt;code&gt;$GIT_DIR/refs/heads&lt;/code&gt; and &lt;code&gt;$GIT_DIR/refs/tags&lt;/code&gt; directories or, as entries in file &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; if refs are packed by &lt;code&gt;git gc&lt;/code&gt;).</source>
          <target state="translated">Git에서 참조는 분기 및 태그를 지정하는 데 사용됩니다. 분기 헤드는 &lt;code&gt;refs/heads&lt;/code&gt; 계층 구조에 저장되는 반면, 태그는 ref 네임 스페이스 의 &lt;code&gt;refs/tags&lt;/code&gt; 계층 구조 (일반적으로 &lt;code&gt;$GIT_DIR/refs/heads&lt;/code&gt; 및 &lt;code&gt;$GIT_DIR/refs/tags&lt;/code&gt; 디렉토리 또는 파일의 항목으로 저장 됨)에 저장됩니다. &lt;code&gt;$GIT_DIR/packed-refs&lt;/code&gt; 가 &lt;code&gt;git gc&lt;/code&gt; 에 의해 압축되는 경우 $ GIT_DIR / packed-refs .</target>
        </trans-unit>
        <trans-unit id="199d9188e1602cc5ab2dbdeca79c96ef9dded776" translate="yes" xml:space="preserve">
          <source>A reference of the form &lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt;. When no &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; is given, the latest stash is assumed (that is, &lt;code&gt;stash@{0}&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;stash@{&amp;lt;revision&amp;gt;}&lt;/code&gt; 형식의 참조입니다 . &lt;code&gt;&amp;lt;stash&amp;gt;&lt;/code&gt; 가 제공 되지 않으면 최신 숨김이 가정됩니다 (즉, &lt;code&gt;stash@{0}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="38b0c287bc0250d0d7c7ad1e770e07055b7fabea" translate="yes" xml:space="preserve">
          <source>A reflog shows the local &quot;history&quot; of a ref. In other words, it can tell you what the 3rd last revision in &lt;code&gt;this&lt;/code&gt; repository was, and what was the current state in &lt;code&gt;this&lt;/code&gt; repository, yesterday 9:14pm. See &lt;a href=&quot;git-reflog&quot;&gt;git-reflog[1]&lt;/a&gt; for details.</source>
          <target state="translated">Reflog는 심판의 로컬 &quot;역사&quot;를 보여줍니다. 즉, 3 번째 최종 개정 무엇을 말할 수있는 &lt;code&gt;this&lt;/code&gt; 저장소, 그리고 어떤 것은에서 현재 상태였다 &lt;code&gt;this&lt;/code&gt; 저장소, 어제 오후 9시 14분. 자세한 내용은 &lt;a href=&quot;git-reflog&quot;&gt;git-reflog [1]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b5d85fab27e60023cfb23c382a480074950bc3b6" translate="yes" xml:space="preserve">
          <source>A regular &lt;code&gt;D..M&lt;/code&gt; computes the set of commits that are ancestors of &lt;code&gt;M&lt;/code&gt;, but excludes the ones that are ancestors of &lt;code&gt;D&lt;/code&gt;. This is useful to see what happened to the history leading to &lt;code&gt;M&lt;/code&gt; since &lt;code&gt;D&lt;/code&gt;, in the sense that &amp;ldquo;what does &lt;code&gt;M&lt;/code&gt; have that did not exist in &lt;code&gt;D&lt;/code&gt;&amp;rdquo;. The result in this example would be all the commits, except &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; (and &lt;code&gt;D&lt;/code&gt; itself, of course).</source>
          <target state="translated">일반 &lt;code&gt;D..M&lt;/code&gt; 은 &lt;code&gt;M&lt;/code&gt; 의 조상 인 커밋 세트를 계산 하지만 &lt;code&gt;D&lt;/code&gt; 의 조상 인 커밋은 제외합니다 . 이것은 &amp;ldquo; &lt;code&gt;D&lt;/code&gt; 에 존재하지 않은 &lt;code&gt;M&lt;/code&gt; 의 것은 무엇&amp;rdquo;이라는 의미에서 &lt;code&gt;D&lt;/code&gt; 이후 &lt;code&gt;M&lt;/code&gt; 으로 이어지는 역사에 무슨 일이 있었는지 보는 데 유용합니다 . 이 예제의 결과는 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; (그리고 물론 &lt;code&gt;D&lt;/code&gt; 자체)를 제외한 모든 커밋이 됩니다.</target>
        </trans-unit>
        <trans-unit id="2ed028af5f97bfe4672822d1dbdbcfbdfebcb455" translate="yes" xml:space="preserve">
          <source>A regular Git &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; that is used by a developer to identify a conceptual line of development. Since branches are very easy and inexpensive, it is often desirable to have several small branches that each contain very well defined concepts or small incremental yet related changes.</source>
          <target state="translated">개발자가 개념적 개발 라인을 식별하는 데 사용 하는 정규 Git &lt;a href=&quot;#def_branch&quot;&gt;브랜치&lt;/a&gt; 입니다. 브랜치는 매우 쉽고 저렴하기 때문에 각각 매우 잘 정의 된 개념 또는 작은 증분이지만 관련 변경을 포함하는 여러 개의 작은 브랜치를 갖는 것이 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="2a66b0bccadf6b4b35ab899aad4e51fd773c916c" translate="yes" xml:space="preserve">
          <source>A remote branch name for tracking updates in the upstream submodule. If the option is not specified, it defaults to &lt;code&gt;master&lt;/code&gt;. A special value of &lt;code&gt;.&lt;/code&gt; is used to indicate that the name of the branch in the submodule should be the same name as the current branch in the current repository. See the &lt;code&gt;--remote&lt;/code&gt; documentation in &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; for details.</source>
          <target state="translated">업스트림 하위 모듈에서 업데이트를 추적하기위한 원격 지점 이름입니다. 이 옵션을 지정하지 않으면 기본값은 &lt;code&gt;master&lt;/code&gt; 입니다. 의 특별한 가치 &lt;code&gt;.&lt;/code&gt; 하위 모듈의 분기 이름이 현재 저장소의 현재 분기 이름과 같아야 함을 나타내는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; 의 &lt;code&gt;--remote&lt;/code&gt; 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8604e0756efd07146f34033a41aaf331102e52fc" translate="yes" xml:space="preserve">
          <source>A remote branch name for tracking updates in the upstream submodule. If the option is not specified, it defaults to the remote &lt;code&gt;HEAD&lt;/code&gt;. A special value of &lt;code&gt;.&lt;/code&gt; is used to indicate that the name of the branch in the submodule should be the same name as the current branch in the current repository. See the &lt;code&gt;--remote&lt;/code&gt; documentation in &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt; for details.</source>
          <target state="translated">업스트림 하위 모듈에서 업데이트를 추적하기위한 원격 분기 이름입니다. 옵션이 지정되지 않은 경우 기본값은 원격 &lt;code&gt;HEAD&lt;/code&gt; 입니다. 특수 값 &lt;code&gt;.&lt;/code&gt; 서브 모듈에있는 브랜치의 이름이 현재 저장소의 현재 브랜치와 같은 이름이어야 함을 나타내는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; 의 &lt;code&gt;--remote&lt;/code&gt; 문서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8a9a8ecf4e3c29353c757ea95408f73fb557ebe2" translate="yes" xml:space="preserve">
          <source>A remote host to house the repository. When this part is specified, &lt;code&gt;git-receive-pack&lt;/code&gt; is invoked via ssh.</source>
          <target state="translated">저장소를 보관할 원격 호스트. 이 부분이 지정되면 &lt;code&gt;git-receive-pack&lt;/code&gt; 이 ssh를 통해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cd3cc062c2af6416292b0ef7c3779dab312dd5ae" translate="yes" xml:space="preserve">
          <source>A repeated field which contains a pathspec used to match against a submodule&amp;rsquo;s path to determine if the submodule is of interest to git commands. See &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt; for details.</source>
          <target state="translated">서브 모듈이 git 명령에 관심이 있는지 판별하기 위해 서브 모듈의 경로와 일치시키는 데 사용되는 경로 스펙을 포함하는 반복 필드. 자세한 내용은 &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules [7]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c4f31deb02430ad940d40632dc48c6584b615bca" translate="yes" xml:space="preserve">
          <source>A repository administrator uses the following tools to set up and maintain access to the repository by developers.</source>
          <target state="translated">저장소 관리자는 다음 도구를 사용하여 개발자가 저장소에 대한 액세스를 설정하고 유지 보수합니다.</target>
        </trans-unit>
        <trans-unit id="291ca170f72d7ae46d3d06abf11420385d3bc632" translate="yes" xml:space="preserve">
          <source>A repository browser written in C++ using Qt.</source>
          <target state="translated">Qt를 사용하여 C ++로 작성된 저장소 브라우저.</target>
        </trans-unit>
        <trans-unit id="4f0e13fa1004207d77a93fcbfe7ad39156045662" translate="yes" xml:space="preserve">
          <source>A repository that was cloned independently and later added as a submodule or old setups have the submodules git directory inside the submodule instead of embedded into the superprojects git directory.</source>
          <target state="translated">독립적으로 복제 된 후 나중에 하위 모듈 또는 이전 설정으로 추가 된 저장소에는 하위 프로젝트 git 디렉토리가 수퍼 프로젝트 git 디렉토리에 포함되지 않고 하위 모듈 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2e984261a0bc7837fbb8a0ec46d94f09fd20ad4" translate="yes" xml:space="preserve">
          <source>A repository, however, may be on a filesystem that handles the filemode correctly, and this variable is set to &lt;code&gt;true&lt;/code&gt; when created, but later may be made accessible from another environment that loses the filemode (e.g. exporting ext4 via CIFS mount, visiting a Cygwin created repository with Git for Windows or Eclipse). In such a case it may be necessary to set this variable to &lt;code&gt;false&lt;/code&gt;. See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;.</source>
          <target state="translated">그러나 리포지토리는 파일 모드를 올바르게 처리하는 파일 시스템에있을 수 있으며이 변수는 만들 때 &lt;code&gt;true&lt;/code&gt; 로 설정 되지만 나중에 파일 모드를 잃는 다른 환경에서 액세스 할 수 있습니다 (예 : CIFS 마운트를 통해 ext4 내보내기, Cygwin 방문) Windows 또는 Eclipse 용 Git을 사용하여 리포지토리 생성) 이러한 경우이 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정해야합니다 . &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="78ddd4f9a8a430a958f1b8538f7d6f7067859a81" translate="yes" xml:space="preserve">
          <source>A response cannot have both &quot;ACK&quot; lines as well as a &quot;NAK&quot; line.</source>
          <target state="translated">응답에는 &quot;ACK&quot;라인과 &quot;NAK&quot;라인이 모두 포함될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2e8097366b5d40667e4abf117fd6ca3ad0717782" translate="yes" xml:space="preserve">
          <source>A revision parameter &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; typically, but not necessarily, names a commit object. It uses what is called an &lt;code&gt;extended SHA-1&lt;/code&gt; syntax. Here are various ways to spell object names. The ones listed near the end of this list name trees and blobs contained in a commit.</source>
          <target state="translated">수정 매개 변수 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 는 일반적으로 커밋 개체의 이름을 지정하지만 반드시 그런 것은 아닙니다. 그것은라는 것을 사용하여 &lt;code&gt;extended SHA-1&lt;/code&gt; 구문. 다음은 객체 이름을 철자하는 다양한 방법입니다. 이 목록의 끝 부분 근처에 나열된 항목은 커밋에 포함 된 트리 및 블롭의 이름을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="62c6349b68cd7c10517a568cd609971cc38e5788" translate="yes" xml:space="preserve">
          <source>A sample script called &lt;code&gt;git merge-one-file&lt;/code&gt; is included in the distribution.</source>
          <target state="translated">배포판에는 &lt;code&gt;git merge-one-file&lt;/code&gt; 이라는 샘플 스크립트 가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="120e3b8f4ab8d187e55b285ecbd0489d8d26eb44" translate="yes" xml:space="preserve">
          <source>A separate reflog is kept for the HEAD, so</source>
          <target state="translated">HEAD에 대한 별도의 Reflog가 유지되므로</target>
        </trans-unit>
        <trans-unit id="d91dd506db610265c4f5339a204fd581531aedbc" translate="yes" xml:space="preserve">
          <source>A server which decides to communicate (based on a request from a client) using protocol version 2, notifies the client by sending a version string in its initial response followed by an advertisement of its capabilities. Each capability is a key with an optional value. Clients must ignore all unknown keys. Semantics of unknown values are left to the definition of each key. Some capabilities will describe commands which can be requested to be executed by the client.</source>
          <target state="translated">프로토콜 버전 2를 사용하여 (클라이언트의 요청에 따라) 통신하기로 결정한 서버는 초기 응답에서 버전 문자열을 전송 한 다음 해당 기능을 알리는 방식으로 클라이언트에게 알립니다. 각 기능은 선택적 값이있는 키입니다. 클라이언트는 알 수없는 모든 키를 무시해야합니다. 알 수없는 값의 의미는 각 키의 정의에 남습니다. 일부 기능은 클라이언트가 실행하도록 요청할 수있는 명령을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1df310f47acb8f98df997eb87d57f9f09ca45534" translate="yes" xml:space="preserve">
          <source>A set of objects which have been compressed into one file (to save space or to transmit them efficiently).</source>
          <target state="translated">공간을 절약하거나 효율적으로 전송하기 위해 하나의 파일로 압축 된 개체 집합입니다.</target>
        </trans-unit>
        <trans-unit id="760738014c8d15080dd8ad99ff6f8946e9b78b3f" translate="yes" xml:space="preserve">
          <source>A shallow &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt; has an incomplete history some of whose &lt;a href=&quot;#def_commit&quot;&gt;commits&lt;/a&gt; have &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt; cauterized away (in other words, Git is told to pretend that these commits do not have the parents, even though they are recorded in the &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt;). This is sometimes useful when you are interested only in the recent history of a project even though the real history recorded in the upstream is much larger. A shallow repository is created by giving the &lt;code&gt;--depth&lt;/code&gt; option to &lt;a href=&quot;git-clone&quot;&gt;git-clone[1]&lt;/a&gt;, and its history can be later deepened with &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">얕은의 &lt;a href=&quot;#def_repository&quot;&gt;저장소는&lt;/a&gt; 어떤 누구의 불완전한 역사를 가지고 &lt;a href=&quot;#def_commit&quot;&gt;커밋이&lt;/a&gt; 한 &lt;a href=&quot;#def_parent&quot;&gt;부모&lt;/a&gt; 멀리 소작 (즉이 망할 놈이는 그들은 기록에도 불구하고,이 커밋은 부모가없는 척하라고 &lt;a href=&quot;#def_commit_object&quot;&gt;객체를 커밋&lt;/a&gt; ). 업스트림에 기록 된 실제 기록이 훨씬 더 크더라도 프로젝트의 최근 기록에만 관심이있는 경우에 유용합니다. 얕은 저장소는 &lt;a href=&quot;git-clone&quot;&gt;git-clone [1]에 &lt;/a&gt; &lt;code&gt;--depth&lt;/code&gt; 옵션을 제공하여 만들어지며 나중에 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 으로 히스토리를 깊게 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84d2217cabdf29712dcb12dec7c077c5557961f7" translate="yes" xml:space="preserve">
          <source>A similar notation &lt;code&gt;r1...r2&lt;/code&gt; is called symmetric difference of &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; and is defined as &lt;code&gt;r1 r2 --not $(git merge-base --all r1 r2)&lt;/code&gt;. It is the set of commits that are reachable from either one of &lt;code&gt;r1&lt;/code&gt; (left side) or &lt;code&gt;r2&lt;/code&gt; (right side) but not from both.</source>
          <target state="translated">비슷한 표기법 &lt;code&gt;r1...r2&lt;/code&gt; 를 &lt;code&gt;r1&lt;/code&gt; 과 &lt;code&gt;r2&lt;/code&gt; 의 대칭 차이라고하며 &lt;code&gt;r1 r2 --not $(git merge-base --all r1 r2)&lt;/code&gt; 로 정의 합니다. &lt;code&gt;r1&lt;/code&gt; (왼쪽) 또는 &lt;code&gt;r2&lt;/code&gt; (오른쪽 ) 중 하나에서 도달 할 수 있지만 둘 다에서 도달 할 수없는 커밋 세트입니다 .</target>
        </trans-unit>
        <trans-unit id="03b58226721c4cc7166ad8aeab7f1974a94bf09d" translate="yes" xml:space="preserve">
          <source>A similar situation may exist if you have many refs outside of &lt;code&gt;refs/heads/&lt;/code&gt; and &lt;code&gt;refs/tags/&lt;/code&gt; that point to related objects (e.g., &lt;code&gt;refs/pull&lt;/code&gt; or &lt;code&gt;refs/changes&lt;/code&gt; used by some hosting providers). By default, clients fetch only heads and tags, and deltas against objects found only in those other groups cannot be sent as-is.</source>
          <target state="translated">&lt;code&gt;refs/heads/&lt;/code&gt; 및 &lt;code&gt;refs/tags/&lt;/code&gt; 이외의 관련 오브젝트를 가리키는 참조 가 많은 경우 (예 : 일부 호스팅 제공 업체 &lt;code&gt;refs/changes&lt;/code&gt; 사용하는 &lt;code&gt;refs/pull&lt;/code&gt; 또는 refs / changes) 유사한 상황이 존재할 수 있습니다 . 기본적으로 클라이언트는 헤드와 태그 만 가져 오며 다른 그룹에서만 찾은 객체에 대한 델타는있는 그대로 보낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b8ed03d108643fd395f938fb72a9354bf316277b" translate="yes" xml:space="preserve">
          <source>A simple CGI program to serve the contents of a Git repository to Git clients accessing the repository over http:// and https:// protocols. The program supports clients fetching using both the smart HTTP protocol and the backwards-compatible dumb HTTP protocol, as well as clients pushing using the smart HTTP protocol.</source>
          <target state="translated">http : // 및 https : // 프로토콜을 통해 저장소에 액세스하는 Git 클라이언트에 Git 저장소의 컨텐츠를 제공하는 간단한 CGI 프로그램. 이 프로그램은 스마트 HTTP 프로토콜과 이전 버전과 호환되는 벙어리 HTTP 프로토콜 및 스마트 HTTP 프로토콜을 사용하여 푸시하는 클라이언트를 모두 사용하여 클라이언트 페칭을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b1195c95166bae01312d67abaddce937f83d9362" translate="yes" xml:space="preserve">
          <source>A simple example showing the use of shell eval on the output, demonstrating the use of --shell. List the prefixes of all heads:</source>
          <target state="translated">출력에서 shell eval을 사용하는 간단한 예제로 --shell의 사용을 보여줍니다. 모든 헤드의 접두사를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="c189ba8d16025c20dba9fcda55d122bc7aead222" translate="yes" xml:space="preserve">
          <source>A simple script to set up &lt;code&gt;gitweb&lt;/code&gt; and a web server for browsing the local repository.</source>
          <target state="translated">로컬 저장소를 찾아보기 위해 &lt;code&gt;gitweb&lt;/code&gt; 및 웹 서버 를 설정하는 간단한 스크립트 입니다.</target>
        </trans-unit>
        <trans-unit id="24dbbf1a98e941496d92210bf8c09236d984ac48" translate="yes" xml:space="preserve">
          <source>A single Git repository can maintain multiple branches of development. To create a new branch named &quot;experimental&quot;, use</source>
          <target state="translated">단일 Git 리포지토리는 여러 개발 지점을 유지할 수 있습니다. &quot;experimental&quot;이라는 새 분기를 만들려면</target>
        </trans-unit>
        <trans-unit id="25083b025a2b5a403b052b2229f06625158a6247" translate="yes" xml:space="preserve">
          <source>A single Git repository can track development on multiple branches. It does this by keeping a list of &lt;a href=&quot;#def_head&quot;&gt;heads&lt;/a&gt; which reference the latest commit on each branch; the &lt;a href=&quot;git-branch&quot;&gt;git-branch[1]&lt;/a&gt; command shows you the list of branch heads:</source>
          <target state="translated">단일 Git 리포지토리는 여러 지점의 개발을 추적 할 수 있습니다. 각 분기의 최신 커밋을 참조하는 &lt;a href=&quot;#def_head&quot;&gt;헤드&lt;/a&gt; 목록을 유지하여이를 수행합니다 . &lt;a href=&quot;git-branch&quot;&gt;자식 분기 [1]&lt;/a&gt; 명령을 보여줍니다 당신에게 브랜치 헤드의 목록 :</target>
        </trans-unit>
        <trans-unit id="7288da94d33c9eb52ba6940278539d1555cfdfd9" translate="yes" xml:space="preserve">
          <source>A single character indicating the status of the ref:</source>
          <target state="translated">심판의 상태를 나타내는 단일 문자 :</target>
        </trans-unit>
        <trans-unit id="31c723ae3e05980f7081e5473a8ac04766150ab6" translate="yes" xml:space="preserve">
          <source>A single commit, &amp;lt;since&amp;gt;, specifies that the commits leading to the tip of the current branch that are not in the history that leads to the &amp;lt;since&amp;gt; to be output.</source>
          <target state="translated">단일 커밋 &amp;lt;since&amp;gt;는 &amp;lt;since&amp;gt;가 출력되는 히스토리에없는 현재 분기의 끝으로 이어지는 커밋을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d66b9962c6b8969581e4f00aff7618bfe88dca4e" translate="yes" xml:space="preserve">
          <source>A slash followed by two consecutive asterisks then a slash matches zero or more directories. For example, &quot;&lt;code&gt;a/**/b&lt;/code&gt;&quot; matches &quot;&lt;code&gt;a/b&lt;/code&gt;&quot;, &quot;&lt;code&gt;a/x/b&lt;/code&gt;&quot;, &quot;&lt;code&gt;a/x/y/b&lt;/code&gt;&quot; and so on.</source>
          <target state="translated">슬래시 다음에 두 개의 연속 별표가 오면 슬래시는 0 개 이상의 디렉토리와 일치합니다. 예를 들어 &quot; &lt;code&gt;a/**/b&lt;/code&gt; &quot;는 &quot; &lt;code&gt;a/b&lt;/code&gt; &quot;, &quot; &lt;code&gt;a/x/b&lt;/code&gt; &quot;, &quot; &lt;code&gt;a/x/y/b&lt;/code&gt; &quot;등과 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="4e21b6b860da30d1826bc3bb029200d80cc11cad" translate="yes" xml:space="preserve">
          <source>A slash followed by two consecutive asterisks then a slash matches zero or more directories. For example, &amp;ldquo;a/**/b&amp;rdquo; matches &amp;ldquo;a/b&amp;rdquo;, &amp;ldquo;a/x/b&amp;rdquo;, &amp;ldquo;a/x/y/b&amp;rdquo; and so on.</source>
          <target state="translated">슬래시 다음에 두 개의 연속 별표가 오면 슬래시는 0 개 이상의 디렉토리와 일치합니다. 예를 들어 &quot;a / ** / b&quot;는 &quot;a / b&quot;, &quot;a / x / b&quot;, &quot;a / x / y / b&quot;등과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7c9431663a53487c588fbbedb283ae62fa2894ff" translate="yes" xml:space="preserve">
          <source>A slightly deprecated way to store shorthands to be used to specify a URL to &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git pull&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt;. A file can be stored as &lt;code&gt;branches/&amp;lt;name&amp;gt;&lt;/code&gt; and then &lt;code&gt;name&lt;/code&gt; can be given to these commands in place of &lt;code&gt;repository&lt;/code&gt; argument. See the REMOTES section in &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; for details. This mechanism is legacy and not likely to be found in modern repositories. This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/branches&quot; will be used instead.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; , &lt;code&gt;git pull&lt;/code&gt; 및 &lt;code&gt;git push&lt;/code&gt; 에 URL을 지정하는 데 사용되는 속기를 저장하는 약간 더 이상 사용되지 않는 방법 입니다. 파일은 &lt;code&gt;branches/&amp;lt;name&amp;gt;&lt;/code&gt; 으로 저장 한 다음 &lt;code&gt;repository&lt;/code&gt; 인수 대신이 명령에 &lt;code&gt;name&lt;/code&gt; 지정할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 의 REMOTES 섹션 을 참조하십시오. 이 메커니즘은 레거시이며 현대 리포지토리에서는 찾을 수 없습니다. $ GIT_COMMON_DIR이 설정되고 대신 &quot;$ GIT_COMMON_DIR / branches&quot;가 사용되는 경우이 디렉토리는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="abbe30d91a78c1b581b029eea169d6574e2c5cb4" translate="yes" xml:space="preserve">
          <source>A sorted list of object IDs.</source>
          <target state="translated">정렬 된 객체 ID 목록.</target>
        </trans-unit>
        <trans-unit id="3047be03f0d3ecaf4a4a3e674d103af6ab32bc53" translate="yes" xml:space="preserve">
          <source>A special notation &quot;&lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt;..&lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt;&quot; can be used as a short-hand for &quot;^'&amp;lt;commit1&amp;gt;' &lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt;&quot;. For example, either of the following may be used interchangeably:</source>
          <target state="translated">특수 표기법 &quot; &lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt; .. &lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt; &quot;는 &quot;^ '&amp;lt;commit1&amp;gt;' &lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt; &quot;의 속기 로 사용할 수 있습니다 . 예를 들어, 다음 중 하나를 상호 교환하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f04b75c4a71a67f88cb97a7461a54292078c16c" translate="yes" xml:space="preserve">
          <source>A special notation &quot;&lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt;..&lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt;&quot; can be used as a short-hand for &quot;^&lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt;&quot;. For example, either of the following may be used interchangeably:</source>
          <target state="translated">특수 표기법 &quot; &lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt; .. &lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt; &quot;를 &quot;^ &lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt; &quot; 의 약어로 사용할 수 있습니다 . 예를 들어, 다음 중 하나를 서로 바꿔서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a3908ea4f3253577085936fe5b76bc16ca04e0c" translate="yes" xml:space="preserve">
          <source>A special work-flow to process regressions can give great results.</source>
          <target state="translated">회귀를 처리하기위한 특별한 워크 플로는 훌륭한 결과를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43ce84536299a4f1684c7f29def2c093aadc39c2" translate="yes" xml:space="preserve">
          <source>A standalone individual developer does not exchange patches with other people, and works alone in a single repository, using the following commands.</source>
          <target state="translated">독립형 개별 개발자는 다른 사용자와 패치를 교환하지 않으며 다음 명령을 사용하여 단일 저장소에서 단독으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6d0b6db37ed70c0023a81918dabe38bb8d99cf58" translate="yes" xml:space="preserve">
          <source>A stash entry is represented as a commit whose tree records the state of the working directory, and its first parent is the commit at &lt;code&gt;HEAD&lt;/code&gt; when the entry was created. The tree of the second parent records the state of the index when the entry is made, and it is made a child of the &lt;code&gt;HEAD&lt;/code&gt; commit. The ancestry graph looks like this:</source>
          <target state="translated">숨김 항목은 트리가 작업 디렉토리의 상태를 기록하는 커밋으로 표시되며 첫 번째 부모는 항목이 작성 될 때 &lt;code&gt;HEAD&lt;/code&gt; 의 커밋 입니다. 두 번째 상위의 트리는 항목이 작성 될 때 색인의 상태를 기록하고 &lt;code&gt;HEAD&lt;/code&gt; 확약 의 하위가 됩니다. 조상 그래프는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="36a517b64103a2430e203bb84a9e73d7f028600f" translate="yes" xml:space="preserve">
          <source>A string that interpolates &lt;code&gt;%(fieldname)&lt;/code&gt; from a branch ref being shown and the object it points at. The format is the same as that of &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;.</source>
          <target state="translated">표시되는 브랜치 참조에서 &lt;code&gt;%(fieldname)&lt;/code&gt; 을 보간하는 문자열 과 그것이 가리키는 객체입니다. 형식은 &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt; 의 형식과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="9edde80e52399b826b491130bef9d05b3925669d" translate="yes" xml:space="preserve">
          <source>A string that interpolates &lt;code&gt;%(fieldname)&lt;/code&gt; from a ref being shown and the object it points at. If &lt;code&gt;fieldname&lt;/code&gt; is prefixed with an asterisk (&lt;code&gt;*&lt;/code&gt;) and the ref points at a tag object, use the value for the field in the object which the tag object refers to (instead of the field in the tag object). When unspecified, &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; defaults to &lt;code&gt;%(objectname) SPC %(objecttype) TAB %(refname)&lt;/code&gt;. It also interpolates &lt;code&gt;%%&lt;/code&gt; to &lt;code&gt;%&lt;/code&gt;, and &lt;code&gt;%xx&lt;/code&gt; where &lt;code&gt;xx&lt;/code&gt; are hex digits interpolates to character with hex code &lt;code&gt;xx&lt;/code&gt;; for example &lt;code&gt;%00&lt;/code&gt; interpolates to &lt;code&gt;\0&lt;/code&gt; (NUL), &lt;code&gt;%09&lt;/code&gt; to &lt;code&gt;\t&lt;/code&gt; (TAB) and &lt;code&gt;%0a&lt;/code&gt; to &lt;code&gt;\n&lt;/code&gt; (LF).</source>
          <target state="translated">표시되는 참조와 그것이 가리키는 오브젝트에서 &lt;code&gt;%(fieldname)&lt;/code&gt; 을 보간하는 문자열입니다 . 경우에 &lt;code&gt;fieldname&lt;/code&gt; 별표 (접두어 &lt;code&gt;*&lt;/code&gt; 태그 객체 AT) 및 REF 포인트 태그 객체 (태그 대신 객체의 필드)을 참조하는 오브젝트의 필드에 대한 값을 사용한다. 지정되지 않은 경우 &lt;code&gt;&amp;lt;format&amp;gt;&lt;/code&gt; 의 기본값은 &lt;code&gt;%(objectname) SPC %(objecttype) TAB %(refname)&lt;/code&gt; 입니다. 또한 &lt;code&gt;%%&lt;/code&gt; 를 &lt;code&gt;%&lt;/code&gt; 로 보간 하고, &lt;code&gt;%xx&lt;/code&gt; 여기서 &lt;code&gt;xx&lt;/code&gt; 는 16 진 숫자이며 16 진 코드 &lt;code&gt;xx&lt;/code&gt; 로 문자를 보간합니다 . 예를 들어 &lt;code&gt;%00&lt;/code&gt; 은 &lt;code&gt;\0&lt;/code&gt; (NUL)으로 보간됩니다 . &lt;code&gt;%09&lt;/code&gt; ~ &lt;code&gt;\t&lt;/code&gt; (TAB) 및 &lt;code&gt;%0a&lt;/code&gt; ~ &lt;code&gt;\n&lt;/code&gt; (LF).</target>
        </trans-unit>
        <trans-unit id="9cb129a282a3da00e35f465609f9329380941366" translate="yes" xml:space="preserve">
          <source>A string that interpolates &lt;code&gt;%(fieldname)&lt;/code&gt; from a tag ref being shown and the object it points at. The format is the same as that of &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref[1]&lt;/a&gt;. When unspecified, defaults to &lt;code&gt;%(refname:strip=2)&lt;/code&gt;.</source>
          <target state="translated">표시되는 태그 참조 및 그것이 가리키는 객체에서 &lt;code&gt;%(fieldname)&lt;/code&gt; 을 보간하는 문자열입니다 . 형식은 &lt;a href=&quot;git-for-each-ref&quot;&gt;git-for-each-ref [1]&lt;/a&gt; 의 형식과 동일 합니다. 지정되지 않은 경우 기본값은 &lt;code&gt;%(refname:strip=2)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0560022c11ba0c716585e6d8f8913228ee3e6c3e" translate="yes" xml:space="preserve">
          <source>A submodule can be deinitialized by running &lt;code&gt;git submodule deinit&lt;/code&gt;. Besides emptying the working directory, this command only modifies the superproject&amp;rsquo;s &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file, so the superproject&amp;rsquo;s history is not affected. This can be undone using &lt;code&gt;git submodule init&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git submodule deinit&lt;/code&gt; 를 실행하여 서브 모듈을 초기화 해제 할 수 있습니다 . 작업 디렉토리를 비우는 것 외에도이 명령은 수퍼 프로젝트의 &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 만 수정하므로 수퍼 프로젝트 의 기록에는 영향을 미치지 않습니다. &lt;code&gt;git submodule init&lt;/code&gt; 사용하여 취소 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b89540955e10e5feb43789fbebb00e44fcb9843" translate="yes" xml:space="preserve">
          <source>A submodule is a repository embedded inside another repository. The submodule has its own history; the repository it is embedded in is called a superproject.</source>
          <target state="translated">서브 모듈은 다른 저장소에 내장 된 저장소입니다. 서브 모듈에는 자체 히스토리가 있습니다. 포함 된 저장소를 수퍼 프로젝트라고합니다.</target>
        </trans-unit>
        <trans-unit id="e88b5d8fa1cd6a4cae09ba91d60ef7a2df883ac3" translate="yes" xml:space="preserve">
          <source>A submodule is considered active,</source>
          <target state="translated">하위 모듈은 활성화 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a4216bd581f8b9370ea9e414788282e84b57f684" translate="yes" xml:space="preserve">
          <source>A submodule is considered up to date when the HEAD is the same as recorded in the index, no tracked files are modified and no untracked files that aren&amp;rsquo;t ignored are present in the submodules work tree. Ignored files are deemed expendable and won&amp;rsquo;t stop a submodule&amp;rsquo;s work tree from being removed.</source>
          <target state="translated">HEAD가 색인에 기록 된 것과 같을 때 서브 모듈은 최신 상태로 간주되며 추적 된 파일은 수정되지 않으며 무시되지 않은 추적되지 않은 파일은 서브 모듈 작업 트리에 존재하지 않습니다. 무시 된 파일은 소모품으로 간주되며 하위 모듈의 작업 트리가 제거되는 것을 막지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df342118147abc0cd90ff22df7d540bbed94c62e" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;:&lt;/code&gt; followed by a path names the blob or tree at the given path in the tree-ish object named by the part before the colon. A path starting with &lt;code&gt;./&lt;/code&gt; or &lt;code&gt;../&lt;/code&gt; is relative to the current working directory. The given path will be converted to be relative to the working tree&amp;rsquo;s root directory. This is most useful to address a blob or tree from a commit or tree that has the same tree structure as the working tree.</source>
          <target state="translated">접미사 &lt;code&gt;:&lt;/code&gt; 뒤에 오는 경로는 콜론 앞 부분에 의해 명명 된 tree-ish 객체의 지정된 경로에서 blob 또는 트리 이름을 지정합니다. &lt;code&gt;./&lt;/code&gt; 또는 &lt;code&gt;../&lt;/code&gt; 로 시작하는 경로 는 현재 작업 디렉토리를 기준으로합니다. 주어진 경로는 작업 트리의 루트 디렉토리를 기준으로 변환됩니다. 이것은 작업 트리와 동일한 트리 구조를 가진 커밋 또는 트리에서 Blob 또는 트리를 처리하는 데 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7e785e37b028efe6293e2efb14cf20d30e4be808" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; followed by an at sign is the same as listing all parents of &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; (meaning, include anything reachable from its parents, but not the commit itself).</source>
          <target state="translated">접미사 &lt;code&gt;^&lt;/code&gt; 다음에 at 기호는 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 의 모든 부모를 나열하는 것과 같습니다 (즉, 부모가 접근 할 수있는 것은 포함하지만 커밋 자체는 포함하지 않음).</target>
        </trans-unit>
        <trans-unit id="234f424b36b663492de634fe2e068b47127b2353" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; followed by an empty brace pair means the object could be a tag, and dereference the tag recursively until a non-tag object is found.</source>
          <target state="translated">접미사 &lt;code&gt;^&lt;/code&gt; 뒤에 빈 괄호 쌍이 있으면 객체가 태그 일 수 있으며 태그가 아닌 객체가 발견 될 때까지 태그를 재귀 적으로 역 참조합니다.</target>
        </trans-unit>
        <trans-unit id="e176abe5e6fcc215a4e351cefa8ffc3e524bb3aa" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; followed by an exclamation mark is the same as giving commit &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; and then all its parents prefixed with &lt;code&gt;^&lt;/code&gt; to exclude them (and their ancestors).</source>
          <target state="translated">접미사 &lt;code&gt;^&lt;/code&gt; 뒤에 느낌표가 붙는 것은 커밋 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 을 부여한 다음 모든 부모에게 &lt;code&gt;^&lt;/code&gt; 를 접두사로 붙여서 그들 (및 그들의 조상)을 제외시키는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="079cde747b39722224d412153b37c2370e8debbb" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; followed by an object type name enclosed in brace pair means dereference the object at &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; recursively until an object of type &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is found or the object cannot be dereferenced anymore (in which case, barf). For example, if &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; is a commit-ish, &lt;code&gt;&amp;lt;rev&amp;gt;^{commit}&lt;/code&gt; describes the corresponding commit object. Similarly, if &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; is a tree-ish, &lt;code&gt;&amp;lt;rev&amp;gt;^{tree}&lt;/code&gt; describes the corresponding tree object. &lt;code&gt;&amp;lt;rev&amp;gt;^0&lt;/code&gt; is a short-hand for &lt;code&gt;&amp;lt;rev&amp;gt;^{commit}&lt;/code&gt;.</source>
          <target state="translated">접미사 &lt;code&gt;^&lt;/code&gt; 뒤에 중괄호 쌍으로 묶인 객체 유형 이름 은 &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; 유형 의 객체가 발견되거나 객체를 더 이상 역 참조 할 수 없을 때까지 ( &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 경우, barf) 재귀 적으로 &amp;lt;rev&amp;gt; 에서 객체를 역 참조 함을 의미합니다 . 예를 들어 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 가 커밋 인 경우 &lt;code&gt;&amp;lt;rev&amp;gt;^{commit}&lt;/code&gt; 은 해당 커밋 개체를 설명합니다. 마찬가지로 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 가 나무 인 경우 &lt;code&gt;&amp;lt;rev&amp;gt;^{tree}&lt;/code&gt; 는 해당 트리 개체를 설명합니다. &lt;code&gt;&amp;lt;rev&amp;gt;^0&lt;/code&gt; 은 &lt;code&gt;&amp;lt;rev&amp;gt;^{commit}&lt;/code&gt; 의 줄임말 입니다.</target>
        </trans-unit>
        <trans-unit id="fffb9575171f3ccde74304b43fe061daf6edfa9e" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; to a revision parameter means the first parent of that commit object. &lt;code&gt;^&amp;lt;n&amp;gt;&lt;/code&gt; means the &amp;lt;n&amp;gt;th parent (i.e. &lt;code&gt;&amp;lt;rev&amp;gt;^&lt;/code&gt; is equivalent to &lt;code&gt;&amp;lt;rev&amp;gt;^1&lt;/code&gt;). As a special rule, &lt;code&gt;&amp;lt;rev&amp;gt;^0&lt;/code&gt; means the commit itself and is used when &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; is the object name of a tag object that refers to a commit object.</source>
          <target state="translated">수정본 매개 변수 의 접미사 &lt;code&gt;^&lt;/code&gt; 는 해당 커밋 객체의 첫 번째 부모를 의미합니다. &lt;code&gt;^&amp;lt;n&amp;gt;&lt;/code&gt; 은 &amp;lt;n&amp;gt; 부모를 의미합니다 (즉, &lt;code&gt;&amp;lt;rev&amp;gt;^&lt;/code&gt; 는 &lt;code&gt;&amp;lt;rev&amp;gt;^1&lt;/code&gt; ). 특별한 규칙으로, &lt;code&gt;&amp;lt;rev&amp;gt;^0&lt;/code&gt; 은 커밋 자체를 의미하며 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; 가 커밋 객체를 참조하는 태그 객체의 객체 이름 일 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4abb972743010d92ad3a5190f17461682915e18a" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;^&lt;/code&gt; to a revision parameter, followed by a brace pair that contains a text led by a slash, is the same as the &lt;code&gt;:/fix nasty bug&lt;/code&gt; syntax below except that it returns the youngest matching commit which is reachable from the &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; before &lt;code&gt;^&lt;/code&gt;.</source>
          <target state="translated">접미사 &lt;code&gt;^&lt;/code&gt; 슬래시 이끄는 텍스트를 포함하는 괄호 쌍 다음 개정 파라미터로는 상기와 동일하다 &lt;code&gt;:/fix nasty bug&lt;/code&gt; 가 막내 매칭을 리턴하는 것을 제외하고 아래 구문로부터 도달하는 커밋 &lt;code&gt;&amp;lt;rev&amp;gt;&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; 전에 .</target>
        </trans-unit>
        <trans-unit id="9efdcb3b13d0c9c0789d26cd7ee831f4aca0612a" translate="yes" xml:space="preserve">
          <source>A suffix &lt;code&gt;~&lt;/code&gt; to a revision parameter means the first parent of that commit object. A suffix &lt;code&gt;~&amp;lt;n&amp;gt;&lt;/code&gt; to a revision parameter means the commit object that is the &amp;lt;n&amp;gt;th generation ancestor of the named commit object, following only the first parents. I.e. &lt;code&gt;&amp;lt;rev&amp;gt;~3&lt;/code&gt; is equivalent to &lt;code&gt;&amp;lt;rev&amp;gt;^^^&lt;/code&gt; which is equivalent to &lt;code&gt;&amp;lt;rev&amp;gt;^1^1^1&lt;/code&gt;. See below for an illustration of the usage of this form.</source>
          <target state="translated">개정판 매개 변수 의 접미사 &lt;code&gt;~&lt;/code&gt; 는 해당 커밋 객체의 첫 번째 부모를 의미합니다. 개정 매개 변수 의 접미사 &lt;code&gt;~&amp;lt;n&amp;gt;&lt;/code&gt; 은 첫 번째 부모 만 따르는 명명 된 커밋 개체의 &amp;lt;n&amp;gt; 조상 인 커밋 개체를 의미합니다. 즉 &lt;code&gt;&amp;lt;rev&amp;gt;~3&lt;/code&gt; 은 &lt;code&gt;&amp;lt;rev&amp;gt;^1^1^1&lt;/code&gt; 과 동일한 &lt;code&gt;&amp;lt;rev&amp;gt;^^^&lt;/code&gt; 와 같습니다 . 이 양식의 사용법에 대한 그림은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="08cd172649a72cf4ad5161e6315024c0dfabce75" translate="yes" xml:space="preserve">
          <source>A symbolic ref is a regular file that stores a string that begins with &lt;code&gt;ref: refs/&lt;/code&gt;. For example, your &lt;code&gt;.git/HEAD&lt;/code&gt; is a regular file whose contents is &lt;code&gt;ref: refs/heads/master&lt;/code&gt;.</source>
          <target state="translated">기호 참조는 &lt;code&gt;ref: refs/&lt;/code&gt; 시작하는 문자열을 저장하는 일반 파일입니다 . 예를 들어 &lt;code&gt;.git/HEAD&lt;/code&gt; 는 내용이 &lt;code&gt;ref: refs/heads/master&lt;/code&gt; 인 일반 파일입니다 .</target>
        </trans-unit>
        <trans-unit id="2f6a4a117c3c9029c31388fc9b0d710a83f42f4d" translate="yes" xml:space="preserve">
          <source>A symbolic ref name. E.g. &lt;code&gt;master&lt;/code&gt; typically means the commit object referenced by &lt;code&gt;refs/heads/master&lt;/code&gt;. If you happen to have both &lt;code&gt;heads/master&lt;/code&gt; and &lt;code&gt;tags/master&lt;/code&gt;, you can explicitly say &lt;code&gt;heads/master&lt;/code&gt; to tell Git which one you mean. When ambiguous, a &lt;code&gt;&amp;lt;refname&amp;gt;&lt;/code&gt; is disambiguated by taking the first match in the following rules:</source>
          <target state="translated">상징적 참조 이름. 예를 들어 &lt;code&gt;master&lt;/code&gt; 는 일반적으로 &lt;code&gt;refs/heads/master&lt;/code&gt; 가 참조하는 커밋 객체를 의미합니다 . &lt;code&gt;heads/master&lt;/code&gt; 와 &lt;code&gt;tags/master&lt;/code&gt; 가 모두 있다면 , &lt;code&gt;heads/master&lt;/code&gt; 를 명시 적으로 말해서 Git에게 어떤 의미인지 말할 수 있습니다. 모호한 경우 다음 규칙에서 첫 번째 일치 항목을 사용하여 &lt;code&gt;&amp;lt;refname&amp;gt;&lt;/code&gt; 이 명확 해집니다.</target>
        </trans-unit>
        <trans-unit id="2a9339c8e09a3c8f9775daba35ba89a601eb61af" translate="yes" xml:space="preserve">
          <source>A symref (see glossary) to the &lt;code&gt;refs/heads/&lt;/code&gt; namespace describing the currently active branch. It does not mean much if the repository is not associated with any working tree (i.e. a &lt;code&gt;bare&lt;/code&gt; repository), but a valid Git repository &lt;strong&gt;must&lt;/strong&gt; have the HEAD file; some porcelains may use it to guess the designated &quot;default&quot; branch of the repository (usually &lt;code&gt;master&lt;/code&gt;). It is legal if the named branch &lt;code&gt;name&lt;/code&gt; does not (yet) exist. In some legacy setups, it is a symbolic link instead of a symref that points at the current branch.</source>
          <target state="translated">현재 활성화 된 분기를 설명하는 &lt;code&gt;refs/heads/&lt;/code&gt; 네임 스페이스에 대한 symref (용어집 참조) 리포지토리가 작업 트리 (예 : &lt;code&gt;bare&lt;/code&gt; 리포지토리) 와 연결되어 있지 않은 경우에는 그다지 의미가 없지만 유효한 Git 리포지토리 에는 HEAD 파일이 &lt;strong&gt;있어야&lt;/strong&gt; 합니다. 일부 도자기는이를 사용하여 저장소의 지정된 &quot;기본&quot;분기 (보통 &lt;code&gt;master&lt;/code&gt; ) 를 추측 할 수 있습니다 . 명명 된 지점 &lt;code&gt;name&lt;/code&gt; 이 존재하지 않으면 합법적 입니다. 일부 레거시 설정에서는 현재 분기를 가리키는 심볼 대신 심볼릭 링크입니다.</target>
        </trans-unit>
        <trans-unit id="29c5b752bfbf12baa27c0d09bf45852511199efe" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;#def_head&quot;&gt;head&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_head&quot;&gt;머리와&lt;/a&gt; 동의어 .</target>
        </trans-unit>
        <trans-unit id="6a76d6428fd9851f11221d0de44fe9ce84899c23" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;code&gt;--right-only --cherry-mark --no-merges&lt;/code&gt;; useful to limit the output to the commits on our side and mark those that have been applied to the other side of a forked history with &lt;code&gt;git log --cherry upstream...mybranch&lt;/code&gt;, similar to &lt;code&gt;git cherry upstream mybranch&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--right-only --cherry-mark --no-merges&lt;/code&gt; 와 동의어 ; 출력을 우리 쪽의 커밋으로 제한하고 &lt;code&gt;git log --cherry upstream...mybranch&lt;/code&gt; 로 &lt;code&gt;git cherry upstream mybranch&lt;/code&gt; 와 비슷한 분기 기록의 다른쪽에 적용된 것을 표시하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="868704b8b35cf6bb729f23c31a6430d7399400cb" translate="yes" xml:space="preserve">
          <source>A table of 4-byte CRC32 values of the packed object data. This is new in v2 so compressed data can be copied directly from pack to pack during repacking without undetected data corruption.</source>
          <target state="translated">묶음 객체 데이터의 4 바이트 CRC32 값 테이블. 이것은 v2의 새로운 기능이므로 압축되지 않은 데이터 손상없이 다시 압축하는 동안 압축 된 데이터를 팩에서 팩으로 직접 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9c572354f0344d27ffddcbe955d1d768c1138c7" translate="yes" xml:space="preserve">
          <source>A table of 4-byte offset values (in network byte order). These are usually 31-bit pack file offsets, but large offsets are encoded as an index into the next table with the msbit set.</source>
          <target state="translated">4 바이트 오프셋 값의 테이블 (네트워크 바이트 순서). 이들은 일반적으로 31 비트 팩 파일 오프셋이지만 큰 오프셋은 msbit가 설정된 다음 테이블에 대한 인덱스로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="115de84d2ad1c82aefd29447ce36382b5a4e7147" translate="yes" xml:space="preserve">
          <source>A table of 8-byte offset entries (empty for pack files less than 2 GiB). Pack files are organized with heavily used objects toward the front, so most object references should not need to refer to this table.</source>
          <target state="translated">8 바이트 오프셋 항목 테이블 (2GiB 미만의 팩 파일의 경우 비어 있음) 팩 파일은 많이 사용되는 객체를 앞쪽으로 구성하므로 대부분의 객체 참조는이 표를 참조하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="9b489f426a28ee960ee163d6ec7cd47d15e9a4e2" translate="yes" xml:space="preserve">
          <source>A table of sorted 20-byte SHA-1 object names. These are packed together without offset values to reduce the cache footprint of the binary search for a specific object name.</source>
          <target state="translated">정렬 된 20 바이트 SHA-1 오브젝트 이름의 테이블. 이들은 특정 객체 이름에 대한 이진 검색의 캐시 공간을 줄이기 위해 오프셋 값없이 함께 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="edf2ea82a914be349ea057cd8f9ba4108e7b2f82" translate="yes" xml:space="preserve">
          <source>A table of sorted object names. These are packed together without offset values to reduce the cache footprint of the binary search for a specific object name.</source>
          <target state="translated">정렬 된 개체 이름 테이블입니다. 특정 개체 이름에 대한 이진 검색의 캐시 풋 프린트를 줄이기 위해 오프셋 값없이 함께 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="04b73c881d8049c32b44bc4f672cd5152d4e0c48" translate="yes" xml:space="preserve">
          <source>A tag is created with &lt;a href=&quot;git-mktag&quot;&gt;git-mktag[1]&lt;/a&gt;, and the signature can be verified by &lt;a href=&quot;git-verify-tag&quot;&gt;git-verify-tag[1]&lt;/a&gt;, though it is normally simpler to use &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; for both.</source>
          <target state="translated">태그는 &lt;a href=&quot;git-mktag&quot;&gt;git-mktag [1]으로&lt;/a&gt; 생성되며 서명은 &lt;a href=&quot;git-verify-tag&quot;&gt;git-verify-tag [1]로 확인할 수&lt;/a&gt; 있지만 일반적으로 둘 다에 &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt; 을 사용하는 것이 더 간단 합니다.</target>
        </trans-unit>
        <trans-unit id="27736fe1ba37175d3cc5e2ce129ab17b8daa1329" translate="yes" xml:space="preserve">
          <source>A tag object contains an object, object type, tag name, the name of the person (&quot;tagger&quot;) who created the tag, and a message, which may contain a signature, as can be seen using &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file[1]&lt;/a&gt;:</source>
          <target state="translated">태그 객체는 객체, 객체 유형, 태그 이름, 태그를 생성 한 사람의 이름 ( &quot;tagger&quot;) 및 &lt;a href=&quot;git-cat-file&quot;&gt;git-cat-file을&lt;/a&gt; 사용하여 볼 수있는 서명을 포함 할 수있는 메시지를 포함 합니다 [1 ] :</target>
        </trans-unit>
        <trans-unit id="460cd2951f141993dd60da4f89bc9632bc5240a6" translate="yes" xml:space="preserve">
          <source>A tag signature file, to be fed to this command&amp;rsquo;s standard input, has a very simple fixed format: four lines of</source>
          <target state="translated">이 명령의 표준 입력에 제공되는 태그 서명 파일은 매우 간단한 고정 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c9577e2a94118633866403eba48d1b01fa7f34b6" translate="yes" xml:space="preserve">
          <source>A text file containing the absolute path back to the .git file that points to here. This is used to check if the linked repository has been manually removed and there is no need to keep this directory any more. The mtime of this file should be updated every time the linked repository is accessed.</source>
          <target state="translated">여기를 가리키는 .git 파일로의 절대 경로를 포함하는 텍스트 파일. 링크 된 저장소가 수동으로 제거되었으며이 디렉토리를 더 이상 유지할 필요가 없는지 확인하는 데 사용됩니다. 이 파일의 mtime은 링크 된 저장소에 액세스 할 때마다 업데이트되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e6620ed6a8dd7fc370324b4a637371aff9ccd2b8" translate="yes" xml:space="preserve">
          <source>A textconv, by comparison, is much more limiting. You provide a transformation of the data into a line-oriented text format, and Git uses its regular diff tools to generate the output. There are several advantages to choosing this method:</source>
          <target state="translated">이에 비해 텍스트 변환은 훨씬 제한적입니다. 데이터를 라인 지향 텍스트 형식으로 변환하고 Git은 일반 diff 도구를 사용하여 출력을 생성합니다. 이 방법을 선택하면 몇 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="20ee50ebcc035e786bc0063549e7c3be96310965" translate="yes" xml:space="preserve">
          <source>A tilde &lt;code&gt;~&lt;/code&gt; and caret &lt;code&gt;^&lt;/code&gt; are used to introduce the postfix &lt;code&gt;nth parent&lt;/code&gt; and &lt;code&gt;peel onion&lt;/code&gt; operation.</source>
          <target state="translated">물결표 &lt;code&gt;~&lt;/code&gt; 와 캐럿 &lt;code&gt;^&lt;/code&gt; 는 후위 &lt;code&gt;nth parent&lt;/code&gt; 및 &lt;code&gt;peel onion&lt;/code&gt; 작업 을 소개하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b05115bcd451b82846a70dc0f8122c29671169c" translate="yes" xml:space="preserve">
          <source>A trailing &quot;&lt;code&gt;/**&lt;/code&gt;&quot; matches everything inside. For example, &quot;&lt;code&gt;abc/**&lt;/code&gt;&quot; matches all files inside directory &quot;&lt;code&gt;abc&lt;/code&gt;&quot;, relative to the location of the &lt;code&gt;.gitignore&lt;/code&gt; file, with infinite depth.</source>
          <target state="translated">후행 &quot; &lt;code&gt;/**&lt;/code&gt; &quot;는 내부의 모든 항목과 일치합니다. 예를 들어, &quot; &lt;code&gt;abc/**&lt;/code&gt; &quot;는 깊이 가 &lt;code&gt;.gitignore&lt;/code&gt; 파일 의 위치와 관련하여 &quot; &lt;code&gt;abc&lt;/code&gt; &quot; 디렉토리 내의 모든 파일과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="c57747a45d9976be1263b4b7a69a5ab667656384" translate="yes" xml:space="preserve">
          <source>A trailing &quot;&lt;code&gt;/**&lt;/code&gt;&quot; matches everything inside. For example, &quot;&lt;code&gt;abc/**&lt;/code&gt;&quot; matches all files inside directory &quot;abc&quot;, relative to the location of the &lt;code&gt;.gitignore&lt;/code&gt; file, with infinite depth.</source>
          <target state="translated">후행 &quot; &lt;code&gt;/**&lt;/code&gt; &quot;는 내부의 모든 항목과 일치합니다. 예를 들어, &quot; &lt;code&gt;abc/**&lt;/code&gt; &quot;는 깊이 가 &lt;code&gt;.gitignore&lt;/code&gt; 파일 의 위치와 관련하여 &quot;abc&quot;디렉토리 내의 모든 파일과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="ed5db9c2038caa3b11960feb667ae09ddbf5220c" translate="yes" xml:space="preserve">
          <source>A trailing &amp;ldquo;/&lt;strong&gt;&amp;rdquo; matches everything inside. For example, &amp;ldquo;abc/&lt;/strong&gt;&amp;rdquo; matches all files inside directory &quot;abc&quot;, relative to the location of the &lt;code&gt;.gitignore&lt;/code&gt; file, with infinite depth.</source>
          <target state="translated">후행 &quot;/ &lt;strong&gt;&quot;는 내부의 모든 항목과 일치합니다. 예를 들어, &quot;abc /&lt;/strong&gt; &quot;는 &lt;code&gt;.gitignore&lt;/code&gt; 파일 의 위치를 ​​기준으로 &quot;abc&quot;디렉토리 내의 모든 파일 을 무한 깊이로 일치시킵니다 .</target>
        </trans-unit>
        <trans-unit id="1ffbc3235b6f3805e76da872c4d7da43eac01de9" translate="yes" xml:space="preserve">
          <source>A tree can be created with &lt;a href=&quot;git-write-tree&quot;&gt;git-write-tree[1]&lt;/a&gt; and its data can be accessed by &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt;. Two trees can be compared with &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;git-write-tree&quot;&gt;git-write-tree [1]로 트리를&lt;/a&gt; 생성 할 수 있으며 &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]로&lt;/a&gt; 데이터에 액세스 할 수 있습니다 . 두 개의 트리를 &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree [1]&lt;/a&gt; 과 비교할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="71ac2a6922ce84e247da3afac7c8eab10ddc8e0d" translate="yes" xml:space="preserve">
          <source>A tree can refer to one or more &quot;blob&quot; objects, each corresponding to a file. In addition, a tree can also refer to other tree objects, thus creating a directory hierarchy. You can examine the contents of any tree using ls-tree (remember that a long enough initial portion of the SHA-1 will also work):</source>
          <target state="translated">트리는 각각 파일에 해당하는 하나 이상의 &quot;blob&quot;객체를 참조 할 수 있습니다. 또한 트리는 다른 트리 객체를 참조하여 디렉토리 계층을 만들 수도 있습니다. ls-tree를 사용하여 모든 트리의 내용을 검사 할 수 있습니다 (SHA-1의 충분한 초기 부분도 작동 함을 기억하십시오).</target>
        </trans-unit>
        <trans-unit id="e1209e9c61fb0516db9ff029636bbf64b5f2cc24" translate="yes" xml:space="preserve">
          <source>A tutorial introduction to Git</source>
          <target state="translated">Git에 대한 튜토리얼 소개</target>
        </trans-unit>
        <trans-unit id="d1c7062a7de157bc933159ad8235a59f59c324f8" translate="yes" xml:space="preserve">
          <source>A tutorial introduction to Git: part two</source>
          <target state="translated">Git에 대한 튜토리얼 소개 : 2 부</target>
        </trans-unit>
        <trans-unit id="20d6593ce00c8f4a86630f0208b8c6cb9ed9de85" translate="yes" xml:space="preserve">
          <source>A typical frontend for fast-import tends to weigh in at approximately 200 lines of Perl/Python/Ruby code. Most developers have been able to create working importers in just a couple of hours, even though it is their first exposure to fast-import, and sometimes even to Git. This is an ideal situation, given that most conversion tools are throw-away (use once, and never look back).</source>
          <target state="translated">빠른 가져 오기를위한 일반적인 프론트 엔드는 약 200 줄의 Perl / Python / Ruby 코드에서 무게가 나가는 경향이 있습니다. 대부분의 개발자는 빠른 수입, 때로는 Git에 처음 노출 되더라도 몇 시간 만에 수입 수입업자를 만들 수있었습니다. 대부분의 변환 도구가 버려지는 경우 (한 번만 사용하고 뒤돌아 보지 않는) 이상적인 상황입니다.</target>
        </trans-unit>
        <trans-unit id="e8135e3fa6705c7716d147bd5d8e6059fc5669c5" translate="yes" xml:space="preserve">
          <source>A typical integrator&amp;rsquo;s Git day.</source>
          <target state="translated">전형적인 통합 자의 Git 날.</target>
        </trans-unit>
        <trans-unit id="cf9ceecdb03729fb43526343794e6a94c95fe225" translate="yes" xml:space="preserve">
          <source>A typical output of &lt;code&gt;git range-diff&lt;/code&gt; would look like this:</source>
          <target state="translated">&lt;code&gt;git range-diff&lt;/code&gt; 의 일반적인 출력 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e41e892a94b26f51f6da2faaf7e783142c2d2445" translate="yes" xml:space="preserve">
          <source>A typical use of notes is to supplement a commit message without changing the commit itself. Notes can be shown by &lt;code&gt;git log&lt;/code&gt; along with the original commit message. To distinguish these notes from the message stored in the commit object, the notes are indented like the message, after an unindented line saying &quot;Notes (&amp;lt;refname&amp;gt;):&quot; (or &quot;Notes:&quot; for &lt;code&gt;refs/notes/commits&lt;/code&gt;).</source>
          <target state="translated">일반적인 노트 사용은 커밋 자체를 변경하지 않고 커밋 메시지를 보완하는 것입니다. 원래 커밋 메시지와 함께 &lt;code&gt;git log&lt;/code&gt; 로 메모를 표시 할 수 있습니다 . 커밋 객체에 저장된 메시지와 이러한 노트를 구별하기 위해, 노트는 &quot;Notes (&amp;lt;refname&amp;gt;) :&quot;(또는 &lt;code&gt;refs/notes/commits&lt;/code&gt; 의 경우 &quot;Notes :&quot;) 뒤에 들여 쓰기되지 않은 행 뒤에 메시지와 같이 들여 쓰기 됩니다.</target>
        </trans-unit>
        <trans-unit id="eaee94e7a5daaa0b37c741d247267e9c8d3bd828" translate="yes" xml:space="preserve">
          <source>A useful minimum set of commands for Everyday Git</source>
          <target state="translated">Everyday Git을위한 유용한 최소 명령 세트</target>
        </trans-unit>
        <trans-unit id="f6b5db3f89763f637b749fc5b0ec07665392a318" translate="yes" xml:space="preserve">
          <source>A v2 server would reply:</source>
          <target state="translated">v2 서버는 다음과 같이 응답합니다.</target>
        </trans-unit>
        <trans-unit id="814fa5229889141123953471b46691119165aa04" translate="yes" xml:space="preserve">
          <source>A value j referring to the jth packfile.</source>
          <target state="translated">j 번째 팩 파일을 참조하는 값 j</target>
        </trans-unit>
        <trans-unit id="0db561a50c25f0c87e4728686c752358969a2d04" translate="yes" xml:space="preserve">
          <source>A value of 0 will give some reasonable default. If unset, it defaults to 1.</source>
          <target state="translated">값이 0이면 합리적인 기본값이 제공됩니다. 설정하지 않으면 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="aa0ad35cb8bc2af5f4d79278f7255026ebe99d79" translate="yes" xml:space="preserve">
          <source>A variable that takes a pathname value can be given a string that begins with &quot;&lt;code&gt;~/&lt;/code&gt;&quot; or &quot;&lt;code&gt;~user/&lt;/code&gt;&quot;, and the usual tilde expansion happens to such a string: &lt;code&gt;~/&lt;/code&gt; is expanded to the value of &lt;code&gt;$HOME&lt;/code&gt;, and &lt;code&gt;~user/&lt;/code&gt; to the specified user&amp;rsquo;s home directory.</source>
          <target state="translated">경로 이름 값을 갖는 변수에는 &quot; &lt;code&gt;~/&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;~user/&lt;/code&gt; &quot;로 시작하는 문자열이 제공 될 수 있으며 이러한 문자열에 대해 일반적인 물결표 확장이 발생합니다. &lt;code&gt;~/&lt;/code&gt; 는 &lt;code&gt;$HOME&lt;/code&gt; 값으로 확장 되고 &lt;code&gt;~user/&lt;/code&gt; 를 지정된 사용자의 홈 디렉토리에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e794a6fd78ae6c428e6284131fe5a2e63e70771b" translate="yes" xml:space="preserve">
          <source>A warning will be issued for refs that do not exist, but a glob that does not match any refs is silently ignored.</source>
          <target state="translated">존재하지 않는 심판에 대해서는 경고가 표시되지만 어떤 심판과도 일치하지 않는 글롭은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="fd32407bcc9b7692e9e0052b8179af70723a8a0f" translate="yes" xml:space="preserve">
          <source>A whole-repository format version bump should only be part of a change that cannot be independently versioned. For instance, if one were to change the reachability rules for objects, or the rules for locking refs, that would require a bump of the repository format version.</source>
          <target state="translated">전체 리포지토리 형식 버전 충돌은 독립적으로 버전을 지정할 수없는 변경의 일부일뿐입니다. 예를 들어 객체의 접근성 규칙 또는 참조 잠금 규칙을 변경하려는 경우 리포지토리 형식 버전이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5bfda56601f95323dd8aca6fc5f3876aceac9edc" translate="yes" xml:space="preserve">
          <source>A zero exit from the update hook allows the ref to be updated. Exiting with a non-zero status prevents &lt;code&gt;git receive-pack&lt;/code&gt; from updating that ref.</source>
          <target state="translated">업데이트 훅에서 빠져 나가면 심판이 업데이트됩니다. 0이 아닌 상태로 종료하면 &lt;code&gt;git receive-pack&lt;/code&gt; 이 해당 참조를 업데이트 하지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="daa85a6ac2fd33dacf832ee98a538368318a091a" translate="yes" xml:space="preserve">
          <source>A: addition of a file</source>
          <target state="translated">A : 파일 추가</target>
        </trans-unit>
        <trans-unit id="8e39d81ad3ae332d60cc3e83e97303a91d0b4f70" translate="yes" xml:space="preserve">
          <source>ALERT ALERT ALERT! The Git &quot;merge object order&quot; is different from the RCS &lt;code&gt;merge&lt;/code&gt; program merge object order. In the above ordering, the original is first. But the argument order to the 3-way merge program &lt;code&gt;merge&lt;/code&gt; is to have the original in the middle. Don&amp;rsquo;t ask me why.</source>
          <target state="translated">경고 경고 경고! Git &quot;병합 오브젝트 순서&quot;는 RCS &lt;code&gt;merge&lt;/code&gt; 프로그램 병합 오브젝트 순서 와 다릅니다 . 위의 순서에서 원본이 첫 번째입니다. 그러나 3 방향 병합 프로그램 &lt;code&gt;merge&lt;/code&gt; 대한 인수 순서 는 원본을 중간에 배치하는 것입니다. 이유를 묻지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4508200e35a10a4b1f04bf5f137007ce3e238313" translate="yes" xml:space="preserve">
          <source>Abbreviate the object name. When using &lt;code&gt;--hash&lt;/code&gt;, you do not have to say &lt;code&gt;--hash --abbrev&lt;/code&gt;; &lt;code&gt;--hash=n&lt;/code&gt; would do.</source>
          <target state="translated">개체 이름을 줄입니다. &lt;code&gt;--hash&lt;/code&gt; 를 사용할 때 &lt;code&gt;--hash --abbrev&lt;/code&gt; 라고 말하지 않아도됩니다 . &lt;code&gt;--hash=n&lt;/code&gt; 은 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="73bf43580d9c77cf2c146fe7b7b0ac96cfdd25cc" translate="yes" xml:space="preserve">
          <source>Abbreviating long options</source>
          <target state="translated">긴 옵션 약어</target>
        </trans-unit>
        <trans-unit id="df0f0090a24082d1353e139667cbd879cef89ee9" translate="yes" xml:space="preserve">
          <source>Abort the current conflict resolution process, and try to reconstruct the pre-merge state.</source>
          <target state="translated">현재 충돌 해결 프로세스를 중단하고 병합 전 상태를 재구성하십시오.</target>
        </trans-unit>
        <trans-unit id="2c9bdb3481f87d016776b3e9fe055e0e08b17764" translate="yes" xml:space="preserve">
          <source>Abort the current conflict resolution process, and try to reconstruct the pre-merge state. If an autostash entry is present, apply it to the worktree.</source>
          <target state="translated">현재 충돌 해결 프로세스를 중단하고 병합 전 상태를 재구성 해보십시오. 자동 숨김 항목이있는 경우 작업 트리에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="97a8cc5ece3d7d535580e6c4ba9d955b1cbee507" translate="yes" xml:space="preserve">
          <source>Abort the patching operation but keep HEAD and the index untouched.</source>
          <target state="translated">패치 작업을 중단하되 HEAD 및 색인은 그대로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="d8af665ebaab7b8a3f7a19d579a76f94def56137" translate="yes" xml:space="preserve">
          <source>Abort the rebase operation and reset HEAD to the original branch. If &amp;lt;branch&amp;gt; was provided when the rebase operation was started, then HEAD will be reset to &amp;lt;branch&amp;gt;. Otherwise HEAD will be reset to where it was when the rebase operation was started.</source>
          <target state="translated">리베이스 작업을 중단하고 HEAD를 원래 분기로 재설정하십시오. 리베이스 작업이 시작될 때 &amp;lt;branch&amp;gt;가 제공된 경우 HEAD는 &amp;lt;branch&amp;gt;로 재설정됩니다. 그렇지 않으면 HEAD가 리베이스 작업이 시작되었을 때의 위치로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e1a60cae95d240ebe223133619984451eb8da56d" translate="yes" xml:space="preserve">
          <source>Abort the rebase operation but HEAD is not reset back to the original branch. The index and working tree are also left unchanged as a result.</source>
          <target state="translated">리베이스 작업을 중단하지만 HEAD는 원래 분기로 다시 재설정되지 않습니다. 결과적으로 인덱스 및 작업 트리도 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dadb38a3988ca24e3d15cd3fb6752f37603a89f5" translate="yes" xml:space="preserve">
          <source>Abort the rebase operation but HEAD is not reset back to the original branch. The index and working tree are also left unchanged as a result. If a temporary stash entry was created using --autostash, it will be saved to the stash list.</source>
          <target state="translated">rebase 작업을 중단하지만 HEAD는 원래 분기로 다시 재설정되지 않습니다. 결과적으로 인덱스 및 작업 트리도 변경되지 않습니다. --autostash를 사용하여 임시 숨김 항목을 만든 경우 숨김 목록에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="b3d9e340762213f6aa557fb380c457beb7949eda" translate="yes" xml:space="preserve">
          <source>Abort the transaction, releasing all locks if the transaction is in prepared state.</source>
          <target state="translated">트랜잭션을 중단하고 트랜잭션이 준비된 상태이면 모든 잠금을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="348ed40ffd74f6eb0fbdde58a662f091cfe18d08" translate="yes" xml:space="preserve">
          <source>Abort/reset an in-progress &lt;code&gt;git notes merge&lt;/code&gt;, i.e. a notes merge with conflicts. This simply removes all files related to the notes merge.</source>
          <target state="translated">진행중인 &lt;code&gt;git notes merge&lt;/code&gt; 중단 / 리셋- 즉 노트가 충돌과 병합됩니다. 이것은 단순히 메모 병합과 관련된 모든 파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="26d78acc57b2d47f1ebfb75a2f9bb6687faa0fcc" translate="yes" xml:space="preserve">
          <source>About ten years ago did i do my first &lt;code&gt;bisection&lt;/code&gt; of a Linux patch queue. That was prior the Git (and even prior the BitKeeper) days. I literally days spent sorting out patches, creating what in essence were standalone commits that i guessed to be related to that bug.</source>
          <target state="translated">약 10 년 전에 Linux 패치 대기열의 첫 번째 &lt;code&gt;bisection&lt;/code&gt; 을 수행했습니다. 그것은 Git 이전과 심지어 BitKeeper 이전이었습니다. 말 그대로 패치를 정렬하는 데 보냈으며 본질적으로 그 버그와 관련이 있다고 생각되는 독립 실행 형 커밋을 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="7a17b1a2762f733cbf8fe0ce3ae058c1fb64af21" translate="yes" xml:space="preserve">
          <source>Absolute filesystem path which will be prepended to project path; the path to repository is &lt;code&gt;$projectroot/$project&lt;/code&gt;. Set to &lt;code&gt;$GITWEB_PROJECTROOT&lt;/code&gt; during installation. This variable has to be set correctly for gitweb to find repositories.</source>
          <target state="translated">프로젝트 경로 앞에 추가되는 절대 파일 시스템 경로. 저장소 경로는 &lt;code&gt;$projectroot/$project&lt;/code&gt; 입니다. 설치 중에 &lt;code&gt;$GITWEB_PROJECTROOT&lt;/code&gt; 설정하십시오 . gitweb이 저장소를 찾으려면이 변수를 올바르게 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d79da395b5d7a09c6439a5f2660d8c568186ab7e" translate="yes" xml:space="preserve">
          <source>Abstract</source>
          <target state="translated">Abstract</target>
        </trans-unit>
        <trans-unit id="17286b3ab79f469f1686313022a96ba044391703" translate="yes" xml:space="preserve">
          <source>Accelerated static Apache 2.x</source>
          <target state="translated">정적 정적 Apache 2.x 가속화</target>
        </trans-unit>
        <trans-unit id="52790b3bcb573f6e8573cdbe7b68a8e690d099eb" translate="yes" xml:space="preserve">
          <source>Access control: By restricting user access to submodules, this can be used to implement read/write policies for different users.</source>
          <target state="translated">액세스 제어 : 하위 모듈에 대한 사용자 액세스를 제한함으로써 다른 사용자에 대한 읽기 / 쓰기 정책을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d9540ff93a75d47409d6a0aa37491da117ecdf8" translate="yes" xml:space="preserve">
          <source>Acknowledgments</source>
          <target state="translated">Acknowledgments</target>
        </trans-unit>
        <trans-unit id="478ae85b8fa23d44da84a56a398158571f09f29c" translate="yes" xml:space="preserve">
          <source>Act as though the corresponding command-line option with a leading &lt;code&gt;--&lt;/code&gt; was passed on the command line (see OPTIONS, above).</source>
          <target state="translated">앞의 &lt;code&gt;--&lt;/code&gt; 와 해당하는 명령 행 옵션 이 명령 행에 전달 된 것처럼 작동합니다 (위의 옵션 참조).</target>
        </trans-unit>
        <trans-unit id="6478562162279a99d43ca11e0923b34140a68ad3" translate="yes" xml:space="preserve">
          <source>Actions, and urls</source>
          <target state="translated">액션 및 URL</target>
        </trans-unit>
        <trans-unit id="3894e58bd38733ccd4747f0674e47d077bbb6100" translate="yes" xml:space="preserve">
          <source>Actions:</source>
          <target state="translated">Actions:</target>
        </trans-unit>
        <trans-unit id="8c5178bf114268e42ef635c5fbc78f8654415410" translate="yes" xml:space="preserve">
          <source>Activate recording of resolved conflicts, so that identical conflict hunks can be resolved automatically, should they be encountered again. By default, &lt;a href=&quot;git-rerere&quot;&gt;git-rerere[1]&lt;/a&gt; is enabled if there is an &lt;code&gt;rr-cache&lt;/code&gt; directory under the &lt;code&gt;$GIT_DIR&lt;/code&gt;, e.g. if &quot;rerere&quot; was previously used in the repository.</source>
          <target state="translated">동일한 충돌 덩어리가 다시 발생할 경우 동일한 충돌 덩어리를 자동으로 해결할 수 있도록 해결 된 충돌 기록을 활성화합니다. &lt;code&gt;$GIT_DIR&lt;/code&gt; GIT_DIR 아래에 &lt;code&gt;rr-cache&lt;/code&gt; 디렉토리가있는 경우 (예 : 저장소에 &quot;rerere&quot;가 이미 사용 된 경우) 기본적으로 &lt;a href=&quot;git-rerere&quot;&gt;git-rerere [1]&lt;/a&gt; 이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f02f312753d69f3d534d52a8b88d589eac9ef0bb" translate="yes" xml:space="preserve">
          <source>Active branches have the same overhead as inactive branches, but also contain copies of every tree that has been recently modified on that branch. If subtree &lt;code&gt;include&lt;/code&gt; has not been modified since the branch became active, its contents will not be loaded into memory, but if subtree &lt;code&gt;src&lt;/code&gt; has been modified by a commit since the branch became active, then its contents will be loaded in memory.</source>
          <target state="translated">활성 분기는 비활성 분기와 동일한 오버 헤드를 갖지만 해당 분기에서 최근 수정 된 모든 트리의 사본도 포함합니다. 분기가 활성화 된 후 하위 트리 &lt;code&gt;include&lt;/code&gt; 이 수정되지 않은 경우 해당 내용이 메모리에로드되지 않지만 분기가 활성화 된 후 커밋에 의해 하위 트리 &lt;code&gt;src&lt;/code&gt; 가 수정 된 경우 해당 내용이 메모리에로드됩니다.</target>
        </trans-unit>
        <trans-unit id="19a0105409fd4103b8842eb13af0140d95a67fb2" translate="yes" xml:space="preserve">
          <source>Active submodules</source>
          <target state="translated">활성 서브 모듈</target>
        </trans-unit>
        <trans-unit id="8a0a4ffd02b3e3415f28bfa49ecef06eac3d36bf" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt;, but is used by &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt; instead of &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;. See the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; documentation for details.</source>
          <target state="translated">같은 역할 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 하지만 의해 사용되는 &lt;a href=&quot;git-fetch-pack&quot;&gt;자식 페치 팩 [1]&lt;/a&gt; 대신 &lt;a href=&quot;git-fsck&quot;&gt;자식-fsck가 [1]&lt;/a&gt; . 자세한 내용은 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8a2b29e689f134a6c33caf76c2612bd809b36f86" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt;, but is used by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; instead of &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;. See the &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; documentation for details.</source>
          <target state="translated">같은 역할 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 하지만 의해 사용되는 &lt;a href=&quot;git-receive-pack&quot;&gt;자식 - 수신 팩 [1]&lt;/a&gt; 대신 &lt;a href=&quot;git-fsck&quot;&gt;자식-fsck가 [1]&lt;/a&gt; . 자세한 내용은 &lt;code&gt;fsck.&amp;lt;msg-id&amp;gt;&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="53c1b47e4f88ea8cc86f31135daa96f65e495e4d" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;fsck.skipList&lt;/code&gt;, but is used by &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack[1]&lt;/a&gt; instead of &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;. See the &lt;code&gt;fsck.skipList&lt;/code&gt; documentation for details.</source>
          <target state="translated">&lt;code&gt;fsck.skipList&lt;/code&gt; 와 유사 하지만 &lt;a href=&quot;git-fsck&quot;&gt;git-fsck [1]&lt;/a&gt; 대신 &lt;a href=&quot;git-fetch-pack&quot;&gt;git-fetch-pack [1]에서&lt;/a&gt; 사용됩니다 . 자세한 내용은 &lt;code&gt;fsck.skipList&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="31c02a316f685de03eb757b49fbbce21e75b00c4" translate="yes" xml:space="preserve">
          <source>Acts like &lt;code&gt;fsck.skipList&lt;/code&gt;, but is used by &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; instead of &lt;a href=&quot;git-fsck&quot;&gt;git-fsck[1]&lt;/a&gt;. See the &lt;code&gt;fsck.skipList&lt;/code&gt; documentation for details.</source>
          <target state="translated">&lt;code&gt;fsck.skipList&lt;/code&gt; 와 유사 하지만 &lt;a href=&quot;git-fsck&quot;&gt;git-fsck [1]&lt;/a&gt; 대신 &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]에서&lt;/a&gt; 사용됩니다 . 자세한 내용은 &lt;code&gt;fsck.skipList&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bb483d422626db8f460b089acb2b2a17f42ef653" translate="yes" xml:space="preserve">
          <source>Actually write the object into the object database.</source>
          <target state="translated">실제로 객체를 객체 데이터베이스에 씁니다.</target>
        </trans-unit>
        <trans-unit id="9ae5ee2ecd5525bbb102db4f0d78bb539c98b2b0" translate="yes" xml:space="preserve">
          <source>Adapting your work-flow</source>
          <target state="translated">워크 플로우 적응</target>
        </trans-unit>
        <trans-unit id="febbcaaccd6732ef0fbf603adeb6e4b1534f2caf" translate="yes" xml:space="preserve">
          <source>Add &quot;glob&quot; magic to all pathspec. This is equivalent to setting the &lt;code&gt;GIT_GLOB_PATHSPECS&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;. Disabling globbing on individual pathspecs can be done using pathspec magic &quot;:(literal)&quot;</source>
          <target state="translated">모든 경로 스펙에 &quot;글로브&quot;마법을 추가하십시오. 이것은 &lt;code&gt;GIT_GLOB_PATHSPECS&lt;/code&gt; 환경 변수를 &lt;code&gt;1&lt;/code&gt; 로 설정하는 것과 같습니다 . 개별 경로 스펙에 대한 글 로빙 비활성화는 pathspec magic &quot;: (literal)&quot;을 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a1c5ad83cb656e31e0abe5871946adce7f2dbed" translate="yes" xml:space="preserve">
          <source>Add &quot;icase&quot; magic to all pathspec. This is equivalent to setting the &lt;code&gt;GIT_ICASE_PATHSPECS&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">모든 경로 스펙에 &quot;icase&quot;매직을 추가하십시오. 이것은 &lt;code&gt;GIT_ICASE_PATHSPECS&lt;/code&gt; 환경 변수를 &lt;code&gt;1&lt;/code&gt; 로 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="38d537b0a7b0bc1a6255114f214ad3b7382addc5" translate="yes" xml:space="preserve">
          <source>Add &quot;literal&quot; magic to all pathspec. This is equivalent to setting the &lt;code&gt;GIT_NOGLOB_PATHSPECS&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;. Enabling globbing on individual pathspecs can be done using pathspec magic &quot;:(glob)&quot;</source>
          <target state="translated">모든 경로 스펙에 &quot;리터럴&quot;마법을 추가하십시오. 이것은 &lt;code&gt;GIT_NOGLOB_PATHSPECS&lt;/code&gt; 환경 변수를 &lt;code&gt;1&lt;/code&gt; 로 설정하는 것과 같습니다 . pathspec magic &quot;: (glob)&quot;를 사용하여 개별 pathspec에서 globbing을 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a692c67e8b6f449d83f8b5219858b8b4cd34c65" translate="yes" xml:space="preserve">
          <source>Add (or prevent adding) the &quot;X-Mailer:&quot; header. By default, the header is added, but it can be turned off by setting the &lt;code&gt;sendemail.xmailer&lt;/code&gt; configuration variable to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&quot;X-Mailer :&quot;헤더를 추가하거나 추가하지 마십시오. 기본적으로 헤더가 추가되지만 &lt;code&gt;sendemail.xmailer&lt;/code&gt; 구성 변수를 &lt;code&gt;false&lt;/code&gt; 로 설정하여 헤더를 끌 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="875e6f546a41d1d0704772304d2d43d72adc62d9" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;Signed-off-by:&lt;/code&gt; line to the commit message, using the committer identity of yourself. See the signoff option in &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more information.</source>
          <target state="translated">자신의 커미터 ID를 사용하여 커밋 메시지에 &lt;code&gt;Signed-off-by:&lt;/code&gt; 라인을 추가 하십시오. 자세한 내용은 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 의 사인 오프 옵션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ed47084b5999b126507c3c0b45a1bb8e478c76b6" translate="yes" xml:space="preserve">
          <source>Add Signed-off-by line at the end of the commit message. See the signoff option in &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more information.</source>
          <target state="translated">커밋 메시지의 끝에 Sign-off-by 행을 추가하십시오. 자세한 내용은 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 의 사인 오프 옵션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="290e4752e9d079cc99d7e2f47d052706296ff714" translate="yes" xml:space="preserve">
          <source>Add Signed-off-by line by the committer at the end of the commit log message. The meaning of a signoff depends on the project, but it typically certifies that committer has the rights to submit this work under the same license and agrees to a Developer Certificate of Origin (see &lt;a href=&quot;http://developercertificate.org/&quot;&gt;http://developercertificate.org/&lt;/a&gt; for more information).</source>
          <target state="translated">커밋 로그 메시지 끝에 커미터가 서명 한 행을 추가합니다. 사인 오프의 의미는 프로젝트에 따라 다르지만 일반적으로 커미터가 동일한 라이센스로이 작업을 제출할 권한이 있으며 개발자 원산지 증명서에 동의 함을 보증합니다 ( 자세한 내용 은 &lt;a href=&quot;http://developercertificate.org/&quot;&gt;http://developercertificate.org/&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="780762089271321ecfe958d672a214a85e1519d6" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;Cc:&lt;/code&gt; header to the email headers. This is in addition to any configured headers, and may be used multiple times. The negated form &lt;code&gt;--no-cc&lt;/code&gt; discards all &lt;code&gt;Cc:&lt;/code&gt; headers added so far (from config or command line).</source>
          <target state="translated">이메일 헤더에 &lt;code&gt;Cc:&lt;/code&gt; 헤더를 추가하십시오 . 이것은 구성된 헤더에 추가되며 여러 번 사용될 수 있습니다. 부정 형식 인 &lt;code&gt;--no-cc&lt;/code&gt; 는 지금까지 추가 된 모든 &lt;code&gt;Cc:&lt;/code&gt; 헤더를 (구성 또는 명령 줄에서) 버립니다 .</target>
        </trans-unit>
        <trans-unit id="ee7701fb474747c5b74516af829e74a1b309150b" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;Signed-off-by:&lt;/code&gt; line to the commit message, using the committer identity of yourself. See the signoff option in &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; for more information.</source>
          <target state="translated">자신의 커미터 ID를 사용하여 커밋 메시지에 &lt;code&gt;Signed-off-by:&lt;/code&gt; 라인을 추가 하십시오. 자세한 내용은 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 의 사인 오프 옵션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1d5ee25b8be312a8351ef48a09ee57bfe0ac5407" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;To:&lt;/code&gt; header to the email headers. This is in addition to any configured headers, and may be used multiple times. The negated form &lt;code&gt;--no-to&lt;/code&gt; discards all &lt;code&gt;To:&lt;/code&gt; headers added so far (from config or command line).</source>
          <target state="translated">이메일 헤더에 &lt;code&gt;To:&lt;/code&gt; 헤더를 추가하십시오 . 이것은 구성된 헤더에 추가되며 여러 번 사용될 수 있습니다. 부정 형식 인 &lt;code&gt;--no-to&lt;/code&gt; 는 지금까지 추가 한 모든 &lt;code&gt;To:&lt;/code&gt; 헤더를 구성 또는 명령 줄에서 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="1d75fe65b404604e5ef539902b9de029d2905810" translate="yes" xml:space="preserve">
          <source>Add a &lt;code&gt;verify&lt;/code&gt; subcommand to the &lt;code&gt;git midx&lt;/code&gt; builtin to verify the contents of the multi-pack-index file match the offsets listed in the corresponding pack-indexes.</source>
          <target state="translated">멀티 팩 인덱스 파일의 내용이 해당 팩 인덱스에 나열된 오프셋과 일치하는지 확인 하려면 &lt;code&gt;git midx&lt;/code&gt; 내장에 &lt;code&gt;verify&lt;/code&gt; 부속 명령을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="f049bd4f468982bc6e0cdfee8fd216a0b6cab6f3" translate="yes" xml:space="preserve">
          <source>Add a Signed-off-by: trailer to all the rebased commits. Note that if &lt;code&gt;--interactive&lt;/code&gt; is given then only commits marked to be picked, edited or reworded will have the trailer added.</source>
          <target state="translated">모든 재 기반 커밋에 Sign-off-by :: 트레일러를 추가하십시오. 경우주의 &lt;code&gt;--interactive&lt;/code&gt; 는 다음 주어진다 만 집어 편집하거나 재 진술로 표시 한 커밋은 트레일러가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ced7c6e6677217cd2f3e27d5808cd7af3f82dcc9" translate="yes" xml:space="preserve">
          <source>Add a new remote, fetch, and check out a branch from it</source>
          <target state="translated">새 리모컨 추가, 가져 오기 및 분기 확인</target>
        </trans-unit>
        <trans-unit id="67a238044913b3fe4075d66007f3a1c6a266ec59" translate="yes" xml:space="preserve">
          <source>Add a non-tracked file to the archive. Can be repeated to add multiple files. The path of the file in the archive is built by concatenating the value for &lt;code&gt;--prefix&lt;/code&gt; (if any) and the basename of &amp;lt;file&amp;gt;.</source>
          <target state="translated">추적되지 않은 파일을 아카이브에 추가합니다. 여러 파일을 추가하기 위해 반복 할 수 있습니다. 아카이브의 파일 경로는 &lt;code&gt;--prefix&lt;/code&gt; (있는 경우) 의 값 과 &amp;lt;file&amp;gt;의 기본 이름을 연결하여 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="c09eb40cb56d6e15f176719436ccb9ad1d152bed" translate="yes" xml:space="preserve">
          <source>Add a remote named &amp;lt;name&amp;gt; for the repository at &amp;lt;url&amp;gt;. The command &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; can then be used to create and update remote-tracking branches &amp;lt;name&amp;gt;/&amp;lt;branch&amp;gt;.</source>
          <target state="translated">&amp;lt;url&amp;gt;의 저장소에 대해 &amp;lt;name&amp;gt;이라는 원격 이름을 추가하십시오. 그런 다음 &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; 명령을 사용하여 원격 추적 분기 &amp;lt;name&amp;gt; / &amp;lt;branch&amp;gt;를 만들고 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7b8618aa62adcdff8f32f43f7ea6da4fbbc410b" translate="yes" xml:space="preserve">
          <source>Add a section on working with other version control systems, including CVS, Subversion, and just imports of series of release tarballs.</source>
          <target state="translated">CVS, Subversion 및 일련의 릴리스 타르볼 가져 오기를 포함한 다른 버전 제어 시스템 작업에 대한 섹션을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a6c8ce810b46aeac59b7c7fbb4f0eb1c414e0fbc" translate="yes" xml:space="preserve">
          <source>Add a signature to each message produced. Per RFC 3676 the signature is separated from the body by a line with '-- ' on it. If the signature option is omitted the signature defaults to the Git version number.</source>
          <target state="translated">생성 된 각 메시지에 서명을 추가하십시오. RFC 3676에 따라 서명은 본문에 '-'가있는 줄로 구분됩니다. 서명 옵션이 생략되면 서명의 기본값은 Git 버전 번호입니다.</target>
        </trans-unit>
        <trans-unit id="d67013d040b00288c354d7feb55fb2074c49fc78" translate="yes" xml:space="preserve">
          <source>Add a tag reference in &lt;code&gt;refs/tags/&lt;/code&gt;, unless &lt;code&gt;-d/-l/-v&lt;/code&gt; is given to delete, list or verify tags.</source>
          <target state="translated">&lt;code&gt;-d/-l/-v&lt;/code&gt; 를 사용하여 태그를 삭제, 나열 또는 확인 하지 않으면 &lt;code&gt;refs/tags/&lt;/code&gt; 에 태그 참조를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3ba9550fdf49f0f7ec1ed9c2838f550f0841180" translate="yes" xml:space="preserve">
          <source>Add all existing files to the index.</source>
          <target state="translated">기존의 모든 파일을 색인에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="61e0fed7e8f28eb826825866ef9181c8986ab6b6" translate="yes" xml:space="preserve">
          <source>Add an arbitrary header to the email headers. This is in addition to any configured headers, and may be used multiple times. For example, &lt;code&gt;--add-header=&quot;Organization: git-foo&quot;&lt;/code&gt;. The negated form &lt;code&gt;--no-add-header&lt;/code&gt; discards &lt;strong&gt;all&lt;/strong&gt; (&lt;code&gt;To:&lt;/code&gt;, &lt;code&gt;Cc:&lt;/code&gt;, and custom) headers added so far from config or command line.</source>
          <target state="translated">이메일 헤더에 임의의 헤더를 추가하십시오. 이것은 구성된 헤더에 추가되며 여러 번 사용될 수 있습니다. 예를 들어 &lt;code&gt;--add-header=&quot;Organization: git-foo&quot;&lt;/code&gt; 입니다. 부정 형식 인 &lt;code&gt;--no-add-header&lt;/code&gt; 는 구성 또는 명령 줄에서 지금까지 추가 된 &lt;strong&gt;모든&lt;/strong&gt; ( &lt;code&gt;To:&lt;/code&gt; , &lt;code&gt;Cc:&lt;/code&gt; 및 사용자 정의) 헤더 를 버립니다 .</target>
        </trans-unit>
        <trans-unit id="3eb694979cbe30dcf490050a0765be211e88b887" translate="yes" xml:space="preserve">
          <source>Add an extra directive to the output for commits and blobs, &lt;code&gt;original-oid &amp;lt;SHA1SUM&amp;gt;&lt;/code&gt;. While such directives will likely be ignored by importers such as git-fast-import, it may be useful for intermediary filters (e.g. for rewriting commit messages which refer to older commits, or for stripping blobs by id).</source>
          <target state="translated">커밋 및 블롭에 대한 출력에 추가 지시문을 추가하십시오 ( &lt;code&gt;original-oid &amp;lt;SHA1SUM&amp;gt;&lt;/code&gt; ) . 이러한 지시문은 git-fast-import와 같은 임포터에 의해 무시 될 수 있지만, 중간 필터 (예 : 이전 커밋을 참조하는 커밋 메시지를 다시 작성하거나 id로 BLOB 제거)에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3d9056473fe07372c67f810c3055c3b46a20590" translate="yes" xml:space="preserve">
          <source>Add authorship information. Adds Author line, and Committer (if different from Author) to the message.</source>
          <target state="translated">저작권 정보를 추가하십시오. 메시지에 작성자 줄과 커미터 (작성자와 다른 경우)를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b495931d52e43ecbfb5286b0146fb64097586eff" translate="yes" xml:space="preserve">
          <source>Add file contents to the index</source>
          <target state="translated">색인에 파일 내용 추가</target>
        </trans-unit>
        <trans-unit id="c35a311c3337f0cc2cbd68316a0fe51132f8719c" translate="yes" xml:space="preserve">
          <source>Add modified contents in the working tree interactively to the index. Optional path arguments may be supplied to limit operation to a subset of the working tree. See &amp;ldquo;Interactive mode&amp;rdquo; for details.</source>
          <target state="translated">작업 트리의 수정 된 내용을 대화식으로 색인에 추가하십시오. 작업 트리의 하위 집합으로 작업을 제한하기 위해 선택적 경로 인수가 제공 될 수 있습니다. 자세한 내용은 &quot;대화식 모드&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f89fde681339a37c16082b848c84b533f9b8eb78" translate="yes" xml:space="preserve">
          <source>Add more good examples. Entire sections of just cookbook examples might be a good idea; maybe make an &quot;advanced examples&quot; section a standard end-of-chapter section?</source>
          <target state="translated">더 좋은 예를 추가하십시오. 요리 책 예제의 전체 섹션이 좋은 아이디어 일 수 있습니다. &quot;고급 예제&quot;섹션을 표준 챕터 끝 섹션으로 만들 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="e557ff36381109d45439d6a8300a1119a6fdeb9a" translate="yes" xml:space="preserve">
          <source>Add notes for a given object (defaults to HEAD). Abort if the object already has notes (use &lt;code&gt;-f&lt;/code&gt; to overwrite existing notes). However, if you&amp;rsquo;re using &lt;code&gt;add&lt;/code&gt; interactively (using an editor to supply the notes contents), then - instead of aborting - the existing notes will be opened in the editor (like the &lt;code&gt;edit&lt;/code&gt; subcommand).</source>
          <target state="translated">주어진 개체에 대한 메모를 추가합니다 (기본값은 HEAD). 객체에 이미 노트가있는 경우 중단합니다 ( 기존 노트를 덮어 &lt;code&gt;-f&lt;/code&gt; 려면 -f 를 사용하십시오 ). 그러나 대화식으로 &lt;code&gt;add&lt;/code&gt; 를 사용하는 경우 (편집기를 사용하여 노트 내용 제공) 중단하지 않고 기존의 노트가 편집기에서 열립니다 ( &lt;code&gt;edit&lt;/code&gt; 부속 명령 과 같이 ).</target>
        </trans-unit>
        <trans-unit id="cc2ade0db6bb50863f06b44fc9c06dfd60dcfff0" translate="yes" xml:space="preserve">
          <source>Add or inspect object notes</source>
          <target state="translated">객체 메모 추가 또는 검사</target>
        </trans-unit>
        <trans-unit id="384163813513712116bc610979aaf5a161ff795b" translate="yes" xml:space="preserve">
          <source>Add or parse structured information in commit messages</source>
          <target state="translated">커밋 메시지에서 구조화 된 정보 추가 또는 구문 분석</target>
        </trans-unit>
        <trans-unit id="4e875c484b14b19240ea9be7566dd014f5c8ec38" translate="yes" xml:space="preserve">
          <source>Add the given merge information during the dcommit (e.g. &lt;code&gt;--mergeinfo=&quot;/branches/foo:1-10&quot;&lt;/code&gt;). All svn server versions can store this information (as a property), and svn clients starting from version 1.5 can make use of it. To specify merge information from multiple branches, use a single space character between the branches (&lt;code&gt;--mergeinfo=&quot;/branches/foo:1-10 /branches/bar:3,5-6,8&quot;&lt;/code&gt;)</source>
          <target state="translated">dcommit 중에 주어진 병합 정보를 추가하십시오 (예 : &lt;code&gt;--mergeinfo=&quot;/branches/foo:1-10&quot;&lt;/code&gt; ). 모든 svn 서버 버전은이 정보를 속성으로 저장할 수 있으며, 버전 1.5부터 시작하는 svn 클라이언트는이를 사용할 수 있습니다. 여러 분기의 병합 정보를 지정하려면 분기 사이에 단일 공백 ​​문자를 사용하십시오 ( &lt;code&gt;--mergeinfo=&quot;/branches/foo:1-10 /branches/bar:3,5-6,8&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3cd81f5530cb193ba26157e4348607aee6556490" translate="yes" xml:space="preserve">
          <source>Add the given repository as a submodule at the given path to the changeset to be committed next to the current project: the current project is termed the &quot;superproject&quot;.</source>
          <target state="translated">현재 프로젝트 옆에 커밋 할 변경 세트의 지정된 경로에 지정된 저장소를 서브 모듈로 추가하십시오. 현재 프로젝트를 &quot;슈퍼 프로젝트&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="5cddbbcd4cc96cbfc64c9c4d6d8f5bcef7bbee43" translate="yes" xml:space="preserve">
          <source>Add the standard Git exclusions: .git/info/exclude, .gitignore in each directory, and the user&amp;rsquo;s global exclusion file.</source>
          <target state="translated">표준 Git 제외를 추가하십시오 : .git / info / exclude, 각 디렉토리의 .gitignore 및 사용자의 글로벌 제외 파일.</target>
        </trans-unit>
        <trans-unit id="9821869aa821996defeaba01e6c12538af610d55" translate="yes" xml:space="preserve">
          <source>Added content is represented by lines beginning with &quot;+&quot;. You can prevent staging any addition lines by deleting them.</source>
          <target state="translated">추가 된 내용은 &quot;+&quot;로 시작하는 줄로 표시됩니다. 추가 라인을 삭제하여 스테이징을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afb70b05688a7cd869d2606481b27296b19719c8" translate="yes" xml:space="preserve">
          <source>Additional commands may be supported, as may be determined from capabilities reported by the helper.</source>
          <target state="translated">도우미가보고 한 기능에서 확인할 수있는 추가 명령이 지원 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73160eb439c17b83bb173df83040945299062f05" translate="yes" xml:space="preserve">
          <source>Additional email headers to include in a patch to be submitted by mail. See &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">메일로 제출할 패치에 포함 할 추가 이메일 헤더입니다. &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54ded2bd3477ca52f24ae225994ba73ed8ad29b3" translate="yes" xml:space="preserve">
          <source>Additional features not supported in the base command will be advertised as the value of the command in the capability advertisement in the form of a space separated list of features: &quot;&amp;lt;command&amp;gt;=&amp;lt;feature 1&amp;gt; &amp;lt;feature 2&amp;gt;&quot;</source>
          <target state="translated">기본 명령에서 지원되지 않는 추가 기능은 공백으로 구분 된 기능 목록 형식으로 기능 알림의 명령 값으로 보급됩니다. &quot;&amp;lt;command&amp;gt; = &amp;lt;feature 1&amp;gt; &amp;lt;feature 2&amp;gt;&quot;</target>
        </trans-unit>
        <trans-unit id="fa12c13f7c5fa3298b908c7e9540ddac59b47249" translate="yes" xml:space="preserve">
          <source>Additional information about the object store is recorded in this directory.</source>
          <target state="translated">오브젝트 저장소에 대한 추가 정보는이 디렉토리에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="be06c5d8e7c3543b7023fd7faff294ed6ccc5563" translate="yes" xml:space="preserve">
          <source>Additional information about the repository is recorded in this directory. This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/info&quot; will be used instead.</source>
          <target state="translated">저장소에 대한 추가 정보는이 디렉토리에 기록됩니다. $ GIT_COMMON_DIR이 설정되고 대신 &quot;$ GIT_COMMON_DIR / info&quot;가 사용되는 경우이 디렉토리는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e1d5079ec73555b8d437ff4e76ae398022d66054" translate="yes" xml:space="preserve">
          <source>Additional links to be added to the start of the breadcrumb trail before the home link, to pages that are logically &quot;above&quot; the gitweb projects list, such as the organization and department which host the gitweb server. Each element of the list is a reference to an array, in which element 0 is the link text (equivalent to &lt;code&gt;$home_link_str&lt;/code&gt;) and element 1 is the target URL (equivalent to &lt;code&gt;$home_link&lt;/code&gt;).</source>
          <target state="translated">gitweb 서버를 호스팅하는 조직 및 부서와 같이 gitweb 프로젝트 목록 위에 논리적으로 &quot;위에있는&quot;페이지에 홈 링크 앞의 이동 경로 추적 시작 부분에 추가 할 추가 링크. 목록의 각 요소는 배열에 대한 참조이며 요소 0은 링크 텍스트 ( &lt;code&gt;$home_link_str&lt;/code&gt; 와 동일 )이고 요소 1은 대상 URL ( &lt;code&gt;$home_link&lt;/code&gt; 와 동일 )입니다.</target>
        </trans-unit>
        <trans-unit id="d9432410873900e1c24cb64c2fa2f5825d3d685b" translate="yes" xml:space="preserve">
          <source>Additional option to &lt;code&gt;--full-history&lt;/code&gt; to remove some needless merges from the resulting history, as there are no selected commits contributing to this merge.</source>
          <target state="translated">이 병합에 기여하는 선택된 커밋이 없으므로 결과 기록에서 불필요한 병합을 제거 하기위한 &lt;code&gt;--full-history&lt;/code&gt; 에 대한 추가 옵션 .</target>
        </trans-unit>
        <trans-unit id="936252ffd07e8aa44edb6a58806e990e0e986320" translate="yes" xml:space="preserve">
          <source>Additional option to &lt;code&gt;--full-history&lt;/code&gt; to remove some needless merges from the resulting history, as there are no selected commits contributing to this merge. (See &quot;History simplification&quot; in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; for a more detailed explanation.)</source>
          <target state="translated">이 병합에 기여하는 선택된 커밋이 없으므로 결과 기록에서 불필요한 병합을 제거 하기위한 &lt;code&gt;--full-history&lt;/code&gt; 에 대한 추가 옵션 . ( 자세한 설명 은 &lt;a href=&quot;git-log&quot;&gt;git-log [1]의&lt;/a&gt; &quot;내역 단순화&quot;를 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="639abe6e93382e14198d397d42d012876c506898" translate="yes" xml:space="preserve">
          <source>Additional options for cvsps. The options &lt;code&gt;-u&lt;/code&gt; and &lt;code&gt;-A&lt;/code&gt; are implicit and should not be used here.</source>
          <target state="translated">cvsp에 대한 추가 옵션. &lt;code&gt;-u&lt;/code&gt; 및 &lt;code&gt;-A&lt;/code&gt; 옵션 은 암시 적이므로 여기에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="126d4b07345ee8d93a4ae79da306723c896414b7" translate="yes" xml:space="preserve">
          <source>Additional recipients to include in a patch to be submitted by mail. See the --to and --cc options in &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">우편으로 제출할 패치에 포함 할 추가 수신자. &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]의&lt;/a&gt; --to 및 --cc 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37901b95369dc888aa41ab1e345bdcf6c9cbdd0a" translate="yes" xml:space="preserve">
          <source>Additionally, &quot;[PATCH]&quot; will be stripped from the commit description.</source>
          <target state="translated">또한 커밋 설명에서 &quot;[PATCH]&quot;가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="45f709ea6030431bf2cc526dc56f831bf13777f2" translate="yes" xml:space="preserve">
          <source>Additionally, it detects and handles renames and complete rewrites intelligently to produce a renaming patch. A renaming patch reduces the amount of text output, and generally makes it easier to review. Note that non-Git &quot;patch&quot; programs won&amp;rsquo;t understand renaming patches, so use it only when you know the recipient uses Git to apply your patch.</source>
          <target state="translated">또한 이름 변경을 감지하고 처리하고 이름을 바꾸어 패치를 작성하기 위해 지능적으로 재 작성을 완료합니다. 이름 바꾸기 패치는 텍스트 출력량을 줄이고 일반적으로 검토하기가 더 쉽습니다. Git 이외의 &quot;패치&quot;프로그램은 패치 이름 바꾸기를 이해하지 못하므로 수신자가 Git을 사용하여 패치를 적용한다는 것을 알고있을 때만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7511556dc9bb42ef3e1b927086b0b7b0eb2fc510" translate="yes" xml:space="preserve">
          <source>Additionally, it will create a special branch named &lt;code&gt;&amp;lt;branchname&amp;gt;@&amp;lt;SVN-Revision&amp;gt;&lt;/code&gt;, where &amp;lt;SVN-Revision&amp;gt; is the SVN revision number the branch was copied from. This branch will point to the newly created parent commit of the branch. If in SVN the branch was deleted and later recreated from a different version, there will be multiple such branches with an &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;&amp;lt;branchname&amp;gt;@&amp;lt;SVN-Revision&amp;gt;&lt;/code&gt; 이라는 특수 분기를 작성합니다 . 여기서 &amp;lt;SVN-Revision&amp;gt;은 분기가 복사 된 SVN 개정 번호입니다. 이 분기는 새로 작성된 분기의 상위 커밋을 가리 킵니다. SVN에서 분기가 삭제 된 후 나중에 다른 버전에서 다시 작성된 경우 &lt;code&gt;@&lt;/code&gt; 가있는 여러 분기가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4aae954f8fe3ec994c11ca19a460c6f95d1b16b" translate="yes" xml:space="preserve">
          <source>Additionally, only one of these options can be used per svn-remote section because they affect the &lt;code&gt;git-svn-id:&lt;/code&gt; metadata line, except for rewriteRoot and rewriteUUID which can be used together.</source>
          <target state="translated">또한 svn-remote 섹션 당 이러한 옵션 중 하나만 함께 사용할 수있는 rewriteRoot 및 rewriteUUID를 제외하고 &lt;code&gt;git-svn-id:&lt;/code&gt; 메타 데이터 행에 영향을주기 때문에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="629abb925697ea2611b60db0bc894374f52c4869" translate="yes" xml:space="preserve">
          <source>Additionally, the commit diff lines that are only present in the first commit range are shown &quot;dimmed&quot; (this can be overridden using the &lt;code&gt;color.diff.&amp;lt;slot&amp;gt;&lt;/code&gt; config setting where &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; is one of &lt;code&gt;contextDimmed&lt;/code&gt;, &lt;code&gt;oldDimmed&lt;/code&gt; and &lt;code&gt;newDimmed&lt;/code&gt;), and the commit diff lines that are only present in the second commit range are shown in bold (which can be overridden using the config settings &lt;code&gt;color.diff.&amp;lt;slot&amp;gt;&lt;/code&gt; with &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; being one of &lt;code&gt;contextBold&lt;/code&gt;, &lt;code&gt;oldBold&lt;/code&gt; or &lt;code&gt;newBold&lt;/code&gt;).</source>
          <target state="translated">또한 첫 번째 커밋 범위에만 존재하는 커밋 차이 라인은 &quot;흐리게&quot;표시됩니다 ( &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 &lt;code&gt;contextDimmed&lt;/code&gt; , &lt;code&gt;oldDimmed&lt;/code&gt; 및 &lt;code&gt;newDimmed&lt;/code&gt; 중 하나 인 &lt;code&gt;color.diff.&amp;lt;slot&amp;gt;&lt;/code&gt; 구성 설정을 사용하여 재정의 할 수 있음 ). 두 번째 커밋 범위에만있는 커밋 차이 라인은 굵게 표시됩니다 (config 설정 &lt;code&gt;color.diff.&amp;lt;slot&amp;gt;&lt;/code&gt; 을 사용하여 재정의 할 수 있음 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 은 &lt;code&gt;contextBold&lt;/code&gt; , &lt;code&gt;oldBold&lt;/code&gt; 또는 &lt;code&gt;newBold&lt;/code&gt; 중 하나임 ).</target>
        </trans-unit>
        <trans-unit id="e3a92988309d106a41ec2c3de042e66fc0f8ee75" translate="yes" xml:space="preserve">
          <source>Additionally, the trailers as interpreted by &lt;a href=&quot;git-interpret-trailers&quot;&gt;git-interpret-trailers[1]&lt;/a&gt; are obtained as &lt;code&gt;trailers&lt;/code&gt; (or by using the historical alias &lt;code&gt;contents:trailers&lt;/code&gt;). Non-trailer lines from the trailer block can be omitted with &lt;code&gt;trailers:only&lt;/code&gt;. Whitespace-continuations can be removed from trailers so that each trailer appears on a line by itself with its full content with &lt;code&gt;trailers:unfold&lt;/code&gt;. Both can be used together as &lt;code&gt;trailers:unfold,only&lt;/code&gt;.</source>
          <target state="translated">또한, 해석으로 트레일러 &lt;a href=&quot;git-interpret-trailers&quot;&gt;자식-해석 트레일러 [1]&lt;/a&gt; 로 얻어진다 &lt;code&gt;trailers&lt;/code&gt; (또는 과거 별명 사용 &lt;code&gt;contents:trailers&lt;/code&gt; ). 트레일러 블록의 비 트레일러 라인은 &lt;code&gt;trailers:only&lt;/code&gt; 로 생략 할 수 있습니다 . 공백 연속은 예고편에서 제거되어 각 예고편이 &lt;code&gt;trailers:unfold&lt;/code&gt; 전체 콘텐츠와 함께 한 줄에 표시되도록 할 수 있습니다 . 둘 다 &lt;code&gt;trailers:unfold,only&lt;/code&gt; 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="33cc6001363abb379cd9070769d41d2ac8c9a55b" translate="yes" xml:space="preserve">
          <source>Additionally, when a configured remote has &lt;code&gt;remote.&amp;lt;name&amp;gt;.vcs&lt;/code&gt; set to &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt;, Git explicitly invokes &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; with &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; as the first argument. If set, the second argument is &lt;code&gt;remote.&amp;lt;name&amp;gt;.url&lt;/code&gt;; otherwise, the second argument is omitted.</source>
          <target state="translated">또한 구성된 원격에 &lt;code&gt;remote.&amp;lt;name&amp;gt;.vcs&lt;/code&gt; 가 &lt;code&gt;&amp;lt;transport&amp;gt;&lt;/code&gt; 로 설정된 경우 Git 은 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 을 첫 번째 인수로 사용하여 &lt;code&gt;git remote-&amp;lt;transport&amp;gt;&lt;/code&gt; 을 명시 적으로 호출합니다 . 설정된 경우 두 번째 인수는 &lt;code&gt;remote.&amp;lt;name&amp;gt;.url&lt;/code&gt; ; 그렇지 않으면 두 번째 인수는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="6af479ae4e97a30fad59cd7baeb4a449867877a2" translate="yes" xml:space="preserve">
          <source>Adds a &lt;code&gt;replace&lt;/code&gt; reference in &lt;code&gt;refs/replace/&lt;/code&gt; namespace.</source>
          <target state="translated">&lt;code&gt;refs/replace/&lt;/code&gt; 네임 스페이스 에 &lt;code&gt;replace&lt;/code&gt; 참조를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="067f226622dab621132cf8ecc0c9775fffa56382" translate="yes" xml:space="preserve">
          <source>Adds a new line to the option without altering any existing values. This is the same as providing &lt;code&gt;^$&lt;/code&gt; as the value_regex in &lt;code&gt;--replace-all&lt;/code&gt;.</source>
          <target state="translated">기존 값을 변경하지 않고 옵션에 새 줄을 추가합니다. 이것은 &lt;code&gt;--replace-all&lt;/code&gt; 의 value_regex와 &lt;code&gt;^$&lt;/code&gt; 를 제공하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="25827132716a81d21acebe34dd646ff14930968e" translate="yes" xml:space="preserve">
          <source>Adds a remote named &amp;lt;name&amp;gt; for the repository at &amp;lt;url&amp;gt;. The command &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; can then be used to create and update remote-tracking branches &amp;lt;name&amp;gt;/&amp;lt;branch&amp;gt;.</source>
          <target state="translated">&amp;lt;url&amp;gt;의 저장소에 &amp;lt;name&amp;gt;이라는 원격을 추가합니다. 그런 다음 &lt;code&gt;git fetch &amp;lt;name&amp;gt;&lt;/code&gt; 명령을 사용하여 원격 추적 분기 &amp;lt;name&amp;gt; / &amp;lt;branch&amp;gt;를 만들고 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab8c59cb65189781a225d03eb525c1d3e35346e1" translate="yes" xml:space="preserve">
          <source>Adds content from all &lt;code&gt;*.txt&lt;/code&gt; files under &lt;code&gt;Documentation&lt;/code&gt; directory and its subdirectories:</source>
          <target state="translated">&lt;code&gt;Documentation&lt;/code&gt; 디렉토리 및 해당 서브 디렉토리 아래의 모든 &lt;code&gt;*.txt&lt;/code&gt; 파일에서 컨텐츠를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="d2a8bde384697b7b35dc55b38f84a5bc59a23070" translate="yes" xml:space="preserve">
          <source>Adds the file to the index again.</source>
          <target state="translated">파일을 색인에 다시 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9deafeaa2ae3e0af3bf37dc46c067f8db67dd63a" translate="yes" xml:space="preserve">
          <source>Adds, removes, or reads notes attached to objects, without touching the objects themselves.</source>
          <target state="translated">객체 자체를 건드리지 않고 객체에 첨부 된 메모를 추가, 제거 또는 읽습니다.</target>
        </trans-unit>
        <trans-unit id="b8f333e4ae95f720feba6eabc8b0ae852b99b985" translate="yes" xml:space="preserve">
          <source>Administering</source>
          <target state="translated">Administering</target>
        </trans-unit>
        <trans-unit id="b8be3d1264310c3b8c848d4b90d5206179a40cc4" translate="yes" xml:space="preserve">
          <source>Administration</source>
          <target state="translated">Administration</target>
        </trans-unit>
        <trans-unit id="c98cde56602b5dbe18cd13dfc6b1296aba3da4ee" translate="yes" xml:space="preserve">
          <source>Advanced branch management</source>
          <target state="translated">고급 지점 관리</target>
        </trans-unit>
        <trans-unit id="63c9e0bac98e698a29bdae673d4e9edfa151c025" translate="yes" xml:space="preserve">
          <source>Advanced options</source>
          <target state="translated">고급 옵션</target>
        </trans-unit>
        <trans-unit id="5126907c1aaa23aea7d546c880913def66c36620" translate="yes" xml:space="preserve">
          <source>Advanced shared repository management</source>
          <target state="translated">고급 공유 저장소 관리</target>
        </trans-unit>
        <trans-unit id="1b3bdc1b24cf17ee4a466d753939342282e0d80f" translate="yes" xml:space="preserve">
          <source>Advanced web server setup</source>
          <target state="translated">고급 웹 서버 설정</target>
        </trans-unit>
        <trans-unit id="b6a2eaecb555069cd46a3c234e96420e295802e9" translate="yes" xml:space="preserve">
          <source>Advertise the URL of &lt;code&gt;proj.git&lt;/code&gt;. Anybody else should then be able to clone or pull from that URL, for example with a command line like:</source>
          <target state="translated">&lt;code&gt;proj.git&lt;/code&gt; 의 URL을 보급하십시오 . 다른 사람은 다음과 같은 명령 줄을 사용하여 해당 URL을 복제하거나 가져올 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="789a67096a4646c15f2aa6086486ffd34077e411" translate="yes" xml:space="preserve">
          <source>Advice on how to set your identity configuration when your information is guessed from the system username and domain name.</source>
          <target state="translated">시스템 사용자 이름 및 도메인 이름에서 정보를 추측 할 때 ID 구성을 설정하는 방법에 대한 조언.</target>
        </trans-unit>
        <trans-unit id="a821447d06e24bab231c15461aafe7618db95e5a" translate="yes" xml:space="preserve">
          <source>Advice on what to do when you&amp;rsquo;ve accidentally added one git repo inside of another.</source>
          <target state="translated">실수로 다른 git repo를 다른 git repo에 추가했을 때 수행 할 작업에 대한 조언.</target>
        </trans-unit>
        <trans-unit id="3d483bea154d1589851e27e82350c90b66804ae7" translate="yes" xml:space="preserve">
          <source>Advice shown by various commands when conflicts prevent the operation from being performed.</source>
          <target state="translated">충돌이 작업 수행을 방해 할 때 다양한 명령으로 표시되는 조언.</target>
        </trans-unit>
        <trans-unit id="f6a85c6f280ebe2521ee45431f06743254445adc" translate="yes" xml:space="preserve">
          <source>Advice shown if a hook is ignored because the hook is not set as executable.</source>
          <target state="translated">후크가 실행 가능으로 설정되지 않아 후크가 무시되는 경우 표시되는 조언.</target>
        </trans-unit>
        <trans-unit id="94667464d70841fb0d303f0566cdfefaa202fbb7" translate="yes" xml:space="preserve">
          <source>Advice shown if a user attempts to add an ignored file to the index.</source>
          <target state="translated">사용자가 무시 된 파일을 색인에 추가하려고 할 때 표시되는 조언입니다.</target>
        </trans-unit>
        <trans-unit id="860ec9915ca898e80b509fbd6387408b77665509" translate="yes" xml:space="preserve">
          <source>Advice shown if a user attempts to recursively tag a tag object.</source>
          <target state="translated">사용자가 태그 객체를 재귀 적으로 태그하려고 시도하면 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="380186874c1d8ce69a1886939554074230a69de1" translate="yes" xml:space="preserve">
          <source>Advice shown if a user runs the add command without providing the pathspec parameter.</source>
          <target state="translated">사용자가 pathspec 매개 변수를 제공하지 않고 add 명령을 실행하는 경우 표시되는 조언입니다.</target>
        </trans-unit>
        <trans-unit id="4564a8cef9c264afd1da9386fe52f7316f5ca2ba" translate="yes" xml:space="preserve">
          <source>Advice shown when &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt; takes a long time to calculate forced updates after ref updates, or to warn that the check is disabled.</source>
          <target state="translated">ref &lt;a href=&quot;git-fetch&quot;&gt;-fetch [1]&lt;/a&gt; 가 ref 업데이트 후 강제 업데이트를 계산하거나 검사가 비활성화되었음을 경고하는 데 시간이 오래 걸릴 때 표시되는 조언 입니다.</target>
        </trans-unit>
        <trans-unit id="1d65ddbca3a799ed312f569d4aeb5502874161b1" translate="yes" xml:space="preserve">
          <source>Advice shown when &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt; refuses to merge to avoid overwriting local changes.</source>
          <target state="translated">&lt;a href=&quot;git-merge&quot;&gt;git-merge [1]가&lt;/a&gt; 로컬 변경 사항 덮어 쓰기를 피하기 위해 병합을 거부 할 때 표시되는 조언 .</target>
        </trans-unit>
        <trans-unit id="b0d8f2ca61900be48cc5b75f8552ddc63690e847" translate="yes" xml:space="preserve">
          <source>Advice shown when &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; fails due to a non-fast-forward update to the current branch.</source>
          <target state="translated">현재 분기에 빨리 감기가 아닌 업데이트로 인해 &lt;a href=&quot;git-push&quot;&gt;git-push [1]&lt;/a&gt; 이 실패 할 때 표시되는 조언 입니다.</target>
        </trans-unit>
        <trans-unit id="4568fed53b701ea10d314b56862ee812cfea2bea" translate="yes" xml:space="preserve">
          <source>Advice shown when a sequencer command is already in progress.</source>
          <target state="translated">시퀀서 명령이 이미 진행 중일 때 표시되는 조언.</target>
        </trans-unit>
        <trans-unit id="9ae8580cfe92126e912e3c0a9b1125abf0c3f017" translate="yes" xml:space="preserve">
          <source>Advice shown when a submodule.alternateErrorStrategy option configured to &quot;die&quot; causes a fatal error.</source>
          <target state="translated">submodule.alternateErrorStrategy 옵션이 &quot;die&quot;로 구성된 경우 치명적인 오류가 발생하는 경우 표시되는 조언입니다.</target>
        </trans-unit>
        <trans-unit id="df663a838b7df94d5ce12ffdd49a91bc903ea158" translate="yes" xml:space="preserve">
          <source>Advice shown when the argument to &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; and &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; ambiguously resolves to a remote tracking branch on more than one remote in situations where an unambiguous argument would have otherwise caused a remote-tracking branch to be checked out. See the &lt;code&gt;checkout.defaultRemote&lt;/code&gt; configuration variable for how to set a given remote to used by default in some situations where this advice would be printed.</source>
          <target state="translated">&lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; 및 &lt;a href=&quot;git-switch&quot;&gt;git-switch [1]&lt;/a&gt; 에 대한 인수가 모호하지 않은 인수로 인해 원격 추적 분기가 체크 아웃되는 상황에서 둘 이상의 원격에서 원격 추적 분기로 모호하게 해석 될 때 표시되는 조언 . 이 조언이 인쇄되는 상황에서 지정된 리모컨을 기본적으로 사용하도록 설정하는 방법 은 &lt;code&gt;checkout.defaultRemote&lt;/code&gt; 구성 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="287a70bfe9316e6c27233404e6ef7bfe75cf2ade" translate="yes" xml:space="preserve">
          <source>Advice shown when you ran &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and pushed &lt;code&gt;matching refs&lt;/code&gt; explicitly (i.e. you used &lt;code&gt;:&lt;/code&gt;, or specified a refspec that isn&amp;rsquo;t your current branch) and it resulted in a non-fast-forward error.</source>
          <target state="translated">&lt;a href=&quot;git-push&quot;&gt;git-push [1]을 실행&lt;/a&gt; 하고 &lt;code&gt;matching refs&lt;/code&gt; 명시 적으로 푸시 했을 때 표시되는 조언 (예 &lt;code&gt;:&lt;/code&gt; 을 사용 하거나 현재 분기가 아닌 참조 스펙을 지정 함)에 빨리 감기 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="c04cbde1130eafb3edca74961656b00234c5044b" translate="yes" xml:space="preserve">
          <source>Advice shown when you used &lt;a href=&quot;git-switch&quot;&gt;git-switch[1]&lt;/a&gt; or &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; to move to the detach HEAD state, to instruct how to create a local branch after the fact.</source>
          <target state="translated">&lt;a href=&quot;git-switch&quot;&gt;git-switch [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; 을 사용하여 HEAD 분리 상태로 이동하여 사실 이후에 로컬 브랜치를 작성하는 방법을 지시 할 때 표시되는 조언 .</target>
        </trans-unit>
        <trans-unit id="ef27fc3c51d0563e2cd508226536f4e82abdea97" translate="yes" xml:space="preserve">
          <source>Advice that shows the location of the patch file when &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; fails to apply it.</source>
          <target state="translated">&lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt; 이 적용하지 못하는 경우 패치 파일의 위치를 ​​표시하는 조언 .</target>
        </trans-unit>
        <trans-unit id="28a199e10db511a76b4343fb1d5d8f81b83d30fa" translate="yes" xml:space="preserve">
          <source>Advice to consider using the &lt;code&gt;--quiet&lt;/code&gt; option to &lt;a href=&quot;git-reset&quot;&gt;git-reset[1]&lt;/a&gt; when the command takes more than 2 seconds to enumerate unstaged changes after reset.</source>
          <target state="translated">조언은 사용을 고려하는 &lt;code&gt;--quiet&lt;/code&gt; 에 옵션을 &lt;a href=&quot;git-reset&quot;&gt;자식 리셋 [1]&lt;/a&gt; 명령이 리셋 후 unstaged 변경 내용을 열거하는 데 2 초 이상 걸리는 경우.</target>
        </trans-unit>
        <trans-unit id="c591e1c0c160f4739a66ef35a070ea84c2e7f3a4" translate="yes" xml:space="preserve">
          <source>Advise to consider using the &lt;code&gt;-u&lt;/code&gt; option to &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; when the command takes more than 2 seconds to enumerate untracked files.</source>
          <target state="translated">조언은 사용을 고려하는 &lt;code&gt;-u&lt;/code&gt; 옵션을 ' &lt;a href=&quot;git-status&quot;&gt;자식 현황 [1]&lt;/a&gt; 명령이 비 추적 파일을 열거하는 데 2 초 이상 걸리는 경우.</target>
        </trans-unit>
        <trans-unit id="5496dea1231cd43f3ddab3a40907ffb3e37af6ae" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;attr:&lt;/code&gt; comes a space separated list of &quot;attribute requirements&quot;, all of which must be met in order for the path to be considered a match; this is in addition to the usual non-magic pathspec pattern matching. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;attr:&lt;/code&gt; 이후 : 공백으로 구분 된 &quot;속성 요구 사항&quot;목록이 제공되며, 경로가 일치하는 것으로 간주 되려면 모두 충족되어야합니다. 이것은 일반적인 비 매직 경로 사양 패턴 일치에 추가됩니다. &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a429914950c338a68e237d8a7583b13b733a18d9" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;collapsing&lt;/code&gt; operation, paths that are different in three trees are left in non-zero stages. At this point, you can inspect the index file with this command:</source>
          <target state="translated">&lt;code&gt;collapsing&lt;/code&gt; 작업 후 3 개의 트리에서 다른 경로는 0이 아닌 단계로 남습니다. 이 시점에서 다음 명령으로 색인 파일을 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8a35b13d3b2d2c3173fb0d4b6b82c758bbe9442" translate="yes" xml:space="preserve">
          <source>After Git received the pathnames, it will request the corresponding blobs again. These requests contain a pathname and an empty content section. The filter is expected to respond with the smudged content in the usual way as explained above.</source>
          <target state="translated">Git이 경로 이름을 수신하면 해당 Blob을 다시 요청합니다. 이러한 요청에는 경로 이름과 빈 내용 섹션이 있습니다. 필터는 위에서 설명한 일반적인 방법으로 얼룩이있는 내용으로 반응합니다.</target>
        </trans-unit>
        <trans-unit id="66031e0774792924c3ad30f78f9d0c8073d135a9" translate="yes" xml:space="preserve">
          <source>After a &lt;code&gt;git merge&lt;/code&gt; stops due to conflicts you can conclude the merge by running &lt;code&gt;git merge --continue&lt;/code&gt; (see &quot;HOW TO RESOLVE CONFLICTS&quot; section below).</source>
          <target state="translated">충돌로 인해 &lt;code&gt;git merge&lt;/code&gt; 가 중지 된 후 &lt;code&gt;git merge --continue&lt;/code&gt; 를 실행하여 병합을 완료 할 수 있습니다 (아래 &quot;충돌 해결 방법&quot;섹션 참조).</target>
        </trans-unit>
        <trans-unit id="fe72261aa48e1b3f091f59d72477eebdd075b990" translate="yes" xml:space="preserve">
          <source>After a bisect session, to clean up the bisection state and return to the original HEAD, issue the following command:</source>
          <target state="translated">이분법 세션 후 이분법 상태를 정리하고 원래 HEAD로 돌아가려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="47c118266972ae017fd4f07d4eca9db22855faae" translate="yes" xml:space="preserve">
          <source>After a failed merge, show refs that touch files having a conflict and don&amp;rsquo;t exist on all heads to merge.</source>
          <target state="translated">병합 실패 후 충돌이 발생한 터치 파일을 병합하고 모든 헤드에 병합하지 않는 참조를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4ca7401582c91e911d7f14741ffa269af2ed6e2a" translate="yes" xml:space="preserve">
          <source>After a feature release, the integration branch &lt;code&gt;next&lt;/code&gt; may optionally be rewound and rebuilt from the tip of &lt;code&gt;master&lt;/code&gt; using the surviving topics on &lt;code&gt;next&lt;/code&gt;:</source>
          <target state="translated">기능 릴리스 후 &lt;code&gt;next&lt;/code&gt; 통합 분기 는 선택적 으로 &lt;code&gt;next&lt;/code&gt; 남아있는 주제를 사용하여 &lt;code&gt;master&lt;/code&gt; 팁에서 되감기 및 재 구축 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ee4d8fb94bffa7e70baa538f9ff73a2b240bae8" translate="yes" xml:space="preserve">
          <source>After a feature release, you need to manage your maintenance branches.</source>
          <target state="translated">기능 릴리스 후 유지 보수 분기를 관리해야합니다.</target>
        </trans-unit>
        <trans-unit id="745f4d981edc1fae67ad7a65eae4ba7b48a51d0c" translate="yes" xml:space="preserve">
          <source>After a merge (initiated by &lt;code&gt;git merge&lt;/code&gt; or &lt;code&gt;git pull&lt;/code&gt;) stops because of conflicts, cleanly merged paths are already staged to be committed for you, and paths that conflicted are left in unmerged state. You would have to first check which paths are conflicting with &lt;code&gt;git status&lt;/code&gt; and after fixing them manually in your working tree, you would stage the result as usual with &lt;code&gt;git add&lt;/code&gt;:</source>
          <target state="translated">충돌로 인해 병합 ( &lt;code&gt;git merge&lt;/code&gt; 또는 &lt;code&gt;git pull&lt;/code&gt; 으로 시작 )이 중지 된 후, 완전히 병합 된 경로는 이미 커밋되도록 준비되어 있으며 충돌 된 경로는 병합되지 않은 상태로 남아 있습니다. 먼저 &lt;code&gt;git status&lt;/code&gt; 와 충돌하는 경로를 확인 하고 작업 트리에서 수동으로 수정 한 후 &lt;code&gt;git add&lt;/code&gt; 를 사용 하여 평소대로 결과를 스테이징합니다 .</target>
        </trans-unit>
        <trans-unit id="10502b7e8b48a8dee46e24b2019e9f5e468162f8" translate="yes" xml:space="preserve">
          <source>After a patch failure (e.g. attempting to apply conflicting patch), the user has applied it by hand and the index file stores the result of the application. Make a commit using the authorship and commit log extracted from the e-mail message and the current index file, and continue.</source>
          <target state="translated">패치가 실패한 후 (예 : 충돌하는 패치를 적용하려고 시도한 후) 사용자는 직접 패치를 적용했으며 인덱스 파일은 응용 프로그램의 결과를 저장합니다. 전자 우편 메시지 및 현재 색인 파일에서 추출 된 권한 및 확약 로그를 사용하여 확약하고 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="5aad77091cab70cb7dbe8f7ee76657f4f26524af" translate="yes" xml:space="preserve">
          <source>After a path matches any non-exclude pathspec, it will be run through all exclude pathspecs (magic signature: &lt;code&gt;!&lt;/code&gt; or its synonym &lt;code&gt;^&lt;/code&gt;). If it matches, the path is ignored. When there is no non-exclude pathspec, the exclusion is applied to the result set as if invoked without any pathspec.</source>
          <target state="translated">경로가 비 제외 경로 스펙과 일치하면 모든 제외 경로 스펙 (마법 서명 : &lt;code&gt;!&lt;/code&gt; 또는 동의어 &lt;code&gt;^&lt;/code&gt; )을 통해 실행됩니다 . 일치하면 경로가 무시됩니다. 비 제외 경로 스펙이없는 경우 제외는 경로 스펙없이 호출 된 것처럼 결과 세트에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e532f3552d5348fdc5f1bdf8915328d4f66e0e76" translate="yes" xml:space="preserve">
          <source>After a successful merge, update the files in the work tree with the result of the merge.</source>
          <target state="translated">성공적으로 병합 한 후에는 병합 결과로 작업 트리의 파일을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="f915a9b6a0d7dfb5ab76e6778aa20c487e2e4897" translate="yes" xml:space="preserve">
          <source>After a while, you will have a number of branches, and despite the well chosen names you picked for each of them, you may forget what they are for, or what status they are in. To get a reminder of what changes are in a specific branch, use:</source>
          <target state="translated">잠시 후, 당신은 많은 지점을 갖게 될 것이며, 당신이 그들 각각에 대해 잘 선택한 이름에도 불구하고, 당신은 그들이 무엇인지 또는 어떤 지위를 잊어 버릴 수 있습니다. 특정 지점 :</target>
        </trans-unit>
        <trans-unit id="a21e19052101e64abbac6635b64126db7893d400" translate="yes" xml:space="preserve">
          <source>After about 13 tests (in this case), it will output the commit id of the guilty commit. You can then examine the commit with &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;, find out who wrote it, and mail them your bug report with the commit id. Finally, run</source>
          <target state="translated">약 13 번의 테스트 (이 경우)가 끝나면 유죄 커밋의 커밋 ID가 출력됩니다. 그런 다음 &lt;a href=&quot;git-show&quot;&gt;git-show [1]로&lt;/a&gt; 커밋을 검사하고 누가 작성했는지 확인하고 커밋 ID로 버그 보고서를 메일로 보낼 수 있습니다. 마지막으로 실행</target>
        </trans-unit>
        <trans-unit id="39d63924c0ad3d41ed7256461fb0f8cabfcd6c6b" translate="yes" xml:space="preserve">
          <source>After all other processing, if at least one ref was updated, and if $GIT_DIR/hooks/post-update file exists and is executable, then post-update will be called with the list of refs that have been updated. This can be used to implement any repository wide cleanup tasks.</source>
          <target state="translated">다른 모든 처리 후 하나 이상의 참조가 업데이트되고 $ GIT_DIR / hooks / post-update 파일이 존재하고 실행 가능한 경우 업데이트 된 참조 목록과 함께 업데이트 후가 호출됩니다. 리포지토리 전체 정리 작업을 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63a0e4603dcf967bd9664f6f3fe860af10658058" translate="yes" xml:space="preserve">
          <source>After all refs were updated (or attempted to be updated), if any ref update was successful, and if $GIT_DIR/hooks/post-receive file exists and is executable, it will be invoked once with no parameters. The standard input of the hook will be one line for each successfully updated ref:</source>
          <target state="translated">모든 참조가 업데이트 된 후 (또는 업데이트를 시도한 후) 참조 업데이트가 성공한 경우 $ GIT_DIR / hooks / post-receive 파일이 존재하고 실행 가능한 경우 매개 변수없이 한 번만 호출됩니다. 후크의 표준 입력은 성공적으로 업데이트 된 각 참조마다 한 줄입니다.</target>
        </trans-unit>
        <trans-unit id="df214f68fd91640cff1f194bcc254ff88f0793ee" translate="yes" xml:space="preserve">
          <source>After an attempt to merge stops with conflicts, show the commits on the history between two branches (i.e. the HEAD and the MERGE_HEAD) that modify the conflicted files and do not exist on all the heads being merged.</source>
          <target state="translated">병합 시도가 충돌로 중지 된 후 충돌 된 파일을 수정하고 병합되는 모든 헤드에 존재하지 않는 두 분기 (예 : HEAD 및 MERGE_HEAD) 사이의 히스토리에 대한 커미트를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="6855a297433d6efa583ee53f54f77288a36a4a3c" translate="yes" xml:space="preserve">
          <source>After committing, do not rebase or reset.</source>
          <target state="translated">커밋 한 후 리베이스하거나 재설정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a6cb6cc7533103000a5b985188fd777c705ca2f2" translate="yes" xml:space="preserve">
          <source>After configuring the remote, the following three commands will do the same thing:</source>
          <target state="translated">원격을 구성한 후 다음 세 명령은 동일한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="38c4cb5f4b09781b6323bee4b2e059f8adaf4c9f" translate="yes" xml:space="preserve">
          <source>After creating a packfile, print a line of data to &amp;lt;file&amp;gt; listing the filename of the packfile and the last commit on each branch that was written to that packfile. This information may be useful after importing projects whose total object set exceeds the 4 GiB packfile limit, as these commits can be used as edge points during calls to &lt;code&gt;git pack-objects&lt;/code&gt;.</source>
          <target state="translated">팩 파일을 만든 후 팩 파일의 파일 이름과 해당 팩 파일에 기록 된 각 분기의 마지막 커밋을 나열하는 데이터 줄을 &amp;lt;file&amp;gt;에 인쇄합니다. 이 정보는 커밋이 &lt;code&gt;git pack-objects&lt;/code&gt; 를 호출하는 동안 엣지 포인트로 사용될 수 있기 때문에 총 오브젝트 세트가 4 GiB packfile 제한을 초과하는 프로젝트를 가져온 후에 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7eb0f12cc4760d99513845842d5818989334b063" translate="yes" xml:space="preserve">
          <source>After creating commits on a local branch, update the remote branch with your commits:</source>
          <target state="translated">로컬 브랜치에서 커밋을 생성 한 후 커밋으로 원격 브랜치를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="d35d26dae79ab6ed7b967d8dc4249bb1ae7ac970" translate="yes" xml:space="preserve">
          <source>After deciding the fate for all hunks, if there is any hunk that was chosen, the index is updated with the selected hunks.</source>
          <target state="translated">모든 덩어리에 대한 운명을 결정한 후 선택된 덩어리가 있으면 선택한 덩어리로 색인이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="1e8e9a912ee46d43880271748ff8431413ab88e6" translate="yes" xml:space="preserve">
          <source>After each line that describes a file, add more data about its cache entry. This is intended to show as much information as possible for manual inspection; the exact format may change at any time.</source>
          <target state="translated">파일을 설명하는 각 줄 뒤에 캐시 항목에 대한 데이터를 더 추가하십시오. 이것은 수동 검사를 위해 가능한 많은 정보를 보여주기위한 것입니다. 정확한 형식은 언제든지 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e22ef2eb3af8a0d0bd459bef01ed36acc704c46" translate="yes" xml:space="preserve">
          <source>After each step you can verify that</source>
          <target state="translated">각 단계 후에는</target>
        </trans-unit>
        <trans-unit id="715ed76b18490d22ccb88eb785651c8c2059a4a7" translate="yes" xml:space="preserve">
          <source>After editing the p4 change message, &lt;code&gt;git p4&lt;/code&gt; makes sure that the description really was changed by looking at the file modification time. This option disables that test.</source>
          <target state="translated">p4 변경 메시지를 편집 한 후 &lt;code&gt;git p4&lt;/code&gt; 는 파일 수정 시간을보고 설명이 실제로 변경되었는지 확인합니다. 이 옵션은 해당 테스트를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="efcca15ec51efe3416c95ceb171efbcf6537ffe0" translate="yes" xml:space="preserve">
          <source>After examining those changes, Alice could merge the changes into her master branch:</source>
          <target state="translated">이러한 변경 사항을 검토 한 후 Alice는 변경 사항을 마스터 지점으로 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6432877f7b94f7bff8d7c5100d32a9aa8ff2a2de" translate="yes" xml:space="preserve">
          <source>After fast-import terminates the frontend will need to do &lt;code&gt;rm .git/TAG_FIXUP&lt;/code&gt; to remove the dummy branch.</source>
          <target state="translated">빠른 가져 오기가 종료 된 후 프론트 엔드는 더미 분기를 제거 하기 위해 &lt;code&gt;rm .git/TAG_FIXUP&lt;/code&gt; 을 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7ccac6fd0d710a221bb8914388317ad9efd2c0ef" translate="yes" xml:space="preserve">
          <source>After finding out a common ancestor commit, the second step is this:</source>
          <target state="translated">공통 조상 커밋을 찾은 후 두 번째 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a0f8226e38e0606c48953eb6013c6b55022869a5" translate="yes" xml:space="preserve">
          <source>After having marked revisions as good or bad, issue the following command to show what has been done so far:</source>
          <target state="translated">개정판을 양호 또는 불량으로 표시 한 후 다음 명령을 실행하여 지금까지 수행 한 작업을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="e71b173e36cfeb3adc5bac23b7ebbe3f932f83d8" translate="yes" xml:space="preserve">
          <source>After importing the stream, you can then run &lt;code&gt;git rev-list foo -- bar.c&lt;/code&gt; in the anonymized repository.</source>
          <target state="translated">스트림을 가져온 후 익명화 된 저장소에서 &lt;code&gt;git rev-list foo -- bar.c&lt;/code&gt; 를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e80bd551ece50cfc5fc850da2031735d0adb9a3e" translate="yes" xml:space="preserve">
          <source>After inspecting the result of the merge, you may find that the change in the other branch is unsatisfactory. Running &lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt; will let you go back to where you were, but it will discard your local changes, which you do not want. &lt;code&gt;git reset --merge&lt;/code&gt; keeps your local changes.</source>
          <target state="translated">병합 결과를 검사 한 후 다른 분기의 변경이 만족스럽지 않을 수 있습니다. &lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt; 를 실행 하면 원래 위치로 돌아갈 수 있지만 원하지 않는 로컬 변경 사항은 무시됩니다. &lt;code&gt;git reset --merge&lt;/code&gt; 는 로컬 변경 사항을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="6ff21b83188a31a6207ce191dc61f50a691f861b" translate="yes" xml:space="preserve">
          <source>After inspecting what Bob did, if there is nothing urgent, Alice may decide to continue working without pulling from Bob. If Bob&amp;rsquo;s history does have something Alice would immediately need, Alice may choose to stash her work-in-progress first, do a &quot;pull&quot;, and then finally unstash her work-in-progress on top of the resulting history.</source>
          <target state="translated">밥이 한 일을 조사한 후 급한 일이 없으면 앨리스는 밥을 빼지 않고 계속 일하기로 결정할 수 있습니다. Bob의 기록에 Alice가 즉시 필요한 것을 가지고 있다면 Alice는 먼저 진행중인 작업을 숨기고 &quot;풀 (Pull)&quot;을 수행 한 다음 결과 기록 위에 진행중인 작업을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03d5abbf7626dec9ccf7afab1dc07b8795265376" translate="yes" xml:space="preserve">
          <source>After making the selection, answer with an empty line to stage the contents of working tree files for selected paths in the index.</source>
          <target state="translated">선택한 후에는 빈 줄로 응답하여 색인에서 선택한 경로에 대한 작업 트리 파일의 내용을 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="dcd3f26f69bbd1d1c0b392e2f4a4b9463da76a66" translate="yes" xml:space="preserve">
          <source>After packing, if the newly created packs make some existing packs redundant, remove the redundant packs. Also run &lt;code&gt;git prune-packed&lt;/code&gt; to remove redundant loose object files.</source>
          <target state="translated">포장 후, 새로 작성된 팩이 기존의 일부 팩을 중복으로 만드는 경우 중복 팩을 제거하십시오. 또한 &lt;code&gt;git prune-packed&lt;/code&gt; 느슨한 객체 파일을 제거하기 위해 정리 된 git을 실행 하십시오.</target>
        </trans-unit>
        <trans-unit id="6310edfcb7521ec31d9b130cb6ae6f20fea23aff" translate="yes" xml:space="preserve">
          <source>After performing a merge, the original file with conflict markers can be saved as a file with a &lt;code&gt;.orig&lt;/code&gt; extension. If this variable is set to &lt;code&gt;false&lt;/code&gt; then this file is not preserved. Defaults to &lt;code&gt;true&lt;/code&gt; (i.e. keep the backup files).</source>
          <target state="translated">병합을 수행 한 후 충돌 표식이있는 원본 파일을 확장자 가 &lt;code&gt;.orig&lt;/code&gt; 인 파일로 저장할 수 있습니다 . 이 변수가 &lt;code&gt;false&lt;/code&gt; 로 설정되면이 파일이 유지되지 않습니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다 (예 : 백업 파일 유지).</target>
        </trans-unit>
        <trans-unit id="df243e176ddfa0cca8db617f9402400e5f7c60ba" translate="yes" xml:space="preserve">
          <source>After pushing your work to &lt;code&gt;mytree&lt;/code&gt;, you can use &lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull[1]&lt;/a&gt; to prepare a &quot;please pull&quot; request message to send to Linus:</source>
          <target state="translated">작업을 &lt;code&gt;mytree&lt;/code&gt; 로 푸시 한 후 &lt;a href=&quot;git-request-pull&quot;&gt;git-request-pull [1]&lt;/a&gt; 을 사용하여 Linus에 보낼 &quot;Please pull&quot;요청 메시지를 준비 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b7b502730a3874da935b609ad110273aca4a8d0" translate="yes" xml:space="preserve">
          <source>After receiving the capability advertisement, a client can then issue a request to select the command it wants with any particular capabilities or arguments. There is then an optional section where the client can provide any command specific parameters or queries. Only a single command can be requested at a time.</source>
          <target state="translated">기능 알림을 수신 한 후 클라이언트는 특정 기능이나 인수로 원하는 명령을 선택하라는 요청을 발행 할 수 있습니다. 그러면 클라이언트가 명령 별 매개 변수 또는 조회를 제공 할 수있는 선택적 섹션이 있습니다. 한 번에 하나의 명령 만 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d906effb7cd99af8f81c132d80d9dfe4320f7472" translate="yes" xml:space="preserve">
          <source>After receiving the pack from the client, &lt;code&gt;receive-pack&lt;/code&gt; may produce no output (if &lt;code&gt;--quiet&lt;/code&gt; was specified) while processing the pack, causing some networks to drop the TCP connection. With this option set, if &lt;code&gt;receive-pack&lt;/code&gt; does not transmit any data in this phase for &lt;code&gt;receive.keepAlive&lt;/code&gt; seconds, it will send a short keepalive packet. The default is 5 seconds; set to 0 to disable keepalives entirely.</source>
          <target state="translated">클라이언트에서 팩을받은 후 팩 을 처리하는 동안 &lt;code&gt;receive-pack&lt;/code&gt; 이 출력을 생성하지 않을 수 있으며 ( &lt;code&gt;--quiet&lt;/code&gt; 이 지정된 경우) 일부 네트워크에서 TCP 연결이 끊어 질 수 있습니다. 이 옵션을 설정하면 &lt;code&gt;receive-pack&lt;/code&gt; 이 &lt;code&gt;receive.keepAlive&lt;/code&gt; 초 동안 이 단계에서 데이터를 전송하지 않으면 짧은 keepalive 패킷을 전송합니다. 기본값은 5 초입니다. Keepalives를 완전히 비활성화하려면 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0db356d4df77c5c16acb15ad22a97c7ea6f2c6df" translate="yes" xml:space="preserve">
          <source>After resolving conflicts and staging the result, &lt;code&gt;git ls-files -u&lt;/code&gt; would stop mentioning the conflicted path. When you are done, run &lt;code&gt;git commit&lt;/code&gt; to finally record the merge:</source>
          <target state="translated">충돌을 해결하고 결과를 &lt;code&gt;git ls-files -u&lt;/code&gt; 후 git ls-files -u 는 충돌 경로 언급을 중단합니다. 완료되면 &lt;code&gt;git commit&lt;/code&gt; 을 실행 하여 마지막으로 병합을 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="8c30281e1be411a0e33e0f09c24d7eee56dd1d4d" translate="yes" xml:space="preserve">
          <source>After resolving the conflict in the obvious way (but before updating the index), the diff will look like:</source>
          <target state="translated">명백한 방식으로 (하지만 색인을 업데이트하기 전에) 충돌을 해결 한 후 diff는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="60011229c2b6e9f4d0205ce31a17f85a92fcdccf" translate="yes" xml:space="preserve">
          <source>After resolving the conflict manually and updating the index with the desired resolution, you can continue the rebasing process with</source>
          <target state="translated">충돌을 수동으로 해결하고 원하는 해결 방법으로 색인을 업데이트 한 후</target>
        </trans-unit>
        <trans-unit id="4f17f667d528a937d15361797e46f1a4fea1bdf2" translate="yes" xml:space="preserve">
          <source>After rewinding, the commit structure should look like this:</source>
          <target state="translated">되감기 후, 커밋 구조는 다음과 같아야합니다 :</target>
        </trans-unit>
        <trans-unit id="b66a5176477ad671c21413d345a1019b22e18ec7" translate="yes" xml:space="preserve">
          <source>After running &lt;code&gt;git reset &amp;lt;pathspec&amp;gt;&lt;/code&gt; to update the index entry, you can use &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt; to check the contents out of the index to the working tree. Alternatively, using &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt; and specifying a commit with &lt;code&gt;--source&lt;/code&gt;, you can copy the contents of a path out of a commit to the index and to the working tree in one go.</source>
          <target state="translated">&lt;code&gt;git reset &amp;lt;pathspec&amp;gt;&lt;/code&gt; 을 실행 하여 인덱스 항목을 업데이트 한 후 &lt;a href=&quot;git-restore&quot;&gt;git-restore [1]&lt;/a&gt; 을 사용하여 인덱스의 내용을 작업 트리로 확인할 수 있습니다. 또는 &lt;a href=&quot;git-restore&quot;&gt;git-restore [1]을 사용&lt;/a&gt; 하고 &lt;code&gt;--source&lt;/code&gt; 를 사용하여 커밋을 지정하면 커밋 의 경로 내용을 인덱스와 작업 트리에 한 번에 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18afdf4deff269ec9f25d6d6aebe21c179f08972" translate="yes" xml:space="preserve">
          <source>After running this &lt;code&gt;git push&lt;/code&gt; on the &lt;code&gt;satellite&lt;/code&gt; machine, you would ssh into the &lt;code&gt;mothership&lt;/code&gt; and run &lt;code&gt;git merge&lt;/code&gt; there to complete the emulation of &lt;code&gt;git pull&lt;/code&gt; that were run on &lt;code&gt;mothership&lt;/code&gt; to pull changes made on &lt;code&gt;satellite&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;satellite&lt;/code&gt; 머신 에서이 &lt;code&gt;git push&lt;/code&gt; 를 실행 한 후 , &lt;code&gt;mothership&lt;/code&gt; 으로 ssh 하고 &lt;code&gt;git merge&lt;/code&gt; 를 실행하여 &lt;code&gt;mothership&lt;/code&gt; 에서 실행 된 &lt;code&gt;git pull&lt;/code&gt; 에뮬레이션을 완료하여 &lt;code&gt;satellite&lt;/code&gt; 변경 한 내용을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="de248d3c434336170b313b4a606fae76271119ac" translate="yes" xml:space="preserve">
          <source>After seeing a conflict, you can do two things:</source>
          <target state="translated">충돌을 본 후 두 가지 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8a8b60b2d146b020baf249114d8bfb4056df2e3" translate="yes" xml:space="preserve">
          <source>After specifying --relative-marks the paths specified with --import-marks= and --export-marks= are relative to an internal directory in the current repository. In git-fast-import this means that the paths are relative to the .git/info/fast-import directory. However, other importers may use a different location.</source>
          <target state="translated">--relative-marks를 지정한 후 --import-marks = 및 --export-marks =로 지정된 경로는 현재 저장소의 내부 디렉토리를 기준으로합니다. git-fast-import에서 이것은 경로가 .git / info / fast-import 디렉토리에 상대적이라는 것을 의미합니다. 그러나 다른 수입 업체는 다른 위치를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55c65fc108282e758fad76a3e65ea8f48110fd1a" translate="yes" xml:space="preserve">
          <source>After staging changes to many files, you can alter the order the changes are recorded in, by giving pathnames to &lt;code&gt;git commit&lt;/code&gt;. When pathnames are given, the command makes a commit that only records the changes made to the named paths:</source>
          <target state="translated">많은 파일에 대한 변경 사항을 &lt;code&gt;git commit&lt;/code&gt; 경로 이름을 git commit에 지정 하여 변경 사항이 기록되는 순서를 변경할 수 있습니다 . 경로명이 지정되면 명령은 이름 지정된 경로에 대한 변경 사항 만 기록하는 커미트를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="e72be6c76fa86af29190b1a1f88fe08f999420ad" translate="yes" xml:space="preserve">
          <source>After step 7) (in the skip algorithm), we could check if the second commit has been skipped and return it if it is not the case. And in fact that was the algorithm we used from when &quot;git bisect skip&quot; was developed in Git version 1.5.4 (released on February 1st 2008) until Git version 1.6.4 (released July 29th 2009).</source>
          <target state="translated">7) 단계 (스킵 알고리즘에서) 후에, 우리는 두 번째 커밋이 스킵되었는지 확인하고 그렇지 않은 경우 리턴합니다. 사실 이것은 &quot;git bisect skip&quot;이 Git 버전 1.5.4 (2008 년 2 월 1 일 릴리스)에서 개발 될 때부터 Git 버전 1.6.4 (2009 년 7 월 29 일 릴리스)까지 사용 된 알고리즘이었습니다.</target>
        </trans-unit>
        <trans-unit id="8ebae7c6dbdbd052d8e1deddf2741dfd39e2c5b6" translate="yes" xml:space="preserve">
          <source>After submitting, sync this named branch instead of the default p4/master. See the &quot;Sync options&quot; section above for more information.</source>
          <target state="translated">제출 후 기본 p4 / 마스터 대신이 명명 된 분기를 동기화하십시오. 자세한 내용은 위의 &quot;동기화 옵션&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="56b0b049063f0a3e5fb48dd65396ec13b42da44e" translate="yes" xml:space="preserve">
          <source>After that is done, you should be able to compose email as you otherwise would (cut + paste, &lt;code&gt;git format-patch&lt;/code&gt; | &lt;code&gt;git imap-send&lt;/code&gt;, etc), and the patches will not be mangled.</source>
          <target state="translated">그 후에는 다른 방법으로 이메일을 작성할 수 있어야하며 (cut + paste, &lt;code&gt;git format-patch&lt;/code&gt; | &lt;code&gt;git imap-send&lt;/code&gt; 등) 패치는 엉망이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bfac36870999dd7fd482f2000fa5fc0ffd3ce594" translate="yes" xml:space="preserve">
          <source>After that you can start bisecting as usual in the new branch and you should eventually find the first bad commit.</source>
          <target state="translated">그 후 새 브랜치에서 평소와 같이 bisecting을 시작할 수 있으며 결국 첫 번째 잘못된 커밋을 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="35f073b8aaf7a7d573c425aa250957facb3adf5b" translate="yes" xml:space="preserve">
          <source>After that, the easiest way to record all removals, additions, and modifications in the working tree is:</source>
          <target state="translated">그런 다음 작업 트리에서 모든 제거, 추가 및 수정 사항을 기록하는 가장 쉬운 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37ec20c881539f18de6028bfbfa7896bacec3155" translate="yes" xml:space="preserve">
          <source>After that, you can go back to what you were working on with &lt;code&gt;git stash pop&lt;/code&gt;:</source>
          <target state="translated">그 후 &lt;code&gt;git stash pop&lt;/code&gt; 으로 작업하고 있던 작업으로 돌아갈 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a18484e36aeec06b4dafe8bfc4dc2214df9ad775" translate="yes" xml:space="preserve">
          <source>After the basics are established, additional command information can be sent to Trace2 as it is discovered.</source>
          <target state="translated">기본 사항이 설정되면 추가 명령 정보가 발견 될 때 Trace2로 전송 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e00cd4b44746238e1913ce6a929735926105a52" translate="yes" xml:space="preserve">
          <source>After the clone is created, initialize and clone submodules within based on the provided pathspec. If no pathspec is provided, all submodules are initialized and cloned. This option can be given multiple times for pathspecs consisting of multiple entries. The resulting clone has &lt;code&gt;submodule.active&lt;/code&gt; set to the provided pathspec, or &quot;.&quot; (meaning all submodules) if no pathspec is provided.</source>
          <target state="translated">클론이 생성 된 후 제공된 경로 사양에 따라 서브 모듈을 초기화하고 복제합니다. pathspec을 제공하지 않으면 모든 하위 모듈이 초기화되고 복제됩니다. 이 옵션은 여러 항목으로 구성된 경로 스펙에 여러 번 제공 될 수 있습니다. 결과 클론에는 &lt;code&gt;submodule.active&lt;/code&gt; 가 제공된 pathspec 또는 &quot;.&quot;으로 설정되어 있습니다. pathspec이 제공되지 않은 경우 (모든 하위 모듈을 의미)</target>
        </trans-unit>
        <trans-unit id="512c768beb6f564041f676bad06ef4ee2a1c558f" translate="yes" xml:space="preserve">
          <source>After the clone, a plain &lt;code&gt;git fetch&lt;/code&gt; without arguments will update all the remote-tracking branches, and a &lt;code&gt;git pull&lt;/code&gt; without arguments will in addition merge the remote master branch into the current master branch, if any (this is untrue when &quot;--single-branch&quot; is given; see below).</source>
          <target state="translated">복제 후 인수가없는 일반 &lt;code&gt;git fetch&lt;/code&gt; 는 모든 원격 추적 분기를 업데이트하고 인수가없는 &lt;code&gt;git pull&lt;/code&gt; 은 원격 마스터 분기를 현재 마스터 분기에 병합합니다 (있는 경우 &quot;-단일 경우에 해당하지 않음). -분기 &quot;가 제공됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="5cd7d7a65c5ebccd7e68c5c66967ea09b43d6139" translate="yes" xml:space="preserve">
          <source>After the last section, you should know how to manage topics. In general, you will not be the only person working on the project, so you will have to share your work.</source>
          <target state="translated">마지막 섹션 이후에는 주제를 관리하는 방법을 알아야합니다. 일반적으로 프로젝트를 진행하는 유일한 사람은 아니므로 작업을 공유해야합니다.</target>
        </trans-unit>
        <trans-unit id="d4845263a9667982d51c2722039eed2001af73b3" translate="yes" xml:space="preserve">
          <source>After this test merge, there are two ways to continue your work on the topic. The easiest is to build on top of the test merge commit &lt;code&gt;+&lt;/code&gt;, and when your work in the topic branch is finally ready, pull the topic branch into master, and/or ask the upstream to pull from you. By that time, however, the master or the upstream might have been advanced since the test merge &lt;code&gt;+&lt;/code&gt;, in which case the final commit graph would look like this:</source>
          <target state="translated">이 테스트 병합 후에는 주제에 대한 작업을 계속하는 두 가지 방법이 있습니다. 가장 쉬운 방법은 테스트 병합 커밋 &lt;code&gt;+&lt;/code&gt; 위에 구축하는 것입니다. 그리고 토픽 브랜치에서 작업이 준비되면 토픽 브랜치를 마스터로 가져 오거나 업스트림에서 가져 오도록 요청하십시오. 그러나 그때까지 마스터 또는 업스트림은 테스트 merge &lt;code&gt;+&lt;/code&gt; 이후에 진행되었을 수 있습니다.이 경우 최종 커밋 그래프는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="764e78b04901ecf447ad9f08fb14a4d7a3784873" translate="yes" xml:space="preserve">
          <source>After this three-way merge, the local modifications are &lt;code&gt;not&lt;/code&gt; registered in your index file, so &lt;code&gt;git diff&lt;/code&gt; would show you what changes you made since the tip of the new branch.</source>
          <target state="translated">이 세 가지 방법으로 병합 한 후에는 로컬 수정 내용이 인덱스 파일에 등록 &lt;code&gt;not&lt;/code&gt; 않으므로 &lt;code&gt;git diff&lt;/code&gt; 는 새 브랜치 끝 이후에 변경된 내용을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9aab9481201d40d0fe77311ee6889968b015c0cc" translate="yes" xml:space="preserve">
          <source>After verifying the pack, show list of objects contained in the pack and a histogram of delta chain length.</source>
          <target state="translated">팩을 확인한 후 팩에 포함 된 개체 목록과 델타 체인 길이의 히스토그램을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="9b8cdc248305abd7fd3ad025c5cea93360a62f47" translate="yes" xml:space="preserve">
          <source>After working in the wrong branch, switching to the correct branch would be done using:</source>
          <target state="translated">잘못된 지점에서 작업 한 후 다음을 사용하여 올바른 지점으로 전환합니다.</target>
        </trans-unit>
        <trans-unit id="eb228e2496a61023caca1aea4a6e82c2396eddae" translate="yes" xml:space="preserve">
          <source>After working on the &lt;code&gt;topic&lt;/code&gt; branch created with &lt;code&gt;git switch -c
topic origin/master&lt;/code&gt;, the history of remote-tracking branch &lt;code&gt;origin/master&lt;/code&gt; may have been rewound and rebuilt, leading to a history of this shape:</source>
          <target state="translated">&lt;code&gt;git switch -c topic origin/master&lt;/code&gt; 작성된 &lt;code&gt;topic&lt;/code&gt; 브랜치를 작업 한 후 , 원격 추적 브랜치 &lt;code&gt;origin/master&lt;/code&gt; 의 히스토리가 되감기 및 재 빌드되어 다음과 같은 형태의 히스토리가 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c12d864e4ce5bf45abb0028f5de0df25bacff49" translate="yes" xml:space="preserve">
          <source>After working some more in the original repository, you can create an incremental bundle to update the other repository:</source>
          <target state="translated">원래 저장소에서 더 많은 작업을 수행 한 후 다른 저장소를 업데이트하기 위해 증분 번들을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c5cdbcbfaa82437e4a65c5f716c041276984b11" translate="yes" xml:space="preserve">
          <source>After writing a crash report fast-import will close the current packfile and export the marks table. This allows the frontend developer to inspect the repository state and resume the import from the point where it crashed. The modified branches and tags are not updated during a crash, as the import did not complete successfully. Branch and tag information can be found in the crash report and must be applied manually if the update is needed.</source>
          <target state="translated">충돌 보고서를 작성한 후 빠른 가져 오기는 현재 팩 파일을 닫고 마크 테이블을 내 보냅니다. 이를 통해 프론트 엔드 개발자는 저장소 상태를 점검하고 충돌이 발생한 지점에서 가져 오기를 재개 할 수 있습니다. 가져 오기가 성공적으로 완료되지 않아 수정 된 분기 및 태그가 충돌 중에 업데이트되지 않습니다. 분기 및 태그 정보는 충돌 보고서에서 찾을 수 있으며 업데이트가 필요한 경우 수동으로 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5c0e0972bba351246b0cebcda509c3b6e9fe7def" translate="yes" xml:space="preserve">
          <source>After you clone a repository and commit a few changes of your own, you may wish to check the original repository for updates and merge them into your own work.</source>
          <target state="translated">저장소를 복제하고 몇 가지 변경 사항을 커미트 한 후 원래 저장소에 업데이트가 있는지 확인하고이를 자신의 작업에 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11b2964f5fca0a040b3f9e0cd2999fe0e6cf0437" translate="yes" xml:space="preserve">
          <source>After you clone a repository and commit a few changes of your own, you may wish to check the original repository for updates.</source>
          <target state="translated">리포지토리를 복제하고 일부 변경 내용을 커밋 한 후 원래 리포지토리에서 업데이트를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c1b426ddf419243558839a9a55a74c0218324ad" translate="yes" xml:space="preserve">
          <source>After you mastered the basic concepts, you can come back to this page to learn what commands Git offers. You can learn more about individual Git commands with &quot;git help command&quot;. &lt;a href=&quot;gitcli&quot;&gt;gitcli[7]&lt;/a&gt; manual page gives you an overview of the command-line command syntax.</source>
          <target state="translated">기본 개념을 익힌 후이 페이지로 돌아와서 Git이 제공하는 명령을 배울 수 있습니다. &quot;git help command&quot;를 사용하여 개별 Git 명령에 대해 더 배울 수 있습니다. &lt;a href=&quot;gitcli&quot;&gt;gitcli [7]&lt;/a&gt; 매뉴얼 페이지는 명령 행 명령 구문에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b3cf4e045979c169751c6df0015d31c55a03d7ee" translate="yes" xml:space="preserve">
          <source>After you&amp;rsquo;re done, start up &lt;code&gt;gitk --all&lt;/code&gt; to see graphically what the history looks like. Notice that &lt;code&gt;mybranch&lt;/code&gt; still exists, and you can switch to it, and continue to work with it if you want to. The &lt;code&gt;mybranch&lt;/code&gt; branch will not contain the merge, but next time you merge it from the &lt;code&gt;master&lt;/code&gt; branch, Git will know how you merged it, so you&amp;rsquo;ll not have to do &lt;code&gt;that&lt;/code&gt; merge again.</source>
          <target state="translated">작업이 끝나면 &lt;code&gt;gitk --all&lt;/code&gt; 을 시작 하여 역사가 어떻게 보이는지 그래픽으로 볼 수 있습니다. 공지 사항 것을 &lt;code&gt;mybranch&lt;/code&gt; 로는 여전히 존재하며, 당신은 그것을로 전환, 당신이 원하는 경우로 작동 할 수 있습니다. &lt;code&gt;mybranch&lt;/code&gt; 로의 분기 병합 포함되지 않습니다,하지만 당신은에서 병합 다음 번에 &lt;code&gt;master&lt;/code&gt; 당신이 그것을 통합하는 방법을 당신이 할 필요가 없습니다 것입니다, 그래서 분기, 힘내, 알 &lt;code&gt;that&lt;/code&gt; 다시 병합.</target>
        </trans-unit>
        <trans-unit id="c0a021ce8c26fc96dbae55d24cd95f42b33ecba6" translate="yes" xml:space="preserve">
          <source>Afterwards Git sends a list of &quot;key=value&quot; pairs terminated with a flush packet. The list will contain at least the filter command (based on the supported capabilities) and the pathname of the file to filter relative to the repository root. Right after the flush packet Git sends the content split in zero or more pkt-line packets and a flush packet to terminate content. Please note, that the filter must not send any response before it received the content and the final flush packet. Also note that the &quot;value&quot; of a &quot;key=value&quot; pair can contain the &quot;=&quot; character whereas the key would never contain that character.</source>
          <target state="translated">이후 Git은 플러시 패킷으로 종료 된 &quot;key = value&quot;쌍의 목록을 보냅니다. 이 목록에는 최소한 필터 명령 (지원되는 기능에 따라)과 저장소 루트를 기준으로 필터링 할 파일의 경로 이름이 포함됩니다. 플러시 패킷 Git 직후에 콘텐츠 분할은 0 개 이상의 pkt-line 패킷과 플러시 패킷으로 콘텐츠 분할을 전송하여 콘텐츠를 종료합니다. 필터는 내용과 최종 플러시 패킷을 받기 전에 응답을 보내지 않아야합니다. 또한 &quot;key = value&quot;쌍의 &quot;value&quot;에는 &quot;=&quot;문자가 포함될 수 있지만 키에는 해당 문자가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08fb4f0b833d93afae381ddbd32b2e731f88bbea" translate="yes" xml:space="preserve">
          <source>Again, because this is a common operation, you can also just shorthand it with</source>
          <target state="translated">다시 말하지만, 이것은 일반적인 작업이기 때문에</target>
        </trans-unit>
        <trans-unit id="2a17673033ec7dbc230aa6a7992e711b3fbc3d4a" translate="yes" xml:space="preserve">
          <source>Again, normally you&amp;rsquo;d never actually do this by hand. There is a helpful script called &lt;code&gt;git commit&lt;/code&gt; that will do all of this for you. So you could have just written &lt;code&gt;git commit&lt;/code&gt; instead, and it would have done the above magic scripting for you.</source>
          <target state="translated">다시 말하지만 일반적으로 실제로는 손으로이 작업을 수행하지 않습니다. &lt;code&gt;git commit&lt;/code&gt; 이라는 유용한 스크립트 가 있습니다. 그래서 당신은 대신 &lt;code&gt;git commit&lt;/code&gt; 을 쓸 수 있었고 , 위의 마술 스크립트를 수행했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="afde498ff4cd811d74693c0df59474ecda94165e" translate="yes" xml:space="preserve">
          <source>Again, this can all be simplified with</source>
          <target state="translated">다시 말하지만, 이것으로 모두 단순화 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b9b1fee6e50d3dc98fed5593a8e8c0ed94635339" translate="yes" xml:space="preserve">
          <source>Again, updating A with this commit will fast-forward and your push will be accepted.</source>
          <target state="translated">이 커밋으로 A를 업데이트하면 빨리 진행되고 푸시가 수락됩니다.</target>
        </trans-unit>
        <trans-unit id="b1bfbc3378c5615b3a3120f32e2b4f7a040c60bb" translate="yes" xml:space="preserve">
          <source>Again, you should never do this to a commit that may already have been merged into another branch; use &lt;a href=&quot;git-revert&quot;&gt;git-revert[1]&lt;/a&gt; instead in that case.</source>
          <target state="translated">다시 말하지만, 이미 다른 브랜치에 병합되었을 수있는 커밋에는이 작업을 수행해서는 안됩니다. 사용 &lt;a href=&quot;git-revert&quot;&gt;자식-되돌리기 [1]를&lt;/a&gt; 대신하는 경우.</target>
        </trans-unit>
        <trans-unit id="4ad4cd921bb660f6346bf34bcf03d35af1d89b1f" translate="yes" xml:space="preserve">
          <source>Aggregating short options</source>
          <target state="translated">짧은 옵션 집계</target>
        </trans-unit>
        <trans-unit id="b46eb2e49d59fe40f45432cfc2d93b9f3ec1b6f6" translate="yes" xml:space="preserve">
          <source>Aggressive</source>
          <target state="translated">Aggressive</target>
        </trans-unit>
        <trans-unit id="02f02485ab679a9031f461bdbd3edab48ea42a79" translate="yes" xml:space="preserve">
          <source>Algorithm</source>
          <target state="translated">Algorithm</target>
        </trans-unit>
        <trans-unit id="f18c0f421eb67bfb50f4d3af9083503fd4868a13" translate="yes" xml:space="preserve">
          <source>Alias for &lt;code&gt;--subject-prefix=&quot;RFC PATCH&quot;&lt;/code&gt;. RFC means &quot;Request For Comments&quot;; use this when sending an experimental patch for discussion rather than application.</source>
          <target state="translated">&lt;code&gt;--subject-prefix=&quot;RFC PATCH&quot;&lt;/code&gt; 의 별칭입니다 . RFC는 &quot;의견 요청&quot;을 의미합니다. 응용 프로그램이 아닌 실험용 패치를 보낼 때 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="33cafd3b08f6afce156de29f77fc37a32f1f3369" translate="yes" xml:space="preserve">
          <source>Alias for a --pretty= format string, as specified in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;. Any aliases defined here can be used just as the built-in pretty formats could. For example, running &lt;code&gt;git config pretty.changelog &quot;format:* %H %s&quot;&lt;/code&gt; would cause the invocation &lt;code&gt;git log --pretty=changelog&lt;/code&gt; to be equivalent to running &lt;code&gt;git log &quot;--pretty=format:* %H %s&quot;&lt;/code&gt;. Note that an alias with the same name as a built-in format will be silently ignored.</source>
          <target state="translated">&lt;a href=&quot;git-log&quot;&gt;git-log [1]에&lt;/a&gt; 지정된 --pretty = 형식 문자열의 별칭입니다 . 여기에 정의 된 모든 별칭은 내장 된 예쁜 형식과 마찬가지로 사용할 수 있습니다. 예를 들어, &lt;code&gt;git config pretty.changelog &quot;format:* %H %s&quot;&lt;/code&gt; 를 실행 하면 호출 &lt;code&gt;git log --pretty=changelog&lt;/code&gt; 가 &lt;code&gt;git log &quot;--pretty=format:* %H %s&quot;&lt;/code&gt; 를 실행하는 것과 같습니다 . 내장 형식과 이름이 같은 별명은 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5d1b325e842f25a822c4b269ff141ef39919c475" translate="yes" xml:space="preserve">
          <source>Alice can peek at what Bob did without merging first, using the &quot;fetch&quot; command; this allows Alice to inspect what Bob did, using a special symbol &quot;FETCH_HEAD&quot;, in order to determine if he has anything worth pulling, like this:</source>
          <target state="translated">Alice는 &quot;fetch&quot;명령을 사용하여 Bob이 먼저 병합하지 않은 것을 엿볼 수 있습니다. 이렇게하면 Alice가 특수 기호 &quot;FETCH_HEAD&quot;를 사용하여 Bob이 수행 한 작업을 검사하여 다음과 같이 잡아 당길만한 것이 있는지 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e66fd3894cd9fabc7340a32ad3678d949571b95" translate="yes" xml:space="preserve">
          <source>Alice may want to view what both of them did since they forked. She can use three-dot form instead of the two-dot form:</source>
          <target state="translated">앨리스는 포크 이후에 두 사람이 무엇을했는지보고 싶을 수도 있습니다. 그녀는 2 도트 형식 대신 3 도트 형식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f40eaaa16860011566dbddc8353ce4cd5b34fb54" translate="yes" xml:space="preserve">
          <source>All 4-byte numbers are in network order.</source>
          <target state="translated">모든 4 바이트 숫자는 네트워크 순서입니다.</target>
        </trans-unit>
        <trans-unit id="099269695c58af639142bdae5a91d1e49c0c2c94" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;CGI&lt;/code&gt; environment variables are available to each of the hooks invoked by the &lt;code&gt;git-receive-pack&lt;/code&gt;.</source>
          <target state="translated">모든 &lt;code&gt;CGI&lt;/code&gt; 환경 변수는 &lt;code&gt;git-receive-pack&lt;/code&gt; 에 의해 호출 된 각 후크에 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="f866a82b5ea8dc3929c4ad04564d5c3ed0ee42d8" translate="yes" xml:space="preserve">
          <source>All Trace2 API functions send a message to all of the active Trace2 Targets. This section describes the set of available messages.</source>
          <target state="translated">모든 Trace2 API 함수는 모든 활성 Trace2 대상에 메시지를 보냅니다. 이 섹션에서는 사용 가능한 메시지 세트에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8567b1f7f97dea5e233c49b40ba1a9668558e4c8" translate="yes" xml:space="preserve">
          <source>All URLs are normalized before attempting any matching (the password part, if embedded in the URL, is always ignored for matching purposes) so that equivalent URLs that are simply spelled differently will match properly. Environment variable settings always override any matches. The URLs that are matched against are those given directly to Git commands. This means any URLs visited as a result of a redirection do not participate in matching.</source>
          <target state="translated">모든 URL은 일치를 시도하기 전에 정규화되므로 (URL에 포함 된 경우 비밀번호 부분은 항상 일치 목적으로 무시 됨) 단순히 철자가 동일한 동등한 URL이 올바르게 일치합니다. 환경 변수 설정은 항상 일치 항목보다 우선합니다. 일치하는 URL은 Git 명령에 직접 제공된 URL입니다. 이는 리디렉션의 결과로 방문한 URL이 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05f6595fa2f42cca20a6fe38ba56a9a1d90610fc" translate="yes" xml:space="preserve">
          <source>All actions except for those that list all available projects, in whatever form, require this parameter.</source>
          <target state="translated">사용 가능한 모든 프로젝트를 나열하는 작업을 제외한 모든 작업에는이 매개 변수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bd0edf3d9b439beeaf5e567024d22155e2273f60" translate="yes" xml:space="preserve">
          <source>All changes already added to the index are left intact.</source>
          <target state="translated">인덱스에 이미 추가 된 모든 변경 사항은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="1aaff790885e322791dd026d468d21215c97d5ed" translate="yes" xml:space="preserve">
          <source>All changes in the split index are pushed back to the shared index file when the number of entries in the split index reaches a level specified by the splitIndex.maxPercentChange config variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">분할 인덱스의 항목 수가 splitIndex.maxPercentChange 구성 변수 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 참조)에 지정된 수준에 도달하면 분할 인덱스의 모든 변경 사항이 공유 인덱스 파일로 다시 푸시됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ee4593d03a3fe3f61740d3dea48d16adb304aaa" translate="yes" xml:space="preserve">
          <source>All changes made by commits in the current branch but that are not in &amp;lt;upstream&amp;gt; are saved to a temporary area. This is the same set of commits that would be shown by &lt;code&gt;git log &amp;lt;upstream&amp;gt;..HEAD&lt;/code&gt;; or by &lt;code&gt;git log 'fork_point'..HEAD&lt;/code&gt;, if &lt;code&gt;--fork-point&lt;/code&gt; is active (see the description on &lt;code&gt;--fork-point&lt;/code&gt; below); or by &lt;code&gt;git log HEAD&lt;/code&gt;, if the &lt;code&gt;--root&lt;/code&gt; option is specified.</source>
          <target state="translated">현재 브랜치에서 커밋에 의해 변경되었지만 &amp;lt;업스트림&amp;gt;에없는 모든 변경 사항은 임시 영역에 저장됩니다. 이것은 &lt;code&gt;git log &amp;lt;upstream&amp;gt;..HEAD&lt;/code&gt; 로 보여지는 것과 동일한 커밋 세트입니다 . &lt;code&gt;--fork-point&lt;/code&gt; 가 활성화 된 경우 &lt;code&gt;git log 'fork_point'..HEAD&lt;/code&gt; 에 의해 ( 아래 &lt;code&gt;--fork-point&lt;/code&gt; 에 대한 설명 참조); &lt;code&gt;--root&lt;/code&gt; 옵션이 지정된 경우 &lt;code&gt;git log HEAD&lt;/code&gt; 에 의해 .</target>
        </trans-unit>
        <trans-unit id="4bdf69f9f9acea0027f5883fae412fef01ef415d" translate="yes" xml:space="preserve">
          <source>All changes to the submodule&amp;rsquo;s work tree will be ignored, only committed differences between the HEAD of the submodule and its recorded state in the superproject are taken into account.</source>
          <target state="translated">서브 모듈의 작업 트리에 대한 모든 변경 사항은 무시되며 서브 모듈의 HEAD와 수퍼 프로젝트에서 기록 된 상태 사이의 확약 된 차이 만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="0078bf2eb8fdaed52c7a49142c07f612f6194ca3" translate="yes" xml:space="preserve">
          <source>All commands except clone accept these options.</source>
          <target state="translated">clone을 제외한 모든 명령은이 옵션을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="747ced70d2f3d8a9f580e20c513a115bf4ca8d06" translate="yes" xml:space="preserve">
          <source>All commits in the simplified history are shown.</source>
          <target state="translated">단순화 된 히스토리의 모든 커밋이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b7857a43f974cc0cc16fc43991167acda1bdb92d" translate="yes" xml:space="preserve">
          <source>All commits that are walked are included.</source>
          <target state="translated">걸었던 모든 커밋이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d8c8c004ab3e327bb23a0e1cb06bdc4ffe16dbfd" translate="yes" xml:space="preserve">
          <source>All communication is done using packet-line framing, just as in v1. See &lt;code&gt;Documentation/technical/pack-protocol.txt&lt;/code&gt; and &lt;code&gt;Documentation/technical/protocol-common.txt&lt;/code&gt; for more information.</source>
          <target state="translated">모든 통신은 v1에서와 같이 패킷 라인 프레임을 사용하여 수행됩니다. 자세한 내용은 &lt;code&gt;Documentation/technical/pack-protocol.txt&lt;/code&gt; 및 &lt;code&gt;Documentation/technical/protocol-common.txt&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7c3a301219274de5dd57371abee3ab5a5312cbb7" translate="yes" xml:space="preserve">
          <source>All configuration variables can also be overridden for a specific method of access. Valid method names are &quot;ext&quot; (for SSH access) and &quot;pserver&quot;. The following example configuration would disable pserver access while still allowing access over SSH.</source>
          <target state="translated">특정 액세스 방법에 대해 모든 구성 변수를 재정의 할 수도 있습니다. 유효한 메소드 이름은 &quot;ext&quot;(SSH 액세스의 경우) 및 &quot;pserver&quot;입니다. 다음 예제 구성은 SSH를 통한 액세스를 허용하면서 pserver 액세스를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="59ca4fe2d0fe1a800f4976e6f9f37c5b67ee4941" translate="yes" xml:space="preserve">
          <source>All files from the branching point are added to a branch even if never added in CVS.</source>
          <target state="translated">분기점의 모든 파일은 CVS에 추가되지 않은 경우에도 분기에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f2751ce2c6eef82a246aaca1478ee0944abee964" translate="yes" xml:space="preserve">
          <source>All files matching a file extension in the list will be processed by the large file system. Do not prefix the extensions with &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">목록에서 파일 확장자와 일치하는 모든 파일은 큰 파일 시스템에서 처리됩니다. 확장자 앞에 접두사를 붙이지 마십시오 &lt;code&gt;.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9eed6a91320d25f6961ad95b2f4c0551182ac97" translate="yes" xml:space="preserve">
          <source>All files with a compressed size exceeding the threshold will be processed by the large file system. This option might slow down your clone/sync process. By default the threshold is defined in bytes. Add the suffix k, m, or g to change the unit.</source>
          <target state="translated">압축 파일 크기가 임계 값을 초과하는 모든 파일은 큰 파일 시스템에서 처리됩니다. 이 옵션은 복제 / 동기화 프로세스를 느리게 할 수 있습니다. 기본적으로 임계 값은 바이트로 정의됩니다. 단위를 변경하려면 접미사 k, m 또는 g를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="cba8238b26241037a2d523c9dbfd57c6ef21fd9c" translate="yes" xml:space="preserve">
          <source>All files with an uncompressed size exceeding the threshold will be processed by the large file system. By default the threshold is defined in bytes. Add the suffix k, m, or g to change the unit.</source>
          <target state="translated">압축되지 않은 크기의 임계 값을 초과하는 모든 파일은 큰 파일 시스템에서 처리됩니다. 기본적으로 임계 값은 바이트로 정의됩니다. 단위를 변경하려면 접미사 k, m 또는 g를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="5faba2ec0a1d011ac70519fe6631987cdc41a2b9" translate="yes" xml:space="preserve">
          <source>All gitcvs variables except for &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; and &lt;code&gt;gitcvs.allBinary&lt;/code&gt; can also be specified as &lt;code&gt;gitcvs.&amp;lt;access_method&amp;gt;.&amp;lt;varname&amp;gt;&lt;/code&gt; (where &lt;code&gt;access_method&lt;/code&gt; is one of &quot;ext&quot; and &quot;pserver&quot;) to make them apply only for the given access method.</source>
          <target state="translated">&lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; 및 &lt;code&gt;gitcvs.allBinary&lt;/code&gt; 를 제외한 모든 gitcvs 변수 는 &lt;code&gt;gitcvs.&amp;lt;access_method&amp;gt;.&amp;lt;varname&amp;gt;&lt;/code&gt; 으로 지정할 수 있습니다 (여기서 &lt;code&gt;access_method&lt;/code&gt; 는 &quot;ext&quot;및 &quot;pserver&quot;중 하나임 ). 지정된 액세스 방법에만 적용됩니다. .</target>
        </trans-unit>
        <trans-unit id="0e525a3897a3668ec85a1e3c0f8de71adbd85c9c" translate="yes" xml:space="preserve">
          <source>All guides...</source>
          <target state="translated">모든 가이드 ...</target>
        </trans-unit>
        <trans-unit id="307b90257cb7faef23bf2daa4065fa0e8e567b0e" translate="yes" xml:space="preserve">
          <source>All ignored and untracked files are also stashed and then cleaned up with &lt;code&gt;git clean&lt;/code&gt;.</source>
          <target state="translated">무시되고 추적되지 않은 모든 파일도 은닉 된 다음 &lt;code&gt;git clean&lt;/code&gt; 으로 정리 됩니다.</target>
        </trans-unit>
        <trans-unit id="e0e3bbc643fcf0e6f476c9a1c5f8183263c2a18a" translate="yes" xml:space="preserve">
          <source>All listed refs are deleted from the remote repository. This is the same as prefixing all refs with a colon.</source>
          <target state="translated">나열된 모든 참조는 원격 저장소에서 삭제됩니다. 이것은 모든 참조 앞에 콜론을 붙이는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a04df7dc83d3748d4d9902845dfe236dbda3335" translate="yes" xml:space="preserve">
          <source>All objects are named by the SHA-1 hash of their contents, normally written as a string of 40 hex digits. Such names are globally unique. The entire history leading up to a commit can be vouched for by signing just that commit. A fourth object type, the tag, is provided for this purpose.</source>
          <target state="translated">모든 객체는 내용의 SHA-1 해시로 이름이 지정되며 일반적으로 40 진수의 문자열로 작성됩니다. 이러한 이름은 전 세계적으로 고유합니다. 커밋으로 이어지는 전체 기록은 해당 커밋에 서명하여 보증 할 수 있습니다. 이를 위해 네 번째 객체 유형 인 태그가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5c22669562d39ab93b88e8b91c6653478eb31b9b" translate="yes" xml:space="preserve">
          <source>All objects have a statically determined &quot;type&quot; which identifies the format of the object (i.e. how it is used, and how it can refer to other objects). There are currently four different object types: &quot;blob&quot;, &quot;tree&quot;, &quot;commit&quot;, and &quot;tag&quot;.</source>
          <target state="translated">모든 객체에는 객체의 형식 (즉, 사용 방법 및 다른 객체를 참조하는 방법)을 식별하는 정적으로 결정된 &quot;유형&quot;이 있습니다. 현재 &quot;blob&quot;, &quot;tree&quot;, &quot;commit&quot;및 &quot;tag&quot;의 네 가지 개체 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="53b47e1baf96b9c8287456e674d706c2d2cb68d3" translate="yes" xml:space="preserve">
          <source>All of the ancestors of a given &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; are said to be &quot;reachable&quot; from that commit. More generally, one &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; is reachable from another if we can reach the one from the other by a &lt;a href=&quot;#def_chain&quot;&gt;chain&lt;/a&gt; that follows &lt;a href=&quot;#def_tag&quot;&gt;tags&lt;/a&gt; to whatever they tag, &lt;a href=&quot;#def_commit_object&quot;&gt;commits&lt;/a&gt; to their parents or trees, and &lt;a href=&quot;#def_tree_object&quot;&gt;trees&lt;/a&gt; to the trees or &lt;a href=&quot;#def_blob_object&quot;&gt;blobs&lt;/a&gt; that they contain.</source>
          <target state="translated">주어진 &lt;a href=&quot;#def_commit&quot;&gt;커밋&lt;/a&gt; 의 모든 조상은 해당 커밋 에서 &quot;도달 가능&quot;하다고합니다. 보다 일반적으로, &lt;a href=&quot;#def_tag&quot;&gt;태그&lt;/a&gt; 에 따라 태그 를 따라가는 부모, 나무 또는 &lt;a href=&quot;#def_commit_object&quot;&gt;커밋&lt;/a&gt; 된 트리 또는 &lt;a href=&quot;#def_blob_object&quot;&gt;얼룩에 &lt;/a&gt;&lt;a href=&quot;#def_tree_object&quot;&gt;트리&lt;/a&gt; 를 &lt;a href=&quot;#def_chain&quot;&gt;연결&lt;/a&gt; 하는 체인 을 통해 다른 &lt;a href=&quot;#def_object&quot;&gt;객체&lt;/a&gt; 에서 다른 객체 에 도달 할 수있는 경우 다른 객체 에서 도달 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c914353521a7fcdc1482a5e3cfa2c2db891768c9" translate="yes" xml:space="preserve">
          <source>All of the changes that Git was able to merge automatically are already added to the index file, so &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; shows only the conflicts. It uses an unusual syntax:</source>
          <target state="translated">Git이 자동으로 병합 할 수있는 모든 변경 사항은 이미 인덱스 파일에 추가되었으므로 &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 은 충돌 만 표시합니다. 특이한 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0851367bef62c00e23b203fa9f1e02fbe0c27531" translate="yes" xml:space="preserve">
          <source>All of the following examples map &lt;code&gt;http://$hostname/git/foo/bar.git&lt;/code&gt; to &lt;code&gt;/var/www/git/foo/bar.git&lt;/code&gt;.</source>
          <target state="translated">다음 예제는 모두 &lt;code&gt;http://$hostname/git/foo/bar.git&lt;/code&gt; 을 &lt;code&gt;/var/www/git/foo/bar.git&lt;/code&gt; 에 맵핑 합니다.</target>
        </trans-unit>
        <trans-unit id="1a148afed6f28c8ecd0df018991ec0db90af85d7" translate="yes" xml:space="preserve">
          <source>All of the rules described above about what&amp;rsquo;s not allowed as an update can be overridden by adding an the optional leading &lt;code&gt;+&lt;/code&gt; to a refspec (or using &lt;code&gt;--force&lt;/code&gt; command line option). The only exception to this is that no amount of forcing will make the &lt;code&gt;refs/heads/*&lt;/code&gt; namespace accept a non-commit object. Hooks and configuration can also override or amend these rules, see e.g. &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; and &lt;code&gt;pre-receive&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; in &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">선택적 선행 &lt;code&gt;+&lt;/code&gt; 를 참조 사양에 추가 하거나 &lt;code&gt;--force&lt;/code&gt; 명령 줄 옵션을 사용하여 업데이트로 허용되지 않는 사항에 대해 위에서 설명한 모든 규칙을 무시할 수 있습니다 . 이것에 대한 유일한 예외는 &lt;code&gt;refs/heads/*&lt;/code&gt; 네임 스페이스가 커밋되지 않은 객체를 허용 하지 않는다는 것 입니다. 후크도 무시하거나 이러한 규칙을 수정할 수있는 구성은, 예를 들어 볼 &lt;code&gt;receive.denyNonFastForwards&lt;/code&gt; 을 에 &lt;a href=&quot;git-config&quot;&gt;[1] - 자식 구성&lt;/a&gt; 과 &lt;code&gt;pre-receive&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt; 에 &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82a27511d4b01630cccb325b4298d897b1527c61" translate="yes" xml:space="preserve">
          <source>All of these also allow you to omit the refspec from the command line because they each contain a refspec which git will use by default.</source>
          <target state="translated">이들 모두는 또한 기본적으로 git이 사용할 참조 스펙을 포함하기 때문에 명령 행에서 참조 스펙을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c91f646c685a7dfcf5e56237f918748518206037" translate="yes" xml:space="preserve">
          <source>All of these objects are stored under their SHA-1 names inside the Git directory:</source>
          <target state="translated">이러한 모든 객체는 Git 디렉토리 내에서 SHA-1 이름으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="dcd6cc66ca5ed15a438644763fc31848cb788922" translate="yes" xml:space="preserve">
          <source>All of those examples use request rewriting, and need &lt;code&gt;mod_rewrite&lt;/code&gt; (or equivalent; examples below are written for Apache).</source>
          <target state="translated">이러한 모든 예제는 요청 다시 쓰기를 사용하며 &lt;code&gt;mod_rewrite&lt;/code&gt; 가 필요합니다 (또는 이에 상응하는 예제는 아래에 Apache 용으로 작성 됨).</target>
        </trans-unit>
        <trans-unit id="555f29027228e8eb9986b68d870b32cd598f6835" translate="yes" xml:space="preserve">
          <source>All offset and size bytes are optional. This is to reduce the instruction size when encoding small offsets or sizes. The first seven bits in the first octet determines which of the next seven octets is present. If bit zero is set, offset1 is present. If bit one is set offset2 is present and so on.</source>
          <target state="translated">모든 오프셋 및 크기 바이트는 선택 사항입니다. 작은 오프셋 또는 크기를 인코딩 할 때 명령어 크기를 줄입니다. 첫 번째 옥텟의 처음 7 비트는 다음 7 옥텟 중 어떤 것이 존재 하는지를 결정합니다. 비트 0이 설정되면 오프셋 1이 존재합니다. 비트 1이 설정되면 offset2가 존재합니다.</target>
        </trans-unit>
        <trans-unit id="64104629c1b1b50c9f411fd4ec6fd95dec11f7bd" translate="yes" xml:space="preserve">
          <source>All packs except the largest pack and those marked with a &lt;code&gt;.keep&lt;/code&gt; files are consolidated into a single pack. When this option is used, &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; is ignored.</source>
          <target state="translated">가장 큰 팩과 &lt;code&gt;.keep&lt;/code&gt; 파일 로 표시된 팩을 제외한 모든 팩 은 단일 팩으로 통합됩니다. 이 옵션을 사용하면 &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; 가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e92b55fa77d7332620f31b40a70c7222a88db6aa" translate="yes" xml:space="preserve">
          <source>All public Trace2 functions and macros are defined in &lt;code&gt;trace2.h&lt;/code&gt; and &lt;code&gt;trace2.c&lt;/code&gt;. All public symbols are prefixed with &lt;code&gt;trace2_&lt;/code&gt;.</source>
          <target state="translated">모든 공용 Trace2 함수 및 매크로는 &lt;code&gt;trace2.h&lt;/code&gt; 및 &lt;code&gt;trace2.c&lt;/code&gt; 에 정의되어 있습니다. 모든 공용 기호 앞에 &lt;code&gt;trace2_&lt;/code&gt; 가 붙 습니다 .</target>
        </trans-unit>
        <trans-unit id="872d9d2cb78e2e8d2f37173a02b50fa38f291d05" translate="yes" xml:space="preserve">
          <source>All recent commands (including stream comments, file changes and progress commands) are shown in the command history within the crash report, but raw file data and commit messages are excluded from the crash report. This exclusion saves space within the report file and reduces the amount of buffering that fast-import must perform during execution.</source>
          <target state="translated">스트림 주석, 파일 변경 및 진행 명령을 포함한 모든 최신 명령이 충돌 보고서의 명령 기록에 표시되지만 원시 파일 데이터 및 커밋 메시지는 충돌 보고서에서 제외됩니다. 이 제외는 보고서 파일 내의 공간을 절약하고 실행 중에 빠른 가져 오기가 수행해야하는 버퍼링 양을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="0d43876445b213dd01218535a02d26c66dcd613b" translate="yes" xml:space="preserve">
          <source>All refs under &lt;code&gt;refs/tags&lt;/code&gt; are pushed, in addition to refspecs explicitly listed on the command line.</source>
          <target state="translated">참조 &lt;code&gt;refs/tags&lt;/code&gt; 아래의 모든 참조 는 명령 행에 명시 적으로 나열된 참조 스펙 외에 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="c5bff800f470ce2148eed81904a64139c855aaa1" translate="yes" xml:space="preserve">
          <source>All submodules which are cloned will be shallow with a depth of 1.</source>
          <target state="translated">복제 된 모든 서브 모듈은 깊이가 1이며 얕습니다.</target>
        </trans-unit>
        <trans-unit id="f0007b01191229097f0830c36da052c040ebd97d" translate="yes" xml:space="preserve">
          <source>All submodules which are cloned will use the status of the submodule&amp;rsquo;s remote-tracking branch to update the submodule, rather than the superproject&amp;rsquo;s recorded SHA-1. Equivalent to passing &lt;code&gt;--remote&lt;/code&gt; to &lt;code&gt;git submodule update&lt;/code&gt;.</source>
          <target state="translated">복제 된 모든 하위 모듈은 수퍼 프로젝트의 기록 된 SHA-1이 아니라 하위 모듈의 원격 추적 분기 상태를 사용하여 하위 모듈을 업데이트합니다. 통과 상당 &lt;code&gt;--remote&lt;/code&gt; 를 에 &lt;code&gt;git submodule update&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a786f92eda8c2712ba677e1c4004bf3ff8163928" translate="yes" xml:space="preserve">
          <source>All such extra objects are removed.</source>
          <target state="translated">이러한 추가 개체는 모두 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="308cf0e6d77f72bd2adee2732440a8d78d5aacdb" translate="yes" xml:space="preserve">
          <source>All the &lt;code&gt;file1&lt;/code&gt; files in the output refer to files before the commit, and all the &lt;code&gt;file2&lt;/code&gt; files refer to files after the commit. It is incorrect to apply each change to each file sequentially. For example, this patch will swap a and b:</source>
          <target state="translated">출력의 모든 &lt;code&gt;file1&lt;/code&gt; 파일은 커밋 이전의 파일을 참조 하고 모든 &lt;code&gt;file2&lt;/code&gt; 파일은 커밋 후 파일을 참조합니다. 각 변경 사항을 각 파일에 순차적으로 적용하는 것은 올바르지 않습니다. 예를 들어,이 패치는 a와 b를 교체합니다 :</target>
        </trans-unit>
        <trans-unit id="239d57c9bf513683c75ec610784ccebafe4aed25" translate="yes" xml:space="preserve">
          <source>All the &lt;code&gt;git commit&lt;/code&gt; hooks are invoked with the environment variable &lt;code&gt;GIT_EDITOR=:&lt;/code&gt; if the command will not bring up an editor to modify the commit message.</source>
          <target state="translated">명령이 커밋 메시지를 수정하기 위해 편집기를 불러 오지 않으면 환경 변수 &lt;code&gt;GIT_EDITOR=:&lt;/code&gt; 로 모든 &lt;code&gt;git commit&lt;/code&gt; 훅이 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="05af0c4256a038463a91f307f30a32fa481ee96d" translate="yes" xml:space="preserve">
          <source>All the operations required for normal use are supported, including checkout, diff, status, update, log, add, remove, commit.</source>
          <target state="translated">체크 아웃, 차이, 상태, 업데이트, 로그, 추가, 제거, 커밋을 포함하여 정상적인 사용에 필요한 모든 작업이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b2fe8473c593abf01d9d1e8a032df7ab79ebe59a" translate="yes" xml:space="preserve">
          <source>All the other lines (and the remainder of the line after the section header) are recognized as setting variables, in the form &lt;code&gt;name = value&lt;/code&gt; (or just &lt;code&gt;name&lt;/code&gt;, which is a short-hand to say that the variable is the boolean &quot;true&quot;). The variable names are case-insensitive, allow only alphanumeric characters and &lt;code&gt;-&lt;/code&gt;, and must start with an alphabetic character.</source>
          <target state="translated">다른 모든 행 (및 섹션 헤더 다음 행의 나머지 부분)은 &lt;code&gt;name = value&lt;/code&gt; 형식으로 변수를 설정하는 것으로 인식됩니다. 또는 &lt;code&gt;name&lt;/code&gt; 은 변수가 부울 &quot;true&quot; ). 변수 이름은 대소 문자를 구분하지 않으며 영숫자 및 &lt;code&gt;-&lt;/code&gt; 만 허용하며 알파벳 문자로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="37ddc9bc522de0a239773cc3df5a07e1939ed991" translate="yes" xml:space="preserve">
          <source>All these options obviously only make sense if enforced by the server side. They have been implemented to resemble the &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; options as closely as possible.</source>
          <target state="translated">이러한 모든 옵션은 서버 측에서 시행하는 경우에만 의미가 있습니다. 그것들은 &lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]&lt;/a&gt; 옵션과 최대한 비슷하게 구현되었습니다 .</target>
        </trans-unit>
        <trans-unit id="8b22c4f0e3bbf22138baec4c3149a4805b70efc2" translate="yes" xml:space="preserve">
          <source>All untracked files are also stashed and then cleaned up with &lt;code&gt;git clean&lt;/code&gt;.</source>
          <target state="translated">추적되지 않은 모든 파일도 숨김 처리 된 다음 &lt;code&gt;git clean&lt;/code&gt; 으로 정리 됩니다.</target>
        </trans-unit>
        <trans-unit id="5a78bca2d245f7f4e49ed3949e2005fd2e3b0774" translate="yes" xml:space="preserve">
          <source>All variables can also be set per access method, see &lt;a href=&quot;#configaccessmethod&quot;&gt;above&lt;/a&gt;.</source>
          <target state="translated">모든 변수는 액세스 방법마다 설정할 수 있습니다 ( &lt;a href=&quot;#configaccessmethod&quot;&gt;위&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="0e67d43426c8567d2129159d2cb0396634aa4c2f" translate="yes" xml:space="preserve">
          <source>All writing options will per default write to the repository specific configuration file. Note that this also affects options like &lt;code&gt;--replace-all&lt;/code&gt; and &lt;code&gt;--unset&lt;/code&gt;. &lt;strong&gt;&lt;em&gt;git config&lt;/em&gt; will only ever change one file at a time&lt;/strong&gt;.</source>
          <target state="translated">모든 쓰기 옵션은 기본적으로 저장소 특정 구성 파일에 기록됩니다. 이는 &lt;code&gt;--replace-all&lt;/code&gt; 및 &lt;code&gt;--unset&lt;/code&gt; 과 같은 옵션에도 영향을 미칩니다 . &lt;strong&gt;&lt;em&gt;git config&lt;/em&gt; 는 한 번에 하나의 파일 만 변경합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="95ccd528c2d028453ad3cf7d0223681cc63467f8" translate="yes" xml:space="preserve">
          <source>All you need to do is edit the files to resolve the conflicts, and then</source>
          <target state="translated">충돌을 해결하기 위해 파일을 편집하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="dd540fb2325b9250764db7424886c097360ae897" translate="yes" xml:space="preserve">
          <source>All you need to do is place the newly created bare Git repository in a directory that is exported by the web server, and make some adjustments to give web clients some extra information they need:</source>
          <target state="translated">새로 만든 베어 Git 리포지토리를 웹 서버에서 내 보낸 디렉토리에 배치하고 웹 클라이언트에 필요한 추가 정보를 제공하기 위해 약간의 조정 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="48af47b0afbfe999262fa68f40e97838cf256b84" translate="yes" xml:space="preserve">
          <source>Allow (or disallow) external text conversion filters to be run when comparing binary files. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details. Because textconv filters are typically a one-way conversion, the resulting diff is suitable for human consumption, but cannot be applied. For this reason, textconv filters are enabled by default only for &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; and &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, but not for &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt; or diff plumbing commands.</source>
          <target state="translated">이진 파일을 비교할 때 외부 텍스트 변환 필터가 실행되도록 허용하거나 허용하지 않습니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오. textconv 필터는 일반적으로 단방향 변환이므로 결과 diff는 사람이 소비하기에 적합하지만 적용 할 수는 없습니다. 이러한 이유로 textconv 필터는 기본적으로 &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 및 &lt;a href=&quot;git-log&quot;&gt;git-log [1]에&lt;/a&gt; 대해서만 활성화 되지만 &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; 또는 diff plumbing 명령 에는 활성화 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c181c3ddfb97039bcd6c32002cf12732d3862d70" translate="yes" xml:space="preserve">
          <source>Allow -s or -t to query broken/corrupt objects of unknown type.</source>
          <target state="translated">알 수없는 유형의 파손 / 손상된 오브젝트를 조회하려면 -s 또는 -t를 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="faf02b1d62cc9d5575e2c1ae9bbaffbbe1cee9af" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;--stdin&lt;/code&gt; to hash any garbage into a loose object which might not otherwise pass standard object parsing or git-fsck checks. Useful for stress-testing Git itself or reproducing characteristics of corrupt or bogus objects encountered in the wild.</source>
          <target state="translated">표준 객체 파싱이나 git-fsck 검사를 통과하지 못하는 느슨한 객체로 가비지를 해시하도록 &lt;code&gt;--stdin&lt;/code&gt; 을 허용 하십시오 . 스트레스 테스트에 유용 Git 자체 또는 야생에서 만나는 부패하거나 가짜 물체의 특성을 재현합니다.</target>
        </trans-unit>
        <trans-unit id="b8cf489219ee9e67f31bd43c44a93293049edf6e" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;upload-pack&lt;/code&gt; to accept a fetch request that asks for an object that is reachable from any ref tip. However, note that calculating object reachability is computationally expensive. Defaults to &lt;code&gt;false&lt;/code&gt;. Even if this is false, a client may be able to steal objects via the techniques described in the &quot;SECURITY&quot; section of the &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; man page; it&amp;rsquo;s best to keep private data in a separate repository.</source>
          <target state="translated">허용 &lt;code&gt;upload-pack&lt;/code&gt; 어떤 심판 끝에서 도달 할 수있는 객체에 대해 묻는 가져 오기 요청을 수락 할 수 있습니다. 그러나 객체 도달 가능성을 계산하는 것은 계산 비용이 많이 듭니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. 이것이 잘못된 경우에도 클라이언트는 &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]&lt;/a&gt; 매뉴얼 페이지 의 &quot;보안&quot;섹션에 설명 된 기술을 통해 객체를 훔칠 수 있습니다 . 개인 데이터를 별도의 저장소에 보관하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5c123f83ef289d2d1e91047a317113ed5e999032" translate="yes" xml:space="preserve">
          <source>Allow &lt;code&gt;upload-pack&lt;/code&gt; to accept a fetch request that asks for any object at all. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">허용 &lt;code&gt;upload-pack&lt;/code&gt; 모두에서 모든 개체를 요구 페치 요청을 수락 할 수 있습니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7dac60bc93b481fbd44fafe13c497842d9a7d982" translate="yes" xml:space="preserve">
          <source>Allow adding otherwise ignored files.</source>
          <target state="translated">다르게 무시 된 파일을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0a681012f0189df01bc378cc160293747f7b006" translate="yes" xml:space="preserve">
          <source>Allow an empty note object to be stored. The default behavior is to automatically remove empty notes.</source>
          <target state="translated">빈 메모 개체를 저장합니다. 기본 동작은 빈 메모를 자동으로 제거하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="87f26de68d4ee0de2215d71b6377c359ff10beb5" translate="yes" xml:space="preserve">
          <source>Allow an external diff helper to be executed. If you set an external diff driver with &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt;, you need to use this option with &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; and friends.</source>
          <target state="translated">외부 diff 도우미를 실행할 수 있습니다. &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 로 외부 diff 드라이버를 설정 한 경우 &lt;a href=&quot;git-log&quot;&gt;git-log [1]&lt;/a&gt; 및 friends 와 함께이 옵션을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="73e430db92a123869cc3ef536d85d87d370ba895" translate="yes" xml:space="preserve">
          <source>Allow building of more than one tree object before exiting. Each tree is separated by as single blank line. The final new-line is optional. Note - if the &lt;code&gt;-z&lt;/code&gt; option is used, lines are terminated with NUL.</source>
          <target state="translated">종료하기 전에 둘 이상의 트리 오브젝트를 빌드하도록 허용하십시오. 각 트리는 단일 빈 줄로 구분됩니다. 마지막 줄 바꿈은 선택 사항입니다. 주 &amp;ndash; &lt;code&gt;-z&lt;/code&gt; 옵션을 사용하면 NUL로 행이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="8e57d5c7661ffc2e9da98170f1d30b0c418901a9" translate="yes" xml:space="preserve">
          <source>Allow missing objects. The default behaviour (without this option) is to verify that each tree entry&amp;rsquo;s sha1 identifies an existing object. This option has no effect on the treatment of gitlink entries (aka &quot;submodules&quot;) which are always allowed to be missing.</source>
          <target state="translated">누락 된 개체를 허용하십시오. 이 옵션이없는 기본 동작은 각 트리 항목의 sha1이 기존 객체를 식별하는지 확인하는 것입니다. 이 옵션은 항상 누락 될 수있는 gitlink 항목 ( &quot;서브 모듈&quot;) 처리에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a9030542d2938f9caeac64676db40e7417c42b9" translate="yes" xml:space="preserve">
          <source>Allow pulling from all directories that look like Git repositories (have the &lt;code&gt;objects&lt;/code&gt; and &lt;code&gt;refs&lt;/code&gt; subdirectories), even if they do not have the &lt;code&gt;git-daemon-export-ok&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;git-daemon-export-ok&lt;/code&gt; 파일 이없는 경우에도 Git 리포지토리 ( &lt;code&gt;objects&lt;/code&gt; 및 참조 하위 디렉토리를 가짐)처럼 보이는 모든 디렉토리에서 &lt;code&gt;refs&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="98350181a43fb733be348f0d041de3f567196c13" translate="yes" xml:space="preserve">
          <source>Allow recursive removal when a leading directory name is given.</source>
          <target state="translated">선행 디렉토리 이름이 제공되면 재귀 제거를 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="c333cb7fb684ac83dfac5b9ca4103644dc06e4b3" translate="yes" xml:space="preserve">
          <source>Allow several &amp;lt;repository&amp;gt; and &amp;lt;group&amp;gt; arguments to be specified. No &amp;lt;refspec&amp;gt;s may be specified.</source>
          <target state="translated">여러 개의 &amp;lt;repository&amp;gt; 및 &amp;lt;group&amp;gt; 인수를 지정할 수 있습니다. &amp;lt;refspec&amp;gt;을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5913a64254a27922cb756768e473a3a0fc91c718" translate="yes" xml:space="preserve">
          <source>Allow the rerere mechanism to update the index with the result of auto-conflict resolution if possible.</source>
          <target state="translated">rerere 메커니즘이 가능하면 자동 충돌 해결 결과로 색인을 업데이트하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="e67909264741a3c975c7c69263b8cae851ce5588" translate="yes" xml:space="preserve">
          <source>Allow to extend .git/shallow if the new refs require it.</source>
          <target state="translated">새로운 심판이 그것을 요구한다면 .git / shallow를 확장하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="021daf7178c1ed944c38d8aa70956d32b2ff6625" translate="yes" xml:space="preserve">
          <source>Allow ~user notation to be used in requests. When specified with no parameter, requests to git://host/~alice/foo is taken as a request to access &lt;code&gt;foo&lt;/code&gt; repository in the home directory of user &lt;code&gt;alice&lt;/code&gt;. If &lt;code&gt;--user-path=path&lt;/code&gt; is specified, the same request is taken as a request to access &lt;code&gt;path/foo&lt;/code&gt; repository in the home directory of user &lt;code&gt;alice&lt;/code&gt;.</source>
          <target state="translated">~ 사용자 표기법을 요청에 사용하도록 허용하십시오. 매개 변수없이 지정하면 git : // host / ~ alice / foo에 대한 요청 은 &lt;code&gt;alice&lt;/code&gt; 사용자의 홈 디렉토리에있는 &lt;code&gt;foo&lt;/code&gt; 저장소에 대한 요청으로 간주됩니다 . 경우 &lt;code&gt;--user-path=path&lt;/code&gt; 지정, 같은 요청은 액세스에 대한 요청으로한다 &lt;code&gt;path/foo&lt;/code&gt; 사용자의 홈 디렉토리에 저장소 &lt;code&gt;alice&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f93db45d6bdb40051ed50b8cdab39b85ae36aa7" translate="yes" xml:space="preserve">
          <source>Allow/forbid overriding the site-wide default with per repository configuration. By default, all the services may be overridden.</source>
          <target state="translated">리포지토리 구성별로 사이트 전체 기본값을 무시하도록 허용 / 금지합니다. 기본적으로 모든 서비스가 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="970c6f976b1a1113e48252fb665bb9621a059065" translate="yes" xml:space="preserve">
          <source>Allowing web browsing of a repository</source>
          <target state="translated">저장소의 웹 브라우징 허용</target>
        </trans-unit>
        <trans-unit id="2c735decb73a4c6a17889815dc7b443aeda53134" translate="yes" xml:space="preserve">
          <source>Allows overriding the default branch name e.g. when initializing a new repository or when cloning an empty repository.</source>
          <target state="translated">새 저장소를 초기화하거나 빈 저장소를 복제 할 때 기본 브랜치 이름을 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8f99759b1b09bc7158e191889a1567fae09d468" translate="yes" xml:space="preserve">
          <source>Allows the pre-rebase hook to run, which is the default. This option can be used to override --no-verify. See also &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">사전 리베이스 후크가 실행되도록 허용합니다 (기본값). 이 옵션은 --no-verify를 재정의하는 데 사용할 수 있습니다. &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c6ea72ee13badd8d83db58afdf5e962ad300ef1" translate="yes" xml:space="preserve">
          <source>Allows to specify the commit message.</source>
          <target state="translated">커밋 메시지를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2ec32ba2a953960fca003bf1ffa505bb688ba89" translate="yes" xml:space="preserve">
          <source>Also note that only one asterisk is allowed per word. For example:</source>
          <target state="translated">또한 단어 당 하나의 별표 만 허용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="771cf844aea157583eecdff70f695735bc6a87ec" translate="yes" xml:space="preserve">
          <source>Also note that the above configuration can be performed by directly editing the file &lt;code&gt;.git/config&lt;/code&gt; instead of using &lt;a href=&quot;git-remote&quot;&gt;git-remote[1]&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;git-remote&quot;&gt;git-remote [1]&lt;/a&gt; 대신 &lt;code&gt;.git/config&lt;/code&gt; 파일을 직접 편집하여 위의 구성을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4107490214e5f413a9517623a2b64cb4835e7c24" translate="yes" xml:space="preserve">
          <source>Also note that we don&amp;rsquo;t require the commits that are kept to be descendants of a &quot;good&quot; commit. So in the following example, commits W and Z will be kept:</source>
          <target state="translated">또한 &quot;양호한&quot;커밋의 자손으로 유지되는 커밋은 필요하지 않습니다. 따라서 다음 예제에서는 커밋 W 및 Z가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f69166c2831d93f6b548f4895823501206c0d3ba" translate="yes" xml:space="preserve">
          <source>Also output details about the matching pattern (if any) for each given pathname. For precedence rules within and between exclude sources, see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;.</source>
          <target state="translated">주어진 각 경로 이름에 대한 일치 패턴 (있는 경우)에 대한 세부 사항도 출력하십시오. 제외 소스 내부 및 사이의 우선 순위 규칙은 &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd9960d9f0773be5357485566c306db4c0f3e065" translate="yes" xml:space="preserve">
          <source>Also read the object names to remove notes from the standard input (there is no reason you cannot combine this with object names from the command line).</source>
          <target state="translated">또한 표준 입력에서 메모를 제거하기 위해 오브젝트 이름을 읽으십시오 (명령 행에서이를 오브젝트 이름과 결합 할 수있는 이유는 없습니다).</target>
        </trans-unit>
        <trans-unit id="c7fa0726e69077445ae425465cf33ea62e9aedfc" translate="yes" xml:space="preserve">
          <source>Also search in ignored files by not honoring the &lt;code&gt;.gitignore&lt;/code&gt; mechanism. Only useful with &lt;code&gt;--untracked&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;.gitignore&lt;/code&gt; 메커니즘 을 따르지 않고 무시 된 파일을 검색하십시오 . &lt;code&gt;--untracked&lt;/code&gt; 에서만 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="05797f7578d1a6ba6a5217b9a350a9edbcb69fe4" translate="yes" xml:space="preserve">
          <source>Also you can use a regular expression to specify the line range:</source>
          <target state="translated">또한 정규식을 사용하여 행 범위를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4774804d03b6c07565acb208c60c6e7cbe3431b2" translate="yes" xml:space="preserve">
          <source>Also, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; will list those files as &quot;unmerged&quot;, and the files with conflicts will have conflict markers added, like this:</source>
          <target state="translated">또한 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 는 해당 파일을 &quot;머지되지 않은&quot;것으로 나열하고 충돌이있는 파일에는 다음과 같이 충돌 마커가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4527cea99021b273b3aba7b9a7e7a9bfd20d98e9" translate="yes" xml:space="preserve">
          <source>Also, note that a bare &lt;code&gt;git diff&lt;/code&gt; shows the changes to file.txt, but not the addition of closing.txt, because the version of closing.txt in the index file is identical to the one in the working directory.</source>
          <target state="translated">또한 &lt;code&gt;git diff&lt;/code&gt; 는 file.txt에 대한 변경 사항을 보여 주지만, index.txt의 버전은 작업 디렉토리의 버전과 동일하기 때문에 closing.txt를 추가하지 않은 것을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1948de62c9472dadd9b232c96fea0db542b4a7f1" translate="yes" xml:space="preserve">
          <source>Also, the poor performance of git-filter-branch often leads to safety issues:</source>
          <target state="translated">또한 git-filter-branch의 성능이 좋지 않으면 종종 안전 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3d45b434e26b625e54920695d02b2fe8da737175" translate="yes" xml:space="preserve">
          <source>Also, the remote-tracking branch you use the &lt;code&gt;--fork-point&lt;/code&gt; mode with must be the one your topic forked from its tip. If you forked from an older commit than the tip, this mode would not find the fork point (imagine in the above sample history B0 did not exist, origin/master started at B1, moved to B2 and then B, and you forked your topic at origin/master^ when origin/master was B1; the shape of the history would be the same as above, without B0, and the parent of B1 is what &lt;code&gt;git merge-base origin/master topic&lt;/code&gt; correctly finds, but the &lt;code&gt;--fork-point&lt;/code&gt; mode will not, because it is not one of the commits that used to be at the tip of origin/master).</source>
          <target state="translated">또한 &lt;code&gt;--fork-point&lt;/code&gt; 모드 를 사용하는 원격 추적 분기 는 주제에서 분기 된 분기 여야합니다. 팁보다 오래된 커밋에서 분기 한 경우이 모드는 분기점을 찾지 못합니다 (위의 샘플 히스토리 B0이 존재하지 않았고 출발지 / 마스터가 B1에서 시작하여 B2로 이동 한 다음 B로 이동하여 주제를 분기 함) origin / master가 B1 인 경우 origin / master ^에서; 히스토리의 모양은 B0없이 위와 동일하며 B1의 상위는 &lt;code&gt;git merge-base origin/master topic&lt;/code&gt; 올바르게 찾는 &lt;code&gt;--fork-point&lt;/code&gt; 모드는 원점 / 마스터 팁에 있던 커밋 중 하나가 아니기 때문에 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac8d6fa69b9f440f0c0a5d003f6fd5f2f023c7f6" translate="yes" xml:space="preserve">
          <source>Also, these upper-case letters can be downcased to exclude. E.g. &lt;code&gt;--diff-filter=ad&lt;/code&gt; excludes added and deleted paths.</source>
          <target state="translated">또한이 대문자는 소문자로 제외 할 수 있습니다. 예를 들어 &lt;code&gt;--diff-filter=ad&lt;/code&gt; 는 추가 및 삭제 된 경로를 제외합니다.</target>
        </trans-unit>
        <trans-unit id="2530a264943c28587e7428206ae85af163c3c029" translate="yes" xml:space="preserve">
          <source>Also, we do not call it &quot;cache&quot; any more, but rather &quot;index&quot;; however, the file is still called &lt;code&gt;cache.h&lt;/code&gt;. Remark: Not much reason to change it now, especially since there is no good single name for it anyway, because it is basically &lt;code&gt;the&lt;/code&gt; header file which is included by &lt;code&gt;all&lt;/code&gt; of Git&amp;rsquo;s C sources.</source>
          <target state="translated">또한 더 이상 &quot;캐시&quot;라고하지 않고 &quot;인덱스&quot;라고 부릅니다. 그러나 파일은 여전히 &lt;code&gt;cache.h&lt;/code&gt; 입니다. 비고 : 그것은 기본적이기 때문에 그것을위한 좋은 하나의 이름은, 어쨌든 없다 특히 이후, 지금 그것을 변경하지 않는 많은 이유 가 포함되어있는 헤더 파일을 &lt;code&gt;all&lt;/code&gt; 망할 놈의 C 소스. &lt;code&gt;the&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4e6472f190ba1582b845a0ece02ff445cff78f4d" translate="yes" xml:space="preserve">
          <source>Also, when &lt;code&gt;--raw&lt;/code&gt; or &lt;code&gt;--numstat&lt;/code&gt; has been given, do not munge pathnames and use NULs as output field terminators.</source>
          <target state="translated">또한 &lt;code&gt;--raw&lt;/code&gt; 또는 &lt;code&gt;--numstat&lt;/code&gt; 가 지정된 경우 경로 이름을 변경하지 않고 NUL을 출력 필드 종결 자로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a1a167e4e28bf08db5b93ca5300935fe27c039fa" translate="yes" xml:space="preserve">
          <source>Alter the sha1&amp;rsquo;s minimum display length in the output listing. The default value is 7 and can be overridden by the &lt;code&gt;core.abbrev&lt;/code&gt; config option.</source>
          <target state="translated">출력 목록에서 sha1의 최소 표시 길이를 변경하십시오. 기본값은 7이며 &lt;code&gt;core.abbrev&lt;/code&gt; 구성 옵션 으로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aadcacaf495c2512ca4329e0d847da152c0541e3" translate="yes" xml:space="preserve">
          <source>Alternate terms</source>
          <target state="translated">다른 용어</target>
        </trans-unit>
        <trans-unit id="0712141dd1ece4a4773c0da1c80f1954ca0f9da5" translate="yes" xml:space="preserve">
          <source>Alternates, clone -reference, etc.</source>
          <target state="translated">대체, 클론 참조 등</target>
        </trans-unit>
        <trans-unit id="2ca863985e6b3522ed032957d62190302ca13b98" translate="yes" xml:space="preserve">
          <source>Alternative Git implementations (e.g. JGit or libgit2) and older Git versions (as of March 2018) do not support the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute. If you decide to use the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute in your repository, then it is strongly recommended to ensure that all clients working with the repository support it.</source>
          <target state="translated">대체 Git 구현 (예 : JGit 또는 libgit2) 및 이전 Git 버전 (2018 년 3 월 기준)은 &lt;code&gt;working-tree-encoding&lt;/code&gt; 속성을 지원하지 않습니다 . 저장소에서 &lt;code&gt;working-tree-encoding&lt;/code&gt; 속성 을 사용하기로 결정한 경우 저장소를 사용하는 모든 클라이언트가이를 지원하도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9dbb61a2fa8dc0f3013308a0745fea72ba7b1a16" translate="yes" xml:space="preserve">
          <source>Alternative development models</source>
          <target state="translated">대체 개발 모델</target>
        </trans-unit>
        <trans-unit id="a7aefac2117f3e88573f4205384ee4d7a98e203b" translate="yes" xml:space="preserve">
          <source>Alternatively you can produce the password with perl&amp;rsquo;s crypt() operator:</source>
          <target state="translated">또는 perl의 crypt () 연산자를 사용하여 비밀번호를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ca416a8fe96dacfa9959132947eceee9f58da64" translate="yes" xml:space="preserve">
          <source>Alternatively, Git has a native protocol, or can use http; see &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; for details.</source>
          <target state="translated">또는 Git에는 기본 프로토콜이 있거나 http를 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7cf31ef819e05669294bc16a9923a23bdb2b7a01" translate="yes" xml:space="preserve">
          <source>Alternatively, if &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; config is not enabled or the attributes do not allow automatic detection for a filename, then the server uses the &lt;code&gt;gitcvs.allBinary&lt;/code&gt; config for the default setting. If &lt;code&gt;gitcvs.allBinary&lt;/code&gt; is set, then file not otherwise specified will default to &lt;code&gt;-kb&lt;/code&gt; mode. Otherwise the &lt;code&gt;-k&lt;/code&gt; mode is left blank. But if &lt;code&gt;gitcvs.allBinary&lt;/code&gt; is set to &quot;guess&quot;, then the correct &lt;code&gt;-k&lt;/code&gt; mode will be guessed based on the contents of the file.</source>
          <target state="translated">또는 &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; 구성이 사용 가능하지 않거나 속성이 파일 이름 자동 감지를 허용하지 않는 경우 서버는 기본 설정에 &lt;code&gt;gitcvs.allBinary&lt;/code&gt; 구성을 사용 합니다. 경우 &lt;code&gt;gitcvs.allBinary&lt;/code&gt; 가 설정되어, 다음, 그렇지 않으면를 기본값으로 지정되지 않은 파일 &lt;code&gt;-kb&lt;/code&gt; 모드. 그렇지 않으면 &lt;code&gt;-k&lt;/code&gt; 모드가 비어 있습니다. 그러나 &lt;code&gt;gitcvs.allBinary&lt;/code&gt; 를 &quot;guess&quot;로 설정 하면 파일의 내용에 따라 올바른 &lt;code&gt;-k&lt;/code&gt; 모드가 추측됩니다.</target>
        </trans-unit>
        <trans-unit id="b1ff522462be60cebf023852e684a91e2d5544f7" translate="yes" xml:space="preserve">
          <source>Alternatively, if the variable is set to an absolute path (starting with a &lt;code&gt;/&lt;/code&gt; character), Git will interpret this as a file path and will try to append the trace messages to it.</source>
          <target state="translated">또는 변수가 절대 경로 ( &lt;code&gt;/&lt;/code&gt; 문자로 시작 )로 설정되면 Git은 이것을 파일 경로로 해석하고 추적 메시지를 추가하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="4d07f3824238dc7367ab6d5b5e874d23e305b47d" translate="yes" xml:space="preserve">
          <source>Alternatively, if the variable is set to an absolute path (starting with a &lt;code&gt;/&lt;/code&gt; character), Git will interpret this as a file path and will try to append the trace messages to it. If the path already exists and is a directory, the trace messages will be written to files (one per process) in that directory, named according to the last component of the SID and an optional counter (to avoid filename collisions).</source>
          <target state="translated">또는 변수가 절대 경로 ( &lt;code&gt;/&lt;/code&gt; 문자로 시작 )로 설정되면 Git은 이것을 파일 경로로 해석하고 추적 메시지를 추가하려고 시도합니다. 경로가 이미 존재하고 디렉토리 인 경우, SID의 마지막 구성 요소 및 선택적 카운터 (파일 이름 충돌을 피하기 위해)에 따라 이름이 지정된 해당 디렉토리의 파일 (프로세스 당 하나)에 추적 메시지가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="c00302c08639585f72779e30a86782e24fd08ff9" translate="yes" xml:space="preserve">
          <source>Alternatively, instead of running &lt;code&gt;git add&lt;/code&gt; beforehand, you can use</source>
          <target state="translated">또는 &lt;code&gt;git add&lt;/code&gt; 를 미리 실행하는 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="530bb07d1f66513818e1b0385a8e30a51f6194af" translate="yes" xml:space="preserve">
          <source>Alternatively, note that</source>
          <target state="translated">또는</target>
        </trans-unit>
        <trans-unit id="f80a5d22f5c293edd914795b473129c37d7276c3" translate="yes" xml:space="preserve">
          <source>Alternatively, use &lt;code&gt;-z&lt;/code&gt; to specify in NUL-terminated format, without quoting:</source>
          <target state="translated">또는 &lt;code&gt;-z&lt;/code&gt; 를 사용하여 따옴표없이 NUL 종료 형식으로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="e5759528a9df2b3bafde33c91b20bb607bfb37f6" translate="yes" xml:space="preserve">
          <source>Alternatively, you can edit the working directory and update the index to fix your mistake, just as if you were going to &lt;a href=&quot;#how-to-make-a-commit&quot;&gt;create a new commit&lt;/a&gt;, then run</source>
          <target state="translated">또는 &lt;a href=&quot;#how-to-make-a-commit&quot;&gt;새 커밋&lt;/a&gt; 을 작성하는 것처럼 작업 디렉토리를 편집하고 색인을 업데이트하여 실수를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b15cfe3da911f6cecf33791979f852dbff3cfb5b" translate="yes" xml:space="preserve">
          <source>Alternatively, you can just use the non-standard extssh protocol that Eclipse offer. In that case CVS_SERVER is ignored, and you will have to replace the cvs utility on the server with &lt;code&gt;git-cvsserver&lt;/code&gt; or manipulate your &lt;code&gt;.bashrc&lt;/code&gt; so that calling &lt;code&gt;cvs&lt;/code&gt; effectively calls &lt;code&gt;git-cvsserver&lt;/code&gt;.</source>
          <target state="translated">또는 Eclipse가 제공하는 비표준 extssh 프로토콜을 사용할 수 있습니다. 이 경우 CVS_SERVER는 무시되므로 서버의 cvs 유틸리티를 &lt;code&gt;git-cvsserver&lt;/code&gt; 로 바꾸 거나 &lt;code&gt;.bashrc&lt;/code&gt; 를 조작하여 &lt;code&gt;cvs&lt;/code&gt; 를 호출하면 효과적으로 &lt;code&gt;git-cvsserver&lt;/code&gt; 를 호출 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="05fd4a6419394e16cfc11919ace1a8f856d1ec42" translate="yes" xml:space="preserve">
          <source>Alternatively, you can rebase your change between X and B on top of A, with &quot;git pull --rebase&quot;, and push the result back. The rebase will create a new commit D that builds the change between X and B on top of A.</source>
          <target state="translated">또는 &quot;git pull --rebase&quot;를 사용하여 A와 X 사이의 변경 사항을 리베이스하고 결과를 다시 푸시 할 수 있습니다. 리베이스는 A 위에 X와 B 사이의 변경을 빌드하는 새로운 커밋 D를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a49fa07d5474cf3dca63ac2a175c46a10b07f5f3" translate="yes" xml:space="preserve">
          <source>Alternatively, you can undo the &lt;code&gt;git rebase&lt;/code&gt; with</source>
          <target state="translated">또는 다음 과 같이 &lt;code&gt;git rebase&lt;/code&gt; 를 취소 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="029034bf1886e77ae0c4d532b4059fd9c7d41a52" translate="yes" xml:space="preserve">
          <source>Alternatively, you may often see this sort of thing done with the lower-level command &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt;, which just lists the SHA-1&amp;rsquo;s of all the given commits:</source>
          <target state="translated">또는 하위 레벨 명령 인 &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]을&lt;/a&gt; 사용하여 이런 종류의 작업을 수행하는 경우가 종종 있습니다 . 여기에는 지정된 모든 커밋의 SHA-1 만 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="bf28b03e83304f7cdad7262da1da6a80b8eb9f3d" translate="yes" xml:space="preserve">
          <source>Although Git includes its own porcelain layer, its low-level commands are sufficient to support development of alternative porcelains. Developers of such porcelains might start by reading about &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; and &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt;.</source>
          <target state="translated">Git에는 자체 도자기 레이어가 포함되어 있지만 저수준 명령은 대체 도자기 개발을 지원하기에 충분합니다. 그러한 도자기의 개발자는 &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt; 및 &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]에&lt;/a&gt; 대해 읽는 것으로 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c4b8611028dc848ad4ee5788ef19d7585dae7a1" translate="yes" xml:space="preserve">
          <source>Although Git is a truly distributed system, it is often convenient to organize your project with an informal hierarchy of developers. Linux kernel development is run this way. There is a nice illustration (page 17, &quot;Merges to Mainline&quot;) in &lt;a href=&quot;https://web.archive.org/web/20120915203609/http://www.xenotime.net/linux/mentor/linux-mentoring-2006.pdf&quot;&gt;Randy Dunlap&amp;rsquo;s presentation&lt;/a&gt;.</source>
          <target state="translated">Git은 실제로 분산 된 시스템이지만 비공식적 인 개발자 계층 구조로 프로젝트를 구성하는 것이 편리한 경우가 많습니다. 리눅스 커널 개발은 이런 식으로 실행됩니다. &lt;a href=&quot;https://web.archive.org/web/20120915203609/http://www.xenotime.net/linux/mentor/linux-mentoring-2006.pdf&quot;&gt;Randy Dunlap의 프레젠테이션&lt;/a&gt; 에는 멋진 삽화 (17 페이지, &quot;메인 라인으로 병합&quot;)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f37ac3daafe831f82aec5b2cea866288f7330ab" translate="yes" xml:space="preserve">
          <source>Although both this option and --fork-point find the merge base between &amp;lt;upstream&amp;gt; and &amp;lt;branch&amp;gt;, this option uses the merge base as the &lt;code&gt;starting point&lt;/code&gt; on which new commits will be created, whereas --fork-point uses the merge base to determine the &lt;code&gt;set of commits&lt;/code&gt; which will be rebased.</source>
          <target state="translated">이 옵션과 --fork-point가 모두 &amp;lt;upstream&amp;gt;과 &amp;lt;branch&amp;gt; 사이의 병합 기준을 찾더라도이 옵션은 병합 기준 을 새 커밋이 생성 될 &lt;code&gt;starting point&lt;/code&gt; 으로 사용하지만 --fork-point는 병합을 사용합니다 기반 이 될 &lt;code&gt;set of commits&lt;/code&gt; 를 결정하는 기준 .</target>
        </trans-unit>
        <trans-unit id="bc30d48b03921e7f964de7f07369eb4188785847" translate="yes" xml:space="preserve">
          <source>Although the object files are gone, any commands that refer to those objects will work exactly as they did before.</source>
          <target state="translated">오브젝트 파일이 없어지더라도 해당 오브젝트를 참조하는 모든 명령은 이전과 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="47f1282955f73f61669189722bd77f19d0aada5a" translate="yes" xml:space="preserve">
          <source>Although this bit looks similar to assume-unchanged bit, its goal is different from assume-unchanged bit&amp;rsquo;s. Skip-worktree also takes precedence over assume-unchanged bit when both are set.</source>
          <target state="translated">이 비트는 변경되지 않은 비트와 비슷해 보이지만 목표는 변경되지 않은 비트와 다릅니다. Skip-worktree는 또한 둘 다 설정 될 때 변경되지 않은 비트보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="d6138749eeae08edd7696427a93048315afbc7d0" translate="yes" xml:space="preserve">
          <source>Although we encourage that the commit log messages are encoded in UTF-8, both the core and Git Porcelain are designed not to force UTF-8 on projects. If all participants of a particular project find it more convenient to use legacy encodings, Git does not forbid it. However, there are a few things to keep in mind.</source>
          <target state="translated">커밋 로그 메시지를 UTF-8로 인코딩하는 것이 좋지만 코어와 Git Porcelain은 프로젝트에서 UTF-8을 강제하지 않도록 설계되었습니다. 특정 프로젝트의 모든 참가자가 레거시 인코딩을 사용하는 것이 더 편리한 경우 Git은이를 금지하지 않습니다. 그러나 명심해야 할 것이 몇 가지 있습니다.</target>
        </trans-unit>
        <trans-unit id="2138c97353c611a94eb25c7e6e46e48baedec73c" translate="yes" xml:space="preserve">
          <source>Always begins with the section header &quot;acknowledgments&quot;</source>
          <target state="translated">섹션 헤더 &quot;승인&quot;으로 항상 시작</target>
        </trans-unit>
        <trans-unit id="e2fd2ed397536c82477394e8a15b0eb70ea28108" translate="yes" xml:space="preserve">
          <source>Always begins with the section header &quot;packfile&quot;</source>
          <target state="translated">섹션 헤더 &quot;packfile&quot;로 항상 시작</target>
        </trans-unit>
        <trans-unit id="e800f612b747be24c1ecc7958dae9ec5015af129" translate="yes" xml:space="preserve">
          <source>Always begins with the section header &quot;packfile-uris&quot;.</source>
          <target state="translated">항상 섹션 헤더 &quot;packfile-uris&quot;로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="2a74cc6750711124d9f54ba56e439b92b2eb550a" translate="yes" xml:space="preserve">
          <source>Always begins with the section header &quot;shallow-info&quot;</source>
          <target state="translated">항상 &quot;shallow-info&quot;섹션 헤더로 시작</target>
        </trans-unit>
        <trans-unit id="fa34aca91ee0baeaea0934aa3e08a4599c439042" translate="yes" xml:space="preserve">
          <source>Always begins with the section header &quot;wanted-refs&quot;.</source>
          <target state="translated">섹션 헤더 &quot;wanted-refs&quot;로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="7e06c04cd8e1ea9ac30d6ef765d5374aeb2852d8" translate="yes" xml:space="preserve">
          <source>Always commit your fixes to the oldest supported branch that requires them. Then (periodically) merge the integration branches upwards into each other.</source>
          <target state="translated">항상 가장 오래된 지원되는 분기에 수정 사항을 커미트하십시오. 그런 다음 (정기적으로) 통합 분기를 서로 병합합니다.</target>
        </trans-unit>
        <trans-unit id="740206082e01fd2ec3dbefb8f6cae1ac54979d66" translate="yes" xml:space="preserve">
          <source>Always output the long format (the tag, the number of commits and the abbreviated commit name) even when it matches a tag. This is useful when you want to see parts of the commit object name in &quot;describe&quot; output, even when the commit in question happens to be a tagged version. Instead of just emitting the tag name, it will describe such a commit as v1.2-0-gdeadbee (0th commit since tag v1.2 that points at object deadbee&amp;hellip;​.).</source>
          <target state="translated">태그와 일치하는 경우에도 항상 긴 형식 (태그, 커밋 수 및 약식 커밋 이름)을 출력하십시오. 이것은 커밋이 태그 된 버전 일 때에도 &quot;describe&quot;출력에서 커밋 객체 이름의 일부를 보려는 경우에 유용합니다. 태그 이름 만 내보내는 대신 v1.2-0-gdeadbee (개체 v1.2 이후 객체 deadbee&amp;hellip;를 가리키는 0 번째 커밋)와 같은 커밋을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="10fe0db5ec22452b1b5e484a236c7996a8b1d4d4" translate="yes" xml:space="preserve">
          <source>Always publish the submodule change before publishing the change to the superproject that references it. If you forget to publish the submodule change, others won&amp;rsquo;t be able to clone the repository:</source>
          <target state="translated">변경 사항을 참조하는 수퍼 프로젝트에 변경 사항을 공개하기 전에 항상 서브 모듈 변경 사항을 공개하십시오. 하위 모듈 변경 사항을 게시하지 않으면 다른 사용자가 리포지토리를 복제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="30bc18fd1cd8bd10b1f49729296161d64c50a6de" translate="yes" xml:space="preserve">
          <source>Always use the current time and time zone. The literal &lt;code&gt;now&lt;/code&gt; must always be supplied for &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">항상 현재 시간과 시간대를 사용하십시오. 리터럴은 &lt;code&gt;now&lt;/code&gt; 항상을 위해 제공해야합니다 &lt;code&gt;&amp;lt;when&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f3edc64a04543ee397addec8da3ac8a7a4a6fa3" translate="yes" xml:space="preserve">
          <source>Always verify that the rewritten version is correct: The original refs, if different from the rewritten ones, will be stored in the namespace &lt;code&gt;refs/original/&lt;/code&gt;.</source>
          <target state="translated">다시 작성된 버전이 올바른지 항상 확인하십시오. 다시 작성된 버전과 다른 경우 원래 참조는 네임 스페이스 &lt;code&gt;refs/original/&lt;/code&gt; 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c005cc3257b6a0770843066bf6334d49c090a4e" translate="yes" xml:space="preserve">
          <source>Among the &amp;lt;reference&amp;gt;s given, display only the ones that cannot be reached from any other &amp;lt;reference&amp;gt;.</source>
          <target state="translated">주어진 &amp;lt;reference&amp;gt; 중 다른 &amp;lt;reference&amp;gt;에서 도달 할 수없는 것만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="ac6d5f7660135e74c3b73d13034cd4552f455751" translate="yes" xml:space="preserve">
          <source>An &quot;annotated tag&quot; is actually a real Git object, and contains not only a pointer to the state you want to tag, but also a small tag name and message, along with optionally a PGP signature that says that yes, you really did that tag. You create these annotated tags with either the &lt;code&gt;-a&lt;/code&gt; or &lt;code&gt;-s&lt;/code&gt; flag to &lt;code&gt;git tag&lt;/code&gt;:</source>
          <target state="translated">&quot;주석이 달린 태그&quot;는 실제로 실제 Git 객체이며, 태그하려는 상태에 대한 포인터뿐만 아니라 작은 태그 이름 및 메시지와 선택적으로 PGP 서명과 함께 포함되어 있습니다. 꼬리표. &lt;code&gt;git tag&lt;/code&gt; 에 &lt;code&gt;-a&lt;/code&gt; 또는 &lt;code&gt;-s&lt;/code&gt; 플래그를 사용하여 주석이 달린 태그를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="1268d4db5a16c4059e58835dc106857c027b0f95" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; which contains unmerged &lt;a href=&quot;#def_index_entry&quot;&gt;index entries&lt;/a&gt;.</source>
          <target state="translated">병합되지 않은 &lt;a href=&quot;#def_index_entry&quot;&gt;색인 항목&lt;/a&gt; 이 포함 된 &lt;a href=&quot;#def_index&quot;&gt;색인&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="d934873e3d430ebe475eea94d0b0f9a9f43c9fd6" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; containing a &lt;a href=&quot;#def_ref&quot;&gt;ref&lt;/a&gt; pointing to another object, which can contain a message just like a &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt;. It can also contain a (PGP) signature, in which case it is called a &quot;signed tag object&quot;.</source>
          <target state="translated">&lt;a href=&quot;#def_object&quot;&gt;객체&lt;/a&gt; 포함 &lt;a href=&quot;#def_ref&quot;&gt;REF&lt;/a&gt; A는 것처럼 메시지를 포함 할 수있는 또 다른 객체를 가리키는 &lt;a href=&quot;#def_commit_object&quot;&gt;객체를 커밋&lt;/a&gt; . 또한 (PGP) 서명을 포함 할 수 있으며이 경우 &quot;서명 된 태그 객체&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="39ba7d0e69e6d58b366781bce9a8868629216c1c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; containing a list of file names and modes along with refs to the associated blob and/or tree objects. A &lt;a href=&quot;#def_tree&quot;&gt;tree&lt;/a&gt; is equivalent to a &lt;a href=&quot;#def_directory&quot;&gt;directory&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_object&quot;&gt;객체&lt;/a&gt; 관련 BLOB 및 / 또는 트리 객체에 대한 심판과 함께 파일 이름과 모드의 목록을 포함. &lt;a href=&quot;#def_tree&quot;&gt;나무&lt;/a&gt; 에 해당 &lt;a href=&quot;#def_directory&quot;&gt;디렉토리&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c15d413f65deef5a874cba86dbad4625cd4cbd2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; used to temporarily store the contents of a &lt;a href=&quot;#def_dirty&quot;&gt;dirty&lt;/a&gt; working directory and the index for future reuse.</source>
          <target state="translated">&lt;a href=&quot;#def_dirty&quot;&gt;더티&lt;/a&gt; 작업 디렉토리 의 내용 과 향후 재사용을 위해 색인 을 임시로 저장하는 데 사용 되는 &lt;a href=&quot;#def_object&quot;&gt;객체&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0c263addb55b65fe527b2a21bf509fb6d214e692" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; which contains the information about a particular &lt;a href=&quot;#def_revision&quot;&gt;revision&lt;/a&gt;, such as &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt;, committer, author, date and the &lt;a href=&quot;#def_tree_object&quot;&gt;tree object&lt;/a&gt; which corresponds to the top &lt;a href=&quot;#def_directory&quot;&gt;directory&lt;/a&gt; of the stored revision.</source>
          <target state="translated">&lt;a href=&quot;#def_parent&quot;&gt;부모&lt;/a&gt; , 커미터, 작성자, 날짜 및 저장된 개정 의 최상위 &lt;a href=&quot;#def_directory&quot;&gt;디렉토리&lt;/a&gt; 에 해당하는 &lt;a href=&quot;#def_tree_object&quot;&gt;트리 오브젝트&lt;/a&gt; 와 같은 특정 &lt;a href=&quot;#def_revision&quot;&gt;개정&lt;/a&gt; 에 대한 정보를 포함 하는 &lt;a href=&quot;#def_object&quot;&gt;오브젝트&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="fa8c0584fca9913191dbab3d7a46ffea1d0255bd" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; which is not &lt;a href=&quot;#def_reachable&quot;&gt;reachable&lt;/a&gt; from a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt;, &lt;a href=&quot;#def_tag&quot;&gt;tag&lt;/a&gt;, or any other reference.</source>
          <target state="translated">&lt;a href=&quot;#def_object&quot;&gt;객체&lt;/a&gt; 아니다 &lt;a href=&quot;#def_reachable&quot;&gt;도달&lt;/a&gt; A로부터 &lt;a href=&quot;#def_branch&quot;&gt;지점&lt;/a&gt; , &lt;a href=&quot;#def_tag&quot;&gt;태그&lt;/a&gt; , 또는 임의의 다른 참조.</target>
        </trans-unit>
        <trans-unit id="0fa11321cf1316d583795e0fa9253aae31456769" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#def_unreachable_object&quot;&gt;unreachable object&lt;/a&gt; which is not &lt;a href=&quot;#def_reachable&quot;&gt;reachable&lt;/a&gt; even from other unreachable objects; a dangling object has no references to it from any reference or &lt;a href=&quot;#def_object&quot;&gt;object&lt;/a&gt; in the &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_unreachable_object&quot;&gt;도달 할 수없는 객체&lt;/a&gt; 되지 않습니다 &lt;a href=&quot;#def_reachable&quot;&gt;도달&lt;/a&gt; 심지어는 다른 도달 할 수없는 객체에서; 매달려있는 개체는 &lt;a href=&quot;#def_repository&quot;&gt;리포지토리의&lt;/a&gt; 참조 또는 &lt;a href=&quot;#def_object&quot;&gt;개체&lt;/a&gt; 에 대한 참조가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1f18e6fb49a003c4f6ae24bcf2f216e9b2db33c0" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;author&lt;/code&gt; command may optionally appear, if the author information might differ from the committer information. If &lt;code&gt;author&lt;/code&gt; is omitted then fast-import will automatically use the committer&amp;rsquo;s information for the author portion of the commit. See below for a description of the fields in &lt;code&gt;author&lt;/code&gt;, as they are identical to &lt;code&gt;committer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;author&lt;/code&gt; 저자 정보가 커미터 정보와 다를 수 있습니다 경우 명령은 선택적으로 나타날 수 있습니다. &lt;code&gt;author&lt;/code&gt; 가 생략 되면 fast-import는 커밋의 작성자 부분에 대해 커미터 정보를 자동으로 사용합니다. &lt;code&gt;committer&lt;/code&gt; 동일하므로 &lt;code&gt;author&lt;/code&gt; 의 필드에 대한 설명은 아래를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ca13f668178d4001fb40c21d014f07bacdba23a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;upload-archive&lt;/code&gt; also exists to serve &lt;code&gt;git archive&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;upload-archive&lt;/code&gt; 또한 제공하기 위해 존재 &lt;code&gt;git archive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2777cee48df007e662d7335b2a99199ee01a9bf5" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;object&lt;/em&gt; is identified by its 160-bit SHA-1 hash, aka &lt;em&gt;object name&lt;/em&gt;, and a reference to an object is always the 40-byte hex representation of that SHA-1 name. The files in the &lt;code&gt;refs&lt;/code&gt; subdirectory are expected to contain these hex references (usually with a final &lt;code&gt;\n&lt;/code&gt; at the end), and you should thus expect to see a number of 41-byte files containing these references in these &lt;code&gt;refs&lt;/code&gt; subdirectories when you actually start populating your tree.</source>
          <target state="translated">&lt;em&gt;목적은&lt;/em&gt; 일명, 그 160 비트 SHA-1 해시에 의해 식별되는 &lt;em&gt;오브젝트 명&lt;/em&gt; , 및 오브젝트에 대한 참조는 항상 SHA-1 이름의 바이트 40 진수 표현이다. 의 파일 &lt;code&gt;refs&lt;/code&gt; 서브 디렉토리 (일반적으로 최종 이러한 진수 참조를 포함 할 것으로 예상된다 &lt;code&gt;\n&lt;/code&gt; 말), 당신은 따라서 다음에서 이러한 참조를 포함하는 41 바이트 파일의 수를 볼 것으로 예상한다 &lt;code&gt;refs&lt;/code&gt; 하위 디렉토리가 실제로 시작 당신의 나무를 채우는 것.</target>
        </trans-unit>
        <trans-unit id="a56c50d5220ee34a87c6403dce1dee00fe1f60bc" translate="yes" xml:space="preserve">
          <source>An advanced user may want to take a look at &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout[5]&lt;/a&gt; after finishing this tutorial.</source>
          <target state="translated">고급 사용자는 이 학습서를 완료 한 후 &lt;a href=&quot;gitrepository-layout&quot;&gt;gitrepository-layout [5]&lt;/a&gt; 을 살펴볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ba7e65ac14d1c1843ebc23a20f7a824d2e90d69" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;--discard-changes&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--discard-changes&lt;/code&gt; 의 별명 .</target>
        </trans-unit>
        <trans-unit id="1c482877d68de7df403d2a569fe4e9b8337d6d28" translate="yes" xml:space="preserve">
          <source>An alternate participant submission mechanism is using the &lt;code&gt;git request-pull&lt;/code&gt; or pull-request mechanisms (e.g as used on GitHub (www.github.com) to notify your upstream of your contribution.</source>
          <target state="translated">대체 참가자 제출 메커니즘은 &lt;code&gt;git request-pull&lt;/code&gt; 또는 pull-request 메커니즘 (예 : GitHub (www.github.com)에서 사용)을 사용하여 업스트림에 기여 사실을 알리는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4308fb9f973f309f701eb31f44b62bb9dad115a0" translate="yes" xml:space="preserve">
          <source>An alternative scp-like syntax may also be used with the ssh protocol:</source>
          <target state="translated">ssh 프로토콜과 함께 대체 scp 유사 구문을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e45d63c9493efc9c482c8956b2b502b296e599f" translate="yes" xml:space="preserve">
          <source>An alternative style can be used by setting the &quot;merge.conflictStyle&quot; configuration variable to &quot;diff3&quot;. In &quot;diff3&quot; style, the above conflict may look like this:</source>
          <target state="translated">&quot;merge.conflictStyle&quot;구성 변수를 &quot;diff3&quot;으로 설정하여 대체 스타일을 사용할 수 있습니다. &quot;diff3&quot;스타일에서 위의 충돌은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b9a3606b6f09bb975ca3b2fd930ed7cfdb47c5de" translate="yes" xml:space="preserve">
          <source>An application using git-credential will typically use &lt;code&gt;git
credential&lt;/code&gt; following these steps:</source>
          <target state="translated">git-credential을 사용하는 응용 프로그램은 일반적으로 다음 단계에 따라 &lt;code&gt;git credential&lt;/code&gt; 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="ae3f33e4c0349221e2575da0576bccf42d579897" translate="yes" xml:space="preserve">
          <source>An asterisk &quot;&lt;code&gt;*&lt;/code&gt;&quot; matches anything except a slash. The character &quot;&lt;code&gt;?&lt;/code&gt;&quot; matches any one character except &quot;&lt;code&gt;/&lt;/code&gt;&quot;. The range notation, e.g. &lt;code&gt;[a-zA-Z]&lt;/code&gt;, can be used to match one of the characters in a range. See fnmatch(3) and the FNM_PATHNAME flag for a more detailed description.</source>
          <target state="translated">별표 &quot; &lt;code&gt;*&lt;/code&gt; &quot;는 슬래시를 제외한 모든 항목과 일치합니다. 문자 &quot; &lt;code&gt;?&lt;/code&gt; &quot;는 &quot; &lt;code&gt;/&lt;/code&gt; &quot;를 제외한 모든 문자와 일치합니다 . 범위 표기법 (예 : &lt;code&gt;[a-zA-Z]&lt;/code&gt; )을 사용하여 범위의 문자 중 하나를 일치시킬 수 있습니다. 자세한 설명은 fnmatch (3) 및 FNM_PATHNAME 플래그를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f92a93236adb7a911f096656f0a19e52c91fc87c" translate="yes" xml:space="preserve">
          <source>An editor will be fired up with all the commits in your current branch (ignoring merge commits), which come after the given commit. You can reorder the commits in this list to your heart&amp;rsquo;s content, and you can remove them. The list looks more or less like this:</source>
          <target state="translated">주어진 커밋 뒤에 오는 현재 분기의 모든 커밋 (병합 커밋 무시)으로 편집기가 시작됩니다. 이 목록의 커밋을 마음의 내용으로 재정렬하고 제거 할 수 있습니다. 목록은 다음과 같이 다소 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="4a20a69211227e7acfb792d7e2f72fe61b4b109b" translate="yes" xml:space="preserve">
          <source>An element with an empty value can be used to clear the list of globs accumulated from previous configuration entries. When there is no &lt;code&gt;merge.suppressDest&lt;/code&gt; variable defined, the default value of &lt;code&gt;master&lt;/code&gt; is used for backward compatibility.</source>
          <target state="translated">값이 비어있는 요소를 사용하여 이전 구성 항목에서 누적 된 glob 목록을 지울 수 있습니다. &lt;code&gt;merge.suppressDest&lt;/code&gt; 변수가 정의 되지 않은 경우 이전 버전과의 호환성을 위해 &lt;code&gt;master&lt;/code&gt; 의 기본값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3034dd5f2cb814d90a3721e980abfe2559bdf7b3" translate="yes" xml:space="preserve">
          <source>An empty color string produces no color effect at all. This can be used to avoid coloring specific elements without disabling color entirely.</source>
          <target state="translated">빈 색상 문자열은 색상 효과를 전혀 생성하지 않습니다. 색상을 완전히 비활성화하지 않고 특정 요소의 색상을 피하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2425d5d7f13cfb1e5013987fec335bdb279cc21f" translate="yes" xml:space="preserve">
          <source>An evil merge is a &lt;a href=&quot;#def_merge&quot;&gt;merge&lt;/a&gt; that introduces changes that do not appear in any &lt;a href=&quot;#def_parent&quot;&gt;parent&lt;/a&gt;.</source>
          <target state="translated">악의적 인 병합은 &lt;a href=&quot;#def_parent&quot;&gt;부모에게&lt;/a&gt; 나타나지 않는 변경 사항을 소개 하는 &lt;a href=&quot;#def_merge&quot;&gt;병합&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="983a5c1c22b13082f53d4ffac58905fc5683444c" translate="yes" xml:space="preserve">
          <source>An example crash:</source>
          <target state="translated">충돌 예 :</target>
        </trans-unit>
        <trans-unit id="b7fefb821701ed8916b003bdc64ab026062f47d5" translate="yes" xml:space="preserve">
          <source>An example directly producing formatted text. Show the most recent 3 tagged commits:</source>
          <target state="translated">서식있는 텍스트를 직접 생성하는 예제입니다. 가장 최근에 태그 된 커밋 3 개 표시 :</target>
        </trans-unit>
        <trans-unit id="07b3f3938c0999bf8d07073e13ae4fad78c37982" translate="yes" xml:space="preserve">
          <source>An example to show the usage of %(if)&amp;hellip;​%(then)&amp;hellip;​%(else)&amp;hellip;​%(end). This prefixes the current branch with a star.</source>
          <target state="translated">% (if)&amp;hellip; % (then)&amp;hellip; % (else)&amp;hellip; % (end)의 사용법을 보여주는 예제입니다. 현재 분기 앞에 별표가 붙습니다.</target>
        </trans-unit>
        <trans-unit id="130d3057e79f4ea0755954d533ec854202e8c665" translate="yes" xml:space="preserve">
          <source>An example to show the usage of %(if)&amp;hellip;​%(then)&amp;hellip;​%(end). This prints the authorname, if present.</source>
          <target state="translated">% (if)&amp;hellip; % (then)&amp;hellip; % (end)의 사용법을 보여주는 예제입니다. 저자 이름이 있으면 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="0dd4a6b345a98548ae1d0552b0faaa4bc7a8afb7" translate="yes" xml:space="preserve">
          <source>An example to use customized color from the configuration in your script:</source>
          <target state="translated">스크립트의 구성에서 사용자 정의 된 색상을 사용하는 예 :</target>
        </trans-unit>
        <trans-unit id="5e3fe250825ac46db801c9bc9679b73fba035132" translate="yes" xml:space="preserve">
          <source>An example value is &amp;ldquo;Tue Feb 6 11:22:18 2007 -0500&amp;rdquo;. The Git parser is accurate, but a little on the lenient side. It is the same parser used by &lt;code&gt;git am&lt;/code&gt; when applying patches received from email.</source>
          <target state="translated">예를 들어 &quot;화 2 월 6 일 11:22:18 2007 -0500&quot;입니다. Git 파서는 정확하지만 관대 한 편이다. 이메일에서받은 패치를 적용 할 때 &lt;code&gt;git am&lt;/code&gt; 에서 사용하는 것과 동일한 파서 입니다.</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="67bf2af305e53a13545716b037aa5bc68e4afad9" translate="yes" xml:space="preserve">
          <source>An example: in an SVN repository with a standard trunk/tags/branches layout, a directory trunk/sub is created in r.100. In r.200, trunk/sub is branched by copying it to branches/. &lt;code&gt;git svn clone -s&lt;/code&gt; will then create a branch &lt;code&gt;sub&lt;/code&gt;. It will also create new Git commits for r.100 through r.199 and use these as the history of branch &lt;code&gt;sub&lt;/code&gt;. Thus there will be two Git commits for each revision from r.100 to r.199 (one containing trunk/, one containing trunk/sub/). Finally, it will create a branch &lt;code&gt;sub@200&lt;/code&gt; pointing to the new parent commit of branch &lt;code&gt;sub&lt;/code&gt; (i.e. the commit for r.200 and trunk/sub/).</source>
          <target state="translated">예 : 표준 트렁크 / 태그 / 분기 레이아웃이있는 SVN 저장소에서 디렉토리 트렁크 / 서브는 r.100에 생성됩니다. r.200에서 트렁크 / 서브는 분기 /에 복사하여 분기됩니다. 그런 다음 &lt;code&gt;git svn clone -s&lt;/code&gt; 는 분기 &lt;code&gt;sub&lt;/code&gt; 를 만듭니다 . 또한 r.100에서 r.199까지 새로운 Git 커밋을 생성하고이를 분기 &lt;code&gt;sub&lt;/code&gt; 의 히스토리로 사용합니다 . 따라서 r.100에서 r.199까지 각 개정에 대해 두 개의 Git 커밋이 있습니다 (하나는 트렁크 / 포함, 하나는 트렁크 / 서브 / 포함). 마지막으로, 분기 만듭니다 &lt;code&gt;sub@200&lt;/code&gt; 새로운 부모를 가리키는 브랜치의 커밋 &lt;code&gt;sub&lt;/code&gt; 합니다 (이 r.200 및 트렁크 / 부 / 커밋 즉).</target>
        </trans-unit>
        <trans-unit id="7e6df9fde9d9b1a6c24b6fde6ccfb6d951abd515" translate="yes" xml:space="preserve">
          <source>An existing tree object.</source>
          <target state="translated">기존 트리 개체</target>
        </trans-unit>
        <trans-unit id="9c0f47829cd53aff363faaa441d2662f7d2a2298" translate="yes" xml:space="preserve">
          <source>An extended regular expression configuring a set of delta islands. See &quot;DELTA ISLANDS&quot; in &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; for details.</source>
          <target state="translated">델타 아일랜드 세트를 구성하는 확장 정규식. 자세한 내용은 &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]의&lt;/a&gt; &quot;DELTA ISLANDS&quot; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e8771c0542061da31756f7f028cf42efc80a6790" translate="yes" xml:space="preserve">
          <source>An integer -1..9, indicating a default compression level. -1 is the zlib default. 0 means no compression, and 1..9 are various speed/size tradeoffs, 9 being slowest. If set, this provides a default to other compression variables, such as &lt;code&gt;core.looseCompression&lt;/code&gt; and &lt;code&gt;pack.compression&lt;/code&gt;.</source>
          <target state="translated">기본 압축 수준을 나타내는 정수 -1..9. -1이 zlib 기본값입니다. 0은 압축이 없음을 의미하고 1..9는 다양한 속도 / 크기 트레이드 오프이며 9는 가장 느립니다. 설정하면 &lt;code&gt;core.looseCompression&lt;/code&gt; 및 &lt;code&gt;pack.compression&lt;/code&gt; 과 같은 다른 압축 변수에 기본값을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="433b558671525ba8e4d4299bcca156947818bc47" translate="yes" xml:space="preserve">
          <source>An integer -1..9, indicating the compression level for objects in a pack file. -1 is the zlib default. 0 means no compression, and 1..9 are various speed/size tradeoffs, 9 being slowest. If not set, defaults to core.compression. If that is not set, defaults to -1, the zlib default, which is &quot;a default compromise between speed and compression (currently equivalent to level 6).&quot;</source>
          <target state="translated">팩 파일에서 객체의 압축 수준을 나타내는 정수 -1..9. -1이 zlib 기본값입니다. 0은 압축이 없음을 의미하고 1..9는 다양한 속도 / 크기 트레이드 오프이며 9는 가장 느립니다. 설정하지 않으면 기본값은 core.compression입니다. 이것이 설정되어 있지 않은 경우, 기본값은 -1, zlib 기본값이며, &quot;속도와 압축의 기본 절충안입니다 (현재 수준 6과 동일)&quot;.</target>
        </trans-unit>
        <trans-unit id="e06d94c2c1c7fdd4fbd64a16fb4219ebbe8c1e07" translate="yes" xml:space="preserve">
          <source>An integer -1..9, indicating the compression level for objects that are not in a pack file. -1 is the zlib default. 0 means no compression, and 1..9 are various speed/size tradeoffs, 9 being slowest. If not set, defaults to core.compression. If that is not set, defaults to 1 (best speed).</source>
          <target state="translated">팩 파일에없는 오브젝트의 압축 레벨을 나타내는 정수 -1..9. -1이 zlib 기본값입니다. 0은 압축이 없음을 의미하고 1..9는 다양한 속도 / 크기 트레이드 오프이며 9는 가장 느립니다. 설정하지 않으면 기본값은 core.compression입니다. 설정하지 않으면 기본값은 1 (최고 속도)입니다.</target>
        </trans-unit>
        <trans-unit id="7a8d9172fe4750854d99468288f15a393b3d2a0b" translate="yes" xml:space="preserve">
          <source>An integer parameter specifies a cut-off percent (3% by default). Directories contributing less than this percentage of the changes are not shown in the output.</source>
          <target state="translated">정수 매개 변수는 컷오프 백분율 (기본적으로 3 %)을 지정합니다. 이 백분율의 변경 사항보다 적은 기여를하는 디렉토리는 출력에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71479e10da1fa6d725307efac957175acd0b7dab" translate="yes" xml:space="preserve">
          <source>An integer port number to connect to on the server. Defaults to 143 for imap:// hosts and 993 for imaps:// hosts. Ignored when imap.tunnel is set.</source>
          <target state="translated">서버에서 연결할 정수 포트 번호입니다. imap : // 호스트의 경우 기본값은 143이고 imaps : // 호스트의 경우 993입니다. imap.tunnel이 설정되면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a13bd69f2aba7e28daf03425a855478a0ac87c0e" translate="yes" xml:space="preserve">
          <source>An object to treat as the head of an unreachability trace.</source>
          <target state="translated">도달 불가능 추적의 헤드로 취급 할 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="649450686ab487a5807b370d54f0bd2d0e6521d8" translate="yes" xml:space="preserve">
          <source>An offset within the jth packfile for the object.</source>
          <target state="translated">객체의 j 번째 팩 파일 내 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="13fd616698d842e6abe0ccbaaa14a722ac806da4" translate="yes" xml:space="preserve">
          <source>An optimized way to tell git &quot;all files have changed&quot; is to return the filename &lt;code&gt;/&lt;/code&gt;.</source>
          <target state="translated">git에게 &quot;모든 파일이 변경되었다&quot;고 알리는 가장 좋은 방법은 파일 이름 &lt;code&gt;/&lt;/code&gt; 를 반환하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="2683b05f238ac5f24ee58eef90d2e93c4d292853" translate="yes" xml:space="preserve">
          <source>An optional prefix &quot;&lt;code&gt;!&lt;/code&gt;&quot; which negates the pattern; any matching file excluded by a previous pattern will become included again. It is not possible to re-include a file if a parent directory of that file is excluded. Git doesn&amp;rsquo;t list excluded directories for performance reasons, so any patterns on contained files have no effect, no matter where they are defined. Put a backslash (&quot;&lt;code&gt;\&lt;/code&gt;&quot;) in front of the first &quot;&lt;code&gt;!&lt;/code&gt;&quot; for patterns that begin with a literal &quot;&lt;code&gt;!&lt;/code&gt;&quot;, for example, &quot;&lt;code&gt;\!important!.txt&lt;/code&gt;&quot;.</source>
          <target state="translated">패턴을 무효화 하는 선택적 접두사 &quot; &lt;code&gt;!&lt;/code&gt; &quot; 이전 패턴에서 제외 된 일치하는 파일은 다시 포함됩니다. 해당 파일의 상위 디렉토리가 제외 된 경우 파일을 다시 포함 할 수 없습니다. Git은 성능상의 이유로 제외 된 디렉토리를 나열하지 않으므로 포함 된 파일의 패턴은 정의 된 위치에 관계없이 영향을 미치지 않습니다. 리터럴 &quot; &lt;code&gt;!&lt;/code&gt; &quot;로 시작하는 패턴 ( 예 : &quot; &lt;code&gt;\!important!.txt&lt;/code&gt; &quot; )의 경우 첫 번째 &quot; &lt;code&gt;!&lt;/code&gt; &quot; 앞에 백 슬래시 ( &quot; &lt;code&gt;\&lt;/code&gt; &quot;)를 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="72eb40b71a3ee1287d4bc59941eb7d52450fb0cd" translate="yes" xml:space="preserve">
          <source>An output line is formatted this way:</source>
          <target state="translated">출력 라인은 다음과 같이 포맷됩니다 :</target>
        </trans-unit>
        <trans-unit id="ec0a220b9a0ca7fed3c65efd073215d72dcdf226" translate="yes" xml:space="preserve">
          <source>An overview of recommended workflows with Git</source>
          <target state="translated">Git의 권장 워크 플로 개요</target>
        </trans-unit>
        <trans-unit id="39328bc4d54c0b1f8244ab4fbfc2b0861f3ec8b7" translate="yes" xml:space="preserve">
          <source>An update will fail (without changing &amp;lt;ref&amp;gt;) if the current user is unable to create a new log file, append to the existing log file or does not have committer information available.</source>
          <target state="translated">현재 사용자가 새 로그 파일을 만들 수 없거나 기존 로그 파일에 추가하거나 커미터 정보를 사용할 수없는 경우 업데이트가 실패합니다 (&amp;lt;ref&amp;gt; 변경하지 않음).</target>
        </trans-unit>
        <trans-unit id="dc6309284d4ffb9f9db9b99bb2400d242ab3d042" translate="yes" xml:space="preserve">
          <source>Ancillary Commands</source>
          <target state="translated">보조 명령</target>
        </trans-unit>
        <trans-unit id="690298b04d34764749d8b6b774f1017ccff2bdf1" translate="yes" xml:space="preserve">
          <source>And &quot;p4 branch -o branch1&quot; shows a View line that looks like:</source>
          <target state="translated">&quot;p4 branch -o branch1&quot;은 다음과 같은 뷰 라인을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="06312e404b0eeaa83f6e7b08d3417e9f32eb7193" translate="yes" xml:space="preserve">
          <source>And &lt;code&gt;echo HEAD:link | git cat-file --batch --follow-symlinks&lt;/code&gt; would print the same thing, as would &lt;code&gt;HEAD:dir/link&lt;/code&gt;, as they both point at &lt;code&gt;HEAD:f&lt;/code&gt;.</source>
          <target state="translated">그리고 &lt;code&gt;echo HEAD:link | git cat-file --batch --follow-symlinks&lt;/code&gt; 는 &lt;code&gt;HEAD:dir/link&lt;/code&gt; 와 같이 &lt;code&gt;HEAD:f&lt;/code&gt; 를 가리키는 것과 동일한 것을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="e8ef2a07032d9e5ab4fbc79e4cc5adecbcbea354" translate="yes" xml:space="preserve">
          <source>And after a few more steps like that, &quot;git bisect&quot; will eventually find a first bad commit:</source>
          <target state="translated">그리고 이와 같은 몇 가지 단계를 더 수행하면 &quot;git bisect&quot;는 결국 첫 번째 잘못된 커밋을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="5e2acfea5a7223f44ca9fe3e573c07079e7f8361" translate="yes" xml:space="preserve">
          <source>And even if a bisection fails today it tells us something valuable about the bug: that it&amp;rsquo;s non-deterministic - timing or kernel image layout dependent.</source>
          <target state="translated">그리고 오늘날 이분법이 실패하더라도 버그에 대해 가치있는 것을 알려줍니다. 타이밍이나 커널 이미지 레이아웃에 따라 결정적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85f0203157ace1141f1dde2ae30a3fa8a3636c88" translate="yes" xml:space="preserve">
          <source>And finally create the final commit.</source>
          <target state="translated">그리고 마지막 커밋을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="860e42dc488be31ffa7a020df965384765242565" translate="yes" xml:space="preserve">
          <source>And here is what Andreas said about this work-flow &lt;a href=&quot;#5&quot;&gt;[5]&lt;/a&gt;:</source>
          <target state="translated">Andreas가이 작업 흐름에 대해 말한 내용은 다음과 같습니다 &lt;a href=&quot;#5&quot;&gt;[5]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="01892e1eb858acb775eb9592a4003c7fc4445cdb" translate="yes" xml:space="preserve">
          <source>And if some bugs slip through your test suite, then you can add a test to your test suite. But if you want to use your new improved test suite to find where the bug slipped in, then you will either have to emulate a bisection process or you will perhaps bluntly test each commit backward starting from the &quot;bad&quot; commit you have which may be very wasteful.</source>
          <target state="translated">테스트 스위트를 통해 버그가 발생하면 테스트 스위트에 테스트를 추가 할 수 있습니다. 그러나 새로운 개선 된 테스트 스위트를 사용하여 버그가 발생한 위치를 찾으려면 이분법 프로세스를 에뮬레이션해야 할 수도 있고 아마도 &quot;나쁜&quot;커밋에서 시작하여 각 커밋을 무심코 테스트해야 할 수도 있습니다. 매우 낭비입니다.</target>
        </trans-unit>
        <trans-unit id="15b39a143fb8659118caee67f4b21c31bc36bf3c" translate="yes" xml:space="preserve">
          <source>And it is possible to replay it using:</source>
          <target state="translated">다음을 사용하여 재생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75822a1512d331a3d4633273030648c95f9328f4" translate="yes" xml:space="preserve">
          <source>And let&amp;rsquo;s take a commit X in the graph.</source>
          <target state="translated">그리고 그래프에서 커밋 X를 봅시다.</target>
        </trans-unit>
        <trans-unit id="f4b0d8092d1f5d252ea539a91373ab642092fc55" translate="yes" xml:space="preserve">
          <source>And move the first patch to the end of the list.</source>
          <target state="translated">그리고 첫 번째 패치를 목록의 끝으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="43f0cc168dfe6f57e4c3a310a06a6b6b3c95713b" translate="yes" xml:space="preserve">
          <source>And of course you can combine all of these; the following finds commits since v2.5 which touch the &lt;code&gt;Makefile&lt;/code&gt; or any file under &lt;code&gt;fs&lt;/code&gt;:</source>
          <target state="translated">물론이 모든 것을 결합 할 수 있습니다. 다음은 &lt;code&gt;Makefile&lt;/code&gt; 또는 &lt;code&gt;fs&lt;/code&gt; 아래의 파일 을 터치하는 v2.5 이후 커밋을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="4c90b40159743f0c37c98cf280277c74b4f36f16" translate="yes" xml:space="preserve">
          <source>And testing can be done more often in special integration branches like linux-next for the linux kernel.</source>
          <target state="translated">그리고 리눅스 커널을위한 linux-next와 같은 특별한 통합 브랜치에서 테스트를 더 자주 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de647a064a0da49ca37de783bfbd65b321bef2ec" translate="yes" xml:space="preserve">
          <source>And then this is what Ingo Molnar (a well known Linux kernel developer) says about his use of git bisect:</source>
          <target state="translated">그리고 이것은 Ingo Molnar (잘 알려진 Linux 커널 개발자)가 git bisect 사용에 대해 말한 것입니다.</target>
        </trans-unit>
        <trans-unit id="66491a56d29baec4b0beb6e367fe2e638c6cc60b" translate="yes" xml:space="preserve">
          <source>And then we can ask to see all the commits reachable from master but not from these other heads:</source>
          <target state="translated">그리고 우리는 모든 커밋을 마스터가 도달 할 수 있지만 다른 헤드는 도달하지 못하도록 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a65c6aab9ccb89445d5895ed004afd6ead95252c" translate="yes" xml:space="preserve">
          <source>And then:</source>
          <target state="translated">그리고:</target>
        </trans-unit>
        <trans-unit id="dc5ba14bf614a8d9b59a130fcae6a5153ba0970b" translate="yes" xml:space="preserve">
          <source>And this is nice because at step 2) we compute number_of_ancestors(X) and so at step 3) we compute f(X).</source>
          <target state="translated">그리고 이것은 2) 단계에서 number_of_ancestors (X)를 계산하고 3 단계에서 f (X)를 계산하기 때문에 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8cc4b2a34ee7e169dafe705c6dd15bf4f2ab80f2" translate="yes" xml:space="preserve">
          <source>And this is true because at step 1) b) we remove the ancestors of the &quot;good&quot; commits.</source>
          <target state="translated">그리고 이것은 1) 단계 b) &quot;좋은&quot;커밋의 조상을 제거하기 때문에 사실입니다.</target>
        </trans-unit>
        <trans-unit id="42d3703f66b9dc1860841e2625f510f6dad5a4b2" translate="yes" xml:space="preserve">
          <source>And this is where we create the &lt;code&gt;.git/refs/heads/master&lt;/code&gt; file which is pointed at by &lt;code&gt;HEAD&lt;/code&gt;. This file is supposed to contain the reference to the top-of-tree of the master branch, and since that&amp;rsquo;s exactly what &lt;code&gt;git commit-tree&lt;/code&gt; spits out, we can do this all with a sequence of simple shell commands:</source>
          <target state="translated">그리고 여기서 &lt;code&gt;HEAD&lt;/code&gt; 가 가리키는 &lt;code&gt;.git/refs/heads/master&lt;/code&gt; 파일을 만듭니다. 이 파일에는 마스터 브랜치의 최상위 트리에 대한 참조가 포함되어 있으며, &lt;code&gt;git commit-tree&lt;/code&gt; 가 뱉어 낸 것이므로 일련의 간단한 쉘 명령 으로이 모든 것을 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e7a1c872c4878ac6e52bac1154940404cb212eeb" translate="yes" xml:space="preserve">
          <source>And when we are finished we can use &quot;git bisect reset&quot; to go back to the branch we were in before we started bisecting:</source>
          <target state="translated">그리고 우리가 끝나면 &quot;git bisect reset&quot;을 사용하여 bisecting을 시작하기 전의 지점으로 돌아갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36ca616a13091cd678c7050cbd59b751c0ca0cb5" translate="yes" xml:space="preserve">
          <source>And yes it can happen in practice that people working on one branch are not aware that people working on another branch fixed a bug! It could also happen that F fixed more than one bug or that it is a revert of some big development effort that was not ready to be released.</source>
          <target state="translated">그리고 실제로는 한 지점에서 일하는 사람들이 다른 지점에서 일하는 사람들이 버그를 수정했다는 것을 인식하지 못할 수 있습니다! F가 하나 이상의 버그를 수정했거나 출시되지 않은 일부 큰 개발 노력을 되돌려 놓은 것일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc2b5b20cbff6f0447bfb79a46815513c19063a1" translate="yes" xml:space="preserve">
          <source>And, as you can see with cat-file, this new entry refers to the current contents of the file:</source>
          <target state="translated">cat-file에서 볼 수 있듯이이 새 항목은 파일의 현재 내용을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a03f7e1dc1779f7a6b6058b743b6c59117c067d5" translate="yes" xml:space="preserve">
          <source>Annotate file lines with commit information</source>
          <target state="translated">커밋 정보로 파일 라인에 주석 달기</target>
        </trans-unit>
        <trans-unit id="fe64bd304ff43d1f92c6b0e9e2636f5e1954515e" translate="yes" xml:space="preserve">
          <source>Annotate only the given line range. May be specified multiple times. Overlapping ranges are allowed.</source>
          <target state="translated">주어진 선 범위에만 주석을 답니다. 여러 번 지정할 수 있습니다. 겹치는 범위가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a4227402e63911eeddf3891b83571a9d301c5199" translate="yes" xml:space="preserve">
          <source>Annotated tags are meant for release while lightweight tags are meant for private or temporary object labels. For this reason, some git commands for naming objects (like &lt;code&gt;git describe&lt;/code&gt;) will ignore lightweight tags by default.</source>
          <target state="translated">주석이 달린 태그는 릴리스 용이며 경량 태그는 개인용 또는 임시 객체 레이블 용입니다. 이러한 이유로 객체 이름 지정을위한 일부 git 명령 ( &lt;code&gt;git describe&lt;/code&gt; 등 )은 기본적으로 경량 태그를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="fb074164892a20bb11edd02087ea8ad1467c6bc3" translate="yes" xml:space="preserve">
          <source>Annotated tags can be accidentally converted to lightweight tags, due to either of two issues:</source>
          <target state="translated">주석이 달린 태그는 다음 두 가지 문제 중 하나로 인해 실수로 가벼운 태그로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78661c20ec385a35ca13b1d1faa523521f8f6f6e" translate="yes" xml:space="preserve">
          <source>Annotates each line in the given file with information from the commit which introduced the line. Optionally annotates from a given revision.</source>
          <target state="translated">주어진 파일의 각 줄에 줄을 도입 한 커밋 정보를 주석으로 표시합니다. 주어진 개정판에서 주석을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="372eac78f459ab911a94fedbdc320e48ccdbf71b" translate="yes" xml:space="preserve">
          <source>Annotates each line in the given file with information from the revision which last modified the line. Optionally, start annotating from the given revision.</source>
          <target state="translated">주어진 파일의 각 행에 마지막으로 수정 한 개정판의 정보를 표시합니다. 선택적으로 주어진 개정판에서 주석을 달기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="b09d247a13d19963c95ef0e9b47f19d8e2953d8d" translate="yes" xml:space="preserve">
          <source>Anonymize the contents of the repository while still retaining the shape of the history and stored tree. See the section on &lt;code&gt;ANONYMIZING&lt;/code&gt; below.</source>
          <target state="translated">히스토리 및 저장된 트리의 모양을 유지하면서 저장소의 컨텐츠를 익명화하십시오. 아래의 &lt;code&gt;ANONYMIZING&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a01e013ecca5b260c6867926bf1ecfcf398d9ba1" translate="yes" xml:space="preserve">
          <source>Anonymizing</source>
          <target state="translated">Anonymizing</target>
        </trans-unit>
        <trans-unit id="40a85528d14ebc97736a92adba47c86eb9ff2aeb" translate="yes" xml:space="preserve">
          <source>Another example of --onto option is to rebase part of a branch. If we have the following situation:</source>
          <target state="translated">--onto 옵션의 또 다른 예는 분기의 일부를 리베이스하는 것입니다. 다음과 같은 상황이 발생하면</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">다른 예시:</target>
        </trans-unit>
        <trans-unit id="11987472d58c6aa8430ac38a3fd3bf9cba4916dd" translate="yes" xml:space="preserve">
          <source>Another example: Find out what to do in order to make some script a builtin:</source>
          <target state="translated">또 다른 예 : 일부 스크립트를 내장하기 위해 수행 할 작업을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="065628e1fb0324bb656fd86df1e08ab2f4715fb3" translate="yes" xml:space="preserve">
          <source>Another good idea is to have good commit messages. They can be very helpful to understand why some changes were made.</source>
          <target state="translated">또 다른 좋은 아이디어는 좋은 커밋 메시지를 갖는 것입니다. 일부 변경이 이루어진 이유를 이해하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32dd386169e45600451de31b5f03542af4e30d00" translate="yes" xml:space="preserve">
          <source>Another nice thing you can do is:</source>
          <target state="translated">당신이 할 수있는 또 다른 좋은 일은 :</target>
        </trans-unit>
        <trans-unit id="9242e709d07837df4600256193a227ac34a2269c" translate="yes" xml:space="preserve">
          <source>Another option is &quot;updateInstead&quot; which will update the working tree if pushing into the current branch. This option is intended for synchronizing working directories when one side is not easily accessible via interactive ssh (e.g. a live web site, hence the requirement that the working directory be clean). This mode also comes in handy when developing inside a VM to test and fix code on different Operating Systems.</source>
          <target state="translated">또 다른 옵션은 &quot;updateInstead&quot;로, 현재 분기로 밀면 작업 트리를 업데이트합니다. 이 옵션은 대화식 ssh를 통해 한쪽에 쉽게 액세스 할 수없는 경우 작업 디렉토리를 동기화하기위한 것입니다 (예 : 라이브 웹 사이트, 따라서 작업 디렉토리가 깨끗해야 함). 이 모드는 다른 운영 체제에서 코드를 테스트하고 수정하기 위해 VM 내부에서 개발할 때도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="41abbfafae0720017768935474ce8290c706a151" translate="yes" xml:space="preserve">
          <source>Another possible improvement to &quot;git bisect&quot; would be to optionally add some redundancy to the tests performed so that it would be more reliable when tracking sporadic bugs.</source>
          <target state="translated">&quot;git bisect&quot;에 대한 또 다른 가능한 개선 사항은 산발적 인 버그를 추적 할 때 더욱 신뢰할 수 있도록 수행 된 테스트에 중복성을 선택적으로 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0a6527778973bccd7f71c735f492db2e31da9fa5" translate="yes" xml:space="preserve">
          <source>Another special notation is &quot;&lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt;&amp;hellip;​&lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt;&quot; which is useful for merges. The resulting set of commits is the symmetric difference between the two operands. The following two commands are equivalent:</source>
          <target state="translated">또 다른 특별한 표기법은 &quot; &lt;code&gt;&amp;lt;commit1&amp;gt;&lt;/code&gt; ... &lt;code&gt;&amp;lt;commit2&amp;gt;&lt;/code&gt; &quot;병합에 유용하다. 결과 커밋 세트는 두 피연산자 간의 대칭 적 차이입니다. 다음 두 명령은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="26135d7c8f5f59da8beefa37e9b70a51b7cf91c1" translate="yes" xml:space="preserve">
          <source>Another tricky thing is fully repopulating the working directory when you no longer want sparse checkout. You cannot just disable &quot;sparse checkout&quot; because skip-worktree bits are still in the index and your working directory is still sparsely populated. You should re-populate the working directory with the &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; file content as follows:</source>
          <target state="translated">또 다른 까다로운 것은 더 이상 스파 스 체크 아웃을 원하지 않을 때 작업 디렉토리를 완전히 다시 채우는 것입니다. skip-worktree 비트가 여전히 색인에 있고 작업 디렉토리가 여전히 희박하므로 &quot;스파 스 체크 아웃&quot;을 비활성화 할 수 없습니다. 다음과 같이 &lt;code&gt;$GIT_DIR/info/sparse-checkout&lt;/code&gt; 파일 내용으로 작업 디렉토리를 다시 채워야합니다 .</target>
        </trans-unit>
        <trans-unit id="ecb7d4f32d7593e5037a022410f521fabccc479c" translate="yes" xml:space="preserve">
          <source>Another use of the content filtering is to store the content that cannot be directly used in the repository (e.g. a UUID that refers to the true content stored outside Git, or an encrypted content) and turn it into a usable form upon checkout (e.g. download the external content, or decrypt the encrypted content).</source>
          <target state="translated">콘텐츠 필터링의 또 다른 용도는 리포지토리에서 직접 사용할 수없는 콘텐츠 (예 : Git 외부에 저장된 실제 콘텐츠를 참조하는 UUID 또는 암호화 된 콘텐츠)를 저장하고 체크 아웃시 사용 가능한 형식으로 전환하는 것입니다 (예 : 다운로드) 외부 콘텐츠 또는 암호화 된 콘텐츠를 해독).</target>
        </trans-unit>
        <trans-unit id="1d8a0103b0697a268e7a45a45f3916e77fac0c3e" translate="yes" xml:space="preserve">
          <source>Another useful tool, especially if you do not always work in X-Window environment, is &lt;code&gt;git show-branch&lt;/code&gt;.</source>
          <target state="translated">다른 유용한 도구, 특히 X-Window 환경에서 항상 작동하지 않는 경우 &lt;code&gt;git show-branch&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d7b5fb1eb9536e4fd859b841771a0add7272b354" translate="yes" xml:space="preserve">
          <source>Another way to collaborate is by using a model similar to that commonly used in CVS, where several developers with special rights all push to and pull from a single shared repository. See &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt; for instructions on how to set this up.</source>
          <target state="translated">공동 작업을 수행하는 또 다른 방법은 CVS에서 일반적으로 사용되는 것과 유사한 모델을 사용하는 것입니다. 여기서는 특별한 권한을 가진 여러 개발자가 모두 단일 공유 리포지토리를 사용합니다. 이를 설정하는 방법에 대한 지침 은 &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration [7]&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27bf2b0b2701454d4c7012f3aa28342f714d532f" translate="yes" xml:space="preserve">
          <source>Another way to submit changes to a project is to tell the maintainer of that project to pull the changes from your repository using &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt;. In the section &quot;&lt;a href=&quot;#getting-updates-With-git-pull&quot;&gt;Getting updates with &lt;code&gt;git pull&lt;/code&gt;&lt;/a&gt;&quot; we described this as a way to get updates from the &quot;main&quot; repository, but it works just as well in the other direction.</source>
          <target state="translated">프로젝트에 변경 사항을 제출하는 또 다른 방법은 해당 프로젝트의 관리자에게 &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]을&lt;/a&gt; 사용하여 저장소에서 변경 사항을 가져 오도록 지시하는 것 입니다. &quot; &lt;a href=&quot;#getting-updates-With-git-pull&quot;&gt; &lt;code&gt;git pull&lt;/code&gt; 을 사용&lt;/a&gt; 하여 업데이트 받기 &quot;섹션 에서이를 &quot;주&quot;리포지토리에서 업데이트를 가져 오는 방법으로 설명했지만 다른 방향으로도 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="85d232111ed1b21837987efa570715d6d841ade7" translate="yes" xml:space="preserve">
          <source>Any Git command accepting any &amp;lt;object&amp;gt; can also use the following symbolic notation:</source>
          <target state="translated">&amp;lt;object&amp;gt;를 허용하는 모든 Git 명령은 다음과 같은 기호 표기법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2637aa3ab721e22e9e92fa0dc5c3b142c43c70b8" translate="yes" xml:space="preserve">
          <source>Any Git command that needs to know a commit can take any of these names. For example:</source>
          <target state="translated">커밋을 알아야하는 Git 명령은이 이름을 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="17e0ecc60216ae45d014af4558855c0627e28395" translate="yes" xml:space="preserve">
          <source>Any URL that starts with this value will be rewritten to start, instead, with &amp;lt;base&amp;gt;. In cases where some site serves a large number of repositories, and serves them with multiple access methods, and some users need to use different access methods, this feature allows people to specify any of the equivalent URLs and have Git automatically rewrite the URL to the best alternative for the particular user, even for a never-before-seen repository on the site. When more than one insteadOf strings match a given URL, the longest match is used.</source>
          <target state="translated">이 값으로 시작하는 URL은 &amp;lt;base&amp;gt;로 시작하도록 다시 작성됩니다. 일부 사이트가 많은 수의 리포지토리를 제공하고 여러 액세스 방법으로 제공하는 경우 일부 사용자가 다른 액세스 방법을 사용해야하는 경우이 기능을 통해 사람들은 동등한 URL을 지정하고 Git이 자동으로 URL을 사이트에서 전혀 볼 수없는 리포지토리에서도 특정 사용자를위한 최상의 대안입니다. 지정된 URL과 일치하는 문자열이 둘 이상인 경우 가장 긴 일치가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="589cf27f168023444a88c2fd0201931be3237bfb" translate="yes" xml:space="preserve">
          <source>Any URL that starts with this value will not be pushed to; instead, it will be rewritten to start with &amp;lt;base&amp;gt;, and the resulting URL will be pushed to. In cases where some site serves a large number of repositories, and serves them with multiple access methods, some of which do not allow push, this feature allows people to specify a pull-only URL and have Git automatically use an appropriate URL to push, even for a never-before-seen repository on the site. When more than one pushInsteadOf strings match a given URL, the longest match is used. If a remote has an explicit pushurl, Git will ignore this setting for that remote.</source>
          <target state="translated">이 값으로 시작하는 URL은 푸시되지 않습니다. 대신 &amp;lt;base&amp;gt;로 시작하도록 다시 작성되고 결과 URL이 푸시됩니다. 일부 사이트가 많은 수의 리포지토리를 제공하고 여러 액세스 방법으로 제공하는 경우 (이 중 일부는 푸시를 허용하지 않는 경우)이 기능을 사용하면 사람들이 풀 전용 URL을 지정하고 Git이 자동으로 적절한 URL을 사용하여 푸시하도록 할 수 있습니다. 사이트에서 본 적이없는 리포지토리의 경우에도 마찬가지입니다. 하나 이상의 pushInsteadOf 문자열이 지정된 URL과 일치하면 가장 긴 일치가 사용됩니다. 리모트에 명시적인 pushurl이 있으면 Git은 해당 리모트에 대한이 설정을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="82a7e54a4e4438b5714cd3ea8d9c648126a4d9c8" translate="yes" xml:space="preserve">
          <source>Any arguments that control the behaviour of the action.</source>
          <target state="translated">조치의 동작을 제어하는 ​​인수</target>
        </trans-unit>
        <trans-unit id="90454bd170fd9408c974e42887247b5e22880026" translate="yes" xml:space="preserve">
          <source>Any commit messages that specify an encoding will become corrupted by the rewrite; git-filter-branch ignores the encoding, takes the original bytes, and feeds it to commit-tree without telling it the proper encoding. (This happens whether or not --msg-filter is used.)</source>
          <target state="translated">인코딩을 지정하는 커밋 메시지는 다시 쓰면 손상됩니다. git-filter-branch는 인코딩을 무시하고 원래 바이트를 가져 와서 적절한 인코딩을 알리지 않고 커밋 트리에 공급합니다. --msg-filter 사용 여부에 관계없이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5b932d4d430aaf425c61def387b1d5f7272350dc" translate="yes" xml:space="preserve">
          <source>Any commits (or tags) that have already been marked will not be exported again. If the backend uses a similar --import-marks file, this allows for incremental bidirectional exporting of the repository by keeping the marks the same across runs.</source>
          <target state="translated">이미 표시된 커밋 (또는 태그)은 다시 내 보내지 않습니다. 백엔드가 유사한 --import-marks 파일을 사용하는 경우, 실행에서 마크를 동일하게 유지하여 저장소를 양방향으로 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3f9b66d28d85d6e19fdb5a2a58f610b82508a43" translate="yes" xml:space="preserve">
          <source>Any corrupt objects you will have to find in backups or other archives (i.e., you can just remove them and do an &lt;code&gt;rsync&lt;/code&gt; with some other site in the hopes that somebody else has the object you have corrupted).</source>
          <target state="translated">모든 손상 객체를 사용하면 백업이나 아카이브 (즉, 당신은 단지 그들을 제거하고 할 수에서 발견 할 것이다 &lt;code&gt;rsync&lt;/code&gt; 를 다른 사람이 당신이 손상 한 목적을 가지고 희망의 다른 사이트).</target>
        </trans-unit>
        <trans-unit id="881f628d30dc8f906e6314a57d637b480027cf97" translate="yes" xml:space="preserve">
          <source>Any diff-generating command can take the &lt;code&gt;-c&lt;/code&gt; or &lt;code&gt;--cc&lt;/code&gt; option to produce a &lt;code&gt;combined diff&lt;/code&gt; when showing a merge. This is the default format when showing merges with &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; or &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt;. Note also that you can give the &lt;code&gt;-m&lt;/code&gt; option to any of these commands to force generation of diffs with individual parents of a merge.</source>
          <target state="translated">diff-generating 명령은 &lt;code&gt;-c&lt;/code&gt; 또는 &lt;code&gt;--cc&lt;/code&gt; 옵션을 사용 하여 병합을 표시 할 때 &lt;code&gt;combined diff&lt;/code&gt; 를 생성 할 수 있습니다 . 이것은 &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-show&quot;&gt;git-show [1]&lt;/a&gt; 과의 병합을 표시 할 때의 기본 형식 입니다. 또한 이 명령 중 하나에 &lt;code&gt;-m&lt;/code&gt; 옵션을 지정하여 병합의 개별 부모와 함께 diff를 강제로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="693fa01c32bbb0a692d5b48b48158d26bcd64f81" translate="yes" xml:space="preserve">
          <source>Any line that is added in one location and was removed in another location will be colored with &lt;code&gt;color.diff.newMoved&lt;/code&gt;. Similarly &lt;code&gt;color.diff.oldMoved&lt;/code&gt; will be used for removed lines that are added somewhere else in the diff. This mode picks up any moved line, but it is not very useful in a review to determine if a block of code was moved without permutation.</source>
          <target state="translated">한 위치에 추가되고 다른 위치에서 제거 된 라인은 &lt;code&gt;color.diff.newMoved&lt;/code&gt; 로 색상이 지정 됩니다. 마찬가지로 &lt;code&gt;color.diff.oldMoved&lt;/code&gt; 는 diff의 다른 곳에 추가 된 제거 된 라인에 사용됩니다. 이 모드는 이동 된 행을 선택하지만 코드 블록이 순열없이 이동되었는지 확인하는 데는 검토에 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e51f4c4f56de2a2384662213d8799137a1187ad" translate="yes" xml:space="preserve">
          <source>Any nontrivial feature will require several patches to implement, and may get extra bugfixes or improvements during its lifetime.</source>
          <target state="translated">사소한 기능을 구현하려면 몇 가지 패치가 필요하며 수명 동안 추가 버그 수정 또는 개선 사항이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d98b5885c45b32a708919758a9a90750e9cf4885" translate="yes" xml:space="preserve">
          <source>Any object with modification time newer than the &lt;code&gt;--prune&lt;/code&gt; date is kept, along with everything reachable from it.</source>
          <target state="translated">&lt;code&gt;--prune&lt;/code&gt; 날짜 보다 새로운 수정 시간을 가진 모든 객체와 그로부터 도달 가능한 모든 객체 가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="57cde5a06f278fc117497921cb6730239da3eb9d" translate="yes" xml:space="preserve">
          <source>Any objects created by the &lt;code&gt;pre-receive&lt;/code&gt; hook will be created in the quarantine directory (and migrated only if it succeeds).</source>
          <target state="translated">&lt;code&gt;pre-receive&lt;/code&gt; 후크로 작성된 모든 오브젝트 는 검역소 디렉토리에 작성됩니다 (성공한 경우에만 마이그레이션 됨).</target>
        </trans-unit>
        <trans-unit id="5f15852fd98f4e7d5fcff8be14576b9b3b53c8dc" translate="yes" xml:space="preserve">
          <source>Any of the credential.* options above can be applied selectively to some credentials. For example &quot;credential.https://example.com.username&quot; would set the default username only for https connections to example.com. See &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt; for details on how URLs are matched.</source>
          <target state="translated">위의 자격 증명. * 옵션 중 일부는 일부 자격 증명에 선택적으로 적용될 수 있습니다. 예를 들어 &quot;credential.https : //example.com.username&quot;은 example.com에 대한 https 연결의 경우에만 기본 사용자 이름을 설정합니다. URL을 일치시키는 방법에 대한 자세한 내용 은 &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bac0fc50e3c83a77179d2fb9959cd57efc236587" translate="yes" xml:space="preserve">
          <source>Any of the http.* options above can be applied selectively to some URLs. For a config key to match a URL, each element of the config key is compared to that of the URL, in the following order:</source>
          <target state="translated">위의 http. * 옵션 중 일부는 일부 URL에 선택적으로 적용될 수 있습니다. 구성 키가 URL과 일치하도록 구성 키의 각 요소는 다음 순서로 URL의 요소와 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="3dafc51d2498886776211f48626918bab9502059" translate="yes" xml:space="preserve">
          <source>Any other arguments are passed directly to &lt;code&gt;git log&lt;/code&gt;</source>
          <target state="translated">다른 인수는 &lt;code&gt;git log&lt;/code&gt; 로 직접 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="41dff852ecf280a28625475c8607b0ee485f1ab1" translate="yes" xml:space="preserve">
          <source>Any other exit code will abort the bisect process. It should be noted that a program that terminates via &lt;code&gt;exit(-1)&lt;/code&gt; leaves $? = 255, (see the exit(3) manual page), as the value is chopped with &lt;code&gt;&amp;amp; 0377&lt;/code&gt;.</source>
          <target state="translated">다른 종료 코드는 bisect 프로세스를 중단합니다. &lt;code&gt;exit(-1)&lt;/code&gt; 통해 종료 되는 프로그램은 $?를 남깁니다. &lt;code&gt;&amp;amp; 0377&lt;/code&gt; 으로 값이 잘 리므로 = 255 (exit (3) 매뉴얼 페이지 참조) .</target>
        </trans-unit>
        <trans-unit id="642004f414daf9dcdfd792ec1198534a94bdecbe" translate="yes" xml:space="preserve">
          <source>Any other value causes Git to act as if &lt;code&gt;text&lt;/code&gt; has been left unspecified.</source>
          <target state="translated">다른 값을 지정하면 Git 은 &lt;code&gt;text&lt;/code&gt; 가 지정되지 않은 것처럼 작동 합니다 .</target>
        </trans-unit>
        <trans-unit id="c934a0e2885189af1607d7090f7bdedd35f47c56" translate="yes" xml:space="preserve">
          <source>Any submodule changes are reported as modified &lt;code&gt;M&lt;/code&gt; instead of &lt;code&gt;m&lt;/code&gt; or single &lt;code&gt;?&lt;/code&gt;.</source>
          <target state="translated">모든 서브 모듈의 변경 내용은 수정 된보고 &lt;code&gt;M&lt;/code&gt; 대신 &lt;code&gt;m&lt;/code&gt; 또는 단일 &lt;code&gt;?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c7f540cc43682f246f3211715ad8ff43ff2cc9b" translate="yes" xml:space="preserve">
          <source>Any valid Git SHA-1 expression that resolves to a commit. See &amp;ldquo;SPECIFYING REVISIONS&amp;rdquo; in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt; for details.</source>
          <target state="translated">커밋으로 해결되는 유효한 Git SHA-1 식 자세한 내용은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]의&lt;/a&gt; &amp;ldquo; Revision of SPECIFYING REVISIONS&amp;rdquo; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f7d956d491ba987cc8588aff431085dc6fef94e0" translate="yes" xml:space="preserve">
          <source>Anyway &quot;git rebase&quot; can be used to linearize history. This can be used either to avoid merging in the first place. Or it can be used to bisect on a linear history instead of the non linear one, as this should give more information in case of a semantic change in one branch.</source>
          <target state="translated">어쨌든 &quot;git rebase&quot;를 사용하여 히스토리를 선형화 할 수 있습니다. 처음부터 병합을 피하기 위해 사용할 수 있습니다. 또는 하나의 브랜치에서 의미가 변경되는 경우 더 많은 정보를 제공해야하기 때문에 비선형이 아닌 선형 이력을 이등분하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e59b76f5bd0befb4dbe4de65fbbfc975d414db1" translate="yes" xml:space="preserve">
          <source>Anyway one can notice in the above special branch example that the Z' and Z commits should point to the same source code state (the same &quot;tree&quot; in git parlance). That&amp;rsquo;s because Z' result from applying the same changes as Z just in a slightly different order.</source>
          <target state="translated">어쨌든 Z '와 Z 커밋이 동일한 소스 코드 상태 (git parlance에서 동일한 &quot;트리&quot;)를 가리켜 야한다는 것을 위의 특수 분기 예제에서 알 수 있습니다. Z '가 Z와 동일한 변경 사항을 약간 다른 순서로 적용한 결과이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b6009c11bd52cccb479f468a5d30bb80204ccc20" translate="yes" xml:space="preserve">
          <source>Anyway, as we mentioned previously, you normally never actually take a look at the objects themselves, and typing long 40-character hex names is not something you&amp;rsquo;d normally want to do. The above digression was just to show that &lt;code&gt;git update-index&lt;/code&gt; did something magical, and actually saved away the contents of your files into the Git object database.</source>
          <target state="translated">어쨌든, 앞에서 언급했듯이 일반적으로 실제로 객체 자체를 보지 않으며 40 자 길이의 긴 16 진수 이름을 입력하는 것은 일반적으로 원하는 것이 아닙니다. 위의 설명은 &lt;code&gt;git update-index&lt;/code&gt; 가 마술 같은 것을 보여주고 실제로 파일의 내용을 Git 객체 데이터베이스에 저장 했다는 것을 보여주기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="868e50b230265adc5a12e0fabfef64c97f0dfb44" translate="yes" xml:space="preserve">
          <source>Anyway, let&amp;rsquo;s exit &lt;code&gt;gitk&lt;/code&gt; (&lt;code&gt;^Q&lt;/code&gt; or the File menu), and decide that we want to merge the work we did on the &lt;code&gt;mybranch&lt;/code&gt; branch into the &lt;code&gt;master&lt;/code&gt; branch (which is currently our &lt;code&gt;HEAD&lt;/code&gt; too). To do that, there&amp;rsquo;s a nice script called &lt;code&gt;git merge&lt;/code&gt;, which wants to know which branches you want to resolve and what the merge is all about:</source>
          <target state="translated">어쨌든 &lt;code&gt;gitk&lt;/code&gt; ( &lt;code&gt;^Q&lt;/code&gt; 또는 File 메뉴)를 종료 하고 &lt;code&gt;mybranch&lt;/code&gt; 브랜치 에서 수행 한 작업을 &lt;code&gt;master&lt;/code&gt; 브랜치 (현재 &lt;code&gt;HEAD&lt;/code&gt; 이기도 함) 로 병합하기로 결정합니다 . 이를 위해 &lt;code&gt;git merge&lt;/code&gt; 라는 멋진 스크립트가 있습니다.이 스크립트는 해결하려는 분기와 병합이 무엇인지 알고 싶어합니다.</target>
        </trans-unit>
        <trans-unit id="4dd4f1d29aada84809b848ed1f3cfeec94f509cd" translate="yes" xml:space="preserve">
          <source>Anyway, once you are sure that you&amp;rsquo;re not interested in any dangling state, you can just prune all unreachable objects:</source>
          <target state="translated">어쨌든, 매달려있는 상태에 관심이 없다고 확신하면 도달 할 수없는 모든 객체를 정리하면됩니다.</target>
        </trans-unit>
        <trans-unit id="0af8b356773c7cf5ba56c2406453ade92d5ac3c1" translate="yes" xml:space="preserve">
          <source>Apache 2.x</source>
          <target state="translated">아파치 2.x</target>
        </trans-unit>
        <trans-unit id="62093635aebe85cb9943f4c0313c4cb13ae431e5" translate="yes" xml:space="preserve">
          <source>Apache as CGI</source>
          <target state="translated">CGI로 아파치</target>
        </trans-unit>
        <trans-unit id="fcf355a3b504d322d867b3a7779ff63edb5eff93" translate="yes" xml:space="preserve">
          <source>Apache must be configured to support CGI scripts in the directory in which gitweb is installed. Let&amp;rsquo;s assume that it is &lt;code&gt;/var/www/cgi-bin&lt;/code&gt; directory.</source>
          <target state="translated">gitweb이 설치된 디렉토리에서 CGI 스크립트를 지원하도록 Apache를 구성해야합니다. 그것이 &lt;code&gt;/var/www/cgi-bin&lt;/code&gt; 디렉토리 라고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="adce44ce9fd05dba8366c6738436e24094334a46" translate="yes" xml:space="preserve">
          <source>Apache with FastCGI</source>
          <target state="translated">FastCGI가 포함 된 Apache</target>
        </trans-unit>
        <trans-unit id="154d9ee4c57b9c60297467031aab475139a92de6" translate="yes" xml:space="preserve">
          <source>Apache with mod_perl, via ModPerl::Registry</source>
          <target state="translated">ModPerl :: Registry를 통해 mod_perl이있는 Apache</target>
        </trans-unit>
        <trans-unit id="0e7319c6d9f1793811603c0e586a372fe36cd4e3" translate="yes" xml:space="preserve">
          <source>Apart from supporting file annotation, Git also supports searching the development history for when a code snippet occurred in a change. This makes it possible to track when a code snippet was added to a file, moved or copied between files, and eventually deleted or replaced. It works by searching for a text string in the diff. A small example of the pickaxe interface that searches for &lt;code&gt;blame_usage&lt;/code&gt;:</source>
          <target state="translated">파일 주석을 지원하는 것 외에도 Git은 코드 조각이 변경되었을 때 개발 히스토리 검색을 지원합니다. 이를 통해 코드 스 니펫이 파일에 추가되고 파일간에 이동 또는 복사 된 후 결국 삭제 또는 교체 된시기를 추적 할 수 있습니다. diff에서 텍스트 문자열을 검색하여 작동합니다. &lt;code&gt;blame_usage&lt;/code&gt; 를 검색하는 pickaxe 인터페이스의 작은 예입니다 .</target>
        </trans-unit>
        <trans-unit id="0d7464dc71494394ceb8bfdacf997c37cf7b2fe0" translate="yes" xml:space="preserve">
          <source>Append &quot;exec &amp;lt;cmd&amp;gt;&quot; after each line creating a commit in the final history. &amp;lt;cmd&amp;gt; will be interpreted as one or more shell commands. Any command that fails will interrupt the rebase, with exit code 1.</source>
          <target state="translated">최종 히스토리에서 확약을 작성하는 각 행 후에 &quot;exec &amp;lt;cmd&amp;gt;&quot;를 추가하십시오. &amp;lt;cmd&amp;gt;는 하나 이상의 쉘 명령으로 해석됩니다. 실패한 명령은 종료 코드 1과 함께 리베이스를 중단합니다.</target>
        </trans-unit>
        <trans-unit id="ef04cef4b0401f57059733c71c586ba695e16618" translate="yes" xml:space="preserve">
          <source>Append ref names and object names of fetched refs to the existing contents of &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt;. Without this option old data in &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; will be overwritten.</source>
          <target state="translated">가져온 참조의 참조 이름 및 오브젝트 이름을 &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; 의 기존 컨텐츠에 추가하십시오 . 이 옵션을 사용하지 않으면 &lt;code&gt;.git/FETCH_HEAD&lt;/code&gt; 의 이전 데이터를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="94dedcc5d01b91b42b1e3ae2801d2b001bfa9291" translate="yes" xml:space="preserve">
          <source>Append the notes (see &lt;a href=&quot;git-notes&quot;&gt;git-notes[1]&lt;/a&gt;) for the commit after the three-dash line.</source>
          <target state="translated">세 개의 대시 라인 다음에 커밋에 대한 메모를 추가하십시오 ( &lt;a href=&quot;git-notes&quot;&gt;git-notes [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="60b0cf67b9a78690ab42bf05c5a970037b617230" translate="yes" xml:space="preserve">
          <source>Append this string to each commit message. Set to empty string to disable this feature. Defaults to &quot;via git-CVS emulator&quot;.</source>
          <target state="translated">각 커밋 메시지에이 문자열을 추가하십시오. 이 기능을 비활성화하려면 빈 문자열로 설정하십시오. 기본값은 &quot;git-CVS 에뮬레이터를 통해&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="2373a40d8b684d9b213d526a29e87b69fa3f0b45" translate="yes" xml:space="preserve">
          <source>Append to the notes of an existing object (defaults to HEAD). Creates a new notes object if needed.</source>
          <target state="translated">기존 객체의 메모에 추가합니다 (기본값은 HEAD). 필요한 경우 새 메모 개체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="64fff387ef07a8a383c37886a7516866c065d733" translate="yes" xml:space="preserve">
          <source>Appendix a: git quick reference</source>
          <target state="translated">부록 A : 자식 빠른 참조</target>
        </trans-unit>
        <trans-unit id="505428ce9360d60afb175c3a83b181da98dfd5f0" translate="yes" xml:space="preserve">
          <source>Appendix b: notes and todo list for this manual</source>
          <target state="translated">부록 B :이 매뉴얼에 대한 참고 및 할 일 목록</target>
        </trans-unit>
        <trans-unit id="0cd05b54bd7b3a6c1bc46851a5cc57ae9e4714f4" translate="yes" xml:space="preserve">
          <source>Applies a quilt patchset onto the current Git branch, preserving the patch boundaries, patch order, and patch descriptions present in the quilt patchset.</source>
          <target state="translated">이불 패치 세트를 현재 Git 브랜치에 적용하여 이불 패치 세트에있는 패치 경계, 패치 순서 및 패치 설명을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="a7cac5d66c52938bbdbd6bb2ccc1b2a1e469d6e9" translate="yes" xml:space="preserve">
          <source>Applies a quilt patchset onto the current branch</source>
          <target state="translated">현재 분기에 퀼트 패치 세트를 적용합니다</target>
        </trans-unit>
        <trans-unit id="0ace5fe552ca52b3206a5bd3ee6c81166a6d4e30" translate="yes" xml:space="preserve">
          <source>Apply a commit to the p4 workspace, opening, adding and deleting files in p4 as for a normal submit operation. Do not issue the final &quot;p4 submit&quot;, but instead print a message about how to submit manually or revert. This option always stops after the first (oldest) commit. Git tags are not exported to p4.</source>
          <target state="translated">p4 작업 공간에 커밋을 적용하여 일반적인 제출 작업과 마찬가지로 p4에서 파일을 열고 추가하고 삭제합니다. 최종 &quot;p4 제출&quot;을 발행하지 말고 수동으로 제출하거나 되 돌리는 방법에 대한 메시지를 인쇄하십시오. 이 옵션은 항상 첫 번째 (가장 오래된) 커밋 후에 중지됩니다. 힘내 태그는 p4로 내보내지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="48f2321ef5db21359607b635bc37d95c3c3f6949" translate="yes" xml:space="preserve">
          <source>Apply a patch to files and/or to the index</source>
          <target state="translated">파일 및 / 또는 색인에 패치 적용</target>
        </trans-unit>
        <trans-unit id="bd267fa176f80df21611314430fb619c6c0ca823" translate="yes" xml:space="preserve">
          <source>Apply a patch without touching the working tree. Instead take the cached data, apply the patch, and store the result in the index without using the working tree. This implies &lt;code&gt;--index&lt;/code&gt;.</source>
          <target state="translated">작업 트리를 건드리지 않고 패치를 적용하십시오. 대신 캐시 된 데이터를 가져 와서 패치를 적용한 후 작업 트리를 사용하지 않고 결과를 색인에 저장하십시오. 이것은 &lt;code&gt;--index&lt;/code&gt; 를 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="9e6f2e44329517aef587c18d6b7620bb801018d0" translate="yes" xml:space="preserve">
          <source>Apply a series of patches from a mailbox</source>
          <target state="translated">사서함에서 일련의 패치 적용</target>
        </trans-unit>
        <trans-unit id="7e0339ba7940213ee941e0cfb4df5c765eb525b6" translate="yes" xml:space="preserve">
          <source>Apply changes to files matching the given path pattern. This can be useful when importing patchsets, where you want to include certain files or directories.</source>
          <target state="translated">지정된 경로 패턴과 일치하는 파일에 변경 사항을 적용하십시오. 패치 파일을 가져올 때 특정 파일이나 디렉토리를 포함 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="62ad9c2cc3b0c429c18e394c154429c6601a33bc" translate="yes" xml:space="preserve">
          <source>Apply it:</source>
          <target state="translated">그것을 적용하십시오 :</target>
        </trans-unit>
        <trans-unit id="9537fc12221a208866b0d5f4bdeb3c72a1e2302e" translate="yes" xml:space="preserve">
          <source>Apply the &quot;clean&quot; process freshly to all tracked files to forcibly add them again to the index. This is useful after changing &lt;code&gt;core.autocrlf&lt;/code&gt; configuration or the &lt;code&gt;text&lt;/code&gt; attribute in order to correct files added with wrong CRLF/LF line endings. This option implies &lt;code&gt;-u&lt;/code&gt;.</source>
          <target state="translated">&quot;깨끗한&quot;프로세스를 모든 추적 된 파일에 새로 적용하여 강제로 인덱스에 다시 추가하십시오. 이는 잘못된 CRLF / LF 줄 끝으로 추가 된 파일을 수정하기 위해 &lt;code&gt;core.autocrlf&lt;/code&gt; 구성 또는 &lt;code&gt;text&lt;/code&gt; 속성을 변경 한 후 유용합니다 . 이 옵션은 &lt;code&gt;-u&lt;/code&gt; 를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="3387547d9c3f57336c6769472fbdaa2f41d8d54e" translate="yes" xml:space="preserve">
          <source>Apply the change introduced by the commit at the tip of the master branch and create a new commit with this change.</source>
          <target state="translated">마스터 브랜치 끝에 커밋이 도입 한 변경 사항을 적용하고이 변경 사항으로 새 커밋을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="dcad7381c75ab9bcebba4ec36c60788e21cc232d" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by all commits on the master branch that touched README to the working tree and index, so the result can be inspected and made into a single new commit if suitable.</source>
          <target state="translated">README를 터치 한 마스터 브랜치의 모든 커밋이 작업 트리 및 인덱스에 적용한 변경 사항을 적용하면 결과를 검사하여 적합한 경우 새 커밋 하나로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cd6111442f7f7c96f0cf43ef692ab3fd0aeaf35" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by all commits that are ancestors of maint or next, but not master or any of its ancestors. Note that the latter does not mean &lt;code&gt;maint&lt;/code&gt; and everything between &lt;code&gt;master&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;; specifically, &lt;code&gt;maint&lt;/code&gt; will not be used if it is included in &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">maint 또는 next의 조상이지만 master 또는 그 조상이 아닌 모든 커밋에 의해 도입 된 변경 사항을 적용하십시오. 후자는 &lt;code&gt;maint&lt;/code&gt; 과 &lt;code&gt;master&lt;/code&gt; 와 &lt;code&gt;next&lt;/code&gt; 사이의 모든 것을 의미하지는 않습니다 . 특히 &lt;code&gt;maint&lt;/code&gt; 이 &lt;code&gt;master&lt;/code&gt; 에 포함되어 있으면 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="93bf7e7b652d09afeef199594d1b407f0e89fdfa" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by all commits that are ancestors of master but not of HEAD to produce new commits.</source>
          <target state="translated">마스터의 조상이지만 HEAD가 아닌 모든 커밋이 도입 한 변경 사항을 적용하여 새로운 커밋을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="267d59350d3cc9c55b8eac43fb7124a86e3e2e8d" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by some existing commits</source>
          <target state="translated">기존 커밋이 도입 한 변경 사항 적용</target>
        </trans-unit>
        <trans-unit id="4483cddab281b7008c2024c5cf39c925a712d6f4" translate="yes" xml:space="preserve">
          <source>Apply the changes introduced by the fifth and third last commits pointed to by master and create 2 new commits with these changes.</source>
          <target state="translated">마스터가 가리키는 다섯 번째 및 세 번째 마지막 커밋이 도입 한 변경 사항을 적용하고이 변경 사항으로 두 개의 새로운 커밋을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="32e6df839ae5866b7658a0152bc89b8703c2e9dc" translate="yes" xml:space="preserve">
          <source>Apply the patch in reverse.</source>
          <target state="translated">패치를 반대로 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="2a3b720a1d345274dfcc30d6bb5718ba5a7d893c" translate="yes" xml:space="preserve">
          <source>Apply the patch to both the index and the working tree (or merely check that it would apply cleanly to both if &lt;code&gt;--check&lt;/code&gt; is in effect). Note that &lt;code&gt;--index&lt;/code&gt; expects index entries and working tree copies for relevant paths to be identical (their contents and metadata such as file mode must match), and will raise an error if they are not, even if the patch would apply cleanly to both the index and the working tree in isolation.</source>
          <target state="translated">인덱스와 작업 트리 모두에 패치를 적용하십시오 (또는 &lt;code&gt;--check&lt;/code&gt; 가 유효한 경우 둘 다에 적용되는지 확인하십시오 ). 참고 &lt;code&gt;--index&lt;/code&gt; 은 인덱스 항목과 관련 경로가 동일해야 할 작업 트리 사본 (해당 내용 및 파일 모드가 일치해야하기 때문에 메타 데이터 등) 기대하고, 그렇지 않은 경우 패치를 모두 깔끔하게 적용될 경우에도 오류를 올릴 것이다 인덱스와 작업 트리가 분리되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="23e8468c7e010cf39f5023f4c74def3832e8706a" translate="yes" xml:space="preserve">
          <source>Apply the patch to just the index, without touching the working tree. If &lt;code&gt;--check&lt;/code&gt; is in effect, merely check that it would apply cleanly to the index entry.</source>
          <target state="translated">작업 트리를 건드리지 않고 인덱스에만 패치를 적용하십시오. 경우 &lt;code&gt;--check&lt;/code&gt; 가 적용되는 단지는 인덱스 항목에 정상적으로 적용됩니다 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="88f8070d0672eae136d921241ac9866b7f235114" translate="yes" xml:space="preserve">
          <source>Apply the specified refspec to each ref exported. Multiple of them can be specified.</source>
          <target state="translated">지정된 참조 스펙을 내 보낸 각 참조에 적용하십시오. 여러 개를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fd7e8ac68a94d08f0fdbfcbab3475962ee42209" translate="yes" xml:space="preserve">
          <source>Apply to the working tree and the index the changes introduced by the second last commit pointed to by master and by the last commit pointed to by next, but do not create any commit with these changes.</source>
          <target state="translated">작업 트리 및 색인에 마스터가 가리키는 두 번째 커밋과 다음에 가리키는 마지막 커밋이 도입 한 변경 사항을 적용하지만 이러한 변경 사항으로 커밋을 만들지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0cd32c5cf17ab15de02490afcc460874d487a4cd" translate="yes" xml:space="preserve">
          <source>Applying the state can fail with conflicts; in this case, it is not removed from the stash list. You need to resolve the conflicts by hand and call &lt;code&gt;git stash drop&lt;/code&gt; manually afterwards.</source>
          <target state="translated">상태를 적용하면 충돌로 실패 할 수 있습니다. 이 경우 숨김 목록에서 제거되지 않습니다. 수동으로 충돌을 해결하고 &lt;code&gt;git stash drop&lt;/code&gt; 을 수동으로 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="956519c248d491798436fec0428abbdf91cbc909" translate="yes" xml:space="preserve">
          <source>Approach #1 (add-on)</source>
          <target state="translated">접근법 # 1 (애드온)</target>
        </trans-unit>
        <trans-unit id="57f019c85346bddb5f41fba94e7c74787f47bd0d" translate="yes" xml:space="preserve">
          <source>Approach #2 (configuration)</source>
          <target state="translated">접근법 # 2 (구성)</target>
        </trans-unit>
        <trans-unit id="bb297e0ad30a52de0d35c2e51c324455cc5006ef" translate="yes" xml:space="preserve">
          <source>Approach #3 (external editor)</source>
          <target state="translated">접근법 # 3 (외부 편집기)</target>
        </trans-unit>
        <trans-unit id="6a4c02b7a9497dd0187742b95b941fbc3f472c18" translate="yes" xml:space="preserve">
          <source>Arbitrary extended SHA-1 expression (see &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;) that typically names a branch head or a tag.</source>
          <target state="translated">일반적으로 분기 헤드 또는 태그의 이름을 지정하는 임의의 확장 SHA-1 표현식 ( &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="99d8ff22bcfacdaff98940313c6f7a07ddd4cf65" translate="yes" xml:space="preserve">
          <source>Archive/branch identifier in a format that &lt;code&gt;tla log&lt;/code&gt; understands.</source>
          <target state="translated">&lt;code&gt;tla log&lt;/code&gt; 가 이해 하는 형식의 아카이브 / 분기 식별자 .</target>
        </trans-unit>
        <trans-unit id="872da414bff0647443183643c537cf06ff00de53" translate="yes" xml:space="preserve">
          <source>Argument --depth specifies the number of commits from the current shallow boundary instead of from the tip of each remote branch history.</source>
          <target state="translated">인수 --depth는 각 원격 분기 히스토리의 팁 대신 현재 얕은 경계에서 커밋 수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5f7cc8b7282309c04b6094d3e942d3596636318c" translate="yes" xml:space="preserve">
          <source>Argument disambiguation</source>
          <target state="translated">인수 명확성</target>
        </trans-unit>
        <trans-unit id="fd50e821541e889c251a37edf6c132e6475912dc" translate="yes" xml:space="preserve">
          <source>Arguments for &lt;code&gt;git rev-list&lt;/code&gt;. All positive refs included by these options are rewritten. You may also specify options such as &lt;code&gt;--all&lt;/code&gt;, but you must use &lt;code&gt;--&lt;/code&gt; to separate them from the &lt;code&gt;git filter-branch&lt;/code&gt; options. Implies &lt;a href=&quot;#Remap_to_ancestor&quot;&gt;Remap to ancestor&lt;/a&gt;.</source>
          <target state="translated">에 대한 인수 &lt;code&gt;git rev-list&lt;/code&gt; . 이러한 옵션에 포함 된 모든 긍정적 참조는 다시 작성됩니다. 당신은 또한 다음과 같은 옵션을 지정할 수 있습니다 &lt;code&gt;--all&lt;/code&gt; 을 ,하지만 당신은 사용해야합니다 &lt;code&gt;--&lt;/code&gt; 으로부터 그들을 분리하는 &lt;code&gt;git filter-branch&lt;/code&gt; 옵션을 제공합니다. &lt;a href=&quot;#Remap_to_ancestor&quot;&gt;조상에 다시 매핑을&lt;/a&gt; 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="345e43f16973168887e556514ee57c8062a62d30" translate="yes" xml:space="preserve">
          <source>Arranges for fast-import to save a reference to the current object, allowing the frontend to recall this object at a future point in time, without knowing its SHA-1. Here the current object is the object creation command the &lt;code&gt;mark&lt;/code&gt; command appears within. This can be &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;tag&lt;/code&gt;, and &lt;code&gt;blob&lt;/code&gt;, but &lt;code&gt;commit&lt;/code&gt; is the most common usage.</source>
          <target state="translated">현재 객체에 대한 참조를 저장하기 위해 빠른 가져 오기를 정렬하여 프런트 엔드가 SHA-1을 몰라도 나중에이 객체를 호출 할 수 있도록합니다. 여기서 현재 객체는 &lt;code&gt;mark&lt;/code&gt; 명령이 표시 되는 객체 생성 명령 입니다. 이것은 &lt;code&gt;commit&lt;/code&gt; , &lt;code&gt;tag&lt;/code&gt; 및 &lt;code&gt;blob&lt;/code&gt; 일 수 있지만 &lt;code&gt;commit&lt;/code&gt; 은 가장 일반적인 사용법입니다.</target>
        </trans-unit>
        <trans-unit id="63f07e2039af4b87f8fad3f523ac66820be39017" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;LF&lt;/code&gt; is not valid in a Git refname or SHA-1 expression, no quoting or escaping syntax is supported within &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">마찬가지로 &lt;code&gt;LF&lt;/code&gt; 는 힘내 refname 또는 SHA-1 발현이 유효하지 않음을 인용 또는 이스케이프 구문 내에지지 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41e120dada68dd444b90dd5ea02098a2591a6678" translate="yes" xml:space="preserve">
          <source>As a &lt;code&gt;checkpoint&lt;/code&gt; can require a significant amount of CPU time and disk IO (to compute the overall pack SHA-1 checksum, generate the corresponding index file, and update the refs) it can easily take several minutes for a single &lt;code&gt;checkpoint&lt;/code&gt; command to complete.</source>
          <target state="translated">A와 &lt;code&gt;checkpoint&lt;/code&gt; CPU 시간과 디스크 IO의 상당한 양을 필요로 할 수 있습니다 쉽게 하나의 몇 분 정도 걸릴 수 있습니다 (해당 인덱스 파일을 생성, 전체 팩 SHA-1 체크섬을 계산하고, 심판을 업데이트) &lt;code&gt;checkpoint&lt;/code&gt; 완전한 명령.</target>
        </trans-unit>
        <trans-unit id="cdb295aae55f7fada69cf590bc90ed14f2b247f0" translate="yes" xml:space="preserve">
          <source>As a consequence, the &lt;code&gt;merge base&lt;/code&gt; is not necessarily contained in each of the commit arguments if more than two commits are specified. This is different from &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch[1]&lt;/a&gt; when used with the &lt;code&gt;--merge-base&lt;/code&gt; option.</source>
          <target state="translated">결과적으로, 두 개 이상의 커밋이 지정된 경우 &lt;code&gt;merge base&lt;/code&gt; 이 각 커밋 인수에 반드시 포함되는 것은 아닙니다. &lt;code&gt;--merge-base&lt;/code&gt; 옵션 과 함께 사용하면 &lt;a href=&quot;git-show-branch&quot;&gt;git-show-branch [1]&lt;/a&gt; 과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="dbf2a4b63177a116bbc3cf47e4c27a09d7f0ef0f" translate="yes" xml:space="preserve">
          <source>As a convenience measure, &lt;code&gt;git merge&lt;/code&gt; automatically invokes &lt;code&gt;git rerere&lt;/code&gt; upon exiting with a failed automerge and &lt;code&gt;git rerere&lt;/code&gt; records the hand resolve when it is a new conflict, or reuses the earlier hand resolve when it is not. &lt;code&gt;git commit&lt;/code&gt; also invokes &lt;code&gt;git rerere&lt;/code&gt; when committing a merge result. What this means is that you do not have to do anything special yourself (besides enabling the rerere.enabled config variable).</source>
          <target state="translated">편의상, &lt;code&gt;git merge&lt;/code&gt; 는 실패한 자동 병합 으로 종료 할 때 자동으로 &lt;code&gt;git rerere&lt;/code&gt; 를 호출 하고 &lt;code&gt;git rerere&lt;/code&gt; 는 새로운 충돌 일 때 손 해결을 기록하거나 그렇지 않은 경우 이전 손 해결을 재사용합니다. &lt;code&gt;git commit&lt;/code&gt; 은 또한 병합 결과를 커밋 할 때 &lt;code&gt;git rerere&lt;/code&gt; 를 호출합니다 . 이것이 의미하는 바는 rerere.enabled 구성 변수를 활성화하는 것 외에 특별한 작업을 수행 할 필요가 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="152aaf1da15e40e4974ab4fba1bc2c82b319de92" translate="yes" xml:space="preserve">
          <source>As a general rule, you should try to split your changes into small logical steps, and commit each of them. They should be consistent, working independently of any later commits, pass the test suite, etc. This makes the review process much easier, and the history much more useful for later inspection and analysis, for example with &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt; and &lt;a href=&quot;git-bisect&quot;&gt;git-bisect[1]&lt;/a&gt;.</source>
          <target state="translated">일반적으로 변경 사항을 작은 논리적 단계로 나누고 각 변경 사항을 커미트해야합니다. 그것들은 일관성 있고, 이후의 커밋과 독립적으로 작동하고, 테스트 스위트를 통과하는 등의 작업을 수행해야합니다. 이는 검토 프로세스를 훨씬 쉽게 해주 며, &lt;a href=&quot;git-blame&quot;&gt;git-blame [1]&lt;/a&gt; 및 &lt;a href=&quot;git-bisect&quot;&gt;git&lt;/a&gt; 와 같이 이후의 검사 및 분석에 이력이 훨씬 더 유용합니다. -bisect [1] .</target>
        </trans-unit>
        <trans-unit id="813a368009448480dbec96398e42a0584e7bd447" translate="yes" xml:space="preserve">
          <source>As a given feature goes from experimental to stable, it also &quot;graduates&quot; between the corresponding branches of the software. &lt;code&gt;git.git&lt;/code&gt; uses the following &lt;code&gt;integration branches&lt;/code&gt;:</source>
          <target state="translated">주어진 기능이 실험에서 안정으로 바뀌면서 소프트웨어의 해당 지점 사이에서 &quot;대학원&quot;도됩니다. &lt;code&gt;git.git&lt;/code&gt; 은 다음과 같은 &lt;code&gt;integration branches&lt;/code&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="b64fd0a9b4f65c1520607403d9b5b0753895060e" translate="yes" xml:space="preserve">
          <source>As a last resort, you can search for the corrupted objects and attempt to replace them by hand. Back up your repository before attempting this in case you corrupt things even more in the process.</source>
          <target state="translated">최후의 수단으로, 손상된 물체를 검색하여 손으로 교체 할 수 있습니다. 프로세스에서 더 많은 것들을 손상시킬 수 있도록 시도하기 전에 리포지토리를 백업하십시오.</target>
        </trans-unit>
        <trans-unit id="55349f46b4e35ef9e012280dbd1cc43373573ca9" translate="yes" xml:space="preserve">
          <source>As a noun: A single point in the Git history; the entire history of a project is represented as a set of interrelated commits. The word &quot;commit&quot; is often used by Git in the same places other revision control systems use the words &quot;revision&quot; or &quot;version&quot;. Also used as a short hand for &lt;a href=&quot;#def_commit_object&quot;&gt;commit object&lt;/a&gt;.</source>
          <target state="translated">명사로서 : Git 역사의 단일 지점; 프로젝트의 전체 히스토리는 상호 관련된 커밋 세트로 표시됩니다. &quot;commit&quot;이라는 단어는 다른 개정 관리 시스템이 &quot;revision&quot;또는 &quot;version&quot;이라는 단어를 사용하는 동일한 장소에서 Git에 의해 종종 사용됩니다. &lt;a href=&quot;#def_commit_object&quot;&gt;커밋 객체&lt;/a&gt; 의 짧은 손으로도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff1fc843fbc05442df0cf0a8f29973ba8fa37083" translate="yes" xml:space="preserve">
          <source>As a noun: unless it is a &lt;a href=&quot;#def_fast_forward&quot;&gt;fast-forward&lt;/a&gt;, a successful merge results in the creation of a new &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; representing the result of the merge, and having as &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt; the tips of the merged &lt;a href=&quot;#def_branch&quot;&gt;branches&lt;/a&gt;. This commit is referred to as a &quot;merge commit&quot;, or sometimes just a &quot;merge&quot;.</source>
          <target state="translated">명사 : &lt;a href=&quot;#def_fast_forward&quot;&gt;빨리 감기&lt;/a&gt; 가 아니라면 성공적인 병합은 병합 결과를 나타내는 새로운 &lt;a href=&quot;#def_commit&quot;&gt;커밋을&lt;/a&gt; 생성 하고 &lt;a href=&quot;#def_parent&quot;&gt;부모&lt;/a&gt; 로서 병합 된 &lt;a href=&quot;#def_branch&quot;&gt;브랜치&lt;/a&gt; 의 팁을 갖습니다 . 이 커밋은 &quot;병합 커밋&quot;또는 때로는 &quot;병합&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="c1c9a37d68f66f1f75bfd831a2c5dd7a1272c9cd" translate="yes" xml:space="preserve">
          <source>As a real example, this is how I update my public Git repository. Kernel.org mirror network takes care of the propagation to other publicly visible machines:</source>
          <target state="translated">실제 예로, 이것은 공용 Git 저장소를 업데이트하는 방법입니다. Kernel.org 미러 네트워크는 공개적으로 보이는 다른 머신으로의 전파를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="d7533f66604d80a31300bb1ce995d97beafc16f1" translate="yes" xml:space="preserve">
          <source>As a result, the general consistency of an object can always be tested independently of the contents or the type of the object: all objects can be validated by verifying that (a) their hashes match the content of the file and (b) the object successfully inflates to a stream of bytes that forms a sequence of &lt;code&gt;&amp;lt;ascii type without space&amp;gt; + &amp;lt;space&amp;gt; + &amp;lt;ascii decimal size&amp;gt; +
&amp;lt;byte\0&amp;gt; + &amp;lt;binary object data&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">결과적으로 객체의 일반적인 일관성은 항상 객체의 내용이나 유형과 관계없이 테스트 할 수 있습니다. 모든 객체는 (a) 해시가 파일의 내용과 일치하고 (b) 객체와 일치하는지 확인하여 유효성을 검사 할 수 있습니다. &lt;code&gt;&amp;lt;ascii type without space&amp;gt; + &amp;lt;space&amp;gt; + &amp;lt;ascii decimal size&amp;gt; + &amp;lt;byte\0&amp;gt; + &amp;lt;binary object data&amp;gt;&lt;/code&gt; 시퀀스를 형성하는 바이트 스트림으로 성공적으로 팽창합니다 .</target>
        </trans-unit>
        <trans-unit id="d1e2c8156579db2980e4a3d9117d5ad5706a2358" translate="yes" xml:space="preserve">
          <source>As a result, the general consistency of an object can always be tested independently of the contents or the type of the object: all objects can be validated by verifying that (a) their hashes match the content of the file and (b) the object successfully inflates to a stream of bytes that forms a sequence of &lt;code&gt;&amp;lt;ascii type without space&amp;gt; + &amp;lt;space&amp;gt; + &amp;lt;ascii decimal size&amp;gt;&lt;br/&gt;
&amp;lt;byte\0&amp;gt; + &amp;lt;binary object data&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">결과적으로 객체의 일반적인 일관성은 항상 내용이나 객체 유형과 상관없이 테스트 할 수 있습니다. 모든 객체는 (a) 해시가 파일의 내용과 일치하고 (b) 객체와 일치하는지 확인하여 확인할 수 있습니다. &lt;code&gt;&amp;lt;ascii type without space&amp;gt; + &amp;lt;space&amp;gt; + &amp;lt;ascii decimal size&amp;gt;&lt;br/&gt; &amp;lt;byte\0&amp;gt; + &amp;lt;binary object data&amp;gt;&lt;/code&gt; 시퀀스를 형성하는 바이트 스트림으로 성공적으로 팽창합니다 .</target>
        </trans-unit>
        <trans-unit id="1a86b8dd400c7fa63fb2fa4b8a7674ea4f9c20d3" translate="yes" xml:space="preserve">
          <source>As a reviewer aid, insert a range-diff (see &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff[1]&lt;/a&gt;) into the cover letter, or as commentary of the lone patch of a 1-patch series, showing the differences between the previous version of the patch series and the series currently being formatted. &lt;code&gt;previous&lt;/code&gt; can be a single revision naming the tip of the previous series if it shares a common base with the series being formatted (for example &lt;code&gt;git format-patch --cover-letter --range-diff=feature/v1 -3
feature/v2&lt;/code&gt;), or a revision range if the two versions of the series are disjoint (for example &lt;code&gt;git format-patch --cover-letter
--range-diff=feature/v1~3..feature/v1 -3 feature/v2&lt;/code&gt;).</source>
          <target state="translated">검토 자의 도움으로, 커버-레터에 range-diff ( &lt;a href=&quot;git-range-diff&quot;&gt;git-range-diff [1] 참조&lt;/a&gt; )를 삽입하거나, 1- 패치 시리즈의 고독한 패치에 대한 주석으로, 이전 버전의 패치 사이의 차이점을 보여줍니다 시리즈 및 현재 포맷중인 시리즈. &lt;code&gt;previous&lt;/code&gt; 시리즈는 형식이 지정된 시리즈와 공통 기반을 공유하는 경우 이전 시리즈의 팁을 명명하는 단일 개정일 수 있습니다 (예 : &lt;code&gt;git format-patch --cover-letter --range-diff=feature/v1 -3 feature/v2&lt;/code&gt; ) 또는 시리즈의 두 버전이 분리 된 경우 수정 범위 (예 : &lt;code&gt;git format-patch --cover-letter --range-diff=feature/v1~3..feature/v1 -3 feature/v2&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7fd619ea41aade7bb01c884d2572b761cf9ff25b" translate="yes" xml:space="preserve">
          <source>As a reviewer aid, insert an interdiff into the cover letter, or as commentary of the lone patch of a 1-patch series, showing the differences between the previous version of the patch series and the series currently being formatted. &lt;code&gt;previous&lt;/code&gt; is a single revision naming the tip of the previous series which shares a common base with the series being formatted (for example &lt;code&gt;git format-patch
--cover-letter --interdiff=feature/v1 -3 feature/v2&lt;/code&gt;).</source>
          <target state="translated">검토 자 보조자로서 표지에 인터 디프를 삽입하거나 1 패치 시리즈의 단독 패치에 대한 주석으로 삽입하십시오. 이전 패치 시리즈의 버전과 현재 포맷중인 시리즈의 차이점을 보여줍니다. &lt;code&gt;previous&lt;/code&gt; 는 이전 시리즈의 팁을 명명하는 단일 개정판으로, 형식이 지정된 시리즈와 공통 기반을 공유합니다 (예 : &lt;code&gt;git format-patch --cover-letter --interdiff=feature/v1 -3 feature/v2&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a396a38596332774142e3633350d3c5ee12f3978" translate="yes" xml:space="preserve">
          <source>As a special case for the date-type fields, you may specify a format for the date by adding &lt;code&gt;:&lt;/code&gt; followed by date format name (see the values the &lt;code&gt;--date&lt;/code&gt; option to &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list[1]&lt;/a&gt; takes).</source>
          <target state="translated">날짜 유형 필드의 특수한 경우 &lt;code&gt;:&lt;/code&gt; 다음에 날짜 형식 이름 을 추가하여 날짜 형식을 지정할 수 있습니다 ( &lt;a href=&quot;git-rev-list&quot;&gt;git-rev-list [1]&lt;/a&gt; 의 &lt;code&gt;--date&lt;/code&gt; 옵션 값 참조 ).</target>
        </trans-unit>
        <trans-unit id="45ade4e7bdf6353bad954746718b0b4bd913e21c" translate="yes" xml:space="preserve">
          <source>As a special case, you can also do &lt;code&gt;git update-index --refresh&lt;/code&gt;, which will refresh the &quot;stat&quot; information of each index to match the current stat information. It will 'not' update the object status itself, and it will only update the fields that are used to quickly test whether an object still matches its old backing store object.</source>
          <target state="translated">특별한 경우, &lt;code&gt;git update-index --refresh&lt;/code&gt; 를 수행 하여 현재 통계 정보와 일치하도록 각 인덱스의 &quot;stat&quot;정보를 새로 고 칩니다 . 객체 상태 자체를 '업데이트'하지 않으며 객체가 여전히 기존 백업 저장소 객체와 일치하는지 빠르게 테스트하는 데 사용되는 필드 만 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="d3a1d61e69563f75beec1cc2498f12801534880e" translate="yes" xml:space="preserve">
          <source>As a special case, you can also do &lt;code&gt;git update-index --refresh&lt;/code&gt;, which will refresh the &quot;stat&quot; information of each index to match the current stat information. It will &lt;code&gt;not&lt;/code&gt; update the object status itself, and it will only update the fields that are used to quickly test whether an object still matches its old backing store object.</source>
          <target state="translated">특별한 경우로 &lt;code&gt;git update-index --refresh&lt;/code&gt; 를 수행 할 수도 있습니다 . 그러면 현재 통계 정보와 일치하도록 각 인덱스의 &quot;stat&quot;정보를 새로 고 칩니다 . 그것은 것입니다 &lt;code&gt;not&lt;/code&gt; 객체 상태 자체를 업데이트하고, 그것은 단지 객체가 여전히 오래된 백업 저장소 개체와 일치하는지 여부를 신속하게 테스트에 사용되는 필드를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="4f896fc12182c6581528d02b73cafa58c18c0571" translate="yes" xml:space="preserve">
          <source>As a special case, you may use &quot;A...B&quot; as a shortcut for the merge base of A and B if there is exactly one merge base. You can leave out at most one of A and B, in which case it defaults to HEAD.</source>
          <target state="translated">특별한 경우, 정확히 하나의 병합 기준이있는 경우 &quot;A ... B&quot;를 A와 B의 병합 기준에 대한 바로 가기로 사용할 수 있습니다. A와 B 중 하나만 남겨 둘 수 있으며,이 경우 기본값은 HEAD입니다.</target>
        </trans-unit>
        <trans-unit id="f60f56407a2b12c7ab7900d72be353ae897d29d5" translate="yes" xml:space="preserve">
          <source>As a special case, you may use &lt;code&gt;&quot;A...B&quot;&lt;/code&gt; as a shortcut for the merge base of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; if there is exactly one merge base. You can leave out at most one of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, in which case it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">특별한 경우, 정확히 하나의 병합 기준이있는 경우 &lt;code&gt;&quot;A...B&quot;&lt;/code&gt; 를 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 병합 기준에 대한 바로 가기로 사용할 수 있습니다 . &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 중 하나만 남겨 둘 수 있으며 ,이 경우 기본값은 &lt;code&gt;HEAD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="10cc0995f68a1af6b96ca8bc169efe97ff360947" translate="yes" xml:space="preserve">
          <source>As a special case, you may use &lt;code&gt;A...B&lt;/code&gt; as a shortcut for the merge base of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; if there is exactly one merge base. You can leave out at most one of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, in which case it defaults to &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">특별한 경우, 정확히 하나의 병합 기준이있는 경우 &lt;code&gt;A...B&lt;/code&gt; 를 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 병합 기준에 대한 바로 가기로 사용할 수 있습니다 . &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 중 하나만 남겨 둘 수 있으며 ,이 경우 기본값은 &lt;code&gt;HEAD&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c98a50738baa944b04be5906cf4230cda7da50f7" translate="yes" xml:space="preserve">
          <source>As a special extension, the commit filter may emit multiple commit ids; in that case, the rewritten children of the original commit will have all of them as parents.</source>
          <target state="translated">특별한 확장으로서, 커밋 필터는 여러 개의 커밋 ID를 방출 할 수있다. 이 경우, 원래의 커밋의 재 작성된 자녀는 모두 부모로서 갖게됩니다.</target>
        </trans-unit>
        <trans-unit id="014231faf08aed1fd006d6569258568e8c26510e" translate="yes" xml:space="preserve">
          <source>As a special shortcut,</source>
          <target state="translated">특별한 지름길로서</target>
        </trans-unit>
        <trans-unit id="4df53d3c6d9483bf31546176476f770bb64d7028" translate="yes" xml:space="preserve">
          <source>As a verb: The action of storing a new snapshot of the project&amp;rsquo;s state in the Git history, by creating a new commit representing the current state of the &lt;a href=&quot;#def_index&quot;&gt;index&lt;/a&gt; and advancing &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; to point at the new commit.</source>
          <target state="translated">동사로 : &lt;a href=&quot;#def_index&quot;&gt;인덱스&lt;/a&gt; 의 현재 상태를 나타내는 새 커밋을 만들고 새 커밋 을 가리 키도록 &lt;a href=&quot;#def_HEAD&quot;&gt;HEAD&lt;/a&gt; 를 진행시켜 Git 히스토리에 프로젝트 상태의 새 스냅 샷을 저장하는 조치입니다 .</target>
        </trans-unit>
        <trans-unit id="e121b03809309d600afd50d432f7cbb397b47657" translate="yes" xml:space="preserve">
          <source>As a verb: To bring the contents of another &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; (possibly from an external &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;) into the current branch. In the case where the merged-in branch is from a different repository, this is done by first &lt;a href=&quot;#def_fetch&quot;&gt;fetching&lt;/a&gt; the remote branch and then merging the result into the current branch. This combination of fetch and merge operations is called a &lt;a href=&quot;#def_pull&quot;&gt;pull&lt;/a&gt;. Merging is performed by an automatic process that identifies changes made since the branches diverged, and then applies all those changes together. In cases where changes conflict, manual intervention may be required to complete the merge.</source>
          <target state="translated">동사로 : 다른 &lt;a href=&quot;#def_branch&quot;&gt;브랜치&lt;/a&gt; (아마도 외부 &lt;a href=&quot;#def_repository&quot;&gt;저장소에서&lt;/a&gt; ) 의 컨텐츠를 현재 브랜치로 가져옵니다. (가) 지점에서 병합 된 다른 저장소의 경우에는,이 우선하여 수행된다 &lt;a href=&quot;#def_fetch&quot;&gt;페치&lt;/a&gt; 원격 분기하고 현재 브랜치에 대한 결과를 합병. 가져 오기 및 병합 작업의 조합은이라고 &lt;a href=&quot;#def_pull&quot;&gt;풀&lt;/a&gt; . 병합은 분기가 분기 된 이후의 변경 사항을 식별하고 모든 변경 사항을 함께 적용하는 자동 프로세스에 의해 수행됩니다. 변경 사항이 충돌하는 경우 병합을 완료하기 위해 수동 개입이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30669ffae471bf3f6383626501505c5e90309074" translate="yes" xml:space="preserve">
          <source>As active branches store metadata about the files contained on that branch, their in-memory storage size can grow to a considerable size (see below).</source>
          <target state="translated">활성 브랜치는 해당 브랜치에 포함 된 파일에 대한 메타 데이터를 저장하므로 메모리 내 스토리지 크기가 상당히 커질 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="5905e313567b9a612b1c4b05bb63adbe4c8ba180" translate="yes" xml:space="preserve">
          <source>As an alternative, to keep the topic branch clean of test merges, you could blow away the test merge, and keep building on top of the tip before the test merge:</source>
          <target state="translated">대안으로, 주제 분기에서 테스트 병합을 깨끗하게 유지하기 위해 테스트 병합을 날려 버리고 테스트 병합 전에 팁 맨 위에 계속 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cabda80231ec81bd47e1b2a8cca346f3b12eb94b" translate="yes" xml:space="preserve">
          <source>As an example use case, consider the following commit history:</source>
          <target state="translated">사용 사례의 예로 다음 커밋 히스토리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d1cfcd564d3c903d2d8f64e4c4116cc502a9ccb3" translate="yes" xml:space="preserve">
          <source>As an example, a typical orderfile for the core Git probably would look like this:</source>
          <target state="translated">예를 들어, 핵심 Git의 일반적인 주문 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="393e086dc57d2576b08e508b4c5a81ba83fe2ed2" translate="yes" xml:space="preserve">
          <source>As an example, suppose you are trying to find the commit that broke a feature that was known to work in version &lt;code&gt;v2.6.13-rc2&lt;/code&gt; of your project. You start a bisect session as follows:</source>
          <target state="translated">예를 들어, 프로젝트 &lt;code&gt;v2.6.13-rc2&lt;/code&gt; 버전에서 작동하는 것으로 알려진 기능을 중단 한 커밋을 찾으려고한다고 가정합니다 . 다음과 같이 이등분 세션을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="f51fd8c0acda05665f38c4533584f1e7599db6e4" translate="yes" xml:space="preserve">
          <source>As an example, the command below will show the path and currently checked out commit for each submodule:</source>
          <target state="translated">예를 들어, 아래 명령은 각 하위 모듈에 대한 경로와 현재 체크 아웃 된 커밋을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3760e902be67f22552bbeb65e39e836e5efd1bcb" translate="yes" xml:space="preserve">
          <source>As an example, use the following attributes if your &lt;code&gt;*.ps1&lt;/code&gt; files are UTF-16 encoded with byte order mark (BOM) and you want Git to perform automatic line ending conversion based on your platform.</source>
          <target state="translated">예를 들어 &lt;code&gt;*.ps1&lt;/code&gt; 파일이 바이트 순서 표시 (BOM)로 UTF-16으로 인코딩되어 있고 Git이 플랫폼을 기반으로 자동 줄 끝 변환을 수행하려는 경우 다음 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="51bf467f4f316d3645d71a2a1258673146c504e9" translate="yes" xml:space="preserve">
          <source>As another useful shortcut, the &quot;HEAD&quot; of a repository can be referred to just using the name of that repository. So, for example, &quot;origin&quot; is usually a shortcut for the HEAD branch in the repository &quot;origin&quot;.</source>
          <target state="translated">또 다른 유용한 지름길로서, 저장소의 &quot;HEAD&quot;는 해당 저장소의 이름을 사용하여 참조 할 수 있습니다. 예를 들어 &quot;origin&quot;은 일반적으로 &quot;origin&quot;저장소의 HEAD 분기에 대한 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="8026d1f9c2456b3e1c9c2d009b9420179e138763" translate="yes" xml:space="preserve">
          <source>As before, if we do &lt;code&gt;git diff-files -p&lt;/code&gt; in our git-tutorial project, we&amp;rsquo;ll still see the same difference we saw last time: the index file hasn&amp;rsquo;t changed by the act of committing anything. However, now that we have committed something, we can also learn to use a new command: &lt;code&gt;git diff-index&lt;/code&gt;.</source>
          <target state="translated">이전과 같이 git-tutorial 프로젝트에서 &lt;code&gt;git diff-files -p&lt;/code&gt; 를 수행하면 지난번에 보았던 것과 동일한 차이점이 여전히 표시됩니다. 그러나 이제 우리는 무언가를 커밋 했으므로 새로운 명령 인 &lt;code&gt;git diff-index&lt;/code&gt; 사용법을 배울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf611fa72ccf0565756cc79d030368187f807460" translate="yes" xml:space="preserve">
          <source>As described in &quot;Projects list file format&quot; section, you can control which projects are &lt;strong&gt;visible&lt;/strong&gt; by selectively including repositories in projects list file, and setting &lt;code&gt;$projects_list&lt;/code&gt; gitweb configuration variable to point to it. With &lt;code&gt;$strict_export&lt;/code&gt; set, projects list file can be used to control which repositories are &lt;strong&gt;available&lt;/strong&gt; as well.</source>
          <target state="translated">&quot;프로젝트 목록 파일 형식&quot;섹션에 설명 된대로 프로젝트 목록 파일에 저장소를 선택적으로 포함하고 &lt;code&gt;$projects_list&lt;/code&gt; gitweb 구성 변수를 지정하여 &lt;strong&gt;표시&lt;/strong&gt; 할 프로젝트를 제어 할 수 있습니다 . 함께 &lt;code&gt;$strict_export&lt;/code&gt; 설정, 프로젝트 목록 파일 저장소가 제어 할 수 있습니다 &lt;strong&gt;사용할 수&lt;/strong&gt; 뿐만 아니라.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7cd736f89da40ebc01b21f3f068771d165721a3" translate="yes" xml:space="preserve">
          <source>As described in step 1) b) of the bisection algorithm, we remove all the ancestors of the good commits because they are supposed to be good too.</source>
          <target state="translated">이분법 알고리즘의 1) 단계 b)에서 설명한 바와 같이, 좋은 커밋의 모든 조상도 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="4986ad28ead3398292128508370a98b8f0d98d3c" translate="yes" xml:space="preserve">
          <source>As development continues in the p4 repository, those changes can be included in the Git repository using:</source>
          <target state="translated">p4 저장소에서 개발이 계속됨에 따라 다음을 사용하여 변경 사항을 Git 저장소에 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b95c634f5d2da95f8f228babb7d2d483e4c0fbd6" translate="yes" xml:space="preserve">
          <source>As explained in the comments, you can reorder commits, squash them together, edit commit messages, etc. by editing the list. Once you are satisfied, save the list and close your editor, and the rebase will begin.</source>
          <target state="translated">주석에 설명 된대로 목록을 편집하여 커밋 순서를 바꾸고 함께 스쿼시하고 커밋 메시지를 편집하는 등의 작업을 수행 할 수 있습니다. 만족 스러우면 목록을 저장하고 편집기를 닫으면 리베이스가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="7111298f6d4fcf0e45bb2162c1a76bdcc1c9c21b" translate="yes" xml:space="preserve">
          <source>As in #1, the attacker chooses an object ID X to steal. The victim sends an object Y that the attacker already has, and the attacker falsely claims to have X and not Y, so the victim sends Y as a delta against X. The delta reveals regions of X that are similar to Y to the attacker.</source>
          <target state="translated"># 1에서와 같이 공격자는 도용 할 개체 ID X를 선택합니다. 피해자는 공격자가 이미 가지고있는 객체 Y를 보내고 공격자는 Y가 아니라 X가 있다고 거짓으로 주장하므로 Y는 X에 대한 델타로 Y를 보냅니다. 델타는 Y와 유사한 X의 영역을 공격자에게 공개합니다.</target>
        </trans-unit>
        <trans-unit id="5b094bea742cc2d9c8adaa2beb6a0f04f6aac290" translate="yes" xml:space="preserve">
          <source>As long as a &quot;smudge&amp;rarr;clean&quot; results in the same output as a &quot;clean&quot; even on files that are already smudged, this strategy will automatically resolve all filter-related conflicts. Filters that do not act in this way may cause additional merge conflicts that must be resolved manually.</source>
          <target state="translated">이미 번져있는 파일에서도 &quot;스머지 &amp;rarr; 청소&quot;결과가 &quot;청소&quot;와 동일한 결과를 얻는 한이 전략은 모든 필터 관련 충돌을 자동으로 해결합니다. 이러한 방식으로 작동하지 않는 필터는 수동으로 해결해야하는 추가 병합 충돌이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1864f8816e6742ed19679415e2b4f0693aaf2aa7" translate="yes" xml:space="preserve">
          <source>As no direct connection between the repositories exists, the user must specify a basis for the bundle that is held by the destination repository: the bundle assumes that all objects in the basis are already in the destination repository.</source>
          <target state="translated">리포지토리 간 직접 연결이 없으므로 사용자는 대상 리포지토리가 보유한 번들의 기본을 지정해야합니다. 번들은 기본의 모든 객체가 이미 대상 리포지토리에 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="cf5a5d1f8e11ad4218ba16acff45cd1e219fd7d0" translate="yes" xml:space="preserve">
          <source>As objects are unpacked they&amp;rsquo;re written to the object store, so there can be cases where malicious objects get introduced even though the &quot;fetch&quot; failed, only to have a subsequent &quot;fetch&quot; succeed because only new incoming objects are checked, not those that have already been written to the object store. That difference in behavior should not be relied upon. In the future, such objects may be quarantined for &quot;fetch&quot; as well.</source>
          <target state="translated">압축이 풀린 객체는 객체 저장소에 기록되므로 &quot;페치&quot;에 실패한 경우에도 악의적 인 객체가 유입되는 경우가 있습니다. 새로운 수신 객체 만 확인하기 때문에 후속 &quot;페치&quot;가 성공하는 경우가 있습니다. 이미 오브젝트 저장소에 작성되었습니다. 그 행동의 차이에 의존해서는 안됩니다. 앞으로 이러한 개체는 &quot;가져 오기&quot;를 위해 격리 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="09eeb717613e6d721cd260fee5aeb319ede3cef4" translate="yes" xml:space="preserve">
          <source>As of cURL v7.60.0, the Secure Channel backend can use the certificate bundle provided via &lt;code&gt;http.sslCAInfo&lt;/code&gt;, but that would override the Windows Certificate Store. Since this is not desirable by default, Git will tell cURL not to use that bundle by default when the &lt;code&gt;schannel&lt;/code&gt; backend was configured via &lt;code&gt;http.sslBackend&lt;/code&gt;, unless &lt;code&gt;http.schannelUseSSLCAInfo&lt;/code&gt; overrides this behavior.</source>
          <target state="translated">cURL v7.60.0부터 보안 채널 백엔드는 &lt;code&gt;http.sslCAInfo&lt;/code&gt; 를 통해 제공된 인증서 번들을 사용할 수 있지만 Windows 인증서 저장소를 대체합니다. 이것이 바람직하지 않기 때문에, Git은 &lt;code&gt;http.schannelUseSSLCAInfo&lt;/code&gt; 가이 동작을 재정의 하지 않는 한 &lt;code&gt;schannel&lt;/code&gt; 백엔드가 &lt;code&gt;http.sslBackend&lt;/code&gt; 를 통해 구성 될 때 cURL에 기본적으로 해당 번들을 사용하지 않도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="965229350b7d9b7b4d3000cae9b4d2865a3ca80c" translate="yes" xml:space="preserve">
          <source>As one can see it lacks the 'sub' element.</source>
          <target state="translated">보시다시피 'sub'요소가 부족합니다.</target>
        </trans-unit>
        <trans-unit id="581927934e29a8f082f8e666e70165083e8e5a90" translate="yes" xml:space="preserve">
          <source>As soon as fast-import completes the Git repository is completely valid and ready for use. Typically this takes only a very short time, even for considerably large projects (100,000+ commits).</source>
          <target state="translated">빠른 가져 오기가 완료되면 Git 리포지토리가 완전히 유효하고 사용할 수 있습니다. 상당히 큰 프로젝트 (100,000+ 커밋)의 경우에도 일반적으로 매우 짧은 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="7ef5bfd643e7695a1fe3a9fa38e890221a2a3138" translate="yes" xml:space="preserve">
          <source>As stated earlier, the repo-id is currently always 1, so there will only be one def_repo event. Later, if in-proc submodules are supported, a def_repo event should be emitted for each submodule visited.</source>
          <target state="translated">앞에서 언급했듯이 repo-id는 현재 항상 1이므로 def_repo 이벤트는 하나만 있습니다. 나중에 in-proc 서브 모듈이 지원되면 방문한 각 서브 모듈에 대해 def_repo 이벤트가 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="d80ca2ccc438317d745ae5338aae99312b25f26c" translate="yes" xml:space="preserve">
          <source>As the Git commits form a directed acyclic graph (DAG), finding the best bisection commit to test at each step is not so simple. Anyway Linus found and implemented a &quot;truly stupid&quot; algorithm, later improved by Junio Hamano, that works quite well.</source>
          <target state="translated">Git 커밋이 DAG (directed acyclic graph)를 형성함에 따라 각 단계에서 테스트 할 최상의 bisection 커밋을 찾는 것은 그리 간단하지 않습니다. 어쨌든 Linus는 Junio ​​Hamano에 의해 개선 된 &quot;정말 바보 같은&quot;알고리즘을 발견하고 구현했습니다.</target>
        </trans-unit>
        <trans-unit id="58257bfeca486a2bf1fd8b1803660be56d2b010d" translate="yes" xml:space="preserve">
          <source>As the most common special case, specifying only two commits on the command line means computing the merge base between the given two commits.</source>
          <target state="translated">가장 일반적인 특수한 경우로, 명령 줄에 두 개의 커밋 만 지정하면 주어진 두 커밋 사이의 병합 기준을 계산하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2031564d4e49bc946d835c341012879d4274c799" translate="yes" xml:space="preserve">
          <source>As the result, the attributes assignment to &lt;code&gt;t/abc&lt;/code&gt; becomes:</source>
          <target state="translated">결과적으로 &lt;code&gt;t/abc&lt;/code&gt; 에 대한 속성 지정 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="192578c95c2280ba3c2f61313d8bf0f6a57ae4fb" translate="yes" xml:space="preserve">
          <source>As this option had confusing syntax, it is no longer supported. Please use &lt;code&gt;--track&lt;/code&gt; or &lt;code&gt;--set-upstream-to&lt;/code&gt; instead.</source>
          <target state="translated">이 옵션에는 혼동되는 구문이 있으므로 더 이상 지원되지 않습니다. 사용하십시오 &lt;code&gt;--track&lt;/code&gt; 나 &lt;code&gt;--set-upstream-to&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="843f190460819446fe8a020e4f922195a92ea733" translate="yes" xml:space="preserve">
          <source>As we know N from the beginning, we know that min(X, N - X) can&amp;rsquo;t be greater than N/2. So during steps 2) and 3), if we would associate N/2 to a commit, then we know this is the best bisection point. So in this case we can just stop processing any other commit and return the current commit.</source>
          <target state="translated">처음부터 N을 알고 있으므로 min (X, N-X)는 N / 2보다 클 수 없습니다. 따라서 2)와 3) 단계에서 N / 2를 커밋에 연결하면 이것이 최고의이 분점임을 알 수 있습니다. 따라서이 경우 다른 커밋 처리를 중단하고 현재 커밋을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85eb1d605d24cad051a866066f0da97dcc80577c" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;git fetch&lt;/code&gt;, &lt;code&gt;git push&lt;/code&gt; will complain if this does not result in a &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt;; see the following section for details on handling this case.</source>
          <target state="translated">와 마찬가지로 &lt;code&gt;git fetch&lt;/code&gt; , &lt;code&gt;git push&lt;/code&gt; 이것이 발생하지 않는 경우 불평 &lt;a href=&quot;#fast-forwards&quot;&gt;빨리 감기&lt;/a&gt; ; 이 사례 처리에 대한 자세한 내용은 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8efa157c58c7162f458fc6766132a5f146c4534e" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;git fetch&lt;/code&gt;, you may also set up configuration options to save typing; so, for example:</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 와 마찬가지로 입력을 저장하도록 구성 옵션을 설정할 수도 있습니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="e2e201452993c8ff29862a314b348165ba75fd76" translate="yes" xml:space="preserve">
          <source>As with other commands of this type, &lt;em&gt;git diff-index&lt;/em&gt; does not actually look at the contents of the file at all. So maybe &lt;code&gt;kernel/sched.c&lt;/code&gt; hasn&amp;rsquo;t actually changed, and it&amp;rsquo;s just that you touched it. In either case, it&amp;rsquo;s a note that you need to &lt;em&gt;git update-index&lt;/em&gt; it to make the index be in sync.</source>
          <target state="translated">이 유형의 다른 명령과 마찬가지로 &lt;em&gt;git diff-index&lt;/em&gt; 는 실제로 파일의 내용을 전혀 보지 않습니다. 아마도 &lt;code&gt;kernel/sched.c&lt;/code&gt; 은 실제로 변경되지 않았으며, 단지 당신이 터치 한 것입니다. 두 경우 모두 인덱스를 동기화하려면 인덱스 &lt;em&gt;업데이트&lt;/em&gt; 를 &lt;em&gt;git 업데이트&lt;/em&gt; 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1a219cc037572dc449858e58401a98b9487e41ef" translate="yes" xml:space="preserve">
          <source>As with pushing with &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt;, all of the rules described above about what&amp;rsquo;s not allowed as an update can be overridden by adding an the optional leading &lt;code&gt;+&lt;/code&gt; to a refspec (or using &lt;code&gt;--force&lt;/code&gt; command line option). The only exception to this is that no amount of forcing will make the &lt;code&gt;refs/heads/*&lt;/code&gt; namespace accept a non-commit object.</source>
          <target state="translated">로 밀고과 마찬가지로 &lt;a href=&quot;git-push&quot;&gt;자식 푸시 [1]&lt;/a&gt; , 허용되지 않는 기능에 대한 위에서 설명한 모든 규칙은 업데이트는 선택 사양 선두 추가하여 오버라이드 (override) 할 수있는 &lt;code&gt;+&lt;/code&gt; 를 refspec에 (또는 사용 &lt;code&gt;--force&lt;/code&gt; 명령 줄 옵션을). 이것에 대한 유일한 예외는 &lt;code&gt;refs/heads/*&lt;/code&gt; 네임 스페이스가 커밋되지 않은 객체를 허용 하지 않는다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3ed71506050bfa72b1ea4f1ce93514b64d8904d8" translate="yes" xml:space="preserve">
          <source>As with the bug described above the solution is to one-off do a &quot;git status&quot; run with &lt;code&gt;core.untrackedCache=false&lt;/code&gt; to flush out the leftover bad data.</source>
          <target state="translated">위에서 설명한 버그와 마찬가지로 해결책은 남은 불량 데이터를 제거하기 위해 &lt;code&gt;core.untrackedCache=false&lt;/code&gt; 로 &quot;git status&quot;를 한 번만 실행 하는 것입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
