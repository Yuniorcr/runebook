<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="0196a37f323e9613bd5e5c6dc6db74a2907c6a83" translate="yes" xml:space="preserve">
          <source>Every time a client connects, first run an external command specified by the &amp;lt;path&amp;gt; with service name (e.g. &quot;upload-pack&quot;), path to the repository, hostname (%H), canonical hostname (%CH), IP address (%IP), and TCP port (%P) as its command-line arguments. The external command can decide to decline the service by exiting with a non-zero status (or to allow it by exiting with a zero status). It can also look at the $REMOTE_ADDR and &lt;code&gt;$REMOTE_PORT&lt;/code&gt; environment variables to learn about the requestor when making this decision.</source>
          <target state="translated">클라이언트가 연결할 때마다 먼저 서비스 이름 (예 : &quot;업로드 팩&quot;), 저장소 경로, 호스트 이름 (% H), 표준 호스트 이름 (% CH), IP 주소 ( % IP) 및 TCP 포트 (% P)를 명령 줄 인수로 사용하십시오. 외부 명령은 0이 아닌 상태로 종료하거나 서비스를 0으로 종료하여 서비스를 거부 할 수 있습니다. 또한 $ REMOTE_ADDR 및 &lt;code&gt;$REMOTE_PORT&lt;/code&gt; 환경 변수를 보고이 결정을 내릴 때 요청자에 대해 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed1e82e85b3b43f7a452c7545f1946734ba8fe78" translate="yes" xml:space="preserve">
          <source>Everyday Git</source>
          <target state="translated">매일 힘내</target>
        </trans-unit>
        <trans-unit id="30edee05f0b86fdef0d1b80bced0b054568a2749" translate="yes" xml:space="preserve">
          <source>Everyday Git With 20 Commands Or So</source>
          <target state="translated">20 가지 정도의 명령으로 매일 Git</target>
        </trans-unit>
        <trans-unit id="0043a64d3fef8a7a23f6cd840b45f8af10f67f75" translate="yes" xml:space="preserve">
          <source>Exact byte count format</source>
          <target state="translated">정확한 바이트 수 형식</target>
        </trans-unit>
        <trans-unit id="6e07117d26445f4c876a2dd689294f11cef857f4" translate="yes" xml:space="preserve">
          <source>Examining an old version without creating a new branch</source>
          <target state="translated">새 브랜치를 만들지 않고 이전 버전 검사</target>
        </trans-unit>
        <trans-unit id="d496fa33f8661db7b0850d74bbd80c109526f113" translate="yes" xml:space="preserve">
          <source>Examining branches from a remote repository</source>
          <target state="translated">원격 저장소에서 분기 검사</target>
        </trans-unit>
        <trans-unit id="bb504595062729729e7244c3229ce860c38e6b76" translate="yes" xml:space="preserve">
          <source>Examining dangling objects</source>
          <target state="translated">매달려있는 객체 검사</target>
        </trans-unit>
        <trans-unit id="9cb0f2fbccfd2e1df3b3fea66d90520dda3d9cf1" translate="yes" xml:space="preserve">
          <source>Examining the data</source>
          <target state="translated">데이터 검사</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="cfd85acb33cc1367c953b61c1f0a7ad60c2565a2" translate="yes" xml:space="preserve">
          <source>Example 1: Your history contains commits by two authors, Jane and Joe, whose names appear in the repository under several forms:</source>
          <target state="translated">예 1 : 기록에는 두 명의 저자 인 Jane과 Joe의 커밋이 포함되어 있으며 이름은 여러 형식으로 저장소에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="aa58f391e50840be9e94b87f72faa5f731cb5766" translate="yes" xml:space="preserve">
          <source>Example 2: Your repository contains commits from the following authors:</source>
          <target state="translated">예 2 : 저장소에 다음 작성자의 커밋이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a76cea78511b0d3032b5011d701b256e4fa824c" translate="yes" xml:space="preserve">
          <source>Example contents:</source>
          <target state="translated">내용 예 :</target>
        </trans-unit>
        <trans-unit id="ee2fa80210fe959342ddb79b523484b1b7a07d33" translate="yes" xml:space="preserve">
          <source>Example to exclude everything except a specific directory &lt;code&gt;foo/bar&lt;/code&gt; (note the &lt;code&gt;/*&lt;/code&gt; - without the slash, the wildcard would also exclude everything within &lt;code&gt;foo/bar&lt;/code&gt;):</source>
          <target state="translated">특정 디렉토리 &lt;code&gt;foo/bar&lt;/code&gt; 를 제외한 모든 것을 제외하는 예제 ( &lt;code&gt;/*&lt;/code&gt; -슬래시없이 와일드 카드는 &lt;code&gt;foo/bar&lt;/code&gt; 내의 모든 것을 제외 합니다 )</target>
        </trans-unit>
        <trans-unit id="59e08af9047abc909e804faec8919301def86320" translate="yes" xml:space="preserve">
          <source>Example trace2 api usage</source>
          <target state="translated">trace2 API 사용법 예</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="523ae6b1873ceced0f776c362dc256ed64902255" translate="yes" xml:space="preserve">
          <source>Example: If you know that there was some test case for &lt;code&gt;git bundle&lt;/code&gt;, but do not remember where it was (yes, you &lt;code&gt;could&lt;/code&gt;&lt;code&gt;git grep bundle t/&lt;/code&gt;, but that does not illustrate the point!):</source>
          <target state="translated">예 : &lt;code&gt;git bundle&lt;/code&gt; 에 대한 테스트 사례가 있지만 그 위치를 기억하지 못하는 경우 (예, &lt;code&gt;git grep bundle t/&lt;/code&gt; 할 &lt;code&gt;could&lt;/code&gt; 있지만 요점을 설명하지는 않습니다!) :</target>
        </trans-unit>
        <trans-unit id="14e4d3109673cecf5094a599bce7b8cb418a458c" translate="yes" xml:space="preserve">
          <source>Example: Let commits &lt;code&gt;1--2&lt;/code&gt; be the first iteration of a patch series and &lt;code&gt;A--C&lt;/code&gt; the second iteration. Let&amp;rsquo;s assume that &lt;code&gt;A&lt;/code&gt; is a cherry-pick of &lt;code&gt;2,&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; is a cherry-pick of &lt;code&gt;1&lt;/code&gt; but with a small modification (say, a fixed typo). Visualize the commits as a bipartite graph:</source>
          <target state="translated">예 : 보자 커밋은 &lt;code&gt;1--2&lt;/code&gt; 패치 시리즈의 첫 번째 반복하고 &lt;code&gt;A--C&lt;/code&gt; 두 번째 반복. 하자가 있다고 가정 &lt;code&gt;A&lt;/code&gt; 는 (A)의 벚꽃이-선택이며 &lt;code&gt;2,&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 는 (A)의 체리 - 선택 인 &lt;code&gt;1&lt;/code&gt; 만 작은 변경 (예를 들어, 고정 오타)와 함께. 커밋을 이분 그래프로 시각화하십시오.</target>
        </trans-unit>
        <trans-unit id="d3bad2d15f343f55dc9f681daca1b6f3326d18b3" translate="yes" xml:space="preserve">
          <source>Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: &lt;code&gt;--dirstat=files,10,cumulative&lt;/code&gt;.</source>
          <target state="translated">예 : 다음은 변경된 파일 수의 10 % 미만인 디렉토리를 무시하고 상위 디렉토리에서 하위 디렉토리 수를 누적하는 동안 변경된 파일 수를 계산합니다. &lt;code&gt;--dirstat=files,10,cumulative&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5998a18b5c87282a79f47b763c8725aa5e8349e" translate="yes" xml:space="preserve">
          <source>Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: &lt;code&gt;files,10,cumulative&lt;/code&gt;.</source>
          <target state="translated">예 : 다음은 변경된 파일 수의 10 % 미만인 디렉토리를 무시하고 상위 디렉토리에서 하위 디렉토리 수를 누적하는 동안 변경된 파일 수를 계산 &lt;code&gt;files,10,cumulative&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7fe9add2c66b1dd7342bec4baea68d566885937" translate="yes" xml:space="preserve">
          <source>Example: let&amp;rsquo;s say I had renamed &lt;code&gt;commit.c&lt;/code&gt; to &lt;code&gt;git-commit.c&lt;/code&gt;, and I had done an &lt;code&gt;update-index&lt;/code&gt; to make that effective in the index file. &lt;code&gt;git diff-files&lt;/code&gt; wouldn&amp;rsquo;t show anything at all, since the index file matches my working directory. But doing a &lt;code&gt;git diff-index&lt;/code&gt; does:</source>
          <target state="translated">예 : &lt;code&gt;commit.c&lt;/code&gt; 의 이름 을 &lt;code&gt;git-commit.c&lt;/code&gt; 로 바꾸고 인덱스 파일에서 효과적으로 &lt;code&gt;update-index&lt;/code&gt; 하기 위해 update-index 를 수행 했다고 가정 해 봅시다 . &lt;code&gt;git diff-files&lt;/code&gt; 는 색인 파일이 내 작업 디렉토리와 일치하므로 아무것도 표시하지 않습니다. 그러나 &lt;code&gt;git diff-index&lt;/code&gt; 를 수행하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="22540b4db15515332cef1b1a56998eebfeba111a" translate="yes" xml:space="preserve">
          <source>Examples for &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;--cc&lt;/code&gt; without &lt;code&gt;--combined-all-paths&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;--combined-all-paths&lt;/code&gt; 가 없는 &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;--cc&lt;/code&gt; 의 예 :</target>
        </trans-unit>
        <trans-unit id="6ba2b2f11f2e1285e022c78a54e28e01334ece54" translate="yes" xml:space="preserve">
          <source>Examples when &lt;code&gt;--combined-all-paths&lt;/code&gt; added to either &lt;code&gt;-c&lt;/code&gt; or &lt;code&gt;--cc&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;--combined-all-paths&lt;/code&gt; 가 &lt;code&gt;-c&lt;/code&gt; 또는 &lt;code&gt;--cc&lt;/code&gt; 에 추가 된 예 :</target>
        </trans-unit>
        <trans-unit id="b280d2c89a83a2bacb63527574e5853bea86f936" translate="yes" xml:space="preserve">
          <source>Examples.</source>
          <target state="translated">Examples.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="24d0d5f830ca936a2b1158c4418847e58a17c132" translate="yes" xml:space="preserve">
          <source>Except for the &lt;code&gt;simple&lt;/code&gt; variant, command-line parameters are likely to change as git gains new features.</source>
          <target state="translated">&lt;code&gt;simple&lt;/code&gt; 변형을 제외하고 git이 새로운 기능을 얻음에 따라 명령 줄 매개 변수가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16cb9d6dc5634fc561d2d614f979976dfee73770" translate="yes" xml:space="preserve">
          <source>Except in a fast-forward merge (see above), the branches to be merged must be tied together by a merge commit that has both of them as its parents.</source>
          <target state="translated">빨리 감기 병합 (위 참조)을 제외하고 병합 할 브랜치는 둘 다 부모로 포함 된 병합 커밋으로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="262c2a4eb81a10a2c9efd3343c2ae85fe92bbd6e" translate="yes" xml:space="preserve">
          <source>Exclude commits that are reachable from &amp;lt;rev&amp;gt; (i.e. &amp;lt;rev&amp;gt; and its ancestors).</source>
          <target state="translated">&amp;lt;rev&amp;gt;에서 도달 할 수있는 커밋을 제외하십시오 (예 : &amp;lt;rev&amp;gt; 및 해당 조상).</target>
        </trans-unit>
        <trans-unit id="f270c263f13543cd4c2b3020f92a691a85883aa7" translate="yes" xml:space="preserve">
          <source>Exclude patterns</source>
          <target state="translated">패턴 제외</target>
        </trans-unit>
        <trans-unit id="87263b3bb52abcdab4a719253ddba1eca4b803f6" translate="yes" xml:space="preserve">
          <source>Exclude selected depot paths when cloning or syncing.</source>
          <target state="translated">복제 또는 동기화시 선택된 저장소 경로를 제외하십시오.</target>
        </trans-unit>
        <trans-unit id="80be5859c8610b0a7e5a0e2227ba09cb8e75bd2e" translate="yes" xml:space="preserve">
          <source>Exclude the given pack from repacking. This is the equivalent of having &lt;code&gt;.keep&lt;/code&gt; file on the pack. &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; is the pack file name without leading directory (e.g. &lt;code&gt;pack-123.pack&lt;/code&gt;). The option could be specified multiple times to keep multiple packs.</source>
          <target state="translated">재 포장에서 지정된 팩을 제외하십시오. 이것은 팩에 &lt;code&gt;.keep&lt;/code&gt; 파일 이있는 것과 같습니다 . &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; 은 선행 디렉토리가없는 팩 파일 이름입니다 (예 : &lt;code&gt;pack-123.pack&lt;/code&gt; ). 여러 팩을 유지하기 위해 옵션을 여러 번 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f719c666cee23f0f1f956fb1a3762ec3484afe81" translate="yes" xml:space="preserve">
          <source>Existing trailers are extracted from the input message by looking for a group of one or more lines that (i) is all trailers, or (ii) contains at least one Git-generated or user-configured trailer and consists of at least 25% trailers. The group must be preceded by one or more empty (or whitespace-only) lines. The group must either be at the end of the message or be the last non-whitespace lines before a line that starts with &lt;code&gt;---&lt;/code&gt; (followed by a space or the end of the line). Such three minus signs start the patch part of the message. See also &lt;code&gt;--no-divider&lt;/code&gt; below.</source>
          <target state="translated">기존 예고편은 (i) 모든 예고편이거나 (ii) 하나 이상의 Git 생성 또는 사용자 구성 예고편을 포함하고 최소 25 % 예고편으로 구성된 하나 이상의 행 그룹을 찾아 입력 메시지에서 추출됩니다. . 그룹 앞에는 하나 이상의 빈 (또는 공백 만있는) 행이 와야합니다. 그룹은 메시지의 끝에 있거나 &lt;code&gt;---&lt;/code&gt; 로 시작하는 줄 (공백 또는 줄 끝) 앞에 공백이 아닌 마지막 줄이어야합니다 . 이러한 세 개의 빼기 부호는 메시지의 패치 부분을 시작합니다. 아래의 &lt;code&gt;--no-divider&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3460174eb1c6ec5b3dd3ca9e87848d068de28a1" translate="yes" xml:space="preserve">
          <source>Exit code between 128 and 255 are special to &quot;git bisect run&quot;. They make it stop immediately the bisection process. This is useful for example if the command passed takes too long to complete, because you can kill it with a signal and it will stop the bisection process.</source>
          <target state="translated">128과 255 사이의 종료 코드는 &quot;git bisect run&quot;에 특별합니다. 그들은 이분법 과정을 즉시 중단시킵니다. 예를 들어, 전달 된 명령을 완료하는 데 너무 오래 걸리면 신호로 명령을 종료하고 이분법 프로세스가 중지되므로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1de8b457f24c5f9f27dc6145c115a0b05b79738e" translate="yes" xml:space="preserve">
          <source>Exit difftool if the invoked diff tool returns a non-zero exit status.</source>
          <target state="translated">호출 된 diff 도구가 0이 아닌 종료 상태를 리턴하면 difftool을 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="105ec316e78b2e21f4200658aebb690c6bfce1c8" translate="yes" xml:space="preserve">
          <source>Exit status</source>
          <target state="translated">종료 상태</target>
        </trans-unit>
        <trans-unit id="3a152e1aa09a1f7c436eafcd44ff191b58dde03b" translate="yes" xml:space="preserve">
          <source>Exit with a zero status even if no files matched.</source>
          <target state="translated">일치하는 파일이없는 경우에도 상태 0으로 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="f661c1461c19e28f4ca3bd981e37f108a510e5f9" translate="yes" xml:space="preserve">
          <source>Exit with status &quot;2&quot; when no matching refs are found in the remote repository. Usually the command exits with status &quot;0&quot; to indicate it successfully talked with the remote repository, whether it found any matching refs.</source>
          <target state="translated">원격 저장소에서 일치하는 참조가 없으면 &quot;2&quot;상태로 종료하십시오. 일반적으로 명령은 상태가 &quot;0&quot;으로 종료되어 일치하는 참조를 찾았는지 여부에 관계없이 원격 저장소와 성공적으로 통신했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a5a799b0a561590f135d49ee5ebae00be685efb3" translate="yes" xml:space="preserve">
          <source>Exit with zero status if &amp;lt;object&amp;gt; exists and is a valid object. If &amp;lt;object&amp;gt; is of an invalid format exit with non-zero and emits an error on stderr.</source>
          <target state="translated">&amp;lt;object&amp;gt;가 존재하고 유효한 오브젝트이면 상태 0으로 종료하십시오. &amp;lt;object&amp;gt;가 유효하지 않은 형식 인 경우 0이 아닌 종료하고 stderr에서 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a4fd2157951095e7b5d26b7c3906810fced8fee9" translate="yes" xml:space="preserve">
          <source>Expand the URL of the given remote repository taking into account any &quot;url.&amp;lt;base&amp;gt;.insteadOf&quot; config setting (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) and exit without talking to the remote.</source>
          <target state="translated">&quot;url. &amp;lt;base&amp;gt; .insteadOf&quot;구성 설정 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 참조)을 고려하여 지정된 원격 저장소의 URL을 펼치고 원격과 대화하지 않고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="82a1b2399131b1d56f52c1e5725ea0754c8c3b25" translate="yes" xml:space="preserve">
          <source>Experimental. If set, clients will attempt to communicate with a server using the specified protocol version. If unset, no attempt will be made by the client to communicate using a particular protocol version, this results in protocol version 0 being used. Supported versions:</source>
          <target state="translated">실험적. 설정된 경우 클라이언트는 지정된 프로토콜 버전을 사용하여 서버와 통신을 시도합니다. 설정하지 않으면 클라이언트가 특정 프로토콜 버전을 사용하여 통신하려고 시도하지 않으므로 프로토콜 버전 0이 사용됩니다. 지원되는 버전 :</target>
        </trans-unit>
        <trans-unit id="374e58867af910990ca1f09ab8f9576e68a9b14e" translate="yes" xml:space="preserve">
          <source>Experimental; for internal use only. Can attempt to connect to a remote server for communication using git&amp;rsquo;s wire-protocol version 2. See the documentation for the stateless-connect command for more information.</source>
          <target state="translated">실험적; 내부 전용. git의 와이어 프로토콜 버전 2를 사용하여 통신을 위해 원격 서버에 연결을 시도 할 수 있습니다. 자세한 정보는 stateless-connect 명령의 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5ed48ec751df29bb5c7b56db740a48bfdffd6f47" translate="yes" xml:space="preserve">
          <source>Experimental; for internal use only. Connects to the given remote service for communication using git&amp;rsquo;s wire-protocol version 2. Valid replies to this command are empty line (connection established), &lt;code&gt;fallback&lt;/code&gt; (no smart transport support, fall back to dumb transports) and just exiting with error message printed (can&amp;rsquo;t connect, don&amp;rsquo;t bother trying to fall back). After line feed terminating the positive (empty) response, the output of the service starts. Messages (both request and response) must consist of zero or more PKT-LINEs, terminating in a flush packet. The client must not expect the server to store any state in between request-response pairs. After the connection ends, the remote helper exits.</source>
          <target state="translated">실험적; 내부 전용. git의 와이어 프로토콜 버전 2를 사용하여 통신을 위해 지정된 원격 서비스에 연결합니다.이 명령에 대한 올바른 응답은 빈 줄 (연결 설정 됨), &lt;code&gt;fallback&lt;/code&gt; (스마트 전송 지원 없음, 벙어리 전송으로 폴백 ) 및 오류 메시지가 인쇄 된 상태로 종료 됨 ( 연결할 수 없습니다. 라인 피드가 양 (빈) 응답을 종료 한 후 서비스 출력이 시작됩니다. 메시지 (요청 및 응답 모두)는 0 개 이상의 PKT-LINE으로 구성되어야하며 플러시 패킷으로 종료됩니다. 클라이언트는 서버가 요청-응답 쌍 사이에 상태를 저장하지 않아야합니다. 연결이 끝나면 원격 헬퍼가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e024c1b1cf5dfc23f1661897286cc082f5684cef" translate="yes" xml:space="preserve">
          <source>Expire all reflogs with &lt;code&gt;git reflog expire --expire=now --all&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git reflog expire --expire=now --all&lt;/code&gt; 하여 모든 reflog를 만료 --expire = now --all 합니다.</target>
        </trans-unit>
        <trans-unit id="ee5da57f58adf9c1ddf8dd03613cf7957a586adf" translate="yes" xml:space="preserve">
          <source>Exploring git history</source>
          <target state="translated">자식 역사 탐험</target>
        </trans-unit>
        <trans-unit id="89032b84259ca753da6ee3335cc874eda5aea88c" translate="yes" xml:space="preserve">
          <source>Exploring history</source>
          <target state="translated">역사 탐험</target>
        </trans-unit>
        <trans-unit id="9594b6cd33e22cedcea0b51e30d878456e8b0103" translate="yes" xml:space="preserve">
          <source>Export Git tags to p4 labels, as per --export-labels.</source>
          <target state="translated">--export-labels에 따라 Git 태그를 p4 레이블로 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="1d5637309048195a7021fdbec654e04c3399ceec" translate="yes" xml:space="preserve">
          <source>Export a single commit to a CVS checkout</source>
          <target state="translated">단일 커밋을 CVS 체크 아웃으로 내보내기</target>
        </trans-unit>
        <trans-unit id="3b1e75b4d51f1271061fcd403a0829e4ee2dbe12" translate="yes" xml:space="preserve">
          <source>Export files with a prefix</source>
          <target state="translated">접두사를 사용하여 파일 내보내기</target>
        </trans-unit>
        <trans-unit id="265e5cf875ec82b17c2d01a82792a32a43a95b55" translate="yes" xml:space="preserve">
          <source>Export tags from Git as p4 labels. Tags found in Git are applied to the perforce working directory.</source>
          <target state="translated">Git에서 p4 레이블로 태그를 내 보냅니다. Git에있는 태그는 perforce 작업 디렉토리에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e1e5965077094d7c4756e516413e72a854f313c9" translate="yes" xml:space="preserve">
          <source>Exporting a Git repository via the Git protocol</source>
          <target state="translated">Git 프로토콜을 통해 Git 리포지토리 내보내기</target>
        </trans-unit>
        <trans-unit id="70581f8681dac905a7c1fddd025df98d77759bfd" translate="yes" xml:space="preserve">
          <source>Exporting a git repository via HTTP</source>
          <target state="translated">HTTP를 통해 git 저장소 내보내기</target>
        </trans-unit>
        <trans-unit id="7d0c2b669436b3c66b28c30bf0f8b2f1227f2bfb" translate="yes" xml:space="preserve">
          <source>Exports a commit from Git to a CVS checkout, making it easier to merge patches from a Git repository into a CVS repository.</source>
          <target state="translated">Git에서 CVS 체크 아웃으로 커밋을 내보내 Git 리포지토리에서 CVS 리포지토리로 패치를 쉽게 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91d81689bc4c223caafef827873bd7159612ae71" translate="yes" xml:space="preserve">
          <source>External Systems</source>
          <target state="translated">외부 시스템</target>
        </trans-unit>
        <trans-unit id="fa9abe3df3ff3676c618be0248e4529ceae9c936" translate="yes" xml:space="preserve">
          <source>External data format</source>
          <target state="translated">외부 데이터 형식</target>
        </trans-unit>
        <trans-unit id="0b01e11ac46c849a71c428abcd94e12009d5387f" translate="yes" xml:space="preserve">
          <source>Extract all commits that lead to &lt;code&gt;origin&lt;/code&gt; since the inception of the project:</source>
          <target state="translated">으로 이어질 모든 커밋 추출 &lt;code&gt;origin&lt;/code&gt; 프로젝트의 개시 이후를 :</target>
        </trans-unit>
        <trans-unit id="86dd39e46e8ada53c01392c7b98857ff781b5490" translate="yes" xml:space="preserve">
          <source>Extract all commits which are in the current branch but not in the origin branch:</source>
          <target state="translated">현재 브랜치에 있지만 오리진 브랜치에는없는 모든 커밋을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="293a4ac8183e30cb22a3c912e62cea8f83a17a45" translate="yes" xml:space="preserve">
          <source>Extract commit ID from an archive created using git-archive</source>
          <target state="translated">git-archive를 사용하여 생성 된 아카이브에서 커밋 ID 추출</target>
        </trans-unit>
        <trans-unit id="e52c75685be818f69a594f72535500e2b5f0de7d" translate="yes" xml:space="preserve">
          <source>Extract commits between revisions R1 and R2, and apply them on top of the current branch using &lt;code&gt;git am&lt;/code&gt; to cherry-pick them:</source>
          <target state="translated">개정판 R1과 R2 사이의 커밋을 추출하고 &lt;code&gt;git am&lt;/code&gt; 을 사용하여 현재 브랜치 위에 적용 하여 체리 피킹하십시오.</target>
        </trans-unit>
        <trans-unit id="a8d5387dbff833fee6e262477f3c484440daa076" translate="yes" xml:space="preserve">
          <source>Extract the last commit as a patch, and add a &lt;code&gt;Cc&lt;/code&gt; and a &lt;code&gt;Reviewed-by&lt;/code&gt; trailer to it:</source>
          <target state="translated">마지막 커밋을 패치로 추출한 후 &lt;code&gt;Cc&lt;/code&gt; 및 &lt;code&gt;Reviewed-by&lt;/code&gt; 트레일러를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d9851ec1c9a62576efac72204eb04797ad73e77a" translate="yes" xml:space="preserve">
          <source>Extract three topmost commits from the current branch and format them as e-mailable patches:</source>
          <target state="translated">현재 브랜치에서 최상위 커밋 3 개를 추출하여 전자 우편 패치로 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="849870ce78e05c63608a62580dff149aaa2767a8" translate="yes" xml:space="preserve">
          <source>Extracted diagnostics</source>
          <target state="translated">추출 된 진단</target>
        </trans-unit>
        <trans-unit id="fd728d82ed551d8e8658407681eee58615e4b172" translate="yes" xml:space="preserve">
          <source>Extracts patch and authorship from a single e-mail message</source>
          <target state="translated">단일 전자 메일 메시지에서 패치 및 저작권 추출</target>
        </trans-unit>
        <trans-unit id="77dbd3520a3a25fa2f64b3a79e8cdd2c5b438dfc" translate="yes" xml:space="preserve">
          <source>False by default.</source>
          <target state="translated">기본적으로 False입니다.</target>
        </trans-unit>
        <trans-unit id="8f5880afd2dba5ba402b936eb6b908e040c6c17a" translate="yes" xml:space="preserve">
          <source>Fast-forward merge</source>
          <target state="translated">빨리 감기 병합</target>
        </trans-unit>
        <trans-unit id="235360a9581b02e6b66f950074d19d23f01883c5" translate="yes" xml:space="preserve">
          <source>Fast-forward merges</source>
          <target state="translated">빨리 감기 병합</target>
        </trans-unit>
        <trans-unit id="4b4c24663902945e814f463b99629f081662828a" translate="yes" xml:space="preserve">
          <source>Features in &lt;code&gt;%feature&lt;/code&gt;</source>
          <target state="translated">기능의 &lt;code&gt;%feature&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac7a3c81a6bcc5d5ecdbb8a42e39a3cabf204420" translate="yes" xml:space="preserve">
          <source>Fetch &amp;lt;n&amp;gt; log entries per request when scanning Subversion history. The default is 100. For very large Subversion repositories, larger values may be needed for &lt;code&gt;clone&lt;/code&gt;/&lt;code&gt;fetch&lt;/code&gt; to complete in reasonable time. But overly large values may lead to higher memory usage and request timeouts.</source>
          <target state="translated">Subversion 기록을 검색 할 때 요청 당 &amp;lt;n&amp;gt; 로그 항목을 가져옵니다. 기본값은 100입니다. 매우 큰 Subversion 리포지토리의 경우 적절한 시간 내에 &lt;code&gt;clone&lt;/code&gt; / &lt;code&gt;fetch&lt;/code&gt; 를 완료 하려면 더 큰 값이 필요할 수 있습니다 . 그러나 값이 너무 크면 메모리 사용량이 높아지고 요청 시간이 초과 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fa9cbd39c84571e7bd481863d7516ff6663aa26" translate="yes" xml:space="preserve">
          <source>Fetch a &quot;thin&quot; pack, which records objects in deltified form based on objects not included in the pack to reduce network traffic.</source>
          <target state="translated">네트워크 트래픽을 줄이기 위해 팩에 포함되지 않은 개체를 기반으로 개체를 축소 된 형태로 기록하는 &quot;씬&quot;팩을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bfa61173eb5ea4c62442430cdd5a0f9a2ccdc304" translate="yes" xml:space="preserve">
          <source>Fetch a branch from a different repository, and give it a new name in your repository:</source>
          <target state="translated">다른 저장소에서 지점을 가져오고 저장소에 새 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="5f0a6423762963194f97ca1e3c9e8131a33fa3bd" translate="yes" xml:space="preserve">
          <source>Fetch a branch in a different Git repository, then merge into the current branch:</source>
          <target state="translated">다른 Git 리포지토리에서 분기를 가져온 다음 현재 분기로 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="4b2c92720b4e036e2e3a513a4ac4888b092fd45b" translate="yes" xml:space="preserve">
          <source>Fetch all remote refs.</source>
          <target state="translated">모든 원격 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="fc6f62670a87982450c7fd1465c966b498d51b73" translate="yes" xml:space="preserve">
          <source>Fetch all remotes.</source>
          <target state="translated">모든 리모컨을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7176a82579f2b775ede7e6b5698f625105e5e80d" translate="yes" xml:space="preserve">
          <source>Fetch all tags from the remote (i.e., fetch remote tags &lt;code&gt;refs/tags/*&lt;/code&gt; into local tags with the same name), in addition to whatever else would otherwise be fetched. Using this option alone does not subject tags to pruning, even if --prune is used (though tags may be pruned anyway if they are also the destination of an explicit refspec; see &lt;code&gt;--prune&lt;/code&gt;).</source>
          <target state="translated">다른 방법으로 가져올 수있는 것 외에 원격에서 모든 태그를 가져옵니다 (즉, 원격 태그 참조 &lt;code&gt;refs/tags/*&lt;/code&gt; 를 동일한 이름의 로컬 태그로 가져 오기 ). 이 옵션 만 사용하면 --prune이 사용 되더라도 태그를 제거 (prune)하지 않습니다 (태그가 명시 적 참조 &lt;code&gt;--prune&lt;/code&gt; 의 대상인 경우에도 제거 될 수 있지만 --prune 참조 ).</target>
        </trans-unit>
        <trans-unit id="24eb114caf72bd86613f02567ef244ced32c67f3" translate="yes" xml:space="preserve">
          <source>Fetch branches and/or tags (collectively, &quot;refs&quot;) from one or more other repositories, along with the objects necessary to complete their histories. Remote-tracking branches are updated (see the description of &amp;lt;refspec&amp;gt; below for ways to control this behavior).</source>
          <target state="translated">히스토리를 완료하는 데 필요한 오브젝트와 함께 하나 이상의 다른 저장소에서 브랜치 및 / 또는 태그 (통칭하여 &quot;참조&quot;)를 가져옵니다. 원격 추적 분기가 업데이트됩니다 (이 동작을 제어하는 ​​방법은 아래 &amp;lt;refspec&amp;gt; 설명 참조).</target>
        </trans-unit>
        <trans-unit id="31082e75ce46d9d1d50a3e2e4d3442657ed8677f" translate="yes" xml:space="preserve">
          <source>Fetch from and integrate with another repository or a local branch</source>
          <target state="translated">다른 리포지토리 또는 로컬 브랜치에서 페치 및 통합</target>
        </trans-unit>
        <trans-unit id="31bd9486b123aa2097f6934aa8fc09cb0582f241" translate="yes" xml:space="preserve">
          <source>Fetch master, using file descriptor #17 to communicate with git-upload-pack.</source>
          <target state="translated">git-upload-pack과 통신하기 위해 파일 디스크립터 # 17을 사용하여 마스터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c7b7a55dc86420061c3ee2c8e313312034e265da" translate="yes" xml:space="preserve">
          <source>Fetch only from the SVN parent of the current HEAD.</source>
          <target state="translated">현재 HEAD의 SVN 상위에서만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ab869fa62e8a09f8f5c922fc9c36375323cdbbc8" translate="yes" xml:space="preserve">
          <source>Fetch unfetched revisions from the Subversion remote we are tracking. The name of the [svn-remote &quot;&amp;hellip;​&quot;] section in the $GIT_DIR/config file may be specified as an optional command-line argument.</source>
          <target state="translated">추적중인 Subversion 원격에서 가져 오지 않은 개정을 가져옵니다. $ GIT_DIR / config 파일에서 [svn-remote &quot;&amp;hellip;&quot;] 섹션의 이름은 선택적 명령 행 인수로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15a003694d110886a95c99728ccaa08a956586a4" translate="yes" xml:space="preserve">
          <source>Fetch updates for remotes or remote groups in the repository as defined by remotes.&amp;lt;group&amp;gt;. If neither group nor remote is specified on the command line, the configuration parameter remotes.default will be used; if remotes.default is not defined, all remotes which do not have the configuration parameter remote.&amp;lt;name&amp;gt;.skipDefaultUpdate set to true will be updated. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">remotes. &amp;lt;group&amp;gt;에 의해 정의 된 리포지토리에서 원격 또는 원격 그룹에 대한 업데이트를 가져옵니다. 명령 행에 group 또는 remote가 지정되지 않은 경우 구성 매개 변수 remotes.default가 사용됩니다. remotes.default가 정의되지 않은 경우 구성 매개 변수 remote. &amp;lt;name&amp;gt; .skipDefaultUpdate가 true로 설정되지 않은 모든 원격이 업데이트됩니다. ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="82e98a6b98be0542f3ca46bd6c66454d11bde6bb" translate="yes" xml:space="preserve">
          <source>Fetches the given object, writing the necessary objects to the database. Fetch commands are sent in a batch, one per line, terminated with a blank line. Outputs a single blank line when all fetch commands in the same batch are complete. Only objects which were reported in the output of &lt;code&gt;list&lt;/code&gt; with a sha1 may be fetched this way.</source>
          <target state="translated">주어진 객체를 가져 와서 필요한 객체를 데이터베이스에 씁니다. 페치 명령은 한 줄에 하나씩 배치로 전송되며 빈 줄로 종료됩니다. 동일한 배치의 모든 페치 명령이 완료되면 단일 빈 줄을 출력합니다. sha1을 사용하여 &lt;code&gt;list&lt;/code&gt; 의 출력에서보고 된 객체 만이 방식으로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e512ef616863b90580db01bc69e67097028beb3" translate="yes" xml:space="preserve">
          <source>Fetching a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; means to get the branch&amp;rsquo;s &lt;a href=&quot;#def_head_ref&quot;&gt;head ref&lt;/a&gt; from a remote &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;, to find out which objects are missing from the local &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt;, and to get them, too. See also &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_branch&quot;&gt;브랜치를&lt;/a&gt; 가져 오는 것은 원격 &lt;a href=&quot;#def_repository&quot;&gt;저장소&lt;/a&gt; 에서 브랜치의 &lt;a href=&quot;#def_head_ref&quot;&gt;헤드 참조&lt;/a&gt; 를 가져 와서 로컬 &lt;a href=&quot;#def_object_database&quot;&gt;오브젝트 데이터베이스&lt;/a&gt; 에서 누락 된 오브젝트를 찾아서 가져 오는 것을 의미합니다 . &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca528f4260a5f0ff38dd8302ddb33ede05c8ee7e" translate="yes" xml:space="preserve">
          <source>Fetching branches from other repositories</source>
          <target state="translated">다른 저장소에서 브랜치 가져 오기</target>
        </trans-unit>
        <trans-unit id="38fdecc5037849cb76e9ff10175400ab8d8520f4" translate="yes" xml:space="preserve">
          <source>Fetching from a remote repository is done by, unsurprisingly, &lt;code&gt;git fetch&lt;/code&gt;:</source>
          <target state="translated">원격 저장소에서 가져 오는 것은 놀랍지 않게 &lt;code&gt;git fetch&lt;/code&gt; 에 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="66837c163f00048d36bcb5882cef29f3589ed957" translate="yes" xml:space="preserve">
          <source>Fetching individual branches</source>
          <target state="translated">개별 분기를 가져 오는 중</target>
        </trans-unit>
        <trans-unit id="95fb769cdd33ccd5fcde15b12c59c0228df81279" translate="yes" xml:space="preserve">
          <source>Field names</source>
          <target state="translated">필드 이름</target>
        </trans-unit>
        <trans-unit id="7d4e1fd5661dae539542971bb6b2fc728d599c94" translate="yes" xml:space="preserve">
          <source>Fields that have name-email-date tuple as its value (&lt;code&gt;author&lt;/code&gt;, &lt;code&gt;committer&lt;/code&gt;, and &lt;code&gt;tagger&lt;/code&gt;) can be suffixed with &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt;, and &lt;code&gt;date&lt;/code&gt; to extract the named component.</source>
          <target state="translated">name-email-date 튜플이 값 ( &lt;code&gt;author&lt;/code&gt; , &lt;code&gt;committer&lt;/code&gt; 및 &lt;code&gt;tagger&lt;/code&gt; ) 인 필드는 &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;email&lt;/code&gt; 및 &lt;code&gt;date&lt;/code&gt; 로 접미사를 붙여 명명 된 구성 요소를 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed2ff2065be5f4efd23916d9b5c024804bb05ec6" translate="yes" xml:space="preserve">
          <source>Fields use modified URI encoding, defined in RFC 3986, section 2.1 (Percent-Encoding), or rather &quot;Query string encoding&quot; (see &lt;a href=&quot;https://en.wikipedia.org/wiki/Query_string#URL_encoding&quot;&gt;https://en.wikipedia.org/wiki/Query_string#URL_encoding&lt;/a&gt;), the difference being that SP (&quot; &quot;) can be encoded as &quot;+&quot; (and therefore &quot;+&quot; has to be also percent-encoded).</source>
          <target state="translated">필드는 RFC 3986, 섹션 2.1 (퍼센트 인코딩) 또는 &quot;쿼리 문자열 인코딩&quot;( &lt;a href=&quot;https://en.wikipedia.org/wiki/Query_string#URL_encoding&quot;&gt;https://en.wikipedia.org/wiki/Query_string#URL_encoding 참조&lt;/a&gt; )에 정의 된 수정 된 URI 인코딩을 사용합니다. ( &quot;&quot;)는 &quot;+&quot;로 인코딩 될 수 있으므로 &quot;+&quot;도 퍼센트로 인코딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ff9cc1a6f5bb5a91d014bd56871d8a7e6dedf925" translate="yes" xml:space="preserve">
          <source>Fighting regressions overview</source>
          <target state="translated">파이팅 회귀 분석 개요</target>
        </trans-unit>
        <trans-unit id="dc286ffc3d263eab0659e5254ed6cbdfe1ed4661" translate="yes" xml:space="preserve">
          <source>Figuring out why this works is left as an exercise to the (advanced) student. The &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree[1]&lt;/a&gt;, and &lt;a href=&quot;git-hash-object&quot;&gt;git-hash-object[1]&lt;/a&gt; man pages may prove helpful.</source>
          <target state="translated">이것이 왜 효과가 있는지를 알아내는 것은 (고급) 학생에게 연습으로 남습니다. &lt;a href=&quot;git-log&quot;&gt;자식 로그 [1]&lt;/a&gt; , &lt;a href=&quot;git-diff-tree&quot;&gt;자식-DIFF 트리 [1]&lt;/a&gt; , 그리고 &lt;a href=&quot;git-hash-object&quot;&gt;자식 해시 객체 [1]&lt;/a&gt; 사람이 페이지는 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39b2ed94cef5d6961eea0620d66a925578f2f283" translate="yes" xml:space="preserve">
          <source>File containing the SSL certificate when fetching or pushing over HTTPS. Can be overridden by the &lt;code&gt;GIT_SSL_CERT&lt;/code&gt; environment variable.</source>
          <target state="translated">HTTPS를 가져 오거나 푸시 할 때 SSL 인증서가 포함 된 파일입니다. &lt;code&gt;GIT_SSL_CERT&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3b34071a7a6143f1cfbfe18d8122a378b6725a7" translate="yes" xml:space="preserve">
          <source>File containing the SSL private key when fetching or pushing over HTTPS. Can be overridden by the &lt;code&gt;GIT_SSL_KEY&lt;/code&gt; environment variable.</source>
          <target state="translated">HTTPS를 가져 오거나 푸시 할 때 SSL 개인 키가 포함 된 파일입니다. &lt;code&gt;GIT_SSL_KEY&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a25f7e6a9a15db1a7bb16a1513a308705fbf008c" translate="yes" xml:space="preserve">
          <source>File containing the certificates to verify the peer with when fetching or pushing over HTTPS. Can be overridden by the &lt;code&gt;GIT_SSL_CAINFO&lt;/code&gt; environment variable.</source>
          <target state="translated">HTTPS를 가져 오거나 푸시 할 때 피어를 확인할 인증서가 포함 된 파일입니다. &lt;code&gt;GIT_SSL_CAINFO&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51de61b9fb1649e39093ab80c2a7df2f9e16643a" translate="yes" xml:space="preserve">
          <source>File globbing matches across directory boundaries. Thus, given two directories &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;d2&lt;/code&gt;, there is a difference between using &lt;code&gt;git rm 'd*'&lt;/code&gt; and &lt;code&gt;git rm 'd/*'&lt;/code&gt;, as the former will also remove all of directory &lt;code&gt;d2&lt;/code&gt;.</source>
          <target state="translated">파일 글 로빙은 디렉토리 경계에서 일치합니다. 따라서, 두 주어진 디렉토리 &lt;code&gt;d&lt;/code&gt; 및 &lt;code&gt;d2&lt;/code&gt; 존재하여 차인 &lt;code&gt;git rm 'd*'&lt;/code&gt; 와 &lt;code&gt;git rm 'd/*'&lt;/code&gt; 전 또한 디렉토리 모두 제거되므로, &lt;code&gt;d2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46bdca067f191e47ac236c4a9946147313edeadf" translate="yes" xml:space="preserve">
          <source>File inclusion (&lt;code&gt;:include: /path/name&lt;/code&gt;) is not supported.</source>
          <target state="translated">파일 포함 ( &lt;code&gt;:include: /path/name&lt;/code&gt; )은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0052ebd08e3dda2e68d8ee7b082b7c890d6ddeef" translate="yes" xml:space="preserve">
          <source>File indicating how to order files within a diff. See the &lt;code&gt;-O&lt;/code&gt; option to &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; for details. If &lt;code&gt;diff.orderFile&lt;/code&gt; is a relative pathname, it is treated as relative to the top of the working tree.</source>
          <target state="translated">diff 내에서 파일을 주문하는 방법을 나타내는 파일입니다. 자세한 내용은 &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 의 &lt;code&gt;-O&lt;/code&gt; 옵션을 참조 하십시오. 경우 &lt;code&gt;diff.orderFile&lt;/code&gt; 가 상대 경로 이름입니다, 그것은 작업 트리의 상단을 기준으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="f2b61a4d1705fa3305542b48c5c1ffd38b30200f" translate="yes" xml:space="preserve">
          <source>File modes are printed as 6-digit octal numbers including the file type and file permission bits.</source>
          <target state="translated">파일 모드는 파일 형식 및 파일 권한 비트를 포함하여 6 자리 8 진수로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="cd4c7b960aaa326dfff2bf746e515a16b2b5bd4d" translate="yes" xml:space="preserve">
          <source>File system monitor</source>
          <target state="translated">파일 시스템 모니터</target>
        </trans-unit>
        <trans-unit id="dab1e8f60ab6cd6f09a76739b1f40f880fb79310" translate="yes" xml:space="preserve">
          <source>File to use for (filename extension based) guessing of MIME types before trying &lt;code&gt;/etc/mime.types&lt;/code&gt;. &lt;strong&gt;NOTE&lt;/strong&gt; that this path, if relative, is taken as relative to the current Git repository, not to CGI script. If unset, only &lt;code&gt;/etc/mime.types&lt;/code&gt; is used (if present on filesystem). If no mimetypes file is found, mimetype guessing based on extension of file is disabled. Unset by default.</source>
          <target state="translated">&lt;code&gt;/etc/mime.types&lt;/code&gt; 를 시도하기 전에 MIME 유형을 추측하는 데 사용할 파일 (확장명 기반) 입니다. &lt;strong&gt;참고&lt;/strong&gt; 이 경로가 상대하는 경우,하지 CGI 스크립트, 현재 Git 저장소에 상대적으로 간주됩니다. 설정하지 않으면 &lt;code&gt;/etc/mime.types&lt;/code&gt; 만 사용됩니다 (파일 시스템에있는 경우). mimetypes 파일이 없으면 파일 확장자에 따른 mimetype 추측이 비활성화됩니다. 기본적으로 설정 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f045415cfa170f304a990874fe0966e6d4eacafb" translate="yes" xml:space="preserve">
          <source>File with repository URL (used for clone and fetch), one per line. Displayed in the project summary page. You can use multiple-valued &lt;code&gt;gitweb.url&lt;/code&gt; repository configuration variable for that, but the file takes precedence.</source>
          <target state="translated">저장소 URL (복제 및 가져 오기에 사용)이있는 파일 (한 줄에 하나씩) 프로젝트 요약 페이지에 표시됩니다. 이를 위해 다중 값 &lt;code&gt;gitweb.url&lt;/code&gt; 저장소 구성 변수를 사용할 수 있지만 파일이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="f73380191ad1f1caa70019147dbb81cb74dd0fbd" translate="yes" xml:space="preserve">
          <source>File/directory structure</source>
          <target state="translated">파일 / 디렉토리 구조</target>
        </trans-unit>
        <trans-unit id="ee97d026e695edaa3af17191656d312a0a7a2ccb" translate="yes" xml:space="preserve">
          <source>Filenames with spaces are often mishandled by shell snippets since they cause problems for shell pipelines. Not everyone is familiar with find -print0, xargs -0, git-ls-files -z, etc. Even people who are familiar with these may assume such flags are not relevant because someone else renamed any such files in their repo back before the person doing the filtering joined the project. And often, even those familiar with handling arguments with spaces may not do so just because they aren&amp;rsquo;t in the mindset of thinking about everything that could possibly go wrong.</source>
          <target state="translated">공백이있는 파일 이름은 셸 파이프 라인에 문제를 유발하기 때문에 셸 스 니펫으로 잘못 처리되는 경우가 많습니다. 모든 사람이 find -print0, xargs -0, git-ls-files -z 등에 익숙하지는 않습니다. 이러한 플래그에 익숙한 사람들도 다른 사람이 이전에 해당 파일의 이름을 바꿨 기 때문에 이러한 플래그는 관련이 없다고 가정 할 수 있습니다. 필터링을 수행하는 사람이 프로젝트에 참여했습니다. 그리고 공백으로 인수를 다루는 데 익숙한 사람들조차도 잘못 될 수있는 모든 것에 대해 생각할 생각이 없기 때문에 그렇게하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="669b1abdd74168ff79423d155c9ddb7e43a80b6e" translate="yes" xml:space="preserve">
          <source>Files (and pointers to subtrees) within active trees require 52 or 64 bytes (32/64 bit platforms) per entry. To conserve space, file and tree names are pooled in a common string table, allowing the filename &amp;ldquo;Makefile&amp;rdquo; to use just 16 bytes (after including the string header overhead) no matter how many times it occurs within the project.</source>
          <target state="translated">활성 트리 내의 파일 (및 하위 트리에 대한 포인터)은 항목 당 52 또는 64 바이트 (32/64 비트 플랫폼)가 필요합니다. 공간을 절약하기 위해 파일 및 트리 이름이 공통 문자열 테이블에 풀링되어 파일 이름 &quot;Makefile&quot;이 프로젝트 내에서 발생하는 횟수에 관계없이 파일 이름 &quot;Makefile&quot;이 16 바이트 만 사용할 수 있습니다 (문자열 헤더 오버 헤드 포함).</target>
        </trans-unit>
        <trans-unit id="94bbb76c1352043c45a00df324ef04fea70e6730" translate="yes" xml:space="preserve">
          <source>Files and directories in the template directory whose name do not start with a dot will be copied to the &lt;code&gt;$GIT_DIR&lt;/code&gt; after it is created.</source>
          <target state="translated">이름이 점으로 시작하지 않는 템플리트 디렉토리의 파일 및 디렉토리 는 작성된 후 &lt;code&gt;$GIT_DIR&lt;/code&gt; 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1270c9a81ec2853fddc0c884f8ccb1e8a45b97e" translate="yes" xml:space="preserve">
          <source>Files and directories with the attribute &lt;code&gt;export-ignore&lt;/code&gt; won&amp;rsquo;t be added to archive files.</source>
          <target state="translated">&lt;code&gt;export-ignore&lt;/code&gt; 속성을 가진 파일 및 디렉토리는 아카이브 파일에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3974c4c3ce398cf177c9471660017bb110038df" translate="yes" xml:space="preserve">
          <source>Files and directories with the attribute export-ignore won&amp;rsquo;t be added to archive files. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">export-ignore 속성을 가진 파일 및 디렉토리는 아카이브 파일에 추가되지 않습니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a7b0ec5c5be81a4a3b161d0317a98cc9a7a62cb3" translate="yes" xml:space="preserve">
          <source>Files larger than this size are stored deflated, without attempting delta compression. Storing large files without delta compression avoids excessive memory usage, at the slight expense of increased disk usage. Additionally files larger than this size are always treated as binary.</source>
          <target state="translated">이 크기보다 큰 파일은 델타 압축을 시도하지 않고 수축 된 상태로 저장됩니다. 델타 압축없이 큰 파일을 저장하면 디스크 사용량이 약간 증가하더라도 과도한 메모리 사용을 피할 수 있습니다. 또한이 크기보다 큰 파일은 항상 이진으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b57b0d88e9fd775cd564cc119a3989093d68ff8d" translate="yes" xml:space="preserve">
          <source>Files to act on. Note that files beginning with &lt;code&gt;.&lt;/code&gt; are discarded. This includes &lt;code&gt;./file&lt;/code&gt; and &lt;code&gt;dir/./file&lt;/code&gt;. If you don&amp;rsquo;t want this, then use cleaner names. The same applies to directories ending &lt;code&gt;/&lt;/code&gt; and paths with &lt;code&gt;//&lt;/code&gt;</source>
          <target state="translated">작동 할 파일. 로 시작하는 파일에 유의하십시오 &lt;code&gt;.&lt;/code&gt; 폐기됩니다. 여기에는 &lt;code&gt;./file&lt;/code&gt; 및 &lt;code&gt;dir/./file&lt;/code&gt; 이 포함 됩니다 . 이것을 원하지 않으면 더 명확한 이름을 사용하십시오. 동일은 종료 디렉토리에 적용 &lt;code&gt;/&lt;/code&gt; 와 경로 &lt;code&gt;//&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a229bb6156d5f90b453ca5e0ca33977f1a3e6a8a" translate="yes" xml:space="preserve">
          <source>Files to add content from. Fileglobs (e.g. &lt;code&gt;*.c&lt;/code&gt;) can be given to add all matching files. Also a leading directory name (e.g. &lt;code&gt;dir&lt;/code&gt; to add &lt;code&gt;dir/file1&lt;/code&gt; and &lt;code&gt;dir/file2&lt;/code&gt;) can be given to update the index to match the current state of the directory as a whole (e.g. specifying &lt;code&gt;dir&lt;/code&gt; will record not just a file &lt;code&gt;dir/file1&lt;/code&gt; modified in the working tree, a file &lt;code&gt;dir/file2&lt;/code&gt; added to the working tree, but also a file &lt;code&gt;dir/file3&lt;/code&gt; removed from the working tree). Note that older versions of Git used to ignore removed files; use &lt;code&gt;--no-all&lt;/code&gt; option if you want to add modified or new files but ignore removed ones.</source>
          <target state="translated">컨텐츠를 추가 할 파일입니다. 일치하는 모든 파일을 추가하기 위해 Fileglobs (예 : &lt;code&gt;*.c&lt;/code&gt; )를 제공 할 수 있습니다. 또한 주요 디렉토리 이름 (예 : &lt;code&gt;dir&lt;/code&gt; 추가 &lt;code&gt;dir/file1&lt;/code&gt; 및 &lt;code&gt;dir/file2&lt;/code&gt; (예를 들면 지정 전체 디렉토리의 현재 상태와 일치하는 인덱스를 업데이트 주어질 수있다) &lt;code&gt;dir&lt;/code&gt; 아닌 파일을 기록 할 &lt;code&gt;dir/file1&lt;/code&gt; 수정 작업 트리에서 파일 &lt;code&gt;dir/file2&lt;/code&gt; 가 작업 트리에 추가되었지만 파일 &lt;code&gt;dir/file3&lt;/code&gt; 이 작업 트리에서 제거되었습니다. 이전 버전의 Git은 제거 된 파일을 무시하는 데 사용되었습니다. 수정되거나 새 파일을 추가하지만 제거 된 파일은 무시 하려면 &lt;code&gt;--no-all&lt;/code&gt; 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6fcfbd1668d25020111102295bf825ad36cd4ad7" translate="yes" xml:space="preserve">
          <source>Files to remove. Fileglobs (e.g. &lt;code&gt;*.c&lt;/code&gt;) can be given to remove all matching files. If you want Git to expand file glob characters, you may need to shell-escape them. A leading directory name (e.g. &lt;code&gt;dir&lt;/code&gt; to remove &lt;code&gt;dir/file1&lt;/code&gt; and &lt;code&gt;dir/file2&lt;/code&gt;) can be given to remove all files in the directory, and recursively all sub-directories, but this requires the &lt;code&gt;-r&lt;/code&gt; option to be explicitly given.</source>
          <target state="translated">제거 할 파일. 일치하는 모든 파일을 제거하기 위해 Fileglobs (예 : &lt;code&gt;*.c&lt;/code&gt; )를 제공 할 수 있습니다. Git이 파일 glob 문자를 확장하도록하려면 쉘 이스케이프해야합니다. 디렉토리의 모든 파일과 재귀 적으로 모든 서브 &lt;code&gt;dir&lt;/code&gt; 를 제거하기 위해 디렉토리 이름 (예 : dir &lt;code&gt;dir/file1&lt;/code&gt; 및 &lt;code&gt;dir/file2&lt;/code&gt; 를 제거하기위한 dir )을 지정할 수 있지만, &lt;code&gt;-r&lt;/code&gt; 옵션을 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d69266d087a66debaeaa16301b1f83a323ef3a05" translate="yes" xml:space="preserve">
          <source>Files to show. If no files are given all files which match the other specified criteria are shown.</source>
          <target state="translated">표시 할 파일입니다. 파일이 제공되지 않으면 지정된 다른 기준과 일치하는 모든 파일이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="94b61f142196a44a91e5065c7d0adcb5cad7dae3" translate="yes" xml:space="preserve">
          <source>Files with conflicts are marked specially in the index, so until you resolve the problem and update the index, &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; will fail:</source>
          <target state="translated">충돌이있는 파일은 인덱스에 특별히 표시되므로 문제를 해결하고 인덱스를 업데이트 할 때까지 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="96e578211aa295317cf257310712fa28ccd8f6c6" translate="yes" xml:space="preserve">
          <source>Filters</source>
          <target state="translated">Filters</target>
        </trans-unit>
        <trans-unit id="1cf100e1097311bd9759a52dc063dba54a0c3fc0" translate="yes" xml:space="preserve">
          <source>Finalize an in-progress &lt;code&gt;git notes merge&lt;/code&gt;. Use this option when you have resolved the conflicts that &lt;code&gt;git notes merge&lt;/code&gt; stored in .git/NOTES_MERGE_WORKTREE. This amends the partial merge commit created by &lt;code&gt;git notes merge&lt;/code&gt; (stored in .git/NOTES_MERGE_PARTIAL) by adding the notes in .git/NOTES_MERGE_WORKTREE. The notes ref stored in the .git/NOTES_MERGE_REF symref is updated to the resulting commit.</source>
          <target state="translated">진행중인 &lt;code&gt;git notes merge&lt;/code&gt; 를 마무리하십시오 . &lt;code&gt;git notes merge&lt;/code&gt; 가 .git / NOTES_MERGE_WORKTREE에 저장된 병합 충돌을 해결 한 경우이 옵션을 사용하십시오 . 이것은 .git / NOTES_MERGE_WORKTREE에 메모를 추가하여 &lt;code&gt;git notes merge&lt;/code&gt; (.git / NOTES_MERGE_PARTIAL에 저장 됨)에 의해 생성 된 부분 병합 커밋을 수정합니다 . .git / NOTES_MERGE_REF symref에 저장된 노트 참조는 결과 커밋으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="9eb00b677ea152c9f2f0f234add05ac350dd5a77" translate="yes" xml:space="preserve">
          <source>Finally it examines &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt;. This file is used to override the in-tree settings. The first line is a match, and &lt;code&gt;foo&lt;/code&gt; is set, &lt;code&gt;bar&lt;/code&gt; is reverted to unspecified state, and &lt;code&gt;baz&lt;/code&gt; is unset.</source>
          <target state="translated">마지막으로 &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; 검사 합니다 . 이 파일은 인트 리 설정을 재정의하는 데 사용됩니다. 첫 번째 줄은 일치하고 &lt;code&gt;foo&lt;/code&gt; 가 설정되고 &lt;code&gt;bar&lt;/code&gt; 는 지정되지 않은 상태로 되돌아 &lt;code&gt;baz&lt;/code&gt; 는 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="331d183abb3e32c5b94fe163358b0bd60def41df" translate="yes" xml:space="preserve">
          <source>Finally, if &lt;code&gt;--expire-time=&amp;lt;datetime&amp;gt;&lt;/code&gt; is not specified, let &lt;code&gt;datetime&lt;/code&gt; be the current time. After writing the split commit-graph, delete all unused commit-graph whose modified times are older than &lt;code&gt;datetime&lt;/code&gt;.</source>
          <target state="translated">마지막으로 &lt;code&gt;--expire-time=&amp;lt;datetime&amp;gt;&lt;/code&gt; 을 지정하지 않으면 &lt;code&gt;datetime&lt;/code&gt; 을 현재 시간으로 둡니다 . split commit-graph를 작성한 후 수정 된 시간이 &lt;code&gt;datetime&lt;/code&gt; 보다 오래된 모든 사용되지 않은 commit-graph를 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="43d1a6457be0c846de5bf38ab3298d9d3628832d" translate="yes" xml:space="preserve">
          <source>Finally, it is possible to specify an arbitrary perl subroutine that will be called for each repository to determine if it can be exported. The subroutine receives an absolute path to the project (repository) as its only parameter (i.e. &quot;$projectroot/$project&quot;).</source>
          <target state="translated">마지막으로, 각 저장소에 대해 호출 될 임의의 perl 서브 루틴을 지정하여 익스포트 가능 여부를 판별 할 수 있습니다. 서브 루틴은 유일한 매개 변수 (예 : &quot;$ projectroot / $ project&quot;)로 프로젝트 (저장소)에 대한 절대 경로를받습니다.</target>
        </trans-unit>
        <trans-unit id="24d1078763f97a2ccc23634e9fb57ca6945117cd" translate="yes" xml:space="preserve">
          <source>Finally, it&amp;rsquo;s worth looking at the effect of &lt;code&gt;git add&lt;/code&gt; on the index file:</source>
          <target state="translated">마지막으로 인덱스 파일에 &lt;code&gt;git add&lt;/code&gt; 의 영향을 살펴볼 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8264955cf61255273040b40a18d8fbbb22fa2f72" translate="yes" xml:space="preserve">
          <source>Finally, most commands that take filenames will optionally allow you to precede any filename by a commit, to specify a particular version of the file:</source>
          <target state="translated">마지막으로 파일 이름을 사용하는 대부분의 명령을 사용하면 파일의 특정 버전을 지정하기 위해 커밋으로 파일 이름 앞에 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c56e02ffa0dc0d04395282d17622dfa271e848b" translate="yes" xml:space="preserve">
          <source>Finally, runs of whitespace are normalized to a single ASCII space character.</source>
          <target state="translated">마지막으로 공백 문자는 단일 ASCII 공백 문자로 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="f254df0ed5803ab0d672797542ab7bd433761746" translate="yes" xml:space="preserve">
          <source>Finally, see &lt;a href=&quot;#todo&quot;&gt;Notes and todo list for this manual&lt;/a&gt; for ways that you can help make this manual more complete.</source>
          <target state="translated">마지막 으로이 매뉴얼을보다 완벽하게 작성하는 데 도움이되는 방법 &lt;a href=&quot;#todo&quot;&gt;은이 매뉴얼의 참고 및 할 일 목록을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f28877b4b3e20afaa3344b89d8d8e7dd3cc9a77" translate="yes" xml:space="preserve">
          <source>Finally, the list of matching commits is shown in the order of the second commit range, with unmatched commits being inserted just after all of their ancestors have been shown.</source>
          <target state="translated">마지막으로 일치하는 커밋 목록은 두 번째 커밋 범위의 순서로 표시되며, 모든 조상이 표시된 직후 일치하지 않는 커밋이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="9a3fea8b3f0925da6c2b86381c6c149ac6f29683" translate="yes" xml:space="preserve">
          <source>Finally, there are a few odds and ends which are not purely moving from one representation to the other:</source>
          <target state="translated">마지막으로, 한 표현에서 다른 표현으로 순전히 이동하지 않는 몇 가지 가능성과 끝이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fe4e962ec8320ef45c1375652f3937a50d04ca2" translate="yes" xml:space="preserve">
          <source>Finally, there is a fifth simplification mode available:</source>
          <target state="translated">마지막으로 다섯 번째 단순화 모드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be9a3fea0f82381aa185e3a3e7bc70453cddfef1" translate="yes" xml:space="preserve">
          <source>Finally, these options can be combined with a layout option (defaults to &lt;code&gt;nodense&lt;/code&gt;):</source>
          <target state="translated">마지막으로 이러한 옵션을 레이아웃 옵션과 결합 할 수 있습니다 (기본값은 &lt;code&gt;nodense&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="20a1c9ffc616ee01b8dce65bdb93f7148cbfeb85" translate="yes" xml:space="preserve">
          <source>Find a helper.</source>
          <target state="translated">도우미를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="30d88faf5655c44ff9e677fe0e00c8e9ca77aa3d" translate="yes" xml:space="preserve">
          <source>Find a ref that matches &lt;code&gt;experimental&lt;/code&gt; in the &lt;code&gt;origin&lt;/code&gt; repository (e.g. &lt;code&gt;refs/heads/experimental&lt;/code&gt;), and delete it.</source>
          <target state="translated">&lt;code&gt;origin&lt;/code&gt; 저장소 에서 &lt;code&gt;experimental&lt;/code&gt; 일치하는 참조 (예 : &lt;code&gt;refs/heads/experimental&lt;/code&gt; )를 찾아 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="ef251b247769ae2bcbe4a6086b08e0deff95b9d6" translate="yes" xml:space="preserve">
          <source>Find a ref that matches &lt;code&gt;master&lt;/code&gt; in the source repository (most likely, it would find &lt;code&gt;refs/heads/master&lt;/code&gt;), and update the same ref (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) in &lt;code&gt;origin&lt;/code&gt; repository with it. If &lt;code&gt;master&lt;/code&gt; did not exist remotely, it would be created.</source>
          <target state="translated">소스 리포지토리에서 &lt;code&gt;master&lt;/code&gt; 와 일치 하는 리퍼를 찾고 (대개 &lt;code&gt;refs/heads/master&lt;/code&gt; 를 찾을 수 있음 ) &lt;code&gt;origin&lt;/code&gt; 리포지토리 에서 동일한 리퍼 (예 : &lt;code&gt;refs/heads/master&lt;/code&gt; )를 업데이트 합니다. 경우 &lt;code&gt;master&lt;/code&gt; 원격으로 존재하지 않았다, 그것은이 생성 된 것을 알 수있다.</target>
        </trans-unit>
        <trans-unit id="ccef9d1bcc3ad53f8d4e9015291e141315fc185c" translate="yes" xml:space="preserve">
          <source>Find as good common ancestors as possible for a merge</source>
          <target state="translated">합병을 위해 가능한 한 공통 조상을 찾으십시오</target>
        </trans-unit>
        <trans-unit id="d3f173da3a7dce0bd9994325b78952d16aab8240" translate="yes" xml:space="preserve">
          <source>Find commits yet to be applied to upstream</source>
          <target state="translated">업스트림에 아직 적용되지 않은 커밋 찾기</target>
        </trans-unit>
        <trans-unit id="f766cd71208fbf6c57bd1c63b40f06ddd3b5b9dc" translate="yes" xml:space="preserve">
          <source>Find first tagged version including a given fix</source>
          <target state="translated">주어진 수정 사항을 포함하여 처음 태그 된 버전 찾기</target>
        </trans-unit>
        <trans-unit id="df9e9c717faf5fac976a38f227398efdc30aeda9" translate="yes" xml:space="preserve">
          <source>Find redundant pack files</source>
          <target state="translated">중복 팩 파일 찾기</target>
        </trans-unit>
        <trans-unit id="44f9539ac1c361035e9a88da329c269fe8a0f4cb" translate="yes" xml:space="preserve">
          <source>Find symbolic names for given revs</source>
          <target state="translated">주어진 개정에 대한 상징적 이름 찾기</target>
        </trans-unit>
        <trans-unit id="f381cb9cf3280c2142361c5998997b7124410055" translate="yes" xml:space="preserve">
          <source>Find the color configured for &lt;code&gt;name&lt;/code&gt; (e.g. &lt;code&gt;color.diff.new&lt;/code&gt;) and output it as the ANSI color escape sequence to the standard output. The optional &lt;code&gt;default&lt;/code&gt; parameter is used instead, if there is no color configured for &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 에 구성된 색상 (예 : &lt;code&gt;color.diff.new&lt;/code&gt; )을 찾아 ANSI 색상 이스케이프 시퀀스로 표준 출력에 출력하십시오. &lt;code&gt;name&lt;/code&gt; 에 색상이 구성되지 않은 경우 선택적 &lt;code&gt;default&lt;/code&gt; 매개 변수가 대신 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="40d2e7dbd88f8b4a905f40b739ac46054d6c280f" translate="yes" xml:space="preserve">
          <source>Find the color setting for &lt;code&gt;name&lt;/code&gt; (e.g. &lt;code&gt;color.diff&lt;/code&gt;) and output &quot;true&quot; or &quot;false&quot;. &lt;code&gt;stdout-is-tty&lt;/code&gt; should be either &quot;true&quot; or &quot;false&quot;, and is taken into account when configuration says &quot;auto&quot;. If &lt;code&gt;stdout-is-tty&lt;/code&gt; is missing, then checks the standard output of the command itself, and exits with status 0 if color is to be used, or exits with status 1 otherwise. When the color setting for &lt;code&gt;name&lt;/code&gt; is undefined, the command uses &lt;code&gt;color.ui&lt;/code&gt; as fallback.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 의 색상 설정 (예 : &lt;code&gt;color.diff&lt;/code&gt; )을 찾고 &quot;true&quot;또는 &quot;false&quot;를 출력하십시오. &lt;code&gt;stdout-is-tty&lt;/code&gt; 는 &quot;true&quot;또는 &quot;false&quot;여야하며 구성에 &quot;auto&quot;가 표시 될 때 고려됩니다. 경우 &lt;code&gt;stdout-is-tty&lt;/code&gt; 누락 후 명령 자체의 표준 출력을 검사하고, 종료 상태 0 컬러가 사용될 경우, 또는 다른 상태 (1)과 종료. &lt;code&gt;name&lt;/code&gt; 의 색상 설정 이 정의되지 않은 경우 명령은 &lt;code&gt;color.ui&lt;/code&gt; 를 대체로 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="df59454620e80f086423090568733ac46b2847e0" translate="yes" xml:space="preserve">
          <source>Find the point at which a branch (or any history that leads to &amp;lt;commit&amp;gt;) forked from another branch (or any reference) &amp;lt;ref&amp;gt;. This does not just look for the common ancestor of the two commits, but also takes into account the reflog of &amp;lt;ref&amp;gt; to see if the history leading to &amp;lt;commit&amp;gt; forked from an earlier incarnation of the branch &amp;lt;ref&amp;gt; (see discussion on this mode below).</source>
          <target state="translated">다른 지점 (또는 참조) &amp;lt;ref&amp;gt;에서 지점 (또는 &amp;lt;commit&amp;gt;으로 이어지는 기록)이 분기 된 지점을 찾습니다. 이것은 두 커밋의 공통 조상을 찾는 것이 아니라 &amp;lt;ref&amp;gt;의 참조를 고려하여 &amp;lt;commit&amp;gt;으로 이어지는 역사가 &amp;lt;ref&amp;gt; 지점의 이전 화신에서 분기되었는지 확인합니다 ( 아래이 모드).</target>
        </trans-unit>
        <trans-unit id="9da189d134fc7190f0c6c1f5c3193ab5948bf13c" translate="yes" xml:space="preserve">
          <source>Finding commits referencing a file with given content</source>
          <target state="translated">주어진 내용으로 파일을 참조하는 커밋 찾기</target>
        </trans-unit>
        <trans-unit id="e333b71e49766be9f1d76f262411fa340daf0c70" translate="yes" xml:space="preserve">
          <source>Finding commits which commit messages matches given search term.</source>
          <target state="translated">주어진 검색어와 일치하는 커밋 메시지를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="1eaaf96aa600c577b3f3a9747228f1b65b0ceefc" translate="yes" xml:space="preserve">
          <source>Finding files</source>
          <target state="translated">파일 찾기</target>
        </trans-unit>
        <trans-unit id="2fc00785f4570abeeda498c54f0284462aed8b44" translate="yes" xml:space="preserve">
          <source>Finding performance regressions</source>
          <target state="translated">성능 회귀 찾기</target>
        </trans-unit>
        <trans-unit id="bc2b131e580f41edfbbcd8f6c9c60a09f1a25b76" translate="yes" xml:space="preserve">
          <source>Finds symbolic names suitable for human digestion for revisions given in any format parsable by &lt;code&gt;git rev-parse&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git rev-parse&lt;/code&gt; 가 구문 분석 할 수있는 형식으로 지정된 개정판에 대해 사람의 소화에 적합한 기호 이름을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="7d4b2472daa261c193507bf4d856ace529dabcc6" translate="yes" xml:space="preserve">
          <source>First let&amp;rsquo;s assume your &lt;code&gt;topic&lt;/code&gt; is based on branch &lt;code&gt;next&lt;/code&gt;. For example, a feature developed in &lt;code&gt;topic&lt;/code&gt; depends on some functionality which is found in &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">먼저 &lt;code&gt;topic&lt;/code&gt; &lt;code&gt;next&lt;/code&gt; 분기를 기반으로 한다고 가정 해 봅시다 . 예를 들어, &lt;code&gt;topic&lt;/code&gt; 에서 개발 된 기능은 &lt;code&gt;next&lt;/code&gt; 있는 일부 기능에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="ed8007e4d48fad1e0a696af768b6078f3fa95c0a" translate="yes" xml:space="preserve">
          <source>First let&amp;rsquo;s define &quot;best bisection point&quot;. We will say that a commit X is a best bisection point or a best bisection commit if knowing its state (&quot;good&quot; or &quot;bad&quot;) gives as much information as possible whether the state of the commit happens to be &quot;good&quot; or &quot;bad&quot;.</source>
          <target state="translated">먼저 &quot;최상의이 분점&quot;을 정의하겠습니다. 커밋 X가 커밋 상태가 &quot;good&quot;또는 &quot;bad&quot;인지 여부를 가능한 한 많은 정보를 제공하면 커밋 X가 최상의이 분점 또는 최상의 이분법 커밋이라고 말할 것입니다. 나쁜&quot;.</target>
        </trans-unit>
        <trans-unit id="ee7f8a8fdabeacb4105bb68c4dfba6a20cea041f" translate="yes" xml:space="preserve">
          <source>First merges by themselves can introduce some regressions even when the merge needs no source code conflict resolution. This is because a semantic change can happen in one branch while the other branch is not aware of it.</source>
          <target state="translated">첫 번째 병합 자체는 병합에 소스 코드 충돌 해결이 필요하지 않은 경우에도 약간의 회귀를 유발할 수 있습니다. 한 지점에서 의미 변경이 발생할 수 있지만 다른 지점은이를 인식하지 못하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="05a55fcafe087cbd44c02228e1ac75a34a01c1f1" translate="yes" xml:space="preserve">
          <source>First, build a history graph in the same way that &lt;code&gt;--full-history&lt;/code&gt; with parent rewriting does (see above).</source>
          <target state="translated">먼저 부모 재 작성이 있는 &lt;code&gt;--full-history&lt;/code&gt; 와 동일한 방식으로 기록 그래프를 작성하십시오 (위 참조).</target>
        </trans-unit>
        <trans-unit id="08310df25f406cc10b8d6127f9ec844567b780fb" translate="yes" xml:space="preserve">
          <source>First, if you wish to continue to release maintenance fixes for the feature release made before the recent one, then you must create another branch to track commits for that previous release.</source>
          <target state="translated">먼저, 최신 기능 릴리스 이전에 작성된 기능 릴리스에 대한 유지 보수 수정 사항을 계속 릴리스하려면 이전 릴리스의 커미트를 추적하기 위해 다른 브랜치를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="3f7b81f4c441b31ef96f877571ae9e6d0b762fd6" translate="yes" xml:space="preserve">
          <source>First, in .gitattributes, you would assign the &lt;code&gt;diff&lt;/code&gt; attribute for paths.</source>
          <target state="translated">먼저 .gitattributes에서 경로에 &lt;code&gt;diff&lt;/code&gt; 속성을 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="b3f5f5cacf6c72eb426cf54eb30cee145c3bf1f2" translate="yes" xml:space="preserve">
          <source>First, install version 2.1 or higher of cvsps from &lt;a href=&quot;https://github.com/andreyvit/cvsps&quot;&gt;https://github.com/andreyvit/cvsps&lt;/a&gt; and make sure it is in your path. Then cd to a checked out CVS working directory of the project you are interested in and run &lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport[1]&lt;/a&gt;:</source>
          <target state="translated">먼저 &lt;a href=&quot;https://github.com/andreyvit/cvsps&quot;&gt;https://github.com/andreyvit/cvsps&lt;/a&gt; 에서 cvsp 버전 2.1 이상을 설치 하고 경로에 있는지 확인하십시오. 그런 다음 관심있는 프로젝트의 체크 아웃 된 CVS 작업 디렉토리로 cd하고 &lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport [1]을 실행하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="576e890855dbcdc8bc3ac7fde0afbe81b0fdd016" translate="yes" xml:space="preserve">
          <source>First, note that you can get documentation for a command such as &lt;code&gt;git log --graph&lt;/code&gt; with:</source>
          <target state="translated">먼저 &lt;code&gt;git log --graph&lt;/code&gt; 와 같은 명령에 대한 문서를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a679f4d1f2379fb3e8b418dd1cdea69390f805f" translate="yes" xml:space="preserve">
          <source>First, reset the history back one commit so that we remove the original commit, but leave the working tree with all the changes. The -N ensures that any new files added with &lt;code&gt;HEAD&lt;/code&gt; are still marked so that &lt;code&gt;git add -p&lt;/code&gt; will find them.</source>
          <target state="translated">먼저 원래 커밋을 제거하기 위해 기록을 한 커밋으로 다시 설정하지만 작업 트리에는 모든 변경 사항이 남아 있습니다. -N은 &lt;code&gt;HEAD&lt;/code&gt; 로 추가 된 새 파일 이 여전히 표시되도록하여 &lt;code&gt;git add -p&lt;/code&gt; 가 해당 파일 을 찾을 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="eac258ebc7c4ff84505375d195a1e24d04961706" translate="yes" xml:space="preserve">
          <source>First, use &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;; for example:</source>
          <target state="translated">먼저 &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]을 사용하십시오&lt;/a&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af62e3f15d84326a813952b253791dac4ec57aaa" translate="yes" xml:space="preserve">
          <source>First, you need to create an empty repository on the remote machine that will house your public repository. This empty repository will be populated and be kept up to date by pushing into it later. Obviously, this repository creation needs to be done only once.</source>
          <target state="translated">먼저 원격 저장소에서 공용 저장소를 보관할 빈 저장소를 작성해야합니다. 이 빈 저장소는 나중에 채워져 채워지고 최신 상태로 유지됩니다. 분명히이 저장소 작성은 한 번만 수행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="52835c0708aa62a7396cacc7dfc2df24ce8a002c" translate="yes" xml:space="preserve">
          <source>Fix a &quot;thin&quot; pack produced by &lt;code&gt;git pack-objects --thin&lt;/code&gt; (see &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; for details) by adding the excluded objects the deltified objects are based on to the pack. This option only makes sense in conjunction with --stdin.</source>
          <target state="translated">deltified 객체가 기반으로하는 제외 된 객체를 팩에 추가하여 &lt;code&gt;git pack-objects --thin&lt;/code&gt; 생성 한 &quot;thin&quot;팩을 수정합니다 ( 세부 사항 은 &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt; 참조). 이 옵션은 --stdin과 함께 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6bef9039e49cd5a1bb992311087de16992b814ac" translate="yes" xml:space="preserve">
          <source>Fix the ignore-paths or SVN permissions problem that caused &quot;r2&quot; to be incomplete in the first place. Then:</source>
          <target state="translated">&quot;r2&quot;가 처음에 불완전하게했던 ignore-paths 또는 SVN 권한 문제를 수정하십시오. 그때:</target>
        </trans-unit>
        <trans-unit id="bf5e51b162922584144bf607debb47b58ed7a8df" translate="yes" xml:space="preserve">
          <source>Fixing a mistake by rewriting history</source>
          <target state="translated">기록을 다시 작성하여 실수 수정</target>
        </trans-unit>
        <trans-unit id="afb2d222f3591d3622f9d0c44f698fe7e6dc0a83" translate="yes" xml:space="preserve">
          <source>Fixing a mistake with a new commit</source>
          <target state="translated">새로운 커밋으로 실수 수정</target>
        </trans-unit>
        <trans-unit id="c169f9b52cd517560d8a456346335c3aedbfac2b" translate="yes" xml:space="preserve">
          <source>Fixing mistakes</source>
          <target state="translated">실수 수정</target>
        </trans-unit>
        <trans-unit id="de18d069db0d9d56daecfccdb3a27275518bc1f7" translate="yes" xml:space="preserve">
          <source>Flags and parameters to be parsed.</source>
          <target state="translated">구문 분석 할 플래그 및 매개 변수</target>
        </trans-unit>
        <trans-unit id="8a2fcacfdef0a8b1fd083381230b0ac0cbbdea61" translate="yes" xml:space="preserve">
          <source>Follow merge ancestry and attempt to import trees that have been merged from. Specify a depth greater than 1 if patch logs have been pruned.</source>
          <target state="translated">병합 조상에 따라 병합 된 트리를 가져 오십시오. 패치 로그가 제거 된 경우 1보다 큰 깊이를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="f48973c6479f97ed9cbdd1aa747abb3d724dfc88" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit. This is useful when you wish to not match tags on branches merged in the history of the target commit.</source>
          <target state="translated">병합 커밋을 볼 때 첫 번째 부모 커밋 만 따르십시오. 대상 커밋 기록에 병합 된 분기의 태그를 일치시키지 않으려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d67b9781a4352de8f66549a8b248fd66aceb7858" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit. This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge. Cannot be combined with --bisect.</source>
          <target state="translated">병합 커밋을 볼 때 첫 번째 부모 커밋 만 따르십시오. 이 옵션은 특정 토픽 브랜치의 진화를 볼 때 더 나은 개요를 제공 할 수 있습니다. 토픽 브랜치로의 병합은 때때로 업스트림으로 업데이트되도록 조정하는 경향이 있기 때문에이 옵션을 사용하면 개별 커밋을 무시할 수 있습니다. 그러한 합병으로 당신의 역사. --bisect와 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b82a1274463e2bfba901905e39b02d331c44520" translate="yes" xml:space="preserve">
          <source>Following general best practices</source>
          <target state="translated">일반적인 모범 사례 준수</target>
        </trans-unit>
        <trans-unit id="788b60e8a3fa302c96ca5000ec7c36053afb1c38" translate="yes" xml:space="preserve">
          <source>Following the headers, a series of lines are printed for tracked entries. One of three different line formats may be used to describe an entry depending on the type of change. Tracked entries are printed in an undefined order; parsers should allow for a mixture of the 3 line types in any order.</source>
          <target state="translated">헤더 다음에 항목을 추적하기 위해 일련의 행이 인쇄됩니다. 변경 유형에 따라 3 가지 다른 라인 형식 중 하나를 사용하여 항목을 설명 할 수 있습니다. 추적 된 항목은 정의되지 않은 순서로 인쇄됩니다. 파서는 임의의 순서로 3 가지 라인 유형의 혼합을 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0af351e25b3235e5cb0b144d879a5948cd0b6627" translate="yes" xml:space="preserve">
          <source>Following the tracked entries (and if requested), a series of lines will be printed for untracked and then ignored items found in the worktree.</source>
          <target state="translated">추적 된 항목 (및 요청 된 경우)에 따라 추적되지 않은 작업에 대해 일련의 행이 인쇄 된 다음 작업 트리에서 찾은 항목이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="18388d4087a6542b5572bea29a06b35e2aae5326" translate="yes" xml:space="preserve">
          <source>Following these N lines, one-line log for each commit is displayed, indented N places. If a commit is on the I-th branch, the I-th indentation character shows a &lt;code&gt;+&lt;/code&gt; sign; otherwise it shows a space. Merge commits are denoted by a &lt;code&gt;-&lt;/code&gt; sign. Each commit shows a short name that can be used as an extended SHA-1 to name that commit.</source>
          <target state="translated">이 N 행 다음에는 각 커밋에 대한 한 줄 로그가 N 자리만큼 들여 쓰기되어 표시됩니다. 커밋이 I 번째 분기에있는 경우 I 번째 들여 쓰기 문자는 &lt;code&gt;+&lt;/code&gt; 부호를 표시합니다. 그렇지 않으면 공백이 표시됩니다. 병합 커밋은 &lt;code&gt;-&lt;/code&gt; 기호 로 표시됩니다 . 각 커밋에는 해당 커밋의 이름을 지정하기 위해 확장 SHA-1로 사용할 수있는 짧은 이름이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="348633bb6883a2c8b3944ebb9c0c3986369c6bb3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;--cc&lt;/code&gt;, only the destination or final path is shown even if the file was renamed on any side of history. With &lt;code&gt;--combined-all-paths&lt;/code&gt;, the name of the path in each parent is shown followed by the name of the path in the merge commit.</source>
          <target state="translated">들면 &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;--cc&lt;/code&gt; 파일이 과거에 어느 쪽 개명되었다하더라도, 단지 최종 도착 경로가 도시되어있다. 함께 &lt;code&gt;--combined-all-paths&lt;/code&gt; , 각 상위의 경로 이름은 병합을 저지에서 경로 이름 앞에 도시된다.</target>
        </trans-unit>
        <trans-unit id="299f58cbaec7164b54b0f4129532e8b5c1642be3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;tag&lt;/code&gt;, display the urls that will be used for copying when creating the branch or tag.</source>
          <target state="translated">들어 &lt;code&gt;branch&lt;/code&gt; 와 &lt;code&gt;tag&lt;/code&gt; , 분기 또는 태그를 생성 할 때 복사하는 데 사용되는 URL을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="007222e8d7dfa1e11f08c139bdea5864653b03fb" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;dcommit&lt;/code&gt;, print out the series of Git arguments that would show which diffs would be committed to SVN.</source>
          <target state="translated">들어 &lt;code&gt;dcommit&lt;/code&gt; , 차이점은 SVN하기 위해 최선을 다하고 될 것이다 보여줄 것이다 망할 놈의 인수의 시리즈를 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7661574c1331f1ffadb88e65b09fb7bbb3d5b369" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;rebase&lt;/code&gt;, display the local branch associated with the upstream svn repository associated with the current branch and the URL of svn repository that will be fetched from.</source>
          <target state="translated">들어 &lt;code&gt;rebase&lt;/code&gt; , 현재의 지점과에서 가져온 것입니다 SVN 저장소의 URL과 관련된 업스트림 SVN 저장소와 관련된 현지 지점을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="8054fb75013a9d33733a54185710f048c11e6754" translate="yes" xml:space="preserve">
          <source>For Git developers, &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt; goes into detail on the lower-level Git mechanisms involved in, for example, creating a new commit.</source>
          <target state="translated">Git 개발자에게 &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial [7]&lt;/a&gt; 은 새로운 커밋 생성과 같은 하위 레벨 Git 메커니즘에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9c7a8b6d1a7a0700f3cd22ce6172861bfe044c11" translate="yes" xml:space="preserve">
          <source>For SSH clients that will make commits, make sure their server-side .ssh/environment files (or .bashrc, etc., according to their specific shell) export appropriate values for GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_COMMITTER_NAME, and GIT_COMMITTER_EMAIL. For SSH clients whose login shell is bash, .bashrc may be a reasonable alternative.</source>
          <target state="translated">커밋 할 SSH 클라이언트의 경우 서버 측 .ssh / environment 파일 (또는 특정 쉘에 따라 .bashrc 등)이 GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_COMMITTER_NAME 및 GIT_COMMITTER_EMAIL에 적절한 값을 내보내도록하십시오. 로그인 쉘이 bash 인 SSH 클라이언트의 경우 .bashrc가 적합한 대안 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e127a96a43fc87667b0c86a8698d094b3fabedbe" translate="yes" xml:space="preserve">
          <source>For URLs in &lt;code&gt;https://weak.example.com&lt;/code&gt;, &lt;code&gt;http.sslVerify&lt;/code&gt; is set to false, while it is set to &lt;code&gt;true&lt;/code&gt; for all others:</source>
          <target state="translated">&lt;code&gt;https://weak.example.com&lt;/code&gt; 의 URL의 경우 &lt;code&gt;http.sslVerify&lt;/code&gt; 는 false로 설정되고 다른 모든 URL은 &lt;code&gt;true&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="51c95f036bd90f837a4d78c935d1c885601df8ec" translate="yes" xml:space="preserve">
          <source>For a custom merge command, specify whether the exit code of the merge command can be used to determine whether the merge was successful. If this is not set to true then the merge target file timestamp is checked and the merge assumed to have been successful if the file has been updated, otherwise the user is prompted to indicate the success of the merge.</source>
          <target state="translated">사용자 정의 병합 명령의 경우, 병합 명령의 종료 코드를 사용하여 병합의 성공 여부를 판별하십시오. 이것이 true로 설정되지 않으면 병합 대상 파일 타임 스탬프가 검사되고 파일이 업데이트 된 경우 병합이 성공한 것으로 가정하고, 그렇지 않으면 사용자에게 병합 성공을 표시하라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="832a920de5e5a1607e20fda89c6b16105d6a3d66" translate="yes" xml:space="preserve">
          <source>For a description of which objects are considered for pruning, see &lt;code&gt;git fsck&lt;/code&gt;'s --unreachable option.</source>
          <target state="translated">잘라내 기로 간주되는 객체에 대한 설명은 &lt;code&gt;git fsck&lt;/code&gt; 의 --unreachable 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7772aa877c345ccdb695091fd19f024126a4a0b8" translate="yes" xml:space="preserve">
          <source>For a detailed description of &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; see above under &lt;code&gt;from&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 에 대한 자세한 설명은 &lt;code&gt;from&lt;/code&gt; 아래 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="97b7c41fd980027cd240574fa45f8b9cf3a30c50" translate="yes" xml:space="preserve">
          <source>For a detailed description of &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; see above under &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;from&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 에 대한 자세한 설명 은 위의 &lt;code&gt;commit&lt;/code&gt; 및 &lt;code&gt;from&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4f4b9fba6569cfb2eebe32e9b505f5e163da8ae" translate="yes" xml:space="preserve">
          <source>For a failed update, more details are given:</source>
          <target state="translated">실패한 업데이트에 대한 자세한 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="243468740a36ab67df241df82903537b2a102239" translate="yes" xml:space="preserve">
          <source>For a more complete list of ways to spell &amp;lt;commit&amp;gt;, see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;. However, &quot;diff&quot; is about comparing two &lt;code&gt;endpoints&lt;/code&gt;, not ranges, and the range notations (&quot;&amp;lt;commit&amp;gt;..&amp;lt;commit&amp;gt;&quot; and &quot;&amp;lt;commit&amp;gt;...&amp;lt;commit&amp;gt;&quot;) do not mean a range as defined in the &quot;SPECIFYING RANGES&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">&amp;lt;commit&amp;gt;을 철자하는 방법에 대한 전체 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]의&lt;/a&gt; &quot; SPECIFYING REVISIONS&quot;섹션을 참조하십시오 . 그러나 &quot;diff&quot;는 범위가 아닌 두 &lt;code&gt;endpoints&lt;/code&gt; 비교 하는 것이며 범위 표기법 ( &quot;&amp;lt;commit&amp;gt; .. &amp;lt;commit&amp;gt;&quot;및 &quot;&amp;lt;commit&amp;gt; ... &amp;lt;commit&amp;gt;&quot;)은 정의 된 범위를 의미하지 않습니다. &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions의&lt;/a&gt; &quot; SPECIFYING RANGES &quot;섹션 [7] .</target>
        </trans-unit>
        <trans-unit id="aef391cab8f8e654bd28a4ebab3ff359b2dd758d" translate="yes" xml:space="preserve">
          <source>For a more complete list of ways to spell object names, see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">객체 이름을 철자하는 방법에 대한 전체 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]의&lt;/a&gt; &quot; SPECIFYING REVISIONS&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ffb03e9988d5aab6ca13a5c4410e25c3bc4d2c1f" translate="yes" xml:space="preserve">
          <source>For a more detailed discussion of the procedure and additional tips, see the &quot;INTERACTIVE MODE&quot; section of &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">절차 및 추가 팁에 대한 자세한 내용은 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; 의 &quot;대화식 모드&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="21840545ec0ef1fb11dadc3e0bd425ddda71d447" translate="yes" xml:space="preserve">
          <source>For a path that is unmerged, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 1 parameter, &amp;lt;path&amp;gt;.</source>
          <target state="translated">병합되지 않은 경로의 경우 1 개의 매개 변수 &amp;lt;path&amp;gt;와 함께 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bf84b30d98b0b2aee4084cebd6a510d7735317e2" translate="yes" xml:space="preserve">
          <source>For a regular file &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;echo HEAD:f | git cat-file --batch&lt;/code&gt; would print</source>
          <target state="translated">일반 파일 &lt;code&gt;f&lt;/code&gt; 의 경우 &lt;code&gt;echo HEAD:f | git cat-file --batch&lt;/code&gt; 인쇄</target>
        </trans-unit>
        <trans-unit id="3d0f9234523f6052cd5829e5dd1cdac95a9b09fd" translate="yes" xml:space="preserve">
          <source>For a simple local test, you can use &lt;a href=&quot;git-remote-ext&quot;&gt;git-remote-ext[1]&lt;/a&gt;:</source>
          <target state="translated">간단한 로컬 테스트를 위해 &lt;a href=&quot;git-remote-ext&quot;&gt;git-remote-ext [1]을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="428bfb3c06af83865df8238da30e9618f9cb0a09" translate="yes" xml:space="preserve">
          <source>For a successfully fetched ref, the summary shows the old and new values of the ref in a form suitable for using as an argument to &lt;code&gt;git log&lt;/code&gt; (this is &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; in most cases, and &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; for forced non-fast-forward updates).</source>
          <target state="translated">성공적으로 가져온 참조의 경우 요약은 참조의 이전 값과 새 값을 &lt;code&gt;git log&lt;/code&gt; 의 인수로 사용하기에 적합한 형식으로 표시합니다 ( 대부분의 경우 &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; 비 신속 강제 업데이트의 경우 &amp;lt;신규&amp;gt; ).</target>
        </trans-unit>
        <trans-unit id="95550d69988e7a758b9c94b13942bde9ad57e2ef" translate="yes" xml:space="preserve">
          <source>For a successfully pushed ref, the summary shows the old and new values of the ref in a form suitable for using as an argument to &lt;code&gt;git log&lt;/code&gt; (this is &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; in most cases, and &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; for forced non-fast-forward updates).</source>
          <target state="translated">성공적으로 푸시 된 참조의 경우, 요약은 참조의 이전 값과 새 값을 &lt;code&gt;git log&lt;/code&gt; 의 인수로 사용하기에 적합한 형식으로 표시합니다 ( 대부분의 경우 &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; 비 신속 강제 업데이트의 경우 &amp;lt;신규&amp;gt; ).</target>
        </trans-unit>
        <trans-unit id="d2bfe73291a6ef412f90bf2eac1210664a9553b3" translate="yes" xml:space="preserve">
          <source>For all objects, the following names can be used:</source>
          <target state="translated">모든 객체에 대해 다음 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96992b112d12dd337ecf884c867dcddc44e026cf" translate="yes" xml:space="preserve">
          <source>For all options that output values and/or keys, always end values with the null character (instead of a newline). Use newline instead as a delimiter between key and value. This allows for secure parsing of the output without getting confused e.g. by values that contain line breaks.</source>
          <target state="translated">값 및 / 또는 키를 출력하는 모든 옵션의 경우 항상 줄 바꿈 대신 널 문자로 값을 종료하십시오. 키와 값 사이의 구분자로 줄 바꿈을 대신 사용하십시오. 따라서 줄 바꿈이 포함 된 값과 혼동되지 않고 출력을 안전하게 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ac2c111de5df363fa2f5b2b630af5f75a90bcb1" translate="yes" xml:space="preserve">
          <source>For an unmerged path, instead of recording a single mode/SHA-1 pair, the index records up to three such pairs; one from tree O in stage 1, A in stage 2, and B in stage 3. This information can be used by the user (or the porcelain) to see what should eventually be recorded at the path. (see &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt; for more information on state)</source>
          <target state="translated">병합되지 않은 경로의 경우 단일 모드 / SHA-1 쌍을 기록하는 대신 인덱스는 최대 3 개의 이러한 쌍을 기록합니다. 1 단계의 트리 O, 2 단계의 A, 3 단계의 B 중 하나입니다.이 정보는 사용자 (또는 도자기)가 경로에 무엇을 기록해야하는지 알 수 있습니다. ( 상태에 대한 자세한 내용 은 &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]&lt;/a&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="43b2d74a2014d25aa6c53b32650e8baad61de67e" translate="yes" xml:space="preserve">
          <source>For any commit graph, you can see the number associated with each commit using &quot;git rev-list --bisect-all&quot;.</source>
          <target state="translated">커밋 그래프는 &quot;git rev-list --bisect-all&quot;을 사용하여 각 커밋과 관련된 번호를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="672441c22b399b226ed91a2cbed5740025f9d076" translate="yes" xml:space="preserve">
          <source>For any remote-tracking branch &lt;code&gt;%(upstream)&lt;/code&gt;, &lt;code&gt;%(upstream:remotename)&lt;/code&gt; and &lt;code&gt;%(upstream:remoteref)&lt;/code&gt; refer to the name of the remote and the name of the tracked remote ref, respectively. In other words, the remote-tracking branch can be updated explicitly and individually by using the refspec &lt;code&gt;%(upstream:remoteref):%(upstream)&lt;/code&gt; to fetch from &lt;code&gt;%(upstream:remotename)&lt;/code&gt;.</source>
          <target state="translated">원격 추적 브랜치 &lt;code&gt;%(upstream)&lt;/code&gt; , &lt;code&gt;%(upstream:remotename)&lt;/code&gt; 및 &lt;code&gt;%(upstream:remoteref)&lt;/code&gt; 는 각각 원격의 이름과 추적 된 원격 참조의 이름을 나타냅니다. 즉, refspec &lt;code&gt;%(upstream:remoteref):%(upstream)&lt;/code&gt; 을 사용하여 &lt;code&gt;%(upstream:remotename)&lt;/code&gt; 에서 가져 오면 원격 추적 분기를 명시적이고 개별적으로 업데이트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="242026e8d7d0593118b4fae738fc0c3f1a90be23" translate="yes" xml:space="preserve">
          <source>For atomicity, &lt;code&gt;git apply&lt;/code&gt; by default fails the whole patch and does not touch the working tree when some of the hunks do not apply. This option makes it apply the parts of the patch that are applicable, and leave the rejected hunks in corresponding *.rej files.</source>
          <target state="translated">원자 성의 경우 기본적으로 &lt;code&gt;git apply&lt;/code&gt; 는 전체 패치에 실패하고 일부 덩어리가 적용되지 않으면 작업 트리를 건드리지 않습니다. 이 옵션을 사용하면 적용 가능한 패치 부분을 적용하고 거부 된 덩어리를 해당 * .rej 파일에 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="8d098e130baba0ccc99da718229f5fc6bc213a77" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, the &lt;code&gt;crlf&lt;/code&gt; attribute is interpreted as follows:</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;code&gt;crlf&lt;/code&gt; 속성은 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="816a47e0ab5f0e7c8c410570167eb66d775695ae" translate="yes" xml:space="preserve">
          <source>For best consistency with &lt;code&gt;cvs&lt;/code&gt;, it is probably best to override the defaults by setting &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; to true, and &lt;code&gt;gitcvs.allBinary&lt;/code&gt; to &quot;guess&quot;.</source>
          <target state="translated">&lt;code&gt;cvs&lt;/code&gt; 와의 일관성을 유지 하려면 &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; 을 true 로 설정 하고 &lt;code&gt;gitcvs.allBinary&lt;/code&gt; 를 &quot;guess&quot; 로 설정하여 기본값을 재정의하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="bad93aa83b2df49f46d609a291da6014ee26a719" translate="yes" xml:space="preserve">
          <source>For best results, &lt;code&gt;clean&lt;/code&gt; should not alter its output further if it is run twice (&quot;clean&amp;rarr;clean&quot; should be equivalent to &quot;clean&quot;), and multiple &lt;code&gt;smudge&lt;/code&gt; commands should not alter &lt;code&gt;clean&lt;/code&gt;'s output (&quot;smudge&amp;rarr;smudge&amp;rarr;clean&quot; should be equivalent to &quot;clean&quot;). See the section on merging below.</source>
          <target state="translated">최상의 결과를 얻으려면 &lt;code&gt;clean&lt;/code&gt; 가 두 번 실행되는 추가하면 출력을 변경해서는 안 ( &quot;청소 &amp;rarr; 청소&quot; &quot;깨끗한&quot;에 해당되어야한다), 여러 &lt;code&gt;smudge&lt;/code&gt; 명령해야 변경하지 &lt;code&gt;clean&lt;/code&gt; (의 출력 &quot;얼룩 &amp;rarr; 얼룩 &amp;rarr; 깨끗한&quot; &quot;clean&quot;과 동일해야합니다.) 아래의 병합 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8d3928084bacb031775f5d7bad0ceaa321b4778c" translate="yes" xml:space="preserve">
          <source>For blobs and trees, you can&amp;rsquo;t do the same, but you can still examine them. You can just do</source>
          <target state="translated">얼룩과 나무의 경우 동일한 작업을 수행 할 수 없지만 여전히 검사 할 수 있습니다. 당신은 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d0eec01499f14d036682e7faa93df840595c4ccf" translate="yes" xml:space="preserve">
          <source>For commit and tag objects, the special &lt;code&gt;creatordate&lt;/code&gt; and &lt;code&gt;creator&lt;/code&gt; fields will correspond to the appropriate date or name-email-date tuple from the &lt;code&gt;committer&lt;/code&gt; or &lt;code&gt;tagger&lt;/code&gt; fields depending on the object type. These are intended for working on a mix of annotated and lightweight tags.</source>
          <target state="translated">커밋 태그 객체의 경우, 특별한 &lt;code&gt;creatordate&lt;/code&gt; 및 &lt;code&gt;creator&lt;/code&gt; 필드는에서 해당 날짜 나 이름 - 이메일 - 날짜 튜플에 해당됩니다 &lt;code&gt;committer&lt;/code&gt; 또는 &lt;code&gt;tagger&lt;/code&gt; 오브젝트 유형에 따라 필드. 이들은 주석이 달린 태그와 가벼운 태그를 혼합하여 작업하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f1ce66454707d43159aa08f01addd1a2cbbd5b3f" translate="yes" xml:space="preserve">
          <source>For commits it shows the log message and textual diff. It also presents the merge commit in a special format as produced by &lt;code&gt;git diff-tree --cc&lt;/code&gt;.</source>
          <target state="translated">커밋의 경우 로그 메시지와 텍스트 차이를 보여줍니다. 또한 &lt;code&gt;git diff-tree --cc&lt;/code&gt; 에 의해 생성 된 병합 커밋을 특별한 형식으로 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="5788d84088826961fe0565ab052c9c41c47117d5" translate="yes" xml:space="preserve">
          <source>For commits, you can just use:</source>
          <target state="translated">커밋의 경우 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="600c796c6fdee3517d0340d7c98d0e629e148085" translate="yes" xml:space="preserve">
          <source>For conflicting paths, the index file records up to three versions, as described in the &quot;TRUE MERGE&quot; section of &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;. The working tree files will include a description of the conflict bracketed by the usual conflict markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">충돌하는 경로의 경우 인덱스 파일은 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt; 의 &quot;TRUE MERGE&quot;섹션에 설명 된대로 최대 3 개의 버전을 기록합니다 . 작업 트리 파일에는 일반적인 충돌 마커 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 로 묶인 충돌에 대한 설명이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="35aa73e9eb71becc5a3756c0cf556cc7d0b77d41" translate="yes" xml:space="preserve">
          <source>For conflicting paths, the index file records up to three versions: stage 1 stores the version from the common ancestor, stage 2 from &lt;code&gt;HEAD&lt;/code&gt;, and stage 3 from &lt;code&gt;MERGE_HEAD&lt;/code&gt; (you can inspect the stages with &lt;code&gt;git ls-files -u&lt;/code&gt;). The working tree files contain the result of the &quot;merge&quot; program; i.e. 3-way merge results with familiar conflict markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;===&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">충돌하는 경로의 경우 색인 파일은 최대 3 개의 버전을 기록합니다. 1 단계는 공통 조상의 버전, &lt;code&gt;HEAD&lt;/code&gt; 의 2 단계 및 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 의 3 단계를 저장합니다 ( &lt;code&gt;git ls-files -u&lt;/code&gt; 로 스테이지를 검사 할 수 있음 ). 작업 트리 파일에는 &quot;병합&quot;프로그램의 결과가 포함됩니다. 즉, 익숙한 충돌 마커 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;===&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 을 사용한 3 방향 병합 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="7a860b5275da5a9c9fab93cf772cd75bc2e0f4eb" translate="yes" xml:space="preserve">
          <source>For consistency, we also try such a trick if &lt;code&gt;man.konqueror.path&lt;/code&gt; is set to something like &lt;code&gt;A_PATH_TO/konqueror&lt;/code&gt;. That means we will try to launch &lt;code&gt;A_PATH_TO/kfmclient&lt;/code&gt; instead.</source>
          <target state="translated">일관성을 유지 하기 위해 &lt;code&gt;man.konqueror.path&lt;/code&gt; 가 &lt;code&gt;A_PATH_TO/konqueror&lt;/code&gt; 와 같은 것으로 설정되어 있으면 그러한 트릭을 시도 합니다. 즉, &lt;code&gt;A_PATH_TO/kfmclient&lt;/code&gt; 를 대신 시작하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="303c07dbeb4d9b201e995967f10cae861d7b985d" translate="yes" xml:space="preserve">
          <source>For convenience, this data is saved to &lt;code&gt;$GIT_DIR/cvs-authors&lt;/code&gt; each time the &lt;code&gt;-A&lt;/code&gt; option is provided and read from that same file each time &lt;code&gt;git cvsimport&lt;/code&gt; is run.</source>
          <target state="translated">편의상이 데이터는 &lt;code&gt;-A&lt;/code&gt; 옵션이 제공 될 때마다 &lt;code&gt;$GIT_DIR/cvs-authors&lt;/code&gt; 저장되고 &lt;code&gt;git cvsimport&lt;/code&gt; 가 실행될 때마다 동일한 파일에서 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="bc9270ed7ea5a3e841c3245ec308c8ddd86f1b91" translate="yes" xml:space="preserve">
          <source>For credential lookups, the files are read in the order given above, with the first matching credential found taking precedence over credentials found in files further down the list.</source>
          <target state="translated">자격 증명 조회의 경우 파일은 위에서 주어진 순서대로 읽히고 일치하는 첫 번째 자격 증명이 목록에서 더 아래에있는 파일에서 찾은 자격 증명보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="78e4826a9de5d7b3349b3c973d4bc09ea13a37ed" translate="yes" xml:space="preserve">
          <source>For each &amp;ldquo;Name &amp;lt;user@host&amp;gt;&amp;rdquo; or &amp;ldquo;&amp;lt;user@host&amp;gt;&amp;rdquo; from the command-line or standard input (when using &lt;code&gt;--stdin&lt;/code&gt;), look up the person&amp;rsquo;s canonical name and email address (see &quot;Mapping Authors&quot; below). If found, print them; otherwise print the input as-is.</source>
          <target state="translated">명령 줄 또는 표준 입력 ( &lt;code&gt;--stdin&lt;/code&gt; 사용시 )의 각&amp;ldquo;이름 &amp;lt;user @ host&amp;gt;&amp;rdquo;또는&amp;ldquo;&amp;lt;user @ host&amp;gt;&amp;rdquo;에 대해 개인의 정식 이름과 전자 메일 주소를 찾으십시오 (아래 &quot;작성자 매핑&quot;참조). ). 발견되면 인쇄하십시오. 그렇지 않으면 입력을 그대로 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="317daaebd1883bdffebfa8e7b1777b5a4f83c1ca" translate="yes" xml:space="preserve">
          <source>For each &amp;lt;pathspec&amp;gt; given on command line, descend at most &amp;lt;depth&amp;gt; levels of directories. A value of -1 means no limit. This option is ignored if &amp;lt;pathspec&amp;gt; contains active wildcards. In other words if &quot;a*&quot; matches a directory named &quot;a*&quot;, &quot;*&quot; is matched literally so --max-depth is still effective.</source>
          <target state="translated">명령 행에 제공된 각 &amp;lt;pathspec&amp;gt;에 대해 최대 &amp;lt;depth&amp;gt; 레벨의 디렉토리까지 내립니다. 값이 -1이면 제한이 없음을 의미합니다. &amp;lt;pathspec&amp;gt;에 활성 와일드 카드가 포함되어 있으면이 옵션이 무시됩니다. 즉, &quot;a *&quot;가 &quot;a *&quot;라는 디렉토리와 일치하는 경우 &quot;*&quot;는 문자 그대로 일치하므로 --max-depth는 여전히 유효합니다.</target>
        </trans-unit>
        <trans-unit id="6cf7cc0cba8ed8b7ebafa73d62528bdea5d7f903" translate="yes" xml:space="preserve">
          <source>For each commit a separate file is created in the current directory.</source>
          <target state="translated">각 커밋마다 현재 디렉토리에 별도의 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6e5eb78674e89f34ddd48ded79bd04ac86b27923" translate="yes" xml:space="preserve">
          <source>For each commit, show a summary of changes using the raw diff format. See the &quot;RAW OUTPUT FORMAT&quot; section of &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. This is different from showing the log itself in raw format, which you can achieve with &lt;code&gt;--format=raw&lt;/code&gt;.</source>
          <target state="translated">각 커밋마다 원시 diff 형식을 사용하여 변경 사항 요약을 표시하십시오. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 의 &quot;RAW OUTPUT FORMAT&quot;섹션을 참조하십시오 . 이것은 &lt;code&gt;--format=raw&lt;/code&gt; 로 달성 할 수있는 원시 형식으로 로그 자체를 표시하는 것과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="334d2ef126bc398bc9fdce4f33bf828f0bbaab0d" translate="yes" xml:space="preserve">
          <source>For each commit-ish supplied, &lt;code&gt;git describe&lt;/code&gt; will first look for a tag which tags exactly that commit. Annotated tags will always be preferred over lightweight tags, and tags with newer dates will always be preferred over tags with older dates. If an exact match is found, its name will be output and searching will stop.</source>
          <target state="translated">제공된 커밋 -ish마다 &lt;code&gt;git describe&lt;/code&gt; 는 먼저 해당 커밋에 태그를 지정하는 태그를 찾습니다. 주석이 달린 태그는 항상 경량 태그보다 선호되며, 최신 날짜가있는 태그는 항상 오래된 날짜가있는 태그보다 선호됩니다. 정확히 일치하면 이름이 출력되고 검색이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="499cd7809be15aac9ff7cdcafa51d0930d0f78d9" translate="yes" xml:space="preserve">
          <source>For each contact, a single line is output, terminated by a newline. If the name is provided or known to the &lt;code&gt;mailmap&lt;/code&gt;, &amp;ldquo;Name &amp;lt;user@host&amp;gt;&amp;rdquo; is printed; otherwise only &amp;ldquo;&amp;lt;user@host&amp;gt;&amp;rdquo; is printed.</source>
          <target state="translated">각 접점에 대해 단일 라인이 출력되고 줄 바꿈으로 종료됩니다. 이름이 &lt;code&gt;mailmap&lt;/code&gt; 에 제공되거나 알려진 경우&amp;ldquo;Name &amp;lt;user @ host&amp;gt;&amp;rdquo;가 인쇄됩니다. 그렇지 않으면&amp;ldquo;&amp;lt;user @ host&amp;gt;&amp;rdquo;만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="0e11740c89977d85e4dd98daa923a91e3f5130da" translate="yes" xml:space="preserve">
          <source>For each patch the code attempts to extract the author from the patch description. If that fails it falls back to the author specified with --author. If the --author flag was not given the patch description is displayed and the user is asked to interactively enter the author of the patch.</source>
          <target state="translated">각 패치에 대해 코드는 패치 설명에서 작성자를 추출하려고 시도합니다. 실패하면 --author로 지정된 작성자에게 폴백합니다. --author 플래그가 제공되지 않은 경우 패치 설명이 표시되고 사용자에게 대화 형으로 패치 작성자를 입력하라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5681283d451e4fc4fc0ca3089786f576c8a1186d" translate="yes" xml:space="preserve">
          <source>For each path &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called, two environment variables, &lt;code&gt;GIT_DIFF_PATH_COUNTER&lt;/code&gt; and &lt;code&gt;GIT_DIFF_PATH_TOTAL&lt;/code&gt; are set.</source>
          <target state="translated">&lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 가 호출되는 각 경로에 대해 두 가지 환경 변수 &lt;code&gt;GIT_DIFF_PATH_COUNTER&lt;/code&gt; 및 &lt;code&gt;GIT_DIFF_PATH_TOTAL&lt;/code&gt; 이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="17e261e522ccbc792cc7bd181c9a0bd755a56975" translate="yes" xml:space="preserve">
          <source>For each pathname given via the command-line or from a file via &lt;code&gt;--stdin&lt;/code&gt;, check whether the file is excluded by .gitignore (or other input files to the exclude mechanism) and output the path if it is excluded.</source>
          <target state="translated">명령 행을 통해 또는 &lt;code&gt;--stdin&lt;/code&gt; 을 통해 파일에서 제공된 각 경로 이름에 대해 파일이 .gitignore (또는 제외 메커니즘에 대한 다른 입력 파일)에 의해 제외되는지 확인하고 제외 된 경우 경로를 출력하십시오.</target>
        </trans-unit>
        <trans-unit id="c7b8eb760e478aaaedca171d489f16e4864063c9" translate="yes" xml:space="preserve">
          <source>For each repo that you want accessible from CVS you need to edit config in the repo and add the following section.</source>
          <target state="translated">CVS에서 액세스 할 수있는 각 리포에 대해 리포지토리에서 구성을 편집하고 다음 섹션을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a6b07eab1d3f6d06954967f77b7754d8ea06736" translate="yes" xml:space="preserve">
          <source>For every branch that is up to date or successfully pushed, add upstream (tracking) reference, used by argument-less &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; and other commands. For more information, see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">최신이거나 성공적으로 푸시 된 모든 브랜치에 대해 인수가없는 &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt; 및 기타 명령 에서 사용하는 업스트림 (추적) 참조를 추가하십시오 . 자세한 내용 은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]의 &lt;/a&gt; &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="288f34b4fe961722eeaf789d738c3abe79ce0128" translate="yes" xml:space="preserve">
          <source>For every pathname, this command will list if each attribute is &lt;code&gt;unspecified&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, or &lt;code&gt;unset&lt;/code&gt; as a gitattribute on that pathname.</source>
          <target state="translated">각 속성 인 경우 모든 경로의 경우,이 명령을 나열합니다 &lt;code&gt;unspecified&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; 또는 &lt;code&gt;unset&lt;/code&gt; 하는 경로에 gitattribute있다.</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="b8684a0f4f3937af285df51bf478195b9b43d0d0" translate="yes" xml:space="preserve">
          <source>For example &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; by default (unless &lt;code&gt;--export-all&lt;/code&gt; option is used) allows pulling only for those repositories that have &lt;code&gt;git-daemon-export-ok&lt;/code&gt; file. Adding</source>
          <target state="translated">예를 들어 기본적으로 &lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]&lt;/a&gt; ( &lt;code&gt;--export-all&lt;/code&gt; 옵션을 사용 하지 않는 한 )은 &lt;code&gt;git-daemon-export-ok&lt;/code&gt; 파일 이있는 리포지토리에 대해서만 가져 오기를 허용 합니다. 첨가</target>
        </trans-unit>
        <trans-unit id="46e0aea8ec6e607a64677afaf2a0016d08ab966a" translate="yes" xml:space="preserve">
          <source>For example David Miller wrote &lt;a href=&quot;#6&quot;&gt;[6]&lt;/a&gt;:</source>
          <target state="translated">예를 들어 데이비드 밀러가 쓴 &lt;a href=&quot;#6&quot;&gt;[6]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0e389491903e64c421beccd08371ba327e60cc0c" translate="yes" xml:space="preserve">
          <source>For example an effect from the submodule&amp;rsquo;s &lt;code&gt;.gitignore&lt;/code&gt; file would be observed when you run &lt;code&gt;git status --ignore-submodules=none&lt;/code&gt; in the superproject. This collects information from the submodule&amp;rsquo;s working directory by running &lt;code&gt;status&lt;/code&gt; in the submodule while paying attention to the &lt;code&gt;.gitignore&lt;/code&gt; file of the submodule.</source>
          <target state="translated">예를 들어 , 수퍼 프로젝트에서 &lt;code&gt;git status --ignore-submodules=none&lt;/code&gt; 을 실행 하면 서브 모듈의 &lt;code&gt;.gitignore&lt;/code&gt; 파일 의 효과 가 나타납니다 . 서브 모듈의 &lt;code&gt;.gitignore&lt;/code&gt; 파일에 주의를 기울이면서 서브 모듈에서 &lt;code&gt;status&lt;/code&gt; 를 실행하여 서브 모듈의 작업 디렉토리에서 정보를 수집합니다 .</target>
        </trans-unit>
        <trans-unit id="56e9b1c030d9ba0ed8f301bc4d928b5ec348ecfb" translate="yes" xml:space="preserve">
          <source>For example if commit &lt;code&gt;foo&lt;/code&gt; has been replaced by commit &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">예를 들어 commit &lt;code&gt;foo&lt;/code&gt; 가 commit &lt;code&gt;bar&lt;/code&gt; 로 교체 된 경우 :</target>
        </trans-unit>
        <trans-unit id="fc4ffa566856e8487717cc75478e8ddebf738773" translate="yes" xml:space="preserve">
          <source>For example if repositories you are hosting use &quot;phtml&quot; extension for PHP files, and you want to have correct syntax-highlighting for those files, you can add the following to gitweb configuration:</source>
          <target state="translated">예를 들어 호스팅하는 리포지토리가 PHP 파일에 &quot;phtml&quot;확장자를 사용하고 해당 파일에 대해 올바른 구문 강조 표시를 원하는 경우 gitweb 구성에 다음을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5154cf5119ca3a0384ad194cc198ec59c07c7ac1" translate="yes" xml:space="preserve">
          <source>For example if we start with a graph like this:</source>
          <target state="translated">예를 들어 다음과 같은 그래프로 시작하면</target>
        </trans-unit>
        <trans-unit id="011e69a8d88e3f2ecd0b2c97750e695437a8b7be" translate="yes" xml:space="preserve">
          <source>For example one branch can change the semantic of a function while the other branch add more calls to the same function.</source>
          <target state="translated">예를 들어 한 브랜치는 함수의 의미를 변경할 수 있지만 다른 브랜치는 같은 함수에 더 많은 호출을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="948250d1153d7a9c5c187de68da76cbf9fe7a0b6" translate="yes" xml:space="preserve">
          <source>For example since all normal branches are stored under &lt;code&gt;refs/heads/&lt;/code&gt; name the tag fixup branch &lt;code&gt;TAG_FIXUP&lt;/code&gt;. This way it is impossible for the fixup branch used by the importer to have namespace conflicts with real branches imported from the source (the name &lt;code&gt;TAG_FIXUP&lt;/code&gt; is not &lt;code&gt;refs/heads/TAG_FIXUP&lt;/code&gt;).</source>
          <target state="translated">예를 들어 모든 일반 브랜치는 &lt;code&gt;refs/heads/&lt;/code&gt; 아래에 저장 되므로 태그 수정 브랜치의 이름은 &lt;code&gt;TAG_FIXUP&lt;/code&gt; 입니다. 이 방법으로 임포터가 사용하는 수정 분기가 소스에서 가져온 실제 분기와 네임 스페이스 충돌을 갖는 것은 불가능합니다 (이름 &lt;code&gt;TAG_FIXUP&lt;/code&gt; 은 &lt;code&gt;refs/heads/TAG_FIXUP&lt;/code&gt; 아님 ).</target>
        </trans-unit>
        <trans-unit id="4be01aa529e151bdbbe73a5ece143631e964e4ac" translate="yes" xml:space="preserve">
          <source>For example some test suites could be run automatically at night with some unusual (or even random) configurations. And if a regression is found by a test suite, then &quot;git bisect&quot; can be automatically launched, and its result can be emailed to the author of the first bad commit found by &quot;git bisect&quot;, and perhaps other people too. And a new entry in the bug tracking system could be automatically created too.</source>
          <target state="translated">예를 들어, 일부 테스트 스위트는 비정상적인 (또는 임의의) 구성으로 야간에 자동으로 실행될 수 있습니다. 그리고 테스트 스위트에서 회귀가 발견되면 &quot;git bisect&quot;가 자동으로 시작될 수 있으며 그 결과는 &quot;git bisect&quot;에 의해 발견 된 첫 번째 나쁜 커밋의 저자 및 다른 사람들에게도 이메일로 전송 될 수 있습니다. 또한 버그 추적 시스템의 새로운 항목도 자동으로 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bbfe98ebcd584e72bba80caca0bbe3de761fb8b" translate="yes" xml:space="preserve">
          <source>For example using:</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="b2715e2afcd57211e00aecf4fa8f8efd172203eb" translate="yes" xml:space="preserve">
          <source>For example with the following graph where H is the &quot;bad&quot; commit and A and D are some parents of some &quot;good&quot; commits:</source>
          <target state="translated">예를 들어 다음 그래프에서 H는 &quot;나쁜&quot;커밋이고 A와 D는 &quot;좋은&quot;커밋의 부모입니다.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="33f7a1b1f9148ad49a81c77432db9d624e3ed14b" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;--batch&lt;/code&gt; without a custom format would produce:</source>
          <target state="translated">예를 들어, 사용자 정의 형식이없는 &lt;code&gt;--batch&lt;/code&gt; 는 다음을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f103141294055917b49b4ff3b11f28f0e7b09a93" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;--cherry-pick --right-only A...B&lt;/code&gt; omits those commits from &lt;code&gt;B&lt;/code&gt; which are in &lt;code&gt;A&lt;/code&gt; or are patch-equivalent to a commit in &lt;code&gt;A&lt;/code&gt;. In other words, this lists the &lt;code&gt;+&lt;/code&gt; commits from &lt;code&gt;git cherry A B&lt;/code&gt;. More precisely, &lt;code&gt;--cherry-pick --right-only --no-merges&lt;/code&gt; gives the exact list.</source>
          <target state="translated">예를 들어, &lt;code&gt;--cherry-pick --right-only A...B&lt;/code&gt; 를 생략부터 그 커밋 &lt;code&gt;B&lt;/code&gt; 에 나에 패치 동등이 커밋 . 즉, 이것은 &lt;code&gt;git cherry A B&lt;/code&gt; 의 &lt;code&gt;+&lt;/code&gt; 커밋을 나열합니다 . 보다 정확하게 &lt;code&gt;--cherry-pick --right-only --no-merges&lt;/code&gt; 는 정확한 목록을 제공합니다. &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8a58c9ab1aebec2fe76ee8cb4f7dc47b3afba08" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;--word-diff-regex=.&lt;/code&gt; will treat each character as a word and, correspondingly, show differences character by character.</source>
          <target state="translated">예를 들어 &lt;code&gt;--word-diff-regex=.&lt;/code&gt; 각 문자를 단어로 취급하고 그에 따라 문자별로 차이를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9497e805114a62dd0cfbb0fd446cb80188b76834" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;git bisect reset bisect/bad&lt;/code&gt; will check out the first bad revision, while &lt;code&gt;git bisect reset HEAD&lt;/code&gt; will leave you on the current bisection commit and avoid switching commits at all.</source>
          <target state="translated">예를 들어, &lt;code&gt;git bisect reset bisect/bad&lt;/code&gt; 는 첫 번째 불량 개정을 확인하는 반면 &lt;code&gt;git bisect reset HEAD&lt;/code&gt; 는 현재 bisection 커밋을 유지하고 커밋 전환을 피합니다.</target>
        </trans-unit>
        <trans-unit id="138442d2b65de29c2047a8caafb4d9bebbf214b3" translate="yes" xml:space="preserve">
          <source>For example, Documentation/*.jpg will match all .jpg files in the Documentation subtree, including Documentation/chapter_1/figure_1.jpg.</source>
          <target state="translated">예를 들어 Documentation / *. jpg는 Documentation / chapter_1 / figure_1.jpg를 포함하여 Documentation 하위 트리의 모든 .jpg 파일과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="0d743ee5b8f526c69043aec1a6e6a8e47be44f66" translate="yes" xml:space="preserve">
          <source>For example, Microsoft Visual Studio resources files (&lt;code&gt;*.rc&lt;/code&gt;) or PowerShell script files (&lt;code&gt;*.ps1&lt;/code&gt;) are sometimes encoded in UTF-16. If you declare &lt;code&gt;*.ps1&lt;/code&gt; as files as UTF-16 and you add &lt;code&gt;foo.ps1&lt;/code&gt; with a &lt;code&gt;working-tree-encoding&lt;/code&gt; enabled Git client, then &lt;code&gt;foo.ps1&lt;/code&gt; will be stored as UTF-8 internally. A client without &lt;code&gt;working-tree-encoding&lt;/code&gt; support will checkout &lt;code&gt;foo.ps1&lt;/code&gt; as UTF-8 encoded file. This will typically cause trouble for the users of this file.</source>
          <target state="translated">예를 들어 Microsoft Visual Studio 리소스 파일 ( &lt;code&gt;*.rc&lt;/code&gt; ) 또는 PowerShell 스크립트 파일 ( &lt;code&gt;*.ps1&lt;/code&gt; )은 때때로 UTF-16으로 인코딩됩니다. 당신이 선언하면 &lt;code&gt;*.ps1&lt;/code&gt; 입니다 UTF-16 등의 파일로 및 추가 &lt;code&gt;foo.ps1&lt;/code&gt; 을 와 &lt;code&gt;working-tree-encoding&lt;/code&gt; 망할 놈의 클라이언트를 활성화 한 다음 &lt;code&gt;foo.ps1&lt;/code&gt; 는 UTF-8 내부적으로 저장됩니다. &lt;code&gt;working-tree-encoding&lt;/code&gt; 지원이 없는 클라이언트 는 &lt;code&gt;foo.ps1&lt;/code&gt; 을 UTF-8 인코딩 파일로 체크 아웃 합니다. 이것은 일반적으로이 파일의 사용자에게 문제를 일으 킵니다.</target>
        </trans-unit>
        <trans-unit id="1ed869792207741cfe6bed98106c7b8b8a3d4f0d" translate="yes" xml:space="preserve">
          <source>For example, a patch that talks about updating &lt;code&gt;a/git-gui.sh&lt;/code&gt; to &lt;code&gt;b/git-gui.sh&lt;/code&gt; can be applied to the file in the working tree &lt;code&gt;modules/git-gui/git-gui.sh&lt;/code&gt; by running &lt;code&gt;git apply --directory=modules/git-gui&lt;/code&gt;.</source>
          <target state="translated">예를 들어, a &lt;code&gt;a/git-gui.sh&lt;/code&gt; 를 &lt;code&gt;b/git-gui.sh&lt;/code&gt; / git-gui.sh 로 업데이트 하는 것에 대한 패치는 &lt;code&gt;git apply --directory=modules/git-gui&lt;/code&gt; 를 실행 하여 작업 트리 &lt;code&gt;modules/git-gui/git-gui.sh&lt;/code&gt; /git-gui/git-gui.sh 의 파일에 적용 할 수 있습니다. -directory = modules / git-gui .</target>
        </trans-unit>
        <trans-unit id="ce77d8f6da94ff85eab04ae4cdac09d8840be36a" translate="yes" xml:space="preserve">
          <source>For example, a pattern &lt;code&gt;doc/frotz/&lt;/code&gt; matches &lt;code&gt;doc/frotz&lt;/code&gt; directory, but not &lt;code&gt;a/doc/frotz&lt;/code&gt; directory; however &lt;code&gt;frotz/&lt;/code&gt; matches &lt;code&gt;frotz&lt;/code&gt; and &lt;code&gt;a/frotz&lt;/code&gt; that is a directory (all paths are relative from the &lt;code&gt;.gitignore&lt;/code&gt; file).</source>
          <target state="translated">예를 들어, 패턴 &lt;code&gt;doc/frotz/&lt;/code&gt; 는 &lt;code&gt;doc/frotz&lt;/code&gt; 디렉토리 와 일치 하지만 &lt;code&gt;a/doc/frotz&lt;/code&gt; 디렉토리 와 일치 하지 않습니다 . 그러나 &lt;code&gt;frotz/&lt;/code&gt; 는 디렉토리 인 &lt;code&gt;frotz&lt;/code&gt; 및 &lt;code&gt;a/frotz&lt;/code&gt; frotz 와 일치합니다 (모든 경로는 &lt;code&gt;.gitignore&lt;/code&gt; 파일 과 관련이 있습니다).</target>
        </trans-unit>
        <trans-unit id="67b1d0bce407e8b4870f6f6a95250837544f5b7b" translate="yes" xml:space="preserve">
          <source>For example, an attempt to rearrange</source>
          <target state="translated">예를 들어, 재배치하려는 시도</target>
        </trans-unit>
        <trans-unit id="5bf319ce2803b376c46250398e2ab2c650bad072" translate="yes" xml:space="preserve">
          <source>For example, at the time this page was written, the &lt;a href=&quot;http://repo.or.cz&quot;&gt;http://repo.or.cz&lt;/a&gt; Git hosting site set it to the following to enable graphical log (using the third party tool &lt;strong&gt;git-browser&lt;/strong&gt;):</source>
          <target state="translated">예를 들어,이 페이지가 작성된 시점에서 &lt;a href=&quot;http://repo.or.cz&quot;&gt;http://repo.or.cz&lt;/a&gt; Git 호스팅 사이트는 그래픽 로그를 활성화하기 위해 다음과 같이 설정했습니다 (타사 도구 &lt;strong&gt;git-browser 사용&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="ff9841351106eb72affbaa34cd9000cbe695e6c0" translate="yes" xml:space="preserve">
          <source>For example, consider a git repository containing:</source>
          <target state="translated">예를 들어, 다음을 포함하는 git 저장소를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="aa3e19341d33b69e0c7637f09cb4c872d477e052" translate="yes" xml:space="preserve">
          <source>For example, for the above graph, a command like:</source>
          <target state="translated">예를 들어 위 그래프의 경우 다음과 같은 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5fffc70646f6a27f7f67e5894c9b6fc5ccd683b" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;$projectroot&lt;/code&gt; is set to &quot;/srv/git&quot; by putting the following in gitweb config file:</source>
          <target state="translated">예를 들어, &lt;code&gt;$projectroot&lt;/code&gt; 가 gitweb 구성 파일에 다음을 입력하여 &quot;/ srv / git&quot;으로 설정된 경우 :</target>
        </trans-unit>
        <trans-unit id="852dc3836c1061d866e063a7498878f33ef3ce12" translate="yes" xml:space="preserve">
          <source>For example, if the P4 repository structure is:</source>
          <target state="translated">예를 들어, P4 저장소 구조가 다음과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="4035b3eacf18f396eb5e00ae6815d18cf72feae5" translate="yes" xml:space="preserve">
          <source>For example, if the value for this option is &quot;%=$&quot;, then only lines using the format &lt;code&gt;&amp;lt;token&amp;gt;&amp;lt;sep&amp;gt;&amp;lt;value&amp;gt;&lt;/code&gt; with &amp;lt;sep&amp;gt; containing &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; and then spaces will be considered trailers. And &lt;code&gt;%&lt;/code&gt; will be the default separator used, so by default trailers will appear like: &lt;code&gt;&amp;lt;token&amp;gt;% &amp;lt;value&amp;gt;&lt;/code&gt; (one percent sign and one space will appear between the token and the value).</source>
          <target state="translated">예를 들면,이 옵션에 대한 값은 &quot;% = $&quot;인 경우, 다음의 형식을 사용하는 경우에만 라인 &lt;code&gt;&amp;lt;token&amp;gt;&amp;lt;sep&amp;gt;&amp;lt;value&amp;gt;&lt;/code&gt; 와 &amp;lt;9월&amp;gt; 함유 &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; 또는 &lt;code&gt;$&lt;/code&gt; 다음 공간이 고려 될 것이다 트레일러. 그리고 &lt;code&gt;%&lt;/code&gt; 가 사용되는 기본 구분 기호이므로 기본적으로 예고편은 &lt;code&gt;&amp;lt;token&amp;gt;% &amp;lt;value&amp;gt;&lt;/code&gt; 와 같이 나타납니다 (토큰과 값 사이에 하나의 백분율 기호와 하나의 공백이 나타남).</target>
        </trans-unit>
        <trans-unit id="5103535d9f29750b8c9135f826c57c311f8eeae1" translate="yes" xml:space="preserve">
          <source>For example, if we want a password for &lt;code&gt;https://example.com/foo.git&lt;/code&gt;, we might generate the following credential description (don&amp;rsquo;t forget the blank line at the end; it tells &lt;code&gt;git credential&lt;/code&gt; that the application finished feeding all the information it has):</source>
          <target state="translated">예를 들어 &lt;code&gt;https://example.com/foo.git&lt;/code&gt; 의 비밀번호를 원하면 다음과 같은 자격 증명 설명을 생성 할 수 있습니다 (끝의 빈 줄을 잊지 마십시오; &lt;code&gt;git credential&lt;/code&gt; 에 응용 프로그램이 모두 공급을 완료했음을 알려줍니다) 그것이 가지고있는 정보) :</target>
        </trans-unit>
        <trans-unit id="bb2f882b3f8efdae1333b719a705576641ca3f31" translate="yes" xml:space="preserve">
          <source>For example, if you are looking for a commit that introduced a performance regression, you might use</source>
          <target state="translated">예를 들어, 성능 회귀를 도입 한 커밋을 찾고 있다면</target>
        </trans-unit>
        <trans-unit id="68d306989ac898943c9324c1636692924527fd1d" translate="yes" xml:space="preserve">
          <source>For example, if you have this topology:</source>
          <target state="translated">예를 들어,이 토폴로지가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="a61cdb8cd8334eeef24d9dfefb310bcbd689195c" translate="yes" xml:space="preserve">
          <source>For example, if you have two branches, &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, a usual way to list all commits on only one side of them is with &lt;code&gt;--left-right&lt;/code&gt; (see the example below in the description of the &lt;code&gt;--left-right&lt;/code&gt; option). However, it shows the commits that were cherry-picked from the other branch (for example, &amp;ldquo;3rd on b&amp;rdquo; may be cherry-picked from branch A). With this option, such pairs of commits are excluded from the output.</source>
          <target state="translated">예를 들어, &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 두 개의 분기 가있는 경우 한쪽의 커밋을 모두 나열하는 일반적인 방법은 &lt;code&gt;--left-right&lt;/code&gt; 입니다 ( &lt;code&gt;--left-right&lt;/code&gt; 옵션 설명에서 아래 예 참조 ). . 그러나 다른 브랜치에서 체리 피킹 된 커밋을 보여줍니다 (예 : &quot;b의 3rd&quot;는 브랜치 A에서 체리 피킹 될 수 있음). 이 옵션을 사용하면 이러한 커밋 쌍이 출력에서 ​​제외됩니다.</target>
        </trans-unit>
        <trans-unit id="fe897c525854ed4ff520e569183f4547ca07cbf6" translate="yes" xml:space="preserve">
          <source>For example, if you use mod_perl to run the script, and have dumb HTTP protocol authentication configured for your repositories, you can use the following hook to allow access only if the user is authorized to read the files:</source>
          <target state="translated">예를 들어, mod_perl을 사용하여 스크립트를 실행하고 저장소에 대해 벙어리 HTTP 프로토콜 인증을 구성한 경우 사용자가 파일을 읽을 권한이있는 경우에만 다음 후크를 사용하여 액세스를 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86c7872b373de97c557b525ebe5143ba729f1f41" translate="yes" xml:space="preserve">
          <source>For example, if you want to reorder the last 5 commits, such that what was HEAD~4 becomes the new HEAD. To achieve that, you would call &lt;code&gt;git rebase&lt;/code&gt; like this:</source>
          <target state="translated">예를 들어, 마지막 5 개의 커밋을 재정렬하려면 HEAD ~ 4가 새로운 HEAD가됩니다. 이를 달성하기 위해 다음과 같이 &lt;code&gt;git rebase&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="3cb17626983b1627f4a677c41e03478d83711c28" translate="yes" xml:space="preserve">
          <source>For example, imagine you store the refs for each fork in &lt;code&gt;refs/virtual/ID&lt;/code&gt;, where &lt;code&gt;ID&lt;/code&gt; is a numeric identifier. You might then configure:</source>
          <target state="translated">예를 들어, 각 포크에 대한 참조를 &lt;code&gt;refs/virtual/ID&lt;/code&gt; 에 저장한다고 가정하십시오 . 여기서 &lt;code&gt;ID&lt;/code&gt; 는 숫자 ID입니다. 그런 다음 다음을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30bbf60289c9238f0d33e5175010f4e252c9853c" translate="yes" xml:space="preserve">
          <source>For example, in .gitattributes, you would assign the &lt;code&gt;filter&lt;/code&gt; attribute for paths.</source>
          <target state="translated">예를 들어 .gitattributes에서는 경로에 &lt;code&gt;filter&lt;/code&gt; 속성을 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="c7b53804fabf5a8d611f469400f3d23e0cdaf582" translate="yes" xml:space="preserve">
          <source>For example, in a commit history like this:</source>
          <target state="translated">예를 들어, 다음과 같은 커밋 기록에서 :</target>
        </trans-unit>
        <trans-unit id="806ca5f41259915dee6774976f8cdf13ec61deac" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say that you have worked on your working directory, updated some files in the index and are ready to commit. You want to see exactly &lt;strong&gt;what&lt;/strong&gt; you are going to commit, without having to write a new tree object and compare it that way, and to do that, you just do</source>
          <target state="translated">예를 들어, 작업 디렉토리에서 작업하고 인덱스의 일부 파일을 업데이트했으며 커밋 할 준비가되었다고 가정 해 봅시다. 당신은 정확히보고 싶은 &lt;strong&gt;무엇을&lt;/strong&gt; 하고 그렇게, 그냥 수행 새 트리 오브젝트를 작성하지 않고도, 저지하려고하고 그런 식으로 비교</target>
        </trans-unit>
        <trans-unit id="476c3fc4a50784809d3ca0defbcdf28a5bcb4395" translate="yes" xml:space="preserve">
          <source>For example, main-worktree/HEAD or main-worktree/refs/bisect/good resolve to the same value as the main working tree&amp;rsquo;s HEAD and refs/bisect/good respectively. Similarly, worktrees/foo/HEAD or worktrees/bar/refs/bisect/bad are the same as GIT_COMMON_DIR/worktrees/foo/HEAD and GIT_COMMON_DIR/worktrees/bar/refs/bisect/bad.</source>
          <target state="translated">예를 들어 main-worktree / HEAD 또는 main-worktree / refs / bisect / good는 각각 기본 작업 트리의 HEAD 및 refs / bisect / good와 동일한 값으로 해석됩니다. 마찬가지로 worktrees / foo / HEAD 또는 worktrees / bar / refs / bisect / bad는 GIT_COMMON_DIR / worktrees / foo / HEAD 및 GIT_COMMON_DIR / worktrees / bar / refs / bisect / bad와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="266db89f5ed370855ec231f0d9586be36c8c2a06" translate="yes" xml:space="preserve">
          <source>For example, running &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; generates this tree object from the index, stores it in the object database, and uses it as the tree object associated with the new commit.</source>
          <target state="translated">예를 들어, &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]을&lt;/a&gt; 실행 하면 인덱스에서이 트리 객체가 생성되어 객체 데이터베이스에 저장되어 새 커밋과 관련된 트리 객체로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9241280c5dcf375f9e4ee8c8496a1f68f481ea18" translate="yes" xml:space="preserve">
          <source>For example, starting with this index:</source>
          <target state="translated">예를 들어이 색인으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="37236815fc65047678c9d53df59b5a94b9133df3" translate="yes" xml:space="preserve">
          <source>For example, the following fetch command spawned ssh, index-pack, rev-list, and gc. This example also shows that fetch took 5.199 seconds and of that 4.932 was in ssh.</source>
          <target state="translated">예를 들어 다음 페치 명령은 ssh, index-pack, rev-list 및 gc를 생성했습니다. 이 예제는 또한 페치가 5.199 초 걸리고 그 중 4.932가 ssh에 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="675eb647719ee2ad2bd9af2ee96b8f7029195efd" translate="yes" xml:space="preserve">
          <source>For example, the following setting produces a breadcrumb trail like &quot;home / dev / projects / &amp;hellip;​&quot; where &quot;projects&quot; is the home link.</source>
          <target state="translated">예를 들어 다음 설정은 &quot;home / dev / projects /&amp;hellip;&quot;와 같은 이동 경로 추적을 생성합니다. 여기서 &quot;projects&quot;는 홈 링크입니다.</target>
        </trans-unit>
        <trans-unit id="f229d0901b53da5a8037ba5b963ab5e1b0a84fc7" translate="yes" xml:space="preserve">
          <source>For example, the hook can simply run &lt;code&gt;git read-tree -u -m HEAD &quot;$1&quot;&lt;/code&gt; in order to emulate &lt;code&gt;git fetch&lt;/code&gt; that is run in the reverse direction with &lt;code&gt;git push&lt;/code&gt;, as the two-tree form of &lt;code&gt;git read-tree -u -m&lt;/code&gt; is essentially the same as &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt; that switches branches while keeping the local changes in the working tree that do not interfere with the difference between the branches.</source>
          <target state="translated">예를 들어, 후크 간단하게 실행할 수 있습니다 &lt;code&gt;git read-tree -u -m HEAD &quot;$1&quot;&lt;/code&gt; 에뮬레이트하기 위해 &lt;code&gt;git fetch&lt;/code&gt; 그와 반대 방향으로 실행되는 &lt;code&gt;git push&lt;/code&gt; 의 두 트리 형태로, &lt;code&gt;git read-tree -u -m&lt;/code&gt; 은 기본적으로 분기 간의 전환을 방해하지 않는 작업 트리의 로컬 변경 사항을 유지하면서 분기를 전환하는 &lt;code&gt;git switch&lt;/code&gt; 또는 &lt;code&gt;git checkout&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="2232af53268b39393df426da2516589a0d0a00e9" translate="yes" xml:space="preserve">
          <source>For example, the multithreaded preload-index code can be instrumented with a region around the thread pool and then per-thread start and exit events within the threadproc.</source>
          <target state="translated">예를 들어, 다중 스레드 사전로드 색인 코드는 스레드 풀 주위의 영역으로 계측 된 다음 스레드 프로 시저 내에서 스레드 별 시작 및 종료 이벤트를 계측 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6165309453e90635fafde69fa6a0dbf363059c7" translate="yes" xml:space="preserve">
          <source>For example, there can be a &quot;main&quot; branch, and a &quot;dev&quot; branch that was forked of the main branch at a commit named &quot;D&quot; like this:</source>
          <target state="translated">예를 들어, &quot;main&quot;브랜치와 다음과 같이 &quot;D&quot;라는 커밋에서 메인 브랜치에서 분기 된 &quot;dev&quot;브랜치가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc0695ddae75754b17aaf6b6d741676357b02fb6" translate="yes" xml:space="preserve">
          <source>For example, this configuration:</source>
          <target state="translated">예를 들어이 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="03526c1b7e3b294cd55189c8a4305129233dcf64" translate="yes" xml:space="preserve">
          <source>For example, this line in &lt;code&gt;.gitattributes&lt;/code&gt; can be used to tell the merge machinery to leave much longer (instead of the usual 7-character-long) conflict markers when merging the file &lt;code&gt;Documentation/git-merge.txt&lt;/code&gt; results in a conflict.</source>
          <target state="translated">예를 들어, &lt;code&gt;.gitattributes&lt;/code&gt; 의이 줄을 사용하면 &lt;code&gt;Documentation/git-merge.txt&lt;/code&gt; 파일을 병합 할 때 병합 기계가 일반적인 7 자 길이가 아닌 충돌 마커를 훨씬 더 오래 남겨 두도록 충돌을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b89cc0f3038d951dcea25e6121459d7deb13668" translate="yes" xml:space="preserve">
          <source>For example, to default to pushing only the current branch to &lt;code&gt;origin&lt;/code&gt; use &lt;code&gt;git config remote.origin.push HEAD&lt;/code&gt;. Any valid &amp;lt;refspec&amp;gt; (like the ones in the examples below) can be configured as the default for &lt;code&gt;git push origin&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 현재 브랜치 만 &lt;code&gt;origin&lt;/code&gt; 으로 푸시하도록 기본 &lt;code&gt;git config remote.origin.push HEAD&lt;/code&gt; 하려면 git config remote.origin.push HEAD를 사용하십시오 . 유효한 &amp;lt;refspec&amp;gt; (아래 예와 같이)은 &lt;code&gt;git push origin&lt;/code&gt; 의 기본값으로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="119ea88469245e9be5ce50fb433af7f4a91870c1" translate="yes" xml:space="preserve">
          <source>For example, to show the diff of the exif information of a file instead of the binary information (assuming you have the exif tool installed), add the following section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file):</source>
          <target state="translated">예를 들어, 바이너리 정보 대신 파일의 EXIF ​​정보의 차이를 표시하려면 (exif 도구가 설치되어 있다고 가정) &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 (또는 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 파일)에 다음 섹션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cf3c72a4130dae24f8e93d376c795356d04a806" translate="yes" xml:space="preserve">
          <source>For example, with this topology:</source>
          <target state="translated">예를 들어이 토폴로지의 경우</target>
        </trans-unit>
        <trans-unit id="9026d38d92fad70bfcca633c7e54419876aa74d7" translate="yes" xml:space="preserve">
          <source>For example, with this:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="94a38b75a57da5e0f9eccf5408c94c3056500ecd" translate="yes" xml:space="preserve">
          <source>For example, you can choose a single person to maintain the project&amp;rsquo;s primary public repository. Other developers then clone this repository and each work in their own clone. When they have a series of changes that they&amp;rsquo;re happy with, they ask the maintainer to pull from the branch containing the changes. The maintainer reviews their changes and pulls them into the primary repository, which other developers pull from as necessary to stay coordinated. The Linux kernel and other projects use variants of this model.</source>
          <target state="translated">예를 들어, 프로젝트의 기본 공용 저장소를 유지하기 위해 한 사람을 선택할 수 있습니다. 그런 다음 다른 개발자는이 저장소를 복제하고 각 저장소는 자체 복제본에서 작업합니다. 그들이 만족하는 일련의 변경 사항이 있으면 관리자에게 변경 사항이 포함 된 지점에서 가져 오도록 요청합니다. 관리자는 변경 사항을 검토하고 기본 저장소로 가져 와서 다른 개발자가 조정을 유지하기 위해 필요한 경우 가져옵니다. Linux 커널 및 기타 프로젝트는이 모델의 변형을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0740e14a7a7f21956f0379ce28c5b2be003ef53b" translate="yes" xml:space="preserve">
          <source>For example, you&amp;rsquo;d want to do this after doing a &lt;code&gt;git read-tree&lt;/code&gt;, to link up the stat index details with the proper files.</source>
          <target state="translated">예를 들어, &lt;code&gt;git read-tree&lt;/code&gt; 를 수행 한 후 통계 색인 세부 사항을 적절한 파일과 연결하기 위해 이를 수행하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0af803cded757214a9f60d6e61360566eb8261f1" translate="yes" xml:space="preserve">
          <source>For git&amp;rsquo;s pre-defined color slots, the attributes are meant to be reset at the beginning of each item in the colored output. So setting &lt;code&gt;color.decorate.branch&lt;/code&gt; to &lt;code&gt;black&lt;/code&gt; will paint that branch name in a plain &lt;code&gt;black&lt;/code&gt;, even if the previous thing on the same output line (e.g. opening parenthesis before the list of branch names in &lt;code&gt;log --decorate&lt;/code&gt; output) is set to be painted with &lt;code&gt;bold&lt;/code&gt; or some other attribute. However, custom log formats may do more complicated and layered coloring, and the negated forms may be useful there.</source>
          <target state="translated">git의 사전 정의 된 색상 슬롯의 경우 속성은 색상이 지정된 출력의 각 항목 시작 부분에서 재설정됩니다. 따라서 &lt;code&gt;color.decorate.branch&lt;/code&gt; 를 &lt;code&gt;black&lt;/code&gt; 으로 설정 하면 동일한 출력 행의 이전 항목 (예 : &lt;code&gt;log --decorate&lt;/code&gt; 출력 의 분기 이름 목록 앞에 여는 괄호 )이 다음과 같이 설정되어 있어도 해당 분기 이름을 일반 &lt;code&gt;black&lt;/code&gt; 칠 합니다. &lt;code&gt;bold&lt;/code&gt; 로 표시 되거나 다른 속성으로 표시됩니다. 그러나 사용자 지정 로그 형식은 더 복잡하고 계층화 된 채색을 수행 할 수 있으며 무효화 된 형식이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e39902dddf1a6f048d53b1c87575ee4b12254521" translate="yes" xml:space="preserve">
          <source>For hints on submission using the IMAP interface, see the EXAMPLE section of &lt;a href=&quot;git-imap-send&quot;&gt;git-imap-send[1]&lt;/a&gt;.</source>
          <target state="translated">IMAP 인터페이스를 사용한 제출에 대한 힌트는 &lt;a href=&quot;git-imap-send&quot;&gt;git-imap-send [1]&lt;/a&gt; 의 EXAMPLE 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="30ba9877f29cd2e9b6e46df54ef9603700cf47bd" translate="yes" xml:space="preserve">
          <source>For hints on using &lt;code&gt;git send-email&lt;/code&gt; to send your patches through the GMail SMTP server, see the EXAMPLE section of &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;git send-email&lt;/code&gt; 을 사용 하여 GMail SMTP 서버를 통해 패치를 보내는 방법 에 대한 힌트 는 &lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt; 의 예 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="98a5ba2755b886f28a6b38a3063fb22b4953fd08" translate="yes" xml:space="preserve">
          <source>For instance, if the command &lt;code&gt;git push origin master:foreign&lt;/code&gt; were run the hook would receive a line like the following:</source>
          <target state="translated">예를 들어, &lt;code&gt;git push origin master:foreign&lt;/code&gt; 명령 이 실행 된 경우 후크는 다음과 같은 행을받습니다.</target>
        </trans-unit>
        <trans-unit id="e0da88c77b6050a1f8498227b0e9ea61aad1dd42" translate="yes" xml:space="preserve">
          <source>For instance, if you configured the &lt;code&gt;diff.algorithm&lt;/code&gt; variable to a non-default value and want to use the default one, then you have to use &lt;code&gt;--diff-algorithm=default&lt;/code&gt; option.</source>
          <target state="translated">예를 들어 &lt;code&gt;diff.algorithm&lt;/code&gt; 변수를 기본값이 아닌 값으로 구성하고 기본값을 사용하려면 &lt;code&gt;--diff-algorithm=default&lt;/code&gt; 옵션 을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c03b6c2e674301ea043615909864bcef9fc3a8b4" translate="yes" xml:space="preserve">
          <source>For instance, imagine we are accessing &lt;code&gt;https://example.com/foo.git&lt;/code&gt;. When Git looks into a config file to see if a section matches this context, it will consider the two a match if the context is a more-specific subset of the pattern in the config file. For example, if you have this in your config file:</source>
          <target state="translated">예를 들어 &lt;code&gt;https://example.com/foo.git&lt;/code&gt; 에 액세스한다고 가정 하십시오 . Git이 구성 파일을 조사하여 섹션이이 컨텍스트와 일치하는지 확인하면 컨텍스트가 구성 파일에서 패턴의보다 특정한 서브 세트 인 경우 두 섹션이 일치하는 것으로 간주됩니다. 예를 들어, 설정 파일에 이것을 가지고 있다면 :</target>
        </trans-unit>
        <trans-unit id="160dca6e4172cec7a014617ee2140fea1d612055" translate="yes" xml:space="preserve">
          <source>For internal use only. Used in handshaking the wire protocol. Contains a colon &lt;code&gt;:&lt;/code&gt; separated list of keys with optional values &lt;code&gt;key[=value]&lt;/code&gt;. Presence of unknown keys and values must be ignored.</source>
          <target state="translated">내부 전용. 와이어 프로토콜을 핸드 쉐이킹하는 데 사용됩니다. 선택적 값이 &lt;code&gt;key[=value]&lt;/code&gt; 인 콜론 &lt;code&gt;:&lt;/code&gt; 구분 된 키 목록을 포함합니다 . 알 수없는 키와 값의 존재는 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="7c3c8218b8f3420e2d309aa9107b8abd4e99e346" translate="yes" xml:space="preserve">
          <source>For local repositories, also supported by Git natively, the following syntaxes may be used:</source>
          <target state="translated">Git에서 기본적으로 지원하는 로컬 리포지토리의 경우 다음 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc185d3a233093301eeacaae1d44792c3563d415" translate="yes" xml:space="preserve">
          <source>For more detailed explanation on these common options, see also &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore[7]&lt;/a&gt;.</source>
          <target state="translated">이러한 공통 옵션에 대한 자세한 설명은 &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore [7]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cfb518a2bdb468f6a1698c12278a7c2890c2e01b" translate="yes" xml:space="preserve">
          <source>For more details about the &amp;lt;pathspec&amp;gt; syntax, see the &lt;code&gt;pathspec&lt;/code&gt; entry in &lt;a href=&quot;gitglossary&quot;&gt;gitglossary[7]&lt;/a&gt;.</source>
          <target state="translated">&amp;lt;pathspec&amp;gt; 구문에 대한 자세한 내용은 &lt;a href=&quot;gitglossary&quot;&gt;gitglossary [7]&lt;/a&gt; 의 &lt;code&gt;pathspec&lt;/code&gt; 항목을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f0360b14fd2012ea432fadffcf3782c95bbb3d96" translate="yes" xml:space="preserve">
          <source>For more details, see the &lt;code&gt;pathspec&lt;/code&gt; entry in &lt;a href=&quot;gitglossary&quot;&gt;gitglossary[7]&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 은 &lt;a href=&quot;gitglossary&quot;&gt;gitglossary [7]&lt;/a&gt; 의 &lt;code&gt;pathspec&lt;/code&gt; 항목을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dee223e709585f8622ae3db9c408c2275df286e3" translate="yes" xml:space="preserve">
          <source>For more information about submodules, see &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt;.</source>
          <target state="translated">하위 모듈에 대한 자세한 내용은 &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules [7]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf4d0c9e8fd0a561af6eb800b4aa95d1953e08dc" translate="yes" xml:space="preserve">
          <source>For non-linear topology, such as</source>
          <target state="translated">다음과 같은 비선형 토폴로지의 경우</target>
        </trans-unit>
        <trans-unit id="6869cf2d54fdd333756ee082074da9e8aa4cabf1" translate="yes" xml:space="preserve">
          <source>For now, the paranoid need to find some way to emulate the quarantine environment if they&amp;rsquo;d like the same protection as &quot;push&quot;. E.g. in the case of an internal mirror do the mirroring in two steps, one to fetch the untrusted objects, and then do a second &quot;push&quot; (which will use the quarantine) to another internal repo, and have internal clients consume this pushed-to repository, or embargo internal fetches and only allow them once a full &quot;fsck&quot; has run (and no new fetches have happened in the meantime).</source>
          <target state="translated">현재, 편집증은 &quot;푸시&quot;와 동일한 보호 기능을 원한다면 격리 환경을 에뮬레이트하는 방법을 찾아야합니다. 예를 들어 내부 미러의 경우 두 단계로 미러링을 수행합니다. 하나는 신뢰할 수없는 객체를 가져오고 두 번째 &quot;푸시&quot;(검역을 사용함)를 다른 내부 리포지토리에 수행하고 내부 클라이언트가이 푸시를 소비하게합니다. 내부 페치를 리포지토리 또는 금지하고 전체 &quot;fsck&quot;가 실행 된 후에 만 ​​허용합니다 (그 동안 새로운 페치가 발생하지 않음).</target>
        </trans-unit>
        <trans-unit id="133fa5a74f060c815b7406a1ab993c4e06ad0024" translate="yes" xml:space="preserve">
          <source>For open source projects it can be a good way to get more useful contributions from end users, and to introduce them to QA and development activities.</source>
          <target state="translated">오픈 소스 프로젝트의 경우 최종 사용자로부터보다 유용한 기여를 얻고이를 QA 및 개발 활동에 소개하는 좋은 방법이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd41930f44da136ca06d3f66916ab11faa591b27" translate="yes" xml:space="preserve">
          <source>For our first example, we&amp;rsquo;re going to start a totally new repository from scratch, with no pre-existing files, and we&amp;rsquo;ll call it &lt;code&gt;git-tutorial&lt;/code&gt;. To start up, create a subdirectory for it, change into that subdirectory, and initialize the Git infrastructure with &lt;code&gt;git init&lt;/code&gt;:</source>
          <target state="translated">첫 번째 예에서는 기존 파일이없는 완전히 새로운 저장소를 처음부터 시작하고이를 &lt;code&gt;git-tutorial&lt;/code&gt; 이라고합니다 . 시작하려면 하위 디렉토리를 만들고 해당 하위 디렉토리로 변경 한 다음 &lt;code&gt;git init&lt;/code&gt; 로 Git 인프라를 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="5307fd3985478faa6faac86f16463cb9c367c366" translate="yes" xml:space="preserve">
          <source>For paths with merge conflicts, &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; show the modification states of each side of the merge. For paths that do not have merge conflicts, &lt;code&gt;X&lt;/code&gt; shows the status of the index, and &lt;code&gt;Y&lt;/code&gt; shows the status of the work tree. For untracked paths, &lt;code&gt;XY&lt;/code&gt; are &lt;code&gt;??&lt;/code&gt;. Other status codes can be interpreted as follows:</source>
          <target state="translated">병합 충돌이있는 경로의 경우 &lt;code&gt;X&lt;/code&gt; 및 &lt;code&gt;Y&lt;/code&gt; 는 병합 각 측면의 수정 상태를 보여줍니다. 병합 충돌이없는 경로의 경우 &lt;code&gt;X&lt;/code&gt; 는 인덱스 의 상태를 나타내고 &lt;code&gt;Y&lt;/code&gt; 는 작업 트리의 상태를 나타냅니다. 추적되지 않은 경로의 경우 &lt;code&gt;XY&lt;/code&gt; 는 &lt;code&gt;??&lt;/code&gt; . 다른 상태 코드는 다음과 같이 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7032989b4e615b54922dcaa29834b5d11069ae03" translate="yes" xml:space="preserve">
          <source>For people who do parsing: to make it more robust, just ignore any lines between the first and last one (&quot;&amp;lt;sha1&amp;gt;&quot; and &quot;filename&quot; lines) where you do not recognize the tag words (or care about that particular one) at the beginning of the &quot;extended information&quot; lines. That way, if there is ever added information (like the commit encoding or extended commit commentary), a blame viewer will not care.</source>
          <target state="translated">구문 분석을 수행하는 사람들의 경우 :보다 강력하게하려면 태그 단어를 인식하지 못하는 첫 번째 행과 마지막 행 ( &quot;&amp;lt;sha1&amp;gt;&quot;및 &quot;filename&quot;행) 사이의 행을 무시하십시오 (또는 특정 단어에 신경 쓰십시오). &quot;확장 된 정보&quot;줄의 시작 부분에. 이런 식으로 커밋 인코딩이나 확장 커밋 주석과 같은 추가 정보가 있으면 책임 뷰어는 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3a8933e3664a281a0f1007219c1a5fb906f5b9c" translate="yes" xml:space="preserve">
          <source>For performance reasons, by default, &lt;code&gt;-C&lt;/code&gt; option finds copies only if the original file of the copy was modified in the same changeset. This flag makes the command inspect unmodified files as candidates for the source of copy. This is a very expensive operation for large projects, so use it with caution. Giving more than one &lt;code&gt;-C&lt;/code&gt; option has the same effect.</source>
          <target state="translated">성능상의 이유로 기본적으로 &lt;code&gt;-C&lt;/code&gt; 옵션은 사본의 원본 파일이 동일한 변경 세트에서 수정 된 경우에만 사본을 찾습니다. 이 플래그는 명령이 수정되지 않은 파일을 사본 소스 후보로 검사하게합니다. 대규모 프로젝트의 경우 비용이 많이 드는 작업이므로주의해서 사용하십시오. 둘 이상의 &lt;code&gt;-C&lt;/code&gt; 옵션을 제공하면 동일한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b9345e0345532d160619f268731569cef16617e" translate="yes" xml:space="preserve">
          <source>For plain blobs, it shows the plain contents.</source>
          <target state="translated">일반 얼룩의 경우 일반 내용이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1e52f5f667fd4d7c4b839fc8977488698f28dddb" translate="yes" xml:space="preserve">
          <source>For projects with few developers, or for synchronizing a few private repositories, this may be all you need.</source>
          <target state="translated">개발자가 적은 프로젝트 또는 소수의 개인 저장소를 동기화하는 데 필요한 것입니다.</target>
        </trans-unit>
        <trans-unit id="513a986f0bbc369f77d7fc94a6a47375b99e8d89" translate="yes" xml:space="preserve">
          <source>For quickly making a snapshot, you can omit &quot;push&quot;. In this mode, non-option arguments are not allowed to prevent a misspelled subcommand from making an unwanted stash entry. The two exceptions to this are &lt;code&gt;stash -p&lt;/code&gt; which acts as alias for &lt;code&gt;stash push -p&lt;/code&gt; and pathspecs, which are allowed after a double hyphen &lt;code&gt;--&lt;/code&gt; for disambiguation.</source>
          <target state="translated">스냅 샷을 빠르게 만들기 위해 &quot;푸시&quot;를 생략 할 수 있습니다. 이 모드에서 옵션이 아닌 인수는 철자가 틀린 부속 명령이 원치 않는 숨김 항목을 작성하는 것을 막을 수 없습니다. 이에 대한 두 가지 예외는 &lt;code&gt;stash -p&lt;/code&gt; 에 대한 별칭 역할을 &lt;code&gt;stash push -p&lt;/code&gt; 이중 하이픈 후 사용할 수 있으며 pathspecs, &lt;code&gt;--&lt;/code&gt; 모호성을 위해.</target>
        </trans-unit>
        <trans-unit id="10b29e2b2e8e16a8f0d937588e990a303d5a39cb" translate="yes" xml:space="preserve">
          <source>For reading options: read only from global &lt;code&gt;~/.gitconfig&lt;/code&gt; and from &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; rather than from all available files.</source>
          <target state="translated">읽기 옵션 : 사용 가능한 모든 파일이 아닌 전역 &lt;code&gt;~/.gitconfig&lt;/code&gt; 및 &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; 에서만 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="f670c3a49f96ee071030446b2338be3d3b61c282" translate="yes" xml:space="preserve">
          <source>For reading options: read only from system-wide &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; rather than from all available files.</source>
          <target state="translated">읽기 옵션 : 사용 가능한 모든 파일이 아닌 시스템 전체 &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; 에서만 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="1a0b8cd1ef1778fc9e72b8ac1ede20b2c02305dd" translate="yes" xml:space="preserve">
          <source>For reading options: read only from the repository &lt;code&gt;.git/config&lt;/code&gt; rather than from all available files.</source>
          <target state="translated">읽기 옵션 : 사용 가능한 모든 파일이 아닌 리포지토리 &lt;code&gt;.git/config&lt;/code&gt; 에서만 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="52ad1818a91b579273748ec3f745c2ea8925da11" translate="yes" xml:space="preserve">
          <source>For remote helpers that implement &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt;, this capability allows the refs to be constrained to a private namespace, instead of writing to refs/heads or refs/remotes directly. It is recommended that all importers providing the &lt;code&gt;import&lt;/code&gt; capability use this. It&amp;rsquo;s mandatory for &lt;code&gt;export&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 또는 &lt;code&gt;export&lt;/code&gt; 를 구현하는 원격 헬퍼의 경우이 기능을 사용하면 참조 / 헤드 또는 참조 / 원격에 직접 쓰는 대신 참조 네임 스페이스를 개인 네임 스페이스로 제한 할 수 있습니다. &lt;code&gt;import&lt;/code&gt; 기능을 제공하는 모든 임포터가이를 사용하는 것이 좋습니다 . &lt;code&gt;export&lt;/code&gt; 이 필수입니다 .</target>
        </trans-unit>
        <trans-unit id="443450d98036603164f83ff3df4c2bf679d11741" translate="yes" xml:space="preserve">
          <source>For remotes that require curl (http, https and ftp), the URL to the proxy to use for that remote. Set to the empty string to disable proxying for that remote.</source>
          <target state="translated">curl (http, https 및 ftp)이 필요한 원격의 경우 해당 원격에 사용할 프록시의 URL입니다. 해당 리모트에 대한 프록시를 사용하지 않으려면 빈 문자열로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8af93420a9afb3e813edb57f9ce58a35a5de2989" translate="yes" xml:space="preserve">
          <source>For remotes that require curl (http, https and ftp), the method to use for authenticating against the proxy in use (probably set in &lt;code&gt;remote.&amp;lt;name&amp;gt;.proxy&lt;/code&gt;). See &lt;code&gt;http.proxyAuthMethod&lt;/code&gt;.</source>
          <target state="translated">curl (http, https 및 ftp)이 필요한 원격의 경우 사용중인 프록시에 대해 인증하는 데 사용할 방법입니다 (아마도 &lt;code&gt;remote.&amp;lt;name&amp;gt;.proxy&lt;/code&gt; 에 설정되어 있음 ). &lt;code&gt;http.proxyAuthMethod&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff12c5f69e6a4dbe2b8b7bc739ac234198e179f4" translate="yes" xml:space="preserve">
          <source>For scripting, you can ask it to be quiet with the &quot;--quiet&quot; flag, which allows you to do things like</source>
          <target state="translated">스크립팅의 경우 &quot;--quiet&quot;플래그를 사용하여 조용히 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ad68ca568ca7f00dfca41d4efe640136cb611e6" translate="yes" xml:space="preserve">
          <source>For some frontends, though, it is useful to be able to read back data from the current repository as it is being updated (for example when the source material describes objects in terms of patches to be applied to previously imported objects). This can be accomplished by connecting the frontend and fast-import via bidirectional pipes:</source>
          <target state="translated">그러나 일부 프론트 엔드의 경우, 업데이트 될 때 현재 저장소에서 데이터를 다시 읽을 수있는 것이 유용합니다 (예 : 소스 자료가 이전에 가져온 오브젝트에 적용 할 패치로 오브젝트를 설명하는 경우). 양방향 파이프를 통해 프런트 엔드와 빠른 가져 오기를 연결하면됩니다.</target>
        </trans-unit>
        <trans-unit id="b5ea8ea5b2c1cd3e6d47c32a09c62d3c70b6ee6f" translate="yes" xml:space="preserve">
          <source>For some interesting examples of Git use, see the &lt;a href=&quot;howto-index&quot;&gt;howtos&lt;/a&gt;.</source>
          <target state="translated">Git 사용에 대한 흥미로운 예는 &lt;a href=&quot;howto-index&quot;&gt;howtos를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd917a632df420113bd1fa62c1a75d6d0838fcf8" translate="yes" xml:space="preserve">
          <source>For sorting purposes, fields with numeric values sort in numeric order (&lt;code&gt;objectsize&lt;/code&gt;, &lt;code&gt;authordate&lt;/code&gt;, &lt;code&gt;committerdate&lt;/code&gt;, &lt;code&gt;creatordate&lt;/code&gt;, &lt;code&gt;taggerdate&lt;/code&gt;). All other fields are used to sort in their byte-value order.</source>
          <target state="translated">정렬을 위해 숫자 값이있는 필드는 숫자 순서로 정렬됩니다 ( &lt;code&gt;objectsize&lt;/code&gt; , &lt;code&gt;authordate&lt;/code&gt; , &lt;code&gt;committerdate&lt;/code&gt; , &lt;code&gt;creatordate&lt;/code&gt; , &lt;code&gt;taggerdate&lt;/code&gt; ). 다른 모든 필드는 바이트 값 순서로 정렬하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="032b282727ffc0c1c45df3e884598bae17ea6ac4" translate="yes" xml:space="preserve">
          <source>For specifying settings like &lt;code&gt;verbosity&lt;/code&gt; (how much output to write to stderr) and &lt;code&gt;depth&lt;/code&gt; (how much history is wanted in the case of a shallow clone) that affect how other commands are carried out.</source>
          <target state="translated">다른 명령이 수행되는 방식에 영향을주는 세부 &lt;code&gt;verbosity&lt;/code&gt; (stderr에 쓸 출력량) 및 &lt;code&gt;depth&lt;/code&gt; (얕은 복제의 경우 원하는 기록 량 )와 같은 설정을 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="c02205be8f69628f646f89a0276ec82187cc890c" translate="yes" xml:space="preserve">
          <source>For submodules, this setting can be overridden using the &lt;code&gt;submodule.fetchJobs&lt;/code&gt; config setting.</source>
          <target state="translated">하위 모듈의 경우이 설정은 &lt;code&gt;submodule.fetchJobs&lt;/code&gt; 구성 설정을 사용하여 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4b69b6e908fa58f8bfb0090b464d01ba7afd33a" translate="yes" xml:space="preserve">
          <source>For such a test, you need to merge master and topic somehow. One way to do it is to pull master into the topic branch:</source>
          <target state="translated">이러한 테스트를 위해서는 어떻게 든 마스터와 주제를 병합해야합니다. 이를 수행하는 한 가지 방법은 마스터를 주제 분기로 끌어 오는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e3a970f50f86b7e372ecc38ba0a4b965f601d385" translate="yes" xml:space="preserve">
          <source>For tags, it shows the tag message and the referenced objects.</source>
          <target state="translated">태그의 경우 태그 메시지와 참조 된 객체가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e66e4764a23ddc1ac17a40208b614c40e3d1e8cd" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;squash&lt;/code&gt; and &lt;code&gt;fixup&lt;/code&gt; operation, all commits that were squashed are listed as being rewritten to the squashed commit. This means that there will be several lines sharing the same &lt;code&gt;new-sha1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;squash&lt;/code&gt; 및 &lt;code&gt;fixup&lt;/code&gt; 작업의 경우 스쿼시 된 모든 커밋이 스쿼시 된 커밋에 다시 작성된 것으로 나열됩니다. 이는 동일한 &lt;code&gt;new-sha1&lt;/code&gt; 을 공유하는 여러 줄이 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="0288085d533925ac75b1f295d9e834640d8fad16" translate="yes" xml:space="preserve">
          <source>For the complete list of paths which Git checks for references, and the order it uses to decide which to choose when there are multiple references with the same shorthand name, see the &quot;SPECIFYING REVISIONS&quot; section of &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">Git이 참조를 확인하는 전체 경로 목록과 동일한 속기 이름을 가진 여러 참조가있을 때 선택할 경로를 결정하는 데 사용되는 순서는 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions의&lt;/a&gt; &quot; SPECIFYING REVISIONS&quot;섹션을 참조하십시오 [7] .</target>
        </trans-unit>
        <trans-unit id="44d025151b0ff5e996c1070f067a89933eee64e1" translate="yes" xml:space="preserve">
          <source>For the initial import, &lt;code&gt;git archimport&lt;/code&gt; expects to find itself in an empty directory. To follow the development of a project that uses Arch, rerun &lt;code&gt;git archimport&lt;/code&gt; with the same parameters as the initial import to perform incremental imports.</source>
          <target state="translated">초기 가져 오기의 경우 &lt;code&gt;git archimport&lt;/code&gt; 는 빈 디렉토리에서 자신을 찾을 것으로 예상합니다. Arch를 사용하는 프로젝트 개발 을 수행하려면 초기 가져 오기와 동일한 매개 변수로 &lt;code&gt;git archimport&lt;/code&gt; 를 다시 실행하여 증분 가져 오기를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c91c81358174e9b87a92bafd019b5720cbf2a8d2" translate="yes" xml:space="preserve">
          <source>For the purpose of breaking a filepair, diffcore-break examines the extent of changes between the contents of the files before and after modification (i.e. the contents that have &quot;bcd1234&amp;hellip;​&quot; and &quot;0123456&amp;hellip;​&quot; as their SHA-1 content ID, in the above example). The amount of deletion of original contents and insertion of new material are added together, and if it exceeds the &quot;break score&quot;, the filepair is broken into two. The break score defaults to 50% of the size of the smaller of the original and the result (i.e. if the edit shrinks the file, the size of the result is used; if the edit lengthens the file, the size of the original is used), and can be customized by giving a number after &quot;-B&quot; option (e.g. &quot;-B75&quot; to tell it to use 75%).</source>
          <target state="translated">파일 쌍을 분리하기 위해 diffcore-break는 수정 전후의 파일 내용 (예 : SHA-1 컨텐츠 ID로 &quot;bcd1234&amp;hellip;&quot;및 &quot;0123456&amp;hellip;&quot;이있는 내용) 사이의 변경 정도를 검사합니다. 위의 예에서). 원본 내용의 삭제량과 새로운 자료의 삽입이 함께 추가되고 &quot;단점&quot;을 초과하면 파일 쌍이 두 개로 나뉩니다. 중단 점수는 기본적으로 원본보다 작은 크기와 결과의 50 %로 설정됩니다 (예 : 편집이 파일을 축소하면 결과 크기가 사용됩니다. 편집이 파일을 길게하면 원본 크기가 사용됨) ) 및 &quot;-B&quot;옵션 뒤에 숫자를 제공하여 사용자 정의 할 수 있습니다 (예 : &quot;-B75&quot;는 75 %를 사용하도록 지시 함).</target>
        </trans-unit>
        <trans-unit id="62f1a958bc660b7d22544723f673271098befa81" translate="yes" xml:space="preserve">
          <source>For the purpose of merging broken filepairs back, it uses a different &quot;extent of changes&quot; computation from the ones used by diffcore-break and diffcore-rename. It counts only the deletion from the original, and does not count insertion. If you removed only 10 lines from a 100-line document, even if you added 910 new lines to make a new 1000-line document, you did not do a complete rewrite. diffcore-break breaks such a case in order to help diffcore-rename to consider such filepairs as candidate of rename/copy detection, but if filepairs broken that way were not matched with other filepairs to create rename/copy, then this transformation merges them back into the original &quot;modification&quot;.</source>
          <target state="translated">손상된 파일 쌍을 병합하기 위해 diffcore-break 및 diffcore-rename에서 사용 된 것과 다른 &quot;extent of changes&quot;계산을 사용합니다. 원본에서의 삭제 만 계산하고 삽입은 계산하지 않습니다. 100 줄짜리 문서에서 10 줄만 제거했다면 새로운 1000 줄짜리 문서를 만들기 위해 910 줄을 추가하더라도 완전히 다시 쓰지 않았습니다. diffcore-break는 diffcore-rename이 이름 바꾸기 / 복사 탐지의 후보와 같은 파일 쌍을 고려하도록 돕기 위해 이러한 경우를 중단하지만, 그런 방식으로 손상된 파일 쌍이 다른 파일 쌍과 일치하지 않아 이름 바꾸기 / 복사를 작성하는 경우이 변환은 다시 병합합니다. 원래의 &quot;수정&quot;으로</target>
        </trans-unit>
        <trans-unit id="6ab2225889ebaecccd59bff89db6e9b9331d68f2" translate="yes" xml:space="preserve">
          <source>For the sake of clarity, let&amp;rsquo;s stay with &lt;code&gt;git cat-file&lt;/code&gt;, because it</source>
          <target state="translated">명확성을 위해 &lt;code&gt;git cat-file&lt;/code&gt; 을 유지 하십시오.</target>
        </trans-unit>
        <trans-unit id="3256aa918e5b4c1710b691c8cd23b5d5181ec72c" translate="yes" xml:space="preserve">
          <source>For the sake of simplicity and interoperating with Subversion, it is recommended that all &lt;code&gt;git svn&lt;/code&gt; users clone, fetch and dcommit directly from the SVN server, and avoid all &lt;code&gt;git clone&lt;/code&gt;/&lt;code&gt;pull&lt;/code&gt;/&lt;code&gt;merge&lt;/code&gt;/&lt;code&gt;push&lt;/code&gt; operations between Git repositories and branches. The recommended method of exchanging code between Git branches and users is &lt;code&gt;git format-patch&lt;/code&gt; and &lt;code&gt;git am&lt;/code&gt;, or just 'dcommit&amp;rsquo;ing to the SVN repository.</source>
          <target state="translated">단순성과 Subversion과의 상호 운용성을 위해 모든 &lt;code&gt;git svn&lt;/code&gt; 사용자는 SVN 서버에서 직접 복제, 페치 및 dcommit하고 Git 저장소와 분기 사이의 모든 &lt;code&gt;git clone&lt;/code&gt; / &lt;code&gt;pull&lt;/code&gt; / &lt;code&gt;merge&lt;/code&gt; / &lt;code&gt;push&lt;/code&gt; 작업을 피하는 것이 좋습니다. Git 브랜치와 사용자간에 코드를 교환하는 데 권장되는 방법은 &lt;code&gt;git format-patch&lt;/code&gt; 및 &lt;code&gt;git am&lt;/code&gt; 또는 SVN 리포지토리에 'dcommit'하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2279b6e7f152e69847961316b26521ce7eeaaca8" translate="yes" xml:space="preserve">
          <source>For these commands, specifying a single revision, using the notation described in the previous section, means the set of commits &lt;code&gt;reachable&lt;/code&gt; from the given commit.</source>
          <target state="translated">이 명령에서 이전 절에서 설명한 표기법을 사용하여 단일 개정을 지정 하면 지정된 커밋에서 &lt;code&gt;reachable&lt;/code&gt; 있는 커밋 세트를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="74da4e1940c3e7e40b0478bfdb6a84a981ccd45c" translate="yes" xml:space="preserve">
          <source>For this reason it is strongly recommended that users repack the repository with &lt;code&gt;git repack -a -d&lt;/code&gt; after fast-import completes, allowing Git to reorganize the packfiles for faster data access. If blob deltas are suboptimal (see above) then also adding the &lt;code&gt;-f&lt;/code&gt; option to force recomputation of all deltas can significantly reduce the final packfile size (30-50% smaller can be quite typical).</source>
          <target state="translated">따라서 빠른 가져 오기가 완료된 후 사용자가 &lt;code&gt;git repack -a -d&lt;/code&gt; 를 사용하여 리포지토리를 다시 포장 하여 Git이 더 빠른 데이터 액세스를 위해 팩 파일을 재구성 할 수 있도록 하는 것이 좋습니다 . Blob 델타가 차선책 인 경우 (위 참조) &lt;code&gt;-f&lt;/code&gt; 옵션을 추가하면 모든 델타를 강제로 재 계산하여 최종 팩 파일 크기를 크게 줄일 수 있습니다 (30-50 % 더 작을 수 있음).</target>
        </trans-unit>
        <trans-unit id="0c101be68a53a28136d34207f208a2b09cd96fd2" translate="yes" xml:space="preserve">
          <source>For transports that SVN handles authentication for (http, https, and plain svn), specify the username. For other transports (e.g. &lt;code&gt;svn+ssh://&lt;/code&gt;), you must include the username in the URL, e.g. &lt;code&gt;svn+ssh://foo@svn.bar.com/project&lt;/code&gt;</source>
          <target state="translated">SVN이 (http, https 및 일반 svn)에 대한 인증을 처리하는 전송의 경우 사용자 이름을 지정하십시오. 다른 전송 (예 : &lt;code&gt;svn+ssh://&lt;/code&gt; )의 경우 URL에 사용자 이름을 포함해야합니다 (예 : &lt;code&gt;svn+ssh://foo@svn.bar.com/project&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="884bf4d941685ae2ac82a222d5a5cd34350cf6bb" translate="yes" xml:space="preserve">
          <source>For trees, it shows the names (equivalent to &lt;code&gt;git ls-tree&lt;/code&gt; with --name-only).</source>
          <target state="translated">나무의 경우 이름이 표시됩니다 ( --name-only의 &lt;code&gt;git ls-tree&lt;/code&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="add825378fcd5c043a391a94c20d1353e2f3f4d7" translate="yes" xml:space="preserve">
          <source>For true distributed development that supports proper merging, published branches should never be rewritten.</source>
          <target state="translated">적절한 병합을 지원하는 진정한 분산 개발의 경우 게시 된 분기를 다시 작성해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="3d68fc99046b8e48302665b1b866f7694067fd6a" translate="yes" xml:space="preserve">
          <source>For use with --textconv or --filters, to allow specifying an object name and a path separately, e.g. when it is difficult to figure out the revision from which the blob came.</source>
          <target state="translated">--textconv 또는 --filters와 함께 사용하여 개체 이름과 경로를 별도로 지정할 수 있습니다 (예 : 얼룩의 수정본을 파악하기 어려운 경우).</target>
        </trans-unit>
        <trans-unit id="e72ffb4fac055436e16518cc2f4fb21127e4cb40" translate="yes" xml:space="preserve">
          <source>For writing options: write to global &lt;code&gt;~/.gitconfig&lt;/code&gt; file rather than the repository &lt;code&gt;.git/config&lt;/code&gt;, write to &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; file if this file exists and the &lt;code&gt;~/.gitconfig&lt;/code&gt; file doesn&amp;rsquo;t.</source>
          <target state="translated">쓰기 옵션 : 저장소 &lt;code&gt;.git/config&lt;/code&gt; 대신 글로벌 &lt;code&gt;~/.gitconfig&lt;/code&gt; 파일 에 쓰기, 이 파일이 있고 &lt;code&gt;~/.gitconfig&lt;/code&gt; 파일이없는 경우 &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="1d4f90bdceeed64344a78d1a30eb973c4a695eed" translate="yes" xml:space="preserve">
          <source>For writing options: write to system-wide &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; rather than the repository &lt;code&gt;.git/config&lt;/code&gt;.</source>
          <target state="translated">쓰기 옵션 : 저장소 &lt;code&gt;.git/config&lt;/code&gt; 대신 시스템 전체 &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; 씁니다 .</target>
        </trans-unit>
        <trans-unit id="ab6a40ba6d951665186720914cfcdda1831523bb" translate="yes" xml:space="preserve">
          <source>For writing options: write to the repository &lt;code&gt;.git/config&lt;/code&gt; file. This is the default behavior.</source>
          <target state="translated">쓰기 옵션 : 저장소 &lt;code&gt;.git/config&lt;/code&gt; 파일에 씁니다 . 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="1b61f0964f0c12ab159b1b9cbdaad36acf5d4cd8" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;git gc&lt;/code&gt; to run even if there may be another &lt;code&gt;git gc&lt;/code&gt; instance running on this repository.</source>
          <target state="translated">이 저장소에서 다른 &lt;code&gt;git gc&lt;/code&gt; 인스턴스가 실행 중이 더라도 &lt;code&gt;git gc&lt;/code&gt; 를 강제 로 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="2041f78f7b4213165ad0484df1b0863ad820d047" translate="yes" xml:space="preserve">
          <source>Force renaming or moving of a file even if the target exists</source>
          <target state="translated">대상이 존재하더라도 파일의 이름을 바꾸거나 파일을 강제로 이동</target>
        </trans-unit>
        <trans-unit id="ecd78b0e67ad331a13ae4cb8f4e6a9ed04fc189e" translate="yes" xml:space="preserve">
          <source>Force the cloning process from a repository on a local filesystem to copy the files under the &lt;code&gt;.git/objects&lt;/code&gt; directory instead of using hardlinks. This may be desirable if you are trying to make a back-up of your repository.</source>
          <target state="translated">로컬 파일 시스템의 저장소에서 복제 프로세스를 수행 하여 하드 링크를 사용하는 대신 &lt;code&gt;.git/objects&lt;/code&gt; 디렉토리 아래에 파일을 복사하십시오 . 저장소를 백업하려는 경우이 방법이 바람직 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aad6db9c36a2f2837e6ea58135f2a7c135ffcc5" translate="yes" xml:space="preserve">
          <source>Force the merge even if the files are not up to date.</source>
          <target state="translated">파일이 최신이 아닌 경우에도 병합을 강제합니다.</target>
        </trans-unit>
        <trans-unit id="b35554b966d1f9e773a7eeb185af7c152ef043be" translate="yes" xml:space="preserve">
          <source>Force the parent commit, even if it is not a direct parent.</source>
          <target state="translated">직접적인 부모가 아닌 경우에도 부모 커밋을 강제 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8fd0762700f6c31dd37961618e48e9600a28f63f" translate="yes" xml:space="preserve">
          <source>Force updating modified existing branches, even if doing so would cause commits to be lost (as the new commit does not contain the old commit).</source>
          <target state="translated">수정 된 기존 분기를 강제로 업데이트하면 새 커밋에 이전 커밋이 포함되지 않으므로 커밋이 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c16110b137eeeb074b6bb1a45d5cee67e8b8d7d" translate="yes" xml:space="preserve">
          <source>Forces fast-import to close the current packfile, generate its unique SHA-1 checksum and index, and start a new packfile. This command is optional and is not needed to perform an import.</source>
          <target state="translated">빠른 가져 오기로 현재 팩 파일을 닫고 고유 한 SHA-1 체크섬 및 색인을 생성 한 후 새 팩 파일을 시작합니다. 이 명령은 선택 사항이며 가져 오기를 수행하는 데 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a687c2c8da515bb3889e24f9c0c80b813b24084" translate="yes" xml:space="preserve">
          <source>Forces fast-import to close the current packfile, start a new one, and to save out all current branch refs, tags and marks.</source>
          <target state="translated">빠른 가져 오기로 현재 팩 파일을 닫고 새 팩 파일을 시작하며 모든 현재 분기 참조, 태그 및 마크를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="434a9daac438458d6a5542866bf4627ab056ebc0" translate="yes" xml:space="preserve">
          <source>Forcing git fetch to do non-fast-forward updates</source>
          <target state="translated">빨리 감기가 아닌 업데이트를 수행하도록 git fetch를 강제 실행</target>
        </trans-unit>
        <trans-unit id="07c2be944c0e6602c04932a6e3d9ec7d07d27d65" translate="yes" xml:space="preserve">
          <source>Forget about the current merge in progress. Leave the index and the working tree as-is.</source>
          <target state="translated">현재 진행중인 병합을 잊어 버리십시오. 인덱스와 작업 트리를 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="81bdf759eac78632844fbde02bcf81c1762add7d" translate="yes" xml:space="preserve">
          <source>Forget about the current operation in progress. Can be used to clear the sequencer state after a failed cherry-pick or revert.</source>
          <target state="translated">현재 진행중인 작업을 잊어 버리십시오. 체리 픽 선택 또는 복귀 실패 후 시퀀서 상태를 지우는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc2093ee15e651049bc58aa54bb94be570859e07" translate="yes" xml:space="preserve">
          <source>Format data by columns:</source>
          <target state="translated">열별로 데이터 형식을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="74cf0d3233deb63a1885a09b7a59d2c4cacb7451" translate="yes" xml:space="preserve">
          <source>Format data by rows:</source>
          <target state="translated">행별로 데이터를 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="1490d94054ac9f1a7565287cb4c10caa7d0a3ff1" translate="yes" xml:space="preserve">
          <source>Format of the file(s) specified in sendemail.aliasesFile. Must be one of &lt;code&gt;mutt&lt;/code&gt;, &lt;code&gt;mailrc&lt;/code&gt;, &lt;code&gt;pine&lt;/code&gt;, &lt;code&gt;elm&lt;/code&gt;, or &lt;code&gt;gnus&lt;/code&gt;, or &lt;code&gt;sendmail&lt;/code&gt;.</source>
          <target state="translated">sendemail.aliasesFile에 지정된 파일 형식. &lt;code&gt;mutt&lt;/code&gt; , &lt;code&gt;mailrc&lt;/code&gt; , &lt;code&gt;pine&lt;/code&gt; , &lt;code&gt;elm&lt;/code&gt; , &lt;code&gt;gnus&lt;/code&gt; 또는 &lt;code&gt;sendmail&lt;/code&gt; 중 하나 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="85b75659b13a3c18419a2059ae24d18f7aec62d9" translate="yes" xml:space="preserve">
          <source>Format of the resulting archive: &lt;code&gt;tar&lt;/code&gt; or &lt;code&gt;zip&lt;/code&gt;. If this option is not given, and the output file is specified, the format is inferred from the filename if possible (e.g. writing to &quot;foo.zip&quot; makes the output to be in the zip format). Otherwise the output format is &lt;code&gt;tar&lt;/code&gt;.</source>
          <target state="translated">결과 아카이브의 형식 : &lt;code&gt;tar&lt;/code&gt; 또는 &lt;code&gt;zip&lt;/code&gt; . 이 옵션을 지정하지 않고 출력 파일을 지정하면 가능한 경우 파일 이름에서 형식이 유추됩니다 (예 : &quot;foo.zip&quot;에 쓰면 출력이 zip 형식이됩니다). 그렇지 않으면 출력 형식은 &lt;code&gt;tar&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2804d9f16a38553f8238529c90d66e7d7426c150" translate="yes" xml:space="preserve">
          <source>Formats</source>
          <target state="translated">Formats</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="97808e16f7b3e0748cf911affe6a2e5f5336bd69" translate="yes" xml:space="preserve">
          <source>Fortunately, Git also keeps a log, called a &quot;reflog&quot;, of all the previous values of each branch. So in this case you can still find the old history using, for example,</source>
          <target state="translated">다행히도 Git은 &quot;reflog&quot;라고하는 각 분기의 모든 이전 값에 대한 로그를 유지합니다. 따라서이 경우에도 예를 들어</target>
        </trans-unit>
        <trans-unit id="52aedb174e481572a146a6eee6e65f3145e19419" translate="yes" xml:space="preserve">
          <source>Fortunately, when you try and merge branches imported from Arch, Git will find a good merge base, and it has a good chance of identifying patches that have been traded out-of-sequence between the branches.</source>
          <target state="translated">다행히도 Arch에서 가져온 브랜치를 병합하려고 시도하면 Git은 좋은 병합 기반을 찾고 브랜치간에 순서가 맞지 않게 거래 된 패치를 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f243a4b31e069ad1af1905a7b7ee3c0a6bc4a9d9" translate="yes" xml:space="preserve">
          <source>Freely Skip Around Branches</source>
          <target state="translated">지점을 자유롭게 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="bc2451038a48527dcbeab53ccfe9fbac5f2cad0f" translate="yes" xml:space="preserve">
          <source>From a clean working directory:</source>
          <target state="translated">깨끗한 작업 디렉토리에서 :</target>
        </trans-unit>
        <trans-unit id="e5d597f5b08d8d486fa4fe348997e77a44c54af8" translate="yes" xml:space="preserve">
          <source>From a remote repository:</source>
          <target state="translated">원격 저장소에서 :</target>
        </trans-unit>
        <trans-unit id="288bfe5db4a5e76e3e6479e8536caa4995b7e02e" translate="yes" xml:space="preserve">
          <source>From a tarball:</source>
          <target state="translated">타르볼에서 :</target>
        </trans-unit>
        <trans-unit id="734c2e78c0e94a1be8f8ce3bed6beeb7e74b3905" translate="yes" xml:space="preserve">
          <source>From the Git 1.5.4 series and further, many Git commands (not all of them at the time of the writing though) come with an enhanced option parser.</source>
          <target state="translated">Git 1.5.4 시리즈 이상에서 많은 Git 명령 (작성 당시 모든 명령이 아님)에는 향상된 옵션 파서가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a7a0e1c60991430a8700058d7dbaaa429f71c02b" translate="yes" xml:space="preserve">
          <source>From this point, the result of either of the following commands:</source>
          <target state="translated">이 시점에서 다음 명령 중 하나의 결과 :</target>
        </trans-unit>
        <trans-unit id="3e41340cee5d477151048da29744ee1316a7f6cb" translate="yes" xml:space="preserve">
          <source>Frontends may choose to issue checkpoints during extremely large and long running imports, or when they need to allow another Git process access to a branch. However given that a 30 GiB Subversion repository can be loaded into Git through fast-import in about 3 hours, explicit checkpointing may not be necessary.</source>
          <target state="translated">프런트 엔드는 매우 크고 오래 실행되는 가져 오기 중이나 다른 Git 프로세스가 분기에 액세스해야 할 때 검사 점을 발행하도록 선택할 수 있습니다. 그러나 30 GiB Subversion 저장소를 약 3 시간 내에 빠른 가져 오기를 통해 Git에로드 할 수 있으므로 명시적인 체크 포인트가 필요하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45f585d5b13263a74e89d30321fceb20439bc1e7" translate="yes" xml:space="preserve">
          <source>Frontends should prefer the &lt;code&gt;raw&lt;/code&gt; format if the source material already uses UNIX-epoch format, can be coaxed to give dates in that format, or its format is easily convertible to it, as there is no ambiguity in parsing.</source>
          <target state="translated">소스 자료가 이미 UNIX-epoch 형식을 사용하거나 해당 형식으로 날짜를 제공하기 위해 동축 될 수 있거나 구문 분석에 모호성이 없으므로 형식을 쉽게 변환 할 수있는 경우 프론트 엔드는 &lt;code&gt;raw&lt;/code&gt; 형식을 선호해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f3cc2873d5f4e3e8be387b77133d15ba005de66f" translate="yes" xml:space="preserve">
          <source>Frontends which have efficient access to all revisions of a single file (for example reading an RCS/CVS ,v file) can choose to supply all revisions of that file as a sequence of consecutive &lt;code&gt;blob&lt;/code&gt; commands. This allows fast-import to deltify the different file revisions against each other, saving space in the final packfile. Marks can be used to later identify individual file revisions during a sequence of &lt;code&gt;commit&lt;/code&gt; commands.</source>
          <target state="translated">단일 파일의 모든 개정판에 효율적으로 액세스 할 수있는 프론트 엔드 (예 : RCS / CVS, v 파일 읽기)는 해당 파일의 모든 개정판을 일련의 연속적인 &lt;code&gt;blob&lt;/code&gt; 명령 으로 제공하도록 선택할 수 있습니다 . 이를 통해 빠른 가져 오기를 통해 서로 다른 파일 개정판을 서로 다른 것으로 수정하여 최종 팩 파일의 공간을 절약 할 수 있습니다. 일련의 &lt;code&gt;commit&lt;/code&gt; 명령 중에 마크를 사용하여 개별 파일 개정을 나중에 식별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3519d227e718b16c5b769aae01680cf2cd77dc46" translate="yes" xml:space="preserve">
          <source>Full URL and absolute URL of the gitweb script; in earlier versions of gitweb you might have need to set those variables, but now there should be no need to do it. See &lt;code&gt;$per_request_config&lt;/code&gt; if you need to set them still.</source>
          <target state="translated">gitweb 스크립트의 전체 URL 및 절대 URL. 이전 버전의 gitweb에서는 해당 변수를 설정해야 할 수도 있지만 이제는 설정할 필요가 없습니다. 여전히 설정해야 할 경우 &lt;code&gt;$per_request_config&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a108e2708a06a554ba0c3dc09504268225bd27f7" translate="yes" xml:space="preserve">
          <source>Full pattern set</source>
          <target state="translated">풀 패턴 세트</target>
        </trans-unit>
        <trans-unit id="b8fec8cb8e4460222f34da65fd7e0d2a0f5118ab" translate="yes" xml:space="preserve">
          <source>Function used to determine which repositories should be shown. This subroutine should take one parameter, the full path to a project, and if it returns true, that project will be included in the projects list and can be accessed through gitweb as long as it fulfills the other requirements described by $export_ok, $projects_list, and $projects_maxdepth. Example:</source>
          <target state="translated">표시 할 리포지토리를 결정하는 데 사용되는 기능입니다. 이 서브 루틴은 하나의 매개 변수, 프로젝트의 전체 경로를 가져야하며, true를 리턴하면 해당 프로젝트는 프로젝트 목록에 포함되며 $ export_ok, $ projects_list에 설명 된 다른 요구 사항을 충족하는 한 gitweb을 통해 액세스 할 수 있습니다. 및 $ projects_maxdepth. 예:</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="953f869510869f147aa66935f6f2e4c1b01346f2" translate="yes" xml:space="preserve">
          <source>Fundamental data structures and utilities of Git. Exposes only limited source code management tools.</source>
          <target state="translated">Git의 기본 데이터 구조 및 유틸리티. 제한된 소스 코드 관리 도구 만 노출합니다.</target>
        </trans-unit>
        <trans-unit id="2a68bfcdf45f0d6508d348a650a90dad4898fc87" translate="yes" xml:space="preserve">
          <source>Further chapters cover more specialized topics.</source>
          <target state="translated">추가 장에서는보다 전문적인 주제를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="bc4614e5e44f10e9735555c384229ac13d88fcbe" translate="yes" xml:space="preserve">
          <source>Further documentation</source>
          <target state="translated">추가 문서</target>
        </trans-unit>
        <trans-unit id="1a67b11bbb73911c0ea7f808bf383dac0f90b1d2" translate="yes" xml:space="preserve">
          <source>Further suppose that the other person already pushed changes leading to A back to the original repository from which you two obtained the original commit X.</source>
          <target state="translated">또한 다른 사람이 이미 변경 사항을 푸시하여 A가 원래 커밋 X를 얻은 원래 저장소로 되돌려 놓았다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="11dea5e071893c59426ef6a8d5f500708e7c087c" translate="yes" xml:space="preserve">
          <source>Further, remember how I said that &lt;code&gt;git write-tree&lt;/code&gt; writes the contents of the &lt;strong&gt;index&lt;/strong&gt; file to the tree, and thus what we just committed was in fact the &lt;strong&gt;original&lt;/strong&gt; contents of the file &lt;code&gt;hello&lt;/code&gt;, not the new ones. We did that on purpose, to show the difference between the index state, and the state in the working tree, and how they don&amp;rsquo;t have to match, even when we commit things.</source>
          <target state="translated">또한 &lt;code&gt;git write-tree&lt;/code&gt; 가 &lt;strong&gt;인덱스&lt;/strong&gt; 파일 의 내용을 트리에 기록 한다고 말했기 때문에 방금 커밋 한 것은 실제로 새로운 파일이 아닌 &lt;code&gt;hello&lt;/code&gt; 파일 의 &lt;strong&gt;원래&lt;/strong&gt; 내용이었습니다 . 우리는 의도적으로 인덱스 상태와 작업 트리의 상태 간의 차이와 일을 커밋 할 때 일치하지 않아도되는 방법을 보여주기 위해 그렇게했습니다.</target>
        </trans-unit>
        <trans-unit id="12a1c3eb3c3466df160e63355f0a70980e5d8a54" translate="yes" xml:space="preserve">
          <source>Further, several additional files are created or updated per commit by git-filter-branch. Some of these are for supporting the convenience functions provided by git-filter-branch (such as map()), while others are for keeping track of internal state (but could have also been accessed by user filters; one of git-filter-branch&amp;rsquo;s regression tests does so). This essentially amounts to using the filesystem as an IPC mechanism between git-filter-branch and the user-provided filters. Disks tend to be a slow IPC mechanism, and writing these files also effectively represents a forced synchronization point between separate processes that we hit with every commit.</source>
          <target state="translated">또한 git-filter-branch에 의해 커밋 당 몇 개의 추가 파일이 생성되거나 업데이트됩니다. 이 중 일부는 git-filter-branch (예 : map ())에서 제공하는 편의 기능을 지원하기위한 것이고 다른 일부는 내부 상태를 추적하기위한 것입니다 (그러나 사용자 필터를 통해 액세스 할 수도 있음). 분기의 회귀 테스트가 수행됩니다). 이것은 본질적으로 파일 시스템을 git-filter-branch와 사용자 제공 필터 사이의 IPC 메커니즘으로 사용하는 것과 같습니다. 디스크는 느린 IPC 메커니즘 인 경향이 있으며, 이러한 파일을 작성하는 것은 모든 커밋에서 발생하는 개별 프로세스 간의 강제 동기화 지점을 효과적으로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7ca2383accb8da62a165b73e8556d1713934adf2" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;git read-tree&lt;/code&gt; has special-case logic that says: if you see a file that matches in all respects in the following states, it &quot;collapses&quot; back to &quot;stage0&quot;:</source>
          <target state="translated">또한 &lt;code&gt;git read-tree&lt;/code&gt; 에는 다음과 같은 특수한 논리가 있습니다. 다음과 같은 상태에서 모든 측면에서 일치하는 파일이 표시되면 &quot;stage&quot;로 다시 &quot;축소&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="31a08e0ad75da0260fa91bb8e152e897858a7305" translate="yes" xml:space="preserve">
          <source>Furthermore, passwords need not be specified in configuration files or on the command line. If a username has been specified (with &lt;code&gt;--smtp-user&lt;/code&gt; or a &lt;code&gt;sendemail.smtpUser&lt;/code&gt;), but no password has been specified (with &lt;code&gt;--smtp-pass&lt;/code&gt; or &lt;code&gt;sendemail.smtpPass&lt;/code&gt;), then a password is obtained using &lt;code&gt;git-credential&lt;/code&gt;.</source>
          <target state="translated">또한 구성 파일이나 명령 줄에 암호를 지정할 필요가 없습니다. 사용자 이름이 지정되었지만 ( &lt;code&gt;--smtp-user&lt;/code&gt; 또는 &lt;code&gt;sendemail.smtpUser&lt;/code&gt; 사용 ) 비밀번호가 지정되지 않은 경우 ( &lt;code&gt;--smtp-pass&lt;/code&gt; 또는 &lt;code&gt;sendemail.smtpPass&lt;/code&gt; 사용 ) 비밀번호는 &lt;code&gt;git-credential&lt;/code&gt; 을 사용하여 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="eebdda6fedb5243cc4950de3133a043a2ebece61" translate="yes" xml:space="preserve">
          <source>Furthermore, supplying &lt;code&gt;--aggressive&lt;/code&gt; will tweak the &lt;code&gt;--depth&lt;/code&gt; and &lt;code&gt;--window&lt;/code&gt; options passed to &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;. See the &lt;code&gt;gc.aggressiveDepth&lt;/code&gt; and &lt;code&gt;gc.aggressiveWindow&lt;/code&gt; settings below. By using a larger window size we&amp;rsquo;re more likely to find more optimal deltas.</source>
          <target state="translated">또한 &lt;code&gt;--aggressive&lt;/code&gt; 를 제공 하면 &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]에&lt;/a&gt; 전달 된 &lt;code&gt;--depth&lt;/code&gt; 및 &lt;code&gt;--window&lt;/code&gt; 옵션 이 조정됩니다 . 아래의 &lt;code&gt;gc.aggressiveDepth&lt;/code&gt; 및 &lt;code&gt;gc.aggressiveWindow&lt;/code&gt; 설정을 참조하십시오. 더 큰 창 크기를 사용하면 더 최적의 델타를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c04d9fd3f33708a82d676293fc52e5a70fbf49e1" translate="yes" xml:space="preserve">
          <source>Future work</source>
          <target state="translated">향후 작업</target>
        </trans-unit>
        <trans-unit id="7fa52712e6497fe42aeefb82c610da75e312ec0f" translate="yes" xml:space="preserve">
          <source>GITWEB_CONFIG</source>
          <target state="translated">GITWEB_CONFIG</target>
        </trans-unit>
        <trans-unit id="9636fb1dbafa2b47af9b2233bf38584401d20651" translate="yes" xml:space="preserve">
          <source>GITWEB_CONFIG_COMMON</source>
          <target state="translated">GITWEB_CONFIG_COMMON</target>
        </trans-unit>
        <trans-unit id="f726c6360c3b65b3b136cb8ed08c06cd6bb3dc13" translate="yes" xml:space="preserve">
          <source>GITWEB_CONFIG_SYSTEM</source>
          <target state="translated">GITWEB_CONFIG_SYSTEM</target>
        </trans-unit>
        <trans-unit id="7280da4640f08695fca3fbf79b196a715d6c95d5" translate="yes" xml:space="preserve">
          <source>GIT_ALTERNATE_OBJECT_DIRECTORIES</source>
          <target state="translated">GIT_ALTERNATE_OBJECT_DIRECTORIES</target>
        </trans-unit>
        <trans-unit id="964a2aa0953b5ffb1cfcd8b66bb3d22332570f05" translate="yes" xml:space="preserve">
          <source>GIT_AUTHOR_IDENT</source>
          <target state="translated">GIT_AUTHOR_IDENT</target>
        </trans-unit>
        <trans-unit id="725c6b7276951cf72d0731356407b6a84b3e59ef" translate="yes" xml:space="preserve">
          <source>GIT_COMMITTER_IDENT</source>
          <target state="translated">GIT_COMMITTER_IDENT</target>
        </trans-unit>
        <trans-unit id="3869ed3f7a51f55040f7a430ffe9ba97f98e246e" translate="yes" xml:space="preserve">
          <source>GIT_CONFIG</source>
          <target state="translated">GIT_CONFIG</target>
        </trans-unit>
        <trans-unit id="a5d490c74fb40af786be750b380476b10d1e4b69" translate="yes" xml:space="preserve">
          <source>GIT_CONFIG_NOSYSTEM</source>
          <target state="translated">GIT_CONFIG_NOSYSTEM</target>
        </trans-unit>
        <trans-unit id="01c412ca4d08642575a66ac381c4483c043b0ee1" translate="yes" xml:space="preserve">
          <source>GIT_CVSSERVER_BASE_PATH takes the place of the argument to --base-path.</source>
          <target state="translated">GIT_CVSSERVER_BASE_PATH는 인수를 --base-path로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="4f0780cd85f15ce5f825b343d1c06abf4cfc9741" translate="yes" xml:space="preserve">
          <source>GIT_CVSSERVER_ROOT specifies a single-directory whitelist. The repository must still be configured to allow access through git-cvsserver, as described above.</source>
          <target state="translated">GIT_CVSSERVER_ROOT는 단일 디렉토리 화이트리스트를 지정합니다. 위에서 설명한대로 저장소는 여전히 git-cvsserver를 통한 액세스를 허용하도록 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4ad19a85aef9ab4dcb6f62d95b8acf07e4c4828f" translate="yes" xml:space="preserve">
          <source>GIT_EDITOR</source>
          <target state="translated">GIT_EDITOR</target>
        </trans-unit>
        <trans-unit id="c8b3461d27dba4e8c6ce0c25c772c18d60c891a3" translate="yes" xml:space="preserve">
          <source>GIT_EXT_SERVICE</source>
          <target state="translated">GIT_EXT_SERVICE</target>
        </trans-unit>
        <trans-unit id="f4a08871056eea1076c323923e7cd2cd5fd6c0a8" translate="yes" xml:space="preserve">
          <source>GIT_EXT_SERVICE_NOPREFIX</source>
          <target state="translated">GIT_EXT_SERVICE_NOPREFIX</target>
        </trans-unit>
        <trans-unit id="08b684f4da6721d3a2c8e7b518324c7c98994b4e" translate="yes" xml:space="preserve">
          <source>GIT_INDEX_FILE</source>
          <target state="translated">GIT_INDEX_FILE</target>
        </trans-unit>
        <trans-unit id="cf57e9b3a04f2696e64705102232bab489ed97a5" translate="yes" xml:space="preserve">
          <source>GIT_OBJECT_DIRECTORY</source>
          <target state="translated">GIT_OBJECT_DIRECTORY</target>
        </trans-unit>
        <trans-unit id="924d60649d04fe751450b8bd3f1fc4a48bf559cb" translate="yes" xml:space="preserve">
          <source>GIT_PAGER</source>
          <target state="translated">GIT_PAGER</target>
        </trans-unit>
        <trans-unit id="ef2d6ed7bd1e2bfa87dc927172ada3fd1bdae6d2" translate="yes" xml:space="preserve">
          <source>GIT_TRANSLOOP_DEBUG</source>
          <target state="translated">GIT_TRANSLOOP_DEBUG</target>
        </trans-unit>
        <trans-unit id="a16f454460c35cd8704027fca6876a6a8646b0f2" translate="yes" xml:space="preserve">
          <source>GMail</source>
          <target state="translated">GMail</target>
        </trans-unit>
        <trans-unit id="cda466cee33ea6d923c0d1a6805da6ace37ac3f0" translate="yes" xml:space="preserve">
          <source>GMail does not have any way to turn off line wrapping in the web interface, so it will mangle any emails that you send. You can however use &quot;git send-email&quot; and send your patches through the GMail SMTP server, or use any IMAP email client to connect to the google IMAP server and forward the emails through that.</source>
          <target state="translated">Gmail은 웹 인터페이스에서 줄 바꿈 기능을 해제 할 수있는 방법이 없으므로 보낸 이메일을 엉망으로 만듭니다. 그러나 &quot;git send-email&quot;을 사용하고 GMail SMTP 서버를 통해 패치를 보내거나 IMAP 이메일 클라이언트를 사용하여 Google IMAP 서버에 연결하고이를 통해 이메일을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31f314da9a863256952d9852bb7b935e9c829e75" translate="yes" xml:space="preserve">
          <source>GPG sign pushes.</source>
          <target state="translated">GPG 표시가 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="d2cc3c3070810078ed6b670e4bd5c8639504233f" translate="yes" xml:space="preserve">
          <source>GPG-sign commits. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space.</source>
          <target state="translated">GPG 서명 커밋. &lt;code&gt;keyid&lt;/code&gt; 인수는 커미터 ID를 기본값은 선택 사항이며; 지정된 경우 공백없이 옵션을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="280cb8af503fd81af0776da1e5da5b505a515ac5" translate="yes" xml:space="preserve">
          <source>GPG-sign the push request to update refs on the receiving side, to allow it to be checked by the hooks and/or be logged. If &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;--no-signed&lt;/code&gt;, no signing will be attempted. If &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;--signed&lt;/code&gt;, the push will fail if the server does not support signed pushes. If set to &lt;code&gt;if-asked&lt;/code&gt;, sign if and only if the server supports signed pushes. The push will also fail if the actual call to &lt;code&gt;gpg --sign&lt;/code&gt; fails. See &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; for the details on the receiving end.</source>
          <target state="translated">푸시 요청에 GPG 서명을하여 수신 측의 참조를 업데이트하여 후크로 확인하거나 기록 할 수 있도록합니다. 경우 &lt;code&gt;false&lt;/code&gt; 또는이 &lt;code&gt;--no-signed&lt;/code&gt; , 어떤 서명은 시도되지 않습니다. 경우 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;--signed&lt;/code&gt; 서버가 서명 푸시를 지원하지 않는 경우, 푸시가 실패합니다. &lt;code&gt;if-asked&lt;/code&gt; 로 설정 되면 서버가 서명 된 푸시를 지원하는 경우에만 서명하십시오. &lt;code&gt;gpg --sign&lt;/code&gt; 에 대한 실제 호출이 실패하면 푸시도 실패 합니다. 수신단에 대한 자세한 내용은 &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="359179ddafe5ac57f233ce54be02401d37d2bd8b" translate="yes" xml:space="preserve">
          <source>GPG-sign the resulting merge commit. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space.</source>
          <target state="translated">결과 병합 커밋에 GPG 서명 &lt;code&gt;keyid&lt;/code&gt; 인수는 커미터 ID를 기본값은 선택 사항이며; 지정된 경우 공백없이 옵션을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="524cceb20916aff43a2680247362fb603a1a49c8" translate="yes" xml:space="preserve">
          <source>Garbage collect all unreferenced objects with &lt;code&gt;git gc --prune=now&lt;/code&gt; (or if your git-gc is not new enough to support arguments to &lt;code&gt;--prune&lt;/code&gt;, use &lt;code&gt;git repack -ad; git prune&lt;/code&gt; instead).</source>
          <target state="translated">가비지는 &lt;code&gt;git gc --prune=now&lt;/code&gt; 로 참조되지 않은 모든 객체를 수집합니다 (또는 git-gc가 &lt;code&gt;--prune&lt;/code&gt; 에 대한 인수를 지원하기에 충분하지 않은 새로운 경우에는 대신 &lt;code&gt;git repack -ad; git prune&lt;/code&gt; 사용하십시오).</target>
        </trans-unit>
        <trans-unit id="5bcb5f8aaf1a9e559046fd7b5b3d79bbe4d3f426" translate="yes" xml:space="preserve">
          <source>General options</source>
          <target state="translated">일반 옵션</target>
        </trans-unit>
        <trans-unit id="a5879c5c764017ca2130842dc888dcc88c04c99e" translate="yes" xml:space="preserve">
          <source>General variables</source>
          <target state="translated">일반 변수</target>
        </trans-unit>
        <trans-unit id="f8e6a94549428bad778124c3c140042198abcb13" translate="yes" xml:space="preserve">
          <source>Generally this mode is used as an administrative interface to allow users to list repositories they have access to, create, delete, or rename repositories, or change repository descriptions and permissions.</source>
          <target state="translated">일반적으로이 모드는 사용자가 저장소에 액세스하거나 저장소를 작성, 삭제 또는 이름을 바꾸거나 저장소 설명 및 권한을 변경할 수있는 관리 인터페이스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5338e8546078668a151a9dabd932d38a31f12f5b" translate="yes" xml:space="preserve">
          <source>Generally, &lt;code&gt;git p4 clone&lt;/code&gt; is used to create a new Git directory from an existing p4 repository:</source>
          <target state="translated">일반적으로 &lt;code&gt;git p4 clone&lt;/code&gt; 은 기존 p4 저장소에서 새 Git 디렉토리를 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ad37ee86e2b3d890455e76bc1e7e0fc45d3460de" translate="yes" xml:space="preserve">
          <source>Generally, all Git operations work on the index file. Some operations work &lt;strong&gt;purely&lt;/strong&gt; on the index file (showing the current state of the index), but most operations move data between the index file and either the database or the working directory. Thus there are four main combinations:</source>
          <target state="translated">일반적으로 모든 Git 작업은 인덱스 파일에서 작동합니다. 일부 작업 은 인덱스 파일 &lt;strong&gt;에서만&lt;/strong&gt; 작동 하지만 (인덱스의 현재 상태 표시) 대부분의 작업은 인덱스 파일과 데이터베이스 또는 작업 디렉토리간에 데이터를 이동합니다. 따라서 네 가지 주요 조합이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c30116e53a947e31daeae056572933416099fbe0" translate="yes" xml:space="preserve">
          <source>Generally, dangling objects aren&amp;rsquo;t anything to worry about. They can even be very useful: if you screw something up, the dangling objects can be how you recover your old tree (say, you did a rebase, and realized that you really didn&amp;rsquo;t want to&amp;mdash;​you can look at what dangling objects you have, and decide to reset your head to some old dangling state).</source>
          <target state="translated">일반적으로 매달린 객체는 걱정할 것이 없습니다. 그것들은 매우 유용 할 수도 있습니다. 무언가를 망쳐 놓으면 매달린 물건이 오래된 나무를 어떻게 복구 할 수 있는지를 알 수 있습니다 (예를 들어, 리베이스를하고 실제로 원치 않는다는 것을 깨달았습니다. 당신이 가지고있는 물건을 가지고 머리를 오래된 매달려있는 상태로 재설정하기로 결정하십시오).</target>
        </trans-unit>
        <trans-unit id="aefb0f39d3bd01ba3e438537ce5e3b6f3d075591" translate="yes" xml:space="preserve">
          <source>Generate a &lt;code&gt;$GIT_DIR/cvs-revisions&lt;/code&gt; file containing a mapping from CVS revision numbers to newly-created Git commit IDs. The generated file will contain one line for each (filename, revision) pair imported; each line will look like</source>
          <target state="translated">CVS 개정 번호에서 새로 작성된 Git 커밋 ID 로의 맵핑이 포함 된 &lt;code&gt;$GIT_DIR/cvs-revisions&lt;/code&gt; 파일을 생성하십시오. 생성 된 파일에는 가져온 각 (파일 이름, 개정) 쌍마다 한 줄이 포함됩니다. 각 줄은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="d956a0b3c8358372085439a04d4b2593dd2bec54" translate="yes" xml:space="preserve">
          <source>Generate a credential description based on the context.</source>
          <target state="translated">컨텍스트를 기반으로 자격 증명 설명을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="8b4e72c7495787832a335e23db7d41cdc955de4e" translate="yes" xml:space="preserve">
          <source>Generate a diff using the &quot;anchored diff&quot; algorithm.</source>
          <target state="translated">&quot;고정 된 차이&quot;알고리즘을 사용하여 차이를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="c65b3bd43c187f9009fd8be60c354464048bfb2c" translate="yes" xml:space="preserve">
          <source>Generate a diff using the &quot;histogram diff&quot; algorithm.</source>
          <target state="translated">&quot;히스토그램 차이&quot;알고리즘을 사용하여 차이를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="5a810f6cb04f85c060e73d8366053dc83cbde1b6" translate="yes" xml:space="preserve">
          <source>Generate a diff using the &quot;patience diff&quot; algorithm.</source>
          <target state="translated">&quot;환자 차이&quot;알고리즘을 사용하여 차이를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="f50a5c7af33db239a645bbb0a36b9c949e7a8bfe" translate="yes" xml:space="preserve">
          <source>Generate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt;. The width of the filename part can be limited by giving another width &lt;code&gt;&amp;lt;name-width&amp;gt;&lt;/code&gt; after a comma. The width of the graph part can be limited by using &lt;code&gt;--stat-graph-width=&amp;lt;width&amp;gt;&lt;/code&gt; (affects all commands generating a stat graph) or by setting &lt;code&gt;diff.statGraphWidth=&amp;lt;width&amp;gt;&lt;/code&gt; (does not affect &lt;code&gt;git format-patch&lt;/code&gt;). By giving a third parameter &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt;, you can limit the output to the first &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; lines, followed by &lt;code&gt;...&lt;/code&gt; if there are more.</source>
          <target state="translated">diffstat를 생성하십시오. 기본적으로 필요한만큼의 공간이 파일 이름 부분에 사용되고 나머지는 그래프 부분에 사용됩니다. 최대 너비는 기본적으로 터미널 너비 또는 터미널에 연결되지 않은 경우 80 열이며 &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; 로 재정의 할 수 있습니다 . 쉼표 뒤에 다른 너비 &lt;code&gt;&amp;lt;name-width&amp;gt;&lt;/code&gt; 를 지정 하여 파일 이름 부분의 너비를 제한 할 수 있습니다 . 그래프 부분의 폭을 사용하여 제한 될 수 &lt;code&gt;--stat-graph-width=&amp;lt;width&amp;gt;&lt;/code&gt; (a 통계의 그래프를 생성하는 모든 명령에 영향을 미친다) 또는 설정 &lt;code&gt;diff.statGraphWidth=&amp;lt;width&amp;gt;&lt;/code&gt; (영향을주지 않는 &lt;code&gt;git format-patch&lt;/code&gt; ) . 세 번째 매개 변수 &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; 를 지정하면 출력을 첫 번째 &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; 행으로 제한 할 수 있습니다 .뒤에 &lt;code&gt;...&lt;/code&gt; 더 있다면</target>
        </trans-unit>
        <trans-unit id="9a58997012274b692734905439c472fc9bf49724" translate="yes" xml:space="preserve">
          <source>Generate a request asking your upstream project to pull changes into their tree. The request, printed to the standard output, begins with the branch description, summarizes the changes and indicates from where they can be pulled.</source>
          <target state="translated">업스트림 프로젝트에 변경 사항을 트리로 가져 오도록 요청하는 요청을 생성하십시오. 표준 출력으로 인쇄 된 요청은 브랜치 설명으로 시작하여 변경 사항을 요약하고 가져올 수있는 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e43be14252a09239d3a95e69575c334d9dcee155" translate="yes" xml:space="preserve">
          <source>Generate diffs with &amp;lt;n&amp;gt; lines of context instead of the default of 3. This value is overridden by the -U option.</source>
          <target state="translated">기본값 3 대신 &amp;lt;n&amp;gt; 행의 컨텍스트를 사용하여 diff를 생성하십시오.이 값은 -U 옵션으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="0c3fb6d76074c691f7bc9656642039721293ad30" translate="yes" xml:space="preserve">
          <source>Generate diffs with &amp;lt;n&amp;gt; lines of context instead of the usual three. Implies &lt;code&gt;--patch&lt;/code&gt;.</source>
          <target state="translated">일반적인 세 ​​줄 대신 &amp;lt;n&amp;gt; 줄의 내용으로 diff를 생성하십시오. &lt;code&gt;--patch&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="5423824f37bf5ebdc5aa787498e564ca92935ec4" translate="yes" xml:space="preserve">
          <source>Generate diffs with &amp;lt;n&amp;gt; lines of context instead of the usual three. Implies &lt;code&gt;--patch&lt;/code&gt;. Implies &lt;code&gt;-p&lt;/code&gt;.</source>
          <target state="translated">일반적인 세 ​​줄 대신 &amp;lt;n&amp;gt; 줄의 내용으로 diff를 생성하십시오. &lt;code&gt;--patch&lt;/code&gt; 를 의미 합니다. &lt;code&gt;-p&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="c5ed7cc57b573e7d3d35a890e87a64e8016055b8" translate="yes" xml:space="preserve">
          <source>Generate patch (see section on generating patches).</source>
          <target state="translated">패치를 생성하십시오 (패치 생성 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="468bd18b2fd829a488878e7cd9b8b00c33a3bf5f" translate="yes" xml:space="preserve">
          <source>Generate patch (see section on generating patches). This is the default.</source>
          <target state="translated">패치를 생성하십시오 (패치 생성 섹션 참조). 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="0305bd83d4a1ca283e78c45f30f1d98f9bb246bc" translate="yes" xml:space="preserve">
          <source>Generate plain patches without any diffstats.</source>
          <target state="translated">diffstats없이 일반 패치를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="0cceb279f32e8c4384bb0e8684243cdf862ab779" translate="yes" xml:space="preserve">
          <source>Generate the diff in raw format.</source>
          <target state="translated">원시 형식으로 diff를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="c49c41c6395d0de919c07a57d58570e04e74713d" translate="yes" xml:space="preserve">
          <source>Generate the diff in raw format. This is the default.</source>
          <target state="translated">원시 형식으로 diff를 생성하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="88ef8fc7ea6872f6140c434b84c60ed4bc477b71" translate="yes" xml:space="preserve">
          <source>Generates a summary of pending changes</source>
          <target state="translated">보류중인 변경 사항의 요약을 생성합니다</target>
        </trans-unit>
        <trans-unit id="b812709580c6b66bf19a88239714db45c6f547d3" translate="yes" xml:space="preserve">
          <source>Generates an RSS (or Atom) feed of changes to repository.</source>
          <target state="translated">저장소에 대한 변경 사항의 RSS (또는 Atom) 피드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6d3ce11672e300b3630956d5357a3f156d393821" translate="yes" xml:space="preserve">
          <source>Generating RSS and Atom feeds of commits, for any branch. The feeds are auto-discoverable in modern web browsers.</source>
          <target state="translated">모든 분기에 대한 커밋의 RSS 및 Atom 피드 생성 피드는 최신 웹 브라우저에서 자동 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39bd3cb8cae2c62c26836b759476b4dce92db62c" translate="yes" xml:space="preserve">
          <source>Generating diff text</source>
          <target state="translated">diff 텍스트 생성</target>
        </trans-unit>
        <trans-unit id="6e83f1be8cebf28e1aa935d46feefe8c9c9b6bff" translate="yes" xml:space="preserve">
          <source>Generating diffs</source>
          <target state="translated">차이 생성</target>
        </trans-unit>
        <trans-unit id="d70a52c9081d71ce670fc7b47fc3bc012193cc1a" translate="yes" xml:space="preserve">
          <source>Generating patch text with -p</source>
          <target state="translated">-p를 사용하여 패치 텍스트 생성</target>
        </trans-unit>
        <trans-unit id="6aeb48d435992fb6dfeaeb57975b9744c65abe0f" translate="yes" xml:space="preserve">
          <source>Generating projects list using gitweb</source>
          <target state="translated">gitweb을 사용하여 프로젝트 목록 생성</target>
        </trans-unit>
        <trans-unit id="77a43161f16023a4081e441eda8d16415635830a" translate="yes" xml:space="preserve">
          <source>Generic &amp;lt;revision range&amp;gt; expression (see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;) means the commits in the specified range.</source>
          <target state="translated">일반 &amp;lt;개정 범위&amp;gt; 표현식 ( &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]의&lt;/a&gt; &quot; SPECIFYING REVISIONS&quot;섹션 참조 )은 지정된 범위의 커밋을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6a8b0f1bc43a4668545c1d049581bdef7899704d" translate="yes" xml:space="preserve">
          <source>Get and set repository or global options</source>
          <target state="translated">저장소 또는 글로벌 옵션 가져 오기 및 설정</target>
        </trans-unit>
        <trans-unit id="e36c9f7c3a3791a600900bd999a01e746ced35ba" translate="yes" xml:space="preserve">
          <source>Get the value for a given key (optionally filtered by a regex matching the value). Returns error code 1 if the key was not found and the last value if multiple key values were found.</source>
          <target state="translated">주어진 키의 값을 가져옵니다 (선택적으로 값과 일치하는 정규 표현식으로 필터링). 키를 찾을 수 없으면 오류 코드 1을 반환하고 여러 키 값을 찾은 경우 마지막 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ed0d09699cf6099e40ea031af476399c03ae869" translate="yes" xml:space="preserve">
          <source>Gets the Subversion property given as the first argument, for a file. A specific revision can be specified with -r/--revision.</source>
          <target state="translated">파일의 첫 번째 인수로 지정된 Subversion 속성을 가져옵니다. -r /-revision을 사용하여 특정 개정을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="516c94a58b7d13bbfd33d93293ff07c0a7a0cbf5" translate="yes" xml:space="preserve">
          <source>Getting and Creating Projects</source>
          <target state="translated">프로젝트 가져 오기 및 생성</target>
        </trans-unit>
        <trans-unit id="970eb65fbea28c10c8dd662819611907796540db" translate="yes" xml:space="preserve">
          <source>Getting changes out is easy:</source>
          <target state="translated">변경 사항을 쉽게 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3ce20bb7af9a1868b401164829dfe90efbb8e6d" translate="yes" xml:space="preserve">
          <source>Getting conflict-resolution help during a merge</source>
          <target state="translated">병합 중 충돌 해결 도움말 얻기</target>
        </trans-unit>
        <trans-unit id="060f712c74598ce01e86d56802d9344d8ed68bb7" translate="yes" xml:space="preserve">
          <source>Getting help</source>
          <target state="translated">도움을 받다</target>
        </trans-unit>
        <trans-unit id="c459e54c0b44554b9b817457994c7c37528258a0" translate="yes" xml:space="preserve">
          <source>Getting updates with git pull</source>
          <target state="translated">자식 풀로 업데이트 받기</target>
        </trans-unit>
        <trans-unit id="5819778898df55e3a762f0c5728b457970d72cae" translate="yes" xml:space="preserve">
          <source>Git</source>
          <target state="translated">Git</target>
        </trans-unit>
        <trans-unit id="d732d81f4de6cbbc7c08999550694240dc675ed1" translate="yes" xml:space="preserve">
          <source>Git Commits</source>
          <target state="translated">힘내 커밋</target>
        </trans-unit>
        <trans-unit id="d0aaf3f6b8eb7d9c0d9e9cfe8351718f5fff142e" translate="yes" xml:space="preserve">
          <source>Git Diffs</source>
          <target state="translated">힘내</target>
        </trans-unit>
        <trans-unit id="2f8f97d0e40130f1bd878938daff8ad22d7dc440" translate="yes" xml:space="preserve">
          <source>Git Native</source>
          <target state="translated">힘내 네이티브</target>
        </trans-unit>
        <trans-unit id="d6e98b90bf56079b25bb9356fe9439f3123affff" translate="yes" xml:space="preserve">
          <source>Git Thread Messages</source>
          <target state="translated">힘내 스레드 메시지</target>
        </trans-unit>
        <trans-unit id="cae0e86da292416c6a36a0e4ce238566c9d247c3" translate="yes" xml:space="preserve">
          <source>Git Transport</source>
          <target state="translated">힘내 교통</target>
        </trans-unit>
        <trans-unit id="a7c39055264c29496e9ec925896bc3e3ec696cb4" translate="yes" xml:space="preserve">
          <source>Git allows you to specify scripts called &quot;hooks&quot; to be run at certain points. You can use these, for example, to send all commits to the shared repository to a mailing list. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">힘내를 사용하면 특정 지점에서 실행할 &quot;후크&quot;라는 스크립트를 지정할 수 있습니다. 예를 들어,이를 사용하여 공유 저장소에 대한 모든 커밋을 메일 목록으로 보낼 수 있습니다. &lt;a href=&quot;githooks&quot;&gt;githooks [5]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d26d4c60652b93a42ab638ebb72c8ba6beaba72" translate="yes" xml:space="preserve">
          <source>Git also keeps a pristine copy of Alice&amp;rsquo;s master branch under the name &quot;origin/master&quot;:</source>
          <target state="translated">또한 Git은 Alice의 원래 브랜치 사본을 &quot;origin / master&quot;라는 이름으로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="1738762c7d776a74999cdf10e57649ca4dc7876a" translate="yes" xml:space="preserve">
          <source>Git also provides a tool called &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; (am stands for &quot;apply mailbox&quot;), for importing such an emailed series of patches. Just save all of the patch-containing messages, in order, into a single mailbox file, say &lt;code&gt;patches.mbox&lt;/code&gt;, then run</source>
          <target state="translated">Git은 또한 이메일로 전송 된 일련의 패치를 가져 오기 위해 &lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt; (am은 &quot;사서함 적용&quot;을 나타냄) 이라는 도구를 제공합니다 . 패치가 포함 된 모든 메시지를 순서대로 단일 메일 함 파일 (예 : &lt;code&gt;patches.mbox&lt;/code&gt; )에 저장 한 후 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="1dc53eccf42e15dc7948bd5d68aac36dca57063c" translate="yes" xml:space="preserve">
          <source>Git archive</source>
          <target state="translated">힘내 아카이브</target>
        </trans-unit>
        <trans-unit id="54c5b60d3b067a46392b8d1f7e7e747f00fb6589" translate="yes" xml:space="preserve">
          <source>Git can also be used in a CVS-like mode, with a central repository that various users push changes to; see &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">Git은 다양한 사용자가 변경 사항을 푸시하는 중앙 저장소와 함께 CVS와 유사한 모드에서 사용할 수 있습니다. 참조 &lt;a href=&quot;git-push&quot;&gt;자식 푸시 [1]&lt;/a&gt; 과 &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs 마이그레이션 [7]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12dda0ab622d98c0bb3ecd2dcca2f78143c72090" translate="yes" xml:space="preserve">
          <source>Git can detect errors when it reads an object, by checking that the object&amp;rsquo;s name is still the SHA-1 hash of its contents.</source>
          <target state="translated">Git은 객체의 이름이 여전히 내용의 SHA-1 해시인지 확인하여 객체를 읽을 때 오류를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e99355d5c834d0a7e793f2a903c686c73ccc0248" translate="yes" xml:space="preserve">
          <source>Git can help you perform a three-way merge, which can in turn be used for a many-way merge by repeating the merge procedure several times. The usual situation is that you only do one three-way merge (reconciling two lines of history) and commit the result, but if you like to, you can merge several branches in one go.</source>
          <target state="translated">Git은 3 방향 병합을 수행하는 데 도움이되며, 병합 절차를 여러 번 반복하여 다 방향 병합에 사용할 수 있습니다. 일반적인 상황은 하나의 3 방향 병합 (두 줄의 기록 조정) 만 수행하고 결과를 커밋하지만 원하는 경우 여러 분기를 한 번에 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9711e4cc3e77224217a8eadfcd9bddb77a1a6b3f" translate="yes" xml:space="preserve">
          <source>Git can quickly determine whether two objects are identical or not, just by comparing names.</source>
          <target state="translated">힘내 이름을 비교하여 두 개체가 동일한 지 여부를 신속하게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66761dbf024e7710e093b6a26bb079c9a462b99d" translate="yes" xml:space="preserve">
          <source>Git comes with a &quot;curl&quot; family of remote helpers, that handle various transport protocols, such as &lt;code&gt;git-remote-http&lt;/code&gt;, &lt;code&gt;git-remote-https&lt;/code&gt;, &lt;code&gt;git-remote-ftp&lt;/code&gt; and &lt;code&gt;git-remote-ftps&lt;/code&gt;. They implement the capabilities &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;option&lt;/code&gt;, and &lt;code&gt;push&lt;/code&gt;.</source>
          <target state="translated">Git에는 &lt;code&gt;git-remote-http&lt;/code&gt; , &lt;code&gt;git-remote-https&lt;/code&gt; , &lt;code&gt;git-remote-ftp&lt;/code&gt; 및 &lt;code&gt;git-remote-ftps&lt;/code&gt; 와 같은 다양한 전송 프로토콜을 처리하는 &quot;curl&quot;원격 헬퍼 제품군이 제공됩니다 . 그것들은 &lt;code&gt;fetch&lt;/code&gt; , &lt;code&gt;option&lt;/code&gt; 및 &lt;code&gt;push&lt;/code&gt; 기능을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="590c7b2e50468cb97c1bacdf4c22b05f53204bcc" translate="yes" xml:space="preserve">
          <source>Git commands</source>
          <target state="translated">힘내 명령</target>
        </trans-unit>
        <trans-unit id="748a4c7cdb8da160e4137b5f163f8f4f719642f9" translate="yes" xml:space="preserve">
          <source>Git concepts</source>
          <target state="translated">힘내 개념</target>
        </trans-unit>
        <trans-unit id="23daed08ae51790de19c33ed17896e5944bcf442" translate="yes" xml:space="preserve">
          <source>Git considers each credential to have a context defined by a URL. This context is used to look up context-specific configuration, and is passed to any helpers, which may use it as an index into secure storage.</source>
          <target state="translated">Git은 각 자격 증명이 URL로 정의 된 컨텍스트를 갖는 것으로 간주합니다. 이 컨텍스트는 컨텍스트 별 구성을 조회하는 데 사용되며 보안 저장소의 인덱스로 사용할 수있는 모든 도우미에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="50d371d1d26e20ed2106ca5d2c77efab159f6b5e" translate="yes" xml:space="preserve">
          <source>Git data exporter</source>
          <target state="translated">힘내 데이터 내보내기</target>
        </trans-unit>
        <trans-unit id="df14b19afe5ac9b190d2e62a9bb072306d0becda" translate="yes" xml:space="preserve">
          <source>Git did not try to send the ref at all, typically because it is not a fast-forward and you did not force the update.</source>
          <target state="translated">Git은 심판을 전혀 보내지 않았다. 일반적으로 빨리 감기가 아니기 때문에 업데이트를 강요하지 않았기 때문이다.</target>
        </trans-unit>
        <trans-unit id="2dac5af4573e16931bda9b37c2f40888a8b49b4e" translate="yes" xml:space="preserve">
          <source>Git diff features. By performing only the transformation step yourself, you can still utilize many of Git&amp;rsquo;s diff features, including colorization, word-diff, and combined diffs for merges.</source>
          <target state="translated">힘내 diff 기능. 변형 단계 만 직접 수행하면 색상 화, 단어 차이 및 병합을위한 결합 차이를 비롯한 여러 Git의 차이 기능을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e4742213b12ec1297779eac50efdab191f84da4" translate="yes" xml:space="preserve">
          <source>Git differs from CVS in that every working tree contains a repository with a full copy of the project history, and no repository is inherently more important than any other. However, you can emulate the CVS model by designating a single shared repository which people can synchronize with; this document explains how to do that.</source>
          <target state="translated">Git은 모든 작업 트리에 전체 프로젝트 히스토리 사본이있는 저장소를 포함하고 다른 저장소보다 본질적으로 더 중요한 저장소는 없다는 점에서 CVS와 다릅니다. 그러나 사람들이 동기화 할 수있는 단일 공유 저장소를 지정하여 CVS 모델을 에뮬레이트 할 수 있습니다. 이 문서는이를 수행하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="52ba75f7d53c0098d95000c61cda5fd5ea6917af" translate="yes" xml:space="preserve">
          <source>Git directory name</source>
          <target state="translated">힘내 디렉토리 이름</target>
        </trans-unit>
        <trans-unit id="5d9fa4d20745d4b5b2bcfd60f9d543f73fbbd4e6" translate="yes" xml:space="preserve">
          <source>Git directory name, where all characters except for alphanumeric ones, &lt;code&gt;.&lt;/code&gt;, and &lt;code&gt;-&lt;/code&gt; are replaced with &lt;code&gt;_&lt;/code&gt; (this should make it easier to use the directory name in a filename if wanted)</source>
          <target state="translated">영숫자 문자를 제외한 모든 문자가있는 Git 디렉토리 이름 &lt;code&gt;.&lt;/code&gt; , 및 &lt;code&gt;-&lt;/code&gt; 는 &lt;code&gt;_&lt;/code&gt; 로 대체됩니다 (원하는 경우 파일 이름에서 디렉토리 이름을 사용하기가 더 쉬워야합니다)</target>
        </trans-unit>
        <trans-unit id="9cf813a3cd69ecbe5e00c63d983206328e14b759" translate="yes" xml:space="preserve">
          <source>Git does not allow partial checkouts, so duplicating this approach in Git would force developers to keep a local copy of modules they are not interested in touching. Commits in an enormous checkout would be slower than you&amp;rsquo;d expect as Git would have to scan every directory for changes. If modules have a lot of local history, clones would take forever.</source>
          <target state="translated">Git은 부분 체크 아웃을 허용하지 않으므로 Git에서이 접근 방식을 복제하면 개발자가 관심이없는 모듈의 로컬 사본을 유지해야합니다. Git이 모든 디렉토리에서 변경 사항을 검색해야하기 때문에 막대한 체크 아웃시 커밋이 예상보다 느려집니다. 모듈에 로컬 히스토리가 많으면 복제본이 영원히 걸립니다.</target>
        </trans-unit>
        <trans-unit id="8b2d9679cf8575fc6c4cfb84434fb5d8180eb7ab" translate="yes" xml:space="preserve">
          <source>Git explained</source>
          <target state="translated">힘내 설명</target>
        </trans-unit>
        <trans-unit id="0db9018815b17c54cf84524352784d68bf492b44" translate="yes" xml:space="preserve">
          <source>Git glossary</source>
          <target state="translated">Git 용어집</target>
        </trans-unit>
        <trans-unit id="11c6d04869311aae599c74c45ab29a30fd9dc2d3" translate="yes" xml:space="preserve">
          <source>Git has a default disposition of keeping data unless it&amp;rsquo;s explicitly thrown away; this extends to holding onto local references to branches on remotes that have themselves deleted those branches.</source>
          <target state="translated">Git은 명시 적으로 버리지 않는 한 데이터를 유지하는 기본 처리 방식을 가지고 있습니다. 이것은 자체적으로 해당 분기를 삭제 한 리모컨의 분기에 대한 로컬 참조를 유지하는 것으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="c792c246c2740fcc85816c7742979ab9c07c5067" translate="yes" xml:space="preserve">
          <source>Git has an internal interface for storing and retrieving credentials from system-specific helpers, as well as prompting the user for usernames and passwords. The git-credential command exposes this interface to scripts which may want to retrieve, store, or prompt for credentials in the same manner as Git. The design of this scriptable interface models the internal C API; see credential.h for more background on the concepts.</source>
          <target state="translated">Git에는 시스템 별 도우미에서 자격 증명을 저장 및 검색하고 사용자 이름 및 암호를 묻는 메시지를 표시하는 내부 인터페이스가 있습니다. git-credential 명령은이 인터페이스를 Git과 같은 방식으로 자격 증명을 검색, 저장 또는 프롬프트 할 수있는 스크립트에 노출합니다. 이 스크립트 가능한 인터페이스의 디자인은 내부 C API를 모델링합니다. 개념에 대한 자세한 배경은 credential.h를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b5c69a965c60312962f3f44179acdc3a60b40e17" translate="yes" xml:space="preserve">
          <source>Git has no way of knowing that the new head is an updated version of the old head; it treats this situation exactly the same as it would if two developers had independently done the work on the old and new heads in parallel. At this point, if someone attempts to merge the new head in to their branch, Git will attempt to merge together the two (old and new) lines of development, instead of trying to replace the old by the new. The results are likely to be unexpected.</source>
          <target state="translated">Git은 새로운 헤드가 기존 헤드의 업데이트 된 버전임을 알 수있는 방법이 없습니다. 두 개발자가 독립적으로 기존 헤드와 새 헤드에서 동시에 작업을 수행 한 경우와 동일하게이 상황을 처리합니다. 이 시점에서 누군가가 새로운 헤드를 자신의 브랜치에 병합하려고 시도하면 Git은 기존 헤드를 새로운 것으로 교체하지 않고 두 개의 (구형과 새로운) 개발 라인을 통합하려고 시도합니다. 결과는 예상치 못한 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="06c2297147a37b1c482365d9d8f31d8dedf40fc4" translate="yes" xml:space="preserve">
          <source>Git history is represented as a series of interrelated commits. We have already seen that the &lt;code&gt;git log&lt;/code&gt; command can list those commits. Note that first line of each git log entry also gives a name for the commit:</source>
          <target state="translated">힘내 히스토리는 일련의 상호 관련된 커밋으로 표시됩니다. 우리는 이미 &lt;code&gt;git log&lt;/code&gt; 명령이 그러한 커밋을 나열 할 수 있음을 보았습니다 . 각 git log 항목의 첫 번째 줄은 커밋의 이름도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3e99ade0692d549a8a950dd96317ceaffb9107bb" translate="yes" xml:space="preserve">
          <source>Git imposes the following rules on how references are named:</source>
          <target state="translated">Git은 참조의 이름을 지정하는 방법에 대해 다음 규칙을 부과합니다.</target>
        </trans-unit>
        <trans-unit id="a288f739ab4cf5d9993c702076fe0dc6fc3ee3ba" translate="yes" xml:space="preserve">
          <source>Git internal format</source>
          <target state="translated">힘내 내부 형식</target>
        </trans-unit>
        <trans-unit id="64a97e8eaa30379dfa62ee80bea9820c4fe8a22e" translate="yes" xml:space="preserve">
          <source>Git is a Distributed Version Control system (DVCS) created by Linus Torvalds and maintained by Junio Hamano.</source>
          <target state="translated">Git은 Linus Torvalds가 생성하고 Junio ​​Hamano가 유지 관리하는 분산 버전 제어 시스템 (DVCS)입니다.</target>
        </trans-unit>
        <trans-unit id="f3967c7f5aeb4487a30c2b76c0330d8f45c7d45a" translate="yes" xml:space="preserve">
          <source>Git is a fast distributed revision control system.</source>
          <target state="translated">Git은 빠른 분산 개정 제어 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="39998d13fc7a27f9efbe60a086c013b3bd3030af" translate="yes" xml:space="preserve">
          <source>Git is a fast, scalable, distributed revision control system with an unusually rich command set that provides both high-level operations and full access to internals.</source>
          <target state="translated">Git은 매우 확장 가능한 분산 수정 제어 시스템으로, 고급 작업과 내부에 대한 모든 액세스를 제공하는 매우 풍부한 명령 세트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9fb5868e31358193ca8585301de5ca9891b34989" translate="yes" xml:space="preserve">
          <source>Git is best thought of as a tool for storing the history of a collection of files. It does this by storing compressed snapshots of the contents of a file hierarchy, together with &quot;commits&quot; which show the relationships between these snapshots.</source>
          <target state="translated">Git은 파일 모음의 히스토리를 저장하는 도구로 가장 잘 생각됩니다. 이 스냅 샷 간의 관계를 보여주는 &quot;커밋&quot;과 함께 파일 계층 구조 내용의 압축 된 스냅 샷을 저장하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="35ff36d5accbb4f2dda359fd3229598730d5aa08" translate="yes" xml:space="preserve">
          <source>Git is best thought of as a tool for storing the history of a collection of files. It stores the history as a compressed collection of interrelated snapshots of the project&amp;rsquo;s contents. In Git each such version is called a &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt;.</source>
          <target state="translated">Git은 파일 모음의 히스토리를 저장하는 도구로 가장 잘 생각됩니다. 히스토리를 프로젝트 컨텐츠의 상호 관련된 스냅 샷 모음으로 압축하여 저장합니다. Git에서는 이러한 각 버전을 &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="7a9590b40529c70c530e12c39759365698786125" translate="yes" xml:space="preserve">
          <source>Git is built on a small number of simple but powerful ideas. While it is possible to get things done without understanding them, you will find Git much more intuitive if you do.</source>
          <target state="translated">힘내는 간단하지만 강력한 아이디어를 기반으로합니다. 이해하지 않고 작업을 수행하는 것이 가능하지만 Git을 사용하면 훨씬 직관적입니다.</target>
        </trans-unit>
        <trans-unit id="acccb72bd7439cce396900f6956100688cfe6ddd" translate="yes" xml:space="preserve">
          <source>Git is to some extent character encoding agnostic.</source>
          <target state="translated">Git은 어느 정도까지는 문자 인코딩에 무관심하다.</target>
        </trans-unit>
        <trans-unit id="a87c04c678f1edcfea18d0a701f5da80659e7540" translate="yes" xml:space="preserve">
          <source>Git neither stops nor restarts the filter process in case the &quot;error&quot;/&quot;abort&quot; status is set. However, Git sets its exit code according to the &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; flag, mimicking the behavior of the &lt;code&gt;filter.&amp;lt;driver&amp;gt;.clean&lt;/code&gt; / &lt;code&gt;filter.&amp;lt;driver&amp;gt;.smudge&lt;/code&gt; mechanism.</source>
          <target state="translated">&quot;오류&quot;/ &quot;중단&quot;상태가 설정된 경우 Git은 필터 프로세스를 중지하거나 다시 시작하지 않습니다. 그러나 Git은 &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; 의 동작을 모방 한 filter. &amp;lt;driver&amp;gt; .quired 플래그 에 따라 종료 코드를 설정합니다 &lt;code&gt;filter.&amp;lt;driver&amp;gt;.clean&lt;/code&gt; / &lt;code&gt;filter.&amp;lt;driver&amp;gt;.smudge&lt;/code&gt; 메커니즘.</target>
        </trans-unit>
        <trans-unit id="bcbcedc091eff7502178afecdce9f3afdc72dc05" translate="yes" xml:space="preserve">
          <source>Git provides extremely flexible and fast tools for exploring the history of a project.</source>
          <target state="translated">Git은 프로젝트 히스토리를 탐색 할 수있는 매우 유연하고 빠른 도구를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="38200bd70c851718b2397208bade5f568860b37a" translate="yes" xml:space="preserve">
          <source>Git recognizes files encoded in ASCII or one of its supersets (e.g. UTF-8, ISO-8859-1, &amp;hellip;​) as text files. Files encoded in certain other encodings (e.g. UTF-16) are interpreted as binary and consequently built-in Git text processing tools (e.g. &lt;code&gt;git diff&lt;/code&gt;) as well as most Git web front ends do not visualize the contents of these files by default.</source>
          <target state="translated">Git은 ASCII 또는 그 슈퍼 세트 중 하나 (예 : UTF-8, ISO-8859-1,&amp;hellip;)로 인코딩 된 파일을 텍스트 파일로 인식합니다. 특정 다른 인코딩 (예 : UTF-16)으로 인코딩 된 파일은 이진으로 해석되므로 내장 Git 텍스트 처리 도구 (예 : &lt;code&gt;git diff&lt;/code&gt; )뿐만 아니라 대부분의 Git 웹 프런트 엔드는 기본적으로 이러한 파일의 내용을 시각화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db884716c8275e6cfa36ed29dbc5d360bba57d0e" translate="yes" xml:space="preserve">
          <source>Git relies on the proper configuration of this variable for your operating and file system. Modifying this value may result in unexpected behavior.</source>
          <target state="translated">Git은 운영 및 파일 시스템에 대해이 변수의 올바른 구성에 의존합니다. 이 값을 수정하면 예기치 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a66f7e50154ea192af5f4749135be70398075b72" translate="yes" xml:space="preserve">
          <source>Git repositories are normally totally self-sufficient and relocatable. Unlike CVS, for example, there is no separate notion of &quot;repository&quot; and &quot;working tree&quot;. A Git repository normally &lt;strong&gt;is&lt;/strong&gt; the working tree, with the local Git information hidden in the &lt;code&gt;.git&lt;/code&gt; subdirectory. There is nothing else. What you see is what you got.</source>
          <target state="translated">Git 리포지토리는 일반적으로 완전히 자급 자족하고 재배치 가능합니다. 예를 들어 CVS와 달리 &quot;리포지토리&quot;와 &quot;작업 트리&quot;라는 별도의 개념은 없습니다. 자식은 일반적으로 리포지토리 &lt;strong&gt;입니다&lt;/strong&gt; 에 숨겨진 지역 망할 놈의 정보를 작업 트리, &lt;code&gt;.git&lt;/code&gt; 디렉토리. 다른 것은 없습니다. 당신이 보는 것은 당신이 가진 것입니다.</target>
        </trans-unit>
        <trans-unit id="cf8c005d3f0e4d9e1ff9d1e8d46ef8fd98f0bbf4" translate="yes" xml:space="preserve">
          <source>Git repository format versions</source>
          <target state="translated">힘내 저장소 형식 버전</target>
        </trans-unit>
        <trans-unit id="cd868bd588534f7cc4b6680d57c0627b3503b53c" translate="yes" xml:space="preserve">
          <source>Git sends the remote helper a list of commands on standard input, one per line. The first command is always the &lt;code&gt;capabilities&lt;/code&gt; command, in response to which the remote helper must print a list of the capabilities it supports (see below) followed by a blank line. The response to the capabilities command determines what commands Git uses in the remainder of the command stream.</source>
          <target state="translated">Git은 원격 헬퍼에게 표준 입력에 대한 명령 목록을 한 줄에 하나씩 보냅니다. 첫 번째 명령은 항상 &lt;code&gt;capabilities&lt;/code&gt; 명령이며, 원격 도우미는 지원하는 기능 목록 (아래 참조)과 빈 줄을 인쇄해야합니다. Capabilities 명령에 대한 응답은 Git이 나머지 명령 스트림에서 사용하는 명령을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="49f2ae128519616ee7193d5988bcbce620249ed4" translate="yes" xml:space="preserve">
          <source>Git supports dividing the refs of a single repository into multiple namespaces, each of which has its own branches, tags, and HEAD. Git can expose each namespace as an independent repository to pull from and push to, while sharing the object store, and exposing all the refs to operations such as &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">Git은 단일 리포지토리의 참조를 여러 개의 네임 스페이스로 나누는 것을 지원하며 각 네임 스페이스에는 자체 분기, 태그 및 HEAD가 있습니다. Git은 객체 저장소를 공유하고 모든 참조를 &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt; 과 같은 작업에 노출시키면서 각 네임 스페이스를 독립적 인 저장소로 노출하여 푸시하고 푸시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da0d87f50d864c408fa4b395576786d97bb31ddd" translate="yes" xml:space="preserve">
          <source>Git supports ssh, git, http, and https protocols (in addition, ftp, and ftps can be used for fetching, but this is inefficient and deprecated; do not use it).</source>
          <target state="translated">Git은 ssh, git, http 및 https 프로토콜을 지원합니다 (또한 ftp 및 ftps는 페치에 사용될 수 있지만 비효율적이며 사용되지 않으므로 사용하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="2cde7635ac8cf69f2e210aa19a54d3042440cb25" translate="yes" xml:space="preserve">
          <source>Git tracks content not files</source>
          <target state="translated">Git은 파일이 아닌 컨텐츠를 추적</target>
        </trans-unit>
        <trans-unit id="d302527fd1d763cfe7e5d18396b3435236371be0" translate="yes" xml:space="preserve">
          <source>Git treats the pattern as a shell glob suitable for consumption by fnmatch(3) with the FNM_PATHNAME flag: wildcards in the pattern will not match a / in the pathname. For example, &quot;Documentation/*.html&quot; matches &quot;Documentation/git.html&quot; but not &quot;Documentation/ppc/ppc.html&quot; or &quot;tools/perf/Documentation/perf.html&quot;.</source>
          <target state="translated">Git은 FNM_PATHNAME 플래그를 사용하여 fnmatch (3)에서 소비하기에 적합한 쉘 글로브로 패턴을 처리합니다. 패턴의 와일드 카드는 경로 이름의 /와 일치하지 않습니다. 예를 들어, &quot;Documentation / *. html&quot;은 &quot;Documentation / git.html&quot;과 일치하지만 &quot;Documentation / ppc / ppc.html&quot;또는 &quot;tools / perf / Documentation / perf.html&quot;과는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e54cce67cf2641b15706179b6168b5a2d3b1bcd" translate="yes" xml:space="preserve">
          <source>Git urls</source>
          <target state="translated">힘내 URL</target>
        </trans-unit>
        <trans-unit id="751190188de5688aa514632f7b1c3310593ad2c7" translate="yes" xml:space="preserve">
          <source>Git users can broadly be grouped into four categories for the purposes of describing here a small set of useful command for everyday Git.</source>
          <target state="translated">Git 사용자는 일상적인 Git에 유용한 명령을 여기에 설명하기 위해 네 가지 범주로 크게 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7ac07d144784e0a8c84df59d7316744b8847546" translate="yes" xml:space="preserve">
          <source>Git uses a simple text format to store customizations that are per repository and are per user. Such a configuration file may look like this:</source>
          <target state="translated">Git은 간단한 텍스트 형식을 사용하여 저장소 및 사용자별로 사용자 정의를 저장합니다. 이러한 구성 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="172b4ceb66bee5a713d5dcc15584b89df5db983d" translate="yes" xml:space="preserve">
          <source>Git usually guesses correctly whether a blob contains text or binary data by examining the beginning of the contents. However, sometimes you may want to override its decision, either because a blob contains binary data later in the file, or because the content, while technically composed of text characters, is opaque to a human reader. For example, many postscript files contain only ASCII characters, but produce noisy and meaningless diffs.</source>
          <target state="translated">Git은 일반적으로 내용의 시작 부분을 검사하여 blob에 텍스트 또는 이진 데이터가 포함되어 있는지 정확하게 추측합니다. 그러나 BLOB에 파일에 나중에 이진 데이터가 포함되어 있거나 기술적으로 텍스트 문자로 구성된 내용이 사람에게 불투명하기 때문에 결정을 무시할 수도 있습니다. 예를 들어 많은 포스트 스크립트 파일에는 ASCII 문자 만 포함되어 있지만 시끄럽고 의미없는 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8049931f388e861f0f1d36c522924184358c43ba" translate="yes" xml:space="preserve">
          <source>Git was started by Linus Torvalds, and is currently maintained by Junio C Hamano. Numerous contributions have come from the Git mailing list &amp;lt;&lt;a href=&quot;mailto:git@vger.kernel.org&quot;&gt;git@vger.kernel.org&lt;/a&gt;&amp;gt;. &lt;a href=&quot;http://www.openhub.net/p/git/contributors/summary&quot;&gt;http://www.openhub.net/p/git/contributors/summary&lt;/a&gt; gives you a more complete list of contributors.</source>
          <target state="translated">Git은 Linus Torvalds에 의해 시작되었으며 현재 Junio ​​C Hamano에 의해 관리됩니다. Git 메일 링리스트 &amp;lt; &lt;a href=&quot;mailto:git@vger.kernel.org&quot;&gt;git@vger.kernel.org&lt;/a&gt; &amp;gt; 에서 많은 기여를했습니다 . &lt;a href=&quot;http://www.openhub.net/p/git/contributors/summary&quot;&gt;http://www.openhub.net/p/git/contributors/summary&lt;/a&gt; 는보다 완전한 기고자 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="526caa17e283066f503c081c2465980601606a1b" translate="yes" xml:space="preserve">
          <source>Git web interface (web frontend to Git repositories)</source>
          <target state="translated">Git 웹 인터페이스 (Git 리포지토리에 대한 웹 프론트 엔드)</target>
        </trans-unit>
        <trans-unit id="041fb03988c0360186f3faf7d7f4aee25aff3a46" translate="yes" xml:space="preserve">
          <source>Git will apply each patch in order; if any conflicts are found, it will stop, and you can fix the conflicts as described in &quot;&lt;a href=&quot;#resolving-a-merge&quot;&gt;Resolving a merge&lt;/a&gt;&quot;. (The &lt;code&gt;-3&lt;/code&gt; option tells Git to perform a merge; if you would prefer it just to abort and leave your tree and index untouched, you may omit that option.)</source>
          <target state="translated">Git은 각 패치를 순서대로 적용합니다. 충돌이 발견되면 중지되고 &quot; &lt;a href=&quot;#resolving-a-merge&quot;&gt;병합 해결&lt;/a&gt; &quot;에 설명 된대로 충돌을 해결할 수 있습니다 . ( &lt;code&gt;-3&lt;/code&gt; 옵션은 Git에게 병합을 수행하도록 지시합니다. 트리와 인덱스를 그대로두고 그대로 두려면 해당 옵션을 생략해도됩니다.)</target>
        </trans-unit>
        <trans-unit id="5affbc744831be1e58dd602e173c2e8a9635241c" translate="yes" xml:space="preserve">
          <source>Git will fail (gracefully) in case it needs to modify this file in the index e.g. when merging in a commit; thus, in case the assumed-untracked file is changed upstream, you will need to handle the situation manually.</source>
          <target state="translated">커밋에서 병합 할 때 인덱스에서이 파일을 수정해야하는 경우 Git은 (정상적으로) 실패합니다. 따라서 추적되지 않은 것으로 가정 된 파일이 업스트림으로 변경되는 경우 상황을 수동으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="48da4a71e3b0bf95013a3e083375ba4a4f8d9442" translate="yes" xml:space="preserve">
          <source>Git will limit what files it checks for changes as well as which directories are checked for untracked files based on the path names given.</source>
          <target state="translated">Git은 경로를 기반으로 변경 사항을 검사 할 파일과 추적되지 않은 파일을 검사 할 디렉토리를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="9b6711c26bfff56f55ea4e0cb9cd80ae556f923a" translate="yes" xml:space="preserve">
          <source>Git will reply</source>
          <target state="translated">힘내 답장</target>
        </trans-unit>
        <trans-unit id="bca1285083439b77ee97a317766aadc935c0bbdf" translate="yes" xml:space="preserve">
          <source>Git will sometimes need credentials from the user in order to perform operations; for example, it may need to ask for a username and password in order to access a remote repository over HTTP. This manual describes the mechanisms Git uses to request these credentials, as well as some features to avoid inputting these credentials repeatedly.</source>
          <target state="translated">Git은 때때로 작업을 수행하기 위해 사용자의 자격 증명이 필요합니다. 예를 들어 HTTP를 통해 원격 저장소에 액세스하려면 사용자 이름과 비밀번호를 요청해야 할 수 있습니다. 이 매뉴얼은 Git이 이러한 자격 증명을 요청하기 위해 사용하는 메커니즘과 이러한 자격 증명을 반복적으로 입력하지 않도록하는 일부 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="dd4de92d6643474e91f15af2289a2ff1175302eb" translate="yes" xml:space="preserve">
          <source>Git writes temporary &lt;code&gt;BASE&lt;/code&gt;, &lt;code&gt;LOCAL&lt;/code&gt;, and &lt;code&gt;REMOTE&lt;/code&gt; versions of conflicting files in the worktree by default. Git will attempt to use a temporary directory for these files when set &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Git은 기본적 으로 작업 트리에 임시 &lt;code&gt;BASE&lt;/code&gt; , &lt;code&gt;LOCAL&lt;/code&gt; 및 &lt;code&gt;REMOTE&lt;/code&gt; 버전의 충돌 파일을 씁니다 . Git은 &lt;code&gt;true&lt;/code&gt; 로 설정하면 이러한 파일에 임시 디렉토리를 사용하려고 시도 합니다 . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="24c7b4499addc9a93ccbe263411515a9a891fc27" translate="yes" xml:space="preserve">
          <source>Git&amp;rsquo;s ability to quickly import and merge patches allows a single maintainer to process incoming changes even at very high rates. And when that becomes too much, &lt;code&gt;git pull&lt;/code&gt; provides an easy way for that maintainer to delegate this job to other maintainers while still allowing optional review of incoming changes.</source>
          <target state="translated">Git의 패치 가져 오기 및 병합 기능을 통해 단일 관리자가 매우 빠른 속도로도 들어오는 변경 사항을 처리 할 수 ​​있습니다. 그리고 그것이 너무 커지면 &lt;code&gt;git pull&lt;/code&gt; 은 해당 유지 관리자 가이 작업을 다른 유지 관리자에게 위임하면서 들어오는 변경 사항을 선택적으로 검토 할 수있는 쉬운 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9715a07ab0249fd3ddbc253711eb7248c1c1366b" translate="yes" xml:space="preserve">
          <source>Git&amp;rsquo;s i18n setup code for shell scripts</source>
          <target state="translated">쉘 스크립트를위한 Git의 i18n 설정 코드</target>
        </trans-unit>
        <trans-unit id="4917cf9f784e37253e2667c9ea0e66247909051b" translate="yes" xml:space="preserve">
          <source>Git&amp;rsquo;s submodule support allows a repository to contain, as a subdirectory, a checkout of an external project. Submodules maintain their own identity; the submodule support just stores the submodule repository location and commit ID, so other developers who clone the containing project (&quot;superproject&quot;) can easily clone all the submodules at the same revision. Partial checkouts of the superproject are possible: you can tell Git to clone none, some or all of the submodules.</source>
          <target state="translated">Git의 서브 모듈 지원은 리포지토리가 외부 프로젝트의 체크 아웃을 서브 디렉토리로 포함 할 수 있도록합니다. 서브 모듈은 자신의 정체성을 유지합니다. 하위 모듈 지원은 하위 모듈 저장소 위치와 커밋 ID 만 저장하므로 포함 프로젝트 ( &quot;superproject&quot;)를 복제하는 다른 개발자는 동일한 개정에서 모든 하위 모듈을 쉽게 복제 할 수 있습니다. 수퍼 프로젝트의 부분 체크 아웃이 가능합니다 : Git에게 서브 모듈의 일부 또는 전부를 복제하지 않도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1ffaf3a57e8861e273a81c5d860f0898c1c6dac" translate="yes" xml:space="preserve">
          <source>Gitk was the first graphical repository browser. It&amp;rsquo;s written in tcl/tk.</source>
          <target state="translated">Gitk는 최초의 그래픽 저장소 브라우저였습니다. tcl / tk로 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="969a3c97b510dcff0a924faf9dee287a0e5d94ec" translate="yes" xml:space="preserve">
          <source>Gitweb assumes this charset when a line contains non-UTF-8 characters. The fallback decoding is used without error checking, so it can be even &quot;utf-8&quot;. The value must be a valid encoding; see the &lt;strong&gt;Encoding::Supported&lt;/strong&gt;(3pm) man page for a list. The default is &quot;latin1&quot;, aka. &quot;iso-8859-1&quot;.</source>
          <target state="translated">줄에 UTF-8이 아닌 문자가 포함 된 경우 Gitweb은이 문자 집합을 가정합니다. 폴백 디코딩은 오류 검사없이 사용되므로 &quot;utf-8&quot;일 수도 있습니다. 값은 유효한 인코딩이어야합니다. 목록은 &lt;strong&gt;Encoding :: Supported&lt;/strong&gt; (3pm) 매뉴얼 페이지를 참조하십시오. 기본값은 &quot;latin1&quot;입니다. &quot;iso-8859-1&quot;.</target>
        </trans-unit>
        <trans-unit id="23aa8c44f909f60d83eed1c6ecddb35429f0603e" translate="yes" xml:space="preserve">
          <source>Gitweb can show information from one or more Git repositories. These repositories have to be all on local filesystem, and have to share common repository root, i.e. be all under a single parent repository (but see also &quot;Advanced web server setup&quot; section, &quot;Webserver configuration with multiple projects' root&quot; subsection).</source>
          <target state="translated">Gitweb은 하나 이상의 Git 리포지토리에서 정보를 표시 할 수 있습니다. 이 리포지토리는 모두 로컬 파일 시스템에 있어야하며 공통 리포지토리 루트를 공유해야합니다. 즉, 단일 상위 리포지토리에 모두 있어야합니다 (그러나 &quot;고급 웹 서버 설정&quot;섹션, &quot;여러 프로젝트의 루트가있는 웹 서버 구성&quot;하위 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="80e6e4e3c32d8a850e194d0e624021eac7612871" translate="yes" xml:space="preserve">
          <source>Gitweb can use path_info (component) based URLs, or it can pass all necessary information via query parameters. The typical gitweb URLs are broken down in to five components:</source>
          <target state="translated">Gitweb은 path_info (구성 요소) 기반 URL을 사용하거나 쿼리 매개 변수를 통해 필요한 모든 정보를 전달할 수 있습니다. 일반적인 gitweb URL은 5 가지 구성 요소로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="c91227cd181327062eb5ac3babb9dcdd0a92cc2a" translate="yes" xml:space="preserve">
          <source>Gitweb provides a web interface to Git repositories. Its features include:</source>
          <target state="translated">Gitweb은 Git 리포지토리에 웹 인터페이스를 제공합니다. 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b64851fc263d72157b99e98603012bfc29c4f9ff" translate="yes" xml:space="preserve">
          <source>Gitweb reads configuration data from the following sources in the following order:</source>
          <target state="translated">Gitweb은 다음 소스에서 다음 순서로 구성 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="0b6ae99cd0fc07dd07b98d65f39c6a8d809c4979" translate="yes" xml:space="preserve">
          <source>Gitweb version, set automatically when creating gitweb.cgi from gitweb.perl. You might want to modify it if you are running modified gitweb, for example</source>
          <target state="translated">gitweb.perl에서 gitweb.cgi를 만들 때 자동으로 설정되는 Gitweb 버전. 예를 들어 수정 된 gitweb을 실행중인 경우 수정하고 싶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcc44369541727be05647a1cc4996dbc27b86060" translate="yes" xml:space="preserve">
          <source>Gitweb works with Apache and FastCGI. First you need to rename, copy or symlink gitweb.cgi to gitweb.fcgi. Let&amp;rsquo;s assume that gitweb is installed in &lt;code&gt;/usr/share/gitweb&lt;/code&gt; directory. The following Apache configuration is suitable (UNTESTED!)</source>
          <target state="translated">Gitweb은 Apache 및 FastCGI와 함께 작동합니다. 먼저 gitweb.cgi를 gitweb.fcgi로 이름을 바꾸거나 복사 또는 symlink해야합니다. gitweb이 &lt;code&gt;/usr/share/gitweb&lt;/code&gt; 디렉토리에 설치되어 있다고 가정 해 봅시다 . 다음 Apache 구성이 적합합니다 (UNTESTED!)</target>
        </trans-unit>
        <trans-unit id="42543af4180750540520e4da78d3e7076123fd5c" translate="yes" xml:space="preserve">
          <source>Give an object a human readable name based on an available ref</source>
          <target state="translated">사용 가능한 참조를 기반으로 사람이 읽을 수있는 이름을 객체에 제공</target>
        </trans-unit>
        <trans-unit id="8a08e691bc874c43f32edff7b28078841082dfd2" translate="yes" xml:space="preserve">
          <source>Give push/pull only access to developers using git-over-ssh.</source>
          <target state="translated">git-over-ssh를 사용하는 개발자에게만 push / pull 액세스 권한을 부여하십시오.</target>
        </trans-unit>
        <trans-unit id="098611c3aa4062358e82cce32a6cb2188462a62d" translate="yes" xml:space="preserve">
          <source>Give the output in an easy-to-parse format for scripts. This is similar to the short output, but will remain stable across Git versions and regardless of user configuration. See below for details.</source>
          <target state="translated">스크립트에 대해 구문 분석하기 쉬운 형식으로 출력을 제공하십시오. 이것은 짧은 출력과 비슷하지만 사용자 구성에 관계없이 Git 버전에서 안정적으로 유지됩니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4cab29647a0992b826e617662d099d2fa7b8c337" translate="yes" xml:space="preserve">
          <source>Give the output in the long-format. This is the default.</source>
          <target state="translated">출력을 긴 형식으로 제공하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="7b3a4cfa6cfda1ef4f79bab4a1d749c9c6c5f5f0" translate="yes" xml:space="preserve">
          <source>Give the output in the short-format.</source>
          <target state="translated">짧은 형식으로 출력하십시오.</target>
        </trans-unit>
        <trans-unit id="2dc950b47492cb25f78f25c843f0ed41c631283b" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;--delete&lt;/code&gt; and an additional argument, deletes the given symbolic ref.</source>
          <target state="translated">을 감안할 때 &lt;code&gt;--delete&lt;/code&gt; 및 추가 인수, 주어진 상징적 심판을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="e97e8a091675b0288dfc0175fdb5f7c838cea92d" translate="yes" xml:space="preserve">
          <source>Given N &amp;lt;references&amp;gt;, the first N lines are the one-line description from their commit message. The branch head that is pointed at by $GIT_DIR/HEAD is prefixed with an asterisk &lt;code&gt;*&lt;/code&gt; character while other heads are prefixed with a &lt;code&gt;!&lt;/code&gt; character.</source>
          <target state="translated">N &amp;lt;references&amp;gt;가 주어지면 첫 번째 N 행은 커밋 메시지의 한 줄 설명입니다. $ GIT_DIR / HEAD가 가리키는 브랜치 헤드는 별표 ( &lt;code&gt;*&lt;/code&gt; ) 로 시작하고 다른 헤드는 &lt;code&gt;!&lt;/code&gt; 로 시작합니다 . 캐릭터.</target>
        </trans-unit>
        <trans-unit id="a02a332c45eb3b9cf3b89841e8aa1ca85e593c49" translate="yes" xml:space="preserve">
          <source>Given a .git/config like this:</source>
          <target state="translated">다음과 같이 .git / config가 주어집니다.</target>
        </trans-unit>
        <trans-unit id="e65ae867c8cb398abc725e8538eba217d02dbede" translate="yes" xml:space="preserve">
          <source>Given a commit, find out where it is relative to the local refs. Say somebody wrote you about that fantastic commit 33db5f4d9027a10e477ccf054b2c1ab94f74c85a. Of course, you look into the commit, but that only tells you what happened, but not the context.</source>
          <target state="translated">커밋이 주어지면 로컬 참조와 관련된 위치를 찾으십시오. 누군가 환상적인 커밋 33db5f4d9027a10e477ccf054b2c1ab94f74c85a에 대해 당신에게 썼다고 가정 해보십시오. 물론, 당신은 커밋을 조사하지만, 그것은 당신에게 무슨 일이 있었는지를 알려주지 만 상황은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7ce01790b46379d506c51a1991e3ea26b3a8d244" translate="yes" xml:space="preserve">
          <source>Given one argument, reads which branch head the given symbolic ref refers to and outputs its path, relative to the &lt;code&gt;.git/&lt;/code&gt; directory. Typically you would give &lt;code&gt;HEAD&lt;/code&gt; as the &amp;lt;name&amp;gt; argument to see which branch your working tree is on.</source>
          <target state="translated">하나의 인수가 주어지면 주어진 기호 참조가 어떤 분기 헤드를 참조하고 &lt;code&gt;.git/&lt;/code&gt; 디렉토리에 상대적인 경로를 출력 하는지를 읽습니다 . 일반적으로 &lt;code&gt;HEAD&lt;/code&gt; 를 &amp;lt;name&amp;gt; 인수로 지정하여 작업 트리가있는 브랜치를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="ee9f44e6df9f9221a39559d12563d4ded15eb1ae" translate="yes" xml:space="preserve">
          <source>Given one or more existing commits, apply the change each one introduces, recording a new commit for each. This requires your working tree to be clean (no modifications from the HEAD commit).</source>
          <target state="translated">하나 이상의 기존 커밋이 주어지면 각 커밋에 대한 변경 사항을 적용하고 각각에 대해 새로운 커밋을 기록하십시오. 이를 위해서는 작업 트리가 깨끗해야합니다 (HEAD 커밋의 수정 사항 없음).</target>
        </trans-unit>
        <trans-unit id="49cfc78f8193ed0e67ffaf9646d690418c000a33" translate="yes" xml:space="preserve">
          <source>Given one or more existing commits, revert the changes that the related patches introduce, and record some new commits that record them. This requires your working tree to be clean (no modifications from the HEAD commit).</source>
          <target state="translated">기존 커밋이 하나 이상 있으면 관련 패치가 도입 한 변경 사항을 되돌리고이를 기록하는 새로운 커밋을 기록하십시오. 이를 위해서는 작업 트리가 깨끗해야합니다 (HEAD 커밋의 수정 사항 없음).</target>
        </trans-unit>
        <trans-unit id="b90c39be8f3013761513d522c230779e0af0700e" translate="yes" xml:space="preserve">
          <source>Given the following noisy input with &lt;code&gt;$&lt;/code&gt; indicating the end of a line:</source>
          <target state="translated">줄의 끝을 나타내는 &lt;code&gt;$&lt;/code&gt; 와 함께 다음과 같은 노이즈 입력이 주어집니다 .</target>
        </trans-unit>
        <trans-unit id="9ae9c5ba5c0cae940c9ccda71b399bacf0ceae54" translate="yes" xml:space="preserve">
          <source>Given three arguments, stores the &amp;lt;newvalue&amp;gt; in the &amp;lt;ref&amp;gt;, possibly dereferencing the symbolic refs, after verifying that the current value of the &amp;lt;ref&amp;gt; matches &amp;lt;oldvalue&amp;gt;. E.g. &lt;code&gt;git update-ref refs/heads/master &amp;lt;newvalue&amp;gt; &amp;lt;oldvalue&amp;gt;&lt;/code&gt; updates the master branch head to &amp;lt;newvalue&amp;gt; only if its current value is &amp;lt;oldvalue&amp;gt;. You can specify 40 &quot;0&quot; or an empty string as &amp;lt;oldvalue&amp;gt; to make sure that the ref you are creating does not exist.</source>
          <target state="translated">세 개의 인수가 주어지면 &amp;lt;ref&amp;gt;의 현재 값이 &amp;lt;oldvalue&amp;gt;와 일치하는지 확인한 후 &amp;lt;newvalue&amp;gt;를 &amp;lt;ref&amp;gt;에 저장하고 기호 참조를 역 참조 할 수 있습니다. 예를 들어 &lt;code&gt;git update-ref refs/heads/master &amp;lt;newvalue&amp;gt; &amp;lt;oldvalue&amp;gt;&lt;/code&gt; 는 현재 값이 &amp;lt;oldvalue&amp;gt; 인 경우에만 마스터 분기 헤드를 &amp;lt;newvalue&amp;gt;로 업데이트합니다. 작성중인 참조가 존재하지 않도록 40 &quot;0&quot;또는 빈 문자열을 &amp;lt;oldvalue&amp;gt;로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d8bb10ba2f3cfa88afc4b8727de27fb3cab8018" translate="yes" xml:space="preserve">
          <source>Given three commits &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;git merge-base A B C&lt;/code&gt; will compute the merge base between &lt;code&gt;A&lt;/code&gt; and a hypothetical commit &lt;code&gt;M&lt;/code&gt;, which is a merge between &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;. For example, with this topology:</source>
          <target state="translated">커밋 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 가 세 개인 경우 , &lt;code&gt;git merge-base A B C&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 와 가설 커밋 &lt;code&gt;M&lt;/code&gt; 사이의 병합 기준을 계산하며 , 이는 &lt;code&gt;B&lt;/code&gt; 와 &lt;code&gt;C&lt;/code&gt; 간의 병합 입니다. 예를 들어이 토폴로지의 경우</target>
        </trans-unit>
        <trans-unit id="be6c9bc842b0965134f1fb7992b74ba082dffe0f" translate="yes" xml:space="preserve">
          <source>Given two arguments, creates or updates a symbolic ref &amp;lt;name&amp;gt; to point at the given branch &amp;lt;ref&amp;gt;.</source>
          <target state="translated">두 개의 인수가 주어지면 주어진 분기 &amp;lt;ref&amp;gt;를 가리 키도록 기호 ref &amp;lt;name&amp;gt;을 작성하거나 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="7cc67b58b4d717f52eb7b590f0c2ac097c83b04a" translate="yes" xml:space="preserve">
          <source>Given two arguments, stores the &amp;lt;newvalue&amp;gt; in the &amp;lt;ref&amp;gt;, possibly dereferencing the symbolic refs. E.g. &lt;code&gt;git update-ref HEAD
&amp;lt;newvalue&amp;gt;&lt;/code&gt; updates the current branch head to the new object.</source>
          <target state="translated">두 개의 인수가 주어지면 &amp;lt;newvalue&amp;gt;를 &amp;lt;ref&amp;gt;에 저장하여 기호 참조를 역 참조 할 수 있습니다. 예를 들어 &lt;code&gt;git update-ref HEAD &amp;lt;newvalue&amp;gt;&lt;/code&gt; 는 현재 분기 헤드를 새 객체로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="931db30a85fe3ea596ac121ca8f065ad449ff885" translate="yes" xml:space="preserve">
          <source>Given two commits &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;git merge-base A B&lt;/code&gt; will output a commit which is reachable from both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; through the parent relationship.</source>
          <target state="translated">두 커밋 주어 및 &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;git merge-base A B&lt;/code&gt; 양쪽에서 접근하는 커미트가 출력 및 &lt;code&gt;B&lt;/code&gt; 부모 관계를 통해서. &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0c09289dc074c18ca9574b29845f64d7cae5bc3" translate="yes" xml:space="preserve">
          <source>Gives some information about the remote &amp;lt;name&amp;gt;.</source>
          <target state="translated">원격 &amp;lt;name&amp;gt;에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9466e3cfe4b90da05672816c37e48d04d2b0bacb" translate="yes" xml:space="preserve">
          <source>Giving these options is an error when used with &lt;code&gt;--inetd&lt;/code&gt;; use the facility of inet daemon to achieve the same before spawning &lt;code&gt;git daemon&lt;/code&gt; if needed.</source>
          <target state="translated">&lt;code&gt;--inetd&lt;/code&gt; 와 함께 사용할 때 이러한 옵션을 제공하면 오류가 발생합니다 . 필요한 경우 &lt;code&gt;git daemon&lt;/code&gt; 생성하기 전에 inet 데몬 기능을 사용하여 동일한 기능을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0ec3ae2bdc4ccb842cc8f2251da67f38c6daf5a" translate="yes" xml:space="preserve">
          <source>Glob magic is incompatible with literal magic.</source>
          <target state="translated">글롭 매직은 리터럴 매직과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="d8608c60e7a8f9d556f6c1f2aff537e2ce064bab" translate="yes" xml:space="preserve">
          <source>Go under &quot;Options&quot; in the Composer window and be sure that &quot;Word wrap&quot; is not set.</source>
          <target state="translated">작성기 창의 &quot;옵션&quot;으로 이동하여 &quot;워드 랩&quot;이 설정되어 있지 않은지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c16a49b3ce3e17532ce6e118e23e9cba92fcb23b" translate="yes" xml:space="preserve">
          <source>Graduation</source>
          <target state="translated">Graduation</target>
        </trans-unit>
        <trans-unit id="7108295a48fb4030d059842641f3ed2f16dd90ea" translate="yes" xml:space="preserve">
          <source>Grafts enables two otherwise different lines of development to be joined together by recording fake ancestry information for commits. This way you can make Git pretend the set of &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt; a &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; has is different from what was recorded when the commit was created. Configured via the &lt;code&gt;.git/info/grafts&lt;/code&gt; file.</source>
          <target state="translated">Grafts를 사용하면 커밋에 대한 가짜 조상 정보를 기록하여 서로 다른 두 가지 개발 라인을 결합 할 수 있습니다. 이 방법으로 Git 이 &lt;a href=&quot;#def_commit&quot;&gt;커밋&lt;/a&gt; 이 있는 &lt;a href=&quot;#def_parent&quot;&gt;부모&lt;/a&gt; 세트를 가장하게 만들 수 있습니다 . 커밋이 생성되었을 때 기록 된 것과 다릅니다. &lt;code&gt;.git/info/grafts&lt;/code&gt; 파일을 통해 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="43addd483f6785ba3f74ca813174b30e77d7804f" translate="yes" xml:space="preserve">
          <source>Graphical alternative to git-commit</source>
          <target state="translated">git-commit의 그래픽 대안</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="7138a51661947b19b5088da5a2bfede2876f49b9" translate="yes" xml:space="preserve">
          <source>HEAD</source>
          <target state="translated">HEAD</target>
        </trans-unit>
        <trans-unit id="f53aba93b9409d79b694657717f24476b7680a38" translate="yes" xml:space="preserve">
          <source>HEAD can also record a specific commit directly, instead of being a symref to point at the current branch. Such a state is often called &lt;code&gt;detached HEAD.&lt;/code&gt; See &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; for details.</source>
          <target state="translated">HEAD는 또한 현재 분기를 가리키는 symref 대신 특정 커밋을 직접 기록 할 수 있습니다. 이러한 상태를 종종 &lt;code&gt;detached HEAD.&lt;/code&gt; 라고 합니다. 자세한 내용은 &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="adaf1f885f4f48f7b3c5a9a2b8f4883bf35d0a07" translate="yes" xml:space="preserve">
          <source>HEAD: refers to the head of the current branch</source>
          <target state="translated">HEAD : 현재 지점의 헤드를 나타냅니다</target>
        </trans-unit>
        <trans-unit id="408093a274a45499420aa72e738c6e970f863fed" translate="yes" xml:space="preserve">
          <source>HEADER:</source>
          <target state="translated">HEADER:</target>
        </trans-unit>
        <trans-unit id="bd0cfe599144b530c7c9685825d1a02a5377b64e" translate="yes" xml:space="preserve">
          <source>HTML snippet to be included in the &amp;lt;head&amp;gt; section of each page. Can be set using &lt;code&gt;GITWEB_SITE_HTML_HEAD_STRING&lt;/code&gt; at build time. No default value.</source>
          <target state="translated">각 페이지의 &amp;lt;head&amp;gt; 섹션에 포함될 HTML 스 니펫 빌드시 &lt;code&gt;GITWEB_SITE_HTML_HEAD_STRING&lt;/code&gt; 을 사용하여 설정할 수 있습니다 . 기본값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="cc56a2df9f8b6a66c5d2a6125ab52ed375e5152b" translate="yes" xml:space="preserve">
          <source>HTTP Transport</source>
          <target state="translated">HTTP 전송</target>
        </trans-unit>
        <trans-unit id="d578fb1b4bb161c78cd19e50fcb2b009bf47fe3e" translate="yes" xml:space="preserve">
          <source>HTTP(S)</source>
          <target state="translated">HTTP(S)</target>
        </trans-unit>
        <trans-unit id="1ba3338bd0d397031ae85dc0347d63c94b00e5df" translate="yes" xml:space="preserve">
          <source>HTTP/1.1</source>
          <target state="translated">HTTP/1.1</target>
        </trans-unit>
        <trans-unit id="396826d4135990391d3176f7b40c9091eed2c0d3" translate="yes" xml:space="preserve">
          <source>HTTP/2</source>
          <target state="translated">HTTP/2</target>
        </trans-unit>
        <trans-unit id="80bde80e45cfc7c229d507fff6d534806b07378c" translate="yes" xml:space="preserve">
          <source>Hacking git</source>
          <target state="translated">해킹 자식</target>
        </trans-unit>
        <trans-unit id="c4b8d31a4ffcd043a96008543e3e1f5d7eaf7692" translate="yes" xml:space="preserve">
          <source>Handling Renames</source>
          <target state="translated">이름 변경 처리</target>
        </trans-unit>
        <trans-unit id="3049c71fe9126eefc3301476201dcd8b12bbbd85" translate="yes" xml:space="preserve">
          <source>Handling of svn branches</source>
          <target state="translated">svn 분기 처리</target>
        </trans-unit>
        <trans-unit id="b2bb788b2d8872820805621988d07bb34824ee87" translate="yes" xml:space="preserve">
          <source>Hard case: The changes are not the same.</source>
          <target state="translated">어려운 경우 : 변경 사항이 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d86493cd0a3bd6cc52c39427d91b4f3fb5f1ba0f" translate="yes" xml:space="preserve">
          <source>Has no effect if the ref does not have tracking information associated with it. All the options apart from &lt;code&gt;nobracket&lt;/code&gt; are mutually exclusive, but if used together the last option is selected.</source>
          <target state="translated">심판이 관련 추적 정보를 가지고 있지 않은 경우에는 효과가 없습니다. &lt;code&gt;nobracket&lt;/code&gt; 을 제외한 모든 옵션은 함께 사용할 수 없지만 함께 사용하면 마지막 옵션이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="eee44516ee4e4873c5ecfb5a6805b0f8b1007d35" translate="yes" xml:space="preserve">
          <source>Hash object as it were located at the given path. The location of file does not directly influence on the hash value, but path is used to determine what Git filters should be applied to the object before it can be placed to the object database, and, as result of applying filters, the actual blob put into the object database may differ from the given file. This option is mainly useful for hashing temporary files located outside of the working directory or files read from stdin.</source>
          <target state="translated">주어진 경로에있는 개체를 해시합니다. 파일의 위치는 해시 값에 직접 영향을 미치지 않지만 경로는 객체 데이터베이스에 배치하기 전에 객체에 적용 할 Git 필터를 결정하는 데 사용되며, 필터를 적용한 결과 실제 Blob은 개체 데이터베이스에 대한 파일은 제공된 파일과 다를 수 있습니다. 이 옵션은 주로 작업 디렉토리 외부에있는 임시 파일이나 stdin에서 읽은 파일을 해싱하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="100c09777204f7d9c4d9c8cca2b2ca1117efcbe1" translate="yes" xml:space="preserve">
          <source>Hash the contents as is, ignoring any input filter that would have been chosen by the attributes mechanism, including the end-of-line conversion. If the file is read from standard input then this is always implied, unless the &lt;code&gt;--path&lt;/code&gt; option is given.</source>
          <target state="translated">행 끝 변환을 포함하여 속성 메커니즘에 의해 선택된 입력 필터를 무시하고 내용을 그대로 해시하십시오. 파일을 표준 입력에서 읽은 경우 &lt;code&gt;--path&lt;/code&gt; 옵션을 지정 하지 않으면 항상 암시 됩니다.</target>
        </trans-unit>
        <trans-unit id="f2ae7e4a6dc9825ef1a4868750168492eeaf6380" translate="yes" xml:space="preserve">
          <source>Have the server run as an inetd service. Implies --syslog (may be overridden with &lt;code&gt;--log-destination=&lt;/code&gt;). Incompatible with --detach, --port, --listen, --user and --group options.</source>
          <target state="translated">서버를 inetd 서비스로 실행하십시오. --syslog를 의미합니다 ( &lt;code&gt;--log-destination=&lt;/code&gt; 으로 재정의 될 수 있음 ). --detach, --port, --listen, --user 및 --group 옵션과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db301d2890ccaa14dc974751b62b359a359b6b5c" translate="yes" xml:space="preserve">
          <source>He also uses a set of temporary branches (&quot;topic branches&quot;), each containing a logical grouping of patches.</source>
          <target state="translated">또한 논리적 패치 그룹을 포함하는 임시 분기 ( &quot;토픽 분기&quot;) 세트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c983e9a4d9daf24f5efac3a67c8f6c12bda32744" translate="yes" xml:space="preserve">
          <source>He uses two public branches:</source>
          <target state="translated">그는 두 가지 공공 지점을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="08dac5b0781534f17eedb09bc82379faeed11d4a" translate="yes" xml:space="preserve">
          <source>Header lines start with &quot;#&quot; and are added in response to specific command line arguments. Parsers should ignore headers they don&amp;rsquo;t recognize.</source>
          <target state="translated">헤더 행은 &quot;#&quot;으로 시작하고 특정 명령 행 인수에 대한 응답으로 추가됩니다. 파서는 인식하지 못하는 헤더를 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="6f7a484a67443c5c4893cfcebc8516ecb7a4f1a2" translate="yes" xml:space="preserve">
          <source>Help parsing or adding &lt;code&gt;trailers&lt;/code&gt; lines, that look similar to RFC 822 e-mail headers, at the end of the otherwise free-form part of a commit message.</source>
          <target state="translated">커밋 메시지의 자유 형식 부분 끝에 RFC 822 전자 메일 헤더와 비슷한 &lt;code&gt;trailers&lt;/code&gt; 줄을 구문 분석하거나 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7f00958253572e7e593fd3637f7f812370db1d4" translate="yes" xml:space="preserve">
          <source>Helper to store credentials on disk</source>
          <target state="translated">디스크에 자격 증명을 저장하는 도우미</target>
        </trans-unit>
        <trans-unit id="91ab6264d347386bb003d96ff4f148c65df714a3" translate="yes" xml:space="preserve">
          <source>Helper to temporarily store passwords in memory</source>
          <target state="translated">메모리에 비밀번호를 임시로 저장하는 도우미</target>
        </trans-unit>
        <trans-unit id="f8801cb816506b471cd751bc46c3d753c8b27a46" translate="yes" xml:space="preserve">
          <source>Hence</source>
          <target state="translated">Hence</target>
        </trans-unit>
        <trans-unit id="8286249a7e764f5f9777c2fc17e5230ccc1ef5fe" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is any of the commit specification expressions also accepted by &lt;code&gt;from&lt;/code&gt; (see above).</source>
          <target state="translated">여기에서 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 는 &lt;code&gt;from&lt;/code&gt; 에 의해 승인 된 커밋 사양 표현식 중 하나 입니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="3fb766f6c8298c39110428f8565787238a736366" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is any of the following:</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="85bca9b0f87b55d545a8c945215b23dd3bdbffcb" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; can be either a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) set by a prior &lt;code&gt;blob&lt;/code&gt; command, or a full 40-byte SHA-1 of an existing Git blob object.</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 는 이전 &lt;code&gt;blob&lt;/code&gt; 명령으로 설정된 마크 참조 ( &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ) 이거나 기존 Git Blob 객체의 전체 40 바이트 SHA-1 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f53683a6742f0030e51cf7120f8e28dba9865c5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is the person&amp;rsquo;s display name (for example &amp;ldquo;Com M Itter&amp;rdquo;) and &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; is the person&amp;rsquo;s email address (&amp;ldquo;cm@example.com&amp;rdquo;). &lt;code&gt;LT&lt;/code&gt; and &lt;code&gt;GT&lt;/code&gt; are the literal less-than (\x3c) and greater-than (\x3e) symbols. These are required to delimit the email address from the other fields in the line. Note that &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; are free-form and may contain any sequence of bytes, except &lt;code&gt;LT&lt;/code&gt;, &lt;code&gt;GT&lt;/code&gt; and &lt;code&gt;LF&lt;/code&gt;. &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is typically UTF-8 encoded.</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 은 사람의 표시 이름 (예 :&amp;ldquo;Com M Itter&amp;rdquo;)이고 &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; 은 사람의 전자 메일 주소 (&amp;ldquo;cm@example.com&amp;rdquo;)입니다. &lt;code&gt;LT&lt;/code&gt; 및 &lt;code&gt;GT&lt;/code&gt; 는 리터럴보다 작음 (\ x3c) 및보다 큼 (\ x3e) 기호입니다. 이들은 라인의 다른 필드에서 이메일 주소를 구분하는 데 필요합니다. 참고 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 과 &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; 자유 형식이며, 제외 바이트의 시퀀스를 포함 할 수있다 &lt;code&gt;LT&lt;/code&gt; , &lt;code&gt;GT&lt;/code&gt; 및 &lt;code&gt;LF&lt;/code&gt; 를 . &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 은 일반적으로 UTF-8로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="88e3e34bac3d333854c449d8638faee3f973bc68" translate="yes" xml:space="preserve">
          <source>Here actual project root is passed to gitweb via &lt;code&gt;GITWEB_PROJECT_ROOT&lt;/code&gt; environment variable from a web server, so you need to put the following line in gitweb configuration file (&lt;code&gt;/etc/gitweb.conf&lt;/code&gt; in above example):</source>
          <target state="translated">여기서 실제 프로젝트 루트는 웹 서버에서 &lt;code&gt;GITWEB_PROJECT_ROOT&lt;/code&gt; 환경 변수를 통해 gitweb에 전달 되므로 gitweb 구성 파일 ( 위의 예에서 &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; ) 에 다음 줄을 넣어야합니다 .</target>
        </trans-unit>
        <trans-unit id="87d852c017173b91ce004ba4ee55c454ec44074f" translate="yes" xml:space="preserve">
          <source>Here again it is a good point to take a pause.</source>
          <target state="translated">여기서 다시 한 번 일시 중지하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9d560d4da9e941f0111865584d812ed4b996ba31" translate="yes" xml:space="preserve">
          <source>Here are a handful of examples using the Loeliger illustration above, with each step in the notation&amp;rsquo;s expansion and selection carefully spelt out:</source>
          <target state="translated">다음은 위의 Loeliger 그림을 사용한 몇 가지 예입니다. 표기법의 확장 및 선택의 각 단계는 신중하게 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a6c1665b5306569c28a748694fd4e1b1e7a55db" translate="yes" xml:space="preserve">
          <source>Here are some hints on how to successfully submit patches inline using various mailers.</source>
          <target state="translated">다음은 다양한 메일러를 사용하여 인라인으로 패치를 제출하는 방법에 대한 힌트입니다.</target>
        </trans-unit>
        <trans-unit id="1510576755c083f75778b41e3e15db4ef8738ed9" translate="yes" xml:space="preserve">
          <source>Here are some of the scripts that simplify all this even further.</source>
          <target state="translated">다음은이 모든 것을 더욱 단순화하는 스크립트 중 일부입니다.</target>
        </trans-unit>
        <trans-unit id="e7b17934614eee2f77ca3149426accc7b6e72d44" translate="yes" xml:space="preserve">
          <source>Here are the rules regarding the &quot;flags&quot; that you should follow when you are scripting Git:</source>
          <target state="translated">Git을 스크립팅 할 때 따라야 할 &quot;플래그&quot;에 관한 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="04cdec1fa8a31abdd551dc359504457bc39d207b" translate="yes" xml:space="preserve">
          <source>Here is a hypothetical usage of the Trace2 API showing the intended usage (without worrying about the actual Git details).</source>
          <target state="translated">다음은 실제 Git 세부 사항에 대한 걱정없이 의도 된 사용법을 보여주는 Trace2 API의 가상 사용법입니다.</target>
        </trans-unit>
        <trans-unit id="ffd38e59dd005a380c8a8570731f44b027a45fba" translate="yes" xml:space="preserve">
          <source>Here is a list of the facilities provided by this option parser.</source>
          <target state="translated">다음은이 옵션 파서가 제공하는 기능 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e4035106d997a5f9ffd025f7ed0bd5862edf3733" translate="yes" xml:space="preserve">
          <source>Here is a picture that illustrates how various pieces fit together:</source>
          <target state="translated">다음은 다양한 조각들이 어떻게 어울리는지를 보여주는 그림입니다.</target>
        </trans-unit>
        <trans-unit id="303a3029ebdf1756e031ccbacc8dc586c90ed37d" translate="yes" xml:space="preserve">
          <source>Here is an ASCII art by Jon Loeliger that illustrates how various &lt;code&gt;diff-*&lt;/code&gt; commands compare things.</source>
          <target state="translated">Jon Loeliger의 ASCII 아트는 다양한 &lt;code&gt;diff-*&lt;/code&gt; 명령이 사물을 비교 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="a1af358ae94ab7cd9ed6d1b4e51b99fcacedf212" translate="yes" xml:space="preserve">
          <source>Here is an example of a work-flow used by Andreas Ericsson:</source>
          <target state="translated">Andreas Ericsson이 사용한 워크 플로우의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="186fb29b724fc88890a2b738e2f88d967cca2e57" translate="yes" xml:space="preserve">
          <source>Here is an example script that comes slightly modified from a real world script used by Junio Hamano &lt;a href=&quot;#4&quot;&gt;[4]&lt;/a&gt;.</source>
          <target state="translated">다음은 Junio ​​Hamano가 사용하는 실제 스크립트에서 약간 수정 된 예제 스크립트입니다 &lt;a href=&quot;#4&quot;&gt;[4]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea2d28e72cba49a8087ea617856210e85cc4631a" translate="yes" xml:space="preserve">
          <source>Here is an illustration, by Jon Loeliger. Both commit nodes B and C are parents of commit node A. Parent commits are ordered left-to-right.</source>
          <target state="translated">다음은 Jon Loeliger의 그림입니다. 커밋 노드 B와 C는 모두 커밋 노드 A의 부모입니다. 부모 커밋은 왼쪽에서 오른쪽으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="01a0e7181fc0932a87393a13bfb324333ce2de29" translate="yes" xml:space="preserve">
          <source>Here is how you would transplant a topic branch based on one branch to another, to pretend that you forked the topic branch from the latter branch, using &lt;code&gt;rebase --onto&lt;/code&gt;.</source>
          <target state="translated">다음은 &lt;code&gt;rebase --onto&lt;/code&gt; 를 사용하여 한 분기에서 다른 분기로 주제 분기를 이식하여 후자의 분기에서 주제 분기를 분기 한 것처럼 가장하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="213d54b0bbf3a7f7afa040a26967e9f565627a3c" translate="yes" xml:space="preserve">
          <source>Here is what Ingo Molnar says about that &lt;a href=&quot;#7&quot;&gt;[7]&lt;/a&gt;:</source>
          <target state="translated">다음은 Ingo Molnar가 말하는 것입니다. &lt;a href=&quot;#7&quot;&gt;[7]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0ace4715fac22315364196a248067a261a46ae73" translate="yes" xml:space="preserve">
          <source>Here usually &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; must be either a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) set by a prior &lt;code&gt;blob&lt;/code&gt; command, or a full 40-byte SHA-1 of an existing Git blob object. If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;040000`&lt;/code&gt; then &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; must be the full 40-byte SHA-1 of an existing Git tree object or a mark reference set with &lt;code&gt;--import-marks&lt;/code&gt;.</source>
          <target state="translated">여기서 일반적으로 &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 는 이전 &lt;code&gt;blob&lt;/code&gt; 명령으로 설정된 마크 참조 ( &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ) 이거나 기존 Git Blob 객체의 전체 40 바이트 SHA-1 이어야 합니다. 경우 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 이다 &lt;code&gt;040000`&lt;/code&gt; 다음 &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 전체 40 바이트의 SHA-1 기존 힘내 트리 오브젝트 또는 마크와 기준 세트이어야 &lt;code&gt;--import-marks&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2beb401ec57f79ec07666eedc396bc9251ab532b" translate="yes" xml:space="preserve">
          <source>Here we use a &lt;code&gt;test.sh&lt;/code&gt; custom script. In this script, if &lt;code&gt;make&lt;/code&gt; fails, we skip the current commit. &lt;code&gt;check_test_case.sh&lt;/code&gt; should &lt;code&gt;exit 0&lt;/code&gt; if the test case passes, and &lt;code&gt;exit 1&lt;/code&gt; otherwise.</source>
          <target state="translated">여기서는 &lt;code&gt;test.sh&lt;/code&gt; 사용자 정의 스크립트를 사용합니다 . 이 스크립트에서 &lt;code&gt;make&lt;/code&gt; 가 실패하면 현재 커밋을 건너 뜁니다. 테스트 케이스가 통과하면 &lt;code&gt;check_test_case.sh&lt;/code&gt; 는 &lt;code&gt;exit 0&lt;/code&gt; 을 종료 하고 그렇지 않으면 &lt;code&gt;exit 1&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4c65aa59e4c90d1dad65ae558dc71a05ca72658c" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example to make it more clear:</source>
          <target state="translated">보다 명확하게하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f876057ef41997694291fae2bce19c94e2c8be27" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s where things get tricky and more specific. The pruning feature doesn&amp;rsquo;t actually care about branches, instead it&amp;rsquo;ll prune local &amp;lt;&amp;rarr; remote-references as a function of the refspec of the remote (see &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; and &lt;a href=&quot;#CRTB&quot;&gt;CONFIGURED REMOTE-TRACKING BRANCHES&lt;/a&gt; above).</source>
          <target state="translated">까다 롭고 구체적이되는 곳이 여기에 있습니다. 가지 치기 기능은 실제로 분기에 신경 쓰지 않고 대신 원격 참조의 함수로 로컬 &amp;lt;&amp;rarr; 원격 참조를 제거합니다 (위의 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 및 &lt;a href=&quot;#CRTB&quot;&gt;CONFIGURED REMOTE-TRACKING BRANCHES&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="6e909debf7e14a75a50a127741701f06b0380ed1" translate="yes" xml:space="preserve">
          <source>Here, order matters, so the negative patterns are overridden by the positive patterns that appear lower in the file.</source>
          <target state="translated">여기서 순서가 중요하므로 파일에서 아래에 나타나는 양의 패턴으로 음의 패턴이 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e1c70b8a098f60c6e63dbb08701031f93ea135ff" translate="yes" xml:space="preserve">
          <source>Here, take a moment to look at the contents of &lt;code&gt;hello&lt;/code&gt;, and notice how they don&amp;rsquo;t contain the work we just did in &lt;code&gt;mybranch&lt;/code&gt; &amp;mdash; because that work hasn&amp;rsquo;t happened in the &lt;code&gt;master&lt;/code&gt; branch at all. Then do</source>
          <target state="translated">여기서 &lt;code&gt;hello&lt;/code&gt; 의 내용을 살펴보고 , &lt;code&gt;mybranch&lt;/code&gt; 에서 방금 수행 한 작업이 포함되어 있지 않은지 확인하십시오. 이 작업은 &lt;code&gt;master&lt;/code&gt; 브랜치에서 전혀 수행되지 않았기 때문입니다 . 그런 다음</target>
        </trans-unit>
        <trans-unit id="d77fbd432531fa44ab380c6d115f43ea2fbe9fc8" translate="yes" xml:space="preserve">
          <source>Here, we just added another line to &lt;code&gt;hello&lt;/code&gt;, and we used a shorthand for doing both &lt;code&gt;git update-index hello&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt; by just giving the filename directly to &lt;code&gt;git commit&lt;/code&gt;, with an &lt;code&gt;-i&lt;/code&gt; flag (it tells Git to &lt;code&gt;include&lt;/code&gt; that file in addition to what you have done to the index file so far when making the commit). The &lt;code&gt;-m&lt;/code&gt; flag is to give the commit log message from the command line.</source>
          <target state="translated">여기, 우리가 또 다른 라인에 추가 &lt;code&gt;hello&lt;/code&gt; , 우리는 모두 일에 대한 속기를 사용 &lt;code&gt;git update-index hello&lt;/code&gt; 하고 &lt;code&gt;git commit&lt;/code&gt; 단지 바로에 파일 이름을 제공하여 &lt;code&gt;git commit&lt;/code&gt; 로, &lt;code&gt;-i&lt;/code&gt; 플래그 (그것을 위해 힘내 알려줍니다 &lt;code&gt;include&lt;/code&gt; 에서 해당 파일을 커밋을 할 때 지금까지 인덱스 파일에 수행 한 작업에 추가). &lt;code&gt;-m&lt;/code&gt; 플래그는 명령 줄에서 로그 메시지를 커밋 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c1304382231014b423d405b863d67d13d9195107" translate="yes" xml:space="preserve">
          <source>Here, we see that the commits A and C (marked with &lt;code&gt;-&lt;/code&gt;) can be dropped from your &lt;code&gt;topic&lt;/code&gt; branch when you rebase it on top of &lt;code&gt;origin/master&lt;/code&gt;, while the commit B (marked with &lt;code&gt;+&lt;/code&gt;) still needs to be kept so that it will be sent to be applied to &lt;code&gt;origin/master&lt;/code&gt;.</source>
          <target state="translated">여기서 커밋 A와 C ( &lt;code&gt;-&lt;/code&gt; 로 표시 ) 를 &lt;code&gt;origin/master&lt;/code&gt; 위에서 리베이스 할 때 &lt;code&gt;topic&lt;/code&gt; 브랜치 에서 삭제할 수 있지만 커밋 B ( &lt;code&gt;+&lt;/code&gt; 로 표시 )는 계속 유지해야합니다. &lt;code&gt;origin/master&lt;/code&gt; 에 적용되도록 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="0cd618d5ab553d5bba621718fb5b54666be9377a" translate="yes" xml:space="preserve">
          <source>High-level commands (porcelain)</source>
          <target state="translated">고급 명령 (도자기)</target>
        </trans-unit>
        <trans-unit id="1ac4e7d9472a79a55ebc3b6988fb3cc4f954a3f4" translate="yes" xml:space="preserve">
          <source>High-level operations such as &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; and &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt; work by moving data between the working tree, the index, and the object database. Git provides low-level operations which perform each of these steps individually.</source>
          <target state="translated">&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 및 &lt;a href=&quot;git-restore&quot;&gt;git-restore &lt;/a&gt;[1] 과 같은 고급 작업 은 작업 트리, 인덱스 및 개체 데이터베이스간에 데이터를 이동하여 작동합니다. Git은 이러한 각 단계를 개별적으로 수행하는 저수준 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c1ce0c926615015cc35af4d00f9f659a79fd9f67" translate="yes" xml:space="preserve">
          <source>Higher level SCMs may provide and manage additional information in the &lt;code&gt;$GIT_DIR&lt;/code&gt;.</source>
          <target state="translated">상위 레벨 SCM은 &lt;code&gt;$GIT_DIR&lt;/code&gt; 에 추가 정보를 제공하고 관리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd055ea7ea783c3a5765e06b74c033615ebf91a1" translate="yes" xml:space="preserve">
          <source>Highest and slowest compression level. You can specify any number from 1 to 9 to adjust compression speed and ratio.</source>
          <target state="translated">최고 및 최저 압축 수준. 압축 속도와 비율을 조정하기 위해 1에서 9 사이의 숫자를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dca5de829f06af308665d596314f33baa6a08d8b" translate="yes" xml:space="preserve">
          <source>Highlight changed words using only colors. Implies &lt;code&gt;--color&lt;/code&gt;.</source>
          <target state="translated">색상 만 사용하여 변경된 단어를 강조 표시하십시오. &lt;code&gt;--color&lt;/code&gt; 를 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="d265b329d8480dd12ed84fd1552194f9ed45b640" translate="yes" xml:space="preserve">
          <source>Highlight whitespace errors in the &lt;code&gt;context&lt;/code&gt;, &lt;code&gt;old&lt;/code&gt; or &lt;code&gt;new&lt;/code&gt; lines of the diff. Multiple values are separated by comma, &lt;code&gt;none&lt;/code&gt; resets previous values, &lt;code&gt;default&lt;/code&gt; reset the list to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; is a shorthand for &lt;code&gt;old,new,context&lt;/code&gt;. The whitespace errors are colored with &lt;code&gt;color.diff.whitespace&lt;/code&gt;. The command line option &lt;code&gt;--ws-error-highlight=&amp;lt;kind&amp;gt;&lt;/code&gt; overrides this setting.</source>
          <target state="translated">diff 의 &lt;code&gt;context&lt;/code&gt; , &lt;code&gt;old&lt;/code&gt; 또는 &lt;code&gt;new&lt;/code&gt; 줄 에서 공백 오류를 강조 표시 하십시오. 여러 값은 쉼표로 구분되고 &lt;code&gt;none&lt;/code&gt; 이전 값을 재설정하고 &lt;code&gt;default&lt;/code&gt; 목록을 &lt;code&gt;new&lt;/code&gt; 로 재설정 하며 &lt;code&gt;all&lt;/code&gt; &lt;code&gt;old,new,context&lt;/code&gt; 의 약어입니다 . 공백 오류는 &lt;code&gt;color.diff.whitespace&lt;/code&gt; 로 표시 됩니다. 명령 줄 옵션 &lt;code&gt;--ws-error-highlight=&amp;lt;kind&amp;gt;&lt;/code&gt; 가이 설정을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="ad64982f5f47504010208292cc60b059ddb2341b" translate="yes" xml:space="preserve">
          <source>Highlight whitespace errors in the &lt;code&gt;context&lt;/code&gt;, &lt;code&gt;old&lt;/code&gt; or &lt;code&gt;new&lt;/code&gt; lines of the diff. Multiple values are separated by comma, &lt;code&gt;none&lt;/code&gt; resets previous values, &lt;code&gt;default&lt;/code&gt; reset the list to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; is a shorthand for &lt;code&gt;old,new,context&lt;/code&gt;. When this option is not given, and the configuration variable &lt;code&gt;diff.wsErrorHighlight&lt;/code&gt; is not set, only whitespace errors in &lt;code&gt;new&lt;/code&gt; lines are highlighted. The whitespace errors are colored with &lt;code&gt;color.diff.whitespace&lt;/code&gt;.</source>
          <target state="translated">diff 의 &lt;code&gt;context&lt;/code&gt; , &lt;code&gt;old&lt;/code&gt; 또는 &lt;code&gt;new&lt;/code&gt; 줄 에서 공백 오류를 강조 표시 하십시오. 여러 값은 쉼표로 구분되고 &lt;code&gt;none&lt;/code&gt; 이전 값을 재설정하고 &lt;code&gt;default&lt;/code&gt; 목록을 &lt;code&gt;new&lt;/code&gt; 로 재설정 하며 &lt;code&gt;all&lt;/code&gt; &lt;code&gt;old,new,context&lt;/code&gt; 의 약어입니다 . 이 옵션이 제공되지 않고 구성 변수 &lt;code&gt;diff.wsErrorHighlight&lt;/code&gt; 가 설정되지 않은 경우 &lt;code&gt;new&lt;/code&gt; 행의 공백 오류 만 강조 표시됩니다. 공백 오류는 &lt;code&gt;color.diff.whitespace&lt;/code&gt; 로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="dd523af5eca7a4658a007786700bef0bcb653aea" translate="yes" xml:space="preserve">
          <source>Historical options for selecting a type specifier. Prefer instead &lt;code&gt;--type&lt;/code&gt; (see above).</source>
          <target state="translated">유형 지정자를 선택하기위한 히스토리 옵션. 대신 &lt;code&gt;--type&lt;/code&gt; 을 선호 하십시오 (위 참조).</target>
        </trans-unit>
        <trans-unit id="d2946930a6bea40f3723a867347d5f13a7e8b511" translate="yes" xml:space="preserve">
          <source>Historically we did not allow binary patch applied without an explicit permission from the user, and this flag was the way to do so. Currently we always allow binary patch application, so this is a no-op.</source>
          <target state="translated">역사적으로 우리는 사용자의 명시적인 허가없이 바이너리 패치를 적용하는 것을 허용하지 않았으며,이 플래그는 그렇게하는 방법이었습니다. 현재 우리는 항상 이진 패치 응용 프로그램을 허용하므로 이것은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="7f2999a0b05d570915b660b4e452265d6ec70628" translate="yes" xml:space="preserve">
          <source>History Simplification</source>
          <target state="translated">역사 단순화</target>
        </trans-unit>
        <trans-unit id="bcdd29839bed9103f5dae5291b4dd975d75a9cc7" translate="yes" xml:space="preserve">
          <source>History traversing commands such as &lt;code&gt;git log&lt;/code&gt; operate on a set of commits, not just a single commit.</source>
          <target state="translated">&lt;code&gt;git log&lt;/code&gt; 와 같은 히스토리 트래버스 명령 은 단일 커밋이 아닌 일련의 커밋에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="173bd843bbaf623a85e5a648a6a9c500533027fc" translate="yes" xml:space="preserve">
          <source>Honor textconv filter settings.</source>
          <target state="translated">텍스트 변환 필터 설정을 존중하십시오.</target>
        </trans-unit>
        <trans-unit id="be308a87ab32a83ddd6a199c65b0dc7cb4884727" translate="yes" xml:space="preserve">
          <source>Hook for submit</source>
          <target state="translated">제출 후크</target>
        </trans-unit>
        <trans-unit id="4bd8f3f03a576b2088bd73a2339d07fca1de805d" translate="yes" xml:space="preserve">
          <source>Hooks</source>
          <target state="translated">Hooks</target>
        </trans-unit>
        <trans-unit id="99dc1a330d0acc7fd52ca441a6ce9f9284dba47c" translate="yes" xml:space="preserve">
          <source>Hooks are customization scripts used by various Git commands. A handful of sample hooks are installed when &lt;code&gt;git init&lt;/code&gt; is run, but all of them are disabled by default. To enable, the &lt;code&gt;.sample&lt;/code&gt; suffix has to be removed from the filename by renaming. Read &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more details about each hook. This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/hooks&quot; will be used instead.</source>
          <target state="translated">후크는 다양한 Git 명령에서 사용되는 사용자 정의 스크립트입니다. &lt;code&gt;git init&lt;/code&gt; 이 실행될 때 소수의 샘플 후크가 설치 되지만 기본적으로 모든 후크 가 비활성화되어 있습니다. 활성화하려면 파일 이름에서 &lt;code&gt;.sample&lt;/code&gt; 접미사를 이름을 바꿔 제거해야합니다. 각 후크에 대한 자세한 내용은 &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 를 읽으십시오 . $ GIT_COMMON_DIR이 설정되고 대신 &quot;$ GIT_COMMON_DIR / hooks&quot;가 사용되는 경우이 디렉토리는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="06a3036cbe5b8e0ded4c91cf35d4acf2e8ad8f53" translate="yes" xml:space="preserve">
          <source>Hooks are programs you can place in a hooks directory to trigger actions at certain points in git&amp;rsquo;s execution. Hooks that don&amp;rsquo;t have the executable bit set are ignored.</source>
          <target state="translated">후크는 후크 디렉토리에 배치하여 git 실행의 특정 지점에서 작업을 트리거 할 수있는 프로그램입니다. 실행 가능 비트가 설정되지 않은 후크는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="bf9a913e0a40d8bcbb788ae480caabb75549e706" translate="yes" xml:space="preserve">
          <source>Hooks can get their arguments via the environment, command-line arguments, and stdin. See the documentation for each hook below for details.</source>
          <target state="translated">후크는 환경, 명령 행 인수 및 stdin을 통해 인수를 가져올 수 있습니다. 자세한 내용은 아래 각 후크에 대한 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="16c7452920ac3fe30578ebea0bb92b7bf8bbfaa1" translate="yes" xml:space="preserve">
          <source>Host specified as an option to all p4 commands, with &lt;code&gt;-h &amp;lt;host&amp;gt;&lt;/code&gt;. The environment variable &lt;code&gt;P4HOST&lt;/code&gt; can be used instead.</source>
          <target state="translated">&lt;code&gt;-h &amp;lt;host&amp;gt;&lt;/code&gt; 와 함께 모든 p4 명령에 대한 옵션으로 호스트가 지정되었습니다 . 환경 변수 &lt;code&gt;P4HOST&lt;/code&gt; 를 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3a4f74d3860a1e7164c5016083b909a49e9f48e" translate="yes" xml:space="preserve">
          <source>Host/domain name (e.g., &lt;code&gt;example.com&lt;/code&gt; in &lt;code&gt;https://example.com/&lt;/code&gt;). This field must match between the config key and the URL. It is possible to specify a &lt;code&gt;*&lt;/code&gt; as part of the host name to match all subdomains at this level. &lt;code&gt;https://*.example.com/&lt;/code&gt; for example would match &lt;code&gt;https://foo.example.com/&lt;/code&gt;, but not &lt;code&gt;https://foo.bar.example.com/&lt;/code&gt;.</source>
          <target state="translated">호스트 / 도메인 이름 (예를 들어, &lt;code&gt;example.com&lt;/code&gt; 에서 &lt;code&gt;https://example.com/&lt;/code&gt; ). 이 필드는 구성 키와 URL 사이에 일치해야합니다. 이 레벨에서 모든 하위 도메인과 일치하도록 호스트 이름의 일부로 &lt;code&gt;*&lt;/code&gt; 를 지정할 수 있습니다. &lt;code&gt;https://*.example.com/&lt;/code&gt; 예를 들어이 일치합니다 &lt;code&gt;https://foo.example.com/&lt;/code&gt; 을 하지만,하지 &lt;code&gt;https://foo.bar.example.com/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62bb4be23aa04882a53a58830164455da0d43aac" translate="yes" xml:space="preserve">
          <source>How Git stores objects efficiently: pack files</source>
          <target state="translated">Git이 객체를 효율적으로 저장하는 방법 : 파일 팩</target>
        </trans-unit>
        <trans-unit id="fc3082d534384228eeed70dd2356631d4f563e7e" translate="yes" xml:space="preserve">
          <source>How conflicts are presented</source>
          <target state="translated">갈등이 어떻게 나타나는가</target>
        </trans-unit>
        <trans-unit id="632a7344e68629673f46b61122a8d717f4af38d1" translate="yes" xml:space="preserve">
          <source>How does the merge work?</source>
          <target state="translated">병합은 어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="ee0a93def9e459d81d86f0f444af48fed200edd7" translate="yes" xml:space="preserve">
          <source>How many HTTP requests to launch in parallel. Can be overridden by the &lt;code&gt;GIT_HTTP_MAX_REQUESTS&lt;/code&gt; environment variable. Default is 5.</source>
          <target state="translated">병렬로 시작할 HTTP 요청 수 &lt;code&gt;GIT_HTTP_MAX_REQUESTS&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 . 기본값은 5입니다.</target>
        </trans-unit>
        <trans-unit id="88ba6c6b51f5b68d7988ac607f3c426807b883bb" translate="yes" xml:space="preserve">
          <source>How to best handle custom GIT_TRACE_&amp;lt;key&amp;gt; messages?</source>
          <target state="translated">맞춤 GIT_TRACE_ &amp;lt;key&amp;gt; 메시지를 가장 잘 처리하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e6e1af910bb5a856e3b4ead0799265f2a1064f75" translate="yes" xml:space="preserve">
          <source>How to check out a different version of a project</source>
          <target state="translated">다른 버전의 프로젝트를 확인하는 방법</target>
        </trans-unit>
        <trans-unit id="d2b9978a0ab6bcc1a292a13931b1286539811f55" translate="yes" xml:space="preserve">
          <source>How to get a Git repository</source>
          <target state="translated">Git 리포지토리를 얻는 방법</target>
        </trans-unit>
        <trans-unit id="d7d2ba06f3721900039efaca56489e6a84b511d3" translate="yes" xml:space="preserve">
          <source>How to get a Git repository with minimal history</source>
          <target state="translated">최소 히스토리로 Git 저장소를 얻는 방법</target>
        </trans-unit>
        <trans-unit id="6a7eba29926bb4a386242f44bbf4f12c6f691a0c" translate="yes" xml:space="preserve">
          <source>How to make a commit</source>
          <target state="translated">커밋하는 법</target>
        </trans-unit>
        <trans-unit id="a8f8fd0d0e36d30f7fbe331a10b1e8f318a5f903" translate="yes" xml:space="preserve">
          <source>How to merge</source>
          <target state="translated">병합하는 방법</target>
        </trans-unit>
        <trans-unit id="813e8d48c24190b471043b3ab0d44e357c5f2791" translate="yes" xml:space="preserve">
          <source>How to resolve conflicts</source>
          <target state="translated">갈등을 해결하는 방법</target>
        </trans-unit>
        <trans-unit id="93e750cda509aa41796eb9d7a6cb3afbf2365356" translate="yes" xml:space="preserve">
          <source>How to use bisect to find a regression</source>
          <target state="translated">bisect를 사용하여 회귀를 찾는 방법</target>
        </trans-unit>
        <trans-unit id="c54b4ab81b97a7d870be1fb485f52b39766adb14" translate="yes" xml:space="preserve">
          <source>However &amp;mdash; it&amp;rsquo;s such a common thing to &lt;code&gt;fetch&lt;/code&gt; and then immediately &lt;code&gt;merge&lt;/code&gt;, that it&amp;rsquo;s called &lt;code&gt;git pull&lt;/code&gt;, and you can simply do</source>
          <target state="translated">그러나 &amp;mdash; &lt;code&gt;git pull&lt;/code&gt; 이라는 것을 &lt;code&gt;fetch&lt;/code&gt; 즉시 &lt;code&gt;merge&lt;/code&gt; 하는 것은 흔한 일 이며 간단히 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d70de578cd37f18e0cd1ccdb7488c789f08117d4" translate="yes" xml:space="preserve">
          <source>However &amp;mdash; normally you&amp;rsquo;d never use &lt;code&gt;git write-tree&lt;/code&gt; on its own, because normally you always commit a tree into a commit object using the &lt;code&gt;git commit-tree&lt;/code&gt; command. In fact, it&amp;rsquo;s easier to not actually use &lt;code&gt;git write-tree&lt;/code&gt; on its own at all, but to just pass its result in as an argument to &lt;code&gt;git commit-tree&lt;/code&gt;.</source>
          <target state="translated">그러나 일반적으로 항상 &lt;code&gt;git commit-tree&lt;/code&gt; 명령을 사용하여 커밋 객체에 트리를 커밋하기 때문에 &lt;code&gt;git write-tree&lt;/code&gt; 를 단독으로 사용하지는 않습니다 . 실제로 실제로 &lt;code&gt;git write-tree&lt;/code&gt; 를 전혀 사용하지 않고 결과를 &lt;code&gt;git commit-tree&lt;/code&gt; 의 인수로 전달 하는 것이 더 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="b251a49d303741aee81dcafea3be641705e5d2d3" translate="yes" xml:space="preserve">
          <source>However repacking the repository is necessary to improve data locality and access performance. It can also take hours on extremely large projects (especially if -f and a large --window parameter is used). Since repacking is safe to run alongside readers and writers, run the repack in the background and let it finish when it finishes. There is no reason to wait to explore your new Git project!</source>
          <target state="translated">그러나 데이터 지역 및 액세스 성능을 향상 시키려면 리포지토리를 다시 포장해야합니다. 매우 큰 프로젝트 (특히 -f 및 큰 --window 매개 변수를 사용하는 경우)에도 몇 시간이 걸릴 수 있습니다. 리 패킹은 리더 및 라이터와 함께 실행하기에 안전하므로 백그라운드에서 리팩을 실행하고 완료되면 마무리하십시오. 새로운 Git 프로젝트를 탐색 할 때까지 기다릴 이유가 없습니다!</target>
        </trans-unit>
        <trans-unit id="4b948e81d3b66aa74b95ff1de52609dbf8f7d04b" translate="yes" xml:space="preserve">
          <source>However, Git does &lt;strong&gt;not&lt;/strong&gt; (and it should not) change tags behind users back. So if somebody already got the old tag, doing a &lt;code&gt;git pull&lt;/code&gt; on your tree shouldn&amp;rsquo;t just make them overwrite the old one.</source>
          <target state="translated">그러나, 힘내 수행 &lt;strong&gt;하지&lt;/strong&gt; (그리고 안) 다시 사용자의 뒤에 변경 태그입니다. 누군가가 이미 오래된 태그를 가지고 있다면 트리 에서 &lt;code&gt;git pull&lt;/code&gt; 을 수행하면 이전 태그를 덮어 쓰지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="774132ee5dd559ea340879a21fd99f6ff4549c5d" translate="yes" xml:space="preserve">
          <source>However, an understanding of these low-level tools can be helpful if you want to understand Git&amp;rsquo;s internals.</source>
          <target state="translated">그러나 Git의 내부를 이해하려는 경우 이러한 저수준 도구를 이해하면 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="866f600e87142f901a49d55ea62ea322295c395d" translate="yes" xml:space="preserve">
          <source>However, if the --combined-all-paths option is provided, instead of a two-line from-file/to-file you get a N+1 line from-file/to-file header, where N is the number of parents in the merge commit</source>
          <target state="translated">그러나 --combined-all-paths 옵션이 제공되면 두 줄의 시작 파일 / 파일 대신 N + 1 행의 파일 / 파일 헤더가 표시됩니다. 여기서 N은 병합 커밋의 부모</target>
        </trans-unit>
        <trans-unit id="24c47b91e42f0b5da2ef1b1de98db109a45643ab" translate="yes" xml:space="preserve">
          <source>However, if the current branch is an ancestor of the other&amp;mdash;​so every commit present in the current branch is already contained in the other branch&amp;mdash;​then Git just performs a &quot;fast-forward&quot;; the head of the current branch is moved forward to point at the head of the merged-in branch, without any new commits being created.</source>
          <target state="translated">그러나 현재 브랜치가 다른 브랜치의 조상 인 경우 (현재 브랜치에있는 모든 커밋이 이미 다른 브랜치에 포함 된 경우) Git은 단지 &quot;빨리 감기&quot;를 수행합니다. 현재 분기의 헤드는 새로운 커밋을 만들지 않고 병합 된 분기의 헤드를 가리 키도록 앞으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="38320aec0b4074b6ba1fc6f9446c9d65a3296509" translate="yes" xml:space="preserve">
          <source>However, if the file is absent from the tree of some commit, a simple &lt;code&gt;rm filename&lt;/code&gt; will fail for that tree and commit. Thus you may instead want to use &lt;code&gt;rm -f filename&lt;/code&gt; as the script.</source>
          <target state="translated">그러나 파일이 일부 커밋 트리에없는 경우 해당 트리에 대해 간단한 &lt;code&gt;rm filename&lt;/code&gt; 이 실패하고 커밋됩니다. 따라서 대신 &lt;code&gt;rm -f filename&lt;/code&gt; 을 스크립트로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="083d51e29026b4e1a08bfd658353fe31999e3907" translate="yes" xml:space="preserve">
          <source>However, if you decide to jump to a new version, or check out somebody else&amp;rsquo;s version, or just restore a previous tree, you&amp;rsquo;d populate your index file with read-tree, and then you need to check out the result with</source>
          <target state="translated">그러나 새 버전으로 이동하거나 다른 사람의 버전을 확인하거나 이전 트리를 복원하려는 경우 인덱스 파일을 읽기 트리로 채우고 결과를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="d73cbcd65f07eabb528955f0d408caeaef9ec132" translate="yes" xml:space="preserve">
          <source>However, if you have local changes in the working tree that would be overwritten by this merge, &lt;code&gt;git read-tree&lt;/code&gt; will refuse to run to prevent your changes from being lost.</source>
          <target state="translated">그러나이 병합으로 덮어 쓰는 작업 트리에 로컬 변경 사항이있는 경우 &lt;code&gt;git read-tree&lt;/code&gt; 는 변경 사항이 손실되지 않도록 실행을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="0f801baa64ce652ffc6d36336f6a234c862e64a0" translate="yes" xml:space="preserve">
          <source>However, if you prefer to keep the history in mywork a simple series of commits without any merges, you may instead choose to use &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;:</source>
          <target state="translated">그러나 mywork에서 히스토리를 병합없이 간단한 일련의 커밋으로 유지하려면 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; 사용하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a9f204773ec4f6bc12691a9ec080236d437d186" translate="yes" xml:space="preserve">
          <source>However, if you really only want to replace the line for the default proxy, i.e. the one without a &quot;for &amp;hellip;​&quot; postfix, do something like this:</source>
          <target state="translated">그러나 기본 프록시 (예 : &quot;...&quot;접미사가없는 행) 만 바꾸려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="fe54b4a5cce25da95a527e803024815678af4c5c" translate="yes" xml:space="preserve">
          <source>However, if you skip a commit adjacent to the one you are looking for, Git will be unable to tell exactly which of those commits was the first bad one.</source>
          <target state="translated">그러나 찾고있는 커밋과 인접한 커밋을 건너 뛰면 Git은 커밋 중 어느 것이 첫 번째 나쁜 커밋인지 정확하게 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e9adef201cc69834664c04ac9c044e6acc3b8daa" translate="yes" xml:space="preserve">
          <source>However, it is not necessary to create branches in p4 to be able to use them like branches. Because it is difficult to infer branch relationships automatically, a Git configuration setting &lt;code&gt;git-p4.branchList&lt;/code&gt; can be used to explicitly identify branch relationships. It is a list of &quot;source:destination&quot; pairs, like a simple p4 branch specification, where the &quot;source&quot; and &quot;destination&quot; are the path elements in the p4 repository. The example above relied on the presence of the p4 branch. Without p4 branches, the same result will occur with:</source>
          <target state="translated">그러나 p4에서 브랜치를 사용하기 위해 브랜치를 생성 할 필요는 없습니다. 분기 관계를 자동으로 유추하기 어렵 기 때문에 Git 구성 설정 &lt;code&gt;git-p4.branchList&lt;/code&gt; 를 사용하여 분기 관계를 명시 적으로 식별 할 수 있습니다. 간단한 p4 분기 스펙과 같이 &quot;source : destination&quot;쌍의 목록입니다. 여기서 &quot;source&quot;및 &quot;destination&quot;은 p4 저장소의 경로 요소입니다. 위의 예는 p4 브랜치의 존재에 의존했습니다. p4 분기가 없으면 동일한 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c71bf4b100c16d667a048d4524ffef40edf8598e" translate="yes" xml:space="preserve">
          <source>However, one may also want to specify other diff driver attributes. For example, you might want to use &lt;code&gt;textconv&lt;/code&gt; to convert postscript files to an ASCII representation for human viewing, but otherwise treat them as binary files. You cannot specify both &lt;code&gt;-diff&lt;/code&gt; and &lt;code&gt;diff=ps&lt;/code&gt; attributes. The solution is to use the &lt;code&gt;diff.*.binary&lt;/code&gt; config option:</source>
          <target state="translated">그러나 다른 diff 드라이버 속성을 지정할 수도 있습니다. 예를 들어 &lt;code&gt;textconv&lt;/code&gt; 를 사용 하여 포스트 스크립트 파일을 사람이 볼 수 있도록 ASCII 표현으로 변환 할 수 있지만 이진 파일로 처리 할 수 ​​있습니다. &lt;code&gt;-diff&lt;/code&gt; 및 &lt;code&gt;diff=ps&lt;/code&gt; 속성을 모두 지정할 수 없습니다 . 해결 방법은 &lt;code&gt;diff.*.binary&lt;/code&gt; 구성 옵션 을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c15b1eea7ada51b9540f36c6d7433749c2518719" translate="yes" xml:space="preserve">
          <source>However, our next step is to commit the &lt;strong&gt;change&lt;/strong&gt; we did, and again, to understand what&amp;rsquo;s going on, keep in mind the difference between &quot;working tree contents&quot;, &quot;index file&quot; and &quot;committed tree&quot;. We have changes in the working tree that we want to commit, and we always have to work through the index file, so the first thing we need to do is to update the index cache:</source>
          <target state="translated">그러나 다음 단계는 &lt;strong&gt;변경 내용&lt;/strong&gt; 을 커밋하고 진행 상황을 이해하기 위해 &quot;작업 트리 내용&quot;, &quot;인덱스 파일&quot;및 &quot;커밋 된 트리&quot;의 차이점을 명심하십시오. 작업 트리에 커밋하려는 변경 사항이 있으며 항상 인덱스 파일을 통해 작업해야하므로 인덱스 캐시를 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="066e262ce5d073a40098065a4bfe593a37b357ee" translate="yes" xml:space="preserve">
          <source>However, since Git knows about them, you can now start using some of the most basic Git commands to manipulate the files or look at their status.</source>
          <target state="translated">그러나 Git은 이에 대해 알고 있으므로 이제 가장 기본적인 Git 명령을 사용하여 파일을 조작하거나 파일 상태를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d4b86f86d3381add9d6753c2a6a37207cb69976" translate="yes" xml:space="preserve">
          <source>However, the &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; command provides a way to do this in one step:</source>
          <target state="translated">그러나 &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt; 명령은 한 단계로이를 수행하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b2062c8611299450fbfa8b88f93e46840eed9772" translate="yes" xml:space="preserve">
          <source>However, the commits do not form a simple list; Git allows lines of development to diverge and then reconverge, and the point where two lines of development reconverge is called a &quot;merge&quot;. The commit representing a merge can therefore have more than one parent, with each parent representing the most recent commit on one of the lines of development leading to that point.</source>
          <target state="translated">그러나 커밋은 간단한 목록을 형성하지 않습니다. 힘내 개발 라인을 분기하고 다시 수렴하고 두 개발 라인이 수렴하는 지점을 &quot;병합&quot;이라고합니다. 따라서 병합을 나타내는 커밋에는 둘 이상의 부모가있을 수 있으며 각 부모는 해당 시점으로 이어지는 개발 라인 중 하나에서 가장 최근의 커밋을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dc3c84ebe58db76ac38c1e3a6d7daded7c305410" translate="yes" xml:space="preserve">
          <source>However, the more common way to do this is to maintain a separate public repository (usually on a different host) for others to pull changes from. This is usually more convenient, and allows you to cleanly separate private work in progress from publicly visible work.</source>
          <target state="translated">그러나이 작업을 수행하는 가장 일반적인 방법은 다른 사람이 변경 사항을 가져올 수 있도록 별도의 공용 리포지토리 (일반적으로 다른 호스트에 있음)를 유지 관리하는 것입니다. 이것은 일반적으로 더 편리하며 진행중인 개인 작업을 공개적으로 보이는 작업과 깨끗하게 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="755c039a0c20727e4839caf6deef253d613f16de" translate="yes" xml:space="preserve">
          <source>However, there are cases in which your local changes do conflict with the upstream changes, and &lt;code&gt;git pull&lt;/code&gt; refuses to overwrite your changes. In such a case, you can stash your changes away, perform a pull, and then unstash, like this:</source>
          <target state="translated">그러나 로컬 변경 사항이 업스트림 변경 사항과 충돌하는 경우가 있으며 &lt;code&gt;git pull&lt;/code&gt; 이 변경 사항을 덮어 쓰지 않습니다. 이 경우 다음과 같이 변경 사항을 숨기고 풀을 수행 한 다음 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e43d419a26518c38e69ee02a5a541b221da6c649" translate="yes" xml:space="preserve">
          <source>However, there are legitimate reasons why a developer may want to recreate merge commits: to keep the branch structure (or &quot;commit topology&quot;) when working on multiple, inter-related branches.</source>
          <target state="translated">그러나 개발자가 병합 커밋을 다시 만들려는 합당한 이유가 있습니다. 여러 개의 상호 관련 분기에서 작업 할 때 분기 구조 (또는 &quot;커밋 토폴로지&quot;)를 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="89adb927099ba4a8289673a41ab8ec24ea6e4abd" translate="yes" xml:space="preserve">
          <source>However, there is a situation in which it can be useful to violate this assumption.</source>
          <target state="translated">그러나이 가정을 위반하는 것이 유용 할 수있는 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b068287d80433091fc93a07d4af49d57d3676c5d" translate="yes" xml:space="preserve">
          <source>However, there is no particular reason to merge in one branch first and the other next, when what you have are a set of truly independent changes (if the order mattered, then they are not independent by definition). You could instead merge those two branches into the current branch at once. First let&amp;rsquo;s undo what we just did and start over. We would want to get the master branch before these two merges by resetting it to &lt;code&gt;master~2&lt;/code&gt;:</source>
          <target state="translated">그러나, 당신이 가지고있는 것이 진정으로 독립적 인 변화의 집합 일 때 (하나의 순서가 중요하다면, 그것들은 정의에 의해 독립적이지 않은) 하나의 브랜치를 먼저 병합하고 다른 브랜치를 병합 할 특별한 이유가 없습니다. 대신 두 분기를 현재 분기로 한 번에 병합 할 수 있습니다. 먼저 방금 수행 한 작업을 취소하고 다시 시작하겠습니다. 우리는이 두 병합 전에 마스터 분기를 &lt;code&gt;master~2&lt;/code&gt; 로 재설정하여 가져오고 싶습니다 .</target>
        </trans-unit>
        <trans-unit id="76dbad7bbd23560fcc8351e42a22aad055901cd6" translate="yes" xml:space="preserve">
          <source>However, these features fall short of a complete solution, so users who run commands concurrently have to live with some risk of corruption (which seems to be low in practice).</source>
          <target state="translated">그러나 이러한 기능은 완벽한 솔루션을 갖추지 못하므로 명령을 동시에 실행하는 사용자는 약간의 손상 위험이 있습니다 (실제로는 낮은 것 같습니다).</target>
        </trans-unit>
        <trans-unit id="f41fcda082e8874086be41192b1abbea2d3295da" translate="yes" xml:space="preserve">
          <source>However, this is &lt;strong&gt;NOT&lt;/strong&gt; allowed for switches with an optional value, where the &lt;code&gt;stuck&lt;/code&gt; form must be used:</source>
          <target state="translated">그러나이 값은 &lt;code&gt;stuck&lt;/code&gt; 양식을 사용해야 하는 선택적 값이있는 스위치에는 허용 &lt;strong&gt;되지&lt;/strong&gt; 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4da9d9ef7c6a0e88df4192c01891a87d88664b48" translate="yes" xml:space="preserve">
          <source>However, this is only a convention, and you can name your branches anything you want, and don&amp;rsquo;t have to ever even &lt;code&gt;have&lt;/code&gt; a &lt;code&gt;master&lt;/code&gt; branch. A number of the Git tools will assume that &lt;code&gt;.git/HEAD&lt;/code&gt; is valid, though.</source>
          <target state="translated">그러나 이것은 컨벤션 일 뿐이므로 원하는 이름으로 지점 이름을 지정할 수 있으며 &lt;code&gt;master&lt;/code&gt; 브랜치를 &lt;code&gt;have&lt;/code&gt; 필요도 없습니다 . 많은 Git 도구는 &lt;code&gt;.git/HEAD&lt;/code&gt; 가 유효 하다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="a7abfde622702125ddcfca8f6b53cf2f29202a6d" translate="yes" xml:space="preserve">
          <source>However, this last command can be dangerous in some cases&amp;mdash;​never throw away a commit you have already committed if that commit may itself have been merged into another branch, as doing so may confuse further merges.</source>
          <target state="translated">그러나이 마지막 명령은 경우에 따라 위험 할 수 있습니다. 커밋 자체가 다른 브랜치에 병합되었을 경우 이미 커밋 한 커밋을 버리지 마십시오. 그렇게하면 추가 병합이 혼동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba574b0c600bcf4947d9fc0b827ea5d5666b3028" translate="yes" xml:space="preserve">
          <source>However, when no confusion will result, we often just use the term &quot;branch&quot; both for branches and for branch heads.</source>
          <target state="translated">그러나 혼동이 없을 때 종종 분기와 분기 헤드 모두에 &quot;분기&quot;라는 용어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2952d19c4dc617ab4a4ae6abe65c729f11b54f82" translate="yes" xml:space="preserve">
          <source>However, when you do &lt;code&gt;git read-tree&lt;/code&gt; with three trees, the &quot;stage&quot; starts out at 1.</source>
          <target state="translated">그러나 세 개의 나무로 &lt;code&gt;git read-tree&lt;/code&gt; 를 수행 하면 &quot;stage&quot;는 1부터 시작합니다.</target>
        </trans-unit>
        <trans-unit id="28dd1f9126b301b96d86409d92ae4b0d38938148" translate="yes" xml:space="preserve">
          <source>However, while there is nothing wrong with Git&amp;rsquo;s support for shared repositories, this mode of operation is not generally recommended, simply because the mode of collaboration that Git supports&amp;mdash;​by exchanging patches and pulling from public repositories&amp;mdash;​has so many advantages over the central shared repository:</source>
          <target state="translated">그러나 Git의 공유 리포지토리 지원에는 아무런 문제가 없지만 패치를 교환하고 퍼블릭 리포지토리에서 가져 와서 Git이 지원하는 공동 작업 모드가 Git에서 지원하는 공동 작업 모드는 일반적으로 권장되지 않습니다. 중앙 공유 저장소 :</target>
        </trans-unit>
        <trans-unit id="6ee73f3ad469e31cc982a856f9ec909f123f7a3b" translate="yes" xml:space="preserve">
          <source>However, you already dirtied the index (i.e. your index does not match the &lt;code&gt;HEAD&lt;/code&gt; commit). But you know the pull you are going to make does not affect &lt;code&gt;frotz.c&lt;/code&gt; or &lt;code&gt;filfre.c&lt;/code&gt;, so you revert the index changes for these two files. Your changes in working tree remain there.</source>
          <target state="translated">그러나 이미 색인을 더럽 혔습니다 (예 : 색인이 &lt;code&gt;HEAD&lt;/code&gt; 커밋 과 일치하지 않음 ). 그러나 당기 &lt;code&gt;frotz.c&lt;/code&gt; 또는 &lt;code&gt;filfre.c&lt;/code&gt; 에 영향을 미치지 않으므로이 두 파일의 인덱스 변경 사항을 되돌 립니다 . 작업 트리의 변경 사항은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9e2e4a0fcb3942d8a82c6a2331932351c7c8a259" translate="yes" xml:space="preserve">
          <source>However, your &quot;wrong&quot; branch and correct &quot;mytopic&quot; branch may differ in files that you have modified locally, in which case the above switch would fail like this:</source>
          <target state="translated">그러나 &quot;잘못된&quot;분기와 올바른 &quot;mytopic&quot;분기는 로컬에서 수정 한 파일이 다를 수 있습니다.이 경우 위의 스위치는 다음과 같이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="6a9281c350a487a356b48bdfa67abfef81982489" translate="yes" xml:space="preserve">
          <source>However, your &quot;wrong&quot; branch and correct &lt;code&gt;mytopic&lt;/code&gt; branch may differ in files that you have modified locally, in which case the above checkout would fail like this:</source>
          <target state="translated">그러나 &quot;잘못된&quot;분기와 올바른 &lt;code&gt;mytopic&lt;/code&gt; 분기는 로컬에서 수정 한 파일이 다를 수 있습니다.이 경우 위의 체크 아웃은 다음과 같이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="eaf133288702a5baf1a98928a127236dfad5386f" translate="yes" xml:space="preserve">
          <source>I most actively use it during the merge window (when a lot of trees get merged upstream and when the influx of bugs is the highest) - and yes, there have been cases that i used it multiple times a day. My average is roughly once a day.</source>
          <target state="translated">병합 창에서 가장 적극적으로 사용합니다 (많은 나무가 업스트림으로 병합되고 버그 유입이 가장 높은 경우). 그렇습니다. 하루에 여러 번 사용한 경우가 있습니다. 내 평균은 대략 하루에 한 번입니다.</target>
        </trans-unit>
        <trans-unit id="27777a39e933776b5c584d121830042fbc955f15" translate="yes" xml:space="preserve">
          <source>I.e. a fast-forward of commits and tags outside &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; is allowed, even in cases where what&amp;rsquo;s being fast-forwarded is not a commit, but a tag object which happens to point to a new commit which is a fast-forward of the commit the last tag (or commit) it&amp;rsquo;s replacing. Replacing a tag with an entirely different tag is also allowed, if it points to the same commit, as well as pushing a peeled tag, i.e. pushing the commit that existing tag object points to, or a new tag object which an existing commit points to.</source>
          <target state="translated">즉, &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 외부의 커밋 및 태그의 빨리 감기 는 허용되지만, 빨리 감기 되는 것이 커밋이 아닌 새로운 커밋을 가리키는 태그 객체 인 경우에도 허용됩니다. 대체하는 커밋의 마지막 태그 (또는 커밋)를 빨리 감습니다. 태그가 동일한 커밋을 가리키고 벗겨진 태그를 푸시하는 것 (예 : 기존 태그 오브젝트가 가리키는 커밋 또는 기존 커밋이 가리키는 새 태그 오브젝트)을 태그하는 경우 완전히 다른 태그로 태그를 교체하는 것도 허용됩니다. .</target>
        </trans-unit>
        <trans-unit id="f6dcea8e2840d6db982f7ea79204e026c88b3ea6" translate="yes" xml:space="preserve">
          <source>I.e. create a &lt;code&gt;base&lt;/code&gt; tag for versions of the upstream code that you&amp;rsquo;ve seen and are willing to overwrite, then rewrite history, and finally force push changes to &lt;code&gt;master&lt;/code&gt; if the remote version is still at &lt;code&gt;base&lt;/code&gt;, regardless of what your local &lt;code&gt;remotes/origin/master&lt;/code&gt; has been updated to in the background.</source>
          <target state="translated">즉, 보았고 기꺼이 덮어 쓴 다음 업스트림 코드 버전에 대한 &lt;code&gt;base&lt;/code&gt; 태그를 작성하고 로컬 &lt;code&gt;remotes/origin/master&lt;/code&gt; 관계없이 원격 버전이 여전히 &lt;code&gt;base&lt;/code&gt; 있으면 변경 사항을 &lt;code&gt;master&lt;/code&gt; 강제 변경합니다. / master 가 백그라운드에서 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="d160035a43dfa655c4a6e47190220d072175392c" translate="yes" xml:space="preserve">
          <source>IOW, you can use this thing to look for likely duplicate commits.</source>
          <target state="translated">IOW,이 것을 사용하여 중복 커밋을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="445867d9c88cb9ec795d4d1edb4358f7f32ed23d" translate="yes" xml:space="preserve">
          <source>ISO 8601</source>
          <target state="translated">ISO 8601</target>
        </trans-unit>
        <trans-unit id="8927163ad4efa8aea54b9b8e320ebffea4053ff8" translate="yes" xml:space="preserve">
          <source>Id of a tree-ish.</source>
          <target state="translated">나무 같은 것.</target>
        </trans-unit>
        <trans-unit id="f64266dea77070f77d87b89cb3f30c2d11210170" translate="yes" xml:space="preserve">
          <source>Identifier terminology</source>
          <target state="translated">식별자 용어</target>
        </trans-unit>
        <trans-unit id="2dd468355239de3fa1d047b407c0f3c35e4315ad" translate="yes" xml:space="preserve">
          <source>Identity-specific versions of the &lt;code&gt;sendemail.*&lt;/code&gt; parameters found below, taking precedence over those when this identity is selected, through either the command-line or &lt;code&gt;sendemail.identity&lt;/code&gt;.</source>
          <target state="translated">아래 에있는 &lt;code&gt;sendemail.*&lt;/code&gt; 매개 변수 의 신원 별 버전은 명령 행 또는 &lt;code&gt;sendemail.identity&lt;/code&gt; 를 통해이 신원을 선택할 때 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="05103278665252bd3225a3f315ada6e006bd41ae" translate="yes" xml:space="preserve">
          <source>If &amp;ldquo;:&amp;lt;funcname&amp;gt;&amp;rdquo; is given in place of &amp;lt;start&amp;gt; and &amp;lt;end&amp;gt;, it is a regular expression that denotes the range from the first funcname line that matches &amp;lt;funcname&amp;gt;, up to the next funcname line. &amp;ldquo;:&amp;lt;funcname&amp;gt;&amp;rdquo; searches from the end of the previous &lt;code&gt;-L&lt;/code&gt; range, if any, otherwise from the start of file. &amp;ldquo;^:&amp;lt;funcname&amp;gt;&amp;rdquo; searches from the start of file.</source>
          <target state="translated">&amp;lt;start&amp;gt; 및 &amp;lt;end&amp;gt; 대신&amp;ldquo;: &amp;lt;funcname&amp;gt;&amp;rdquo;이 지정된 경우 &amp;lt;funcname&amp;gt;과 일치하는 첫 번째 funcname 행부터 다음 funcname 행까지의 범위를 나타내는 정규식입니다. &amp;ldquo;: &amp;lt;funcname&amp;gt;&amp;rdquo;은 이전 &lt;code&gt;-L&lt;/code&gt; 범위 의 끝에서 검색 합니다 (있는 경우). 그렇지 않으면 파일 시작에서 검색합니다. &amp;ldquo;^ : &amp;lt;funcname&amp;gt;&amp;rdquo;은 파일 시작 부분에서 검색합니다.</target>
        </trans-unit>
        <trans-unit id="a70081d33e7c2f9862444b9de88b6fa456d0c4eb" translate="yes" xml:space="preserve">
          <source>If &amp;lt;branch&amp;gt; is specified, &lt;code&gt;git rebase&lt;/code&gt; will perform an automatic &lt;code&gt;git switch &amp;lt;branch&amp;gt;&lt;/code&gt; before doing anything else. Otherwise it remains on the current branch.</source>
          <target state="translated">&amp;lt;branch&amp;gt;가 지정되면 &lt;code&gt;git rebase&lt;/code&gt; 는 다른 작업을 수행하기 전에 자동 &lt;code&gt;git switch &amp;lt;branch&amp;gt;&lt;/code&gt; 를 수행합니다. 그렇지 않으면 현재 분기에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="441a1b498aa3709837145817fb556c2b9312d349" translate="yes" xml:space="preserve">
          <source>If &amp;lt;commit-ish&amp;gt; is a branch name (call it &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;) and is not found, and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; are used, but there does exist a tracking branch in exactly one remote (call it &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;) with a matching name, treat as equivalent to:</source>
          <target state="translated">&amp;lt;commit-ish&amp;gt;가 분기 이름이고 ( &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 라고 함 ) 찾을 수없고 &lt;code&gt;-b&lt;/code&gt; 도 &lt;code&gt;-B&lt;/code&gt; 도 &lt;code&gt;--detach&lt;/code&gt; 도 사용되지 않지만 정확히 하나의 리모트에 추적 분기가있는 경우 (호출) 이름이 일치하는 &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; )는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a2dfa99d3d5ae08ba34d86a50dd72c99c275182b" translate="yes" xml:space="preserve">
          <source>If &amp;lt;dst&amp;gt; does not match any remote ref, either</source>
          <target state="translated">&amp;lt;dst&amp;gt;가 원격 참조와 일치하지 않으면</target>
        </trans-unit>
        <trans-unit id="a47c4a8533ef20594cec62184911d5ccc54294bc" translate="yes" xml:space="preserve">
          <source>If &amp;lt;dst&amp;gt; doesn&amp;rsquo;t start with &lt;code&gt;refs/&lt;/code&gt; (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) we will try to infer where in &lt;code&gt;refs/*&lt;/code&gt; on the destination &amp;lt;repository&amp;gt; it belongs based on the type of &amp;lt;src&amp;gt; being pushed and whether &amp;lt;dst&amp;gt; is ambiguous.</source>
          <target state="translated">&amp;lt;dst&amp;gt;가 &lt;code&gt;refs/&lt;/code&gt; 시작하지 않는 경우 (예 : &lt;code&gt;refs/heads/master&lt;/code&gt; ) 목적지 &amp;lt;repository&amp;gt;의 &lt;code&gt;refs/*&lt;/code&gt; 에서 &amp;lt;src&amp;gt;의 유형과 &amp;lt;src&amp;gt;의 유형 및 &amp;lt; dst&amp;gt;가 모호합니다.</target>
        </trans-unit>
        <trans-unit id="055e400548fbd1f8dd3a927bc48c7fba28571578" translate="yes" xml:space="preserve">
          <source>If &amp;lt;dst&amp;gt; unambiguously refers to a ref on the &amp;lt;repository&amp;gt; remote, then push to that ref.</source>
          <target state="translated">&amp;lt;dst&amp;gt;가 &amp;lt;repository&amp;gt; 리모콘의 참조를 모호하지 않으면 해당 참조로 푸시하십시오.</target>
        </trans-unit>
        <trans-unit id="2f8ca0e0f80952529303f3d2318f597064384182" translate="yes" xml:space="preserve">
          <source>If &amp;lt;src&amp;gt; resolves to a ref starting with refs/heads/ or refs/tags/, then prepend that to &amp;lt;dst&amp;gt;.</source>
          <target state="translated">&amp;lt;src&amp;gt;가 refs / heads / 또는 refs / tags /로 시작하는 ref로 해석되면, &amp;lt;dst&amp;gt; 앞에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="22f62b9091f5d458969b188b7b4383b4ee480486" translate="yes" xml:space="preserve">
          <source>If &amp;lt;start&amp;gt; or &amp;lt;end&amp;gt; is a number, it specifies an absolute line number (lines count from 1).</source>
          <target state="translated">&amp;lt;start&amp;gt; 또는 &amp;lt;end&amp;gt;가 숫자 인 경우 절대 줄 번호를 지정합니다 (줄은 1부터 계산).</target>
        </trans-unit>
        <trans-unit id="3dcd00aaff1f71fc43821b3cae7ba5d1996fda2a" translate="yes" xml:space="preserve">
          <source>If &amp;lt;type&amp;gt; is specified, the raw (though uncompressed) contents of the &amp;lt;object&amp;gt; will be returned.</source>
          <target state="translated">&amp;lt;type&amp;gt;을 지정하면 &amp;lt;object&amp;gt;의 원시 (압축되지 않은) 내용이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="099d6bbda7b3ea83e2000830c8cd48d38a505e41" translate="yes" xml:space="preserve">
          <source>If &amp;lt;upstream&amp;gt; is not specified, the upstream configured in branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge options will be used (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details) and the &lt;code&gt;--fork-point&lt;/code&gt; option is assumed. If you are currently not on any branch or if the current branch does not have a configured upstream, the rebase will abort.</source>
          <target state="translated">&amp;lt;upstream&amp;gt;을 지정하지 않으면 branch. &amp;lt;name&amp;gt; .remote 및 branch. &amp;lt;name&amp;gt; .merge 옵션에 구성된 업스트림 (자세한 내용은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 참조) 및 &lt;code&gt;--fork-point&lt;/code&gt; 옵션이 사용됩니다. 가정합니다. 현재 지점에 없거나 현재 지점에 업스트림이 구성되어 있지 않으면 리베이스가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="217621e5abfa606810a09d87aaa6c7fa540fc0fa" translate="yes" xml:space="preserve">
          <source>If --base-path is enabled and repo lookup fails, with this option &lt;code&gt;git daemon&lt;/code&gt; will attempt to lookup without prefixing the base path. This is useful for switching to --base-path usage, while still allowing the old paths.</source>
          <target state="translated">--base-path가 활성화되어 있고 repo 조회가 실패하면이 옵션을 사용하여 &lt;code&gt;git daemon&lt;/code&gt; 은 기본 경로의 접두사없이 조회를 시도합니다. 이는 기존 경로를 계속 허용하면서 --base-path 사용법으로 전환하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8fc1cea1e55be69663b951a920323d5b77c212cc" translate="yes" xml:space="preserve">
          <source>If --follow-symlinks is used, and a symlink in the repository points outside the repository, then &lt;code&gt;cat-file&lt;/code&gt; will ignore any custom format and print:</source>
          <target state="translated">--follow-symlinks가 사용되고 저장소의 symlink가 저장소 외부를 가리키는 경우 &lt;code&gt;cat-file&lt;/code&gt; 은 사용자 정의 형식을 무시하고 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="100e053a72420596d3d8e1af3be6193b59283565" translate="yes" xml:space="preserve">
          <source>If --follow-symlinks is used, the following error messages will be displayed:</source>
          <target state="translated">--follow-symlinks를 사용하면 다음 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5af2f9fd35f6354ba06f2224c3a1950a1f2e9539" translate="yes" xml:space="preserve">
          <source>If --no-deref is given, &amp;lt;ref&amp;gt; itself is overwritten, rather than the result of following the symbolic pointers.</source>
          <target state="translated">--no-deref를 지정하면 기호 포인터를 따른 결과가 아니라 &amp;lt;ref&amp;gt; 자체를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="09e3aecc968d12fb9705beff5237174e03c29bc7" translate="yes" xml:space="preserve">
          <source>If --porcelain is used, then each line of the output is of the form:</source>
          <target state="translated">--porcelain을 사용하는 경우 출력의 각 줄은 다음과 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="f6d2b768e06f422855acdd627f6c6194c3c0ef9e" translate="yes" xml:space="preserve">
          <source>If --prune-empty is specified, sometimes empty commits are missed and left around anyway (a somewhat rare bug, but it happens&amp;hellip;​)</source>
          <target state="translated">--prune-empty를 지정하면 빈 커밋이 누락되어 어쨌든 남습니다 (약간 드문 버그이지만 발생합니다 ...)</target>
        </trans-unit>
        <trans-unit id="e22868793c21cef41b42f4d8e7236df1fabd77b0" translate="yes" xml:space="preserve">
          <source>If --prune-empty is specified, then intentionally placed empty commits from before the filtering operation are also pruned instead of just pruning commits that became empty due to filtering rules.</source>
          <target state="translated">--prune-empty를 지정하면 필터링 규칙으로 인해 비워진 커밋을 정리하는 대신 필터링 작업을 시작하기 전에 의도적으로 빈 커밋을 배치합니다.</target>
        </trans-unit>
        <trans-unit id="a5f91d56ff44d75c2f6264bd8bf6a44ba8095c27" translate="yes" xml:space="preserve">
          <source>If --prune-empty isn&amp;rsquo;t specified, then the filtering process can create hoards of confusing empty commits</source>
          <target state="translated">--prune-empty를 지정하지 않으면 필터링 프로세스로 인해 빈 커밋이 혼동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d1fd147af59c1bbe70034d2e19205e4683ec22e" translate="yes" xml:space="preserve">
          <source>If --refresh finds unmerged changes in the index, the default behavior is to error out. This option makes &lt;code&gt;git update-index&lt;/code&gt; continue anyway.</source>
          <target state="translated">--refresh가 인덱스에서 병합되지 않은 변경 사항을 찾으면 기본 동작은 오류입니다. 이 옵션은 &lt;code&gt;git update-index&lt;/code&gt; 를 계속 진행시킵니다.</target>
        </trans-unit>
        <trans-unit id="a1d97a45ebe920517b85d93c5180821e570038df" translate="yes" xml:space="preserve">
          <source>If -b is used the short-format status is preceded by a line</source>
          <target state="translated">-b를 사용하면 짧은 형식 상태 앞에 줄이옵니다.</target>
        </trans-unit>
        <trans-unit id="a46e8db06d3992e975f7697afc61f277e4b431aa" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; or &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; is not selecting the key you want it to automatically when creating a signed tag or commit, you can override the default selection with this variable. This option is passed unchanged to gpg&amp;rsquo;s --local-user parameter, so you may specify a key using any method that gpg supports.</source>
          <target state="translated">경우 &lt;a href=&quot;git-tag&quot;&gt;자식 태그 [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-commit&quot;&gt;[1] 자식이 커밋&lt;/a&gt; 키를 선택하지 않는 당신이 자동으로 서명 된 태그를 만들거나 커밋 할 때 원하는,이 변수로 기본 선택을 무시할 수 있습니다. 이 옵션은 변경되지 않고 gpg의 --local-user 매개 변수로 전달되므로 gpg가 지원하는 방법을 사용하여 키를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cf1a7ea3bd0bf42d7200bd0e5a09fa57461a419" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$GIT_DIR/&amp;lt;refname&amp;gt;&lt;/code&gt; exists, that is what you mean (this is usually useful only for &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;FETCH_HEAD&lt;/code&gt;, &lt;code&gt;ORIG_HEAD&lt;/code&gt;, &lt;code&gt;MERGE_HEAD&lt;/code&gt; and &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt;);</source>
          <target state="translated">경우 &lt;code&gt;$GIT_DIR/&amp;lt;refname&amp;gt;&lt;/code&gt; 당신이 무엇을 의미하는지 즉, 존재 (이것은 단지에 일반적으로 유용 &lt;code&gt;HEAD&lt;/code&gt; , &lt;code&gt;FETCH_HEAD&lt;/code&gt; , &lt;code&gt;ORIG_HEAD&lt;/code&gt; , &lt;code&gt;MERGE_HEAD&lt;/code&gt; 및 &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; );</target>
        </trans-unit>
        <trans-unit id="393d945c97962e065f70f0c395a4b7cc04c58275" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$GIT_DIR&lt;/code&gt; is not defined and the current directory is not detected to lie in a Git repository or work tree print a message to stderr and exit with nonzero status.</source>
          <target state="translated">경우 &lt;code&gt;$GIT_DIR&lt;/code&gt; 정의되지 않고 현재 디렉토리가 Git 저장소 또는 작업 트리의 거짓말에 감지되지 제로 상태로 표준 오류 및 종료에 메시지를 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b71bb32cc72ead271cb1dd3ba713d52586ceff1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$per_request_config&lt;/code&gt; is not a code reference, it is interpreted as boolean value. If it is true gitweb will process config files once per request, and if it is false gitweb will process config files only once, each time it is executed. True by default (set to 1).</source>
          <target state="translated">&lt;code&gt;$per_request_config&lt;/code&gt; 가 코드 참조가 아닌 경우 부울 값으로 해석됩니다. 그것이 사실이라면 gitweb은 요청 당 한 번 설정 파일을 처리하고, 거짓이라면 gitweb은 실행될 때마다 설정 파일을 한 번만 처리합니다. 기본적으로 True입니다 (1로 설정).</target>
        </trans-unit>
        <trans-unit id="2006fc66d73a978df057f23b3e1521f13762b146" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$projects_list&lt;/code&gt; variable is unset, gitweb will recursively scan filesystem for Git repositories. The &lt;code&gt;$project_maxdepth&lt;/code&gt; is used to limit traversing depth, relative to &lt;code&gt;$projectroot&lt;/code&gt; (starting point); it means that directories which are further from &lt;code&gt;$projectroot&lt;/code&gt; than &lt;code&gt;$project_maxdepth&lt;/code&gt; will be skipped.</source>
          <target state="translated">&lt;code&gt;$projects_list&lt;/code&gt; 변수가 설정되어 있지 않으면 gitweb은 파일 시스템에서 Git 저장소를 재귀 적으로 검색합니다. &lt;code&gt;$project_maxdepth&lt;/code&gt; 제한 이송 깊이를 기준으로 사용되는 &lt;code&gt;$projectroot&lt;/code&gt; (시작 지점) 이는 &lt;code&gt;$project_maxdepth&lt;/code&gt; 보다 $ &lt;code&gt;$projectroot&lt;/code&gt; 에서 더 떨어진 디렉토리는 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="e1a24fe330082e54d9c17c846d5ecec5993c1e30" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is not found but there does exist a tracking branch in exactly one remote (call it &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;) with a matching name and &lt;code&gt;--no-guess&lt;/code&gt; is not specified, treat as equivalent to</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 발견하지만 원격 단 하나의 추적 지점은 존재하지 않습니다됩니다 (이 전화 &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; 일치하는 이름) 및 &lt;code&gt;--no-guess&lt;/code&gt; 상당로 처리, 지정되지 않은</target>
        </trans-unit>
        <trans-unit id="8d6aaf33671aeae0467cc81ab4a876d4297a1c66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is not found but there does exist a tracking branch in exactly one remote (call it &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;) with a matching name, treat as equivalent to</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 발견하지만 원격 단 하나의 추적 지점은 존재하지 않습니다됩니다 (이 전화 &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; 상당으로 일치하는 이름, 치료와 함께)</target>
        </trans-unit>
        <trans-unit id="29cec940deeaa506fbdf23d2fcc19ea5029d5ef6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; used, then, as a convenience, the new worktree is associated with a branch (call it &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;) named after &lt;code&gt;$(basename &amp;lt;path&amp;gt;)&lt;/code&gt;. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t exist, a new branch based on HEAD is automatically created as if &lt;code&gt;-b &amp;lt;branch&amp;gt;&lt;/code&gt; was given. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; does exist, it will be checked out in the new worktree, if it&amp;rsquo;s not checked out anywhere else, otherwise the command will refuse to create the worktree (unless &lt;code&gt;--force&lt;/code&gt; is used).</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 생략하지도 &lt;code&gt;-b&lt;/code&gt; 도 &lt;code&gt;-B&lt;/code&gt; 도 &lt;code&gt;--detach&lt;/code&gt; 사용하고, 편의상, 새로운 worktree이 분기 (호출과 관련된 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 따서) &lt;code&gt;$(basename &amp;lt;path&amp;gt;)&lt;/code&gt; . 만약 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 것처럼 HEAD 기반으로 새 가지가 자동으로 생성됩니다, 존재하지 않는 &lt;code&gt;-b &amp;lt;branch&amp;gt;&lt;/code&gt; 주어졌다. 경우 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 존재를 않습니다, 그것은 새로운 worktree에서 체크 아웃 할 것이다 그것을 다른 곳 체크 아웃되어 있지 않은 경우, 그렇지 않으면 명령은 (하지 않는 한 worktree을 만들 거부합니다 &lt;code&gt;--force&lt;/code&gt; 이 사용된다).</target>
        </trans-unit>
        <trans-unit id="62b6dbbe2a25a278c760cd92507e0bb77e25690a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;auto&lt;/code&gt;, if the first paragraph of the branch description is greater than 100 bytes, then the mode will be &lt;code&gt;message&lt;/code&gt;, otherwise &lt;code&gt;subject&lt;/code&gt; will be used.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 입니다 &lt;code&gt;auto&lt;/code&gt; , 분기 설명의 첫 번째 단락보다 큰 100 바이트 인 경우, 다음 모드가 될 것입니다 &lt;code&gt;message&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;subject&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="563c89a3c046790f554398f75098f56ae60f56e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;message&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;, the cover letter subject will be populated with placeholder text. The body of the cover letter will be populated with the branch&amp;rsquo;s description. This is the default mode when no configuration nor command line option is specified.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 입니다 &lt;code&gt;message&lt;/code&gt; 또는 &lt;code&gt;default&lt;/code&gt; , 커버 레터 제목은 자리 표시 자 텍스트로 채워집니다. 표지의 본문은 지점의 설명으로 채워집니다. 구성이나 명령 행 옵션이 지정되지 않은 경우 이것이 기본 모드입니다.</target>
        </trans-unit>
        <trans-unit id="768e82f3c3c3a8afb9417d73246f89dace57fcaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;, both the cover letter subject and body will be populated with placeholder text.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 되는 &lt;code&gt;none&lt;/code&gt; , 커버 레터의 제목과 본문 모두 자리 표시 자 텍스트로 채워되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b18877d6ecf14744d4315ad4c41aafa8a39f64e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;subject&lt;/code&gt;, the first paragraph of the branch description will populate the cover letter subject. The remainder of the description will populate the body of the cover letter.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 입니다 &lt;code&gt;subject&lt;/code&gt; , 분기 설명의 첫 번째 단락은 표지의 제목을 채 웁니다. 나머지 설명은 표지의 본문을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="c6a4599482148106286830a5bf06a49e73c76aca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--autosquash&lt;/code&gt; is used, &quot;exec&quot; lines will not be appended for the intermediate commits, and will only appear at the end of each squash/fixup series.</source>
          <target state="translated">경우 &lt;code&gt;--autosquash&lt;/code&gt; 가 사용된다 &quot;간부&quot;라인은 중간 커밋에 대한 추가되지 않고, 각 스쿼시 / 픽스 시리즈의 끝 부분에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ab8e2bae185710923964a946f737935700b0fc1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--batch&lt;/code&gt; is specified, the object information is followed by the object contents (consisting of &lt;code&gt;%(objectsize)&lt;/code&gt; bytes), followed by a newline.</source>
          <target state="translated">경우 &lt;code&gt;--batch&lt;/code&gt; 가 지정된 오브젝트 정보 (이루어진 오브젝트 내용 뒤에 &lt;code&gt;%(objectsize)&lt;/code&gt; 개행 바이트 단위).</target>
        </trans-unit>
        <trans-unit id="c868d58aa72d9bce1efba44bdbf844fae93d14ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--batch&lt;/code&gt; or &lt;code&gt;--batch-check&lt;/code&gt; is given, &lt;code&gt;cat-file&lt;/code&gt; will read objects from stdin, one per line, and print information about them. By default, the whole line is considered as an object, as if it were fed to &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;--batch&lt;/code&gt; 또는 &lt;code&gt;--batch-check&lt;/code&gt; 주어진다, &lt;code&gt;cat-file&lt;/code&gt; 표준 입력에서 오브젝트, 한 줄에 하나씩 읽고, 그들에 대한 정보를 인쇄합니다. 기본적으로 전체 줄은 마치 마치 &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]에&lt;/a&gt; 공급 된 것처럼 객체로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="2b49579ab9891477a433f3c4a7d881c054bf542d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--branch&lt;/code&gt; is given, a series of header lines are printed with information about the current branch.</source>
          <target state="translated">경우 &lt;code&gt;--branch&lt;/code&gt; 이 주어집니다, 헤더 행의 일련의 현재 지점에 대한 정보가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="92890e94239521769988796133cb653b32aed431" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--cached&lt;/code&gt; is specified, it allows you to ask:</source>
          <target state="translated">경우 &lt;code&gt;--cached&lt;/code&gt; 가 지정되어, 당신이 질문 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cdc2c32e44cf382458d3759532d549dfd10bb0ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--cached&lt;/code&gt; is specified, this command will instead print the SHA-1 recorded in the superproject for each submodule.</source>
          <target state="translated">경우 &lt;code&gt;--cached&lt;/code&gt; 가 지정되어,이 명령 대신 SHA-1 각 서브 모듈에 대한 superproject에 기록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="efe0936134ada9314d303de0a6d1675a3e22d7d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--force&lt;/code&gt; is specified, the submodule will be checked out (using &lt;code&gt;git checkout --force&lt;/code&gt;), even if the commit specified in the index of the containing repository already matches the commit checked out in the submodule.</source>
          <target state="translated">경우 &lt;code&gt;--force&lt;/code&gt; 가 지정되어, 서브 모듈은 (사용하여 확인됩니다 &lt;code&gt;git checkout --force&lt;/code&gt; 이미이 서브 모듈에서 체크 아웃 커밋 일치가 포함 된 저장소의 인덱스에 지정된 커밋하더라도).</target>
        </trans-unit>
        <trans-unit id="b5618fac3945aa3c15ec4d6ac940c3fc88cab042" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--force&lt;/code&gt; is specified, the submodule&amp;rsquo;s working tree will be removed even if it contains local modifications.</source>
          <target state="translated">경우 &lt;code&gt;--force&lt;/code&gt; 가 지정되면, 서브 모듈의 작업 나무는 로컬 수정 사항을 포함 된 경우에도 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="f2db79d4530ac333b81dd59fc3c02ca024b34411" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--index&lt;/code&gt; is not specified, then the submodule commits in the patch are ignored and only the absence or presence of the corresponding subdirectory is checked and (if possible) updated.</source>
          <target state="translated">경우 &lt;code&gt;--index&lt;/code&gt; 가 지정되어 있지 않은 경우, 패치의 서브 모듈 커밋은 무시됩니다 만 부재 또는 해당 하위 디렉토리의 존재를 확인하고 (가능한 경우)가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="ab41ddd9d49ddaff35bf4379642301cf2f1054d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--index&lt;/code&gt; is specified (explicitly or implicitly), then the submodule commits must match the index exactly for the patch to apply. If any of the submodules are checked-out, then these check-outs are completely ignored, i.e., they are not required to be up to date or clean and they are not updated.</source>
          <target state="translated">경우 &lt;code&gt;--index&lt;/code&gt; 이 (명시 적 또는 암시 적으로) 지정 패치를 적용하기 위해, 다음 서브 모듈 커밋은 정확히 인덱스와 일치해야합니다. 하위 모듈이 체크 아웃되면이 체크 아웃이 완전히 무시됩니다. 즉, 최신 상태이거나 정리할 필요가 없으며 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7cd61ae0dde953250d385a6012605e922398ec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--list&lt;/code&gt; is given, or if there are no non-option arguments, existing branches are listed; the current branch will be highlighted in green and marked with an asterisk. Any branches checked out in linked worktrees will be highlighted in cyan and marked with a plus sign. Option &lt;code&gt;-r&lt;/code&gt; causes the remote-tracking branches to be listed, and option &lt;code&gt;-a&lt;/code&gt; shows both local and remote branches.</source>
          <target state="translated">경우 &lt;code&gt;--list&lt;/code&gt; 이 주어진다에는 옵션이 아닌 인수가없는 경우, 또는 기존의 지점이 나열됩니다; 현재 분기는 녹색으로 강조 표시되고 별표로 표시됩니다. 연결된 작업 트리에서 체크 아웃 된 분기는 시안 색으로 강조 표시되고 더하기 부호가 표시됩니다. &lt;code&gt;-r&lt;/code&gt; 옵션을 사용 하면 원격 추적 분기가 나열되고 &lt;code&gt;-a&lt;/code&gt; 옵션 은 로컬 및 원격 분기를 모두 표시합니다.</target>
        </trans-unit>
        <trans-unit id="45b84e8c64b1db8d6046842947d0384f2fee755b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--log&lt;/code&gt; is specified, a shortlog of the commits being merged will be appended to the specified message.</source>
          <target state="translated">경우 &lt;code&gt;--log&lt;/code&gt; 가 지정, 병합 될 커밋의 shortlog 지정된 메시지에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1772a311632ebe173773fb98d78cf3669fc056b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--max-commits=&amp;lt;M&amp;gt;&lt;/code&gt; is specified with &lt;code&gt;M&lt;/code&gt; a positive integer, and the new tip file would have more than &lt;code&gt;M&lt;/code&gt; commits, then instead merge the new tip with the previous tip.</source>
          <target state="translated">경우 &lt;code&gt;--max-commits=&amp;lt;M&amp;gt;&lt;/code&gt; 지정되어 &lt;code&gt;M&lt;/code&gt; 양의 정수를, 새로운 팁 파일보다 더 많은 것 &lt;code&gt;M&lt;/code&gt; 의 커밋하고 대신 이전 팁 새로운 팁을 병합합니다.</target>
        </trans-unit>
        <trans-unit id="f4eab33758877fd85cebec91765014b4b92dc48c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--recursive&lt;/code&gt; is specified, this command will recurse into nested submodules, and show their status as well.</source>
          <target state="translated">경우 &lt;code&gt;--recursive&lt;/code&gt; 가 지정되어,이 명령은 중첩 된 서브 모듈로 재귀 적, 자신의 상태를 표시뿐만 아니라 것입니다.</target>
        </trans-unit>
        <trans-unit id="776298c85f9bd8538095ba7ea6588e9b7e4a25e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--recursive&lt;/code&gt; is specified, this command will recurse into the registered submodules, and sync any nested submodules within.</source>
          <target state="translated">경우 &lt;code&gt;--recursive&lt;/code&gt; 이 지정되면,이 명령은 등록 된 서브 모듈로 재귀 및 중첩 내에 서브 모듈을 동기화한다.</target>
        </trans-unit>
        <trans-unit id="1ddca2ea8ce5da739445e37cd4a4048560236396" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--recursive&lt;/code&gt; is specified, this command will recurse into the registered submodules, and update any nested submodules within.</source>
          <target state="translated">경우 &lt;code&gt;--recursive&lt;/code&gt; 가 지정되어,이 명령은 등록 된 서브 모듈로 재귀 적 및 내에서 중첩 된 서브 모듈을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="ccfd5529f6d32ddb692a0a0edb24e2ebd0aeb784" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--size-multiple=&amp;lt;X&amp;gt;&lt;/code&gt; is not specified, let &lt;code&gt;X&lt;/code&gt; equal 2. If the new tip file would have &lt;code&gt;N&lt;/code&gt; commits and the previous tip has &lt;code&gt;M&lt;/code&gt; commits and &lt;code&gt;X&lt;/code&gt; times &lt;code&gt;N&lt;/code&gt; is greater than &lt;code&gt;M&lt;/code&gt;, instead merge the two files into a single file.</source>
          <target state="translated">경우 &lt;code&gt;--size-multiple=&amp;lt;X&amp;gt;&lt;/code&gt; 를 지정하지 않은하자 &lt;code&gt;X&lt;/code&gt; 는 새로운 팁 파일이있을 것입니다 경우 2. 동일 &lt;code&gt;N&lt;/code&gt; 의 커밋을 이전 끝이 &lt;code&gt;M&lt;/code&gt; 의 커밋 및 &lt;code&gt;X&lt;/code&gt; 의 시간 &lt;code&gt;N&lt;/code&gt; 이 보다 큰 &lt;code&gt;M&lt;/code&gt; 을 대신에 두 파일을 병합, 단일 파일.</target>
        </trans-unit>
        <trans-unit id="c75734f6686dc8bf756f12580f08ccb633b88773" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--stateless-rpc&lt;/code&gt; is specified together with this option then the list of refs must be in packet format (pkt-line). Each ref must be in a separate packet, and the list must end with a flush packet.</source>
          <target state="translated">경우 &lt;code&gt;--stateless-rpc&lt;/code&gt; 이 옵션과 함께 지정 후 심판의리스트는 패킷 형식 (PKT-라인)에 있어야합니다. 각 심판은 별도의 패킷에 있어야하며 목록은 플러시 패킷으로 끝나야합니다.</target>
        </trans-unit>
        <trans-unit id="d363c35441978c92ee5ead459023dfd1f9ed35c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--verbose&lt;/code&gt; is specified, the output is a series of lines of the form:</source>
          <target state="translated">경우 &lt;code&gt;--verbose&lt;/code&gt; 를 지정, 출력 형태의 일련의 선이다 :</target>
        </trans-unit>
        <trans-unit id="b441bd31aac4d2437fef46e0587314ace0da5e13" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-B&lt;/code&gt; is given, &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; is created if it doesn&amp;rsquo;t exist; otherwise, it is reset. This is the transactional equivalent of</source>
          <target state="translated">경우 &lt;code&gt;-B&lt;/code&gt; 가 주어진다, &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; 가 존재하지 않는 경우에 작성됩니다; 그렇지 않으면 재설정됩니다. 이것은 거래에 해당하는</target>
        </trans-unit>
        <trans-unit id="b749f9938784db5272ac47989617994390a95806" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-N&lt;/code&gt; is specified, removed paths are marked as intent-to-add (see &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;code&gt;-N&lt;/code&gt; 가 지정된 제거 경로를 목적으로 표시된 대 추가 (참조 &lt;a href=&quot;git-add&quot;&gt;자식 합산을 [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0d1031ba738c1e4895034c45a671bdfc4feb8ed4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-e&lt;/code&gt; is specified, no output, unless the &amp;lt;object&amp;gt; is malformed.</source>
          <target state="translated">경우 &lt;code&gt;-e&lt;/code&gt; 가 지정되어, 더 출력은 &amp;lt;object&amp;gt;하지 않는 한, 부정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b39ecbbcbddbe2e5db1df9079f165a4a73917d14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; or &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; is given and &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, and &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; are absent, &lt;code&gt;-a&lt;/code&gt; is implied.</source>
          <target state="translated">경우 &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; 부여하고 &lt;code&gt;-a&lt;/code&gt; 는 , &lt;code&gt;-s&lt;/code&gt; , 및 &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 결석, &lt;code&gt;-a&lt;/code&gt; 는 암시한다.</target>
        </trans-unit>
        <trans-unit id="c5ab965e580c550a049049c227e584f98537d08f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-m&lt;/code&gt; is specified, &lt;code&gt;git read-tree&lt;/code&gt; can perform 3 kinds of merge, a single tree merge if only 1 tree is given, a fast-forward merge with 2 trees, or a 3-way merge if 3 or more trees are provided.</source>
          <target state="translated">경우 &lt;code&gt;-m&lt;/code&gt; 이 지정되어, &lt;code&gt;git read-tree&lt;/code&gt; 단지 1 트리가 주어진다면 3 개 이상의 나무가 제공하는 경우 2 나무, 또는 3 방향 병합으로, 병합의 빨리 감기 병합을 단일 트리 병합을 3 종류 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f1322547f9936fb21adaa0927130bdfd594f82e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;--non-matching&lt;/code&gt; are specified, non-matching pathnames will also be output, in which case all fields in each output record except for &amp;lt;pathname&amp;gt; will be empty. This can be useful when running non-interactively, so that files can be incrementally streamed to STDIN of a long-running check-ignore process, and for each of these files, STDOUT will indicate whether that file matched a pattern or not. (Without this option, it would be impossible to tell whether the absence of output for a given file meant that it didn&amp;rsquo;t match any pattern, or that the output hadn&amp;rsquo;t been generated yet.)</source>
          <target state="translated">경우 &lt;code&gt;-n&lt;/code&gt; 또는 &lt;code&gt;--non-matching&lt;/code&gt; 지정되어, 일치하지 않는 경로 이름은 &amp;lt;경로&amp;gt;을 제외한 각 출력 레코드의 모든 필드가 비어있는 경우에 출력 될 것이다. 이는 비 대화식으로 실행할 때 유용하므로 파일을 장기 실행 검사 무시 프로세스의 STDIN으로 증분 스트리밍 할 수 있으며 이러한 각 파일에 대해 STDOUT은 해당 파일이 패턴과 일치하는지 여부를 표시합니다. (이 옵션이 없으면 주어진 파일에 대한 출력이 없다는 것이 어떤 패턴과도 일치하지 않거나 출력이 아직 생성되지 않았 음을 의미하는지 여부를 알 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="bedfa7472b5b880935d5dde5c2d6b7df2dd5534d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-o&lt;/code&gt; is specified, output files are created in &amp;lt;dir&amp;gt;. Otherwise they are created in the current working directory. The default path can be set with the &lt;code&gt;format.outputDirectory&lt;/code&gt; configuration option. The &lt;code&gt;-o&lt;/code&gt; option takes precedence over &lt;code&gt;format.outputDirectory&lt;/code&gt;. To store patches in the current working directory even when &lt;code&gt;format.outputDirectory&lt;/code&gt; points elsewhere, use &lt;code&gt;-o .&lt;/code&gt;. All directory components will be created.</source>
          <target state="translated">경우 &lt;code&gt;-o&lt;/code&gt; 가 지정, 출력 파일은 &amp;lt;디렉토리&amp;gt;에 작성됩니다. 그렇지 않으면 현재 작업 디렉토리에 작성됩니다. 기본 경로는 &lt;code&gt;format.outputDirectory&lt;/code&gt; 구성 옵션 으로 설정할 수 있습니다 . &lt;code&gt;-o&lt;/code&gt; 옵션보다 우선합니다 &lt;code&gt;format.outputDirectory&lt;/code&gt; . &lt;code&gt;format.outputDirectory&lt;/code&gt; 가 다른 곳을 가리켜 도 현재 작업 디렉토리에 패치를 저장하려면 &lt;code&gt;-o .&lt;/code&gt; 사용하십시오 . . 모든 디렉토리 구성 요소가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="bbc0034ea645324d7719670d640dccda6b5513e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-p&lt;/code&gt; is specified, the contents of &amp;lt;object&amp;gt; are pretty-printed.</source>
          <target state="translated">경우 &lt;code&gt;-p&lt;/code&gt; 가 지정되어, &amp;lt;object&amp;gt;의 내용은 꽤-인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="49cafb1f81b012710180fa1719861bbc315bac4f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-s&lt;/code&gt; is specified, the size of the &amp;lt;object&amp;gt; in bytes.</source>
          <target state="translated">경우 &lt;code&gt;-s&lt;/code&gt; 가 지정된 바이트의 &amp;lt;object&amp;gt;의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="859275c6340e08abbb3b87a577dd1f75bdf60296" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-t&lt;/code&gt; is specified, one of the &amp;lt;type&amp;gt;.</source>
          <target state="translated">경우 &lt;code&gt;-t&lt;/code&gt; 가 지정되면, &amp;lt;유형&amp;gt; 중 하나.</target>
        </trans-unit>
        <trans-unit id="77cb52b6f5e5f8b68fe5657e97a4dba5f22808fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-v&lt;/code&gt; is specified, the script reports what it is doing.</source>
          <target state="translated">경우 &lt;code&gt;-v&lt;/code&gt; 가 지정되는 스크립트는 무엇을하고 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="f7c94cac86b7d031a538f6e54d51ce5da54af947" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-z&lt;/code&gt; is specified, the pathnames in the output are delimited by the null character; if &lt;code&gt;--verbose&lt;/code&gt; is also specified then null characters are also used instead of colons and hard tabs:</source>
          <target state="translated">경우 &lt;code&gt;-z&lt;/code&gt; 가 지정되면, 출력 경로 이름은 널 문자에 의해 분리되며 경우 &lt;code&gt;--verbose&lt;/code&gt; 은 또한 다음 지정된 널 문자 대신 콜론 하드 탭으로 사용된다 :</target>
        </trans-unit>
        <trans-unit id="54b1b9cb08e8013285c455de408ae4d63672e927" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GIT_TRACE2_BRIEF&lt;/code&gt; or &lt;code&gt;trace2.normalBrief&lt;/code&gt; is true, the &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt;, and &lt;code&gt;line&lt;/code&gt; fields are omitted.</source>
          <target state="translated">경우 &lt;code&gt;GIT_TRACE2_BRIEF&lt;/code&gt; 또는 &lt;code&gt;trace2.normalBrief&lt;/code&gt; 이 사실은 &lt;code&gt;time&lt;/code&gt; , &lt;code&gt;filename&lt;/code&gt; 및 &lt;code&gt;line&lt;/code&gt; 필드는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="2e9a7edfc47ae5456f77e7777204d6f377e2ee4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GIT_TRACE2_EVENT_BRIEF&lt;/code&gt; or &lt;code&gt;trace2.eventBrief&lt;/code&gt; is true, the &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt; fields are omitted from all events and the &lt;code&gt;time&lt;/code&gt; field is only present on the &quot;start&quot; and &quot;atexit&quot; events.</source>
          <target state="translated">경우 &lt;code&gt;GIT_TRACE2_EVENT_BRIEF&lt;/code&gt; 또는 &lt;code&gt;trace2.eventBrief&lt;/code&gt; 이 사실의 &lt;code&gt;file&lt;/code&gt; 및 &lt;code&gt;line&lt;/code&gt; 필드는 모든 이벤트에서 생략되고, &lt;code&gt;time&lt;/code&gt; 필드는 &quot;시작&quot;과 &quot;atexit&quot;이벤트에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="1f02cbb9b13595b2ae6e45bc6f6b5fd9cfaab0a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GIT_TRACE2_PERF_BRIEF&lt;/code&gt; or &lt;code&gt;trace2.perfBrief&lt;/code&gt; is true, the &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, and &lt;code&gt;line&lt;/code&gt; fields are omitted.</source>
          <target state="translated">경우 &lt;code&gt;GIT_TRACE2_PERF_BRIEF&lt;/code&gt; 또는 &lt;code&gt;trace2.perfBrief&lt;/code&gt; 이 사실은 &lt;code&gt;time&lt;/code&gt; , &lt;code&gt;file&lt;/code&gt; 및 &lt;code&gt;line&lt;/code&gt; 필드는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="ac54e4f3ca84b268e2b102a57942d2590e1ed97e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration for the current branch &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; exists, that is the name of the branch at the remote site that is merged.</source>
          <target state="translated">만약 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 구성 현재 지점에 대한 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 존재 병합 원격 사이트의 분기의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0bbbd298acfcfe77553aeabe5dcce9895508b92f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;core.ignoreCase=true&lt;/code&gt;, then the pattern-matching algorithm will use a case-insensitive check. This corrects for case mismatched filenames in the &lt;code&gt;git sparse-checkout set&lt;/code&gt; command to reflect the expected cone in the working directory.</source>
          <target state="translated">경우 &lt;code&gt;core.ignoreCase=true&lt;/code&gt; 다음 패턴 매칭 알고리즘은 대소 문자 구별 검사를 사용한다. 이것은 &lt;code&gt;git sparse-checkout set&lt;/code&gt; 명령 에서 파일 이름이 일치하지 않는 경우 작업 디렉토리의 예상 원뿔을 반영하도록 수정합니다.</target>
        </trans-unit>
        <trans-unit id="e0b5d0106d1c8675cc37e497ff6608e05f8526d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;core.safecrlf&lt;/code&gt; is set to &quot;true&quot; or &quot;warn&quot;, Git verifies if the conversion is reversible for the current setting of &lt;code&gt;core.autocrlf&lt;/code&gt;. For &quot;true&quot;, Git rejects irreversible conversions; for &quot;warn&quot;, Git only prints a warning but accepts an irreversible conversion. The safety triggers to prevent such a conversion done to the files in the work tree, but there are a few exceptions. Even though&amp;hellip;​</source>
          <target state="translated">경우 &lt;code&gt;core.safecrlf&lt;/code&gt; 은 &quot;true&quot;또는 &quot;경고&quot;힘내를 검증로 설정되어 변환의 현재 설정 가역 경우 &lt;code&gt;core.autocrlf&lt;/code&gt; . &quot;true&quot;의 경우 Git은 되돌릴 수없는 변환을 거부합니다. &quot;경고&quot;의 경우, Git은 경고 만 인쇄하지만 되돌릴 수없는 변환을 허용합니다. 안전은 작업 트리의 파일에 대한 이러한 변환을 방지하기 위해 트리거되지만 몇 가지 예외가 있습니다. 그래도&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="a8fd82d7f01c8cd14090b39826adb8859d4c03b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;core.sparseCheckoutCone=true&lt;/code&gt;, then Git will parse the sparse-checkout file expecting patterns of these types. Git will warn if the patterns do not match. If the patterns do match the expected format, then Git will use faster hash- based algorithms to compute inclusion in the sparse-checkout.</source>
          <target state="translated">경우 &lt;code&gt;core.sparseCheckoutCone=true&lt;/code&gt; 다음 힘내는 이러한 유형의 패턴을 기대 스파 스 - 체크 아웃 파일을 구문 분석합니다. 패턴이 일치하지 않으면 Git이 경고합니다. 패턴이 예상 형식과 일치하면 Git은 빠른 해시 기반 알고리즘을 사용하여 희소 체크 아웃에 포함되는 것을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="9f2eb1f9e30347412b91990fde6d0d3118015f0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;credential.helper&lt;/code&gt; is configured to the empty string, this resets the helper list to empty (so you may override a helper set by a lower-priority config file by configuring the empty-string helper, followed by whatever set of helpers you would like).</source>
          <target state="translated">경우 &lt;code&gt;credential.helper&lt;/code&gt; 가 빈 문자열로 구성되어 당신이 빈 문자열 도우미를 구성하여 낮은 우선 순위의 설정 파일에 의한 도우미 세트를 오버라이드 (override) 할 수 있도록,이 재설정은 도우미 목록 (비우, 당신이하고 싶은 헬퍼의 어떤 설정 한 다음 ).</target>
        </trans-unit>
        <trans-unit id="6f6bc24ce4d9cb03fd023baafceb347acba1bf38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt; and related commands will not treat the initial commit as a big creation event. Any root commits in &lt;code&gt;git log -p&lt;/code&gt; output would be shown without a diff attached. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 인 경우 &lt;code&gt;git log&lt;/code&gt; 및 관련 명령은 초기 커밋을 큰 생성 이벤트로 취급하지 않습니다. &lt;code&gt;git log -p&lt;/code&gt; 출력의 모든 루트 커밋은 diff가 첨부되지 않은 상태로 표시됩니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="176a2b5b60655848aad57cb4f6f5216b8fca3bab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;git merge-index&lt;/code&gt; is called with multiple &amp;lt;file&amp;gt;s (or -a) then it processes them in turn only stopping if merge returns a non-zero exit code.</source>
          <target state="translated">경우 &lt;code&gt;git merge-index&lt;/code&gt; 여러 &amp;lt;파일&amp;gt;로 호출들 (또는 -a) 다음은 병합 반환하는 경우 0이 아닌 종료 코드를 중지 차례로을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="806256aa8b91febcc951ef689b4cdbc521c56b19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;git svn&lt;/code&gt; is configured to fetch branches (and --follow-branches is in effect), it sometimes creates multiple Git branches for one SVN branch, where the additional branches have names of the form &lt;code&gt;branchname@nnn&lt;/code&gt; (with nnn an SVN revision number). These additional branches are created if &lt;code&gt;git svn&lt;/code&gt; cannot find a parent commit for the first commit in an SVN branch, to connect the branch to the history of the other branches.</source>
          <target state="translated">경우 &lt;code&gt;git svn&lt;/code&gt; 지점 (및 --follow-가지 효과입니다) 가져하도록 구성되어, 때로는 추가 가지 양식의 이름이 하나 개 SVN 지점, 여러 힘내 분기를 생성 &lt;code&gt;branchname@nnn&lt;/code&gt; (AN SVN 개정 번호 NNN으로 ). 이 추가 브랜치는 &lt;code&gt;git svn&lt;/code&gt; 이 SVN 브랜치에서 첫 번째 커밋에 대한 상위 커밋을 찾을 수없는 경우 브랜치를 다른 브랜치의 히스토리에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="ea83fb8f1cd42b6f4ec377884889f8ee539b7922" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;our&lt;/code&gt; version introduces whitespace changes but &lt;code&gt;their&lt;/code&gt; version includes a substantial change, &lt;code&gt;their&lt;/code&gt; version is used;</source>
          <target state="translated">경우 &lt;code&gt;our&lt;/code&gt; 변화하지만 공백 버전을 소개합니다 &lt;code&gt;their&lt;/code&gt; 버전은 상당한 변화를 포함, &lt;code&gt;their&lt;/code&gt; 버전이 사용됩니다;</target>
        </trans-unit>
        <trans-unit id="9a3c5f8b5c3f8823d3bb0bf75c68202ef91e0068" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;status.submoduleSummary&lt;/code&gt; is set to a non zero number or true (identical to -1 or an unlimited number), the submodule summary will be enabled for the long format and a summary of commits for modified submodules will be shown (see --summary-limit option of &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;). Please note that the summary output from the status command will be suppressed for all submodules when &lt;code&gt;diff.ignoreSubmodules&lt;/code&gt; is set to &lt;code&gt;all&lt;/code&gt; or only for those submodules where &lt;code&gt;submodule.&amp;lt;name&amp;gt;.ignore=all&lt;/code&gt;. To also view the summary for ignored submodules you can either use the --ignore-submodules=dirty command line option or the &lt;code&gt;git submodule summary&lt;/code&gt; command, which shows a similar output but does not honor these settings.</source>
          <target state="translated">경우 &lt;code&gt;status.submoduleSummary&lt;/code&gt; 가 0이 아닌 숫자 또는 참 (동일 -1 또는 무제한)로 설정되고, 서브 모듈 요약 --summary 볼 (도시한다 긴 포맷과 수정 된 서브 모듈에 대한 커밋 요약 활성화 될 &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; 의 -limit 옵션 ). &lt;code&gt;diff.ignoreSubmodules&lt;/code&gt; 가 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.ignore=all&lt;/code&gt; 인 서브 모듈에 대해 &lt;code&gt;all&lt;/code&gt; 또는 only로 설정 되면 status 명령의 요약 출력이 모든 서브 모듈에 대해 억제 됩니다 . 무시 된 하위 모듈에 대한 요약을 보려면 --ignore-submodules = dirty 명령 행 옵션 또는 &lt;code&gt;git submodule summary&lt;/code&gt; 명령은 유사한 출력을 표시하지만 이러한 설정을 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e9c3270ca55bc57874ba3c8e582e2598d79892a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subsystem&lt;/code&gt; is rebased against &lt;code&gt;master&lt;/code&gt;, the following happens:</source>
          <target state="translated">경우 &lt;code&gt;subsystem&lt;/code&gt; 에 대해으로 업데이트되어 &lt;code&gt;master&lt;/code&gt; , 다음과 같은 상황이 발생합니다</target>
        </trans-unit>
        <trans-unit id="601fb7e577607a9227812e9cbf0586e6f099c5c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;their&lt;/code&gt; version only introduces whitespace changes to a line, &lt;code&gt;our&lt;/code&gt; version is used;</source>
          <target state="translated">만약 &lt;code&gt;their&lt;/code&gt; 라인으로 변경 공백 버전 만 소개하고는, &lt;code&gt;our&lt;/code&gt; 버전이 사용됩니다;</target>
        </trans-unit>
        <trans-unit id="8afd53e5e6b34e88bd67e48774d4e9aa34d681c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt; and related commands will act as if the &lt;code&gt;--show-signature&lt;/code&gt; option was passed to them.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;git log&lt;/code&gt; 및 관련 명령은 &lt;code&gt;--show-signature&lt;/code&gt; 옵션이 전달 된 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="30fb3a857bee5620305914164cd0d4800cd1bf39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt; will act as if the &lt;code&gt;--follow&lt;/code&gt; option was used when a single &amp;lt;path&amp;gt; is given. This has the same limitations as &lt;code&gt;--follow&lt;/code&gt;, i.e. it cannot be used to follow multiple files and does not work well on non-linear history.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;git log&lt;/code&gt; 는 단일 &amp;lt;path&amp;gt;가 제공 될 때 &lt;code&gt;--follow&lt;/code&gt; 옵션이 사용 된 것처럼 작동합니다 . 이것은 &lt;code&gt;--follow&lt;/code&gt; 와 같은 제한 사항이 있습니다. 즉, 여러 파일을 따라가는 데 사용할 수 없으며 비선형 히스토리에서는 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e427e8f5bde6693ff553f72c72fbaf5c9a84e60f" translate="yes" xml:space="preserve">
          <source>If Alice wants to visualize what Bob did since their histories forked she can issue the following command:</source>
          <target state="translated">Alice가 Bob이 기록한 이후 Bob이 수행 한 작업을 시각화하려면 다음 명령을 발행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38d81a70b720705355c01f2f151a0b608b67e1f5" translate="yes" xml:space="preserve">
          <source>If Bob later decides to work from a different host, he can still perform clones and pulls using the ssh protocol:</source>
          <target state="translated">Bob이 나중에 다른 호스트에서 작업하기로 결정한 경우에도 여전히 ssh 프로토콜을 사용하여 복제 및 풀을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="906533644a5e321915983ba584ed131ee5f02be3" translate="yes" xml:space="preserve">
          <source>If X is found to be &quot;bad&quot;, then we know that its descendants are all &quot;bad&quot;, so we want to say that:</source>
          <target state="translated">X가 &quot;나쁜&quot;것으로 판명되면, 우리는 그 자손이 모두 &quot;나쁜&quot;것이므로 다음과 같이 말하고 싶습니다 :</target>
        </trans-unit>
        <trans-unit id="585173cb924da5e21521ae8038b0882b2bd9054d" translate="yes" xml:space="preserve">
          <source>If X is found to be &quot;good&quot;, then we know that its ancestors are all &quot;good&quot;, so we want to say that:</source>
          <target state="translated">X가 &quot;좋은&quot;것으로 판명되면 우리는 그 조상이 모두 &quot;좋은&quot;것을 알기 때문에 다음과 같이 말하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="5b8abb6b4933866023868019ddfccc59a8fddfdf" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; is given, it is used as a shell wildcard to restrict the output to matching branches. If multiple patterns are given, a branch is shown if it matches any of the patterns.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 주어진다이를 매칭 지점에 대한 출력을 제한하는 쉘 와일드 카드로서 이용된다. 여러 패턴이 제공되면 패턴과 일치하면 분기가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9af8e725fef48828fa7bc334de43f0ec2851ec0b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;merge&lt;/code&gt; command fails for any reason other than merge conflicts (i.e. when the merge operation did not even start), it is rescheduled immediately.</source>
          <target state="translated">경우 &lt;code&gt;merge&lt;/code&gt; 명령 병합 충돌 (즉, 병합 작업도 시작하지 않은 경우) 이외의 이유로 실패, 그것은 즉시 재조정된다.</target>
        </trans-unit>
        <trans-unit id="78142494afa000f59dc94a96d37bd84306c42e5e" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;no-interactive-login&lt;/code&gt; command exists, then it is run and the interactive shell is aborted.</source>
          <target state="translated">경우 &lt;code&gt;no-interactive-login&lt;/code&gt; 명령이 존재, 그것은 실행되고 대화 형 쉘이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="7f80f5447bc118a0311c9425234560dac2c0a613" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;pattern&lt;/code&gt; is given, only refs matching the given shell glob are shown. If the pattern does not contain a globbing character (&lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or &lt;code&gt;[&lt;/code&gt;), it is turned into a prefix match by appending &lt;code&gt;/*&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;pattern&lt;/code&gt; 부여하고, 지정된 셀 글롭 일치 심판 만이 도시되어있다. 패턴에 글 로빙 문자 ( &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;[&lt;/code&gt; ) 가 포함되어 있지 않으면 &lt;code&gt;/*&lt;/code&gt; 를 추가하여 접두사 일치로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="744bace39aac155f24f5426e32b134c34f641c3b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;~/git-shell-commands&lt;/code&gt; directory is present, &lt;code&gt;git shell&lt;/code&gt; can also be run interactively (with no arguments). If a &lt;code&gt;help&lt;/code&gt; command is present in the &lt;code&gt;git-shell-commands&lt;/code&gt; directory, it is run to provide the user with an overview of allowed actions. Then a &quot;git&amp;gt; &quot; prompt is presented at which one can enter any of the commands from the &lt;code&gt;git-shell-commands&lt;/code&gt; directory, or &lt;code&gt;exit&lt;/code&gt; to close the connection.</source>
          <target state="translated">경우 &lt;code&gt;~/git-shell-commands&lt;/code&gt; 디렉토리가 존재, &lt;code&gt;git shell&lt;/code&gt; 또한 (인수 없음) 대화 형으로 실행할 수 있습니다. &lt;code&gt;git-shell-commands&lt;/code&gt; 디렉토리 에 &lt;code&gt;help&lt;/code&gt; 명령이 있으면이 명령이 실행되어 사용자에게 허용 된 작업에 대한 개요를 제공합니다. 그런 다음 &quot;git&amp;gt;&quot;프롬프트가 표시되어 &lt;code&gt;git-shell-commands&lt;/code&gt; 디렉토리 에서 명령을 입력 하거나 &lt;code&gt;exit&lt;/code&gt; 하여 연결을 닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa403bcc24255cf8941b29ab4148b7eee12a6185" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;~/git-shell-commands&lt;/code&gt; directory is present, &lt;code&gt;git shell&lt;/code&gt; will also handle other, custom commands by running &quot;&lt;code&gt;git-shell-commands/&amp;lt;command&amp;gt; &amp;lt;arguments&amp;gt;&lt;/code&gt;&quot; from the user&amp;rsquo;s home directory.</source>
          <target state="translated">경우 &lt;code&gt;~/git-shell-commands&lt;/code&gt; 디렉토리가 존재, &lt;code&gt;git shell&lt;/code&gt; 또한 &quot;실행하여 다른 사용자 정의 명령을 처리 할 &lt;code&gt;git-shell-commands/&amp;lt;command&amp;gt; &amp;lt;arguments&amp;gt;&lt;/code&gt; 사용자의 홈 디렉토리에서&quot;.</target>
        </trans-unit>
        <trans-unit id="106b7929c0261fff657b2746b76dd80d35492e74" translate="yes" xml:space="preserve">
          <source>If a Git client that does not support the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute adds a new file &lt;code&gt;bar.ps1&lt;/code&gt;, then &lt;code&gt;bar.ps1&lt;/code&gt; will be stored &quot;as-is&quot; internally (in this example probably as UTF-16). A client with &lt;code&gt;working-tree-encoding&lt;/code&gt; support will interpret the internal contents as UTF-8 and try to convert it to UTF-16 on checkout. That operation will fail and cause an error.</source>
          <target state="translated">지원하지 않는 힘내 클라이언트 경우 &lt;code&gt;working-tree-encoding&lt;/code&gt; 속성이 새 파일 추가 &lt;code&gt;bar.ps1&lt;/code&gt; 을 다음 &lt;code&gt;bar.ps1&lt;/code&gt; 은 (아마도 UTF-16이 예에서) 내부적으로 &quot;있는 그대로&quot;저장됩니다. &lt;code&gt;working-tree-encoding&lt;/code&gt; 지원 하는 클라이언트 는 내부 내용을 UTF-8로 해석하여 체크 아웃시 UTF-16으로 변환하려고합니다. 해당 작업이 실패하고 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="84278502dbc74a9c4cc8dd831a2c5f189f159ac0" translate="yes" xml:space="preserve">
          <source>If a Git repository includes branches &lt;code&gt;refs/remotes/origin/p4&lt;/code&gt;, these will be fetched and consulted first during a &lt;code&gt;git p4 sync&lt;/code&gt;. Since importing directly from p4 is considerably slower than pulling changes from a Git remote, this can be useful in a multi-developer environment.</source>
          <target state="translated">Git 저장소에 분기 &lt;code&gt;refs/remotes/origin/p4&lt;/code&gt; 가 포함 된 경우 &lt;code&gt;git p4 sync&lt;/code&gt; 중에 먼저 가져 와서 참조 합니다 . p4에서 직접 가져 오기는 Git 리모콘에서 변경 사항을 가져 오는 것보다 상당히 느리기 때문에 다중 개발자 환경에서 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af291be12b7b5a290c76485729b6b8f4918ca983" translate="yes" xml:space="preserve">
          <source>If a command, or a guide, is given, a manual page for that command or guide is brought up. The &lt;code&gt;man&lt;/code&gt; program is used by default for this purpose, but this can be overridden by other options or configuration variables.</source>
          <target state="translated">명령 또는 안내서가 제공되면 해당 명령 또는 안내서의 매뉴얼 페이지가 나타납니다. &lt;code&gt;man&lt;/code&gt; 프로그램은이 목적을 위해 기본적으로 사용됩니다 만, 다른 옵션이나 구성 변수에 의해 오버라이드 (override) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72743ffe0426b38cdd1755e732e28a11a9ff3a78" translate="yes" xml:space="preserve">
          <source>If a commit being cherry picked duplicates a commit already in the current history, it will become empty. By default these redundant commits cause &lt;code&gt;cherry-pick&lt;/code&gt; to stop so the user can examine the commit. This option overrides that behavior and creates an empty commit object. Implies &lt;code&gt;--allow-empty&lt;/code&gt;.</source>
          <target state="translated">체리 선택되는 커밋이 현재 히스토리에 이미있는 커밋을 복제하면 비어있게됩니다. 기본적으로 이러한 중복 커밋 은 사용자가 커밋을 검사 할 수 있도록 &lt;code&gt;cherry-pick&lt;/code&gt; 을 중지시킵니다. 이 옵션은 해당 동작을 재정의하고 빈 커밋 개체를 만듭니다. &lt;code&gt;--allow-empty&lt;/code&gt; 를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="4b42bbbaf339d6cf05d45edbdf2ada972df70aa1" translate="yes" xml:space="preserve">
          <source>If a diff tool is not specified, &lt;code&gt;git difftool&lt;/code&gt; will use the configuration variable &lt;code&gt;diff.tool&lt;/code&gt;. If the configuration variable &lt;code&gt;diff.tool&lt;/code&gt; is not set, &lt;code&gt;git difftool&lt;/code&gt; will pick a suitable default.</source>
          <target state="translated">diff 도구를 지정하지 않으면 &lt;code&gt;git difftool&lt;/code&gt; 은 구성 변수 &lt;code&gt;diff.tool&lt;/code&gt; 을 사용합니다 . 구성 변수 &lt;code&gt;diff.tool&lt;/code&gt; 이 설정되어 있지 않으면 &lt;code&gt;git difftool&lt;/code&gt; 이 적절한 기본값을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="a8ee98dcb134f1a2c8067ffe5665347c4c70f9e4" translate="yes" xml:space="preserve">
          <source>If a fatal error occurs, the program writes the error message to stderr and exits. The caller should expect that a suitable error message has been printed if the child closes the connection without completing a valid response for the current command.</source>
          <target state="translated">치명적인 오류가 발생하면 프로그램은 오류 메시지를 stderr에 기록하고 종료합니다. 호출자는 자식이 현재 명령에 대한 유효한 응답을 완료하지 않고 연결을 닫으면 적절한 오류 메시지가 인쇄 된 것으로 예상해야합니다.</target>
        </trans-unit>
        <trans-unit id="571d71cd29e09f41d5c855a2a419d634cc0eecce" translate="yes" xml:space="preserve">
          <source>If a filter &lt;code&gt;must&lt;/code&gt; succeed in order to make the stored contents usable, you can declare that the filter is &lt;code&gt;required&lt;/code&gt;, in the configuration:</source>
          <target state="translated">저장된 컨텐츠를 사용 가능하게하기 위해 필터 &lt;code&gt;must&lt;/code&gt; 성공 해야하는 경우 구성에서 필터가 &lt;code&gt;required&lt;/code&gt; 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22e70bb4ff6d3a3dd5464ffc106fa14107a4c8dc" translate="yes" xml:space="preserve">
          <source>If a git directory of a submodule is inside the submodule, move the git directory of the submodule into its superproject&amp;rsquo;s &lt;code&gt;$GIT_DIR/modules&lt;/code&gt; path and then connect the git directory and its working directory by setting the &lt;code&gt;core.worktree&lt;/code&gt; and adding a .git file pointing to the git directory embedded in the superprojects git directory.</source>
          <target state="translated">서브 모듈의 git 디렉토리가 서브 모듈 내부에 있다면, 서브 모듈의 git 디렉토리를 수퍼 프로젝트의 &lt;code&gt;$GIT_DIR/modules&lt;/code&gt; 경로로 옮긴 다음 &lt;code&gt;core.worktree&lt;/code&gt; 를 설정하고 .git 파일을 추가 하여 git 디렉토리와 작업 디렉토리를 연결하십시오 superprojects git 디렉토리에 포함 된 git 디렉토리에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="7b7f1fa74f78e5b674bbee244bef979691bc168d" translate="yes" xml:space="preserve">
          <source>If a helper advertises &lt;code&gt;connect&lt;/code&gt;, Git will use it if possible and fall back to another capability if the helper requests so when connecting (see the &lt;code&gt;connect&lt;/code&gt; command under COMMANDS). When choosing between &lt;code&gt;fetch&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt;, Git prefers &lt;code&gt;fetch&lt;/code&gt;. Other frontends may have some other order of preference.</source>
          <target state="translated">헬퍼가 &lt;code&gt;connect&lt;/code&gt; 를 광고 하면 Git은 가능하면이를 사용하고 헬퍼가 &lt;code&gt;connect&lt;/code&gt; 때 요청하면 다른 기능으로 폴백합니다 ( COMMANDS 의 connect 명령 참조 ). &lt;code&gt;fetch&lt;/code&gt; 와 &lt;code&gt;import&lt;/code&gt; 중에서 선택할 때 Git은 &lt;code&gt;fetch&lt;/code&gt; 선호합니다 . 다른 프론트 엔드에는 다른 우선 순위가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="148562d25b0603b8eee662bc94ef7dd269783449" translate="yes" xml:space="preserve">
          <source>If a helper advertises &lt;code&gt;connect&lt;/code&gt;, Git will use it if possible and fall back to another capability if the helper requests so when connecting (see the &lt;code&gt;connect&lt;/code&gt; command under COMMANDS). When choosing between &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt;, Git prefers &lt;code&gt;push&lt;/code&gt;. Other frontends may have some other order of preference.</source>
          <target state="translated">헬퍼가 &lt;code&gt;connect&lt;/code&gt; 를 광고 하면 Git은 가능하면이를 사용하고 헬퍼가 &lt;code&gt;connect&lt;/code&gt; 때 요청하면 다른 기능으로 폴백합니다 ( COMMANDS 의 connect 명령 참조 ). &lt;code&gt;push&lt;/code&gt; 와 &lt;code&gt;export&lt;/code&gt; 선택할 때 Git은 &lt;code&gt;push&lt;/code&gt; 선호합니다 . 다른 프론트 엔드에는 다른 우선 순위가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c8d1c4561ad329297670b7c11b5cea0c040fa93" translate="yes" xml:space="preserve">
          <source>If a line exists in both the source and destination, exists only once, and starts with this text, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the &quot;patience diff&quot; algorithm internally.</source>
          <target state="translated">소스와 대상 모두에 한 줄이 존재하고 한 번만 존재하며이 텍스트로 시작하면이 알고리즘은 해당 줄이 출력에서 ​​삭제 또는 추가로 표시되지 않도록 시도합니다. 내부적으로 &quot;환자 차이&quot;알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="03800f18f812afe9c365f3cd10e3618c12ca274e" translate="yes" xml:space="preserve">
          <source>If a linked working tree is stored on a portable device or network share which is not always mounted, you can prevent its administrative files from being pruned by issuing the &lt;code&gt;git worktree lock&lt;/code&gt; command, optionally specifying &lt;code&gt;--reason&lt;/code&gt; to explain why the working tree is locked.</source>
          <target state="translated">링크 된 작업 나무는 항상 당신이 실행하여 정리되는 행정 파일을 방지 할 수 있습니다 장착되지 않은 휴대 장치 또는 네트워크 공유에 저장되어있는 경우 &lt;code&gt;git worktree lock&lt;/code&gt; 선택적으로 지정 명령을 &lt;code&gt;--reason&lt;/code&gt; 작업 트리가 잠겨있는 이유를 설명 .</target>
        </trans-unit>
        <trans-unit id="055300f804a90741eca19d86c43f3b133b4438b5" translate="yes" xml:space="preserve">
          <source>If a merge resolution program is not specified, &lt;code&gt;git mergetool&lt;/code&gt; will use the configuration variable &lt;code&gt;merge.tool&lt;/code&gt;. If the configuration variable &lt;code&gt;merge.tool&lt;/code&gt; is not set, &lt;code&gt;git mergetool&lt;/code&gt; will pick a suitable default.</source>
          <target state="translated">병합 해결 프로그램을 지정하지 않으면 &lt;code&gt;git mergetool&lt;/code&gt; 은 구성 변수 &lt;code&gt;merge.tool&lt;/code&gt; 을 사용합니다 . 구성 변수 &lt;code&gt;merge.tool&lt;/code&gt; 이 설정되어 있지 않으면 &lt;code&gt;git mergetool&lt;/code&gt; 이 적절한 기본값을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="1ea5bcda19ff920edc6797065824126354674b5b" translate="yes" xml:space="preserve">
          <source>If a name is specified on stdin that cannot be resolved to an object in the repository, then &lt;code&gt;cat-file&lt;/code&gt; will ignore any custom format and print:</source>
          <target state="translated">stdin에 이름을 지정하여 저장소의 오브젝트로 해석 할 수없는 경우 &lt;code&gt;cat-file&lt;/code&gt; 은 사용자 정의 형식을 무시하고 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b64d6e7bd6f81b6c41d97bf3465e33dac59a1923" translate="yes" xml:space="preserve">
          <source>If a name is specified that might refer to more than one object (an ambiguous short sha), then &lt;code&gt;cat-file&lt;/code&gt; will ignore any custom format and print:</source>
          <target state="translated">둘 이상의 객체 (모호한 짧은 음영)를 나타내는 이름이 지정된 경우 &lt;code&gt;cat-file&lt;/code&gt; 은 사용자 정의 형식을 무시하고 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="6e4b893bbe0d833def4e5b2195c3efca0abfc652" translate="yes" xml:space="preserve">
          <source>If a namespace is in use, the namespace prefix is stripped from each reference before it is matched against &lt;code&gt;transfer.hiderefs&lt;/code&gt; patterns. For example, if &lt;code&gt;refs/heads/master&lt;/code&gt; is specified in &lt;code&gt;transfer.hideRefs&lt;/code&gt; and the current namespace is &lt;code&gt;foo&lt;/code&gt;, then &lt;code&gt;refs/namespaces/foo/refs/heads/master&lt;/code&gt; is omitted from the advertisements but &lt;code&gt;refs/heads/master&lt;/code&gt; and &lt;code&gt;refs/namespaces/bar/refs/heads/master&lt;/code&gt; are still advertised as so-called &quot;have&quot; lines. In order to match refs before stripping, add a &lt;code&gt;^&lt;/code&gt; in front of the ref name. If you combine &lt;code&gt;!&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt; must be specified first.</source>
          <target state="translated">네임 스페이스가 사용중인 경우 네임 스페이스 접두어는 &lt;code&gt;transfer.hiderefs&lt;/code&gt; 패턴 과 일치하기 전에 각 참조에서 제거됩니다 . 예를 들어, &lt;code&gt;refs/heads/master&lt;/code&gt; 가 &lt;code&gt;transfer.hideRefs&lt;/code&gt; 에 지정되고 현재 네임 스페이스가 &lt;code&gt;foo&lt;/code&gt; 인 경우 &lt;code&gt;refs/namespaces/foo/refs/heads/master&lt;/code&gt; 는 알림에서 생략되지만 &lt;code&gt;refs/heads/master&lt;/code&gt; 및 &lt;code&gt;refs/namespaces/bar/refs/heads/master&lt;/code&gt; 는 여전히 소위 &quot;have&quot;라인으로 알려집니다. 벗기기 전에 심판을 맞추 려면 심판 이름 앞에 &lt;code&gt;^&lt;/code&gt; 를 추가하십시오 . 당신이 결합하면 &lt;code&gt;!&lt;/code&gt; 및 &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;!&lt;/code&gt; 먼저 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="01a3979b0db1ea5ddb68d8d2296f1a14d4a19443" translate="yes" xml:space="preserve">
          <source>If a positive depth is requested, the server will compute the set of commits which are no deeper than the desired depth.</source>
          <target state="translated">양의 깊이가 요청되면 서버는 원하는 깊이보다 깊지 않은 커밋 세트를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="1af76a23a450746535be3f72c4b4bca12a2092d2" translate="yes" xml:space="preserve">
          <source>If a push would not result in a &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt; of the remote branch, then it will fail with an error like:</source>
          <target state="translated">푸시 로 인해 원격 브랜치 가 &lt;a href=&quot;#fast-forwards&quot;&gt;빨리 전달&lt;/a&gt; 되지 않으면 다음과 같은 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="74746f4cd8d12a2fd7c6b3eb595d0f3e0b5c16c7" translate="yes" xml:space="preserve">
          <source>If a reflog entry&amp;rsquo;s predecessor is pruned, adjust its &quot;old&quot; SHA-1 to be equal to the &quot;new&quot; SHA-1 field of the entry that now precedes it.</source>
          <target state="translated">참조 로그 항목의 선행 작업이 제거되면 &quot;이전&quot;SHA-1이 이전 항목의 &quot;새&quot;SHA-1 필드와 같도록 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="6545e25a03004b7b80ff7680d7d52c75ae528db2" translate="yes" xml:space="preserve">
          <source>If a specified file is in the index but is missing then it&amp;rsquo;s removed. Default behavior is to ignore removed file.</source>
          <target state="translated">지정된 파일이 색인에 있지만 누락 된 경우 제거됩니다. 기본 동작은 제거 된 파일을 무시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0b6d50904501e60c5730f3fc1689dbda57685832" translate="yes" xml:space="preserve">
          <source>If a specified file isn&amp;rsquo;t in the index already then it&amp;rsquo;s added. Default behaviour is to ignore new files.</source>
          <target state="translated">지정된 파일이 색인에 없으면 추가됩니다. 기본 동작은 새 파일을 무시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a14dea6ce44fe61b94cf6eca48f584619dca6981" translate="yes" xml:space="preserve">
          <source>If a subject is not found in the patch description the patch name is preserved as the 1 line subject in the Git description.</source>
          <target state="translated">패치 설명에서 제목을 찾을 수 없으면 패치 이름은 Git 설명에서 한 줄 제목으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="511834d1553ad3d02aefac42a3d932c821a68c9a" translate="yes" xml:space="preserve">
          <source>If a version-1 repository specifies any &lt;code&gt;extensions.*&lt;/code&gt; keys that the running git has not implemented, the operation MUST NOT proceed. Similarly, if the value of any known key is not understood by the implementation, the operation MUST NOT proceed.</source>
          <target state="translated">버전 1 리포지토리 가 실행중인 git이 구현하지 않은 &lt;code&gt;extensions.*&lt;/code&gt; 키를 지정 하면 작업을 진행해서는 안됩니다. 마찬가지로, 알려진 키의 값을 구현에서 이해하지 못하면 작업을 진행해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7fc57bcdf92fac8f6a715a452b985f9026a5a582" translate="yes" xml:space="preserve">
          <source>If a whole directory is classified as &quot;other&quot;, show just its name (with a trailing slash) and not its whole contents.</source>
          <target state="translated">전체 디렉토리가 &quot;other&quot;로 분류 된 경우 전체 내용이 아닌 이름 (후행 슬래시 포함) 만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="9069929e0dad6127e4d7686101bafb1ad2a53dfd" translate="yes" xml:space="preserve">
          <source>If a working tree is deleted without using &lt;code&gt;git worktree remove&lt;/code&gt;, then its associated administrative files, which reside in the repository (see &quot;DETAILS&quot; below), will eventually be removed automatically (see &lt;code&gt;gc.worktreePruneExpire&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;), or you can run &lt;code&gt;git worktree prune&lt;/code&gt; in the main or any linked working tree to clean up any stale administrative files.</source>
          <target state="translated">작업 트리를 사용하지 않고 삭제하면 &lt;code&gt;git worktree remove&lt;/code&gt; 다음 저장소에있는 관련 관리 파일은, 결국 자동으로 제거됩니다 (아래 &quot;세부 사항&quot;참조) (참조 &lt;code&gt;gc.worktreePruneExpire&lt;/code&gt; 을 에 &lt;a href=&quot;git-config&quot;&gt;자식-설정 [1]&lt;/a&gt; ), 또는 기본 또는 연결된 작업 트리에서 &lt;code&gt;git worktree prune&lt;/code&gt; 을 실행 하여 오래된 관리 파일을 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="601f99371e1781bbcc6e4fbcb70987193e9cb892" translate="yes" xml:space="preserve">
          <source>If a working tree is on a portable device or network share which is not always mounted, lock it to prevent its administrative files from being pruned automatically. This also prevents it from being moved or deleted. Optionally, specify a reason for the lock with &lt;code&gt;--reason&lt;/code&gt;.</source>
          <target state="translated">작업 트리가 항상 마운트되지 않은 휴대용 장치 또는 네트워크 공유에있는 경우 관리 파일이 자동으로 정리되지 않도록 잠그십시오. 또한 이동되거나 삭제되지 않습니다. 선택적으로 &lt;code&gt;--reason&lt;/code&gt; 을 사용하여 잠금 이유를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c89355d42dbc93622cf0025bcf122df76b472f1" translate="yes" xml:space="preserve">
          <source>If advertised, indicates that any number of server specific options can be included in a request. This is done by sending each option as a &quot;server-option=&amp;lt;option&amp;gt;&quot; capability line in the capability-list section of a request.</source>
          <target state="translated">보급 된 경우, 서버 특정 옵션을 요청에 포함 할 수 있음을 나타냅니다. 이는 요청의 기능 목록 섹션에서 각 옵션을 &quot;server-option = &amp;lt;option&amp;gt;&quot;기능 행으로 전송하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c768073bebd10b960d1a77545805ba6684f69c55" translate="yes" xml:space="preserve">
          <source>If after this parent rewriting, &lt;code&gt;C'&lt;/code&gt; is a root or merge commit (has zero or &amp;gt;1 parents), a boundary commit, or !TREESAME, it remains. Otherwise, it is replaced with its only parent.</source>
          <target state="translated">이 부모 재 작성 후에 &lt;code&gt;C'&lt;/code&gt; 가 루트 또는 병합 커밋 (0 또는&amp;gt; 1 부모가 있음), 경계 커밋 또는! TREESAME이면 그대로 유지됩니다. 그렇지 않으면 유일한 부모로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="331241d5d1136bad0fab6978a8eab7a815b255e9" translate="yes" xml:space="preserve">
          <source>If all &amp;lt;ref&amp;gt;s can be locked with matching &amp;lt;oldvalue&amp;gt;s simultaneously, all modifications are performed. Otherwise, no modifications are performed. Note that while each individual &amp;lt;ref&amp;gt; is updated or deleted atomically, a concurrent reader may still see a subset of the modifications.</source>
          <target state="translated">일치하는 &amp;lt;oldvalue&amp;gt;로 모든 &amp;lt;ref&amp;gt;를 동시에 잠글 수있는 경우 모든 수정이 수행됩니다. 그렇지 않으면 수정이 수행되지 않습니다. 각 개별 &amp;lt;ref&amp;gt;가 원자 적으로 업데이트되거나 삭제되는 동안 동시 판독기는 여전히 수정의 하위 집합을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2745e08ed788856c12f02ca7a5befc54f3c9443" translate="yes" xml:space="preserve">
          <source>If all named commits are already ancestors of &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;git merge&lt;/code&gt; will exit early with the message &quot;Already up to date.&quot;</source>
          <target state="translated">모든 이름 커밋의 조상이 이미있는 경우 &lt;code&gt;HEAD&lt;/code&gt; 가 , &lt;code&gt;git merge&lt;/code&gt; 초기 메시지와 함께 종료됩니다 &quot;이미 최신.&quot;</target>
        </trans-unit>
        <trans-unit id="cf6cb5a66ab4b3c3c33160d1bdddf3e27a51bd6e" translate="yes" xml:space="preserve">
          <source>If all you really want to do is to remove from the index the files that are no longer present in the working tree (perhaps because your working tree is dirty so that you cannot use &lt;code&gt;git commit -a&lt;/code&gt;), use the following command:</source>
          <target state="translated">작업 트리에 더 이상 존재하지 않는 파일을 인덱스에서 제거하는 것만 큼 원하는 경우 (아마도 작업 트리가 &lt;code&gt;git commit -a&lt;/code&gt; 사용할 수 없기 때문에 ) 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="232e0a33b39a8eedbea0de34207896fce9d5da1b" translate="yes" xml:space="preserve">
          <source>If an SVN revision has a property, &quot;svm:headrev&quot;, it is likely that the revision was created by SVN::Mirror (also used by SVK). The property contains a repository UUID and a revision. We want to make it look like we are mirroring the original URL, so introduce a helper function that returns the original identity URL and UUID, and use it when generating metadata in commit messages.</source>
          <target state="translated">SVN 개정판에 &quot;svm : headrev&quot;특성이있는 경우 SVN :: Mirror (SVK에서도 사용)에 의해 개정판이 작성되었을 수 있습니다. 이 특성에는 저장소 UUID 및 개정판이 포함되어 있습니다. 원래 URL을 미러링하는 것처럼 보이게 만들고자하므로 원래 ID URL과 UUID를 반환하고 커밋 메시지에서 메타 데이터를 생성 할 때 사용하는 도우미 함수를 소개합니다.</target>
        </trans-unit>
        <trans-unit id="8ec6058ea575ab09ff2743fac6f67664b17c975f" translate="yes" xml:space="preserve">
          <source>If an alias is given, git shows the definition of the alias on standard output. To get the manual page for the aliased command, use &lt;code&gt;git COMMAND --help&lt;/code&gt;.</source>
          <target state="translated">별명이 주어지면, git은 표준 출력에서 ​​별명의 정의를 보여줍니다. 별칭 명령의 매뉴얼 페이지를 얻으려면 &lt;code&gt;git COMMAND --help&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="06b64f77884080bf4b8a1b3580804b4fc90c62bc" translate="yes" xml:space="preserve">
          <source>If an exact match was not found, &lt;code&gt;git describe&lt;/code&gt; will walk back through the commit history to locate an ancestor commit which has been tagged. The ancestor&amp;rsquo;s tag will be output along with an abbreviation of the input commit-ish&amp;rsquo;s SHA-1. If &lt;code&gt;--first-parent&lt;/code&gt; was specified then the walk will only consider the first parent of each commit.</source>
          <target state="translated">정확히 일치하는 것을 찾을 수 없으면, &lt;code&gt;git describe&lt;/code&gt; 는 커밋 히스토리를 통해 태그 된 상위 커밋을 찾습니다. 조상의 태그는 입력 커밋의 SHA-1의 약어와 함께 출력됩니다. 경우 &lt;code&gt;--first-parent&lt;/code&gt; 지정된 후, 도보 각 커밋의 첫 번째 부모를 고려할 것입니다.</target>
        </trans-unit>
        <trans-unit id="98c6f5f40e2b8ae0667cb14d2e8af19ba85f9e07" translate="yes" xml:space="preserve">
          <source>If an existing replace ref for the same object exists, it will be overwritten (instead of failing).</source>
          <target state="translated">동일한 객체에 대한 기존 교체 참조가 있으면 실패 대신 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="046c10da2487af8c5911472dad4ec66653003b0a" translate="yes" xml:space="preserve">
          <source>If any &amp;lt;file&amp;gt; does not appear in the index, treat this as an error (return 1).</source>
          <target state="translated">&amp;lt;file&amp;gt;이 색인에 나타나지 않으면이를 오류로 간주하십시오 (반환 1).</target>
        </trans-unit>
        <trans-unit id="d5c329c54100c9f229f2bd1af9a36354df219a33" translate="yes" xml:space="preserve">
          <source>If any evaluation of &amp;lt;command&amp;gt; returns a non-zero exit status, the whole operation will be aborted.</source>
          <target state="translated">&amp;lt;command&amp;gt;에 대한 평가가 0이 아닌 종료 상태를 반환하면 전체 작업이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="939ada40ab0c594838b538aaf9b14ce39d17200d" translate="yes" xml:space="preserve">
          <source>If any file doesn&amp;rsquo;t begin with a From line, assume it is a single mail message instead of signaling error.</source>
          <target state="translated">From 줄로 시작하지 않는 파일이 있으면 신호 오류 대신 단일 메일 메시지라고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="824867a2502f9c0cf53ed6a13fd4b286bb82c4ed" translate="yes" xml:space="preserve">
          <source>If any files that should not be normalized show up in &lt;code&gt;git status&lt;/code&gt;, unset their &lt;code&gt;text&lt;/code&gt; attribute before running &lt;code&gt;git add -u&lt;/code&gt;.</source>
          <target state="translated">정규화하지 않아야하는 파일이 &lt;code&gt;git status&lt;/code&gt; 표시되면 &lt;code&gt;git add -u&lt;/code&gt; 를 실행하기 전에 해당 &lt;code&gt;text&lt;/code&gt; 속성을 설정 해제 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c34b6095a9c49861d2acc43610b57c3a4a36934" translate="yes" xml:space="preserve">
          <source>If any files were ever &quot;cvs import&quot;ed more than once (e.g., import of more than one vendor release) the HEAD contains the wrong content.</source>
          <target state="translated">파일이 두 번 이상 &quot;cvs import&quot;된 경우 (예 : 둘 이상의 공급 업체 릴리스 가져 오기) HEAD에 잘못된 내용이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a184d41ad4c8629ad4f2bce24803b0c9fa2c0bb" translate="yes" xml:space="preserve">
          <source>If any of the remote changes overlap with local uncommitted changes, the merge will be automatically canceled and the work tree untouched. It is generally best to get any local changes in working order before pulling or stash them away with &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">원격 변경 내용이 커밋되지 않은 로컬 변경 내용과 겹치면 병합이 자동으로 취소되고 작업 트리가 수정되지 않습니다. 일반적으로 &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]을 사용&lt;/a&gt; 하여 변경하거나 가져 오기 전에 작업 순서에서 로컬 변경 사항을 얻는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="27aabdb37af0432fadcd5ffecc44449505cac9be" translate="yes" xml:space="preserve">
          <source>If any optional &lt;code&gt;&amp;lt;path&amp;gt;...&lt;/code&gt; arguments are given, only those paths are affected.</source>
          <target state="translated">선택적 &lt;code&gt;&amp;lt;path&amp;gt;...&lt;/code&gt; 인수가 제공되면 해당 경로 만 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="d20da8878e924b8ea99ba5928199985d6eb45c5b" translate="yes" xml:space="preserve">
          <source>If at least one of the specified mechanisms matches the ones advertised by the SMTP server and if it is supported by the utilized SASL library, the mechanism is used for authentication. If neither &lt;code&gt;sendemail.smtpAuth&lt;/code&gt; nor &lt;code&gt;--smtp-auth&lt;/code&gt; is specified, all mechanisms supported by the SASL library can be used. The special value &lt;code&gt;none&lt;/code&gt; maybe specified to completely disable authentication independently of &lt;code&gt;--smtp-user&lt;/code&gt;</source>
          <target state="translated">지정된 메커니즘 중 하나 이상이 SMTP 서버에 의해 보급 된 메커니즘과 일치하고 사용 된 SASL 라이브러리에서 지원되는 메커니즘과 일치하면이 메커니즘이 인증에 사용됩니다. 어느 경우 &lt;code&gt;sendemail.smtpAuth&lt;/code&gt; 도 &lt;code&gt;--smtp-auth&lt;/code&gt; 지정되면, SASL 라이브러리가 지원하는 모든 메커니즘을 사용할 수 있습니다. &lt;code&gt;--smtp-user&lt;/code&gt; 와 독립적으로 인증을 완전히 비활성화하기 위해 특별한 값을 지정 &lt;code&gt;none&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d66be204c5192d97175dc2e5a6cea91a845a9494" translate="yes" xml:space="preserve">
          <source>If config parameter &quot;core.logAllRefUpdates&quot; is true and the ref is one under &quot;refs/heads/&quot;, &quot;refs/remotes/&quot;, &quot;refs/notes/&quot;, or the symbolic ref HEAD; or the file &quot;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&quot; exists then &lt;code&gt;git update-ref&lt;/code&gt; will append a line to the log file &quot;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&quot; (dereferencing all symbolic refs before creating the log name) describing the change in ref value. Log lines are formatted as:</source>
          <target state="translated">구성 매개 변수 &quot;core.logAllRefUpdates&quot;가 true이고 참조가 &quot;refs / heads /&quot;, &quot;refs / remotes /&quot;, &quot;refs / notes /&quot;또는 기호 참조 HEAD 중 하나 인 경우; 또는 &quot;$ GIT_DIR / logs / &amp;lt;ref&amp;gt;&quot;파일이 존재하면 &lt;code&gt;git update-ref&lt;/code&gt; 는 로그 파일 &quot;$ GIT_DIR / logs / &amp;lt;ref&amp;gt;&quot;(로그 이름을 만들기 전에 모든 기호 참조를 참조)에 줄을 추가합니다. 심판 가치의 변화. 로그 라인의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb79d7b0840991ebe429aab3a3410932b975f32c" translate="yes" xml:space="preserve">
          <source>If conflicts arise and a strategy for automatically resolving conflicting notes (see the &quot;NOTES MERGE STRATEGIES&quot; section) is not given, the &quot;manual&quot; resolver is used. This resolver checks out the conflicting notes in a special worktree (&lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt;), and instructs the user to manually resolve the conflicts there. When done, the user can either finalize the merge with &lt;code&gt;git notes merge --commit&lt;/code&gt;, or abort the merge with &lt;code&gt;git notes merge --abort&lt;/code&gt;.</source>
          <target state="translated">충돌이 발생하고 충돌 메모를 자동으로 해결하기위한 전략 ( &quot;노트 병합 전략&quot;섹션 참조)이 제공되지 않으면 &quot;수동&quot;리졸버가 사용됩니다. 이 리졸버는 특수 작업 트리 ( &lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt; ) 에서 충돌하는 노트를 확인 하고 사용자에게 충돌을 수동으로 해결하도록 지시합니다. 완료되면 사용자는 &lt;code&gt;git notes merge --commit&lt;/code&gt; 으로 병합을 완료하거나 git notes merge --abort로 병합을 중단 &lt;code&gt;git notes merge --abort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a02a69db3092fb7486e9bff9ff76c98958fe4d57" translate="yes" xml:space="preserve">
          <source>If core.commitGraph is true, the commit-graph file will also be inspected using &lt;code&gt;git commit-graph verify&lt;/code&gt;. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt;.</source>
          <target state="translated">core.commitGraph가 true 인 경우 커밋 그래프 파일도 &lt;code&gt;git commit-graph verify&lt;/code&gt; 를 사용하여 검사됩니다 . &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8280fdd5ec3fb25317b497d70f747c3177f7ef0e" translate="yes" xml:space="preserve">
          <source>If disabled with &quot;--no-thread&quot;, those headers will not be added (unless specified with --in-reply-to). Default is the value of the &lt;code&gt;sendemail.thread&lt;/code&gt; configuration value; if that is unspecified, default to --thread.</source>
          <target state="translated">&quot;-스레드 없음&quot;으로 비활성화하면 해당 헤더가 추가되지 않습니다 (--in-reply-to로 지정되지 않은 경우). 기본값은 &lt;code&gt;sendemail.thread&lt;/code&gt; 구성 값입니다. 지정되지 않은 경우 기본값은 --thread입니다.</target>
        </trans-unit>
        <trans-unit id="f00c2d7bc0317e9cad287fad199ae73edff4a848" translate="yes" xml:space="preserve">
          <source>If either &amp;lt;upstream&amp;gt; or --root is given on the command line, then the default is &lt;code&gt;--no-fork-point&lt;/code&gt;, otherwise the default is &lt;code&gt;--fork-point&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;upstream&amp;gt; 또는 --root가 명령 행에 제공되면 기본값은 &lt;code&gt;--no-fork-point&lt;/code&gt; 이고, 그렇지 않으면 기본값은 &lt;code&gt;--fork-point&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a4729a11522c55d49b0e7c329a8805975c4198d9" translate="yes" xml:space="preserve">
          <source>If either of these environment variables is set then &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; will use the specified command instead of &lt;code&gt;ssh&lt;/code&gt; when they need to connect to a remote system. The command-line parameters passed to the configured command are determined by the ssh variant. See &lt;code&gt;ssh.variant&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.</source>
          <target state="translated">이러한 환경 변수 중 하나가 설정되면 &lt;code&gt;git fetch&lt;/code&gt; 및 &lt;code&gt;git push&lt;/code&gt; 는 원격 시스템에 연결해야 할 때 &lt;code&gt;ssh&lt;/code&gt; 대신 지정된 명령 을 사용합니다. 구성된 명령에 전달 된 명령 줄 매개 변수는 ssh 변형에 의해 결정됩니다. 자세한 내용 은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]의 &lt;/a&gt; &lt;code&gt;ssh.variant&lt;/code&gt; 옵션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="3669ee4e6fd1ff3473f59b85f73b98bc8093a5f0" translate="yes" xml:space="preserve">
          <source>If enabled the helper should automatically fetch annotated tag objects if the object the tag points at was transferred during the fetch command. If the tag is not fetched by the helper a second fetch command will usually be sent to ask for the tag specifically. Some helpers may be able to use this option to avoid a second network connection.</source>
          <target state="translated">활성화 된 경우, 페치 명령 동안 태그가 가리키는 오브젝트가 전송 된 경우 헬퍼는 주석이 달린 태그 오브젝트를 자동으로 페치해야합니다. 도우미가 태그를 가져 오지 않으면 일반적으로 두 번째 가져 오기 명령을 보내 태그를 구체적으로 요청합니다. 일부 도우미는이 옵션을 사용하여 두 번째 네트워크 연결을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27acfa87cdb69a824b9bae48206b42168ffde848" translate="yes" xml:space="preserve">
          <source>If enabled, &lt;code&gt;git p4 submit&lt;/code&gt; will attempt to cleanup RCS keywords ($Header$, etc). These would otherwise cause merge conflicts and prevent the submit going ahead. This option should be considered experimental at present.</source>
          <target state="translated">활성화되면 &lt;code&gt;git p4 submit&lt;/code&gt; 은 RCS 키워드 정리 ($ Header $ 등)를 시도합니다. 그렇지 않으면 병합 충돌이 발생하여 제출이 진행되지 않습니다. 이 옵션은 현재 실험적인 것으로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="551059a87916480f640c4e8b1f0ae5467d5d2b16" translate="yes" xml:space="preserve">
          <source>If everything fails, or if no viewer is configured, the viewer specified in the &lt;code&gt;GIT_MAN_VIEWER&lt;/code&gt; environment variable will be tried. If that fails too, the &lt;code&gt;man&lt;/code&gt; program will be tried anyway.</source>
          <target state="translated">모든 것이 실패하거나 뷰어가 구성되지 않은 경우 &lt;code&gt;GIT_MAN_VIEWER&lt;/code&gt; 환경 변수에 지정된 뷰어 가 시도됩니다. 이것도 실패하면 &lt;code&gt;man&lt;/code&gt; 프로그램은 어쨌든 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="dc951917b8a4344a8f095e91594828b8eb0d132d" translate="yes" xml:space="preserve">
          <source>If explicit refspecs were given on the command line of &lt;code&gt;git pull&lt;/code&gt;, they are all merged.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 의 명령 행에 명시 적 참조 스펙이 제공된 경우 모두 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="9f9421c37df0f080e8411a466937f35ec8c1d1a5" translate="yes" xml:space="preserve">
          <source>If false, symbolic links are checked out as small plain files that contain the link text. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; and &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; will not change the recorded type to regular file. Useful on filesystems like FAT that do not support symbolic links.</source>
          <target state="translated">False 인 경우 심볼릭 링크는 링크 텍스트가 포함 된 작은 일반 파일로 체크 아웃됩니다. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt; 및 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 은 기록 된 유형을 일반 파일로 변경하지 않습니다. 기호 링크를 지원하지 않는 FAT와 같은 파일 시스템에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8463a48927d35802080dff1be147345270adfa9a" translate="yes" xml:space="preserve">
          <source>If false, the ctime differences between the index and the working tree are ignored; useful when the inode change time is regularly modified by something outside Git (file system crawlers and some backup systems). See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;. True by default.</source>
          <target state="translated">False 인 경우 인덱스와 작업 트리 간의 ctime 차이는 무시됩니다. inode 변경 시간이 Git 외부의 파일 시스템 (파일 시스템 크롤러 및 일부 백업 시스템)에 의해 정기적으로 수정 될 때 유용합니다. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]를&lt;/a&gt; 참조하십시오 . 기본적으로 true입니다.</target>
        </trans-unit>
        <trans-unit id="c3b2c82ffccecb89175e5c1911567eb5a6cff2f5" translate="yes" xml:space="preserve">
          <source>If fast-import is supplied invalid input it will terminate with a non-zero exit status and create a crash report in the top level of the Git repository it was importing into. Crash reports contain a snapshot of the internal fast-import state as well as the most recent commands that lead up to the crash.</source>
          <target state="translated">빠른 가져 오기에 유효하지 않은 입력이 제공되면 0이 아닌 종료 상태로 종료되고 가져 오는 Git 저장소의 최상위 레벨에 충돌 보고서가 작성됩니다. 충돌 보고서에는 내부 빠른 가져 오기 상태의 스냅 샷과 충돌을 일으키는 최신 명령이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b4b929406272978e9913bc69bd98a25fedb2b075" translate="yes" xml:space="preserve">
          <source>If generating diffs, detect and report renames for each commit. For following files across renames while traversing history, see &lt;code&gt;--follow&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is specified, it is a threshold on the similarity index (i.e. amount of addition/deletions compared to the file&amp;rsquo;s size). For example, &lt;code&gt;-M90%&lt;/code&gt; means Git should consider a delete/add pair to be a rename if more than 90% of the file hasn&amp;rsquo;t changed. Without a &lt;code&gt;%&lt;/code&gt; sign, the number is to be read as a fraction, with a decimal point before it. I.e., &lt;code&gt;-M5&lt;/code&gt; becomes 0.5, and is thus the same as &lt;code&gt;-M50%&lt;/code&gt;. Similarly, &lt;code&gt;-M05&lt;/code&gt; is the same as &lt;code&gt;-M5%&lt;/code&gt;. To limit detection to exact renames, use &lt;code&gt;-M100%&lt;/code&gt;. The default similarity index is 50%.</source>
          <target state="translated">diff를 생성하는 경우 각 커밋에 대한 이름 변경을 감지하고보고하십시오. 히스토리를 순회하면서 이름을 &lt;code&gt;--follow&lt;/code&gt; 파일에 대해서는 --follow를 참조하십시오 . 경우 &lt;code&gt;n&lt;/code&gt; 을 지정, 그것은 유사성 지수 임계 값 (파일의 크기에 비해 추가 / 삭제의 예 양)입니다. 예를 들어, &lt;code&gt;-M90%&lt;/code&gt; 는 파일의 90 % 이상이 변경되지 않은 경우 Git이 삭제 / 추가 쌍을 이름 바꾸기로 간주해야 함을 의미합니다. &lt;code&gt;%&lt;/code&gt; 부호가 없으면 숫자는 소수점 앞에 소수점을 사용하여 분수로 읽습니다. 즉, &lt;code&gt;-M5&lt;/code&gt; 는 0.5가되므로 &lt;code&gt;-M50%&lt;/code&gt; 와 같습니다 . 마찬가지로 &lt;code&gt;-M05&lt;/code&gt; 는 -M5 &lt;code&gt;-M5%&lt;/code&gt; 와 동일 합니다. 정확한 이름 변경으로 탐지를 제한하려면 &lt;code&gt;-M100%&lt;/code&gt; 사용 하십시오.. 기본 유사성 지수는 50 %입니다.</target>
        </trans-unit>
        <trans-unit id="6bf34c88ee2af8f797d0000ddc97681383ffc8ba" translate="yes" xml:space="preserve">
          <source>If git fetch fails because the new head of a branch is not a descendant of the old head, you may force the update with:</source>
          <target state="translated">분기의 새 헤드가 이전 헤드의 후손이 아니기 때문에 git fetch가 실패하면 다음을 사용하여 업데이트를 강제 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e083719ea272a39b1421c558e4392c556db2e4ef" translate="yes" xml:space="preserve">
          <source>If given &lt;code&gt;--thread&lt;/code&gt;, &lt;code&gt;git-format-patch&lt;/code&gt; will generate &lt;code&gt;In-Reply-To&lt;/code&gt; and &lt;code&gt;References&lt;/code&gt; headers to make the second and subsequent patch mails appear as replies to the first mail; this also generates a &lt;code&gt;Message-Id&lt;/code&gt; header to reference.</source>
          <target state="translated">주어진 경우 &lt;code&gt;--thread&lt;/code&gt; , &lt;code&gt;git-format-patch&lt;/code&gt; 생성 &lt;code&gt;In-Reply-To&lt;/code&gt; 과 &lt;code&gt;References&lt;/code&gt; 두 번째 이후 패치 메일이 첫 번째 메일에 대한 응답으로 표시 할 헤더를; 또한 참조 할 &lt;code&gt;Message-Id&lt;/code&gt; 헤더를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="b8bcbf4a83fcf4f75c98a2212241bdcbc1331a73" translate="yes" xml:space="preserve">
          <source>If given, limit the search to paths matching at least one pattern. Both leading paths match and glob(7) patterns are supported.</source>
          <target state="translated">주어진 경우, 하나 이상의 패턴과 일치하는 경로로 검색을 제한하십시오. 선행 경로가 일치하고 glob (7) 패턴이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0f1d3c019382d162e2080cbdc28ed58b9e3bfa0a" translate="yes" xml:space="preserve">
          <source>If given, strings that substitute &lt;code&gt;%(fieldname)&lt;/code&gt; placeholders are quoted as string literals suitable for the specified host language. This is meant to produce a scriptlet that can directly be `eval`ed.</source>
          <target state="translated">주어진 경우, &lt;code&gt;%(fieldname)&lt;/code&gt; 자리 표시자를 대체 하는 문자열은 지정된 호스트 언어에 적합한 문자열 리터럴로 인용됩니다. 이것은 직접 평가할 수있는 스크립틀릿을 생성하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="fbaedaa3bd6d3e9940a1f51ae6f8f8f02a814640" translate="yes" xml:space="preserve">
          <source>If history is linear and HEAD is an ancestor of next, update the working tree and advance the HEAD pointer to match next. Otherwise, apply the changes introduced by those commits that are in next but not HEAD to the current branch, creating a new commit for each new change.</source>
          <target state="translated">히스토리가 선형이고 HEAD가 다음의 조상이면 작업 트리를 업데이트하고 HEAD 포인터를 다음과 일치하도록 진행하십시오. 그렇지 않으면 다음에 있지만 커밋되지 않은 커밋이 도입 한 변경 사항을 현재 분기에 적용하여 새 변경 사항마다 새 커밋을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c5f1ba7eca8a5dae95e4277b8eb6e331cbac924e" translate="yes" xml:space="preserve">
          <source>If it does not apply correctly, there can be various reasons.</source>
          <target state="translated">제대로 적용되지 않으면 여러 가지 이유가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="527b079607be5b2a4ead185d633224b57d83444a" translate="yes" xml:space="preserve">
          <source>If it exits with non-zero status, then the working tree will not be committed after applying the patch.</source>
          <target state="translated">0이 아닌 상태로 종료되면 패치를 적용한 후 작업 트리가 커밋되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="769efb2c6e10769ef0506d8fb6e30821bd41e6ea" translate="yes" xml:space="preserve">
          <source>If it happens that one merge base is bad, then the bisection process is stopped with a message like:</source>
          <target state="translated">하나의 병합 기반이 잘못되면 다음과 같은 메시지와 함께 이분법 프로세스가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="d7b7066e9f3ba640d6b7d345ddda270a80c2a559" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;after&lt;/code&gt;, then each new trailer will appear just after the last trailer with the same &amp;lt;token&amp;gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;after&lt;/code&gt; , 각각의 새로운 트레일러는 &amp;lt;토큰&amp;gt; 같은과 마지막 트레일러 후에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="f2bafbae3498cf1dc8b7c4f581b63d0bfa115d9a" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;before&lt;/code&gt;, then each new trailer will appear just before the first trailer with the same &amp;lt;token&amp;gt;.</source>
          <target state="translated">&lt;code&gt;before&lt;/code&gt; 인 경우 , 각각의 새 트레일러는 동일한 &amp;lt;토큰&amp;gt;을 가진 첫 번째 트레일러 바로 앞에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="76425e0a50de1913b3cc7557f216714041d9e64a" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;end&lt;/code&gt;, then each new trailer will appear at the end of the existing trailers.</source>
          <target state="translated">이 경우 &lt;code&gt;end&lt;/code&gt; 후, 각각의 새로운 트레일러는 기존 트레일러의 끝 부분에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="df34e468f7176e0de86a55be70b61c5f69c7697c" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;start&lt;/code&gt;, then each new trailer will appear at the start, instead of the end, of the existing trailers.</source>
          <target state="translated">그것이 &lt;code&gt;start&lt;/code&gt; 이면, 각각의 새로운 트레일러는 기존 트레일러의 끝이 아니라 시작에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4def1637480df26c3310f2a04dde58c55a8e6a6e" translate="yes" xml:space="preserve">
          <source>If it is set to true, git-fetch-pack will check all fetched objects. See &lt;code&gt;transfer.fsckObjects&lt;/code&gt; for what&amp;rsquo;s checked. Defaults to false. If not set, the value of &lt;code&gt;transfer.fsckObjects&lt;/code&gt; is used instead.</source>
          <target state="translated">그것이 true로 설정되면, git-fetch-pack은 가져온 모든 객체를 검사합니다. 확인 된 내용은 &lt;code&gt;transfer.fsckObjects&lt;/code&gt; 를 참조하십시오 . 기본값은 false입니다. 설정하지 않으면 &lt;code&gt;transfer.fsckObjects&lt;/code&gt; 값이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c85a90553a06232b5ee8a2aebb2a31cb696c1660" translate="yes" xml:space="preserve">
          <source>If it is set to true, git-receive-pack will check all received objects. See &lt;code&gt;transfer.fsckObjects&lt;/code&gt; for what&amp;rsquo;s checked. Defaults to false. If not set, the value of &lt;code&gt;transfer.fsckObjects&lt;/code&gt; is used instead.</source>
          <target state="translated">그것이 true로 설정되면, git-receive-pack은 모든 수신 된 객체를 검사합니다. 확인 된 내용은 &lt;code&gt;transfer.fsckObjects&lt;/code&gt; 를 참조하십시오 . 기본값은 false입니다. 설정하지 않으면 &lt;code&gt;transfer.fsckObjects&lt;/code&gt; 값이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f046c10bd7462cc956529dcbe0a86de2200086ed" translate="yes" xml:space="preserve">
          <source>If it turns out whatever you have done is worth keeping, you can always create a new name for it (without switching away):</source>
          <target state="translated">수행 한 작업이 유지해야 할 가치가있는 것으로 판명되면 언제든지 새 이름을 만들 수 있습니다 (전환하지 않고).</target>
        </trans-unit>
        <trans-unit id="4d0ff556eb63bcc0fd849ad26a1310c3a4323d31" translate="yes" xml:space="preserve">
          <source>If it&amp;rsquo;s not set, filesystem directory&amp;rsquo;s owner is used (via GECOS field, i.e. real name field from &lt;strong&gt;getpwuid&lt;/strong&gt;(3)) if &lt;code&gt;$projects_list&lt;/code&gt; is unset (gitweb scans &lt;code&gt;$projectroot&lt;/code&gt; for repositories); if &lt;code&gt;$projects_list&lt;/code&gt; points to file with list of repositories, then project owner defaults to value from this file for given repository.</source>
          <target state="translated">설정되지 않은 경우 &lt;code&gt;$projects_list&lt;/code&gt; 가 설정되어 있지 않으면 (gitweb 이 저장소에 대해 &lt;code&gt;$projectroot&lt;/code&gt; 를 스캔 함) 파일 시스템 디렉토리의 소유자가 사용됩니다 (GECOS 필드, 즉 &lt;strong&gt;getpwuid의&lt;/strong&gt; 실제 이름 필드 (3) 사용 ). &lt;code&gt;$projects_list&lt;/code&gt; 가 리포지토리 목록이있는 파일을 가리키는 경우 프로젝트 소유자는 지정된 리포지토리에 대해이 파일의 값을 기본값으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1cadf23ffce6eccc7a87c304031ef4b8e4d3adc6" translate="yes" xml:space="preserve">
          <source>If large offsets are required, we use another list of large offsets similar to version 2 pack-indexes.</source>
          <target state="translated">큰 오프셋이 필요한 경우 버전 2 팩 인덱스와 유사한 다른 큰 오프셋 목록을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="960d179c1e161024bf740912a06839844c1002e6" translate="yes" xml:space="preserve">
          <source>If left to accumulate, these stale references might make performance worse on big and busy repos that have a lot of branch churn, and e.g. make the output of commands like &lt;code&gt;git branch -a --contains
&amp;lt;commit&amp;gt;&lt;/code&gt; needlessly verbose, as well as impacting anything else that&amp;rsquo;ll work with the complete set of known references.</source>
          <target state="translated">누적 된 상태로 남겨둔 경우, 이러한 오래된 참조는 분기 이탈이 많은 크고 바쁜 &lt;code&gt;git branch -a --contains &amp;lt;commit&amp;gt;&lt;/code&gt; 에서 성능을 저하시킬 수 있습니다. 예를 들어 git branch -a 와 같은 명령의 출력을 만드는 것은 &amp;lt;commit&amp;gt;을 불필요하게 상세하게 포함하고 영향을 미칩니다 알려진 일련의 알려진 참조와 함께 작동하는 다른 것.</target>
        </trans-unit>
        <trans-unit id="703f6583148f1f4b148dcc92cca37187812e5840" translate="yes" xml:space="preserve">
          <source>If merge is called without any commit argument, merge the upstream branches configured for the current branch by using their last observed values stored in their remote-tracking branches. The values of the &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.merge&lt;/code&gt; that name the branches at the remote named by &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.remote&lt;/code&gt; are consulted, and then they are mapped via &lt;code&gt;remote.&amp;lt;remote&amp;gt;.fetch&lt;/code&gt; to their corresponding remote-tracking branches, and the tips of these tracking branches are merged.</source>
          <target state="translated">commit 인수없이 merge를 호출하면 원격 추적 분기에 저장된 마지막 관찰 된 값을 사용하여 현재 분기에 대해 구성된 업스트림 분기를 병합합니다. 의 값 &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.merge&lt;/code&gt; 원격으로 명명에 그 이름을 분기를 &lt;code&gt;branch.&amp;lt;current branch&amp;gt;.remote&lt;/code&gt; 협의하고, 그 후에는로 매핑되는 &lt;code&gt;remote.&amp;lt;remote&amp;gt;.fetch&lt;/code&gt; 그들의 remote- 대응하는 추적 지점과 이러한 추적 지점의 팁이 병합되었습니다.</target>
        </trans-unit>
        <trans-unit id="115451ca901f83782dcbbcd683a49aed658e9f54" translate="yes" xml:space="preserve">
          <source>If more than one --branches (or --tags) option was given to the &lt;code&gt;init&lt;/code&gt; or &lt;code&gt;clone&lt;/code&gt; command, you must provide the location of the branch (or tag) you wish to create in the SVN repository. &amp;lt;path&amp;gt; specifies which path to use to create the branch or tag and should match the pattern on the left-hand side of one of the configured branches or tags refspecs. You can see these refspecs with the commands</source>
          <target state="translated">&lt;code&gt;init&lt;/code&gt; 또는 &lt;code&gt;clone&lt;/code&gt; 명령에 둘 이상의 --branches (또는 --tags) 옵션이 제공된 경우 SVN 저장소에서 작성하려는 분기 (또는 태그)의 위치를 ​​제공해야합니다. &amp;lt;path&amp;gt;는 분기 또는 태그를 작성하는 데 사용할 경로를 지정하며 구성된 분기 또는 태그 참조 스펙 중 하나의 왼쪽에있는 패턴과 일치해야합니다. 명령을 사용하여 이러한 참조 사양을 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="720d1ff370baad05fcb8565540994e450819ec63" translate="yes" xml:space="preserve">
          <source>If more than one suffixes match the same tagname, then that tagname will be sorted according to the suffix which starts at the earliest position in the tagname. If more than one different matching suffixes start at that earliest position, then that tagname will be sorted according to the longest of those suffixes. The sorting order between different suffixes is undefined if they are in multiple config files.</source>
          <target state="translated">둘 이상의 접미사가 동일한 태그 이름과 일치하면 해당 태그 이름은 태그 이름의 가장 빠른 위치에서 시작하는 접미사에 따라 정렬됩니다. 하나 이상의 서로 다른 일치하는 접미사가 가장 빠른 위치에서 시작되면 해당 접미사 중 가장 긴 접미사에 따라 태그 이름이 정렬됩니다. 다른 접미사 간의 정렬 순서는 여러 구성 파일에있는 경우 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3ac1856f1f0f57064ddb5057de6638c24881f47" translate="yes" xml:space="preserve">
          <source>If multiple tags were found during the walk then the tag which has the fewest commits different from the input commit-ish will be selected and output. Here fewest commits different is defined as the number of commits which would be shown by &lt;code&gt;git log tag..input&lt;/code&gt; will be the smallest number of commits possible.</source>
          <target state="translated">보행 중에 여러 태그가 발견되면 입력 커밋과 다른 커밋이 가장 적은 태그가 선택되어 출력됩니다. 여기에서 커밋 수가 가장 적은 것은 &lt;code&gt;git log tag..input&lt;/code&gt; 의해 표시되는 커밋 수로 정의됩니다. 입력 은 가능한 최소 커밋 수입니다.</target>
        </trans-unit>
        <trans-unit id="a7822ac9c32ce308a5503a1fdd5fe89ff6cb69d3" translate="yes" xml:space="preserve">
          <source>If neither of the above exist then &lt;code&gt;$XDG_CONFIG_HOME/git/gitk&lt;/code&gt; is created and used by default. If &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; is not set it defaults to &lt;code&gt;$HOME/.config&lt;/code&gt; in all cases.</source>
          <target state="translated">위의 어느 것도 존재하지 않으면 &lt;code&gt;$XDG_CONFIG_HOME/git/gitk&lt;/code&gt; 가 생성되어 기본적으로 사용됩니다. 경우 &lt;code&gt;$XDG_CONFIG_HOME&lt;/code&gt; 에 그것을 기본값으로 설정되지 않은 &lt;code&gt;$HOME/.config&lt;/code&gt; 모든 경우입니다.</target>
        </trans-unit>
        <trans-unit id="cd81c5109f07b879105adf39e250a5f3aca1a356" translate="yes" xml:space="preserve">
          <source>If neither was used, but &lt;code&gt;--date&lt;/code&gt; was given on the command line, show the timestamp in the format requested by &lt;code&gt;--date&lt;/code&gt;.</source>
          <target state="translated">둘 다 사용하지 않은,하지만 경우 &lt;code&gt;--date&lt;/code&gt; 이 명령 행에 주어졌다,에 의해 요구 된 형식의 타임 스탬프 보여 &lt;code&gt;--date&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="a3bb0635e00afaf46918027a40807c06a70ce207" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;pathspec&amp;gt; is given when &lt;code&gt;-A&lt;/code&gt; option is used, all files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories).</source>
          <target state="translated">&lt;code&gt;-A&lt;/code&gt; 옵션을 사용할 때 &amp;lt;pathspec&amp;gt;이 제공되지 않으면 전체 작업 트리의 모든 파일이 업데이트됩니다 (이전 버전의 Git은 현재 디렉토리 및 하위 디렉토리로 업데이트를 제한하는 데 사용됨).</target>
        </trans-unit>
        <trans-unit id="4b6e9bfea0c02571aea512af96edfe88c9715f04" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;pathspec&amp;gt; is given when &lt;code&gt;-u&lt;/code&gt; option is used, all tracked files in the entire working tree are updated (old versions of Git used to limit the update to the current directory and its subdirectories).</source>
          <target state="translated">&lt;code&gt;-u&lt;/code&gt; 옵션을 사용할 때 &amp;lt;pathspec&amp;gt;을 지정하지 않으면 전체 작업 트리에서 추적 된 모든 파일이 업데이트됩니다 (이전 버전의 Git은 업데이트를 현재 디렉토리 및 하위 디렉토리로 제한하는 데 사용됨).</target>
        </trans-unit>
        <trans-unit id="4b6d20762b018937bfcb3d137cde943022a33140" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;--decorate-refs&lt;/code&gt; is given, pretend as if all refs were included. For each candidate, do not use it for decoration if it matches any patterns given to &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; or if it doesn&amp;rsquo;t match any of the patterns given to &lt;code&gt;--decorate-refs&lt;/code&gt;.</source>
          <target state="translated">어떤 경우 &lt;code&gt;--decorate-refs&lt;/code&gt; 주어지지 않는, 모든 심판이 포함 된 경우로 척. 그에게 주어진 어떤 패턴과 일치하는 경우 각 후보의 경우, 장식을 사용하지 않는 &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; 하거나 주어진 패턴과 일치하지 않는 경우 &lt;code&gt;--decorate-refs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0c2ed2d5d960c224ec529b5f6156261c52081093" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;-b&lt;/code&gt; option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the &quot;*&quot;. This would tell us to use &lt;code&gt;hack&lt;/code&gt; as the local branch when branching off of &lt;code&gt;origin/hack&lt;/code&gt; (or &lt;code&gt;remotes/origin/hack&lt;/code&gt;, or even &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt;). If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted. You can explicitly give a name with &lt;code&gt;-b&lt;/code&gt; in such a case.</source>
          <target state="translated">&lt;code&gt;-b&lt;/code&gt; 옵션을 지정 하지 않으면 해당 분기에 대해 구성된 참조 사양의 로컬 부분을보고 &quot;*까지 초기 부분을 제거하여 새 분기의 이름이 원격 추적 분기에서 파생됩니다. &quot;. 이것은 &lt;code&gt;origin/hack&lt;/code&gt; (또는 &lt;code&gt;remotes/origin/hack&lt;/code&gt; 또는 &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt; )에서 분기 할 때 &lt;code&gt;hack&lt;/code&gt; 을 로컬 브랜치로 사용하도록 지시합니다 . 주어진 이름에 슬래시가 없거나 위의 추측 결과 빈 이름이 나오면 추측이 중단됩니다. 이 경우 명시 적으로 &lt;code&gt;-b&lt;/code&gt; 를 사용하여 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b362c22d46cf3c9ce26cb952c31ebfa05896260" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;-c&lt;/code&gt; option is given, the name of the new branch will be derived from the remote-tracking branch, by looking at the local part of the refspec configured for the corresponding remote, and then stripping the initial part up to the &quot;*&quot;. This would tell us to use &lt;code&gt;hack&lt;/code&gt; as the local branch when branching off of &lt;code&gt;origin/hack&lt;/code&gt; (or &lt;code&gt;remotes/origin/hack&lt;/code&gt;, or even &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt;). If the given name has no slash, or the above guessing results in an empty name, the guessing is aborted. You can explicitly give a name with &lt;code&gt;-c&lt;/code&gt; in such a case.</source>
          <target state="translated">&lt;code&gt;-c&lt;/code&gt; 옵션을 지정 하지 않으면 해당 분기에 대해 구성된 참조 사양의 로컬 부분을보고 새 부분을 &quot;*까지 제거하여 새 분기의 이름이 원격 추적 분기에서 파생됩니다. &quot;. 이것은 &lt;code&gt;origin/hack&lt;/code&gt; (또는 &lt;code&gt;remotes/origin/hack&lt;/code&gt; 또는 &lt;code&gt;refs/remotes/origin/hack&lt;/code&gt; )에서 분기 할 때 &lt;code&gt;hack&lt;/code&gt; 을 로컬 브랜치로 사용하도록 지시합니다 . 주어진 이름에 슬래시가 없거나 위의 추측 결과 빈 이름이 나오면 추측이 중단됩니다. 이 경우 명시 적으로 &lt;code&gt;-c&lt;/code&gt; 를 사용하여 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5eb9ed53cf409691a2adb1a958e7a2a354184a7" translate="yes" xml:space="preserve">
          <source>If no branch is specified and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; is used, then &lt;code&gt;git worktree add&lt;/code&gt; defaults to creating a new branch from HEAD. If &lt;code&gt;worktree.guessRemote&lt;/code&gt; is set to true, &lt;code&gt;worktree add&lt;/code&gt; tries to find a remote-tracking branch whose name uniquely matches the new branch name. If such a branch exists, it is checked out and set as &quot;upstream&quot; for the new branch. If no such match can be found, it falls back to creating a new branch from the current HEAD.</source>
          <target state="translated">분기가 지정되지 않고 &lt;code&gt;-b&lt;/code&gt; 또는 &lt;code&gt;-B&lt;/code&gt; 및 &lt;code&gt;--detach&lt;/code&gt; 가 사용 되지 않으면 &lt;code&gt;git worktree add&lt;/code&gt; 는 HEAD에서 새 분기를 작성하기 위해 기본값을 추가 합니다. &lt;code&gt;worktree.guessRemote&lt;/code&gt; 가 true로 설정된 경우 worktree &lt;code&gt;worktree add&lt;/code&gt; 는 새 분기 이름과 고유 한 이름을 가진 원격 추적 분기를 찾으려고 시도합니다. 그러한 분기가 존재하면 체크 아웃되고 새 분기에 대해 &quot;업스트림&quot;으로 설정됩니다. 일치하는 항목을 찾을 수 없으면 현재 HEAD에서 새 분기를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="cd840721ca4f2ba5f348ba0cdeddc96e7d47ba2a" translate="yes" xml:space="preserve">
          <source>If no command-line option is passed, the &lt;code&gt;help.format&lt;/code&gt; configuration variable will be checked. The following values are supported for this variable; they make &lt;code&gt;git help&lt;/code&gt; behave as their corresponding command- line option:</source>
          <target state="translated">명령 행 옵션이 전달되지 않으면 &lt;code&gt;help.format&lt;/code&gt; 구성 변수가 점검됩니다. 이 변수에 대해 다음 값이 지원됩니다. 그들은 &lt;code&gt;git help&lt;/code&gt; 가 해당 명령 행 옵션으로 동작하도록합니다.</target>
        </trans-unit>
        <trans-unit id="48f09dc10a5152e65a114506d3daba225636a70e" translate="yes" xml:space="preserve">
          <source>If no commit ID is found, &lt;code&gt;git get-tar-commit-id&lt;/code&gt; quietly exists with a return code of 1. This can happen if the archive had not been created using &lt;code&gt;git archive&lt;/code&gt; or if the first parameter of &lt;code&gt;git archive&lt;/code&gt; had been a tree ID instead of a commit ID or tag.</source>
          <target state="translated">어떤 경우 ID가 발견 커밋하지 &lt;code&gt;git get-tar-commit-id&lt;/code&gt; 조용히 아카이브를 사용하여 생성되지 않은 경우가 발생할 수 1의 리턴 코드로 존재 &lt;code&gt;git archive&lt;/code&gt; 또는 첫 번째 매개 변수 경우 &lt;code&gt;git archive&lt;/code&gt; 트리 ID 있었다 커밋 ID 또는 태그 대신.</target>
        </trans-unit>
        <trans-unit id="daf3aead6a5bfcff96ae9ec0da48e9d2be49b75e" translate="yes" xml:space="preserve">
          <source>If no commit is given from the command line, merge the remote-tracking branches that the current branch is configured to use as its upstream. See also the configuration section of this manual page.</source>
          <target state="translated">명령 줄에서 커밋이 제공되지 않으면 현재 분기가 업스트림으로 사용하도록 구성된 원격 추적 분기를 병합하십시오. 이 매뉴얼 페이지의 구성 섹션도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7188b50eb220f479115e7bb7b4e8a6b937273e6f" translate="yes" xml:space="preserve">
          <source>If no format is specified, the default format is &lt;code&gt;%(objectname)
%(objecttype) %(objectsize)&lt;/code&gt;.</source>
          <target state="translated">형식을 지정하지 않으면 기본 형식은 &lt;code&gt;%(objectname) %(objecttype) %(objectsize)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e72375796417844d20df5e1c264d965559c3c0c9" translate="yes" xml:space="preserve">
          <source>If no further options are given, all reading options will read all of these files that are available. If the global or the system-wide configuration file are not available they will be ignored. If the repository configuration file is not available or readable, &lt;code&gt;git config&lt;/code&gt; will exit with a non-zero error code. However, in neither case will an error message be issued.</source>
          <target state="translated">추가 옵션이 제공되지 않으면 모든 읽기 옵션에서 사용 가능한 모든 파일을 읽습니다. 글로벌 또는 시스템 전체 구성 파일을 사용할 수 없으면 무시됩니다. 저장소 구성 파일을 사용할 수 없거나 읽을 수없는 경우 &lt;code&gt;git config&lt;/code&gt; 는 0이 아닌 오류 코드와 함께 종료됩니다. 그러나 어떤 경우에도 오류 메시지가 발행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="542c100edd4ea5b59ab171a7795bc617673af483" translate="yes" xml:space="preserve">
          <source>If no objects are given, &lt;code&gt;git fsck&lt;/code&gt; defaults to using the index file, all SHA-1 references in &lt;code&gt;refs&lt;/code&gt; namespace, and all reflogs (unless --no-reflogs is given) as heads.</source>
          <target state="translated">객체가 제공되지 않으면 &lt;code&gt;git fsck&lt;/code&gt; 는 기본적으로 인덱스 파일, &lt;code&gt;refs&lt;/code&gt; 네임 스페이스의 모든 SHA-1 참조 및 모든 reflog (-no-reflogs가 제공되지 않은 경우)를 헤드로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3ac71fd77839914951c054588c999a4a8ef138ac" translate="yes" xml:space="preserve">
          <source>If no revisions are passed on the command line and either standard input is not a terminal or there is no current branch, &lt;code&gt;git shortlog&lt;/code&gt; will output a summary of the log read from standard input, without reference to the current repository.</source>
          <target state="translated">명령 행에 개정이 전달되지 않고 표준 입력이 터미널이 아니거나 현재 분기가없는 경우 &lt;code&gt;git shortlog&lt;/code&gt; 는 현재 저장소를 참조하지 않고 표준 입력에서 읽은 로그 요약을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="abf7234009b8e35c90eeb194fcd9fd8cfced1763" translate="yes" xml:space="preserve">
          <source>If no username is set for a network authentication, use this username by default. See credential.&amp;lt;context&amp;gt;.* below, and &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials[7]&lt;/a&gt;.</source>
          <target state="translated">네트워크 인증에 사용자 이름이 설정되어 있지 않으면이 사용자 이름을 기본적으로 사용하십시오. 아래의 credential. &amp;lt;context&amp;gt;. * 및 &lt;a href=&quot;gitcredentials&quot;&gt;gitcredentials [7]을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="68bd2465b7813ae05686685c60e9c1221c412754" translate="yes" xml:space="preserve">
          <source>If non-zero, all packs larger than this limit are kept when &lt;code&gt;git gc&lt;/code&gt; is run. This is very similar to &lt;code&gt;--keep-base-pack&lt;/code&gt; except that all packs that meet the threshold are kept, not just the base pack. Defaults to zero. Common unit suffixes of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, or &lt;code&gt;g&lt;/code&gt; are supported.</source>
          <target state="translated">0이 아닌 경우, &lt;code&gt;git gc&lt;/code&gt; 가 실행될 때이 한계보다 큰 모든 팩이 유지됩니다 . 이는 기본 팩뿐만 아니라 임계 값을 충족하는 모든 팩이 유지된다는 점을 제외하고 &lt;code&gt;--keep-base-pack&lt;/code&gt; 과 매우 유사합니다 . 기본값은 0입니다. &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; 또는 &lt;code&gt;g&lt;/code&gt; 의 공통 단위 접미사 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="80f929e50dc4409c5d26df44de311be2ffed8079" translate="yes" xml:space="preserve">
          <source>If none of &lt;code&gt;--stdin&lt;/code&gt;, &lt;code&gt;--all&lt;/code&gt;, or &lt;code&gt;--&lt;/code&gt; is used, the first argument will be treated as an attribute and the rest of the arguments as pathnames.</source>
          <target state="translated">&lt;code&gt;--stdin&lt;/code&gt; , &lt;code&gt;--all&lt;/code&gt; 또는 &lt;code&gt;--&lt;/code&gt; 을 사용 하지 않으면 첫 번째 인수는 속성으로 처리되고 나머지 인수는 경로 이름으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="af13390230f0ed2d9d7a8cd452e31841984f2fea" translate="yes" xml:space="preserve">
          <source>If not set (default), it means that this feature is disabled.</source>
          <target state="translated">설정하지 않으면 (기본값)이 기능이 비활성화 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="ffeb0befbf6f99dd0616072c3aff8f91a09da3dd" translate="yes" xml:space="preserve">
          <source>If not set explicitly with &lt;code&gt;--file&lt;/code&gt;, there are four files where &lt;code&gt;git config&lt;/code&gt; will search for configuration options:</source>
          <target state="translated">&lt;code&gt;--file&lt;/code&gt; 을 명시 적으로 설정하지 않으면 &lt;code&gt;git config&lt;/code&gt; 가 구성 옵션을 검색 하는 4 개의 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="42b0a7358d3a7018936abd1faefcf6d947a2a30c" translate="yes" xml:space="preserve">
          <source>If not set explicitly with &lt;code&gt;--file&lt;/code&gt;, there are two files where git-credential-store will search for credentials in order of precedence:</source>
          <target state="translated">&lt;code&gt;--file&lt;/code&gt; 을 명시 적으로 설정하지 않으면 git-credential-store가 우선 순위에 따라 자격 증명을 검색하는 두 개의 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dcc101d67cdfa1a1e655970a079699595239b44" translate="yes" xml:space="preserve">
          <source>If not set in the environment, the list of notes to copy depends on the &lt;code&gt;notes.rewrite.&amp;lt;command&amp;gt;&lt;/code&gt; and &lt;code&gt;notes.rewriteRef&lt;/code&gt; settings.</source>
          <target state="translated">환경에서 설정하지 않은 경우 복사 할 메모 목록은 &lt;code&gt;notes.rewrite.&amp;lt;command&amp;gt;&lt;/code&gt; 및 &lt;code&gt;notes.rewriteRef&lt;/code&gt; 설정 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="b9f85a49fbdf8e068a215ef9d6f0bd6bbfeb7a4e" translate="yes" xml:space="preserve">
          <source>If not specified, the default restore source for the working tree is the index, and the default restore source for the index is &lt;code&gt;HEAD&lt;/code&gt;. When both &lt;code&gt;--staged&lt;/code&gt; and &lt;code&gt;--worktree&lt;/code&gt; are specified, &lt;code&gt;--source&lt;/code&gt; must also be specified.</source>
          <target state="translated">지정되지 않은 경우 작업 트리의 기본 복원 소스는 색인이고 색인의 기본 복원 소스는 &lt;code&gt;HEAD&lt;/code&gt; 입니다. 모두가 때 &lt;code&gt;--staged&lt;/code&gt; 및 &lt;code&gt;--worktree&lt;/code&gt; 가 지정되어, &lt;code&gt;--source&lt;/code&gt; 는 도 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="56d3a4f46f938bb42b1fca6d786b8e7fc54bbe14" translate="yes" xml:space="preserve">
          <source>If nothing matches, &lt;code&gt;git show-ref&lt;/code&gt; will return an error code of 1, and in the case of verification, it will show an error message.</source>
          <target state="translated">일치하는 것이 없으면 &lt;code&gt;git show-ref&lt;/code&gt; 는 오류 코드 1을 반환하고 확인의 경우 오류 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b1f5a8844fabfc412b2762d5d95a3c4d967624ca" translate="yes" xml:space="preserve">
          <source>If one of &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, or &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; is passed, the command creates a &lt;code&gt;tag&lt;/code&gt; object, and requires a tag message. Unless &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; or &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; is given, an editor is started for the user to type in the tag message.</source>
          <target state="translated">&lt;code&gt;-a&lt;/code&gt; , &lt;code&gt;-s&lt;/code&gt; 또는 &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 중 하나 가 전달되면 명령이 &lt;code&gt;tag&lt;/code&gt; 객체를 작성 하고 태그 메시지가 필요합니다. &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; 이 제공 되지 않으면 사용자가 태그 메시지를 입력 할 수있는 편집기가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="2202ccf1357459c2102fac8580d0b9c370cb2843" translate="yes" xml:space="preserve">
          <source>If one or more &amp;lt;file&amp;gt; parameters are given, the merge tool program will be run to resolve differences on each file (skipping those without conflicts). Specifying a directory will include all unresolved files in that path. If no &amp;lt;file&amp;gt; names are specified, &lt;code&gt;git mergetool&lt;/code&gt; will run the merge tool program on every file with merge conflicts.</source>
          <target state="translated">하나 이상의 &amp;lt;file&amp;gt; 매개 변수가 제공되면, 병합 도구 프로그램이 실행되어 각 파일의 차이점을 해결합니다 (충돌이없는 매개 변수 생략). 디렉토리를 지정하면 해당 경로에 해결되지 않은 모든 파일이 포함됩니다. &amp;lt;file&amp;gt; 이름이 지정되지 않으면 &lt;code&gt;git mergetool&lt;/code&gt; 은 병합 충돌이있는 모든 파일에서 병합 도구 프로그램을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="ce7c35e9da7a7a12641957ffb2984ef7917b0e3e" translate="yes" xml:space="preserve">
          <source>If one or more patterns are given, only refs are shown that match against at least one pattern, either using fnmatch(3) or literally, in the latter case matching completely or from the beginning up to a slash.</source>
          <target state="translated">하나 이상의 패턴이 제공되면 fnmatch (3)를 사용하거나 문자 그대로 후자의 경우 완전히 또는 처음부터 슬래시까지 일치하는 하나 이상의 패턴과 일치하는 참조 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d335af2a37a580d9863e5a06bbfa0d646026268f" translate="yes" xml:space="preserve">
          <source>If one wishes to use the ref &lt;code&gt;ref/notes/true&lt;/code&gt;, please use that literal instead.</source>
          <target state="translated">ref &lt;code&gt;ref/notes/true&lt;/code&gt; 를 사용하려면 대신 해당 리터럴을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c90c8ad16602dc9d2f205c9d917c69aa3c723c01" translate="yes" xml:space="preserve">
          <source>If only &amp;lt;infd&amp;gt; is given, it is assumed to be a bidirectional socket connected to remote Git server (git-upload-pack, git-receive-pack or git-upload-archive). If both &amp;lt;infd&amp;gt; and &amp;lt;outfd&amp;gt; are given, they are assumed to be pipes connected to a remote Git server (&amp;lt;infd&amp;gt; being the inbound pipe and &amp;lt;outfd&amp;gt; being the outbound pipe.</source>
          <target state="translated">&amp;lt;infd&amp;gt; 만 주어진 경우, 원격 Git 서버 (git-upload-pack, git-receive-pack 또는 git-upload-archive)에 연결된 양방향 소켓 인 것으로 가정합니다. &amp;lt;infd&amp;gt;와 &amp;lt;outfd&amp;gt;가 모두 주어지면, 원격 Git 서버에 연결된 파이프 (&amp;lt;infd&amp;gt;는 인바운드 파이프이고 &amp;lt;outfd&amp;gt;는 아웃 바운드 파이프 인 것으로 가정)입니다.</target>
        </trans-unit>
        <trans-unit id="ce722a3060a9ef1801cda4fdb7cc3661d10ec67c" translate="yes" xml:space="preserve">
          <source>If only 1 tree is specified, &lt;code&gt;git read-tree&lt;/code&gt; operates as if the user did not specify &lt;code&gt;-m&lt;/code&gt;, except that if the original index has an entry for a given pathname, and the contents of the path match with the tree being read, the stat info from the index is used. (In other words, the index&amp;rsquo;s stat()s take precedence over the merged tree&amp;rsquo;s).</source>
          <target state="translated">트리가 1 개만 지정된 경우, &lt;code&gt;git read-tree&lt;/code&gt; 는 사용자가 &lt;code&gt;-m&lt;/code&gt; 을 지정하지 않은 것처럼 작동합니다 . 단, 원래 색인에 지정된 경로 이름에 대한 항목이 있고 경로의 내용이 읽는 트리와 일치하는 경우는 예외입니다. 인덱스의 통계 정보가 사용됩니다. 즉, 인덱스의 stat ()가 병합 된 트리보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="ed44ceba40face622ee83aefe1801bafac3f799c" translate="yes" xml:space="preserve">
          <source>If option &lt;code&gt;check-connectivity&lt;/code&gt; is requested, the helper must output &lt;code&gt;connectivity-ok&lt;/code&gt; if the clone is self-contained and connected.</source>
          <target state="translated">&lt;code&gt;check-connectivity&lt;/code&gt; 옵션 이 요청되면 클론이 자체 포함되어 연결되어 있으면 도우미가 &lt;code&gt;connectivity-ok&lt;/code&gt; 출력해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d94f0028bb24f94910f79bf2b787bad6af3cf852" translate="yes" xml:space="preserve">
          <source>If other people are pulling from your repository over dumb transport protocols (HTTP), you need to keep this repository &lt;code&gt;dumb transport friendly&lt;/code&gt;. After &lt;code&gt;git init&lt;/code&gt;, &lt;code&gt;$GIT_DIR/hooks/post-update.sample&lt;/code&gt; copied from the standard templates would contain a call to &lt;code&gt;git update-server-info&lt;/code&gt; but you need to manually enable the hook with &lt;code&gt;mv post-update.sample post-update&lt;/code&gt;. This makes sure &lt;code&gt;git update-server-info&lt;/code&gt; keeps the necessary files up to date.</source>
          <target state="translated">다른 사람이 바보 전송 프로토콜 (HTTP)을 통해 저장소에서 가져 오는 경우이 저장소 &lt;code&gt;dumb transport friendly&lt;/code&gt; 하게 유지해야합니다 . 후 &lt;code&gt;git init&lt;/code&gt; , &lt;code&gt;$GIT_DIR/hooks/post-update.sample&lt;/code&gt; 표준 템플릿에서 복사가의 호출에 포함됩니다 &lt;code&gt;git update-server-info&lt;/code&gt; 하지만 당신은 수동으로 후크 활성화해야 &lt;code&gt;mv post-update.sample post-update&lt;/code&gt; . 이것은 &lt;code&gt;git update-server-info&lt;/code&gt; 가 필요한 파일을 최신 상태로 유지하도록합니다.</target>
        </trans-unit>
        <trans-unit id="e17148a8f3d2ab81971460344696589bc00ec7fe" translate="yes" xml:space="preserve">
          <source>If provided, the results are limited to a subset of files matching one of the provided pathspecs.</source>
          <target state="translated">제공된 경우 결과는 제공된 경로 스펙 중 하나와 일치하는 파일의 서브 세트로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="c6bf36e1017847984a394e553be49b7f1e0149c6" translate="yes" xml:space="preserve">
          <source>If separate &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;committer&lt;/code&gt; commands are used in a &lt;code&gt;commit&lt;/code&gt; the timestamps may not match, as the system clock will be polled twice (once for each command). The only way to ensure that both author and committer identity information has the same timestamp is to omit &lt;code&gt;author&lt;/code&gt; (thus copying from &lt;code&gt;committer&lt;/code&gt;) or to use a date format other than &lt;code&gt;now&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;commit&lt;/code&gt; 에서 별도의 &lt;code&gt;author&lt;/code&gt; 및 &lt;code&gt;committer&lt;/code&gt; 명령을 사용 하면 시스템 시계가 두 번 폴링되므로 (각 명령마다 한 번씩) 타임 스탬프가 일치하지 않을 수 있습니다. 유일한 방법은 생략 할 수있다 저자 및 커미터 신원 정보가 동일한 타임 스탬프를 가지고 있는지 확인하기 위해 &lt;code&gt;author&lt;/code&gt; (따라서에서 복사 &lt;code&gt;committer&lt;/code&gt; ) 또는 이외의 날짜 형식을 사용하는 &lt;code&gt;now&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="866d5a5839fdc5ae41f48af4bbd37789bc250691" translate="yes" xml:space="preserve">
          <source>If set &lt;code&gt;--base=auto&lt;/code&gt; in cmdline, it will track base commit automatically, the base commit will be the merge base of tip commit of the remote-tracking branch and revision-range specified in cmdline. For a local branch, you need to track a remote branch by &lt;code&gt;git branch
--set-upstream-to&lt;/code&gt; before using this option.</source>
          <target state="translated">cmdline에서 &lt;code&gt;--base=auto&lt;/code&gt; 로 설정하면 기본 커밋이 자동으로 추적되고, 기본 커밋은 cmdline에 지정된 원격 추적 분기의 팁 커밋과 개정 범위의 병합 기반이됩니다. 로컬 지점의 경우이 옵션을 사용 &lt;code&gt;git branch --set-upstream-to&lt;/code&gt; 전에 git branch --set-upstream-to 로 원격 지점을 추적해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c4e55e2ff9b8cf62b34b50d7d6b4a09bd94fb5d9" translate="yes" xml:space="preserve">
          <source>If set to &quot;auto&quot;, &lt;code&gt;git-commit&lt;/code&gt; would select a character that is not the beginning character of any line in existing commit messages.</source>
          <target state="translated">&quot;auto&quot;로 설정하면 &lt;code&gt;git-commit&lt;/code&gt; 은 기존 커밋 메시지에서 줄의 시작 문자가 아닌 문자를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="3cb1da898d09757c537ab553b3fe27d9de1953ee" translate="yes" xml:space="preserve">
          <source>If set to &quot;warn&quot;, git rebase -i will print a warning if some commits are removed (e.g. a line was deleted), however the rebase will still proceed. If set to &quot;error&quot;, it will print the previous warning and stop the rebase, &lt;code&gt;git rebase --edit-todo&lt;/code&gt; can then be used to correct the error. If set to &quot;ignore&quot;, no checking is done. To drop a commit without warning or error, use the &lt;code&gt;drop&lt;/code&gt; command in the todo list. Defaults to &quot;ignore&quot;.</source>
          <target state="translated">&quot;warn&quot;으로 설정하면 git rebase -i는 일부 커밋이 제거되면 (예 : 라인이 삭제 된 경우) 경고를 표시하지만 rebase는 계속 진행됩니다. &quot;error&quot;로 설정하면 이전 경고를 인쇄하고 rebase를 중지합니다. &lt;code&gt;git rebase --edit-todo&lt;/code&gt; 를 사용하여 오류를 수정할 수 있습니다. &quot;무시&quot;로 설정하면 검사가 수행되지 않습니다. 경고 나 오류없이 커밋을 삭제하려면 할 일 목록에서 &lt;code&gt;drop&lt;/code&gt; 명령을 사용하십시오 . 기본값은 &quot;무시&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="ac8b0270c3c47d08febdcf04811ec5325e6bcef3" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;0&lt;/code&gt;, Git will complete any requested operation without performing any optional sub-operations that require taking a lock. For example, this will prevent &lt;code&gt;git status&lt;/code&gt; from refreshing the index as a side effect. This is useful for processes running in the background which do not want to cause lock contention with other operations on the repository. Defaults to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 으로 설정 되면 Git은 잠금이 필요한 선택적 하위 작업을 수행하지 않고 요청 된 작업을 완료합니다. 예를 들어, 이것은 &lt;code&gt;git status&lt;/code&gt; 가 색인으로 색인을 새로 고치는 것을 방지 합니다. 이는 백그라운드에서 실행중인 프로세스에서 저장소의 다른 조작으로 잠금 경합을 일으키지 않으려는 경우에 유용합니다. 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9d1e5156e1d430a4750260179109e036962ca85d" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;1&lt;/code&gt;, include broken or badly named refs when iterating over lists of refs. In a normal, non-corrupted repository, this does nothing. However, enabling it may help git to detect and abort some operations in the presence of broken refs. Git sets this variable automatically when performing destructive operations like &lt;a href=&quot;git-prune&quot;&gt;git-prune[1]&lt;/a&gt;. You should not need to set it yourself unless you want to be paranoid about making sure an operation has touched every ref (e.g., because you are cloning a repository to make a backup).</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 로 설정된 경우 심판 목록을 반복 할 때 파손되거나 잘못 명명 된 심판을 포함시킵니다. 손상되지 않은 정상적인 저장소에서는 아무 것도 수행하지 않습니다. 그러나이 기능을 활성화하면 ref가 깨진 참조가있는 경우 일부 작업을 감지하고 중단하는 데 도움이 될 수 있습니다. Git은 &lt;a href=&quot;git-prune&quot;&gt;git-prune [1]&lt;/a&gt; 과 같은 파괴적인 작업을 수행 할 때이 변수를 자동으로 설정합니다 . 작업이 모든 참조에 닿아 있는지 확인하지 않으려는 경우 (예 : 백업을 위해 리포지토리를 복제하기 때문에) 편집증을 원치 않는 한 직접 설정하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="721e268a3bbca2372f644ef6baf34d6bc14a8b54" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;false&lt;/code&gt;, behave as if the &lt;code&gt;--no-replace-objects&lt;/code&gt; option was given on the command line. See &lt;a href=&quot;git&quot;&gt;git[1]&lt;/a&gt; and &lt;a href=&quot;git-replace&quot;&gt;git-replace[1]&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 로 설정 되면 &lt;code&gt;--no-replace-objects&lt;/code&gt; 옵션이 명령 행에 제공된 것처럼 작동합니다 . 자세한 내용은 &lt;a href=&quot;git&quot;&gt;git [1]&lt;/a&gt; 및 &lt;a href=&quot;git-replace&quot;&gt;git-replace [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5c80e3d63d134dccb3136c655fb06b3aa0219fb0" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;yes&lt;/code&gt;, print an ellipsis following an (abbreviated) SHA-1 value. This affects indications of detached HEADs (&lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;) and the raw diff output (&lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;). Printing an ellipsis in the cases mentioned is no longer considered adequate and support for it is likely to be removed in the foreseeable future (along with the variable).</source>
          <target state="translated">&lt;code&gt;yes&lt;/code&gt; 로 설정되면 (약칭 된) SHA-1 값 뒤에 줄임표를 인쇄하십시오. 이는 분리 된 HEAD ( &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; ) 및 원시 diff 출력 ( &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; )의 표시에 영향을줍니다 . 언급 된 사례에서 줄임표를 인쇄하는 것은 더 이상 적절한 것으로 간주되지 않으며 가까운 장래에 변수에 대한 지원이 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03e97ab625ba0ca85ff94dae74e07745d32e9ba5" translate="yes" xml:space="preserve">
          <source>If set to a colon-separated list of protocols, behave as if &lt;code&gt;protocol.allow&lt;/code&gt; is set to &lt;code&gt;never&lt;/code&gt;, and each of the listed protocols has &lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt; set to &lt;code&gt;always&lt;/code&gt; (overriding any existing configuration). In other words, any protocol not mentioned will be disallowed (i.e., this is a whitelist, not a blacklist). See the description of &lt;code&gt;protocol.allow&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for more details.</source>
          <target state="translated">콜론으로 구분 된 프로토콜 목록으로 설정된 경우 &lt;code&gt;protocol.allow&lt;/code&gt; 가 &lt;code&gt;never&lt;/code&gt; 로 설정되고 나열된 각 프로토콜에 &lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt; 가 &lt;code&gt;always&lt;/code&gt; 설정되어 있습니다 (기존 구성을 재정의 함). 즉, 언급되지 않은 프로토콜은 허용되지 않습니다 (즉, 블랙리스트가 아닌 화이트리스트입니다). 자세한 내용은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 의 &lt;code&gt;protocol.allow&lt;/code&gt; 에 대한 설명 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d02bbac09e65cccb0fb85d779cd5ffdc25f0fea6" translate="yes" xml:space="preserve">
          <source>If set to either a valid &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; or a true value, moved lines in a diff are colored differently, for details of valid modes see &lt;code&gt;--color-moved&lt;/code&gt; in &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. If simply set to true the default color mode will be used. When set to false, moved lines are not colored.</source>
          <target state="translated">유효한 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 또는 true 값으로 설정하면 diff에서 이동 한 행의 색상이 다르게 표시됩니다. 유효한 모드에 대한 자세한 내용은 &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]의 &lt;/a&gt; &lt;code&gt;--color-moved&lt;/code&gt; 를 참조하십시오 . 단순히 true로 설정하면 기본 색상 모드가 사용됩니다. false로 설정하면 이동 한 선이 색상으로 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2017527381afe3327ef07745ea82e7ee1e2ae55" translate="yes" xml:space="preserve">
          <source>If set to true enable &lt;code&gt;--autosquash&lt;/code&gt; option by default.</source>
          <target state="translated">true로 설정하면 기본적으로 &lt;code&gt;--autosquash&lt;/code&gt; 옵션을 활성화 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7630a0d058d7490b6c2c7394afc94b9292f8389f" translate="yes" xml:space="preserve">
          <source>If set to true enable &lt;code&gt;--follow-tags&lt;/code&gt; option by default. You may override this configuration at time of push by specifying &lt;code&gt;--no-follow-tags&lt;/code&gt;.</source>
          <target state="translated">true로 설정하면 기본적으로 &lt;code&gt;--follow-tags&lt;/code&gt; 옵션을 활성화하십시오 . &lt;code&gt;--no-follow-tags&lt;/code&gt; 를 지정하여 푸시시이 구성을 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64fe3b4eafd82bc5365512adbc156f5096a46d37" translate="yes" xml:space="preserve">
          <source>If set to true or &quot;refuse&quot;, git-receive-pack will deny a ref update to the currently checked out branch of a non-bare repository. Such a push is potentially dangerous because it brings the HEAD out of sync with the index and working tree. If set to &quot;warn&quot;, print a warning of such a push to stderr, but allow the push to proceed. If set to false or &quot;ignore&quot;, allow such pushes with no message. Defaults to &quot;refuse&quot;.</source>
          <target state="translated">true 또는 &quot;refuse&quot;로 설정하면 git-receive-pack은 현재 베어지지 않은 저장소의 체크 아웃 된 분기에 대한 참조 업데이트를 거부합니다. 이러한 푸시는 HEAD가 인덱스 및 작업 트리와 동기화되지 않기 때문에 잠재적으로 위험합니다. &quot;경고&quot;로 설정된 경우 stderr에 대한 푸시에 대한 경고를 인쇄하되 계속 진행하십시오. false 또는 &quot;무시&quot;로 설정된 경우 메시지없이 푸시를 허용하십시오. 기본값은 &quot;거부&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="d09a3b8e56d92fdf26b71ac7a66610897ebf56ec" translate="yes" xml:space="preserve">
          <source>If set to true, .git/shallow can be updated when new refs require new shallow roots. Otherwise those refs are rejected.</source>
          <target state="translated">true로 설정하면 새 참조에 새 얕은 루트가 필요할 때 .git / shallow를 업데이트 할 수 있습니다. 그렇지 않으면 해당 심판은 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="54bb951308d4910fbcee8b759c22be8fe1cad2d9" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; will display the number of entries currently stashed away. Defaults to false.</source>
          <target state="translated">true로 설정하면 &lt;a href=&quot;git-status&quot;&gt;git-status [1]에&lt;/a&gt; 현재 숨겨져있는 항목 수가 표시됩니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="3713c634b09bf65bc394c012cee94ba42c596b9c" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; will insert a comment prefix before each output line (starting with &lt;code&gt;core.commentChar&lt;/code&gt;, i.e. &lt;code&gt;#&lt;/code&gt; by default). This was the behavior of &lt;a href=&quot;git-status&quot;&gt;git-status[1]&lt;/a&gt; in Git 1.8.4 and previous. Defaults to false.</source>
          <target state="translated">true로 설정하면 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 은 각 출력 행 앞에 주석 접두사를 삽입합니다 ( &lt;code&gt;core.commentChar&lt;/code&gt; 로 시작 , 기본적으로 &lt;code&gt;#&lt;/code&gt; ). 이것은 Git 1.8.4 이하에서 &lt;a href=&quot;git-status&quot;&gt;git-status [1]&lt;/a&gt; 의 동작이었습니다 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="9b89821396e7eac11e5ad2faf8d7540e7c67829b" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;code&gt;git rebase&lt;/code&gt; will use abbreviated command names in the todo list resulting in something like this:</source>
          <target state="translated">true로 설정하면 &lt;code&gt;git rebase&lt;/code&gt; 는 할일 목록에 축약 된 명령 이름을 사용하여 다음과 같은 결과를냅니다 :</target>
        </trans-unit>
        <trans-unit id="a871da2391e5e77cb10a7b13bd4e3a7269114ee0" translate="yes" xml:space="preserve">
          <source>If set to true, do not allow checkout of paths that would be considered equivalent to &lt;code&gt;.git&lt;/code&gt; on an HFS+ filesystem. Defaults to &lt;code&gt;true&lt;/code&gt; on Mac OS, and &lt;code&gt;false&lt;/code&gt; elsewhere.</source>
          <target state="translated">true로 설정되면 HFS + 파일 시스템 에서 &lt;code&gt;.git&lt;/code&gt; 과 동등한 경로를 체크 아웃하지 마십시오 . Mac OS에서는 기본값이 &lt;code&gt;true&lt;/code&gt; 이고 다른 곳에서는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0b91b7e4dfffb3891da9de8dba8ed2d19154ae38" translate="yes" xml:space="preserve">
          <source>If set to true, do not allow checkout of paths that would cause problems with the NTFS filesystem, e.g. conflict with 8.3 &quot;short&quot; names. Defaults to &lt;code&gt;true&lt;/code&gt; on Windows, and &lt;code&gt;false&lt;/code&gt; elsewhere.</source>
          <target state="translated">true로 설정된 경우 NTFS 파일 시스템에 문제를 일으킬 수있는 경로를 체크 아웃하지 마십시오 (예 : 8.3 &quot;짧은&quot;이름과의 충돌). Windows에서는 기본값이 &lt;code&gt;true&lt;/code&gt; 이고 다른 곳에서는 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="54ccdbeca4965b6fc3cb17a6075d84092d7309ba" translate="yes" xml:space="preserve">
          <source>If set to true, enable &lt;code&gt;--extended-regexp&lt;/code&gt; option by default. This option is ignored when the &lt;code&gt;grep.patternType&lt;/code&gt; option is set to a value other than &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">true로 설정되면 기본적으로 &lt;code&gt;--extended-regexp&lt;/code&gt; 옵션을 활성화하십시오 . &lt;code&gt;grep.patternType&lt;/code&gt; 옵션이 &lt;code&gt;default&lt;/code&gt; 이외의 값으로 설정된 경우이 옵션은 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="30887a5524c263667737b125eed1b7397b4d3c85" translate="yes" xml:space="preserve">
          <source>If set to true, enable &lt;code&gt;--full-name&lt;/code&gt; option by default.</source>
          <target state="translated">true로 설정되면 기본적으로 &lt;code&gt;--full-name&lt;/code&gt; 옵션을 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="a770bd77a59ee1eda1723cd39df7104106a40a38" translate="yes" xml:space="preserve">
          <source>If set to true, enable &lt;code&gt;-n&lt;/code&gt; option by default.</source>
          <target state="translated">true로 설정되면 기본적으로 &lt;code&gt;-n&lt;/code&gt; 옵션을 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ae1bc4fce8b6029e6cbb4c5d0167ebeeaacf37d" translate="yes" xml:space="preserve">
          <source>If set to true, enable the &lt;code&gt;--column&lt;/code&gt; option by default.</source>
          <target state="translated">true로 설정되면 기본적으로 &lt;code&gt;--column&lt;/code&gt; 옵션을 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f2144fe2d27e9e20f68c9036ebab8459a790815" translate="yes" xml:space="preserve">
          <source>If set to true, fall back to git grep --no-index if git grep is executed outside of a git repository. Defaults to false.</source>
          <target state="translated">true로 설정되면 git grep이 git 저장소 외부에서 실행되면 git grep --no-index로 돌아갑니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="25ad8c4a959eb80b90f95ddbc01fcd1f2b16d26e" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will deny a ref update that deletes the currently checked out branch of a non-bare repository.</source>
          <target state="translated">true로 설정하면 git-receive-pack은 현재 베어지지 않은 저장소의 체크 아웃 된 분기를 삭제하는 참조 업데이트를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="f7f0fff426d74ea17456c56eae07f347498018a4" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will deny a ref update that deletes the ref. Use this to prevent such a ref deletion via a push.</source>
          <target state="translated">true로 설정하면 git-receive-pack은 심판을 삭제하는 심판 업데이트를 거부합니다. 푸시를 통한 이러한 참조 삭제를 방지하려면이를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bc6468d5687d1713aadc8dfe39af8a6b8a9b584c" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will deny a ref update which is not a fast-forward. Use this to prevent such an update via a push, even if that push is forced. This configuration variable is set when initializing a shared repository.</source>
          <target state="translated">true로 설정하면 git-receive-pack은 빨리 감기가 아닌 참조 업데이트를 거부합니다. 푸시를 강제로 실행하더라도 푸시를 통한 업데이트를 방지하려면이 옵션을 사용하십시오. 이 구성 변수는 공유 저장소를 초기화 할 때 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="aa5f05e34699c4bff5b25fced7ce1653e77528d2" translate="yes" xml:space="preserve">
          <source>If set to true, git-receive-pack will run git-update-server-info after receiving data from git-push and updating refs.</source>
          <target state="translated">true로 설정하면 git-receive-pack은 git-push로부터 데이터를 수신하고 참조를 업데이트 한 후 git-update-server-info를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="875b965a1988574b490477056983b56357db9a5f" translate="yes" xml:space="preserve">
          <source>If set to true, makes &lt;code&gt;git repack&lt;/code&gt; act as if &lt;code&gt;--delta-islands&lt;/code&gt; was passed. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">true로 설정하면 &lt;code&gt;git repack&lt;/code&gt; 이 &lt;code&gt;--delta-islands&lt;/code&gt; 가 전달 된 것처럼 작동 합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3a3fff86e688774493783e955a40569a2b6cd00b" translate="yes" xml:space="preserve">
          <source>If set to true, makes &lt;code&gt;git repack&lt;/code&gt; act as if &lt;code&gt;--pack-kept-objects&lt;/code&gt; was passed. See &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt; for details. Defaults to &lt;code&gt;false&lt;/code&gt; normally, but &lt;code&gt;true&lt;/code&gt; if a bitmap index is being written (either via &lt;code&gt;--write-bitmap-index&lt;/code&gt; or &lt;code&gt;repack.writeBitmaps&lt;/code&gt;).</source>
          <target state="translated">true로 설정하면 &lt;code&gt;git repack&lt;/code&gt; 이 마치 &lt;code&gt;--pack-kept-objects&lt;/code&gt; 가 전달 된 것처럼 작동 합니다. 자세한 내용은 &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]&lt;/a&gt; 을 참조하십시오. 디폴트는 &lt;code&gt;false&lt;/code&gt; 일반적이지만 &lt;code&gt;true&lt;/code&gt; 비트 맵 인덱스 (경유로 기재되는 경우 &lt;code&gt;--write-bitmap-index&lt;/code&gt; 또는 &lt;code&gt;repack.writeBitmaps&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f4685adbf82f5fe84483ac0a4116dbb7a4fa6307" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;git diff&lt;/code&gt; does not show any source or destination prefix.</source>
          <target state="translated">설정하면 &lt;code&gt;git diff&lt;/code&gt; 는 소스 또는 대상 접두사를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="407c23ddaf3ebfe9c20e0dd5ae2fc627eb8b4502" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;git diff&lt;/code&gt; uses a prefix pair that is different from the standard &quot;a/&quot; and &quot;b/&quot; depending on what is being compared. When this configuration is in effect, reverse diff output also swaps the order of the prefixes:</source>
          <target state="translated">설정되면 &lt;code&gt;git diff&lt;/code&gt; 는 비교 대상에 따라 표준 &quot;a /&quot;및 &quot;b /&quot;와 다른 접두사 쌍을 사용합니다. 이 구성이 적용되면 역방향 diff 출력도 접두사의 순서를 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="ce70dfc2b2921383247fcc52103661d4583ff009" translate="yes" xml:space="preserve">
          <source>If set, by default &quot;git config&quot; reads from both &quot;config&quot; and &quot;config.worktree&quot; file from GIT_DIR in that order. In multiple working directory mode, &quot;config&quot; file is shared while &quot;config.worktree&quot; is per-working directory (i.e., it&amp;rsquo;s in GIT_COMMON_DIR/worktrees/&amp;lt;id&amp;gt;/config.worktree)</source>
          <target state="translated">설정하면 기본적으로 &quot;git config&quot;는 GIT_DIR의 &quot;config&quot;및 &quot;config.worktree&quot;파일을 순서대로 읽습니다. 다중 작업 디렉토리 모드에서 &quot;config&quot;파일은 공유되고 &quot;config.worktree&quot;는 작업 별 디렉토리입니다 (즉, GIT_COMMON_DIR / worktrees / &amp;lt;id&amp;gt; /config.worktree에 있음)</target>
        </trans-unit>
        <trans-unit id="b176f794890668142b94887636cc924076126a16" translate="yes" xml:space="preserve">
          <source>If set, keywords at the start of the line are highlighted. The keywords are &quot;error&quot;, &quot;warning&quot;, &quot;hint&quot; and &quot;success&quot;, and are matched case-insensitively. May be set to &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; (or &lt;code&gt;never&lt;/code&gt;) or &lt;code&gt;auto&lt;/code&gt; (or &lt;code&gt;true&lt;/code&gt;). If unset, then the value of &lt;code&gt;color.ui&lt;/code&gt; is used (&lt;code&gt;auto&lt;/code&gt; by default).</source>
          <target state="translated">설정하면 줄의 시작 부분에 키워드가 강조 표시됩니다. 키워드는 &quot;오류&quot;, &quot;경고&quot;, &quot;힌트&quot;및 &quot;성공&quot;이며 대소 문자를 구분하지 않습니다. &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; (또는 &lt;code&gt;never&lt;/code&gt; ) 또는 &lt;code&gt;auto&lt;/code&gt; (또는 &lt;code&gt;true&lt;/code&gt; ) 로 설정 될 수 있습니다 . 설정하지 않으면 &lt;code&gt;color.ui&lt;/code&gt; 의 값 이 사용됩니다 ( 기본적으로 &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b183dd8c0ffee365fe58a6a334a19fb15f9512f0" translate="yes" xml:space="preserve">
          <source>If set, prints debugging information about various reads/writes.</source>
          <target state="translated">설정된 경우 다양한 읽기 / 쓰기에 대한 디버깅 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b8c5d5bfb05b8eec245d869376183965da454ecd" translate="yes" xml:space="preserve">
          <source>If set, provide a user defined default policy for all protocols which don&amp;rsquo;t explicitly have a policy (&lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt;). By default, if unset, known-safe protocols (http, https, git, ssh, file) have a default policy of &lt;code&gt;always&lt;/code&gt;, known-dangerous protocols (ext) have a default policy of &lt;code&gt;never&lt;/code&gt;, and all other protocols have a default policy of &lt;code&gt;user&lt;/code&gt;. Supported policies:</source>
          <target state="translated">설정된 경우 명시 적으로 정책이없는 모든 프로토콜에 대해 사용자 정의 기본 정책을 제공하십시오 ( &lt;code&gt;protocol.&amp;lt;name&amp;gt;.allow&lt;/code&gt; ). 기본적으로 설정되지 않은 알려진 안전한 프로토콜 (http, https, git, ssh, file)의 기본 정책은 &lt;code&gt;always&lt;/code&gt; 이고 알려진 위험한 프로토콜 (ext)의 기본 정책은 &lt;code&gt;never&lt;/code&gt; 이며 다른 모든 프로토콜에는 기본 정책이 있습니다 의 &lt;code&gt;user&lt;/code&gt; . 지원되는 정책 :</target>
        </trans-unit>
        <trans-unit id="8d4a6e984ec5e0aad11e32a678cf60da360c5f1c" translate="yes" xml:space="preserve">
          <source>If set, specifies the outgoing SMTP server option to use. Default value can be specified by the &lt;code&gt;sendemail.smtpServerOption&lt;/code&gt; configuration option.</source>
          <target state="translated">설정된 경우 사용할 발신 SMTP 서버 옵션을 지정합니다. &lt;code&gt;sendemail.smtpServerOption&lt;/code&gt; 구성 옵션으로 기본값을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fab27431c274f5a81ff1327c3c271e3371074f0" translate="yes" xml:space="preserve">
          <source>If set, specifies the outgoing SMTP server to use (e.g. &lt;code&gt;smtp.example.com&lt;/code&gt; or a raw IP address). Alternatively it can specify a full pathname of a sendmail-like program instead; the program must support the &lt;code&gt;-i&lt;/code&gt; option. Default value can be specified by the &lt;code&gt;sendemail.smtpServer&lt;/code&gt; configuration option; the built-in default is to search for &lt;code&gt;sendmail&lt;/code&gt; in &lt;code&gt;/usr/sbin&lt;/code&gt;, &lt;code&gt;/usr/lib&lt;/code&gt; and $PATH if such program is available, falling back to &lt;code&gt;localhost&lt;/code&gt; otherwise.</source>
          <target state="translated">설정된 경우 사용할 발신 SMTP 서버 (예 : &lt;code&gt;smtp.example.com&lt;/code&gt; 또는 원시 IP 주소)를 지정합니다. 대신 sendmail 같은 프로그램의 전체 경로 이름을 지정할 수도 있습니다. 프로그램은 &lt;code&gt;-i&lt;/code&gt; 옵션을 지원해야합니다 . &lt;code&gt;sendemail.smtpServer&lt;/code&gt; 구성 옵션으로 기본값을 지정할 수 있습니다 . 내장 된 기본값은 &lt;code&gt;/usr/sbin&lt;/code&gt; , &lt;code&gt;/usr/lib&lt;/code&gt; 및 $ PATH 에서 &lt;code&gt;sendmail&lt;/code&gt; 을 검색하는 것입니다. 이러한 프로그램을 사용할 수있는 경우 &lt;code&gt;localhost&lt;/code&gt; 로 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="95132676994fa7152c54abc8928412e3414f6991" translate="yes" xml:space="preserve">
          <source>If set, store cookies received during requests to the file specified by http.cookieFile. Has no effect if http.cookieFile is unset.</source>
          <target state="translated">설정된 경우 요청 중에받은 쿠키를 http.cookieFile에 지정된 파일에 저장하십시오. http.cookieFile이 설정되어 있지 않으면 아무런 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9802dde85fc0323285bb8c0402ffcc333cf47ed2" translate="yes" xml:space="preserve">
          <source>If set, the value of this variable is used as a command which will identify all files that may have changed since the requested date/time. This information is used to speed up git by avoiding unnecessary processing of files that have not changed. See the &quot;fsmonitor-watchman&quot; section of &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">설정된 경우이 변수의 값은 요청 된 날짜 / 시간 이후에 변경되었을 수있는 모든 파일을 식별하는 명령으로 사용됩니다. 이 정보는 변경되지 않은 파일의 불필요한 처리를 피함으로써 자식 속도를 높이는 데 사용됩니다. &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 의 &quot;fsmonitor-watchman&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9612a7f8efdd3501a24381e7aae358082b8ef892" translate="yes" xml:space="preserve">
          <source>If some &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; arguments are also passed on the command line, when a &lt;code&gt;trailer.&amp;lt;token&amp;gt;.command&lt;/code&gt; is configured, the command will also be executed for each of these arguments. And the &amp;lt;value&amp;gt; part of these arguments, if any, will be used to replace the &lt;code&gt;$ARG&lt;/code&gt; string in the command.</source>
          <target state="translated">예를 들어 &lt;code&gt;trailer.&amp;lt;token&amp;gt;.command&lt;/code&gt; 가 구성 되면 일부 &lt;code&gt;&amp;lt;token&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 인수가 명령 행에 전달되면 이러한 각 인수에 대해 명령이 실행됩니다. 그리고 이러한 인수의 &amp;lt;value&amp;gt; 부분은 명령에서 &lt;code&gt;$ARG&lt;/code&gt; 문자열 을 대체하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="00679e1f1be4cb3b83ae3531e0f65d104df1ba84" translate="yes" xml:space="preserve">
          <source>If some files could not be added because of errors indexing them, do not abort the operation, but continue adding the others. The command shall still exit with non-zero status. The configuration variable &lt;code&gt;add.ignoreErrors&lt;/code&gt; can be set to true to make this the default behaviour.</source>
          <target state="translated">인덱싱 오류로 인해 일부 파일을 추가 할 수없는 경우 작업을 중단하지 말고 다른 파일을 계속 추가하십시오. 명령은 여전히 ​​0이 아닌 상태로 종료됩니다. 구성 변수 &lt;code&gt;add.ignoreErrors&lt;/code&gt; 를 true로 설정하여이를 기본 동작으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02424da36361565abc928c3cd12899bb91686b1d" translate="yes" xml:space="preserve">
          <source>If some of the merge bases are skipped, then the bisection process continues, but the following message is printed for each skipped merge base:</source>
          <target state="translated">일부 병합 기준을 건너 뛰면 이분법 프로세스는 계속되지만 건너 뛴 각 병합 기준에 대해 다음 메시지가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="c23bec329e1ab3f8ab844a76b3b2aad8e4c54310" translate="yes" xml:space="preserve">
          <source>If somebody got a release tag from you, you cannot just change the tag for them by updating your own one. This is a big security issue, in that people MUST be able to trust their tag-names. If you really want to do the insane thing, you need to just fess up to it, and tell people that you messed up. You can do that by making a very public announcement saying:</source>
          <target state="translated">누군가 릴리스 태그를받은 경우 자신의 태그를 업데이트하여 태그를 변경할 수는 없습니다. 사람들이 태그 이름을 신뢰할 수 있어야한다는 점에서 이는 큰 보안 문제입니다. 당신이 정말로 미쳤던 일을하고 싶다면, 당신은 그것을 속이고, 사람들에게 당신이 엉망이라고 말하면됩니다. 다음과 같이 매우 대중적인 발표를함으로써 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c1822b09998ebb74d19f39d240afd93e64789bf" translate="yes" xml:space="preserve">
          <source>If someone else administers the server, they should tell you what directory to put the repository in, and what &lt;code&gt;git://&lt;/code&gt; URL it will appear at. You can then skip to the section &quot;&lt;a href=&quot;#pushing-changes-to-a-public-repository&quot;&gt;Pushing changes to a public repository&lt;/a&gt;&quot;, below.</source>
          <target state="translated">다른 사람이 서버를 관리하는 경우 리포지토리를 넣을 디렉토리와 표시 할 &lt;code&gt;git://&lt;/code&gt; URL을 알려 주어야합니다 . 그런 다음 아래 &quot; &lt;a href=&quot;#pushing-changes-to-a-public-repository&quot;&gt;공개 리포지토리에 변경 내용 푸시&lt;/a&gt; &quot;섹션으로 건너 뛸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4199717fddcec6935af08019e365f779fa359364" translate="yes" xml:space="preserve">
          <source>If specified twice, show in addition the unified diff between what would be committed and the worktree files, i.e. the unstaged changes to tracked files.</source>
          <target state="translated">두 번 지정하면 커밋 된 파일과 작업 트리 파일 사이의 통합 된 차이 (예 : 추적 된 파일에 대한 단계적 변경 사항)를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="fcf7bcff6fb66a8267ebcd9b00a7e09f8cfe6596" translate="yes" xml:space="preserve">
          <source>If that version is broken, type</source>
          <target state="translated">해당 버전이 손상된 경우 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="c26c727c738ef7a0a9fa459f5d8c7e2c7478ba23" translate="yes" xml:space="preserve">
          <source>If the &quot;pattern&quot; URL does include a path component, then this too must match exactly: the context &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; will match a config entry for &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; (in addition to matching the config entry for &lt;code&gt;https://example.com&lt;/code&gt;) but will not match a config entry for &lt;code&gt;https://example.com/bar&lt;/code&gt;.</source>
          <target state="translated">은 &quot;패턴&quot;URL이 경로 구성 요소가 포함되어 있지 않습니다 경우,이 역시 정확히 일치해야합니다 : 문맥 &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; 을 위한 config 항목과 일치합니다 &lt;code&gt;https://example.com/bar/baz.git&lt;/code&gt; (대한 설정 항목 일치 이외에 &lt;code&gt;https://example.com&lt;/code&gt; 을 하지만위한 config 항목과 일치하지 않습니다) &lt;code&gt;https://example.com/bar&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="c4d8f312459b1b390b1c7f9b1bd219e73052861c" translate="yes" xml:space="preserve">
          <source>If the &amp;lt;value&amp;gt; part of any trailer contains only whitespace, the whole trailer will be removed from the resulting message. This applies to existing trailers as well as new trailers.</source>
          <target state="translated">예고편의 &amp;lt;value&amp;gt; 부분에 공백 만 포함 된 경우 결과 메시지에서 전체 예고편이 제거됩니다. 이는 새로운 예고편뿐만 아니라 기존 예고편에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b64722d374d9ba94f59d4b75e0b20b3d04a38c9e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;$GIT_DIR&lt;/code&gt; environment variable is set then it specifies a path to use instead of &lt;code&gt;./.git&lt;/code&gt; for the base of the repository.</source>
          <target state="translated">는 IF &lt;code&gt;$GIT_DIR&lt;/code&gt; 환경 변수가 설정되어 대신으로 사용할 수있는 경로를 지정 &lt;code&gt;./.git&lt;/code&gt; 저장소의 기지를.</target>
        </trans-unit>
        <trans-unit id="010f47d5eb5a20440d8f9779a052d1045e200486" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--anonymize&lt;/code&gt; option is given, git will attempt to remove all identifying information from the repository while still retaining enough of the original tree and history patterns to reproduce some bugs. The goal is that a git bug which is found on a private repository will persist in the anonymized repository, and the latter can be shared with git developers to help solve the bug.</source>
          <target state="translated">경우 &lt;code&gt;--anonymize&lt;/code&gt; 옵션이 주어, 자식은 여전히 몇 가지 버그를 재현하기 위해 원래의 나무와 역사 패턴을 충분히 유지하면서 저장소에서 모든 식별 정보를 제거하려고 시도합니다. 개인 저장소에서 발견되는 git 버그는 익명화 된 저장소에서 유지되며 버그 버그를 해결하기 위해 자식 개발자와 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4c6f80eebbd991a705883e3a7ddf7805d5a2ad9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--autosquash&lt;/code&gt; option is enabled by default using the configuration variable &lt;code&gt;rebase.autoSquash&lt;/code&gt;, this option can be used to override and disable this setting.</source>
          <target state="translated">경우 &lt;code&gt;--autosquash&lt;/code&gt; 옵션 구성 변수 사용 기본적으로 활성화되어 &lt;code&gt;rebase.autoSquash&lt;/code&gt; 을 ,이 옵션이 설정을 무시하고 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cf1db99e3ec777fa9fc759a96b9df8702668643" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--done&lt;/code&gt; command-line option or &lt;code&gt;feature done&lt;/code&gt; command is in use, the &lt;code&gt;done&lt;/code&gt; command is mandatory and marks the end of the stream.</source>
          <target state="translated">는 IF &lt;code&gt;--done&lt;/code&gt; 명령 줄 옵션 또는 &lt;code&gt;feature done&lt;/code&gt; 명령이 사용되면, &lt;code&gt;done&lt;/code&gt; 명령은 필수이며 표시 스트림의 끝을.</target>
        </trans-unit>
        <trans-unit id="a0c52682314428d0b2cfaeb79c7cb6ca41bbd107" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--include-untracked&lt;/code&gt; option is used, all untracked files are also stashed and then cleaned up with &lt;code&gt;git clean&lt;/code&gt;, leaving the working directory in a very clean state. If the &lt;code&gt;--all&lt;/code&gt; option is used instead then the ignored files are stashed and cleaned in addition to the untracked files.</source>
          <target state="translated">는 IF &lt;code&gt;--include-untracked&lt;/code&gt; 옵션을 사용, 모든 비 추적 파일은 은닉 된 후 함께 청소 &lt;code&gt;git clean&lt;/code&gt; 매우 깨끗한 상태로 작업 디렉토리를 떠나. 는 IF &lt;code&gt;--all&lt;/code&gt; 옵션은 다음 대신 사용되는 무시 파일을 은닉 및 비 추적 파일 외에도 세정합니다.</target>
        </trans-unit>
        <trans-unit id="bbfa929c9630d94c6f050152effe58514108dc44" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--index&lt;/code&gt; option is used, then tries to reinstate not only the working tree&amp;rsquo;s changes, but also the index&amp;rsquo;s ones. However, this can fail, when you have conflicts (which are stored in the index, where you therefore can no longer apply the changes as they were originally).</source>
          <target state="translated">경우 &lt;code&gt;--index&lt;/code&gt; 옵션을 사용하고 작업 트리의 변경뿐만 아니라 인덱스의 사람뿐만 아니라 복원을 시도합니다. 그러나 충돌이있는 경우 (인덱스에 저장되어 원래 변경 사항을 더 이상 적용 할 수없는 경우) 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3433648ddba23324bfe890535ea8fba49406cc9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--keep-index&lt;/code&gt; option is used, all changes already added to the index are left intact.</source>
          <target state="translated">는 IF &lt;code&gt;--keep-index&lt;/code&gt; 옵션을 사용, 이미 인덱스에 추가 된 모든 변경 내용은 그대로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0b71e8c338c336264145f9c00a25064d3a5d745" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;--multiple&lt;/code&gt; option was specified, the different remotes will be fetched in parallel. If multiple submodules are fetched, they will be fetched in parallel. To control them independently, use the config settings &lt;code&gt;fetch.parallel&lt;/code&gt; and &lt;code&gt;submodule.fetchJobs&lt;/code&gt; (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;code&gt;--multiple&lt;/code&gt; 옵션을 지정하고, 다른 리모트는 병렬로 가져온 것입니다. 여러 개의 서브 모듈이 페치되면 병렬로 페치됩니다. 독립적으로 제어하려면 구성 설정 &lt;code&gt;fetch.parallel&lt;/code&gt; 및 &lt;code&gt;submodule.fetchJobs&lt;/code&gt; 를 사용 하십시오 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="86926b76e3db734e6c786d5fed43f678b858b280" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;DISPLAY&lt;/code&gt; environment variable is not set, &lt;code&gt;git log&lt;/code&gt; is used instead. You can also give command-line options such as &lt;code&gt;-p&lt;/code&gt; and &lt;code&gt;--stat&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DISPLAY&lt;/code&gt; 환경 변수가 설정되지 않은 경우 대신 &lt;code&gt;git log&lt;/code&gt; 가 사용됩니다. &lt;code&gt;-p&lt;/code&gt; 및 &lt;code&gt;--stat&lt;/code&gt; 와 같은 명령 줄 옵션을 제공 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d759f2e991e02f3a71fd36511a7699e5f49db70c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GIT_ASKPASS&lt;/code&gt; environment variable is set, the program specified by the variable is invoked. A suitable prompt is provided to the program on the command line, and the user&amp;rsquo;s input is read from its standard output.</source>
          <target state="translated">는 IF &lt;code&gt;GIT_ASKPASS&lt;/code&gt; 의 환경 변수가 설정되어 변수에 의해 지정된 프로그램이 호출됩니다. 명령 행에서 프로그램에 적합한 프롬프트가 제공되며 사용자 입력은 표준 출력에서 ​​읽습니다.</target>
        </trans-unit>
        <trans-unit id="4b682e3beccdc952b131cf46cc2adb457e7b0390" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GIT_DIR&lt;/code&gt; environment variable is set then it specifies a path to use instead of the default &lt;code&gt;.git&lt;/code&gt; for the base of the repository. The &lt;code&gt;--git-dir&lt;/code&gt; command-line option also sets this value.</source>
          <target state="translated">는 IF &lt;code&gt;GIT_DIR&lt;/code&gt; 의 환경 변수가 설정되어 그것은 기본 대신 사용하는 경로를 지정 &lt;code&gt;.git&lt;/code&gt; 저장소의 기지를. &lt;code&gt;--git-dir&lt;/code&gt; 명령 줄 옵션은이 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="643cae995a607334b36d06d83fbe3fb662a8bb45" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;done&lt;/code&gt; feature is not in use, treated as if EOF was read. This can be used to tell fast-import to finish early.</source>
          <target state="translated">는 IF &lt;code&gt;done&lt;/code&gt; 기능을 사용하지 않을 EOF 읽고 된 것처럼, 처리 하였다. 빠른 가져 오기로 일찍 완료하도록 지시하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18aa9d79f5a644e72e69f66c98e1e834c977b6b0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;filter&lt;/code&gt; feature is advertised, the following argument can be included in the client&amp;rsquo;s request:</source>
          <target state="translated">는 IF &lt;code&gt;filter&lt;/code&gt; 기능을 광고하고, 다음 인수는 클라이언트의 요청에 포함 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="338c6269ff70e3588bd2606af346bee907c22325" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;git credential&lt;/code&gt; knew about the password, this step may not have involved the user actually typing this password (the user may have typed a password to unlock the keychain instead, or no user interaction was done if the keychain was already unlocked) before it returned &lt;code&gt;password=secr3t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git credential&lt;/code&gt; 이 암호에 대해 알고 있다면 이 단계는 사용자가 실제로이 암호를 입력하는 것과 관련이 없을 수 있습니다 (사용자는 대신 암호를 입력하여 키 체인을 잠금 해제하거나 키 체인이 이미 잠금 해제 된 경우 사용자 상호 작용이 수행되지 않았을 수 있음) &lt;code&gt;password=secr3t&lt;/code&gt; 를 리턴 했습니다 .</target>
        </trans-unit>
        <trans-unit id="1e7bad5825e1ca0d0f2641273cfd194a2b47fe7f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ref-in-want&lt;/code&gt; feature is advertised, the following argument can be included in the client&amp;rsquo;s request as well as the potential addition of the &lt;code&gt;wanted-refs&lt;/code&gt; section in the server&amp;rsquo;s response as explained below.</source>
          <target state="translated">는 IF &lt;code&gt;ref-in-want&lt;/code&gt; 기능을 광고하고, 다음 인수는 클라이언트의 요청뿐만 아니라 잠재적 추가로 포함 할 수 있습니다 &lt;code&gt;wanted-refs&lt;/code&gt; 아래에 설명 된대로 서버의 응답 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8ee9fffd993cfbf2d4a66bab484646e0aab5c31d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shallow&lt;/code&gt; feature is advertised the following arguments can be included in the clients request as well as the potential addition of the &lt;code&gt;shallow-info&lt;/code&gt; section in the server&amp;rsquo;s response as explained below.</source>
          <target state="translated">는 IF &lt;code&gt;shallow&lt;/code&gt; 기능은 클라이언트가의 잠재력 또한뿐만 아니라 요청에 다음 인수가 포함될 수 있습니다 보급 &lt;code&gt;shallow-info&lt;/code&gt; 아래에 설명 된대로 서버의 응답 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cc56c6c35649e4cbd1848d389261cbadfd34e234" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sideband-all&lt;/code&gt; feature is advertised, the following argument can be included in the client&amp;rsquo;s request:</source>
          <target state="translated">는 IF &lt;code&gt;sideband-all&lt;/code&gt; 기능을 광고하고, 다음 인수는 클라이언트의 요청에 포함 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5221b8fce1b302181f6152b9a7b516c793a8424a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;text&lt;/code&gt; attribute is unspecified, Git uses the &lt;code&gt;core.autocrlf&lt;/code&gt; configuration variable to determine if the file should be converted.</source>
          <target state="translated">경우 &lt;code&gt;text&lt;/code&gt; 속성이 지정되지 않은, 힘내는 사용 &lt;code&gt;core.autocrlf&lt;/code&gt; 파일을 변환해야하는지 결정하기 위해 구성 변수를.</target>
        </trans-unit>
        <trans-unit id="501d792e8a9528e67beb280aae4c4f6b3a3116f1" translate="yes" xml:space="preserve">
          <source>If the Git configuration variable clean.requireForce is not set to false, &lt;code&gt;git clean&lt;/code&gt; will refuse to delete files or directories unless given -f or -i. Git will refuse to modify untracked nested git repositories (directories with a .git subdirectory) unless a second -f is given.</source>
          <target state="translated">Git 구성 변수 clean.requireForce가 false로 설정되지 않은 경우, &lt;code&gt;git clean&lt;/code&gt; 은 -f 또는 -i를 지정하지 않으면 파일 또는 디렉토리 삭제를 거부합니다. Git은 두 번째 -f를 지정하지 않으면 추적되지 않은 중첩 된 git 저장소 (.git 서브 디렉토리가있는 디렉토리)를 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a08af52d1bb96063df69a1ba9c6458415ca2e42" translate="yes" xml:space="preserve">
          <source>If the HTTP transfer speed is less than &lt;code&gt;http.lowSpeedLimit&lt;/code&gt; for longer than &lt;code&gt;http.lowSpeedTime&lt;/code&gt; seconds, the transfer is aborted. Can be overridden by the &lt;code&gt;GIT_HTTP_LOW_SPEED_LIMIT&lt;/code&gt; and &lt;code&gt;GIT_HTTP_LOW_SPEED_TIME&lt;/code&gt; environment variables.</source>
          <target state="translated">는 HTTP 전송 속도가보다 작은 경우 &lt;code&gt;http.lowSpeedLimit&lt;/code&gt; 보다 오래 &lt;code&gt;http.lowSpeedTime&lt;/code&gt; 초, 전송이 중단됩니다. &lt;code&gt;GIT_HTTP_LOW_SPEED_LIMIT&lt;/code&gt; 및 &lt;code&gt;GIT_HTTP_LOW_SPEED_TIME&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c44d5cf7886c82987c35de787d30a82008f591b" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;approve&lt;/code&gt; or &lt;code&gt;reject&lt;/code&gt;, no output should be emitted.</source>
          <target state="translated">조치가 &lt;code&gt;approve&lt;/code&gt; 또는 &lt;code&gt;reject&lt;/code&gt; 인 경우 출력이 생성되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a7a299c18f6719e8e8b963c0bc834abd5de39626" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;approve&lt;/code&gt;, git-credential will send the description to any configured credential helpers, which may store the credential for later use.</source>
          <target state="translated">조치가 &lt;code&gt;approve&lt;/code&gt; 되면 git-credential은 설명을 구성된 자격 증명 헬퍼에게 보내면 나중에 사용할 수 있도록 자격 증명을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fc4d66ebd944d4cf73c3d3a8712c0dec288c62f" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;fill&lt;/code&gt;, git-credential will attempt to add &quot;username&quot; and &quot;password&quot; attributes to the description by reading config files, by contacting any configured credential helpers, or by prompting the user. The username and password attributes of the credential description are then printed to stdout together with the attributes already provided.</source>
          <target state="translated">작업이 &lt;code&gt;fill&lt;/code&gt; 인 경우 git-credential은 구성 파일을 읽거나 구성된 자격 증명 도우미에 연락하거나 사용자에게 프롬프트하여 설명에 &quot;username&quot;및 &quot;password&quot;특성을 추가하려고 시도합니다. 그런 다음 신임 정보의 사용자 이름 및 비밀번호 속성은 이미 제공된 속성과 함께 stdout으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="194451718843bfcaf463de902599c24ff69e0de0" translate="yes" xml:space="preserve">
          <source>If the action is &lt;code&gt;reject&lt;/code&gt;, git-credential will send the description to any configured credential helpers, which may erase any stored credential matching the description.</source>
          <target state="translated">작업이 &lt;code&gt;reject&lt;/code&gt; 경우 git-credential은 설명을 구성된 자격 증명 헬퍼에게 보내면 설명과 일치하는 저장된 자격 증명이 지워질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8fc44b68b56d1ac1b923c6197e4ad961f9ec579" translate="yes" xml:space="preserve">
          <source>If the alias expansion is prefixed with an exclamation point, it will be treated as a shell command. For example, defining &lt;code&gt;alias.new = !gitk --all --not ORIG_HEAD&lt;/code&gt;, the invocation &lt;code&gt;git new&lt;/code&gt; is equivalent to running the shell command &lt;code&gt;gitk --all --not ORIG_HEAD&lt;/code&gt;. Note that shell commands will be executed from the top-level directory of a repository, which may not necessarily be the current directory. &lt;code&gt;GIT_PREFIX&lt;/code&gt; is set as returned by running &lt;code&gt;git rev-parse --show-prefix&lt;/code&gt; from the original current directory. See &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;.</source>
          <target state="translated">별명 확장 앞에 느낌표가 있으면 쉘 명령으로 취급됩니다. 예를 들어 &lt;code&gt;alias.new = !gitk --all --not ORIG_HEAD&lt;/code&gt; 정의 하면 &lt;code&gt;git new&lt;/code&gt; 호출 은 쉘 명령 &lt;code&gt;gitk --all --not ORIG_HEAD&lt;/code&gt; 를 실행하는 것과 같습니다 . 쉘 명령은 저장소의 최상위 디렉토리에서 실행되며, 반드시 현재 디렉토리 일 필요는 없습니다. &lt;code&gt;GIT_PREFIX&lt;/code&gt; 는 원래 현재 디렉토리에서 &lt;code&gt;git rev-parse --show-prefix&lt;/code&gt; 를 실행하여 반환 된 것으로 설정됩니다 . &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="81bb3cca543b16e19f5e2adb35c917e85fde2f7d" translate="yes" xml:space="preserve">
          <source>If the amount of memory estimated for &lt;code&gt;git repack&lt;/code&gt; to run smoothly is not available and &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; is not set, the largest pack will also be excluded (this is the equivalent of running &lt;code&gt;git gc&lt;/code&gt; with &lt;code&gt;--keep-base-pack&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;git repack&lt;/code&gt; 이 원활하게 실행 되는 것으로 추정되는 메모리 양을 사용할 수없고 &lt;code&gt;gc.bigPackThreshold&lt;/code&gt; 가 설정되지 않은 경우 가장 큰 팩도 제외됩니다 (이것은 --git-c &lt;code&gt;--keep-base-pack&lt;/code&gt; &lt;code&gt;git gc&lt;/code&gt; 를 실행하는 것과 같습니다 ).</target>
        </trans-unit>
        <trans-unit id="28ae5c748411e761b0bfb160798c17e5330bf010" translate="yes" xml:space="preserve">
          <source>If the anonymized repository shows the bug, it may be worth sharing &lt;code&gt;anon-stream&lt;/code&gt; along with a regular bug report. Note that the anonymized stream compresses very well, so gzipping it is encouraged. If you want to examine the stream to see that it does not contain any private data, you can peruse it directly before sending. You may also want to try:</source>
          <target state="translated">익명화 된 저장소에 버그가 표시되면 일반 버그 보고서와 함께 &lt;code&gt;anon-stream&lt;/code&gt; 을 공유 할 가치가 있습니다 . 익명화 된 스트림은 매우 잘 압축되므로 gzipping하는 것이 좋습니다. 스트림에 개인 데이터가 포함되어 있지 않은지 확인하려면 전송하기 전에 스트림을 직접 살펴보십시오. 시도해 볼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="723ec66f7929012c8a6ac732a23c4db7a105b505" translate="yes" xml:space="preserve">
          <source>If the attribute &lt;code&gt;export-subst&lt;/code&gt; is set for a file then Git will expand several placeholders when adding this file to an archive. The expansion depends on the availability of a commit ID, i.e., if &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt; has been given a tree instead of a commit or a tag then no replacement will be done. The placeholders are the same as those for the option &lt;code&gt;--pretty=format:&lt;/code&gt; of &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, except that they need to be wrapped like this: &lt;code&gt;$Format:PLACEHOLDERS$&lt;/code&gt; in the file. E.g. the string &lt;code&gt;$Format:%H$&lt;/code&gt; will be replaced by the commit hash.</source>
          <target state="translated">&lt;code&gt;export-subst&lt;/code&gt; 속성 이 파일에 설정되어 있으면 Git은이 파일을 아카이브에 추가 할 때 여러 자리 표시자를 확장합니다. 확약은 확약 ID의 가용성에 따라 다릅니다. 즉, &lt;a href=&quot;git-archive&quot;&gt;git-archive [1]&lt;/a&gt; 에 확약 또는 태그 대신 트리가 제공된 경우 교체가 수행되지 않습니다. 플레이스 홀더는 &lt;code&gt;--pretty=format:&lt;/code&gt; of &lt;a href=&quot;git-log&quot;&gt;git-log [1] 옵션&lt;/a&gt; 과 동일하지만 파일에서 &lt;code&gt;$Format:PLACEHOLDERS$&lt;/code&gt; 와 같이 랩핑되어야한다는 점만 다릅니다 . 예를 들어 &lt;code&gt;$Format:%H$&lt;/code&gt; 문자열 은 커밋 해시로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="bd056a8735e1abbf79ce6a360a1a80c3f28cbbd6" translate="yes" xml:space="preserve">
          <source>If the attribute export-subst is set for a file then Git will expand several placeholders when adding this file to an archive. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">export-subst 속성이 파일에 설정되어 있으면 Git은이 파일을 아카이브에 추가 할 때 여러 자리 표시자를 확장합니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="da80064c2ffb4013d75c1676828faa86849266b6" translate="yes" xml:space="preserve">
          <source>If the bisection process is driven manually, you can use &quot;git bisect skip&quot; to do the same thing. (In fact the special exit code 125 makes &quot;git bisect run&quot; use &quot;git bisect skip&quot; in the background.)</source>
          <target state="translated">이분법 프로세스가 수동으로 구동되는 경우 &quot;git bisect skip&quot;을 사용하여 동일한 작업을 수행 할 수 있습니다. 실제로 특수 종료 코드 125는 &quot;git bisect run&quot;을 백그라운드에서 &quot;git bisect skip&quot;으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="92ad120c671c36b884538f372611cf38d29a6827" translate="yes" xml:space="preserve">
          <source>If the branch exists in multiple remotes and one of them is named by the &lt;code&gt;checkout.defaultRemote&lt;/code&gt; configuration variable, we&amp;rsquo;ll use that one for the purposes of disambiguation, even if the &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; isn&amp;rsquo;t unique across all remotes. Set it to e.g. &lt;code&gt;checkout.defaultRemote=origin&lt;/code&gt; to always checkout remote branches from there if &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is ambiguous but exists on the &lt;code&gt;origin&lt;/code&gt; remote. See also &lt;code&gt;checkout.defaultRemote&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">브랜치가 여러 리모트에 존재하고 그 중 하나가 &lt;code&gt;checkout.defaultRemote&lt;/code&gt; 구성 변수에 의해 이름이 지정된 경우, &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 가 모든 리모트에서 고유하지 않더라도 명확성을 목적으로 그 브랜치 를 사용합니다. &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 가 모호하지만 &lt;code&gt;origin&lt;/code&gt; 원격 에 존재하는 경우 항상 원격 지점을 체크 아웃하려면 &lt;code&gt;checkout.defaultRemote=origin&lt;/code&gt; 으로 설정하십시오 . 참조 &lt;code&gt;checkout.defaultRemote&lt;/code&gt; 는 에서 &lt;a href=&quot;git-config&quot;&gt;자식-설정 [1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c39c5c03f65f2a5b7cc29c6c30fb330e225795da" translate="yes" xml:space="preserve">
          <source>If the changes are independent enough, Git will automatically complete the merge and commit the result (or reuse an existing commit in case of &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt;, see below). On the other hand, if there are conflicts&amp;mdash;​for example, if the same file is modified in two different ways in the remote branch and the local branch&amp;mdash;​then you are warned; the output may look something like this:</source>
          <target state="translated">변경 사항이 충분히 독립적이라면 Git은 자동으로 병합을 완료하고 결과를 커밋합니다 (또는 &lt;a href=&quot;#fast-forwards&quot;&gt;빨리 감기의&lt;/a&gt; 경우 기존 커밋을 재사용 하십시오 (아래 참조)). 반면에 원격 지점과 로컬 지점에서 동일한 파일이 서로 다른 두 가지 방식으로 수정 된 경우와 같이 충돌이있는 경우 경고가 표시됩니다. 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="288f48e57898c3a0706dea1db36d760600650737" translate="yes" xml:space="preserve">
          <source>If the changes don&amp;rsquo;t conflict, you&amp;rsquo;re done. If there are conflicts, markers will be left in the problematic files showing the conflict;</source>
          <target state="translated">변경 사항이 충돌하지 않으면 완료된 것입니다. 충돌이 발생하면 문제가있는 파일에 충돌이 있음을 나타내는 마커가 남습니다.</target>
        </trans-unit>
        <trans-unit id="0c9dca535f00f8f010f3f51cbdf5a64ba071ad26" translate="yes" xml:space="preserve">
          <source>If the checkout is done via rebase, local submodule commits are rebased as well.</source>
          <target state="translated">체크 아웃이 리베이스를 통해 수행되면 로컬 서브 모듈 커밋도 리베이스됩니다.</target>
        </trans-unit>
        <trans-unit id="da1ce847fd50c0ebce51907161b2297389c68a97" translate="yes" xml:space="preserve">
          <source>If the command contains the &lt;code&gt;$ARG&lt;/code&gt; string, this string will be replaced with the &amp;lt;value&amp;gt; part of an existing trailer with the same &amp;lt;token&amp;gt;, if any, before the command is launched.</source>
          <target state="translated">명령에 &lt;code&gt;$ARG&lt;/code&gt; 문자열이 포함 된 경우이 문자열은 명령이 시작되기 전에 동일한 &amp;lt;토큰&amp;gt;이있는 기존 트레일러의 &amp;lt;값&amp;gt; 부분으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="d68b3a0db25981cb416126191f5f7a8b40a5795b" translate="yes" xml:space="preserve">
          <source>If the commit is a merge commit, you must tell &lt;code&gt;git cvsexportcommit&lt;/code&gt; what parent the changeset should be done against.</source>
          <target state="translated">커밋이 병합 커밋 인 경우 &lt;code&gt;git cvsexportcommit&lt;/code&gt; 에게 변경 세트를 수행해야하는 상위 항목을 알려 주어야합니다.</target>
        </trans-unit>
        <trans-unit id="50eff6c32d5b1376396b813f799767464152ed15" translate="yes" xml:space="preserve">
          <source>If the commit is a merge, and if the pretty-format is not &lt;code&gt;oneline&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt; or &lt;code&gt;raw&lt;/code&gt;, an additional line is inserted before the &lt;code&gt;Author:&lt;/code&gt; line. This line begins with &quot;Merge: &quot; and the hashes of ancestral commits are printed, separated by spaces. Note that the listed commits may not necessarily be the list of the &lt;strong&gt;direct&lt;/strong&gt; parent commits if you have limited your view of history: for example, if you are only interested in changes related to a certain directory or file.</source>
          <target state="translated">커밋이 병합이고 pretty-format이 &lt;code&gt;oneline&lt;/code&gt; , &lt;code&gt;email&lt;/code&gt; 또는 &lt;code&gt;raw&lt;/code&gt; 가 아닌 경우 &lt;code&gt;Author:&lt;/code&gt; 행 앞에 추가 행이 삽입 됩니다. 이 줄은 &quot;Merge :&quot;로 시작하고 조상의 커밋 해시는 공백으로 구분되어 인쇄됩니다. 히스토리보기를 제한 한 경우 (예 : 특정 디렉토리 또는 파일과 관련된 변경에만 관심이있는 경우) 나열된 확약이 &lt;strong&gt;직접&lt;/strong&gt; 상위 확약 목록 일 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fb562926c30c7dcdbad03cee2dab579f6b030079" translate="yes" xml:space="preserve">
          <source>If the commit is done directly by using &lt;code&gt;git&lt;/code&gt; (as opposed to using &lt;code&gt;git-cvsserver&lt;/code&gt;) the update will need to happen on the next repository access by &lt;code&gt;git-cvsserver&lt;/code&gt;, independent of access method and requested operation.</source>
          <target state="translated">커밋이 &lt;code&gt;git&lt;/code&gt; 를 사용하여 직접 수행되는 경우 ( &lt;code&gt;git-cvsserver&lt;/code&gt; 사용하는 것과 달리 ) 액세스 방법 및 요청 된 작업에 관계 &lt;code&gt;git-cvsserver&lt;/code&gt; 의한 다음 저장소 액세스에서 업데이트가 발생해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f829bbddf6f6f452756492321328ac75e498d9d9" translate="yes" xml:space="preserve">
          <source>If the config option &lt;code&gt;uploadArchive.allowUnreachable&lt;/code&gt; is true, these rules are ignored, and clients may use arbitrary sha1 expressions. This is useful if you do not care about the privacy of unreachable objects, or if your object database is already publicly available for access via non-smart-http.</source>
          <target state="translated">구성 옵션 &lt;code&gt;uploadArchive.allowUnreachable&lt;/code&gt; 이 true 인 경우이 규칙은 무시되며 클라이언트는 임의의 sha1 표현식을 사용할 수 있습니다. 도달 할 수없는 객체의 프라이버시를 신경 쓰지 않거나 스마트 이외의 http를 통해 액세스 할 수있는 객체 데이터베이스가 이미있는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a1bf5bff98f507f37d5394622406355fb10d8518" translate="yes" xml:space="preserve">
          <source>If the config variable &lt;code&gt;status.relativePaths&lt;/code&gt; is set to false, then all paths shown are relative to the repository root, not to the current directory.</source>
          <target state="translated">구성 변수 &lt;code&gt;status.relativePaths&lt;/code&gt; 가 false로 설정되면 표시된 모든 경로는 현재 디렉토리가 아닌 저장소 루트를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="cd3ff15aa0e04d429d03e9f6131934c58fa371f6" translate="yes" xml:space="preserve">
          <source>If the configuration variable &lt;code&gt;instaweb.browser&lt;/code&gt; is not set, &lt;code&gt;web.browser&lt;/code&gt; will be used instead if it is defined. See git-web{litdd}browse[1] for more information about this.</source>
          <target state="translated">&lt;code&gt;instaweb.browser&lt;/code&gt; 구성 변수 가 설정되어 있지 않으면 &lt;code&gt;web.browser&lt;/code&gt; 가 대신 정의되어 사용됩니다. 이에 대한 자세한 내용은 git-web {litdd} browse [1]를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="63b229ee2ee5c7c387585f3ec858739b37c09980" translate="yes" xml:space="preserve">
          <source>If the current HEAD is the same as the parent of the cherry-pick&amp;rsquo;ed commit, then a fast forward to this commit will be performed.</source>
          <target state="translated">현재 HEAD가 cherry-pick의 커밋의 부모와 동일하면이 커밋으로 빨리 감기가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7ca0a51612928d164dbfccc37787084c17e98850" translate="yes" xml:space="preserve">
          <source>If the custom merge tool correctly indicates the success of a merge resolution with its exit code, then the configuration variable &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.trustExitCode&lt;/code&gt; can be set to &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;git mergetool&lt;/code&gt; will prompt the user to indicate the success of the resolution after the custom tool has exited.</source>
          <target state="translated">사용자 정의 병합 도구가 종료 코드로 병합 분석의 성공을 올바르게 표시하면 구성 변수 &lt;code&gt;mergetool.&amp;lt;tool&amp;gt;.trustExitCode&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정할 수 있습니다 . 그렇지 않으면 &lt;code&gt;git mergetool&lt;/code&gt; 은 사용자 정의 도구가 종료 된 후 사용자에게 해결 성공을 표시하라는 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="36390d22499feba94308c3d2a6c08dfbe3009ec3" translate="yes" xml:space="preserve">
          <source>If the exit status is non-zero, &lt;code&gt;git commit&lt;/code&gt; will abort.</source>
          <target state="translated">종료 상태가 0이 아닌 경우 &lt;code&gt;git commit&lt;/code&gt; 이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="ffb6fc6e4737a7b7be769bd191cc211dd325235f" translate="yes" xml:space="preserve">
          <source>If the file &lt;code&gt;.mailmap&lt;/code&gt; exists at the toplevel of the repository, or at the location pointed to by the mailmap.file or mailmap.blob configuration options, it is used to map author and committer names and email addresses to canonical real names and email addresses.</source>
          <target state="translated">&lt;code&gt;.mailmap&lt;/code&gt; 파일 이 저장소의 최상위 레벨에 있거나 mailmap.file 또는 mailmap.blob 구성 옵션이 가리키는 위치에있는 경우, 작성자 및 커미터 이름 및 이메일 주소를 표준 실제 이름 및 이메일 주소로 맵핑하는 데 사용됩니다. .</target>
        </trans-unit>
        <trans-unit id="7142e4ddc34f82f593252b78cfae14d3292c9524" translate="yes" xml:space="preserve">
          <source>If the file gc.log exists, then &lt;code&gt;git gc --auto&lt;/code&gt; will print its content and exit with status zero instead of running unless that file is more than &lt;code&gt;gc.logExpiry&lt;/code&gt; old. Default is &quot;1.day&quot;. See &lt;code&gt;gc.pruneExpire&lt;/code&gt; for more ways to specify its value.</source>
          <target state="translated">gc.log 파일이 존재하는 경우, &lt;code&gt;git gc --auto&lt;/code&gt; 는 파일이 &lt;code&gt;gc.logExpiry&lt;/code&gt; old 이상이 아닌 경우 내용을 인쇄하고 실행하는 대신 상태 0으로 종료 합니다. 기본값은 &quot;1. 일&quot;입니다. 값을 지정하는 자세한 방법 은 &lt;code&gt;gc.pruneExpire&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7333f3457fce187a5640d74385a1bbc89a0c5a97" translate="yes" xml:space="preserve">
          <source>If the filter command (a string value) is defined via &lt;code&gt;filter.&amp;lt;driver&amp;gt;.process&lt;/code&gt; then Git can process all blobs with a single filter invocation for the entire life of a single Git command. This is achieved by using the long-running process protocol (described in technical/long-running-process-protocol.txt).</source>
          <target state="translated">filter 명령 (문자열 값)이 &lt;code&gt;filter.&amp;lt;driver&amp;gt;.process&lt;/code&gt; 를 통해 정의 된 경우 Git은 단일 Git 명령의 전체 수명 동안 단일 필터 호출로 모든 Blob을 처리 할 수 ​​있습니다. 이는 장기 실행 프로세스 프로토콜 (technical / long-running-process-protocol.txt에 설명되어 있음)을 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="edaaa7b77ca9e9ee284b92c3f4abf94dbe583827" translate="yes" xml:space="preserve">
          <source>If the filter dies during the communication or does not adhere to the protocol then Git will stop the filter process and restart it with the next file that needs to be processed. Depending on the &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; flag Git will interpret that as error.</source>
          <target state="translated">통신 중 필터가 죽거나 프로토콜을 준수하지 않으면 Git은 필터 프로세스를 중지하고 처리해야 할 다음 파일로 필터를 다시 시작합니다. 에 따라 &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; 플래그 힘내 오류로 그 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="5e14f4a25e8ac87108268501a2fbb6eaeaabe84f" translate="yes" xml:space="preserve">
          <source>If the filter experiences an error during processing, then it can send the status &quot;error&quot; after the content was (partially or completely) sent.</source>
          <target state="translated">처리 중에 필터에 오류가 발생하면 컨텐츠가 (일부 또는 완전히) 전송 된 후 상태 &quot;오류&quot;를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bace70b57e96bff11ceac069e6098423752b6f8" translate="yes" xml:space="preserve">
          <source>If the filter supports the &quot;delay&quot; capability then it must support the &quot;list_available_blobs&quot; command. If Git sends this command, then the filter is expected to return a list of pathnames representing blobs that have been delayed earlier and are now available. The list must be terminated with a flush packet followed by a &quot;success&quot; status that is also terminated with a flush packet. If no blobs for the delayed paths are available, yet, then the filter is expected to block the response until at least one blob becomes available. The filter can tell Git that it has no more delayed blobs by sending an empty list. As soon as the filter responds with an empty list, Git stops asking. All blobs that Git has not received at this point are considered missing and will result in an error.</source>
          <target state="translated">If the filter supports the &quot;delay&quot; capability then it must support the &quot;list_available_blobs&quot; command. If Git sends this command, then the filter is expected to return a list of pathnames representing blobs that have been delayed earlier and are now available. The list must be terminated with a flush packet followed by a &quot;success&quot; status that is also terminated with a flush packet. If no blobs for the delayed paths are available, yet, then the filter is expected to block the response until at least one blob becomes available. The filter can tell Git that it has no more delayed blobs by sending an empty list. As soon as the filter responds with an empty list, Git stops asking. All blobs that Git has not received at this point are considered missing and will result in an error.</target>
        </trans-unit>
        <trans-unit id="03052ebbe356e67d3f76578abb0f90e9da0b94ac" translate="yes" xml:space="preserve">
          <source>If the filter supports the &quot;delay&quot; capability, then Git can send the flag &quot;can-delay&quot; after the filter command and pathname. This flag denotes that the filter can delay filtering the current blob (e.g. to compensate network latencies) by responding with no content but with the status &quot;delayed&quot; and a flush packet.</source>
          <target state="translated">필터가 &quot;지연&quot;기능을 지원하는 경우 Git은 필터 명령 및 경로 이름 뒤에 &quot;can-delay&quot;플래그를 보낼 수 있습니다. 이 플래그는 필터가 내용이 아니라 &quot;지연됨&quot;상태와 플러시 패킷으로 응답함으로써 현재 블롭 필터링을 지연시킬 수 있음을 나타냅니다 (예 : 네트워크 지연 시간 보상).</target>
        </trans-unit>
        <trans-unit id="13eec1f811a3745751e3462b5df9eab594af45cb" translate="yes" xml:space="preserve">
          <source>If the format is set to &quot;auto:foo&quot; and the pager is in use, format &quot;foo&quot; will be the used for the date format. Otherwise &quot;default&quot; will be used.</source>
          <target state="translated">형식이 &quot;auto : foo&quot;로 설정되어 있고 호출기가 사용중인 경우 날짜 형식에 &quot;foo&quot;형식이 사용됩니다. 그렇지 않으면 &quot;default&quot;가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7402fa03babc6cbdcbdc9c0c2d38f35b3f77eedb" translate="yes" xml:space="preserve">
          <source>If the given object refers to a blob, it will be described as &lt;code&gt;&amp;lt;commit-ish&amp;gt;:&amp;lt;path&amp;gt;&lt;/code&gt;, such that the blob can be found at &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; in the &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt;, which itself describes the first commit in which this blob occurs in a reverse revision walk from HEAD.</source>
          <target state="translated">지정된 객체의 Blob를 참조하는 경우,이를 설명한다 &lt;code&gt;&amp;lt;commit-ish&amp;gt;:&amp;lt;path&amp;gt;&lt;/code&gt; , 블롭이에서 발견 될 수 있도록 &lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt; 에서 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 자체가 먼저 커밋 설명 이 블롭은 HEAD에서 리버스 리비전으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="228c738194bda1bc3c409314b8269609d7c41e0b" translate="yes" xml:space="preserve">
          <source>If the hook exits with non-zero status, none of the refs will be updated. If the hook exits with zero, updating of individual refs can still be prevented by the &lt;a href=&quot;#update&quot;&gt;&lt;em&gt;update&lt;/em&gt;&lt;/a&gt; hook.</source>
          <target state="translated">후크가 0이 아닌 상태로 종료되면 참조가 업데이트되지 않습니다. 제로와 후크가 종료되면, 개별 심판의 업데이트는 여전히 방지 할 수 &lt;a href=&quot;#update&quot;&gt;&lt;em&gt;업데이트&lt;/em&gt;&lt;/a&gt; 후크.</target>
        </trans-unit>
        <trans-unit id="8439515eb9b2d0e08bb52156ea070a5b55f21477" translate="yes" xml:space="preserve">
          <source>If the ignore-paths configuration key is set, and the command-line option is also given, both regular expressions will be used.</source>
          <target state="translated">ignore-paths 구성 키가 설정되고 명령 행 옵션도 제공되면 두 정규식이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e545fa5704075d5dfeae5601c6d9858dfebf0464" translate="yes" xml:space="preserve">
          <source>If the ignore-refs configuration key is set, and the command-line option is also given, both regular expressions will be used.</source>
          <target state="translated">ignore-refs 구성 키가 설정되고 명령 행 옵션도 제공되면 두 개의 정규식이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="368e2e291b26f0dca547e5b1c9de986c75896687" translate="yes" xml:space="preserve">
          <source>If the last path components in the working tree&amp;rsquo;s path is unique among working trees, it can be used to identify worktrees. For example if you only have two working trees, at &quot;/abc/def/ghi&quot; and &quot;/abc/def/ggg&quot;, then &quot;ghi&quot; or &quot;def/ghi&quot; is enough to point to the former working tree.</source>
          <target state="translated">작업 트리 경로의 마지막 경로 구성 요소가 작업 트리 중에서 고유 한 경우 작업 트리를 식별하는 데 사용할 수 있습니다. 예를 들어, &quot;/ abc / def / ghi&quot;및 &quot;/ abc / def / ggg&quot;에 두 개의 작업 트리 만있는 경우 &quot;ghi&quot;또는 &quot;def / ghi&quot;이면 이전 작업 트리를 가리 키기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="a77fa7a1d051613196a1695412c9a05d33f69ded" translate="yes" xml:space="preserve">
          <source>If the local offset is not available in the source material, use &amp;ldquo;+0000&amp;rdquo;, or the most common local offset. For example many organizations have a CVS repository which has only ever been accessed by users who are located in the same location and time zone. In this case a reasonable offset from UTC could be assumed.</source>
          <target state="translated">소스 자료에서 로컬 오프셋을 사용할 수없는 경우 &quot;+0000&quot;또는 가장 일반적인 로컬 오프셋을 사용하십시오. 예를 들어 많은 조직에는 CVS 리포지토리가 있으며 동일한 위치와 시간대에있는 사용자 만 액세스 할 수 있습니다. 이 경우 UTC와의 합리적인 오프셋을 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="178f63f22948e35272dd2355f9864ebc5b092dbe" translate="yes" xml:space="preserve">
          <source>If the maintainer tells you that your patch no longer applies to the current upstream, you will have to rebase your topic (you cannot use a merge because you cannot format-patch merges):</source>
          <target state="translated">관리자가 패치가 더 이상 현재 업스트림에 적용되지 않는다고 알려 주면 주제를 리베이스해야합니다 (패치 병합을 포맷 할 수 없으므로 병합을 사용할 수 없음).</target>
        </trans-unit>
        <trans-unit id="9b0ae610cbbc854a9104beb55038f8e674b12699" translate="yes" xml:space="preserve">
          <source>If the merge cannot be carried out automatically, the conflicts need to be resolved and the result committed separately (see &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;). At that point, this hook will not be executed, but the &lt;code&gt;pre-commit&lt;/code&gt; hook will, if it is enabled.</source>
          <target state="translated">병합을 자동으로 수행 할 수 없으면 충돌을 해결하고 결과를 별도로 커밋해야합니다 ( &lt;a href=&quot;git-merge&quot;&gt;git-merge [1] 참조&lt;/a&gt; ). 이 시점에서이 후크는 실행되지 않지만 &lt;code&gt;pre-commit&lt;/code&gt; 후크 (활성화 된 경우)입니다.</target>
        </trans-unit>
        <trans-unit id="e1f358924aaa72264d85ec0ddf7ef92dd8191058" translate="yes" xml:space="preserve">
          <source>If the merge fails because it is not a fast-forward, then it is possible some fixes on &lt;code&gt;maint&lt;/code&gt; were missed in the feature release. This will not happen if the content of the branches was verified as described in the previous section.</source>
          <target state="translated">빨리 감기가 아니기 때문에 병합에 실패 하면 기능 릴리스에서 &lt;code&gt;maint&lt;/code&gt; 의 일부 수정 사항 이 누락되었을 수 있습니다. 분기의 내용이 이전 섹션에서 설명한대로 확인 된 경우에는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39e28c0246f221ccbae77af3a33cb0a2f4910f1f" translate="yes" xml:space="preserve">
          <source>If the number of objects fetched over the Git native transfer is below this limit, then the objects will be unpacked into loose object files. However if the number of received objects equals or exceeds this limit then the received pack will be stored as a pack, after adding any missing delta bases. Storing the pack from a push can make the push operation complete faster, especially on slow filesystems. If not set, the value of &lt;code&gt;transfer.unpackLimit&lt;/code&gt; is used instead.</source>
          <target state="translated">Git 기본 전송을 통해 페치 된 오브젝트 수가이 한계 미만이면 오브젝트가 느슨한 오브젝트 파일로 압축 해제됩니다. 그러나 수신 된 오브젝트 수가이 한계와 같거나 초과하면 누락 된 델타베이스를 추가 한 후 수신 된 팩이 팩으로 저장됩니다. 푸시에서 팩을 저장하면 특히 느린 파일 시스템에서 푸시 작업이 더 빨리 완료 될 수 있습니다. 설정하지 않으면 &lt;code&gt;transfer.unpackLimit&lt;/code&gt; 값이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba1c0757ead2b007fd4bc7bc8fe3299d5f283bd7" translate="yes" xml:space="preserve">
          <source>If the number of objects imported by &lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import[1]&lt;/a&gt; is below this limit, then the objects will be unpacked into loose object files. However if the number of imported objects equals or exceeds this limit then the pack will be stored as a pack. Storing the pack from a fast-import can make the import operation complete faster, especially on slow filesystems. If not set, the value of &lt;code&gt;transfer.unpackLimit&lt;/code&gt; is used instead.</source>
          <target state="translated">&lt;a href=&quot;git-fast-import&quot;&gt;git-fast-import [1]&lt;/a&gt; 로 가져온 객체 수가이 제한보다 낮 으면 객체가 느슨한 객체 파일로 압축 해제됩니다. 그러나 반입 된 오브젝트 수가이 한계와 같거나 초과하면 팩은 팩으로 저장됩니다. 빠른 가져 오기에서 팩을 저장하면 특히 느린 파일 시스템에서 가져 오기 작업을 더 빠르게 완료 할 수 있습니다. 설정하지 않으면 &lt;code&gt;transfer.unpackLimit&lt;/code&gt; 값이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="66dbfca32684aa415437926e2128b562d1010471" translate="yes" xml:space="preserve">
          <source>If the number of objects received in a push is below this limit then the objects will be unpacked into loose object files. However if the number of received objects equals or exceeds this limit then the received pack will be stored as a pack, after adding any missing delta bases. Storing the pack from a push can make the push operation complete faster, especially on slow filesystems. If not set, the value of &lt;code&gt;transfer.unpackLimit&lt;/code&gt; is used instead.</source>
          <target state="translated">푸시에 수신 된 오브젝트 수가이 한계 미만이면 오브젝트가 느슨한 오브젝트 파일로 압축 해제됩니다. 그러나 수신 된 오브젝트 수가이 한계와 같거나 초과하면 누락 된 델타베이스를 추가 한 후 수신 된 팩이 팩으로 저장됩니다. 푸시에서 팩을 저장하면 특히 느린 파일 시스템에서 푸시 작업이 더 빨리 완료 될 수 있습니다. 설정하지 않으면 &lt;code&gt;transfer.unpackLimit&lt;/code&gt; 값이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e5106f465347ea1c1f64d4a4e406ce8334671d0b" translate="yes" xml:space="preserve">
          <source>If the object being copied out to a temporary file is a symbolic link the content of the link will be written to a normal file. It is up to the end-user or the Porcelain to make use of this information.</source>
          <target state="translated">임시 파일로 복사되는 객체가 심볼릭 링크 인 경우 링크의 내용이 일반 파일에 기록됩니다. 이 정보를 이용하는 것은 최종 사용자 또는 도자기의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="0199138006db8140692b7fdc79404759dcaa332d" translate="yes" xml:space="preserve">
          <source>If the object is stored as a delta on-disk, this expands to the 40-hex sha1 of the delta base object. Otherwise, expands to the null sha1 (40 zeroes). See &lt;code&gt;CAVEATS&lt;/code&gt; below.</source>
          <target state="translated">객체가 델타 온 디스크로 저장된 경우 이는 델타 기본 객체의 40- 헥스 sha1로 확장됩니다. 그렇지 않으면 널 sha1 (40 0)으로 확장됩니다. 참조 &lt;code&gt;CAVEATS&lt;/code&gt; 은 아래를.</target>
        </trans-unit>
        <trans-unit id="bd902b813b2d32a3c916d53036b9b4661bcff5a2" translate="yes" xml:space="preserve">
          <source>If the object storage directory is specified via the &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; environment variable then the sha1 directories are created underneath - otherwise the default &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; directory is used.</source>
          <target state="translated">오브젝트 스토리지 디렉토리가 &lt;code&gt;$GIT_OBJECT_DIRECTORY&lt;/code&gt; 환경 변수를 통해 지정 되면 sha1 디렉토리가 아래에 작성 됩니다. 그렇지 않으면 기본 &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; 디렉토리가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5445d9592417f6217da69d0d0ffe49e2288619f2" translate="yes" xml:space="preserve">
          <source>If the object storage directory is specified via this environment variable then the sha1 directories are created underneath - otherwise the default &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; directory is used.</source>
          <target state="translated">이 환경 변수를 통해 오브젝트 스토리지 디렉토리가 지정된 경우 sha1 디렉토리가 아래에 작성 됩니다. 그렇지 않으면 기본 &lt;code&gt;$GIT_DIR/objects&lt;/code&gt; 디렉토리가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f2dc3f2759f3e631848eb5ab78d16a8be4a1f31" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;--all&lt;/code&gt; or &lt;code&gt;-a&lt;/code&gt; is given, all available commands are printed on the standard output.</source>
          <target state="translated">&lt;code&gt;--all&lt;/code&gt; 또는 &lt;code&gt;-a&lt;/code&gt; 옵션 이 제공되면 사용 가능한 모든 명령이 표준 출력에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="5db3d9ce81a9166e23fdfafcb7cf25752ff75423" translate="yes" xml:space="preserve">
          <source>If the option &lt;code&gt;--guide&lt;/code&gt; or &lt;code&gt;-g&lt;/code&gt; is given, a list of the useful Git guides is also printed on the standard output.</source>
          <target state="translated">&lt;code&gt;--guide&lt;/code&gt; 또는 &lt;code&gt;-g&lt;/code&gt; 옵션 이 제공되면 유용한 Git 안내서 목록도 표준 출력에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="22d4a6b6cbe8c87e55028aafc6f2a3b165e3a3fa" translate="yes" xml:space="preserve">
          <source>If the patch contains any changes to submodules then &lt;code&gt;git apply&lt;/code&gt; treats these changes as follows.</source>
          <target state="translated">패치에 서브 모듈에 대한 변경 사항이 포함되어 있으면 &lt;code&gt;git apply&lt;/code&gt; 는 이러한 변경 사항을 다음과 같이 처리합니다.</target>
        </trans-unit>
        <trans-unit id="bc5f440658cbf7f8fc36476e96067d0db070086e" translate="yes" xml:space="preserve">
          <source>If the pattern does not start with either &lt;code&gt;~/&lt;/code&gt;, &lt;code&gt;./&lt;/code&gt; or &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**/&lt;/code&gt; will be automatically prepended. For example, the pattern &lt;code&gt;foo/bar&lt;/code&gt; becomes &lt;code&gt;**/foo/bar&lt;/code&gt; and would match &lt;code&gt;/any/path/to/foo/bar&lt;/code&gt;.</source>
          <target state="translated">패턴 중 하나로 시작하지 않으면 &lt;code&gt;~/&lt;/code&gt; , &lt;code&gt;./&lt;/code&gt; 또는 &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;**/&lt;/code&gt; 이 자동으로 앞에 추가됩니다. 예를 들어, 패턴 &lt;code&gt;foo/bar&lt;/code&gt; 는 &lt;code&gt;**/foo/bar&lt;/code&gt; 가 되고 &lt;code&gt;/any/path/to/foo/bar&lt;/code&gt; 와 일치 합니다 .</target>
        </trans-unit>
        <trans-unit id="cdf2b04ab13a298c669a989712845f14a413f23b" translate="yes" xml:space="preserve">
          <source>If the pattern ends with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt; will be automatically added. For example, the pattern &lt;code&gt;foo/&lt;/code&gt; becomes &lt;code&gt;foo/**&lt;/code&gt;. In other words, it matches &quot;foo&quot; and everything inside, recursively.</source>
          <target state="translated">패턴 끝이 경우 &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; 는 자동으로 추가됩니다. 예를 들어, 패턴 &lt;code&gt;foo/&lt;/code&gt; 는 &lt;code&gt;foo/**&lt;/code&gt; 가 됩니다. 다시 말해, &quot;foo&quot;와 내부의 모든 것을 재귀 적으로 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="ead2b404e5878a53eb56a401706bd4f86f5cdd4b" translate="yes" xml:space="preserve">
          <source>If the pattern ends with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt; will be automatically added. For example, the pattern &lt;code&gt;foo/&lt;/code&gt; becomes &lt;code&gt;foo/**&lt;/code&gt;. In other words, it matches all branches that begin with &lt;code&gt;foo/&lt;/code&gt;. This is useful if your branches are organized hierarchically and you would like to apply a configuration to all the branches in that hierarchy.</source>
          <target state="translated">패턴 끝이 경우 &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; 는 자동으로 추가됩니다. 예를 들어, 패턴 &lt;code&gt;foo/&lt;/code&gt; 는 &lt;code&gt;foo/**&lt;/code&gt; 가 됩니다. 즉, &lt;code&gt;foo/&lt;/code&gt; 시작하는 모든 분기와 일치합니다 . 분기가 계층 적으로 구성되어 있고 해당 계층의 모든 분기에 구성을 적용하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f1c8abd89592d50ca8ca62bbaec12c523f709263" translate="yes" xml:space="preserve">
          <source>If the pattern starts with &lt;code&gt;./&lt;/code&gt;, it is replaced with the directory containing the current config file.</source>
          <target state="translated">패턴이 &lt;code&gt;./&lt;/code&gt; 로 시작 하면 현재 구성 파일이 들어있는 디렉토리로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="f924b2c312a1632ec51dd0f0353e6842160ab641" translate="yes" xml:space="preserve">
          <source>If the pattern starts with &lt;code&gt;~/&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; will be substituted with the content of the environment variable &lt;code&gt;HOME&lt;/code&gt;.</source>
          <target state="translated">패턴이로 시작하면 &lt;code&gt;~/&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; 환경 변수의 내용으로 대체됩니다 &lt;code&gt;HOME&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25b5ae377df44f33ba840cf2411c6edf767c0d5b" translate="yes" xml:space="preserve">
          <source>If the pre-receive hook exits with a non-zero exit status no updates will be performed, and the update, post-receive and post-update hooks will not be invoked either. This can be useful to quickly bail out if the update is not to be supported.</source>
          <target state="translated">수신 전 후크가 0이 아닌 종료 상태로 종료되면 업데이트가 수행되지 않으며 업데이트, 수신 후 및 업데이트 후 후크도 호출되지 않습니다. 업데이트를 지원하지 않을 경우 신속하게 구제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0131da637807c8654fda6294e521f8e5e74d9c2b" translate="yes" xml:space="preserve">
          <source>If the problematic commit is the most recent commit, and you have not yet made that commit public, then you may just &lt;a href=&quot;#undoing-a-merge&quot;&gt;destroy it using &lt;code&gt;git reset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문제가있는 커밋이 가장 최근의 커밋이고 아직 해당 커밋을 공개하지 않은 &lt;a href=&quot;#undoing-a-merge&quot;&gt;경우 &lt;code&gt;git reset&lt;/code&gt; 을&lt;/a&gt; 사용하여 커밋을 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f275a1769b3300733689c93e8034126052b9dd7" translate="yes" xml:space="preserve">
          <source>If the project list is taken from a file (&lt;code&gt;$projects_list&lt;/code&gt; points to a file), forks are only recognized if they are listed after the main project in that file.</source>
          <target state="translated">프로젝트 목록을 파일에서 가져 오면 ( &lt;code&gt;$projects_list&lt;/code&gt; 는 파일을 가리킴) 포크는 해당 파일에서 기본 프로젝트 뒤에 나열된 경우에만 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="cabde5708a0c59fc40ce3c5aef7bb8948c87aab4" translate="yes" xml:space="preserve">
          <source>If the reference repository is on the local machine, automatically setup &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; to obtain objects from the reference repository. Using an already existing repository as an alternate will require fewer objects to be copied from the repository being cloned, reducing network and local storage costs. When using the &lt;code&gt;--reference-if-able&lt;/code&gt;, a non existing directory is skipped with a warning instead of aborting the clone.</source>
          <target state="translated">참조 리포지토리가 로컬 컴퓨터에있는 경우 &lt;code&gt;.git/objects/info/alternates&lt;/code&gt; 를 자동으로 설정 하여 참조 리포지토리에서 개체를 가져옵니다. 이미 존재하는 리포지토리를 대체물로 사용하면 복제되는 리포지토리에서 적은 수의 객체를 복사해야하므로 네트워크 및 로컬 스토리지 비용이 줄어 듭니다. &lt;code&gt;--reference-if-able&lt;/code&gt; 을 사용할 때 기존 디렉토리가 아닌 디렉토리는 복제를 중단하는 대신 경고와 함께 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="5ea9c0fb462e839210565ca58d9885017561c1be" translate="yes" xml:space="preserve">
          <source>If the refspec is a globbing one, nothing is merged.</source>
          <target state="translated">참조 스펙이 globbing 하나이면 아무 것도 병합되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67d81d9e5d98e20a38ce258501ea936cdaf3477e" translate="yes" xml:space="preserve">
          <source>If the remote has enabled the options &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt;, &lt;code&gt;uploadpack.allowReachableSHA1InWant&lt;/code&gt;, or &lt;code&gt;uploadpack.allowAnySHA1InWant&lt;/code&gt;, they may alternatively be 40-hex sha1s present on the remote.</source>
          <target state="translated">원격에서 &lt;code&gt;uploadpack.allowTipSHA1InWant&lt;/code&gt; , &lt;code&gt;uploadpack.allowReachableSHA1InWant&lt;/code&gt; 또는 &lt;code&gt;uploadpack.allowAnySHA1InWant&lt;/code&gt; 옵션을 활성화 한 경우 원격에 40- 헥스 sha1이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b40a2dab8bd4f0c4875755d97441dd96a4edce1" translate="yes" xml:space="preserve">
          <source>If the remote is fetched successfully, pull and add upstream (tracking) reference, used by argument-less &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; and other commands. For more information, see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; and &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">리모트가 성공적으로 페치되면 인수없는 &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt; 및 기타 명령 에서 사용하는 업스트림 (추적) 참조를 끌어 추가하십시오 . 자세한 내용 은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]의 &lt;/a&gt; &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 및 &lt;code&gt;branch.&amp;lt;name&amp;gt;.remote&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc0cb0804e07bed75e0e991fffdc9aae616f339a" translate="yes" xml:space="preserve">
          <source>If the remote side supports it, annotated tags objects will be downloaded on the same connection as the other objects if the object the tag references is downloaded. The caller must otherwise determine the tags this option made available.</source>
          <target state="translated">원격 측에서 지원하는 경우 태그가 참조하는 객체를 다운로드하면 주석이 달린 태그 객체가 다른 객체와 동일한 연결로 다운로드됩니다. 그렇지 않으면 호출자는이 옵션을 사용 가능하게 한 태그를 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b72444ac7244fe67691159600db782df37b1532c" translate="yes" xml:space="preserve">
          <source>If the repository is bare, &lt;code&gt;--no-checkout&lt;/code&gt; is assumed.</source>
          <target state="translated">리포지토리가없는 경우 &lt;code&gt;--no-checkout&lt;/code&gt; 이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="36e50561f165c018ae6f119c2c6f3e5164508f60" translate="yes" xml:space="preserve">
          <source>If the repository is specified as a local path (e.g., &lt;code&gt;/path/to/repo&lt;/code&gt;), this is the default, and --local is essentially a no-op. If the repository is specified as a URL, then this flag is ignored (and we never use the local optimizations). Specifying &lt;code&gt;--no-local&lt;/code&gt; will override the default when &lt;code&gt;/path/to/repo&lt;/code&gt; is given, using the regular Git transport instead.</source>
          <target state="translated">저장소가 로컬 경로 (예 : &lt;code&gt;/path/to/repo&lt;/code&gt; )로 지정되면 이것이 기본값이며 --local은 기본적으로 no-op입니다. 리포지토리가 URL로 지정된 경우이 플래그는 무시되며 로컬 최적화를 사용하지 않습니다. &lt;code&gt;--no-local&lt;/code&gt; 을 지정 하면 대신 일반 Git 전송을 사용하여 &lt;code&gt;/path/to/repo&lt;/code&gt; 가 제공 될 때 기본값을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="9c19da211c253af2b7a5a65c4c24c5e8a4f73309" translate="yes" xml:space="preserve">
          <source>If the result content is empty then the filter is expected to respond with a &quot;success&quot; status and a flush packet to signal the empty content.</source>
          <target state="translated">결과 내용이 비어 있으면 필터는 &quot;성공&quot;상태 및 비우기 패킷으로 응답하여 빈 내용을 알립니다.</target>
        </trans-unit>
        <trans-unit id="87bdb08d6c6927271153931ec7c3dbb32bf0435b" translate="yes" xml:space="preserve">
          <source>If the server has found a suitable cut point and has decided to send a &quot;ready&quot; line, then the server can decide to (as an optimization) omit any &quot;ACK&quot; lines it would have sent during its response. This is because the server will have already determined the objects it plans to send to the client and no further negotiation is needed.</source>
          <target state="translated">서버가 적절한 컷 포인트를 발견하고 &quot;준비&quot;라인을 전송하기로 결정한 경우, 서버는 응답 중에 전송 한 &quot;ACK&quot;라인을 (최적화로) 생략하기로 결정할 수 있습니다. 서버가 클라이언트에 보낼 객체를 이미 결정 했으므로 추가 협상이 필요하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b994a26dfc45bfc84fb73ef67436c3f647661961" translate="yes" xml:space="preserve">
          <source>If the size of the incoming pack stream is larger than this limit, then git-receive-pack will error out, instead of accepting the pack file. If not set or set to 0, then the size is unlimited.</source>
          <target state="translated">수신 팩 스트림의 크기가이 한계보다 크면 팩 파일을 승인하는 대신 git-receive-pack이 오류를 발생시킵니다. 설정하지 않거나 0으로 설정하면 크기는 무제한입니다.</target>
        </trans-unit>
        <trans-unit id="ff78750ae83975fe12661694a886f60b06a8fa31" translate="yes" xml:space="preserve">
          <source>If the source material uses RFC 2822 style dates, the frontend should let fast-import handle the parsing and conversion (rather than attempting to do it itself) as the Git parser has been well tested in the wild.</source>
          <target state="translated">소스 자료가 RFC 2822 스타일 날짜를 사용하는 경우 프런트 엔드는 Git 파서가 제대로 테스트되었으므로 파싱 및 변환을 자체적으로 시도하지 않고 빨리 가져 오기로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="3c8cd70e721e8a0b9cd7092e81bbbfc31a3bd8bd" translate="yes" xml:space="preserve">
          <source>If the source repository is complete, convert a shallow repository to a complete one, removing all the limitations imposed by shallow repositories.</source>
          <target state="translated">소스 저장소가 완료된 경우 얕은 저장소를 완전한 저장소로 변환하여 얕은 저장소에 의해 부과 된 모든 제한 사항을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="9e6d3a4e3136a4838fe6f50fd9653c6cb56b6d6c" translate="yes" xml:space="preserve">
          <source>If the source repository is shallow, fetch as much as possible so that the current repository has the same history as the source repository.</source>
          <target state="translated">소스 저장소가 얕은 경우, 현재 저장소가 소스 저장소와 동일한 히스토리를 갖도록 가능한 한 많이 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="de8398976a760845a7849338955a9624333ab515" translate="yes" xml:space="preserve">
          <source>If the starting point is specified as &lt;code&gt;ref@{Nth}&lt;/code&gt;, show the index format.</source>
          <target state="translated">시작점이 &lt;code&gt;ref@{Nth}&lt;/code&gt; 로 지정 되면 색인 형식을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="6a2386c7d64f544644194a06f1f15e00500df35a" translate="yes" xml:space="preserve">
          <source>If the starting point was specified as &lt;code&gt;ref@{now}&lt;/code&gt;, show the timestamp format.</source>
          <target state="translated">시작점이 &lt;code&gt;ref@{now}&lt;/code&gt; 로 지정된 경우 타임 스탬프 형식을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="a401b7c4a3b36e61e5b713fb185191570664ec06" translate="yes" xml:space="preserve">
          <source>If the submodule has never been initialized, this is the only place where submodule configuration is found. It serves as the last fallback to specify where to obtain the submodule from.</source>
          <target state="translated">서브 모듈이 초기화되지 않은 경우, 이것은 서브 모듈 구성이있는 유일한 곳입니다. 서브 모듈을 얻을 수있는 곳을 지정하는 마지막 폴백 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="c93d30e9eb4c6197dacc1ad5f6b79e20616e783c" translate="yes" xml:space="preserve">
          <source>If the submodule is not yet initialized, and you just want to use the setting as stored in &lt;code&gt;.gitmodules&lt;/code&gt;, you can automatically initialize the submodule with the &lt;code&gt;--init&lt;/code&gt; option.</source>
          <target state="translated">하위 모듈이 아직 초기화되지 않았으며 &lt;code&gt;.gitmodules&lt;/code&gt; 에 저장된 설정을 사용하려는 경우 &lt;code&gt;--init&lt;/code&gt; 옵션을 사용 하여 하위 모듈을 자동으로 초기화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02845d91bbeb482c77721be199fb493e9af0747b" translate="yes" xml:space="preserve">
          <source>If the submodule is not yet initialized, then the configuration inside the submodule does not exist yet, so where to obtain the submodule from is configured here for example.</source>
          <target state="translated">서브 모듈이 아직 초기화되지 않은 경우 서브 모듈 내부의 구성이 아직 존재하지 않으므로 서브 모듈을 어디서 구할 수 있는지가 여기에 구성됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
