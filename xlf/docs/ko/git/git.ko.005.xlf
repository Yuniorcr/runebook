<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="git">
    <body>
      <group id="git">
        <trans-unit id="23b7a95dc6b5470754cb8fce020cce7d3aab1ac0" translate="yes" xml:space="preserve">
          <source>Due to the non-quarantine nature of the &lt;code&gt;fetch.fsckObjects&lt;/code&gt; implementation it cannot be relied upon to leave the object store clean like &lt;code&gt;receive.fsckObjects&lt;/code&gt; can.</source>
          <target state="translated">&lt;code&gt;fetch.fsckObjects&lt;/code&gt; 구현 의 비 격리 특성으로 인해 &lt;code&gt;receive.fsckObjects&lt;/code&gt; 처럼 오브젝트 저장소를 깨끗하게 유지하는 데 의존 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="68e19d88dc6eefe7753376e94bb2d970e8771158" translate="yes" xml:space="preserve">
          <source>Dumps the internal marks table to &amp;lt;file&amp;gt; when complete. Marks are written one per line as &lt;code&gt;:markid SHA-1&lt;/code&gt;. Frontends can use this file to validate imports after they have been completed, or to save the marks table across incremental runs. As &amp;lt;file&amp;gt; is only opened and truncated at checkpoint (or completion) the same path can also be safely given to --import-marks.</source>
          <target state="translated">완료되면 내부 마크 테이블을 &amp;lt;file&amp;gt;에 덤프합니다. 마크는 한 줄에 하나씩 &lt;code&gt;:markid SHA-1&lt;/code&gt; 로 작성 됩니다. 프런트 엔드에서이 파일을 사용하여 가져 오기가 완료된 후 가져 오기를 확인하거나 증분 실행에서 표시 테이블을 저장할 수 있습니다. &amp;lt;file&amp;gt;은 검사 점 (또는 완료)에서만 열리고 잘 리므로 동일한 경로를 --import-marks에 안전하게 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5f9d9df34707e95a5d4be8e3705f8049d385295" translate="yes" xml:space="preserve">
          <source>Dumps the internal marks table to &amp;lt;file&amp;gt; when complete. Marks are written one per line as &lt;code&gt;:markid SHA-1&lt;/code&gt;. Only marks for revisions are dumped; marks for blobs are ignored. Backends can use this file to validate imports after they have been completed, or to save the marks table across incremental runs. As &amp;lt;file&amp;gt; is only opened and truncated at completion, the same path can also be safely given to --import-marks. The file will not be written if no new object has been marked/exported.</source>
          <target state="translated">완료되면 내부 마크 테이블을 &amp;lt;file&amp;gt;에 덤프합니다. 마크는 한 줄에 하나씩 &lt;code&gt;:markid SHA-1&lt;/code&gt; 로 작성 됩니다. 개정 표시 만 덤프됩니다. 얼룩 표시는 무시됩니다. 백엔드는이 파일을 사용하여 가져 오기가 완료된 후 가져 오기의 유효성을 검사하거나 증분 실행에서 표시 테이블을 저장할 수 있습니다. &amp;lt;file&amp;gt;은 완료시에만 열리고 잘 리므로 동일한 경로를 --import-marks에 안전하게 지정할 수도 있습니다. 표시 / 내 보낸 새 개체가 없으면 파일이 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aec3ad9b971b7ff8255345b154c94258f560f0d2" translate="yes" xml:space="preserve">
          <source>During a merge, the working tree files are updated to reflect the result of the merge. Among the changes made to the common ancestor&amp;rsquo;s version, non-overlapping ones (that is, you changed an area of the file while the other side left that area intact, or vice versa) are incorporated in the final result verbatim. When both sides made changes to the same area, however, Git cannot randomly pick one side over the other, and asks you to resolve it by leaving what both sides did to that area.</source>
          <target state="translated">병합하는 동안 작업 트리 파일은 병합 결과를 반영하도록 업데이트됩니다. 공통 조상 버전에 대한 변경 사항 중 겹치지 않는 파일 (즉, 파일 영역을 변경 한 반면 다른 쪽은 그대로 두거나 그 반대)이 최종 결과 그대로 사용됩니다. 그러나 양쪽이 같은 영역을 변경했을 때, Git은 무작위로 한쪽을 다른 쪽에서 선택할 수 없으며, 양쪽에서 수행 한 작업을 그 영역에 남겨두고 해결하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="d0b0f9a14f12b4d06a31ddb153754d3c653f1bb2" translate="yes" xml:space="preserve">
          <source>During fsck git may find issues with legacy data which wouldn&amp;rsquo;t be generated by current versions of git, and which wouldn&amp;rsquo;t be sent over the wire if &lt;code&gt;transfer.fsckObjects&lt;/code&gt; was set. This feature is intended to support working with legacy repositories containing such data.</source>
          <target state="translated">fsck 중에 git은 현재 버전의 git에서 생성되지 않고 &lt;code&gt;transfer.fsckObjects&lt;/code&gt; 가 설정된 경우 유선을 통해 전송되지 않는 레거시 데이터 관련 문제를 찾을 수 있습니다 . 이 기능은 해당 데이터가 포함 된 레거시 리포지토리 작업을 지원하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="0eedfc5c015b233e6082e4e46ded41bc5da25b25" translate="yes" xml:space="preserve">
          <source>During the merge, the index holds three versions of each file. Each of these three &quot;file stages&quot; represents a different version of the file:</source>
          <target state="translated">병합하는 동안 인덱스는 각 파일의 세 가지 버전을 보유합니다. 이 세 가지 &quot;파일 단계&quot;는 각각 다른 버전의 파일을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="338f11841fc746012903e84c16b88356c6508da5" translate="yes" xml:space="preserve">
          <source>During the normal execution of several Git commands, call-outs are made to optional scripts that allow a developer to add functionality or checking. Typically, the hooks allow for a command to be pre-verified and potentially aborted, and allow for a post-notification after the operation is done. The hook scripts are found in the &lt;code&gt;$GIT_DIR/hooks/&lt;/code&gt; directory, and are enabled by simply removing the &lt;code&gt;.sample&lt;/code&gt; suffix from the filename. In earlier versions of Git you had to make them executable.</source>
          <target state="translated">여러 Git 명령을 정상적으로 실행하는 동안 개발자가 기능을 추가하거나 검사 할 수있는 선택적 스크립트가 콜 아웃됩니다. 일반적으로 후크를 사용하면 명령을 사전 검증하고 잠재적으로 중단 할 수 있으며 작업이 완료된 후 사후 알림을 수행 할 수 있습니다. 후크 스크립트는 &lt;code&gt;$GIT_DIR/hooks/&lt;/code&gt; 디렉토리에 있으며 파일 이름에서 &lt;code&gt;.sample&lt;/code&gt; 접미사를 제거하면 됩니다. 이전 버전의 Git에서는 실행 가능해야했습니다.</target>
        </trans-unit>
        <trans-unit id="0c9afe2970bcd3db38ea14d913886ce00bad52d6" translate="yes" xml:space="preserve">
          <source>E.g, &lt;code&gt;format:&quot;The author of %h was %an, %ar%nThe title was &amp;gt;&amp;gt;%s&amp;lt;&amp;lt;%n&quot;&lt;/code&gt; would show something like this:</source>
          <target state="translated">예를 들어 &lt;code&gt;format:&quot;The author of %h was %an, %ar%nThe title was &amp;gt;&amp;gt;%s&amp;lt;&amp;lt;%n&quot;&lt;/code&gt; 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f48496348ce670a87dfe7a89fce6efc7850de45b" translate="yes" xml:space="preserve">
          <source>EVENT Format</source>
          <target state="translated">이벤트 형식</target>
        </trans-unit>
        <trans-unit id="6c7b6f5f1d21b52d57339a7396d0f52ff8e6b468" translate="yes" xml:space="preserve">
          <source>Each &quot;index&quot; entry has two bits worth of &quot;stage&quot; state. stage 0 is the normal one, and is the only one you&amp;rsquo;d see in any kind of normal use.</source>
          <target state="translated">각 &quot;인덱스&quot;항목에는 2 단계의 &quot;스테이지&quot;상태가 있습니다. 스테이지 0은 일반적인 것이며 모든 종류의 일반적인 용도에서 볼 수있는 유일한 것입니다.</target>
        </trans-unit>
        <trans-unit id="81f54a7f6a9b658757fad1b0dd5d1a9971c93ea4" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;%feature&lt;/code&gt; hash element is a hash reference and has the following structure:</source>
          <target state="translated">각 &lt;code&gt;%feature&lt;/code&gt; 해시 요소는 해시 참조이며 다음 구조를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b26592933b83f1f492565be647afc2706b49b317" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;-p&lt;/code&gt; indicates the id of a parent commit object.</source>
          <target state="translated">각 &lt;code&gt;-p&lt;/code&gt; 는 상위 커미트 오브젝트의 ID를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e2a09fd45cc17448d565b97a290193dc0600d3ce" translate="yes" xml:space="preserve">
          <source>Each action is implemented as a subroutine, and must be present in %actions hash. Some actions are disabled by default, and must be turned on via feature mechanism. For example to enable &lt;code&gt;blame&lt;/code&gt; view add the following to gitweb configuration file:</source>
          <target state="translated">각 조치는 서브 루틴으로 구현되며 % actions 해시에 있어야합니다. 일부 작업은 기본적으로 비활성화되어 있으며 기능 메커니즘을 통해 설정해야합니다. 예를 활성화하려면 &lt;code&gt;blame&lt;/code&gt; 보기를 gitweb 구성 파일에 다음을 추가합니다 :</target>
        </trans-unit>
        <trans-unit id="4a431caa46e2fb6d34e98615d6339148b9977f86" translate="yes" xml:space="preserve">
          <source>Each attribute can be in one of these states for a given path:</source>
          <target state="translated">각 경로는 주어진 경로에 대해 다음 상태 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80fa6b90c4af909cefe5f1fba5144ae109300923" translate="yes" xml:space="preserve">
          <source>Each blame entry always starts with a line of:</source>
          <target state="translated">각 책임 항목은 항상 다음 줄로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="2235e2f29b242d64317e253060371b53dfcfe3a6" translate="yes" xml:space="preserve">
          <source>Each command for the &lt;code&gt;proc-receive&lt;/code&gt; hook may point to a pseudo-reference and always has a zero-old as its old-oid, while the &lt;code&gt;proc-receive&lt;/code&gt; hook may update an alternate reference and the alternate reference may exist already with a non-zero old-oid. For this case, this hook will use &quot;option&quot; directives to report extended attributes for the reference given by the leading &quot;ok&quot; directive.</source>
          <target state="translated">&lt;code&gt;proc-receive&lt;/code&gt; 후크에 대한 각 명령 은 의사 참조를 가리킬 수 있으며 항상 old-oid로 0-old를 갖는 반면, &lt;code&gt;proc-receive&lt;/code&gt; 후크는 대체 참조를 업데이트 할 수 있으며 대체 참조는 이미 비 제로 구형. 이 경우이 후크는 &quot;옵션&quot;지시문을 사용하여 선행 &quot;ok&quot;지시문이 제공하는 참조에 대한 확장 속성을보고합니다.</target>
        </trans-unit>
        <trans-unit id="890525cbde82d7616c57fdec079512ee27038efd" translate="yes" xml:space="preserve">
          <source>Each commit imported by &lt;code&gt;git p4&lt;/code&gt; has a line at the end of the log message indicating the p4 depot location and change number. This line is used by later &lt;code&gt;git p4 sync&lt;/code&gt; operations to know which p4 changes are new.</source>
          <target state="translated">&lt;code&gt;git p4&lt;/code&gt; 로 가져온 커밋마다 로그 메시지 끝에 p4 저장소 위치 및 변경 번호를 나타내는 줄이 있습니다. 이 줄은 나중에 &lt;code&gt;git p4 sync&lt;/code&gt; 작업에서 어떤 p4 변경 사항이 새로운 것인지 알기 위해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0d7aba1c95771e1fa299e8f177a2cb8fdb72c0d3" translate="yes" xml:space="preserve">
          <source>Each event is a JSON-object containing multiple key/value pairs written as a single line and followed by a LF.</source>
          <target state="translated">각 이벤트는 단일 행으로 작성된 여러 키 / 값 쌍을 포함하고 LF가 포함 된 JSON 객체입니다.</target>
        </trans-unit>
        <trans-unit id="93024a055d9225f66feed1627e9698b1aeced23b" translate="yes" xml:space="preserve">
          <source>Each group of changes (called a &quot;hunk&quot;) in the textual diff output is prefixed with a line of the form:</source>
          <target state="translated">텍스트 diff 출력의 각 변경 그룹 ( &quot;hunk&quot;이라고 함) 앞에는 다음과 같은 형식의 줄이 붙습니다.</target>
        </trans-unit>
        <trans-unit id="227cc42fafaaa73089d47f3a2585fc225301de56" translate="yes" xml:space="preserve">
          <source>Each helper is specified by a single string in the configuration variable &lt;code&gt;credential.helper&lt;/code&gt; (and others, see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). The string is transformed by Git into a command to be executed using these rules:</source>
          <target state="translated">각 도우미는 구성 변수 &lt;code&gt;credential.helper&lt;/code&gt; 의 단일 문자열로 지정됩니다. (및 기타 항목은 &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). 문자열은 Git에 의해 다음 규칙을 사용하여 실행되는 명령으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="82afba91b0fbc1511d9d66475a7a1226634e3792" translate="yes" xml:space="preserve">
          <source>Each instruction has variable length. Instruction type is determined by the seventh bit of the first octet. The following diagrams follow the convention in RFC 1951 (Deflate compressed data format).</source>
          <target state="translated">각 명령어는 가변 길이를 갖습니다. 명령어 유형은 첫 번째 옥텟의 일곱 번째 비트에 의해 결정됩니다. 다음 다이어그램은 RFC 1951 (압축 데이터 형식 정의)의 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="e70c1e613f5f534aeea8db8eaf0d4059228f6833" translate="yes" xml:space="preserve">
          <source>Each line in &lt;code&gt;gitattributes&lt;/code&gt; file is of form:</source>
          <target state="translated">&lt;code&gt;gitattributes&lt;/code&gt; 파일의 각 줄 은 다음과 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="1c072d6c2cdd76489a2967b2e7ee81381c672ff3" translate="yes" xml:space="preserve">
          <source>Each line in a &lt;code&gt;gitignore&lt;/code&gt; file specifies a pattern. When deciding whether to ignore a path, Git normally checks &lt;code&gt;gitignore&lt;/code&gt; patterns from multiple sources, with the following order of precedence, from highest to lowest (within one level of precedence, the last matching pattern decides the outcome):</source>
          <target state="translated">&lt;code&gt;gitignore&lt;/code&gt; 파일의 각 줄은 패턴을 지정합니다. 경로를 무시할지 여부를 결정할 때 Git은 일반적으로 여러 소스의 &lt;code&gt;gitignore&lt;/code&gt; 패턴을 다음 우선 순위로 가장 높은 순서에서 가장 낮은 순서로 확인합니다 (1 단계의 우선 순위 내에서 마지막 일치 패턴이 결과를 결정 함).</target>
        </trans-unit>
        <trans-unit id="d043aa624315c625b39f19b7c5a71a08d0fbefd2" translate="yes" xml:space="preserve">
          <source>Each line of options has this format:</source>
          <target state="translated">각 옵션 라인의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ce263659ab1a0135f8fda2a68c8ecc96cb2e4b52" translate="yes" xml:space="preserve">
          <source>Each line of the &lt;code&gt;git ls-files --unmerged&lt;/code&gt; output begins with the blob mode bits, blob SHA-1, 'stage number', and the filename. The 'stage number' is Git&amp;rsquo;s way to say which tree it came from: stage 1 corresponds to the &lt;code&gt;$orig&lt;/code&gt; tree, stage 2 to the &lt;code&gt;HEAD&lt;/code&gt; tree, and stage 3 to the &lt;code&gt;$target&lt;/code&gt; tree.</source>
          <target state="translated">&lt;code&gt;git ls-files --unmerged&lt;/code&gt; 출력 의 각 줄은 블로 브 모드 비트, 블로 브 SHA-1, '스테이지 번호'및 파일 이름으로 시작합니다. 'stage number'는 Git이 어떤 트리에서 왔는지 말하는 방법입니다. 1 단계는 &lt;code&gt;$orig&lt;/code&gt; 트리, 2 단계는 &lt;code&gt;HEAD&lt;/code&gt; 트리, 3 단계는 &lt;code&gt;$target&lt;/code&gt; 트리에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="a2e72e23a1ee3c2cf405696e86ad1ef3c4d6f422" translate="yes" xml:space="preserve">
          <source>Each line of the &lt;code&gt;git ls-files --unmerged&lt;/code&gt; output begins with the blob mode bits, blob SHA-1, &lt;code&gt;stage number&lt;/code&gt;, and the filename. The &lt;code&gt;stage number&lt;/code&gt; is Git&amp;rsquo;s way to say which tree it came from: stage 1 corresponds to the &lt;code&gt;$orig&lt;/code&gt; tree, stage 2 to the &lt;code&gt;HEAD&lt;/code&gt; tree, and stage 3 to the &lt;code&gt;$target&lt;/code&gt; tree.</source>
          <target state="translated">&lt;code&gt;git ls-files --unmerged&lt;/code&gt; 출력 의 각 줄은 blob 모드 비트, blob SHA-1, &lt;code&gt;stage number&lt;/code&gt; 및 파일 이름으로 시작합니다. &lt;code&gt;stage number&lt;/code&gt; 1 개 단계 상당에 : 그것은에서 들어온 나무 말할 망할 놈의 방법입니다 &lt;code&gt;$orig&lt;/code&gt; 받는 나무, 2 단계 &lt;code&gt;HEAD&lt;/code&gt; 받는 나무, 무대 3 &lt;code&gt;$target&lt;/code&gt; 트리.</target>
        </trans-unit>
        <trans-unit id="ac1b4287ed9a44af81d40c798f15ea7666d1fc7e" translate="yes" xml:space="preserve">
          <source>Each linked working tree has a private sub-directory in the repository&amp;rsquo;s $GIT_DIR/worktrees directory. The private sub-directory&amp;rsquo;s name is usually the base name of the linked working tree&amp;rsquo;s path, possibly appended with a number to make it unique. For example, when &lt;code&gt;$GIT_DIR=/path/main/.git&lt;/code&gt; the command &lt;code&gt;git worktree add /path/other/test-next next&lt;/code&gt; creates the linked working tree in &lt;code&gt;/path/other/test-next&lt;/code&gt; and also creates a &lt;code&gt;$GIT_DIR/worktrees/test-next&lt;/code&gt; directory (or &lt;code&gt;$GIT_DIR/worktrees/test-next1&lt;/code&gt; if &lt;code&gt;test-next&lt;/code&gt; is already taken).</source>
          <target state="translated">링크 된 각 작업 트리에는 저장소의 $ GIT_DIR / worktrees 디렉토리에 개인용 하위 디렉토리가 있습니다. 개인용 서브 디렉토리의 이름은 일반적으로 연결된 작업 트리 경로의 기본 이름이며 고유하게하기 위해 숫자가 추가 될 수 있습니다. 예를 들어, &lt;code&gt;$GIT_DIR=/path/main/.git&lt;/code&gt; 명령 &lt;code&gt;git worktree add /path/other/test-next next&lt;/code&gt; 링크 된 작업 트리의 생성 &lt;code&gt;/path/other/test-next&lt;/code&gt; 또와는 생성 &lt;code&gt;$GIT_DIR/worktrees/test-next&lt;/code&gt; 디렉토리 (또는 &lt;code&gt;test-next&lt;/code&gt; 가 이미 수행 된 경우 &lt;code&gt;$GIT_DIR/worktrees/test-next1&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="08c05bcbce27635e929ab0aeef0154946c733deb" translate="yes" xml:space="preserve">
          <source>Each linked working tree has a private sub-directory in the repository&amp;rsquo;s &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; directory. The private sub-directory&amp;rsquo;s name is usually the base name of the linked working tree&amp;rsquo;s path, possibly appended with a number to make it unique. For example, when &lt;code&gt;$GIT_DIR=/path/main/.git&lt;/code&gt; the command &lt;code&gt;git worktree add /path/other/test-next next&lt;/code&gt; creates the linked working tree in &lt;code&gt;/path/other/test-next&lt;/code&gt; and also creates a &lt;code&gt;$GIT_DIR/worktrees/test-next&lt;/code&gt; directory (or &lt;code&gt;$GIT_DIR/worktrees/test-next1&lt;/code&gt; if &lt;code&gt;test-next&lt;/code&gt; is already taken).</source>
          <target state="translated">연결된 각 작업 트리에는 저장소의 &lt;code&gt;$GIT_DIR/worktrees&lt;/code&gt; 디렉토리에 개인 하위 디렉토리가 있습니다. 개인 하위 디렉토리의 이름은 일반적으로 연결된 작업 트리 경로의 기본 이름이며 고유하게 만들기 위해 번호가 추가 될 수 있습니다. 예를 들어, &lt;code&gt;$GIT_DIR=/path/main/.git&lt;/code&gt; 명령 &lt;code&gt;git worktree add /path/other/test-next next&lt;/code&gt; 링크 된 작업 트리의 생성 &lt;code&gt;/path/other/test-next&lt;/code&gt; 또와는 생성 &lt;code&gt;$GIT_DIR/worktrees/test-next&lt;/code&gt; 디렉토리 (또는 &lt;code&gt;test-next&lt;/code&gt; 가 이미 사용 된 경우 &lt;code&gt;$GIT_DIR/worktrees/test-next1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0e13434b85bdba9c36937ef9acd2f33c427adfe8" translate="yes" xml:space="preserve">
          <source>Each of the attribute requirements for the path takes one of these forms:</source>
          <target state="translated">경로에 대한 각 속성 요구 사항은 다음 형식 중 하나를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="58398b8104bc9622bb9865f6e7c9793546a9471d" translate="yes" xml:space="preserve">
          <source>Each of the four branches is usually a direct descendant of the one above it.</source>
          <target state="translated">네 가지 가지 각각은 보통 그 위 가지의 직계 후손입니다.</target>
        </trans-unit>
        <trans-unit id="dfc2dc1cc1f2e4f6e3d7ce6e6191c01415d0880b" translate="yes" xml:space="preserve">
          <source>Each of these options must appear first on the command line.</source>
          <target state="translated">이러한 각 옵션은 명령 행에서 먼저 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="79d9036a8f3f011f6caea432d8fa6198deb15d8c" translate="yes" xml:space="preserve">
          <source>Each other line contains a single pattern.</source>
          <target state="translated">서로 다른 선은 단일 패턴을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="36e6db0cb81d09d2c644d8a7c4b702648cc38f78" translate="yes" xml:space="preserve">
          <source>Each patch can be applied in order.</source>
          <target state="translated">각 패치는 순서대로 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d39c2ae5926cd9b5a6631ab32e0430d3e598f09" translate="yes" xml:space="preserve">
          <source>Each patch includes a single logical change, together with a message explaining the change.</source>
          <target state="translated">각 패치에는 변경 사항을 설명하는 메시지와 함께 단일 논리적 변경 사항이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="493d693b4f2b5ea37d0460dc9ff9f76e6d401041" translate="yes" xml:space="preserve">
          <source>Each pattern pair consists of the source side (before the colon) and the destination side (after the colon). The ref to be pushed is determined by finding a match that matches the source side, and where it is pushed is determined by using the destination side.</source>
          <target state="translated">각 패턴 쌍은 소스 측 (콜론 이전)과 대상 측 (콜론 이후)으로 구성됩니다. 푸시 할 참조는 소스 측과 일치하는 일치 항목을 찾아서 결정되며, 푸시되는 위치는 대상 측을 사용하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="b313cea753099ce8f3968fb8a5c9e65e86c611ac" translate="yes" xml:space="preserve">
          <source>Each pattern pair consists of the source side (before the colon) and the destination side (after the colon). The ref to be pushed is determined by finding a match that matches the source side, and where it is pushed is determined by using the destination side. The rules used to match a ref are the same rules used by &lt;code&gt;git rev-parse&lt;/code&gt; to resolve a symbolic ref name. See &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;.</source>
          <target state="translated">각 패턴 쌍은 소스 측 (콜론 이전)과 대상 측 (콜론 이후)으로 구성됩니다. 푸시 할 참조는 소스 측과 일치하는 일치 항목을 찾아서 결정되며, 푸시되는 위치는 대상 측을 사용하여 결정됩니다. 참조와 일치하는 데 사용되는 규칙 은 기호 참조 이름을 확인하기 위해 &lt;code&gt;git rev-parse&lt;/code&gt; 에서 사용하는 규칙과 동일 합니다. &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2aa7f4f33bfb7b26b4af691cb7e2c6d52612b8b" translate="yes" xml:space="preserve">
          <source>Each remote helper is expected to support only a subset of commands. The operations a helper supports are declared to Git in the response to the &lt;code&gt;capabilities&lt;/code&gt; command (see COMMANDS, below).</source>
          <target state="translated">각 원격 헬퍼는 명령의 서브 세트 만 지원해야합니다. 도우미가 지원하는 작업은 &lt;code&gt;capabilities&lt;/code&gt; 명령 에 대한 응답으로 Git에 선언됩니다 (아래의 COMMANDS 참조).</target>
        </trans-unit>
        <trans-unit id="640db855296fc622a8934e713d8f1835acdff3f5" translate="yes" xml:space="preserve">
          <source>Each time a new shared index file is created, the old shared index files are deleted if their modification time is older than what is specified by the splitIndex.sharedIndexExpire config variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">새 공유 색인 파일이 작성 될 때마다 수정 시간이 splitIndex.sharedIndexExpire 구성 변수에 지정된 시간보다 오래된 경우 이전 공유 색인 파일이 삭제됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6b67247d73793e579b74a9b09ccf935b5a398f89" translate="yes" xml:space="preserve">
          <source>Each time a superproject update moves a populated submodule (e.g. when switching between commits before and after the move) a stale submodule checkout will remain in the old location and an empty directory will appear in the new location. To populate the submodule again in the new location the user will have to run &quot;git submodule update&quot; afterwards. Removing the old directory is only safe when it uses a gitfile, as otherwise the history of the submodule will be deleted too. Both steps will be obsolete when recursive submodule update has been implemented.</source>
          <target state="translated">수퍼 프로젝트 업데이트가 채워진 하위 모듈을 이동할 때마다 (예 : 이동 전후 커밋간에 전환 할 때) 오래된 하위 모듈 체크 아웃이 이전 위치에 유지되고 빈 디렉토리가 새 위치에 나타납니다. 새로운 위치에서 서브 모듈을 다시 채우려면 사용자는 &quot;git submodule update&quot;를 실행해야합니다. 이전 디렉토리를 제거하는 것은 gitfile을 사용할 때만 안전합니다. 그렇지 않으면 서브 모듈의 히스토리도 삭제됩니다. 재귀 하위 모듈 업데이트가 구현되면 두 단계가 모두 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70398d4e57fc6de31488380bf7caac1138d58530" translate="yes" xml:space="preserve">
          <source>Each time a superproject update removes a populated submodule (e.g. when switching between commits before and after the removal) a stale submodule checkout will remain in the old location. Removing the old directory is only safe when it uses a gitfile, as otherwise the history of the submodule will be deleted too. This step will be obsolete when recursive submodule update has been implemented.</source>
          <target state="translated">수퍼 프로젝트 업데이트가 채워진 하위 모듈을 제거 할 때마다 (예 : 제거 전후 커밋 간 전환시) 오래된 하위 모듈 체크 아웃은 이전 위치에 유지됩니다. 이전 디렉토리를 제거하는 것은 gitfile을 사용할 때만 안전합니다. 그렇지 않으면 서브 모듈의 히스토리도 삭제됩니다. 재귀 서브 모듈 업데이트가 구현되면이 단계는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49035126eea24f612f322a34d235d8eeac55e17a" translate="yes" xml:space="preserve">
          <source>Each time you resolve the conflicts in a file and update the index:</source>
          <target state="translated">파일에서 충돌을 해결하고 색인을 업데이트 할 때마다 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="91df855bba63011edb2c56419d0fb8efa1e50e11" translate="yes" xml:space="preserve">
          <source>Earlier we said that trivial merges are done inside &lt;code&gt;git read-tree -m&lt;/code&gt;. For example, if the file did not change from &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;HEAD&lt;/code&gt; or &lt;code&gt;$target&lt;/code&gt;, or if the file changed from &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;$target&lt;/code&gt; the same way, obviously the final outcome is what is in &lt;code&gt;HEAD&lt;/code&gt;. What the above example shows is that file &lt;code&gt;hello.c&lt;/code&gt; was changed from &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;$orig&lt;/code&gt; to &lt;code&gt;$target&lt;/code&gt; in a different way. You could resolve this by running your favorite 3-way merge program, e.g. &lt;code&gt;diff3&lt;/code&gt;, &lt;code&gt;merge&lt;/code&gt;, or Git&amp;rsquo;s own merge-file, on the blob objects from these three stages yourself, like this:</source>
          <target state="translated">앞에서 우리는 간단한 병합이 &lt;code&gt;git read-tree -m&lt;/code&gt; 내부에서 수행된다고 말했다 . 예를 들어, 파일이 &lt;code&gt;$orig&lt;/code&gt; 에서 &lt;code&gt;HEAD&lt;/code&gt; 또는 &lt;code&gt;$target&lt;/code&gt; 으로 변경되지 않았 거나 파일이 &lt;code&gt;$orig&lt;/code&gt; 에서 &lt;code&gt;HEAD&lt;/code&gt; 및 &lt;code&gt;$orig&lt;/code&gt; 에서 &lt;code&gt;$target&lt;/code&gt; 으로 동일한 방식으로 변경된 경우 최종 결과는 분명히 &lt;code&gt;HEAD&lt;/code&gt; 에있는 것 입니다. 위의 예에서 보여지는 것처럼 &lt;code&gt;hello.c&lt;/code&gt; 파일 은 &lt;code&gt;$orig&lt;/code&gt; 에서 &lt;code&gt;HEAD&lt;/code&gt; 로 , &lt;code&gt;$orig&lt;/code&gt; 에서 &lt;code&gt;$target&lt;/code&gt; 으로 다른 방식으로 변경되었습니다. 선호하는 3 방향 병합 프로그램 (예 : &lt;code&gt;diff3&lt;/code&gt; ) 을 실행하여이 문제를 해결할 수 있습니다., &lt;code&gt;merge&lt;/code&gt; 또는 Git의 자체 병합 파일은 다음과 같은 세 단계의 blob 객체에서 직접 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="cf0ee6adeaeadff98f7e216b0d8eb81b31226098" translate="yes" xml:space="preserve">
          <source>Earlier, we saw that one file under &lt;code&gt;.git/objects/??/&lt;/code&gt; directory is stored for each Git object you create. This representation is efficient to create atomically and safely, but not so convenient to transport over the network. Since Git objects are immutable once they are created, there is a way to optimize the storage by &quot;packing them together&quot;. The command</source>
          <target state="translated">이전에는 생성 한 각 Git 객체에 대해 &lt;code&gt;.git/objects/??/&lt;/code&gt; 디렉토리에 하나의 파일 이 저장되어 있음을 확인했습니다. 이 표현은 원자 적으로 안전하게 만드는 데 효율적이지만 네트워크를 통해 전송하기에는 그리 편리하지 않습니다. Git 객체는 일단 생성되면 변경할 수 없으므로 &quot;함께 포장&quot;하여 스토리지를 최적화 할 수 있습니다. 명령</target>
        </trans-unit>
        <trans-unit id="b4c8a83331a00582f4030fa5296077717cda7730" translate="yes" xml:space="preserve">
          <source>Ease of use. It is often much simpler to write a binary to text transformation than it is to perform your own diff. In many cases, existing programs can be used as textconv filters (e.g., exif, odt2txt).</source>
          <target state="translated">사용의 용이성. 자신의 diff를 수행하는 것보다 이진을 텍스트로 변환하는 것이 훨씬 간단합니다. 대부분의 경우 기존 프로그램을 텍스트 변환 필터 (예 : exif, odt2txt)로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4d52eb229c8c557c44ab0035085b989953060f9" translate="yes" xml:space="preserve">
          <source>Easily extendable as capabilities are moved into their own section of the protocol, no longer being hidden behind a NUL byte and limited by the size of a pkt-line</source>
          <target state="translated">기능이 프로토콜의 자체 섹션으로 이동함에 따라 쉽게 확장 가능, 더 이상 NUL 바이트 뒤에 숨기지 않고 pkt-line의 크기에 의해 제한됨</target>
        </trans-unit>
        <trans-unit id="c0ecd6c3f25fc4cb4d76566a21fece2ca48f95ab" translate="yes" xml:space="preserve">
          <source>Easy case: The changes are literally the same.</source>
          <target state="translated">쉬운 경우 : 변경 사항은 그대로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d4f35a5d52e75e1ab425158dcb45339db600d3f4" translate="yes" xml:space="preserve">
          <source>Eclipse 3.0, 3.1.2 on MacOSX (see Eclipse CVS Client Notes)</source>
          <target state="translated">MacOSX의 Eclipse 3.0, 3.1.2 (Eclipse CVS Client Notes 참조)</target>
        </trans-unit>
        <trans-unit id="f5e176bd2c2df731632b9ca0ee7983e84b3d8517" translate="yes" xml:space="preserve">
          <source>Eclipse cvs client notes</source>
          <target state="translated">이클립스 이력서 클라이언트 노트</target>
        </trans-unit>
        <trans-unit id="ea0675157801730c96e515d20a6ad02ac765e6d4" translate="yes" xml:space="preserve">
          <source>Edit an object&amp;rsquo;s content interactively. The existing content for &amp;lt;object&amp;gt; is pretty-printed into a temporary file, an editor is launched on the file, and the result is parsed to create a new object of the same type as &amp;lt;object&amp;gt;. A replacement ref is then created to replace &amp;lt;object&amp;gt; with the newly created object. See &lt;a href=&quot;git-var&quot;&gt;git-var[1]&lt;/a&gt; for details about how the editor will be chosen.</source>
          <target state="translated">대화식으로 객체의 내용을 편집합니다. &amp;lt;object&amp;gt;의 기존 내용은 임시 파일로 인쇄되고 파일에서 편집기가 시작되며 결과는 &amp;lt;object&amp;gt;와 동일한 유형의 새 개체를 만들기 위해 구문 분석됩니다. 그런 다음 &amp;lt;object&amp;gt;를 새로 만든 개체로 바꾸는 대체 참조가 만들어집니다. 참조 &lt;a href=&quot;git-var&quot;&gt;자식-VAR [1]&lt;/a&gt; 에디터가 선택되는 방법에 대한 자세한 내용을.</target>
        </trans-unit>
        <trans-unit id="0f76fc2a41a48ffbf729f7fe389bfe3f0b08de68" translate="yes" xml:space="preserve">
          <source>Edit the commit message before committing to SVN. This is off by default for objects that are commits, and forced on when committing tree objects.</source>
          <target state="translated">SVN에 커밋하기 전에 커밋 메시지를 편집하십시오. 커밋되는 객체의 경우 기본적으로 꺼져 있으며 트리 객체를 커밋 할 때 강제로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c92b0955a7a67e8bc1f5f7afd177ec4ed55d0e4c" translate="yes" xml:space="preserve">
          <source>Edit the files in place.</source>
          <target state="translated">파일을 제자리에 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="b87cea5cffa31e45fd50bcd7540894242796f029" translate="yes" xml:space="preserve">
          <source>Edit the notes for a given object (defaults to HEAD).</source>
          <target state="translated">주어진 개체에 대한 메모를 편집합니다 (기본값은 HEAD).</target>
        </trans-unit>
        <trans-unit id="81933d4e997d5f22262236af308c480381855b0f" translate="yes" xml:space="preserve">
          <source>Edit the todo list during an interactive rebase.</source>
          <target state="translated">대화식 리베이스 중에 할 일 목록을 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="f392476dbdf7968fc4726a7173f15cf238dddd46" translate="yes" xml:space="preserve">
          <source>Editing patches</source>
          <target state="translated">패치 편집</target>
        </trans-unit>
        <trans-unit id="8f25a859269ca51039632dd6bba28fb061cfb8d4" translate="yes" xml:space="preserve">
          <source>Effects</source>
          <target state="translated">Effects</target>
        </trans-unit>
        <trans-unit id="7002bc1d2bcb94f212817ade973f1baffe1d4266" translate="yes" xml:space="preserve">
          <source>Either a &lt;a href=&quot;#def_working_tree&quot;&gt;working tree&lt;/a&gt;, or a &lt;a href=&quot;#def_tree_object&quot;&gt;tree object&lt;/a&gt; together with the dependent &lt;a href=&quot;#def_blob_object&quot;&gt;blob&lt;/a&gt; and tree objects (i.e. a stored representation of a working tree).</source>
          <target state="translated">어느 &lt;a href=&quot;#def_working_tree&quot;&gt;작업 트리&lt;/a&gt; , 또는 &lt;a href=&quot;#def_tree_object&quot;&gt;트리 오브젝트&lt;/a&gt; 종속과 함께 &lt;a href=&quot;#def_blob_object&quot;&gt;방울&lt;/a&gt; 과 트리 객체 (작업 트리의 예를 저장 표현).</target>
        </trans-unit>
        <trans-unit id="bc0851580574fafe647ac3b5e7bd049ba47eee8d" translate="yes" xml:space="preserve">
          <source>Either the hash or the filename under [URL]/refs/ to pull.</source>
          <target state="translated">[URL] / refs / 아래의 해시 또는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3c055884457fa0453683ceee26bbe41d08beb912" translate="yes" xml:space="preserve">
          <source>Either way, if you have a string of untestable commits, it might happen that the regression you are looking for has been introduced by one of these untestable commits. In this case it&amp;rsquo;s not possible to tell for sure which commit introduced the regression.</source>
          <target state="translated">어느 쪽이든, 테스트 할 수없는 커밋 문자열이있는 경우 찾고있는 회귀가 테스트 할 수없는 커밋 중 하나에 의해 도입되었을 수 있습니다. 이 경우 어떤 커밋이 회귀를 도입했는지 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="84add5b2952787581cb9a8851eef63d1ec75d22b" translate="yes" xml:space="preserve">
          <source>Email</source>
          <target state="translated">Email</target>
        </trans-unit>
        <trans-unit id="727400f70d8ff4dd021cd3b46cd8407431accd18" translate="yes" xml:space="preserve">
          <source>Empty commits</source>
          <target state="translated">빈 커밋</target>
        </trans-unit>
        <trans-unit id="64c856db8d7087653e88ddbd52d985c5029c26f3" translate="yes" xml:space="preserve">
          <source>Empty context lines that do not have &lt;code&gt;any&lt;/code&gt; whitespace.</source>
          <target state="translated">이없는 빈 상황에 맞는 라인 &lt;code&gt;any&lt;/code&gt; 공백을.</target>
        </trans-unit>
        <trans-unit id="bc35de4b332414e34ea66c4e2722d1b3c677ee26" translate="yes" xml:space="preserve">
          <source>Enable &quot;sparse checkout&quot; feature. See &lt;a href=&quot;git-sparse-checkout&quot;&gt;git-sparse-checkout[1]&lt;/a&gt; for more information.</source>
          <target state="translated">&quot;스파 스 체크 아웃&quot;기능을 활성화하십시오. 자세한 내용은 &lt;a href=&quot;git-sparse-checkout&quot;&gt;git-sparse-checkout [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b1506b425dd0a659b4e3f7dbaad1db76c1920ca2" translate="yes" xml:space="preserve">
          <source>Enable (1) or disable (0) debug output. If enabled, SMTP commands and replies will be printed. Useful to debug TLS connection and authentication problems.</source>
          <target state="translated">디버그 출력을 활성화 (1) 또는 비활성화 (0)합니다. 활성화하면 SMTP 명령과 응답이 인쇄됩니다. TLS 연결 및 인증 문제를 디버깅하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5ca5f9ffb4eef636571b0732ca8e82f4b117bf57" translate="yes" xml:space="preserve">
          <source>Enable Git&amp;rsquo;s password prompt for the SSL certificate. Otherwise OpenSSL will prompt the user, possibly many times, if the certificate or private key is encrypted. Can be overridden by the &lt;code&gt;GIT_SSL_CERT_PASSWORD_PROTECTED&lt;/code&gt; environment variable.</source>
          <target state="translated">SSL 인증서에 대해 Git의 비밀번호 프롬프트를 사용하십시오. 그렇지 않으면 인증서 또는 개인 키가 암호화 된 경우 OpenSSL에서 사용자에게 여러 번 프롬프트를 표시합니다. &lt;code&gt;GIT_SSL_CERT_PASSWORD_PROTECTED&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="22af37288ef16d6e96158d900edae0bae2453223" translate="yes" xml:space="preserve">
          <source>Enable Git&amp;rsquo;s password prompt for the proxy SSL certificate. Otherwise OpenSSL will prompt the user, possibly many times, if the certificate or private key is encrypted. Can be overriden by the &lt;code&gt;GIT_PROXY_SSL_CERT_PASSWORD_PROTECTED&lt;/code&gt; environment variable.</source>
          <target state="translated">프록시 SSL 인증서에 대해 Git의 암호 프롬프트를 활성화합니다. 그렇지 않으면 OpenSSL은 인증서 또는 개인 키가 암호화 된 경우 여러 번 사용자에게 메시지를 표시합니다. 다음으로 재정의 될 수 있습니다. &lt;code&gt;GIT_PROXY_SSL_CERT_PASSWORD_PROTECTED&lt;/code&gt; 환경 변수 .</target>
        </trans-unit>
        <trans-unit id="202cfbf6c643ccf61c3e6855fb4942a959d7c88c" translate="yes" xml:space="preserve">
          <source>Enable and configure &quot;patches&quot; view, which displays list of commits in email (plain text) output format; see also &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;. The value is the maximum number of patches in a patchset generated in &quot;patches&quot; view. Set the &lt;code&gt;default&lt;/code&gt; field to a list containing single item of or to an empty list to disable patch view, or to a list containing a single negative number to remove any limit. Default value is 16.</source>
          <target state="translated">커밋 목록을 전자 메일 (일반 텍스트) 출력 형식으로 표시하는 &quot;패치&quot;보기를 활성화하고 구성합니다. &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; 도 참조하십시오 . 이 값은 &quot;패치&quot;보기에서 생성 된 패치 세트의 최대 패치 수입니다. 패치보기를 비활성화 하려면 &lt;code&gt;default&lt;/code&gt; 필드를 단일 항목이 포함 된 목록 또는 빈 목록으로 설정하거나 제한을 제거하려면 단일 음수를 포함하는 목록으로 설정하십시오. 기본값은 16입니다.</target>
        </trans-unit>
        <trans-unit id="3ec940cc58a7e0a3ca8323d3832e04ecb527aead" translate="yes" xml:space="preserve">
          <source>Enable and configure the &quot;snapshot&quot; action, which allows user to download a compressed archive of any tree or commit, as produced by &lt;a href=&quot;git-archive&quot;&gt;git-archive[1]&lt;/a&gt; and possibly additionally compressed. This can potentially generate high traffic if you have large project.</source>
          <target state="translated">&quot;스냅 샷&quot;작업을 활성화하고 구성합니다. 사용자는 &lt;a href=&quot;git-archive&quot;&gt;git-archive [1]에&lt;/a&gt; 의해 생성되고 추가로 압축 된 트리 또는 커밋의 압축 된 아카이브를 다운로드 할 수 있습니다 . 큰 프로젝트가있는 경우 트래픽이 많이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="875ff7ca114490b100a4ae7597d23eb505e57466" translate="yes" xml:space="preserve">
          <source>Enable and configure the ability to change a common time zone for dates in gitweb output via JavaScript. Dates in gitweb output include authordate and committerdate in &quot;commit&quot;, &quot;commitdiff&quot; and &quot;log&quot; views, and taggerdate in &quot;tag&quot; view. Enabled by default.</source>
          <target state="translated">JavaScript를 통해 gitweb 출력의 날짜에 대한 표준 시간대를 변경하는 기능을 활성화하고 구성하십시오. gitweb 출력의 날짜에는 &quot;commit&quot;, &quot;commitdiff&quot;및 &quot;log&quot;보기의 authordate 및 committerdate 및 &quot;tag&quot;보기의 taggerdate가 포함됩니다. 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1b8a656580e419265edb3d93e7fbf612f88122b" translate="yes" xml:space="preserve">
          <source>Enable config options that are new to Git, and are being considered for future defaults. Config settings included here may be added or removed with each release, including minor version updates. These settings may have unintended interactions since they are so new. Please enable this setting if you are interested in providing feedback on experimental features. The new default values are:</source>
          <target state="translated">Git에 새로운 설정 옵션을 활성화하고 향후 기본값으로 고려합니다. 여기에 포함 된 구성 설정은 부 버전 업데이트를 포함하여 각 릴리스마다 추가 또는 제거 될 수 있습니다. 이러한 설정은 새로운 기능이므로 의도하지 않은 상호 작용이있을 수 있습니다. 실험 기능에 대한 피드백을 제공하려면이 설정을 활성화하십시오. 새로운 기본값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8740fb3b16d2502b6a07330a252227f128574417" translate="yes" xml:space="preserve">
          <source>Enable config options that optimize for repos with many files in the working directory. With many files, commands such as &lt;code&gt;git status&lt;/code&gt; and &lt;code&gt;git checkout&lt;/code&gt; may be slow and these new defaults improve performance:</source>
          <target state="translated">작업 디렉토리에 많은 파일이있는 저장소를 최적화하는 구성 옵션을 활성화하십시오. 많은 파일에서 &lt;code&gt;git status&lt;/code&gt; 및 &lt;code&gt;git checkout&lt;/code&gt; 과 같은 명령 이 느려질 수 있으며 이러한 새로운 기본값은 성능을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="b62688a948f16b8896e24589781ecaee64693ffd" translate="yes" xml:space="preserve">
          <source>Enable displaying how much time and how many Git commands it took to generate and display each page in the page footer (at the bottom of page). For example the footer might contain: &quot;This page took 6.53325 seconds and 13 Git commands to generate.&quot; Disabled by default.</source>
          <target state="translated">페이지 바닥 글 (페이지 하단)에 각 페이지를 생성하고 표시하는 데 걸리는 시간과 Git 명령 수를 표시합니다. 예를 들어 바닥 글에는 &quot;이 페이지에는 6.53325 초와 13 개의 Git 명령이 생성되었습니다.&quot;가 포함될 수 있습니다. 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9bd131fb11e7d8a575c789c619c56115c835cfc" translate="yes" xml:space="preserve">
          <source>Enable displaying remote heads (remote-tracking branches) in the &quot;heads&quot; list. In most cases the list of remote-tracking branches is an unnecessary internal private detail, and this feature is therefore disabled by default. &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb[1]&lt;/a&gt;, which is usually used to browse local repositories, enables and uses this feature.</source>
          <target state="translated">&quot;헤드&quot;목록에서 원격 헤드 (원격 추적 분기)를 표시 할 수 있습니다. 대부분의 경우 원격 추적 분기 목록은 불필요한 내부 개인 정보이므로이 기능은 기본적으로 비활성화되어 있습니다. 일반적으로 로컬 리포지토리를 탐색하는 데 사용되는 &lt;a href=&quot;git-instaweb&quot;&gt;git-instaweb [1]&lt;/a&gt; 은이 기능을 활성화하고 사용합니다.</target>
        </trans-unit>
        <trans-unit id="39da6c4d119e094eeb647ff45a2f63bf34d04c9c" translate="yes" xml:space="preserve">
          <source>Enable grep search, which lists the files in currently selected tree (directory) containing the given string; see &lt;a href=&quot;git-grep&quot;&gt;git-grep[1]&lt;/a&gt;. This can be potentially CPU-intensive, of course. Enabled by default.</source>
          <target state="translated">주어진 문자열을 포함하는 현재 선택된 트리 (디렉토리)의 파일을 나열하는 grep 검색을 사용하십시오. &lt;a href=&quot;git-grep&quot;&gt;git-grep [1]을&lt;/a&gt; 참조하십시오 . 물론 이것은 CPU를 많이 사용할 수 있습니다. 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="393e4a210cdfd96d50c3abf9958899d9c77b22c9" translate="yes" xml:space="preserve">
          <source>Enable more strict checking, namely to catch a file mode recorded with g+w bit set, which was created by older versions of Git. Existing repositories, including the Linux kernel, Git itself, and sparse repository have old objects that triggers this check, but it is recommended to check new projects with this flag.</source>
          <target state="translated">이전 버전의 Git에 의해 생성 된 g + w 비트 세트로 기록 된 파일 모드를 포착하기 위해보다 엄격한 검사를 활성화합니다. Linux 커널, Git 자체 및 스파 스 저장소를 포함한 기존 저장소에는이 검사를 트리거하는 오래된 오브젝트가 있지만이 플래그를 사용하여 새 프로젝트를 검사하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8081f1426d8047f2f5c9039fb2b3187c4aed51ad" translate="yes" xml:space="preserve">
          <source>Enable multipart/mixed attachments as the default for &lt;code&gt;format-patch&lt;/code&gt;. The value can also be a double quoted string which will enable attachments as the default and set the value as the boundary. See the --attach option in &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;format-patch&lt;/code&gt; 의 기본값으로 멀티 파트 / 혼합 첨부 파일을 활성화하십시오 . 값은 큰 따옴표로 묶인 문자열 일 수도 있으며 첨부 파일을 기본값으로 사용하고 값을 경계로 설정합니다. &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]&lt;/a&gt; 의 --attach 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d973b021f64131371542864785f310ed020b9e66" translate="yes" xml:space="preserve">
          <source>Enable or disable files system monitor feature. These options take effect whatever the value of the &lt;code&gt;core.fsmonitor&lt;/code&gt; configuration variable (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;). But a warning is emitted when the change goes against the configured value, as the configured value will take effect next time the index is read and this will remove the intended effect of the option.</source>
          <target state="translated">파일 시스템 모니터 기능을 활성화 또는 비활성화합니다. 이 옵션은 &lt;code&gt;core.fsmonitor&lt;/code&gt; 구성 변수 의 값에 관계없이 적용됩니다 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ). 그러나 구성된 값이 다음에 인덱스를 읽을 때 적용되고 옵션의 의도 된 효과가 제거되므로 구성된 값에 대한 변경이 발생하면 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d83423bb73684fa975c3f77aeba009920792cf88" translate="yes" xml:space="preserve">
          <source>Enable or disable split index mode. If split-index mode is already enabled and &lt;code&gt;--split-index&lt;/code&gt; is given again, all changes in $GIT_DIR/index are pushed back to the shared index file.</source>
          <target state="translated">분할 인덱스 모드를 활성화 또는 비활성화합니다. 분할 인덱스 모드가 이미 활성화되어 있고 &lt;code&gt;--split-index&lt;/code&gt; 가 다시 지정된 경우 $ GIT_DIR / index의 모든 변경 사항이 공유 인덱스 파일로 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="f8b0173e3fdc03c4e03595346f1584e741b798c1" translate="yes" xml:space="preserve">
          <source>Enable or disable untracked cache feature. Please use &lt;code&gt;--test-untracked-cache&lt;/code&gt; before enabling it.</source>
          <target state="translated">추적되지 않은 캐시 기능을 활성화 또는 비활성화합니다. 사용하십시오 &lt;code&gt;--test-untracked-cache&lt;/code&gt; 를 사용하기 전에.</target>
        </trans-unit>
        <trans-unit id="5d058dbf876c4efd16b9ed5eae486a10be79bb86" translate="yes" xml:space="preserve">
          <source>Enable parallel index preload for operations like &lt;code&gt;git diff&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git diff&lt;/code&gt; 와 같은 작업에 병렬 인덱스 프리로드 사용</target>
        </trans-unit>
        <trans-unit id="1aa8a755e195170094ad7c0108b7874b637b96b6" translate="yes" xml:space="preserve">
          <source>Enable showing size of blobs (ordinary files) in a &quot;tree&quot; view, in a separate column, similar to what &lt;code&gt;ls -l&lt;/code&gt; does; see description of &lt;code&gt;-l&lt;/code&gt; option in &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree[1]&lt;/a&gt; manpage. This costs a bit of I/O. Enabled by default.</source>
          <target state="translated">&lt;code&gt;ls -l&lt;/code&gt; 의 기능 과 유사한 별도의 열에서 &quot;트리&quot;보기에서 Blob (일반 파일)의 크기를 표시 할 수 있습니다. &lt;a href=&quot;git-ls-tree&quot;&gt;git-ls-tree [1]&lt;/a&gt; 맨 페이지 의 &lt;code&gt;-l&lt;/code&gt; 옵션에 대한 설명을 참조하십시오 . 이것은 약간의 I / O 비용이 듭니다. 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="72fa50bb7bb0362a9a5efa2aa6f34941c4906089" translate="yes" xml:space="preserve">
          <source>Enable stricter reference checking by requiring an exact ref path. Aside from returning an error code of 1, it will also print an error message if &lt;code&gt;--quiet&lt;/code&gt; was not specified.</source>
          <target state="translated">정확한 참조 경로를 요구하여보다 엄격한 참조 확인이 가능합니다. &lt;code&gt;--quiet&lt;/code&gt; 이 지정되지 않은 경우 오류 코드 1을 반환하는 것 외에도 오류 메시지를 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="48730f76cba5f67862630837d3f93d8ce9288066" translate="yes" xml:space="preserve">
          <source>Enable text search, which will list the commits which match author, committer or commit text to a given string; see the description of &lt;code&gt;--author&lt;/code&gt;, &lt;code&gt;--committer&lt;/code&gt; and &lt;code&gt;--grep&lt;/code&gt; options in &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt; manpage. Enabled by default.</source>
          <target state="translated">텍스트 검색을 사용하면 지정된 문자열에 작성자, 커미터 또는 커밋 텍스트와 일치하는 커밋이 나열됩니다. 의 설명 참조 &lt;code&gt;--author&lt;/code&gt; , &lt;code&gt;--committer&lt;/code&gt; 및 &lt;code&gt;--grep&lt;/code&gt; 의 옵션 &lt;a href=&quot;git-log&quot;&gt;자식 로그 [1]&lt;/a&gt; 맨있다. 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bf942f17a0adbd66d5dff03794ede7ed6ce3a03" translate="yes" xml:space="preserve">
          <source>Enable the &quot;blame&quot; and &quot;blame_incremental&quot; blob views, showing for each line the last commit that modified it; see &lt;a href=&quot;git-blame&quot;&gt;git-blame[1]&lt;/a&gt;. This can be very CPU-intensive and is therefore disabled by default.</source>
          <target state="translated">&quot;blame&quot;및 &quot;blame_incremental&quot;Blob보기를 활성화하여 각 행에 대해이를 수정 한 마지막 커밋을 표시하십시오. 참조 &lt;a href=&quot;git-blame&quot;&gt;자식 비난 [1]가&lt;/a&gt; . 이는 CPU를 많이 사용하므로 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7fc03efc211d064bf3be01f125339a0be59fcba" translate="yes" xml:space="preserve">
          <source>Enable the &lt;code&gt;core.sparseCheckout&lt;/code&gt; setting. If the sparse-checkout file does not exist, then populate it with patterns that match every file in the root directory and no other directories, then will remove all directories tracked by Git. Add patterns to the sparse-checkout file to repopulate the working directory.</source>
          <target state="translated">&lt;code&gt;core.sparseCheckout&lt;/code&gt; 설정을 사용하십시오 . 스파 스 체크 아웃 파일이 없으면 루트 디렉토리의 모든 파일과 일치하고 다른 디렉토리는없는 패턴으로 파일을 채우면 Git에서 추적 한 모든 디렉토리가 제거됩니다. 스파 스 체크 아웃 파일에 패턴을 추가하여 작업 디렉토리를 다시 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="388296e4f7d314018094f8c18fc5c6de39a494b4" translate="yes" xml:space="preserve">
          <source>Enable the heuristic that shifts diff hunk boundaries to make patches easier to read. This is the default.</source>
          <target state="translated">패치를 쉽게 읽을 수 있도록 diff hunk 경계를 이동시키는 휴리스틱을 활성화합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="01f1f887420f77509dbb30a6ca88007ca92eded6" translate="yes" xml:space="preserve">
          <source>Enable the reflog. Updates to a ref &amp;lt;ref&amp;gt; is logged to the file &quot;&lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt;&quot;, by appending the new and old SHA-1, the date/time and the reason of the update, but only when the file exists. If this configuration variable is set to &lt;code&gt;true&lt;/code&gt;, missing &quot;&lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt;&quot; file is automatically created for branch heads (i.e. under &lt;code&gt;refs/heads/&lt;/code&gt;), remote refs (i.e. under &lt;code&gt;refs/remotes/&lt;/code&gt;), note refs (i.e. under &lt;code&gt;refs/notes/&lt;/code&gt;), and the symbolic ref &lt;code&gt;HEAD&lt;/code&gt;. If it is set to &lt;code&gt;always&lt;/code&gt;, then a missing reflog is automatically created for any ref under &lt;code&gt;refs/&lt;/code&gt;.</source>
          <target state="translated">reflog를 활성화하십시오. ref &amp;lt;ref&amp;gt; 에 대한 업데이트는 파일이 존재하는 경우에만 새 SHAD, 기존 SHA-1, 날짜 / 시간 및 업데이트 이유를 추가하여 &quot; &lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt; &quot;파일에 기록됩니다. . 이 구성 변수로 설정되어있는 경우 &lt;code&gt;true&lt;/code&gt; , 실종 &quot; &lt;code&gt;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&lt;/code&gt; &quot;파일이 자동으로 지점 헤드 생성됩니다 (예에서 &lt;code&gt;refs/heads/&lt;/code&gt; ), 원격 심판 (즉, 아래의 &lt;code&gt;refs/remotes/&lt;/code&gt; ), 노트 심판 ( 즉 &lt;code&gt;refs/notes/&lt;/code&gt; ) 및 refs &lt;code&gt;HEAD&lt;/code&gt; 기호 아래에 있습니다. &lt;code&gt;always&lt;/code&gt; 로 설정된 경우 &lt;code&gt;refs/&lt;/code&gt; 아래의 모든 ref에 대해 누락 된 reflog가 자동으로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="b50a25e099857665aa0b9ce95777350330756bcc" translate="yes" xml:space="preserve">
          <source>Enable the so called pickaxe search, which will list the commits that introduced or removed a given string in a file. This can be practical and quite faster alternative to &quot;blame&quot; action, but it is still potentially CPU-intensive. Enabled by default.</source>
          <target state="translated">소위 pickaxe 검색을 사용하면 파일에서 지정된 문자열을 도입하거나 제거한 커밋이 나열됩니다. 이것은 &quot;비난&quot;행동에 대한 실용적이고 매우 빠른 대안 일 수 있지만 여전히 CPU를 많이 사용합니다. 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8928096a1d83fe75290fee4b17a3faa5d2c2864" translate="yes" xml:space="preserve">
          <source>Enable the specified feature. This requires that fast-import supports the specified feature, and aborts if it does not.</source>
          <target state="translated">지정된 기능을 활성화하십시오. 이를 위해서는 빠른 가져 오기 기능이 지정된 기능을 지원해야하며 그렇지 않으면 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="cb33ed4fbb60981dda9e34bad99e8fe5205271b1" translate="yes" xml:space="preserve">
          <source>Enable/disable the service site-wide per default. Note that a service disabled site-wide can still be enabled per repository if it is marked overridable and the repository enables the service with a configuration item.</source>
          <target state="translated">기본적으로 사이트 전체에서 서비스를 활성화 / 비활성화합니다. 사이트 전체에서 비활성화 된 서비스는 재정의 가능으로 표시되고 리포지토리가 구성 항목으로 서비스를 활성화하는 경우 리포지토리 당 여전히 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35a563959614f6c71c72cc0395ec6a9ebde3235d" translate="yes" xml:space="preserve">
          <source>Enables (or disables) progress messages displayed by the transport helper during a command.</source>
          <target state="translated">명령 중에 전송 도우미가 표시하는 진행 메시지를 활성화 (또는 비활성화)합니다.</target>
        </trans-unit>
        <trans-unit id="c889da55fe7b392cff2ceaa7f38c976ee6969838" translate="yes" xml:space="preserve">
          <source>Enables a curl full trace dump of all incoming and outgoing data, including descriptive information, of the git transport protocol. This is similar to doing curl &lt;code&gt;--trace-ascii&lt;/code&gt; on the command line. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">설명 정보를 포함하여 git 전송 프로토콜의 모든 수신 및 발신 데이터에 대한 curl 전체 추적 덤프를 사용합니다. 이것은 명령 줄에서 curl &lt;code&gt;--trace-ascii&lt;/code&gt; 를 수행하는 것과 유사합니다 . 보다 &lt;code&gt;GIT_TRACE&lt;/code&gt; 사용 가능한 추적 출력 옵션 GIT_TRACE 를 .</target>
        </trans-unit>
        <trans-unit id="55ef71c7bfb2fa4d7687d0c6a055c6d9acec70dd" translate="yes" xml:space="preserve">
          <source>Enables a curl full trace dump of all incoming and outgoing data, including descriptive information, of the git transport protocol. This is similar to doing curl &lt;code&gt;--trace-ascii&lt;/code&gt; on the command line. This option overrides setting the &lt;code&gt;GIT_CURL_VERBOSE&lt;/code&gt; environment variable. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">설명 정보를 포함하여 git 전송 프로토콜의 모든 수신 및 발신 데이터에 대한 컬 전체 추적 덤프를 사용합니다. 이것은 명령 행에서 curl &lt;code&gt;--trace-ascii&lt;/code&gt; 를 수행하는 것과 유사합니다 . 이 옵션은 &lt;code&gt;GIT_CURL_VERBOSE&lt;/code&gt; 환경 변수 설정을 대체합니다 . 사용 가능한 추적 출력 옵션 은 &lt;code&gt;GIT_TRACE&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6691f775d187ea6f64d054b6823e9e86f9c085bf" translate="yes" xml:space="preserve">
          <source>Enables general trace messages, e.g. alias expansion, built-in command execution and external command execution.</source>
          <target state="translated">별명 확장, 내장 명령 실행 및 외부 명령 실행과 같은 일반 추적 메시지를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e48905b14288617c8ceaa87834665d923c04c051" translate="yes" xml:space="preserve">
          <source>Enables more detailed trace messages from the &quot;trace2&quot; library. Output from &lt;code&gt;GIT_TRACE2&lt;/code&gt; is a simple text-based format for human readability.</source>
          <target state="translated">&quot;trace2&quot;라이브러리에서보다 자세한 추적 메시지를 사용합니다. &lt;code&gt;GIT_TRACE2&lt;/code&gt; 의 출력은 사람이 읽을 수있는 간단한 텍스트 기반 형식입니다.</target>
        </trans-unit>
        <trans-unit id="660988c86be3da054f2d2df3321eefbdd55b0999" translate="yes" xml:space="preserve">
          <source>Enables performance related trace messages, e.g. total execution time of each Git command. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">각 Git 명령의 총 실행 시간과 같은 성능 관련 추적 메시지를 활성화합니다. 사용 가능한 추적 출력 옵션 은 &lt;code&gt;GIT_TRACE&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc7b8ed816ac9633bd1375cea1e49bf11b8f4cfe" translate="yes" xml:space="preserve">
          <source>Enables the &quot;cone mode&quot; of the sparse checkout feature. When the sparse-checkout file contains a limited set of patterns, then this mode provides significant performance advantages. See &lt;a href=&quot;git-sparse-checkout&quot;&gt;git-sparse-checkout[1]&lt;/a&gt; for more information.</source>
          <target state="translated">스파 스 체크 아웃 기능의 &quot;콘 모드&quot;를 활성화합니다. 스파 스 체크 아웃 파일에 제한된 패턴 세트가 포함 된 경우이 모드는 상당한 성능 이점을 제공합니다. 자세한 내용은 &lt;a href=&quot;git-sparse-checkout&quot;&gt;git-sparse-checkout [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="69a28feccce4c72bcadfb900d39f7f184847d39a" translate="yes" xml:space="preserve">
          <source>Enables trace messages for all accesses to any packs. For each access, the pack file name and an offset in the pack is recorded. This may be helpful for troubleshooting some pack-related performance problems. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">모든 팩에 대한 모든 액세스에 대한 추적 메시지를 사용합니다. 액세스 할 때마다 팩 파일 이름과 팩의 오프셋이 기록됩니다. 이는 팩 관련 성능 문제를 해결하는 데 도움이 될 수 있습니다. 사용 가능한 추적 출력 옵션 은 &lt;code&gt;GIT_TRACE&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="facc11ad57d6672e51f919b154eb028564e3944e" translate="yes" xml:space="preserve">
          <source>Enables trace messages for all packets coming in or out of a given program. This can help with debugging object negotiation or other protocol issues. Tracing is turned off at a packet starting with &quot;PACK&quot; (but see &lt;code&gt;GIT_TRACE_PACKFILE&lt;/code&gt; below). See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">주어진 프로그램에서 들어 오거나 나가는 모든 패킷에 대해 추적 메시지를 활성화합니다. 이를 통해 개체 협상 또는 기타 프로토콜 문제를 디버깅 할 수 있습니다. &quot;PACK&quot;으로 시작하는 패킷에서 추적이 해제됩니다 (하지만 아래의 &lt;code&gt;GIT_TRACE_PACKFILE&lt;/code&gt; 참조). 사용 가능한 추적 출력 옵션 은 &lt;code&gt;GIT_TRACE&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="edb9b39606e0f9447b27a5131ddede4062e0f50d" translate="yes" xml:space="preserve">
          <source>Enables trace messages for operations on the ref database. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">ref 데이터베이스에서 작업에 대한 추적 메시지를 활성화합니다. 사용 가능한 추적 출력 옵션 은 &lt;code&gt;GIT_TRACE&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a96e0b90f936140e14c4f59157281584502b280" translate="yes" xml:space="preserve">
          <source>Enables trace messages for the filesystem monitor extension. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">파일 시스템 모니터 확장에 대한 추적 메시지를 사용 가능하게합니다. 사용 가능한 추적 출력 옵션 은 &lt;code&gt;GIT_TRACE&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="226b098ac2b03df2efedb4d6f3177d8a53d1323d" translate="yes" xml:space="preserve">
          <source>Enables trace messages printing the .git, working tree and current working directory after Git has completed its setup phase. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">Git이 설정 단계를 완료 한 후 .git, 작업 트리 및 현재 작업 디렉토리를 인쇄하는 추적 메시지를 활성화합니다. 사용 가능한 추적 출력 옵션 은 &lt;code&gt;GIT_TRACE&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0876ec8b14060e46110f6e776b65e26631e1613f" translate="yes" xml:space="preserve">
          <source>Enables trace messages that can help debugging fetching / cloning of shallow repositories. See &lt;code&gt;GIT_TRACE&lt;/code&gt; for available trace output options.</source>
          <target state="translated">얕은 리포지토리의 페칭 / 복제 디버깅에 도움이되는 추적 메시지를 활성화합니다. 사용 가능한 추적 출력 옵션 은 &lt;code&gt;GIT_TRACE&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9d84b12f1c34508f5365e4fa51faae6983f4d76" translate="yes" xml:space="preserve">
          <source>Enables tracing of packfiles sent or received by a given program. Unlike other trace output, this trace is verbatim: no headers, and no quoting of binary data. You almost certainly want to direct into a file (e.g., &lt;code&gt;GIT_TRACE_PACKFILE=/tmp/my.pack&lt;/code&gt;) rather than displaying it on the terminal or mixing it with other trace output.</source>
          <target state="translated">지정된 프로그램에서 보내거나받은 팩 파일을 추적 할 수 있습니다. 다른 추적 출력과 달리이 추적은 그대로 사용됩니다. 헤더가없고 이진 데이터를 인용하지 않습니다. 터미널에 표시하거나 다른 추적 출력과 혼합하지 않고 파일 (예 : &lt;code&gt;GIT_TRACE_PACKFILE=/tmp/my.pack&lt;/code&gt; ) 로 직접 전달하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="e7a1430764d62a995667824305a6bb53b99cb2fa" translate="yes" xml:space="preserve">
          <source>Enabling a Target</source>
          <target state="translated">대상 활성화</target>
        </trans-unit>
        <trans-unit id="619b6ac53993b275b163fbd1d47132e1851812f0" translate="yes" xml:space="preserve">
          <source>Encode email headers that have non-ASCII characters with &quot;Q-encoding&quot; (described in RFC 2047) for email transmission. Defaults to true.</source>
          <target state="translated">이메일 전송을 위해 &quot;Q 인코딩&quot;(RFC 2047에 설명 됨)을 사용하여 비 ASCII 문자가있는 이메일 헤더를 인코딩합니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="aae00f8479c80f28e526371cda478b9f2e76f78a" translate="yes" xml:space="preserve">
          <source>Encode email headers that have non-ASCII characters with &quot;Q-encoding&quot; (described in RFC 2047), instead of outputting the headers verbatim. Defaults to the value of the &lt;code&gt;format.encodeEmailHeaders&lt;/code&gt; configuration variable.</source>
          <target state="translated">헤더를 그대로 출력하는 대신 &quot;Q 인코딩&quot;(RFC 2047에 설명 됨)을 사용하여 비 ASCII 문자가있는 이메일 헤더를 인코딩합니다. 기본값은 &lt;code&gt;format.encodeEmailHeaders&lt;/code&gt; 구성 변수 .</target>
        </trans-unit>
        <trans-unit id="3ff218bfdfe647deb6f8afd9e1fb8602500fad3a" translate="yes" xml:space="preserve">
          <source>Encoding to use when displaying logs. (See &lt;code&gt;Discussion&lt;/code&gt; above.) Defaults to the value of &lt;code&gt;i18n.commitEncoding&lt;/code&gt; if set, and UTF-8 otherwise.</source>
          <target state="translated">로그를 표시 할 때 사용할 인코딩입니다. (참고 &lt;code&gt;Discussion&lt;/code&gt; 상술.)의 값이 기본값 &lt;code&gt;i18n.commitEncoding&lt;/code&gt; 설정 한 경우와 UTF-8 그렇지.</target>
        </trans-unit>
        <trans-unit id="89269a8275f94980b4ffe877e221e0d466987782" translate="yes" xml:space="preserve">
          <source>End-of-line conversion</source>
          <target state="translated">라인 끝 변환</target>
        </trans-unit>
        <trans-unit id="ab7c0d7ed2b514b7971808ab6a9cdbd8fa7e7be5" translate="yes" xml:space="preserve">
          <source>Enhanced option parser</source>
          <target state="translated">향상된 옵션 파서</target>
        </trans-unit>
        <trans-unit id="d48b2fd91c06d512d371b7025cd11deeb23b34ad" translate="yes" xml:space="preserve">
          <source>Ensure at least &amp;lt;n&amp;gt; lines of surrounding context match before and after each change. When fewer lines of surrounding context exist they all must match. By default no context is ever ignored.</source>
          <target state="translated">각 변경 전후에 최소한 &amp;lt;n&amp;gt; 개의 주변 컨텍스트 행이 일치하는지 확인하십시오. 더 적은 줄의 주변 컨텍스트가 존재하면 모두 일치해야합니다. 기본적으로 컨텍스트는 무시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40fd8773c6f206a9063f0067c04f352f2f44d8bc" translate="yes" xml:space="preserve">
          <source>Ensure at least &amp;lt;n&amp;gt; lines of surrounding context match before and after each change. When fewer lines of surrounding context exist they all must match. By default no context is ever ignored. Implies --apply.</source>
          <target state="translated">각 변경 전후에 적어도 &amp;lt;n&amp;gt; 줄의 주변 컨텍스트가 일치하는지 확인합니다. 주변 컨텍스트의 줄이 더 적 으면 모두 일치해야합니다. 기본적으로 컨텍스트는 무시되지 않습니다. -적용을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6825ec27b2b654ed999d31628f8e31396467a23b" translate="yes" xml:space="preserve">
          <source>Ensure mod_cgi, mod_alias, and mod_env are enabled, set GIT_PROJECT_ROOT (or DocumentRoot) appropriately, and create a ScriptAlias to the CGI:</source>
          <target state="translated">mod_cgi, mod_alias 및 mod_env가 사용 가능한지 확인하고 GIT_PROJECT_ROOT (또는 DocumentRoot)를 적절하게 설정하고 CGI에 ScriptAlias를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="136727d71b4774df6f61241cd1f96329e996c416" translate="yes" xml:space="preserve">
          <source>Ensure that &lt;code&gt;mod_cgi&lt;/code&gt;, &lt;code&gt;mod_alias&lt;/code&gt;, &lt;code&gt;mod_auth&lt;/code&gt;, &lt;code&gt;mod_setenv&lt;/code&gt; are loaded, then set &lt;code&gt;GIT_PROJECT_ROOT&lt;/code&gt; appropriately and redirect all requests to the CGI:</source>
          <target state="translated">그 확인 &lt;code&gt;mod_cgi&lt;/code&gt; 를 , &lt;code&gt;mod_alias&lt;/code&gt; 가 , &lt;code&gt;mod_auth&lt;/code&gt; 가 , &lt;code&gt;mod_setenv&lt;/code&gt; 로드, 다음 설정 &lt;code&gt;GIT_PROJECT_ROOT&lt;/code&gt; 적절를하고 CGI에 대한 모든 요청을 리디렉션 :</target>
        </trans-unit>
        <trans-unit id="05b99bf62f144f697a8ee2786cac4dbb9ea1f0fb" translate="yes" xml:space="preserve">
          <source>Ensures that a reference name is well formed</source>
          <target state="translated">참조 이름이 잘 구성되어 있는지 확인</target>
        </trans-unit>
        <trans-unit id="ced8b1d7750a47c0481b135a1b95578c79b545a4" translate="yes" xml:space="preserve">
          <source>Ensuring good performance</source>
          <target state="translated">좋은 성능 보장</target>
        </trans-unit>
        <trans-unit id="bbdd824923a22a7ee366da56344be9b791387ca5" translate="yes" xml:space="preserve">
          <source>Ensuring reliability</source>
          <target state="translated">신뢰성 확보</target>
        </trans-unit>
        <trans-unit id="35254b488f033ee2fce6cea7c360bd0f51157448" translate="yes" xml:space="preserve">
          <source>Enter &lt;code&gt;git name-rev&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;git name-rev&lt;/code&gt; 를 입력하십시오 :</target>
        </trans-unit>
        <trans-unit id="35cd2b0a8df7f89252ec5f994efe80c34ae3bb81" translate="yes" xml:space="preserve">
          <source>Entries that begin with &lt;code&gt;&quot;&lt;/code&gt; (double-quote) will be interpreted as C-style quoted paths, removing leading and trailing double-quotes and respecting backslash escapes. E.g., the value &lt;code&gt;&quot;path-with-\&quot;-and-:-in-it&quot;:vanilla-path&lt;/code&gt; has two paths: &lt;code&gt;path-with-&quot;-and-:-in-it&lt;/code&gt; and &lt;code&gt;vanilla-path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;&lt;/code&gt; (큰 따옴표)로 시작하는 항목은 C 스타일 인용 경로로 해석되어 선행 및 후행 큰 따옴표를 제거하고 백 슬래시 이스케이프를 존중합니다 (예 : &lt;code&gt;&quot;path-with-\&quot;-and-:-in-it&quot;:vanilla-path&lt;/code&gt; with- \ &quot;-and-:-in- it :: vanilla-path 에는 path-with- &quot;-and &lt;code&gt;path-with-&quot;-and-:-in-it&lt;/code&gt; 및 &lt;code&gt;vanilla-path&lt;/code&gt; 의 두 경로가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="8403ba2a4a5aa9baffc30d3d46a39f555141e42f" translate="yes" xml:space="preserve">
          <source>Environment and configuration variables</source>
          <target state="translated">환경 및 구성 변수</target>
        </trans-unit>
        <trans-unit id="1173b2e11bd16e5dc36c119a4b84f02be11626b5" translate="yes" xml:space="preserve">
          <source>Environment variables</source>
          <target state="translated">환경 변수</target>
        </trans-unit>
        <trans-unit id="2e9c1d645028b692809462da156b1ceab497759c" translate="yes" xml:space="preserve">
          <source>Environment variables passed to command</source>
          <target state="translated">명령에 전달 된 환경 변수</target>
        </trans-unit>
        <trans-unit id="0939f663868ba2e69e812a3d630f787f9c5cfc8e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt;, with &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1 if not given.</source>
          <target state="translated">당량 &lt;code&gt;&amp;lt;rev&amp;gt;^&amp;lt;n&amp;gt;..&amp;lt;rev&amp;gt;&lt;/code&gt; 과 &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; = 1 지정되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="0c3185db11169cc7a29ed7dd80f79aa18ce0f759" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;--word-diff=color&lt;/code&gt; plus (if a regex was specified) &lt;code&gt;--word-diff-regex=&amp;lt;regex&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">당량 &lt;code&gt;--word-diff=color&lt;/code&gt; (정규식 지정된 경우) 플러스 &lt;code&gt;--word-diff-regex=&amp;lt;regex&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fce804cbafec5e50fdfe3953fee8d48f776185de" translate="yes" xml:space="preserve">
          <source>Equivalent to passing &lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt;. Note that &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; does not need to be the exact branch point of the branches. Example: after rebasing a branch &lt;code&gt;my-topic&lt;/code&gt;, &lt;code&gt;git range-diff my-topic@{u} my-topic@{1} my-topic&lt;/code&gt; would show the differences introduced by the rebase.</source>
          <target state="translated">&lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;base&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt; 를 전달하는 것과 같습니다 . 하는 것으로는 &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; 지점의 정확한 분기점이 될 필요가 없습니다. 예 : 분기 리베이스 후 &lt;code&gt;my-topic&lt;/code&gt; , &lt;code&gt;git range-diff my-topic@{u} my-topic@{1} my-topic&lt;/code&gt; REBASE에 의해 도입 된 차이를 보여주는 것이다.</target>
        </trans-unit>
        <trans-unit id="fee223c131ae45dd7f0054cc61edf8587521b104" translate="yes" xml:space="preserve">
          <source>Equivalent to passing &lt;code&gt;&amp;lt;rev2&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;rev1&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;rev2&amp;gt;..&amp;lt;rev1&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;rev1&amp;gt;..&amp;lt;rev2&amp;gt;&lt;/code&gt; 를 전달하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d9b3a0b879a412ed7b377d180ca1727a3b8f2d6d" translate="yes" xml:space="preserve">
          <source>Error out if the stream ends without a &lt;code&gt;done&lt;/code&gt; command. Without this feature, errors causing the frontend to end abruptly at a convenient point in the stream can go undetected. This may occur, for example, if an import front end dies in mid-operation without emitting SIGTERM or SIGKILL at its subordinate git fast-import instance.</source>
          <target state="translated">&lt;code&gt;done&lt;/code&gt; 명령 없이 스트림이 종료되면 오류가 발생합니다 . 이 기능이 없으면 스트림의 편리한 지점에서 프런트 엔드가 갑자기 종료되는 오류가 감지되지 않을 수 있습니다. 예를 들어 가져 오기 프런트 엔드가 하위 git fast-import 인스턴스에서 SIGTERM 또는 SIGKILL을 방출하지 않고 작동 중일 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="137e434092ea32c83e7a34f0c9bc0aa62d172e84" translate="yes" xml:space="preserve">
          <source>Especially useful for interoperability with a foreign versioning system.</source>
          <target state="translated">외부 버전 관리 시스템과의 상호 운용성에 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="058d99599bd9d3348c2826266e98651571ad20e7" translate="yes" xml:space="preserve">
          <source>Evaluates an arbitrary shell command in each checked out submodule. The command has access to the variables $name, $sm_path, $displaypath, $sha1 and $toplevel: $name is the name of the relevant submodule section in &lt;code&gt;.gitmodules&lt;/code&gt;, $sm_path is the path of the submodule as recorded in the immediate superproject, $displaypath contains the relative path from the current working directory to the submodules root directory, $sha1 is the commit as recorded in the immediate superproject, and $toplevel is the absolute path to the top-level of the immediate superproject. Note that to avoid conflicts with &lt;code&gt;$PATH&lt;/code&gt; on Windows, the &lt;code&gt;$path&lt;/code&gt; variable is now a deprecated synonym of &lt;code&gt;$sm_path&lt;/code&gt; variable. Any submodules defined in the superproject but not checked out are ignored by this command. Unless given &lt;code&gt;--quiet&lt;/code&gt;, foreach prints the name of each submodule before evaluating the command. If &lt;code&gt;--recursive&lt;/code&gt; is given, submodules are traversed recursively (i.e. the given shell command is evaluated in nested submodules as well). A non-zero return from the command in any submodule causes the processing to terminate. This can be overridden by adding &lt;code&gt;|| :&lt;/code&gt; to the end of the command.</source>
          <target state="translated">체크 아웃 된 각 서브 모듈에서 임의의 쉘 명령을 평가합니다. 이 명령은 변수 $ 이름에 액세스 할 수 있습니다, $ sm_path, $ displaypath, $ SHA1 및 $ 최상위 : $ 이름의 관련 서브 모듈 섹션의 이름입니다 &lt;code&gt;.gitmodules&lt;/code&gt; 은 즉시 superproject에 기록 된대로, $ sm_path는 서브 모듈의 경로입니다 $ displaypath는 현재 작업 디렉토리에서 하위 모듈 루트 디렉토리까지의 상대 경로를 포함하고 $ sha1은 즉각적인 수퍼 프로젝트에 기록 된 커밋이고 $ toplevel은 즉각적인 수퍼 프로젝트의 최상위 수준에 대한 절대 경로입니다. Windows에서 &lt;code&gt;$PATH&lt;/code&gt; 와의 충돌을 피하기 위해 &lt;code&gt;$path&lt;/code&gt; 변수는 이제 더 이상 사용되지 않는 &lt;code&gt;$sm_path&lt;/code&gt; 동의어입니다.변하기 쉬운. 수퍼 프로젝트에 정의되었지만 체크 아웃되지 않은 하위 모듈은이 명령에서 무시됩니다. &lt;code&gt;--quiet&lt;/code&gt; 이 지정되지 않으면 foreach는 명령을 평가하기 전에 각 하위 모듈의 이름을 인쇄합니다. 경우 &lt;code&gt;--recursive&lt;/code&gt; 이 주어집니다, 서브 모듈 (즉 주어진 쉘 명령이 아니라 중첩 된 서브 모듈의 평가) 재귀 적으로 이송됩니다. 서브 모듈의 명령에서 0이 아닌 리턴은 처리를 종료시킵니다. 이것은 &lt;code&gt;|| :&lt;/code&gt; 를 추가하여 무시할 수 있습니다. : 명령 끝.</target>
        </trans-unit>
        <trans-unit id="3346640c72369c22dbe8ece1ce186df75f62b7da" translate="yes" xml:space="preserve">
          <source>Even if you don&amp;rsquo;t need to edit files but only want to e.g. rename or remove some and thus can avoid checking out each file (i.e. you can use --index-filter), you still are passing shell snippets for your filters. This means that for every commit, you have to have a prepared git repo where those filters can be run. That&amp;rsquo;s a significant setup.</source>
          <target state="translated">파일을 편집 할 필요는 없지만 예를 들어 이름을 바꾸거나 일부만 제거하여 각 파일의 체크 아웃을 피할 수있는 경우에도 (예 : --index-filter를 사용할 수 있음) 필터에 대한 쉘 스 니펫을 계속 전달합니다. 이것은 모든 커밋마다 해당 필터를 실행할 수있는 준비된 git repo가 ​​있어야 함을 의미합니다. 중요한 설정입니다.</target>
        </trans-unit>
        <trans-unit id="5eb6ad0af0ebc64a82d836be8d647670a50936f8" translate="yes" xml:space="preserve">
          <source>Even if you hide refs, a client may still be able to steal the target objects via the techniques described in the &quot;SECURITY&quot; section of the &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces[7]&lt;/a&gt; man page; it&amp;rsquo;s best to keep private data in a separate repository.</source>
          <target state="translated">참조를 숨겨도 클라이언트는 &lt;a href=&quot;gitnamespaces&quot;&gt;gitnamespaces [7]&lt;/a&gt; 매뉴얼 페이지 의 &quot;보안&quot;섹션에 설명 된 기술을 통해 대상 객체를 훔칠 수 있습니다 . 개인 데이터를 별도의 저장소에 보관하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="631b3a432b8ec594fabc393b96af10483ed3b9bf" translate="yes" xml:space="preserve">
          <source>Even if you may have local modifications in your working tree, you can safely say &lt;code&gt;git pull&lt;/code&gt; when you know that the change in the other branch does not overlap with them.</source>
          <target state="translated">작업 트리에 로컬 수정이 있더라도 다른 분기의 변경 사항이 해당 변경 사항과 겹치지 않는다는 것을 알면 &lt;code&gt;git pull&lt;/code&gt; 을 안전하게 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9dc426299074d12c83589e674bb08692f265116" translate="yes" xml:space="preserve">
          <source>Even when version sort is used in &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt;, tagnames with the same base version but different suffixes are still sorted lexicographically, resulting e.g. in prerelease tags appearing after the main release (e.g. &quot;1.0-rc1&quot; after &quot;1.0&quot;). This variable can be specified to determine the sorting order of tags with different suffixes.</source>
          <target state="translated">버전 정렬이 &lt;a href=&quot;git-tag&quot;&gt;git-tag [1]&lt;/a&gt; 에서 사용되는 경우에도 기본 버전은 동일하지만 접미사가 다른 태그 이름은 사전 식으로 정렬되어 주 릴리스 이후에 시험판 태그가 표시됩니다 (예 : &quot;1.0&quot;후 &quot;1.0-rc1&quot;). . 이 변수를 지정하여 접미사가 다른 태그의 정렬 순서를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e079d1f744d65307fba536fb55c673ed5690ed3" translate="yes" xml:space="preserve">
          <source>Event-Specific Key/Value Pairs</source>
          <target state="translated">이벤트 별 키 / 값 쌍</target>
        </trans-unit>
        <trans-unit id="574b5ade849d92dcfbdbf5ca26c3f1b37761f49f" translate="yes" xml:space="preserve">
          <source>Events are written as lines of the form:</source>
          <target state="translated">이벤트는 다음과 같은 형식으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="af0aec79a3d13a4c4b91dbf7a8bc02d48eb692d6" translate="yes" xml:space="preserve">
          <source>Eventually the conclusion started with:</source>
          <target state="translated">결국 결론은 다음과 같이 시작되었습니다.</target>
        </trans-unit>
        <trans-unit id="e1529d50cc2b2be76fa87bc3d3169dd428571183" translate="yes" xml:space="preserve">
          <source>Eventually there will be no more revisions left to inspect, and the command will print out a description of the first bad commit. The reference &lt;code&gt;refs/bisect/bad&lt;/code&gt; will be left pointing at that commit.</source>
          <target state="translated">결국 검사 할 개정이 더 이상 없으며 명령은 첫 번째 잘못된 커밋에 대한 설명을 인쇄합니다. 참조 &lt;code&gt;refs/bisect/bad&lt;/code&gt; 는 해당 커밋을 가리키고 있습니다.</target>
        </trans-unit>
        <trans-unit id="33494a61e10c94c6a655dac5cf7ce556eb778f1d" translate="yes" xml:space="preserve">
          <source>Every change in the history of a project is represented by a commit. The &lt;a href=&quot;git-show&quot;&gt;git-show[1]&lt;/a&gt; command shows the most recent commit on the current branch:</source>
          <target state="translated">프로젝트 히스토리의 모든 변경 사항은 커밋으로 표시됩니다. &lt;a href=&quot;git-show&quot;&gt;자식 쇼 [1]&lt;/a&gt; 명령 쇼 가장 최근의 현재 지점에 커밋 :</target>
        </trans-unit>
        <trans-unit id="c0294fb403c28f35bf86f99624f936e70c163f9d" translate="yes" xml:space="preserve">
          <source>Every commit (except the very first commit in a project) also has a parent commit which shows what happened before this commit. Following the chain of parents will eventually take you back to the beginning of the project.</source>
          <target state="translated">모든 커밋 (프로젝트의 첫 번째 커밋 제외)에는이 커밋 전에 발생한 일을 보여주는 부모 커밋도 있습니다. 부모님을 따라 가면 결국 프로젝트의 시작으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="2fd9540af511da41e4e859d7e772df1cd2e0716c" translate="yes" xml:space="preserve">
          <source>Every commit has a 40-hexdigit id, sometimes called the &quot;object name&quot; or the &quot;SHA-1 id&quot;, shown on the first line of the &lt;code&gt;git show&lt;/code&gt; output. You can usually refer to a commit by a shorter name, such as a tag or a branch name, but this longer name can also be useful. Most importantly, it is a globally unique name for this commit: so if you tell somebody else the object name (for example in email), then you are guaranteed that name will refer to the same commit in their repository that it does in yours (assuming their repository has that commit at all). Since the object name is computed as a hash over the contents of the commit, you are guaranteed that the commit can never change without its name also changing.</source>
          <target state="translated">모든 커밋에는 &lt;code&gt;git show&lt;/code&gt; 출력 의 첫 번째 줄에 표시 되는 40 개 16 진수 ID ( &quot;object name&quot;또는 &quot;SHA-1 id&quot;라고도 함)가 있습니다. 일반적으로 태그 또는 분기 이름과 같이 짧은 이름으로 커밋을 참조 할 수 있지만이 긴 이름도 유용 할 수 있습니다. 가장 중요한 것은이 커밋에 대해 전 세계적으로 고유 한 이름입니다. 따라서 다른 사람에게 객체 이름 (예 : 전자 메일)을 알려 주면 리포지토리에서 해당 커밋과 동일한 커밋을 참조하게됩니다 ( 그들의 저장소에 커밋이 있다고 가정). 객체 이름은 커밋 내용에 대한 해시로 계산되므로 커밋 이름도 변경하지 않고는 커밋을 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2c58cc3c4a4eeeefba12cfd52db7d6b22833ae51" translate="yes" xml:space="preserve">
          <source>Every commit usually has one &quot;parent&quot; commit which points to the previous state of the project:</source>
          <target state="translated">모든 커밋에는 일반적으로 프로젝트의 이전 상태를 가리키는 하나의 &quot;부모&quot;커밋이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a873d3296fdc5740fd2d57065300557ff50e9de" translate="yes" xml:space="preserve">
          <source>Every git repository is marked with a numeric version in the &lt;code&gt;core.repositoryformatversion&lt;/code&gt; key of its &lt;code&gt;config&lt;/code&gt; file. This version specifies the rules for operating on the on-disk repository data. An implementation of git which does not understand a particular version advertised by an on-disk repository MUST NOT operate on that repository; doing so risks not only producing wrong results, but actually losing data.</source>
          <target state="translated">모든 자식 저장소는 &lt;code&gt;config&lt;/code&gt; 파일 의 &lt;code&gt;core.repositoryformatversion&lt;/code&gt; 키에 숫자 버전으로 표시 됩니다. 이 버전은 온 디스크 저장소 데이터에서 작동하기위한 규칙을 지정합니다. 온 디스크 저장소에 의해 알려진 특정 버전을 이해하지 못하는 git 구현은 해당 저장소에서 작동해서는 안됩니다. 그렇게하면 잘못된 결과가 발생할뿐만 아니라 실제로 데이터가 손실 될 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="62d7b4b8755b9c58dc64c45f9e43e9a1848ebae6" translate="yes" xml:space="preserve">
          <source>Every helper must support the &quot;capabilities&quot; command, which Git uses to determine what other commands the helper will accept. Those other commands can be used to discover and update remote refs, transport objects between the object database and the remote repository, and update the local object store.</source>
          <target state="translated">모든 도우미는 Git에서 도우미가 수락 할 다른 명령을 결정하는 데 사용하는 &quot;기능&quot;명령을 지원해야합니다. 이러한 다른 명령을 사용하여 원격 참조를 발견 및 업데이트하고, 오브젝트 데이터베이스와 원격 저장소간에 오브젝트를 전송하고, 로컬 오브젝트 저장소를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5adcecab706a9dd84c1d3eebe8cd1a4069a04b5" translate="yes" xml:space="preserve">
          <source>Every non-overlapping match of the &amp;lt;regex&amp;gt; is considered a word. Anything between these matches is considered whitespace and ignored(!) for the purposes of finding differences. You may want to append &lt;code&gt;|[^[:space:]]&lt;/code&gt; to your regular expression to make sure that it matches all non-whitespace characters. A match that contains a newline is silently truncated(!) at the newline.</source>
          <target state="translated">&amp;lt;regex&amp;gt;와 겹치지 않는 모든 일치는 단어로 간주됩니다. 이러한 일치 항목 사이의 모든 항목은 공백으로 간주되며 차이점을 찾기 위해 무시됩니다 (!). 공백이 아닌 모든 문자와 일치하도록 &lt;code&gt;|[^[:space:]]&lt;/code&gt; 를 정규식 에 추가 할 수 있습니다 . 줄 바꿈이 포함 된 일치는 줄 바꿈에서 자동으로 잘립니다 (!).</target>
        </trans-unit>
        <trans-unit id="ca9e8deab33d39332d7b528ab194c9573c58ac97" translate="yes" xml:space="preserve">
          <source>Every notes change creates a new commit at the specified notes ref. You can therefore inspect the history of the notes by invoking, e.g., &lt;code&gt;git log -p notes/commits&lt;/code&gt;. Currently the commit message only records which operation triggered the update, and the commit authorship is determined according to the usual rules (see &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt;). These details may change in the future.</source>
          <target state="translated">모든 노트 변경은 지정된 노트 심판에서 새로운 커밋을 만듭니다. 따라서 &lt;code&gt;git log -p notes/commits&lt;/code&gt; 와 같이 호출하여 노트의 히스토리를 검사 할 수 있습니다 . 현재 커밋 메시지는 업데이트를 트리거 한 작업 만 기록하며 커밋 권한은 일반적인 규칙에 따라 결정됩니다 ( &lt;a href=&quot;git-commit&quot;&gt;git-commit [1] 참조&lt;/a&gt; ). 이러한 세부 사항은 나중에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bfad9a034d5ed29730f0b4fba66efb6b1249b9d" translate="yes" xml:space="preserve">
          <source>Every once in a while have your frontend emit a &lt;code&gt;progress&lt;/code&gt; message to fast-import. The contents of the messages are entirely free-form, so one suggestion would be to output the current month and year each time the current commit date moves into the next month. Your users will feel better knowing how much of the data stream has been processed.</source>
          <target state="translated">가끔씩 프론트 엔드 에서 빠르게 가져 오기 위한 &lt;code&gt;progress&lt;/code&gt; 메시지가 표시됩니다. 메시지 내용은 전적으로 자유 형식이므로 현재 커밋 날짜가 다음 달로 이동할 때마다 현재 월과 연도를 출력하는 것이 좋습니다. 사용자는 처리 된 데이터 스트림의 양을 더 잘 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="cda48ad1074123130b527f02f3f1db8c4fd5c129" translate="yes" xml:space="preserve">
          <source>Every once in a while, &lt;code&gt;git repack&lt;/code&gt; the public repository. Go back to step 5. and continue working.</source>
          <target state="translated">때때로 &lt;code&gt;git repack&lt;/code&gt; 은 공용 저장소를 다시 포장 합니다. 5 단계로 돌아가서 계속 작업하십시오.</target>
        </trans-unit>
        <trans-unit id="0196a37f323e9613bd5e5c6dc6db74a2907c6a83" translate="yes" xml:space="preserve">
          <source>Every time a client connects, first run an external command specified by the &amp;lt;path&amp;gt; with service name (e.g. &quot;upload-pack&quot;), path to the repository, hostname (%H), canonical hostname (%CH), IP address (%IP), and TCP port (%P) as its command-line arguments. The external command can decide to decline the service by exiting with a non-zero status (or to allow it by exiting with a zero status). It can also look at the $REMOTE_ADDR and &lt;code&gt;$REMOTE_PORT&lt;/code&gt; environment variables to learn about the requestor when making this decision.</source>
          <target state="translated">클라이언트가 연결할 때마다 먼저 서비스 이름 (예 : &quot;업로드 팩&quot;), 저장소 경로, 호스트 이름 (% H), 표준 호스트 이름 (% CH), IP 주소 ( % IP) 및 TCP 포트 (% P)를 명령 줄 인수로 사용하십시오. 외부 명령은 0이 아닌 상태로 종료하거나 서비스를 0으로 종료하여 서비스를 거부 할 수 있습니다. 또한 $ REMOTE_ADDR 및 &lt;code&gt;$REMOTE_PORT&lt;/code&gt; 환경 변수를 보고이 결정을 내릴 때 요청자에 대해 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed1e82e85b3b43f7a452c7545f1946734ba8fe78" translate="yes" xml:space="preserve">
          <source>Everyday Git</source>
          <target state="translated">매일 힘내</target>
        </trans-unit>
        <trans-unit id="30edee05f0b86fdef0d1b80bced0b054568a2749" translate="yes" xml:space="preserve">
          <source>Everyday Git With 20 Commands Or So</source>
          <target state="translated">20 가지 정도의 명령으로 매일 Git</target>
        </trans-unit>
        <trans-unit id="0043a64d3fef8a7a23f6cd840b45f8af10f67f75" translate="yes" xml:space="preserve">
          <source>Exact byte count format</source>
          <target state="translated">정확한 바이트 수 형식</target>
        </trans-unit>
        <trans-unit id="6e07117d26445f4c876a2dd689294f11cef857f4" translate="yes" xml:space="preserve">
          <source>Examining an old version without creating a new branch</source>
          <target state="translated">새 브랜치를 만들지 않고 이전 버전 검사</target>
        </trans-unit>
        <trans-unit id="d496fa33f8661db7b0850d74bbd80c109526f113" translate="yes" xml:space="preserve">
          <source>Examining branches from a remote repository</source>
          <target state="translated">원격 저장소에서 분기 검사</target>
        </trans-unit>
        <trans-unit id="bb504595062729729e7244c3229ce860c38e6b76" translate="yes" xml:space="preserve">
          <source>Examining dangling objects</source>
          <target state="translated">매달려있는 객체 검사</target>
        </trans-unit>
        <trans-unit id="9cb0f2fbccfd2e1df3b3fea66d90520dda3d9cf1" translate="yes" xml:space="preserve">
          <source>Examining the data</source>
          <target state="translated">데이터 검사</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="cfd85acb33cc1367c953b61c1f0a7ad60c2565a2" translate="yes" xml:space="preserve">
          <source>Example 1: Your history contains commits by two authors, Jane and Joe, whose names appear in the repository under several forms:</source>
          <target state="translated">예 1 : 기록에는 두 명의 저자 인 Jane과 Joe의 커밋이 포함되어 있으며 이름은 여러 형식으로 저장소에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="aa58f391e50840be9e94b87f72faa5f731cb5766" translate="yes" xml:space="preserve">
          <source>Example 2: Your repository contains commits from the following authors:</source>
          <target state="translated">예 2 : 저장소에 다음 작성자의 커밋이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a76cea78511b0d3032b5011d701b256e4fa824c" translate="yes" xml:space="preserve">
          <source>Example contents:</source>
          <target state="translated">내용 예 :</target>
        </trans-unit>
        <trans-unit id="ee2fa80210fe959342ddb79b523484b1b7a07d33" translate="yes" xml:space="preserve">
          <source>Example to exclude everything except a specific directory &lt;code&gt;foo/bar&lt;/code&gt; (note the &lt;code&gt;/*&lt;/code&gt; - without the slash, the wildcard would also exclude everything within &lt;code&gt;foo/bar&lt;/code&gt;):</source>
          <target state="translated">특정 디렉토리 &lt;code&gt;foo/bar&lt;/code&gt; 를 제외한 모든 것을 제외하는 예제 ( &lt;code&gt;/*&lt;/code&gt; -슬래시없이 와일드 카드는 &lt;code&gt;foo/bar&lt;/code&gt; 내의 모든 것을 제외 합니다 )</target>
        </trans-unit>
        <trans-unit id="59e08af9047abc909e804faec8919301def86320" translate="yes" xml:space="preserve">
          <source>Example trace2 api usage</source>
          <target state="translated">trace2 API 사용법 예</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="523ae6b1873ceced0f776c362dc256ed64902255" translate="yes" xml:space="preserve">
          <source>Example: If you know that there was some test case for &lt;code&gt;git bundle&lt;/code&gt;, but do not remember where it was (yes, you &lt;code&gt;could&lt;/code&gt;&lt;code&gt;git grep bundle t/&lt;/code&gt;, but that does not illustrate the point!):</source>
          <target state="translated">예 : &lt;code&gt;git bundle&lt;/code&gt; 에 대한 테스트 사례가 있지만 그 위치를 기억하지 못하는 경우 (예, &lt;code&gt;git grep bundle t/&lt;/code&gt; 할 &lt;code&gt;could&lt;/code&gt; 있지만 요점을 설명하지는 않습니다!) :</target>
        </trans-unit>
        <trans-unit id="14e4d3109673cecf5094a599bce7b8cb418a458c" translate="yes" xml:space="preserve">
          <source>Example: Let commits &lt;code&gt;1--2&lt;/code&gt; be the first iteration of a patch series and &lt;code&gt;A--C&lt;/code&gt; the second iteration. Let&amp;rsquo;s assume that &lt;code&gt;A&lt;/code&gt; is a cherry-pick of &lt;code&gt;2,&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; is a cherry-pick of &lt;code&gt;1&lt;/code&gt; but with a small modification (say, a fixed typo). Visualize the commits as a bipartite graph:</source>
          <target state="translated">예 : 보자 커밋은 &lt;code&gt;1--2&lt;/code&gt; 패치 시리즈의 첫 번째 반복하고 &lt;code&gt;A--C&lt;/code&gt; 두 번째 반복. 하자가 있다고 가정 &lt;code&gt;A&lt;/code&gt; 는 (A)의 벚꽃이-선택이며 &lt;code&gt;2,&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 는 (A)의 체리 - 선택 인 &lt;code&gt;1&lt;/code&gt; 만 작은 변경 (예를 들어, 고정 오타)와 함께. 커밋을 이분 그래프로 시각화하십시오.</target>
        </trans-unit>
        <trans-unit id="d3bad2d15f343f55dc9f681daca1b6f3326d18b3" translate="yes" xml:space="preserve">
          <source>Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: &lt;code&gt;--dirstat=files,10,cumulative&lt;/code&gt;.</source>
          <target state="translated">예 : 다음은 변경된 파일 수의 10 % 미만인 디렉토리를 무시하고 상위 디렉토리에서 하위 디렉토리 수를 누적하는 동안 변경된 파일 수를 계산합니다. &lt;code&gt;--dirstat=files,10,cumulative&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5998a18b5c87282a79f47b763c8725aa5e8349e" translate="yes" xml:space="preserve">
          <source>Example: The following will count changed files, while ignoring directories with less than 10% of the total amount of changed files, and accumulating child directory counts in the parent directories: &lt;code&gt;files,10,cumulative&lt;/code&gt;.</source>
          <target state="translated">예 : 다음은 변경된 파일 수의 10 % 미만인 디렉토리를 무시하고 상위 디렉토리에서 하위 디렉토리 수를 누적하는 동안 변경된 파일 수를 계산 &lt;code&gt;files,10,cumulative&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7fe9add2c66b1dd7342bec4baea68d566885937" translate="yes" xml:space="preserve">
          <source>Example: let&amp;rsquo;s say I had renamed &lt;code&gt;commit.c&lt;/code&gt; to &lt;code&gt;git-commit.c&lt;/code&gt;, and I had done an &lt;code&gt;update-index&lt;/code&gt; to make that effective in the index file. &lt;code&gt;git diff-files&lt;/code&gt; wouldn&amp;rsquo;t show anything at all, since the index file matches my working directory. But doing a &lt;code&gt;git diff-index&lt;/code&gt; does:</source>
          <target state="translated">예 : &lt;code&gt;commit.c&lt;/code&gt; 의 이름 을 &lt;code&gt;git-commit.c&lt;/code&gt; 로 바꾸고 인덱스 파일에서 효과적으로 &lt;code&gt;update-index&lt;/code&gt; 하기 위해 update-index 를 수행 했다고 가정 해 봅시다 . &lt;code&gt;git diff-files&lt;/code&gt; 는 색인 파일이 내 작업 디렉토리와 일치하므로 아무것도 표시하지 않습니다. 그러나 &lt;code&gt;git diff-index&lt;/code&gt; 를 수행하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="22540b4db15515332cef1b1a56998eebfeba111a" translate="yes" xml:space="preserve">
          <source>Examples for &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;--cc&lt;/code&gt; without &lt;code&gt;--combined-all-paths&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;--combined-all-paths&lt;/code&gt; 가 없는 &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;--cc&lt;/code&gt; 의 예 :</target>
        </trans-unit>
        <trans-unit id="6ba2b2f11f2e1285e022c78a54e28e01334ece54" translate="yes" xml:space="preserve">
          <source>Examples when &lt;code&gt;--combined-all-paths&lt;/code&gt; added to either &lt;code&gt;-c&lt;/code&gt; or &lt;code&gt;--cc&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;--combined-all-paths&lt;/code&gt; 가 &lt;code&gt;-c&lt;/code&gt; 또는 &lt;code&gt;--cc&lt;/code&gt; 에 추가 된 예 :</target>
        </trans-unit>
        <trans-unit id="b280d2c89a83a2bacb63527574e5853bea86f936" translate="yes" xml:space="preserve">
          <source>Examples.</source>
          <target state="translated">Examples.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="24d0d5f830ca936a2b1158c4418847e58a17c132" translate="yes" xml:space="preserve">
          <source>Except for the &lt;code&gt;simple&lt;/code&gt; variant, command-line parameters are likely to change as git gains new features.</source>
          <target state="translated">&lt;code&gt;simple&lt;/code&gt; 변형을 제외하고 git이 새로운 기능을 얻음에 따라 명령 줄 매개 변수가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16cb9d6dc5634fc561d2d614f979976dfee73770" translate="yes" xml:space="preserve">
          <source>Except in a fast-forward merge (see above), the branches to be merged must be tied together by a merge commit that has both of them as its parents.</source>
          <target state="translated">빨리 감기 병합 (위 참조)을 제외하고 병합 할 브랜치는 둘 다 부모로 포함 된 병합 커밋으로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="262c2a4eb81a10a2c9efd3343c2ae85fe92bbd6e" translate="yes" xml:space="preserve">
          <source>Exclude commits that are reachable from &amp;lt;rev&amp;gt; (i.e. &amp;lt;rev&amp;gt; and its ancestors).</source>
          <target state="translated">&amp;lt;rev&amp;gt;에서 도달 할 수있는 커밋을 제외하십시오 (예 : &amp;lt;rev&amp;gt; 및 해당 조상).</target>
        </trans-unit>
        <trans-unit id="f270c263f13543cd4c2b3020f92a691a85883aa7" translate="yes" xml:space="preserve">
          <source>Exclude patterns</source>
          <target state="translated">패턴 제외</target>
        </trans-unit>
        <trans-unit id="87263b3bb52abcdab4a719253ddba1eca4b803f6" translate="yes" xml:space="preserve">
          <source>Exclude selected depot paths when cloning or syncing.</source>
          <target state="translated">복제 또는 동기화시 선택된 저장소 경로를 제외하십시오.</target>
        </trans-unit>
        <trans-unit id="80be5859c8610b0a7e5a0e2227ba09cb8e75bd2e" translate="yes" xml:space="preserve">
          <source>Exclude the given pack from repacking. This is the equivalent of having &lt;code&gt;.keep&lt;/code&gt; file on the pack. &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; is the pack file name without leading directory (e.g. &lt;code&gt;pack-123.pack&lt;/code&gt;). The option could be specified multiple times to keep multiple packs.</source>
          <target state="translated">재 포장에서 지정된 팩을 제외하십시오. 이것은 팩에 &lt;code&gt;.keep&lt;/code&gt; 파일 이있는 것과 같습니다 . &lt;code&gt;&amp;lt;pack-name&amp;gt;&lt;/code&gt; 은 선행 디렉토리가없는 팩 파일 이름입니다 (예 : &lt;code&gt;pack-123.pack&lt;/code&gt; ). 여러 팩을 유지하기 위해 옵션을 여러 번 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c21ad96ce2991b5c76c93826f8c1c709d756ef00" translate="yes" xml:space="preserve">
          <source>Exclude the specified patterns from the log decorations. This is similar to the &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; command-line option, but the config option can be overridden by the &lt;code&gt;--decorate-refs&lt;/code&gt; option.</source>
          <target state="translated">로그 장식에서 지정된 패턴을 제외합니다. 이것은 &lt;code&gt;--decorate-refs-exclude&lt;/code&gt; 명령 줄 옵션과 유사하지만 구성 옵션은 &lt;code&gt;--decorate-refs&lt;/code&gt; 로 재정의 할 수 있습니다. 옵션 .</target>
        </trans-unit>
        <trans-unit id="f719c666cee23f0f1f956fb1a3762ec3484afe81" translate="yes" xml:space="preserve">
          <source>Existing trailers are extracted from the input message by looking for a group of one or more lines that (i) is all trailers, or (ii) contains at least one Git-generated or user-configured trailer and consists of at least 25% trailers. The group must be preceded by one or more empty (or whitespace-only) lines. The group must either be at the end of the message or be the last non-whitespace lines before a line that starts with &lt;code&gt;---&lt;/code&gt; (followed by a space or the end of the line). Such three minus signs start the patch part of the message. See also &lt;code&gt;--no-divider&lt;/code&gt; below.</source>
          <target state="translated">기존 예고편은 (i) 모든 예고편이거나 (ii) 하나 이상의 Git 생성 또는 사용자 구성 예고편을 포함하고 최소 25 % 예고편으로 구성된 하나 이상의 행 그룹을 찾아 입력 메시지에서 추출됩니다. . 그룹 앞에는 하나 이상의 빈 (또는 공백 만있는) 행이 와야합니다. 그룹은 메시지의 끝에 있거나 &lt;code&gt;---&lt;/code&gt; 로 시작하는 줄 (공백 또는 줄 끝) 앞에 공백이 아닌 마지막 줄이어야합니다 . 이러한 세 개의 빼기 부호는 메시지의 패치 부분을 시작합니다. 아래의 &lt;code&gt;--no-divider&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3460174eb1c6ec5b3dd3ca9e87848d068de28a1" translate="yes" xml:space="preserve">
          <source>Exit code between 128 and 255 are special to &quot;git bisect run&quot;. They make it stop immediately the bisection process. This is useful for example if the command passed takes too long to complete, because you can kill it with a signal and it will stop the bisection process.</source>
          <target state="translated">128과 255 사이의 종료 코드는 &quot;git bisect run&quot;에 특별합니다. 그들은 이분법 과정을 즉시 중단시킵니다. 예를 들어, 전달 된 명령을 완료하는 데 너무 오래 걸리면 신호로 명령을 종료하고 이분법 프로세스가 중지되므로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1de8b457f24c5f9f27dc6145c115a0b05b79738e" translate="yes" xml:space="preserve">
          <source>Exit difftool if the invoked diff tool returns a non-zero exit status.</source>
          <target state="translated">호출 된 diff 도구가 0이 아닌 종료 상태를 리턴하면 difftool을 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="105ec316e78b2e21f4200658aebb690c6bfce1c8" translate="yes" xml:space="preserve">
          <source>Exit status</source>
          <target state="translated">종료 상태</target>
        </trans-unit>
        <trans-unit id="3a152e1aa09a1f7c436eafcd44ff191b58dde03b" translate="yes" xml:space="preserve">
          <source>Exit with a zero status even if no files matched.</source>
          <target state="translated">일치하는 파일이없는 경우에도 상태 0으로 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="f661c1461c19e28f4ca3bd981e37f108a510e5f9" translate="yes" xml:space="preserve">
          <source>Exit with status &quot;2&quot; when no matching refs are found in the remote repository. Usually the command exits with status &quot;0&quot; to indicate it successfully talked with the remote repository, whether it found any matching refs.</source>
          <target state="translated">원격 저장소에서 일치하는 참조가 없으면 &quot;2&quot;상태로 종료하십시오. 일반적으로 명령은 상태가 &quot;0&quot;으로 종료되어 일치하는 참조를 찾았는지 여부에 관계없이 원격 저장소와 성공적으로 통신했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a5a799b0a561590f135d49ee5ebae00be685efb3" translate="yes" xml:space="preserve">
          <source>Exit with zero status if &amp;lt;object&amp;gt; exists and is a valid object. If &amp;lt;object&amp;gt; is of an invalid format exit with non-zero and emits an error on stderr.</source>
          <target state="translated">&amp;lt;object&amp;gt;가 존재하고 유효한 오브젝트이면 상태 0으로 종료하십시오. &amp;lt;object&amp;gt;가 유효하지 않은 형식 인 경우 0이 아닌 종료하고 stderr에서 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a4fd2157951095e7b5d26b7c3906810fced8fee9" translate="yes" xml:space="preserve">
          <source>Expand the URL of the given remote repository taking into account any &quot;url.&amp;lt;base&amp;gt;.insteadOf&quot; config setting (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;) and exit without talking to the remote.</source>
          <target state="translated">&quot;url. &amp;lt;base&amp;gt; .insteadOf&quot;구성 설정 ( &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 참조)을 고려하여 지정된 원격 저장소의 URL을 펼치고 원격과 대화하지 않고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="82a1b2399131b1d56f52c1e5725ea0754c8c3b25" translate="yes" xml:space="preserve">
          <source>Experimental. If set, clients will attempt to communicate with a server using the specified protocol version. If unset, no attempt will be made by the client to communicate using a particular protocol version, this results in protocol version 0 being used. Supported versions:</source>
          <target state="translated">실험적. 설정된 경우 클라이언트는 지정된 프로토콜 버전을 사용하여 서버와 통신을 시도합니다. 설정하지 않으면 클라이언트가 특정 프로토콜 버전을 사용하여 통신하려고 시도하지 않으므로 프로토콜 버전 0이 사용됩니다. 지원되는 버전 :</target>
        </trans-unit>
        <trans-unit id="374e58867af910990ca1f09ab8f9576e68a9b14e" translate="yes" xml:space="preserve">
          <source>Experimental; for internal use only. Can attempt to connect to a remote server for communication using git&amp;rsquo;s wire-protocol version 2. See the documentation for the stateless-connect command for more information.</source>
          <target state="translated">실험적; 내부 전용. git의 와이어 프로토콜 버전 2를 사용하여 통신을 위해 원격 서버에 연결을 시도 할 수 있습니다. 자세한 정보는 stateless-connect 명령의 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a6c1ea190613127e3c33180eee19de027a289612" translate="yes" xml:space="preserve">
          <source>Experimental; for internal use only. Connects to the given remote service for communication using git&amp;rsquo;s wire-protocol version 2. Valid replies to this command are empty line (connection established), &lt;code&gt;fallback&lt;/code&gt; (no smart transport support, fall back to dumb transports) and just exiting with error message printed (can&amp;rsquo;t connect, don&amp;rsquo;t bother trying to fall back). After line feed terminating the positive (empty) response, the output of the service starts. Messages (both request and response) must consist of zero or more PKT-LINEs, terminating in a flush packet. Response messages will then have a response end packet after the flush packet to indicate the end of a response. The client must not expect the server to store any state in between request-response pairs. After the connection ends, the remote helper exits.</source>
          <target state="translated">실험적; 내부 전용입니다. git의 wire-protocol 버전 ​​2를 사용하여 통신을 위해 주어진 원격 서비스에 연결합니다.이 명령에 대한 유효한 응답은 빈 줄 (연결 설정 됨), &lt;code&gt;fallback&lt;/code&gt; (스마트 전송 지원 없음, 멍청한 전송으로 ) 및 인쇄 된 오류 메시지와 함께 종료됩니다 ( 연결할 수 없습니다. 폴백을 시도하지 마십시오.) 줄 바꿈이 긍정적 (비어 있음) 응답을 종료 한 후 서비스 출력이 시작됩니다. 메시지 (요청 및 응답 모두)는 0 개 이상의 PKT-LINE으로 구성되어야하며 플러시 패킷으로 종료됩니다. 그러면 응답 메시지는 응답의 끝을 나타내는 플러시 패킷 뒤에 응답 끝 패킷을 갖게됩니다. 클라이언트는 서버가 요청-응답 쌍 사이에 어떤 상태도 저장할 것으로 기 대해서는 안됩니다. 연결이 끝나면 원격 도우미가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="5ed48ec751df29bb5c7b56db740a48bfdffd6f47" translate="yes" xml:space="preserve">
          <source>Experimental; for internal use only. Connects to the given remote service for communication using git&amp;rsquo;s wire-protocol version 2. Valid replies to this command are empty line (connection established), &lt;code&gt;fallback&lt;/code&gt; (no smart transport support, fall back to dumb transports) and just exiting with error message printed (can&amp;rsquo;t connect, don&amp;rsquo;t bother trying to fall back). After line feed terminating the positive (empty) response, the output of the service starts. Messages (both request and response) must consist of zero or more PKT-LINEs, terminating in a flush packet. The client must not expect the server to store any state in between request-response pairs. After the connection ends, the remote helper exits.</source>
          <target state="translated">실험적; 내부 전용. git의 와이어 프로토콜 버전 2를 사용하여 통신을 위해 지정된 원격 서비스에 연결합니다.이 명령에 대한 올바른 응답은 빈 줄 (연결 설정 됨), &lt;code&gt;fallback&lt;/code&gt; (스마트 전송 지원 없음, 벙어리 전송으로 폴백 ) 및 오류 메시지가 인쇄 된 상태로 종료 됨 ( 연결할 수 없습니다. 라인 피드가 양 (빈) 응답을 종료 한 후 서비스 출력이 시작됩니다. 메시지 (요청 및 응답 모두)는 0 개 이상의 PKT-LINE으로 구성되어야하며 플러시 패킷으로 종료됩니다. 클라이언트는 서버가 요청-응답 쌍 사이에 상태를 저장하지 않아야합니다. 연결이 끝나면 원격 헬퍼가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="e024c1b1cf5dfc23f1661897286cc082f5684cef" translate="yes" xml:space="preserve">
          <source>Expire all reflogs with &lt;code&gt;git reflog expire --expire=now --all&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git reflog expire --expire=now --all&lt;/code&gt; 하여 모든 reflog를 만료 --expire = now --all 합니다.</target>
        </trans-unit>
        <trans-unit id="4f38f9dff86033ea204fa903651e0d6603ef28dd" translate="yes" xml:space="preserve">
          <source>Explicitly allow or ban the object filter corresponding to &lt;code&gt;&amp;lt;filter&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;filter&amp;gt;&lt;/code&gt; may be one of: &lt;code&gt;blob:none&lt;/code&gt;, &lt;code&gt;blob:limit&lt;/code&gt;, &lt;code&gt;tree&lt;/code&gt;, &lt;code&gt;sparse:oid&lt;/code&gt;, or &lt;code&gt;combine&lt;/code&gt;. If using combined filters, both &lt;code&gt;combine&lt;/code&gt; and all of the nested filter kinds must be allowed. Defaults to &lt;code&gt;uploadpackfilter.allow&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;filter&amp;gt;&lt;/code&gt; 에 해당하는 객체 필터를 명시 적으로 허용하거나 금지합니다 . 여기서 &lt;code&gt;&amp;lt;filter&amp;gt;&lt;/code&gt; 는 &lt;code&gt;blob:none&lt;/code&gt; , &lt;code&gt;blob:limit&lt;/code&gt; , &lt;code&gt;tree&lt;/code&gt; , &lt;code&gt;sparse:oid&lt;/code&gt; 또는 &lt;code&gt;combine&lt;/code&gt; 중 하나 일 수 있습니다 . 결합 된 필터를 사용하는 경우 &lt;code&gt;combine&lt;/code&gt; 및 모든 중첩 필터 종류가 모두 허용되어야합니다. 기본값은 &lt;code&gt;uploadpackfilter.allow&lt;/code&gt; 입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="ee5da57f58adf9c1ddf8dd03613cf7957a586adf" translate="yes" xml:space="preserve">
          <source>Exploring git history</source>
          <target state="translated">자식 역사 탐험</target>
        </trans-unit>
        <trans-unit id="89032b84259ca753da6ee3335cc874eda5aea88c" translate="yes" xml:space="preserve">
          <source>Exploring history</source>
          <target state="translated">역사 탐험</target>
        </trans-unit>
        <trans-unit id="9594b6cd33e22cedcea0b51e30d878456e8b0103" translate="yes" xml:space="preserve">
          <source>Export Git tags to p4 labels, as per --export-labels.</source>
          <target state="translated">--export-labels에 따라 Git 태그를 p4 레이블로 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="1d5637309048195a7021fdbec654e04c3399ceec" translate="yes" xml:space="preserve">
          <source>Export a single commit to a CVS checkout</source>
          <target state="translated">단일 커밋을 CVS 체크 아웃으로 내보내기</target>
        </trans-unit>
        <trans-unit id="3b1e75b4d51f1271061fcd403a0829e4ee2dbe12" translate="yes" xml:space="preserve">
          <source>Export files with a prefix</source>
          <target state="translated">접두사를 사용하여 파일 내보내기</target>
        </trans-unit>
        <trans-unit id="265e5cf875ec82b17c2d01a82792a32a43a95b55" translate="yes" xml:space="preserve">
          <source>Export tags from Git as p4 labels. Tags found in Git are applied to the perforce working directory.</source>
          <target state="translated">Git에서 p4 레이블로 태그를 내 보냅니다. Git에있는 태그는 perforce 작업 디렉토리에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e1e5965077094d7c4756e516413e72a854f313c9" translate="yes" xml:space="preserve">
          <source>Exporting a Git repository via the Git protocol</source>
          <target state="translated">Git 프로토콜을 통해 Git 리포지토리 내보내기</target>
        </trans-unit>
        <trans-unit id="70581f8681dac905a7c1fddd025df98d77759bfd" translate="yes" xml:space="preserve">
          <source>Exporting a git repository via HTTP</source>
          <target state="translated">HTTP를 통해 git 저장소 내보내기</target>
        </trans-unit>
        <trans-unit id="7d0c2b669436b3c66b28c30bf0f8b2f1227f2bfb" translate="yes" xml:space="preserve">
          <source>Exports a commit from Git to a CVS checkout, making it easier to merge patches from a Git repository into a CVS repository.</source>
          <target state="translated">Git에서 CVS 체크 아웃으로 커밋을 내보내 Git 리포지토리에서 CVS 리포지토리로 패치를 쉽게 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91d81689bc4c223caafef827873bd7159612ae71" translate="yes" xml:space="preserve">
          <source>External Systems</source>
          <target state="translated">외부 시스템</target>
        </trans-unit>
        <trans-unit id="fa9abe3df3ff3676c618be0248e4529ceae9c936" translate="yes" xml:space="preserve">
          <source>External data format</source>
          <target state="translated">외부 데이터 형식</target>
        </trans-unit>
        <trans-unit id="0b01e11ac46c849a71c428abcd94e12009d5387f" translate="yes" xml:space="preserve">
          <source>Extract all commits that lead to &lt;code&gt;origin&lt;/code&gt; since the inception of the project:</source>
          <target state="translated">으로 이어질 모든 커밋 추출 &lt;code&gt;origin&lt;/code&gt; 프로젝트의 개시 이후를 :</target>
        </trans-unit>
        <trans-unit id="86dd39e46e8ada53c01392c7b98857ff781b5490" translate="yes" xml:space="preserve">
          <source>Extract all commits which are in the current branch but not in the origin branch:</source>
          <target state="translated">현재 브랜치에 있지만 오리진 브랜치에는없는 모든 커밋을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="293a4ac8183e30cb22a3c912e62cea8f83a17a45" translate="yes" xml:space="preserve">
          <source>Extract commit ID from an archive created using git-archive</source>
          <target state="translated">git-archive를 사용하여 생성 된 아카이브에서 커밋 ID 추출</target>
        </trans-unit>
        <trans-unit id="e52c75685be818f69a594f72535500e2b5f0de7d" translate="yes" xml:space="preserve">
          <source>Extract commits between revisions R1 and R2, and apply them on top of the current branch using &lt;code&gt;git am&lt;/code&gt; to cherry-pick them:</source>
          <target state="translated">개정판 R1과 R2 사이의 커밋을 추출하고 &lt;code&gt;git am&lt;/code&gt; 을 사용하여 현재 브랜치 위에 적용 하여 체리 피킹하십시오.</target>
        </trans-unit>
        <trans-unit id="a8d5387dbff833fee6e262477f3c484440daa076" translate="yes" xml:space="preserve">
          <source>Extract the last commit as a patch, and add a &lt;code&gt;Cc&lt;/code&gt; and a &lt;code&gt;Reviewed-by&lt;/code&gt; trailer to it:</source>
          <target state="translated">마지막 커밋을 패치로 추출한 후 &lt;code&gt;Cc&lt;/code&gt; 및 &lt;code&gt;Reviewed-by&lt;/code&gt; 트레일러를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d9851ec1c9a62576efac72204eb04797ad73e77a" translate="yes" xml:space="preserve">
          <source>Extract three topmost commits from the current branch and format them as e-mailable patches:</source>
          <target state="translated">현재 브랜치에서 최상위 커밋 3 개를 추출하여 전자 우편 패치로 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="849870ce78e05c63608a62580dff149aaa2767a8" translate="yes" xml:space="preserve">
          <source>Extracted diagnostics</source>
          <target state="translated">추출 된 진단</target>
        </trans-unit>
        <trans-unit id="fd728d82ed551d8e8658407681eee58615e4b172" translate="yes" xml:space="preserve">
          <source>Extracts patch and authorship from a single e-mail message</source>
          <target state="translated">단일 전자 메일 메시지에서 패치 및 저작권 추출</target>
        </trans-unit>
        <trans-unit id="77dbd3520a3a25fa2f64b3a79e8cdd2c5b438dfc" translate="yes" xml:space="preserve">
          <source>False by default.</source>
          <target state="translated">기본적으로 False입니다.</target>
        </trans-unit>
        <trans-unit id="8f5880afd2dba5ba402b936eb6b908e040c6c17a" translate="yes" xml:space="preserve">
          <source>Fast-forward merge</source>
          <target state="translated">빨리 감기 병합</target>
        </trans-unit>
        <trans-unit id="235360a9581b02e6b66f950074d19d23f01883c5" translate="yes" xml:space="preserve">
          <source>Fast-forward merges</source>
          <target state="translated">빨리 감기 병합</target>
        </trans-unit>
        <trans-unit id="4b4c24663902945e814f463b99629f081662828a" translate="yes" xml:space="preserve">
          <source>Features in &lt;code&gt;%feature&lt;/code&gt;</source>
          <target state="translated">기능의 &lt;code&gt;%feature&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac7a3c81a6bcc5d5ecdbb8a42e39a3cabf204420" translate="yes" xml:space="preserve">
          <source>Fetch &amp;lt;n&amp;gt; log entries per request when scanning Subversion history. The default is 100. For very large Subversion repositories, larger values may be needed for &lt;code&gt;clone&lt;/code&gt;/&lt;code&gt;fetch&lt;/code&gt; to complete in reasonable time. But overly large values may lead to higher memory usage and request timeouts.</source>
          <target state="translated">Subversion 기록을 검색 할 때 요청 당 &amp;lt;n&amp;gt; 로그 항목을 가져옵니다. 기본값은 100입니다. 매우 큰 Subversion 리포지토리의 경우 적절한 시간 내에 &lt;code&gt;clone&lt;/code&gt; / &lt;code&gt;fetch&lt;/code&gt; 를 완료 하려면 더 큰 값이 필요할 수 있습니다 . 그러나 값이 너무 크면 메모리 사용량이 높아지고 요청 시간이 초과 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fa9cbd39c84571e7bd481863d7516ff6663aa26" translate="yes" xml:space="preserve">
          <source>Fetch a &quot;thin&quot; pack, which records objects in deltified form based on objects not included in the pack to reduce network traffic.</source>
          <target state="translated">네트워크 트래픽을 줄이기 위해 팩에 포함되지 않은 개체를 기반으로 개체를 축소 된 형태로 기록하는 &quot;씬&quot;팩을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bfa61173eb5ea4c62442430cdd5a0f9a2ccdc304" translate="yes" xml:space="preserve">
          <source>Fetch a branch from a different repository, and give it a new name in your repository:</source>
          <target state="translated">다른 저장소에서 지점을 가져오고 저장소에 새 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="5f0a6423762963194f97ca1e3c9e8131a33fa3bd" translate="yes" xml:space="preserve">
          <source>Fetch a branch in a different Git repository, then merge into the current branch:</source>
          <target state="translated">다른 Git 리포지토리에서 분기를 가져온 다음 현재 분기로 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="4b2c92720b4e036e2e3a513a4ac4888b092fd45b" translate="yes" xml:space="preserve">
          <source>Fetch all remote refs.</source>
          <target state="translated">모든 원격 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="fc6f62670a87982450c7fd1465c966b498d51b73" translate="yes" xml:space="preserve">
          <source>Fetch all remotes.</source>
          <target state="translated">모든 리모컨을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7176a82579f2b775ede7e6b5698f625105e5e80d" translate="yes" xml:space="preserve">
          <source>Fetch all tags from the remote (i.e., fetch remote tags &lt;code&gt;refs/tags/*&lt;/code&gt; into local tags with the same name), in addition to whatever else would otherwise be fetched. Using this option alone does not subject tags to pruning, even if --prune is used (though tags may be pruned anyway if they are also the destination of an explicit refspec; see &lt;code&gt;--prune&lt;/code&gt;).</source>
          <target state="translated">다른 방법으로 가져올 수있는 것 외에 원격에서 모든 태그를 가져옵니다 (즉, 원격 태그 참조 &lt;code&gt;refs/tags/*&lt;/code&gt; 를 동일한 이름의 로컬 태그로 가져 오기 ). 이 옵션 만 사용하면 --prune이 사용 되더라도 태그를 제거 (prune)하지 않습니다 (태그가 명시 적 참조 &lt;code&gt;--prune&lt;/code&gt; 의 대상인 경우에도 제거 될 수 있지만 --prune 참조 ).</target>
        </trans-unit>
        <trans-unit id="24eb114caf72bd86613f02567ef244ced32c67f3" translate="yes" xml:space="preserve">
          <source>Fetch branches and/or tags (collectively, &quot;refs&quot;) from one or more other repositories, along with the objects necessary to complete their histories. Remote-tracking branches are updated (see the description of &amp;lt;refspec&amp;gt; below for ways to control this behavior).</source>
          <target state="translated">히스토리를 완료하는 데 필요한 오브젝트와 함께 하나 이상의 다른 저장소에서 브랜치 및 / 또는 태그 (통칭하여 &quot;참조&quot;)를 가져옵니다. 원격 추적 분기가 업데이트됩니다 (이 동작을 제어하는 ​​방법은 아래 &amp;lt;refspec&amp;gt; 설명 참조).</target>
        </trans-unit>
        <trans-unit id="31082e75ce46d9d1d50a3e2e4d3442657ed8677f" translate="yes" xml:space="preserve">
          <source>Fetch from and integrate with another repository or a local branch</source>
          <target state="translated">다른 리포지토리 또는 로컬 브랜치에서 페치 및 통합</target>
        </trans-unit>
        <trans-unit id="31bd9486b123aa2097f6934aa8fc09cb0582f241" translate="yes" xml:space="preserve">
          <source>Fetch master, using file descriptor #17 to communicate with git-upload-pack.</source>
          <target state="translated">git-upload-pack과 통신하기 위해 파일 디스크립터 # 17을 사용하여 마스터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c7b7a55dc86420061c3ee2c8e313312034e265da" translate="yes" xml:space="preserve">
          <source>Fetch only from the SVN parent of the current HEAD.</source>
          <target state="translated">현재 HEAD의 SVN 상위에서만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ab869fa62e8a09f8f5c922fc9c36375323cdbbc8" translate="yes" xml:space="preserve">
          <source>Fetch unfetched revisions from the Subversion remote we are tracking. The name of the [svn-remote &quot;&amp;hellip;​&quot;] section in the $GIT_DIR/config file may be specified as an optional command-line argument.</source>
          <target state="translated">추적중인 Subversion 원격에서 가져 오지 않은 개정을 가져옵니다. $ GIT_DIR / config 파일에서 [svn-remote &quot;&amp;hellip;&quot;] 섹션의 이름은 선택적 명령 행 인수로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="280e77f3e0aa84ca742f26ca190cb5692edeefd2" translate="yes" xml:space="preserve">
          <source>Fetch updates for remotes or remote groups in the repository as defined by &lt;code&gt;remotes.&amp;lt;group&amp;gt;&lt;/code&gt;. If neither group nor remote is specified on the command line, the configuration parameter remotes.default will be used; if remotes.default is not defined, all remotes which do not have the configuration parameter &lt;code&gt;remote.&amp;lt;name&amp;gt;.skipDefaultUpdate&lt;/code&gt; set to true will be updated. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;remotes.&amp;lt;group&amp;gt;&lt;/code&gt; 에 정의 된대로 저장소의 원격 또는 원격 그룹에 대한 업데이트를 가져옵니다 . 명령 줄에 그룹과 원격이 모두 지정되지 않은 경우 구성 매개 변수 remotes.default가 사용됩니다. remotes.default가 정의되지 않은 경우 구성 매개 변수 &lt;code&gt;remote.&amp;lt;name&amp;gt;.skipDefaultUpdate&lt;/code&gt; 가 true로 설정 되지 않은 모든 원격지 가 업데이트됩니다. ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="15a003694d110886a95c99728ccaa08a956586a4" translate="yes" xml:space="preserve">
          <source>Fetch updates for remotes or remote groups in the repository as defined by remotes.&amp;lt;group&amp;gt;. If neither group nor remote is specified on the command line, the configuration parameter remotes.default will be used; if remotes.default is not defined, all remotes which do not have the configuration parameter remote.&amp;lt;name&amp;gt;.skipDefaultUpdate set to true will be updated. (See &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;).</source>
          <target state="translated">remotes. &amp;lt;group&amp;gt;에 의해 정의 된 리포지토리에서 원격 또는 원격 그룹에 대한 업데이트를 가져옵니다. 명령 행에 group 또는 remote가 지정되지 않은 경우 구성 매개 변수 remotes.default가 사용됩니다. remotes.default가 정의되지 않은 경우 구성 매개 변수 remote. &amp;lt;name&amp;gt; .skipDefaultUpdate가 true로 설정되지 않은 모든 원격이 업데이트됩니다. ( &lt;a href=&quot;git-config&quot;&gt;git-config [1] 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="82e98a6b98be0542f3ca46bd6c66454d11bde6bb" translate="yes" xml:space="preserve">
          <source>Fetches the given object, writing the necessary objects to the database. Fetch commands are sent in a batch, one per line, terminated with a blank line. Outputs a single blank line when all fetch commands in the same batch are complete. Only objects which were reported in the output of &lt;code&gt;list&lt;/code&gt; with a sha1 may be fetched this way.</source>
          <target state="translated">주어진 객체를 가져 와서 필요한 객체를 데이터베이스에 씁니다. 페치 명령은 한 줄에 하나씩 배치로 전송되며 빈 줄로 종료됩니다. 동일한 배치의 모든 페치 명령이 완료되면 단일 빈 줄을 출력합니다. sha1을 사용하여 &lt;code&gt;list&lt;/code&gt; 의 출력에서보고 된 객체 만이 방식으로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e512ef616863b90580db01bc69e67097028beb3" translate="yes" xml:space="preserve">
          <source>Fetching a &lt;a href=&quot;#def_branch&quot;&gt;branch&lt;/a&gt; means to get the branch&amp;rsquo;s &lt;a href=&quot;#def_head_ref&quot;&gt;head ref&lt;/a&gt; from a remote &lt;a href=&quot;#def_repository&quot;&gt;repository&lt;/a&gt;, to find out which objects are missing from the local &lt;a href=&quot;#def_object_database&quot;&gt;object database&lt;/a&gt;, and to get them, too. See also &lt;a href=&quot;git-fetch&quot;&gt;git-fetch[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#def_branch&quot;&gt;브랜치를&lt;/a&gt; 가져 오는 것은 원격 &lt;a href=&quot;#def_repository&quot;&gt;저장소&lt;/a&gt; 에서 브랜치의 &lt;a href=&quot;#def_head_ref&quot;&gt;헤드 참조&lt;/a&gt; 를 가져 와서 로컬 &lt;a href=&quot;#def_object_database&quot;&gt;오브젝트 데이터베이스&lt;/a&gt; 에서 누락 된 오브젝트를 찾아서 가져 오는 것을 의미합니다 . &lt;a href=&quot;git-fetch&quot;&gt;git-fetch [1]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca528f4260a5f0ff38dd8302ddb33ede05c8ee7e" translate="yes" xml:space="preserve">
          <source>Fetching branches from other repositories</source>
          <target state="translated">다른 저장소에서 브랜치 가져 오기</target>
        </trans-unit>
        <trans-unit id="38fdecc5037849cb76e9ff10175400ab8d8520f4" translate="yes" xml:space="preserve">
          <source>Fetching from a remote repository is done by, unsurprisingly, &lt;code&gt;git fetch&lt;/code&gt;:</source>
          <target state="translated">원격 저장소에서 가져 오는 것은 놀랍지 않게 &lt;code&gt;git fetch&lt;/code&gt; 에 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="66837c163f00048d36bcb5882cef29f3589ed957" translate="yes" xml:space="preserve">
          <source>Fetching individual branches</source>
          <target state="translated">개별 분기를 가져 오는 중</target>
        </trans-unit>
        <trans-unit id="95fb769cdd33ccd5fcde15b12c59c0228df81279" translate="yes" xml:space="preserve">
          <source>Field names</source>
          <target state="translated">필드 이름</target>
        </trans-unit>
        <trans-unit id="7d4e1fd5661dae539542971bb6b2fc728d599c94" translate="yes" xml:space="preserve">
          <source>Fields that have name-email-date tuple as its value (&lt;code&gt;author&lt;/code&gt;, &lt;code&gt;committer&lt;/code&gt;, and &lt;code&gt;tagger&lt;/code&gt;) can be suffixed with &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt;, and &lt;code&gt;date&lt;/code&gt; to extract the named component.</source>
          <target state="translated">name-email-date 튜플이 값 ( &lt;code&gt;author&lt;/code&gt; , &lt;code&gt;committer&lt;/code&gt; 및 &lt;code&gt;tagger&lt;/code&gt; ) 인 필드는 &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;email&lt;/code&gt; 및 &lt;code&gt;date&lt;/code&gt; 로 접미사를 붙여 명명 된 구성 요소를 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f890c334357c63fe5c4a4300d447bac89c08dc17" translate="yes" xml:space="preserve">
          <source>Fields that have name-email-date tuple as its value (&lt;code&gt;author&lt;/code&gt;, &lt;code&gt;committer&lt;/code&gt;, and &lt;code&gt;tagger&lt;/code&gt;) can be suffixed with &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;email&lt;/code&gt;, and &lt;code&gt;date&lt;/code&gt; to extract the named component. For email fields (&lt;code&gt;authoremail&lt;/code&gt;, &lt;code&gt;committeremail&lt;/code&gt; and &lt;code&gt;taggeremail&lt;/code&gt;), &lt;code&gt;:trim&lt;/code&gt; can be appended to get the email without angle brackets, and &lt;code&gt;:localpart&lt;/code&gt; to get the part before the &lt;code&gt;@&lt;/code&gt; symbol out of the trimmed email.</source>
          <target state="translated">값으로 name-email-date 튜플이있는 필드 ( &lt;code&gt;author&lt;/code&gt; , &lt;code&gt;committer&lt;/code&gt; , &lt;code&gt;tagger&lt;/code&gt; )는 &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;email&lt;/code&gt; 및 &lt;code&gt;date&lt;/code&gt; 로 접미사를 붙여 명명 된 구성 요소를 추출 할 수 있습니다 . 이메일 필드 ( &lt;code&gt;authoremail&lt;/code&gt; , &lt;code&gt;committeremail&lt;/code&gt; 및 &lt;code&gt;taggeremail&lt;/code&gt; )의 경우 &lt;code&gt;:trim&lt;/code&gt; 을 추가하여 꺾쇠 괄호없이 이메일을 가져오고 &lt;code&gt;:localpart&lt;/code&gt; 를 추가 하여 잘린 이메일 에서 &lt;code&gt;@&lt;/code&gt; 기호 앞의 부분을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed2ff2065be5f4efd23916d9b5c024804bb05ec6" translate="yes" xml:space="preserve">
          <source>Fields use modified URI encoding, defined in RFC 3986, section 2.1 (Percent-Encoding), or rather &quot;Query string encoding&quot; (see &lt;a href=&quot;https://en.wikipedia.org/wiki/Query_string#URL_encoding&quot;&gt;https://en.wikipedia.org/wiki/Query_string#URL_encoding&lt;/a&gt;), the difference being that SP (&quot; &quot;) can be encoded as &quot;+&quot; (and therefore &quot;+&quot; has to be also percent-encoded).</source>
          <target state="translated">필드는 RFC 3986, 섹션 2.1 (퍼센트 인코딩) 또는 &quot;쿼리 문자열 인코딩&quot;( &lt;a href=&quot;https://en.wikipedia.org/wiki/Query_string#URL_encoding&quot;&gt;https://en.wikipedia.org/wiki/Query_string#URL_encoding 참조&lt;/a&gt; )에 정의 된 수정 된 URI 인코딩을 사용합니다. ( &quot;&quot;)는 &quot;+&quot;로 인코딩 될 수 있으므로 &quot;+&quot;도 퍼센트로 인코딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ff9cc1a6f5bb5a91d014bd56871d8a7e6dedf925" translate="yes" xml:space="preserve">
          <source>Fighting regressions overview</source>
          <target state="translated">파이팅 회귀 분석 개요</target>
        </trans-unit>
        <trans-unit id="dc286ffc3d263eab0659e5254ed6cbdfe1ed4661" translate="yes" xml:space="preserve">
          <source>Figuring out why this works is left as an exercise to the (advanced) student. The &lt;a href=&quot;git-log&quot;&gt;git-log[1]&lt;/a&gt;, &lt;a href=&quot;git-diff-tree&quot;&gt;git-diff-tree[1]&lt;/a&gt;, and &lt;a href=&quot;git-hash-object&quot;&gt;git-hash-object[1]&lt;/a&gt; man pages may prove helpful.</source>
          <target state="translated">이것이 왜 효과가 있는지를 알아내는 것은 (고급) 학생에게 연습으로 남습니다. &lt;a href=&quot;git-log&quot;&gt;자식 로그 [1]&lt;/a&gt; , &lt;a href=&quot;git-diff-tree&quot;&gt;자식-DIFF 트리 [1]&lt;/a&gt; , 그리고 &lt;a href=&quot;git-hash-object&quot;&gt;자식 해시 객체 [1]&lt;/a&gt; 사람이 페이지는 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39b2ed94cef5d6961eea0620d66a925578f2f283" translate="yes" xml:space="preserve">
          <source>File containing the SSL certificate when fetching or pushing over HTTPS. Can be overridden by the &lt;code&gt;GIT_SSL_CERT&lt;/code&gt; environment variable.</source>
          <target state="translated">HTTPS를 가져 오거나 푸시 할 때 SSL 인증서가 포함 된 파일입니다. &lt;code&gt;GIT_SSL_CERT&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3b34071a7a6143f1cfbfe18d8122a378b6725a7" translate="yes" xml:space="preserve">
          <source>File containing the SSL private key when fetching or pushing over HTTPS. Can be overridden by the &lt;code&gt;GIT_SSL_KEY&lt;/code&gt; environment variable.</source>
          <target state="translated">HTTPS를 가져 오거나 푸시 할 때 SSL 개인 키가 포함 된 파일입니다. &lt;code&gt;GIT_SSL_KEY&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a25f7e6a9a15db1a7bb16a1513a308705fbf008c" translate="yes" xml:space="preserve">
          <source>File containing the certificates to verify the peer with when fetching or pushing over HTTPS. Can be overridden by the &lt;code&gt;GIT_SSL_CAINFO&lt;/code&gt; environment variable.</source>
          <target state="translated">HTTPS를 가져 오거나 푸시 할 때 피어를 확인할 인증서가 포함 된 파일입니다. &lt;code&gt;GIT_SSL_CAINFO&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51de61b9fb1649e39093ab80c2a7df2f9e16643a" translate="yes" xml:space="preserve">
          <source>File globbing matches across directory boundaries. Thus, given two directories &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;d2&lt;/code&gt;, there is a difference between using &lt;code&gt;git rm 'd*'&lt;/code&gt; and &lt;code&gt;git rm 'd/*'&lt;/code&gt;, as the former will also remove all of directory &lt;code&gt;d2&lt;/code&gt;.</source>
          <target state="translated">파일 글 로빙은 디렉토리 경계에서 일치합니다. 따라서, 두 주어진 디렉토리 &lt;code&gt;d&lt;/code&gt; 및 &lt;code&gt;d2&lt;/code&gt; 존재하여 차인 &lt;code&gt;git rm 'd*'&lt;/code&gt; 와 &lt;code&gt;git rm 'd/*'&lt;/code&gt; 전 또한 디렉토리 모두 제거되므로, &lt;code&gt;d2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46bdca067f191e47ac236c4a9946147313edeadf" translate="yes" xml:space="preserve">
          <source>File inclusion (&lt;code&gt;:include: /path/name&lt;/code&gt;) is not supported.</source>
          <target state="translated">파일 포함 ( &lt;code&gt;:include: /path/name&lt;/code&gt; )은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0052ebd08e3dda2e68d8ee7b082b7c890d6ddeef" translate="yes" xml:space="preserve">
          <source>File indicating how to order files within a diff. See the &lt;code&gt;-O&lt;/code&gt; option to &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt; for details. If &lt;code&gt;diff.orderFile&lt;/code&gt; is a relative pathname, it is treated as relative to the top of the working tree.</source>
          <target state="translated">diff 내에서 파일을 주문하는 방법을 나타내는 파일입니다. 자세한 내용은 &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 의 &lt;code&gt;-O&lt;/code&gt; 옵션을 참조 하십시오. 경우 &lt;code&gt;diff.orderFile&lt;/code&gt; 가 상대 경로 이름입니다, 그것은 작업 트리의 상단을 기준으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="f2b61a4d1705fa3305542b48c5c1ffd38b30200f" translate="yes" xml:space="preserve">
          <source>File modes are printed as 6-digit octal numbers including the file type and file permission bits.</source>
          <target state="translated">파일 모드는 파일 형식 및 파일 권한 비트를 포함하여 6 자리 8 진수로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="cd4c7b960aaa326dfff2bf746e515a16b2b5bd4d" translate="yes" xml:space="preserve">
          <source>File system monitor</source>
          <target state="translated">파일 시스템 모니터</target>
        </trans-unit>
        <trans-unit id="dab1e8f60ab6cd6f09a76739b1f40f880fb79310" translate="yes" xml:space="preserve">
          <source>File to use for (filename extension based) guessing of MIME types before trying &lt;code&gt;/etc/mime.types&lt;/code&gt;. &lt;strong&gt;NOTE&lt;/strong&gt; that this path, if relative, is taken as relative to the current Git repository, not to CGI script. If unset, only &lt;code&gt;/etc/mime.types&lt;/code&gt; is used (if present on filesystem). If no mimetypes file is found, mimetype guessing based on extension of file is disabled. Unset by default.</source>
          <target state="translated">&lt;code&gt;/etc/mime.types&lt;/code&gt; 를 시도하기 전에 MIME 유형을 추측하는 데 사용할 파일 (확장명 기반) 입니다. &lt;strong&gt;참고&lt;/strong&gt; 이 경로가 상대하는 경우,하지 CGI 스크립트, 현재 Git 저장소에 상대적으로 간주됩니다. 설정하지 않으면 &lt;code&gt;/etc/mime.types&lt;/code&gt; 만 사용됩니다 (파일 시스템에있는 경우). mimetypes 파일이 없으면 파일 확장자에 따른 mimetype 추측이 비활성화됩니다. 기본적으로 설정 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f045415cfa170f304a990874fe0966e6d4eacafb" translate="yes" xml:space="preserve">
          <source>File with repository URL (used for clone and fetch), one per line. Displayed in the project summary page. You can use multiple-valued &lt;code&gt;gitweb.url&lt;/code&gt; repository configuration variable for that, but the file takes precedence.</source>
          <target state="translated">저장소 URL (복제 및 가져 오기에 사용)이있는 파일 (한 줄에 하나씩) 프로젝트 요약 페이지에 표시됩니다. 이를 위해 다중 값 &lt;code&gt;gitweb.url&lt;/code&gt; 저장소 구성 변수를 사용할 수 있지만 파일이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="f73380191ad1f1caa70019147dbb81cb74dd0fbd" translate="yes" xml:space="preserve">
          <source>File/directory structure</source>
          <target state="translated">파일 / 디렉토리 구조</target>
        </trans-unit>
        <trans-unit id="ee97d026e695edaa3af17191656d312a0a7a2ccb" translate="yes" xml:space="preserve">
          <source>Filenames with spaces are often mishandled by shell snippets since they cause problems for shell pipelines. Not everyone is familiar with find -print0, xargs -0, git-ls-files -z, etc. Even people who are familiar with these may assume such flags are not relevant because someone else renamed any such files in their repo back before the person doing the filtering joined the project. And often, even those familiar with handling arguments with spaces may not do so just because they aren&amp;rsquo;t in the mindset of thinking about everything that could possibly go wrong.</source>
          <target state="translated">공백이있는 파일 이름은 셸 파이프 라인에 문제를 유발하기 때문에 셸 스 니펫으로 잘못 처리되는 경우가 많습니다. 모든 사람이 find -print0, xargs -0, git-ls-files -z 등에 익숙하지는 않습니다. 이러한 플래그에 익숙한 사람들도 다른 사람이 이전에 해당 파일의 이름을 바꿨 기 때문에 이러한 플래그는 관련이 없다고 가정 할 수 있습니다. 필터링을 수행하는 사람이 프로젝트에 참여했습니다. 그리고 공백으로 인수를 다루는 데 익숙한 사람들조차도 잘못 될 수있는 모든 것에 대해 생각할 생각이 없기 때문에 그렇게하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="669b1abdd74168ff79423d155c9ddb7e43a80b6e" translate="yes" xml:space="preserve">
          <source>Files (and pointers to subtrees) within active trees require 52 or 64 bytes (32/64 bit platforms) per entry. To conserve space, file and tree names are pooled in a common string table, allowing the filename &amp;ldquo;Makefile&amp;rdquo; to use just 16 bytes (after including the string header overhead) no matter how many times it occurs within the project.</source>
          <target state="translated">활성 트리 내의 파일 (및 하위 트리에 대한 포인터)은 항목 당 52 또는 64 바이트 (32/64 비트 플랫폼)가 필요합니다. 공간을 절약하기 위해 파일 및 트리 이름이 공통 문자열 테이블에 풀링되어 파일 이름 &quot;Makefile&quot;이 프로젝트 내에서 발생하는 횟수에 관계없이 파일 이름 &quot;Makefile&quot;이 16 바이트 만 사용할 수 있습니다 (문자열 헤더 오버 헤드 포함).</target>
        </trans-unit>
        <trans-unit id="94bbb76c1352043c45a00df324ef04fea70e6730" translate="yes" xml:space="preserve">
          <source>Files and directories in the template directory whose name do not start with a dot will be copied to the &lt;code&gt;$GIT_DIR&lt;/code&gt; after it is created.</source>
          <target state="translated">이름이 점으로 시작하지 않는 템플리트 디렉토리의 파일 및 디렉토리 는 작성된 후 &lt;code&gt;$GIT_DIR&lt;/code&gt; 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1270c9a81ec2853fddc0c884f8ccb1e8a45b97e" translate="yes" xml:space="preserve">
          <source>Files and directories with the attribute &lt;code&gt;export-ignore&lt;/code&gt; won&amp;rsquo;t be added to archive files.</source>
          <target state="translated">&lt;code&gt;export-ignore&lt;/code&gt; 속성을 가진 파일 및 디렉토리는 아카이브 파일에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3974c4c3ce398cf177c9471660017bb110038df" translate="yes" xml:space="preserve">
          <source>Files and directories with the attribute export-ignore won&amp;rsquo;t be added to archive files. See &lt;a href=&quot;gitattributes&quot;&gt;gitattributes[5]&lt;/a&gt; for details.</source>
          <target state="translated">export-ignore 속성을 가진 파일 및 디렉토리는 아카이브 파일에 추가되지 않습니다. 자세한 내용은 &lt;a href=&quot;gitattributes&quot;&gt;gitattributes [5]&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a7b0ec5c5be81a4a3b161d0317a98cc9a7a62cb3" translate="yes" xml:space="preserve">
          <source>Files larger than this size are stored deflated, without attempting delta compression. Storing large files without delta compression avoids excessive memory usage, at the slight expense of increased disk usage. Additionally files larger than this size are always treated as binary.</source>
          <target state="translated">이 크기보다 큰 파일은 델타 압축을 시도하지 않고 수축 된 상태로 저장됩니다. 델타 압축없이 큰 파일을 저장하면 디스크 사용량이 약간 증가하더라도 과도한 메모리 사용을 피할 수 있습니다. 또한이 크기보다 큰 파일은 항상 이진으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b57b0d88e9fd775cd564cc119a3989093d68ff8d" translate="yes" xml:space="preserve">
          <source>Files to act on. Note that files beginning with &lt;code&gt;.&lt;/code&gt; are discarded. This includes &lt;code&gt;./file&lt;/code&gt; and &lt;code&gt;dir/./file&lt;/code&gt;. If you don&amp;rsquo;t want this, then use cleaner names. The same applies to directories ending &lt;code&gt;/&lt;/code&gt; and paths with &lt;code&gt;//&lt;/code&gt;</source>
          <target state="translated">작동 할 파일. 로 시작하는 파일에 유의하십시오 &lt;code&gt;.&lt;/code&gt; 폐기됩니다. 여기에는 &lt;code&gt;./file&lt;/code&gt; 및 &lt;code&gt;dir/./file&lt;/code&gt; 이 포함 됩니다 . 이것을 원하지 않으면 더 명확한 이름을 사용하십시오. 동일은 종료 디렉토리에 적용 &lt;code&gt;/&lt;/code&gt; 와 경로 &lt;code&gt;//&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a229bb6156d5f90b453ca5e0ca33977f1a3e6a8a" translate="yes" xml:space="preserve">
          <source>Files to add content from. Fileglobs (e.g. &lt;code&gt;*.c&lt;/code&gt;) can be given to add all matching files. Also a leading directory name (e.g. &lt;code&gt;dir&lt;/code&gt; to add &lt;code&gt;dir/file1&lt;/code&gt; and &lt;code&gt;dir/file2&lt;/code&gt;) can be given to update the index to match the current state of the directory as a whole (e.g. specifying &lt;code&gt;dir&lt;/code&gt; will record not just a file &lt;code&gt;dir/file1&lt;/code&gt; modified in the working tree, a file &lt;code&gt;dir/file2&lt;/code&gt; added to the working tree, but also a file &lt;code&gt;dir/file3&lt;/code&gt; removed from the working tree). Note that older versions of Git used to ignore removed files; use &lt;code&gt;--no-all&lt;/code&gt; option if you want to add modified or new files but ignore removed ones.</source>
          <target state="translated">컨텐츠를 추가 할 파일입니다. 일치하는 모든 파일을 추가하기 위해 Fileglobs (예 : &lt;code&gt;*.c&lt;/code&gt; )를 제공 할 수 있습니다. 또한 주요 디렉토리 이름 (예 : &lt;code&gt;dir&lt;/code&gt; 추가 &lt;code&gt;dir/file1&lt;/code&gt; 및 &lt;code&gt;dir/file2&lt;/code&gt; (예를 들면 지정 전체 디렉토리의 현재 상태와 일치하는 인덱스를 업데이트 주어질 수있다) &lt;code&gt;dir&lt;/code&gt; 아닌 파일을 기록 할 &lt;code&gt;dir/file1&lt;/code&gt; 수정 작업 트리에서 파일 &lt;code&gt;dir/file2&lt;/code&gt; 가 작업 트리에 추가되었지만 파일 &lt;code&gt;dir/file3&lt;/code&gt; 이 작업 트리에서 제거되었습니다. 이전 버전의 Git은 제거 된 파일을 무시하는 데 사용되었습니다. 수정되거나 새 파일을 추가하지만 제거 된 파일은 무시 하려면 &lt;code&gt;--no-all&lt;/code&gt; 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="965ffdf35ae99a80180c99419426ec2062c992e9" translate="yes" xml:space="preserve">
          <source>Files to remove. A leading directory name (e.g. &lt;code&gt;dir&lt;/code&gt; to remove &lt;code&gt;dir/file1&lt;/code&gt; and &lt;code&gt;dir/file2&lt;/code&gt;) can be given to remove all files in the directory, and recursively all sub-directories, but this requires the &lt;code&gt;-r&lt;/code&gt; option to be explicitly given.</source>
          <target state="translated">제거 할 파일. 선행 디렉토리 이름 (예 : &lt;code&gt;dir&lt;/code&gt; &lt;code&gt;dir/file1&lt;/code&gt; 및 &lt;code&gt;dir/file2&lt;/code&gt; 를 제거하기위한 dir )을 제공하여 디렉토리의 모든 파일과 모든 하위 디렉토리를 반복적으로 제거 할 수 있지만,이를 위해서는 &lt;code&gt;-r&lt;/code&gt; 옵션을 명시 적으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="6fcfbd1668d25020111102295bf825ad36cd4ad7" translate="yes" xml:space="preserve">
          <source>Files to remove. Fileglobs (e.g. &lt;code&gt;*.c&lt;/code&gt;) can be given to remove all matching files. If you want Git to expand file glob characters, you may need to shell-escape them. A leading directory name (e.g. &lt;code&gt;dir&lt;/code&gt; to remove &lt;code&gt;dir/file1&lt;/code&gt; and &lt;code&gt;dir/file2&lt;/code&gt;) can be given to remove all files in the directory, and recursively all sub-directories, but this requires the &lt;code&gt;-r&lt;/code&gt; option to be explicitly given.</source>
          <target state="translated">제거 할 파일. 일치하는 모든 파일을 제거하기 위해 Fileglobs (예 : &lt;code&gt;*.c&lt;/code&gt; )를 제공 할 수 있습니다. Git이 파일 glob 문자를 확장하도록하려면 쉘 이스케이프해야합니다. 디렉토리의 모든 파일과 재귀 적으로 모든 서브 &lt;code&gt;dir&lt;/code&gt; 를 제거하기 위해 디렉토리 이름 (예 : dir &lt;code&gt;dir/file1&lt;/code&gt; 및 &lt;code&gt;dir/file2&lt;/code&gt; 를 제거하기위한 dir )을 지정할 수 있지만, &lt;code&gt;-r&lt;/code&gt; 옵션을 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d69266d087a66debaeaa16301b1f83a323ef3a05" translate="yes" xml:space="preserve">
          <source>Files to show. If no files are given all files which match the other specified criteria are shown.</source>
          <target state="translated">표시 할 파일입니다. 파일이 제공되지 않으면 지정된 다른 기준과 일치하는 모든 파일이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="94b61f142196a44a91e5065c7d0adcb5cad7dae3" translate="yes" xml:space="preserve">
          <source>Files with conflicts are marked specially in the index, so until you resolve the problem and update the index, &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; will fail:</source>
          <target state="translated">충돌이있는 파일은 인덱스에 특별히 표시되므로 문제를 해결하고 인덱스를 업데이트 할 때까지 &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="96e578211aa295317cf257310712fa28ccd8f6c6" translate="yes" xml:space="preserve">
          <source>Filters</source>
          <target state="translated">Filters</target>
        </trans-unit>
        <trans-unit id="1cf100e1097311bd9759a52dc063dba54a0c3fc0" translate="yes" xml:space="preserve">
          <source>Finalize an in-progress &lt;code&gt;git notes merge&lt;/code&gt;. Use this option when you have resolved the conflicts that &lt;code&gt;git notes merge&lt;/code&gt; stored in .git/NOTES_MERGE_WORKTREE. This amends the partial merge commit created by &lt;code&gt;git notes merge&lt;/code&gt; (stored in .git/NOTES_MERGE_PARTIAL) by adding the notes in .git/NOTES_MERGE_WORKTREE. The notes ref stored in the .git/NOTES_MERGE_REF symref is updated to the resulting commit.</source>
          <target state="translated">진행중인 &lt;code&gt;git notes merge&lt;/code&gt; 를 마무리하십시오 . &lt;code&gt;git notes merge&lt;/code&gt; 가 .git / NOTES_MERGE_WORKTREE에 저장된 병합 충돌을 해결 한 경우이 옵션을 사용하십시오 . 이것은 .git / NOTES_MERGE_WORKTREE에 메모를 추가하여 &lt;code&gt;git notes merge&lt;/code&gt; (.git / NOTES_MERGE_PARTIAL에 저장 됨)에 의해 생성 된 부분 병합 커밋을 수정합니다 . .git / NOTES_MERGE_REF symref에 저장된 노트 참조는 결과 커밋으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="9eb00b677ea152c9f2f0f234add05ac350dd5a77" translate="yes" xml:space="preserve">
          <source>Finally it examines &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt;. This file is used to override the in-tree settings. The first line is a match, and &lt;code&gt;foo&lt;/code&gt; is set, &lt;code&gt;bar&lt;/code&gt; is reverted to unspecified state, and &lt;code&gt;baz&lt;/code&gt; is unset.</source>
          <target state="translated">마지막으로 &lt;code&gt;$GIT_DIR/info/attributes&lt;/code&gt; 검사 합니다 . 이 파일은 인트 리 설정을 재정의하는 데 사용됩니다. 첫 번째 줄은 일치하고 &lt;code&gt;foo&lt;/code&gt; 가 설정되고 &lt;code&gt;bar&lt;/code&gt; 는 지정되지 않은 상태로 되돌아 &lt;code&gt;baz&lt;/code&gt; 는 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="331d183abb3e32c5b94fe163358b0bd60def41df" translate="yes" xml:space="preserve">
          <source>Finally, if &lt;code&gt;--expire-time=&amp;lt;datetime&amp;gt;&lt;/code&gt; is not specified, let &lt;code&gt;datetime&lt;/code&gt; be the current time. After writing the split commit-graph, delete all unused commit-graph whose modified times are older than &lt;code&gt;datetime&lt;/code&gt;.</source>
          <target state="translated">마지막으로 &lt;code&gt;--expire-time=&amp;lt;datetime&amp;gt;&lt;/code&gt; 을 지정하지 않으면 &lt;code&gt;datetime&lt;/code&gt; 을 현재 시간으로 둡니다 . split commit-graph를 작성한 후 수정 된 시간이 &lt;code&gt;datetime&lt;/code&gt; 보다 오래된 모든 사용되지 않은 commit-graph를 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="43d1a6457be0c846de5bf38ab3298d9d3628832d" translate="yes" xml:space="preserve">
          <source>Finally, it is possible to specify an arbitrary perl subroutine that will be called for each repository to determine if it can be exported. The subroutine receives an absolute path to the project (repository) as its only parameter (i.e. &quot;$projectroot/$project&quot;).</source>
          <target state="translated">마지막으로, 각 저장소에 대해 호출 될 임의의 perl 서브 루틴을 지정하여 익스포트 가능 여부를 판별 할 수 있습니다. 서브 루틴은 유일한 매개 변수 (예 : &quot;$ projectroot / $ project&quot;)로 프로젝트 (저장소)에 대한 절대 경로를받습니다.</target>
        </trans-unit>
        <trans-unit id="24d1078763f97a2ccc23634e9fb57ca6945117cd" translate="yes" xml:space="preserve">
          <source>Finally, it&amp;rsquo;s worth looking at the effect of &lt;code&gt;git add&lt;/code&gt; on the index file:</source>
          <target state="translated">마지막으로 인덱스 파일에 &lt;code&gt;git add&lt;/code&gt; 의 영향을 살펴볼 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8264955cf61255273040b40a18d8fbbb22fa2f72" translate="yes" xml:space="preserve">
          <source>Finally, most commands that take filenames will optionally allow you to precede any filename by a commit, to specify a particular version of the file:</source>
          <target state="translated">마지막으로 파일 이름을 사용하는 대부분의 명령을 사용하면 파일의 특정 버전을 지정하기 위해 커밋으로 파일 이름 앞에 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c56e02ffa0dc0d04395282d17622dfa271e848b" translate="yes" xml:space="preserve">
          <source>Finally, runs of whitespace are normalized to a single ASCII space character.</source>
          <target state="translated">마지막으로 공백 문자는 단일 ASCII 공백 문자로 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="f254df0ed5803ab0d672797542ab7bd433761746" translate="yes" xml:space="preserve">
          <source>Finally, see &lt;a href=&quot;#todo&quot;&gt;Notes and todo list for this manual&lt;/a&gt; for ways that you can help make this manual more complete.</source>
          <target state="translated">마지막 으로이 매뉴얼을보다 완벽하게 작성하는 데 도움이되는 방법 &lt;a href=&quot;#todo&quot;&gt;은이 매뉴얼의 참고 및 할 일 목록을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f28877b4b3e20afaa3344b89d8d8e7dd3cc9a77" translate="yes" xml:space="preserve">
          <source>Finally, the list of matching commits is shown in the order of the second commit range, with unmatched commits being inserted just after all of their ancestors have been shown.</source>
          <target state="translated">마지막으로 일치하는 커밋 목록은 두 번째 커밋 범위의 순서로 표시되며, 모든 조상이 표시된 직후 일치하지 않는 커밋이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="9a3fea8b3f0925da6c2b86381c6c149ac6f29683" translate="yes" xml:space="preserve">
          <source>Finally, there are a few odds and ends which are not purely moving from one representation to the other:</source>
          <target state="translated">마지막으로, 한 표현에서 다른 표현으로 순전히 이동하지 않는 몇 가지 가능성과 끝이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fe4e962ec8320ef45c1375652f3937a50d04ca2" translate="yes" xml:space="preserve">
          <source>Finally, there is a fifth simplification mode available:</source>
          <target state="translated">마지막으로 다섯 번째 단순화 모드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be9a3fea0f82381aa185e3a3e7bc70453cddfef1" translate="yes" xml:space="preserve">
          <source>Finally, these options can be combined with a layout option (defaults to &lt;code&gt;nodense&lt;/code&gt;):</source>
          <target state="translated">마지막으로 이러한 옵션을 레이아웃 옵션과 결합 할 수 있습니다 (기본값은 &lt;code&gt;nodense&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="20a1c9ffc616ee01b8dce65bdb93f7148cbfeb85" translate="yes" xml:space="preserve">
          <source>Find a helper.</source>
          <target state="translated">도우미를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="30d88faf5655c44ff9e677fe0e00c8e9ca77aa3d" translate="yes" xml:space="preserve">
          <source>Find a ref that matches &lt;code&gt;experimental&lt;/code&gt; in the &lt;code&gt;origin&lt;/code&gt; repository (e.g. &lt;code&gt;refs/heads/experimental&lt;/code&gt;), and delete it.</source>
          <target state="translated">&lt;code&gt;origin&lt;/code&gt; 저장소 에서 &lt;code&gt;experimental&lt;/code&gt; 일치하는 참조 (예 : &lt;code&gt;refs/heads/experimental&lt;/code&gt; )를 찾아 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="ef251b247769ae2bcbe4a6086b08e0deff95b9d6" translate="yes" xml:space="preserve">
          <source>Find a ref that matches &lt;code&gt;master&lt;/code&gt; in the source repository (most likely, it would find &lt;code&gt;refs/heads/master&lt;/code&gt;), and update the same ref (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) in &lt;code&gt;origin&lt;/code&gt; repository with it. If &lt;code&gt;master&lt;/code&gt; did not exist remotely, it would be created.</source>
          <target state="translated">소스 리포지토리에서 &lt;code&gt;master&lt;/code&gt; 와 일치 하는 리퍼를 찾고 (대개 &lt;code&gt;refs/heads/master&lt;/code&gt; 를 찾을 수 있음 ) &lt;code&gt;origin&lt;/code&gt; 리포지토리 에서 동일한 리퍼 (예 : &lt;code&gt;refs/heads/master&lt;/code&gt; )를 업데이트 합니다. 경우 &lt;code&gt;master&lt;/code&gt; 원격으로 존재하지 않았다, 그것은이 생성 된 것을 알 수있다.</target>
        </trans-unit>
        <trans-unit id="ccef9d1bcc3ad53f8d4e9015291e141315fc185c" translate="yes" xml:space="preserve">
          <source>Find as good common ancestors as possible for a merge</source>
          <target state="translated">합병을 위해 가능한 한 공통 조상을 찾으십시오</target>
        </trans-unit>
        <trans-unit id="d3f173da3a7dce0bd9994325b78952d16aab8240" translate="yes" xml:space="preserve">
          <source>Find commits yet to be applied to upstream</source>
          <target state="translated">업스트림에 아직 적용되지 않은 커밋 찾기</target>
        </trans-unit>
        <trans-unit id="f766cd71208fbf6c57bd1c63b40f06ddd3b5b9dc" translate="yes" xml:space="preserve">
          <source>Find first tagged version including a given fix</source>
          <target state="translated">주어진 수정 사항을 포함하여 처음 태그 된 버전 찾기</target>
        </trans-unit>
        <trans-unit id="df9e9c717faf5fac976a38f227398efdc30aeda9" translate="yes" xml:space="preserve">
          <source>Find redundant pack files</source>
          <target state="translated">중복 팩 파일 찾기</target>
        </trans-unit>
        <trans-unit id="44f9539ac1c361035e9a88da329c269fe8a0f4cb" translate="yes" xml:space="preserve">
          <source>Find symbolic names for given revs</source>
          <target state="translated">주어진 개정에 대한 상징적 이름 찾기</target>
        </trans-unit>
        <trans-unit id="f381cb9cf3280c2142361c5998997b7124410055" translate="yes" xml:space="preserve">
          <source>Find the color configured for &lt;code&gt;name&lt;/code&gt; (e.g. &lt;code&gt;color.diff.new&lt;/code&gt;) and output it as the ANSI color escape sequence to the standard output. The optional &lt;code&gt;default&lt;/code&gt; parameter is used instead, if there is no color configured for &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 에 구성된 색상 (예 : &lt;code&gt;color.diff.new&lt;/code&gt; )을 찾아 ANSI 색상 이스케이프 시퀀스로 표준 출력에 출력하십시오. &lt;code&gt;name&lt;/code&gt; 에 색상이 구성되지 않은 경우 선택적 &lt;code&gt;default&lt;/code&gt; 매개 변수가 대신 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="40d2e7dbd88f8b4a905f40b739ac46054d6c280f" translate="yes" xml:space="preserve">
          <source>Find the color setting for &lt;code&gt;name&lt;/code&gt; (e.g. &lt;code&gt;color.diff&lt;/code&gt;) and output &quot;true&quot; or &quot;false&quot;. &lt;code&gt;stdout-is-tty&lt;/code&gt; should be either &quot;true&quot; or &quot;false&quot;, and is taken into account when configuration says &quot;auto&quot;. If &lt;code&gt;stdout-is-tty&lt;/code&gt; is missing, then checks the standard output of the command itself, and exits with status 0 if color is to be used, or exits with status 1 otherwise. When the color setting for &lt;code&gt;name&lt;/code&gt; is undefined, the command uses &lt;code&gt;color.ui&lt;/code&gt; as fallback.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 의 색상 설정 (예 : &lt;code&gt;color.diff&lt;/code&gt; )을 찾고 &quot;true&quot;또는 &quot;false&quot;를 출력하십시오. &lt;code&gt;stdout-is-tty&lt;/code&gt; 는 &quot;true&quot;또는 &quot;false&quot;여야하며 구성에 &quot;auto&quot;가 표시 될 때 고려됩니다. 경우 &lt;code&gt;stdout-is-tty&lt;/code&gt; 누락 후 명령 자체의 표준 출력을 검사하고, 종료 상태 0 컬러가 사용될 경우, 또는 다른 상태 (1)과 종료. &lt;code&gt;name&lt;/code&gt; 의 색상 설정 이 정의되지 않은 경우 명령은 &lt;code&gt;color.ui&lt;/code&gt; 를 대체로 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="df59454620e80f086423090568733ac46b2847e0" translate="yes" xml:space="preserve">
          <source>Find the point at which a branch (or any history that leads to &amp;lt;commit&amp;gt;) forked from another branch (or any reference) &amp;lt;ref&amp;gt;. This does not just look for the common ancestor of the two commits, but also takes into account the reflog of &amp;lt;ref&amp;gt; to see if the history leading to &amp;lt;commit&amp;gt; forked from an earlier incarnation of the branch &amp;lt;ref&amp;gt; (see discussion on this mode below).</source>
          <target state="translated">다른 지점 (또는 참조) &amp;lt;ref&amp;gt;에서 지점 (또는 &amp;lt;commit&amp;gt;으로 이어지는 기록)이 분기 된 지점을 찾습니다. 이것은 두 커밋의 공통 조상을 찾는 것이 아니라 &amp;lt;ref&amp;gt;의 참조를 고려하여 &amp;lt;commit&amp;gt;으로 이어지는 역사가 &amp;lt;ref&amp;gt; 지점의 이전 화신에서 분기되었는지 확인합니다 ( 아래이 모드).</target>
        </trans-unit>
        <trans-unit id="9da189d134fc7190f0c6c1f5c3193ab5948bf13c" translate="yes" xml:space="preserve">
          <source>Finding commits referencing a file with given content</source>
          <target state="translated">주어진 내용으로 파일을 참조하는 커밋 찾기</target>
        </trans-unit>
        <trans-unit id="e333b71e49766be9f1d76f262411fa340daf0c70" translate="yes" xml:space="preserve">
          <source>Finding commits which commit messages matches given search term.</source>
          <target state="translated">주어진 검색어와 일치하는 커밋 메시지를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="1eaaf96aa600c577b3f3a9747228f1b65b0ceefc" translate="yes" xml:space="preserve">
          <source>Finding files</source>
          <target state="translated">파일 찾기</target>
        </trans-unit>
        <trans-unit id="2fc00785f4570abeeda498c54f0284462aed8b44" translate="yes" xml:space="preserve">
          <source>Finding performance regressions</source>
          <target state="translated">성능 회귀 찾기</target>
        </trans-unit>
        <trans-unit id="bc2b131e580f41edfbbcd8f6c9c60a09f1a25b76" translate="yes" xml:space="preserve">
          <source>Finds symbolic names suitable for human digestion for revisions given in any format parsable by &lt;code&gt;git rev-parse&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git rev-parse&lt;/code&gt; 가 구문 분석 할 수있는 형식으로 지정된 개정판에 대해 사람의 소화에 적합한 기호 이름을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="7d4b2472daa261c193507bf4d856ace529dabcc6" translate="yes" xml:space="preserve">
          <source>First let&amp;rsquo;s assume your &lt;code&gt;topic&lt;/code&gt; is based on branch &lt;code&gt;next&lt;/code&gt;. For example, a feature developed in &lt;code&gt;topic&lt;/code&gt; depends on some functionality which is found in &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">먼저 &lt;code&gt;topic&lt;/code&gt; &lt;code&gt;next&lt;/code&gt; 분기를 기반으로 한다고 가정 해 봅시다 . 예를 들어, &lt;code&gt;topic&lt;/code&gt; 에서 개발 된 기능은 &lt;code&gt;next&lt;/code&gt; 있는 일부 기능에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="ed8007e4d48fad1e0a696af768b6078f3fa95c0a" translate="yes" xml:space="preserve">
          <source>First let&amp;rsquo;s define &quot;best bisection point&quot;. We will say that a commit X is a best bisection point or a best bisection commit if knowing its state (&quot;good&quot; or &quot;bad&quot;) gives as much information as possible whether the state of the commit happens to be &quot;good&quot; or &quot;bad&quot;.</source>
          <target state="translated">먼저 &quot;최상의이 분점&quot;을 정의하겠습니다. 커밋 X가 커밋 상태가 &quot;good&quot;또는 &quot;bad&quot;인지 여부를 가능한 한 많은 정보를 제공하면 커밋 X가 최상의이 분점 또는 최상의 이분법 커밋이라고 말할 것입니다. 나쁜&quot;.</target>
        </trans-unit>
        <trans-unit id="ee7f8a8fdabeacb4105bb68c4dfba6a20cea041f" translate="yes" xml:space="preserve">
          <source>First merges by themselves can introduce some regressions even when the merge needs no source code conflict resolution. This is because a semantic change can happen in one branch while the other branch is not aware of it.</source>
          <target state="translated">첫 번째 병합 자체는 병합에 소스 코드 충돌 해결이 필요하지 않은 경우에도 약간의 회귀를 유발할 수 있습니다. 한 지점에서 의미 변경이 발생할 수 있지만 다른 지점은이를 인식하지 못하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="05a55fcafe087cbd44c02228e1ac75a34a01c1f1" translate="yes" xml:space="preserve">
          <source>First, build a history graph in the same way that &lt;code&gt;--full-history&lt;/code&gt; with parent rewriting does (see above).</source>
          <target state="translated">먼저 부모 재 작성이 있는 &lt;code&gt;--full-history&lt;/code&gt; 와 동일한 방식으로 기록 그래프를 작성하십시오 (위 참조).</target>
        </trans-unit>
        <trans-unit id="08310df25f406cc10b8d6127f9ec844567b780fb" translate="yes" xml:space="preserve">
          <source>First, if you wish to continue to release maintenance fixes for the feature release made before the recent one, then you must create another branch to track commits for that previous release.</source>
          <target state="translated">먼저, 최신 기능 릴리스 이전에 작성된 기능 릴리스에 대한 유지 보수 수정 사항을 계속 릴리스하려면 이전 릴리스의 커미트를 추적하기 위해 다른 브랜치를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="3f7b81f4c441b31ef96f877571ae9e6d0b762fd6" translate="yes" xml:space="preserve">
          <source>First, in .gitattributes, you would assign the &lt;code&gt;diff&lt;/code&gt; attribute for paths.</source>
          <target state="translated">먼저 .gitattributes에서 경로에 &lt;code&gt;diff&lt;/code&gt; 속성을 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="b3f5f5cacf6c72eb426cf54eb30cee145c3bf1f2" translate="yes" xml:space="preserve">
          <source>First, install version 2.1 or higher of cvsps from &lt;a href=&quot;https://github.com/andreyvit/cvsps&quot;&gt;https://github.com/andreyvit/cvsps&lt;/a&gt; and make sure it is in your path. Then cd to a checked out CVS working directory of the project you are interested in and run &lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport[1]&lt;/a&gt;:</source>
          <target state="translated">먼저 &lt;a href=&quot;https://github.com/andreyvit/cvsps&quot;&gt;https://github.com/andreyvit/cvsps&lt;/a&gt; 에서 cvsp 버전 2.1 이상을 설치 하고 경로에 있는지 확인하십시오. 그런 다음 관심있는 프로젝트의 체크 아웃 된 CVS 작업 디렉토리로 cd하고 &lt;a href=&quot;git-cvsimport&quot;&gt;git-cvsimport [1]을 실행하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="576e890855dbcdc8bc3ac7fde0afbe81b0fdd016" translate="yes" xml:space="preserve">
          <source>First, note that you can get documentation for a command such as &lt;code&gt;git log --graph&lt;/code&gt; with:</source>
          <target state="translated">먼저 &lt;code&gt;git log --graph&lt;/code&gt; 와 같은 명령에 대한 문서를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a679f4d1f2379fb3e8b418dd1cdea69390f805f" translate="yes" xml:space="preserve">
          <source>First, reset the history back one commit so that we remove the original commit, but leave the working tree with all the changes. The -N ensures that any new files added with &lt;code&gt;HEAD&lt;/code&gt; are still marked so that &lt;code&gt;git add -p&lt;/code&gt; will find them.</source>
          <target state="translated">먼저 원래 커밋을 제거하기 위해 기록을 한 커밋으로 다시 설정하지만 작업 트리에는 모든 변경 사항이 남아 있습니다. -N은 &lt;code&gt;HEAD&lt;/code&gt; 로 추가 된 새 파일 이 여전히 표시되도록하여 &lt;code&gt;git add -p&lt;/code&gt; 가 해당 파일 을 찾을 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="eac258ebc7c4ff84505375d195a1e24d04961706" translate="yes" xml:space="preserve">
          <source>First, use &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch[1]&lt;/a&gt;; for example:</source>
          <target state="translated">먼저 &lt;a href=&quot;git-format-patch&quot;&gt;git-format-patch [1]을 사용하십시오&lt;/a&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af62e3f15d84326a813952b253791dac4ec57aaa" translate="yes" xml:space="preserve">
          <source>First, you need to create an empty repository on the remote machine that will house your public repository. This empty repository will be populated and be kept up to date by pushing into it later. Obviously, this repository creation needs to be done only once.</source>
          <target state="translated">먼저 원격 저장소에서 공용 저장소를 보관할 빈 저장소를 작성해야합니다. 이 빈 저장소는 나중에 채워져 채워지고 최신 상태로 유지됩니다. 분명히이 저장소 작성은 한 번만 수행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="52835c0708aa62a7396cacc7dfc2df24ce8a002c" translate="yes" xml:space="preserve">
          <source>Fix a &quot;thin&quot; pack produced by &lt;code&gt;git pack-objects --thin&lt;/code&gt; (see &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects[1]&lt;/a&gt; for details) by adding the excluded objects the deltified objects are based on to the pack. This option only makes sense in conjunction with --stdin.</source>
          <target state="translated">deltified 객체가 기반으로하는 제외 된 객체를 팩에 추가하여 &lt;code&gt;git pack-objects --thin&lt;/code&gt; 생성 한 &quot;thin&quot;팩을 수정합니다 ( 세부 사항 은 &lt;a href=&quot;git-pack-objects&quot;&gt;git-pack-objects [1]&lt;/a&gt; 참조). 이 옵션은 --stdin과 함께 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6bef9039e49cd5a1bb992311087de16992b814ac" translate="yes" xml:space="preserve">
          <source>Fix the ignore-paths or SVN permissions problem that caused &quot;r2&quot; to be incomplete in the first place. Then:</source>
          <target state="translated">&quot;r2&quot;가 처음에 불완전하게했던 ignore-paths 또는 SVN 권한 문제를 수정하십시오. 그때:</target>
        </trans-unit>
        <trans-unit id="bf5e51b162922584144bf607debb47b58ed7a8df" translate="yes" xml:space="preserve">
          <source>Fixing a mistake by rewriting history</source>
          <target state="translated">기록을 다시 작성하여 실수 수정</target>
        </trans-unit>
        <trans-unit id="afb2d222f3591d3622f9d0c44f698fe7e6dc0a83" translate="yes" xml:space="preserve">
          <source>Fixing a mistake with a new commit</source>
          <target state="translated">새로운 커밋으로 실수 수정</target>
        </trans-unit>
        <trans-unit id="c169f9b52cd517560d8a456346335c3aedbfac2b" translate="yes" xml:space="preserve">
          <source>Fixing mistakes</source>
          <target state="translated">실수 수정</target>
        </trans-unit>
        <trans-unit id="de18d069db0d9d56daecfccdb3a27275518bc1f7" translate="yes" xml:space="preserve">
          <source>Flags and parameters to be parsed.</source>
          <target state="translated">구문 분석 할 플래그 및 매개 변수</target>
        </trans-unit>
        <trans-unit id="8a2fcacfdef0a8b1fd083381230b0ac0cbbdea61" translate="yes" xml:space="preserve">
          <source>Follow merge ancestry and attempt to import trees that have been merged from. Specify a depth greater than 1 if patch logs have been pruned.</source>
          <target state="translated">병합 조상에 따라 병합 된 트리를 가져 오십시오. 패치 로그가 제거 된 경우 1보다 큰 깊이를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="fc08e4a2c4c96e25ad3223cdd944785cb30a915c" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit.</source>
          <target state="translated">병합 커밋을 볼 때 첫 번째 부모 커밋 만 따르십시오.</target>
        </trans-unit>
        <trans-unit id="f48973c6479f97ed9cbdd1aa747abb3d724dfc88" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit. This is useful when you wish to not match tags on branches merged in the history of the target commit.</source>
          <target state="translated">병합 커밋을 볼 때 첫 번째 부모 커밋 만 따르십시오. 대상 커밋 기록에 병합 된 분기의 태그를 일치시키지 않으려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="37deb1921d5628bb8484cd98e5d1812d850199d4" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit. This option can be used to determine when a line was introduced to a particular integration branch, rather than when it was introduced to the history overall.</source>
          <target state="translated">병합 커밋을 볼 때 첫 번째 부모 커밋 만 따르십시오. 이 옵션은 라인이 전체 히스토리에 도입 된시기가 아니라 특정 통합 분기에 도입 된시기를 판별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="592429d37f44072b1083ee8b6715edf266446955" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit. This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge.</source>
          <target state="translated">병합 커밋을 볼 때 첫 번째 부모 커밋 만 따르십시오. 이 옵션은 특정 토픽 브랜치의 진화를 볼 때 더 나은 개요를 제공 할 수 있습니다. 토픽 브랜치로 병합하는 것은 수시로 업데이트 된 업스트림에 맞게 조정하는 경향이 있기 때문에이 옵션을 사용하면 가져온 개별 커밋을 무시할 수 있습니다. 그러한 합병으로 당신의 역사.</target>
        </trans-unit>
        <trans-unit id="d67b9781a4352de8f66549a8b248fd66aceb7858" translate="yes" xml:space="preserve">
          <source>Follow only the first parent commit upon seeing a merge commit. This option can give a better overview when viewing the evolution of a particular topic branch, because merges into a topic branch tend to be only about adjusting to updated upstream from time to time, and this option allows you to ignore the individual commits brought in to your history by such a merge. Cannot be combined with --bisect.</source>
          <target state="translated">병합 커밋을 볼 때 첫 번째 부모 커밋 만 따르십시오. 이 옵션은 특정 토픽 브랜치의 진화를 볼 때 더 나은 개요를 제공 할 수 있습니다. 토픽 브랜치로의 병합은 때때로 업스트림으로 업데이트되도록 조정하는 경향이 있기 때문에이 옵션을 사용하면 개별 커밋을 무시할 수 있습니다. 그러한 합병으로 당신의 역사. --bisect와 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b82a1274463e2bfba901905e39b02d331c44520" translate="yes" xml:space="preserve">
          <source>Following general best practices</source>
          <target state="translated">일반적인 모범 사례 준수</target>
        </trans-unit>
        <trans-unit id="788b60e8a3fa302c96ca5000ec7c36053afb1c38" translate="yes" xml:space="preserve">
          <source>Following the headers, a series of lines are printed for tracked entries. One of three different line formats may be used to describe an entry depending on the type of change. Tracked entries are printed in an undefined order; parsers should allow for a mixture of the 3 line types in any order.</source>
          <target state="translated">헤더 다음에 항목을 추적하기 위해 일련의 행이 인쇄됩니다. 변경 유형에 따라 3 가지 다른 라인 형식 중 하나를 사용하여 항목을 설명 할 수 있습니다. 추적 된 항목은 정의되지 않은 순서로 인쇄됩니다. 파서는 임의의 순서로 3 가지 라인 유형의 혼합을 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0af351e25b3235e5cb0b144d879a5948cd0b6627" translate="yes" xml:space="preserve">
          <source>Following the tracked entries (and if requested), a series of lines will be printed for untracked and then ignored items found in the worktree.</source>
          <target state="translated">추적 된 항목 (및 요청 된 경우)에 따라 추적되지 않은 작업에 대해 일련의 행이 인쇄 된 다음 작업 트리에서 찾은 항목이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="18388d4087a6542b5572bea29a06b35e2aae5326" translate="yes" xml:space="preserve">
          <source>Following these N lines, one-line log for each commit is displayed, indented N places. If a commit is on the I-th branch, the I-th indentation character shows a &lt;code&gt;+&lt;/code&gt; sign; otherwise it shows a space. Merge commits are denoted by a &lt;code&gt;-&lt;/code&gt; sign. Each commit shows a short name that can be used as an extended SHA-1 to name that commit.</source>
          <target state="translated">이 N 행 다음에는 각 커밋에 대한 한 줄 로그가 N 자리만큼 들여 쓰기되어 표시됩니다. 커밋이 I 번째 분기에있는 경우 I 번째 들여 쓰기 문자는 &lt;code&gt;+&lt;/code&gt; 부호를 표시합니다. 그렇지 않으면 공백이 표시됩니다. 병합 커밋은 &lt;code&gt;-&lt;/code&gt; 기호 로 표시됩니다 . 각 커밋에는 해당 커밋의 이름을 지정하기 위해 확장 SHA-1로 사용할 수있는 짧은 이름이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="348633bb6883a2c8b3944ebb9c0c3986369c6bb3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;--cc&lt;/code&gt;, only the destination or final path is shown even if the file was renamed on any side of history. With &lt;code&gt;--combined-all-paths&lt;/code&gt;, the name of the path in each parent is shown followed by the name of the path in the merge commit.</source>
          <target state="translated">들면 &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;--cc&lt;/code&gt; 파일이 과거에 어느 쪽 개명되었다하더라도, 단지 최종 도착 경로가 도시되어있다. 함께 &lt;code&gt;--combined-all-paths&lt;/code&gt; , 각 상위의 경로 이름은 병합을 저지에서 경로 이름 앞에 도시된다.</target>
        </trans-unit>
        <trans-unit id="299f58cbaec7164b54b0f4129532e8b5c1642be3" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;branch&lt;/code&gt; and &lt;code&gt;tag&lt;/code&gt;, display the urls that will be used for copying when creating the branch or tag.</source>
          <target state="translated">들어 &lt;code&gt;branch&lt;/code&gt; 와 &lt;code&gt;tag&lt;/code&gt; , 분기 또는 태그를 생성 할 때 복사하는 데 사용되는 URL을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="007222e8d7dfa1e11f08c139bdea5864653b03fb" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;dcommit&lt;/code&gt;, print out the series of Git arguments that would show which diffs would be committed to SVN.</source>
          <target state="translated">들어 &lt;code&gt;dcommit&lt;/code&gt; , 차이점은 SVN하기 위해 최선을 다하고 될 것이다 보여줄 것이다 망할 놈의 인수의 시리즈를 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7661574c1331f1ffadb88e65b09fb7bbb3d5b369" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;rebase&lt;/code&gt;, display the local branch associated with the upstream svn repository associated with the current branch and the URL of svn repository that will be fetched from.</source>
          <target state="translated">들어 &lt;code&gt;rebase&lt;/code&gt; , 현재의 지점과에서 가져온 것입니다 SVN 저장소의 URL과 관련된 업스트림 SVN 저장소와 관련된 현지 지점을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="8054fb75013a9d33733a54185710f048c11e6754" translate="yes" xml:space="preserve">
          <source>For Git developers, &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial[7]&lt;/a&gt; goes into detail on the lower-level Git mechanisms involved in, for example, creating a new commit.</source>
          <target state="translated">Git 개발자에게 &lt;a href=&quot;gitcore-tutorial&quot;&gt;gitcore-tutorial [7]&lt;/a&gt; 은 새로운 커밋 생성과 같은 하위 레벨 Git 메커니즘에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9c7a8b6d1a7a0700f3cd22ce6172861bfe044c11" translate="yes" xml:space="preserve">
          <source>For SSH clients that will make commits, make sure their server-side .ssh/environment files (or .bashrc, etc., according to their specific shell) export appropriate values for GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_COMMITTER_NAME, and GIT_COMMITTER_EMAIL. For SSH clients whose login shell is bash, .bashrc may be a reasonable alternative.</source>
          <target state="translated">커밋 할 SSH 클라이언트의 경우 서버 측 .ssh / environment 파일 (또는 특정 쉘에 따라 .bashrc 등)이 GIT_AUTHOR_NAME, GIT_AUTHOR_EMAIL, GIT_COMMITTER_NAME 및 GIT_COMMITTER_EMAIL에 적절한 값을 내보내도록하십시오. 로그인 쉘이 bash 인 SSH 클라이언트의 경우 .bashrc가 적합한 대안 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e127a96a43fc87667b0c86a8698d094b3fabedbe" translate="yes" xml:space="preserve">
          <source>For URLs in &lt;code&gt;https://weak.example.com&lt;/code&gt;, &lt;code&gt;http.sslVerify&lt;/code&gt; is set to false, while it is set to &lt;code&gt;true&lt;/code&gt; for all others:</source>
          <target state="translated">&lt;code&gt;https://weak.example.com&lt;/code&gt; 의 URL의 경우 &lt;code&gt;http.sslVerify&lt;/code&gt; 는 false로 설정되고 다른 모든 URL은 &lt;code&gt;true&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="701bbbb19204ae1c36fbfa4b6462dff9d4624e60" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;get&lt;/code&gt; operation, the helper should produce a list of attributes on stdout in the same format (see &lt;a href=&quot;git-credential&quot;&gt;git-credential[1]&lt;/a&gt; for common attributes). A helper is free to produce a subset, or even no values at all if it has nothing useful to provide. Any provided attributes will overwrite those already known about by Git&amp;rsquo;s credential subsystem.</source>
          <target state="translated">A의 &lt;code&gt;get&lt;/code&gt; 동작 헬퍼 (참고 같은 형식의 표준 출력에 대한 속성의리스트를 생성한다 &lt;a href=&quot;git-credential&quot;&gt;자식-자격 [1]&lt;/a&gt; 일반 속성). 도우미는 무료로 하위 집합을 생성하거나 제공 할 유용한 값이없는 경우 값이 전혀 없습니다. 제공된 속성은 Git의 자격 증명 하위 시스템에서 이미 알려진 속성을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="ef97080144d6e0b76f4c32d65bbd8d420f1d9d3f" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;store&lt;/code&gt; or &lt;code&gt;erase&lt;/code&gt; operation, the helper&amp;rsquo;s output is ignored.</source>
          <target state="translated">A의 &lt;code&gt;store&lt;/code&gt; 또는 &lt;code&gt;erase&lt;/code&gt; 작업, 헬퍼의 출력은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="51c95f036bd90f837a4d78c935d1c885601df8ec" translate="yes" xml:space="preserve">
          <source>For a custom merge command, specify whether the exit code of the merge command can be used to determine whether the merge was successful. If this is not set to true then the merge target file timestamp is checked and the merge assumed to have been successful if the file has been updated, otherwise the user is prompted to indicate the success of the merge.</source>
          <target state="translated">사용자 정의 병합 명령의 경우, 병합 명령의 종료 코드를 사용하여 병합의 성공 여부를 판별하십시오. 이것이 true로 설정되지 않으면 병합 대상 파일 타임 스탬프가 검사되고 파일이 업데이트 된 경우 병합이 성공한 것으로 가정하고, 그렇지 않으면 사용자에게 병합 성공을 표시하라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="832a920de5e5a1607e20fda89c6b16105d6a3d66" translate="yes" xml:space="preserve">
          <source>For a description of which objects are considered for pruning, see &lt;code&gt;git fsck&lt;/code&gt;'s --unreachable option.</source>
          <target state="translated">잘라내 기로 간주되는 객체에 대한 설명은 &lt;code&gt;git fsck&lt;/code&gt; 의 --unreachable 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7772aa877c345ccdb695091fd19f024126a4a0b8" translate="yes" xml:space="preserve">
          <source>For a detailed description of &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; see above under &lt;code&gt;from&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 에 대한 자세한 설명은 &lt;code&gt;from&lt;/code&gt; 아래 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="97b7c41fd980027cd240574fa45f8b9cf3a30c50" translate="yes" xml:space="preserve">
          <source>For a detailed description of &lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; see above under &lt;code&gt;commit&lt;/code&gt; and &lt;code&gt;from&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;ref&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 에 대한 자세한 설명 은 위의 &lt;code&gt;commit&lt;/code&gt; 및 &lt;code&gt;from&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4f4b9fba6569cfb2eebe32e9b505f5e163da8ae" translate="yes" xml:space="preserve">
          <source>For a failed update, more details are given:</source>
          <target state="translated">실패한 업데이트에 대한 자세한 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="243468740a36ab67df241df82903537b2a102239" translate="yes" xml:space="preserve">
          <source>For a more complete list of ways to spell &amp;lt;commit&amp;gt;, see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;. However, &quot;diff&quot; is about comparing two &lt;code&gt;endpoints&lt;/code&gt;, not ranges, and the range notations (&quot;&amp;lt;commit&amp;gt;..&amp;lt;commit&amp;gt;&quot; and &quot;&amp;lt;commit&amp;gt;...&amp;lt;commit&amp;gt;&quot;) do not mean a range as defined in the &quot;SPECIFYING RANGES&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">&amp;lt;commit&amp;gt;을 철자하는 방법에 대한 전체 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]의&lt;/a&gt; &quot; SPECIFYING REVISIONS&quot;섹션을 참조하십시오 . 그러나 &quot;diff&quot;는 범위가 아닌 두 &lt;code&gt;endpoints&lt;/code&gt; 비교 하는 것이며 범위 표기법 ( &quot;&amp;lt;commit&amp;gt; .. &amp;lt;commit&amp;gt;&quot;및 &quot;&amp;lt;commit&amp;gt; ... &amp;lt;commit&amp;gt;&quot;)은 정의 된 범위를 의미하지 않습니다. &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions의&lt;/a&gt; &quot; SPECIFYING RANGES &quot;섹션 [7] .</target>
        </trans-unit>
        <trans-unit id="aef391cab8f8e654bd28a4ebab3ff359b2dd758d" translate="yes" xml:space="preserve">
          <source>For a more complete list of ways to spell object names, see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">객체 이름을 철자하는 방법에 대한 전체 목록은 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]의&lt;/a&gt; &quot; SPECIFYING REVISIONS&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ffb03e9988d5aab6ca13a5c4410e25c3bc4d2c1f" translate="yes" xml:space="preserve">
          <source>For a more detailed discussion of the procedure and additional tips, see the &quot;INTERACTIVE MODE&quot; section of &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;.</source>
          <target state="translated">절차 및 추가 팁에 대한 자세한 내용은 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; 의 &quot;대화식 모드&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="21840545ec0ef1fb11dadc3e0bd425ddda71d447" translate="yes" xml:space="preserve">
          <source>For a path that is unmerged, &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called with 1 parameter, &amp;lt;path&amp;gt;.</source>
          <target state="translated">병합되지 않은 경로의 경우 1 개의 매개 변수 &amp;lt;path&amp;gt;와 함께 &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bf84b30d98b0b2aee4084cebd6a510d7735317e2" translate="yes" xml:space="preserve">
          <source>For a regular file &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;echo HEAD:f | git cat-file --batch&lt;/code&gt; would print</source>
          <target state="translated">일반 파일 &lt;code&gt;f&lt;/code&gt; 의 경우 &lt;code&gt;echo HEAD:f | git cat-file --batch&lt;/code&gt; 인쇄</target>
        </trans-unit>
        <trans-unit id="3d0f9234523f6052cd5829e5dd1cdac95a9b09fd" translate="yes" xml:space="preserve">
          <source>For a simple local test, you can use &lt;a href=&quot;git-remote-ext&quot;&gt;git-remote-ext[1]&lt;/a&gt;:</source>
          <target state="translated">간단한 로컬 테스트를 위해 &lt;a href=&quot;git-remote-ext&quot;&gt;git-remote-ext [1]을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="428bfb3c06af83865df8238da30e9618f9cb0a09" translate="yes" xml:space="preserve">
          <source>For a successfully fetched ref, the summary shows the old and new values of the ref in a form suitable for using as an argument to &lt;code&gt;git log&lt;/code&gt; (this is &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; in most cases, and &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; for forced non-fast-forward updates).</source>
          <target state="translated">성공적으로 가져온 참조의 경우 요약은 참조의 이전 값과 새 값을 &lt;code&gt;git log&lt;/code&gt; 의 인수로 사용하기에 적합한 형식으로 표시합니다 ( 대부분의 경우 &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; 비 신속 강제 업데이트의 경우 &amp;lt;신규&amp;gt; ).</target>
        </trans-unit>
        <trans-unit id="95550d69988e7a758b9c94b13942bde9ad57e2ef" translate="yes" xml:space="preserve">
          <source>For a successfully pushed ref, the summary shows the old and new values of the ref in a form suitable for using as an argument to &lt;code&gt;git log&lt;/code&gt; (this is &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; in most cases, and &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; for forced non-fast-forward updates).</source>
          <target state="translated">성공적으로 푸시 된 참조의 경우, 요약은 참조의 이전 값과 새 값을 &lt;code&gt;git log&lt;/code&gt; 의 인수로 사용하기에 적합한 형식으로 표시합니다 ( 대부분의 경우 &lt;code&gt;&amp;lt;old&amp;gt;..&amp;lt;new&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;old&amp;gt;...&amp;lt;new&amp;gt;&lt;/code&gt; 비 신속 강제 업데이트의 경우 &amp;lt;신규&amp;gt; ).</target>
        </trans-unit>
        <trans-unit id="d2bfe73291a6ef412f90bf2eac1210664a9553b3" translate="yes" xml:space="preserve">
          <source>For all objects, the following names can be used:</source>
          <target state="translated">모든 객체에 대해 다음 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96992b112d12dd337ecf884c867dcddc44e026cf" translate="yes" xml:space="preserve">
          <source>For all options that output values and/or keys, always end values with the null character (instead of a newline). Use newline instead as a delimiter between key and value. This allows for secure parsing of the output without getting confused e.g. by values that contain line breaks.</source>
          <target state="translated">값 및 / 또는 키를 출력하는 모든 옵션의 경우 항상 줄 바꿈 대신 널 문자로 값을 종료하십시오. 키와 값 사이의 구분자로 줄 바꿈을 대신 사용하십시오. 따라서 줄 바꿈이 포함 된 값과 혼동되지 않고 출력을 안전하게 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ac2c111de5df363fa2f5b2b630af5f75a90bcb1" translate="yes" xml:space="preserve">
          <source>For an unmerged path, instead of recording a single mode/SHA-1 pair, the index records up to three such pairs; one from tree O in stage 1, A in stage 2, and B in stage 3. This information can be used by the user (or the porcelain) to see what should eventually be recorded at the path. (see &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree[1]&lt;/a&gt; for more information on state)</source>
          <target state="translated">병합되지 않은 경로의 경우 단일 모드 / SHA-1 쌍을 기록하는 대신 인덱스는 최대 3 개의 이러한 쌍을 기록합니다. 1 단계의 트리 O, 2 단계의 A, 3 단계의 B 중 하나입니다.이 정보는 사용자 (또는 도자기)가 경로에 무엇을 기록해야하는지 알 수 있습니다. ( 상태에 대한 자세한 내용 은 &lt;a href=&quot;git-read-tree&quot;&gt;git-read-tree [1]&lt;/a&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="43b2d74a2014d25aa6c53b32650e8baad61de67e" translate="yes" xml:space="preserve">
          <source>For any commit graph, you can see the number associated with each commit using &quot;git rev-list --bisect-all&quot;.</source>
          <target state="translated">커밋 그래프는 &quot;git rev-list --bisect-all&quot;을 사용하여 각 커밋과 관련된 번호를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="672441c22b399b226ed91a2cbed5740025f9d076" translate="yes" xml:space="preserve">
          <source>For any remote-tracking branch &lt;code&gt;%(upstream)&lt;/code&gt;, &lt;code&gt;%(upstream:remotename)&lt;/code&gt; and &lt;code&gt;%(upstream:remoteref)&lt;/code&gt; refer to the name of the remote and the name of the tracked remote ref, respectively. In other words, the remote-tracking branch can be updated explicitly and individually by using the refspec &lt;code&gt;%(upstream:remoteref):%(upstream)&lt;/code&gt; to fetch from &lt;code&gt;%(upstream:remotename)&lt;/code&gt;.</source>
          <target state="translated">원격 추적 브랜치 &lt;code&gt;%(upstream)&lt;/code&gt; , &lt;code&gt;%(upstream:remotename)&lt;/code&gt; 및 &lt;code&gt;%(upstream:remoteref)&lt;/code&gt; 는 각각 원격의 이름과 추적 된 원격 참조의 이름을 나타냅니다. 즉, refspec &lt;code&gt;%(upstream:remoteref):%(upstream)&lt;/code&gt; 을 사용하여 &lt;code&gt;%(upstream:remotename)&lt;/code&gt; 에서 가져 오면 원격 추적 분기를 명시적이고 개별적으로 업데이트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="242026e8d7d0593118b4fae738fc0c3f1a90be23" translate="yes" xml:space="preserve">
          <source>For atomicity, &lt;code&gt;git apply&lt;/code&gt; by default fails the whole patch and does not touch the working tree when some of the hunks do not apply. This option makes it apply the parts of the patch that are applicable, and leave the rejected hunks in corresponding *.rej files.</source>
          <target state="translated">원자 성의 경우 기본적으로 &lt;code&gt;git apply&lt;/code&gt; 는 전체 패치에 실패하고 일부 덩어리가 적용되지 않으면 작업 트리를 건드리지 않습니다. 이 옵션을 사용하면 적용 가능한 패치 부분을 적용하고 거부 된 덩어리를 해당 * .rej 파일에 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="8d098e130baba0ccc99da718229f5fc6bc213a77" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, the &lt;code&gt;crlf&lt;/code&gt; attribute is interpreted as follows:</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;code&gt;crlf&lt;/code&gt; 속성은 다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="816a47e0ab5f0e7c8c410570167eb66d775695ae" translate="yes" xml:space="preserve">
          <source>For best consistency with &lt;code&gt;cvs&lt;/code&gt;, it is probably best to override the defaults by setting &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; to true, and &lt;code&gt;gitcvs.allBinary&lt;/code&gt; to &quot;guess&quot;.</source>
          <target state="translated">&lt;code&gt;cvs&lt;/code&gt; 와의 일관성을 유지 하려면 &lt;code&gt;gitcvs.usecrlfattr&lt;/code&gt; 을 true 로 설정 하고 &lt;code&gt;gitcvs.allBinary&lt;/code&gt; 를 &quot;guess&quot; 로 설정하여 기본값을 재정의하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="bad93aa83b2df49f46d609a291da6014ee26a719" translate="yes" xml:space="preserve">
          <source>For best results, &lt;code&gt;clean&lt;/code&gt; should not alter its output further if it is run twice (&quot;clean&amp;rarr;clean&quot; should be equivalent to &quot;clean&quot;), and multiple &lt;code&gt;smudge&lt;/code&gt; commands should not alter &lt;code&gt;clean&lt;/code&gt;'s output (&quot;smudge&amp;rarr;smudge&amp;rarr;clean&quot; should be equivalent to &quot;clean&quot;). See the section on merging below.</source>
          <target state="translated">최상의 결과를 얻으려면 &lt;code&gt;clean&lt;/code&gt; 가 두 번 실행되는 추가하면 출력을 변경해서는 안 ( &quot;청소 &amp;rarr; 청소&quot; &quot;깨끗한&quot;에 해당되어야한다), 여러 &lt;code&gt;smudge&lt;/code&gt; 명령해야 변경하지 &lt;code&gt;clean&lt;/code&gt; (의 출력 &quot;얼룩 &amp;rarr; 얼룩 &amp;rarr; 깨끗한&quot; &quot;clean&quot;과 동일해야합니다.) 아래의 병합 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8d3928084bacb031775f5d7bad0ceaa321b4778c" translate="yes" xml:space="preserve">
          <source>For blobs and trees, you can&amp;rsquo;t do the same, but you can still examine them. You can just do</source>
          <target state="translated">얼룩과 나무의 경우 동일한 작업을 수행 할 수 없지만 여전히 검사 할 수 있습니다. 당신은 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d0eec01499f14d036682e7faa93df840595c4ccf" translate="yes" xml:space="preserve">
          <source>For commit and tag objects, the special &lt;code&gt;creatordate&lt;/code&gt; and &lt;code&gt;creator&lt;/code&gt; fields will correspond to the appropriate date or name-email-date tuple from the &lt;code&gt;committer&lt;/code&gt; or &lt;code&gt;tagger&lt;/code&gt; fields depending on the object type. These are intended for working on a mix of annotated and lightweight tags.</source>
          <target state="translated">커밋 태그 객체의 경우, 특별한 &lt;code&gt;creatordate&lt;/code&gt; 및 &lt;code&gt;creator&lt;/code&gt; 필드는에서 해당 날짜 나 이름 - 이메일 - 날짜 튜플에 해당됩니다 &lt;code&gt;committer&lt;/code&gt; 또는 &lt;code&gt;tagger&lt;/code&gt; 오브젝트 유형에 따라 필드. 이들은 주석이 달린 태그와 가벼운 태그를 혼합하여 작업하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f1ce66454707d43159aa08f01addd1a2cbbd5b3f" translate="yes" xml:space="preserve">
          <source>For commits it shows the log message and textual diff. It also presents the merge commit in a special format as produced by &lt;code&gt;git diff-tree --cc&lt;/code&gt;.</source>
          <target state="translated">커밋의 경우 로그 메시지와 텍스트 차이를 보여줍니다. 또한 &lt;code&gt;git diff-tree --cc&lt;/code&gt; 에 의해 생성 된 병합 커밋을 특별한 형식으로 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="65305ecf02c6387d8a2b51f2d0ea21b43d00656b" translate="yes" xml:space="preserve">
          <source>For commits which do not start empty but become empty after rebasing, see the --empty flag.</source>
          <target state="translated">비어 있지 않고 리베이스 후에 비어있는 커밋에 대해서는 --empty 플래그를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5788d84088826961fe0565ab052c9c41c47117d5" translate="yes" xml:space="preserve">
          <source>For commits, you can just use:</source>
          <target state="translated">커밋의 경우 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="600c796c6fdee3517d0340d7c98d0e629e148085" translate="yes" xml:space="preserve">
          <source>For conflicting paths, the index file records up to three versions, as described in the &quot;TRUE MERGE&quot; section of &lt;a href=&quot;git-merge&quot;&gt;git-merge[1]&lt;/a&gt;. The working tree files will include a description of the conflict bracketed by the usual conflict markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">충돌하는 경로의 경우 인덱스 파일은 &lt;a href=&quot;git-merge&quot;&gt;git-merge [1]&lt;/a&gt; 의 &quot;TRUE MERGE&quot;섹션에 설명 된대로 최대 3 개의 버전을 기록합니다 . 작업 트리 파일에는 일반적인 충돌 마커 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 로 묶인 충돌에 대한 설명이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="35aa73e9eb71becc5a3756c0cf556cc7d0b77d41" translate="yes" xml:space="preserve">
          <source>For conflicting paths, the index file records up to three versions: stage 1 stores the version from the common ancestor, stage 2 from &lt;code&gt;HEAD&lt;/code&gt;, and stage 3 from &lt;code&gt;MERGE_HEAD&lt;/code&gt; (you can inspect the stages with &lt;code&gt;git ls-files -u&lt;/code&gt;). The working tree files contain the result of the &quot;merge&quot; program; i.e. 3-way merge results with familiar conflict markers &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;===&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">충돌하는 경로의 경우 색인 파일은 최대 3 개의 버전을 기록합니다. 1 단계는 공통 조상의 버전, &lt;code&gt;HEAD&lt;/code&gt; 의 2 단계 및 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 의 3 단계를 저장합니다 ( &lt;code&gt;git ls-files -u&lt;/code&gt; 로 스테이지를 검사 할 수 있음 ). 작업 트리 파일에는 &quot;병합&quot;프로그램의 결과가 포함됩니다. 즉, 익숙한 충돌 마커 &lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;===&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 을 사용한 3 방향 병합 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="7a860b5275da5a9c9fab93cf772cd75bc2e0f4eb" translate="yes" xml:space="preserve">
          <source>For consistency, we also try such a trick if &lt;code&gt;man.konqueror.path&lt;/code&gt; is set to something like &lt;code&gt;A_PATH_TO/konqueror&lt;/code&gt;. That means we will try to launch &lt;code&gt;A_PATH_TO/kfmclient&lt;/code&gt; instead.</source>
          <target state="translated">일관성을 유지 하기 위해 &lt;code&gt;man.konqueror.path&lt;/code&gt; 가 &lt;code&gt;A_PATH_TO/konqueror&lt;/code&gt; 와 같은 것으로 설정되어 있으면 그러한 트릭을 시도 합니다. 즉, &lt;code&gt;A_PATH_TO/kfmclient&lt;/code&gt; 를 대신 시작하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="303c07dbeb4d9b201e995967f10cae861d7b985d" translate="yes" xml:space="preserve">
          <source>For convenience, this data is saved to &lt;code&gt;$GIT_DIR/cvs-authors&lt;/code&gt; each time the &lt;code&gt;-A&lt;/code&gt; option is provided and read from that same file each time &lt;code&gt;git cvsimport&lt;/code&gt; is run.</source>
          <target state="translated">편의상이 데이터는 &lt;code&gt;-A&lt;/code&gt; 옵션이 제공 될 때마다 &lt;code&gt;$GIT_DIR/cvs-authors&lt;/code&gt; 저장되고 &lt;code&gt;git cvsimport&lt;/code&gt; 가 실행될 때마다 동일한 파일에서 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="bc9270ed7ea5a3e841c3245ec308c8ddd86f1b91" translate="yes" xml:space="preserve">
          <source>For credential lookups, the files are read in the order given above, with the first matching credential found taking precedence over credentials found in files further down the list.</source>
          <target state="translated">자격 증명 조회의 경우 파일은 위에서 주어진 순서대로 읽히고 일치하는 첫 번째 자격 증명이 목록에서 더 아래에있는 파일에서 찾은 자격 증명보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="78e4826a9de5d7b3349b3c973d4bc09ea13a37ed" translate="yes" xml:space="preserve">
          <source>For each &amp;ldquo;Name &amp;lt;user@host&amp;gt;&amp;rdquo; or &amp;ldquo;&amp;lt;user@host&amp;gt;&amp;rdquo; from the command-line or standard input (when using &lt;code&gt;--stdin&lt;/code&gt;), look up the person&amp;rsquo;s canonical name and email address (see &quot;Mapping Authors&quot; below). If found, print them; otherwise print the input as-is.</source>
          <target state="translated">명령 줄 또는 표준 입력 ( &lt;code&gt;--stdin&lt;/code&gt; 사용시 )의 각&amp;ldquo;이름 &amp;lt;user @ host&amp;gt;&amp;rdquo;또는&amp;ldquo;&amp;lt;user @ host&amp;gt;&amp;rdquo;에 대해 개인의 정식 이름과 전자 메일 주소를 찾으십시오 (아래 &quot;작성자 매핑&quot;참조). ). 발견되면 인쇄하십시오. 그렇지 않으면 입력을 그대로 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="317daaebd1883bdffebfa8e7b1777b5a4f83c1ca" translate="yes" xml:space="preserve">
          <source>For each &amp;lt;pathspec&amp;gt; given on command line, descend at most &amp;lt;depth&amp;gt; levels of directories. A value of -1 means no limit. This option is ignored if &amp;lt;pathspec&amp;gt; contains active wildcards. In other words if &quot;a*&quot; matches a directory named &quot;a*&quot;, &quot;*&quot; is matched literally so --max-depth is still effective.</source>
          <target state="translated">명령 행에 제공된 각 &amp;lt;pathspec&amp;gt;에 대해 최대 &amp;lt;depth&amp;gt; 레벨의 디렉토리까지 내립니다. 값이 -1이면 제한이 없음을 의미합니다. &amp;lt;pathspec&amp;gt;에 활성 와일드 카드가 포함되어 있으면이 옵션이 무시됩니다. 즉, &quot;a *&quot;가 &quot;a *&quot;라는 디렉토리와 일치하는 경우 &quot;*&quot;는 문자 그대로 일치하므로 --max-depth는 여전히 유효합니다.</target>
        </trans-unit>
        <trans-unit id="5e28a0aae950ca165e06c71e20e1b405d570f17a" translate="yes" xml:space="preserve">
          <source>For each URI the server sends, it sends a hash of the pack&amp;rsquo;s contents (as output by git index-pack) followed by the URI.</source>
          <target state="translated">서버가 보내는 각 URI에 대해 팩 콘텐츠의 해시 (git index-pack의 출력)와 그 뒤에 URI를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="6cf7cc0cba8ed8b7ebafa73d62528bdea5d7f903" translate="yes" xml:space="preserve">
          <source>For each commit a separate file is created in the current directory.</source>
          <target state="translated">각 커밋마다 현재 디렉토리에 별도의 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6e5eb78674e89f34ddd48ded79bd04ac86b27923" translate="yes" xml:space="preserve">
          <source>For each commit, show a summary of changes using the raw diff format. See the &quot;RAW OUTPUT FORMAT&quot; section of &lt;a href=&quot;git-diff&quot;&gt;git-diff[1]&lt;/a&gt;. This is different from showing the log itself in raw format, which you can achieve with &lt;code&gt;--format=raw&lt;/code&gt;.</source>
          <target state="translated">각 커밋마다 원시 diff 형식을 사용하여 변경 사항 요약을 표시하십시오. &lt;a href=&quot;git-diff&quot;&gt;git-diff [1]&lt;/a&gt; 의 &quot;RAW OUTPUT FORMAT&quot;섹션을 참조하십시오 . 이것은 &lt;code&gt;--format=raw&lt;/code&gt; 로 달성 할 수있는 원시 형식으로 로그 자체를 표시하는 것과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="334d2ef126bc398bc9fdce4f33bf828f0bbaab0d" translate="yes" xml:space="preserve">
          <source>For each commit-ish supplied, &lt;code&gt;git describe&lt;/code&gt; will first look for a tag which tags exactly that commit. Annotated tags will always be preferred over lightweight tags, and tags with newer dates will always be preferred over tags with older dates. If an exact match is found, its name will be output and searching will stop.</source>
          <target state="translated">제공된 커밋 -ish마다 &lt;code&gt;git describe&lt;/code&gt; 는 먼저 해당 커밋에 태그를 지정하는 태그를 찾습니다. 주석이 달린 태그는 항상 경량 태그보다 선호되며, 최신 날짜가있는 태그는 항상 오래된 날짜가있는 태그보다 선호됩니다. 정확히 일치하면 이름이 출력되고 검색이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="499cd7809be15aac9ff7cdcafa51d0930d0f78d9" translate="yes" xml:space="preserve">
          <source>For each contact, a single line is output, terminated by a newline. If the name is provided or known to the &lt;code&gt;mailmap&lt;/code&gt;, &amp;ldquo;Name &amp;lt;user@host&amp;gt;&amp;rdquo; is printed; otherwise only &amp;ldquo;&amp;lt;user@host&amp;gt;&amp;rdquo; is printed.</source>
          <target state="translated">각 접점에 대해 단일 라인이 출력되고 줄 바꿈으로 종료됩니다. 이름이 &lt;code&gt;mailmap&lt;/code&gt; 에 제공되거나 알려진 경우&amp;ldquo;Name &amp;lt;user @ host&amp;gt;&amp;rdquo;가 인쇄됩니다. 그렇지 않으면&amp;ldquo;&amp;lt;user @ host&amp;gt;&amp;rdquo;만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="0e11740c89977d85e4dd98daa923a91e3f5130da" translate="yes" xml:space="preserve">
          <source>For each patch the code attempts to extract the author from the patch description. If that fails it falls back to the author specified with --author. If the --author flag was not given the patch description is displayed and the user is asked to interactively enter the author of the patch.</source>
          <target state="translated">각 패치에 대해 코드는 패치 설명에서 작성자를 추출하려고 시도합니다. 실패하면 --author로 지정된 작성자에게 폴백합니다. --author 플래그가 제공되지 않은 경우 패치 설명이 표시되고 사용자에게 대화 형으로 패치 작성자를 입력하라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5681283d451e4fc4fc0ca3089786f576c8a1186d" translate="yes" xml:space="preserve">
          <source>For each path &lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; is called, two environment variables, &lt;code&gt;GIT_DIFF_PATH_COUNTER&lt;/code&gt; and &lt;code&gt;GIT_DIFF_PATH_TOTAL&lt;/code&gt; are set.</source>
          <target state="translated">&lt;code&gt;GIT_EXTERNAL_DIFF&lt;/code&gt; 가 호출되는 각 경로에 대해 두 가지 환경 변수 &lt;code&gt;GIT_DIFF_PATH_COUNTER&lt;/code&gt; 및 &lt;code&gt;GIT_DIFF_PATH_TOTAL&lt;/code&gt; 이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="17e261e522ccbc792cc7bd181c9a0bd755a56975" translate="yes" xml:space="preserve">
          <source>For each pathname given via the command-line or from a file via &lt;code&gt;--stdin&lt;/code&gt;, check whether the file is excluded by .gitignore (or other input files to the exclude mechanism) and output the path if it is excluded.</source>
          <target state="translated">명령 행을 통해 또는 &lt;code&gt;--stdin&lt;/code&gt; 을 통해 파일에서 제공된 각 경로 이름에 대해 파일이 .gitignore (또는 제외 메커니즘에 대한 다른 입력 파일)에 의해 제외되는지 확인하고 제외 된 경우 경로를 출력하십시오.</target>
        </trans-unit>
        <trans-unit id="3b2b4e958456928c896ce5a2236319df3a467837" translate="yes" xml:space="preserve">
          <source>For each reference update that was added to the transaction, the hook receives on standard input a line of the format:</source>
          <target state="translated">트랜잭션에 추가 된 각 참조 업데이트에 대해 후크는 표준 입력에서 다음 형식의 행을 수신합니다.</target>
        </trans-unit>
        <trans-unit id="c7b8eb760e478aaaedca171d489f16e4864063c9" translate="yes" xml:space="preserve">
          <source>For each repo that you want accessible from CVS you need to edit config in the repo and add the following section.</source>
          <target state="translated">CVS에서 액세스 할 수있는 각 리포에 대해 리포지토리에서 구성을 편집하고 다음 섹션을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a6b07eab1d3f6d06954967f77b7754d8ea06736" translate="yes" xml:space="preserve">
          <source>For every branch that is up to date or successfully pushed, add upstream (tracking) reference, used by argument-less &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; and other commands. For more information, see &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;.</source>
          <target state="translated">최신이거나 성공적으로 푸시 된 모든 브랜치에 대해 인수가없는 &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt; 및 기타 명령 에서 사용하는 업스트림 (추적) 참조를 추가하십시오 . 자세한 내용 은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]의 &lt;/a&gt; &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="288f34b4fe961722eeaf789d738c3abe79ce0128" translate="yes" xml:space="preserve">
          <source>For every pathname, this command will list if each attribute is &lt;code&gt;unspecified&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, or &lt;code&gt;unset&lt;/code&gt; as a gitattribute on that pathname.</source>
          <target state="translated">각 속성 인 경우 모든 경로의 경우,이 명령을 나열합니다 &lt;code&gt;unspecified&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; 또는 &lt;code&gt;unset&lt;/code&gt; 하는 경로에 gitattribute있다.</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="b8684a0f4f3937af285df51bf478195b9b43d0d0" translate="yes" xml:space="preserve">
          <source>For example &lt;a href=&quot;git-daemon&quot;&gt;git-daemon[1]&lt;/a&gt; by default (unless &lt;code&gt;--export-all&lt;/code&gt; option is used) allows pulling only for those repositories that have &lt;code&gt;git-daemon-export-ok&lt;/code&gt; file. Adding</source>
          <target state="translated">예를 들어 기본적으로 &lt;a href=&quot;git-daemon&quot;&gt;git-daemon [1]&lt;/a&gt; ( &lt;code&gt;--export-all&lt;/code&gt; 옵션을 사용 하지 않는 한 )은 &lt;code&gt;git-daemon-export-ok&lt;/code&gt; 파일 이있는 리포지토리에 대해서만 가져 오기를 허용 합니다. 첨가</target>
        </trans-unit>
        <trans-unit id="46e0aea8ec6e607a64677afaf2a0016d08ab966a" translate="yes" xml:space="preserve">
          <source>For example David Miller wrote &lt;a href=&quot;#6&quot;&gt;[6]&lt;/a&gt;:</source>
          <target state="translated">예를 들어 데이비드 밀러가 쓴 &lt;a href=&quot;#6&quot;&gt;[6]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0e389491903e64c421beccd08371ba327e60cc0c" translate="yes" xml:space="preserve">
          <source>For example an effect from the submodule&amp;rsquo;s &lt;code&gt;.gitignore&lt;/code&gt; file would be observed when you run &lt;code&gt;git status --ignore-submodules=none&lt;/code&gt; in the superproject. This collects information from the submodule&amp;rsquo;s working directory by running &lt;code&gt;status&lt;/code&gt; in the submodule while paying attention to the &lt;code&gt;.gitignore&lt;/code&gt; file of the submodule.</source>
          <target state="translated">예를 들어 , 수퍼 프로젝트에서 &lt;code&gt;git status --ignore-submodules=none&lt;/code&gt; 을 실행 하면 서브 모듈의 &lt;code&gt;.gitignore&lt;/code&gt; 파일 의 효과 가 나타납니다 . 서브 모듈의 &lt;code&gt;.gitignore&lt;/code&gt; 파일에 주의를 기울이면서 서브 모듈에서 &lt;code&gt;status&lt;/code&gt; 를 실행하여 서브 모듈의 작업 디렉토리에서 정보를 수집합니다 .</target>
        </trans-unit>
        <trans-unit id="56e9b1c030d9ba0ed8f301bc4d928b5ec348ecfb" translate="yes" xml:space="preserve">
          <source>For example if commit &lt;code&gt;foo&lt;/code&gt; has been replaced by commit &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">예를 들어 commit &lt;code&gt;foo&lt;/code&gt; 가 commit &lt;code&gt;bar&lt;/code&gt; 로 교체 된 경우 :</target>
        </trans-unit>
        <trans-unit id="fc4ffa566856e8487717cc75478e8ddebf738773" translate="yes" xml:space="preserve">
          <source>For example if repositories you are hosting use &quot;phtml&quot; extension for PHP files, and you want to have correct syntax-highlighting for those files, you can add the following to gitweb configuration:</source>
          <target state="translated">예를 들어 호스팅하는 리포지토리가 PHP 파일에 &quot;phtml&quot;확장자를 사용하고 해당 파일에 대해 올바른 구문 강조 표시를 원하는 경우 gitweb 구성에 다음을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5154cf5119ca3a0384ad194cc198ec59c07c7ac1" translate="yes" xml:space="preserve">
          <source>For example if we start with a graph like this:</source>
          <target state="translated">예를 들어 다음과 같은 그래프로 시작하면</target>
        </trans-unit>
        <trans-unit id="011e69a8d88e3f2ecd0b2c97750e695437a8b7be" translate="yes" xml:space="preserve">
          <source>For example one branch can change the semantic of a function while the other branch add more calls to the same function.</source>
          <target state="translated">예를 들어 한 브랜치는 함수의 의미를 변경할 수 있지만 다른 브랜치는 같은 함수에 더 많은 호출을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="948250d1153d7a9c5c187de68da76cbf9fe7a0b6" translate="yes" xml:space="preserve">
          <source>For example since all normal branches are stored under &lt;code&gt;refs/heads/&lt;/code&gt; name the tag fixup branch &lt;code&gt;TAG_FIXUP&lt;/code&gt;. This way it is impossible for the fixup branch used by the importer to have namespace conflicts with real branches imported from the source (the name &lt;code&gt;TAG_FIXUP&lt;/code&gt; is not &lt;code&gt;refs/heads/TAG_FIXUP&lt;/code&gt;).</source>
          <target state="translated">예를 들어 모든 일반 브랜치는 &lt;code&gt;refs/heads/&lt;/code&gt; 아래에 저장 되므로 태그 수정 브랜치의 이름은 &lt;code&gt;TAG_FIXUP&lt;/code&gt; 입니다. 이 방법으로 임포터가 사용하는 수정 분기가 소스에서 가져온 실제 분기와 네임 스페이스 충돌을 갖는 것은 불가능합니다 (이름 &lt;code&gt;TAG_FIXUP&lt;/code&gt; 은 &lt;code&gt;refs/heads/TAG_FIXUP&lt;/code&gt; 아님 ).</target>
        </trans-unit>
        <trans-unit id="4be01aa529e151bdbbe73a5ece143631e964e4ac" translate="yes" xml:space="preserve">
          <source>For example some test suites could be run automatically at night with some unusual (or even random) configurations. And if a regression is found by a test suite, then &quot;git bisect&quot; can be automatically launched, and its result can be emailed to the author of the first bad commit found by &quot;git bisect&quot;, and perhaps other people too. And a new entry in the bug tracking system could be automatically created too.</source>
          <target state="translated">예를 들어, 일부 테스트 스위트는 비정상적인 (또는 임의의) 구성으로 야간에 자동으로 실행될 수 있습니다. 그리고 테스트 스위트에서 회귀가 발견되면 &quot;git bisect&quot;가 자동으로 시작될 수 있으며 그 결과는 &quot;git bisect&quot;에 의해 발견 된 첫 번째 나쁜 커밋의 저자 및 다른 사람들에게도 이메일로 전송 될 수 있습니다. 또한 버그 추적 시스템의 새로운 항목도 자동으로 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bbfe98ebcd584e72bba80caca0bbe3de761fb8b" translate="yes" xml:space="preserve">
          <source>For example using:</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="b2715e2afcd57211e00aecf4fa8f8efd172203eb" translate="yes" xml:space="preserve">
          <source>For example with the following graph where H is the &quot;bad&quot; commit and A and D are some parents of some &quot;good&quot; commits:</source>
          <target state="translated">예를 들어 다음 그래프에서 H는 &quot;나쁜&quot;커밋이고 A와 D는 &quot;좋은&quot;커밋의 부모입니다.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="33f7a1b1f9148ad49a81c77432db9d624e3ed14b" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;--batch&lt;/code&gt; without a custom format would produce:</source>
          <target state="translated">예를 들어, 사용자 정의 형식이없는 &lt;code&gt;--batch&lt;/code&gt; 는 다음을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f103141294055917b49b4ff3b11f28f0e7b09a93" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;--cherry-pick --right-only A...B&lt;/code&gt; omits those commits from &lt;code&gt;B&lt;/code&gt; which are in &lt;code&gt;A&lt;/code&gt; or are patch-equivalent to a commit in &lt;code&gt;A&lt;/code&gt;. In other words, this lists the &lt;code&gt;+&lt;/code&gt; commits from &lt;code&gt;git cherry A B&lt;/code&gt;. More precisely, &lt;code&gt;--cherry-pick --right-only --no-merges&lt;/code&gt; gives the exact list.</source>
          <target state="translated">예를 들어, &lt;code&gt;--cherry-pick --right-only A...B&lt;/code&gt; 를 생략부터 그 커밋 &lt;code&gt;B&lt;/code&gt; 에 나에 패치 동등이 커밋 . 즉, 이것은 &lt;code&gt;git cherry A B&lt;/code&gt; 의 &lt;code&gt;+&lt;/code&gt; 커밋을 나열합니다 . 보다 정확하게 &lt;code&gt;--cherry-pick --right-only --no-merges&lt;/code&gt; 는 정확한 목록을 제공합니다. &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8a58c9ab1aebec2fe76ee8cb4f7dc47b3afba08" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;--word-diff-regex=.&lt;/code&gt; will treat each character as a word and, correspondingly, show differences character by character.</source>
          <target state="translated">예를 들어 &lt;code&gt;--word-diff-regex=.&lt;/code&gt; 각 문자를 단어로 취급하고 그에 따라 문자별로 차이를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9497e805114a62dd0cfbb0fd446cb80188b76834" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;git bisect reset bisect/bad&lt;/code&gt; will check out the first bad revision, while &lt;code&gt;git bisect reset HEAD&lt;/code&gt; will leave you on the current bisection commit and avoid switching commits at all.</source>
          <target state="translated">예를 들어, &lt;code&gt;git bisect reset bisect/bad&lt;/code&gt; 는 첫 번째 불량 개정을 확인하는 반면 &lt;code&gt;git bisect reset HEAD&lt;/code&gt; 는 현재 bisection 커밋을 유지하고 커밋 전환을 피합니다.</target>
        </trans-unit>
        <trans-unit id="fe1483bfc3665f725dee6688f5887a817d1f226c" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;main-worktree/HEAD&lt;/code&gt; or &lt;code&gt;main-worktree/refs/bisect/good&lt;/code&gt; resolve to the same value as the main working tree&amp;rsquo;s &lt;code&gt;HEAD&lt;/code&gt; and &lt;code&gt;refs/bisect/good&lt;/code&gt; respectively. Similarly, &lt;code&gt;worktrees/foo/HEAD&lt;/code&gt; or &lt;code&gt;worktrees/bar/refs/bisect/bad&lt;/code&gt; are the same as &lt;code&gt;$GIT_COMMON_DIR/worktrees/foo/HEAD&lt;/code&gt; and &lt;code&gt;$GIT_COMMON_DIR/worktrees/bar/refs/bisect/bad&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;main-worktree/HEAD&lt;/code&gt; 또는 &lt;code&gt;main-worktree/refs/bisect/good&lt;/code&gt; 은 각각 기본 작업 트리의 &lt;code&gt;HEAD&lt;/code&gt; 및 &lt;code&gt;refs/bisect/good&lt;/code&gt; 과 동일한 값으로 확인 됩니다. 마찬가지로, &lt;code&gt;worktrees/foo/HEAD&lt;/code&gt; 또는 &lt;code&gt;worktrees/bar/refs/bisect/bad&lt;/code&gt; 는 &lt;code&gt;$GIT_COMMON_DIR/worktrees/foo/HEAD&lt;/code&gt; 및 &lt;code&gt;$GIT_COMMON_DIR/worktrees/bar/refs/bisect/bad&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="138442d2b65de29c2047a8caafb4d9bebbf214b3" translate="yes" xml:space="preserve">
          <source>For example, Documentation/*.jpg will match all .jpg files in the Documentation subtree, including Documentation/chapter_1/figure_1.jpg.</source>
          <target state="translated">예를 들어 Documentation / *. jpg는 Documentation / chapter_1 / figure_1.jpg를 포함하여 Documentation 하위 트리의 모든 .jpg 파일과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="0d743ee5b8f526c69043aec1a6e6a8e47be44f66" translate="yes" xml:space="preserve">
          <source>For example, Microsoft Visual Studio resources files (&lt;code&gt;*.rc&lt;/code&gt;) or PowerShell script files (&lt;code&gt;*.ps1&lt;/code&gt;) are sometimes encoded in UTF-16. If you declare &lt;code&gt;*.ps1&lt;/code&gt; as files as UTF-16 and you add &lt;code&gt;foo.ps1&lt;/code&gt; with a &lt;code&gt;working-tree-encoding&lt;/code&gt; enabled Git client, then &lt;code&gt;foo.ps1&lt;/code&gt; will be stored as UTF-8 internally. A client without &lt;code&gt;working-tree-encoding&lt;/code&gt; support will checkout &lt;code&gt;foo.ps1&lt;/code&gt; as UTF-8 encoded file. This will typically cause trouble for the users of this file.</source>
          <target state="translated">예를 들어 Microsoft Visual Studio 리소스 파일 ( &lt;code&gt;*.rc&lt;/code&gt; ) 또는 PowerShell 스크립트 파일 ( &lt;code&gt;*.ps1&lt;/code&gt; )은 때때로 UTF-16으로 인코딩됩니다. 당신이 선언하면 &lt;code&gt;*.ps1&lt;/code&gt; 입니다 UTF-16 등의 파일로 및 추가 &lt;code&gt;foo.ps1&lt;/code&gt; 을 와 &lt;code&gt;working-tree-encoding&lt;/code&gt; 망할 놈의 클라이언트를 활성화 한 다음 &lt;code&gt;foo.ps1&lt;/code&gt; 는 UTF-8 내부적으로 저장됩니다. &lt;code&gt;working-tree-encoding&lt;/code&gt; 지원이 없는 클라이언트 는 &lt;code&gt;foo.ps1&lt;/code&gt; 을 UTF-8 인코딩 파일로 체크 아웃 합니다. 이것은 일반적으로이 파일의 사용자에게 문제를 일으 킵니다.</target>
        </trans-unit>
        <trans-unit id="1ed869792207741cfe6bed98106c7b8b8a3d4f0d" translate="yes" xml:space="preserve">
          <source>For example, a patch that talks about updating &lt;code&gt;a/git-gui.sh&lt;/code&gt; to &lt;code&gt;b/git-gui.sh&lt;/code&gt; can be applied to the file in the working tree &lt;code&gt;modules/git-gui/git-gui.sh&lt;/code&gt; by running &lt;code&gt;git apply --directory=modules/git-gui&lt;/code&gt;.</source>
          <target state="translated">예를 들어, a &lt;code&gt;a/git-gui.sh&lt;/code&gt; 를 &lt;code&gt;b/git-gui.sh&lt;/code&gt; / git-gui.sh 로 업데이트 하는 것에 대한 패치는 &lt;code&gt;git apply --directory=modules/git-gui&lt;/code&gt; 를 실행 하여 작업 트리 &lt;code&gt;modules/git-gui/git-gui.sh&lt;/code&gt; /git-gui/git-gui.sh 의 파일에 적용 할 수 있습니다. -directory = modules / git-gui .</target>
        </trans-unit>
        <trans-unit id="ce77d8f6da94ff85eab04ae4cdac09d8840be36a" translate="yes" xml:space="preserve">
          <source>For example, a pattern &lt;code&gt;doc/frotz/&lt;/code&gt; matches &lt;code&gt;doc/frotz&lt;/code&gt; directory, but not &lt;code&gt;a/doc/frotz&lt;/code&gt; directory; however &lt;code&gt;frotz/&lt;/code&gt; matches &lt;code&gt;frotz&lt;/code&gt; and &lt;code&gt;a/frotz&lt;/code&gt; that is a directory (all paths are relative from the &lt;code&gt;.gitignore&lt;/code&gt; file).</source>
          <target state="translated">예를 들어, 패턴 &lt;code&gt;doc/frotz/&lt;/code&gt; 는 &lt;code&gt;doc/frotz&lt;/code&gt; 디렉토리 와 일치 하지만 &lt;code&gt;a/doc/frotz&lt;/code&gt; 디렉토리 와 일치 하지 않습니다 . 그러나 &lt;code&gt;frotz/&lt;/code&gt; 는 디렉토리 인 &lt;code&gt;frotz&lt;/code&gt; 및 &lt;code&gt;a/frotz&lt;/code&gt; frotz 와 일치합니다 (모든 경로는 &lt;code&gt;.gitignore&lt;/code&gt; 파일 과 관련이 있습니다).</target>
        </trans-unit>
        <trans-unit id="67b1d0bce407e8b4870f6f6a95250837544f5b7b" translate="yes" xml:space="preserve">
          <source>For example, an attempt to rearrange</source>
          <target state="translated">예를 들어, 재배치하려는 시도</target>
        </trans-unit>
        <trans-unit id="5bf319ce2803b376c46250398e2ab2c650bad072" translate="yes" xml:space="preserve">
          <source>For example, at the time this page was written, the &lt;a href=&quot;http://repo.or.cz&quot;&gt;http://repo.or.cz&lt;/a&gt; Git hosting site set it to the following to enable graphical log (using the third party tool &lt;strong&gt;git-browser&lt;/strong&gt;):</source>
          <target state="translated">예를 들어,이 페이지가 작성된 시점에서 &lt;a href=&quot;http://repo.or.cz&quot;&gt;http://repo.or.cz&lt;/a&gt; Git 호스팅 사이트는 그래픽 로그를 활성화하기 위해 다음과 같이 설정했습니다 (타사 도구 &lt;strong&gt;git-browser 사용&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="ff9841351106eb72affbaa34cd9000cbe695e6c0" translate="yes" xml:space="preserve">
          <source>For example, consider a git repository containing:</source>
          <target state="translated">예를 들어, 다음을 포함하는 git 저장소를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="aa3e19341d33b69e0c7637f09cb4c872d477e052" translate="yes" xml:space="preserve">
          <source>For example, for the above graph, a command like:</source>
          <target state="translated">예를 들어 위 그래프의 경우 다음과 같은 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5fffc70646f6a27f7f67e5894c9b6fc5ccd683b" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;$projectroot&lt;/code&gt; is set to &quot;/srv/git&quot; by putting the following in gitweb config file:</source>
          <target state="translated">예를 들어, &lt;code&gt;$projectroot&lt;/code&gt; 가 gitweb 구성 파일에 다음을 입력하여 &quot;/ srv / git&quot;으로 설정된 경우 :</target>
        </trans-unit>
        <trans-unit id="852dc3836c1061d866e063a7498878f33ef3ce12" translate="yes" xml:space="preserve">
          <source>For example, if the P4 repository structure is:</source>
          <target state="translated">예를 들어, P4 저장소 구조가 다음과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="36dce8b0d031af7904e6cd8255529f9ec8396929" translate="yes" xml:space="preserve">
          <source>For example, if the file you want to change is some sort of config file, the repository can include a sample config file that can then be copied into the ignored name and modified. The repository can even include a script to treat the sample file as a template, modifying and copying it automatically.</source>
          <target state="translated">예를 들어 변경하려는 파일이 일종의 구성 파일 인 경우 저장소에는 무시 된 이름으로 복사하여 수정할 수있는 샘플 구성 파일이 포함될 수 있습니다. 저장소에는 샘플 파일을 템플릿으로 처리하고 자동으로 수정 및 복사하는 스크립트도 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4035b3eacf18f396eb5e00ae6815d18cf72feae5" translate="yes" xml:space="preserve">
          <source>For example, if the value for this option is &quot;%=$&quot;, then only lines using the format &lt;code&gt;&amp;lt;token&amp;gt;&amp;lt;sep&amp;gt;&amp;lt;value&amp;gt;&lt;/code&gt; with &amp;lt;sep&amp;gt; containing &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; and then spaces will be considered trailers. And &lt;code&gt;%&lt;/code&gt; will be the default separator used, so by default trailers will appear like: &lt;code&gt;&amp;lt;token&amp;gt;% &amp;lt;value&amp;gt;&lt;/code&gt; (one percent sign and one space will appear between the token and the value).</source>
          <target state="translated">예를 들면,이 옵션에 대한 값은 &quot;% = $&quot;인 경우, 다음의 형식을 사용하는 경우에만 라인 &lt;code&gt;&amp;lt;token&amp;gt;&amp;lt;sep&amp;gt;&amp;lt;value&amp;gt;&lt;/code&gt; 와 &amp;lt;9월&amp;gt; 함유 &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt; 또는 &lt;code&gt;$&lt;/code&gt; 다음 공간이 고려 될 것이다 트레일러. 그리고 &lt;code&gt;%&lt;/code&gt; 가 사용되는 기본 구분 기호이므로 기본적으로 예고편은 &lt;code&gt;&amp;lt;token&amp;gt;% &amp;lt;value&amp;gt;&lt;/code&gt; 와 같이 나타납니다 (토큰과 값 사이에 하나의 백분율 기호와 하나의 공백이 나타남).</target>
        </trans-unit>
        <trans-unit id="534223d4530dd35132999074203db95c4ecee123" translate="yes" xml:space="preserve">
          <source>For example, if this variable is set to &quot;refs/for&quot;, pushing to reference such as &quot;refs/for/master&quot; will not create or update a reference named &quot;refs/for/master&quot;, but may create or update a pull request directly by running the hook &quot;proc-receive&quot;.</source>
          <target state="translated">예를 들어,이 변수가 &quot;refs / for&quot;로 설정된 경우 &quot;refs / for / master&quot;와 같은 참조로 푸시하면 &quot;refs / for / master&quot;라는 참조를 만들거나 업데이트하지 않지만 pull을 만들거나 업데이트 할 수 있습니다. 후크 &quot;proc-receive&quot;를 실행하여 직접 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="5103535d9f29750b8c9135f826c57c311f8eeae1" translate="yes" xml:space="preserve">
          <source>For example, if we want a password for &lt;code&gt;https://example.com/foo.git&lt;/code&gt;, we might generate the following credential description (don&amp;rsquo;t forget the blank line at the end; it tells &lt;code&gt;git credential&lt;/code&gt; that the application finished feeding all the information it has):</source>
          <target state="translated">예를 들어 &lt;code&gt;https://example.com/foo.git&lt;/code&gt; 의 비밀번호를 원하면 다음과 같은 자격 증명 설명을 생성 할 수 있습니다 (끝의 빈 줄을 잊지 마십시오; &lt;code&gt;git credential&lt;/code&gt; 에 응용 프로그램이 모두 공급을 완료했음을 알려줍니다) 그것이 가지고있는 정보) :</target>
        </trans-unit>
        <trans-unit id="bb2f882b3f8efdae1333b719a705576641ca3f31" translate="yes" xml:space="preserve">
          <source>For example, if you are looking for a commit that introduced a performance regression, you might use</source>
          <target state="translated">예를 들어, 성능 회귀를 도입 한 커밋을 찾고 있다면</target>
        </trans-unit>
        <trans-unit id="68d306989ac898943c9324c1636692924527fd1d" translate="yes" xml:space="preserve">
          <source>For example, if you have this topology:</source>
          <target state="translated">예를 들어,이 토폴로지가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="a61cdb8cd8334eeef24d9dfefb310bcbd689195c" translate="yes" xml:space="preserve">
          <source>For example, if you have two branches, &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, a usual way to list all commits on only one side of them is with &lt;code&gt;--left-right&lt;/code&gt; (see the example below in the description of the &lt;code&gt;--left-right&lt;/code&gt; option). However, it shows the commits that were cherry-picked from the other branch (for example, &amp;ldquo;3rd on b&amp;rdquo; may be cherry-picked from branch A). With this option, such pairs of commits are excluded from the output.</source>
          <target state="translated">예를 들어, &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 두 개의 분기 가있는 경우 한쪽의 커밋을 모두 나열하는 일반적인 방법은 &lt;code&gt;--left-right&lt;/code&gt; 입니다 ( &lt;code&gt;--left-right&lt;/code&gt; 옵션 설명에서 아래 예 참조 ). . 그러나 다른 브랜치에서 체리 피킹 된 커밋을 보여줍니다 (예 : &quot;b의 3rd&quot;는 브랜치 A에서 체리 피킹 될 수 있음). 이 옵션을 사용하면 이러한 커밋 쌍이 출력에서 ​​제외됩니다.</target>
        </trans-unit>
        <trans-unit id="fe897c525854ed4ff520e569183f4547ca07cbf6" translate="yes" xml:space="preserve">
          <source>For example, if you use mod_perl to run the script, and have dumb HTTP protocol authentication configured for your repositories, you can use the following hook to allow access only if the user is authorized to read the files:</source>
          <target state="translated">예를 들어, mod_perl을 사용하여 스크립트를 실행하고 저장소에 대해 벙어리 HTTP 프로토콜 인증을 구성한 경우 사용자가 파일을 읽을 권한이있는 경우에만 다음 후크를 사용하여 액세스를 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86c7872b373de97c557b525ebe5143ba729f1f41" translate="yes" xml:space="preserve">
          <source>For example, if you want to reorder the last 5 commits, such that what was HEAD~4 becomes the new HEAD. To achieve that, you would call &lt;code&gt;git rebase&lt;/code&gt; like this:</source>
          <target state="translated">예를 들어, 마지막 5 개의 커밋을 재정렬하려면 HEAD ~ 4가 새로운 HEAD가됩니다. 이를 달성하기 위해 다음과 같이 &lt;code&gt;git rebase&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="3cb17626983b1627f4a677c41e03478d83711c28" translate="yes" xml:space="preserve">
          <source>For example, imagine you store the refs for each fork in &lt;code&gt;refs/virtual/ID&lt;/code&gt;, where &lt;code&gt;ID&lt;/code&gt; is a numeric identifier. You might then configure:</source>
          <target state="translated">예를 들어, 각 포크에 대한 참조를 &lt;code&gt;refs/virtual/ID&lt;/code&gt; 에 저장한다고 가정하십시오 . 여기서 &lt;code&gt;ID&lt;/code&gt; 는 숫자 ID입니다. 그런 다음 다음을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30bbf60289c9238f0d33e5175010f4e252c9853c" translate="yes" xml:space="preserve">
          <source>For example, in .gitattributes, you would assign the &lt;code&gt;filter&lt;/code&gt; attribute for paths.</source>
          <target state="translated">예를 들어 .gitattributes에서는 경로에 &lt;code&gt;filter&lt;/code&gt; 속성을 할당합니다 .</target>
        </trans-unit>
        <trans-unit id="c7b53804fabf5a8d611f469400f3d23e0cdaf582" translate="yes" xml:space="preserve">
          <source>For example, in a commit history like this:</source>
          <target state="translated">예를 들어, 다음과 같은 커밋 기록에서 :</target>
        </trans-unit>
        <trans-unit id="806ca5f41259915dee6774976f8cdf13ec61deac" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say that you have worked on your working directory, updated some files in the index and are ready to commit. You want to see exactly &lt;strong&gt;what&lt;/strong&gt; you are going to commit, without having to write a new tree object and compare it that way, and to do that, you just do</source>
          <target state="translated">예를 들어, 작업 디렉토리에서 작업하고 인덱스의 일부 파일을 업데이트했으며 커밋 할 준비가되었다고 가정 해 봅시다. 당신은 정확히보고 싶은 &lt;strong&gt;무엇을&lt;/strong&gt; 하고 그렇게, 그냥 수행 새 트리 오브젝트를 작성하지 않고도, 저지하려고하고 그런 식으로 비교</target>
        </trans-unit>
        <trans-unit id="476c3fc4a50784809d3ca0defbcdf28a5bcb4395" translate="yes" xml:space="preserve">
          <source>For example, main-worktree/HEAD or main-worktree/refs/bisect/good resolve to the same value as the main working tree&amp;rsquo;s HEAD and refs/bisect/good respectively. Similarly, worktrees/foo/HEAD or worktrees/bar/refs/bisect/bad are the same as GIT_COMMON_DIR/worktrees/foo/HEAD and GIT_COMMON_DIR/worktrees/bar/refs/bisect/bad.</source>
          <target state="translated">예를 들어 main-worktree / HEAD 또는 main-worktree / refs / bisect / good는 각각 기본 작업 트리의 HEAD 및 refs / bisect / good와 동일한 값으로 해석됩니다. 마찬가지로 worktrees / foo / HEAD 또는 worktrees / bar / refs / bisect / bad는 GIT_COMMON_DIR / worktrees / foo / HEAD 및 GIT_COMMON_DIR / worktrees / bar / refs / bisect / bad와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="266db89f5ed370855ec231f0d9586be36c8c2a06" translate="yes" xml:space="preserve">
          <source>For example, running &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; generates this tree object from the index, stores it in the object database, and uses it as the tree object associated with the new commit.</source>
          <target state="translated">예를 들어, &lt;a href=&quot;git-commit&quot;&gt;git-commit [1]을&lt;/a&gt; 실행 하면 인덱스에서이 트리 객체가 생성되어 객체 데이터베이스에 저장되어 새 커밋과 관련된 트리 객체로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9241280c5dcf375f9e4ee8c8496a1f68f481ea18" translate="yes" xml:space="preserve">
          <source>For example, starting with this index:</source>
          <target state="translated">예를 들어이 색인으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="37236815fc65047678c9d53df59b5a94b9133df3" translate="yes" xml:space="preserve">
          <source>For example, the following fetch command spawned ssh, index-pack, rev-list, and gc. This example also shows that fetch took 5.199 seconds and of that 4.932 was in ssh.</source>
          <target state="translated">예를 들어 다음 페치 명령은 ssh, index-pack, rev-list 및 gc를 생성했습니다. 이 예제는 또한 페치가 5.199 초 걸리고 그 중 4.932가 ssh에 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="675eb647719ee2ad2bd9af2ee96b8f7029195efd" translate="yes" xml:space="preserve">
          <source>For example, the following setting produces a breadcrumb trail like &quot;home / dev / projects / &amp;hellip;​&quot; where &quot;projects&quot; is the home link.</source>
          <target state="translated">예를 들어 다음 설정은 &quot;home / dev / projects /&amp;hellip;&quot;와 같은 이동 경로 추적을 생성합니다. 여기서 &quot;projects&quot;는 홈 링크입니다.</target>
        </trans-unit>
        <trans-unit id="f229d0901b53da5a8037ba5b963ab5e1b0a84fc7" translate="yes" xml:space="preserve">
          <source>For example, the hook can simply run &lt;code&gt;git read-tree -u -m HEAD &quot;$1&quot;&lt;/code&gt; in order to emulate &lt;code&gt;git fetch&lt;/code&gt; that is run in the reverse direction with &lt;code&gt;git push&lt;/code&gt;, as the two-tree form of &lt;code&gt;git read-tree -u -m&lt;/code&gt; is essentially the same as &lt;code&gt;git switch&lt;/code&gt; or &lt;code&gt;git checkout&lt;/code&gt; that switches branches while keeping the local changes in the working tree that do not interfere with the difference between the branches.</source>
          <target state="translated">예를 들어, 후크 간단하게 실행할 수 있습니다 &lt;code&gt;git read-tree -u -m HEAD &quot;$1&quot;&lt;/code&gt; 에뮬레이트하기 위해 &lt;code&gt;git fetch&lt;/code&gt; 그와 반대 방향으로 실행되는 &lt;code&gt;git push&lt;/code&gt; 의 두 트리 형태로, &lt;code&gt;git read-tree -u -m&lt;/code&gt; 은 기본적으로 분기 간의 전환을 방해하지 않는 작업 트리의 로컬 변경 사항을 유지하면서 분기를 전환하는 &lt;code&gt;git switch&lt;/code&gt; 또는 &lt;code&gt;git checkout&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="2232af53268b39393df426da2516589a0d0a00e9" translate="yes" xml:space="preserve">
          <source>For example, the multithreaded preload-index code can be instrumented with a region around the thread pool and then per-thread start and exit events within the threadproc.</source>
          <target state="translated">예를 들어, 다중 스레드 사전로드 색인 코드는 스레드 풀 주위의 영역으로 계측 된 다음 스레드 프로 시저 내에서 스레드 별 시작 및 종료 이벤트를 계측 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6165309453e90635fafde69fa6a0dbf363059c7" translate="yes" xml:space="preserve">
          <source>For example, there can be a &quot;main&quot; branch, and a &quot;dev&quot; branch that was forked of the main branch at a commit named &quot;D&quot; like this:</source>
          <target state="translated">예를 들어, &quot;main&quot;브랜치와 다음과 같이 &quot;D&quot;라는 커밋에서 메인 브랜치에서 분기 된 &quot;dev&quot;브랜치가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc0695ddae75754b17aaf6b6d741676357b02fb6" translate="yes" xml:space="preserve">
          <source>For example, this configuration:</source>
          <target state="translated">예를 들어이 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="03526c1b7e3b294cd55189c8a4305129233dcf64" translate="yes" xml:space="preserve">
          <source>For example, this line in &lt;code&gt;.gitattributes&lt;/code&gt; can be used to tell the merge machinery to leave much longer (instead of the usual 7-character-long) conflict markers when merging the file &lt;code&gt;Documentation/git-merge.txt&lt;/code&gt; results in a conflict.</source>
          <target state="translated">예를 들어, &lt;code&gt;.gitattributes&lt;/code&gt; 의이 줄을 사용하면 &lt;code&gt;Documentation/git-merge.txt&lt;/code&gt; 파일을 병합 할 때 병합 기계가 일반적인 7 자 길이가 아닌 충돌 마커를 훨씬 더 오래 남겨 두도록 충돌을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b89cc0f3038d951dcea25e6121459d7deb13668" translate="yes" xml:space="preserve">
          <source>For example, to default to pushing only the current branch to &lt;code&gt;origin&lt;/code&gt; use &lt;code&gt;git config remote.origin.push HEAD&lt;/code&gt;. Any valid &amp;lt;refspec&amp;gt; (like the ones in the examples below) can be configured as the default for &lt;code&gt;git push origin&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 현재 브랜치 만 &lt;code&gt;origin&lt;/code&gt; 으로 푸시하도록 기본 &lt;code&gt;git config remote.origin.push HEAD&lt;/code&gt; 하려면 git config remote.origin.push HEAD를 사용하십시오 . 유효한 &amp;lt;refspec&amp;gt; (아래 예와 같이)은 &lt;code&gt;git push origin&lt;/code&gt; 의 기본값으로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="119ea88469245e9be5ce50fb433af7f4a91870c1" translate="yes" xml:space="preserve">
          <source>For example, to show the diff of the exif information of a file instead of the binary information (assuming you have the exif tool installed), add the following section to your &lt;code&gt;$GIT_DIR/config&lt;/code&gt; file (or &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; file):</source>
          <target state="translated">예를 들어, 바이너리 정보 대신 파일의 EXIF ​​정보의 차이를 표시하려면 (exif 도구가 설치되어 있다고 가정) &lt;code&gt;$GIT_DIR/config&lt;/code&gt; 파일 (또는 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt; 파일)에 다음 섹션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="0cf3c72a4130dae24f8e93d376c795356d04a806" translate="yes" xml:space="preserve">
          <source>For example, with this topology:</source>
          <target state="translated">예를 들어이 토폴로지의 경우</target>
        </trans-unit>
        <trans-unit id="9026d38d92fad70bfcca633c7e54419876aa74d7" translate="yes" xml:space="preserve">
          <source>For example, with this:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="94a38b75a57da5e0f9eccf5408c94c3056500ecd" translate="yes" xml:space="preserve">
          <source>For example, you can choose a single person to maintain the project&amp;rsquo;s primary public repository. Other developers then clone this repository and each work in their own clone. When they have a series of changes that they&amp;rsquo;re happy with, they ask the maintainer to pull from the branch containing the changes. The maintainer reviews their changes and pulls them into the primary repository, which other developers pull from as necessary to stay coordinated. The Linux kernel and other projects use variants of this model.</source>
          <target state="translated">예를 들어, 프로젝트의 기본 공용 저장소를 유지하기 위해 한 사람을 선택할 수 있습니다. 그런 다음 다른 개발자는이 저장소를 복제하고 각 저장소는 자체 복제본에서 작업합니다. 그들이 만족하는 일련의 변경 사항이 있으면 관리자에게 변경 사항이 포함 된 지점에서 가져 오도록 요청합니다. 관리자는 변경 사항을 검토하고 기본 저장소로 가져 와서 다른 개발자가 조정을 유지하기 위해 필요한 경우 가져옵니다. Linux 커널 및 기타 프로젝트는이 모델의 변형을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0740e14a7a7f21956f0379ce28c5b2be003ef53b" translate="yes" xml:space="preserve">
          <source>For example, you&amp;rsquo;d want to do this after doing a &lt;code&gt;git read-tree&lt;/code&gt;, to link up the stat index details with the proper files.</source>
          <target state="translated">예를 들어, &lt;code&gt;git read-tree&lt;/code&gt; 를 수행 한 후 통계 색인 세부 사항을 적절한 파일과 연결하기 위해 이를 수행하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0af803cded757214a9f60d6e61360566eb8261f1" translate="yes" xml:space="preserve">
          <source>For git&amp;rsquo;s pre-defined color slots, the attributes are meant to be reset at the beginning of each item in the colored output. So setting &lt;code&gt;color.decorate.branch&lt;/code&gt; to &lt;code&gt;black&lt;/code&gt; will paint that branch name in a plain &lt;code&gt;black&lt;/code&gt;, even if the previous thing on the same output line (e.g. opening parenthesis before the list of branch names in &lt;code&gt;log --decorate&lt;/code&gt; output) is set to be painted with &lt;code&gt;bold&lt;/code&gt; or some other attribute. However, custom log formats may do more complicated and layered coloring, and the negated forms may be useful there.</source>
          <target state="translated">git의 사전 정의 된 색상 슬롯의 경우 속성은 색상이 지정된 출력의 각 항목 시작 부분에서 재설정됩니다. 따라서 &lt;code&gt;color.decorate.branch&lt;/code&gt; 를 &lt;code&gt;black&lt;/code&gt; 으로 설정 하면 동일한 출력 행의 이전 항목 (예 : &lt;code&gt;log --decorate&lt;/code&gt; 출력 의 분기 이름 목록 앞에 여는 괄호 )이 다음과 같이 설정되어 있어도 해당 분기 이름을 일반 &lt;code&gt;black&lt;/code&gt; 칠 합니다. &lt;code&gt;bold&lt;/code&gt; 로 표시 되거나 다른 속성으로 표시됩니다. 그러나 사용자 지정 로그 형식은 더 복잡하고 계층화 된 채색을 수행 할 수 있으며 무효화 된 형식이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e39902dddf1a6f048d53b1c87575ee4b12254521" translate="yes" xml:space="preserve">
          <source>For hints on submission using the IMAP interface, see the EXAMPLE section of &lt;a href=&quot;git-imap-send&quot;&gt;git-imap-send[1]&lt;/a&gt;.</source>
          <target state="translated">IMAP 인터페이스를 사용한 제출에 대한 힌트는 &lt;a href=&quot;git-imap-send&quot;&gt;git-imap-send [1]&lt;/a&gt; 의 EXAMPLE 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="30ba9877f29cd2e9b6e46df54ef9603700cf47bd" translate="yes" xml:space="preserve">
          <source>For hints on using &lt;code&gt;git send-email&lt;/code&gt; to send your patches through the GMail SMTP server, see the EXAMPLE section of &lt;a href=&quot;git-send-email&quot;&gt;git-send-email[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;git send-email&lt;/code&gt; 을 사용 하여 GMail SMTP 서버를 통해 패치를 보내는 방법 에 대한 힌트 는 &lt;a href=&quot;git-send-email&quot;&gt;git-send-email [1]&lt;/a&gt; 의 예 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="98a5ba2755b886f28a6b38a3063fb22b4953fd08" translate="yes" xml:space="preserve">
          <source>For instance, if the command &lt;code&gt;git push origin master:foreign&lt;/code&gt; were run the hook would receive a line like the following:</source>
          <target state="translated">예를 들어, &lt;code&gt;git push origin master:foreign&lt;/code&gt; 명령 이 실행 된 경우 후크는 다음과 같은 행을받습니다.</target>
        </trans-unit>
        <trans-unit id="b7654d69e08e0a1f9383662a9764223dc833d854" translate="yes" xml:space="preserve">
          <source>For instance, if the main working tree (or bare repository) is moved, linked working trees will be unable to locate it. Running &lt;code&gt;repair&lt;/code&gt; in the main working tree will reestablish the connection from linked working trees back to the main working tree.</source>
          <target state="translated">예를 들어, 기본 작업 트리 (또는 베어 저장소)가 이동되면 연결된 작업 트리가이를 찾을 수 없습니다. 주 작업 트리에서 &lt;code&gt;repair&lt;/code&gt; 를 실행 하면 연결된 작업 트리에서 주 작업 트리로의 연결이 다시 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e0da88c77b6050a1f8498227b0e9ea61aad1dd42" translate="yes" xml:space="preserve">
          <source>For instance, if you configured the &lt;code&gt;diff.algorithm&lt;/code&gt; variable to a non-default value and want to use the default one, then you have to use &lt;code&gt;--diff-algorithm=default&lt;/code&gt; option.</source>
          <target state="translated">예를 들어 &lt;code&gt;diff.algorithm&lt;/code&gt; 변수를 기본값이 아닌 값으로 구성하고 기본값을 사용하려면 &lt;code&gt;--diff-algorithm=default&lt;/code&gt; 옵션 을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c03b6c2e674301ea043615909864bcef9fc3a8b4" translate="yes" xml:space="preserve">
          <source>For instance, imagine we are accessing &lt;code&gt;https://example.com/foo.git&lt;/code&gt;. When Git looks into a config file to see if a section matches this context, it will consider the two a match if the context is a more-specific subset of the pattern in the config file. For example, if you have this in your config file:</source>
          <target state="translated">예를 들어 &lt;code&gt;https://example.com/foo.git&lt;/code&gt; 에 액세스한다고 가정 하십시오 . Git이 구성 파일을 조사하여 섹션이이 컨텍스트와 일치하는지 확인하면 컨텍스트가 구성 파일에서 패턴의보다 특정한 서브 세트 인 경우 두 섹션이 일치하는 것으로 간주됩니다. 예를 들어, 설정 파일에 이것을 가지고 있다면 :</target>
        </trans-unit>
        <trans-unit id="160dca6e4172cec7a014617ee2140fea1d612055" translate="yes" xml:space="preserve">
          <source>For internal use only. Used in handshaking the wire protocol. Contains a colon &lt;code&gt;:&lt;/code&gt; separated list of keys with optional values &lt;code&gt;key[=value]&lt;/code&gt;. Presence of unknown keys and values must be ignored.</source>
          <target state="translated">내부 전용. 와이어 프로토콜을 핸드 쉐이킹하는 데 사용됩니다. 선택적 값이 &lt;code&gt;key[=value]&lt;/code&gt; 인 콜론 &lt;code&gt;:&lt;/code&gt; 구분 된 키 목록을 포함합니다 . 알 수없는 키와 값의 존재는 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="7c3c8218b8f3420e2d309aa9107b8abd4e99e346" translate="yes" xml:space="preserve">
          <source>For local repositories, also supported by Git natively, the following syntaxes may be used:</source>
          <target state="translated">Git에서 기본적으로 지원하는 로컬 리포지토리의 경우 다음 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc185d3a233093301eeacaae1d44792c3563d415" translate="yes" xml:space="preserve">
          <source>For more detailed explanation on these common options, see also &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore[7]&lt;/a&gt;.</source>
          <target state="translated">이러한 공통 옵션에 대한 자세한 설명은 &lt;a href=&quot;gitdiffcore&quot;&gt;gitdiffcore [7]&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cfb518a2bdb468f6a1698c12278a7c2890c2e01b" translate="yes" xml:space="preserve">
          <source>For more details about the &amp;lt;pathspec&amp;gt; syntax, see the &lt;code&gt;pathspec&lt;/code&gt; entry in &lt;a href=&quot;gitglossary&quot;&gt;gitglossary[7]&lt;/a&gt;.</source>
          <target state="translated">&amp;lt;pathspec&amp;gt; 구문에 대한 자세한 내용은 &lt;a href=&quot;gitglossary&quot;&gt;gitglossary [7]&lt;/a&gt; 의 &lt;code&gt;pathspec&lt;/code&gt; 항목을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f0360b14fd2012ea432fadffcf3782c95bbb3d96" translate="yes" xml:space="preserve">
          <source>For more details, see the &lt;code&gt;pathspec&lt;/code&gt; entry in &lt;a href=&quot;gitglossary&quot;&gt;gitglossary[7]&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 은 &lt;a href=&quot;gitglossary&quot;&gt;gitglossary [7]&lt;/a&gt; 의 &lt;code&gt;pathspec&lt;/code&gt; 항목을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dee223e709585f8622ae3db9c408c2275df286e3" translate="yes" xml:space="preserve">
          <source>For more information about submodules, see &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules[7]&lt;/a&gt;.</source>
          <target state="translated">하위 모듈에 대한 자세한 내용은 &lt;a href=&quot;gitsubmodules&quot;&gt;gitsubmodules [7]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf4d0c9e8fd0a561af6eb800b4aa95d1953e08dc" translate="yes" xml:space="preserve">
          <source>For non-linear topology, such as</source>
          <target state="translated">다음과 같은 비선형 토폴로지의 경우</target>
        </trans-unit>
        <trans-unit id="6869cf2d54fdd333756ee082074da9e8aa4cabf1" translate="yes" xml:space="preserve">
          <source>For now, the paranoid need to find some way to emulate the quarantine environment if they&amp;rsquo;d like the same protection as &quot;push&quot;. E.g. in the case of an internal mirror do the mirroring in two steps, one to fetch the untrusted objects, and then do a second &quot;push&quot; (which will use the quarantine) to another internal repo, and have internal clients consume this pushed-to repository, or embargo internal fetches and only allow them once a full &quot;fsck&quot; has run (and no new fetches have happened in the meantime).</source>
          <target state="translated">현재, 편집증은 &quot;푸시&quot;와 동일한 보호 기능을 원한다면 격리 환경을 에뮬레이트하는 방법을 찾아야합니다. 예를 들어 내부 미러의 경우 두 단계로 미러링을 수행합니다. 하나는 신뢰할 수없는 객체를 가져오고 두 번째 &quot;푸시&quot;(검역을 사용함)를 다른 내부 리포지토리에 수행하고 내부 클라이언트가이 푸시를 소비하게합니다. 내부 페치를 리포지토리 또는 금지하고 전체 &quot;fsck&quot;가 실행 된 후에 만 ​​허용합니다 (그 동안 새로운 페치가 발생하지 않음).</target>
        </trans-unit>
        <trans-unit id="133fa5a74f060c815b7406a1ab993c4e06ad0024" translate="yes" xml:space="preserve">
          <source>For open source projects it can be a good way to get more useful contributions from end users, and to introduce them to QA and development activities.</source>
          <target state="translated">오픈 소스 프로젝트의 경우 최종 사용자로부터보다 유용한 기여를 얻고이를 QA 및 개발 활동에 소개하는 좋은 방법이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd41930f44da136ca06d3f66916ab11faa591b27" translate="yes" xml:space="preserve">
          <source>For our first example, we&amp;rsquo;re going to start a totally new repository from scratch, with no pre-existing files, and we&amp;rsquo;ll call it &lt;code&gt;git-tutorial&lt;/code&gt;. To start up, create a subdirectory for it, change into that subdirectory, and initialize the Git infrastructure with &lt;code&gt;git init&lt;/code&gt;:</source>
          <target state="translated">첫 번째 예에서는 기존 파일이없는 완전히 새로운 저장소를 처음부터 시작하고이를 &lt;code&gt;git-tutorial&lt;/code&gt; 이라고합니다 . 시작하려면 하위 디렉토리를 만들고 해당 하위 디렉토리로 변경 한 다음 &lt;code&gt;git init&lt;/code&gt; 로 Git 인프라를 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="5307fd3985478faa6faac86f16463cb9c367c366" translate="yes" xml:space="preserve">
          <source>For paths with merge conflicts, &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; show the modification states of each side of the merge. For paths that do not have merge conflicts, &lt;code&gt;X&lt;/code&gt; shows the status of the index, and &lt;code&gt;Y&lt;/code&gt; shows the status of the work tree. For untracked paths, &lt;code&gt;XY&lt;/code&gt; are &lt;code&gt;??&lt;/code&gt;. Other status codes can be interpreted as follows:</source>
          <target state="translated">병합 충돌이있는 경로의 경우 &lt;code&gt;X&lt;/code&gt; 및 &lt;code&gt;Y&lt;/code&gt; 는 병합 각 측면의 수정 상태를 보여줍니다. 병합 충돌이없는 경로의 경우 &lt;code&gt;X&lt;/code&gt; 는 인덱스 의 상태를 나타내고 &lt;code&gt;Y&lt;/code&gt; 는 작업 트리의 상태를 나타냅니다. 추적되지 않은 경로의 경우 &lt;code&gt;XY&lt;/code&gt; 는 &lt;code&gt;??&lt;/code&gt; . 다른 상태 코드는 다음과 같이 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7032989b4e615b54922dcaa29834b5d11069ae03" translate="yes" xml:space="preserve">
          <source>For people who do parsing: to make it more robust, just ignore any lines between the first and last one (&quot;&amp;lt;sha1&amp;gt;&quot; and &quot;filename&quot; lines) where you do not recognize the tag words (or care about that particular one) at the beginning of the &quot;extended information&quot; lines. That way, if there is ever added information (like the commit encoding or extended commit commentary), a blame viewer will not care.</source>
          <target state="translated">구문 분석을 수행하는 사람들의 경우 :보다 강력하게하려면 태그 단어를 인식하지 못하는 첫 번째 행과 마지막 행 ( &quot;&amp;lt;sha1&amp;gt;&quot;및 &quot;filename&quot;행) 사이의 행을 무시하십시오 (또는 특정 단어에 신경 쓰십시오). &quot;확장 된 정보&quot;줄의 시작 부분에. 이런 식으로 커밋 인코딩이나 확장 커밋 주석과 같은 추가 정보가 있으면 책임 뷰어는 신경 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3a8933e3664a281a0f1007219c1a5fb906f5b9c" translate="yes" xml:space="preserve">
          <source>For performance reasons, by default, &lt;code&gt;-C&lt;/code&gt; option finds copies only if the original file of the copy was modified in the same changeset. This flag makes the command inspect unmodified files as candidates for the source of copy. This is a very expensive operation for large projects, so use it with caution. Giving more than one &lt;code&gt;-C&lt;/code&gt; option has the same effect.</source>
          <target state="translated">성능상의 이유로 기본적으로 &lt;code&gt;-C&lt;/code&gt; 옵션은 사본의 원본 파일이 동일한 변경 세트에서 수정 된 경우에만 사본을 찾습니다. 이 플래그는 명령이 수정되지 않은 파일을 사본 소스 후보로 검사하게합니다. 대규모 프로젝트의 경우 비용이 많이 드는 작업이므로주의해서 사용하십시오. 둘 이상의 &lt;code&gt;-C&lt;/code&gt; 옵션을 제공하면 동일한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b9345e0345532d160619f268731569cef16617e" translate="yes" xml:space="preserve">
          <source>For plain blobs, it shows the plain contents.</source>
          <target state="translated">일반 얼룩의 경우 일반 내용이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9e1c4f262d546f1a8d01796c1dc838262d4af7ed" translate="yes" xml:space="preserve">
          <source>For precedence rules within and between exclude sources, see &lt;a href=&quot;gitignore&quot;&gt;gitignore[5]&lt;/a&gt;.</source>
          <target state="translated">제외 소스 내부와 소스 간의 우선 순위 규칙은 &lt;a href=&quot;gitignore&quot;&gt;gitignore [5]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e52f5f667fd4d7c4b839fc8977488698f28dddb" translate="yes" xml:space="preserve">
          <source>For projects with few developers, or for synchronizing a few private repositories, this may be all you need.</source>
          <target state="translated">개발자가 적은 프로젝트 또는 소수의 개인 저장소를 동기화하는 데 필요한 것입니다.</target>
        </trans-unit>
        <trans-unit id="0fbf0a1225d8cd0da43e8dc6b186868e699b6219" translate="yes" xml:space="preserve">
          <source>For quickly making a snapshot, you can omit &quot;push&quot;. In this mode, non-option arguments are not allowed to prevent a misspelled subcommand from making an unwanted stash entry. The two exceptions to this are &lt;code&gt;stash -p&lt;/code&gt; which acts as alias for &lt;code&gt;stash push -p&lt;/code&gt; and pathspec elements, which are allowed after a double hyphen &lt;code&gt;--&lt;/code&gt; for disambiguation.</source>
          <target state="translated">스냅 샷을 빠르게 만들려면 &quot;푸시&quot;를 생략 할 수 있습니다. 이 모드에서는 맞춤법이 잘못된 하위 명령이 원하지 않는 숨김 항목을 만드는 것을 방지하기 위해 비 옵션 인수가 허용되지 않습니다. 이에 대한 두 가지 예외는 &lt;code&gt;stash -p&lt;/code&gt; 에 대한 별칭 역할을 &lt;code&gt;stash push -p&lt;/code&gt; 이중 하이픈 후 사용할 수 있으며 pathspec 요소 &lt;code&gt;--&lt;/code&gt; 모호성을 위해.</target>
        </trans-unit>
        <trans-unit id="513a986f0bbc369f77d7fc94a6a47375b99e8d89" translate="yes" xml:space="preserve">
          <source>For quickly making a snapshot, you can omit &quot;push&quot;. In this mode, non-option arguments are not allowed to prevent a misspelled subcommand from making an unwanted stash entry. The two exceptions to this are &lt;code&gt;stash -p&lt;/code&gt; which acts as alias for &lt;code&gt;stash push -p&lt;/code&gt; and pathspecs, which are allowed after a double hyphen &lt;code&gt;--&lt;/code&gt; for disambiguation.</source>
          <target state="translated">스냅 샷을 빠르게 만들기 위해 &quot;푸시&quot;를 생략 할 수 있습니다. 이 모드에서 옵션이 아닌 인수는 철자가 틀린 부속 명령이 원치 않는 숨김 항목을 작성하는 것을 막을 수 없습니다. 이에 대한 두 가지 예외는 &lt;code&gt;stash -p&lt;/code&gt; 에 대한 별칭 역할을 &lt;code&gt;stash push -p&lt;/code&gt; 이중 하이픈 후 사용할 수 있으며 pathspecs, &lt;code&gt;--&lt;/code&gt; 모호성을 위해.</target>
        </trans-unit>
        <trans-unit id="10b29e2b2e8e16a8f0d937588e990a303d5a39cb" translate="yes" xml:space="preserve">
          <source>For reading options: read only from global &lt;code&gt;~/.gitconfig&lt;/code&gt; and from &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; rather than from all available files.</source>
          <target state="translated">읽기 옵션 : 사용 가능한 모든 파일이 아닌 전역 &lt;code&gt;~/.gitconfig&lt;/code&gt; 및 &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; 에서만 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="f670c3a49f96ee071030446b2338be3d3b61c282" translate="yes" xml:space="preserve">
          <source>For reading options: read only from system-wide &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; rather than from all available files.</source>
          <target state="translated">읽기 옵션 : 사용 가능한 모든 파일이 아닌 시스템 전체 &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; 에서만 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="1a0b8cd1ef1778fc9e72b8ac1ede20b2c02305dd" translate="yes" xml:space="preserve">
          <source>For reading options: read only from the repository &lt;code&gt;.git/config&lt;/code&gt; rather than from all available files.</source>
          <target state="translated">읽기 옵션 : 사용 가능한 모든 파일이 아닌 리포지토리 &lt;code&gt;.git/config&lt;/code&gt; 에서만 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="52ad1818a91b579273748ec3f745c2ea8925da11" translate="yes" xml:space="preserve">
          <source>For remote helpers that implement &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt;, this capability allows the refs to be constrained to a private namespace, instead of writing to refs/heads or refs/remotes directly. It is recommended that all importers providing the &lt;code&gt;import&lt;/code&gt; capability use this. It&amp;rsquo;s mandatory for &lt;code&gt;export&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 또는 &lt;code&gt;export&lt;/code&gt; 를 구현하는 원격 헬퍼의 경우이 기능을 사용하면 참조 / 헤드 또는 참조 / 원격에 직접 쓰는 대신 참조 네임 스페이스를 개인 네임 스페이스로 제한 할 수 있습니다. &lt;code&gt;import&lt;/code&gt; 기능을 제공하는 모든 임포터가이를 사용하는 것이 좋습니다 . &lt;code&gt;export&lt;/code&gt; 이 필수입니다 .</target>
        </trans-unit>
        <trans-unit id="443450d98036603164f83ff3df4c2bf679d11741" translate="yes" xml:space="preserve">
          <source>For remotes that require curl (http, https and ftp), the URL to the proxy to use for that remote. Set to the empty string to disable proxying for that remote.</source>
          <target state="translated">curl (http, https 및 ftp)이 필요한 원격의 경우 해당 원격에 사용할 프록시의 URL입니다. 해당 리모트에 대한 프록시를 사용하지 않으려면 빈 문자열로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8af93420a9afb3e813edb57f9ce58a35a5de2989" translate="yes" xml:space="preserve">
          <source>For remotes that require curl (http, https and ftp), the method to use for authenticating against the proxy in use (probably set in &lt;code&gt;remote.&amp;lt;name&amp;gt;.proxy&lt;/code&gt;). See &lt;code&gt;http.proxyAuthMethod&lt;/code&gt;.</source>
          <target state="translated">curl (http, https 및 ftp)이 필요한 원격의 경우 사용중인 프록시에 대해 인증하는 데 사용할 방법입니다 (아마도 &lt;code&gt;remote.&amp;lt;name&amp;gt;.proxy&lt;/code&gt; 에 설정되어 있음 ). &lt;code&gt;http.proxyAuthMethod&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff12c5f69e6a4dbe2b8b7bc739ac234198e179f4" translate="yes" xml:space="preserve">
          <source>For scripting, you can ask it to be quiet with the &quot;--quiet&quot; flag, which allows you to do things like</source>
          <target state="translated">스크립팅의 경우 &quot;--quiet&quot;플래그를 사용하여 조용히 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ad68ca568ca7f00dfca41d4efe640136cb611e6" translate="yes" xml:space="preserve">
          <source>For some frontends, though, it is useful to be able to read back data from the current repository as it is being updated (for example when the source material describes objects in terms of patches to be applied to previously imported objects). This can be accomplished by connecting the frontend and fast-import via bidirectional pipes:</source>
          <target state="translated">그러나 일부 프론트 엔드의 경우, 업데이트 될 때 현재 저장소에서 데이터를 다시 읽을 수있는 것이 유용합니다 (예 : 소스 자료가 이전에 가져온 오브젝트에 적용 할 패치로 오브젝트를 설명하는 경우). 양방향 파이프를 통해 프런트 엔드와 빠른 가져 오기를 연결하면됩니다.</target>
        </trans-unit>
        <trans-unit id="b5ea8ea5b2c1cd3e6d47c32a09c62d3c70b6ee6f" translate="yes" xml:space="preserve">
          <source>For some interesting examples of Git use, see the &lt;a href=&quot;howto-index&quot;&gt;howtos&lt;/a&gt;.</source>
          <target state="translated">Git 사용에 대한 흥미로운 예는 &lt;a href=&quot;howto-index&quot;&gt;howtos를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd917a632df420113bd1fa62c1a75d6d0838fcf8" translate="yes" xml:space="preserve">
          <source>For sorting purposes, fields with numeric values sort in numeric order (&lt;code&gt;objectsize&lt;/code&gt;, &lt;code&gt;authordate&lt;/code&gt;, &lt;code&gt;committerdate&lt;/code&gt;, &lt;code&gt;creatordate&lt;/code&gt;, &lt;code&gt;taggerdate&lt;/code&gt;). All other fields are used to sort in their byte-value order.</source>
          <target state="translated">정렬을 위해 숫자 값이있는 필드는 숫자 순서로 정렬됩니다 ( &lt;code&gt;objectsize&lt;/code&gt; , &lt;code&gt;authordate&lt;/code&gt; , &lt;code&gt;committerdate&lt;/code&gt; , &lt;code&gt;creatordate&lt;/code&gt; , &lt;code&gt;taggerdate&lt;/code&gt; ). 다른 모든 필드는 바이트 값 순서로 정렬하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="032b282727ffc0c1c45df3e884598bae17ea6ac4" translate="yes" xml:space="preserve">
          <source>For specifying settings like &lt;code&gt;verbosity&lt;/code&gt; (how much output to write to stderr) and &lt;code&gt;depth&lt;/code&gt; (how much history is wanted in the case of a shallow clone) that affect how other commands are carried out.</source>
          <target state="translated">다른 명령이 수행되는 방식에 영향을주는 세부 &lt;code&gt;verbosity&lt;/code&gt; (stderr에 쓸 출력량) 및 &lt;code&gt;depth&lt;/code&gt; (얕은 복제의 경우 원하는 기록 량 )와 같은 설정을 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="c02205be8f69628f646f89a0276ec82187cc890c" translate="yes" xml:space="preserve">
          <source>For submodules, this setting can be overridden using the &lt;code&gt;submodule.fetchJobs&lt;/code&gt; config setting.</source>
          <target state="translated">하위 모듈의 경우이 설정은 &lt;code&gt;submodule.fetchJobs&lt;/code&gt; 구성 설정을 사용하여 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4b69b6e908fa58f8bfb0090b464d01ba7afd33a" translate="yes" xml:space="preserve">
          <source>For such a test, you need to merge master and topic somehow. One way to do it is to pull master into the topic branch:</source>
          <target state="translated">이러한 테스트를 위해서는 어떻게 든 마스터와 주제를 병합해야합니다. 이를 수행하는 한 가지 방법은 마스터를 주제 분기로 끌어 오는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e3a970f50f86b7e372ecc38ba0a4b965f601d385" translate="yes" xml:space="preserve">
          <source>For tags, it shows the tag message and the referenced objects.</source>
          <target state="translated">태그의 경우 태그 메시지와 참조 된 객체가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e66e4764a23ddc1ac17a40208b614c40e3d1e8cd" translate="yes" xml:space="preserve">
          <source>For the &lt;code&gt;squash&lt;/code&gt; and &lt;code&gt;fixup&lt;/code&gt; operation, all commits that were squashed are listed as being rewritten to the squashed commit. This means that there will be several lines sharing the same &lt;code&gt;new-sha1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;squash&lt;/code&gt; 및 &lt;code&gt;fixup&lt;/code&gt; 작업의 경우 스쿼시 된 모든 커밋이 스쿼시 된 커밋에 다시 작성된 것으로 나열됩니다. 이는 동일한 &lt;code&gt;new-sha1&lt;/code&gt; 을 공유하는 여러 줄이 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="0288085d533925ac75b1f295d9e834640d8fad16" translate="yes" xml:space="preserve">
          <source>For the complete list of paths which Git checks for references, and the order it uses to decide which to choose when there are multiple references with the same shorthand name, see the &quot;SPECIFYING REVISIONS&quot; section of &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;.</source>
          <target state="translated">Git이 참조를 확인하는 전체 경로 목록과 동일한 속기 이름을 가진 여러 참조가있을 때 선택할 경로를 결정하는 데 사용되는 순서는 &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions의&lt;/a&gt; &quot; SPECIFYING REVISIONS&quot;섹션을 참조하십시오 [7] .</target>
        </trans-unit>
        <trans-unit id="44d025151b0ff5e996c1070f067a89933eee64e1" translate="yes" xml:space="preserve">
          <source>For the initial import, &lt;code&gt;git archimport&lt;/code&gt; expects to find itself in an empty directory. To follow the development of a project that uses Arch, rerun &lt;code&gt;git archimport&lt;/code&gt; with the same parameters as the initial import to perform incremental imports.</source>
          <target state="translated">초기 가져 오기의 경우 &lt;code&gt;git archimport&lt;/code&gt; 는 빈 디렉토리에서 자신을 찾을 것으로 예상합니다. Arch를 사용하는 프로젝트 개발 을 수행하려면 초기 가져 오기와 동일한 매개 변수로 &lt;code&gt;git archimport&lt;/code&gt; 를 다시 실행하여 증분 가져 오기를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c91c81358174e9b87a92bafd019b5720cbf2a8d2" translate="yes" xml:space="preserve">
          <source>For the purpose of breaking a filepair, diffcore-break examines the extent of changes between the contents of the files before and after modification (i.e. the contents that have &quot;bcd1234&amp;hellip;​&quot; and &quot;0123456&amp;hellip;​&quot; as their SHA-1 content ID, in the above example). The amount of deletion of original contents and insertion of new material are added together, and if it exceeds the &quot;break score&quot;, the filepair is broken into two. The break score defaults to 50% of the size of the smaller of the original and the result (i.e. if the edit shrinks the file, the size of the result is used; if the edit lengthens the file, the size of the original is used), and can be customized by giving a number after &quot;-B&quot; option (e.g. &quot;-B75&quot; to tell it to use 75%).</source>
          <target state="translated">파일 쌍을 분리하기 위해 diffcore-break는 수정 전후의 파일 내용 (예 : SHA-1 컨텐츠 ID로 &quot;bcd1234&amp;hellip;&quot;및 &quot;0123456&amp;hellip;&quot;이있는 내용) 사이의 변경 정도를 검사합니다. 위의 예에서). 원본 내용의 삭제량과 새로운 자료의 삽입이 함께 추가되고 &quot;단점&quot;을 초과하면 파일 쌍이 두 개로 나뉩니다. 중단 점수는 기본적으로 원본보다 작은 크기와 결과의 50 %로 설정됩니다 (예 : 편집이 파일을 축소하면 결과 크기가 사용됩니다. 편집이 파일을 길게하면 원본 크기가 사용됨) ) 및 &quot;-B&quot;옵션 뒤에 숫자를 제공하여 사용자 정의 할 수 있습니다 (예 : &quot;-B75&quot;는 75 %를 사용하도록 지시 함).</target>
        </trans-unit>
        <trans-unit id="62f1a958bc660b7d22544723f673271098befa81" translate="yes" xml:space="preserve">
          <source>For the purpose of merging broken filepairs back, it uses a different &quot;extent of changes&quot; computation from the ones used by diffcore-break and diffcore-rename. It counts only the deletion from the original, and does not count insertion. If you removed only 10 lines from a 100-line document, even if you added 910 new lines to make a new 1000-line document, you did not do a complete rewrite. diffcore-break breaks such a case in order to help diffcore-rename to consider such filepairs as candidate of rename/copy detection, but if filepairs broken that way were not matched with other filepairs to create rename/copy, then this transformation merges them back into the original &quot;modification&quot;.</source>
          <target state="translated">손상된 파일 쌍을 병합하기 위해 diffcore-break 및 diffcore-rename에서 사용 된 것과 다른 &quot;extent of changes&quot;계산을 사용합니다. 원본에서의 삭제 만 계산하고 삽입은 계산하지 않습니다. 100 줄짜리 문서에서 10 줄만 제거했다면 새로운 1000 줄짜리 문서를 만들기 위해 910 줄을 추가하더라도 완전히 다시 쓰지 않았습니다. diffcore-break는 diffcore-rename이 이름 바꾸기 / 복사 탐지의 후보와 같은 파일 쌍을 고려하도록 돕기 위해 이러한 경우를 중단하지만, 그런 방식으로 손상된 파일 쌍이 다른 파일 쌍과 일치하지 않아 이름 바꾸기 / 복사를 작성하는 경우이 변환은 다시 병합합니다. 원래의 &quot;수정&quot;으로</target>
        </trans-unit>
        <trans-unit id="6ab2225889ebaecccd59bff89db6e9b9331d68f2" translate="yes" xml:space="preserve">
          <source>For the sake of clarity, let&amp;rsquo;s stay with &lt;code&gt;git cat-file&lt;/code&gt;, because it</source>
          <target state="translated">명확성을 위해 &lt;code&gt;git cat-file&lt;/code&gt; 을 유지 하십시오.</target>
        </trans-unit>
        <trans-unit id="3256aa918e5b4c1710b691c8cd23b5d5181ec72c" translate="yes" xml:space="preserve">
          <source>For the sake of simplicity and interoperating with Subversion, it is recommended that all &lt;code&gt;git svn&lt;/code&gt; users clone, fetch and dcommit directly from the SVN server, and avoid all &lt;code&gt;git clone&lt;/code&gt;/&lt;code&gt;pull&lt;/code&gt;/&lt;code&gt;merge&lt;/code&gt;/&lt;code&gt;push&lt;/code&gt; operations between Git repositories and branches. The recommended method of exchanging code between Git branches and users is &lt;code&gt;git format-patch&lt;/code&gt; and &lt;code&gt;git am&lt;/code&gt;, or just 'dcommit&amp;rsquo;ing to the SVN repository.</source>
          <target state="translated">단순성과 Subversion과의 상호 운용성을 위해 모든 &lt;code&gt;git svn&lt;/code&gt; 사용자는 SVN 서버에서 직접 복제, 페치 및 dcommit하고 Git 저장소와 분기 사이의 모든 &lt;code&gt;git clone&lt;/code&gt; / &lt;code&gt;pull&lt;/code&gt; / &lt;code&gt;merge&lt;/code&gt; / &lt;code&gt;push&lt;/code&gt; 작업을 피하는 것이 좋습니다. Git 브랜치와 사용자간에 코드를 교환하는 데 권장되는 방법은 &lt;code&gt;git format-patch&lt;/code&gt; 및 &lt;code&gt;git am&lt;/code&gt; 또는 SVN 리포지토리에 'dcommit'하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2279b6e7f152e69847961316b26521ce7eeaaca8" translate="yes" xml:space="preserve">
          <source>For these commands, specifying a single revision, using the notation described in the previous section, means the set of commits &lt;code&gt;reachable&lt;/code&gt; from the given commit.</source>
          <target state="translated">이 명령에서 이전 절에서 설명한 표기법을 사용하여 단일 개정을 지정 하면 지정된 커밋에서 &lt;code&gt;reachable&lt;/code&gt; 있는 커밋 세트를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="bd23aa2eb5a5735171ddacb742b9284ac1e13d5d" translate="yes" xml:space="preserve">
          <source>For this example, suppose &lt;code&gt;I&lt;/code&gt; created &lt;code&gt;file.txt&lt;/code&gt; which was modified by &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;X&lt;/code&gt; in different ways. The single-parent commits &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt;, and &lt;code&gt;Y&lt;/code&gt; do not change &lt;code&gt;file.txt&lt;/code&gt;. The merge commit &lt;code&gt;M&lt;/code&gt; was created by resolving the merge conflict to include both changes from &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; and hence is not TREESAME to either. The merge commit &lt;code&gt;R&lt;/code&gt;, however, was created by ignoring the contents of &lt;code&gt;file.txt&lt;/code&gt; at &lt;code&gt;M&lt;/code&gt; and taking only the contents of &lt;code&gt;file.txt&lt;/code&gt; at &lt;code&gt;X&lt;/code&gt;. Hence, &lt;code&gt;R&lt;/code&gt; is TREESAME to &lt;code&gt;X&lt;/code&gt; but not &lt;code&gt;M&lt;/code&gt;. Finally, the natural merge resolution to create &lt;code&gt;N&lt;/code&gt; is to take the contents of &lt;code&gt;file.txt&lt;/code&gt; at &lt;code&gt;R&lt;/code&gt;, so &lt;code&gt;N&lt;/code&gt; is TREESAME to &lt;code&gt;R&lt;/code&gt; but not &lt;code&gt;C&lt;/code&gt;. The merge commits &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; are TREESAME to their first parents, but not to their second parents, &lt;code&gt;Z&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; respectively.</source>
          <target state="translated">이 예를 들어, 가정 &lt;code&gt;I&lt;/code&gt; 만든 &lt;code&gt;file.txt&lt;/code&gt; 를 수정했습니다 , &lt;code&gt;B&lt;/code&gt; , 및 &lt;code&gt;X&lt;/code&gt; 를 다른 방법으로. 단일 부모 커밋 &lt;code&gt;C&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; 및 &lt;code&gt;Y&lt;/code&gt; 는 &lt;code&gt;file.txt&lt;/code&gt; 를 변경하지 않습니다 . 병합 커밋 &lt;code&gt;M&lt;/code&gt; 은 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 의 변경 사항을 모두 포함하도록 병합 충돌을 해결하여 만들어 졌으므로 TREESAME이 아닙니다. 그러나 병합 커밋 &lt;code&gt;R&lt;/code&gt; 은 &lt;code&gt;M&lt;/code&gt; 에서 &lt;code&gt;file.txt&lt;/code&gt; 의 내용을 무시하고 &lt;code&gt;file.txt&lt;/code&gt; &lt;code&gt;X&lt;/code&gt; 의 내용 만 취하여 생성되었습니다. &lt;code&gt;A&lt;/code&gt; 시를. 따라서 &lt;code&gt;R&lt;/code&gt; 은 &lt;code&gt;X&lt;/code&gt; 에 대해 TREESAME 이지만 &lt;code&gt;M&lt;/code&gt; 은 아닙니다 . 마지막으로 &lt;code&gt;N&lt;/code&gt; 을 만드는 자연스러운 병합 해결 방법 은 &lt;code&gt;R&lt;/code&gt; 에서 &lt;code&gt;file.txt&lt;/code&gt; 의 내용을 가져 오는 것이므로 &lt;code&gt;N&lt;/code&gt; 은 &lt;code&gt;R&lt;/code&gt; 에는 TREESAME 이지만 &lt;code&gt;C&lt;/code&gt; 는 아닙니다 . 병합 커밋 &lt;code&gt;O&lt;/code&gt; 와 &lt;code&gt;P&lt;/code&gt; 는 첫 번째 부모에게는 나무 같지만 두 번째 부모 인 &lt;code&gt;Z&lt;/code&gt; 와 &lt;code&gt;Y&lt;/code&gt; 에는 각각 그렇지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="74da4e1940c3e7e40b0478bfdb6a84a981ccd45c" translate="yes" xml:space="preserve">
          <source>For this reason it is strongly recommended that users repack the repository with &lt;code&gt;git repack -a -d&lt;/code&gt; after fast-import completes, allowing Git to reorganize the packfiles for faster data access. If blob deltas are suboptimal (see above) then also adding the &lt;code&gt;-f&lt;/code&gt; option to force recomputation of all deltas can significantly reduce the final packfile size (30-50% smaller can be quite typical).</source>
          <target state="translated">따라서 빠른 가져 오기가 완료된 후 사용자가 &lt;code&gt;git repack -a -d&lt;/code&gt; 를 사용하여 리포지토리를 다시 포장 하여 Git이 더 빠른 데이터 액세스를 위해 팩 파일을 재구성 할 수 있도록 하는 것이 좋습니다 . Blob 델타가 차선책 인 경우 (위 참조) &lt;code&gt;-f&lt;/code&gt; 옵션을 추가하면 모든 델타를 강제로 재 계산하여 최종 팩 파일 크기를 크게 줄일 수 있습니다 (30-50 % 더 작을 수 있음).</target>
        </trans-unit>
        <trans-unit id="0c101be68a53a28136d34207f208a2b09cd96fd2" translate="yes" xml:space="preserve">
          <source>For transports that SVN handles authentication for (http, https, and plain svn), specify the username. For other transports (e.g. &lt;code&gt;svn+ssh://&lt;/code&gt;), you must include the username in the URL, e.g. &lt;code&gt;svn+ssh://foo@svn.bar.com/project&lt;/code&gt;</source>
          <target state="translated">SVN이 (http, https 및 일반 svn)에 대한 인증을 처리하는 전송의 경우 사용자 이름을 지정하십시오. 다른 전송 (예 : &lt;code&gt;svn+ssh://&lt;/code&gt; )의 경우 URL에 사용자 이름을 포함해야합니다 (예 : &lt;code&gt;svn+ssh://foo@svn.bar.com/project&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="884bf4d941685ae2ac82a222d5a5cd34350cf6bb" translate="yes" xml:space="preserve">
          <source>For trees, it shows the names (equivalent to &lt;code&gt;git ls-tree&lt;/code&gt; with --name-only).</source>
          <target state="translated">나무의 경우 이름이 표시됩니다 ( --name-only의 &lt;code&gt;git ls-tree&lt;/code&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="add825378fcd5c043a391a94c20d1353e2f3f4d7" translate="yes" xml:space="preserve">
          <source>For true distributed development that supports proper merging, published branches should never be rewritten.</source>
          <target state="translated">적절한 병합을 지원하는 진정한 분산 개발의 경우 게시 된 분기를 다시 작성해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="3d68fc99046b8e48302665b1b866f7694067fd6a" translate="yes" xml:space="preserve">
          <source>For use with --textconv or --filters, to allow specifying an object name and a path separately, e.g. when it is difficult to figure out the revision from which the blob came.</source>
          <target state="translated">--textconv 또는 --filters와 함께 사용하여 개체 이름과 경로를 별도로 지정할 수 있습니다 (예 : 얼룩의 수정본을 파악하기 어려운 경우).</target>
        </trans-unit>
        <trans-unit id="e72ffb4fac055436e16518cc2f4fb21127e4cb40" translate="yes" xml:space="preserve">
          <source>For writing options: write to global &lt;code&gt;~/.gitconfig&lt;/code&gt; file rather than the repository &lt;code&gt;.git/config&lt;/code&gt;, write to &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; file if this file exists and the &lt;code&gt;~/.gitconfig&lt;/code&gt; file doesn&amp;rsquo;t.</source>
          <target state="translated">쓰기 옵션 : 저장소 &lt;code&gt;.git/config&lt;/code&gt; 대신 글로벌 &lt;code&gt;~/.gitconfig&lt;/code&gt; 파일 에 쓰기, 이 파일이 있고 &lt;code&gt;~/.gitconfig&lt;/code&gt; 파일이없는 경우 &lt;code&gt;$XDG_CONFIG_HOME/git/config&lt;/code&gt; 파일에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="1d4f90bdceeed64344a78d1a30eb973c4a695eed" translate="yes" xml:space="preserve">
          <source>For writing options: write to system-wide &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; rather than the repository &lt;code&gt;.git/config&lt;/code&gt;.</source>
          <target state="translated">쓰기 옵션 : 저장소 &lt;code&gt;.git/config&lt;/code&gt; 대신 시스템 전체 &lt;code&gt;$(prefix)/etc/gitconfig&lt;/code&gt; 씁니다 .</target>
        </trans-unit>
        <trans-unit id="ab6a40ba6d951665186720914cfcdda1831523bb" translate="yes" xml:space="preserve">
          <source>For writing options: write to the repository &lt;code&gt;.git/config&lt;/code&gt; file. This is the default behavior.</source>
          <target state="translated">쓰기 옵션 : 저장소 &lt;code&gt;.git/config&lt;/code&gt; 파일에 씁니다 . 이것이 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="1b61f0964f0c12ab159b1b9cbdaad36acf5d4cd8" translate="yes" xml:space="preserve">
          <source>Force &lt;code&gt;git gc&lt;/code&gt; to run even if there may be another &lt;code&gt;git gc&lt;/code&gt; instance running on this repository.</source>
          <target state="translated">이 저장소에서 다른 &lt;code&gt;git gc&lt;/code&gt; 인스턴스가 실행 중이 더라도 &lt;code&gt;git gc&lt;/code&gt; 를 강제 로 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="2041f78f7b4213165ad0484df1b0863ad820d047" translate="yes" xml:space="preserve">
          <source>Force renaming or moving of a file even if the target exists</source>
          <target state="translated">대상이 존재하더라도 파일의 이름을 바꾸거나 파일을 강제로 이동</target>
        </trans-unit>
        <trans-unit id="ecd78b0e67ad331a13ae4cb8f4e6a9ed04fc189e" translate="yes" xml:space="preserve">
          <source>Force the cloning process from a repository on a local filesystem to copy the files under the &lt;code&gt;.git/objects&lt;/code&gt; directory instead of using hardlinks. This may be desirable if you are trying to make a back-up of your repository.</source>
          <target state="translated">로컬 파일 시스템의 저장소에서 복제 프로세스를 수행 하여 하드 링크를 사용하는 대신 &lt;code&gt;.git/objects&lt;/code&gt; 디렉토리 아래에 파일을 복사하십시오 . 저장소를 백업하려는 경우이 방법이 바람직 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aad6db9c36a2f2837e6ea58135f2a7c135ffcc5" translate="yes" xml:space="preserve">
          <source>Force the merge even if the files are not up to date.</source>
          <target state="translated">파일이 최신이 아닌 경우에도 병합을 강제합니다.</target>
        </trans-unit>
        <trans-unit id="b35554b966d1f9e773a7eeb185af7c152ef043be" translate="yes" xml:space="preserve">
          <source>Force the parent commit, even if it is not a direct parent.</source>
          <target state="translated">직접적인 부모가 아닌 경우에도 부모 커밋을 강제 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8fd0762700f6c31dd37961618e48e9600a28f63f" translate="yes" xml:space="preserve">
          <source>Force updating modified existing branches, even if doing so would cause commits to be lost (as the new commit does not contain the old commit).</source>
          <target state="translated">수정 된 기존 분기를 강제로 업데이트하면 새 커밋에 이전 커밋이 포함되지 않으므로 커밋이 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c16110b137eeeb074b6bb1a45d5cee67e8b8d7d" translate="yes" xml:space="preserve">
          <source>Forces fast-import to close the current packfile, generate its unique SHA-1 checksum and index, and start a new packfile. This command is optional and is not needed to perform an import.</source>
          <target state="translated">빠른 가져 오기로 현재 팩 파일을 닫고 고유 한 SHA-1 체크섬 및 색인을 생성 한 후 새 팩 파일을 시작합니다. 이 명령은 선택 사항이며 가져 오기를 수행하는 데 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a687c2c8da515bb3889e24f9c0c80b813b24084" translate="yes" xml:space="preserve">
          <source>Forces fast-import to close the current packfile, start a new one, and to save out all current branch refs, tags and marks.</source>
          <target state="translated">빠른 가져 오기로 현재 팩 파일을 닫고 새 팩 파일을 시작하며 모든 현재 분기 참조, 태그 및 마크를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="434a9daac438458d6a5542866bf4627ab056ebc0" translate="yes" xml:space="preserve">
          <source>Forcing git fetch to do non-fast-forward updates</source>
          <target state="translated">빨리 감기가 아닌 업데이트를 수행하도록 git fetch를 강제 실행</target>
        </trans-unit>
        <trans-unit id="07c2be944c0e6602c04932a6e3d9ec7d07d27d65" translate="yes" xml:space="preserve">
          <source>Forget about the current merge in progress. Leave the index and the working tree as-is.</source>
          <target state="translated">현재 진행중인 병합을 잊어 버리십시오. 인덱스와 작업 트리를 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="b7fac01fb2068412feecd8f7081be42b5f011f68" translate="yes" xml:space="preserve">
          <source>Forget about the current merge in progress. Leave the index and the working tree as-is. If &lt;code&gt;MERGE_AUTOSTASH&lt;/code&gt; is present, the stash entry will be saved to the stash list.</source>
          <target state="translated">현재 진행중인 병합은 잊어 버리십시오. 인덱스와 작업 트리는 그대로 둡니다. 경우 &lt;code&gt;MERGE_AUTOSTASH&lt;/code&gt; 이 존재하는, 숨김 항목이 숨김 목록에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="81bdf759eac78632844fbde02bcf81c1762add7d" translate="yes" xml:space="preserve">
          <source>Forget about the current operation in progress. Can be used to clear the sequencer state after a failed cherry-pick or revert.</source>
          <target state="translated">현재 진행중인 작업을 잊어 버리십시오. 체리 픽 선택 또는 복귀 실패 후 시퀀서 상태를 지우는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc2093ee15e651049bc58aa54bb94be570859e07" translate="yes" xml:space="preserve">
          <source>Format data by columns:</source>
          <target state="translated">열별로 데이터 형식을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="74cf0d3233deb63a1885a09b7a59d2c4cacb7451" translate="yes" xml:space="preserve">
          <source>Format data by rows:</source>
          <target state="translated">행별로 데이터를 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="1490d94054ac9f1a7565287cb4c10caa7d0a3ff1" translate="yes" xml:space="preserve">
          <source>Format of the file(s) specified in sendemail.aliasesFile. Must be one of &lt;code&gt;mutt&lt;/code&gt;, &lt;code&gt;mailrc&lt;/code&gt;, &lt;code&gt;pine&lt;/code&gt;, &lt;code&gt;elm&lt;/code&gt;, or &lt;code&gt;gnus&lt;/code&gt;, or &lt;code&gt;sendmail&lt;/code&gt;.</source>
          <target state="translated">sendemail.aliasesFile에 지정된 파일 형식. &lt;code&gt;mutt&lt;/code&gt; , &lt;code&gt;mailrc&lt;/code&gt; , &lt;code&gt;pine&lt;/code&gt; , &lt;code&gt;elm&lt;/code&gt; , &lt;code&gt;gnus&lt;/code&gt; 또는 &lt;code&gt;sendmail&lt;/code&gt; 중 하나 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="85b75659b13a3c18419a2059ae24d18f7aec62d9" translate="yes" xml:space="preserve">
          <source>Format of the resulting archive: &lt;code&gt;tar&lt;/code&gt; or &lt;code&gt;zip&lt;/code&gt;. If this option is not given, and the output file is specified, the format is inferred from the filename if possible (e.g. writing to &quot;foo.zip&quot; makes the output to be in the zip format). Otherwise the output format is &lt;code&gt;tar&lt;/code&gt;.</source>
          <target state="translated">결과 아카이브의 형식 : &lt;code&gt;tar&lt;/code&gt; 또는 &lt;code&gt;zip&lt;/code&gt; . 이 옵션을 지정하지 않고 출력 파일을 지정하면 가능한 경우 파일 이름에서 형식이 유추됩니다 (예 : &quot;foo.zip&quot;에 쓰면 출력이 zip 형식이됩니다). 그렇지 않으면 출력 형식은 &lt;code&gt;tar&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2804d9f16a38553f8238529c90d66e7d7426c150" translate="yes" xml:space="preserve">
          <source>Formats</source>
          <target state="translated">Formats</target>
        </trans-unit>
        <trans-unit id="4bec9575721b2739ed1e7c56eb6c8471084fcbcf" translate="yes" xml:space="preserve">
          <source>Forms</source>
          <target state="translated">Forms</target>
        </trans-unit>
        <trans-unit id="97808e16f7b3e0748cf911affe6a2e5f5336bd69" translate="yes" xml:space="preserve">
          <source>Fortunately, Git also keeps a log, called a &quot;reflog&quot;, of all the previous values of each branch. So in this case you can still find the old history using, for example,</source>
          <target state="translated">다행히도 Git은 &quot;reflog&quot;라고하는 각 분기의 모든 이전 값에 대한 로그를 유지합니다. 따라서이 경우에도 예를 들어</target>
        </trans-unit>
        <trans-unit id="52aedb174e481572a146a6eee6e65f3145e19419" translate="yes" xml:space="preserve">
          <source>Fortunately, when you try and merge branches imported from Arch, Git will find a good merge base, and it has a good chance of identifying patches that have been traded out-of-sequence between the branches.</source>
          <target state="translated">다행히도 Arch에서 가져온 브랜치를 병합하려고 시도하면 Git은 좋은 병합 기반을 찾고 브랜치간에 순서가 맞지 않게 거래 된 패치를 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f243a4b31e069ad1af1905a7b7ee3c0a6bc4a9d9" translate="yes" xml:space="preserve">
          <source>Freely Skip Around Branches</source>
          <target state="translated">지점을 자유롭게 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="4f5fb89546fa56451bf07260d4420bcc62940bb0" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions (FAQ)</source>
          <target state="translated">자주 묻는 질문 (FAQ)</target>
        </trans-unit>
        <trans-unit id="6954599bb4bd53fc74592c122080450ce5ed81db" translate="yes" xml:space="preserve">
          <source>Frequently asked questions about using Git</source>
          <target state="translated">Git 사용에 대해 자주 묻는 질문</target>
        </trans-unit>
        <trans-unit id="bc2451038a48527dcbeab53ccfe9fbac5f2cad0f" translate="yes" xml:space="preserve">
          <source>From a clean working directory:</source>
          <target state="translated">깨끗한 작업 디렉토리에서 :</target>
        </trans-unit>
        <trans-unit id="e5d597f5b08d8d486fa4fe348997e77a44c54af8" translate="yes" xml:space="preserve">
          <source>From a remote repository:</source>
          <target state="translated">원격 저장소에서 :</target>
        </trans-unit>
        <trans-unit id="288bfe5db4a5e76e3e6479e8536caa4995b7e02e" translate="yes" xml:space="preserve">
          <source>From a tarball:</source>
          <target state="translated">타르볼에서 :</target>
        </trans-unit>
        <trans-unit id="734c2e78c0e94a1be8f8ce3bed6beeb7e74b3905" translate="yes" xml:space="preserve">
          <source>From the Git 1.5.4 series and further, many Git commands (not all of them at the time of the writing though) come with an enhanced option parser.</source>
          <target state="translated">Git 1.5.4 시리즈 이상에서 많은 Git 명령 (작성 당시 모든 명령이 아님)에는 향상된 옵션 파서가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a7a0e1c60991430a8700058d7dbaaa429f71c02b" translate="yes" xml:space="preserve">
          <source>From this point, the result of either of the following commands:</source>
          <target state="translated">이 시점에서 다음 명령 중 하나의 결과 :</target>
        </trans-unit>
        <trans-unit id="3e41340cee5d477151048da29744ee1316a7f6cb" translate="yes" xml:space="preserve">
          <source>Frontends may choose to issue checkpoints during extremely large and long running imports, or when they need to allow another Git process access to a branch. However given that a 30 GiB Subversion repository can be loaded into Git through fast-import in about 3 hours, explicit checkpointing may not be necessary.</source>
          <target state="translated">프런트 엔드는 매우 크고 오래 실행되는 가져 오기 중이나 다른 Git 프로세스가 분기에 액세스해야 할 때 검사 점을 발행하도록 선택할 수 있습니다. 그러나 30 GiB Subversion 저장소를 약 3 시간 내에 빠른 가져 오기를 통해 Git에로드 할 수 있으므로 명시적인 체크 포인트가 필요하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45f585d5b13263a74e89d30321fceb20439bc1e7" translate="yes" xml:space="preserve">
          <source>Frontends should prefer the &lt;code&gt;raw&lt;/code&gt; format if the source material already uses UNIX-epoch format, can be coaxed to give dates in that format, or its format is easily convertible to it, as there is no ambiguity in parsing.</source>
          <target state="translated">소스 자료가 이미 UNIX-epoch 형식을 사용하거나 해당 형식으로 날짜를 제공하기 위해 동축 될 수 있거나 구문 분석에 모호성이 없으므로 형식을 쉽게 변환 할 수있는 경우 프론트 엔드는 &lt;code&gt;raw&lt;/code&gt; 형식을 선호해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f3cc2873d5f4e3e8be387b77133d15ba005de66f" translate="yes" xml:space="preserve">
          <source>Frontends which have efficient access to all revisions of a single file (for example reading an RCS/CVS ,v file) can choose to supply all revisions of that file as a sequence of consecutive &lt;code&gt;blob&lt;/code&gt; commands. This allows fast-import to deltify the different file revisions against each other, saving space in the final packfile. Marks can be used to later identify individual file revisions during a sequence of &lt;code&gt;commit&lt;/code&gt; commands.</source>
          <target state="translated">단일 파일의 모든 개정판에 효율적으로 액세스 할 수있는 프론트 엔드 (예 : RCS / CVS, v 파일 읽기)는 해당 파일의 모든 개정판을 일련의 연속적인 &lt;code&gt;blob&lt;/code&gt; 명령 으로 제공하도록 선택할 수 있습니다 . 이를 통해 빠른 가져 오기를 통해 서로 다른 파일 개정판을 서로 다른 것으로 수정하여 최종 팩 파일의 공간을 절약 할 수 있습니다. 일련의 &lt;code&gt;commit&lt;/code&gt; 명령 중에 마크를 사용하여 개별 파일 개정을 나중에 식별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3519d227e718b16c5b769aae01680cf2cd77dc46" translate="yes" xml:space="preserve">
          <source>Full URL and absolute URL of the gitweb script; in earlier versions of gitweb you might have need to set those variables, but now there should be no need to do it. See &lt;code&gt;$per_request_config&lt;/code&gt; if you need to set them still.</source>
          <target state="translated">gitweb 스크립트의 전체 URL 및 절대 URL. 이전 버전의 gitweb에서는 해당 변수를 설정해야 할 수도 있지만 이제는 설정할 필요가 없습니다. 여전히 설정해야 할 경우 &lt;code&gt;$per_request_config&lt;/code&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a108e2708a06a554ba0c3dc09504268225bd27f7" translate="yes" xml:space="preserve">
          <source>Full pattern set</source>
          <target state="translated">풀 패턴 세트</target>
        </trans-unit>
        <trans-unit id="b8fec8cb8e4460222f34da65fd7e0d2a0f5118ab" translate="yes" xml:space="preserve">
          <source>Function used to determine which repositories should be shown. This subroutine should take one parameter, the full path to a project, and if it returns true, that project will be included in the projects list and can be accessed through gitweb as long as it fulfills the other requirements described by $export_ok, $projects_list, and $projects_maxdepth. Example:</source>
          <target state="translated">표시 할 리포지토리를 결정하는 데 사용되는 기능입니다. 이 서브 루틴은 하나의 매개 변수, 프로젝트의 전체 경로를 가져야하며, true를 리턴하면 해당 프로젝트는 프로젝트 목록에 포함되며 $ export_ok, $ projects_list에 설명 된 다른 요구 사항을 충족하는 한 gitweb을 통해 액세스 할 수 있습니다. 및 $ projects_maxdepth. 예:</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="953f869510869f147aa66935f6f2e4c1b01346f2" translate="yes" xml:space="preserve">
          <source>Fundamental data structures and utilities of Git. Exposes only limited source code management tools.</source>
          <target state="translated">Git의 기본 데이터 구조 및 유틸리티. 제한된 소스 코드 관리 도구 만 노출합니다.</target>
        </trans-unit>
        <trans-unit id="2a68bfcdf45f0d6508d348a650a90dad4898fc87" translate="yes" xml:space="preserve">
          <source>Further chapters cover more specialized topics.</source>
          <target state="translated">추가 장에서는보다 전문적인 주제를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="bc4614e5e44f10e9735555c384229ac13d88fcbe" translate="yes" xml:space="preserve">
          <source>Further documentation</source>
          <target state="translated">추가 문서</target>
        </trans-unit>
        <trans-unit id="1a67b11bbb73911c0ea7f808bf383dac0f90b1d2" translate="yes" xml:space="preserve">
          <source>Further suppose that the other person already pushed changes leading to A back to the original repository from which you two obtained the original commit X.</source>
          <target state="translated">또한 다른 사람이 이미 변경 사항을 푸시하여 A가 원래 커밋 X를 얻은 원래 저장소로 되돌려 놓았다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="11dea5e071893c59426ef6a8d5f500708e7c087c" translate="yes" xml:space="preserve">
          <source>Further, remember how I said that &lt;code&gt;git write-tree&lt;/code&gt; writes the contents of the &lt;strong&gt;index&lt;/strong&gt; file to the tree, and thus what we just committed was in fact the &lt;strong&gt;original&lt;/strong&gt; contents of the file &lt;code&gt;hello&lt;/code&gt;, not the new ones. We did that on purpose, to show the difference between the index state, and the state in the working tree, and how they don&amp;rsquo;t have to match, even when we commit things.</source>
          <target state="translated">또한 &lt;code&gt;git write-tree&lt;/code&gt; 가 &lt;strong&gt;인덱스&lt;/strong&gt; 파일 의 내용을 트리에 기록 한다고 말했기 때문에 방금 커밋 한 것은 실제로 새로운 파일이 아닌 &lt;code&gt;hello&lt;/code&gt; 파일 의 &lt;strong&gt;원래&lt;/strong&gt; 내용이었습니다 . 우리는 의도적으로 인덱스 상태와 작업 트리의 상태 간의 차이와 일을 커밋 할 때 일치하지 않아도되는 방법을 보여주기 위해 그렇게했습니다.</target>
        </trans-unit>
        <trans-unit id="12a1c3eb3c3466df160e63355f0a70980e5d8a54" translate="yes" xml:space="preserve">
          <source>Further, several additional files are created or updated per commit by git-filter-branch. Some of these are for supporting the convenience functions provided by git-filter-branch (such as map()), while others are for keeping track of internal state (but could have also been accessed by user filters; one of git-filter-branch&amp;rsquo;s regression tests does so). This essentially amounts to using the filesystem as an IPC mechanism between git-filter-branch and the user-provided filters. Disks tend to be a slow IPC mechanism, and writing these files also effectively represents a forced synchronization point between separate processes that we hit with every commit.</source>
          <target state="translated">또한 git-filter-branch에 의해 커밋 당 몇 개의 추가 파일이 생성되거나 업데이트됩니다. 이 중 일부는 git-filter-branch (예 : map ())에서 제공하는 편의 기능을 지원하기위한 것이고 다른 일부는 내부 상태를 추적하기위한 것입니다 (그러나 사용자 필터를 통해 액세스 할 수도 있음). 분기의 회귀 테스트가 수행됩니다). 이것은 본질적으로 파일 시스템을 git-filter-branch와 사용자 제공 필터 사이의 IPC 메커니즘으로 사용하는 것과 같습니다. 디스크는 느린 IPC 메커니즘 인 경향이 있으며, 이러한 파일을 작성하는 것은 모든 커밋에서 발생하는 개별 프로세스 간의 강제 동기화 지점을 효과적으로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="48717135930571b8087beeed13bb405458558d68" translate="yes" xml:space="preserve">
          <source>Further, the above facts mean that there are multiple reasons that &quot;tracked&quot; files might not be present in the working copy: sparsity pattern application from sparse-checkout, and submodule initialization state. Thus, commands like &lt;code&gt;git grep&lt;/code&gt; that work on tracked files in the working copy may return results that are limited by either or both of these restrictions.</source>
          <target state="translated">또한, 위의 사실은 &quot;추적 된&quot;파일이 작업 복사본에 없을 수있는 여러 가지 이유가 있음을 의미합니다. 스파 스 체크 아웃의 희소성 패턴 응용 프로그램 및 하위 모듈 초기화 상태입니다. 따라서 작업 복사본의 추적 된 파일에서 작동하는 &lt;code&gt;git grep&lt;/code&gt; 과 같은 명령 은 이러한 제한 중 하나 또는 둘 모두에 의해 제한되는 결과를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ca2383accb8da62a165b73e8556d1713934adf2" translate="yes" xml:space="preserve">
          <source>Furthermore, &lt;code&gt;git read-tree&lt;/code&gt; has special-case logic that says: if you see a file that matches in all respects in the following states, it &quot;collapses&quot; back to &quot;stage0&quot;:</source>
          <target state="translated">또한 &lt;code&gt;git read-tree&lt;/code&gt; 에는 다음과 같은 특수한 논리가 있습니다. 다음과 같은 상태에서 모든 측면에서 일치하는 파일이 표시되면 &quot;stage&quot;로 다시 &quot;축소&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="31a08e0ad75da0260fa91bb8e152e897858a7305" translate="yes" xml:space="preserve">
          <source>Furthermore, passwords need not be specified in configuration files or on the command line. If a username has been specified (with &lt;code&gt;--smtp-user&lt;/code&gt; or a &lt;code&gt;sendemail.smtpUser&lt;/code&gt;), but no password has been specified (with &lt;code&gt;--smtp-pass&lt;/code&gt; or &lt;code&gt;sendemail.smtpPass&lt;/code&gt;), then a password is obtained using &lt;code&gt;git-credential&lt;/code&gt;.</source>
          <target state="translated">또한 구성 파일이나 명령 줄에 암호를 지정할 필요가 없습니다. 사용자 이름이 지정되었지만 ( &lt;code&gt;--smtp-user&lt;/code&gt; 또는 &lt;code&gt;sendemail.smtpUser&lt;/code&gt; 사용 ) 비밀번호가 지정되지 않은 경우 ( &lt;code&gt;--smtp-pass&lt;/code&gt; 또는 &lt;code&gt;sendemail.smtpPass&lt;/code&gt; 사용 ) 비밀번호는 &lt;code&gt;git-credential&lt;/code&gt; 을 사용하여 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="eebdda6fedb5243cc4950de3133a043a2ebece61" translate="yes" xml:space="preserve">
          <source>Furthermore, supplying &lt;code&gt;--aggressive&lt;/code&gt; will tweak the &lt;code&gt;--depth&lt;/code&gt; and &lt;code&gt;--window&lt;/code&gt; options passed to &lt;a href=&quot;git-repack&quot;&gt;git-repack[1]&lt;/a&gt;. See the &lt;code&gt;gc.aggressiveDepth&lt;/code&gt; and &lt;code&gt;gc.aggressiveWindow&lt;/code&gt; settings below. By using a larger window size we&amp;rsquo;re more likely to find more optimal deltas.</source>
          <target state="translated">또한 &lt;code&gt;--aggressive&lt;/code&gt; 를 제공 하면 &lt;a href=&quot;git-repack&quot;&gt;git-repack [1]에&lt;/a&gt; 전달 된 &lt;code&gt;--depth&lt;/code&gt; 및 &lt;code&gt;--window&lt;/code&gt; 옵션 이 조정됩니다 . 아래의 &lt;code&gt;gc.aggressiveDepth&lt;/code&gt; 및 &lt;code&gt;gc.aggressiveWindow&lt;/code&gt; 설정을 참조하십시오. 더 큰 창 크기를 사용하면 더 최적의 델타를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c04d9fd3f33708a82d676293fc52e5a70fbf49e1" translate="yes" xml:space="preserve">
          <source>Future work</source>
          <target state="translated">향후 작업</target>
        </trans-unit>
        <trans-unit id="7fa52712e6497fe42aeefb82c610da75e312ec0f" translate="yes" xml:space="preserve">
          <source>GITWEB_CONFIG</source>
          <target state="translated">GITWEB_CONFIG</target>
        </trans-unit>
        <trans-unit id="9636fb1dbafa2b47af9b2233bf38584401d20651" translate="yes" xml:space="preserve">
          <source>GITWEB_CONFIG_COMMON</source>
          <target state="translated">GITWEB_CONFIG_COMMON</target>
        </trans-unit>
        <trans-unit id="f726c6360c3b65b3b136cb8ed08c06cd6bb3dc13" translate="yes" xml:space="preserve">
          <source>GITWEB_CONFIG_SYSTEM</source>
          <target state="translated">GITWEB_CONFIG_SYSTEM</target>
        </trans-unit>
        <trans-unit id="7280da4640f08695fca3fbf79b196a715d6c95d5" translate="yes" xml:space="preserve">
          <source>GIT_ALTERNATE_OBJECT_DIRECTORIES</source>
          <target state="translated">GIT_ALTERNATE_OBJECT_DIRECTORIES</target>
        </trans-unit>
        <trans-unit id="964a2aa0953b5ffb1cfcd8b66bb3d22332570f05" translate="yes" xml:space="preserve">
          <source>GIT_AUTHOR_IDENT</source>
          <target state="translated">GIT_AUTHOR_IDENT</target>
        </trans-unit>
        <trans-unit id="725c6b7276951cf72d0731356407b6a84b3e59ef" translate="yes" xml:space="preserve">
          <source>GIT_COMMITTER_IDENT</source>
          <target state="translated">GIT_COMMITTER_IDENT</target>
        </trans-unit>
        <trans-unit id="3869ed3f7a51f55040f7a430ffe9ba97f98e246e" translate="yes" xml:space="preserve">
          <source>GIT_CONFIG</source>
          <target state="translated">GIT_CONFIG</target>
        </trans-unit>
        <trans-unit id="a5d490c74fb40af786be750b380476b10d1e4b69" translate="yes" xml:space="preserve">
          <source>GIT_CONFIG_NOSYSTEM</source>
          <target state="translated">GIT_CONFIG_NOSYSTEM</target>
        </trans-unit>
        <trans-unit id="01c412ca4d08642575a66ac381c4483c043b0ee1" translate="yes" xml:space="preserve">
          <source>GIT_CVSSERVER_BASE_PATH takes the place of the argument to --base-path.</source>
          <target state="translated">GIT_CVSSERVER_BASE_PATH는 인수를 --base-path로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="4f0780cd85f15ce5f825b343d1c06abf4cfc9741" translate="yes" xml:space="preserve">
          <source>GIT_CVSSERVER_ROOT specifies a single-directory whitelist. The repository must still be configured to allow access through git-cvsserver, as described above.</source>
          <target state="translated">GIT_CVSSERVER_ROOT는 단일 디렉토리 화이트리스트를 지정합니다. 위에서 설명한대로 저장소는 여전히 git-cvsserver를 통한 액세스를 허용하도록 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4ad19a85aef9ab4dcb6f62d95b8acf07e4c4828f" translate="yes" xml:space="preserve">
          <source>GIT_EDITOR</source>
          <target state="translated">GIT_EDITOR</target>
        </trans-unit>
        <trans-unit id="c8b3461d27dba4e8c6ce0c25c772c18d60c891a3" translate="yes" xml:space="preserve">
          <source>GIT_EXT_SERVICE</source>
          <target state="translated">GIT_EXT_SERVICE</target>
        </trans-unit>
        <trans-unit id="f4a08871056eea1076c323923e7cd2cd5fd6c0a8" translate="yes" xml:space="preserve">
          <source>GIT_EXT_SERVICE_NOPREFIX</source>
          <target state="translated">GIT_EXT_SERVICE_NOPREFIX</target>
        </trans-unit>
        <trans-unit id="08b684f4da6721d3a2c8e7b518324c7c98994b4e" translate="yes" xml:space="preserve">
          <source>GIT_INDEX_FILE</source>
          <target state="translated">GIT_INDEX_FILE</target>
        </trans-unit>
        <trans-unit id="cf57e9b3a04f2696e64705102232bab489ed97a5" translate="yes" xml:space="preserve">
          <source>GIT_OBJECT_DIRECTORY</source>
          <target state="translated">GIT_OBJECT_DIRECTORY</target>
        </trans-unit>
        <trans-unit id="924d60649d04fe751450b8bd3f1fc4a48bf559cb" translate="yes" xml:space="preserve">
          <source>GIT_PAGER</source>
          <target state="translated">GIT_PAGER</target>
        </trans-unit>
        <trans-unit id="ef2d6ed7bd1e2bfa87dc927172ada3fd1bdae6d2" translate="yes" xml:space="preserve">
          <source>GIT_TRANSLOOP_DEBUG</source>
          <target state="translated">GIT_TRANSLOOP_DEBUG</target>
        </trans-unit>
        <trans-unit id="a16f454460c35cd8704027fca6876a6a8646b0f2" translate="yes" xml:space="preserve">
          <source>GMail</source>
          <target state="translated">GMail</target>
        </trans-unit>
        <trans-unit id="cda466cee33ea6d923c0d1a6805da6ace37ac3f0" translate="yes" xml:space="preserve">
          <source>GMail does not have any way to turn off line wrapping in the web interface, so it will mangle any emails that you send. You can however use &quot;git send-email&quot; and send your patches through the GMail SMTP server, or use any IMAP email client to connect to the google IMAP server and forward the emails through that.</source>
          <target state="translated">Gmail은 웹 인터페이스에서 줄 바꿈 기능을 해제 할 수있는 방법이 없으므로 보낸 이메일을 엉망으로 만듭니다. 그러나 &quot;git send-email&quot;을 사용하고 GMail SMTP 서버를 통해 패치를 보내거나 IMAP 이메일 클라이언트를 사용하여 Google IMAP 서버에 연결하고이를 통해 이메일을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31f314da9a863256952d9852bb7b935e9c829e75" translate="yes" xml:space="preserve">
          <source>GPG sign pushes.</source>
          <target state="translated">GPG 표시가 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="d2cc3c3070810078ed6b670e4bd5c8639504233f" translate="yes" xml:space="preserve">
          <source>GPG-sign commits. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space.</source>
          <target state="translated">GPG 서명 커밋. &lt;code&gt;keyid&lt;/code&gt; 인수는 커미터 ID를 기본값은 선택 사항이며; 지정된 경우 공백없이 옵션을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b1aed1c7977c0e2de26949b45fd71f731a4b1c8b" translate="yes" xml:space="preserve">
          <source>GPG-sign commits. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. &lt;code&gt;--no-gpg-sign&lt;/code&gt; is useful to countermand a &lt;code&gt;--gpg-sign&lt;/code&gt; option given earlier on the command line.</source>
          <target state="translated">GPG 서명 커밋. &lt;code&gt;keyid&lt;/code&gt; 인수는 커미터 ID를 기본값은 선택 사항이며; 지정된 경우 공백없이 옵션에 고정되어야합니다. &lt;code&gt;--no-gpg-sign&lt;/code&gt; 은 이전에 명령 줄에서 제공 한 &lt;code&gt;--gpg-sign&lt;/code&gt; 옵션 에 대응하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="064f918c2672d1e438a7a65cbdf8c083e0ff21e6" translate="yes" xml:space="preserve">
          <source>GPG-sign commits. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. &lt;code&gt;--no-gpg-sign&lt;/code&gt; is useful to countermand both &lt;code&gt;commit.gpgSign&lt;/code&gt; configuration variable, and earlier &lt;code&gt;--gpg-sign&lt;/code&gt;.</source>
          <target state="translated">GPG 서명 커밋. &lt;code&gt;keyid&lt;/code&gt; 인수는 커미터 ID를 기본값은 선택 사항이며; 지정된 경우 공백없이 옵션에 고정되어야합니다. &lt;code&gt;--no-gpg-sign&lt;/code&gt; 은 &lt;code&gt;commit.gpgSign&lt;/code&gt; 구성 변수와 이전의 &lt;code&gt;--gpg-sign&lt;/code&gt; 둘 다에 대응하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="280cb8af503fd81af0776da1e5da5b505a515ac5" translate="yes" xml:space="preserve">
          <source>GPG-sign the push request to update refs on the receiving side, to allow it to be checked by the hooks and/or be logged. If &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;--no-signed&lt;/code&gt;, no signing will be attempted. If &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;--signed&lt;/code&gt;, the push will fail if the server does not support signed pushes. If set to &lt;code&gt;if-asked&lt;/code&gt;, sign if and only if the server supports signed pushes. The push will also fail if the actual call to &lt;code&gt;gpg --sign&lt;/code&gt; fails. See &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack[1]&lt;/a&gt; for the details on the receiving end.</source>
          <target state="translated">푸시 요청에 GPG 서명을하여 수신 측의 참조를 업데이트하여 후크로 확인하거나 기록 할 수 있도록합니다. 경우 &lt;code&gt;false&lt;/code&gt; 또는이 &lt;code&gt;--no-signed&lt;/code&gt; , 어떤 서명은 시도되지 않습니다. 경우 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;--signed&lt;/code&gt; 서버가 서명 푸시를 지원하지 않는 경우, 푸시가 실패합니다. &lt;code&gt;if-asked&lt;/code&gt; 로 설정 되면 서버가 서명 된 푸시를 지원하는 경우에만 서명하십시오. &lt;code&gt;gpg --sign&lt;/code&gt; 에 대한 실제 호출이 실패하면 푸시도 실패 합니다. 수신단에 대한 자세한 내용은 &lt;a href=&quot;git-receive-pack&quot;&gt;git-receive-pack [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="359179ddafe5ac57f233ce54be02401d37d2bd8b" translate="yes" xml:space="preserve">
          <source>GPG-sign the resulting merge commit. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space.</source>
          <target state="translated">결과 병합 커밋에 GPG 서명 &lt;code&gt;keyid&lt;/code&gt; 인수는 커미터 ID를 기본값은 선택 사항이며; 지정된 경우 공백없이 옵션을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="701d2f8958de65d8fe7b7eb1b839a88b4e25736c" translate="yes" xml:space="preserve">
          <source>GPG-sign the resulting merge commit. The &lt;code&gt;keyid&lt;/code&gt; argument is optional and defaults to the committer identity; if specified, it must be stuck to the option without a space. &lt;code&gt;--no-gpg-sign&lt;/code&gt; is useful to countermand both &lt;code&gt;commit.gpgSign&lt;/code&gt; configuration variable, and earlier &lt;code&gt;--gpg-sign&lt;/code&gt;.</source>
          <target state="translated">결과 병합 커밋을 GPG로 서명합니다. &lt;code&gt;keyid&lt;/code&gt; 인수는 커미터 ID를 기본값은 선택 사항이며; 지정된 경우 공백없이 옵션에 고정되어야합니다. &lt;code&gt;--no-gpg-sign&lt;/code&gt; 은 &lt;code&gt;commit.gpgSign&lt;/code&gt; 구성 변수와 이전의 &lt;code&gt;--gpg-sign&lt;/code&gt; 둘 다에 대응하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="524cceb20916aff43a2680247362fb603a1a49c8" translate="yes" xml:space="preserve">
          <source>Garbage collect all unreferenced objects with &lt;code&gt;git gc --prune=now&lt;/code&gt; (or if your git-gc is not new enough to support arguments to &lt;code&gt;--prune&lt;/code&gt;, use &lt;code&gt;git repack -ad; git prune&lt;/code&gt; instead).</source>
          <target state="translated">가비지는 &lt;code&gt;git gc --prune=now&lt;/code&gt; 로 참조되지 않은 모든 객체를 수집합니다 (또는 git-gc가 &lt;code&gt;--prune&lt;/code&gt; 에 대한 인수를 지원하기에 충분하지 않은 새로운 경우에는 대신 &lt;code&gt;git repack -ad; git prune&lt;/code&gt; 사용하십시오).</target>
        </trans-unit>
        <trans-unit id="5bcb5f8aaf1a9e559046fd7b5b3d79bbe4d3f426" translate="yes" xml:space="preserve">
          <source>General options</source>
          <target state="translated">일반 옵션</target>
        </trans-unit>
        <trans-unit id="a5879c5c764017ca2130842dc888dcc88c04c99e" translate="yes" xml:space="preserve">
          <source>General variables</source>
          <target state="translated">일반 변수</target>
        </trans-unit>
        <trans-unit id="55fd2438a0c551b4e16240eed52ec4917c61134a" translate="yes" xml:space="preserve">
          <source>Generally speaking, rule (3) above is the simplest for users to specify. Authors of credential helpers should make an effort to assist their users by naming their program &quot;git-credential-$NAME&quot;, and putting it in the &lt;code&gt;$PATH&lt;/code&gt; or &lt;code&gt;$GIT_EXEC_PATH&lt;/code&gt; during installation, which will allow a user to enable it with &lt;code&gt;git config credential.helper $NAME&lt;/code&gt;.</source>
          <target state="translated">일반적으로 위의 규칙 (3)은 사용자가 지정하기 가장 간단합니다. 자격 증명 도우미의 작성자는 프로그램 이름을 &quot;git-credential- $ NAME&quot;로 지정하고 설치 중에 &lt;code&gt;$PATH&lt;/code&gt; 또는 &lt;code&gt;$GIT_EXEC_PATH&lt;/code&gt; 에 넣어 사용자가 &lt;code&gt;git config credential.helper $NAME&lt;/code&gt; 으로 활성화 할 수 있도록하여 사용자를 지원해야합니다. .helper $ NAME .</target>
        </trans-unit>
        <trans-unit id="f8e6a94549428bad778124c3c140042198abcb13" translate="yes" xml:space="preserve">
          <source>Generally this mode is used as an administrative interface to allow users to list repositories they have access to, create, delete, or rename repositories, or change repository descriptions and permissions.</source>
          <target state="translated">일반적으로이 모드는 사용자가 저장소에 액세스하거나 저장소를 작성, 삭제 또는 이름을 바꾸거나 저장소 설명 및 권한을 변경할 수있는 관리 인터페이스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5338e8546078668a151a9dabd932d38a31f12f5b" translate="yes" xml:space="preserve">
          <source>Generally, &lt;code&gt;git p4 clone&lt;/code&gt; is used to create a new Git directory from an existing p4 repository:</source>
          <target state="translated">일반적으로 &lt;code&gt;git p4 clone&lt;/code&gt; 은 기존 p4 저장소에서 새 Git 디렉토리를 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ad37ee86e2b3d890455e76bc1e7e0fc45d3460de" translate="yes" xml:space="preserve">
          <source>Generally, all Git operations work on the index file. Some operations work &lt;strong&gt;purely&lt;/strong&gt; on the index file (showing the current state of the index), but most operations move data between the index file and either the database or the working directory. Thus there are four main combinations:</source>
          <target state="translated">일반적으로 모든 Git 작업은 인덱스 파일에서 작동합니다. 일부 작업 은 인덱스 파일 &lt;strong&gt;에서만&lt;/strong&gt; 작동 하지만 (인덱스의 현재 상태 표시) 대부분의 작업은 인덱스 파일과 데이터베이스 또는 작업 디렉토리간에 데이터를 이동합니다. 따라서 네 가지 주요 조합이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c30116e53a947e31daeae056572933416099fbe0" translate="yes" xml:space="preserve">
          <source>Generally, dangling objects aren&amp;rsquo;t anything to worry about. They can even be very useful: if you screw something up, the dangling objects can be how you recover your old tree (say, you did a rebase, and realized that you really didn&amp;rsquo;t want to&amp;mdash;​you can look at what dangling objects you have, and decide to reset your head to some old dangling state).</source>
          <target state="translated">일반적으로 매달린 객체는 걱정할 것이 없습니다. 그것들은 매우 유용 할 수도 있습니다. 무언가를 망쳐 놓으면 매달린 물건이 오래된 나무를 어떻게 복구 할 수 있는지를 알 수 있습니다 (예를 들어, 리베이스를하고 실제로 원치 않는다는 것을 깨달았습니다. 당신이 가지고있는 물건을 가지고 머리를 오래된 매달려있는 상태로 재설정하기로 결정하십시오).</target>
        </trans-unit>
        <trans-unit id="aefb0f39d3bd01ba3e438537ce5e3b6f3d075591" translate="yes" xml:space="preserve">
          <source>Generate a &lt;code&gt;$GIT_DIR/cvs-revisions&lt;/code&gt; file containing a mapping from CVS revision numbers to newly-created Git commit IDs. The generated file will contain one line for each (filename, revision) pair imported; each line will look like</source>
          <target state="translated">CVS 개정 번호에서 새로 작성된 Git 커밋 ID 로의 맵핑이 포함 된 &lt;code&gt;$GIT_DIR/cvs-revisions&lt;/code&gt; 파일을 생성하십시오. 생성 된 파일에는 가져온 각 (파일 이름, 개정) 쌍마다 한 줄이 포함됩니다. 각 줄은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="d956a0b3c8358372085439a04d4b2593dd2bec54" translate="yes" xml:space="preserve">
          <source>Generate a credential description based on the context.</source>
          <target state="translated">컨텍스트를 기반으로 자격 증명 설명을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="8b4e72c7495787832a335e23db7d41cdc955de4e" translate="yes" xml:space="preserve">
          <source>Generate a diff using the &quot;anchored diff&quot; algorithm.</source>
          <target state="translated">&quot;고정 된 차이&quot;알고리즘을 사용하여 차이를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="c65b3bd43c187f9009fd8be60c354464048bfb2c" translate="yes" xml:space="preserve">
          <source>Generate a diff using the &quot;histogram diff&quot; algorithm.</source>
          <target state="translated">&quot;히스토그램 차이&quot;알고리즘을 사용하여 차이를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="5a810f6cb04f85c060e73d8366053dc83cbde1b6" translate="yes" xml:space="preserve">
          <source>Generate a diff using the &quot;patience diff&quot; algorithm.</source>
          <target state="translated">&quot;환자 차이&quot;알고리즘을 사용하여 차이를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="f50a5c7af33db239a645bbb0a36b9c949e7a8bfe" translate="yes" xml:space="preserve">
          <source>Generate a diffstat. By default, as much space as necessary will be used for the filename part, and the rest for the graph part. Maximum width defaults to terminal width, or 80 columns if not connected to a terminal, and can be overridden by &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt;. The width of the filename part can be limited by giving another width &lt;code&gt;&amp;lt;name-width&amp;gt;&lt;/code&gt; after a comma. The width of the graph part can be limited by using &lt;code&gt;--stat-graph-width=&amp;lt;width&amp;gt;&lt;/code&gt; (affects all commands generating a stat graph) or by setting &lt;code&gt;diff.statGraphWidth=&amp;lt;width&amp;gt;&lt;/code&gt; (does not affect &lt;code&gt;git format-patch&lt;/code&gt;). By giving a third parameter &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt;, you can limit the output to the first &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; lines, followed by &lt;code&gt;...&lt;/code&gt; if there are more.</source>
          <target state="translated">diffstat를 생성하십시오. 기본적으로 필요한만큼의 공간이 파일 이름 부분에 사용되고 나머지는 그래프 부분에 사용됩니다. 최대 너비는 기본적으로 터미널 너비 또는 터미널에 연결되지 않은 경우 80 열이며 &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; 로 재정의 할 수 있습니다 . 쉼표 뒤에 다른 너비 &lt;code&gt;&amp;lt;name-width&amp;gt;&lt;/code&gt; 를 지정 하여 파일 이름 부분의 너비를 제한 할 수 있습니다 . 그래프 부분의 폭을 사용하여 제한 될 수 &lt;code&gt;--stat-graph-width=&amp;lt;width&amp;gt;&lt;/code&gt; (a 통계의 그래프를 생성하는 모든 명령에 영향을 미친다) 또는 설정 &lt;code&gt;diff.statGraphWidth=&amp;lt;width&amp;gt;&lt;/code&gt; (영향을주지 않는 &lt;code&gt;git format-patch&lt;/code&gt; ) . 세 번째 매개 변수 &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; 를 지정하면 출력을 첫 번째 &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; 행으로 제한 할 수 있습니다 .뒤에 &lt;code&gt;...&lt;/code&gt; 더 있다면</target>
        </trans-unit>
        <trans-unit id="9a58997012274b692734905439c472fc9bf49724" translate="yes" xml:space="preserve">
          <source>Generate a request asking your upstream project to pull changes into their tree. The request, printed to the standard output, begins with the branch description, summarizes the changes and indicates from where they can be pulled.</source>
          <target state="translated">업스트림 프로젝트에 변경 사항을 트리로 가져 오도록 요청하는 요청을 생성하십시오. 표준 출력으로 인쇄 된 요청은 브랜치 설명으로 시작하여 변경 사항을 요약하고 가져올 수있는 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e43be14252a09239d3a95e69575c334d9dcee155" translate="yes" xml:space="preserve">
          <source>Generate diffs with &amp;lt;n&amp;gt; lines of context instead of the default of 3. This value is overridden by the -U option.</source>
          <target state="translated">기본값 3 대신 &amp;lt;n&amp;gt; 행의 컨텍스트를 사용하여 diff를 생성하십시오.이 값은 -U 옵션으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="0c3fb6d76074c691f7bc9656642039721293ad30" translate="yes" xml:space="preserve">
          <source>Generate diffs with &amp;lt;n&amp;gt; lines of context instead of the usual three. Implies &lt;code&gt;--patch&lt;/code&gt;.</source>
          <target state="translated">일반적인 세 ​​줄 대신 &amp;lt;n&amp;gt; 줄의 내용으로 diff를 생성하십시오. &lt;code&gt;--patch&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="5423824f37bf5ebdc5aa787498e564ca92935ec4" translate="yes" xml:space="preserve">
          <source>Generate diffs with &amp;lt;n&amp;gt; lines of context instead of the usual three. Implies &lt;code&gt;--patch&lt;/code&gt;. Implies &lt;code&gt;-p&lt;/code&gt;.</source>
          <target state="translated">일반적인 세 ​​줄 대신 &amp;lt;n&amp;gt; 줄의 내용으로 diff를 생성하십시오. &lt;code&gt;--patch&lt;/code&gt; 를 의미 합니다. &lt;code&gt;-p&lt;/code&gt; 를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="c5ed7cc57b573e7d3d35a890e87a64e8016055b8" translate="yes" xml:space="preserve">
          <source>Generate patch (see section on generating patches).</source>
          <target state="translated">패치를 생성하십시오 (패치 생성 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="468bd18b2fd829a488878e7cd9b8b00c33a3bf5f" translate="yes" xml:space="preserve">
          <source>Generate patch (see section on generating patches). This is the default.</source>
          <target state="translated">패치를 생성하십시오 (패치 생성 섹션 참조). 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="0305bd83d4a1ca283e78c45f30f1d98f9bb246bc" translate="yes" xml:space="preserve">
          <source>Generate plain patches without any diffstats.</source>
          <target state="translated">diffstats없이 일반 패치를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="0cceb279f32e8c4384bb0e8684243cdf862ab779" translate="yes" xml:space="preserve">
          <source>Generate the diff in raw format.</source>
          <target state="translated">원시 형식으로 diff를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="c49c41c6395d0de919c07a57d58570e04e74713d" translate="yes" xml:space="preserve">
          <source>Generate the diff in raw format. This is the default.</source>
          <target state="translated">원시 형식으로 diff를 생성하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="88ef8fc7ea6872f6140c434b84c60ed4bc477b71" translate="yes" xml:space="preserve">
          <source>Generates a summary of pending changes</source>
          <target state="translated">보류중인 변경 사항의 요약을 생성합니다</target>
        </trans-unit>
        <trans-unit id="b812709580c6b66bf19a88239714db45c6f547d3" translate="yes" xml:space="preserve">
          <source>Generates an RSS (or Atom) feed of changes to repository.</source>
          <target state="translated">저장소에 대한 변경 사항의 RSS (또는 Atom) 피드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6d3ce11672e300b3630956d5357a3f156d393821" translate="yes" xml:space="preserve">
          <source>Generating RSS and Atom feeds of commits, for any branch. The feeds are auto-discoverable in modern web browsers.</source>
          <target state="translated">모든 분기에 대한 커밋의 RSS 및 Atom 피드 생성 피드는 최신 웹 브라우저에서 자동 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39bd3cb8cae2c62c26836b759476b4dce92db62c" translate="yes" xml:space="preserve">
          <source>Generating diff text</source>
          <target state="translated">diff 텍스트 생성</target>
        </trans-unit>
        <trans-unit id="6e83f1be8cebf28e1aa935d46feefe8c9c9b6bff" translate="yes" xml:space="preserve">
          <source>Generating diffs</source>
          <target state="translated">차이 생성</target>
        </trans-unit>
        <trans-unit id="d70a52c9081d71ce670fc7b47fc3bc012193cc1a" translate="yes" xml:space="preserve">
          <source>Generating patch text with -p</source>
          <target state="translated">-p를 사용하여 패치 텍스트 생성</target>
        </trans-unit>
        <trans-unit id="6aeb48d435992fb6dfeaeb57975b9744c65abe0f" translate="yes" xml:space="preserve">
          <source>Generating projects list using gitweb</source>
          <target state="translated">gitweb을 사용하여 프로젝트 목록 생성</target>
        </trans-unit>
        <trans-unit id="77a43161f16023a4081e441eda8d16415635830a" translate="yes" xml:space="preserve">
          <source>Generic &amp;lt;revision range&amp;gt; expression (see &quot;SPECIFYING REVISIONS&quot; section in &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions[7]&lt;/a&gt;) means the commits in the specified range.</source>
          <target state="translated">일반 &amp;lt;개정 범위&amp;gt; 표현식 ( &lt;a href=&quot;gitrevisions&quot;&gt;gitrevisions [7]의&lt;/a&gt; &quot; SPECIFYING REVISIONS&quot;섹션 참조 )은 지정된 범위의 커밋을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6a8b0f1bc43a4668545c1d049581bdef7899704d" translate="yes" xml:space="preserve">
          <source>Get and set repository or global options</source>
          <target state="translated">저장소 또는 글로벌 옵션 가져 오기 및 설정</target>
        </trans-unit>
        <trans-unit id="e36c9f7c3a3791a600900bd999a01e746ced35ba" translate="yes" xml:space="preserve">
          <source>Get the value for a given key (optionally filtered by a regex matching the value). Returns error code 1 if the key was not found and the last value if multiple key values were found.</source>
          <target state="translated">주어진 키의 값을 가져옵니다 (선택적으로 값과 일치하는 정규 표현식으로 필터링). 키를 찾을 수 없으면 오류 코드 1을 반환하고 여러 키 값을 찾은 경우 마지막 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ed0d09699cf6099e40ea031af476399c03ae869" translate="yes" xml:space="preserve">
          <source>Gets the Subversion property given as the first argument, for a file. A specific revision can be specified with -r/--revision.</source>
          <target state="translated">파일의 첫 번째 인수로 지정된 Subversion 속성을 가져옵니다. -r /-revision을 사용하여 특정 개정을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="516c94a58b7d13bbfd33d93293ff07c0a7a0cbf5" translate="yes" xml:space="preserve">
          <source>Getting and Creating Projects</source>
          <target state="translated">프로젝트 가져 오기 및 생성</target>
        </trans-unit>
        <trans-unit id="970eb65fbea28c10c8dd662819611907796540db" translate="yes" xml:space="preserve">
          <source>Getting changes out is easy:</source>
          <target state="translated">변경 사항을 쉽게 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3ce20bb7af9a1868b401164829dfe90efbb8e6d" translate="yes" xml:space="preserve">
          <source>Getting conflict-resolution help during a merge</source>
          <target state="translated">병합 중 충돌 해결 도움말 얻기</target>
        </trans-unit>
        <trans-unit id="060f712c74598ce01e86d56802d9344d8ed68bb7" translate="yes" xml:space="preserve">
          <source>Getting help</source>
          <target state="translated">도움을 받다</target>
        </trans-unit>
        <trans-unit id="c459e54c0b44554b9b817457994c7c37528258a0" translate="yes" xml:space="preserve">
          <source>Getting updates with git pull</source>
          <target state="translated">자식 풀로 업데이트 받기</target>
        </trans-unit>
        <trans-unit id="5819778898df55e3a762f0c5728b457970d72cae" translate="yes" xml:space="preserve">
          <source>Git</source>
          <target state="translated">Git</target>
        </trans-unit>
        <trans-unit id="d732d81f4de6cbbc7c08999550694240dc675ed1" translate="yes" xml:space="preserve">
          <source>Git Commits</source>
          <target state="translated">힘내 커밋</target>
        </trans-unit>
        <trans-unit id="d0aaf3f6b8eb7d9c0d9e9cfe8351718f5fff142e" translate="yes" xml:space="preserve">
          <source>Git Diffs</source>
          <target state="translated">힘내</target>
        </trans-unit>
        <trans-unit id="2f8f97d0e40130f1bd878938daff8ad22d7dc440" translate="yes" xml:space="preserve">
          <source>Git Native</source>
          <target state="translated">힘내 네이티브</target>
        </trans-unit>
        <trans-unit id="29dd0634894701f7508333c275f98d0f1320daee" translate="yes" xml:space="preserve">
          <source>Git Repository Layout</source>
          <target state="translated">Git 리포지토리 레이아웃</target>
        </trans-unit>
        <trans-unit id="d6e98b90bf56079b25bb9356fe9439f3123affff" translate="yes" xml:space="preserve">
          <source>Git Thread Messages</source>
          <target state="translated">힘내 스레드 메시지</target>
        </trans-unit>
        <trans-unit id="cae0e86da292416c6a36a0e4ce238566c9d247c3" translate="yes" xml:space="preserve">
          <source>Git Transport</source>
          <target state="translated">힘내 교통</target>
        </trans-unit>
        <trans-unit id="a7c39055264c29496e9ec925896bc3e3ec696cb4" translate="yes" xml:space="preserve">
          <source>Git allows you to specify scripts called &quot;hooks&quot; to be run at certain points. You can use these, for example, to send all commits to the shared repository to a mailing list. See &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt;.</source>
          <target state="translated">힘내를 사용하면 특정 지점에서 실행할 &quot;후크&quot;라는 스크립트를 지정할 수 있습니다. 예를 들어,이를 사용하여 공유 저장소에 대한 모든 커밋을 메일 목록으로 보낼 수 있습니다. &lt;a href=&quot;githooks&quot;&gt;githooks [5]를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d26d4c60652b93a42ab638ebb72c8ba6beaba72" translate="yes" xml:space="preserve">
          <source>Git also keeps a pristine copy of Alice&amp;rsquo;s master branch under the name &quot;origin/master&quot;:</source>
          <target state="translated">또한 Git은 Alice의 원래 브랜치 사본을 &quot;origin / master&quot;라는 이름으로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="1738762c7d776a74999cdf10e57649ca4dc7876a" translate="yes" xml:space="preserve">
          <source>Git also provides a tool called &lt;a href=&quot;git-am&quot;&gt;git-am[1]&lt;/a&gt; (am stands for &quot;apply mailbox&quot;), for importing such an emailed series of patches. Just save all of the patch-containing messages, in order, into a single mailbox file, say &lt;code&gt;patches.mbox&lt;/code&gt;, then run</source>
          <target state="translated">Git은 또한 이메일로 전송 된 일련의 패치를 가져 오기 위해 &lt;a href=&quot;git-am&quot;&gt;git-am [1]&lt;/a&gt; (am은 &quot;사서함 적용&quot;을 나타냄) 이라는 도구를 제공합니다 . 패치가 포함 된 모든 메시지를 순서대로 단일 메일 함 파일 (예 : &lt;code&gt;patches.mbox&lt;/code&gt; )에 저장 한 후 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="1dc53eccf42e15dc7948bd5d68aac36dca57063c" translate="yes" xml:space="preserve">
          <source>Git archive</source>
          <target state="translated">힘내 아카이브</target>
        </trans-unit>
        <trans-unit id="54c5b60d3b067a46392b8d1f7e7e747f00fb6589" translate="yes" xml:space="preserve">
          <source>Git can also be used in a CVS-like mode, with a central repository that various users push changes to; see &lt;a href=&quot;git-push&quot;&gt;git-push[1]&lt;/a&gt; and &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs-migration[7]&lt;/a&gt;.</source>
          <target state="translated">Git은 다양한 사용자가 변경 사항을 푸시하는 중앙 저장소와 함께 CVS와 유사한 모드에서 사용할 수 있습니다. 참조 &lt;a href=&quot;git-push&quot;&gt;자식 푸시 [1]&lt;/a&gt; 과 &lt;a href=&quot;gitcvs-migration&quot;&gt;gitcvs 마이그레이션 [7]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12dda0ab622d98c0bb3ecd2dcca2f78143c72090" translate="yes" xml:space="preserve">
          <source>Git can detect errors when it reads an object, by checking that the object&amp;rsquo;s name is still the SHA-1 hash of its contents.</source>
          <target state="translated">Git은 객체의 이름이 여전히 내용의 SHA-1 해시인지 확인하여 객체를 읽을 때 오류를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e99355d5c834d0a7e793f2a903c686c73ccc0248" translate="yes" xml:space="preserve">
          <source>Git can help you perform a three-way merge, which can in turn be used for a many-way merge by repeating the merge procedure several times. The usual situation is that you only do one three-way merge (reconciling two lines of history) and commit the result, but if you like to, you can merge several branches in one go.</source>
          <target state="translated">Git은 3 방향 병합을 수행하는 데 도움이되며, 병합 절차를 여러 번 반복하여 다 방향 병합에 사용할 수 있습니다. 일반적인 상황은 하나의 3 방향 병합 (두 줄의 기록 조정) 만 수행하고 결과를 커밋하지만 원하는 경우 여러 분기를 한 번에 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9711e4cc3e77224217a8eadfcd9bddb77a1a6b3f" translate="yes" xml:space="preserve">
          <source>Git can quickly determine whether two objects are identical or not, just by comparing names.</source>
          <target state="translated">힘내 이름을 비교하여 두 개체가 동일한 지 여부를 신속하게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66761dbf024e7710e093b6a26bb079c9a462b99d" translate="yes" xml:space="preserve">
          <source>Git comes with a &quot;curl&quot; family of remote helpers, that handle various transport protocols, such as &lt;code&gt;git-remote-http&lt;/code&gt;, &lt;code&gt;git-remote-https&lt;/code&gt;, &lt;code&gt;git-remote-ftp&lt;/code&gt; and &lt;code&gt;git-remote-ftps&lt;/code&gt;. They implement the capabilities &lt;code&gt;fetch&lt;/code&gt;, &lt;code&gt;option&lt;/code&gt;, and &lt;code&gt;push&lt;/code&gt;.</source>
          <target state="translated">Git에는 &lt;code&gt;git-remote-http&lt;/code&gt; , &lt;code&gt;git-remote-https&lt;/code&gt; , &lt;code&gt;git-remote-ftp&lt;/code&gt; 및 &lt;code&gt;git-remote-ftps&lt;/code&gt; 와 같은 다양한 전송 프로토콜을 처리하는 &quot;curl&quot;원격 헬퍼 제품군이 제공됩니다 . 그것들은 &lt;code&gt;fetch&lt;/code&gt; , &lt;code&gt;option&lt;/code&gt; 및 &lt;code&gt;push&lt;/code&gt; 기능을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="91008229119a3ca60fa9a13273e5a206ad3c01e1" translate="yes" xml:space="preserve">
          <source>Git command-line interface and conventions</source>
          <target state="translated">Git 명령 줄 인터페이스 및 규칙</target>
        </trans-unit>
        <trans-unit id="590c7b2e50468cb97c1bacdf4c22b05f53204bcc" translate="yes" xml:space="preserve">
          <source>Git commands</source>
          <target state="translated">힘내 명령</target>
        </trans-unit>
        <trans-unit id="748a4c7cdb8da160e4137b5f163f8f4f719642f9" translate="yes" xml:space="preserve">
          <source>Git concepts</source>
          <target state="translated">힘내 개념</target>
        </trans-unit>
        <trans-unit id="23daed08ae51790de19c33ed17896e5944bcf442" translate="yes" xml:space="preserve">
          <source>Git considers each credential to have a context defined by a URL. This context is used to look up context-specific configuration, and is passed to any helpers, which may use it as an index into secure storage.</source>
          <target state="translated">Git은 각 자격 증명이 URL로 정의 된 컨텍스트를 갖는 것으로 간주합니다. 이 컨텍스트는 컨텍스트 별 구성을 조회하는 데 사용되며 보안 저장소의 인덱스로 사용할 수있는 모든 도우미에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="50d371d1d26e20ed2106ca5d2c77efab159f6b5e" translate="yes" xml:space="preserve">
          <source>Git data exporter</source>
          <target state="translated">힘내 데이터 내보내기</target>
        </trans-unit>
        <trans-unit id="df14b19afe5ac9b190d2e62a9bb072306d0becda" translate="yes" xml:space="preserve">
          <source>Git did not try to send the ref at all, typically because it is not a fast-forward and you did not force the update.</source>
          <target state="translated">Git은 심판을 전혀 보내지 않았다. 일반적으로 빨리 감기가 아니기 때문에 업데이트를 강요하지 않았기 때문이다.</target>
        </trans-unit>
        <trans-unit id="2dac5af4573e16931bda9b37c2f40888a8b49b4e" translate="yes" xml:space="preserve">
          <source>Git diff features. By performing only the transformation step yourself, you can still utilize many of Git&amp;rsquo;s diff features, including colorization, word-diff, and combined diffs for merges.</source>
          <target state="translated">힘내 diff 기능. 변형 단계 만 직접 수행하면 색상 화, 단어 차이 및 병합을위한 결합 차이를 비롯한 여러 Git의 차이 기능을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e4742213b12ec1297779eac50efdab191f84da4" translate="yes" xml:space="preserve">
          <source>Git differs from CVS in that every working tree contains a repository with a full copy of the project history, and no repository is inherently more important than any other. However, you can emulate the CVS model by designating a single shared repository which people can synchronize with; this document explains how to do that.</source>
          <target state="translated">Git은 모든 작업 트리에 전체 프로젝트 히스토리 사본이있는 저장소를 포함하고 다른 저장소보다 본질적으로 더 중요한 저장소는 없다는 점에서 CVS와 다릅니다. 그러나 사람들이 동기화 할 수있는 단일 공유 저장소를 지정하여 CVS 모델을 에뮬레이트 할 수 있습니다. 이 문서는이를 수행하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="52ba75f7d53c0098d95000c61cda5fd5ea6917af" translate="yes" xml:space="preserve">
          <source>Git directory name</source>
          <target state="translated">힘내 디렉토리 이름</target>
        </trans-unit>
        <trans-unit id="5d9fa4d20745d4b5b2bcfd60f9d543f73fbbd4e6" translate="yes" xml:space="preserve">
          <source>Git directory name, where all characters except for alphanumeric ones, &lt;code&gt;.&lt;/code&gt;, and &lt;code&gt;-&lt;/code&gt; are replaced with &lt;code&gt;_&lt;/code&gt; (this should make it easier to use the directory name in a filename if wanted)</source>
          <target state="translated">영숫자 문자를 제외한 모든 문자가있는 Git 디렉토리 이름 &lt;code&gt;.&lt;/code&gt; , 및 &lt;code&gt;-&lt;/code&gt; 는 &lt;code&gt;_&lt;/code&gt; 로 대체됩니다 (원하는 경우 파일 이름에서 디렉토리 이름을 사용하기가 더 쉬워야합니다)</target>
        </trans-unit>
        <trans-unit id="9cf813a3cd69ecbe5e00c63d983206328e14b759" translate="yes" xml:space="preserve">
          <source>Git does not allow partial checkouts, so duplicating this approach in Git would force developers to keep a local copy of modules they are not interested in touching. Commits in an enormous checkout would be slower than you&amp;rsquo;d expect as Git would have to scan every directory for changes. If modules have a lot of local history, clones would take forever.</source>
          <target state="translated">Git은 부분 체크 아웃을 허용하지 않으므로 Git에서이 접근 방식을 복제하면 개발자가 관심이없는 모듈의 로컬 사본을 유지해야합니다. Git이 모든 디렉토리에서 변경 사항을 검색해야하기 때문에 막대한 체크 아웃시 커밋이 예상보다 느려집니다. 모듈에 로컬 히스토리가 많으면 복제본이 영원히 걸립니다.</target>
        </trans-unit>
        <trans-unit id="8b2d9679cf8575fc6c4cfb84434fb5d8180eb7ab" translate="yes" xml:space="preserve">
          <source>Git explained</source>
          <target state="translated">힘내 설명</target>
        </trans-unit>
        <trans-unit id="97b68f2c19cbd9c04d7ca8ff88d2678de8cfd1c0" translate="yes" xml:space="preserve">
          <source>Git for CVS users</source>
          <target state="translated">CVS 사용자를위한 Git</target>
        </trans-unit>
        <trans-unit id="0db9018815b17c54cf84524352784d68bf492b44" translate="yes" xml:space="preserve">
          <source>Git glossary</source>
          <target state="translated">Git 용어집</target>
        </trans-unit>
        <trans-unit id="11c6d04869311aae599c74c45ab29a30fd9dc2d3" translate="yes" xml:space="preserve">
          <source>Git has a default disposition of keeping data unless it&amp;rsquo;s explicitly thrown away; this extends to holding onto local references to branches on remotes that have themselves deleted those branches.</source>
          <target state="translated">Git은 명시 적으로 버리지 않는 한 데이터를 유지하는 기본 처리 방식을 가지고 있습니다. 이것은 자체적으로 해당 분기를 삭제 한 리모컨의 분기에 대한 로컬 참조를 유지하는 것으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="c792c246c2740fcc85816c7742979ab9c07c5067" translate="yes" xml:space="preserve">
          <source>Git has an internal interface for storing and retrieving credentials from system-specific helpers, as well as prompting the user for usernames and passwords. The git-credential command exposes this interface to scripts which may want to retrieve, store, or prompt for credentials in the same manner as Git. The design of this scriptable interface models the internal C API; see credential.h for more background on the concepts.</source>
          <target state="translated">Git에는 시스템 별 도우미에서 자격 증명을 저장 및 검색하고 사용자 이름 및 암호를 묻는 메시지를 표시하는 내부 인터페이스가 있습니다. git-credential 명령은이 인터페이스를 Git과 같은 방식으로 자격 증명을 검색, 저장 또는 프롬프트 할 수있는 스크립트에 노출합니다. 이 스크립트 가능한 인터페이스의 디자인은 내부 C API를 모델링합니다. 개념에 대한 자세한 배경은 credential.h를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b5c69a965c60312962f3f44179acdc3a60b40e17" translate="yes" xml:space="preserve">
          <source>Git has no way of knowing that the new head is an updated version of the old head; it treats this situation exactly the same as it would if two developers had independently done the work on the old and new heads in parallel. At this point, if someone attempts to merge the new head in to their branch, Git will attempt to merge together the two (old and new) lines of development, instead of trying to replace the old by the new. The results are likely to be unexpected.</source>
          <target state="translated">Git은 새로운 헤드가 기존 헤드의 업데이트 된 버전임을 알 수있는 방법이 없습니다. 두 개발자가 독립적으로 기존 헤드와 새 헤드에서 동시에 작업을 수행 한 경우와 동일하게이 상황을 처리합니다. 이 시점에서 누군가가 새로운 헤드를 자신의 브랜치에 병합하려고 시도하면 Git은 기존 헤드를 새로운 것으로 교체하지 않고 두 개의 (구형과 새로운) 개발 라인을 통합하려고 시도합니다. 결과는 예상치 못한 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="06c2297147a37b1c482365d9d8f31d8dedf40fc4" translate="yes" xml:space="preserve">
          <source>Git history is represented as a series of interrelated commits. We have already seen that the &lt;code&gt;git log&lt;/code&gt; command can list those commits. Note that first line of each git log entry also gives a name for the commit:</source>
          <target state="translated">힘내 히스토리는 일련의 상호 관련된 커밋으로 표시됩니다. 우리는 이미 &lt;code&gt;git log&lt;/code&gt; 명령이 그러한 커밋을 나열 할 수 있음을 보았습니다 . 각 git log 항목의 첫 번째 줄은 커밋의 이름도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3e99ade0692d549a8a950dd96317ceaffb9107bb" translate="yes" xml:space="preserve">
          <source>Git imposes the following rules on how references are named:</source>
          <target state="translated">Git은 참조의 이름을 지정하는 방법에 대해 다음 규칙을 부과합니다.</target>
        </trans-unit>
        <trans-unit id="a288f739ab4cf5d9993c702076fe0dc6fc3ee3ba" translate="yes" xml:space="preserve">
          <source>Git internal format</source>
          <target state="translated">힘내 내부 형식</target>
        </trans-unit>
        <trans-unit id="64a97e8eaa30379dfa62ee80bea9820c4fe8a22e" translate="yes" xml:space="preserve">
          <source>Git is a Distributed Version Control system (DVCS) created by Linus Torvalds and maintained by Junio Hamano.</source>
          <target state="translated">Git은 Linus Torvalds가 생성하고 Junio ​​Hamano가 유지 관리하는 분산 버전 제어 시스템 (DVCS)입니다.</target>
        </trans-unit>
        <trans-unit id="f3967c7f5aeb4487a30c2b76c0330d8f45c7d45a" translate="yes" xml:space="preserve">
          <source>Git is a fast distributed revision control system.</source>
          <target state="translated">Git은 빠른 분산 개정 제어 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="39998d13fc7a27f9efbe60a086c013b3bd3030af" translate="yes" xml:space="preserve">
          <source>Git is a fast, scalable, distributed revision control system with an unusually rich command set that provides both high-level operations and full access to internals.</source>
          <target state="translated">Git은 매우 확장 가능한 분산 수정 제어 시스템으로, 고급 작업과 내부에 대한 모든 액세스를 제공하는 매우 풍부한 명령 세트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9fb5868e31358193ca8585301de5ca9891b34989" translate="yes" xml:space="preserve">
          <source>Git is best thought of as a tool for storing the history of a collection of files. It does this by storing compressed snapshots of the contents of a file hierarchy, together with &quot;commits&quot; which show the relationships between these snapshots.</source>
          <target state="translated">Git은 파일 모음의 히스토리를 저장하는 도구로 가장 잘 생각됩니다. 이 스냅 샷 간의 관계를 보여주는 &quot;커밋&quot;과 함께 파일 계층 구조 내용의 압축 된 스냅 샷을 저장하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="35ff36d5accbb4f2dda359fd3229598730d5aa08" translate="yes" xml:space="preserve">
          <source>Git is best thought of as a tool for storing the history of a collection of files. It stores the history as a compressed collection of interrelated snapshots of the project&amp;rsquo;s contents. In Git each such version is called a &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt;.</source>
          <target state="translated">Git은 파일 모음의 히스토리를 저장하는 도구로 가장 잘 생각됩니다. 히스토리를 프로젝트 컨텐츠의 상호 관련된 스냅 샷 모음으로 압축하여 저장합니다. Git에서는 이러한 각 버전을 &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="7a9590b40529c70c530e12c39759365698786125" translate="yes" xml:space="preserve">
          <source>Git is built on a small number of simple but powerful ideas. While it is possible to get things done without understanding them, you will find Git much more intuitive if you do.</source>
          <target state="translated">힘내는 간단하지만 강력한 아이디어를 기반으로합니다. 이해하지 않고 작업을 수행하는 것이 가능하지만 Git을 사용하면 훨씬 직관적입니다.</target>
        </trans-unit>
        <trans-unit id="acccb72bd7439cce396900f6956100688cfe6ddd" translate="yes" xml:space="preserve">
          <source>Git is to some extent character encoding agnostic.</source>
          <target state="translated">Git은 어느 정도까지는 문자 인코딩에 무관심하다.</target>
        </trans-unit>
        <trans-unit id="db4366f04a4436ab91b01ad18e3f75e42a556e25" translate="yes" xml:space="preserve">
          <source>Git namespaces</source>
          <target state="translated">Git 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="a87c04c678f1edcfea18d0a701f5da80659e7540" translate="yes" xml:space="preserve">
          <source>Git neither stops nor restarts the filter process in case the &quot;error&quot;/&quot;abort&quot; status is set. However, Git sets its exit code according to the &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; flag, mimicking the behavior of the &lt;code&gt;filter.&amp;lt;driver&amp;gt;.clean&lt;/code&gt; / &lt;code&gt;filter.&amp;lt;driver&amp;gt;.smudge&lt;/code&gt; mechanism.</source>
          <target state="translated">&quot;오류&quot;/ &quot;중단&quot;상태가 설정된 경우 Git은 필터 프로세스를 중지하거나 다시 시작하지 않습니다. 그러나 Git은 &lt;code&gt;filter.&amp;lt;driver&amp;gt;.required&lt;/code&gt; 의 동작을 모방 한 filter. &amp;lt;driver&amp;gt; .quired 플래그 에 따라 종료 코드를 설정합니다 &lt;code&gt;filter.&amp;lt;driver&amp;gt;.clean&lt;/code&gt; / &lt;code&gt;filter.&amp;lt;driver&amp;gt;.smudge&lt;/code&gt; 메커니즘.</target>
        </trans-unit>
        <trans-unit id="bcbcedc091eff7502178afecdce9f3afdc72dc05" translate="yes" xml:space="preserve">
          <source>Git provides extremely flexible and fast tools for exploring the history of a project.</source>
          <target state="translated">Git은 프로젝트 히스토리를 탐색 할 수있는 매우 유연하고 빠른 도구를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="38200bd70c851718b2397208bade5f568860b37a" translate="yes" xml:space="preserve">
          <source>Git recognizes files encoded in ASCII or one of its supersets (e.g. UTF-8, ISO-8859-1, &amp;hellip;​) as text files. Files encoded in certain other encodings (e.g. UTF-16) are interpreted as binary and consequently built-in Git text processing tools (e.g. &lt;code&gt;git diff&lt;/code&gt;) as well as most Git web front ends do not visualize the contents of these files by default.</source>
          <target state="translated">Git은 ASCII 또는 그 슈퍼 세트 중 하나 (예 : UTF-8, ISO-8859-1,&amp;hellip;)로 인코딩 된 파일을 텍스트 파일로 인식합니다. 특정 다른 인코딩 (예 : UTF-16)으로 인코딩 된 파일은 이진으로 해석되므로 내장 Git 텍스트 처리 도구 (예 : &lt;code&gt;git diff&lt;/code&gt; )뿐만 아니라 대부분의 Git 웹 프런트 엔드는 기본적으로 이러한 파일의 내용을 시각화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db884716c8275e6cfa36ed29dbc5d360bba57d0e" translate="yes" xml:space="preserve">
          <source>Git relies on the proper configuration of this variable for your operating and file system. Modifying this value may result in unexpected behavior.</source>
          <target state="translated">Git은 운영 및 파일 시스템에 대해이 변수의 올바른 구성에 의존합니다. 이 값을 수정하면 예기치 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a66f7e50154ea192af5f4749135be70398075b72" translate="yes" xml:space="preserve">
          <source>Git repositories are normally totally self-sufficient and relocatable. Unlike CVS, for example, there is no separate notion of &quot;repository&quot; and &quot;working tree&quot;. A Git repository normally &lt;strong&gt;is&lt;/strong&gt; the working tree, with the local Git information hidden in the &lt;code&gt;.git&lt;/code&gt; subdirectory. There is nothing else. What you see is what you got.</source>
          <target state="translated">Git 리포지토리는 일반적으로 완전히 자급 자족하고 재배치 가능합니다. 예를 들어 CVS와 달리 &quot;리포지토리&quot;와 &quot;작업 트리&quot;라는 별도의 개념은 없습니다. 자식은 일반적으로 리포지토리 &lt;strong&gt;입니다&lt;/strong&gt; 에 숨겨진 지역 망할 놈의 정보를 작업 트리, &lt;code&gt;.git&lt;/code&gt; 디렉토리. 다른 것은 없습니다. 당신이 보는 것은 당신이 가진 것입니다.</target>
        </trans-unit>
        <trans-unit id="cf8c005d3f0e4d9e1ff9d1e8d46ef8fd98f0bbf4" translate="yes" xml:space="preserve">
          <source>Git repository format versions</source>
          <target state="translated">힘내 저장소 형식 버전</target>
        </trans-unit>
        <trans-unit id="cd868bd588534f7cc4b6680d57c0627b3503b53c" translate="yes" xml:space="preserve">
          <source>Git sends the remote helper a list of commands on standard input, one per line. The first command is always the &lt;code&gt;capabilities&lt;/code&gt; command, in response to which the remote helper must print a list of the capabilities it supports (see below) followed by a blank line. The response to the capabilities command determines what commands Git uses in the remainder of the command stream.</source>
          <target state="translated">Git은 원격 헬퍼에게 표준 입력에 대한 명령 목록을 한 줄에 하나씩 보냅니다. 첫 번째 명령은 항상 &lt;code&gt;capabilities&lt;/code&gt; 명령이며, 원격 도우미는 지원하는 기능 목록 (아래 참조)과 빈 줄을 인쇄해야합니다. Capabilities 명령에 대한 응답은 Git이 나머지 명령 스트림에서 사용하는 명령을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="49f2ae128519616ee7193d5988bcbce620249ed4" translate="yes" xml:space="preserve">
          <source>Git supports dividing the refs of a single repository into multiple namespaces, each of which has its own branches, tags, and HEAD. Git can expose each namespace as an independent repository to pull from and push to, while sharing the object store, and exposing all the refs to operations such as &lt;a href=&quot;git-gc&quot;&gt;git-gc[1]&lt;/a&gt;.</source>
          <target state="translated">Git은 단일 리포지토리의 참조를 여러 개의 네임 스페이스로 나누는 것을 지원하며 각 네임 스페이스에는 자체 분기, 태그 및 HEAD가 있습니다. Git은 객체 저장소를 공유하고 모든 참조를 &lt;a href=&quot;git-gc&quot;&gt;git-gc [1]&lt;/a&gt; 과 같은 작업에 노출시키면서 각 네임 스페이스를 독립적 인 저장소로 노출하여 푸시하고 푸시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da0d87f50d864c408fa4b395576786d97bb31ddd" translate="yes" xml:space="preserve">
          <source>Git supports ssh, git, http, and https protocols (in addition, ftp, and ftps can be used for fetching, but this is inefficient and deprecated; do not use it).</source>
          <target state="translated">Git은 ssh, git, http 및 https 프로토콜을 지원합니다 (또한 ftp 및 ftps는 페치에 사용될 수 있지만 비효율적이며 사용되지 않으므로 사용하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="2cde7635ac8cf69f2e210aa19a54d3042440cb25" translate="yes" xml:space="preserve">
          <source>Git tracks content not files</source>
          <target state="translated">Git은 파일이 아닌 컨텐츠를 추적</target>
        </trans-unit>
        <trans-unit id="d302527fd1d763cfe7e5d18396b3435236371be0" translate="yes" xml:space="preserve">
          <source>Git treats the pattern as a shell glob suitable for consumption by fnmatch(3) with the FNM_PATHNAME flag: wildcards in the pattern will not match a / in the pathname. For example, &quot;Documentation/*.html&quot; matches &quot;Documentation/git.html&quot; but not &quot;Documentation/ppc/ppc.html&quot; or &quot;tools/perf/Documentation/perf.html&quot;.</source>
          <target state="translated">Git은 FNM_PATHNAME 플래그를 사용하여 fnmatch (3)에서 소비하기에 적합한 쉘 글로브로 패턴을 처리합니다. 패턴의 와일드 카드는 경로 이름의 /와 일치하지 않습니다. 예를 들어, &quot;Documentation / *. html&quot;은 &quot;Documentation / git.html&quot;과 일치하지만 &quot;Documentation / ppc / ppc.html&quot;또는 &quot;tools / perf / Documentation / perf.html&quot;과는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8bad0cd453249cf5d129aec87c3431738399e00" translate="yes" xml:space="preserve">
          <source>Git understands the following attributes:</source>
          <target state="translated">Git은 다음 속성을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="7e54cce67cf2641b15706179b6168b5a2d3b1bcd" translate="yes" xml:space="preserve">
          <source>Git urls</source>
          <target state="translated">힘내 URL</target>
        </trans-unit>
        <trans-unit id="751190188de5688aa514632f7b1c3310593ad2c7" translate="yes" xml:space="preserve">
          <source>Git users can broadly be grouped into four categories for the purposes of describing here a small set of useful command for everyday Git.</source>
          <target state="translated">Git 사용자는 일상적인 Git에 유용한 명령을 여기에 설명하기 위해 네 가지 범주로 크게 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7ac07d144784e0a8c84df59d7316744b8847546" translate="yes" xml:space="preserve">
          <source>Git uses a simple text format to store customizations that are per repository and are per user. Such a configuration file may look like this:</source>
          <target state="translated">Git은 간단한 텍스트 형식을 사용하여 저장소 및 사용자별로 사용자 정의를 저장합니다. 이러한 구성 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="172b4ceb66bee5a713d5dcc15584b89df5db983d" translate="yes" xml:space="preserve">
          <source>Git usually guesses correctly whether a blob contains text or binary data by examining the beginning of the contents. However, sometimes you may want to override its decision, either because a blob contains binary data later in the file, or because the content, while technically composed of text characters, is opaque to a human reader. For example, many postscript files contain only ASCII characters, but produce noisy and meaningless diffs.</source>
          <target state="translated">Git은 일반적으로 내용의 시작 부분을 검사하여 blob에 텍스트 또는 이진 데이터가 포함되어 있는지 정확하게 추측합니다. 그러나 BLOB에 파일에 나중에 이진 데이터가 포함되어 있거나 기술적으로 텍스트 문자로 구성된 내용이 사람에게 불투명하기 때문에 결정을 무시할 수도 있습니다. 예를 들어 많은 포스트 스크립트 파일에는 ASCII 문자 만 포함되어 있지만 시끄럽고 의미없는 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8049931f388e861f0f1d36c522924184358c43ba" translate="yes" xml:space="preserve">
          <source>Git was started by Linus Torvalds, and is currently maintained by Junio C Hamano. Numerous contributions have come from the Git mailing list &amp;lt;&lt;a href=&quot;mailto:git@vger.kernel.org&quot;&gt;git@vger.kernel.org&lt;/a&gt;&amp;gt;. &lt;a href=&quot;http://www.openhub.net/p/git/contributors/summary&quot;&gt;http://www.openhub.net/p/git/contributors/summary&lt;/a&gt; gives you a more complete list of contributors.</source>
          <target state="translated">Git은 Linus Torvalds에 의해 시작되었으며 현재 Junio ​​C Hamano에 의해 관리됩니다. Git 메일 링리스트 &amp;lt; &lt;a href=&quot;mailto:git@vger.kernel.org&quot;&gt;git@vger.kernel.org&lt;/a&gt; &amp;gt; 에서 많은 기여를했습니다 . &lt;a href=&quot;http://www.openhub.net/p/git/contributors/summary&quot;&gt;http://www.openhub.net/p/git/contributors/summary&lt;/a&gt; 는보다 완전한 기고자 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="526caa17e283066f503c081c2465980601606a1b" translate="yes" xml:space="preserve">
          <source>Git web interface (web frontend to Git repositories)</source>
          <target state="translated">Git 웹 인터페이스 (Git 리포지토리에 대한 웹 프론트 엔드)</target>
        </trans-unit>
        <trans-unit id="041fb03988c0360186f3faf7d7f4aee25aff3a46" translate="yes" xml:space="preserve">
          <source>Git will apply each patch in order; if any conflicts are found, it will stop, and you can fix the conflicts as described in &quot;&lt;a href=&quot;#resolving-a-merge&quot;&gt;Resolving a merge&lt;/a&gt;&quot;. (The &lt;code&gt;-3&lt;/code&gt; option tells Git to perform a merge; if you would prefer it just to abort and leave your tree and index untouched, you may omit that option.)</source>
          <target state="translated">Git은 각 패치를 순서대로 적용합니다. 충돌이 발견되면 중지되고 &quot; &lt;a href=&quot;#resolving-a-merge&quot;&gt;병합 해결&lt;/a&gt; &quot;에 설명 된대로 충돌을 해결할 수 있습니다 . ( &lt;code&gt;-3&lt;/code&gt; 옵션은 Git에게 병합을 수행하도록 지시합니다. 트리와 인덱스를 그대로두고 그대로 두려면 해당 옵션을 생략해도됩니다.)</target>
        </trans-unit>
        <trans-unit id="5affbc744831be1e58dd602e173c2e8a9635241c" translate="yes" xml:space="preserve">
          <source>Git will fail (gracefully) in case it needs to modify this file in the index e.g. when merging in a commit; thus, in case the assumed-untracked file is changed upstream, you will need to handle the situation manually.</source>
          <target state="translated">커밋에서 병합 할 때 인덱스에서이 파일을 수정해야하는 경우 Git은 (정상적으로) 실패합니다. 따라서 추적되지 않은 것으로 가정 된 파일이 업스트림으로 변경되는 경우 상황을 수동으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="48da4a71e3b0bf95013a3e083375ba4a4f8d9442" translate="yes" xml:space="preserve">
          <source>Git will limit what files it checks for changes as well as which directories are checked for untracked files based on the path names given.</source>
          <target state="translated">Git은 경로를 기반으로 변경 사항을 검사 할 파일과 추적되지 않은 파일을 검사 할 디렉토리를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="9b6711c26bfff56f55ea4e0cb9cd80ae556f923a" translate="yes" xml:space="preserve">
          <source>Git will reply</source>
          <target state="translated">힘내 답장</target>
        </trans-unit>
        <trans-unit id="bca1285083439b77ee97a317766aadc935c0bbdf" translate="yes" xml:space="preserve">
          <source>Git will sometimes need credentials from the user in order to perform operations; for example, it may need to ask for a username and password in order to access a remote repository over HTTP. This manual describes the mechanisms Git uses to request these credentials, as well as some features to avoid inputting these credentials repeatedly.</source>
          <target state="translated">Git은 때때로 작업을 수행하기 위해 사용자의 자격 증명이 필요합니다. 예를 들어 HTTP를 통해 원격 저장소에 액세스하려면 사용자 이름과 비밀번호를 요청해야 할 수 있습니다. 이 매뉴얼은 Git이 이러한 자격 증명을 요청하기 위해 사용하는 메커니즘과 이러한 자격 증명을 반복적으로 입력하지 않도록하는 일부 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="dd4de92d6643474e91f15af2289a2ff1175302eb" translate="yes" xml:space="preserve">
          <source>Git writes temporary &lt;code&gt;BASE&lt;/code&gt;, &lt;code&gt;LOCAL&lt;/code&gt;, and &lt;code&gt;REMOTE&lt;/code&gt; versions of conflicting files in the worktree by default. Git will attempt to use a temporary directory for these files when set &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Git은 기본적 으로 작업 트리에 임시 &lt;code&gt;BASE&lt;/code&gt; , &lt;code&gt;LOCAL&lt;/code&gt; 및 &lt;code&gt;REMOTE&lt;/code&gt; 버전의 충돌 파일을 씁니다 . Git은 &lt;code&gt;true&lt;/code&gt; 로 설정하면 이러한 파일에 임시 디렉토리를 사용하려고 시도 합니다 . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="24c7b4499addc9a93ccbe263411515a9a891fc27" translate="yes" xml:space="preserve">
          <source>Git&amp;rsquo;s ability to quickly import and merge patches allows a single maintainer to process incoming changes even at very high rates. And when that becomes too much, &lt;code&gt;git pull&lt;/code&gt; provides an easy way for that maintainer to delegate this job to other maintainers while still allowing optional review of incoming changes.</source>
          <target state="translated">Git의 패치 가져 오기 및 병합 기능을 통해 단일 관리자가 매우 빠른 속도로도 들어오는 변경 사항을 처리 할 수 ​​있습니다. 그리고 그것이 너무 커지면 &lt;code&gt;git pull&lt;/code&gt; 은 해당 유지 관리자 가이 작업을 다른 유지 관리자에게 위임하면서 들어오는 변경 사항을 선택적으로 검토 할 수있는 쉬운 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9715a07ab0249fd3ddbc253711eb7248c1c1366b" translate="yes" xml:space="preserve">
          <source>Git&amp;rsquo;s i18n setup code for shell scripts</source>
          <target state="translated">쉘 스크립트를위한 Git의 i18n 설정 코드</target>
        </trans-unit>
        <trans-unit id="4917cf9f784e37253e2667c9ea0e66247909051b" translate="yes" xml:space="preserve">
          <source>Git&amp;rsquo;s submodule support allows a repository to contain, as a subdirectory, a checkout of an external project. Submodules maintain their own identity; the submodule support just stores the submodule repository location and commit ID, so other developers who clone the containing project (&quot;superproject&quot;) can easily clone all the submodules at the same revision. Partial checkouts of the superproject are possible: you can tell Git to clone none, some or all of the submodules.</source>
          <target state="translated">Git의 서브 모듈 지원은 리포지토리가 외부 프로젝트의 체크 아웃을 서브 디렉토리로 포함 할 수 있도록합니다. 서브 모듈은 자신의 정체성을 유지합니다. 하위 모듈 지원은 하위 모듈 저장소 위치와 커밋 ID 만 저장하므로 포함 프로젝트 ( &quot;superproject&quot;)를 복제하는 다른 개발자는 동일한 개정에서 모든 하위 모듈을 쉽게 복제 할 수 있습니다. 수퍼 프로젝트의 부분 체크 아웃이 가능합니다 : Git에게 서브 모듈의 일부 또는 전부를 복제하지 않도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1ffaf3a57e8861e273a81c5d860f0898c1c6dac" translate="yes" xml:space="preserve">
          <source>Gitk was the first graphical repository browser. It&amp;rsquo;s written in tcl/tk.</source>
          <target state="translated">Gitk는 최초의 그래픽 저장소 브라우저였습니다. tcl / tk로 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="969a3c97b510dcff0a924faf9dee287a0e5d94ec" translate="yes" xml:space="preserve">
          <source>Gitweb assumes this charset when a line contains non-UTF-8 characters. The fallback decoding is used without error checking, so it can be even &quot;utf-8&quot;. The value must be a valid encoding; see the &lt;strong&gt;Encoding::Supported&lt;/strong&gt;(3pm) man page for a list. The default is &quot;latin1&quot;, aka. &quot;iso-8859-1&quot;.</source>
          <target state="translated">줄에 UTF-8이 아닌 문자가 포함 된 경우 Gitweb은이 문자 집합을 가정합니다. 폴백 디코딩은 오류 검사없이 사용되므로 &quot;utf-8&quot;일 수도 있습니다. 값은 유효한 인코딩이어야합니다. 목록은 &lt;strong&gt;Encoding :: Supported&lt;/strong&gt; (3pm) 매뉴얼 페이지를 참조하십시오. 기본값은 &quot;latin1&quot;입니다. &quot;iso-8859-1&quot;.</target>
        </trans-unit>
        <trans-unit id="23aa8c44f909f60d83eed1c6ecddb35429f0603e" translate="yes" xml:space="preserve">
          <source>Gitweb can show information from one or more Git repositories. These repositories have to be all on local filesystem, and have to share common repository root, i.e. be all under a single parent repository (but see also &quot;Advanced web server setup&quot; section, &quot;Webserver configuration with multiple projects' root&quot; subsection).</source>
          <target state="translated">Gitweb은 하나 이상의 Git 리포지토리에서 정보를 표시 할 수 있습니다. 이 리포지토리는 모두 로컬 파일 시스템에 있어야하며 공통 리포지토리 루트를 공유해야합니다. 즉, 단일 상위 리포지토리에 모두 있어야합니다 (그러나 &quot;고급 웹 서버 설정&quot;섹션, &quot;여러 프로젝트의 루트가있는 웹 서버 구성&quot;하위 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="80e6e4e3c32d8a850e194d0e624021eac7612871" translate="yes" xml:space="preserve">
          <source>Gitweb can use path_info (component) based URLs, or it can pass all necessary information via query parameters. The typical gitweb URLs are broken down in to five components:</source>
          <target state="translated">Gitweb은 path_info (구성 요소) 기반 URL을 사용하거나 쿼리 매개 변수를 통해 필요한 모든 정보를 전달할 수 있습니다. 일반적인 gitweb URL은 5 가지 구성 요소로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="c91227cd181327062eb5ac3babb9dcdd0a92cc2a" translate="yes" xml:space="preserve">
          <source>Gitweb provides a web interface to Git repositories. Its features include:</source>
          <target state="translated">Gitweb은 Git 리포지토리에 웹 인터페이스를 제공합니다. 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b64851fc263d72157b99e98603012bfc29c4f9ff" translate="yes" xml:space="preserve">
          <source>Gitweb reads configuration data from the following sources in the following order:</source>
          <target state="translated">Gitweb은 다음 소스에서 다음 순서로 구성 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="0b6ae99cd0fc07dd07b98d65f39c6a8d809c4979" translate="yes" xml:space="preserve">
          <source>Gitweb version, set automatically when creating gitweb.cgi from gitweb.perl. You might want to modify it if you are running modified gitweb, for example</source>
          <target state="translated">gitweb.perl에서 gitweb.cgi를 만들 때 자동으로 설정되는 Gitweb 버전. 예를 들어 수정 된 gitweb을 실행중인 경우 수정하고 싶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcc44369541727be05647a1cc4996dbc27b86060" translate="yes" xml:space="preserve">
          <source>Gitweb works with Apache and FastCGI. First you need to rename, copy or symlink gitweb.cgi to gitweb.fcgi. Let&amp;rsquo;s assume that gitweb is installed in &lt;code&gt;/usr/share/gitweb&lt;/code&gt; directory. The following Apache configuration is suitable (UNTESTED!)</source>
          <target state="translated">Gitweb은 Apache 및 FastCGI와 함께 작동합니다. 먼저 gitweb.cgi를 gitweb.fcgi로 이름을 바꾸거나 복사 또는 symlink해야합니다. gitweb이 &lt;code&gt;/usr/share/gitweb&lt;/code&gt; 디렉토리에 설치되어 있다고 가정 해 봅시다 . 다음 Apache 구성이 적합합니다 (UNTESTED!)</target>
        </trans-unit>
        <trans-unit id="42543af4180750540520e4da78d3e7076123fd5c" translate="yes" xml:space="preserve">
          <source>Give an object a human readable name based on an available ref</source>
          <target state="translated">사용 가능한 참조를 기반으로 사람이 읽을 수있는 이름을 객체에 제공</target>
        </trans-unit>
        <trans-unit id="8a08e691bc874c43f32edff7b28078841082dfd2" translate="yes" xml:space="preserve">
          <source>Give push/pull only access to developers using git-over-ssh.</source>
          <target state="translated">git-over-ssh를 사용하는 개발자에게만 push / pull 액세스 권한을 부여하십시오.</target>
        </trans-unit>
        <trans-unit id="098611c3aa4062358e82cce32a6cb2188462a62d" translate="yes" xml:space="preserve">
          <source>Give the output in an easy-to-parse format for scripts. This is similar to the short output, but will remain stable across Git versions and regardless of user configuration. See below for details.</source>
          <target state="translated">스크립트에 대해 구문 분석하기 쉬운 형식으로 출력을 제공하십시오. 이것은 짧은 출력과 비슷하지만 사용자 구성에 관계없이 Git 버전에서 안정적으로 유지됩니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4cab29647a0992b826e617662d099d2fa7b8c337" translate="yes" xml:space="preserve">
          <source>Give the output in the long-format. This is the default.</source>
          <target state="translated">출력을 긴 형식으로 제공하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="7b3a4cfa6cfda1ef4f79bab4a1d749c9c6c5f5f0" translate="yes" xml:space="preserve">
          <source>Give the output in the short-format.</source>
          <target state="translated">짧은 형식으로 출력하십시오.</target>
        </trans-unit>
        <trans-unit id="2dc950b47492cb25f78f25c843f0ed41c631283b" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;--delete&lt;/code&gt; and an additional argument, deletes the given symbolic ref.</source>
          <target state="translated">을 감안할 때 &lt;code&gt;--delete&lt;/code&gt; 및 추가 인수, 주어진 상징적 심판을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="e97e8a091675b0288dfc0175fdb5f7c838cea92d" translate="yes" xml:space="preserve">
          <source>Given N &amp;lt;references&amp;gt;, the first N lines are the one-line description from their commit message. The branch head that is pointed at by $GIT_DIR/HEAD is prefixed with an asterisk &lt;code&gt;*&lt;/code&gt; character while other heads are prefixed with a &lt;code&gt;!&lt;/code&gt; character.</source>
          <target state="translated">N &amp;lt;references&amp;gt;가 주어지면 첫 번째 N 행은 커밋 메시지의 한 줄 설명입니다. $ GIT_DIR / HEAD가 가리키는 브랜치 헤드는 별표 ( &lt;code&gt;*&lt;/code&gt; ) 로 시작하고 다른 헤드는 &lt;code&gt;!&lt;/code&gt; 로 시작합니다 . 캐릭터.</target>
        </trans-unit>
        <trans-unit id="a02a332c45eb3b9cf3b89841e8aa1ca85e593c49" translate="yes" xml:space="preserve">
          <source>Given a .git/config like this:</source>
          <target state="translated">다음과 같이 .git / config가 주어집니다.</target>
        </trans-unit>
        <trans-unit id="e65ae867c8cb398abc725e8538eba217d02dbede" translate="yes" xml:space="preserve">
          <source>Given a commit, find out where it is relative to the local refs. Say somebody wrote you about that fantastic commit 33db5f4d9027a10e477ccf054b2c1ab94f74c85a. Of course, you look into the commit, but that only tells you what happened, but not the context.</source>
          <target state="translated">커밋이 주어지면 로컬 참조와 관련된 위치를 찾으십시오. 누군가 환상적인 커밋 33db5f4d9027a10e477ccf054b2c1ab94f74c85a에 대해 당신에게 썼다고 가정 해보십시오. 물론, 당신은 커밋을 조사하지만, 그것은 당신에게 무슨 일이 있었는지를 알려주지 만 상황은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7ce01790b46379d506c51a1991e3ea26b3a8d244" translate="yes" xml:space="preserve">
          <source>Given one argument, reads which branch head the given symbolic ref refers to and outputs its path, relative to the &lt;code&gt;.git/&lt;/code&gt; directory. Typically you would give &lt;code&gt;HEAD&lt;/code&gt; as the &amp;lt;name&amp;gt; argument to see which branch your working tree is on.</source>
          <target state="translated">하나의 인수가 주어지면 주어진 기호 참조가 어떤 분기 헤드를 참조하고 &lt;code&gt;.git/&lt;/code&gt; 디렉토리에 상대적인 경로를 출력 하는지를 읽습니다 . 일반적으로 &lt;code&gt;HEAD&lt;/code&gt; 를 &amp;lt;name&amp;gt; 인수로 지정하여 작업 트리가있는 브랜치를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="ee9f44e6df9f9221a39559d12563d4ded15eb1ae" translate="yes" xml:space="preserve">
          <source>Given one or more existing commits, apply the change each one introduces, recording a new commit for each. This requires your working tree to be clean (no modifications from the HEAD commit).</source>
          <target state="translated">하나 이상의 기존 커밋이 주어지면 각 커밋에 대한 변경 사항을 적용하고 각각에 대해 새로운 커밋을 기록하십시오. 이를 위해서는 작업 트리가 깨끗해야합니다 (HEAD 커밋의 수정 사항 없음).</target>
        </trans-unit>
        <trans-unit id="49cfc78f8193ed0e67ffaf9646d690418c000a33" translate="yes" xml:space="preserve">
          <source>Given one or more existing commits, revert the changes that the related patches introduce, and record some new commits that record them. This requires your working tree to be clean (no modifications from the HEAD commit).</source>
          <target state="translated">기존 커밋이 하나 이상 있으면 관련 패치가 도입 한 변경 사항을 되돌리고이를 기록하는 새로운 커밋을 기록하십시오. 이를 위해서는 작업 트리가 깨끗해야합니다 (HEAD 커밋의 수정 사항 없음).</target>
        </trans-unit>
        <trans-unit id="b90c39be8f3013761513d522c230779e0af0700e" translate="yes" xml:space="preserve">
          <source>Given the following noisy input with &lt;code&gt;$&lt;/code&gt; indicating the end of a line:</source>
          <target state="translated">줄의 끝을 나타내는 &lt;code&gt;$&lt;/code&gt; 와 함께 다음과 같은 노이즈 입력이 주어집니다 .</target>
        </trans-unit>
        <trans-unit id="9ae9c5ba5c0cae940c9ccda71b399bacf0ceae54" translate="yes" xml:space="preserve">
          <source>Given three arguments, stores the &amp;lt;newvalue&amp;gt; in the &amp;lt;ref&amp;gt;, possibly dereferencing the symbolic refs, after verifying that the current value of the &amp;lt;ref&amp;gt; matches &amp;lt;oldvalue&amp;gt;. E.g. &lt;code&gt;git update-ref refs/heads/master &amp;lt;newvalue&amp;gt; &amp;lt;oldvalue&amp;gt;&lt;/code&gt; updates the master branch head to &amp;lt;newvalue&amp;gt; only if its current value is &amp;lt;oldvalue&amp;gt;. You can specify 40 &quot;0&quot; or an empty string as &amp;lt;oldvalue&amp;gt; to make sure that the ref you are creating does not exist.</source>
          <target state="translated">세 개의 인수가 주어지면 &amp;lt;ref&amp;gt;의 현재 값이 &amp;lt;oldvalue&amp;gt;와 일치하는지 확인한 후 &amp;lt;newvalue&amp;gt;를 &amp;lt;ref&amp;gt;에 저장하고 기호 참조를 역 참조 할 수 있습니다. 예를 들어 &lt;code&gt;git update-ref refs/heads/master &amp;lt;newvalue&amp;gt; &amp;lt;oldvalue&amp;gt;&lt;/code&gt; 는 현재 값이 &amp;lt;oldvalue&amp;gt; 인 경우에만 마스터 분기 헤드를 &amp;lt;newvalue&amp;gt;로 업데이트합니다. 작성중인 참조가 존재하지 않도록 40 &quot;0&quot;또는 빈 문자열을 &amp;lt;oldvalue&amp;gt;로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d8bb10ba2f3cfa88afc4b8727de27fb3cab8018" translate="yes" xml:space="preserve">
          <source>Given three commits &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;git merge-base A B C&lt;/code&gt; will compute the merge base between &lt;code&gt;A&lt;/code&gt; and a hypothetical commit &lt;code&gt;M&lt;/code&gt;, which is a merge between &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;. For example, with this topology:</source>
          <target state="translated">커밋 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 가 세 개인 경우 , &lt;code&gt;git merge-base A B C&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 와 가설 커밋 &lt;code&gt;M&lt;/code&gt; 사이의 병합 기준을 계산하며 , 이는 &lt;code&gt;B&lt;/code&gt; 와 &lt;code&gt;C&lt;/code&gt; 간의 병합 입니다. 예를 들어이 토폴로지의 경우</target>
        </trans-unit>
        <trans-unit id="be6c9bc842b0965134f1fb7992b74ba082dffe0f" translate="yes" xml:space="preserve">
          <source>Given two arguments, creates or updates a symbolic ref &amp;lt;name&amp;gt; to point at the given branch &amp;lt;ref&amp;gt;.</source>
          <target state="translated">두 개의 인수가 주어지면 주어진 분기 &amp;lt;ref&amp;gt;를 가리 키도록 기호 ref &amp;lt;name&amp;gt;을 작성하거나 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="7cc67b58b4d717f52eb7b590f0c2ac097c83b04a" translate="yes" xml:space="preserve">
          <source>Given two arguments, stores the &amp;lt;newvalue&amp;gt; in the &amp;lt;ref&amp;gt;, possibly dereferencing the symbolic refs. E.g. &lt;code&gt;git update-ref HEAD
&amp;lt;newvalue&amp;gt;&lt;/code&gt; updates the current branch head to the new object.</source>
          <target state="translated">두 개의 인수가 주어지면 &amp;lt;newvalue&amp;gt;를 &amp;lt;ref&amp;gt;에 저장하여 기호 참조를 역 참조 할 수 있습니다. 예를 들어 &lt;code&gt;git update-ref HEAD &amp;lt;newvalue&amp;gt;&lt;/code&gt; 는 현재 분기 헤드를 새 객체로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="931db30a85fe3ea596ac121ca8f065ad449ff885" translate="yes" xml:space="preserve">
          <source>Given two commits &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;git merge-base A B&lt;/code&gt; will output a commit which is reachable from both &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; through the parent relationship.</source>
          <target state="translated">두 커밋 주어 및 &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;git merge-base A B&lt;/code&gt; 양쪽에서 접근하는 커미트가 출력 및 &lt;code&gt;B&lt;/code&gt; 부모 관계를 통해서. &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0c09289dc074c18ca9574b29845f64d7cae5bc3" translate="yes" xml:space="preserve">
          <source>Gives some information about the remote &amp;lt;name&amp;gt;.</source>
          <target state="translated">원격 &amp;lt;name&amp;gt;에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9466e3cfe4b90da05672816c37e48d04d2b0bacb" translate="yes" xml:space="preserve">
          <source>Giving these options is an error when used with &lt;code&gt;--inetd&lt;/code&gt;; use the facility of inet daemon to achieve the same before spawning &lt;code&gt;git daemon&lt;/code&gt; if needed.</source>
          <target state="translated">&lt;code&gt;--inetd&lt;/code&gt; 와 함께 사용할 때 이러한 옵션을 제공하면 오류가 발생합니다 . 필요한 경우 &lt;code&gt;git daemon&lt;/code&gt; 생성하기 전에 inet 데몬 기능을 사용하여 동일한 기능을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0ec3ae2bdc4ccb842cc8f2251da67f38c6daf5a" translate="yes" xml:space="preserve">
          <source>Glob magic is incompatible with literal magic.</source>
          <target state="translated">글롭 매직은 리터럴 매직과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="d8608c60e7a8f9d556f6c1f2aff537e2ce064bab" translate="yes" xml:space="preserve">
          <source>Go under &quot;Options&quot; in the Composer window and be sure that &quot;Word wrap&quot; is not set.</source>
          <target state="translated">작성기 창의 &quot;옵션&quot;으로 이동하여 &quot;워드 랩&quot;이 설정되어 있지 않은지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c16a49b3ce3e17532ce6e118e23e9cba92fcb23b" translate="yes" xml:space="preserve">
          <source>Graduation</source>
          <target state="translated">Graduation</target>
        </trans-unit>
        <trans-unit id="7108295a48fb4030d059842641f3ed2f16dd90ea" translate="yes" xml:space="preserve">
          <source>Grafts enables two otherwise different lines of development to be joined together by recording fake ancestry information for commits. This way you can make Git pretend the set of &lt;a href=&quot;#def_parent&quot;&gt;parents&lt;/a&gt; a &lt;a href=&quot;#def_commit&quot;&gt;commit&lt;/a&gt; has is different from what was recorded when the commit was created. Configured via the &lt;code&gt;.git/info/grafts&lt;/code&gt; file.</source>
          <target state="translated">Grafts를 사용하면 커밋에 대한 가짜 조상 정보를 기록하여 서로 다른 두 가지 개발 라인을 결합 할 수 있습니다. 이 방법으로 Git 이 &lt;a href=&quot;#def_commit&quot;&gt;커밋&lt;/a&gt; 이 있는 &lt;a href=&quot;#def_parent&quot;&gt;부모&lt;/a&gt; 세트를 가장하게 만들 수 있습니다 . 커밋이 생성되었을 때 기록 된 것과 다릅니다. &lt;code&gt;.git/info/grafts&lt;/code&gt; 파일을 통해 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="43addd483f6785ba3f74ca813174b30e77d7804f" translate="yes" xml:space="preserve">
          <source>Graphical alternative to git-commit</source>
          <target state="translated">git-commit의 그래픽 대안</target>
        </trans-unit>
        <trans-unit id="7e3e6e185a96c1bddac8bacc3e22b2d8c14f25b3" translate="yes" xml:space="preserve">
          <source>Group commits based on &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;. If no &lt;code&gt;--group&lt;/code&gt; option is specified, the default is &lt;code&gt;author&lt;/code&gt;. &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is one of:</source>
          <target state="translated">&lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; 을 기반으로 한 그룹 커밋 . &lt;code&gt;--group&lt;/code&gt; 옵션이 지정 되지 않은 경우 기본값은 &lt;code&gt;author&lt;/code&gt; 입니다. &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; 은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="7138a51661947b19b5088da5a2bfede2876f49b9" translate="yes" xml:space="preserve">
          <source>HEAD</source>
          <target state="translated">HEAD</target>
        </trans-unit>
        <trans-unit id="f53aba93b9409d79b694657717f24476b7680a38" translate="yes" xml:space="preserve">
          <source>HEAD can also record a specific commit directly, instead of being a symref to point at the current branch. Such a state is often called &lt;code&gt;detached HEAD.&lt;/code&gt; See &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt; for details.</source>
          <target state="translated">HEAD는 또한 현재 분기를 가리키는 symref 대신 특정 커밋을 직접 기록 할 수 있습니다. 이러한 상태를 종종 &lt;code&gt;detached HEAD.&lt;/code&gt; 라고 합니다. 자세한 내용은 &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="adaf1f885f4f48f7b3c5a9a2b8f4883bf35d0a07" translate="yes" xml:space="preserve">
          <source>HEAD: refers to the head of the current branch</source>
          <target state="translated">HEAD : 현재 지점의 헤드를 나타냅니다</target>
        </trans-unit>
        <trans-unit id="408093a274a45499420aa72e738c6e970f863fed" translate="yes" xml:space="preserve">
          <source>HEADER:</source>
          <target state="translated">HEADER:</target>
        </trans-unit>
        <trans-unit id="bd0cfe599144b530c7c9685825d1a02a5377b64e" translate="yes" xml:space="preserve">
          <source>HTML snippet to be included in the &amp;lt;head&amp;gt; section of each page. Can be set using &lt;code&gt;GITWEB_SITE_HTML_HEAD_STRING&lt;/code&gt; at build time. No default value.</source>
          <target state="translated">각 페이지의 &amp;lt;head&amp;gt; 섹션에 포함될 HTML 스 니펫 빌드시 &lt;code&gt;GITWEB_SITE_HTML_HEAD_STRING&lt;/code&gt; 을 사용하여 설정할 수 있습니다 . 기본값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="cc56a2df9f8b6a66c5d2a6125ab52ed375e5152b" translate="yes" xml:space="preserve">
          <source>HTTP Transport</source>
          <target state="translated">HTTP 전송</target>
        </trans-unit>
        <trans-unit id="d578fb1b4bb161c78cd19e50fcb2b009bf47fe3e" translate="yes" xml:space="preserve">
          <source>HTTP(S)</source>
          <target state="translated">HTTP(S)</target>
        </trans-unit>
        <trans-unit id="1ba3338bd0d397031ae85dc0347d63c94b00e5df" translate="yes" xml:space="preserve">
          <source>HTTP/1.1</source>
          <target state="translated">HTTP/1.1</target>
        </trans-unit>
        <trans-unit id="396826d4135990391d3176f7b40c9091eed2c0d3" translate="yes" xml:space="preserve">
          <source>HTTP/2</source>
          <target state="translated">HTTP/2</target>
        </trans-unit>
        <trans-unit id="80bde80e45cfc7c229d507fff6d534806b07378c" translate="yes" xml:space="preserve">
          <source>Hacking git</source>
          <target state="translated">해킹 자식</target>
        </trans-unit>
        <trans-unit id="c4b8d31a4ffcd043a96008543e3e1f5d7eaf7692" translate="yes" xml:space="preserve">
          <source>Handling Renames</source>
          <target state="translated">이름 변경 처리</target>
        </trans-unit>
        <trans-unit id="3049c71fe9126eefc3301476201dcd8b12bbbd85" translate="yes" xml:space="preserve">
          <source>Handling of svn branches</source>
          <target state="translated">svn 분기 처리</target>
        </trans-unit>
        <trans-unit id="b2bb788b2d8872820805621988d07bb34824ee87" translate="yes" xml:space="preserve">
          <source>Hard case: The changes are not the same.</source>
          <target state="translated">어려운 경우 : 변경 사항이 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d86493cd0a3bd6cc52c39427d91b4f3fb5f1ba0f" translate="yes" xml:space="preserve">
          <source>Has no effect if the ref does not have tracking information associated with it. All the options apart from &lt;code&gt;nobracket&lt;/code&gt; are mutually exclusive, but if used together the last option is selected.</source>
          <target state="translated">심판이 관련 추적 정보를 가지고 있지 않은 경우에는 효과가 없습니다. &lt;code&gt;nobracket&lt;/code&gt; 을 제외한 모든 옵션은 함께 사용할 수 없지만 함께 사용하면 마지막 옵션이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="eee44516ee4e4873c5ecfb5a6805b0f8b1007d35" translate="yes" xml:space="preserve">
          <source>Hash object as it were located at the given path. The location of file does not directly influence on the hash value, but path is used to determine what Git filters should be applied to the object before it can be placed to the object database, and, as result of applying filters, the actual blob put into the object database may differ from the given file. This option is mainly useful for hashing temporary files located outside of the working directory or files read from stdin.</source>
          <target state="translated">주어진 경로에있는 개체를 해시합니다. 파일의 위치는 해시 값에 직접 영향을 미치지 않지만 경로는 객체 데이터베이스에 배치하기 전에 객체에 적용 할 Git 필터를 결정하는 데 사용되며, 필터를 적용한 결과 실제 Blob은 개체 데이터베이스에 대한 파일은 제공된 파일과 다를 수 있습니다. 이 옵션은 주로 작업 디렉토리 외부에있는 임시 파일이나 stdin에서 읽은 파일을 해싱하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="100c09777204f7d9c4d9c8cca2b2ca1117efcbe1" translate="yes" xml:space="preserve">
          <source>Hash the contents as is, ignoring any input filter that would have been chosen by the attributes mechanism, including the end-of-line conversion. If the file is read from standard input then this is always implied, unless the &lt;code&gt;--path&lt;/code&gt; option is given.</source>
          <target state="translated">행 끝 변환을 포함하여 속성 메커니즘에 의해 선택된 입력 필터를 무시하고 내용을 그대로 해시하십시오. 파일을 표준 입력에서 읽은 경우 &lt;code&gt;--path&lt;/code&gt; 옵션을 지정 하지 않으면 항상 암시 됩니다.</target>
        </trans-unit>
        <trans-unit id="f2ae7e4a6dc9825ef1a4868750168492eeaf6380" translate="yes" xml:space="preserve">
          <source>Have the server run as an inetd service. Implies --syslog (may be overridden with &lt;code&gt;--log-destination=&lt;/code&gt;). Incompatible with --detach, --port, --listen, --user and --group options.</source>
          <target state="translated">서버를 inetd 서비스로 실행하십시오. --syslog를 의미합니다 ( &lt;code&gt;--log-destination=&lt;/code&gt; 으로 재정의 될 수 있음 ). --detach, --port, --listen, --user 및 --group 옵션과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db301d2890ccaa14dc974751b62b359a359b6b5c" translate="yes" xml:space="preserve">
          <source>He also uses a set of temporary branches (&quot;topic branches&quot;), each containing a logical grouping of patches.</source>
          <target state="translated">또한 논리적 패치 그룹을 포함하는 임시 분기 ( &quot;토픽 분기&quot;) 세트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c983e9a4d9daf24f5efac3a67c8f6c12bda32744" translate="yes" xml:space="preserve">
          <source>He uses two public branches:</source>
          <target state="translated">그는 두 가지 공공 지점을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="08dac5b0781534f17eedb09bc82379faeed11d4a" translate="yes" xml:space="preserve">
          <source>Header lines start with &quot;#&quot; and are added in response to specific command line arguments. Parsers should ignore headers they don&amp;rsquo;t recognize.</source>
          <target state="translated">헤더 행은 &quot;#&quot;으로 시작하고 특정 명령 행 인수에 대한 응답으로 추가됩니다. 파서는 인식하지 못하는 헤더를 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="6f7a484a67443c5c4893cfcebc8516ecb7a4f1a2" translate="yes" xml:space="preserve">
          <source>Help parsing or adding &lt;code&gt;trailers&lt;/code&gt; lines, that look similar to RFC 822 e-mail headers, at the end of the otherwise free-form part of a commit message.</source>
          <target state="translated">커밋 메시지의 자유 형식 부분 끝에 RFC 822 전자 메일 헤더와 비슷한 &lt;code&gt;trailers&lt;/code&gt; 줄을 구문 분석하거나 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f07e99c3fb43a6bcfb5e09ad2c991cc9571165ae" translate="yes" xml:space="preserve">
          <source>Helper programs to interact with remote repositories</source>
          <target state="translated">원격 저장소와 상호 작용하는 도우미 프로그램</target>
        </trans-unit>
        <trans-unit id="d7f00958253572e7e593fd3637f7f812370db1d4" translate="yes" xml:space="preserve">
          <source>Helper to store credentials on disk</source>
          <target state="translated">디스크에 자격 증명을 저장하는 도우미</target>
        </trans-unit>
        <trans-unit id="91ab6264d347386bb003d96ff4f148c65df714a3" translate="yes" xml:space="preserve">
          <source>Helper to temporarily store passwords in memory</source>
          <target state="translated">메모리에 비밀번호를 임시로 저장하는 도우미</target>
        </trans-unit>
        <trans-unit id="f8801cb816506b471cd751bc46c3d753c8b27a46" translate="yes" xml:space="preserve">
          <source>Hence</source>
          <target state="translated">Hence</target>
        </trans-unit>
        <trans-unit id="8286249a7e764f5f9777c2fc17e5230ccc1ef5fe" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is any of the commit specification expressions also accepted by &lt;code&gt;from&lt;/code&gt; (see above).</source>
          <target state="translated">여기에서 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 는 &lt;code&gt;from&lt;/code&gt; 에 의해 승인 된 커밋 사양 표현식 중 하나 입니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="3fb766f6c8298c39110428f8565787238a736366" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is any of the following:</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="85bca9b0f87b55d545a8c945215b23dd3bdbffcb" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; can be either a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) set by a prior &lt;code&gt;blob&lt;/code&gt; command, or a full 40-byte SHA-1 of an existing Git blob object.</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 는 이전 &lt;code&gt;blob&lt;/code&gt; 명령으로 설정된 마크 참조 ( &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ) 이거나 기존 Git Blob 객체의 전체 40 바이트 SHA-1 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f53683a6742f0030e51cf7120f8e28dba9865c5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is the person&amp;rsquo;s display name (for example &amp;ldquo;Com M Itter&amp;rdquo;) and &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; is the person&amp;rsquo;s email address (&amp;ldquo;cm@example.com&amp;rdquo;). &lt;code&gt;LT&lt;/code&gt; and &lt;code&gt;GT&lt;/code&gt; are the literal less-than (\x3c) and greater-than (\x3e) symbols. These are required to delimit the email address from the other fields in the line. Note that &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; are free-form and may contain any sequence of bytes, except &lt;code&gt;LT&lt;/code&gt;, &lt;code&gt;GT&lt;/code&gt; and &lt;code&gt;LF&lt;/code&gt;. &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; is typically UTF-8 encoded.</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 은 사람의 표시 이름 (예 :&amp;ldquo;Com M Itter&amp;rdquo;)이고 &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; 은 사람의 전자 메일 주소 (&amp;ldquo;cm@example.com&amp;rdquo;)입니다. &lt;code&gt;LT&lt;/code&gt; 및 &lt;code&gt;GT&lt;/code&gt; 는 리터럴보다 작음 (\ x3c) 및보다 큼 (\ x3e) 기호입니다. 이들은 라인의 다른 필드에서 이메일 주소를 구분하는 데 필요합니다. 참고 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 과 &lt;code&gt;&amp;lt;email&amp;gt;&lt;/code&gt; 자유 형식이며, 제외 바이트의 시퀀스를 포함 할 수있다 &lt;code&gt;LT&lt;/code&gt; , &lt;code&gt;GT&lt;/code&gt; 및 &lt;code&gt;LF&lt;/code&gt; 를 . &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 은 일반적으로 UTF-8로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="88e3e34bac3d333854c449d8638faee3f973bc68" translate="yes" xml:space="preserve">
          <source>Here actual project root is passed to gitweb via &lt;code&gt;GITWEB_PROJECT_ROOT&lt;/code&gt; environment variable from a web server, so you need to put the following line in gitweb configuration file (&lt;code&gt;/etc/gitweb.conf&lt;/code&gt; in above example):</source>
          <target state="translated">여기서 실제 프로젝트 루트는 웹 서버에서 &lt;code&gt;GITWEB_PROJECT_ROOT&lt;/code&gt; 환경 변수를 통해 gitweb에 전달 되므로 gitweb 구성 파일 ( 위의 예에서 &lt;code&gt;/etc/gitweb.conf&lt;/code&gt; ) 에 다음 줄을 넣어야합니다 .</target>
        </trans-unit>
        <trans-unit id="87d852c017173b91ce004ba4ee55c454ec44074f" translate="yes" xml:space="preserve">
          <source>Here again it is a good point to take a pause.</source>
          <target state="translated">여기서 다시 한 번 일시 중지하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9d560d4da9e941f0111865584d812ed4b996ba31" translate="yes" xml:space="preserve">
          <source>Here are a handful of examples using the Loeliger illustration above, with each step in the notation&amp;rsquo;s expansion and selection carefully spelt out:</source>
          <target state="translated">다음은 위의 Loeliger 그림을 사용한 몇 가지 예입니다. 표기법의 확장 및 선택의 각 단계는 신중하게 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="917cc5ec6b02db542b24a5b6455b2e756b18d73b" translate="yes" xml:space="preserve">
          <source>Here are some example specifications:</source>
          <target state="translated">다음은 몇 가지 예시 사양입니다.</target>
        </trans-unit>
        <trans-unit id="3a6c1665b5306569c28a748694fd4e1b1e7a55db" translate="yes" xml:space="preserve">
          <source>Here are some hints on how to successfully submit patches inline using various mailers.</source>
          <target state="translated">다음은 다양한 메일러를 사용하여 인라인으로 패치를 제출하는 방법에 대한 힌트입니다.</target>
        </trans-unit>
        <trans-unit id="1510576755c083f75778b41e3e15db4ef8738ed9" translate="yes" xml:space="preserve">
          <source>Here are some of the scripts that simplify all this even further.</source>
          <target state="translated">다음은이 모든 것을 더욱 단순화하는 스크립트 중 일부입니다.</target>
        </trans-unit>
        <trans-unit id="e7b17934614eee2f77ca3149426accc7b6e72d44" translate="yes" xml:space="preserve">
          <source>Here are the rules regarding the &quot;flags&quot; that you should follow when you are scripting Git:</source>
          <target state="translated">Git을 스크립팅 할 때 따라야 할 &quot;플래그&quot;에 관한 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="04cdec1fa8a31abdd551dc359504457bc39d207b" translate="yes" xml:space="preserve">
          <source>Here is a hypothetical usage of the Trace2 API showing the intended usage (without worrying about the actual Git details).</source>
          <target state="translated">다음은 실제 Git 세부 사항에 대한 걱정없이 의도 된 사용법을 보여주는 Trace2 API의 가상 사용법입니다.</target>
        </trans-unit>
        <trans-unit id="ffd38e59dd005a380c8a8570731f44b027a45fba" translate="yes" xml:space="preserve">
          <source>Here is a list of the facilities provided by this option parser.</source>
          <target state="translated">다음은이 옵션 파서가 제공하는 기능 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e4035106d997a5f9ffd025f7ed0bd5862edf3733" translate="yes" xml:space="preserve">
          <source>Here is a picture that illustrates how various pieces fit together:</source>
          <target state="translated">다음은 다양한 조각들이 어떻게 어울리는지를 보여주는 그림입니다.</target>
        </trans-unit>
        <trans-unit id="303a3029ebdf1756e031ccbacc8dc586c90ed37d" translate="yes" xml:space="preserve">
          <source>Here is an ASCII art by Jon Loeliger that illustrates how various &lt;code&gt;diff-*&lt;/code&gt; commands compare things.</source>
          <target state="translated">Jon Loeliger의 ASCII 아트는 다양한 &lt;code&gt;diff-*&lt;/code&gt; 명령이 사물을 비교 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="a1af358ae94ab7cd9ed6d1b4e51b99fcacedf212" translate="yes" xml:space="preserve">
          <source>Here is an example of a work-flow used by Andreas Ericsson:</source>
          <target state="translated">Andreas Ericsson이 사용한 워크 플로우의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="186fb29b724fc88890a2b738e2f88d967cca2e57" translate="yes" xml:space="preserve">
          <source>Here is an example script that comes slightly modified from a real world script used by Junio Hamano &lt;a href=&quot;#4&quot;&gt;[4]&lt;/a&gt;.</source>
          <target state="translated">다음은 Junio ​​Hamano가 사용하는 실제 스크립트에서 약간 수정 된 예제 스크립트입니다 &lt;a href=&quot;#4&quot;&gt;[4]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea2d28e72cba49a8087ea617856210e85cc4631a" translate="yes" xml:space="preserve">
          <source>Here is an illustration, by Jon Loeliger. Both commit nodes B and C are parents of commit node A. Parent commits are ordered left-to-right.</source>
          <target state="translated">다음은 Jon Loeliger의 그림입니다. 커밋 노드 B와 C는 모두 커밋 노드 A의 부모입니다. 부모 커밋은 왼쪽에서 오른쪽으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="01a0e7181fc0932a87393a13bfb324333ce2de29" translate="yes" xml:space="preserve">
          <source>Here is how you would transplant a topic branch based on one branch to another, to pretend that you forked the topic branch from the latter branch, using &lt;code&gt;rebase --onto&lt;/code&gt;.</source>
          <target state="translated">다음은 &lt;code&gt;rebase --onto&lt;/code&gt; 를 사용하여 한 분기에서 다른 분기로 주제 분기를 이식하여 후자의 분기에서 주제 분기를 분기 한 것처럼 가장하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="213d54b0bbf3a7f7afa040a26967e9f565627a3c" translate="yes" xml:space="preserve">
          <source>Here is what Ingo Molnar says about that &lt;a href=&quot;#7&quot;&gt;[7]&lt;/a&gt;:</source>
          <target state="translated">다음은 Ingo Molnar가 말하는 것입니다. &lt;a href=&quot;#7&quot;&gt;[7]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0ace4715fac22315364196a248067a261a46ae73" translate="yes" xml:space="preserve">
          <source>Here usually &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; must be either a mark reference (&lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt;) set by a prior &lt;code&gt;blob&lt;/code&gt; command, or a full 40-byte SHA-1 of an existing Git blob object. If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;040000`&lt;/code&gt; then &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; must be the full 40-byte SHA-1 of an existing Git tree object or a mark reference set with &lt;code&gt;--import-marks&lt;/code&gt;.</source>
          <target state="translated">여기서 일반적으로 &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 는 이전 &lt;code&gt;blob&lt;/code&gt; 명령으로 설정된 마크 참조 ( &lt;code&gt;:&amp;lt;idnum&amp;gt;&lt;/code&gt; ) 이거나 기존 Git Blob 객체의 전체 40 바이트 SHA-1 이어야 합니다. 경우 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 이다 &lt;code&gt;040000`&lt;/code&gt; 다음 &lt;code&gt;&amp;lt;dataref&amp;gt;&lt;/code&gt; 전체 40 바이트의 SHA-1 기존 힘내 트리 오브젝트 또는 마크와 기준 세트이어야 &lt;code&gt;--import-marks&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2beb401ec57f79ec07666eedc396bc9251ab532b" translate="yes" xml:space="preserve">
          <source>Here we use a &lt;code&gt;test.sh&lt;/code&gt; custom script. In this script, if &lt;code&gt;make&lt;/code&gt; fails, we skip the current commit. &lt;code&gt;check_test_case.sh&lt;/code&gt; should &lt;code&gt;exit 0&lt;/code&gt; if the test case passes, and &lt;code&gt;exit 1&lt;/code&gt; otherwise.</source>
          <target state="translated">여기서는 &lt;code&gt;test.sh&lt;/code&gt; 사용자 정의 스크립트를 사용합니다 . 이 스크립트에서 &lt;code&gt;make&lt;/code&gt; 가 실패하면 현재 커밋을 건너 뜁니다. 테스트 케이스가 통과하면 &lt;code&gt;check_test_case.sh&lt;/code&gt; 는 &lt;code&gt;exit 0&lt;/code&gt; 을 종료 하고 그렇지 않으면 &lt;code&gt;exit 1&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4c65aa59e4c90d1dad65ae558dc71a05ca72658c" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example to make it more clear:</source>
          <target state="translated">보다 명확하게하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f876057ef41997694291fae2bce19c94e2c8be27" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s where things get tricky and more specific. The pruning feature doesn&amp;rsquo;t actually care about branches, instead it&amp;rsquo;ll prune local &amp;lt;&amp;rarr; remote-references as a function of the refspec of the remote (see &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; and &lt;a href=&quot;#CRTB&quot;&gt;CONFIGURED REMOTE-TRACKING BRANCHES&lt;/a&gt; above).</source>
          <target state="translated">까다 롭고 구체적이되는 곳이 여기에 있습니다. 가지 치기 기능은 실제로 분기에 신경 쓰지 않고 대신 원격 참조의 함수로 로컬 &amp;lt;&amp;rarr; 원격 참조를 제거합니다 (위의 &lt;code&gt;&amp;lt;refspec&amp;gt;&lt;/code&gt; 및 &lt;a href=&quot;#CRTB&quot;&gt;CONFIGURED REMOTE-TRACKING BRANCHES&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="6e909debf7e14a75a50a127741701f06b0380ed1" translate="yes" xml:space="preserve">
          <source>Here, order matters, so the negative patterns are overridden by the positive patterns that appear lower in the file.</source>
          <target state="translated">여기서 순서가 중요하므로 파일에서 아래에 나타나는 양의 패턴으로 음의 패턴이 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e1c70b8a098f60c6e63dbb08701031f93ea135ff" translate="yes" xml:space="preserve">
          <source>Here, take a moment to look at the contents of &lt;code&gt;hello&lt;/code&gt;, and notice how they don&amp;rsquo;t contain the work we just did in &lt;code&gt;mybranch&lt;/code&gt; &amp;mdash; because that work hasn&amp;rsquo;t happened in the &lt;code&gt;master&lt;/code&gt; branch at all. Then do</source>
          <target state="translated">여기서 &lt;code&gt;hello&lt;/code&gt; 의 내용을 살펴보고 , &lt;code&gt;mybranch&lt;/code&gt; 에서 방금 수행 한 작업이 포함되어 있지 않은지 확인하십시오. 이 작업은 &lt;code&gt;master&lt;/code&gt; 브랜치에서 전혀 수행되지 않았기 때문입니다 . 그런 다음</target>
        </trans-unit>
        <trans-unit id="04fe7010553ef714229d324da3944b7bef8ef4bf" translate="yes" xml:space="preserve">
          <source>Here, the merge commits &lt;code&gt;O&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; contribute extra noise, as they did not actually contribute a change to &lt;code&gt;file.txt&lt;/code&gt;. They only merged a topic that was based on an older version of &lt;code&gt;file.txt&lt;/code&gt;. This is a common issue in repositories using a workflow where many contributors work in parallel and merge their topic branches along a single trunk: manu unrelated merges appear in the &lt;code&gt;--full-history&lt;/code&gt; results.</source>
          <target state="translated">여기서 병합 커밋 &lt;code&gt;O&lt;/code&gt; 와 &lt;code&gt;P&lt;/code&gt; 는 실제로 &lt;code&gt;file.txt&lt;/code&gt; 변경에 기여하지 않았기 때문에 추가 노이즈를 발생시킵니다 . 이전 버전의 &lt;code&gt;file.txt&lt;/code&gt; 를 기반으로 한 주제 만 병합했습니다 . 이것은 많은 기여자가 병렬로 작업하고 단일 트렁크를 따라 토픽 분기를 병합하는 워크 플로를 사용하는 리포지토리의 일반적인 문제입니다. manu 관련없는 병합은 &lt;code&gt;--full-history&lt;/code&gt; 결과에 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="6b3155f9e3fff9d9745dcec6fcafe4ea22b8525d" translate="yes" xml:space="preserve">
          <source>Here, the merge commits &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; are included because they pulled the commits &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; into the base branch, respectively. These merges are the reason the commits &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; do not appear in the default history.</source>
          <target state="translated">여기서 병합 커밋 &lt;code&gt;R&lt;/code&gt; 과 &lt;code&gt;N&lt;/code&gt; 은 각각 커밋 &lt;code&gt;X&lt;/code&gt; 와 &lt;code&gt;R&lt;/code&gt; 을 기본 브랜치로 가져 왔기 때문에 포함 됩니다. 이러한 병합은 커밋 &lt;code&gt;A&lt;/code&gt; 와 &lt;code&gt;B&lt;/code&gt; 가 기본 기록에 나타나지 않는 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="d77fbd432531fa44ab380c6d115f43ea2fbe9fc8" translate="yes" xml:space="preserve">
          <source>Here, we just added another line to &lt;code&gt;hello&lt;/code&gt;, and we used a shorthand for doing both &lt;code&gt;git update-index hello&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt; by just giving the filename directly to &lt;code&gt;git commit&lt;/code&gt;, with an &lt;code&gt;-i&lt;/code&gt; flag (it tells Git to &lt;code&gt;include&lt;/code&gt; that file in addition to what you have done to the index file so far when making the commit). The &lt;code&gt;-m&lt;/code&gt; flag is to give the commit log message from the command line.</source>
          <target state="translated">여기, 우리가 또 다른 라인에 추가 &lt;code&gt;hello&lt;/code&gt; , 우리는 모두 일에 대한 속기를 사용 &lt;code&gt;git update-index hello&lt;/code&gt; 하고 &lt;code&gt;git commit&lt;/code&gt; 단지 바로에 파일 이름을 제공하여 &lt;code&gt;git commit&lt;/code&gt; 로, &lt;code&gt;-i&lt;/code&gt; 플래그 (그것을 위해 힘내 알려줍니다 &lt;code&gt;include&lt;/code&gt; 에서 해당 파일을 커밋을 할 때 지금까지 인덱스 파일에 수행 한 작업에 추가). &lt;code&gt;-m&lt;/code&gt; 플래그는 명령 줄에서 로그 메시지를 커밋 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c1304382231014b423d405b863d67d13d9195107" translate="yes" xml:space="preserve">
          <source>Here, we see that the commits A and C (marked with &lt;code&gt;-&lt;/code&gt;) can be dropped from your &lt;code&gt;topic&lt;/code&gt; branch when you rebase it on top of &lt;code&gt;origin/master&lt;/code&gt;, while the commit B (marked with &lt;code&gt;+&lt;/code&gt;) still needs to be kept so that it will be sent to be applied to &lt;code&gt;origin/master&lt;/code&gt;.</source>
          <target state="translated">여기서 커밋 A와 C ( &lt;code&gt;-&lt;/code&gt; 로 표시 ) 를 &lt;code&gt;origin/master&lt;/code&gt; 위에서 리베이스 할 때 &lt;code&gt;topic&lt;/code&gt; 브랜치 에서 삭제할 수 있지만 커밋 B ( &lt;code&gt;+&lt;/code&gt; 로 표시 )는 계속 유지해야합니다. &lt;code&gt;origin/master&lt;/code&gt; 에 적용되도록 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="0cd618d5ab553d5bba621718fb5b54666be9377a" translate="yes" xml:space="preserve">
          <source>High-level commands (porcelain)</source>
          <target state="translated">고급 명령 (도자기)</target>
        </trans-unit>
        <trans-unit id="1ac4e7d9472a79a55ebc3b6988fb3cc4f954a3f4" translate="yes" xml:space="preserve">
          <source>High-level operations such as &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; and &lt;a href=&quot;git-restore&quot;&gt;git-restore[1]&lt;/a&gt; work by moving data between the working tree, the index, and the object database. Git provides low-level operations which perform each of these steps individually.</source>
          <target state="translated">&lt;a href=&quot;git-commit&quot;&gt;git-commit [1]&lt;/a&gt; 및 &lt;a href=&quot;git-restore&quot;&gt;git-restore &lt;/a&gt;[1] 과 같은 고급 작업 은 작업 트리, 인덱스 및 개체 데이터베이스간에 데이터를 이동하여 작동합니다. Git은 이러한 각 단계를 개별적으로 수행하는 저수준 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c1ce0c926615015cc35af4d00f9f659a79fd9f67" translate="yes" xml:space="preserve">
          <source>Higher level SCMs may provide and manage additional information in the &lt;code&gt;$GIT_DIR&lt;/code&gt;.</source>
          <target state="translated">상위 레벨 SCM은 &lt;code&gt;$GIT_DIR&lt;/code&gt; 에 추가 정보를 제공하고 관리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd055ea7ea783c3a5765e06b74c033615ebf91a1" translate="yes" xml:space="preserve">
          <source>Highest and slowest compression level. You can specify any number from 1 to 9 to adjust compression speed and ratio.</source>
          <target state="translated">최고 및 최저 압축 수준. 압축 속도와 비율을 조정하기 위해 1에서 9 사이의 숫자를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dca5de829f06af308665d596314f33baa6a08d8b" translate="yes" xml:space="preserve">
          <source>Highlight changed words using only colors. Implies &lt;code&gt;--color&lt;/code&gt;.</source>
          <target state="translated">색상 만 사용하여 변경된 단어를 강조 표시하십시오. &lt;code&gt;--color&lt;/code&gt; 를 의미 합니다 .</target>
        </trans-unit>
        <trans-unit id="d265b329d8480dd12ed84fd1552194f9ed45b640" translate="yes" xml:space="preserve">
          <source>Highlight whitespace errors in the &lt;code&gt;context&lt;/code&gt;, &lt;code&gt;old&lt;/code&gt; or &lt;code&gt;new&lt;/code&gt; lines of the diff. Multiple values are separated by comma, &lt;code&gt;none&lt;/code&gt; resets previous values, &lt;code&gt;default&lt;/code&gt; reset the list to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; is a shorthand for &lt;code&gt;old,new,context&lt;/code&gt;. The whitespace errors are colored with &lt;code&gt;color.diff.whitespace&lt;/code&gt;. The command line option &lt;code&gt;--ws-error-highlight=&amp;lt;kind&amp;gt;&lt;/code&gt; overrides this setting.</source>
          <target state="translated">diff 의 &lt;code&gt;context&lt;/code&gt; , &lt;code&gt;old&lt;/code&gt; 또는 &lt;code&gt;new&lt;/code&gt; 줄 에서 공백 오류를 강조 표시 하십시오. 여러 값은 쉼표로 구분되고 &lt;code&gt;none&lt;/code&gt; 이전 값을 재설정하고 &lt;code&gt;default&lt;/code&gt; 목록을 &lt;code&gt;new&lt;/code&gt; 로 재설정 하며 &lt;code&gt;all&lt;/code&gt; &lt;code&gt;old,new,context&lt;/code&gt; 의 약어입니다 . 공백 오류는 &lt;code&gt;color.diff.whitespace&lt;/code&gt; 로 표시 됩니다. 명령 줄 옵션 &lt;code&gt;--ws-error-highlight=&amp;lt;kind&amp;gt;&lt;/code&gt; 가이 설정을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="ad64982f5f47504010208292cc60b059ddb2341b" translate="yes" xml:space="preserve">
          <source>Highlight whitespace errors in the &lt;code&gt;context&lt;/code&gt;, &lt;code&gt;old&lt;/code&gt; or &lt;code&gt;new&lt;/code&gt; lines of the diff. Multiple values are separated by comma, &lt;code&gt;none&lt;/code&gt; resets previous values, &lt;code&gt;default&lt;/code&gt; reset the list to &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;all&lt;/code&gt; is a shorthand for &lt;code&gt;old,new,context&lt;/code&gt;. When this option is not given, and the configuration variable &lt;code&gt;diff.wsErrorHighlight&lt;/code&gt; is not set, only whitespace errors in &lt;code&gt;new&lt;/code&gt; lines are highlighted. The whitespace errors are colored with &lt;code&gt;color.diff.whitespace&lt;/code&gt;.</source>
          <target state="translated">diff 의 &lt;code&gt;context&lt;/code&gt; , &lt;code&gt;old&lt;/code&gt; 또는 &lt;code&gt;new&lt;/code&gt; 줄 에서 공백 오류를 강조 표시 하십시오. 여러 값은 쉼표로 구분되고 &lt;code&gt;none&lt;/code&gt; 이전 값을 재설정하고 &lt;code&gt;default&lt;/code&gt; 목록을 &lt;code&gt;new&lt;/code&gt; 로 재설정 하며 &lt;code&gt;all&lt;/code&gt; &lt;code&gt;old,new,context&lt;/code&gt; 의 약어입니다 . 이 옵션이 제공되지 않고 구성 변수 &lt;code&gt;diff.wsErrorHighlight&lt;/code&gt; 가 설정되지 않은 경우 &lt;code&gt;new&lt;/code&gt; 행의 공백 오류 만 강조 표시됩니다. 공백 오류는 &lt;code&gt;color.diff.whitespace&lt;/code&gt; 로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="dd523af5eca7a4658a007786700bef0bcb653aea" translate="yes" xml:space="preserve">
          <source>Historical options for selecting a type specifier. Prefer instead &lt;code&gt;--type&lt;/code&gt; (see above).</source>
          <target state="translated">유형 지정자를 선택하기위한 히스토리 옵션. 대신 &lt;code&gt;--type&lt;/code&gt; 을 선호 하십시오 (위 참조).</target>
        </trans-unit>
        <trans-unit id="d2946930a6bea40f3723a867347d5f13a7e8b511" translate="yes" xml:space="preserve">
          <source>Historically we did not allow binary patch applied without an explicit permission from the user, and this flag was the way to do so. Currently we always allow binary patch application, so this is a no-op.</source>
          <target state="translated">역사적으로 우리는 사용자의 명시적인 허가없이 바이너리 패치를 적용하는 것을 허용하지 않았으며,이 플래그는 그렇게하는 방법이었습니다. 현재 우리는 항상 이진 패치 응용 프로그램을 허용하므로 이것은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="7f2999a0b05d570915b660b4e452265d6ec70628" translate="yes" xml:space="preserve">
          <source>History Simplification</source>
          <target state="translated">역사 단순화</target>
        </trans-unit>
        <trans-unit id="bcdd29839bed9103f5dae5291b4dd975d75a9cc7" translate="yes" xml:space="preserve">
          <source>History traversing commands such as &lt;code&gt;git log&lt;/code&gt; operate on a set of commits, not just a single commit.</source>
          <target state="translated">&lt;code&gt;git log&lt;/code&gt; 와 같은 히스토리 트래버스 명령 은 단일 커밋이 아닌 일련의 커밋에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="173bd843bbaf623a85e5a648a6a9c500533027fc" translate="yes" xml:space="preserve">
          <source>Honor textconv filter settings.</source>
          <target state="translated">텍스트 변환 필터 설정을 존중하십시오.</target>
        </trans-unit>
        <trans-unit id="be308a87ab32a83ddd6a199c65b0dc7cb4884727" translate="yes" xml:space="preserve">
          <source>Hook for submit</source>
          <target state="translated">제출 후크</target>
        </trans-unit>
        <trans-unit id="4bd8f3f03a576b2088bd73a2339d07fca1de805d" translate="yes" xml:space="preserve">
          <source>Hooks</source>
          <target state="translated">Hooks</target>
        </trans-unit>
        <trans-unit id="99dc1a330d0acc7fd52ca441a6ce9f9284dba47c" translate="yes" xml:space="preserve">
          <source>Hooks are customization scripts used by various Git commands. A handful of sample hooks are installed when &lt;code&gt;git init&lt;/code&gt; is run, but all of them are disabled by default. To enable, the &lt;code&gt;.sample&lt;/code&gt; suffix has to be removed from the filename by renaming. Read &lt;a href=&quot;githooks&quot;&gt;githooks[5]&lt;/a&gt; for more details about each hook. This directory is ignored if $GIT_COMMON_DIR is set and &quot;$GIT_COMMON_DIR/hooks&quot; will be used instead.</source>
          <target state="translated">후크는 다양한 Git 명령에서 사용되는 사용자 정의 스크립트입니다. &lt;code&gt;git init&lt;/code&gt; 이 실행될 때 소수의 샘플 후크가 설치 되지만 기본적으로 모든 후크 가 비활성화되어 있습니다. 활성화하려면 파일 이름에서 &lt;code&gt;.sample&lt;/code&gt; 접미사를 이름을 바꿔 제거해야합니다. 각 후크에 대한 자세한 내용은 &lt;a href=&quot;githooks&quot;&gt;githooks [5]&lt;/a&gt; 를 읽으십시오 . $ GIT_COMMON_DIR이 설정되고 대신 &quot;$ GIT_COMMON_DIR / hooks&quot;가 사용되는 경우이 디렉토리는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="06a3036cbe5b8e0ded4c91cf35d4acf2e8ad8f53" translate="yes" xml:space="preserve">
          <source>Hooks are programs you can place in a hooks directory to trigger actions at certain points in git&amp;rsquo;s execution. Hooks that don&amp;rsquo;t have the executable bit set are ignored.</source>
          <target state="translated">후크는 후크 디렉토리에 배치하여 git 실행의 특정 지점에서 작업을 트리거 할 수있는 프로그램입니다. 실행 가능 비트가 설정되지 않은 후크는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="bf9a913e0a40d8bcbb788ae480caabb75549e706" translate="yes" xml:space="preserve">
          <source>Hooks can get their arguments via the environment, command-line arguments, and stdin. See the documentation for each hook below for details.</source>
          <target state="translated">후크는 환경, 명령 행 인수 및 stdin을 통해 인수를 가져올 수 있습니다. 자세한 내용은 아래 각 후크에 대한 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ada52d2258e33812dc48261a96d9e1bee90a02e9" translate="yes" xml:space="preserve">
          <source>Hooks for submit</source>
          <target state="translated">제출할 후크</target>
        </trans-unit>
        <trans-unit id="0b25ef249acb89a2076c9e4eabf85c1464e0ce20" translate="yes" xml:space="preserve">
          <source>Hooks used by Git</source>
          <target state="translated">Git에서 사용하는 후크</target>
        </trans-unit>
        <trans-unit id="16c7452920ac3fe30578ebea0bb92b7bf8bbfaa1" translate="yes" xml:space="preserve">
          <source>Host specified as an option to all p4 commands, with &lt;code&gt;-h &amp;lt;host&amp;gt;&lt;/code&gt;. The environment variable &lt;code&gt;P4HOST&lt;/code&gt; can be used instead.</source>
          <target state="translated">&lt;code&gt;-h &amp;lt;host&amp;gt;&lt;/code&gt; 와 함께 모든 p4 명령에 대한 옵션으로 호스트가 지정되었습니다 . 환경 변수 &lt;code&gt;P4HOST&lt;/code&gt; 를 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3a4f74d3860a1e7164c5016083b909a49e9f48e" translate="yes" xml:space="preserve">
          <source>Host/domain name (e.g., &lt;code&gt;example.com&lt;/code&gt; in &lt;code&gt;https://example.com/&lt;/code&gt;). This field must match between the config key and the URL. It is possible to specify a &lt;code&gt;*&lt;/code&gt; as part of the host name to match all subdomains at this level. &lt;code&gt;https://*.example.com/&lt;/code&gt; for example would match &lt;code&gt;https://foo.example.com/&lt;/code&gt;, but not &lt;code&gt;https://foo.bar.example.com/&lt;/code&gt;.</source>
          <target state="translated">호스트 / 도메인 이름 (예를 들어, &lt;code&gt;example.com&lt;/code&gt; 에서 &lt;code&gt;https://example.com/&lt;/code&gt; ). 이 필드는 구성 키와 URL 사이에 일치해야합니다. 이 레벨에서 모든 하위 도메인과 일치하도록 호스트 이름의 일부로 &lt;code&gt;*&lt;/code&gt; 를 지정할 수 있습니다. &lt;code&gt;https://*.example.com/&lt;/code&gt; 예를 들어이 일치합니다 &lt;code&gt;https://foo.example.com/&lt;/code&gt; 을 하지만,하지 &lt;code&gt;https://foo.bar.example.com/&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62bb4be23aa04882a53a58830164455da0d43aac" translate="yes" xml:space="preserve">
          <source>How Git stores objects efficiently: pack files</source>
          <target state="translated">Git이 객체를 효율적으로 저장하는 방법 : 파일 팩</target>
        </trans-unit>
        <trans-unit id="fc3082d534384228eeed70dd2356631d4f563e7e" translate="yes" xml:space="preserve">
          <source>How conflicts are presented</source>
          <target state="translated">갈등이 어떻게 나타나는가</target>
        </trans-unit>
        <trans-unit id="632a7344e68629673f46b61122a8d717f4af38d1" translate="yes" xml:space="preserve">
          <source>How does the merge work?</source>
          <target state="translated">병합은 어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="ee0a93def9e459d81d86f0f444af48fed200edd7" translate="yes" xml:space="preserve">
          <source>How many HTTP requests to launch in parallel. Can be overridden by the &lt;code&gt;GIT_HTTP_MAX_REQUESTS&lt;/code&gt; environment variable. Default is 5.</source>
          <target state="translated">병렬로 시작할 HTTP 요청 수 &lt;code&gt;GIT_HTTP_MAX_REQUESTS&lt;/code&gt; 환경 변수 로 대체 할 수 있습니다 . 기본값은 5입니다.</target>
        </trans-unit>
        <trans-unit id="88ba6c6b51f5b68d7988ac607f3c426807b883bb" translate="yes" xml:space="preserve">
          <source>How to best handle custom GIT_TRACE_&amp;lt;key&amp;gt; messages?</source>
          <target state="translated">맞춤 GIT_TRACE_ &amp;lt;key&amp;gt; 메시지를 가장 잘 처리하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e6e1af910bb5a856e3b4ead0799265f2a1064f75" translate="yes" xml:space="preserve">
          <source>How to check out a different version of a project</source>
          <target state="translated">다른 버전의 프로젝트를 확인하는 방법</target>
        </trans-unit>
        <trans-unit id="d2b9978a0ab6bcc1a292a13931b1286539811f55" translate="yes" xml:space="preserve">
          <source>How to get a Git repository</source>
          <target state="translated">Git 리포지토리를 얻는 방법</target>
        </trans-unit>
        <trans-unit id="d7d2ba06f3721900039efaca56489e6a84b511d3" translate="yes" xml:space="preserve">
          <source>How to get a Git repository with minimal history</source>
          <target state="translated">최소 히스토리로 Git 저장소를 얻는 방법</target>
        </trans-unit>
        <trans-unit id="d757cda7bc3ea5053c7cf45f6afca8dbb51305c3" translate="yes" xml:space="preserve">
          <source>How to handle commits that are not empty to start and are not clean cherry-picks of any upstream commit, but which become empty after rebasing (because they contain a subset of already upstream changes). With drop (the default), commits that become empty are dropped. With keep, such commits are kept. With ask (implied by --interactive), the rebase will halt when an empty commit is applied allowing you to choose whether to drop it, edit files more, or just commit the empty changes. Other options, like --exec, will use the default of drop unless -i/--interactive is explicitly specified.</source>
          <target state="translated">시작하기 위해 비어 있지 않고 업스트림 커밋의 깔끔한 체리 선택이 아니지만 리베이스 후 비어있는 커밋을 처리하는 방법 (이미 업스트림 변경 사항의 하위 집합을 포함하기 때문에). drop (기본값)을 사용하면 비어있는 커밋이 삭제됩니다. keep을 사용하면 이러한 커밋이 유지됩니다. ask (-interactive로 표시됨)를 사용하면 빈 커밋이 적용될 때 리베이스가 중지되어이를 드롭할지, 파일을 더 편집할지 또는 빈 변경 사항을 커밋할지 선택할 수 있습니다. --exec와 같은 다른 옵션은 -i /-interactive를 명시 적으로 지정하지 않는 한 기본값 drop을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6a7eba29926bb4a386242f44bbf4f12c6f691a0c" translate="yes" xml:space="preserve">
          <source>How to make a commit</source>
          <target state="translated">커밋하는 법</target>
        </trans-unit>
        <trans-unit id="a8f8fd0d0e36d30f7fbe331a10b1e8f318a5f903" translate="yes" xml:space="preserve">
          <source>How to merge</source>
          <target state="translated">병합하는 방법</target>
        </trans-unit>
        <trans-unit id="813e8d48c24190b471043b3ab0d44e357c5f2791" translate="yes" xml:space="preserve">
          <source>How to resolve conflicts</source>
          <target state="translated">갈등을 해결하는 방법</target>
        </trans-unit>
        <trans-unit id="93e750cda509aa41796eb9d7a6cb3afbf2365356" translate="yes" xml:space="preserve">
          <source>How to use bisect to find a regression</source>
          <target state="translated">bisect를 사용하여 회귀를 찾는 방법</target>
        </trans-unit>
        <trans-unit id="c54b4ab81b97a7d870be1fb485f52b39766adb14" translate="yes" xml:space="preserve">
          <source>However &amp;mdash; it&amp;rsquo;s such a common thing to &lt;code&gt;fetch&lt;/code&gt; and then immediately &lt;code&gt;merge&lt;/code&gt;, that it&amp;rsquo;s called &lt;code&gt;git pull&lt;/code&gt;, and you can simply do</source>
          <target state="translated">그러나 &amp;mdash; &lt;code&gt;git pull&lt;/code&gt; 이라는 것을 &lt;code&gt;fetch&lt;/code&gt; 즉시 &lt;code&gt;merge&lt;/code&gt; 하는 것은 흔한 일 이며 간단히 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d70de578cd37f18e0cd1ccdb7488c789f08117d4" translate="yes" xml:space="preserve">
          <source>However &amp;mdash; normally you&amp;rsquo;d never use &lt;code&gt;git write-tree&lt;/code&gt; on its own, because normally you always commit a tree into a commit object using the &lt;code&gt;git commit-tree&lt;/code&gt; command. In fact, it&amp;rsquo;s easier to not actually use &lt;code&gt;git write-tree&lt;/code&gt; on its own at all, but to just pass its result in as an argument to &lt;code&gt;git commit-tree&lt;/code&gt;.</source>
          <target state="translated">그러나 일반적으로 항상 &lt;code&gt;git commit-tree&lt;/code&gt; 명령을 사용하여 커밋 객체에 트리를 커밋하기 때문에 &lt;code&gt;git write-tree&lt;/code&gt; 를 단독으로 사용하지는 않습니다 . 실제로 실제로 &lt;code&gt;git write-tree&lt;/code&gt; 를 전혀 사용하지 않고 결과를 &lt;code&gt;git commit-tree&lt;/code&gt; 의 인수로 전달 하는 것이 더 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="b251a49d303741aee81dcafea3be641705e5d2d3" translate="yes" xml:space="preserve">
          <source>However repacking the repository is necessary to improve data locality and access performance. It can also take hours on extremely large projects (especially if -f and a large --window parameter is used). Since repacking is safe to run alongside readers and writers, run the repack in the background and let it finish when it finishes. There is no reason to wait to explore your new Git project!</source>
          <target state="translated">그러나 데이터 지역 및 액세스 성능을 향상 시키려면 리포지토리를 다시 포장해야합니다. 매우 큰 프로젝트 (특히 -f 및 큰 --window 매개 변수를 사용하는 경우)에도 몇 시간이 걸릴 수 있습니다. 리 패킹은 리더 및 라이터와 함께 실행하기에 안전하므로 백그라운드에서 리팩을 실행하고 완료되면 마무리하십시오. 새로운 Git 프로젝트를 탐색 할 때까지 기다릴 이유가 없습니다!</target>
        </trans-unit>
        <trans-unit id="4b948e81d3b66aa74b95ff1de52609dbf8f7d04b" translate="yes" xml:space="preserve">
          <source>However, Git does &lt;strong&gt;not&lt;/strong&gt; (and it should not) change tags behind users back. So if somebody already got the old tag, doing a &lt;code&gt;git pull&lt;/code&gt; on your tree shouldn&amp;rsquo;t just make them overwrite the old one.</source>
          <target state="translated">그러나, 힘내 수행 &lt;strong&gt;하지&lt;/strong&gt; (그리고 안) 다시 사용자의 뒤에 변경 태그입니다. 누군가가 이미 오래된 태그를 가지고 있다면 트리 에서 &lt;code&gt;git pull&lt;/code&gt; 을 수행하면 이전 태그를 덮어 쓰지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="774132ee5dd559ea340879a21fd99f6ff4549c5d" translate="yes" xml:space="preserve">
          <source>However, an understanding of these low-level tools can be helpful if you want to understand Git&amp;rsquo;s internals.</source>
          <target state="translated">그러나 Git의 내부를 이해하려는 경우 이러한 저수준 도구를 이해하면 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="866f600e87142f901a49d55ea62ea322295c395d" translate="yes" xml:space="preserve">
          <source>However, if the --combined-all-paths option is provided, instead of a two-line from-file/to-file you get a N+1 line from-file/to-file header, where N is the number of parents in the merge commit</source>
          <target state="translated">그러나 --combined-all-paths 옵션이 제공되면 두 줄의 시작 파일 / 파일 대신 N + 1 행의 파일 / 파일 헤더가 표시됩니다. 여기서 N은 병합 커밋의 부모</target>
        </trans-unit>
        <trans-unit id="24c47b91e42f0b5da2ef1b1de98db109a45643ab" translate="yes" xml:space="preserve">
          <source>However, if the current branch is an ancestor of the other&amp;mdash;​so every commit present in the current branch is already contained in the other branch&amp;mdash;​then Git just performs a &quot;fast-forward&quot;; the head of the current branch is moved forward to point at the head of the merged-in branch, without any new commits being created.</source>
          <target state="translated">그러나 현재 브랜치가 다른 브랜치의 조상 인 경우 (현재 브랜치에있는 모든 커밋이 이미 다른 브랜치에 포함 된 경우) Git은 단지 &quot;빨리 감기&quot;를 수행합니다. 현재 분기의 헤드는 새로운 커밋을 만들지 않고 병합 된 분기의 헤드를 가리 키도록 앞으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="38320aec0b4074b6ba1fc6f9446c9d65a3296509" translate="yes" xml:space="preserve">
          <source>However, if the file is absent from the tree of some commit, a simple &lt;code&gt;rm filename&lt;/code&gt; will fail for that tree and commit. Thus you may instead want to use &lt;code&gt;rm -f filename&lt;/code&gt; as the script.</source>
          <target state="translated">그러나 파일이 일부 커밋 트리에없는 경우 해당 트리에 대해 간단한 &lt;code&gt;rm filename&lt;/code&gt; 이 실패하고 커밋됩니다. 따라서 대신 &lt;code&gt;rm -f filename&lt;/code&gt; 을 스크립트로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="083d51e29026b4e1a08bfd658353fe31999e3907" translate="yes" xml:space="preserve">
          <source>However, if you decide to jump to a new version, or check out somebody else&amp;rsquo;s version, or just restore a previous tree, you&amp;rsquo;d populate your index file with read-tree, and then you need to check out the result with</source>
          <target state="translated">그러나 새 버전으로 이동하거나 다른 사람의 버전을 확인하거나 이전 트리를 복원하려는 경우 인덱스 파일을 읽기 트리로 채우고 결과를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="d73cbcd65f07eabb528955f0d408caeaef9ec132" translate="yes" xml:space="preserve">
          <source>However, if you have local changes in the working tree that would be overwritten by this merge, &lt;code&gt;git read-tree&lt;/code&gt; will refuse to run to prevent your changes from being lost.</source>
          <target state="translated">그러나이 병합으로 덮어 쓰는 작업 트리에 로컬 변경 사항이있는 경우 &lt;code&gt;git read-tree&lt;/code&gt; 는 변경 사항이 손실되지 않도록 실행을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="0f801baa64ce652ffc6d36336f6a234c862e64a0" translate="yes" xml:space="preserve">
          <source>However, if you prefer to keep the history in mywork a simple series of commits without any merges, you may instead choose to use &lt;a href=&quot;git-rebase&quot;&gt;git-rebase[1]&lt;/a&gt;:</source>
          <target state="translated">그러나 mywork에서 히스토리를 병합없이 간단한 일련의 커밋으로 유지하려면 &lt;a href=&quot;git-rebase&quot;&gt;git-rebase [1]&lt;/a&gt; 사용하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a9f204773ec4f6bc12691a9ec080236d437d186" translate="yes" xml:space="preserve">
          <source>However, if you really only want to replace the line for the default proxy, i.e. the one without a &quot;for &amp;hellip;​&quot; postfix, do something like this:</source>
          <target state="translated">그러나 기본 프록시 (예 : &quot;...&quot;접미사가없는 행) 만 바꾸려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="fe54b4a5cce25da95a527e803024815678af4c5c" translate="yes" xml:space="preserve">
          <source>However, if you skip a commit adjacent to the one you are looking for, Git will be unable to tell exactly which of those commits was the first bad one.</source>
          <target state="translated">그러나 찾고있는 커밋과 인접한 커밋을 건너 뛰면 Git은 커밋 중 어느 것이 첫 번째 나쁜 커밋인지 정확하게 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e9adef201cc69834664c04ac9c044e6acc3b8daa" translate="yes" xml:space="preserve">
          <source>However, it is not necessary to create branches in p4 to be able to use them like branches. Because it is difficult to infer branch relationships automatically, a Git configuration setting &lt;code&gt;git-p4.branchList&lt;/code&gt; can be used to explicitly identify branch relationships. It is a list of &quot;source:destination&quot; pairs, like a simple p4 branch specification, where the &quot;source&quot; and &quot;destination&quot; are the path elements in the p4 repository. The example above relied on the presence of the p4 branch. Without p4 branches, the same result will occur with:</source>
          <target state="translated">그러나 p4에서 브랜치를 사용하기 위해 브랜치를 생성 할 필요는 없습니다. 분기 관계를 자동으로 유추하기 어렵 기 때문에 Git 구성 설정 &lt;code&gt;git-p4.branchList&lt;/code&gt; 를 사용하여 분기 관계를 명시 적으로 식별 할 수 있습니다. 간단한 p4 분기 스펙과 같이 &quot;source : destination&quot;쌍의 목록입니다. 여기서 &quot;source&quot;및 &quot;destination&quot;은 p4 저장소의 경로 요소입니다. 위의 예는 p4 브랜치의 존재에 의존했습니다. p4 분기가 없으면 동일한 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c71bf4b100c16d667a048d4524ffef40edf8598e" translate="yes" xml:space="preserve">
          <source>However, one may also want to specify other diff driver attributes. For example, you might want to use &lt;code&gt;textconv&lt;/code&gt; to convert postscript files to an ASCII representation for human viewing, but otherwise treat them as binary files. You cannot specify both &lt;code&gt;-diff&lt;/code&gt; and &lt;code&gt;diff=ps&lt;/code&gt; attributes. The solution is to use the &lt;code&gt;diff.*.binary&lt;/code&gt; config option:</source>
          <target state="translated">그러나 다른 diff 드라이버 속성을 지정할 수도 있습니다. 예를 들어 &lt;code&gt;textconv&lt;/code&gt; 를 사용 하여 포스트 스크립트 파일을 사람이 볼 수 있도록 ASCII 표현으로 변환 할 수 있지만 이진 파일로 처리 할 수 ​​있습니다. &lt;code&gt;-diff&lt;/code&gt; 및 &lt;code&gt;diff=ps&lt;/code&gt; 속성을 모두 지정할 수 없습니다 . 해결 방법은 &lt;code&gt;diff.*.binary&lt;/code&gt; 구성 옵션 을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c15b1eea7ada51b9540f36c6d7433749c2518719" translate="yes" xml:space="preserve">
          <source>However, our next step is to commit the &lt;strong&gt;change&lt;/strong&gt; we did, and again, to understand what&amp;rsquo;s going on, keep in mind the difference between &quot;working tree contents&quot;, &quot;index file&quot; and &quot;committed tree&quot;. We have changes in the working tree that we want to commit, and we always have to work through the index file, so the first thing we need to do is to update the index cache:</source>
          <target state="translated">그러나 다음 단계는 &lt;strong&gt;변경 내용&lt;/strong&gt; 을 커밋하고 진행 상황을 이해하기 위해 &quot;작업 트리 내용&quot;, &quot;인덱스 파일&quot;및 &quot;커밋 된 트리&quot;의 차이점을 명심하십시오. 작업 트리에 커밋하려는 변경 사항이 있으며 항상 인덱스 파일을 통해 작업해야하므로 인덱스 캐시를 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="066e262ce5d073a40098065a4bfe593a37b357ee" translate="yes" xml:space="preserve">
          <source>However, since Git knows about them, you can now start using some of the most basic Git commands to manipulate the files or look at their status.</source>
          <target state="translated">그러나 Git은 이에 대해 알고 있으므로 이제 가장 기본적인 Git 명령을 사용하여 파일을 조작하거나 파일 상태를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d4b86f86d3381add9d6753c2a6a37207cb69976" translate="yes" xml:space="preserve">
          <source>However, the &lt;a href=&quot;git-pull&quot;&gt;git-pull[1]&lt;/a&gt; command provides a way to do this in one step:</source>
          <target state="translated">그러나 &lt;a href=&quot;git-pull&quot;&gt;git-pull [1]&lt;/a&gt; 명령은 한 단계로이를 수행하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b2062c8611299450fbfa8b88f93e46840eed9772" translate="yes" xml:space="preserve">
          <source>However, the commits do not form a simple list; Git allows lines of development to diverge and then reconverge, and the point where two lines of development reconverge is called a &quot;merge&quot;. The commit representing a merge can therefore have more than one parent, with each parent representing the most recent commit on one of the lines of development leading to that point.</source>
          <target state="translated">그러나 커밋은 간단한 목록을 형성하지 않습니다. 힘내 개발 라인을 분기하고 다시 수렴하고 두 개발 라인이 수렴하는 지점을 &quot;병합&quot;이라고합니다. 따라서 병합을 나타내는 커밋에는 둘 이상의 부모가있을 수 있으며 각 부모는 해당 시점으로 이어지는 개발 라인 중 하나에서 가장 최근의 커밋을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dc3c84ebe58db76ac38c1e3a6d7daded7c305410" translate="yes" xml:space="preserve">
          <source>However, the more common way to do this is to maintain a separate public repository (usually on a different host) for others to pull changes from. This is usually more convenient, and allows you to cleanly separate private work in progress from publicly visible work.</source>
          <target state="translated">그러나이 작업을 수행하는 가장 일반적인 방법은 다른 사람이 변경 사항을 가져올 수 있도록 별도의 공용 리포지토리 (일반적으로 다른 호스트에 있음)를 유지 관리하는 것입니다. 이것은 일반적으로 더 편리하며 진행중인 개인 작업을 공개적으로 보이는 작업과 깨끗하게 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="755c039a0c20727e4839caf6deef253d613f16de" translate="yes" xml:space="preserve">
          <source>However, there are cases in which your local changes do conflict with the upstream changes, and &lt;code&gt;git pull&lt;/code&gt; refuses to overwrite your changes. In such a case, you can stash your changes away, perform a pull, and then unstash, like this:</source>
          <target state="translated">그러나 로컬 변경 사항이 업스트림 변경 사항과 충돌하는 경우가 있으며 &lt;code&gt;git pull&lt;/code&gt; 이 변경 사항을 덮어 쓰지 않습니다. 이 경우 다음과 같이 변경 사항을 숨기고 풀을 수행 한 다음 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e43d419a26518c38e69ee02a5a541b221da6c649" translate="yes" xml:space="preserve">
          <source>However, there are legitimate reasons why a developer may want to recreate merge commits: to keep the branch structure (or &quot;commit topology&quot;) when working on multiple, inter-related branches.</source>
          <target state="translated">그러나 개발자가 병합 커밋을 다시 만들려는 합당한 이유가 있습니다. 여러 개의 상호 관련 분기에서 작업 할 때 분기 구조 (또는 &quot;커밋 토폴로지&quot;)를 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="89adb927099ba4a8289673a41ab8ec24ea6e4abd" translate="yes" xml:space="preserve">
          <source>However, there is a situation in which it can be useful to violate this assumption.</source>
          <target state="translated">그러나이 가정을 위반하는 것이 유용 할 수있는 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b068287d80433091fc93a07d4af49d57d3676c5d" translate="yes" xml:space="preserve">
          <source>However, there is no particular reason to merge in one branch first and the other next, when what you have are a set of truly independent changes (if the order mattered, then they are not independent by definition). You could instead merge those two branches into the current branch at once. First let&amp;rsquo;s undo what we just did and start over. We would want to get the master branch before these two merges by resetting it to &lt;code&gt;master~2&lt;/code&gt;:</source>
          <target state="translated">그러나, 당신이 가지고있는 것이 진정으로 독립적 인 변화의 집합 일 때 (하나의 순서가 중요하다면, 그것들은 정의에 의해 독립적이지 않은) 하나의 브랜치를 먼저 병합하고 다른 브랜치를 병합 할 특별한 이유가 없습니다. 대신 두 분기를 현재 분기로 한 번에 병합 할 수 있습니다. 먼저 방금 수행 한 작업을 취소하고 다시 시작하겠습니다. 우리는이 두 병합 전에 마스터 분기를 &lt;code&gt;master~2&lt;/code&gt; 로 재설정하여 가져오고 싶습니다 .</target>
        </trans-unit>
        <trans-unit id="76dbad7bbd23560fcc8351e42a22aad055901cd6" translate="yes" xml:space="preserve">
          <source>However, these features fall short of a complete solution, so users who run commands concurrently have to live with some risk of corruption (which seems to be low in practice).</source>
          <target state="translated">그러나 이러한 기능은 완벽한 솔루션을 갖추지 못하므로 명령을 동시에 실행하는 사용자는 약간의 손상 위험이 있습니다 (실제로는 낮은 것 같습니다).</target>
        </trans-unit>
        <trans-unit id="f41fcda082e8874086be41192b1abbea2d3295da" translate="yes" xml:space="preserve">
          <source>However, this is &lt;strong&gt;NOT&lt;/strong&gt; allowed for switches with an optional value, where the &lt;code&gt;stuck&lt;/code&gt; form must be used:</source>
          <target state="translated">그러나이 값은 &lt;code&gt;stuck&lt;/code&gt; 양식을 사용해야 하는 선택적 값이있는 스위치에는 허용 &lt;strong&gt;되지&lt;/strong&gt; 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4da9d9ef7c6a0e88df4192c01891a87d88664b48" translate="yes" xml:space="preserve">
          <source>However, this is only a convention, and you can name your branches anything you want, and don&amp;rsquo;t have to ever even &lt;code&gt;have&lt;/code&gt; a &lt;code&gt;master&lt;/code&gt; branch. A number of the Git tools will assume that &lt;code&gt;.git/HEAD&lt;/code&gt; is valid, though.</source>
          <target state="translated">그러나 이것은 컨벤션 일 뿐이므로 원하는 이름으로 지점 이름을 지정할 수 있으며 &lt;code&gt;master&lt;/code&gt; 브랜치를 &lt;code&gt;have&lt;/code&gt; 필요도 없습니다 . 많은 Git 도구는 &lt;code&gt;.git/HEAD&lt;/code&gt; 가 유효 하다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="a7abfde622702125ddcfca8f6b53cf2f29202a6d" translate="yes" xml:space="preserve">
          <source>However, this last command can be dangerous in some cases&amp;mdash;​never throw away a commit you have already committed if that commit may itself have been merged into another branch, as doing so may confuse further merges.</source>
          <target state="translated">그러나이 마지막 명령은 경우에 따라 위험 할 수 있습니다. 커밋 자체가 다른 브랜치에 병합되었을 경우 이미 커밋 한 커밋을 버리지 마십시오. 그렇게하면 추가 병합이 혼동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba574b0c600bcf4947d9fc0b827ea5d5666b3028" translate="yes" xml:space="preserve">
          <source>However, when no confusion will result, we often just use the term &quot;branch&quot; both for branches and for branch heads.</source>
          <target state="translated">그러나 혼동이 없을 때 종종 분기와 분기 헤드 모두에 &quot;분기&quot;라는 용어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2952d19c4dc617ab4a4ae6abe65c729f11b54f82" translate="yes" xml:space="preserve">
          <source>However, when you do &lt;code&gt;git read-tree&lt;/code&gt; with three trees, the &quot;stage&quot; starts out at 1.</source>
          <target state="translated">그러나 세 개의 나무로 &lt;code&gt;git read-tree&lt;/code&gt; 를 수행 하면 &quot;stage&quot;는 1부터 시작합니다.</target>
        </trans-unit>
        <trans-unit id="28dd1f9126b301b96d86409d92ae4b0d38938148" translate="yes" xml:space="preserve">
          <source>However, while there is nothing wrong with Git&amp;rsquo;s support for shared repositories, this mode of operation is not generally recommended, simply because the mode of collaboration that Git supports&amp;mdash;​by exchanging patches and pulling from public repositories&amp;mdash;​has so many advantages over the central shared repository:</source>
          <target state="translated">그러나 Git의 공유 리포지토리 지원에는 아무런 문제가 없지만 패치를 교환하고 퍼블릭 리포지토리에서 가져 와서 Git이 지원하는 공동 작업 모드가 Git에서 지원하는 공동 작업 모드는 일반적으로 권장되지 않습니다. 중앙 공유 저장소 :</target>
        </trans-unit>
        <trans-unit id="6ee73f3ad469e31cc982a856f9ec909f123f7a3b" translate="yes" xml:space="preserve">
          <source>However, you already dirtied the index (i.e. your index does not match the &lt;code&gt;HEAD&lt;/code&gt; commit). But you know the pull you are going to make does not affect &lt;code&gt;frotz.c&lt;/code&gt; or &lt;code&gt;filfre.c&lt;/code&gt;, so you revert the index changes for these two files. Your changes in working tree remain there.</source>
          <target state="translated">그러나 이미 색인을 더럽 혔습니다 (예 : 색인이 &lt;code&gt;HEAD&lt;/code&gt; 커밋 과 일치하지 않음 ). 그러나 당기 &lt;code&gt;frotz.c&lt;/code&gt; 또는 &lt;code&gt;filfre.c&lt;/code&gt; 에 영향을 미치지 않으므로이 두 파일의 인덱스 변경 사항을 되돌 립니다 . 작업 트리의 변경 사항은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9e2e4a0fcb3942d8a82c6a2331932351c7c8a259" translate="yes" xml:space="preserve">
          <source>However, your &quot;wrong&quot; branch and correct &quot;mytopic&quot; branch may differ in files that you have modified locally, in which case the above switch would fail like this:</source>
          <target state="translated">그러나 &quot;잘못된&quot;분기와 올바른 &quot;mytopic&quot;분기는 로컬에서 수정 한 파일이 다를 수 있습니다.이 경우 위의 스위치는 다음과 같이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="6a9281c350a487a356b48bdfa67abfef81982489" translate="yes" xml:space="preserve">
          <source>However, your &quot;wrong&quot; branch and correct &lt;code&gt;mytopic&lt;/code&gt; branch may differ in files that you have modified locally, in which case the above checkout would fail like this:</source>
          <target state="translated">그러나 &quot;잘못된&quot;분기와 올바른 &lt;code&gt;mytopic&lt;/code&gt; 분기는 로컬에서 수정 한 파일이 다를 수 있습니다.이 경우 위의 체크 아웃은 다음과 같이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="eaf133288702a5baf1a98928a127236dfad5386f" translate="yes" xml:space="preserve">
          <source>I most actively use it during the merge window (when a lot of trees get merged upstream and when the influx of bugs is the highest) - and yes, there have been cases that i used it multiple times a day. My average is roughly once a day.</source>
          <target state="translated">병합 창에서 가장 적극적으로 사용합니다 (많은 나무가 업스트림으로 병합되고 버그 유입이 가장 높은 경우). 그렇습니다. 하루에 여러 번 사용한 경우가 있습니다. 내 평균은 대략 하루에 한 번입니다.</target>
        </trans-unit>
        <trans-unit id="27777a39e933776b5c584d121830042fbc955f15" translate="yes" xml:space="preserve">
          <source>I.e. a fast-forward of commits and tags outside &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; is allowed, even in cases where what&amp;rsquo;s being fast-forwarded is not a commit, but a tag object which happens to point to a new commit which is a fast-forward of the commit the last tag (or commit) it&amp;rsquo;s replacing. Replacing a tag with an entirely different tag is also allowed, if it points to the same commit, as well as pushing a peeled tag, i.e. pushing the commit that existing tag object points to, or a new tag object which an existing commit points to.</source>
          <target state="translated">즉, &lt;code&gt;refs/{tags,heads}/*&lt;/code&gt; 외부의 커밋 및 태그의 빨리 감기 는 허용되지만, 빨리 감기 되는 것이 커밋이 아닌 새로운 커밋을 가리키는 태그 객체 인 경우에도 허용됩니다. 대체하는 커밋의 마지막 태그 (또는 커밋)를 빨리 감습니다. 태그가 동일한 커밋을 가리키고 벗겨진 태그를 푸시하는 것 (예 : 기존 태그 오브젝트가 가리키는 커밋 또는 기존 커밋이 가리키는 새 태그 오브젝트)을 태그하는 경우 완전히 다른 태그로 태그를 교체하는 것도 허용됩니다. .</target>
        </trans-unit>
        <trans-unit id="f6dcea8e2840d6db982f7ea79204e026c88b3ea6" translate="yes" xml:space="preserve">
          <source>I.e. create a &lt;code&gt;base&lt;/code&gt; tag for versions of the upstream code that you&amp;rsquo;ve seen and are willing to overwrite, then rewrite history, and finally force push changes to &lt;code&gt;master&lt;/code&gt; if the remote version is still at &lt;code&gt;base&lt;/code&gt;, regardless of what your local &lt;code&gt;remotes/origin/master&lt;/code&gt; has been updated to in the background.</source>
          <target state="translated">즉, 보았고 기꺼이 덮어 쓴 다음 업스트림 코드 버전에 대한 &lt;code&gt;base&lt;/code&gt; 태그를 작성하고 로컬 &lt;code&gt;remotes/origin/master&lt;/code&gt; 관계없이 원격 버전이 여전히 &lt;code&gt;base&lt;/code&gt; 있으면 변경 사항을 &lt;code&gt;master&lt;/code&gt; 강제 변경합니다. / master 가 백그라운드에서 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="d160035a43dfa655c4a6e47190220d072175392c" translate="yes" xml:space="preserve">
          <source>IOW, you can use this thing to look for likely duplicate commits.</source>
          <target state="translated">IOW,이 것을 사용하여 중복 커밋을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="445867d9c88cb9ec795d4d1edb4358f7f32ed23d" translate="yes" xml:space="preserve">
          <source>ISO 8601</source>
          <target state="translated">ISO 8601</target>
        </trans-unit>
        <trans-unit id="8927163ad4efa8aea54b9b8e320ebffea4053ff8" translate="yes" xml:space="preserve">
          <source>Id of a tree-ish.</source>
          <target state="translated">나무 같은 것.</target>
        </trans-unit>
        <trans-unit id="f64266dea77070f77d87b89cb3f30c2d11210170" translate="yes" xml:space="preserve">
          <source>Identifier terminology</source>
          <target state="translated">식별자 용어</target>
        </trans-unit>
        <trans-unit id="2dd468355239de3fa1d047b407c0f3c35e4315ad" translate="yes" xml:space="preserve">
          <source>Identity-specific versions of the &lt;code&gt;sendemail.*&lt;/code&gt; parameters found below, taking precedence over those when this identity is selected, through either the command-line or &lt;code&gt;sendemail.identity&lt;/code&gt;.</source>
          <target state="translated">아래 에있는 &lt;code&gt;sendemail.*&lt;/code&gt; 매개 변수 의 신원 별 버전은 명령 행 또는 &lt;code&gt;sendemail.identity&lt;/code&gt; 를 통해이 신원을 선택할 때 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="05103278665252bd3225a3f315ada6e006bd41ae" translate="yes" xml:space="preserve">
          <source>If &amp;ldquo;:&amp;lt;funcname&amp;gt;&amp;rdquo; is given in place of &amp;lt;start&amp;gt; and &amp;lt;end&amp;gt;, it is a regular expression that denotes the range from the first funcname line that matches &amp;lt;funcname&amp;gt;, up to the next funcname line. &amp;ldquo;:&amp;lt;funcname&amp;gt;&amp;rdquo; searches from the end of the previous &lt;code&gt;-L&lt;/code&gt; range, if any, otherwise from the start of file. &amp;ldquo;^:&amp;lt;funcname&amp;gt;&amp;rdquo; searches from the start of file.</source>
          <target state="translated">&amp;lt;start&amp;gt; 및 &amp;lt;end&amp;gt; 대신&amp;ldquo;: &amp;lt;funcname&amp;gt;&amp;rdquo;이 지정된 경우 &amp;lt;funcname&amp;gt;과 일치하는 첫 번째 funcname 행부터 다음 funcname 행까지의 범위를 나타내는 정규식입니다. &amp;ldquo;: &amp;lt;funcname&amp;gt;&amp;rdquo;은 이전 &lt;code&gt;-L&lt;/code&gt; 범위 의 끝에서 검색 합니다 (있는 경우). 그렇지 않으면 파일 시작에서 검색합니다. &amp;ldquo;^ : &amp;lt;funcname&amp;gt;&amp;rdquo;은 파일 시작 부분에서 검색합니다.</target>
        </trans-unit>
        <trans-unit id="a70081d33e7c2f9862444b9de88b6fa456d0c4eb" translate="yes" xml:space="preserve">
          <source>If &amp;lt;branch&amp;gt; is specified, &lt;code&gt;git rebase&lt;/code&gt; will perform an automatic &lt;code&gt;git switch &amp;lt;branch&amp;gt;&lt;/code&gt; before doing anything else. Otherwise it remains on the current branch.</source>
          <target state="translated">&amp;lt;branch&amp;gt;가 지정되면 &lt;code&gt;git rebase&lt;/code&gt; 는 다른 작업을 수행하기 전에 자동 &lt;code&gt;git switch &amp;lt;branch&amp;gt;&lt;/code&gt; 를 수행합니다. 그렇지 않으면 현재 분기에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="441a1b498aa3709837145817fb556c2b9312d349" translate="yes" xml:space="preserve">
          <source>If &amp;lt;commit-ish&amp;gt; is a branch name (call it &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;) and is not found, and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; are used, but there does exist a tracking branch in exactly one remote (call it &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;) with a matching name, treat as equivalent to:</source>
          <target state="translated">&amp;lt;commit-ish&amp;gt;가 분기 이름이고 ( &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 라고 함 ) 찾을 수없고 &lt;code&gt;-b&lt;/code&gt; 도 &lt;code&gt;-B&lt;/code&gt; 도 &lt;code&gt;--detach&lt;/code&gt; 도 사용되지 않지만 정확히 하나의 리모트에 추적 분기가있는 경우 (호출) 이름이 일치하는 &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; )는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a2dfa99d3d5ae08ba34d86a50dd72c99c275182b" translate="yes" xml:space="preserve">
          <source>If &amp;lt;dst&amp;gt; does not match any remote ref, either</source>
          <target state="translated">&amp;lt;dst&amp;gt;가 원격 참조와 일치하지 않으면</target>
        </trans-unit>
        <trans-unit id="a47c4a8533ef20594cec62184911d5ccc54294bc" translate="yes" xml:space="preserve">
          <source>If &amp;lt;dst&amp;gt; doesn&amp;rsquo;t start with &lt;code&gt;refs/&lt;/code&gt; (e.g. &lt;code&gt;refs/heads/master&lt;/code&gt;) we will try to infer where in &lt;code&gt;refs/*&lt;/code&gt; on the destination &amp;lt;repository&amp;gt; it belongs based on the type of &amp;lt;src&amp;gt; being pushed and whether &amp;lt;dst&amp;gt; is ambiguous.</source>
          <target state="translated">&amp;lt;dst&amp;gt;가 &lt;code&gt;refs/&lt;/code&gt; 시작하지 않는 경우 (예 : &lt;code&gt;refs/heads/master&lt;/code&gt; ) 목적지 &amp;lt;repository&amp;gt;의 &lt;code&gt;refs/*&lt;/code&gt; 에서 &amp;lt;src&amp;gt;의 유형과 &amp;lt;src&amp;gt;의 유형 및 &amp;lt; dst&amp;gt;가 모호합니다.</target>
        </trans-unit>
        <trans-unit id="055e400548fbd1f8dd3a927bc48c7fba28571578" translate="yes" xml:space="preserve">
          <source>If &amp;lt;dst&amp;gt; unambiguously refers to a ref on the &amp;lt;repository&amp;gt; remote, then push to that ref.</source>
          <target state="translated">&amp;lt;dst&amp;gt;가 &amp;lt;repository&amp;gt; 리모콘의 참조를 모호하지 않으면 해당 참조로 푸시하십시오.</target>
        </trans-unit>
        <trans-unit id="2f8ca0e0f80952529303f3d2318f597064384182" translate="yes" xml:space="preserve">
          <source>If &amp;lt;src&amp;gt; resolves to a ref starting with refs/heads/ or refs/tags/, then prepend that to &amp;lt;dst&amp;gt;.</source>
          <target state="translated">&amp;lt;src&amp;gt;가 refs / heads / 또는 refs / tags /로 시작하는 ref로 해석되면, &amp;lt;dst&amp;gt; 앞에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="22f62b9091f5d458969b188b7b4383b4ee480486" translate="yes" xml:space="preserve">
          <source>If &amp;lt;start&amp;gt; or &amp;lt;end&amp;gt; is a number, it specifies an absolute line number (lines count from 1).</source>
          <target state="translated">&amp;lt;start&amp;gt; 또는 &amp;lt;end&amp;gt;가 숫자 인 경우 절대 줄 번호를 지정합니다 (줄은 1부터 계산).</target>
        </trans-unit>
        <trans-unit id="3dcd00aaff1f71fc43821b3cae7ba5d1996fda2a" translate="yes" xml:space="preserve">
          <source>If &amp;lt;type&amp;gt; is specified, the raw (though uncompressed) contents of the &amp;lt;object&amp;gt; will be returned.</source>
          <target state="translated">&amp;lt;type&amp;gt;을 지정하면 &amp;lt;object&amp;gt;의 원시 (압축되지 않은) 내용이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="60fbab80da041fac4b578f6b9620a6e042d89ff6" translate="yes" xml:space="preserve">
          <source>If &amp;lt;upstream&amp;gt; is given on the command line, then the default is &lt;code&gt;--no-fork-point&lt;/code&gt;, otherwise the default is &lt;code&gt;--fork-point&lt;/code&gt;.</source>
          <target state="translated">명령 줄에 &amp;lt;upstream&amp;gt;이 제공되면 기본값은 &lt;code&gt;--no-fork-point&lt;/code&gt; 이고, 그렇지 않으면 기본값은 &lt;code&gt;--fork-point&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="099d6bbda7b3ea83e2000830c8cd48d38a505e41" translate="yes" xml:space="preserve">
          <source>If &amp;lt;upstream&amp;gt; is not specified, the upstream configured in branch.&amp;lt;name&amp;gt;.remote and branch.&amp;lt;name&amp;gt;.merge options will be used (see &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details) and the &lt;code&gt;--fork-point&lt;/code&gt; option is assumed. If you are currently not on any branch or if the current branch does not have a configured upstream, the rebase will abort.</source>
          <target state="translated">&amp;lt;upstream&amp;gt;을 지정하지 않으면 branch. &amp;lt;name&amp;gt; .remote 및 branch. &amp;lt;name&amp;gt; .merge 옵션에 구성된 업스트림 (자세한 내용은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]&lt;/a&gt; 참조) 및 &lt;code&gt;--fork-point&lt;/code&gt; 옵션이 사용됩니다. 가정합니다. 현재 지점에 없거나 현재 지점에 업스트림이 구성되어 있지 않으면 리베이스가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="217621e5abfa606810a09d87aaa6c7fa540fc0fa" translate="yes" xml:space="preserve">
          <source>If --base-path is enabled and repo lookup fails, with this option &lt;code&gt;git daemon&lt;/code&gt; will attempt to lookup without prefixing the base path. This is useful for switching to --base-path usage, while still allowing the old paths.</source>
          <target state="translated">--base-path가 활성화되어 있고 repo 조회가 실패하면이 옵션을 사용하여 &lt;code&gt;git daemon&lt;/code&gt; 은 기본 경로의 접두사없이 조회를 시도합니다. 이는 기존 경로를 계속 허용하면서 --base-path 사용법으로 전환하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8fc1cea1e55be69663b951a920323d5b77c212cc" translate="yes" xml:space="preserve">
          <source>If --follow-symlinks is used, and a symlink in the repository points outside the repository, then &lt;code&gt;cat-file&lt;/code&gt; will ignore any custom format and print:</source>
          <target state="translated">--follow-symlinks가 사용되고 저장소의 symlink가 저장소 외부를 가리키는 경우 &lt;code&gt;cat-file&lt;/code&gt; 은 사용자 정의 형식을 무시하고 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="100e053a72420596d3d8e1af3be6193b59283565" translate="yes" xml:space="preserve">
          <source>If --follow-symlinks is used, the following error messages will be displayed:</source>
          <target state="translated">--follow-symlinks를 사용하면 다음 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5af2f9fd35f6354ba06f2224c3a1950a1f2e9539" translate="yes" xml:space="preserve">
          <source>If --no-deref is given, &amp;lt;ref&amp;gt; itself is overwritten, rather than the result of following the symbolic pointers.</source>
          <target state="translated">--no-deref를 지정하면 기호 포인터를 따른 결과가 아니라 &amp;lt;ref&amp;gt; 자체를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="09e3aecc968d12fb9705beff5237174e03c29bc7" translate="yes" xml:space="preserve">
          <source>If --porcelain is used, then each line of the output is of the form:</source>
          <target state="translated">--porcelain을 사용하는 경우 출력의 각 줄은 다음과 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="f6d2b768e06f422855acdd627f6c6194c3c0ef9e" translate="yes" xml:space="preserve">
          <source>If --prune-empty is specified, sometimes empty commits are missed and left around anyway (a somewhat rare bug, but it happens&amp;hellip;​)</source>
          <target state="translated">--prune-empty를 지정하면 빈 커밋이 누락되어 어쨌든 남습니다 (약간 드문 버그이지만 발생합니다 ...)</target>
        </trans-unit>
        <trans-unit id="e22868793c21cef41b42f4d8e7236df1fabd77b0" translate="yes" xml:space="preserve">
          <source>If --prune-empty is specified, then intentionally placed empty commits from before the filtering operation are also pruned instead of just pruning commits that became empty due to filtering rules.</source>
          <target state="translated">--prune-empty를 지정하면 필터링 규칙으로 인해 비워진 커밋을 정리하는 대신 필터링 작업을 시작하기 전에 의도적으로 빈 커밋을 배치합니다.</target>
        </trans-unit>
        <trans-unit id="a5f91d56ff44d75c2f6264bd8bf6a44ba8095c27" translate="yes" xml:space="preserve">
          <source>If --prune-empty isn&amp;rsquo;t specified, then the filtering process can create hoards of confusing empty commits</source>
          <target state="translated">--prune-empty를 지정하지 않으면 필터링 프로세스로 인해 빈 커밋이 혼동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d1fd147af59c1bbe70034d2e19205e4683ec22e" translate="yes" xml:space="preserve">
          <source>If --refresh finds unmerged changes in the index, the default behavior is to error out. This option makes &lt;code&gt;git update-index&lt;/code&gt; continue anyway.</source>
          <target state="translated">--refresh가 인덱스에서 병합되지 않은 변경 사항을 찾으면 기본 동작은 오류입니다. 이 옵션은 &lt;code&gt;git update-index&lt;/code&gt; 를 계속 진행시킵니다.</target>
        </trans-unit>
        <trans-unit id="a1d97a45ebe920517b85d93c5180821e570038df" translate="yes" xml:space="preserve">
          <source>If -b is used the short-format status is preceded by a line</source>
          <target state="translated">-b를 사용하면 짧은 형식 상태 앞에 줄이옵니다.</target>
        </trans-unit>
        <trans-unit id="a46e8db06d3992e975f7697afc61f277e4b431aa" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;git-tag&quot;&gt;git-tag[1]&lt;/a&gt; or &lt;a href=&quot;git-commit&quot;&gt;git-commit[1]&lt;/a&gt; is not selecting the key you want it to automatically when creating a signed tag or commit, you can override the default selection with this variable. This option is passed unchanged to gpg&amp;rsquo;s --local-user parameter, so you may specify a key using any method that gpg supports.</source>
          <target state="translated">경우 &lt;a href=&quot;git-tag&quot;&gt;자식 태그 [1]&lt;/a&gt; 또는 &lt;a href=&quot;git-commit&quot;&gt;[1] 자식이 커밋&lt;/a&gt; 키를 선택하지 않는 당신이 자동으로 서명 된 태그를 만들거나 커밋 할 때 원하는,이 변수로 기본 선택을 무시할 수 있습니다. 이 옵션은 변경되지 않고 gpg의 --local-user 매개 변수로 전달되므로 gpg가 지원하는 방법을 사용하여 키를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cf1a7ea3bd0bf42d7200bd0e5a09fa57461a419" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$GIT_DIR/&amp;lt;refname&amp;gt;&lt;/code&gt; exists, that is what you mean (this is usually useful only for &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;FETCH_HEAD&lt;/code&gt;, &lt;code&gt;ORIG_HEAD&lt;/code&gt;, &lt;code&gt;MERGE_HEAD&lt;/code&gt; and &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt;);</source>
          <target state="translated">경우 &lt;code&gt;$GIT_DIR/&amp;lt;refname&amp;gt;&lt;/code&gt; 당신이 무엇을 의미하는지 즉, 존재 (이것은 단지에 일반적으로 유용 &lt;code&gt;HEAD&lt;/code&gt; , &lt;code&gt;FETCH_HEAD&lt;/code&gt; , &lt;code&gt;ORIG_HEAD&lt;/code&gt; , &lt;code&gt;MERGE_HEAD&lt;/code&gt; 및 &lt;code&gt;CHERRY_PICK_HEAD&lt;/code&gt; );</target>
        </trans-unit>
        <trans-unit id="393d945c97962e065f70f0c395a4b7cc04c58275" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$GIT_DIR&lt;/code&gt; is not defined and the current directory is not detected to lie in a Git repository or work tree print a message to stderr and exit with nonzero status.</source>
          <target state="translated">경우 &lt;code&gt;$GIT_DIR&lt;/code&gt; 정의되지 않고 현재 디렉토리가 Git 저장소 또는 작업 트리의 거짓말에 감지되지 제로 상태로 표준 오류 및 종료에 메시지를 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b71bb32cc72ead271cb1dd3ba713d52586ceff1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$per_request_config&lt;/code&gt; is not a code reference, it is interpreted as boolean value. If it is true gitweb will process config files once per request, and if it is false gitweb will process config files only once, each time it is executed. True by default (set to 1).</source>
          <target state="translated">&lt;code&gt;$per_request_config&lt;/code&gt; 가 코드 참조가 아닌 경우 부울 값으로 해석됩니다. 그것이 사실이라면 gitweb은 요청 당 한 번 설정 파일을 처리하고, 거짓이라면 gitweb은 실행될 때마다 설정 파일을 한 번만 처리합니다. 기본적으로 True입니다 (1로 설정).</target>
        </trans-unit>
        <trans-unit id="2006fc66d73a978df057f23b3e1521f13762b146" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;$projects_list&lt;/code&gt; variable is unset, gitweb will recursively scan filesystem for Git repositories. The &lt;code&gt;$project_maxdepth&lt;/code&gt; is used to limit traversing depth, relative to &lt;code&gt;$projectroot&lt;/code&gt; (starting point); it means that directories which are further from &lt;code&gt;$projectroot&lt;/code&gt; than &lt;code&gt;$project_maxdepth&lt;/code&gt; will be skipped.</source>
          <target state="translated">&lt;code&gt;$projects_list&lt;/code&gt; 변수가 설정되어 있지 않으면 gitweb은 파일 시스템에서 Git 저장소를 재귀 적으로 검색합니다. &lt;code&gt;$project_maxdepth&lt;/code&gt; 제한 이송 깊이를 기준으로 사용되는 &lt;code&gt;$projectroot&lt;/code&gt; (시작 지점) 이는 &lt;code&gt;$project_maxdepth&lt;/code&gt; 보다 $ &lt;code&gt;$projectroot&lt;/code&gt; 에서 더 떨어진 디렉토리는 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="e1a24fe330082e54d9c17c846d5ecec5993c1e30" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is not found but there does exist a tracking branch in exactly one remote (call it &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;) with a matching name and &lt;code&gt;--no-guess&lt;/code&gt; is not specified, treat as equivalent to</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 발견하지만 원격 단 하나의 추적 지점은 존재하지 않습니다됩니다 (이 전화 &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; 일치하는 이름) 및 &lt;code&gt;--no-guess&lt;/code&gt; 상당로 처리, 지정되지 않은</target>
        </trans-unit>
        <trans-unit id="8d6aaf33671aeae0467cc81ab4a876d4297a1c66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; is not found but there does exist a tracking branch in exactly one remote (call it &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;) with a matching name, treat as equivalent to</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 발견하지만 원격 단 하나의 추적 지점은 존재하지 않습니다됩니다 (이 전화 &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; 상당으로 일치하는 이름, 치료와 함께)</target>
        </trans-unit>
        <trans-unit id="d5e4daa5549f785c6c9358d5ddb62b147a25d8f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is a branch name (call it &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;) and is not found, and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; are used, but there does exist a tracking branch in exactly one remote (call it &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt;) with a matching name, treat as equivalent to:</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 지점 이름 (그것을 호출이다 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; ) 발견되지 않으며,도 &lt;code&gt;-b&lt;/code&gt; 도 &lt;code&gt;-B&lt;/code&gt; 도 &lt;code&gt;--detach&lt;/code&gt; 가 사용되지만, 원격 정확히 하나의 추적 지점은 존재하지 않습니다 (호출 &lt;code&gt;&amp;lt;remote&amp;gt;&lt;/code&gt; ) 이름이 일치하는 경우 다음과 동일하게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e34274f8acc6fb322cd63ad185064de80d714660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; used, then, as a convenience, the new working tree is associated with a branch (call it &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;) named after &lt;code&gt;$(basename &amp;lt;path&amp;gt;)&lt;/code&gt;. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t exist, a new branch based on &lt;code&gt;HEAD&lt;/code&gt; is automatically created as if &lt;code&gt;-b &amp;lt;branch&amp;gt;&lt;/code&gt; was given. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; does exist, it will be checked out in the new working tree, if it&amp;rsquo;s not checked out anywhere else, otherwise the command will refuse to create the working tree (unless &lt;code&gt;--force&lt;/code&gt; is used).</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 생략도있다 &lt;code&gt;-b&lt;/code&gt; 도 &lt;code&gt;-B&lt;/code&gt; 도 &lt;code&gt;--detach&lt;/code&gt; 사용하고, 편의, 새로운 작업 트리가 지점 (그 호출과 관련된 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 의 이름을 따서 명명) &lt;code&gt;$(basename &amp;lt;path&amp;gt;)&lt;/code&gt; . 만약 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 을 기반으로 새 지점, 존재하지 않는 &lt;code&gt;HEAD&lt;/code&gt; 는 경우 자동으로 생성됩니다 &lt;code&gt;-b &amp;lt;branch&amp;gt;&lt;/code&gt; 주어졌다. 경우 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 존재를하지, 그것이 새로운 작업 트리에서 체크 아웃 할 것이다 그것을 다른 곳 체크 아웃되어 있지 않은 경우, 그렇지 않으면 명령은 (하지 않는 한 작업 트리를 만들 거부합니다 &lt;code&gt;--force&lt;/code&gt; 이 사용된다).</target>
        </trans-unit>
        <trans-unit id="29cec940deeaa506fbdf23d2fcc19ea5029d5ef6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; is omitted and neither &lt;code&gt;-b&lt;/code&gt; nor &lt;code&gt;-B&lt;/code&gt; nor &lt;code&gt;--detach&lt;/code&gt; used, then, as a convenience, the new worktree is associated with a branch (call it &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt;) named after &lt;code&gt;$(basename &amp;lt;path&amp;gt;)&lt;/code&gt;. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; doesn&amp;rsquo;t exist, a new branch based on HEAD is automatically created as if &lt;code&gt;-b &amp;lt;branch&amp;gt;&lt;/code&gt; was given. If &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; does exist, it will be checked out in the new worktree, if it&amp;rsquo;s not checked out anywhere else, otherwise the command will refuse to create the worktree (unless &lt;code&gt;--force&lt;/code&gt; is used).</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;commit-ish&amp;gt;&lt;/code&gt; 생략하지도 &lt;code&gt;-b&lt;/code&gt; 도 &lt;code&gt;-B&lt;/code&gt; 도 &lt;code&gt;--detach&lt;/code&gt; 사용하고, 편의상, 새로운 worktree이 분기 (호출과 관련된 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 따서) &lt;code&gt;$(basename &amp;lt;path&amp;gt;)&lt;/code&gt; . 만약 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 것처럼 HEAD 기반으로 새 가지가 자동으로 생성됩니다, 존재하지 않는 &lt;code&gt;-b &amp;lt;branch&amp;gt;&lt;/code&gt; 주어졌다. 경우 &lt;code&gt;&amp;lt;branch&amp;gt;&lt;/code&gt; 존재를 않습니다, 그것은 새로운 worktree에서 체크 아웃 할 것이다 그것을 다른 곳 체크 아웃되어 있지 않은 경우, 그렇지 않으면 명령은 (하지 않는 한 worktree을 만들 거부합니다 &lt;code&gt;--force&lt;/code&gt; 이 사용된다).</target>
        </trans-unit>
        <trans-unit id="62b6dbbe2a25a278c760cd92507e0bb77e25690a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;auto&lt;/code&gt;, if the first paragraph of the branch description is greater than 100 bytes, then the mode will be &lt;code&gt;message&lt;/code&gt;, otherwise &lt;code&gt;subject&lt;/code&gt; will be used.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 입니다 &lt;code&gt;auto&lt;/code&gt; , 분기 설명의 첫 번째 단락보다 큰 100 바이트 인 경우, 다음 모드가 될 것입니다 &lt;code&gt;message&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;subject&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="563c89a3c046790f554398f75098f56ae60f56e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;message&lt;/code&gt; or &lt;code&gt;default&lt;/code&gt;, the cover letter subject will be populated with placeholder text. The body of the cover letter will be populated with the branch&amp;rsquo;s description. This is the default mode when no configuration nor command line option is specified.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 입니다 &lt;code&gt;message&lt;/code&gt; 또는 &lt;code&gt;default&lt;/code&gt; , 커버 레터 제목은 자리 표시 자 텍스트로 채워집니다. 표지의 본문은 지점의 설명으로 채워집니다. 구성이나 명령 행 옵션이 지정되지 않은 경우 이것이 기본 모드입니다.</target>
        </trans-unit>
        <trans-unit id="768e82f3c3c3a8afb9417d73246f89dace57fcaa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;, both the cover letter subject and body will be populated with placeholder text.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 되는 &lt;code&gt;none&lt;/code&gt; , 커버 레터의 제목과 본문 모두 자리 표시 자 텍스트로 채워되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b18877d6ecf14744d4315ad4c41aafa8a39f64e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; is &lt;code&gt;subject&lt;/code&gt;, the first paragraph of the branch description will populate the cover letter subject. The remainder of the description will populate the body of the cover letter.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;mode&amp;gt;&lt;/code&gt; 입니다 &lt;code&gt;subject&lt;/code&gt; , 분기 설명의 첫 번째 단락은 표지의 제목을 채 웁니다. 나머지 설명은 표지의 본문을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="5e29b380beb0930e1e749e4eaa468dd6abb12015" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; names an active submodule and the restore location includes the working tree, the submodule will only be updated if this option is given, in which case its working tree will be restored to the commit recorded in the superproject, and any local modifications overwritten. If nothing (or &lt;code&gt;--no-recurse-submodules&lt;/code&gt;) is used, submodules working trees will not be updated. Just like &lt;a href=&quot;git-checkout&quot;&gt;git-checkout[1]&lt;/a&gt;, this will detach &lt;code&gt;HEAD&lt;/code&gt; of the submodule.</source>
          <target state="translated">만일 &lt;code&gt;&amp;lt;pathspec&amp;gt;&lt;/code&gt; 그 작업 트리가 상기 superproject 기록 커밋을 복원 할 경우에이 옵션이 주어지면 액티브 서브 모듈 및 위치는 작업 트리 포함 복원이 서브 모듈 만 업데이트 될 이름, 및 로컬 수정 덮어 씁니다. 아무것도 사용하지 않으면 (또는 &lt;code&gt;--no-recurse-submodules&lt;/code&gt; ), 하위 모듈 작업 트리가 업데이트되지 않습니다. &lt;a href=&quot;git-checkout&quot;&gt;git-checkout [1]&lt;/a&gt; 처럼 서브 모듈의 &lt;code&gt;HEAD&lt;/code&gt; 를 분리 합니다.</target>
        </trans-unit>
        <trans-unit id="c6a4599482148106286830a5bf06a49e73c76aca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--autosquash&lt;/code&gt; is used, &quot;exec&quot; lines will not be appended for the intermediate commits, and will only appear at the end of each squash/fixup series.</source>
          <target state="translated">경우 &lt;code&gt;--autosquash&lt;/code&gt; 가 사용된다 &quot;간부&quot;라인은 중간 커밋에 대한 추가되지 않고, 각 스쿼시 / 픽스 시리즈의 끝 부분에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ab8e2bae185710923964a946f737935700b0fc1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--batch&lt;/code&gt; is specified, the object information is followed by the object contents (consisting of &lt;code&gt;%(objectsize)&lt;/code&gt; bytes), followed by a newline.</source>
          <target state="translated">경우 &lt;code&gt;--batch&lt;/code&gt; 가 지정된 오브젝트 정보 (이루어진 오브젝트 내용 뒤에 &lt;code&gt;%(objectsize)&lt;/code&gt; 개행 바이트 단위).</target>
        </trans-unit>
        <trans-unit id="c868d58aa72d9bce1efba44bdbf844fae93d14ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--batch&lt;/code&gt; or &lt;code&gt;--batch-check&lt;/code&gt; is given, &lt;code&gt;cat-file&lt;/code&gt; will read objects from stdin, one per line, and print information about them. By default, the whole line is considered as an object, as if it were fed to &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse[1]&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;--batch&lt;/code&gt; 또는 &lt;code&gt;--batch-check&lt;/code&gt; 주어진다, &lt;code&gt;cat-file&lt;/code&gt; 표준 입력에서 오브젝트, 한 줄에 하나씩 읽고, 그들에 대한 정보를 인쇄합니다. 기본적으로 전체 줄은 마치 마치 &lt;a href=&quot;git-rev-parse&quot;&gt;git-rev-parse [1]에&lt;/a&gt; 공급 된 것처럼 객체로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="2b49579ab9891477a433f3c4a7d881c054bf542d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--branch&lt;/code&gt; is given, a series of header lines are printed with information about the current branch.</source>
          <target state="translated">경우 &lt;code&gt;--branch&lt;/code&gt; 이 주어집니다, 헤더 행의 일련의 현재 지점에 대한 정보가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="92890e94239521769988796133cb653b32aed431" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--cached&lt;/code&gt; is specified, it allows you to ask:</source>
          <target state="translated">경우 &lt;code&gt;--cached&lt;/code&gt; 가 지정되어, 당신이 질문 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cdc2c32e44cf382458d3759532d549dfd10bb0ff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--cached&lt;/code&gt; is specified, this command will instead print the SHA-1 recorded in the superproject for each submodule.</source>
          <target state="translated">경우 &lt;code&gt;--cached&lt;/code&gt; 가 지정되어,이 명령 대신 SHA-1 각 서브 모듈에 대한 superproject에 기록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="efe0936134ada9314d303de0a6d1675a3e22d7d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--force&lt;/code&gt; is specified, the submodule will be checked out (using &lt;code&gt;git checkout --force&lt;/code&gt;), even if the commit specified in the index of the containing repository already matches the commit checked out in the submodule.</source>
          <target state="translated">경우 &lt;code&gt;--force&lt;/code&gt; 가 지정되어, 서브 모듈은 (사용하여 확인됩니다 &lt;code&gt;git checkout --force&lt;/code&gt; 이미이 서브 모듈에서 체크 아웃 커밋 일치가 포함 된 저장소의 인덱스에 지정된 커밋하더라도).</target>
        </trans-unit>
        <trans-unit id="b5618fac3945aa3c15ec4d6ac940c3fc88cab042" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--force&lt;/code&gt; is specified, the submodule&amp;rsquo;s working tree will be removed even if it contains local modifications.</source>
          <target state="translated">경우 &lt;code&gt;--force&lt;/code&gt; 가 지정되면, 서브 모듈의 작업 나무는 로컬 수정 사항을 포함 된 경우에도 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="95d47c3b72d050d56bd3bb3556c38937bb16f1f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--group&lt;/code&gt; is specified multiple times, commits are counted under each value (but again, only once per unique value in that commit). For example, &lt;code&gt;git shortlog --group=author --group=trailer:co-authored-by&lt;/code&gt; counts both authors and co-authors.</source>
          <target state="translated">&lt;code&gt;--group&lt;/code&gt; 이 여러 번 지정된 경우 커밋은 각 값 아래에서 계산됩니다 (하지만 해당 커밋의 고유 값당 한 번만). 예를 들어 &lt;code&gt;git shortlog --group=author --group=trailer:co-authored-by&lt;/code&gt; 는 작성자와 공동 작성자를 모두 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f2db79d4530ac333b81dd59fc3c02ca024b34411" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--index&lt;/code&gt; is not specified, then the submodule commits in the patch are ignored and only the absence or presence of the corresponding subdirectory is checked and (if possible) updated.</source>
          <target state="translated">경우 &lt;code&gt;--index&lt;/code&gt; 가 지정되어 있지 않은 경우, 패치의 서브 모듈 커밋은 무시됩니다 만 부재 또는 해당 하위 디렉토리의 존재를 확인하고 (가능한 경우)가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="ab41ddd9d49ddaff35bf4379642301cf2f1054d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--index&lt;/code&gt; is specified (explicitly or implicitly), then the submodule commits must match the index exactly for the patch to apply. If any of the submodules are checked-out, then these check-outs are completely ignored, i.e., they are not required to be up to date or clean and they are not updated.</source>
          <target state="translated">경우 &lt;code&gt;--index&lt;/code&gt; 이 (명시 적 또는 암시 적으로) 지정 패치를 적용하기 위해, 다음 서브 모듈 커밋은 정확히 인덱스와 일치해야합니다. 하위 모듈이 체크 아웃되면이 체크 아웃이 완전히 무시됩니다. 즉, 최신 상태이거나 정리할 필요가 없으며 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7cd61ae0dde953250d385a6012605e922398ec2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--list&lt;/code&gt; is given, or if there are no non-option arguments, existing branches are listed; the current branch will be highlighted in green and marked with an asterisk. Any branches checked out in linked worktrees will be highlighted in cyan and marked with a plus sign. Option &lt;code&gt;-r&lt;/code&gt; causes the remote-tracking branches to be listed, and option &lt;code&gt;-a&lt;/code&gt; shows both local and remote branches.</source>
          <target state="translated">경우 &lt;code&gt;--list&lt;/code&gt; 이 주어진다에는 옵션이 아닌 인수가없는 경우, 또는 기존의 지점이 나열됩니다; 현재 분기는 녹색으로 강조 표시되고 별표로 표시됩니다. 연결된 작업 트리에서 체크 아웃 된 분기는 시안 색으로 강조 표시되고 더하기 부호가 표시됩니다. &lt;code&gt;-r&lt;/code&gt; 옵션을 사용 하면 원격 추적 분기가 나열되고 &lt;code&gt;-a&lt;/code&gt; 옵션 은 로컬 및 원격 분기를 모두 표시합니다.</target>
        </trans-unit>
        <trans-unit id="45b84e8c64b1db8d6046842947d0384f2fee755b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--log&lt;/code&gt; is specified, a shortlog of the commits being merged will be appended to the specified message.</source>
          <target state="translated">경우 &lt;code&gt;--log&lt;/code&gt; 가 지정, 병합 될 커밋의 shortlog 지정된 메시지에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1772a311632ebe173773fb98d78cf3669fc056b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--max-commits=&amp;lt;M&amp;gt;&lt;/code&gt; is specified with &lt;code&gt;M&lt;/code&gt; a positive integer, and the new tip file would have more than &lt;code&gt;M&lt;/code&gt; commits, then instead merge the new tip with the previous tip.</source>
          <target state="translated">경우 &lt;code&gt;--max-commits=&amp;lt;M&amp;gt;&lt;/code&gt; 지정되어 &lt;code&gt;M&lt;/code&gt; 양의 정수를, 새로운 팁 파일보다 더 많은 것 &lt;code&gt;M&lt;/code&gt; 의 커밋하고 대신 이전 팁 새로운 팁을 병합합니다.</target>
        </trans-unit>
        <trans-unit id="f4eab33758877fd85cebec91765014b4b92dc48c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--recursive&lt;/code&gt; is specified, this command will recurse into nested submodules, and show their status as well.</source>
          <target state="translated">경우 &lt;code&gt;--recursive&lt;/code&gt; 가 지정되어,이 명령은 중첩 된 서브 모듈로 재귀 적, 자신의 상태를 표시뿐만 아니라 것입니다.</target>
        </trans-unit>
        <trans-unit id="776298c85f9bd8538095ba7ea6588e9b7e4a25e3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--recursive&lt;/code&gt; is specified, this command will recurse into the registered submodules, and sync any nested submodules within.</source>
          <target state="translated">경우 &lt;code&gt;--recursive&lt;/code&gt; 이 지정되면,이 명령은 등록 된 서브 모듈로 재귀 및 중첩 내에 서브 모듈을 동기화한다.</target>
        </trans-unit>
        <trans-unit id="1ddca2ea8ce5da739445e37cd4a4048560236396" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--recursive&lt;/code&gt; is specified, this command will recurse into the registered submodules, and update any nested submodules within.</source>
          <target state="translated">경우 &lt;code&gt;--recursive&lt;/code&gt; 가 지정되어,이 명령은 등록 된 서브 모듈로 재귀 적 및 내에서 중첩 된 서브 모듈을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="ccfd5529f6d32ddb692a0a0edb24e2ebd0aeb784" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--size-multiple=&amp;lt;X&amp;gt;&lt;/code&gt; is not specified, let &lt;code&gt;X&lt;/code&gt; equal 2. If the new tip file would have &lt;code&gt;N&lt;/code&gt; commits and the previous tip has &lt;code&gt;M&lt;/code&gt; commits and &lt;code&gt;X&lt;/code&gt; times &lt;code&gt;N&lt;/code&gt; is greater than &lt;code&gt;M&lt;/code&gt;, instead merge the two files into a single file.</source>
          <target state="translated">경우 &lt;code&gt;--size-multiple=&amp;lt;X&amp;gt;&lt;/code&gt; 를 지정하지 않은하자 &lt;code&gt;X&lt;/code&gt; 는 새로운 팁 파일이있을 것입니다 경우 2. 동일 &lt;code&gt;N&lt;/code&gt; 의 커밋을 이전 끝이 &lt;code&gt;M&lt;/code&gt; 의 커밋 및 &lt;code&gt;X&lt;/code&gt; 의 시간 &lt;code&gt;N&lt;/code&gt; 이 보다 큰 &lt;code&gt;M&lt;/code&gt; 을 대신에 두 파일을 병합, 단일 파일.</target>
        </trans-unit>
        <trans-unit id="769d8817aa727ff62e14daf04f7de44e2d479abb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--split=no-merge&lt;/code&gt; is specified, a merge is never performed, and the remaining options are ignored. &lt;code&gt;--split=replace&lt;/code&gt; overwrites the existing chain with a new one. A bare &lt;code&gt;--split&lt;/code&gt; defers to the remaining options. (Note that merging a chain of commit graphs replaces the existing chain with a length-1 chain where the first and only incremental holds the entire graph).</source>
          <target state="translated">경우 &lt;code&gt;--split=no-merge&lt;/code&gt; 지정되지 않은, 병합이 수행되지 않습니다, 나머지 옵션은 무시됩니다. &lt;code&gt;--split=replace&lt;/code&gt; 는 기존 체인을 새 체인으로 덮어 씁니다. 베어 &lt;code&gt;--split&lt;/code&gt; 은 나머지 옵션을 따릅니다 . (커밋 그래프 체인을 병합하면 기존 체인이 길이 1 체인으로 대체됩니다. 여기서 첫 번째이자 증분 만 전체 그래프를 유지합니다).</target>
        </trans-unit>
        <trans-unit id="c75734f6686dc8bf756f12580f08ccb633b88773" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--stateless-rpc&lt;/code&gt; is specified together with this option then the list of refs must be in packet format (pkt-line). Each ref must be in a separate packet, and the list must end with a flush packet.</source>
          <target state="translated">경우 &lt;code&gt;--stateless-rpc&lt;/code&gt; 이 옵션과 함께 지정 후 심판의리스트는 패킷 형식 (PKT-라인)에 있어야합니다. 각 심판은 별도의 패킷에 있어야하며 목록은 플러시 패킷으로 끝나야합니다.</target>
        </trans-unit>
        <trans-unit id="d363c35441978c92ee5ead459023dfd1f9ed35c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--verbose&lt;/code&gt; is specified, the output is a series of lines of the form:</source>
          <target state="translated">경우 &lt;code&gt;--verbose&lt;/code&gt; 를 지정, 출력 형태의 일련의 선이다 :</target>
        </trans-unit>
        <trans-unit id="b441bd31aac4d2437fef46e0587314ace0da5e13" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-B&lt;/code&gt; is given, &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; is created if it doesn&amp;rsquo;t exist; otherwise, it is reset. This is the transactional equivalent of</source>
          <target state="translated">경우 &lt;code&gt;-B&lt;/code&gt; 가 주어진다, &lt;code&gt;&amp;lt;new_branch&amp;gt;&lt;/code&gt; 가 존재하지 않는 경우에 작성됩니다; 그렇지 않으면 재설정됩니다. 이것은 거래에 해당하는</target>
        </trans-unit>
        <trans-unit id="b749f9938784db5272ac47989617994390a95806" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-N&lt;/code&gt; is specified, removed paths are marked as intent-to-add (see &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;code&gt;-N&lt;/code&gt; 가 지정된 제거 경로를 목적으로 표시된 대 추가 (참조 &lt;a href=&quot;git-add&quot;&gt;자식 합산을 [1]&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0d1031ba738c1e4895034c45a671bdfc4feb8ed4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-e&lt;/code&gt; is specified, no output, unless the &amp;lt;object&amp;gt; is malformed.</source>
          <target state="translated">경우 &lt;code&gt;-e&lt;/code&gt; 가 지정되어, 더 출력은 &amp;lt;object&amp;gt;하지 않는 한, 부정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b39ecbbcbddbe2e5db1df9079f165a4a73917d14" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; or &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; is given and &lt;code&gt;-a&lt;/code&gt;, &lt;code&gt;-s&lt;/code&gt;, and &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; are absent, &lt;code&gt;-a&lt;/code&gt; is implied.</source>
          <target state="translated">경우 &lt;code&gt;-m &amp;lt;msg&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;-F &amp;lt;file&amp;gt;&lt;/code&gt; 부여하고 &lt;code&gt;-a&lt;/code&gt; 는 , &lt;code&gt;-s&lt;/code&gt; , 및 &lt;code&gt;-u &amp;lt;keyid&amp;gt;&lt;/code&gt; 결석, &lt;code&gt;-a&lt;/code&gt; 는 암시한다.</target>
        </trans-unit>
        <trans-unit id="c5ab965e580c550a049049c227e584f98537d08f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-m&lt;/code&gt; is specified, &lt;code&gt;git read-tree&lt;/code&gt; can perform 3 kinds of merge, a single tree merge if only 1 tree is given, a fast-forward merge with 2 trees, or a 3-way merge if 3 or more trees are provided.</source>
          <target state="translated">경우 &lt;code&gt;-m&lt;/code&gt; 이 지정되어, &lt;code&gt;git read-tree&lt;/code&gt; 단지 1 트리가 주어진다면 3 개 이상의 나무가 제공하는 경우 2 나무, 또는 3 방향 병합으로, 병합의 빨리 감기 병합을 단일 트리 병합을 3 종류 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f1322547f9936fb21adaa0927130bdfd594f82e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;--non-matching&lt;/code&gt; are specified, non-matching pathnames will also be output, in which case all fields in each output record except for &amp;lt;pathname&amp;gt; will be empty. This can be useful when running non-interactively, so that files can be incrementally streamed to STDIN of a long-running check-ignore process, and for each of these files, STDOUT will indicate whether that file matched a pattern or not. (Without this option, it would be impossible to tell whether the absence of output for a given file meant that it didn&amp;rsquo;t match any pattern, or that the output hadn&amp;rsquo;t been generated yet.)</source>
          <target state="translated">경우 &lt;code&gt;-n&lt;/code&gt; 또는 &lt;code&gt;--non-matching&lt;/code&gt; 지정되어, 일치하지 않는 경로 이름은 &amp;lt;경로&amp;gt;을 제외한 각 출력 레코드의 모든 필드가 비어있는 경우에 출력 될 것이다. 이는 비 대화식으로 실행할 때 유용하므로 파일을 장기 실행 검사 무시 프로세스의 STDIN으로 증분 스트리밍 할 수 있으며 이러한 각 파일에 대해 STDOUT은 해당 파일이 패턴과 일치하는지 여부를 표시합니다. (이 옵션이 없으면 주어진 파일에 대한 출력이 없다는 것이 어떤 패턴과도 일치하지 않거나 출력이 아직 생성되지 않았 음을 의미하는지 여부를 알 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="bedfa7472b5b880935d5dde5c2d6b7df2dd5534d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-o&lt;/code&gt; is specified, output files are created in &amp;lt;dir&amp;gt;. Otherwise they are created in the current working directory. The default path can be set with the &lt;code&gt;format.outputDirectory&lt;/code&gt; configuration option. The &lt;code&gt;-o&lt;/code&gt; option takes precedence over &lt;code&gt;format.outputDirectory&lt;/code&gt;. To store patches in the current working directory even when &lt;code&gt;format.outputDirectory&lt;/code&gt; points elsewhere, use &lt;code&gt;-o .&lt;/code&gt;. All directory components will be created.</source>
          <target state="translated">경우 &lt;code&gt;-o&lt;/code&gt; 가 지정, 출력 파일은 &amp;lt;디렉토리&amp;gt;에 작성됩니다. 그렇지 않으면 현재 작업 디렉토리에 작성됩니다. 기본 경로는 &lt;code&gt;format.outputDirectory&lt;/code&gt; 구성 옵션 으로 설정할 수 있습니다 . &lt;code&gt;-o&lt;/code&gt; 옵션보다 우선합니다 &lt;code&gt;format.outputDirectory&lt;/code&gt; . &lt;code&gt;format.outputDirectory&lt;/code&gt; 가 다른 곳을 가리켜 도 현재 작업 디렉토리에 패치를 저장하려면 &lt;code&gt;-o .&lt;/code&gt; 사용하십시오 . . 모든 디렉토리 구성 요소가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="bbc0034ea645324d7719670d640dccda6b5513e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-p&lt;/code&gt; is specified, the contents of &amp;lt;object&amp;gt; are pretty-printed.</source>
          <target state="translated">경우 &lt;code&gt;-p&lt;/code&gt; 가 지정되어, &amp;lt;object&amp;gt;의 내용은 꽤-인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="49cafb1f81b012710180fa1719861bbc315bac4f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-s&lt;/code&gt; is specified, the size of the &amp;lt;object&amp;gt; in bytes.</source>
          <target state="translated">경우 &lt;code&gt;-s&lt;/code&gt; 가 지정된 바이트의 &amp;lt;object&amp;gt;의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="859275c6340e08abbb3b87a577dd1f75bdf60296" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-t&lt;/code&gt; is specified, one of the &amp;lt;type&amp;gt;.</source>
          <target state="translated">경우 &lt;code&gt;-t&lt;/code&gt; 가 지정되면, &amp;lt;유형&amp;gt; 중 하나.</target>
        </trans-unit>
        <trans-unit id="77cb52b6f5e5f8b68fe5657e97a4dba5f22808fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-v&lt;/code&gt; is specified, the script reports what it is doing.</source>
          <target state="translated">경우 &lt;code&gt;-v&lt;/code&gt; 가 지정되는 스크립트는 무엇을하고 있는지보고합니다.</target>
        </trans-unit>
        <trans-unit id="f7c94cac86b7d031a538f6e54d51ce5da54af947" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-z&lt;/code&gt; is specified, the pathnames in the output are delimited by the null character; if &lt;code&gt;--verbose&lt;/code&gt; is also specified then null characters are also used instead of colons and hard tabs:</source>
          <target state="translated">경우 &lt;code&gt;-z&lt;/code&gt; 가 지정되면, 출력 경로 이름은 널 문자에 의해 분리되며 경우 &lt;code&gt;--verbose&lt;/code&gt; 은 또한 다음 지정된 널 문자 대신 콜론 하드 탭으로 사용된다 :</target>
        </trans-unit>
        <trans-unit id="54b1b9cb08e8013285c455de408ae4d63672e927" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GIT_TRACE2_BRIEF&lt;/code&gt; or &lt;code&gt;trace2.normalBrief&lt;/code&gt; is true, the &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;filename&lt;/code&gt;, and &lt;code&gt;line&lt;/code&gt; fields are omitted.</source>
          <target state="translated">경우 &lt;code&gt;GIT_TRACE2_BRIEF&lt;/code&gt; 또는 &lt;code&gt;trace2.normalBrief&lt;/code&gt; 이 사실은 &lt;code&gt;time&lt;/code&gt; , &lt;code&gt;filename&lt;/code&gt; 및 &lt;code&gt;line&lt;/code&gt; 필드는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="2e9a7edfc47ae5456f77e7777204d6f377e2ee4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GIT_TRACE2_EVENT_BRIEF&lt;/code&gt; or &lt;code&gt;trace2.eventBrief&lt;/code&gt; is true, the &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;line&lt;/code&gt; fields are omitted from all events and the &lt;code&gt;time&lt;/code&gt; field is only present on the &quot;start&quot; and &quot;atexit&quot; events.</source>
          <target state="translated">경우 &lt;code&gt;GIT_TRACE2_EVENT_BRIEF&lt;/code&gt; 또는 &lt;code&gt;trace2.eventBrief&lt;/code&gt; 이 사실의 &lt;code&gt;file&lt;/code&gt; 및 &lt;code&gt;line&lt;/code&gt; 필드는 모든 이벤트에서 생략되고, &lt;code&gt;time&lt;/code&gt; 필드는 &quot;시작&quot;과 &quot;atexit&quot;이벤트에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="1f02cbb9b13595b2ae6e45bc6f6b5fd9cfaab0a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;GIT_TRACE2_PERF_BRIEF&lt;/code&gt; or &lt;code&gt;trace2.perfBrief&lt;/code&gt; is true, the &lt;code&gt;time&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, and &lt;code&gt;line&lt;/code&gt; fields are omitted.</source>
          <target state="translated">경우 &lt;code&gt;GIT_TRACE2_PERF_BRIEF&lt;/code&gt; 또는 &lt;code&gt;trace2.perfBrief&lt;/code&gt; 이 사실은 &lt;code&gt;time&lt;/code&gt; , &lt;code&gt;file&lt;/code&gt; 및 &lt;code&gt;line&lt;/code&gt; 필드는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="ac54e4f3ca84b268e2b102a57942d2590e1ed97e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; configuration for the current branch &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; exists, that is the name of the branch at the remote site that is merged.</source>
          <target state="translated">만약 &lt;code&gt;branch.&amp;lt;name&amp;gt;.merge&lt;/code&gt; 구성 현재 지점에 대한 &lt;code&gt;&amp;lt;name&amp;gt;&lt;/code&gt; 존재 병합 원격 사이트의 분기의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0bbbd298acfcfe77553aeabe5dcce9895508b92f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;core.ignoreCase=true&lt;/code&gt;, then the pattern-matching algorithm will use a case-insensitive check. This corrects for case mismatched filenames in the &lt;code&gt;git sparse-checkout set&lt;/code&gt; command to reflect the expected cone in the working directory.</source>
          <target state="translated">경우 &lt;code&gt;core.ignoreCase=true&lt;/code&gt; 다음 패턴 매칭 알고리즘은 대소 문자 구별 검사를 사용한다. 이것은 &lt;code&gt;git sparse-checkout set&lt;/code&gt; 명령 에서 파일 이름이 일치하지 않는 경우 작업 디렉토리의 예상 원뿔을 반영하도록 수정합니다.</target>
        </trans-unit>
        <trans-unit id="e0b5d0106d1c8675cc37e497ff6608e05f8526d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;core.safecrlf&lt;/code&gt; is set to &quot;true&quot; or &quot;warn&quot;, Git verifies if the conversion is reversible for the current setting of &lt;code&gt;core.autocrlf&lt;/code&gt;. For &quot;true&quot;, Git rejects irreversible conversions; for &quot;warn&quot;, Git only prints a warning but accepts an irreversible conversion. The safety triggers to prevent such a conversion done to the files in the work tree, but there are a few exceptions. Even though&amp;hellip;​</source>
          <target state="translated">경우 &lt;code&gt;core.safecrlf&lt;/code&gt; 은 &quot;true&quot;또는 &quot;경고&quot;힘내를 검증로 설정되어 변환의 현재 설정 가역 경우 &lt;code&gt;core.autocrlf&lt;/code&gt; . &quot;true&quot;의 경우 Git은 되돌릴 수없는 변환을 거부합니다. &quot;경고&quot;의 경우, Git은 경고 만 인쇄하지만 되돌릴 수없는 변환을 허용합니다. 안전은 작업 트리의 파일에 대한 이러한 변환을 방지하기 위해 트리거되지만 몇 가지 예외가 있습니다. 그래도&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="a8fd82d7f01c8cd14090b39826adb8859d4c03b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;core.sparseCheckoutCone=true&lt;/code&gt;, then Git will parse the sparse-checkout file expecting patterns of these types. Git will warn if the patterns do not match. If the patterns do match the expected format, then Git will use faster hash- based algorithms to compute inclusion in the sparse-checkout.</source>
          <target state="translated">경우 &lt;code&gt;core.sparseCheckoutCone=true&lt;/code&gt; 다음 힘내는 이러한 유형의 패턴을 기대 스파 스 - 체크 아웃 파일을 구문 분석합니다. 패턴이 일치하지 않으면 Git이 경고합니다. 패턴이 예상 형식과 일치하면 Git은 빠른 해시 기반 알고리즘을 사용하여 희소 체크 아웃에 포함되는 것을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="9f2eb1f9e30347412b91990fde6d0d3118015f0c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;credential.helper&lt;/code&gt; is configured to the empty string, this resets the helper list to empty (so you may override a helper set by a lower-priority config file by configuring the empty-string helper, followed by whatever set of helpers you would like).</source>
          <target state="translated">경우 &lt;code&gt;credential.helper&lt;/code&gt; 가 빈 문자열로 구성되어 당신이 빈 문자열 도우미를 구성하여 낮은 우선 순위의 설정 파일에 의한 도우미 세트를 오버라이드 (override) 할 수 있도록,이 재설정은 도우미 목록 (비우, 당신이하고 싶은 헬퍼의 어떤 설정 한 다음 ).</target>
        </trans-unit>
        <trans-unit id="6f6bc24ce4d9cb03fd023baafceb347acba1bf38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt; and related commands will not treat the initial commit as a big creation event. Any root commits in &lt;code&gt;git log -p&lt;/code&gt; output would be shown without a diff attached. The default is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; 인 경우 &lt;code&gt;git log&lt;/code&gt; 및 관련 명령은 초기 커밋을 큰 생성 이벤트로 취급하지 않습니다. &lt;code&gt;git log -p&lt;/code&gt; 출력의 모든 루트 커밋은 diff가 첨부되지 않은 상태로 표시됩니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="176a2b5b60655848aad57cb4f6f5216b8fca3bab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;git merge-index&lt;/code&gt; is called with multiple &amp;lt;file&amp;gt;s (or -a) then it processes them in turn only stopping if merge returns a non-zero exit code.</source>
          <target state="translated">경우 &lt;code&gt;git merge-index&lt;/code&gt; 여러 &amp;lt;파일&amp;gt;로 호출들 (또는 -a) 다음은 병합 반환하는 경우 0이 아닌 종료 코드를 중지 차례로을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="806256aa8b91febcc951ef689b4cdbc521c56b19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;git svn&lt;/code&gt; is configured to fetch branches (and --follow-branches is in effect), it sometimes creates multiple Git branches for one SVN branch, where the additional branches have names of the form &lt;code&gt;branchname@nnn&lt;/code&gt; (with nnn an SVN revision number). These additional branches are created if &lt;code&gt;git svn&lt;/code&gt; cannot find a parent commit for the first commit in an SVN branch, to connect the branch to the history of the other branches.</source>
          <target state="translated">경우 &lt;code&gt;git svn&lt;/code&gt; 지점 (및 --follow-가지 효과입니다) 가져하도록 구성되어, 때로는 추가 가지 양식의 이름이 하나 개 SVN 지점, 여러 힘내 분기를 생성 &lt;code&gt;branchname@nnn&lt;/code&gt; (AN SVN 개정 번호 NNN으로 ). 이 추가 브랜치는 &lt;code&gt;git svn&lt;/code&gt; 이 SVN 브랜치에서 첫 번째 커밋에 대한 상위 커밋을 찾을 수없는 경우 브랜치를 다른 브랜치의 히스토리에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="ea83fb8f1cd42b6f4ec377884889f8ee539b7922" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;our&lt;/code&gt; version introduces whitespace changes but &lt;code&gt;their&lt;/code&gt; version includes a substantial change, &lt;code&gt;their&lt;/code&gt; version is used;</source>
          <target state="translated">경우 &lt;code&gt;our&lt;/code&gt; 변화하지만 공백 버전을 소개합니다 &lt;code&gt;their&lt;/code&gt; 버전은 상당한 변화를 포함, &lt;code&gt;their&lt;/code&gt; 버전이 사용됩니다;</target>
        </trans-unit>
        <trans-unit id="a540055d45818789fbb8422bbf0d3790f08d9718" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;repack.packKeptObjects&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then any pack-files with an associated &lt;code&gt;.keep&lt;/code&gt; file will not be selected for the batch to repack.</source>
          <target state="translated">만약 &lt;code&gt;repack.packKeptObjects&lt;/code&gt; 이 있다 &lt;code&gt;false&lt;/code&gt; , 다음 관련있는 모든 팩 - 파일 &lt;code&gt;.keep&lt;/code&gt; 파일은 재 포장시에 일괄 선택되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a3c5f8b5c3f8823d3bb0bf75c68202ef91e0068" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;status.submoduleSummary&lt;/code&gt; is set to a non zero number or true (identical to -1 or an unlimited number), the submodule summary will be enabled for the long format and a summary of commits for modified submodules will be shown (see --summary-limit option of &lt;a href=&quot;git-submodule&quot;&gt;git-submodule[1]&lt;/a&gt;). Please note that the summary output from the status command will be suppressed for all submodules when &lt;code&gt;diff.ignoreSubmodules&lt;/code&gt; is set to &lt;code&gt;all&lt;/code&gt; or only for those submodules where &lt;code&gt;submodule.&amp;lt;name&amp;gt;.ignore=all&lt;/code&gt;. To also view the summary for ignored submodules you can either use the --ignore-submodules=dirty command line option or the &lt;code&gt;git submodule summary&lt;/code&gt; command, which shows a similar output but does not honor these settings.</source>
          <target state="translated">경우 &lt;code&gt;status.submoduleSummary&lt;/code&gt; 가 0이 아닌 숫자 또는 참 (동일 -1 또는 무제한)로 설정되고, 서브 모듈 요약 --summary 볼 (도시한다 긴 포맷과 수정 된 서브 모듈에 대한 커밋 요약 활성화 될 &lt;a href=&quot;git-submodule&quot;&gt;git-submodule [1]&lt;/a&gt; 의 -limit 옵션 ). &lt;code&gt;diff.ignoreSubmodules&lt;/code&gt; 가 &lt;code&gt;submodule.&amp;lt;name&amp;gt;.ignore=all&lt;/code&gt; 인 서브 모듈에 대해 &lt;code&gt;all&lt;/code&gt; 또는 only로 설정 되면 status 명령의 요약 출력이 모든 서브 모듈에 대해 억제 됩니다 . 무시 된 하위 모듈에 대한 요약을 보려면 --ignore-submodules = dirty 명령 행 옵션 또는 &lt;code&gt;git submodule summary&lt;/code&gt; 명령은 유사한 출력을 표시하지만 이러한 설정을 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e9c3270ca55bc57874ba3c8e582e2598d79892a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;subsystem&lt;/code&gt; is rebased against &lt;code&gt;master&lt;/code&gt;, the following happens:</source>
          <target state="translated">경우 &lt;code&gt;subsystem&lt;/code&gt; 에 대해으로 업데이트되어 &lt;code&gt;master&lt;/code&gt; , 다음과 같은 상황이 발생합니다</target>
        </trans-unit>
        <trans-unit id="601fb7e577607a9227812e9cbf0586e6f099c5c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;their&lt;/code&gt; version only introduces whitespace changes to a line, &lt;code&gt;our&lt;/code&gt; version is used;</source>
          <target state="translated">만약 &lt;code&gt;their&lt;/code&gt; 라인으로 변경 공백 버전 만 소개하고는, &lt;code&gt;our&lt;/code&gt; 버전이 사용됩니다;</target>
        </trans-unit>
        <trans-unit id="8afd53e5e6b34e88bd67e48774d4e9aa34d681c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt; and related commands will act as if the &lt;code&gt;--show-signature&lt;/code&gt; option was passed to them.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;git log&lt;/code&gt; 및 관련 명령은 &lt;code&gt;--show-signature&lt;/code&gt; 옵션이 전달 된 것처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="30fb3a857bee5620305914164cd0d4800cd1bf39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;git log&lt;/code&gt; will act as if the &lt;code&gt;--follow&lt;/code&gt; option was used when a single &amp;lt;path&amp;gt; is given. This has the same limitations as &lt;code&gt;--follow&lt;/code&gt;, i.e. it cannot be used to follow multiple files and does not work well on non-linear history.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;git log&lt;/code&gt; 는 단일 &amp;lt;path&amp;gt;가 제공 될 때 &lt;code&gt;--follow&lt;/code&gt; 옵션이 사용 된 것처럼 작동합니다 . 이것은 &lt;code&gt;--follow&lt;/code&gt; 와 같은 제한 사항이 있습니다. 즉, 여러 파일을 따라가는 데 사용할 수 없으며 비선형 히스토리에서는 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ee512d5daa33e9512f53b0ef8141d045d9eb4b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, indicate that the caller wants hash algorithm information to be passed back from the remote. This mode is used when fetching refs.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 호출자가 해시 알고리즘 정보를 다시 원격에서 전달하고자하는 것을 나타냅니다. 이 모드는 참조를 가져올 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e427e8f5bde6693ff553f72c72fbaf5c9a84e60f" translate="yes" xml:space="preserve">
          <source>If Alice wants to visualize what Bob did since their histories forked she can issue the following command:</source>
          <target state="translated">Alice가 Bob이 기록한 이후 Bob이 수행 한 작업을 시각화하려면 다음 명령을 발행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38d81a70b720705355c01f2f151a0b608b67e1f5" translate="yes" xml:space="preserve">
          <source>If Bob later decides to work from a different host, he can still perform clones and pulls using the ssh protocol:</source>
          <target state="translated">Bob이 나중에 다른 호스트에서 작업하기로 결정한 경우에도 여전히 ssh 프로토콜을 사용하여 복제 및 풀을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="906533644a5e321915983ba584ed131ee5f02be3" translate="yes" xml:space="preserve">
          <source>If X is found to be &quot;bad&quot;, then we know that its descendants are all &quot;bad&quot;, so we want to say that:</source>
          <target state="translated">X가 &quot;나쁜&quot;것으로 판명되면, 우리는 그 자손이 모두 &quot;나쁜&quot;것이므로 다음과 같이 말하고 싶습니다 :</target>
        </trans-unit>
        <trans-unit id="585173cb924da5e21521ae8038b0882b2bd9054d" translate="yes" xml:space="preserve">
          <source>If X is found to be &quot;good&quot;, then we know that its ancestors are all &quot;good&quot;, so we want to say that:</source>
          <target state="translated">X가 &quot;좋은&quot;것으로 판명되면 우리는 그 조상이 모두 &quot;좋은&quot;것을 알기 때문에 다음과 같이 말하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="5b8abb6b4933866023868019ddfccc59a8fddfdf" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; is given, it is used as a shell wildcard to restrict the output to matching branches. If multiple patterns are given, a branch is shown if it matches any of the patterns.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 주어진다이를 매칭 지점에 대한 출력을 제한하는 쉘 와일드 카드로서 이용된다. 여러 패턴이 제공되면 패턴과 일치하면 분기가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9af8e725fef48828fa7bc334de43f0ec2851ec0b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;merge&lt;/code&gt; command fails for any reason other than merge conflicts (i.e. when the merge operation did not even start), it is rescheduled immediately.</source>
          <target state="translated">경우 &lt;code&gt;merge&lt;/code&gt; 명령 병합 충돌 (즉, 병합 작업도 시작하지 않은 경우) 이외의 이유로 실패, 그것은 즉시 재조정된다.</target>
        </trans-unit>
        <trans-unit id="78142494afa000f59dc94a96d37bd84306c42e5e" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;no-interactive-login&lt;/code&gt; command exists, then it is run and the interactive shell is aborted.</source>
          <target state="translated">경우 &lt;code&gt;no-interactive-login&lt;/code&gt; 명령이 존재, 그것은 실행되고 대화 형 쉘이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="7f80f5447bc118a0311c9425234560dac2c0a613" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;pattern&lt;/code&gt; is given, only refs matching the given shell glob are shown. If the pattern does not contain a globbing character (&lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or &lt;code&gt;[&lt;/code&gt;), it is turned into a prefix match by appending &lt;code&gt;/*&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;pattern&lt;/code&gt; 부여하고, 지정된 셀 글롭 일치 심판 만이 도시되어있다. 패턴에 글 로빙 문자 ( &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;[&lt;/code&gt; ) 가 포함되어 있지 않으면 &lt;code&gt;/*&lt;/code&gt; 를 추가하여 접두사 일치로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="744bace39aac155f24f5426e32b134c34f641c3b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;~/git-shell-commands&lt;/code&gt; directory is present, &lt;code&gt;git shell&lt;/code&gt; can also be run interactively (with no arguments). If a &lt;code&gt;help&lt;/code&gt; command is present in the &lt;code&gt;git-shell-commands&lt;/code&gt; directory, it is run to provide the user with an overview of allowed actions. Then a &quot;git&amp;gt; &quot; prompt is presented at which one can enter any of the commands from the &lt;code&gt;git-shell-commands&lt;/code&gt; directory, or &lt;code&gt;exit&lt;/code&gt; to close the connection.</source>
          <target state="translated">경우 &lt;code&gt;~/git-shell-commands&lt;/code&gt; 디렉토리가 존재, &lt;code&gt;git shell&lt;/code&gt; 또한 (인수 없음) 대화 형으로 실행할 수 있습니다. &lt;code&gt;git-shell-commands&lt;/code&gt; 디렉토리 에 &lt;code&gt;help&lt;/code&gt; 명령이 있으면이 명령이 실행되어 사용자에게 허용 된 작업에 대한 개요를 제공합니다. 그런 다음 &quot;git&amp;gt;&quot;프롬프트가 표시되어 &lt;code&gt;git-shell-commands&lt;/code&gt; 디렉토리 에서 명령을 입력 하거나 &lt;code&gt;exit&lt;/code&gt; 하여 연결을 닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa403bcc24255cf8941b29ab4148b7eee12a6185" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;~/git-shell-commands&lt;/code&gt; directory is present, &lt;code&gt;git shell&lt;/code&gt; will also handle other, custom commands by running &quot;&lt;code&gt;git-shell-commands/&amp;lt;command&amp;gt; &amp;lt;arguments&amp;gt;&lt;/code&gt;&quot; from the user&amp;rsquo;s home directory.</source>
          <target state="translated">경우 &lt;code&gt;~/git-shell-commands&lt;/code&gt; 디렉토리가 존재, &lt;code&gt;git shell&lt;/code&gt; 또한 &quot;실행하여 다른 사용자 정의 명령을 처리 할 &lt;code&gt;git-shell-commands/&amp;lt;command&amp;gt; &amp;lt;arguments&amp;gt;&lt;/code&gt; 사용자의 홈 디렉토리에서&quot;.</target>
        </trans-unit>
        <trans-unit id="106b7929c0261fff657b2746b76dd80d35492e74" translate="yes" xml:space="preserve">
          <source>If a Git client that does not support the &lt;code&gt;working-tree-encoding&lt;/code&gt; attribute adds a new file &lt;code&gt;bar.ps1&lt;/code&gt;, then &lt;code&gt;bar.ps1&lt;/code&gt; will be stored &quot;as-is&quot; internally (in this example probably as UTF-16). A client with &lt;code&gt;working-tree-encoding&lt;/code&gt; support will interpret the internal contents as UTF-8 and try to convert it to UTF-16 on checkout. That operation will fail and cause an error.</source>
          <target state="translated">지원하지 않는 힘내 클라이언트 경우 &lt;code&gt;working-tree-encoding&lt;/code&gt; 속성이 새 파일 추가 &lt;code&gt;bar.ps1&lt;/code&gt; 을 다음 &lt;code&gt;bar.ps1&lt;/code&gt; 은 (아마도 UTF-16이 예에서) 내부적으로 &quot;있는 그대로&quot;저장됩니다. &lt;code&gt;working-tree-encoding&lt;/code&gt; 지원 하는 클라이언트 는 내부 내용을 UTF-8로 해석하여 체크 아웃시 UTF-16으로 변환하려고합니다. 해당 작업이 실패하고 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="84278502dbc74a9c4cc8dd831a2c5f189f159ac0" translate="yes" xml:space="preserve">
          <source>If a Git repository includes branches &lt;code&gt;refs/remotes/origin/p4&lt;/code&gt;, these will be fetched and consulted first during a &lt;code&gt;git p4 sync&lt;/code&gt;. Since importing directly from p4 is considerably slower than pulling changes from a Git remote, this can be useful in a multi-developer environment.</source>
          <target state="translated">Git 저장소에 분기 &lt;code&gt;refs/remotes/origin/p4&lt;/code&gt; 가 포함 된 경우 &lt;code&gt;git p4 sync&lt;/code&gt; 중에 먼저 가져 와서 참조 합니다 . p4에서 직접 가져 오기는 Git 리모콘에서 변경 사항을 가져 오는 것보다 상당히 느리기 때문에 다중 개발자 환경에서 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af291be12b7b5a290c76485729b6b8f4918ca983" translate="yes" xml:space="preserve">
          <source>If a command, or a guide, is given, a manual page for that command or guide is brought up. The &lt;code&gt;man&lt;/code&gt; program is used by default for this purpose, but this can be overridden by other options or configuration variables.</source>
          <target state="translated">명령 또는 안내서가 제공되면 해당 명령 또는 안내서의 매뉴얼 페이지가 나타납니다. &lt;code&gt;man&lt;/code&gt; 프로그램은이 목적을 위해 기본적으로 사용됩니다 만, 다른 옵션이나 구성 변수에 의해 오버라이드 (override) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72743ffe0426b38cdd1755e732e28a11a9ff3a78" translate="yes" xml:space="preserve">
          <source>If a commit being cherry picked duplicates a commit already in the current history, it will become empty. By default these redundant commits cause &lt;code&gt;cherry-pick&lt;/code&gt; to stop so the user can examine the commit. This option overrides that behavior and creates an empty commit object. Implies &lt;code&gt;--allow-empty&lt;/code&gt;.</source>
          <target state="translated">체리 선택되는 커밋이 현재 히스토리에 이미있는 커밋을 복제하면 비어있게됩니다. 기본적으로 이러한 중복 커밋 은 사용자가 커밋을 검사 할 수 있도록 &lt;code&gt;cherry-pick&lt;/code&gt; 을 중지시킵니다. 이 옵션은 해당 동작을 재정의하고 빈 커밋 개체를 만듭니다. &lt;code&gt;--allow-empty&lt;/code&gt; 를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="4b42bbbaf339d6cf05d45edbdf2ada972df70aa1" translate="yes" xml:space="preserve">
          <source>If a diff tool is not specified, &lt;code&gt;git difftool&lt;/code&gt; will use the configuration variable &lt;code&gt;diff.tool&lt;/code&gt;. If the configuration variable &lt;code&gt;diff.tool&lt;/code&gt; is not set, &lt;code&gt;git difftool&lt;/code&gt; will pick a suitable default.</source>
          <target state="translated">diff 도구를 지정하지 않으면 &lt;code&gt;git difftool&lt;/code&gt; 은 구성 변수 &lt;code&gt;diff.tool&lt;/code&gt; 을 사용합니다 . 구성 변수 &lt;code&gt;diff.tool&lt;/code&gt; 이 설정되어 있지 않으면 &lt;code&gt;git difftool&lt;/code&gt; 이 적절한 기본값을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="a8ee98dcb134f1a2c8067ffe5665347c4c70f9e4" translate="yes" xml:space="preserve">
          <source>If a fatal error occurs, the program writes the error message to stderr and exits. The caller should expect that a suitable error message has been printed if the child closes the connection without completing a valid response for the current command.</source>
          <target state="translated">치명적인 오류가 발생하면 프로그램은 오류 메시지를 stderr에 기록하고 종료합니다. 호출자는 자식이 현재 명령에 대한 유효한 응답을 완료하지 않고 연결을 닫으면 적절한 오류 메시지가 인쇄 된 것으로 예상해야합니다.</target>
        </trans-unit>
        <trans-unit id="571d71cd29e09f41d5c855a2a419d634cc0eecce" translate="yes" xml:space="preserve">
          <source>If a filter &lt;code&gt;must&lt;/code&gt; succeed in order to make the stored contents usable, you can declare that the filter is &lt;code&gt;required&lt;/code&gt;, in the configuration:</source>
          <target state="translated">저장된 컨텐츠를 사용 가능하게하기 위해 필터 &lt;code&gt;must&lt;/code&gt; 성공 해야하는 경우 구성에서 필터가 &lt;code&gt;required&lt;/code&gt; 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22e70bb4ff6d3a3dd5464ffc106fa14107a4c8dc" translate="yes" xml:space="preserve">
          <source>If a git directory of a submodule is inside the submodule, move the git directory of the submodule into its superproject&amp;rsquo;s &lt;code&gt;$GIT_DIR/modules&lt;/code&gt; path and then connect the git directory and its working directory by setting the &lt;code&gt;core.worktree&lt;/code&gt; and adding a .git file pointing to the git directory embedded in the superprojects git directory.</source>
          <target state="translated">서브 모듈의 git 디렉토리가 서브 모듈 내부에 있다면, 서브 모듈의 git 디렉토리를 수퍼 프로젝트의 &lt;code&gt;$GIT_DIR/modules&lt;/code&gt; 경로로 옮긴 다음 &lt;code&gt;core.worktree&lt;/code&gt; 를 설정하고 .git 파일을 추가 하여 git 디렉토리와 작업 디렉토리를 연결하십시오 superprojects git 디렉토리에 포함 된 git 디렉토리에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="7b7f1fa74f78e5b674bbee244bef979691bc168d" translate="yes" xml:space="preserve">
          <source>If a helper advertises &lt;code&gt;connect&lt;/code&gt;, Git will use it if possible and fall back to another capability if the helper requests so when connecting (see the &lt;code&gt;connect&lt;/code&gt; command under COMMANDS). When choosing between &lt;code&gt;fetch&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt;, Git prefers &lt;code&gt;fetch&lt;/code&gt;. Other frontends may have some other order of preference.</source>
          <target state="translated">헬퍼가 &lt;code&gt;connect&lt;/code&gt; 를 광고 하면 Git은 가능하면이를 사용하고 헬퍼가 &lt;code&gt;connect&lt;/code&gt; 때 요청하면 다른 기능으로 폴백합니다 ( COMMANDS 의 connect 명령 참조 ). &lt;code&gt;fetch&lt;/code&gt; 와 &lt;code&gt;import&lt;/code&gt; 중에서 선택할 때 Git은 &lt;code&gt;fetch&lt;/code&gt; 선호합니다 . 다른 프론트 엔드에는 다른 우선 순위가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="148562d25b0603b8eee662bc94ef7dd269783449" translate="yes" xml:space="preserve">
          <source>If a helper advertises &lt;code&gt;connect&lt;/code&gt;, Git will use it if possible and fall back to another capability if the helper requests so when connecting (see the &lt;code&gt;connect&lt;/code&gt; command under COMMANDS). When choosing between &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt;, Git prefers &lt;code&gt;push&lt;/code&gt;. Other frontends may have some other order of preference.</source>
          <target state="translated">헬퍼가 &lt;code&gt;connect&lt;/code&gt; 를 광고 하면 Git은 가능하면이를 사용하고 헬퍼가 &lt;code&gt;connect&lt;/code&gt; 때 요청하면 다른 기능으로 폴백합니다 ( COMMANDS 의 connect 명령 참조 ). &lt;code&gt;push&lt;/code&gt; 와 &lt;code&gt;export&lt;/code&gt; 선택할 때 Git은 &lt;code&gt;push&lt;/code&gt; 선호합니다 . 다른 프론트 엔드에는 다른 우선 순위가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa7f2d8c2e0ee7753a285dedc0954f30b43daa88" translate="yes" xml:space="preserve">
          <source>If a helper fails to perform the requested operation or needs to notify the user of a potential issue, it may write to stderr.</source>
          <target state="translated">도우미가 요청 된 작업을 수행하지 못하거나 잠재적 인 문제를 사용자에게 알려야하는 경우 stderr에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2388ab5f8918a49ad2647c3d1835f78b1fd11f78" translate="yes" xml:space="preserve">
          <source>If a helper outputs a &lt;code&gt;quit&lt;/code&gt; attribute with a value of &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, no further helpers will be consulted, nor will the user be prompted (if no credential has been provided, the operation will then fail).</source>
          <target state="translated">도우미 가 &lt;code&gt;true&lt;/code&gt; 값으로 &lt;code&gt;quit&lt;/code&gt; 속성을 출력하는 경우 또는 &lt;code&gt;1&lt;/code&gt; 인 추가 도우미가 참조되지 않으며 사용자에게 메시지가 표시되지 않습니다 (인증 정보가 제공되지 않은 경우 작업이 실패 함).</target>
        </trans-unit>
        <trans-unit id="79eaf960175c04b54e3507607c968b768d5dc83c" translate="yes" xml:space="preserve">
          <source>If a helper receives any other operation, it should silently ignore the request. This leaves room for future operations to be added (older helpers will just ignore the new requests).</source>
          <target state="translated">도우미가 다른 작업을 받으면 요청을 자동으로 무시해야합니다. 이로 인해 향후 작업이 추가 될 여지가 남습니다 (이전 도우미는 새 요청을 무시합니다).</target>
        </trans-unit>
        <trans-unit id="3c8d1c4561ad329297670b7c11b5cea0c040fa93" translate="yes" xml:space="preserve">
          <source>If a line exists in both the source and destination, exists only once, and starts with this text, this algorithm attempts to prevent it from appearing as a deletion or addition in the output. It uses the &quot;patience diff&quot; algorithm internally.</source>
          <target state="translated">소스와 대상 모두에 한 줄이 존재하고 한 번만 존재하며이 텍스트로 시작하면이 알고리즘은 해당 줄이 출력에서 ​​삭제 또는 추가로 표시되지 않도록 시도합니다. 내부적으로 &quot;환자 차이&quot;알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="03800f18f812afe9c365f3cd10e3618c12ca274e" translate="yes" xml:space="preserve">
          <source>If a linked working tree is stored on a portable device or network share which is not always mounted, you can prevent its administrative files from being pruned by issuing the &lt;code&gt;git worktree lock&lt;/code&gt; command, optionally specifying &lt;code&gt;--reason&lt;/code&gt; to explain why the working tree is locked.</source>
          <target state="translated">링크 된 작업 나무는 항상 당신이 실행하여 정리되는 행정 파일을 방지 할 수 있습니다 장착되지 않은 휴대 장치 또는 네트워크 공유에 저장되어있는 경우 &lt;code&gt;git worktree lock&lt;/code&gt; 선택적으로 지정 명령을 &lt;code&gt;--reason&lt;/code&gt; 작업 트리가 잠겨있는 이유를 설명 .</target>
        </trans-unit>
        <trans-unit id="055300f804a90741eca19d86c43f3b133b4438b5" translate="yes" xml:space="preserve">
          <source>If a merge resolution program is not specified, &lt;code&gt;git mergetool&lt;/code&gt; will use the configuration variable &lt;code&gt;merge.tool&lt;/code&gt;. If the configuration variable &lt;code&gt;merge.tool&lt;/code&gt; is not set, &lt;code&gt;git mergetool&lt;/code&gt; will pick a suitable default.</source>
          <target state="translated">병합 해결 프로그램을 지정하지 않으면 &lt;code&gt;git mergetool&lt;/code&gt; 은 구성 변수 &lt;code&gt;merge.tool&lt;/code&gt; 을 사용합니다 . 구성 변수 &lt;code&gt;merge.tool&lt;/code&gt; 이 설정되어 있지 않으면 &lt;code&gt;git mergetool&lt;/code&gt; 이 적절한 기본값을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="1ea5bcda19ff920edc6797065824126354674b5b" translate="yes" xml:space="preserve">
          <source>If a name is specified on stdin that cannot be resolved to an object in the repository, then &lt;code&gt;cat-file&lt;/code&gt; will ignore any custom format and print:</source>
          <target state="translated">stdin에 이름을 지정하여 저장소의 오브젝트로 해석 할 수없는 경우 &lt;code&gt;cat-file&lt;/code&gt; 은 사용자 정의 형식을 무시하고 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b64d6e7bd6f81b6c41d97bf3465e33dac59a1923" translate="yes" xml:space="preserve">
          <source>If a name is specified that might refer to more than one object (an ambiguous short sha), then &lt;code&gt;cat-file&lt;/code&gt; will ignore any custom format and print:</source>
          <target state="translated">둘 이상의 객체 (모호한 짧은 음영)를 나타내는 이름이 지정된 경우 &lt;code&gt;cat-file&lt;/code&gt; 은 사용자 정의 형식을 무시하고 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="6e4b893bbe0d833def4e5b2195c3efca0abfc652" translate="yes" xml:space="preserve">
          <source>If a namespace is in use, the namespace prefix is stripped from each reference before it is matched against &lt;code&gt;transfer.hiderefs&lt;/code&gt; patterns. For example, if &lt;code&gt;refs/heads/master&lt;/code&gt; is specified in &lt;code&gt;transfer.hideRefs&lt;/code&gt; and the current namespace is &lt;code&gt;foo&lt;/code&gt;, then &lt;code&gt;refs/namespaces/foo/refs/heads/master&lt;/code&gt; is omitted from the advertisements but &lt;code&gt;refs/heads/master&lt;/code&gt; and &lt;code&gt;refs/namespaces/bar/refs/heads/master&lt;/code&gt; are still advertised as so-called &quot;have&quot; lines. In order to match refs before stripping, add a &lt;code&gt;^&lt;/code&gt; in front of the ref name. If you combine &lt;code&gt;!&lt;/code&gt; and &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt; must be specified first.</source>
          <target state="translated">네임 스페이스가 사용중인 경우 네임 스페이스 접두어는 &lt;code&gt;transfer.hiderefs&lt;/code&gt; 패턴 과 일치하기 전에 각 참조에서 제거됩니다 . 예를 들어, &lt;code&gt;refs/heads/master&lt;/code&gt; 가 &lt;code&gt;transfer.hideRefs&lt;/code&gt; 에 지정되고 현재 네임 스페이스가 &lt;code&gt;foo&lt;/code&gt; 인 경우 &lt;code&gt;refs/namespaces/foo/refs/heads/master&lt;/code&gt; 는 알림에서 생략되지만 &lt;code&gt;refs/heads/master&lt;/code&gt; 및 &lt;code&gt;refs/namespaces/bar/refs/heads/master&lt;/code&gt; 는 여전히 소위 &quot;have&quot;라인으로 알려집니다. 벗기기 전에 심판을 맞추 려면 심판 이름 앞에 &lt;code&gt;^&lt;/code&gt; 를 추가하십시오 . 당신이 결합하면 &lt;code&gt;!&lt;/code&gt; 및 &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;!&lt;/code&gt; 먼저 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="01a3979b0db1ea5ddb68d8d2296f1a14d4a19443" translate="yes" xml:space="preserve">
          <source>If a positive depth is requested, the server will compute the set of commits which are no deeper than the desired depth.</source>
          <target state="translated">양의 깊이가 요청되면 서버는 원하는 깊이보다 깊지 않은 커밋 세트를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="1af76a23a450746535be3f72c4b4bca12a2092d2" translate="yes" xml:space="preserve">
          <source>If a push would not result in a &lt;a href=&quot;#fast-forwards&quot;&gt;fast-forward&lt;/a&gt; of the remote branch, then it will fail with an error like:</source>
          <target state="translated">푸시 로 인해 원격 브랜치 가 &lt;a href=&quot;#fast-forwards&quot;&gt;빨리 전달&lt;/a&gt; 되지 않으면 다음과 같은 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="74746f4cd8d12a2fd7c6b3eb595d0f3e0b5c16c7" translate="yes" xml:space="preserve">
          <source>If a reflog entry&amp;rsquo;s predecessor is pruned, adjust its &quot;old&quot; SHA-1 to be equal to the &quot;new&quot; SHA-1 field of the entry that now precedes it.</source>
          <target state="translated">참조 로그 항목의 선행 작업이 제거되면 &quot;이전&quot;SHA-1이 이전 항목의 &quot;새&quot;SHA-1 필드와 같도록 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="335f210edb83cade21599987ff0ffeaab940885d" translate="yes" xml:space="preserve">
          <source>If a refspec is prefixed by &lt;code&gt;^&lt;/code&gt;, it will be interpreted as a negative refspec. Rather than specifying which refs to fetch or which local refs to update, such a refspec will instead specify refs to exclude. A ref will be considered to match if it matches at least one positive refspec, and does not match any negative refspec. Negative refspecs can be useful to restrict the scope of a pattern refspec so that it will not include specific refs. Negative refspecs can themselves be pattern refspecs. However, they may only contain a &amp;lt;src&amp;gt; and do not specify a &amp;lt;dst&amp;gt;. Fully spelled out hex object names are also not supported.</source>
          <target state="translated">refspec 앞에 &lt;code&gt;^&lt;/code&gt; 음의 refspec으로 해석됩니다. 가져올 참조 또는 업데이트 할 로컬 참조를 지정하는 대신 이러한 참조 사양은 제외 할 참조를 지정합니다. 참조가 하나 이상의 양의 참조 사양과 일치하고 어떤 음의 참조 사양과도 일치하지 않으면 일치하는 것으로 간주됩니다. 음의 참조 스펙은 특정 참조를 포함하지 않도록 패턴 참조 스펙의 범위를 제한하는 데 유용 할 수 있습니다. 음의 참조 사양은 그 자체로 패턴 참조 사양이 될 수 있습니다. 그러나 &amp;lt;src&amp;gt; 만 포함 할 수 있으며 &amp;lt;dst&amp;gt;를 지정하지 않습니다. 완전한 철자 16 진수 개체 이름도 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6545e25a03004b7b80ff7680d7d52c75ae528db2" translate="yes" xml:space="preserve">
          <source>If a specified file is in the index but is missing then it&amp;rsquo;s removed. Default behavior is to ignore removed file.</source>
          <target state="translated">지정된 파일이 색인에 있지만 누락 된 경우 제거됩니다. 기본 동작은 제거 된 파일을 무시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0b6d50904501e60c5730f3fc1689dbda57685832" translate="yes" xml:space="preserve">
          <source>If a specified file isn&amp;rsquo;t in the index already then it&amp;rsquo;s added. Default behaviour is to ignore new files.</source>
          <target state="translated">지정된 파일이 색인에 없으면 추가됩니다. 기본 동작은 새 파일을 무시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a14dea6ce44fe61b94cf6eca48f584619dca6981" translate="yes" xml:space="preserve">
          <source>If a subject is not found in the patch description the patch name is preserved as the 1 line subject in the Git description.</source>
          <target state="translated">패치 설명에서 제목을 찾을 수 없으면 패치 이름은 Git 설명에서 한 줄 제목으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="511834d1553ad3d02aefac42a3d932c821a68c9a" translate="yes" xml:space="preserve">
          <source>If a version-1 repository specifies any &lt;code&gt;extensions.*&lt;/code&gt; keys that the running git has not implemented, the operation MUST NOT proceed. Similarly, if the value of any known key is not understood by the implementation, the operation MUST NOT proceed.</source>
          <target state="translated">버전 1 리포지토리 가 실행중인 git이 구현하지 않은 &lt;code&gt;extensions.*&lt;/code&gt; 키를 지정 하면 작업을 진행해서는 안됩니다. 마찬가지로, 알려진 키의 값을 구현에서 이해하지 못하면 작업을 진행해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7fc57bcdf92fac8f6a715a452b985f9026a5a582" translate="yes" xml:space="preserve">
          <source>If a whole directory is classified as &quot;other&quot;, show just its name (with a trailing slash) and not its whole contents.</source>
          <target state="translated">전체 디렉토리가 &quot;other&quot;로 분류 된 경우 전체 내용이 아닌 이름 (후행 슬래시 포함) 만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="9069929e0dad6127e4d7686101bafb1ad2a53dfd" translate="yes" xml:space="preserve">
          <source>If a working tree is deleted without using &lt;code&gt;git worktree remove&lt;/code&gt;, then its associated administrative files, which reside in the repository (see &quot;DETAILS&quot; below), will eventually be removed automatically (see &lt;code&gt;gc.worktreePruneExpire&lt;/code&gt; in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt;), or you can run &lt;code&gt;git worktree prune&lt;/code&gt; in the main or any linked working tree to clean up any stale administrative files.</source>
          <target state="translated">작업 트리를 사용하지 않고 삭제하면 &lt;code&gt;git worktree remove&lt;/code&gt; 다음 저장소에있는 관련 관리 파일은, 결국 자동으로 제거됩니다 (아래 &quot;세부 사항&quot;참조) (참조 &lt;code&gt;gc.worktreePruneExpire&lt;/code&gt; 을 에 &lt;a href=&quot;git-config&quot;&gt;자식-설정 [1]&lt;/a&gt; ), 또는 기본 또는 연결된 작업 트리에서 &lt;code&gt;git worktree prune&lt;/code&gt; 을 실행 하여 오래된 관리 파일을 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="601f99371e1781bbcc6e4fbcb70987193e9cb892" translate="yes" xml:space="preserve">
          <source>If a working tree is on a portable device or network share which is not always mounted, lock it to prevent its administrative files from being pruned automatically. This also prevents it from being moved or deleted. Optionally, specify a reason for the lock with &lt;code&gt;--reason&lt;/code&gt;.</source>
          <target state="translated">작업 트리가 항상 마운트되지 않은 휴대용 장치 또는 네트워크 공유에있는 경우 관리 파일이 자동으로 정리되지 않도록 잠그십시오. 또한 이동되거나 삭제되지 않습니다. 선택적으로 &lt;code&gt;--reason&lt;/code&gt; 을 사용하여 잠금 이유를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c89355d42dbc93622cf0025bcf122df76b472f1" translate="yes" xml:space="preserve">
          <source>If advertised, indicates that any number of server specific options can be included in a request. This is done by sending each option as a &quot;server-option=&amp;lt;option&amp;gt;&quot; capability line in the capability-list section of a request.</source>
          <target state="translated">보급 된 경우, 서버 특정 옵션을 요청에 포함 할 수 있음을 나타냅니다. 이는 요청의 기능 목록 섹션에서 각 옵션을 &quot;server-option = &amp;lt;option&amp;gt;&quot;기능 행으로 전송하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c768073bebd10b960d1a77545805ba6684f69c55" translate="yes" xml:space="preserve">
          <source>If after this parent rewriting, &lt;code&gt;C'&lt;/code&gt; is a root or merge commit (has zero or &amp;gt;1 parents), a boundary commit, or !TREESAME, it remains. Otherwise, it is replaced with its only parent.</source>
          <target state="translated">이 부모 재 작성 후에 &lt;code&gt;C'&lt;/code&gt; 가 루트 또는 병합 커밋 (0 또는&amp;gt; 1 부모가 있음), 경계 커밋 또는! TREESAME이면 그대로 유지됩니다. 그렇지 않으면 유일한 부모로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="331241d5d1136bad0fab6978a8eab7a815b255e9" translate="yes" xml:space="preserve">
          <source>If all &amp;lt;ref&amp;gt;s can be locked with matching &amp;lt;oldvalue&amp;gt;s simultaneously, all modifications are performed. Otherwise, no modifications are performed. Note that while each individual &amp;lt;ref&amp;gt; is updated or deleted atomically, a concurrent reader may still see a subset of the modifications.</source>
          <target state="translated">일치하는 &amp;lt;oldvalue&amp;gt;로 모든 &amp;lt;ref&amp;gt;를 동시에 잠글 수있는 경우 모든 수정이 수행됩니다. 그렇지 않으면 수정이 수행되지 않습니다. 각 개별 &amp;lt;ref&amp;gt;가 원자 적으로 업데이트되거나 삭제되는 동안 동시 판독기는 여전히 수정의 하위 집합을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2745e08ed788856c12f02ca7a5befc54f3c9443" translate="yes" xml:space="preserve">
          <source>If all named commits are already ancestors of &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;git merge&lt;/code&gt; will exit early with the message &quot;Already up to date.&quot;</source>
          <target state="translated">모든 이름 커밋의 조상이 이미있는 경우 &lt;code&gt;HEAD&lt;/code&gt; 가 , &lt;code&gt;git merge&lt;/code&gt; 초기 메시지와 함께 종료됩니다 &quot;이미 최신.&quot;</target>
        </trans-unit>
        <trans-unit id="cf6cb5a66ab4b3c3c33160d1bdddf3e27a51bd6e" translate="yes" xml:space="preserve">
          <source>If all you really want to do is to remove from the index the files that are no longer present in the working tree (perhaps because your working tree is dirty so that you cannot use &lt;code&gt;git commit -a&lt;/code&gt;), use the following command:</source>
          <target state="translated">작업 트리에 더 이상 존재하지 않는 파일을 인덱스에서 제거하는 것만 큼 원하는 경우 (아마도 작업 트리가 &lt;code&gt;git commit -a&lt;/code&gt; 사용할 수 없기 때문에 ) 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="232e0a33b39a8eedbea0de34207896fce9d5da1b" translate="yes" xml:space="preserve">
          <source>If an SVN revision has a property, &quot;svm:headrev&quot;, it is likely that the revision was created by SVN::Mirror (also used by SVK). The property contains a repository UUID and a revision. We want to make it look like we are mirroring the original URL, so introduce a helper function that returns the original identity URL and UUID, and use it when generating metadata in commit messages.</source>
          <target state="translated">SVN 개정판에 &quot;svm : headrev&quot;특성이있는 경우 SVN :: Mirror (SVK에서도 사용)에 의해 개정판이 작성되었을 수 있습니다. 이 특성에는 저장소 UUID 및 개정판이 포함되어 있습니다. 원래 URL을 미러링하는 것처럼 보이게 만들고자하므로 원래 ID URL과 UUID를 반환하고 커밋 메시지에서 메타 데이터를 생성 할 때 사용하는 도우미 함수를 소개합니다.</target>
        </trans-unit>
        <trans-unit id="8ec6058ea575ab09ff2743fac6f67664b17c975f" translate="yes" xml:space="preserve">
          <source>If an alias is given, git shows the definition of the alias on standard output. To get the manual page for the aliased command, use &lt;code&gt;git COMMAND --help&lt;/code&gt;.</source>
          <target state="translated">별명이 주어지면, git은 표준 출력에서 ​​별명의 정의를 보여줍니다. 별칭 명령의 매뉴얼 페이지를 얻으려면 &lt;code&gt;git COMMAND --help&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="06b64f77884080bf4b8a1b3580804b4fc90c62bc" translate="yes" xml:space="preserve">
          <source>If an exact match was not found, &lt;code&gt;git describe&lt;/code&gt; will walk back through the commit history to locate an ancestor commit which has been tagged. The ancestor&amp;rsquo;s tag will be output along with an abbreviation of the input commit-ish&amp;rsquo;s SHA-1. If &lt;code&gt;--first-parent&lt;/code&gt; was specified then the walk will only consider the first parent of each commit.</source>
          <target state="translated">정확히 일치하는 것을 찾을 수 없으면, &lt;code&gt;git describe&lt;/code&gt; 는 커밋 히스토리를 통해 태그 된 상위 커밋을 찾습니다. 조상의 태그는 입력 커밋의 SHA-1의 약어와 함께 출력됩니다. 경우 &lt;code&gt;--first-parent&lt;/code&gt; 지정된 후, 도보 각 커밋의 첫 번째 부모를 고려할 것입니다.</target>
        </trans-unit>
        <trans-unit id="98c6f5f40e2b8ae0667cb14d2e8af19ba85f9e07" translate="yes" xml:space="preserve">
          <source>If an existing replace ref for the same object exists, it will be overwritten (instead of failing).</source>
          <target state="translated">동일한 객체에 대한 기존 교체 참조가 있으면 실패 대신 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="046c10da2487af8c5911472dad4ec66653003b0a" translate="yes" xml:space="preserve">
          <source>If any &amp;lt;file&amp;gt; does not appear in the index, treat this as an error (return 1).</source>
          <target state="translated">&amp;lt;file&amp;gt;이 색인에 나타나지 않으면이를 오류로 간주하십시오 (반환 1).</target>
        </trans-unit>
        <trans-unit id="d5c329c54100c9f229f2bd1af9a36354df219a33" translate="yes" xml:space="preserve">
          <source>If any evaluation of &amp;lt;command&amp;gt; returns a non-zero exit status, the whole operation will be aborted.</source>
          <target state="translated">&amp;lt;command&amp;gt;에 대한 평가가 0이 아닌 종료 상태를 반환하면 전체 작업이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="939ada40ab0c594838b538aaf9b14ce39d17200d" translate="yes" xml:space="preserve">
          <source>If any file doesn&amp;rsquo;t begin with a From line, assume it is a single mail message instead of signaling error.</source>
          <target state="translated">From 줄로 시작하지 않는 파일이 있으면 신호 오류 대신 단일 메일 메시지라고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="824867a2502f9c0cf53ed6a13fd4b286bb82c4ed" translate="yes" xml:space="preserve">
          <source>If any files that should not be normalized show up in &lt;code&gt;git status&lt;/code&gt;, unset their &lt;code&gt;text&lt;/code&gt; attribute before running &lt;code&gt;git add -u&lt;/code&gt;.</source>
          <target state="translated">정규화하지 않아야하는 파일이 &lt;code&gt;git status&lt;/code&gt; 표시되면 &lt;code&gt;git add -u&lt;/code&gt; 를 실행하기 전에 해당 &lt;code&gt;text&lt;/code&gt; 속성을 설정 해제 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c34b6095a9c49861d2acc43610b57c3a4a36934" translate="yes" xml:space="preserve">
          <source>If any files were ever &quot;cvs import&quot;ed more than once (e.g., import of more than one vendor release) the HEAD contains the wrong content.</source>
          <target state="translated">파일이 두 번 이상 &quot;cvs import&quot;된 경우 (예 : 둘 이상의 공급 업체 릴리스 가져 오기) HEAD에 잘못된 내용이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a184d41ad4c8629ad4f2bce24803b0c9fa2c0bb" translate="yes" xml:space="preserve">
          <source>If any of the remote changes overlap with local uncommitted changes, the merge will be automatically canceled and the work tree untouched. It is generally best to get any local changes in working order before pulling or stash them away with &lt;a href=&quot;git-stash&quot;&gt;git-stash[1]&lt;/a&gt;.</source>
          <target state="translated">원격 변경 내용이 커밋되지 않은 로컬 변경 내용과 겹치면 병합이 자동으로 취소되고 작업 트리가 수정되지 않습니다. 일반적으로 &lt;a href=&quot;git-stash&quot;&gt;git-stash [1]을 사용&lt;/a&gt; 하여 변경하거나 가져 오기 전에 작업 순서에서 로컬 변경 사항을 얻는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="27aabdb37af0432fadcd5ffecc44449505cac9be" translate="yes" xml:space="preserve">
          <source>If any optional &lt;code&gt;&amp;lt;path&amp;gt;...&lt;/code&gt; arguments are given, only those paths are affected.</source>
          <target state="translated">선택적 &lt;code&gt;&amp;lt;path&amp;gt;...&lt;/code&gt; 인수가 제공되면 해당 경로 만 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="d20da8878e924b8ea99ba5928199985d6eb45c5b" translate="yes" xml:space="preserve">
          <source>If at least one of the specified mechanisms matches the ones advertised by the SMTP server and if it is supported by the utilized SASL library, the mechanism is used for authentication. If neither &lt;code&gt;sendemail.smtpAuth&lt;/code&gt; nor &lt;code&gt;--smtp-auth&lt;/code&gt; is specified, all mechanisms supported by the SASL library can be used. The special value &lt;code&gt;none&lt;/code&gt; maybe specified to completely disable authentication independently of &lt;code&gt;--smtp-user&lt;/code&gt;</source>
          <target state="translated">지정된 메커니즘 중 하나 이상이 SMTP 서버에 의해 보급 된 메커니즘과 일치하고 사용 된 SASL 라이브러리에서 지원되는 메커니즘과 일치하면이 메커니즘이 인증에 사용됩니다. 어느 경우 &lt;code&gt;sendemail.smtpAuth&lt;/code&gt; 도 &lt;code&gt;--smtp-auth&lt;/code&gt; 지정되면, SASL 라이브러리가 지원하는 모든 메커니즘을 사용할 수 있습니다. &lt;code&gt;--smtp-user&lt;/code&gt; 와 독립적으로 인증을 완전히 비활성화하기 위해 특별한 값을 지정 &lt;code&gt;none&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48ca5fe331a67872cf3424cd090943cee3b1214a" translate="yes" xml:space="preserve">
          <source>If config parameter &quot;core.logAllRefUpdates&quot; is true and the ref is one under &quot;refs/heads/&quot;, &quot;refs/remotes/&quot;, &quot;refs/notes/&quot;, or a pseudoref like HEAD or ORIG_HEAD; or the file &quot;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&quot; exists then &lt;code&gt;git update-ref&lt;/code&gt; will append a line to the log file &quot;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&quot; (dereferencing all symbolic refs before creating the log name) describing the change in ref value. Log lines are formatted as:</source>
          <target state="translated">구성 매개 변수 &quot;core.logAllRefUpdates&quot;가 true이고 참조가 &quot;refs / heads /&quot;, &quot;refs / remotes /&quot;, &quot;refs / notes /&quot;또는 HEAD 또는 ORIG_HEAD와 같은 의사 참조 인 경우; 또는 &quot;$ GIT_DIR / logs / &amp;lt;ref&amp;gt;&quot;파일이 존재하면 &lt;code&gt;git update-ref&lt;/code&gt; 는 로그 파일 &quot;$ GIT_DIR / logs / &amp;lt;ref&amp;gt;&quot;에 줄을 추가합니다 (로그 이름을 만들기 전에 모든 기호 참조 참조). 참조 값의 변경. 로그 행의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d66be204c5192d97175dc2e5a6cea91a845a9494" translate="yes" xml:space="preserve">
          <source>If config parameter &quot;core.logAllRefUpdates&quot; is true and the ref is one under &quot;refs/heads/&quot;, &quot;refs/remotes/&quot;, &quot;refs/notes/&quot;, or the symbolic ref HEAD; or the file &quot;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&quot; exists then &lt;code&gt;git update-ref&lt;/code&gt; will append a line to the log file &quot;$GIT_DIR/logs/&amp;lt;ref&amp;gt;&quot; (dereferencing all symbolic refs before creating the log name) describing the change in ref value. Log lines are formatted as:</source>
          <target state="translated">구성 매개 변수 &quot;core.logAllRefUpdates&quot;가 true이고 참조가 &quot;refs / heads /&quot;, &quot;refs / remotes /&quot;, &quot;refs / notes /&quot;또는 기호 참조 HEAD 중 하나 인 경우; 또는 &quot;$ GIT_DIR / logs / &amp;lt;ref&amp;gt;&quot;파일이 존재하면 &lt;code&gt;git update-ref&lt;/code&gt; 는 로그 파일 &quot;$ GIT_DIR / logs / &amp;lt;ref&amp;gt;&quot;(로그 이름을 만들기 전에 모든 기호 참조를 참조)에 줄을 추가합니다. 심판 가치의 변화. 로그 라인의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb79d7b0840991ebe429aab3a3410932b975f32c" translate="yes" xml:space="preserve">
          <source>If conflicts arise and a strategy for automatically resolving conflicting notes (see the &quot;NOTES MERGE STRATEGIES&quot; section) is not given, the &quot;manual&quot; resolver is used. This resolver checks out the conflicting notes in a special worktree (&lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt;), and instructs the user to manually resolve the conflicts there. When done, the user can either finalize the merge with &lt;code&gt;git notes merge --commit&lt;/code&gt;, or abort the merge with &lt;code&gt;git notes merge --abort&lt;/code&gt;.</source>
          <target state="translated">충돌이 발생하고 충돌 메모를 자동으로 해결하기위한 전략 ( &quot;노트 병합 전략&quot;섹션 참조)이 제공되지 않으면 &quot;수동&quot;리졸버가 사용됩니다. 이 리졸버는 특수 작업 트리 ( &lt;code&gt;.git/NOTES_MERGE_WORKTREE&lt;/code&gt; ) 에서 충돌하는 노트를 확인 하고 사용자에게 충돌을 수동으로 해결하도록 지시합니다. 완료되면 사용자는 &lt;code&gt;git notes merge --commit&lt;/code&gt; 으로 병합을 완료하거나 git notes merge --abort로 병합을 중단 &lt;code&gt;git notes merge --abort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a02a69db3092fb7486e9bff9ff76c98958fe4d57" translate="yes" xml:space="preserve">
          <source>If core.commitGraph is true, the commit-graph file will also be inspected using &lt;code&gt;git commit-graph verify&lt;/code&gt;. See &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph[1]&lt;/a&gt;.</source>
          <target state="translated">core.commitGraph가 true 인 경우 커밋 그래프 파일도 &lt;code&gt;git commit-graph verify&lt;/code&gt; 를 사용하여 검사됩니다 . &lt;a href=&quot;git-commit-graph&quot;&gt;git-commit-graph [1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8280fdd5ec3fb25317b497d70f747c3177f7ef0e" translate="yes" xml:space="preserve">
          <source>If disabled with &quot;--no-thread&quot;, those headers will not be added (unless specified with --in-reply-to). Default is the value of the &lt;code&gt;sendemail.thread&lt;/code&gt; configuration value; if that is unspecified, default to --thread.</source>
          <target state="translated">&quot;-스레드 없음&quot;으로 비활성화하면 해당 헤더가 추가되지 않습니다 (--in-reply-to로 지정되지 않은 경우). 기본값은 &lt;code&gt;sendemail.thread&lt;/code&gt; 구성 값입니다. 지정되지 않은 경우 기본값은 --thread입니다.</target>
        </trans-unit>
        <trans-unit id="f00c2d7bc0317e9cad287fad199ae73edff4a848" translate="yes" xml:space="preserve">
          <source>If either &amp;lt;upstream&amp;gt; or --root is given on the command line, then the default is &lt;code&gt;--no-fork-point&lt;/code&gt;, otherwise the default is &lt;code&gt;--fork-point&lt;/code&gt;.</source>
          <target state="translated">&amp;lt;upstream&amp;gt; 또는 --root가 명령 행에 제공되면 기본값은 &lt;code&gt;--no-fork-point&lt;/code&gt; 이고, 그렇지 않으면 기본값은 &lt;code&gt;--fork-point&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a4729a11522c55d49b0e7c329a8805975c4198d9" translate="yes" xml:space="preserve">
          <source>If either of these environment variables is set then &lt;code&gt;git fetch&lt;/code&gt; and &lt;code&gt;git push&lt;/code&gt; will use the specified command instead of &lt;code&gt;ssh&lt;/code&gt; when they need to connect to a remote system. The command-line parameters passed to the configured command are determined by the ssh variant. See &lt;code&gt;ssh.variant&lt;/code&gt; option in &lt;a href=&quot;git-config&quot;&gt;git-config[1]&lt;/a&gt; for details.</source>
          <target state="translated">이러한 환경 변수 중 하나가 설정되면 &lt;code&gt;git fetch&lt;/code&gt; 및 &lt;code&gt;git push&lt;/code&gt; 는 원격 시스템에 연결해야 할 때 &lt;code&gt;ssh&lt;/code&gt; 대신 지정된 명령 을 사용합니다. 구성된 명령에 전달 된 명령 줄 매개 변수는 ssh 변형에 의해 결정됩니다. 자세한 내용 은 &lt;a href=&quot;git-config&quot;&gt;git-config [1]의 &lt;/a&gt; &lt;code&gt;ssh.variant&lt;/code&gt; 옵션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="3669ee4e6fd1ff3473f59b85f73b98bc8093a5f0" translate="yes" xml:space="preserve">
          <source>If enabled the helper should automatically fetch annotated tag objects if the object the tag points at was transferred during the fetch command. If the tag is not fetched by the helper a second fetch command will usually be sent to ask for the tag specifically. Some helpers may be able to use this option to avoid a second network connection.</source>
          <target state="translated">활성화 된 경우, 페치 명령 동안 태그가 가리키는 오브젝트가 전송 된 경우 헬퍼는 주석이 달린 태그 오브젝트를 자동으로 페치해야합니다. 도우미가 태그를 가져 오지 않으면 일반적으로 두 번째 가져 오기 명령을 보내 태그를 구체적으로 요청합니다. 일부 도우미는이 옵션을 사용하여 두 번째 네트워크 연결을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27acfa87cdb69a824b9bae48206b42168ffde848" translate="yes" xml:space="preserve">
          <source>If enabled, &lt;code&gt;git p4 submit&lt;/code&gt; will attempt to cleanup RCS keywords ($Header$, etc). These would otherwise cause merge conflicts and prevent the submit going ahead. This option should be considered experimental at present.</source>
          <target state="translated">활성화되면 &lt;code&gt;git p4 submit&lt;/code&gt; 은 RCS 키워드 정리 ($ Header $ 등)를 시도합니다. 그렇지 않으면 병합 충돌이 발생하여 제출이 진행되지 않습니다. 이 옵션은 현재 실험적인 것으로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="551059a87916480f640c4e8b1f0ae5467d5d2b16" translate="yes" xml:space="preserve">
          <source>If everything fails, or if no viewer is configured, the viewer specified in the &lt;code&gt;GIT_MAN_VIEWER&lt;/code&gt; environment variable will be tried. If that fails too, the &lt;code&gt;man&lt;/code&gt; program will be tried anyway.</source>
          <target state="translated">모든 것이 실패하거나 뷰어가 구성되지 않은 경우 &lt;code&gt;GIT_MAN_VIEWER&lt;/code&gt; 환경 변수에 지정된 뷰어 가 시도됩니다. 이것도 실패하면 &lt;code&gt;man&lt;/code&gt; 프로그램은 어쨌든 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="dc951917b8a4344a8f095e91594828b8eb0d132d" translate="yes" xml:space="preserve">
          <source>If explicit refspecs were given on the command line of &lt;code&gt;git pull&lt;/code&gt;, they are all merged.</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 의 명령 행에 명시 적 참조 스펙이 제공된 경우 모두 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="9f9421c37df0f080e8411a466937f35ec8c1d1a5" translate="yes" xml:space="preserve">
          <source>If false, symbolic links are checked out as small plain files that contain the link text. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt; and &lt;a href=&quot;git-add&quot;&gt;git-add[1]&lt;/a&gt; will not change the recorded type to regular file. Useful on filesystems like FAT that do not support symbolic links.</source>
          <target state="translated">False 인 경우 심볼릭 링크는 링크 텍스트가 포함 된 작은 일반 파일로 체크 아웃됩니다. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]&lt;/a&gt; 및 &lt;a href=&quot;git-add&quot;&gt;git-add [1]&lt;/a&gt; 은 기록 된 유형을 일반 파일로 변경하지 않습니다. 기호 링크를 지원하지 않는 FAT와 같은 파일 시스템에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8463a48927d35802080dff1be147345270adfa9a" translate="yes" xml:space="preserve">
          <source>If false, the ctime differences between the index and the working tree are ignored; useful when the inode change time is regularly modified by something outside Git (file system crawlers and some backup systems). See &lt;a href=&quot;git-update-index&quot;&gt;git-update-index[1]&lt;/a&gt;. True by default.</source>
          <target state="translated">False 인 경우 인덱스와 작업 트리 간의 ctime 차이는 무시됩니다. inode 변경 시간이 Git 외부의 파일 시스템 (파일 시스템 크롤러 및 일부 백업 시스템)에 의해 정기적으로 수정 될 때 유용합니다. &lt;a href=&quot;git-update-index&quot;&gt;git-update-index [1]를&lt;/a&gt; 참조하십시오 . 기본적으로 true입니다.</target>
        </trans-unit>
        <trans-unit id="c3b2c82ffccecb89175e5c1911567eb5a6cff2f5" translate="yes" xml:space="preserve">
          <source>If fast-import is supplied invalid input it will terminate with a non-zero exit status and create a crash report in the top level of the Git repository it was importing into. Crash reports contain a snapshot of the internal fast-import state as well as the most recent commands that lead up to the crash.</source>
          <target state="translated">빠른 가져 오기에 유효하지 않은 입력이 제공되면 0이 아닌 종료 상태로 종료되고 가져 오는 Git 저장소의 최상위 레벨에 충돌 보고서가 작성됩니다. 충돌 보고서에는 내부 빠른 가져 오기 상태의 스냅 샷과 충돌을 일으키는 최신 명령이 포함됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
