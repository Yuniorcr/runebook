<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rxjs">
    <body>
      <group id="rxjs">
        <trans-unit id="392ce755360743798adc6f37abf60a01a85dac13" translate="yes" xml:space="preserve">
          <source>&quot;Complete&quot; notification: does not send a value.</source>
          <target state="translated">&quot;완료&quot;알림 : 값을 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c81d9f638ee0e1bf38fde281d7d0722e5ae02890" translate="yes" xml:space="preserve">
          <source>&quot;Creation&quot; operators The following operators have been moved from &lt;code&gt;rxjs/operators&lt;/code&gt; to &lt;code&gt;rxjs&lt;/code&gt;, and their usage has changed:</source>
          <target state="translated">&quot;창조&quot;연산자 다음 연산자에서 이동 된 &lt;code&gt;rxjs/operators&lt;/code&gt; 에 &lt;code&gt;rxjs&lt;/code&gt; 및 사용법이 변경되었습니다 :</target>
        </trans-unit>
        <trans-unit id="3e7d16b53c2fad1237d23976a605c79f1b13451d" translate="yes" xml:space="preserve">
          <source>&quot;Error&quot; notification: sends a JavaScript Error or exception.</source>
          <target state="translated">&quot;오류&quot;알림 : JavaScript 오류 또는 예외를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="61ed1f5cc7d257c5a6fb114343a8ac81acd81a74" translate="yes" xml:space="preserve">
          <source>&quot;Marble Tests&quot; are tests that use a specialized VirtualScheduler called the &lt;code&gt;TestScheduler&lt;/code&gt;. They enable us to test asynchronous operations in a synchronous and dependable manner. The &quot;marble notation&quot; is something that's been adapted from many teachings and documents by people such as &lt;a href=&quot;https://twitter.com/jhusain&quot;&gt;@jhusain&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/headinthebox&quot;&gt;@headinthebox&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/mattpodwysocki&quot;&gt;@mattpodwysocki&lt;/a&gt; and &lt;a href=&quot;https://twitter.com/andrestaltz&quot;&gt;@andrestaltz&lt;/a&gt;. In fact, Andr&amp;eacute; Staltz first recommended this as a DSL for creating unit tests, and it has since been altered and adopted.</source>
          <target state="translated">&quot; &lt;code&gt;TestScheduler&lt;/code&gt; 테스트&quot;는 TestScheduler 라는 특수 VirtualScheduler를 사용하는 테스트입니다 . 이를 통해 비동기 작업을 동기적이고 신뢰할 수있는 방식으로 테스트 할 수 있습니다. &quot;대리석 표기법&quot;은 &lt;a href=&quot;https://twitter.com/jhusain&quot;&gt;@jhusain&lt;/a&gt; , &lt;a href=&quot;https://twitter.com/headinthebox&quot;&gt;@headinthebox&lt;/a&gt; , &lt;a href=&quot;https://twitter.com/mattpodwysocki&quot;&gt;@mattpodwysocki&lt;/a&gt; 및 &lt;a href=&quot;https://twitter.com/andrestaltz&quot;&gt;@andrestaltz&lt;/a&gt; 와 같은 사람들이 많은 가르침과 문서에서 수정 한 것입니다 . 실제로 Andr&amp;eacute; Staltz는이를 단위 테스트 작성을 위해 DSL로 권장했으며 이후 변경 및 채택되었습니다.</target>
        </trans-unit>
        <trans-unit id="42a2c7dc9cd6a678723aae38fa9f03c7b8bf1f15" translate="yes" xml:space="preserve">
          <source>&quot;Next&quot; notification: sends a value such as a Number, a String, an Object, etc.</source>
          <target state="translated">&quot;다음&quot;알림 : 숫자, 문자열, 개체 등과 같은 값을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="cd753dbdc17c8e8263d11f9f804dab829f01e73e" translate="yes" xml:space="preserve">
          <source>&quot;Next&quot; notifications are the most important and most common type: they represent actual data being delivered to an subscriber. &quot;Error&quot; and &quot;Complete&quot; notifications may happen only once during the Observable Execution, and there can only be either one of them.</source>
          <target state="translated">&quot;다음&quot;알림은 가장 중요하고 가장 일반적인 유형입니다. 구독자에게 전달되는 실제 데이터를 나타냅니다. &quot;오류&quot;및 &quot;완료&quot;알림은 Observable Execution 중에 한 번만 발생할 수 있으며 그 중 하나만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="346adb0427f466457992cab12b66149214b60148" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2015&amp;ndash;2018 Google, Inc., Netflix, Inc., Microsoft Corp. and contributors.</source>
          <target state="translated">&amp;copy; 2015&amp;ndash;2018 Google, Inc., Netflix, Inc., Microsoft Corp. 및 기고자.</target>
        </trans-unit>
        <trans-unit id="ec83739778c86aaa8e3c14cb62c33740056380aa" translate="yes" xml:space="preserve">
          <source>(The &lt;code&gt;pipe()&lt;/code&gt; function is analogous to, but not the same thing as, the &lt;code&gt;.pipe()&lt;/code&gt; method on an Observable.)</source>
          <target state="translated">( &lt;code&gt;pipe()&lt;/code&gt; 함수는 Observable 의 &lt;code&gt;.pipe()&lt;/code&gt; 메소드 와 유사하지만 동일하지는 않습니다 .)</target>
        </trans-unit>
        <trans-unit id="11fc77211983736b813c658ece601fdcc5bca5b3" translate="yes" xml:space="preserve">
          <source>// Logs: // 0 // 1 // 2 // &quot;Yo!&quot;</source>
          <target state="translated">// 로그 : // 0 // 1 // 2 // &quot;Yo!&quot;</target>
        </trans-unit>
        <trans-unit id="413662e05fbda8a75422816345471abce134f0b2" translate="yes" xml:space="preserve">
          <source>// Logs: // 0 // 1000 // 2000 // &quot;Yo!&quot;</source>
          <target state="translated">// 로그 : // 0 // 1000 // 2000 // &quot;Yo!&quot;</target>
        </trans-unit>
        <trans-unit id="4cf7b3b0689dc3d62e361b359129706be46007b9" translate="yes" xml:space="preserve">
          <source>// Logs: // 0 // 1000 // 2000 // 3000 // ...and never stops.</source>
          <target state="translated">// 로그 : // 0 // 1000 // 2000 // 3000 // ... 정지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4932860fd63504b051ce368dbc339d987387b63a" translate="yes" xml:space="preserve">
          <source>1 frame is 10 virtual milliseconds by default. i.e. &lt;code&gt;TestScheduler.frameTimeFactor = 10&lt;/code&gt;</source>
          <target state="translated">기본적으로 1 프레임은 10 밀리 초입니다. 즉, &lt;code&gt;TestScheduler.frameTimeFactor = 10&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d65e71651123d00f13f6a1dd9134124f96f272f3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../api/operators/exhaust&quot;&gt;&lt;code&gt;exhaust()&lt;/code&gt;&lt;/a&gt; &amp;mdash; subscribes to the first inner Observable when it arrives, and emits each value as it arrives, discarding all newly arriving inner Observables until that first one completes, then waits for the next inner Observable.</source>
          <target state="translated">&lt;a href=&quot;../api/operators/exhaust&quot;&gt; &lt;code&gt;exhaust()&lt;/code&gt; &lt;/a&gt; &amp;mdash; 도착할 때 첫 번째 내부 Observable을 구독하고, 도착할 때마다 각 값을 방출하여 새로 도착한 모든 내부 Observable을 완료 한 후 다음 내부 Observable을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="7a7ea42cc6cca0849dbb1c78069f7e16487eadce" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../api/operators/mergeall&quot;&gt;&lt;code&gt;mergeAll()&lt;/code&gt;&lt;/a&gt; &amp;mdash; subscribes to each inner Observable as it arrives, then emits each value as it arrives</source>
          <target state="translated">&lt;a href=&quot;../api/operators/mergeall&quot;&gt; &lt;code&gt;mergeAll()&lt;/code&gt; &lt;/a&gt; &amp;mdash; 도착할 때 각 내부 Observable을 구독 한 다음 도착할 때마다 각 값을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="00d7dfe90d22907f84e2b9aa6d174c7093188de9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../api/operators/switchall&quot;&gt;&lt;code&gt;switchAll()&lt;/code&gt;&lt;/a&gt; &amp;mdash; subscribes to the first inner Observable when it arrives, and emits each value as it arrives, but when the next inner Observable arrives, unsubscribes to the previous one, and subscribes to the new one.</source>
          <target state="translated">&lt;a href=&quot;../api/operators/switchall&quot;&gt; &lt;code&gt;switchAll()&lt;/code&gt; &lt;/a&gt; &amp;mdash; 도착할 때 첫 번째 내부 Observable을 구독하고 도착할 때 각 값을 내 보냅니다 . 그러나 다음 내부 Observable이 도착하면 이전 값을 구독 해제하고 새 것을 관찰합니다.</target>
        </trans-unit>
        <trans-unit id="6a5210f0bf7d5b359aadf70cf0e45a3b962eba14" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../index/class/subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt; that communicates with a server via WebSocket</source>
          <target state="translated">&lt;a href=&quot;../index/class/subject&quot;&gt; &lt;code&gt;Subject&lt;/code&gt; &lt;/a&gt;WebSocket을 통해 서버와 통신하는 주제</target>
        </trans-unit>
        <trans-unit id="058d6b50d45cc928153edc804bde7133ba593471" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;!&quot;&lt;/code&gt; unsubscription point: shows the point in time at which a subscription is unsubscribed.</source>
          <target state="translated">&lt;code&gt;&quot;!&quot;&lt;/code&gt; 구독 취소 : 구독이 구독 취소 된 시점을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="81a3ce5520c5667d66bf855b46c44589a826a0d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;#&quot;&lt;/code&gt; error: An error terminating the observable. This is the observable producer signaling &lt;code&gt;error()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;#&quot;&lt;/code&gt; 오류 : 관찰 가능 항목을 종료하는 중 오류가 발생했습니다. 이것은 관찰 가능한 생산자 신호 &lt;code&gt;error()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="107cfd640387781b75d0bb619e0d899ed5b34314" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;()&quot;&lt;/code&gt; sync groupings: When multiple events need to be in the same frame synchronously, parentheses are used to group those events. You can group nexted values, a completion or an error in this manner. The position of the initial &lt;code&gt;(&lt;/code&gt; determines the time at which its values are emitted.</source>
          <target state="translated">&lt;code&gt;&quot;()&quot;&lt;/code&gt; 동기화 그룹화 : 여러 이벤트가 동일한 프레임에 동 기적으로 있어야하는 경우 괄호를 사용하여 해당 이벤트를 그룹화하십시오. 이러한 방식으로 다음 값, 완료 또는 오류를 그룹화 할 수 있습니다. 이니셜의 위치 &lt;code&gt;(&lt;/code&gt; 값이 방출되는 시간을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="064762d55524c322feeaa267de2dba55cae25836" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;-&quot;&lt;/code&gt; time: 10 &quot;frames&quot; of the passage.</source>
          <target state="translated">&lt;code&gt;&quot;-&quot;&lt;/code&gt; 시간 : 10 개의 &quot;프레임&quot;구절.</target>
        </trans-unit>
        <trans-unit id="8e080bce20eb3fc6c4946b152fe200b8a369f991" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;-&quot;&lt;/code&gt; time: 10 &quot;frames&quot; of time passage.</source>
          <target state="translated">&lt;code&gt;&quot;-&quot;&lt;/code&gt; 시간 : 시간 통과의 10 &quot;프레임&quot;.</target>
        </trans-unit>
        <trans-unit id="48a3e4768e9a2314ab6c955d210fda5eee9e16ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;^&quot;&lt;/code&gt; subscription point: (hot observables only) shows the point at which the tested observables will be subscribed to the hot observable. This is the &quot;zero frame&quot; for that observable, every frame before the &lt;code&gt;^&lt;/code&gt; will be negative.</source>
          <target state="translated">&lt;code&gt;&quot;^&quot;&lt;/code&gt; 구독 지점 : (핫 옵저버 블 만 해당)는 테스트 된 옵저버 블이 핫 옵저버 블을 구독 할 지점을 나타냅니다. 이것은 관찰 가능 항목에 대한 &quot;제로 프레임&quot;이며 &lt;code&gt;^&lt;/code&gt; 앞의 모든 프레임 은 음수입니다.</target>
        </trans-unit>
        <trans-unit id="00e0999da09e1b7ac615beac5e032458d7eaeb8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;^&quot;&lt;/code&gt; subscription point: shows the point in time at which a subscription happen.</source>
          <target state="translated">&lt;code&gt;&quot;^&quot;&lt;/code&gt; 구독 지점 : 구독이 발생하는 시점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="42596687beb2a6b5b9594c84cc181a1c419f8a34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;a&quot;&lt;/code&gt; any character: All other characters represent a value being emitted by the producer signaling &lt;code&gt;next()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;a&quot;&lt;/code&gt; 모든 문자 : 다른 모든 문자는 생산자가 신호를 보내는 값을 나타냅니다 &lt;code&gt;next()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0f4e7bf26a0b7700ddaf9f8256bbac86b3539a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;|&quot;&lt;/code&gt; complete: The successful completion of an observable. This is the observable producer signaling &lt;code&gt;complete()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;|&quot;&lt;/code&gt; 완료 : 관찰 가능 항목을 성공적으로 완료했습니다. 이것은 관찰 가능한 프로듀서 신호입니다. &lt;code&gt;complete()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="264671634e07abdf4534265024ab55c7443d1523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#&lt;/code&gt;: Equivalent to &lt;code&gt;Observable.throw()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; : &lt;code&gt;Observable.throw()&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="826146bd4f6b3958dfa2716d8a103525afcd4809" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#&lt;/code&gt;: Equivalent to &lt;code&gt;throwError()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt; : &lt;code&gt;throwError()&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="63834177a0d274bef046c96bd46b7d79ffa05fb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;' '&lt;/code&gt; whitespace: horizontal whitespace is ignored, and can be used to help vertically align multiple marble diagrams.</source>
          <target state="translated">&lt;code&gt;' '&lt;/code&gt; 공백 : 수평 공백은 무시되며 여러 개의 대리석 다이어그램을 수직으로 정렬하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6954e21ca9dfaa3f0526fc31dd9bb1ea892618cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'!'&lt;/code&gt; unsubscription point: shows the point in time at which a subscription is unsubscribed.</source>
          <target state="translated">&lt;code&gt;'!'&lt;/code&gt; 구독 취소 : 구독이 구독 취소 된 시점을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="494cfb16dcf327f243341a9829050b41fdaaafa7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'#'&lt;/code&gt; error: An error terminating the observable. This is the observable producer signaling &lt;code&gt;error()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'#'&lt;/code&gt; 오류 : 관찰 가능 항목을 종료하는 중 오류가 발생했습니다. 관찰 가능한 생산자 신호 &lt;code&gt;error()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="900db5e390475e30c0b02294da8a016b0ba83ca6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'()'&lt;/code&gt; sync groupings: When multiple events need to be in the same frame synchronously, parentheses are used to group those events. You can group next'd values, a completion, or an error in this manner. The position of the initial &lt;code&gt;(&lt;/code&gt; determines the time at which its values are emitted. While it can be unintuitive at first, after all the values have synchronously emitted time will progress a number of frames equal to the number of ASCII characters in the group, including the parentheses. e.g. &lt;code&gt;'(abc)'&lt;/code&gt; will emit the values of a, b, and c synchronously in the same frame and then advance virtual time by 5 frames, &lt;code&gt;'(abc)'.length === 5&lt;/code&gt;. This is done because it often helps you vertically align your marble diagrams, but it's a known pain point in real-world testing. &lt;a href=&quot;marble-testing#known-issues&quot;&gt;Learn more about known issues&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;'()'&lt;/code&gt; 동기화 그룹화 : 여러 이벤트가 동일한 프레임에 동 기적으로 있어야하는 경우 괄호를 사용하여 해당 이벤트를 그룹화하십시오. 이러한 방식으로 다음 값, 완료 또는 오류를 그룹화 할 수 있습니다. 이니셜의 위치 &lt;code&gt;(&lt;/code&gt; 값이 방출되는 시간을 결정합니다. 처음에는 직관적이지 않을 수 있지만 모든 값이 동시에 방출 된 후에는 그룹의 ASCII 문자 수와 동일한 수의 프레임이 진행됩니다. 괄호 &lt;code&gt;'(abc)'&lt;/code&gt; 예 : '(abc)' 는 동일한 프레임에서 a, b 및 c의 값을 동 기적으로 방출 한 다음 가상 프레임을 &lt;code&gt;'(abc)'.length === 5&lt;/code&gt; 5 프레임 씩 진행 합니다 .length === 5. 이것은 대리석 다이어그램을 수직으로 정렬하는 데 도움이되기 때문에 수행되지만 실제 테스트에서 알려진 문제입니다. &lt;a href=&quot;marble-testing#known-issues&quot;&gt;알려진 문제에 대해 자세히 알아보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd0ed6d06b7c0c50d7f1ded02adc8d9c93dc954e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; frame: 1 &quot;frame&quot; of virtual time passing (see above description of frames).</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; 프레임 : 가상 시간 통과의 1 &quot;프레임&quot;(위의 프레임 설명 참조).</target>
        </trans-unit>
        <trans-unit id="cd2274308e133d94aab4086c64348e0b9367d78f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'------'&lt;/code&gt;: Equivalent to &lt;code&gt;Observable.never()&lt;/code&gt;, or an observable that never emits or completes</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; 또는 &lt;code&gt;'------'&lt;/code&gt; : &lt;code&gt;Observable.never()&lt;/code&gt; 와 동일 하거나 절대로 방출 또는 완료되지 않는 관찰 가능</target>
        </trans-unit>
        <trans-unit id="b9ddd2753c7382111307878ff965226a99935b81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'------'&lt;/code&gt;: Equivalent to &lt;code&gt;never()&lt;/code&gt;, or an observable that never emits or completes</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; 또는 &lt;code&gt;'------'&lt;/code&gt; : &lt;code&gt;never()&lt;/code&gt; 와 같거나 절대로 방출 또는 완료되지 않는 관찰 가능</target>
        </trans-unit>
        <trans-unit id="e85ff3d8ea96e01ddc94347b9770c2baafc5a3f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; or &lt;code&gt;'------'&lt;/code&gt;: no subscription ever happened.</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; 또는 &lt;code&gt;'------'&lt;/code&gt; : 구독이 발생하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b2deb15be9de4e952591a988c11249d643af1ab1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-'&lt;/code&gt; time: 1 frame time passing.</source>
          <target state="translated">&lt;code&gt;'-'&lt;/code&gt; 시간 : 1 프레임 시간이 지났습니다.</target>
        </trans-unit>
        <trans-unit id="90551104ab363bce845a980f30cb723fbc3d84ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--(abc)-|'&lt;/code&gt;: on frame 2 emit &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, then on frame 8 &lt;code&gt;complete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--(abc)-|'&lt;/code&gt; : 프레임 2에서 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 를 방출 한 다음 프레임 8에서 &lt;code&gt;complete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a66914cc904a1616e408742fcf744c2669d43dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--(abc)-|'&lt;/code&gt;: on frame 20, emit &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt;, then on frame 80 &lt;code&gt;complete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--(abc)-|'&lt;/code&gt; : 프레임 20에서 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 를 방출 한 다음 프레임 80에서 &lt;code&gt;complete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7fe548a294627e814b17d903dab9561a209e6a12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-----(a|)'&lt;/code&gt;: on frame 5 emit &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'-----(a|)'&lt;/code&gt; : 프레임 5에서 &lt;code&gt;a&lt;/code&gt; 를 방출 하고 &lt;code&gt;complete&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="4fa0191fc2dbbdc24db47e31a6c21c2c4d99e31c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-----(a|)'&lt;/code&gt;: on frame 50, emit &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'-----(a|)'&lt;/code&gt; : 프레임 50에서 &lt;code&gt;a&lt;/code&gt; 를 생성 하고 &lt;code&gt;complete&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="857d299688e4bc90586f9054240d4d4f9908447e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--^--!-'&lt;/code&gt;: on frame 2 a subscription happened, and on frame 5 was unsubscribed.</source>
          <target state="translated">&lt;code&gt;'--^--!-'&lt;/code&gt; : 프레임 2에서 구독이 발생했으며 프레임 5에서 구독이 취소되었습니다.</target>
        </trans-unit>
        <trans-unit id="f7eb2910a933490ae2e8679f6e15b0ea2a86e24c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--^--!-'&lt;/code&gt;: on frame 20 a subscription happened, and on frame 50 was unsubscribed.</source>
          <target state="translated">&lt;code&gt;'--^--!-'&lt;/code&gt; : 프레임 20에서 구독이 발생했으며 프레임 50에서 구독이 취소되었습니다.</target>
        </trans-unit>
        <trans-unit id="0006636d06083015f66b5db0ac8912f9ce320737" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--^--'&lt;/code&gt;: a subscription happened after 2 &quot;frames&quot; of time passed, and the subscription was not unsubscribed.</source>
          <target state="translated">&lt;code&gt;'--^--'&lt;/code&gt; : 2 개의 &quot;프레임&quot;시간이 지난 후에 구독이 발생했으며 구독이 구독 해제되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1f35221f2edb5714d1b0dc2c10a61f6aa4d5ec78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--^--'&lt;/code&gt;: a subscription happened after 20 &quot;frames&quot; of time passed, and the subscription was not unsubscribed.</source>
          <target state="translated">&lt;code&gt;'--^--'&lt;/code&gt; : 20 개의 &quot;프레임&quot;시간이 지난 후에 구독이 발생했으며 구독이 구독 해제되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5dc8c6bec3861c166b48135c76387c8aae72940a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a 2.5m b'&lt;/code&gt;: on frame 2 emit &lt;code&gt;a&lt;/code&gt;, on frame 150,003 emit &lt;code&gt;b&lt;/code&gt; and never complete.</source>
          <target state="translated">&lt;code&gt;'--a 2.5m b'&lt;/code&gt; : 프레임 2에서 a를 방출 &lt;code&gt;a&lt;/code&gt; 프레임 150,003에서 &lt;code&gt;b&lt;/code&gt; 를 방출 하고 완료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c518d60968c44900d3105e92d3ff56cbce420fb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--'&lt;/code&gt;: An observable that waits 2 &quot;frames&quot;, emits value &lt;code&gt;a&lt;/code&gt; and then never completes.</source>
          <target state="translated">&lt;code&gt;'--a--'&lt;/code&gt; : 2 개의 &quot;프레임&quot;을 대기 하고 값 &lt;code&gt;a&lt;/code&gt; 를 방출 한 다음 완료되지 않는 관찰 가능 항목입니다 .</target>
        </trans-unit>
        <trans-unit id="e9a8a6bc5f8b8dc21df4a25f847e34ac915bf0ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--'&lt;/code&gt;: An observable that waits 20 &quot;frames&quot;, emits value &lt;code&gt;a&lt;/code&gt; and then never completes.</source>
          <target state="translated">&lt;code&gt;'--a--'&lt;/code&gt; : 20 개의 &quot;프레임&quot;을 대기 하고 값 &lt;code&gt;a&lt;/code&gt; 를 방출 한 다음 절대 완료되지 않는 관찰 가능 항목입니다 .</target>
        </trans-unit>
        <trans-unit id="558dc22b4c13f724e11da08b71a45c7a874aadbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--b--#'&lt;/code&gt;: On frame 2 emit &lt;code&gt;a&lt;/code&gt;, on frame 5 emit &lt;code&gt;b&lt;/code&gt;, and on frame 8, &lt;code&gt;error&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--a--b--#'&lt;/code&gt; : 프레임 2에서 &lt;code&gt;a&lt;/code&gt; 를 , 프레임 5에서 &lt;code&gt;b&lt;/code&gt; 를 , 프레임 8에서 &lt;code&gt;error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f66a0e5bb742deb080922072f07969bf8f5073f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--b--#'&lt;/code&gt;: On frame 20 emit &lt;code&gt;a&lt;/code&gt;, on frame 50 emit &lt;code&gt;b&lt;/code&gt;, and on frame 80, &lt;code&gt;error&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--a--b--#'&lt;/code&gt; : 프레임 20에서 &lt;code&gt;a&lt;/code&gt; 를 , 프레임 50에서 &lt;code&gt;b&lt;/code&gt; 를 , 프레임 80에서, &lt;code&gt;error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1fbec99faa34f8d8c6178c17bdba6a6c88e1bc7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--b--|'&lt;/code&gt;: On frame 2 emit &lt;code&gt;a&lt;/code&gt;, on frame 5 emit &lt;code&gt;b&lt;/code&gt;, and on frame 8, &lt;code&gt;complete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--a--b--|'&lt;/code&gt; : 프레임 2에서 &lt;code&gt;a&lt;/code&gt; 를 방출 하고 , 프레임 5에서 &lt;code&gt;b&lt;/code&gt; 를 방출 하고 , 프레임 8에서 &lt;code&gt;complete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="011793c2617b3542600d252674d69a846c293e1d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'--a--b--|'&lt;/code&gt;: On frame 20 emit &lt;code&gt;a&lt;/code&gt;, on frame 50 emit &lt;code&gt;b&lt;/code&gt;, and on frame 80, &lt;code&gt;complete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;'--a--b--|'&lt;/code&gt; : 프레임 20에서 &lt;code&gt;a&lt;/code&gt; 를 방출 하고 , 프레임 50에서 &lt;code&gt;b&lt;/code&gt; 를 방출 하고 , 프레임 80에서 &lt;code&gt;complete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d571db83420af98e9c5810ad493278bf7ed45756" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-a-^-b--|'&lt;/code&gt;: In a hot observable, on frame -2 emit &lt;code&gt;a&lt;/code&gt;, then on frame 2 emit &lt;code&gt;b&lt;/code&gt;, and on frame 5, &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'-a-^-b--|'&lt;/code&gt; : 핫 옵저버 블에서 프레임 -2에서 &lt;code&gt;a&lt;/code&gt; 를 방출 한 다음 프레임 2에서 &lt;code&gt;b&lt;/code&gt; 를 방출 하고 프레임 5에서 &lt;code&gt;complete&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="3c4be0daed0fe6a5f4a6444309f2485c8d7052a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'-a-^-b--|'&lt;/code&gt;: In a hot observable, on frame -20 emit &lt;code&gt;a&lt;/code&gt;, then on frame 20 emit &lt;code&gt;b&lt;/code&gt;, and on frame 50, &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'-a-^-b--|'&lt;/code&gt; : 핫 옵저버 블에서 -20 프레임에서 &lt;code&gt;a&lt;/code&gt; 를 방출 한 다음 20 프레임에서 &lt;code&gt;b&lt;/code&gt; 를 방출 하고 프레임 50에서 &lt;code&gt;complete&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="e08758a3a46525c399cbbae215e45c0d5e4f18d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'500ms ^ 1s !'&lt;/code&gt;: on frame 500 a subscription happened, and on frame 1,501 was unsubscribed.</source>
          <target state="translated">&lt;code&gt;'500ms ^ 1s !'&lt;/code&gt; : 프레임 500에서 구독이 발생했으며 프레임 1,501에서 구독이 취소되었습니다.</target>
        </trans-unit>
        <trans-unit id="3645e6c2789e746235dbb1a683c78f91316c0ff1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'^'&lt;/code&gt; subscription point: (hot observables only) shows the point at which the tested observables will be subscribed to the hot observable. This is the &quot;zero frame&quot; for that observable, every frame before the &lt;code&gt;^&lt;/code&gt; will be negative. Negative time might seem pointless, but there are in fact advanced cases where this is necessary, usually involving ReplaySubjects.</source>
          <target state="translated">&lt;code&gt;'^'&lt;/code&gt; 구독 지점 : (핫 옵저버 블 만 해당)는 테스트 된 옵저버 블이 핫 옵저버 블을 구독 할 지점을 나타냅니다. 이것은 관찰 가능 항목에 대한 &quot;제로 프레임&quot;이며 &lt;code&gt;^&lt;/code&gt; 앞의 모든 프레임 은 음수입니다. 음의 시간은 무의미 해 보이지만 실제로는 ReplaySubjects와 관련하여 필요한 고급 사례가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e08ffcab1613e5d26675b9934c425ca2aeaeb774" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'^'&lt;/code&gt; subscription point: shows the point in time at which a subscription happen.</source>
          <target state="translated">&lt;code&gt;'^'&lt;/code&gt; 구독 지점 : 구독이 발생하는 시점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c9eec6341670ec1c6b1e9b19d18fdf631feeedf6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'a 9ms b 9s c|'&lt;/code&gt;: on frame 0 emit &lt;code&gt;a&lt;/code&gt;, on frame 10 emit &lt;code&gt;b&lt;/code&gt;, on frame 10,012 emit &lt;code&gt;c&lt;/code&gt;, then on on frame 10,013 &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'a 9ms b 9s c|'&lt;/code&gt; : 프레임 0에서 &lt;code&gt;a&lt;/code&gt; 를 방출 하고 , 프레임 10에서 &lt;code&gt;b&lt;/code&gt; 를 방출 하고 , 프레임 10,012에서 &lt;code&gt;c&lt;/code&gt; 를 방출 한 다음, 프레임 10,013에서 on을 &lt;code&gt;complete&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52c23705b515df4c100f707c5889b869f7738d66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;'|'&lt;/code&gt; complete: The successful completion of an observable. This is the observable producer signaling &lt;code&gt;complete()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'|'&lt;/code&gt; 완료 : 관찰 가능 항목을 성공적으로 완료했습니다. 이것은 관찰 가능한 프로듀서 시그널링 &lt;code&gt;complete()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8ed8289c6915557851ae2fc185944335fcceab94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(...args: any[]) =&amp;gt; Observable&amp;lt;T&amp;gt;&lt;/code&gt;: A function which returns the Observable that delivers the same values the Node.js callback would deliver.</source>
          <target state="translated">&lt;code&gt;(...args: any[]) =&amp;gt; Observable&amp;lt;T&amp;gt;&lt;/code&gt; : Node.js 콜백이 전달하는 것과 동일한 값을 전달하는 Observable을 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="9af6c1ceaf17b75b780332cfb3ea76a28e668fd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;(...args: any[]) =&amp;gt; Observable&amp;lt;T&amp;gt;&lt;/code&gt;: A function which returns the Observable that delivers the same values the callback would deliver.</source>
          <target state="translated">&lt;code&gt;(...args: any[]) =&amp;gt; Observable&amp;lt;T&amp;gt;&lt;/code&gt; : 콜백과 동일한 값을 전달하는 Observable을 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="77f4a7aa096d066890cd4560eb8be8512c98b678" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; When using &lt;code&gt;elementAt(i)&lt;/code&gt;, it delivers an ArgumentOutOrRangeError to the Observer's &lt;code&gt;error&lt;/code&gt; callback if &lt;code&gt;i &amp;lt; 0&lt;/code&gt; or the Observable has completed before emitting the i-th &lt;code&gt;next&lt;/code&gt; notification.</source>
          <target state="translated">&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; &lt;code&gt;elementAt(i)&lt;/code&gt; 사용시 , &lt;code&gt;i &amp;lt; 0&lt;/code&gt; 이거나 i 번째 &lt;code&gt;next&lt;/code&gt; 알림을 보내기 전에 Observable이 완료된 경우 ArgumentOutOrRangeError를 Observer의 &lt;code&gt;error&lt;/code&gt; 콜백에 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="440326ab0df253e9d1a2baf16e42ef22aea1f82d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; When using &lt;code&gt;skipLast(i)&lt;/code&gt;, it throws ArgumentOutOrRangeError if &lt;code&gt;i &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; &lt;code&gt;skipLast(i)&lt;/code&gt; 사용할 때 &lt;code&gt;i &amp;lt; 0&lt;/code&gt; 경우 ArgumentOutOrRangeError가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="ab36e17fb5757f8497903f935e1060283fd57611" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; When using &lt;code&gt;take(i)&lt;/code&gt;, it delivers an ArgumentOutOrRangeError to the Observer's &lt;code&gt;error&lt;/code&gt; callback if &lt;code&gt;i &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; &lt;code&gt;take(i)&lt;/code&gt; 사용할 때 &lt;code&gt;i &amp;lt; 0&lt;/code&gt; 경우 ArgumentOutOrRangeError를 관찰자의 &lt;code&gt;error&lt;/code&gt; 콜백에 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="640ea84593ebfbf6d363bf5efc85c28283078a3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; When using &lt;code&gt;takeLast(i)&lt;/code&gt;, it delivers an ArgumentOutOrRangeError to the Observer's &lt;code&gt;error&lt;/code&gt; callback if &lt;code&gt;i &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; &lt;code&gt;takeLast(i)&lt;/code&gt; 사용할 때 &lt;code&gt;i &amp;lt; 0&lt;/code&gt; 경우 ArgumentOutOrRangeError를 Observer의 &lt;code&gt;error&lt;/code&gt; 콜백에 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="31e642c2f3e6b9f25cc4726681ae36498a69e080" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ConnectableObservable&lt;/code&gt; is hidden from direct use in v6 and is accessible only through operators &lt;code&gt;multicast&lt;/code&gt;, &lt;code&gt;publish&lt;/code&gt;, &lt;code&gt;publishReplay&lt;/code&gt;, and &lt;code&gt;publishLast&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ConnectableObservable&lt;/code&gt; 은 v6에서 직접 사용되지 않도록 숨겨져 있으며 &lt;code&gt;multicast&lt;/code&gt; , &lt;code&gt;publish&lt;/code&gt; , &lt;code&gt;publishReplay&lt;/code&gt; 및 &lt;code&gt;publishLast&lt;/code&gt; 연산자를 통해서만 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25628c7cfe20af88f31a364c509c719222e82f15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EmptyError&lt;/code&gt; Delivers an EmptyError to the Observer's &lt;code&gt;error&lt;/code&gt; callback if the Observable completes before any &lt;code&gt;next&lt;/code&gt; notification was sent.</source>
          <target state="translated">&lt;code&gt;EmptyError&lt;/code&gt; &lt;code&gt;next&lt;/code&gt; 알림을 보내기 전에 Observable이 완료되면 Observer의 &lt;code&gt;error&lt;/code&gt; 콜백에 EmptyError를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="cf43bc7be5b6a9f4eff2297551b22603dcce7470" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Error&lt;/code&gt; - Throws if no items that match the predicate are emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;Error&lt;/code&gt; - 술어와 일치하는 항목이 소스 관찰 가능한 방출되지 않는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0c038e664cac7e678a7189ea519cc11210358a93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;If&lt;/code&gt; statement for Observables.</source>
          <target state="translated">&lt;code&gt;If&lt;/code&gt; Observables에 대한 If 문.</target>
        </trans-unit>
        <trans-unit id="c8604585789c7f45b430d747e2826b514bd35187" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt; | OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt; | OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; : ConnectableObservable : 연결시 소스 Observable이 항목을 관찰자에게 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="0833ea0338f3e9c17cc9ca3e78e5ac2595518c59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable identical to the source, but runs the specified Observer or callback(s) for each item.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 소스와 동일한 Observable이지만 각 항목에 대해 지정된 Observer 또는 콜백을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="9a3ff938938e7f92083767cff963ec408bc72281" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable of values from the source that were allowed by the &lt;code&gt;predicate&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : &lt;code&gt;predicate&lt;/code&gt; 함수에 의해 허용 된 소스의 값을 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48b16d89a273649e6300bb81e302e25a4c761d4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that begins emitting items emitted by the source Observable when the specified predicate becomes false.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 지정된 술어가 false가되면 소스 Observable이 방출 한 항목을 방출하기 시작하는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="9449ccb1f132a2fe147e056e41b27587341903fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that delays the emissions of the source Observable by an amount of time specified by the Observable returned by &lt;code&gt;delayDurationSelector&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 소스 Observable의 방출을 &lt;code&gt;delayDurationSelector&lt;/code&gt; 에 의해 반환 된 Observable에 의해 지정된 시간만큼 지연시키는 Observable .</target>
        </trans-unit>
        <trans-unit id="38a02d0451e76caad26e6ddc73ce1e225241f99f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that delays the emissions of the source Observable by the specified &lt;code&gt;dueTime&lt;/code&gt;, and may drop some values if they occur too frequently.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 지정된 &lt;code&gt;dueTime&lt;/code&gt; 만큼 Observable 소스의 방출을 지연시키는 Observable 이며 , 너무 자주 발생하면 일부 값을 떨어 뜨릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed3ec44e2afb8b4f0db7d022d34500a94284cdbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that delays the emissions of the source Observable by the specified duration Observable returned by &lt;code&gt;durationSelector&lt;/code&gt;, and may drop some values if they occur too frequently.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; :에 의해 반환 관찰 가능한 지정된 시간에 의해 관찰 가능한 소스의 배출 지연 관측 &lt;code&gt;durationSelector&lt;/code&gt; 을 , 그들이 너무 자주 발생하면 일부 값을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1abab6fda2770b6bc76976f9a61742680f62d69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that delays the emissions of the source Observable by the specified timeout or Date.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 지정된 시간 초과 또는 날짜에 따라 Observable 소스의 배출을 지연시키는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="e889533f93eed35b01537d0147d0955ccb947ef4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits a single item, if it is found. Otherwise, will emit the default value if given. If not, then emits an error.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 단일 항목이 있으면이를 방출하는 Observable입니다. 그렇지 않으면 주어진 경우 기본값을 내 보냅니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6395d1a685b354afb5235c686fc8add7f341178f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits at most the last count values emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 소스 Observable이 방출 한 마지막 카운트 값을 최대한 방출하는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="b5d994a03ce94afe4026fa16bc1a7e336127fa8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits item with the largest value.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 가장 큰 값을 가진 항목을 내보내는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="b9d8c36ee2b5cd4623102825282d7ac16ed85f38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits item with the smallest value.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 가장 작은 값을 가진 항목을 내보내는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="682f9f17153985c8d9995ecf01c83b22afc2f6ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits items from the source Observable with distinct values based on the key specified.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 지정된 키에 따라 고유 한 값으로 소스 Observable에서 항목을 내보내는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="3d6800c9e0f9ae6a14fbb6b44f0d6875055a3d0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits items from the source Observable with distinct values.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 고유 한 값으로 소스 Observable에서 항목을 내보내는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="a5ae53fe7fc4ee976638967a24f49e925818d67f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits only the first &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable, or all of the values from the source if the source emits fewer than &lt;code&gt;count&lt;/code&gt; values.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 소스 Observable이 방출 한 첫 번째 &lt;code&gt;count&lt;/code&gt; 값만 또는 소스가 &lt;code&gt;count&lt;/code&gt; 값 보다 적은 양을 방출하는 경우 소스에서 모든 값을 방출하는 Observable 입니다.</target>
        </trans-unit>
        <trans-unit id="b4a8c6ed88fd287a7fb8db2c7007184096326e4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the items emitted by the source Observable and then emits the items in the specified Iterable.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 소스 Observable이 방출 한 항목을 방출 한 다음 지정된 Iterable에서 항목을 방출하는 Observable.</target>
        </trans-unit>
        <trans-unit id="9c81ca47826ed80fc19d479ca6fdffc6d56f6a6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the results of sampling the values emitted by the source Observable at the specified time interval.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 지정된 시간 간격으로 소스 Observable이 방출 한 값을 샘플링 한 결과를 내보내는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="7cd751b89528c1671e4f80823e7b81bacc8aeec1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the results of sampling the values emitted by the source Observable whenever the notifier Observable emits value or completes.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : Observable 알리미가 값을 생성하거나 완료 할 때마다 소스 Observable이 방출 한 값을 샘플링 한 결과를 내보내는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="a1a0b870de4e6611a1c770dfd589fb1187f9deae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the single item emitted by the source Observable that matches the predicate or &lt;code&gt;undefined&lt;/code&gt; when no items match.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 소스 Observable이 생성 한 단일 항목을 내보내는 술어와 일치하거나 일치하는 항목이 없을 때 &lt;code&gt;undefined&lt;/code&gt; Observable입니다 .</target>
        </trans-unit>
        <trans-unit id="d8e0addfb5015dbaa3535820ab93808a87b6e9c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the values from the source Observable so long as each value satisfies the condition defined by the &lt;code&gt;predicate&lt;/code&gt;, then completes.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; 다음 조건에 의해 정의 된 각각의 값을 만족하는 것이면 관찰 가능한 소스로부터 값을 출사 관찰 &lt;code&gt;predicate&lt;/code&gt; , 완료된다.</target>
        </trans-unit>
        <trans-unit id="e6261ccdbc462844fef242c6c04ab7ff1aa60d18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the values from the source Observable until such time as &lt;code&gt;notifier&lt;/code&gt; emits its first value.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; :로 될 때까지 관찰 가능한 소스로부터 값을 출사 관찰 &lt;code&gt;notifier&lt;/code&gt; 최초 값을 방출한다.</target>
        </trans-unit>
        <trans-unit id="3c308d842f2d0d1867ca783e8dc73eaa380e9c04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that mirrors the output of the first Observable to emit an item.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 항목을 방출하기 위해 첫 번째 Observable의 출력을 미러링하는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="c1f86da4ab0846a743a7251a13b70c94c877b6f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that mirrors the source, but will call the specified function on termination.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 소스를 미러링하지만 종료시 지정된 함수를 호출하는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="7e4710248cea691104373b5664ba6d261d7d8dc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that performs rate-limiting of emissions from the source Observable.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : Observable 소스에서 방출 속도를 제한하는 Observable.</target>
        </trans-unit>
        <trans-unit id="946c0b65142202dabd849b9b61c4283b9dd08baf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that performs the throttle operation to limit the rate of emissions from the source.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 소스에서 배출되는 비율을 제한하기 위해 스로틀 작동을 수행하는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="602e1b382729f2ce251c1b92b443bbd937af3340" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that skips items from the source Observable until the second Observable emits an item, then emits the remaining items.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 두 번째 Observable이 항목을 방출 할 때까지 소스 Observable에서 항목을 건너 뛰고 나머지 항목을 방출하는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="1ef7f4cf892977bb212561f1a77acf132b290686" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that skips the last count values emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 소스 Observable이 방출 한 마지막 카운트 값을 건너 뛰는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="d557c423d0245ce169be446a043cb268e1ca5ec5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that skips values emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 소스 Observable이 생성 한 값을 건너 뛰는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="4cfa061328f40141206293f33fa4e67d138bc66a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that upon connection causes the source Observable to emit items to its Observers.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 연결시 소스 Observable이 해당 항목을 Observer에 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="9c6d52f8ed9f46e4195b54356a66ccf875933728" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that will resubscribe to the source stream when the source stream completes , at most count times.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 소스 스트림이 완료 될 때 최대 횟수만큼 소스 스트림을 다시 구독하는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="0f22925542ce9ba6590bea06ee00f05160b4c25e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: Observable that emits the same notifications as the source Observable, but with provided scheduler.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 소스 Observable과 동일한 알림을 제공하지만 스케줄러가 제공되는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="58a671188d09f4f66f5a13afcd8af3a07fbd548d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: Observable that mirrors behaviour of source, unless timeout checks fail.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 시간 초과 확인에 실패하지 않는 한 소스의 동작을 미러링하는 관찰 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c6bf69d4f9d0ab23a12db778ab90b11d481273cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: The source Observable modified so that its subscriptions happen on the specified &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt;. .</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 소스 Observable이 구독이 지정된 &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt; 에서 발생하도록 수정되었습니다 . .</target>
        </trans-unit>
        <trans-unit id="98eaeae8156b0d69ae687593c863bfb00f1b8b0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: The source Observable modified with repeat logic.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 소스 Observable이 반복 로직으로 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="32b9e6769395cbfd746c2fd896e1edba7235d3c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: The source Observable modified with retry logic.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 재시도 로직으로 수정 된 소스 Observable.</target>
        </trans-unit>
        <trans-unit id="a06d6f1678091badb1098fdfbba9250008ad6ef3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt;: The source Observable modified with the retry logic.</source>
          <target state="translated">&lt;code&gt;MonoTypeOperatorFunction&amp;lt;T&amp;gt;&lt;/code&gt; : 재시도 로직으로 수정 된 소스 Observable.</target>
        </trans-unit>
        <trans-unit id="8763fb5889ab433a69024fe4938e084fc22037c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Notification&amp;lt;T&amp;gt;&lt;/code&gt;: The &quot;error&quot; Notification representing the argument.</source>
          <target state="translated">&lt;code&gt;Notification&amp;lt;T&amp;gt;&lt;/code&gt; : 인수를 나타내는 &quot;오류&quot;알림입니다.</target>
        </trans-unit>
        <trans-unit id="ef879440b9acd7b903b77c7ea86c552b00e297d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Notification&amp;lt;T&amp;gt;&lt;/code&gt;: The &quot;next&quot; Notification representing the argument.</source>
          <target state="translated">&lt;code&gt;Notification&amp;lt;T&amp;gt;&lt;/code&gt; : 인수를 나타내는 &quot;다음&quot;알림.</target>
        </trans-unit>
        <trans-unit id="38d464bb5af13abcb15464548a27988c4fe87d46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Notification&amp;lt;any&amp;gt;&lt;/code&gt;: The valueless &quot;complete&quot; Notification.</source>
          <target state="translated">&lt;code&gt;Notification&amp;lt;any&amp;gt;&lt;/code&gt; : 무가치 한 &quot;완전한&quot;알림.</target>
        </trans-unit>
        <trans-unit id="ee120528c9ab1715102554c9aa15756201b1fb7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: All values of each passed Observable merged into a single Observable, in order, in serial fashion.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; : 전달 된 각 Observable의 모든 값이 순차적으로 순차적으로 단일 Observable로 병합되었습니다.</target>
        </trans-unit>
        <trans-unit id="bd0e1703773d09072a2fc9c6abfbab19b7184e3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;O&amp;gt;[] | R&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;O&amp;gt;[] | R&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9fd71541e5d46e89663978e9c179e73d33d7f460" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;R&amp;gt;&amp;gt;&lt;/code&gt;: An Observable whose Observers' subscriptions trigger an invocation of the given Observable factory function.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;ObservedValueOf&amp;lt;R&amp;gt;&amp;gt;&lt;/code&gt; : 관찰자의 구독이 주어진 Observable 팩토리 함수의 호출을 트리거하는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="72ea18b738f13176716cd3530244cf48151fd843" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt;: An Observable of projected values from the most recent values from each input Observable, or an array of the most recent values from each input Observable.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt; : 각 입력 Observable의 가장 최근 값에서 투사 된 값의 Observable 또는 각 입력 Observable의 가장 최근 값의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="669000de8f64c0f068e1e8d2b995d5ae4e1cd7e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt;: An Observable that concatenates all sources, one after the other, ignoring all errors, such that any error causes it to move on to the next source.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt; : 모든 오류를 무시하고 모든 오류를 무시하고 모든 오류를 무시하여 다음 소스로 넘어가는 Observable.</target>
        </trans-unit>
        <trans-unit id="5dd2c89285ed413ee73cb8ed373783a71556739e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt;: a new observable with the Operator applied</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt; : Operator가 적용된 새로운 관찰 가능</target>
        </trans-unit>
        <trans-unit id="546d4d5a898b2514cd733c7691edcbe22e343808" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt;: an Observable that emits items that are the result of every input Observable.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;R&amp;gt;&lt;/code&gt; : 모든 Observable 입력의 결과 인 항목을 내보내는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="f246ffeb696ea044aea059a6547ab60ed97903e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;Response&amp;gt;&lt;/code&gt;: An Observable, that when subscribed to performs an HTTP request using the native &lt;code&gt;fetch&lt;/code&gt; function. The &lt;a href=&quot;../index/class/subscription&quot;&gt;&lt;code&gt;Subscription&lt;/code&gt;&lt;/a&gt; is tied to an &lt;code&gt;AbortController&lt;/code&gt; for the the fetch.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;Response&amp;gt;&lt;/code&gt; : Observable. 구독 할 때 기본 &lt;code&gt;fetch&lt;/code&gt; 기능을 사용하여 HTTP 요청을 수행 합니다. &lt;a href=&quot;../index/class/subscription&quot;&gt; &lt;code&gt;Subscription&lt;/code&gt; &lt;/a&gt; 에 묶여 &lt;code&gt;AbortController&lt;/code&gt; 하여 가져 오기합니다.</target>
        </trans-unit>
        <trans-unit id="12df656ce83de0d952270b74d9d36115ce231f71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;S&amp;gt;&lt;/code&gt;: The generated sequence.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;S&amp;gt;&lt;/code&gt; : 생성 된 시퀀스.</target>
        </trans-unit>
        <trans-unit id="1b8df8881cd223a6d99f276649bb495aa498b2e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T | F&amp;gt;&lt;/code&gt;: Either first or second Observable, depending on condition.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T | F&amp;gt;&lt;/code&gt; : 조건에 따라 첫 번째 또는 두 번째 관찰 가능.</target>
        </trans-unit>
        <trans-unit id="09e76145a70f20853eb46f82588e140da99d594f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T | T[]&amp;gt;&lt;/code&gt;: Observable which, when an event happens, emits first parameter passed to registered event handler. Alternatively it emits whatever project function returns at that moment.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T | T[]&amp;gt;&lt;/code&gt; : 이벤트가 발생할 때 등록 된 이벤트 핸들러로 전달 된 첫 번째 매개 변수를 방출하는 관찰 가능합니다. 또는 그 순간에 프로젝트 기능이 반환하는 것을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="d7584ca661dd77ce664d3ff61f1e49b4909d87c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="1b80f12276d3a40a5fa937076c33adccf9646b17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that behaves the same as Observable returned by &lt;code&gt;observableFactory&lt;/code&gt;, but which - when completed, errored or unsubscribed - will also call &lt;code&gt;unsubscribe&lt;/code&gt; on created resource object.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt; : Observable이 &lt;code&gt;observableFactory&lt;/code&gt; 에 의해 반환 된 Observable과 동일하게 동작 하지만 완료, 오류 또는 구독 &lt;code&gt;unsubscribe&lt;/code&gt; 시 생성 된 리소스 개체에 대해 구독 취소 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="8d9f59154e679519172ccff523d963b577c7ba52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: An Observable that emits the arguments described above and then completes.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt; : 위에서 설명한 인수를 내 보낸 후 완료되는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="5a17efa17d3475364890f0d3f49f8f8c5cd4a4d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: Observable that the Subject casts to</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt; : 대상이 시전하는 관측 가능</target>
        </trans-unit>
        <trans-unit id="a80ce4eeb36f3e609ba0293318360af2884d5e92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: The generated sequence.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt; : 생성 된 시퀀스.</target>
        </trans-unit>
        <trans-unit id="625771d790fd38d43439cefc89d792200861d6c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt;: an Observable that mirrors the output of the first Observable to emit an item.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;T&amp;gt;&lt;/code&gt; : 항목을 방출하기 위해 첫 번째 Observable의 출력을 미러링하는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="3c402a0e4b6a9e65ebc0e3c78845b844e7e841a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;any&amp;gt;&lt;/code&gt;: Observable emitting either an array of last values emitted by passed Observables or value from project function.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;any&amp;gt;&lt;/code&gt; : 전달 된 Observable에 의해 방출 된 마지막 값의 배열 또는 프로젝트 함수의 값을 방출하는 Observable.</target>
        </trans-unit>
        <trans-unit id="d644633ca879cf0518e4252c5291db0c1473f62e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;never&amp;gt;&lt;/code&gt;: An error Observable: emits only the error notification using the given error argument.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;never&amp;gt;&lt;/code&gt; : 오류 Observable : 주어진 오류 인수를 사용하여 오류 알림 만 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="4fd37309412eebab1af8b444e3494ff46307ad58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt;: An Observable of numbers that emits a finite range of sequential integers.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt; : 유한 범위의 순차 정수를 방출하는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="5bafa5caf9714920c7d9794783daad8cb6cfe408" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt;: An Observable that emits a &lt;code&gt;0&lt;/code&gt; after the &lt;code&gt;dueTime&lt;/code&gt; and ever increasing numbers after each &lt;code&gt;period&lt;/code&gt; of time thereafter.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt; : &lt;code&gt;dueTime&lt;/code&gt; 이후 에 &lt;code&gt;0&lt;/code&gt; 을 방출하고 이후에 각 &lt;code&gt;period&lt;/code&gt; 이 지나면 숫자가 증가 하는 Observable입니다 .</target>
        </trans-unit>
        <trans-unit id="18ef7a2d7b03b517f7cba00b53dce721410629dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt;: An Observable that emits a sequential number each time interval.</source>
          <target state="translated">&lt;code&gt;Observable&amp;lt;number&amp;gt;&lt;/code&gt; : 매 간격마다 순차적 인 숫자를 방출하는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="9c60d02600031a7c4e4077aaed375e92e7ce4c66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Observable.if&lt;/code&gt; and &lt;code&gt;Observable.throw&lt;/code&gt; These methods have been replaced by the static &lt;code&gt;iif()&lt;/code&gt; and &lt;code&gt;throwError()&lt;/code&gt; functions. Use &lt;a href=&quot;https://github.com/reactivex/rxjs-tslint&quot;&gt;rxjs-tslint&lt;/a&gt; to convert method calls with function calls.</source>
          <target state="translated">&lt;code&gt;Observable.if&lt;/code&gt; 및 &lt;code&gt;Observable.throw&lt;/code&gt; 이 메소드는 정적 &lt;code&gt;iif()&lt;/code&gt; 및 &lt;code&gt;throwError()&lt;/code&gt; 함수 로 대체되었습니다 . &lt;a href=&quot;https://github.com/reactivex/rxjs-tslint&quot;&gt;rxjs-tslint&lt;/a&gt; 를 사용 하여 함수 호출로 메소드 호출을 변환 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8dd422c34dd6670e5820789a3935b0f8a163b30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;Notification&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt;: An Observable that emits items and notifications embedded in Notification objects emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;Notification&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt; : 소스 Observable이 생성 한 Notification 객체에 포함 된 항목과 알림을 내보내는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="b943e1dff560a9b4731381e69c691f9f2663856d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;ObservableInput&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt;: An Observable emitting values from all the inner Observables concatenated.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;ObservableInput&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt; : 연결된 모든 내부 Observable에서 Observable 방출 값.</target>
        </trans-unit>
        <trans-unit id="a9fbd53ce8c4ca4704991f6a4e6424efb51a3e50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;ObservableInput&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt;: An Observable that emits values coming from all the inner Observables emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;ObservableInput&amp;lt;T&amp;gt;, T&amp;gt;&lt;/code&gt; : 소스 Observable이 내 보낸 모든 내부 Observable에서 나오는 값을 내보내는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="4e9e5b74e3d4c5968ec5aa65403ccf2f27d4ac10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, GroupedObservable&amp;lt;K, R&amp;gt;&amp;gt;&lt;/code&gt;: An Observable that emits GroupedObservables, each of which corresponds to a unique key value and each of which emits those items from the source Observable that share that key value.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, GroupedObservable&amp;lt;K, R&amp;gt;&amp;gt;&lt;/code&gt; : GroupedObservables를 내보내는 Observable로, 각각 고유 한 키 값에 해당하며 각각의 키 값을 공유하는 Observable에서 해당 항목을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a31762e776d77c6f8116c3b05cba4d1b24ca6464" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, I | R&amp;gt;&lt;/code&gt;: An Observable that emits items from the given &lt;code&gt;innerObservable&lt;/code&gt; (and optionally transformed through the deprecated &lt;code&gt;resultSelector&lt;/code&gt;) every time a value is emitted on the source Observable, and taking only the values from the most recently projected inner Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, I | R&amp;gt;&lt;/code&gt; : Observable 은 소스 Observable에서 값이 방출 될 때마다 주어진 &lt;code&gt;innerObservable&lt;/code&gt; (및 선택적으로 deprecated &lt;code&gt;resultSelector&lt;/code&gt; 를 통해 변환 됨) 에서 항목을 내보내고 Observable에서 가장 최근에 투영 된 내부 Observable의 값만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8a4fd670838262d305edf3ffd88f8a75a09e6037" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Notification&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An Observable that emits &lt;a href=&quot;../index/class/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; objects that wrap the original emissions from the source Observable with metadata.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, Notification&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; : 원본 Observable의 원본 배출을 메타 데이터로 감싸는 &lt;a href=&quot;../index/class/notification&quot;&gt; &lt;code&gt;Notification&lt;/code&gt; &lt;/a&gt; 객체를 내보내는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="25fe863e956990570054cbe8f4a3ae938b4a7a37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An Observable of windows, which are Observables emitting values of the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; : 소스 Observable의 값을 방출하는 Observable 창인 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="0391947d88f4f7f42a95717260c28949831f0f0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An Observable of windows, which in turn are Observable of values.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; : Window의 Observable이며, 값은 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="2f931b53ceabcaf37290a1e173d5261898200497" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An observable of windows, which in turn are Observables.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; : 관찰 가능한 창의 관찰 가능한 창입니다.</target>
        </trans-unit>
        <trans-unit id="36b665d4b96e8622df44bceaa15c3aef802424b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable containing projected Observables of each item of the source, ignoring projected Observables that start before their preceding Observable has completed.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; : 소스의 각 항목에 대한 투영 된 Observable을 포함하는 Observable은 이전 Observable이 완료되기 전에 시작되는 예상 Observable을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="ae05bfd16d5b0dc9ad579b88debdcb634355a5d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable that emits items from the given &lt;code&gt;innerObservable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; : 주어진 &lt;code&gt;innerObservable&lt;/code&gt; 에서 아이템을 방출하는 Observable</target>
        </trans-unit>
        <trans-unit id="f1114fbae762bbcc842c75a346d50886aba62bd3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable that emits the result of applying the projection function (and the optional deprecated &lt;code&gt;resultSelector&lt;/code&gt;) to each item emitted by the source Observable and merging the results of the Observables obtained from this transformation.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; : Observable 은 소스 Observable에서 방출 된 각 항목에 프로젝션 함수 (및 선택적 deprecated &lt;code&gt;resultSelector&lt;/code&gt; )를 적용한 결과를 내보내고이 변환에서 얻은 Observable의 결과를 병합합니다.</target>
        </trans-unit>
        <trans-unit id="4936e9ad8b47feae4057bfc06b74066ba9c2244e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable that emits the result of applying the projection function (and the optional deprecated &lt;code&gt;resultSelector&lt;/code&gt;) to each item emitted by the source Observable and taking only the values from the most recently projected inner Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; : Observable 은 소스 Observable이 방출 한 각 항목에 투영 기능 (및 선택적인 deprecated &lt;code&gt;resultSelector&lt;/code&gt; )을 적용한 결과를 내보내고 가장 최근에 투영 된 내부 Observable의 값만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2a802dcfd33b79856466fc5e35de71361bf29241" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An Observable that emits the result of applying the projection function (and the optional deprecated &lt;code&gt;resultSelector&lt;/code&gt;) to each item emitted by the source Observable and taking values from each projected inner Observable sequentially.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; : Observable 은 소스 Observable에 의해 방출 된 각 항목에 프로젝션 기능 (및 선택적 deprecated &lt;code&gt;resultSelector&lt;/code&gt; )을 적용한 결과를 방출하고 각 투영 된 내부 Observable에서 순차적으로 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="92eec52d3a9e0aee0ab31663d93da5ec6a88327a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt;: An observable of values merged together by joining the passed observable with itself, one after the other, for each value emitted from the source.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, ObservedValueOf&amp;lt;O&amp;gt; | R&amp;gt;&lt;/code&gt; : 소스에서 방출 된 각 값에 대해 전달 된 observable을 자신과 차례로 결합하여 observable 값을 병합합니다.</target>
        </trans-unit>
        <trans-unit id="6389b114b24798b556b201a37917cf23aa19a979" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e8d1bd733bcb192dc0ef096871364d3d023737c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: A new Observable of property values from the source values.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; : 소스 값에서 새로운 속성 값을 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e304529f59d93d3c25b21c0bd7fe17bed8f078ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable of projected values from the most recent values from each input Observable, or an array of the most recent values from each input Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; : 각 입력 Observable의 가장 최근 값에서 투사 된 값의 Observable 또는 각 입력 Observable의 가장 최근 값의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="0c94ddce24cecab84d17bb4f8b35baa77d868ac0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits the given &lt;code&gt;value&lt;/code&gt; every time the source Observable emits something.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; : 소스 Observable이 무언가를 방출 할 때마다 주어진 &lt;code&gt;value&lt;/code&gt; 을 방출하는 Observable .</target>
        </trans-unit>
        <trans-unit id="fc79b7763d23cae388f6ab3337dcf1c4d68ce6b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits the results of invoking the selector on the items emitted by a &lt;code&gt;ConnectableObservable&lt;/code&gt; that shares a single subscription to the underlying stream.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; : 기본 스트림에 대한 단일 구독을 공유하는 &lt;code&gt;ConnectableObservable&lt;/code&gt; 에서 방출 된 항목에 대해 선택기를 호출 한 결과를 내보내는 Observable입니다 .</target>
        </trans-unit>
        <trans-unit id="83d1263ae27c17bb3433e47a18a1040160a7d6e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits the source values and also result of applying the projection function to each value emitted on the output Observable and and merging the results of the Observables obtained from this transformation.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; : 소스 값을 방출하고 출력 Observable에서 방출 된 각 값에 투영 함수를 적용하고이 변환에서 얻은 Observable의 결과를 병합 한 결과 인 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="1e461258d10f81fe5813686fbc0c2bda14a219dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits the values from the source Observable transformed by the given &lt;code&gt;project&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; : 제공된 &lt;code&gt;project&lt;/code&gt; 함수로 변환 된 소스 Observable에서 값을 내보내는 Observable입니다 .</target>
        </trans-unit>
        <trans-unit id="936d1a67ca42c166a86a10148a49bde1e454fa75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An Observable that emits values from source Observable, but - if it errors - subscribes to the next passed Observable and so on, until it completes or runs out of Observables.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; : 소스 Observable에서 값을 내보내는 Observable이지만 오류가 발생한 경우 Observable이 완료되거나 없어 질 때까지 다음으로 전달 된 Observable 등을 구독합니다.</target>
        </trans-unit>
        <trans-unit id="99d2bff6a3704c559e008d5d0bc66fdcb9c51d50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt;: An observable of the accumulated values.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, R&amp;gt;&lt;/code&gt; : 누적 된 값을 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b40b1eb80ecabc355acb81f89cecbb6782e4906c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt;: An Observable of the first item that matches the condition.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt; : 조건과 일치하는 첫 번째 항목의 Observable.</target>
        </trans-unit>
        <trans-unit id="0da3914377c50370c3b653fe993f2deb3effae27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt;: An Observable that emits only the last item satisfying the given condition from the source, or an NoSuchElementException if no such items are emitted.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt; : 소스에서 주어진 조건을 만족하는 마지막 항목 만 내보내는 Observable 또는 그러한 항목이 없으면 NoSuchElementException입니다.</target>
        </trans-unit>
        <trans-unit id="609691028cdab1ac2a82fd5eb880713da1a59fd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt;: An Observable that emits the items in the specified Iterable and then emits the items emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | D&amp;gt;&lt;/code&gt; : 지정된 Iterable에서 항목을 방출 한 다음 소스 Observable에서 방출 한 항목을 방출하는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="ed5d3fe82744ac00ef5f18025cfc4a819f2feec8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | ObservedValueOf&amp;lt;O&amp;gt;&amp;gt;&lt;/code&gt;: An observable that originates from either the source or the observable returned by the catch &lt;code&gt;selector&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | ObservedValueOf&amp;lt;O&amp;gt;&amp;gt;&lt;/code&gt; : 소스 또는 캐치 &lt;code&gt;selector&lt;/code&gt; 함수 에서 반환 한 관찰 가능 항목에서 발생하는 관찰 가능 파일입니다 .</target>
        </trans-unit>
        <trans-unit id="917e13a869d45f18bbb3fa233d195401c5881fc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt;: An Observable that emits a single value that is the result of accumulating the values emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt; : 소스 Observable에 의해 방출 된 값을 누적 한 결과 단일 값을 방출하는 Observable.</target>
        </trans-unit>
        <trans-unit id="f3dbf8202edc720dbee99010f4de8c8d524a1654" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt;: An Observable that emits either the specified &lt;code&gt;defaultValue&lt;/code&gt; if the source Observable emits no items, or the values emitted by the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt; : 소스 Observable이 항목을 방출하지 않으면 지정된 &lt;code&gt;defaultValue&lt;/code&gt; 를 방출하거나 Observable이 방출 한 값을 방출하는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="529b798ac9b12565a4850db4ce7e7eedfdc11a0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt;: Observable that mirrors behaviour of source or, when timeout check fails, of an Observable passed as a second parameter.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | R&amp;gt;&lt;/code&gt; : Observable은 소스의 동작 또는 시간 초과 확인에 실패한 경우 Observable의 두 번째 매개 변수로 전달 된 동작을 미러링합니다.</target>
        </trans-unit>
        <trans-unit id="6ab6b4873dd13ed201c943f6c53cf2f2269d7d5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T | undefined&amp;gt;&lt;/code&gt;: An Observable of the first item that matches the condition.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T | undefined&amp;gt;&lt;/code&gt; : 조건과 일치하는 첫 번째 항목의 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="92b0d5ad575e28215f2190858c47eade8e16ab5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt;: An Observable of arrays of buffered values.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt; : 버퍼링 된 값의 배열을 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06e1a442a5978c8053196612fd140be99654a739" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt;: An Observable of buffers, which are arrays of values.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt; : 버퍼의 관찰 가능 값 배열입니다.</target>
        </trans-unit>
        <trans-unit id="963e1454f929c69a8e15356996340866e7328b0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt;: An array from an observable sequence.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt; : 관찰 가능한 시퀀스의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="46031b573a888633ac1d11c7d0c5a75d253ba889" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt;: An observable of arrays of buffered values.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, T[]&amp;gt;&lt;/code&gt; : 버퍼링 된 값의 배열을 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95d772c65fa6e969daaef9c997413f7d78c99bab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, TimeInterval&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: Observable that emit infomation about value and interval</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, TimeInterval&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; : 값과 간격에 대한 정보를 방출하는 관찰 가능</target>
        </trans-unit>
        <trans-unit id="f01e99c7b50bfb9837a11c004da57eb915716d96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, Timestamp&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, Timestamp&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ac1c1912e9c531cf65e1edd68b325400d84e4c9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, [T, T]&amp;gt;&lt;/code&gt;: An Observable of pairs (as arrays) of consecutive values from the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, [T, T]&amp;gt;&lt;/code&gt; : 소스 Observable의 연속 값 쌍으로 구성된 Observable (배열)입니다.</target>
        </trans-unit>
        <trans-unit id="1c706a87589545aacce9fc175adab0cfa04a67fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt;: An Observable of a boolean value indicating whether observable was empty or not</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt; : observable이 비어 있는지 여부를 나타내는 boolean 값의 Observable</target>
        </trans-unit>
        <trans-unit id="52c5f27dea5137ec37457b98a437e8a147c2012b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt;: An Observable of a single boolean value representing whether or not the values emitted by both observables were equal in sequence.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt; : 두 관찰 가능 값에 의해 방출 된 값이 순서대로 같은지 여부를 나타내는 단일 부울 값의 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="084491f279558c6a0089f3fafc3e046ac95017d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt;: An Observable of booleans that determines if all items of the source Observable meet the condition specified.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, boolean&amp;gt;&lt;/code&gt; : 소스 Observable의 모든 항목이 지정된 조건을 충족하는지 여부를 결정하는 Observable of booleans입니다.</target>
        </trans-unit>
        <trans-unit id="9c8ab2999ba64eaf1d254ef445e315a3af05b9ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, number&amp;gt;&lt;/code&gt;: An Observable of one number that represents the count as described above.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, number&amp;gt;&lt;/code&gt; : 위에서 설명한 카운트를 나타내는 하나의 숫자로 된 Observable.</target>
        </trans-unit>
        <trans-unit id="21508cc91f2bf6aad48d4bf57db2587d1fdae434" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;T, number&amp;gt;&lt;/code&gt;: An Observable of the index of the first item that matches the condition.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;T, number&amp;gt;&lt;/code&gt; : 조건과 일치하는 첫 번째 항목의 인덱스를 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e1666f9fe233ad327cda0b296e7fd550add86f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;any, T&amp;gt;&lt;/code&gt;: An Observable that takes a source of Observables and propagates the first observable exclusively until it completes before subscribing to the next.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;any, T&amp;gt;&lt;/code&gt; : Observables의 소스를 가져 와서 다음 Observation에 가입하기 전에 완료 될 때까지 첫 번째 Observable을 독점적으로 전파하는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="c6a5ca5378c9fcf666946deff36b36b6ae25600b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OperatorFunction&amp;lt;any, never&amp;gt;&lt;/code&gt;: An empty Observable that only calls &lt;code&gt;complete&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;, based on which one is called by the source Observable.</source>
          <target state="translated">&lt;code&gt;OperatorFunction&amp;lt;any, never&amp;gt;&lt;/code&gt; : 소스 Observable이 호출 한 것을 기준으로 &lt;code&gt;complete&lt;/code&gt; 또는 &lt;code&gt;error&lt;/code&gt; 만 호출하는 빈 Observable입니다 .</target>
        </trans-unit>
        <trans-unit id="6e58713c020d2f707061137552b408199b941f2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Promise&amp;lt;void&amp;gt;&lt;/code&gt;: a promise that either resolves on observable completion or rejects with the handled error</source>
          <target state="translated">&lt;code&gt;Promise&amp;lt;void&amp;gt;&lt;/code&gt; : 관찰 가능한 완료시 해결되거나 처리 된 오류로 거부되는 약속</target>
        </trans-unit>
        <trans-unit id="cd50de8ad5bd5bb0c32bba750b39c2af3faa752d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SubscribeOnObservable&lt;/code&gt; is hidden from direct use in v6 and is accessible only through operator &lt;code&gt;subscribeOn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SubscribeOnObservable&lt;/code&gt; 은 v6에서 직접 사용하지 않도록 숨겨져 있으며 &lt;code&gt;subscribeOn&lt;/code&gt; 연산자를 통해서만 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d845fe57dde654307e9827b34a87ee47b1565c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Subscriber&amp;lt;T&amp;gt;&lt;/code&gt;: A Subscriber wrapping the (partially defined) Observer represented by the given arguments.</source>
          <target state="translated">&lt;code&gt;Subscriber&amp;lt;T&amp;gt;&lt;/code&gt; : 주어진 인수로 표시되는 (부분적으로 정의 된) 관찰자를 래핑하는 구독자입니다.</target>
        </trans-unit>
        <trans-unit id="e9296bc5910b2bafe547429ecf483eeaf5e40ba8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Subscription&lt;/code&gt;: A subscription in order to be able to unsubscribe the scheduled work.</source>
          <target state="translated">&lt;code&gt;Subscription&lt;/code&gt; : 예약 된 작업을 구독 취소 할 수있는 구독입니다.</target>
        </trans-unit>
        <trans-unit id="5eb8999b131bccb24bac0dc65dd7ee3184a724a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Subscription&lt;/code&gt;: Returns the Subscription used or created to be added to the inner subscriptions list. This Subscription can be used with &lt;code&gt;remove()&lt;/code&gt; to remove the passed teardown logic from the inner subscriptions list.</source>
          <target state="translated">&lt;code&gt;Subscription&lt;/code&gt; : 내부 구독 목록에 추가하기 위해 사용되거나 생성 된 구독을 반환합니다. 이 구독을 &lt;code&gt;remove()&lt;/code&gt; 와 함께 사용 하여 내부 구독 목록에서 전달 된 테어 다운 논리를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9751fe552726353c3cf0acaa69371203468189b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, ConnectableObservable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, ConnectableObservable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8caae40fe3d57bed9c2dba2b723525aef2fe63ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, ConnectableObservable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;: An observable sequence that contains the elements of a sequence produced by multicasting the source sequence.</source>
          <target state="translated">&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, ConnectableObservable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; : 소스 시퀀스를 멀티 캐스트하여 생성 된 시퀀스의 요소를 포함하는 관찰 가능한 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="0c0eb17bf7e6eda8feecbb427e767db2329c3198" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, [Observable&amp;lt;T&amp;gt;, Observable&amp;lt;T&amp;gt;]&amp;gt;&lt;/code&gt;: An array with two Observables: one with values that passed the predicate, and another with values that did not pass the predicate.</source>
          <target state="translated">&lt;code&gt;UnaryFunction&amp;lt;Observable&amp;lt;T&amp;gt;, [Observable&amp;lt;T&amp;gt;, Observable&amp;lt;T&amp;gt;]&amp;gt;&lt;/code&gt; : 두 개의 Observable이있는 배열 : 하나는 술어를 통과 한 값이 있고 다른 하나는 술어를 통과하지 않은 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="daa3594eaba6fa012b962e692bb34ebadc67452e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WebSocketSubject&amp;lt;T&amp;gt;&lt;/code&gt;: Subject which allows to both send and receive messages via WebSocket connection.</source>
          <target state="translated">&lt;code&gt;WebSocketSubject&amp;lt;T&amp;gt;&lt;/code&gt; : WebSocket 연결을 통해 메시지를주고받을 수있는 제목.</target>
        </trans-unit>
        <trans-unit id="b48aa90627a1c9215b79016aecac86a4deb348c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WebSocketSubject&lt;/code&gt; has an additional operator, not found in other Subjects. It is called &lt;code&gt;multiplex&lt;/code&gt; and it is used to simulate opening several socket connections, while in reality maintaining only one. For example, an application has both chat panel and real-time notifications about sport news. Since these are two distinct functions, it would make sense to have two separate connections for each. Perhaps there could even be two separate services with WebSocket endpoints, running on separate machines with only GUI combining them together. Having a socket connection for each functionality could become too resource expensive. It is a common pattern to have single WebSocket endpoint that acts as a gateway for the other services (in this case chat and sport news services). Even though there is a single connection in a client app, having the ability to manipulate streams as if it were two separate sockets is desirable. This eliminates manually registering and unregistering in a gateway for given service and filter out messages of interest. This is exactly what &lt;code&gt;multiplex&lt;/code&gt; method is for.</source>
          <target state="translated">&lt;code&gt;WebSocketSubject&lt;/code&gt; 에는 다른 주제에없는 추가 연산자가 있습니다. 그것은 &lt;code&gt;multiplex&lt;/code&gt; 라고 합니다 &lt;code&gt;multiplex&lt;/code&gt; 방법입니다.실제로는 하나의 소켓 만 유지하면서 여러 소켓 연결을 여는 것을 시뮬레이션하는 데 사용됩니다. 예를 들어, 응용 프로그램에는 스포츠 뉴스에 대한 채팅 패널과 실시간 알림이 모두 있습니다. 이들은 두 개의 고유 한 기능이므로 각각에 대해 두 개의 개별 연결을 갖는 것이 좋습니다. WebSocket 엔드 포인트가있는 별도의 서비스가 두 개있을 수 있으며 GUI 만 결합하여 별도의 시스템에서 실행될 수도 있습니다. 각 기능에 대한 소켓 연결이 너무 많은 자원이 될 수 있습니다. 다른 서비스 (이 경우 채팅 및 스포츠 뉴스 서비스)의 게이트웨이 역할을하는 단일 WebSocket 엔드 포인트를 갖는 것이 일반적인 패턴입니다. 클라이언트 앱에 단일 연결이 있더라도 스트림이 별도의 소켓 인 것처럼 조작 할 수있는 기능이 바람직합니다.이를 통해 지정된 서비스에 대해 게이트웨이에서 수동으로 등록 및 등록 취소 할 필요가 없으며 관심있는 메시지를 필터링 할 수 있습니다. 이것은 정확히 무엇입니까</target>
        </trans-unit>
        <trans-unit id="69561978d6621715d34ad8aac9add39a6dd9bc48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[0-9]+[ms|s|m]&lt;/code&gt; time progression: the time progression syntax lets you progress virtual time by a specific amount. It's a number, followed by a time unit of &lt;code&gt;ms&lt;/code&gt; (milliseconds), &lt;code&gt;s&lt;/code&gt; (seconds), or &lt;code&gt;m&lt;/code&gt; (minutes) without any space between them, e.g. &lt;code&gt;a 10ms b&lt;/code&gt;. See &lt;a href=&quot;marble-testing#time-progression-syntax&quot;&gt;Time progression syntax&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;[0-9]+[ms|s|m]&lt;/code&gt; 시간 진행 : 시간 진행 구문을 사용하면 가상 시간을 특정 양만큼 진행할 수 있습니다. 숫자이며 그 뒤에 공백이없는 시간 단위 &lt;code&gt;ms&lt;/code&gt; (밀리 초), &lt;code&gt;s&lt;/code&gt; (초) 또는 &lt;code&gt;m&lt;/code&gt; (분)입니다 (예 : &lt;code&gt;a 10ms b&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;marble-testing#time-progression-syntax&quot;&gt;시간 진행 구문&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="06d76181f50eed2bda7f22c043e74fa2ae4d0f2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[Observable&amp;lt;T&amp;gt;, Observable&amp;lt;T&amp;gt;]&lt;/code&gt;: An array with two Observables: one with values that passed the predicate, and another with values that did not pass the predicate.</source>
          <target state="translated">&lt;code&gt;[Observable&amp;lt;T&amp;gt;, Observable&amp;lt;T&amp;gt;]&lt;/code&gt; : 두 개의 Observable이있는 배열 : 하나는 술어를 전달한 값이 있고 다른 하나는 술어를 전달하지 않은 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7be0d73ff95f971ce3d0ec056f20b5e78d2401a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[a-z0-9]&lt;/code&gt; e.g. &lt;code&gt;'a'&lt;/code&gt; any alphanumeric character: Represents a value being emitted by the producer signaling &lt;code&gt;next()&lt;/code&gt;. Also consider that you could map this into an object or an array like this:</source>
          <target state="translated">&lt;code&gt;[a-z0-9]&lt;/code&gt; 예 : &lt;code&gt;'a'&lt;/code&gt; 임의의 영숫자 문자 : 생산자가 시그널링하는 &lt;code&gt;next()&lt;/code&gt; 의해 방출되는 값을 나타 냅니다. 또한 이것을 다음과 같은 객체 또는 배열에 매핑 할 수 있다고 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="76574adecd5f0112d1ef6e3dee5ffec9d1760f98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="1d66416b13f1e69be3b9fe9168a34eccd8117317" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asap&lt;/code&gt; scheduler behaves the same as &lt;a href=&quot;asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; scheduler when you use it to delay task in time. If however you set delay to &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;asap&lt;/code&gt; will wait for current synchronously executing code to end and then it will try to execute given task as fast as possible.</source>
          <target state="translated">&lt;code&gt;asap&lt;/code&gt; 스케줄러 를 사용하면 작업을 제 시간에 지연시키기 위해 &lt;a href=&quot;asyncscheduler&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt; 스케줄러 와 동일하게 작동합니다 . 그러나 당신이 세트 지연되면 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;asap&lt;/code&gt; 끝으로 현재 동 기적으로 실행 코드에 대한 대기 후는 가능한 한 빨리으로 주어진 작업을 실행하려고합니다.</target>
        </trans-unit>
        <trans-unit id="8d2f7871c278c3ff4f15d4e1797b46bd3a11325e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asap&lt;/code&gt; scheduler will do its best to minimize time between end of currently executing code and start of scheduled task. This makes it best candidate for performing so called &quot;deferring&quot;. Traditionally this was achieved by calling &lt;code&gt;setTimeout(deferredTask, 0)&lt;/code&gt;, but that technique involves some (although minimal) unwanted delay.</source>
          <target state="translated">&lt;code&gt;asap&lt;/code&gt; 스케줄러는 현재 실행중인 코드 종료와 예약 된 작업 시작 사이의 시간을 최소화하기 위해 최선을 다할 것입니다. 이것은 소위 &quot;지연&quot;을 수행하기에 가장 적합한 후보입니다. 전통적으로 이것은 &lt;code&gt;setTimeout(deferredTask, 0)&lt;/code&gt; 을 호출하여 이루어 졌지만,이 기법에는 약간의 원치 않는 지연이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="38282087e639f45cb81b714b183b93c266c618fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt; scheduler schedules tasks asynchronously, by putting them on the JavaScript event loop queue. It is best used to delay tasks in time or to schedule tasks repeating in intervals.</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; 스케줄러는 JavaScript 이벤트 루프 큐에 배치하여 작업을 비동기식으로 예약합니다. 작업을 제 시간에 지연 시키거나 간격을두고 반복되는 작업을 예약하는 데 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5f3bfc256736a1a2b56372aad02d0143b55bdd10" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;audit&lt;/code&gt; is similar to &lt;code&gt;throttle&lt;/code&gt;, but emits the last value from the silenced time window, instead of the first value. &lt;code&gt;audit&lt;/code&gt; emits the most recent value from the source Observable on the output Observable as soon as its internal timer becomes disabled, and ignores source values while the timer is enabled. Initially, the timer is disabled. As soon as the first source value arrives, the timer is enabled by calling the &lt;code&gt;durationSelector&lt;/code&gt; function with the source value, which returns the &quot;duration&quot; Observable. When the duration Observable emits a value or completes, the timer is disabled, then the most recent source value is emitted on the output Observable, and this process repeats for the next source value.</source>
          <target state="translated">&lt;code&gt;audit&lt;/code&gt; 는 &lt;code&gt;throttle&lt;/code&gt; 과 비슷 하지만 첫 번째 값 대신 무음 시간 창에서 마지막 값을 내 보냅니다. &lt;code&gt;audit&lt;/code&gt; 는 내부 타이머가 비활성화 되 자마자 출력 Observable의 소스 Observable에서 가장 최근 값을 내보내고 타이머가 활성화 된 동안 소스 값을 무시합니다. 처음에는 타이머가 비활성화되어 있습니다. 첫 번째 소스 값이 도착하자마자 &quot;duration&quot;Observable을 반환하는 소스 값으로 &lt;code&gt;durationSelector&lt;/code&gt; 함수를 호출하여 타이머가 활성화됩니다 . Observable 기간이 값을 방출하거나 완료되면 타이머가 비활성화되고 가장 최근의 소스 값이 출력 Observable에서 방출되며이 프로세스는 다음 소스 값에 대해 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="40805c639cd2c3fa224cf3a2a39ee4a56ef4f08e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;auditTime&lt;/code&gt; is similar to &lt;code&gt;throttleTime&lt;/code&gt;, but emits the last value from the silenced time window, instead of the first value. &lt;code&gt;auditTime&lt;/code&gt; emits the most recent value from the source Observable on the output Observable as soon as its internal timer becomes disabled, and ignores source values while the timer is enabled. Initially, the timer is disabled. As soon as the first source value arrives, the timer is enabled. After &lt;code&gt;duration&lt;/code&gt; milliseconds (or the time unit determined internally by the optional &lt;code&gt;scheduler&lt;/code&gt;) has passed, the timer is disabled, then the most recent source value is emitted on the output Observable, and this process repeats for the next source value. Optionally takes a &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; for managing timers.</source>
          <target state="translated">&lt;code&gt;auditTime&lt;/code&gt; 은 &lt;code&gt;throttleTime&lt;/code&gt; 과 유사 하지만 첫 번째 값 대신 무음 시간 창에서 마지막 값을 내 보냅니다 . &lt;code&gt;auditTime&lt;/code&gt; 은 내부 타이머가 비활성화 되 자마자 출력 Observable의 소스 Observable에서 가장 최근 값을 방출하고 타이머가 활성화 된 동안 소스 값을 무시합니다. 처음에는 타이머가 비활성화되어 있습니다. 첫 번째 소스 값에 도달하면 타이머가 활성화됩니다. 후 &lt;code&gt;duration&lt;/code&gt; 밀리 초 (또는 시간 단위는 선택적으로 내부 결정 &lt;code&gt;scheduler&lt;/code&gt; 경과), 상기 타이머는 가장 최근의 소스 값 관측 가능한 출력을 방출하고, 비활성화하고, 다음의 소스 값이 과정을 반복. 선택적으로 &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt; 처럼 타이머 관리를 위해.</target>
        </trans-unit>
        <trans-unit id="0b2f0508ff5d8cf3b8a58819217df8e1f5a557ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bindCallback&lt;/code&gt; is not an operator because its input and output are not Observables. The input is a function &lt;code&gt;func&lt;/code&gt; with some parameters. The last parameter must be a callback function that &lt;code&gt;func&lt;/code&gt; calls when it is done.</source>
          <target state="translated">&lt;code&gt;bindCallback&lt;/code&gt; 은 입력 및 출력이 Observable이 아니므로 연산자가 아닙니다. 입력은 일부 매개 변수 가있는 함수 &lt;code&gt;func&lt;/code&gt; 입니다. 마지막 매개 변수는 콜백 함수 여야합니다. &lt;code&gt;func&lt;/code&gt; 는 완료시 func이 호출 .</target>
        </trans-unit>
        <trans-unit id="9211f4b858fc968794a77bc7b1d03546135e6858" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bindNodeCallback&lt;/code&gt; is not an operator because its input and output are not Observables. The input is a function &lt;code&gt;func&lt;/code&gt; with some parameters, but the last parameter must be a callback function that &lt;code&gt;func&lt;/code&gt; calls when it is done. The callback function is expected to follow Node.js conventions, where the first argument to the callback is an error object, signaling whether call was successful. If that object is passed to callback, it means something went wrong.</source>
          <target state="translated">&lt;code&gt;bindNodeCallback&lt;/code&gt; 은 입력 및 출력이 Observable이 아니므로 연산자가 아닙니다. 입력은 일부 매개 변수 가있는 함수 &lt;code&gt;func&lt;/code&gt; 이지만 마지막 매개 변수 는 완료시 &lt;code&gt;func&lt;/code&gt; 이 호출 하는 콜백 함수 여야합니다 . 콜백 함수는 Node.js 규칙을 따라야합니다. 여기서 콜백의 첫 번째 인수는 호출의 성공 여부를 나타내는 오류 객체입니다. 해당 객체가 콜백에 전달되면 문제가 발생한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b958fd92ecb9faf8ae58cd7ebc6f92725abe218c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; -&amp;gt; &lt;code&gt;catchError&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; -&amp;gt; &lt;code&gt;catchError&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="090112e53789f1e202cdc6c3e33483de9d1744a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;class&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a862595a3c1548793957cd83ac96a6a641a31216" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;class&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="48fe30ff9e2a9d2bcaf4ee2c5d861788e26cdd20" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cold(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; - creates a &lt;a href=&quot;https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339&quot;&gt;&quot;cold&quot; observable&lt;/a&gt; whose subscription starts when the test begins.</source>
          <target state="translated">&lt;code&gt;cold(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; -생성합니다&lt;a href=&quot;https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339&quot;&gt;&lt;/a&gt; 테스트가 시작될 때 구독이 시작 &quot;감기&quot;관찰 가능을 .</target>
        </trans-unit>
        <trans-unit id="86ed056620603316b0dd1656f24b1776a713dcee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cold(marbles: string, values?: object, error?: any)&lt;/code&gt; - creates a &quot;cold&quot; observable whose subscription starts when the test begins.</source>
          <target state="translated">&lt;code&gt;cold(marbles: string, values?: object, error?: any)&lt;/code&gt; -테스트가 시작될 때 구독이 시작되는 &quot;감기&quot;관찰 가능을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f6b28dc7fe98921afceb99175e066d6a87d85a26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineAll&lt;/code&gt; takes an Observable of Observables, and collects all Observables from it. Once the outer Observable completes, it subscribes to all collected Observables and combines their values using the &lt;a href=&quot;../index/function/combinelatest&quot;&gt;&lt;code&gt;combineLatest&lt;/code&gt;&lt;/a&gt; strategy, such that:</source>
          <target state="translated">&lt;code&gt;combineAll&lt;/code&gt; 은 Observables of Observables를 가져 와서 Observable을 모두 수집합니다. 외부 Observable이 완료되면 수집 된 모든 Observable을 구독하고 &lt;a href=&quot;../index/function/combinelatest&quot;&gt; &lt;code&gt;combineLatest&lt;/code&gt; 를&lt;/a&gt; 사용하여 해당 값을 결합합니다. 전략을 합니다.</target>
        </trans-unit>
        <trans-unit id="c48c87a64f802358b3ec81f54db717377180b5f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineLatest&lt;/code&gt; accepts as optional parameter &lt;code&gt;project&lt;/code&gt; function, which takes as arguments all values that would normally be emitted by resulting Observable. &lt;code&gt;project&lt;/code&gt; can return any kind of value, which will be then emitted by Observable instead of default array. Note that &lt;code&gt;project&lt;/code&gt; does not take as argument that array of values, but values themselves. That means default &lt;code&gt;project&lt;/code&gt; can be imagined as function that takes all its arguments and puts them into an array.</source>
          <target state="translated">&lt;code&gt;combineLatest&lt;/code&gt; 는 선택적 매개 변수 &lt;code&gt;project&lt;/code&gt; 함수 로 허용되며 , Observable 결과로 생성되는 모든 값을 인수로 사용합니다. &lt;code&gt;project&lt;/code&gt; 는 모든 종류의 값을 반환 할 수 있으며 기본 배열 대신 Observable에서 방출됩니다. 참고 &lt;code&gt;project&lt;/code&gt; 인수로 값의 배열을 고려하지 않고, 값 자체. 즉, 기본 &lt;code&gt;project&lt;/code&gt; 는 모든 인수를 가져 와서 배열에 넣는 함수로 상상할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0acc0a59cb9c4861d27d529a998d4109e7b2dd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineLatest&lt;/code&gt; combines the values from all the Observables passed as arguments. This is done by subscribing to each Observable in order and, whenever any Observable emits, collecting an array of the most recent values from each Observable. So if you pass &lt;code&gt;n&lt;/code&gt; Observables to operator, returned Observable will always emit an array of &lt;code&gt;n&lt;/code&gt; values, in order corresponding to order of passed Observables (value from the first Observable on the first place and so on).</source>
          <target state="translated">&lt;code&gt;combineLatest&lt;/code&gt; 는 인수로 전달 된 모든 Observable의 값을 결합합니다. 이는 각 Observable을 순서대로 구독하고 Observable이 발생할 때마다 각 Observable에서 최신 값의 배열을 수집하여 수행됩니다. 따라서 &lt;code&gt;n&lt;/code&gt; Observables를 연산자 에게 전달하면 반환 된 Observable은 전달 된 Observable의 순서 (처음부터 첫 번째 Observable의 값 등)에 따라 순서대로 &lt;code&gt;n&lt;/code&gt; 값 의 배열을 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="01ad8a728f3323a7a044e430120e60f1ce5b8a98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concat&lt;/code&gt; joins multiple Observables together, by subscribing to them one at a time and merging their results into the output Observable. You can pass either an array of Observables, or put them directly as arguments. Passing an empty array will result in Observable that completes immediately.</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; 은 한 번에 하나씩 구독하고 결과를 출력 Observable에 병합하여 여러 Observable을 결합합니다. Observables 배열을 전달하거나 인수로 직접 넣을 수 있습니다. 빈 배열을 전달하면 Observable이 즉시 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="cd455e398737536791faa98b5aaf7d26b9064afe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;concat&lt;/code&gt; will subscribe to first input Observable and emit all its values, without changing or affecting them in any way. When that Observable completes, it will subscribe to then next Observable passed and, again, emit its values. This will be repeated, until the operator runs out of Observables. When last input Observable completes, &lt;code&gt;concat&lt;/code&gt; will complete as well. At any given moment only one Observable passed to operator emits values. If you would like to emit values from passed Observables concurrently, check out &lt;a href=&quot;merge&quot;&gt;&lt;code&gt;merge&lt;/code&gt;&lt;/a&gt; instead, especially with optional &lt;code&gt;concurrent&lt;/code&gt; parameter. As a matter of fact, &lt;code&gt;concat&lt;/code&gt; is an equivalent of &lt;code&gt;merge&lt;/code&gt; operator with &lt;code&gt;concurrent&lt;/code&gt; parameter set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; 은 첫 번째 입력 Observable을 구독하고 어떤 식 으로든 변경하거나 영향을주지 않으면 서 모든 값을 내 보냅니다. 해당 Observable이 완료되면 다음 Observable에 가입 ​​한 후 다시 해당 값을 내 보냅니다. 작업자가 Observables가 없어 질 때까지이 과정이 반복됩니다. 마지막 입력 Observable이 완료되면 &lt;code&gt;concat&lt;/code&gt; 도 완료됩니다. 주어진 순간에 오직 하나의 Observable만이 운영자에게 전달됩니다. 전달 된 Observables에서 동시에 값을 내보내려면 , 특히 선택적 &lt;code&gt;concurrent&lt;/code&gt; 매개 변수를 사용 하여 &lt;a href=&quot;merge&quot;&gt; &lt;code&gt;merge&lt;/code&gt; &lt;/a&gt; 대신 확인하십시오 . 사실 &lt;code&gt;concat&lt;/code&gt; 은 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;merge&lt;/code&gt; 연산자와 같습니다 . &lt;code&gt;concurrent&lt;/code&gt; 매개 변수가로 설정된</target>
        </trans-unit>
        <trans-unit id="385581e593ae600c22359073bd8d84c8d9c69e58" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a4d3fc4b7f98a5a344bac51798dbde83d943597" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count&lt;/code&gt; transforms an Observable that emits values into an Observable that emits a single value that represents the number of values emitted by the source Observable. If the source Observable terminates with an error, &lt;code&gt;count&lt;/code&gt; will pass this error notification along without emitting a value first. If the source Observable does not terminate at all, &lt;code&gt;count&lt;/code&gt; will neither emit a value nor terminate. This operator takes an optional &lt;code&gt;predicate&lt;/code&gt; function as argument, in which case the output emission will represent the number of source values that matched &lt;code&gt;true&lt;/code&gt; with the &lt;code&gt;predicate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 는 값을 방출하는 Observable을 소스 Observable이 방출 한 값의 수를 나타내는 단일 값을 방출하는 Observable로 변환합니다. 소스 Observable 이 오류 와 함께 종료되면 &lt;code&gt;count&lt;/code&gt; 는 값을 먼저 표시하지 않고이 오류 알림을 전달합니다. 소스 Observable이 전혀 종료되지 않으면 &lt;code&gt;count&lt;/code&gt; 는 값을 내보내거나 종료하지 않습니다. 이 연산자는 선택적 &lt;code&gt;predicate&lt;/code&gt; 함수를 인수로 사용하며,이 경우 출력 방출은 &lt;code&gt;predicate&lt;/code&gt; 와 &lt;code&gt;true&lt;/code&gt; 로 일치하는 소스 값 수를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f0cdc1ef62ba04465e2f72df3b6dbbf436fe86ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;debounce&lt;/code&gt; delays values emitted by the source Observable, but drops previous pending delayed emissions if a new value arrives on the source Observable. This operator keeps track of the most recent value from the source Observable, and spawns a duration Observable by calling the &lt;code&gt;durationSelector&lt;/code&gt; function. The value is emitted only when the duration Observable emits a value or completes, and if no other value was emitted on the source Observable since the duration Observable was spawned. If a new value appears before the duration Observable emits, the previous value will be dropped and will not be emitted on the output Observable.</source>
          <target state="translated">&lt;code&gt;debounce&lt;/code&gt; 는 소스 Observable에 의해 방출 된 값을 지연 시키지만, 새로운 값이 소스 Observable에 도달하면 대기중인 지연 방출을 줄입니다. 이 연산자는 소스 Observable에서 가장 최근 값을 추적하고 &lt;code&gt;durationSelector&lt;/code&gt; 함수 를 호출하여 Duration Observable을 생성합니다 . Observable 기간이 값을 생성하거나 완료 할 때와 Observable 기간이 생성 된 이후 소스 Observable에서 다른 값이 방출되지 않은 경우에만 값이 생성됩니다. Observable이 방출하기 전에 새로운 값이 표시되면 이전 값이 삭제되고 출력 Observable에서 방출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37876e5463e7779e33fb2f769015b62934416edb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;debounceTime&lt;/code&gt; delays values emitted by the source Observable, but drops previous pending delayed emissions if a new value arrives on the source Observable. This operator keeps track of the most recent value from the source Observable, and emits that only when &lt;code&gt;dueTime&lt;/code&gt; enough time has passed without any other value appearing on the source Observable. If a new value appears before &lt;code&gt;dueTime&lt;/code&gt; silence occurs, the previous value will be dropped and will not be emitted on the output Observable.</source>
          <target state="translated">&lt;code&gt;debounceTime&lt;/code&gt; 은 소스 Observable에 의해 방출 된 값을 지연 시키지만, 새로운 값이 소스 Observable에 도달하면 대기중인 지연 방출을 줄입니다. 이 연산자는 소스 Observable에서 가장 최근 값을 추적하며 소스 Observable에 다른 값이 표시되지 않고 &lt;code&gt;dueTime&lt;/code&gt; 이 충분한 시간이 경과 한 경우에만이를 방출합니다 . &lt;code&gt;dueTime&lt;/code&gt; 침묵이 발생 하기 전에 새 값이 표시 되면 이전 값이 삭제되고 출력 Observable에서 방출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c49335f81d19a51a43bd936b56c74ed6776fb327" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defaultIfEmpty&lt;/code&gt; emits the values emitted by the source Observable or a specified default value if the source Observable is empty (completes without having emitted any &lt;code&gt;next&lt;/code&gt; value).</source>
          <target state="translated">&lt;code&gt;defaultIfEmpty&lt;/code&gt; 는 소스 Observable에서 생성 된 값을 내보내거나 소스 Observable이 비어있는 경우 지정된 기본값을 생성합니다 ( &lt;code&gt;next&lt;/code&gt; 값을 생성 하지 않고 완료 ).</target>
        </trans-unit>
        <trans-unit id="b48bcd84068ffa0b67531f2cc7d97d7b8ddcc69e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;defer&lt;/code&gt; allows you to create the Observable only when the Observer subscribes, and create a fresh Observable for each Observer. It waits until an Observer subscribes to it, and then it generates an Observable, typically with an Observable factory function. It does this afresh for each subscriber, so although each subscriber may think it is subscribing to the same Observable, in fact each subscriber gets its own individual Observable.</source>
          <target state="translated">&lt;code&gt;defer&lt;/code&gt; 사용하면 Observer가 구독 할 때만 Observable을 만들고 각 Observer에 대해 새로운 Observable을 만들 수 있습니다. Observer가 구독 할 때까지 기다린 다음 일반적으로 Observable 팩토리 기능을 사용하여 Observable을 생성합니다. 각 구독자마다 새로 고쳐 지므로 각 구독자가 동일한 Observable을 구독한다고 생각할 수 있지만 실제로 각 구독자는 고유 한 Observable을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="5eaa3f953343c295087c9f21c5472ac2c26f0955" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;delayWhen&lt;/code&gt; time shifts each emitted value from the source Observable by a time span determined by another Observable. When the source emits a value, the &lt;code&gt;delayDurationSelector&lt;/code&gt; function is called with the source value as argument, and should return an Observable, called the &quot;duration&quot; Observable. The source value is emitted on the output Observable only when the duration Observable emits a value or completes. The completion of the notifier triggering the emission of the source value is deprecated behavior and will be removed in future versions.</source>
          <target state="translated">&lt;code&gt;delayWhen&lt;/code&gt; 시간이 다른 Observable에 의해 결정된 시간 범위만큼 소스 Observable에서 방출 된 각 값을 이동할 때. 소스가 값을 생성하면 &lt;code&gt;delayDurationSelector&lt;/code&gt; 함수가 소스 값을 인수로 사용하여 호출되며 &quot;duration&quot;Observable이라는 Observable을 반환해야합니다. Observable 기간이 값을 방출하거나 완료 할 때만 소스 값이 출력 Observable에서 방출됩니다. 소스 값의 방출을 트리거하는 알리미의 완료는 더 이상 사용되지 않으며 향후 버전에서 제거 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="263c061588410725a4756688a261e25ff539d88a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dematerialize&lt;/code&gt; is assumed to operate an Observable that only emits &lt;a href=&quot;../index/class/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; objects as &lt;code&gt;next&lt;/code&gt; emissions, and does not emit any &lt;code&gt;error&lt;/code&gt;. Such Observable is the output of a &lt;code&gt;materialize&lt;/code&gt; operation. Those notifications are then unwrapped using the metadata they contain, and emitted as &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, and &lt;code&gt;complete&lt;/code&gt; on the output Observable.</source>
          <target state="translated">&lt;code&gt;dematerialize&lt;/code&gt; 는 &lt;a href=&quot;../index/class/notification&quot;&gt; &lt;code&gt;Notification&lt;/code&gt; &lt;/a&gt; 객체 만 &lt;code&gt;next&lt;/code&gt; 방출 로만 방출하고 &lt;code&gt;error&lt;/code&gt; 시키지 않는 Observable을 작동한다고 가정합니다 . 그러한 관찰은 &lt;code&gt;materialize&lt;/code&gt; 작업 의 결과물입니다 . 그런 다음 해당 알림은 포함 된 메타 데이터를 사용하여 래핑 해제하고 &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;error&lt;/code&gt; 로 생성되며 출력 Observable에서 &lt;code&gt;complete&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="337f0156035bbe32cb1c65689f5ceaab1523241c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;distinctUntilKeyChanged&lt;/code&gt; emits all items of the source Observable, wich are distinct by comparison. The comparison checks if the previous item is distinct from the current item, using a &lt;code&gt;key&lt;/code&gt; to access a property. If a comparator function is provided, then it will be called for each item with the property key to test for whether or not that value should be emitted.</source>
          <target state="translated">&lt;code&gt;distinctUntilKeyChanged&lt;/code&gt; 는 소스 Observable의 모든 항목을 내 보냅니다. 비교는 &lt;code&gt;key&lt;/code&gt; 를 사용하여 속성에 액세스 하여 이전 항목이 현재 항목과 다른지 확인합니다 . 비교기 기능이 제공되면 속성 키를 사용하여 각 항목에 대해 호출되어 해당 값의 방출 여부를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="c68787b081b8a13ef3a2883757212c65f8a16510" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt; -&amp;gt; &lt;code&gt;tap&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; -&amp;gt; &lt;code&gt;tap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7709400aa46a908f912c42fdd85c31afe4bd334c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;elementAt&lt;/code&gt; returns an Observable that emits the item at the specified &lt;code&gt;index&lt;/code&gt; in the source Observable, or a default value if that &lt;code&gt;index&lt;/code&gt; is out of range and the &lt;code&gt;default&lt;/code&gt; argument is provided. If the &lt;code&gt;default&lt;/code&gt; argument is not given and the &lt;code&gt;index&lt;/code&gt; is out of range, the output Observable will emit an &lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; error.</source>
          <target state="translated">&lt;code&gt;elementAt&lt;/code&gt; 는 소스 Observable 의 지정된 &lt;code&gt;index&lt;/code&gt; 에서 항목을 내보내는 Observable을 반환 하거나 해당 &lt;code&gt;index&lt;/code&gt; 가 범위를 벗어난 상태에서 &lt;code&gt;default&lt;/code&gt; 인수가 제공되는 경우 기본값을 반환합니다 . 경우 &lt;code&gt;default&lt;/code&gt; 인수를 제공하고 있지 않습니다 &lt;code&gt;index&lt;/code&gt; 범위를 벗어나, 출력 관찰 가능한가 방출됩니다 &lt;code&gt;ArgumentOutOfRangeError&lt;/code&gt; 의 오류입니다.</target>
        </trans-unit>
        <trans-unit id="48cd8a1eb0de7b3c8ccb7d3f4b8f0aab446953b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76ad9b9d842a773470337752107150337d51fd75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exhaust&lt;/code&gt; subscribes to an Observable that emits Observables, also known as a higher-order Observable. Each time it observes one of these emitted inner Observables, the output Observable begins emitting the items emitted by that inner Observable. So far, it behaves like &lt;a href=&quot;mergeall&quot;&gt;&lt;code&gt;mergeAll&lt;/code&gt;&lt;/a&gt;. However, &lt;code&gt;exhaust&lt;/code&gt; ignores every new inner Observable if the previous Observable has not yet completed. Once that one completes, it will accept and flatten the next inner Observable and repeat this process.</source>
          <target state="translated">&lt;code&gt;exhaust&lt;/code&gt; 는 Observable을 방출하는 Observable을 구독하며, 상위 Observable이라고도합니다. 방출 된 내부 Observable 중 하나를 관찰 할 때마다 출력 Observable은 해당 내부 Observable이 방출 한 항목을 방출하기 시작합니다. 지금까지는 &lt;a href=&quot;mergeall&quot;&gt; &lt;code&gt;mergeAll&lt;/code&gt; &lt;/a&gt; 처럼 동작 합니다. 그러나 이전 Observable이 아직 완료되지 않은 경우 &lt;code&gt;exhaust&lt;/code&gt; 는 모든 새로운 내부 Observable을 무시합니다. 이 작업이 완료되면 다음 내부 Observable을 수락하고 평탄화하고이 프로세스를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="40ffb7c8fd558d6f81aaa088689dbebae17d57a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expectObservable(actual: Observable&amp;lt;T&amp;gt;).toBe(marbles: string, values?: object, error?: any)&lt;/code&gt; - schedules an assertion for when the TestScheduler flushes. The TestScheduler will automatically flush at the end of your jasmine &lt;code&gt;it&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;expectObservable(actual: Observable&amp;lt;T&amp;gt;).toBe(marbles: string, values?: object, error?: any)&lt;/code&gt; -TestScheduler가 플러시 될 때의 어설 션을 예약합니다. Jasmine &lt;code&gt;it&lt;/code&gt; 블록 이 끝나면 TestScheduler가 자동으로 플러시됩니다 .</target>
        </trans-unit>
        <trans-unit id="549efb9322293515e99c072f635c335f7dea77ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expectObservable(actual: Observable&amp;lt;T&amp;gt;, subscriptionMarbles?: string).toBe(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; - schedules an assertion for when the TestScheduler flushes. Give &lt;code&gt;subscriptionMarbles&lt;/code&gt; as parameter to change the schedule of subscription and unsubscription. If you don't provide the &lt;code&gt;subscriptionMarbles&lt;/code&gt; parameter it will subscribe at the beginning and never unsubscribe. Read below about subscription marble diagram.</source>
          <target state="translated">&lt;code&gt;expectObservable(actual: Observable&amp;lt;T&amp;gt;, subscriptionMarbles?: string).toBe(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; -TestScheduler가 플러시 될 때의 어설 션을 예약합니다. subscription 및 unsubscription 일정을 변경하려면 &lt;code&gt;subscriptionMarbles&lt;/code&gt; 를 매개 변수로 제공하십시오 . &lt;code&gt;subscriptionMarbles&lt;/code&gt; 매개 변수를 제공하지 않으면 처음에 구독하고 구독을 취소하지 않습니다. 서브 스크립 션 대리석 다이어그램에 대해 아래에서 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="b7e81cef1adea62fe9dabc7f8970e2ecbcee0d1b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]).toBe(subscriptionMarbles: string)&lt;/code&gt; - like &lt;code&gt;expectObservable&lt;/code&gt; schedules an assertion for when the testScheduler flushes. Both &lt;code&gt;cold()&lt;/code&gt; and &lt;code&gt;hot()&lt;/code&gt; return an observable with a property &lt;code&gt;subscriptions&lt;/code&gt; of type &lt;code&gt;SubscriptionLog[]&lt;/code&gt;. Give &lt;code&gt;subscriptions&lt;/code&gt; as parameter to &lt;code&gt;expectSubscriptions&lt;/code&gt; to assert whether it matches the &lt;code&gt;subscriptionsMarbles&lt;/code&gt; marble diagram given in &lt;code&gt;toBe()&lt;/code&gt;. Subscription marble diagrams are slightly different than Observable marble diagrams. Read more below.</source>
          <target state="translated">&lt;code&gt;expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]).toBe(subscriptionMarbles: string)&lt;/code&gt; &lt;code&gt;expectObservable&lt;/code&gt; 과 마찬가지로 testScheduler가 플러시 될 때 어설 션을 예약합니다. &lt;code&gt;cold()&lt;/code&gt; 와 &lt;code&gt;hot()&lt;/code&gt; 모두 &lt;code&gt;SubscriptionLog[]&lt;/code&gt; 유형 의 등록 &lt;code&gt;subscriptions&lt;/code&gt; 을 가진 옵저버 블을 반환합니다 . 부여 &lt;code&gt;subscriptions&lt;/code&gt; 에 매개 변수로 &lt;code&gt;expectSubscriptions&lt;/code&gt; 가 일치하는지 여부 주장을 &lt;code&gt;subscriptionsMarbles&lt;/code&gt; 의 주어진 대리석 다이어그램 &lt;code&gt;toBe()&lt;/code&gt; . 서브 스크립 션 대리석 다이어그램은 Observable 대리석 다이어그램과 약간 다릅니다. 아래에서 더 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="468eda33598bc9af7354a4a5ba445b8895a6ac71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;finally&lt;/code&gt; -&amp;gt; &lt;code&gt;finalize&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;finally&lt;/code&gt; -&amp;gt; &lt;code&gt;finalize&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="513a86951178ed9972ed24317636bd2a20645e11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;find&lt;/code&gt; searches for the first item in the source Observable that matches the specified condition embodied by the &lt;code&gt;predicate&lt;/code&gt;, and returns the first occurrence in the source. Unlike &lt;a href=&quot;first&quot;&gt;&lt;code&gt;first&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;predicate&lt;/code&gt; is required in &lt;code&gt;find&lt;/code&gt;, and does not emit an error if a valid value is not found.</source>
          <target state="translated">&lt;code&gt;find&lt;/code&gt; &lt;code&gt;predicate&lt;/code&gt; 의해 구체화 된 지정된 조건과 일치하는 소스 Observable에서 첫 번째 항목을 검색하고 소스에서 첫 번째 항목을 리턴합니다. 달리 &lt;a href=&quot;first&quot;&gt; &lt;code&gt;first&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;predicate&lt;/code&gt; 필요합니다 &lt;code&gt;find&lt;/code&gt; , 유효한 값을 찾을 수없는 경우 오류를 방출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42f3c71e5ee0b7b93c06c1bd1e67828f7bee0200" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;findIndex&lt;/code&gt; searches for the first item in the source Observable that matches the specified condition embodied by the &lt;code&gt;predicate&lt;/code&gt;, and returns the (zero-based) index of the first occurrence in the source. Unlike &lt;a href=&quot;first&quot;&gt;&lt;code&gt;first&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;predicate&lt;/code&gt; is required in &lt;code&gt;findIndex&lt;/code&gt;, and does not emit an error if a valid value is not found.</source>
          <target state="translated">&lt;code&gt;findIndex&lt;/code&gt; 는 &lt;code&gt;predicate&lt;/code&gt; 의해 구체화 된 지정된 조건과 일치하는 소스 Observable에서 첫 번째 항목을 검색하고 소스 에서 첫 번째 발생의 인덱스 (0부터 시작)를 리턴합니다. 달리 &lt;a href=&quot;first&quot;&gt; &lt;code&gt;first&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;predicate&lt;/code&gt; 필요하다 &lt;code&gt;findIndex&lt;/code&gt; , 유효한 값이 발견되지 않는 경우, 에러를 방출하지 않는다.</target>
        </trans-unit>
        <trans-unit id="bbafc7127363c7baba3b13392ba68a2794417a48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flush()&lt;/code&gt; - immediately starts virtual time. Not often used since &lt;code&gt;run()&lt;/code&gt; will automatically flush for you when your callback returns, but in some cases you may wish to flush more than once or otherwise have more control.</source>
          <target state="translated">&lt;code&gt;flush()&lt;/code&gt; -즉시 가상 시간을 시작합니다. 콜백이 반환되면 &lt;code&gt;run()&lt;/code&gt; 이 자동으로 플러시 되기 때문에 자주 사용되지 는 않지만, 경우에 따라 두 번 이상 플러시하거나 더 많은 제어 권한을 갖고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a725c42c24e4558c24a6dceba8ebb231a13bba5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forkJoin&lt;/code&gt; is an operator that takes any number of input observables which can be passed either as an array or a dictionary of input observables. If no input observables are provided, resulting stream will complete immediately.</source>
          <target state="translated">&lt;code&gt;forkJoin&lt;/code&gt; 은 배열 또는 입력 관측 가능 사전으로 전달 될 수있는 입력 관측 가능 수를 가져 오는 연산자입니다. 입력 옵저버 블이 제공되지 않으면 결과 스트림이 즉시 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="7d066c42163ed51de74c8d0a23c6fbe14edf715a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forkJoin&lt;/code&gt; will wait for all passed observables to complete and then it will emit an array or an object with last values from corresponding observables.</source>
          <target state="translated">&lt;code&gt;forkJoin&lt;/code&gt; 은 전달 된 모든 관찰 가능 항목이 완료 될 때까지 기다린 다음 해당 관찰 가능 항목의 마지막 값을 가진 배열 또는 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="701b8bcaf7f433faa8857e32bc6ab6cb78a529cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;from&lt;/code&gt; converts various other objects and data types into Observables. It also converts a Promise, an array-like, or an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable&quot;&gt;iterable&lt;/a&gt; object into an Observable that emits the items in that promise, array, or iterable. A String, in this context, is treated as an array of characters. Observable-like objects (contains a function named with the ES2015 Symbol for Observable) can also be converted through this operator.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 은 다양한 다른 객체 및 데이터 유형을 Observables로 변환합니다. 또한 약속, 배열 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable&quot;&gt;반복 가능한&lt;/a&gt; 개체를 해당 약속, 배열 또는 반복 가능한 항목을 내보내는 Observable로 변환합니다. 이 문맥에서 문자열은 문자 배열로 취급됩니다. 이 연산자를 통해 Observable과 유사한 객체 (ES2015 Symbol for Observable로 이름 지정된 함수를 포함)도 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6cd47e56e386e34dc898b3c2f75f66f676fe304" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromEvent&lt;/code&gt; accepts as a first argument event target, which is an object with methods for registering event handler functions. As a second argument it takes string that indicates type of event we want to listen for. &lt;code&gt;fromEvent&lt;/code&gt; supports selected types of event targets, which are described in detail below. If your event target does not match any of the ones listed, you should use &lt;a href=&quot;fromeventpattern&quot;&gt;&lt;code&gt;fromEventPattern&lt;/code&gt;&lt;/a&gt;, which can be used on arbitrary APIs. When it comes to APIs supported by &lt;code&gt;fromEvent&lt;/code&gt;, their methods for adding and removing event handler functions have different names, but they all accept a string describing event type and function itself, which will be called whenever said event happens.</source>
          <target state="translated">&lt;code&gt;fromEvent&lt;/code&gt; 는 첫 번째 인수 이벤트 대상으로 허용되며, 이는 이벤트 핸들러 함수를 등록하기위한 메소드가있는 오브젝트입니다. 두 번째 인수로 듣고 싶은 이벤트 유형을 나타내는 문자열이 사용됩니다. &lt;code&gt;fromEvent&lt;/code&gt; 는 선택된 유형의 이벤트 대상을 지원하며, 이에 대해서는 아래에서 자세히 설명합니다. 이벤트 대상이 나열된 대상과 일치하지 않으면 임의의 API에서 사용할 수있는 &lt;a href=&quot;fromeventpattern&quot;&gt; &lt;code&gt;fromEventPattern&lt;/code&gt; &lt;/a&gt; 을 사용해야합니다 . &lt;code&gt;fromEvent&lt;/code&gt; 가 지원하는 API의 경우 이벤트 핸들러 함수를 추가 및 제거하는 메소드의 이름이 다르지만 모두 이벤트 유형 및 함수 자체를 설명하는 문자열을 허용하며, 이는 해당 이벤트가 발생할 때마다 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1462671f1cb00bce6cf0a828bb7679536e52712a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromEvent&lt;/code&gt; supports following types of event targets:</source>
          <target state="translated">&lt;code&gt;fromEvent&lt;/code&gt; 는 다음 유형의 이벤트 대상을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="63e874687188bf84e0cd65512816c5a08aed1deb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fromEventPattern&lt;/code&gt; allows you to convert into an Observable any API that supports registering handler functions for events. It is similar to &lt;a href=&quot;fromevent&quot;&gt;&lt;code&gt;fromEvent&lt;/code&gt;&lt;/a&gt;, but far more flexible. In fact, all use cases of &lt;a href=&quot;fromevent&quot;&gt;&lt;code&gt;fromEvent&lt;/code&gt;&lt;/a&gt; could be easily handled by &lt;code&gt;fromEventPattern&lt;/code&gt; (although in slightly more verbose way).</source>
          <target state="translated">&lt;code&gt;fromEventPattern&lt;/code&gt; 을 사용하면 이벤트 처리기 기능 등록을 지원하는 모든 API를 Observable로 변환 할 수 있습니다. &lt;a href=&quot;fromevent&quot;&gt; &lt;code&gt;fromEvent&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 훨씬 유연합니다. 사실, 모든 사용 사례 &lt;a href=&quot;fromevent&quot;&gt; &lt;code&gt;fromEvent&lt;/code&gt; 는&lt;/a&gt; 쉽게 처리 할 수 &lt;code&gt;fromEventPattern&lt;/code&gt; (비록 약간 더 자세한 방법)을.</target>
        </trans-unit>
        <trans-unit id="0e7665a15f690a6c0179b0183091da0c68190f5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;func.call()&lt;/code&gt; means &quot;&lt;em&gt;give me one value synchronously&lt;/em&gt;&quot;</source>
          <target state="translated">&lt;code&gt;func.call()&lt;/code&gt; 은 &quot; &lt;em&gt;동 기적으로 하나의 값을 제공합니다&lt;/em&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="8fe45d23f684b15638587a600e466d7276009066" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;function&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="81fd3bab51295b9b61c59cc065e6349a7f240f69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;function&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3ba75bfe8b6d2f7dad160fa84807c8529ff10b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;generate&lt;/code&gt; allows you to create stream of values generated with a loop very similar to traditional for loop. First argument of &lt;code&gt;generate&lt;/code&gt; is a beginning value. Second argument is a function that accepts this value and tests if some condition still holds. If it does, loop continues, if not, it stops. Third value is a function which takes previously defined value and modifies it in some way on each iteration. Note how these three parameters are direct equivalents of three expressions in regular for loop: first expression initializes some state (for example numeric index), second tests if loop can make next iteration (for example if index is lower than 10) and third states how defined value will be modified on every step (index will be incremented by one).</source>
          <target state="translated">&lt;code&gt;generate&lt;/code&gt; 를 사용하면 기존 for 루프와 매우 유사한 루프로 생성 된 값 스트림을 작성할 수 있습니다. &lt;code&gt;generate&lt;/code&gt; 의 첫 번째 인수 는 시작 값입니다. 두 번째 인수는이 값을 받아들이고 일부 조건이 여전히 유지되는지 테스트하는 함수입니다. 그렇지 않으면 루프가 계속되고, 그렇지 않으면 중지됩니다. 세 번째 값은 이전에 정의 된 값을 가져 와서 각 반복에서 어떤 방식 으로든 수정하는 함수입니다. 이 세 매개 변수가 정규 for 루프에서 세 개의 표현식과 직접 등가 인 방법에 주목하십시오. 첫 번째 표현식은 일부 상태 (예 : 숫자 인덱스)를 초기화하고 두 번째 루프는 다음 반복을 수행 할 수 있는지 테스트합니다 (예 : 인덱스가 10보다 낮은 경우). 정의 된 값은 모든 단계에서 수정됩니다 (색인은 1 씩 증가합니다).</target>
        </trans-unit>
        <trans-unit id="94c16493b674e13437dfb3fd79fcd0ea9dff5d88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot('---#')&lt;/code&gt; will emit error &lt;code&gt;&quot;error&quot;&lt;/code&gt; whereas</source>
          <target state="translated">&lt;code&gt;hot('---#')&lt;/code&gt; 은 &lt;code&gt;&quot;error&quot;&lt;/code&gt; 오류를 발생시키는 반면</target>
        </trans-unit>
        <trans-unit id="d6a2e8fa0c13885a147ad8101a000224f75f5e84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot('---#', null, new SpecialError('test'))&lt;/code&gt; will emit &lt;code&gt;new SpecialError('test')&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hot('---#', null, new SpecialError('test'))&lt;/code&gt; 는 &lt;code&gt;new SpecialError('test')&lt;/code&gt; 방출합니다</target>
        </trans-unit>
        <trans-unit id="2911c19e5e499272edbb90d648b992bf10bf1534" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot('--a--b')&lt;/code&gt; will emit &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;&quot;b&quot;&lt;/code&gt; whereas</source>
          <target state="translated">&lt;code&gt;hot('--a--b')&lt;/code&gt; -a --b') 는 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 와 &lt;code&gt;&quot;b&quot;&lt;/code&gt; 를 방출 하지만</target>
        </trans-unit>
        <trans-unit id="799d6476abc1d323a6766cadbdeb1eaebd8adc4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot('--a--b', { a: 1, b: 2 })&lt;/code&gt; will emit &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hot('--a--b', { a: 1, b: 2 })&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;2&lt;/code&gt; 를 방출 합니다.</target>
        </trans-unit>
        <trans-unit id="767983367cb68219511d69bc8f1151ae9e35c771" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; - creates a &lt;a href=&quot;https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339&quot;&gt;&quot;hot&quot; observable&lt;/a&gt; (like a subject) that will behave as though it's already &quot;running&quot; when the test begins. An interesting difference is that &lt;code&gt;hot&lt;/code&gt; marbles allow a &lt;code&gt;^&lt;/code&gt; character to signal where the &quot;zero frame&quot; is. This is the default point at which the subscription to observables being tested begins, (this can be configured - see &lt;code&gt;expectObservable&lt;/code&gt; below).</source>
          <target state="translated">&lt;code&gt;hot(marbleDiagram: string, values?: object, error?: any)&lt;/code&gt; - 테스트가 시작될 때 이미 &quot;실행중인&quot;것처럼 동작 하는 &lt;a href=&quot;https://medium.com/@benlesh/hot-vs-cold-observables-f8094ed53339&quot;&gt;&quot;핫&quot;관찰 가능&lt;/a&gt; (주제와 같이)을 만듭니다 . 흥미로운 차이점은 &lt;code&gt;hot&lt;/code&gt; 마블 은 &quot;제로 프레임&quot;이있는 위치에 &lt;code&gt;^&lt;/code&gt; 문자를 표시 할 수 있다는 것 입니다. 이것은 테스트 대상 관찰 가능 대상에 대한 구독이 시작되는 기본 지점입니다 (이 구성 가능-아래 &lt;code&gt;expectObservable&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="5a7962e956269eb833ec362893ebed3b1638a063" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hot(marbles: string, values?: object, error?: any)&lt;/code&gt; - creates a &quot;hot&quot; observable (a subject) that will behave as though it's already &quot;running&quot; when the test begins. An interesting difference is that &lt;code&gt;hot&lt;/code&gt; marbles allow a &lt;code&gt;^&lt;/code&gt; character to signal where the &quot;zero frame&quot; is. That is the point at which the subscription to observables being tested begins.</source>
          <target state="translated">&lt;code&gt;hot(marbles: string, values?: object, error?: any)&lt;/code&gt; -테스트가 시작될 때 이미 &quot;실행중인&quot;것처럼 동작하는 &quot;핫&quot;관찰 가능 (주체)을 만듭니다. 흥미로운 차이점은 &lt;code&gt;hot&lt;/code&gt; 마블 은 &quot;제로 프레임&quot;이있는 위치에 &lt;code&gt;^&lt;/code&gt; 문자를 표시 할 수 있다는 것 입니다. 이것이 테스트 대상 관찰 대상에 대한 구독이 시작되는 시점입니다.</target>
        </trans-unit>
        <trans-unit id="0690d36fbdcb56b4f242b89d13ab4d0c31ca0bc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;http.get()&lt;/code&gt; returns an Observable (of string or string arrays probably) for each individual URL. Now you have an Observables &lt;em&gt;of&lt;/em&gt; Observables, a higher-order Observable.</source>
          <target state="translated">&lt;code&gt;http.get()&lt;/code&gt; 은 개별 URL마다 Observable (문자열 또는 문자열 배열 )을 반환합니다. 이제 당신은 Observables &lt;em&gt;of&lt;/em&gt; Observables 를 가지고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="981ee7c6f5b4848e80c872e42d57f19bc3938e4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iif&lt;/code&gt; accepts a condition function and two Observables. When an Observable returned by the operator is subscribed, condition function will be called. Based on what boolean it returns at that moment, consumer will subscribe either to the first Observable (if condition was true) or to the second (if condition was false). Condition function may also not return anything - in that case condition will be evaluated as false and second Observable will be subscribed.</source>
          <target state="translated">&lt;code&gt;iif&lt;/code&gt; 는 조건 함수와 두 개의 Observable을 허용합니다. 연산자가 반환 한 Observable을 구독하면 조건 함수가 호출됩니다. 그 순간에 어떤 부울 값이 반환되는지에 따라 소비자는 첫 번째 Observable (조건이 true 인 경우) 또는 두 번째 (조건이 false 인 경우)를 구독합니다. 조건 함수는 아무 것도 반환하지 않을 수 있습니다.이 경우 조건은 false로 평가되고 두 ​​번째 Observable이 구독됩니다.</target>
        </trans-unit>
        <trans-unit id="ff917215158e324736c1491962076002ae2685e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index&lt;/code&gt;: the (zero-based) &quot;index&quot; of the value from the source Observable.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; : 소스 Observable의 값에 대한 (0부터 시작) &quot;인덱스&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="da2c4ef43d82866aae3c09d679912b62685d5d30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interface&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;interface&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c06c8243829ec012b90429a487f7f9de74dfe132" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;interval&lt;/code&gt; returns an Observable that emits an infinite sequence of ascending integers, with a constant interval of time of your choosing between those emissions. The first emission is not sent immediately, but only after the first period has passed. By default, this operator uses the &lt;code&gt;async&lt;/code&gt;&lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to provide a notion of time, but you may pass any &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to it.</source>
          <target state="translated">&lt;code&gt;interval&lt;/code&gt; 은 방출 사이에서 선택하는 일정한 시간 간격으로 무한한 오름차순 정수를 방출하는 Observable을 반환합니다. 첫 번째 방출은 즉시 보내지는 것이 아니라 첫 번째 기간이 지난 후에야 보내집니다. 기본적으로이 연산자는 &lt;code&gt;async&lt;/code&gt; &lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt; 를 사용하여 시간 개념을 제공하지만 &lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt; 를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7aec19d4438c03177ae60e77c76f1deda18e1f69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;isEmpty&lt;/code&gt; transforms an Observable that emits values into an Observable that emits a single boolean value representing whether or not any values were emitted by the source Observable. As soon as the source Observable emits a value, &lt;code&gt;isEmpty&lt;/code&gt; will emit a &lt;code&gt;false&lt;/code&gt; and complete. If the source Observable completes having not emitted anything, &lt;code&gt;isEmpty&lt;/code&gt; will emit a &lt;code&gt;true&lt;/code&gt; and complete.</source>
          <target state="translated">&lt;code&gt;isEmpty&lt;/code&gt; 는 값을 방출하는 Observable을 Observable로 변환하여 소스 Observable이 값을 방출했는지 여부를 나타내는 단일 부울 값을 방출합니다. 소스 Observable이 값을 방출하자마자 &lt;code&gt;isEmpty&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 를 생성 하고 완료합니다. 소스 Observable이 아무 것도 방출하지 않고 완료하면 &lt;code&gt;isEmpty&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 와 complete를 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="c31771f17b1d50d97171a9c911e381ff4519dabb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;materialize&lt;/code&gt; returns an Observable that emits a &lt;code&gt;next&lt;/code&gt; notification for each &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, or &lt;code&gt;complete&lt;/code&gt; emission of the source Observable. When the source Observable emits &lt;code&gt;complete&lt;/code&gt;, the output Observable will emit &lt;code&gt;next&lt;/code&gt; as a Notification of type &quot;complete&quot;, and then it will emit &lt;code&gt;complete&lt;/code&gt; as well. When the source Observable emits &lt;code&gt;error&lt;/code&gt;, the output will emit &lt;code&gt;next&lt;/code&gt; as a Notification of type &quot;error&quot;, and then &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;materialize&lt;/code&gt; 방출한다는 관찰 가능한 수익을 &lt;code&gt;next&lt;/code&gt; 각 통지 &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;error&lt;/code&gt; , 또는 &lt;code&gt;complete&lt;/code&gt; 관찰 가능한 소스의 방출을. 때 소스 관찰 가능한이 방출 &lt;code&gt;complete&lt;/code&gt; , 출력 관찰 가능한이 방출됩니다 &lt;code&gt;next&lt;/code&gt; &quot;완료&quot;유형의 통지로 한 다음이 방출됩니다 &lt;code&gt;complete&lt;/code&gt; 뿐만 아니라. 소스 Observable에서 &lt;code&gt;error&lt;/code&gt; 하면 &lt;code&gt;next&lt;/code&gt; &quot;error&quot;유형의 알림으로 출력이 방출 된 다음 &lt;code&gt;complete&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="a620a1dab62832d7036c018e55f712758cba7539" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge&lt;/code&gt; subscribes to each given input Observable (as arguments), and simply forwards (without doing any transformation) all the values from all the input Observables to the output Observable. The output Observable only completes once all input Observables have completed. Any error delivered by an input Observable will be immediately emitted on the output Observable.</source>
          <target state="translated">&lt;code&gt;merge&lt;/code&gt; 는 각각의 주어진 입력 Observable을 인수로 구독하고, 모든 입력 Observables의 모든 값을 출력 Observable로 전달합니다 (변환없이). 출력 Observable은 모든 입력 Observable이 완료된 후에 만 ​​완료됩니다. 입력 Observable이 전달한 모든 오류는 출력 Observable에서 즉시 발생합니다.</target>
        </trans-unit>
        <trans-unit id="59410dc6a24fddd12fdff9f08ed905e09d08d34c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mergeAll&lt;/code&gt; subscribes to an Observable that emits Observables, also known as a higher-order Observable. Each time it observes one of these emitted inner Observables, it subscribes to that and delivers all the values from the inner Observable on the output Observable. The output Observable only completes once all inner Observables have completed. Any error delivered by a inner Observable will be immediately emitted on the output Observable.</source>
          <target state="translated">&lt;code&gt;mergeAll&lt;/code&gt; 은 Observable을 방출하는 Observable을 구독하며, 상위 Observable이라고도합니다. 방출 된 내부 Observable 중 하나를 관찰 할 때마다이를 구독하고 출력 Observable에서 내부 Observable의 모든 값을 전달합니다. 출력 Observable은 모든 내부 Observable이 완료된 후에 만 ​​완료됩니다. 내부 Observable이 전달한 모든 오류는 출력 Observable에서 즉시 발생합니다.</target>
        </trans-unit>
        <trans-unit id="777683b7cfdd5857d651bddab3fd9e125e6cb74e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multicast&lt;/code&gt; returns an Observable that looks like a normal Observable, but works like a Subject when it comes to subscribing. &lt;code&gt;multicast&lt;/code&gt; returns a &lt;code&gt;ConnectableObservable&lt;/code&gt;, which is simply an Observable with the &lt;code&gt;connect()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;multicast&lt;/code&gt; 는 일반 Observable처럼 보이지만 구독 할 때 Subject처럼 작동하는 Observable을 반환합니다. &lt;code&gt;multicast&lt;/code&gt; 는 &lt;code&gt;ConnectableObservable&lt;/code&gt; 을 반환하며 , 이는 &lt;code&gt;connect()&lt;/code&gt; 메서드를 사용하여 간단히 Observable입니다 .</target>
        </trans-unit>
        <trans-unit id="5f5b38c7d5c43ed1d44d70a0d42babaf3da2c27d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;observable.subscribe()&lt;/code&gt; means &quot;&lt;em&gt;give me any amount of values, either synchronously or asynchronously&lt;/em&gt;&quot;</source>
          <target state="translated">&lt;code&gt;observable.subscribe()&lt;/code&gt; 방법은 &quot; &lt;em&gt;동 기적 또는 비동기 내게 값의 금액을 부여&lt;/em&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="5a554e609492cca8c57b2a0aecc84d1057a5aac3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;observeOn&lt;/code&gt; is an operator that accepts a scheduler as a first parameter, which will be used to reschedule notifications emitted by the source Observable. It might be useful, if you do not have control over internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.</source>
          <target state="translated">&lt;code&gt;observeOn&lt;/code&gt; 은 스케줄러를 첫 번째 매개 변수로 받아들이는 연산자로, 소스 Observable이 생성 한 알림을 다시 예약하는 데 사용됩니다. 주어진 Observable의 내부 스케줄러를 제어 할 수 없지만 그 값이 방출되는시기를 제어하려는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1994390fee01ea975c48bfe909a4072be3d883a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; Will subscribe to each observable source it is provided, in order. If the source it's subscribed to emits an error or completes, it will move to the next source without error.</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; 제공된 각 관찰 가능 소스를 순서대로 구독합니다. 구독 한 소스에서 오류가 발생하거나 완료되면 오류없이 다음 소스로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="ef16d58131c642abbfab0c592384eafb6f227b95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; can be therefore thought of as version of &lt;a href=&quot;../index/function/concat&quot;&gt;&lt;code&gt;concat&lt;/code&gt;&lt;/a&gt; operator, which is more permissive when it comes to the errors emitted by its input Observables. While &lt;code&gt;concat&lt;/code&gt; subscribes to the next Observable in series only if previous one successfully completed, &lt;code&gt;onErrorResumeNext&lt;/code&gt; subscribes even if it ended with an error.</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; 따라서 onErrorResumeNext 는 &lt;a href=&quot;../index/function/concat&quot;&gt; &lt;code&gt;concat&lt;/code&gt; &lt;/a&gt; 연산자의 버전으로 생각할 수 있는데, 이는 입력 Observables에서 생성 된 오류와 관련하여 더 허용 적입니다. &lt;code&gt;concat&lt;/code&gt; 은 이전 Observable이 성공적으로 완료된 경우에만 다음 Observable을 직렬로 구독 하지만 &lt;code&gt;onErrorResumeNext&lt;/code&gt; 는 오류로 종료 된 경우에도 구독합니다.</target>
        </trans-unit>
        <trans-unit id="291e2549ced3cc796e330b6fc2231a429b9e5349" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; is an operator that accepts a series of Observables, provided either directly as arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same as the source.</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; 는 인수 또는 배열로 직접 제공되는 일련의 Observable을 허용하는 연산자입니다. 단일 Observable이 제공되지 않으면 리턴 된 Observable은 단순히 소스와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1dd5ccaf3fba11c911848593b79d46ec1794b960" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; is basically &lt;a href=&quot;concat&quot;&gt;&lt;code&gt;concat&lt;/code&gt;&lt;/a&gt;, only it will continue, even if one of its sources emits an error.</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; 는 기본적으로 &lt;a href=&quot;concat&quot;&gt; &lt;code&gt;concat&lt;/code&gt; &lt;/a&gt; 이며 소스 중 하나에서 오류가 발생하더라도 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="ff80ad62141e00cd2add9d085cf99cc33cc90177" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onErrorResumeNext&lt;/code&gt; returns an Observable that starts by subscribing and re-emitting values from the source Observable. When its stream of values ends - no matter if Observable completed or emitted an error - &lt;code&gt;onErrorResumeNext&lt;/code&gt; will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting its values as well and - again - when that stream ends, &lt;code&gt;onErrorResumeNext&lt;/code&gt; will proceed to subscribing yet another Observable in provided series, no matter if previous Observable completed or ended with an error. This will be happening until there is no more Observables left in the series, at which point returned Observable will complete - even if the last subscribed stream ended with an error.</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; 는 소스 Observable에서 값을 구독하고 다시 시작하여 시작되는 Observable을 반환합니다. Observable이 완료되었거나 오류를 생성했는지 여부에 관계없이 값 스트림이 종료되면 &lt;code&gt;onErrorResumeNext&lt;/code&gt; 는 메소드에 인수로 전달 된 첫 번째 Observable을 구독합니다. 값이 다시 출력되기 시작하고 다시 스트림이 종료되면 &lt;code&gt;onErrorResumeNext&lt;/code&gt; 는 이전 Observable이 완료되었거나 오류로 종료 되더라도 제공된 시리즈에서 다른 Observable을 구독합니다. 이것은 시리즈에 남은 Observable이 더 이상 없을 때까지 발생하며, 마지막으로 구독 한 스트림이 오류로 종료 된 경우에도 Observable이 반환 된 지점이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="1c9b05342b9557c75c17b290cebc80a1b1e3220f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pairs&lt;/code&gt; takes an arbitrary object and returns an Observable that emits arrays. Each emitted array has exactly two elements - the first is a key from the object and the second is a value corresponding to that key. Keys are extracted from an object via &lt;code&gt;Object.keys&lt;/code&gt; function, which means that they will be only enumerable keys that are present on an object directly - not ones inherited via prototype chain.</source>
          <target state="translated">&lt;code&gt;pairs&lt;/code&gt; 는 임의의 객체를 취하고 배열을 방출하는 Observable을 반환합니다. 방출 된 각 배열에는 정확히 두 개의 요소가 있습니다. 첫 번째는 객체의 키이고 두 번째는 해당 키에 해당하는 값입니다. 키는 &lt;code&gt;Object.keys&lt;/code&gt; 함수 를 통해 객체에서 추출됩니다. 즉, 프로토 타입 체인을 통해 상속 된 키가 아닌 객체에 직접 존재하는 열거 가능한 키일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="4f6fdfa42f667cfba7439d1f21478f14b5582463" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;partition&lt;/code&gt; outputs an array with two Observables that partition the values from the source Observable through the given &lt;code&gt;predicate&lt;/code&gt; function. The first Observable in that array emits source values for which the predicate argument returns true. The second Observable emits source values for which the predicate returns false. The first behaves like &lt;a href=&quot;../../operators/filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and the second behaves like &lt;a href=&quot;../../operators/filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; with the predicate negated.</source>
          <target state="translated">&lt;code&gt;partition&lt;/code&gt; 은 주어진 &lt;code&gt;predicate&lt;/code&gt; 함수를 통해 소스 Observable의 값을 분할하는 두 개의 Observable이있는 배열을 출력합니다 . 해당 배열의 첫 번째 Observable은 술어 인수가 true를 리턴하는 소스 값을 방출합니다. 두 번째 Observable은 술어가 false를 리턴하는 소스 값을 방출합니다. 첫 번째는 &lt;a href=&quot;../../operators/filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 처럼 작동 하고 두 번째 는 조건자가 무시 된 &lt;a href=&quot;../../operators/filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="29b0a69077ab704f04ffa917a9190d5c068cb61d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;partition&lt;/code&gt; outputs an array with two Observables that partition the values from the source Observable through the given &lt;code&gt;predicate&lt;/code&gt; function. The first Observable in that array emits source values for which the predicate argument returns true. The second Observable emits source values for which the predicate returns false. The first behaves like &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; and the second behaves like &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt; with the predicate negated.</source>
          <target state="translated">&lt;code&gt;partition&lt;/code&gt; 은 주어진 &lt;code&gt;predicate&lt;/code&gt; 함수를 통해 소스 Observable의 값을 분할하는 두 개의 Observable이있는 배열을 출력합니다 . 해당 배열의 첫 번째 Observable은 술어 인수가 true를 리턴하는 소스 값을 방출합니다. 두 번째 Observable은 술어가 false를 리턴하는 소스 값을 방출합니다. 첫 번째는 &lt;a href=&quot;filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 처럼 작동 하고 두 번째 는 조건자가 무시 된 &lt;a href=&quot;filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 처럼 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="d757360aa9c33465dd08a4b49ea5c09adbe8789e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;queue&lt;/code&gt; scheduler, when used with delay, behaves the same as &lt;a href=&quot;asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; scheduler.</source>
          <target state="translated">&lt;code&gt;queue&lt;/code&gt; 지연과 함께 사용되는 큐 스케줄러는 &lt;a href=&quot;asyncscheduler&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt; 스케줄러 와 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="17fdff06ac58fc951a7149d674b80a48d8ad8290" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;range&lt;/code&gt; operator emits a range of sequential integers, in order, where you select the &lt;code&gt;start&lt;/code&gt; of the range and its &lt;code&gt;length&lt;/code&gt;. By default, uses no &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; and just delivers the notifications synchronously, but may use an optional &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to regulate those deliveries.</source>
          <target state="translated">&lt;code&gt;range&lt;/code&gt; 연산자는 범위의 &lt;code&gt;start&lt;/code&gt; 과 &lt;code&gt;length&lt;/code&gt; 를 선택하는 순차적 인 정수 범위를 순서대로 내 보냅니다 . 기본적으로 &lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; 를&lt;/a&gt; 사용하지 않고 알림을 동기식으로 만 전달하지만 선택적 &lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt; 를 사용하여 해당 전달을 규제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e22b100da74aa12e2c1daa7b8100c2dbf04c3dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refCount&lt;/code&gt; makes the multicasted Observable automatically start executing when the first subscriber arrives, and stop executing when the last subscriber leaves.</source>
          <target state="translated">&lt;code&gt;refCount&lt;/code&gt; 는 멀티 캐스트 된 Observable이 첫 번째 구독자가 도착하면 자동으로 실행을 시작하고 마지막 구독자가 떠날 때 실행을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="7dbccc612f4b41c939a27316ce2aa6e8a76a4022" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sampleTime&lt;/code&gt; periodically looks at the source Observable and emits whichever value it has most recently emitted since the previous sampling, unless the source has not emitted anything since the previous sampling. The sampling happens periodically in time every &lt;code&gt;period&lt;/code&gt; milliseconds (or the time unit defined by the optional &lt;code&gt;scheduler&lt;/code&gt; argument). The sampling starts as soon as the output Observable is subscribed.</source>
          <target state="translated">&lt;code&gt;sampleTime&lt;/code&gt; 은 소스 Observable을 주기적으로보고 소스가 이전 샘플링 이후 아무 것도 방출하지 않은 한 이전 샘플링 이후 가장 최근에 방출 된 값을 방출합니다. 샘플링은 &lt;code&gt;period&lt;/code&gt; 밀리 초 마다 (또는 선택적 &lt;code&gt;scheduler&lt;/code&gt; 인수로 정의 된 시간 단위) 주기적으로 발생합니다 . 출력 Observable이 등록 되 자마자 샘플링이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="d5980710dadf7c9ae58853275ba85eaf3881bd1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sequenceEqual&lt;/code&gt; subscribes to two observables and buffers incoming values from each observable. Whenever either observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom up; If any value pair doesn't match, the returned observable will emit &lt;code&gt;false&lt;/code&gt; and complete. If one of the observables completes, the operator will wait for the other observable to complete; If the other observable emits before completing, the returned observable will emit &lt;code&gt;false&lt;/code&gt; and complete. If one observable never completes or emits after the other complets, the returned observable will never complete.</source>
          <target state="translated">&lt;code&gt;sequenceEqual&lt;/code&gt; 은 두 개의 Observable을 구독하고 각 Observable에서 들어오는 값을 버퍼링합니다. 관찰 가능한 값이있을 때마다 값이 버퍼링되고 버퍼가 이동되어 상향식에서 상향식으로 비교됩니다. 값 쌍이 일치하지 않으면 반환 된 Observable이 &lt;code&gt;false&lt;/code&gt; 를 생성 하고 완료합니다. 관찰 가능 항목 중 하나가 완료되면 조작자는 다른 관찰 가능 항목이 완료 될 때까지 기다립니다. 완료하기 전에 다른 옵저버 블이 방출되면 반환 된 옵저버 블은 &lt;code&gt;false&lt;/code&gt; 과 완료를 방출 합니다. 하나의 옵저버 블이 다른 complets 후에 완료되거나 방출되지 않으면 반환 된 옵저버 블은 절대 완료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f58d2f8563d7e3159c6ebb8ebafb1de8e6d7489" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;skipLast&lt;/code&gt; returns an Observable that accumulates a queue with a length enough to store the first &lt;code&gt;count&lt;/code&gt; values. As more values are received, values are taken from the front of the queue and produced on the result sequence. This causes values to be delayed.</source>
          <target state="translated">&lt;code&gt;skipLast&lt;/code&gt; 는 첫 번째 &lt;code&gt;count&lt;/code&gt; 값 을 저장하기에 충분한 길이의 큐를 누적하는 Observable을 반환 합니다. 더 많은 값이 수신되면 값은 큐의 앞면에서 가져 와서 결과 시퀀스에서 생성됩니다. 이로 인해 값이 지연됩니다.</target>
        </trans-unit>
        <trans-unit id="4dfa14c602b33dade952c18426ddaa9fa684801b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;source&lt;/code&gt;: the source Observable instance itself.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; : 소스 Observable 인스턴스 자체.</target>
        </trans-unit>
        <trans-unit id="1b4b0818cfe231af3c058ff8b49a57db0d1c71e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscribe&lt;/code&gt; is not a regular operator, but a method that calls Observable's internal &lt;code&gt;subscribe&lt;/code&gt; function. It might be for example a function that you passed to Observable's constructor, but most of the time it is a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means that calling &lt;code&gt;subscribe&lt;/code&gt; is actually the moment when Observable starts its work, not when it is created, as it is often the thought.</source>
          <target state="translated">&lt;code&gt;subscribe&lt;/code&gt; 는 정규 연산자가 아니라 Observable의 내부 &lt;code&gt;subscribe&lt;/code&gt; 함수 를 호출하는 메소드입니다 . 예를 들어 Observable의 생성자에 전달한 함수 일 수 있지만 대부분은 Observable에서 생성되는 내용과 생성되는 시간을 정의하는 라이브러리 구현입니다. 이것은 &lt;code&gt;subscribe&lt;/code&gt; 을 호출하는 것이 실제로는 생각이되기 때문에 생성 될 때가 아니라 실제로 Observable이 작업을 시작하는 순간 임을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="7b11a8ddb4b29050c92924f7c707c9f383b4539d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switch&lt;/code&gt; -&amp;gt; &lt;code&gt;switchAll&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; -&amp;gt; &lt;code&gt;switchAll&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="42f30fe54a88e73cf07d5e7dde80265a6018d9c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;switchAll&lt;/code&gt; subscribes to a source that is an observable of observables, also known as a &quot;higher-order observable&quot; (or &lt;code&gt;Observable&amp;lt;Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;). It subscribes to the most recently provided &quot;inner observable&quot; emitted by the source, unsubscribing from any previously subscribed to inner observable, such that only the most recent inner observable may be subscribed to at any point in time. The resulting observable returned by &lt;code&gt;switchAll&lt;/code&gt; will only complete if the source observable completes, &lt;em&gt;and&lt;/em&gt; any currently subscribed to inner observable also has completed, if there are any.</source>
          <target state="translated">&lt;code&gt;switchAll&lt;/code&gt; 은 &quot;높은 수준의 관찰 가능&quot;(또는 &lt;code&gt;Observable&amp;lt;Observable&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; )으로 알려진 관찰 가능 관찰 가능 소스에 가입합니다 . 소스에서 방출 한 가장 최근에 제공된 &quot;내부 관찰 가능&quot;을 구독하고, 내부 관찰 가능 대상에 대해 이전에 구독 한 구독자 중 하나를 구독하지 않으므로 가장 최근의 내부 관찰 가능 대상 만 언제든지 구독 할 수 있습니다. &lt;code&gt;switchAll&lt;/code&gt; 에 의해 반환 된 결과 옵저버 블 은 소스 옵저버 블 이 완료 &lt;em&gt;되고&lt;/em&gt; 현재 내부 옵저버 블에 가입 된 모든 옵저버 블 이 완료된 경우에만 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="69dd20bf2331adf056c62cc0c41f4a92f233c680" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;take&lt;/code&gt; returns an Observable that emits only the first &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable. If the source emits fewer than &lt;code&gt;count&lt;/code&gt; values then all of its values are emitted. After that, it completes, regardless if the source completes.</source>
          <target state="translated">&lt;code&gt;take&lt;/code&gt; 는 소스 Observable 이 내 보낸 첫 번째 &lt;code&gt;count&lt;/code&gt; 값만 내보내는 Observable을 반환합니다 . 소스가 &lt;code&gt;count&lt;/code&gt; 값 보다 적은 양을 방출하면 모든 값이 방출됩니다. 그 후 소스가 완료되는지 여부에 관계없이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="e0d3558cc44022c2e8684d41349bf690ef45ad6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeLast&lt;/code&gt; returns an Observable that emits at most the last &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable. If the source emits fewer than &lt;code&gt;count&lt;/code&gt; values then all of its values are emitted. This operator must wait until the &lt;code&gt;complete&lt;/code&gt; notification emission from the source in order to emit the &lt;code&gt;next&lt;/code&gt; values on the output Observable, because otherwise it is impossible to know whether or not more values will be emitted on the source. For this reason, all values are emitted synchronously, followed by the complete notification.</source>
          <target state="translated">&lt;code&gt;takeLast&lt;/code&gt; 는 소스 Observable이 방출 한 마지막 &lt;code&gt;count&lt;/code&gt; 값 을 최대한 방출하는 Observable을 반환합니다 . 소스가 &lt;code&gt;count&lt;/code&gt; 값 보다 적은 양을 방출하면 모든 값이 방출됩니다. 이 오퍼레이터는 출력 Observable 에서 &lt;code&gt;next&lt;/code&gt; 값 을 방출하기 위해 소스에서 &lt;code&gt;complete&lt;/code&gt; 알림 방출 이 나올 때까지 기다려야합니다. 그렇지 않으면 소스에서 더 많은 값이 방출되는지 여부를 알 수 없기 때문입니다. 이러한 이유로 모든 값은 동기식으로 생성 된 후 완전한 알림이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a41e94110409f4ba43cb9c3758b60c921ba32bbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeUntil&lt;/code&gt; subscribes and begins mirroring the source Observable. It also monitors a second Observable, &lt;code&gt;notifier&lt;/code&gt; that you provide. If the &lt;code&gt;notifier&lt;/code&gt; emits a value, the output Observable stops mirroring the source Observable and completes. If the &lt;code&gt;notifier&lt;/code&gt; doesn't emit any value and completes then &lt;code&gt;takeUntil&lt;/code&gt; will pass all values.</source>
          <target state="translated">&lt;code&gt;takeUntil&lt;/code&gt; 이 구독하고 소스 Observable을 미러링하기 시작할 때까지. 또한 사용자가 제공 한 두 번째 Observable &lt;code&gt;notifier&lt;/code&gt; 를 모니터 합니다. 는 IF &lt;code&gt;notifier&lt;/code&gt; 값을 발광 출력 정지 관찰 가능한 소스 피 감시 및 완료 미러링. 는 IF &lt;code&gt;notifier&lt;/code&gt; 값 및 완료를 방출하지 않는 다음 &lt;code&gt;takeUntil&lt;/code&gt; 은 모든 값을 전달한다.</target>
        </trans-unit>
        <trans-unit id="4a230ff2a0b2808f0225be3b8c769a658194b52c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;takeWhile&lt;/code&gt; subscribes and begins mirroring the source Observable. Each value emitted on the source is given to the &lt;code&gt;predicate&lt;/code&gt; function which returns a boolean, representing a condition to be satisfied by the source values. The output Observable emits the source values until such time as the &lt;code&gt;predicate&lt;/code&gt; returns false, at which point &lt;code&gt;takeWhile&lt;/code&gt; stops mirroring the source Observable and completes the output Observable.</source>
          <target state="translated">&lt;code&gt;takeWhile&lt;/code&gt; 구독하고 소스 Observable을 미러링하기 시작합니다. 소스에서 생성 된 각 값은 &lt;code&gt;predicate&lt;/code&gt; 함수에 제공되어 소스 값으로 충족되는 조건을 나타내는 부울을 리턴합니다. 출력 Observable은 &lt;code&gt;predicate&lt;/code&gt; 가 false를 리턴 할 때까지 소스 값을 방출합니다 .이 시점에서 &lt;code&gt;takeWhile&lt;/code&gt; 는 소스 Observable의 미러링을 중지하고 출력 Observable을 완료합니다.</target>
        </trans-unit>
        <trans-unit id="893d4d7f1c2faad041677d314bbceaa20ca07709" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throttle&lt;/code&gt; emits the source Observable values on the output Observable when its internal timer is disabled, and ignores source values when the timer is enabled. Initially, the timer is disabled. As soon as the first source value arrives, it is forwarded to the output Observable, and then the timer is enabled by calling the &lt;code&gt;durationSelector&lt;/code&gt; function with the source value, which returns the &quot;duration&quot; Observable. When the duration Observable emits a value or completes, the timer is disabled, and this process repeats for the next source value.</source>
          <target state="translated">&lt;code&gt;throttle&lt;/code&gt; 은 내부 타이머가 비활성화되면 출력 Observable에서 소스 Observable 값을 방출하고 타이머가 활성화되면 소스 값을 무시합니다. 처음에는 타이머가 비활성화되어 있습니다. 첫 번째 소스 값이 도착하자마자 출력 Observable로 전달 된 다음 소스 값으로 &lt;code&gt;durationSelector&lt;/code&gt; 함수를 호출하여 타이머가 활성화되고 &quot;duration&quot;Observable이 반환됩니다. Observable 지속 시간이 값을 생성하거나 완료하면 타이머가 비활성화되고이 프로세스는 다음 소스 값에 대해 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="ed9390044a64b750cabefbab7627d762696a0957" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;throttleTime&lt;/code&gt; emits the source Observable values on the output Observable when its internal timer is disabled, and ignores source values when the timer is enabled. Initially, the timer is disabled. As soon as the first source value arrives, it is forwarded to the output Observable, and then the timer is enabled. After &lt;code&gt;duration&lt;/code&gt; milliseconds (or the time unit determined internally by the optional &lt;code&gt;scheduler&lt;/code&gt;) has passed, the timer is disabled, and this process repeats for the next source value. Optionally takes a &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; for managing timers.</source>
          <target state="translated">&lt;code&gt;throttleTime&lt;/code&gt; 은 내부 타이머가 비활성화되면 출력 Observable에서 소스 Observable 값을 방출하고 타이머가 활성화되면 소스 값을 무시합니다. 처음에는 타이머가 비활성화되어 있습니다. 첫 번째 소스 값에 도달하면 출력 Observable로 전달 된 다음 타이머가 활성화됩니다. 후 &lt;code&gt;duration&lt;/code&gt; 밀리 초 (또는 옵션에 의해 내부적으로 결정된 시간 단위 &lt;code&gt;scheduler&lt;/code&gt; ) 경과 타이머가 비활성화되고, 다음 소스 값에 대해이 과정을 반복. 선택적으로 타이머 관리를 위해 &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="837bf2907a5094046aef9c509d4b9c80692617d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments) when returned Observable will check if source stream emitted value or completed.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 은 스케줄러도 두 번째 매개 변수로 승인합니다. Observable이 소스 스트림이 값을 방출했는지 또는 완료했는지 검사 할 때 순간을 예약하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4a7dc88dd8ca560076bef8f42aecb45980ad1c4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; operator accepts as an argument either a number or a Date.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 연산자는 숫자 또는 날짜를 인수로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9434e63eff4482ecfbfd0ab90266a6145b5d0017" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeoutWith&lt;/code&gt; is a variation of &lt;code&gt;timeout&lt;/code&gt; operator. It behaves exactly the same, still accepting as a first argument either a number or a Date, which control - respectively - when values of source Observable should be emitted or when it should complete.</source>
          <target state="translated">&lt;code&gt;timeoutWith&lt;/code&gt; 는 &lt;code&gt;timeout&lt;/code&gt; 연산자 의 변형입니다 . 소스와 Observable의 값이 언제 방출되어야하는지 또는 언제 완료해야 하는지를 제어하는 ​​숫자 또는 날짜를 첫 번째 인수로 그대로 받아들이면서 정확히 동일하게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="4710700c6f8e512d7c421a3fa66ab6a55bd22c59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timer&lt;/code&gt; returns an Observable that emits an infinite sequence of ascending integers, with a constant interval of time, &lt;code&gt;period&lt;/code&gt; of your choosing between those emissions. The first emission happens after the specified &lt;code&gt;dueTime&lt;/code&gt;. The initial delay may be a &lt;code&gt;Date&lt;/code&gt;. By default, this operator uses the &lt;a href=&quot;../const/asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to provide a notion of time, but you may pass any &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to it. If &lt;code&gt;period&lt;/code&gt; is not specified, the output Observable emits only one value, &lt;code&gt;0&lt;/code&gt;. Otherwise, it emits an infinite sequence.</source>
          <target state="translated">&lt;code&gt;timer&lt;/code&gt; 는 일정한 시간 간격과 해당 방출 사이에서 선택한 &lt;code&gt;period&lt;/code&gt; 무한한 오름차순 정수를 방출하는 Observable을 반환합니다 . 첫 번째 방출은 지정된 &lt;code&gt;dueTime&lt;/code&gt; 후에 발생합니다 . 초기 지연은 &lt;code&gt;Date&lt;/code&gt; 일 수 있습니다 . 기본적으로이 연산자는 &lt;a href=&quot;../const/asyncscheduler&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt; 를 사용하여 시간 개념을 제공하지만 &lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt; 를 전달할 수 있습니다. 만약 &lt;code&gt;period&lt;/code&gt; 지정되어 있지 않은, 관측 가능한 출력을 방출 하나 개의 값이 &lt;code&gt;0&lt;/code&gt; . 그렇지 않으면 무한 시퀀스를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="5d336ba47502080cf68f8a6221d7a484097c3e86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toArray&lt;/code&gt; will wait until the source Observable completes before emitting the array containing all emissions. When the source Observable errors no array will be emitted.</source>
          <target state="translated">&lt;code&gt;toArray&lt;/code&gt; 는 소스 Observable이 완료 될 때까지 기다렸다가 모든 방출이 포함 된 어레이를 방출합니다. 소스 Observable 오류가 발생하면 배열이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="882041f58c61297d3bc52474672369483f237e67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type-alias&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;type-alias&lt;/code&gt;&lt;code&gt;deprecated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c1be2711a1aca94a2a1d5e62e346824e0545d42d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type-alias&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;type-alias&lt;/code&gt;&lt;code&gt;stable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d345979c928da012a70daaf3ad24a52650157db4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;using&lt;/code&gt; is a factory operator, which accepts two functions. First function returns a disposable resource. It can be an arbitrary object that implements &lt;code&gt;unsubscribe&lt;/code&gt; method. Second function will be injected with that object and should return an Observable. That Observable can use resource object during its execution. Both functions passed to &lt;code&gt;using&lt;/code&gt; will be called every time someone subscribes - neither an Observable nor resource object will be shared in any way between subscriptions.</source>
          <target state="translated">&lt;code&gt;using&lt;/code&gt; 은 두 가지 기능을 허용하는 팩토리 운영자입니다. 첫 번째 함수는 일회용 자원을 반환합니다. &lt;code&gt;unsubscribe&lt;/code&gt; 메소드 를 구현하는 임의의 오브젝트 일 수 있습니다 . 두 번째 함수는 해당 개체에 주입되며 Observable을 반환해야합니다. Observable은 실행 중에 자원 오브젝트를 사용할 수 있습니다. 두 기능 모두 &lt;code&gt;using&lt;/code&gt; 누군가가 구독 할 때마다 호출됩니다. 구독과 리소스 개체는 구독간에 어떤 방식으로도 공유되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61103ee33a8a3cb94239d307c3afbd3dc50159b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt;: the value from the source Observable.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; : 소스 Observable의 값입니다.</target>
        </trans-unit>
        <trans-unit id="9bd5b9326ee02528186bb1b60e87af552140ef37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="31d672942033870f817236e058621cb34ad12098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;webSocket&lt;/code&gt; is a factory function that produces a &lt;code&gt;WebSocketSubject&lt;/code&gt;, which can be used to make WebSocket connection with an arbitrary endpoint. &lt;code&gt;webSocket&lt;/code&gt; accepts as an argument either a string with url of WebSocket endpoint, or an &lt;a href=&quot;websocketsubjectconfig&quot;&gt;&lt;code&gt;WebSocketSubjectConfig&lt;/code&gt;&lt;/a&gt; object for providing additional configuration, as well as Observers for tracking lifecycle of WebSocket connection.</source>
          <target state="translated">&lt;code&gt;webSocket&lt;/code&gt; 은 &lt;code&gt;WebSocketSubject&lt;/code&gt; 를 생성하는 팩토리 함수 로, 임의의 엔드 포인트와 WebSocket을 연결하는 데 사용할 수 있습니다. &lt;code&gt;webSocket&lt;/code&gt; 은 WebSocket 엔드 포인트의 URL을 가진 문자열 또는&lt;a href=&quot;websocketsubjectconfig&quot;&gt; &lt;code&gt;WebSocketSubjectConfig&lt;/code&gt; &lt;/a&gt;추가 구성을 제공하기위한 WebSocketSubjectConfig 객체 및 WebSocket 연결의 수명주기를 추적하는 관찰자를합니다.</target>
        </trans-unit>
        <trans-unit id="42327b58fe89d4b9abe60f993e7061fb8c13cb90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;withLatestFrom&lt;/code&gt; combines each value from the source Observable (the instance) with the latest values from the other input Observables only when the source emits a value, optionally using a &lt;code&gt;project&lt;/code&gt; function to determine the value to be emitted on the output Observable. All input Observables must emit at least one value before the output Observable will emit a value.</source>
          <target state="translated">&lt;code&gt;withLatestFrom&lt;/code&gt; 은 소스 Observable (인스턴스)의 각 값을 다른 입력 Observables의 최신 값과 소스가 값을 방출 할 때만, 선택적으로 &lt;code&gt;project&lt;/code&gt; 함수를 사용하여 출력 Observable에서 방출 될 값을 결정합니다. 출력 Observable이 값을 생성하기 전에 모든 입력 Observable이 하나 이상의 값을 방출해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b728c16ebf18a54406f817875e31683e7bead01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt;: Equivalent to &lt;code&gt;Observable.empty()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; : &lt;code&gt;Observable.empty()&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="9fc5c704c2f6cc2c0c5a80f700059819fe2e60c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt;: Equivalent to &lt;code&gt;empty()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; : &lt;code&gt;empty()&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="611ae3064b4a8437c9d8a8987b8edf4d63b802fc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Pull&lt;/em&gt; and &lt;em&gt;Push&lt;/em&gt; are two different protocols that describe how a data &lt;em&gt;Producer&lt;/em&gt; can communicate with a data &lt;em&gt;Consumer&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Pull&lt;/em&gt; and &lt;em&gt;Push&lt;/em&gt; 는 데이터 &lt;em&gt;생산자&lt;/em&gt; 가 데이터 &lt;em&gt;소비자&lt;/em&gt; 와 통신 하는 방법을 설명하는 서로 다른 두 가지 프로토콜입니다 .</target>
        </trans-unit>
        <trans-unit id="b062cafef9329a689038f3f6bb0d6df3b1e17fc9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Scheduler has a (virtual) clock.&lt;/strong&gt; It provides a notion of &quot;time&quot; by a getter method &lt;code&gt;now()&lt;/code&gt; on the scheduler. Tasks being scheduled on a particular scheduler will adhere only to the time denoted by that clock.</source>
          <target state="translated">&lt;strong&gt;스케줄러에는 (가상) 시계가 있습니다. &lt;/strong&gt;getter 메소드에 의해 &quot;시간&quot;이라는 개념을 제공합니다 &lt;code&gt;now()&lt;/code&gt; 스케줄러 now () 에 . 특정 스케줄러에서 예약 된 작업은 해당 시계가 나타내는 시간 만 준수합니다.</target>
        </trans-unit>
        <trans-unit id="074b016986830a891feacbe88dcea585792b6754" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Scheduler is a data structure.&lt;/strong&gt; It knows how to store and queue tasks based on priority or other criteria.</source>
          <target state="translated">&lt;strong&gt;스케줄러는 데이터 구조입니다.&lt;/strong&gt;우선 순위 또는 다른 기준에 따라 작업을 저장하고 대기열에 넣는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d23e926a842ae9b7ec36083837a1300934aa0807" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A Scheduler is an execution context.&lt;/strong&gt; It denotes where and when the task is executed (e.g. immediately, or in another callback mechanism such as setTimeout or process.nextTick, or the animation frame).</source>
          <target state="translated">&lt;strong&gt;스케줄러는 실행 컨텍스트입니다.&lt;/strong&gt;작업이 언제 어디서 실행되는지를 나타냅니다 (예 : 즉시 또는 setTimeout 또는 process.nextTick과 같은 다른 콜백 메커니즘 또는 애니메이션 프레임).</target>
        </trans-unit>
        <trans-unit id="c2696dbc62b706589ef9271f2becbde4c0d86eb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Active:&lt;/strong&gt; decides when data is requested.</source>
          <target state="translated">&lt;strong&gt;유효한:&lt;/strong&gt; 데이터 요청시기를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="40ad7c047bd1f3c45b24a8afae9c8e0660d7e1af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Active:&lt;/strong&gt; produces data at its own pace.</source>
          <target state="translated">&lt;strong&gt;유효한:&lt;/strong&gt; 자체 속도로 데이터를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="84179ebccd8aeb96d5d2a2ad2a67b59c7a558188" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Creating&lt;/strong&gt; Observables</source>
          <target state="translated">&lt;strong&gt;만들기&lt;/strong&gt;Observable</target>
        </trans-unit>
        <trans-unit id="2cbf914fb3e5f78e9d854a8a21e5a8003fab511a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Creation Operators&lt;/strong&gt; are the other kind of operator, which can be called as standalone functions to create a new Observable. For example: &lt;code&gt;of(1, 2, 3)&lt;/code&gt; creates an observable that will emit 1, 2, and 3, one right after another. Creation operators will be discussed in more detail in a later section.</source>
          <target state="translated">&lt;strong&gt;생성 연산자&lt;/strong&gt; 는 다른 종류의 연산자로, 새로운 Observable을 만들기 위해 독립형 함수라고 할 수 있습니다. 예를 들면 : &lt;code&gt;of(1, 2, 3)&lt;/code&gt; 은 1, 2 및 3을 하나씩 차례로 방출하는 Observable을 만듭니다. 생성 연산자는 이후 섹션에서 더 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ca200ee9bac7753c1984e93beda095c8fbb8031e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DOM EventTarget&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DOM EventTarget&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e68420a4c7815b5f0c672698af4bf7843778d45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DOM HtmlCollection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DOM HtmlCollection&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8943c4167154d5069a0f8a5c2c3dd62af27cc3cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DOM NodeList&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;DOM 노드리스트&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a21f27d9b01b50a7b29f7fa2322b39771e0b7e35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disposing&lt;/strong&gt; Observables</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;Observables &lt;strong&gt;처리&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cb151d1e02f000a2e2e7a787d5b9cd87bf237000" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Every Subject is an Observable.&lt;/strong&gt; Given a Subject, you can &lt;code&gt;subscribe&lt;/code&gt; to it, providing an Observer, which will start receiving values normally. From the perspective of the Observer, it cannot tell whether the Observable execution is coming from a plain unicast Observable or a Subject.</source>
          <target state="translated">&lt;strong&gt;모든 주제는 관찰 가능하다. &lt;/strong&gt;주제가 주어지면 &lt;code&gt;subscribe&lt;/code&gt; 를 제공하여 정상적으로 값을 받기 시작하는 관찰자를 제공 할 수 있습니다 . Observer의 관점에서 Observable 실행이 일반 유니 캐스트 Observable 또는 Subject에서 발생하는지 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5373b1d2caa00d50f019c34ecd9071bc9c038433" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Every Subject is an Observer.&lt;/strong&gt; It is an object with the methods &lt;code&gt;next(v)&lt;/code&gt;, &lt;code&gt;error(e)&lt;/code&gt;, and &lt;code&gt;complete()&lt;/code&gt;. To feed a new value to the Subject, just call &lt;code&gt;next(theValue)&lt;/code&gt;, and it will be multicasted to the Observers registered to listen to the Subject.</source>
          <target state="translated">&lt;strong&gt;모든 주제는 관찰자입니다. &lt;/strong&gt; &lt;code&gt;next(v)&lt;/code&gt; , &lt;code&gt;error(e)&lt;/code&gt; 및 &lt;code&gt;complete()&lt;/code&gt; 메소드가있는 객체입니다 . 주제에 새로운 값을 제공하려면 &lt;code&gt;next(theValue)&lt;/code&gt; 호출 하면 주제를 청취하도록 등록 된 관찰자에게 멀티 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="183af49f4d960a43e78387ddc6ee3ed6f8e3ccf0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example.&lt;/strong&gt; The following is an Observable that pushes the values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; immediately (synchronously) when subscribed, and the value &lt;code&gt;4&lt;/code&gt; after one second has passed since the subscribe call, then completes:</source>
          <target state="translated">&lt;strong&gt;예. &lt;/strong&gt;다음은 구독 할 때 값 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt; 을 즉시 (동기식으로) 푸시 하고 구독 호출 이후 1 초 후에 값 &lt;code&gt;4&lt;/code&gt; 를 푸시 한 다음 완료되는 Observable입니다 .</target>
        </trans-unit>
        <trans-unit id="dc8b1db7d6c863328921dd393ba3c393b762f959" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Executing&lt;/strong&gt; the Observable</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;Observable &lt;strong&gt;실행&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4048867ebc7d64b979ef3246ca49c44be92b16b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Instance operators may take a Scheduler as argument.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;인스턴스 운영자는 스케줄러를 인수로 사용할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="96bab829a0c0f4399a5e75cee75d035f3056b17b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JQuery-style event target&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jQuery 스타일의 이벤트 대상&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="27bbb9b4010ebcf793220387d26bf7f0eb25cef0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Multiplexing&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Multiplexing&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ed0d7836fa3fb4540d3c4bbd9ca9eb12e6e3e01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: Using &lt;code&gt;rxjs&lt;/code&gt; or &lt;code&gt;rxjs/operators&lt;/code&gt; without making changes to your build process can result in larger bundles. See &lt;a href=&quot;pipeable-operators#known-issues&quot;&gt;Known Issues&lt;/a&gt; section below.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 빌드 프로세스를 변경하지 않고 &lt;code&gt;rxjs&lt;/code&gt; 또는 &lt;code&gt;rxjs/operators&lt;/code&gt; 를 사용하면 번들이 더 커질 수 있습니다. 아래의 &lt;a href=&quot;pipeable-operators#known-issues&quot;&gt;알려진 문제&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f105f3f8fa68751b4b8a425493ce2fc80d1fe5b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt;: You may have to subtract 1 millisecond from the time you want to progress because the alphanumeric marbles (representing an actual emitted value) &lt;em&gt;advance time 1 virtual frame&lt;/em&gt; themselves already, after they emit. This can be very unintuitive and frustrating, but for now it is indeed correct.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 영숫자 구슬 (실제로 방출되는 값을 나타냄)은 이미 방출 된 후 &lt;em&gt;1 가상 프레임&lt;/em&gt; 자체 를 진행하므로 진행 시간에서 1 밀리 초를 빼야 할 수도 있습니다 . 이것은 매우 직관적이지 않고 실망 스러울 수 있지만 현재로서는 실제로 정확합니다.</target>
        </trans-unit>
        <trans-unit id="1b82b6885d2ca4a917dedb922318618f04d40411" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Node.js EventEmitter&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Node.js EventEmitter&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1e6804a13811d1de6f399d6c72e02d791ca86aa0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observable.error &amp;gt; throwError()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Observable.error&amp;gt; throwError ()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8bd3c9bb800e7f0fb7e366cf1c7b3e082bddc190" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observable.if &amp;gt; iif()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Observable.if&amp;gt; iif ()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00391a5b16891388706b4319b8c7649c5c3df177" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observable:&lt;/strong&gt; represents the idea of an invokable collection of future values or events.</source>
          <target state="translated">&lt;strong&gt;관찰 가능 :&lt;/strong&gt; 미래 가치 또는 이벤트의 호출 가능한 콜렉션에 대한 아이디어를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0acdf1a2141240d22bc99dc78cf3713da2737dcd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Observer:&lt;/strong&gt; is a collection of callbacks that knows how to listen to values delivered by the Observable.</source>
          <target state="translated">&lt;strong&gt;Observer :&lt;/strong&gt; Observable이 전달한 값을 듣는 방법을 알고있는 콜백 모음입니다.</target>
        </trans-unit>
        <trans-unit id="af427c5f339addc519da7767cdb1e6f5c930d89d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Operators:&lt;/strong&gt; are pure functions that enable a functional programming style of dealing with collections with operations like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;, &lt;code&gt;concat&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, etc.</source>
          <target state="translated">&lt;strong&gt;연산자 : &lt;/strong&gt; &lt;code&gt;map&lt;/code&gt; , &lt;code&gt;filter&lt;/code&gt; , &lt;code&gt;concat&lt;/code&gt; , &lt;code&gt;reduce&lt;/code&gt; 등과 같은 연산으로 컬렉션을 처리하는 기능적 프로그래밍 스타일을 가능하게하는 순수한 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="903114a5875a76c7e7e738db8ee5670ecaffeb9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passive:&lt;/strong&gt; produces data when requested.</source>
          <target state="translated">&lt;strong&gt;수동 :&lt;/strong&gt; 요청시 데이터를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a9558477bc2631c7221403c490210bc959155791" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Passive:&lt;/strong&gt; reacts to received data.</source>
          <target state="translated">&lt;strong&gt;수동 :&lt;/strong&gt; 수신 된 데이터에 반응합니다.</target>
        </trans-unit>
        <trans-unit id="3f0517560b9f6522d3ec876a649641ec26e37bec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pipeable Operators&lt;/strong&gt; are the kind that can be piped to Observables using the syntax &lt;code&gt;observableInstance.pipe(operator())&lt;/code&gt;. These include, &lt;a href=&quot;../api/operators/filter&quot;&gt;&lt;code&gt;filter(...)&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../api/operators/mergemap&quot;&gt;&lt;code&gt;mergeMap(...)&lt;/code&gt;&lt;/a&gt;. When called, they do not &lt;em&gt;change&lt;/em&gt; the existing Observable instance. Instead, they return a &lt;em&gt;new&lt;/em&gt; Observable, whose subscription logic is based on the first Observable.</source>
          <target state="translated">&lt;strong&gt;Pipeable 운영자&lt;/strong&gt; 구 사용에 파이프 Observables은 될 수있는 종류 &lt;code&gt;observableInstance.pipe(operator())&lt;/code&gt; . 여기에는 &lt;a href=&quot;../api/operators/filter&quot;&gt; &lt;code&gt;filter(...)&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../api/operators/mergemap&quot;&gt; &lt;code&gt;mergeMap(...)&lt;/code&gt; &lt;/a&gt; 됩니다. 호출되면 기존 Observable 인스턴스를 &lt;em&gt;변경&lt;/em&gt; 하지 않습니다 . 대신 구독 논리가 첫 번째 Observable을 기반으로 하는 &lt;em&gt;새로운&lt;/em&gt; Observable 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dfcbd70cd68821b77e692cfdf2ea4926f7734a21" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pull&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pull&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="15f12ede62915f48b6ad83b8e92e23880f687ba9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Push&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Push&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a3a338d979540294175612757b03b13e50907fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Renamed Operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이름이 바뀐 연산자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1f679c158b945669b0b1bcd8dcbe4cf80ff3e13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Replacing synchronous error handling&lt;/strong&gt; The following example shows code that subscribes to an observable within a &lt;code&gt;try/catch&lt;/code&gt; block, in order to handle errors synchronously:</source>
          <target state="translated">&lt;strong&gt;동기 오류 처리 교체&lt;/strong&gt; 다음 예는 오류를 동 기적으로 처리하기 위해 &lt;code&gt;try/catch&lt;/code&gt; 블록 내에서 옵저버 블을 구독하는 코드를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="657c2d83cff0ceff049ce2ce6e5ebce465c69192" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Schedulers:&lt;/strong&gt; are centralized dispatchers to control concurrency, allowing us to coordinate when computation happens on e.g. &lt;code&gt;setTimeout&lt;/code&gt; or &lt;code&gt;requestAnimationFrame&lt;/code&gt; or others.</source>
          <target state="translated">&lt;strong&gt;스케줄러 :&lt;/strong&gt; 동시성을 제어하기위한 중앙 집중식 디스패처로서 &lt;code&gt;setTimeout&lt;/code&gt; 또는 &lt;code&gt;requestAnimationFrame&lt;/code&gt; 등에서 계산이 수행되는 시점을 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="230aa9b6906a94c5dd268a2a57b8df69be5e6259" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Static creation operators usually take a Scheduler as argument.&lt;/strong&gt; For instance, &lt;code&gt;from(array, scheduler)&lt;/code&gt; lets you specify the Scheduler to use when delivering each notification converted from the &lt;code&gt;array&lt;/code&gt;. It is usually the last argument to the operator. The following static creation operators take a Scheduler argument:</source>
          <target state="translated">&lt;strong&gt;정적 작성 연산자는 일반적으로 스케줄러를 인수로 사용합니다. &lt;/strong&gt;예를 들어 &lt;code&gt;from(array, scheduler)&lt;/code&gt; 를 사용하면 &lt;code&gt;array&lt;/code&gt; 에서 변환 된 각 알림을 전달할 때 사용할 스케줄러를 지정할 수 있습니다 . 일반적으로 연산자의 마지막 인수입니다. 다음 정적 작성 연산자는 스케줄러 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4bc5912a19fdcb523a962180f2331e7ae3926205" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subject:&lt;/strong&gt; is the equivalent to an EventEmitter, and the only way of multicasting a value or event to multiple Observers.</source>
          <target state="translated">&lt;strong&gt;Subject :&lt;/strong&gt; 는 EventEmitter와 동일하며 값이나 이벤트를 여러 관찰자에게 멀티 캐스팅하는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="428168244c9f05e1c6da25e04311afe32902b6a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subscribing&lt;/strong&gt; to Observables</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;옵저버 블 &lt;strong&gt;구독&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c45e0a77d0dd75edd547e7bfbd17a13e9e46d91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subscription:&lt;/strong&gt; represents the execution of an Observable, is primarily useful for cancelling the execution.</source>
          <target state="translated">&lt;strong&gt;구독 :&lt;/strong&gt; Observable의 실행을 나타내며 주로 실행 취소에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e7223a3f6b3dd5ad4fd2f32718adaef606ac7aca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TS 2.3 and under&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TS 2.3 이하&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7646ff7a27645ddbc2bb23a98cb8442f76858fe1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TS 2.4 and up&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TS 2.4 이상&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8497eed474718bc72853151f790b74187f2c7fd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The connection to the multicasted Observable is unsubscribed&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;멀티 캐스트 된 Observable에 대한 연결이 구독 해제되었습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ed94109423adc7864e5311e1fc56286c608c0c06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The multicasted Observable is connected&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;멀티 캐스트 된 Observable이 연결되었습니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="90bf18b1ad6ea31a02c0712a451768817863ff9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TypeScript user-defined prototype operators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TypeScript 사용자 정의 프로토 타입 연산자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0fd6589a319070a0e7bfc47072abae83661199ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;observeOn&lt;/code&gt; to schedule in what context will notifications be delivered.&lt;/strong&gt; As we saw in the examples above, instance operator &lt;code&gt;observeOn(scheduler)&lt;/code&gt; introduces a mediator Observer between the source Observable and the destination Observer, where the mediator schedules calls to the destination Observer using your given &lt;code&gt;scheduler&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;observeOn&lt;/code&gt; 을 사용 하여 알림을 전달할 컨텍스트를 예약 하십시오 .&lt;/strong&gt; 위의 예에서 알 수 있듯이 인스턴스 운영자 &lt;code&gt;observeOn(scheduler)&lt;/code&gt; 는 소스 Observable과 대상 Observer 사이에 중재자 Observer를 도입합니다. 여기서 중재자는 지정된 &lt;code&gt;scheduler&lt;/code&gt; 사용하여 대상 Observer에 대한 호출을 예약 합니다.</target>
        </trans-unit>
        <trans-unit id="fc501f48fc8f14891b059480a7053bc23bc4bcf9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use &lt;code&gt;subscribeOn&lt;/code&gt; to schedule in what context will the &lt;code&gt;subscribe()&lt;/code&gt; call happen.&lt;/strong&gt; By default, a &lt;code&gt;subscribe()&lt;/code&gt; call on an Observable will happen synchronously and immediately. However, you may delay or schedule the actual subscription to happen on a given Scheduler, using the instance operator &lt;code&gt;subscribeOn(scheduler)&lt;/code&gt;, where &lt;code&gt;scheduler&lt;/code&gt; is an argument you provide.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;subscribeOn&lt;/code&gt; 을 사용 하여 &lt;code&gt;subscribe()&lt;/code&gt; 호출이 발생 하는 컨텍스트를 예약 하십시오 . &lt;/strong&gt;기본적으로 Observable 의 &lt;code&gt;subscribe()&lt;/code&gt; 호출은 동 기적으로 즉시 수행됩니다. 그러나 인스턴스 운영자 &lt;code&gt;subscribeOn(scheduler)&lt;/code&gt; 사용하여 지정된 스케줄러에서 발생하는 실제 구독을 지연 시키거나 스케줄 할 수 있습니다 . 여기서 &lt;code&gt;scheduler&lt;/code&gt; 는 사용자가 제공하는 인수입니다.</target>
        </trans-unit>
        <trans-unit id="f02212ebedff47f3c2d37899d71ae6efdb50385f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING&lt;/strong&gt; Parts of the fetch API are still experimental. &lt;code&gt;AbortController&lt;/code&gt; is required for this implementation to work and use cancellation appropriately.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; 페치 API의 일부는 아직 실험 중입니다. 이 구현이 작동하고 취소를 적절하게 사용하려면 &lt;code&gt;AbortController&lt;/code&gt; 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1891fe62d5c1ffcfee45323d0789bc157a1b7e2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; If the source Observable emits Observables quickly and endlessly, and the inner Observables it emits generally complete slower than the source emits, you can run into memory issues as the incoming Observables collect in an unbounded buffer.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 소스 Observable이 Observable을 빠르고 끝없이 방출하고 일반적으로 방출하는 내부 Observable이 소스가 방출하는 것보다 느리게 완료되면 들어오는 Observable이 무제한 버퍼에 수집 될 때 메모리 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cb773da4994f4f259ae2f115254f536579e71cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if source values arrive endlessly and faster than their corresponding inner Observables can complete, it will result in memory issues as inner Observables amass in an unbounded buffer waiting for their turn to be subscribed to.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 소스 값이 해당 내부 Observable이 완료 할 수있는 것보다 끝없이 빠르게 도착하면 내부 Observable이 차례가 구독되기를 기다리는 무제한 버퍼에 누적되므로 메모리 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="16407a2f9afdb7f2ce60cdb22355e0487e064350" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What are creation operators?&lt;/strong&gt; Distinct from pipeable operators, creation operators are functions that can be used to create an Observable with some common predefined behavior or by joining other Observables.</source>
          <target state="translated">&lt;strong&gt;생성 연산자 란 무엇입니까? &lt;/strong&gt;파이프 가능한 연산자와 구별되는 생성 연산자는 일반적인 사전 정의 된 동작으로 다른 Observable과 결합하여 Observable을 작성하는 데 사용할 수있는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="a15df290a491ec301883de6ed75f191f29efc83f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is Pull?&lt;/strong&gt; In Pull systems, the Consumer determines when it receives data from the data Producer. The Producer itself is unaware of when the data will be delivered to the Consumer.</source>
          <target state="translated">&lt;strong&gt;풀이 란? &lt;/strong&gt;풀 시스템에서 소비자는 데이터 생산자로부터 데이터를 수신 할시기를 결정합니다. 생산자 자체는 언제 데이터가 소비자에게 전달 될지 모릅니다.</target>
        </trans-unit>
        <trans-unit id="712dfa59ac3cdd93a3d866043138aa70bec8cb8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is Push?&lt;/strong&gt; In Push systems, the Producer determines when to send data to the Consumer. The Consumer is unaware of when it will receive that data.</source>
          <target state="translated">&lt;strong&gt;푸시 란? &lt;/strong&gt;푸시 시스템에서 생산자는 소비자에게 데이터를 보낼시기를 결정합니다. 소비자는 언제 해당 데이터를 받을지 모릅니다.</target>
        </trans-unit>
        <trans-unit id="6e4e1cb26de7af121d4d8d54dca402173b733a70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a Scheduler?&lt;/strong&gt; A scheduler controls when a subscription starts and when notifications are delivered. It consists of three components.</source>
          <target state="translated">&lt;strong&gt;스케줄러 란 무엇입니까? &lt;/strong&gt;스케줄러는 구독이 시작되는시기와 알림이 전달되는시기를 제어합니다. 세 가지 구성 요소로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2d2a4d77a523e5f22052a30bccc030255bae1a0d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a Subject?&lt;/strong&gt; An RxJS Subject is a special type of Observable that allows values to be multicasted to many Observers. While plain Observables are unicast (each subscribed Observer owns an independent execution of the Observable), Subjects are multicast.</source>
          <target state="translated">&lt;strong&gt;주제 란 무엇입니까? &lt;/strong&gt;RxJS 주제는 값을 여러 관찰자에게 멀티 캐스트 할 수있는 특수한 유형의 관찰 가능입니다. 일반 Observable은 유니 캐스트 (구독 된 Observer는 각각 Observable의 독립적 인 실행을 소유 함)이지만 주제는 멀티 캐스트입니다.</target>
        </trans-unit>
        <trans-unit id="10d4a8daeb2d6cb88fe9a685eea5d8b32f44696b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a Subscription?&lt;/strong&gt; A Subscription is an object that represents a disposable resource, usually the execution of an Observable. A Subscription has one important method, &lt;code&gt;unsubscribe&lt;/code&gt;, that takes no argument and just disposes the resource held by the subscription. In previous versions of RxJS, Subscription was called &quot;Disposable&quot;.</source>
          <target state="translated">&lt;strong&gt;구독이란 무엇입니까? &lt;/strong&gt;서브 스크립 션은 일회용 자원, 일반적으로 Observable의 실행을 나타내는 객체입니다. 서브 스크립 션에는 인수를 취하지 않고 서브 스크립 션이 보유한 자원을 폐기하는 중요한 방법 인 &lt;code&gt;unsubscribe&lt;/code&gt; 가 있습니다. 이전 버전의 RxJS에서는 구독을 &quot;일회용&quot;이라고했습니다.</target>
        </trans-unit>
        <trans-unit id="3c08f2aa1b9f97e99a2ace9631fba523ce2fd5c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;closeObserver&lt;/strong&gt; allows us to set a custom error when an error raise up.</source>
          <target state="translated">&lt;strong&gt;closeObserver를&lt;/strong&gt; 사용하면 오류가 발생할 때 사용자 정의 오류를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9617eb95fe095e9c89063af41768f15e1a35cf1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;combineLatest()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;combineLatest()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d99ba7b6ef9e2babf8c03e5482a1865fc0add46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;combineLatest&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;combineLatest&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cb88dd148fb5f8fde2a56a840fd602c4b4bdd87e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;concat&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;concat&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="93b6911eb6bffc04528624a72bd00d9ce4d69501" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;concatMap()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;concatMap()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee79ceed9ae5ea9c01c077904fc5aeebea2049a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;concatMapTo()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;concatMapTo()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dc0108ff4be926ab3398bb1da3b2169513a5b19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;deserializer&lt;/strong&gt;, the default for this property is &lt;code&gt;JSON.parse&lt;/code&gt; but since there are just two options for incomming data, either be text or binarydata. We can apply a custom deserialization strategy or just simply skip the default behaviour.</source>
          <target state="translated">&lt;strong&gt;deserializer&lt;/strong&gt; ,이 속성의 기본값은 &lt;code&gt;JSON.parse&lt;/code&gt; 이지만 들어오는 데이터에 대한 두 가지 옵션 (텍스트 또는 이진 데이터) 만 있습니다. 사용자 지정 역 직렬화 전략을 적용하거나 단순히 기본 동작을 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88b721e1327ee5ca846cce316ea3831e2a114c03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;exhaustMap()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;exhaustMap()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e64aa89b14e9f0fb930d801d1474b5a069471528" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;first()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;first()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42e9b71b0c9f6abe41f5d21d7b89bce1bc5a1757" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;forkJoin()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;forkJoin()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="02f22409ce12dc5cd696a8b7770bb37378c4161b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fromEvent()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;fromEvent()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9e7f297cde0f3e57a576c156803f456f4db3232" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;last()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;last()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2f99c5d66faa95e388d7a91e5e6a1a931e1e9e04" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;merge&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;merge&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be2ed258895844046061c6a16c4d7666a9c67e9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mergeMap()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;mergeMap()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="30a98a7c67095b1f9efa43fb3cf29683f8e7d437" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mergeMapTo()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;mergeMapTo()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="df9761fa7db55227d364bae7412590b4a16c3a00" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;openObserver&lt;/strong&gt;, Let's say we need to make some kind of init task before sending/receiving msgs to the webSocket or sending notification that the connection was successful, this is when openObserver is usefull for.</source>
          <target state="translated">&lt;strong&gt;openObserver&lt;/strong&gt; , &lt;strong&gt;webSocket에 메시지&lt;/strong&gt; 를 보내거나 받기 전에 또는 연결에 성공했다는 알림을 보내기 전에 일종의 초기화 작업을 수행해야한다고 가정 해 봅시다. 이것은 openObserver가 유용 할 때입니다.</target>
        </trans-unit>
        <trans-unit id="8538babf0df6e2488807caf11c32fb6442ea9a8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;path-mapping&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;path-mapping&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7a7c1c0408320eae8f251ee13416ba7fa8e9813" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;race&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;race&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8033164aedc67a47d9b741674b893e5df574ec71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs/ajax&lt;/strong&gt;: The Rx ajax implementation</source>
          <target state="translated">&lt;strong&gt;rxjs / ajax&lt;/strong&gt; : Rx 아약스 구현</target>
        </trans-unit>
        <trans-unit id="ee249de4ff74839d7d59160e6fa42747ac6d1f64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs/operators&lt;/strong&gt;: All pipeable operators:</source>
          <target state="translated">&lt;strong&gt;rxjs / operators&lt;/strong&gt; : 모든 파이프 가능 연산자 :</target>
        </trans-unit>
        <trans-unit id="b77ea218deb17c3d483e367c8b5e926f7e94fd62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs/testing&lt;/strong&gt;: The testing utilities</source>
          <target state="translated">&lt;strong&gt;rxjs / testing&lt;/strong&gt; : 테스트 유틸리티</target>
        </trans-unit>
        <trans-unit id="6f08d6ab32819c43824e650817b5cea7ae780d4d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs/webSocket:&lt;/strong&gt; The web socket subject implementation</source>
          <target state="translated">&lt;strong&gt;rxjs / webSocket :&lt;/strong&gt; 웹 소켓 주제 구현</target>
        </trans-unit>
        <trans-unit id="5b5978c6ff6549ebfd8d09317422f89f556f26bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;rxjs:&lt;/strong&gt; Creation methods, types, schedulers and utilities</source>
          <target state="translated">&lt;strong&gt;rxjs :&lt;/strong&gt; 작성 방법, 유형, 스케줄러 및 유틸리티</target>
        </trans-unit>
        <trans-unit id="5a96c3978998d062f56f520209675d5ca2e3200e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;serializer&lt;/strong&gt; allows us tom apply custom serialization strategy but for the outgoing messages</source>
          <target state="translated">&lt;strong&gt;serializer를&lt;/strong&gt; 사용하면 사용자 정의 직렬화 전략을 적용 할 수 있지만 발신 메시지는</target>
        </trans-unit>
        <trans-unit id="25d76e530dc6bddd9b5a2cbb5c4fc4417032db68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;switchMap()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;switchMap()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e09ba85c76d585a9df1b1dcd098e925200d3fff8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;switchMapTo()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;switchMapTo()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2d721ba21cdb4b4325c8bcbfaa215f9c4db0440" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;webpack.config.js&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;webpack.config.js&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37c0839b8cdacbbaae239d4a9bad18c24e1f7e5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;zip()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;zip()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37b86f110b2db8e46463dee1f96085d7c7d8c7ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;zip&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;zip&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d9cbda34fcb1655f6eac22b4d8800b2f74463f70" translate="yes" xml:space="preserve">
          <source>@example</source>
          <target state="translated">@example</target>
        </trans-unit>
        <trans-unit id="7752616a2a7d9f9dad2611e86f931cdee6d7370c" translate="yes" xml:space="preserve">
          <source>@example Converts a javascript object to an Observable</source>
          <target state="translated">@example 자바 스크립트 객체를 Observable로 변환</target>
        </trans-unit>
        <trans-unit id="69554a23de0b45d4239ec533bf92361e87963547" translate="yes" xml:space="preserve">
          <source>@param {Object} obj The object to inspect and turn into an Observable sequence. @param {Scheduler} [scheduler] An optional IScheduler to schedule when resulting Observable will emit values. @returns {(Observable&amp;lt;Array&amp;lt;string|T&amp;gt;&amp;gt;)} An observable sequence of [key, value] pairs from the object.</source>
          <target state="translated">@param {Object} obj 검사 할 객체로 Observable 시퀀스를 만듭니다. @param {Scheduler} [scheduler] Observable 결과가 발생하는시기를 예약하는 선택적 IScheduler입니다. @returns {(Observable &amp;lt;Array &amp;lt;string | T &amp;gt;&amp;gt;)} 객체에서 관찰 가능한 [키, 값] 쌍의 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="aecffaccb00ca124ca2411785bcddae1a5614c86" translate="yes" xml:space="preserve">
          <source>@param {S} initialState Initial state. @param {function (state: S): boolean} condition Condition to terminate generation (upon returning false). @param {function (state: S): S} iterate Iteration step function. @param {function (state: S): T} [resultSelector] Selector function for results produced in the sequence. @param {Scheduler} [scheduler] A &lt;a href=&quot;../class/scheduler&quot;&gt;&lt;code&gt;Scheduler&lt;/code&gt;&lt;/a&gt; on which to run the generator loop. If not provided, defaults to emitting immediately. @return {Observable</source>
          <target state="translated">@param {S} initialState 초기 상태입니다. @param {함수 (상태 : S) : 부울} 조건 생성을 종료하기위한 조건 (false 반환시). @param {함수 (상태 : S) : S} 반복 단계 함수를 반복합니다. @param {함수 (상태 : S) : T} [resultSelector] 시퀀스에서 생성 된 결과에 대한 선택기 기능. @param {Scheduler} [scheduler] 생성기 루프를 실행할 &lt;a href=&quot;../class/scheduler&quot;&gt; &lt;code&gt;Scheduler&lt;/code&gt; &lt;/a&gt; 입니다. 제공하지 않으면 기본적으로 즉시 방출됩니다. @return {관찰 가능</target>
        </trans-unit>
        <trans-unit id="a86b8f8b9392a35784c87db9c3a38fa906373730" translate="yes" xml:space="preserve">
          <source>@see &lt;a href=&quot;from&quot;&gt;&lt;code&gt;from&lt;/code&gt;&lt;/a&gt; @see &lt;a href=&quot;../class/observable#create&quot;&gt;&lt;code&gt;create&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">@see &lt;a href=&quot;from&quot;&gt; &lt;code&gt;from&lt;/code&gt; &lt;/a&gt; @see가 &lt;a href=&quot;../class/observable#create&quot;&gt; &lt;code&gt;create&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df198b98a019b86cf56dbdbe15e6f3192da5358f" translate="yes" xml:space="preserve">
          <source>A &quot;multicasted Observable&quot; passes notifications through a Subject which may have many subscribers, whereas a plain &quot;unicast Observable&quot; only sends notifications to a single Observer.</source>
          <target state="translated">&quot;멀티 캐스트 된 관찰 가능&quot;은 많은 가입자가있을 수있는 주제를 통해 알림을 전달하는 반면 일반 &quot;유니 캐스트 관찰 가능&quot;은 단일 관찰자에게만 알림을 전송합니다.</target>
        </trans-unit>
        <trans-unit id="92b8313735e022c08e283746820b60689e84e023" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; represents values belonging to the same group represented by a common key. The common key is available as the key field of a &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;../index/class/groupedobservable&quot;&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; 이&lt;/a&gt; 공통 키에 의해 나타낸 동일한 그룹에 속하는 값을 나타낸다. 공통 키는 &lt;a href=&quot;../index/class/groupedobservable&quot;&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; &lt;/a&gt; 인스턴스 의 키 필드로 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="d526b50bab2cb764a769f15056314286d65451b5" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; on which to run the generator loop. If not provided, defaults to emit immediately.</source>
          <target state="translated">&lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt; 에 발전기 루프를 실행합니다. 제공하지 않으면 기본적으로 즉시 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="b4ec8a1e9cab67d3465e14c22c1480c899232202" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to use for scheduling the emission of the complete notification.</source>
          <target state="translated">전체 알림의 방출을 예약하는 데 사용 하는 &lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt; 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="e3502d4cd60420575855768df193717ce7af823c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to use for scheduling the emission of the error notification.</source>
          <target state="translated">오류 알림의 방출을 예약하는 데 사용 하는 &lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt; 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="bfb45378875cd0dbee1204d3f1675469e0de052d" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; to use for scheduling the emissions of the notifications.</source>
          <target state="translated">알림의 방출을 예약하는 데 사용 하는 &lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt; 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="e45bc63b80ef36d258103d1502ec98c1bc283c44" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ReplaySubject&lt;/code&gt; is similar to a &lt;code&gt;BehaviorSubject&lt;/code&gt; in that it can send old values to new subscribers, but it can also &lt;em&gt;record&lt;/em&gt; a part of the Observable execution.</source>
          <target state="translated">&lt;code&gt;ReplaySubject&lt;/code&gt; 는 A와 유사하다 &lt;code&gt;BehaviorSubject&lt;/code&gt; 는 신규 가입자에 이전 값을 보낼 수 있다는 점에서, 그러나 또한 수 &lt;em&gt;기록&lt;/em&gt; 관찰 실행의 일부를.</target>
        </trans-unit>
        <trans-unit id="9266d79d79e506e9015638a1e7fa25d05eed2d9a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ReplaySubject&lt;/code&gt; records multiple values from the Observable execution and replays them to new subscribers.</source>
          <target state="translated">&lt;code&gt;ReplaySubject&lt;/code&gt; 는 관찰 실행 및 신규 가입자에 리플레이 그들로부터 여러 값을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="b627fb490427e84b2fb30afc924259f8c9213ca3" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;subscribe&lt;/code&gt; call is simply a way to start an &quot;Observable execution&quot; and deliver values or events to an Observer of that execution.</source>
          <target state="translated">A는 &lt;code&gt;subscribe&lt;/code&gt; 전화는 단순히 '관찰 가능한 실행 &quot;을 시작하고 그 실행의 관찰자에 값이나 이벤트를 제공하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="efd0bc3590ad0e5cd305fc066f8858e79d9f944e" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;Function&lt;/strong&gt; is a lazily evaluated computation that synchronously returns a single value on invocation.</source>
          <target state="translated">&lt;strong&gt;기능&lt;/strong&gt; 동기 호출에 하나의 값을 반환하는 느리게 평가 연산이다.</target>
        </trans-unit>
        <trans-unit id="3f042dfe09e5b8f66ba0f9c0ba654f1fd5be3a96" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;Promise&lt;/strong&gt; is a computation that may (or may not) eventually return a single value.</source>
          <target state="translated">&lt;strong&gt;약속&lt;/strong&gt; (또는되지 않을 수 있음), 결국 하나의 값을 반환 할 수 계산한다.</target>
        </trans-unit>
        <trans-unit id="65e785fe4afd3cb8b2772ccac68387742bbdc4b9" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;generator&lt;/strong&gt; is a lazily evaluated computation that synchronously returns zero to (potentially) infinite values on iteration.</source>
          <target state="translated">&lt;strong&gt;생성기는&lt;/strong&gt; 동기 복귀 반복에서 (잠재적 인) 무한 값 제로 느리게하는 평가 연산이다.</target>
        </trans-unit>
        <trans-unit id="787a4416e61a830e0934a34a8528eaf6a5d6f8a0" translate="yes" xml:space="preserve">
          <source>A Pipeable Operator is a function that takes an Observable as its input and returns another Observable. It is a pure operation: the previous Observable stays unmodified.</source>
          <target state="translated">파이프 가능 연산자는 Observable을 입력으로 사용하고 다른 Observable을 반환하는 함수입니다. 순수한 작업입니다. 이전 Observable은 수정되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="ee8f5678bb76afe5dd5b02ced66fb1b0d0044586" translate="yes" xml:space="preserve">
          <source>A Pipeable Operator is essentially a pure function which takes one Observable as input and generates another Observable as output. Subscribing to the output Observable will also subscribe to the input Observable.</source>
          <target state="translated">Pipeable Operator는 본질적으로 하나의 Observable을 입력으로 사용하고 다른 Observable을 출력으로 생성하는 순수한 기능입니다. 출력 Observable을 구독하면 입력 Observable도 구독합니다.</target>
        </trans-unit>
        <trans-unit id="8a8fb471411d33905e9737fbb68ea61b6feae34c" translate="yes" xml:space="preserve">
          <source>A Scheduler lets you define in what execution context will an Observable deliver notifications to its Observer.</source>
          <target state="translated">스케줄러를 사용하면 Observable이 어떤 실행 컨텍스트에서 Observer에게 알림을 전달할지 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1383655957399b6d6567929c08301e77b08501ae" translate="yes" xml:space="preserve">
          <source>A Subject is a special type of Observable that allows values to be multicasted to many Observers. Subjects are like EventEmitters.</source>
          <target state="translated">주제는 특수한 유형의 Observable로 값을 여러 관찰자에게 멀티 캐스트 할 수 있습니다. 주제는 EventEmitters와 같습니다.</target>
        </trans-unit>
        <trans-unit id="595e5accf5017b8e9b3a26eab2f3945e3ee64ffd" translate="yes" xml:space="preserve">
          <source>A Subject is like an Observable, but can multicast to many Observers. Subjects are like EventEmitters: they maintain a registry of many listeners.</source>
          <target state="translated">주제는 Observable과 비슷하지만 많은 Observer에게 멀티 캐스트 할 수 있습니다. 주제는 EventEmitters와 같습니다. 많은 청취자의 레지스트리를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="59267fecd593def896e3fba4fd2bf602984d25ea" translate="yes" xml:space="preserve">
          <source>A Subscribable or Promise of notifications to start new buffers.</source>
          <target state="translated">새 버퍼를 시작하기위한 알림의 구독 또는 약속.</target>
        </trans-unit>
        <trans-unit id="7313d23b65818f64b6af3fe148cd41e7983c1394" translate="yes" xml:space="preserve">
          <source>A Subscription essentially just has an &lt;code&gt;unsubscribe()&lt;/code&gt; function to release resources or cancel Observable executions.</source>
          <target state="translated">Subscription에는 기본적으로 &lt;code&gt;unsubscribe()&lt;/code&gt; 함수가있어 리소스를 해제하거나 Observable 실행을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="c63c60cba20643163ad3c75c34404680f19c072f" translate="yes" xml:space="preserve">
          <source>A WebSocket constructor to use. This is useful for situations like using a WebSocket impl in Node (WebSocket is a DOM API), or for mocking a WebSocket for testing purposes</source>
          <target state="translated">사용할 WebSocket 생성자. 이는 노드에서 WebSocket impl을 사용하거나 (WebSocket은 DOM API 임) 테스트 목적으로 WebSocket을 조롱하는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a9e61acb5afa79b453b4ba08613ae03fd867cf3a" translate="yes" xml:space="preserve">
          <source>A backward-compatibility layer eases the update process, allowing you to keep your apps working while you address most code changes at your own pace. The overall process can be carried out in stages:</source>
          <target state="translated">이전 버전과의 호환성 계층으로 업데이트 프로세스가 쉬워 지므로 대부분의 코드 변경 사항을 원하는대로 처리하면서 앱이 계속 작동 할 수 있습니다. 전체 프로세스는 다음 단계로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bd800c7ab855f649fc2eab1b004a611c7c13886" translate="yes" xml:space="preserve">
          <source>A basic test might look as follows:</source>
          <target state="translated">기본 테스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eef697f1cf672e4d57623879c7156c74ecc95eec" translate="yes" xml:space="preserve">
          <source>A boolean function to select what values are to be counted. It is provided with arguments of:</source>
          <target state="translated">계산할 값을 선택하는 부울 함수입니다. 다음과 같은 인수가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8f45c3c3413edfacde63e5866f13cd65204265d1" translate="yes" xml:space="preserve">
          <source>A configuration object for the fetch. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters&quot;&gt;See MDN for more details&lt;/a&gt;</source>
          <target state="translated">페치에 대한 구성 오브젝트. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters&quot;&gt;자세한 내용은 MDN을 참조하십시오&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c4de04a5af82cb23d096ab9e62b3870971781c1" translate="yes" xml:space="preserve">
          <source>A deserializer used for messages arriving on the socket from the server. Defaults to JSON.parse.</source>
          <target state="translated">서버에서 소켓에 도착하는 메시지에 사용되는 디시리얼라이저입니다. 기본값은 JSON.parse입니다.</target>
        </trans-unit>
        <trans-unit id="d167c96728eb69fa561194cbec15b9f0fe0d7285" translate="yes" xml:space="preserve">
          <source>A diagram in the marble DSL. Letters map to keys in &lt;code&gt;values&lt;/code&gt; if provided.</source>
          <target state="translated">대리석 DSL의 다이어그램. 문자는 제공된 경우 &lt;code&gt;values&lt;/code&gt; 키에 매핑 됩니다.</target>
        </trans-unit>
        <trans-unit id="f009493c51fc2592cb8421af3d23ee4de3965f99" translate="yes" xml:space="preserve">
          <source>A factory function called to produce the error to be thrown when the source observable completes without emitting a value.</source>
          <target state="translated">소스 관찰 가능 값이 완료되지 않고 완료 될 때 발생하는 오류를 생성하기 위해 호출 된 팩토리 함수입니다.</target>
        </trans-unit>
        <trans-unit id="b40eaa47a4ae0d329a8fa61931721257cccf71cf" translate="yes" xml:space="preserve">
          <source>A flag to indicate whether this Subscription has already been unsubscribed.</source>
          <target state="translated">이 구독이 이미 구독 해제되었는지 여부를 나타내는 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="02bee705142a9e998ed4143d3f997683135a4d25" translate="yes" xml:space="preserve">
          <source>A function called with each item to test for condition matching.</source>
          <target state="translated">조건 일치를 테스트하기 위해 각 항목과 함께 호출되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="2ee4f743ea411d4ec9d0fd32831905e9c306b5b3" translate="yes" xml:space="preserve">
          <source>A function describing how to perform the disposal of resources when the &lt;code&gt;unsubscribe&lt;/code&gt; method is called.</source>
          <target state="translated">&lt;code&gt;unsubscribe&lt;/code&gt; 메소드가 호출 될 때 자원 처리를 수행하는 방법을 설명하는 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="a174085e61b79f49711a9af69a212b61636f083c" translate="yes" xml:space="preserve">
          <source>A function for determining if an item meets a specified condition.</source>
          <target state="translated">항목이 지정된 조건을 충족하는지 확인하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="8a7581bf977049768d2d00279073287d26391eb0" translate="yes" xml:space="preserve">
          <source>A function representing a task, or some unit of work to be executed by the Scheduler.</source>
          <target state="translated">스케줄러가 실행할 태스크 또는 일부 작업 단위를 나타내는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="a7aff61d4e068dee4178bfa46d0c1c9fd8cd2470" translate="yes" xml:space="preserve">
          <source>A function that evaluates a value emitted by the source Observable and returns a boolean. Also takes the (zero-based) index as the second argument.</source>
          <target state="translated">소스 Observable이 방출 한 값을 평가하고 부울을 리턴하는 함수입니다. 또한 (0부터 시작) 인덱스를 두 번째 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f3ab69212cd1f782cb1df01a2c437c820bc7a64d" translate="yes" xml:space="preserve">
          <source>A function that evaluates each value emitted by the source Observable. If it returns &lt;code&gt;true&lt;/code&gt;, the value is emitted on the first Observable in the returned array, if &lt;code&gt;false&lt;/code&gt; the value is emitted on the second Observable in the array. The &lt;code&gt;index&lt;/code&gt; parameter is the number &lt;code&gt;i&lt;/code&gt; for the i-th source emission that has happened since the subscription, starting from the number &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">소스 Observable이 방출 한 각 값을 평가하는 함수입니다. &lt;code&gt;true&lt;/code&gt; 를 반환 하면 반환 된 배열의 첫 번째 Observable에서 값이 생성 되고, &lt;code&gt;false&lt;/code&gt; 이면 배열 의 두 번째 Observable에서 값이 생성됩니다. &lt;code&gt;index&lt;/code&gt; 파라미터 개수 &lt;code&gt;i&lt;/code&gt; 숫자부터 가입 일어난 이후 i 번째의 소스 방출 용 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b06811fdd9e2d5cba0316a248e9cd4d70bbd164" translate="yes" xml:space="preserve">
          <source>A function that evaluates each value emitted by the source Observable. If it returns &lt;code&gt;true&lt;/code&gt;, the value is emitted, if &lt;code&gt;false&lt;/code&gt; the value is not passed to the output Observable. The &lt;code&gt;index&lt;/code&gt; parameter is the number &lt;code&gt;i&lt;/code&gt; for the i-th source emission that has happened since the subscription, starting from the number &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">소스 Observable이 방출 한 각 값을 평가하는 함수입니다. &lt;code&gt;true&lt;/code&gt; 를 반환 하면 값이 생성되고, &lt;code&gt;false&lt;/code&gt; 이면 출력 Observable에 값이 전달되지 않습니다. &lt;code&gt;index&lt;/code&gt; 파라미터 개수 &lt;code&gt;i&lt;/code&gt; 숫자부터 가입 일어난 이후 i 번째의 소스 방출 용 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e1cc55fd47812c320470c4debab0def8d7c31a3" translate="yes" xml:space="preserve">
          <source>A function that extracts the key for each item.</source>
          <target state="translated">각 항목의 키를 추출하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="3f20c2c55aa51748f5e336dd5f3cb99f33dbde47" translate="yes" xml:space="preserve">
          <source>A function that extracts the return element for each item.</source>
          <target state="translated">각 항목의 반환 요소를 추출하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="a7a58224a8bd100ed0e485a88080137b3854b471" translate="yes" xml:space="preserve">
          <source>A function that receives a value from the source Observable, for computing the silencing duration for each source value, returned as an Observable or a Promise.</source>
          <target state="translated">소스 Observable에서 각 소스 값의 침묵 지속 시간을 계산하기 위해 값을받는 함수는 Observable 또는 Promise로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1d7f24177fda0fadd63dbf54c962d5ab5af0557d" translate="yes" xml:space="preserve">
          <source>A function that receives a value from the source Observable, for computing the silencing duration, returned as an Observable or a Promise.</source>
          <target state="translated">침묵 지속 시간을 계산하기 위해 소스 Observable에서 값을받는 함수는 Observable 또는 Promise로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="436e0ae8e52a3c1bd4ebac765d2258eba7bc6c87" translate="yes" xml:space="preserve">
          <source>A function that receives a value from the source Observable, for computing the timeout duration for each source value, returned as an Observable or a Promise.</source>
          <target state="translated">각 소스 값에 대한 시간 종료 지속 기간을 계산하기 위해 소스 Observable에서 값을 수신하는 함수는 Observable 또는 Promise로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="825ac0575211babe238f66911631d9f77c0e8aed" translate="yes" xml:space="preserve">
          <source>A function that returns an Observable for each value emitted by the source Observable, which is then used to delay the emission of that item on the output Observable until the Observable returned from this function emits a value.</source>
          <target state="translated">소스 Observable에서 방출 된 각 값에 대해 Observable을 반환하는 함수이며,이 함수는이 함수에서 반환 된 Observable이 값을 방출 할 때까지 출력 Observable에서 해당 항목의 방출을 지연시키는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="181087b8926d4dacf4b94055e684261bebea38b7" translate="yes" xml:space="preserve">
          <source>A function that returns an Observable to determine how long each group should exist.</source>
          <target state="translated">각 그룹이 존재해야하는 기간을 결정하기 위해 Observable을 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="eac0f18ee26680057d8da59fa8a9a4494d446b1a" translate="yes" xml:space="preserve">
          <source>A function that takes a &lt;code&gt;handler&lt;/code&gt; function as an argument and removes it from the event source. If &lt;code&gt;addHandler&lt;/code&gt; returns some kind of token, &lt;code&gt;removeHandler&lt;/code&gt; function will have it as a second parameter.</source>
          <target state="translated">취하는 함수 &lt;code&gt;handler&lt;/code&gt; 인자로서 기능을하고, 이벤트 소스로부터 삭제. &lt;code&gt;addHandler&lt;/code&gt; 가 일종의 토큰을 리턴 하면 &lt;code&gt;removeHandler&lt;/code&gt; 함수는이를 두 번째 매개 변수로 갖습니다.</target>
        </trans-unit>
        <trans-unit id="512d938ca2d5a7413ab46f41aee1ed8553649e96" translate="yes" xml:space="preserve">
          <source>A function that takes a &lt;code&gt;handler&lt;/code&gt; function as argument and attaches it somehow to the actual source of events.</source>
          <target state="translated">필요한 기능 &lt;code&gt;handler&lt;/code&gt; 인수로 기능과 이벤트의 실제 소스에 어떻게 든 연결합니다.</target>
        </trans-unit>
        <trans-unit id="3a61edb60f61f060a406dfa0442bbf11948b3169" translate="yes" xml:space="preserve">
          <source>A function that takes no arguments and returns an Observable that signals (on either &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;complete&lt;/code&gt;) when to close the previous window and start a new one.</source>
          <target state="translated">인수를 취하지 않고 &lt;code&gt;next&lt;/code&gt; 또는 &lt;code&gt;complete&lt;/code&gt; 신호를 보내는 Observable을 반환하는 함수 이전 창을 닫고 새로 시작).</target>
        </trans-unit>
        <trans-unit id="b395dbcb5596f4c88f229c93db0ee664db88fae9" translate="yes" xml:space="preserve">
          <source>A function that takes no arguments and returns an Observable that signals buffer closure.</source>
          <target state="translated">인수를 취하지 않고 버퍼 클로저를 알리는 Observable을 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="eb8af6ffdd3fa19c6c972a4b39dd50cf5f5f1294" translate="yes" xml:space="preserve">
          <source>A function that takes the value emitted by the &lt;code&gt;openings&lt;/code&gt; observable and returns a Subscribable or Promise, which, when it emits, signals that the associated buffer should be emitted and cleared.</source>
          <target state="translated">&lt;code&gt;openings&lt;/code&gt; 의해 방출되는 가치를 취하는 기능 관측 가능하고 Subscribable 또는 Promise를 반환하는 함수로서 방출 될 때 관련 버퍼가 방출되고 지워 져야한다는 신호를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="7d19cda655bdbba514c8fec7bdafdf3f88786fc2" translate="yes" xml:space="preserve">
          <source>A function that takes the value emitted by the &lt;code&gt;openings&lt;/code&gt; observable and returns an Observable, which, when it emits (either &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;complete&lt;/code&gt;), signals that the associated window should complete.</source>
          <target state="translated">&lt;code&gt;openings&lt;/code&gt; 의해 방출 된 값을 관찰 가능하고 방출 할 때 ( &lt;code&gt;next&lt;/code&gt; 또는 &lt;code&gt;complete&lt;/code&gt; Observable을 반환하는 함수 ) 관련 창이 완료되어야한다는 신호를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="9369aa3d687e421514195d33b42429aec008ddf9" translate="yes" xml:space="preserve">
          <source>A function that, when applied to an item emitted by the source Observable, returns an Observable.</source>
          <target state="translated">소스 Observable이 방출 한 항목에 적용될 때 Observable을 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="e4521e5c267ddc4bb538190c2ca06dc029d5330e" translate="yes" xml:space="preserve">
          <source>A function that, when applied to an item emitted by the source or the output Observable, returns an Observable.</source>
          <target state="translated">소스 또는 출력 Observable에서 방출 된 항목에 적용될 때 Observable을 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="a84e17a04254867664848fc07b92b50560da7d6a" translate="yes" xml:space="preserve">
          <source>A function to generate the subscription message to be sent to the server. This will still be processed by the serializer in the WebSocketSubject's config. (Which defaults to JSON serialization)</source>
          <target state="translated">서버로 전송 될 구독 메시지를 생성하는 기능입니다. 이것은 여전히 ​​WebSocketSubject 구성의 시리얼 라이저에 의해 처리됩니다. (기본값은 JSON 직렬화입니다)</target>
        </trans-unit>
        <trans-unit id="a1d17233911c6a0e69dc28d400ccf5e8edbe8e23" translate="yes" xml:space="preserve">
          <source>A function to generate the unsubscription message to be sent to the server at teardown. This will still be processed by the serializer in the WebSocketSubject's config.</source>
          <target state="translated">해지시 서버에 전송 될 구독 취소 메시지를 생성하는 기능입니다. 이것은 여전히 ​​WebSocketSubject 구성의 시리얼 라이저에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="345023669dea9569b5e96a5b0a04ffc52aedf25a" translate="yes" xml:space="preserve">
          <source>A function to test each item emitted from the source Observable.</source>
          <target state="translated">소스 Observable에서 방출 된 각 항목을 테스트하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="20ba5bd927254728b204da746dfd84abfc0c9fa2" translate="yes" xml:space="preserve">
          <source>A function which creates an Observable, that can use injected resource object.</source>
          <target state="translated">주입 된 자원 오브젝트를 사용할 수있는 Observable을 작성하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="9ec4c214ea4517113854529a01f2d0f71b7f9ef9" translate="yes" xml:space="preserve">
          <source>A function which creates any resource object that implements &lt;code&gt;unsubscribe&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;unsubscribe&lt;/code&gt; 메소드 를 구현하는 모든 자원 오브젝트를 작성하는 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="085acb778c87b3d06d060ed301b6efeae7bf802c" translate="yes" xml:space="preserve">
          <source>A getter method that returns a number representing the current time (at the time this function was called) according to the scheduler's own internal clock.</source>
          <target state="translated">스케줄러의 내부 시계에 따라 현재 시간 (이 함수가 호출 된 시간)을 나타내는 숫자를 리턴하는 getter 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="06d29234ccfd4191ed3ffb325c080e536a830b43" translate="yes" xml:space="preserve">
          <source>A multicasted Observable uses a Subject under the hood to make multiple Observers see the same Observable execution.</source>
          <target state="translated">멀티 캐스트 된 Observable은 후드 아래의 주제를 사용하여 여러 Observer가 동일한 Observable 실행을 보게합니다.</target>
        </trans-unit>
        <trans-unit id="f1c6692289c195d88b6f02552c67a2b7ecc0cfc2" translate="yes" xml:space="preserve">
          <source>A normal Observer object or a callback for &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">정상적인 관찰자 객체 또는에 대한 콜백 &lt;code&gt;next&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b14e10f14b46eb52564b107c3c18922d62e81ef" translate="yes" xml:space="preserve">
          <source>A normalized AJAX response.</source>
          <target state="translated">정규화 된 AJAX 응답입니다.</target>
        </trans-unit>
        <trans-unit id="832e857924dcf7ac90856d16c612abe5583d2e58" translate="yes" xml:space="preserve">
          <source>A partially defined Observer or a &lt;code&gt;next&lt;/code&gt; callback function.</source>
          <target state="translated">부분적으로 정의 된 관찰자 또는 &lt;code&gt;next&lt;/code&gt; 콜백 함수</target>
        </trans-unit>
        <trans-unit id="3e7fcb0ff2bd1ab1f5f2e0116a79bcfe7f2f9174" translate="yes" xml:space="preserve">
          <source>A predicate for selecting the appropriate messages from the server for the output stream.</source>
          <target state="translated">서버에서 출력 스트림에 적합한 메시지를 선택하기위한 술어.</target>
        </trans-unit>
        <trans-unit id="69939066fee7c1a440ccb1dfd8dfbe76ef63e1ce" translate="yes" xml:space="preserve">
          <source>A predicate function to evaluate items emitted by the source Observable.</source>
          <target state="translated">소스 Observable이 방출 한 항목을 평가하는 술어 함수.</target>
        </trans-unit>
        <trans-unit id="ed983b10ec661fc781c33afc49596f31baaae0ee" translate="yes" xml:space="preserve">
          <source>A representation of any set of values over any amount of time. This is the most basic building block of RxJS.</source>
          <target state="translated">일정 시간 동안의 값 집합을 나타냅니다. 이것이 RxJS의 가장 기본적인 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="b9b66ed15a9a4e0c284c9afdfaeb0b0b176e9562" translate="yes" xml:space="preserve">
          <source>A serializer used to create messages from passed values before the messages are sent to the server. Defaults to JSON.stringify.</source>
          <target state="translated">메시지가 서버로 전송되기 전에 전달 된 값에서 메시지를 작성하는 데 사용되는 직렬 변환기입니다. 기본값은 JSON.stringify입니다.</target>
        </trans-unit>
        <trans-unit id="ff7eb2bf9dc197cd6db071463f78db0f65ad773e" translate="yes" xml:space="preserve">
          <source>A shortcut to create a Notification instance of the type &lt;code&gt;complete&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;complete&lt;/code&gt; 유형의 Notification 인스턴스를 작성하는 바로 가기 입니다.</target>
        </trans-unit>
        <trans-unit id="d81c5d3e349ae456b72b795ea3af164beb77755c" translate="yes" xml:space="preserve">
          <source>A shortcut to create a Notification instance of the type &lt;code&gt;error&lt;/code&gt; from a given error.</source>
          <target state="translated">주어진 오류에서 &lt;code&gt;error&lt;/code&gt; 유형의 알림 인스턴스를 작성하는 바로 가기 입니다.</target>
        </trans-unit>
        <trans-unit id="dc2ac3c034182e80275264531f2481e8b5aa45f0" translate="yes" xml:space="preserve">
          <source>A shortcut to create a Notification instance of the type &lt;code&gt;next&lt;/code&gt; from a given value.</source>
          <target state="translated">주어진 값에서 &lt;code&gt;next&lt;/code&gt; 유형의 Notification 인스턴스를 작성하는 바로 가기 입니다.</target>
        </trans-unit>
        <trans-unit id="c3d9971add316bca4c32c78db34ba1835fc86306" translate="yes" xml:space="preserve">
          <source>A similar effect could be achieved with &lt;a href=&quot;count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt;, but &lt;code&gt;isEmpty&lt;/code&gt; can emit a &lt;code&gt;false&lt;/code&gt; value sooner.</source>
          <target state="translated">&lt;a href=&quot;count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; &lt;code&gt;isEmpty&lt;/code&gt; 비슷한 효과를 얻을 수 있지만 isEmpty 는 더 빨리 &lt;code&gt;false&lt;/code&gt; 값을 방출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58aead400ac5e5653e3f72ddc4177b36ea162b31" translate="yes" xml:space="preserve">
          <source>A simple Observable that emits neither values nor errors nor the completion notification. It can be used for testing purposes or for composing with other Observables. Please note that by never emitting a complete notification, this Observable keeps the subscription from being disposed automatically. Subscriptions need to be manually disposed.</source>
          <target state="translated">값이나 오류 또는 완료 알림을 내 보내지 않는 간단한 Observable입니다. 테스트 목적이나 다른 Observable과 구성하기 위해 사용할 수 있습니다. 완전한 알림을 보내지 않으면 서이 Observable은 구독이 자동으로 처리되지 않도록합니다. 구독은 수동으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="daeebe20328b78c57c2965c3885cd4f9150827af" translate="yes" xml:space="preserve">
          <source>A simple example emitting true if all elements are less than 5, false otherwise</source>
          <target state="translated">모든 요소가 5보다 작 으면 true를, 그렇지 않으면 false를 방출하는 간단한 예제</target>
        </trans-unit>
        <trans-unit id="81e41a4a8e6d911462364fa9ad372501ccb3129c" translate="yes" xml:space="preserve">
          <source>A simple example with numbers</source>
          <target state="translated">숫자가있는 간단한 예</target>
        </trans-unit>
        <trans-unit id="0017d7fc0455f54b0b0d3ac7b46d34bb31004b1b" translate="yes" xml:space="preserve">
          <source>A static factory for a Subscriber, given a (potentially partial) definition of an Observer.</source>
          <target state="translated">관찰자에 대한 (잠재적으로 부분적인) 정의가 주어지면 구독자에 대한 정적 팩토리입니다.</target>
        </trans-unit>
        <trans-unit id="1a80de59cfb7fce6af657c15200a9ea50fa95ff4" translate="yes" xml:space="preserve">
          <source>A test example with specified values:</source>
          <target state="translated">지정된 값을 가진 테스트 예 :</target>
        </trans-unit>
        <trans-unit id="5904f92e91374bb07f1b8a9b7cf799d0276598a4" translate="yes" xml:space="preserve">
          <source>A test example with subscription assertions:</source>
          <target state="translated">구독 어설 션이있는 테스트 예제 :</target>
        </trans-unit>
        <trans-unit id="6d05f99bacc1009f0378c940ffbdf08d8d33492a" translate="yes" xml:space="preserve">
          <source>A typical example of a creation operator would be the &lt;code&gt;interval&lt;/code&gt; function. It takes a number (not an Observable) as input argument, and produces an Observable as output:</source>
          <target state="translated">작성 연산자의 일반적인 예는 &lt;code&gt;interval&lt;/code&gt; 함수입니다. 입력 인수로 숫자 (Observable이 아님)를 사용하고 Observable을 출력으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b3423f2e2a7685acbd8fc5ab4ba2ea70e1e221bb" translate="yes" xml:space="preserve">
          <source>A variant of Subject that &quot;replays&quot; or emits old values to new subscribers. It buffers a set number of values and will emit those values immediately to any new subscribers in addition to emitting new values to existing subscribers.</source>
          <target state="translated">신규 가입자에게 이전 값을 &quot;재생&quot;하거나 내보내는 주제의 변형입니다. 설정된 수의 값을 버퍼링하고 기존 구독자에게 새 값을 내보내는 것 외에도 새 구독자에게 해당 값을 즉시 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="77bd200819e8216578aa6a20682297a4fcdf7791" translate="yes" xml:space="preserve">
          <source>A variant of Subject that only emits a value when it completes. It will emit its latest value to all its observers on completion.</source>
          <target state="translated">완료 될 때만 값을 내보내는 주제의 변형입니다. 완료되면 모든 관찰자에게 최신 값을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="ce13e7226e5fa3326a58386cbacfa231b35fc1b1" translate="yes" xml:space="preserve">
          <source>A variant of Subject that requires an initial value and emits its current value whenever it is subscribed to.</source>
          <target state="translated">초기 값이 필요하고 구독 할 때마다 현재 값을 방출하는 Subject의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="6970dba4e61b8a8291ad7482373472fd7ab1cb7e" translate="yes" xml:space="preserve">
          <source>Accepts an &lt;code&gt;Array&lt;/code&gt; of &lt;a href=&quot;../type-alias/observableinput&quot;&gt;&lt;code&gt;ObservableInput&lt;/code&gt;&lt;/a&gt; or a dictionary &lt;code&gt;Object&lt;/code&gt; of &lt;a href=&quot;../type-alias/observableinput&quot;&gt;&lt;code&gt;ObservableInput&lt;/code&gt;&lt;/a&gt; and returns an &lt;a href=&quot;../class/observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt; that emits either an array of values in the exact same order as the passed array, or a dictionary of values in the same shape as the passed dictionary.</source>
          <target state="translated">수용 &lt;code&gt;Array&lt;/code&gt; 의 &lt;a href=&quot;../type-alias/observableinput&quot;&gt; &lt;code&gt;ObservableInput&lt;/code&gt; &lt;/a&gt; 또는 사전 &lt;code&gt;Object&lt;/code&gt; 의 &lt;a href=&quot;../type-alias/observableinput&quot;&gt; &lt;code&gt;ObservableInput&lt;/code&gt; 을&lt;/a&gt; 하고 반환 &lt;a href=&quot;../class/observable&quot;&gt; &lt;code&gt;Observable&lt;/code&gt; &lt;/a&gt; 그을 방출하거나 전달 배열 또는 전달 사전과 같은 형상의 사전 값과 완전히 같은 순서 값의 배열.</target>
        </trans-unit>
        <trans-unit id="f302cad0f3e21130c578083076708337124b26be" translate="yes" xml:space="preserve">
          <source>Add fallback observable</source>
          <target state="translated">폴백 관찰 가능 추가</target>
        </trans-unit>
        <trans-unit id="04b3ddff5046a21c4d3de14d423344ef2017b089" translate="yes" xml:space="preserve">
          <source>Add type definition file included in tsconfig.json or CLI argument.</source>
          <target state="translated">tsconfig.json 또는 CLI 인수에 포함 된 유형 정의 파일을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e96e9902a32c66c0b71790ad6985f9dd53265b5c" translate="yes" xml:space="preserve">
          <source>Additionally, subscriptions may be grouped together through the &lt;code&gt;add()&lt;/code&gt; method, which will attach a child Subscription to the current Subscription. When a Subscription is unsubscribed, all its children (and its grandchildren) will be unsubscribed as well.</source>
          <target state="translated">또한 서브 스크립 션은 &lt;code&gt;add()&lt;/code&gt; 메소드를 통해 그룹화되어 하위 서브 스크립 션을 현재 서브 스크립 션에 첨부합니다. 구독을 구독 취소하면 모든 하위 (및 손자)도 구독이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="0aa18f6c9ead1c7ca1c22b5cfd3ff2341aea9ebe" translate="yes" xml:space="preserve">
          <source>Adds a tear down to be called during the unsubscribe() of this Subscription. Can also be used to add a child subscription.</source>
          <target state="translated">이 서브 스크립 션의 unsubscribe () 중에 호출 될 분류를 추가합니다. 하위 구독을 추가하는 데 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdd3e24e6fb92b8a42d2faa20d75b3f18d75c394" translate="yes" xml:space="preserve">
          <source>After Observable emits value, it will complete immediately. This means even if &lt;code&gt;func&lt;/code&gt; calls callback again, values from second and consecutive calls will never appear on the stream. If you need to handle functions that call callbacks multiple times, check out &lt;a href=&quot;fromevent&quot;&gt;&lt;code&gt;fromEvent&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;fromeventpattern&quot;&gt;&lt;code&gt;fromEventPattern&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Observable이 값을 내면 즉시 완료됩니다. 이는 &lt;code&gt;func&lt;/code&gt; 이 콜백을 다시 호출 하더라도 두 번째 및 연속 호출의 값이 스트림에 표시되지 않음을 의미합니다. 콜백을 여러 번 호출하는 함수를 처리해야하는 경우 &lt;a href=&quot;fromevent&quot;&gt; &lt;code&gt;fromEvent&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;fromeventpattern&quot;&gt; &lt;code&gt;fromEventPattern&lt;/code&gt; 을&lt;/a&gt; 대신 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="62e230c5906ba4af3b736e1edf79883437e056f5" translate="yes" xml:space="preserve">
          <source>After registration, every time an event that we listen to happens, Observable returned by &lt;code&gt;fromEventPattern&lt;/code&gt; will emit value that event handler function was called with. Note that if event handler was called with more then one argument, second and following arguments will not appear in the Observable.</source>
          <target state="translated">등록 후, 우리가 듣는 이벤트가 발생할 때마다 &lt;code&gt;fromEventPattern&lt;/code&gt; 에 의해 리턴 된 Observable 은 이벤트 핸들러 함수가 호출 된 값을 방출합니다. 이벤트 핸들러가 둘 이상의 인수로 호출 된 경우 두 번째 및 다음 인수는 Observable에 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01e81606a47771087aa940effff843c4b9eaabf0" translate="yes" xml:space="preserve">
          <source>After the source observable completes, appends an emission and then completes too.</source>
          <target state="translated">소스 관측 가능이 완료되면 방출을 추가 한 다음 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="812b4c6aa91173811b26dca0debd2d93641cd98c" translate="yes" xml:space="preserve">
          <source>AjaxError</source>
          <target state="translated">AjaxError</target>
        </trans-unit>
        <trans-unit id="e1175723771662904588d76a2118378edca8e6d8" translate="yes" xml:space="preserve">
          <source>AjaxRequest</source>
          <target state="translated">AjaxRequest</target>
        </trans-unit>
        <trans-unit id="b50c373483c8fcf45654d5d17af76c8e637c982d" translate="yes" xml:space="preserve">
          <source>AjaxResponse</source>
          <target state="translated">AjaxResponse</target>
        </trans-unit>
        <trans-unit id="9af59b49cf059f9d459db29a4d043d065589afb4" translate="yes" xml:space="preserve">
          <source>AjaxTimeoutError</source>
          <target state="translated">AjaxTimeoutError</target>
        </trans-unit>
        <trans-unit id="105cfe4477aacf8249d3536b4bf75dabe360f308" translate="yes" xml:space="preserve">
          <source>Align the start of &lt;code&gt;xsubs&lt;/code&gt; and &lt;code&gt;ysubs&lt;/code&gt; diagrams with &lt;code&gt;expected&lt;/code&gt; diagram.</source>
          <target state="translated">&lt;code&gt;xsubs&lt;/code&gt; 및 &lt;code&gt;ysubs&lt;/code&gt; 다이어그램 의 시작을 &lt;code&gt;expected&lt;/code&gt; 다이어그램과 정렬하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ef4c56f1f3170c1f08a8ed6c2e4fe9df4af5b0f" translate="yes" xml:space="preserve">
          <source>All Module Types (CJS/ES6/AMD/TypeScript) via npm</source>
          <target state="translated">npm을 통한 모든 모듈 유형 (CJS / ES6 / AMD / TypeScript)</target>
        </trans-unit>
        <trans-unit id="514510db8c4150ad0ec84a47308b42bde697ded1" translate="yes" xml:space="preserve">
          <source>All observable classes (&lt;a href=&quot;https://github.com/ReactiveX/rxjs/tree/5.5.8/src/observable&quot;&gt;https://github.com/ReactiveX/rxjs/tree/5.5.8/src/observable&lt;/a&gt;) have been removed from v6, in favor of existing or new operators that perform the same operations as the class methods. For example, &lt;code&gt;ArrayObservable.create(myArray)&lt;/code&gt; can be replaced by &lt;code&gt;from(myArray)&lt;/code&gt;, or the new operator &lt;code&gt;fromArray()&lt;/code&gt;.</source>
          <target state="translated">모든 관찰 가능한 클래스 ( &lt;a href=&quot;https://github.com/ReactiveX/rxjs/tree/5.5.8/src/observable&quot;&gt;https://github.com/ReactiveX/rxjs/tree/5.5.8/src/observable&lt;/a&gt; )는 클래스 메소드와 동일한 작업을 수행하는 기존 또는 새로운 연산자를 위해 v6에서 제거되었습니다. 예를 들어, &lt;code&gt;ArrayObservable.create(myArray)&lt;/code&gt; 에 의해 대체 될 수있다 &lt;code&gt;from(myArray)&lt;/code&gt; , 또는 새로운 오퍼레이터 &lt;code&gt;fromArray()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0570b2ca99e5e7005b25a7d91319eade51046745" translate="yes" xml:space="preserve">
          <source>Also see the &lt;a href=&quot;operators#join-creation-operators&quot;&gt;Join Creation Operators&lt;/a&gt; section above.</source>
          <target state="translated">위 의 &lt;a href=&quot;operators#join-creation-operators&quot;&gt;조인 생성 연산자&lt;/a&gt; 섹션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ddc4de29faa4779f5e84f09b14c51796f6f1d9db" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;run()&lt;/code&gt; executes entirely synchronously, the helper functions inside your callback function do not! These functions &lt;strong&gt;schedule assertions&lt;/strong&gt; that will execute either when your callback completes or when you explicitly call &lt;code&gt;flush()&lt;/code&gt;. Be wary of calling synchronous assertions, for example &lt;code&gt;expect&lt;/code&gt; from your testing library of choice, from within the callback. See &lt;a href=&quot;marble-testing#synchronous-assertion&quot;&gt;Synchronous Assertion&lt;/a&gt; for more information on how to do this.</source>
          <target state="translated">&lt;code&gt;run()&lt;/code&gt; 완전히 동 기적으로 실행 되지만 콜백 함수 내부의 도우미 함수는 그렇지 않습니다! 이 함수 는 콜백이 완료되거나 명시 적으로 &lt;code&gt;flush()&lt;/code&gt; 호출 할 때 실행될 &lt;strong&gt;어설 션&lt;/strong&gt; 을 &lt;strong&gt;예약&lt;/strong&gt; 합니다 . 예를 들어 콜백 내에서 선택한 테스트 라이브러리에서 &lt;code&gt;expect&lt;/code&gt; 하는 동기식 어설 션 호출에주의하십시오 . 이를 수행하는 방법에 대한 자세한 정보는 &lt;a href=&quot;marble-testing#synchronous-assertion&quot;&gt;동기식 어설 션&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7290a7b1e738919f1fad7cc0ff505aa61251a321" translate="yes" xml:space="preserve">
          <source>Although this collection is not event target in itself, &lt;code&gt;fromEvent&lt;/code&gt; will iterate over all Nodes it contains and install event handler function in every of them. When returned Observable is unsubscribed, function will be removed from all Nodes.</source>
          <target state="translated">이 컬렉션 자체가 이벤트 대상은 아니지만 &lt;code&gt;fromEvent&lt;/code&gt; 는 포함 된 모든 노드를 반복하여 모든 이벤트 처리기 기능을 설치합니다. 리턴 된 Observable이 등록 해제되면 기능이 모든 노드에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2f3d96867ef3ae1b957b32b3ee78a80f323ec3df" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;Observable&lt;/strong&gt; is a lazily evaluated computation that can synchronously or asynchronously return zero to (potentially) infinite values from the time it's invoked onwards.</source>
          <target state="translated">&lt;strong&gt;관찰 가능한은&lt;/strong&gt; 동기식 또는 비동기식이있어 호출 이후 시점에서 (잠재적) 무한 값으로 0을 반환 할 수 느리게 평가 연산이다.</target>
        </trans-unit>
        <trans-unit id="fdabd30359339d2f65c66d1635f6a6017447f842" translate="yes" xml:space="preserve">
          <source>An Observable representing values belonging to the same group represented by a common key. The values emitted by a GroupedObservable come from the source Observable. The common key is available as the field &lt;code&gt;key&lt;/code&gt; on a GroupedObservable instance.</source>
          <target state="translated">공통 키로 표시되는 동일한 그룹에 속하는 값을 나타내는 Observable. GroupedObservable이 생성 한 값은 소스 Observable에서 가져옵니다. 공통 키는 GroupedObservable 인스턴스 에서 필드 &lt;code&gt;key&lt;/code&gt; 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="2126f07d8b41f5aaca35b6c0b56828a7558936a0" translate="yes" xml:space="preserve">
          <source>An Observable that completes the previous window and starts a new window.</source>
          <target state="translated">이전 창을 완료하고 새 창을 시작하는 Observable.</target>
        </trans-unit>
        <trans-unit id="eef9d9f524886759c9f7f7b8471abe2dc0dbd650" translate="yes" xml:space="preserve">
          <source>An Observable that emits no items to the Observer and never completes.</source>
          <target state="translated">관찰자에게 항목을 내 보내지 않으며 완료되지 않는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="f5a1fcfb06b841150430ba58a7521f53ce01d9a1" translate="yes" xml:space="preserve">
          <source>An Observable that signals the buffer to be emitted on the output Observable.</source>
          <target state="translated">출력 Observable에서 방출 될 버퍼를 알리는 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="a31b174ccd32d747b6510dfee065773758e2d469" translate="yes" xml:space="preserve">
          <source>An Observable that triggers the subscription to the source Observable once it emits any value.</source>
          <target state="translated">소스 Observable에 대한 구독을 트리거하면 Observable이 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="773261e3c36d88f960d0387c51370a6a26126228" translate="yes" xml:space="preserve">
          <source>An Observable to replace each value from the source Observable.</source>
          <target state="translated">소스 Observable의 각 값을 대체 할 Observable입니다.</target>
        </trans-unit>
        <trans-unit id="b6e7ad14921bdce569edd7b5b3ca7dca5e12aabd" translate="yes" xml:space="preserve">
          <source>An Observer &lt;code&gt;complete&lt;/code&gt; callback.</source>
          <target state="translated">관찰자 &lt;code&gt;complete&lt;/code&gt; 콜백.</target>
        </trans-unit>
        <trans-unit id="8d40920acd75345296d3a12fbe36dadd5106b59a" translate="yes" xml:space="preserve">
          <source>An Observer &lt;code&gt;error&lt;/code&gt; callback.</source>
          <target state="translated">관찰자 &lt;code&gt;error&lt;/code&gt; 콜백</target>
        </trans-unit>
        <trans-unit id="d2e15da54f48a5ffa62a9bd03b8be8923ce3223c" translate="yes" xml:space="preserve">
          <source>An Observer &lt;code&gt;next&lt;/code&gt; callback.</source>
          <target state="translated">관찰자 &lt;code&gt;next&lt;/code&gt; 콜백.</target>
        </trans-unit>
        <trans-unit id="290534edc14a92a2f20f67f00211fac900855530" translate="yes" xml:space="preserve">
          <source>An Observer or the &lt;code&gt;next&lt;/code&gt; callback.</source>
          <target state="translated">관찰자 또는 &lt;code&gt;next&lt;/code&gt; 콜백</target>
        </trans-unit>
        <trans-unit id="8142d3c4512e5fc9ab5b382e6d48c2f2c070d795" translate="yes" xml:space="preserve">
          <source>An Observer than watches when close events occur on the underlying webSocket</source>
          <target state="translated">기본 webSocket에서 클로즈 이벤트가 발생할 때 감시하는 것보다 관찰자</target>
        </trans-unit>
        <trans-unit id="7657d899f5aaec99147ebbd9f77e9b0e634b3882" translate="yes" xml:space="preserve">
          <source>An Observer that watches when a close is about to occur due to unsubscription.</source>
          <target state="translated">구독 취소로 인해 마감이 가까워 질 때 관찰하는 관찰자입니다.</target>
        </trans-unit>
        <trans-unit id="3132b8e54e0ef31bfe72f5ff852390ecf6b3479f" translate="yes" xml:space="preserve">
          <source>An Observer that watches when open events occur on the underlying web socket.</source>
          <target state="translated">기본 웹 소켓에서 열린 이벤트가 발생하는시기를 감시하는 관찰자입니다.</target>
        </trans-unit>
        <trans-unit id="91c0a696b86c72c060aa4384dcb22d8de7a3a054" translate="yes" xml:space="preserve">
          <source>An error thrown when an Observable or a sequence was queried but has no elements.</source>
          <target state="translated">Observable 또는 시퀀스가 ​​쿼리되었지만 요소가 없을 때 발생하는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="da13ad6095d69814a5801a7d120440a1d6cab007" translate="yes" xml:space="preserve">
          <source>An error thrown when an action is invalid because the object has been unsubscribed.</source>
          <target state="translated">오브젝트가 등록 해제되어 조치가 유효하지 않은 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="edcf9ad5deaa38ba68865544115b17e656d8234c" translate="yes" xml:space="preserve">
          <source>An error thrown when an element was queried at a certain index of an Observable, but no such index or position exists in that sequence.</source>
          <target state="translated">Observable의 특정 인덱스에서 요소를 쿼리 할 때 오류가 발생했지만 해당 시퀀스에 해당 인덱스 또는 위치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e3bba335f950fd7f62a4632dd56239ddfb99ade9" translate="yes" xml:space="preserve">
          <source>An error thrown when duetime elapses.</source>
          <target state="translated">마감 시간이 경과하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="351c9f6fe481a21cfd383241cc681a6e67328aa7" translate="yes" xml:space="preserve">
          <source>An error thrown when one or more errors have occurred during the &lt;code&gt;unsubscribe&lt;/code&gt; of a &lt;a href=&quot;../class/subscription&quot;&gt;&lt;code&gt;Subscription&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">하나 이상의 오류가 동안 발생한 때 오류가 발생 &lt;code&gt;unsubscribe&lt;/code&gt; (A)의 &lt;a href=&quot;../class/subscription&quot;&gt; &lt;code&gt;Subscription&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9db7036f458eae0a4e55d2760ffc791aecceeada" translate="yes" xml:space="preserve">
          <source>An example comparing the first letters of the name</source>
          <target state="translated">이름의 첫 글자를 비교하는 예</target>
        </trans-unit>
        <trans-unit id="e65a68f21295f409926b7be91cbe2fa484218580" translate="yes" xml:space="preserve">
          <source>An example comparing the name of persons</source>
          <target state="translated">사람의 이름을 비교하는 예</target>
        </trans-unit>
        <trans-unit id="01e0a637d42f33d5f806ef0237a5736686d5cbad" translate="yes" xml:space="preserve">
          <source>An example using a compare function</source>
          <target state="translated">비교 기능을 사용하는 예</target>
        </trans-unit>
        <trans-unit id="97a9626aa65abda5d59774630093d7b017384c98" translate="yes" xml:space="preserve">
          <source>An example using a keySelector function</source>
          <target state="translated">keySelector 함수를 사용한 예제</target>
        </trans-unit>
        <trans-unit id="b56783c677e083451fb563ec7d3d0942623e25d6" translate="yes" xml:space="preserve">
          <source>An execution context and a data structure to order tasks and schedule their execution. Provides a notion of (potentially virtual) time, through the &lt;code&gt;now()&lt;/code&gt; getter method.</source>
          <target state="translated">작업을 주문하고 실행을 예약하기위한 실행 컨텍스트 및 데이터 구조 &lt;code&gt;now()&lt;/code&gt; getter 메소드를 통해 (잠재적으로 가상의) 시간 개념을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="8dd554f8f53b0e7325a2a34d17ed08bf4a5f2f7b" translate="yes" xml:space="preserve">
          <source>An object with &lt;code&gt;addListener&lt;/code&gt; and &lt;code&gt;removeListener&lt;/code&gt; methods.</source>
          <target state="translated">&lt;code&gt;addListener&lt;/code&gt; 및 &lt;code&gt;removeListener&lt;/code&gt; 메소드가 있는 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="8764ac07674a81492e4055cbd5febfdaa5d400ac" translate="yes" xml:space="preserve">
          <source>An object with &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;off&lt;/code&gt; methods</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 및 &lt;code&gt;off&lt;/code&gt; 메소드가 있는 객체</target>
        </trans-unit>
        <trans-unit id="9e40e670213d473533cefd4270f561e8408dc324" translate="yes" xml:space="preserve">
          <source>An observable of notifications to start new windows.</source>
          <target state="translated">새 창을 시작하라는 알림의 관찰 가능.</target>
        </trans-unit>
        <trans-unit id="4600b8f07b4000ea590f0835556e6c2afb8552ae" translate="yes" xml:space="preserve">
          <source>An optional argument to define what &lt;code&gt;this&lt;/code&gt; is in the &lt;code&gt;project&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;project&lt;/code&gt; 에서 &lt;code&gt;this&lt;/code&gt; 무엇인지 정의하는 선택적 인수 함수 입니다.</target>
        </trans-unit>
        <trans-unit id="dcc798e4ed4023df36df2945f6d44acbe266748f" translate="yes" xml:space="preserve">
          <source>An optional argument to determine the value of &lt;code&gt;this&lt;/code&gt; in the &lt;code&gt;predicate&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;predicate&lt;/code&gt; 함수 에서 &lt;code&gt;this&lt;/code&gt; 의 값을 결정하기위한 선택적 인수 .</target>
        </trans-unit>
        <trans-unit id="0f8b9e0b704b92c65ddc070628f4835bbb78aeac" translate="yes" xml:space="preserve">
          <source>An optional default value to provide if last predicate isn't met or no values were emitted.</source>
          <target state="translated">마지막 술어가 충족되지 않거나 값이 생성되지 않은 경우 제공하는 선택적 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="e052978179167326c8d61eac34c703447b1e61fb" translate="yes" xml:space="preserve">
          <source>An optional function called with each item to test for condition matching.</source>
          <target state="translated">조건 일치를 테스트하기 위해 각 항목과 함께 호출되는 선택적 기능입니다.</target>
        </trans-unit>
        <trans-unit id="11fde83a782627f966a91292359ee23e91c0e522" translate="yes" xml:space="preserve">
          <source>An optional function to compare each value pair</source>
          <target state="translated">각 값 쌍을 비교하는 선택적 기능</target>
        </trans-unit>
        <trans-unit id="44db2f22e6b5dff55846c4998171a7b720c141ea" translate="yes" xml:space="preserve">
          <source>Anatomy of a Test</source>
          <target state="translated">테스트 해부</target>
        </trans-unit>
        <trans-unit id="d54c716cf2e4abcaf1f883f748f7d86e57c136a9" translate="yes" xml:space="preserve">
          <source>Anatomy of an Observable</source>
          <target state="translated">관찰 가능한 해부학</target>
        </trans-unit>
        <trans-unit id="f5680c78958499a16c8fcf9016c85188d194ba63" translate="yes" xml:space="preserve">
          <source>And the output is the same:</source>
          <target state="translated">그리고 출력은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ef4d4c6fb57c79a8162041f226c5e4efb9e26af4" translate="yes" xml:space="preserve">
          <source>And the output is:</source>
          <target state="translated">그리고 출력은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="2198b9b68b5a6618e09f564fa6fda9a820559da6" translate="yes" xml:space="preserve">
          <source>And this is the same behavior with Observables:</source>
          <target state="translated">그리고 이것은 Observables와 같은 동작입니다 :</target>
        </trans-unit>
        <trans-unit id="214aff037545c6d78b224ab75b946443ebeacca1" translate="yes" xml:space="preserve">
          <source>Animation Frame Scheduler</source>
          <target state="translated">애니메이션 프레임 스케줄러</target>
        </trans-unit>
        <trans-unit id="0dd0b75d03698b8df77f879fc79e7a964c400184" translate="yes" xml:space="preserve">
          <source>Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications would be: [1, 2, 1, 2, 3, 4, 5, &lt;code&gt;complete&lt;/code&gt;].</source>
          <target state="translated">소스 Observable이 방출 한 모든 항목은 가입 실패 중에 생성 된 항목이라도 결과 Observable이 방출합니다. 예를 들어, Observable이 처음에는 실패하지만 [1, 2]를 방출하고 두 번째로 성공하고 [1, 2, 3, 4, 5]를 방출하면 배출 및 알림의 전체 스트림은 다음과 같습니다. [1, 2 , 1, 2, 3, 4, 5, &lt;code&gt;complete&lt;/code&gt; ].</target>
        </trans-unit>
        <trans-unit id="d23ece9441868386248d50c2f4a407afa2b6ac2c" translate="yes" xml:space="preserve">
          <source>Any library that imports a patch operator will augment the &lt;code&gt;Observable.prototype&lt;/code&gt; for all consumers of that library, creating blind dependencies. If the library removes their usage, they unknowingly break everyone else. With pipeables, you have to import the operators you need into each file you use them in.</source>
          <target state="translated">패치 연산자를 가져 오는 라이브러리 는 해당 라이브러리의 모든 소비자에 대한 &lt;code&gt;Observable.prototype&lt;/code&gt; 을 보강하여 맹인 종속성을 만듭니다. 라이브러리가 사용법을 제거하면 모르게 다른 모든 사람이 중단됩니다. 파이프 가능 파일을 사용하면 필요한 연산자를 사용하는 각 파일로 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="5a9be752cd40fb5aa6726b480b2cc085a184fb0b" translate="yes" xml:space="preserve">
          <source>Any number of Observables provided either as an array or as an arguments passed directly to the operator.</source>
          <target state="translated">배열 또는 연산자로 직접 전달되는 인수로 제공되는 모든 Observable.</target>
        </trans-unit>
        <trans-unit id="7a81bf5d2d1e477c23e38f5412482a72481c13bc" translate="yes" xml:space="preserve">
          <source>Apart from starting the execution of an Observable, this method allows you to listen for values that an Observable emits, as well as for when it completes or errors. You can achieve this in two of the following ways.</source>
          <target state="translated">Observable의 실행을 시작하는 것 외에도이 메소드를 사용하면 Observable이 생성 한 값과 완료 또는 오류 시점을 청취 할 수 있습니다. 다음 두 가지 방법으로이를 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff7736e9905851cb4d03cef20435fde04d60ad18" translate="yes" xml:space="preserve">
          <source>Applies a given &lt;code&gt;project&lt;/code&gt; function to each value emitted by the source Observable, and emits the resulting values as an Observable.</source>
          <target state="translated">소스 Observable에서 방출 된 각 값에 지정된 &lt;code&gt;project&lt;/code&gt; 기능을 적용 하고 결과 값을 Observable로 방출합니다.</target>
        </trans-unit>
        <trans-unit id="fb6220c1b034dd6ba15056fd67c656e6ac8dbc7a" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over the source Observable where the accumulator function itself returns an Observable, then each intermediate Observable returned is merged into the output Observable.</source>
          <target state="translated">누산기 함수 자체가 Observable을 반환하는 소스 Observable에 누산기 함수를 적용한 다음 반환 된 각 중간 Observable이 출력 Observable에 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="18af990d85065af126fe49df23d1000d8f9bea14" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over the source Observable, and returns each intermediate result, with an optional seed value.</source>
          <target state="translated">소스 Observable에 누산기 함수를 적용하고 선택적 시드 값과 함께 각 중간 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="896a5a66d1584a3cd0b7ce73ba41aa2daa7bfdd6" translate="yes" xml:space="preserve">
          <source>Applies an accumulator function over the source Observable, and returns the accumulated result when the source completes, given an optional seed value.</source>
          <target state="translated">소스 Observable에 누산기 함수를 적용하고, 선택적인 시드 값이 주어지면 소스가 완료 될 때 누적 된 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0cbc9507c24ae88b47a008f6d590f27d4404b1b6" translate="yes" xml:space="preserve">
          <source>ArgumentOutOfRangeError</source>
          <target state="translated">ArgumentOutOfRangeError</target>
        </trans-unit>
        <trans-unit id="d06d786204f911793c3c415d554d0f4e76454fb1" translate="yes" xml:space="preserve">
          <source>ArrayLikeObservable</source>
          <target state="translated">ArrayLikeObservable</target>
        </trans-unit>
        <trans-unit id="668878ff5d1e1cf54d4ec1d029de7b2fb934a432" translate="yes" xml:space="preserve">
          <source>ArrayObservable</source>
          <target state="translated">ArrayObservable</target>
        </trans-unit>
        <trans-unit id="66dcfefb4f4c7b689358e87ea28105b7823f1fa7" translate="yes" xml:space="preserve">
          <source>As a matter of fact, &lt;code&gt;observeOn&lt;/code&gt; accepts second parameter, which specifies in milliseconds with what delay notifications will be emitted. The main difference between &lt;a href=&quot;delay&quot;&gt;&lt;code&gt;delay&lt;/code&gt;&lt;/a&gt; operator and &lt;code&gt;observeOn&lt;/code&gt; is that &lt;code&gt;observeOn&lt;/code&gt; will delay all notifications - including error notifications - while &lt;code&gt;delay&lt;/code&gt; will pass through error from source Observable immediately when it is emitted. In general it is highly recommended to use &lt;code&gt;delay&lt;/code&gt; operator for any kind of delaying of values in the stream, while using &lt;code&gt;observeOn&lt;/code&gt; to specify which scheduler should be used for notification emissions in general.</source>
          <target state="translated">실제로 &lt;code&gt;observeOn&lt;/code&gt; 은 지연 알림이 발생하는 시간을 밀리 초 단위로 지정하는 두 번째 매개 변수를 허용합니다. 주요 차이점 &lt;a href=&quot;delay&quot;&gt; &lt;code&gt;delay&lt;/code&gt; &lt;/a&gt; 연산자와 &lt;code&gt;observeOn&lt;/code&gt; 는 점이다 &lt;code&gt;observeOn&lt;/code&gt; 가 오류 통지를 포함 - - 동안 모든 통지를 지연시킬 &lt;code&gt;delay&lt;/code&gt; 이 즉시 방출 될 때 소스로부터 관찰 가능한 오류를 통과한다. 일반적으로 스트림의 모든 값 지연에 대해 &lt;code&gt;delay&lt;/code&gt; 연산자 를 사용하는 것이 &lt;code&gt;observeOn&lt;/code&gt; 을 사용하여 일반적으로 알림 방출에 사용할 스케줄러를 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3d5c716ac8bd96d9826faee7f9bc5e977aad794e" translate="yes" xml:space="preserve">
          <source>As a stylistic matter, &lt;code&gt;op()(obs)&lt;/code&gt; is never used, even if there is only one operator; &lt;code&gt;obs.pipe(op())&lt;/code&gt; is universally preferred.</source>
          <target state="translated">문체 적으로 &lt;code&gt;op()(obs)&lt;/code&gt; 는 연산자가 하나만 있어도 절대 사용되지 않습니다. &lt;code&gt;obs.pipe(op())&lt;/code&gt; 가 보편적으로 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="968f7565b22c962aa3c40415db42dac7b144a148" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;bindcallback&quot;&gt;&lt;code&gt;bindCallback&lt;/code&gt;&lt;/a&gt;, context (&lt;code&gt;this&lt;/code&gt; property) of input function will be set to context of returned function, when it is called.</source>
          <target state="translated">&lt;a href=&quot;bindcallback&quot;&gt; &lt;code&gt;bindCallback&lt;/code&gt; 에서&lt;/a&gt; 와 같이 입력 함수의 컨텍스트 ( &lt;code&gt;this&lt;/code&gt; 특성)는 호출 될 때 리턴 된 함수의 컨텍스트로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="54800d323d149aa9eb668c0c0768a97a0cc7370b" translate="yes" xml:space="preserve">
          <source>Asap Scheduler</source>
          <target state="translated">최대한 빨리 스케줄러</target>
        </trans-unit>
        <trans-unit id="52a6e3d46a41f66b32f4c8d80361bb3892c5a671" translate="yes" xml:space="preserve">
          <source>Async Scheduler</source>
          <target state="translated">비동기 스케줄러</target>
        </trans-unit>
        <trans-unit id="81a3a332582f8b7c97ecac0a351df1689bfb7637" translate="yes" xml:space="preserve">
          <source>AsyncSubject</source>
          <target state="translated">AsyncSubject</target>
        </trans-unit>
        <trans-unit id="05e4550664a2860277fdca7625b41eb03e1da7ab" translate="yes" xml:space="preserve">
          <source>AsyncSubject._subscribe()</source>
          <target state="translated">AsyncSubject._subscribe()</target>
        </trans-unit>
        <trans-unit id="cdc3490a12008c174af711e0f3ece207778092a8" translate="yes" xml:space="preserve">
          <source>AsyncSubject.complete()</source>
          <target state="translated">AsyncSubject.complete()</target>
        </trans-unit>
        <trans-unit id="7ed8300fc48bbd3e79239add064fa42a036adee5" translate="yes" xml:space="preserve">
          <source>AsyncSubject.error()</source>
          <target state="translated">AsyncSubject.error()</target>
        </trans-unit>
        <trans-unit id="421d4487d1f2f065114b3871b83b0469818575a2" translate="yes" xml:space="preserve">
          <source>AsyncSubject.next()</source>
          <target state="translated">AsyncSubject.next()</target>
        </trans-unit>
        <trans-unit id="1f7d665c10ce012f074c9cbc8a3520a520d0e05d" translate="yes" xml:space="preserve">
          <source>Asynchronously subscribes Observers to this Observable on the specified &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;../index/interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt; 에서 Observer를이 Observable에 비동기 적으로 구독합니다 .</target>
        </trans-unit>
        <trans-unit id="b422e2c59989bd1e00ff26b3cef6aec5666b0b25" translate="yes" xml:space="preserve">
          <source>At this time the TestScheduler can only be used to test code that uses timers, like delay/debounceTime/etc (i.e. it uses AsyncScheduler with delays &amp;gt; 1). If the code consumes a Promise or does scheduling with AsapScheduler/AnimationFrameScheduler/etc it cannot be reliably tested with TestScheduler, but instead should be tested more traditionally. See the &lt;a href=&quot;marble-testing#known-issues&quot;&gt;Known Issues&lt;/a&gt; section for more details.</source>
          <target state="translated">현재 TestScheduler는 delay / debounceTime / etc와 같은 타이머를 사용하는 코드를 테스트하는 데만 사용할 수 있습니다 (즉, 지연이 1보다 큰 AsyncScheduler를 사용함). 코드가 Promise를 사용하거나 AsapScheduler / AnimationFrameScheduler 등으로 스케줄링하는 경우 TestScheduler를 사용하여 안정적으로 테스트 할 수 없지만 대신보다 전통적인 방식으로 테스트해야합니다. 자세한 내용은 &lt;a href=&quot;marble-testing#known-issues&quot;&gt;알려진 문제&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="068b119ae196b62a5a08d536ca924f4965b8125d" translate="yes" xml:space="preserve">
          <source>Attaches a timestamp to each item emitted by an observable indicating when it was emitted</source>
          <target state="translated">방출 시점을 나타내는 관찰 가능 항목이 방출 한 각 항목에 타임 스탬프를 첨부합니다.</target>
        </trans-unit>
        <trans-unit id="8fd78925dba59eef91afba0cdabe923520e5ee69" translate="yes" xml:space="preserve">
          <source>Backwards compatibility</source>
          <target state="translated">이전 버전과의 호환성</target>
        </trans-unit>
        <trans-unit id="c8932006bc9fb215b4928a3cadf6c2845e613b82" translate="yes" xml:space="preserve">
          <source>Basic Use</source>
          <target state="translated">기본 사용</target>
        </trans-unit>
        <trans-unit id="7308cb8418c068204c128968b5967fdf3606cc09" translate="yes" xml:space="preserve">
          <source>Basic methods</source>
          <target state="translated">기본 방법</target>
        </trans-unit>
        <trans-unit id="59428be2e125d7f441079c691a9bbee761fe6cb1" translate="yes" xml:space="preserve">
          <source>Because Observable Executions may be infinite, and it's common for an Observer to want to abort execution in finite time, we need an API for canceling an execution. Since each execution is exclusive to one Observer only, once the Observer is done receiving values, it has to have a way to stop the execution, in order to avoid wasting computation power or memory resources.</source>
          <target state="translated">Observable Executions는 무한 할 수 있으며 Observer가 유한 한 시간에 실행을 중단하려는 것이 일반적이므로 실행 취소를위한 API가 필요합니다. 각 실행은 하나의 관찰자에게만 배타적이기 때문에 일단 관찰자가 값 수신을 완료하면 계산 능력이나 메모리 자원 낭비를 피하기 위해 실행을 중지 할 방법이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3fe58a0f3e937be16a4d3adc3bbcdc21e755f616" translate="yes" xml:space="preserve">
          <source>Because RxJS uses the least concurrency scheduler, you can pick a different scheduler if you want to introduce concurrency for performance purpose. To specify a particular scheduler, you can use those operator methods that take a scheduler, e.g., &lt;code&gt;from([10, 20, 30], asyncScheduler)&lt;/code&gt;.</source>
          <target state="translated">RxJS는 최소 동시성 스케줄러를 사용하므로 성능 목적으로 동시성을 도입하려는 경우 다른 스케줄러를 선택할 수 있습니다. 특정 스케줄러를 지정하려면 스케줄러를 사용하는 연산자 메소드를 사용할 수 있습니다 &lt;code&gt;from([10, 20, 30], asyncScheduler)&lt;/code&gt; 예 : from ([10, 20, 30], asyncScheduler)) .</target>
        </trans-unit>
        <trans-unit id="86af633db829662420c6a9d8694edaad1afb49df" translate="yes" xml:space="preserve">
          <source>Before RxJS release v7, you will need to remove and replace all use of &lt;a href=&quot;migration#deprecations&quot;&gt;deprecated functionality&lt;/a&gt;.</source>
          <target state="translated">RxJS 릴리스 v7 이전에는 &lt;a href=&quot;migration#deprecations&quot;&gt;더 이상 사용되지 않는 기능을&lt;/a&gt; 모두 제거하고 교체해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="6910ad273ef167a843b9c22fe90ab4067b73a2e7" translate="yes" xml:space="preserve">
          <source>Before RxJS releases v7, you will need to remove and replace all use of deprecated functionality. The following areas contain deprecated functionality:</source>
          <target state="translated">RxJS 릴리스 v7 이전에는 더 이상 사용되지 않는 기능을 모두 제거하고 교체해야합니다. 다음 영역에는 더 이상 사용되지 않는 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="80a472e92e169440db08c5cb53e9880fe704c6ac" translate="yes" xml:space="preserve">
          <source>Before converting dot-chained operators to pipeable operators, make sure you import all operators used from &lt;code&gt;rxjs/operators&lt;/code&gt;. For example:</source>
          <target state="translated">도트 체인 연산자를 파이프 가능한 연산자로 변환하기 전에 &lt;code&gt;rxjs/operators&lt;/code&gt; 에서 사용 된 모든 연산자를 가져와야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5427d9bbbb297506a892f764b0a10b1efb9ef3e2" translate="yes" xml:space="preserve">
          <source>Before you can remove the compatibility layer, you must refactor your code to use only pipeable operators. For Typescript, the &lt;code&gt;tslint&lt;/code&gt; tool automates the process to some extent, by applying the transform to well-typed code.</source>
          <target state="translated">호환성 계층을 제거하기 전에 파이프 가능한 연산자 만 사용하도록 코드를 리팩터링해야합니다. Typescript의 경우 &lt;code&gt;tslint&lt;/code&gt; 도구는 변환을 올바른 형식의 코드에 적용하여 프로세스를 어느 정도 자동화합니다.</target>
        </trans-unit>
        <trans-unit id="5cb66fd20ca03a58764710f01cf907abc931d1ec" translate="yes" xml:space="preserve">
          <source>Behavior is different outside of &lt;code&gt;testScheduler.run(callback)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;testScheduler.run(callback)&lt;/code&gt; 외부에서 동작이 다릅니다</target>
        </trans-unit>
        <trans-unit id="368c978e94ba7ae5d0f5a362fef744af7dd7667e" translate="yes" xml:space="preserve">
          <source>BehaviorSubject</source>
          <target state="translated">BehaviorSubject</target>
        </trans-unit>
        <trans-unit id="09fcd7eca9f3082eeb05a34f8c6c349c912eacc6" translate="yes" xml:space="preserve">
          <source>BehaviorSubject._subscribe()</source>
          <target state="translated">BehaviorSubject._subscribe()</target>
        </trans-unit>
        <trans-unit id="656e17240ff3b7b269f8e9c364cfb41b688c27b5" translate="yes" xml:space="preserve">
          <source>BehaviorSubject.getValue()</source>
          <target state="translated">BehaviorSubject.getValue()</target>
        </trans-unit>
        <trans-unit id="2f226a2a37d46000d57385a4e6bc7b2abbb68c8b" translate="yes" xml:space="preserve">
          <source>BehaviorSubject.next()</source>
          <target state="translated">BehaviorSubject.next()</target>
        </trans-unit>
        <trans-unit id="df8979ce02d450847fa09bc10fa2a8741c7eea06" translate="yes" xml:space="preserve">
          <source>BehaviorSubjects are useful for representing &quot;values over time&quot;. For instance, an event stream of birthdays is a Subject, but the stream of a person's age would be a BehaviorSubject.</source>
          <target state="translated">BehaviorSubjects는 &quot;시간에 따른 값&quot;을 나타내는 데 유용합니다. 예를 들어, 생일의 이벤트 스트림은 주제이지만 개인의 나이의 스트림은 BehaviorSubject가됩니다.</target>
        </trans-unit>
        <trans-unit id="3a70d04c1ef62c14933cff1c5df6d13ef6a06dc8" translate="yes" xml:space="preserve">
          <source>Below is an example:</source>
          <target state="translated">아래는 예입니다.</target>
        </trans-unit>
        <trans-unit id="30731caf412562ba61e98248292d79cfc45fd636" translate="yes" xml:space="preserve">
          <source>Below you can see the anatomy of a marble diagram.</source>
          <target state="translated">아래에서 대리석 다이어그램의 해부학을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca1c302c34fc031ab37087b438ad1e0215b218b0" translate="yes" xml:space="preserve">
          <source>Both Observable &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; will emit their values directly and synchronously once they are subscribed to. This will result in the output of &lt;code&gt;1 2 3 4 5 6 7 8 9&lt;/code&gt;.</source>
          <target state="translated">Observable &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 모두 가입 한 후에 직접 및 동 기적으로 값을 방출합니다. 결과는 &lt;code&gt;1 2 3 4 5 6 7 8 9&lt;/code&gt; 의 결과가 됩니다.</target>
        </trans-unit>
        <trans-unit id="9cb922bf8af8668272484b70ff6096a26125cc4f" translate="yes" xml:space="preserve">
          <source>Both forms of &lt;code&gt;generate&lt;/code&gt; can optionally accept a scheduler. In case of multi-parameter call, scheduler simply comes as a last argument (no matter if there is resultSelector function or not). In case of single-parameter call, you can provide it as a &lt;code&gt;scheduler&lt;/code&gt; property on object passed to the operator. In both cases scheduler decides when next iteration of the loop will happen and therefore when next value will be emitted by the Observable. For example to ensure that each value is pushed to the observer on separate task in event loop, you could use &lt;code&gt;async&lt;/code&gt; scheduler. Note that by default (when no scheduler is passed) values are simply emitted synchronously.</source>
          <target state="translated">두 형태의 &lt;code&gt;generate&lt;/code&gt; 모두 선택적으로 스케줄러를 승인 할 수 있습니다. 다중 매개 변수 호출의 경우 스케줄러는 단순히 최종 인수로 제공됩니다 (resultSelector 함수의 유무에 관계없이). 단일 매개 변수 호출의 경우 운영자에게 전달 된 오브젝트에 &lt;code&gt;scheduler&lt;/code&gt; 특성으로 제공 할 수 있습니다 . 두 경우 모두 스케줄러는 루프의 다음 반복이 발생하는시기와 Observable이 다음 값을 생성 할시기를 결정합니다. 예를 들어, 이벤트 루프에서 별도의 작업을 수행 할 때 각 값이 관찰자에게 푸시되도록하려면 &lt;code&gt;async&lt;/code&gt; 스케줄러를 사용할 수 있습니다 . 기본적으로 (스케줄러가 전달되지 않은 경우) 값은 단순히 동기식으로 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="5f36985eed9db6051e472734cab05c794944ca1d" translate="yes" xml:space="preserve">
          <source>BoundCallbackObservable</source>
          <target state="translated">BoundCallbackObservable</target>
        </trans-unit>
        <trans-unit id="7ed5f49381a89f00035a1e54c238c08417cd22c7" translate="yes" xml:space="preserve">
          <source>BoundNodeCallbackObservable</source>
          <target state="translated">BoundNodeCallbackObservable</target>
        </trans-unit>
        <trans-unit id="0d8754ad2d4f272c021b8a6de30806cf10b10891" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable periodically in time.</source>
          <target state="translated">소스 Observable 값을 정기적으로 중첩 된 Observable로 분기하십시오.</target>
        </trans-unit>
        <trans-unit id="d5768cefc3dc6135e746fa10e7dc64978cd8c7d2" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable starting from an emission from &lt;code&gt;openings&lt;/code&gt; and ending when the output of &lt;code&gt;closingSelector&lt;/code&gt; emits.</source>
          <target state="translated">소스 Observable 값을 &lt;code&gt;openings&lt;/code&gt; 의 배출에서 시작하여 &lt;code&gt;closingSelector&lt;/code&gt; 의 출력이 방출 될 때 끝나는 중첩 된 Observable로 분기하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f875199af965263013c9045ea52ec0e0f71c9b4" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable using a factory function of closing Observables to determine when to start a new window.</source>
          <target state="translated">Observable을 닫는 팩토리 기능을 사용하여 소스 Observable 값을 중첩 Observable로 분기하여 새 창을 시작할시기를 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="d41ca8a818abab5874a4f5707cd8909fc3d690c8" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable whenever &lt;code&gt;windowBoundaries&lt;/code&gt; emits.</source>
          <target state="translated">&lt;code&gt;windowBoundaries&lt;/code&gt; 가 발생할 때마다 소스 Observable 값을 중첩 된 Observable로 분기하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c9602d8a405448b7a2d3de72389356d74e29054" translate="yes" xml:space="preserve">
          <source>Branch out the source Observable values as a nested Observable with each nested Observable emitting at most &lt;code&gt;windowSize&lt;/code&gt; values.</source>
          <target state="translated">소스 Observable 값을 중첩 된 Observable로 분기하여 각 중첩 Observable이 최대 &lt;code&gt;windowSize&lt;/code&gt; 값을 방출 하도록 합니다.</target>
        </trans-unit>
        <trans-unit id="a75f48b1b22b879f9c22d646edaa0759db697611" translate="yes" xml:space="preserve">
          <source>Breaking changes not covered by rxjs-compat</source>
          <target state="translated">rxjs-compat에서 다루지 않는 주요 변경 사항</target>
        </trans-unit>
        <trans-unit id="91726b714dab75ed3b7d092c95de02bacf38fad2" translate="yes" xml:space="preserve">
          <source>Buffers a number of values from the source Observable by &lt;code&gt;bufferSize&lt;/code&gt; then emits the buffer and clears it, and starts a new buffer each &lt;code&gt;startBufferEvery&lt;/code&gt; values. If &lt;code&gt;startBufferEvery&lt;/code&gt; is not provided or is &lt;code&gt;null&lt;/code&gt;, then new buffers are started immediately at the start of the source and when each buffer closes and is emitted.</source>
          <target state="translated">&lt;code&gt;bufferSize&lt;/code&gt; 에 의해 소스 Observable의 여러 값을 버퍼링 한 후 버퍼를 방출하고이를 지우고 각 &lt;code&gt;startBufferEvery&lt;/code&gt; 값 마다 새 버퍼를 시작 합니다. 경우 &lt;code&gt;startBufferEvery&lt;/code&gt; 이 제공되지 않았거나 &lt;code&gt;null&lt;/code&gt; 후 새로운 버퍼는 소스의 개시 때 즉시 각 버퍼 폐쇄 시작되어 방출된다.</target>
        </trans-unit>
        <trans-unit id="45860b887da4c0323bdef83a3c8f9aa2573f347f" translate="yes" xml:space="preserve">
          <source>Buffers the incoming Observable values until the given &lt;code&gt;closingNotifier&lt;/code&gt; Observable emits a value, at which point it emits the buffer on the output Observable and starts a new buffer internally, awaiting the next time &lt;code&gt;closingNotifier&lt;/code&gt; emits.</source>
          <target state="translated">지정된 &lt;code&gt;closingNotifier&lt;/code&gt; Observable이 값을 방출 할 때까지 들어오는 Observable 값을 버퍼링합니다 .이 시점에서 출력 Observable에서 버퍼를 방출하고 다음에 &lt;code&gt;closingNotifier&lt;/code&gt; 방출 될 때 까지 내부에서 새 버퍼를 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="15d7d3de47ff61c82d143794cb6ccfc5db3c977c" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values for a specific time period.</source>
          <target state="translated">특정 기간 동안 소스 Observable 값을 버퍼링합니다.</target>
        </trans-unit>
        <trans-unit id="24cf8cc6ee5fcd728d08f9677bba84affa9b2ed5" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values starting from an emission from &lt;code&gt;openings&lt;/code&gt; and ending when the output of &lt;code&gt;closingSelector&lt;/code&gt; emits.</source>
          <target state="translated">소스를 버퍼링합니다. &lt;code&gt;openings&lt;/code&gt; 로부터의 방출에서 시작하여 &lt;code&gt;closingSelector&lt;/code&gt; 의 출력이 방출 될 때 종료 되는 Observable 값 .</target>
        </trans-unit>
        <trans-unit id="5667b07dfc95ab11889cc351c1f1a6450c22be83" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values until &lt;code&gt;closingNotifier&lt;/code&gt; emits.</source>
          <target state="translated">&lt;code&gt;closingNotifier&lt;/code&gt; 때까지 소스 Observable 값을 버퍼링 합니다.</target>
        </trans-unit>
        <trans-unit id="aa0cc84b678395e32b914e69c26a7d621ee5a670" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values until the size hits the maximum &lt;code&gt;bufferSize&lt;/code&gt; given.</source>
          <target state="translated">크기가 주어진 최대 &lt;code&gt;bufferSize&lt;/code&gt; 에 도달 할 때까지 소스 Observable 값을 버퍼링합니다 .</target>
        </trans-unit>
        <trans-unit id="03884c4fb7d2e362201a4108c8ca60b6bfb2b71f" translate="yes" xml:space="preserve">
          <source>Buffers the source Observable values, using a factory function of closing Observables to determine when to close, emit, and reset the buffer.</source>
          <target state="translated">Observable을 닫고 방출하고 재설정 할시기를 결정하기 위해 Observable을 닫는 팩토리 기능을 사용하여 소스 Observable 값을 버퍼링합니다.</target>
        </trans-unit>
        <trans-unit id="eb04a2297b04b37862c0441dd71728bd5ba4a23a" translate="yes" xml:space="preserve">
          <source>Buffers values from the source by opening the buffer via signals from an Observable provided to &lt;code&gt;openings&lt;/code&gt;, and closing and sending the buffers when a Subscribable or Promise returned by the &lt;code&gt;closingSelector&lt;/code&gt; function emits.</source>
          <target state="translated">제공된 피 감시에서 신호를 통해 상기 버퍼를 열어 버퍼 소스 값과 &lt;code&gt;openings&lt;/code&gt; 및 폐쇄 및 등록 가능 또는 약속에 의해 리턴 될 때 송신 버퍼 &lt;code&gt;closingSelector&lt;/code&gt; 의 기능 방출한다.</target>
        </trans-unit>
        <trans-unit id="12d7e4a57d8db25980df2b5e57d6a44630d2bef0" translate="yes" xml:space="preserve">
          <source>Buffers values from the source for a specific time duration &lt;code&gt;bufferTimeSpan&lt;/code&gt;. Unless the optional argument &lt;code&gt;bufferCreationInterval&lt;/code&gt; is given, it emits and resets the buffer every &lt;code&gt;bufferTimeSpan&lt;/code&gt; milliseconds. If &lt;code&gt;bufferCreationInterval&lt;/code&gt; is given, this operator opens the buffer every &lt;code&gt;bufferCreationInterval&lt;/code&gt; milliseconds and closes (emits and resets) the buffer every &lt;code&gt;bufferTimeSpan&lt;/code&gt; milliseconds. When the optional argument &lt;code&gt;maxBufferSize&lt;/code&gt; is specified, the buffer will be closed either after &lt;code&gt;bufferTimeSpan&lt;/code&gt; milliseconds or when it contains &lt;code&gt;maxBufferSize&lt;/code&gt; elements.</source>
          <target state="translated">특정 시간 동안 &lt;code&gt;bufferTimeSpan&lt;/code&gt; 소스의 값을 버퍼링합니다 . 선택적 인수 인 &lt;code&gt;bufferCreationInterval&lt;/code&gt; 이 제공 되지 않으면 &lt;code&gt;bufferTimeSpan&lt;/code&gt; 밀리 초 마다 버퍼를 내보내고 재설정합니다 . 경우 &lt;code&gt;bufferCreationInterval&lt;/code&gt; 가 주어지고,이 오퍼레이터는 모든 버퍼 열리고 &lt;code&gt;bufferCreationInterval&lt;/code&gt; 의 밀리 폐쇄 (울리며 리셋)을 각 버퍼 &lt;code&gt;bufferTimeSpan&lt;/code&gt; 의 밀리. 선택적 인수 &lt;code&gt;maxBufferSize&lt;/code&gt; 를 지정하면 &lt;code&gt;bufferTimeSpan&lt;/code&gt; 밀리 초 후 또는 &lt;code&gt;maxBufferSize&lt;/code&gt; 요소 가 포함 된 버퍼가 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="2ab13858e624370f0f64b6c332c7f2614bc328c2" translate="yes" xml:space="preserve">
          <source>Build Your Own Operators Easily</source>
          <target state="translated">쉽게 자신의 운영자를 구축</target>
        </trans-unit>
        <trans-unit id="676f6ca72b7ceddfaefe05b718ec94fe4ee584db" translate="yes" xml:space="preserve">
          <source>Build and Treeshaking</source>
          <target state="translated">빌드 및 트리 쉐이킹</target>
        </trans-unit>
        <trans-unit id="fbdb16ef0c14df9ae818c34fde6140cc17ebec29" translate="yes" xml:space="preserve">
          <source>But how do you work with a higher-order Observable? Typically, by &lt;em&gt;flattening&lt;/em&gt;: by (somehow) converting a higher-order Observable into an ordinary Observable. For example:</source>
          <target state="translated">그러나 고차원 Observable로 어떻게 작업합니까? 일반적으로 &lt;em&gt;flattening&lt;/em&gt; : 고차원 Observable을 일반 Observable로 변환합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="81261945285e1f2fcd2cb9624774cb27067692f5" translate="yes" xml:space="preserve">
          <source>But if we instead us the &lt;code&gt;subscribeOn&lt;/code&gt; operator declaring that we want to use the &lt;a href=&quot;../index/const/asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; for values emited by Observable &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">그러나 대신에 &lt;code&gt;subscribeOn&lt;/code&gt; 연산자를 사용하면 Observable &lt;code&gt;a&lt;/code&gt; 가 방출하는 값에 대해 &lt;a href=&quot;../index/const/asyncscheduler&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt; 를 사용하고 싶다고 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="e6d6e0552657f23eb778d7b0e73b6e76e73ea9a7" translate="yes" xml:space="preserve">
          <source>But you can also &quot;return&quot; values asynchronously:</source>
          <target state="translated">그러나 값을 비동기 적으로 &quot;반환&quot;할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f90e5f831e73c22e973a350195d169a635741751" translate="yes" xml:space="preserve">
          <source>By default these arrays are emitted synchronously. To change that you can pass a &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt; as a second argument to &lt;code&gt;pairs&lt;/code&gt;.</source>
          <target state="translated">기본적으로 이러한 배열은 동 기적으로 방출됩니다. 이를 변경하려면 &lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt; 를 두 번째 인수로 &lt;code&gt;pairs&lt;/code&gt; 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab95b076b9a889a20adbe974f689337a0938a989" translate="yes" xml:space="preserve">
          <source>By default, results passed to the callback are emitted immediately after &lt;code&gt;func&lt;/code&gt; invokes the callback. In particular, if the callback is called synchronously, then the subscription of the resulting Observable will call the &lt;code&gt;next&lt;/code&gt; function synchronously as well. If you want to defer that call, you may use &lt;a href=&quot;../const/asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; just as before. This means that by using &lt;code&gt;Scheduler.async&lt;/code&gt; you can ensure that &lt;code&gt;func&lt;/code&gt; always calls its callback asynchronously, thus avoiding terrifying Zalgo.</source>
          <target state="translated">기본적으로 &lt;code&gt;func&lt;/code&gt; 이 콜백을 호출 한 직후 콜백에 전달 된 결과가 생성됩니다 . 특히, 콜백이 동 기적으로 호출되면 결과 Observable의 구독은 &lt;code&gt;next&lt;/code&gt; 함수도 동 기적으로 호출합니다 . 해당 통화를 연기하려면 이전과 마찬가지로 &lt;a href=&quot;../const/asyncscheduler&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 . 이는 &lt;code&gt;Scheduler.async&lt;/code&gt; 를 사용하여 &lt;code&gt;func&lt;/code&gt; 이 항상 콜백을 비동기식으로 호출하여 Zalgo를 무서워하지 않도록 할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="2f3c24c0b8ca48e155030e9400fba049ed478537" translate="yes" xml:space="preserve">
          <source>By not passing any scheduler, notifications are delivered synchronously and recursively. Use this for constant-time operations or tail recursive operations.</source>
          <target state="translated">스케줄러를 전달하지 않으면 알림이 동기 및 재귀 적으로 전달됩니다. 일정 시간 작업 또는 꼬리 재귀 작업에 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="511c31182dd5c650c4510a3c0301a11cadc8c586" translate="yes" xml:space="preserve">
          <source>By virtue of being a &lt;a href=&quot;../index/class/subject&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;WebSocketSubject&lt;/code&gt; allows for receiving and sending messages from the server. In order to communicate with a connected endpoint, use &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt; and &lt;code&gt;complete&lt;/code&gt; methods. &lt;code&gt;next&lt;/code&gt; sends a value to the server, so bear in mind that this value will not be serialized beforehand. Because of This, &lt;code&gt;JSON.stringify&lt;/code&gt; will have to be called on a value by hand, before calling &lt;code&gt;next&lt;/code&gt; with a result. Note also that if at the moment of nexting value there is no socket connection (for example no one is subscribing), those values will be buffered, and sent when connection is finally established. &lt;code&gt;complete&lt;/code&gt; method closes socket connection. &lt;code&gt;error&lt;/code&gt; does the same, as well as notifying the server that something went wrong via status code and string with details of what happened. Since status code is required in WebSocket API, &lt;code&gt;WebSocketSubject&lt;/code&gt; does not allow, like regular &lt;code&gt;Subject&lt;/code&gt;, arbitrary values being passed to the &lt;code&gt;error&lt;/code&gt; method. It needs to be called with an object that has &lt;code&gt;code&lt;/code&gt; property with status code number and optional &lt;code&gt;reason&lt;/code&gt; property with string describing details of an error.</source>
          <target state="translated">되는 미덕으로 &lt;a href=&quot;../index/class/subject&quot;&gt; &lt;code&gt;Subject&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;WebSocketSubject&lt;/code&gt; 가 수신 서버에서 메시지를 보낼 수 있습니다. 연결된 엔드 포인트와 통신하려면 &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;error&lt;/code&gt; 및 &lt;code&gt;complete&lt;/code&gt; 메소드를 사용하십시오. &lt;code&gt;next&lt;/code&gt; 는 서버에 값을 보내므로이 값은 미리 직렬화되지 않습니다. 이로 인해 &lt;code&gt;next&lt;/code&gt; 결과를 호출하기 전에 &lt;code&gt;JSON.stringify&lt;/code&gt; 를 직접 값으로 호출 해야합니다. 다음 값 순간에 소켓 연결이없는 경우 (예 : 아무도 가입하지 않은 경우) 해당 값이 버퍼링되고 연결이 설정되면 전송됩니다. &lt;code&gt;complete&lt;/code&gt; 메소드는 소켓 연결을 닫습니다. &lt;code&gt;error&lt;/code&gt; 는 동일한 일을 수행 할뿐 아니라 상태 코드 및 문자열을 통해 문제가 발생한 것을 서버에 알리는 것뿐만 아니라 발생하는 사항을 자세히 설명합니다. WebSocket API에는 상태 코드가 필요하므로 &lt;code&gt;WebSocketSubject&lt;/code&gt; 는 일반 &lt;code&gt;Subject&lt;/code&gt; 와 같이 임의의 값이 &lt;code&gt;error&lt;/code&gt; 메소드 에 전달되도록 허용하지 않습니다 . 상태 코드 번호 가있는 &lt;code&gt;code&lt;/code&gt; 특성과 오류의 세부 사항을 설명하는 문자열이있는 선택적 &lt;code&gt;reason&lt;/code&gt; 특성 이있는 오브젝트로 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="67b6c4b8addee6f0bec9b64fdc066f75fd594e81" translate="yes" xml:space="preserve">
          <source>CDN</source>
          <target state="translated">CDN</target>
        </trans-unit>
        <trans-unit id="2c85a73cd12db61768b9bb19ea9828e95032a59a" translate="yes" xml:space="preserve">
          <source>COMPLETE</source>
          <target state="translated">COMPLETE</target>
        </trans-unit>
        <trans-unit id="4590aa62874fd7b9a9997615d2263d8941afd9c2" translate="yes" xml:space="preserve">
          <source>Callback for errors in the source.</source>
          <target state="translated">소스 오류에 대한 콜백</target>
        </trans-unit>
        <trans-unit id="2a398f7106ab8cbcc00f7e0b623031a44b27c4c0" translate="yes" xml:space="preserve">
          <source>Callback for the completion of the source.</source>
          <target state="translated">소스 완성을위한 콜백</target>
        </trans-unit>
        <trans-unit id="6bc9d59a54f34bf3e88d0a22203ceafb349998a2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;connect()&lt;/code&gt; manually and handling the Subscription is often cumbersome. Usually, we want to &lt;em&gt;automatically&lt;/em&gt; connect when the first Observer arrives, and automatically cancel the shared execution when the last Observer unsubscribes.</source>
          <target state="translated">&lt;code&gt;connect()&lt;/code&gt; 수동으로 호출 하고 구독을 처리하는 것은 종종 성가신 일입니다. 일반적 &lt;em&gt;으로&lt;/em&gt; 첫 번째 관찰자가 도착하면 &lt;em&gt;자동으로&lt;/em&gt; 연결하고 마지막 관찰자가 구독을 취소하면 공유 실행을 자동으로 취소 하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="cac74e4863ea82589bf37f274214232a2020fde7" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;next&lt;/code&gt; does not affect subscribers of &lt;code&gt;WebSocketSubject&lt;/code&gt; - they have no information that something was sent to the server (unless of course the server responds somehow to a message). On the other hand, since calling &lt;code&gt;complete&lt;/code&gt; triggers an attempt to close socket connection. If that connection is closed without any errors, stream will complete, thus notifying all subscribers. And since calling &lt;code&gt;error&lt;/code&gt; closes socket connection as well, just with a different status code for the server, if closing itself proceeds without errors, subscribed Observable will not error, as one might expect, but complete as usual. In both cases (calling &lt;code&gt;complete&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;), if process of closing socket connection results in some errors, &lt;em&gt;then&lt;/em&gt; stream will error.</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; 호출 은 &lt;code&gt;WebSocketSubject&lt;/code&gt; 의 구독자에게 영향을 미치지 않습니다 . 서버가 메시지에 응답하지 않는 한 서버로 무언가가 전송되었다는 정보가 없습니다. 반면에 &lt;code&gt;complete&lt;/code&gt; 를 호출 하면 소켓 연결을 닫으려는 시도가 트리거됩니다. 해당 연결이 오류없이 닫히면 스트림이 완료되어 모든 가입자에게 알립니다. 그리고 &lt;code&gt;error&lt;/code&gt; 호출 하면 서버에 대한 다른 상태 코드로 소켓 연결도 닫히 므로 오류 없이 종료 자체가 진행되면 구독 가능한 Observable은 예상대로 오류가 아니라 평소와 같이 완료됩니다. 두 경우 모두 (호출 &lt;code&gt;complete&lt;/code&gt; 또는 &lt;code&gt;error&lt;/code&gt; ), 소켓 연결을 닫는 과정에서 일부 오류 가 발생 &lt;em&gt;하면&lt;/em&gt; 스트림 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="935e0374fc62004171fd85c905965758a1891c08" translate="yes" xml:space="preserve">
          <source>Cancel a subscription</source>
          <target state="translated">구독 취소</target>
        </trans-unit>
        <trans-unit id="9d1e2f3e476609e344df33a8265f591eb579afca" translate="yes" xml:space="preserve">
          <source>Catches errors on the observable to be handled by returning a new observable or throwing an error.</source>
          <target state="translated">새로운 Observable을 반환하거나 오류를 발생시켜 Observable의 오류를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="40e6c757452db48cd925951cfe7eef7f22c5e862" translate="yes" xml:space="preserve">
          <source>Categories of operators</source>
          <target state="translated">운영자 카테고리</target>
        </trans-unit>
        <trans-unit id="bf247e16c63f07775f0becbb509d151d49677413" translate="yes" xml:space="preserve">
          <source>Change at runtime which Observable will be subscribed</source>
          <target state="translated">Observable이 구독 할 런타임 변경</target>
        </trans-unit>
        <trans-unit id="acddfe6e0f84690d12ae8d6dba931938820b0320" translate="yes" xml:space="preserve">
          <source>Check if ticks are emitted within certain timespan</source>
          <target state="translated">특정 시간 내에 진드기가 방출되는지 확인</target>
        </trans-unit>
        <trans-unit id="4180596115cf7ecf0a22e17994523dc7e25709ef" translate="yes" xml:space="preserve">
          <source>Checks to see of all values emitted by both observables are equal, in order.</source>
          <target state="translated">두 옵저버 블에서 방출 된 모든 값이 순서대로 같은지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="3c6f0a9d624ec81db524dbe06b9e088e944f553b" translate="yes" xml:space="preserve">
          <source>Child Interfaces</source>
          <target state="translated">자식 인터페이스</target>
        </trans-unit>
        <trans-unit id="92a715716ffdf82ae0698aa576184e0fd68dee01" translate="yes" xml:space="preserve">
          <source>Class Implementations</source>
          <target state="translated">클래스 구현</target>
        </trans-unit>
        <trans-unit id="92adf227123fe3164559c8b57554084d078adbb1" translate="yes" xml:space="preserve">
          <source>Classes that operate on observables have been replaced by functions.</source>
          <target state="translated">옵저버 블에서 작동하는 클래스는 함수로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="f56986343e465f67e4ade9b4d5003bb79270d98a" translate="yes" xml:space="preserve">
          <source>Code licensed under an Apache-2.0 License. Documentation licensed under CC BY 4.0.</source>
          <target state="translated">Apache-2.0 라이센스에 따라 라이센스가 부여 된 코드. CC BY 4.0에 따라 라이센스가 부여 된 문서.</target>
        </trans-unit>
        <trans-unit id="264398069882e7753347718021d0c9c51b7ce8fc" translate="yes" xml:space="preserve">
          <source>Code of Conduct</source>
          <target state="translated">행동 강령</target>
        </trans-unit>
        <trans-unit id="bff53ee5bce91f6e48134eda698e59b8359d48bf" translate="yes" xml:space="preserve">
          <source>Collects all source emissions and emits them as an array when the source completes.</source>
          <target state="translated">모든 소스 배출물을 수집하고 소스가 완료되면이를 어레이로 방출합니다.</target>
        </trans-unit>
        <trans-unit id="a87c4457cd65817173f42a58e3b056f94792975c" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array, and emits that array only when another Observable emits.</source>
          <target state="translated">과거의 값을 배열로 수집하고 다른 Observable이 방출 할 때만 해당 배열을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="84e5c2c56ccc76a9cf62fb80908721c69ede86cf" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array, and emits that array only when its size reaches &lt;code&gt;bufferSize&lt;/code&gt;.</source>
          <target state="translated">과거에서 값을 배열로 수집하고, 크기가 &lt;code&gt;bufferSize&lt;/code&gt; 에 도달 할 때만 해당 배열을 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="dcb48d99f7461fdace8881995c945f640d453091" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array, and emits those arrays periodically in time.</source>
          <target state="translated">과거의 값을 배열로 수집하고 해당 배열을 주기적으로 방출합니다.</target>
        </trans-unit>
        <trans-unit id="a28d40eb03d856d357a7a6d8bf9631fe8ab94554" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array. Starts collecting only when &lt;code&gt;opening&lt;/code&gt; emits, and calls the &lt;code&gt;closingSelector&lt;/code&gt; function to get an Observable that tells when to close the buffer.</source>
          <target state="translated">과거의 값을 배열로 수집합니다. &lt;code&gt;opening&lt;/code&gt; 방출 될 때만 수집을 시작 하고 , 버퍼를 닫을시기를 알려주는 Observable을 얻기 위해 &lt;code&gt;closingSelector&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="4b8aa081fb705436429dff9d465de035e7e62f11" translate="yes" xml:space="preserve">
          <source>Collects values from the past as an array. When it starts collecting values, it calls a function that returns an Observable that tells when to close the buffer and restart collecting.</source>
          <target state="translated">과거의 값을 배열로 수집합니다. 값 수집을 시작하면 버퍼를 닫고 수집을 다시 시작할시기를 알려주는 Observable을 반환하는 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="16dc60a0adf13d9db9d55f345c909d25f48d7dd5" translate="yes" xml:space="preserve">
          <source>Combine age and name from different sources</source>
          <target state="translated">다른 출처의 연령과 이름을 결합</target>
        </trans-unit>
        <trans-unit id="ddcd6864d0909fbc11124756a02fcda077e9eee9" translate="yes" xml:space="preserve">
          <source>Combine an array of Observables</source>
          <target state="translated">다양한 Observable을 결합</target>
        </trans-unit>
        <trans-unit id="3290c60aa41ac81295b37ea06bcc86ce998efa56" translate="yes" xml:space="preserve">
          <source>Combine two timer Observables</source>
          <target state="translated">두 개의 타이머 옵저버 블 결합</target>
        </trans-unit>
        <trans-unit id="d89a0d96a043bd7133e0dc51016f7f120ae0eaae" translate="yes" xml:space="preserve">
          <source>Combines multiple Observables to create an Observable whose values are calculated from the latest values of each of its input Observables.</source>
          <target state="translated">여러 Observable을 결합하여 각 입력 Observable의 최신 값에서 값을 계산하는 Observable을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7db2a4e0664e1e1247e446b34d85228f39aa98c1" translate="yes" xml:space="preserve">
          <source>Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each of its input Observables.</source>
          <target state="translated">여러 Observable을 결합하여 각 입력 Observable의 값을 순서대로 계산하는 Observable을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a94b90034171278929060f4c02c4d77ccd4193cc" translate="yes" xml:space="preserve">
          <source>Combines the source Observable with other Observables to create an Observable whose values are calculated from the latest values of each, only when the source emits.</source>
          <target state="translated">소스 Observable을 다른 Observable과 결합하여 소스가 방출 될 때만 각각의 최신 값에서 값을 계산하는 Observable을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5b0baff3ec7a8c1314bf1adf98ac28a48a1e9524" translate="yes" xml:space="preserve">
          <source>Combines together all values emitted on the source, using an accumulator function that knows how to join a new source value into the accumulation from the past.</source>
          <target state="translated">새로운 소스 값을 과거의 누적으로 결합하는 방법을 알고있는 누산기 기능을 사용하여 소스에서 방출 된 모든 값을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="b2cd10bda67f3c2a0db363c783f1be790f5f461a" translate="yes" xml:space="preserve">
          <source>Combines together all values emitted on the source, using an accumulator function that knows how to join a new source value into the accumulation from the past. Is similar to &lt;a href=&quot;reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but emits the intermediate accumulations.</source>
          <target state="translated">새로운 소스 값을 과거의 누적으로 결합하는 방법을 알고있는 누산기 기능을 사용하여 소스에서 방출 된 모든 값을 결합합니다. &lt;a href=&quot;reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 중간 누적을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="d9a3849cfa8277187bcfd6ad0b01e4f8005b9aaf" translate="yes" xml:space="preserve">
          <source>CommonJS via npm</source>
          <target state="translated">npm을 통한 CommonJS</target>
        </trans-unit>
        <trans-unit id="d4d22effb8cb3b670cec35ed783a128ce947ac0a" translate="yes" xml:space="preserve">
          <source>Compare async and asap scheduler&amp;lt;</source>
          <target state="translated">비동기 및 최대한 빠른 스케줄러 비교 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="7435cdb2b01945189354f363a0421a39f3cd8faa" translate="yes" xml:space="preserve">
          <source>Compare behaviour with and without async Scheduler</source>
          <target state="translated">비동기 스케줄러 유무에 따른 동작 비교</target>
        </trans-unit>
        <trans-unit id="ea2fd62aaac1214e57e275acea20cefc00fdc055" translate="yes" xml:space="preserve">
          <source>Compares all values of two observables in sequence using an optional comparator function and returns an observable of a single boolean value representing whether or not the two sequences are equal.</source>
          <target state="translated">선택적 비교기 함수를 사용하여 두 관측 값의 모든 값을 순서대로 비교하고 두 시퀀스가 ​​같은지 여부를 나타내는 단일 부울 값의 관측 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3a4a4ba8ed0c16db5d39596cb0488aad4649a436" translate="yes" xml:space="preserve">
          <source>CompletionObserver</source>
          <target state="translated">CompletionObserver</target>
        </trans-unit>
        <trans-unit id="d982b449859a628c84de4d2d6a5c484a7c842af0" translate="yes" xml:space="preserve">
          <source>Concatenate 3 Observables</source>
          <target state="translated">3 개의 관측 값 연결</target>
        </trans-unit>
        <trans-unit id="63f84436a9e4551523680f6e33010bbd81eceb69" translate="yes" xml:space="preserve">
          <source>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</source>
          <target state="translated">1에서 10까지의 동기 시퀀스로 0에서 3까지의 타이머를 연결</target>
        </trans-unit>
        <trans-unit id="d2f209d251c0e1e81cd1edf9ef7e4dd74fc1df55" translate="yes" xml:space="preserve">
          <source>Concatenate the same Observable to repeat it</source>
          <target state="translated">동일한 Observable을 연결하여 반복</target>
        </trans-unit>
        <trans-unit id="6ca2d7e68988508caae3db5f7e018aedff9b9fc9" translate="yes" xml:space="preserve">
          <source>Concatenates multiple Observables together by sequentially emitting their values, one Observable after the other.</source>
          <target state="translated">여러 개의 Observable을 순차적으로 방출하여 여러 Observable을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="d0b35f2e80cf4078de3821051d01800d2a02ba30" translate="yes" xml:space="preserve">
          <source>Conclusion:</source>
          <target state="translated">Conclusion:</target>
        </trans-unit>
        <trans-unit id="0994f75274a8c52a8effb0dff41d86197463bb06" translate="yes" xml:space="preserve">
          <source>Condition to terminate generation (upon returning false).</source>
          <target state="translated">생성을 종료하기위한 조건 (false 반환시).</target>
        </trans-unit>
        <trans-unit id="89e222ef595e95335f78cd2e3d813306054bc919" translate="yes" xml:space="preserve">
          <source>Condition which Observable should be chosen.</source>
          <target state="translated">관찰 할 수있는 조건을 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="9b047f76f02c3292f835923209499db8eb35fdb8" translate="yes" xml:space="preserve">
          <source>Conditional and Boolean Operators</source>
          <target state="translated">조건부 및 부울 연산자</target>
        </trans-unit>
        <trans-unit id="98fc062426c459824189a5ec2607ca8eff08cd75" translate="yes" xml:space="preserve">
          <source>ConnectableObservable</source>
          <target state="translated">ConnectableObservable</target>
        </trans-unit>
        <trans-unit id="227f6773256bb7ed0a8c8aef07706b2d613095e7" translate="yes" xml:space="preserve">
          <source>ConnectableObservable._subscribe()</source>
          <target state="translated">ConnectableObservable._subscribe()</target>
        </trans-unit>
        <trans-unit id="e4e83313fbffa48c823bbad63fe418da25e13b75" translate="yes" xml:space="preserve">
          <source>ConnectableObservable.connect()</source>
          <target state="translated">ConnectableObservable.connect()</target>
        </trans-unit>
        <trans-unit id="5b738b218b7aa49bf8395157e1f139e5d7314c3d" translate="yes" xml:space="preserve">
          <source>ConnectableObservable.getSubject()</source>
          <target state="translated">ConnectableObservable.getSubject()</target>
        </trans-unit>
        <trans-unit id="682ebb04b9bff65e60368de186fac3051021f642" translate="yes" xml:space="preserve">
          <source>ConnectableObservable.refCount()</source>
          <target state="translated">ConnectableObservable.refCount()</target>
        </trans-unit>
        <trans-unit id="a3613a775b8dd1ea901d700f28e65babb54cab38" translate="yes" xml:space="preserve">
          <source>Consider the following example where subscriptions occur as outlined by this list:</source>
          <target state="translated">이 목록에 요약 된대로 구독이 발생하는 다음 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="fc53f41d4c528eb43347a836891919335055512d" translate="yes" xml:space="preserve">
          <source>Consider the following:</source>
          <target state="translated">다음을 고려하세요:</target>
        </trans-unit>
        <trans-unit id="edb7861f190be64ab7c7a39786a00727bb16847d" translate="yes" xml:space="preserve">
          <source>Constructor</source>
          <target state="translated">Constructor</target>
        </trans-unit>
        <trans-unit id="0c707f2781a489cf7e4ea7d11c190f8dfe3a0bf0" translate="yes" xml:space="preserve">
          <source>Consumer</source>
          <target state="translated">Consumer</target>
        </trans-unit>
        <trans-unit id="c98977bcb8208e29729ee8d1a4102b950f779678" translate="yes" xml:space="preserve">
          <source>Continues with a different Observable when there's an error</source>
          <target state="translated">오류가있을 때 다른 Observable로 계속</target>
        </trans-unit>
        <trans-unit id="7ada7cd7c5728485ea37e7e90c589b594cd34212" translate="yes" xml:space="preserve">
          <source>Contrary to popular claims, Observables are not like EventEmitters nor are they like Promises for multiple values. Observables &lt;em&gt;may act&lt;/em&gt; like EventEmitters in some cases, namely when they are multicasted using RxJS Subjects, but usually they don't act like EventEmitters.</source>
          <target state="translated">널리 알려진 주장과 달리 Observables는 EventEmitters와 같지 않으며 여러 값에 대한 약속을 좋아하지도 않습니다. Observable &lt;em&gt;은&lt;/em&gt; 경우에 따라 RxJS 주제를 사용하여 멀티 캐스트 할 때 EventEmitters처럼 작동하지만 일반적으로 EventEmitters처럼 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0a49d6e404607e10a989271aec1f79d6ac8a2119" translate="yes" xml:space="preserve">
          <source>Control an access to an Observable</source>
          <target state="translated">Observable에 대한 액세스 제어</target>
        </trans-unit>
        <trans-unit id="59cdbb05d9b9d2c325ba6cc70236d63b8806330c" translate="yes" xml:space="preserve">
          <source>Convert a faulty Observable to an Observable of Notifications</source>
          <target state="translated">결함이있는 Observable을 Observable of Notifications로 변환</target>
        </trans-unit>
        <trans-unit id="c7a397319f2ad4db3ea562e9725ebd2ef8e801dc" translate="yes" xml:space="preserve">
          <source>Convert an Observable of Notifications to an actual Observable</source>
          <target state="translated">Observable of Notifications를 실제 Observable로 변환</target>
        </trans-unit>
        <trans-unit id="a57ac9929f9075b8bad9951d6bf02471c724dcb8" translate="yes" xml:space="preserve">
          <source>Convert an Observable that emits items into one that emits indications of the amount of time elapsed between those emissions.</source>
          <target state="translated">아이템을 방출하는 Observable을 해당 방출 사이에 경과 된 시간의 양을 나타내는 것으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="a364d3d6bb030d153b00d33ba8b033883901284b" translate="yes" xml:space="preserve">
          <source>Convert an infinite iterable (from a generator) to an Observable</source>
          <target state="translated">무한 iterable을 (생성기에서) Observable로 변환</target>
        </trans-unit>
        <trans-unit id="ea2d5c2f9388b6f9038c0c700046b2170a04bde6" translate="yes" xml:space="preserve">
          <source>Convert an object into an Observable of &lt;code&gt;[key, value]&lt;/code&gt; pairs.</source>
          <target state="translated">객체를 Observable &lt;code&gt;[key, value]&lt;/code&gt; 쌍 으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="3288bcd2be86adb205c2a9df12810cd9003b7c8e" translate="yes" xml:space="preserve">
          <source>Convert jQuery's getJSON to an Observable API</source>
          <target state="translated">jQuery의 getJSON을 Observable API로 변환</target>
        </trans-unit>
        <trans-unit id="819a8ca76a22d542e92a562a9321de242bb32824" translate="yes" xml:space="preserve">
          <source>Converts a Node.js-style callback API to a function that returns an Observable.</source>
          <target state="translated">Node.js 스타일 콜백 API를 Observable을 반환하는 함수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="0ca228dc00e3b500ab7c0c59f7db8fa3cc379cf4" translate="yes" xml:space="preserve">
          <source>Converts a callback API to a function that returns an Observable.</source>
          <target state="translated">콜백 API를 Observable을 반환하는 함수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="d8bdbac484a550c5290dc0793186ded042951331" translate="yes" xml:space="preserve">
          <source>Converts a higher-order Observable into a first-order Observable by concatenating the inner Observables in order.</source>
          <target state="translated">내부 Observable을 순서대로 연결하여 상위 Observable을 1 차 Observable로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="512eb28280b7e03ca5f0d999e4ad906680f5cf55" translate="yes" xml:space="preserve">
          <source>Converts a higher-order Observable into a first-order Observable by dropping inner Observables while the previous inner Observable has not yet completed.</source>
          <target state="translated">내부 Observable을 삭제하여 상위 Observable을 1 차 Observable로 변환합니다. 이전 내부 Observable은 아직 완료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0fc3a87abee50d7640e787cc66c96745d64bcdfe" translate="yes" xml:space="preserve">
          <source>Converts a higher-order Observable into a first-order Observable producing values only from the most recent observable sequence</source>
          <target state="translated">최상위 Observable을 가장 최근의 관찰 가능한 시퀀스에서만 값을 생성하는 1 차 Observable로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="fc15afc5a3b5a5a5700f443e1064756e1aeb0ef1" translate="yes" xml:space="preserve">
          <source>Converts a higher-order Observable into a first-order Observable which concurrently delivers all values that are emitted on the inner Observables.</source>
          <target state="translated">상위 Observable을 1 차 Observable로 변환하여 내부 Observable에서 방출되는 모든 값을 동시에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="b51d3e7b3c8cccda64472b781a2fe516fd3c8d36" translate="yes" xml:space="preserve">
          <source>Converts almost anything to an Observable.</source>
          <target state="translated">거의 모든 것을 Observable로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="dcafce430dc29181daa478cf9c06fd80fd059a0f" translate="yes" xml:space="preserve">
          <source>Converts an Observable of &lt;a href=&quot;../index/class/notification&quot;&gt;&lt;code&gt;Notification&lt;/code&gt;&lt;/a&gt; objects into the emissions that they represent.</source>
          <target state="translated">Observable of &lt;a href=&quot;../index/class/notification&quot;&gt; &lt;code&gt;Notification&lt;/code&gt; &lt;/a&gt; 객체를 이들이 나타내는 방출로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="90543f0ae59be2561cf130cfe357a2eb0d2f310c" translate="yes" xml:space="preserve">
          <source>Converts an array to an Observable</source>
          <target state="translated">배열을 Observable로 변환</target>
        </trans-unit>
        <trans-unit id="38d9b9c231b0641f88f17b35e4cd114dbaa6824b" translate="yes" xml:space="preserve">
          <source>Converts from a common &lt;a href=&quot;../type-alias/observableinput&quot;&gt;&lt;code&gt;ObservableInput&lt;/code&gt;&lt;/a&gt; type to an observable where subscription and emissions are scheduled on the provided scheduler.</source>
          <target state="translated">제공된 스케줄러에서 구독 및 배출이 예약 된 공통 &lt;a href=&quot;../type-alias/observableinput&quot;&gt; &lt;code&gt;ObservableInput&lt;/code&gt; &lt;/a&gt; 유형에서 관찰 가능으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="c8516852b5b3e129bf4cf88d8db27cd4db8ae7ec" translate="yes" xml:space="preserve">
          <source>Converts the arguments to an observable sequence.</source>
          <target state="translated">인수를 관찰 가능한 순서로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="cd9fea92083a870676e543be5c6771c16d35faf8" translate="yes" xml:space="preserve">
          <source>Core Observable concerns:</source>
          <target state="translated">핵심 관찰 가능한 관심사 :</target>
        </trans-unit>
        <trans-unit id="fc6c40245600e6f83559183f877fd23ea3ec4525" translate="yes" xml:space="preserve">
          <source>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</source>
          <target state="translated">클릭당 1 초마다 0에서 9까지 계산하지만 동시에 2 개의 타이머 만 허용</target>
        </trans-unit>
        <trans-unit id="8e4e16903b9c68e1a70feb9c1b12a2e432e40e13" translate="yes" xml:space="preserve">
          <source>Count the number of click events</source>
          <target state="translated">클릭 이벤트 수 계산</target>
        </trans-unit>
        <trans-unit id="76fe820e51c08ab2fdcfa79429ab0f2b55d0239b" translate="yes" xml:space="preserve">
          <source>Count the number of click events that happened in 5 seconds</source>
          <target state="translated">5 초 동안 발생한 클릭 이벤트 수 계산</target>
        </trans-unit>
        <trans-unit id="38297b14fd834b687d5f9c6c0c377bc3a26611e7" translate="yes" xml:space="preserve">
          <source>Counts how many odd numbers are there between 1 and 7</source>
          <target state="translated">1과 7 사이의 홀수 수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="6527ed3c67425451554706dd6e296b6b07cfda36" translate="yes" xml:space="preserve">
          <source>Counts how many seconds have passed before the first click happened</source>
          <target state="translated">첫 번째 클릭이 발생하기까지 몇 초가 지 났는지 계산합니다.</target>
        </trans-unit>
        <trans-unit id="491a828d8c53ae7db8b33fbcf030f25402cd90e8" translate="yes" xml:space="preserve">
          <source>Counts the number of emissions on the source and emits that number when the source completes.</source>
          <target state="translated">소스의 배출 수를 세고 소스가 완료되면 해당 수를 방출합니다.</target>
        </trans-unit>
        <trans-unit id="b7d8894a964a606855f76a9e1a3c256a85a77af3" translate="yes" xml:space="preserve">
          <source>Creates a new Observable with this Subject as the source. You can do this to create customize Observer-side logic of the Subject and conceal it from code that uses the Observable.</source>
          <target state="translated">이 주제를 소스로하여 새로운 Observable을 작성합니다. 이를 수행하여 주제의 사용자 정의 관찰자 측 로직을 작성하고 관찰자를 사용하는 코드에서이를 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efd43c4f17bae72263830052e23af52fd14ac204" translate="yes" xml:space="preserve">
          <source>Creates a new Observable, with this Observable as the source, and the passed operator defined as the new observable's operator.</source>
          <target state="translated">이 Observable을 소스로 사용하고 전달 된 연산자를 새 Observable의 연산자로 정의하여 새 Observable을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6c433e239b323f6366118477eb69a8b50b369846" translate="yes" xml:space="preserve">
          <source>Creates a new cold Observable by calling the Observable constructor</source>
          <target state="translated">Observable 생성자를 호출하여 콜드 Observable을 새로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e42c4af5ccb591cb72c7f304fdf206bf4581acd1" translate="yes" xml:space="preserve">
          <source>Creates an &lt;a href=&quot;../index/class/observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;, that when subscribed to, sends a message, defined by the &lt;code&gt;subMsg&lt;/code&gt; function, to the server over the socket to begin a subscription to data over that socket. Once data arrives, the &lt;code&gt;messageFilter&lt;/code&gt; argument will be used to select the appropriate data for the resulting Observable. When teardown occurs, either due to unsubscription, completion or error, a message defined by the &lt;code&gt;unsubMsg&lt;/code&gt; argument will be send to the server over the WebSocketSubject.</source>
          <target state="translated">구독 할 때 &lt;code&gt;subMsg&lt;/code&gt; 함수로 정의 된 메시지를 소켓을 통해 서버로 보내 해당 소켓을 통해 데이터에 대한 구독을 시작 하는 &lt;a href=&quot;../index/class/observable&quot;&gt; &lt;code&gt;Observable&lt;/code&gt; &lt;/a&gt; 을 작성합니다. 데이터가 도착하면 &lt;code&gt;messageFilter&lt;/code&gt; 인수를 사용하여 결과 Observable에 적합한 데이터를 선택합니다. 구독 취소, 완료 또는 오류로 인해 해제가 발생하면 &lt;code&gt;unsubMsg&lt;/code&gt; 인수로 정의 된 메시지 가 WebSocketSubject를 통해 서버로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="6ba57e20fce78b5dfa9aefcbbbb2225cbb2cd085" translate="yes" xml:space="preserve">
          <source>Creates an Observable from DOM events, or Node.js EventEmitter events or others.</source>
          <target state="translated">DOM 이벤트 또는 Node.js EventEmitter 이벤트 또는 기타에서 Observable을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="30076be76739faf49c8bf250c9ce3b8582621a15" translate="yes" xml:space="preserve">
          <source>Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.</source>
          <target state="translated">배열, 배열 형 객체, Promise, 반복 가능 객체 또는 Observable 형 객체에서 Observable을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a4b1d654222d9d963587195913c2db77cd1b2ff3" translate="yes" xml:space="preserve">
          <source>Creates an Observable from an arbitrary API for registering event handlers.</source>
          <target state="translated">이벤트 핸들러를 등록하기 위해 임의의 API에서 Observable을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="8733e65df876cdecf09a85905357f82185d6f2a9" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits a sequence of numbers within a specified range.</source>
          <target state="translated">지정된 범위 내에서 일련의 숫자를 방출하는 Observable을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8ee788397d60121f2a0cdbe5153d1f8ed70114d7" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits events of a specific type coming from the given event target.</source>
          <target state="translated">지정된 이벤트 대상에서 특정 유형의 이벤트를 내보내는 Observable을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b19f653638b964e69cc5d6d83f264b627db6396d" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits no items to the Observer and immediately emits a complete notification.</source>
          <target state="translated">관찰자에게 항목을 내 보내지 않고 즉시 완전한 알림을 보내는 Observable을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="9ecbdd7d8ebb055a77e819dc27b5b8e144ac8f76" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits no items to the Observer and immediately emits an error notification.</source>
          <target state="translated">관찰자에게 항목을 내 보내지 않고 즉시 오류 알림을 내보내는 Observable을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c834efdbaabe5e44921e2ec46f3ff1e6caa151a5" translate="yes" xml:space="preserve">
          <source>Creates an Observable that emits sequential numbers every specified interval of time, on a specified &lt;a href=&quot;../interface/schedulerlike&quot;&gt;&lt;code&gt;SchedulerLike&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;../interface/schedulerlike&quot;&gt; &lt;code&gt;SchedulerLike&lt;/code&gt; &lt;/a&gt; 에서 지정된 시간 간격마다 순차 번호를 방출하는 Observable을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="c660a5a39524e13cbab144cbe8ab5e14563e2a40" translate="yes" xml:space="preserve">
          <source>Creates an Observable that starts emitting after an &lt;code&gt;dueTime&lt;/code&gt; and emits ever increasing numbers after each &lt;code&gt;period&lt;/code&gt; of time thereafter.</source>
          <target state="translated">&lt;code&gt;dueTime&lt;/code&gt; 이후에 방출을 시작 하고 그 이후 각 &lt;code&gt;period&lt;/code&gt; 후에 증가하는 수를 방출 하는 Observable을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="ae9fed84cdc523c537f6047938e7614dfd90ce38" translate="yes" xml:space="preserve">
          <source>Creates an Observable that uses a resource which will be disposed at the same time as the Observable.</source>
          <target state="translated">Observable과 동시에 폐기 될 리소스를 사용하는 Observable을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="88400625480f529b5c6a9d3898751cae3e084fbf" translate="yes" xml:space="preserve">
          <source>Creates an Observable that, on subscribe, calls an Observable factory to make an Observable for each new Observer.</source>
          <target state="translated">구독시 Observable 팩토리를 호출하여 각각의 새 Observer에 대해 Observable을 작성하는 Observable을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="0763a1a84734bc982d4480f3a3459456e835d5cd" translate="yes" xml:space="preserve">
          <source>Creates an output Observable which concurrently emits all values from every given input Observable.</source>
          <target state="translated">주어진 모든 입력 Observable에서 모든 값을 동시에 방출하는 출력 Observable을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="33b018d042209578a46cb7d33213ab03f281363d" translate="yes" xml:space="preserve">
          <source>Creates an output Observable which sequentially emits all values from given Observable and then moves on to the next.</source>
          <target state="translated">주어진 Observable에서 모든 값을 순차적으로 방출하고 다음으로 이동하는 출력 Observable을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="70011ddbfcf5671aa0c05bf7fceff4d551c240d5" translate="yes" xml:space="preserve">
          <source>Creates the Observable lazily, that is, only when it is subscribed.</source>
          <target state="translated">Observable을 느리게, 즉 구독 할 때만 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6ad6131d04bc2f8da39dba3829954ab817589a3f" translate="yes" xml:space="preserve">
          <source>Creating Observables</source>
          <target state="translated">Observable 생성</target>
        </trans-unit>
        <trans-unit id="3b55e62a31cf0de003b499939010016bd026ad3c" translate="yes" xml:space="preserve">
          <source>Creating custom observables</source>
          <target state="translated">커스텀 옵저버 블 생성</target>
        </trans-unit>
        <trans-unit id="eb98788b461efb61b82601e6daec4642ab62fad1" translate="yes" xml:space="preserve">
          <source>Creating new operators from scratch</source>
          <target state="translated">처음부터 새 연산자 만들기</target>
        </trans-unit>
        <trans-unit id="94397887885ac635c016bdd99861cf6ef324405b" translate="yes" xml:space="preserve">
          <source>Creation Operators</source>
          <target state="translated">창조 연산자</target>
        </trans-unit>
        <trans-unit id="e10b82309ae23cd7af56714b5258dc6a40b2138f" translate="yes" xml:space="preserve">
          <source>Decides at subscription time which Observable will actually be subscribed.</source>
          <target state="translated">Observable이 실제로 구독 될 구독 시간을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="4cf333763d14e699755bedabc5590efe13366f13" translate="yes" xml:space="preserve">
          <source>Declared in constructor.</source>
          <target state="translated">생성자에서 선언되었습니다.</target>
        </trans-unit>
        <trans-unit id="23bcb0d403ca12abcc86f64467b703be68b8f8c7" translate="yes" xml:space="preserve">
          <source>DeferObservable</source>
          <target state="translated">DeferObservable</target>
        </trans-unit>
        <trans-unit id="621045d69c5be1f634a4e5bcc53ff0a6021d3950" translate="yes" xml:space="preserve">
          <source>Delay all clicks until a future date happens</source>
          <target state="translated">향후 날짜가 발생할 때까지 모든 클릭 지연</target>
        </trans-unit>
        <trans-unit id="fe5c6e39f63a2abb17033a49863d02e213157524" translate="yes" xml:space="preserve">
          <source>Delay each click by a random amount of time, between 0 and 5 seconds</source>
          <target state="translated">0 ~ 5 초 사이의 임의의 시간만큼 클릭 할 때마다 지연</target>
        </trans-unit>
        <trans-unit id="8915b9cde2c4ef9b51fbce85255c288a61f24642" translate="yes" xml:space="preserve">
          <source>Delay each click by one second</source>
          <target state="translated">각 클릭을 1 초 지연</target>
        </trans-unit>
        <trans-unit id="68662352061ba86d162c267de395269277632ba7" translate="yes" xml:space="preserve">
          <source>Delays the emission of items from the source Observable by a given time span determined by the emissions of another Observable.</source>
          <target state="translated">다른 Observable의 배출에 의해 결정된 주어진 시간 간격으로 소스 Observable로부터의 배출을 지연시킵니다.</target>
        </trans-unit>
        <trans-unit id="1ef659436a6c36a417cd112a0a121582339f99c4" translate="yes" xml:space="preserve">
          <source>Delays the emission of items from the source Observable by a given timeout or until a given Date.</source>
          <target state="translated">지정된 시간 종료 또는 지정된 날짜까지 소스 Observable에서 항목의 방출을 지연시킵니다.</target>
        </trans-unit>
        <trans-unit id="7e315272fd1a4207c99a387e25509471282803ef" translate="yes" xml:space="preserve">
          <source>Delivers to the given &lt;code&gt;observer&lt;/code&gt; the value wrapped by this Notification.</source>
          <target state="translated">이 통지에 의해 랩 된 값을 지정된 &lt;code&gt;observer&lt;/code&gt; 에게 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="1605f6c45747aafbe495b3876f2cf20e7b6fdd24" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/combinelatest&quot;&gt;&lt;code&gt;combineLatest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정적 &lt;a href=&quot;../index/function/combinelatest&quot;&gt; &lt;code&gt;combineLatest&lt;/code&gt; &lt;/a&gt; 를 위해 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6b14b595931fc098a11ef3100bdb2821b6ac22c6" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/concat&quot;&gt;&lt;code&gt;concat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정적 &lt;a href=&quot;../index/function/concat&quot;&gt; &lt;code&gt;concat&lt;/code&gt; &lt;/a&gt; 을 위해 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bb891d216533ca453393f5560f216a593180a0c4" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/merge&quot;&gt;&lt;code&gt;merge&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정적 &lt;a href=&quot;../index/function/merge&quot;&gt; &lt;code&gt;merge&lt;/code&gt; &lt;/a&gt; 을 위해 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4923b07923f47345827f9dbc43bdd9226f071ef1" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/race&quot;&gt;&lt;code&gt;race&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정적 &lt;a href=&quot;../index/function/race&quot;&gt; &lt;code&gt;race&lt;/code&gt; &lt;/a&gt; 를 위해 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="65017388b7b5b653ed1176ea2721b4807d0aab75" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of static &lt;a href=&quot;../index/function/zip&quot;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정적 &lt;a href=&quot;../index/function/zip&quot;&gt; &lt;code&gt;zip&lt;/code&gt; &lt;/a&gt; 을 위해 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bd528af798c288f24a1995a90fcf7251b1fb384c" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of using &lt;a href=&quot;../const/never&quot;&gt;&lt;code&gt;NEVER&lt;/code&gt;&lt;/a&gt; constant.</source>
          <target state="translated">&lt;a href=&quot;../const/never&quot;&gt; &lt;code&gt;NEVER&lt;/code&gt; &lt;/a&gt; 상수 를 사용하기 위해 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="22ecf0e4bb675b2432fe6ba41fe1a4c5f10d31ec" translate="yes" xml:space="preserve">
          <source>Deprecated in favor of using &lt;a href=&quot;empty&quot;&gt;EMPTY&lt;/a&gt; constant, or &lt;a href=&quot;scheduled&quot;&gt;&lt;code&gt;scheduled&lt;/code&gt;&lt;/a&gt; (e.g. &lt;code&gt;scheduled([], scheduler)&lt;/code&gt;)</source>
          <target state="translated">&lt;a href=&quot;empty&quot;&gt;EMPTY&lt;/a&gt; 상수 를 사용 하거나 &lt;a href=&quot;scheduled&quot;&gt; &lt;code&gt;scheduled&lt;/code&gt; &lt;/a&gt; (예 : &lt;code&gt;scheduled([], scheduler)&lt;/code&gt; ) 을 위해 사용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="463582ed19dfc58a87321a7b92cfba5549a9c5d0" translate="yes" xml:space="preserve">
          <source>Deprecation Notes</source>
          <target state="translated">지원 중단 노트</target>
        </trans-unit>
        <trans-unit id="34730e9bbd5c0ba7b7655973316eed44e39da85f" translate="yes" xml:space="preserve">
          <source>Deprecations</source>
          <target state="translated">Deprecations</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="2666820b5bb0173df8ddd17b764bde4b0f8b1b61" translate="yes" xml:space="preserve">
          <source>Disposes the resources held by the subscription. May, for instance, cancel an ongoing Observable execution or cancel any other type of work that started when the Subscription was created.</source>
          <target state="translated">구독이 보유한 리소스를 삭제합니다. 예를 들어, 진행중인 Observable 실행을 취소하거나 서브 스크립 션 작성시 시작된 다른 유형의 작업을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="316644b959082a2cc487f06bf5876e8dcf368159" translate="yes" xml:space="preserve">
          <source>Disposing Observable Executions</source>
          <target state="translated">관찰 가능한 처형 처분</target>
        </trans-unit>
        <trans-unit id="af481d033e3d6a89a0a00f12185b62203c7b5177" translate="yes" xml:space="preserve">
          <source>Double Click</source>
          <target state="translated">더블 클릭</target>
        </trans-unit>
        <trans-unit id="f04e90acad2440fd4a1e87ff19b6433cbce9b7c3" translate="yes" xml:space="preserve">
          <source>Dropping the compatibility layer</source>
          <target state="translated">호환성 레이어 삭제</target>
        </trans-unit>
        <trans-unit id="52f444678c751856f9a1ce086837968f7c75e741" translate="yes" xml:space="preserve">
          <source>Due to having operators available independent of an Observable, operator names cannot conflict with JavaScript keyword restrictions. Therefore the names of the pipeable version of some operators have changed. These operators are:</source>
          <target state="translated">Observable과 독립적으로 사용할 수있는 연산자가 있기 때문에 연산자 이름은 JavaScript 키워드 제한과 충돌 할 수 없습니다. 따라서 일부 연산자의 파이프 가능 버전 이름이 변경되었습니다. 이 연산자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5bc604777adb22ae457a5473c397202e00689e23" translate="yes" xml:space="preserve">
          <source>EMPTY</source>
          <target state="translated">EMPTY</target>
        </trans-unit>
        <trans-unit id="0b99cebe565822c64ac5d84aecb00fe40e59cbd3" translate="yes" xml:space="preserve">
          <source>ERROR</source>
          <target state="translated">ERROR</target>
        </trans-unit>
        <trans-unit id="42e1bdd92a7f77d27b8d2717d5eeb1d59be288ff" translate="yes" xml:space="preserve">
          <source>ES2015 introduced &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;generator functions and iterators&lt;/a&gt; (&lt;code&gt;function*&lt;/code&gt;), another type of Pull system. Code that calls &lt;code&gt;iterator.next()&lt;/code&gt; is the Consumer, &quot;pulling&quot; out &lt;em&gt;multiple&lt;/em&gt; values from the iterator (the Producer).</source>
          <target state="translated">ES2015는 또 다른 유형의 풀 시스템 인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;생성기 함수 및 반복자&lt;/a&gt; ( &lt;code&gt;function*&lt;/code&gt; )를 도입했습니다. &lt;code&gt;iterator.next()&lt;/code&gt; 를 호출하는 코드 는 반복자 (프로듀서)에서 &lt;em&gt;여러&lt;/em&gt; 값을 &quot;풀링&quot;하는 소비자 입니다.</target>
        </trans-unit>
        <trans-unit id="674227a972a4b55f0756d9b2d66199ac3bfe89e5" translate="yes" xml:space="preserve">
          <source>ES6 via npm</source>
          <target state="translated">npm을 통한 ES6</target>
        </trans-unit>
        <trans-unit id="666ff450a66a4678df3ec36c42739caaec2c8c52" translate="yes" xml:space="preserve">
          <source>Each Observable must define how to dispose resources of that execution when we create the Observable using &lt;code&gt;create()&lt;/code&gt;. You can do that by returning a custom &lt;code&gt;unsubscribe&lt;/code&gt; function from within &lt;code&gt;function subscribe()&lt;/code&gt;.</source>
          <target state="translated">각 Observable은 &lt;code&gt;create()&lt;/code&gt; 사용하여 Observable을 만들 때 해당 실행 리소스를 처리하는 방법을 정의해야합니다 . &lt;code&gt;function subscribe()&lt;/code&gt; 내에서 사용자 지정 &lt;code&gt;unsubscribe&lt;/code&gt; 함수를 반환하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="f678d49cb58e833db6233feb20eeeaa4428483bb" translate="yes" xml:space="preserve">
          <source>Each argument becomes a &lt;code&gt;next&lt;/code&gt; notification.</source>
          <target state="translated">각 인수는 &lt;code&gt;next&lt;/code&gt; 알림이됩니다.</target>
        </trans-unit>
        <trans-unit id="058613ebc4c427459ecefefd3afa54ff8652eb4e" translate="yes" xml:space="preserve">
          <source>Each space  equals 1 frame, same as a hyphen &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">각 공간은 하이픈 &lt;code&gt;-&lt;/code&gt; 과 동일하게 1 프레임과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="adf1a47a9d340f3325f9f83ae4bbd1be31b28aa3" translate="yes" xml:space="preserve">
          <source>Each unit of work in a Scheduler is called an &lt;code&gt;Action&lt;/code&gt;.</source>
          <target state="translated">스케줄러의 각 작업 단위를 &lt;code&gt;Action&lt;/code&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="a38b3bf75f93d9975be6df57e4eea447fc05cb7b" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;false&lt;/code&gt; for a non-empty Observable</source>
          <target state="translated">비어 있지 않은 Observable에 대해서는 &lt;code&gt;false&lt;/code&gt; 를 방출</target>
        </trans-unit>
        <trans-unit id="36595adf79029effea5aafbe0b33e1661d847cfa" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;true&lt;/code&gt; for an empty Observable</source>
          <target state="translated">빈 Observable에 대해 &lt;code&gt;true&lt;/code&gt; 를 방출</target>
        </trans-unit>
        <trans-unit id="9e45731f0c536caf528a3c80e03eb08e5adb47de" translate="yes" xml:space="preserve">
          <source>Emit an array of the last clicks every [1-5] random seconds</source>
          <target state="translated">[1-5] 임의의 초마다 마지막 클릭의 배열을 방출</target>
        </trans-unit>
        <trans-unit id="cae1dc3d5bbad2305fd286cad6d208c19363eab7" translate="yes" xml:space="preserve">
          <source>Emit click events only while the clientX property is greater than 200</source>
          <target state="translated">clientX 속성이 200보다 큰 경우에만 클릭 이벤트를 방출합니다</target>
        </trans-unit>
        <trans-unit id="dda0faf5498ca6dcf8ab28c43818f4feec0a0a42" translate="yes" xml:space="preserve">
          <source>Emit clicks at a rate of at most one click per second</source>
          <target state="translated">초당 최대 한 번의 클릭으로 클릭 수 발생</target>
        </trans-unit>
        <trans-unit id="3c76a13f5ebea7e20bbf00f2c9d32b7c447120aa" translate="yes" xml:space="preserve">
          <source>Emit inteval between current value with the last value</source>
          <target state="translated">현재 값과 마지막 값 사이의 정수를 방출</target>
        </trans-unit>
        <trans-unit id="84e59125f4895d959fba5383e8c9b85b6d26b42c" translate="yes" xml:space="preserve">
          <source>Emit only click events whose target was a DIV element</source>
          <target state="translated">대상이 DIV 요소 인 클릭 이벤트 만 방출</target>
        </trans-unit>
        <trans-unit id="aca713a5446a034f7eb7ee7cfd82582714e0d9f0" translate="yes" xml:space="preserve">
          <source>Emit only the first click that happens on the DOM</source>
          <target state="translated">DOM에서 발생한 첫 번째 클릭 만 방출</target>
        </trans-unit>
        <trans-unit id="6b2725c4f577b99a3c281b978bc1da2e3d162a2d" translate="yes" xml:space="preserve">
          <source>Emit only the first two clicks events in every window of [1-5] random seconds</source>
          <target state="translated">[1-5] 임의의 초의 모든 창에서 처음 두 번의 클릭 이벤트 만 방출</target>
        </trans-unit>
        <trans-unit id="d4bf60f5d394bc9dce56c9746cc1455601173e04" translate="yes" xml:space="preserve">
          <source>Emit only the third click event</source>
          <target state="translated">세 번째 클릭 이벤트 만 방출</target>
        </trans-unit>
        <trans-unit id="be82a967776bd06b73a9ef958b479a7e772ebb46" translate="yes" xml:space="preserve">
          <source>Emit the array &lt;code&gt;[1,2,3]&lt;/code&gt;</source>
          <target state="translated">배열 방출 &lt;code&gt;[1,2,3]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="258507901d76adefcf885e2d2ba14720064b4f43" translate="yes" xml:space="preserve">
          <source>Emit the index of first click that happens on a DIV element</source>
          <target state="translated">DIV 요소에서 발생하는 첫 번째 클릭의 인덱스를 방출</target>
        </trans-unit>
        <trans-unit id="e999d3a97f2c47d682185359cbc062466b4ecaee" translate="yes" xml:space="preserve">
          <source>Emit the last two click events as an array</source>
          <target state="translated">마지막 두 번의 클릭 이벤트를 배열로 방출</target>
        </trans-unit>
        <trans-unit id="b06ea69b0090aa2950941eebc373f9ab08c43134" translate="yes" xml:space="preserve">
          <source>Emit the most recent click after a burst of clicks</source>
          <target state="translated">클릭 수가 급증한 후 가장 최근의 클릭을 방출</target>
        </trans-unit>
        <trans-unit id="2ea4407361558147d8a964707b8d5610dfeeb1ab" translate="yes" xml:space="preserve">
          <source>Emit the number 7, then complete</source>
          <target state="translated">숫자 7을 방출 한 다음 완료</target>
        </trans-unit>
        <trans-unit id="08b53dacead1c62d68921ed8a27c7e6dd38496b0" translate="yes" xml:space="preserve">
          <source>Emit the number 7, then emit an error</source>
          <target state="translated">숫자 7을 방출 한 다음 오류가 발생합니다</target>
        </trans-unit>
        <trans-unit id="b6f544e32d0273819a571f258748d660fa3de0b5" translate="yes" xml:space="preserve">
          <source>Emit the number 7, then never emit anything else (not even complete)</source>
          <target state="translated">숫자 7을 방출 한 다음 다른 것을 방출하지 마십시오 (완전하지 않음)</target>
        </trans-unit>
        <trans-unit id="035524c755f99f7f39661d88482f9c247d60ae51" translate="yes" xml:space="preserve">
          <source>Emit the values &lt;code&gt;10, 20, 30&lt;/code&gt;</source>
          <target state="translated">값 &lt;code&gt;10, 20, 30&lt;/code&gt; 방출하십시오</target>
        </trans-unit>
        <trans-unit id="71a66df699b18ab8842ed8372fe230b4344398b0" translate="yes" xml:space="preserve">
          <source>Emits a given value if the source Observable completes without emitting any &lt;code&gt;next&lt;/code&gt; value, otherwise mirrors the source Observable.</source>
          <target state="translated">소스 Observable이 &lt;code&gt;next&lt;/code&gt; 값 을 방출하지 않고 완료되면 지정된 값을 생성하고 , 그렇지 않으면 소스 Observable을 미러링합니다.</target>
        </trans-unit>
        <trans-unit id="f5936dfcfd0d7b376e741c1351e9508df5c31a94" translate="yes" xml:space="preserve">
          <source>Emits a sequence of numbers in a range.</source>
          <target state="translated">범위 내에서 일련의 숫자를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="3459aa8bde5600535a38bc29ec55520c8ffe5b3b" translate="yes" xml:space="preserve">
          <source>Emits a value from the source Observable only after a particular time span determined by another Observable has passed without another source emission.</source>
          <target state="translated">다른 Observable에 의해 결정된 특정 시간 범위가 다른 소스 방출없이 경과 한 후에 만 ​​소스 Observable에서 값을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="796b34385a59e79b833e9d74db73634c2b0ff888" translate="yes" xml:space="preserve">
          <source>Emits a value from the source Observable only after a particular time span has passed without another source emission.</source>
          <target state="translated">특정 시간 범위가 다른 소스 방출없이 경과 한 후에 만 ​​소스 Observable에서 값을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="1145fc21b2f2c2783c18b2286b6ba6d20b685d48" translate="yes" xml:space="preserve">
          <source>Emits a value from the source Observable, then ignores subsequent source values for &lt;code&gt;duration&lt;/code&gt; milliseconds, then repeats this process.</source>
          <target state="translated">소스 Observable에서 값을 가져온 후 &lt;code&gt;duration&lt;/code&gt; 밀리 초) 동안 후속 소스 값을 무시한 후이 프로세스를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="3ea9d1e82cdd52be474e2587516de6ae66e19bc8" translate="yes" xml:space="preserve">
          <source>Emits a value from the source Observable, then ignores subsequent source values for a duration determined by another Observable, then repeats this process.</source>
          <target state="translated">소스 Observable에서 값을 가져온 다음 다른 Observable에서 결정한 지속 기간 동안 후속 소스 값을 무시한 다음이 프로세스를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="9362d35a79ede3aa7be38e1b31753d1ce5e19bfa" translate="yes" xml:space="preserve">
          <source>Emits an object containing the current value, and the time that has passed between emitting the current value and the previous value, which is calculated by using the provided &lt;code&gt;scheduler&lt;/code&gt;'s &lt;code&gt;now()&lt;/code&gt; method to retrieve the current time at each emission, then calculating the difference. The &lt;code&gt;scheduler&lt;/code&gt; defaults to &lt;a href=&quot;../index/const/asyncscheduler&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt;, so by default, the &lt;code&gt;interval&lt;/code&gt; will be in milliseconds.</source>
          <target state="translated">현재 값과 현재 값과 이전 값을 방출하는 사이의 시간을 포함하는 객체를 생성합니다.이 값은 제공된 &lt;code&gt;scheduler&lt;/code&gt; 의 &lt;code&gt;now()&lt;/code&gt; 메소드를 사용하여 각 방출에서 현재 시간을 검색 한 다음 계산합니다. 차. &lt;code&gt;scheduler&lt;/code&gt; 기본값 &lt;a href=&quot;../index/const/asyncscheduler&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt; , 그래서 기본적으로 &lt;code&gt;interval&lt;/code&gt; 밀리 초에있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="a0bc548abaef51ec19270a209d925069b3deaf16" translate="yes" xml:space="preserve">
          <source>Emits ascending numbers, one every second (1000ms) up to the number 3</source>
          <target state="translated">3까지 최대 1 초마다 (1000ms) 오름차순 숫자를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="416f5c82d0c0c1e9c7bc782fe6a56560370e5e6d" translate="yes" xml:space="preserve">
          <source>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</source>
          <target state="translated">3 초 후에 시작하여 1 초마다 (1000ms) 오름차순 숫자를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="987c87f4a4f4e45515380da71ea51604f2c31a4c" translate="yes" xml:space="preserve">
          <source>Emits clicks happening on the DOM document</source>
          <target state="translated">DOM 문서에서 발생하는 클릭 발생</target>
        </trans-unit>
        <trans-unit id="fb68143f9c22c639fe4241870686be6e3443cf56" translate="yes" xml:space="preserve">
          <source>Emits false if the input observable emits any values, or emits true if the input observable completes without emitting any values.</source>
          <target state="translated">입력 관측 가능 값이 값을 방출하면 false를 생성하거나, 입력 관측 가능 값을 방출하지 않고 완료하면 true를 방출합니다.</target>
        </trans-unit>
        <trans-unit id="40866b2ae203c7bcd97be2c7b2bd3a74f920770b" translate="yes" xml:space="preserve">
          <source>Emits incremental numbers periodically in time.</source>
          <target state="translated">주기적으로 증분 숫자를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="dfc6629a60560428832a42a80e579e178deeedea" translate="yes" xml:space="preserve">
          <source>Emits one number after five seconds</source>
          <target state="translated">5 초 후에 하나의 숫자를 방출합니다</target>
        </trans-unit>
        <trans-unit id="c8db73b5e36157de7f7351e274e9b9ff88a812aa" translate="yes" xml:space="preserve">
          <source>Emits only the first &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable.</source>
          <target state="translated">소스 Observable이 내 보낸 첫 번째 &lt;code&gt;count&lt;/code&gt; 값만 방출합니다.</target>
        </trans-unit>
        <trans-unit id="8578296e355b5b8276c06eca98343ce699c77a41" translate="yes" xml:space="preserve">
          <source>Emits only the first value (or the first value that meets some condition) emitted by the source Observable.</source>
          <target state="translated">소스 Observable이 방출 한 첫 번째 값 (또는 특정 조건을 충족하는 첫 번째 값) 만 방출합니다.</target>
        </trans-unit>
        <trans-unit id="ee4e2bb5f62bd3a3b6a3b8f9742dadbb7c8fd314" translate="yes" xml:space="preserve">
          <source>Emits only the first value emitted by the source Observable that meets some condition.</source>
          <target state="translated">소스 Observable이 방출 한 첫 번째 값만 일부 조건을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="d453139a17724a88567155f88992de9a43704fed" translate="yes" xml:space="preserve">
          <source>Emits only the first value. Or emits only the first value that passes some test.</source>
          <target state="translated">첫 번째 값만 내 보냅니다. 또는 일부 테스트를 통과 한 첫 번째 값만 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="47bb0a635fba06f7e64359ed31cd996b61370dd0" translate="yes" xml:space="preserve">
          <source>Emits only the i-th value, then completes.</source>
          <target state="translated">i 번째 값만 방출 한 후 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="ce3a6a1ffd4b5b5bdb5c7fe2a320ecee099869c6" translate="yes" xml:space="preserve">
          <source>Emits only the index of the first value emitted by the source Observable that meets some condition.</source>
          <target state="translated">소스 Observable이 방출 한 첫 번째 값의 인덱스 만 일부 조건을 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="c942645033239d24b677fcb60f721a558bf5f73f" translate="yes" xml:space="preserve">
          <source>Emits only the last &lt;code&gt;count&lt;/code&gt; values emitted by the source Observable.</source>
          <target state="translated">소스 Observable이 방출 한 마지막 &lt;code&gt;count&lt;/code&gt; 값만 방출합니다.</target>
        </trans-unit>
        <trans-unit id="633638a649508aa1d7574551df6b44843d5c0978" translate="yes" xml:space="preserve">
          <source>Emits the first click that happens on a DIV</source>
          <target state="translated">DIV에서 발생하는 첫 번째 클릭 발생</target>
        </trans-unit>
        <trans-unit id="33baacac631afed4cb4748baf32b4a71bcb00d28" translate="yes" xml:space="preserve">
          <source>Emits the given constant value on the output Observable every time the source Observable emits a value.</source>
          <target state="translated">소스 Observable이 값을 생성 할 때마다 출력 Observable에서 지정된 상수 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="471a2baa629dc6681c52e99caccf2f18b0e2938c" translate="yes" xml:space="preserve">
          <source>Emits the most recently emitted value from the source Observable whenever another Observable, the &lt;code&gt;notifier&lt;/code&gt;, emits.</source>
          <target state="translated">다른 Observable 인 &lt;code&gt;notifier&lt;/code&gt; 가 발생할 때마다 소스 Observable에서 가장 최근에 방출 된 값을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="2254e36517076818c8f4383fb5e0ecdaf0d2521b" translate="yes" xml:space="preserve">
          <source>Emits the most recently emitted value from the source Observable within periodic time intervals.</source>
          <target state="translated">주기적으로 소스 Observable에서 가장 최근에 방출 된 값을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="c275f10e004389aaf9cbd780140b6f96348805dc" translate="yes" xml:space="preserve">
          <source>Emits the numbers 1 to 10</source>
          <target state="translated">1에서 10까지의 숫자를 방출합니다</target>
        </trans-unit>
        <trans-unit id="33e3a9ae3cb8e784f5aecfedde6103fba869fe5b" translate="yes" xml:space="preserve">
          <source>Emits the single value at the specified &lt;code&gt;index&lt;/code&gt; in a sequence of emissions from the source Observable.</source>
          <target state="translated">소스 Observable의 배출 시퀀스에서 지정된 &lt;code&gt;index&lt;/code&gt; 의 단일 값을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="1a493989aa04d9a64a56db66249f73aafd987eda" translate="yes" xml:space="preserve">
          <source>Emits the values emitted by the source Observable until a &lt;code&gt;notifier&lt;/code&gt; Observable emits a value.</source>
          <target state="translated">까지 관찰 가능한 소스에 의해 방출 된 값 방출 &lt;code&gt;notifier&lt;/code&gt; 관찰 가능한 발광하는 값.</target>
        </trans-unit>
        <trans-unit id="3c7bee64498c2a7e9a5a73840f298dd4a0a008ee" translate="yes" xml:space="preserve">
          <source>Emits values emitted by the source Observable so long as each value satisfies the given &lt;code&gt;predicate&lt;/code&gt;, and then completes as soon as this &lt;code&gt;predicate&lt;/code&gt; is not satisfied.</source>
          <target state="translated">각 값이 주어진 &lt;code&gt;predicate&lt;/code&gt; 만족하는 한 소스 Observable이 방출 한 값을 방출 한 다음이 &lt;code&gt;predicate&lt;/code&gt; 가 만족되지 않는 한 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a93d62619ac813564e9da8a4eebdc9e63296f52" translate="yes" xml:space="preserve">
          <source>EmptyError</source>
          <target state="translated">EmptyError</target>
        </trans-unit>
        <trans-unit id="c6a5baec1a656a6918482ae0a38e309a4e174ed7" translate="yes" xml:space="preserve">
          <source>EmptyObservable</source>
          <target state="translated">EmptyObservable</target>
        </trans-unit>
        <trans-unit id="c919a5ad2e7fdd8f109a1caa5d1715b51ed11664" translate="yes" xml:space="preserve">
          <source>Ensure a specific scheduler is used, from outside of an Observable.</source>
          <target state="translated">Observable 외부에서 특정 스케줄러가 사용되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="83c2c62e8479762708c16c7da93e27d58c64626d" translate="yes" xml:space="preserve">
          <source>Ensure values in subscribe are called just before browser repaint.</source>
          <target state="translated">구독의 값이 브라우저 다시 그리기 직전에 호출되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c2e8a31728f0c93cb4c1c3ea370cd7225cf97657" translate="yes" xml:space="preserve">
          <source>Ergonomic defaults for &lt;code&gt;hot&lt;/code&gt; and &lt;code&gt;cold&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;hot&lt;/code&gt; 및 &lt;code&gt;cold&lt;/code&gt; 인체 공학적 기본값</target>
        </trans-unit>
        <trans-unit id="b8a2a7f6e5c6d27ddebfed1897c207d4db559890" translate="yes" xml:space="preserve">
          <source>Error Handling Operators</source>
          <target state="translated">오류 처리 연산자</target>
        </trans-unit>
        <trans-unit id="9ceb71ac05eb7c0d4e0f71e59f027348742ea94e" translate="yes" xml:space="preserve">
          <source>ErrorObservable</source>
          <target state="translated">ErrorObservable</target>
        </trans-unit>
        <trans-unit id="459dd73e2f9690fb4438b0975a4b05b0ce7cfa81" translate="yes" xml:space="preserve">
          <source>ErrorObserver</source>
          <target state="translated">ErrorObserver</target>
        </trans-unit>
        <trans-unit id="5e34fb3687b1278339ee0d3379e624bb84cd98a9" translate="yes" xml:space="preserve">
          <source>Errors if Observable does not emit a value in given time span, in case of which subscribes to the second Observable.</source>
          <target state="translated">Observable이 두 번째 Observable을 구독하는 경우 지정된 시간 범위에서 값을 내 보내지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6e5818bcafbec15ddf51911a2500238bc9d154f3" translate="yes" xml:space="preserve">
          <source>Errors if Observable does not emit a value in given time span.</source>
          <target state="translated">Observable이 지정된 시간 범위에서 값을 방출하지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="38f019ec5a63549d3da60d25881b1179dbc406bc" translate="yes" xml:space="preserve">
          <source>Eventually, you will want to &lt;a href=&quot;migration#drop-compat&quot;&gt;drop the compatibility layer&lt;/a&gt; to complete the update to RxJS v6. Doing so will significantly decrease the size of your apps.</source>
          <target state="translated">결국 &lt;a href=&quot;migration#drop-compat&quot;&gt;호환성 계층&lt;/a&gt; 을 삭제하여 RxJS v6에 대한 업데이트를 완료하려고합니다. 그렇게하면 앱 크기가 크게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="d18cb123476987ea913bfeca6bc87919f03bebfc" translate="yes" xml:space="preserve">
          <source>Every 5 seconds start a window 1 second long, and emit at most 2 click events per window</source>
          <target state="translated">5 초마다 1 초 길이의 창을 시작하고 창당 최대 2 개의 클릭 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="cb9905734da60c3cce52678ea5d32b0f08238cd2" translate="yes" xml:space="preserve">
          <source>Every 5 seconds, emit the click events from the next 2 seconds</source>
          <target state="translated">5 초마다 다음 2 초부터 클릭 이벤트 발생</target>
        </trans-unit>
        <trans-unit id="90c6a7e49deda3f103b834960dca350177cc2e5b" translate="yes" xml:space="preserve">
          <source>Every JavaScript Function is a Pull system. The function is a Producer of data, and the code that calls the function is consuming it by &quot;pulling&quot; out a &lt;em&gt;single&lt;/em&gt; return value from its call.</source>
          <target state="translated">모든 JavaScript 함수는 풀 시스템입니다. 이 함수는 데이터 생산자이며 함수를 호출하는 코드는 호출에서 &lt;em&gt;단일&lt;/em&gt; 반환 값을 &quot;풀링&quot;하여 소비합니다 .</target>
        </trans-unit>
        <trans-unit id="568b3d67354a5fa6ac1d4ef7693c00e90a54fb43" translate="yes" xml:space="preserve">
          <source>Every Subject is an Observable and an Observer. You can subscribe to a Subject, and you can call next to feed values as well as error and complete.</source>
          <target state="translated">모든 주제는 관찰 가능하고 관찰자입니다. 주제를 구독 할 수 있으며 오류 및 완료뿐만 아니라 피드 값 옆에 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1aa05f062d0202c71119ad89e743230455866b79" translate="yes" xml:space="preserve">
          <source>Every other second, emit the click events from the next 500ms</source>
          <target state="translated">격초마다 다음 500ms에서 클릭 이벤트를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d7a66bf925858e2f45ba1914ac8b54a09fb42dc1" translate="yes" xml:space="preserve">
          <source>Every second, emit an array of the recent click events</source>
          <target state="translated">1 초마다 최근 클릭 이벤트 배열을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="fe3c8aa86bdfe0f0edf5b8b63b533f703120c08f" translate="yes" xml:space="preserve">
          <source>Every second, emit the most recent click at most once</source>
          <target state="translated">매초마다 가장 최근의 클릭을 최대 한 번 방출</target>
        </trans-unit>
        <trans-unit id="d33c52a1410cde2ffc8ffc9c4edd53ef14bdbed3" translate="yes" xml:space="preserve">
          <source>Every time an inner Observable emits, the output Observable emits</source>
          <target state="translated">내부 Observable이 방출 될 때마다 출력 Observable이 방출합니다</target>
        </trans-unit>
        <trans-unit id="19ed07cf669163fd549db2eac802f1a0db6dcee4" translate="yes" xml:space="preserve">
          <source>Every time resulting Observable is subscribed, event handler function will be registered to event target on given event type. When that event fires, value passed as a first argument to registered function will be emitted by output Observable. When Observable is unsubscribed, function will be unregistered from event target.</source>
          <target state="translated">결과 Observable이 등록 될 때마다 이벤트 핸들러 기능은 주어진 이벤트 유형에서 이벤트 대상에 등록됩니다. 해당 이벤트가 발생하면 등록 된 함수에 대한 첫 번째 인수로 전달 된 값이 출력 Observable에 의해 생성됩니다. Observable을 구독 취소하면 이벤트 대상에서 기능이 등록 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="392fe123059b9042a525c45fd36c5654d0b87c0c" translate="yes" xml:space="preserve">
          <source>Execute series of Observables no matter what, even if it means swallowing errors.</source>
          <target state="translated">삼키는 실수를 의미하더라도 무엇이든 상관없이 일련의 Observable을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ffa0db8a0362fcc46cdb81bf76f1fdb699e21fa2" translate="yes" xml:space="preserve">
          <source>Executing Observables</source>
          <target state="translated">옵저버 블 실행</target>
        </trans-unit>
        <trans-unit id="71a576c62e540f89942e39482d77e573b45c5750" translate="yes" xml:space="preserve">
          <source>Factory function to create an intermediate subject through which the source sequence's elements will be multicast to the selector function or Subject to push source elements into.</source>
          <target state="translated">소스 시퀀스의 요소가 선택기 기능으로 멀티 캐스트되거나 소스 요소를 푸시 할 주제로 중간 주제를 작성하는 팩토리 기능.</target>
        </trans-unit>
        <trans-unit id="49ebe28cd9d8a3b499e2ee48c4519d62f46db7ff" translate="yes" xml:space="preserve">
          <source>FactoryOrValue</source>
          <target state="translated">FactoryOrValue</target>
        </trans-unit>
        <trans-unit id="b2b3f280ebecac0f650af8442da0c28b812dc3a1" translate="yes" xml:space="preserve">
          <source>Filter items emitted by the source Observable by only emitting those that satisfy a specified predicate.</source>
          <target state="translated">지정된 술어를 만족하는 항목 만 방출하여 Observable 소스에서 방출 된 항목을 필터링하십시오.</target>
        </trans-unit>
        <trans-unit id="40e34b6dd8be897316b63fbba02a18e6929f348e" translate="yes" xml:space="preserve">
          <source>Filtering Operators</source>
          <target state="translated">필터링 연산자</target>
        </trans-unit>
        <trans-unit id="e8471e9cac7e3ccd5d662762dfc077ee68ce5fa5" translate="yes" xml:space="preserve">
          <source>Find and emit the first click that happens on a DIV element</source>
          <target state="translated">DIV 요소에서 발생하는 첫 번째 클릭을 찾아서 방출</target>
        </trans-unit>
        <trans-unit id="bdde1667c7637fa9e392561fe37a9129b5e37d35" translate="yes" xml:space="preserve">
          <source>Finds the first value that passes some test and emits that.</source>
          <target state="translated">테스트를 통과 한 첫 번째 값을 찾아서 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="e93ac40354ce3c02e55c7b9d6be7101043533708" translate="yes" xml:space="preserve">
          <source>First Observer subscribes to the multicasted Observable</source>
          <target state="translated">첫 번째 관찰자는 멀티 캐스트 된 Observable을 구독합니다.</target>
        </trans-unit>
        <trans-unit id="9f43d22726f1db010faa50c5dad1f4baef24a307" translate="yes" xml:space="preserve">
          <source>First Observer unsubscribes from the multicasted Observable</source>
          <target state="translated">첫 번째 관찰자는 멀티 캐스트 된 Observable에서 구독을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="2c0a59b2a738934720a981af4caf0f2257febc5f" translate="yes" xml:space="preserve">
          <source>First emits its arguments in order, and then any emissions from the source.</source>
          <target state="translated">먼저 순서대로 인수를 내린 다음 소스에서 나오는 모든 배출물을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="8447958c50fe14e1542bd2daf039b6f88aec1dcb" translate="yes" xml:space="preserve">
          <source>First examples</source>
          <target state="translated">첫 번째 예</target>
        </trans-unit>
        <trans-unit id="3e6017001d21808ecf90abeb0ea1829904c30600" translate="yes" xml:space="preserve">
          <source>Flattens an Observable-of-Observables by applying &lt;a href=&quot;../index/function/combinelatest&quot;&gt;&lt;code&gt;combineLatest&lt;/code&gt;&lt;/a&gt; when the Observable-of-Observables completes.</source>
          <target state="translated">Observable of Observables가 완료되면 &lt;a href=&quot;../index/function/combinelatest&quot;&gt; &lt;code&gt;combineLatest&lt;/code&gt; &lt;/a&gt; 를 적용하여 Observable-Observables를 평평 하게합니다.</target>
        </trans-unit>
        <trans-unit id="04cfff7f117896451c5efe35700ad71de1b0e885" translate="yes" xml:space="preserve">
          <source>Flattens an Observable-of-Observables by dropping the next inner Observables while the current inner is still executing.</source>
          <target state="translated">현재 내부가 여전히 실행되는 동안 다음 내부 Observable을 삭제하여 Observable-of-Observables를 평평하게합니다.</target>
        </trans-unit>
        <trans-unit id="7c4a395e33ae8f3613262bc17d460166f11f9771" translate="yes" xml:space="preserve">
          <source>Flattens an Observable-of-Observables by putting one inner Observable after the other.</source>
          <target state="translated">하나의 내부 Observable을 차례로 배치하여 Observable-of-Observables를 평평하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6261077d2db4f0f01ad8b5805900564289137493" translate="yes" xml:space="preserve">
          <source>Flattens an Observable-of-Observables.</source>
          <target state="translated">Observable of Observables를 평평하게합니다.</target>
        </trans-unit>
        <trans-unit id="336fdc425e8fb1e80985b24a579f686f6a6e2009" translate="yes" xml:space="preserve">
          <source>Flattens multiple Observables together by blending their values into one Observable.</source>
          <target state="translated">여러 개의 Observable을 하나의 Observable에 블렌딩하여 함께 평평하게합니다.</target>
        </trans-unit>
        <trans-unit id="86eff8eb789b097ddca83f2c9c4617ed23605105" translate="yes" xml:space="preserve">
          <source>Flow</source>
          <target state="translated">Flow</target>
        </trans-unit>
        <trans-unit id="3c706a96d542205f77531708a1c3b3097bd865a3" translate="yes" xml:space="preserve">
          <source>For CDN, you can use &lt;a href=&quot;https://unpkg.com/&quot;&gt;unpkg&lt;/a&gt;. Just replace version with the current version on the link below:</source>
          <target state="translated">CDN의 경우 &lt;a href=&quot;https://unpkg.com/&quot;&gt;unpkg&lt;/a&gt; 를 사용할 수 있습니다 . 아래 링크에서 버전을 현재 버전으로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="4dfc618a631337e10398e7c78f1909641f8774de" translate="yes" xml:space="preserve">
          <source>For JavaScript developers, the general rule is as follows:</source>
          <target state="translated">JavaScript 개발자의 경우 일반적인 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b93bc381a837cdd2e8f67790fd49b772a51d3702" translate="yes" xml:space="preserve">
          <source>For RxJS 5.0.0-beta.1 through beta.11: &lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.umd.js&quot;&gt;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.umd.js&lt;/a&gt;</source>
          <target state="translated">RxJS 5.0.0-beta.1에서 beta.11까지 : &lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.umd.js&quot;&gt;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.umd.js&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2cc880d660c8400030b8519a180258b600db213" translate="yes" xml:space="preserve">
          <source>For RxJS 5.0.0-beta.12 and higher: &lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.js&quot;&gt;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.js&lt;/a&gt;</source>
          <target state="translated">RxJS 5.0.0-beta.12 이상 : &lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.js&quot;&gt;https://unpkg.com/@reactivex/rxjs@version/dist/global/Rx.js&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="30781bd7122d9317d92dfe60463848c929299e16" translate="yes" xml:space="preserve">
          <source>For RxJS 6.0.0 and higher: &lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/rxjs.umd.js&quot;&gt;https://unpkg.com/@reactivex/rxjs@version/dist/global/rxjs.umd.js&lt;/a&gt;</source>
          <target state="translated">RxJS 6.0.0 이상 : &lt;a href=&quot;https://unpkg.com/@reactivex/rxjs@version/dist/global/rxjs.umd.js&quot;&gt;https://unpkg.com/@reactivex/rxjs@version/dist/global/rxjs.umd.js&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3aacb38d3ba8f1eca27a7d04d08c9ec383211f28" translate="yes" xml:space="preserve">
          <source>For a complete overview, see the &lt;a href=&quot;https://rxjs.dev/api&quot;&gt;references page&lt;/a&gt;.</source>
          <target state="translated">전체 개요는 &lt;a href=&quot;https://rxjs.dev/api&quot;&gt;참조 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="71adf40f1b3801502c368d773ac928b5fff11968" translate="yes" xml:space="preserve">
          <source>For a full explanation of what you will have to update in order to remove &lt;code&gt;rxjs-compat&lt;/code&gt;, see &lt;a href=&quot;migration#drop-compat&quot;&gt;Dropping the compatibility layer&lt;/a&gt;. Note also that fully updating your application to v6 may expose existing type errors that were not previously shown.</source>
          <target state="translated">&lt;code&gt;rxjs-compat&lt;/code&gt; 를 제거하기 위해 업데이트해야 할 내용에 대한 자세한 내용 &lt;a href=&quot;migration#drop-compat&quot;&gt;은 호환성 계층 삭제를&lt;/a&gt; 참조하십시오 . 또한 애플리케이션을 v6으로 완전히 업데이트하면 이전에 표시되지 않은 기존 유형 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3075c8d5f2ddd9453495c23a6d3a85a860c95665" translate="yes" xml:space="preserve">
          <source>For details about this package, see &lt;a href=&quot;https://www.npmjs.com/package/rxjs-compat&quot;&gt;https://www.npmjs.com/package/rxjs-compat&lt;/a&gt;.</source>
          <target state="translated">이 패키지에 대한 자세한 내용은 &lt;a href=&quot;https://www.npmjs.com/package/rxjs-compat&quot;&gt;https://www.npmjs.com/package/rxjs-compat를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd428686c6c90545d8b2bcd91920f91a6a7f16b7" translate="yes" xml:space="preserve">
          <source>For each click event, start an interval Observable ticking every 1 second</source>
          <target state="translated">각 클릭 이벤트마다 1 초마다 간격으로 관찰 가능 틱을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="9b5bd25151ae50ac80cb48151094fd9a522bc6b1" translate="yes" xml:space="preserve">
          <source>For each click event, tick every second from 0 to 3, with no concurrency</source>
          <target state="translated">각 클릭 이벤트에 대해 동시성없이 매 초마다 0에서 3까지 틱</target>
        </trans-unit>
        <trans-unit id="da73e6bc7c69579ce47d156493aaad13c78b9719" translate="yes" xml:space="preserve">
          <source>For example, the following code uses chaining:</source>
          <target state="translated">예를 들어 다음 코드는 체인을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1390fdbdab4c48752843cc3d3c5e3771179171fc" translate="yes" xml:space="preserve">
          <source>For example, the operator called &lt;a href=&quot;../api/operators/map&quot;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; is analogous to the Array method of the same name. Just as &lt;code&gt;[1, 2, 3].map(x =&amp;gt; x * x)&lt;/code&gt; will yield &lt;code&gt;[1, 4, 9]&lt;/code&gt;, the Observable created like this:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;../api/operators/map&quot;&gt; &lt;code&gt;map&lt;/code&gt; &lt;/a&gt; 이라는 연산자 는 같은 이름의 Array 메서드와 유사합니다. 마찬가지로 &lt;code&gt;[1, 2, 3].map(x =&amp;gt; x * x)&lt;/code&gt; 수득한다 &lt;code&gt;[1, 4, 9]&lt;/code&gt; , 이렇게 생성 된 관찰 :</target>
        </trans-unit>
        <trans-unit id="853b2727d71c0f828cbb891d5a55aed1ec783449" translate="yes" xml:space="preserve">
          <source>For example, you could make a function that discarded odd values and doubled even values like this:</source>
          <target state="translated">예를 들어 홀수 값을 버리고 다음과 같이 짝수 값을 두 배로 늘리는 함수를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec273ba7965ca090ef888c5ba8c99a2ff30f1dec" translate="yes" xml:space="preserve">
          <source>For instance, this is how we clear an interval execution set with &lt;code&gt;setInterval&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 이것은 &lt;code&gt;setInterval&lt;/code&gt; 을 사용 하여 간격 실행 세트를 지우는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="e26f23e8b0af8cdf983bb14b29d6d328a65014a9" translate="yes" xml:space="preserve">
          <source>For instance, with &lt;code&gt;zip&lt;/code&gt;, we would write</source>
          <target state="translated">예를 들어, &lt;code&gt;zip&lt;/code&gt; 을 사용 하면</target>
        </trans-unit>
        <trans-unit id="838888620b40e19c6ff7033090befe975b7f38ac" translate="yes" xml:space="preserve">
          <source>For typings users:</source>
          <target state="translated">타이핑 사용자 :</target>
        </trans-unit>
        <trans-unit id="0e64fe21f9689afc29ace240393c9a0373103b20" translate="yes" xml:space="preserve">
          <source>ForkJoinObservable</source>
          <target state="translated">ForkJoinObservable</target>
        </trans-unit>
        <trans-unit id="1c20ecad94bb21004fd90931f9cf9570a480d646" translate="yes" xml:space="preserve">
          <source>FromEventObservable</source>
          <target state="translated">FromEventObservable</target>
        </trans-unit>
        <trans-unit id="c3e704712cb43291834e2a5aa665ac60fe6ead64" translate="yes" xml:space="preserve">
          <source>FromEventPatternObservable</source>
          <target state="translated">FromEventPatternObservable</target>
        </trans-unit>
        <trans-unit id="ba952857f29ad095dbdd44119f64aee2803a96d9" translate="yes" xml:space="preserve">
          <source>FromObservable</source>
          <target state="translated">FromObservable</target>
        </trans-unit>
        <trans-unit id="621c78a2e74d2dc796c3b71647b55c0326ffa66c" translate="yes" xml:space="preserve">
          <source>Function to be called when source terminates.</source>
          <target state="translated">소스가 종료 될 때 호출되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="957c5944acd33361e7062dcad7a7a9a695d6b332" translate="yes" xml:space="preserve">
          <source>Functional composition is awesome. Building your own custom operators becomes much easier, and now they work and look just like all other operators in rxjs. You don't need to extend Observable or override &lt;code&gt;lift&lt;/code&gt; anymore.</source>
          <target state="translated">기능적 구성이 훌륭합니다. 사용자 정의 연산자를 작성하는 것이 훨씬 쉬워졌으며 이제는 rxjs의 다른 모든 연산자와 같이 작동하고 보입니다. 더 이상 Observable을 확장하거나 &lt;code&gt;lift&lt;/code&gt; 오버라이드 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3889ea8611c26a725e8465c567a219fb5666a68d" translate="yes" xml:space="preserve">
          <source>Functions can only return one value. Observables, however, can do this:</source>
          <target state="translated">함수는 하나의 값만 반환 할 수 있습니다. 그러나 Observable은 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="303e10207f177b23a328afb3ed7c795eb19ec395" translate="yes" xml:space="preserve">
          <source>Generate new Observable according to source Observable values</source>
          <target state="translated">소스 Observable 값에 따라 새로운 Observable 생성</target>
        </trans-unit>
        <trans-unit id="5bc786743f08df2282eeb88bdd929373a66a5cbd" translate="yes" xml:space="preserve">
          <source>GenerateObservable</source>
          <target state="translated">GenerateObservable</target>
        </trans-unit>
        <trans-unit id="81c0c27865a5aabbe78b36634e674339ea12f03f" translate="yes" xml:space="preserve">
          <source>Generates an Observable by running a state-driven loop that emits an element on each iteration.</source>
          <target state="translated">각 반복에서 요소를 내보내는 상태 중심 루프를 실행하여 Observable을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="54ff995c1db460f7d4ec8a43c9ff7df5b3307597" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages.</source>
          <target state="translated">지정된 스케줄러를 사용하여 관찰자 메시지를 전송하여 시퀀스의 요소를 생성하는 상태 중심 루프를 실행하여 관찰 가능한 시퀀스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="98b825ac41b8397865bf35074f515a8f5e86edd2" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages. The overload accepts options object that might contain initial state, iterate, condition and scheduler.</source>
          <target state="translated">지정된 스케줄러를 사용하여 관찰자 메시지를 전송하여 시퀀스의 요소를 생성하는 상태 중심 루프를 실행하여 관찰 가능한 시퀀스를 생성합니다. 오버로드는 초기 상태, 반복, 조건 및 스케줄러를 포함 할 수있는 옵션 오브젝트를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="ad90c1a944ee3fa6d5c7be853db7c58d15ddb878" translate="yes" xml:space="preserve">
          <source>Generates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages. The overload accepts options object that might contain initial state, iterate, condition, result selector and scheduler.</source>
          <target state="translated">지정된 스케줄러를 사용하여 관찰자 메시지를 전송하여 시퀀스의 요소를 생성하는 상태 중심 루프를 실행하여 관찰 가능한 시퀀스를 생성합니다. 오버로드는 초기 상태, 반복, 조건, 결과 선택기 및 스케줄러를 포함 할 수있는 옵션 오브젝트를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="57184ea89e0ad3d9688251dfe4bd88d9b6a4b24c" translate="yes" xml:space="preserve">
          <source>Generating PNG marble diagrams from tests</source>
          <target state="translated">테스트에서 PNG 대리석 다이어그램 생성</target>
        </trans-unit>
        <trans-unit id="551763240307b358e2541252c4ea9844aad40ac7" translate="yes" xml:space="preserve">
          <source>Get all values inside an array when the source completes</source>
          <target state="translated">소스가 완료되면 배열 내부의 모든 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6192885702ae8a6bc4b4e65f4064742ed47013e0" translate="yes" xml:space="preserve">
          <source>Get the maximal value of a series of numbers</source>
          <target state="translated">일련의 숫자의 최대 값 얻기</target>
        </trans-unit>
        <trans-unit id="cd9b12ae584c39e58461f2d1c2bc7b2d2d918c83" translate="yes" xml:space="preserve">
          <source>Get the minimal value of a series of numbers</source>
          <target state="translated">일련의 숫자의 최소값 얻기</target>
        </trans-unit>
        <trans-unit id="82645a0e54372b3bd69d16159415e8bede299b3c" translate="yes" xml:space="preserve">
          <source>Give it a function &lt;code&gt;f&lt;/code&gt; of type &lt;code&gt;f(x, callback)&lt;/code&gt; and it will return a function &lt;code&gt;g&lt;/code&gt; that when called as &lt;code&gt;g(x)&lt;/code&gt; will output an Observable.</source>
          <target state="translated">&lt;code&gt;f(x, callback)&lt;/code&gt; 유형 의 함수 &lt;code&gt;f&lt;/code&gt; 를 제공하면 &lt;code&gt;g(x)&lt;/code&gt; 로 호출 될 때 Observable을 출력하는 함수 &lt;code&gt;g&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6f36b89b671804ed1110fb922788cc37c4a564fe" translate="yes" xml:space="preserve">
          <source>Given a hot source, test multiple subscribers that subscribe at different times:</source>
          <target state="translated">핫 소스가 주어지면 다른 시간에 구독하는 여러 구독자를 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="39da52064d9093fec3f687f9ef3a311b61691213" translate="yes" xml:space="preserve">
          <source>Given a list of strings describing a path to an object property, retrieves the value of a specified nested property from all values in the source Observable. If a property can't be resolved, it will return &lt;code&gt;undefined&lt;/code&gt; for that value.</source>
          <target state="translated">객체 속성에 대한 경로를 설명하는 문자열 목록이 제공되면 소스 Observable의 모든 값에서 지정된 중첩 속성의 값을 검색합니다. 속성을 확인할 수 없으면 해당 값에 대해 &lt;code&gt;undefined&lt;/code&gt; 값을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="07449bc0c82fd975877782bde1b7acc37ead6d3e" translate="yes" xml:space="preserve">
          <source>Given some &lt;a href=&quot;../interface/observer&quot;&gt;&lt;code&gt;Observer&lt;/code&gt;&lt;/a&gt; callbacks, deliver the value represented by the current Notification to the correctly corresponding callback.</source>
          <target state="translated">일부 주어 &lt;a href=&quot;../interface/observer&quot;&gt; &lt;code&gt;Observer&lt;/code&gt; &lt;/a&gt; 콜백 올바르게 대응하는 콜백 현재 통지가 나타내는 값을 제공한다.</target>
        </trans-unit>
        <trans-unit id="54f2ff8a238acabb2079588d5c2033656ef069ee" translate="yes" xml:space="preserve">
          <source>Given the following code:</source>
          <target state="translated">다음 코드가 주어진다 :</target>
        </trans-unit>
        <trans-unit id="c124c9fdd71373efa4b6882f80c535df13098af6" translate="yes" xml:space="preserve">
          <source>Group objects by id and return as array</source>
          <target state="translated">id로 객체를 그룹화하고 배열로 반환</target>
        </trans-unit>
        <trans-unit id="dc85de0c8d1aa8d1842c6bc27349fd8488ab304a" translate="yes" xml:space="preserve">
          <source>GroupedObservable</source>
          <target state="translated">GroupedObservable</target>
        </trans-unit>
        <trans-unit id="29da1b8ea5e10bb6cee089501b380d1c22317b19" translate="yes" xml:space="preserve">
          <source>GroupedObservable._subscribe()</source>
          <target state="translated">GroupedObservable._subscribe()</target>
        </trans-unit>
        <trans-unit id="67a5ee349162f7ac679862e2cb19c477ef489ade" translate="yes" xml:space="preserve">
          <source>Groups pairs of consecutive emissions together and emits them as an array of two values.</source>
          <target state="translated">연속 방출 쌍을 함께 그룹화하여 두 값의 배열로 방출합니다.</target>
        </trans-unit>
        <trans-unit id="20050b3ab03e9f7ad2f940b4b5719c213555e0f0" translate="yes" xml:space="preserve">
          <source>Groups the items emitted by an Observable according to a specified criterion, and emits these grouped items as &lt;code&gt;GroupedObservables&lt;/code&gt;, one &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; per group.</source>
          <target state="translated">지정된 기준에 따라 Observable이 방출 한 항목을 그룹화하고 이러한 그룹화 된 항목을 &lt;code&gt;GroupedObservables&lt;/code&gt; 하나의 &lt;a href=&quot;../index/class/groupedobservable&quot;&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; &lt;/a&gt; 로 GroupedObservables 로 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="bf073fae640ded81eeb7a4cee70faff4a623c16c" translate="yes" xml:space="preserve">
          <source>Guide</source>
          <target state="translated">Guide</target>
        </trans-unit>
        <trans-unit id="1c928db5e3e6d1f30a2aed1390d012555c85e156" translate="yes" xml:space="preserve">
          <source>Here are different ways you can install RxJs:</source>
          <target state="translated">RxJ를 설치할 수있는 다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a5385a2e5e53ebc1302f5ef2e06bfb489acf042" translate="yes" xml:space="preserve">
          <source>Here is an example of a user-defined prototype operator:</source>
          <target state="translated">다음은 사용자 정의 프로토 타입 연산자의 예입니다.</target>
        </trans-unit>
        <trans-unit id="c07d60dcb84ebdbbf843c148434b505c3237d745" translate="yes" xml:space="preserve">
          <source>Here's how you can add the current mouse x position for every click, in plain JavaScript:</source>
          <target state="translated">다음은 일반 JavaScript에서 모든 클릭에 대해 현재 마우스 x 위치를 추가하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7e8f1c39f2eee220aa407a7a27af05dd7e03a1ba" translate="yes" xml:space="preserve">
          <source>Higher-order Observables</source>
          <target state="translated">고차 관측치</target>
        </trans-unit>
        <trans-unit id="03629c9d2b75927156ea1bbd28d4746b87641d9a" translate="yes" xml:space="preserve">
          <source>How many virtual milliseconds one frame represents depends on the value of &lt;code&gt;TestScheduler.frameTimeFactor&lt;/code&gt;. For legacy reasons the value of &lt;code&gt;frameTimeFactor&lt;/code&gt; is 1 &lt;em&gt;only&lt;/em&gt; when your code inside the &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; callback is running. Outside of it, it's set to 10. This will likely change in a future version of RxJS so that it is always 1.</source>
          <target state="translated">한 프레임이 나타내는 가상 밀리 초 수는 &lt;code&gt;TestScheduler.frameTimeFactor&lt;/code&gt; 의 값에 따라 다릅니다 . 레거시 이유로 인해 &lt;code&gt;frameTimeFactor&lt;/code&gt; 의 값은 &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; 콜백 내의 코드 가 실행중인 경우 &lt;em&gt;에만&lt;/em&gt; 1 입니다. 그 밖에는 10으로 설정되어 있습니다. 향후 버전의 RxJS에서는 항상 1이되도록 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac69cb6bdf7453f64d6f79219570637438301804" translate="yes" xml:space="preserve">
          <source>HowTo: Convert deprecated methods</source>
          <target state="translated">HowTo : 더 이상 사용되지 않는 메소드 변환</target>
        </trans-unit>
        <trans-unit id="a70b4ef372737a8a66669faafec62818909ed3a7" translate="yes" xml:space="preserve">
          <source>HowTo: Convert to pipe syntax</source>
          <target state="translated">방법 : 파이프 구문으로 변환</target>
        </trans-unit>
        <trans-unit id="36e080fecbaabae929b5fc636275d5fc7eb5d6cc" translate="yes" xml:space="preserve">
          <source>HowTo: Result selector migration</source>
          <target state="translated">방법 : 결과 선택기 마이그레이션</target>
        </trans-unit>
        <trans-unit id="8b929422af26da967f9b75d1aeabb1e1f639d189" translate="yes" xml:space="preserve">
          <source>IMPORTANT: This syntax guide refers to usage of marble diagrams when using the new &lt;code&gt;testScheduler.run(callback)&lt;/code&gt;. The semantics of marble diagrams when using the TestScheduler manually are different, and some features like the new time progression syntax are not supported.</source>
          <target state="translated">중요 :이 구문 안내서는 새로운 &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; 사용할 때 대리석 다이어그램의 사용법을 나타냅니다 . TestScheduler를 수동으로 사용할 때 대리석 다이어그램의 의미는 다르며 새로운 시간 진행 구문과 같은 일부 기능은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40f0b7905e2da41f9e18c82b1b0614b2ffabfa2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; depends on some context (&lt;code&gt;this&lt;/code&gt; property) and is not already bound, the context of &lt;code&gt;func&lt;/code&gt; will be the context that the output function has at call time. In particular, if &lt;code&gt;func&lt;/code&gt; is called as a method of some objec and if &lt;code&gt;func&lt;/code&gt; is not already bound, in order to preserve the context it is recommended that the context of the output function is set to that object as well.</source>
          <target state="translated">경우 &lt;code&gt;func&lt;/code&gt; 어떤 상황 (에 따라 &lt;code&gt;this&lt;/code&gt; 속성) 이미 구속되지 않고, 문맥 &lt;code&gt;func&lt;/code&gt; 출력 기능은 통화 시간에 가지고있는 상황이 될 것입니다. 특히 &lt;code&gt;func&lt;/code&gt; 가 일부 objec의 메소드로 호출되고 &lt;code&gt;func&lt;/code&gt; 가 이미 바인딩되어 있지 않은 경우 컨텍스트를 유지하려면 출력 함수의 컨텍스트를 해당 객체로 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="07c92379e38482d3edbd155b04331dd9b3b02da3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;onErrorResumeNext&lt;/code&gt; is provided no arguments, or a single, empty array, it will return &lt;a href=&quot;../const/empty&quot;&gt;&lt;code&gt;EMPTY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;onErrorResumeNext&lt;/code&gt; 에 인수가 없거나 빈 배열 하나가 제공 되면 &lt;a href=&quot;../const/empty&quot;&gt; &lt;code&gt;EMPTY&lt;/code&gt; &lt;/a&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b1c709af96b5325f3d70325ca645039104585d8e" translate="yes" xml:space="preserve">
          <source>If API you are using allows to unregister event handlers as well, you can pass to &lt;code&gt;fromEventPattern&lt;/code&gt; another function - &lt;code&gt;removeHandler&lt;/code&gt; - as a second parameter. It will be injected with the same handler function as before, which now you can use to unregister it from the API. &lt;code&gt;removeHandler&lt;/code&gt; will be called when consumer of resulting Observable unsubscribes from it.</source>
          <target state="translated">사용중인 API가 이벤트 핸들러 등록을 취소 할 수있는 경우 &lt;code&gt;fromEventPattern&lt;/code&gt; 에 다른 함수 인 &lt;code&gt;removeHandler&lt;/code&gt; 를 두 번째 매개 변수로 전달할 수 있습니다 . 이전과 동일한 핸들러 함수가 주입되어 이제 API에서 등록 해제하는 데 사용할 수 있습니다. 결과 Observable의 &lt;code&gt;removeHandler&lt;/code&gt; 가 구독을 취소하면 removeHandler 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4af6c10fb1dd2648dc979da484b8a8053c819fb3" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; for this key exists, this &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; emits. Elsewhere, a new &lt;a href=&quot;../index/class/groupedobservable&quot;&gt;&lt;code&gt;GroupedObservable&lt;/code&gt;&lt;/a&gt; for this key is created and emits.</source>
          <target state="translated">이 키에 대한 &lt;a href=&quot;../index/class/groupedobservable&quot;&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; &lt;/a&gt; 이 존재하면이 &lt;a href=&quot;../index/class/groupedobservable&quot;&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; 이&lt;/a&gt; 방출됩니다. 다른 곳에서는 이 키에 대한 새로운 &lt;a href=&quot;../index/class/groupedobservable&quot;&gt; &lt;code&gt;GroupedObservable&lt;/code&gt; &lt;/a&gt; 이 작성되어 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="df8b94facaadd3672b301652e68967bd50f31e88" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;project&lt;/code&gt; function is provided, it is called with each recent value from each inner Observable in whatever order they arrived, and the result of the &lt;code&gt;project&lt;/code&gt; function is what is emitted by the output Observable.</source>
          <target state="translated">경우 &lt;code&gt;project&lt;/code&gt; 기능이 제공되는, 그것은 그들이 도착 순서대로 각 내부 관찰 가능한에서 각 최근 값으로 호출하고 결과되는 &lt;code&gt;project&lt;/code&gt; 기능은 관찰 가능한 출력에 의해 방출되는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9a850724cf0766e1952f2eb5588d6e0108fae17b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;signal&lt;/code&gt; is provided via the &lt;code&gt;init&lt;/code&gt; argument, it will behave like it usually does with &lt;code&gt;fetch&lt;/code&gt;. If the provided &lt;code&gt;signal&lt;/code&gt; aborts, the error that &lt;code&gt;fetch&lt;/code&gt; normally rejects with in that scenario will be emitted as an error from the observable.</source>
          <target state="translated">&lt;code&gt;signal&lt;/code&gt; 가 &lt;code&gt;init&lt;/code&gt; 인수 를 통해 제공 되면 일반적으로 &lt;code&gt;fetch&lt;/code&gt; 와 같이 동작합니다 . 제공된 &lt;code&gt;signal&lt;/code&gt; 중단되면 해당 시나리오에서 &lt;code&gt;fetch&lt;/code&gt; 일반적으로 거부하는 오류는 관찰 가능 항목에서 오류로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="028415691a9845121c3a2af04d5b598c1f3893a8" translate="yes" xml:space="preserve">
          <source>If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted. If a comparator function is not provided, an equality check is used by default.</source>
          <target state="translated">비교기 기능이 제공되면 각 항목에 대해 해당 값의 방출 여부를 테스트하기 위해 호출됩니다. 비교기 기능이 제공되지 않으면 기본적으로 동등 검사가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4b4b939b7eaab790925369773890c1bf7cf233c9" translate="yes" xml:space="preserve">
          <source>If a keySelector function is provided, then it will project each value from the source observable into a new value that it will check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the source observable directly with an equality check against previous values.</source>
          <target state="translated">keySelector 함수가 제공되면, 소스에서 관찰 가능한 각 값을 새로운 값으로 투영하여 이전에 투영 된 값과 같은지 확인합니다. keySelector 기능이 제공되지 않으면 소스 값의 각 값을 이전 값과의 동등성 검사와 함께 직접 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f37cc6878132becb067139744ba3d260310d9d74" translate="yes" xml:space="preserve">
          <source>If any Observable in chain errors, instead of passing control to the next Observable, &lt;code&gt;concat&lt;/code&gt; will error immediately as well. Observables that would be subscribed after the one that emitted error, never will.</source>
          <target state="translated">체인 오류에서 Observable이 제어를 다음 Observable로 전달하는 대신 &lt;code&gt;concat&lt;/code&gt; 도 즉시 오류를 발생시킵니다. 오류를 발생시킨 후에 구독하는 Observable은 절대로 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb0b51e78db6718b4838278fc6306924448093f9" translate="yes" xml:space="preserve">
          <source>If any input observable errors at some point, &lt;code&gt;forkJoin&lt;/code&gt; will error as well and all other observables will be immediately unsubscribed.</source>
          <target state="translated">어떤 시점에서 입력 관찰 가능 오류 가 발생 하면 &lt;code&gt;forkJoin&lt;/code&gt; 도 오류가 발생하고 다른 모든 관찰 가능 항목은 즉시 구독 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="b185bb62138ba5ed799cdcae2d55f53c229a1bb0" translate="yes" xml:space="preserve">
          <source>If at least one Observable was passed to &lt;code&gt;combineLatest&lt;/code&gt; and all passed Observables emitted something, resulting Observable will complete when all combined streams complete. So even if some Observable completes, result of &lt;code&gt;combineLatest&lt;/code&gt; will still emit values when other Observables do. In case of completed Observable, its value from now on will always be the last emitted value. On the other hand, if any Observable errors, &lt;code&gt;combineLatest&lt;/code&gt; will error immediately as well, and all other Observables will be unsubscribed.</source>
          <target state="translated">하나 이상의 Observable이 &lt;code&gt;combineLatest&lt;/code&gt; 로 전달되고 전달 된 모든 Observable이 무언가를 방출 한 경우 모든 결합 된 스트림이 완료되면 Observable이 완료됩니다. 따라서 일부 Observable이 완료 되더라도 다른 Observable이 수행 할 때 &lt;code&gt;combineLatest&lt;/code&gt; 의 결과 는 여전히 값을 방출합니다. Observable이 완료된 경우 지금부터 해당 값이 항상 마지막으로 방출 된 값이됩니다. 반면 Observable 오류가 &lt;code&gt;combineLatest&lt;/code&gt; 도 즉시 오류가 발생하고 다른 모든 Observable은 구독 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="1e0c62fb072d51f0442df156d8425d45e8d5cf22" translate="yes" xml:space="preserve">
          <source>If called with no arguments, &lt;code&gt;first&lt;/code&gt; emits the first value of the source Observable, then completes. If called with a &lt;code&gt;predicate&lt;/code&gt; function, &lt;code&gt;first&lt;/code&gt; emits the first value of the source that matches the specified condition. It may also take a deprecated &lt;code&gt;resultSelector&lt;/code&gt; function to produce the output value from the input value, and a &lt;code&gt;defaultValue&lt;/code&gt; to emit in case the source completes before it is able to emit a valid value. Throws an error if &lt;code&gt;defaultValue&lt;/code&gt; was not provided and a matching element is not found.</source>
          <target state="translated">인수없이 호출하면 &lt;code&gt;first&lt;/code&gt; 소스 Observable의 첫 번째 값을 방출 한 다음 완료됩니다. &lt;code&gt;predicate&lt;/code&gt; 함수 와 함께 호출 되면 &lt;code&gt;first&lt;/code&gt; 지정된 조건과 일치하는 소스의 첫 번째 값을 내 보냅니다. 또한 사용되지 않는 &lt;code&gt;resultSelector&lt;/code&gt; 함수를 사용하여 입력 값에서 출력 값을 생성 하고 소스가 유효한 값을 생성하기 전에 완료 될 경우 방출 할 &lt;code&gt;defaultValue&lt;/code&gt; 를 사용할 수 있습니다. &lt;code&gt;defaultValue&lt;/code&gt; 가 제공되지 않고 일치하는 요소를 찾지 못하면 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="3bcd9d37561bf68f49980616d1911338e805195a" translate="yes" xml:space="preserve">
          <source>If no clicks happen in 5 seconds, then emit &quot;no clicks&quot;</source>
          <target state="translated">5 초 내에 클릭이 발생하지 않으면 &quot;클릭 없음&quot;이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fe2f6c30c49a1d0418d15b8fce2ca69c14e338fe" translate="yes" xml:space="preserve">
          <source>If number was provided, it returns an Observable that behaves like a source Observable, unless there is a period of time where there is no value emitted. So if you provide &lt;code&gt;100&lt;/code&gt; as argument and first value comes after 50ms from the moment of subscription, this value will be simply re-emitted by the resulting Observable. If however after that 100ms passes without a second value being emitted, stream will end with an error and source Observable will be unsubscribed. These checks are performed throughout whole lifecycle of Observable - from the moment it was subscribed to, until it completes or errors itself. Thus every value must be emitted within specified period since previous value.</source>
          <target state="translated">숫자가 제공된 경우, 방출되는 값이없는 기간이 없으면 소스 Observable처럼 동작하는 Observable을 리턴합니다. 따라서 인수로 &lt;code&gt;100&lt;/code&gt; 을 제공 하고 구독 순간부터 50ms 후에 첫 번째 값이 오는 경우이 값은 결과 Observable에 의해 단순히 다시 전송됩니다. 그러나 두 번째 값이 방출되지 않고 100ms가 지나면 스트림이 오류로 끝나고 Observable 소스가 구독 취소됩니다. 이러한 점검은 가입 한 순간부터 완료 또는 오류 자체까지 Observable의 전체 수명주기 동안 수행됩니다. 따라서 모든 값은 이전 값 이후 지정된 기간 내에 방출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9927bd26769cb903fed62e7a678f564c56dffc51" translate="yes" xml:space="preserve">
          <source>If provided argument was Date, returned Observable behaves differently. It throws if Observable did not complete before provided Date. This means that periods between emission of particular values do not matter in this case. If Observable did not complete before provided Date, source Observable will be unsubscribed. Other than that, resulting stream behaves just as source Observable.</source>
          <target state="translated">제공된 인수가 Date 인 경우 반환 된 Observable은 다르게 동작합니다. 제공된 날짜 전에 Observable이 완료되지 않은 경우 발생합니다. 이것은 특정 값의 방출 간격은이 경우 중요하지 않음을 의미합니다. 제공된 날짜 전에 Observable이 완료되지 않은 경우 소스 Observable은 구독 취소됩니다. 그 이외의 결과 스트림은 소스 Observable처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="f38eff0754b3ee76a87f735922543165f876702b" translate="yes" xml:space="preserve">
          <source>If the API you use is more callback then event handler oriented (subscribed callback function fires only once and thus there is no need to manually unregister it), you should use &lt;a href=&quot;bindcallback&quot;&gt;&lt;code&gt;bindCallback&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;bindnodecallback&quot;&gt;&lt;code&gt;bindNodeCallback&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">사용하는 API가 더 많은 콜백 인 경우 이벤트 핸들러 지향 (구독 된 콜백 함수가 한 번만 실행되므로 수동으로 등록을 해제 할 필요가 없음) 대신 &lt;a href=&quot;bindcallback&quot;&gt; &lt;code&gt;bindCallback&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;bindnodecallback&quot;&gt; &lt;code&gt;bindNodeCallback&lt;/code&gt; 을 사용해야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d701a75284d0a6eaaaeb95b5a8f86ab1226adb0a" translate="yes" xml:space="preserve">
          <source>If the delay argument is a Date, this operator time shifts the start of the Observable execution until the given date occurs.</source>
          <target state="translated">delay 인수가 Date 인 경우이 연산자 시간은 지정된 날짜가 발생할 때까지 Observable 실행 시작을 이동시킵니다.</target>
        </trans-unit>
        <trans-unit id="a35fe97591e295a1ffadb54ac04ce29d0914a39f" translate="yes" xml:space="preserve">
          <source>If the delay argument is a Number, this operator time shifts the source Observable by that amount of time expressed in milliseconds. The relative time intervals between the values are preserved.</source>
          <target state="translated">지연 인수가 숫자 인 경우이 연산자 시간은 소스 Observable을 밀리 초 단위로 표시된 시간만큼 이동합니다. 값 사이의 상대적 시간 간격이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="1d0edea354d308cd425e5a8ad0f533ee55c07ab3" translate="yes" xml:space="preserve">
          <source>If the input function calls its callback in the &quot;node style&quot; (i.e. first argument to callback is optional error parameter signaling whether the call failed or not), &lt;a href=&quot;bindnodecallback&quot;&gt;&lt;code&gt;bindNodeCallback&lt;/code&gt;&lt;/a&gt; provides convenient error handling and probably is a better choice. &lt;code&gt;bindCallback&lt;/code&gt; will treat such functions the same as any other and error parameters (whether passed or not) will always be interpreted as regular callback argument.</source>
          <target state="translated">입력 함수가 &quot;노드 스타일&quot;에서 콜백을 호출하는 경우 (즉, 콜백에 대한 첫 번째 인수는 호출 실패 여부를 나타내는 선택적 오류 매개 변수 임), &lt;a href=&quot;bindnodecallback&quot;&gt; &lt;code&gt;bindNodeCallback&lt;/code&gt; &lt;/a&gt; 은 편리한 오류 처리 기능을 제공하며 아마도 더 나은 선택 일 것입니다. &lt;code&gt;bindCallback&lt;/code&gt; 은 이러한 함수를 다른 함수와 동일하게 처리하며 오류 매개 변수 (통과 여부에 상관없이)는 항상 일반 콜백 인수로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="0b21237624e24ba4cc805cfeee666fd31c53c5b0" translate="yes" xml:space="preserve">
          <source>If the last parameter is a function, this function is used to compute the created value from the input values. Otherwise, an array of the input values is returned.</source>
          <target state="translated">마지막 매개 변수가 함수 인 경우이 함수는 입력 값에서 작성된 값을 계산하는 데 사용됩니다. 그렇지 않으면 입력 값의 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="704afffd75894b6709cab10f66bc542fc722f744" translate="yes" xml:space="preserve">
          <source>If the source Observable turns out to be empty, then this operator will emit a default value.</source>
          <target state="translated">소스 Observable이 비어 있으면이 연산자는 기본값을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="65c66c04bc0bef2071226e606af604f4bb46432a" translate="yes" xml:space="preserve">
          <source>If the source observable completes without emitting a value, it will emit an error. The error will be created at that time by the optional &lt;code&gt;errorFactory&lt;/code&gt; argument, otherwise, the error will be &lt;a href=&quot;../index/interface/emptyerror&quot;&gt;&lt;code&gt;EmptyError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">소스 옵저버 블이 값을 내 보내지 않고 완료되면 오류가 발생합니다. 해당 시점에 선택적 &lt;code&gt;errorFactory&lt;/code&gt; 인수에 의해 오류가 작성되고 , 그렇지 않으면 오류는 &lt;a href=&quot;../index/interface/emptyerror&quot;&gt; &lt;code&gt;EmptyError&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b81b74a71c6eeb0509a7903617c743cf2e95798b" translate="yes" xml:space="preserve">
          <source>If the tear down being added is a subscription that is already unsubscribed, is the same reference &lt;code&gt;add&lt;/code&gt; is being called on, or is &lt;code&gt;Subscription.EMPTY&lt;/code&gt;, it will not be added.</source>
          <target state="translated">추가중인 분류가 이미 구독 취소 된 구독 이거나 동일한 참조 &lt;code&gt;add&lt;/code&gt; 가 호출되고 있거나 &lt;code&gt;Subscription.EMPTY&lt;/code&gt; 인 구독 인 경우 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9540c042022e13c3a09c2d5bc7fab29748e20f12" translate="yes" xml:space="preserve">
          <source>If there is a commonly used sequence of operators in your code, use the &lt;code&gt;pipe()&lt;/code&gt; function to extract the sequence into a new operator. Even if a sequence is not that common, breaking it out into a single operator can improve readability.</source>
          <target state="translated">코드에 일반적으로 사용되는 일련의 연산자가 있으면 &lt;code&gt;pipe()&lt;/code&gt; 함수를 사용하여 시퀀스를 새 연산자로 추출하십시오. 시퀀스가 그렇게 일반적이지 않더라도 단일 연산자로 분류하면 가독성이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="120e2aa081d0d7d86f0ec952fbf8c0c6ba52c280" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;project&lt;/code&gt; function, an array of all the most recent values is emitted by the output Observable.</source>
          <target state="translated">&lt;code&gt;project&lt;/code&gt; 기능 이없는 경우 가장 최근의 모든 값의 배열이 출력 Observable에 의해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2042c5f5108b1085d8f0cd4827f1b1647e843180" translate="yes" xml:space="preserve">
          <source>If this subscription is already in an &lt;code&gt;closed&lt;/code&gt; state, the passed tear down logic will be executed immediately.</source>
          <target state="translated">이 가입이 이미 &lt;code&gt;closed&lt;/code&gt; 상태 인 경우 전달 된 분리 로직이 즉시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="617020e61af12a357bc2772c78eadc0453defeed" translate="yes" xml:space="preserve">
          <source>If we wish to avoid explicit calls to &lt;code&gt;connect()&lt;/code&gt;, we can use ConnectableObservable's &lt;code&gt;refCount()&lt;/code&gt; method (reference counting), which returns an Observable that keeps track of how many subscribers it has. When the number of subscribers increases from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;, it will call &lt;code&gt;connect()&lt;/code&gt; for us, which starts the shared execution. Only when the number of subscribers decreases from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt; will it be fully unsubscribed, stopping further execution.</source>
          <target state="translated">&lt;code&gt;connect()&lt;/code&gt; 에 대한 명시적인 호출을 피 하려면 ConnectableObservable의 &lt;code&gt;refCount()&lt;/code&gt; 메서드 (참조 횟수)를 사용하면 구독자 수를 추적하는 Observable을 반환합니다. 가입자 수가 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;1&lt;/code&gt; 로 증가 하면 &lt;code&gt;connect()&lt;/code&gt; 를 호출 하여 공유 실행을 시작합니다. 가입자 수가 &lt;code&gt;1&lt;/code&gt; 에서 &lt;code&gt;0&lt;/code&gt; 으로 감소한 경우에만 구독이 완전히 취소되어 추가 실행이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="5439a31ba2d71bf365539528323ff6c90d45a470" translate="yes" xml:space="preserve">
          <source>If you &lt;code&gt;require('rxjs/_esm5/path-mapping')&lt;/code&gt;, you will receive a function that returns an object of key-value pairs mapping each input to it's file location on disk. Utilize this mapping as follows:</source>
          <target state="translated">&lt;code&gt;require('rxjs/_esm5/path-mapping')&lt;/code&gt; 이 필요한 경우 각 입력을 디스크의 파일 위치에 매핑하는 키-값 쌍의 객체를 반환하는 함수를받습니다. 이 매핑을 다음과 같이 활용하십시오.</target>
        </trans-unit>
        <trans-unit id="38877b71d192590feabd1b186895b050de142d89" translate="yes" xml:space="preserve">
          <source>If you are defining your own prototype operators in TypeScript and modifying the &lt;code&gt;Observable&lt;/code&gt; namespace, you will need to change your operator code in order to get TypeScript to compile. See &lt;a href=&quot;migration#ex-2&quot;&gt;examples&lt;/a&gt;. This is a relatively rare case, likely to affect only advanced TypeScript developers.</source>
          <target state="translated">TypeScript에서 자체 프로토 타입 연산자를 정의하고 &lt;code&gt;Observable&lt;/code&gt; 네임 스페이스를 수정하는 경우 TypeScript를 컴파일하려면 연산자 코드를 변경해야합니다. &lt;a href=&quot;migration#ex-2&quot;&gt;예를&lt;/a&gt; 참조하십시오 . 비교적 드문 경우이며 고급 TypeScript 개발자에게만 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77ad98badca810f45da78ca2f70f7bab1d886cbb" translate="yes" xml:space="preserve">
          <source>If you are using npm version 2 before this library has achieved a stable version, you need to specify the library version explicitly:</source>
          <target state="translated">이 라이브러리가 안정적인 버전을 얻기 전에 npm 버전 2를 사용하는 경우 라이브러리 버전을 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="844ad591748c8aca77e4dcdccf63c8692cdaaa4b" translate="yes" xml:space="preserve">
          <source>If you are using the parameter, you must update your code by moving your result-selection function out of the original operator call, and applying it to the results of the call.</source>
          <target state="translated">매개 변수를 사용하는 경우 결과 선택 기능을 원래 운영자 호출에서 이동시킨 후 호출 결과에 적용하여 코드를 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="3978310b1cc85c905bb0eeaf6cf95815f8dd8096" translate="yes" xml:space="preserve">
          <source>If you enable the &lt;code&gt;leading&lt;/code&gt; parameter in this example, the output would be the primary click and the double click, but restricts additional clicks within 400ms.</source>
          <target state="translated">이 예제에서 &lt;code&gt;leading&lt;/code&gt; 매개 변수 를 사용하면 기본 클릭과 이중 클릭이 출력되지만 400ms 이내에 추가 클릭이 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="8924e6022acb95d4b22dad3bc88d202b7faa16fd" translate="yes" xml:space="preserve">
          <source>If you find three anonymous functions in &lt;code&gt;generate&lt;/code&gt; call hard to read, you can provide single object to the operator instead. That object has properties: &lt;code&gt;initialState&lt;/code&gt;, &lt;code&gt;condition&lt;/code&gt;, &lt;code&gt;iterate&lt;/code&gt; and &lt;code&gt;resultSelector&lt;/code&gt;, which should have respective values that you would normally pass to &lt;code&gt;generate&lt;/code&gt;. &lt;code&gt;resultSelector&lt;/code&gt; is still optional, but that form of calling &lt;code&gt;generate&lt;/code&gt; allows you to omit &lt;code&gt;condition&lt;/code&gt; as well. If you omit it, that means condition always holds, so output Observable will never complete.</source>
          <target state="translated">&lt;code&gt;generate&lt;/code&gt; 하기 어려운 호출 생성 에서 세 개의 익명 함수를 찾으면 대신 단일 객체를 연산자에 제공 할 수 있습니다. 해당 객체에는 &lt;code&gt;initialState&lt;/code&gt; , &lt;code&gt;condition&lt;/code&gt; , &lt;code&gt;iterate&lt;/code&gt; 및 &lt;code&gt;resultSelector&lt;/code&gt; 속성이 있습니다.이 속성에는 일반적으로 &lt;code&gt;generate&lt;/code&gt; 하기 위해 전달할 각 값이 있어야합니다 . &lt;code&gt;resultSelector&lt;/code&gt; 는 여전히 선택 사항이지만, &lt;code&gt;generate&lt;/code&gt; 하는 호출 양식을 사용하면 &lt;code&gt;condition&lt;/code&gt; 을 생략 할 수도 있습니다. 생략하면 조건이 항상 유지되므로 출력 Observable이 완료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6622080ade80659a6c5d1d8c040185d09d9ce150" translate="yes" xml:space="preserve">
          <source>If you have RxJS code that uses any other form of async scheduling other than AsyncScheduler, e.g. Promises, AsapScheduler, etc. you can't reliably use marble diagrams &lt;em&gt;for that particular code&lt;/em&gt;. This is because those other scheduling methods won't be virtualized or known to TestScheduler.</source>
          <target state="translated">AsyncScheduler 이외의 다른 형태의 비동기 스케줄링 (예 : Promises, AsapScheduler 등)을 사용하는 RxJS 코드가있는 경우 &lt;em&gt;해당 특정 코드에 대해&lt;/em&gt; 대리석 다이어그램 &lt;em&gt;을&lt;/em&gt; 안정적으로 사용할 수 없습니다 . 다른 스케줄링 방법은 가상화되지 않았거나 TestScheduler에 알려지지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e8f64885951634f31a84994c2ad579ee912cd26e" translate="yes" xml:space="preserve">
          <source>If you have installed &lt;code&gt;rxjs-compat&lt;/code&gt;, there are only two breaking changes that you might need to address immediately.</source>
          <target state="translated">&lt;code&gt;rxjs-compat&lt;/code&gt; 를 설치 한 경우 즉시 해결해야 할 두 가지 주요 변경 사항 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="9392292c8ce329d2c59bb25843c4bd27a5cd47c1" translate="yes" xml:space="preserve">
          <source>If you have more complex logic that requires decision between more than two Observables, &lt;a href=&quot;defer&quot;&gt;&lt;code&gt;defer&lt;/code&gt;&lt;/a&gt; will probably be a better choice. Actually &lt;code&gt;iif&lt;/code&gt; can be easily implemented with &lt;a href=&quot;defer&quot;&gt;&lt;code&gt;defer&lt;/code&gt;&lt;/a&gt; and exists only for convenience and readability reasons.</source>
          <target state="translated">둘 이상의 Observable간에 결정이 필요한 더 복잡한 논리가있는 경우 &lt;a href=&quot;defer&quot;&gt; &lt;code&gt;defer&lt;/code&gt; &lt;/a&gt; 이 더 나은 선택 일 수 있습니다. 실제로 &lt;code&gt;iif&lt;/code&gt; 는 쉽게 구현할 수 있습니다&lt;a href=&quot;defer&quot;&gt; &lt;code&gt;defer&lt;/code&gt; &lt;/a&gt;편의성과 가독성을 위해서만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="e5dd67de623021f1d498a36750dcf6c79d4e0143" translate="yes" xml:space="preserve">
          <source>If you just want to &quot;defer&quot; task, that is to perform it right after currently executing synchronous code ends (commonly achieved by &lt;code&gt;setTimeout(deferredTask, 0)&lt;/code&gt;), better choice will be the &lt;a href=&quot;asapscheduler&quot;&gt;&lt;code&gt;asap&lt;/code&gt;&lt;/a&gt; scheduler.</source>
          <target state="translated">작업을 &quot;지연&quot;하려는 경우, 즉 현재 실행중인 동기 코드 종료 직후 수행 (일반적으로 &lt;code&gt;setTimeout(deferredTask, 0)&lt;/code&gt; )하려는 경우 더 나은 선택이&lt;a href=&quot;asapscheduler&quot;&gt; &lt;code&gt;asap&lt;/code&gt; &lt;/a&gt; 스케줄러를.</target>
        </trans-unit>
        <trans-unit id="5a9a1fa1312c35ddac86b41c30d41c3f5e594c2e" translate="yes" xml:space="preserve">
          <source>If you need access to all event handler parameters (not only the first one), or you need to transform them in any way, you can call &lt;code&gt;fromEventPattern&lt;/code&gt; with optional third parameter - project function which will accept all arguments passed to event handler when it is called. Whatever is returned from project function will appear on resulting stream instead of usual event handlers first argument. This means that default project can be thought of as function that takes its first parameter and ignores the rest.</source>
          <target state="translated">모든 이벤트 핸들러 매개 변수 (첫 번째 매개 변수뿐만 아니라)에 액세스해야하거나 어떤 방식 으로든 변환해야하는 경우, &lt;code&gt;fromEventPattern&lt;/code&gt; 경우 선택적 세 번째 매개 변수 (프로젝트 함수가 이벤트 핸들러에 전달 된 모든 인수를 승인 함)를 사용 하여 fromEventPattern 을 전화했다. 프로젝트 함수에서 반환되는 것은 일반적인 이벤트 처리기의 첫 번째 인수 대신 결과 스트림에 나타납니다. 즉, 기본 프로젝트는 첫 번째 매개 변수를 사용하고 나머지는 무시하는 함수로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bdbac235dd8a8f9129b495ef4e47c6d79c2d5d4" translate="yes" xml:space="preserve">
          <source>If you pass a dictionary of observables to the operator, resulting objects will have the same keys as the dictionary passed, with their last values they've emitted located at the corresponding key.</source>
          <target state="translated">Observable 사전을 연산자에게 전달하면 결과 객체는 사전에 전달 된 것과 동일한 키를 가지며, 마지막으로 생성 한 값이 해당 키에 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d837f1f500cd898bebd92644c0fcb4ec5f7fcb7" translate="yes" xml:space="preserve">
          <source>If you pass an array of &lt;code&gt;n&lt;/code&gt; observables to the operator, resulting array will have &lt;code&gt;n&lt;/code&gt; values, where first value is the last thing emitted by the first observable, second value is the last thing emitted by the second observable and so on.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 개의 관측 가능 항목 의 배열을 연산자에 전달하면 결과 배열에는 &lt;code&gt;n&lt;/code&gt; 개의 값이 있습니다. 여기서 첫 번째 값은 첫 번째 관찰 가능 항목에서 방출 한 값이고, 두 번째 값은 두 번째 관찰 가능 항목에서 생성 된 마지막 것입니다.</target>
        </trans-unit>
        <trans-unit id="ee570c9f654defeedccb901085f0bb73f4226f34" translate="yes" xml:space="preserve">
          <source>If you pass to &lt;code&gt;concat&lt;/code&gt; the same Observable many times, its stream of values will be &quot;replayed&quot; on every subscription, which means you can repeat given Observable as many times as you like. If passing the same Observable to &lt;code&gt;concat&lt;/code&gt; 1000 times becomes tedious, you can always use &lt;a href=&quot;../../operators/repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">동일한 Observable을 여러 번 &lt;code&gt;concat&lt;/code&gt; 하도록 전달하면 구독마다 값의 스트림이 &quot;재생&quot;되므로 지정된 Observable을 원하는만큼 반복 할 수 있습니다. 동일한 관찰 가능한 전달 경우 &lt;code&gt;concat&lt;/code&gt; 1000 배 지루한되고, 당신은 항상 사용할 수있는 &lt;a href=&quot;../../operators/repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4a842ea19f74aaea650d3b005c684fa452f2f03" translate="yes" xml:space="preserve">
          <source>If you receive an error like error TS2304: Cannot find name 'Promise' or error TS2304: Cannot find name 'Iterable' when using RxJS you may need to install a supplemental set of typings.</source>
          <target state="translated">오류 TS2304 : 'Promise'이름을 찾을 수 없음 또는 오류 TS2304 : RxJS를 사용할 때 'Iterable'이름을 찾을 수 없음과 같은 오류가 표시되면 보충 입력 세트를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="bc2f69f01e85bf5d619a756550c3023d53f1eb41" translate="yes" xml:space="preserve">
          <source>If you use functionality that is removed from v6, but supported by the &lt;code&gt;rxjs-compat&lt;/code&gt; package, you must refactor or rewrite code to complete the update to v6. The following areas of functionality depend on the compatibility layer:</source>
          <target state="translated">v6에서 제거되었지만 &lt;code&gt;rxjs-compat&lt;/code&gt; 패키지에서 지원되는 기능을 사용하는 경우 v6으로 의 업데이트를 완료하려면 코드를 리팩터링하거나 다시 작성해야합니다. 다음 기능 영역은 호환성 계층에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8115cc9902d10e9cbc721cbe7139de103776ba25" translate="yes" xml:space="preserve">
          <source>If you're a TypeScript developer, it's recommended that you use &lt;code&gt;rxjs-tslint&lt;/code&gt; to refactor your import paths.</source>
          <target state="translated">TypeScript 개발자 인 경우 &lt;code&gt;rxjs-tslint&lt;/code&gt; 를 사용 하여 가져 오기 경로를 리팩터링 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6013f20fa65ee7b571375547cde18c11a11195b9" translate="yes" xml:space="preserve">
          <source>If you're not using typings the interfaces can be copied from /es6-shim/es6-shim.d.ts.</source>
          <target state="translated">타이핑을 사용하지 않는 경우 /es6-shim/es6-shim.d.ts에서 인터페이스를 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e55924f1e55081fa0d810b45171dfff9935a10b9" translate="yes" xml:space="preserve">
          <source>If your app is affected by the few &lt;a href=&quot;migration#breaking-changes&quot;&gt;breaking changes&lt;/a&gt; not covered by &lt;code&gt;rxjs-compat&lt;/code&gt;, update the affected code according to the instructions provided below.</source>
          <target state="translated">&lt;code&gt;rxjs-compat&lt;/code&gt; 에서 다루지 않는 몇 가지 &lt;a href=&quot;migration#breaking-changes&quot;&gt;주요 변경 사항으로&lt;/a&gt; 앱이 영향을 받는 경우 아래 지침에 따라 영향을받는 코드를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="a25eefd9034a0248cd7ddd31d1d8d721666b3a11" translate="yes" xml:space="preserve">
          <source>IfObservable</source>
          <target state="translated">IfObservable</target>
        </trans-unit>
        <trans-unit id="a71757c57da2855a990877a7134d7fa854f423d4" translate="yes" xml:space="preserve">
          <source>Ignore every 3rd click event, starting from the first one</source>
          <target state="translated">첫 번째 클릭부터 시작하여 모든 세 번째 클릭 이벤트를 무시</target>
        </trans-unit>
        <trans-unit id="fa4d2cc45a3baa30509775b1cb451f0bae0f04ac" translate="yes" xml:space="preserve">
          <source>Ignore every 3rd click event, starting from the third one</source>
          <target state="translated">세 번째 클릭부터 시작하여 모든 세 번째 클릭 이벤트를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="c30072d05b38673f5eb2d636804574de2101d7e1" translate="yes" xml:space="preserve">
          <source>Ignores all items emitted by the source Observable and only passes calls of &lt;code&gt;complete&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;.</source>
          <target state="translated">소스 Observable이 방출 한 모든 항목을 무시하고 &lt;code&gt;complete&lt;/code&gt; 또는 &lt;code&gt;error&lt;/code&gt; 호출 만 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="40e5987468ce7f856e1a72614ed4dc8bef08b57f" translate="yes" xml:space="preserve">
          <source>Ignores emitted values, reacts to observable's completion.</source>
          <target state="translated">방출 된 값을 무시하고 관찰 가능 완료에 반응합니다.</target>
        </trans-unit>
        <trans-unit id="70355e794eb2aafb77d98edb0d89a6e944d813ad" translate="yes" xml:space="preserve">
          <source>Ignores source values for &lt;code&gt;duration&lt;/code&gt; milliseconds, then emits the most recent value from the source Observable, then repeats this process.</source>
          <target state="translated">&lt;code&gt;duration&lt;/code&gt; 밀리 초) 동안 소스 값을 무시한 다음 소스 Observable에서 가장 최근 값을 방출 한 다음이 프로세스를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="529d2ea415ea19d29423e03ad35a1b7fa6aec7f7" translate="yes" xml:space="preserve">
          <source>Ignores source values for a duration determined by another Observable, then emits the most recent value from the source Observable, then repeats this process.</source>
          <target state="translated">다른 Observable에 의해 결정된 지속 기간 동안 소스 값을 무시한 다음 소스 Observable에서 가장 최근 값을 내 보낸 다음이 프로세스를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="a40044f6794fce3bb8fd5737e1d66787d43844de" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;../interface/observer&quot;&gt;&lt;code&gt;Observer&lt;/code&gt;&lt;/a&gt; interface and extends the &lt;a href=&quot;subscription&quot;&gt;&lt;code&gt;Subscription&lt;/code&gt;&lt;/a&gt; class. While the &lt;a href=&quot;../interface/observer&quot;&gt;&lt;code&gt;Observer&lt;/code&gt;&lt;/a&gt; is the public API for consuming the values of an &lt;a href=&quot;observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;, all Observers get converted to a Subscriber, in order to provide Subscription-like capabilities such as &lt;code&gt;unsubscribe&lt;/code&gt;. Subscriber is a common type in RxJS, and crucial for implementing operators, but it is rarely used as a public API.</source>
          <target state="translated">&lt;a href=&quot;../interface/observer&quot;&gt; &lt;code&gt;Observer&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하고 &lt;a href=&quot;subscription&quot;&gt; &lt;code&gt;Subscription&lt;/code&gt; &lt;/a&gt; 클래스를 확장합니다 . 그동안 &lt;a href=&quot;../interface/observer&quot;&gt; &lt;code&gt;Observer&lt;/code&gt; &lt;/a&gt; 의 값 소모에 대한 공용 API입니다 &lt;a href=&quot;observable&quot;&gt; &lt;code&gt;Observable&lt;/code&gt; &lt;/a&gt; , 모든 관찰자 구독과 같은 기능 등 제공하기 위해 가입자로 변환됩니다 &lt;code&gt;unsubscribe&lt;/code&gt; . 구독자는 RxJS의 일반적인 유형이며 연산자 구현에 중요하지만 공용 API로는 거의 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22a882e9f78320d3f6a26b70debc5504cfb608e8" translate="yes" xml:space="preserve">
          <source>Import paths</source>
          <target state="translated">가져 오기 경로</target>
        </trans-unit>
        <trans-unit id="d78821ba5d868d9a31095edd36e64f53ec95ec9b" translate="yes" xml:space="preserve">
          <source>Import paths have changed.</source>
          <target state="translated">가져 오기 경로가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="604c5adf7e512895ef3206a2a38925fde75adbf4" translate="yes" xml:space="preserve">
          <source>In JavaScript runtimes that support &lt;code&gt;Set&lt;/code&gt;, this operator will use a &lt;code&gt;Set&lt;/code&gt; to improve performance of the distinct value checking.</source>
          <target state="translated">&lt;code&gt;Set&lt;/code&gt; 를 지원하는 JavaScript 런타임 에서이 연산자는 &lt;code&gt;Set&lt;/code&gt; 을 사용 하여 고유 한 값 검사의 성능을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="e5195133f63632cc13452c63ce186838089e5949" translate="yes" xml:space="preserve">
          <source>In RxJS v5.x, a number of operators have an optional resultSelector argument, in which you can pass a function for handling the result of the operations.</source>
          <target state="translated">RxJS v5.x에서 다수의 연산자에는 선택적 resultSelector 인수가 있으며,이를 통해 조작 결과를 처리하기위한 함수를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ed98d14e00fa6f78e3945d35bbdbe8132e2ecd9" translate="yes" xml:space="preserve">
          <source>In RxJS v6.x, UMD module name has been changed from Rx to rxjs so that it's align with other imports module name.</source>
          <target state="translated">RxJS v6.x에서 UMD 모듈 이름이 Rx에서 rxjs로 변경되어 다른 가져 오기 모듈 이름과 정렬되었습니다.</target>
        </trans-unit>
        <trans-unit id="9f5e3817dd59d2b07ee7cbf50ed5e3af33894a40" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.3 and lower, typings will need to be added to functions passed to operators, as types cannot be inferred prior to TypeScript 2.4. In TypeScript 2.4, types will infer via composition properly.</source>
          <target state="translated">TypeScript 2.3 이하에서는 TypeScript 2.4 이전에 유형을 유추 할 수 없으므로 연산자에 전달 된 함수에 입력을 추가해야합니다. TypeScript 2.4에서는 형식이 컴포지션을 통해 올바르게 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="09c23a7addb52527b7cdfb469f68066abf364c42" translate="yes" xml:space="preserve">
          <source>In a marble diagram, time flows to the right, and the diagram describes how values (&quot;marbles&quot;) are emitted on the Observable execution.</source>
          <target state="translated">대리석 다이어그램에서 시간은 오른쪽으로 흐르고 다이어그램은 Observable 실행에서 값 ( &quot;대리석&quot;)이 생성되는 방식을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fb16cf9ddcefacd27292666512786e6449d62f05" translate="yes" xml:space="preserve">
          <source>In an Observable Execution, zero to infinite Next notifications may be delivered. If either an Error or Complete notification is delivered, then nothing else can be delivered afterwards.</source>
          <target state="translated">Observable Execution에서는 0에서 무한한 Next 알림이 전달 될 수 있습니다. 오류 또는 완료 알림이 전달되면 이후에는 다른 것을 전달할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6c035b77c3b045a395fde85eddc3bc476a772acf" translate="yes" xml:space="preserve">
          <source>In both &lt;code&gt;hot&lt;/code&gt; and &lt;code&gt;cold&lt;/code&gt; methods, value characters specified in marble diagrams are emitted as strings unless a &lt;code&gt;values&lt;/code&gt; argument is passed to the method. Therefor:</source>
          <target state="translated">&lt;code&gt;hot&lt;/code&gt; 메소드 와 &lt;code&gt;cold&lt;/code&gt; 메소드 모두 에서 &lt;code&gt;values&lt;/code&gt; 인수가 메소드에 전달 되지 않으면 대리석 다이어그램에 지정된 값 문자가 문자열로 생성됩니다 . 그 때문에:</target>
        </trans-unit>
        <trans-unit id="295e5d256d6bbe1d0869e05b595f7b24f349478f" translate="yes" xml:space="preserve">
          <source>In every window of 1 second each, emit at most 2 click events</source>
          <target state="translated">1 초마다 모든 창에서 최대 2 개의 클릭 이벤트 발생</target>
        </trans-unit>
        <trans-unit id="c49794905cd1728d46b3103a435edb3badc67155" translate="yes" xml:space="preserve">
          <source>In functions that have the resultSelector parameter, the parameters have been deprecated in most cases, and removed for two functions. The ones that have been removed must be updated before you can remove the compatibility layer.</source>
          <target state="translated">resultSelector 매개 변수가있는 함수에서는 대부분의 경우 매개 변수가 더 이상 사용되지 않으며 두 가지 함수에서 제거되었습니다. 호환성 계층을 제거하려면 먼저 제거 된 항목을 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="e1fd85e3cd2bf300851eee6724b69f0c2ea88b01" translate="yes" xml:space="preserve">
          <source>In most tests it will be unnecessary to test subscription and unsubscription points, being either obvious or implied from the &lt;code&gt;expected&lt;/code&gt; diagram. In those cases do not write subscription assertions. In test cases that have inner subscriptions or cold observables with multiple subscribers, these subscription assertions can be useful.</source>
          <target state="translated">대부분의 테스트에서 &lt;code&gt;expected&lt;/code&gt; 다이어그램 에서 명백하거나 암시 된 구독 및 구독 취소 지점을 테스트 할 필요가 없습니다 . 이 경우 구독 어설 션을 쓰지 마십시오. 내부 구독 또는 여러 구독자가있는 콜드 옵저버 블이있는 테스트 사례에서 이러한 구독 어설 션이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aec95503709d60cd6d6b2ee3ce1d30d30b825fd7" translate="yes" xml:space="preserve">
          <source>In order for resulting array to have the same length as the number of input observables, whenever any of that observables completes without emitting any value, &lt;code&gt;forkJoin&lt;/code&gt; will complete at that moment as well and it will not emit anything either, even if it already has some last values from other observables. Conversely, if there is an observable that never completes, &lt;code&gt;forkJoin&lt;/code&gt; will never complete as well, unless at any point some other observable completes without emitting value, which brings us back to the previous case. Overall, in order for &lt;code&gt;forkJoin&lt;/code&gt; to emit a value, all observables passed as arguments have to emit something at least once and complete.</source>
          <target state="translated">결과 배열이 입력 관찰 가능 개수와 동일한 길이를 갖도록하기 위해, 해당 관찰 가능 값이 값을 &lt;code&gt;forkJoin&lt;/code&gt; 하지 않고 완료 될 때마다 forkJoin 은 그 순간에도 완료되며 이미 일부를 가지고 있어도 아무 것도 방출하지 않습니다. 다른 관측 가능한 값의 마지막 값. 반대로, 완료 할 수없는 관찰 가능 항목이있는 경우, 어떤 시점에서 다른 관찰 가능 값이 값을 방출하지 않고 완료되어 이전 사례로 돌아 가지 않는 한 &lt;code&gt;forkJoin&lt;/code&gt; 도 완료되지 않습니다. 전체적으로, &lt;code&gt;forkJoin&lt;/code&gt; 이 값 을 생성 하기 위해서는 인수로 전달 된 모든 관찰 가능 항목이 적어도 한 번 이상 무언가를 방출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a45eba608694af1c74ee2e9386099587189e2989" translate="yes" xml:space="preserve">
          <source>In order to minimize the impact of the upgrade, RxJS v6 releases with a sibling package, &lt;code&gt;rxjs-compat&lt;/code&gt;, which provides a compatibility layer between the v6 and v5 APIs. Most developers with existing applications should upgrade by installing both &lt;code&gt;rxjs&lt;/code&gt; and &lt;code&gt;rxjs-compat&lt;/code&gt; at ^6.0.0:</source>
          <target state="translated">업그레이드의 영향을 최소화하기 위해 RxJS v6은 &lt;code&gt;rxjs-compat&lt;/code&gt; 형제 패키지와 함께 출시되어 v6과 v5 API 간의 호환성 계층을 제공합니다. 기존 응용 프로그램을 보유한 대부분의 개발자는 &lt;code&gt;rxjs&lt;/code&gt; 와 &lt;code&gt;rxjs-compat&lt;/code&gt; 를 모두 ^ 6.0.0 에 설치하여 업그레이드해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fe403bd5e814fd0d03b717695065a0f083c8e78f" translate="yes" xml:space="preserve">
          <source>In order to use the new pipeable operators and not gain bundle size, you will need to change your Webpack configuration. This will only work with Webpack 3+ as it relies on the new &lt;code&gt;ModuleConcatenationPlugin&lt;/code&gt; from Webpack 3.</source>
          <target state="translated">새로운 파이프 가능 연산자를 사용하고 번들 크기를 확보하지 않으려면 Webpack 구성을 변경해야합니다. 이것은 Webpack 3의 새로운 &lt;code&gt;ModuleConcatenationPlugin&lt;/code&gt; 에 의존하기 때문에 Webpack 3 이상에서만 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="3d435e3fa3d8d13c3292375c9df88ca4214ee5db" translate="yes" xml:space="preserve">
          <source>In other runtimes, this operator will use a minimal implementation of &lt;code&gt;Set&lt;/code&gt; that relies on an &lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;indexOf&lt;/code&gt; under the hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running &lt;code&gt;distinct&lt;/code&gt; use might result in memory leaks. To help alleviate this in some scenarios, an optional &lt;code&gt;flushes&lt;/code&gt; parameter is also provided so that the internal &lt;code&gt;Set&lt;/code&gt; can be &quot;flushed&quot;, basically clearing it of values.</source>
          <target state="translated">다른 런타임에서이 연산자는 후드 아래에서 &lt;code&gt;Array&lt;/code&gt; 및 &lt;code&gt;indexOf&lt;/code&gt; 에 의존 하는 최소한의 &lt;code&gt;Set&lt;/code&gt; 구현을 사용 하므로 더 많은 값이 구별되는지 확인하면 성능이 저하됩니다. 심지어 새로운 브라우저에서, 장기 실행 &lt;code&gt;distinct&lt;/code&gt; 사용은 메모리 누수가 발생할 수 있습니다. 일부 시나리오에서이를 완화하기 위해 내부 &lt;code&gt;Set&lt;/code&gt; 을 &quot;플러시&quot;하여 기본적으로 값을 지우 도록 선택적 &lt;code&gt;flushes&lt;/code&gt; 매개 변수도 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="768c1eec37c4aabe5ab384f41143b24385fc36f4" translate="yes" xml:space="preserve">
          <source>In some APIs unregistering is actually handled differently. Method registering an event handler returns some kind of token, which is later used to identify which function should be unregistered or it itself has method that unregisters event handler. If that is the case with your API, make sure token returned by registering method is returned by &lt;code&gt;addHandler&lt;/code&gt;. Then it will be passed as a second argument to &lt;code&gt;removeHandler&lt;/code&gt;, where you will be able to use it.</source>
          <target state="translated">일부 API에서는 등록 해제가 실제로 다르게 처리됩니다. 이벤트 핸들러를 등록하는 메소드는 일종의 토큰을 리턴하는데, 이는 나중에 등록 해제해야 할 함수를 식별하는 데 사용되거나 자체적으로 이벤트 핸들러를 등록 해제하는 메소드를 갖습니다. API에 해당하는 경우, 등록 메소드에 의해 리턴 된 토큰이 &lt;code&gt;addHandler&lt;/code&gt; 에 의해 리턴되는지 확인하십시오 . 그런 다음 &lt;code&gt;removeHandler&lt;/code&gt; 의 두 번째 인수로 전달되어 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31cb9789c815a7a8a9b3a98df002734fb61392f8" translate="yes" xml:space="preserve">
          <source>In the above situation we need the observable stream to complete so that we can test the variable was set to the correct value. The TestScheduler runs in 'virtual time' (synchronously), but doesn't normally run (and complete) until the testScheduler callback returns. The flush() method manually triggers the virtual time so that we can test the local variable after the observable completes.</source>
          <target state="translated">위 상황에서 변수가 올바른 값으로 설정되었는지 테스트 할 수 있도록 관찰 가능한 스트림이 필요합니다. TestScheduler는 '가상 시간'(동기식)으로 실행되지만 testScheduler 콜백이 리턴 될 때까지 정상적으로 실행 (및 완료)되지 않습니다. flush () 메소드는 가상 시간을 수동으로 트리거하므로 관찰 가능 완료 후 로컬 변수를 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d19c3b25e6f5d0f4dceb81b95a860d7b023fe387" translate="yes" xml:space="preserve">
          <source>In the browser, &lt;code&gt;addEventListener&lt;/code&gt; accepts - apart from event type string and event handler function arguments - optional third parameter, which is either an object or boolean, both used for additional configuration how and when passed function will be called. When &lt;code&gt;fromEvent&lt;/code&gt; is used with event target of that type, you can provide this values as third parameter as well.</source>
          <target state="translated">브라우저에서 &lt;code&gt;addEventListener&lt;/code&gt; 는 이벤트 유형 문자열 및 이벤트 핸들러 함수 인수와는 별개로 선택적 세 번째 매개 변수 (객체 또는 부울)를 전달합니다.이 매개 변수는 전달 된 함수의 호출 방법 및시기에 추가 구성에 사용됩니다. 때 &lt;code&gt;fromEvent&lt;/code&gt; 가 해당 유형의 이벤트 대상에 사용됩니다, 당신은뿐만 아니라 세 번째 매개 변수로이 값을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d611fc72a1a0461578e38fb87221937cf83ac16c" translate="yes" xml:space="preserve">
          <source>In the context of TestScheduler, a marble diagram is a string containing special syntax representing events happening over virtual time. Time progresses by &lt;em&gt;frames&lt;/em&gt;. The first character of any marble string always represents the &lt;em&gt;zero frame&lt;/em&gt;, or the start of time. Inside of &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; the frameTimeFactor is set to 1, which means one frame is equal to one virtual millisecond.</source>
          <target state="translated">TestScheduler의 맥락에서 대리석 다이어그램은 가상 시간에 발생하는 이벤트를 나타내는 특수 구문이 포함 된 문자열입니다. &lt;em&gt;프레임&lt;/em&gt; 별로 시간이 진행됩니다 . 모든 대리석 문자열의 첫 문자는 항상 &lt;em&gt;제로 프레임&lt;/em&gt; 또는 시작 시간을 나타냅니다 . 내부 &lt;code&gt;testScheduler.run(callback)&lt;/code&gt; frameTimeFactor 1 프레임은 하나의 가상 밀리 동일한 수단 (1)로 설정된다.</target>
        </trans-unit>
        <trans-unit id="9e61d0bd368bc24118ba8a711748b25b10256924" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;subscribe&lt;/code&gt; function is the most important piece to describe the Observable. Let's look at what subscribing means.</source>
          <target state="translated">위의 예에서 &lt;code&gt;subscribe&lt;/code&gt; 함수는 Observable을 설명하는 가장 중요한 부분입니다. 구독이 무엇을 의미하는지 봅시다.</target>
        </trans-unit>
        <trans-unit id="2d66b1569870cda1caa7fda5b5781d96cf478a71" translate="yes" xml:space="preserve">
          <source>In the example below, we have two Observers attached to a Subject, and we feed some values to the Subject:</source>
          <target state="translated">아래 예에서는 주제에 두 개의 관찰자가 첨부되어 있으며 주제에 일부 값을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ab82f1f7a93e0c1d53bf67dd2a2293a5337f6463" translate="yes" xml:space="preserve">
          <source>In the example below, we take the usual simple Observable that emits values &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; synchronously, and use the operator &lt;code&gt;observeOn&lt;/code&gt; to specify the &lt;code&gt;async&lt;/code&gt; scheduler to use for delivering those values.</source>
          <target state="translated">아래 예에서는 값 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt; 을 동 기적으로 방출하는 일반적인 간단한 Observable을 가져 &lt;code&gt;observeOn&lt;/code&gt; 연산자 를 사용하여 해당 값을 전달하는 데 사용할 &lt;code&gt;async&lt;/code&gt; 스케줄러를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e820ca5df78d6c0c13eb499231cccdc5f101da8d" translate="yes" xml:space="preserve">
          <source>In the following example there are two intervals turned into connectable observables by using the &lt;em&gt;publish&lt;/em&gt; operator. The first one uses the &lt;em&gt;refCount&lt;/em&gt; operator, the second one does not use it. You will notice that a connectable observable does nothing until you call its connect function.</source>
          <target state="translated">다음 예제에서는 &lt;em&gt;publish&lt;/em&gt; 연산자 를 사용하여 두 개의 간격을 연결 가능한 관찰 가능으로 설정했습니다 . 첫 번째는 &lt;em&gt;refCount&lt;/em&gt; 연산자를 사용하고 두 번째 는 &lt;em&gt;refCount&lt;/em&gt; 연산자를 사용하지 않습니다. connectable observable은 connect 함수를 호출 할 때까지 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0552027c5d9b9c65f728320bf4fafca352e42373" translate="yes" xml:space="preserve">
          <source>In the following example, all emitted values ​​of the interval observable are skipped until the user clicks anywhere within the page.</source>
          <target state="translated">다음 예제에서 관찰 가능한 간격의 방출 된 모든 값은 사용자가 페이지 내의 아무 곳이나 클릭 할 때까지 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="efee9e2790f7d7f99cf98470cbc85b870bc2c30d" translate="yes" xml:space="preserve">
          <source>In the following example, the BehaviorSubject is initialized with the value &lt;code&gt;0&lt;/code&gt; which the first Observer receives when it subscribes. The second Observer receives the value &lt;code&gt;2&lt;/code&gt; even though it subscribed after the value &lt;code&gt;2&lt;/code&gt; was sent.</source>
          <target state="translated">다음 예에서 BehaviorSubject는 구독 할 때 첫 번째 관찰자가받는 값 &lt;code&gt;0&lt;/code&gt; 으로 초기화됩니다 . 두 번째 옵저버는 값 &lt;code&gt;2&lt;/code&gt; 가 전송 된 후에 구독하더라도 값 &lt;code&gt;2&lt;/code&gt; 를 받습니다 .</target>
        </trans-unit>
        <trans-unit id="8ee442c5a6c2ae9c1636bfba12a54be8b0e91b7b" translate="yes" xml:space="preserve">
          <source>In this example there is a timestamp attached to the documents click event.</source>
          <target state="translated">이 예에서는 문서 클릭 이벤트에 첨부 된 타임 스탬프가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b43a6d6f344b089c30152a966852ef922f720b7" translate="yes" xml:space="preserve">
          <source>Initial state.</source>
          <target state="translated">초기 상태.</target>
        </trans-unit>
        <trans-unit id="b2a80b44b4811d2384ef831fa8087b37898d084c" translate="yes" xml:space="preserve">
          <source>Input Observables to merge together.</source>
          <target state="translated">함께 병합 할 Observable을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="2f07bb68f696a1f9376f7eac1c90eada31549502" translate="yes" xml:space="preserve">
          <source>Install RxJS v6 along with the &lt;a href=&quot;migration#backwards-compatibility&quot;&gt;backward-compatibility&lt;/a&gt; package, &lt;code&gt;rxjs-compat&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;migration#backwards-compatibility&quot;&gt;이전 버전과의 호환성&lt;/a&gt; 패키지 인 &lt;code&gt;rxjs-compat&lt;/code&gt; 와 함께 RxJS v6을 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="550c70d12638cfa6aa8f9e73e5ae88f8cbc4e453" translate="yes" xml:space="preserve">
          <source>Installation Instructions</source>
          <target state="translated">설치 방법</target>
        </trans-unit>
        <trans-unit id="65ec13dada396444df2fea802736eaf9062f72a3" translate="yes" xml:space="preserve">
          <source>Intercepts each emission on the source and runs a function, but returns an output which is identical to the source as long as errors don't occur.</source>
          <target state="translated">소스의 각 방출을 가로 채서 함수를 실행하지만 오류가 발생하지 않는 한 소스와 동일한 출력을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fb09c60d73f84a6357255306df1f745b4014fb6b" translate="yes" xml:space="preserve">
          <source>Internal implementation detail, do not use directly.</source>
          <target state="translated">내부 구현 세부 사항, 직접 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="05fd7d31eb579f2cd61b47be24e926bade2627fd" translate="yes" xml:space="preserve">
          <source>Internally it counts the subscriptions to the observable and subscribes (only once) to the source if the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it unsubscribes from the source. This way you can make sure that everything before the &lt;em&gt;published&lt;/em&gt; refCount has only a single subscription independently of the number of subscribers to the target observable.</source>
          <target state="translated">내부적으로는 관찰 가능 수에 대한 구독 수를 계산하고 구독 수가 0보다 큰 경우 소스를 한 번만 구독합니다. 구독 수가 1보다 작 으면 원본에서 구독을 취소합니다. 이렇게하면 &lt;em&gt;게시 된&lt;/em&gt; refCount 이전의 모든 대상에 대상 관찰 가능 구독자 수와 관계없이 단일 구독 만 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aaa8e0fc940297bcdab02842e2a5147eec870040" translate="yes" xml:space="preserve">
          <source>Internally the &lt;code&gt;skipUntil&lt;/code&gt; operator subscribes to the passed in observable (in the following called &lt;em&gt;notifier&lt;/em&gt;) in order to recognize the emission of its first value. When this happens, the operator unsubscribes from the &lt;em&gt;notifier&lt;/em&gt; and starts emitting the values of the &lt;em&gt;source&lt;/em&gt; observable. It will never let the &lt;em&gt;source&lt;/em&gt; observable emit any values if the &lt;em&gt;notifier&lt;/em&gt; completes or throws an error without emitting a value before.</source>
          <target state="translated">내부적으로 &lt;code&gt;skipUntil&lt;/code&gt; 연산자 는 첫 번째 값의 방출을 인식하기 위해 전달 된 observable (다음 &lt;em&gt;notifier&lt;/em&gt; )을 구독 합니다. 이 경우 운영자는 &lt;em&gt;알리미&lt;/em&gt; 에서 구독을 취소하고 관찰 가능한 &lt;em&gt;소스&lt;/em&gt; 값을 방출하기 시작합니다 . 그것은시키지 않을 것입니다 &lt;em&gt;소스&lt;/em&gt; 경우 관찰되는 발광 어떤 값을 &lt;em&gt;통지의&lt;/em&gt; 완료 또는 이전 값을 방출하지 않고 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8a7007ce84b08e270eeaa49d4929b8f2489cac28" translate="yes" xml:space="preserve">
          <source>Internally to the Subject, &lt;code&gt;subscribe&lt;/code&gt; does not invoke a new execution that delivers values. It simply registers the given Observer in a list of Observers, similarly to how &lt;code&gt;addListener&lt;/code&gt; usually works in other libraries and languages.</source>
          <target state="translated">주제 내부에서 &lt;code&gt;subscribe&lt;/code&gt; 는 값을 전달하는 새 실행을 호출하지 않습니다. &lt;code&gt;addListener&lt;/code&gt; 가 일반적으로 다른 라이브러리 및 언어에서 작동 하는 방식과 유사하게 지정된 Observer를 Observers 목록에 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="24accef6c599f78a54078eab954e8eaa64e50ddd" translate="yes" xml:space="preserve">
          <source>InteropObservable</source>
          <target state="translated">InteropObservable</target>
        </trans-unit>
        <trans-unit id="2137906387d8cc5b016d85b0a13be63dbc02c890" translate="yes" xml:space="preserve">
          <source>Interval at which to start a new buffer. For example if &lt;code&gt;startBufferEvery&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;, then a new buffer will be started on every other value from the source. A new buffer is started at the beginning of the source by default.</source>
          <target state="translated">새 버퍼를 시작하는 간격입니다. 예를 들어 &lt;code&gt;startBufferEvery&lt;/code&gt; 가 &lt;code&gt;2&lt;/code&gt; 인 경우 소스의 다른 모든 값에서 새 버퍼가 시작됩니다. 새 버퍼는 기본적으로 소스 시작 부분에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="099ee7f53a8b8a0c2b710920d86de6469411ddbb" translate="yes" xml:space="preserve">
          <source>Interval at which to start a new window. For example if &lt;code&gt;startWindowEvery&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;, then a new window will be started on every other value from the source. A new window is started at the beginning of the source by default.</source>
          <target state="translated">새 창을 시작하는 간격입니다. 예를 들어 &lt;code&gt;startWindowEvery&lt;/code&gt; 가 &lt;code&gt;2&lt;/code&gt; 인 경우 소스의 다른 모든 값에서 새 창이 시작됩니다. 기본적으로 소스 시작 부분에 새 창이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="cf4da275720c283107736e8fa280351990f16a51" translate="yes" xml:space="preserve">
          <source>IntervalObservable</source>
          <target state="translated">IntervalObservable</target>
        </trans-unit>
        <trans-unit id="c36e44208f62181f22b4bcd7126f50a720e594e1" translate="yes" xml:space="preserve">
          <source>Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.</source>
          <target state="translated">Observable의 실행을 호출하고 발생하는 알림에 대해 Observer 핸들러를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="9d3ed26be15137921010183c814a29d964162f2d" translate="yes" xml:space="preserve">
          <source>Is the number &lt;code&gt;i&lt;/code&gt; for the i-th source emission that has happened since the subscription, starting from the number &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">구독 이후 발생한 i 번째 소스 방출 의 숫자 &lt;code&gt;i&lt;/code&gt; 는 숫자 &lt;code&gt;0&lt;/code&gt; 부터 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="97ed0bfaa76c328255273846366b63dd8bec2bd0" translate="yes" xml:space="preserve">
          <source>It creates an observable for an Ajax request with either a request object with url, headers, etc or a string for a URL.</source>
          <target state="translated">URL, 헤더 등이 포함 된 요청 객체 또는 URL 문자열을 사용하여 Ajax 요청에 대한 관찰 가능 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0db1e53616a29e5e2b418755002a34b4586aae8c" translate="yes" xml:space="preserve">
          <source>It defines a set of properties to provide custom behavior in specific moments of the socket's lifecycle. When the connection opens we can use &lt;code&gt;openObserver&lt;/code&gt;, when the connection is closed &lt;code&gt;closeObserver&lt;/code&gt;, if we are interested in listening for data comming from server: &lt;code&gt;deserializer&lt;/code&gt;, which allows us to customize the deserialization strategy of data before passing it to the socket client. By default &lt;code&gt;deserializer&lt;/code&gt; is going to apply &lt;code&gt;JSON.parse&lt;/code&gt; to each message comming from the Server.</source>
          <target state="translated">소켓 수명주기의 특정 순간에 사용자 정의 동작을 제공하기 위해 특성 세트를 정의합니다. 연결이 우리가 사용할 수있는 열리면 &lt;code&gt;openObserver&lt;/code&gt; 를 연결이 닫힐 때, &lt;code&gt;closeObserver&lt;/code&gt; : 우리가 서버에서 오는 데이터를 수신에 관심이 있다면, &lt;code&gt;deserializer&lt;/code&gt; 우리가 소켓 클라이언트에 전달하기 전에 데이터의 직렬화 전략을 사용자 정의 할 수 있습니다. 기본적으로 &lt;code&gt;deserializer&lt;/code&gt; 는 서버에서 오는 각 메시지에 &lt;code&gt;JSON.parse&lt;/code&gt; 를 적용 합니다.</target>
        </trans-unit>
        <trans-unit id="bd607bfeb0a8c9ef7622b42ffa771561bde8a17d" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;very important&lt;/strong&gt; to remember that input function &lt;code&gt;func&lt;/code&gt; is not called when the output function is, but rather when the Observable returned by the output function is subscribed. This means if &lt;code&gt;func&lt;/code&gt; makes an AJAX request, that request will be made every time someone subscribes to the resulting Observable, but not before.</source>
          <target state="translated">입력 함수 &lt;code&gt;func&lt;/code&gt; 는 출력 함수가 호출 될 때가 아니라 출력 함수가 반환 한 Observable이 구독 될 때 호출 된다는 것을 기억하는 것이 &lt;strong&gt;매우 중요&lt;/strong&gt; 합니다 . 이는 &lt;code&gt;func&lt;/code&gt; 이 AJAX 요청을하는 경우 누군가가 결과 Observable에 가입 ​​할 때마다 요청되지만 이전에는 요청되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="38a279bd2826e12e3145c4d6fbc3b6abb46c6bdb" translate="yes" xml:space="preserve">
          <source>It is a good idea to wrap any code in &lt;code&gt;subscribe&lt;/code&gt; with &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; block that will deliver an Error notification if it catches an exception:</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 블록을 &lt;code&gt;subscribe&lt;/code&gt; 하여 코드를 래핑 하여 예외를 발견하면 오류 알림을 전달하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b9794570cb14fba1d1e1d2d489f15060023fbee9" translate="yes" xml:space="preserve">
          <source>It is more complicated, but if you have to write an operator that cannot be made from a combination of existing operators (a rare occurrance), you can write an operator from scratch using the Observable constructor, like this:</source>
          <target state="translated">더 복잡하지만 기존 연산자의 조합으로 만들 수없는 연산자 (드문 발생)를 작성해야하는 경우 Observable 생성자를 사용하여 다음과 같이 처음부터 연산자를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cdb922439d8586a691049b40d1a49708c3bd2ec" translate="yes" xml:space="preserve">
          <source>It is not a coincidence that &lt;code&gt;observable.subscribe&lt;/code&gt; and &lt;code&gt;subscribe&lt;/code&gt; in &lt;code&gt;new Observable(function subscribe(subscriber) {...})&lt;/code&gt; have the same name. In the library, they are different, but for practical purposes you can consider them conceptually equal.</source>
          <target state="translated">&lt;code&gt;new Observable(function subscribe(subscriber) {...})&lt;/code&gt; 에서 &lt;code&gt;observable.subscribe&lt;/code&gt; 와 &lt;code&gt;subscribe&lt;/code&gt; 가 동일한 이름을 갖는 것은 우연의 일치가 아닙니다 . 도서관에서는 그것들이 다르지만 실제적인 목적으로 그것들은 개념적으로 동등하다고 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f49f2032f83866e5a41394fb7bdc366cf78bdb9" translate="yes" xml:space="preserve">
          <source>It's a version of &lt;code&gt;timeout&lt;/code&gt; operator that let's you specify fallback Observable.</source>
          <target state="translated">폴백 옵저버 블을 지정할 수 있는 &lt;code&gt;timeout&lt;/code&gt; 연산자 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="adba087c9c9e58ee773402b9f6f601d478443832" translate="yes" xml:space="preserve">
          <source>It's just like &lt;a href=&quot;bindcallback&quot;&gt;&lt;code&gt;bindCallback&lt;/code&gt;&lt;/a&gt;, but the callback is expected to be of type &lt;code&gt;callback(error, result)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;bindcallback&quot;&gt; &lt;code&gt;bindCallback&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만 콜백은 &lt;code&gt;callback(error, result)&lt;/code&gt; 유형이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="8a949408305dcb2e7acb7e5b74339b4b8a9ea2f9" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;../../operators/filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, but returns two Observables: one like the output of &lt;a href=&quot;../../operators/filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, and the other with values that did not pass the condition.</source>
          <target state="translated">그것은처럼 &lt;a href=&quot;../../operators/filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; ,하지만 두 Observables은 반환의 출력과 같은 하나의 &lt;a href=&quot;../../operators/filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 및 조건을 통과하지 못한 값을 다른.</target>
        </trans-unit>
        <trans-unit id="df2238ba3a95389559de5a8118b9e1b31e6870d1" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;audittime&quot;&gt;&lt;code&gt;auditTime&lt;/code&gt;&lt;/a&gt;, but the silencing duration is determined by a second Observable.</source>
          <target state="translated">&lt;a href=&quot;audittime&quot;&gt; &lt;code&gt;auditTime&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만 침묵 지속 시간은 두 번째 Observable에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="c6de2f5807f7a8f592a3f85530871d0646e8235f" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;buffer&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="translated">그것은처럼 &lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;buffer&lt;/code&gt; &lt;/a&gt; , 대신 배열의 중첩 관찰 가능한을 방출한다.</target>
        </trans-unit>
        <trans-unit id="bb360af1ed3cecf856ed4ee0d48cd7d85b7a8dbf" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;buffercount&quot;&gt;&lt;code&gt;bufferCount&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="translated">&lt;a href=&quot;buffercount&quot;&gt; &lt;code&gt;bufferCount&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 배열 대신 중첩 된 Observable을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="ea49a2ff2b8a6a7fb1a2e802f2a2482ba7e26405" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;buffertime&quot;&gt;&lt;code&gt;bufferTime&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="translated">그것은처럼 &lt;a href=&quot;buffertime&quot;&gt; &lt;code&gt;bufferTime&lt;/code&gt; &lt;/a&gt; , 대신 배열의 중첩 관찰 가능한을 방출한다.</target>
        </trans-unit>
        <trans-unit id="706a3adc8ab410c897c16a98366204b1a5b1240e" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;buffertoggle&quot;&gt;&lt;code&gt;bufferToggle&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="translated">&lt;a href=&quot;buffertoggle&quot;&gt; &lt;code&gt;bufferToggle&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만 배열 대신 중첩 된 Observable을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="c558f7f5e114dacdde1f0f95f96fa4b2c26413e6" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;bufferwhen&quot;&gt;&lt;code&gt;bufferWhen&lt;/code&gt;&lt;/a&gt;, but emits a nested Observable instead of an array.</source>
          <target state="translated">&lt;a href=&quot;bufferwhen&quot;&gt; &lt;code&gt;bufferWhen&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 배열 대신 중첩 된 Observable을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="11e12fef4db4958942dc505d6a8f8247a1770fb1" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;concatmap&quot;&gt;&lt;code&gt;concatMap&lt;/code&gt;&lt;/a&gt;, but maps each value always to the same inner Observable.</source>
          <target state="translated">&lt;a href=&quot;concatmap&quot;&gt; &lt;code&gt;concatMap&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만 각 값을 항상 동일한 내부 Observable에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="e3a867c904920532b682926d9570e66b6bd84a27" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;debouncetime&quot;&gt;&lt;code&gt;debounceTime&lt;/code&gt;&lt;/a&gt;, but the time span of emission silence is determined by a second Observable.</source>
          <target state="translated">이처럼 &lt;a href=&quot;debouncetime&quot;&gt; &lt;code&gt;debounceTime&lt;/code&gt; &lt;/a&gt; 하지만 발광 침묵 시간 범위는 제 피 감시에 의해 결정된다.</target>
        </trans-unit>
        <trans-unit id="3275012c1bb12737fa3e7ae966dc46708b8e6efc" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;delay&quot;&gt;&lt;code&gt;delay&lt;/code&gt;&lt;/a&gt;, but passes only the most recent value from each burst of emissions.</source>
          <target state="translated">그것은 &lt;a href=&quot;delay&quot;&gt; &lt;code&gt;delay&lt;/code&gt; &lt;/a&gt; 와 같지만 각 배출 버스트에서 가장 최근의 값만 전달합니다.</target>
        </trans-unit>
        <trans-unit id="d6cdbfb00c44af71004ef36133f0e226b40e866d" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;delay&quot;&gt;&lt;code&gt;delay&lt;/code&gt;&lt;/a&gt;, but the time span of the delay duration is determined by a second Observable.</source>
          <target state="translated">이처럼 &lt;a href=&quot;delay&quot;&gt; &lt;code&gt;delay&lt;/code&gt; &lt;/a&gt; 되지만, 지연 시간의 시간 범위는 제 피 감시에 의해 결정된다.</target>
        </trans-unit>
        <trans-unit id="ce158c4252c2c44186bb2ae22b21fe949150e8db" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;distinctuntilchanged&quot;&gt;&lt;code&gt;distinctUntilChanged&lt;/code&gt;&lt;/a&gt;, but the distinct comparison uses a key to access a property.</source>
          <target state="translated">그것은처럼 &lt;a href=&quot;distinctuntilchanged&quot;&gt; &lt;code&gt;distinctUntilChanged&lt;/code&gt; &lt;/a&gt; 하지만 별개의 비교는 속성에 액세스 키를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5c0357dea7ccb925e323e6256fef87dc2aa65faa" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, but just emits the values that are distinct from the previous.</source>
          <target state="translated">그것은처럼 &lt;a href=&quot;filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; , 그러나 다만 이전 구별되는 값을 방출한다.</target>
        </trans-unit>
        <trans-unit id="99fd3844345480d4d64d317a7f5cce322d21307b" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, but returns two Observables: one like the output of &lt;a href=&quot;filter&quot;&gt;&lt;code&gt;filter&lt;/code&gt;&lt;/a&gt;, and the other with values that did not pass the condition.</source>
          <target state="translated">그것은처럼 &lt;a href=&quot;filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; ,하지만 두 Observables은 반환의 출력과 같은 하나의 &lt;a href=&quot;filter&quot;&gt; &lt;code&gt;filter&lt;/code&gt; &lt;/a&gt; 및 조건을 통과하지 못한 값을 다른.</target>
        </trans-unit>
        <trans-unit id="d3d241a8228a7878020999c61c552183637beb90" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but emits the index of the found value, not the value itself.</source>
          <target state="translated">그것은처럼 &lt;a href=&quot;find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt; ,하지만 발견 된 값의 인덱스 값이 아닌 자체를 방출한다.</target>
        </trans-unit>
        <trans-unit id="e351dca74c30132376a13304bc29d358d6a27d4a" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;mergemap&quot;&gt;&lt;code&gt;mergeMap&lt;/code&gt;&lt;/a&gt;, but maps each value always to the same inner Observable.</source>
          <target state="translated">&lt;a href=&quot;mergemap&quot;&gt; &lt;code&gt;mergeMap&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만 각 값을 항상 동일한 내부 Observable에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="5a2dae1b945020085aa1bdb445e10117bc9edf5c" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt;, but emits the current accumulation whenever the source emits a value.</source>
          <target state="translated">그것은처럼 &lt;a href=&quot;reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 있지만 소스가 값을 방출 할 때마다 현재의 축적을 방출한다.</target>
        </trans-unit>
        <trans-unit id="11335e7a911246f108a73bcdde65715b0a687052" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;sampletime&quot;&gt;&lt;code&gt;sampleTime&lt;/code&gt;&lt;/a&gt;, but samples whenever the &lt;code&gt;notifier&lt;/code&gt; Observable emits something.</source>
          <target state="translated">&lt;a href=&quot;sampletime&quot;&gt; &lt;code&gt;sampleTime&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만, Observable &lt;code&gt;notifier&lt;/code&gt; 무언가를 방출 할 때마다 샘플링 합니다.</target>
        </trans-unit>
        <trans-unit id="9c680229f70e56c617131cc1ad57ec227fad2968" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;scan&quot;&gt;&lt;code&gt;scan&lt;/code&gt;&lt;/a&gt;, but the Observables returned by the accumulator are merged into the outer Observable.</source>
          <target state="translated">그것은처럼 &lt;a href=&quot;scan&quot;&gt; &lt;code&gt;scan&lt;/code&gt; &lt;/a&gt; 하지만, 축적에 의해 반환 된 Observable 인은 외부 관찰 가능한에 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="91c3e182197c6bbc8865c1e13f76ab49385127db" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;switchmap&quot;&gt;&lt;code&gt;switchMap&lt;/code&gt;&lt;/a&gt;, but maps each value always to the same inner Observable.</source>
          <target state="translated">&lt;a href=&quot;switchmap&quot;&gt; &lt;code&gt;switchMap&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만 각 값을 항상 동일한 내부 Observable에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="30b32b4febb6083279feeaff98ca0e142595e8ea" translate="yes" xml:space="preserve">
          <source>It's like &lt;a href=&quot;throttletime&quot;&gt;&lt;code&gt;throttleTime&lt;/code&gt;&lt;/a&gt;, but the silencing duration is determined by a second Observable.</source>
          <target state="translated">그것은처럼 &lt;a href=&quot;throttletime&quot;&gt; &lt;code&gt;throttleTime&lt;/code&gt; &lt;/a&gt; , 그러나 침묵의 시간은 두 번째 관찰 가능한 의해 결정된다.</target>
        </trans-unit>
        <trans-unit id="8810900091c7ff83ffa55bebab9241df1287ca4d" translate="yes" xml:space="preserve">
          <source>It's similar to &lt;a href=&quot;mergemap&quot;&gt;&lt;code&gt;mergeMap&lt;/code&gt;&lt;/a&gt;, but applies the projection function to every source value as well as every output value. It's recursive.</source>
          <target state="translated">&lt;a href=&quot;mergemap&quot;&gt; &lt;code&gt;mergeMap&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만 프로젝션 함수를 모든 소스 값과 모든 출력 값에 적용합니다. 재귀 적입니다.</target>
        </trans-unit>
        <trans-unit id="dcf6717fe65da536a04da4f882bbdfa195868e09" translate="yes" xml:space="preserve">
          <source>Iteration step function.</source>
          <target state="translated">반복 단계 기능.</target>
        </trans-unit>
        <trans-unit id="2b22b7393382746b99d053013a324ab18c83302f" translate="yes" xml:space="preserve">
          <source>IteratorObservable</source>
          <target state="translated">IteratorObservable</target>
        </trans-unit>
        <trans-unit id="18774004fcf928104b67925a5470d3718ffd4dd1" translate="yes" xml:space="preserve">
          <source>Its like &lt;a href=&quot;interval&quot;&gt;&lt;code&gt;interval&lt;/code&gt;&lt;/a&gt;, but you can specify when should the emissions start.</source>
          <target state="translated">그 같은 &lt;a href=&quot;interval&quot;&gt; &lt;code&gt;interval&lt;/code&gt; &lt;/a&gt; 배출을 시작해야 할 때,하지만 당신은 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1203b0749dc07175c4d76a73a84de4edcdb74c59" translate="yes" xml:space="preserve">
          <source>Join Creation Operators</source>
          <target state="translated">조인 생성 연산자</target>
        </trans-unit>
        <trans-unit id="63c003abaf20a9193778451d8079bc48f87ac911" translate="yes" xml:space="preserve">
          <source>Join Operators</source>
          <target state="translated">조인 연산자</target>
        </trans-unit>
        <trans-unit id="84e488e39c2aaa417a3c3e76304c3db42f028475" translate="yes" xml:space="preserve">
          <source>Joins every Observable emitted by the source (a higher-order Observable), in a serial fashion. It subscribes to each inner Observable only after the previous inner Observable has completed, and merges all of their values into the returned observable.</source>
          <target state="translated">소스에 의해 방출 된 모든 Observable (고차 Observable)을 직렬 방식으로 결합합니다. 이전 내부 Observable이 완료된 후에 만 ​​각 내부 Observable을 구독하고 모든 값을 반환 된 Observable에 병합합니다.</target>
        </trans-unit>
        <trans-unit id="3515b72ff2f6de015a4a8c6afbf292965ba26aa0" translate="yes" xml:space="preserve">
          <source>Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is installed and removed in each of elements.</source>
          <target state="translated">NodeList의 경우와 마찬가지로 DOM 노드의 모음입니다. 여기에서도 이벤트 핸들러 기능이 각 요소에 설치 및 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="404e85255f54d27c3b2cdce08ac4a990657b5eac" translate="yes" xml:space="preserve">
          <source>Just as many array library combine &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat&quot;&gt;&lt;code&gt;flat()&lt;/code&gt;&lt;/a&gt; (or &lt;code&gt;flatten()&lt;/code&gt;) into a single &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap&quot;&gt;&lt;code&gt;flatMap()&lt;/code&gt;&lt;/a&gt;, there are mapping equivalents of all the RxJS flattening operators &lt;a href=&quot;../api/operators/concatmap&quot;&gt;&lt;code&gt;concatMap()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/operators/mergemap&quot;&gt;&lt;code&gt;mergeMap()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../api/operators/switchmap&quot;&gt;&lt;code&gt;switchMap()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../api/operators/exhaustmap&quot;&gt;&lt;code&gt;exhaustMap()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">많은 배열 라이브러리가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat&quot;&gt; &lt;code&gt;flat()&lt;/code&gt; &lt;/a&gt; (또는 &lt;code&gt;flatten()&lt;/code&gt; )을 단일 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap&quot;&gt; &lt;code&gt;flatMap()&lt;/code&gt; &lt;/a&gt; 로 결합하는 것처럼 모든 RxJS 병합 연산자 &lt;a href=&quot;../api/operators/concatmap&quot;&gt; &lt;code&gt;concatMap()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../api/operators/mergemap&quot;&gt; &lt;code&gt;mergeMap()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../api/operators/switchmap&quot;&gt; &lt;code&gt;switchMap()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../api/operators/exhaustmap&quot;&gt; &lt;code&gt;exhaustMap()&lt;/code&gt; &lt;/a&gt; 과 동등한 매핑이 있습니다. () .</target>
        </trans-unit>
        <trans-unit id="6c1daef5575638ed8a0458933187be02bbdef946" translate="yes" xml:space="preserve">
          <source>Just emits 'complete', and nothing else.</source>
          <target state="translated">'완전한'것을 방출하고 다른 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="c3af46a19db3dcac82625d7bebe2770ee0d8fc0f" translate="yes" xml:space="preserve">
          <source>Just emits 'error', and nothing else.</source>
          <target state="translated">단지 '오류'를 내고 다른 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="1b80e3c5bd407999419466edbb962c55711528d1" translate="yes" xml:space="preserve">
          <source>Just like &lt;code&gt;observable.subscribe&lt;/code&gt; resembles &lt;code&gt;new Observable(function subscribe() {...})&lt;/code&gt;, the &lt;code&gt;unsubscribe&lt;/code&gt; we return from &lt;code&gt;subscribe&lt;/code&gt; is conceptually equal to &lt;code&gt;subscription.unsubscribe&lt;/code&gt;. In fact, if we remove the ReactiveX types surrounding these concepts, we're left with rather straightforward JavaScript.</source>
          <target state="translated">마찬가지로 &lt;code&gt;observable.subscribe&lt;/code&gt; 이 유사 &lt;code&gt;new Observable(function subscribe() {...})&lt;/code&gt; 의 &lt;code&gt;unsubscribe&lt;/code&gt; 에서 우리 리턴 &lt;code&gt;subscribe&lt;/code&gt; 개념적으로되는 동일 &lt;code&gt;subscription.unsubscribe&lt;/code&gt; . 실제로 이러한 개념을 둘러싼 ReactiveX 유형을 제거하면 다소 간단한 JavaScript가 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5025143a89e9b224781aa62468c0e2c91c66496" translate="yes" xml:space="preserve">
          <source>Known Issues</source>
          <target state="translated">알려진 문제</target>
        </trans-unit>
        <trans-unit id="52fab7dcbdbdd2ead5469234d5dae4a2b47ad34c" translate="yes" xml:space="preserve">
          <source>Last argument to &lt;code&gt;multiplex&lt;/code&gt; is a &lt;code&gt;messageFilter&lt;/code&gt; function which should return a boolean. It is used to filter out messages sent by the server to only those that belong to simulated WebSocket stream. For example, server might mark these messages with some kind of string identifier on a message object and &lt;code&gt;messageFilter&lt;/code&gt; would return &lt;code&gt;true&lt;/code&gt; if there is such identifier on an object emitted by the socket. Messages which returns &lt;code&gt;false&lt;/code&gt; in &lt;code&gt;messageFilter&lt;/code&gt; are simply skipped, and are not passed down the stream.</source>
          <target state="translated">에 마지막 인수 &lt;code&gt;multiplex&lt;/code&gt; A는 &lt;code&gt;messageFilter&lt;/code&gt; 의 부울을 반환해야 기능. 서버가 전송 한 메시지를 시뮬레이트 된 WebSocket 스트림에 속하는 메시지로 필터링하는 데 사용됩니다. 예를 들어, 서버는 이러한 메시지를 메시지 객체에 일종의 문자열 식별자로 표시 할 수 있으며 소켓에서 방출 된 객체에 이러한 식별자가 있으면 &lt;code&gt;messageFilter&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . &lt;code&gt;messageFilter&lt;/code&gt; 에서 &lt;code&gt;false&lt;/code&gt; 를 반환하는 메시지 는 단순히 건너 뛰고 스트림으로 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae3a986fdd0c26fe5d0e22d38167502d27e4db8f" translate="yes" xml:space="preserve">
          <source>Lets a value pass, then ignores source values for the next &lt;code&gt;duration&lt;/code&gt; milliseconds.</source>
          <target state="translated">값을 전달한 후 다음 &lt;code&gt;duration&lt;/code&gt; 밀리 초) 동안 소스 값을 무시합니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
