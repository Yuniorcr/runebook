<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="gnu_cobol">
    <body>
      <group id="gnu_cobol">
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="1ba54893e49d5a98fdd72b1731cb837c15733eae" translate="yes" xml:space="preserve">
          <source>F, FACTORIAL, FACTORY, FALSE, FD, FILE, FILE-CONTROL, FILE-ID, FILLER, FINAL, FIRST, FIXED, FLOAT-BINARY-128, FLOAT-BINARY-32, FLOAT-BINARY-64, FLOAT-DECIMAL-16, FLOAT-DECIMAL-34, FLOAT-EXTENDED, FLOAT-INFINITY, FLOAT-LONG, FLOAT-NOT-A-NUMBER, FLOAT-SHORT, FOOTING, FOR, FOREGROUND-COLOR, FOREGROUND-COLOUR, FOREVER, FORMAT, FORMATTED-CURRENT-DATE, FORMATTED-DATE, FORMATTED-DATETIME, FORMATTED-TIME, FORMFEED, FRACTION-PART, FREE, FROM, FULL, FUNCTION, FUNCTION-ID, FUNCTION-POINTER</source>
          <target state="translated">F, 공장, 공장, 거짓, FD, 파일, 파일 제어, 파일 ID, 필러, 최종, 첫 번째, 고정, 플로트 이진 -128, 플로트 이진 -32, 플로트 이진 -64, 플로트 데크 16, FLOAT-DECIMAL-34, FLOAT-EXTENDED, FLOAT-INFINITY, FLOAT-LONG, FLOAT-NOT-A-NUMBER, FLOAT-SHORT, FOOTING, FOR, FOREGROUND-COLOR, FOREGROUND-COLOUR, FOREVER, FORMAT, FORMAT- CURRENT-DATE, FORMATTED-DATE, FORMATTED-DATETIME, FORMATTED-TIME, FORMFEED, FRACTION-PART, FREE, FROM, FULL, FUNCTION, FUNCTION-ID, FUNCTION-POINTER</target>
        </trans-unit>
        <trans-unit id="d7caf280db3cab23a3efd52f861a41479460fa6f" translate="yes" xml:space="preserve">
          <source>F, FACTORIAL, FACTORY, FALSE, FD, FILE-CONTROL, FILE-ID, FILE-NAME, FILE-POS, FILE, FILL-COLOR2, FILL-COLOR, FILLER, FILL-PERCENT, FINAL, FINISH-REASON, FIRST, FIXED-FONT, FIXED-WIDTH, FIXED, FLAT-BUTTONS, FLAT, FLOAT-BINARY-128, FLOAT-BINARY-32, FLOAT-BINARY-64, FLOAT-DECIMAL-16, FLOAT-DECIMAL-34, FLOAT-EXTENDED, FLOAT-INFINITY, FLOATING, FLOAT-LONG, FLOAT-NOT-A-NUMBER, FLOAT-SHORT, FLOAT, FONT, FOOTING, FOREGROUND-COLOR, FOREGROUND-COLOUR, FOREVER, FORMAT, FORMATTED-CURRENT-DATE, FORMATTED-DATETIME, FORMATTED-DATE, FORMATTED-TIME, FORMFEED, FOR, FRACTION-PART, FRAMED, FRAME, FREE, FROM, FULL-HEIGHT, FULL, FUNCTION-ID, FUNCTION-POINTER, FUNCTION</source>
          <target state="translated">F, FACTORIAL, FACTORY, FALSE, FD, FILE-CONTROL, FILE-ID, FILE-NAME, FILE-POS, FILE, FILL-COLOR2, FILL-COLOR, FILLER, FILL-PERCENT, FINAL, FINISH-REASON, FIRST, FIXED-FONT, FIXED-WIDTH, FIXED, FLAT-BUTTONS, FLAT, FLOAT-BINARY-128, FLOAT-BINARY-32, FLOAT-BINARY-64, FLOAT-DECIMAL-16, FLOAT-DECIMAL-34, FLOAT-EXTENDED, FLOAT-INFINITY, FLOATING, FLOAT-LONG, FLOAT-NOT-A-NUMBER, FLOAT-SHORT, FLOAT, FONT, FOOTING, FOREGROUND-COLOR, FOREGROUND-COLOUR, FOREVER, FORMAT, FORMATTED-CURRENT-DATE, FORMATTED-DATETIME, FORMATTED-DATE, FORMATTED-TIME, FORMFEED, FOR, FRACTION-PART, FRAMED, FRAME, FREE, FROM, FULL-HEIGHT, FULL, FUNCTION-ID, FUNCTION-POINTER, FUNCTION</target>
        </trans-unit>
        <trans-unit id="c388ca73e917511c83a42c7c3347b5330aa45cac" translate="yes" xml:space="preserve">
          <source>F1&amp;ndash;F64, respectively, were pressed</source>
          <target state="translated">F1&amp;ndash;F64를 각각 눌렀습니다.</target>
        </trans-unit>
        <trans-unit id="03de1b80d9ce6c956e045a67ec26864bd9ba86c4" translate="yes" xml:space="preserve">
          <source>FACTORIAL Function Syntax</source>
          <target state="translated">FACTORIAL 함수 구문</target>
        </trans-unit>
        <trans-unit id="c9236dbf1d5f35b60810d9900ebae017d4554e9f" translate="yes" xml:space="preserve">
          <source>FALSE Clause Syntax</source>
          <target state="translated">거짓 조항 구문</target>
        </trans-unit>
        <trans-unit id="a721f50a7a690a4a15e9a37c997197a6892fe7c1" translate="yes" xml:space="preserve">
          <source>FETCH</source>
          <target state="translated">FETCH</target>
        </trans-unit>
        <trans-unit id="237f463d19c40eb262085170910a45a2579d4007" translate="yes" xml:space="preserve">
          <source>FILE SECTION Syntax</source>
          <target state="translated">파일 섹션 구문</target>
        </trans-unit>
        <trans-unit id="6dfe1492af3adfd94529936ae7572256a4829765" translate="yes" xml:space="preserve">
          <source>FILE-SECTION-Data-Item</source>
          <target state="translated">FILE-SECTION-Data-Item</target>
        </trans-unit>
        <trans-unit id="a00fbabfeb0e3333ddad8f67452398d7a56df6cc" translate="yes" xml:space="preserve">
          <source>FILE-SECTION-Data-Item Syntax</source>
          <target state="translated">파일 섹션 데이터 항목 구문</target>
        </trans-unit>
        <trans-unit id="9e0f66f312ce180a9aae7f3163bafb7826f66328" translate="yes" xml:space="preserve">
          <source>FINAL CONTROL FOOTING</source>
          <target state="translated">최종 제어 발판</target>
        </trans-unit>
        <trans-unit id="731f027415da5cfbed9659d7626ce1ec426fcffa" translate="yes" xml:space="preserve">
          <source>FOOTING AT</source>
          <target state="translated">FOOTING AT</target>
        </trans-unit>
        <trans-unit id="3e19d8cecb7e5bc7a9e28e9032b126d8e079e6f9" translate="yes" xml:space="preserve">
          <source>FOREGROUND-COLOR Attribute Syntax</source>
          <target state="translated">FOREGROUND-COLOR 속성 구문</target>
        </trans-unit>
        <trans-unit id="c692d3a2f6af3743ae5e8378f4c972f6314b9106" translate="yes" xml:space="preserve">
          <source>FORMATTED-CURRENT-DATE Function Syntax</source>
          <target state="translated">FORMATTED-CURRENT-DATE 함수 구문</target>
        </trans-unit>
        <trans-unit id="0d6c854d359a51e18bcbb535437b70bfcccdf40e" translate="yes" xml:space="preserve">
          <source>FORMATTED-DATE Function Syntax</source>
          <target state="translated">FORMATTED-DATE 함수 구문</target>
        </trans-unit>
        <trans-unit id="2356dae93cb030bd9402e0c53b8de8c6ad996010" translate="yes" xml:space="preserve">
          <source>FORMATTED-DATETIME Function Syntax</source>
          <target state="translated">FORMATTED-DATETIME 함수 구문</target>
        </trans-unit>
        <trans-unit id="38f8e91eae2a330b39222f7cba3ef7d527f6dd64" translate="yes" xml:space="preserve">
          <source>FORMATTED-TIME Function Syntax</source>
          <target state="translated">FORMATTED-TIME 함수 구문</target>
        </trans-unit>
        <trans-unit id="d5452f4037c6aa0b6e742313c3d7af9ddb944ba1" translate="yes" xml:space="preserve">
          <source>FRACTION-PART Function Syntax</source>
          <target state="translated">FRACTION-PART 함수 구문</target>
        </trans-unit>
        <trans-unit id="6a87ce926e3fdeec20b1a39152e04f9b4879b7c9" translate="yes" xml:space="preserve">
          <source>FREE Syntax</source>
          <target state="translated">무료 구문</target>
        </trans-unit>
        <trans-unit id="42879485a7a11418680abc60f6ddfab84a32360f" translate="yes" xml:space="preserve">
          <source>FROM Clause Syntax</source>
          <target state="translated">FROM 절 구문</target>
        </trans-unit>
        <trans-unit id="2f45ea6b6316a4f10231808ddaece8cd1888d793" translate="yes" xml:space="preserve">
          <source>FULL Attribute Syntax</source>
          <target state="translated">전체 속성 구문</target>
        </trans-unit>
        <trans-unit id="f8bf04d41870db2b7d965f6fcab85ce00b574e04" translate="yes" xml:space="preserve">
          <source>FUNCTION ALL INTRINSIC</source>
          <target state="translated">모든 본질적인 기능</target>
        </trans-unit>
        <trans-unit id="19aa8d076903fa405aac265ff791623484d35537" translate="yes" xml:space="preserve">
          <source>Fails due to rule #1</source>
          <target state="translated">규칙 # 1로 인해 실패</target>
        </trans-unit>
        <trans-unit id="c8f41e04860a699d459755ee5bc85c6fd14d5b99" translate="yes" xml:space="preserve">
          <source>Fails due to rule #2a</source>
          <target state="translated">규칙 # 2a로 인해 실패</target>
        </trans-unit>
        <trans-unit id="ff00be8ee320bab1c7ba44d9360894c017495313" translate="yes" xml:space="preserve">
          <source>Fails due to rule #2b</source>
          <target state="translated">규칙 # 2b로 인해 실패</target>
        </trans-unit>
        <trans-unit id="75efda3b01e99fcd496782dcc687d25e00babfe5" translate="yes" xml:space="preserve">
          <source>Fails due to rule #3a</source>
          <target state="translated">규칙 # 3a로 인해 실패</target>
        </trans-unit>
        <trans-unit id="050c309a1409aa9e640bd99affba7737a0884c7e" translate="yes" xml:space="preserve">
          <source>Fails due to rule #3b</source>
          <target state="translated">규칙 # 3b로 인해 실패</target>
        </trans-unit>
        <trans-unit id="296fa1d7af3bb7cac562c31b466a3232f2bb3696" translate="yes" xml:space="preserve">
          <source>Fails due to rule #5</source>
          <target state="translated">규칙 # 5로 인해 실패</target>
        </trans-unit>
        <trans-unit id="8ba4b7cd854379dc43efe678aa9fc863d5f197f9" translate="yes" xml:space="preserve">
          <source>Fails due to rule #6</source>
          <target state="translated">규칙 # 6으로 인해 실패</target>
        </trans-unit>
        <trans-unit id="1c882dc98a68cae48a636d1057fb89ac7d36d44d" translate="yes" xml:space="preserve">
          <source>Failure Reason</source>
          <target state="translated">실패 이유</target>
        </trans-unit>
        <trans-unit id="915120b00045631c4e8983c0043b1f79dd8a3042" translate="yes" xml:space="preserve">
          <source>Fatal</source>
          <target state="translated">Fatal</target>
        </trans-unit>
        <trans-unit id="c35c802e8500c8d21fd613e5ef4507f4da40a451" translate="yes" xml:space="preserve">
          <source>Fatal screen I/O error</source>
          <target state="translated">치명적인 화면 I / O 오류</target>
        </trans-unit>
        <trans-unit id="e19ab926093727a391692498a7ce5cfb742d2ae9" translate="yes" xml:space="preserve">
          <source>Field Outlining</source>
          <target state="translated">필드 개요</target>
        </trans-unit>
        <trans-unit id="3e7ab145eda1bc068c4891bdc4d2491b7ca3babf" translate="yes" xml:space="preserve">
          <source>Figurative Constants</source>
          <target state="translated">형상 상수</target>
        </trans-unit>
        <trans-unit id="03bfea69bef182d9778a417b4cddffa248ed1ef1" translate="yes" xml:space="preserve">
          <source>Figurative constants are reserved words that may be used as literals anywhere the figurative constants value could be interpreted as an arbitrarily long sequence of the characters in question. When a specific length is required, such as would be the case with an argument to a subprogram, a figurative constant may not be used. Thus, the following are valid uses of figurative constants:</source>
          <target state="translated">형상 상수는 형상 상수 값이 해당 문자의 임의의 긴 시퀀스로 해석 될 수있는 모든 곳에서 리터럴로 사용될 수있는 예약어입니다. 서브 프로그램에 대한 인수가있는 경우와 같이 특정 길이가 필요한 경우 형상 상수를 사용할 수 없습니다. 따라서 다음은 형상 상수의 유효한 사용입니다.</target>
        </trans-unit>
        <trans-unit id="daa8d8ba501862c2b07978aab870f1b814a865ba" translate="yes" xml:space="preserve">
          <source>File Location Strings are used (at runtime) to identify the path and filename to the data file that must be attached to &amp;lt;</source>
          <target state="translated">파일 위치 문자열은 (런타임에서) &amp;lt;에 첨부해야하는 데이터 파일의 경로와 파일 이름을 식별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="13f7443b10b7ca5925342febfec77171568b9348" translate="yes" xml:space="preserve">
          <source>File Location Strings are used (at runtime) to identify the path and filename to the data file that must be attached to &lt;var&gt;file-name-1&lt;/var&gt; when that file is opened.</source>
          <target state="translated">파일 위치 문자열은 파일이 열릴 때 &lt;var&gt;file-name-1&lt;/var&gt; 에 첨부되어야하는 데이터 파일의 경로와 파일 이름을 식별하기 위해 (런타임에) 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0f3e89f8a70a0298352574b5f3d10f8e9f6307ef" translate="yes" xml:space="preserve">
          <source>File Location Strings will be discussed shortly.</source>
          <target state="translated">파일 위치 문자열은 곧 논의 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="30ee6392d050dffb23e534b9b1e788b586e3c285" translate="yes" xml:space="preserve">
          <source>File already open</source>
          <target state="translated">파일이 이미 열려 있습니다</target>
        </trans-unit>
        <trans-unit id="1f1c6a46840542ee93667be29fe00c4a2ca6e55e" translate="yes" xml:space="preserve">
          <source>File not available</source>
          <target state="translated">사용할 수없는 파일</target>
        </trans-unit>
        <trans-unit id="a22e9c3b6a9f5c70de4f76a464810ecba1fb97c3" translate="yes" xml:space="preserve">
          <source>File not found</source>
          <target state="translated">파일을 찾을 수 없습니다</target>
        </trans-unit>
        <trans-unit id="d5a01ba68e46b606375d0915c493efcb6d3e3101" translate="yes" xml:space="preserve">
          <source>File not open</source>
          <target state="translated">파일이 열리지 않습니다</target>
        </trans-unit>
        <trans-unit id="aa73a3bd94b48e7abeca430b784ba4827580e7e5" translate="yes" xml:space="preserve">
          <source>File section data buffers (and therefore all 01-level record layouts defined in the file section) are initialized to all binary zeros when the program is loaded into storage.</source>
          <target state="translated">파일 섹션 데이터 버퍼 (및 파일 섹션에 정의 된 모든 01 레벨 레코드 레이아웃)는 프로그램이 스토리지에로드 될 때 모든 이진 0으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="2b5ebf13d43a94cfe869d3ece0ff8aa5a1595ced" translate="yes" xml:space="preserve">
          <source>File sharing failure</source>
          <target state="translated">파일 공유 실패</target>
        </trans-unit>
        <trans-unit id="182a34198299cefa26a74b5a5e4c6b7e382dfda1" translate="yes" xml:space="preserve">
          <source>File sharing is controlled through the use of a &lt;code&gt;SHARING&lt;/code&gt; clause:</source>
          <target state="translated">파일 공유는 &lt;code&gt;SHARING&lt;/code&gt; 절을 사용하여 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="d6b7a316c213638a85b3dd6184fc41aa5cc4fb7b" translate="yes" xml:space="preserve">
          <source>File sharing is controlled through the use of a&lt;code&gt;SHARING&lt;/code&gt;</source>
          <target state="translated">파일 공유는의 사용을 통해 제어됩니다 &lt;code&gt;SHARING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f47df965cafac62967f207b6e7f09ae5add8b8f" translate="yes" xml:space="preserve">
          <source>File-Based SORT Syntax</source>
          <target state="translated">파일 기반 SORT 구문</target>
        </trans-unit>
        <trans-unit id="d87ff91def81de51380ccde36991f463b59063af" translate="yes" xml:space="preserve">
          <source>File/Sort-Description Syntax</source>
          <target state="translated">파일 / 정렬 설명 구문</target>
        </trans-unit>
        <trans-unit id="0330be4deafe2943904ace5eb8bb1fc169381304" translate="yes" xml:space="preserve">
          <source>Files assigned to &lt;code&gt;PRINTER&lt;/code&gt; or &lt;code&gt;CONSOLE&lt;/code&gt; should be specified as &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PRINTER&lt;/code&gt; 또는 &lt;code&gt;CONSOLE&lt;/code&gt; 에 할당 된 파일 은 &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; 로 지정되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7083473fe7c031e4e4634ba20b9fb70b80346024" translate="yes" xml:space="preserve">
          <source>Files assigned to&lt;code&gt;PRINTER&lt;/code&gt;or&lt;code&gt;CONSOLE&lt;/code&gt;should be specified as&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PRINTER&lt;/code&gt; 또는 &lt;code&gt;CONSOLE&lt;/code&gt; 에 지정된 파일 은 &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; 로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="31bbe64669631ae63fd6fe6257505f9cc209fe68" translate="yes" xml:space="preserve">
          <source>Files declared as &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; will consist of records terminated by an end-of-record delimiter character or character sequence.</source>
          <target state="translated">&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; 로 선언 된 파일 은 레코드 끝 구분 문자 또는 문자 시퀀스로 끝나는 레코드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="8ece89d6efecefef42df7b76a92d5e414e65d7fc" translate="yes" xml:space="preserve">
          <source>Files declared as &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; will consist of records with no explicit end-of-record delimiter character sequences; records in such files are &amp;ldquo;delineated&amp;rdquo; by a calculated byte-offset (based on the maximum record length) into the file.</source>
          <target state="translated">&lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; 로 선언 된 파일은 명시적인 레코드 끝 구분 문자 시퀀스가없는 레코드로 구성됩니다. 이러한 파일의 레코드는 계산 된 바이트 오프셋 (최대 레코드 길이 기준)에 의해 파일에 &quot;설명&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="fadccef542c5815627f9bfef0daa01bf051a65a4" translate="yes" xml:space="preserve">
          <source>Files destined for use as sort/merge work files must be described with a Sort/Merge File Description (&lt;code&gt;SD&lt;/code&gt;) while every other file is described with a File Description (&lt;code&gt;FD&lt;/code&gt;). Each of these descriptions will almost always be followed with at least one record description.</source>
          <target state="translated">정렬 / 병합 작업 파일로 사용할 파일은 &lt;code&gt;SD&lt;/code&gt; (정렬 / 병합 파일 설명 ) 로 설명해야하며 다른 모든 파일은 파일 설명 ( &lt;code&gt;FD&lt;/code&gt; )으로 설명해야 합니다. 이러한 각 설명은 거의 항상 최소한 하나의 레코드 설명이 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="edea6aacf2ec3d63ce72d8e95db88b7bd15eacd7" translate="yes" xml:space="preserve">
          <source>Files destined for use as sort/merge work files must be described with a Sort/Merge File Description &lt;code&gt;SD&lt;/code&gt; while every other file is described with a File Description &lt;code&gt;FD&lt;/code&gt;. Each of these descriptions will almost always be followed with at least one record description.</source>
          <target state="translated">정렬 / 병합 작업 파일로 사용되는 파일은 정렬 / 병합 파일 설명 &lt;code&gt;SD&lt;/code&gt; 를 사용하여 설명해야하며 다른 모든 파일은 파일 설명 &lt;code&gt;FD&lt;/code&gt; 를 사용하여 설명해야합니다 . 이러한 각 설명에는 거의 항상 하나 이상의 레코드 설명이옵니다.</target>
        </trans-unit>
        <trans-unit id="367feea21d15dacc3ac862c7a57bd856bad73096" translate="yes" xml:space="preserve">
          <source>Finally, COBOL has the ability to perform in-place sorts of the data that is found in a table.</source>
          <target state="translated">마지막으로 COBOL은 테이블에서 찾은 데이터를 제자리에서 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6001a209721116a31aff91d01e445326ed01374" translate="yes" xml:space="preserve">
          <source>Finally, here&amp;rsquo;s the report the program generates!</source>
          <target state="translated">마지막으로, 프로그램이 생성하는 보고서가 있습니다!</target>
        </trans-unit>
        <trans-unit id="f20c28fefd559b4e296c1d1db0eefc938688cab3" translate="yes" xml:space="preserve">
          <source>Finally,the &lt;code&gt;REPORT FOOTING&lt;/code&gt; group, if any, will be presented.</source>
          <target state="translated">마지막으로 &lt;code&gt;REPORT FOOTING&lt;/code&gt; 그룹 (있는 경우)이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f8e1fd8ed05817c2c1238d06570433fc37097c39" translate="yes" xml:space="preserve">
          <source>Finally,the&lt;code&gt;REPORT FOOTING&lt;/code&gt;group, if any, will be presented.</source>
          <target state="translated">마지막으로 &lt;code&gt;REPORT FOOTING&lt;/code&gt; 그룹 (있는 경우)이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8a928ac89796afd20a583c169e78e1d2e97f3cee" translate="yes" xml:space="preserve">
          <source>First, the &quot;Hard Way&quot;:</source>
          <target state="translated">먼저 &quot;하드 웨이&quot;:</target>
        </trans-unit>
        <trans-unit id="700b01ba4bdd2da33483f145da324ac61e1b1906" translate="yes" xml:space="preserve">
          <source>First, the &amp;ldquo;Hard Way&amp;rdquo;:</source>
          <target state="translated">첫째,&amp;ldquo;어려운 길&amp;rdquo;:</target>
        </trans-unit>
        <trans-unit id="69a656c5968fc19e26398c39c1d42930578021ec" translate="yes" xml:space="preserve">
          <source>First/Last Digit</source>
          <target state="translated">첫 번째 / 마지막 자리</target>
        </trans-unit>
        <trans-unit id="c698ef5e7b0a316052b55cd8ba9f275dd3cc64d1" translate="yes" xml:space="preserve">
          <source>Fixed Format Mode</source>
          <target state="translated">고정 형식 모드</target>
        </trans-unit>
        <trans-unit id="fb6455fd910bbce0c221e84e30d7a80946a5a47c" translate="yes" xml:space="preserve">
          <source>Floating-point values using &quot;Enn&quot; notation such as 9.92E25, representing 9.92 x 10^25 (10 raised to the 25th power) or 5.7E-14, representing 5.7 x 10^-14 (10 raised to the -14th power). Both the mantissa (the number before the E) and the exponent (the number after the E) may be explicitly specified as positive (with a +), negative (with a -) or unsigned (and therefore implicitly positive). A floating-point literals value must be within the range -1.7 x 10^308 to +1.7 x 10^308 with no more than 15 decimal digits of precision.</source>
          <target state="translated">9.92 x 10 ^ 25 (10을 25 승으로 올림) 또는 5.7E-14를 나타내는 9.92E25와 같이 &quot;Enn&quot;표기법을 사용하는 부동 소수점 값 . 가수 (E 이전의 숫자)와 지수 (E 이후의 숫자)는 모두 양수 (+), 음수 (-) 또는 부호없는 (따라서 암시 적으로 양수)로 명시 적으로 지정할 수 있습니다. 부동 소수점 리터럴 값은 -1.7 x 10 ^ 308-+1.7 x 10 ^ 308 범위 내에 있어야하며 소수점 이하 자릿수는 15 자리를 넘지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="3669c6f52ce8ae20cb1c5200355804595b964532" translate="yes" xml:space="preserve">
          <source>Floating-point values using &amp;lsquo;</source>
          <target state="translated">'를 사용하는 부동 소수점 값</target>
        </trans-unit>
        <trans-unit id="5988bca9b2f3443b9ecd1f06fab806eb243168de" translate="yes" xml:space="preserve">
          <source>Footing Area</source>
          <target state="translated">바닥 면적</target>
        </trans-unit>
        <trans-unit id="87ab5909b2f76e9e20c96df08cc1254796e8a1d7" translate="yes" xml:space="preserve">
          <source>Footing Area &amp;mdash; An exception to this is the situation where the report footing report group contains the &lt;code&gt;NEXT PAGE&lt;/code&gt; option in its &lt;code&gt;LINE&lt;/code&gt; (see &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;) clause; in those cases, the report footing will be presented on a page by itself at the end of the report.</source>
          <target state="translated">기초 영역 &amp;mdash; 보고서 기초 보고서 그룹 의 &lt;code&gt;LINE&lt;/code&gt; ( &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt; 참조 ) 절 에 &lt;code&gt;NEXT PAGE&lt;/code&gt; 옵션이 포함 된 경우는 예외입니다 . 이 경우 보고서 끝 부분에 보고서 기초가 페이지에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e40c95fbb3b9dc7a620c19bde2435c717bde7695" translate="yes" xml:space="preserve">
          <source>Footing Area &amp;mdash; An exception to this is the situation where the report footing report group contains the&lt;code&gt;NEXT PAGE&lt;/code&gt;option in its&lt;code&gt;LINE&lt;/code&gt;(see &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;) clause; in those cases, the report footing will be presented on a page by itself at the end of the report.</source>
          <target state="translated">Footing Area &amp;mdash; 보고서 예외 보고서 그룹 의 &lt;code&gt;LINE&lt;/code&gt; ( &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt; 참조 ) 절 에 &lt;code&gt;NEXT PAGE&lt;/code&gt; 옵션이 포함 된 상황은 예외입니다 . 이 경우 보고서 마지막 부분에 보고서 기초가 페이지에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f1f2df0044b1fb68f6dc423b5264f3723a7c8996" translate="yes" xml:space="preserve">
          <source>For all other data types, the field size is set to the size of the item (same as if &lt;code&gt;CONVERT&lt;/code&gt; were not specified).</source>
          <target state="translated">다른 모든 데이터 유형의 경우 필드 크기는 항목의 크기로 설정됩니다 ( &lt;code&gt;CONVERT&lt;/code&gt; 가 지정되지 않은 것과 동일 ).</target>
        </trans-unit>
        <trans-unit id="a3127f980dbd36611f50532c041a2233802b3eff" translate="yes" xml:space="preserve">
          <source>For all other data types, the field size is set to the size of the item (same as if CONVERT were not specified).</source>
          <target state="translated">다른 모든 데이터 유형의 경우 필드 크기는 항목의 크기로 설정됩니다 (CONVERT가 지정되지 않은 것과 동일).</target>
        </trans-unit>
        <trans-unit id="aa49eb1e0aec6d10ce624911ab1285a133bc19a0" translate="yes" xml:space="preserve">
          <source>For any given version of GnuCOBOL you can also list the full current set of reserved words by running cobc with</source>
          <target state="translated">주어진 GnuCOBOL 버전에 대해 cobc를 다음과 같이 실행하여 현재 전체 예약어 집합을 나열 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f10546dc4d3d3e676fa3bc40fd34171c3147ee1" translate="yes" xml:space="preserve">
          <source>For composite &lt;code&gt;DISPLAY&lt;/code&gt;&amp;rsquo;s, the attributes are always only applied to the previous source-item but the following also allows a change by variable or literal</source>
          <target state="translated">복합 &lt;code&gt;DISPLAY&lt;/code&gt; 의 경우 속성은 항상 이전 소스 항목에만 적용되지만 다음은 변수 또는 리터럴에 의한 변경도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="0be022f00b31b21ff6869cd088d057bfb0e3270f" translate="yes" xml:space="preserve">
          <source>For each implementation of the GnuCOBOL compiler the supplied files NEWS should also be read for any last minute updates along with files README and INSTALL for building the compiler.</source>
          <target state="translated">GnuCOBOL 컴파일러의 각 구현에 대해 제공된 파일 NEWS는 컴파일러 빌드를위한 파일 README 및 INSTALL과 함께 마지막 순간 업데이트에 대해서도 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="c1fcb175d336c0714548be23a006f2304e931f29" translate="yes" xml:space="preserve">
          <source>For each source item, the contents of the sending item will be copied &amp;mdash; character-by-character &amp;mdash; into &amp;lt;</source>
          <target state="translated">각 소스 항목마다 전송 항목의 내용이 문자별로 복사되어 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="8d55093f3e06168b03c01ccd400fda41e135275a" translate="yes" xml:space="preserve">
          <source>For each source item, the contents of the sending item will be copied &amp;mdash; character-by-character &amp;mdash; into &lt;var&gt;identifier-3&lt;/var&gt; at the character position specified by the current character pointer. After each character is copied, the current character pointer will be incremented by 1 so that it points to the position within &lt;var&gt;identifier-3&lt;/var&gt; where the</source>
          <target state="translated">각 소스 항목에 대해 전송 항목의 내용 이 현재 문자 포인터에 의해 지정된 문자 위치의 &lt;var&gt;identifier-3&lt;/var&gt; 에 문자 단위로 복사됩니다 . 각 문자가 복사 된 후 현재 문자 포인터가 1 씩 증가하여 &lt;var&gt;identifier-3&lt;/var&gt; 내의 위치를 ​​가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="cf9156cf449643f9bda337a140c24f2f1504f039" translate="yes" xml:space="preserve">
          <source>For example, You will not expect to see any difference whatsoever between values of 1, 100, 500 or 1000, but you should see a difference between values such as 250000000 and 500000000.</source>
          <target state="translated">예를 들어, 1, 100, 500 또는 1000 값의 차이는 없을 것으로 예상되지만 250000000 및 500000000과 같은 값의 차이는 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67f2916632d9738b41e6e54331471967b49d6ae6" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard &lt;small&gt;ASCII&lt;/small&gt; collating sequence, &lt;code&gt;ORD('!')&lt;/code&gt; returns 34 because &amp;lsquo;</source>
          <target state="translated">예를 들어, 프로그램이 표준 &lt;small&gt;ASCII&lt;/small&gt; 배열 순서를 사용한다고 가정하면 &lt;code&gt;ORD('!')&lt;/code&gt; 는 '</target>
        </trans-unit>
        <trans-unit id="7766723a8b265a321d985162bb404da7b04dcd19" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard &lt;small&gt;ASCII&lt;/small&gt; collating sequence, &lt;code&gt;ORD-MAX('Z', 'z', '!')&lt;/code&gt; returns 2 because the 2nd character in the argument list (the &lt;small&gt;ASCII&lt;/small&gt; character &amp;lsquo;</source>
          <target state="translated">예를 들어, 프로그램이 표준 &lt;small&gt;ASCII&lt;/small&gt; 배열 순서를 사용한다고 가정하면 &lt;code&gt;ORD-MAX('Z', 'z', '!')&lt;/code&gt; 는 인수 목록의 두 번째 문자 ( &lt;small&gt;ASCII&lt;/small&gt; 문자 '</target>
        </trans-unit>
        <trans-unit id="0ed29102fb766b9394cd4e12f35df95ed7177458" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard &lt;small&gt;ASCII&lt;/small&gt; collating sequence, &lt;code&gt;ORD-MIN('Z', 'z', '!')&lt;/code&gt; returns 3 because the 3rd character in the argument list (the &lt;small&gt;ASCII&lt;/small&gt; character &amp;lsquo;</source>
          <target state="translated">예를 들어, 프로그램이 표준 &lt;small&gt;ASCII&lt;/small&gt; 배열 순서를 사용한다고 가정하면 &lt;code&gt;ORD-MIN('Z', 'z', '!')&lt;/code&gt; 는 인수 목록의 세 번째 문자 ( &lt;small&gt;ASCII&lt;/small&gt; 문자 '</target>
        </trans-unit>
        <trans-unit id="3368f51d3762d71c83916eebf4457e0236b996e5" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard ASCII collating sequence,&lt;code&gt;ORD('!')&lt;/code&gt;returns 34 because &quot;!&quot; is the 34th ASCII character. If you are using this function to convert an ASCII character to its numeric value, you must subtract one from the result.</source>
          <target state="translated">예를 들어, 프로그램이 표준 ASCII 조합 순서를 사용한다고 가정하면 &lt;code&gt;ORD('!')&lt;/code&gt; 는 &quot;!&quot; 34 번째 ASCII 문자입니다. 이 기능을 사용하여 ASCII 문자를 숫자 값으로 변환하는 경우 결과에서 하나를 빼야합니다.</target>
        </trans-unit>
        <trans-unit id="55a9ee5de13cdf67bb331bd003f29ecf42021db7" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard ASCII collating sequence,&lt;code&gt;ORD-MAX('Z', 'z', '!')&lt;/code&gt;returns 2 because the 2nd character in the argument list (the ASCII character &amp;rsquo;z&amp;rsquo;) occurs after &amp;rsquo;Z&amp;rsquo; and &amp;rsquo;!&amp;rsquo; in the program collating sequence. Each &amp;lt;</source>
          <target state="translated">예를 들어, 프로그램이 표준 ASCII 조합 순서를 사용한다고 가정하면 &lt;code&gt;ORD-MAX('Z', 'z', '!')&lt;/code&gt; 는 인수 목록의 두 번째 문자 (ASCII 문자 'z')가 다음에 발생하므로 2를 리턴합니다. 'Z'와 '!' 프로그램 조합 순서에서. 각 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="0b8897a3e322f2447e1c9d83730f3c7e2254e611" translate="yes" xml:space="preserve">
          <source>For example, assuming the program is using the standard ASCII collating sequence,&lt;code&gt;ORD-MIN('Z', 'z', '!')&lt;/code&gt;returns 3 because the 3rd character in the argument list (the ASCII character &amp;rsquo;!&amp;rsquo;) occurs before &amp;rsquo;Z&amp;rsquo; and &amp;rsquo;z&amp;rsquo; in the program collating sequence. Each &amp;lt;</source>
          <target state="translated">예를 들어, 프로그램이 표준 ASCII 조합 순서를 사용한다고 가정하면 &lt;code&gt;ORD-MIN('Z', 'z', '!')&lt;/code&gt; 은 인수 목록의 3 번째 문자 (ASCII 문자 '!')가 발생하기 때문에 3을 리턴합니다. 프로그램 조합 순서에서 'Z'및 'z' 각 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="749e13e172aac64f618104a47c4a2c7a40595730" translate="yes" xml:space="preserve">
          <source>For example, if &amp;lt;</source>
          <target state="translated">예를 들어 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="897cd42747603a9b53f6ab8470617280073ce9e3" translate="yes" xml:space="preserve">
          <source>For example, if &lt;var&gt;string&lt;/var&gt; is encoded using a double-byte character set such as Unicode UTF-16 (where each character is represented by 16 bits of storage, not the 8-bits inherent to character sets like &lt;small&gt;ASCII&lt;/small&gt; or &lt;small&gt;EBCDIC&lt;/small&gt;), then calling this function with a &lt;var&gt;string&lt;/var&gt; argument whose &lt;code&gt;PICTURE&lt;/code&gt; (see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) is &lt;code&gt;X(4)&lt;/code&gt; would return a value of 8 rather than the value 4.</source>
          <target state="translated">예를 들어 &lt;var&gt;string&lt;/var&gt; 이 유니 코드 UTF-16과 같은 2 바이트 문자 집합을 사용하여 인코딩 된 경우 (각 문자는 &lt;small&gt;ASCII&lt;/small&gt; 또는 &lt;small&gt;EBCDIC&lt;/small&gt; 같은 문자 집합에 고유 한 8 비트가 아닌 16 비트 저장소로 표시됨) 다음을 호출합니다. A의 함수 &lt;var&gt;string&lt;/var&gt; 인수 &lt;code&gt;PICTURE&lt;/code&gt; (참고 &lt;a href=&quot;#PICTURE&quot;&gt;사진&lt;/a&gt; )는 &lt;code&gt;X(4)&lt;/code&gt; 이 아니라 값이 4보다 8의 값을 반환하는 것이다.</target>
        </trans-unit>
        <trans-unit id="9ee8b6b0eabb2430a55cd033971a62ef89f44236" translate="yes" xml:space="preserve">
          <source>For example, if the program is using the (default) &lt;small&gt;ASCII&lt;/small&gt; character set, CHAR(34) returns the 34th character in the &lt;small&gt;ASCII&lt;/small&gt; character set &amp;mdash; an exclamation-point (&amp;lsquo;</source>
          <target state="translated">예를 들어, 프로그램이 (기본값) &lt;small&gt;ASCII&lt;/small&gt; 문자 집합을 사용하는 경우 CHAR (34)는 &lt;small&gt;ASCII&lt;/small&gt; 문자 집합 의 34 번째 문자 인 느낌표 ( '</target>
        </trans-unit>
        <trans-unit id="24697a3ba1d925f052573a7696493b003e3077cd" translate="yes" xml:space="preserve">
          <source>For example, if the program is using the (default) ASCII character set, CHAR(34) returns the 34th character in the ASCII character set &amp;mdash; an exclamation-point (&quot;!&quot;). If you are using this function to convert a numeric value to its corresponding ASCII character, you must use an argument value one greater than the numeric value.</source>
          <target state="translated">예를 들어, 프로그램이 (기본) ASCII 문자 집합을 사용하는 경우 CHAR (34)는 ASCII 문자 집합의 34 번째 문자 인 느낌표 ( &quot;!&quot;)를 반환합니다. 이 함수를 사용하여 숫자 값을 해당 ASCII 문자로 변환하는 경우 숫자 값보다 하나 더 큰 인수 값을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="86d303a32d15849fb5f8b370e6bee4a9d77d8625" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s assume we&amp;rsquo;re sorting a series of financial transactions. The SORT statement might look like this:</source>
          <target state="translated">예를 들어, 일련의 금융 거래를 정렬한다고 가정 해 봅시다. SORT 문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb00a63cdc6f6eb78d00ce4dd102beadda021aab" translate="yes" xml:space="preserve">
          <source>For example, let&amp;rsquo;s say you need to allocate a data item that contains however many millions of dollars of revenue your company has in gross revenues this year:</source>
          <target state="translated">예를 들어 올해 회사가 총 매출에서 수백만 달러의 수입을 포함하는 데이터 항목을 할당해야한다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="baad68c9ee59c08b3b83b0d9b5e6c9c54362d8ca" translate="yes" xml:space="preserve">
          <source>For example, observe the following data structure which defines a 4 column by 3 row grid of characters:</source>
          <target state="translated">예를 들어, 4 열 x 3 행 문자 격자를 정의하는 다음 데이터 구조를 관찰하십시오.</target>
        </trans-unit>
        <trans-unit id="1e1810c68bddd424a5992ed3cf44b3e08e986f15" translate="yes" xml:space="preserve">
          <source>For example, on a GnuCOBOL build for a Windows PC using MinGW and &amp;ldquo;PDCurses&amp;rdquo;, &lt;code&gt;F1&lt;/code&gt;&amp;ndash;&lt;code&gt;F12&lt;/code&gt; are the actual F-keys on the PC keyboard, &lt;code&gt;F&lt;var&gt;13&lt;/var&gt;&lt;/code&gt;&amp;ndash;&lt;code&gt;F&lt;var&gt;24&lt;/var&gt;&lt;/code&gt; are entered by shifting the F-keys, &lt;code&gt;F&lt;var&gt;25&lt;/var&gt;&lt;/code&gt;&amp;ndash;&lt;code&gt;F&lt;var&gt;36&lt;/var&gt;&lt;/code&gt; are entered by holding Ctrl while pressing an F-key and &lt;code&gt;F&lt;var&gt;37&lt;/var&gt;&lt;/code&gt;&amp;ndash;&lt;code&gt;F&lt;var&gt;48&lt;/var&gt;&lt;/code&gt; are entered by holding Alt while pressing an F-key. On the other hand, a GnuCOBOL implementation built for Windows using Cygwin and NCurses treats the PCs &lt;code&gt;F&lt;var&gt;1&lt;/var&gt;&lt;/code&gt;&amp;ndash;&lt;code&gt;F&lt;var&gt;12&lt;/var&gt;&lt;/code&gt; keys as the actual &lt;code&gt;F&lt;var&gt;1&lt;/var&gt;&lt;/code&gt;&amp;ndash;&lt;code&gt;F&lt;var&gt;12&lt;/var&gt;&lt;/code&gt;, while shifted F-keys will enter &lt;code&gt;F&lt;var&gt;11&lt;/var&gt;&lt;/code&gt;&amp;ndash;&lt;code&gt;F&lt;var&gt;2&lt;/var&gt;&lt;/code&gt;0. With Cygwin/NCurses, Ctrl- and Alt-modified F-keys aren&amp;rsquo;t recognized, nor are &lt;code&gt;Shift-F&lt;var&gt;11&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;Shift-F&lt;var&gt;12&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">예를 들어 MinGW 및 &quot;PDCurses&quot;를 사용하는 Windows PC 용 GnuCOBOL 빌드에서 &lt;code&gt;F1&lt;/code&gt; &amp;ndash; &lt;code&gt;F12&lt;/code&gt; 는 PC 키보드의 실제 F 키이고 &lt;code&gt;F&lt;var&gt;13&lt;/var&gt;&lt;/code&gt; &amp;ndash; &lt;code&gt;F&lt;var&gt;24&lt;/var&gt;&lt;/code&gt; 는 F 키를 이동하여 입력합니다. &lt;code&gt;F&lt;var&gt;25&lt;/var&gt;&lt;/code&gt; &amp;ndash; &lt;code&gt;F&lt;var&gt;36&lt;/var&gt;&lt;/code&gt; 은 Ctrl 키를 누른 상태에서 F 키를 누르면 입력되고 &lt;code&gt;F&lt;var&gt;37&lt;/var&gt;&lt;/code&gt; &amp;ndash; &lt;code&gt;F&lt;var&gt;48&lt;/var&gt;&lt;/code&gt; 은 Alt 키를 누른 상태에서 F 키를 누르면 입력됩니다. 반면에 Cygwin 및 NCurses를 사용하여 Windows 용으로 구축 된 GnuCOBOL 구현은 PC &lt;code&gt;F&lt;var&gt;1&lt;/var&gt;&lt;/code&gt; &amp;ndash; &lt;code&gt;F&lt;var&gt;12&lt;/var&gt;&lt;/code&gt; 키를 실제 &lt;code&gt;F&lt;var&gt;1&lt;/var&gt;&lt;/code&gt; &amp;ndash; &lt;code&gt;F&lt;var&gt;12&lt;/var&gt;&lt;/code&gt; , 이동 된 F 키는 &lt;code&gt;F&lt;var&gt;11&lt;/var&gt;&lt;/code&gt; &amp;ndash; &lt;code&gt;F&lt;var&gt;2&lt;/var&gt;&lt;/code&gt; 0을입력합니다. Cygwin / NCurses를 사용하면 Ctrl- 및 Alt- 수정 된 F 키가 인식되지 않으며 &lt;code&gt;Shift-F&lt;var&gt;11&lt;/var&gt;&lt;/code&gt; 또는 &lt;code&gt;Shift-F&lt;var&gt;12&lt;/var&gt;&lt;/code&gt; 도 인식되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3aafb29761d15f601ec670e73bfded28362456c7" translate="yes" xml:space="preserve">
          <source>For example, the following defines a class called &quot;Hexadecimal&quot;, the definition of which specifies the only characters that may be present in an alphanumeric data item if that data item is to be part of the &quot;Hexadecimal&quot; class:</source>
          <target state="translated">예를 들어, 다음은 &quot;16 진수&quot;라는 클래스를 정의합니다. 정의는 해당 데이터 항목이 &quot;16 진수&quot;클래스의 일부인 경우 영숫자 데이터 항목에 존재할 수있는 유일한 문자를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="affabf883c8efcc9b6ac761a06fc5f1e4af89db5" translate="yes" xml:space="preserve">
          <source>For example, the following defines a class called &lt;code&gt;Hexadecimal&lt;/code&gt;, the definition of which specifies the only characters that may be present in an alphanumeric data item if that data item is to be part of the &lt;code&gt;Hexadecimal&lt;/code&gt; class:</source>
          <target state="translated">예를 들어, 다음은 &lt;code&gt;Hexadecimal&lt;/code&gt; 이라는 클래스를 정의합니다. 이 정의는 데이터 항목이 &lt;code&gt;Hexadecimal&lt;/code&gt; 클래스의 일부인 경우 영숫자 데이터 항목에 존재할 수있는 유일한 문자를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="0bfaac6856103f819db17ad997ea57d182a00507" translate="yes" xml:space="preserve">
          <source>For example, you will not expect to see any difference between values of 1, 100, 500 or 1000, but you should see a difference between values such as 250000000 and 500000000.</source>
          <target state="translated">예를 들어 1, 100, 500 또는 1000의 값 사이에는 차이가 없을 것으로 예상되지만 250000000과 500000000과 같은 값 사이에는 차이가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="768d8aa397739d0da5300dfc289107304c48653e" translate="yes" xml:space="preserve">
          <source>For files in the &lt;code&gt;SEQUENTIAL&lt;/code&gt; access mode, the last input-output statement executed against &lt;var&gt;file-name-1&lt;/var&gt; prior to the execution of the &lt;code&gt;DELETE&lt;/code&gt; statement must have been a successfully executed sequential-format &lt;code&gt;READ&lt;/code&gt; statement (see &lt;a href=&quot;#Sequential-READ&quot;&gt;Sequential READ&lt;/a&gt;). That &lt;code&gt;READ&lt;/code&gt; will therefore identify the record to be deleted.</source>
          <target state="translated">에서 파일의 &lt;code&gt;SEQUENTIAL&lt;/code&gt; 액세스 모드, 마지막 입력 - 출력 문에 대해 실행 &lt;var&gt;file-name-1&lt;/var&gt; 의 실행 이전에 &lt;code&gt;DELETE&lt;/code&gt; 문이 성공적으로 실행 순차 포맷되어 있어야합니다 &lt;code&gt;READ&lt;/code&gt; 의 문을 (참조 &lt;a href=&quot;#Sequential-READ&quot;&gt;순차 읽기를&lt;/a&gt; ). 따라서 해당 &lt;code&gt;READ&lt;/code&gt; 는 삭제할 레코드를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="dab6ce21e23d5e22f729efd782034eee11b18ef5" translate="yes" xml:space="preserve">
          <source>For files in the&lt;code&gt;SEQUENTIAL&lt;/code&gt;access mode, the last input-output statement executed against &amp;lt;</source>
          <target state="translated">&lt;code&gt;SEQUENTIAL&lt;/code&gt; 액세스 모드 에있는 파일의 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="e59cbd1f100864f2a69aca9178b5457c051de746" translate="yes" xml:space="preserve">
          <source>For non-trivial computations, &lt;code&gt;COMPUTE&lt;/code&gt; statements &amp;ldquo;read&amp;rdquo; better. Take this, for example:</source>
          <target state="translated">사소하지 않은 계산의 경우 &lt;code&gt;COMPUTE&lt;/code&gt; 문이 &quot;읽기&quot;더 좋습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a39b87b77ac08a2facf379872c177dbaf2f50de3" translate="yes" xml:space="preserve">
          <source>For non-trivial computations, &lt;code&gt;COMPUTE&lt;/code&gt; statements may execute faster than the equivalent chain of basic arithmetic statements. For example, the COMPUTE statement shown above executes about 25% faster on my computer using GnuCOBOL than does the MULTIPLY-ADD-DIVIDE sequence.</source>
          <target state="translated">사소하지 않은 계산의 경우 &lt;code&gt;COMPUTE&lt;/code&gt; 문은 기본 산술 명령문의 동등한 체인보다 빠르게 실행될 수 있습니다. 예를 들어, 위에 표시된 COMPUTE 문은 MULTIPLY-ADD-DIVIDE 시퀀스보다 GnuCOBOL을 사용하여 내 컴퓨터에서 약 25 % 더 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0033fcaf736090140a9ae955ceeeed639d0db017" translate="yes" xml:space="preserve">
          <source>For non-trivial computations,&lt;code&gt;COMPUTE&lt;/code&gt;statements &quot;read&quot; better. Take this, for example:</source>
          <target state="translated">사소한 계산의 경우 &lt;code&gt;COMPUTE&lt;/code&gt; 문이 &quot;읽기&quot;좋습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4b25cf83aa9b241d27a0438f702e22b38e6a5771" translate="yes" xml:space="preserve">
          <source>For non-trivial computations,&lt;code&gt;COMPUTE&lt;/code&gt;statements may execute faster than the equivalent chain of basic arithmetic statements. For example, the COMPUTE statement shown above executes about 25% faster on my computer using GnuCOBOL than does the MULTIPLY-ADD-DIVIDE sequence.</source>
          <target state="translated">사소한 계산의 경우, &lt;code&gt;COMPUTE&lt;/code&gt; 문은 기본 산술 명령문의 동등한 체인보다 빠르게 실행될 수 있습니다. 예를 들어, 위에 표시된 COMPUTE 문은 MULTIPLY-ADD-DIVIDE 시퀀스보다 GnuCOBOL을 사용하는 컴퓨터에서 약 25 % 더 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4921ac486a9a7a241c39c923f2dc1b53c77e5445" translate="yes" xml:space="preserve">
          <source>For purposes of comparison, trailing spaces are truncated from the operands except that an operand consisting of all spaces is truncated to a single space.</source>
          <target state="translated">비교를 위해 모든 공백으로 구성된 피연산자가 단일 공백으로 잘리는 경우를 제외하고 후행 공백은 피연산자에서 잘립니다.</target>
        </trans-unit>
        <trans-unit id="4ea212aeaa1a2268b2a88fc06fad4dfb6854c1d1" translate="yes" xml:space="preserve">
          <source>For quite a while now (back to the late 1970&amp;rsquo;s), the</source>
          <target state="translated">한동안 (1970 년대 후반)</target>
        </trans-unit>
        <trans-unit id="483a043da3e58761a7a31d92b7cee03f34d3a0e9" translate="yes" xml:space="preserve">
          <source>For quite a while now (back to the late 1970&amp;rsquo;s), the &quot;sequence number area&quot; of a COBOL statement (columns 1-6) has come to be used as a change indicator area. Programmers would place a code in columns 1-6 of every line they changed in a program. The author works in a COBOL shop where change indicators of the form &quot;xxmmyy&quot; are required on every altered line of a program &amp;mdash; &quot;xx&quot; is the initials of the programmer while &quot;mmyy&quot; are the month and two-digit year of the date the change was made. This is frequently accompanied by a comment block at or near the top of a COBOL program providing general documentation of what changes were made and what change indicator was used to mark that change.</source>
          <target state="translated">꽤 오랫동안 (1970 년대 후반으로), COBOL 문의 &quot;열 번호 영역&quot;(1-6 열)이 변경 표시기 영역으로 사용되었습니다. 프로그래머는 프로그램에서 변경 한 모든 줄의 1-6 열에 코드를 배치합니다. 저자는 프로그램의 모든 변경된 줄에 &quot;xxmmyy&quot;형식의 변경 표시기가 필요한 COBOL 상점에서 작업합니다. &quot;xx&quot;는 프로그래머의 이니셜이고 &quot;mmyy&quot;는 날짜의 월과 두 자리 연도입니다. 변경되었습니다. 여기에는 COBOL 프로그램의 맨 위 또는 근처에 주석 블록이 포함되어 있으며, 변경 내용과 해당 변경 표시에 사용 된 변경 표시기에 대한 일반적인 문서를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="457470efdde973d009f597e9d358f8aba703173f" translate="yes" xml:space="preserve">
          <source>For syntax details for the &lt;code&gt;ORGANIZATION&lt;/code&gt; clause, see next group of paragraphs.</source>
          <target state="translated">&lt;code&gt;ORGANIZATION&lt;/code&gt; 절에 대한 구문 세부 사항 은 다음 단락 그룹을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e2dea5e1669c0a9fe3c1fbcb48cb6bd943c60b26" translate="yes" xml:space="preserve">
          <source>For the sake of brevity, this document lists the data in three columns.</source>
          <target state="translated">간결하게하기 위해이 문서는 데이터를 세 개의 열로 나열합니다.</target>
        </trans-unit>
        <trans-unit id="aa9a0c097479cba30f19eaa01767298dde8ef7ef" translate="yes" xml:space="preserve">
          <source>For the values specified on a &lt;code&gt;PAGE LIMIT&lt;/code&gt; clause to be valid, all of the following must be true:</source>
          <target state="translated">&lt;code&gt;PAGE LIMIT&lt;/code&gt; 절 에 지정된 값 이 유효하려면 다음이 모두 참이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ba325520d21c79af4680da537a3249fca4c6eeab" translate="yes" xml:space="preserve">
          <source>For the values specified on a&lt;code&gt;PAGE LIMIT&lt;/code&gt;clause to be valid, all of the following must be true:</source>
          <target state="translated">&lt;code&gt;PAGE LIMIT&lt;/code&gt; 절 에 지정된 값 이 유효하려면 다음이 모두 참이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6b68ca39097c0a0bedb3dc7024be567498339bfa" translate="yes" xml:space="preserve">
          <source>For those wishing to learn COBOL for the first time, Gary can strongly recommend the following resources.</source>
          <target state="translated">처음으로 COBOL을 배우고 자하는 사람들을 위해 Gary는 다음 리소스를 강력히 추천 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efdae81d538ace29e7236aee7c1c96a4ee6706e5" translate="yes" xml:space="preserve">
          <source>For trivial computations, on the other hand, I prefer the inherent readability of a statement such as this:</source>
          <target state="translated">반면에 사소한 계산의 경우 다음과 같은 문장의 고유 한 가독성을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="410ac084c444abe7ef2e13dea30c88749ac663a7" translate="yes" xml:space="preserve">
          <source>Format 1 of the &lt;code&gt;REPLACE&lt;/code&gt; statement can be used to make changes to program source code in much the same way as the  &lt;code&gt;REPLACING&lt;/code&gt; option of the &lt;code&gt;COPY&lt;/code&gt; statement can, via these options:</source>
          <target state="translated">&lt;code&gt;REPLACE&lt;/code&gt; 문의 형식 1을 사용하여 다음 옵션을 통해 &lt;code&gt;COPY&lt;/code&gt; 문의 &lt;code&gt;REPLACING&lt;/code&gt; 옵션과 거의 동일한 방식으로 프로그램 소스 코드를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09bebf0bea412802e3fbb625d9294d89526d28f2" translate="yes" xml:space="preserve">
          <source>Format 1 of the&lt;code&gt;REPLACE&lt;/code&gt;statement can be used to make changes to program source code in much the same way as the&lt;code&gt;REPLACING&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;REPLACE&lt;/code&gt; 문의 형식 1을 사용하면 &lt;code&gt;REPLACING&lt;/code&gt; 과 거의 같은 방식으로 프로그램 소스 코드를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcc8ef045e79317e7c9e712ad4f3b0696cfbb717" translate="yes" xml:space="preserve">
          <source>Format a numeric item for output, including thousands-separators (&amp;lsquo;</source>
          <target state="translated">천 단위 구분 기호 ( '</target>
        </trans-unit>
        <trans-unit id="e143df1aa83eabbe82d17220703bff1e6c2ae88e" translate="yes" xml:space="preserve">
          <source>Free Format Mode</source>
          <target state="translated">자유 형식 모드</target>
        </trans-unit>
        <trans-unit id="fbc349f93c5e079ef91504e8bcea3293322299f8" translate="yes" xml:space="preserve">
          <source>From the sequence of &amp;lt;</source>
          <target state="translated">&amp;lt;의 순서에서</target>
        </trans-unit>
        <trans-unit id="df46413f7f4a5b9afba020897df1c289f4be82fa" translate="yes" xml:space="preserve">
          <source>From the sequence of &lt;var&gt;identifier-1&lt;/var&gt; data items specified on the &lt;code&gt;INITIALIZE&lt;/code&gt; statement, a list of initialized fields referred to as the</source>
          <target state="translated">&lt;code&gt;INITIALIZE&lt;/code&gt; 문 에 지정된 &lt;var&gt;identifier-1&lt;/var&gt; 데이터 항목 시퀀스에서 초기화 된 필드 목록은</target>
        </trans-unit>
        <trans-unit id="ffd07c1bac910139b31da58ed3629443089db490" translate="yes" xml:space="preserve">
          <source>Full awareness of where the &quot;pen&quot; is about to &quot;write&quot; on the current page, automatically forcing an eject to a new page, along with the automatic generation of a page footer to close the old page and/or a page header to begin the new one.</source>
          <target state="translated">현재 페이지에서 &quot;펜&quot;이 &quot;쓰기&quot;되는 위치를 완전히 인식하여 이전 페이지 및 / 또는 페이지 머리글을 닫기위한 페이지 바닥 글 자동 생성과 함께 새 페이지로 자동으로 배출 새로운 것.</target>
        </trans-unit>
        <trans-unit id="b45a6d9d6000937f47f8b7fba24889e8e6116874" translate="yes" xml:space="preserve">
          <source>Full awareness of where the &amp;ldquo;pen&amp;rdquo; is about to &amp;ldquo;write&amp;rdquo; on the current page, automatically forcing an eject to a new page, along with the automatic generation of a page footer to close the old page and/or a page header to begin the new one.</source>
          <target state="translated">현재 페이지에서 &quot;펜&quot;이 &quot;쓰기&quot;되는 위치를 완전히 인식하여 자동으로 새 페이지로 꺼내고, 페이지 바닥 글을 자동으로 생성하여 이전 페이지를 닫고 /하거나 페이지 머리글을 시작합니다. 새로운 것.</target>
        </trans-unit>
        <trans-unit id="3a8b63681a5465651b7dd860e482efb9e8de5eee" translate="yes" xml:space="preserve">
          <source>Full-line comments</source>
          <target state="translated">전체 댓글</target>
        </trans-unit>
        <trans-unit id="a21a4b632492cfc3397cd22cf7495b9aac4c3cd0" translate="yes" xml:space="preserve">
          <source>Full-line comments with form-feed</source>
          <target state="translated">양식 피드가 포함 된 전체 주석</target>
        </trans-unit>
        <trans-unit id="a09ae3cf11bf198bd67625dda3216ea87527262f" translate="yes" xml:space="preserve">
          <source>Function argument error</source>
          <target state="translated">함수 인수 오류</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="fe94fb61bab790759d07739129a3829c99d0ddcc" translate="yes" xml:space="preserve">
          <source>GENERATE Syntax</source>
          <target state="translated">생성 구문</target>
        </trans-unit>
        <trans-unit id="ce7e9bdff283283e8c751261303522d7a587ceec" translate="yes" xml:space="preserve">
          <source>GENERATE, GET, GIVING, GLOBAL, GO, GOBACK, GREATER, GRID, GROUP, GROUP-USAGE</source>
          <target state="translated">생성, GET, GIVING, GLOBAL, GO, GOBACK, GREATER, GRID, GROUP, GROUP-USAGE</target>
        </trans-unit>
        <trans-unit id="ce40a1df1f0f92cc5772759de30fb76faa874571" translate="yes" xml:space="preserve">
          <source>GENERATE, GET, GIVING, GLOBAL, GOBACK, GO-BACK, GO-FORWARD, GO-HOME, GO-SEARCH, GO, GRAPHICAL, GREATER, GRID, GROUP-USAGE, GROUP-VALUE, GROUP</source>
          <target state="translated">생성, 가져 오기, 기부, 글로벌, GOBACK, GO-BACK, GO-FORWARD, GO-Home, GO-SEARCH, GO, GRAPHICAL, GREATER, GRID, GROUP-USAGE, GROUP-VALUE, GROUP</target>
        </trans-unit>
        <trans-unit id="3f77fc06eaeeaf7f12de14c907a75f7348ac4dc4" translate="yes" xml:space="preserve">
          <source>GLOBAL Attribute Syntax</source>
          <target state="translated">글로벌 속성 구문</target>
        </trans-unit>
        <trans-unit id="de1cb4189a6066e305ef5c9f7a84a37a249dad4c" translate="yes" xml:space="preserve">
          <source>GO TO DEPENDING ON</source>
          <target state="translated">DEPENDING ON으로 이동</target>
        </trans-unit>
        <trans-unit id="be6aeb1acd05ec878a2af6fecff181b13e85aa9a" translate="yes" xml:space="preserve">
          <source>GO TO DEPENDING ON Syntax</source>
          <target state="translated">구문에 따라 이동</target>
        </trans-unit>
        <trans-unit id="64f22d3218b9eaee10fe86a76b0f4f7308747bfe" translate="yes" xml:space="preserve">
          <source>GOBACK Syntax</source>
          <target state="translated">GOBACK 구문</target>
        </trans-unit>
        <trans-unit id="508368112dc00f3cf1200af84f7e4f2f7a3b1cbd" translate="yes" xml:space="preserve">
          <source>GROUP-INDICATE Attribute Syntax</source>
          <target state="translated">GROUP-INDICATE 속성 구문</target>
        </trans-unit>
        <trans-unit id="c9af09d3388e8d49bb54cf04c1c03cad69919dbf" translate="yes" xml:space="preserve">
          <source>Generally, these routines are intended to match those available in Micro Focus COBOL, ACUCOBOL and directly for GnuCOBOL.</source>
          <target state="translated">일반적으로 이러한 루틴은 Micro Focus COBOL, ACUCOBOL 및 GnuCOBOL에서 직접 사용할 수있는 루틴과 일치하도록 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="9d41e5d8aa938481797b811e06ef4d213ca2b12d" translate="yes" xml:space="preserve">
          <source>Generic terms representing user-defined substitutable items will be shown entirely in lower-case in syntax diagrams. When such items are referenced in text, they will appear as &amp;lt;</source>
          <target state="translated">사용자 정의 대체 가능 항목을 나타내는 일반 용어는 구문 다이어그램에서 모두 소문자로 표시됩니다. 이러한 항목이 텍스트로 참조되면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="39e33c54ed774d897c1886a402826062bfaee877" translate="yes" xml:space="preserve">
          <source>Generic terms representing user-defined substitutable items will be shown entirely in lower-case in syntax diagrams. When such items are referenced in text, they will appear as &lt;var&gt;substitutable-items&lt;/var&gt;.</source>
          <target state="translated">사용자 정의 대체 가능 항목을 나타내는 일반 용어는 구문 다이어그램에서 완전히 소문자로 표시됩니다. 이러한 항목이 텍스트에서 참조되면 &lt;var&gt;substitutable-items&lt;/var&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="a9457bdd27c6a3d78025d6c377d1adcbbc659a08" translate="yes" xml:space="preserve">
          <source>Getting file information (size and last-modification date/time)</source>
          <target state="translated">파일 정보 얻기 (크기 및 최종 수정 날짜 / 시간)</target>
        </trans-unit>
        <trans-unit id="75e08852c633c9bcebe7ab91746503bd91ff4946" translate="yes" xml:space="preserve">
          <source>Getting the length (in bytes) of an argument passed to a subroutine</source>
          <target state="translated">서브 루틴에 전달 된 인수의 길이 (바이트) 가져 오기</target>
        </trans-unit>
        <trans-unit id="838fcc5009c91a67ccafcd3d8a98dceb9843f0c5" translate="yes" xml:space="preserve">
          <source>Giving a table an initial, compile-time value is one of the trickier aspects of COBOL data definition. There are basically three standard techniques and a fourth that people familiar with other COBOL implementations but new to GnuCOBOL may find interesting. So, here are the three</source>
          <target state="translated">테이블에 초기 컴파일 시간 값을주는 것은 COBOL 데이터 정의의 까다로운 측면 중 하나입니다. 기본적으로 다른 COBOL 구현에 익숙하지만 GnuCOBOL에 익숙하지 않은 사람들은 세 가지 표준 기술과 네 번째 표준이 있습니다. 그래서 여기에 세</target>
        </trans-unit>
        <trans-unit id="dacd5d80181f68a262558fbeed5d04078293a6de" translate="yes" xml:space="preserve">
          <source>GnuCOBOL</source>
          <target state="translated">GnuCOBOL</target>
        </trans-unit>
        <trans-unit id="0f9a00d4af4500b63568bfe0a468268ec41fa076" translate="yes" xml:space="preserve">
          <source>GnuCOBOL Programmer&amp;rsquo;s Guide</source>
          <target state="translated">GnuCOBOL 프로그래머 가이드</target>
        </trans-unit>
        <trans-unit id="081f0e8a59ba2bfacc1ba96aeec3dec3e6c1b941" translate="yes" xml:space="preserve">
          <source>GnuCOBOL Quick Reference</source>
          <target state="translated">GnuCOBOL 빠른 참조</target>
        </trans-unit>
        <trans-unit id="b879a384bcf6b18e0b722cf0970e253d133c9742" translate="yes" xml:space="preserve">
          <source>GnuCOBOL Sample Programs</source>
          <target state="translated">GnuCOBOL 샘플 프로그램</target>
        </trans-unit>
        <trans-unit id="2015e1c594285c68a45a46a4c1c754031a21ab4b" translate="yes" xml:space="preserve">
          <source>GnuCOBOL always behaves as if the &lt;code&gt;WITH DUPLICATES IN ORDER&lt;/code&gt; clause is specified, even if it isn&amp;rsquo;t.</source>
          <target state="translated">GnuCOBOL 은 지정되지 않은 경우에도 항상 &lt;code&gt;WITH DUPLICATES IN ORDER&lt;/code&gt; 절이 지정된 것처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e9fc1fe76cf391a32dad55a122f4e0a0353992f7" translate="yes" xml:space="preserve">
          <source>GnuCOBOL always behaves as if the&lt;code&gt;WITH DUPLICATES IN ORDER&lt;/code&gt;clause is specified, even if it isn&amp;rsquo;t.</source>
          <target state="translated">GnuCOBOL은 &lt;code&gt;WITH DUPLICATES IN ORDER&lt;/code&gt; 절이 지정되지 않은 경우에도 항상 지정된 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="7ad04b4d1ad6af7bea77754b5641545c0ecdeb13" translate="yes" xml:space="preserve">
          <source>GnuCOBOL considers  &lt;code&gt;ASCII&lt;/code&gt;,  &lt;code&gt;STANDARD-1&lt;/code&gt; and  &lt;code&gt;STANDARD-2&lt;/code&gt; to be interchangeable.</source>
          <target state="translated">GnuCOBOL은 &lt;code&gt;ASCII&lt;/code&gt; , &lt;code&gt;STANDARD-1&lt;/code&gt; 및 &lt;code&gt;STANDARD-2&lt;/code&gt; 를 상호 교환 가능 하다고 간주 합니다.</target>
        </trans-unit>
        <trans-unit id="9e90bf626298379ff7d3f8b411b399e5608f6660" translate="yes" xml:space="preserve">
          <source>GnuCOBOL considers&lt;code&gt;ASCII&lt;/code&gt;</source>
          <target state="translated">GnuCOBOL은 &lt;code&gt;ASCII&lt;/code&gt; 를 고려합니다</target>
        </trans-unit>
        <trans-unit id="c9a66a6ceb8182d84df581737874a3597f8a4882" translate="yes" xml:space="preserve">
          <source>GnuCOBOL controls concurrent-file access at the highest level through the concept of file sharing, enforced when a program attempts to open a file. This is accomplished via a UNIX operating-system routine called &lt;code&gt;fcntl&lt;/code&gt;. That module is not currently supported by Windows and is not present in the MinGW Unix-emulation package. GnuCOBOL builds created using a MinGW environment will be incapable of supporting file-sharing controls &amp;mdash; files will always be shared in such environments. A GnuCOBOL build created using the Cygwin environment on Windows</source>
          <target state="translated">GnuCOBOL은 프로그램이 파일을 열려고 할 때 적용되는 파일 공유 개념을 통해 최고 수준에서 동시 파일 액세스를 제어합니다. 이는 &lt;code&gt;fcntl&lt;/code&gt; 이라는 UNIX 운영 체제 루틴을 통해 수행됩니다 . 해당 모듈은 현재 Windows에서 지원되지 않으며 MinGW Unix 에뮬레이션 패키지에 없습니다. MinGW 환경을 사용하여 생성 된 GnuCOBOL 빌드는 파일 공유 제어를 지원할 수 없습니다. 파일은 항상 이러한 환경에서 공유됩니다. Windows에서 Cygwin 환경을 사용하여 생성 된 GnuCOBOL 빌드</target>
        </trans-unit>
        <trans-unit id="a42d16409222bdca47c6d18f713049cd4e48dfe5" translate="yes" xml:space="preserve">
          <source>GnuCOBOL data items, like those of other COBOL implementations, are described in a hierarchical manner. This accommodates the fact that data items frequently need to be able to be broken up into subordinate items. Take for example, the following logical layout of a portion of a data item named &lt;code&gt;Employee&lt;/code&gt;:</source>
          <target state="translated">다른 COBOL 구현과 마찬가지로 GnuCOBOL 데이터 항목은 계층 적으로 설명됩니다. 이는 데이터 항목을 자주 하위 항목으로 나눌 수 있어야한다는 사실을 수용합니다. 예를 들어 &lt;code&gt;Employee&lt;/code&gt; 라는 데이터 항목의 일부에 대한 다음과 같은 논리적 레이아웃이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="000801f5dd39b155259c54a804c2b16d6f375132" translate="yes" xml:space="preserve">
          <source>GnuCOBOL defines &lt;em&gt;compilation variables&lt;/em&gt; when various conditions are true. If the condition associated with a variable is false, the variable is not defined.</source>
          <target state="translated">GnuCOBOL은 다양한 조건이 참일 때 &lt;em&gt;컴파일 변수를&lt;/em&gt; 정의 합니다. 변수와 연관된 조건이 거짓이면 변수가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ade20b6aef56cd0ff2aed2427da9159fa14af39b" translate="yes" xml:space="preserve">
          <source>GnuCOBOL defines compilation variables when certain conditions are true.</source>
          <target state="translated">GnuCOBOL은 특정 조건이 참일 때 컴파일 변수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="ce92bb9f1fd0286db331c868da0f7ad81d39837c" translate="yes" xml:space="preserve">
          <source>GnuCOBOL fully supports much of the ANSI 85 standard for COBOL (the only major exclusion is the Communications Module) and also supports some of the components of the COBOL2002 and COBOL2014 standards, such as the &lt;code&gt;SCREEN SECTION&lt;/code&gt; (see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;), table-based &lt;code&gt;SORT&lt;/code&gt; (see &lt;a href=&quot;#Table-SORT&quot;&gt;Table SORT&lt;/a&gt;) and user-defined functions. There are others with more being added almost weekly.</source>
          <target state="translated">GnuCOBOL은 COBOL에 대한 ANSI 85 표준의 대부분을 완벽하게 지원하며 (유일한 제외는 Communications Module) COBOL2002 및 COBOL2014 표준의 일부 구성 요소 (예 : &lt;code&gt;SCREEN SECTION&lt;/code&gt; ( &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt; 참조 ), 테이블 기반 &lt;code&gt;SORT&lt;/code&gt; )도 지원합니다. ( &lt;a href=&quot;#Table-SORT&quot;&gt;Table SORT&lt;/a&gt; 참조 ) 및 사용자 정의 함수. 거의 매주 추가되는 다른 것들이 있습니다.</target>
        </trans-unit>
        <trans-unit id="12cf00b4626858f857b18dd724c1c9875f678c7e" translate="yes" xml:space="preserve">
          <source>GnuCOBOL fully supports much of the ANSI 85 standard for COBOL (the only major exclusion is the Communications Module) and also supports some of the components of the COBOL2002 standard, such as the&lt;code&gt;SCREEN SECTION&lt;/code&gt;(see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;), table-based&lt;code&gt;SORT&lt;/code&gt;(see &lt;a href=&quot;#Table-SORT&quot;&gt;Table SORT&lt;/a&gt;) and user-defined functions.</source>
          <target state="translated">GnuCOBOL은 COBOL에 대한 많은 ANSI 85 표준 (통신 모듈 만 유일하게 제외)을 완전히 지원하고 &lt;code&gt;SCREEN SECTION&lt;/code&gt; ( &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;스크린 섹션&lt;/a&gt; 참조 ), 테이블 기반 &lt;code&gt;SORT&lt;/code&gt; 와 같은 COBOL2002 표준의 일부 구성 요소도 지원합니다 (참조 &lt;a href=&quot;#Table-SORT&quot;&gt;표 SORT&lt;/a&gt; ) 및 사용자 정의 함수</target>
        </trans-unit>
        <trans-unit id="97e9d0710dd9b847b88301b5ded4630f6ebd6cf5" translate="yes" xml:space="preserve">
          <source>GnuCOBOL has also been built as a truly native Windows application utilizing Microsoft&amp;rsquo;s freely-downloadable Visual Studio Express package to provide the C compiler and linker/loader. This approach does not lend itself well to a &quot;portable&quot; distribution.</source>
          <target state="translated">GnuCOBOL은 또한 무료로 다운로드 할 수있는 Microsoft의 Visual Studio Express 패키지를 사용하여 C 컴파일러 및 링커 / 로더를 제공하는 진정한 네이티브 Windows 응용 프로그램으로 구축되었습니다. 이 접근 방식은 &quot;휴대용&quot;배포에 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="989809682a477dc64a331b0aedc581e943030842" translate="yes" xml:space="preserve">
          <source>GnuCOBOL has also been built as a truly native Windows application utilizing Microsoft&amp;rsquo;s freely-downloadable Visual Studio Express package to provide the C compiler and linker/loader. This approach does not lend itself well to a &amp;ldquo;portable&amp;rdquo; distribution.</source>
          <target state="translated">GnuCOBOL은 또한 C 컴파일러와 링커 / 로더를 제공하기 위해 Microsoft의 무료로 다운로드 가능한 Visual Studio Express 패키지를 활용하는 진정한 네이티브 Windows 애플리케이션으로 구축되었습니다. 이 접근 방식은 &quot;휴대용&quot;배포에 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ec4d6f9297d331838c7e1bc3be7fcca33c892c1" translate="yes" xml:space="preserve">
          <source>GnuCOBOL includes an implementation of the Report Writer Control System, or RWCS. The reportwriter module is now fully implemented as of version 3.0. This is a standardized, optional add-on feature to the COBOL language which automates much of the mechanics involved in the generation of printed reports by:</source>
          <target state="translated">GnuCOBOL은 보고서 작성기 제어 시스템 (RWCS)의 구현을 포함합니다. 보고서 작성기 모듈은 이제 버전 3.0부터 완전히 구현되었습니다. 이것은 COBOL 언어에 대한 표준화 된 선택적 추가 기능으로, 다음을 통해 인쇄 된 보고서 생성과 관련된 많은 메커니즘을 자동화합니다.</target>
        </trans-unit>
        <trans-unit id="748dc4c0de13fcba44056b388d77f85eed18ba64" translate="yes" xml:space="preserve">
          <source>GnuCOBOL is a free and open sourced COBOL compiler and runtime environment, written using the C programming language. GnuCOBOL is typically distributed in source-code form, and must then be built for your computer&amp;rsquo;s operating system using the system&amp;rsquo;s C compiler and loader. While originally developed for the UNIX and Linux operating systems, GnuCOBOL has also been successfully built for computers running OSX and Windows utilizing the UNIX-emulation features of such tools as Cygwin and MinGW. Also see the &lt;a href=&quot;https://savannah.gnu.org/projects/gnucobol&quot;&gt;GNU website&lt;/a&gt; for more information at.</source>
          <target state="translated">GnuCOBOL은 C 프로그래밍 언어를 사용하여 작성된 무료 오픈 소스 COBOL 컴파일러 및 런타임 환경입니다. GnuCOBOL은 일반적으로 소스 코드 형식으로 배포되며 시스템의 C 컴파일러 및 로더를 사용하여 컴퓨터 운영 체제 용으로 빌드해야합니다. 원래는 UNIX 및 Linux 운영 체제 용으로 개발되었지만 GnuCOBOL은 Cygwin 및 MinGW와 같은 도구의 UNIX 에뮬레이션 기능을 사용하여 OSX 및 Windows를 실행하는 컴퓨터 용으로 성공적으로 구축되었습니다. 자세한 내용 은 &lt;a href=&quot;https://savannah.gnu.org/projects/gnucobol&quot;&gt;GNU 웹 사이트&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fe0e58c1b50f38b5d5939b86c78fc28f3f84cd98" translate="yes" xml:space="preserve">
          <source>GnuCOBOL is compiling the source unit.</source>
          <target state="translated">GnuCOBOL이 소스 유닛을 컴파일하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ec33f04258b5a5ce00f804f3a7f12afecaa7b22" translate="yes" xml:space="preserve">
          <source>GnuCOBOL programs compiled with the</source>
          <target state="translated">GnuCOBOL 프로그램은</target>
        </trans-unit>
        <trans-unit id="763499a319b22b6d28fecd96e5e4577d44422e38" translate="yes" xml:space="preserve">
          <source>GnuCOBOL programs compiled with the&lt;code&gt;-x&lt;/code&gt;switch</source>
          <target state="translated">&lt;code&gt;-x&lt;/code&gt; 스위치로 컴파일 된 GnuCOBOL 프로그램</target>
        </trans-unit>
        <trans-unit id="093449c074389871b78ba91d90fbe11fdc681ce0" translate="yes" xml:space="preserve">
          <source>GnuCOBOL provides for control over the final rounding process applied to the receiving fields on all arithmetic verbs. Each of the arithmetic statements (&lt;code&gt;ADD&lt;/code&gt; (see &lt;a href=&quot;#ADD&quot;&gt;ADD&lt;/a&gt;), &lt;code&gt;COMPUTE&lt;/code&gt; (see &lt;a href=&quot;#COMPUTE&quot;&gt;COMPUTE&lt;/a&gt;), &lt;code&gt;DIVIDE&lt;/code&gt; (see &lt;a href=&quot;#DIVIDE&quot;&gt;DIVIDE&lt;/a&gt;), &lt;code&gt;MULTIPLY&lt;/code&gt; (see &lt;a href=&quot;#MULTIPLY&quot;&gt;MULTIPLY&lt;/a&gt;) and &lt;code&gt;SUBTRACT&lt;/code&gt; (see &lt;a href=&quot;#SUBTRACT&quot;&gt;SUBTRACT&lt;/a&gt;)) statements allow an optional &lt;code&gt;ROUNDED&lt;/code&gt; clause to be applied to each receiving data item.</source>
          <target state="translated">GnuCOBOL은 모든 산술 동사의 수신 필드에 적용되는 최종 반올림 프로세스를 제어합니다. 산술 제표 각 ( &lt;code&gt;ADD&lt;/code&gt; (참조 &lt;a href=&quot;#ADD&quot;&gt;ADD를&lt;/a&gt; ) &lt;code&gt;COMPUTE&lt;/code&gt; 는 (참조 &lt;a href=&quot;#COMPUTE&quot;&gt;COMPUTE를&lt;/a&gt; ) &lt;code&gt;DIVIDE&lt;/code&gt; (참조 &lt;a href=&quot;#DIVIDE&quot;&gt;나누기&lt;/a&gt; ) &lt;code&gt;MULTIPLY&lt;/code&gt; (참조 &lt;a href=&quot;#MULTIPLY&quot;&gt;곱셈&lt;/a&gt; ) 및 &lt;code&gt;SUBTRACT&lt;/code&gt; (참조 &lt;a href=&quot;#SUBTRACT&quot;&gt;빼기&lt;/a&gt; )) 문은 선택 가능 &lt;code&gt;ROUNDED&lt;/code&gt; 절 각각의 수신 데이터 항목에인가 .</target>
        </trans-unit>
        <trans-unit id="a9cf477a6985387b61c2ac288aa91a195ba51db5" translate="yes" xml:space="preserve">
          <source>GnuCOBOL run-time screen management must have been initialized prior to CALLing this routine in order to receive meaningful values. This means that a &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; statement (see &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-item&lt;/a&gt;) or a &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) must have been executed prior to executing the &lt;code&gt;CALL&lt;/code&gt; statement.</source>
          <target state="translated">의미있는 값을 받으려면이 루틴을 호출하기 전에 GnuCOBOL 런타임 화면 관리를 초기화해야합니다. 이는 &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; 문 ( &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-item 참조&lt;/a&gt; ) 또는 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 문 ( &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item 참조&lt;/a&gt; )이 &lt;code&gt;CALL&lt;/code&gt; 문 을 실행하기 전에 실행되어야 함을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="20252ad5ff4fe084533d45067eda2369ad4e5568" translate="yes" xml:space="preserve">
          <source>GnuCOBOL run-time screen management must have been initialized prior to CALLing this routine in order to receive meaningful values. This means that a&lt;code&gt;DISPLAY screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-item&lt;/a&gt;) or a&lt;code&gt;ACCEPT screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) must have been executed prior to executing the&lt;code&gt;CALL&lt;/code&gt;statement.</source>
          <target state="translated">의미있는 값을 받으려면이 루틴을 호출하기 전에 GnuCOBOL 런타임 화면 관리를 초기화해야합니다. 이는 &lt;code&gt;CALL&lt;/code&gt; 문 을 실행하기 전에 &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY 화면 &lt;/a&gt; &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; 명령문 ( DISPLAY 화면 데이터 항목 참조 ) 또는 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 명령문 ( &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item 참조&lt;/a&gt; )이 실행되어야 함을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="b10af487d74e250e882604b1bf9bb79ff41e00cf" translate="yes" xml:space="preserve">
          <source>GnuCOBOL stores &lt;code&gt;FLOAT-DECIMAL-16&lt;/code&gt; and &lt;code&gt;FLOAT-DECIMAL-34&lt;/code&gt; data items using either Big-Endian or Little-Endian form, whichever is native to the system.</source>
          <target state="translated">GnuCOBOL 은 시스템 고유의 Big-Endian 또는 Little-Endian 형식을 사용하여 &lt;code&gt;FLOAT-DECIMAL-16&lt;/code&gt; 및 &lt;code&gt;FLOAT-DECIMAL-34&lt;/code&gt; 데이터 항목을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="577f54cb6512af8b81a61cc8247c3cb8a51134a5" translate="yes" xml:space="preserve">
          <source>GnuCOBOL stores &lt;code&gt;FLOAT-LONG&lt;/code&gt; and &lt;code&gt;FLOAT-SHORT&lt;/code&gt; data items using either Big-Endian or Little-Endian form, whichever is native to the system.</source>
          <target state="translated">GnuCOBOL은 Big-Endian 또는 Little-Endian 형식 중 시스템에 고유 한 형식을 사용하여 &lt;code&gt;FLOAT-LONG&lt;/code&gt; 및 &lt;code&gt;FLOAT-SHORT&lt;/code&gt; 데이터 항목을 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="bca9afd1bdb28fa197bd33fb7a24153cdc7c56b4" translate="yes" xml:space="preserve">
          <source>GnuCOBOL stores&lt;code&gt;FLOAT-DECIMAL-16&lt;/code&gt;and&lt;code&gt;FLOAT-DECIMAL-34&lt;/code&gt;data items using either Big-Endian or Little-Endian form, whichever is native to the system.</source>
          <target state="translated">GnuCOBOL 은 시스템 고유의 Big-Endian 또는 Little-Endian 형식을 사용하여 &lt;code&gt;FLOAT-DECIMAL-16&lt;/code&gt; 및 &lt;code&gt;FLOAT-DECIMAL-34&lt;/code&gt; 데이터 항목을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="3b9f975d574fd7cc4ea7de4b02075b1a7eaf9bfc" translate="yes" xml:space="preserve">
          <source>GnuCOBOL stores&lt;code&gt;FLOAT-LONG&lt;/code&gt;and&lt;code&gt;FLOAT-SHORT&lt;/code&gt;data items using either Big-Endian or Little-Endian form, whichever is native to the system.</source>
          <target state="translated">GnuCOBOL 은 시스템 고유의 Big-Endian 또는 Little-Endian 형식을 사용하여 &lt;code&gt;FLOAT-LONG&lt;/code&gt; 및 &lt;code&gt;FLOAT-SHORT&lt;/code&gt; 데이터 항목을 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="6ab3cffbe92c165a46df6ca158ad1c4a6a0c158c" translate="yes" xml:space="preserve">
          <source>GnuCOBOL subprograms may be created as either static or dynamic subprograms, as desired by the programmer.</source>
          <target state="translated">GnuCOBOL 서브 프로그램은 프로그래머가 원하는대로 정적 또는 동적 서브 프로그램으로 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90caf4fdcad7d8990c1ca4da35e29871f7d9e6ce" translate="yes" xml:space="preserve">
          <source>GnuCOBOL supports a wide variety of &amp;ldquo;intrinsic functions&amp;rdquo; that may be used anywhere in the PROCEDURE DIVISION where a literal is allowed. For example:</source>
          <target state="translated">GnuCOBOL은 리터럴이 허용되는 PROCEDURE DIVISION 어디에서나 사용할 수있는 다양한&amp;ldquo;내재 함수&amp;rdquo;를 지원합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="5d2f811d109dc8d5b31442b8bf34dfb7a89f84e4" translate="yes" xml:space="preserve">
          <source>GnuCOBOL supports the following visual attribute specifications in the &lt;code&gt;SCREEN SECTION&lt;/code&gt; (see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;):</source>
          <target state="translated">GnuCOBOL은 &lt;code&gt;SCREEN SECTION&lt;/code&gt; 에서 다음과 같은 시각적 속성 사양을 지원합니다 ( &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="183088592eb0fa2ad8ba5f34425e030453ebfcc8" translate="yes" xml:space="preserve">
          <source>GnuCOBOL supports the following visual attribute specifications in the&lt;code&gt;SCREEN SECTION&lt;/code&gt;(see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;):</source>
          <target state="translated">GnuCOBOL은 &lt;code&gt;SCREEN SECTION&lt;/code&gt; 에서 다음과 같은 시각적 속성 사양을 지원합니다 ( &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;화면 섹션&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4323e46dfc1114d37bb106302840110ba00746d3" translate="yes" xml:space="preserve">
          <source>GnuCOBOL uses compiler configuration files to define various options that will control the compilation process. These configuration files are specified using the</source>
          <target state="translated">GnuCOBOL은 컴파일러 구성 파일을 사용하여 컴파일 프로세스를 제어하는 ​​다양한 옵션을 정의합니다. 이러한 구성 파일은</target>
        </trans-unit>
        <trans-unit id="6684809df42a659397430ece5dce09f5dd77386c" translate="yes" xml:space="preserve">
          <source>GnuCOBOL uses compiler configuration files to define various options that will control the compilation process. These configuration files are specified using the&lt;code&gt;-conf&lt;/code&gt;switch</source>
          <target state="translated">GnuCOBOL은 컴파일러 구성 파일을 사용하여 컴파일 프로세스를 제어 할 다양한 옵션을 정의합니다. 이러한 구성 파일은 &lt;code&gt;-conf&lt;/code&gt; 스위치를 사용하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="0825d5ebac283b0d7888040222d108fb9bbc2f52" translate="yes" xml:space="preserve">
          <source>GnuCOBOL, like other COBOL dialects, includes a number of data items that are automatically available to a programmer without the need to actually define them in the data division. COBOL refers to such items as registers or special registers. The special registers available to a GnuCOBOL program are as follows:</source>
          <target state="translated">다른 COBOL 언어와 마찬가지로 GnuCOBOL에는 데이터 분할에서 실제로 정의 할 필요없이 프로그래머가 자동으로 사용할 수있는 여러 데이터 항목이 포함되어 있습니다. COBOL은 레지스터 또는 특수 레지스터와 같은 항목을 참조합니다. GnuCOBOL 프로그램에 사용할 수있는 특수 레지스터는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3bd06fc3f53a54465c3ccaa768b1a3b1875dd413" translate="yes" xml:space="preserve">
          <source>GnuCOBOL, like other COBOL implementations, supports a number of reserved words that may be used to represent a specific literal value. These are known as figurative constants. See &lt;a href=&quot;#Figurative-Constants&quot;&gt;Figurative Constants&lt;/a&gt;, for more information.</source>
          <target state="translated">GnuCOBOL은 다른 COBOL 구현과 마찬가지로 특정 리터럴 값을 나타내는 데 사용될 수있는 많은 예약어를 지원합니다. 이것을 형상 상수라고합니다. 자세한 내용은 &lt;a href=&quot;#Figurative-Constants&quot;&gt;형상 상수&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e2bb4d252c23fe267cb78311b78a5c392a8eb567" translate="yes" xml:space="preserve">
          <source>Good programmers have &amp;mdash; for decades &amp;mdash; maintained their own skeleton &quot;template&quot; programs for a variety of program types; simply load a template into a text editor and you&amp;rsquo;ve got a good start to the program&amp;hellip;</source>
          <target state="translated">훌륭한 프로그래머는 수십 년 동안 다양한 프로그램 유형에 대한 자체 &quot;템플릿&quot;프로그램을 유지해 왔습니다. 템플릿을 텍스트 편집기에로드하기 만하면 프로그램을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79b4a37e7986f285a68bde2a7f6753b7d96b28bf" translate="yes" xml:space="preserve">
          <source>Good programmers have &amp;mdash; for decades &amp;mdash; maintained their own skeleton &amp;ldquo;template&amp;rdquo; programs for a variety of program types; simply load a template into a text editor and you&amp;rsquo;ve got a good start to the program&amp;hellip;</source>
          <target state="translated">훌륭한 프로그래머는 수십 년 동안 다양한 프로그램 유형에 대해 고유 한 기본 &quot;템플릿&quot;프로그램을 유지해 왔습니다. 템플릿을 텍스트 편집기에로드하기 만하면 프로그램을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bb1297cd4586126018027c7f1e1612420c22c4d" translate="yes" xml:space="preserve">
          <source>Green: COB-COLOR-GREEN</source>
          <target state="translated">그린 : COB-COLOR-GREEN</target>
        </trans-unit>
        <trans-unit id="7c42686edc5c14ca17081cedfebfa14c924ebc58" translate="yes" xml:space="preserve">
          <source>Group Item</source>
          <target state="translated">그룹 아이템</target>
        </trans-unit>
        <trans-unit id="df7d4a9ed92798538291678b66f3ab2363cff6fa" translate="yes" xml:space="preserve">
          <source>Group Item &amp;mdash; A group item in which debugging information generated by a &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; section in the declaratives area of the procedure division will place information documenting why the &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; procedure was invoked. Consult the &lt;code&gt;DECLARATIVES&lt;/code&gt; (see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) documentation for information on the structure of this register.</source>
          <target state="translated">그룹 항목 &amp;mdash; 프로 시저 분할의 선언 영역 에있는 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; 섹션에 의해 생성 된 디버깅 정보 가 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; 프로 시저가 호출 된 이유를 문서화하는 정보를 배치 하는 그룹 항목입니다 . 상담 호 &lt;code&gt;DECLARATIVES&lt;/code&gt; (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES를&lt;/a&gt; 이 레지스터의 구조에 대한 정보) 문서를.</target>
        </trans-unit>
        <trans-unit id="abf442e977221f7e251a5aee4a674647ed69f44a" translate="yes" xml:space="preserve">
          <source>Group Item &amp;mdash; A group item in which debugging information generated by a&lt;code&gt;USE FOR DEBUGGING&lt;/code&gt;section in the declaratives area of the procedure division will place information documenting why the&lt;code&gt;USE FOR DEBUGGING&lt;/code&gt;procedure was invoked. Consult the&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) documentation for information on the structure of this register.</source>
          <target state="translated">그룹 항목 &amp;mdash; 프로 시저 부서의 선언 영역 에있는 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; 섹션에서 생성 된 디버깅 정보 가 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; 프로 시저가 호출 된 이유를 설명하는 정보를 배치 하는 그룹 항목입니다 . 상담 호 &lt;code&gt;DECLARATIVES&lt;/code&gt; (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES를&lt;/a&gt; 이 레지스터의 구조에 대한 정보) 문서를.</target>
        </trans-unit>
        <trans-unit id="31b43f990792fb2f0f7720e964fcf810fe794cb0" translate="yes" xml:space="preserve">
          <source>Group items (those without  &lt;code&gt;PICTURE&lt;/code&gt; clauses) are frequently used to describe entire lines of a report, while elementary items (those with a picture clause) are frequently used to describe specific fields of information on the report. When this coding convention is being used, group items will have &lt;code&gt;LINE&lt;/code&gt; (see &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;) clauses and no &lt;code&gt;COLUMN&lt;/code&gt; (see &lt;a href=&quot;#COLUMN&quot;&gt;COLUMN&lt;/a&gt;) clauses while elementary items will be specified the other way around.</source>
          <target state="translated">그룹 항목 ( &lt;code&gt;PICTURE&lt;/code&gt; 절이 없는 항목)은 보고서의 전체 행을 설명하는 데 자주 사용되는 반면, 기본 항목 (그림 절이있는 항목)은 보고서의 특정 정보 필드를 설명하는 데 자주 사용됩니다. 이 코딩 규칙을 사용중인 경우, 항목을 그룹화해야합니다 &lt;code&gt;LINE&lt;/code&gt; (참조 &lt;a href=&quot;#LINE&quot;&gt;LINE을&lt;/a&gt; ) 조항없이 &lt;code&gt;COLUMN&lt;/code&gt; (참조 &lt;a href=&quot;#COLUMN&quot;&gt;COLUMN을&lt;/a&gt; 기본 항목 주위에 다른 방법으로 지정됩니다 동안) 조항.</target>
        </trans-unit>
        <trans-unit id="810a65e9b0bdcfef9d822c231c10d01c65b32ddf" translate="yes" xml:space="preserve">
          <source>Group items (those without&lt;code&gt;PICTURE&lt;/code&gt;</source>
          <target state="translated">그룹 항목 ( &lt;code&gt;PICTURE&lt;/code&gt; 이없는 항목)</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="fa57db087f0e8c33baf60078a3ea31594a8db65b" translate="yes" xml:space="preserve">
          <source>HANDLE, HAS-CHILDREN, HEADING-COLOR, HEADING-DIVIDER-COLOR, HEADING-FONT, HEADING, HEAVY, HEIGHT-IN-CELLS, HIDDEN-DATA, HIGH-COLOR, HIGHEST-ALGEBRAIC, HIGHLIGHT, HIGH-VALUES, HIGH-VALUE, HOT-TRACK, HSCROLL-POS, HSCROLL</source>
          <target state="translated">핸들, HAS-CHILDREN, HEADING-COLOR, HEADING-DIVIDER-COLOR, HEADING-FONT, HEADING, HEAVY, HEIGHT-IN-CELLS, HIDDEN-DATA, HIGH-COLOR, HIGHEST-ALGEBRAIC, HIGHLIGHT, HIGH-VALUES, HIGH- 값, 핫 트랙, HSCROLL-POS, HSCROLL</target>
        </trans-unit>
        <trans-unit id="89a17ef0f66b4296a009bd40714a7d880bc71878" translate="yes" xml:space="preserve">
          <source>HEADING, HIGHEST-ALGEBRAIC, HIGHLIGHT, HIGH-VALUE, HIGH-VALUES</source>
          <target state="translated">청각, 최고 대수, 하이라이트, 고가, 고가</target>
        </trans-unit>
        <trans-unit id="30cfc7dc90ba24ab43e38507c7e4463f0560ba02" translate="yes" xml:space="preserve">
          <source>HIGHEST-ALGEBRAIC Function Syntax</source>
          <target state="translated">최고 대수 함수 구문</target>
        </trans-unit>
        <trans-unit id="d60066848e06a51085c8e2354e105347e3c601c8" translate="yes" xml:space="preserve">
          <source>HIGHLIGHT Attribute Syntax</source>
          <target state="translated">하이라이트 속성 구문</target>
        </trans-unit>
        <trans-unit id="020f748f595dbf9466daa5cd4e6bc7d9ede66c6f" translate="yes" xml:space="preserve">
          <source>Had there been at least one space to the left and/or the right of the &lt;code&gt;-&lt;/code&gt;, there would have been no ambiguity &amp;mdash; the compiler would have been forced to use the individual &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; data items.</source>
          <target state="translated">왼쪽 및 / 또는 오른쪽에 적어도 하나 개의 공간이 있었다면 &lt;code&gt;-&lt;/code&gt; ,이되었을 것이다 모호함 - 컴파일러는 개인 사용을 강요했을 &lt;code&gt;C&lt;/code&gt; 와 &lt;code&gt;D&lt;/code&gt; 의 데이터 항목을.</target>
        </trans-unit>
        <trans-unit id="8c6979d233b84b4e040cc3b6f33204115bd4f223" translate="yes" xml:space="preserve">
          <source>Had there been at least one space to the left and/or the right of the&lt;code&gt;-&lt;/code&gt; there would have been no ambiguity &amp;mdash; the compiler would have been forced to use the individual&lt;code&gt;C&lt;/code&gt;and&lt;code&gt;D&lt;/code&gt;data items.</source>
          <target state="translated">왼쪽 및 / 또는 오른쪽에 적어도 하나 개의 공간이 있었다면 &lt;code&gt;-&lt;/code&gt; 모호함이 없었을 것입니다 - 컴파일러는 개인 사용을 강요했을 &lt;code&gt;C&lt;/code&gt; 와 &lt;code&gt;D&lt;/code&gt; 의 데이터 항목을.</target>
        </trans-unit>
        <trans-unit id="87a433cf0bc677c32d39cd5b979920082688b536" translate="yes" xml:space="preserve">
          <source>Heading Area</source>
          <target state="translated">제목 영역</target>
        </trans-unit>
        <trans-unit id="2ac9d02efcfc8c69f3e81956659315a414e9db18" translate="yes" xml:space="preserve">
          <source>Heading Area &amp;mdash; An exception to this is the situation where the report heading report group contains the &lt;code&gt;NEXT GROUP NEXT PAGE&lt;/code&gt; (see &lt;a href=&quot;#NEXT-GROUP&quot;&gt;NEXT GROUP&lt;/a&gt;) option; in those cases, the report heading will be presented on a page by itself (anywhere on that page) at the beginning of the report.</source>
          <target state="translated">머리글 영역 &amp;mdash; 보고서 머리글 보고서 그룹에 &lt;code&gt;NEXT GROUP NEXT PAGE&lt;/code&gt; ( &lt;a href=&quot;#NEXT-GROUP&quot;&gt;NEXT GROUP&lt;/a&gt; 참조 ) 옵션이 포함 된 경우는 예외입니다 . 이 경우 보고서 머리글은 보고서 시작시 페이지에 단독으로 (해당 페이지의 모든 위치) 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cbbb9cee65c6576a367576c2ac65ada91311b34f" translate="yes" xml:space="preserve">
          <source>Heading Area &amp;mdash; An exception to this is the situation where the report heading report group contains the&lt;code&gt;NEXT GROUP NEXT PAGE&lt;/code&gt;(see &lt;a href=&quot;#NEXT-GROUP&quot;&gt;NEXT GROUP&lt;/a&gt;) option; in those cases, the report heading will be presented on a page by itself (anywhere on that page) at the beginning of the report.</source>
          <target state="translated">제목 영역 &amp;mdash; 예외는 보고서 제목 보고서 그룹에 &lt;code&gt;NEXT GROUP NEXT PAGE&lt;/code&gt; ( &lt;a href=&quot;#NEXT-GROUP&quot;&gt;다음 그룹&lt;/a&gt; 참조 ) 옵션이 포함 된 경우입니다. 이 경우 보고서 머리글은 보고서 시작 부분에 페이지 자체 (해당 페이지의 아무 곳이나)에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9a3fc3dac7c2610f19172d33b654b99f82029bf8" translate="yes" xml:space="preserve">
          <source>Here are a few examples:</source>
          <target state="translated">다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="a58d0be2a26b29065720289affde96b396953bc6" translate="yes" xml:space="preserve">
          <source>Here are some examples of how the precedence of operations affects the results of arithmetic expressions (all examples use numeric literals, to simplify the discussion).</source>
          <target state="translated">다음은 연산 우선 순위가 산술 표현식의 결과에 어떤 영향을 미치는지에 대한 몇 가지 예입니다 (모든 예는 토론을 단순화하기 위해 숫자 리터럴을 사용합니다).</target>
        </trans-unit>
        <trans-unit id="ce8b7658bf191725329e97e66717da8863c93fce" translate="yes" xml:space="preserve">
          <source>Here are the facts &amp;mdash; draw your own conclusions as to which approach is more appropriate under which circumstances.</source>
          <target state="translated">사실은 다음과 같습니다. 어떤 상황에서 어떤 접근법이 더 적합한 지에 대한 자신의 결론을 도출하십시오.</target>
        </trans-unit>
        <trans-unit id="71e41b379565b9db9a0898e306e44094c8f202bb" translate="yes" xml:space="preserve">
          <source>Here are the meanings of the three options:</source>
          <target state="translated">세 가지 옵션의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="53cbe05ea3a4478bf935f4356ab4ff0f5e1c960c" translate="yes" xml:space="preserve">
          <source>Here are the relevant sections of code in a program named</source>
          <target state="translated">다음은 이름이 지정된 프로그램의 관련 코드 섹션입니다.</target>
        </trans-unit>
        <trans-unit id="8db79160667581172099438ddb7cbe10fdc25a56" translate="yes" xml:space="preserve">
          <source>Here are the relevant sections of code in a program named &quot;testprog&quot;, which is designed to simply announce if SWITCH-1 is on:</source>
          <target state="translated">다음은 &quot;testprog&quot;라는 프로그램의 관련 코드 섹션입니다.이 코드는 SWITCH-1이 켜져있는 경우 간단히 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="4806c2364021b8f8145a30057c39a5142245883f" translate="yes" xml:space="preserve">
          <source>Here are the results:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6bcf44b499d0088da0556d2de36d212cd7d4aaa3" translate="yes" xml:space="preserve">
          <source>Here are the rules about GnuCOBOL dynamically-loadable modules:</source>
          <target state="translated">GnuCOBOL 동적으로로드 가능한 모듈에 대한 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d98760fd5f7d0d451fc2f1b70dda01b46952cd2b" translate="yes" xml:space="preserve">
          <source>Here are two different &quot;Hello World&quot; applications &amp;mdash; one written in Java and the second in GnuCOBOL. First, the Java version:</source>
          <target state="translated">다음은 두 가지 다른 &quot;Hello World&quot;응용 프로그램입니다. 하나는 Java로 작성되고 다른 하나는 GnuCOBOL로 작성됩니다. 먼저, Java 버전 :</target>
        </trans-unit>
        <trans-unit id="9a7a5c011f0ce663c0dc595e94b546e1a82c50ac" translate="yes" xml:space="preserve">
          <source>Here are two different &amp;ldquo;Hello World&amp;rdquo; applications, one written in Java and the second in GnuCOBOL. First, the Java version:</source>
          <target state="translated">다음은 두 가지 &quot;Hello World&quot;응용 프로그램입니다. 하나는 Java로 작성되고 다른 하나는 GnuCOBOL로 작성되었습니다. 첫째, Java 버전 :</target>
        </trans-unit>
        <trans-unit id="e6bcd662dbb0c6100434bd63900ae3c2799a7347" translate="yes" xml:space="preserve">
          <source>Here are two examples of using &lt;code&gt;cobcrun&lt;/code&gt;. First, on a Unix, OSX or Windows/Cygwin system:</source>
          <target state="translated">다음은 &lt;code&gt;cobcrun&lt;/code&gt; 사용의 두 가지 예입니다 . 첫째, Unix, OSX 또는 Windows / Cygwin 시스템에서 :</target>
        </trans-unit>
        <trans-unit id="2486c63ce113fa9dfa91ee5ea183529c4d50239f" translate="yes" xml:space="preserve">
          <source>Here are two examples of using&lt;code&gt;cobcrun&lt;/code&gt; First, on a Unix, OSX or Windows/Cygwin system:</source>
          <target state="translated">다음은 Unix, OSX 또는 Windows / Cygwin 시스템에서 &lt;code&gt;cobcrun&lt;/code&gt; First 를 사용하는 두 가지 예입니다 .</target>
        </trans-unit>
        <trans-unit id="88f0b25a36a42c34f75db34b7878e30378e348fc" translate="yes" xml:space="preserve">
          <source>Here is a sample program that illustrates the EVALUATE statement.</source>
          <target state="translated">다음은 EVALUATE 문을 보여주는 샘플 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="b44351443986b8d6208b8077f937b80d2c5d797f" translate="yes" xml:space="preserve">
          <source>Here is an example of a main program (DEMOFACT) that calls both a subprogram (SUB) and a user-defined function (FUNC) to compute the factorial value of a number.</source>
          <target state="translated">다음은 서브 프로그램 (SUB)과 사용자 정의 함수 (FUNC)를 모두 호출하여 숫자의 계승 값을 계산하는 기본 프로그램 (DEMOFACT)의 예입니다.</target>
        </trans-unit>
        <trans-unit id="fce56f05dd0a684307248e0509281b28f6150e2a" translate="yes" xml:space="preserve">
          <source>Here is an example. The following two GnuCOBOL statements both display the same result (27):</source>
          <target state="translated">다음은 예입니다. 다음 두 GnuCOBOL 문은 모두 동일한 결과를 표시합니다 (27).</target>
        </trans-unit>
        <trans-unit id="b6e578854c806b2cf1a7f51f1181b4443af68716" translate="yes" xml:space="preserve">
          <source>Here is how the main program and the three subprograms could be compiled if the three subprograms are to be dynamic:</source>
          <target state="translated">다음은 세 개의 서브 프로그램이 동적 일 경우 메인 프로그램과 세 개의 서브 프로그램을 컴파일하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b8a4250afe2b9b703be52c8963f7c7e83af93bec" translate="yes" xml:space="preserve">
          <source>Here is how these four programs would be compiled if the three subprograms are to be static:</source>
          <target state="translated">세 개의 서브 프로그램이 정적 인 경우이 네 가지 프로그램을 컴파일하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="beb1c1603f299093bba7034e28d01c9ea9428c93" translate="yes" xml:space="preserve">
          <source>Here is the data that the program will be reading. Each record reflects the aggregated benchmark scoring for one particular CPU, as scores for benchmarks against that CPU have been reported to the &lt;a href=&quot;https://gnucobol.sourceforge.io/HTML/cpubenchmark.net&quot;&gt;cpubenchmark.net&lt;/a&gt; website by their PassMark benchmark software. The data consists of four fields. Fields are separated from one another by a single comma. The descriptions of the fields are as follows:</source>
          <target state="translated">다음은 프로그램이 읽을 데이터입니다. 해당 CPU에 대한 벤치 마크 점수 가 PassMark 벤치 마크 소프트웨어에 의해 &lt;a href=&quot;https://gnucobol.sourceforge.io/HTML/cpubenchmark.net&quot;&gt;cpubenchmark.net&lt;/a&gt; 웹 사이트에 보고되었으므로 각 레코드는 특정 CPU에 대한 집계 된 벤치 마크 점수를 반영합니다 . 데이터는 4 개의 필드로 구성됩니다. 필드는 하나의 쉼표로 서로 구분됩니다. 필드에 대한 설명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3885b22c6e4bdc48af657c6fedb7ca8f97433747" translate="yes" xml:space="preserve">
          <source>Here is the data that the program will be reading. Each record reflects the aggregated benchmark scoring for one particular CPU, as scores for benchmarks against that CPU have been reported to the &lt;a href=&quot;https://open-cobol.sourceforge.io/HTML/cpubenchmark.net&quot;&gt;cpubenchmark.net&lt;/a&gt; website by their PassMark benchmark software. The data consists of four fields. Fields are separated from one another by a single comma. The descriptions of the fields are as follows:</source>
          <target state="translated">다음은 프로그램이 읽을 데이터입니다. 각 레코드는 해당 CPU에 대한 벤치 마크 점수 가 PassMark 벤치 마크 소프트웨어에 의해 &lt;a href=&quot;https://open-cobol.sourceforge.io/HTML/cpubenchmark.net&quot;&gt;cpubenchmark.net&lt;/a&gt; 웹 사이트에 보고되었으므로 특정 CPU에 대한 집계 된 벤치 마크 점수를 반영합니다 . 데이터는 네 개의 필드로 구성됩니다. 필드는 단일 쉼표로 서로 구분됩니다. 필드에 대한 설명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b01180e30ff342f12b30bea352d08df8ee331a14" translate="yes" xml:space="preserve">
          <source>Here is the listing of a GnuCOBOL program that uses 01-level constants to display the length (in bytes) of the various picture-less usage types.</source>
          <target state="translated">다음은 01 레벨 상수를 사용하여 다양한 그림이없는 사용 유형의 길이 (바이트)를 표시하는 GnuCOBOL 프로그램 목록입니다.</target>
        </trans-unit>
        <trans-unit id="1857cc7a022f0e1395961419f1f74e43d98e7680" translate="yes" xml:space="preserve">
          <source>Here is the program that will be producing the report. Pay attention to how the data is sorted and how the control hierarchy (&lt;code&gt;CONTROLS ARE&lt;/code&gt;) relates to the &lt;code&gt;SORT&lt;/code&gt;.</source>
          <target state="translated">다음은 보고서를 생성 할 프로그램입니다. 데이터가 정렬되는 방식과 컨트롤 계층 ( &lt;code&gt;CONTROLS ARE&lt;/code&gt; )이 &lt;code&gt;SORT&lt;/code&gt; 와 관련되는 방식에주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="73247c417733995d371c239937b20d07507d4db9" translate="yes" xml:space="preserve">
          <source>Here is the program that will be producing the report. Pay attention to how the data is sorted and how the control hierarchy &lt;code&gt;CONTROLS ARE&lt;/code&gt; relates to the&lt;code&gt;SORT&lt;/code&gt;</source>
          <target state="translated">보고서를 작성하는 프로그램은 다음과 같습니다. 데이터 정렬 방법과 제어 계층 구조 가 &lt;code&gt;SORT&lt;/code&gt; 와 어떤 관련이 &lt;code&gt;CONTROLS ARE&lt;/code&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="da6729e808d0a3e4a663c2fea411af7a2fdc2b58" translate="yes" xml:space="preserve">
          <source>Here we see that &lt;code&gt;PROG2&lt;/code&gt; is nested inside of &lt;code&gt;PROG1&lt;/code&gt; because there is no &lt;code&gt;END PROGRAM&lt;/code&gt; marker separating them. This means that data items or files defined within &lt;code&gt;PROG1&lt;/code&gt; can be used within &lt;code&gt;PROG2&lt;/code&gt; simply by attaching the &lt;code&gt;GLOBAL&lt;/code&gt; (see &lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt;) attribute to them back in &lt;code&gt;PROG1&lt;/code&gt; when they are defined.</source>
          <target state="translated">여기서 우리는 &lt;code&gt;PROG2&lt;/code&gt; 를 구분하는 &lt;code&gt;END PROGRAM&lt;/code&gt; 마커 가 없기 때문에 &lt;code&gt;PROG1&lt;/code&gt; 내부에 중첩되어 있음을 알 수 있습니다. 즉, &lt;code&gt;PROG1&lt;/code&gt; 내에 정의 된 데이터 항목 또는 파일 은 정의 될 때 &lt;code&gt;PROG1&lt;/code&gt; 에서 다시 &lt;code&gt;GLOBAL&lt;/code&gt; ( &lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt; 참조 ) 속성을 해당 항목에 다시 첨부하여 &lt;code&gt;PROG2&lt;/code&gt; 내에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5a81b08e879fde5dd2a59dae3f46849e9f50742" translate="yes" xml:space="preserve">
          <source>Here we see that PROG2 is nested inside of PROG1 because there is no&lt;code&gt;END PROGRAM&lt;/code&gt;marker separating them. This means that data items or files defined within PROG1 can be used within PROG2 simply by attaching the&lt;code&gt;GLOBAL&lt;/code&gt;(see &lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt;) attribute to them back in PROG1 when they are defined.</source>
          <target state="translated">여기서는 PROG2가 분리되는 &lt;code&gt;END PROGRAM&lt;/code&gt; 마커 가 없기 때문에 PROG2가 PROG1 안에 중첩되어 있음을 알 수 있습니다. 이는 PROG1에 정의 된 데이터 항목 또는 파일을 정의 할 때 &lt;code&gt;GLOBAL&lt;/code&gt; ( &lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt; 참조 ) 속성을 PROG1에 다시 첨부하여 PROG2 내에서 사용할 수 있음 을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9e665b8afaa854f3affd19ae081739fadefc957c" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a demonstration:</source>
          <target state="translated">데모는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1bb3a890739a2d89878b41828136b7843797b0c4" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a more practical view of the difference. Let&amp;rsquo;s say that a table has 1,000 entries in it. With a sequential search, on average, you&amp;rsquo;ll have to check 500 of them to find an entry and you&amp;rsquo;ll have to look at all 1,000 of them to find that an entry doesn&amp;rsquo;t exist.</source>
          <target state="translated">차이점에 대한보다 실용적인 견해는 다음과 같습니다. 테이블에 1,000 개의 항목이 있다고 가정 해 봅시다. 순차적으로 검색하는 경우 평균적으로 항목을 찾기 위해 500 개를 확인해야하며 항목이 존재하지 않는 것을 찾으려면 1,000 개를 모두 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="5e93bdc7d9e913c109cf4064444cedee83b88ddb" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a sample of a GnuCOBOL program that CALLs a C subprogram.</source>
          <target state="translated">다음은 C 서브 프로그램을 호출하는 GnuCOBOL 프로그램의 샘플입니다.</target>
        </trans-unit>
        <trans-unit id="bce0f5ae6fe98feb4beb66b9de11f14f54d3934d" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a small example:</source>
          <target state="translated">다음은 작은 예입니다.</target>
        </trans-unit>
        <trans-unit id="79a379c34c53ce83d07e71356345ea69136a74d1" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b4f96988044521adc26ab35ce61bb5f09db1123c" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the output of the compilation process as well as the program&amp;rsquo;s execution. The example assumes a Windows system with a GnuCOBOL build that uses the GNU C compiler on that system; the technique works equally well regardless of which C compiler and which operating system you&amp;rsquo;re using.</source>
          <target state="translated">다음은 컴파일 프로세스의 출력과 프로그램 실행입니다. 이 예에서는 해당 시스템에서 GNU C 컴파일러를 사용하는 GnuCOBOL 빌드가있는 Windows 시스템을 가정합니다. 이 기술은 사용하는 C 컴파일러와 운영 체제에 관계없이 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="54b1a90f72334cf67c79da3608b8cff7cc194a79" translate="yes" xml:space="preserve">
          <source>Hexadecimal</source>
          <target state="translated">Hexadecimal</target>
        </trans-unit>
        <trans-unit id="411f51a5654b397be9062ca82d9069ac5e760156" translate="yes" xml:space="preserve">
          <source>Hexadecimal Alphanumeric Literal</source>
          <target state="translated">16 진 영숫자 리터럴</target>
        </trans-unit>
        <trans-unit id="0622237faae035a0d62bd2b8400c09913d5beb12" translate="yes" xml:space="preserve">
          <source>Hexadecimal Numeric Literal</source>
          <target state="translated">16 진 숫자 리터럴</target>
        </trans-unit>
        <trans-unit id="94ab07f464da8a3b187f31192ac4d12a08adf1a8" translate="yes" xml:space="preserve">
          <source>Hexadecimal number using &lt;code&gt;H#&lt;/code&gt; or &lt;code&gt;X#&lt;/code&gt; &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;H#&lt;/code&gt; 또는 &lt;code&gt;X#&lt;/code&gt; '를 사용하는 16 진수</target>
        </trans-unit>
        <trans-unit id="9b5d84e4c523dc629848bb4349e680f8bf34c64b" translate="yes" xml:space="preserve">
          <source>Hexadecimal numeric literals</source>
          <target state="translated">16 진 숫자 리터럴</target>
        </trans-unit>
        <trans-unit id="fc83f87e3f62574b840ab2334e64d62930fb1c3c" translate="yes" xml:space="preserve">
          <source>Historically in the early 60&amp;rsquo;s programs were first punched on to paper tape and by the mid 60&amp;rsquo;s that was replaced almost totally, by punched cards although paper tape was still used by programmers for the odd few changes to their sources held on magnetic tape or disk as a portable paper tape punch could be put in your pocket. Now the problem with punched cards were there was 2,000 cards per box and that they could and did, get dropped. So, cc (column) 1 through 6 had the card sequence number in and that way if a box was dropped they could be feed in to a card sorter to be fixed. This was after the cards was cleaned up so that they were all in the same direction which one corner cut out helped.</source>
          <target state="translated">역사적으로 60 년대 초의 프로그램은 종이 테이프에 처음으로 펀칭되었고 60 년대 중반에는 거의 완전히 교체 된 펀치 카드로 프로그래머가 종이 테이프를 사용했지만 마그네틱 테이프 또는 디스크에 저장된 소스의 이상한 변화는 프로그래머가 여전히 사용했습니다 휴대용 종이 테이프 펀치를 주머니에 넣을 수 있습니다. 이제 천공 카드의 문제점은 상자 당 2,000 장의 카드가 있었고 떨어 뜨릴 수 있다는 것입니다. 따라서 cc (열) 1에서 6까지는 카드 시퀀스 번호를 가지고 있으며 상자를 떨어 뜨린 경우 카드 분류기로 공급하여 고정 할 수 있습니다. 이것은 한 쪽 모서리를 잘라낸 것과 같은 방향이되도록 카드를 정리 한 후에였습니다.</target>
        </trans-unit>
        <trans-unit id="82581b08d1abc17171e1f2f9cf9815374d6d8df7" translate="yes" xml:space="preserve">
          <source>Historically, back in the days when punched-cards were used to submit COBOL program source to a COBOL compiler, this part of a COBOL statement was reserved for a six-digit sequence number. While the contents of this area are ignored by COBOL compilers, it existed so that a program actually punched on 80-character cards could &amp;mdash; if the card deck were dropped on the floor &amp;mdash; be run through a card sorter machine and restored to it&amp;rsquo;s proper sequence. Of course, this isn&amp;rsquo;t necessary today; if truth be told, it hasn&amp;rsquo;t been necessary for a long time.</source>
          <target state="translated">역사적으로 펀치 카드를 사용하여 COBOL 프로그램 소스를 COBOL 컴파일러에 제출했던 시절에이 COBOL 문의이 부분은 6 자리 시퀀스 번호로 예약되었습니다. 이 영역의 내용은 COBOL 컴파일러에 의해 무시되지만 실제로 80 자 카드에 펀칭 된 프로그램 (카드 데크를 바닥에 떨어 뜨린 경우)이 카드 분류기 시스템을 통해 실행되고 올바른 순서로 복원 될 수 있습니다. . 물론 오늘날에는 필요하지 않습니다. 진실을 말하면 오랫동안 필요하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="02647b82d9fa83c81d555404d1e10b603758c168" translate="yes" xml:space="preserve">
          <source>Historically, back in the days when punched-cards were used to submit COBOL program source to a COBOL compiler, this part of a COBOL statement was reserved for a six-digit sequence number. While the contents of this area are ignored by COBOL compilers, it existed so that a program actually punched on 80-character cards could &amp;mdash; if the card deck were dropped on the floor &amp;mdash; be run through a card sorter machine and restored to its proper sequence. Of course, this isn&amp;rsquo;t necessary today; if truth be told, it hasn&amp;rsquo;t been necessary for a long time.</source>
          <target state="translated">역사적으로 천공 카드가 COBOL 프로그램 소스를 COBOL 컴파일러에 제출하는 데 사용되었던 시절에는 COBOL 문의이 부분이 6 자리 시퀀스 번호로 예약되었습니다. 이 영역의 내용은 COBOL 컴파일러에 의해 무시되지만 실제로 80 자 카드에 펀칭 된 프로그램이 카드 데크가 바닥에 떨어질 경우 카드 분류기 기계를 통해 실행되고 적절한 순서로 복원 될 수 있도록 존재했습니다. . 물론 오늘날에는 이것이 필요하지 않습니다. 진실을 말하면 오랫동안 필요하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0df9e10180565ea1110b91a867b356bd0e25bf9c" translate="yes" xml:space="preserve">
          <source>How then do we inform the compiler that the &lt;code&gt;DISPLAY&lt;/code&gt; statement is outside the scope of the &lt;code&gt;IF&lt;/code&gt;?</source>
          <target state="translated">그러면 컴파일러에게 &lt;code&gt;DISPLAY&lt;/code&gt; 문이 &lt;code&gt;IF&lt;/code&gt; 범위 밖에 있음을 어떻게 알립니 까?</target>
        </trans-unit>
        <trans-unit id="dbfbb76720b9c478938cb351772ad799b84f9efe" translate="yes" xml:space="preserve">
          <source>I also ran the tests multiple times, just to make sure I had consistent results (I did). Like I mentioned earlier, this is not a rigorous, scientific benchmark of numeric performance; it&amp;rsquo;s just a quick-and-dirty comparison.</source>
          <target state="translated">또한 일관된 결과를 얻었는지 확인하기 위해 테스트를 여러 번 실행했습니다. 앞에서 언급했듯이 이것은 수치 적 성능에 대한 엄격하고 과학적인 벤치 마크가 아닙니다. 그것은 단지 더럽고 더러운 비교 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="555eb23964b638ebb4898ef46762a788413b2a7a" translate="yes" xml:space="preserve">
          <source>I always include a numeric prefix to all procedure names I define, for the reasons stated earlier.</source>
          <target state="translated">앞서 정의한 이유로 항상 정의한 모든 프로 시저 이름에 숫자 접두사를 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="6ef71f90a853f2945a57020e6c1ee95aebd594b3" translate="yes" xml:space="preserve">
          <source>I changed the &lt;code&gt;CONTROLS ARE&lt;/code&gt; clause on the sample program from this:</source>
          <target state="translated">샘플 프로그램 의 &lt;code&gt;CONTROLS ARE&lt;/code&gt; 절을 다음과 같이 변경했습니다 .</target>
        </trans-unit>
        <trans-unit id="df6a4fe99929dd991e0202127b86aa20cecf96af" translate="yes" xml:space="preserve">
          <source>I changed the&lt;code&gt;CONTROLS ARE&lt;/code&gt;clause on the sample program from this:</source>
          <target state="translated">샘플 프로그램에서 &lt;code&gt;CONTROLS ARE&lt;/code&gt; 절을 다음과 같이 변경했습니다 .</target>
        </trans-unit>
        <trans-unit id="d4babbd3edc9eb4d910c787c66392fcc67f2231b" translate="yes" xml:space="preserve">
          <source>I do not use &lt;code&gt;THRU&lt;/code&gt; on any &lt;code&gt;MERGE&lt;/code&gt;, &lt;code&gt;PERFORM&lt;/code&gt; or &lt;code&gt;SORT&lt;/code&gt; statement unless the programming standards of the shop in which I am working require it. My reasoning for this is that it is too easy to accidentally introduce a new procedure into the scope of a &lt;code&gt;THRU&lt;/code&gt;.</source>
          <target state="translated">작업중인 상점의 프로그래밍 표준에서 요구하지 않는 한 &lt;code&gt;MERGE&lt;/code&gt; , &lt;code&gt;PERFORM&lt;/code&gt; 또는 &lt;code&gt;SORT&lt;/code&gt; 문 에 &lt;code&gt;THRU&lt;/code&gt; 를 사용하지 않습니다 . 저의 이유는 &lt;code&gt;THRU&lt;/code&gt; 범위에 실수로 새로운 절차를 도입하기가 너무 쉽기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="8d7255df40c7e6bd55c76738ac87c79c48b55013" translate="yes" xml:space="preserve">
          <source>I do not use&lt;code&gt;THRU&lt;/code&gt;on any&lt;code&gt;MERGE&lt;/code&gt;&lt;code&gt;PERFORM&lt;/code&gt;or&lt;code&gt;SORT&lt;/code&gt;statement unless the programming standards of the shop in which I am working require it. My reasoning for this is that it is too easy to accidentally introduce a new procedure into the scope of a&lt;code&gt;THRU&lt;/code&gt;</source>
          <target state="translated">작업중인 상점의 프로그래밍 표준에서 요구하지 않는 한 &lt;code&gt;MERGE&lt;/code&gt; &lt;code&gt;PERFORM&lt;/code&gt; 또는 &lt;code&gt;SORT&lt;/code&gt; 문 에 &lt;code&gt;THRU&lt;/code&gt; 를 사용하지 않습니다 . 이것에 대한 나의 추론은 실수로 &lt;code&gt;THRU&lt;/code&gt; 의 범위에 새로운 절차를 도입하는 것이 너무 쉽다는 것입니다</target>
        </trans-unit>
        <trans-unit id="1fbc97a4457717dc23d1ecc1bf25f471eabb9c4f" translate="yes" xml:space="preserve">
          <source>I like to use procedure division paragraphs and sections as follows:</source>
          <target state="translated">절차 구분 단락과 섹션을 다음과 같이 사용하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="80ed72858cef207934e285ac054f1c8a269fc88f" translate="yes" xml:space="preserve">
          <source>I-O status &quot;1x&quot;</source>
          <target state="translated">IO 상태 &quot;1x&quot;</target>
        </trans-unit>
        <trans-unit id="e7876f32dd29146c722eec80cdba831c36ef9026" translate="yes" xml:space="preserve">
          <source>I-O status &quot;2x&quot;</source>
          <target state="translated">IO 상태 &quot;2x&quot;</target>
        </trans-unit>
        <trans-unit id="76b397e0ec9019d1f6c9d9402f9be35add987c62" translate="yes" xml:space="preserve">
          <source>I-O status &quot;3x&quot;</source>
          <target state="translated">IO 상태 &quot;3x&quot;</target>
        </trans-unit>
        <trans-unit id="6eff1612faad7c99ae78ea1e6080ebc0dc3c4df1" translate="yes" xml:space="preserve">
          <source>I-O status &quot;4x&quot;</source>
          <target state="translated">IO 상태 &quot;4x&quot;</target>
        </trans-unit>
        <trans-unit id="67e793587f319a335dc7c63a71a23c530563d185" translate="yes" xml:space="preserve">
          <source>I-O status &quot;5x&quot;</source>
          <target state="translated">IO 상태 &quot;5x&quot;</target>
        </trans-unit>
        <trans-unit id="b8524f001cba70110ae60dee01287daded416b11" translate="yes" xml:space="preserve">
          <source>I-O status &quot;6x&quot;</source>
          <target state="translated">IO 상태 &quot;6x&quot;</target>
        </trans-unit>
        <trans-unit id="be335b5a5eadd43e4b4e63cf77557e87542095cf" translate="yes" xml:space="preserve">
          <source>I-O status &quot;9x&quot;</source>
          <target state="translated">IO 상태 &quot;9x&quot;</target>
        </trans-unit>
        <trans-unit id="6a40883c56a23e578d1618cce3df76e43d5b7350" translate="yes" xml:space="preserve">
          <source>I-O status &lt;code&gt;1x&lt;/code&gt;</source>
          <target state="translated">IO 상태 &lt;code&gt;1x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="87ff1a1275bf109eaff56708cd4e221f5ca0d8bc" translate="yes" xml:space="preserve">
          <source>I-O status &lt;code&gt;2x&lt;/code&gt;</source>
          <target state="translated">IO 상태 &lt;code&gt;2x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be7973453310dbe96df8c3018a9424798391b2e4" translate="yes" xml:space="preserve">
          <source>I-O status &lt;code&gt;3x&lt;/code&gt;</source>
          <target state="translated">IO 상태 &lt;code&gt;3x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2458183a044f5219cfb3b7ef88f92e2d8c9e5f33" translate="yes" xml:space="preserve">
          <source>I-O status &lt;code&gt;4x&lt;/code&gt;</source>
          <target state="translated">IO 상태 &lt;code&gt;4x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="38cedebc1b1941a50e028e9d6550e769870941c1" translate="yes" xml:space="preserve">
          <source>I-O status &lt;code&gt;5x&lt;/code&gt;</source>
          <target state="translated">IO 상태 &lt;code&gt;5x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3d793e81b9a3c98c450a59713300bf381d8058c" translate="yes" xml:space="preserve">
          <source>I-O status &lt;code&gt;6x&lt;/code&gt;</source>
          <target state="translated">IO 상태 &lt;code&gt;6x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="555a7b0c863d6be59d84386e7390b5bbffbf7505" translate="yes" xml:space="preserve">
          <source>I-O status &lt;code&gt;9x&lt;/code&gt;</source>
          <target state="translated">IO 상태 &lt;code&gt;9x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f12b2d4b4f8188676296a19fede62525110b1c0" translate="yes" xml:space="preserve">
          <source>I-O-CONTROL MULTIPLE FILE Syntax</source>
          <target state="translated">IO-CONTROL 다중 파일 구문</target>
        </trans-unit>
        <trans-unit id="6f75dae5c47d389ce684040629f1e36258a6ce54" translate="yes" xml:space="preserve">
          <source>I-O-CONTROL SAME AREA Syntax</source>
          <target state="translated">IO-CONTROL SAME AREA 구문</target>
        </trans-unit>
        <trans-unit id="bb6745092ff5da5fbe4ae9f7460a002043bade91" translate="yes" xml:space="preserve">
          <source>ICON, IDENTIFICATION, IDENTIFIED, ID, IF, IGNORE, IGNORING, IMPLEMENTS, INDEPENDENT, INDEXED, INDEX, INDICATE, INHERITS, INITIALISED, INITIALISE, INITIALIZED, INITIALIZE, INITIAL, INITIATE, INPUT-OUTPUT, INPUT, INQUIRE, INSERTION-INDEX, INSERT-ROWS, INSPECT, INSTALLATION, INTEGER-OF-BOOLEAN, INTEGER-OF-DATE, INTEGER-OF-DAY, INTEGER-OF-FORMATTED-DATE, INTEGER-PART, INTEGER, INTERFACE-ID, INTERFACE, INTERMEDIATE, INTO, INTRINSIC, INVALID, INVOKE, IN, I-O-CONTROL, I-O, IS, ITEM-TEXT, ITEM-TO-ADD, ITEM-TO-DELETE, ITEM-TO-EMPTY, ITEM-VALUE, ITEM</source>
          <target state="translated">아이콘, 식별, 식별, ID, IF, 무시, 무시, 구현, 독립, 색인, 색인, 표시, 상속, 초기화, 초기화, 초기화, 초기화, 삽입, 초기화, 다시 시작, 입력-출력 INSERT-ROWS, INSPECT, INSTALLATION, INTEGER-OF-BOOLEAN, INTEGER-OF-DATE, INTEGER-OF-DAY, INTEGER-OF-FORMATTED-DATE, INTEGER-PART, INTEGER, INTERFACE-ID, INTERFACE, INTERMEDIATE, INTO, INTRINSIC, INVALID, INVOKE, IN, IO-CONTROL, IO, IS, ITEM-TEXT, ITEM-TO-ADD, ITEM-TO-DELETE, ITEM-to-EMPTY, ITEM-VALUE, ITEM</target>
        </trans-unit>
        <trans-unit id="9c32595038680ec5b76e6c8935109525fa67eebc" translate="yes" xml:space="preserve">
          <source>ID, IDENTIFICATION, IF, IGNORE, IGNORING, IMPLEMENTS, IN, INDEX, INDEXED, INDICATE, INHERITS, INITIAL, INITIALISE, INITIALISED, INITIALIZE, INITIALIZED, INITIATE, INPUT, INPUT-OUTPUT, INSPECT, INSTALLATION, INTEGER, INTEGER-OF-BOOLEAN, INTEGER-OF-DATE, INTEGER-OF-DAY, INTEGER-OF-FORMATTED-DATE, INTEGER-PART, INTERFACE, INTERFACE-ID, INTERMEDIATE, INTO, INTRINSIC, INVALID, INVOKE, I-O, I-O-CONTROL, IS</source>
          <target state="translated">ID, 식별, IF, IGNORE, IGNORING, IMPLEMENTS, IN, INDEX, INDEXED, INDICATE, INITITS, INITIALISE, INITIALISED, INITIALISED, INITIALIZE, 초기화, 초기화, 입력, 입력-출력, 검사, 설치, 정수, 설치, 정수 BOOLEAN, 정수, 날짜, 정수, 정수 날짜, 정수, 인터페이스, 인터페이스 ID, 중간, INTO, INTRINSIC, INVALNSIC, INVOKE, IO, IO-CONTROL, IS</target>
        </trans-unit>
        <trans-unit id="9b9c55248e0c5e189619271ca0ded3b5bd005453" translate="yes" xml:space="preserve">
          <source>IDENTIFICATION DIVISION Syntax</source>
          <target state="translated">식별 구분 구문</target>
        </trans-unit>
        <trans-unit id="b825b4511a0db8bbe7c5d10a6be13d4b3f73d3e5" translate="yes" xml:space="preserve">
          <source>IF Syntax</source>
          <target state="translated">IF 구문</target>
        </trans-unit>
        <trans-unit id="8a579c7bbbf6cdd11286272217a8b94f74b4f75a" translate="yes" xml:space="preserve">
          <source>INITIALIZE Syntax</source>
          <target state="translated">초기화 구문</target>
        </trans-unit>
        <trans-unit id="f22feedf7bc3a1ceec5b7c202882c8aa6f0e185d" translate="yes" xml:space="preserve">
          <source>INITIATE Syntax</source>
          <target state="translated">초기화 구문</target>
        </trans-unit>
        <trans-unit id="4f5b873e331f2e93c7e38f36475cf57cbfec3d6a" translate="yes" xml:space="preserve">
          <source>INPUT-OUTPUT SECTION Syntax</source>
          <target state="translated">입력-출력 섹션 구문</target>
        </trans-unit>
        <trans-unit id="baa55ae57b9d3c323f03e28edc87f8c479cca623" translate="yes" xml:space="preserve">
          <source>INSPECT Syntax</source>
          <target state="translated">검사 구문</target>
        </trans-unit>
        <trans-unit id="078ab307f07f53957c6ec7a0918c5e4474c21ea5" translate="yes" xml:space="preserve">
          <source>INTEGER Function Syntax</source>
          <target state="translated">INTEGER 함수 구문</target>
        </trans-unit>
        <trans-unit id="c9e25e51f813fe8bc79fe92425c0aa73a9ead86d" translate="yes" xml:space="preserve">
          <source>INTEGER-OF-BOOLEAN Function Syntax</source>
          <target state="translated">INTEGER-OF-BOOLEAN 함수 구문</target>
        </trans-unit>
        <trans-unit id="2c22d504f0b728c455886a880af6cd5a9ad23315" translate="yes" xml:space="preserve">
          <source>INTEGER-OF-DATE Function Syntax</source>
          <target state="translated">정수 날짜 함수 구문</target>
        </trans-unit>
        <trans-unit id="c56815bbf474260cef47707dfeb34754b39ce7d9" translate="yes" xml:space="preserve">
          <source>INTEGER-OF-DAY Function Syntax</source>
          <target state="translated">정수 오늘 함수 구문</target>
        </trans-unit>
        <trans-unit id="4d95e4ffa5addf9dfa93519bd4426b5f3b805749" translate="yes" xml:space="preserve">
          <source>INTEGER-OF-FORMATTED-DATE Function Syntax</source>
          <target state="translated">INTEGER-OF-FORMATTED-DATE 함수 구문</target>
        </trans-unit>
        <trans-unit id="8690212db49eea2a08db459f36ed19a01dcc1797" translate="yes" xml:space="preserve">
          <source>INTEGER-PART Function Syntax</source>
          <target state="translated">INTEGER-PART 함수 구문</target>
        </trans-unit>
        <trans-unit id="b7b5138514830769db3bcc33e44ecf17e41dd72e" translate="yes" xml:space="preserve">
          <source>INVALID KEY Syntax</source>
          <target state="translated">잘못된 키 구문</target>
        </trans-unit>
        <trans-unit id="ec4a2a5056d72d8e03345caaebf4607d163e6dd7" translate="yes" xml:space="preserve">
          <source>IS</source>
          <target state="translated">IS</target>
        </trans-unit>
        <trans-unit id="52a5254cfd81b370ec179ea32fe392572fa23032" translate="yes" xml:space="preserve">
          <source>Identified sub strings will be moved into each destination field in the sequence they are identified; values moved into a destination field will be truncated if the sub string length exceeds the destination field length, or padded with spaces if the destination field length exceeds the sub string length. Both truncation and padding will be controlled by the presence or absence of a &lt;code&gt;JUSTIFIED&lt;/code&gt; (see &lt;a href=&quot;#JUSTIFIED&quot;&gt;JUSTIFIED&lt;/a&gt;) clause on the destination field.</source>
          <target state="translated">식별 된 하위 문자열은 식별 된 순서대로 각 대상 필드로 이동됩니다. 대상 필드로 이동 된 값은 하위 문자열 길이가 대상 필드 길이를 초과하면 잘 리거나 대상 필드 길이가 하위 문자열 길이를 초과하면 공백으로 채워집니다. 자르기와 패딩 모두 대상 필드에 &lt;code&gt;JUSTIFIED&lt;/code&gt; ( &lt;a href=&quot;#JUSTIFIED&quot;&gt;JUSTIFIED&lt;/a&gt; 참조 ) 절의 존재 여부에 따라 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="1e0e983b66f7b85304dc35598bdbe112fd3d5cf6" translate="yes" xml:space="preserve">
          <source>Identified sub strings will be moved into each destination field in the sequence they are identified; values moved into a destination field will be truncated if the sub string length exceeds the destination field length, or padded with spaces if the destination field length exceeds the sub string length. Both truncation and padding will be controlled by the presence or absence of a&lt;code&gt;JUSTIFIED&lt;/code&gt;(see &lt;a href=&quot;#JUSTIFIED&quot;&gt;JUSTIFIED&lt;/a&gt;) clause on the destination field.</source>
          <target state="translated">식별 된 하위 문자열은 식별 된 순서대로 각 대상 필드로 이동합니다. 하위 문자열 길이가 대상 필드 길이를 초과하면 대상 필드로 이동 한 값이 잘 리거나 대상 필드 길이가 하위 문자열 길이를 초과하면 공백으로 채워집니다. 잘림 및 패딩은 대상 필드에 &lt;code&gt;JUSTIFIED&lt;/code&gt; ( &lt;a href=&quot;#JUSTIFIED&quot;&gt;JUSTIFIED&lt;/a&gt; 참조 ) 절의 존재 여부에 따라 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="649d2864df18704de32e689e69e63f2483e8b76e" translate="yes" xml:space="preserve">
          <source>Identifiers</source>
          <target state="translated">Identifiers</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="3322b13c210812f0828395f739652509dab01dfe" translate="yes" xml:space="preserve">
          <source>If  &lt;code&gt;AFTER ADVANCING&lt;/code&gt; is used (or implied), the &lt;code&gt;ADVANCING&lt;/code&gt; action writes line-terminator characters to the file and then the record data is written to the file.</source>
          <target state="translated">경우 &lt;code&gt;AFTER ADVANCING&lt;/code&gt; 사용 (또는 암시)되면, &lt;code&gt;ADVANCING&lt;/code&gt; 동작은 파일에 라인 종결 문자를 기록하고 기록 데이터는 파일에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="85fdddf7199ca1a02d1e410b6661de3c0d82e8ec" translate="yes" xml:space="preserve">
          <source>If &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="d2c897fd06a8b3a329cd50ec25ba6764ec9129b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;CALL &lt;var&gt;literal&lt;/var&gt;&lt;/code&gt; is used, the subroutine can only be located and linked with the calling program at compilation time.</source>
          <target state="translated">경우 &lt;code&gt;CALL &lt;var&gt;literal&lt;/var&gt;&lt;/code&gt; 사용하는 경우, 서브 루틴은 위치 및 컴파일 시간에 호출 프로그램에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15806721a5363c12e0ab5309e695812b2ca53124" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;CALL &lt;var&gt;literal&lt;/var&gt;&lt;/code&gt; is used, the subroutine will be located and linked in with the calling program at compile time or may be dynamically located and loaded at execution time, depending on compiler switch settings and operating system capabilities.</source>
          <target state="translated">경우 &lt;code&gt;CALL &lt;var&gt;literal&lt;/var&gt;&lt;/code&gt; 사용하는 경우, 서브 루틴이 있으며, 컴파일시에 호출 프로그램에 연결 또는 동적 컴파일러 스위치 설정에 따라 시스템 기능을 운영, 위치 및 실행 시간에로드 할 수 있습니다됩니다.</target>
        </trans-unit>
        <trans-unit id="2766f1a1a46e9b0ceae7190dd211a923f2adb01a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PICTURE&lt;/code&gt; 9 and contains &amp;lsquo;</source>
          <target state="translated">만약 &lt;code&gt;PICTURE&lt;/code&gt; '9 포함</target>
        </trans-unit>
        <trans-unit id="806c67b77afcd84b74bff546c895a4a635e84b62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PICTURE&lt;/code&gt; contains &amp;lsquo;</source>
          <target state="translated">만약 &lt;code&gt;PICTURE&lt;/code&gt; '포함</target>
        </trans-unit>
        <trans-unit id="31f064c7a8360dece576eaaabb04042e1b417012" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RETURNING&lt;/code&gt; is not used the &lt;code&gt;RETURN-CODE&lt;/code&gt; special register receives the status-code where zero is success and non-zero it is not.</source>
          <target state="translated">&lt;code&gt;RETURNING&lt;/code&gt; 이 사용되지 않는 경우 &lt;code&gt;RETURN-CODE&lt;/code&gt; 특수 레지스터는 0이 성공하고 0이 아닌 상태 코드를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="95fee7622299f954f5a78d52d81bfb663497c86f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITH TEST AFTER&lt;/code&gt; was specified, control will return back to the &lt;code&gt;PERFORM&lt;/code&gt;, where &lt;var&gt;conditional-expression-1&lt;/var&gt; will be evaluated, and processing of the &lt;code&gt;PERFORM&lt;/code&gt; will halt if the expression evaluates to &lt;code&gt;TRUE&lt;/code&gt;. If &lt;code&gt;WITH TEST AFTER&lt;/code&gt; was</source>
          <target state="translated">경우 &lt;code&gt;WITH TEST AFTER&lt;/code&gt; 지정하고, 제어는 다시 반환 &lt;code&gt;PERFORM&lt;/code&gt; 경우, &lt;var&gt;conditional-expression-1&lt;/var&gt; 평가 될 것이며,이 처리 &lt;code&gt;PERFORM&lt;/code&gt; 하면 에 발현 평가되면 멈추게 &lt;code&gt;TRUE&lt;/code&gt; . 경우 &lt;code&gt;WITH TEST AFTER&lt;/code&gt; 있었다</target>
        </trans-unit>
        <trans-unit id="7d673c8ed35a3c161a6adb890f355404e231d51a" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;argument-1&lt;/var&gt; is a combined date and time format, the content of &lt;var&gt;argument-2&lt;/var&gt; shall be a valid combined date and time in same format.</source>
          <target state="translated">경우 &lt;var&gt;argument-1&lt;/var&gt; 결합 된 날짜 및 시간 형식의 콘텐츠 인 &lt;var&gt;argument-2&lt;/var&gt; 동일한 형식으로 유효한 결합 된 날짜와 시간을한다.</target>
        </trans-unit>
        <trans-unit id="b161484e3fd2f91300ced0138276489baa7a3071" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;argument-1&lt;/var&gt; is a date format the content of &lt;var&gt;argument-2&lt;/var&gt; shall be a valid date in that format.</source>
          <target state="translated">경우 &lt;var&gt;argument-1&lt;/var&gt; 날짜 형식의 내용입니다 &lt;var&gt;argument-2&lt;/var&gt; 그 형식의 유효한 날짜이어야한다.</target>
        </trans-unit>
        <trans-unit id="cebb80a273ff58e8cda6576d2d206c71054b7fc1" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;argument-2&lt;/var&gt; is specified, each character in &lt;var&gt;argument-1&lt;/var&gt; that has no corresponding national representation is converted to the substitution character specified by &lt;var&gt;argument-2&lt;/var&gt;.</source>
          <target state="translated">경우 &lt;var&gt;argument-2&lt;/var&gt; 지정되어있는 각 캐릭터 &lt;var&gt;argument-1&lt;/var&gt; 해당하는 국가의 표현이없는 의해 지정된 대체 문자로 변환된다 &lt;var&gt;argument-2&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="eada64104bafc15080cf4986ed1d995224af39ae" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;argument-2&lt;/var&gt; is specified, the alphanumeric substitution character is returned for each national character in &lt;var&gt;argument-1&lt;/var&gt; that has no corresponding alphanumeric character representation.</source>
          <target state="translated">경우 &lt;var&gt;argument-2&lt;/var&gt; 지정되면, 숫자 대체 문자는 각 국가의 문자를 반환 &lt;var&gt;argument-1&lt;/var&gt; 없이 영숫자 문자 표현을 해당했다.</target>
        </trans-unit>
        <trans-unit id="41229338f436e811725413188daac4719abf2425" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;argument-2&lt;/var&gt; is un-specified, and &lt;var&gt;argument-1&lt;/var&gt; contains a national character for which there is no corresponding alphanumeric character representation, an substitution character is used as the corresponding alphanumeric character and the EC-DATA-CONVERSION exception condition is set.</source>
          <target state="translated">경우 &lt;var&gt;argument-2&lt;/var&gt; 지정 - 해제하고, &lt;var&gt;argument-1&lt;/var&gt; 영숫자 문자 표현을 대응하는이 대체 문자는 해당 영문자와 EC-DATA-CONVERSION 예외 조건으로 사용된다 없다 해당하는 국가의 문자를 포함하는 세트이다.</target>
        </trans-unit>
        <trans-unit id="acea6d05311cd87855cd26011e8b713e8b0a701e" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;argument-2&lt;/var&gt; is unspecified and &lt;var&gt;argument-1&lt;/var&gt; contains an alphanumeric character for which there is no corresponding national character representation, a substitution character is used as the corresponding national character and the &lt;code&gt;EC-DATA-CONVERSION&lt;/code&gt; exception condition is set to exist.</source>
          <target state="translated">경우 &lt;var&gt;argument-2&lt;/var&gt; 불특정 인 &lt;var&gt;argument-1&lt;/var&gt; , 대체 문자를 해당 국가의 문자와 같이 사용되는 해당하는 국가의 문자 표현이 존재하지 않은 영숫자 포함 &lt;code&gt;EC-DATA-CONVERSION&lt;/code&gt; 의 존재로 설정 예외 조건.</target>
        </trans-unit>
        <trans-unit id="70189109ae068537461ee39c4f8e066bfd97e8b8" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;argument-4&lt;/var&gt; is unspecified, the highest level defined in the ordering table is used for the comparison.</source>
          <target state="translated">경우 &lt;var&gt;argument-4&lt;/var&gt; 지정되어 있지 않은, 주문 테이블에 정의 된 최고 수준의 비교를 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="5adaf014414135fbd03c55a5e2040f272de5bc12" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;category-name-1&lt;/var&gt; is specified instead of &lt;code&gt;ALL&lt;/code&gt;, only those members of the field list with &lt;code&gt;VALUE&lt;/code&gt; clauses that also meet the criteria set down for the specified &lt;var&gt;category-name&lt;/var&gt; (see the list above) will qualify.</source>
          <target state="translated">경우 &lt;var&gt;category-name-1&lt;/var&gt; 대신 지정 &lt;code&gt;ALL&lt;/code&gt; 와 필드 목록의 만 회원 &lt;code&gt;VALUE&lt;/code&gt; 의 도 지정을 위해 아래 제시된 기준에 부합 조항 &lt;var&gt;category-name&lt;/var&gt; 자격이됩니다 (위의 목록 참조).</target>
        </trans-unit>
        <trans-unit id="bf8869d2fca2a3ed90b31983b8854737520e2708" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;conditional-expression&lt;/var&gt; evaluates to &lt;code&gt;TRUE&lt;/code&gt;, &lt;var&gt;imperative-statement-1&lt;/var&gt; will be executed regardless of whether or not an  &lt;code&gt;ELSE&lt;/code&gt; clause is present. Once &lt;var&gt;imperative-statement-1&lt;/var&gt; has been executed, control falls into the first statement following the &lt;code&gt;END-IF&lt;/code&gt; or to the first statement of the next sentence if there is no &lt;code&gt;END-IF&lt;/code&gt; clause.</source>
          <target state="translated">If &lt;var&gt;conditional-expression&lt;/var&gt; evaluates to &lt;code&gt;TRUE&lt;/code&gt; , &lt;var&gt;imperative-statement-1&lt;/var&gt; will be executed regardless of whether or not an &lt;code&gt;ELSE&lt;/code&gt; clause is present. Once &lt;var&gt;imperative-statement-1&lt;/var&gt; has been executed, control falls into the first statement following the &lt;code&gt;END-IF&lt;/code&gt; or to the first statement of the next sentence if there is no &lt;code&gt;END-IF&lt;/code&gt; clause.</target>
        </trans-unit>
        <trans-unit id="bcaac60957317961c413c6d092bcc276d2b47710" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;convert-length&lt;/var&gt; is negative or zero, no conversion will be performed.</source>
          <target state="translated">If &lt;var&gt;convert-length&lt;/var&gt; is negative or zero, no conversion will be performed.</target>
        </trans-unit>
        <trans-unit id="07c13d6426ecaae87b4c4a28931d4fa60cb75464" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;days&lt;/var&gt; is less than 1 or greater than 3,067,671, or if &lt;var&gt;seconds&lt;/var&gt; is less than 1 or greater than 86,400, a value of 0 is returned and a runtime error will result.</source>
          <target state="translated">If &lt;var&gt;days&lt;/var&gt; is less than 1 or greater than 3,067,671, or if &lt;var&gt;seconds&lt;/var&gt; is less than 1 or greater than 86,400, a value of 0 is returned and a runtime error will result.</target>
        </trans-unit>
        <trans-unit id="b9f1024cba4d9345c0a63209d2870b749e90c2d6" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file-name-1&lt;/var&gt; is a &lt;code&gt;RELATIVE&lt;/code&gt; file whose &lt;code&gt;ACCESS MODE&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) is either &lt;code&gt;RANDOM&lt;/code&gt; or &lt;code&gt;DYNAMIC&lt;/code&gt;, the record to be deleted is the one whose relative record number is currently the value of the field specified as the files  &lt;code&gt;RELATIVE KEY&lt;/code&gt; in its &lt;code&gt;SELECT&lt;/code&gt; statement.</source>
          <target state="translated">If &lt;var&gt;file-name-1&lt;/var&gt; is a &lt;code&gt;RELATIVE&lt;/code&gt; file whose &lt;code&gt;ACCESS MODE&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) is either &lt;code&gt;RANDOM&lt;/code&gt; or &lt;code&gt;DYNAMIC&lt;/code&gt; , the record to be deleted is the one whose relative record number is currently the value of the field specified as the files &lt;code&gt;RELATIVE KEY&lt;/code&gt; in its &lt;code&gt;SELECT&lt;/code&gt; statement.</target>
        </trans-unit>
        <trans-unit id="d6e9fbaab9d61e6f5e6e5a867b015f6b71b3228d" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file-name-1&lt;/var&gt; is a Sort/Merge work file, no action will be taken.</source>
          <target state="translated">If &lt;var&gt;file-name-1&lt;/var&gt; is a Sort/Merge work file, no action will be taken.</target>
        </trans-unit>
        <trans-unit id="6801050e9c52b67ea54ec1034310f5f1e7764d49" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file-name-1&lt;/var&gt; is a relative file, &lt;var&gt;identifier-1&lt;/var&gt; must be the defined &lt;code&gt;RELATIVE KEY&lt;/code&gt; of the file.</source>
          <target state="translated">If &lt;var&gt;file-name-1&lt;/var&gt; is a relative file, &lt;var&gt;identifier-1&lt;/var&gt; must be the defined &lt;code&gt;RELATIVE KEY&lt;/code&gt; of the file.</target>
        </trans-unit>
        <trans-unit id="f16c5b4c23ecd3d0bf7b5b50d4f95f840e67dc51" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file-name-1&lt;/var&gt; is an &lt;code&gt;INDEXED&lt;/code&gt; file whose &lt;code&gt;ACCESS MODE&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) is &lt;code&gt;RANDOM&lt;/code&gt; or &lt;code&gt;DYNAMIC&lt;/code&gt;, the record to be deleted is the one whose primary key is currently the value of the field specified as the  &lt;code&gt;RECORD KEY&lt;/code&gt; in the file&amp;rsquo;s &lt;code&gt;SELECT&lt;/code&gt; statement.</source>
          <target state="translated">If &lt;var&gt;file-name-1&lt;/var&gt; is an &lt;code&gt;INDEXED&lt;/code&gt; file whose &lt;code&gt;ACCESS MODE&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) is &lt;code&gt;RANDOM&lt;/code&gt; or &lt;code&gt;DYNAMIC&lt;/code&gt; , the record to be deleted is the one whose primary key is currently the value of the field specified as the &lt;code&gt;RECORD KEY&lt;/code&gt; in the file&amp;rsquo;s &lt;code&gt;SELECT&lt;/code&gt; statement.</target>
        </trans-unit>
        <trans-unit id="0cc5aaff69dc11c0104e28890f987c56b77e0ded" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file-name-1&lt;/var&gt; is an &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) or &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) file with &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt;, this statement as well as a random &lt;code&gt;READ&lt;/code&gt; (see &lt;a href=&quot;#Random-READ&quot;&gt;Random READ&lt;/a&gt;) may be used.</source>
          <target state="translated">If &lt;var&gt;file-name-1&lt;/var&gt; is an &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) or &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) file with &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt; , this statement as well as a random &lt;code&gt;READ&lt;/code&gt; (see &lt;a href=&quot;#Random-READ&quot;&gt;Random READ&lt;/a&gt;) may be used.</target>
        </trans-unit>
        <trans-unit id="feee2421e42f2b2e6a2dd8b71df262f9e36a6466" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file-name-1&lt;/var&gt; is an &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) or &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) file with &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt;, this statement as well as a sequential &lt;code&gt;READ&lt;/code&gt; (see &lt;a href=&quot;#Sequential-READ&quot;&gt;Sequential READ&lt;/a&gt;) may be used.</source>
          <target state="translated">If &lt;var&gt;file-name-1&lt;/var&gt; is an &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) or &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) file with &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt; , this statement as well as a sequential &lt;code&gt;READ&lt;/code&gt; (see &lt;a href=&quot;#Sequential-READ&quot;&gt;Sequential READ&lt;/a&gt;) may be used.</target>
        </trans-unit>
        <trans-unit id="902b8ff8b63de74c2449d52d8e0f866355ef7969" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file-name-1&lt;/var&gt; is an &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) or &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) file with an &lt;code&gt;ACCESS MODE RANDOM&lt;/code&gt;, this statement cannot be used.</source>
          <target state="translated">If &lt;var&gt;file-name-1&lt;/var&gt; is an &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) or &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) file with an &lt;code&gt;ACCESS MODE RANDOM&lt;/code&gt; , this statement cannot be used.</target>
        </trans-unit>
        <trans-unit id="6de6701cf8243f215a533b45a324eb216e5e7e58" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file-name-1&lt;/var&gt; is an indexed file, &lt;var&gt;identifier-1&lt;/var&gt; must be the defined &lt;code&gt;RECORD KEY&lt;/code&gt; of the file or any of the &lt;code&gt;ALTERNATE RECORD KEY&lt;/code&gt; fields for the file.</source>
          <target state="translated">If &lt;var&gt;file-name-1&lt;/var&gt; is an indexed file, &lt;var&gt;identifier-1&lt;/var&gt; must be the defined &lt;code&gt;RECORD KEY&lt;/code&gt; of the file or any of the &lt;code&gt;ALTERNATE RECORD KEY&lt;/code&gt; fields for the file.</target>
        </trans-unit>
        <trans-unit id="d5d4d8566ac4ba9f4843bebb395b7f0e5f6c1ec7" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;file-name-1&lt;/var&gt; was specified as &lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt;, this is the</source>
          <target state="translated">If &lt;var&gt;file-name-1&lt;/var&gt; was specified as &lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; , this is the</target>
        </trans-unit>
        <trans-unit id="c635cc29031373da581d69c58507380ea8674609" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;function-reference-1&lt;/var&gt; is specified, it must be an invocation of an intrinsic function that returns a</source>
          <target state="translated">If &lt;var&gt;function-reference-1&lt;/var&gt; is specified, it must be an invocation of an intrinsic function that returns a</target>
        </trans-unit>
        <trans-unit id="7a82f6faf02bfc8a064e8072fdb8d01d8438d86a" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; is a &lt;code&gt;BASED&lt;/code&gt; data item and that data item is currently based (meaning it currently has memory allocated to it), its memory is released and &lt;var&gt;identifier-1&lt;/var&gt; will become un-based and therefore unusable. If &lt;var&gt;identifier-1&lt;/var&gt; was not based, no action will be taken.</source>
          <target state="translated">If &lt;var&gt;identifier-1&lt;/var&gt; is a &lt;code&gt;BASED&lt;/code&gt; data item and that data item is currently based (meaning it currently has memory allocated to it), its memory is released and &lt;var&gt;identifier-1&lt;/var&gt; will become un-based and therefore unusable. If &lt;var&gt;identifier-1&lt;/var&gt; was not based, no action will be taken.</target>
        </trans-unit>
        <trans-unit id="601b9a08fc689a416f43353282b056e64d29cfa8" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; is a &lt;code&gt;USAGE POINTER&lt;/code&gt; data item and it contains a valid address, the &lt;code&gt;FREE&lt;/code&gt; statement will release the memory block the pointer references. In addition, any &lt;code&gt;BASED&lt;/code&gt; data items that the pointer was used to provide an address for will become un-based and therefore unusable. If &lt;var&gt;identifier-1&lt;/var&gt; did not contain a valid address, no action will be taken.</source>
          <target state="translated">If &lt;var&gt;identifier-1&lt;/var&gt; is a &lt;code&gt;USAGE POINTER&lt;/code&gt; data item and it contains a valid address, the &lt;code&gt;FREE&lt;/code&gt; statement will release the memory block the pointer references. In addition, any &lt;code&gt;BASED&lt;/code&gt; data items that the pointer was used to provide an address for will become un-based and therefore unusable. If &lt;var&gt;identifier-1&lt;/var&gt; did not contain a valid address, no action will be taken.</target>
        </trans-unit>
        <trans-unit id="7eefce7fd4f33c7516ec5fe7dc7febf7af0c0c45" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; is a numeric data item, the character value read from the console or standard-input device will be parsed according to the rules for input to the &lt;code&gt;NUMVAL&lt;/code&gt; intrinsic function (see &lt;a href=&quot;#NUMVAL&quot;&gt;NUMVAL&lt;/a&gt;), except that none of the trailing sign formats are honoured.</source>
          <target state="translated">If &lt;var&gt;identifier-1&lt;/var&gt; is a numeric data item, the character value read from the console or standard-input device will be parsed according to the rules for input to the &lt;code&gt;NUMVAL&lt;/code&gt; intrinsic function (see &lt;a href=&quot;#NUMVAL&quot;&gt;NUMVAL&lt;/a&gt;), except that none of the trailing sign formats are honoured.</target>
        </trans-unit>
        <trans-unit id="b2beffe69683166de2996cc3ad1d307a3b738cdc" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; is coded, the value of the identifier will serve as the File Location String that will identify the data file.</source>
          <target state="translated">If &lt;var&gt;identifier-1&lt;/var&gt; is coded, the value of the identifier will serve as the File Location String that will identify the data file.</target>
        </trans-unit>
        <trans-unit id="65401601e1b5f316be7956b04fef58574812c3c4" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; is defined as numeric edited, entered data must be acceptable as &lt;code&gt;NUMVAL-C&lt;/code&gt; intrinsic function (see &lt;a href=&quot;#NUMVAL_002dC&quot;&gt;NUMVAL-C&lt;/a&gt;) input (again, no decimal points are allowed). The value stored into &lt;var&gt;identifier-1&lt;/var&gt; will be as if the input were passed to that function.</source>
          <target state="translated">If &lt;var&gt;identifier-1&lt;/var&gt; is defined as numeric edited, entered data must be acceptable as &lt;code&gt;NUMVAL-C&lt;/code&gt; intrinsic function (see &lt;a href=&quot;#NUMVAL_002dC&quot;&gt;NUMVAL-C&lt;/a&gt;) input (again, no decimal points are allowed). The value stored into &lt;var&gt;identifier-1&lt;/var&gt; will be as if the input were passed to that function.</target>
        </trans-unit>
        <trans-unit id="f0b993fc56bd4161c6cb118462c21f8a02792ac0" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; is defined as numeric, entered data must be acceptable as &lt;code&gt;NUMVAL&lt;/code&gt; intrinsic function (see &lt;a href=&quot;#NUMVAL&quot;&gt;NUMVAL&lt;/a&gt;) input (no decimal points are allowed, however). The value stored into &lt;var&gt;identifier-1&lt;/var&gt; will be as if the input were passed to that function.</source>
          <target state="translated">If &lt;var&gt;identifier-1&lt;/var&gt; is defined as numeric, entered data must be acceptable as &lt;code&gt;NUMVAL&lt;/code&gt; intrinsic function (see &lt;a href=&quot;#NUMVAL&quot;&gt;NUMVAL&lt;/a&gt;) input (no decimal points are allowed, however). The value stored into &lt;var&gt;identifier-1&lt;/var&gt; will be as if the input were passed to that function.</target>
        </trans-unit>
        <trans-unit id="e6e9927c6cd1c05d327eeb65ca2308723fd015a5" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; is defined in the &lt;code&gt;SCREEN SECTION&lt;/code&gt; (see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;), any &lt;code&gt;AT&lt;/code&gt;, &lt;var&gt;Attribute-Specification&lt;/var&gt; and &lt;code&gt;WITH&lt;/code&gt; clauses will be ignored. All field definition, cursor positioning and screen control will occur as a result of the screen section definition of &lt;var&gt;identifier-1&lt;/var&gt;.</source>
          <target state="translated">If &lt;var&gt;identifier-1&lt;/var&gt; is defined in the &lt;code&gt;SCREEN SECTION&lt;/code&gt; (see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;), any &lt;code&gt;AT&lt;/code&gt; , &lt;var&gt;Attribute-Specification&lt;/var&gt; and &lt;code&gt;WITH&lt;/code&gt; clauses will be ignored. All field definition, cursor positioning and screen control will occur as a result of the screen section definition of &lt;var&gt;identifier-1&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="a0be8c8fcd431f360b0c36422f8f1d1039c159c1" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; is defined in the &lt;code&gt;SCREEN SECTION&lt;/code&gt; (see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;), any &lt;code&gt;AT&lt;/code&gt;, &lt;var&gt;Attribute-Specification&lt;/var&gt;, &lt;code&gt;LOWER&lt;/code&gt;, &lt;code&gt;UPPER&lt;/code&gt; or &lt;code&gt;SCROLL&lt;/code&gt; clauses will be ignored. In these cases, an implied &lt;code&gt;DISPLAY&lt;/code&gt; (see &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-item&lt;/a&gt;) of &lt;var&gt;identifier-1&lt;/var&gt; will occur before input is accepted. Coding an explicit &lt;code&gt;DISPLAY identifier-1&lt;/code&gt; before an &lt;code&gt;ACCEPT identifier-1&lt;/code&gt; is redundant and will incur the performance penalty of painting the screen contents twice.</source>
          <target state="translated">If &lt;var&gt;identifier-1&lt;/var&gt; is defined in the &lt;code&gt;SCREEN SECTION&lt;/code&gt; (see &lt;a href=&quot;#SCREEN-SECTION&quot;&gt;SCREEN SECTION&lt;/a&gt;), any &lt;code&gt;AT&lt;/code&gt; , &lt;var&gt;Attribute-Specification&lt;/var&gt; , &lt;code&gt;LOWER&lt;/code&gt; , &lt;code&gt;UPPER&lt;/code&gt; or &lt;code&gt;SCROLL&lt;/code&gt; clauses will be ignored. In these cases, an implied &lt;code&gt;DISPLAY&lt;/code&gt; (see &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-item&lt;/a&gt;) of &lt;var&gt;identifier-1&lt;/var&gt; will occur before input is accepted. Coding an explicit &lt;code&gt;DISPLAY identifier-1&lt;/code&gt; before an &lt;code&gt;ACCEPT identifier-1&lt;/code&gt; is redundant and will incur the performance penalty of painting the screen contents twice.</target>
        </trans-unit>
        <trans-unit id="956b6a2cf4a9431c2521f13980ff654199ac7292" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; is used to specify either an absolute or relative column position, &lt;var&gt;identifier-1&lt;/var&gt; must be defined as a numeric item of any &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) other than &lt;code&gt;COMPUTATIONAL-1&lt;/code&gt; or &lt;code&gt;COMPUTATIONAL-2&lt;/code&gt;, without editing symbols. The value of &lt;var&gt;identifier-1&lt;/var&gt; at the time the screen data item is presented must be 1 or greater. Note that a &lt;code&gt;COMPUTATIONAL-1&lt;/code&gt; or &lt;code&gt;COMPUTATIONAL-2&lt;/code&gt; identifier will be accepted by the compiler, but will produce unpredictable results at run-time.</source>
          <target state="translated">If &lt;var&gt;identifier-1&lt;/var&gt; is used to specify either an absolute or relative column position, &lt;var&gt;identifier-1&lt;/var&gt; must be defined as a numeric item of any &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) other than &lt;code&gt;COMPUTATIONAL-1&lt;/code&gt; or &lt;code&gt;COMPUTATIONAL-2&lt;/code&gt; , without editing symbols. The value of &lt;var&gt;identifier-1&lt;/var&gt; at the time the screen data item is presented must be 1 or greater. Note that a &lt;code&gt;COMPUTATIONAL-1&lt;/code&gt; or &lt;code&gt;COMPUTATIONAL-2&lt;/code&gt; identifier will be accepted by the compiler, but will produce unpredictable results at run-time.</target>
        </trans-unit>
        <trans-unit id="8935f15a51dfdcb07032c577d7b0309e385b373c" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; or any screen data item subordinate to it are defined as numeric edited, entered data must be acceptable as &lt;code&gt;NUMVAL-C&lt;/code&gt; intrinsic function (see &lt;a href=&quot;#NUMVAL_002dC&quot;&gt;NUMVAL-C&lt;/a&gt;) input (again, no decimal points are allowed). The value stored into the screen data item will be as if the input were passed to that function.</source>
          <target state="translated">If &lt;var&gt;identifier-1&lt;/var&gt; or any screen data item subordinate to it are defined as numeric edited, entered data must be acceptable as &lt;code&gt;NUMVAL-C&lt;/code&gt; intrinsic function (see &lt;a href=&quot;#NUMVAL_002dC&quot;&gt;NUMVAL-C&lt;/a&gt;) input (again, no decimal points are allowed). The value stored into the screen data item will be as if the input were passed to that function.</target>
        </trans-unit>
        <trans-unit id="31b0d79efa4947cd92b96b43401a7ba32221e382" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;identifier-1&lt;/var&gt; or any screen data item subordinate to it are defined as numeric, entered data must be acceptable as &lt;code&gt;NUMVAL&lt;/code&gt; intrinsic function (see &lt;a href=&quot;#NUMVAL&quot;&gt;NUMVAL&lt;/a&gt;) input (no decimal points are allowed, however). The value stored into the screen data item will be as if the input were passed to that function.</source>
          <target state="translated">If &lt;var&gt;identifier-1&lt;/var&gt; or any screen data item subordinate to it are defined as numeric, entered data must be acceptable as &lt;code&gt;NUMVAL&lt;/code&gt; intrinsic function (see &lt;a href=&quot;#NUMVAL&quot;&gt;NUMVAL&lt;/a&gt;) input (no decimal points are allowed, however). The value stored into the screen data item will be as if the input were passed to that function.</target>
        </trans-unit>
        <trans-unit id="75a91a06fe865c44309aca591d5aa524e8b8ce58" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;literal-1&lt;/var&gt; is coded, the value of the literal will serve as the File Location String that will identify the data file.</source>
          <target state="translated">If &lt;var&gt;literal-1&lt;/var&gt; is coded, the value of the literal will serve as the File Location String that will identify the data file.</target>
        </trans-unit>
        <trans-unit id="7685ca3db5a671108387e10e7c45ec2601aa2125" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;literal-1&lt;/var&gt; is specified, only the &lt;code&gt;TALLYING&lt;/code&gt; clause may be specified.</source>
          <target state="translated">If &lt;var&gt;literal-1&lt;/var&gt; is specified, only the &lt;code&gt;TALLYING&lt;/code&gt; clause may be specified.</target>
        </trans-unit>
        <trans-unit id="feef07f33e68757737bb23c63cff57a7595d6eb9" translate="yes" xml:space="preserve">
          <source>If &lt;var&gt;word-1&lt;/var&gt; (a syntactically valid word not duplicating a reserved or user-defined word) is coded, and a &lt;var&gt;Type&lt;/var&gt; is &lt;code&gt;EXTERNAL&lt;/code&gt;, then &lt;var&gt;word-1&lt;/var&gt; itself will serve as the File Location String that will identify the data file. If, however, a &lt;var&gt;Type&lt;/var&gt; of &lt;code&gt;EXTERNAL&lt;/code&gt; was</source>
          <target state="translated">If &lt;var&gt;word-1&lt;/var&gt; (a syntactically valid word not duplicating a reserved or user-defined word) is coded, and a &lt;var&gt;Type&lt;/var&gt; is &lt;code&gt;EXTERNAL&lt;/code&gt; , then &lt;var&gt;word-1&lt;/var&gt; itself will serve as the File Location String that will identify the data file. If, however, a &lt;var&gt;Type&lt;/var&gt; of &lt;code&gt;EXTERNAL&lt;/code&gt; was</target>
        </trans-unit>
        <trans-unit id="a4c0ae6969ecd1edf278dc7c43adf6ccf840a59b" translate="yes" xml:space="preserve">
          <source>If CALL &quot;literal&quot; is used, the subroutine can only be located and linked with the calling program at compilation time.</source>
          <target state="translated">CALL &quot;literal&quot;이 사용되면 서브 루틴은 컴파일 할 때 호출 프로그램에만 위치하고 링크 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb834ae0ee1fee06659da54155901a048c8ab107" translate="yes" xml:space="preserve">
          <source>If CALL &quot;literal&quot; is used, the subroutine will be located and linked in with the calling program at compile time or may be dynamically located and loaded at execution time, depending on compiler switch settings and operating system capabilities.</source>
          <target state="translated">CALL &quot;literal&quot;이 사용되는 경우, 컴파일 타임에 서브 루틴이 호출 프로그램과 함께 위치하여 링크되거나 실행 시간에 컴파일러 스위치 설정 및 운영 체제 기능에 따라 동적으로 위치 및로드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c0a19ff2f39be755da80b6e4db03b3261af8ab0" translate="yes" xml:space="preserve">
          <source>If COB_SET_TRACE is set to Y, then tracing will always occur regardless of the presence of READY TRACE or RESET TRACE so in effect they will have no action on program execution.</source>
          <target state="translated">COB_SET_TRACE가 Y로 설정되면 READY TRACE 또는 RESET TRACE의 존재 여부에 관계없이 추적이 항상 발생하므로 사실상 프로그램 실행에 대한 조치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6d1a23e212f8e65bc46791457b48cc5d7fbdbbe2" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently active, a &lt;code&gt;REPLACE LAST OFF.&lt;/code&gt; will replace the current replace specification(s) with those popped off the top of the stack. If there were no replace specification(s) on the stack, the effect will be as if a &lt;code&gt;REPLACE OFF.&lt;/code&gt; had been coded.</source>
          <target state="translated">If Replace Mode is currently active, a &lt;code&gt;REPLACE LAST OFF.&lt;/code&gt; will replace the current replace specification(s) with those popped off the top of the stack. If there were no replace specification(s) on the stack, the effect will be as if a &lt;code&gt;REPLACE OFF.&lt;/code&gt; had been coded.</target>
        </trans-unit>
        <trans-unit id="0bc67cadf74afefc80e1f9092f0b4284c7c21baf" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently active, a &lt;code&gt;REPLACE OFF.&lt;/code&gt; will deactivate Replace Mode and discard any replace specification(s) on the stack. The compiler will henceforth operate as if no &lt;code&gt;REPLACE&lt;/code&gt; had ever been encountered, until such time as another Format 1 &lt;code&gt;REPLACE&lt;/code&gt; is encountered.</source>
          <target state="translated">If Replace Mode is currently active, a &lt;code&gt;REPLACE OFF.&lt;/code&gt; will deactivate Replace Mode and discard any replace specification(s) on the stack. The compiler will henceforth operate as if no &lt;code&gt;REPLACE&lt;/code&gt; had ever been encountered, until such time as another Format 1 &lt;code&gt;REPLACE&lt;/code&gt; is encountered.</target>
        </trans-unit>
        <trans-unit id="fca0edd85d905b4998e39dbc0abfe08d59abf9e2" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently active, a&lt;code&gt;REPLACE LAST OFF.&lt;/code&gt;will replace the current replace specification(s) with those popped off the top of the stack. If there were no replace specification(s) on the stack, the effect will be as if a&lt;code&gt;REPLACE OFF.&lt;/code&gt;had been coded.</source>
          <target state="translated">교체 모드가 현재 활성화되어 있으면 &lt;code&gt;REPLACE LAST OFF.&lt;/code&gt; 현재 교체 사양을 스택 상단에서 튀어 나온 사양으로 교체합니다. 스택에 교체 사양이 없으면 &lt;code&gt;REPLACE OFF.&lt;/code&gt; 와 같은 결과가 나타납니다 . 코딩되었습니다.</target>
        </trans-unit>
        <trans-unit id="3aa454bf040b4488335636d3825b242cd96c6894" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently active, a&lt;code&gt;REPLACE OFF.&lt;/code&gt;will deactivate Replace Mode and discard any replace specification(s) on the stack. The compiler will henceforth operate as if no&lt;code&gt;REPLACE&lt;/code&gt;had ever been encountered, until such time as another Format 1&lt;code&gt;REPLACE&lt;/code&gt;is encountered.</source>
          <target state="translated">교체 모드가 현재 활성화되어 있으면 교체를 &lt;code&gt;REPLACE OFF.&lt;/code&gt; 교체 모드를 비활성화하고 스택에서 교체 사양을 폐기합니다. 따라서 컴파일러는 다른 형식 1 &lt;code&gt;REPLACE&lt;/code&gt; 가 나타날 때까지 &lt;code&gt;REPLACE&lt;/code&gt; 가 없는 것처럼 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="80910c1b2c959a05703945d16cb5a530953c00b1" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently inactive, the Format 2 &lt;code&gt;REPLACE&lt;/code&gt; statement will be ignored.</source>
          <target state="translated">If Replace Mode is currently inactive, the Format 2 &lt;code&gt;REPLACE&lt;/code&gt; statement will be ignored.</target>
        </trans-unit>
        <trans-unit id="f9f8b4a7fa7d08d0000f216b49dbe0fdb7aba40b" translate="yes" xml:space="preserve">
          <source>If Replace Mode is currently inactive, the Format 2 REPLACE statement will be ignored.</source>
          <target state="translated">대체 모드가 현재 비활성 인 경우 형식 2 REPLACE 문은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0f7541fee62285ef531295f6b5bcda473caf4aa3" translate="yes" xml:space="preserve">
          <source>If a  &lt;code&gt;CONVERTING&lt;/code&gt; clause is specified, neither the  &lt;code&gt;TALLYING&lt;/code&gt; nor  &lt;code&gt;REPLACING&lt;/code&gt; clauses may be used.</source>
          <target state="translated">If a &lt;code&gt;CONVERTING&lt;/code&gt; clause is specified, neither the &lt;code&gt;TALLYING&lt;/code&gt; nor &lt;code&gt;REPLACING&lt;/code&gt; clauses may be used.</target>
        </trans-unit>
        <trans-unit id="02d270f35c2331a3f0b66309eedab53f64314826" translate="yes" xml:space="preserve">
          <source>If a &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="eab9e954d4363fe95501767a50e10db235e4192f" translate="yes" xml:space="preserve">
          <source>If a &amp;lt;&amp;lt;</source>
          <target state="translated">&amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="fc1c32024a481de06916a31d66dbe9f8f79db74e" translate="yes" xml:space="preserve">
          <source>If a &amp;rsquo;</source>
          <target state="translated">만약 '</target>
        </trans-unit>
        <trans-unit id="de6289cc04bef66b51bd9ae8b980cf5848e4a2b3" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DEFAULT&lt;/code&gt; clause is specified, any remaining uninitialized members of the field list will be initialized according to the default for their class (numeric and numeric-edited are initialized to &lt;code&gt;ZERO&lt;/code&gt;, all others are initialized to &lt;code&gt;SPACES&lt;/code&gt;).</source>
          <target state="translated">If a &lt;code&gt;DEFAULT&lt;/code&gt; clause is specified, any remaining uninitialized members of the field list will be initialized according to the default for their class (numeric and numeric-edited are initialized to &lt;code&gt;ZERO&lt;/code&gt; , all others are initialized to &lt;code&gt;SPACES&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b7df430cdd4beaec68b52b642faa847848df1390" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;GO TO&lt;/code&gt; is executed within the scope of&amp;hellip;</source>
          <target state="translated">If a &lt;code&gt;GO TO&lt;/code&gt; is executed within the scope of&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="086b6db77bb8a4063af573e2157e345885d882c7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;LINAGE&lt;/code&gt; clause is also specified, Values specified for &lt;code&gt;LINAGE IS&lt;/code&gt; and &lt;code&gt;FOOTING AT&lt;/code&gt; will be ignored. The values of &lt;code&gt;LINES AT BOTTOM&lt;/code&gt; and &lt;code&gt;LINES AT TOP&lt;/code&gt;, if any, will be honoured.</source>
          <target state="translated">If a &lt;code&gt;LINAGE&lt;/code&gt; clause is also specified, Values specified for &lt;code&gt;LINAGE IS&lt;/code&gt; and &lt;code&gt;FOOTING AT&lt;/code&gt; will be ignored. The values of &lt;code&gt;LINES AT BOTTOM&lt;/code&gt; and &lt;code&gt;LINES AT TOP&lt;/code&gt; , if any, will be honoured.</target>
        </trans-unit>
        <trans-unit id="5be09d0f0d2567af382c50f46015e5dfada291d2" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;REMAINDER&lt;/code&gt; clause is specified, the value of the one and only &lt;var&gt;identifier-3&lt;/var&gt; (as stated earlier, if &lt;code&gt;REMAINDER&lt;/code&gt; is specified there may only be a single &lt;var&gt;identifier-3&lt;/var&gt; coded on the statement) after it was assigned a value according to the previous rule will be multiplied by the value of &lt;var&gt;literal-1&lt;/var&gt; or &lt;var&gt;identifier-1&lt;/var&gt;; that result is then subtracted from the value of &lt;var&gt;literal-2&lt;/var&gt; or &lt;var&gt;identifier-2&lt;/var&gt; and</source>
          <target state="translated">If a &lt;code&gt;REMAINDER&lt;/code&gt; clause is specified, the value of the one and only &lt;var&gt;identifier-3&lt;/var&gt; (as stated earlier, if &lt;code&gt;REMAINDER&lt;/code&gt; is specified there may only be a single &lt;var&gt;identifier-3&lt;/var&gt; coded on the statement) after it was assigned a value according to the previous rule will be multiplied by the value of &lt;var&gt;literal-1&lt;/var&gt; or &lt;var&gt;identifier-1&lt;/var&gt; ; that result is then subtracted from the value of &lt;var&gt;literal-2&lt;/var&gt; or &lt;var&gt;identifier-2&lt;/var&gt; and</target>
        </trans-unit>
        <trans-unit id="84aa3649a06583fe904bb0cbe1044a6769ee21ac" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;REMAINDER&lt;/code&gt; clause is specified, the value of the one and only &lt;var&gt;identifier-3&lt;/var&gt; (as stated earlier, if &lt;code&gt;REMAINDER&lt;/code&gt; is specified there may only be a single &lt;var&gt;identifier-3&lt;/var&gt; coded on the statement) after it was assigned a value according to the previous rule will be multiplied by the value of &lt;var&gt;literal-2&lt;/var&gt; or &lt;var&gt;identifier-2&lt;/var&gt;; that result is then subtracted from the value of &lt;var&gt;literal-1&lt;/var&gt; or &lt;var&gt;identifier-1&lt;/var&gt; and</source>
          <target state="translated">If a &lt;code&gt;REMAINDER&lt;/code&gt; clause is specified, the value of the one and only &lt;var&gt;identifier-3&lt;/var&gt; (as stated earlier, if &lt;code&gt;REMAINDER&lt;/code&gt; is specified there may only be a single &lt;var&gt;identifier-3&lt;/var&gt; coded on the statement) after it was assigned a value according to the previous rule will be multiplied by the value of &lt;var&gt;literal-2&lt;/var&gt; or &lt;var&gt;identifier-2&lt;/var&gt; ; that result is then subtracted from the value of &lt;var&gt;literal-1&lt;/var&gt; or &lt;var&gt;identifier-1&lt;/var&gt; and</target>
        </trans-unit>
        <trans-unit id="c7594e0aab5f388821a150d339e4244378eb19f3" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;REPLACING&lt;/code&gt; clause is specified on the &lt;code&gt;INITIALIZE&lt;/code&gt; statement, each qualifying member of the field list that was not already initialized by a &lt;code&gt;VALUE&lt;/code&gt; clause, if any, will be initialized to the specified &lt;var&gt;literal-1&lt;/var&gt; or &lt;var&gt;identifier-1&lt;/var&gt; value.</source>
          <target state="translated">If a &lt;code&gt;REPLACING&lt;/code&gt; clause is specified on the &lt;code&gt;INITIALIZE&lt;/code&gt; statement, each qualifying member of the field list that was not already initialized by a &lt;code&gt;VALUE&lt;/code&gt; clause, if any, will be initialized to the specified &lt;var&gt;literal-1&lt;/var&gt; or &lt;var&gt;identifier-1&lt;/var&gt; value.</target>
        </trans-unit>
        <trans-unit id="33813c77e109dc9b4f61adc0fc691a4853fcf07b" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;TALLYING&lt;/code&gt; clause is coded, &lt;var&gt;identifier-8&lt;/var&gt; will be incremented by 1 each time a destination field is populated.</source>
          <target state="translated">If a &lt;code&gt;TALLYING&lt;/code&gt; clause is coded, &lt;var&gt;identifier-8&lt;/var&gt; will be incremented by 1 each time a destination field is populated.</target>
        </trans-unit>
        <trans-unit id="cfbcf8874de3c3aaa304872f76604715abf41f16" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; (see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) section exists, the code within it will be disabled unless this environment variable is set to a value of &amp;lsquo;</source>
          <target state="translated">If a &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; (see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) section exists, the code within it will be disabled unless this environment variable is set to a value of &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="cfeeade2dc63344bcaf30d0b6c55fa29ff959fe6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;VALUE&lt;/code&gt; clause is specified on the &lt;code&gt;INITIALIZE&lt;/code&gt; statement, each qualifying member of the field list having a compile-time &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) specified in its definition will be initialized to that value. Field list members with &lt;code&gt;VALUE&lt;/code&gt; clauses will qualify for this treatment as follows:</source>
          <target state="translated">If a &lt;code&gt;VALUE&lt;/code&gt; clause is specified on the &lt;code&gt;INITIALIZE&lt;/code&gt; statement, each qualifying member of the field list having a compile-time &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) specified in its definition will be initialized to that value. Field list members with &lt;code&gt;VALUE&lt;/code&gt; clauses will qualify for this treatment as follows:</target>
        </trans-unit>
        <trans-unit id="b332c79b04dd17e719157d2d796d16e81fdbe72a" translate="yes" xml:space="preserve">
          <source>If a &lt;var&gt;Locator&lt;/var&gt; clause is coded, the COBOL file &lt;var&gt;file-name-1&lt;/var&gt; will be attached to a data file within any file system that is mounted and available to the executing program at the time &lt;var&gt;file-name-1&lt;/var&gt; is opened. How that file is identified varies, depending upon the specified &lt;var&gt;Locator&lt;/var&gt;, as follows:</source>
          <target state="translated">If a &lt;var&gt;Locator&lt;/var&gt; clause is coded, the COBOL file &lt;var&gt;file-name-1&lt;/var&gt; will be attached to a data file within any file system that is mounted and available to the executing program at the time &lt;var&gt;file-name-1&lt;/var&gt; is opened. How that file is identified varies, depending upon the specified &lt;var&gt;Locator&lt;/var&gt; , as follows:</target>
        </trans-unit>
        <trans-unit id="54691cdf72f92aa16f748c67998097c3dcd32cbc" translate="yes" xml:space="preserve">
          <source>If a dynamically-loadable module unloaded by the &lt;code&gt;CANCEL&lt;/code&gt; statement is subsequently re-executed, all data division storage for that module will once again be in its initial state.</source>
          <target state="translated">If a dynamically-loadable module unloaded by the &lt;code&gt;CANCEL&lt;/code&gt; statement is subsequently re-executed, all data division storage for that module will once again be in its initial state.</target>
        </trans-unit>
        <trans-unit id="edb4a54100b677ae4d121fffad6d12711ca6c737" translate="yes" xml:space="preserve">
          <source>If a dynamically-loadable module unloaded by the&lt;code&gt;CANCEL&lt;/code&gt;statement is subsequently re-executed, all data division storage for that module will once again be in it&amp;rsquo;s initial state.</source>
          <target state="translated">&lt;code&gt;CANCEL&lt;/code&gt; 문에 의해 언로드 된 동적으로로드 가능한 모듈 이 이후에 다시 실행되면 해당 모듈의 모든 데이터 분할 스토리지가 다시 한 번 초기 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="5eebbcc68042ec2300934665674cc9484d03e969" translate="yes" xml:space="preserve">
          <source>If a numeric literal or &lt;code&gt;PIC 9&lt;/code&gt; identifier is specified as an argument, decimal points, if any, will be removed and negative signs in &lt;code&gt;PIC S9&lt;/code&gt; fields or numeric literals will be inserted as defined by the &lt;code&gt;SIGN IS&lt;/code&gt; (see &lt;a href=&quot;#SIGN-IS&quot;&gt;SIGN IS&lt;/a&gt;) clause (or absence thereof) of the field. Numeric literals are processed as if &lt;code&gt;SIGN IS TRAILING SEPARATE&lt;/code&gt; were in effect.</source>
          <target state="translated">If a numeric literal or &lt;code&gt;PIC 9&lt;/code&gt; identifier is specified as an argument, decimal points, if any, will be removed and negative signs in &lt;code&gt;PIC S9&lt;/code&gt; fields or numeric literals will be inserted as defined by the &lt;code&gt;SIGN IS&lt;/code&gt; (see &lt;a href=&quot;#SIGN-IS&quot;&gt;SIGN IS&lt;/a&gt;) clause (or absence thereof) of the field. Numeric literals are processed as if &lt;code&gt;SIGN IS TRAILING SEPARATE&lt;/code&gt; were in effect.</target>
        </trans-unit>
        <trans-unit id="df6f3afc62331cf6c1dea91965aa4ef057173188" translate="yes" xml:space="preserve">
          <source>If a numeric literal or&lt;code&gt;PIC 9&lt;/code&gt;identifier is specified as an argument, decimal points, if any, will be removed and negative signs in&lt;code&gt;PIC S9&lt;/code&gt;fields or numeric literals will be inserted as defined by the&lt;code&gt;SIGN IS&lt;/code&gt;(see &lt;a href=&quot;#SIGN-IS&quot;&gt;SIGN IS&lt;/a&gt;) clause (or absence thereof) of the field. Numeric literals are processed as if&lt;code&gt;SIGN IS TRAILING SEPARATE&lt;/code&gt;were in effect.</source>
          <target state="translated">숫자 리터럴 또는 &lt;code&gt;PIC 9&lt;/code&gt; 식별자가 인수로 지정된 경우 소수점이있는 경우 소수점이 제거되고 &lt;code&gt;PIC S9&lt;/code&gt; 필드 또는 숫자 리터럴의 부호 가 &lt;code&gt;SIGN IS&lt;/code&gt; ( &lt;a href=&quot;#SIGN-IS&quot;&gt;SIGN IS&lt;/a&gt; 참조 ) 절에 정의 된대로 삽입됩니다 (또는 이의 부재). &lt;code&gt;SIGN IS TRAILING SEPARATE&lt;/code&gt; 가 적용된 것처럼 숫자 리터럴이 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="b18f2b8fc696ea2a37c9ab7e4932c0f375cc7203" translate="yes" xml:space="preserve">
          <source>If a report data item&amp;rsquo;s description includes the &lt;code&gt;SOURCE&lt;/code&gt; (see &lt;a href=&quot;#SOURCE&quot;&gt;SOURCE&lt;/a&gt;), &lt;code&gt;SUM&lt;/code&gt; (see &lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt;) or &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no &lt;code&gt;COLUMN&lt;/code&gt; clause, &lt;code&gt;COLUMN PLUS 1&lt;/code&gt; will be assumed.</source>
          <target state="translated">If a report data item&amp;rsquo;s description includes the &lt;code&gt;SOURCE&lt;/code&gt; (see &lt;a href=&quot;#SOURCE&quot;&gt;SOURCE&lt;/a&gt;), &lt;code&gt;SUM&lt;/code&gt; (see &lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt;) or &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no &lt;code&gt;COLUMN&lt;/code&gt; clause, &lt;code&gt;COLUMN PLUS 1&lt;/code&gt; will be assumed.</target>
        </trans-unit>
        <trans-unit id="57490b79cb430dd4450134ac2677f6cf11e26604" translate="yes" xml:space="preserve">
          <source>If a report data item&amp;rsquo;s description includes the&lt;code&gt;SOURCE&lt;/code&gt;(see &lt;a href=&quot;#SOURCE&quot;&gt;SOURCE&lt;/a&gt;),&lt;code&gt;SUM&lt;/code&gt;(see &lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt;) or&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no&lt;code&gt;COLUMN&lt;/code&gt;clause,&lt;code&gt;COLUMN PLUS 1&lt;/code&gt;will be assumed.</source>
          <target state="translated">보고서 데이터 항목의 설명이 포함 된 경우 &lt;code&gt;SOURCE&lt;/code&gt; 를 (참조 &lt;a href=&quot;#SOURCE&quot;&gt;SOURCE를&lt;/a&gt; ), &lt;code&gt;SUM&lt;/code&gt; 은 (참조 &lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt; 또는) &lt;code&gt;VALUE&lt;/code&gt; (참조 &lt;a href=&quot;#VALUE&quot;&gt;VALUE를&lt;/a&gt; ) 절을하지만이 없습니다 &lt;code&gt;COLUMN&lt;/code&gt; 의 절, &lt;code&gt;COLUMN PLUS 1&lt;/code&gt; 가정한다.</target>
        </trans-unit>
        <trans-unit id="8e78fe002204288bdbf727c66cab2b49730fadeb" translate="yes" xml:space="preserve">
          <source>If a screen data item&amp;rsquo;s description includes the &lt;code&gt;FROM&lt;/code&gt; (see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;), &lt;code&gt;TO&lt;/code&gt; (see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;), &lt;code&gt;USING&lt;/code&gt; (see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) or &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no &lt;code&gt;COLUMN&lt;/code&gt; clause, the new screen field will begin at the column coordinate of the last character of the previous field.</source>
          <target state="translated">If a screen data item&amp;rsquo;s description includes the &lt;code&gt;FROM&lt;/code&gt; (see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;), &lt;code&gt;TO&lt;/code&gt; (see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;), &lt;code&gt;USING&lt;/code&gt; (see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) or &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no &lt;code&gt;COLUMN&lt;/code&gt; clause, the new screen field will begin at the column coordinate of the last character of the previous field.</target>
        </trans-unit>
        <trans-unit id="2ff794a9c9880c18c06d094247c0f0194d807cda" translate="yes" xml:space="preserve">
          <source>If a screen data item&amp;rsquo;s description includes the &lt;code&gt;FROM&lt;/code&gt; (see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;), &lt;code&gt;TO&lt;/code&gt; (see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;), &lt;code&gt;USING&lt;/code&gt; (see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) or &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no LINE clause, the &amp;ldquo;current screen line&amp;rdquo; will be assumed.</source>
          <target state="translated">If a screen data item&amp;rsquo;s description includes the &lt;code&gt;FROM&lt;/code&gt; (see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;), &lt;code&gt;TO&lt;/code&gt; (see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;), &lt;code&gt;USING&lt;/code&gt; (see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) or &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no LINE clause, the &amp;ldquo;current screen line&amp;rdquo; will be assumed.</target>
        </trans-unit>
        <trans-unit id="71da1ffb9548582f3fa4c8e682811f42638458f2" translate="yes" xml:space="preserve">
          <source>If a screen data item&amp;rsquo;s description includes the&lt;code&gt;FROM&lt;/code&gt;(see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;),&lt;code&gt;TO&lt;/code&gt;(see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;),&lt;code&gt;USING&lt;/code&gt;(see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) or&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no LINE clause, the &quot;current screen line&quot; will be assumed.</source>
          <target state="translated">화면 데이터 항목의 설명이 포함되어있는 경우 &lt;code&gt;FROM&lt;/code&gt; (참조 &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt; ), &lt;code&gt;TO&lt;/code&gt; 가 (참조 &lt;a href=&quot;#TO&quot;&gt;TO를&lt;/a&gt; ) &lt;code&gt;USING&lt;/code&gt; 합니다 ( &lt;a href=&quot;#USING&quot;&gt;사용&lt;/a&gt; ) 또는 &lt;code&gt;VALUE&lt;/code&gt; (참조 &lt;a href=&quot;#VALUE&quot;&gt;VALUE를&lt;/a&gt; 절)하지만 LINE 절, &quot;현재 화면 라인&quot;가정한다이 없습니다.</target>
        </trans-unit>
        <trans-unit id="48d3ea6a5c04f441a3bbe9ad4aa57d07cef44e81" translate="yes" xml:space="preserve">
          <source>If a screen data item&amp;rsquo;s description includes the&lt;code&gt;FROM&lt;/code&gt;(see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;),&lt;code&gt;TO&lt;/code&gt;(see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;),&lt;code&gt;USING&lt;/code&gt;(see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) or&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause but has no&lt;code&gt;COLUMN&lt;/code&gt;clause, the new screen field will begin at the column coordinate of the last character of the previous field.</source>
          <target state="translated">화면 데이터 항목의 설명이 포함 된 경우 &lt;code&gt;FROM&lt;/code&gt; 을 합니다 ( &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt; ) &lt;code&gt;TO&lt;/code&gt; (참조 &lt;a href=&quot;#TO&quot;&gt;TO를&lt;/a&gt; ) &lt;code&gt;USING&lt;/code&gt; 합니다 ( &lt;a href=&quot;#USING&quot;&gt;사용&lt;/a&gt; ) 또는 &lt;code&gt;VALUE&lt;/code&gt; (참조 &lt;a href=&quot;#VALUE&quot;&gt;VALUE를&lt;/a&gt; 절)하지만이 없습니다 &lt;code&gt;COLUMN&lt;/code&gt; 절을, 새 화면 필드는 좌표 열에서 시작됩니다 이전 필드의 마지막 문자.</target>
        </trans-unit>
        <trans-unit id="59f4cb284f3687d766f621905e37ba2b4393b002" translate="yes" xml:space="preserve">
          <source>If a subprogram does not expect any arguments, it should not have a &lt;code&gt;USING&lt;/code&gt; clause specified on its procedure division header.</source>
          <target state="translated">If a subprogram does not expect any arguments, it should not have a &lt;code&gt;USING&lt;/code&gt; clause specified on its procedure division header.</target>
        </trans-unit>
        <trans-unit id="1ecf4f102cec092a989e853dbb05716d18d10735" translate="yes" xml:space="preserve">
          <source>If a subprogram does not expect any arguments, it should not have a&lt;code&gt;USING&lt;/code&gt;clause specified on it&amp;rsquo;s procedure division header.</source>
          <target state="translated">서브 프로그램이 인수를 기대하지 않으면, 프로 시저 분할 헤더에 &lt;code&gt;USING&lt;/code&gt; 절이 지정 되어서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="92b7f84efc871dae3988a9b29ad470f6b8703091" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;CONVERTING&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;CONVERTING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2032d4dadae8be3fe061169d553c0926d6a379ee" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;DEFAULT&lt;/code&gt;clause is specified, any remaining uninitialized members of the field list will be initialized according to the default for their class (numeric and numeric-edited are initialized to ZERO, all others are initialized to SPACES).</source>
          <target state="translated">경우 &lt;code&gt;DEFAULT&lt;/code&gt; 의 절이 지정된 필드 목록의 나머지 초기화되지 않은 회원은 자신의 클래스에 대한 기본에 따라 초기화됩니다 (숫자와 숫자-편집이 0으로 초기화, 나머지는 모두 공간으로 초기화된다).</target>
        </trans-unit>
        <trans-unit id="7156dc318e4e3f5aa0881e3dc01f136733e5ac30" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;GO TO&lt;/code&gt;is executed within the scope of&amp;hellip;</source>
          <target state="translated">다음 의 범위 내에서 &lt;code&gt;GO TO&lt;/code&gt; 가 실행되는 경우&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="e12db606ad57abcf661cf0d99d8020cc167d9db0" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;LINAGE&lt;/code&gt;clause is also specified, Values specified for&lt;code&gt;LINAGE IS&lt;/code&gt;and&lt;code&gt;FOOTING AT&lt;/code&gt;will be ignored. The values of&lt;code&gt;LINES AT BOTTOM&lt;/code&gt;and&lt;code&gt;LINES AT TOP&lt;/code&gt; if any, will be honoured.</source>
          <target state="translated">경우 &lt;code&gt;LINAGE&lt;/code&gt; 절도 지정되어, 지정된 값 &lt;code&gt;LINAGE IS&lt;/code&gt; 와 &lt;code&gt;FOOTING AT&lt;/code&gt; 는 무시된다. 의 값 &lt;code&gt;LINES AT BOTTOM&lt;/code&gt; 및 &lt;code&gt;LINES AT TOP&lt;/code&gt; 어떤 경우에는 수상한다.</target>
        </trans-unit>
        <trans-unit id="b64062bb86b4cc026b65a0da4120142c176e5547" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;REMAINDER&lt;/code&gt;clause is specified, the value of the one and only &amp;lt;</source>
          <target state="translated">경우 &lt;code&gt;REMAINDER&lt;/code&gt; 절이 지정, 유일의 값 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c8a9ba4a49154db62b70c94627e9f9a09a50f6f3" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;REPLACING&lt;/code&gt;clause is specified on the&lt;code&gt;INITIALIZE&lt;/code&gt;statement, each qualifying member of the field list that was not already initialized by a&lt;code&gt;VALUE&lt;/code&gt;clause, if any, will be initialized to the specified &amp;lt;</source>
          <target state="translated">경우 &lt;code&gt;REPLACING&lt;/code&gt; 절을에 지정된 &lt;code&gt;INITIALIZE&lt;/code&gt; 의 문, 이미 초기화되지 않은 필드 목록의 각 자격을 갖춘 회원 &lt;code&gt;VALUE&lt;/code&gt; 의 조항이있는 경우, 지정된 초기화됩니다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="5b838d7717f95d20a08cd03498f7882a18db7072" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;TALLYING&lt;/code&gt;clause is coded, &amp;lt;</source>
          <target state="translated">경우 &lt;code&gt;TALLYING&lt;/code&gt; 절을 코딩, &amp;lt;</target>
        </trans-unit>
        <trans-unit id="42850d1581077257d5fcf6cbd3d76feb45a57582" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;USE FOR DEBUGGING&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) section exists, the code within it will be disabled unless this environment variable is set to a value of &quot;Y&quot;, &quot;y&quot; or &quot;1&quot;.</source>
          <target state="translated">경우 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES를&lt;/a&gt; ) 섹션이 존재하는 환경 변수가 &quot;Y&quot;, &quot;Y&quot;또는 &quot;1&quot;의 값으로 설정되지 않는 한, 그 안에 코드는 비활성화 될 것이다.</target>
        </trans-unit>
        <trans-unit id="936f63734566944fcd01e49ee30a1e66bbeaea72" translate="yes" xml:space="preserve">
          <source>If a&lt;code&gt;VALUE&lt;/code&gt;clause is specified on the&lt;code&gt;INITIALIZE&lt;/code&gt;statement, each qualifying member of the field list having a compile-time&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) specified in it&amp;rsquo;s definition will be initialized to that value. Field list members with&lt;code&gt;VALUE&lt;/code&gt;clauses will qualify for this treatment as follows:</source>
          <target state="translated">&lt;code&gt;INITIALIZE&lt;/code&gt; 문 에 &lt;code&gt;VALUE&lt;/code&gt; 절이 지정 되면, 정의에 지정된 컴파일 시간 &lt;code&gt;VALUE&lt;/code&gt; ( &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt; 참조 ) 가있는 필드 목록의 각 규정 멤버 가 해당 값으로 초기화됩니다. &lt;code&gt;VALUE&lt;/code&gt; 절이있는 필드 목록 멤버는 다음과 같이이 처리에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="bbb21152f55feeb2156f854427c62c771c0ef692" translate="yes" xml:space="preserve">
          <source>If all &amp;lt;</source>
          <target state="translated">모두 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="b0c2ba2e09c1e900b3eb01b9e52898d0118ff88e" translate="yes" xml:space="preserve">
          <source>If all &lt;var&gt;conditional-expression-n&lt;/var&gt;s evaluated to FALSE:</source>
          <target state="translated">If all &lt;var&gt;conditional-expression-n&lt;/var&gt; s evaluated to FALSE:</target>
        </trans-unit>
        <trans-unit id="ca4cd8a8a2a1d8c22e29cd6e90d36ad1fe723b40" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ASSIGN&lt;/code&gt; clause is coded without a &lt;var&gt;Device&lt;/var&gt;, the device &lt;code&gt;DISC&lt;/code&gt; will be assumed.</source>
          <target state="translated">If an &lt;code&gt;ASSIGN&lt;/code&gt; clause is coded without a &lt;var&gt;Device&lt;/var&gt; , the device &lt;code&gt;DISC&lt;/code&gt; will be assumed.</target>
        </trans-unit>
        <trans-unit id="857d57ff196431645c6d9af6fd43be900ca29f6f" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; statement or &lt;code&gt;EXIT SECTION&lt;/code&gt; statement resides</source>
          <target state="translated">If an &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; statement or &lt;code&gt;EXIT SECTION&lt;/code&gt; statement resides</target>
        </trans-unit>
        <trans-unit id="34351b99792f0fec35328d816d720a1f1eee1e44" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; statement or &lt;code&gt;EXIT SECTION&lt;/code&gt; statement resides in a paragraph</source>
          <target state="translated">If an &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; statement or &lt;code&gt;EXIT SECTION&lt;/code&gt; statement resides in a paragraph</target>
        </trans-unit>
        <trans-unit id="efdf48973d179f8a73d7a44db16fe05e785724d6" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;INITIATE&lt;/code&gt; is followed by a &lt;code&gt;TERMINATE&lt;/code&gt; with no intervening &lt;code&gt;GENERATE&lt;/code&gt; (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) statements (all pertaining to the same report, of course), no report groups will be presented to the output file.</source>
          <target state="translated">If an &lt;code&gt;INITIATE&lt;/code&gt; is followed by a &lt;code&gt;TERMINATE&lt;/code&gt; with no intervening &lt;code&gt;GENERATE&lt;/code&gt; (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) statements (all pertaining to the same report, of course), no report groups will be presented to the output file.</target>
        </trans-unit>
        <trans-unit id="ff2c2cd31d2de130d184a1a6186491ebcbe37896" translate="yes" xml:space="preserve">
          <source>If an argument identifier is smaller in storage size than the token value to be stored in it, the right-most excess characters of the token value will be truncated as the value is moved in. Any &lt;code&gt;JUSTIFIED RIGHT&lt;/code&gt; clause on such an argument identifier will be ignored.</source>
          <target state="translated">If an argument identifier is smaller in storage size than the token value to be stored in it, the right-most excess characters of the token value will be truncated as the value is moved in. Any &lt;code&gt;JUSTIFIED RIGHT&lt;/code&gt; clause on such an argument identifier will be ignored.</target>
        </trans-unit>
        <trans-unit id="82152df9872b03795b0f65167d26e2e94749c462" translate="yes" xml:space="preserve">
          <source>If an argument identifier is smaller in storage size than the token value to be stored in it, the right-most excess characters of the token value will be truncated as the value is moved in. Any JUSTIFIED RIGHT clause on such an argument identifier will be ignored.</source>
          <target state="translated">인수 ID가 저장 될 토큰 값보다 저장 영역 크기가 더 작은 경우, 값이 이동함에 따라 토큰 값의 가장 오른쪽에있는 문자가 잘립니다. 이러한 인수 ID의 JUSTIFIED RIGHT 절은 다음과 같습니다. 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="07a8ee359a67bccd96333577bde8fdcc626d0ff2" translate="yes" xml:space="preserve">
          <source>If an argument is larger in storage size than the token value to be stored in it, the token value will be moved into the argument identifier in a left-justified manner. unmodified-modified byte positions in the identifier will be space filled, unless the argument identifier is defined as &lt;code&gt;PIC 9 USAGE DISPLAY&lt;/code&gt;, in which case unmodified bytes will be filled with &amp;lsquo;</source>
          <target state="translated">If an argument is larger in storage size than the token value to be stored in it, the token value will be moved into the argument identifier in a left-justified manner. unmodified-modified byte positions in the identifier will be space filled, unless the argument identifier is defined as &lt;code&gt;PIC 9 USAGE DISPLAY&lt;/code&gt; , in which case unmodified bytes will be filled with &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="bccb47600312a31302d4243c123c27cac5d4e303" translate="yes" xml:space="preserve">
          <source>If an argument is larger in storage size than the token value to be stored in it, the token value will be moved into the argument identifier in a left-justified manner. unmodified-modified byte positions in the identifier will be space filled, unless the argument identifier is defined as PIC 9 USAGE DISPLAY, in which case unmodified bytes will be filled with &quot;0&quot; characters from the systems native character set.</source>
          <target state="translated">인수가 저장 될 토큰 값보다 저장 영역 크기가 더 큰 경우, 토큰 값은 왼쪽 정렬 방식으로 인수 ID로 이동합니다. 인수 식별자가 PIC 9 USAGE DISPLAY로 정의되지 않으면 식별자의 수정되지 않은 수정 바이트 위치는 공백으로 채워집니다.이 경우 수정되지 않은 바이트는 시스템 기본 문자 세트의 &quot;0&quot;문자로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="238de03036789e77a079b1d3ae5e90db16e38bae" translate="yes" xml:space="preserve">
          <source>If an argument lacks a &lt;code&gt;BY&lt;/code&gt; clause, the most-recently encountered &lt;code&gt;BY&lt;/code&gt; specification on that &lt;code&gt;CALL&lt;/code&gt; statement will be assumed. If the first argument specified on a &lt;code&gt;CALL&lt;/code&gt; lacks a &lt;code&gt;BY&lt;/code&gt; clause, &lt;code&gt;BY REFERENCE&lt;/code&gt; will be assumed.</source>
          <target state="translated">If an argument lacks a &lt;code&gt;BY&lt;/code&gt; clause, the most-recently encountered &lt;code&gt;BY&lt;/code&gt; specification on that &lt;code&gt;CALL&lt;/code&gt; statement will be assumed. If the first argument specified on a &lt;code&gt;CALL&lt;/code&gt; lacks a &lt;code&gt;BY&lt;/code&gt; clause, &lt;code&gt;BY REFERENCE&lt;/code&gt; will be assumed.</target>
        </trans-unit>
        <trans-unit id="14f8fa4ce97209c48ec71484cb50b99ef2bd0709" translate="yes" xml:space="preserve">
          <source>If an argument lacks a&lt;code&gt;BY&lt;/code&gt;clause, the most-recently encountered&lt;code&gt;BY&lt;/code&gt;specification on that&lt;code&gt;CALL&lt;/code&gt;statement will be assumed. If the first argument specified on a&lt;code&gt;CALL&lt;/code&gt;lacks a&lt;code&gt;BY&lt;/code&gt;clause,&lt;code&gt;BY REFERENCE&lt;/code&gt;will be assumed.</source>
          <target state="translated">인수에 &lt;code&gt;BY&lt;/code&gt; 절이 없으면 해당 &lt;code&gt;CALL&lt;/code&gt; 문 에서 가장 최근에 발생한 &lt;code&gt;BY&lt;/code&gt; 스펙 이 가정됩니다. 에 지정된 첫 번째 인수하는 경우 &lt;code&gt;CALL&lt;/code&gt; 이 부족 &lt;code&gt;BY&lt;/code&gt; 의 절을 &lt;code&gt;BY REFERENCE&lt;/code&gt; 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="05823b59c6e317b0d6f6bda99166cee75a4f73b6" translate="yes" xml:space="preserve">
          <source>If an argument whose value is less than 1 or greater than 256 is specified, the character in the program collating sequence corresponding to a value of all zero bits is returned.</source>
          <target state="translated">값이 1보다 작거나 256보다 큰 인수가 지정된 경우, 프로그램 조합 순서에서 모든 0 비트의 값에 해당하는 문자가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2b8c1834ab8abb452a19e34dee7da8437a78703c" translate="yes" xml:space="preserve">
          <source>If an environment variable was found, it&amp;rsquo;s value will serve as the path and filename to the data file.</source>
          <target state="translated">환경 변수가 발견되면 해당 값은 데이터 파일의 경로 및 파일 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="87ade2418959261313850658cf96a90fea7f484f" translate="yes" xml:space="preserve">
          <source>If an environment variable was found, its value will serve as the path and filename to the data file.</source>
          <target state="translated">If an environment variable was found, its value will serve as the path and filename to the data file.</target>
        </trans-unit>
        <trans-unit id="bcab58a3e462d384fa130cd4e9016e959b6a71b4" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;ASSIGN&lt;/code&gt;clause is coded without a &amp;lt;&amp;lt;</source>
          <target state="translated">&lt;code&gt;ASSIGN&lt;/code&gt; 절이 &amp;lt;&amp;lt;없이 코딩 된 경우</target>
        </trans-unit>
        <trans-unit id="c44efa18b320631b1a96a201bad730ca80153f8d" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;EXIT PARAGRAPH&lt;/code&gt;statement or&lt;code&gt;EXIT SECTION&lt;/code&gt;statement resides</source>
          <target state="translated">에 If &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; 문 또는 &lt;code&gt;EXIT SECTION&lt;/code&gt; 문 상주</target>
        </trans-unit>
        <trans-unit id="87612bdd6bb75a44b81526c8c27d9968de497f3d" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;EXIT PARAGRAPH&lt;/code&gt;statement or&lt;code&gt;EXIT SECTION&lt;/code&gt;statement resides in a paragraph</source>
          <target state="translated">에 If &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; 문 또는 &lt;code&gt;EXIT SECTION&lt;/code&gt; 단락의 문 상주</target>
        </trans-unit>
        <trans-unit id="3f0242e3af04c028a1ddce44867fb3964faf61b9" translate="yes" xml:space="preserve">
          <source>If an&lt;code&gt;INITIATE&lt;/code&gt;is followed by a&lt;code&gt;TERMINATE&lt;/code&gt;with no intervening&lt;code&gt;GENERATE&lt;/code&gt;(see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) statements (all pertaining to the same report, of course), no report groups will be presented to the output file.</source>
          <target state="translated">이 경우 &lt;code&gt;INITIATE&lt;/code&gt; a로 다음에 &lt;code&gt;TERMINATE&lt;/code&gt; 중간에 더와 &lt;code&gt;GENERATE&lt;/code&gt; (참조 &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt; ) 문 (모든 물론, 동일한 보고서에 관한), 어떤 보고서 그룹은 출력 파일에 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1989e1692cf63856050ee6de069649854e1b7eed" translate="yes" xml:space="preserve">
          <source>If any &amp;lt;</source>
          <target state="translated">만약 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="8c41868f40616dcddd4c750ebaeb0a81bc5fba89" translate="yes" xml:space="preserve">
          <source>If any &lt;var&gt;identifier-7&lt;/var&gt; data item is defined in the report section, it must be a sum counter.</source>
          <target state="translated">If any &lt;var&gt;identifier-7&lt;/var&gt; data item is defined in the report section, it must be a sum counter.</target>
        </trans-unit>
        <trans-unit id="ded48aebbdbbf018e482c90608c9d4d54578f860" translate="yes" xml:space="preserve">
          <source>If any of the paragraphs within one of the sections are coded, the section header itself must be coded.</source>
          <target state="translated">섹션 중 하나에있는 단락 중 하나라도 코딩 된 경우 섹션 헤더 자체를 코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed99d154978b96e721c4902c0ac26b3300f9f982" translate="yes" xml:space="preserve">
          <source>If at least one &lt;code&gt;GENERATE&lt;/code&gt; statement of this form is executed against a report, the report is said to be a  &lt;em&gt;detail report&lt;/em&gt;. If no &lt;code&gt;GENERATE&lt;/code&gt; statements of this form are executed against a report, the report is said to be a  &lt;em&gt;summary report&lt;/em&gt;.</source>
          <target state="translated">If at least one &lt;code&gt;GENERATE&lt;/code&gt; statement of this form is executed against a report, the report is said to be a &lt;em&gt;detail report&lt;/em&gt;. If no &lt;code&gt;GENERATE&lt;/code&gt; statements of this form are executed against a report, the report is said to be a &lt;em&gt;summary report&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="098c66a7cc7db43fe1a5e65ab50d6051cee41a88" translate="yes" xml:space="preserve">
          <source>If at least one&lt;code&gt;GENERATE&lt;/code&gt;statement of this form is executed against a report, the report is said to be a &amp;rsquo;</source>
          <target state="translated">이 형식의 &lt;code&gt;GENERATE&lt;/code&gt; 문을 하나 이상 보고서에 대해 실행하면 보고서는 '</target>
        </trans-unit>
        <trans-unit id="bbb1f438e0e2ddccdd230dea44836bc244c52259" translate="yes" xml:space="preserve">
          <source>If both optional sections of this division are coded, they must be coded in the sequence shown.</source>
          <target state="translated">이 부서의 두 옵션 섹션이 모두 코딩 된 경우 표시된 순서대로 코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="745c71ce2e06f35a39cb484c7fa128871c700a6d" translate="yes" xml:space="preserve">
          <source>If both statement types are coded in the &lt;code&gt;I-O-CONTROL&lt;/code&gt; paragraph, the order in which those statements are coded is irrelevant.</source>
          <target state="translated">If both statement types are coded in the &lt;code&gt;I-O-CONTROL&lt;/code&gt; paragraph, the order in which those statements are coded is irrelevant.</target>
        </trans-unit>
        <trans-unit id="e41dfd24c49449dc06a287d66915bfb31196edfa" translate="yes" xml:space="preserve">
          <source>If both statement types are coded in the&lt;code&gt;I-O-CONTROL&lt;/code&gt;paragraph, the order in which those statements are coded is irrelevant.</source>
          <target state="translated">두 명령문 유형이 모두 &lt;code&gt;I-O-CONTROL&lt;/code&gt; 단락에 코딩 된 경우 해당 명령문이 코딩되는 순서는 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="6382741c00dff89ae4bdb6330bb5ee8e859bb989" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;TALLYING&lt;/code&gt; and &lt;code&gt;REPLACING&lt;/code&gt; clauses are specified, they must be specified in the order shown.</source>
          <target state="translated">If both the &lt;code&gt;TALLYING&lt;/code&gt; and &lt;code&gt;REPLACING&lt;/code&gt; clauses are specified, they must be specified in the order shown.</target>
        </trans-unit>
        <trans-unit id="776f3c5eecbcd34d511d3925b8b352f3fe294871" translate="yes" xml:space="preserve">
          <source>If both the&lt;code&gt;TALLYING&lt;/code&gt;and&lt;code&gt;REPLACING&lt;/code&gt;clauses are specified, they must be specified in the order shown.</source>
          <target state="translated">두 경우 &lt;code&gt;TALLYING&lt;/code&gt; 및 &lt;code&gt;REPLACING&lt;/code&gt; 절을 지정, 그들은 표시된 순서대로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5240d922a647b65cd3c813dbacecd9ac5a5286ba" translate="yes" xml:space="preserve">
          <source>If control of execution is transferred to a procedure named on the statement, and the &lt;code&gt;GO TO&lt;/code&gt; is executed within the scope of&amp;hellip;</source>
          <target state="translated">If control of execution is transferred to a procedure named on the statement, and the &lt;code&gt;GO TO&lt;/code&gt; is executed within the scope of&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="49551f9075c0114086955d559a1442bce3fdaf10" translate="yes" xml:space="preserve">
          <source>If control of execution is transferred to a procedure named on the statement, and the&lt;code&gt;GO TO&lt;/code&gt;is executed within the scope of&amp;hellip;</source>
          <target state="translated">실행 제어가 명령문에 명명 된 프로 시저로 전송되고 &lt;code&gt;GO TO&lt;/code&gt; 범위가&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="cc41015e2010811d0a9e0da87d915540d0d175bb" translate="yes" xml:space="preserve">
          <source>If copybooks your program needs are</source>
          <target state="translated">If copybooks your program needs are</target>
        </trans-unit>
        <trans-unit id="25bbb2134d570b993f324faa68838566a3259e83" translate="yes" xml:space="preserve">
          <source>If copybooks your program needs are NOT stored in the same directory as your program, set this environment variable to the folder in which the copybooks may be found (IBM mainframe programmers will recognize this as &quot;SYSLIB&quot;).</source>
          <target state="translated">프로그램에 필요한 카피 북이 프로그램과 동일한 디렉토리에 저장되어 있지 않으면이 환경 변수를 카피 북을 찾을 수있는 폴더로 설정하십시오 (IBM 메인 프레임 프로그래머는이를 &quot;SYSLIB&quot;로 인식 함).</target>
        </trans-unit>
        <trans-unit id="325de08baac6d6bd1b4e1ebed585b6caa542bf6a" translate="yes" xml:space="preserve">
          <source>If desired, screen fields used as input fields may defined as &quot;secure&quot; fields, where each input character (regardless of what was actually typed) will appear as an asterisk (*) character. The actual character whose key was pressed will still be stored into the field in the program, however. This is very useful for password or account number fields.</source>
          <target state="translated">원하는 경우 입력 필드로 사용 된 화면 필드는 &quot;보안&quot;필드로 정의 될 수 있으며, 여기서 각 입력 문자 (실제로 입력 한 내용에 관계없이)는 별표 (*) 문자로 나타납니다. 그러나 키를 누른 실제 문자는 여전히 프로그램의 필드에 저장됩니다. 암호 또는 계정 번호 필드에 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b98d4aa5c71bffe8c951cb1f6b2c3a833d26abf4" translate="yes" xml:space="preserve">
          <source>If desired, screen fields used as input fields may defined as &amp;ldquo;secure&amp;rdquo; fields, where each input character (regardless of what was actually typed) will appear as an asterisk (*) character. The actual character whose key was pressed will still be stored into the field in the program, however. This is very useful for password or account number fields.</source>
          <target state="translated">If desired, screen fields used as input fields may defined as &amp;ldquo;secure&amp;rdquo; fields, where each input character (regardless of what was actually typed) will appear as an asterisk (*) character. The actual character whose key was pressed will still be stored into the field in the program, however. This is very useful for password or account number fields.</target>
        </trans-unit>
        <trans-unit id="3ce1ca984a9baec19cd93dd7844ad13f57d63d88" translate="yes" xml:space="preserve">
          <source>If desired, you may reverse the roles of the &amp;lsquo;</source>
          <target state="translated">If desired, you may reverse the roles of the &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="e8c0e23858d8c34351be31b2e2dd7ef0f308a47c" translate="yes" xml:space="preserve">
          <source>If desired, you may reverse the roles of the&lt;code&gt;.&lt;/code&gt;and&lt;code&gt;,&lt;/code&gt;editing symbols by specifying&lt;code&gt;DECIMAL POINT IS COMMA&lt;/code&gt;in the&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) paragraph.</source>
          <target state="translated">원하는 경우의 역할을 취소 할 수 있습니다 &lt;code&gt;.&lt;/code&gt; 그리고 &lt;code&gt;,&lt;/code&gt; 특정 심볼에 의해 편집 &lt;code&gt;DECIMAL POINT IS COMMA&lt;/code&gt; 에 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; (참조 &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 단락).</target>
        </trans-unit>
        <trans-unit id="0fe77fd80daaf49b4bba036f938fdc3be72e0ebb" translate="yes" xml:space="preserve">
          <source>If either condition has a value of &lt;code&gt;TRUE&lt;/code&gt;, the result of &lt;code&gt;OR&lt;/code&gt;ing the two together will result in a value of &lt;code&gt;TRUE&lt;/code&gt;. &lt;code&gt;OR&lt;/code&gt;ing two &lt;code&gt;FALSE&lt;/code&gt; conditions will result in a value of &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">If either condition has a value of &lt;code&gt;TRUE&lt;/code&gt; , the result of &lt;code&gt;OR&lt;/code&gt; ing the two together will result in a value of &lt;code&gt;TRUE&lt;/code&gt; . &lt;code&gt;OR&lt;/code&gt; ing two &lt;code&gt;FALSE&lt;/code&gt; conditions will result in a value of &lt;code&gt;FALSE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfeb571780980c15ef5118f06fd533dfd406e005" translate="yes" xml:space="preserve">
          <source>If either condition has a value of TRUE, the result of&lt;code&gt;OR&lt;/code&gt;</source>
          <target state="translated">두 조건 중 하나라도 TRUE이면 &lt;code&gt;OR&lt;/code&gt; 의 결과</target>
        </trans-unit>
        <trans-unit id="ed9d44430038aa1155fc55e46a2d9a9ecb6312ec" translate="yes" xml:space="preserve">
          <source>If either the &lt;code&gt;TALLYING&lt;/code&gt; or &lt;code&gt;REPLACING&lt;/code&gt; clauses are specified, the &lt;code&gt;CONVERTING&lt;/code&gt; clause cannot be used.</source>
          <target state="translated">If either the &lt;code&gt;TALLYING&lt;/code&gt; or &lt;code&gt;REPLACING&lt;/code&gt; clauses are specified, the &lt;code&gt;CONVERTING&lt;/code&gt; clause cannot be used.</target>
        </trans-unit>
        <trans-unit id="bc1c6b979e9c37d992caa4fdb32b5bbe5b97b0db" translate="yes" xml:space="preserve">
          <source>If either the&lt;code&gt;TALLYING&lt;/code&gt;or&lt;code&gt;REPLACING&lt;/code&gt;clauses are specified, the&lt;code&gt;CONVERTING&lt;/code&gt;clause cannot be used.</source>
          <target state="translated">어느 경우 &lt;code&gt;TALLYING&lt;/code&gt; 또는 &lt;code&gt;REPLACING&lt;/code&gt; 절을 지정의 &lt;code&gt;CONVERTING&lt;/code&gt; 절은 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4d7f77af0291647c5dacacbc811f9084a6405007" translate="yes" xml:space="preserve">
          <source>If event</source>
          <target state="translated">If event</target>
        </trans-unit>
        <trans-unit id="65d896699ba7417f38fac49a744a6351011f2338" translate="yes" xml:space="preserve">
          <source>If event (A) occurs, &amp;lt;</source>
          <target state="translated">이벤트 (A)가 발생하면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c6ea8276245b74726b44312b8cbb459b9ea45f59" translate="yes" xml:space="preserve">
          <source>If event (A) occurs, none of the destination field contents (or the contents of their&lt;code&gt;DELIMITER&lt;/code&gt;or &amp;lt;</source>
          <target state="translated">이벤트 (A)가 발생하면 대상 필드 내용 (또는 &lt;code&gt;DELIMITER&lt;/code&gt; 또는 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c766138e5b6a0fb5e159fe3be6df3cb65c15aa94" translate="yes" xml:space="preserve">
          <source>If excess space is allocated, the returned value will be padded with spaces (to the right).</source>
          <target state="translated">초과 공간이 할당되면 반환 된 값은 공백으로 채워집니다 (오른쪽).</target>
        </trans-unit>
        <trans-unit id="0ee821a14b535409c9db6845f5fa9d2ad8f3ef2b" translate="yes" xml:space="preserve">
          <source>If executed by a main program, neither the &lt;code&gt;EXIT PROGRAM&lt;/code&gt; nor &lt;code&gt;EXIT FUNCTION&lt;/code&gt; statements will take any action.</source>
          <target state="translated">If executed by a main program, neither the &lt;code&gt;EXIT PROGRAM&lt;/code&gt; nor &lt;code&gt;EXIT FUNCTION&lt;/code&gt; statements will take any action.</target>
        </trans-unit>
        <trans-unit id="dcf599fa35195bfeb7d750a1aa7ddb9854348d4d" translate="yes" xml:space="preserve">
          <source>If executed by a main program, neither the&lt;code&gt;EXIT PROGRAM&lt;/code&gt;nor&lt;code&gt;EXIT FUNCTION&lt;/code&gt;statements will take any action.</source>
          <target state="translated">기본 프로그램에서 실행하면 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 또는 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 문은 어떤 조치도 취하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec56e985e662e98e355eae2b56f2b8eb89f00cd3" translate="yes" xml:space="preserve">
          <source>If executed within a main program, &lt;code&gt;GOBACK&lt;/code&gt; will act as a &lt;code&gt;STOP RUN&lt;/code&gt; statement.</source>
          <target state="translated">If executed within a main program, &lt;code&gt;GOBACK&lt;/code&gt; will act as a &lt;code&gt;STOP RUN&lt;/code&gt; statement.</target>
        </trans-unit>
        <trans-unit id="adc22a801c0d5cf9afd2251ba837acc24c7e7595" translate="yes" xml:space="preserve">
          <source>If executed within a main program,&lt;code&gt;GOBACK&lt;/code&gt;will act as a&lt;code&gt;STOP RUN&lt;/code&gt;statement.</source>
          <target state="translated">기본 프로그램 내에서 실행되면 &lt;code&gt;GOBACK&lt;/code&gt; 은 &lt;code&gt;STOP RUN&lt;/code&gt; 문 으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="29e21ce7e21f0a3076c47fd2aba39be700d024bc" translate="yes" xml:space="preserve">
          <source>If executed within a subprogram (i.e. a subroutine or user-defined function), &lt;code&gt;GOBACK&lt;/code&gt; behaves like an &lt;code&gt;EXIT PROGRAM&lt;/code&gt; or &lt;code&gt;EXIT FUNCTION&lt;/code&gt; statement, respectively.</source>
          <target state="translated">If executed within a subprogram (i.e. a subroutine or user-defined function), &lt;code&gt;GOBACK&lt;/code&gt; behaves like an &lt;code&gt;EXIT PROGRAM&lt;/code&gt; or &lt;code&gt;EXIT FUNCTION&lt;/code&gt; statement, respectively.</target>
        </trans-unit>
        <trans-unit id="0c913e686677f4f2542ed04551fc54a61ca3b586" translate="yes" xml:space="preserve">
          <source>If executed within a subprogram (i.e. a subroutine or user-defined function),&lt;code&gt;GOBACK&lt;/code&gt;behaves like an&lt;code&gt;EXIT PROGRAM&lt;/code&gt;or&lt;code&gt;EXIT FUNCTION&lt;/code&gt;statement, respectively.</source>
          <target state="translated">서브 프로그램 (즉, 서브 루틴 또는 사용자 정의 함수) 내에서 실행되는 경우 &lt;code&gt;GOBACK&lt;/code&gt; 은 각각 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 또는 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 문 처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="37a5ec4ba4f6eb14fb6bc4cdf6c2b834a2e18251" translate="yes" xml:space="preserve">
          <source>If insufficient space is allocated, the returned value will be truncated.</source>
          <target state="translated">충분한 공간이 할당되지 않으면 반환 된 값이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="20788d6df5c521759ffd6da038d7efacbc53537c" translate="yes" xml:space="preserve">
          <source>If it begins with a capital &quot;C&quot;, the value will be centred</source>
          <target state="translated">대문자 &quot;C&quot;로 시작하면 값이 중앙에 위치합니다.</target>
        </trans-unit>
        <trans-unit id="cce45705eb2edf3ee981ccb8a02325faa9873b7a" translate="yes" xml:space="preserve">
          <source>If it begins with a capital &quot;L&quot;, the value will be left-justified, space-filled to the right</source>
          <target state="translated">대문자 &quot;L&quot;로 시작하면 값이 왼쪽으로 정렬되고 오른쪽으로 공간이 채워집니다.</target>
        </trans-unit>
        <trans-unit id="49095cec719464061ddd1eea1650a1e60b0b3522" translate="yes" xml:space="preserve">
          <source>If it begins with a capital &quot;R&quot;, the value will be right-justified, space-filled to the left</source>
          <target state="translated">대문자 &quot;R&quot;로 시작하면 값이 오른쪽으로 정렬되고 왼쪽으로 공간이 채워집니다.</target>
        </trans-unit>
        <trans-unit id="e6e9d41a84edd6ab6b611b8a64b21d8cc9efa7ef" translate="yes" xml:space="preserve">
          <source>If it begins with anything else, or is absent, it will be treated as if it is present and begins with a capital &quot;R&quot;</source>
          <target state="translated">다른 것으로 시작하거나없는 경우, 존재하는 것처럼 취급되고 대문자 &quot;R&quot;로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="0a89badd7879c4ca69abaf146998c7ff5dc1ad26" translate="yes" xml:space="preserve">
          <source>If it begins with anything else, or is absent, it will be treated as if it is present and begins with a capital &amp;lsquo;</source>
          <target state="translated">If it begins with anything else, or is absent, it will be treated as if it is present and begins with a capital &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="e314a2cf494e58e27d506f6b9a3b270acdcc85b6" translate="yes" xml:space="preserve">
          <source>If it contains a &lt;code&gt;CR&lt;/code&gt;, &lt;code&gt;DB&lt;/code&gt;, or the minus sign (&amp;lsquo;</source>
          <target state="translated">If it contains a &lt;code&gt;CR&lt;/code&gt; , &lt;code&gt;DB&lt;/code&gt; , or the minus sign (&amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="ddfddaec4eb6defafd4236c3804acb2833a56ffc" translate="yes" xml:space="preserve">
          <source>If it is a dynamic subroutine, the GnuCOBOL run-time system will check to see if a dynamically-loadable module containing the subprogram&amp;rsquo;s entry point was already located. If it was, no further &quot;location&quot; activity is needed. If not, the dynamically-loadable module will be located (see &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;Locating Dynamically-Loadable Modules&lt;/a&gt;).</source>
          <target state="translated">동적 서브 루틴 인 경우 GnuCOBOL 런타임 시스템은 서브 프로그램의 진입 점이 포함 된 동적으로로드 가능한 모듈이 이미 있는지 확인합니다. 그렇다면 추가 &quot;위치&quot;활동이 필요하지 않습니다. 그렇지 않으면 동적으로로드 가능한 모듈이 배치됩니다 ( &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;동적로드 가능한 모듈 찾기&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c2c2b30c5a2cdcf0f0e42916c610b89f78e14195" translate="yes" xml:space="preserve">
          <source>If it is a dynamic subroutine, the GnuCOBOL run-time system will check to see if a dynamically-loadable module containing the subprogram&amp;rsquo;s entry point was already located. If it was, no further &amp;ldquo;location&amp;rdquo; activity is needed. If not, the dynamically-loadable module will be located (see &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;Locating Dynamically-Loadable Modules&lt;/a&gt;).</source>
          <target state="translated">If it is a dynamic subroutine, the GnuCOBOL run-time system will check to see if a dynamically-loadable module containing the subprogram&amp;rsquo;s entry point was already located. If it was, no further &amp;ldquo;location&amp;rdquo; activity is needed. If not, the dynamically-loadable module will be located (see &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;Locating Dynamically-Loadable Modules&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="a084bcee5f6f297e9fac72fc57197692e67653da" translate="yes" xml:space="preserve">
          <source>If it is a dynamic user-defined function, the GnuCOBOL run-time system will check to see if a dynamically-loadable module containing the function&amp;rsquo;s entry point was already located. If it was, no further &quot;location&quot; activity is needed. If not, the dynamically-loadable module will be located (see &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;Locating Dynamically-Loadable Modules&lt;/a&gt;).</source>
          <target state="translated">동적 사용자 정의 함수 인 경우 GnuCOBOL 런타임 시스템은 함수의 진입 점이 포함 된 동적으로로드 가능한 모듈이 이미 있는지 확인합니다. 그렇다면 추가 &quot;위치&quot;활동이 필요하지 않습니다. 그렇지 않으면 동적으로로드 가능한 모듈이 배치됩니다 ( &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;동적로드 가능한 모듈 찾기&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3a587abb6e0208602df7555796aa18f2e38bcaa6" translate="yes" xml:space="preserve">
          <source>If it is a dynamic user-defined function, the GnuCOBOL run-time system will check to see if a dynamically-loadable module containing the function&amp;rsquo;s entry point was already located. If it was, no further &amp;ldquo;location&amp;rdquo; activity is needed. If not, the dynamically-loadable module will be located (see &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;Locating Dynamically-Loadable Modules&lt;/a&gt;).</source>
          <target state="translated">If it is a dynamic user-defined function, the GnuCOBOL run-time system will check to see if a dynamically-loadable module containing the function&amp;rsquo;s entry point was already located. If it was, no further &amp;ldquo;location&amp;rdquo; activity is needed. If not, the dynamically-loadable module will be located (see &lt;a href=&quot;#Locating-Dynamically_002dLoadable-Modules&quot;&gt;Locating Dynamically-Loadable Modules&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="1d35a2709398b64faf3d0f6a4cba74a904396997" translate="yes" xml:space="preserve">
          <source>If it is a static subroutine, it will already be part of the executable program issuing the &lt;code&gt;CALL&lt;/code&gt; (see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;).</source>
          <target state="translated">If it is a static subroutine, it will already be part of the executable program issuing the &lt;code&gt;CALL&lt;/code&gt; (see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="d0f43ca29a675e226a37e6b6d8088cdbc37ebd39" translate="yes" xml:space="preserve">
          <source>If it is a static subroutine, it will already be part of the executable program issuing the&lt;code&gt;CALL&lt;/code&gt;(see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;).</source>
          <target state="translated">정적 서브 루틴 인 경우 이미 &lt;code&gt;CALL&lt;/code&gt; 을 발행하는 실행 프로그램의 일부입니다 ( &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="caa175b4499a85fc8b3c0efe4a0f73f3d1c1c886" translate="yes" xml:space="preserve">
          <source>If it is a static user-defined function, it will already be part of the executable file containing the calling program.</source>
          <target state="translated">정적 사용자 정의 함수 인 경우 이미 호출 프로그램을 포함하는 실행 파일의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="84a0f01c66da97418e3aa21d01e0ef5b3ae55060" translate="yes" xml:space="preserve">
          <source>If more than one section is needed in the data division (a common situation), the sections must be coded in the sequence they are presented above.</source>
          <target state="translated">데이터 분할 (일반적인 상황)에 둘 이상의 섹션이 필요한 경우 섹션은 위에 제시된 순서대로 코딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="08575c4d82cf8b371a6f7d53f268979ac88898e9" translate="yes" xml:space="preserve">
          <source>If necessary, &amp;lt;</source>
          <target state="translated">필요한 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f3c5cfa2cd5754ef4f9ebd8819c023866cec6753" translate="yes" xml:space="preserve">
          <source>If necessary, &lt;var&gt;identifier-1&lt;/var&gt; may be qualified with a report name.</source>
          <target state="translated">If necessary, &lt;var&gt;identifier-1&lt;/var&gt; may be qualified with a report name.</target>
        </trans-unit>
        <trans-unit id="a07bc04cad751bf3729834d0eede1f438f0dd23e" translate="yes" xml:space="preserve">
          <source>If neither &lt;var&gt;argument-2&lt;/var&gt; nor the &lt;code&gt;LOCALE&lt;/code&gt; keyword is specified, there shall be only one currency string used, either the default currency sign or a currency string specified in the &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; paragraph.</source>
          <target state="translated">If neither &lt;var&gt;argument-2&lt;/var&gt; nor the &lt;code&gt;LOCALE&lt;/code&gt; keyword is specified, there shall be only one currency string used, either the default currency sign or a currency string specified in the &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; paragraph.</target>
        </trans-unit>
        <trans-unit id="7e171173d63b5e9bade35a7d12eac799bc4e2f54" translate="yes" xml:space="preserve">
          <source>If neither paragraph is coded, the &lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt; header itself may be omitted, otherwise it is normally required.</source>
          <target state="translated">If neither paragraph is coded, the &lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt; header itself may be omitted, otherwise it is normally required.</target>
        </trans-unit>
        <trans-unit id="f63584104f0c3fb031bde71d0b6dcee112c103e0" translate="yes" xml:space="preserve">
          <source>If neither paragraph is coded, the&lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt;header itself may be omitted, otherwise it is normally required.</source>
          <target state="translated">단락이 코딩되지 않으면 &lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt; 헤더 자체는 생략 될 수 있으며, 그렇지 않으면 일반적으로 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2c24d8323d5e2e2f3832cf5a89d8b67b228d4bcd" translate="yes" xml:space="preserve">
          <source>If neither symbol nor the &lt;code&gt;LOCALE&lt;/code&gt; keyword is specified, there shall be only one currency string used, either the default currency sign or a currency string specified in the &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; paragraph.</source>
          <target state="translated">If neither symbol nor the &lt;code&gt;LOCALE&lt;/code&gt; keyword is specified, there shall be only one currency string used, either the default currency sign or a currency string specified in the &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; paragraph.</target>
        </trans-unit>
        <trans-unit id="7b645e3fb4170a043aa45114410ba79af6cbd2a8" translate="yes" xml:space="preserve">
          <source>If no  &lt;code&gt;UPON&lt;/code&gt; clause is specified, &lt;code&gt;UPON CONSOLE&lt;/code&gt; will be assumed. If the &lt;code&gt;UPON&lt;/code&gt; clause</source>
          <target state="translated">If no &lt;code&gt;UPON&lt;/code&gt; clause is specified, &lt;code&gt;UPON CONSOLE&lt;/code&gt; will be assumed. If the &lt;code&gt;UPON&lt;/code&gt; clause</target>
        </trans-unit>
        <trans-unit id="3c31c5678998b1cb03f4a683a72bb094dd2d47bc" translate="yes" xml:space="preserve">
          <source>If no  &lt;code&gt;VALUE&lt;/code&gt;,  &lt;code&gt;REPLACING&lt;/code&gt; or  &lt;code&gt;DEFAULT&lt;/code&gt; clauses are coded, each member of the field list will be initialized as if the figurative constant &lt;code&gt;ZERO&lt;/code&gt; (if the field list item is numeric or numeric-edited) or &lt;code&gt;SPACES&lt;/code&gt; (otherwise) were being moved to it.</source>
          <target state="translated">If no &lt;code&gt;VALUE&lt;/code&gt; , &lt;code&gt;REPLACING&lt;/code&gt; or &lt;code&gt;DEFAULT&lt;/code&gt; clauses are coded, each member of the field list will be initialized as if the figurative constant &lt;code&gt;ZERO&lt;/code&gt; (if the field list item is numeric or numeric-edited) or &lt;code&gt;SPACES&lt;/code&gt; (otherwise) were being moved to it.</target>
        </trans-unit>
        <trans-unit id="112a01f52ed19b32bc288508d6054c95da8fdd85" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;</source>
          <target state="translated">없는 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c520e3d4aae69229f5d030660491f8d24e39ce90" translate="yes" xml:space="preserve">
          <source>If no &amp;lt;&amp;lt;</source>
          <target state="translated">없는 경우 &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="cccae1dc6e8637e1b5c5c2fbf5052d3f0ccf07fa" translate="yes" xml:space="preserve">
          <source>If no &amp;rsquo;</source>
          <target state="translated">'아니요</target>
        </trans-unit>
        <trans-unit id="243c405d0e431941f396cdf2cc7debb85eff9bdf" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;ADVANCING&lt;/code&gt; clause is specified on a &lt;code&gt;WRITE&lt;/code&gt; to a line-advancing file, &lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt; will be assumed; on other than line-advancing files, &lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt; will be assumed.</source>
          <target state="translated">If no &lt;code&gt;ADVANCING&lt;/code&gt; clause is specified on a &lt;code&gt;WRITE&lt;/code&gt; to a line-advancing file, &lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt; will be assumed; on other than line-advancing files, &lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt; will be assumed.</target>
        </trans-unit>
        <trans-unit id="534401253d3dd6379f2606857f4cc89f0c94f6f0" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;AFTER&lt;/code&gt; is specified, the first character position of the target range will be character position #1 of the inspect subject.</source>
          <target state="translated">If no &lt;code&gt;AFTER&lt;/code&gt; is specified, the first character position of the target range will be character position #1 of the inspect subject.</target>
        </trans-unit>
        <trans-unit id="eb47f868ee5f1f162e6f6003816f7c136573587c" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;BEFORE&lt;/code&gt; is specified, the last character position of the target range will be the last character position of the inspect subject.</source>
          <target state="translated">If no &lt;code&gt;BEFORE&lt;/code&gt; is specified, the last character position of the target range will be the last character position of the inspect subject.</target>
        </trans-unit>
        <trans-unit id="6fd871db48d394ff9b78f12f0fce35ca9364a8e1" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; clause is specified, the collating sequence implied by the character set native to the computer (usually ASCII) will be used.</source>
          <target state="translated">If no &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; clause is specified, the collating sequence implied by the character set native to the computer (usually ASCII) will be used.</target>
        </trans-unit>
        <trans-unit id="d88264a069243f7453b6028d4a728c1fac697306" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;FIRST&lt;/code&gt;, &lt;code&gt;LAST&lt;/code&gt; or &lt;code&gt;KEY&lt;/code&gt; clause is specified, &lt;code&gt;KEY IS EQUAL TO &lt;var&gt;xxx&lt;/var&gt;&lt;/code&gt; will be assumed, where &lt;code&gt;&lt;var&gt;xxx&lt;/var&gt;&lt;/code&gt; is the defined &lt;code&gt;RELATIVE KEY&lt;/code&gt; of (if &lt;var&gt;file-name-1&lt;/var&gt; is a relative file) or the defined &lt;code&gt;RECORD KEY&lt;/code&gt; (if &lt;var&gt;file-name-1&lt;/var&gt; is an indexed file).</source>
          <target state="translated">If no &lt;code&gt;FIRST&lt;/code&gt; , &lt;code&gt;LAST&lt;/code&gt; or &lt;code&gt;KEY&lt;/code&gt; clause is specified, &lt;code&gt;KEY IS EQUAL TO &lt;var&gt;xxx&lt;/var&gt;&lt;/code&gt; will be assumed, where &lt;code&gt;&lt;var&gt;xxx&lt;/var&gt;&lt;/code&gt; is the defined &lt;code&gt;RELATIVE KEY&lt;/code&gt; of (if &lt;var&gt;file-name-1&lt;/var&gt; is a relative file) or the defined &lt;code&gt;RECORD KEY&lt;/code&gt; (if &lt;var&gt;file-name-1&lt;/var&gt; is an indexed file).</target>
        </trans-unit>
        <trans-unit id="4293878bed72313a6e2568d2a16aac81190571f1" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;FROM&lt;/code&gt; clause is specified, &lt;code&gt;FROM CONSOLE&lt;/code&gt; is assumed.</source>
          <target state="translated">If no &lt;code&gt;FROM&lt;/code&gt; clause is specified, &lt;code&gt;FROM CONSOLE&lt;/code&gt; is assumed.</target>
        </trans-unit>
        <trans-unit id="2cceaf02110825913a3c818819bfaba8864abacf" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;PAGE LIMITS&lt;/code&gt; clause is specified, the entire report will be generated as if it consists of a single arbitrarily long page.</source>
          <target state="translated">If no &lt;code&gt;PAGE LIMITS&lt;/code&gt; clause is specified, the entire report will be generated as if it consists of a single arbitrarily long page.</target>
        </trans-unit>
        <trans-unit id="e498385d96185eed7cacd4320d52a11ef46ca39a" translate="yes" xml:space="preserve">
          <source>If no &lt;var&gt;CDF-Conditional-Expression-n&lt;/var&gt; evaluates to &lt;code&gt;TRUE&lt;/code&gt; and there is no &lt;code&gt;&amp;gt;&amp;gt;ELSE&lt;/code&gt; clause, then none of the &lt;var&gt;Program-Source-Lines-n&lt;/var&gt; block of statements within the &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt;-&lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; scope will be processed by the compiler.</source>
          <target state="translated">If no &lt;var&gt;CDF-Conditional-Expression-n&lt;/var&gt; evaluates to &lt;code&gt;TRUE&lt;/code&gt; and there is no &lt;code&gt;&amp;gt;&amp;gt;ELSE&lt;/code&gt; clause, then none of the &lt;var&gt;Program-Source-Lines-n&lt;/var&gt; block of statements within the &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; - &lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; scope will be processed by the compiler.</target>
        </trans-unit>
        <trans-unit id="c439aee91e928500a2dd00bc3e6fe3094d07c6fa" translate="yes" xml:space="preserve">
          <source>If no &lt;var&gt;CDF-Conditional-Expression&lt;/var&gt; evaluates to &lt;code&gt;TRUE&lt;/code&gt;, and there is an &lt;code&gt;&amp;gt;&amp;gt;ELSE&lt;/code&gt; clause, the &lt;var&gt;Program-Source-Lines-3&lt;/var&gt; block of statements following the &lt;code&gt;&amp;gt;&amp;gt;ELSE&lt;/code&gt; clause will be processed by the compiler and all others within the &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt;-&lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; scope will be ignored.</source>
          <target state="translated">If no &lt;var&gt;CDF-Conditional-Expression&lt;/var&gt; evaluates to &lt;code&gt;TRUE&lt;/code&gt; , and there is an &lt;code&gt;&amp;gt;&amp;gt;ELSE&lt;/code&gt; clause, the &lt;var&gt;Program-Source-Lines-3&lt;/var&gt; block of statements following the &lt;code&gt;&amp;gt;&amp;gt;ELSE&lt;/code&gt; clause will be processed by the compiler and all others within the &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; - &lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; scope will be ignored.</target>
        </trans-unit>
        <trans-unit id="ea11b50cea12a93376d57eb2c22cc7b7c141fc7a" translate="yes" xml:space="preserve">
          <source>If no &lt;var&gt;Locator&lt;/var&gt; is coded, &lt;var&gt;file-name-1&lt;/var&gt; will be attached to a logical device or a file based upon the specified (or implied) &lt;var&gt;Device&lt;/var&gt;, as follows:</source>
          <target state="translated">If no &lt;var&gt;Locator&lt;/var&gt; is coded, &lt;var&gt;file-name-1&lt;/var&gt; will be attached to a logical device or a file based upon the specified (or implied) &lt;var&gt;Device&lt;/var&gt; , as follows:</target>
        </trans-unit>
        <trans-unit id="326b1fc9786b9941320c69f4a2d328c2621c654e" translate="yes" xml:space="preserve">
          <source>If no &lt;var&gt;alphabet-name-1&lt;/var&gt; is specified, the systems native character set will be assumed.</source>
          <target state="translated">If no &lt;var&gt;alphabet-name-1&lt;/var&gt; is specified, the systems native character set will be assumed.</target>
        </trans-unit>
        <trans-unit id="f8d3967f390234b0e1110f4076dff26d44bdbae2" translate="yes" xml:space="preserve">
          <source>If no &lt;var&gt;char&lt;/var&gt; argument is provided, a period (&amp;lsquo;</source>
          <target state="translated">If no &lt;var&gt;char&lt;/var&gt; argument is provided, a period (&amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="a2a4248b2b64fc34d7fa95f6235b59c5f46f6584" translate="yes" xml:space="preserve">
          <source>If no &lt;var&gt;length&lt;/var&gt; is specified, a value equivalent to the remaining character positions from &lt;var&gt;start&lt;/var&gt; to the end of &lt;var&gt;identifier-1&lt;/var&gt; or to the end of the value returned by the function will be assumed.</source>
          <target state="translated">If no &lt;var&gt;length&lt;/var&gt; is specified, a value equivalent to the remaining character positions from &lt;var&gt;start&lt;/var&gt; to the end of &lt;var&gt;identifier-1&lt;/var&gt; or to the end of the value returned by the function will be assumed.</target>
        </trans-unit>
        <trans-unit id="5a3a61b3775ed7776f1c79b27fb6ed8d88789b91" translate="yes" xml:space="preserve">
          <source>If no data division sections are needed, the &lt;code&gt;DATA DIVISION.&lt;/code&gt; header itself may be omitted.</source>
          <target state="translated">If no data division sections are needed, the &lt;code&gt;DATA DIVISION.&lt;/code&gt; header itself may be omitted.</target>
        </trans-unit>
        <trans-unit id="80ec6de7e7c7e7960f42ef9bf764d5e364ff0ae6" translate="yes" xml:space="preserve">
          <source>If no data division sections are needed, the&lt;code&gt;DATA DIVISION.&lt;/code&gt;header itself may be omitted.</source>
          <target state="translated">데이터 분할 섹션이 필요하지 않으면 &lt;code&gt;DATA DIVISION.&lt;/code&gt; 헤더 자체는 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5c8083a19d4bf6b791a2ad3bee37fd9780d046a" translate="yes" xml:space="preserve">
          <source>If no data will be described in one of the data division sections, that section header may be omitted.</source>
          <target state="translated">데이터 분할 섹션 중 하나에서 데이터가 설명되지 않으면, 해당 섹션 헤더는 생략 될 수있다.</target>
        </trans-unit>
        <trans-unit id="052c39714759c532cb982b4e847835f597be06cb" translate="yes" xml:space="preserve">
          <source>If no environment variable was found, or the</source>
          <target state="translated">If no environment variable was found, or the</target>
        </trans-unit>
        <trans-unit id="4ea37cd62fe13ae475efaf0fa631e7d1254a22ce" translate="yes" xml:space="preserve">
          <source>If no environment variable was found, or the &quot;config&quot; file used to compile the program had a &quot;filename-mapping&quot; value of &quot;no&quot;, then the File Locator String value will serve as the path and filename to the data file.</source>
          <target state="translated">환경 변수가 없거나 프로그램을 컴파일하는 데 사용 된 &quot;config&quot;파일의 &quot;filename-mapping&quot;값이 &quot;no&quot;인 경우 File Locator String 값은 데이터 파일의 경로 및 파일 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bd8e0699d8e0136dc7ce2219053480886ff4034d" translate="yes" xml:space="preserve">
          <source>If no format or range problems occur during evaluation of &lt;var&gt;argument-2&lt;/var&gt; according to the format in &lt;var&gt;argument-1&lt;/var&gt;, the returned value is zero. Otherwise the returned value is the ordinal character position at which the first error in &lt;var&gt;argument-2&lt;/var&gt; was detected.</source>
          <target state="translated">If no format or range problems occur during evaluation of &lt;var&gt;argument-2&lt;/var&gt; according to the format in &lt;var&gt;argument-1&lt;/var&gt; , the returned value is zero. Otherwise the returned value is the ordinal character position at which the first error in &lt;var&gt;argument-2&lt;/var&gt; was detected.</target>
        </trans-unit>
        <trans-unit id="97d63005403252ba6869749f325e5b668c7826c7" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;ADVANCING&lt;/code&gt;clause is specified on a&lt;code&gt;WRITE&lt;/code&gt;to a line-advancing file,&lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt;will be assumed; on other than line-advancing files,&lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt;will be assumed.</source>
          <target state="translated">&lt;code&gt;WRITE&lt;/code&gt; 에 &lt;code&gt;ADVANCING&lt;/code&gt; 절이 라인 어드밴 &lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt; 파일 에 지정 되지 않으면 AFTER ADVANCING 1 LINE 이 가정됩니다. &lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt; 진행 파일 이외의 다른 파일에서는 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6c0dd54af0bcfe6aba553419a7f8fa41175966da" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;AFTER&lt;/code&gt;is specified, the first character position of the target range will be character position #1 of the inspect subject.</source>
          <target state="translated">&lt;code&gt;AFTER&lt;/code&gt; 를 지정 하지 않으면 대상 범위의 첫 번째 문자 위치가 검사 대상의 문자 위치 # 1이됩니다.</target>
        </trans-unit>
        <trans-unit id="15393df0a9af6eb90b29b75caf239e68d67158ac" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;BEFORE&lt;/code&gt;is specified, the last character position of the target range will be the last character position of the inspect subject.</source>
          <target state="translated">&lt;code&gt;BEFORE&lt;/code&gt; 를 지정 하지 않으면 대상 범위의 마지막 문자 위치가 검사 대상의 마지막 문자 위치가됩니다.</target>
        </trans-unit>
        <trans-unit id="1a0d2b27d4ce9b801ffdc741e7e7060c7a514405" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;COLLATING SEQUENCE&lt;/code&gt;clause is specified, the collating sequence implied by the character set native to the computer (usually ASCII) will be used.</source>
          <target state="translated">&lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; 절이 지정 되지 않은 경우 컴퓨터 고유의 문자 세트 (일반적으로 ASCII)가 암시하는 조합 순서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="938ef54a5b2f3a79dc5e586019fcecd25b200f27" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;FIRST&lt;/code&gt;&lt;code&gt;LAST&lt;/code&gt;or&lt;code&gt;KEY&lt;/code&gt;clause is specified,&lt;code&gt;KEY IS EQUAL TO xxx&lt;/code&gt;will be assumed, where &quot;xxx&quot; is the defined&lt;code&gt;RELATIVE KEY&lt;/code&gt;of (if &amp;lt;</source>
          <target state="translated">&lt;code&gt;FIRST&lt;/code&gt; &lt;code&gt;LAST&lt;/code&gt; 또는 &lt;code&gt;KEY&lt;/code&gt; 절이 지정 되지 않은 경우 , &lt;code&gt;KEY IS EQUAL TO xxx&lt;/code&gt; 가 가정됩니다. 여기서 &quot;xxx&quot;는 정의 된 &lt;code&gt;RELATIVE KEY&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="3c134ddd26a13c987732536178ffc2d3596e0cc0" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;FROM&lt;/code&gt;clause is specified,&lt;code&gt;FROM CONSOLE&lt;/code&gt;is assumed.</source>
          <target state="translated">&lt;code&gt;FROM&lt;/code&gt; 절이 지정 되지 않으면 &lt;code&gt;FROM CONSOLE&lt;/code&gt; 이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="a936605766c63b6943b34a949cbfd95d11891a47" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;PAGE LIMITS&lt;/code&gt;clause is specified, the entire report will be generated as if it consists of a single arbitrarily long page.</source>
          <target state="translated">&lt;code&gt;PAGE LIMITS&lt;/code&gt; 절을 지정 하지 않으면 , 임의의 긴 페이지로 구성된 것처럼 전체 보고서가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="8df6bcbeab6aa11894e4fe7cbd9a91d3d00317e5" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;UPON&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;UPON&lt;/code&gt; 이 없으면</target>
        </trans-unit>
        <trans-unit id="fe6ea8dfb325db99c6308c46b06bda141821bb43" translate="yes" xml:space="preserve">
          <source>If no&lt;code&gt;VALUE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;VALUE&lt;/code&gt; 가 없으면</target>
        </trans-unit>
        <trans-unit id="17a7486226a182e50e61ddf27a8089d1e7d3a4e7" translate="yes" xml:space="preserve">
          <source>If none of the features provided by the configuration section are required by a program, the entire &lt;code&gt;CONFIGURATION SECTION.&lt;/code&gt; header may be omitted from the program.</source>
          <target state="translated">If none of the features provided by the configuration section are required by a program, the entire &lt;code&gt;CONFIGURATION SECTION.&lt;/code&gt; header may be omitted from the program.</target>
        </trans-unit>
        <trans-unit id="acc316a6b22ed428d8859027514f370adf001d62" translate="yes" xml:space="preserve">
          <source>If none of the features provided by the configuration section are required by a program, the entire&lt;code&gt;CONFIGURATION SECTION.&lt;/code&gt;header may be omitted from the program.</source>
          <target state="translated">구성 섹션에서 제공하는 기능이 프로그램에 필요하지 않은 경우 전체 &lt;code&gt;CONFIGURATION SECTION.&lt;/code&gt; 프로그램에서 헤더를 생략해도됩니다.</target>
        </trans-unit>
        <trans-unit id="38302bf8e20435daf87449711673f45dc0fc7efa" translate="yes" xml:space="preserve">
          <source>If none of the paragraphs within one of the sections are coded, the section header itself may be omitted.</source>
          <target state="translated">섹션 중 하나 내의 단락이 코딩되지 않은 경우 섹션 헤더 자체는 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dadd5125e77aeeda6a5112001c153a016dba637" translate="yes" xml:space="preserve">
          <source>If none of the sections within the data division are coded (a highly unlikely, but theoretically possible circumstance), the &lt;code&gt;DATA DIVISION.&lt;/code&gt; header itself may be omitted.</source>
          <target state="translated">If none of the sections within the data division are coded (a highly unlikely, but theoretically possible circumstance), the &lt;code&gt;DATA DIVISION.&lt;/code&gt; header itself may be omitted.</target>
        </trans-unit>
        <trans-unit id="c20690aa244c08791983cf1b27135cf3c295161b" translate="yes" xml:space="preserve">
          <source>If none of the sections within the data division are coded (a highly unlikely, but theoretically possible circumstance), the&lt;code&gt;DATA DIVISION.&lt;/code&gt;header itself may be omitted.</source>
          <target state="translated">데이터 분할 내의 섹션이 코딩되지 않은 경우 (아마도 가능하지만 이론적으로 가능한 상황) &lt;code&gt;DATA DIVISION.&lt;/code&gt; 헤더 자체는 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="614f1bfd9e62febeba4cb5fdaea32c820a1ed346" translate="yes" xml:space="preserve">
          <source>If none of the sections within the environment division are coded, the &lt;code&gt;ENVIRONMENT DIVISION.&lt;/code&gt; header itself may be omitted.</source>
          <target state="translated">If none of the sections within the environment division are coded, the &lt;code&gt;ENVIRONMENT DIVISION.&lt;/code&gt; header itself may be omitted.</target>
        </trans-unit>
        <trans-unit id="0a6df96501f79aab798f69106ec9e2b97487e708" translate="yes" xml:space="preserve">
          <source>If none of the sections within the environment division are coded, the&lt;code&gt;ENVIRONMENT DIVISION.&lt;/code&gt;header itself may be omitted.</source>
          <target state="translated">환경 부서 내의 섹션이 코딩되지 않은 경우 &lt;code&gt;ENVIRONMENT DIVISION.&lt;/code&gt; 헤더 자체는 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f3504ace1fcbbfe8785eaf44906c2e8b0fac8ce" translate="yes" xml:space="preserve">
          <source>If references to table elements are going to be performed many, many times (tens or hundreds of thousands of times or more) during program execution, you will probably see a noticeable reduction in program execution time if you use indexing versus subscripting.</source>
          <target state="translated">프로그램을 실행하는 동안 테이블 요소에 대한 참조를 여러 번 (수십 또는 수십만 회 이상) 수행하려는 경우 인덱싱과 첨자를 사용하면 프로그램 실행 시간이 눈에 띄게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="8e464aa3baae37e1c17db766f8597a99a293b6e4" translate="yes" xml:space="preserve">
          <source>If references to table elements are not going to be performed many, many times it probably won&amp;rsquo;t make much difference whether you use indexing or subscripting.</source>
          <target state="translated">테이블 요소에 대한 참조가 여러 번 수행되지 않으면 인덱싱 또는 첨자 사용 여부에 따라 큰 차이가 없을 것입니다.</target>
        </trans-unit>
        <trans-unit id="aaecf6782edaccec3acfe39a9b02ed5a4cd9c916" translate="yes" xml:space="preserve">
          <source>If rule</source>
          <target state="translated">If 규칙</target>
        </trans-unit>
        <trans-unit id="2d7b2b72b6ddc84fee15212248b1a81b23f1b096" translate="yes" xml:space="preserve">
          <source>If rule (A) is violated, the compiler will reject the&lt;code&gt;SEARCH ALL&lt;/code&gt; If rules (B) and/or (C) are violated, there will be no message issued by the compiler, but the run-time results of a&lt;code&gt;SEARCH ALL&lt;/code&gt;against the table will probably be incorrect.</source>
          <target state="translated">규칙 (A)를 위반하는 경우, 거부합니다 컴파일러 &lt;code&gt;SEARCH ALL&lt;/code&gt; 규칙 (B) 및 / 또는 (C)를 위반하는 경우, 컴파일러에 의해 발행 된 어떠한 메시지,하지만의 런타임 결과가 없습니다 &lt;code&gt;SEARCH ALL&lt;/code&gt; 에 대한 테이블이 잘못되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="953965bec96dd86973cb12584b0c3f4d8e27d9dc" translate="yes" xml:space="preserve">
          <source>If set to &quot;Y&quot;, &quot;y&quot; or &quot;1&quot;, a&lt;code&gt;CANCEL&lt;/code&gt;statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;) will physically unload a subprogram dynamically-loadable module.</source>
          <target state="translated">&quot;Y&quot;, &quot;y&quot;또는 &quot;1&quot;로 설정되면 &lt;code&gt;CANCEL&lt;/code&gt; 문 ( &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt; 참조 )이 서브 프로그램 동적로드 가능 모듈을 실제로 언로드합니다.</target>
        </trans-unit>
        <trans-unit id="f88d67aae9fbbcc5e6bf0dc40d8e5dbe106478a0" translate="yes" xml:space="preserve">
          <source>If set to &amp;lsquo;</source>
          <target state="translated">'로 설정하면</target>
        </trans-unit>
        <trans-unit id="e304fe2f130a29229fe3b203d139f3c8d0b1b8a9" translate="yes" xml:space="preserve">
          <source>If set to a value of &quot;Y&quot;, any run-time warnings (such as noting the implicit closing of open files when a&lt;code&gt;GOBACK&lt;/code&gt;statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) or&lt;code&gt;STOP&lt;/code&gt;statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) with the&lt;code&gt;RUN&lt;/code&gt;option is executed) will be displayed. Any other value for this environment variable (including not setting the variable at all) will suppress such messages.</source>
          <target state="translated">&quot;Y&quot;값으로 설정하면 모든 런타임 경고 (예 : &lt;code&gt;GOBACK&lt;/code&gt; 문 ( &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt; 참조 ) 또는 &lt;code&gt;RUN&lt;/code&gt; 옵션으로 &lt;code&gt;STOP&lt;/code&gt; 문 ( &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt; 참조 )을 실행할 때 열린 파일을 암시 적으로 닫는 것과 같은 )가 표시됩니다. . 이 환경 변수의 다른 값 (변수를 전혀 설정하지 않은 것을 포함하여)은 그러한 메시지를 억제합니다.</target>
        </trans-unit>
        <trans-unit id="2e24028937a15160864d8d70027a4e0de73165b6" translate="yes" xml:space="preserve">
          <source>If set to a value of &amp;lsquo;</source>
          <target state="translated">'의 값으로 설정된 경우</target>
        </trans-unit>
        <trans-unit id="2bc077c4c98b87e839493508304c45c1d8484f6d" translate="yes" xml:space="preserve">
          <source>If set to a value of upper- or lower-case &quot;p&quot;, this variable will force a file commit every time a file is written to (ensuring that data is immediately written to the file rather than retained in memory until a future commit occurs). This will slow-down update access to files, but will provide for better integrity in the event of a program failure.</source>
          <target state="translated">대문자 또는 소문자 &quot;p&quot;값으로 설정하면이 변수는 파일을 쓸 때마다 파일 커밋을 강제 실행합니다 (미래 커밋이 발생할 때까지 데이터가 메모리에 유지되지 않고 즉시 파일에 기록되도록 보장합니다) ). 이렇게하면 파일에 대한 업데이트 액세스 속도가 느려지지만 프로그램 오류 발생시 무결성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="8ef009313288e4b38dade52c03aab10d1ff99537" translate="yes" xml:space="preserve">
          <source>If set to a value of upper- or lower-case &amp;lsquo;</source>
          <target state="translated">대문자 또는 소문자 값으로 설정된 경우 '</target>
        </trans-unit>
        <trans-unit id="a40079ff225e97a80fb28e577e2103bb2e14eadc" translate="yes" xml:space="preserve">
          <source>If set to any non-blank value, this variable allows a &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) to detect the &lt;code&gt;Esc&lt;/code&gt; key.</source>
          <target state="translated">공백이 아닌 값으로 설정하면이 변수를 사용하면 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 문 ( &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item 참조&lt;/a&gt; )이 &lt;code&gt;Esc&lt;/code&gt; 키 를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ff6dd80412acb65fea091eeee45227f17f79745" translate="yes" xml:space="preserve">
          <source>If set to any non-blank value, this variable allows a&lt;code&gt;ACCEPT screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) to detect the &quot;Esc&quot; key.</source>
          <target state="translated">공백이 아닌 값으로 설정된 경우이 변수를 사용하면 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 명령문 ( &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT 화면 데이터 항목 참조&lt;/a&gt; )이 &quot;Esc&quot;키를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1484a009cf90e95f0122b3b84adf74c213a3afb" translate="yes" xml:space="preserve">
          <source>If set to any non-null value, this environment variable specifies the file to which all</source>
          <target state="translated">널이 아닌 값으로 설정하면이 환경 변수는 모든</target>
        </trans-unit>
        <trans-unit id="02c873d8dea11df102afae708aa8d02b69151e6b" translate="yes" xml:space="preserve">
          <source>If set to any non-null value, this environment variable specifies the file to which all&lt;code&gt;-ftrace&lt;/code&gt;switch and&lt;code&gt;-ftraceall&lt;/code&gt;switch output will be written.</source>
          <target state="translated">널이 아닌 값으로 설정되면이 환경 변수는 모든 &lt;code&gt;-ftrace&lt;/code&gt; 스위치 및 &lt;code&gt;-ftraceall&lt;/code&gt; 스위치 출력이 기록 될 파일을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="422d3cddd2d7b811c88085d18de9df66cdccb313" translate="yes" xml:space="preserve">
          <source>If set to any non-null value, this variable will cause all dynamically-loadable libraries to be loaded when the program begins execution (rather than searching for and loading the module upon first use).</source>
          <target state="translated">널이 아닌 값으로 설정되면이 변수는 프로그램이 실행을 시작할 때 (처음 사용할 때 모듈을 검색하여로드하지 않고) 동적으로로드 가능한 모든 라이브러리를로드합니다.</target>
        </trans-unit>
        <trans-unit id="d8aab5d7cf6334fa7d1d64a36e03690790d2311f" translate="yes" xml:space="preserve">
          <source>If set to anything else, a&lt;code&gt;CANCEL&lt;/code&gt;statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;) logically unloads a module so that subsequent use will re-initialize the module as if it had actually been reloaded, but the overhead of actually reloading the module will be avoided.</source>
          <target state="translated">다른 것으로 설정하면 &lt;code&gt;CANCEL&lt;/code&gt; 문 ( &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt; 참조 )이 모듈을 논리적으로 언로드하여 후속 사용에서 실제로 재로드 된 것처럼 모듈을 다시 초기화하지만 실제로 재로드하는 오버 헤드는 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a128e5ae83dd950222f98e00dbd8196d885904f" translate="yes" xml:space="preserve">
          <source>If set to either &lt;code&gt;UPPER&lt;/code&gt; or &lt;code&gt;LOWER&lt;/code&gt;, this environment variable will internally convert referenced entry-point names to either upper- or lower-case before initiating searches for dynamically-loadable modules. The &lt;code&gt;UPPER&lt;/code&gt; and &lt;code&gt;LOWER&lt;/code&gt; values of the environment variable are actually case-insensitive.</source>
          <target state="translated">&lt;code&gt;UPPER&lt;/code&gt; 또는 &lt;code&gt;LOWER&lt;/code&gt; 로 설정된 경우이 환경 변수는 동적으로로드 가능한 모듈 검색을 시작하기 전에 참조 된 진입 점 이름을 대문자 또는 소문자로 내부적으로 변환합니다. 환경 변수 의 &lt;code&gt;UPPER&lt;/code&gt; 및 &lt;code&gt;LOWER&lt;/code&gt; 값은 실제로 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ffb03e9553a2471b244e5697186cb21ecae1836a" translate="yes" xml:space="preserve">
          <source>If set to either&lt;code&gt;UPPER&lt;/code&gt;or&lt;code&gt;LOWER&lt;/code&gt; this environment variable will internally convert referenced entry-point names to either upper- or lower-case before initiating searches for dynamically-loadable modules. The&lt;code&gt;UPPER&lt;/code&gt;and&lt;code&gt;LOWER&lt;/code&gt;values of the environment variable are actually case-insensitive.</source>
          <target state="translated">&lt;code&gt;UPPER&lt;/code&gt; 또는 &lt;code&gt;LOWER&lt;/code&gt; 로 설정되면 이 환경 변수는 동적으로로드 가능한 모듈에 대한 검색을 시작하기 전에 참조 된 진입 점 이름을 내부적으로 대문자 또는 소문자로 변환합니다. 환경 변수 의 &lt;code&gt;UPPER&lt;/code&gt; 및 &lt;code&gt;LOWER&lt;/code&gt; 값은 실제로 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75ff3ad897d4389bd5d4346a9d0cead6b649265f" translate="yes" xml:space="preserve">
          <source>If specified, &amp;lt;</source>
          <target state="translated">지정된 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f6d52ca0abfa8f5411c2983924d29df64c8c256d" translate="yes" xml:space="preserve">
          <source>If specified, &lt;var&gt;file-name-1&lt;/var&gt; and &lt;var&gt;file-name-2&lt;/var&gt; must reference &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt;) or &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;) files. These files must be defined using a file description (&lt;code&gt;FD&lt;/code&gt; (see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;)). The same file(s) may be used for &lt;var&gt;file-name-1&lt;/var&gt; and &lt;var&gt;file-name-2&lt;/var&gt;.</source>
          <target state="translated">지정된 경우 &lt;var&gt;file-name-1&lt;/var&gt; 및 &lt;var&gt;file-name-2&lt;/var&gt; 는 &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; ( &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt; 참조 ) 또는 &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; ( &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt; 참조 ) 파일을 참조해야 합니다. 이러한 파일은 파일 설명을 사용하여 정의해야합니다 ( &lt;code&gt;FD&lt;/code&gt; ( &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File / Sort-Description 참조&lt;/a&gt; )). &lt;var&gt;file-name-1&lt;/var&gt; 및 &lt;var&gt;file-name-2&lt;/var&gt; 에 동일한 파일을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d643f7a76d11f3783c425395dd049a444b2d9584" translate="yes" xml:space="preserve">
          <source>If specified, &lt;var&gt;literal-1&lt;/var&gt; must be an actual alphanumeric literal and may not be a figurative constant.</source>
          <target state="translated">지정된 경우 &lt;var&gt;literal-1&lt;/var&gt; 은 실제 영숫자 리터럴이어야하며 형상 상수가 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="a61102f29e127858b5b49ad3ddadb11d241c6452" translate="yes" xml:space="preserve">
          <source>If the  &lt;code&gt;CONSTANT&lt;/code&gt; option is used, &lt;var&gt;literal-1&lt;/var&gt; must also be used. This option provides another means of defining constants that may be used anywhere in the program that a literal could be specified.</source>
          <target state="translated">는 IF &lt;code&gt;CONSTANT&lt;/code&gt; 옵션을 사용, &lt;var&gt;literal-1&lt;/var&gt; 도 사용할 수 있어야합니다. 이 옵션은 리터럴을 지정할 수있는 프로그램의 모든 위치에서 사용할 수있는 상수를 정의하는 또 다른 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1b97cb6dfd7464ecb308b4b7b48f8c5eb2d3f1b9" translate="yes" xml:space="preserve">
          <source>If the  &lt;code&gt;CRT STATUS&lt;/code&gt; clause is not specified, an implicit  &lt;code&gt;COB-CRT-STATUS&lt;/code&gt; identifier (with a &lt;code&gt;PICTURE 9(4)&lt;/code&gt;) will be allocated for the purpose of receiving screen &lt;code&gt;ACCEPT&lt;/code&gt; statuses. If &lt;code&gt;CRT STATUS&lt;/code&gt; is specified, then &lt;var&gt;identifier-1&lt;/var&gt; must be defined in the program as a &lt;code&gt;PICTURE 9(4)&lt;/code&gt; field.</source>
          <target state="translated">경우] &lt;code&gt;CRT STATUS&lt;/code&gt; 절을 지정하지 내재적 &lt;code&gt;COB-CRT-STATUS&lt;/code&gt; (a와 식별자 &lt;code&gt;PICTURE 9(4)&lt;/code&gt; )의 수신 화면이 목적을 위해 할당 될 &lt;code&gt;ACCEPT&lt;/code&gt; 상태를. &lt;code&gt;CRT STATUS&lt;/code&gt; 가 지정된 경우 &lt;var&gt;identifier-1&lt;/var&gt; 은 프로그램에서 &lt;code&gt;PICTURE 9(4)&lt;/code&gt; 필드 로 정의되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="3d34d52f388167ee4038f6dc4387fe17a911a532" translate="yes" xml:space="preserve">
          <source>If the  &lt;code&gt;LOCK ON&lt;/code&gt; clause is</source>
          <target state="translated">는 IF &lt;code&gt;LOCK ON&lt;/code&gt; 의 절입니다</target>
        </trans-unit>
        <trans-unit id="10f70fdda4e9fca981b962e0cf0e57130077fb32" translate="yes" xml:space="preserve">
          <source>If the  &lt;code&gt;REMAINDER&lt;/code&gt; clause is coded, there may be only one &lt;var&gt;identifier-3&lt;/var&gt; specified.</source>
          <target state="translated">&lt;code&gt;REMAINDER&lt;/code&gt; 절이 코딩 된 경우 &lt;var&gt;identifier-3&lt;/var&gt; 이 하나만 지정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc641baf619f0e3d0d10496e69f3b55fd6e604c8" translate="yes" xml:space="preserve">
          <source>If the &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="e13e056c87fa2f427f793205b7eacd30a5fd277c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ACCESS MODE&lt;/code&gt; of &lt;var&gt;file-name-1&lt;/var&gt; is &lt;code&gt;RANDOM&lt;/code&gt;, this is the</source>
          <target state="translated">는 IF &lt;code&gt;ACCESS MODE&lt;/code&gt; 의 &lt;var&gt;file-name-1&lt;/var&gt; 입니다 &lt;code&gt;RANDOM&lt;/code&gt; 이 , 이것은이다</target>
        </trans-unit>
        <trans-unit id="cbfec2ca247c35b1fe3cd674bf865aa9c4e77254" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ACCESS MODE&lt;/code&gt; of &lt;var&gt;file-name-1&lt;/var&gt; is &lt;code&gt;SEQUENTIAL&lt;/code&gt;, or the &lt;code&gt;ORGANIZATION&lt;/code&gt; of the file is any form of sequential, this format of the &lt;code&gt;READ&lt;/code&gt; statement cannot be used.</source>
          <target state="translated">는 IF &lt;code&gt;ACCESS MODE&lt;/code&gt; 의 &lt;var&gt;file-name-1&lt;/var&gt; 이다 &lt;code&gt;SEQUENTIAL&lt;/code&gt; 또는 &lt;code&gt;ORGANIZATION&lt;/code&gt; 파일의 순차적의 형태이며,의 형식 &lt;code&gt;READ&lt;/code&gt; 문을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b99a4ee59cfeb5de61b259ea000c70aa7e4d712" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ADDRESS OF&lt;/code&gt; clause is absent after the &lt;code&gt;TO&lt;/code&gt;, the contents of &lt;var&gt;pointer-name-2&lt;/var&gt; will serve as the address to be assigned.</source>
          <target state="translated">는 IF &lt;code&gt;ADDRESS OF&lt;/code&gt; 절은 후 결석 &lt;code&gt;TO&lt;/code&gt; 의 내용 &lt;var&gt;pointer-name-2&lt;/var&gt; 주소가 할당하는 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="3a39328d467fa4aba02370624eef3ef047a3e884" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ALL&lt;/code&gt; keyword was specified on the &lt;code&gt;VALUE&lt;/code&gt; clause, all members of the field list with &lt;code&gt;VALUE&lt;/code&gt; clauses will qualify.</source>
          <target state="translated">는 IF &lt;code&gt;ALL&lt;/code&gt; 의 키워드가에 지정된 &lt;code&gt;VALUE&lt;/code&gt; 의 절과 필드 목록의 모든 구성원 &lt;code&gt;VALUE&lt;/code&gt; 의 조항은 자격이됩니다.</target>
        </trans-unit>
        <trans-unit id="affc8978f778bb38e14313c6ca5fcc039529bb95" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ANYCASE&lt;/code&gt; keyword is specified, the matching rules for detecting a currency string in &lt;var&gt;argument-1&lt;/var&gt; are case-insensitive. If not specified, the matching rules are case-sensitive.</source>
          <target state="translated">는 IF &lt;code&gt;ANYCASE&lt;/code&gt; 의 키워드가 지정되면, 매칭에 통화 문자열을 검출 규칙 &lt;var&gt;argument-1&lt;/var&gt; 대소 문자를 구별하지 않는다. 지정되지 않은 경우 일치 규칙은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="6c01a232d52ad2f85603f61ab340b0cc67dd59c9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ANYCASE&lt;/code&gt; keyword is used the matching rules for detecting a currency string in &lt;var&gt;argument-1&lt;/var&gt; are case-insensitive. If the &lt;code&gt;ANYCASE&lt;/code&gt; keyword is not specified, the matching rules are case-sensitive.</source>
          <target state="translated">는 IF &lt;code&gt;ANYCASE&lt;/code&gt; 의 키워드에 통화 문자열을 검출하는 일치 규칙을 사용 &lt;var&gt;argument-1&lt;/var&gt; 대소 문자를 구별하지 않는다. 는 IF &lt;code&gt;ANYCASE&lt;/code&gt; 의 키워드가 지정되지 않고 일치하는 규칙은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="cb8f2b64fc86910982f5fae1234323c5b508ae09" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;DISPLAY&lt;/code&gt; verb is executing, then the size is the same as if the &lt;code&gt;CONVERT&lt;/code&gt; phrase were not specified except for numeric items. For numeric items, the size is the number of digits in the item, plus one if it is not an integer, plus one if it is signed. The remaining cases cover the size when an &lt;code&gt;ACCEPT&lt;/code&gt; statement is used.</source>
          <target state="translated">경우] &lt;code&gt;DISPLAY&lt;/code&gt; 가 동사 실행 후, 크기가 마치 동일 &lt;code&gt;CONVERT&lt;/code&gt; 의 구문은 숫자 항목을 제외하고 지정되지 않았다. 숫자 항목의 경우 크기는 항목의 자릿수이며 정수가 아닌 경우 1을 더하고 서명 된 경우 1을 더한 값입니다. 나머지 경우는 &lt;code&gt;ACCEPT&lt;/code&gt; 문이 사용될 때 크기를 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="b21479425a0b5f1b3972c0bb6a5e095100ce63f5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FD&lt;/code&gt; of the file contains the &lt;code&gt;RECORD CONTAINS&lt;/code&gt; or &lt;code&gt;RECORD IS VARYING&lt;/code&gt; clause, and that clause allows the record size to vary, the size</source>
          <target state="translated">파일 의 &lt;code&gt;FD&lt;/code&gt; 에 &lt;code&gt;RECORD CONTAINS&lt;/code&gt; 또는 &lt;code&gt;RECORD IS VARYING&lt;/code&gt; 절이 포함되어 있고 해당 절에서 레코드 크기를 변경할 수있는 경우 크기</target>
        </trans-unit>
        <trans-unit id="612748aa0fd9fd900088d10208b06bb3cf2d1475" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;FD&lt;/code&gt; of the file contains the &lt;code&gt;RECORD CONTAINS&lt;/code&gt; or &lt;code&gt;RECORD IS VARYING&lt;/code&gt; clause, and that clause allows the record size to vary, the size of &lt;var&gt;record-name-1&lt;/var&gt; cannot be altered.</source>
          <target state="translated">파일 의 &lt;code&gt;FD&lt;/code&gt; 에 &lt;code&gt;RECORD CONTAINS&lt;/code&gt; 또는 &lt;code&gt;RECORD IS VARYING&lt;/code&gt; 절이 포함되어 있고 해당 절이 레코드 크기를 변경하도록 허용하는 경우 &lt;var&gt;record-name-1&lt;/var&gt; 의 크기를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e7c0d4e8f13608d05ca72c7f3b1d750f90712a45" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;KEY&lt;/code&gt; clause</source>
          <target state="translated">경우] &lt;code&gt;KEY&lt;/code&gt; 의 절</target>
        </trans-unit>
        <trans-unit id="4547815fd9462b9fdfd1b9e08a5b31f916fcc311" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;KEY&lt;/code&gt; clause is absent, and the file is</source>
          <target state="translated">는 IF &lt;code&gt;KEY&lt;/code&gt; 의 절은 결석, 그리고 파일입니다</target>
        </trans-unit>
        <trans-unit id="c131416981dbc6b7002b415e8799c61201dcee0e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LINAGE&lt;/code&gt; (see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;) clause is</source>
          <target state="translated">만약 &lt;code&gt;LINAGE&lt;/code&gt; (참조 &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;파일 / 정렬-설명&lt;/a&gt; ) 절은</target>
        </trans-unit>
        <trans-unit id="5958dd0b525624c148252a3b2cc0e92d9d3b1d1c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;LOCK ON&lt;/code&gt; clause</source>
          <target state="translated">경우] &lt;code&gt;LOCK ON&lt;/code&gt; 의 절</target>
        </trans-unit>
        <trans-unit id="4d86db89a19e04fde3c518d2333f8c4d9f0d9c88" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PERFORM&lt;/code&gt; specifies or implies &lt;code&gt;WITH TEST BEFORE&lt;/code&gt;, &lt;var&gt;conditional-expression-1&lt;/var&gt; will be evaluated and processing of the &lt;code&gt;PERFORM&lt;/code&gt; will halt if the expression evaluates to &lt;code&gt;TRUE&lt;/code&gt;. If &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; was</source>
          <target state="translated">(가) 경우 &lt;code&gt;PERFORM&lt;/code&gt; 지정하거나 암시 &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; , &lt;var&gt;conditional-expression-1&lt;/var&gt; 평가하고이 처리 될 &lt;code&gt;PERFORM&lt;/code&gt; 식으로 평가되면 멈추게 &lt;code&gt;TRUE&lt;/code&gt; . 경우 &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; 이었다</target>
        </trans-unit>
        <trans-unit id="c8a8781b936d58dad050ed871a38906d8222a3e3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;PROGRAM-ID&lt;/code&gt; (see &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;) clause of the subprogram included the  &lt;code&gt;INITIAL&lt;/code&gt; clause, the program will be reinitialized back to its compile-time state. This will happen regardless of the &lt;code&gt;INITIAL&lt;/code&gt; clause the first time the subprogram is executed.</source>
          <target state="translated">서브 프로그램 의 &lt;code&gt;PROGRAM-ID&lt;/code&gt; ( &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt; 참조 ) 절에 &lt;code&gt;INITIAL&lt;/code&gt; 절이 포함 된 경우 프로그램은 컴파일 타임 상태로 다시 초기화됩니다. 이것은 서브 프로그램이 처음 실행될 때 &lt;code&gt;INITIAL&lt;/code&gt; 절에 관계없이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="61c625a5b9d0d59baca0aca12858bf1329830d25" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;RD&lt;/code&gt; (see &lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;) in which the report group containing a &lt;code&gt;NEXT GROUP&lt;/code&gt; clause does not contain a &lt;code&gt;PAGE LIMITS&lt;/code&gt; clause, only the &lt;code&gt;PLUS integer-1&lt;/code&gt; option may be specified.</source>
          <target state="translated">경우 &lt;code&gt;RD&lt;/code&gt; 는 (참조 &lt;a href=&quot;#REPORT-SECTION&quot;&gt;보고서 제&lt;/a&gt; 이 포함 된 보고서 그룹있는) &lt;code&gt;NEXT GROUP&lt;/code&gt; 의 조항이 포함되지 않은 &lt;code&gt;PAGE LIMITS&lt;/code&gt; 조항 만 &lt;code&gt;PLUS integer-1&lt;/code&gt; 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8e781dd56448e51eb78f19906f5d0d7a4bbccc2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;RESET&lt;/code&gt; option is coded, &lt;code&gt;FINAL&lt;/code&gt; or &lt;var&gt;identifier-8&lt;/var&gt; (whichever is coded on the &lt;code&gt;RESET&lt;/code&gt;) must be one of the report&amp;rsquo;s control breaks specified on the &lt;code&gt;CONTROLS&lt;/code&gt; clause.</source>
          <target state="translated">경우 &lt;code&gt;RESET&lt;/code&gt; 옵션을 코딩, &lt;code&gt;FINAL&lt;/code&gt; 또는 &lt;var&gt;identifier-8&lt;/var&gt; (온 코딩 중 &lt;code&gt;RESET&lt;/code&gt; )를 지정 보고서의 컨트롤 휴식 중 하나 여야합니다 &lt;code&gt;CONTROLS&lt;/code&gt; 절.</target>
        </trans-unit>
        <trans-unit id="9731559b4666a0155b6ed6fd6776bba0461135ca" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SELECT&lt;/code&gt; (see &lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt;) statement or file &lt;code&gt;OPEN&lt;/code&gt; (see &lt;a href=&quot;#OPEN&quot;&gt;OPEN&lt;/a&gt;) specifies &lt;code&gt;SHARING WITH NO OTHER&lt;/code&gt;, record locking will be disabled.</source>
          <target state="translated">경우 &lt;code&gt;SELECT&lt;/code&gt; 는 (참조 &lt;a href=&quot;#SELECT&quot;&gt;SELECT를&lt;/a&gt; ) 문 또는 파일 &lt;code&gt;OPEN&lt;/code&gt; (참조 &lt;a href=&quot;#OPEN&quot;&gt;OPEN가&lt;/a&gt; ) 지정 &lt;code&gt;SHARING WITH NO OTHER&lt;/code&gt; 기록 잠금이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="c36b400baefa619ddc6f8161b993620feb6e7338" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SELECT&lt;/code&gt; of a file is coded with a &lt;code&gt;FILE STATUS&lt;/code&gt; clause, &lt;code&gt;OPEN&lt;/code&gt; failures &amp;mdash; including those induced by sharing failures &amp;mdash; will be detectable by the program and a graceful recovery (or at least a graceful termination) will be possible. If no such clause was coded, however, a runtime message will be issued and the program will be terminated.</source>
          <target state="translated">파일 의 &lt;code&gt;SELECT&lt;/code&gt; 가 &lt;code&gt;FILE STATUS&lt;/code&gt; 절로 코딩 된 경우 공유 실패로 인한 실패를 포함하여 &lt;code&gt;OPEN&lt;/code&gt; 실패는 프로그램에서 감지 할 수 있으며 정상적인 복구 (또는 적어도 정상 종료)가 가능합니다. 그러나 그러한 절이 코딩되지 않은 경우 런타임 메시지가 발행되고 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="6ae0587444dde6ad68a36a9c51951f280dcedd0b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt; clause</source>
          <target state="translated">경우] &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt; 절</target>
        </trans-unit>
        <trans-unit id="8833ea8060feeb2e21ef8632dc5243ea617a1936" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SIZE&lt;/code&gt; phrase is not used, then the field length defaults to the size of the item being accepted or displayed. If the &lt;code&gt;CONVERT&lt;/code&gt; phrase is used, however, then the size of the field depends on the data type of the item and the verb being used.</source>
          <target state="translated">상기 중간 &lt;code&gt;SIZE&lt;/code&gt; 문구를 사용하지 않는, 다음 항목의 크기에 필드 길이 기본값이 허용 또는 표시되지. 경우 &lt;code&gt;CONVERT&lt;/code&gt; 의 문구를 사용하지만, 다음 필드의 크기는 사용되는 항목 동사의 데이터 유형에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="f2e7f31806cccbda89316cd317a96b918accf50b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;SYNCRONIZED&lt;/code&gt; clause is coded on anything but a numeric data item with a &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) that specifies storage of data in a binary form, the &lt;code&gt;SYNCRONIZED&lt;/code&gt; clause will be ignored.</source>
          <target state="translated">경우 &lt;code&gt;SYNCRONIZED&lt;/code&gt; 절은 아무것도하지만 숫자 데이터 항목에 코딩 &lt;code&gt;USAGE&lt;/code&gt; (참조 &lt;a href=&quot;#USAGE&quot;&gt;사용법을&lt;/a&gt; 바이너리 형태로 데이터의 지정 저장)에 &lt;code&gt;SYNCRONIZED&lt;/code&gt; 절은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="adb29705e22e972e94afa12e6e0d59c74f962b10" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;Program-Source-Lines-n&lt;/var&gt;&amp;gt; statement block selected for processing is empty, no error results &amp;mdash; there will just be no code generated from the &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt;-&lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; structure.</source>
          <target state="translated">경우] &lt;var&gt;Program-Source-Lines-n&lt;/var&gt; &amp;gt; 처리 선정 문 블록은 비어 오류 결과 - 단지 어떤 코드로부터 발생이 없을 것 &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; - &lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; 구조.</target>
        </trans-unit>
        <trans-unit id="564bf6b26846f0e8ea8231e86eea4efd5ec50259" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;Selection-Object&lt;/var&gt; is a &lt;var&gt;partial-expression&lt;/var&gt;, then the conditional expression that would be represented by coding &lt;code&gt;&lt;var&gt;Selection-Subject&lt;/var&gt; &lt;var&gt;Selection-Object&lt;/var&gt;&lt;/code&gt; evaluates to &lt;code&gt;TRUE&lt;/code&gt;</source>
          <target state="translated">는 IF &lt;var&gt;Selection-Object&lt;/var&gt; A는 &lt;var&gt;partial-expression&lt;/var&gt; 코딩으로 표현 될 것입니다, 다음 조건식 &lt;code&gt;&lt;var&gt;Selection-Subject&lt;/var&gt; &lt;var&gt;Selection-Object&lt;/var&gt;&lt;/code&gt; 로 평가를 &lt;code&gt;TRUE&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="66b0f3198b803257325039929d9fe35011c49095" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;date&lt;/var&gt; is valid, a 0 value is returned. If it isn&amp;rsquo;t, a value of 1, 2 or 3 is returned signalling the problem lies with the year, month or day, respectively.</source>
          <target state="translated">경우 &lt;var&gt;date&lt;/var&gt; 유효, 0 값이 반환됩니다. 그렇지 않은 경우 1, 2 또는 3 값이 반환되어 문제가 각각 연도, 월 또는 일에 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9c430cd31b9abfd8e44351ebd7f1aa3c9a7a5032" translate="yes" xml:space="preserve">
          <source>If the &lt;var&gt;identifier-1&lt;/var&gt; option was used, altering the value of that data item within the perform scope will</source>
          <target state="translated">는 IF &lt;var&gt;identifier-1&lt;/var&gt; 옵션을 사용하고, 그 내에서 데이터 항목의 값을 변경 스코프 뜻을 수행</target>
        </trans-unit>
        <trans-unit id="80f8927587ac8a416163b826212188d6cd97481c" translate="yes" xml:space="preserve">
          <source>If the DISPLAY verb is executing, then the size is the same as if the CONVERT phrase were not specified except for numeric items. For numeric items, the size is the number of digits in the item, plus one if it is not an integer, plus one if it is signed. The remaining cases cover the size when an ACCEPT statement is used.</source>
          <target state="translated">DISPLAY 동사가 실행중인 경우 크기는 숫자 항목을 제외하고 CONVERT 문구가 지정되지 않은 것과 같습니다. 숫자 항목의 경우 크기는 항목의 자릿수와 정수가 아닌 경우 1을 더한 값, 부호가있는 경우 1을 더한 값입니다. 나머지 경우는 ACCEPT 문이 사용될 때 크기를 커버합니다.</target>
        </trans-unit>
        <trans-unit id="fd1fa5d5fdcea9b7c73d25c9d04a3be93ca9dd38" translate="yes" xml:space="preserve">
          <source>If the GnuCOBOL build you are using was configured to use the Berkeley Database (BDB) package for indexed file I/O, record locking will be available by using the</source>
          <target state="translated">사용중인 GnuCOBOL 빌드가 색인화 된 파일 I / O에 Berkeley Database (BDB) 패키지를 사용하도록 구성된 경우 레코드 잠금은</target>
        </trans-unit>
        <trans-unit id="0d899de06d6d01d580a3dfba1caa36e62b45d65a" translate="yes" xml:space="preserve">
          <source>If the GnuCOBOL build you are using was configured to use the Berkeley Database (BDB) package for indexed file I/O, record locking will be available by using the   &lt;code&gt;DB_HOME&lt;/code&gt; run-time environment variable.</source>
          <target state="translated">사용중인 GnuCOBOL 빌드가 인덱싱 된 파일 I / O를 위해 BDB (Berkeley Database) 패키지를 사용하도록 구성된 경우 &lt;code&gt;DB_HOME&lt;/code&gt; 런타임 환경 변수 를 사용하여 레코드 잠금을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9251feae92fd6a356cf9eb5cd17eee1487827fc" translate="yes" xml:space="preserve">
          <source>If the GnuCOBOL compiler you are using was built to utilize a native Windows environment, use a semicolon (&amp;lsquo;</source>
          <target state="translated">사용중인 GnuCOBOL 컴파일러가 기본 Windows 환경을 활용하도록 빌드 된 경우 세미콜론 ( '</target>
        </trans-unit>
        <trans-unit id="aa11e579492cde59f0f2b4460dae0515f472c0c0" translate="yes" xml:space="preserve">
          <source>If the GnuCOBOL compiler you are using was built to utilize a native Windows environment, use a semicolon (;) as the delimiter character.</source>
          <target state="translated">사용중인 GnuCOBOL 컴파일러가 고유 Windows 환경을 사용하도록 빌드 된 경우 세미콜론 (;)을 구분 기호 문자로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e8e174d71b0a53ce0abb721ccafcd0e36830ee7a" translate="yes" xml:space="preserve">
          <source>If the LINAGE clause is</source>
          <target state="translated">LINAGE 절이</target>
        </trans-unit>
        <trans-unit id="876792b175fdff61a6c190841827c8f95e62bf94" translate="yes" xml:space="preserve">
          <source>If the SIZE phrase is not used, then the field length defaults to the size of the item being accepted or displayed. If the CONVERT phrase is used, however, then the size of the field depends on the data type of the item and the verb being used.</source>
          <target state="translated">SIZE 구문을 사용하지 않으면 필드 길이는 기본적으로 허용되거나 표시되는 항목의 크기입니다. 그러나 CONVERT 문구가 사용되는 경우 필드의 크기는 항목의 데이터 유형과 사용되는 동사에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="629f7e68a3bad837fc28d40bdbf837b0b7cb4fda" translate="yes" xml:space="preserve">
          <source>If the arguments are of different classes, and one is national, the other argument is converted to class national for purposes of comparison.</source>
          <target state="translated">인수가 다른 클래스이고 하나가 국가 인 경우 다른 인수는 비교를 위해 국가 클래스로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="56af7538068ae678c4d858d4ef9cbf8a92b01ddc" translate="yes" xml:space="preserve">
          <source>If the attempt to copy the file fails (for example, it or the destination directory doesn&amp;rsquo;t exist), the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">파일을 복사 할 수있는 시도가 실패하면 (예를 들어, 또는 존재하지 않는 대상 디렉토리)는 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터를&lt;/a&gt; 128로 설정됩니다) 성공적으로 완료되면 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a1a846b486d6a849fb5aee6dc27f07a8ed92c919" translate="yes" xml:space="preserve">
          <source>If the attempt to copy the file fails (for example, it or the destination directory doesn&amp;rsquo;t exist), the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">파일을 복사 할 수있는 시도가 실패하면 (예를 들어, 또는 존재하지 않는 대상 디렉토리)는 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터를&lt;/a&gt; 128로 설정됩니다) 성공적으로 완료되면 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="96df2a17b61b3c904901bfed0767bc034fc48ebb" translate="yes" xml:space="preserve">
          <source>If the attempt to delete the file fails (for example, it doesn&amp;rsquo;t exist), the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">파일을 삭제하는 시도가 (예를 들어, 존재하지 않는) 실패하면 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터를&lt;/a&gt; 128로 설정됩니다) 성공적으로 완료되면 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="da68db930b7285a3ca3007bae8464343ac79a0ea" translate="yes" xml:space="preserve">
          <source>If the attempt to delete the file fails (for example, it doesn&amp;rsquo;t exist), the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">파일을 삭제하는 시도가 (예를 들어, 존재하지 않는) 실패하면 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터를&lt;/a&gt; 128로 설정됩니다) 성공적으로 완료되면 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="46a66bc0217d79087be7ab86156a7254a4cba8b6" translate="yes" xml:space="preserve">
          <source>If the attempt to move the file fails (for example, it doesn&amp;rsquo;t exist), the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">파일을 이동하는 시도가 (예를 들어, 존재하지 않는) 실패하면 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터를&lt;/a&gt; 128로 설정됩니다) 성공적으로 완료되면 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6d499ade6d8bd513045d21fd97b496bc7d59e814" translate="yes" xml:space="preserve">
          <source>If the attempt to move the file fails (for example, it doesn&amp;rsquo;t exist), the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to 128; on successful completion it will be set to 0.</source>
          <target state="translated">파일을 이동하는 시도가 (예를 들어, 존재하지 않는) 실패하면 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터를&lt;/a&gt; 128로 설정됩니다) 성공적으로 완료되면 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9cc49a6a7bfb3aab04847a284111d2050a7803d8" translate="yes" xml:space="preserve">
          <source>If the binary item occupies four bytes of storage, the binary item is allocated at the next word boundary.</source>
          <target state="translated">이진 항목이 4 바이트의 스토리지를 차지하는 경우 이진 항목은 다음 단어 경계에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="c9eb3b2ff78316af9e06d9ecdca03186e9054272" translate="yes" xml:space="preserve">
          <source>If the binary item occupies one byte of storage, no synchronization is performed.</source>
          <target state="translated">이진 항목이 1 바이트의 저장소를 차지하면 동기화가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29ee50f202c57db2b363fa927e6f5d81d5d2accb" translate="yes" xml:space="preserve">
          <source>If the binary item occupies two bytes of storage, the binary item is allocated at the next half-word boundary.</source>
          <target state="translated">이진 항목이 2 바이트의 스토리지를 차지하면 이진 항목은 다음 반 단어 경계에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="1516aad53f3f5948528f5a4d82dbb11e687a6c3e" translate="yes" xml:space="preserve">
          <source>If the calling program included a &lt;code&gt;RETURNING&lt;/code&gt; clause on the &lt;code&gt;CALL&lt;/code&gt; statement that invoked the subprogram, the value of the &lt;code&gt;RETURNING&lt;/code&gt; data item in the subroutine is moved to that data item. If there was no &lt;code&gt;RETURNING&lt;/code&gt; specified in the subroutine, the value of the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register is moved to that data item.</source>
          <target state="translated">호출 프로그램 이 서브 프로그램을 호출 한 &lt;code&gt;CALL&lt;/code&gt; 문 에 &lt;code&gt;RETURNING&lt;/code&gt; 절을 포함 하면 서브 루틴 의 &lt;code&gt;RETURNING&lt;/code&gt; 데이터 항목 값이 해당 데이터 항목으로 이동됩니다. 서브 루틴에 &lt;code&gt;RETURNING&lt;/code&gt; 이 지정 되지 않은 경우 &lt;code&gt;RETURN-CODE&lt;/code&gt; 특수 레지스터 의 값이 해당 데이터 항목으로 이동됩니다.</target>
        </trans-unit>
        <trans-unit id="78d1c026459ef474eb28e2011cf978cfda3d3820" translate="yes" xml:space="preserve">
          <source>If the calling program included a&lt;code&gt;RETURNING&lt;/code&gt;clause on the&lt;code&gt;CALL&lt;/code&gt;statement that invoked the subprogram, the value of the&lt;code&gt;RETURNING&lt;/code&gt;data item in the subroutine is moved to that data item. If there was no&lt;code&gt;RETURNING&lt;/code&gt;specified in the subroutine, the value of the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register is moved to that data item.</source>
          <target state="translated">호출 프로그램 이 서브 프로그램을 호출 한 &lt;code&gt;CALL&lt;/code&gt; 문 에 &lt;code&gt;RETURNING&lt;/code&gt; 절을 포함 하면 서브 루틴 의 &lt;code&gt;RETURNING&lt;/code&gt; 데이터 항목 값이 해당 데이터 항목으로 이동됩니다. 서브 루틴에 &lt;code&gt;RETURNING&lt;/code&gt; 이 지정 되지 않은 경우 &lt;code&gt;RETURN-CODE&lt;/code&gt; 특수 레지스터 의 값이 해당 데이터 항목으로 이동됩니다.</target>
        </trans-unit>
        <trans-unit id="e083d7f833ec502784a9231152a3dee4dd0d633a" translate="yes" xml:space="preserve">
          <source>If the compiler</source>
          <target state="translated">컴파일러가</target>
        </trans-unit>
        <trans-unit id="237f820b1887571d0c11ce781473f803467fad98" translate="yes" xml:space="preserve">
          <source>If the compiler &quot;config&quot; file (see &lt;a href=&quot;#Compiler-Configuration-Files&quot;&gt;Compiler Configuration Files&lt;/a&gt;) you used to compile the program specified &quot;mf&quot; as the &quot;assign-clause&quot; value, then the File Locator String will be interpreted according to Microfocus COBOL rules &amp;mdash; namely, everything before the last &quot;-&quot; in the File Locator String will be ignored; the characters after the last &quot;-&quot; will be treated as the base of an environment variable name. If there is no &quot;-&quot; character in the File Locator String then the entire File Locator String will serve as the base of an environment variable name. This is the default behaviour for every config file except &quot;ibm&quot;.</source>
          <target state="translated">컴파일러 &quot;config&quot;파일 ( &lt;a href=&quot;#Compiler-Configuration-Files&quot;&gt;컴파일러 구성 파일&lt;/a&gt; 참조 )을 &quot;assign-clause&quot;값으로 &quot;mf&quot;로 지정한 프로그램을 컴파일하는 데 사용한 경우 파일 로케이터 문자열은 Microfocus COBOL 규칙에 따라 해석됩니다. File Locator String의 마지막 &quot;-&quot;는 무시됩니다. 마지막 &quot;-&quot;뒤의 문자는 환경 변수 이름의 기본으로 취급됩니다. 파일 로케이터 문자열에 &quot;-&quot;문자가 없으면 전체 파일 로케이터 문자열이 환경 변수 이름의 기본으로 사용됩니다. &quot;ibm&quot;을 제외한 모든 구성 파일의 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="be7c428b2bd6fcf64ba18d7fc20a33ae78ee6418" translate="yes" xml:space="preserve">
          <source>If the compiler &quot;config&quot; file you are using has &quot;relaxed-syntax-check&quot; set to &quot;yes&quot;, the&lt;code&gt;FILE-CONTROL&lt;/code&gt;and&lt;code&gt;I-O-CONTROL&lt;/code&gt;paragraphs may be specified without the&lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt;header having been coded.</source>
          <target state="translated">사용중인 컴파일러 &quot;config&quot;파일에 &quot;relaxed-syntax-check&quot;가 &quot;yes&quot;로 설정되어 있으면 &lt;code&gt;INPUT-OUTPUT SECTION.&lt;/code&gt; 없이 &lt;code&gt;FILE-CONTROL&lt;/code&gt; 및 &lt;code&gt;I-O-CONTROL&lt;/code&gt; 단락을 지정할 수 있습니다 . 헤더가 코딩되었습니다.</target>
        </trans-unit>
        <trans-unit id="fe92b0755173ad538d05379125cea0810a360175" translate="yes" xml:space="preserve">
          <source>If the compiler &quot;config&quot; file you used to compile the program with had a &quot;filename-mapping&quot; value of &quot;yes&quot;, the GnuCOBOL runtime system will first attempt to identify a currently-defined environment variable whose value will serve as the data file&amp;rsquo;s path and filename, as follows:</source>
          <target state="translated">프로그램을 컴파일하는 데 사용한 컴파일러 &quot;config&quot;파일의 &quot;filename-mapping&quot;값이 &quot;yes&quot;인 경우 GnuCOBOL 런타임 시스템은 먼저 값이 데이터 파일의 역할을하는 현재 정의 된 환경 변수를 식별하려고 시도합니다. 다음과 같이 경로 및 파일 이름 :</target>
        </trans-unit>
        <trans-unit id="ada8d4fd5949881c69e3976ea553cf9ce6a69ad2" translate="yes" xml:space="preserve">
          <source>If the compiler is already in the specified mode, this statement will have no effect.</source>
          <target state="translated">컴파일러가 이미 지정된 모드에있는 경우이 명령문은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e079882ba26c2f94b1fe1a9df7387534f553e034" translate="yes" xml:space="preserve">
          <source>If the condition associated with a variable is false, the variable is not defined during compilations.</source>
          <target state="translated">변수와 관련된 조건이 false이면 컴파일 중에 변수가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="481059d865593d9863661241b07d6b44c95410c1" translate="yes" xml:space="preserve">
          <source>If the condition-name has a value of &lt;code&gt;TRUE&lt;/code&gt;, the group will be presented.</source>
          <target state="translated">condition-name의 값이 &lt;code&gt;TRUE&lt;/code&gt; 이면 그룹이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3a326fe6a76a0eaf9c6262d498515fe5ffc5ef03" translate="yes" xml:space="preserve">
          <source>If the condition-name has a value of TRUE, the group will be presented.</source>
          <target state="translated">condition-name의 값이 TRUE이면 그룹이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4acbc5f8b855a0f2c7b341b78e53f686bdfdc939" translate="yes" xml:space="preserve">
          <source>If the counter has a value greater than zero, the statement(s) within the &lt;code&gt;PERFORM&lt;/code&gt; scope will be executed, after which the counter will be decremented by 1 with each repetition. Once that counter reaches zero, repetition will cease and control will fall into the next statement following the &lt;code&gt;PERFORM&lt;/code&gt;.</source>
          <target state="translated">카운터의 값이 0보다 큰 경우 &lt;code&gt;PERFORM&lt;/code&gt; 범위 내의 문 이 실행되고 그 후에 카운터는 반복 할 때마다 1 씩 감소합니다. 카운터가 0에 도달하면 반복이 중지되고 제어는 &lt;code&gt;PERFORM&lt;/code&gt; 다음에 오는 다음 문으로 넘어갑니다 .</target>
        </trans-unit>
        <trans-unit id="8c023cec5138da702e62deee764a0698dddd5f75" translate="yes" xml:space="preserve">
          <source>If the counter has a value greater than zero, the statement(s) within the&lt;code&gt;PERFORM&lt;/code&gt;scope will be executed, after which the counter will be decremented by 1 with each repetition. Once that counter reaches zero, repetition will cease and control will fall into the next statement following the&lt;code&gt;PERFORM&lt;/code&gt;</source>
          <target state="translated">카운터의 값이 0보다 크면 &lt;code&gt;PERFORM&lt;/code&gt; 범위 내의 문 이 실행 된 후 각 반복마다 카운터가 1 씩 감소합니다. 해당 카운터가 0에 도달하면 반복이 중단되고 &lt;code&gt;PERFORM&lt;/code&gt; 에 이어 다음 명령문으로 제어가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8c6046d88dbdb2938b2d2acebdcd24126952a996" translate="yes" xml:space="preserve">
          <source>If the cultural ordering table is not available on the processor, or the specified ordering level is not available, or the level number specified by &lt;var&gt;argument-4&lt;/var&gt; is not defined in the ordering table, the &lt;code&gt;EC-ORDER-NOT-SUPPORTED&lt;/code&gt; exception condition is set.</source>
          <target state="translated">프로세서에서 문화적 순서 지정 테이블을 사용할 수 없거나 지정된 순서 지정 수준을 사용할 수 없거나 &lt;var&gt;argument-4&lt;/var&gt; 지정된 레벨 번호 가 순서 지정 테이블에 정의되지 않은 경우 &lt;code&gt;EC-ORDER-NOT-SUPPORTED&lt;/code&gt; 예외 조건이 설정됩니다. .</target>
        </trans-unit>
        <trans-unit id="4e9e418e6dfdb063a1e13b0c99a0aba0ba8470f4" translate="yes" xml:space="preserve">
          <source>If the data item in which the &lt;code&gt;SUM&lt;/code&gt; clause appears has been assigned its own identifier name, and that name is not &lt;code&gt;FILLER&lt;/code&gt;, then that data item is referred to as a sum counter.</source>
          <target state="translated">&lt;code&gt;SUM&lt;/code&gt; 절이 표시 되는 데이터 항목에 자체 식별자 이름이 할당되고 해당 이름이 &lt;code&gt;FILLER&lt;/code&gt; 가 아닌 경우 해당 데이터 항목을 합계 카운터라고합니다.</target>
        </trans-unit>
        <trans-unit id="139a2f116480a978d8a516ae3f69011cef95b11e" translate="yes" xml:space="preserve">
          <source>If the data item in which the&lt;code&gt;SUM&lt;/code&gt;clause appears has been assigned it&amp;rsquo;s own identifier name, and that name is not&lt;code&gt;FILLER&lt;/code&gt; then that data item is referred to as a sum counter.</source>
          <target state="translated">&lt;code&gt;SUM&lt;/code&gt; 절이 나타나는 데이터 항목에 고유 식별자 이름이 할당되고 해당 이름이 &lt;code&gt;FILLER&lt;/code&gt; 가 아닌 경우 해당 데이터 항목을 합계 카운터라고합니다.</target>
        </trans-unit>
        <trans-unit id="d6641aac6877a23c3a650b80aa0141134bfbab68" translate="yes" xml:space="preserve">
          <source>If the date is valid, a 0 value is returned. If it isn&amp;rsquo;t, a value of 1 or 2 is returned signalling the problem lies with the year or day, respectively.</source>
          <target state="translated">날짜가 유효하면 0 값이 리턴됩니다. 그렇지 않은 경우 1 또는 2의 값이 반환되어 문제가 각각 년 또는 일에 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7b011773af10dd8c1b119874aa6b6d6a7bdffaf9" translate="yes" xml:space="preserve">
          <source>If the file defined by the &amp;lt;</source>
          <target state="translated">파일이 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="280352139004548c36bc2735b683a84068a2d2ad" translate="yes" xml:space="preserve">
          <source>If the file defined by the &lt;var&gt;file-handle&lt;/var&gt; argument (a &lt;code&gt;PIC X(4) USAGE COMP-X&lt;/code&gt; data item) was opened for output, an implicit &lt;code&gt;CBL_FLUSH_FILE&lt;/code&gt; built-in system subroutine (see &lt;a href=&quot;#CBL_005fFLUSH_005fFILE&quot;&gt;CBL_FLUSH_FILE&lt;/a&gt;) will be performed before the file is closed.</source>
          <target state="translated">&lt;var&gt;file-handle&lt;/var&gt; 인수 ( &lt;code&gt;PIC X(4) USAGE COMP-X&lt;/code&gt; 데이터 항목)에 의해 정의 된 파일이 출력을 위해 열린 경우 파일이 닫히기 전에 암시 적 &lt;code&gt;CBL_FLUSH_FILE&lt;/code&gt; 내장 시스템 서브 루틴 ( &lt;a href=&quot;#CBL_005fFLUSH_005fFILE&quot;&gt;CBL_FLUSH_FILE&lt;/a&gt; 참조 )이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b49b836ff4d8cb3dab39eaf631a058c6fcd3656e" translate="yes" xml:space="preserve">
          <source>If the file has &lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt;, the record to be rewritten will be the one retrieved by the most-recently executed &lt;code&gt;READ&lt;/code&gt; of the file. If the file has &lt;code&gt;ACCESS MODE RANDOM&lt;/code&gt; or &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt;, no &lt;code&gt;READ&lt;/code&gt; is required before a record may be rewritten &amp;mdash; the &lt;code&gt;RELATIVE KEY&lt;/code&gt; or &lt;code&gt;RECORD KEY&lt;/code&gt; definition for the file, respectively, will specify the record to be updated.</source>
          <target state="translated">파일에 &lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; 이있는 경우 다시 쓸 레코드 는 파일 의 가장 최근에 실행 된 &lt;code&gt;READ&lt;/code&gt; 에 의해 검색된 레코드가 됩니다. 파일에 &lt;code&gt;ACCESS MODE RANDOM&lt;/code&gt; 또는 &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt; 이있는 경우 레코드를 다시 쓰기 전에 &lt;code&gt;READ&lt;/code&gt; 가 필요 하지 않습니다 . 파일에 대한 &lt;code&gt;RELATIVE KEY&lt;/code&gt; 또는 &lt;code&gt;RECORD KEY&lt;/code&gt; 정의는 각각 업데이트 할 레코드를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b92cdda09e23c6babe9323f2fab796558b95e032" translate="yes" xml:space="preserve">
          <source>If the file has &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) or &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;):</source>
          <target state="translated">파일이있는 경우 &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;조직 RELATIVE&lt;/a&gt; 또는) &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;조직 색인을&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="9bb8fcfe2e45e1f8ae2ed6c423aee276e8feaa74" translate="yes" xml:space="preserve">
          <source>If the file has &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;):</source>
          <target state="translated">파일에 &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; 이있는 경우 ( &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt; 참조 ) :</target>
        </trans-unit>
        <trans-unit id="8308b61ce7bcbfc94d926cc1722564983504a579" translate="yes" xml:space="preserve">
          <source>If the file has&lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; the record to be rewritten will be the one retrieved by the most-recently executed&lt;code&gt;READ&lt;/code&gt;of the file. If the file has&lt;code&gt;ACCESS MODE RANDOM&lt;/code&gt;or&lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt; no&lt;code&gt;READ&lt;/code&gt;is required before a record may be rewritten &amp;mdash; the&lt;code&gt;RELATIVE KEY&lt;/code&gt;or&lt;code&gt;RECORD KEY&lt;/code&gt;definition for the file, respectively, will specify the record to be updated.</source>
          <target state="translated">파일에 &lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; 이 있으면 다시 기록 할 레코드는 가장 최근에 실행 된 파일의 &lt;code&gt;READ&lt;/code&gt; 에 의해 검색된 레코드 입니다. 파일에 &lt;code&gt;ACCESS MODE RANDOM&lt;/code&gt; 또는 &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt; 이있는 경우 레코드를 다시 쓰기 전에 &lt;code&gt;READ&lt;/code&gt; 가 필요 하지 않습니다 . 파일에 대한 &lt;code&gt;RELATIVE KEY&lt;/code&gt; 또는 &lt;code&gt;RECORD KEY&lt;/code&gt; 정의는 각각 업데이트 할 레코드를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="979f0a1fc8e50fd115ef1c5a2607d25c8a146e66" translate="yes" xml:space="preserve">
          <source>If the file has&lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) or&lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;):</source>
          <target state="translated">파일이있는 경우 &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;조직 RELATIVE&lt;/a&gt; 또는) &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;조직 색인을&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="a1d7d6e295ed262b048e40c65c57cc69c1a22916" translate="yes" xml:space="preserve">
          <source>If the file has&lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;):</source>
          <target state="translated">파일에 &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; 이있는 경우 ( &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt; 참조 ) :</target>
        </trans-unit>
        <trans-unit id="ebc6dd0f2cfa35fc8904be11678446623b9ff834" translate="yes" xml:space="preserve">
          <source>If the file&amp;rsquo;s &lt;code&gt;SELECT&lt;/code&gt; contains a &lt;code&gt;LOCK MODE IS AUTOMATIC&lt;/code&gt; clause, every time a record is read from the file, that record is automatically locked. Other programs may access</source>
          <target state="translated">파일이 &lt;code&gt;SELECT&lt;/code&gt; 에 &lt;code&gt;LOCK MODE IS AUTOMATIC&lt;/code&gt; 절이 포함 된 레코드를 읽을 때마다 해당 레코드가 자동으로 잠 깁니다. 다른 프로그램이 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5581252930e28cda52f7dd409750375325db5ed0" translate="yes" xml:space="preserve">
          <source>If the file&amp;rsquo;s &lt;code&gt;SELECT&lt;/code&gt; contains a &lt;code&gt;LOCK MODE IS MANUAL&lt;/code&gt; clause, locks are placed on records</source>
          <target state="translated">파일이 &lt;code&gt;SELECT&lt;/code&gt; 에 &lt;code&gt;LOCK MODE IS MANUAL&lt;/code&gt; 절이 포함 된 레코드에 잠금이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e57bb4b94ad8d138b6e068547fa0dd3393b0fc4d" translate="yes" xml:space="preserve">
          <source>If the file&amp;rsquo;s&lt;code&gt;SELECT&lt;/code&gt;contains a&lt;code&gt;LOCK MODE IS AUTOMATIC&lt;/code&gt;</source>
          <target state="translated">파일의 &lt;code&gt;SELECT&lt;/code&gt; 에 &lt;code&gt;LOCK MODE IS AUTOMATIC&lt;/code&gt; 이 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="b0edb822a1ecdc41221997c63041ba9a3c222689" translate="yes" xml:space="preserve">
          <source>If the file&amp;rsquo;s&lt;code&gt;SELECT&lt;/code&gt;contains a&lt;code&gt;LOCK MODE IS MANUAL&lt;/code&gt;</source>
          <target state="translated">파일의 &lt;code&gt;SELECT&lt;/code&gt; 에 &lt;code&gt;LOCK MODE IS MANUAL&lt;/code&gt; 이 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="10abb20b2ca302db903ccde6ac80ddbd1e14af4b" translate="yes" xml:space="preserve">
          <source>If the format in &lt;var&gt;argument-1&lt;/var&gt; indicates that the returned value is to be expressed in UTC, the time portion of the returned value reflects the adjustment of the value in &lt;var&gt;argument-2&lt;/var&gt; by the offset in &lt;var&gt;argument-3&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;argument-1&lt;/var&gt; 의 형식이 리턴 값은 UTC로 표현된다는 것을 나타낸다 리턴 값의 시간 부분의 값의 조정을 반영 &lt;var&gt;argument-2&lt;/var&gt; (가)에서 오프셋에 의해 &lt;var&gt;argument-3&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="5fd625e9cd0e795e1abbea2d50fee9d16f247fea" translate="yes" xml:space="preserve">
          <source>If the format in &lt;var&gt;argument-1&lt;/var&gt; indicates that the returned value is to be expressed in UTC, the time portion of the returned value reflects the adjustment of the value in &lt;var&gt;argument-3&lt;/var&gt; by the offset in &lt;var&gt;argument-4&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;argument-1&lt;/var&gt; 의 형식이 리턴 값은 UTC로 표현된다는 것을 나타낸다 리턴 값의 시간 부분의 값의 조정을 반영 &lt;var&gt;argument-3&lt;/var&gt; (가)에서 오프셋에 의해 &lt;var&gt;argument-4&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="166178cacdbe5fd462fb190489612b357d06f5ce" translate="yes" xml:space="preserve">
          <source>If the format in &lt;var&gt;argument-1&lt;/var&gt; indicates that the time is to be returned as an offset from UTC, the value in &lt;var&gt;argument-2&lt;/var&gt; is reflected directly in the time portion of the returned value and the offset in &lt;var&gt;argument-3&lt;/var&gt; is reflected directly in the offset portion of the returned value.</source>
          <target state="translated">&lt;var&gt;argument-1&lt;/var&gt; 의 형식 이 시간이 UTC로부터의 오프셋으로 반환됨을 나타내면 &lt;var&gt;argument-2&lt;/var&gt; 리턴 값의 시간 부분에 직접 반영하고이 오프셋되는 &lt;var&gt;argument-3&lt;/var&gt; 직접 반영 반환 된 값의 오프셋 부분.</target>
        </trans-unit>
        <trans-unit id="26e28a33e8881735eccfadfa004e07caea00d59d" translate="yes" xml:space="preserve">
          <source>If the format in &lt;var&gt;argument-1&lt;/var&gt; indicates that the time is to be returned as an offset from UTC, the value in &lt;var&gt;argument-3&lt;/var&gt; is reflected directly in the time portion of the returned value and the offset in &lt;var&gt;argument-4&lt;/var&gt; is reflected directly in the offset portion of the returned value.</source>
          <target state="translated">&lt;var&gt;argument-1&lt;/var&gt; 의 형식 이 시간이 UTC로부터의 오프셋으로 반환됨을 나타내면 &lt;var&gt;argument-3&lt;/var&gt; 리턴 값의 시간 부분에 직접 반영하고이 오프셋되는 &lt;var&gt;argument-4&lt;/var&gt; 직접 반영 반환 된 값의 오프셋 부분.</target>
        </trans-unit>
        <trans-unit id="baea16fa39768fdef0af9d58e56f8513fcbd8390" translate="yes" xml:space="preserve">
          <source>If the function issues a &lt;code&gt;STOP&lt;/code&gt; statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) with the &lt;code&gt;RUN&lt;/code&gt; option, program execution ceases and control returns to the operating system or whatever execution shell invoked the main program.</source>
          <target state="translated">함수가 &lt;code&gt;STOP&lt;/code&gt; 문을 발행하면 ( &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt; 가 &lt;code&gt;RUN&lt;/code&gt; 옵션 과 함께 )을 프로그램 실행이 중지되고 제어가 운영 체제 또는 기본 프로그램을 호출 한 실행 쉘로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="9ac3ef7c53e5a1a9ebd82e6132c731fb366bb269" translate="yes" xml:space="preserve">
          <source>If the function issues a&lt;code&gt;STOP&lt;/code&gt;statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) with the&lt;code&gt;RUN&lt;/code&gt;option, program execution ceases and control returns to the operating system or whatever execution shell invoked the main program.</source>
          <target state="translated">함수 가 &lt;code&gt;RUN&lt;/code&gt; 옵션 과 함께 &lt;code&gt;STOP&lt;/code&gt; 문 ( &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt; 참조 )을 발행하면 프로그램 실행이 중지되고 운영 체제 또는 기본 프로그램을 호출 한 실행 쉘로 제어가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="35a6f4e231eb8c92eedcef095e1eb5b985195124" translate="yes" xml:space="preserve">
          <source>If the function wishes to return control back to the calling program, it will do so using either the &lt;code&gt;GOBACK&lt;/code&gt; statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) or the &lt;code&gt;EXIT FUNCTION&lt;/code&gt; statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;). At this time:</source>
          <target state="translated">함수가 호출 프로그램으로 제어 등을 반환하고자 할 경우에는 하나 사용하여 그렇게 할 것입니다 &lt;code&gt;GOBACK&lt;/code&gt; 문 (참조 &lt;a href=&quot;#GOBACK&quot;&gt;하고 GoBack을&lt;/a&gt; ) 또는 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 문 ( &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt; 참조 )을 사용합니다. 현재 :</target>
        </trans-unit>
        <trans-unit id="768fc6ac0826962232769e54ee3d27933dbe814a" translate="yes" xml:space="preserve">
          <source>If the function wishes to return control back to the calling program, it will do so using either the&lt;code&gt;GOBACK&lt;/code&gt;statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) or the&lt;code&gt;EXIT FUNCTION&lt;/code&gt;statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;). At this time:</source>
          <target state="translated">함수가 호출 프로그램으로 제어 등을 반환하고자 할 경우에는 하나 사용하여 그렇게 할 것입니다 &lt;code&gt;GOBACK&lt;/code&gt; 문 (참조 &lt;a href=&quot;#GOBACK&quot;&gt;하고 GoBack을&lt;/a&gt; ) 또는 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 문을합니다 ( &lt;a href=&quot;#EXIT&quot;&gt;EXIT를&lt;/a&gt; ). 현재 :</target>
        </trans-unit>
        <trans-unit id="30455ee292f12916879ea7b27b16596593857296" translate="yes" xml:space="preserve">
          <source>If the item is alphanumeric edited, then the size is set to the number of &quot;A&quot; or &quot;X&quot; positions specified in its PICTURE clause.</source>
          <target state="translated">항목을 영숫자 편집하면 크기는 PICTURE 절에 지정된 &quot;A&quot;또는 &quot;X&quot;위치 수로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7a208a6cc6a893ebed7ca1af029a4cbd81f73ef4" translate="yes" xml:space="preserve">
          <source>If the item is alphanumeric edited, then the size is set to the number of &amp;lsquo;</source>
          <target state="translated">항목이 영숫자 편집 된 경우 크기는 '</target>
        </trans-unit>
        <trans-unit id="5a3ac59ecad83c4e62bbb64e4efcc1980153a8fd" translate="yes" xml:space="preserve">
          <source>If the item is numeric or numeric edited, then the size is the number of digits in the item, plus one if it is not an integer, plus one if it is signed.</source>
          <target state="translated">항목이 숫자 또는 편집 된 항목 인 경우 크기는 항목의 자릿수와 정수가 아닌 경우 1을 더한 값, 부호가있는 경우 1을 더한 값입니다.</target>
        </trans-unit>
        <trans-unit id="0bf6190961c1d912062042b050c89a336fba6e4f" translate="yes" xml:space="preserve">
          <source>If the key(s) and value(s) match, &amp;lt;</source>
          <target state="translated">키와 값이 일치하면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="364099d939dac1d20ae3d5cb7f9ea15deb38944b" translate="yes" xml:space="preserve">
          <source>If the key(s) and value(s) match, &lt;var&gt;imperative-statement-2&lt;/var&gt; (see &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt;) is executed, after which control falls through into the next statement following the &lt;code&gt;SEARCH ALL&lt;/code&gt;.</source>
          <target state="translated">키와 값이 일치하면 &lt;var&gt;imperative-statement-2&lt;/var&gt; ( &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt; 참조 )가 실행되고 제어는 &lt;code&gt;SEARCH ALL&lt;/code&gt; 다음의 다음 명령문으로 넘어갑니다 .</target>
        </trans-unit>
        <trans-unit id="8718b549db26737624f77d41114ec5bbc3bc5cfc" translate="yes" xml:space="preserve">
          <source>If the key(s) are GREATER THAN the value(s), then the table entry being searched for can only occur in the &quot;first&quot; to &quot;current&quot; range of the table, so a new &quot;last&quot; pointer value is set (it will be set to the &quot;current&quot; pointer).</source>
          <target state="translated">키가 값보다 크면 검색되는 테이블 항목이 테이블의 &quot;첫 번째&quot;에서 &quot;현재&quot;범위에서만 발생할 수 있으므로 새로운 &quot;마지막&quot;포인터 값이 설정됩니다 ( &quot;현재&quot;포인터로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="26a06caa2d8e4511f177ae678ee1706922a64e12" translate="yes" xml:space="preserve">
          <source>If the key(s) are GREATER THAN the value(s), then the table entry being searched for can only occur in the &amp;ldquo;first&amp;rdquo; to &amp;ldquo;current&amp;rdquo; range of the table, so a new &amp;ldquo;last&amp;rdquo; pointer value is set (it will be set to the &amp;ldquo;current&amp;rdquo; pointer).</source>
          <target state="translated">키가 값보다 크면 검색중인 테이블 항목이 테이블의 &quot;첫 번째&quot;에서 &quot;현재&quot;범위에서만 발생할 수 있으므로 새 &quot;마지막&quot;포인터 값이 설정됩니다 ( &quot;현재&quot;포인터로 설정됩니다).</target>
        </trans-unit>
        <trans-unit id="f855f7c7ead100cd07565ea01cc7a9230a155db1" translate="yes" xml:space="preserve">
          <source>If the key(s) are LESS THAN the value(s), then the table entry being searched for can only occur in the &quot;current&quot; to &quot;last&quot; range of the table, so a new &quot;first&quot; pointer value is set (it will be set to the &quot;current&quot; pointer).</source>
          <target state="translated">키가 값보다 적은 경우, 검색중인 테이블 항목은 테이블의 &quot;현재&quot;에서 &quot;마지막&quot;범위에서만 발생할 수 있으므로 새로운 &quot;첫 번째&quot;포인터 값이 설정됩니다 ( &quot;현재&quot;포인터로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="998f5bf567570409a15717d5bf167eb530056f3b" translate="yes" xml:space="preserve">
          <source>If the key(s) are LESS THAN the value(s), then the table entry being searched for can only occur in the &amp;ldquo;current&amp;rdquo; to &amp;ldquo;last&amp;rdquo; range of the table, so a new &amp;ldquo;first&amp;rdquo; pointer value is set (it will be set to the &amp;ldquo;current&amp;rdquo; pointer).</source>
          <target state="translated">키가 값보다 작 으면 검색중인 테이블 항목이 테이블의 &quot;현재&quot;에서 &quot;마지막&quot;범위에서만 발생할 수 있으므로 새로운 &quot;첫 번째&quot;포인터 값이 설정됩니다 ( &quot;현재&quot;포인터로 설정됩니다).</target>
        </trans-unit>
        <trans-unit id="67dac445610e60fc54c4fe228d7fb92749633d59" translate="yes" xml:space="preserve">
          <source>If the last exception status is not an &lt;code&gt;EC-I-O&lt;/code&gt; exception condition, the returned value is two national zeros.</source>
          <target state="translated">마지막 예외 상태가 &lt;code&gt;EC-I-O&lt;/code&gt; 예외 조건 이 아닌 경우 반환 된 값은 두 개의 국가 0입니다.</target>
        </trans-unit>
        <trans-unit id="75791070ef3413617c60c665e733867b07b700c6" translate="yes" xml:space="preserve">
          <source>If the length of &amp;lt;</source>
          <target state="translated">길이가 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="bde88dc03a2aeb1136469227b1d64906347783ff" translate="yes" xml:space="preserve">
          <source>If the length of &lt;var&gt;literal-7&lt;/var&gt; or &lt;var&gt;identifier-8&lt;/var&gt; (the &amp;ldquo;from&amp;rdquo; string)</source>
          <target state="translated">&lt;var&gt;literal-7&lt;/var&gt; 또는 &lt;var&gt;identifier-8&lt;/var&gt; 의 길이 ( &quot;from&quot;문자열)</target>
        </trans-unit>
        <trans-unit id="f678ec7b4d2b5c8286ebadce4169b6ec51506464" translate="yes" xml:space="preserve">
          <source>If the length of the &quot;from&quot; string</source>
          <target state="translated">&quot;from&quot;문자열의 길이가</target>
        </trans-unit>
        <trans-unit id="4967916491cd5aa62c1b2e2727ffb24cfed85aa7" translate="yes" xml:space="preserve">
          <source>If the length of the &amp;ldquo;from&amp;rdquo; string</source>
          <target state="translated">&quot;from&quot;문자열의 길이가</target>
        </trans-unit>
        <trans-unit id="163af06aed58d0ce62be6ce917a711c8bc398a55" translate="yes" xml:space="preserve">
          <source>If the new &quot;first&quot; and &quot;last&quot; pointers are different than the old &quot;first&quot; and &quot;last&quot; pointers, there&amp;rsquo;s more left to be searched, so return to step (A) and continue.</source>
          <target state="translated">새로운 &quot;첫번째&quot;및 &quot;마지막&quot;포인터가 이전의 &quot;첫번째&quot;및 &quot;마지막&quot;포인터와 다른 경우, 더 검색 할 것이 남아 있으므로 단계 (A)로 돌아가서 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="20cd460d91c2dd82c32020553b0991e55b5ca84b" translate="yes" xml:space="preserve">
          <source>If the new &quot;first&quot; and &quot;last&quot; pointers are the same as the old &quot;first&quot; and &quot;last&quot; pointers, the table has been exhausted and the entry being searched for cannot be found; &amp;lt;</source>
          <target state="translated">새로운 &quot;첫번째&quot;및 &quot;마지막&quot;포인터가 이전의 &quot;첫번째&quot;및 &quot;마지막&quot;포인터와 동일하면 테이블이 소진되어 검색중인 항목을 찾을 수 없습니다. &amp;lt;</target>
        </trans-unit>
        <trans-unit id="3aa34417c0be454f4995442d8a7806453694a874" translate="yes" xml:space="preserve">
          <source>If the new &amp;ldquo;first&amp;rdquo; and &amp;ldquo;last&amp;rdquo; pointers are different than the old &amp;ldquo;first&amp;rdquo; and &amp;ldquo;last&amp;rdquo; pointers, there&amp;rsquo;s more left to be searched, so return to step</source>
          <target state="translated">새 &quot;첫 번째&quot;및 &quot;마지막&quot;포인터가 이전 &quot;첫 번째&quot;및 &quot;마지막&quot;포인터와 다른 경우 검색 할 항목이 더 많으므로 단계로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="e9ca8c9950d6818daad84f3ad32fa98a7278a457" translate="yes" xml:space="preserve">
          <source>If the new &amp;ldquo;first&amp;rdquo; and &amp;ldquo;last&amp;rdquo; pointers are the same as the old &amp;ldquo;first&amp;rdquo; and &amp;ldquo;last&amp;rdquo; pointers, the table has been exhausted and the entry being searched for cannot be found; &lt;var&gt;imperative-statement-1&lt;/var&gt; is executed, after which control falls through into the next statement following the &lt;code&gt;SEARCH ALL&lt;/code&gt;. If there is no &lt;code&gt;AT END&lt;/code&gt; clause coded, control simply falls into the next statement following the &lt;code&gt;SEARCH ALL&lt;/code&gt;.</source>
          <target state="translated">새 &quot;첫 번째&quot;및 &quot;마지막&quot;포인터가 이전 &quot;첫 번째&quot;및 &quot;마지막&quot;포인터와 같으면 테이블이 모두 소모되어 검색중인 항목을 찾을 수 없습니다. &lt;var&gt;imperative-statement-1&lt;/var&gt; 이 실행 된 후 제어가 &lt;code&gt;SEARCH ALL&lt;/code&gt; 다음의 다음 명령문으로 넘어갑니다 . 코딩 된 &lt;code&gt;AT END&lt;/code&gt; 절이 없는 경우 제어는 &lt;code&gt;SEARCH ALL&lt;/code&gt; 다음의 다음 문으로 넘어갑니다. .</target>
        </trans-unit>
        <trans-unit id="37e0698c4d0426b5a1539d9872daa55a48e4b3fd" translate="yes" xml:space="preserve">
          <source>If the optional  &lt;code&gt;ALL&lt;/code&gt; clause is used, it may only be used with an alphanumeric literal value; the value will be repeated as needed to completely fill the data item. Here are some examples with and without &lt;code&gt;ALL&lt;/code&gt; (the symbol</source>
          <target state="translated">선택적 &lt;code&gt;ALL&lt;/code&gt; 절을 사용하는 경우 영숫자 리터럴 값과 함께 만 사용할 수 있습니다. 데이터 항목을 완전히 채우는 데 필요한만큼 값이 반복됩니다. 다음은 &lt;code&gt;ALL&lt;/code&gt; (기호</target>
        </trans-unit>
        <trans-unit id="eb9269c6626b9c22244a99ff3bcdeb28d197891f" translate="yes" xml:space="preserve">
          <source>If the optional  &lt;code&gt;WITH FILLER&lt;/code&gt; clause is included on the &lt;code&gt;INITIALIZE&lt;/code&gt; statement, then every FILLER elementary item subordinate to each &lt;var&gt;identifier-1&lt;/var&gt; will be included as well, provided that elementary item neither contains a &lt;code&gt;REDEFINES&lt;/code&gt; clause in its definition nor belongs to a group item</source>
          <target state="translated">선택적 &lt;code&gt;WITH FILLER&lt;/code&gt; 절이 &lt;code&gt;INITIALIZE&lt;/code&gt; 문 에 포함 된 경우 기본 항목이 &lt;code&gt;REDEFINES&lt;/code&gt; 를 포함하지 않는 경우 각 &lt;var&gt;identifier-1&lt;/var&gt; 종속 된 모든 FILLER 기본 항목도 포함됩니다. 이 정의에 절을 하지 않거나 그룹 항목에 됩니다.</target>
        </trans-unit>
        <trans-unit id="305f0831253ff348ae38af25eb67e6760bc88db7" translate="yes" xml:space="preserve">
          <source>If the optional &lt;code&gt;ELSE&lt;/code&gt; clause is present and conditional-expression evaluates to false, then (and only then) &lt;var&gt;imperative-statement-2&lt;/var&gt; will be executed. Once &lt;var&gt;imperative-statement-2&lt;/var&gt; has been executed, control falls into the first statement following the &lt;code&gt;END-IF&lt;/code&gt; or to the first statement of the next sentence if there is no &lt;code&gt;END-IF&lt;/code&gt; clause.</source>
          <target state="translated">선택적 &lt;code&gt;ELSE&lt;/code&gt; 절이 있고 conditional-expression이 false로 평가되면 ( &lt;var&gt;imperative-statement-2&lt;/var&gt; ) imperative-statement-2 가 실행됩니다. 일단 &lt;var&gt;imperative-statement-2&lt;/var&gt; 실행 된 제어는 다음의 첫 번째 문에 속하는 &lt;code&gt;END-IF&lt;/code&gt; 를 더이없는 경우 또는 다음 문장의 첫 문 &lt;code&gt;END-IF&lt;/code&gt; 절.</target>
        </trans-unit>
        <trans-unit id="99b9a44588304e8fd897153b6442bc44498ed178" translate="yes" xml:space="preserve">
          <source>If the optional&lt;code&gt;ALL&lt;/code&gt;</source>
          <target state="translated">선택 사항 인 경우 &lt;code&gt;ALL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7bdbfa412dd855282c99935345311e80faa35ff" translate="yes" xml:space="preserve">
          <source>If the optional&lt;code&gt;ELSE&lt;/code&gt;clause is present and conditional-expression evaluates to false, then (and only then) &amp;lt;</source>
          <target state="translated">선택적인 &lt;code&gt;ELSE&lt;/code&gt; 절이 존재하고 조건식이 거짓으로 평가되면 &amp;lt;그리고 만&amp;gt; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="214f8446472e76c131789cea52e9df99ff6d7324" translate="yes" xml:space="preserve">
          <source>If the optional&lt;code&gt;WITH FILLER&lt;/code&gt;</source>
          <target state="translated">선택 품목 인 &lt;code&gt;WITH FILLER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f4352556df8eac0b7e634194c0f18b8190333b57" translate="yes" xml:space="preserve">
          <source>If the program is compiled with the</source>
          <target state="translated">프로그램이</target>
        </trans-unit>
        <trans-unit id="0e0c98a1a847d99310eeb35f540d53fc5e523af7" translate="yes" xml:space="preserve">
          <source>If the program is compiled with the&lt;code&gt;-fsyntax-extension&lt;/code&gt;switch</source>
          <target state="translated">프로그램이 &lt;code&gt;-fsyntax-extension&lt;/code&gt; 스위치로 컴파일 된 경우</target>
        </trans-unit>
        <trans-unit id="28811669593d85ac3f545d78f92b27c993663314" translate="yes" xml:space="preserve">
          <source>If the replacement string is a multiple-item phrase or is to be deleted altogether, you must use the &lt;code&gt;==&lt;var&gt;pseudo-text-2&lt;/var&gt;==&lt;/code&gt; option. If &lt;code&gt;&lt;var&gt;pseudo-text-2&lt;/var&gt;&lt;/code&gt; is null (in other words, the replacement text is specified as &lt;code&gt;====&lt;/code&gt;), all encountered occurrences of the search string will be deleted.</source>
          <target state="translated">대체 문자열이 여러 항목 구문이거나 모두 삭제 될 경우 &lt;code&gt;==&lt;var&gt;pseudo-text-2&lt;/var&gt;==&lt;/code&gt; 옵션을 사용해야합니다 . 경우 &lt;code&gt;&lt;var&gt;pseudo-text-2&lt;/var&gt;&lt;/code&gt; 널 (null)이 (즉, 대체 텍스트로 지정된다 &lt;code&gt;====&lt;/code&gt; ), 검색 문자열의 모든 발생 사건이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="3f250bad0b5b4ae9aea9503229c333bf1801f01f" translate="yes" xml:space="preserve">
          <source>If the replacement string is a multiple-item phrase or is to be deleted altogether, you must use the&lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;==&lt;/code&gt;option. If&lt;code&gt;&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;&lt;/code&gt;is null (in other words, the replacement text is specified as&lt;code&gt;====&lt;/code&gt;, all encountered occurrences of the search string will be deleted.</source>
          <target state="translated">대체 문자열이 여러 항목 문구이거나 모두 삭제되는 경우 &lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;==&lt;/code&gt; 옵션을 사용해야합니다 . 경우 &lt;code&gt;&amp;lt;&lt;i&gt;pseudo-text-2&lt;/i&gt;&amp;gt;&lt;/code&gt; 즉, 대체 텍스트는 다음과 같이 지정됩니다 (null 인 &lt;code&gt;====&lt;/code&gt; , 검색 문자열의 모든 발생 사건이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f5f6ed5272b3e9c841cbdbf96eb7afe75d6967c2" translate="yes" xml:space="preserve">
          <source>If the routine is successful, a value of 0 will be returned to the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). If the routine failed because of a problem with an argument (such as a negative or 0 length), a value of 128 will result. Finally, if the 1&lt;sup&gt;st&lt;/sup&gt; argument value is anything but zero, the routine will fail with a 129 value.</source>
          <target state="translated">루틴이 성공하면 0의 값이 반환됩니다 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; ). 인수 문제 (예 : 음수 또는 0 길이)로 인해 루틴이 실패한 경우 값은 128이됩니다. 마지막으로 &lt;sup&gt;첫 번째&lt;/sup&gt; 인수 값이 0이 아닌 경우 루틴은 129 값으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="b864101b1cf94817be38b70b043aacccfa75cd6e" translate="yes" xml:space="preserve">
          <source>If the routine is successful, a value of 0 will be returned to the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). If the routine failed because of a problem with an argument (such as a negative or 0 length), a value of 128 will result. Finally, if the 1st argument value is anything but zero, the routine will fail with a 129 value.</source>
          <target state="translated">루틴이 성공하면 0의 값이 반환됩니다 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; ). 인수 (예 : 음수 또는 0 길이)의 문제점으로 인해 루틴이 실패한 경우 값 128이 발생합니다. 마지막으로, 첫 번째 인수 값이 0이 아닌 경우 루틴은 129 값으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5a1b44b26b84f05f8af22b9e038aef3fc238f233" translate="yes" xml:space="preserve">
          <source>If the search index now has a value greater than the number of entries in the table, the search is considered to have failed and the &amp;lt;</source>
          <target state="translated">검색 색인의 값이 테이블의 항목 수보다 큰 경우 검색이 실패한 것으로 간주되고 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="da9683de4eb44741b248beaf10f0ef79a0a17667" translate="yes" xml:space="preserve">
          <source>If the search index now has a value greater than the number of entries in the table, the search is considered to have failed and the &lt;var&gt;imperative-statement-1&lt;/var&gt; on the optional  &lt;code&gt;AT END&lt;/code&gt; clause, if any, will be executed. After that, control will fall into the first executable statement following the &lt;code&gt;SEARCH&lt;/code&gt;.</source>
          <target state="translated">이제 검색 인덱스에 테이블의 항목 수보다 큰 값이있는 경우 검색이 실패한 것으로 간주되고 선택적 &lt;code&gt;AT END&lt;/code&gt; 절 (있는 경우) 의 &lt;var&gt;imperative-statement-1&lt;/var&gt; 이 실행됩니다. 그 후, 제어는 &lt;code&gt;SEARCH&lt;/code&gt; 다음의 첫 번째 실행 가능 명령문으로 떨어집니다. .</target>
        </trans-unit>
        <trans-unit id="94565d23be2bb0fc7d85c959aef69eff52cd9069" translate="yes" xml:space="preserve">
          <source>If the search index now has a value less than or equal to the number of entries in the table, search processing returns back to step (A).</source>
          <target state="translated">검색 색인이 이제 테이블의 항목 수보다 작거나 같은 값을 갖는 경우 검색 처리는 단계 (A)로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="05d2db096b087a315ef5bec8efc903576ddb9453" translate="yes" xml:space="preserve">
          <source>If the search index now has a value less than or equal to the number of entries in the table, search processing returns back to step A.</source>
          <target state="translated">검색 색인의 값이 테이블의 항목 수보다 작거나 같은 경우 검색 처리는 단계 A로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="63b646dd35f2ad5b466ac70be0367ce3e11e5b92" translate="yes" xml:space="preserve">
          <source>If the specified argument does not exist, or an invalid argument number is specified, a value of 0 is returned.</source>
          <target state="translated">지정된 인수가 존재하지 않거나 유효하지 않은 인수 번호가 지정되면 값 0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="226dbbe68839151abdc383473011282ae0f610cd" translate="yes" xml:space="preserve">
          <source>If the specified condition-name has a value of FALSE when a &lt;code&gt;GENERATE&lt;/code&gt; statement (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) causes a report group to be presented, the presentation of that group will be suppressed.</source>
          <target state="translated">&lt;code&gt;GENERATE&lt;/code&gt; 문일 때 지정된 condition-name의 값이 FALSE 인 경우 ( &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt; )으로 인해 보고서 그룹이 표시 될 해당 그룹의 표시가 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="a1c8f712007564d99604775da06766bbac9f03bb" translate="yes" xml:space="preserve">
          <source>If the specified condition-name has a value of FALSE when a&lt;code&gt;GENERATE&lt;/code&gt;statement (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) causes a report group to be presented, the presentation of that group will be suppressed.</source>
          <target state="translated">&lt;code&gt;GENERATE&lt;/code&gt; 문 ( &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt; 참조 )으로 인해 보고서 그룹이 표시 될 때 지정된 condition-name 값이 FALSE 인 경우 해당 그룹의 표시가 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="66774ceedbe10981e42302c55639170b0ed0f28a" translate="yes" xml:space="preserve">
          <source>If the structure contains the following grid of characters:</source>
          <target state="translated">구조에 다음 문자 그리드가 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="2e19606b520468997579db75010657ce092d9a6b" translate="yes" xml:space="preserve">
          <source>If the subprogram being called is a GnuCOBOL program, and if that program had the &lt;code&gt;INITIAL&lt;/code&gt; (see &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;) attribute specified on its &lt;code&gt;PROGRAM-ID&lt;/code&gt; clause, all of the subprogram&amp;rsquo;s data division data will be restored to its initial state each time the subprogram is executed, regardless of which entry-point within the subprogram is being referenced.</source>
          <target state="translated">호출되는 서브 프로그램이 GnuCOBOL 프로그램이고 해당 &lt;code&gt;PROGRAM-ID&lt;/code&gt; 에 지정된 &lt;code&gt;INITIAL&lt;/code&gt; ( &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt; 참조 ) 속성이있는 경우 절 이있는 경우 서브 프로그램이 실행될 때마다 모든 서브 프로그램의 데이터 분할 데이터가 초기 상태로 복원됩니다. 참조되는 서브 프로그램 내 진입 점에 관계없이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5be0ca5096c1af0f623320b98f1b64f052b51144" translate="yes" xml:space="preserve">
          <source>If the subprogram being called is a GnuCOBOL program, and if that program had the&lt;code&gt;INITIAL&lt;/code&gt;(see &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;) attribute specified on its&lt;code&gt;PROGRAM-ID&lt;/code&gt;clause, all of the subprogram&amp;rsquo;s data division data will be restored to its initial state each time the subprogram is executed, regardless of which entry-point within the subprogram is being referenced.</source>
          <target state="translated">호출되는 서브 프로그램이 GnuCOBOL 프로그램이고 해당 &lt;code&gt;PROGRAM-ID&lt;/code&gt; 절 에 지정된 &lt;code&gt;INITIAL&lt;/code&gt; ( &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt; 참조 ) 속성 이 있으면 서브 프로그램이 호출 될 때마다 서브 프로그램의 모든 데이터 분할 데이터가 초기 상태로 복원됩니다. 서브 프로그램 내에서 시작점에 관계없이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9dd526e1cd7c1977c8a7c4056a1348911b1c31d3" translate="yes" xml:space="preserve">
          <source>If the subprogram issues a &lt;code&gt;STOP&lt;/code&gt; statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) with the &lt;code&gt;RUN&lt;/code&gt; option, program execution ceases and control returns to the operating system or whatever execution shell invoked the main program.</source>
          <target state="translated">서브 프로그램 이 &lt;code&gt;RUN&lt;/code&gt; 옵션 과 함께 &lt;code&gt;STOP&lt;/code&gt; 문 ( &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt; 참조 )을 발행하면 프로그램 실행이 중지되고 제어가 운영 체제 또는 주 프로그램을 호출 한 실행 쉘로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="1ad68b7c421e5be7cfd3f061b145123e5b308674" translate="yes" xml:space="preserve">
          <source>If the subprogram issues a&lt;code&gt;STOP&lt;/code&gt;statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) with the&lt;code&gt;RUN&lt;/code&gt;option, program execution ceases and control returns to the operating system or whatever execution shell invoked the main program.</source>
          <target state="translated">서브 프로그램 이 &lt;code&gt;RUN&lt;/code&gt; 옵션 과 함께 &lt;code&gt;STOP&lt;/code&gt; 문 ( &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt; 참조 )을 발행하면 프로그램 실행이 중단되고 운영 체제 또는 기본 프로그램을 호출 한 실행 쉘로 제어가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="4c7b6241365e4ec6dc288450226d6b64947002d1" translate="yes" xml:space="preserve">
          <source>If the subprogram returns a value, the data item in which the value is returned must also be defined in the subprogram&amp;rsquo;s linkage section, with a &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of &lt;code&gt;BINARY-LONG SIGNED&lt;/code&gt;, or its equivalent.</source>
          <target state="translated">서브 프로그램이 값을 반환하는 경우 값이 반환되는 데이터 항목 은 &lt;code&gt;BINARY-LONG SIGNED&lt;/code&gt; 의 &lt;code&gt;USAGE&lt;/code&gt; ( &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt; 참조 ) 와 함께 서브 프로그램의 연결 섹션에서도 정의되어야합니다. 또는 이와 동등한 .</target>
        </trans-unit>
        <trans-unit id="3fddc95876d626c2ec7bbbe309cf154f2991a624" translate="yes" xml:space="preserve">
          <source>If the subprogram returns a value, the data item in which the value is returned must also be defined in the subprogram&amp;rsquo;s linkage section, with a&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of&lt;code&gt;BINARY-LONG SIGNED&lt;/code&gt; or it&amp;rsquo;s equivalent.</source>
          <target state="translated">서브 프로그램이 값을 리턴하면 값이 리턴되는 데이터 항목도 서브 프로그램의 링크 섹션에 정의되어야하며 &lt;code&gt;USAGE&lt;/code&gt; ( &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt; 참조 )가 &lt;code&gt;BINARY-LONG SIGNED&lt;/code&gt; 또는 이와 동등한 값이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d18f5e6b28b4c653d9208ecaefc48bd300bc047a" translate="yes" xml:space="preserve">
          <source>If the subprogram wishes to return control back to the calling program, it will do so using either the &lt;code&gt;GOBACK&lt;/code&gt; statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) or the &lt;code&gt;EXIT PROGRAM&lt;/code&gt; statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;). At this time:</source>
          <target state="translated">서브 프로그램이 호출 프로그램으로 제어를 되돌리려는 경우 &lt;code&gt;GOBACK&lt;/code&gt; 문 ( &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt; 참조 ) 또는 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 문 ( &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt; 참조 )을 사용합니다. 현재 :</target>
        </trans-unit>
        <trans-unit id="3977b529e0e7ac10b11afc507f2c9eb5bfc68f03" translate="yes" xml:space="preserve">
          <source>If the subprogram wishes to return control back to the calling program, it will do so using either the&lt;code&gt;GOBACK&lt;/code&gt;statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) or the&lt;code&gt;EXIT PROGRAM&lt;/code&gt;statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;). At this time:</source>
          <target state="translated">서브 프로그램이 호출 프로그램으로 제어 등을 반환하고자 할 경우에는 하나 사용하여 그렇게 할 것입니다 &lt;code&gt;GOBACK&lt;/code&gt; 문 (참조 &lt;a href=&quot;#GOBACK&quot;&gt;하고 GoBack을&lt;/a&gt; ) 또는 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 문을합니다 ( &lt;a href=&quot;#EXIT&quot;&gt;EXIT를&lt;/a&gt; ). 현재 :</target>
        </trans-unit>
        <trans-unit id="b7d442294a11ad2647525adddd4f76ac113b07cb" translate="yes" xml:space="preserve">
          <source>If the subprograms procedure division header or &lt;code&gt;ENTRY&lt;/code&gt; statement included a  &lt;code&gt;RETURNING&lt;/code&gt;, the value of the data item found on that clause is moved to the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;); this behaviour can be altered utilizing the &lt;code&gt;CALL-CONVENTION&lt;/code&gt; (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) feature to leave &lt;code&gt;RETURN-CODE&lt;/code&gt; unchanged.</source>
          <target state="translated">서브 프로그램 절차 분할 헤더 또는 경우 &lt;code&gt;ENTRY&lt;/code&gt; 문이 포함 &lt;code&gt;RETURNING&lt;/code&gt; , 데이터 항목의 값을로 이동이 절에서 발견 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; ); 이 동작은 &lt;code&gt;RETURN-CODE&lt;/code&gt; 를 변경하지 않고 그대로 두기 위해 &lt;code&gt;CALL-CONVENTION&lt;/code&gt; ( &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 참조 ) 기능을 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb4435d664648be40b4a8cc4319cd6f4b4970f02" translate="yes" xml:space="preserve">
          <source>If the subprograms procedure division header or&lt;code&gt;ENTRY&lt;/code&gt;statement included a&lt;code&gt;RETURNING&lt;/code&gt; (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;); this behaviour can be altered utilizing the&lt;code&gt;CALL-CONVENTION&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) feature to leave&lt;code&gt;RETURN-CODE&lt;/code&gt;unchanged.</source>
          <target state="translated">서브 프로그램 프로 시저 분할 헤더 또는 &lt;code&gt;ENTRY&lt;/code&gt; 문에 &lt;code&gt;RETURNING&lt;/code&gt; 이 포함 된 경우 ( &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; 참조 ); 이 동작은 &lt;code&gt;CALL-CONVENTION&lt;/code&gt; ( &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 참조 ) 기능을 사용하여 변경하여 &lt;code&gt;RETURN-CODE&lt;/code&gt; 를 변경하지 않고 그대로 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c11c1280cd66204488ac2a1a06bc536f96275c7f" translate="yes" xml:space="preserve">
          <source>If the subroutine is successful, a value of 0 will be returned in the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). Failure to retrieve the needed statistics on the file will cause a   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register value of 35 to be passed back. Supplying less than two arguments will generate a 128   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register value.</source>
          <target state="translated">서브 루틴이 성공하면 0의 값이 반환됩니다 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; ). 파일에서 필요한 통계를 검색하지 못하면 &lt;code&gt;RETURN-CODE&lt;/code&gt; 특수 레지스터 값 35가 다시 전달됩니다. 두 개 미만의 인수를 제공하면 128 &lt;code&gt;RETURN-CODE&lt;/code&gt; 특수 레지스터 값 이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="f09551bd08e29b51e6abf0aea5fe4a5e33e0c372" translate="yes" xml:space="preserve">
          <source>If the subroutine is successful, a value of 0 will be returned in the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). Failure will cause a   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register value of -1 to be passed back.</source>
          <target state="translated">서브 루틴이 성공하면 0의 값이 반환됩니다 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; ). 실패하면 &lt;code&gt;RETURN-CODE&lt;/code&gt; 특수 레지스터 값 -1이 다시 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4fca4d357c4da52ecdfe09ff7f3b59313032d58e" translate="yes" xml:space="preserve">
          <source>If the subroutine is successful, a value of 0 will be returned in the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). Failure to retrieve the needed statistics on the file will cause a&lt;code&gt;RETURN-CODE&lt;/code&gt;special register value of 35 to be passed back. Supplying less than two arguments will generate a 128&lt;code&gt;RETURN-CODE&lt;/code&gt;special register value.</source>
          <target state="translated">서브 루틴이 성공하면 0의 값이 반환됩니다 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; ). 파일에서 필요한 통계를 검색하지 못하면 &lt;code&gt;RETURN-CODE&lt;/code&gt; 특수 레지스터 값 35가 다시 전달됩니다. 두 개 미만의 인수를 제공하면 128 &lt;code&gt;RETURN-CODE&lt;/code&gt; 특수 레지스터 값 이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2e2d3e910dfeb525715cdc365898fd54399a43c4" translate="yes" xml:space="preserve">
          <source>If the subroutine is successful, a value of 0 will be returned in the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;). Failure will cause a&lt;code&gt;RETURN-CODE&lt;/code&gt;special register value of -1 to be passed back.</source>
          <target state="translated">서브 루틴이 성공하면 0의 값이 반환됩니다 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; ). 실패하면 &lt;code&gt;RETURN-CODE&lt;/code&gt; 특수 레지스터 값 -1이 다시 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f698aa2435d6084a56df16270589b76ed6111e07" translate="yes" xml:space="preserve">
          <source>If the value being stored into the field is the same length as the receiving field, the presence or absence of the &lt;code&gt;JUSTIFIED RIGHT&lt;/code&gt; clause on that field&amp;rsquo;s description is irrelevant.</source>
          <target state="translated">필드에 저장되는 값이 수신 필드와 길이가 같으면 해당 필드 설명에 &lt;code&gt;JUSTIFIED RIGHT&lt;/code&gt; 절이 있는지 여부 는 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d1bb984fa6207ca92b69374fdf44a4d8170a10b1" translate="yes" xml:space="preserve">
          <source>If the value being stored into the field is the same length as the receiving field, the presence or absence of the&lt;code&gt;JUSTIFIED RIGHT&lt;/code&gt;clause on that field&amp;rsquo;s description is irrelevant.</source>
          <target state="translated">필드에 저장되는 값이 수신 필드와 동일한 길이 인 경우 해당 필드 설명에 &lt;code&gt;JUSTIFIED RIGHT&lt;/code&gt; 절의 존재 여부 는 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5b69bef404018740f53a3d7738badc9ff4e4531" translate="yes" xml:space="preserve">
          <source>If the value of &amp;lt;</source>
          <target state="translated">&amp;lt;의 값이</target>
        </trans-unit>
        <trans-unit id="bb8439f9510a756d8324157cc108db5bd22ad20d" translate="yes" xml:space="preserve">
          <source>If the value of &lt;var&gt;identifier-1&lt;/var&gt; has the value 1, control will be transferred to the 1&lt;sup&gt;st&lt;/sup&gt; specified procedure name. If the value is 2, control will transfer to the 2nd procedure name, and so on.</source>
          <target state="translated">값 경우 &lt;var&gt;identifier-1&lt;/var&gt; 1의 값을 가지며, 제어는 (1)로 전송한다 &lt;sup&gt;명세서가&lt;/sup&gt; 프로 시저 이름을 지정. 값이 2이면 제어가 두 번째 프로 시저 이름으로 이전됩니다.</target>
        </trans-unit>
        <trans-unit id="b45314dff2682587d20ce286905a20dcf658ec33" translate="yes" xml:space="preserve">
          <source>If the value of &lt;var&gt;identifier-1&lt;/var&gt; is less than 1 or exceeds the total number of procedure names specified on the statement, control will simply fall through into the next statement following the &lt;code&gt;GO TO&lt;/code&gt;.</source>
          <target state="translated">&lt;var&gt;identifier-1&lt;/var&gt; 의 값이 1 보다 작거나 명령문에 지정된 총 프로 시저 이름 수를 초과하는 경우 제어는 단순히 &lt;code&gt;GO TO&lt;/code&gt; 다음의 다음 명령문으로 넘어갑니다 .</target>
        </trans-unit>
        <trans-unit id="a8941ef78769624061ef92939b2c773736817ccd" translate="yes" xml:space="preserve">
          <source>If the value of the numeric value moved into the field is positive (0 or greater), a &quot;+&quot; character will be inserted. If the value is negative (less than 0), a &quot;-&quot; character is inserted.</source>
          <target state="translated">필드로 이동 한 숫자 값이 양수 (0 이상)이면 &quot;+&quot;문자가 삽입됩니다. 값이 음수 (0 미만)이면 &quot;-&quot;문자가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="acd1e3bc19ece522be6fdfb971b0319b26484139" translate="yes" xml:space="preserve">
          <source>If the value of the numeric value moved into the field is positive (0 or greater), a &amp;lsquo;</source>
          <target state="translated">필드로 이동 된 숫자 값의 값이 양수 (0 이상)이면 '</target>
        </trans-unit>
        <trans-unit id="fa45922afd3a1788e3ef11576266d429b5817fba" translate="yes" xml:space="preserve">
          <source>If the value of the numeric value moved into the field is positive (0 or greater), a space will be inserted. If the value is negative (less than 0), a &quot;-&quot; character is inserted.</source>
          <target state="translated">필드로 이동 한 숫자 값이 양수 (0 이상)이면 공백이 삽입됩니다. 값이 음수 (0 미만)이면 &quot;-&quot;문자가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="fef0c37a2cadff9632c6704e1cf9b5158cf0c3f9" translate="yes" xml:space="preserve">
          <source>If the value of the numeric value moved into the field is positive (0 or greater), a space will be inserted. If the value is negative (less than 0), a &amp;lsquo;</source>
          <target state="translated">필드로 이동 된 숫자 값의 값이 양수 (0 이상)이면 공백이 삽입됩니다. 값이 음수 (0 미만)이면 '</target>
        </trans-unit>
        <trans-unit id="48dd00b4185648ad98a04dd28fc9dd3c41fb5dc5" translate="yes" xml:space="preserve">
          <source>If the value specified for the &amp;lt;</source>
          <target state="translated">&amp;lt;에 지정된 값이</target>
        </trans-unit>
        <trans-unit id="be2c15d4233159c72f68bc3cfec16dff9b82c54c" translate="yes" xml:space="preserve">
          <source>If the value specified for the &lt;var&gt;length&lt;/var&gt; argument is LESS THAN the actual length of &lt;var&gt;buffer&lt;/var&gt; argument, the current directory path will be left-justified and space filled within the first &lt;var&gt;length&lt;/var&gt; bytes of &lt;var&gt;buffer&lt;/var&gt; &amp;mdash; any bytes in &lt;var&gt;buffer&lt;/var&gt; after that point will be unchanged.</source>
          <target state="translated">지정된 값 경우 &lt;var&gt;length&lt;/var&gt; 인수의 실제 길이 미만이다 &lt;var&gt;buffer&lt;/var&gt; 인수는 현재의 디렉토리 경로가 왼쪽 정렬되며 제 내에 채워진 공간 &lt;var&gt;length&lt;/var&gt; 바이트 &lt;var&gt;buffer&lt;/var&gt; - 어떤 바이트 &lt;var&gt;buffer&lt;/var&gt; 그 시점이 변경되지 후.</target>
        </trans-unit>
        <trans-unit id="0831d72b5b85932627f6976dfb6259ade2e7b74e" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;-fintrinsics=WHEN-COMPILED&lt;/code&gt;switch or&lt;code&gt;-fintrinsics=ALL&lt;/code&gt;switch is specified to the compiler or the&lt;code&gt;REPOSITORY&lt;/code&gt;(see &lt;a href=&quot;#REPOSITORY&quot;&gt;REPOSITORY&lt;/a&gt;) paragraph specifies either&lt;code&gt;FUNCTION WHEN-COMPILED INTRINSIC&lt;/code&gt;or&lt;code&gt;FUNCTION ALL INTRINSIC&lt;/code&gt; then references to&lt;code&gt;WHEN-COMPILED&lt;/code&gt;(without a leading&lt;code&gt;FUNCTION&lt;/code&gt;keyword will always reference this intrinsic function and there will be no way to access the&lt;code&gt;WHEN-COMPILED&lt;/code&gt;special register.</source>
          <target state="translated">경우] &lt;code&gt;-fintrinsics=WHEN-COMPILED&lt;/code&gt; 또는 스위치 &lt;code&gt;-fintrinsics=ALL&lt;/code&gt; 스위치 컴파일러 또는로한다 &lt;code&gt;REPOSITORY&lt;/code&gt; (참조 &lt;a href=&quot;#REPOSITORY&quot;&gt;저장소&lt;/a&gt; ) 단락 지정하거나 &lt;code&gt;FUNCTION WHEN-COMPILED INTRINSIC&lt;/code&gt; 또는 &lt;code&gt;FUNCTION ALL INTRINSIC&lt;/code&gt; 으로 다음의 참조 &lt;code&gt;WHEN-COMPILED&lt;/code&gt; (a 선도없이 &lt;code&gt;FUNCTION&lt;/code&gt; 키워드는 항상이 내장 함수를 참조하며 &lt;code&gt;WHEN-COMPILED&lt;/code&gt; 특수 레지스터 에 액세스 할 방법이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3b420486302df3f6e207a4313dfd931a759d89b7" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;-ftrace&lt;/code&gt;switch</source>
          <target state="translated">경우] &lt;code&gt;-ftrace&lt;/code&gt; 의 스위치</target>
        </trans-unit>
        <trans-unit id="3349b7269aaccc8bb1cc998766e4a46beb55bde2" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;ACCESS MODE&lt;/code&gt;of &amp;lt;</source>
          <target state="translated">경우] &lt;code&gt;ACCESS MODE&lt;/code&gt; 의 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="2e5d9e90a43cf87c9978ea30182b2bcd04cc6c52" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;ADDRESS OF&lt;/code&gt;clause is absent after the&lt;code&gt;TO&lt;/code&gt; the contents of &amp;lt;</source>
          <target state="translated">&lt;code&gt;TO&lt;/code&gt; 다음에 &lt;code&gt;ADDRESS OF&lt;/code&gt; 절이없는 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="26199d3754ff366a5846d65d208ee2e6de9686ad" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;ALL&lt;/code&gt;keyword was specified on the&lt;code&gt;VALUE&lt;/code&gt;clause, all members of the field list with&lt;code&gt;VALUE&lt;/code&gt;clauses will qualify.</source>
          <target state="translated">는 IF &lt;code&gt;ALL&lt;/code&gt; 의 키워드가에 지정된 &lt;code&gt;VALUE&lt;/code&gt; 의 절과 필드 목록의 모든 구성원 &lt;code&gt;VALUE&lt;/code&gt; 의 조항은 자격이됩니다.</target>
        </trans-unit>
        <trans-unit id="df5d251bac8a9bff6db280d0993ff1dbfac8f41c" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;CONSTANT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CONSTANT&lt;/code&gt; 경우</target>
        </trans-unit>
        <trans-unit id="0c81429e41c0cb12a035faac7aa149969b981744" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;CRT STATUS&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CRT STATUS&lt;/code&gt; 경우</target>
        </trans-unit>
        <trans-unit id="bdf79d6d2d1dddc9f4d79dc6b3151fcff14428de" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;FD&lt;/code&gt;of the file contains the&lt;code&gt;RECORD CONTAINS&lt;/code&gt;or&lt;code&gt;RECORD IS VARYING&lt;/code&gt;clause, and that clause allows the record size to vary, the size</source>
          <target state="translated">파일 의 &lt;code&gt;FD&lt;/code&gt; 에 &lt;code&gt;RECORD CONTAINS&lt;/code&gt; 또는 &lt;code&gt;RECORD IS VARYING&lt;/code&gt; 절이 포함되어 있고 해당 절에서 레코드 크기를 변경할 수있는 경우</target>
        </trans-unit>
        <trans-unit id="7cd7e97ca9d4f2995a04bb967f17ad631843750e" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;FD&lt;/code&gt;of the file contains the&lt;code&gt;RECORD CONTAINS&lt;/code&gt;or&lt;code&gt;RECORD IS VARYING&lt;/code&gt;clause, and that clause allows the record size to vary, the size of &amp;lt;</source>
          <target state="translated">파일 의 &lt;code&gt;FD&lt;/code&gt; 에 &lt;code&gt;RECORD CONTAINS&lt;/code&gt; 또는 &lt;code&gt;RECORD IS VARYING&lt;/code&gt; 절이 포함되어 있고 해당 절에서 레코드 크기를 변경할 수있는 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="8342745452a46e82129819210173c072a362af42" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;LINAGE&lt;/code&gt;(see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;) clause is</source>
          <target state="translated">만약 &lt;code&gt;LINAGE&lt;/code&gt; (참조 &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;파일 / 정렬-설명&lt;/a&gt; ) 절은</target>
        </trans-unit>
        <trans-unit id="67faed20b65d381e0f35f57376ea02fccee28463" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;LOCK ON&lt;/code&gt;</source>
          <target state="translated">경우] &lt;code&gt;LOCK ON&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a4cf245f7ab4d128cf1a215befd46fe8ca30464" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;LOCK ON&lt;/code&gt;clause</source>
          <target state="translated">경우] &lt;code&gt;LOCK ON&lt;/code&gt; 의 절</target>
        </trans-unit>
        <trans-unit id="5348e096005262a0ab82c3168003e7e7371e7dae" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;PERFORM&lt;/code&gt;specifies or implies&lt;code&gt;WITH TEST BEFORE&lt;/code&gt; &amp;lt;</source>
          <target state="translated">&lt;code&gt;PERFORM&lt;/code&gt; 이 &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; &amp;lt;을 지정하거나 암시 하는 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="dd5a2104ff28017a6be9e284824ff9c6d67e6603" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;PROGRAM-ID&lt;/code&gt;(see &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;) clause of the subprogram included the&lt;code&gt;INITIAL&lt;/code&gt;</source>
          <target state="translated">서브 프로그램 의 &lt;code&gt;PROGRAM-ID&lt;/code&gt; ( &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt; 참조 ) 절에 &lt;code&gt;INITIAL&lt;/code&gt; 이 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="68679aad3ae2e21817a3db3c1cd8a4c87162b63f" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;RD&lt;/code&gt;(see &lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;) in which the report group containing a&lt;code&gt;NEXT GROUP&lt;/code&gt;clause does not contain a&lt;code&gt;PAGE LIMITS&lt;/code&gt;clause, only the&lt;code&gt;PLUS integer-1&lt;/code&gt;option may be specified.</source>
          <target state="translated">경우 &lt;code&gt;RD&lt;/code&gt; 는 (참조 &lt;a href=&quot;#REPORT-SECTION&quot;&gt;보고서 제&lt;/a&gt; 이 포함 된 보고서 그룹있는) &lt;code&gt;NEXT GROUP&lt;/code&gt; 의 조항이 포함되지 않은 &lt;code&gt;PAGE LIMITS&lt;/code&gt; 조항 만 &lt;code&gt;PLUS integer-1&lt;/code&gt; 옵션을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6326e274617c726298b0f2a259364a71ec08cb9a" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;REMAINDER&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;REMAINDER&lt;/code&gt; 인 경우</target>
        </trans-unit>
        <trans-unit id="d46ae7e0403a69183623c2c0c30c04ac183c02a4" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;RESET&lt;/code&gt;option is coded,&lt;code&gt;FINAL&lt;/code&gt;or &amp;lt;</source>
          <target state="translated">경우 &lt;code&gt;RESET&lt;/code&gt; 옵션을 코딩, &lt;code&gt;FINAL&lt;/code&gt; 또는 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="38a1fbfcc2ff5f0f55dba89a7b49d153d656d7e5" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SELECT&lt;/code&gt;(see &lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt;) statement or file&lt;code&gt;OPEN&lt;/code&gt;(see &lt;a href=&quot;#OPEN&quot;&gt;OPEN&lt;/a&gt;) specifies&lt;code&gt;SHARING WITH NO OTHER&lt;/code&gt; record locking will be disabled.</source>
          <target state="translated">만약 &lt;code&gt;SELECT&lt;/code&gt; (참조 &lt;a href=&quot;#SELECT&quot;&gt;SELECT를&lt;/a&gt; ) 문 또는 파일 &lt;code&gt;OPEN&lt;/code&gt; (참조 &lt;a href=&quot;#OPEN&quot;&gt;OPEN가&lt;/a&gt; ) 지정 &lt;code&gt;SHARING WITH NO OTHER&lt;/code&gt; 사용할 수있을 것입니다 레코드 잠금을.</target>
        </trans-unit>
        <trans-unit id="4469b431cec5ac5fa31a45bf59859b62ee522aee" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SELECT&lt;/code&gt;of a file is coded with a&lt;code&gt;FILE STATUS&lt;/code&gt;clause,&lt;code&gt;OPEN&lt;/code&gt;failures &amp;mdash; including those induced by sharing failures &amp;mdash; will be detectable by the program and a graceful recovery (or at least a graceful termination) will be possible. If no such clause was coded, however, a runtime message will be issued and the program will be terminated.</source>
          <target state="translated">파일 의 &lt;code&gt;SELECT&lt;/code&gt; 가 &lt;code&gt;FILE STATUS&lt;/code&gt; 절로 코딩 된 경우, 공유 실패로 인한 오류를 포함하여 &lt;code&gt;OPEN&lt;/code&gt; 실패는 프로그램에 의해 감지 될 수 있으며 정상적인 복구 (또는 적어도 정상 종료)가 가능합니다. 그러나 그러한 절이 코딩되지 않으면 런타임 메시지가 발행되고 프로그램이 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="d43773d0d9856113d341b49d71c616d3ba81cd29" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SEPARATE CHARACTER&lt;/code&gt;clause</source>
          <target state="translated">경우] &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt; 절</target>
        </trans-unit>
        <trans-unit id="cc7da6fe4678bd908df6708f4cd87c152a905cc1" translate="yes" xml:space="preserve">
          <source>If the&lt;code&gt;SYNCRONIZED&lt;/code&gt;clause is coded on anything but a numeric data item with a&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) that specifies storage of data in a binary form, the&lt;code&gt;SYNCRONIZED&lt;/code&gt;clause will be ignored.</source>
          <target state="translated">경우 &lt;code&gt;SYNCRONIZED&lt;/code&gt; 절은 아무것도하지만 숫자 데이터 항목에 코딩 &lt;code&gt;USAGE&lt;/code&gt; (참조 &lt;a href=&quot;#USAGE&quot;&gt;사용법을&lt;/a&gt; 바이너리 형태로 데이터의 지정 저장)에 &lt;code&gt;SYNCRONIZED&lt;/code&gt; 절은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d78ec8f2b4dfe7f01a17864e7420734286b9c412" translate="yes" xml:space="preserve">
          <source>If there are fewer tokens than there are arguments, the excess arguments will be initialized as if the &lt;code&gt;INITIALIZE &lt;var&gt;identifier-1&lt;/var&gt;&lt;/code&gt; (see &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;) statement were executed.</source>
          <target state="translated">인수보다 토큰이 적 으면 초과 인수는 &lt;code&gt;INITIALIZE &lt;var&gt;identifier-1&lt;/var&gt;&lt;/code&gt; ( &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt; 참조 ) 문이 실행 된 것처럼 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="3d2f7b6539018dd97bf4f7ebf6332805f3b4ccf8" translate="yes" xml:space="preserve">
          <source>If there are fewer tokens than there are arguments, the excess arguments will be initialized as if the&lt;code&gt;INITIALIZE &amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt;&lt;/code&gt;(see &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;) statement were executed.</source>
          <target state="translated">인수보다 토큰이 적 으면 초과 인수는 &lt;code&gt;INITIALIZE &amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt;&lt;/code&gt; ( &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt; 참조 ) 명령문이 실행 된 것처럼 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="061529f2e81b4789d20b56f0ff94bb58b24306f6" translate="yes" xml:space="preserve">
          <source>If there are more tokens than there are arguments, the excess tokens will be discarded.</source>
          <target state="translated">인수보다 많은 토큰이 있으면 초과 토큰은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f2d936a65b86a2841ae9003e465d423ea6c6934c" translate="yes" xml:space="preserve">
          <source>If there are multiple cash registers in a particular department of a specific store, the data needs to be further sorted so that the cash registers are ordered in sequence of their register number.</source>
          <target state="translated">특정 상점의 특정 부서에 여러 개의 금전 등록 기가있는 경우, 금전 등록 기가 등록 번호 순서대로 정렬되도록 데이터를 추가로 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="e59de2a27b6a35a90e0f8bc07988b0621533bd24" translate="yes" xml:space="preserve">
          <source>If there are multiple record descriptions present for a given &lt;code&gt;FD&lt;/code&gt; or &lt;code&gt;SD&lt;/code&gt;, the one with the longest length will define the size of the record buffer into which a &lt;code&gt;READ&lt;/code&gt; statement (see &lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;) or a &lt;code&gt;RETURN&lt;/code&gt; statement (see &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt;) will deliver data read from the file and from which a &lt;code&gt;WRITE&lt;/code&gt; statement (see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;) or &lt;code&gt;RELEASE&lt;/code&gt; statement (see &lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt;) statement will obtain the data to be written to the file.</source>
          <target state="translated">주어진 &lt;code&gt;FD&lt;/code&gt; 또는 &lt;code&gt;SD&lt;/code&gt; 에 대해 여러 레코드 설명이 있는 경우 가장 긴 길이의 설명은 &lt;code&gt;READ&lt;/code&gt; 문 ( &lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt; 참조 ) 또는 &lt;code&gt;RETURN&lt;/code&gt; 문 ( &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt; 참조 )이 읽은 데이터를 전달할 레코드 버퍼의 크기를 정의합니다. 파일 및 이로부터 &lt;code&gt;WRITE&lt;/code&gt; 문 (참조 &lt;a href=&quot;#WRITE&quot;&gt;WRITE를&lt;/a&gt; ) 또는 &lt;code&gt;RELEASE&lt;/code&gt; 의 문 (참조 &lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt; 데이터를 얻을 것이다 문) 파일에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="3972fbb29cfb0307f762dc829ca3e5c79c5963a7" translate="yes" xml:space="preserve">
          <source>If there are multiple record descriptions present for a given&lt;code&gt;FD&lt;/code&gt;or&lt;code&gt;SD&lt;/code&gt; the one with the longest length will define the size of the record buffer into which a&lt;code&gt;READ&lt;/code&gt;statement (see &lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;) or a&lt;code&gt;RETURN&lt;/code&gt;statement (see &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt;) will deliver data read from the file and from which a&lt;code&gt;WRITE&lt;/code&gt;statement (see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;) or&lt;code&gt;RELEASE&lt;/code&gt;statement (see &lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt;) statement will obtain the data to be written to the file.</source>
          <target state="translated">주어진 &lt;code&gt;FD&lt;/code&gt; 또는 &lt;code&gt;SD&lt;/code&gt; 에 대해 여러 레코드 설명이있는 경우 길이가 가장 긴 레코드 설명 은 &lt;code&gt;READ&lt;/code&gt; 문 ( &lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt; 참조 ) 또는 &lt;code&gt;RETURN&lt;/code&gt; 문 ( &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt; 참조 )이 읽은 데이터를 전달할 레코드 버퍼의 크기를 정의합니다 . 파일 및 이로부터 &lt;code&gt;WRITE&lt;/code&gt; 문 (참조 &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt; ) 또는 &lt;code&gt;RELEASE&lt;/code&gt; 의 문 (참조 &lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt; 데이터를 얻을 것이다 문) 파일에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="6af5fafade490255d4c9294e9ca6e0bf011fdff0" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;C-D&lt;/code&gt; data item, then are there &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;D&lt;/code&gt; data items? If not, the &lt;code&gt;COMPUTE&lt;/code&gt; statement is in error. If there are, however, then code will be generated to subtract the value of &lt;code&gt;D&lt;/code&gt; from &lt;code&gt;C&lt;/code&gt; and add 1 to the result.</source>
          <target state="translated">어떤이없는 경우 &lt;code&gt;C-D&lt;/code&gt; 데이터 항목, 다음, 거기에 &lt;code&gt;C&lt;/code&gt; 와 &lt;code&gt;D&lt;/code&gt; 데이터 항목? 그렇지 않으면 &lt;code&gt;COMPUTE&lt;/code&gt; 문에 오류가 있습니다. 그러나있는 경우 &lt;code&gt;C&lt;/code&gt; 에서 &lt;code&gt;D&lt;/code&gt; 값을 빼고 결과에 1을 더하는 코드가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="c8b3aecda840e3adb64a0514f90c687896399421" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;CONTROL&lt;/code&gt; clause, the report will contain no control breaks; this implies that there can be no &lt;code&gt;CONTROL HEADING&lt;/code&gt; or &lt;code&gt;CONTROL FOOTING&lt;/code&gt; report groups defined for this &lt;code&gt;RD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CONTROL&lt;/code&gt; 절이 없으면 보고서에 제어 구분이 포함되지 않습니다. 이는 이 &lt;code&gt;RD&lt;/code&gt; 에 대해 정의 된 &lt;code&gt;CONTROL HEADING&lt;/code&gt; 또는 &lt;code&gt;CONTROL FOOTING&lt;/code&gt; 보고서 그룹 이 없을 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="d762e7f62e886e48e2ba03dcf5bc48c95f682f84" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;INITIAL&lt;/code&gt; clause specified, the target range is the entire inspect subject.</source>
          <target state="translated">&lt;code&gt;INITIAL&lt;/code&gt; 절이 지정 되지 않은 경우 대상 범위는 전체 검사 대상입니다.</target>
        </trans-unit>
        <trans-unit id="16abcea8905ec59c88cbf72bfdd646aa20d52b18" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;RESET&lt;/code&gt; option coded, the sum counter will be reset back to zero after each time the control footing containing the &lt;code&gt;SUM&lt;/code&gt; clause is presented. This is the typical behaviour that would be expected.</source>
          <target state="translated">&lt;code&gt;RESET&lt;/code&gt; 옵션이 코딩 되지 않은 경우 &lt;code&gt;SUM&lt;/code&gt; 절을 포함하는 제어 기반 이 표시 될 때마다 합계 카운터가 0으로 다시 재설정됩니다 . 이것은 예상되는 일반적인 동작입니다.</target>
        </trans-unit>
        <trans-unit id="41ec3f30640928a7442c69732eddf2379b4afaed" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;UPON&lt;/code&gt; clause specified, the value of &lt;var&gt;identifier-7&lt;/var&gt; or &lt;var&gt;literal-2&lt;/var&gt; will be added into the sum counter whenever a &lt;code&gt;GENERATE&lt;/code&gt; (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) of any detail report group in the report is executed.</source>
          <target state="translated">&lt;code&gt;UPON&lt;/code&gt; 절이 지정 되지 않은 경우 보고서에있는 세부 보고서 그룹의 &lt;code&gt;GENERATE&lt;/code&gt; ( &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt; 참조 )가 실행될 때마다 &lt;var&gt;identifier-7&lt;/var&gt; 또는 &lt;var&gt;literal-2&lt;/var&gt; 의 값이 합계 카운터에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="d3312782c3bd864e73fc604ba5b82a1e503c0463" translate="yes" xml:space="preserve">
          <source>If there is no picture clause and the &lt;code&gt;ALL&lt;/code&gt; option is specified, the &lt;code&gt;ALL&lt;/code&gt; option will be ignored.</source>
          <target state="translated">그림 절이없고 &lt;code&gt;ALL&lt;/code&gt; 옵션이 지정되면 &lt;code&gt;ALL&lt;/code&gt; 옵션이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="75eb31de9a88419e99f8f2249dfa222651219fe7" translate="yes" xml:space="preserve">
          <source>If there is no picture clause and the&lt;code&gt;ALL&lt;/code&gt;option is specified, the&lt;code&gt;ALL&lt;/code&gt;option will be ignored.</source>
          <target state="translated">picture 절이없고 &lt;code&gt;ALL&lt;/code&gt; 옵션을 지정하면 &lt;code&gt;ALL&lt;/code&gt; 옵션이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0c755b4b694e7c4beb9b1c5901a6f3a6e90065fa" translate="yes" xml:space="preserve">
          <source>If there is no picture clause specified, the size of the screen data item will be the length of the &amp;lt;</source>
          <target state="translated">picture 절이 지정되지 않은 경우 화면 데이터 항목의 크기는 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="65e6d23a23213a7521f378d2234f516bcfe5dc63" translate="yes" xml:space="preserve">
          <source>If there is no picture clause specified, the size of the screen data item will be the length of the &lt;var&gt;literal-1&lt;/var&gt; value.</source>
          <target state="translated">그림 절이 지정되지 않은 경우 화면 데이터 항목의 크기는 &lt;var&gt;literal-1&lt;/var&gt; 값 의 길이가 됩니다.</target>
        </trans-unit>
        <trans-unit id="be6e32115bff0c291e8d3c6d6525390722099349" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;C-D&lt;/code&gt;data item, then are there&lt;code&gt;C&lt;/code&gt;and&lt;code&gt;D&lt;/code&gt;data items? If not, the&lt;code&gt;COMPUTE&lt;/code&gt;statement is in error. If there are, however, then code will be generated to subtract the value of&lt;code&gt;D&lt;/code&gt;from&lt;code&gt;C&lt;/code&gt;and add 1 to the result.</source>
          <target state="translated">어떤이없는 경우 &lt;code&gt;C-D&lt;/code&gt; 의 데이터 항목, 다음, 거기에 &lt;code&gt;C&lt;/code&gt; 와 &lt;code&gt;D&lt;/code&gt; 데이터 항목? 그렇지 않으면 &lt;code&gt;COMPUTE&lt;/code&gt; 문에 오류가 있습니다. 그러나 존재하는 경우 &lt;code&gt;C&lt;/code&gt; 에서 &lt;code&gt;D&lt;/code&gt; 의 값을 빼고 결과에 1을 더하는 코드가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="6dbb73155f0ea4fd82ba811977b3d699fc88a4ae" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;CONTROL&lt;/code&gt;clause, the report will contain no control breaks; this implies that there can be no&lt;code&gt;CONTROL HEADING&lt;/code&gt;or&lt;code&gt;CONTROL FOOTING&lt;/code&gt;report groups defined for this&lt;code&gt;RD&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CONTROL&lt;/code&gt; 절이 없으면 보고서에 제어 구분이 없습니다. 이는 이 &lt;code&gt;RD&lt;/code&gt; 에 대해 정의 된 &lt;code&gt;CONTROL HEADING&lt;/code&gt; 또는 &lt;code&gt;CONTROL FOOTING&lt;/code&gt; 보고서 그룹 이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a351d89c95027f7701058bc9f942df00ed507cdc" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;INITIAL&lt;/code&gt;clause specified, the target range is the entire inspect subject.</source>
          <target state="translated">&lt;code&gt;INITIAL&lt;/code&gt; 절이 지정 되지 않은 경우 대상 범위는 전체 검사 주제입니다.</target>
        </trans-unit>
        <trans-unit id="f81540f4079ee51c4206d96a7efc736809a22ed7" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;RESET&lt;/code&gt;option coded, the sum counter will be reset back to zero after each time the control footing containing the&lt;code&gt;SUM&lt;/code&gt;clause is presented. This is the typical behaviour that would be expected.</source>
          <target state="translated">코딩 된 &lt;code&gt;RESET&lt;/code&gt; 옵션 이 없으면 &lt;code&gt;SUM&lt;/code&gt; 절을 포함하는 제어 푸팅이 나타날 때마다 합계 카운터가 0으로 다시 재설정됩니다 . 이것이 예상되는 일반적인 동작입니다.</target>
        </trans-unit>
        <trans-unit id="d5e252dc91e0d99f464bda7bc7cffd6140f7edd1" translate="yes" xml:space="preserve">
          <source>If there is no&lt;code&gt;UPON&lt;/code&gt;clause specified, the value of &amp;lt;</source>
          <target state="translated">&lt;code&gt;UPON&lt;/code&gt; 절이 지정 되지 않은 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="85ed95cffb116ddc0e04b0ff9f3f85cb3f686c72" translate="yes" xml:space="preserve">
          <source>If there is only a single detail group in the report&amp;rsquo;s definition, the &lt;code&gt;UPON&lt;/code&gt; clause is meaningless.</source>
          <target state="translated">보고서 정의에 세부 그룹이 하나만있는 경우 &lt;code&gt;UPON&lt;/code&gt; 절은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3241679c69995dc4a256fad0940c95e8635b9f3e" translate="yes" xml:space="preserve">
          <source>If there is only a single detail group in the report&amp;rsquo;s definition, the&lt;code&gt;UPON&lt;/code&gt;clause is meaningless.</source>
          <target state="translated">보고서 정의에 단일 세부 사항 그룹 만있는 경우 &lt;code&gt;UPON&lt;/code&gt; 절은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8336291c2ee7aa90b14f47a5ffa73da4f4ccca8c" translate="yes" xml:space="preserve">
          <source>If this format of the &lt;code&gt;GO TO&lt;/code&gt; statement appears in a consecutive sequence of imperative statements (see &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt;) within a sentence, it must be the</source>
          <target state="translated">의 형식 경우 &lt;code&gt;GO TO&lt;/code&gt; 의 문이 필수적 문 (볼의 연속 순서로 나타납니다 &lt;a href=&quot;#Imperative-Statement&quot;&gt;명령형 문&lt;/a&gt; 문장 내에서), 그것은을해야합니다</target>
        </trans-unit>
        <trans-unit id="c11b35162c1c669848bde8fb8b4adb40363c054b" translate="yes" xml:space="preserve">
          <source>If this format of the&lt;code&gt;GO TO&lt;/code&gt;statement appears in a consecutive sequence of imperative statements (see &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt;) within a sentence, it must be the</source>
          <target state="translated">의 형식 경우 &lt;code&gt;GO TO&lt;/code&gt; 의 문이 필수적 문 (볼의 연속 순서로 나타납니다 &lt;a href=&quot;#Imperative-Statement&quot;&gt;명령형 문&lt;/a&gt; 문장 내에서), 그것은을해야합니다</target>
        </trans-unit>
        <trans-unit id="87568d2d981805ff51bcc79d09c4d6bfd7b2a8ef" translate="yes" xml:space="preserve">
          <source>If this is NOT set to a value, all&lt;code&gt;-ftrace&lt;/code&gt;switch and&lt;code&gt;-ftraceall&lt;/code&gt;switch output will be written to STDERR, where it may be piped via a &quot;2&amp;gt; filename&quot; on the command that executes the program.</source>
          <target state="translated">이 값을 설정하지 않으면 모든 &lt;code&gt;-ftrace&lt;/code&gt; 스위치 및 &lt;code&gt;-ftraceall&lt;/code&gt; 스위치 출력이 STDERR에 기록되며 프로그램을 실행하는 명령에서 &quot;2&amp;gt; filename&quot;을 통해 파이프 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a83736211ab7a8ebcd841864f94ccc4520a7dfa7" translate="yes" xml:space="preserve">
          <source>If this is needed then the use of &lt;code&gt;CONCATENATE&lt;/code&gt; to built more than one element together prior to the display,</source>
          <target state="translated">이것이 필요한 경우 &lt;code&gt;CONCATENATE&lt;/code&gt; 를 사용 하여 디스플레이 이전에 둘 이상의 요소를 함께 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="a889b90fb05948e48163ce89cde9903008828bde" translate="yes" xml:space="preserve">
          <source>If this is not defined under *nix it will default to</source>
          <target state="translated">* nix에서 정의되지 않은 경우 기본값은</target>
        </trans-unit>
        <trans-unit id="e41eac2db71cda7170c71b8ec2c30d7834407d0c" translate="yes" xml:space="preserve">
          <source>If this is not defined under *nix it will default to /usr/local/share/gnucobol/config.</source>
          <target state="translated">이것이 * nix에 정의되어 있지 않으면 / usr / local / share / gnucobol / config로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f658454bbe0cb00adbd321dd682ed210523825d2" translate="yes" xml:space="preserve">
          <source>If this references the &lt;code&gt;LOCALE&lt;/code&gt; :</source>
          <target state="translated">&lt;code&gt;LOCALE&lt;/code&gt; 를 참조하는 경우 :</target>
        </trans-unit>
        <trans-unit id="13a780ab73e0d98067b8082c96e09315273c7654" translate="yes" xml:space="preserve">
          <source>If used with &lt;code&gt;PIC X&lt;/code&gt;, allocates one byte of storage per &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;PIC X&lt;/code&gt; 와 함께 사용하는 경우 '당 1 바이트의 스토리지 할당</target>
        </trans-unit>
        <trans-unit id="023cf0ecfd0afc5f6ae392348d069495edac90d8" translate="yes" xml:space="preserve">
          <source>If used with&lt;code&gt;PIC X&lt;/code&gt; allocates one byte of storage per&lt;code&gt;X&lt;/code&gt; range of values is 0 to max storable in that many bytes. If used with&lt;code&gt;PIC 9&lt;/code&gt; range of values depends on number of&lt;code&gt;9&lt;/code&gt; in PICTURE</source>
          <target state="translated">&lt;code&gt;PIC X&lt;/code&gt; 와 함께 사용하는 경우 &lt;code&gt;X&lt;/code&gt; 범위 당 1 바이트의 스토리지를 할당 하면 값의 범위는 0에서 최대 바이트까지 저장 가능합니다. &lt;code&gt;PIC 9&lt;/code&gt; 와 함께 사용하는 경우 PICTURE 의 값 범위는 &lt;code&gt;9&lt;/code&gt; 의 수에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5b48ea3221a5bd190b3da00947706eadb4325c47" translate="yes" xml:space="preserve">
          <source>If used, &amp;lt;</source>
          <target state="translated">사용하는 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="b86b211a643f0894516daa2e4887ef0058458a13" translate="yes" xml:space="preserve">
          <source>If used, &lt;var&gt;expression-1&lt;/var&gt; must be an arithmetic expression with a non-zero positive integer value.</source>
          <target state="translated">사용되는 경우 &lt;var&gt;expression-1&lt;/var&gt; 은 0이 아닌 양의 정수 값이있는 산술 표현식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b8e42b7d06183584a3c82a1e30a497fb1500ac29" translate="yes" xml:space="preserve">
          <source>If used, &lt;var&gt;identifier-1&lt;/var&gt; should be an 01-level item defined in working-storage or local-storage with the &lt;code&gt;BASED&lt;/code&gt; (see &lt;a href=&quot;#BASED&quot;&gt;BASED&lt;/a&gt;) attribute. It may be an 01 item defined in the linkage section without the &lt;code&gt;BASED&lt;/code&gt; attribute, but using such a data item is not recommended.</source>
          <target state="translated">사용되는 경우 &lt;var&gt;identifier-1&lt;/var&gt; 은 &lt;code&gt;BASED&lt;/code&gt; ( &lt;a href=&quot;#BASED&quot;&gt;BASED&lt;/a&gt; 참조 ) 속성을 사용하여 작업 저장소 또는 로컬 저장소에 정의 된 01 수준 항목이어야 합니다. &lt;code&gt;BASED&lt;/code&gt; 속성 없이 연결 섹션에 정의 된 01 항목 일 수 있지만 이러한 데이터 항목을 사용하는 것은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bc0724035e374262548f9e5245c6c8b9be6bbaa" translate="yes" xml:space="preserve">
          <source>If used, &lt;var&gt;identifier-2&lt;/var&gt; should be a &lt;code&gt;POINTER&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) data item.</source>
          <target state="translated">사용되는 경우 &lt;var&gt;identifier-2&lt;/var&gt; 는 &lt;code&gt;POINTER&lt;/code&gt; ( &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt; 참조 ) 데이터 항목 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="71f1f5a847333c2f0a308baea3e7cd54b097d32f" translate="yes" xml:space="preserve">
          <source>If you already know a programming language other than COBOL, chances are that language is Java, C or C++. You will find COBOL much different from those; sometimes the differences are a good thing and sometimes they aren&amp;rsquo;t. The thing to remember about COBOL is this:</source>
          <target state="translated">COBOL 이외의 프로그래밍 언어를 이미 알고 있다면 해당 언어가 Java, C 또는 C ++ 일 가능성이 있습니다. COBOL은 그것과는 많이 다릅니다. 때로는 차이점이 좋은 것이고 때로는 그렇지 않습니다. COBOL에 대해 기억해야 할 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f92f6ebb3f39d6efd118da1f36149fda0df27506" translate="yes" xml:space="preserve">
          <source>If you are comfortable with the &quot;C&quot; programming language, you might find the following simple GnuCOBOL program useful in exploring the differences between subscripting and indexing:</source>
          <target state="translated">&quot;C&quot;프로그래밍 언어에 익숙하다면 다음과 같은 간단한 GnuCOBOL 프로그램이 아래 첨자와 색인 작성의 차이점을 살펴 보는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d72a55c3208d833e5593b857446fb0e285092f9f" translate="yes" xml:space="preserve">
          <source>If you are comfortable with the C programming language, you might find the following simple GnuCOBOL program useful in exploring the differences between subscripting and indexing:</source>
          <target state="translated">C 프로그래밍 언어에 익숙하다면 다음과 같은 간단한 GnuCOBOL 프로그램이 첨자 및 인덱싱 간의 차이점을 탐색하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66062304bf503c5649ee5c39992874bd53f8d855" translate="yes" xml:space="preserve">
          <source>If you are planning on using static-linked subroutine libraries, set this variable to the path of the directory containing your libraries.</source>
          <target state="translated">정적 링크 서브 루틴 라이브러리를 사용하려는 경우이 변수를 라이브러리가 포함 된 디렉토리의 경로로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="01f92f2645932d2e7b72a1c8110cdcfbd8882f1a" translate="yes" xml:space="preserve">
          <source>If you are sorting &amp;lt;</source>
          <target state="translated">정렬중인 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="004cad48c1c7e5cd3697d0259ff8f530252b1f42" translate="yes" xml:space="preserve">
          <source>If you are sorting &lt;var&gt;table-name-1&lt;/var&gt; for the purpose of preparing the table for use with a &lt;code&gt;SEARCH ALL&lt;/code&gt; statement (see &lt;a href=&quot;#SEARCH-ALL&quot;&gt;SEARCH ALL&lt;/a&gt;), care must be taken that the &lt;code&gt;KEY&lt;/code&gt; specifications on the &lt;code&gt;SORT&lt;/code&gt; agree with those in the table&amp;rsquo;s definition.</source>
          <target state="translated">&lt;code&gt;SEARCH ALL&lt;/code&gt; 문과 함께 사용할 테이블을 준비하기 위해 &lt;var&gt;table-name-1&lt;/var&gt; 을 정렬하는 경우 ( &lt;a href=&quot;#SEARCH-ALL&quot;&gt;SEARCH ALL&lt;/a&gt; 참조 ) &lt;code&gt;SORT&lt;/code&gt; 의 &lt;code&gt;KEY&lt;/code&gt; 사양 이 테이블 정의에있는 것과 일치 하는지주의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="02aa6a4a695c82943ebf8b43c9d16d82122de6f1" translate="yes" xml:space="preserve">
          <source>If you are using Fixed Format Mode, the alphanumeric literal can be run right up to and including column 72. The literal may then be continued on the next line anywhere after column 11 by coding another quote or apostrophe (whichever was used to begin the literal originally). The continuation line must also have a hyphen (-)</source>
          <target state="translated">고정 형식 모드를 사용하는 경우 영숫자 리터럴을 열 72까지 포함하여 바로 실행할 수 있습니다. 그런 다음 리터럴을 시작하는 데 사용 된 다른 따옴표 나 아포스트로피를 코딩하여 열 11 다음의 다음 행에서 리터럴을 계속할 수 있습니다. 원래). 연속 줄에도 하이픈 (-)이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c9f65d9b9ed555da4b63d4488fe138317d725d8d" translate="yes" xml:space="preserve">
          <source>If you attempt to store a negative number into a packed decimal field that has no &amp;lsquo;</source>
          <target state="translated">'가없는 팩형 십진수 필드에 음수를 저장하려는 경우</target>
        </trans-unit>
        <trans-unit id="67c575e7eebaede09fa7a3ba7a66b085e2b666ab" translate="yes" xml:space="preserve">
          <source>If you attempt to store a negative number into a packed decimal field that has no&lt;code&gt;S&lt;/code&gt;in its&lt;code&gt;PICTURE&lt;/code&gt; the absolute value of the negative number will actually be stored.</source>
          <target state="translated">더이없는 팩 십진 필드에 음의 번호를 저장하려고하면 &lt;code&gt;S&lt;/code&gt; 를 자사에서 &lt;code&gt;PICTURE&lt;/code&gt; 부정적인 숫자의 절대 값을 실제로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="33f09798c9350fe782168c79a484ebfce1dfd921" translate="yes" xml:space="preserve">
          <source>If you have used other versions of COBOL before (particularly mainframe implementations), you&amp;rsquo;ve possibly seen subroutine calls made passing a procedure name as an argument &amp;mdash; that is not possible in GnuCOBOL; instead, you need to know how to use this form of the&lt;code&gt;SET&lt;/code&gt;statement.</source>
          <target state="translated">이전에 다른 버전의 COBOL (특히 메인 프레임 구현)을 사용한 경우 프로 시저 이름을 인수로 전달하는 서브 루틴 호출이 GnuCOBOL에서는 불가능한 것으로 보았을 것입니다. 대신,이 양식의 &lt;code&gt;SET&lt;/code&gt; 문 을 사용하는 방법을 알아야합니다 .</target>
        </trans-unit>
        <trans-unit id="3e0e21f3fa3e35e385e61b770f9f269497ad078b" translate="yes" xml:space="preserve">
          <source>If you like to hold a book in your hands, I strongly recommend</source>
          <target state="translated">책을 손에 들고 싶다면 강력히 추천합니다</target>
        </trans-unit>
        <trans-unit id="8575747ffb34e15317f4825a1a6d194e243908c5" translate="yes" xml:space="preserve">
          <source>If you like to hold a book in your hands, I strongly recommend &quot;Murach&amp;rsquo;s Structured COBOL&quot;, by Mike Murach, Anne Prince and Raul Menendez (2000) - ISBN 9781890774059. Mike Murach and his various writing partners have been writing outstanding COBOL textbooks for decades, and this text is no exception. It&amp;rsquo;s an excellent book for those familiar with the concepts of programming in other languages, but unfamiliar with COBOL.</source>
          <target state="translated">Mike Murach, Anne Prince 및 Raul Menendez (2000)-ISBN 9781890774059의 &quot;Murach 's Structured COBOL&quot;을 강력히 추천합니다. Mike Murach와 그의 다양한 저술 파트너는 뛰어난 COBOL 교과서를 작성했습니다. 수십 년 동안이 본문도 예외는 아닙니다. 다른 언어로 된 프로그래밍 개념에 익숙하지만 COBOL에 익숙하지 않은 사람들에게 훌륭한 책입니다.</target>
        </trans-unit>
        <trans-unit id="a983cec50cc8adb2cb72101e62421b49b40c3f8f" translate="yes" xml:space="preserve">
          <source>If you need to allocate space for a data item whose format is two letters followed by five digits followed by three letters, you could use the &amp;lt;</source>
          <target state="translated">형식이 2 자, 5 자리, 3자인 데이터 항목에 공간을 할당해야하는 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="8d26eb887b2bfd89c144e5b52c0cdeb9c7a63cdb" translate="yes" xml:space="preserve">
          <source>If you need to allocate space for a data item whose format is two letters followed by five digits followed by three letters, you could use the &lt;var&gt;picture-string&lt;/var&gt;&lt;code&gt;AA99999AAA&lt;/code&gt;, &lt;code&gt;A(2)9(5)A(3)&lt;/code&gt;&lt;code&gt;XXXXXXXXXX&lt;/code&gt; or &lt;code&gt;X(10)&lt;/code&gt;. There is absolutely no functional difference whatsoever between the four &amp;mdash; none of them provide any functionality the others do not. The first two probably make for better</source>
          <target state="translated">형식이 두 글자, 다섯 자리, 세 글자 인 데이터 항목에 공간을 할당해야하는 경우 &lt;var&gt;picture-string&lt;/var&gt; &lt;code&gt;AA99999AAA&lt;/code&gt; , &lt;code&gt;A(2)9(5)A(3)&lt;/code&gt; &lt;code&gt;XXXXXXXXXX&lt;/code&gt; 또는 &lt;code&gt;X(10)&lt;/code&gt; . 네 가지 간에는 기능적 차이가 전혀 없습니다. 이들 중 어느 것도 다른 것들이 제공하지 않는 기능을 제공하지 않습니다. 처음 두 가지는 아마도 더 나아질 것입니다.</target>
        </trans-unit>
        <trans-unit id="85dc896ccc0af03eabd5023a9189c0f764205518" translate="yes" xml:space="preserve">
          <source>If you need to apply &lt;code&gt;REPLACING&lt;/code&gt; initialization to multiple &lt;var&gt;category-name-2&lt;/var&gt; values, you may repeat the syntax after the reserved word &lt;code&gt;REPLACING&lt;/code&gt;, as necessary.</source>
          <target state="translated">&lt;code&gt;REPLACING&lt;/code&gt; 초기화를 여러 &lt;var&gt;category-name-2&lt;/var&gt; 값 에 적용해야하는 경우 필요에 따라 예약어 &lt;code&gt;REPLACING&lt;/code&gt; 뒤에 구문을 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f07cc92bcdb1fb4966a29f8bc48cd7ec589d721" translate="yes" xml:space="preserve">
          <source>If you need to apply &lt;code&gt;VALUE&lt;/code&gt; initialization to multiple &lt;var&gt;category-name-1&lt;/var&gt; values, you will need to use multiple &lt;code&gt;INITIALIZE&lt;/code&gt; statements.</source>
          <target state="translated">&lt;code&gt;VALUE&lt;/code&gt; 초기화를 여러 &lt;var&gt;category-name-1&lt;/var&gt; 값 에 적용 해야하는 경우 여러 &lt;code&gt;INITIALIZE&lt;/code&gt; 문 을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3d7ab34ba2edb8344ca5cd05ed4f78d8ca295856" translate="yes" xml:space="preserve">
          <source>If you need to apply&lt;code&gt;REPLACING&lt;/code&gt;initialization to multiple &amp;lt;</source>
          <target state="translated">당신은 적용해야하는 경우 &lt;code&gt;REPLACING&lt;/code&gt; 배수로 초기화 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="0be77805ea73d60e3aa2532f09cd1417a0b5f725" translate="yes" xml:space="preserve">
          <source>If you need to apply&lt;code&gt;VALUE&lt;/code&gt;initialization to multiple &amp;lt;</source>
          <target state="translated">여러 &lt;code&gt;VALUE&lt;/code&gt; 초기화를 적용해야하는 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="faedf40171740f5c51b093163f9803ad34a888e7" translate="yes" xml:space="preserve">
          <source>If you need to qualify a reference to a table, do so by coding something like &lt;code&gt;&lt;var&gt;identifier-1&lt;/var&gt; OF &lt;var&gt;identifier-2&lt;/var&gt; ( &lt;var&gt;subscript(s)&lt;/var&gt; )&lt;/code&gt;.</source>
          <target state="translated">테이블에 대한 참조를 한정해야하는 경우 &lt;code&gt;&lt;var&gt;identifier-1&lt;/var&gt; OF &lt;var&gt;identifier-2&lt;/var&gt; ( &lt;var&gt;subscript(s)&lt;/var&gt; )&lt;/code&gt; 와 같은 것을 코딩하여 그렇게하십시오 .</target>
        </trans-unit>
        <trans-unit id="09b277bb04315e13de2ea2c1d6215f972f449420" translate="yes" xml:space="preserve">
          <source>If you need to qualify a reference to a table, do so by coding something like&lt;code&gt;&amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt; OF &amp;lt;&lt;i&gt;identifier-2&lt;/i&gt;&amp;gt; ( subscript(s) )&lt;/code&gt;</source>
          <target state="translated">테이블에 대한 참조를 규정해야하는 경우 &lt;code&gt;&amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt; OF &amp;lt;&lt;i&gt;identifier-2&lt;/i&gt;&amp;gt; ( subscript(s) )&lt;/code&gt; &lt;i&gt;identifier-1&lt;/i&gt; &amp;gt; OF &amp;lt; &lt;i&gt;identifier-2&lt;/i&gt; &amp;gt; (subscript (s)) 와 같은 코드를 작성하십시오.&lt;i&gt;&lt;/i&gt;&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="ea477a1b93e894e00c5029bde5c4700835a658bc" translate="yes" xml:space="preserve">
          <source>If you only need to use the computed occurrence number once, you might as well just use the computed occurrence number data item as a subscript. If, however, you will need to use a computed &quot;subscript&quot; many more times than once, the run-time overhead of converting that occurrence value to an index (via&lt;code&gt;SET Index&lt;/code&gt; will be worth the coding effort.</source>
          <target state="translated">계산 된 발생 수를 한 번만 사용해야하는 경우 계산 된 발생 수 데이터 항목을 아래 첨자로 사용할 수도 있습니다. 그러나 계산 된 &quot;첨자&quot;를 두 번 이상 여러 번 사용해야하는 경우 해당 발생 값을 인덱스로 변환하는 런타임 오버 헤드 ( &lt;code&gt;SET Index&lt;/code&gt; 를 통해) 는 코딩 노력의 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="08d6331d8b515c4ddcea5626d36be26117cd2759" translate="yes" xml:space="preserve">
          <source>If you only need to use the computed occurrence number once, you might as well just use the computed occurrence number data item as a subscript. If, however, you will need to use a computed &amp;ldquo;subscript&amp;rdquo; many more times than once, the run-time overhead of converting that occurrence value to an index (via &lt;code&gt;SET Index&lt;/code&gt;) will be worth the coding effort.</source>
          <target state="translated">계산 된 발생 수를 한 번만 사용해야하는 경우 계산 된 발생 수 데이터 항목을 첨자로 사용하는 것이 좋습니다. 그러나 계산 된&amp;ldquo;subscript&amp;rdquo;를 두 번 이상 사용해야하는 경우 해당 발생 값을 인덱스로 변환하는 런타임 오버 헤드 ( &lt;code&gt;SET Index&lt;/code&gt; 를 통해 )는 코딩 노력의 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b11929fcfd27ebcc5881e51e66067da91bf2b68" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;FINAL&lt;/code&gt;, it must be the first control break named in the &lt;code&gt;RD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FINAL&lt;/code&gt; 을 지정하는 경우 &lt;code&gt;RD&lt;/code&gt; 에 명명 된 첫 번째 제어 중단이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c7ef595b63c0ad5f2b42b214045d49f212ec5149" translate="yes" xml:space="preserve">
          <source>If you specify a specific filename in the sort/merge work file&amp;rsquo;s &lt;code&gt;SELECT&lt;/code&gt;, it will be ignored.</source>
          <target state="translated">정렬 / 병합 작업 파일의 &lt;code&gt;SELECT&lt;/code&gt; 에 특정 파일 이름을 지정하면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1b1aec7f2d01b9337cb99ecf14cbd063323c6bfc" translate="yes" xml:space="preserve">
          <source>If you specify a specific filename in the sort/merge work file&amp;rsquo;s&lt;code&gt;SELECT&lt;/code&gt; it will be ignored.</source>
          <target state="translated">정렬 / 병합 작업 파일의 &lt;code&gt;SELECT&lt;/code&gt; 에 특정 파일 이름을 지정하면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="db4b705d51633a3053f41836b85c013703781c0c" translate="yes" xml:space="preserve">
          <source>If you specify&lt;code&gt;FINAL&lt;/code&gt; it must be the first control break named in the&lt;code&gt;RD&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;FINAL&lt;/code&gt; 을 지정 하면 &lt;code&gt;RD&lt;/code&gt; 에 이름이 지정된 첫 번째 제어 구분이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ff6d082d36226e2e4f40a2e7e8119f64d1550bdf" translate="yes" xml:space="preserve">
          <source>If you want to squeeze every last bit of performance out of your GnuCOBOL programs, don&amp;rsquo;t forget to investigate the</source>
          <target state="translated">GnuCOBOL 프로그램의 모든 성능을 최대한 활용하려면 다음을 조사하는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bd75b97fc760ccc29226f53558113a860ab9c393" translate="yes" xml:space="preserve">
          <source>If you want to squeeze every last bit of performance out of your GnuCOBOL programs, don&amp;rsquo;t forget to investigate the&lt;code&gt;-O&lt;/code&gt;switch</source>
          <target state="translated">GnuCOBOL 프로그램에서 성능의 모든 마지막 비트를 짜내려면 &lt;code&gt;-O&lt;/code&gt; 스위치 를 조사하는 것을 잊지 마십시오</target>
        </trans-unit>
        <trans-unit id="1395a21f9c2355a2d51c47b543c90015c04147c1" translate="yes" xml:space="preserve">
          <source>If you wanted to store the value 128 million into that field, you would do so as if the &amp;lsquo;</source>
          <target state="translated">해당 필드에 128 백만 값을 저장하려면 '</target>
        </trans-unit>
        <trans-unit id="d6f238b944da72a8958154ef52736f8bf20193b7" translate="yes" xml:space="preserve">
          <source>If you wanted to store the value 128 million into that field, you would do so as if the&lt;code&gt;P&lt;/code&gt; were&lt;code&gt;9&lt;/code&gt;:</source>
          <target state="translated">해당 필드에 1 억 2 천 2 백만 값을 저장하려면 &lt;code&gt;P&lt;/code&gt; 가 &lt;code&gt;9&lt;/code&gt; 인 것처럼 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="3a1e11453cfdbd4a0f6b18b6c27cb66cedc0741d" translate="yes" xml:space="preserve">
          <source>If you will be porting existing code over to GnuCOBOL, you&amp;rsquo;ll find it an accommodating facility capable of conforming to whatever language and coding standards that code is likely to use. If you are creating new GnuCOBOL programs, however, I would strongly counsel you to use the &lt;code&gt;END-&lt;var&gt;verb&lt;/var&gt;&lt;/code&gt; structures in those programs.</source>
          <target state="translated">기존 코드를 GnuCOBOL로 포팅하는 경우 코드가 사용할 가능성이있는 모든 언어 및 코딩 표준을 준수 할 수있는 수용 기능을 찾을 수 있습니다. 그러나 새로운 GnuCOBOL 프로그램을 만드는 경우 에는 해당 프로그램에서 &lt;code&gt;END-&lt;var&gt;verb&lt;/var&gt;&lt;/code&gt; 구조 를 사용하도록 강력히 권고합니다 .</target>
        </trans-unit>
        <trans-unit id="f960091ad57764e902ba6a62fa5a1b8ba304ce95" translate="yes" xml:space="preserve">
          <source>If you will be porting existing code over to GnuCOBOL, you&amp;rsquo;ll find it an accommodating facility capable of conforming to whatever language and coding standards that code is likely to use. If you are creating new GnuCOBOL programs, however, I would strongly counsel you to use the&lt;code&gt;END-verb&lt;/code&gt;structures in those programs.</source>
          <target state="translated">기존 코드를 GnuCOBOL로 포팅 할 경우 코드가 사용하는 언어 및 코딩 표준을 준수 할 수있는 수용 시설을 찾을 수 있습니다. 그러나 새로운 GnuCOBOL 프로그램을 작성하는 경우 해당 프로그램에서 &lt;code&gt;END-verb&lt;/code&gt; 구조 를 사용하도록 강력히 권고합니다 .</target>
        </trans-unit>
        <trans-unit id="bc53cf603e35a32cb8513a9837d8949b255f4fa1" translate="yes" xml:space="preserve">
          <source>If your GnuCOBOL build uses the Berkeley Database (BDB) package, use this environment variable to specify the folder in which the lock management files to be associated with all non-SORT files opened by the program will be stored. &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) files will also have their data file allocated in the folder pointed to by this environment variable, if it exists.. Having this variable defined will activate record locking features on the &lt;code&gt;READ&lt;/code&gt; statement (see &lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;), &lt;code&gt;REWRITE&lt;/code&gt; statement (see &lt;a href=&quot;#REWRITE&quot;&gt;REWRITE&lt;/a&gt;) and &lt;code&gt;WRITE&lt;/code&gt; statement (see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;). Even with DB_HOME, locking will not work with &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;), &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt;) or ORGANIZATION RELATIVE files with GnuCOBOL builds created for Windows/MinGW. &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; locks will work with Windows/MinGW + BDB and all locks will work for all file organizations with UNIX GnuCOBOL builds.</source>
          <target state="translated">GnuCOBOL 빌드가 BDB (Berkeley Database) 패키지를 사용하는 경우이 환경 변수를 사용하여 프로그램에서 연 모든 비 SORT 파일과 연결할 잠금 관리 파일이 저장 될 폴더를 지정합니다. &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;조직 인덱스를&lt;/a&gt; 존재하는 경우) 파일이 또한 자신의 데이터 파일은 폴더에 할당 된 것은 .. 기록 잠금을에 기능을 활성화 정의이 변수 데,이 환경 변수가 가리키는 &lt;code&gt;READ&lt;/code&gt; (참조 문을 &lt;a href=&quot;#READ&quot;&gt;READ를&lt;/a&gt; ) &lt;code&gt;REWRITE&lt;/code&gt; 문 ( &lt;a href=&quot;#REWRITE&quot;&gt;REWRITE&lt;/a&gt; 참조 ) 및 &lt;code&gt;WRITE&lt;/code&gt; 문 ( &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt; 참조 ). DB_HOME을 사용하더라도 잠금은 &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;조직 순차적&lt;/a&gt; ), &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;조직 LINE SEQUENTIAL&lt;/a&gt; GnuCOBOL는 윈도우 /는 MinGW 위해 만든 빌드 또는 조직 RELATIVE 파일). &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; 잠금은 Windows / MinGW + BDB에서 작동하며 모든 잠금은 UNIX GnuCOBOL 빌드를 사용하는 모든 파일 조직에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="84f76abe3e8dfd99557f1d9c28b5a29519b7cdd8" translate="yes" xml:space="preserve">
          <source>If your GnuCOBOL build uses the Berkeley Database (BDB) package, use this environment variable to specify the folder in which the lock management files to be associated with all non-SORT files opened by the program will be stored.&lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) files will also have their data file allocated in the folder pointed to by this environment variable, if it exists.. Having this variable defined will activate record locking features on the&lt;code&gt;READ&lt;/code&gt;statement (see &lt;a href=&quot;#READ&quot;&gt;READ&lt;/a&gt;),&lt;code&gt;REWRITE&lt;/code&gt;statement (see &lt;a href=&quot;#REWRITE&quot;&gt;REWRITE&lt;/a&gt;) and&lt;code&gt;WRITE&lt;/code&gt;statement (see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;). Even with DB_HOME, locking will not work with&lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;),&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt;) or ORGANIZATION RELATIVE files with GnuCOBOL builds created for Windows/MinGW.&lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt;locks will work with Windows/MinGW + BDB and all locks will work for all file organizations with UNIX GnuCOBOL builds.</source>
          <target state="translated">GnuCOBOL 빌드가 BDB (Berkeley Database) 패키지를 사용하는 경우이 환경 변수를 사용하여 프로그램에서 연 모든 비 SORT 파일과 연관 될 잠금 관리 파일이 저장 될 폴더를 지정하십시오. &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;조직 인덱스를&lt;/a&gt; 존재하는 경우) 파일이 또한 자신의 데이터 파일은 폴더에 할당 된 것은 .. 기록 잠금을에 기능을 활성화 정의이 변수 데,이 환경 변수가 가리키는 &lt;code&gt;READ&lt;/code&gt; (참조 문을 &lt;a href=&quot;#READ&quot;&gt;READ를&lt;/a&gt; ) &lt;code&gt;REWRITE&lt;/code&gt; 문 ( &lt;a href=&quot;#REWRITE&quot;&gt;REWRITE&lt;/a&gt; 참조 ) 및 &lt;code&gt;WRITE&lt;/code&gt; 문 ( &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt; 참조 ). DB_HOME을 사용하더라도 &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; 에서는 잠금이 작동하지 않습니다.( &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;조직&lt;/a&gt; 시퀀스 참조 ), &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; ( &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;조직 라인&lt;/a&gt; 시퀀스 참조 ) 또는 Windows / MinGW 용으로 생성 된 GnuCOBOL 빌드가 포함 된 조직 관련 파일. &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; 잠금은 Windows / MinGW + BDB에서 작동하며 모든 잠금은 UNIX GnuCOBOL 빌드를 사용하는 모든 파일 조직에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5d5c76b0afd98975a32ec5cfb6a7e9651011522c" translate="yes" xml:space="preserve">
          <source>If your program is using Free Format Mode, there&amp;rsquo;s less need to continue long alphanumeric literals because statements may be as long as 255 characters.</source>
          <target state="translated">프로그램이 자유 형식 모드를 사용하는 경우 명령문의 길이가 255 자일 수 있으므로 긴 영숫자 리터럴을 계속할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="95fac7041303838d18e876497588b4e3cf6b6006" translate="yes" xml:space="preserve">
          <source>If, however, the GnuCOBOL compiler was built for a Unix, OSX or Linux environment, or was built for a Windows environment utilizing either the Cygwin or MinGW Unix emulators, use a colon character (&amp;lsquo;</source>
          <target state="translated">그러나 GnuCOBOL 컴파일러가 Unix, OSX 또는 Linux 환경 용으로 빌드되었거나 Cygwin 또는 MinGW Unix 에뮬레이터를 사용하는 Windows 환경 용으로 빌드 된 경우 콜론 문자 ( '</target>
        </trans-unit>
        <trans-unit id="9ec069692353086fbfea33bd5148cbb40a61d28b" translate="yes" xml:space="preserve">
          <source>If, however, the GnuCOBOL compiler was built for a Unix, OSX or Linux environment, or was built for a Windows environment utilizing either the Cygwin or MinGW Unix emulators, use a colon character (:) as the delimiter.</source>
          <target state="translated">그러나 GnuCOBOL 컴파일러가 Unix, OSX 또는 Linux 환경 용으로 구축되었거나 Cygwin 또는 MinGW Unix 에뮬레이터를 사용하는 Windows 환경 용으로 구축 된 경우 콜론 문자 (:)를 구분 기호로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c5c01c32e00c545ff3bdc88e7beddc787c903e01" translate="yes" xml:space="preserve">
          <source>If, however, you want to reset the &lt;code&gt;SUM&lt;/code&gt; counter only when the control footing for a control break higher in the control hierarchy is presented, specify that higher control break on the &lt;code&gt;RESET&lt;/code&gt; option.</source>
          <target state="translated">그러나 제어 계층 구조에서 상위 제어 구분에 대한 제어 기초가 제공되는 경우에만 &lt;code&gt;SUM&lt;/code&gt; 카운터 를 재설정 하려면 &lt;code&gt;RESET&lt;/code&gt; 옵션 에서 상위 제어 구분을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="732d00d8a979e2d6acfa93077091ec5aa45575e1" translate="yes" xml:space="preserve">
          <source>If, however, you want to reset the&lt;code&gt;SUM&lt;/code&gt;counter only when the control footing for a control break higher in the control hierarchy is presented, specify that higher control break on the&lt;code&gt;RESET&lt;/code&gt;option.</source>
          <target state="translated">그러나 제어 계층 구조에서 더 높은 제어 브레이크에 대한 제어 푸팅이 표시 될 때만 &lt;code&gt;SUM&lt;/code&gt; 카운터 를 재설정 하려면 &lt;code&gt;RESET&lt;/code&gt; 옵션 에서 더 높은 제어 브레이크를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="5806c2a3b18d52c426a775c9f93d63ac19b6bb13" translate="yes" xml:space="preserve">
          <source>If, on the other hand, the compiler</source>
          <target state="translated">반면에 컴파일러가</target>
        </trans-unit>
        <trans-unit id="2cd8cc804f2a5ff93a10ce1b74fdd3576f5a7e3f" translate="yes" xml:space="preserve">
          <source>If, on the other hand, the compiler &quot;config&quot; file you used to compile the program specified &quot;mf&quot; as the &quot;assign-clause&quot; value, then the File Locator String will be interpreted according to according to IBM COBOL rules &amp;mdash; namely, the File Locator String is expected to be of the form &quot;S-xxx&quot; or &quot;AS-xxx&quot;, in which case the &quot;xxx&quot; will be treated as the base of an environment variable name. If there is no &quot;-&quot; character in the File Locator String then the entire File Locator String will serve as the base of an environment variable name.</source>
          <target state="translated">반면, 프로그램 &quot;mf&quot;를 &quot;assign-clause&quot;값으로 지정한 프로그램을 컴파일하는 데 사용한 컴파일러 &quot;config&quot;파일 인 경우 File Locator 문자열은 IBM COBOL 규칙에 따라 해석됩니다. 파일 로케이터 문자열은 &quot;S-xxx&quot;또는 &quot;AS-xxx&quot;형식이어야하며,이 경우 &quot;xxx&quot;는 환경 변수 이름의 기본으로 취급됩니다. 파일 로케이터 문자열에 &quot;-&quot;문자가 없으면 전체 파일 로케이터 문자열이 환경 변수 이름의 기본으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="14a1e778d3d526022a292de2dd1ee46c48882f7a" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;AFTER ADVANCING&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;AFTER ADVANCING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2484c7b62fe9d88e48bcea28b9bbba49a4a0abff" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;FIRST&lt;/code&gt;was specified, the logical record pointer will point to the first record in the file.</source>
          <target state="translated">&lt;code&gt;FIRST&lt;/code&gt; 가 지정된 경우 논리 레코드 포인터는 파일의 첫 번째 레코드를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="7863a8759644caaed13a6998607dcd0f2e23acf3" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;KEY&lt;/code&gt;was specified or implied, the logical record pointer will be specified to the</source>
          <target state="translated">경우 &lt;code&gt;KEY&lt;/code&gt; 가 지정되거나 암시 된 논리 레코드 포인터가로 지정됩니다</target>
        </trans-unit>
        <trans-unit id="1552ccf0c116c7d239331a720f9d74cec693c257" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;LAST&lt;/code&gt;was specified, the logical record pointer will point to the last record in the file.</source>
          <target state="translated">&lt;code&gt;LAST&lt;/code&gt; 가 지정된 경우 논리 레코드 포인터는 파일의 마지막 레코드를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="8278b8c8384858282c9b205d0ba2082757d20698" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;PICTURE&lt;/code&gt;9 and contains&lt;code&gt;S&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PICTURE&lt;/code&gt; 9에 &lt;code&gt;S&lt;/code&gt; 가 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="8061e9cae2be0636e69237bf17be3f7098f0542a" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;PICTURE&lt;/code&gt;contains&lt;code&gt;S&lt;/code&gt;</source>
          <target state="translated">If&lt;code&gt;PICTURE&lt;/code&gt;contains&lt;code&gt;S&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cd6edca65a7476c700085fccd1713df6568c8bd" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;n&lt;/code&gt;represents the level number of the object, then no other data items with a level number numerically less than&lt;code&gt;n&lt;/code&gt;may be defined between the subject and object data items.</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 보다 작은 수치의 레벨 번호를 가진 물체의 레벨 번호 다음 다른 데이터 항목을 나타내며 &lt;code&gt;n&lt;/code&gt; 주체와 대상 데이터 항목들 사이에 형성 될 수있다.</target>
        </trans-unit>
        <trans-unit id="d3c3a4ef34b214c7901c86d04f87249a39615cfd" translate="yes" xml:space="preserve">
          <source>If&lt;code&gt;n&lt;/code&gt;represents the level number of the object, then no other data items with level number&lt;code&gt;n&lt;/code&gt;may be defined between the subject and object data items unless they too are&lt;code&gt;REDEFINES&lt;/code&gt;of the subject.</source>
          <target state="translated">경우에 &lt;code&gt;n&lt;/code&gt; 상기 객체의 레벨 번호 일절 레벨 번호와 다른 데이터 항목을 대표하지 &lt;code&gt;n&lt;/code&gt; 이 너무 아니라면 주체와 대상 데이터 항목 사이에 형성 될 수있다 &lt;code&gt;REDEFINES&lt;/code&gt; 피사체.</target>
        </trans-unit>
        <trans-unit id="44bac4e7eb3f9b6dfa360542d18651d867fe0f3a" translate="yes" xml:space="preserve">
          <source>Imagine my surprise, however, when I discovered that the use of</source>
          <target state="translated">하지만 놀랍게도</target>
        </trans-unit>
        <trans-unit id="41e3512adad8c7a49c2bc5818c26857faf073355" translate="yes" xml:space="preserve">
          <source>Imagine my surprise, however, when I discovered that the use of&lt;code&gt;-fnotrunc&lt;/code&gt;switch also made a difference:</source>
          <target state="translated">그러나 &lt;code&gt;-fnotrunc&lt;/code&gt; 스위치를 사용 하면 차이가 있음을 발견했을 때 놀랍습니다 .</target>
        </trans-unit>
        <trans-unit id="ba2d2155230191737321736ab1c421252a9d474f" translate="yes" xml:space="preserve">
          <source>Imperative Statement</source>
          <target state="translated">명령문</target>
        </trans-unit>
        <trans-unit id="093f2fea111647ab73586789136bb3d0d4a0950c" translate="yes" xml:space="preserve">
          <source>Implementation-defined accept condition</source>
          <target state="translated">구현 정의 수락 조건</target>
        </trans-unit>
        <trans-unit id="3d29bb9dbd4be0c211a42d389e2c3292fd50b3aa" translate="yes" xml:space="preserve">
          <source>Implementation-defined display condition</source>
          <target state="translated">구현 정의 표시 조건</target>
        </trans-unit>
        <trans-unit id="b6644f9a8f19bd69003afc9a5c99d078e33e6700" translate="yes" xml:space="preserve">
          <source>In Micro Focus COBOL, calling this subroutine flushes any as-yet unwritten buffers for the (output) file whose file-handle is specified as the argument to disk.</source>
          <target state="translated">Micro Focus COBOL에서이 서브 루틴을 호출하면 파일 핸들이 디스크에 대한 인수로 지정된 (출력) 파일에 대해 아직 기록되지 않은 버퍼가 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="9a3d8039ba479addeceb49cf9771fd1febf412b7" translate="yes" xml:space="preserve">
          <source>In addition there is the &lt;a href=&quot;https://gnucobol.sourceforge.io/faq/index.html&quot;&gt;GnuCOBOL FAQ&lt;/a&gt; &amp;mdash; which has now exceeded 1,400 pages &amp;mdash; available as HTML or a downloadable</source>
          <target state="translated">또한 &lt;a href=&quot;https://gnucobol.sourceforge.io/faq/index.html&quot;&gt;GnuCOBOL FAQ (&lt;/a&gt; 현재 1,400 페이지를 넘었습니다)가 있습니다. HTML 또는 다운로드 가능한</target>
        </trans-unit>
        <trans-unit id="d9ef63e2e17e3ccc69daafe9826c9b7b1b6876dd" translate="yes" xml:space="preserve">
          <source>In addition, you can add and/or remove reserved words by adding one of these options to cobc to add</source>
          <target state="translated">또한 이러한 옵션 중 하나를 cobc에 추가하여 예약어를 추가 및 / 또는 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1823875f108e53987aa44c7484ef1eb0340b856" translate="yes" xml:space="preserve">
          <source>In an attempt to correct the problem, we could qualify the reference to &lt;code&gt;CITY&lt;/code&gt; as &lt;code&gt;MOVE 'Philadelphia' TO CITY OF MAILING-ADDRESS&lt;/code&gt;.</source>
          <target state="translated">문제를 해결하기 위해 &lt;code&gt;CITY&lt;/code&gt; 에 대한 참조를 &lt;code&gt;MOVE 'Philadelphia' TO CITY OF MAILING-ADDRESS&lt;/code&gt; 로 한정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d3ffee367a47df22f0329d2161f7179c7140f49" translate="yes" xml:space="preserve">
          <source>In an attempt to correct the problem, we could qualify the reference to CITY as&lt;code&gt;MOVE 'Philadelphia' TO CITY OF MAILING-ADDRESS&lt;/code&gt;</source>
          <target state="translated">문제를 해결하기 위해 도시 &lt;code&gt;MOVE 'Philadelphia' TO CITY OF MAILING-ADDRESS&lt;/code&gt; 로 이동하는 '필라델피아 (Philadelphia)' 로 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1132a1566c2ed19e4f36c07a65dd3752e2bf4c83" translate="yes" xml:space="preserve">
          <source>In complex expressions composed of multiple operators and operands, a precedence of operation applies whereby those operations having a higher precedence are computed first before operations with a lower precedence.</source>
          <target state="translated">여러 연산자와 피연산자로 구성된 복잡한 식에서 우선 순위가 높은 연산이 우선 순위가 낮은 연산보다 먼저 계산되는 연산 우선 순위가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="79c5dda42b4edec899decd22cc8013757597eb29" translate="yes" xml:space="preserve">
          <source>In either instance, program</source>
          <target state="translated">두 경우 모두 프로그램</target>
        </trans-unit>
        <trans-unit id="67cd2a991339c0db61eccf443f46cb731b97b13e" translate="yes" xml:space="preserve">
          <source>In either instance, program &quot;A&quot; is referred to as the &amp;rsquo;</source>
          <target state="translated">어느 경우 든, 프로그램 &quot;A&quot;는 &quot;</target>
        </trans-unit>
        <trans-unit id="b68b4bcf151b57e71e554fe7952a0e73619a414f" translate="yes" xml:space="preserve">
          <source>In general, each picture symbol represents either a single character in storage or a single decimal digit. There are a few exceptions, and they will be discussed as needed.</source>
          <target state="translated">일반적으로 각 그림 기호는 저장소의 단일 문자 또는 하나의 10 진수를 나타냅니다. 몇 가지 예외가 있으며 필요에 따라 논의 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="2411df7c12420101004e143cb3943a4101a56bf7" translate="yes" xml:space="preserve">
          <source>In general, table references such as example #1 (constant subscript) generate the smallest, simplest and fastest object code while table references such as example #2 (numeric data item subscript) generate the largest, most-complicated and slowest object code.</source>
          <target state="translated">일반적으로 예제 # 1 (일정한 첨자)과 같은 테이블 참조는 가장 작고 단순하며 빠른 객체 코드를 생성하는 반면 예제 # 2 (숫자 데이터 항목 첨자)와 같은 테이블 참조는 가장 크고 복잡하고 느린 객체 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9f3d74011ccc810b1770ab4e3dfbc7f8f1fdf305" translate="yes" xml:space="preserve">
          <source>In highest to lowest order of precedence, here is a discussion of each category of operation:</source>
          <target state="translated">우선 순위가 가장 높은 순서에서 다음은 각 작업 범주에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="37e03fd035bc729f5e1bac261783ab6dc96b9a08" translate="yes" xml:space="preserve">
          <source>In order for &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="8be023fea55c01ac8e26c286b3ef96dd0c3a62af" translate="yes" xml:space="preserve">
          <source>In order for &lt;code&gt;AND&lt;/code&gt; to yield a value of &lt;code&gt;TRUE&lt;/code&gt;, both conditions must have a value of &lt;code&gt;TRUE&lt;/code&gt;. In all other circumstances, &lt;code&gt;AND&lt;/code&gt; produces a &lt;code&gt;FALSE&lt;/code&gt; value.</source>
          <target state="translated">위해서는 &lt;code&gt;AND&lt;/code&gt; 의 값을 산출하는 &lt;code&gt;TRUE&lt;/code&gt; 를 , 두 조건이 모두의 값이 있어야합니다 &lt;code&gt;TRUE&lt;/code&gt; 를 . 다른 모든 상황에서 &lt;code&gt;AND&lt;/code&gt; 는 &lt;code&gt;FALSE&lt;/code&gt; 값을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="403d7a15fce45769c754a15681e968a4fbdf42a3" translate="yes" xml:space="preserve">
          <source>In order for &lt;var&gt;data-item-1&lt;/var&gt;, defined subordinate to group item &lt;var&gt;group-item-1&lt;/var&gt; to be a</source>
          <target state="translated">위해서는 &lt;var&gt;data-item-1&lt;/var&gt; , 항목 그룹에 종속 정의 &lt;var&gt;group-item-1&lt;/var&gt; 이어야</target>
        </trans-unit>
        <trans-unit id="6bb3bbadc2d27138c4c9dae5d396fb6f7ddc8694" translate="yes" xml:space="preserve">
          <source>In order for a &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="696cb05cea8df84db487d490488180e06e42f98d" translate="yes" xml:space="preserve">
          <source>In order for a &lt;var&gt;Selection-Subject&lt;/var&gt; to match the corresponding &lt;var&gt;Selection-Object&lt;/var&gt; on a &lt;code&gt;WHEN&lt;/code&gt; clause, at least one of the following must be true:</source>
          <target state="translated">A의 순서로 &lt;var&gt;Selection-Subject&lt;/var&gt; 대응에 맞게 &lt;var&gt;Selection-Object&lt;/var&gt; A의 &lt;code&gt;WHEN&lt;/code&gt; 절을, 다음 중 적어도 하나에 해당해야합니다 :</target>
        </trans-unit>
        <trans-unit id="36616f50c54eeaba783ad05be353c37e7580b497" translate="yes" xml:space="preserve">
          <source>In order for this clause to take effect at execution time, the user must move the cursor into the field having this clause in its definition.</source>
          <target state="translated">이 절이 실행 시간에 적용 되려면 사용자는 정의에서이 절이있는 필드로 커서를 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="444f270a7cbd0c09971c70be690ab851095b1a67" translate="yes" xml:space="preserve">
          <source>In order for this statement to be functional, tracing code must have been generated into the compiled program using either the</source>
          <target state="translated">이 명령문이 작동하려면 추적 코드가 다음 중 하나를 사용하여 컴파일 된 프로그램에 생성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d4cc191768c1993e9df309f3f21d935b4723ece5" translate="yes" xml:space="preserve">
          <source>In order for this statement to be functional, tracing code must have been generated into the compiled program using either the&lt;code&gt;-ftrace&lt;/code&gt;switch</source>
          <target state="translated">이 명령문이 작동하려면 &lt;code&gt;-ftrace&lt;/code&gt; 스위치를 사용하여 컴파일 된 프로그램에 추적 코드가 생성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d5716d69487d7213f5a154886aec1d579f1359df" translate="yes" xml:space="preserve">
          <source>In order for&lt;code&gt;AND&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;AND&lt;/code&gt; 를 위해</target>
        </trans-unit>
        <trans-unit id="55a2f8f43b118a2097c61e0a121129644cb22e23" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;ldquo;curses&amp;rdquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;ldquo;PDCurses&amp;rdquo; package (used for native Windows or MinGW builds) does not support &lt;code&gt;EMPTY-CHECK&lt;/code&gt;.</source>
          <target state="translated">작동하려면이 속성이 GnuCOBOL 구현에 사용 된 기본 &quot;curses&quot;패키지에 의해 지원되어야합니다. 현재 &quot;PDCurses&quot;패키지 (기본 Windows 또는 MinGW 빌드에 사용됨)는 &lt;code&gt;EMPTY-CHECK&lt;/code&gt; 를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="10f811fb445b449e40e131320d635a7695478fd5" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;ldquo;curses&amp;rdquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;ldquo;PDCurses&amp;rdquo; package (used for native Windows or MinGW builds) does not support &lt;code&gt;FULL&lt;/code&gt;.</source>
          <target state="translated">작동하려면이 속성이 GnuCOBOL 구현에 사용 된 기본 &quot;curses&quot;패키지에 의해 지원되어야합니다. 현재 &quot;PDCurses&quot;패키지 (기본 Windows 또는 MinGW 빌드에 사용됨)는 &lt;code&gt;FULL&lt;/code&gt; 을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ee0e64cc488517a5d97ddaf5487ad3ecb48a7a2a" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;ldquo;curses&amp;rdquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;ldquo;PDCurses&amp;rdquo; package (used for native Windows or MinGW builds) does not support &lt;code&gt;LENGTH-CHECK&lt;/code&gt;.</source>
          <target state="translated">작동하려면이 속성이 GnuCOBOL 구현에 사용 된 기본 &quot;curses&quot;패키지에 의해 지원되어야합니다. 현재 &quot;PDCurses&quot;패키지 (기본 Windows 또는 MinGW 빌드에 사용됨)는 &lt;code&gt;LENGTH-CHECK&lt;/code&gt; 를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fa94c33bd182287b891147b289c4b02751b3b24e" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;ldquo;curses&amp;rdquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;ldquo;PDCurses&amp;rdquo; package (used for native Windows or MinGW builds) does not support &lt;code&gt;REQUIRED&lt;/code&gt;.</source>
          <target state="translated">작동하려면이 속성이 GnuCOBOL 구현에 사용 된 기본 &quot;curses&quot;패키지에 의해 지원되어야합니다. 현재 &quot;PDCurses&quot;패키지 (기본 Windows 또는 MinGW 빌드에 사용됨)는 &lt;code&gt;REQUIRED&lt;/code&gt; 를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="12840b41d70472b409489727335424ef0070e853" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;EMPTY-CHECK&lt;/code&gt;</source>
          <target state="translated">기능적으로 작동하려면 GnuCOBOL 구현이 구축 된 기본 'curses'패키지에서이 속성을 지원해야합니다. 현재 'PDCurses'패키지 (기본 Windows 또는 MinGW 빌드에 사용)는 &lt;code&gt;EMPTY-CHECK&lt;/code&gt; 를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="17d285867c49f9dd90eb1f27cf9c7a60d1e38df8" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;FULL&lt;/code&gt;</source>
          <target state="translated">기능적으로 작동하려면 GnuCOBOL 구현이 구축 된 기본 'curses'패키지에서이 속성을 지원해야합니다. 현재 'PDCurses'패키지 (기본 Windows 또는 MinGW 빌드에 사용)는 &lt;code&gt;FULL&lt;/code&gt; 을 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="0a81aca05eb7b3e3ebeefcb93bfd42b8a77e381a" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;LENGTH-CHECK&lt;/code&gt;</source>
          <target state="translated">기능적으로 작동하려면 GnuCOBOL 구현이 구축 된 기본 'curses'패키지에서이 속성을 지원해야합니다. 현재 'PDCurses'패키지 (기본 Windows 또는 MinGW 빌드에 사용)는 &lt;code&gt;LENGTH-CHECK&lt;/code&gt; 를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de32275ede835ac63170073ab2d665b3951078da" translate="yes" xml:space="preserve">
          <source>In order to be functional, this attribute must be supported by the underlying &amp;rsquo;curses&amp;rsquo; package your GnuCOBOL implementation was built with. As of this time, the &amp;rsquo;PDCurses&amp;rsquo; package (used for native Windows or MinGW builds) does not support&lt;code&gt;REQUIRED&lt;/code&gt;</source>
          <target state="translated">기능적으로 작동하려면 GnuCOBOL 구현이 구축 된 기본 'curses'패키지에서이 속성을 지원해야합니다. 현재 'PDCurses'패키지 (기본 Windows 또는 MinGW 빌드에 사용)는 &lt;code&gt;REQUIRED&lt;/code&gt; 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ea48fcaef90024e13873585a7560dd9b545d9d4" translate="yes" xml:space="preserve">
          <source>In order to take effect, the user must first move the cursor into the field having this clause in its definition.</source>
          <target state="translated">적용하려면 사용자가 먼저 정의에서이 절이있는 필드로 커서를 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="6329aaa46fe1739509d0184063f2f41cb7ae1982" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; paragraph, an external switch name can be associated with one or more condition names. These condition names may then be used to test the ON/OFF status of the external switch.</source>
          <target state="translated">에서 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; 단락 외부 스위치 이름이 하나 개 이상의 조건의 이름과 연관 될 수있다. 그런 다음 이러한 조건 이름을 사용하여 외부 스위치의 ON / OFF 상태를 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc57fee8f92052111c736b00a5242c4a85a7c964" translate="yes" xml:space="preserve">
          <source>In the above examples, a comma is used as a separator character between the two subscript values; semicolons (&lt;code&gt;;&lt;/code&gt;) are also valid subscript separator characters, as are spaces! The use of a comma or semicolon separator in such a situation is technically optional, but by convention most COBOL programmers use one or the other. The use of no separator character (other than a space) is not recommended, even though it is syntactically correct, as this practice can lead to programmer-unfriendly code. It isn&amp;rsquo;t too difficult to read and understand &lt;code&gt;GRID-CHARACTER(2 3)&lt;/code&gt;, but it&amp;rsquo;s another story entirely when trying to comprehend &lt;code&gt;GRID-CHARACTER(I + 1 J / 3)&lt;/code&gt; (instead of &lt;code&gt;GRID-CHARACTER(I + 1, J / 3)&lt;/code&gt;). The compiler accepts it, but too much of this would make</source>
          <target state="translated">위의 예에서 쉼표는 두 첨자 값 사이의 구분 문자로 사용됩니다. 세미콜론 ( &lt;code&gt;;&lt;/code&gt; )은 공백과 마찬가지로 유효한 아래 첨자 구분 문자입니다! 이러한 상황에서 쉼표 또는 세미콜론 구분 기호를 사용하는 것은 기술적으로 선택 사항이지만 일반적으로 대부분의 COBOL 프로그래머는 둘 중 하나를 사용합니다. 구분 문자 (공백 제외)를 사용하지 않는 것은 구문 적으로 정확하더라도 프로그래머에게 친숙하지 않은 코드로 이어질 수 있으므로 권장되지 않습니다. &lt;code&gt;GRID-CHARACTER(2 3)&lt;/code&gt; 을 읽고 이해하는 것은 그리 어렵지 않지만 &lt;code&gt;GRID-CHARACTER(I + 1 J / 3)&lt;/code&gt; ( &lt;code&gt;GRID-CHARACTER(I + 1, J / 3)&lt;/code&gt; ). 컴파일러는 그것을 받아들이지 만 너무 많이하면</target>
        </trans-unit>
        <trans-unit id="c1ff1f707da403375eb5aac3df8097ce50066a1d" translate="yes" xml:space="preserve">
          <source>In the above examples, a comma is used as a separator character between the two subscript values; semicolons &lt;code&gt;;&lt;/code&gt; are also valid subscript separator characters, as are spaces! The use of a comma or semicolon separator in such a situation is technically optional, but by convention most COBOL programmers use one or the other. The use of no separator character (other than a space) is not recommended, even though it is syntactically correct, as this practice can lead to programmer-unfriendly code. It isn&amp;rsquo;t too difficult to read and understand&lt;code&gt;GRID-CHARACTER(2 3)&lt;/code&gt; but it&amp;rsquo;s another story entirely when trying to comprehend&lt;code&gt;GRID-CHARACTER(I + 1 J / 3)&lt;/code&gt;(instead of&lt;code&gt;GRID-CHARACTER(I + 1, J / 3)&lt;/code&gt;. The compiler accepts it, but too much of this would make</source>
          <target state="translated">위의 예에서 쉼표는 두 첨자 값 사이의 구분 문자로 사용됩니다. 세미콜론 &lt;code&gt;;&lt;/code&gt; 공백과 마찬가지로 유효한 첨자 구분 문자도 있습니다! 이러한 상황에서 쉼표 또는 세미콜론 구분 기호를 사용하는 것은 기술적으로 선택 사항이지만, 대부분의 COBOL 프로그래머는 일반적으로 하나를 사용합니다. 프로그래밍 방식에 친숙하지 않은 코드로 이어질 수 있으므로 구문 상 올바르지 만 구분 기호 문자 (공백 이외의)는 사용하지 않는 것이 좋습니다. &lt;code&gt;GRID-CHARACTER(2 3)&lt;/code&gt; 를 읽고 이해하는 것은 너무 어렵지 않지만 &lt;code&gt;GRID-CHARACTER(I + 1 J / 3)&lt;/code&gt; 를 이해하려고 할 때의 이야기 입니다 ( &lt;code&gt;GRID-CHARACTER(I + 1, J / 3)&lt;/code&gt; . 컴파일러가이를 받아들이지 만 너무 많으면</target>
        </trans-unit>
        <trans-unit id="52f55f41b9c4760d3c377c604dc4758316a39ba3" translate="yes" xml:space="preserve">
          <source>In the absence of the  &lt;code&gt;OVERRIDE&lt;/code&gt; option, &lt;var&gt;cdf-variable-1&lt;/var&gt; must not yet have been defined. When the &lt;code&gt;OVERRIDE&lt;/code&gt; option is specified, &lt;var&gt;cdf-variable-1&lt;/var&gt; will be created with the specified value, if it had not yet been defined. If it had already been defined, it will be redefined with the new value.</source>
          <target state="translated">&lt;code&gt;OVERRIDE&lt;/code&gt; 옵션 이 없으면 &lt;var&gt;cdf-variable-1&lt;/var&gt; 이 아직 정의되지 않았어야 합니다. 때 &lt;code&gt;OVERRIDE&lt;/code&gt; 의 옵션을 지정, &lt;var&gt;cdf-variable-1&lt;/var&gt; 이 아직 정의되지 않은 경우, 지정된 값으로 생성됩니다. 이미 정의 된 경우 새 값으로 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="ab0a8c97ecdd65110e9781dbe9e9bcdabaa33882" translate="yes" xml:space="preserve">
          <source>In the absence of the&lt;code&gt;OVERRIDE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;OVERRIDE&lt;/code&gt; 가 없을 때</target>
        </trans-unit>
        <trans-unit id="bfc5f4c3999bc465f3a7a57164398621856b4683" translate="yes" xml:space="preserve">
          <source>In the case of the former, the &lt;code&gt;USING&lt;/code&gt; clause on the procedure division header should describe the argument via the  &lt;code&gt;BY REFERENCE&lt;/code&gt; clause &amp;mdash; in the latter case, a  &lt;code&gt;BY VALUE&lt;/code&gt; specification should be coded. This allows the code generated by the compiler to properly reference the subprogram arguments at run-time.</source>
          <target state="translated">전자의 경우 프로 시저 분할 헤더 의 &lt;code&gt;USING&lt;/code&gt; 절은 &lt;code&gt;BY REFERENCE&lt;/code&gt; 절을 통해 인수를 설명해야 합니다. 후자의 경우 &lt;code&gt;BY VALUE&lt;/code&gt; 사양을 코딩해야합니다. 이렇게하면 컴파일러에서 생성 된 코드가 런타임에 하위 프로그램 인수를 적절하게 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be9ad81756c2c029daadb7f85dc6de13011d4872" translate="yes" xml:space="preserve">
          <source>In the case of the former, the&lt;code&gt;USING&lt;/code&gt;clause on the procedure division header should describe the argument via the&lt;code&gt;BY REFERENCE&lt;/code&gt;</source>
          <target state="translated">전자의 경우 , 프로 시저 분할 헤더 의 &lt;code&gt;USING&lt;/code&gt; 절은 &lt;code&gt;BY REFERENCE&lt;/code&gt; 를 통해 인수를 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="3683f2272e68eee3328548bbf75c6cbed2e45e7d" translate="yes" xml:space="preserve">
          <source>In the late 70&amp;rsquo;s cards was also on its way out to the point where P.C&amp;rsquo;s started being used (and no they were not made by IBM), so these columns could be used for other purposes including cc 73 - 80 instead of indicating the 8 character program name which was the maximum size allowed on a IBM system.</source>
          <target state="translated">70 년대 후반에 PC가 사용되기 시작한 시점 (그리고 IBM이 만든 것도 아님)까지 카드가 나오기 때문에이 열은 CC 73-80을 포함한 다른 목적으로 IBM 시스템에서 허용되는 최대 크기 인 8 자 프로그램 이름.</target>
        </trans-unit>
        <trans-unit id="d448bc8e604cd799be10bb1a12e035041426f0fc" translate="yes" xml:space="preserve">
          <source>In this case, the &lt;code&gt;EXIT&lt;/code&gt; statement takes no other run-time action.</source>
          <target state="translated">이 경우 &lt;code&gt;EXIT&lt;/code&gt; 문은 다른 런타임 작업을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82849a227b43e92353f440e6cf481dde7d3eb800" translate="yes" xml:space="preserve">
          <source>In this case, the&lt;code&gt;EXIT&lt;/code&gt;statement takes no other run-time action.</source>
          <target state="translated">이 경우 &lt;code&gt;EXIT&lt;/code&gt; 문은 다른 런타임 조치를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f943ab0caafc93abf22796cdb3e33af1b9b863ef" translate="yes" xml:space="preserve">
          <source>In this context, &lt;code&gt;VALUE&lt;/code&gt; specifies an initial compilation-time value that will be assigned to the storage occupied by the data item in the program object code generated by the compiler.</source>
          <target state="translated">이 컨텍스트에서 &lt;code&gt;VALUE&lt;/code&gt; 는 컴파일러가 생성 한 프로그램 오브젝트 코드에서 데이터 항목이 차지하는 스토리지에 할당 될 초기 컴파일 시간 값을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2a9d1dc97c6798126e8a06dda35c75cc92d21220" translate="yes" xml:space="preserve">
          <source>In this context,&lt;code&gt;VALUE&lt;/code&gt;specifies an initial compilation-time value that will be assigned to the storage occupied by the data item in the program object code generated by the compiler.</source>
          <target state="translated">이 컨텍스트에서 &lt;code&gt;VALUE&lt;/code&gt; 는 컴파일러가 생성 한 프로그램 오브젝트 코드에서 데이터 항목이 차지하는 스토리지에 할당 될 초기 컴파일 시간 값을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="eec8378c7504896f2e89770da7d03a86fe4ae4b3" translate="yes" xml:space="preserve">
          <source>In this example, all six &amp;lsquo;</source>
          <target state="translated">이 예에서는 6 개의 '</target>
        </trans-unit>
        <trans-unit id="84cb1e4aa0b378b3db93b48860594751f6ae285f" translate="yes" xml:space="preserve">
          <source>In this example, all six&lt;code&gt;A&lt;/code&gt;items will be initialized to &quot;?&quot;, all six&lt;code&gt;B&lt;/code&gt;items will be initialized to &quot;%&quot; and all six&lt;code&gt;N&lt;/code&gt;items will be initialized to 10. It&amp;rsquo;s not clear exactly how many times this sort of initialization will be useful, but it&amp;rsquo;s there if you need it.</source>
          <target state="translated">이 예에서는 6 개의 &lt;code&gt;A&lt;/code&gt; 항목이 모두 &quot;?&quot;로 초기화되고 6 개의 &lt;code&gt;B&lt;/code&gt; 항목이 모두 &quot;%&quot;로 초기화되고 6 개의 &lt;code&gt;N&lt;/code&gt; 항목이 모두 10으로 초기화됩니다. 이러한 초기화 유형이 정확히 몇 번인지는 명확하지 않습니다. 유용하지만 필요한 경우 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdd4beaea45ea4f61aa50c556d96af34394add5c" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;IF&lt;/code&gt; statement actually has a scope that can include two sets of associated statements: one set to be executed when the &lt;code&gt;IF&lt;/code&gt; (see &lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt;) condition is &lt;code&gt;TRUE&lt;/code&gt;, and another if it is &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">이 예에서 &lt;code&gt;IF&lt;/code&gt; 문은 실제로 두 세트의 관련 문을 포함 할 수있는 범위를 가지고 있습니다. 하나는 &lt;code&gt;IF&lt;/code&gt; ( &lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt; 참조 ) 조건이 &lt;code&gt;TRUE&lt;/code&gt; 일 때 실행되는 집합 이고 다른 하나는 &lt;code&gt;FALSE&lt;/code&gt; 일 때 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="2879e2f56bb5d870554e86f04a4bf9ebe7fb4ed9" translate="yes" xml:space="preserve">
          <source>In this example, the IF statement actually has a scope that can include two sets of associated statements &amp;ndash; one set to be executed when the&lt;code&gt;IF&lt;/code&gt;(see &lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt;) condition is TRUE and another if it is FALSE.</source>
          <target state="translated">이 예에서 IF 문에는 실제로 두 세트의 연관된 명령문이 포함될 수있는 범위가 있습니다. 하나는 &lt;code&gt;IF&lt;/code&gt; ( &lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt; 참조 ) 조건이 TRUE 일 때 실행 되고 다른 하나는 FALSE 일 때 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="b671b6f79a2badfb5c4ccb993eb5f1ff2485bd4c" translate="yes" xml:space="preserve">
          <source>In which case 9 characters of storage will be reserved. The values 000000000 through 999999999 will represent the gross-revenues. But, if only the millions are tracked (meaning the last six digits are always going to be 0), you could define the field as:</source>
          <target state="translated">이 경우 9 문자의 스토리지가 예약됩니다. 000000000-999999999 값은 총 수익을 나타냅니다. 그러나 수백만 만 추적하는 경우 (마지막 6 자리가 항상 0이 됨) 필드를 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f756e9a80d7e50bae6b071828fc08b35abbddf1" translate="yes" xml:space="preserve">
          <source>Include the reserved word  &lt;code&gt;FINAL&lt;/code&gt; if you want to include a special control heading before the first detail line is generated (&lt;code&gt;CONTROL HEADING FINAL&lt;/code&gt;) or after the last detail line is generated (&lt;code&gt;CONTROL FOOTING FINAL&lt;/code&gt;).</source>
          <target state="translated">첫 번째 세부 줄이 생성되기 전 ( &lt;code&gt;CONTROL HEADING FINAL&lt;/code&gt; ) 또는 마지막 세부 줄이 생성 된 후 ( &lt;code&gt;CONTROL FOOTING FINAL&lt;/code&gt; ) 특수 제어 머리글을 포함하려면 예약어 &lt;code&gt;FINAL&lt;/code&gt; 을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="6178a2fcb450efe4624273996659b2d5392d26b6" translate="yes" xml:space="preserve">
          <source>Include the reserved word&lt;code&gt;FINAL&lt;/code&gt;</source>
          <target state="translated">예약어 &lt;code&gt;FINAL&lt;/code&gt; 포함</target>
        </trans-unit>
        <trans-unit id="86e3af29a6d78fb45be9ab4a356d52986963f954" translate="yes" xml:space="preserve">
          <source>Including an &lt;code&gt;ON SIZE ERROR&lt;/code&gt; clause on an arithmetic statement will allow your program to trap a failure of an arithmetic statement (either generating a result too large for the receiving field, or attempting to divide by zero) and handle it gracefully by executing &lt;var&gt;imperative-statement-1&lt;/var&gt; (see &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt;). Field size overflow conditions occur silently, usually without any runtime messages being generated, even though such events rarely lend themselves to generating correct results. Division by zero errors, when no &lt;code&gt;ON SIZE ERROR&lt;/code&gt; clause exists, will produce an error message (by the GnuCOBOL runtime library) to the &lt;code&gt;SYSERR&lt;/code&gt; device (pipe 2) and will also abort the program.</source>
          <target state="translated">산술 명령문에 &lt;code&gt;ON SIZE ERROR&lt;/code&gt; 절을 포함하면 프로그램이 산술 명령문의 실패를 포착하고 (수신 필드에 비해 너무 큰 결과를 생성하거나 0으로 나누려고 시도 함) &lt;var&gt;imperative-statement-1&lt;/var&gt; 을 실행하여 정상적으로 처리 할 수 ​​있습니다 . -1 ( &lt;a href=&quot;#Imperative-Statement&quot;&gt;명령문&lt;/a&gt; 참조 ). 필드 크기 오버플로 조건은 이러한 이벤트가 올바른 결과를 생성하는 데 거의 도움이되지 않더라도 일반적으로 런타임 메시지가 생성되지 않고 조용히 발생합니다. &lt;code&gt;ON SIZE ERROR&lt;/code&gt; 절이 없는 경우 오류 0으로 나누면 &lt;code&gt;SYSERR&lt;/code&gt; 장치 (파이프 2)에 오류 메시지 (GnuCOBOL 런타임 라이브러리에 의해)가 생성 되고 프로그램도 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="4587868819f3914fb0d960b2a017af52903b843c" translate="yes" xml:space="preserve">
          <source>Including an&lt;code&gt;ON SIZE ERROR&lt;/code&gt;clause on an arithmetic statement will allow your program to trap a failure of an arithmetic statement (either generating a result too large for the receiving field, or attempting to divide by zero) and handle it gracefully by executing &amp;lt;</source>
          <target state="translated">산술 문에 &lt;code&gt;ON SIZE ERROR&lt;/code&gt; 절을 포함 시키면 프로그램이 산술 문의 실패 (수신 필드에 대해 너무 큰 결과를 생성하거나 0으로 나누려고 시도)를 트랩하고 &amp;lt;를 실행하여 정상적으로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="2ec9e5e5288405f63d74272e4e8bcad544b64e15" translate="yes" xml:space="preserve">
          <source>Incompatible data exception</source>
          <target state="translated">호환되지 않는 데이터 예외</target>
        </trans-unit>
        <trans-unit id="e0049c7018b06d02f3c0ba2245a0ee83c74d7cc7" translate="yes" xml:space="preserve">
          <source>Inconsistent filename</source>
          <target state="translated">일치하지 않는 파일 이름</target>
        </trans-unit>
        <trans-unit id="e5d727021f58d38c370cf7243256d9dff80ee53f" translate="yes" xml:space="preserve">
          <source>Independent Subprograms</source>
          <target state="translated">독립 서브 프로그램</target>
        </trans-unit>
        <trans-unit id="0e0834dadd433c69c101f415ef11e7aef2f4805a" translate="yes" xml:space="preserve">
          <source>Indexed files are processed using the following statements:</source>
          <target state="translated">색인화 된 파일은 다음 명령문을 사용하여 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="1744e48f509016afca9d63b5cee3efedb0414b54" translate="yes" xml:space="preserve">
          <source>Indexed files, like relative files, may have their records processed in either a sequential or random manner. Unlike relative files, however, the actual location of a record in an indexed file is calculated automatically based upon the value(s) of one or more alphanumeric fields within records of the file. For example, an indexed file containing product data might use the product identification code as a record key. This means you may read, write or update the &lt;code&gt;A6G4328&lt;/code&gt;&lt;sup&gt;th&lt;/sup&gt; record or the &lt;code&gt;Z8X7723&lt;/code&gt;&lt;sup&gt;th&lt;/sup&gt; record directly, based upon the product id value of those records!</source>
          <target state="translated">상대 파일과 같이 인덱싱 된 파일은 순차적 또는 무작위 방식으로 처리되는 레코드를 가질 수 있습니다. 그러나 상대 파일과 달리 인덱싱 된 파일에서 레코드의 실제 위치는 파일 레코드 내의 하나 이상의 영숫자 필드 값을 기반으로 자동으로 계산됩니다. 예를 들어, 제품 데이터가 포함 된 색인 파일은 제품 식별 코드를 레코드 키로 사용할 수 있습니다. 즉 , 해당 레코드의 제품 ID 값을 기반으로 &lt;code&gt;A6G4328&lt;/code&gt; &lt;sup&gt;번째&lt;/sup&gt; 레코드 또는 &lt;code&gt;Z8X7723&lt;/code&gt; &lt;sup&gt;번째&lt;/sup&gt; 레코드를 직접 읽거나 쓰거나 업데이트 할 수 있습니다 !</target>
        </trans-unit>
        <trans-unit id="53ce26f7aaa0c6fd7bd1bac7547ef119ea253eb9" translate="yes" xml:space="preserve">
          <source>Indexing is the process of referencing an element of a table utilizing a data item with an explicitly or implicitly defined &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of &lt;code&gt;INDEX&lt;/code&gt; to select the desired occurrence, while &amp;hellip;</source>
          <target state="translated">인덱싱은 원하는 항목을 선택하기 위해 명시 적 또는 암시 적으로 정의 된 &lt;code&gt;INDEX&lt;/code&gt; 의 &lt;code&gt;USAGE&lt;/code&gt; ( &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt; 참조 )가 있는 데이터 항목을 사용하여 테이블의 요소를 참조하는 프로세스입니다 .</target>
        </trans-unit>
        <trans-unit id="9353f9003cee9268ec86b3a1ea7f4d4ecb16eb1c" translate="yes" xml:space="preserve">
          <source>Indexing is the process of referencing an element of a table utilizing a data item with an explicitly or implicitly defined&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of&lt;code&gt;INDEX&lt;/code&gt;to select the desired occurrence, while &amp;hellip;</source>
          <target state="translated">인덱싱은 &lt;code&gt;INDEX&lt;/code&gt; 의 명시 적 또는 암시 적으로 정의 된 &lt;code&gt;USAGE&lt;/code&gt; ( &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt; 참조 )가 있는 데이터 항목을 사용 하여 원하는 요소를 선택하는 동안 테이블 요소를 참조하는 프로세스입니다 .</target>
        </trans-unit>
        <trans-unit id="93776ca03e71b3ad421edc98eae15b926b860367" translate="yes" xml:space="preserve">
          <source>Indicator Area</source>
          <target state="translated">표시기 영역</target>
        </trans-unit>
        <trans-unit id="2fd879baf4180584f7bd97459985ff5ec005ec3f" translate="yes" xml:space="preserve">
          <source>Individually</source>
          <target state="translated">Individually</target>
        </trans-unit>
        <trans-unit id="b89618369028da6501ce98bcb744af95461452b5" translate="yes" xml:space="preserve">
          <source>Initialize small tables at compile time by including a &lt;code&gt;VALUE&lt;/code&gt; clause on the group item that serves as a parent to the table, as follows:</source>
          <target state="translated">다음과 같이 테이블의 부모 역할을하는 그룹 항목에 &lt;code&gt;VALUE&lt;/code&gt; 절을 포함하여 컴파일 타임에 작은 테이블을 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="a6c6b82216692a3106690069e47ca45a2e70d92d" translate="yes" xml:space="preserve">
          <source>Initialize small tables at compile time by including a&lt;code&gt;VALUE&lt;/code&gt;clause on the group item that serves as a parent to the table, as follows:</source>
          <target state="translated">다음과 같이 테이블의 부모 역할을하는 그룹 항목에 &lt;code&gt;VALUE&lt;/code&gt; 절을 포함시켜 컴파일 타임에 작은 테이블을 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="27a882e0892fd25d36e3f04ed9f9da709b0210eb" translate="yes" xml:space="preserve">
          <source>Initialize tables of almost any size at compilation time by utilizing the &lt;code&gt;REDEFINES&lt;/code&gt; (see &lt;a href=&quot;#REDEFINES&quot;&gt;REDEFINES&lt;/a&gt;) clause:</source>
          <target state="translated">&lt;code&gt;REDEFINES&lt;/code&gt; ( &lt;a href=&quot;#REDEFINES&quot;&gt;REDEFINES&lt;/a&gt; 참조 ) 절 을 사용하여 컴파일 시간에 거의 모든 크기의 테이블을 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="24b3196c683087c1c3199428c0580a1c1d58213b" translate="yes" xml:space="preserve">
          <source>Initialize tables of almost any size at compilation time by utilizing the&lt;code&gt;REDEFINES&lt;/code&gt;(see &lt;a href=&quot;#REDEFINES&quot;&gt;REDEFINES&lt;/a&gt;) clause:</source>
          <target state="translated">&lt;code&gt;REDEFINES&lt;/code&gt; ( &lt;a href=&quot;#REDEFINES&quot;&gt;REDEFINES&lt;/a&gt; 참조 ) 절 을 사용하여 컴파일 타임에 거의 모든 크기의 테이블을 초기화 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2fec9ecf2a45eb0fd0af8f70fdb0cee7e4377f3b" translate="yes" xml:space="preserve">
          <source>Inline PERFORM Syntax</source>
          <target state="translated">인라인 PERFORM 구문</target>
        </trans-unit>
        <trans-unit id="bc36d8128c5a1e8ca8d8c4f2854d174a361c1c90" translate="yes" xml:space="preserve">
          <source>Input fields may have any character used as a fill character. These fill characters provide a visual indication of the size of the input field, and will automatically be transformed into spaces when the input field is processed by the program. If no such character is defined for an input field, an underscore (&quot;_&quot;) will be assumed.</source>
          <target state="translated">입력 필드에는 채우기 문자로 사용되는 문자가있을 수 있습니다. 이 채우기 문자는 입력 필드의 크기를 시각적으로 표시하며 입력 필드가 프로그램에 의해 처리 될 때 공백으로 자동 변환됩니다. 입력 필드에 이러한 문자가 정의되어 있지 않으면 밑줄 ( &quot;_&quot;)이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="ec96e3ae34d38a6710e8a26303046f2131923ec8" translate="yes" xml:space="preserve">
          <source>Input fields may have any character used as a fill character. These fill characters provide a visual indication of the size of the input field, and will automatically be transformed into spaces when the input field is processed by the program. If no such character is defined for an input field, an underscore (&amp;lsquo;</source>
          <target state="translated">입력 필드에는 채우기 문자로 사용되는 모든 문자가있을 수 있습니다. 이러한 채우기 문자는 입력 필드의 크기를 시각적으로 표시하며 프로그램에서 입력 필드를 처리 할 때 자동으로 공백으로 변환됩니다. 입력 필드에 이러한 문자가 정의되지 않은 경우 밑줄 ( '</target>
        </trans-unit>
        <trans-unit id="33e5e7e82f76a11ddf2991effebf767de7f3deb5" translate="yes" xml:space="preserve">
          <source>Input validation</source>
          <target state="translated">입력 검증</target>
        </trans-unit>
        <trans-unit id="0f58e23445d1adbd9ab6441d745e78e9796ac8aa" translate="yes" xml:space="preserve">
          <source>Input will be read either from the console window (&lt;code&gt;CONSOLE&lt;/code&gt;) or from the system-standard input (pipe 0 = &lt;code&gt;STDIN&lt;/code&gt;, &lt;code&gt;SYSIN&lt;/code&gt; or &lt;code&gt;SYSIPT&lt;/code&gt;) and will be saved in &lt;var&gt;identifier-1&lt;/var&gt;.</source>
          <target state="translated">입력은 콘솔 창 ( &lt;code&gt;CONSOLE&lt;/code&gt; ) 또는 시스템 표준 입력 (파이프 0 = &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;SYSIN&lt;/code&gt; 또는 &lt;code&gt;SYSIPT&lt;/code&gt; )에서 읽고 &lt;var&gt;identifier-1&lt;/var&gt; 에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="d4fe42447823ec3b9e2e9421bf9fdef259cf35f1" translate="yes" xml:space="preserve">
          <source>Input will be read either from the console window &lt;code&gt;CONSOLE&lt;/code&gt; or from the system-standard input (pipe 0 =&lt;code&gt;STDIN&lt;/code&gt;&lt;code&gt;SYSIN&lt;/code&gt;or&lt;code&gt;SYSIPT&lt;/code&gt; and will be saved in &amp;lt;</source>
          <target state="translated">콘솔 창 &lt;code&gt;CONSOLE&lt;/code&gt; 또는 시스템 표준 입력 (파이프 0 = &lt;code&gt;STDIN&lt;/code&gt; &lt;code&gt;SYSIN&lt;/code&gt; 또는 &lt;code&gt;SYSIPT&lt;/code&gt; )에서 입력을 읽고 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="11b11dadbac78c35efb5d86e561bfcff60c6701b" translate="yes" xml:space="preserve">
          <source>Integer and non-integer operands may be freely intermixed</source>
          <target state="translated">정수와 비정 수 피연산자는 자유롭게 섞일 수 있습니다</target>
        </trans-unit>
        <trans-unit id="8626f5223c37139c00a44d21c18f768de6e8df20" translate="yes" xml:space="preserve">
          <source>Integers such as 1, 56, 2192 or -54.</source>
          <target state="translated">1, 56, 2192 또는 -54와 같은 정수</target>
        </trans-unit>
        <trans-unit id="d47bc2c05ec93f214d2f93848b03eba3a04ff0c4" translate="yes" xml:space="preserve">
          <source>Integrating well with non-COBOL infrastructures such as XML, SOA, MQ, almost any DBMS, Transaction Processing platforms, Queue-Management facilities and other programming languages.</source>
          <target state="translated">XML, SOA, MQ, 거의 모든 DBMS, 트랜잭션 처리 플랫폼, 큐 관리 기능 및 기타 프로그래밍 언어와 같은 비 COBOL 인프라와 잘 통합됩니다.</target>
        </trans-unit>
        <trans-unit id="8b3eb3d9c05dbc205b027a6d0771b0af833c1b89" translate="yes" xml:space="preserve">
          <source>Interactions between the program and the user will take place using the standard input, standard output and standard error streams. Any screen section I/O performed by the program will take place within the command shell &quot;window&quot;.</source>
          <target state="translated">프로그램과 사용자 간의 상호 작용은 표준 입력, 표준 출력 및 표준 오류 스트림을 사용하여 수행됩니다. 프로그램이 수행하는 모든 화면 섹션 I / O는 &quot;shell&quot;명령 셸 내에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a9a9b5bdf1a9e72af88d9b1c9aeeec1f68626f9e" translate="yes" xml:space="preserve">
          <source>Interactions between the program and the user will take place using the standard input, standard output and standard error streams. Any screen section I/O performed by the program will take place within the terminal window.</source>
          <target state="translated">프로그램과 사용자 간의 상호 작용은 표준 입력, 표준 출력 및 표준 오류 스트림을 사용하여 발생합니다. 프로그램에 의해 수행되는 모든 화면 섹션 I / O는 터미널 창 내에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4004bbedc882730cd7377c55c8a60c3d77d841f3" translate="yes" xml:space="preserve">
          <source>Intrinsic Function</source>
          <target state="translated">내장 함수</target>
        </trans-unit>
        <trans-unit id="79732e9fc9080596110feae301927876fc7259e7" translate="yes" xml:space="preserve">
          <source>Is a representation of the standard numeric time contained in &lt;var&gt;argument-2&lt;/var&gt; according to the format in &lt;var&gt;argument-1&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;argument-1&lt;/var&gt; 의 형식에 따라 &lt;var&gt;argument-2&lt;/var&gt; 에 포함 된 표준 숫자 시간의 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="e5ee413f8103631bd485cdfac46dfe6d0d5e3fd5" translate="yes" xml:space="preserve">
          <source>Is there a data item named &lt;code&gt;C-D&lt;/code&gt; defined? If so, use its value for the character sequence &lt;code&gt;C-D&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;C-D&lt;/code&gt; 라는 데이터 항목이 정의되어 있습니까? 그렇다면 해당 값을 문자 시퀀스 &lt;code&gt;C-D&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3afb87dd54b38fa7410a22ca94bf84568bc6f936" translate="yes" xml:space="preserve">
          <source>Is there a data item named&lt;code&gt;C-D&lt;/code&gt;defined? If so, use its value for the character sequence&lt;code&gt;C-D&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;C-D&lt;/code&gt; 라는 데이터 항목이 정의되어 있습니까? 그렇다면 문자 순서 &lt;code&gt;C-D&lt;/code&gt; 에 해당 값을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b2a3023db707fff296813396a984d683cabd59f0" translate="yes" xml:space="preserve">
          <source>It is also possible to create source files where GnuCOBOL programs are nested inside each other. Take for example these four GnuCOBOL programs:</source>
          <target state="translated">GnuCOBOL 프로그램이 서로 중첩 된 소스 파일을 만들 수도 있습니다. 다음 네 가지 GnuCOBOL 프로그램을 예로 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="84300e8f98a0f3852c30d9579e7c60614ed0dbd3" translate="yes" xml:space="preserve">
          <source>It is expected that:</source>
          <target state="translated">다음이 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="ca9e6f0f2e7f593201ed043e07c2e0d871facea5" translate="yes" xml:space="preserve">
          <source>It is possible to generate executable modules for all GnuCOBOL programs, not just subprograms, by choosing to use the</source>
          <target state="translated">서브 프로그램뿐만 아니라 모든 GnuCOBOL 프로그램에 대해 실행 가능한 모듈을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c528e93ea46610dc90b04c262c6d8a0c4d80f39" translate="yes" xml:space="preserve">
          <source>It is possible to generate executable modules for all GnuCOBOL programs, not just subprograms, by choosing to use the&lt;code&gt;-m&lt;/code&gt;switch</source>
          <target state="translated">&lt;code&gt;-m&lt;/code&gt; 스위치 를 사용하여 서브 프로그램뿐만 아니라 모든 GnuCOBOL 프로그램에 대해 실행 가능한 모듈을 생성 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e3e380ef206ba659e48d91cb175358e2449a8b4e" translate="yes" xml:space="preserve">
          <source>It is possible, however, to automatically cause all &lt;code&gt;COPY&lt;/code&gt; statements to &amp;ldquo;fold&amp;rdquo; the names of all copybooks to upper-case by specifying the</source>
          <target state="translated">그러나 다음을 지정하여 모든 &lt;code&gt;COPY&lt;/code&gt; 문이 모든 카피 북의 이름을 대문자 로 자동 &quot;접기&quot;하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b97faf48dcb0719b17e707ba50e23f3c431c6b2f" translate="yes" xml:space="preserve">
          <source>It is possible, however, to automatically cause all library names to &amp;rsquo;fold&amp;rsquo; to upper-case by specifying the</source>
          <target state="translated">그러나 다음을 지정하여 모든 라이브러리 이름이 대문자로 자동으로 '접 히게'할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd71df406ad79246a83a283db27a4507793dc703" translate="yes" xml:space="preserve">
          <source>It is possible, however, to automatically cause all library names to &amp;rsquo;fold&amp;rsquo; to upper-case by specifying the&lt;code&gt;-ffold-call&lt;/code&gt;switch</source>
          <target state="translated">그러나 &lt;code&gt;-ffold-call&lt;/code&gt; 스위치를 지정하여 모든 라이브러리 이름을 자동으로 대문자로 '폴드'할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f5ff5b5b0cc8eb3a5f026f5c68c2c34d3dd2e58" translate="yes" xml:space="preserve">
          <source>It is possible, however, to automatically cause all&lt;code&gt;COPY&lt;/code&gt;statements to &amp;rsquo;fold&amp;rsquo; the names of all copybooks to upper-case by specifying the&lt;code&gt;-ffold-copy&lt;/code&gt;switch</source>
          <target state="translated">그러나 &lt;code&gt;-ffold-copy&lt;/code&gt; 스위치를 지정하여 모든 &lt;code&gt;COPY&lt;/code&gt; 문 이 자동으로 모든 카피 북의 이름을 대문자로 '폴딩'하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fd4db1874deb79d1734c24cfc068bf9dfa3c2af" translate="yes" xml:space="preserve">
          <source>It is possible, if supported by the</source>
          <target state="translated">지원하는 경우 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8d95a0b3b4408000436885116c035d2b4d4eb090" translate="yes" xml:space="preserve">
          <source>It is possible, if supported by the &quot;curses&quot; package being used, to draw borders on the top, left and/or bottom edges of a field.</source>
          <target state="translated">사용중인 &quot;저주&quot;패키지가 지원하는 경우 필드의 위쪽, 왼쪽 및 / 또는 아래쪽 가장자리에 테두리를 그릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d7394694e1e1adbaef5eeee92d5a9373e538bc3" translate="yes" xml:space="preserve">
          <source>It is recommended to change the CBL_OC routines to CBL_GC for forward compatability as at some point they will be removed as they are a hangover from Open Cobol.</source>
          <target state="translated">순방향 호환성을 위해 CBL_OC 루틴을 CBL_GC로 변경하여 Open Cobol에서 숙취가되어 언젠가는 제거 될 것을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="061e684ce444da672f8f250f9c15f353e99d24e9" translate="yes" xml:space="preserve">
          <source>It is recommended to change the CBL_OC routines to CBL_GC for forward compatibility as at some point they will be removed as they are a hangover from Open Cobol.</source>
          <target state="translated">CBL_OC 루틴을 CBL_GC로 변경하는 것이 좋습니다. 언젠가는 Open Cobol의 숙취로 인해 제거되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="4bc4bb06183a156efac27d1054572b8c27c65421" translate="yes" xml:space="preserve">
          <source>It is worth mentioning that if the</source>
          <target state="translated">언급하면 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7246d8ea302a84c950724aa56d84b52fff1c6e02" translate="yes" xml:space="preserve">
          <source>It returns 0 when match, 1 on failure, case matters as does length, &quot;arg&quot; won&amp;rsquo;t match.</source>
          <target state="translated">일치하면 0을, 실패하면 1을 반환합니다. 대소 문자는 길이와 마찬가지로 중요하며 &quot;arg&quot;는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18a80c8fa72d80aad7d81f986d63eacc53ab4b98" translate="yes" xml:space="preserve">
          <source>It would appear that it should be possible to locate and process any record in the file directly simply by calculating its starting character position based upon the program-defined record size. Even so, however, records must be still be read or written to these files in a purely sequential manner. The only way to read (or write) record number 100 would be to have read (or written) records number 1 through 99 first.</source>
          <target state="translated">프로그램 정의 레코드 크기에 따라 시작 문자 위치를 계산하여 파일에서 레코드를 직접 찾아서 처리 할 수 ​​있어야합니다. 그러나 그럼에도 불구하고 레코드는 순차 순차 방식으로 이러한 파일을 읽거나 기록해야합니다. 레코드 번호 100을 읽거나 쓰는 유일한 방법은 레코드 번호 1-99를 먼저 읽거나 쓰는 것입니다.</target>
        </trans-unit>
        <trans-unit id="70dcde551f3b6956e677f96a1f00fa175867fa96" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s impossible to perform any arithmetic operation against an index data item directly (other than a simple incrementation or decremental operation via the &lt;code&gt;SET UP/DOWN&lt;/code&gt; statement (see &lt;a href=&quot;#SET-UP_002fDOWN&quot;&gt;SET UP/DOWN&lt;/a&gt;)). Situations where any non-trivial computations are required to calculate the effective occurrence number for a table reference will require you to use a conventional unedited numeric data item as the receiving field for the calculation. That calculated value would then need to be saved into the index data item via a &lt;code&gt;SET Index&lt;/code&gt; statement.</source>
          <target state="translated">인덱스 데이터 항목에 대해 직접 산술 연산을 수행하는 것은 불가능합니다 ( &lt;code&gt;SET UP/DOWN&lt;/code&gt; 문을 통한 단순 증가 또는 감소 연산 제외 ( &lt;a href=&quot;#SET-UP_002fDOWN&quot;&gt;SET UP / DOWN&lt;/a&gt; 참조 )). 테이블 참조에 대한 유효 발생 수를 계산하기 위해 사소하지 않은 계산이 필요한 상황에서는 계산을위한 수신 필드로 기존의 편집되지 않은 숫자 데이터 항목을 사용해야합니다. 계산 된 값은 &lt;code&gt;SET Index&lt;/code&gt; 문을 통해 인덱스 데이터 항목에 저장되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="6d1a9ad994fd74f3ea9c0abfcfff5c67eb069908" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s impossible to perform any arithmetic operation against an index data item directly (other than a simple incrementation or decremental operation via the&lt;code&gt;SET UP/DOWN&lt;/code&gt;statement (see &lt;a href=&quot;#SET-UP_002fDOWN&quot;&gt;SET UP/DOWN&lt;/a&gt;)). Situations where any non-trivial computations are required to calculate the effective occurrence number for a table reference will require you to use a conventional unedited numeric data item as the receiving field for the calculation. That calculated value would then need to be saved into the index data item via a&lt;code&gt;SET Index&lt;/code&gt;statement.</source>
          <target state="translated">인덱스 데이터 항목에 대해 직접 산술 연산을 수행하는 것은 불가능합니다 ( &lt;code&gt;SET UP/DOWN&lt;/code&gt; 문을 통한 간단한 증분 또는 감산 연산 제외) ( &lt;a href=&quot;#SET-UP_002fDOWN&quot;&gt;SET UP / DOWN&lt;/a&gt; 참조). 테이블 참조의 유효 발생 수를 계산하기 위해 사소한 계산이 필요한 상황에서는 일반 편집되지 않은 숫자 데이터 항목을 계산의 수신 필드로 사용해야합니다. 그런 다음 계산 된 값을 &lt;code&gt;SET Index&lt;/code&gt; 문을 통해 인덱스 데이터 항목에 저장해야 합니다.</target>
        </trans-unit>
        <trans-unit id="48149098c4b72f980cb6ef484a18559b6952ecbd" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s probably a true that an IT professional can no longer afford to allow COBOL to be the</source>
          <target state="translated">IT 전문가가 더 이상 COBOL을</target>
        </trans-unit>
        <trans-unit id="02387685edacc74ddafb8999ab4d02ea233cee8c" translate="yes" xml:space="preserve">
          <source>Items appearing in Mixed Case within a syntax diagram represent complex clauses of other syntax elements that may appear in that position. Some COBOL syntax gets quite complicated, and using a convention such as this significantly reduces the complexity of a syntax diagram. When such items are referenced in text, they will appear as &amp;lt;&amp;lt;</source>
          <target state="translated">구문 다이어그램에서 대소 문자 혼합으로 나타나는 항목은 해당 위치에 나타날 수있는 다른 구문 요소의 복잡한 절을 나타냅니다. 일부 COBOL 구문은 상당히 복잡해지며 이와 같은 규칙을 사용하면 구문 다이어그램의 복잡성이 크게 줄어 듭니다. 이러한 항목이 텍스트로 참조되면 &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="4c435dc1bbde5c2dacc928889559b530821b3122" translate="yes" xml:space="preserve">
          <source>Items appearing in Mixed Case within a syntax diagram represent complex clauses of other syntax elements that may appear in that position. Some COBOL syntax gets quite complicated, and using a convention such as this significantly reduces the complexity of a syntax diagram. When such items are referenced in text, they will appear as &lt;var&gt;Complex-Syntax-Clause&lt;/var&gt;.</source>
          <target state="translated">구문 다이어그램에서 대소 문자가 혼합 된 항목은 해당 위치에 나타날 수있는 다른 구문 요소의 복잡한 절을 나타냅니다. 일부 COBOL 구문은 매우 복잡해지며 이와 같은 규칙을 사용하면 구문 다이어그램의 복잡성이 크게 줄어 듭니다. 이러한 항목이 텍스트에서 참조되면 &lt;var&gt;Complex-Syntax-Clause&lt;/var&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="56625773bdd51fd820fa786a2e0f16b75e88d894" translate="yes" xml:space="preserve">
          <source>JUST, JUSTIFIED</source>
          <target state="translated">그냥 정당화</target>
        </trans-unit>
        <trans-unit id="362a2940964523b043977ef5c326c0da3c417c71" translate="yes" xml:space="preserve">
          <source>JUSTIFIED Attribute Syntax</source>
          <target state="translated">정당한 속성 구문</target>
        </trans-unit>
        <trans-unit id="90e0e514b7cbaade00f2505567f728c431ef2c8f" translate="yes" xml:space="preserve">
          <source>JUSTIFIED, JUST</source>
          <target state="translated">정당화, 정당화</target>
        </trans-unit>
        <trans-unit id="5722133c7e6a0b8bbf45b32c72de74b6bc64c397" translate="yes" xml:space="preserve">
          <source>Just as multiplication takes precedence over addition in arithmetic expressions, so does &lt;code&gt;AND&lt;/code&gt; take precedence over &lt;code&gt;OR&lt;/code&gt; in combined conditions. Use parenthesis to change this precedence, if necessary. For example:</source>
          <target state="translated">곱셈이 산술 표현식에서 더하기보다 우선하는 것처럼 &lt;code&gt;AND&lt;/code&gt; 도 결합 된 조건에서 &lt;code&gt;OR&lt;/code&gt; 보다 우선 합니다. 필요한 경우 괄호를 사용하여이 우선 순위를 변경합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="69d7203c7ddac97c0f7dbb23cc2fe036c4f8c92f" translate="yes" xml:space="preserve">
          <source>Just as multiplication takes precedence over addition in arithmetic expressions, so does&lt;code&gt;AND&lt;/code&gt;take precedence over&lt;code&gt;OR&lt;/code&gt;in combined conditions. Use parenthesis to change this precedence, if necessary. For example:</source>
          <target state="translated">산술 연산 식에서 곱셈이 덧셈보다 우선하고, 결합 된 조건에서 &lt;code&gt;AND&lt;/code&gt; 가 &lt;code&gt;OR&lt;/code&gt; 보다 우선 합니다. 필요한 경우 괄호를 사용하여이 우선 순위를 변경하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d13eab767d2368877889bd7045a0a16db421d69" translate="yes" xml:space="preserve">
          <source>Just because COBOL doesn&amp;rsquo;t traditionally support objects, classes, and the like doesn&amp;rsquo;t mean that its &quot;procedural&quot; approach to computing isn&amp;rsquo;t valuable &amp;mdash; after all, it runs 70% of the</source>
          <target state="translated">COBOL이 전통적으로 객체, 클래스 등을 지원하지 않는다고해서 컴퓨팅에 대한 &quot;절차&quot;접근 방식이 중요하지 않다는 것을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8c01857f89a36261130d305fde5b5812e5298f0" translate="yes" xml:space="preserve">
          <source>Just because COBOL doesn&amp;rsquo;t traditionally support objects, classes, and the like doesn&amp;rsquo;t mean that its &amp;ldquo;procedural&amp;rdquo; approach to computing isn&amp;rsquo;t valuable &amp;mdash; after all, it runs 70% of the</source>
          <target state="translated">COBOL이 전통적으로 객체, 클래스 등을 지원하지 않는다고해서 컴퓨팅에 대한 &quot;절차 적&quot;접근 방식이 가치가 없음을 의미하지는 않습니다. 결국 COBOL은</target>
        </trans-unit>
        <trans-unit id="979a2652877865746b7247ec58a121d845b88ba1" translate="yes" xml:space="preserve">
          <source>Just because the table has one or more &lt;code&gt;KEY&lt;/code&gt; clauses doesn&amp;rsquo;t mean the data is actually</source>
          <target state="translated">테이블에 하나 이상의 &lt;code&gt;KEY&lt;/code&gt; 절이 있다고 해서 데이터가 실제로</target>
        </trans-unit>
        <trans-unit id="eab1ffaceb7e528d02f388bc4a44de1ac999f956" translate="yes" xml:space="preserve">
          <source>Just because the table has one or more&lt;code&gt;KEY&lt;/code&gt;clauses doesn&amp;rsquo;t mean the data is actually</source>
          <target state="translated">테이블에 하나 이상의 &lt;code&gt;KEY&lt;/code&gt; 절이 있다고 해서 데이터가 실제로는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5b5d12ea2ea365ae4f8ff7a7d00d39c0f6a22117" translate="yes" xml:space="preserve">
          <source>Justification (left, right or centred) of a string field</source>
          <target state="translated">문자열 필드의 양쪽 맞춤 (왼쪽, 오른쪽 또는 가운데)</target>
        </trans-unit>
        <trans-unit id="c2d43141ba675c34b7c1d27c2a20a48306114ad6" translate="yes" xml:space="preserve">
          <source>Justifying a field left-, right- or center-aligned</source>
          <target state="translated">필드를 왼쪽, 오른쪽 또는 가운데로 정렬</target>
        </trans-unit>
        <trans-unit id="84f38d3f20c7775e2217cde20dd53b4fca4c4de9" translate="yes" xml:space="preserve">
          <source>KEPT, KEY, KEYBOARD</source>
          <target state="translated">KEPT, KEY, KEYBOARD</target>
        </trans-unit>
        <trans-unit id="dff84808f4a83b06a0b8dc389f4ca84fd6e483a3" translate="yes" xml:space="preserve">
          <source>Key already exists</source>
          <target state="translated">키가 이미 있습니다.</target>
        </trans-unit>
        <trans-unit id="92bd34b75e6ff630359dc24ce994bebb8b03c58a" translate="yes" xml:space="preserve">
          <source>Key boundary violation</source>
          <target state="translated">주요 경계 위반</target>
        </trans-unit>
        <trans-unit id="a1abb8bae6a20d6d2a3d297fadb85dbb06f153f7" translate="yes" xml:space="preserve">
          <source>Key invalid</source>
          <target state="translated">키가 잘못되었습니다</target>
        </trans-unit>
        <trans-unit id="0dca24f2a9944795f9d4824194f21fc80ddaa094" translate="yes" xml:space="preserve">
          <source>Key not found</source>
          <target state="translated">키를 찾을 수 없습니다</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="6114979f0d6bbe96ece7032f3f733bd6eddb23b0" translate="yes" xml:space="preserve">
          <source>LABEL-OFFSET, LABEL, LARGE-FONT, LARGE-OFFSET, LAST-ROW, LAST, LAYOUT-DATA, LAYOUT-MANAGER, LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES, LC_MONETARY, LC_NUMERIC, LC_TIME, LEADING-SHIFT, LEADING, LEFT-JUSTIFY, LEFTLINE, LEFT-TEXT, LEFT, LENGTH-AN, LENGTH-CHECK, LENGTH, LESS, LIMITS, LIMIT, LINAGE-COUNTER, LINAGE, LINE-COUNTER, LINES-AT-ROOT, LINE-SEQUENTIAL, LINES, LINE, LINKAGE, LIST-BOX, LM-RESIZE, LOCALE-COMPARE, LOCALE-DATE, LOCALE-TIME-FROM-SECONDS, LOCALE-TIME, LOCALE, LOCAL-STORAGE, LOCK, LOG10, LOG, LONG-DATE, LOW-COLOR, LOWER-CASE, LOWERED, LOWER, LOWEST-ALGEBRAIC, LOWLIGHT, LOW-VALUES, LOW-VALUE</source>
          <target state="translated">LABEL-OFFSET, LABEL, LARGE-FONT, LARGE-OFFSET, LAST-ROW, LAST, LAYOUT-DATA, LAYOUT-MANAGER, LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES, LC_MONETARY, LC_NUMERIC, LC_TIME, LEADING-SHIFT, LEADING, LEFT- JUSTIFY, LEFTLINE, LEFT-TEXT, LEFT, LENGTH-AN, LENGTH-CHECK, LENGTH, LESS, LIMITS, LIMIT, LINAGE-COUNTER, LINAGE, LINE-COUNTER, LINES-AT-ROOT, LINE-SEQUENTIAL, LINES, LINE, LINKAGE, LIST-BOX, LM-RESIZE, LOCALE-COMPARE, LOCALE-DATE, LOCALE-TIME-FROM-SECONDS, LOCALE-TIME, LOCALE, LOCAL-STORAGE, LOCK, LOG10, LOG, LONG-DATE, LOW-COLOR, LOWER-CASE, LOWERED, LOWER, LOWEST-ALGEBRAIC, LOWLIGHT, LOW-VALUES, LOW-VALUE</target>
        </trans-unit>
        <trans-unit id="b27d585a06f48010c011f378dec6cda9ce6fe385" translate="yes" xml:space="preserve">
          <source>LABEL. LAST, LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES, LC_MONETARY, LC_NUMERIC, LC_TIME, LEADING, LEFT, LEFT-JUSTIFY, LEFTLINE, LENGTH, LENGTH-AN, LENGTH-CHECK, LESS, LIMIT, LIMITS, LINAGE, LINAGE-COUNTER, LINE, LINE-COUNTER, LINES, LINKAGE, LOCALE, LOCALE-COMPARE, LOCALE-DATE, LOCALE-TIME, LOCALE-TIME-FROM-SECONDS, LOCAL-STORAGE, LOCK, LOG, LOG10, LOWER, LOWER-CASE, LOWEST-ALGEBRAIC, LOWLIGHT, LOW-VALUE, LOW-VALUES</source>
          <target state="translated">상표. LAST, LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES, LC_MONETARY, LC_NUMERIC, LC_TIME, LEADING, LEFT, LEFT-JUSTIFY, LEFTLINE, LENGTH, LENGTH-AN, LENGTH-CHECK, LESS, LIMIT, LIMITS, LINAGE, LINEAGE 라인 카운터, 라인, 링키지, 로케일, 로케일 비교, 로케일-날짜, 로케일-시간, 로케일-시간 -ROM- 초, 로칼-스토리지, 잠금, 로그, LOG10, 로어, 로어-케이스, 최저-대수, LOWLIGHT, LOW-VALUE, LOW-VALUES</target>
        </trans-unit>
        <trans-unit id="f7adab25c99ba32828c8334645ed0e592317c0dd" translate="yes" xml:space="preserve">
          <source>LEFTLINE Attribute Syntax</source>
          <target state="translated">LEFTLINE 속성 구문</target>
        </trans-unit>
        <trans-unit id="131342f51da66f70ac3d8ad3a42ad6266e7cfe09" translate="yes" xml:space="preserve">
          <source>LENGTH Function Syntax</source>
          <target state="translated">LENGTH 함수 구문</target>
        </trans-unit>
        <trans-unit id="d74d405b72ac688357a94ddb91f3bd1d36b38a48" translate="yes" xml:space="preserve">
          <source>LENGTH OF Syntax</source>
          <target state="translated">구문의 길이</target>
        </trans-unit>
        <trans-unit id="a6c3bbbb104612f77a62807c2c1de5109220484e" translate="yes" xml:space="preserve">
          <source>LENGTH-AN Function Syntax</source>
          <target state="translated">LENGTH-AN 함수 구문</target>
        </trans-unit>
        <trans-unit id="954f779688b59664bc2c0157a1a346f68764ce28" translate="yes" xml:space="preserve">
          <source>LENGTH-CHECK Attribute Syntax</source>
          <target state="translated">길이 검사 속성 구문</target>
        </trans-unit>
        <trans-unit id="f4069c469e237582353fbcc1ca054bde5eb25517" translate="yes" xml:space="preserve">
          <source>LINAGE IS n LINES</source>
          <target state="translated">LINAGE는 n 개의 라인입니다</target>
        </trans-unit>
        <trans-unit id="700c1989f8b190ed7e6537ef207d774a560d050f" translate="yes" xml:space="preserve">
          <source>LINE (REPORT SECTION) Clause Syntax</source>
          <target state="translated">LINE (보고서 섹션) 조항 구문</target>
        </trans-unit>
        <trans-unit id="e8f4389c48575a281e9f925b390e924cf0c4233d" translate="yes" xml:space="preserve">
          <source>LINE (SCREEN SECTION) Clause Syntax</source>
          <target state="translated">LINE (스크린 섹션) 조항 구문</target>
        </trans-unit>
        <trans-unit id="7c6e6d7676fc26598c1022695002f33ef9cb1a7f" translate="yes" xml:space="preserve">
          <source>LINES AT BOTTOM</source>
          <target state="translated">하단 라인</target>
        </trans-unit>
        <trans-unit id="2bb17bd344a3058733c23cfa10c4a15543c5a7a0" translate="yes" xml:space="preserve">
          <source>LINES AT TOP</source>
          <target state="translated">상단 라인</target>
        </trans-unit>
        <trans-unit id="e4f2ff384d74fc8578647b7045a783150209d9b6" translate="yes" xml:space="preserve">
          <source>LINKAGE-SECTION-Data-Item</source>
          <target state="translated">LINKAGE-SECTION-Data-Item</target>
        </trans-unit>
        <trans-unit id="6c615d91fc665579223c013c286410416b6e1014" translate="yes" xml:space="preserve">
          <source>LINKAGE-SECTION-Data-Item Syntax</source>
          <target state="translated">연결 섹션 데이터 항목 구문</target>
        </trans-unit>
        <trans-unit id="de80fa7cc22fe7bc720ec1f880b19a375e416fad" translate="yes" xml:space="preserve">
          <source>LOCAL-STORAGE-SECTION-Data-Item</source>
          <target state="translated">LOCAL-STORAGE-SECTION-Data-Item</target>
        </trans-unit>
        <trans-unit id="7aaab284fb19784decbd8f8b27788cee676e6312" translate="yes" xml:space="preserve">
          <source>LOCAL-STORAGE-SECTION-Data-Item Syntax</source>
          <target state="translated">로컬 스토리지 섹션 데이터 항목 구문</target>
        </trans-unit>
        <trans-unit id="43137ffee30418f0ee2f9cddfdfde852be8ee37f" translate="yes" xml:space="preserve">
          <source>LOCALE-COMPARE Function Syntax</source>
          <target state="translated">LOCALE-COMPARE 함수 구문</target>
        </trans-unit>
        <trans-unit id="b1fca96794478203376fc5f182a5206a1cd9879a" translate="yes" xml:space="preserve">
          <source>LOCALE-DATE Function Syntax</source>
          <target state="translated">LOCALE-DATE 함수 구문</target>
        </trans-unit>
        <trans-unit id="bb3ee280b5397e14e50725a5217c3a5d3ba477ce" translate="yes" xml:space="preserve">
          <source>LOCALE-TIME Function Syntax</source>
          <target state="translated">LOCALE-TIME 함수 구문</target>
        </trans-unit>
        <trans-unit id="5471c4a61062a5428ab007db0990af8c067fcb5d" translate="yes" xml:space="preserve">
          <source>LOCALE-TIME-FROM-SECONDS Function Syntax</source>
          <target state="translated">LOCALE-TIME-FROM-SECONDS 함수 구문</target>
        </trans-unit>
        <trans-unit id="37c5bf8af77ce9710567f4d33ea9e7df839040cc" translate="yes" xml:space="preserve">
          <source>LOG Function Syntax</source>
          <target state="translated">LOG 함수 구문</target>
        </trans-unit>
        <trans-unit id="9192c8decf1f9c720375df3f6fa03e112ff20e88" translate="yes" xml:space="preserve">
          <source>LOG10 Function Syntax</source>
          <target state="translated">LOG10 함수 구문</target>
        </trans-unit>
        <trans-unit id="ee7e6e2ad53ef8f056736d307514898fdd404c69" translate="yes" xml:space="preserve">
          <source>LOWER-CASE Function Syntax</source>
          <target state="translated">LOWER-CASE 함수 구문</target>
        </trans-unit>
        <trans-unit id="439e85988349d2d4d56bcd162fc79031cbfe5293" translate="yes" xml:space="preserve">
          <source>LOWEST-ALGEBRAIC Function Syntax</source>
          <target state="translated">최저 대수 함수 구문</target>
        </trans-unit>
        <trans-unit id="a8456caa490bee9c2c0be989a83696a4f186cc13" translate="yes" xml:space="preserve">
          <source>LOWLIGHT Attribute Syntax</source>
          <target state="translated">LOWLIGHT 속성 구문</target>
        </trans-unit>
        <trans-unit id="ab9f0a91ded19b860a0bb2aa383c74029ea96c55" translate="yes" xml:space="preserve">
          <source>Language &lt;code&gt;DIVISION&lt;/code&gt;, &lt;code&gt;SECTION&lt;/code&gt; and paragraph section headers must b egin in Area A, as must the level numbers 01, 77 in data description entries and the &lt;code&gt;FD&lt;/code&gt; and &lt;code&gt;SD&lt;/code&gt; file and &lt;code&gt;SORT&lt;/code&gt; description headers.</source>
          <target state="translated">언어 &lt;code&gt;DIVISION&lt;/code&gt; , &lt;code&gt;SECTION&lt;/code&gt; 및 단락 섹션 헤더는 데이터 설명 항목과 &lt;code&gt;FD&lt;/code&gt; 및 &lt;code&gt;SD&lt;/code&gt; 파일 및 &lt;code&gt;SORT&lt;/code&gt; 설명 헤더 의 레벨 번호 01, 77과 마찬가지로 영역 A에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b77f5ed95a31f852095a500e8931cb13a5b9471b" translate="yes" xml:space="preserve">
          <source>Language DIVISION, SECTION and paragraph section headers must begin in Area A, as must the level numbers 01, 77 in data description entries and the &quot;FD&quot; and &quot;SD&quot; file and SORT description headers.</source>
          <target state="translated">언어 DIVISION, SECTION 및 단락 섹션 헤더는 영역 A에서 시작해야하며 데이터 설명 항목의 레벨 번호 01, 77, &quot;FD&quot;및 &quot;SD&quot;파일 및 SORT 설명 헤더와 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="1882dc6a1967f34bbac58b9f9a979e4a9b63398b" translate="yes" xml:space="preserve">
          <source>Later, when you wish to compile a calling program and combine any needed assembly language subroutines in (as static subroutines &amp;mdash; see &lt;a href=&quot;#Dynamic-vs-Static-Subprograms&quot;&gt;Dynamic vs Static Subprograms&lt;/a&gt;), use a command such as this:</source>
          <target state="translated">나중에 호출 프로그램을 컴파일하고 필요한 어셈블리 언어 서브 루틴을 (정적 서브 루틴- &lt;a href=&quot;#Dynamic-vs-Static-Subprograms&quot;&gt;동적 vs 정적 서브 프로그램&lt;/a&gt; 참조 ) 결합하려면 다음과 같은 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="66985c4b56238cdffd3d626011e0ae9656911e65" translate="yes" xml:space="preserve">
          <source>Leading and/or trailing spaces are allowed, as are spaces before and/or after any sign characters.</source>
          <target state="translated">선행 및 / 또는 후행 공백은 부호 문자 앞뒤 및 공백과 같이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="0ff8a66126e2608d00693ba8dd0efcf5b6c8473c" translate="yes" xml:space="preserve">
          <source>Leading and/or trailing spaces are allowed, as are spaces before and/or after the currency symbol, sign, CR and DB characters.</source>
          <target state="translated">통화 기호, 부호, CR 및 DB 문자 앞뒤에 공백과 마찬가지로 선행 및 / 또는 후행 공백이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="13235fcc87f3e6e8669414dd697a803db485fc34" translate="yes" xml:space="preserve">
          <source>Leading and/or trailing spaces are allowed, as are spaces before and/or after the sign, CR and DB characters.</source>
          <target state="translated">선행 및 / 또는 후행 공백이 허용되며 부호 앞뒤의 공백, CR 및 DB 문자가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d8c6e1dcd78cbde53dbfb5d9de88b738224cdda7" translate="yes" xml:space="preserve">
          <source>Leading and/or trailing spaces are allowed, as are spaces before the first digit.</source>
          <target state="translated">첫 번째 숫자 앞의 공백과 마찬가지로 선행 및 / 또는 후행 공백이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="4a73716efd725dd69ed96a4ea0bb80f513d3861e" translate="yes" xml:space="preserve">
          <source>Left Dbl Click</source>
          <target state="translated">왼쪽 더블 클릭</target>
        </trans-unit>
        <trans-unit id="88fb5a06f570b6e81cc3331af90bb5ea437de3f2" translate="yes" xml:space="preserve">
          <source>Left Pressed</source>
          <target state="translated">왼쪽 누름</target>
        </trans-unit>
        <trans-unit id="cd690f11442f85e3110b4a63bf12f94127c762cc" translate="yes" xml:space="preserve">
          <source>Left Released</source>
          <target state="translated">왼쪽 릴리스</target>
        </trans-unit>
        <trans-unit id="6d1192545a490f725efd7534bb1ad77133927978" translate="yes" xml:space="preserve">
          <source>Legend has it that there&amp;rsquo;s actually only been ONE program ever written in COBOL, and all programs ever &quot;written&quot; thereafter were simply derivatives of that one. Although this is clearly intended as a (probably) bad joke, it is nevertheless close to the very simple truth that many programmers&quot;reuse&quot; existing COBOL programs when creating new ones. There&amp;rsquo;s certainly nothing preventing this from happening with programs written in other languages, but it does seem to happen more in COBOL shops. It&amp;rsquo;s ironic that &quot;code re-usability&quot; is one of the arguments used to justify the existence of the &quot;modern&quot; languages.</source>
          <target state="translated">범례에 따르면 실제로 COBOL로 작성된 프로그램은 하나 뿐이며 이후 &quot;작성된&quot;모든 프로그램은 단순히 그 프로그램의 파생물이었습니다. 비록 이것이 아마도 나쁜 농담으로 의도되었지만, 많은 프로그래머들이 새로운 코볼 프로그램을 만들 때 기존의 COBOL 프로그램을 &quot;재사용&quot;한다는 것은 매우 단순한 사실에 가깝습니다. 다른 언어로 작성된 프로그램에서 이런 일이 발생하는 것을 막을 수는 없지만 COBOL 상점에서는 더 많이 발생하는 것 같습니다. &quot;코드 재사용 성&quot;이 &quot;현대&quot;언어의 존재를 정당화하는 데 사용되는 주장 중 하나라는 것은 아이러니 한 일입니다.</target>
        </trans-unit>
        <trans-unit id="9c975edbd71a157d47b1d648200e63954dd79c0f" translate="yes" xml:space="preserve">
          <source>Legend has it that there&amp;rsquo;s actually only been ONE program ever written in COBOL, and all programs ever &amp;ldquo;written&amp;rdquo; thereafter were simply derivatives of that one. Although this is clearly intended as a (probably) bad joke, it is nevertheless close to the very simple truth that many programmers&amp;ldquo;reuse&amp;rdquo; existing COBOL programs when creating new ones. There&amp;rsquo;s certainly nothing preventing this from happening with programs written in other languages, but it does seem to happen more in COBOL shops. It&amp;rsquo;s ironic that &amp;ldquo;code re-usability&amp;rdquo; is one of the arguments used to justify the existence of the &amp;ldquo;modern&amp;rdquo; languages.</source>
          <target state="translated">전설에 따르면 실제로 COBOL로 작성된 프로그램은 단 하나 뿐이며 이후에 &quot;작성&quot;된 모든 프로그램은 단순히 그 프로그램의 파생물입니다. 이것은 분명히 (아마도) 나쁜 농담으로 의도되었지만, 그럼에도 불구하고 많은 프로그래머가 새 프로그램을 만들 때 기존 COBOL 프로그램을 &quot;재사용&quot;한다는 것은 매우 단순한 진실에 가깝습니다. 확실히 다른 언어로 작성된 프로그램에서 이런 일이 발생하는 것을 막을 수는 없지만 COBOL 상점에서 더 많이 발생하는 것 같습니다. &quot;코드 재사용 성&quot;이 &quot;현대&quot;언어의 존재를 정당화하는 데 사용되는 주장 중 하나라는 것은 아이러니합니다.</target>
        </trans-unit>
        <trans-unit id="0b3fb64877d0da3cc80aa54b2402a8b8eaf24bde" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a different problem. Surely a program that asks a user to input a positive integer, generates the sum of all positive integers from 1 to that number and then prints the result will be MUCH shorter and MUCH easier to understand when coded in Java than in COBOL, right?</source>
          <target state="translated">다른 문제를 봅시다. 분명히 사용자에게 양의 정수를 입력하도록 요청하고 1에서 그 숫자까지의 모든 양의 정수의 합을 생성 한 다음 결과를 인쇄하면 COBOL보다 Java로 코딩 할 때 이해하기가 훨씬 짧아지고 이해하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="26e5808de92654f265239c37c8e3bd7a273163fd" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at how much more &quot;wordy&quot; COBOL is than Java. Count the characters in the two programs. The Java program has 95 (not counting carriage returns and any indentation). The COBOL program has 89 (again, not counting carriage returns and indentation)! Technically, it could have been only 65 because the&lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt;header is actually optional. Clearly, &quot;Hello World&quot; doesn&amp;rsquo;t look any more concise in Java than it does in COBOL.</source>
          <target state="translated">Java보다 얼마나 &quot;협잡 한&quot;COBOL이 있는지 살펴 보자. 두 프로그램에서 문자를 세십시오. Java 프로그램에는 95가 있습니다 (캐리지 리턴 및 들여 쓰기 제외). COBOL 프로그램에는 89가 있습니다 (캐리지 리턴 및 들여 쓰기를 세지 않음)! 기술적으로, &lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt; 인해 65 세에 불과했습니다 . 헤더는 실제로 선택 사항입니다. 분명히 &quot;Hello World&quot;는 COBOL보다 Java에서 더 간결하게 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fce67368220fd5d1a069d467b1d821a9f6cc0caf" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at how much more &amp;ldquo;wordy&amp;rdquo; COBOL is than Java. Count the characters in the two programs. The Java program has 95 (not counting carriage returns and any indentation). The COBOL program has 89 (again, not counting carriage returns and indentation)! Technically, it could have been only 65 because the &lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt; header is actually optional. Clearly, &amp;ldquo;Hello World&amp;rdquo; doesn&amp;rsquo;t look any more concise in Java than it does in COBOL.</source>
          <target state="translated">Java보다 &quot;단단한&quot;COBOL이 얼마나 더 많은지 살펴 보겠습니다. 두 프로그램의 문자를 센다. Java 프로그램에는 95가 있습니다 (캐리지 리턴 및 들여 쓰기 제외). COBOL 프로그램에는 89 개가 있습니다 (다시 말하지만 캐리지 리턴 및 들여 쓰기를 계산하지 않음)! 기술적으로는 &lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt; 이기 때문에 65 세가 될 수 있습니다 . 헤더는 실제로 선택 사항입니다. 분명히 &quot;Hello World&quot;는 Java에서 COBOL보다 더 간결 해 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="963bbbacb61f8751db91170e221a486a9a4d3b42" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say the 3x4 &quot;grid&quot; defined by the above structure has these values:</source>
          <target state="translated">위의 구조로 정의 된 3x4 &quot;그리드&quot;에 다음 값이 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="5974d6c322da30f80987e1170616d04027e9daef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say the 3x4 &amp;ldquo;grid&amp;rdquo; defined by the above structure has these values:</source>
          <target state="translated">위 구조로 정의 된 3x4 &quot;그리드&quot;에 다음 값이 있다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="5f6c75fa3581f1fe3d845277eaa7b25f5ef95342" translate="yes" xml:space="preserve">
          <source>Level 1 (Highest) &amp;mdash; Unary Sign Specification (&lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt; with a single argument)</source>
          <target state="translated">레벨 1 (가장 높음) &amp;mdash; 단항 부호 지정 ( &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;-&lt;/code&gt; 단일 인수 포함)</target>
        </trans-unit>
        <trans-unit id="807ef358de181fc6f5a56bc69f36677531a8d93e" translate="yes" xml:space="preserve">
          <source>Level 1 (Highest) &amp;mdash; Unary Sign Specification &lt;code&gt;+&lt;/code&gt;and&lt;code&gt;-&lt;/code&gt;with a single argument)</source>
          <target state="translated">수준 1 (가장 높음) &amp;mdash; 단항 부호 사양 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;-&lt;/code&gt; 단일 인수 사용)</target>
        </trans-unit>
        <trans-unit id="c1fb74ac0d874a2011af4ed300de85b0a379c044" translate="yes" xml:space="preserve">
          <source>Level 2 &amp;mdash; Exponentiation (&lt;code&gt;**&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt;)</source>
          <target state="translated">수준 2 &amp;mdash; 지수 ( &lt;code&gt;**&lt;/code&gt; 또는 &lt;code&gt;^&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c0776e45f0a30777bc589139ec70ff962e33c83c" translate="yes" xml:space="preserve">
          <source>Level 2 &amp;mdash; Exponentiation &lt;code&gt;**&lt;/code&gt;or&lt;code&gt;^&lt;/code&gt;</source>
          <target state="translated">수준 2 &amp;mdash; 지수 &lt;code&gt;**&lt;/code&gt; 또는 &lt;code&gt;^&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19f33b8f84b6acbf527317823b1dc97071f87bb0" translate="yes" xml:space="preserve">
          <source>Level 3 &amp;mdash; Multiplication (&lt;code&gt;*&lt;/code&gt;) and division (&lt;code&gt;/&lt;/code&gt;)</source>
          <target state="translated">레벨 3 &amp;mdash; 곱하기 ( &lt;code&gt;*&lt;/code&gt; ) 및 나누기 ( &lt;code&gt;/&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b6d3eb2924374b17ead104f2e6704337373d534b" translate="yes" xml:space="preserve">
          <source>Level 3 &amp;mdash; Multiplication &lt;code&gt;*&lt;/code&gt; and division &lt;code&gt;/&lt;/code&gt;</source>
          <target state="translated">레벨 3 &amp;mdash; 곱하기 &lt;code&gt;*&lt;/code&gt; 와 나누기 &lt;code&gt;/&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ff1bbf028b1676dcbed5efec78712eec2eec2f1" translate="yes" xml:space="preserve">
          <source>Level 4 &amp;mdash; Addition (&lt;code&gt;+&lt;/code&gt;) or subtraction (&lt;code&gt;+&lt;/code&gt;)</source>
          <target state="translated">레벨 4 &amp;mdash; 더하기 ( &lt;code&gt;+&lt;/code&gt; ) 또는 빼기 ( &lt;code&gt;+&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="76c7a53b8aaf3b4d3d4c40f9ab98b835416a16f8" translate="yes" xml:space="preserve">
          <source>Level 4 &amp;mdash; Addition &lt;code&gt;+&lt;/code&gt; or subtraction &lt;code&gt;+&lt;/code&gt;</source>
          <target state="translated">4 단계 &amp;mdash; 더하기 &lt;code&gt;+&lt;/code&gt; 또는 빼기 &lt;code&gt;+&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5597f96dc9d80c27ec5e33857991562ca948cabc" translate="yes" xml:space="preserve">
          <source>Level Number</source>
          <target state="translated">레벨 번호</target>
        </trans-unit>
        <trans-unit id="3052fa9dd47259fbdfdaada2330b8f6e3cbdd9ac" translate="yes" xml:space="preserve">
          <source>Level numbers 66, 77, 78 and 88 all have special uses &amp;mdash; See &lt;a href=&quot;#Special-Data-Items&quot;&gt;Special Data Items&lt;/a&gt;, for details.</source>
          <target state="translated">레벨 번호 66, 77, 78 및 88은 모두 특수 용도로 사용됩니다. 자세한 내용은 &lt;a href=&quot;#Special-Data-Items&quot;&gt;특수 데이터 항목&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c40b4c76be763282435e76a210c233701e5f2f23" translate="yes" xml:space="preserve">
          <source>Level numbers 66, 77, 78 and 88 identify special properties of a data description entry.</source>
          <target state="translated">레벨 번호 66, 77, 78 및 88은 데이터 설명 항목의 특수 속성을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="f058b290679bb97e2e65e2ade8e908cf0471986c" translate="yes" xml:space="preserve">
          <source>Level numbers in the range 1 through 49 indicate the position of a data item in the hierarchical structure of a logical record. Level numbers in the range 1 through 9 can be written either as a single digit or as a zero followed by the significant digit.</source>
          <target state="translated">1-49 범위의 레벨 번호는 논리 레코드의 계층 구조에서 데이터 항목의 위치를 ​​나타냅니다. 1-9 범위의 레벨 번호는 단일 숫자 또는 0과 유효 숫자 뒤에 기록 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d0db8c2b020268e4b2e48ddcbb42e59195d905a" translate="yes" xml:space="preserve">
          <source>Licensed under the GNU Free Documentation License.</source>
          <target state="translated">GNU Free Documentation License에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="1c7be671b82e536f670976ec80f415fa5dd43afc" translate="yes" xml:space="preserve">
          <source>Like line sequential files, these files should not be defined to contain any exact binary data fields because the contents of those fields could inadvertently have the end-of-record sequence as part of their values &amp;mdash; this would confuse the runtime system when reading the file, and it would interpret that value as an actual end-of-record sequence.</source>
          <target state="translated">행 순차 파일과 같이 이러한 파일은 해당 2 진 데이터 필드를 포함하도록 정의되어서는 안됩니다. 해당 필드의 내용이 실수로 레코드 끝 순서를 값의 일부로 가질 수 있기 때문에 파일을 읽을 때 런타임 시스템이 혼동 될 수 있습니다. 이 값을 실제 레코드 끝 시퀀스로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="57489ee4e43a2ed5c736dd719377be4582a70ea3" translate="yes" xml:space="preserve">
          <source>Like most other implementations of the COBOL language, GnuCOBOL utilizes a run-time library. When the first program executed in a given execution sequence is a GnuCOBOL program, any run-time library initialization will be performed by the compiled COBOL code in a manner that is transparent to the C-language programmer. If, however, a C program is the first to execute, the burden of performing GnuCOBOL run-time library initialization falls upon the C program. See &lt;a href=&quot;#C-Main-Programs-Calling-GnuCOBOL-Subprograms&quot;&gt;C Main Programs Calling GnuCOBOL Subprograms&lt;/a&gt;, for an example of how to do this.</source>
          <target state="translated">다른 대부분의 COBOL 언어 구현과 마찬가지로 GnuCOBOL은 런타임 라이브러리를 사용합니다. 주어진 실행 시퀀스에서 실행 된 첫 번째 프로그램이 GnuCOBOL 프로그램 인 경우, 런타임 라이브러리 초기화는 C 언어 프로그래머에게 투명한 방식으로 컴파일 된 COBOL 코드에 의해 수행됩니다. 그러나 C 프로그램이 처음으로 실행되는 경우 GnuCOBOL 런타임 라이브러리 초기화 수행 부담은 C 프로그램에 달려 있습니다. 이를 수행하는 방법에 대한 예제는 &lt;a href=&quot;#C-Main-Programs-Calling-GnuCOBOL-Subprograms&quot;&gt;GnuCOBOL 서브 프로그램 호출 C 기본 프로그램을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="57fb879374ae97e5eb278f255c02c63fea22e809" translate="yes" xml:space="preserve">
          <source>Line Sequential files are processed using the following statements:</source>
          <target state="translated">행 순차 파일은 다음 명령문을 사용하여 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="705ab24e9e88484bd36a188c2786c37738960962" translate="yes" xml:space="preserve">
          <source>Line number beyond which nothing may be printed except for any footing that is to appear on every page. The default for this if not specified is zero, meaning there will be no footings. This value cannot be larger than the &lt;code&gt;LINAGE IS &lt;var&gt;n&lt;/var&gt; LINES&lt;/code&gt; value.</source>
          <target state="translated">모든 페이지에 표시되는 꼬리말을 제외하고 아무것도 인쇄되지 않는 행 번호입니다. 지정되지 않은 경우 기본값은 0이며 기초가 없음을 의미합니다. 이 값은 &lt;code&gt;LINAGE IS &lt;var&gt;n&lt;/var&gt; LINES&lt;/code&gt; 값 보다 클 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="92e97e035f44f8980e413b0d3167603ea36902ee" translate="yes" xml:space="preserve">
          <source>Literal</source>
          <target state="translated">Literal</target>
        </trans-unit>
        <trans-unit id="0f04cc81bf496e196dc1ead869612937cb48371b" translate="yes" xml:space="preserve">
          <source>Literals are constant values that will not change during the execution of a program. There are two fundamental types of literals &amp;mdash; numeric and alphanumeric.</source>
          <target state="translated">리터럴은 프로그램 실행 중에 변경되지 않는 상수 값입니다. 리터럴에는 숫자와 영숫자의 두 가지 기본 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="44ac976e13987b2e461319b6b07bf2f1d2977574" translate="yes" xml:space="preserve">
          <source>Little-Endian</source>
          <target state="translated">Little-Endian</target>
        </trans-unit>
        <trans-unit id="226d589b5f25caf9198d123daff4d9daae8eba87" translate="yes" xml:space="preserve">
          <source>Little-endian data allocation calls for the bytes that comprise a binary item to be allocated such that the least-significant byte is the left-most byte. For example, a four-byte binary item having a value of decimal 20 would be little-endian allocated as 14000000 (shown in hexadecimal notation).</source>
          <target state="translated">리틀 엔디안 데이터 할당은 가장 중요하지 않은 바이트가 가장 왼쪽 바이트가되도록 할당 할 이진 항목을 구성하는 바이트를 요구합니다. 예를 들어, 10 진수 값이 20 인 4 바이트 2 진 항목은 14000000 (16 진 표기법으로 표시)으로 리틀 엔디안이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="835de5c115f7b3e75f88f1bf5d8aaf4ad47e0bd8" translate="yes" xml:space="preserve">
          <source>Local-storage cannot be used in nested subprograms.</source>
          <target state="translated">로컬 서브 시스템은 중첩 서브 프로그램에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a5e093ebdd409890bed85c2fed42792048e3ee67" translate="yes" xml:space="preserve">
          <source>Local-storage, if any, is de-allocated.</source>
          <target state="translated">로컬 스토리지 (있는 경우)가 할당 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="3690da6677c866b7070485f97c20dfa1fc2058b7" translate="yes" xml:space="preserve">
          <source>Local-storage, if any, will be allocated and initialized.</source>
          <target state="translated">로컬 스토리지 (있는 경우)가 할당되고 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="029c39972ba6042647e3f70b02f4bd91260e9fb3" translate="yes" xml:space="preserve">
          <source>Locator</source>
          <target state="translated">Locator</target>
        </trans-unit>
        <trans-unit id="8d02c4cdcb2b9946ab2619bfecc5df1af1b12a02" translate="yes" xml:space="preserve">
          <source>Locks acquired vie multiple record locking remain in-effect until the program holding the lock&amp;hellip;</source>
          <target state="translated">다중 레코드 잠금을 통해 획득 한 잠금은 프로그램이 잠금을 보유 할 때까지 영향을받지 않습니다&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="256b0211cd7dcbaef103250b00102fed3e6e0d1e" translate="yes" xml:space="preserve">
          <source>M.cbl</source>
          <target state="translated">M.cbl</target>
        </trans-unit>
        <trans-unit id="fc3ab2432b8c18e9520aae59030cc15f96a27da9" translate="yes" xml:space="preserve">
          <source>MAGNETIC-TAPE, MANUAL, MASS-UPDATE, MAX-LINES, MAX-PROGRESS, MAX-TEXT, MAX-VAL, MAX, MEAN, MEDIAN, MEDIUM-FONT, MEMORY, MENU, MERGE, MESSAGE, METHOD-ID, METHOD, MIDRANGE, MINUS, MIN-VAL, MIN, MODE, MODIFY, MODULE-CALLER-ID, MODULE-DATE, MODULE-FORMATTED-DATE, MODULE-ID, MODULE-PATH, MODULE-SOURCE, MODULES, MODULE-TIME, MOD, MONETARY-DECIMAL-POINT, MONETARY-THOUSANDS-SEPARATOR, MOVE, MULTILINE, MULTIPLE, MULTIPLY</source>
          <target state="translated">MAGNETIC-TAPE, MANUAL, MASS-UPDATE, MAX-LINES, MAX-PROGRESS, MAX-TEXT, MAX-VAL, MAX, MEAN, MEDIAN, MEDIUM-FONT, MEMORY, MENU, MERGE, MESSAGE, METHOD-ID, METHOD, MIDRANGE, MINUS, MIN-VAL, MIN, MODE, MODIFY, MODULE-CALLER-ID, MODULE-DATE, MODULE-FORMATTED-DATE, MODULE-ID, MODULE-PATH, MODULE-SOURCE, MODULES, MODULE-TIME, MOD, 화폐-소수점, 화폐-수천-구분자, 이동, 다중 선, 다중, 다중</target>
        </trans-unit>
        <trans-unit id="be9a3c255cc059f59d89184276ee44ce2ff74a47" translate="yes" xml:space="preserve">
          <source>MAGNETIC-TAPE, MANUAL, MAX, MEAN, MEDIAN, MEMORY, MERGE, MESSAGE, METHOD, METHOD-ID, MIDRANGE, MIN, MINUS, MOD, MODE, MODULE-CALLER-ID, MODULE-DATE, MODULE-FORMATTED-DATE, MODULE-ID, MODULE-PATH, MODULES, MODULE-SOURCE, MODULE-TIME, MONETARY-DECIMAL-POINT, MONETARY-THOUSANDS-SEPARATOR, MOVE, MULTIPLE, MULTIPLY</source>
          <target state="translated">자기 테이프, 수동, 최대, 평균, 중간, 메모리, 병합, 메시지, 방법, 방법 ID, 중간 범위, 최소, 최소, 모드, 모드, 모듈러 ID, 모듈 날짜, 모듈 형식 날짜, 모듈 식 ID, 모듈 식 경로, 모듈 식, 모듈 식 소스, 모듈 식 시간, 화폐-소수점, 화 음식-분리기, 이동, 다중, 복수</target>
        </trans-unit>
        <trans-unit id="57e71373c55e995e80f24e3f2087d0a7b5dbbec9" translate="yes" xml:space="preserve">
          <source>MAX Function Syntax</source>
          <target state="translated">MAX 함수 구문</target>
        </trans-unit>
        <trans-unit id="0abf13bfa8b362e60f0cf8bd2bacaab30d7f67c9" translate="yes" xml:space="preserve">
          <source>MEAN Function Syntax</source>
          <target state="translated">MEAN 함수 구문</target>
        </trans-unit>
        <trans-unit id="31a496c910f49ef35450cbdb8cbc4374b9f67273" translate="yes" xml:space="preserve">
          <source>MEDIAN Function Syntax</source>
          <target state="translated">MEDIAN 함수 구문</target>
        </trans-unit>
        <trans-unit id="daee7fdd946c270a9b400d0cb5b7e42fe5872e0c" translate="yes" xml:space="preserve">
          <source>MERGE Syntax</source>
          <target state="translated">병합 구문</target>
        </trans-unit>
        <trans-unit id="c8035dd19f4b057f89b85a604ee1af37d346e31e" translate="yes" xml:space="preserve">
          <source>MIDRANGE Function Syntax</source>
          <target state="translated">MIDRANGE 함수 구문</target>
        </trans-unit>
        <trans-unit id="b3922fba0ffbf0d82c96e71393fb62e945ccf5b9" translate="yes" xml:space="preserve">
          <source>MIN Function Syntax</source>
          <target state="translated">MIN 함수 구문</target>
        </trans-unit>
        <trans-unit id="6df76c53746f58160bf9ed45943e438821905bb2" translate="yes" xml:space="preserve">
          <source>MOD Function Syntax</source>
          <target state="translated">MOD 함수 구문</target>
        </trans-unit>
        <trans-unit id="fb9072e5497502c8b0c9f0cc92c12083bdb2cecc" translate="yes" xml:space="preserve">
          <source>MODULE-CALLER-ID Function Syntax</source>
          <target state="translated">모듈러 ID 기능 구문</target>
        </trans-unit>
        <trans-unit id="77023dbd5e71addbd6ecdf7b0de7955c05a7cbcc" translate="yes" xml:space="preserve">
          <source>MODULE-DATE Function Syntax</source>
          <target state="translated">모듈 날짜 함수 구문</target>
        </trans-unit>
        <trans-unit id="e4f1aeb1a72fe45f289846eea035900277d6474e" translate="yes" xml:space="preserve">
          <source>MODULE-FORMATTED-DATE Function Syntax</source>
          <target state="translated">모듈 식 날짜 함수 구문</target>
        </trans-unit>
        <trans-unit id="e4708a13b25aed7fbcdde2ed7eb4f478e4e5a0d2" translate="yes" xml:space="preserve">
          <source>MODULE-ID Function Syntax</source>
          <target state="translated">모듈 ID 함수 구문</target>
        </trans-unit>
        <trans-unit id="9c157b8be74a13e0253ff0fdbcddcca6237613e4" translate="yes" xml:space="preserve">
          <source>MODULE-PATH Function Syntax</source>
          <target state="translated">모듈 경로 함수 구문</target>
        </trans-unit>
        <trans-unit id="6aeac5d8bb6edf96b2cc15b2e1900d618339fe87" translate="yes" xml:space="preserve">
          <source>MODULE-SOURCE Function Syntax</source>
          <target state="translated">모듈 소스 함수 구문</target>
        </trans-unit>
        <trans-unit id="9ba6dae63e2adfd381389ee805e05d8f98957c6a" translate="yes" xml:space="preserve">
          <source>MODULE-TIME Function Syntax</source>
          <target state="translated">MODULE-TIME 함수 구문</target>
        </trans-unit>
        <trans-unit id="f73ead11798a2b39d355bdb9cc3ee0afd6c73ca2" translate="yes" xml:space="preserve">
          <source>MONETARY-DECIMAL-POINT Function Syntax</source>
          <target state="translated">MOTORARY-DECIMAL-POINT 함수 구문</target>
        </trans-unit>
        <trans-unit id="f959bf7a22a6fa8fd96fe2dd391a08fa5dd22aa0" translate="yes" xml:space="preserve">
          <source>MONETARY-THOUSANDS-SEPARATOR Function Syntax</source>
          <target state="translated">통화-천-분리기 함수 구문</target>
        </trans-unit>
        <trans-unit id="ec0648f1ef8e6f8e156101c88dcd2b9563d62924" translate="yes" xml:space="preserve">
          <source>MOVE CORRESPONDING Syntax</source>
          <target state="translated">이동 구문</target>
        </trans-unit>
        <trans-unit id="569fe924e80927234226e1da480e2aaeb896476b" translate="yes" xml:space="preserve">
          <source>MULTIPLY BY Syntax</source>
          <target state="translated">여러 구문으로</target>
        </trans-unit>
        <trans-unit id="3ad347c2697684ef0953e3a767d0bc1635d31d5a" translate="yes" xml:space="preserve">
          <source>MULTIPLY GIVING Syntax</source>
          <target state="translated">다양한 기부 구문</target>
        </trans-unit>
        <trans-unit id="412299ff020a7154d245c3b0f04152fc824d367f" translate="yes" xml:space="preserve">
          <source>Magenta: COB-COLOR-MAGENTA</source>
          <target state="translated">마젠타 : COB-COLOR-MAGENTA</target>
        </trans-unit>
        <trans-unit id="4ad990da0619f2f6612747fd3b18ae051e2e5eca" translate="yes" xml:space="preserve">
          <source>Main Program</source>
          <target state="translated">메인 프로그램</target>
        </trans-unit>
        <trans-unit id="62df8b8e9bbaa8bb9f1517aa2bf38f13fc37e36a" translate="yes" xml:space="preserve">
          <source>Main program</source>
          <target state="translated">주요 프로그램</target>
        </trans-unit>
        <trans-unit id="154c8bfc5f3e601547791b40d3a205f6ed780b67" translate="yes" xml:space="preserve">
          <source>Main programs compiled in this manner should be executed as follows:</source>
          <target state="translated">이러한 방식으로 컴파일 된 주요 프로그램은 다음과 같이 실행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ad9766c462696f99f3025a340a18914544b7bff9" translate="yes" xml:space="preserve">
          <source>Main programs that wish to &quot;pass back&quot; a return code value to the operating system when they exit do not use RETURNING - they do so simply by MOVEing a value to the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register.</source>
          <target state="translated">종료시 리턴 코드 값을 운영 체제로 &quot;패스 백&quot;하려는 기본 프로그램은 RETURNING을 사용하지 않습니다. 단순히 &lt;code&gt;RETURN-CODE&lt;/code&gt; 특수 레지스터 로 값을 이동하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="0cb2ae133e90657ae54e6ab6a5c15f115ac565ee" translate="yes" xml:space="preserve">
          <source>Main programs that wish to &amp;ldquo;pass back&amp;rdquo; a return code value to the operating system when they exit do not use &lt;code&gt;RETURNING&lt;/code&gt; - they do so simply by MOVEing a value to the &lt;code&gt;RETURN-CODE&lt;/code&gt; special register.</source>
          <target state="translated">종료시 리턴 코드 값을 운영 체제로 &quot;전달&quot;하려는 주 프로그램은 &lt;code&gt;RETURNING&lt;/code&gt; 을 사용하지 않습니다. 단순히 값을 &lt;code&gt;RETURN-CODE&lt;/code&gt; 특수 레지스터로 이동하여 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7a5053f6a0e7ffe3e98db384f4662350eb992d81" translate="yes" xml:space="preserve">
          <source>Management of areas on the printed page such as top-of page headers, bottom-of-page footers, dealing with &quot;full page&quot; situations and the like are now the joint responsibility of the programmer and the GnuCOBOL run-time library, which provides tools such as the&lt;code&gt;LINAGE-COUNTER&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) and the&lt;code&gt;END-OF-PAGE&lt;/code&gt;</source>
          <target state="translated">&quot;전체 페이지&quot;상황 등을 처리하는 페이지 상단 머리글, 페이지 하단 바닥 글과 같은 인쇄 된 페이지의 영역 관리는 이제 프로그래머와 GnuCOBOL 런타임 라이브러리의 공동 책임입니다. 예를 들면 같은 도구 &lt;code&gt;LINAGE-COUNTER&lt;/code&gt; 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; )와 &lt;code&gt;END-OF-PAGE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="535d01a3bb7e25e935da4ad3d0028806321932cc" translate="yes" xml:space="preserve">
          <source>Management of areas on the printed page such as top-of page headers, bottom-of-page footers, dealing with &quot;full page&quot; situations and the like are the complete responsibility of the programmer.</source>
          <target state="translated">&quot;전체 페이지&quot;상황 등을 처리하는 페이지 상단 머리글, 페이지 하단 바닥 글과 같은 인쇄 된 페이지 영역 관리는 프로그래머의 전적인 책임입니다.</target>
        </trans-unit>
        <trans-unit id="c39f4af3f8ee369d5da98590dfa9970ef82b38d1" translate="yes" xml:space="preserve">
          <source>Management of areas on the printed page such as top-of page headers, bottom-of-page footers, dealing with &amp;ldquo;full page&amp;rdquo; situations and the like are now the joint responsibility of the programmer and the GnuCOBOL run-time library, which provides tools such as the   &lt;code&gt;LINAGE-COUNTER&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) and the  &lt;code&gt;END-OF-PAGE&lt;/code&gt; clause to deal with page formatting issues.</source>
          <target state="translated">페이지 상단 헤더, 하단 하단 바닥 글과 같은 인쇄 된 페이지의 영역 관리, &quot;전체 페이지&quot;상황 처리 등은 이제 프로그래머와 GnuCOBOL 런타임 라이브러리의 공동 책임입니다. 예를 들면 같은 도구 &lt;code&gt;LINAGE-COUNTER&lt;/code&gt; 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; )와 &lt;code&gt;END-OF-PAGE&lt;/code&gt; 절은 페이지 서식 문제를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="1eae0d85460231010a2eeca71dca39a95cfe258b" translate="yes" xml:space="preserve">
          <source>Management of areas on the printed page such as top-of page headers, bottom-of-page footers, dealing with &amp;ldquo;full page&amp;rdquo; situations and the like are the complete responsibility of the programmer.</source>
          <target state="translated">페이지 상단 머리글, 페이지 하단 바닥 글과 같은 인쇄 된 페이지의 영역 관리, &quot;전체 페이지&quot;상황 처리 등은 프로그래머의 전적인 책임입니다.</target>
        </trans-unit>
        <trans-unit id="72c571f7110392bd7e9a608a8c56799f3c875b76" translate="yes" xml:space="preserve">
          <source>Many COBOL compilers do not allow the use of &lt;code&gt;VALUE&lt;/code&gt; and &lt;code&gt;OCCURS&lt;/code&gt; (see &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt;) on the same data item; additionally, they don&amp;rsquo;t allow a &lt;code&gt;VALUE&lt;/code&gt; clause on a data item subordinate to an &lt;code&gt;OCCURS&lt;/code&gt;. GnuCOBOL, however, has neither of these restrictions!</source>
          <target state="translated">많은 COBOL 컴파일러는 동일한 데이터 항목에서 &lt;code&gt;VALUE&lt;/code&gt; 및 &lt;code&gt;OCCURS&lt;/code&gt; ( &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt; 참조 ) 사용을 허용하지 않습니다 . 또한 &lt;code&gt;OCCURS&lt;/code&gt; 에 종속 된 데이터 항목에 &lt;code&gt;VALUE&lt;/code&gt; 절을 허용하지 않습니다 . 그러나 GnuCOBOL에는 이러한 제한 사항이 없습니다!</target>
        </trans-unit>
        <trans-unit id="5d904664fde10f48cc22ff0d5ed913f64ac37406" translate="yes" xml:space="preserve">
          <source>Many COBOL compilers do not allow the use of&lt;code&gt;VALUE&lt;/code&gt;and&lt;code&gt;OCCURS&lt;/code&gt;(see &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt;) on the same data item; additionally, they don&amp;rsquo;t allow a&lt;code&gt;VALUE&lt;/code&gt;clause on a data item subordinate to an&lt;code&gt;OCCURS&lt;/code&gt; GnuCOBOL, however, has neither of these restrictions!</source>
          <target state="translated">많은 COBOL 컴파일러는 동일한 데이터 항목에서 &lt;code&gt;VALUE&lt;/code&gt; 및 &lt;code&gt;OCCURS&lt;/code&gt; ( &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt; 참조 )를 사용할 수 없습니다 . 또한 &lt;code&gt;OCCURS&lt;/code&gt; GnuCOBOL에 종속 된 데이터 항목에 &lt;code&gt;VALUE&lt;/code&gt; 절을 허용하지 않지만 이러한 제한은 없습니다!</target>
        </trans-unit>
        <trans-unit id="cec330cac6c061d7cea06b901961f17d2342ed88" translate="yes" xml:space="preserve">
          <source>Many systems have program-development tools available to ease the task of coding programs; those tools that concentrate on COBOL are capable of providing templates for much of the &quot;overhead&quot; verbiage of any program&amp;hellip;</source>
          <target state="translated">많은 시스템에는 프로그램 코딩 작업을 용이하게하는 프로그램 개발 도구가 있습니다. COBOL에 중점을 둔 도구는 모든 프로그램의 &quot;오버 헤드&quot;에 대한 템플릿을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16eba348bc9f50336686ef5cc4e108f9eb85d221" translate="yes" xml:space="preserve">
          <source>Many systems have program-development tools available to ease the task of coding programs; those tools that concentrate on COBOL are capable of providing templates for much of the &amp;ldquo;overhead&amp;rdquo; verbiage of any program&amp;hellip;</source>
          <target state="translated">많은 시스템에는 프로그램 코딩 작업을 쉽게하기 위해 사용할 수있는 프로그램 개발 도구가 있습니다. COBOL에 집중하는 이러한 도구는 모든 프로그램의 &quot;오버 헤드&quot;표현에 대한 템플릿을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bea0e296af322cedefa66548ccd5635e5218df89" translate="yes" xml:space="preserve">
          <source>Many times these businesses are finding the cost of the system/networking engineering, operational management and monitoring and risk management (i.e. disaster recovery) infrastructures necessary to support truly mission-critical applications to be so high that the &quot;less-expensive&quot; solution really isn&amp;rsquo;t; in these cases the mainframe may remain the best option, thus leaving COBOL in play and businesses seeking another solution for at least part of their application base.</source>
          <target state="translated">이러한 비즈니스는 여러 번 이러한 시스템에서 네트워킹, 네트워킹 관리, 운영 관리 및 모니터링 및 위험 관리 (예 : 재해 복구) 인프라의 비용을 찾아야 미션 크리티컬 한 응용 프로그램을 지원하여 &quot;비싼&quot;솔루션이 될 정도로 '티; 이 경우 메인 프레임이 최상의 옵션으로 남아있을 수 있으므로 COBOL을 사용하고 비즈니스는 애플리케이션 기반의 적어도 일부를위한 다른 솔루션을 찾고 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f715c7f265bfdd61e133e71be0ec5656198b750" translate="yes" xml:space="preserve">
          <source>Many times these businesses are finding the cost of the system/networking engineering, operational management and monitoring and risk management (i.e. disaster recovery) infrastructures necessary to support truly mission-critical applications to be so high that the &amp;ldquo;less-expensive&amp;rdquo; solution really isn&amp;rsquo;t; in these cases the mainframe may remain the best option, thus leaving COBOL in play and businesses seeking another solution for at least part of their application base.</source>
          <target state="translated">많은 경우 이러한 기업들은 진정한 미션 크리티컬 애플리케이션을 지원하는 데 필요한 시스템 / 네트워킹 엔지니어링, 운영 관리 및 모니터링 및 위험 관리 (예 : 재해 복구) 인프라 비용이 너무 높아서&amp;ldquo;저렴한&amp;rdquo;솔루션이 실제로는 그렇지 않다는 것을 발견하고 있습니다. '티; 이러한 경우 메인 프레임이 최상의 옵션으로 남아있을 수 있으므로 COBOL이 작동하고 기업은 애플리케이션 기반의 적어도 일부를위한 다른 솔루션을 찾고 있습니다.</target>
        </trans-unit>
        <trans-unit id="02c05fa5e2daee8ddf4a77057b17571c14977849" translate="yes" xml:space="preserve">
          <source>Marking changes becomes more of a challenge when free-format source code is in effect. Creating a top-of-program comment block to generically describe changes that have been made isn&amp;rsquo;t difficult, even in free-form. What</source>
          <target state="translated">자유 형식 소스 코드가 적용되면 변경 사항 표시가 더 어려워집니다. 변경 사항을 일반적으로 설명하는 프로그램 상단 주석 블록을 만드는 것은 자유 형식에서도 어렵지 않습니다. 뭐</target>
        </trans-unit>
        <trans-unit id="5c7162a608e9a76bc0cf997699b25c2bb027fd85" translate="yes" xml:space="preserve">
          <source>Marking changes becomes more of a challenge when free-format source code is in effect. Creating a top-of-program comment block to generically describe changes that have been made isn&amp;rsquo;t difficult, even in free-form. What IS difficult, however, is coming up with a scheme for per-statement mark up of changes that doesn&amp;rsquo;t introduce a ridiculously excessive number of source lines to the program. I&amp;rsquo;m not sure there is a good answer to this problem (if a reader has one, please let me know). Generally, I&amp;rsquo;ve noticed that shops using free-format conventions for their COBOL source tend to stick with just the top-of-program comment block combined with minimal comment blocks sprinkled throughout the program noting areas that underwent major changes.</source>
          <target state="translated">자유 형식의 소스 코드가 적용되면 변경 사항을 표시하는 것이 더 어려워집니다. 작성된 변경 사항을 일반적으로 설명하기 위해 프로그램 상단 주석 블록을 작성하는 것은 자유 형식에서도 어렵지 않습니다. 그러나 어려운 점은 프로그램에 엄청나게 많은 수의 소스 라인을 도입하지 않는 변경 사항에 대한 문마다 마크 업을위한 체계를 마련하는 것입니다. 이 문제에 대한 좋은 답변이 있는지 잘 모르겠습니다 (독자가있는 경우 알려주세요). 일반적으로 COBOL 소스에 대해 자유 형식 규칙을 사용하는 상점은 주요 변경 사항이 발생한 영역을 지적하면서 프로그램 전체에 뿌려지는 최소 주석 블록과 결합 된 최고 프로그램 주석 블록 만 사용하는 경향이 있음을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="44df495b9a46d581843f66787d274a1a7bcc6fc8" translate="yes" xml:space="preserve">
          <source>Matching up GnuCOBOL numeric Usage s with their C language data type equivalents is possible via the following chart:</source>
          <target state="translated">다음 차트를 통해 GnuCOBOL 숫자 사용법과 C 언어 데이터 유형을 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2f00dc90e71c34249a20020c959899070b8c43f" translate="yes" xml:space="preserve">
          <source>Matching up GnuCOBOL numeric Usage&amp;rsquo;s with their C language data type equivalents is possible via the following chart:</source>
          <target state="translated">다음 차트를 통해 GnuCOBOL 숫자 사용을 해당 C 언어 데이터 유형과 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1278cc3d1ceb3c4e92292f1cb7c4a187629fa8a3" translate="yes" xml:space="preserve">
          <source>Max Field</source>
          <target state="translated">최대 필드</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="f15a625eabeb2b9b8fbf957ba6acb6ea6384e8c2" translate="yes" xml:space="preserve">
          <source>Meaning if 0</source>
          <target state="translated">0의 의미</target>
        </trans-unit>
        <trans-unit id="0b296b5b70a4eb122d3023d41ac6ce6b7484aab3" translate="yes" xml:space="preserve">
          <source>Meaning if 1</source>
          <target state="translated">1의 의미</target>
        </trans-unit>
        <trans-unit id="1b4220e0370bfab2a63184640badca2fac263661" translate="yes" xml:space="preserve">
          <source>Mid Dbl Click</source>
          <target state="translated">중간 Dbl 클릭</target>
        </trans-unit>
        <trans-unit id="9535e3b01f3281dac5bb35122bd26a849b2a9282" translate="yes" xml:space="preserve">
          <source>Mid Pressed</source>
          <target state="translated">누르면 중간</target>
        </trans-unit>
        <trans-unit id="95b9cc214c1eef97ef2b6df8fd8ea55bec0588af" translate="yes" xml:space="preserve">
          <source>Mid Released</source>
          <target state="translated">중간 출시</target>
        </trans-unit>
        <trans-unit id="84025296e15836cc805dc0fcce6f78c345ddda06" translate="yes" xml:space="preserve">
          <source>Module being compiled contains the main program.</source>
          <target state="translated">컴파일중인 모듈에는 기본 프로그램이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b59a4226fd1a0c6fe0f0ae5ec580ab41c849fe7f" translate="yes" xml:space="preserve">
          <source>Monoalphabetic substitution of one or more characters in a string with different characters</source>
          <target state="translated">다른 문자를 사용하여 문자열에서 하나 이상의 문자를 단일 알파벳으로 대체</target>
        </trans-unit>
        <trans-unit id="f99e481919f7772162edf428466c40acaa045b03" translate="yes" xml:space="preserve">
          <source>Most &amp;lt;</source>
          <target state="translated">대부분 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="924840d8c80007140d8bdc6ad8624d02dec61d6e" translate="yes" xml:space="preserve">
          <source>Most &lt;code&gt;&lt;var&gt;VARYING-Clause&lt;/var&gt;&lt;/code&gt;s have no &lt;code&gt;AFTER&lt;/code&gt; specified. Those that do, however, are establishing a loop-within-a-loop situation where the process described above in steps (&amp;lsquo;</source>
          <target state="translated">대부분의 &lt;code&gt;&lt;var&gt;VARYING-Clause&lt;/var&gt;&lt;/code&gt; 에는 &lt;code&gt;AFTER&lt;/code&gt; 가 지정 되어 있지 않습니다 . 그러나 그렇게하는 사람들은 위에서 설명한 단계 ( ')에서 설명한 프로세스가있는 루프 내 루프 상황을 설정하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffb0edd87964fd75f70c6e96275eddb4f0d8c34a" translate="yes" xml:space="preserve">
          <source>Most COBOL programmers, when using &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; explicitly or implicitly have developed the habit of using &amp;lsquo;</source>
          <target state="translated">대부분의 COBOL 프로그래머는 &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; 를 명시 적으로 또는 암시 적으로 사용할 때 '를 사용하는 습관을 개발했습니다.</target>
        </trans-unit>
        <trans-unit id="f9aaebcdc913ba77329c6f07dbfd334a3e319cb4" translate="yes" xml:space="preserve">
          <source>Most COBOL programmers, when using&lt;code&gt;WITH TEST BEFORE&lt;/code&gt;explicitly or implicitly have developed the habit of using &quot;&amp;gt;&quot; rather than &quot;=&quot; on&lt;code&gt;UNTIL&lt;/code&gt;clauses. This would make the sample code:</source>
          <target state="translated">&lt;code&gt;WITH TEST BEFORE&lt;/code&gt; 를 명시 적 또는 암시 적으로 사용할 때 대부분의 COBOL 프로그래머 는 &lt;code&gt;UNTIL&lt;/code&gt; 절 에서 &quot;=&quot;대신 &quot;&amp;gt;&quot;를 사용하는 습관을 개발했습니다 . 이것은 샘플 코드를 만들 것입니다 :</target>
        </trans-unit>
        <trans-unit id="af302c911fcda5124147255d68b3ea18b4163a54" translate="yes" xml:space="preserve">
          <source>Most of the call-by-number routines have evolved into even more powerful call-by-name routines, many of which are supported by GnuCOBOL.</source>
          <target state="translated">대부분의 번호순 전화 루틴은 훨씬 더 강력한 이름순 전화 루틴으로 발전했으며 그 중 많은 것이 GnuCOBOL에 의해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="817d5274cb3dad555ae670d47cd2b238950e0a1b" translate="yes" xml:space="preserve">
          <source>Most other COBOL implementations reject the use of multiple occurrences of multiple floating editing symbols. For example, they would reject &amp;lt;</source>
          <target state="translated">대부분의 다른 COBOL 구현은 여러 번의 여러 부동 편집 기호 사용을 거부합니다. 예를 들어, 그들은 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="58de159141a408dd736236a21261f443f9261611" translate="yes" xml:space="preserve">
          <source>Most other COBOL implementations reject the use of multiple occurrences of multiple floating editing symbols. For example, they would reject &lt;var&gt;picture-string&lt;/var&gt;s such as &lt;code&gt;+++$$$9.99&lt;/code&gt;, &lt;code&gt;$$$ZZZ9.99&lt;/code&gt; and so on. GnuCOBOL accepts these. Programmers creating GnuCOBOL programs should avoid such &lt;var&gt;picture-string&lt;/var&gt;s if there is any likelihood that those programs may be used with other COBOL implementations.</source>
          <target state="translated">대부분의 다른 COBOL 구현은 다중 부동 편집 기호의 다중 발생 사용을 거부합니다. 예를 들어, 그들은 &lt;code&gt;+++$$$9.99&lt;/code&gt; , &lt;code&gt;$$$ZZZ9.99&lt;/code&gt; 등과 같은 &lt;var&gt;picture-string&lt;/var&gt; 거부 합니다. GnuCOBOL은이를 받아들입니다. GnuCOBOL 프로그램을 작성하는 프로그래머 는 해당 프로그램이 다른 COBOL 구현과 함께 사용될 가능성이있는 경우 이러한 &lt;var&gt;picture-string&lt;/var&gt; 피해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ae88dcc958cf082a5ddff5e3bffb27559f0abd8e" translate="yes" xml:space="preserve">
          <source>Mouse Key codes are populated only if mouse management has been enabled. To enable mouse it is first necessary to set &lt;code&gt;COB_MOUSE_FLAGS&lt;/code&gt; (either externally via terminal command, or internally via &lt;code&gt;SET ENVIRONMENT&lt;/code&gt; to the applicable ?mouse mask? (specifying which activities you wish the program to detect). Here is an example of setting the mask from a COBOL program:</source>
          <target state="translated">마우스 키 코드는 마우스 관리가 활성화 된 경우에만 채워집니다. 마우스를 활성화하려면 먼저 &lt;code&gt;COB_MOUSE_FLAGS&lt;/code&gt; 를 설정 해야합니다 (외부 적으로 터미널 명령을 통해 또는 &lt;code&gt;SET ENVIRONMENT&lt;/code&gt; 를 통해 내부적으로 해당 &quot;마우스 마스크&quot;(프로그램이 감지 할 활동 지정)로 설정). 다음은 마스크를 설정하는 예입니다. COBOL 프로그램 :</target>
        </trans-unit>
        <trans-unit id="e99a5dcdcef05304aba95db02a55182cfff694d7" translate="yes" xml:space="preserve">
          <source>Mouse Move</source>
          <target state="translated">마우스 이동</target>
        </trans-unit>
        <trans-unit id="bd8dc228cac7dc6165d9a7427a86371a364ab9e9" translate="yes" xml:space="preserve">
          <source>Moving files (a destructive &quot;copy&quot;)</source>
          <target state="translated">파일 이동 (파괴적인 &quot;복사&quot;)</target>
        </trans-unit>
        <trans-unit id="af7bc5186e5f6587dd7cf943c6a4e4b97482ae2e" translate="yes" xml:space="preserve">
          <source>Moving files (a destructive &amp;ldquo;copy&amp;rdquo;)</source>
          <target state="translated">파일 이동 (파괴적인 &quot;복사본&quot;)</target>
        </trans-unit>
        <trans-unit id="b3170807df2699f5d0529b6da50976a416981ad4" translate="yes" xml:space="preserve">
          <source>Multiple &amp;lsquo;</source>
          <target state="translated">여러 '</target>
        </trans-unit>
        <trans-unit id="c6f6bfc686d3122948fbe2220d2b1d5226a79270" translate="yes" xml:space="preserve">
          <source>Multiple programs, separated from one another by &lt;code&gt;END PROGRAM&lt;/code&gt; or &lt;code&gt;END FUNCTION&lt;/code&gt; statements. The final program in such a source code file need not have an &lt;code&gt;END PROGRAM&lt;/code&gt; or &lt;code&gt;END FUNCTION&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;END PROGRAM&lt;/code&gt; 또는 &lt;code&gt;END FUNCTION&lt;/code&gt; 문으로 서로 분리 된 여러 프로그램 . 이러한 소스 코드 파일의 최종 프로그램에는 &lt;code&gt;END PROGRAM&lt;/code&gt; 또는 &lt;code&gt;END FUNCTION&lt;/code&gt; 문 이 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8068c142bfb974eaa19e904ed221669dae03ee9c" translate="yes" xml:space="preserve">
          <source>Multiple programs, separated from one another by&lt;code&gt;END PROGRAM&lt;/code&gt;or&lt;code&gt;END FUNCTION&lt;/code&gt;statements. The final program in such a source code file need not have an&lt;code&gt;END PROGRAM&lt;/code&gt;or&lt;code&gt;END FUNCTION&lt;/code&gt;statement.</source>
          <target state="translated">&lt;code&gt;END PROGRAM&lt;/code&gt; 또는 &lt;code&gt;END FUNCTION&lt;/code&gt; 문으로 서로 분리 된 여러 프로그램 . 이러한 소스 코드 파일의 최종 프로그램에는 &lt;code&gt;END PROGRAM&lt;/code&gt; 또는 &lt;code&gt;END FUNCTION&lt;/code&gt; 문 이 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="02160c2d59fcbe5c753ac574ebfed903f459af79" translate="yes" xml:space="preserve">
          <source>Multiple space-delimited tokens may be treated as a single token by enclosing them in quotes. For example, there are only three tokens generated from the command line &lt;code&gt;C:\Pgms\myprog.exe &quot;THIS IS A&quot; TEST&lt;/code&gt; &amp;mdash; &quot;C:\Pgms\myprog.exe&quot;, &quot;THIS IS A&quot; and &quot;TEST&quot;. When quote characters are used to create multi-word tokens, the quote characters themselves are stripped from the token&amp;rsquo;s value.</source>
          <target state="translated">공백으로 구분 된 여러 토큰은 따옴표로 묶어 단일 토큰으로 취급 될 수 있습니다. 예를 들어 명령 줄 &lt;code&gt;C:\Pgms\myprog.exe &quot;THIS IS A&quot; TEST&lt;/code&gt; &amp;mdash; &quot;C : \ Pgms \ myprog.exe&quot;, &quot;THIS IS A&quot;및 &quot;TEST&quot; 에서 생성 된 토큰은 3 개뿐입니다 . 따옴표 문자를 사용하여 여러 단어 토큰을 만들면 따옴표 문자 자체가 토큰 값에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="a00cb7c2ea609150a27e4dadeed928c42c11310c" translate="yes" xml:space="preserve">
          <source>Multiple space-delimited tokens may be treated as a single token by enclosing them in quotes. For example, there are only three tokens generated from the command line &lt;code&gt;C:\Pgms\myprog.exe &amp;lsquo;&lt;samp&gt;THIS IS A&lt;/samp&gt;&amp;rsquo; TEST&lt;/code&gt; &amp;mdash; &amp;lsquo;</source>
          <target state="translated">공백으로 구분 된 여러 토큰은 따옴표로 묶어 단일 토큰으로 처리 할 수 ​​있습니다. 예를 들어 &lt;code&gt;C:\Pgms\myprog.exe &amp;lsquo;&lt;samp&gt;THIS IS A&lt;/samp&gt;&amp;rsquo; TEST&lt;/code&gt; 명령 줄에서 생성 된 토큰은 세 개뿐입니다 .&lt;samp&gt;이것은&lt;/samp&gt;'테스트 &amp;mdash;'</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
