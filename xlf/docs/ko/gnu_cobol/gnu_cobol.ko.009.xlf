<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="gnu_cobol">
    <body>
      <group id="gnu_cobol">
        <trans-unit id="46402f53de25af4f770ab21b1329a124cb879aa0" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;X&quot;E4&quot;&lt;/code&gt; to clear the screen. There are no arguments and no returned value.</source>
          <target state="translated">Use &lt;code&gt;X&quot;E4&quot;&lt;/code&gt; to clear the screen. There are no arguments and no returned value.</target>
        </trans-unit>
        <trans-unit id="fdcfbf712cf773911aa1a3b1676e871c1c6e5a66" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;DECLARATIVES&lt;/code&gt; (see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) routine or an explicitly-declared file status field tested after the &lt;code&gt;READ&lt;/code&gt; or &lt;code&gt;RETURN&lt;/code&gt; to detect error conditions other than end-of-file.</source>
          <target state="translated">Use a &lt;code&gt;DECLARATIVES&lt;/code&gt; (see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) routine or an explicitly-declared file status field tested after the &lt;code&gt;READ&lt;/code&gt; or &lt;code&gt;RETURN&lt;/code&gt; to detect error conditions other than end-of-file.</target>
        </trans-unit>
        <trans-unit id="a077f478ea6c8b338771cd509e06fe612041307c" translate="yes" xml:space="preserve">
          <source>Use a&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) routine or an explicitly-declared file status field tested after the&lt;code&gt;READ&lt;/code&gt;or&lt;code&gt;RETURN&lt;/code&gt;to detect error conditions other than end-of-file.</source>
          <target state="translated">용도 &lt;code&gt;DECLARATIVES&lt;/code&gt; 를 (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt; 루틴 또는 후 테스트를 명시 적으로 선언 파일 상태 필드) &lt;code&gt;READ&lt;/code&gt; 또는 &lt;code&gt;RETURN&lt;/code&gt; end-of-file 이외의 오류 조건을 감지합니다.</target>
        </trans-unit>
        <trans-unit id="1df41f6fa8acd2d4a7200e2fefac6d5d04cf6a05" translate="yes" xml:space="preserve">
          <source>Use constant subscripts (example #1) wherever possible/practical.</source>
          <target state="translated">가능한 한 / 실제로 일정한 첨자를 사용하십시오 (예 # 1).</target>
        </trans-unit>
        <trans-unit id="886385dc37dfa4f17c4b715350ce42a8bec6d9e2" translate="yes" xml:space="preserve">
          <source>Use of a &lt;code&gt;ROUNDED&lt;/code&gt; clause without a &lt;code&gt;MODE&lt;/code&gt; specification is the same as specifying &lt;code&gt;ROUNDED MODE IS NEAREST-AWAY-FROM-ZERO&lt;/code&gt;.</source>
          <target state="translated">Use of a &lt;code&gt;ROUNDED&lt;/code&gt; clause without a &lt;code&gt;MODE&lt;/code&gt; specification is the same as specifying &lt;code&gt;ROUNDED MODE IS NEAREST-AWAY-FROM-ZERO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70d5d4de708078d88800b585c6de016b9cfd3034" translate="yes" xml:space="preserve">
          <source>Use of a reference modifier on the string field - See &lt;a href=&quot;#Reference-Modifiers&quot;&gt;Reference Modifiers&lt;/a&gt;.</source>
          <target state="translated">문자열 필드에서 &lt;a href=&quot;#Reference-Modifiers&quot;&gt;참조 수정 자 사용&lt;/a&gt; &amp;ndash; 참조 수정 자 참조 .</target>
        </trans-unit>
        <trans-unit id="49e7f0a9502b6030322ad77ec830602c53a48d0e" translate="yes" xml:space="preserve">
          <source>Use of a&lt;code&gt;ROUNDED&lt;/code&gt;clause without a&lt;code&gt;MODE&lt;/code&gt;specification is the same as specifying&lt;code&gt;ROUNDED MODE IS NEAREST-AWAY-FROM-ZERO&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;MODE&lt;/code&gt; 스펙 없이 &lt;code&gt;ROUNDED&lt;/code&gt; 절을 사용하는 것은 ROUNDED &lt;code&gt;ROUNDED MODE IS NEAREST-AWAY-FROM-ZERO&lt;/code&gt; 를 지정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e538ffbb023749c67b9aff077d23fa6ff6b5060" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt; CDF directive to create CDF variables and (optionally) assign them either literal or environment variable values.</source>
          <target state="translated">Use the &lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt; CDF directive to create CDF variables and (optionally) assign them either literal or environment variable values.</target>
        </trans-unit>
        <trans-unit id="0ec74ef6b77875bcf29d71bbe60c0705c09eeb37" translate="yes" xml:space="preserve">
          <source>Use this clause to cause an audible tone to occur when the screen item is &lt;code&gt;DISPLAY&lt;/code&gt;ed.</source>
          <target state="translated">Use this clause to cause an audible tone to occur when the screen item is &lt;code&gt;DISPLAY&lt;/code&gt; ed.</target>
        </trans-unit>
        <trans-unit id="543986951caf80e7bf2ee225eace63af8f6047bf" translate="yes" xml:space="preserve">
          <source>Use this clause to cause an audible tone to occur when the screen item is DISPLAYed.</source>
          <target state="translated">화면 항목이 표시 될 때 소리가 나게하려면이 절을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="def89069432793ce44d44629ecc1a4e2ebfa5049" translate="yes" xml:space="preserve">
          <source>Use this feature at your own risk &amp;ndash; you should always use the c compiler your gnucobol build was generated for.</source>
          <target state="translated">Use this feature at your own risk &amp;ndash; you should always use the c compiler your gnucobol build was generated for.</target>
        </trans-unit>
        <trans-unit id="b352a48d49f68999049e3808aeb8142eebfd14e0" translate="yes" xml:space="preserve">
          <source>Use this function to determine and return the trigonometric arc-tangent, or inverse tangent, of &lt;var&gt;tangent&lt;/var&gt; value (a numeric literal or data item) supplied as an argument.</source>
          <target state="translated">Use this function to determine and return the trigonometric arc-tangent, or inverse tangent, of &lt;var&gt;tangent&lt;/var&gt; value (a numeric literal or data item) supplied as an argument.</target>
        </trans-unit>
        <trans-unit id="36da13391a38405613799a008e90c2843050db55" translate="yes" xml:space="preserve">
          <source>Use this statement to increment or decrement the value of an index or pointer by a specified amount.</source>
          <target state="translated">Use this statement to increment or decrement the value of an index or pointer by a specified amount.</target>
        </trans-unit>
        <trans-unit id="64d9c620ffd7b38a0d416aebe327254a87d26c11" translate="yes" xml:space="preserve">
          <source>Use this subroutine to copy file &lt;var&gt;src-file-path&lt;/var&gt; to &lt;var&gt;dest-file-path&lt;/var&gt; as if it were done via the &lt;code&gt;cp&lt;/code&gt; (Unix/OSX) or &lt;code&gt;COPY&lt;/code&gt; (Windows) command.</source>
          <target state="translated">Use this subroutine to copy file &lt;var&gt;src-file-path&lt;/var&gt; to &lt;var&gt;dest-file-path&lt;/var&gt; as if it were done via the &lt;code&gt;cp&lt;/code&gt; (Unix/OSX) or &lt;code&gt;COPY&lt;/code&gt; (Windows) command.</target>
        </trans-unit>
        <trans-unit id="f19b44f4737f057c6473c94d5fb08b2debecb598" translate="yes" xml:space="preserve">
          <source>Use this subroutine to retrieve the current console screen size.</source>
          <target state="translated">Use this subroutine to retrieve the current console screen size.</target>
        </trans-unit>
        <trans-unit id="dbc25f0825e8fe418dc8901acbb7dc9aca0481ee" translate="yes" xml:space="preserve">
          <source>Use this subroutine to return the PID (process ID) of the executing GnuCOBOL program. The PID value is returned into the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;).</source>
          <target state="translated">Use this subroutine to return the PID (process ID) of the executing GnuCOBOL program. The PID value is returned into the &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="3e6837cd5f7c10330960b6d4123be7352b790cc4" translate="yes" xml:space="preserve">
          <source>User-Defined Function</source>
          <target state="translated">사용자 정의 기능</target>
        </trans-unit>
        <trans-unit id="90912dab063fcb2124df96e643e8ab0464a51dc5" translate="yes" xml:space="preserve">
          <source>User-Defined Names</source>
          <target state="translated">사용자 정의 이름</target>
        </trans-unit>
        <trans-unit id="bab3f28c55547733b50c8d784809fb7fe88b3298" translate="yes" xml:space="preserve">
          <source>User-defined functions (i.e. &lt;code&gt;FUNCTION-ID&lt;/code&gt;) are always recursive.</source>
          <target state="translated">User-defined functions (i.e. &lt;code&gt;FUNCTION-ID&lt;/code&gt; ) are always recursive.</target>
        </trans-unit>
        <trans-unit id="d6b3ce6e7694d86d90e740481f312ce05fcd9c4d" translate="yes" xml:space="preserve">
          <source>User-defined functions (i.e.&lt;code&gt;FUNCTION-ID&lt;/code&gt; are always recursive.</source>
          <target state="translated">사용자 정의 함수 (예 : &lt;code&gt;FUNCTION-ID&lt;/code&gt; ) 는 항상 재귀 적입니다.</target>
        </trans-unit>
        <trans-unit id="1fc4ac540a1a64364793a04fa696f3ddff4bcdfc" translate="yes" xml:space="preserve">
          <source>User-defined words may be composed from the characters &quot;A&quot; through &quot;Z&quot; (upper- and/or lower-case), &quot;0&quot; through &quot;9&quot;, dash (&quot;-&quot;)</source>
          <target state="translated">사용자 정의 단어는 &quot;A&quot;~ &quot;Z&quot;(대문자 및 / 또는 소문자), &quot;0&quot;~ ​​&quot;9&quot;, 대시 ( &quot;-&quot;) 문자로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19d1fc4876e2b1f2e9f75a463b3a0b93d9095ee8" translate="yes" xml:space="preserve">
          <source>User-defined words may be composed from the characters &amp;lsquo;</source>
          <target state="translated">User-defined words may be composed from the characters &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="128f583a5b32fe803a8ac9c034e0c7e1a0586868" translate="yes" xml:space="preserve">
          <source>User-written functions (see &lt;a href=&quot;#Subprogram-Types&quot;&gt;Subprogram Types&lt;/a&gt;) never require the &lt;code&gt;FUNCTION&lt;/code&gt; keyword when they are executed, because each user-written function a program uses</source>
          <target state="translated">User-written functions (see &lt;a href=&quot;#Subprogram-Types&quot;&gt;Subprogram Types&lt;/a&gt;) never require the &lt;code&gt;FUNCTION&lt;/code&gt; keyword when they are executed, because each user-written function a program uses</target>
        </trans-unit>
        <trans-unit id="e0d6673b38b9cdf2e1a6d43c1347627240486119" translate="yes" xml:space="preserve">
          <source>User-written functions (see &lt;a href=&quot;#Subprogram-Types&quot;&gt;Subprogram Types&lt;/a&gt;) never require the&lt;code&gt;FUNCTION&lt;/code&gt;keyword when they are executed, because each user-written function a program uses</source>
          <target state="translated">사용자 작성 함수 ( &lt;a href=&quot;#Subprogram-Types&quot;&gt;하위 프로그램 유형&lt;/a&gt; 참조 ) 는 프로그램이 사용하는 각 사용자 작성 함수로 인해 실행될 때 &lt;code&gt;FUNCTION&lt;/code&gt; 키워드를 요구하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2d361932d2db4fa457a5f503d958c818df2ef65" translate="yes" xml:space="preserve">
          <source>Using &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="1cf67a3e1b5ff4de97b2852cdc4456e7da79fabf" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;COMMAND-LINE&lt;/code&gt; or &lt;code&gt;ARGUMENT-VALUE&lt;/code&gt; in a *nix based platform and that includes Linux, OSX, BSD and under windows running msys or MinGW etc, the shell process will expand any arguments that have a &amp;lsquo;</source>
          <target state="translated">Using &lt;code&gt;COMMAND-LINE&lt;/code&gt; or &lt;code&gt;ARGUMENT-VALUE&lt;/code&gt; in a *nix based platform and that includes Linux, OSX, BSD and under windows running msys or MinGW etc, the shell process will expand any arguments that have a &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="acd26437278789f129c6153d2ded460ab33bdeda" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;DELIMITED BY &lt;var&gt;literal-2&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;DELIMITED BY &lt;var&gt;identifier-2&lt;/var&gt;&lt;/code&gt; causes only the contents of the source item up to but not including the character sequence specified by the literal or identifier to be copied.</source>
          <target state="translated">Using &lt;code&gt;DELIMITED BY &lt;var&gt;literal-2&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;DELIMITED BY &lt;var&gt;identifier-2&lt;/var&gt;&lt;/code&gt; causes only the contents of the source item up to but not including the character sequence specified by the literal or identifier to be copied.</target>
        </trans-unit>
        <trans-unit id="cab5d9e54511393d0f2c1c80f82b479a4c4acb74" translate="yes" xml:space="preserve">
          <source>Using &lt;var&gt;identifier&lt;/var&gt; rather than &lt;var&gt;integer&lt;/var&gt; specifications in the &lt;code&gt;RD&lt;/code&gt; will give your program the ability &amp;mdash; at run time &amp;mdash; to accommodate multiple printers, fonts, font sizes and paper orientation. Just follow the above steps for each combination you wish your program to support.</source>
          <target state="translated">Using &lt;var&gt;identifier&lt;/var&gt; rather than &lt;var&gt;integer&lt;/var&gt; specifications in the &lt;code&gt;RD&lt;/code&gt; will give your program the ability &amp;mdash; at run time &amp;mdash; to accommodate multiple printers, fonts, font sizes and paper orientation. Just follow the above steps for each combination you wish your program to support.</target>
        </trans-unit>
        <trans-unit id="63c509b61bff1b104d3ee2d55975c668f3f4cfbc" translate="yes" xml:space="preserve">
          <source>Using a</source>
          <target state="translated">Using a</target>
        </trans-unit>
        <trans-unit id="15ddc9249fd1dd26ef0729a51c2fe7bf64de6337" translate="yes" xml:space="preserve">
          <source>Using a compiler option switch &amp;mdash; use the</source>
          <target state="translated">Using a compiler option switch &amp;mdash; use the</target>
        </trans-unit>
        <trans-unit id="6d25575124f2b1d21418340870745666f2f2eccf" translate="yes" xml:space="preserve">
          <source>Using a compiler option switch &amp;mdash; use the&lt;code&gt;-fixed&lt;/code&gt;switch</source>
          <target state="translated">컴파일러 옵션 스위치 사용 &amp;mdash; &lt;code&gt;-fixed&lt;/code&gt; 스위치 사용</target>
        </trans-unit>
        <trans-unit id="bf0e03ebfa108b2c88b9744b24c7946ec2982481" translate="yes" xml:space="preserve">
          <source>Using methods 2-4 above, you may switch back and forth between the two formats at will.</source>
          <target state="translated">위의 방법 2-4를 사용하면 마음대로 두 형식간에 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30fc2e97060231bd35e5ef9e873ee5e07f7e8bf0" translate="yes" xml:space="preserve">
          <source>Using programs that, for the most part, are much more self-documenting than would be the case with any other programming language.</source>
          <target state="translated">대부분의 경우 다른 프로그래밍 언어의 경우보다 훨씬 더 많은 자체 문서화 프로그램을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="30a128e6f79bf550eb1584fb0a87431c9b8a02a5" translate="yes" xml:space="preserve">
          <source>Using relative column positioning (&lt;code&gt;COLUMN PLUS&lt;/code&gt;) has slightly different behaviour depending upon the section in which the clause is used, as follows:</source>
          <target state="translated">Using relative column positioning ( &lt;code&gt;COLUMN PLUS&lt;/code&gt; ) has slightly different behaviour depending upon the section in which the clause is used, as follows:</target>
        </trans-unit>
        <trans-unit id="dce1ca9279ec7bad57a4928960fcf2964806a117" translate="yes" xml:space="preserve">
          <source>Using relative column positioning &lt;code&gt;COLUMN PLUS&lt;/code&gt; has slightly different behaviour depending upon the section in which the clause is used, as follows:</source>
          <target state="translated">상대 열 위치 지정 사용 &lt;code&gt;COLUMN PLUS&lt;/code&gt; 는 다음과 같이 절이 사용되는 섹션에 따라 동작이 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="26d69b7e96871e0aed8ae7a52d627672b46957a3" translate="yes" xml:space="preserve">
          <source>Using the  &lt;code&gt;ALL&lt;/code&gt; option allows a delimiter sequence to be an arbitrarily long sequence of occurrences of the delimiter literal whereas its absence treats each occurrence as a separate delimiter. When multiple delimiters are specified, they will be looked for in the source string in the sequence in which they are coded.</source>
          <target state="translated">Using the &lt;code&gt;ALL&lt;/code&gt; option allows a delimiter sequence to be an arbitrarily long sequence of occurrences of the delimiter literal whereas its absence treats each occurrence as a separate delimiter. When multiple delimiters are specified, they will be looked for in the source string in the sequence in which they are coded.</target>
        </trans-unit>
        <trans-unit id="47886faa714a780188b89a7f041cb7c35d6aa955" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;DECIMAL-POINT IS COMMA&lt;/code&gt; (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) clause in your program will not affect the value returned by this function.</source>
          <target state="translated">Using the &lt;code&gt;DECIMAL-POINT IS COMMA&lt;/code&gt; (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) clause in your program will not affect the value returned by this function.</target>
        </trans-unit>
        <trans-unit id="893f177cf329eeac65620415a2ea84c4dfcdffd0" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;STATIC&lt;/code&gt; option on a &lt;code&gt;CALL&lt;/code&gt; statement is equivalent to using &lt;code&gt;CALL-CONVENTION 8&lt;/code&gt; (only bit 3 set).</source>
          <target state="translated">Using the &lt;code&gt;STATIC&lt;/code&gt; option on a &lt;code&gt;CALL&lt;/code&gt; statement is equivalent to using &lt;code&gt;CALL-CONVENTION 8&lt;/code&gt; (only bit 3 set).</target>
        </trans-unit>
        <trans-unit id="066046976cfbe19ee059e1051f98a56d6193f86b" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;STATUS&lt;/code&gt; clause without a &lt;var&gt;literal-2&lt;/var&gt; or &lt;var&gt;identifier-2&lt;/var&gt; will return an exit status of 0 if the  &lt;code&gt;NORMAL&lt;/code&gt; keyword is used or a 1 if  &lt;code&gt;ERROR&lt;/code&gt; was specified.</source>
          <target state="translated">Using the &lt;code&gt;STATUS&lt;/code&gt; clause without a &lt;var&gt;literal-2&lt;/var&gt; or &lt;var&gt;identifier-2&lt;/var&gt; will return an exit status of 0 if the &lt;code&gt;NORMAL&lt;/code&gt; keyword is used or a 1 if &lt;code&gt;ERROR&lt;/code&gt; was specified.</target>
        </trans-unit>
        <trans-unit id="2ec550462e395d32bf5f8163a92904f4b9b580de" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;STDCALL&lt;/code&gt; option on a &lt;code&gt;CALL&lt;/code&gt; statement is equivalent to using &lt;code&gt;CALL CONVENTION 64&lt;/code&gt; (only bit 6 set).</source>
          <target state="translated">Using the &lt;code&gt;STDCALL&lt;/code&gt; option on a &lt;code&gt;CALL&lt;/code&gt; statement is equivalent to using &lt;code&gt;CALL CONVENTION 64&lt;/code&gt; (only bit 6 set).</target>
        </trans-unit>
        <trans-unit id="364ebd5efd21da183fb00b1c6ce4d7d1330a8f9c" translate="yes" xml:space="preserve">
          <source>Using the&lt;code&gt;ALL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ALL&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="5c7418af4591ec3349c45d28db0db908a5995065" translate="yes" xml:space="preserve">
          <source>Using the&lt;code&gt;DECIMAL-POINT IS COMMA&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) clause in your program will not affect the value returned by this function.</source>
          <target state="translated">프로그램에서 &lt;code&gt;DECIMAL-POINT IS COMMA&lt;/code&gt; ( &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 참조 ) 절을 사용 해도이 함수가 반환하는 값에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d7bec9edfe24f7bc97ad7025c81773afc592db4" translate="yes" xml:space="preserve">
          <source>Using the&lt;code&gt;STATIC&lt;/code&gt;option on a&lt;code&gt;CALL&lt;/code&gt;statement is equivalent to using&lt;code&gt;CALL CONVENTION 64&lt;/code&gt;(only bit 6 set).</source>
          <target state="translated">&lt;code&gt;CALL&lt;/code&gt; 문 에서 &lt;code&gt;STATIC&lt;/code&gt; 옵션을 사용하는 것은 &lt;code&gt;CALL CONVENTION 64&lt;/code&gt; (비트 6 만 설정) 를 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="dcda3f19c20b8f12cf9e41bdefb3336575eeba80" translate="yes" xml:space="preserve">
          <source>Using the&lt;code&gt;STATUS&lt;/code&gt;clause without a &amp;lt;</source>
          <target state="translated">&amp;lt;없이 &lt;code&gt;STATUS&lt;/code&gt; 절 사용</target>
        </trans-unit>
        <trans-unit id="1cbde56e4687cbd99f85608012c26564941b51d8" translate="yes" xml:space="preserve">
          <source>Using the&lt;code&gt;STDCALL&lt;/code&gt;option on a&lt;code&gt;CALL&lt;/code&gt;statement is equivalent to using&lt;code&gt;CALL-CONVENTION 8&lt;/code&gt;(only bit 3 set).</source>
          <target state="translated">&lt;code&gt;CALL&lt;/code&gt; 문 에서 &lt;code&gt;STDCALL&lt;/code&gt; 옵션을 사용하는 것은 &lt;code&gt;CALL-CONVENTION 8&lt;/code&gt; (비트 3 만 설정) 을 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c2eaee1513738c874413763271210c49804e8aa8" translate="yes" xml:space="preserve">
          <source>Using this clause with any organization other than &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; will either be rejected outright by the compiler (relative or indexed files) or may introduce unwanted characters into the file (&lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;)).</source>
          <target state="translated">Using this clause with any organization other than &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; will either be rejected outright by the compiler (relative or indexed files) or may introduce unwanted characters into the file ( &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;)).</target>
        </trans-unit>
        <trans-unit id="055069cd0b3ac72305253e471732284f0ce7b811" translate="yes" xml:space="preserve">
          <source>Using this clause with any organization other than&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;will either be rejected outright by the compiler (relative or indexed files) or may introduce unwanted characters into the file &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;)).</source>
          <target state="translated">&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; 이외의 다른 조직에서이 절을 사용 하면 컴파일러 (상대 또는 색인화 된 파일)가 즉시 거부하거나 &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; 파일에 원하지 않는 문자를 도입 할 수 있습니다 ( &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="671601f0bca9ccc4264cb0e6764f25ad943abbeb" translate="yes" xml:space="preserve">
          <source>Using this, you may replace character sequences that occur at the beginning (see  &lt;code&gt;LEADING&lt;/code&gt;) or end (see  &lt;code&gt;TRAILING&lt;/code&gt;) of reserved or user-defined words. For example, to change all words of the form &quot;0100-xxxxxx&quot; to &quot;020-xxxxxx&quot;, code &lt;code&gt;LEADING ==0100-== BY ==020-==&lt;/code&gt;. To simply remove all &quot;0100-&quot; prefixes from words, code &lt;code&gt;LEADING ==0100-== BY ====&lt;/code&gt;.</source>
          <target state="translated">Using this, you may replace character sequences that occur at the beginning (see &lt;code&gt;LEADING&lt;/code&gt; ) or end (see &lt;code&gt;TRAILING&lt;/code&gt; ) of reserved or user-defined words. For example, to change all words of the form &quot;0100-xxxxxx&quot; to &quot;020-xxxxxx&quot;, code &lt;code&gt;LEADING ==0100-== BY ==020-==&lt;/code&gt; . To simply remove all &quot;0100-&quot; prefixes from words, code &lt;code&gt;LEADING ==0100-== BY ====&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d045dc0df6c82b505ff2b86a71d9d7ecfebed4da" translate="yes" xml:space="preserve">
          <source>Using this, you may replace character sequences that occur at the beginning &lt;code&gt;LEADING&lt;/code&gt;</source>
          <target state="translated">이 사용하면 처음에 발생 문자 시퀀스를 대체 할 수 &lt;code&gt;LEADING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="473751d4f457e913755e0b7d0834b9e83484f656" translate="yes" xml:space="preserve">
          <source>Using&lt;code&gt;DELIMITED BY &amp;lt;&lt;i&gt;literal-2&lt;/i&gt;&amp;gt;&lt;/code&gt;or&lt;code&gt;DELIMITED BY &amp;lt;&lt;i&gt;identifier-2&lt;/i&gt;&amp;gt;&lt;/code&gt;causes only the contents of the source item up to but not including the character sequence specified by the literal or identifier to be copied.</source>
          <target state="translated">사용 &lt;code&gt;DELIMITED BY &amp;lt;&lt;i&gt;literal-2&lt;/i&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;DELIMITED BY &amp;lt;&lt;i&gt;identifier-2&lt;/i&gt;&amp;gt;&lt;/code&gt; 최대하지만 문자 또는 식별자를 복사 할 수로 지정된 문자 순서를 포함하지 않고 소스 항목의 내용 만됩니다.</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="5d1ad554e0d92c73f5806ac5626ba8fead7eeabd" translate="yes" xml:space="preserve">
          <source>V, VALID, VALIDATE, VALIDATE-STATUS, VAL-STATUS, VALUE, VALUES, VARIABLE, VARIANCE, VARYING</source>
          <target state="translated">V, VALID, VALIDATE, VALIDATE-STATUS, VAL-STATUS, VALUE, VALUES, VARIABLE, VARIANCE, VARYING</target>
        </trans-unit>
        <trans-unit id="6e1551f6391a4d91b4d689da6ddb8521cbaaa996" translate="yes" xml:space="preserve">
          <source>V, VALIDATE-STATUS, VALIDATE, VALID, VAL-STATUS, VALUE-FORMAT, VALUES, VALUE, VARIABLE, VARIANCE, VARIANT, VARYING, VERTICAL, VERY-HEAVY, VIRTUAL-WIDTH, VPADDING, VSCROLL-BAR, VSCROLL-POS, VSCROLL, VTOP</source>
          <target state="translated">V, VALIDATE-STATUS, VALIDATE, VALID, VAL-STATUS, VALUE-FORMAT, VALUES, VALUE, VARIABLE, VARIANCE, VARIANT, VARYING, VERTICAL, VERY-HEAVY, VIRTUAL-WIDTH, VPADDING, VSCROLL-BAR, VSCROLL-POS, VSCROLL, VTOP</target>
        </trans-unit>
        <trans-unit id="ebc6e4ee470001bf8e164fc1af3e6959efcb65bb" translate="yes" xml:space="preserve">
          <source>VALUE (Condition Names) Clause Syntax</source>
          <target state="translated">VALUE (조건 이름) 절 구문</target>
        </trans-unit>
        <trans-unit id="63cd3ebb0fb81cea3748b8d9509c32ae6fe58ee7" translate="yes" xml:space="preserve">
          <source>VALUE (Other Data Items) Syntax</source>
          <target state="translated">VALUE (기타 데이터 항목) 구문</target>
        </trans-unit>
        <trans-unit id="f93f233c1e3f1c1329fd9fd4d748269757ee2f23" translate="yes" xml:space="preserve">
          <source>VARIANCE Function Syntax</source>
          <target state="translated">VARIANCE 함수 구문</target>
        </trans-unit>
        <trans-unit id="d8eedc8107b965cbde0511d027a2377e39a085bf" translate="yes" xml:space="preserve">
          <source>VARYING Syntax</source>
          <target state="translated">다양한 구문</target>
        </trans-unit>
        <trans-unit id="1460437d17a2fe697f601b3af9079d9a98ae5afb" translate="yes" xml:space="preserve">
          <source>VARYING-Clause</source>
          <target state="translated">VARYING-Clause</target>
        </trans-unit>
        <trans-unit id="ce1b089a7469f7a7435681b1daa0f9444f349773" translate="yes" xml:space="preserve">
          <source>Valid return code values can be in the range -2147483648 to +2147483647.</source>
          <target state="translated">유효한 리턴 코드 값은 -2147483648에서 +2147483647 범위에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06b8a672cadb78c6399afa356021a887f83eef82" translate="yes" xml:space="preserve">
          <source>Value For Positive</source>
          <target state="translated">긍정적 인 가치</target>
        </trans-unit>
        <trans-unit id="867cb97da0125676cf5656c5dafc6e5f822d8d38" translate="yes" xml:space="preserve">
          <source>Value for Negative</source>
          <target state="translated">부정적 가치</target>
        </trans-unit>
        <trans-unit id="ce10391642834208f65de6172d958c969f7f4bc8" translate="yes" xml:space="preserve">
          <source>Values of 0 will be returned if GnuCOBOL was not generated to include screen I/O.</source>
          <target state="translated">화면 I / O를 포함하도록 GnuCOBOL이 생성되지 않은 경우 0 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="81cad7d9a6789eaf829d8bb24bf8cd92e85aefe9" translate="yes" xml:space="preserve">
          <source>Values of 1 (Line) and 1 (column) will be returned if GnuCOBOL was not generated to include screen I/O.</source>
          <target state="translated">화면 I / O를 포함하도록 GnuCOBOL이 생성되지 않은 경우 1 (행) 및 1 (열) 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b814d960006b5980858a36bc094f395a0b420215" translate="yes" xml:space="preserve">
          <source>Values other than 0 or 1 will be ignored.</source>
          <target state="translated">0 또는 1 이외의 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="655249fc2f22beeccfa0d8e17b14dfe0bbd81872" translate="yes" xml:space="preserve">
          <source>Various implementations of COBOL generate object code that is quite different in each of these three situations, and GnuCOBOL is no exception.</source>
          <target state="translated">다양한 COBOL 구현은 이러한 세 가지 상황에서 각각 다른 객체 코드를 생성하며 GnuCOBOL도 예외는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="33817a63b651d4a84e7a5d740d58bef5f67a6a2a" translate="yes" xml:space="preserve">
          <source>Verb</source>
          <target state="translated">Verb</target>
        </trans-unit>
        <trans-unit id="8f924ae8f2821ea13136a49a2f30149c04dea61b" translate="yes" xml:space="preserve">
          <source>Vertical bar meta characters on syntax diagrams document simple choices. The | character itself should not be coded. If a syntax diagram contains &quot;a|b|c&quot;, exactly one of the items &quot;a&quot;, &quot;b&quot; or &quot;c&quot; must be selected.</source>
          <target state="translated">구문 다이어그램의 세로 막대 메타 문자는 간단한 선택을 문서화합니다. | 문자 자체는 코딩해서는 안됩니다. 구문 다이어그램에 &quot;a | b | c&quot;가 포함 된 경우 &quot;a&quot;, &quot;b&quot;또는 &quot;c&quot;항목 중 정확히 하나를 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="7c4756422445bc9c577ecd746a5b9ba73c1eff99" translate="yes" xml:space="preserve">
          <source>Vertical bar meta characters on syntax diagrams document simple choices. The | character itself should not be coded. If a syntax diagram contains &amp;lsquo;</source>
          <target state="translated">Vertical bar meta characters on syntax diagrams document simple choices. The | character itself should not be coded. If a syntax diagram contains &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="4b02a108ff9740e9b09f581e1394df2123dfcb80" translate="yes" xml:space="preserve">
          <source>WAIT, WEB-BROWSER, WHEN-COMPILED, WHEN, WIDTH-IN-CELLS, WIDTH, WINDOW, WITH, WORDS, WORKING-STORAGE, WRAP, WRITE</source>
          <target state="translated">WAIT, WEB-BROWSER, WHEN-COMPILED, WHEN, WIDTH-IN-CELLS, WIDTH, WINDOW, WITH, WORDS, WORKING-STORAGE, WRAP, WRITE</target>
        </trans-unit>
        <trans-unit id="865bd476e8da657a3730a2cf5b4afe0ce5ef5c72" translate="yes" xml:space="preserve">
          <source>WAIT, WHEN, WHEN-COMPILED, WITH, WORDS, WORKING-STORAGE, WRITE</source>
          <target state="translated">대기 시간, 종료시, 단어, 작업 스토리지, 쓰기</target>
        </trans-unit>
        <trans-unit id="9526c3fde17971c75db66951966656c3a9bcdf06" translate="yes" xml:space="preserve">
          <source>WHEN-COMPILED Function Syntax</source>
          <target state="translated">언제 COMPILED 함수 구문</target>
        </trans-unit>
        <trans-unit id="eb822949005337e6f85298a3d973233e7426e7e6" translate="yes" xml:space="preserve">
          <source>WITH IGNORE LOCK</source>
          <target state="translated">WITH IGNORE LOCK</target>
        </trans-unit>
        <trans-unit id="b8afbfcec0d7323da75e2cbb6538598b82bc6ba1" translate="yes" xml:space="preserve">
          <source>WORKING-STORAGE-SECTION-Data-Item</source>
          <target state="translated">WORKING-STORAGE-SECTION-Data-Item</target>
        </trans-unit>
        <trans-unit id="e509974f5343f06b8c28dd65e19b1ca0fc9e9e74" translate="yes" xml:space="preserve">
          <source>WORKING-STORAGE-SECTION-Data-Item Syntax</source>
          <target state="translated">작업 스토리지 섹션 데이터 항목 구문</target>
        </trans-unit>
        <trans-unit id="8a3a0314ec970477daf2970487711f5978bc099d" translate="yes" xml:space="preserve">
          <source>WRITE Syntax</source>
          <target state="translated">쓰기 구문</target>
        </trans-unit>
        <trans-unit id="f45cbc8c5e7bd33a44cf369d47aa331b8d8c068c" translate="yes" xml:space="preserve">
          <source>Waits until a character is typed from the terminal and then read it with no echo.</source>
          <target state="translated">Waits until a character is typed from the terminal and then read it with no echo.</target>
        </trans-unit>
        <trans-unit id="b5d0d2442446a0984eace1334dc2326c64f266c7" translate="yes" xml:space="preserve">
          <source>We first need to define the necessary fields for &lt;code&gt;getopt&lt;/code&gt;&amp;rsquo;s &lt;code&gt;shortoptions&lt;/code&gt;, &lt;code&gt;longoptions&lt;/code&gt;, longoption index (&lt;code&gt;longind&lt;/code&gt;), long-only-option (&lt;code&gt;long-only&lt;/code&gt;) and also the fields for return values &lt;code&gt;return-char&lt;/code&gt; and &lt;code&gt;opt-val&lt;/code&gt; (arbitrary size with trimming, see return codes).</source>
          <target state="translated">We first need to define the necessary fields for &lt;code&gt;getopt&lt;/code&gt; &amp;rsquo;s &lt;code&gt;shortoptions&lt;/code&gt; , &lt;code&gt;longoptions&lt;/code&gt; , longoption index ( &lt;code&gt;longind&lt;/code&gt; ), long-only-option ( &lt;code&gt;long-only&lt;/code&gt; ) and also the fields for return values &lt;code&gt;return-char&lt;/code&gt; and &lt;code&gt;opt-val&lt;/code&gt; (arbitrary size with trimming, see return codes).</target>
        </trans-unit>
        <trans-unit id="71b237df64f9b51f1237736626ec7b82bf855929" translate="yes" xml:space="preserve">
          <source>What constitutes a &quot;letter&quot; (or upper/lower case too, for that manner) may be influenced through the use of a&lt;code&gt;CHARACTER CLASSIFICATION&lt;/code&gt;(see &lt;a href=&quot;#OBJECT_002dCOMPUTER&quot;&gt;OBJECT-COMPUTER&lt;/a&gt;).</source>
          <target state="translated">&quot;문자&quot;(또는 그와 같은 경우 대문자 / 소문자도)를 구성하는 것은 &lt;code&gt;CHARACTER CLASSIFICATION&lt;/code&gt; 사용하여 영향을받을 수 있습니다 ( &lt;a href=&quot;#OBJECT_002dCOMPUTER&quot;&gt;OBJECT-COMPUTER&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="29441701dad2a582893fec0037bff4289869ec3c" translate="yes" xml:space="preserve">
          <source>What constitutes a &amp;ldquo;letter&amp;rdquo; (or upper/lower case too, for that manner) may be influenced through the use of a &lt;code&gt;CHARACTER CLASSIFICATION&lt;/code&gt; (see &lt;a href=&quot;#OBJECT_002dCOMPUTER&quot;&gt;OBJECT-COMPUTER&lt;/a&gt;).</source>
          <target state="translated">What constitutes a &amp;ldquo;letter&amp;rdquo; (or upper/lower case too, for that manner) may be influenced through the use of a &lt;code&gt;CHARACTER CLASSIFICATION&lt;/code&gt; (see &lt;a href=&quot;#OBJECT_002dCOMPUTER&quot;&gt;OBJECT-COMPUTER&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="7a5dc3b00fd066d729c12426c404973d472ba142" translate="yes" xml:space="preserve">
          <source>What font and font size will be used for the report when it is printed? RWCS-generated reports will assume that a fixed-width font such as &quot;Courier&quot;, &quot;Lucida Console&quot;, &quot;Consolas&quot; and the like will be used to print, as variable-pitch fonts would make the proper alignment of columns of data on reports virtually impossible.</source>
          <target state="translated">보고서를 인쇄 할 때 어떤 글꼴 및 글꼴 크기가 사용됩니까? RWCS 생성 보고서는 가변 피치 글꼴이 사실상 불가능한보고.</target>
        </trans-unit>
        <trans-unit id="de610c0aff735898bc9148d35a86dc67ae2cff5c" translate="yes" xml:space="preserve">
          <source>What font and font size will be used for the report when it is printed? RWCS-generated reports will assume that a fixed-width font such as &amp;ldquo;Courier&amp;rdquo;, &amp;ldquo;Lucida Console&amp;rdquo;, &amp;ldquo;Consolas&amp;rdquo; and the like will be used to print, as variable-pitch fonts would make the proper alignment of columns of data on reports virtually impossible.</source>
          <target state="translated">What font and font size will be used for the report when it is printed? RWCS-generated reports will assume that a fixed-width font such as &amp;ldquo;Courier&amp;rdquo;, &amp;ldquo;Lucida Console&amp;rdquo;, &amp;ldquo;Consolas&amp;rdquo; and the like will be used to print, as variable-pitch fonts would make the proper alignment of columns of data on reports virtually impossible.</target>
        </trans-unit>
        <trans-unit id="bbdcaf0e5f1badb74e39f4542272bcd8c71b4fe2" translate="yes" xml:space="preserve">
          <source>What is the maximum number of characters that may be printed on one line?</source>
          <target state="translated">한 줄에 인쇄 할 수있는 최대 문자 수는 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="3dfea8d0c26dbf8641b4160af02785df1d84b8c3" translate="yes" xml:space="preserve">
          <source>What is the maximum number of lines per page that may be printed on a single sheet of paper?</source>
          <target state="translated">한 장에 인쇄 할 수있는 페이지 당 최대 줄 수는 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="b95c1be1be9b54be43aa4ba3ab14463b33d596e0" translate="yes" xml:space="preserve">
          <source>What paper orientation will you use, &amp;mdash; Landscape (long edge of the paper at the top and bottom of page), or Portrait (long edge of the paper at the left and right of page)?</source>
          <target state="translated">가로 (페이지의 위쪽과 아래쪽에있는 용지의 긴 쪽) 또는 세로 (페이지의 왼쪽과 오른쪽에있는 용지의 긴 쪽)와 같은 용지 방향을 사용 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="2b65da80c1855dc3510a765ddb84dc985073cfee" translate="yes" xml:space="preserve">
          <source>What printer(s) will the report be printed on?</source>
          <target state="translated">보고서는 어떤 프린터에 인쇄됩니까?</target>
        </trans-unit>
        <trans-unit id="2e74d89aed0becdc4a29ee6ec0d6b154837ce475" translate="yes" xml:space="preserve">
          <source>What tool will be used to print the report (direct printing to the device, notepad.exe, MS-Word, &amp;hellip;)?</source>
          <target state="translated">보고서를 인쇄하는 데 어떤 도구가 사용됩니까 (장치에 직접 인쇄, notepad.exe, MS-Word 등)?</target>
        </trans-unit>
        <trans-unit id="e2d8267c9af661413ae4be4c24f13308f3a92cdd" translate="yes" xml:space="preserve">
          <source>What value will be stored in &lt;code&gt;I&lt;/code&gt;? The number 4, which is the result of subtracting the value of &lt;code&gt;D&lt;/code&gt; (2) from the value of &lt;code&gt;C&lt;/code&gt; (5) and then adding 1? Or, will it be the number 8, which is the value of adding 1 to the value of data item &lt;code&gt;C-D&lt;/code&gt; (7)?</source>
          <target state="translated">What value will be stored in &lt;code&gt;I&lt;/code&gt; ? The number 4, which is the result of subtracting the value of &lt;code&gt;D&lt;/code&gt; (2) from the value of &lt;code&gt;C&lt;/code&gt; (5) and then adding 1? Or, will it be the number 8, which is the value of adding 1 to the value of data item &lt;code&gt;C-D&lt;/code&gt; (7)?</target>
        </trans-unit>
        <trans-unit id="6a852f999ff1776e3230a0faadd9d1d3879bd2b8" translate="yes" xml:space="preserve">
          <source>What value will be stored in&lt;code&gt;I&lt;/code&gt; The number 4, which is the result of subtracting the value of&lt;code&gt;D&lt;/code&gt;(2) from the value of&lt;code&gt;C&lt;/code&gt;(5) and then adding 1? Or, will it be the number 8, which is the value of adding 1 to the value of data item&lt;code&gt;C-D&lt;/code&gt;(7)?</source>
          <target state="translated">어떤 값이 저장된다 &lt;code&gt;I&lt;/code&gt; 의 값을 뺀 결과 인 4 번, &lt;code&gt;D&lt;/code&gt; 의 값과 (2) &lt;code&gt;C&lt;/code&gt; (5), 그리고, 1을 가산을? 또는 데이터 항목 &lt;code&gt;C-D&lt;/code&gt; (7) 의 값에 1을 더한 값인 숫자 8 입니까?</target>
        </trans-unit>
        <trans-unit id="220c8174e91d00cfca62a9e329350d4d27cca908" translate="yes" xml:space="preserve">
          <source>Whatever precedes the &lt;code&gt;BY&lt;/code&gt; will be referred to here as the search string.</source>
          <target state="translated">Whatever precedes the &lt;code&gt;BY&lt;/code&gt; will be referred to here as the search string.</target>
        </trans-unit>
        <trans-unit id="acdaf525a738f8ef278213e37b2b43ac406e433a" translate="yes" xml:space="preserve">
          <source>Whatever precedes the&lt;code&gt;BY&lt;/code&gt;will be referred to here as the search string.</source>
          <target state="translated">&lt;code&gt;BY&lt;/code&gt; 앞에 오는 것은 여기에서 검색 문자열이라고합니다.</target>
        </trans-unit>
        <trans-unit id="aeef5350092ee5baaf3cc5b0719aaf340925ad2d" translate="yes" xml:space="preserve">
          <source>Wheel Down</source>
          <target state="translated">Wheel Down</target>
        </trans-unit>
        <trans-unit id="68a3c315167a38f981c6b88d233ee26356b21f8b" translate="yes" xml:space="preserve">
          <source>Wheel Left</source>
          <target state="translated">왼쪽 휠</target>
        </trans-unit>
        <trans-unit id="316c3e28d28a0dc6d99dfc2fe6f6963d0761e98c" translate="yes" xml:space="preserve">
          <source>Wheel Right</source>
          <target state="translated">오른쪽 휠</target>
        </trans-unit>
        <trans-unit id="747956308395803ba985d3349de43bb6d97dcab6" translate="yes" xml:space="preserve">
          <source>Wheel Up</source>
          <target state="translated">휠 업</target>
        </trans-unit>
        <trans-unit id="c8cbccc493315409c6e7f6385fbc6e392def9c4e" translate="yes" xml:space="preserve">
          <source>When  &lt;code&gt;BEFORE ADVANCING&lt;/code&gt; is used (or implied), the record is written to the file before the &lt;code&gt;ADVANCING&lt;/code&gt; action writes line-terminator characters to the file.</source>
          <target state="translated">시 &lt;code&gt;BEFORE ADVANCING&lt;/code&gt; 사용 (또는 암시)되어있는 전에 레코드가 파일에 기록됩니다 &lt;code&gt;ADVANCING&lt;/code&gt; 동작이 파일에 라인 종결 문자를 씁니다.</target>
        </trans-unit>
        <trans-unit id="7b2857b3676d4003591e5372fa2f9957a667138d" translate="yes" xml:space="preserve">
          <source>When  &lt;code&gt;USING&lt;/code&gt; is specified, none of the &lt;var&gt;file-name-1&lt;/var&gt; files may be open at the time the &lt;code&gt;SORT&lt;/code&gt; statement is executed.</source>
          <target state="translated">&lt;code&gt;USING&lt;/code&gt; 이 지정 되면 &lt;code&gt;SORT&lt;/code&gt; 문이 실행될 때 &lt;var&gt;file-name-1&lt;/var&gt; 파일이 열리지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc0254d7d342b46fa2084c28407845fb4ca60b36" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;DECLARATIVES&lt;/code&gt; (see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) are specified.</source>
          <target state="translated">때 &lt;code&gt;DECLARATIVES&lt;/code&gt; 는 (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES를&lt;/a&gt; ) 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="c46af1592f2e226ac4f29a5a0d35db657d35cd15" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;DISPLAY&lt;/code&gt; is used with Line and column where multiple variables or literals are used before &lt;code&gt;LINE&lt;/code&gt; only the first will be displayed.</source>
          <target state="translated">경우 &lt;code&gt;DISPLAY&lt;/code&gt; 는 라인과 컬럼에 사용되는 여러 변수 또는 리터럴 전에 사용되는 경우 &lt;code&gt;LINE&lt;/code&gt; 표시 될 첫 번째.</target>
        </trans-unit>
        <trans-unit id="d5e09bd291ece15d42088ab5350a942f350adcb2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;DISPLAY&lt;/code&gt; is used without line or column controls only one variable or literal may will appear on a line, so the use of the above example should also be employed.</source>
          <target state="translated">&lt;code&gt;DISPLAY&lt;/code&gt; 가 행 또는 열 제어없이 사용 되면 한 행에 하나의 변수 또는 리터럴 만 나타날 수 있으므로 위의 예를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb96235667ad9c3932fc9e36c2c407a3af6fa844" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GIVING&lt;/code&gt; is specified, none of the &lt;var&gt;file-name-3&lt;/var&gt; files can be open at the time the &lt;code&gt;MERGE&lt;/code&gt; statement is executed.</source>
          <target state="translated">&lt;code&gt;GIVING&lt;/code&gt; 이 지정 되면 &lt;code&gt;MERGE&lt;/code&gt; 문이 실행될 때 &lt;var&gt;file-name-3&lt;/var&gt; 파일을 열 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c258a6963cf9aded3d9775cc2fa6b1ee5182c083" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt; is specified, the &amp;lsquo;</source>
          <target state="translated">경우 &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt; 지정되면, '</target>
        </trans-unit>
        <trans-unit id="bf21c8ca51e8a77147b616e20a41440ee73b0798" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;WRITE&lt;/code&gt; is used against an &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt;) file, with or without the &lt;code&gt;LINE ADVANCING&lt;/code&gt; (see &lt;a href=&quot;#LINE-ADVANCING&quot;&gt;LINE ADVANCING&lt;/a&gt;) option, an end-of-record delimiter character sequence will be written to the file to signify where one record ends and the next record begins. This delimiter sequence will be either of the following:</source>
          <target state="translated">때 &lt;code&gt;WRITE&lt;/code&gt; 가 에 사용되는 &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;조직 LINE SEQUENTIAL&lt;/a&gt; 와 함께 또는없이, 파일)을 &lt;code&gt;LINE ADVANCING&lt;/code&gt; (참조 &lt;a href=&quot;#LINE-ADVANCING&quot;&gt;LINE 전진&lt;/a&gt; ) 옵션, 최종의 레코드 구분 문자 순서가 파일에 기록 될 위치를 하나 개의 레코드를 의미합니다 종료되고 다음 레코드가 시작됩니다. 이 구분 기호 시퀀스는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="e1f2e5f165dcc0919ed94a24e87936dac695bc95" translate="yes" xml:space="preserve">
          <source>When DEMOFACT is executed, the output shown below is generated.</source>
          <target state="translated">DEMOFACT가 실행되면 아래와 같은 출력이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e454e9d4e085d6ac64b7d40e4d1c8805cb4336a7" translate="yes" xml:space="preserve">
          <source>When a &amp;lt;</source>
          <target state="translated">때 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="fc7ce198e787169a5afbe1686eb836daadccd4ef" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt;) or &lt;code&gt;LINE ADVANCING&lt;/code&gt; (see &lt;a href=&quot;#LINE-ADVANCING&quot;&gt;LINE ADVANCING&lt;/a&gt;) file is closed, a final delimiter sequence will be written to the file to signal the termination point of the final data record in the file. This will only be necessary if the final record written to the file was written with the &lt;code&gt;AFTER ADVANCING&lt;/code&gt; (see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;) option.</source>
          <target state="translated">때 &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE 순차&lt;/a&gt; ) 또는 &lt;code&gt;LINE ADVANCING&lt;/code&gt; (참조 &lt;a href=&quot;#LINE-ADVANCING&quot;&gt;LINE 전진&lt;/a&gt; ) 파일을 닫고, 최종 분리 시퀀스 파일의 최종 데이터 기록의 종료 시점을 알리기 위해 파일에 기록한다. 이는 파일에 기록 된 최종 레코드가 &lt;code&gt;AFTER ADVANCING&lt;/code&gt; ( &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt; 참조 ) 옵션으로 기록 된 경우에만 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="8b2dce8d4fafda50efe8ee72eb2396a08e31b2c8" translate="yes" xml:space="preserve">
          <source>When a &lt;var&gt;picture-string&lt;/var&gt; contains a repeated sequence of symbols &amp;mdash; &lt;code&gt;PIC 9999/99/99&lt;/code&gt; &amp;mdash; for example, the repetition can be specified using a parenthetic repeat count, as in &lt;code&gt;PIC 9(4)/9(2)/9(2)&lt;/code&gt;. Using repeat counts is optional and their use (or not) is entirely at the discretion of the programmer. Many programmers use repetition for small sequences (&lt;code&gt;PIC XXX&lt;/code&gt;) and repeat counts for larger ones (&lt;code&gt;PIC 9(9)&lt;/code&gt;.</source>
          <target state="translated">때 &lt;var&gt;picture-string&lt;/var&gt; - 심볼들의 반복되는 시퀀스를 포함 &lt;code&gt;PIC 9999/99/99&lt;/code&gt; 를 - 예를 들면, 반복은 에서처럼 삽입구의 반복 카운트를 이용하여 지정 될 수 &lt;code&gt;PIC 9(4)/9(2)/9(2)&lt;/code&gt; . 반복 횟수를 사용하는 것은 선택 사항이며 사용 여부는 전적으로 프로그래머의 재량에 달려 있습니다. 많은 프로그래머는 작은 시퀀스 ( &lt;code&gt;PIC XXX&lt;/code&gt; )에 대해 반복을 사용하고 큰 시퀀스에 대해서는 반복 횟수 ( &lt;code&gt;PIC 9(9)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="580c29da61d60db4f7954f35a03a07e98ec1b5af" translate="yes" xml:space="preserve">
          <source>When a COBOL program needs to process string data prepared by a C program, the embedded null character must be accounted for. This can easily be accomplished with an &lt;code&gt;INSPECT&lt;/code&gt; statement (see &lt;a href=&quot;#INSPECT&quot;&gt;INSPECT&lt;/a&gt;) such as the following:</source>
          <target state="translated">COBOL 프로그램이 C 프로그램에서 준비한 문자열 데이터를 처리해야하는 경우 포함 된 널 문자를 고려해야합니다. 다음과 같은 &lt;code&gt;INSPECT&lt;/code&gt; 문 ( &lt;a href=&quot;#INSPECT&quot;&gt;INSPECT&lt;/a&gt; 참조 )으로 쉽게 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="071f0bb9b82c84d3aab4d8e0fd4613bf250b9554" translate="yes" xml:space="preserve">
          <source>When a COBOL program needs to process string data prepared by a C program, the embedded null character must be accounted for. This can easily be accomplished with an&lt;code&gt;INSPECT&lt;/code&gt;statement (see &lt;a href=&quot;#INSPECT&quot;&gt;INSPECT&lt;/a&gt;) such as the following:</source>
          <target state="translated">COBOL 프로그램이 C 프로그램에서 준비한 문자열 데이터를 처리해야하는 경우 임베드 된 널 문자를 고려해야합니다. 이것은 다음과 같은 &lt;code&gt;INSPECT&lt;/code&gt; 문 ( &lt;a href=&quot;#INSPECT&quot;&gt;INSPECT&lt;/a&gt; 참조 )으로 쉽게 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f28445311a32a41c9acb3c9113b8ad1f9db2af0" translate="yes" xml:space="preserve">
          <source>When a Format 1 &lt;code&gt;REPLACE&lt;/code&gt; statement with the  &lt;code&gt;ALSO&lt;/code&gt; keyword is encountered without Replace Mode being currently active, the effect will be as if the &lt;code&gt;ALSO&lt;/code&gt; had not been specified. If Replace Mode already was in effect, the effect will be to &amp;ldquo;push&amp;rdquo; the current change specification(s) onto the top of a stack and add the specification(s) of the new statement to those that were already in effect.</source>
          <target state="translated">대체 모드가 현재 활성화되지 않은 상태 에서 &lt;code&gt;ALSO&lt;/code&gt; 키워드가 있는 형식 1 &lt;code&gt;REPLACE&lt;/code&gt; 문 이 발견되면 &lt;code&gt;ALSO&lt;/code&gt; 가 지정되지 않은 것처럼 효과가 나타납니다 . Replace Mode가 이미 적용된 경우 현재 변경 사양을 스택 맨 위에 &quot;푸시&quot;하고 새 문의 사양을 이미 적용된 사양에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9242a69d328d85db3212fcc174551e14f2cac1fb" translate="yes" xml:space="preserve">
          <source>When a Format 1 &lt;code&gt;REPLACE&lt;/code&gt; without the &lt;code&gt;ALSO&lt;/code&gt; keyword is encountered, any stacked change specification(s), if any, will be discarded and the currently in-effect change specification(s), if any, will be replaced by those of the new statement.</source>
          <target state="translated">&lt;code&gt;ALSO&lt;/code&gt; 키워드가 없는 형식 1 &lt;code&gt;REPLACE&lt;/code&gt; 가 발견되면 스택 된 변경 스펙 (있는 경우)이 삭제되고 현재 유효한 변경 스펙 (있는 경우)이 새 명령문의 스펙으로 대체됩니다. .</target>
        </trans-unit>
        <trans-unit id="74c72b319d141b225148d238fb8c1fedb422ca16" translate="yes" xml:space="preserve">
          <source>When a Format 1&lt;code&gt;REPLACE&lt;/code&gt;statement with the&lt;code&gt;ALSO&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ALSO&lt;/code&gt; 가 있는 형식 1 &lt;code&gt;REPLACE&lt;/code&gt; 문</target>
        </trans-unit>
        <trans-unit id="609d85ba79405fab967ad11164a5456813a08759" translate="yes" xml:space="preserve">
          <source>When a Format 1&lt;code&gt;REPLACE&lt;/code&gt;without the&lt;code&gt;ALSO&lt;/code&gt;keyword is encountered, any stacked change specification(s), if any, will be discarded and the currently in-effect change specification(s), if any, will be replaced by those of the new statement.</source>
          <target state="translated">&lt;code&gt;ALSO&lt;/code&gt; 키워드가 없는 형식 1 &lt;code&gt;REPLACE&lt;/code&gt; 가 발생하면 누적 변경 스펙 (있는 경우)이 삭제되고 현재 적용중인 변경 스펙 (있는 경우)이 새 명령문의 스펙으로 대체됩니다. .</target>
        </trans-unit>
        <trans-unit id="1498c9493cd10edf878070c6850c4066fbd3931c" translate="yes" xml:space="preserve">
          <source>When a GnuCOBOL program is executed from a command-line, the complete command line text will be broken into a series of</source>
          <target state="translated">GnuCOBOL 프로그램이 명령 줄에서 실행되면 전체 명령 줄 텍스트가 일련의</target>
        </trans-unit>
        <trans-unit id="3e4370629d8db76dfdb59a6d547a7a75da5953b1" translate="yes" xml:space="preserve">
          <source>When a GnuCOBOL program is executed from a command-line, the complete command line text will be broken into a series of &quot;tokens&quot;, where each token is identified as being a word separated from the others in the command text by at least one space. For example, if the command line was &lt;code&gt;/usr/local/myprog THIS IS A TEST&lt;/code&gt;, there will be five tokens identified by the operating system &amp;mdash; &quot;/usr/local/myprog&quot;, &quot;THIS&quot;, &quot;IS&quot;, &quot;A&quot; and &quot;TEST&quot;.</source>
          <target state="translated">GnuCOBOL 프로그램이 명령 행에서 실행될 때, 전체 명령 행 텍스트는 일련의 &quot;토큰&quot;으로 분리되며, 여기서 각 토큰은 하나 이상의 공백으로 명령 텍스트에서 다른 토큰과 분리 된 단어로 식별됩니다. . 예를 들어, 명령 행이 &lt;code&gt;/usr/local/myprog THIS IS A TEST&lt;/code&gt; 경우 운영 체제에서 식별 한 토큰은 &quot;/ usr / local / myprog&quot;, &quot;THIS&quot;, &quot;IS&quot;, &quot;A&quot;입니다. 그리고 &quot;테스트&quot;.</target>
        </trans-unit>
        <trans-unit id="1968e3e733fa898eb7fff35a164afeee04aa71e6" translate="yes" xml:space="preserve">
          <source>When a dynamically-loadable module needs to be loaded (because it is not already in memory from a previous subprogram execution), the dynamically-loadable library will be sought in the same directory from which the main program was loaded. If it cannot be found there, each directory named in the</source>
          <target state="translated">동적으로로드 가능한 모듈을로드해야하는 경우 (이전 서브 프로그램 실행의 메모리에 아직 없기 때문에) 동적으로로드 가능한 라이브러리는 기본 프로그램이로드 된 동일한 디렉토리에 있습니다. 찾을 수없는 경우 각 디렉토리는</target>
        </trans-unit>
        <trans-unit id="607b1adbb25b590f97f525b3f9bc0233dd07cdd7" translate="yes" xml:space="preserve">
          <source>When a dynamically-loadable module needs to be loaded (because it is not already in memory from a previous subprogram execution), the dynamically-loadable library will be sought in the same directory from which the main program was loaded. If it cannot be found there, each directory named in the   &lt;code&gt;PATH&lt;/code&gt; run-time environment variable (see &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;Run Time Environment Variables&lt;/a&gt;) will be searched. If it was not located in any of those directories, the library specified by the   &lt;code&gt;COB_LIBRARY_PATH&lt;/code&gt; run-time environment variable will be searched. Finally, if it</source>
          <target state="translated">동적으로로드 할 수있는 모듈을로드해야하는 경우 (이전 서브 프로그램 실행에서 이미 메모리에 있지 않기 때문에) 동적으로로드 할 수있는 라이브러리는 주 프로그램이로드 된 동일한 디렉토리에서 검색됩니다. 여기서 찾을 수없는 경우 &lt;code&gt;PATH&lt;/code&gt; 런타임 환경 변수 ( &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;런타임&lt;/a&gt; 환경 변수 참조)에 이름이 지정된 각 디렉토리 가 검색됩니다. 해당 디렉토리에없는 경우 &lt;code&gt;COB_LIBRARY_PATH&lt;/code&gt; 런타임 환경 변수로 지정된 라이브러리 가 검색됩니다. 마지막으로</target>
        </trans-unit>
        <trans-unit id="51a8ed7ef35afd0920cf4174866afe1f0f667a87" translate="yes" xml:space="preserve">
          <source>When a function key (&lt;code&gt;F&lt;var&gt;n&lt;/var&gt;&lt;/code&gt;) is pressed.</source>
          <target state="translated">기능 키 ( &lt;code&gt;F&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; )를 눌렀을 때.</target>
        </trans-unit>
        <trans-unit id="8e4263cd1334069c6f7173b8ede8ed05ebf8464b" translate="yes" xml:space="preserve">
          <source>When a function key (Fn) is pressed.</source>
          <target state="translated">기능 키 (Fn)를 누를 때.</target>
        </trans-unit>
        <trans-unit id="ac45edb70ad44424b1a7876ade379c91f86efe2c" translate="yes" xml:space="preserve">
          <source>When a program or subprogram is first executed, much of the data in it&amp;rsquo;s data division will be initialized as follows:</source>
          <target state="translated">프로그램 또는 서브 프로그램이 처음 실행될 때, 데이터 분할의 많은 데이터는 다음과 같이 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="89e98bb604cd41e6cf702f2a531d5e3527af86e7" translate="yes" xml:space="preserve">
          <source>When a program or subprogram is first executed, much of the data in its data division will be initialized as follows:</source>
          <target state="translated">프로그램 또는 서브 프로그램이 처음 실행될 때 데이터 분할에있는 대부분의 데이터는 다음과 같이 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="facb9dbcd71a4e9843cdc8b09ad8afde94406f7e" translate="yes" xml:space="preserve">
          <source>When a report group&amp;rsquo;s presentation is suppressed, none of the following operations for the report will take place:</source>
          <target state="translated">보고서 그룹의 표시가 억제되면 보고서에 대해 다음 작업이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca3ab3a9579a8665008e315c51d31fce818d6ed6" translate="yes" xml:space="preserve">
          <source>When a subprogram is invoked, the flow of execution will differ slightly depending on whether the subprogram is a subroutine or a user-defined function.</source>
          <target state="translated">서브 프로그램이 호출되면 서브 플로우가 서브 루틴인지 사용자 정의 함수인지에 따라 실행 흐름이 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e464d636a741208aa64fc93f4b24867d5d99345a" translate="yes" xml:space="preserve">
          <source>When a subroutine argument is passed  &lt;code&gt;BY REFERENCE&lt;/code&gt;, the subroutine is passed the</source>
          <target state="translated">&lt;code&gt;BY REFERENCE&lt;/code&gt; 에 의해 서브 루틴 인수가 전달 되면 서브 루틴은</target>
        </trans-unit>
        <trans-unit id="940be2e3508e9644f58b55af8a2958ecec5b3cd5" translate="yes" xml:space="preserve">
          <source>When a subroutine argument is passed&lt;code&gt;BY REFERENCE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BY REFERENCE&lt;/code&gt; 에 의해 서브 루틴 인수가 전달 될 때</target>
        </trans-unit>
        <trans-unit id="ae3103f003b36016dadb24974a37cb3a0cd09f20" translate="yes" xml:space="preserve">
          <source>When a subroutine is &lt;code&gt;CALL&lt;/code&gt;ed:</source>
          <target state="translated">서브 루틴이 &lt;code&gt;CALL&lt;/code&gt; ed 일 때 :</target>
        </trans-unit>
        <trans-unit id="ed7dc6435382cc99c4b410b0a8c0f2d5f71430ef" translate="yes" xml:space="preserve">
          <source>When a subroutine is passed an argument  &lt;code&gt;BY CONTENT&lt;/code&gt;, the subroutine is passed the</source>
          <target state="translated">서브 루틴에 &lt;code&gt;BY CONTENT&lt;/code&gt; 인수 가 전달되면 서브 루틴은</target>
        </trans-unit>
        <trans-unit id="3f72daa026176d89a20466eece46174a0229f9e4" translate="yes" xml:space="preserve">
          <source>When a subroutine is passed an argument&lt;code&gt;BY CONTENT&lt;/code&gt;</source>
          <target state="translated">서브 루틴에 인수 &lt;code&gt;BY CONTENT&lt;/code&gt; 가 전달 될 때</target>
        </trans-unit>
        <trans-unit id="999bc503c0b4c1d58f8dd2e8dc5c53e05d6a972d" translate="yes" xml:space="preserve">
          <source>When a subroutine is&lt;code&gt;CALL&lt;/code&gt;d:</source>
          <target state="translated">서브 루틴이 &lt;code&gt;CALL&lt;/code&gt; 일 때 :</target>
        </trans-unit>
        <trans-unit id="6b3f0dcc87d05529aa57daa3996393da6636f775" translate="yes" xml:space="preserve">
          <source>When a user-defined function is executed:</source>
          <target state="translated">사용자 정의 함수가 실행될 때 :</target>
        </trans-unit>
        <trans-unit id="c194fc952fa4a418c7fa17712386ca1ffdddb141" translate="yes" xml:space="preserve">
          <source>When a&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt;) or&lt;code&gt;LINE ADVANCING&lt;/code&gt;(see &lt;a href=&quot;#LINE-ADVANCING&quot;&gt;LINE ADVANCING&lt;/a&gt;) file is closed, a final delimiter sequence will be written to the file to signal the termination point of the final data record in the file. This will only be necessary if the final record written to the file was written with the&lt;code&gt;AFTER ADVANCING&lt;/code&gt;(see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;) option.</source>
          <target state="translated">때 &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE 순차&lt;/a&gt; ) 또는 &lt;code&gt;LINE ADVANCING&lt;/code&gt; (참조 &lt;a href=&quot;#LINE-ADVANCING&quot;&gt;LINE 전진&lt;/a&gt; ) 파일을 닫고, 최종 분리 시퀀스 파일의 최종 데이터 기록의 종료 시점을 알리기 위해 파일에 기록한다. 파일에 기록 된 최종 레코드가 &lt;code&gt;AFTER ADVANCING&lt;/code&gt; ( &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt; 참조 ) 옵션으로 기록 된 경우에만 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="cb18cfe63b41a026a68a61409a46e1e15527917f" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; file has been successfully read, the file&amp;rsquo;s &lt;code&gt;RELATIVE KEY&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) field will be automatically populated with the relative record number (ordinal occurrence number) of the record in the file.</source>
          <target state="translated">때 &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; 파일이 성공적으로 읽은 파일의 &lt;code&gt;RELATIVE KEY&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;조직 상대적으로&lt;/a&gt; ) 필드는 자동으로 파일의 레코드의 상대 레코드 번호 (서수 발생 번호)로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="14deee3de35bd3ed897022111d6d6ff12b42d466" translate="yes" xml:space="preserve">
          <source>When an alternate entry-point is called, execution within the subroutine will begin at the first executable statement following the &lt;code&gt;ENTRY&lt;/code&gt; statement.</source>
          <target state="translated">대체 진입 점이 호출되면 서브 루틴 내의 실행은 &lt;code&gt;ENTRY&lt;/code&gt; 문 다음의 첫 번째 실행 가능 문에서 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="40d9758a601000c88af8c955e6507ffc04cc2191" translate="yes" xml:space="preserve">
          <source>When an alternate entry-point is called, execution within the subroutine will begin at the first executable statement following the&lt;code&gt;ENTRY&lt;/code&gt;statement.</source>
          <target state="translated">대체 진입 점이 호출되면 서브 루틴 내에서 실행이 &lt;code&gt;ENTRY&lt;/code&gt; 문 다음의 첫 번째 실행 문에서 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="c10bdaa27d6f7ae098d484fddaa2f4997c805850" translate="yes" xml:space="preserve">
          <source>When an input procedure is used, the procedure(s) specified on the  &lt;code&gt;INPUT PROCEDURE&lt;/code&gt; clause will be invoked as if by a procedural &lt;code&gt;PERFORM&lt;/code&gt; statement (see &lt;a href=&quot;#Procedural-PERFORM&quot;&gt;Procedural PERFORM&lt;/a&gt;) with no &lt;code&gt;VARYING&lt;/code&gt;, &lt;code&gt;TIMES&lt;/code&gt; or &lt;code&gt;UNTIL&lt;/code&gt; options specified. Records will be loaded into the sort work file &amp;mdash; one at a time &amp;mdash; within the input procedure using the &lt;code&gt;RELEASE&lt;/code&gt; statement (see &lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt;). This, by the way, is how you could sort the contents of relative or indexed files.</source>
          <target state="translated">입력 프로 시저가 사용되면 &lt;code&gt;INPUT PROCEDURE&lt;/code&gt; 절 에 지정된 &lt;a href=&quot;#Procedural-PERFORM&quot;&gt;프로 시저&lt;/a&gt; 가 &lt;code&gt;VARYING&lt;/code&gt; , &lt;code&gt;TIMES&lt;/code&gt; 또는 &lt;code&gt;UNTIL&lt;/code&gt; 옵션이 지정 되지 않은 프로 시저 &lt;code&gt;PERFORM&lt;/code&gt; 문 ( Procedural PERFORM 참조)에 의해 호출되는 것처럼 호출됩니다 . 레코드는 &lt;code&gt;RELEASE&lt;/code&gt; 문을 사용하여 입력 프로 시저 내에서 한 번에 하나씩 정렬 작업 파일로로드됩니다 ( &lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt; 참조 ). 그건 그렇고, 상대 또는 색인 파일의 내용을 정렬하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="92d196d291e628f332ffc42a4d148518815e95a2" translate="yes" xml:space="preserve">
          <source>When an input procedure is used, the procedure(s) specified on the&lt;code&gt;INPUT PROCEDURE&lt;/code&gt;</source>
          <target state="translated">입력 절차를 사용하는 경우 입력 절차에 지정된 &lt;code&gt;INPUT PROCEDURE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebcfc5fcf187028b957421284b1c2379f7640463" translate="yes" xml:space="preserve">
          <source>When an output procedure is used, the procedure(s) specified on the  &lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt; clause will be invoked as if by a procedural &lt;code&gt;PERFORM&lt;/code&gt; statement (see &lt;a href=&quot;#Procedural-PERFORM&quot;&gt;Procedural PERFORM&lt;/a&gt;) with no &lt;code&gt;VARYING&lt;/code&gt;, &lt;code&gt;TIMES&lt;/code&gt; or &lt;code&gt;UNTIL&lt;/code&gt; options specified. Records will be retrieved from the sort work file &amp;mdash; one at a time &amp;mdash; within the output procedure using the &lt;code&gt;RETURN&lt;/code&gt; statement (see &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt;).</source>
          <target state="translated">출력 프로 시저가 사용되면 &lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt; 절 에 지정된 &lt;a href=&quot;#Procedural-PERFORM&quot;&gt;프로 시저&lt;/a&gt; 가 &lt;code&gt;VARYING&lt;/code&gt; , &lt;code&gt;TIMES&lt;/code&gt; 또는 &lt;code&gt;UNTIL&lt;/code&gt; 옵션이 지정 되지 않은 프로 시저 &lt;code&gt;PERFORM&lt;/code&gt; 문 ( Procedural PERFORM 참조)에 의해 호출되는 것처럼 호출됩니다 . 레코드는 &lt;code&gt;RETURN&lt;/code&gt; 문을 사용하는 출력 프로 시저 내에서 한 번에 하나씩 정렬 작업 파일에서 검색됩니다 ( &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f943e0cf680de98f1f0c98b15043b55428f0ece1" translate="yes" xml:space="preserve">
          <source>When an output procedure is used, the procedure(s) specified on the &lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt; clause will be invoked as if by a procedural &lt;code&gt;PERFORM&lt;/code&gt; (see &lt;a href=&quot;#Procedural-PERFORM&quot;&gt;Procedural PERFORM&lt;/a&gt;) statement with no &lt;code&gt;VARYING&lt;/code&gt;, &lt;code&gt;TIMES&lt;/code&gt; or &lt;code&gt;UNTIL&lt;/code&gt; options specified. Merged records may be read from the merge work file &amp;mdash; one at a time &amp;mdash; within the output procedure using the &lt;code&gt;RETURN&lt;/code&gt; (see &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt;) statement.</source>
          <target state="translated">출력 프로 시저가 사용되면 &lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt; 절 에 지정된 프로시 저는 &lt;code&gt;VARYING&lt;/code&gt; , &lt;code&gt;TIMES&lt;/code&gt; 또는 &lt;code&gt;UNTIL&lt;/code&gt; 옵션이 지정 되지 않은 &lt;a href=&quot;#Procedural-PERFORM&quot;&gt;프로&lt;/a&gt; 시저 &lt;code&gt;PERFORM&lt;/code&gt; ( Procedural PERFORM 참조 ) 문에 의해 호출되는 것처럼 호출됩니다 . 병합 된 레코드는 &lt;code&gt;RETURN&lt;/code&gt; ( &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt; 참조 ) 문을 사용하여 출력 프로 시저 내에서 한 번에 하나씩 병합 작업 파일에서 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a4c9a37d6d2b90cdc80ee4f641c1c61745e1756" translate="yes" xml:space="preserve">
          <source>When an output procedure is used, the procedure(s) specified on the&lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt;</source>
          <target state="translated">출력 절차가 사용되는 경우, &lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt; 에 지정된 절차</target>
        </trans-unit>
        <trans-unit id="93684fea254995b6865fb1a4ab54f6078a0b1615" translate="yes" xml:space="preserve">
          <source>When an output procedure is used, the procedure(s) specified on the&lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt;clause will be invoked as if by a procedural&lt;code&gt;PERFORM&lt;/code&gt;(see &lt;a href=&quot;#Procedural-PERFORM&quot;&gt;Procedural PERFORM&lt;/a&gt;) statement with no&lt;code&gt;VARYING&lt;/code&gt;&lt;code&gt;TIMES&lt;/code&gt;or&lt;code&gt;UNTIL&lt;/code&gt;options specified. Merged records may be read from the merge work file &amp;mdash; one at a time &amp;mdash; within the output procedure using the&lt;code&gt;RETURN&lt;/code&gt;(see &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt;) statement.</source>
          <target state="translated">출력 프로 시저가 사용될 때, &lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt; 절 에 지정된 프로시 저는 &lt;code&gt;VARYING&lt;/code&gt; &lt;code&gt;TIMES&lt;/code&gt; 또는 &lt;code&gt;UNTIL&lt;/code&gt; 옵션이 지정 되지 않은 &lt;a href=&quot;#Procedural-PERFORM&quot;&gt;프로&lt;/a&gt; 시저 &lt;code&gt;PERFORM&lt;/code&gt; ( 프로 시저 PERFORM 참조 ) 명령문에 의해 호출되는 것처럼 호출됩니다 . 병합 된 레코드는 &lt;code&gt;RETURN&lt;/code&gt; ( &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt; 참조 ) 문을 사용하여 출력 프로 시저 내에서 병합 작업 파일에서 한 번에 하나씩 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7ec9aff785eae6a95fe44d95188bd4764eb8f20" translate="yes" xml:space="preserve">
          <source>When an&lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt;file has been successfully read, the file&amp;rsquo;s&lt;code&gt;RELATIVE KEY&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;ORGANIZATION RELATIVE&lt;/a&gt;) field will be automatically populated with the relative record number (ordinal occurrence number) of the record in the file.</source>
          <target state="translated">때 &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; 파일이 성공적으로 읽은 파일의 &lt;code&gt;RELATIVE KEY&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-RELATIVE&quot;&gt;조직 상대적으로&lt;/a&gt; ) 필드는 자동으로 파일의 레코드의 상대 레코드 번호 (서수 발생 번호)로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="b8912a19f17811c2f39822283e113ebcf7a32e2d" translate="yes" xml:space="preserve">
          <source>When any procedure division statement that references procedures is used. These statements are:</source>
          <target state="translated">절차를 참조하는 절차 구분 문이 사용될 때. 이러한 진술은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="38f2062626bdc2c02c89b57095232e950635fe08" translate="yes" xml:space="preserve">
          <source>When both &lt;code&gt;REPLACING&lt;/code&gt; and &lt;code&gt;TALLYING&lt;/code&gt; are specified:</source>
          <target state="translated">때 모두 &lt;code&gt;REPLACING&lt;/code&gt; 및 &lt;code&gt;TALLYING&lt;/code&gt; 지정됩니다</target>
        </trans-unit>
        <trans-unit id="d62fb0ac02d02b75e585235df2e99ed528d3a2a5" translate="yes" xml:space="preserve">
          <source>When both a &lt;code&gt;TALLYING&lt;/code&gt; and a &lt;code&gt;REPLACING&lt;/code&gt; instruction have been selected for execution, the &lt;code&gt;TALLYING&lt;/code&gt; instruction will be executed first. This guarantees that &lt;code&gt;TALLYING&lt;/code&gt; will compute occurrences based upon the</source>
          <target state="translated">둘 다를 경우 &lt;code&gt;TALLYING&lt;/code&gt; 및 &lt;code&gt;REPLACING&lt;/code&gt; 명령이 실행을 위해 선택되었습니다 &lt;code&gt;TALLYING&lt;/code&gt; 지시가 먼저 실행된다. 이것은 &lt;code&gt;TALLYING&lt;/code&gt; 이</target>
        </trans-unit>
        <trans-unit id="146c574872a542aa257d3bc0f72bf6c4b3c7b165" translate="yes" xml:space="preserve">
          <source>When both a&lt;code&gt;TALLYING&lt;/code&gt;and a&lt;code&gt;REPLACING&lt;/code&gt;instruction have been selected for execution, the&lt;code&gt;TALLYING&lt;/code&gt;instruction will be executed first. This guarantees that&lt;code&gt;TALLYING&lt;/code&gt;will compute occurrences based upon the</source>
          <target state="translated">둘 다를 경우 &lt;code&gt;TALLYING&lt;/code&gt; 및 &lt;code&gt;REPLACING&lt;/code&gt; 명령이 실행을 위해 선택되었습니다 &lt;code&gt;TALLYING&lt;/code&gt; 지시가 먼저 실행된다. 이를 통해 &lt;code&gt;TALLYING&lt;/code&gt; 은 다음을 기반으로 발생을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="24eab9fb267801a6ef7bd6685824bbe296e86f53" translate="yes" xml:space="preserve">
          <source>When both&lt;code&gt;REPLACING&lt;/code&gt;and&lt;code&gt;TALLYING&lt;/code&gt;are specified:</source>
          <target state="translated">때 모두 &lt;code&gt;REPLACING&lt;/code&gt; 및 &lt;code&gt;TALLYING&lt;/code&gt; 지정됩니다</target>
        </trans-unit>
        <trans-unit id="7941f0aacf9a7dc1f040df5e95ab186de4cadc32" translate="yes" xml:space="preserve">
          <source>When called from a main program, the returned value will always be 0.</source>
          <target state="translated">메인 프로그램에서 호출 될 때 반환되는 값은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="2cc80ec14d3e2b6d6e5c2a0277fa1296504b79a1" translate="yes" xml:space="preserve">
          <source>When chaining multiple, similar conditions together with the same operator (OR/AND), and left or right arguments have common subjects, it is possible to abbreviate the program code. For example:</source>
          <target state="translated">여러 개의 유사한 조건을 동일한 연산자 (OR / AND)와 함께 묶고 왼쪽 또는 오른쪽 인수에 공통 주제가있는 경우 프로그램 코드를 축약 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f2ed9ec2463a0d709bd1b56388694f65c1fa1e8b" translate="yes" xml:space="preserve">
          <source>When coding a GnuCOBOL subprogram (a subroutine or user-defined function), all arguments to the subprogram must be defined in the subprogram&amp;rsquo;s linkage section.</source>
          <target state="translated">GnuCOBOL 서브 프로그램 (서브 루틴 또는 사용자 정의 함수)을 코딩 할 때 서브 프로그램의 모든 인수는 서브 프로그램의 링크 섹션에 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7c73335cca7877322a5801e7fc15b33a9d1dfec2" translate="yes" xml:space="preserve">
          <source>When comparing one numeric value to another, the &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) and number of significant digits in either value are irrelevant as the comparison is performed using the actual algebraic values.</source>
          <target state="translated">다른 하나 개의 수치를 비교하면, &lt;code&gt;USAGE&lt;/code&gt; 는 (참조 &lt;a href=&quot;#USAGE&quot;&gt;사용&lt;/a&gt; ) 및 비교는 실제의 대수 값을 이용하여 수행됨에 따라 어느 값이 유효 숫자의 수는 적합하다.</target>
        </trans-unit>
        <trans-unit id="1b1d786daa32294159fc0ca54e3d597c33137bce" translate="yes" xml:space="preserve">
          <source>When comparing one numeric value to another, the&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) and number of significant digits in either value are irrelevant as the comparison is performed using the actual algebraic values.</source>
          <target state="translated">다른 하나 개의 수치를 비교하면, &lt;code&gt;USAGE&lt;/code&gt; 는 (참조 &lt;a href=&quot;#USAGE&quot;&gt;사용&lt;/a&gt; ) 및 비교는 실제의 대수 값을 이용하여 수행됨에 따라 어느 값이 유효 숫자의 수는 적합하다.</target>
        </trans-unit>
        <trans-unit id="6fcf3f0f861903b7e3e9c41a826fbb85e7aefdcd" translate="yes" xml:space="preserve">
          <source>When comparing strings, the comparison is made based upon the program&amp;rsquo;s collating sequence. When the two string arguments are of unequal length, the shorter is assumed to be padded (on the right) with a sufficient number of spaces as to make the two strings of equal length. String comparisons take place on a corresponding character-by-character basis, left to right, until the &lt;code&gt;TRUE&lt;/code&gt;/&lt;code&gt;FALSE&lt;/code&gt; value for the relation test can be established. Characters are compared according to their relative position in the program&amp;rsquo;s &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; (as defined in &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;)),</source>
          <target state="translated">문자열을 비교할 때 프로그램의 배열 순서를 기준으로 비교가 이루어집니다. 두 문자열 인수의 길이가 같지 않으면 길이가 같은 두 문자열을 만들기에 충분한 수의 공백으로 더 짧은 것이 오른쪽에있는 것으로 간주됩니다. 문자열 비교 는 관계 테스트에 대한 &lt;code&gt;TRUE&lt;/code&gt; / &lt;code&gt;FALSE&lt;/code&gt; 값이 설정 될 수있을 때까지 해당 문자별로 왼쪽에서 오른쪽으로 발생 합니다 . 문자가 프로그램의 상대적 위치에 따라 비교 &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; (항에 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; (참조 &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL - 이름&lt;/a&gt; ))</target>
        </trans-unit>
        <trans-unit id="5173647e20c2eb250053e19884f9ad6c1ef4fdf3" translate="yes" xml:space="preserve">
          <source>When comparing strings, the comparison is made based upon the program&amp;rsquo;s collating sequence. When the two string arguments are of unequal length, the shorter is assumed to be padded (on the right) with a sufficient number of spaces as to make the two strings of equal length. String comparisons take place on a corresponding character-by-character basis, left to right, until the TRUE/FALSE value for the relation test can be established. Characters are compared according to their relative position in the program&amp;rsquo;s&lt;code&gt;COLLATING SEQUENCE&lt;/code&gt;(as defined in&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;)),</source>
          <target state="translated">문자열을 비교할 때 프로그램의 조합 순서에 따라 비교가 이루어집니다. 두 문자열 인수의 길이가 동일하지 않은 경우 두 문자열을 같은 길이로 만들기에 충분한 수의 공백으로 더 짧은 것으로 채워집니다 (오른쪽). 문자열 비교는 관계 테스트에 대한 TRUE / FALSE 값이 설정 될 때까지 왼쪽에서 오른쪽으로 해당 문자별로 수행됩니다. 문자는 프로그램의 &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; ( &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; ( &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 참조)에 정의 된)에서 상대 위치에 따라 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="9237b11247a16b4db5fe351e08587d03b35fa917" translate="yes" xml:space="preserve">
          <source>When corresponding matches are established, the effect of a &lt;code&gt;MOVE CORRESPONDING&lt;/code&gt; on those matches will be as if a series of individual &lt;code&gt;MOVE&lt;/code&gt;s were done &amp;mdash; one for each match.</source>
          <target state="translated">해당 일치가 설정되면 해당 일치에 대한 &lt;code&gt;MOVE CORRESPONDING&lt;/code&gt; 의 효과는 각 일치에 대해 일련의 개별 &lt;code&gt;MOVE&lt;/code&gt; 가 수행 된 것처럼됩니다.</target>
        </trans-unit>
        <trans-unit id="d9b3397e0799dd72dda73077c1607271c7cf700e" translate="yes" xml:space="preserve">
          <source>When corresponding matches are established, the effect of a&lt;code&gt;MOVE CORRESPONDING&lt;/code&gt;on those matches will be as if a series of individual&lt;code&gt;MOVE&lt;/code&gt; were done &amp;mdash; one for each match.</source>
          <target state="translated">해당 일치가 설정되면 해당 일치에 대한 &lt;code&gt;MOVE CORRESPONDING&lt;/code&gt; 의 효과 는 일련의 개별 &lt;code&gt;MOVE&lt;/code&gt; 가 수행 된 것처럼 (매 일치마다 하나씩) 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="30284d7e238eaf309d479d7bf6e2d0ea790b2e36" translate="yes" xml:space="preserve">
          <source>When describing a report via the &lt;code&gt;RD&lt;/code&gt; (see &lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;) clause, the total number of usable lines are specified as the &lt;code&gt;PAGE LIMIT&lt;/code&gt; value; this value is the sum of the number of lines contained in the Heading, Body and Footing Areas.</source>
          <target state="translated">&lt;code&gt;RD&lt;/code&gt; ( &lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt; 참조 ) 절을 통해 보고서를 설명 할 때 사용 가능한 총 행 수는 &lt;code&gt;PAGE LIMIT&lt;/code&gt; 값 으로 지정됩니다 . 이 값은 머리글, 본문 및 기초 영역에 포함 된 줄 수의 합계입니다.</target>
        </trans-unit>
        <trans-unit id="41a918721b83779c30ebf56d095541b79d4dacdc" translate="yes" xml:space="preserve">
          <source>When describing a report via the&lt;code&gt;RD&lt;/code&gt;(see &lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;) clause, the total number of usable lines are specified as the&lt;code&gt;PAGE LIMIT&lt;/code&gt;value; this value is the sum of the number of lines contained in the Heading, Body and Footing Areas.</source>
          <target state="translated">&lt;code&gt;RD&lt;/code&gt; ( &lt;a href=&quot;#REPORT-SECTION&quot;&gt;보고서 섹션&lt;/a&gt; 참조 ) 절을 통해 보고서를 설명 할 때 사용 가능한 총 행 수는 &lt;code&gt;PAGE LIMIT&lt;/code&gt; 값 으로 지정됩니다 . 이 값은 제목, 본문 및 바닥 영역에 포함 된 줄 수의 합계입니다.</target>
        </trans-unit>
        <trans-unit id="39392c2e6fa180cc814e786c6003f2f16a336a4e" translate="yes" xml:space="preserve">
          <source>When describing data hierarchies, you may never use a level number greater than 49 (except for 66, 77, 78 and 88 which have very special meanings &amp;mdash; see see &lt;a href=&quot;#Special-Data-Items&quot;&gt;Special Data Items&lt;/a&gt;).</source>
          <target state="translated">데이터 계층 구조를 설명 할 때 49보다 큰 레벨 번호를 사용할 수 없습니다 (매우 특별한 의미가있는 66, 77, 78 및 88 제외) &amp;ndash; &lt;a href=&quot;#Special-Data-Items&quot;&gt;특수 데이터 항목&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="219b9518ec32a6c271a02a32d00039c522c77017" translate="yes" xml:space="preserve">
          <source>When describing data hierarchies, you may never use a level number greater than 49 (except for 66, 77, 78 and 88 which have very special meanings (see &lt;a href=&quot;#Special-Data-Items&quot;&gt;Special Data Items&lt;/a&gt;).</source>
          <target state="translated">데이터 계층 구조를 설명 할 때 49보다 큰 레벨 번호는 절대로 사용할 수 없습니다 (매우 특별한 의미를 갖는 66, 77, 78 및 88 제외) ( &lt;a href=&quot;#Special-Data-Items&quot;&gt;특수 데이터 항목&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4d4bcd060003bd360faf969bcf728b82f2f5652d" translate="yes" xml:space="preserve">
          <source>When displaying upon the &lt;code&gt;CONSOLE&lt;/code&gt;, &lt;code&gt;PRINTER&lt;/code&gt;, &lt;code&gt;STDOUT&lt;/code&gt;, &lt;code&gt;SYSLIST&lt;/code&gt;, &lt;code&gt;SYSLST&lt;/code&gt; or &lt;code&gt;SYSOUT&lt;/code&gt; devices or to a &lt;var&gt;mnemonic-name-1&lt;/var&gt; attached to one of them, the output will be written to output pipe #1, which will normally cause the output to appear in the console output window. You may, if desired, redirect that output to a file by appending</source>
          <target state="translated">에 표시 할 때 &lt;code&gt;CONSOLE&lt;/code&gt; , &lt;code&gt;PRINTER&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , &lt;code&gt;SYSLIST&lt;/code&gt; , &lt;code&gt;SYSLST&lt;/code&gt; 또는 &lt;code&gt;SYSOUT&lt;/code&gt; 장치 또는로 &lt;var&gt;mnemonic-name-1&lt;/var&gt; 중 하나에 연결된 출력 정상적으로 출력에 나타나는 것 원인하는 출력 파이프 # 1에 기록 될 콘솔 출력 창. 원하는 경우 다음을 추가하여 해당 출력을 파일로 리디렉션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2032c76ebf4ffa2e23b61656c9253b1026461031" translate="yes" xml:space="preserve">
          <source>When displaying upon the &lt;code&gt;STDERR&lt;/code&gt; or &lt;code&gt;SYSERR&lt;/code&gt; devices or to a &lt;var&gt;mnemonic-name-1&lt;/var&gt; attached to one of those two devices, the output will be written to output pipe #2, which will normally cause the output to appear in the console output window. You may, if desired, redirect that output to a file by appending</source>
          <target state="translated">에 표시 할 때 &lt;code&gt;STDERR&lt;/code&gt; 또는 &lt;code&gt;SYSERR&lt;/code&gt; 장치 또는로 &lt;var&gt;mnemonic-name-1&lt;/var&gt; 두 장치 중 하나에 연결된 출력 정상적으로 출력 콘솔 출력 화면에 표시한다 원인 출력 파이프 # 2에 기록한다. 원하는 경우 다음을 추가하여 해당 출력을 파일로 리디렉션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c5513aeebcad1e2856cc9f8d4cb7d2f2eaec2c2" translate="yes" xml:space="preserve">
          <source>When displaying upon the&lt;code&gt;CONSOLE&lt;/code&gt;&lt;code&gt;PRINTER&lt;/code&gt;&lt;code&gt;STDOUT&lt;/code&gt;&lt;code&gt;SYSLIST&lt;/code&gt;&lt;code&gt;SYSLST&lt;/code&gt;or&lt;code&gt;SYSOUT&lt;/code&gt;devices or to a &amp;lt;</source>
          <target state="translated">에 표시 할 때 &lt;code&gt;CONSOLE&lt;/code&gt; &lt;code&gt;PRINTER&lt;/code&gt; &lt;code&gt;STDOUT&lt;/code&gt; &lt;code&gt;SYSLIST&lt;/code&gt; &lt;code&gt;SYSLST&lt;/code&gt; 또는 &lt;code&gt;SYSOUT&lt;/code&gt; 장치 또는로 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="655d94f947c604b783209f57f37ba32fc344e54d" translate="yes" xml:space="preserve">
          <source>When displaying upon the&lt;code&gt;STDERR&lt;/code&gt;or&lt;code&gt;SYSERR&lt;/code&gt;devices or to a &amp;lt;</source>
          <target state="translated">에 표시 할 때 &lt;code&gt;STDERR&lt;/code&gt; 또는 &lt;code&gt;SYSERR&lt;/code&gt; 장치 또는로 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="bbb1f161357d396c754cf54ef943e316e55193af" translate="yes" xml:space="preserve">
          <source>When executed, this program produces the following output:</source>
          <target state="translated">실행될 때이 프로그램은 다음과 같은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1144df86ac6d48e9fa3c46d5a49a748eabd886e5" translate="yes" xml:space="preserve">
          <source>When executed, this sample program generates the following console output.</source>
          <target state="translated">실행될 때이 샘플 프로그램은 다음 콘솔 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="204809fb0c4c4ee192c241c5223178a3a7e57dd4" translate="yes" xml:space="preserve">
          <source>When group items are being defined, subordinate items may be assigned a&lt;code&gt;name&lt;/code&gt;of&lt;code&gt;FILLER&lt;/code&gt;</source>
          <target state="translated">그룹 항목을 정의 할 때 하위 항목 에 &lt;code&gt;FILLER&lt;/code&gt; &lt;code&gt;name&lt;/code&gt; 이 할당 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebf4d578476d9b88fb987de7694155472de2d0ec" translate="yes" xml:space="preserve">
          <source>When group items are being defined, subordinate items may be assigned the &amp;ldquo;name&amp;rdquo;  &lt;code&gt;FILLER&lt;/code&gt;. There may be any number of &lt;code&gt;FILLER&lt;/code&gt; items defined within a group item. A data item named &lt;code&gt;FILLER&lt;/code&gt; cannot be referenced directly; these items are generally used to specify an unused portion of the total storage allocated to a group item. Note that it is possible that the name of the group item itself might be specified as &lt;code&gt;FILLER&lt;/code&gt; if there is no need to ever refer directly to the group structure itself.</source>
          <target state="translated">그룹 항목을 정의 할 때 하위 항목에 &quot;이름&quot; &lt;code&gt;FILLER&lt;/code&gt; 를 할당 할 수 있습니다 . 그룹 항목 내에 정의 된 &lt;code&gt;FILLER&lt;/code&gt; 항목 이 얼마 든지있을 수 있습니다 . &lt;code&gt;FILLER&lt;/code&gt; 라는 데이터 항목은 직접 참조 할 수 없습니다. 이러한 항목은 일반적으로 그룹 항목에 할당 된 총 스토리지 중 사용되지 않은 부분을 지정하는 데 사용됩니다. 그룹 구조 자체를 직접 참조 할 필요가없는 경우 그룹 항목 자체의 이름이 &lt;code&gt;FILLER&lt;/code&gt; 로 지정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e1d10fb3d8bd6442c17b53e32bad30479bdc327" translate="yes" xml:space="preserve">
          <source>When it first was developed, COBOL&amp;rsquo;s easily-readable syntax made it profoundly different from anything that had been seen before. For the first time, it was possible to specify logic in a manner that was &amp;mdash; at least to some extent &amp;mdash; comprehensible even to non-programmers. Take for example, the following code written in FORTRAN &amp;mdash; a language developed only a year before COBOL:</source>
          <target state="translated">처음 개발되었을 때 COBOL의 쉽게 읽을 수있는 구문은 이전에 보았던 것과는 완전히 달랐습니다. 처음으로 프로그래머가 아닌 사람도 이해할 수있는 방식으로 로직을 지정할 수있었습니다. 예를 들어, COBOL보다 1 년 전에 개발 된 언어 인 FORTRAN으로 작성된 다음 코드를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="81cc473530e4b89a1df51da3c3b3540a6bfb4031" translate="yes" xml:space="preserve">
          <source>When it first was developed, Cobol&amp;rsquo;s easily-readable syntax made it profoundly different from anything that had been seen before. For the first time, it was possible to specify logic in a manner that was &amp;mdash; at least to some extent &amp;mdash; comprehensible even to non-programmers. Take for example, the following code written in FORTRAN &amp;mdash; a language developed only a year before COBOL:</source>
          <target state="translated">처음 개발 될 때 Cobol의 쉽게 읽을 수있는 구문은 이전에 보았던 것과는 크게 다릅니다. 처음으로 프로그래머가 아닌 사람도 이해할 수있는 방식으로 논리를 지정할 수있었습니다. 예를 들어, COBOL 1 년 전에 개발 된 언어 인 FORTRAN으로 작성된 다음 코드를 생각해보십시오.</target>
        </trans-unit>
        <trans-unit id="4f44d0cc215e6bf095db28c3b9429a71f8b099ef" translate="yes" xml:space="preserve">
          <source>When making an attribute change to &amp;lt;</source>
          <target state="translated">속성을 &amp;lt;로 변경하면</target>
        </trans-unit>
        <trans-unit id="0544ca0e07f06dc90c398e3432db3f07ae5c3636" translate="yes" xml:space="preserve">
          <source>When making an attribute change to &lt;var&gt;identifier-1&lt;/var&gt;, the change will not become visible on the screen until the screen section data item containing &lt;var&gt;identifier-1&lt;/var&gt; is next accepted (if &lt;var&gt;identifier-1&lt;/var&gt; is an input field) or is next displayed (if &lt;var&gt;identifier-1&lt;/var&gt; is not an input field).</source>
          <target state="translated">&lt;var&gt;identifier-1&lt;/var&gt; 속성을 변경할 때, &lt;var&gt;identifier-1&lt;/var&gt; 이 포함 된 화면 섹션 데이터 항목 이 다음에 승인되거나 ( &lt;var&gt;identifier-1&lt;/var&gt; 이 입력 필드 인 경우) 다음에 표시 될 때까지 ( &lt;var&gt;identifier-1&lt;/var&gt; 은 입력 필드가 아닙니다.)</target>
        </trans-unit>
        <trans-unit id="6c6f5660a230a40eb3eb6b1e1b3a34548fea984d" translate="yes" xml:space="preserve">
          <source>When multiple floating symbols are coded, even if there is only one of them used they will all be considered floating and will all be able to assume each other&amp;rsquo;s properties. For example, if a data item has a &lt;code&gt;PIC +$ZZZZ9.99&lt;/code&gt;&lt;var&gt;picture-string&lt;/var&gt;, and a value of 1 is moved to that field at run-time, the resulting value will be (the</source>
          <target state="translated">여러 개의 부동 기호가 코딩되면 그중 하나만 사용 되더라도 모두 부동 기호로 간주되고 모두 서로의 속성을 가정 할 수 있습니다. 예를 들어 데이터 항목에 &lt;code&gt;PIC +$ZZZZ9.99&lt;/code&gt; &lt;var&gt;picture-string&lt;/var&gt; 이 있고 런타임에 값 1이 해당 필드로 이동되면 결과 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="765347088d1cd595526699fe437b6c492beff319" translate="yes" xml:space="preserve">
          <source>When multiple floating symbols are coded, even if there is only one of them used they will all be considered floating and will all be able to assume each other&amp;rsquo;s properties. For example, if a data item has a&lt;code&gt;PIC +$ZZZZ9.99&lt;/code&gt;&amp;lt;</source>
          <target state="translated">여러 개의 부동 기호가 코딩 될 때, 그 중 하나만 사용하더라도 모두 부동으로 간주되며 서로의 속성을 가정 할 수 있습니다. 예를 들어 데이터 항목에 &lt;code&gt;PIC +$ZZZZ9.99&lt;/code&gt; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="6dc3f84f281c37195ea362e1243dc91c864bf7bf" translate="yes" xml:space="preserve">
          <source>When multiple programs occur in a source file, it is assumed that the programs are related to one another in that they will be &lt;code&gt;CALL&lt;/code&gt;ed or executed as functions from the others.</source>
          <target state="translated">소스 파일에서 여러 프로그램이 발생하면 프로그램이 다른 프로그램의 함수 로 &lt;code&gt;CALL&lt;/code&gt; 되거나 실행 된다는 점에서 프로그램이 서로 관련되어 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="357bac3f35e4cad10100a74fa4de493239fed268" translate="yes" xml:space="preserve">
          <source>When multiple programs occur in a source file, it is assumed that the programs are related to one another in that they will be CALLed or executed as functions from the others.</source>
          <target state="translated">소스 파일에서 여러 프로그램이 발생하면 프로그램이 다른 프로그램의 함수로 호출되거나 실행될 것이라는 점에서 프로그램이 서로 관련이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ee4d022507775e46145db061fb817e298c431714" translate="yes" xml:space="preserve">
          <source>When only a portion of a reserved word is underlined, it indicates that the word may either be coded in its full form or may be abbreviated to the portion that is underlined.</source>
          <target state="translated">예약어의 일부에만 밑줄이있는 경우, 단어가 전체 형식으로 코딩되거나 밑줄이있는 부분으로 축약 될 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2e7365af2e81c2e60530aede0ed3cecebdb3968c" translate="yes" xml:space="preserve">
          <source>When program</source>
          <target state="translated">때 프로그램</target>
        </trans-unit>
        <trans-unit id="16b43a9e336b11f14ff5999514c47a3da0207e37" translate="yes" xml:space="preserve">
          <source>When program &quot;A&quot; invokes program &quot;B&quot; as a &amp;rsquo;</source>
          <target state="translated">프로그램 &quot;A&quot;가 &quot;B&quot;프로그램을 '</target>
        </trans-unit>
        <trans-unit id="cb631f6f2ec2e69653942f71a148c4d305b9976c" translate="yes" xml:space="preserve">
          <source>When program &quot;A&quot; invokes subprogram &quot;B&quot; as a &amp;rsquo;</source>
          <target state="translated">프로그램 &quot;A&quot;가 서브 프로그램 &quot;B&quot;를 '</target>
        </trans-unit>
        <trans-unit id="24575c99a46bc504177bdf4d662ceef89ceff979" translate="yes" xml:space="preserve">
          <source>When programs get very large, it becomes more and more challenging to keep track of the data items that will be used in the program. Here, in no particular order of importance, are a variety of conventions that can simply that problem.</source>
          <target state="translated">프로그램이 매우 커지면 프로그램에서 사용될 데이터 항목을 추적하는 것이 점점 더 어려워집니다. 여기서 중요한 순서는 아니지만 단순히 그 문제를 해결할 수있는 다양한 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="056320b3e7b4a81baa126f4234eb85b83c88b1d3" translate="yes" xml:space="preserve">
          <source>When reading a &lt;code&gt;LINE SEQUENTIAL&lt;/code&gt; file, records in excess of the size implied by the file&amp;rsquo;s description in the &lt;code&gt;FILE SECTION&lt;/code&gt; will be truncated while records shorter than that size will be padded to the right with &lt;code&gt;SPACES&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LINE SEQUENTIAL&lt;/code&gt; 파일을 읽을 때 &lt;code&gt;FILE SECTION&lt;/code&gt; 의 파일 설명이 의미하는 크기를 초과 하는 레코드는 잘리고 해당 크기보다 짧은 레코드는 오른쪽이 &lt;code&gt;SPACES&lt;/code&gt; 로 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="12f9d3bfdb77a158eebc43ccf582ee2143f458e5" translate="yes" xml:space="preserve">
          <source>When reading a&lt;code&gt;LINE SEQUENTIAL&lt;/code&gt;file, records in excess of the size implied by the file&amp;rsquo;s description in the&lt;code&gt;FILE SECTION&lt;/code&gt;will be truncated while records shorter than that size will be padded to the right with&lt;code&gt;SPACES&lt;/code&gt;</source>
          <target state="translated">읽을 때 &lt;code&gt;LINE SEQUENTIAL&lt;/code&gt; 파일의에서 파일의 설명에 의해 암시 크기를 초과하는 기록 &lt;code&gt;FILE SECTION&lt;/code&gt; 그 크기보다 짧은 기록과 함께 오른쪽으로 패딩됩니다 동안립니다 &lt;code&gt;SPACES&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0e7557431ef7c1f77d37d108a31fd016e5ee22c0" translate="yes" xml:space="preserve">
          <source>When reading any sequential (any organization) or relative file, the &quot;next&quot; direction refers to the physical sequence of records in the file. When reading an indexed file, the &quot;next&quot; and &quot;previous&quot; directions refer to the sequence of primary or alternate record key values in the file&amp;rsquo;s records, regardless of where the records physically occur within the file.</source>
          <target state="translated">순차 (모든 조직) 또는 상대 파일을 읽을 때 &quot;다음&quot;방향은 파일의 실제 레코드 순서를 나타냅니다. 인덱스 파일을 읽을 때 &quot;다음&quot;및 &quot;이전&quot;방향은 파일 내에서 레코드가 실제로 발생하는 위치에 관계없이 파일 레코드의 기본 또는 대체 레코드 키 값 시퀀스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="38c4d1aee98684f6b56eea111c3623b05f2c82cf" translate="yes" xml:space="preserve">
          <source>When reading any sequential (any organization) or relative file, the &amp;ldquo;next&amp;rdquo; direction refers to the physical sequence of records in the file. When reading an indexed file, the &amp;ldquo;next&amp;rdquo; and &amp;ldquo;previous&amp;rdquo; directions refer to the sequence of primary or alternate record key values in the file&amp;rsquo;s records, regardless of where the records physically occur within the file.</source>
          <target state="translated">순차 (모든 조직) 또는 상대 파일을 읽을 때 &quot;다음&quot;방향은 파일에있는 레코드의 실제 순서를 나타냅니다. 인덱싱 된 파일을 읽을 때 &quot;다음&quot;및 &quot;이전&quot;지침은 레코드가 파일 내에서 물리적으로 발생하는 위치에 관계없이 파일 레코드의 기본 또는 대체 레코드 키 값 시퀀스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3f6d782d21d25a325bf3c06a721b2e954c4410af" translate="yes" xml:space="preserve">
          <source>When reserved words appear without underlining, as this one is, they are optional; such reserved words are available in the language syntax merely to improve readability &amp;mdash; their presence or absence has no effect upon the program.</source>
          <target state="translated">예약어가 밑줄없이 나타나면이 단어는 선택 사항입니다. 이러한 예약어는 가독성을 향상시키기 위해 언어 구문으로 제공됩니다. 존재 여부는 프로그램에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c768ddd74129ff295493f476c55dc10dc7c0634" translate="yes" xml:space="preserve">
          <source>When searching a table with</source>
          <target state="translated">표를 검색 할 때</target>
        </trans-unit>
        <trans-unit id="9bf691cf2e7161985065f654248401fc0ecfeb3b" translate="yes" xml:space="preserve">
          <source>When searching a table with &quot;n&quot; entries, a binary search will need a worst-case of log2(n) tests in order to find an entry and log2(n) tests to identify that an entry doesn&amp;rsquo;t exist (n = the number of entries in the table), where &quot;log2&quot; is the base-2 logarithm function.</source>
          <target state="translated">&quot;n&quot;항목이있는 테이블을 검색 할 때 이진 검색은 항목을 찾기 위해 최악의 경우 log2 (n) 테스트와 항목이 존재하지 않는 것을 식별하기 위해 log2 (n) 테스트가 필요합니다 (n = the &quot;log2&quot;는 밑이 2 인 로그 함수입니다.</target>
        </trans-unit>
        <trans-unit id="7f79e279fbc5ca83bb92ac3dcf632fe2490e114e" translate="yes" xml:space="preserve">
          <source>When searching a table with &quot;n&quot; entries, a sequential search will need an average of n/2 tests and a worst case of n tests in order to find an entry and n tests to identify that an entry doesn&amp;rsquo;t exist.</source>
          <target state="translated">&quot;n&quot;항목이있는 테이블을 검색 할 때, 순차 검색에는 항목을 찾기 위해 평균 n / 2 테스트와 최악의 n 테스트가 필요하고 항목이 존재하지 않음을 식별하기 위해 n 테스트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b8f4490281d75e98dc4f428a3b0c03843c89ab2b" translate="yes" xml:space="preserve">
          <source>When single record locking is in effect, as a new record is accessed, locks held for previous records are released. By using this option, not only is the newly accessed record locked (as &lt;code&gt;WITH LOCK&lt;/code&gt; would do), but prior record locks will be retained as well. A subsequent &lt;code&gt;READ&lt;/code&gt; without the &lt;code&gt;KEPT LOCK&lt;/code&gt; option will release all &amp;ldquo;kept&amp;rdquo; locks, as will the &lt;code&gt;UNLOCK&lt;/code&gt; statement.</source>
          <target state="translated">단일 레코드 잠금이 적용되면 새 레코드에 액세스 할 때 이전 레코드에 대해 보유 된 잠금이 해제됩니다. 이 옵션을 사용하면 새로 액세스 한 레코드가 잠길뿐만 아니라 ( &lt;code&gt;WITH LOCK&lt;/code&gt; 이 수행하는 것처럼 ) 이전 레코드 잠금도 유지됩니다. &lt;code&gt;KEPT LOCK&lt;/code&gt; 옵션이 없는 후속 &lt;code&gt;READ&lt;/code&gt; 는 &lt;code&gt;UNLOCK&lt;/code&gt; 문과 마찬가지로 모든 &quot;유지&quot;잠금을 해제 합니다.</target>
        </trans-unit>
        <trans-unit id="1ead7f9a0129742e47eb21548cb149b2afd83a4f" translate="yes" xml:space="preserve">
          <source>When single record locking is in-effect, as a new record is accessed, locks held for previous records are released. By using this option, not only is the newly-accessed record locked (as WITH LOCK would do), but prior record locks will be retained as well. A subsequent&lt;code&gt;READ&lt;/code&gt;without the&lt;code&gt;KEPT LOCK&lt;/code&gt;option will release all &quot;kept&quot; locks, as will the&lt;code&gt;UNLOCK&lt;/code&gt;statement.</source>
          <target state="translated">단일 레코드 잠금이 영향을받는 경우 새 레코드에 액세스 할 때 이전 레코드에 대해 보유 된 잠금이 해제됩니다. 이 옵션을 사용하면 WITH LOCK처럼 새로 액세스 한 레코드가 잠길뿐만 아니라 이전 레코드 잠금도 유지됩니다. &lt;code&gt;KEPT LOCK&lt;/code&gt; 옵션이 없는 후속 &lt;code&gt;READ&lt;/code&gt; 는 &lt;code&gt;UNLOCK&lt;/code&gt; 문과 마찬가지로 모든 &quot;kept&quot;잠금을 해제 합니다.</target>
        </trans-unit>
        <trans-unit id="09c805a4126f146b319ecf7473a0ae797bc14095" translate="yes" xml:space="preserve">
          <source>When specifying &lt;code&gt;FALSE&lt;/code&gt;, the value assigned to each parent data item will be the value specified for the &lt;code&gt;FALSE&lt;/code&gt; clause of the condition name&amp;rsquo;s definition; if any &lt;var&gt;condition-name-1&lt;/var&gt; occurrence lacks a &lt;code&gt;FALSE&lt;/code&gt; clause, the &lt;code&gt;SET&lt;/code&gt; statement will be rejected by the compiler.</source>
          <target state="translated">&lt;code&gt;FALSE&lt;/code&gt; 를 지정할 때 각 상위 데이터 항목에 할당 된 값 은 조건 이름 정의 의 &lt;code&gt;FALSE&lt;/code&gt; 절에 지정된 값이됩니다 . 어떤 경우 &lt;var&gt;condition-name-1&lt;/var&gt; 발생이 부족 &lt;code&gt;FALSE&lt;/code&gt; 절을의 &lt;code&gt;SET&lt;/code&gt; 의 문은 컴파일러에 의해 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="0bc08ca7102847a5381dda441b941e229da8ede1" translate="yes" xml:space="preserve">
          <source>When specifying &lt;code&gt;TRUE&lt;/code&gt;, the value assigned to each parent data item will be the first value specified on the condition name&amp;rsquo;s &lt;code&gt;VALUE&lt;/code&gt; clause.</source>
          <target state="translated">지정하는 경우 &lt;code&gt;TRUE&lt;/code&gt; 를 , 각 상위 데이터 항목에 할당 된 값은 조건 이름의에 지정된 첫 번째 값이됩니다 &lt;code&gt;VALUE&lt;/code&gt; 의 절.</target>
        </trans-unit>
        <trans-unit id="ba00b2b56dccc0c37a2385d169dfa2ac94c0801e" translate="yes" xml:space="preserve">
          <source>When specifying&lt;code&gt;FALSE&lt;/code&gt; the value assigned to each parent data item will be the value specified for the&lt;code&gt;FALSE&lt;/code&gt;clause of the condition name&amp;rsquo;s definition; if any &amp;lt;</source>
          <target state="translated">&lt;code&gt;FALSE&lt;/code&gt; 를 지정할 때 각 상위 데이터 항목에 지정된 값 은 조건 이름 정의 의 &lt;code&gt;FALSE&lt;/code&gt; 절에 지정된 값입니다 . 만약에 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="4356780039a5293c513a6b6cd5c3842864bda12f" translate="yes" xml:space="preserve">
          <source>When specifying&lt;code&gt;TRUE&lt;/code&gt; the value assigned to each parent data item will be the first value specified on the condition name&amp;rsquo;s&lt;code&gt;VALUE&lt;/code&gt;clause.</source>
          <target state="translated">지정하는 경우 &lt;code&gt;TRUE&lt;/code&gt; 각 상위 데이터 항목에 할당 된 값은 조건 이름의에 지정된 첫 번째 값이됩니다 &lt;code&gt;VALUE&lt;/code&gt; 의 절.</target>
        </trans-unit>
        <trans-unit id="55f3e3f1e06a97818ce0ffb33865599309fb29ae" translate="yes" xml:space="preserve">
          <source>When the</source>
          <target state="translated">때</target>
        </trans-unit>
        <trans-unit id="79e5b7076245dc3a86ca03ed0827ab574faf4d6f" translate="yes" xml:space="preserve">
          <source>When the  &lt;code&gt;ADDRESS OF&lt;/code&gt; clause is used</source>
          <target state="translated">때 &lt;code&gt;ADDRESS OF&lt;/code&gt; 절 사용</target>
        </trans-unit>
        <trans-unit id="3567380cba462a3ad588bf15ca96ed5e4b76ffa4" translate="yes" xml:space="preserve">
          <source>When the &amp;lt;</source>
          <target state="translated">때 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="ecb5c7291bd4406532b8655fe4140ec4851a635e" translate="yes" xml:space="preserve">
          <source>When the &amp;rsquo;Enter&amp;rsquo; key is pressed.</source>
          <target state="translated">'Enter'키를 누를 때</target>
        </trans-unit>
        <trans-unit id="8e20f0275461f08d21e23d49bdf76f1f6fe85033" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;var&gt;expression-1&lt;/var&gt; CHARACTERS&lt;/code&gt; option is used, &lt;code&gt;INITIALIZED&lt;/code&gt; will initialize the allocated memory block to binary zeros. If &lt;code&gt;INITIALIZED&lt;/code&gt; is not used, the initial contents of allocated memory will be left to whatever rules of memory allocation are in effect for the operating system the program is running under.</source>
          <target state="translated">경우 &lt;code&gt;&lt;var&gt;expression-1&lt;/var&gt; CHARACTERS&lt;/code&gt; 옵션이 사용된다 &lt;code&gt;INITIALIZED&lt;/code&gt; 는 진 0에 할당 된 메모리 블록을 초기화한다. 경우 &lt;code&gt;INITIALIZED&lt;/code&gt; 가 사용되지 않는, 할당 된 메모리의 초기 내용은 메모리 할당의 규칙은 프로그램이 실행중인 운영 체제에 적용되는 무엇에 남아있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="be480e8eea6e58fa6e5466aacf6c82835c748aea" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ALLOCATE&lt;/code&gt; statement (see &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt;) statement is used to allocate a data item or to simply allocate an area of storage of a size specified on the &lt;code&gt;ALLOCATE&lt;/code&gt;, that allocation may occur with or without initialization, as per the programmer&amp;rsquo;s needs.</source>
          <target state="translated">(가)하면 &lt;code&gt;ALLOCATE&lt;/code&gt; 문 (참조 &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt; 문은 단순히이 지정 사이즈의 기억 영역에 할당하는 데이터 항목을 할당하는 데 사용하거나한다) &lt;code&gt;ALLOCATE&lt;/code&gt; 를 그 할당 프로그래머의 요구에 따라, 또는 초기화없이 발생할 수있다.</target>
        </trans-unit>
        <trans-unit id="894d040ba5fa8b3e5cb90265478b84612bba6b8f" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;ENTRY&lt;/code&gt; statement (see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;) is being used.</source>
          <target state="translated">때 &lt;code&gt;ENTRY&lt;/code&gt; 의 문 (참조 &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY을&lt;/a&gt; )를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="15a2637446da369c6a84dd21d2cb77e317c5ce74" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Enter&lt;/code&gt; key is pressed.</source>
          <target state="translated">때 &lt;code&gt;Enter&lt;/code&gt; 키를 누르면됩니다.</target>
        </trans-unit>
        <trans-unit id="7ddd20c21f69d1d224573cedc8fa5f5ec2d3a883" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;LOCALE&lt;/code&gt; keyword is not specified, the returning value is negative if string contains CR, DB, or a minus sign.</source>
          <target state="translated">때 &lt;code&gt;LOCALE&lt;/code&gt; 키워드가 지정되지 않은 문자열 CR, DB, 또는 빼기 기호를 포함하는 경우, 반환 값은 음수입니다.</target>
        </trans-unit>
        <trans-unit id="7b85b7c5b15e048a542364c0d1a081d339c2e37d" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;LOCALE&lt;/code&gt; keyword is specified, the returned value is negative if string contains a negative sign and when not specified, the returning value is negative if string contains CR, DB, or a minus sign.</source>
          <target state="translated">때 &lt;code&gt;LOCALE&lt;/code&gt; 키워드가 지정 문자열이 음의 기호를 포함하고 지정되지 않은 경우 문자열 CR, DB, 또는 빼기 기호를 포함하는 경우, 반환 값이 음수 인 경우, 반환 값은 음수입니다.</target>
        </trans-unit>
        <trans-unit id="1e4a4d22937d10446524e6c96a2f5792de9e5d3b" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;LOCALE&lt;/code&gt; keyword is specified, the returned value is negative if string contains a negative sign.</source>
          <target state="translated">때 &lt;code&gt;LOCALE&lt;/code&gt; 키워드가 지정 문자열이 음의 기호가 포함되어있는 경우, 반환 값은 음수입니다.</target>
        </trans-unit>
        <trans-unit id="2f97b62345646ee39a7f16760a5af6857e3287b8" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;PERFORM&lt;/code&gt; begins execution, the &lt;code&gt;FROM&lt;/code&gt; value will be moved to &lt;var&gt;identifier&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;PERFORM&lt;/code&gt; 실행이 시작 되면 &lt;code&gt;FROM&lt;/code&gt; 값이 &lt;var&gt;identifier&lt;/var&gt; 로 이동됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b8a9f607f1a20c72d1d8cf6f0864f0a9619df30" translate="yes" xml:space="preserve">
          <source>When the &lt;var&gt;identifier-1&lt;/var&gt; option is used in conjunction with  &lt;code&gt;INITIALIZED&lt;/code&gt; (or its internationalized alternative &lt;code&gt;INITIALISED&lt;/code&gt;), the allocated memory block will be initialized as if an &lt;code&gt;INITIALIZE &lt;var&gt;identifier-1&lt;/var&gt; WITH FILLER ALL TO VALUE THEN TO DEFAULT&lt;/code&gt; (see &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;) were executed.</source>
          <target state="translated">때 &lt;var&gt;identifier-1&lt;/var&gt; 옵션과 함께 사용 &lt;code&gt;INITIALIZED&lt;/code&gt; (또는 국제화 대안 &lt;code&gt;INITIALISED&lt;/code&gt; )을 것처럼, 할당 된 메모리 블록은 초기화 될 &lt;code&gt;INITIALIZE &lt;var&gt;identifier-1&lt;/var&gt; WITH FILLER ALL TO VALUE THEN TO DEFAULT&lt;/code&gt; (참조 &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE을&lt;/a&gt; ) 수행되었다.</target>
        </trans-unit>
        <trans-unit id="bf7962ebc9274427208d796901bf8406bfc55d0c" translate="yes" xml:space="preserve">
          <source>When the character set in use is ASCII with no collating sequence modifications, the &lt;code&gt;LOW-VALUES&lt;/code&gt; figurative constant value is the ASCII &lt;code&gt;NUL&lt;/code&gt; character. Because character sets can be redefined, however, you should not rely on this fact. Use the &lt;code&gt;NULL&lt;/code&gt; figurative constant instead.</source>
          <target state="translated">사용중인 문자 세트가 배열 순서 수정없이 ASCII 인 경우 &lt;code&gt;LOW-VALUES&lt;/code&gt; 형상 상수 값은 ASCII &lt;code&gt;NUL&lt;/code&gt; 문자입니다. 그러나 문자 집합을 재정의 할 수 있으므로이 사실에 의존해서는 안됩니다. 사용 &lt;code&gt;NULL&lt;/code&gt; 의 대신 상징적 상수를.</target>
        </trans-unit>
        <trans-unit id="eec1d6e3a7e2975948f245e3fa65949ec9243c1e" translate="yes" xml:space="preserve">
          <source>When the character set in use is ASCII with no collating sequence modifications, the&lt;code&gt;LOW-VALUES&lt;/code&gt;figurative constant value is the ASCII &quot;NUL&quot; character. Because character sets can be redefined, however, you should not rely on this fact &amp;mdash; use the&lt;code&gt;NULL&lt;/code&gt;figurative constant instead.</source>
          <target state="translated">사용중인 문자 세트가 배열 순서를 수정하지 않은 ASCII 인 경우 &lt;code&gt;LOW-VALUES&lt;/code&gt; 형상 상수 값은 ASCII &quot;NUL&quot;문자입니다. 그러나 문자 집합을 재정의 할 수 있기 때문에이 사실에 의존해서는 안됩니다 . 대신 &lt;code&gt;NULL&lt;/code&gt; 비유 상수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2dadab11f4931efd0eadc4c86b99fe85b231c15c" translate="yes" xml:space="preserve">
          <source>When the compiler is operating in Fixed Format Mode, all CDF statements must begin in column eight (8) or beyond.</source>
          <target state="translated">컴파일러가 고정 형식 모드에서 작동하는 경우 모든 CDF 문은 8 열 이상에서 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="ddf6ead6cf2735f6d4733429ca466edfebfc4036" translate="yes" xml:space="preserve">
          <source>When the console is running in a windowed environment, this will be the sizing of the window in which the program is executing, in terms of horizontal (&lt;code&gt;COLUMNS&lt;/code&gt;) or vertical (&lt;code&gt;LINES&lt;/code&gt;) character counts &amp;mdash; not pixels.</source>
          <target state="translated">콘솔이 윈도우 환경에서 실행될 때 이것은 픽셀이 아닌 수평 ( &lt;code&gt;COLUMNS&lt;/code&gt; ) 또는 수직 ( &lt;code&gt;LINES&lt;/code&gt; ) 문자 수의 관점에서 프로그램이 실행되는 윈도우의 크기입니다 .</target>
        </trans-unit>
        <trans-unit id="40abc34cb1f8c895d660e103e7ef08d30419b512" translate="yes" xml:space="preserve">
          <source>When the console is running in a windowed environment, this will be the sizing of the window in which the program is executing, in terms of horizontal &lt;code&gt;COLUMNS&lt;/code&gt; or vertical &lt;code&gt;LINES&lt;/code&gt; character counts &amp;mdash; not pixels.</source>
          <target state="translated">콘솔이 윈도우 환경에서 실행될 때, 이것은 픽셀이 아닌 수평 &lt;code&gt;COLUMNS&lt;/code&gt; 또는 수직 &lt;code&gt;LINES&lt;/code&gt; 문자 수 와 관련하여 프로그램이 실행되는 창의 크기입니다 .</target>
        </trans-unit>
        <trans-unit id="49d311bd71e37ea88f80c1acf5a46cc2cd7e9896" translate="yes" xml:space="preserve">
          <source>When the end of the currently-compiling source file is reached, Replace Mode is deactivated and any stacked replace specifications will be discarded &amp;mdash; compilation of the next source file (if any) will begin with Replace Mode inactive and no change specification(s) on the stack.</source>
          <target state="translated">현재 컴파일중인 소스 파일의 끝에 도달하면 교체 모드가 비활성화되고 스택 된 교체 사양이 모두 폐기됩니다. 다음 소스 파일 (있는 경우)의 컴파일은 교체 모드가 비활성화 된 상태에서 시작되고 변경 사양은 없습니다. 스택.</target>
        </trans-unit>
        <trans-unit id="2227a36d5cd7f4d291abcce4764658ad8567a554" translate="yes" xml:space="preserve">
          <source>When the file is read, the GnuCOBOL runtime system will strip the trailing delimiter sequence from each record. The data will be padded (on the right) with spaces if the data just read is shorter than the area described for data records in the program. If the data is too long, it will be truncated and the excess will be lost.</source>
          <target state="translated">파일을 읽을 때 GnuCOBOL 런타임 시스템은 각 레코드에서 후미 구분 기호 시퀀스를 제거합니다. 방금 읽은 데이터가 프로그램의 데이터 레코드에 대해 설명 된 영역보다 짧은 경우 데이터는 공백으로 채워집니다 (오른쪽). 데이터가 너무 길면 잘리고 초과분이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="4eebc909f1695d64257ea0ebfb9c8ad6e5e72760" translate="yes" xml:space="preserve">
          <source>When the file is read, the data is transferred into the program exactly as it exists in the file.</source>
          <target state="translated">파일을 읽을 때 데이터는 파일에있는 그대로 프로그램으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="1095f382913505e70906f62a227a9960253628ee" translate="yes" xml:space="preserve">
          <source>When the file is read, the data is transferred into the program exactly as it exists in the file. In the event that a short record is read as the very last record, that record will be padded (to the right) with spaces.</source>
          <target state="translated">파일을 읽을 때 데이터는 파일에있는 그대로 프로그램으로 전송됩니다. 짧은 레코드를 마지막 레코드로 읽는 경우 해당 레코드는 공백으로 채워집니다 (오른쪽).</target>
        </trans-unit>
        <trans-unit id="4714998234fd85ca6aacf95b1f60fc2e0606d179" translate="yes" xml:space="preserve">
          <source>When the file is written by a GnuCOBOL program, no delimiter sequence is appended to the data, but a record-length field is added to the beginning of each physical record.</source>
          <target state="translated">파일이 GnuCOBOL 프로그램에 의해 작성되면 구분 기호 시퀀스가 ​​데이터에 추가되지 않지만 레코드 길이 필드는 각 실제 레코드의 시작 부분에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="734d5bfe0d79dd47fee0117ca7b442dfa911220b" translate="yes" xml:space="preserve">
          <source>When the file is written to by a GnuCOBOL program, the delimiter sequence will be automatically appended to each data record as it is written to the file. A &lt;code&gt;WRITE&lt;/code&gt; (see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;) to this type of file will be done as if a &lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt; clause were specified on the &lt;code&gt;WRITE&lt;/code&gt;, if no &lt;code&gt;ADVANCING&lt;/code&gt; clause is coded.</source>
          <target state="translated">GnuCOBOL 프로그램에 의해 파일이 기록 될 때 구분 기호 시퀀스는 파일에 기록 될 때 각 데이터 레코드에 자동으로 추가됩니다. &lt;code&gt;WRITE&lt;/code&gt; (참조 &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt; 이 유형의 파일에)는 경우로 수행됩니다 &lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt; 절을에 지정된 &lt;code&gt;WRITE&lt;/code&gt; 없는 경우, &lt;code&gt;ADVANCING&lt;/code&gt; 절을 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81691df2003fd4bbec12f9dc36d30933f837ffbe" translate="yes" xml:space="preserve">
          <source>When the file is written to by a GnuCOBOL program, the delimiter sequence will be automatically appended to each data record as it is written to the file. A&lt;code&gt;WRITE&lt;/code&gt;(see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;) to this type of file will be done as if a&lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt;clause were specified on the&lt;code&gt;WRITE&lt;/code&gt; if no&lt;code&gt;ADVANCING&lt;/code&gt;clause is coded.</source>
          <target state="translated">파일이 GnuCOBOL 프로그램에 의해 쓰여질 때, 분리 문자 시퀀스는 파일에 쓰여질 때 각 데이터 레코드에 자동으로 추가됩니다. &lt;code&gt;WRITE&lt;/code&gt; (참조 &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt; 것처럼이 유형의 파일에)가 수행됩니다 &lt;code&gt;BEFORE ADVANCING 1 LINE&lt;/code&gt; 절을에 지정된 &lt;code&gt;WRITE&lt;/code&gt; 어떤 경우 &lt;code&gt;ADVANCING&lt;/code&gt; 절을 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1276c9afafc3c7cbe0e2680e29bf8de066051280" translate="yes" xml:space="preserve">
          <source>When the first &lt;code&gt;GENERATE&lt;/code&gt; statement for a report is executed, the contents of all control fields are saved so they may be referenced during the processing of subsequent &lt;code&gt;GENERATE&lt;/code&gt; statements.</source>
          <target state="translated">보고서에 대한 첫 번째 &lt;code&gt;GENERATE&lt;/code&gt; 문이 실행되면 모든 제어 필드의 내용이 저장되므로 후속 &lt;code&gt;GENERATE&lt;/code&gt; 문을 처리하는 동안 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1c4a220f73cf6e6321e6a87a7569c10ca47095d" translate="yes" xml:space="preserve">
          <source>When the first&lt;code&gt;GENERATE&lt;/code&gt;statement for a report is executed, the contents of all control fields are saved so they may be referenced during the processing of subsequent&lt;code&gt;GENERATE&lt;/code&gt;statements.</source>
          <target state="translated">보고서 의 첫 번째 &lt;code&gt;GENERATE&lt;/code&gt; 문이 실행될 때 모든 제어 필드의 컨텐츠가 저장되어 후속 &lt;code&gt;GENERATE&lt;/code&gt; 문 처리 중에 참조 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="074e2dcc44a417676e5996468b40ba0494eff2f2" translate="yes" xml:space="preserve">
          <source>When the program runs, it produces the output:</source>
          <target state="translated">프로그램이 실행되면 출력이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a8010d73ef14277722d75fc16df53fde2a0c078f" translate="yes" xml:space="preserve">
          <source>When the report group containing this clause is presented, the value of the specified numeric literal or identifier will be automatically moved to the report data item prior to presentation.</source>
          <target state="translated">이 절을 포함하는 보고서 그룹이 표시되면 지정된 숫자 리터럴 또는 식별자의 값이 프리젠 테이션 전에 보고서 데이터 항목으로 자동 이동됩니다.</target>
        </trans-unit>
        <trans-unit id="0d926bc0fa4507f912079e3d2a6e26167c916cc0" translate="yes" xml:space="preserve">
          <source>When the report is defined, it&amp;rsquo;s &lt;code&gt;RD&lt;/code&gt; would contain a &lt;code&gt;CONTROLS ARE&lt;/code&gt; clause that lists the control breaks in least- to most-frequent sequence of changing. This would be coded as:</source>
          <target state="translated">보고서가 정의되면 &lt;code&gt;RD&lt;/code&gt; 에는 제어 중단을 최소에서 가장 자주 변경하는 순서로 나열 하는 &lt;code&gt;CONTROLS ARE&lt;/code&gt; 절이 포함 됩니다. 이것은 다음과 같이 코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="f3c5fe04ca5c5ff54e7b4c5484bdebe852cb3224" translate="yes" xml:space="preserve">
          <source>When the report is defined, it&amp;rsquo;s&lt;code&gt;RD&lt;/code&gt;would contain a&lt;code&gt;CONTROLS ARE&lt;/code&gt;clause that lists the control breaks in least- to most-frequent sequence of changing. This would be coded as:</source>
          <target state="translated">보고서가 정의되면 &lt;code&gt;RD&lt;/code&gt; 에는 &lt;code&gt;CONTROLS ARE&lt;/code&gt; 절이 포함되어 있으며 가장 자주 또는 자주 변경되는 순서대로 제어 구분을 나열합니다. 이것은 다음과 같이 코딩됩니다 :</target>
        </trans-unit>
        <trans-unit id="bcfb647dc5347cb77600489e720593442321749d" translate="yes" xml:space="preserve">
          <source>When the screen item whose definition this clause is part of (or its parent) is accepted, the current contents of the screen item will be saved back to &amp;lt;</source>
          <target state="translated">이 항목의 정의가 부모 (또는 그 상위) 인 화면 항목을 승인하면 화면 항목의 현재 내용이 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="f6c69b77f7d6afff68ae39105204f8cae1f097bd" translate="yes" xml:space="preserve">
          <source>When the screen item whose definition this clause is part of (or its parent) is accepted, the current contents of the screen item will be saved back to &lt;var&gt;identifier-1&lt;/var&gt; at the conclusion of the &lt;code&gt;ACCEPT&lt;/code&gt;.</source>
          <target state="translated">정의가이 절의 일부 (또는 부모) 인 화면 항목이 수락되면 화면 항목의 현재 내용은 &lt;code&gt;ACCEPT&lt;/code&gt; 종료시 &lt;var&gt;identifier-1&lt;/var&gt; 에 다시 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="695d50e951aec5be635277efb4ba5d0a5d981166" translate="yes" xml:space="preserve">
          <source>When the screen item whose definition this clause is part of is displayed, the value currently in &amp;lt;</source>
          <target state="translated">이 절이 정의 된 화면 항목이 표시되면 현재 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="7628a889c9e1cc10cecbd9a56fda45e3348d7d26" translate="yes" xml:space="preserve">
          <source>When the screen item whose definition this clause is part of is displayed, the value currently in &lt;var&gt;identifier-1&lt;/var&gt; will be automatically moved into the screen item first.</source>
          <target state="translated">이 절이 정의 된 화면 항목이 표시되면 현재 &lt;var&gt;identifier-1&lt;/var&gt; 에있는 값 이 자동으로 화면 항목으로 먼저 이동합니다.</target>
        </trans-unit>
        <trans-unit id="75d1eb809603a41225da0d020749337d5898a6fe" translate="yes" xml:space="preserve">
          <source>When the statements within the perform scope terminate the loop iteration, by one of:</source>
          <target state="translated">수행 범위 내의 명령문이 다음 중 하나에 의해 루프 반복을 종료 할 때 :</target>
        </trans-unit>
        <trans-unit id="07b8542ab787f6c8b8c395ad790e2a6b7ca2ff49" translate="yes" xml:space="preserve">
          <source>When the statements within the perform scope terminate the loop iteration, by&amp;hellip;</source>
          <target state="translated">수행 범위 내의 명령문이 루프 반복을 종료하면</target>
        </trans-unit>
        <trans-unit id="69280dd9886752b96dbde5900ee345503734c4e6" translate="yes" xml:space="preserve">
          <source>When the system is not running a windowing environment, the physical console screen attributes will be returned.</source>
          <target state="translated">시스템이 윈도우 환경을 실행하지 않으면 실제 콘솔 화면 속성이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f718469daec1d449d89ac94fc080a888412ff614" translate="yes" xml:space="preserve">
          <source>When the system is running in a windowed environment, this will be the sizing of the console window in which the program is executing. When the system is not running a windowing environment, the physical console screen attributes will be returned. In environments such as a Windows console window, where the logical size of the window may far exceed that of the physical console window, the size returned will be that of the physical console window. Two one-byte values will be returned &amp;mdash; the first will be the current number of lines (rows) while the second will be the number of columns.</source>
          <target state="translated">시스템이 창 환경에서 실행될 때 프로그램이 실행되는 콘솔 창의 크기가됩니다. 시스템이 윈도우 환경을 실행하지 않으면 실제 콘솔 화면 속성이 리턴됩니다. 창의 콘솔 크기가 실제 콘솔 창의 크기를 훨씬 초과 할 수있는 Windows 콘솔 창의 환경에서는 리턴되는 크기가 실제 콘솔 창의 크기가됩니다. 두 개의 1 바이트 값이 리턴됩니다. 첫 번째는 현재 행 수 (행)이고 두 번째는 열 수입니다.</target>
        </trans-unit>
        <trans-unit id="0588efd75f99da9dc80511ef21ac1bc96cb67b8a" translate="yes" xml:space="preserve">
          <source>When the value is</source>
          <target state="translated">값이</target>
        </trans-unit>
        <trans-unit id="4bd372c2bfab46fb27f74cff162404f89944fc1c" translate="yes" xml:space="preserve">
          <source>When the&lt;code&gt;&amp;lt;&lt;i&gt;expression-1&lt;/i&gt;&amp;gt; CHARACTERS&lt;/code&gt;option is used,&lt;code&gt;INITIALIZED&lt;/code&gt;will initialize the allocated memory block to binary zeros. If&lt;code&gt;INITIALIZED&lt;/code&gt;is not used, the initial contents of allocated memory will be left to whatever rules of memory allocation are in effect for the operating system the program is running under.</source>
          <target state="translated">때 &lt;code&gt;&amp;lt;&lt;i&gt;expression-1&lt;/i&gt;&amp;gt; CHARACTERS&lt;/code&gt; 옵션이 사용된다 &lt;code&gt;INITIALIZED&lt;/code&gt; 는 진 0에 할당 된 메모리 블록을 초기화한다. 경우 &lt;code&gt;INITIALIZED&lt;/code&gt; 가 사용되지 않는, 할당 된 메모리의 초기 내용은 메모리 할당의 규칙은 프로그램이 실행중인 운영 체제에 적용되는 무엇에 남아있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="2d804e2ac555d7cf12d198a962f66c87e56b175e" translate="yes" xml:space="preserve">
          <source>When the&lt;code&gt;-m&lt;/code&gt;switch is used, an operating-system specific dynamically-loadable module is generated</source>
          <target state="translated">때 &lt;code&gt;-m&lt;/code&gt; 스위치가 사용되며, 운영 시스템 특정 동적으로로드 가능한 모듈을 생성</target>
        </trans-unit>
        <trans-unit id="13f46effb41077b1e944109400444a4ff5cd4992" translate="yes" xml:space="preserve">
          <source>When the&lt;code&gt;ADDRESS OF&lt;/code&gt;</source>
          <target state="translated">때 &lt;code&gt;ADDRESS OF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d289ba86ffbf5db049321c033b99dd64249f3f0f" translate="yes" xml:space="preserve">
          <source>When the&lt;code&gt;ADDRESS OF&lt;/code&gt;clause is used</source>
          <target state="translated">때 &lt;code&gt;ADDRESS OF&lt;/code&gt; 절 사용</target>
        </trans-unit>
        <trans-unit id="a8b9a2b204f8e6e0ca17a32a4de5e1a2e43de083" translate="yes" xml:space="preserve">
          <source>When the&lt;code&gt;ALLOCATE&lt;/code&gt;statement (see &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt;) statement is used to allocate a data item or to simply allocate an area of storage of a size specified on the&lt;code&gt;ALLOCATE&lt;/code&gt; that allocation may occur with or without initialization, as per the programmer&amp;rsquo;s needs.</source>
          <target state="translated">(가)하면 &lt;code&gt;ALLOCATE&lt;/code&gt; 문 (참조 &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt; 단순히 지정 사이즈의 기억 영역을 할당 문 데이터 항목을 할당하는 데 사용되거나) &lt;code&gt;ALLOCATE&lt;/code&gt; 프로그래머의 요구에 따라, 또는 초기화없이 발생할 수있는 할당.</target>
        </trans-unit>
        <trans-unit id="74a04afcd016118307ae353a14ee261c728b8565" translate="yes" xml:space="preserve">
          <source>When the&lt;code&gt;ENTRY&lt;/code&gt;statement (see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;) is being used.</source>
          <target state="translated">때 &lt;code&gt;ENTRY&lt;/code&gt; 의 문 (참조 &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY을&lt;/a&gt; )를 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5250dcf950b00231f60ea92c0ea15f05da5cadc0" translate="yes" xml:space="preserve">
          <source>When the&lt;code&gt;PERFORM&lt;/code&gt;begins execution, the&lt;code&gt;FROM&lt;/code&gt;value will be moved to &amp;lt;</source>
          <target state="translated">(가)하면 &lt;code&gt;PERFORM&lt;/code&gt; 실행 시작은 &lt;code&gt;FROM&lt;/code&gt; 값으로 이동한다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="72447040e7a4b4f4bf2a5e524fd5777a11ef4d60" translate="yes" xml:space="preserve">
          <source>When there</source>
          <target state="translated">있을 때</target>
        </trans-unit>
        <trans-unit id="d0ccd0b2ea32415458ae1ae69c697ed322392468" translate="yes" xml:space="preserve">
          <source>When this clause is present, the data item in question will be presented only under the following circumstances:</source>
          <target state="translated">이 절이 존재하면 해당 데이터 항목은 다음 상황에서만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7dc17405518b6980336acdba10a4b2585042c992" translate="yes" xml:space="preserve">
          <source>When this form of an &lt;code&gt;EXIT&lt;/code&gt; statement is used, it must be the only statement in the procedure (paragraph or section) in which it occurs. This is</source>
          <target state="translated">이 형식의 &lt;code&gt;EXIT&lt;/code&gt; 문을 사용하는 경우 해당 문이 발생하는 프로 시저 (단락 또는 섹션)에서 유일한 문이어야합니다. 이것은</target>
        </trans-unit>
        <trans-unit id="aabb87d78c631aff329a8607b2f22afa622c4b99" translate="yes" xml:space="preserve">
          <source>When this form of an&lt;code&gt;EXIT&lt;/code&gt;statement is used, it must be the only statement in the procedure (paragraph or section) in which it occurs.</source>
          <target state="translated">이 형식의 &lt;code&gt;EXIT&lt;/code&gt; 문을 사용하는 경우, 프로 시저 (문단 또는 섹션)에서 발생하는 유일한 명령문이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b860ec563aab15f40737913cdf9afa37254cd05b" translate="yes" xml:space="preserve">
          <source>When this kind of file is written to by a GnuCOBOL program, an end-of-record delimiter sequence will be automatically added to each data record as it is written to the file. A &lt;code&gt;WRITE&lt;/code&gt; to this type of file will be done as if an &lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt; clause were specified on the &lt;code&gt;WRITE&lt;/code&gt;, if no &lt;code&gt;ADVANCING&lt;/code&gt; clause is coded.</source>
          <target state="translated">이러한 종류의 파일이 GnuCOBOL 프로그램에 의해 기록 될 때, 레코드 끝 구분 기호 시퀀스는 파일에 기록 될 때 각 데이터 레코드에 자동으로 추가됩니다. &lt;code&gt;WRITE&lt;/code&gt; 는 IF으로이 유형의 파일에이 수행됩니다 &lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt; 절을에 지정된 &lt;code&gt;WRITE&lt;/code&gt; 없는 경우, &lt;code&gt;ADVANCING&lt;/code&gt; 절을 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97b30ad0f25dcade2d01e3738933c789a0d0e584" translate="yes" xml:space="preserve">
          <source>When this kind of file is written to by a GnuCOBOL program, an end-of-record delimiter sequence will be automatically added to each data record as it is written to the file. A&lt;code&gt;WRITE&lt;/code&gt;to this type of file will be done as if an&lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt;clause were specified on the&lt;code&gt;WRITE&lt;/code&gt; if no&lt;code&gt;ADVANCING&lt;/code&gt;clause is coded.</source>
          <target state="translated">이런 종류의 파일이 GnuCOBOL 프로그램에 의해 쓰여질 때, 레코드 끝 분리 문자 순서는 파일에 쓰여질 때 각 데이터 레코드에 자동으로 추가됩니다. &lt;code&gt;ADVANCING&lt;/code&gt; 절이 코딩 되지 않은 경우 &lt;code&gt;WRITE&lt;/code&gt; 에 &lt;code&gt;AFTER ADVANCING 1 LINE&lt;/code&gt; 절이 지정된 것처럼이 유형의 파일에 대한 &lt;code&gt;WRITE&lt;/code&gt; 가 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="f0a1df19b6c99bf68d1fce26c8f95a4cf1892a89" translate="yes" xml:space="preserve">
          <source>When unprintable area exists at all four margins of the paper? These are generally caused by the printer itself or by its software driver.</source>
          <target state="translated">용지의 여백에 인쇄 할 수없는 영역이있는 경우 이러한 문제는 일반적으로 프린터 자체 또는 소프트웨어 드라이버로 인해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="194120b0286a35a2dcf5def798c14d60552c4e11" translate="yes" xml:space="preserve">
          <source>When used in the definition of a screen data item:</source>
          <target state="translated">화면 데이터 항목의 정의에 사용되는 경우 :</target>
        </trans-unit>
        <trans-unit id="914017cc4ba60a76096040e81843243f6f2a9e4a" translate="yes" xml:space="preserve">
          <source>When used on a report section data item, &lt;code&gt;COLUMN PLUS&lt;/code&gt; will position the start of the new field&amp;rsquo;s value such that there are &lt;var&gt;integer-1&lt;/var&gt; blank columns between the end of the previous field and the beginning of this field.</source>
          <target state="translated">보고서 섹션 데이터 항목에 사용되는 경우 &lt;code&gt;COLUMN PLUS&lt;/code&gt; 는 이전 필드의 끝과이 필드의 시작 사이에 &lt;var&gt;integer-1&lt;/var&gt; 빈 열 이 있도록 새 필드 값의 시작 위치를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="5d7dee905f968e799c08d314024c914b9335fa97" translate="yes" xml:space="preserve">
          <source>When used on a report section data item,&lt;code&gt;COLUMN PLUS&lt;/code&gt;will position the start of the new field&amp;rsquo;s value such that there are &amp;lt;</source>
          <target state="translated">보고서 섹션 데이터 항목에 사용될 경우 &lt;code&gt;COLUMN PLUS&lt;/code&gt; 는 새 필드 값의 시작 위치를 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="884c39afc934b6095268ea1decfd4c3b0cbc1283" translate="yes" xml:space="preserve">
          <source>When used on a screen section data item, &lt;code&gt;COLUMN PLUS&lt;/code&gt; will position the new field so that it begins exactly &lt;var&gt;integer-1&lt;/var&gt; or &lt;var&gt;identifier-1&lt;/var&gt; characters past the</source>
          <target state="translated">화면 섹션 데이터 항목에 사용되는 경우 &lt;code&gt;COLUMN PLUS&lt;/code&gt; 는 새 필드를 배치하여 정확히 &lt;var&gt;integer-1&lt;/var&gt; 또는 &lt;var&gt;identifier-1&lt;/var&gt; 문자로 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="f12387ad8083a72240747b5e731f9f439e5dc6b8" translate="yes" xml:space="preserve">
          <source>When used on a screen section data item,&lt;code&gt;COLUMN PLUS&lt;/code&gt;will position the new field so that it begins exactly &amp;lt;</source>
          <target state="translated">화면 섹션 데이터 항목에서 사용될 경우 &lt;code&gt;COLUMN PLUS&lt;/code&gt; 는 새 필드가 정확하게 시작되도록 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="9e374f1e81c11afd2249d3f6a2521b72f3b2fd5f" translate="yes" xml:space="preserve">
          <source>When used with &lt;code&gt;ADD&lt;/code&gt; or &lt;code&gt;SUBTRACT&lt;/code&gt; verbs, both &lt;var&gt;data-item-1&lt;/var&gt; and &lt;var&gt;data-item-2&lt;/var&gt; must be numeric, elementary, unedited items.</source>
          <target state="translated">&lt;code&gt;ADD&lt;/code&gt; 또는 &lt;code&gt;SUBTRACT&lt;/code&gt; 동사 와 함께 사용하는 경우 &lt;var&gt;data-item-1&lt;/var&gt; 및 &lt;var&gt;data-item-2&lt;/var&gt; 는 모두 숫자, 기본, 편집되지 않은 항목이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d3150b52f68f349f04fa41c40fdf390a964be9a0" translate="yes" xml:space="preserve">
          <source>When used with a &lt;code&gt;MOVE&lt;/code&gt; verb&amp;hellip;</source>
          <target state="translated">&lt;code&gt;MOVE&lt;/code&gt; 동사 와 함께 사용하면 &amp;hellip;</target>
        </trans-unit>
        <trans-unit id="65aa1415a9565bd8d28746dc9c2570be60594107" translate="yes" xml:space="preserve">
          <source>When used with a&lt;code&gt;MOVE&lt;/code&gt;verb&amp;hellip;</source>
          <target state="translated">&lt;code&gt;MOVE&lt;/code&gt; 동사 와 함께 사용하면 &amp;hellip;</target>
        </trans-unit>
        <trans-unit id="735fedfc0b2cf513cd84398c479056078487c738" translate="yes" xml:space="preserve">
          <source>When used with&lt;code&gt;ADD&lt;/code&gt;or&lt;code&gt;SUBTRACT&lt;/code&gt;verbs, both &amp;lt;</source>
          <target state="translated">&lt;code&gt;ADD&lt;/code&gt; 또는 &lt;code&gt;SUBTRACT&lt;/code&gt; 동사 와 함께 사용하는 경우 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="a1d5f337922c35e7829e56c9add16387bc638cc5" translate="yes" xml:space="preserve">
          <source>When using  &lt;code&gt;THRU&lt;/code&gt;, the values on both sides of the &lt;code&gt;THRU&lt;/code&gt; must be the same class (both numeric, both alphanumeric, etc.).</source>
          <target state="translated">사용시 &lt;code&gt;THRU&lt;/code&gt; 의 양쪽의 값 &lt;code&gt;THRU&lt;/code&gt; 는 동일한 클래스 (두 숫자 모두 영숫자 등)이어야한다.</target>
        </trans-unit>
        <trans-unit id="c148563bd1d3d7efcb2e158a73738fe2860d1763" translate="yes" xml:space="preserve">
          <source>When using&lt;code&gt;THRU&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;THRU&lt;/code&gt; 를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="3c15ffd2b0bb8da495d78e861fe2dddbedf49918" translate="yes" xml:space="preserve">
          <source>When viewing, note the Default settings.</source>
          <target state="translated">볼 때 기본 설정에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="9b62a103f642fae7a427ae64fffefd39ac8918ae" translate="yes" xml:space="preserve">
          <source>When you accept from the  &lt;code&gt;COMMAND-LINE&lt;/code&gt; option, you will retrieve the entire set of arguments entered on the command line that executed the program, exactly as they were specified. Parsing that returned data into its meaningful information will be your responsibility.</source>
          <target state="translated">&lt;code&gt;COMMAND-LINE&lt;/code&gt; 옵션 에서 수락 하면 프로그램을 실행 한 명령 줄에 입력 된 전체 인수 집합이 지정된대로 정확하게 검색됩니다. 반환 된 데이터를 의미있는 정보로 구문 분석하는 것은 귀하의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="3a8294f64ceb40348b6de0e74db01a84f5474364" translate="yes" xml:space="preserve">
          <source>When you accept from the&lt;code&gt;COMMAND-LINE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;COMMAND-LINE&lt;/code&gt; 줄에서 수락 할 때</target>
        </trans-unit>
        <trans-unit id="6bd1b751d7e6715a12fe1f8e23931d88a5a54f9a" translate="yes" xml:space="preserve">
          <source>When you are looking at or editing any large COBOL program that has been created with programming standards that include these two rules, it is always a simple thing to know whether a reference to a procedure is being made to code that exists before or after your current location in the program, simply by comparing the numeric component of the current procedure&amp;rsquo;s name with the one in question.</source>
          <target state="translated">이 두 가지 규칙을 포함하는 프로그래밍 표준으로 작성된 대형 COBOL 프로그램을 보거나 편집 할 때 항상 현재 또는 이전에 존재하는 코드에 대한 프로 시저 참조가 있는지 여부를 아는 것은 간단합니다. 현재 프로 시저 이름의 숫자 구성 요소와 해당 프로 시저의 숫자 구성 요소를 비교하여 프로그램의 위치.</target>
        </trans-unit>
        <trans-unit id="c326fe2a33e3eca5f34e00297d48c498f3021042" translate="yes" xml:space="preserve">
          <source>When you call a subroutine using &amp;lt;</source>
          <target state="translated">&amp;lt;를 사용하여 서브 루틴을 호출 할 때</target>
        </trans-unit>
        <trans-unit id="eee00164dba357ac9a72f6248f8cc64846630a22" translate="yes" xml:space="preserve">
          <source>When you call a subroutine using &lt;var&gt;identifier-1&lt;/var&gt;, you are forcing the runtime system to call a dynamically-loadable subprogram. The contents of &lt;var&gt;identifier-1&lt;/var&gt; will be the entry-point name within that module. If this is the</source>
          <target state="translated">&lt;var&gt;identifier-1&lt;/var&gt; 을 사용하여 서브 루틴 을 호출하면 런타임 시스템이 동적으로로드 가능한 서브 프로그램을 호출하게됩니다. &lt;var&gt;identifier-1&lt;/var&gt; 의 내용은 해당 모듈 내의 진입 점 이름이됩니다. 이것이</target>
        </trans-unit>
        <trans-unit id="850e8bd50831bfdcfe07cdaca0354267afadbc42" translate="yes" xml:space="preserve">
          <source>When you write GnuCOBOL programs, you&amp;rsquo;ll need to create a variety of words to represent various aspects of the program, the program&amp;rsquo;s data and the external environment in which the program will run. This will include internal names by which data files will be referenced, data item names and names of executable logic procedures.</source>
          <target state="translated">GnuCOBOL 프로그램을 작성할 때 프로그램의 다양한 측면, 프로그램의 데이터 및 프로그램이 실행될 외부 환경을 나타내는 다양한 단어를 만들어야합니다. 여기에는 데이터 파일이 참조되는 내부 이름, 데이터 항목 이름 및 실행 가능한 논리 프로 시저의 이름이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ffc520b222e77da15b6c865b34612d86ea5838f2" translate="yes" xml:space="preserve">
          <source>When your program opens a file with this sharing option in effect, no restrictions will be placed on other programs attempting to &lt;code&gt;OPEN&lt;/code&gt; the file after your program did. This is the default sharing mode.</source>
          <target state="translated">프로그램이 효과에서이 공유 옵션으로 파일을 열 때 제한을 시도하는 다른 프로그램에 배치되지 않습니다 &lt;code&gt;OPEN&lt;/code&gt; 프로그램이 한 후 파일을. 이것이 기본 공유 모드입니다.</target>
        </trans-unit>
        <trans-unit id="c9af7dd389fd17e7c67b109e83a0d0b301a015b6" translate="yes" xml:space="preserve">
          <source>When your program opens a file with this sharing option in effect, no restrictions will be placed on other programs attempting to&lt;code&gt;OPEN&lt;/code&gt;the file after your program did. This is the default sharing mode.</source>
          <target state="translated">프로그램이 효과에서이 공유 옵션으로 파일을 열 때 제한을 시도하는 다른 프로그램에 배치되지 않습니다 &lt;code&gt;OPEN&lt;/code&gt; 프로그램이 한 후 파일을. 이것이 기본 공유 모드입니다.</target>
        </trans-unit>
        <trans-unit id="352ce31eca7b7204069433d6d52c76781abb09b0" translate="yes" xml:space="preserve">
          <source>When your program opens a file with this sharing option in effect, your program announces that it is unwilling to allow any other program to have any access to the file as long as you are using that file; &lt;code&gt;OPEN&lt;/code&gt; attempts made in other programs will fail with a file status of 37 (&lt;code&gt;PERMISSION DENIED&lt;/code&gt;) until such time as you &lt;code&gt;CLOSE&lt;/code&gt; (see &lt;a href=&quot;#CLOSE&quot;&gt;CLOSE&lt;/a&gt;) the file.</source>
          <target state="translated">프로그램에서이 공유 옵션이 적용된 파일을 열면 프로그램은 해당 파일을 사용하는 동안 다른 프로그램이 파일에 액세스하는 것을 허용하지 않는다고 알립니다. &lt;code&gt;OPEN&lt;/code&gt; 다른 프로그램에서 만든 시도는 (37의 파일 상태로 실패합니다 &lt;code&gt;PERMISSION DENIED&lt;/code&gt; 하면 같은 시간까지) &lt;code&gt;CLOSE&lt;/code&gt; (참조 &lt;a href=&quot;#CLOSE&quot;&gt;CLOSE&lt;/a&gt; 파일).</target>
        </trans-unit>
        <trans-unit id="12ebbc4e8a1599c7bdbee469dfb83f639975ca1d" translate="yes" xml:space="preserve">
          <source>When your program opens a file with this sharing option in effect, your program announces that it is unwilling to allow any other program to have any access to the file as long as you are using that file;&lt;code&gt;OPEN&lt;/code&gt;attempts made in other programs will fail with a file status of 37 (&quot;PERMISSION DENIED&quot;) until such time as you&lt;code&gt;CLOSE&lt;/code&gt;(see &lt;a href=&quot;#CLOSE&quot;&gt;CLOSE&lt;/a&gt;) the file.</source>
          <target state="translated">프로그램이이 공유 옵션을 사용하여 파일을 열면 프로그램은 해당 파일을 사용하는 한 다른 프로그램이 파일에 액세스 할 수 없다는 것을 알립니다. &lt;code&gt;OPEN&lt;/code&gt; 당신이 같은 다른 프로그램에서 만든 시도 때까지 37의 파일 상태 ( &quot;사용 권한이 거부되었습니다&quot;) 실패합니다 &lt;code&gt;CLOSE&lt;/code&gt; (참조 &lt;a href=&quot;#CLOSE&quot;&gt;CLOSE를&lt;/a&gt; 파일).</target>
        </trans-unit>
        <trans-unit id="556c79f22f6ffdcc416d17471e5d496b461c5104" translate="yes" xml:space="preserve">
          <source>When, during the processing of a subsequent &lt;code&gt;GENERATE&lt;/code&gt;, it is determined that a control field has changed value (ie. a control break has occurred), the appropriate control footing and control heading processing will take place and a snapshot of the current values of all control fields will again be saved.</source>
          <target state="translated">후속 &lt;code&gt;GENERATE&lt;/code&gt; 처리 중에 제어 필드 값이 변경되었다고 판단되면 (즉, 제어 중단이 발생 했음) 적절한 제어 기초 및 제어 머리글 처리가 발생하고 모든 항목의 현재 값에 대한 스냅 샷이 생성됩니다. 제어 필드가 다시 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="989ffa5528ba9c1e7d6cced1426d8c8808d2dc65" translate="yes" xml:space="preserve">
          <source>When, during the processing of a subsequent&lt;code&gt;GENERATE&lt;/code&gt; it is determined that a control field has changed value (ie. a control break has occurred), the appropriate control footing and control heading processing will take place and a snapshot of the current values of all control fields will again be saved.</source>
          <target state="translated">후속 &lt;code&gt;GENERATE&lt;/code&gt; 처리 중에 제어 필드 값이 변경되었다고 판단되면 (즉, 제어 중단이 발생 함) 적절한 제어 푸팅 및 제어 표제 처리가 수행되고 모든 제어의 현재 값에 대한 스냅 샷이 생성됩니다. 필드가 다시 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="aba2821f2c7d19a9257df5bad889f05eefb35aa0" translate="yes" xml:space="preserve">
          <source>When&lt;code&gt;BEFORE ADVANCING&lt;/code&gt;</source>
          <target state="translated">때 &lt;code&gt;BEFORE ADVANCING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="660c42a17efa48500b4895ec5768fbd5f4682f3e" translate="yes" xml:space="preserve">
          <source>When&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) are specified.</source>
          <target state="translated">때 &lt;code&gt;DECLARATIVES&lt;/code&gt; 는 (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES를&lt;/a&gt; ) 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="8be9ad62baef7dbf9c77304fcc8e3b58cbb0fc10" translate="yes" xml:space="preserve">
          <source>When&lt;code&gt;GIVING&lt;/code&gt;is specified, none of the &amp;lt;</source>
          <target state="translated">&lt;code&gt;GIVING&lt;/code&gt; 이 지정 되면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="9f15bbea56b2d4b899e335cb9a345cd9d8f82a29" translate="yes" xml:space="preserve">
          <source>When&lt;code&gt;SEPARATE CHARACTER&lt;/code&gt;is specified, the&lt;code&gt;S&lt;/code&gt;symbol in the data item&amp;rsquo;s&lt;code&gt;PICTURE&lt;/code&gt;must be counted when determining the data item&amp;rsquo;s size.</source>
          <target state="translated">경우 &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt; 지정되면, &lt;code&gt;S&lt;/code&gt; 의 데이터 항목의 상징 &lt;code&gt;PICTURE&lt;/code&gt; 데이터 항목의 크기를 결정할 때 계산해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e42c65e553940b7f9a1f905ef498a75f481d086" translate="yes" xml:space="preserve">
          <source>When&lt;code&gt;USING&lt;/code&gt;</source>
          <target state="translated">When&lt;code&gt;USING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="043b8829b0449fc5ab1a590150209867725cb659" translate="yes" xml:space="preserve">
          <source>When&lt;code&gt;WRITE&lt;/code&gt;is used against an&lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt;) file, with or without the&lt;code&gt;LINE ADVANCING&lt;/code&gt;(see &lt;a href=&quot;#LINE-ADVANCING&quot;&gt;LINE ADVANCING&lt;/a&gt;) option, an end-of-record delimiter character sequence will be written to the file to signify where one record ends and the next record begins. This delimiter sequence will be either of the following:</source>
          <target state="translated">때 &lt;code&gt;WRITE&lt;/code&gt; 가 에 사용되는 &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;조직 LINE SEQUENTIAL&lt;/a&gt; 와 함께 또는없이, 파일)을 &lt;code&gt;LINE ADVANCING&lt;/code&gt; (참조 &lt;a href=&quot;#LINE-ADVANCING&quot;&gt;LINE 전진&lt;/a&gt; ) 옵션, 최종의 레코드 구분 문자 순서가 파일에 기록 될 위치를 하나 개의 레코드를 의미합니다 종료하고 다음 레코드가 시작됩니다. 이 분리 문자 순서는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="81fc3749ee583c3bc9f0ced7fa3089a97dbbf1a6" translate="yes" xml:space="preserve">
          <source>Whenever Gross-Revenue is referenced in calculations, or whenever its value is moved to another data item, the value of Gross-Revenue will be treated as if it is &lt;code&gt;&lt;var&gt;nnn&lt;/var&gt;000000&lt;/code&gt;, where &lt;code&gt;&lt;var&gt;nnn&lt;/var&gt;&lt;/code&gt; is the actual value in storage.</source>
          <target state="translated">Gross-Revenue가 계산에서 참조되거나 값이 다른 데이터 항목으로 이동 될 때마다 Gross-Revenue 값은 &lt;code&gt;&lt;var&gt;nnn&lt;/var&gt;000000&lt;/code&gt; 인 것처럼 처리됩니다 . 여기서 &lt;code&gt;&lt;var&gt;nnn&lt;/var&gt;&lt;/code&gt; 은 스토리지의 실제 값입니다.</target>
        </trans-unit>
        <trans-unit id="5b508f605ade03c2f540e4f5a3cebc74803e17cc" translate="yes" xml:space="preserve">
          <source>Whenever Gross-Revenue is referenced in calculations, or whenever its value is moved to another data item, the value of Gross-Revenue will be treated as if it is nnn000000, where &amp;rsquo;nnn&amp;rsquo; is the actual value in storage.</source>
          <target state="translated">총 수익이 계산에서 참조되거나 해당 값이 다른 데이터 항목으로 이동 될 때마다 총 수익의 값은 nnn000000 인 것처럼 처리됩니다. 여기서 'nnn'은 스토리지의 실제 값입니다.</target>
        </trans-unit>
        <trans-unit id="785ec59aee9a72bba26200b372a399baa862df4e" translate="yes" xml:space="preserve">
          <source>Whenever the parent data item assumes any value</source>
          <target state="translated">부모 데이터 항목이 값을 가질 때마다</target>
        </trans-unit>
        <trans-unit id="3020ed815683faf46902fc4b199d49c0e3b037f1" translate="yes" xml:space="preserve">
          <source>Whether or not changes made to an argument within a subroutine will be &quot;visible&quot; to the calling program depends on how the argument was passed. There are three ways in which arguments may be passed from a calling program to a subroutine, as defined by the use of optional&lt;code&gt;BY&lt;/code&gt;clauses in the&lt;code&gt;CALL&lt;/code&gt;(see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;) statement&amp;rsquo;s list of arguments.</source>
          <target state="translated">서브 루틴 내의 인수에 대한 변경이 호출 프로그램에 &quot;표시&quot;되는지 여부는 인수가 전달 된 방법에 따라 다릅니다. &lt;code&gt;CALL&lt;/code&gt; ( &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt; 참조 ) 명령문의 인수 목록 에서 선택적 &lt;code&gt;BY&lt;/code&gt; 절을 사용하여 정의 된대로 호출 프로그램에서 서브 루틴으로 인수를 전달할 수있는 세 가지 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5d7fae378f9b419294f084f6d2785178d128606" translate="yes" xml:space="preserve">
          <source>Whether or not changes made to an argument within a subroutine will be &amp;ldquo;visible&amp;rdquo; to the calling program depends on how the argument was passed. There are three ways in which arguments may be passed from a calling program to a subroutine, as defined by the use of optional &lt;code&gt;BY&lt;/code&gt; clauses in the &lt;code&gt;CALL&lt;/code&gt; (see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;) statement&amp;rsquo;s list of arguments.</source>
          <target state="translated">서브 루틴 내의 인수에 대한 변경 사항이 호출 프로그램에 &quot;표시&quot;되는지 여부는 인수가 전달 된 방법에 따라 다릅니다. &lt;code&gt;CALL&lt;/code&gt; ( &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt; 참조 ) 명령문의 인수 목록 에서 선택적 &lt;code&gt;BY&lt;/code&gt; 절을 사용하여 정의 된대로 호출 프로그램에서 서브 루틴으로 인수를 전달할 수있는 세 가지 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74b6469707bcf11ab46a854d5b8ab7de06f6723e" translate="yes" xml:space="preserve">
          <source>Whether or not this clause operates on Cygwin or UNIX/Linux/OSX systems will depend upon the video attribute capabilities of the terminal output drivers and &amp;ldquo;curses&amp;rdquo; software being used.</source>
          <target state="translated">이 절이 Cygwin 또는 UNIX / Linux / OSX 시스템에서 작동하는지 여부는 사용중인 터미널 출력 드라이버 및 &quot;curses&quot;소프트웨어의 비디오 속성 기능에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="993618ed434a2a43305ba7349ec2785f35f4d2db" translate="yes" xml:space="preserve">
          <source>Whether or not this clause operates on Cygwin or UNIX/Linux/OSX systems will depend upon the video attribute capabilities of the terminal output drivers and &amp;rsquo;curses&amp;rsquo; software being used.</source>
          <target state="translated">이 절이 Cygwin 또는 UNIX / Linux / OSX 시스템에서 작동하는지 여부는 사용중인 터미널 출력 드라이버 및 '저주'소프트웨어의 비디오 속성 기능에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b72f722e09e0083d38fb90dd5444c9de133d0ddb" translate="yes" xml:space="preserve">
          <source>Whether the &lt;code&gt;CANCEL&lt;/code&gt; statement actually physically unloads a dynamically-loaded module or simply marks it as logically-unloaded depends on the use and value of the   &lt;code&gt;COB_PHYSICAL_CANCEL&lt;/code&gt; run-time environment variable (see &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;Run Time Environment Variables&lt;/a&gt;).</source>
          <target state="translated">(가) 여부 &lt;code&gt;CANCEL&lt;/code&gt; 문을 실제로 물리적으로 동적으로로드 된 모듈 또는 그와 같은 논리적으로 언로드 단순히 마크의 사용과 값에 따라 달라집니다 언로드 &lt;code&gt;COB_PHYSICAL_CANCEL&lt;/code&gt; 런타임 환경 변수 (참조 &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;실행 시간 환경 변수&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="16e0ad6794fdb0dfdd1676519f08a64fbdcb0d14" translate="yes" xml:space="preserve">
          <source>Whether the&lt;code&gt;CANCEL&lt;/code&gt;statement actually physically unloads a dynamically-loaded module or simply marks it as logically-unloaded depends on the use and value of the</source>
          <target state="translated">(가) 여부 &lt;code&gt;CANCEL&lt;/code&gt; 문을 실제로 물리적으로 동적으로로드 된 모듈을 언로드하거나 논리적으로-언로드 단순히 마크의 사용과 값에 따라 달라집니다</target>
        </trans-unit>
        <trans-unit id="6db0e2b97dbdb94af74fc2dc892c61e0833952d1" translate="yes" xml:space="preserve">
          <source>Whew!</source>
          <target state="translated">Whew!</target>
        </trans-unit>
        <trans-unit id="2d2aa5ab115d5ea9193b33a8f0fce25b2e1a1345" translate="yes" xml:space="preserve">
          <source>Whichever is specified &amp;mdash; &amp;lt;</source>
          <target state="translated">어느 것이 지정 되나 &amp;mdash; &amp;lt;</target>
        </trans-unit>
        <trans-unit id="413afb0cf0307c1a3eb5cba26f3d7d14f2c680a6" translate="yes" xml:space="preserve">
          <source>Whichever is specified &amp;mdash; &lt;var&gt;literal-1&lt;/var&gt;, &lt;var&gt;identifier-1&lt;/var&gt; or &lt;var&gt;function-reference-1&lt;/var&gt; &amp;mdash; that item will be referred to in the discussions that follows as the &amp;rsquo;</source>
          <target state="translated">지정된 항목 ( &lt;var&gt;literal-1&lt;/var&gt; , &lt;var&gt;identifier-1&lt;/var&gt; 또는 &lt;var&gt;function-reference-1&lt;/var&gt; 은 다음 토론에서 '</target>
        </trans-unit>
        <trans-unit id="bb22ce173d1b9a5a41ef7fa2ee33bc7fcdd0f526" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;NUMVAL-C&lt;/code&gt; will always use the currency symbol that is specified via the &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; paragraph&amp;rsquo;s &lt;code&gt;CURRENCY SYMBOL&lt;/code&gt; (or the system default which is currently always &amp;lsquo;</source>
          <target state="translated">하지만 &lt;code&gt;NUMVAL-C&lt;/code&gt; 는 항상을 통해 지정된 통화 기호 사용 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; 단락의 &lt;code&gt;CURRENCY SYMBOL&lt;/code&gt; (또는 현재 항상 '는 시스템 기본을</target>
        </trans-unit>
        <trans-unit id="86a0cce83a62c7812099d3a8b1fa3d04f5ea4a12" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;NUMVAL-C&lt;/code&gt; will always use the currency symbol that is specified via the &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; paragraph&amp;rsquo;s &lt;code&gt;CURRENCY SYMBOL&lt;/code&gt; (or the system default which is currently always &amp;rsquo;$&amp;rsquo;) &lt;var&gt;argument-1&lt;/var&gt; shall have any of the following formats, where &amp;rsquo;#&amp;rsquo; represents a sequence of one or more decimal digits and &amp;rsquo;$&amp;rsquo; represents the &lt;var&gt;symbol&lt;/var&gt; character:</source>
          <target state="translated">&lt;code&gt;NUMVAL-C&lt;/code&gt; 는 항상 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; 단락의 &lt;code&gt;CURRENCY SYMBOL&lt;/code&gt; (또는 현재 항상 '$'인 시스템 기본값)을 통해 지정된 통화 기호를 사용 하지만 &lt;var&gt;argument-1&lt;/var&gt; 은 다음 형식 중 하나를 가져야합니다. 여기서 '#'은 하나 이상의 10 진수 시퀀스와 '$'는 &lt;var&gt;symbol&lt;/var&gt; 문자를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="43c3d769c52a2d910ead2c74cc0e23b72bba6989" translate="yes" xml:space="preserve">
          <source>While GnuCOBOL supports few of the OOP programming constructs defined by the COBOL2002 and COBOL2014 standards, it supports every aspect of the ANSI 85 standard and therefore fully meets the needs of points #1 and #2, above. With its supported feature set (see &lt;a href=&quot;#So-What-is-GnuCOBOL_003f&quot;&gt;So What is GnuCOBOL?&lt;/a&gt;), it provides significant programmer productivity capabilities.</source>
          <target state="translated">GnuCOBOL은 COBOL2002 및 COBOL2014 표준에 정의 된 OOP 프로그래밍 구조를 거의 지원하지 않지만 ANSI 85 표준의 모든 측면을 지원하므로 위의 포인트 # 1 및 # 2의 요구 사항을 완전히 충족합니다. 지원되는 기능 세트 ( &lt;a href=&quot;#So-What-is-GnuCOBOL_003f&quot;&gt;GnuCOBOL이란 무엇입니까? 참조&lt;/a&gt; )를 통해 상당한 프로그래머 생산성 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2d9ab71a82ddf03172f5ae146fa990c99623a69e" translate="yes" xml:space="preserve">
          <source>While GnuCOBOL supports few of the OOP programming constructs defined by the COBOL2002 and COBOL20xx standards, it supports every aspect of the ANSI 85 standard and therefore fully meets the needs of points #1 and #2, above. With it&amp;rsquo;s supported feature set (see &lt;a href=&quot;#So-What-is-GnuCOBOL_003f&quot;&gt;So What is GnuCOBOL?&lt;/a&gt;), it provides significant programmer productivity capabilities.</source>
          <target state="translated">GnuCOBOL은 COBOL2002 및 COBOL20xx 표준으로 정의 된 OOP 프로그래밍 구성을 거의 지원하지 않지만 ANSI 85 표준의 모든 측면을 지원하므로 위의 1 번 및 2 번 지점의 요구를 완전히 충족합니다. 지원되는 기능 세트 ( &lt;a href=&quot;#So-What-is-GnuCOBOL_003f&quot;&gt;GnuCOBOL이란 무엇입니까? 참조&lt;/a&gt; )를 통해 중요한 프로그래머 생산성 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="34bb772bfc23ab0a162d8e4a8ceb98fb39b0e66c" translate="yes" xml:space="preserve">
          <source>While an &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; file may be defined as having variable-length records, the file will be structured in such a manner as to reserve space for each record equal to the size of the largest possible record as defined by the file&amp;rsquo;s description in the &lt;code&gt;FILE SECTION&lt;/code&gt;.</source>
          <target state="translated">동안 &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; 에서 파일의 설명에 의해 정의 된 바와 같은 파일이 가변 길이 레코드를 갖는 것으로 정의 될 수있다,이 파일은 각각의 기록 영역을 확보하는 것과 같은 방식으로 구성 될 가능한 최대 기록 크기와 동일 &lt;code&gt;FILE SECTION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc119e55dcd0c1775da7b76db9572116ad0f404f" translate="yes" xml:space="preserve">
          <source>While an&lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt;file may be defined as having variable-length records, the file will be structured in such a manner as to reserve space for each record equal to the size of the largest possible record as defined by the file&amp;rsquo;s description in the&lt;code&gt;FILE SECTION&lt;/code&gt;</source>
          <target state="translated">동안 &lt;code&gt;ORGANIZATION RELATIVE&lt;/code&gt; 에서 파일의 설명에 의해 정의 된 바와 같은 파일이 가변 길이 레코드를 갖는 것으로 정의 될 수있다,이 파일은 각각의 기록 영역을 확보하는 것과 같은 방식으로 구성 될 가능한 최대 기록 크기와 동일 &lt;code&gt;FILE SECTION&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9b658db9baa0989c9e3b4d3ec36c86799d0b8e0" translate="yes" xml:space="preserve">
          <source>While any COBOL implementation&amp;rsquo;s sort or merge facilities guarantee that records with duplicate key values will be in proper sequence with regard to other records with different key values, they generally make no promises as to the resulting relative sequence of records having duplicate key values with one another.</source>
          <target state="translated">COBOL 구현의 정렬 또는 병합 기능은 중복 키 값을 가진 레코드가 다른 키 값을 가진 다른 레코드와 관련하여 올바른 순서를 갖도록 보장하지만, 일반적으로 중복 키 값을 갖는 레코드의 상대적 상대 시퀀스에 대해서는 약속하지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="1c536667b503a5b3159f51a218c42911686d55c2" translate="yes" xml:space="preserve">
          <source>While coding only a single file name (the repeated &amp;lt;</source>
          <target state="translated">단일 파일 이름 만 코딩하면서 (반복되는 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="edbe59536ef531641905f5b678938ad7fcfd31b4" translate="yes" xml:space="preserve">
          <source>While coding only a single file name (the repeated &lt;var&gt;file-name-1&lt;/var&gt; item) is syntactically valid, this statement will have no effect upon the program unless at least two files are specified.</source>
          <target state="translated">단일 파일 이름 (반복되는 &lt;var&gt;file-name-1&lt;/var&gt; 항목) 만 코딩하는 것이 구문 상 유효하지만이 명령문은 최소한 두 개의 파일이 지정되지 않는 한 프로그램에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4898f28fd78ff6e887f5e83820e41d22333b3cdf" translate="yes" xml:space="preserve">
          <source>While many technological and procedural developments have made</source>
          <target state="translated">많은 기술 및 절차 적 개발이 이루어졌지만</target>
        </trans-unit>
        <trans-unit id="ce14adfadffafdc4cb2f8f2501d3b78ab504a483" translate="yes" xml:space="preserve">
          <source>While records in a &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; file may be defined as having variable-length records, the file will be structured in such a manner as to reserve space for each record equal to the size of the largest possible record, based on the file&amp;rsquo;s description in the &lt;code&gt;FILE SECTION&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; 파일의 레코드는 가변 길이 레코드를 갖는 것으로 정의 될 수 있지만, 파일은 &lt;code&gt;FILE SECTION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68135204143b500639be0a19a270194158addb58" translate="yes" xml:space="preserve">
          <source>While records in a&lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt;file may be defined as having variable-length records, the file will be structured in such a manner as to reserve space for each record equal to the size of the largest possible record, based on the file&amp;rsquo;s description in the&lt;code&gt;FILE SECTION&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; 파일의 레코드는 가변 길이 레코드를 갖는 것으로 정의 될 수 있지만, 파일은 파일의 설명에 따라 가능한 최대 레코드의 크기와 동일한 각 레코드의 공간을 예약하는 방식으로 구성됩니다. &lt;code&gt;FILE SECTION&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3cfce579f36338b8d7457dd5cdd72e83934491f" translate="yes" xml:space="preserve">
          <source>While simple, these two programs illustrate the techniques required quite nicely.</source>
          <target state="translated">이 두 프로그램은 간단하지만 필요한 기술을 잘 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1904e6c52b82123c5de9191c7776f45ed5f736cb" translate="yes" xml:space="preserve">
          <source>While still supported, this may well be removed in the future and should not be used. See &lt;code&gt;GCCOMP&lt;/code&gt; and &lt;code&gt;GNUCOBOL&lt;/code&gt; instead:</source>
          <target state="translated">여전히 지원되지만 향후 제거 될 수 있으므로 사용해서는 안됩니다. 대신 &lt;code&gt;GCCOMP&lt;/code&gt; 및 &lt;code&gt;GNUCOBOL&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51c18de6a0ec379a644b87853bd58290e34a1486" translate="yes" xml:space="preserve">
          <source>While the actual &lt;code&gt;IDENTIFICATION DIVISION&lt;/code&gt; or &lt;code&gt;ID DIVISION&lt;/code&gt; header is optional, the &lt;code&gt;PROGRAM-ID&lt;/code&gt; /  &lt;code&gt;FUNCTION-ID&lt;/code&gt; paragraphs are not; only one or the other, however, may be coded.</source>
          <target state="translated">실제 &lt;code&gt;IDENTIFICATION DIVISION&lt;/code&gt; 또는 &lt;code&gt;ID DIVISION&lt;/code&gt; 헤더는 선택 사항이지만 &lt;code&gt;PROGRAM-ID&lt;/code&gt; / &lt;code&gt;FUNCTION-ID&lt;/code&gt; 단락은 그렇지 않습니다. 그러나 둘 중 하나만 코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a47bb81be25a2cdf3581d7e855505093b3e30386" translate="yes" xml:space="preserve">
          <source>While the actual&lt;code&gt;IDENTIFICATION DIVISION&lt;/code&gt;or&lt;code&gt;ID DIVISION&lt;/code&gt;header is optional, the&lt;code&gt;PROGRAM-ID&lt;/code&gt;/&lt;code&gt;FUNCTION-ID&lt;/code&gt;</source>
          <target state="translated">실제 &lt;code&gt;IDENTIFICATION DIVISION&lt;/code&gt; 또는 &lt;code&gt;ID DIVISION&lt;/code&gt; 헤더는 선택 사항이지만 &lt;code&gt;PROGRAM-ID&lt;/code&gt; / &lt;code&gt;FUNCTION-ID&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ce78c0466970594eab37d7038114cc1d2e575c19" translate="yes" xml:space="preserve">
          <source>While there will typically be only be a single set of counting instructions on an &lt;code&gt;INSPECT&lt;/code&gt;:</source>
          <target state="translated">일반적으로 &lt;code&gt;INSPECT&lt;/code&gt; 에는 한 세트의 계산 지침 만 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72bf04cdadfed642909255f7fc579bddbbd28879" translate="yes" xml:space="preserve">
          <source>While there will typically be only be a single set of counting instructions on an&lt;code&gt;INSPECT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;INSPECT&lt;/code&gt; 에는 일반적으로 하나의 카운팅 명령 세트 만 있지만</target>
        </trans-unit>
        <trans-unit id="9350e537af97a798b7129108ac3ba640a6d62fce" translate="yes" xml:space="preserve">
          <source>While there will typically be only be a single set of replacement instructions on an &lt;code&gt;INSPECT&lt;/code&gt;:</source>
          <target state="translated">일반적으로 &lt;code&gt;INSPECT&lt;/code&gt; 에는 단일 교체 지침 세트 만 있습니다 .</target>
        </trans-unit>
        <trans-unit id="22879925a3c987ac29988c1ec2fc71f9d9d5a5c1" translate="yes" xml:space="preserve">
          <source>While there will typically be only be a single set of replacement instructions on an&lt;code&gt;INSPECT&lt;/code&gt;</source>
          <target state="translated">일반적으로 &lt;code&gt;INSPECT&lt;/code&gt; 에는 단일 교체 지시 세트 만 있지만</target>
        </trans-unit>
        <trans-unit id="a091d72e252c450765fbbf39d602cf3b4dcae823" translate="yes" xml:space="preserve">
          <source>While this code will display &lt;code&gt;AEIBFJCGKDHL&lt;/code&gt; on the console output window:</source>
          <target state="translated">이 코드는 콘솔 출력 창에 &lt;code&gt;AEIBFJCGKDHL&lt;/code&gt; 을 표시하지만 :</target>
        </trans-unit>
        <trans-unit id="29d43a6a9c4b7b033de415ebc142a3f57ece324e" translate="yes" xml:space="preserve">
          <source>While this code will display&lt;code&gt;AEIBFJCGKDHL&lt;/code&gt;on the console output window:</source>
          <target state="translated">이 코드는 콘솔 출력 창에 &lt;code&gt;AEIBFJCGKDHL&lt;/code&gt; 을 표시하지만 :</target>
        </trans-unit>
        <trans-unit id="99543c522e794b7d88e204113cdbdbd019d525a0" translate="yes" xml:space="preserve">
          <source>While we&amp;rsquo;re looking at sample code, this code displays &lt;code&gt;ABCEFG&lt;/code&gt;:</source>
          <target state="translated">샘플 코드를 보는 동안이 코드는 &lt;code&gt;ABCEFG&lt;/code&gt; 를 표시 합니다 .</target>
        </trans-unit>
        <trans-unit id="5a95c1be453d4df24ce5e16c30f82bcc31a23762" translate="yes" xml:space="preserve">
          <source>While we&amp;rsquo;re looking at sample code, this code displays&lt;code&gt;ABCEFG&lt;/code&gt;</source>
          <target state="translated">샘플 코드를보고있는 동안이 코드는 &lt;code&gt;ABCEFG&lt;/code&gt; 를 표시 합니다.</target>
        </trans-unit>
        <trans-unit id="caf3a21bbc17cb9f6d2a069e72716706eb83cda5" translate="yes" xml:space="preserve">
          <source>White: COB-COLOR-WHITE</source>
          <target state="translated">화이트 : COB-COLOR-WHITE</target>
        </trans-unit>
        <trans-unit id="893e0ae52146465f8879b903cc2cd576ae909bb7" translate="yes" xml:space="preserve">
          <source>Windows 16-bit &quot;thunking&quot; will be used to call the subroutine as a DLL.</source>
          <target state="translated">Windows 16 비트 &quot;썽킹&quot;은 서브 루틴을 DLL로 호출하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c44c44110ccd48cf9d68ccd53a21edcfdc414c35" translate="yes" xml:space="preserve">
          <source>Windows 16-bit &quot;thunking&quot; will not be in effect.</source>
          <target state="translated">Windows 16 비트 &quot;썽킹&quot;은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="738e806b29e3cd8e11cdc40311b0e3e9dd6b2ec4" translate="yes" xml:space="preserve">
          <source>Windows 16-bit &amp;ldquo;thunking&amp;rdquo; will be used to call the subroutine as a DLL.</source>
          <target state="translated">Windows 16 비트 &quot;thunking&quot;은 서브 루틴을 DLL로 호출하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="60b0de0c6822371eb1fc42e3a1bfd00883aaa6b3" translate="yes" xml:space="preserve">
          <source>Windows 16-bit &amp;ldquo;thunking&amp;rdquo; will not be in effect.</source>
          <target state="translated">Windows 16 비트 &quot;thunking&quot;은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a854364cf6b93b75d3740d8a770c6dd3b65e7eaa" translate="yes" xml:space="preserve">
          <source>Windows implementations of GnuCOBOL may, or may not, be similarly case sensitive with regard to copybook names, depending upon the Windows version and GnuCOBOL build options &amp;mdash; it is safest to simply treat the COPY command as case-sensitive in all environments.</source>
          <target state="translated">GnuCOBOL의 Windows 구현은 Windows 버전 및 GnuCOBOL 빌드 옵션에 따라 카피 북 이름과 관련하여 대소 문자를 유사하게 구분하거나 대소 문자를 구분하지 않을 수 있습니다. 모든 환경에서 COPY 명령을 대소 문자를 구분하여 처리하는 것이 가장 안전합니다.</target>
        </trans-unit>
        <trans-unit id="1054f28a5174d8cdc32cfadf25c22e4f7097d403" translate="yes" xml:space="preserve">
          <source>Windows implementations of GnuCOBOL may, or may not, be similarly case sensitive with regard to library names, depending upon the Windows version and GnuCOBOL build options &amp;mdash; it is safest to simply treat library names as case-sensitive in all environments.</source>
          <target state="translated">GnuCOBOL의 Windows 구현은 Windows 버전 및 GnuCOBOL 빌드 옵션에 따라 라이브러리 이름과 관련하여 대소 문자를 구분하거나 유사하지 않을 수 있습니다. 모든 환경에서 라이브러리 이름을 대소 문자를 구분하여 처리하는 것이 가장 안전합니다.</target>
        </trans-unit>
        <trans-unit id="8da945840c5e04775bc13e57dab1de5604b64371" translate="yes" xml:space="preserve">
          <source>Windows systems are case-insensitive with regard to environment variables, so there is no difference between the first two when using a GnuCOBOL implementation built for either Windows/MinGW or native Windows.</source>
          <target state="translated">Windows 시스템은 환경 변수와 관련하여 대소 문자를 구분하지 않으므로 Windows / MinGW 또는 기본 Windows 용으로 빌드 된 GnuCOBOL 구현을 사용할 때 처음 두 시스템간에 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="d514e41913d320d452417e0ba6c5fcc52ca55986" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;JUSTIFIED&lt;/code&gt;</source>
          <target state="translated">With &lt;code&gt;JUSTIFIED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa06feed7cedbea00f76e3fa9443e210cb593516" translate="yes" xml:space="preserve">
          <source>With JUSTIFIED</source>
          <target state="translated">JUSTIFIED로</target>
        </trans-unit>
        <trans-unit id="fe31c224b02d0a126187887b882bca596be517f1" translate="yes" xml:space="preserve">
          <source>With a binary search, express the number of entries as a binary number (1,000 = 1111101000), count the number of digits in the result (which is, essentially, what a logarithm is, when rounded up to the next integer &amp;mdash; the number of digits a decimal number would have if expressed in the logarithm&amp;rsquo;s number base). In this case, we end up with 10 &amp;mdash;</source>
          <target state="translated">With a binary search, express the number of entries as a binary number (1,000 = 1111101000), count the number of digits in the result (which is, essentially, what a logarithm is, when rounded up to the next integer &amp;mdash; the number of digits a decimal number would have if expressed in the logarithm&amp;rsquo;s number base). In this case, we end up with 10 &amp;mdash;</target>
        </trans-unit>
        <trans-unit id="11454b97dcb0273b7a714ac8435c03de473ffd56" translate="yes" xml:space="preserve">
          <source>With a binary search, express the number of entries as a binary number (1,000 = 1111101000), count the number of digits in the result (which is, essentially, what a logarithm is, when rounded up to the next integer &amp;mdash; the number of digits a decimal number would have if expressed in the logarithm&amp;rsquo;s number base). In this case, we end up with 10 &amp;mdash; THAT is the worst-case number of tests required to find an entry or to identify that it doesn&amp;rsquo;t exist. That&amp;rsquo;s quite an improvement!</source>
          <target state="translated">이진 검색을 사용하면 항목 수를 이진 숫자 (1,000 = 1111101000)로 표현하고 결과의 자릿수 (기본적으로 다음 정수로 반올림 할 때의 로그 수) 숫자는 로그의 숫자로 표현 된 경우 10 진수입니다. 이 경우 10으로 끝납니다. 항목을 찾거나 존재하지 않는 것을 식별하는 데 필요한 최악의 테스트 수입니다. 상당히 개선되었습니다!</target>
        </trans-unit>
        <trans-unit id="47e879273dc7c65aef87a79fda96d4ad7f96b774" translate="yes" xml:space="preserve">
          <source>With its original limitation on the length of variable names (one- to six-character names comprised of a letter followed by up to five letters and/or digits), it&amp;rsquo;s implicit rule that variable were automatically created as real (floating-point) unless their name started with a letter in the range I-N, and its use of algebraic notation to express actions being taken, FORTRAN wasn&amp;rsquo;t a particularly readable language, even for programmers. Compare this with the equivalent COBOL code:</source>
          <target state="translated">변수 이름의 길이에 대한 원래 제한 (문자와 최대 5 개의 문자 및 / 또는 숫자로 구성되는 1-6 자의 이름)으로 인해 변수가 자동으로 실수 (부동 소수점)로 생성 된 것은 암시적인 규칙입니다. 그들의 이름은 IN 범위의 문자로 시작했으며, 행동을 표현하기 위해 대수 표기법을 사용했기 때문에 FORTRAN은 프로그래머조차도 특히 읽을 수있는 언어가 아니 었습니다. 이것을 동등한 COBOL 코드와 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="b51faddd25f6109b2ed3a0899742109174e8eae6" translate="yes" xml:space="preserve">
          <source>With its original limitation on the length of variable names (one- to six-character names comprised of a letter followed by up to five letters and/or digits), its implicit rule that variables were automatically created as real (floating-point) unless their name started with a letter in the range I-N, and its use of algebraic notation to express actions being taken, FORTRAN wasn&amp;rsquo;t a particularly readable language, even for programmers. Compare this with the equivalent COBOL code:</source>
          <target state="translated">With its original limitation on the length of variable names (one- to six-character names comprised of a letter followed by up to five letters and/or digits), its implicit rule that variables were automatically created as real (floating-point) unless their name started with a letter in the range I-N, and its use of algebraic notation to express actions being taken, FORTRAN wasn&amp;rsquo;t a particularly readable language, even for programmers. Compare this with the equivalent COBOL code:</target>
        </trans-unit>
        <trans-unit id="fd0418f7bed2f93e5ebeccb68eca807233f86dda" translate="yes" xml:space="preserve">
          <source>With native Windows Windows/MinGW builds, the shell environment will be the Windows console window command processor (usually &quot;cmd.exe&quot;) appropriate for the version of Windows you&amp;rsquo;re using.</source>
          <target state="translated">기본 Windows Windows / MinGW 빌드에서는 셸 환경이 사용중인 Windows 버전에 적합한 Windows 콘솔 창 명령 프로세서 (일반적으로 &quot;cmd.exe&quot;)가됩니다.</target>
        </trans-unit>
        <trans-unit id="ade1871d4ba6ebc8091b613597376e1b3dd7fdd5" translate="yes" xml:space="preserve">
          <source>With native Windows Windows/MinGW builds, the shell environment will be the Windows console window command processor (usually &lt;code&gt;cmd.exe&lt;/code&gt;) appropriate for the version of Windows you&amp;rsquo;re using.</source>
          <target state="translated">With native Windows Windows/MinGW builds, the shell environment will be the Windows console window command processor (usually &lt;code&gt;cmd.exe&lt;/code&gt; ) appropriate for the version of Windows you&amp;rsquo;re using.</target>
        </trans-unit>
        <trans-unit id="d8a4b9d08d97e45adb4da87468c9bc15fb87e195" translate="yes" xml:space="preserve">
          <source>With the</source>
          <target state="translated">이랑</target>
        </trans-unit>
        <trans-unit id="5533efcd719d0939b4d8a09721f90f554e67f5bf" translate="yes" xml:space="preserve">
          <source>With the 1985 standard for COBOL, a much more elegant solution was introduced. Any COBOL  &lt;em&gt;Verb&lt;/em&gt; (the first reserved word of a statement) that needed such a thing was allowed to use an &lt;code&gt;END-&lt;var&gt;verb&lt;/var&gt;&lt;/code&gt; construct to end its scope without disrupting the scope of any other statement it might have been in. Any COBOL 85 compiler would have allowed the following solution to our problem:</source>
          <target state="translated">With the 1985 standard for COBOL, a much more elegant solution was introduced. Any COBOL &lt;em&gt;Verb&lt;/em&gt; (the first reserved word of a statement) that needed such a thing was allowed to use an &lt;code&gt;END-&lt;var&gt;verb&lt;/var&gt;&lt;/code&gt; construct to end its scope without disrupting the scope of any other statement it might have been in. Any COBOL 85 compiler would have allowed the following solution to our problem:</target>
        </trans-unit>
        <trans-unit id="900c601e8872bca9c518d845e59cdea0f51bca60" translate="yes" xml:space="preserve">
          <source>With the 1985 standard for COBOL, a much more elegant solution was introduced. Any COBOL &amp;rsquo;</source>
          <target state="translated">1985 년 COBOL 표준에 따라 훨씬 더 우아한 솔루션이 도입되었습니다. 모든 코볼 '</target>
        </trans-unit>
        <trans-unit id="96fd6e78b960ae95b45cff1310e5d2dd84e397a8" translate="yes" xml:space="preserve">
          <source>With the above example, if the inspect subject were &lt;code&gt;--ABCDEF----BCDEF--&lt;/code&gt;, the final result of the counting would be that &lt;code&gt;C-ABC&lt;/code&gt; would be incremented by 1 while &lt;code&gt;C-BCDE&lt;/code&gt; would be incremented only once; although the human eye clearly sees two &amp;lsquo;</source>
          <target state="translated">With the above example, if the inspect subject were &lt;code&gt;--ABCDEF----BCDEF--&lt;/code&gt; , the final result of the counting would be that &lt;code&gt;C-ABC&lt;/code&gt; would be incremented by 1 while &lt;code&gt;C-BCDE&lt;/code&gt; would be incremented only once; although the human eye clearly sees two &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="760a2321d6385d2d56b0c9ca66f658a2519750d9" translate="yes" xml:space="preserve">
          <source>With the above example, if the inspect subject were &lt;code&gt;--ABCDEF----BCDEF--&lt;/code&gt;, the final result of the replacement would be &lt;code&gt;--DEFDEF----WXYZF--&lt;/code&gt;.</source>
          <target state="translated">With the above example, if the inspect subject were &lt;code&gt;--ABCDEF----BCDEF--&lt;/code&gt; , the final result of the replacement would be &lt;code&gt;--DEFDEF----WXYZF--&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b2e3a1904c05e56dc97d5236366be38066e9720" translate="yes" xml:space="preserve">
          <source>With the above example, if the inspect subject were&lt;code&gt;--ABCDEF----BCDEF--&lt;/code&gt; the final result of the counting would be that C-ABC would be incremented by 1 while C-BCDE would be incremented only once; although the human eye clearly sees two &quot;BCDE&quot; sequences, the&lt;code&gt;INSPECT ... TALLYING&lt;/code&gt;would only &quot;see&quot; the second &amp;mdash; the first would have been processed by the first (higher-priority) counting instruction.</source>
          <target state="translated">위의 예에서 검사 대상이 &lt;code&gt;--ABCDEF----BCDEF--&lt;/code&gt; 인 경우 계산의 최종 결과는 C-ABC가 1 씩 증가하고 C-BCDE는 한 번만 증가한다는 것입니다. 인간의 눈에는 두 개의 &quot;BCDE&quot;서열이 명확하게 &lt;code&gt;INSPECT ... TALLYING&lt;/code&gt; 은 두 번째 만 &quot;보는&quot;것입니다.</target>
        </trans-unit>
        <trans-unit id="0ec61b9beac4bc288026474e74d20b0a8c2b16b1" translate="yes" xml:space="preserve">
          <source>With the above example, if the inspect subject were&lt;code&gt;--ABCDEF----BCDEF--&lt;/code&gt; the final result of the replacement would be&lt;code&gt;--DEFDEF----WXYZF--&lt;/code&gt;</source>
          <target state="translated">위의 예에서 검사 대상이 &lt;code&gt;--ABCDEF----BCDEF--&lt;/code&gt; 인 경우 교체의 최종 결과는 &lt;code&gt;--DEFDEF----WXYZF--&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6bfa1062b6dfc9197230a44113df7b463aed0e73" translate="yes" xml:space="preserve">
          <source>With the exception of logic procedure names, which may consist entirely of nothing but digits, user-defined words must contain at least one letter.</source>
          <target state="translated">숫자로만 구성된 논리 프로 시저 이름을 제외하고 사용자 정의 단어는 하나 이상의 문자를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="14cb39996348ed7ae459bae96a3b068a93114c37" translate="yes" xml:space="preserve">
          <source>With the&lt;code&gt;-x&lt;/code&gt;switch</source>
          <target state="translated">와 &lt;code&gt;-x&lt;/code&gt; 스위치</target>
        </trans-unit>
        <trans-unit id="c6ff49c8991a76b75a412956721d5748480a8cf4" translate="yes" xml:space="preserve">
          <source>With this change, &lt;code&gt;ABCDEFGHIJKL&lt;/code&gt; is once again displayed.</source>
          <target state="translated">With this change, &lt;code&gt;ABCDEFGHIJKL&lt;/code&gt; is once again displayed.</target>
        </trans-unit>
        <trans-unit id="78966db73e1c66deedbeb3320b74e26b2a795c32" translate="yes" xml:space="preserve">
          <source>With this change,&lt;code&gt;ABCDEFGHIJKL&lt;/code&gt;is once again displayed.</source>
          <target state="translated">이 변경으로 &lt;code&gt;ABCDEFGHIJKL&lt;/code&gt; 이 다시 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c48ba46a1c93ae133c3d083b0c8bb668c6624312" translate="yes" xml:space="preserve">
          <source>With this form My-01-Item can either be defined with the &lt;code&gt;BASED&lt;/code&gt; attribute or be defined in LINKAGE SECTION. Instead of LENGTH OF My-01-Item you may also use a size smaller to the maximum field size as long as you ensure that the complete field is never used.</source>
          <target state="translated">With this form My-01-Item can either be defined with the &lt;code&gt;BASED&lt;/code&gt; attribute or be defined in LINKAGE SECTION. Instead of LENGTH OF My-01-Item you may also use a size smaller to the maximum field size as long as you ensure that the complete field is never used.</target>
        </trans-unit>
        <trans-unit id="ad664d23a107a21ea15f8e0e447f33d5b4ec9d29" translate="yes" xml:space="preserve">
          <source>With this form, a block of storage equal in size to the defined size of My-01-Item (which must have been defined with the &lt;code&gt;BASED&lt;/code&gt; attribute) will be allocated. The address of that block of storage will become the base address of My-01-Item so that it and its subordinate data items become usable within the program.</source>
          <target state="translated">With this form, a block of storage equal in size to the defined size of My-01-Item (which must have been defined with the &lt;code&gt;BASED&lt;/code&gt; attribute) will be allocated. The address of that block of storage will become the base address of My-01-Item so that it and its subordinate data items become usable within the program.</target>
        </trans-unit>
        <trans-unit id="eacf1d46236299e914ae93e3d3c7dea5357d90e9" translate="yes" xml:space="preserve">
          <source>With this form, a block of storage equal in size to the defined size of My-01-Item (which must have been defined with the&lt;code&gt;BASED&lt;/code&gt;attribute) will be allocated. The address of that block of storage will become the base address of My-01-Item so that it and its subordinate data items become usable within the program.</source>
          <target state="translated">이 형식을 사용하면 정의 된 크기의 My-01-Item ( &lt;code&gt;BASED&lt;/code&gt; 속성 으로 정의되어야 함)과 동일한 크기의 스토리지 블록 이 할당됩니다. 해당 스토리지 블록의 주소는 My-01-Item의 기본 주소가되므로 프로그램 및 해당 하위 데이터 항목을 프로그램 내에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e37330921085546813e977e7d077fc41a6c9d12" translate="yes" xml:space="preserve">
          <source>With this option, the program will wait for a pre-configured time for the lock to be released. If the lock is released within the preconfigured wait time, the read will be successful. If the pre-configured wait time expires before the lock is released, the read attempt will be aborted and a 51 file status will be issued.</source>
          <target state="translated">이 옵션을 사용하면 잠금이 해제 될 때까지 사전 구성된 시간 동안 프로그램이 대기합니다. 사전 구성된 대기 시간 내에 잠금이 해제되면 읽기에 성공합니다. 잠금이 해제되기 전에 사전 구성된 대기 시간이 만료되면 읽기 시도가 중단되고 51 파일 상태가 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="d63c4744dda8a31bef4aef8c2f8a4a3696dc4329" translate="yes" xml:space="preserve">
          <source>With this option, the program will wait for a preconfigured time for the lock to be released. If the lock is released within the preconfigured wait time, the read will be successful. If the preconfigured wait time expires before the lock is released, the read attempt will be aborted and a 51 file status will be issued.</source>
          <target state="translated">With this option, the program will wait for a preconfigured time for the lock to be released. If the lock is released within the preconfigured wait time, the read will be successful. If the preconfigured wait time expires before the lock is released, the read attempt will be aborted and a 51 file status will be issued.</target>
        </trans-unit>
        <trans-unit id="e98d0ca761cbe05f77d08c91997bea00e85903fd" translate="yes" xml:space="preserve">
          <source>With this routine you may create a new directory &amp;mdash; the name of which is supplied as the &lt;var&gt;dir-path&lt;/var&gt; argument (an alphanumeric literal or identifier).</source>
          <target state="translated">With this routine you may create a new directory &amp;mdash; the name of which is supplied as the &lt;var&gt;dir-path&lt;/var&gt; argument (an alphanumeric literal or identifier).</target>
        </trans-unit>
        <trans-unit id="3c3ae86df0ed352e1be0ed78493310164646938d" translate="yes" xml:space="preserve">
          <source>With this routine you may retrieve the size of the file specified as the &lt;var&gt;file-path&lt;/var&gt; argument (an alphanumeric literal or identifier) and the date/time that file was last modified. File size information may not be available in the particular GnuCOBOL build / Operating System combination you are using and may therefore always be returned as zero.</source>
          <target state="translated">With this routine you may retrieve the size of the file specified as the &lt;var&gt;file-path&lt;/var&gt; argument (an alphanumeric literal or identifier) and the date/time that file was last modified. File size information may not be available in the particular GnuCOBOL build / Operating System combination you are using and may therefore always be returned as zero.</target>
        </trans-unit>
        <trans-unit id="72b6a5947cb9ec043beb1feddb8e0ed9a91a5714" translate="yes" xml:space="preserve">
          <source>With this routine you may retrieve the size of the file specified as the &lt;var&gt;file-path&lt;/var&gt; argument (an alphanumeric literal or identifier) and the date/time that file was last modified. File size information may not be available in the particular GnuCOBOL build / Operating System combination you are using and may therefore always be returned as zero. The information is returned to the &lt;var&gt;file-info&lt;/var&gt; argument, which is defined as the following 16-byte area:</source>
          <target state="translated">With this routine you may retrieve the size of the file specified as the &lt;var&gt;file-path&lt;/var&gt; argument (an alphanumeric literal or identifier) and the date/time that file was last modified. File size information may not be available in the particular GnuCOBOL build / Operating System combination you are using and may therefore always be returned as zero. The information is returned to the &lt;var&gt;file-info&lt;/var&gt; argument, which is defined as the following 16-byte area:</target>
        </trans-unit>
        <trans-unit id="9896244cd1008752a0e7c117022d3e2f86f69b57" translate="yes" xml:space="preserve">
          <source>Within each store, data will be sorted into ascending sequence of department number</source>
          <target state="translated">각 상점 내에서 데이터는 부서 번호의 오름차순으로 정렬됩니다</target>
        </trans-unit>
        <trans-unit id="cb7353567e5fa105e1e904cb9f6dc9fbbd610436" translate="yes" xml:space="preserve">
          <source>Without</source>
          <target state="translated">Without</target>
        </trans-unit>
        <trans-unit id="9f19f591590767d81220e0ebde610d4165cef822" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;JUSTIFIED&lt;/code&gt;</source>
          <target state="translated">Without &lt;code&gt;JUSTIFIED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1219c6b838c4ac50723b943cd9f99727f30854c9" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;LINE&lt;/code&gt; (see &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;) or &lt;code&gt;COLUMN&lt;/code&gt; (see &lt;a href=&quot;#COLUMN&quot;&gt;COLUMN&lt;/a&gt;) clauses, screen section fields will display on the console window beginning at whatever line/column coordinate is stated or implied by the &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; or &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; statement that presents the screen item. After a field is presented to the console window, the next field will be presented immediately following that field.</source>
          <target state="translated">Without &lt;code&gt;LINE&lt;/code&gt; (see &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;) or &lt;code&gt;COLUMN&lt;/code&gt; (see &lt;a href=&quot;#COLUMN&quot;&gt;COLUMN&lt;/a&gt;) clauses, screen section fields will display on the console window beginning at whatever line/column coordinate is stated or implied by the &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; or &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; statement that presents the screen item. After a field is presented to the console window, the next field will be presented immediately following that field.</target>
        </trans-unit>
        <trans-unit id="2b8ae25757eec97d48c815b31dad6e832a80cdd7" translate="yes" xml:space="preserve">
          <source>Without JUSTIFIED</source>
          <target state="translated">근거없이</target>
        </trans-unit>
        <trans-unit id="a5a974f350c89ea3cfabfccf4dce10149288bd59" translate="yes" xml:space="preserve">
          <source>Without the  &lt;code&gt;UNTIL&lt;/code&gt;,  &lt;code&gt;UNTIL EXIT&lt;/code&gt;,  &lt;code&gt;TIMES&lt;/code&gt;,</source>
          <target state="translated">Without the &lt;code&gt;UNTIL&lt;/code&gt; , &lt;code&gt;UNTIL EXIT&lt;/code&gt; , &lt;code&gt;TIMES&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="ab1662b525695dcf16eaed53309bddac5a86a0a2" translate="yes" xml:space="preserve">
          <source>Without the&lt;code&gt;UNTIL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;UNTIL&lt;/code&gt; 없이</target>
        </trans-unit>
        <trans-unit id="318d16788cef4def38bb2bb4185f58e85897fa0b" translate="yes" xml:space="preserve">
          <source>Without this option, an attempt to read a locked record will be immediately aborted and a file status of 51 will be returned.</source>
          <target state="translated">이 옵션이 없으면 잠긴 레코드를 읽으려는 시도가 즉시 중단되고 파일 상태 51이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8cd37d9eaa3e8129d58497de8c9d51d756352ce2" translate="yes" xml:space="preserve">
          <source>Without&lt;code&gt;LINE&lt;/code&gt;(see &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;) or&lt;code&gt;COLUMN&lt;/code&gt;(see &lt;a href=&quot;#COLUMN&quot;&gt;COLUMN&lt;/a&gt;) clauses, screen section fields will display on the console window beginning at whatever line/column coordinate is stated or implied by the&lt;code&gt;ACCEPT screen-data-item&lt;/code&gt;or&lt;code&gt;DISPLAY screen-data-item&lt;/code&gt;statement that presents the screen item. After a field is presented to the console window, the next field will be presented immediately following that field.</source>
          <target state="translated">없이 &lt;code&gt;LINE&lt;/code&gt; (참조 &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt; ) 또는 &lt;code&gt;COLUMN&lt;/code&gt; (참조 &lt;a href=&quot;#COLUMN&quot;&gt;COLUMN&lt;/a&gt; ) 조항 섹션의 필드는 콘솔 창에 표시됩니다 화면이 언급하거나 암시 좌표 어떤 행 / 열에서 시작 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 또는 &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; 문 화면 항목을 표시합니다. 필드가 콘솔 창에 표시되면 다음 필드가 해당 필드 바로 뒤에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9e64323db2e7d0d96c5ed3cc3fd4228d45e35ac9" translate="yes" xml:space="preserve">
          <source>Would &amp;mdash; with &lt;code&gt;DECIMAL POINT IS COMMA&lt;/code&gt; in effect &amp;mdash; actually be interpreted as a subroutine call with 1 argument (the non-integer numeric literal whose value is 1 and 2 tenths). For this reason, it is best to always follow a comma with a space.</source>
          <target state="translated">Would &amp;mdash; with &lt;code&gt;DECIMAL POINT IS COMMA&lt;/code&gt; in effect &amp;mdash; actually be interpreted as a subroutine call with 1 argument (the non-integer numeric literal whose value is 1 and 2 tenths). For this reason, it is best to always follow a comma with a space.</target>
        </trans-unit>
        <trans-unit id="67fbefc0694f5d33e6c127adf3f2289741a4299a" translate="yes" xml:space="preserve">
          <source>Would &amp;mdash; with&lt;code&gt;DECIMAL POINT IS COMMA&lt;/code&gt;in effect &amp;mdash; actually be interpreted as a subroutine call with 1 argument (the non-integer numeric literal whose value is 1 and 2 tenths). For this reason, it is best to always follow a comma with a space.</source>
          <target state="translated">함께 -겠습니까 &lt;code&gt;DECIMAL POINT IS COMMA&lt;/code&gt; 효과는 - 실제로 1 개 인수 서브 루틴 호출로서 해석 (비 - 정수 숫자 리터럴 값이 1 10분의 2이다). 이러한 이유로 항상 공백이있는 쉼표를 따르는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2330eca4f6c21f7646442a0976749e0d1c10f4da" translate="yes" xml:space="preserve">
          <source>Would you prefer a web-based tutorial? Try the University of Limerick (Ireland) - &lt;a href=&quot;http://www.csis.ul.ie/cobol/&quot;&gt;COBOL web site&lt;/a&gt;.</source>
          <target state="translated">Would you prefer a web-based tutorial? Try the University of Limerick (Ireland) - &lt;a href=&quot;http://www.csis.ul.ie/cobol/&quot;&gt;COBOL web site&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="8b8150892159602ee6880cbdb65c5c94fa3b86c2" translate="yes" xml:space="preserve">
          <source>Would you prefer a web-based tutorial? Try the University of Limerick (Ireland) COBOL web site - &amp;lsquo;&lt;code&gt;http://www.csis.ul.ie/cobol/&lt;/code&gt;&amp;rsquo;.</source>
          <target state="translated">웹 기반 자습서를 원하십니까? University of Limerick (아일랜드) COBOL 웹 사이트- ' &lt;code&gt;http://www.csis.ul.ie/cobol/&lt;/code&gt; '를 사용해보십시오 .</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="b4d3ab0d60813524c789808a8629059951cba18f" translate="yes" xml:space="preserve">
          <source>X&quot;91&quot; Built-In Subroutine Syntax</source>
          <target state="translated">X &quot;91&quot;내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="97f87e069e216128f98e9c2af0cce434c82ce350" translate="yes" xml:space="preserve">
          <source>X&quot;91&quot;, X&quot;E4&quot;, X&quot;E5&quot;, X&quot;F4&quot;, X&quot;F5&quot;</source>
          <target state="translated">X &quot;91&quot;, X &quot;E4&quot;, X &quot;E5&quot;, X &quot;F4&quot;, X &quot;F5&quot;</target>
        </trans-unit>
        <trans-unit id="8d8536c7c0c1fd48eeadd62a1f344a382c3c755f" translate="yes" xml:space="preserve">
          <source>X&quot;E4&quot; Built-In Subroutine Syntax</source>
          <target state="translated">X &quot;E4&quot;내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="96be13de8161c84b26c98d09bc8893feddb2cc4b" translate="yes" xml:space="preserve">
          <source>X&quot;E5&quot; Built-In Subroutine Syntax</source>
          <target state="translated">X &quot;E5&quot;내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="19f11b35bad70a5b1ede73eadccb8461da3d60ec" translate="yes" xml:space="preserve">
          <source>X&quot;F4&quot; Built-In Subroutine Syntax</source>
          <target state="translated">X &quot;F4&quot;내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="a6f980fd2288ee90e3ff3cf7a2750572499659dc" translate="yes" xml:space="preserve">
          <source>X&quot;F5&quot; Built-In Subroutine Syntax</source>
          <target state="translated">X &quot;F5&quot;내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="3a4de874772628ee6f8b6a0d6745a75f130782c1" translate="yes" xml:space="preserve">
          <source>X, X&quot;91&quot;, X&quot;E4&quot;, X&quot;E5&quot;, X&quot;F4&quot;, X&quot;F5&quot;</source>
          <target state="translated">X, X&quot;91&quot;, X&quot;E4&quot;, X&quot;E5&quot;, X&quot;F4&quot;, X&quot;F5&quot;</target>
        </trans-unit>
        <trans-unit id="76a4acaf31b815aa2c41cc2a2176b11fa9edf00a" translate="yes" xml:space="preserve">
          <source>XXXXXXXX</source>
          <target state="translated">XXXXXXXX</target>
        </trans-unit>
        <trans-unit id="25e75fdfd45a2fc65a1561c4a55be63b9304cfed" translate="yes" xml:space="preserve">
          <source>XXXXXXXX.CBL</source>
          <target state="translated">XXXXXXXX.CBL</target>
        </trans-unit>
        <trans-unit id="1a01c2f9db4448135c332d5f03b244553defd98d" translate="yes" xml:space="preserve">
          <source>XXXXXXXX.COB</source>
          <target state="translated">XXXXXXXX.COB</target>
        </trans-unit>
        <trans-unit id="26a11bebdc3ad2e98fe156aadc84bf03c8dc8f3c" translate="yes" xml:space="preserve">
          <source>XXXXXXXX.CPY</source>
          <target state="translated">XXXXXXXX.CPY</target>
        </trans-unit>
        <trans-unit id="3cd491714e8ed44d5cb357d61183cedb0a3402e5" translate="yes" xml:space="preserve">
          <source>XXXXXXXX.cbl</source>
          <target state="translated">XXXXXXXX.cbl</target>
        </trans-unit>
        <trans-unit id="9fb508638a72e981e0325bbdcc50cdc1f9f3620f" translate="yes" xml:space="preserve">
          <source>XXXXXXXX.cob</source>
          <target state="translated">XXXXXXXX.cob</target>
        </trans-unit>
        <trans-unit id="a5fa44a32f41bda6ec768284d959a8ea5287ffce" translate="yes" xml:space="preserve">
          <source>XXXXXXXX.cpy</source>
          <target state="translated">XXXXXXXX.cpy</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="6c9fe31cd48ccb48b0fcba068b273acf1fadbf95" translate="yes" xml:space="preserve">
          <source>Y, YEAR-TO-YYYY, YYYYDDD, YYYYMMDD</source>
          <target state="translated">Y, YEAR-TO-YYYY, YYYYDDD, YYYYMMDD</target>
        </trans-unit>
        <trans-unit id="035d6c7fc713b700d2289c38ad8671ce8b5cdfbb" translate="yes" xml:space="preserve">
          <source>YEAR-TO-YYYY Function Syntax</source>
          <target state="translated">YEAR-TO-YYYY 함수 구문</target>
        </trans-unit>
        <trans-unit id="ba22b3f45e963d700438d015dd547e20f4b6b3c3" translate="yes" xml:space="preserve">
          <source>YEAR-TO-YYYY, YYYYDDD, YYYYMMDD</source>
          <target state="translated">YEAR-TO-YYYY, YYYYDDD, YYYYMMDD</target>
        </trans-unit>
        <trans-unit id="d14d07d181bf7b8dada461fc0c61775f143468e4" translate="yes" xml:space="preserve">
          <source>Yellow: COB-COLOR-YELLOW</source>
          <target state="translated">노랑 : COB-COLOR-YELLOW</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="cf2e40d5ca6f9e81feb6add45ec962879362caa3" translate="yes" xml:space="preserve">
          <source>Yet another document which delves deeper in to the compiler that is a</source>
          <target state="translated">Yet another document which delves deeper in to the compiler that is a</target>
        </trans-unit>
        <trans-unit id="973f5d9cfaef037f174bb17145f0580695b187da" translate="yes" xml:space="preserve">
          <source>You are using &lt;code&gt;DECLARATIVES&lt;/code&gt; (see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;)</source>
          <target state="translated">You are using &lt;code&gt;DECLARATIVES&lt;/code&gt; (see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;)</target>
        </trans-unit>
        <trans-unit id="39d08b2d14df1fb662316ed38639d8474bcb272b" translate="yes" xml:space="preserve">
          <source>You are using a &lt;code&gt;GO TO&lt;/code&gt; statement (see &lt;a href=&quot;#GO-TO&quot;&gt;GO TO&lt;/a&gt;)</source>
          <target state="translated">You are using a &lt;code&gt;GO TO&lt;/code&gt; statement (see &lt;a href=&quot;#GO-TO&quot;&gt;GO TO&lt;/a&gt;)</target>
        </trans-unit>
        <trans-unit id="e0cf35f218c0a9e9870676e929c1f556a9893bac" translate="yes" xml:space="preserve">
          <source>You are using a &lt;code&gt;MERGE&lt;/code&gt; statement (see &lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt;) with an &lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt;</source>
          <target state="translated">You are using a &lt;code&gt;MERGE&lt;/code&gt; statement (see &lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt;) with an &lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6a1ef82b4a9f5110a00824b950d37e5cfca47e7e" translate="yes" xml:space="preserve">
          <source>You are using a &lt;code&gt;SORT&lt;/code&gt; statement (see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) with either (or both) an &lt;code&gt;INPUT PROCEDURE&lt;/code&gt; or &lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt;</source>
          <target state="translated">You are using a &lt;code&gt;SORT&lt;/code&gt; statement (see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) with either (or both) an &lt;code&gt;INPUT PROCEDURE&lt;/code&gt; or &lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1df79d37b1951eb3cff30a015d8f21addb564b2" translate="yes" xml:space="preserve">
          <source>You are using a procedural &lt;code&gt;PERFORM&lt;/code&gt; statement (see &lt;a href=&quot;#Procedural-PERFORM&quot;&gt;Procedural PERFORM&lt;/a&gt;)</source>
          <target state="translated">You are using a procedural &lt;code&gt;PERFORM&lt;/code&gt; statement (see &lt;a href=&quot;#Procedural-PERFORM&quot;&gt;Procedural PERFORM&lt;/a&gt;)</target>
        </trans-unit>
        <trans-unit id="8873953cd7a77c3bfb5aeec4e2dbe92cc8b6c02b" translate="yes" xml:space="preserve">
          <source>You are using a procedural&lt;code&gt;PERFORM&lt;/code&gt;statement (see &lt;a href=&quot;#Procedural-PERFORM&quot;&gt;Procedural PERFORM&lt;/a&gt;)</source>
          <target state="translated">당신은 절차 적 사용 &lt;code&gt;PERFORM&lt;/code&gt; 문을 (참조 &lt;a href=&quot;#Procedural-PERFORM&quot;&gt;절차 수행&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="6f37cb61f92c3ee61980cefac590243753a942fa" translate="yes" xml:space="preserve">
          <source>You are using a&lt;code&gt;GO TO&lt;/code&gt;statement (see &lt;a href=&quot;#GO-TO&quot;&gt;GO TO&lt;/a&gt;)</source>
          <target state="translated">당신이 사용하는 &lt;code&gt;GO TO&lt;/code&gt; 의 문을합니다 ( &lt;a href=&quot;#GO-TO&quot;&gt;이동을&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="415be0c2a589d6613ea0e96ff0fa4a09a854f06e" translate="yes" xml:space="preserve">
          <source>You are using a&lt;code&gt;MERGE&lt;/code&gt;statement (see &lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt;) with an&lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt;</source>
          <target state="translated">당신은 사용하는 &lt;code&gt;MERGE&lt;/code&gt; 의 문 (참조 &lt;a href=&quot;#MERGE&quot;&gt;MERGE를&lt;/a&gt; 로) &lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4b4d6fcd956ffc249b5fe966f8cd9c513397f34" translate="yes" xml:space="preserve">
          <source>You are using a&lt;code&gt;SORT&lt;/code&gt;statement (see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) with either (or both) an&lt;code&gt;INPUT PROCEDURE&lt;/code&gt;or&lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt;</source>
          <target state="translated">당신은 사용하는 &lt;code&gt;SORT&lt;/code&gt; (참조 문을 &lt;a href=&quot;#SORT&quot;&gt;SORT를&lt;/a&gt; 하나 (또는 둘 다)와 함께) &lt;code&gt;INPUT PROCEDURE&lt;/code&gt; 또는 &lt;code&gt;OUTPUT PROCEDURE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db5d45ed5a1ed970e62b7a977159ce8c770b7a7e" translate="yes" xml:space="preserve">
          <source>You are using the &lt;code&gt;ALTER&lt;/code&gt; statement (see &lt;a href=&quot;#ALTER&quot;&gt;ALTER&lt;/a&gt;) (the use of which should be avoided at all costs)</source>
          <target state="translated">You are using the &lt;code&gt;ALTER&lt;/code&gt; statement (see &lt;a href=&quot;#ALTER&quot;&gt;ALTER&lt;/a&gt;) (the use of which should be avoided at all costs)</target>
        </trans-unit>
        <trans-unit id="441752d0d9f2139c764487ac2e305c7a3ab08b46" translate="yes" xml:space="preserve">
          <source>You are using the&lt;code&gt;ALTER&lt;/code&gt;statement (see &lt;a href=&quot;#ALTER&quot;&gt;ALTER&lt;/a&gt;) (the use of which should be avoided at all costs)</source>
          <target state="translated">당신이 사용하는 &lt;code&gt;ALTER&lt;/code&gt; 의 (참조 문을 &lt;a href=&quot;#ALTER&quot;&gt;ALTER를&lt;/a&gt; (사용이있는 희생을 치르더라도 피해야한다))</target>
        </trans-unit>
        <trans-unit id="aac698e9bc381153d9f728b218ad195b63c4d794" translate="yes" xml:space="preserve">
          <source>You are using&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;)</source>
          <target state="translated">당신이 사용하는 &lt;code&gt;DECLARATIVES&lt;/code&gt; 를 (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES를&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="37683c4bf268a521f1e0ce750e80912f0e6b5185" translate="yes" xml:space="preserve">
          <source>You can be the judge. First, the Java version:</source>
          <target state="translated">당신은 판사가 될 수 있습니다. 먼저, Java 버전 :</target>
        </trans-unit>
        <trans-unit id="1f7d5d96863dbc8809bed0960c251cfde3ab6242" translate="yes" xml:space="preserve">
          <source>You can force the GnuCOBOL runtime system to pre-load all dynamically-loaded modules that could ever be called by the program, at the time the program starts executing. This is accomplished through the use of the</source>
          <target state="translated">프로그램 실행을 시작할 때 프로그램에서 호출 할 수있는 동적으로로드 된 모든 모듈을 GnuCOBOL 런타임 시스템에 미리로드하도록 할 수 있습니다. 이것은 사용하여 달성됩니다</target>
        </trans-unit>
        <trans-unit id="4fe9bfbec876b9e6c046e1589cbca48f419e6ccd" translate="yes" xml:space="preserve">
          <source>You can force the GnuCOBOL runtime system to pre-load all dynamically-loaded modules that could ever be called by the program, at the time the program starts executing. This is accomplished through the use of the   &lt;code&gt;COB_PRE_LOAD&lt;/code&gt; run-time environment variable (see &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;Run Time Environment Variables&lt;/a&gt;). If used, this will only pre-load those modules invoked via &lt;code&gt;CALL &lt;var&gt;literal-1&lt;/var&gt;&lt;/code&gt;, as the runtime contents of &lt;var&gt;identifier-1&lt;/var&gt; cannot be predicted.</source>
          <target state="translated">You can force the GnuCOBOL runtime system to pre-load all dynamically-loaded modules that could ever be called by the program, at the time the program starts executing. This is accomplished through the use of the &lt;code&gt;COB_PRE_LOAD&lt;/code&gt; run-time environment variable (see &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;Run Time Environment Variables&lt;/a&gt;). If used, this will only pre-load those modules invoked via &lt;code&gt;CALL &lt;var&gt;literal-1&lt;/var&gt;&lt;/code&gt; , as the runtime contents of &lt;var&gt;identifier-1&lt;/var&gt; cannot be predicted.</target>
        </trans-unit>
        <trans-unit id="270d35ba6741a740863603676c8152a487ab7cef" translate="yes" xml:space="preserve">
          <source>You can trick RWCS into using the &lt;code&gt;PAGE LIMIT&lt;/code&gt; values as logical specifications rather than physical ones quite easily &amp;mdash; simply include an &lt;small&gt;ASCII&lt;/small&gt; form-feed (&lt;code&gt;X'0C'&lt;/code&gt;) character into your page heading design! Here&amp;rsquo;s how the sample program shown earlier could be easily modified:</source>
          <target state="translated">You can trick RWCS into using the &lt;code&gt;PAGE LIMIT&lt;/code&gt; values as logical specifications rather than physical ones quite easily &amp;mdash; simply include an &lt;small&gt;ASCII&lt;/small&gt; form-feed ( &lt;code&gt;X'0C'&lt;/code&gt; ) character into your page heading design! Here&amp;rsquo;s how the sample program shown earlier could be easily modified:</target>
        </trans-unit>
        <trans-unit id="fe1621c0d0817ae920144fa8c01766737cc2e5c6" translate="yes" xml:space="preserve">
          <source>You can trick RWCS into using the PAGE LIMIT values as logical specifications rather than physical ones quite easily &amp;mdash; simply include an ASCII form-feed (X&amp;rsquo;0C&amp;rsquo;) character into your page heading design! Here&amp;rsquo;s how the sample program shown earlier could be easily modified:</source>
          <target state="translated">실제 페이지가 아닌 논리적 사양으로 PAGE LIMIT 값을 사용하여 RWCS를 속일 수 있습니다. 페이지 머리글 디자인에 ASCII form-feed (X'0C ') 문자를 포함시키기 만하면됩니다! 이전에 표시된 샘플 프로그램을 쉽게 수정하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="beded125cc663a02e20cb3ad8ab8f7de205db5ba" translate="yes" xml:space="preserve">
          <source>You can use this function to convert the five-digit Julian date specified as &lt;var&gt;yyddd&lt;/var&gt; (a numeric integer data item or literal) to a seven-digit numeric Julian format (yyyyddd).</source>
          <target state="translated">You can use this function to convert the five-digit Julian date specified as &lt;var&gt;yyddd&lt;/var&gt; (a numeric integer data item or literal) to a seven-digit numeric Julian format (yyyyddd).</target>
        </trans-unit>
        <trans-unit id="35034459984131013e168b1a4809cc5c41a89bd7" translate="yes" xml:space="preserve">
          <source>You can use this function to convert the six-digit Gregorian date specified as &lt;var&gt;yymmdd&lt;/var&gt; (a numeric integer data item or literal) to an eight-digit format (</source>
          <target state="translated">You can use this function to convert the six-digit Gregorian date specified as &lt;var&gt;yymmdd&lt;/var&gt; (a numeric integer data item or literal) to an eight-digit format (</target>
        </trans-unit>
        <trans-unit id="d332c1100eaac1c578cd4f2b04aa5eec038af7a8" translate="yes" xml:space="preserve">
          <source>You can used extended attributes, useful for setting timeouts or positioning.</source>
          <target state="translated">시간 초과 또는 위치 설정에 유용한 확장 된 속성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b41372785ce5a41c998052796febce4e38e45c1f" translate="yes" xml:space="preserve">
          <source>You cannot use both &lt;code&gt;NEXT SENTENCE&lt;/code&gt; and the &lt;code&gt;END-IF&lt;/code&gt; scope terminator in the same &lt;code&gt;IF&lt;/code&gt; statement.</source>
          <target state="translated">You cannot use both &lt;code&gt;NEXT SENTENCE&lt;/code&gt; and the &lt;code&gt;END-IF&lt;/code&gt; scope terminator in the same &lt;code&gt;IF&lt;/code&gt; statement.</target>
        </trans-unit>
        <trans-unit id="77d05b291c9496cc2a1f64183cd8f36a18749716" translate="yes" xml:space="preserve">
          <source>You cannot use both&lt;code&gt;NEXT SENTENCE&lt;/code&gt;and the&lt;code&gt;END-IF&lt;/code&gt;scope terminator in the same&lt;code&gt;IF&lt;/code&gt;statement.</source>
          <target state="translated">동일한 &lt;code&gt;IF&lt;/code&gt; 문 에서 &lt;code&gt;NEXT SENTENCE&lt;/code&gt; 와 &lt;code&gt;END-IF&lt;/code&gt; 범위 종결 자를 모두 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2a6c1ef407f93c5957e8aec5cf6f6076ab3e6fad" translate="yes" xml:space="preserve">
          <source>You may adjust the value(s) of any items referenced in &lt;code&gt;SUM&lt;/code&gt; (see &lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt;) or &lt;code&gt;SOURCE&lt;/code&gt; (see &lt;a href=&quot;#SOURCE&quot;&gt;SOURCE&lt;/a&gt;) clauses in the report group.</source>
          <target state="translated">You may adjust the value(s) of any items referenced in &lt;code&gt;SUM&lt;/code&gt; (see &lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt;) or &lt;code&gt;SOURCE&lt;/code&gt; (see &lt;a href=&quot;#SOURCE&quot;&gt;SOURCE&lt;/a&gt;) clauses in the report group.</target>
        </trans-unit>
        <trans-unit id="2163b4265cac1689d879f5158a2a727ab8743995" translate="yes" xml:space="preserve">
          <source>You may adjust the value(s) of any items referenced in&lt;code&gt;SUM&lt;/code&gt;(see &lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt;) or&lt;code&gt;SOURCE&lt;/code&gt;(see &lt;a href=&quot;#SOURCE&quot;&gt;SOURCE&lt;/a&gt;) clauses in the report group.</source>
          <target state="translated">보고서 그룹 에서 &lt;code&gt;SUM&lt;/code&gt; ( &lt;a href=&quot;#SUM&quot;&gt;SUM&lt;/a&gt; 참조 ) 또는 &lt;code&gt;SOURCE&lt;/code&gt; ( &lt;a href=&quot;#SOURCE&quot;&gt;SOURCE&lt;/a&gt; 참조 ) 절에서 참조 된 항목의 값을 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88c8dd83c236bac1752ef5719f31b5392c08bc47" translate="yes" xml:space="preserve">
          <source>You may also use the &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; CDF directive to perform this function.</source>
          <target state="translated">You may also use the &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; CDF directive to perform this function.</target>
        </trans-unit>
        <trans-unit id="c81bd8b7d8060cbc5296d5c531b7829e7783dc1d" translate="yes" xml:space="preserve">
          <source>You may also use the&lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt;CDF directive to perform this function.</source>
          <target state="translated">&lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; CDF 지시문을 사용하여이 기능을 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="054cafde64dedbde58f8596ae459b0722d673330" translate="yes" xml:space="preserve">
          <source>You may compile GnuCOBOL subprograms into assembler source code which can then be assembled and linked with a main program when that main program is compiled. To create such an assembler source file, compile the subprogram(s) as follows:</source>
          <target state="translated">GnuCOBOL 서브 프로그램을 어셈블러 소스 코드로 컴파일 한 다음 해당 메인 프로그램을 컴파일 할 때 메인 프로그램과 어셈블하고 링크 할 수 있습니다. 이러한 어셈블러 소스 파일을 작성하려면 다음과 같이 서브 프로그램을 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="817f06c45fce9e88b56afdc8b5da827b89e74702" translate="yes" xml:space="preserve">
          <source>You may execute the &lt;code&gt;SUPPRESS&lt;/code&gt; (see &lt;a href=&quot;#SUPPRESS&quot;&gt;SUPPRESS&lt;/a&gt;) statement to squelch the presentation of the specified report group altogether. Note that you will be suppressing this one specific instance of that group&amp;rsquo;s presentation and not all of them.</source>
          <target state="translated">You may execute the &lt;code&gt;SUPPRESS&lt;/code&gt; (see &lt;a href=&quot;#SUPPRESS&quot;&gt;SUPPRESS&lt;/a&gt;) statement to squelch the presentation of the specified report group altogether. Note that you will be suppressing this one specific instance of that group&amp;rsquo;s presentation and not all of them.</target>
        </trans-unit>
        <trans-unit id="293e8ddddd1f1c233342acd299061a2bfd3ebdc9" translate="yes" xml:space="preserve">
          <source>You may execute the&lt;code&gt;SUPPRESS&lt;/code&gt;(see &lt;a href=&quot;#SUPPRESS&quot;&gt;SUPPRESS&lt;/a&gt;) statement to squelch the presentation of the specified report group altogether. Note that you will be suppressing this one specific instance of that group&amp;rsquo;s presentation and not all of them.</source>
          <target state="translated">당신은 실행할 수 &lt;code&gt;SUPPRESS&lt;/code&gt; (참조 &lt;a href=&quot;#SUPPRESS&quot;&gt;SUPPRESS를&lt;/a&gt; 모두 지정된 보고서 그룹의 프리젠 테이션을 퀠치하기 위해) 문을. 해당 그룹 프리젠 테이션의 특정 인스턴스 하나를 모두 억제하지는 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="cf35460f181c19d36a0dc1c7b0ad84cfd0d3c69d" translate="yes" xml:space="preserve">
          <source>You may include an optional &amp;lt;</source>
          <target state="translated">선택 사항 인 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="312f5689c142ce880f3ac0637b0a2691c95cf9a5" translate="yes" xml:space="preserve">
          <source>You may include an optional &lt;var&gt;locale&lt;/var&gt; name (a group item or &lt;code&gt;PIC X&lt;/code&gt; identifier) you&amp;rsquo;d like to use for time formatting. If used, this second argument</source>
          <target state="translated">You may include an optional &lt;var&gt;locale&lt;/var&gt; name (a group item or &lt;code&gt;PIC X&lt;/code&gt; identifier) you&amp;rsquo;d like to use for time formatting. If used, this second argument</target>
        </trans-unit>
        <trans-unit id="1e65202f55f04b3e7b3e9d4991c283932e0f6d32" translate="yes" xml:space="preserve">
          <source>You may include an optional second argument to specify the &amp;lt;</source>
          <target state="translated">선택적인 두 번째 인수를 포함하여 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="20c5e7e4362ddb9c109356ce7bc115f4a18837b2" translate="yes" xml:space="preserve">
          <source>You may include an optional second argument to specify the &lt;var&gt;locale&lt;/var&gt; name (group item or &lt;code&gt;PIC X&lt;/code&gt; identifier) you&amp;rsquo;d like to use for date formatting. If used, this second argument</source>
          <target state="translated">You may include an optional second argument to specify the &lt;var&gt;locale&lt;/var&gt; name (group item or &lt;code&gt;PIC X&lt;/code&gt; identifier) you&amp;rsquo;d like to use for date formatting. If used, this second argument</target>
        </trans-unit>
        <trans-unit id="709533b89822f6454b505f7101d5fda082a9df96" translate="yes" xml:space="preserve">
          <source>You may not use an &lt;code&gt;ENTRY&lt;/code&gt; statement in a nested subprogram, nor may you use it in any form of user-defined function.</source>
          <target state="translated">You may not use an &lt;code&gt;ENTRY&lt;/code&gt; statement in a nested subprogram, nor may you use it in any form of user-defined function.</target>
        </trans-unit>
        <trans-unit id="98c555bf0695949427e1a3b270cc9a04b52aee11" translate="yes" xml:space="preserve">
          <source>You may not use an&lt;code&gt;ENTRY&lt;/code&gt;statement in a nested subprogram, nor may you use it in any form of user-defined function.</source>
          <target state="translated">당신은 사용할 수 없습니다 &lt;code&gt;ENTRY&lt;/code&gt; 의 중첩 된 서브 프로그램에서 문을 없으며 사용자 정의 함수의 형태로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2f727663ad318f0efbd31111309b075b1a251eb" translate="yes" xml:space="preserve">
          <source>You may only read the existing contents of the file &amp;mdash; only the &lt;code&gt;CLOSE&lt;/code&gt;, &lt;code&gt;READ&lt;/code&gt;, &lt;code&gt;START&lt;/code&gt; and &lt;code&gt;UNLOCK&lt;/code&gt; statements will be allowed. This enforcement takes place at execution time, not compilation time.</source>
          <target state="translated">You may only read the existing contents of the file &amp;mdash; only the &lt;code&gt;CLOSE&lt;/code&gt; , &lt;code&gt;READ&lt;/code&gt; , &lt;code&gt;START&lt;/code&gt; and &lt;code&gt;UNLOCK&lt;/code&gt; statements will be allowed. This enforcement takes place at execution time, not compilation time.</target>
        </trans-unit>
        <trans-unit id="63c66023128251792acf3aef777c2a0929748699" translate="yes" xml:space="preserve">
          <source>You may only read the existing contents of the file &amp;mdash; only the&lt;code&gt;CLOSE&lt;/code&gt;&lt;code&gt;READ&lt;/code&gt;&lt;code&gt;START&lt;/code&gt;and&lt;code&gt;UNLOCK&lt;/code&gt;statements will be allowed. This enforcement takes place at execution time, not compilation time.</source>
          <target state="translated">파일의 기존 내용 만 읽을 수 있습니다. &lt;code&gt;CLOSE&lt;/code&gt; &lt;code&gt;READ&lt;/code&gt; &lt;code&gt;START&lt;/code&gt; 및 &lt;code&gt;UNLOCK&lt;/code&gt; 문만 허용됩니다. 이 시행은 컴파일 시간이 아닌 실행 시간에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f23510d751cf0c2604e8c5707b0e37b199aa868e" translate="yes" xml:space="preserve">
          <source>You may only write new content (which will be appended after the previously existing file contents) to the file &amp;mdash; only the &lt;code&gt;CLOSE&lt;/code&gt;, &lt;code&gt;UNLOCK&lt;/code&gt; and &lt;code&gt;WRITE&lt;/code&gt; statements will be allowed. This enforcement takes place at execution time, not compilation time. You cannot extend an empty file; this will not generate a runtime error, but no output will appear in the file.</source>
          <target state="translated">You may only write new content (which will be appended after the previously existing file contents) to the file &amp;mdash; only the &lt;code&gt;CLOSE&lt;/code&gt; , &lt;code&gt;UNLOCK&lt;/code&gt; and &lt;code&gt;WRITE&lt;/code&gt; statements will be allowed. This enforcement takes place at execution time, not compilation time. You cannot extend an empty file; this will not generate a runtime error, but no output will appear in the file.</target>
        </trans-unit>
        <trans-unit id="0fceeeee26f5eba247280b6d471f003bdfb30269" translate="yes" xml:space="preserve">
          <source>You may only write new content (which will be appended after the previously existing file contents) to the file &amp;mdash; only the&lt;code&gt;CLOSE&lt;/code&gt;&lt;code&gt;UNLOCK&lt;/code&gt;and&lt;code&gt;WRITE&lt;/code&gt;statements will be allowed. This enforcement takes place at execution time, not compilation time. You cannot extend an empty file; this will not generate a runtime error, but no output will appear in the file.</source>
          <target state="translated">파일에 새 내용 (이전에 존재하는 파일 내용 뒤에 추가됨) 만 쓸 수 있습니다. &lt;code&gt;CLOSE&lt;/code&gt; &lt;code&gt;UNLOCK&lt;/code&gt; 및 &lt;code&gt;WRITE&lt;/code&gt; 문만 허용됩니다. 이 시행은 컴파일 시간이 아닌 실행 시간에 발생합니다. 빈 파일은 확장 할 수 없습니다. 런타임 오류는 발생하지 않지만 파일에 출력이 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1130b4f4f0f9c7bb725f2d1c3ca835214dc78e02" translate="yes" xml:space="preserve">
          <source>You may only write new content (which will completely replace any previous file contents) to the file &amp;mdash; only the &lt;code&gt;CLOSE&lt;/code&gt;, &lt;code&gt;UNLOCK&lt;/code&gt; and &lt;code&gt;WRITE&lt;/code&gt; statements will be allowed. This enforcement takes place at execution time, not compilation time.</source>
          <target state="translated">You may only write new content (which will completely replace any previous file contents) to the file &amp;mdash; only the &lt;code&gt;CLOSE&lt;/code&gt; , &lt;code&gt;UNLOCK&lt;/code&gt; and &lt;code&gt;WRITE&lt;/code&gt; statements will be allowed. This enforcement takes place at execution time, not compilation time.</target>
        </trans-unit>
        <trans-unit id="7194a843c087582371e18303f104720cc644680d" translate="yes" xml:space="preserve">
          <source>You may only write new content (which will completely replace any previous file contents) to the file &amp;mdash; only the&lt;code&gt;CLOSE&lt;/code&gt;&lt;code&gt;UNLOCK&lt;/code&gt;and&lt;code&gt;WRITE&lt;/code&gt;statements will be allowed. This enforcement takes place at execution time, not compilation time.</source>
          <target state="translated">파일에 새 내용 (이전 파일 내용을 완전히 대체 함) 만 쓸 수 있습니다. &lt;code&gt;CLOSE&lt;/code&gt; &lt;code&gt;UNLOCK&lt;/code&gt; 및 &lt;code&gt;WRITE&lt;/code&gt; 문만 허용됩니다. 이 시행은 컴파일 시간이 아닌 실행 시간에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e3756c1b6ac169f0b0368c02dd5c3224b2fbaf2d" translate="yes" xml:space="preserve">
          <source>You may perform any operation you wish against the file &amp;mdash; all file I/O statements will be allowed.</source>
          <target state="translated">파일에 대해 원하는 작업을 수행 할 수 있습니다. 모든 파일 I / O 문이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb9f5e823cac5b8f7a30e832feec945b23d9d094" translate="yes" xml:space="preserve">
          <source>You may specify any of the figurative constants &lt;code&gt;SPACE&lt;/code&gt;, &lt;code&gt;SPACES&lt;/code&gt;, &lt;code&gt;ZERO&lt;/code&gt;, &lt;code&gt;ZEROS&lt;/code&gt;, &lt;code&gt;ZEROES&lt;/code&gt;, &lt;code&gt;QUOTE&lt;/code&gt;, &lt;code&gt;QUOTES&lt;/code&gt;, &lt;code&gt;HIGH-VALUE&lt;/code&gt;, &lt;code&gt;HIGH-VALUES&lt;/code&gt;, &lt;code&gt;LOW-VALUE&lt;/code&gt; or &lt;code&gt;LOW-VALUES&lt;/code&gt; for any of the &lt;var&gt;literal-1&lt;/var&gt;, &lt;var&gt;literal-2&lt;/var&gt; or &lt;var&gt;literal-3&lt;/var&gt; specifications.</source>
          <target state="translated">You may specify any of the figurative constants &lt;code&gt;SPACE&lt;/code&gt; , &lt;code&gt;SPACES&lt;/code&gt; , &lt;code&gt;ZERO&lt;/code&gt; , &lt;code&gt;ZEROS&lt;/code&gt; , &lt;code&gt;ZEROES&lt;/code&gt; , &lt;code&gt;QUOTE&lt;/code&gt; , &lt;code&gt;QUOTES&lt;/code&gt; , &lt;code&gt;HIGH-VALUE&lt;/code&gt; , &lt;code&gt;HIGH-VALUES&lt;/code&gt; , &lt;code&gt;LOW-VALUE&lt;/code&gt; or &lt;code&gt;LOW-VALUES&lt;/code&gt; for any of the &lt;var&gt;literal-1&lt;/var&gt; , &lt;var&gt;literal-2&lt;/var&gt; or &lt;var&gt;literal-3&lt;/var&gt; specifications.</target>
        </trans-unit>
        <trans-unit id="2a5faeff37b19213ac8a6045d710277e7246741c" translate="yes" xml:space="preserve">
          <source>You may specify any of the figurative constants&lt;code&gt;SPACE&lt;/code&gt;&lt;code&gt;SPACES&lt;/code&gt;&lt;code&gt;ZERO&lt;/code&gt;&lt;code&gt;ZEROS&lt;/code&gt;&lt;code&gt;ZEROES&lt;/code&gt;&lt;code&gt;QUOTE&lt;/code&gt;&lt;code&gt;QUOTES&lt;/code&gt;&lt;code&gt;HIGH-VALUE&lt;/code&gt;&lt;code&gt;HIGH-VALUES&lt;/code&gt;&lt;code&gt;LOW-VALUE&lt;/code&gt;or&lt;code&gt;LOW-VALUES&lt;/code&gt;for any of the &amp;lt;</source>
          <target state="translated">당신은 상징적 인 상수의 지정할 수 있습니다 &lt;code&gt;SPACE&lt;/code&gt; &lt;code&gt;SPACES&lt;/code&gt; &lt;code&gt;ZERO&lt;/code&gt; &lt;code&gt;ZEROS&lt;/code&gt; &lt;code&gt;ZEROES&lt;/code&gt; &lt;code&gt;QUOTE&lt;/code&gt; &lt;code&gt;QUOTES&lt;/code&gt; &lt;code&gt;HIGH-VALUE&lt;/code&gt; &lt;code&gt;HIGH-VALUES&lt;/code&gt; &lt;code&gt;LOW-VALUE&lt;/code&gt; 또는 &lt;code&gt;LOW-VALUES&lt;/code&gt; 의 어떤을 위해 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="57925f010215b0fe69908b4a664937b25fd094f8" translate="yes" xml:space="preserve">
          <source>You may switch between &lt;code&gt;FIXED&lt;/code&gt; and &lt;code&gt;FREE&lt;/code&gt; mode as desired.</source>
          <target state="translated">You may switch between &lt;code&gt;FIXED&lt;/code&gt; and &lt;code&gt;FREE&lt;/code&gt; mode as desired.</target>
        </trans-unit>
        <trans-unit id="8d0528105c78c72bb842f937fe08a1a8a0fb3af6" translate="yes" xml:space="preserve">
          <source>You may switch between&lt;code&gt;FIXED&lt;/code&gt;and&lt;code&gt;FREE&lt;/code&gt;mode as desired.</source>
          <target state="translated">원하는대로 &lt;code&gt;FIXED&lt;/code&gt; 와 &lt;code&gt;FREE&lt;/code&gt; 모드를 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3a47e3553171f292a018ff09ce9d1448d2b29d8" translate="yes" xml:space="preserve">
          <source>You may use the &lt;code&gt;&amp;gt;&amp;gt;FORMAT IS FIXED&lt;/code&gt; and &lt;code&gt;FORMAT IS FREE&lt;/code&gt; clauses of the &lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt; CDF directive (see &lt;a href=&quot;#g_t_003e_003eDEFINE&quot;&gt;&amp;gt;&amp;gt;DEFINE&lt;/a&gt;) within your source code to switch to Fixed or Free Format Mode, respectively.</source>
          <target state="translated">You may use the &lt;code&gt;&amp;gt;&amp;gt;FORMAT IS FIXED&lt;/code&gt; and &lt;code&gt;FORMAT IS FREE&lt;/code&gt; clauses of the &lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt; CDF directive (see &lt;a href=&quot;#g_t_003e_003eDEFINE&quot;&gt;&amp;gt;&amp;gt;DEFINE&lt;/a&gt;) within your source code to switch to Fixed or Free Format Mode, respectively.</target>
        </trans-unit>
        <trans-unit id="8ddc822eb7907e23b6abf5d322f2f8f5d5cfffb7" translate="yes" xml:space="preserve">
          <source>You may use the &lt;code&gt;&amp;gt;&amp;gt;SOURCE&lt;/code&gt; CDF directive (see &lt;a href=&quot;#g_t_003e_003eSOURCE&quot;&gt;&amp;gt;&amp;gt;SOURCE&lt;/a&gt;) to switch to Free Format Mode (&lt;code&gt;&amp;gt;&amp;gt;SOURCE FORMAT IS FREE&lt;/code&gt;) or Fixed Format Mode (&lt;code&gt;&amp;gt;&amp;gt;SOURCE FORMAT IS FIXED&lt;/code&gt;.</source>
          <target state="translated">You may use the &lt;code&gt;&amp;gt;&amp;gt;SOURCE&lt;/code&gt; CDF directive (see &lt;a href=&quot;#g_t_003e_003eSOURCE&quot;&gt;&amp;gt;&amp;gt;SOURCE&lt;/a&gt;) to switch to Free Format Mode ( &lt;code&gt;&amp;gt;&amp;gt;SOURCE FORMAT IS FREE&lt;/code&gt; ) or Fixed Format Mode ( &lt;code&gt;&amp;gt;&amp;gt;SOURCE FORMAT IS FIXED&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="444826c1a534e6e55d300f2ff6284c77e41a588f" translate="yes" xml:space="preserve">
          <source>You may use the &lt;code&gt;SOURCEFORMAT AS FIXED&lt;/code&gt; and &lt;code&gt;SOURCEFORMAT AS FREE&lt;/code&gt; clauses of the &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; CDF directive (see &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt;SET&lt;/a&gt;) within your source code to switch to Fixed or Free Format Mode, respectively.</source>
          <target state="translated">You may use the &lt;code&gt;SOURCEFORMAT AS FIXED&lt;/code&gt; and &lt;code&gt;SOURCEFORMAT AS FREE&lt;/code&gt; clauses of the &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; CDF directive (see &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt;SET&lt;/a&gt;) within your source code to switch to Fixed or Free Format Mode, respectively.</target>
        </trans-unit>
        <trans-unit id="3c57bbd7fad45df71287483ca0cb429f32233abf" translate="yes" xml:space="preserve">
          <source>You may use the&lt;code&gt;&amp;gt;&amp;gt;FORMAT IS FIXED&lt;/code&gt;and&lt;code&gt;FORMAT IS FREE&lt;/code&gt;clauses of the&lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt;CDF directive (see &lt;a href=&quot;#g_t_003e_003eDEFINE&quot;&gt;&amp;gt;&amp;gt;DEFINE&lt;/a&gt;) within your source code to switch to Fixed or Free Format Mode, respectively.</source>
          <target state="translated">소스 코드 내 에서 &lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt; CDF 지시문 의 &lt;code&gt;&amp;gt;&amp;gt;FORMAT IS FIXED&lt;/code&gt; 및 &lt;code&gt;FORMAT IS FREE&lt;/code&gt; 절 ( &lt;a href=&quot;#g_t_003e_003eDEFINE&quot;&gt;&amp;gt;&amp;gt; DEFINE&lt;/a&gt; 참조 )을 사용하여 각각 고정 또는 자유 형식 모드로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a65c2afd5c4a99f2eba4f6b86c709ea517566a11" translate="yes" xml:space="preserve">
          <source>You may use the&lt;code&gt;&amp;gt;&amp;gt;SOURCE&lt;/code&gt;CDF directive (see &lt;a href=&quot;#g_t_003e_003eSOURCE&quot;&gt;&amp;gt;&amp;gt;SOURCE&lt;/a&gt;) to switch to Free Format Mode &lt;code&gt;&amp;gt;&amp;gt;SOURCE FORMAT IS FREE&lt;/code&gt; or Fixed Format Mode &lt;code&gt;&amp;gt;&amp;gt;SOURCE FORMAT IS FIXED&lt;/code&gt;</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;code&gt;&amp;gt;&amp;gt;SOURCE&lt;/code&gt; (참조 CDF 지시어를 &lt;a href=&quot;#g_t_003e_003eSOURCE&quot;&gt;SOURCE &amp;gt;&amp;gt;&lt;/a&gt; 자유 형식 모드로 전환) &lt;code&gt;&amp;gt;&amp;gt;SOURCE FORMAT IS FREE&lt;/code&gt; 또는 고정 형식 모드 &lt;code&gt;&amp;gt;&amp;gt;SOURCE FORMAT IS FIXED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="23232cdf18e0d19a45c1b2ca8eac3e2ecb81eddb" translate="yes" xml:space="preserve">
          <source>You may use the&lt;code&gt;SOURCEFORMAT AS FIXED&lt;/code&gt;and&lt;code&gt;SOURCEFORMAT AS FREE&lt;/code&gt;clauses of the&lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt;CDF directive (see &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt;SET&lt;/a&gt;) within your source code to switch to Fixed or Free Format Mode, respectively.</source>
          <target state="translated">소스 코드 내 에서 &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; CDF 지시문 ( &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt; SET&lt;/a&gt; 참조 ) 의 &lt;code&gt;SOURCEFORMAT AS FIXED&lt;/code&gt; 및 &lt;code&gt;SOURCEFORMAT AS FREE&lt;/code&gt; 절을 사용하여 각각 고정 또는 자유 형식 모드로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b27e93f3af4c40d7b3d1f2bc8eb658b881fd7ba" translate="yes" xml:space="preserve">
          <source>You may use this subroutine to rename a file.</source>
          <target state="translated">You may use this subroutine to rename a file.</target>
        </trans-unit>
        <trans-unit id="2779cd2dd75ef37d890afce8b59bff67489cc769" translate="yes" xml:space="preserve">
          <source>You must use the level number 66 for data description entries that contain the &lt;code&gt;RENAMES&lt;/code&gt; clause.</source>
          <target state="translated">You must use the level number 66 for data description entries that contain the &lt;code&gt;RENAMES&lt;/code&gt; clause.</target>
        </trans-unit>
        <trans-unit id="630674bf3cd87d358512935149be2e55f84e3ea8" translate="yes" xml:space="preserve">
          <source>You must use the level number 66 for data description entries that contain the&lt;code&gt;RENAMES&lt;/code&gt;clause.</source>
          <target state="translated">&lt;code&gt;RENAMES&lt;/code&gt; 절이 포함 된 데이터 설명 항목에는 레벨 번호 66을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="38cadaafad2f56f667bee6bce530f7083abf14b5" translate="yes" xml:space="preserve">
          <source>You specify colors by number (0-7), or by using the constant names provided in the</source>
          <target state="translated">You specify colors by number (0-7), or by using the constant names provided in the</target>
        </trans-unit>
        <trans-unit id="be9486f9c225e2cf954dbe853b25986a80f7ef23" translate="yes" xml:space="preserve">
          <source>You specify colors by number (0-7), or by using the constant names provided in the &quot;screenio.cpy&quot; copybook (which is provided with all GnuCOBOL source distributions).</source>
          <target state="translated">숫자 (0-7) 또는 &quot;screenio.cpy&quot;카피 북 (모든 GnuCOBOL 소스 배포와 함께 제공됨)에 제공된 상수 이름을 사용하여 색상을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b4527f9a0d70d5e57ae677d77f4d8889745ffdc5" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll find COBOL an easy language to learn and a FAR EASIER language to master than many of the &quot;modern&quot; languages.</source>
          <target state="translated">COBOL은 배우기 쉬운 언어이며 많은 &quot;현대&quot;언어보다 마스터하기 쉬운 FAR EASIER 언어입니다.</target>
        </trans-unit>
        <trans-unit id="4f933339ddf3a8941cfb7fa6a1beae80c3ace09b" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll find COBOL an easy language to learn and a FAR EASIER language to master than many of the &amp;ldquo;modern&amp;rdquo; languages.</source>
          <target state="translated">You&amp;rsquo;ll find COBOL an easy language to learn and a FAR EASIER language to master than many of the &amp;ldquo;modern&amp;rdquo; languages.</target>
        </trans-unit>
        <trans-unit id="015e7877b250464577511fa0a6efa973747a2e0a" translate="yes" xml:space="preserve">
          <source>Your program will</source>
          <target state="translated">당신의 프로그램은</target>
        </trans-unit>
        <trans-unit id="7652dfd94315da720712c87b3ed050c2c020ba57" translate="yes" xml:space="preserve">
          <source>Your task is to develop a report that shows the sales total from each cash register and summarizes those sales by department within each store, by store and also generates a total sales figure for the day across all stores.</source>
          <target state="translated">귀하의 임무는 각 금전 등록기의 판매 총계를 표시하고 각 상점의 부서별 판매량을 상점별로 요약하고 모든 상점에서 하루 동안의 총 판매량을 생성하는 보고서를 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="909f99a779adb66a76fc53ab56c7dd1caf35d0fd" translate="yes" xml:space="preserve">
          <source>Z</source>
          <target state="translated">Z</target>
        </trans-unit>
        <trans-unit id="477c268e42b87c6b2096a0b9b74b0654741b83dd" translate="yes" xml:space="preserve">
          <source>ZERO, ZERO-FILL, ZEROES, ZEROS</source>
          <target state="translated">ZERO, ZERO-FILL, ZEROES, ZEROS</target>
        </trans-unit>
        <trans-unit id="e47ce1738d575c46485bfd8a54baea8d43996a94" translate="yes" xml:space="preserve">
          <source>ZEROES, ZERO-FILL, ZEROS, ZERO</source>
          <target state="translated">ZEROES, ZERO-FILL, ZEROS, ZERO</target>
        </trans-unit>
        <trans-unit id="2ec58715d6df7f2d792b4cca3206894cdc59a26f" translate="yes" xml:space="preserve">
          <source>Zero values will be returned if the screen has not been initialized and values of 24 (lines) and 80 (columns) will be returned if GnuCOBOL was not generated to include screen I/O.</source>
          <target state="translated">화면이 초기화되지 않은 경우 0 값이 반환되고 GnuCOBOL이 화면 I / O를 포함하도록 생성되지 않은 경우 24 (행) 및 80 (열) 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7791354c5965aaef2b88cad01bede0954dcce40c" translate="yes" xml:space="preserve">
          <source>Zero-Delimited Alphanumeric Literals</source>
          <target state="translated">0으로 구분 된 영숫자 리터럴</target>
        </trans-unit>
        <trans-unit id="2b28017acece29be5d7f937a0e40a94f92777732" translate="yes" xml:space="preserve">
          <source>[Above information taken from MF WB manual].</source>
          <target state="translated">[Above information taken from MF WB manual].</target>
        </trans-unit>
        <trans-unit id="3ae8aa2226204f7ba9e8232d9ea2150b6123ae84" translate="yes" xml:space="preserve">
          <source>[more info needed]</source>
          <target state="translated">[more info needed]</target>
        </trans-unit>
        <trans-unit id="5cd776fc74658d3a49fe8459fd48df458a354bfc" translate="yes" xml:space="preserve">
          <source>[to do]</source>
          <target state="translated">[to do]</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="9fa84fc91c01386659e07d966391b412315ed75e" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;RAISE&lt;/code&gt; statement.</source>
          <target state="translated">a &lt;code&gt;RAISE&lt;/code&gt; statement.</target>
        </trans-unit>
        <trans-unit id="918bdfb46a691d311de2d2b5efbe36ecf4756dd6" translate="yes" xml:space="preserve">
          <source>a GnuCOBOL rule &amp;mdash; this is my own personal programming practice intended to improve the readability and maintainability of my programs.</source>
          <target state="translated">GnuCOBOL 규칙-이것은 내 프로그램의 가독성 및 유지 관리 성을 향상시키기위한 개인적인 프로그래밍 관행입니다.</target>
        </trans-unit>
        <trans-unit id="fcb31032bd8cc544a8534c348a73610a8c310718" translate="yes" xml:space="preserve">
          <source>a [b] c</source>
          <target state="translated">a [b] c</target>
        </trans-unit>
        <trans-unit id="3e79b35e6a0ed8c9d175abe71214cac5519209ad" translate="yes" xml:space="preserve">
          <source>a non-option (only if first byte of so is &amp;lsquo;</source>
          <target state="translated">a non-option (only if first byte of so is &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="c95517ebeff6c5ba0f8fce8c78baa0bc1bb4c0c0" translate="yes" xml:space="preserve">
          <source>a recursive subroutine. This is accomplished by adding the &lt;code&gt;RECURSIVE&lt;/code&gt; attribute to its &lt;code&gt;PROGRAM-ID&lt;/code&gt; (see &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;).</source>
          <target state="translated">a recursive subroutine. This is accomplished by adding the &lt;code&gt;RECURSIVE&lt;/code&gt; attribute to its &lt;code&gt;PROGRAM-ID&lt;/code&gt; (see &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="4f304498bf53e92eac59949cf9de42bddf58e0be" translate="yes" xml:space="preserve">
          <source>a recursive subroutine. This is accomplished by adding the&lt;code&gt;RECURSIVE&lt;/code&gt;attribute to it&amp;rsquo;s&lt;code&gt;PROGRAM-ID&lt;/code&gt;(see &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;IDENTIFICATION DIVISION&lt;/a&gt;).</source>
          <target state="translated">재귀 서브 루틴 &lt;code&gt;RECURSIVE&lt;/code&gt; 속성을 &lt;code&gt;PROGRAM-ID&lt;/code&gt; 에 추가하면됩니다 ( &lt;a href=&quot;#IDENTIFICATION-DIVISION&quot;&gt;식별&lt;/a&gt; 섹션 참조 ).</target>
        </trans-unit>
        <trans-unit id="9f51777a0f2ec048fcf0cb6c98b79f3bddb3d90d" translate="yes" xml:space="preserve">
          <source>a regular answer from &lt;code&gt;getopt&lt;/code&gt;</source>
          <target state="translated">a regular answer from &lt;code&gt;getopt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="308ab8140c595dbad9d3ac81515fac02e6c3e988" translate="yes" xml:space="preserve">
          <source>a*</source>
          <target state="translated">a*</target>
        </trans-unit>
        <trans-unit id="496fbb0f632dcff40def9b88233c286632c28e7f" translate="yes" xml:space="preserve">
          <source>abc*.*</source>
          <target state="translated">abc*.*</target>
        </trans-unit>
        <trans-unit id="16ca7689b5f953679c1b2277cacb8702590a370d" translate="yes" xml:space="preserve">
          <source>absent</source>
          <target state="translated">absent</target>
        </trans-unit>
        <trans-unit id="17f83623a1a2bf8f175e19de5a9671b06ec81ca2" translate="yes" xml:space="preserve">
          <source>access-mode</source>
          <target state="translated">access-mode</target>
        </trans-unit>
        <trans-unit id="5164e24487b4e9a05448434ac3e600826fe14664" translate="yes" xml:space="preserve">
          <source>according to the bit-pattern values the characters have in storage.</source>
          <target state="translated">문자가 저장에있는 비트 패턴 값에 따라.</target>
        </trans-unit>
        <trans-unit id="d041df6bcc932ee43e6fcaff3883a2a2cf123331" translate="yes" xml:space="preserve">
          <source>active.</source>
          <target state="translated">active.</target>
        </trans-unit>
        <trans-unit id="d0f562285f01cb9165c20a4a98761926dca4caf3" translate="yes" xml:space="preserve">
          <source>actual data item</source>
          <target state="translated">actual data item</target>
        </trans-unit>
        <trans-unit id="cfa37cb7cf91b06767c8396f6246deb0ce7f39d2" translate="yes" xml:space="preserve">
          <source>actual numeric value</source>
          <target state="translated">actual numeric value</target>
        </trans-unit>
        <trans-unit id="a251ffa6dfbb4e889c9a5a7014aed642dce00102" translate="yes" xml:space="preserve">
          <source>actual value</source>
          <target state="translated">실제 값</target>
        </trans-unit>
        <trans-unit id="c662180230cad14787d4ab7e77aa08681ce783fa" translate="yes" xml:space="preserve">
          <source>address</source>
          <target state="translated">address</target>
        </trans-unit>
        <trans-unit id="acd5d99ec4b1e046d49c78b276a85efe8f9022a0" translate="yes" xml:space="preserve">
          <source>af_ZA, am_ET, ar_AE, ar_BH, ar_DZ, ar_EG, ar_IQ, ar_JO, ar_KW, ar_LB, ar_LY, ar_MA, ar_OM, ar_QA, ar_SA, ar_SY, ar_TN, ar_YE, arn_CL, as_IN, az_Cyrl_AZ, az_Latn_AZ</source>
          <target state="translated">af_ZA, am_ET, ar_AE, ar_BH, ar_DZ, ar_EG, ar_IQ, ar_JO, ar_KW, ar_LB, ar_LY, ar_MA, ar_OM, ar_QA, ar_SA, ar_SY, ar_TN, ar_YE, arn_CL, as_IN, az_Cyrl_AZ,</target>
        </trans-unit>
        <trans-unit id="12f9d82a9e8e502cf4a6191377da462ef5f2fc82" translate="yes" xml:space="preserve">
          <source>affect the repetition count.</source>
          <target state="translated">반복 횟수에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="79da5dd0b59f9ff1b16d302146ba7b172322a180" translate="yes" xml:space="preserve">
          <source>affect the value returned by this function.</source>
          <target state="translated">이 함수가 반환 한 값에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="405906c9d5be6ae5393ca65fb0e7c38e0d585ecb" translate="yes" xml:space="preserve">
          <source>after</source>
          <target state="translated">after</target>
        </trans-unit>
        <trans-unit id="856b0706a4873d359b6db9e59b03bf463c804b0d" translate="yes" xml:space="preserve">
          <source>agree with the KEY clause(s)! A table-based &lt;code&gt;SORT&lt;/code&gt; (see &lt;a href=&quot;#Table-SORT&quot;&gt;Table SORT&lt;/a&gt;) can prove very useful in this regard.</source>
          <target state="translated">agree with the KEY clause(s)! A table-based &lt;code&gt;SORT&lt;/code&gt; (see &lt;a href=&quot;#Table-SORT&quot;&gt;Table SORT&lt;/a&gt;) can prove very useful in this regard.</target>
        </trans-unit>
        <trans-unit id="ab64e92b8ed3846e3f1f30a25bd334e437e4cefc" translate="yes" xml:space="preserve">
          <source>agree with the KEY clause(s)! A table-based&lt;code&gt;SORT&lt;/code&gt;(see &lt;a href=&quot;#Table-SORT&quot;&gt;Table SORT&lt;/a&gt;) can prove very useful in this regard.</source>
          <target state="translated">KEY 조항에 동의하십시오! 이와 관련하여 테이블 기반 &lt;code&gt;SORT&lt;/code&gt; ( &lt;a href=&quot;#Table-SORT&quot;&gt;Table SORT&lt;/a&gt; 참조 )가 매우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf6ba9fe91e2963559ced78969ebb2f46bec0231" translate="yes" xml:space="preserve">
          <source>allowing the flow of execution to attempt to fall past the last statement in the perform scope</source>
          <target state="translated">allowing the flow of execution to attempt to fall past the last statement in the perform scope</target>
        </trans-unit>
        <trans-unit id="e806ea67ed831688bf6d5b51e7055bc980a87d37" translate="yes" xml:space="preserve">
          <source>allows a custom defined calling convention to be used. Such mnemonic names are defined using the &lt;code&gt;CALL-CONVENTION&lt;/code&gt; (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) clause. That clause associates a decimal integer value with &lt;var&gt;mnemonic-name-1&lt;/var&gt; such that the individual bits set on or off in the binary equivalent of the integer affect linkage to the subroutine as described in the following chart. Those rows of the chart marked with a &amp;ldquo;No&amp;rdquo; in the &lt;b&gt;Supported&lt;/b&gt; column represent bit positions (switch settings) in the integer value that are currently accepted (to provide compatibility to other COBOL implementations) if coded, but are otherwise unsupported.</source>
          <target state="translated">allows a custom defined calling convention to be used. Such mnemonic names are defined using the &lt;code&gt;CALL-CONVENTION&lt;/code&gt; (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) clause. That clause associates a decimal integer value with &lt;var&gt;mnemonic-name-1&lt;/var&gt; such that the individual bits set on or off in the binary equivalent of the integer affect linkage to the subroutine as described in the following chart. Those rows of the chart marked with a &amp;ldquo;No&amp;rdquo; in the &lt;b&gt;Supported&lt;/b&gt; column represent bit positions (switch settings) in the integer value that are currently accepted (to provide compatibility to other COBOL implementations) if coded, but are otherwise unsupported.</target>
        </trans-unit>
        <trans-unit id="171a6879b3822a6a4c4bc44495aa066156bec99d" translate="yes" xml:space="preserve">
          <source>allows system standard calling conventions (as opposed to GnuCOBOL calling conventions) to be used when calling a subroutine. The definition of what constitutes &amp;ldquo;system standard&amp;rdquo; may vary from operating system to operating system. Use of this requires special knowledge about the linkage requirements of subroutines you are intending to &lt;code&gt;CALL&lt;/code&gt;. Subroutines written in GnuCOBOL do not need this option.</source>
          <target state="translated">allows system standard calling conventions (as opposed to GnuCOBOL calling conventions) to be used when calling a subroutine. The definition of what constitutes &amp;ldquo;system standard&amp;rdquo; may vary from operating system to operating system. Use of this requires special knowledge about the linkage requirements of subroutines you are intending to &lt;code&gt;CALL&lt;/code&gt; . Subroutines written in GnuCOBOL do not need this option.</target>
        </trans-unit>
        <trans-unit id="4cbc7ba2b65974670df89fbe8132e872527b5526" translate="yes" xml:space="preserve">
          <source>alphabet-name-1</source>
          <target state="translated">alphabet-name-1</target>
        </trans-unit>
        <trans-unit id="09706c418809f1f4cfda992435ca1438eddaaeed" translate="yes" xml:space="preserve">
          <source>also</source>
          <target state="translated">also</target>
        </trans-unit>
        <trans-unit id="9a43ad09fba0d1144c4ad5f54e93695504772898" translate="yes" xml:space="preserve">
          <source>also marks the completion of the detailed description of the file and signifies the end of the file section as well.</source>
          <target state="translated">also marks the completion of the detailed description of the file and signifies the end of the file section as well.</target>
        </trans-unit>
        <trans-unit id="6656018ac96d0295d887ff2893ba9af66ae16af2" translate="yes" xml:space="preserve">
          <source>always</source>
          <target state="translated">always</target>
        </trans-unit>
        <trans-unit id="c0c857c8ae8164660e8debe2b53f3c013b626e79" translate="yes" xml:space="preserve">
          <source>an &lt;code&gt;EXIT&lt;/code&gt; or a &lt;code&gt;GOBACK&lt;/code&gt; statement with a &lt;code&gt;RAISING&lt;/code&gt; phrase that specifies an &lt;code&gt;EC-I-O&lt;/code&gt; exception-name.</source>
          <target state="translated">an &lt;code&gt;EXIT&lt;/code&gt; or a &lt;code&gt;GOBACK&lt;/code&gt; statement with a &lt;code&gt;RAISING&lt;/code&gt; phrase that specifies an &lt;code&gt;EC-I-O&lt;/code&gt; exception-name.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="6590f3a0d59d049171a74ce6c10575f7b9541994" translate="yes" xml:space="preserve">
          <source>and continue.</source>
          <target state="translated">and continue.</target>
        </trans-unit>
        <trans-unit id="f2543e402211712cd09c975116bc94b39b29a629" translate="yes" xml:space="preserve">
          <source>and each &lt;var&gt;identifier-4&lt;/var&gt; will be referred to as a</source>
          <target state="translated">and each &lt;var&gt;identifier-4&lt;/var&gt; will be referred to as a</target>
        </trans-unit>
        <trans-unit id="b0adec687e3ab4fff14b5efa8b7087cfcfe80d04" translate="yes" xml:space="preserve">
          <source>and/or</source>
          <target state="translated">and/or</target>
        </trans-unit>
        <trans-unit id="11a9215ec620218c8e8d409263469091431ff0d4" translate="yes" xml:space="preserve">
          <source>angle</source>
          <target state="translated">angle</target>
        </trans-unit>
        <trans-unit id="c5fe0200d1c7a5139bd18fd22268c4ca8bf45e90" translate="yes" xml:space="preserve">
          <source>any</source>
          <target state="translated">any</target>
        </trans-unit>
        <trans-unit id="6bbcc8758530e878d069a2f7c2e349edd577689a" translate="yes" xml:space="preserve">
          <source>any &amp;lsquo;</source>
          <target state="translated">any &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="d0556c73c33d86f01f7279b33f28b599f555f488" translate="yes" xml:space="preserve">
          <source>any&lt;code&gt;9&lt;/code&gt;editing symbols in the &amp;lt;</source>
          <target state="translated">어떤 &lt;code&gt;9&lt;/code&gt; 개 에서 편집 기호를 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="910f17dc52f0ccb23c3fe3b44a23cb9b097f162a" translate="yes" xml:space="preserve">
          <source>appear</source>
          <target state="translated">appear</target>
        </trans-unit>
        <trans-unit id="b146ac07dd6fd8782adda34f369c1c7e97ac5d26" translate="yes" xml:space="preserve">
          <source>apply to any subprogram&amp;rsquo;s local-storage (if any), regardless of the use (or not) of &lt;code&gt;INITIAL&lt;/code&gt;.</source>
          <target state="translated">apply to any subprogram&amp;rsquo;s local-storage (if any), regardless of the use (or not) of &lt;code&gt;INITIAL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ad6dd8109ca919475311b73fe54db7348d531dd" translate="yes" xml:space="preserve">
          <source>apply to any subprogram&amp;rsquo;s local-storage (if any), regardless of the use (or not) of&lt;code&gt;INITIAL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;INITIAL&lt;/code&gt; 의 사용 여부에 관계없이 서브 프로그램의 로컬 스토리지 (있는 경우)에 적용</target>
        </trans-unit>
        <trans-unit id="7683453cdf2eff068451e7462bee7ef655e9870a" translate="yes" xml:space="preserve">
          <source>approaches:</source>
          <target state="translated">approaches:</target>
        </trans-unit>
        <trans-unit id="5f9e5802bbabc71f9275fccf122f5a52b8599f12" translate="yes" xml:space="preserve">
          <source>are</source>
          <target state="translated">are</target>
        </trans-unit>
        <trans-unit id="29948a0a66c87654b20be9c4115624bb821e2e3a" translate="yes" xml:space="preserve">
          <source>are also known by the term dynamically-loadable</source>
          <target state="translated">동적로드 가능이라는 용어로도 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="f36f6877daeed6091f68c806fda4a33e3c5452f3" translate="yes" xml:space="preserve">
          <source>are discussed in detail in the next four sections.</source>
          <target state="translated">다음 네 섹션에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e8b8be006465b4c5c029bda978c07ec1e5b259e6" translate="yes" xml:space="preserve">
          <source>are violated, there will be no message issued by the compiler, but the run-time results of a &lt;code&gt;SEARCH ALL&lt;/code&gt; against the table will probably be incorrect.</source>
          <target state="translated">are violated, there will be no message issued by the compiler, but the run-time results of a &lt;code&gt;SEARCH ALL&lt;/code&gt; against the table will probably be incorrect.</target>
        </trans-unit>
        <trans-unit id="975aafa5f2d95d44f3bca9869a18011d029224a8" translate="yes" xml:space="preserve">
          <source>argument-1</source>
          <target state="translated">argument-1</target>
        </trans-unit>
        <trans-unit id="4ae676b823e986b993a278f745f557f8d2ed84da" translate="yes" xml:space="preserve">
          <source>argument-2</source>
          <target state="translated">argument-2</target>
        </trans-unit>
        <trans-unit id="79336744d84b3e9e06e4ea8baee1163cc4f5b910" translate="yes" xml:space="preserve">
          <source>as a  &lt;em&gt;Subroutine&lt;/em&gt;, it does so using a special statement dedicated to that function (the &lt;code&gt;CALL&lt;/code&gt; statement (see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;), just as if</source>
          <target state="translated">as a &lt;em&gt;Subroutine&lt;/em&gt;, it does so using a special statement dedicated to that function (the &lt;code&gt;CALL&lt;/code&gt; statement (see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;), just as if</target>
        </trans-unit>
        <trans-unit id="a28b2a84dcb2b0814bafda2ba5dc98551383d375" translate="yes" xml:space="preserve">
          <source>as a  &lt;em&gt;User-Defined Function&lt;/em&gt;, it does so in a manner identical to how</source>
          <target state="translated">as a &lt;em&gt;User-Defined Function&lt;/em&gt;, it does so in a manner identical to how</target>
        </trans-unit>
        <trans-unit id="51c0a11fa63600bc263d3cb5fff69d9425a8f7fe" translate="yes" xml:space="preserve">
          <source>as well as</source>
          <target state="translated">만큼 잘</target>
        </trans-unit>
        <trans-unit id="c18ea10366705f39afd098bbd91d67a28d56302b" translate="yes" xml:space="preserve">
          <source>associated with them where one or more other statements can be considered to be part of or related to the statement in question. An example of such a situation might be the following, where the interest on a loan is being calculated and displayed at 4% interest if the loan balance is under $10,000, and 4.5% otherwise. (WARNING: the following code has an error!):</source>
          <target state="translated">associated with them where one or more other statements can be considered to be part of or related to the statement in question. An example of such a situation might be the following, where the interest on a loan is being calculated and displayed at 4% interest if the loan balance is under $10,000, and 4.5% otherwise. (WARNING: the following code has an error!):</target>
        </trans-unit>
        <trans-unit id="20988a5ccb7a4e693b66e54bb26fb4920fb42b4a" translate="yes" xml:space="preserve">
          <source>attached</source>
          <target state="translated">attached</target>
        </trans-unit>
        <trans-unit id="7b231a50a498ef151e291795f46f56bee569eae5" translate="yes" xml:space="preserve">
          <source>available</source>
          <target state="translated">available</target>
        </trans-unit>
        <trans-unit id="2d29618a552da37749759f6bc5f9d17d7c71721f" translate="yes" xml:space="preserve">
          <source>available screen area</source>
          <target state="translated">available screen area</target>
        </trans-unit>
        <trans-unit id="e67d8b800da686700b4a206b211194171ea095c2" translate="yes" xml:space="preserve">
          <source>available with GnuCOBOL.</source>
          <target state="translated">available with GnuCOBOL.</target>
        </trans-unit>
        <trans-unit id="c74a3276c7e3cbbf386b6332e627989dfc851c00" translate="yes" xml:space="preserve">
          <source>a|b|c</source>
          <target state="translated">a|b|c</target>
        </trans-unit>
        <trans-unit id="e9d71f5ee7c92d6dc9e92ffdad17b8bd49418f98" translate="yes" xml:space="preserve">
          <source>b</source>
          <target state="translated">b</target>
        </trans-unit>
        <trans-unit id="8574c92d5408a2611ef5579b3457177f0e71591f" translate="yes" xml:space="preserve">
          <source>ba_R, be_BY, bg_BG, bn_IN bo_BT, bo_CN, br_FR, bs_Cyrl_BA, bs_Latn_BA</source>
          <target state="translated">ba_R, be_BY, bg_BG, bn_IN bo_BT, bo_CN, br_FR, bs_Cyrl_BA, bs_Latn_BA</target>
        </trans-unit>
        <trans-unit id="5cb138284d431abd6a053a56625ec088bfb88912" translate="yes" xml:space="preserve">
          <source>bbb</source>
          <target state="translated">bbb</target>
        </trans-unit>
        <trans-unit id="939d32e2787670e0c75caf85136869e4565bd7c5" translate="yes" xml:space="preserve">
          <source>be altered.</source>
          <target state="translated">변경됩니다.</target>
        </trans-unit>
        <trans-unit id="e5d09d9b66a4129da6d84709951467918b797970" translate="yes" xml:space="preserve">
          <source>be an identifier. Locale names are specified using UNIX-standard names.</source>
          <target state="translated">식별자입니다. 로케일 이름은 UNIX 표준 이름을 사용하여 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="d27337cff63054b63275f40d49eb20ca852b3ee7" translate="yes" xml:space="preserve">
          <source>be an object-code module (output</source>
          <target state="translated">객체 코드 모듈 (출력)</target>
        </trans-unit>
        <trans-unit id="567b0dc3fdac8695529ac71a282008a58c7a2393" translate="yes" xml:space="preserve">
          <source>be an object-code module (output from the C compiler), recognized as such by having a file extension of &lt;code&gt;.o&lt;/code&gt;. In these situations, all compilation will be bypassed, and the object code will be &amp;ldquo;bound&amp;rdquo; into the generated executable by the linker (an &lt;code&gt;ld&lt;/code&gt; command executed internally by the &lt;code&gt;cobc&lt;/code&gt; command).</source>
          <target state="translated">be an object-code module (output from the C compiler), recognized as such by having a file extension of &lt;code&gt;.o&lt;/code&gt; . In these situations, all compilation will be bypassed, and the object code will be &amp;ldquo;bound&amp;rdquo; into the generated executable by the linker (an &lt;code&gt;ld&lt;/code&gt; command executed internally by the &lt;code&gt;cobc&lt;/code&gt; command).</target>
        </trans-unit>
        <trans-unit id="b5b72f0374ede222401b74384819801508acd9e1" translate="yes" xml:space="preserve">
          <source>be considered &lt;code&gt;NUMERIC&lt;/code&gt; if sign = &lt;code&gt;X&quot;F&quot;&lt;/code&gt;.</source>
          <target state="translated">sign = &lt;code&gt;X&quot;F&quot;&lt;/code&gt; 경우 &lt;code&gt;NUMERIC&lt;/code&gt; 로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c5486f7db3cb39afb23f698798d2f38819b91a3" translate="yes" xml:space="preserve">
          <source>be consistent with the &lt;code&gt;PICTURE&lt;/code&gt; (see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause of that item, although that will not be enforced by the &lt;code&gt;ACCEPT&lt;/code&gt; statement. You may use &lt;code&gt;Class Conditions&lt;/code&gt; (see &lt;a href=&quot;#Class-Conditions&quot;&gt;Class Conditions&lt;/a&gt;) after the data is accepted to enforce the data type.</source>
          <target state="translated">과 일치 &lt;code&gt;PICTURE&lt;/code&gt; (참조 &lt;a href=&quot;#PICTURE&quot;&gt;그림을&lt;/a&gt; 그가에 의해 적용되지 않습니다 있지만) 해당 항목의 조항 &lt;code&gt;ACCEPT&lt;/code&gt; 문. 당신은 사용할 수 있습니다 &lt;code&gt;Class Conditions&lt;/code&gt; (참조 &lt;a href=&quot;#Class-Conditions&quot;&gt;클래스 조건&lt;/a&gt; 데이터가 데이터 형식을 시행 승인 후).</target>
        </trans-unit>
        <trans-unit id="45971856d899017253da77c1bb7afd2687b69100" translate="yes" xml:space="preserve">
          <source>be consistent with the &lt;code&gt;PICTURE&lt;/code&gt; (see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause of that item. This will be enforced at runtime by the &lt;code&gt;ACCEPT&lt;/code&gt; statement.</source>
          <target state="translated">과 일치 &lt;code&gt;PICTURE&lt;/code&gt; (참조 &lt;a href=&quot;#PICTURE&quot;&gt;영상&lt;/a&gt; 해당 항목의 절). 이는 &lt;code&gt;ACCEPT&lt;/code&gt; 문에 의해 런타임에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6e5f49b74408f187421cb162814725b355a262a8" translate="yes" xml:space="preserve">
          <source>be consistent with the&lt;code&gt;PICTURE&lt;/code&gt;(see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause of that item, although that will not be enforced by the&lt;code&gt;ACCEPT&lt;/code&gt;statement. You may use&lt;code&gt;Class Conditions&lt;/code&gt;(see &lt;a href=&quot;#Class-Conditions&quot;&gt;Class Conditions&lt;/a&gt;) after the data is accepted to enforce the data type.</source>
          <target state="translated">과 일치 &lt;code&gt;PICTURE&lt;/code&gt; (참조 &lt;a href=&quot;#PICTURE&quot;&gt;그림을&lt;/a&gt; 그가에 의해 적용되지 않습니다 있지만) 해당 항목의 조항 &lt;code&gt;ACCEPT&lt;/code&gt; 문. 당신은 사용할 수 있습니다 &lt;code&gt;Class Conditions&lt;/code&gt; (참조 &lt;a href=&quot;#Class-Conditions&quot;&gt;클래스 조건&lt;/a&gt; 데이터가 데이터 형식을 시행 승인 후).</target>
        </trans-unit>
        <trans-unit id="6cdc6e7bb66fbea5641669c73f21ddc31c4d50ef" translate="yes" xml:space="preserve">
          <source>be consistent with the&lt;code&gt;PICTURE&lt;/code&gt;(see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause of that item. This will be enforced at runtime by the&lt;code&gt;ACCEPT&lt;/code&gt;statement.</source>
          <target state="translated">과 일치 &lt;code&gt;PICTURE&lt;/code&gt; (참조 &lt;a href=&quot;#PICTURE&quot;&gt;영상&lt;/a&gt; 해당 항목의 절). 이것은 &lt;code&gt;ACCEPT&lt;/code&gt; 문에 의해 런타임에 시행됩니다 .</target>
        </trans-unit>
        <trans-unit id="9768d56b7e9b8ca72d04ef0b2d188dbe66acb783" translate="yes" xml:space="preserve">
          <source>be included in that program&amp;rsquo;s &lt;code&gt;REPOSITORY&lt;/code&gt; paragraph, which therefore makes the &lt;code&gt;FUNCTION&lt;/code&gt; keyword optional.</source>
          <target state="translated">해당 프로그램의 &lt;code&gt;REPOSITORY&lt;/code&gt; 단락에 포함되므로 &lt;code&gt;FUNCTION&lt;/code&gt; 키워드를 선택 사항으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c02c30672a6d6bb0800865402cb2b81c4de6e0d9" translate="yes" xml:space="preserve">
          <source>be included in that program&amp;rsquo;s&lt;code&gt;REPOSITORY&lt;/code&gt;paragraph, which therefore makes the&lt;code&gt;FUNCTION&lt;/code&gt;keyword optional.</source>
          <target state="translated">해당 프로그램의 &lt;code&gt;REPOSITORY&lt;/code&gt; 단락에 포함되어 &lt;code&gt;FUNCTION&lt;/code&gt; 키워드를 선택 사항으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b56c5f861486451b494423cecbbcfa75af783203" translate="yes" xml:space="preserve">
          <source>be null-terminating their strings!</source>
          <target state="translated">문자열을 null로 종료하십시오!</target>
        </trans-unit>
        <trans-unit id="df8d89e04bbe12a0c857bbe05f65f6bbe4efa37c" translate="yes" xml:space="preserve">
          <source>be processed but will not actually be presented to any report page. This will allow summary processing to take place. If all &lt;code&gt;GENERATE&lt;/code&gt; statements are of this form, the report is said to be a  &lt;em&gt;summary report&lt;/em&gt;. If at least one &lt;code&gt;GENERATE &lt;var&gt;identifier-1&lt;/var&gt;&lt;/code&gt; is executed, the report is considered to be a  &lt;em&gt;detail report&lt;/em&gt;.</source>
          <target state="translated">처리되지만 실제로 보고서 페이지에 표시되지는 않습니다. 이렇게하면 요약 처리가 수행됩니다. 모든 &lt;code&gt;GENERATE&lt;/code&gt; 문이이 형식이면 보고서를 &lt;em&gt;요약 보고서&lt;/em&gt; 라고합니다 . 하나 이상의 &lt;code&gt;GENERATE &lt;var&gt;identifier-1&lt;/var&gt;&lt;/code&gt; 이 실행되면 보고서는 &lt;em&gt;세부 보고서로&lt;/em&gt; 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="1cf9515113004ee74094093f1af2dbbea9e220db" translate="yes" xml:space="preserve">
          <source>be processed but will not actually be presented to any report page. This will allow summary processing to take place. If all&lt;code&gt;GENERATE&lt;/code&gt;statements are of this form, the report is said to be a &amp;rsquo;</source>
          <target state="translated">처리되지만 실제로는 보고서 페이지에 표시되지 않습니다. 그러면 요약 처리가 수행됩니다. 모든 &lt;code&gt;GENERATE&lt;/code&gt; 문이이 형식 인 경우 보고서는 '</target>
        </trans-unit>
        <trans-unit id="4b3f10734486156e4756838575d8ed76c6b00435" translate="yes" xml:space="preserve">
          <source>be the &lt;code&gt;RECORD KEY&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) or one of the file&amp;rsquo;s &lt;code&gt;ALTERNATE RECORD KEY&lt;/code&gt; fields (if any). The current contents of that field will identify the record to be accessed. If an alternate record key is used, and that key allows duplicate values, the record accessed will be the</source>
          <target state="translated">&lt;code&gt;RECORD KEY&lt;/code&gt; ( &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt; 참조 ) 또는 파일의 &lt;code&gt;ALTERNATE RECORD KEY&lt;/code&gt; 필드 (있는 경우) 중 하나 여야합니다 . 해당 필드의 현재 내용은 액세스 할 레코드를 식별합니다. 대체 레코드 키가 사용되고 해당 키가 중복 값을 허용하는 경우 액세스 된 레코드는</target>
        </trans-unit>
        <trans-unit id="bf25b5dab4899cf41e9e3be57720ff2e1b853f30" translate="yes" xml:space="preserve">
          <source>be the&lt;code&gt;RECORD KEY&lt;/code&gt;(see &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;ORGANIZATION INDEXED&lt;/a&gt;) or one of the file&amp;rsquo;s&lt;code&gt;ALTERNATE RECORD KEY&lt;/code&gt;fields (if any) &amp;mdash; the current contents of that field will identify the record to be accessed. If an alternate record key is used, and that key allows duplicate values, the record accessed will be the</source>
          <target state="translated">수 &lt;code&gt;RECORD KEY&lt;/code&gt; (참조 &lt;a href=&quot;#ORGANIZATION-INDEXED&quot;&gt;조직 인덱스를&lt;/a&gt; ) 또는 파일의 하나 &lt;code&gt;ALTERNATE RECORD KEY&lt;/code&gt; 의 필드 (있는 경우) - 해당 필드의 현재 내용은 레코드를 액세스 할 수 식별합니다. 대체 레코드 키가 사용되고 해당 키가 중복 값을 허용하는 경우 액세스 된 레코드는</target>
        </trans-unit>
        <trans-unit id="d077e6349eb33a0d09adc80e02a9607bb9a1024a" translate="yes" xml:space="preserve">
          <source>be treated as a random &lt;code&gt;READ&lt;/code&gt;.</source>
          <target state="translated">임의의 &lt;code&gt;READ&lt;/code&gt; 로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="40166cb4775ca6d1342e7c80b14a94342553cf77" translate="yes" xml:space="preserve">
          <source>be treated as a random&lt;code&gt;READ&lt;/code&gt;</source>
          <target state="translated">무작위 &lt;code&gt;READ&lt;/code&gt; 로 취급</target>
        </trans-unit>
        <trans-unit id="1d56440881a826d1d8c3632b28b8bcfef3b4584d" translate="yes" xml:space="preserve">
          <source>be yet included in this manual.</source>
          <target state="translated">이 설명서에는 아직 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51de2b835bd35a67eb32dbcd3d77d4b96e5aa39d" translate="yes" xml:space="preserve">
          <source>before</source>
          <target state="translated">before</target>
        </trans-unit>
        <trans-unit id="336edf81860bdfc5e56a603ab1759d4ec3c587d2" translate="yes" xml:space="preserve">
          <source>beginning</source>
          <target state="translated">beginning</target>
        </trans-unit>
        <trans-unit id="05e0c9dbd571ec666d677cee01437943c515b77c" translate="yes" xml:space="preserve">
          <source>behave as a &lt;code&gt;mkdir -p&lt;/code&gt; (Unix) or &lt;code&gt;mkdir /p&lt;/code&gt; (Windows).</source>
          <target state="translated">A와 행동 &lt;code&gt;mkdir -p&lt;/code&gt; (UNIX) 또는 &lt;code&gt;mkdir /p&lt;/code&gt; (Windows)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e8b95d665e2ceb500a33527b2321b156a6f1e2d2" translate="yes" xml:space="preserve">
          <source>being</source>
          <target state="translated">being</target>
        </trans-unit>
        <trans-unit id="6ddbfcc194f9a300adec2468ed6303dfeda48f4e" translate="yes" xml:space="preserve">
          <source>being passed as an argument. The item may anything defined within the data division of the program. If the subroutine modifies the contents of this argument, the calling program will &amp;ldquo;see&amp;rdquo; the results of that change when the subroutine returns control. This is the default manner in which GnuCOBOL passes arguments to a subroutine, should no &lt;code&gt;BY&lt;/code&gt; clauses be included on the &lt;code&gt;CALL&lt;/code&gt;.</source>
          <target state="translated">인수로 전달됩니다. 항목은 프로그램의 데이터 분할 내에 정의 된 모든 것이 될 수 있습니다. 서브 루틴이이 인수의 내용을 수정하는 경우 호출 프로그램은 서브 루틴이 제어를 반환 할 때 해당 변경 결과를 &quot;확인&quot;합니다. 이것은 GnuCOBOL이 &lt;code&gt;CALL&lt;/code&gt; 에 &lt;code&gt;BY&lt;/code&gt; 절이 포함 되지 않은 경우 서브 루틴에 인수를 전달하는 기본 방식입니다 .</target>
        </trans-unit>
        <trans-unit id="a31e44e0548b4c995336834db72c429ffc0f13ba" translate="yes" xml:space="preserve">
          <source>better</source>
          <target state="translated">better</target>
        </trans-unit>
        <trans-unit id="006acda9f06556a6af437327a836218723347f23" translate="yes" xml:space="preserve">
          <source>big-endian format, which makes it the</source>
          <target state="translated">빅 엔디안 형식이므로</target>
        </trans-unit>
        <trans-unit id="ab08c707d243fff0b0fb1231fe4c0d59e731bea3" translate="yes" xml:space="preserve">
          <source>billion</source>
          <target state="translated">billion</target>
        </trans-unit>
        <trans-unit id="fb62f2de393cc99fa4328b8bf80cfaada069e9f2" translate="yes" xml:space="preserve">
          <source>binary format.</source>
          <target state="translated">바이너리 형식.</target>
        </trans-unit>
        <trans-unit id="fc39b18f287d8bbfaceae020f4a4eb32ac5c1e70" translate="yes" xml:space="preserve">
          <source>both</source>
          <target state="translated">both</target>
        </trans-unit>
        <trans-unit id="e53c2ea1fe4bd2b78bf4723c7c155a578e020a25" translate="yes" xml:space="preserve">
          <source>buffer</source>
          <target state="translated">buffer</target>
        </trans-unit>
        <trans-unit id="7bede894df35d0068545c9b1530be26c8101c681" translate="yes" xml:space="preserve">
          <source>business transactions, and does so:</source>
          <target state="translated">비즈니스 거래 및 그렇게 :</target>
        </trans-unit>
        <trans-unit id="8cf1783fa99f62ca581f6fe8f3cd66b0f9ab9fc3" translate="yes" xml:space="preserve">
          <source>byte</source>
          <target state="translated">byte</target>
        </trans-unit>
        <trans-unit id="23de52d797f4b2ca08a737f353d733440fe30805" translate="yes" xml:space="preserve">
          <source>byte of a &lt;code&gt;PACKED-DECIMAL&lt;/code&gt; or &lt;code&gt;COMP-3&lt;/code&gt; data item will always have its left nibble corresponding to the last &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;PACKED-DECIMAL&lt;/code&gt; 또는 &lt;code&gt;COMP-3&lt;/code&gt; 데이터 항목의 바이트 는 항상 마지막 '에 해당하는 왼쪽 니블을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="d9ac3e11fefbb7ec102338bbc279e87b8162e569" translate="yes" xml:space="preserve">
          <source>byte of a&lt;code&gt;PACKED-DECIMAL&lt;/code&gt;or&lt;code&gt;COMP-3&lt;/code&gt;data item will always have its left nibble corresponding to the last&lt;code&gt;9&lt;/code&gt;in the&lt;code&gt;PICTURE&lt;/code&gt;and its right nibble reserved as a sign indicator. This sign indicator is always present regardless of whether or not the&lt;code&gt;PICTURE&lt;/code&gt;included an&lt;code&gt;S&lt;/code&gt;symbol.</source>
          <target state="translated">&lt;code&gt;PACKED-DECIMAL&lt;/code&gt; 또는 &lt;code&gt;COMP-3&lt;/code&gt; 데이터 항목의 바이트 는 항상 &lt;code&gt;PICTURE&lt;/code&gt; 의 마지막 &lt;code&gt;9&lt;/code&gt; 에 해당하는 왼쪽 니블 과 부호 표시 자로 예약 된 오른쪽 니블을 갖습니다. 이 기호 표시기는 &lt;code&gt;PICTURE&lt;/code&gt; 에 &lt;code&gt;S&lt;/code&gt; 기호가 포함되어 있는지 여부에 관계없이 항상 존재합니다 .</target>
        </trans-unit>
        <trans-unit id="796efdc0493e232d0715f946331203f93214e309" translate="yes" xml:space="preserve">
          <source>byte of the data item will contain an unused left nibble if the &lt;code&gt;PICTURE&lt;/code&gt; had an even number of &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;PICTURE&lt;/code&gt; 에 '가 짝수 인 경우 데이터 항목의 바이트에는 사용되지 않은 왼쪽 니블이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8dddc0a54b0d5290a97771b9c64fb19fb1449dfb" translate="yes" xml:space="preserve">
          <source>byte of the data item will contain an unused left nibble if the&lt;code&gt;PICTURE&lt;/code&gt;had an even number of&lt;code&gt;9&lt;/code&gt;symbols in it.</source>
          <target state="translated">&lt;code&gt;PICTURE&lt;/code&gt; 에 짝수의 &lt;code&gt;9&lt;/code&gt; 개 심볼 이 있으면 데이터 항목의 바이트에 사용되지 않은 왼쪽 니블이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="7f53e9e0d45bdd5f6b7cff71771eaa637b33d856" translate="yes" xml:space="preserve">
          <source>byte-length</source>
          <target state="translated">byte-length</target>
        </trans-unit>
        <trans-unit id="daf529a73101c2be626b99fc6938163e7a27620b" translate="yes" xml:space="preserve">
          <source>bytes</source>
          <target state="translated">bytes</target>
        </trans-unit>
        <trans-unit id="84a516841ba77a5b4648de2cd0dfcb30ea46dbb4" translate="yes" xml:space="preserve">
          <source>c</source>
          <target state="translated">c</target>
        </trans-unit>
        <trans-unit id="d911be42721d2dba24da73c4d7c079e8855f77ea" translate="yes" xml:space="preserve">
          <source>ca_ES, cs_CZ, cy_GB</source>
          <target state="translated">ca_ES, cs_CZ, cy_GB</target>
        </trans-unit>
        <trans-unit id="3a3f75346c72eb3d88c3f6ebab78414f0335a06a" translate="yes" xml:space="preserve">
          <source>call to any entry-point within the module being made at run-time, the contents of &amp;lt;</source>
          <target state="translated">런타임에 모듈 내에서 시작점을 호출하면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="8c6ccad4c244addbdb2e51d00e428bee5cdd1a1c" translate="yes" xml:space="preserve">
          <source>call to any entry-point within the module being made at run-time, the contents of &lt;var&gt;identifier-1&lt;/var&gt; must be the primary entry-point name of the module (which must also match the filename, minus any OS-mandated extension) of the executable file comprising the module).</source>
          <target state="translated">런타임에 수행되는 모듈 내의 모든 진입 점에 대한 호출의 경우 &lt;var&gt;identifier-1&lt;/var&gt; 의 내용은 모듈의 기본 진입 점 이름이어야합니다. 모듈을 구성하는 실행 파일).</target>
        </trans-unit>
        <trans-unit id="c50385b00820e4cf8207569dc389cf7ef0e084e7" translate="yes" xml:space="preserve">
          <source>call.c</source>
          <target state="translated">call.c</target>
        </trans-unit>
        <trans-unit id="5befc09eb73b7a9fec50948d990c5a79bd742c7c" translate="yes" xml:space="preserve">
          <source>call.h</source>
          <target state="translated">call.h</target>
        </trans-unit>
        <trans-unit id="7e9219a0599eae1d9601883f894b4fbe60870586" translate="yes" xml:space="preserve">
          <source>can</source>
          <target state="translated">can</target>
        </trans-unit>
        <trans-unit id="cef4976ddc3e2938d7b80027804ec561702e42df" translate="yes" xml:space="preserve">
          <source>cannot be located, execution will be terminated with an error message (</source>
          <target state="translated">찾을 수 없습니다. 실행은 오류 메시지 (</target>
        </trans-unit>
        <trans-unit id="ba66513885706cb6a15b73c09c19bdb842147a3b" translate="yes" xml:space="preserve">
          <source>category-name</source>
          <target state="translated">category-name</target>
        </trans-unit>
        <trans-unit id="e9caf8630551c29ad4932878a08a50cbeb5eaae8" translate="yes" xml:space="preserve">
          <source>category-name-1</source>
          <target state="translated">category-name-1</target>
        </trans-unit>
        <trans-unit id="22342094b67766e3316ea5d2f18158c85575c178" translate="yes" xml:space="preserve">
          <source>category-name-2</source>
          <target state="translated">category-name-2</target>
        </trans-unit>
        <trans-unit id="5d03264c02c8a8e8f28fc35631aa4353e90f7838" translate="yes" xml:space="preserve">
          <source>causes the linkage to the subroutine to be performed in such a way as to require the subroutine to be statically-linked with the calling program. Note that this enables static-linking to be used on a subroutine-by-subroutine selective basis.</source>
          <target state="translated">서브 루틴이 호출 프로그램과 정적으로 링크되도록 요구하는 방식으로 서브 루틴에 대한 링크가 수행되도록합니다. 이렇게하면 서브 루틴별로 선택적으로 정적 링크를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdb480de655aa6ec75ca058c849c4faf3c0f75b1" translate="yes" xml:space="preserve">
          <source>cc</source>
          <target state="translated">cc</target>
        </trans-unit>
        <trans-unit id="f36b4825e5db2cf7dd2d2593b3f5c24c0311d8b2" translate="yes" xml:space="preserve">
          <source>ccc</source>
          <target state="translated">ccc</target>
        </trans-unit>
        <trans-unit id="db4bdde8d0ab52655add950628eec505e47c8801" translate="yes" xml:space="preserve">
          <source>changed that argument, but since the COBOL program passed that argument &lt;code&gt;BY CONTENT&lt;/code&gt;, the change was made to a</source>
          <target state="translated">인수 있음을 변경하지만, COBOL 프로그램이 그 인수 통과 이후 &lt;code&gt;BY CONTENT&lt;/code&gt; , 변경이가 변경되었습니다</target>
        </trans-unit>
        <trans-unit id="b3b836b6d3e1f47968489287c1e0548e95a4d5a5" translate="yes" xml:space="preserve">
          <source>changed that argument, but since the COBOL program passed that argument&lt;code&gt;BY CONTENT&lt;/code&gt; the change was made to a</source>
          <target state="translated">해당 인수를 변경했지만 COBOL 프로그램이 해당 인수 &lt;code&gt;BY CONTENT&lt;/code&gt; 를 전달한 이후로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="71fafc4e2fc1e47e234762a96b80512b6b5534c2" translate="yes" xml:space="preserve">
          <source>char</source>
          <target state="translated">char</target>
        </trans-unit>
        <trans-unit id="b788d2d8258d677c25673d0d7a7e7f3f71952e42" translate="yes" xml:space="preserve">
          <source>char-n</source>
          <target state="translated">char-n</target>
        </trans-unit>
        <trans-unit id="771e30d3c784e7ffe91bd6cb3c2102facfc79d8f" translate="yes" xml:space="preserve">
          <source>character of the previous field. Thus, &lt;code&gt;COLUMN PLUS 1&lt;/code&gt; will leave no blank positions between the end of the previous field and the start of this one.</source>
          <target state="translated">이전 필드의 문자. 따라서 &lt;code&gt;COLUMN PLUS 1&lt;/code&gt; 은 이전 필드의 끝과이 필드의 시작 사이에 빈 위치를 남기지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7bce3f12d4abaa2e130fb08144194778e53b6c3" translate="yes" xml:space="preserve">
          <source>character of the previous field. Thus,&lt;code&gt;COLUMN PLUS 1&lt;/code&gt;will leave no blank positions between the end of the previous field and the start of this one.</source>
          <target state="translated">이전 필드의 문자 따라서 &lt;code&gt;COLUMN PLUS 1&lt;/code&gt; 은 이전 필드의 끝과이 필드의 시작 사이에 공백 위치를 남기지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e16d5410e80c68f6e79485651dd566b4a31a1c7" translate="yes" xml:space="preserve">
          <source>character should be copied.</source>
          <target state="translated">문자를 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa908a40ba515918f9d5edbdcad8ebc1fe5c2b42" translate="yes" xml:space="preserve">
          <source>characters</source>
          <target state="translated">characters</target>
        </trans-unit>
        <trans-unit id="a11971e3e49773aad3e9437b286e6b4004a839eb" translate="yes" xml:space="preserve">
          <source>class-name-1</source>
          <target state="translated">class-name-1</target>
        </trans-unit>
        <trans-unit id="ebf1f9fa8afd6d1932bd65bc4cc3af89a4c8e228" translate="yes" xml:space="preserve">
          <source>cmd.exe</source>
          <target state="translated">cmd.exe</target>
        </trans-unit>
        <trans-unit id="c8f5188595be08262f83053ecc3b45c8033261dc" translate="yes" xml:space="preserve">
          <source>cob*.tmp</source>
          <target state="translated">cob*.tmp</target>
        </trans-unit>
        <trans-unit id="e6fb06210fafc02fd7479ddbed2d042cc3a5155e" translate="yes" xml:space="preserve">
          <source>code</source>
          <target state="translated">code</target>
        </trans-unit>
        <trans-unit id="77ffa6b4ec61bc57f3f63935b0894f05ea401e88" translate="yes" xml:space="preserve">
          <source>combination</source>
          <target state="translated">combination</target>
        </trans-unit>
        <trans-unit id="023646ce8406be5b9700f2babded876beaf4396b" translate="yes" xml:space="preserve">
          <source>compilation</source>
          <target state="translated">compilation</target>
        </trans-unit>
        <trans-unit id="1578383ff3c1f54d849bd981ffe830e1826b83f6" translate="yes" xml:space="preserve">
          <source>compilation of that file will be bypassed by the &lt;code&gt;cobc&lt;/code&gt; command; instead, the file will be passed directly to the C compiler or assembler (executed automatically by &lt;code&gt;cobc&lt;/code&gt;).</source>
          <target state="translated">해당 파일의 컴파일은 &lt;code&gt;cobc&lt;/code&gt; 명령에 의해 무시됩니다 . 대신, 파일은 C 컴파일러 또는 어셈블러 ( &lt;code&gt;cobc&lt;/code&gt; 에 의해 자동으로 실행 됨 )로 직접 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="1c8d44cbafac2dce468ebeca5512dabab659262d" translate="yes" xml:space="preserve">
          <source>compilation of that file will be bypassed by the&lt;code&gt;cobc&lt;/code&gt;command; instead, the file will be passed directly to the C compiler or assembler (executed automatically by&lt;code&gt;cobc&lt;/code&gt;.</source>
          <target state="translated">해당 파일의 컴파일은 &lt;code&gt;cobc&lt;/code&gt; 명령 으로 무시됩니다 . 대신, 파일은 C 컴파일러 또는 어셈블러에 직접 전달됩니다 ( &lt;code&gt;cobc&lt;/code&gt; 에 의해 자동으로 실행 됨) .</target>
        </trans-unit>
        <trans-unit id="ee949b5ab61fa909a700ca8437c0cdb33aadd918" translate="yes" xml:space="preserve">
          <source>comprising &lt;var&gt;string&lt;/var&gt;, but rather the number of actual</source>
          <target state="translated">구성하는 &lt;var&gt;string&lt;/var&gt; , 오히려 실제</target>
        </trans-unit>
        <trans-unit id="d41597c0c2a80da2c7cd737d1070882d465efb8b" translate="yes" xml:space="preserve">
          <source>computer-name</source>
          <target state="translated">computer-name</target>
        </trans-unit>
        <trans-unit id="f224743746ddb8a1dab554e93d7b2145cd1d58de" translate="yes" xml:space="preserve">
          <source>condition exists if either event</source>
          <target state="translated">조건이 존재하는 경우</target>
        </trans-unit>
        <trans-unit id="1c7188ab4172abb6c62697f890095f0a676e3f97" translate="yes" xml:space="preserve">
          <source>condition-name-1</source>
          <target state="translated">condition-name-1</target>
        </trans-unit>
        <trans-unit id="ef1ee50bd158d6ed3c36884c33e77ef494c6396c" translate="yes" xml:space="preserve">
          <source>conditional-expression</source>
          <target state="translated">conditional-expression</target>
        </trans-unit>
        <trans-unit id="5a86dfc34df5a8f883b051eb759549ec71849023" translate="yes" xml:space="preserve">
          <source>conditional-expression-1</source>
          <target state="translated">conditional-expression-1</target>
        </trans-unit>
        <trans-unit id="45d3ac68f56243d622aa900efcd26c772a59280c" translate="yes" xml:space="preserve">
          <source>conditional-expression-n</source>
          <target state="translated">conditional-expression-n</target>
        </trans-unit>
        <trans-unit id="dfba7aade0868074c2861c98e2a9a92f3178a51b" translate="yes" xml:space="preserve">
          <source>config</source>
          <target state="translated">config</target>
        </trans-unit>
        <trans-unit id="c257f3a69e960ba0e53d47acdb6f781f96ae561a" translate="yes" xml:space="preserve">
          <source>configuration file</source>
          <target state="translated">구성 파일</target>
        </trans-unit>
        <trans-unit id="e23ea9fa92024f274edf17de5120d9997324d2b6" translate="yes" xml:space="preserve">
          <source>constant-name-1</source>
          <target state="translated">constant-name-1</target>
        </trans-unit>
        <trans-unit id="c1380af48659113969e097bf1cb2bc27425f186c" translate="yes" xml:space="preserve">
          <source>contain</source>
          <target state="translated">contain</target>
        </trans-unit>
        <trans-unit id="9c62d8e055bc5c222d8c0dc348eb143ff8ae6343" translate="yes" xml:space="preserve">
          <source>contain exact binary data fields. Because there is no character sequence that constitutes an end-of-record delimiter, the contents of record fields are irrelevant to the reading process.</source>
          <target state="translated">정확한 이진 데이터 필드를 포함합니다. 레코드 끝 구분 기호를 구성하는 문자 시퀀스가 ​​없기 때문에 레코드 필드의 내용은 읽기 프로세스와 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b9b6529f9dead616c10e5b27dcd19a05e26bca8b" translate="yes" xml:space="preserve">
          <source>contain exact binary data fields. This is possible because &amp;mdash; since there is no character sequence that constitutes an end-of-record delimiter &amp;mdash; the contents of record fields are irrelevant to the reading process.</source>
          <target state="translated">정확한 이진 데이터 필드를 포함합니다. 레코드 끝 구분 기호를 구성하는 문자 시퀀스가 ​​없기 때문에 레코드 필드의 내용이 읽기 프로세스와 관련이 없기 때문에 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c1539178999cb90cd184317da067ebbeee89c5db" translate="yes" xml:space="preserve">
          <source>contents of the source item to be copied into &lt;var&gt;identifier-3&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;identifier-3&lt;/var&gt; 에 복사 될 소스 항목의 내용 .</target>
        </trans-unit>
        <trans-unit id="25b3b540ffe91062307298e03d6b133116e04a3f" translate="yes" xml:space="preserve">
          <source>control hierarchy</source>
          <target state="translated">제어 계층</target>
        </trans-unit>
        <trans-unit id="297b7cef30711e4f96f89482acd1108c3d436888" translate="yes" xml:space="preserve">
          <source>convert-length</source>
          <target state="translated">convert-length</target>
        </trans-unit>
        <trans-unit id="f84e2e2dadd87384fb55f25886926b777e8378f1" translate="yes" xml:space="preserve">
          <source>copy</source>
          <target state="translated">copy</target>
        </trans-unit>
        <trans-unit id="2c5897f2cddfa8be0ceb1ba8fa3c3672941d7853" translate="yes" xml:space="preserve">
          <source>copybook (provided with all GnuCOBOL source distributions).</source>
          <target state="translated">카피 북 (모든 GnuCOBOL 소스 배포와 함께 제공됨).</target>
        </trans-unit>
        <trans-unit id="b7f8907a38a4804cd93d966a83a8d685bf3cc177" translate="yes" xml:space="preserve">
          <source>copybook (which is provided with all GnuCOBOL source distributions).</source>
          <target state="translated">카피 북 (모든 GnuCOBOL 소스 배포판과 함께 제공됨).</target>
        </trans-unit>
        <trans-unit id="a586b6f6d9e4ad77e99b7e44209f81f147384d32" translate="yes" xml:space="preserve">
          <source>corresponding</source>
          <target state="translated">corresponding</target>
        </trans-unit>
        <trans-unit id="e30de8fdbd3f2502c1d3f32cf7288b3caecc93ee" translate="yes" xml:space="preserve">
          <source>could</source>
          <target state="translated">could</target>
        </trans-unit>
        <trans-unit id="900b9508be71f44d3cd16145e6c11f753e0f48ef" translate="yes" xml:space="preserve">
          <source>current character pointer</source>
          <target state="translated">현재 문자 포인터</target>
        </trans-unit>
        <trans-unit id="0517dc15ace78f45267daf3f51414b59ec2cf7cb" translate="yes" xml:space="preserve">
          <source>currently</source>
          <target state="translated">currently</target>
        </trans-unit>
        <trans-unit id="4c69edc4585507050a968b8a17155991b5bc6e59" translate="yes" xml:space="preserve">
          <source>curses</source>
          <target state="translated">curses</target>
        </trans-unit>
        <trans-unit id="84f12e2f2d8f5f2ae96f442c17f5afcff6f86f1e" translate="yes" xml:space="preserve">
          <source>cursor-locn-buffer</source>
          <target state="translated">cursor-locn-buffer</target>
        </trans-unit>
        <trans-unit id="3c363836cf4e16666669a25da280a1865c2d2874" translate="yes" xml:space="preserve">
          <source>d</source>
          <target state="translated">d</target>
        </trans-unit>
        <trans-unit id="e2672e3ce1a6432042ad7551a1c96f43987698ea" translate="yes" xml:space="preserve">
          <source>da_DK, de_AT, de_CH, de_DE, de_LI, de_LU, dsb_DE, dv_MV</source>
          <target state="translated">da_DK, de_AT, de_CH, de_DE, de_LI, de_LU, dsb_DE, dv_MV</target>
        </trans-unit>
        <trans-unit id="d73f07246e62e2478353ca797783c6545d88c2d8" translate="yes" xml:space="preserve">
          <source>data has been entered into the field. Function keys will still be allowed to terminate the &lt;code&gt;ACCEPT&lt;/code&gt;.</source>
          <target state="translated">데이터가 필드에 입력되었습니다. 기능 키는 여전히 &lt;code&gt;ACCEPT&lt;/code&gt; 를 종료 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2682df29294579cd37979cde1e8ce10b70ef166" translate="yes" xml:space="preserve">
          <source>data has been entered into the field. Function keys will still be allowed to terminate the&lt;code&gt;ACCEPT&lt;/code&gt;</source>
          <target state="translated">데이터가 필드에 입력되었습니다. 기능 키는 여전히 &lt;code&gt;ACCEPT&lt;/code&gt; 를 종료 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f7a7f78f73f3ad64b6531ad23828c3b5cc1707e7" translate="yes" xml:space="preserve">
          <source>data item, which can no longer be used in calculations or subscripts.</source>
          <target state="translated">더 이상 계산 또는 아래 첨자에 사용할 수없는 데이터 항목.</target>
        </trans-unit>
        <trans-unit id="90bbe949e88140cd30a94193e0f4e20c1a82c010" translate="yes" xml:space="preserve">
          <source>data items with &lt;code&gt;OCCURS&lt;/code&gt; clauses.</source>
          <target state="translated">&lt;code&gt;OCCURS&lt;/code&gt; 절이있는 데이터 항목 .</target>
        </trans-unit>
        <trans-unit id="a91167500c594bafd47b06f9a4ed1e12b292c9c0" translate="yes" xml:space="preserve">
          <source>data items with&lt;code&gt;OCCURS&lt;/code&gt;clauses.</source>
          <target state="translated">&lt;code&gt;OCCURS&lt;/code&gt; 절이있는 데이터 항목</target>
        </trans-unit>
        <trans-unit id="c1979d332f0d4265a9660ff50d55b8010fbaa636" translate="yes" xml:space="preserve">
          <source>data-item</source>
          <target state="translated">data-item</target>
        </trans-unit>
        <trans-unit id="82af73cdcddd95abf635f91d39cd40ecb7a0fd4d" translate="yes" xml:space="preserve">
          <source>data-item-1</source>
          <target state="translated">data-item-1</target>
        </trans-unit>
        <trans-unit id="8df1978c5a66677984c580c0c50109d84c490108" translate="yes" xml:space="preserve">
          <source>data-item-2</source>
          <target state="translated">data-item-2</target>
        </trans-unit>
        <trans-unit id="e927d0677c77241b707442314346326278051dd6" translate="yes" xml:space="preserve">
          <source>date</source>
          <target state="translated">date</target>
        </trans-unit>
        <trans-unit id="5548ae4f34cbb6e30414532924e2088d915b460f" translate="yes" xml:space="preserve">
          <source>days</source>
          <target state="translated">days</target>
        </trans-unit>
        <trans-unit id="681214568b146f593ec76176beaffef1946b6459" translate="yes" xml:space="preserve">
          <source>debug flag is specified.</source>
          <target state="translated">디버그 플래그가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="782543c51caa24ef638b37ad436e82c446f910f0" translate="yes" xml:space="preserve">
          <source>decimal points in their picture clauses. They actually don&amp;rsquo;t, because the last character of every data item definition is always a period &amp;mdash; the period that ends the definition.</source>
          <target state="translated">그림 절의 소수점. 모든 데이터 항목 정의의 마지막 문자는 항상 마침표 (정의를 끝내는 마침표)이기 때문에 실제로는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54ede94cd019301ebee1585410f32144060a1066" translate="yes" xml:space="preserve">
          <source>default is one (1)</source>
          <target state="translated">기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="4a2c6386f5532fcc2000785cfa6683a0e1d51ebe" translate="yes" xml:space="preserve">
          <source>defined in the &lt;code&gt;SCREEN SECTION&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;SCREEN SECTION&lt;/code&gt; 에 정의 된 :</target>
        </trans-unit>
        <trans-unit id="090d6cc90a32a19a738eb06290adb96cc6b806ff" translate="yes" xml:space="preserve">
          <source>defined in the&lt;code&gt;SCREEN SECTION&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SCREEN SECTION&lt;/code&gt; 정의</target>
        </trans-unit>
        <trans-unit id="458af8cd52c66c0fcc964c0c890514e881f3c4c3" translate="yes" xml:space="preserve">
          <source>definitely</source>
          <target state="translated">definitely</target>
        </trans-unit>
        <trans-unit id="5fcda2cef93277fdd9cc34162e03f4bdb426c3b8" translate="yes" xml:space="preserve">
          <source>delineate argument strings.</source>
          <target state="translated">인수 문자열을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e9a7ff1e7aa665f2dad18a85bf1bc478a370daf7" translate="yes" xml:space="preserve">
          <source>denotes a space):</source>
          <target state="translated">공백을 나타냄) :</target>
        </trans-unit>
        <trans-unit id="d911c6b3e4180f05850a2b50e12b0f3cc050a527" translate="yes" xml:space="preserve">
          <source>destination field</source>
          <target state="translated">대상 필드</target>
        </trans-unit>
        <trans-unit id="7733da1c8899a87c0260881bbabb171d30b1bab8" translate="yes" xml:space="preserve">
          <source>detail report</source>
          <target state="translated">상세 보고서</target>
        </trans-unit>
        <trans-unit id="48aa062640a717893157ec5f11d69ac5f2bbaffa" translate="yes" xml:space="preserve">
          <source>determined according to the IBM scheme.</source>
          <target state="translated">IBM 계획에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="ebd2df6b79c966e0e9938d3484c93e09a98f2a02" translate="yes" xml:space="preserve">
          <source>device-name-1</source>
          <target state="translated">device-name-1</target>
        </trans-unit>
        <trans-unit id="517d5a7240861ec297fa07542a7bf7470bb604fe" translate="yes" xml:space="preserve">
          <source>different</source>
          <target state="translated">different</target>
        </trans-unit>
        <trans-unit id="a0e58fb35f5a9356596c6ee7b6d9ddcf051e69c5" translate="yes" xml:space="preserve">
          <source>difficult, however, is coming up with a scheme for per-statement mark up of changes that doesn&amp;rsquo;t introduce a ridiculously excessive number of source lines to the program. I&amp;rsquo;m not sure there is a good answer to this problem (if a reader has one, please let me know). Generally, I&amp;rsquo;ve noticed that shops using free-format conventions for their COBOL source tend to stick with just the top-of-program comment block combined with minimal comment blocks sprinkled throughout the program noting areas that underwent major changes.</source>
          <target state="translated">그러나 프로그램에 엄청나게 과도한 수의 소스 라인을 도입하지 않는 변경 사항의 문별 마크 업 계획을 세우는 것이 어렵습니다. 이 문제에 대한 좋은 대답이 있는지 잘 모르겠습니다 (독자가있는 경우 알려주십시오). 일반적으로 COBOL 소스에 자유 형식 규칙을 사용하는 상점은 주요 변경 사항이 발생한 영역을 표시하는 프로그램 전체에 뿌려진 최소한의 주석 블록과 결합 된 프로그램 상단 주석 블록만을 고수하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a60df0fd4e35ca5b91140235dbf7ac24dec5d07" translate="yes" xml:space="preserve">
          <source>dir-path</source>
          <target state="translated">dir-path</target>
        </trans-unit>
        <trans-unit id="8b5c9329857ef4df7bc7c7f7e95120a69e0ff213" translate="yes" xml:space="preserve">
          <source>directory of the compiler sources and the file</source>
          <target state="translated">컴파일러 소스 및 파일의 디렉토리</target>
        </trans-unit>
        <trans-unit id="eadcd9bd2a09c75aef04954e6799e50278ee124a" translate="yes" xml:space="preserve">
          <source>do</source>
          <target state="translated">do</target>
        </trans-unit>
        <trans-unit id="f7f029ecb98abe979074a3ab45b74dbd9af02d42" translate="yes" xml:space="preserve">
          <source>doc</source>
          <target state="translated">doc</target>
        </trans-unit>
        <trans-unit id="7d7f449eb2f252a814e9ed9b0f19b3e2dbb411e8" translate="yes" xml:space="preserve">
          <source>document (see &lt;a href=&quot;https://gnucobol.sourceforge.io/HTML/gnucobsp.html#Top&quot;&gt;Top&lt;/a&gt; in</source>
          <target state="translated">문서 ( &lt;a href=&quot;https://gnucobol.sourceforge.io/HTML/gnucobsp.html#Top&quot;&gt;Top&lt;/a&gt; in</target>
        </trans-unit>
        <trans-unit id="ba2a1650a795afc041726acf1824670ed22f1154" translate="yes" xml:space="preserve">
          <source>documentation</source>
          <target state="translated">documentation</target>
        </trans-unit>
        <trans-unit id="f0d521a5dc37493901c869e3f3753ee3ac06b9c0" translate="yes" xml:space="preserve">
          <source>does</source>
          <target state="translated">does</target>
        </trans-unit>
        <trans-unit id="bdb36bb22deb169275b3094ba9005a29eeddd195" translate="yes" xml:space="preserve">
          <source>double</source>
          <target state="translated">double</target>
        </trans-unit>
        <trans-unit id="58e6b3a414a1e090dfc6029add0f3555ccba127f" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">e</target>
        </trans-unit>
        <trans-unit id="7f53a68d324346fc8457a1665141697dcc97ee86" translate="yes" xml:space="preserve">
          <source>e.g.</source>
          <target state="translated">e.g.</target>
        </trans-unit>
        <trans-unit id="b32f279e548b6fceef4343170778273bfe60658c" translate="yes" xml:space="preserve">
          <source>each</source>
          <target state="translated">each</target>
        </trans-unit>
        <trans-unit id="a22fca6c3065d5684c7f16ed40b8c3b877a68a24" translate="yes" xml:space="preserve">
          <source>edited</source>
          <target state="translated">edited</target>
        </trans-unit>
        <trans-unit id="120d2922d41c49c93ebfce3fbeb16a6a5cca7bc9" translate="yes" xml:space="preserve">
          <source>el_GR, en_029, en_AU, en_BZ, en_CA, en_GB, en_IE, en_IN, en_JM, en_MY en_NZ, en_PH, en_SG, en_TT, en_US, en_ZA, en_ZW, es_AR, es_BO, es_CL, es_CO, es_CR, es_DO, es_EC, es_ES, es_GT, es_HN, es_MX, es_NI, es_PA, es_PE, es_PR, es_PY, es_SV, es_US, es_UY es_VE, et_EE, eu_ES</source>
          <target state="translated">el_GR, en_029, en_AU, en_BZ, en_CA, en_GB, en_IE, en_IN, en_JM, en_MY en_NZ, en_PH, en_SG, en_TT, en_US, en_ZA, en_ZW, es_AR, es_BO, es_CL, es_CO, es_CR, es_DO, es_DO, , es_HN, es_MX, es_NI, es_PA, es_PE, es_PR, es_PY, es_SV, es_US, es_UY es_VE, et_EE, eu_ES</target>
        </trans-unit>
        <trans-unit id="85d3fa8f98826a9d81d0666f93ca02cbb9e1d4de" translate="yes" xml:space="preserve">
          <source>enables all intrinsic functions to be specified without the use of the &lt;code&gt;FUNCTION&lt;/code&gt; keyword,</source>
          <target state="translated">&lt;code&gt;FUNCTION&lt;/code&gt; 키워드를 사용하지 않고도 모든 내장 함수를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90550dfb5d11bdcf85dd523cf89904679fc7a7d8" translate="yes" xml:space="preserve">
          <source>enforced in GnuCOBOL.</source>
          <target state="translated">GnuCOBOL에서 시행됩니다.</target>
        </trans-unit>
        <trans-unit id="747761a820ea0860b14fc6679787e58916623a88" translate="yes" xml:space="preserve">
          <source>entire</source>
          <target state="translated">entire</target>
        </trans-unit>
        <trans-unit id="2bac323b7fb86c3dd77aa6b8986e10783b2cd4b0" translate="yes" xml:space="preserve">
          <source>entries, a binary search will need a worst-case of log2(</source>
          <target state="translated">이진 검색은 최악의 경우 log2 (</target>
        </trans-unit>
        <trans-unit id="7cb92eceb47d53da33a5f1e02fcc1fcd68a077f2" translate="yes" xml:space="preserve">
          <source>entries, a sequential search will need an average of</source>
          <target state="translated">항목, 순차 검색에는 평균</target>
        </trans-unit>
        <trans-unit id="04b8c80bb78edbc4f2742dedfab5f5bddf895cd1" translate="yes" xml:space="preserve">
          <source>even</source>
          <target state="translated">even</target>
        </trans-unit>
        <trans-unit id="644588b073b3c51e8781a7cc23f3fa1cf09ad9a9" translate="yes" xml:space="preserve">
          <source>evolutionary</source>
          <target state="translated">evolutionary</target>
        </trans-unit>
        <trans-unit id="fa361dc6994cb4f44130d42a561627e721bc4af8" translate="yes" xml:space="preserve">
          <source>exactly</source>
          <target state="translated">exactly</target>
        </trans-unit>
        <trans-unit id="8d71b59a2b5645c1add1e4ac70b4e4be130f6634" translate="yes" xml:space="preserve">
          <source>exactly matches, including the usage of upper- and lower-case letters, the primary entry-point name (&lt;code&gt;PROGRAM-ID&lt;/code&gt; or &lt;code&gt;FUNCTION-ID&lt;/code&gt;) or an alternate entry point name defined via the &lt;code&gt;ENTRY&lt;/code&gt; statement (see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;) of any one of the GnuCOBOL programs included in that module.</source>
          <target state="translated">대문자 및 소문자 사용, 기본 진입 점 이름 ( &lt;code&gt;PROGRAM-ID&lt;/code&gt; 또는 &lt;code&gt;FUNCTION-ID&lt;/code&gt; ) 또는 다음 중 하나의 &lt;code&gt;ENTRY&lt;/code&gt; 문 ( &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt; 참조 )을 통해 정의 된 대체 진입 점 이름을 포함하여 정확히 일치 합니다. 해당 모듈에 포함 된 GnuCOBOL 프로그램.</target>
        </trans-unit>
        <trans-unit id="28250c910f8a1df05447e14189aca065edd114d8" translate="yes" xml:space="preserve">
          <source>exceeds</source>
          <target state="translated">exceeds</target>
        </trans-unit>
        <trans-unit id="672fccd70b672edfe12c4b12cbbdf7da010ad355" translate="yes" xml:space="preserve">
          <source>except</source>
          <target state="translated">except</target>
        </trans-unit>
        <trans-unit id="2935217b8f0d832c64304c27e48cf1504494e46e" translate="yes" xml:space="preserve">
          <source>exclusive or</source>
          <target state="translated">독점 또는</target>
        </trans-unit>
        <trans-unit id="720b1bf2781c1a57c5f455ce124d1f01a42399a8" translate="yes" xml:space="preserve">
          <source>executing an &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; statement or &lt;code&gt;EXIT SECTION&lt;/code&gt; statement when there is only one paragraph (or section) in the perform scope ( this option only applies to a procedural &lt;code&gt;PERFORM&lt;/code&gt;)</source>
          <target state="translated">실행 &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; 문 또는 &lt;code&gt;EXIT SECTION&lt;/code&gt; 하나의 단락 (또는 부분)가이 범위를 수행 (이 옵션은 절차 적 적용에있을 때 문 &lt;code&gt;PERFORM&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="018686d3ef908e31091dc3eb0645c2a294ba1c1c" translate="yes" xml:space="preserve">
          <source>executing an &lt;code&gt;EXIT PERFORM CYCLE&lt;/code&gt; statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;EXIT PERFORM CYCLE&lt;/code&gt; 문 실행 ( &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="1e214745988827864e768979d9a107575a2772a7" translate="yes" xml:space="preserve">
          <source>execution</source>
          <target state="translated">execution</target>
        </trans-unit>
        <trans-unit id="03f91d55ee67a7ad2b3a6140a2b8050acca1ab9d" translate="yes" xml:space="preserve">
          <source>execution of &lt;code&gt;RANDOM&lt;/code&gt; in your program lacks a &lt;var&gt;seed&lt;/var&gt; argument, the result will be exactly as if that execution were coded with a &lt;var&gt;seed&lt;/var&gt; argument value of 1.</source>
          <target state="translated">프로그램에서 &lt;code&gt;RANDOM&lt;/code&gt; 을 실행 하면 &lt;var&gt;seed&lt;/var&gt; 인수가 없는 경우 결과는 해당 실행이 &lt;var&gt;seed&lt;/var&gt; 인수 값 1 로 코딩 된 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8f58cb7f2d45f91da77ac9d8b15ce5d5f8bdc76f" translate="yes" xml:space="preserve">
          <source>execution of&lt;code&gt;RANDOM&lt;/code&gt;in your program lacks a &amp;lt;</source>
          <target state="translated">프로그램에서 &lt;code&gt;RANDOM&lt;/code&gt; 을 실행 하면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="de3ac21778e51de199438300e1a9f816c618d33a" translate="yes" xml:space="preserve">
          <source>exit</source>
          <target state="translated">exit</target>
        </trans-unit>
        <trans-unit id="02bfbca7c50eea6ef860280445622b05fdfded8f" translate="yes" xml:space="preserve">
          <source>exit status</source>
          <target state="translated">종료 상태</target>
        </trans-unit>
        <trans-unit id="3a85e310858fac24740203d4b8282ad28b2b2ac2" translate="yes" xml:space="preserve">
          <source>expense</source>
          <target state="translated">expense</target>
        </trans-unit>
        <trans-unit id="5c67f5de5ad488d73e422b27497baec8997e1104" translate="yes" xml:space="preserve">
          <source>expression-1</source>
          <target state="translated">expression-1</target>
        </trans-unit>
        <trans-unit id="6bfdb17c43cfe8c25d85a10ece72c84ddb434c28" translate="yes" xml:space="preserve">
          <source>extension on the program name. The</source>
          <target state="translated">프로그램 이름의 확장자. 그만큼</target>
        </trans-unit>
        <trans-unit id="1d74f5ff81953122b3b3ac32ccc5f077ce56777e" translate="yes" xml:space="preserve">
          <source>fa_IR, fi_FI, fil_PH, fo_FO, fr_BE, fr_CA, fr_CH, fr_FR, fr_LU, fr_MC, fy_NL</source>
          <target state="translated">fa_IR, fi_FI, fil_PH, fo_FO, fr_BE, fr_CA, fr_CH, fr_FR, fr_LU, fr_MC, fy_NL</target>
        </trans-unit>
        <trans-unit id="0afde56699db99c43c6254d81ccc16fbb7096ad3" translate="yes" xml:space="preserve">
          <source>fast</source>
          <target state="translated">fast</target>
        </trans-unit>
        <trans-unit id="c100526d650dc4bdace3a7042b3845cb88ed5a4b" translate="yes" xml:space="preserve">
          <source>faster than performing a sequential &lt;code&gt;SEARCH&lt;/code&gt; of a table, especially if the table contains a large number of entries.</source>
          <target state="translated">특히 테이블에 많은 수의 항목이 포함 된 경우 테이블 의 순차 &lt;code&gt;SEARCH&lt;/code&gt; 을 수행하는 것보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="078cdc5e24f16f0fa98419d87311a47ccfd8f33d" translate="yes" xml:space="preserve">
          <source>field list</source>
          <target state="translated">필드리스트</target>
        </trans-unit>
        <trans-unit id="31e0c64ee0de7484fd0c3c934086693f3363e121" translate="yes" xml:space="preserve">
          <source>file (found in the</source>
          <target state="translated">파일 (</target>
        </trans-unit>
        <trans-unit id="af776ee20b72f2d741033ec06a94e68f4d0e672d" translate="yes" xml:space="preserve">
          <source>file is named.</source>
          <target state="translated">파일 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="a19e4011b725986f5c5f356f9d0efa5273dbf84f" translate="yes" xml:space="preserve">
          <source>file when the</source>
          <target state="translated">파일 때</target>
        </trans-unit>
        <trans-unit id="610d5740cca3d5dc8a1c5803668922a81f3f89fd" translate="yes" xml:space="preserve">
          <source>file-handle</source>
          <target state="translated">file-handle</target>
        </trans-unit>
        <trans-unit id="cdef4f783f2a73e3396664124161bcd7640efa9e" translate="yes" xml:space="preserve">
          <source>file-info</source>
          <target state="translated">file-info</target>
        </trans-unit>
        <trans-unit id="402826864b88e53c9e8819c84191512e637a9f2c" translate="yes" xml:space="preserve">
          <source>file-name-1</source>
          <target state="translated">file-name-1</target>
        </trans-unit>
        <trans-unit id="aa80f54f3221afeb97150f16e0214de20dc115ff" translate="yes" xml:space="preserve">
          <source>file-name-2</source>
          <target state="translated">file-name-2</target>
        </trans-unit>
        <trans-unit id="228f0ffa33e96512091505ed4ee0488ccaef5821" translate="yes" xml:space="preserve">
          <source>file-name-3</source>
          <target state="translated">file-name-3</target>
        </trans-unit>
        <trans-unit id="add9146ac2ae9febab7d2d73acf47890527b93c3" translate="yes" xml:space="preserve">
          <source>file-path</source>
          <target state="translated">file-path</target>
        </trans-unit>
        <trans-unit id="e1ae90fc2f86d79825a96562add0919aed98dd02" translate="yes" xml:space="preserve">
          <source>file.</source>
          <target state="translated">file.</target>
        </trans-unit>
        <trans-unit id="e472fc646952774190ecbead2485102da6c3f30c" translate="yes" xml:space="preserve">
          <source>file. On Unix systems, this will be a file with no specific extension, but with execute permissions. This file will include the main program as well as any static-linked subprograms.</source>
          <target state="translated">파일. Unix 시스템에서는 특정 확장자가 없지만 실행 권한이있는 파일입니다. 이 파일에는 주 프로그램과 정적 연결 하위 프로그램이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3a188f107890a9d3d4e388128a78525d21b50637" translate="yes" xml:space="preserve">
          <source>files (OSX uses</source>
          <target state="translated">파일 (OSX는</target>
        </trans-unit>
        <trans-unit id="39cc06e4acbfe2053f44a2d2262d8c477a383856" translate="yes" xml:space="preserve">
          <source>files are kept.</source>
          <target state="translated">파일이 보관됩니다.</target>
        </trans-unit>
        <trans-unit id="29de5a8f399d19ee13ccb27f58983d52dbcc25e2" translate="yes" xml:space="preserve">
          <source>files whereas on UNIX systems they will have no specific extensions. The compiler&amp;rsquo;s</source>
          <target state="translated">UNIX 시스템에서는 특정 확장자가 없습니다. 컴파일러의</target>
        </trans-unit>
        <trans-unit id="69a54dadb2f52a6c070617d3012e0bc6da9a414f" translate="yes" xml:space="preserve">
          <source>files, while on Unix systems they are typically</source>
          <target state="translated">파일, Unix 시스템에서는 일반적으로</target>
        </trans-unit>
        <trans-unit id="d594c2cc0a53025004791399d80e20852af4c988" translate="yes" xml:space="preserve">
          <source>final</source>
          <target state="translated">final</target>
        </trans-unit>
        <trans-unit id="e0996a37c13d44c3b06074939d43fa3759bd32c1" translate="yes" xml:space="preserve">
          <source>first</source>
          <target state="translated">first</target>
        </trans-unit>
        <trans-unit id="8589f27d6afbebf620ca6e80591a8871d0156852" translate="yes" xml:space="preserve">
          <source>first-execution rule</source>
          <target state="translated">첫 번째 실행 규칙</target>
        </trans-unit>
        <trans-unit id="e5772a62ee1f1c75d8b8fe7a2f30b815a556f705" translate="yes" xml:space="preserve">
          <source>fit on the report page being currently generated, the report group will be</source>
          <target state="translated">현재 생성중인 보고서 페이지에 맞으면 보고서 그룹이</target>
        </trans-unit>
        <trans-unit id="112f3a99b283a4e1788dedd8e0e5d35375c33747" translate="yes" xml:space="preserve">
          <source>flag</source>
          <target state="translated">flag</target>
        </trans-unit>
        <trans-unit id="685e80366130387cb75c055248326976d16fdf8d" translate="yes" xml:space="preserve">
          <source>float</source>
          <target state="translated">float</target>
        </trans-unit>
        <trans-unit id="2db90ad54b4a54a2a32c1bae87a0fac6b7a109df" translate="yes" xml:space="preserve">
          <source>folder specified on the COB_COPY_DIR environment variable.</source>
          <target state="translated">COB_COPY_DIR 환경 변수에 지정된 폴더.</target>
        </trans-unit>
        <trans-unit id="201e6a571e2c4f6bd032d948f7bc3c5e0b82738c" translate="yes" xml:space="preserve">
          <source>folder) as well as the last shown &lt;code&gt;#if MAX_CALL_FIELD_PARAMS&lt;/code&gt; statement before you run &lt;code&gt;make&lt;/code&gt; to build the compiler and run-time library.</source>
          <target state="translated">폴더)뿐만 아니라 컴파일러 및 런타임 라이브러리를 빌드하기 위해 &lt;code&gt;make&lt;/code&gt; 를 실행하기 전에 마지막으로 표시된 &lt;code&gt;#if MAX_CALL_FIELD_PARAMS&lt;/code&gt; 문 .</target>
        </trans-unit>
        <trans-unit id="8540abcfa75b00672715f592e3daa2d3a8a3f6df" translate="yes" xml:space="preserve">
          <source>for each individual compilation unit</source>
          <target state="translated">각 개별 편집 단위</target>
        </trans-unit>
        <trans-unit id="54e98d45ac70c3f4b57ae9fdd4d74b044b3e8b7f" translate="yes" xml:space="preserve">
          <source>forced</source>
          <target state="translated">forced</target>
        </trans-unit>
        <trans-unit id="e97bb4d8bfb26be2a304929eaac7deda3ee30b11" translate="yes" xml:space="preserve">
          <source>form of binary storage across computer systems.</source>
          <target state="translated">컴퓨터 시스템에 걸친 바이너리 스토리지의 형태.</target>
        </trans-unit>
        <trans-unit id="3dbe96a0f3c200a72682473a6e49385220e3c7bf" translate="yes" xml:space="preserve">
          <source>form-feed the printer when the report is printed. As long as any printer you plan on using supports at least as many physical print lines as what is defined as the &lt;code&gt;PAGE LIMIT&lt;/code&gt; value in whatever paper orientation and font you plan on (or are limited to) printing in, you have now divorced your program from the physical realities of the printer!</source>
          <target state="translated">보고서가 인쇄 될 때 프린터에 용지를 공급합니다. 사용하려는 프린터가 인쇄 할 용지 방향 및 글꼴에 관계없이 &lt;code&gt;PAGE LIMIT&lt;/code&gt; 값 으로 정의 된만큼의 실제 인쇄 라인을 지원하는 한 (또는 이에 제한되는) 이제 프로그램과 이혼 한 것입니다. 프린터의 물리적 현실에서!</target>
        </trans-unit>
        <trans-unit id="ac0145cef797b732f1ae24da018faf97c04ea4c7" translate="yes" xml:space="preserve">
          <source>form-feed the printer when the report is printed. As long as any printer you plan on using supports at least as many physical print lines as what is defined as the&lt;code&gt;PAGE LIMIT&lt;/code&gt;value in whatever paper orientation and font you plan on (or are limited to) printing in, you have now divorced your program from the physical realities of the printer!</source>
          <target state="translated">보고서가 인쇄 될 때 프린터에 용지를 공급합니다. 사용하려는 프린터가 인쇄 하려는 용지 방향 및 글꼴에서 &lt;code&gt;PAGE LIMIT&lt;/code&gt; 값 으로 정의 된 것보다 많은 물리적 인쇄 라인을 지원하는 한, 이제 프로그램을 이혼했습니다. 프린터의 실제 현실에서!</target>
        </trans-unit>
        <trans-unit id="faf930434155f8dd7dfa52b0063df281b5f3d4cc" translate="yes" xml:space="preserve">
          <source>form.</source>
          <target state="translated">form.</target>
        </trans-unit>
        <trans-unit id="785987648f85190cfde9eadc69fc7c46fe8a7433" translate="yes" xml:space="preserve">
          <source>format</source>
          <target state="translated">format</target>
        </trans-unit>
        <trans-unit id="e954fb707078afb77fb27c7e241bd290ce96b106" translate="yes" xml:space="preserve">
          <source>format are synonymous.</source>
          <target state="translated">형식은 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="bbdc86c621e3f6c5df736bcfa2bbcfbb045095f7" translate="yes" xml:space="preserve">
          <source>format of the &lt;code&gt;READ&lt;/code&gt; statement that is available.</source>
          <target state="translated">사용 가능한 &lt;code&gt;READ&lt;/code&gt; 문의 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="a38e7493ce48eebce728d03d0d79ecc6bedd8c08" translate="yes" xml:space="preserve">
          <source>format of the&lt;code&gt;READ&lt;/code&gt;statement that is available.</source>
          <target state="translated">사용 가능한 &lt;code&gt;READ&lt;/code&gt; 문의 형식</target>
        </trans-unit>
        <trans-unit id="670e9012dfa0af70e6adb7a484c74995510887e7" translate="yes" xml:space="preserve">
          <source>format, respectively. The former allows for up to 16 digits of exact precision while the latter offers 34. The phrase &amp;ldquo;exact precision&amp;rdquo; is used because the traditional binary renderings of decimal real numbers in a floating-point format (&lt;code&gt;FLOAT-LONG&lt;/code&gt; and &lt;code&gt;FLOAT-SHORT&lt;/code&gt;, for example) only yield an approximation of the actual value because many decimal fractions cannot be precisely rendered in binary. The Decimal64 and Decimal128 renderings, however, render decimal real numbers in encoded decimal form in much the same way that &lt;code&gt;PACKED-DECIMAL&lt;/code&gt; renders a decimal integer in digit-by-digit decimal form. The exact manner in which this rendering is performed is complex (Wikipedia has an excellent article on the subject &amp;mdash; just search for</source>
          <target state="translated">형식입니다. 전자는 최대 16 자리의 정확한 정밀도를 허용하고 후자는 34를 제공합니다. &quot;정확한 정밀도&quot;라는 문구는 부동 소수점 형식 ( &lt;code&gt;FLOAT-LONG&lt;/code&gt; 및 &lt;code&gt;FLOAT-SHORT&lt;/code&gt; , 예) 많은 소수가 이진수로 정확하게 렌더링 될 수 없기 때문에 실제 값의 근사값 만 산출합니다. 그러나 Decimal64 및 Decimal128 렌더링은 &lt;code&gt;PACKED-DECIMAL&lt;/code&gt; 이 십진 정수를 자릿수 십진수 형식으로 렌더링하는 것과 거의 동일한 방식으로 인코딩 된 십진수 형식으로 십진수 실수를 렌더링합니다. 이 렌더링이 수행되는 정확한 방식은 복잡합니다 (Wikipedia에는 ​​주제에 대한 훌륭한 기사가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c43f555ae48ba83a1b621f833f35e7822c3008d8" translate="yes" xml:space="preserve">
          <source>formats, respectively. These are binary encodings of real decimal numbers, and as such cannot represent every possible value between the minimum and maximum values in the range for those usages. Wikipedia has an excellent article on the Binary64 and Binary32 encoding schemes &amp;mdash; just search on</source>
          <target state="translated">형식입니다. 이는 실제 십진수의 이진 인코딩이므로 해당 사용 범위에서 최소값과 최대 값 사이의 가능한 모든 값을 나타낼 수는 없습니다. Wikipedia에는 ​​Binary64 및 Binary32 인코딩 체계에 대한 훌륭한 기사가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d22482fe72435ff97bd46837c3c438837fbd3747" translate="yes" xml:space="preserve">
          <source>found in the</source>
          <target state="translated">에서 발견</target>
        </trans-unit>
        <trans-unit id="0b1e95cfd9775191a7224d0a218ae79187e80c1d" translate="yes" xml:space="preserve">
          <source>from</source>
          <target state="translated">from</target>
        </trans-unit>
        <trans-unit id="fe399db7dfc239e45d84f5cd3410cb9f6f5c1a36" translate="yes" xml:space="preserve">
          <source>from the file&amp;rsquo;s &lt;code&gt;FD&lt;/code&gt;:</source>
          <target state="translated">파일의 &lt;code&gt;FD&lt;/code&gt; 에서 :</target>
        </trans-unit>
        <trans-unit id="e1a6c03dfc6b6ca5efd873e9790afcbbc546d8c7" translate="yes" xml:space="preserve">
          <source>from the file&amp;rsquo;s&lt;code&gt;FD&lt;/code&gt;</source>
          <target state="translated">파일의 &lt;code&gt;FD&lt;/code&gt; 에서</target>
        </trans-unit>
        <trans-unit id="cc545ae12a78e3b7d0b7c0c3183b6fc9932272c3" translate="yes" xml:space="preserve">
          <source>from-n</source>
          <target state="translated">from-n</target>
        </trans-unit>
        <trans-unit id="c218e39efa2e1aae69f39d2054528369ce1e1f46" translate="yes" xml:space="preserve">
          <source>function</source>
          <target state="translated">function</target>
        </trans-unit>
        <trans-unit id="1dcf1bf6437e1ecb2b2ed377936a3e31dc030c98" translate="yes" xml:space="preserve">
          <source>function-code</source>
          <target state="translated">function-code</target>
        </trans-unit>
        <trans-unit id="5c95b841a8c31fc92fb4ebf32d39fadb342a1a9c" translate="yes" xml:space="preserve">
          <source>function-prototype-name-1</source>
          <target state="translated">function-prototype-name-1</target>
        </trans-unit>
        <trans-unit id="16b36791517907892e73c0edd5ee6e89eb57110f" translate="yes" xml:space="preserve">
          <source>function-reference-1</source>
          <target state="translated">function-reference-1</target>
        </trans-unit>
        <trans-unit id="8af904e6eb6589d42306b2e39375aa6e10ddd19c" translate="yes" xml:space="preserve">
          <source>ga_IE, gbz_AF, gl_ES, gsw_FR, gu_IN</source>
          <target state="translated">ga_IE, gbz_AF, gl_ES, gsw_FR, gu_IN</target>
        </trans-unit>
        <trans-unit id="23ed3e42e59e398f00a6d981cdce63c3ef659eef" translate="yes" xml:space="preserve">
          <source>giving address of &lt;code&gt;errno&lt;/code&gt; in pointer to &lt;code&gt;binary-long&lt;/code&gt;, use &lt;code&gt;based&lt;/code&gt; for more</source>
          <target state="translated">&lt;code&gt;binary-long&lt;/code&gt; 에 대한 포인터 에 &lt;code&gt;errno&lt;/code&gt; 의 주소를 제공 하고 더 많은 것을 &lt;code&gt;based&lt;/code&gt; 으로 사용</target>
        </trans-unit>
        <trans-unit id="82180b93dbf1b73c155f1b79ef0538780d00c37d" translate="yes" xml:space="preserve">
          <source>gnucobol.pdf</source>
          <target state="translated">gnucobol.pdf</target>
        </trans-unit>
        <trans-unit id="577a679f233117f18eb15e67d20713a480c3f64e" translate="yes" xml:space="preserve">
          <source>group-item-1</source>
          <target state="translated">group-item-1</target>
        </trans-unit>
        <trans-unit id="1fc0c3216db67923c6e875b2b538a212ea127609" translate="yes" xml:space="preserve">
          <source>group-item-2</source>
          <target state="translated">group-item-2</target>
        </trans-unit>
        <trans-unit id="2c2655bc6cb7d5def06a2900eb8ef9c2ce7fe797" translate="yes" xml:space="preserve">
          <source>groups cannot span pages</source>
          <target state="translated">그룹은 페이지에 걸쳐있을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4dc4de69e102c80f392d678e8815167fafbb3cd8" translate="yes" xml:space="preserve">
          <source>ha_Latn_NG, he_IL, hi_IN, hr_BA, hr_HR, hu_HU, hy_AM</source>
          <target state="translated">ha_Latn_NG, he_IL, hi_IN, hr_BA, hr_HR, hu_HU, hy_AM</target>
        </trans-unit>
        <trans-unit id="a2dd7ec666aacd57fc6d0571db038b51deb9fb6e" translate="yes" xml:space="preserve">
          <source>handle</source>
          <target state="translated">handle</target>
        </trans-unit>
        <trans-unit id="ff87cea4a48b77342a2dbef29133a128abc52679" translate="yes" xml:space="preserve">
          <source>have</source>
          <target state="translated">have</target>
        </trans-unit>
        <trans-unit id="9f714ede952227daf835425d7fe09385a81cd575" translate="yes" xml:space="preserve">
          <source>have access to &lt;code&gt;fcntl&lt;/code&gt; and therefore</source>
          <target state="translated">&lt;code&gt;fcntl&lt;/code&gt; 에 액세스 할 수 있으므로</target>
        </trans-unit>
        <trans-unit id="84871dacfa3c0a2ed1724e20d15e15821fda6dc3" translate="yes" xml:space="preserve">
          <source>have an &lt;code&gt;OCCURS&lt;/code&gt; clause (assuming rule 3a applies)</source>
          <target state="translated">이는 &lt;code&gt;OCCURS&lt;/code&gt; 절 (3A 가정 룰을 적용)</target>
        </trans-unit>
        <trans-unit id="57df2f3744644fba20a5d968635d3bfe48c791c0" translate="yes" xml:space="preserve">
          <source>have an&lt;code&gt;OCCURS&lt;/code&gt;clause (assuming rule 3a applies)</source>
          <target state="translated">이는 &lt;code&gt;OCCURS&lt;/code&gt; 절 (3A 가정 룰을 적용)</target>
        </trans-unit>
        <trans-unit id="bcba55a1db328b2ff567608993ad5d460be04560" translate="yes" xml:space="preserve">
          <source>have been defined via an &lt;code&gt;FD&lt;/code&gt; (see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;), not an &lt;code&gt;SD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SD&lt;/code&gt; 가 아닌 &lt;code&gt;FD&lt;/code&gt; ( &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File / Sort-Description&lt;/a&gt; 참조) 를 통해 정의되었습니다 .</target>
        </trans-unit>
        <trans-unit id="761b2694b65d2b39fde48322b9a0d889a60ef955" translate="yes" xml:space="preserve">
          <source>have been defined via an&lt;code&gt;FD&lt;/code&gt;(see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;), not an&lt;code&gt;SD&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;SD&lt;/code&gt; 가 아닌 &lt;code&gt;FD&lt;/code&gt; ( &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;파일 / 정렬 설명&lt;/a&gt; 참조) 를 통해 정의되었습니다</target>
        </trans-unit>
        <trans-unit id="07c4cf9b26a7dd721ee5c0e10a7f57704f8856da" translate="yes" xml:space="preserve">
          <source>head hurt.</source>
          <target state="translated">머리가 아프다.</target>
        </trans-unit>
        <trans-unit id="4f9ea5a35d4dc3e9b77b957f73f88ff2df2d1fa5" translate="yes" xml:space="preserve">
          <source>header file but also see 7.8.5.11 for more information. There is no built-in GnuCOBOL limit to how many arguments a user-defined function may be passed.</source>
          <target state="translated">헤더 파일을 참조하십시오. 자세한 내용은 7.8.5.11을 참조하십시오. 사용자 정의 함수가 전달할 수있는 인수 수에 대한 내장 GnuCOBOL 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8476a1f414faa841f749102ad2d90ce217062c3a" translate="yes" xml:space="preserve">
          <source>hhmmssnn</source>
          <target state="translated">hhmmssnn</target>
        </trans-unit>
        <trans-unit id="8d98bda19baa9a41e2325338d9b840f352a12d37" translate="yes" xml:space="preserve">
          <source>highly</source>
          <target state="translated">highly</target>
        </trans-unit>
        <trans-unit id="9d0735a57e0f7a5d955a42afc340a62fa49446d7" translate="yes" xml:space="preserve">
          <source>how long each record may be, add additional records and reprint. Continue until printing overflows to a second page.</source>
          <target state="translated">각 기록의 길이에 따라 기록을 추가하고 재 인쇄하십시오. 인쇄가 두 번째 페이지로 넘칠 때까지 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="2c3a0ef6ef4316e6e5d1c614dce6be8faad1cb40" translate="yes" xml:space="preserve">
          <source>i.e.</source>
          <target state="translated">i.e.</target>
        </trans-unit>
        <trans-unit id="f7f67fb647a86905691ae276eb823d6505dad545" translate="yes" xml:space="preserve">
          <source>id_ID, ig_NG, ii_CN, is_IS, it_CH, it_IT, iu_Cans_CA, iu_Latn_CA</source>
          <target state="translated">id_ID, ig_NG, ii_CN, is_IS, it_CH, it_IT, iu_Cans_CA, iu_Latn_CA</target>
        </trans-unit>
        <trans-unit id="fae9fd39301eb7e657d4dad32a828cda5d7399e5" translate="yes" xml:space="preserve">
          <source>identifier</source>
          <target state="translated">identifier</target>
        </trans-unit>
        <trans-unit id="ff9ef548a6e30a0462795d916f3f00d1e2b082ca" translate="yes" xml:space="preserve">
          <source>identifier-1</source>
          <target state="translated">identifier-1</target>
        </trans-unit>
        <trans-unit id="4299e8ddd819f9bde9cfacf45716724c17b5ddf7" translate="yes" xml:space="preserve">
          <source>identifier-2</source>
          <target state="translated">identifier-2</target>
        </trans-unit>
        <trans-unit id="54d8030f95bd952a5fdbf08042150efd045c5757" translate="yes" xml:space="preserve">
          <source>identifier-3</source>
          <target state="translated">identifier-3</target>
        </trans-unit>
        <trans-unit id="a8f51733a16b09b02c26d93e713eacfbd6f33acb" translate="yes" xml:space="preserve">
          <source>identifier-4</source>
          <target state="translated">identifier-4</target>
        </trans-unit>
        <trans-unit id="35b69c24481dea97ec439b3877fe487af8c3fed9" translate="yes" xml:space="preserve">
          <source>identifier-5</source>
          <target state="translated">identifier-5</target>
        </trans-unit>
        <trans-unit id="16b2129453949d508c94af10dbf524d3fde69390" translate="yes" xml:space="preserve">
          <source>identifier-6</source>
          <target state="translated">identifier-6</target>
        </trans-unit>
        <trans-unit id="4a772137f40adf1842f5bd6b1f70526822586bfb" translate="yes" xml:space="preserve">
          <source>identifier-7</source>
          <target state="translated">identifier-7</target>
        </trans-unit>
        <trans-unit id="2fb5b73dfce72d993ba2e440cbe7a630330e7436" translate="yes" xml:space="preserve">
          <source>identifier-8</source>
          <target state="translated">identifier-8</target>
        </trans-unit>
        <trans-unit id="89630820e7fead9119682cc5c69c73676b1fb288" translate="yes" xml:space="preserve">
          <source>identifier-9</source>
          <target state="translated">identifier-9</target>
        </trans-unit>
        <trans-unit id="d887d3a98103808d0553620820694932cdbecb8a" translate="yes" xml:space="preserve">
          <source>if the sign has value &lt;code&gt;X&quot;F&quot;&lt;/code&gt;.</source>
          <target state="translated">부호 값이 &lt;code&gt;X&quot;F&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a10d4d0cbbf122b7a2fae40eadaaa68b67ee991b" translate="yes" xml:space="preserve">
          <source>imperative-statement-1</source>
          <target state="translated">imperative-statement-1</target>
        </trans-unit>
        <trans-unit id="92d0ba5bd03f855a2a8bb930ed07ff61462ce5a3" translate="yes" xml:space="preserve">
          <source>imperative-statement-2</source>
          <target state="translated">imperative-statement-2</target>
        </trans-unit>
        <trans-unit id="b19f275ec20d29c93524ce9ad12c37ea45b29190" translate="yes" xml:space="preserve">
          <source>imperative-statement-n</source>
          <target state="translated">imperative-statement-n</target>
        </trans-unit>
        <trans-unit id="1b2dada4799292907e0dca408b6f4eb3ea2b486d" translate="yes" xml:space="preserve">
          <source>imperative-statement-other</source>
          <target state="translated">imperative-statement-other</target>
        </trans-unit>
        <trans-unit id="470cec587602b47395a317eb72d14272f9628412" translate="yes" xml:space="preserve">
          <source>implies</source>
          <target state="translated">implies</target>
        </trans-unit>
        <trans-unit id="8ea5b19d8359d0ceda3368180c4aadeaab15475c" translate="yes" xml:space="preserve">
          <source>improvements to programmer productivity, each of the following three events has been responsible for</source>
          <target state="translated">프로그래머 생산성 향상, 다음 세 가지 이벤트 각각이</target>
        </trans-unit>
        <trans-unit id="67617b5a9180ad92e9057c52cde11c3337e20a93" translate="yes" xml:space="preserve">
          <source>improvements:</source>
          <target state="translated">improvements:</target>
        </trans-unit>
        <trans-unit id="af10ef20dd9060bbeead0afbc55381a66af442ef" translate="yes" xml:space="preserve">
          <source>in</source>
          <target state="translated">in</target>
        </trans-unit>
        <trans-unit id="4ae6fa7da19d3c5d02bea3b9ffbec788b89ad575" translate="yes" xml:space="preserve">
          <source>in Fixed Format Mode, the &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; must begin in column 8 or beyond, provided no part of the directive extends past column 72. If the compiler is currently in Free Format Mode, the &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; may appear in any column, provided no part of the directive extends past column 255.</source>
          <target state="translated">고정 형식 모드에서 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 는 지시문의 어느 부분도 72 열을지나 확장되지 않는 경우 열 8 이상에서 시작해야합니다. 컴파일러가 현재 자유 형식 모드에있는 경우 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 는 열의 일부가 아니면 모든 열에 나타날 수 있습니다. 지시문은 열 255를지나 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="3086b509c23f67816e1a1d1d97ac0fa65d97a22b" translate="yes" xml:space="preserve">
          <source>in Fixed Format Mode, the&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;must begin in column 8 or beyond, provided no part of the directive extends past column 72. If the compiler is currently in Free Format Mode, the&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;may appear in any column, provided no part of the directive extends past column 255.</source>
          <target state="translated">고정 형식 모드에서 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 컴파일러는 무료 형식 모드에서 현재 인 경우 지침의 어떤 부분은 과거의 열 (72)을 확장하지 않습니다 제공, 열 8 이상에서 시작해야는 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 어떤 부분을 제공하지, 어떤 열에 표시 할 수 있습니다 지시문은 255 열을지나 연장됩니다.</target>
        </trans-unit>
        <trans-unit id="50dc202b596fce83e444527c302861c4b0a2316b" translate="yes" xml:space="preserve">
          <source>in the file&amp;rsquo;s &lt;code&gt;FD&lt;/code&gt;:</source>
          <target state="translated">파일의 &lt;code&gt;FD&lt;/code&gt; 에서 :</target>
        </trans-unit>
        <trans-unit id="fe0a755f8359cbd92ceadc4d4666a50511f50cae" translate="yes" xml:space="preserve">
          <source>in the file&amp;rsquo;s&lt;code&gt;FD&lt;/code&gt;</source>
          <target state="translated">파일의 &lt;code&gt;FD&lt;/code&gt; 에서</target>
        </trans-unit>
        <trans-unit id="25b9f5826bb49080dee504b9926d314dc7eb3524" translate="yes" xml:space="preserve">
          <source>in the following discussions.</source>
          <target state="translated">다음 토론에서.</target>
        </trans-unit>
        <trans-unit id="674ad124fd8077ba060909e1d56ebfb9b77671f1" translate="yes" xml:space="preserve">
          <source>in the remainder of this section, will include:</source>
          <target state="translated">이 섹션의 나머지 부분에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="18bcbd949d4382c088f0afab28112f135a66d781" translate="yes" xml:space="preserve">
          <source>in the result.</source>
          <target state="translated">결과적으로.</target>
        </trans-unit>
        <trans-unit id="fd8f3d2cabb404ce841edf65b3a71c0e063298ff" translate="yes" xml:space="preserve">
          <source>index-name-1</source>
          <target state="translated">index-name-1</target>
        </trans-unit>
        <trans-unit id="8ad7d21c71b049b7003ba31b5f1322974df77ac8" translate="yes" xml:space="preserve">
          <source>initial</source>
          <target state="translated">initial</target>
        </trans-unit>
        <trans-unit id="ff4c22c8d9adf3bc7492bb0d25582262ab268d0e" translate="yes" xml:space="preserve">
          <source>input (read-only)</source>
          <target state="translated">입력 (읽기 전용)</target>
        </trans-unit>
        <trans-unit id="dc43e8574cf0d201d1b86352a4425e06d58b90c2" translate="yes" xml:space="preserve">
          <source>input and/or output</source>
          <target state="translated">입력 및 / 또는 출력</target>
        </trans-unit>
        <trans-unit id="6174d19ad37ae52255cedcecf45fe5d15533d060" translate="yes" xml:space="preserve">
          <source>input-output exception</source>
          <target state="translated">입출력 예외</target>
        </trans-unit>
        <trans-unit id="4e3c52ffe7593eb8b18d91cc855f3f4d45780b35" translate="yes" xml:space="preserve">
          <source>inspect subject</source>
          <target state="translated">주제를 검사하다</target>
        </trans-unit>
        <trans-unit id="1a06e0fbe4a9af107ecf682db9f47f21add5c1a2" translate="yes" xml:space="preserve">
          <source>int  short  short int  signed int  signed short  signed short int</source>
          <target state="translated">int short short int signed int 서명 된 짧은 서명 된 짧은 int</target>
        </trans-unit>
        <trans-unit id="1178cafbd64bbbfa77f5ac0a9d5032ed88162781" translate="yes" xml:space="preserve">
          <source>integer</source>
          <target state="translated">integer</target>
        </trans-unit>
        <trans-unit id="0880e19f0422595cf18fea5d9a9d51f9476732ea" translate="yes" xml:space="preserve">
          <source>integer-1</source>
          <target state="translated">integer-1</target>
        </trans-unit>
        <trans-unit id="d466665e16fb91305bce8b0426267d80ee09fca8" translate="yes" xml:space="preserve">
          <source>integer-2</source>
          <target state="translated">integer-2</target>
        </trans-unit>
        <trans-unit id="3eff3cc6f22d383c685b3ec52acab1331dc78647" translate="yes" xml:space="preserve">
          <source>interest-rate</source>
          <target state="translated">interest-rate</target>
        </trans-unit>
        <trans-unit id="3f4477039e167b7a6148337a3a7179193c4ac9bd" translate="yes" xml:space="preserve">
          <source>invokes program</source>
          <target state="translated">프로그램을 호출</target>
        </trans-unit>
        <trans-unit id="0862f6ae39be324b0fc18c9fcd87571cfe4639c7" translate="yes" xml:space="preserve">
          <source>invokes subprogram</source>
          <target state="translated">하위 프로그램을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="7e0eb9c23fe73bae30a7e28fa1e9cf1d45dafefc" translate="yes" xml:space="preserve">
          <source>is a nebulous one in those environments where command-line shell sessions are invoked within a graphical user-interface environment, as will be the case on Windows, OSX and most Unix/Linux systems &amp;mdash; these environments allow command-line session windows to exist with a variable number of available screen rows and columns. When you are designing GnuCOBOL screens, you need to do so with an awareness of the logical screen row/column geometry the program will be executing within.</source>
          <target state="translated">Windows, OSX 및 대부분의 Unix / Linux 시스템 에서처럼 명령 줄 셸 세션이 그래픽 사용자 인터페이스 환경에서 호출되는 환경에서는 모호합니다. 이러한 환경에서는 명령 줄 세션 창이 사용 가능한 화면 행 및 열의 가변 개수. GnuCOBOL 화면을 디자인 할 때 프로그램이 실행될 논리 화면 행 / 열 지오메트리를 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="60d2fcbb87b18499a45b53a9589955f297c9aaf8" translate="yes" xml:space="preserve">
          <source>is known as the  &lt;em&gt;Called Program&lt;/em&gt;. GnuCOBOL programs may be a calling program, a called program or both.</source>
          <target state="translated">로 알려진됩니다 &lt;em&gt;호출 된 프로그램&lt;/em&gt; . GnuCOBOL 프로그램은 호출 프로그램, 호출 된 프로그램 또는 둘 다일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04ba37a0efab1b66029a25010fd96149606f9bf6" translate="yes" xml:space="preserve">
          <source>is less than</source>
          <target state="translated">보다 작다</target>
        </trans-unit>
        <trans-unit id="ee54d23ef9a89e00e9df77e7a8a0c5947a5d24f3" translate="yes" xml:space="preserve">
          <source>is referred to as the  &lt;em&gt;Calling Program&lt;/em&gt; while program</source>
          <target state="translated">&lt;em&gt;프로그램&lt;/em&gt; 을 &lt;em&gt;호출&lt;/em&gt; 하는 동안 &lt;em&gt;호출 프로그램&lt;/em&gt; 이라고합니다.</target>
        </trans-unit>
        <trans-unit id="82577b2a63db0207534b5e7ba5dd739d0aa31cd3" translate="yes" xml:space="preserve">
          <source>is selected. This mode is sometimes called &quot;Banker&amp;rsquo;s rounding&quot;.</source>
          <target state="translated">가 선택되었습니다. 이 모드를 &quot;뱅커의 반올림&quot;이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="9953e1bd3371e6422544ca482866f6d7ccfe684b" translate="yes" xml:space="preserve">
          <source>is selected. This mode is sometimes called &amp;ldquo;Banker&amp;rsquo;s rounding&amp;rdquo;.</source>
          <target state="translated">선택됩니다. 이 모드를 &quot;뱅커 반올림&quot;이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="02c6feed680444413ba154fd5c658a45cdffd380" translate="yes" xml:space="preserve">
          <source>is the base-2 logarithm function.</source>
          <target state="translated">밑이 2 인 로그 함수입니다.</target>
        </trans-unit>
        <trans-unit id="f548a6e755efff274b2d60149a48b4a2de937ad9" translate="yes" xml:space="preserve">
          <source>is the worst-case number of tests required to find an entry or to identify that it doesn&amp;rsquo;t exist. That&amp;rsquo;s quite an improvement!</source>
          <target state="translated">항목을 찾거나 항목이 존재하지 않음을 식별하는 데 필요한 최악의 경우 테스트 수입니다. 그것은 상당히 개선되었습니다!</target>
        </trans-unit>
        <trans-unit id="4784b644e8b7c06a0953b5cd163b94ccd64b8613" translate="yes" xml:space="preserve">
          <source>is violated, the compiler will reject the &lt;code&gt;SEARCH ALL&lt;/code&gt;. If rules</source>
          <target state="translated">위반되면 컴파일러는 &lt;code&gt;SEARCH ALL&lt;/code&gt; 을 거부합니다 . If 규칙</target>
        </trans-unit>
        <trans-unit id="589501573c5428c194e6ac87489e0ff92f24878a" translate="yes" xml:space="preserve">
          <source>it was designed to solve business problems</source>
          <target state="translated">비즈니스 문제를 해결하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="a7034905ef7a2cfdce0011aa3a00fc34eae07bb1" translate="yes" xml:space="preserve">
          <source>item has 1 byte</source>
          <target state="translated">항목에 1 바이트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fb95cc7ce628c5a211b7cf0dcd5f18910ef167f" translate="yes" xml:space="preserve">
          <source>item has 2 bytes</source>
          <target state="translated">항목에 2 바이트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b64937752a136475d4827085065723dddb4428c1" translate="yes" xml:space="preserve">
          <source>item has 4 bytes</source>
          <target state="translated">항목에 4 바이트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="56b420856c1a54a34980063faa74976c127c73bf" translate="yes" xml:space="preserve">
          <source>item has 8 bytes.</source>
          <target state="translated">항목에는 8 바이트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d6b6cf8e6806f74576ba203a91c471b5fa3d139" translate="yes" xml:space="preserve">
          <source>item-1</source>
          <target state="translated">item-1</target>
        </trans-unit>
        <trans-unit id="334df637d343c683e687dbe25c19c31e60954863" translate="yes" xml:space="preserve">
          <source>item-2</source>
          <target state="translated">item-2</target>
        </trans-unit>
        <trans-unit id="b2dccae6b4872c82f860d6e9ce9893824ac678a8" translate="yes" xml:space="preserve">
          <source>ja_JP</source>
          <target state="translated">ja_JP</target>
        </trans-unit>
        <trans-unit id="da556d2f307f11e88fb19c027c41779c23c8d3a3" translate="yes" xml:space="preserve">
          <source>ka_GE, kh_KH, kk_KZ, kl_GL, kn_IN, ko_KR, kok_IN, ky_KG</source>
          <target state="translated">ka_GE, kh_KH, kk_KZ, kl_GL, kn_IN, ko_KR, kok_IN, ky_KG</target>
        </trans-unit>
        <trans-unit id="213ed3ea453bf610688ff8041e0a3b7b6abb5e6e" translate="yes" xml:space="preserve">
          <source>last</source>
          <target state="translated">last</target>
        </trans-unit>
        <trans-unit id="47c20fed16aa6fcb3da0a146bf1113d60840b502" translate="yes" xml:space="preserve">
          <source>lb_LU, lo_LA, lt_LT, lv_LV</source>
          <target state="translated">lb_LU, lo_LA, lt_LT, lv_LV</target>
        </trans-unit>
        <trans-unit id="30ee943dd3606c7af7cfbb5617967cb82ca25748" translate="yes" xml:space="preserve">
          <source>leading and trailing spaces will be removed. The case (upper, lower or mixed) of this argument is irrelevant.</source>
          <target state="translated">선행 및 후행 공백이 제거됩니다. 이 주장의 경우 (상단, 하한 또는 혼합)는 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="196fb6899d232853e2f0750450ecff38bfa06f3c" translate="yes" xml:space="preserve">
          <source>left blank) lines at the bottom of every page. The default if this if not specified is zero.</source>
          <target state="translated">비어 있음) 모든 페이지 하단에 줄. 지정되지 않은 경우 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="a192f32231ab469c1937ba329ba865f6f1bdb32c" translate="yes" xml:space="preserve">
          <source>left blank) lines at the top of every page. The default if this if not specified is zero.</source>
          <target state="translated">비어 있음) 모든 페이지 상단에 줄. 지정되지 않은 경우 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="3d54973f528b01019a58a52d34d518405a01b891" translate="yes" xml:space="preserve">
          <source>length</source>
          <target state="translated">length</target>
        </trans-unit>
        <trans-unit id="62f93624e5657e7dba9ae41dbf769f57e7150cdc" translate="yes" xml:space="preserve">
          <source>length, consider using either the &lt;code&gt;SUBSTITUTE&lt;/code&gt; intrinsic function (see &lt;a href=&quot;#SUBSTITUTE&quot;&gt;SUBSTITUTE&lt;/a&gt;) or the &lt;code&gt;SUBSTITUTE-CASE&lt;/code&gt; intrinsic function (see &lt;a href=&quot;#SUBSTITUTE_002dCASE&quot;&gt;SUBSTITUTE-CASE&lt;/a&gt;).</source>
          <target state="translated">길이의 경우 &lt;code&gt;SUBSTITUTE&lt;/code&gt; 내장 함수 ( &lt;a href=&quot;#SUBSTITUTE&quot;&gt;SUBSTITUTE&lt;/a&gt; 참조 ) 또는 &lt;code&gt;SUBSTITUTE-CASE&lt;/code&gt; 내장 함수 ( &lt;a href=&quot;#SUBSTITUTE_002dCASE&quot;&gt;SUBSTITUTE-CASE&lt;/a&gt; 참조 )를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="36b7334d64ab3bf5006b87f513210897492d9aeb" translate="yes" xml:space="preserve">
          <source>length, consider using either the&lt;code&gt;SUBSTITUTE&lt;/code&gt;intrinsic function (see &lt;a href=&quot;#SUBSTITUTE&quot;&gt;SUBSTITUTE&lt;/a&gt;) or the&lt;code&gt;SUBSTITUTE-CASE&lt;/code&gt;intrinsic function (see &lt;a href=&quot;#SUBSTITUTE_002dCASE&quot;&gt;SUBSTITUTE-CASE&lt;/a&gt;).</source>
          <target state="translated">길이는 사용 중 고려 &lt;code&gt;SUBSTITUTE&lt;/code&gt; 내장 함수 (참조 &lt;a href=&quot;#SUBSTITUTE&quot;&gt;대용품&lt;/a&gt; ) 또는 &lt;code&gt;SUBSTITUTE-CASE&lt;/code&gt; (참조 고유 함수를 &lt;a href=&quot;#SUBSTITUTE_002dCASE&quot;&gt;대체 케이스를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ad60c535ff88e85bf0254452fe3934f24e9668d5" translate="yes" xml:space="preserve">
          <source>level</source>
          <target state="translated">level</target>
        </trans-unit>
        <trans-unit id="60af719bb03138ecfb2b6154024a0d98788ee915" translate="yes" xml:space="preserve">
          <source>libcob</source>
          <target state="translated">libcob</target>
        </trans-unit>
        <trans-unit id="763c482eb6647e679978fef150121ab5b283dc95" translate="yes" xml:space="preserve">
          <source>libcob: Cannot find module &amp;rsquo;xxxxxxxx&amp;rsquo;</source>
          <target state="translated">libcob : 'xxxxxxxx'모듈을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bad634f05e7986e4b446add7334f687200fcc30f" translate="yes" xml:space="preserve">
          <source>libraries</source>
          <target state="translated">libraries</target>
        </trans-unit>
        <trans-unit id="4e35ef6c79c937e3508918f6d81ee08f922921c1" translate="yes" xml:space="preserve">
          <source>library-name-1</source>
          <target state="translated">library-name-1</target>
        </trans-unit>
        <trans-unit id="bed545de5e28e6ce7c1a2fc1d06c3f5514425123" translate="yes" xml:space="preserve">
          <source>line command.</source>
          <target state="translated">라인 명령.</target>
        </trans-unit>
        <trans-unit id="4c295ebe9d557baf1130270941dda5964740971a" translate="yes" xml:space="preserve">
          <source>line of the group in which this clause appears.</source>
          <target state="translated">이 절이 나타나는 그룹의 줄.</target>
        </trans-unit>
        <trans-unit id="b91ec97e22039cb627485497de5939717e3b5b7d" translate="yes" xml:space="preserve">
          <source>literal-1</source>
          <target state="translated">literal-1</target>
        </trans-unit>
        <trans-unit id="0a65b805c715c90695767079697ba735dac8548d" translate="yes" xml:space="preserve">
          <source>literal-2</source>
          <target state="translated">literal-2</target>
        </trans-unit>
        <trans-unit id="5ec53893b895f76908df9f21f08a3f472729cde8" translate="yes" xml:space="preserve">
          <source>literal-3</source>
          <target state="translated">literal-3</target>
        </trans-unit>
        <trans-unit id="8f151b5686e5f22d0433c0e8cf8b66a73acf8874" translate="yes" xml:space="preserve">
          <source>literal-7</source>
          <target state="translated">literal-7</target>
        </trans-unit>
        <trans-unit id="abf5608f8d79f898fb306253d2975050ec1b130a" translate="yes" xml:space="preserve">
          <source>literal-8</source>
          <target state="translated">literal-8</target>
        </trans-unit>
        <trans-unit id="2ddac5929f220245722c86038084c6b721a15ecb" translate="yes" xml:space="preserve">
          <source>literal-n</source>
          <target state="translated">literal-n</target>
        </trans-unit>
        <trans-unit id="0e038a42cca30122c3324dfda646d3f079374dd5" translate="yes" xml:space="preserve">
          <source>locale</source>
          <target state="translated">locale</target>
        </trans-unit>
        <trans-unit id="ad5df452f8f3d434647b8422aa8ceac40006c89c" translate="yes" xml:space="preserve">
          <source>locale-name-1</source>
          <target state="translated">locale-name-1</target>
        </trans-unit>
        <trans-unit id="8272fbd4ea89b69b3ccf4f94a9578f957614acd7" translate="yes" xml:space="preserve">
          <source>log2</source>
          <target state="translated">log2</target>
        </trans-unit>
        <trans-unit id="bd3027fa569ea15ca76d84db21c67e2d514c1a5a" translate="yes" xml:space="preserve">
          <source>long</source>
          <target state="translated">long</target>
        </trans-unit>
        <trans-unit id="1171c9c4d02af61af8bf008c32cfdf108d9ddf9b" translate="yes" xml:space="preserve">
          <source>long  long int  signed long  signed long int</source>
          <target state="translated">long long int signed long 서명 된 긴 int</target>
        </trans-unit>
        <trans-unit id="b5656629587221b8239b7141684c8f69c57c8f23" translate="yes" xml:space="preserve">
          <source>long double</source>
          <target state="translated">롱 더블</target>
        </trans-unit>
        <trans-unit id="a5dba644f98b3753342c7053cd1f1cf4d33492b4" translate="yes" xml:space="preserve">
          <source>long long int  signed long long int</source>
          <target state="translated">long long int 서명 long long int</target>
        </trans-unit>
        <trans-unit id="cc4df8ae0af123bb4dc2f7f91c6a8bf88fea3d71" translate="yes" xml:space="preserve">
          <source>longer</source>
          <target state="translated">longer</target>
        </trans-unit>
        <trans-unit id="abb375e7f5e38fb231a54f1eeaa2dd8547c446f8" translate="yes" xml:space="preserve">
          <source>mainprog.cbl</source>
          <target state="translated">mainprog.cbl</target>
        </trans-unit>
        <trans-unit id="225607305b3a0bea58569f390ffdfb5e0a57a681" translate="yes" xml:space="preserve">
          <source>making up the &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="d41181040207e3c3e2ec093f2e00579ff6d86ee8" translate="yes" xml:space="preserve">
          <source>making up the &lt;var&gt;string&lt;/var&gt;, but rather the number of actual</source>
          <target state="translated">위로 만드는 &lt;var&gt;string&lt;/var&gt; 실제의 수를 오히려</target>
        </trans-unit>
        <trans-unit id="07e9b8035af557b3dfaa8d6423a3d5988e463a69" translate="yes" xml:space="preserve">
          <source>making up the string. For example, if &amp;lt;</source>
          <target state="translated">문자열을 구성합니다. 예를 들어 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="962d550fd2b83e7010fdde2065078494fc3a07d2" translate="yes" xml:space="preserve">
          <source>making up the string. For example, if &lt;var&gt;string&lt;/var&gt; is encoded using a double-byte character set such as Unicode UTF-16 (where each character is represented by 16 bits of storage, not the 8-bits inherent to character sets like &lt;small&gt;ASCII&lt;/small&gt; or &lt;small&gt;EBCDIC&lt;/small&gt;), then calling this function with a &lt;var&gt;string&lt;/var&gt; argument whose &lt;code&gt;PICTURE is X(4)&lt;/code&gt; would return a value of 4 rather than the value 8 (the actual number of bytes of storage occupied by that item).</source>
          <target state="translated">문자열을 구성합니다. 예를 들어, &lt;var&gt;string&lt;/var&gt; 이 Unicode UTF-16과 같은 2 바이트 문자 집합을 사용하여 인코딩 된 경우 (각 문자는 &lt;small&gt;ASCII&lt;/small&gt; 또는 &lt;small&gt;EBCDIC&lt;/small&gt; 같은 문자 집합에 고유 한 8 비트가 아닌 16 비트 저장소로 표시됨) 다음을 호출합니다. &lt;code&gt;PICTURE is X(4)&lt;/code&gt; 인 &lt;var&gt;string&lt;/var&gt; 인수가있는 함수 는 값 8 (해당 항목이 차지하는 실제 스토리지 바이트 수)이 아닌 값 4를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="56a227300429063dcf8f3e2a4e389ff533a4f704" translate="yes" xml:space="preserve">
          <source>marks the completion of the detailed description of the file and begins another.</source>
          <target state="translated">파일에 대한 자세한 설명의 완료를 표시하고 다른 설명을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="8da66034c13714b476e6066f8fdbf2a0b436565f" translate="yes" xml:space="preserve">
          <source>match to &lt;var&gt;data-item-2&lt;/var&gt; which is subordinate to &lt;var&gt;group-item-2&lt;/var&gt;, each of the following must be true:</source>
          <target state="translated">&lt;var&gt;group-item-2&lt;/var&gt; 에 종속 된 &lt;var&gt;data-item-2&lt;/var&gt; 와 일치하는 경우 다음 각 항목 이 참이어야합니다.</target>
        </trans-unit>
        <trans-unit id="7b515827470760ab40da37e2116bcea6cd58bd38" translate="yes" xml:space="preserve">
          <source>may be defined between the subject and object data items unless they too are &lt;code&gt;REDEFINES&lt;/code&gt; of the subject.</source>
          <target state="translated">주체를 &lt;code&gt;REDEFINES&lt;/code&gt; 하지 않는 한 주체와 객체 데이터 항목 사이에 정의 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9134ac300db64c512211b06cfb2c26384474b76" translate="yes" xml:space="preserve">
          <source>may be defined between the subject and object data items.</source>
          <target state="translated">주제와 객체 데이터 항목 사이에 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edffdb31cec74750e6c185475855eb4e7e1220cb" translate="yes" xml:space="preserve">
          <source>merge work file</source>
          <target state="translated">작업 파일 병합</target>
        </trans-unit>
        <trans-unit id="2e9240d009766bf7dcc35040c929bc9d417fbade" translate="yes" xml:space="preserve">
          <source>mi_NZ, mk_MK, ml_IN, mn_Cyrl_MN, mn_Mong_CN moh_CA, mr_IN, ms_BN, ms_MY, mt_MT</source>
          <target state="translated">mi_NZ, mk_MK, ml_IN, mn_Cyrl_MN, mn_Mong_CN moh_CA, mr_IN, ms_BN, ms_MY, mt_MT</target>
        </trans-unit>
        <trans-unit id="e8502058829cfba51a93c4e9b73a28d5bbf1c8eb" translate="yes" xml:space="preserve">
          <source>million</source>
          <target state="translated">million</target>
        </trans-unit>
        <trans-unit id="58e7f376083f586adb6b384e7c48d8210f863ec1" translate="yes" xml:space="preserve">
          <source>mm/dd/yyhh.mm.ss</source>
          <target state="translated">mm/dd/yyhh.mm.ss</target>
        </trans-unit>
        <trans-unit id="9590fc58f5377ae5b917003bb31ebe13133e932b" translate="yes" xml:space="preserve">
          <source>mnemonic-name-1</source>
          <target state="translated">mnemonic-name-1</target>
        </trans-unit>
        <trans-unit id="0f92dda0c509fe67988118bc93ddecd1e3b90c22" translate="yes" xml:space="preserve">
          <source>mnemonic-name-2</source>
          <target state="translated">mnemonic-name-2</target>
        </trans-unit>
        <trans-unit id="cfba570e97e848caaa28f6ee1d8d851fb1873c2c" translate="yes" xml:space="preserve">
          <source>mnemonic-name-3</source>
          <target state="translated">mnemonic-name-3</target>
        </trans-unit>
        <trans-unit id="4580485d482a9037af94f68af98adf23819cbdf4" translate="yes" xml:space="preserve">
          <source>modules</source>
          <target state="translated">modules</target>
        </trans-unit>
        <trans-unit id="ff051150ace8dd2dda6af3d0d8f0d5ddec3d57ed" translate="yes" xml:space="preserve">
          <source>most compatible</source>
          <target state="translated">가장 호환성이있는</target>
        </trans-unit>
        <trans-unit id="d9f683a48bf148c33acf54af538353283133c407" translate="yes" xml:space="preserve">
          <source>most efficient</source>
          <target state="translated">가장 효율적인</target>
        </trans-unit>
        <trans-unit id="b93fe7d6eecfefdca6d3ee82df4d24985d123fe5" translate="yes" xml:space="preserve">
          <source>multiple instructions, the one specified first will take priority over the one specified second, (and so forth) as the &lt;code&gt;INSPECT&lt;/code&gt; proceeds forward through the inspect subject, character-by-character.</source>
          <target state="translated">여러 명령이있는 경우, &lt;code&gt;INSPECT&lt;/code&gt; 가 문자별로 검사 대상을 통해 진행할 때 먼저 지정된 것이 지정된 초 (등)보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="4d0a9e1e89dd9419ca99d38f5cb0a00266462ce2" translate="yes" xml:space="preserve">
          <source>multiple instructions, the one specified first will take priority over the one specified second, (and so forth) as the&lt;code&gt;INSPECT&lt;/code&gt;proceeds forward through the inspect subject, character-by-character.</source>
          <target state="translated">&lt;code&gt;INSPECT&lt;/code&gt; 가 문자 단위로 검사 대상을 진행 함에 따라 여러 명령에서 첫 번째로 지정된 명령이 지정된 두 번째 명령보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="b752a34cdbf2688aea2d0b54d697c7ca41481962" translate="yes" xml:space="preserve">
          <source>multiple record locking</source>
          <target state="translated">다중 레코드 잠금</target>
        </trans-unit>
        <trans-unit id="8afd1068a6b6b52d595abbeeb6c21d80a22c5f28" translate="yes" xml:space="preserve">
          <source>multiple replacement instructions, the one specified first will take priority over the one specified second, (and so forth) as the &lt;code&gt;INSPECT&lt;/code&gt; proceeds forward through the inspect subject, character-by-character.</source>
          <target state="translated">여러 개의 교체 지침이있는 경우, &lt;code&gt;INSPECT&lt;/code&gt; 가 검사 대상을 문자별로 진행 함에 따라 먼저 지정된 것이 지정된 초 (등)보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="50f378229c2f281da767eb8a6f1aaab660dbc7e7" translate="yes" xml:space="preserve">
          <source>multiple replacement instructions, the one specified first will take priority over the one specified second, (and so forth) as the&lt;code&gt;INSPECT&lt;/code&gt;proceeds forward through the inspect subject, character-by-character.</source>
          <target state="translated">&lt;code&gt;INSPECT&lt;/code&gt; 가 검사 대상을 문자 단위로 진행 함에 따라, 복수의 교체 명령들에서, 먼저 지정된 것들은 지정된 것 (1 등)보다 우선 할 것이다 .</target>
        </trans-unit>
        <trans-unit id="5723d165ed59595207e8c0c85bb720c83f4ce809" translate="yes" xml:space="preserve">
          <source>must</source>
          <target state="translated">must</target>
        </trans-unit>
        <trans-unit id="3ece1471f44f63177cbc35ba0b904e0c096b6783" translate="yes" xml:space="preserve">
          <source>my</source>
          <target state="translated">my</target>
        </trans-unit>
        <trans-unit id="491234c773da99ee6db04a90db80e5fc0398e192" translate="yes" xml:space="preserve">
          <source>names two user-defined functions named &lt;code&gt;MY-FUNCTION-1&lt;/code&gt; and &lt;code&gt;MY-FUNCTION-2&lt;/code&gt; that will be used by the program and</source>
          <target state="translated">프로그램에서 사용할 &lt;code&gt;MY-FUNCTION-1&lt;/code&gt; 및 &lt;code&gt;MY-FUNCTION-2&lt;/code&gt; 라는 두 개의 사용자 정의 함수를 명명 하고</target>
        </trans-unit>
        <trans-unit id="a0d7ea371450db6c6591187559a46a1fee4b6b50" translate="yes" xml:space="preserve">
          <source>nanoseconds in a second, so if you wanted to put the program to sleep for 1/4 second you&amp;rsquo;d use a &lt;var&gt;nanoseconds-to-sleep&lt;/var&gt; value of 250000000.</source>
          <target state="translated">1 초에 나노초이므로 프로그램을 1/4 초 동안 절전 모드로 설정하려면 &lt;var&gt;nanoseconds-to-sleep&lt;/var&gt; 값 250000000을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2d21cb91498086c56bd98d77ed2e347f323e5abc" translate="yes" xml:space="preserve">
          <source>nanoseconds-to-sleep</source>
          <target state="translated">nanoseconds-to-sleep</target>
        </trans-unit>
        <trans-unit id="6f5b01580ce43822444ae4c79edcd0dc789028f1" translate="yes" xml:space="preserve">
          <source>native</source>
          <target state="translated">native</target>
        </trans-unit>
        <trans-unit id="bb84549a6c61802d443c69b93e2044f47674a8d7" translate="yes" xml:space="preserve">
          <source>nb_NO, ne_NP, nl_BE, nl_NL, nn_NO, ns_ZA</source>
          <target state="translated">nb_NO, ne_NP, nl_BE, nl_NL, nn_NO, ns_ZA</target>
        </trans-unit>
        <trans-unit id="e75caf8a34e88ca0f260e3151a4a7c25d661ed86" translate="yes" xml:space="preserve">
          <source>nbytes</source>
          <target state="translated">nbytes</target>
        </trans-unit>
        <trans-unit id="efe30e310694de6b40db25e0bb3b5aa8b0c2b976" translate="yes" xml:space="preserve">
          <source>need</source>
          <target state="translated">need</target>
        </trans-unit>
        <trans-unit id="faf504d6fc8ff2da7d7e8957dc744fbb1d027ee5" translate="yes" xml:space="preserve">
          <source>negation</source>
          <target state="translated">negation</target>
        </trans-unit>
        <trans-unit id="85777c03b72554cd08e721b6148dc27d2a50a7a6" translate="yes" xml:space="preserve">
          <source>never</source>
          <target state="translated">never</target>
        </trans-unit>
        <trans-unit id="7d1b75d4524035840e3860a4b0a00d3e0cf501b6" translate="yes" xml:space="preserve">
          <source>new-file-path</source>
          <target state="translated">new-file-path</target>
        </trans-unit>
        <trans-unit id="edee9402d198b04ac77dcf5dc9cc3dac44573782" translate="yes" xml:space="preserve">
          <source>next</source>
          <target state="translated">next</target>
        </trans-unit>
        <trans-unit id="fd1286353570c5703799ba76999323b7c7447b06" translate="yes" xml:space="preserve">
          <source>no</source>
          <target state="translated">no</target>
        </trans-unit>
        <trans-unit id="d26dc0e1209fc8976e0148c4923ec5b93ab8b0ca" translate="yes" xml:space="preserve">
          <source>no more options (or reach the first non-option if first byte of &lt;code&gt;shortoptions&lt;/code&gt; is &amp;lsquo;</source>
          <target state="translated">더 이상 옵션이 없습니다 (또는 &lt;code&gt;shortoptions&lt;/code&gt; 의 첫 번째 바이트 가 '인 경우 첫 번째 비 옵션에 도달합니다.</target>
        </trans-unit>
        <trans-unit id="693601abe691ba1a256cb7ec7310ef05b4342b73" translate="yes" xml:space="preserve">
          <source>no-of-columns</source>
          <target state="translated">no-of-columns</target>
        </trans-unit>
        <trans-unit id="8a4124f3d444fcef48d5c730d8a58b5371714ace" translate="yes" xml:space="preserve">
          <source>no-of-lines</source>
          <target state="translated">no-of-lines</target>
        </trans-unit>
        <trans-unit id="32de11c9bc665c26dee808f6b2ce617d21f12d8a" translate="yes" xml:space="preserve">
          <source>non-option (only if first byte of so is &amp;lsquo;</source>
          <target state="translated">비 옵션 (첫 번째 바이트가 '</target>
        </trans-unit>
        <trans-unit id="557f255516719ea16f8f4a0aae1166054e2c9b43" translate="yes" xml:space="preserve">
          <source>not</source>
          <target state="translated">not</target>
        </trans-unit>
        <trans-unit id="9063d84355b652e7bdcd0b2d96dcaf4374cd76fd" translate="yes" xml:space="preserve">
          <source>number to indicate the level at which a data item occurs in a data structure such as the example shown above. When these data items are defined, they are all defined together with a number in the range 1-49 specified in front of their names. Over the years, a convention has come to exist among COBOL programmers that level numbers are always coded as two-digit numbers &amp;mdash; they don&amp;rsquo;t</source>
          <target state="translated">위에 표시된 예와 같은 데이터 구조에서 데이터 항목이 발생하는 수준을 나타내는 숫자입니다. 이러한 데이터 항목이 정의되면 이름 앞에 지정된 1-49 범위의 숫자와 함께 모두 정의됩니다. 수년에 걸쳐 레벨 번호는 항상 두 자리 숫자로 코딩된다는 규칙이 COBOL 프로그래머 사이에 존재하게되었습니다.</target>
        </trans-unit>
        <trans-unit id="19bd795751043a22ccad28f97f10989ae6773ac9" translate="yes" xml:space="preserve">
          <source>number-n</source>
          <target state="translated">number-n</target>
        </trans-unit>
        <trans-unit id="1ceb1fc8f4515311d653d1a9fceb729eda7e612e" translate="yes" xml:space="preserve">
          <source>oc_FR, or_IN</source>
          <target state="translated">oc_FR, or_IN</target>
        </trans-unit>
        <trans-unit id="30390cc70b7dfe1d7c535ad74aa7e3f3b56725cd" translate="yes" xml:space="preserve">
          <source>occurs with at least one character position in &lt;var&gt;identifier-1&lt;/var&gt; not having been processed.</source>
          <target state="translated">처리되지 않은 &lt;var&gt;identifier-1&lt;/var&gt; 에서 하나 이상의 문자 위치로 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="c718f52486a370888c3ddc08491292078d180e1c" translate="yes" xml:space="preserve">
          <source>occurs, &lt;var&gt;identifier-3&lt;/var&gt; will remain unchanged.</source>
          <target state="translated">발생하면 &lt;var&gt;identifier-3&lt;/var&gt; 은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c8cfff7985c854ebed2f94ebd5e1ce5c353ad60" translate="yes" xml:space="preserve">
          <source>occurs, none of the destination field contents (or the contents of their &lt;code&gt;DELIMITER&lt;/code&gt; or &lt;var&gt;COUNT&lt;/var&gt; identifiers) will be changed.</source>
          <target state="translated">발생하면 대상 필드 내용 (또는 &lt;code&gt;DELIMITER&lt;/code&gt; 또는 &lt;var&gt;COUNT&lt;/var&gt; 식별자 의 내용 )이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd33a9547d5c98a892eeab2fba6f81efe6f9ff02" translate="yes" xml:space="preserve">
          <source>occurs, or if event</source>
          <target state="translated">발생하거나 이벤트</target>
        </trans-unit>
        <trans-unit id="54e48c40255c10fbac9d4f88883e0d4d8941d9d4" translate="yes" xml:space="preserve">
          <source>of &lt;code&gt;KEY&lt;/code&gt; field values.</source>
          <target state="translated">의 &lt;code&gt;KEY&lt;/code&gt; 필드 값.</target>
        </trans-unit>
        <trans-unit id="00817663de16bba67d6b56eb971ddd8ce1b8b6e4" translate="yes" xml:space="preserve">
          <source>of a</source>
          <target state="translated">~의</target>
        </trans-unit>
        <trans-unit id="0bfeba1b70657e1c5ab71fcb65e7829380c0429f" translate="yes" xml:space="preserve">
          <source>of a COBOL statement (columns 1-6) has come to be used as a change indicator area. Programmers would place a code in columns 1-6 of every line they changed in a program. The author works in a COBOL shop where change indicators of the form &amp;ldquo;xxmmyy&amp;rdquo; are required on every altered line of a program &amp;mdash; &amp;ldquo;xx&amp;rdquo; is the initials of the programmer while &amp;ldquo;mmyy&amp;rdquo; are the month and two-digit year of the date the change was made. This is frequently accompanied by a comment block at or near the top of a COBOL program providing general documentation of what changes were made and what change indicator was used to mark that change.</source>
          <target state="translated">COBOL 문 (1-6 열)의 변경 표시기 영역으로 사용되었습니다. 프로그래머는 프로그램에서 변경 한 모든 행의 1-6 열에 코드를 배치합니다. 저자는 프로그램의 모든 변경된 줄에 &quot;xxmmyy&quot;형식의 변경 표시기가 필요한 COBOL 상점에서 작업합니다. &quot;xx&quot;는 프로그래머의 이니셜이고 &quot;mmyy&quot;는 날짜의 월과 두 자리 연도입니다. 변경되었습니다. 여기에는 COBOL 프로그램 상단 또는 그 근처에 주석 블록이 수반되어 어떤 변경이 이루어 졌는지에 대한 일반 문서를 제공하고 해당 변경을 표시하는 데 사용 된 변경 표시기가 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="d4e302b8a928921c3f08821c2f9091fec8ae9257" translate="yes" xml:space="preserve">
          <source>of a bit-by-bit logical</source>
          <target state="translated">비트 단위 논리</target>
        </trans-unit>
        <trans-unit id="70eb4366df45deb985b8851b2f7f9214a6abd1a7" translate="yes" xml:space="preserve">
          <source>of a hierarchy diagram such as the one you see here (if you were to make one, which you rarely will, if ever, once you get used to this concept) must have the same level number.</source>
          <target state="translated">여기에서 볼 수있는 것과 같은 계층 구조 다이어그램의 (만들려면이 개념에 익숙해지면 거의 발생하지 않는) 레벨 번호가 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="438df02371524711a6810f863f8af74761d4adbe" translate="yes" xml:space="preserve">
          <source>of a word they are creating themselves, but may not create their own word as an exact duplicate (without regard to case) of a COBOL reserved word. Note that a reserved word includes all classes, such as intrinsic functions, mnemonics names, system routines and reserved words.</source>
          <target state="translated">단어 자체는 자신을 만들지 만 COBOL 예약어의 정확한 복제본 (사건에 관계없이)으로 자체 단어를 만들 수는 없습니다. 예약어에는 내장 함수, 니모닉 이름, 시스템 루틴 및 예약어와 같은 모든 클래스가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1efbdfa080aa86ce64218c583c46eebd266a644d" translate="yes" xml:space="preserve">
          <source>of a word they are creating themselves, but may not create their own word as an exact duplicate (without regard to case) of a COBOL reserved word. Note that a reserved word includes all classes, such as intrinsic functions, mnemonics names, system routines and reserved words. The list of reserved words can be changed by adding or removing specific words for a given compile or as a default by use of the steering command -std and -conf. See the specific config files that are by default, held in</source>
          <target state="translated">자신이 생성하는 단어의 경우 COBOL 예약어의 정확한 중복 (대소 문자에 관계없이)으로 자신의 단어를 생성 할 수 없습니다. 예약어에는 내장 함수, 니모닉 이름, 시스템 루틴 및 예약어와 같은 모든 클래스가 포함됩니다. 예약어 목록은 주어진 컴파일에 대해 특정 단어를 추가 또는 제거하여 변경하거나 스티어링 명령 -std 및 -conf를 사용하여 기본값으로 변경할 수 있습니다. 기본적으로 보관되는 특정 구성 파일을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d2cef8324449cad6fcd6296dd50ba7bfc4485549" translate="yes" xml:space="preserve">
          <source>of its &amp;lt;</source>
          <target state="translated">그것의 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="7eb9cf33857178ef8304c399383cac7bda400530" translate="yes" xml:space="preserve">
          <source>of its &lt;var&gt;Selection-Object&lt;/var&gt;(s) successfully matched by the corresponding &lt;var&gt;Selection-Subject&lt;/var&gt;; this will be referred to as the &amp;rsquo;</source>
          <target state="translated">그것의 &lt;var&gt;Selection-Object&lt;/var&gt; 성공적 대응 일치 (들) &lt;var&gt;Selection-Subject&lt;/var&gt; ; 이것은 '</target>
        </trans-unit>
        <trans-unit id="7eea32ae6b997e915cde5a9467168690b3fc12b3" translate="yes" xml:space="preserve">
          <source>of storage occupied by string, but rather the number of actual</source>
          <target state="translated">문자열이 차지하는 저장 공간이 아니라 실제 수</target>
        </trans-unit>
        <trans-unit id="2605e91ed9c4a654cfb0cc10d80a5b839d89aa18" translate="yes" xml:space="preserve">
          <source>of storage required to store &amp;lt;</source>
          <target state="translated">저장에 필요한 저장 공간 수 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="b4fd539db186255c525f867f556d57cc7b806229" translate="yes" xml:space="preserve">
          <source>of storage required to store &lt;var&gt;string&lt;/var&gt;. For example, if &lt;var&gt;string&lt;/var&gt; is encoded using a double-byte character set such as Unicode UTF-16 (where each character is represented by 16 bits of storage, not the 8-bits inherent to character sets like &lt;small&gt;ASCII&lt;/small&gt; or &lt;small&gt;EBCDIC&lt;/small&gt;), then calling this function with a &lt;var&gt;string&lt;/var&gt; argument whose &lt;code&gt;PICTURE is X(4)&lt;/code&gt; would return a value of 8 rather than the value 4.</source>
          <target state="translated">&lt;var&gt;string&lt;/var&gt; 을 저장하는 데 필요한 스토리지의 . 예를 들어, &lt;var&gt;string&lt;/var&gt; 이 Unicode UTF-16과 같은 2 바이트 문자 집합을 사용하여 인코딩 된 경우 (각 문자는 &lt;small&gt;ASCII&lt;/small&gt; 또는 &lt;small&gt;EBCDIC&lt;/small&gt; 같은 문자 집합에 고유 한 8 비트가 아닌 16 비트 저장소로 표시됨) 다음을 호출합니다. &lt;code&gt;PICTURE is X(4)&lt;/code&gt; 인 &lt;var&gt;string&lt;/var&gt; 인수가있는 함수 는 값 4가 아닌 8 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d2263e6a77aa654ea8937e310e4e58af7cbbc1cc" translate="yes" xml:space="preserve">
          <source>of the</source>
          <target state="translated">의</target>
        </trans-unit>
        <trans-unit id="2dce3529fe1d643164f3325788f59fbe751ab6a8" translate="yes" xml:space="preserve">
          <source>of the &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="51679ea6192f3e1a3c47a39a775267d6ffb3405b" translate="yes" xml:space="preserve">
          <source>of the &lt;var&gt;picture-string&lt;/var&gt; &amp;mdash; a subject that will be covered in the next numbered paragraph.</source>
          <target state="translated">의 &lt;var&gt;picture-string&lt;/var&gt; 다음 번호가 매겨진 단락에서 다룰 것이다 주제 -.</target>
        </trans-unit>
        <trans-unit id="ccf5f36a992fa38ae95a6be40f073db340cd7960" translate="yes" xml:space="preserve">
          <source>of the actual data being passed as an argument. The item may anything defined within the data division of the program. The copy is made each time the &lt;code&gt;CALL&lt;/code&gt; statement is executed, immediately before the &lt;code&gt;CALL&lt;/code&gt; actually takes place. If the subroutine modifies the contents of this argument, it will be the</source>
          <target state="translated">인수로 전달되는 실제 데이터의. 항목은 프로그램의 데이터 분할 내에 정의 된 모든 것이 될 수 있습니다. 복사는 &lt;code&gt;CALL&lt;/code&gt; 문이 실행될 때마다 &lt;code&gt;CALL&lt;/code&gt; 이 실제로 발생 하기 직전에 만들어집니다 . 서브 루틴이이 인수의 내용을 수정하면</target>
        </trans-unit>
        <trans-unit id="2a1a58622de761fd871f251948cce934a111366c" translate="yes" xml:space="preserve">
          <source>of the argument to the subprogram. If the subprogram changes the contents of that argument, the change will be &amp;ldquo;visible&amp;rdquo; to the calling program.</source>
          <target state="translated">서브 프로그램에 대한 인수의. 하위 프로그램이 해당 인수의 내용을 변경하면 변경 내용이 호출 프로그램에 &quot;표시&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="87979fc448414ee03ec18050c5ac86426312c5ec" translate="yes" xml:space="preserve">
          <source>of the argument to the subprogram. If the subprogram changes the value of such an argument, the change only affects the copy back in the calling program, not the original version.</source>
          <target state="translated">서브 프로그램에 대한 인수의. 서브 프로그램이 그러한 인수의 값을 변경하면 변경은 원래 버전이 아닌 호출 프로그램의 사본에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="584528fbd584739d3cee4f96d2f0e5160df76da5" translate="yes" xml:space="preserve">
          <source>of the argument, not to the &quot;Arg1&quot; data item itself.</source>
          <target state="translated">&quot;Arg1&quot;데이터 항목 자체가 아닌 인수</target>
        </trans-unit>
        <trans-unit id="da06a35c8fdc1e7932e6968c509ec07fc8cfa3b1" translate="yes" xml:space="preserve">
          <source>of the argument, not to the &lt;code&gt;Arg1&lt;/code&gt; data item itself.</source>
          <target state="translated">&lt;code&gt;Arg1&lt;/code&gt; 데이터 항목 자체가 아닌 인수의</target>
        </trans-unit>
        <trans-unit id="12f8f69ca68615b20f7a59b8e9461c480041ed91" translate="yes" xml:space="preserve">
          <source>of the choices could be selected.</source>
          <target state="translated">선택 중 하나를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d40c655eef994dbcce3095438a84c616dbdedac8" translate="yes" xml:space="preserve">
          <source>of the data being passed as an argument. The item may be any elementary binary numeric item defined within the data division of the program. If the subroutine modifies the contents of this argument, the calling program will not &amp;ldquo;see&amp;rdquo; the results of that change when the subroutine returns control.</source>
          <target state="translated">인수로 전달되는 데이터의. 항목은 프로그램의 데이터 분할 내에 정의 된 기본 이진 숫자 항목 일 수 있습니다. 서브 루틴이이 인수의 내용을 수정하면 호출 프로그램은 서브 루틴이 제어를 반환 할 때 변경 결과를 &quot;보지&quot;않습니다.</target>
        </trans-unit>
        <trans-unit id="b67d462cb1898a67ac15be58129e5f4a0c45ea82" translate="yes" xml:space="preserve">
          <source>of the expected field contents, but they don&amp;rsquo;t provide any run-time enforcement capabilities.</source>
          <target state="translated">예상되는 필드 내용 중 하나이지만 런타임 시행 기능을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8924daa104aecc98c3005ea7a96e9522778d045e" translate="yes" xml:space="preserve">
          <source>of the literal or identifiers contents as the argument. This feature exists to provide compatibility with C, C++ and other languages and would not normally be used when calling GnuCOBOL subprograms. Only numeric literals or numeric data items should be passed in this manner.</source>
          <target state="translated">인수로 리터럴 또는 식별자 내용의. 이 기능은 C, C ++ 및 기타 언어와의 호환성을 제공하기 위해 존재하며 일반적으로 GnuCOBOL 하위 프로그램을 호출 할 때 사용되지 않습니다. 숫자 리터럴 또는 숫자 데이터 항목 만이 방식으로 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="cdb7134f602e9ae69a5c1b1e5d9ed01b5c1089f2" translate="yes" xml:space="preserve">
          <source>of&lt;code&gt;KEY&lt;/code&gt;field values.</source>
          <target state="translated">의 &lt;code&gt;KEY&lt;/code&gt; 필드 값.</target>
        </trans-unit>
        <trans-unit id="3d4bd380de3a45e1e906061bef8cf5b078205935" translate="yes" xml:space="preserve">
          <source>offers additional control (see &lt;a href=&quot;#cobc-_002d-The-GnuCOBOL-Compiler&quot;&gt;cobc - The GnuCOBOL Compiler&lt;/a&gt;).</source>
          <target state="translated">추가 제어를 제공합니다 ( &lt;a href=&quot;#cobc-_002d-The-GnuCOBOL-Compiler&quot;&gt;cobc-GnuCOBOL 컴파일러 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="53a610e925bbc0a175e365d31241ae75aeead651" translate="yes" xml:space="preserve">
          <source>offset</source>
          <target state="translated">offset</target>
        </trans-unit>
        <trans-unit id="f39eff231d902e951120c52e24ec1ec55c0f4e02" translate="yes" xml:space="preserve">
          <source>old-file-path</source>
          <target state="translated">old-file-path</target>
        </trans-unit>
        <trans-unit id="d2c11fc3a3889a3283384ae7e7bf955d6a8159ff" translate="yes" xml:space="preserve">
          <source>on a Unix system or</source>
          <target state="translated">Unix 시스템 또는</target>
        </trans-unit>
        <trans-unit id="9e06cc27d9ca99733156d10703365c3b57550ee9" translate="yes" xml:space="preserve">
          <source>on a Windows system,</source>
          <target state="translated">Windows 시스템에서</target>
        </trans-unit>
        <trans-unit id="333c5c1a6b6f02f058733f18f1ed30aba47bd210" translate="yes" xml:space="preserve">
          <source>on an OSX system, where</source>
          <target state="translated">OSX 시스템에서</target>
        </trans-unit>
        <trans-unit id="0c5dc404c04a6382420b1067dcbd54dd9c72d36d" translate="yes" xml:space="preserve">
          <source>on mainframes. The &quot;modern&quot; programming languages were designed and intended for use on the full variety of computer platforms, from shirt-pocket computers (i.e. smart phones) up to the most massive of supercomputers.</source>
          <target state="translated">메인 프레임에. &quot;현대&quot;프로그래밍 언어는 셔츠 포켓 컴퓨터 (예 : 스마트 폰)에서 가장 큰 수퍼 컴퓨터에 이르기까지 다양한 컴퓨터 플랫폼에서 사용하도록 설계 및 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="927ba17967f5c8574bec59d8abdb698f02f77da5" translate="yes" xml:space="preserve">
          <source>one having that key value.</source>
          <target state="translated">하나는 그 키 값을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="535be298fd198220e216b199a8f61c63c31e3940" translate="yes" xml:space="preserve">
          <source>one of the values specified on &amp;lt;</source>
          <target state="translated">&amp;lt;에 지정된 값 중 하나</target>
        </trans-unit>
        <trans-unit id="17f7a705f564828b667ab13ae63dc4043218cd0c" translate="yes" xml:space="preserve">
          <source>one of the values specified on &lt;var&gt;condition-name-1&lt;/var&gt;&amp;rsquo;s &lt;code&gt;VALUE&lt;/code&gt; clause, &lt;var&gt;condition-name-1&lt;/var&gt; will take on the value of FALSE.</source>
          <target state="translated">&lt;var&gt;condition-name-1&lt;/var&gt; 의 &lt;code&gt;VALUE&lt;/code&gt; 절 에 지정된 값 중 하나 인 &lt;var&gt;condition-name-1&lt;/var&gt; 은 FALSE 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f8969a18a0daab6f59b42990613def0b8b6d48eb" translate="yes" xml:space="preserve">
          <source>only</source>
          <target state="translated">only</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="b4ec2698d7966ba79f03fb8d1d275336dad6acf8" translate="yes" xml:space="preserve">
          <source>or each A,B,C item could be referenced as follows:</source>
          <target state="translated">또는 각 A, B, C 항목은 다음과 같이 참조 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fede30d067e948f0b1df282d890c3f9b28c88f04" translate="yes" xml:space="preserve">
          <source>or more</source>
          <target state="translated">이상</target>
        </trans-unit>
        <trans-unit id="3c0bbe327a66a8e7eedd636422b4d6c7fcb3416f" translate="yes" xml:space="preserve">
          <source>or simply</source>
          <target state="translated">또는 단순히</target>
        </trans-unit>
        <trans-unit id="96e22d2a00937b9f6401f0cad1fddcb906c099f0" translate="yes" xml:space="preserve">
          <source>or&amp;rsquo;</source>
          <target state="translated">or&amp;rsquo;</target>
        </trans-unit>
        <trans-unit id="cb6544596cc25b87874112c1aacf51133d3eeb68" translate="yes" xml:space="preserve">
          <source>or, to remove,</source>
          <target state="translated">또는 제거하려면</target>
        </trans-unit>
        <trans-unit id="d0941e68da8f38151ff86a61fc59f7c5cf9fcaa2" translate="yes" xml:space="preserve">
          <source>other</source>
          <target state="translated">other</target>
        </trans-unit>
        <trans-unit id="ba9f5c0fec92d17fc44396ae62f2c2842ff7b319" translate="yes" xml:space="preserve">
          <source>output (write-only)</source>
          <target state="translated">출력 (쓰기 전용)</target>
        </trans-unit>
        <trans-unit id="45e18dad51fd9e8869897fba48fa93d118e5e404" translate="yes" xml:space="preserve">
          <source>outside</source>
          <target state="translated">outside</target>
        </trans-unit>
        <trans-unit id="10e80591d92f76de99d040a135745da09e965721" translate="yes" xml:space="preserve">
          <source>overflow</source>
          <target state="translated">overflow</target>
        </trans-unit>
        <trans-unit id="a85aeba05ff29a64c79b46e91721e04ad7b237c4" translate="yes" xml:space="preserve">
          <source>overflow condition</source>
          <target state="translated">오버 플로우 조건</target>
        </trans-unit>
        <trans-unit id="516b9783fca517eecbd1d064da2d165310b19759" translate="yes" xml:space="preserve">
          <source>p</source>
          <target state="translated">p</target>
        </trans-unit>
        <trans-unit id="c79bf582b108ff0d1408803265b812180b4b0a05" translate="yes" xml:space="preserve">
          <source>pa_IN, pl_PL, ps_AF, pt_BR, pt_PT</source>
          <target state="translated">pa_IN, pl_PL, ps_AF, pt_BR, pt_PT</target>
        </trans-unit>
        <trans-unit id="a8f8ca95d37fec89f9b511602cc555817efed118" translate="yes" xml:space="preserve">
          <source>package being used, to draw borders on the top, left and/or bottom edges of a field.</source>
          <target state="translated">필드의 위쪽, 왼쪽 및 / 또는 아래쪽 가장자리에 테두리를 그리는 데 사용되는 패키지입니다.</target>
        </trans-unit>
        <trans-unit id="65747ebacd0ac49a3fa1ca664105304f86930c8a" translate="yes" xml:space="preserve">
          <source>package built into your version of GnuCOBOL. If blinking is enabled in that package, text displayed in fields defined in the screen section as being blinking will endlessly cycle between the brightest possible setting (highlight) and an &amp;ldquo;invisible&amp;rdquo; setting where the text color matches that of the field background color. A Windows build, which generally uses the &amp;ldquo;pcurses&amp;rdquo; package, will uses a brighter-than-normal background color to signify &amp;ldquo;blinking&amp;rdquo;.</source>
          <target state="translated">GnuCOBOL 버전에 내장 된 패키지입니다. 해당 패키지에서 깜박임이 활성화 된 경우 화면 섹션에서 깜박이는 것으로 정의 된 필드에 표시된 텍스트는 가능한 가장 밝은 설정 (강조 표시)과 텍스트 색상이 필드 배경색과 일치하는 &quot;보이지 않는&quot;설정 사이를 끝없이 순환합니다. 일반적으로 &quot;pcurses&quot;패키지를 사용하는 Windows 빌드는 &quot;깜박임&quot;을 나타 내기 위해 일반보다 밝은 배경색을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2d71d077085417a86595aca3ae237eb3e1181e65" translate="yes" xml:space="preserve">
          <source>package that is being used. This is a utility screen-IO package that is included into the GnuCOBOL run-time library when the GnuCOBOL software is built.</source>
          <target state="translated">사용중인 패키지. 이것은 GnuCOBOL 소프트웨어가 빌드 될 때 GnuCOBOL 런타임 라이브러리에 포함 된 유틸리티 화면 IO 패키지입니다.</target>
        </trans-unit>
        <trans-unit id="3fc88b83767af036ec64f408a5c22693db6e3b76" translate="yes" xml:space="preserve">
          <source>part</source>
          <target state="translated">part</target>
        </trans-unit>
        <trans-unit id="1082bca68f8e12601a08bba7c233915f43845b35" translate="yes" xml:space="preserve">
          <source>partial-expression</source>
          <target state="translated">partial-expression</target>
        </trans-unit>
        <trans-unit id="f7ff4ed368bedac08f79aae442cc1507c3f8e23c" translate="yes" xml:space="preserve">
          <source>partial-word-2</source>
          <target state="translated">partial-word-2</target>
        </trans-unit>
        <trans-unit id="56cac2c49a8b11b95f73c0c9dad210cc0856153c" translate="yes" xml:space="preserve">
          <source>passes the</source>
          <target state="translated">통과</target>
        </trans-unit>
        <trans-unit id="430aa2dd7372e5d1ea04b9ce0e001d99a27f773c" translate="yes" xml:space="preserve">
          <source>perceived</source>
          <target state="translated">perceived</target>
        </trans-unit>
        <trans-unit id="87027c65c23c23ca979c2b2a4d13bdd2bda88973" translate="yes" xml:space="preserve">
          <source>perform scope</source>
          <target state="translated">범위를 수행</target>
        </trans-unit>
        <trans-unit id="6c0f74889f239077d2ad94ee7c3c1570d90b5725" translate="yes" xml:space="preserve">
          <source>physically</source>
          <target state="translated">physically</target>
        </trans-unit>
        <trans-unit id="533b443aa0f0c65e72e2c3119f30bca75af15df6" translate="yes" xml:space="preserve">
          <source>picture-string</source>
          <target state="translated">picture-string</target>
        </trans-unit>
        <trans-unit id="1e1f839513da16f0f13759d03fc432410960f1d9" translate="yes" xml:space="preserve">
          <source>places, the specifications made on the &lt;code&gt;OPEN&lt;/code&gt; statement will take precedence over those from the &lt;code&gt;SELECT&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;OPEN&lt;/code&gt; 문에 작성된 스펙 이 &lt;code&gt;SELECT&lt;/code&gt; 문의 스펙 보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="31199b77f53a9467ce06fa11ec3bc6de1f3a9f05" translate="yes" xml:space="preserve">
          <source>places, the specifications made on the&lt;code&gt;OPEN&lt;/code&gt;statement will take precedence over those from the&lt;code&gt;SELECT&lt;/code&gt;statement.</source>
          <target state="translated">&lt;code&gt;OPEN&lt;/code&gt; 문에 작성된 스펙 이 &lt;code&gt;SELECT&lt;/code&gt; 문의 스펙 보다 우선 합니다.</target>
        </trans-unit>
        <trans-unit id="c20c2e1477b31426734d5a6addf21b86323eaab8" translate="yes" xml:space="preserve">
          <source>pointer-name-1</source>
          <target state="translated">pointer-name-1</target>
        </trans-unit>
        <trans-unit id="de2dd0958981ff4f0c8b0f6f982d77c9873a3c84" translate="yes" xml:space="preserve">
          <source>pointer-name-2</source>
          <target state="translated">pointer-name-2</target>
        </trans-unit>
        <trans-unit id="914aa7bc3595e1b0ca611b2667533c9989c4e78e" translate="yes" xml:space="preserve">
          <source>possible, however, to manually allocate linkage section data items that aren&amp;rsquo;t subprogram arguments via the &lt;code&gt;ALLOCATE&lt;/code&gt; statement (see &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt;) statement. In such cases, initialization will take place as per the documentation of that statement.</source>
          <target state="translated">그러나 &lt;code&gt;ALLOCATE&lt;/code&gt; 문 ( &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt; 참조 ) 문을 통해 하위 프로그램 인수가 아닌 연결 섹션 데이터 항목을 수동으로 할당 할 수 있습니다 . 이러한 경우 해당 명령문의 문서에 따라 초기화가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e18f18bda25aa010088527eb0a3d4152b2449c73" translate="yes" xml:space="preserve">
          <source>possible, however, to manually allocate linkage section data items that aren&amp;rsquo;t subprogram arguments via the&lt;code&gt;ALLOCATE&lt;/code&gt;statement (see &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt;) statement. In such cases, initialization will take place as per the documentation of that statement.</source>
          <target state="translated">그러나 &lt;code&gt;ALLOCATE&lt;/code&gt; 문을 통해 서브 프로그램 인수가 아닌 연계 섹션 데이터 항목을 수동으로 할당 할 수 있습니다 ( &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt; 참조 ). 그러한 경우 해당 명령문의 문서에 따라 초기화가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="967bab6ce060caba3daa22350131f0b8d115cfb8" translate="yes" xml:space="preserve">
          <source>prefixing data items with an indication of where in the program structure they were created. For example:</source>
          <target state="translated">프로그램 구조에서 생성 된 위치를 나타내는 데이터 항목 접 두부. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50644481c7cd620b733fcc580e5d6745665dac74" translate="yes" xml:space="preserve">
          <source>present</source>
          <target state="translated">present</target>
        </trans-unit>
        <trans-unit id="1b2bf1cea7985b24f409bb71d85b8ce321a18c03" translate="yes" xml:space="preserve">
          <source>prevent</source>
          <target state="translated">prevent</target>
        </trans-unit>
        <trans-unit id="d76f79729efeafccf0ae84e817750988afa8142b" translate="yes" xml:space="preserve">
          <source>primary-entry-point-name; paragraph OF section; statement-number</source>
          <target state="translated">1 차 엔트리 포인트 이름; 섹션의 단락; 명세서 번호</target>
        </trans-unit>
        <trans-unit id="d807007bebf317b7d6f4e7440492bf70d8284c7f" translate="yes" xml:space="preserve">
          <source>primary-entry-point-name; paragraph; statement-number</source>
          <target state="translated">1 차 엔트리 포인트 이름; 절; 명세서 번호</target>
        </trans-unit>
        <trans-unit id="e20ff6a4a8243a1860898c825de6b1e274487d09" translate="yes" xml:space="preserve">
          <source>primary-entry-point-name; section; statement-number</source>
          <target state="translated">1 차 엔트리 포인트 이름; 부분; 명세서 번호</target>
        </trans-unit>
        <trans-unit id="6123a6ccd2c4400eb6b9fbec9e6f999012983a94" translate="yes" xml:space="preserve">
          <source>primary-entry-point-name; statement-number</source>
          <target state="translated">1 차 엔트리 포인트 이름; 명세서 번호</target>
        </trans-unit>
        <trans-unit id="4302b676f1bed3e5a01be19307571ae4fab6f57f" translate="yes" xml:space="preserve">
          <source>printable will be converted to the character specified as the second argument.</source>
          <target state="translated">printable은 두 번째 인수로 지정된 문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="a25713781b11256c74c4697e173c717844965570" translate="yes" xml:space="preserve">
          <source>procedure-name-1</source>
          <target state="translated">procedure-name-1</target>
        </trans-unit>
        <trans-unit id="e986ac33edee17e139ecc7fc0b6e5329594d34cc" translate="yes" xml:space="preserve">
          <source>procedure-name-2</source>
          <target state="translated">procedure-name-2</target>
        </trans-unit>
        <trans-unit id="139827ce72b5f042e39a91352565ea6e8c0bde5c" translate="yes" xml:space="preserve">
          <source>process between the left-most 8*&lt;var&gt;byte-length&lt;/var&gt; corresponding bits of &lt;var&gt;item-1&lt;/var&gt; and &lt;var&gt;item-2&lt;/var&gt;, storing the resulting bit string into &lt;var&gt;item-2&lt;/var&gt;. The truth table shown to the left documents the &lt;code&gt;IMP&lt;/code&gt; process.   The &lt;var&gt;item-1&lt;/var&gt; argument may be an alphanumeric literal or a data item and &lt;var&gt;item-2&lt;/var&gt; must be a data item. The length of both &lt;var&gt;item-1&lt;/var&gt; and &lt;var&gt;item-2&lt;/var&gt; must be at least 8*&lt;var&gt;byte-length&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;item-1&lt;/var&gt; 과 &lt;var&gt;item-2&lt;/var&gt; 의 가장 왼쪽에있는 8 * &lt;var&gt;byte-length&lt;/var&gt; 해당하는 비트 사이를 처리 하여 결과 비트 문자열을 &lt;var&gt;item-2&lt;/var&gt; 에 저장합니다 . 왼쪽에 표시된 진리표는 &lt;code&gt;IMP&lt;/code&gt; 프로세스를 문서화합니다 . &lt;var&gt;item-1&lt;/var&gt; 인수는 영숫자 문자 또는 데이터 항목 일 수있다 &lt;var&gt;item-2&lt;/var&gt; 데이터 항목이어야한다. &lt;var&gt;item-1&lt;/var&gt; 과 &lt;var&gt;item-2&lt;/var&gt; 의 길이 적어도 8 * &lt;var&gt;byte-length&lt;/var&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="00a7c3a84dcff7487f6665d6efb4825c97d952c0" translate="yes" xml:space="preserve">
          <source>process between the left-most 8*&lt;var&gt;byte-length&lt;/var&gt; corresponding bits of &lt;var&gt;item-1&lt;/var&gt; and &lt;var&gt;item-2&lt;/var&gt;, storing the resulting bit string into &lt;var&gt;item-2&lt;/var&gt;. The truth table shown to the left documents the &lt;code&gt;NIMP&lt;/code&gt; process.   The &lt;var&gt;item-1&lt;/var&gt; argument may be an alphanumeric literal or a data item and &lt;var&gt;item-2&lt;/var&gt; must be a data item. The length of both &lt;var&gt;item-1&lt;/var&gt; and &lt;var&gt;item-2&lt;/var&gt; must be at least 8*&lt;var&gt;byte-length&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;item-1&lt;/var&gt; 과 &lt;var&gt;item-2&lt;/var&gt; 의 가장 왼쪽에있는 8 * &lt;var&gt;byte-length&lt;/var&gt; 해당하는 비트 사이를 처리 하여 결과 비트 문자열을 &lt;var&gt;item-2&lt;/var&gt; 에 저장합니다 . 왼쪽에 표시된 진리표는 &lt;code&gt;NIMP&lt;/code&gt; 프로세스를 문서화합니다 . &lt;var&gt;item-1&lt;/var&gt; 인수는 영숫자 문자 또는 데이터 항목 일 수있다 &lt;var&gt;item-2&lt;/var&gt; 데이터 항목이어야한다. &lt;var&gt;item-1&lt;/var&gt; 과 &lt;var&gt;item-2&lt;/var&gt; 의 길이는 모두 8 * 이상이어야합니다. &lt;var&gt;byte-length&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="7f058f2b6fc66e118c46f18b4914dbdc22772909" translate="yes" xml:space="preserve">
          <source>process between the left-most 8*&lt;var&gt;byte-length&lt;/var&gt; corresponding bits of &lt;var&gt;item-1&lt;/var&gt; and &lt;var&gt;item-2&lt;/var&gt;, storing the resulting bit string into &lt;var&gt;item-2&lt;/var&gt;. The truth table shown to the left documents the &lt;code&gt;NOR&lt;/code&gt; process.   The &lt;var&gt;item-1&lt;/var&gt; argument may be an alphanumeric literal or a data item and &lt;var&gt;item-2&lt;/var&gt; must be a data item. The length of both &lt;var&gt;item-1&lt;/var&gt; and &lt;var&gt;item-2&lt;/var&gt; must be at least 8*&lt;var&gt;byte-length&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;item-1&lt;/var&gt; 과 &lt;var&gt;item-2&lt;/var&gt; 의 가장 왼쪽에있는 8 * &lt;var&gt;byte-length&lt;/var&gt; 해당하는 비트 사이를 처리 하여 결과 비트 문자열을 &lt;var&gt;item-2&lt;/var&gt; 에 저장합니다 . 왼쪽에 표시된 진리표는 &lt;code&gt;NOR&lt;/code&gt; 프로세스를 문서화합니다 . &lt;var&gt;item-1&lt;/var&gt; 인수는 영숫자 문자 또는 데이터 항목 일 수있다 &lt;var&gt;item-2&lt;/var&gt; 데이터 항목이어야한다. &lt;var&gt;item-1&lt;/var&gt; 과 &lt;var&gt;item-2&lt;/var&gt; 의 길이는 모두 8 * 이상이어야합니다. &lt;var&gt;byte-length&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="15b0948268b2b1af1e84df0a50293ab58da8fe2e" translate="yes" xml:space="preserve">
          <source>process between the left-most 8*&lt;var&gt;byte-length&lt;/var&gt; corresponding bits of &lt;var&gt;item-1&lt;/var&gt; and &lt;var&gt;item-2&lt;/var&gt;, storing the resulting bit string into &lt;var&gt;item-2&lt;/var&gt;. The truth table shown to the left documents the &lt;code&gt;OR&lt;/code&gt; process.   The &lt;var&gt;item-1&lt;/var&gt; argument may be an alphanumeric literal or a data item and &lt;var&gt;item-2&lt;/var&gt; must be a data item. The length of both &lt;var&gt;item-1&lt;/var&gt; and &lt;var&gt;item-2&lt;/var&gt; must be at least 8*&lt;var&gt;byte-length&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;item-1&lt;/var&gt; 과 &lt;var&gt;item-2&lt;/var&gt; 의 가장 왼쪽에있는 8 * &lt;var&gt;byte-length&lt;/var&gt; 해당하는 비트 사이를 처리 하여 결과 비트 문자열을 &lt;var&gt;item-2&lt;/var&gt; 에 저장합니다 . 왼쪽에 표시된 진리표는 &lt;code&gt;OR&lt;/code&gt; 프로세스를 문서화합니다 . &lt;var&gt;item-1&lt;/var&gt; 인수는 영숫자 문자 또는 데이터 항목 일 수있다 &lt;var&gt;item-2&lt;/var&gt; 데이터 항목이어야한다. &lt;var&gt;item-1&lt;/var&gt; 과 &lt;var&gt;item-2&lt;/var&gt; 의 길이는 모두 8 * 이상이어야합니다. &lt;var&gt;byte-length&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="ad64a736b990abada98a647e02830acf1bcd7c7d" translate="yes" xml:space="preserve">
          <source>process between the left-most 8*&lt;var&gt;byte-length&lt;/var&gt; corresponding bits of &lt;var&gt;item-1&lt;/var&gt; and &lt;var&gt;item-2&lt;/var&gt;, storing the resulting bit string into &lt;var&gt;item-2&lt;/var&gt;. The truth table shown to the left documents the &lt;code&gt;XOR&lt;/code&gt; process.   The &lt;var&gt;item-1&lt;/var&gt; argument may be an alphanumeric literal or a data item and &lt;var&gt;item-2&lt;/var&gt; must be a data item. The length of both &lt;var&gt;item-1&lt;/var&gt; and &lt;var&gt;item-2&lt;/var&gt; must be at least 8*&lt;var&gt;byte-length&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;item-1&lt;/var&gt; 과 &lt;var&gt;item-2&lt;/var&gt; 의 가장 왼쪽에있는 8 * &lt;var&gt;byte-length&lt;/var&gt; 해당하는 비트 사이를 처리 하여 결과 비트 문자열을 &lt;var&gt;item-2&lt;/var&gt; 에 저장합니다 . 왼쪽에 표시된 진리표는 &lt;code&gt;XOR&lt;/code&gt; 프로세스를 문서화합니다 . &lt;var&gt;item-1&lt;/var&gt; 인수는 영숫자 문자 또는 데이터 항목 일 수있다 &lt;var&gt;item-2&lt;/var&gt; 데이터 항목이어야한다. &lt;var&gt;item-1&lt;/var&gt; 과 &lt;var&gt;item-2&lt;/var&gt; 의 길이는 적어도 8 * &lt;var&gt;byte-length&lt;/var&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="f6830a1949c43eac237ae8af2e50dd85b2fad098" translate="yes" xml:space="preserve">
          <source>prog-name-area</source>
          <target state="translated">prog-name-area</target>
        </trans-unit>
        <trans-unit id="81d9aeea0e1a408d65b6660a176c5de83dc98e7b" translate="yes" xml:space="preserve">
          <source>program</source>
          <target state="translated">program</target>
        </trans-unit>
        <trans-unit id="7ca2597258912c52e810db1c329a57b3f6675549" translate="yes" xml:space="preserve">
          <source>program requiring it. This sharing allows the file to be opened, read and/or written and closed in different programs. This sharing applies to the record descriptions subordinate to the file description too.</source>
          <target state="translated">그것을 요구하는 프로그램. 이 공유를 통해 파일을 다른 프로그램에서 열고, 읽거나 쓰고 쓸 수 있습니다. 이 공유는 파일 설명에 종속 된 레코드 설명에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="14aeca04c4fe691bec4a99ab1466754ad67ef664" translate="yes" xml:space="preserve">
          <source>program will read:</source>
          <target state="translated">프로그램은 다음을 읽습니다 :</target>
        </trans-unit>
        <trans-unit id="1a8713bbf0aa6b03447fd0a82f9b4665956fa7be" translate="yes" xml:space="preserve">
          <source>program-id</source>
          <target state="translated">program-id</target>
        </trans-unit>
        <trans-unit id="006de2c31562e5d0ab0f9068e221b36c389cd38f" translate="yes" xml:space="preserve">
          <source>program-pointer</source>
          <target state="translated">program-pointer</target>
        </trans-unit>
        <trans-unit id="4645a2a90a791dddb4d4c1861422bcc7f36292b2" translate="yes" xml:space="preserve">
          <source>program-pointer-1</source>
          <target state="translated">program-pointer-1</target>
        </trans-unit>
        <trans-unit id="dc45bb2aa104feee9c1523199e61978d99ec09fd" translate="yes" xml:space="preserve">
          <source>program. Notice how the message indicating that the program detected the switch was set is displayed in both examples:</source>
          <target state="translated">프로그램. 프로그램이 스위치가 설정된 것을 감지했음을 나타내는 메시지가 두 예에서 어떻게 표시되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="cb6fef073fd712f286d487a67671c08ca29eb22f" translate="yes" xml:space="preserve">
          <source>pseudo-text-2</source>
          <target state="translated">pseudo-text-2</target>
        </trans-unit>
        <trans-unit id="22ea1c649c82946aa6e479e1ffd321e4a318b1b0" translate="yes" xml:space="preserve">
          <source>q</source>
          <target state="translated">q</target>
        </trans-unit>
        <trans-unit id="f0cccd21f830d2a19e8fd9e9d0e534af08c2b526" translate="yes" xml:space="preserve">
          <source>qut_GT, quz_BO, quz_EC, quz_PE</source>
          <target state="translated">qut_GT, quz_BO, quz_EC, quz_PE</target>
        </trans-unit>
        <trans-unit id="4dc7c9ec434ed06502767136789763ec11d2c4b7" translate="yes" xml:space="preserve">
          <source>r</source>
          <target state="translated">r</target>
        </trans-unit>
        <trans-unit id="326b9dbf58e4bda908b6a34b780b2d464209d711" translate="yes" xml:space="preserve">
          <source>raised to the power specified by &lt;var&gt;number&lt;/var&gt; (a numeric literal or data item).</source>
          <target state="translated">&lt;var&gt;number&lt;/var&gt; (숫자 리터럴 또는 데이터 항목)로 지정된 거듭 제곱으로 올립니다.</target>
        </trans-unit>
        <trans-unit id="a415ab5cc17c8c093c015ccdb7e552aee7911aa4" translate="yes" xml:space="preserve">
          <source>random</source>
          <target state="translated">random</target>
        </trans-unit>
        <trans-unit id="f3e98923daec75acd117be9e078c69e8354a2abd" translate="yes" xml:space="preserve">
          <source>read, is the FAQ available via the GnuCOBOL &lt;a href=&quot;https://gnucobol.sourceforge.io/#faq&quot;&gt;Manuals and Guides&lt;/a&gt;, although it could do with a wee clean up to ease reading and finding required information.</source>
          <target state="translated">읽기, GnuCOBOL을 통해 사용 가능한 FAQ입니다. &lt;a href=&quot;https://gnucobol.sourceforge.io/#faq&quot;&gt; 매뉴얼 및 가이드&lt;/a&gt; 이지만 필요한 정보를 쉽게 읽고 찾을 수 있도록 간단한 정리 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="275a700078f03f25e840fd7ed4d0be5d2e30e359" translate="yes" xml:space="preserve">
          <source>record</source>
          <target state="translated">record</target>
        </trans-unit>
        <trans-unit id="3bf21923c3325416a371c19c37d33f78c091a774" translate="yes" xml:space="preserve">
          <source>record satisfying the relation condition; to identify this record, the file&amp;rsquo;s contents are searched in a first-to-last (in sequence of the key implied by the&lt;code&gt;KEY&lt;/code&gt;clause), provided the relation is&lt;code&gt;EQUAL TO&lt;/code&gt;&lt;code&gt;GREATER THAN&lt;/code&gt;or&lt;code&gt;GREATER THAN OR EQUAL TO&lt;/code&gt;(or any of their syntactical equivalents).</source>
          <target state="translated">관계 조건을 만족시키는 기록; 이 레코드를 식별하기 위해, 파일의 내용이 검색됩니다 첫 번째 - 투 - 마지막으로 (에 의해 묵시적 키의 순서 &lt;code&gt;KEY&lt;/code&gt; 의 관계를 제공, 절)입니다 &lt;code&gt;EQUAL TO&lt;/code&gt; &lt;code&gt;GREATER THAN&lt;/code&gt; 나 &lt;code&gt;GREATER THAN OR EQUAL TO&lt;/code&gt; (또는 구문의 등가).</target>
        </trans-unit>
        <trans-unit id="b6d5d27d5286bf5026101f5e44bad4c5e54354b6" translate="yes" xml:space="preserve">
          <source>record satisfying the relation condition; to identify this record, the file&amp;rsquo;s contents are searched in a last-to-first (in sequence of the key implied by the&lt;code&gt;KEY&lt;/code&gt;clause), provided the relation is&lt;code&gt;LESS THAN&lt;/code&gt;&lt;code&gt;LESS THAN OR EQUAL TO&lt;/code&gt;or&lt;code&gt;NOT GREATER THAN&lt;/code&gt;(or any of their syntactical equivalents).</source>
          <target state="translated">관계 조건을 만족시키는 기록; 이 레코드를 식별하기 위해, 파일의 내용이 마지막에 - 첫 번째 (에 의해 묵시적 키의 순서로 검색됩니다 &lt;code&gt;KEY&lt;/code&gt; 의 관계를 제공, 절)입니다 &lt;code&gt;LESS THAN&lt;/code&gt; &lt;code&gt;LESS THAN OR EQUAL TO&lt;/code&gt; 나 &lt;code&gt;NOT GREATER THAN&lt;/code&gt; (또는 어떤 자신의 구문 상 등가).</target>
        </trans-unit>
        <trans-unit id="3c861ce72d0ce6ce67fc7ea82d4a0978ee226938" translate="yes" xml:space="preserve">
          <source>record satisfying the relation condition; to identify this record. The file&amp;rsquo;s contents are searched in a first-to-last (in sequence of the key implied by the &lt;code&gt;KEY&lt;/code&gt; clause), provided the relation is</source>
          <target state="translated">관계 조건을 만족하는 기록; 이 기록을 확인합니다. 파일의 내용은 처음부터 마지막으로 검색됩니다 ( &lt;code&gt;KEY&lt;/code&gt; 가 암시하는 키 순서대로). 절에서 ) 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="bf6ccf1b9108c9320dfeda537af978d16ae4fb22" translate="yes" xml:space="preserve">
          <source>record satisfying the relation condition; to identify this record. The file&amp;rsquo;s contents are searched in a last-to-first (in sequence of the key implied by the &lt;code&gt;KEY&lt;/code&gt; clause)</source>
          <target state="translated">관계 조건을 만족하는 기록; 이 기록을 확인합니다. 파일의 내용은 마지막에서 처음으로 검색됩니다 ( &lt;code&gt;KEY&lt;/code&gt; 절에서 ).</target>
        </trans-unit>
        <trans-unit id="7d8f2fc89c538ae3573d1e8a3d72aa08aa98f40b" translate="yes" xml:space="preserve">
          <source>record-name-1</source>
          <target state="translated">record-name-1</target>
        </trans-unit>
        <trans-unit id="fb9506353f30524544104665f5255b2d8a64dac8" translate="yes" xml:space="preserve">
          <source>records within the file, but not a locked record.</source>
          <target state="translated">파일 내에 기록되지만 잠긴 기록은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="201c8ed1b8f0fb92ffdbcdbd255a22b238d1c653" translate="yes" xml:space="preserve">
          <source>report-name-1</source>
          <target state="translated">report-name-1</target>
        </trans-unit>
        <trans-unit id="1d5efe8d7422891d97f22f5bb245ca1fbee5fedc" translate="yes" xml:space="preserve">
          <source>represent the column number (also starting at zero). There is no default data item allocated for this data if the &lt;code&gt;CURSOR IS&lt;/code&gt; clause is not specified, and it is the programmer&amp;rsquo;s responsibility to define &lt;var&gt;identifier-2&lt;/var&gt; if the clause is specified.</source>
          <target state="translated">열 번호를 나타냅니다 (또한 0에서 시작). &lt;code&gt;CURSOR IS&lt;/code&gt; 절이 지정되지 않은 경우이 데이터에 할당 된 기본 데이터 항목 이 없으며 &lt;var&gt;identifier-2&lt;/var&gt; 를 정의하는 것은 프로그래머의 책임입니다. 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="e7c57d80edd2b2c5f4bf1ae395f8c1bed93e1952" translate="yes" xml:space="preserve">
          <source>represent the row number (starting at zero) and</source>
          <target state="translated">행 번호 (0에서 시작)를 나타내고</target>
        </trans-unit>
        <trans-unit id="47104e2b70e98b356f6378a79d0fbc592a40bfc2" translate="yes" xml:space="preserve">
          <source>represents a space.</source>
          <target state="translated">공백을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="39cd0da2bcce352e16240351850beaa15810f391" translate="yes" xml:space="preserve">
          <source>represents the level number of the object, then no other data items with a level number numerically less than</source>
          <target state="translated">객체의 레벨 번호를 나타내며 레벨 번호가 숫자보다 작은 다른 데이터 항목은 없습니다.</target>
        </trans-unit>
        <trans-unit id="3fd7b2124f842551b8179241989b53b0d0eae735" translate="yes" xml:space="preserve">
          <source>represents the level number of the object, then no other data items with level number</source>
          <target state="translated">객체의 레벨 번호를 나타내며 레벨 번호가있는 다른 데이터 항목은 없습니다.</target>
        </trans-unit>
        <trans-unit id="6e7b17591deef9016b872824fdb508d92216b823" translate="yes" xml:space="preserve">
          <source>required to store it.</source>
          <target state="translated">그것을 저장하는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d6e7cd005c0ada962cf1ca31f4b64e6f45e1f24b" translate="yes" xml:space="preserve">
          <source>requires</source>
          <target state="translated">requires</target>
        </trans-unit>
        <trans-unit id="37a5301a88da334dc5afc5b63979daa0f3f45e68" translate="yes" xml:space="preserve">
          <source>result</source>
          <target state="translated">result</target>
        </trans-unit>
        <trans-unit id="9ba5ceb884fd6460da4c2340df57740ea5778c5b" translate="yes" xml:space="preserve">
          <source>result is the value which is moved to &amp;lt;</source>
          <target state="translated">결과는 &amp;lt;로 이동 한 값입니다.</target>
        </trans-unit>
        <trans-unit id="5907726112c3153de7dd4f5a1e022e090cd41946" translate="yes" xml:space="preserve">
          <source>result is the value which is moved to &lt;var&gt;identifier-4&lt;/var&gt;.</source>
          <target state="translated">결과는 &lt;var&gt;identifier-4&lt;/var&gt; 로 이동 된 값입니다 .</target>
        </trans-unit>
        <trans-unit id="136e120cce23aca8fca6696125188c2b1baa86c3" translate="yes" xml:space="preserve">
          <source>result. Additionally, only the &lt;code&gt;TALLYING&lt;/code&gt; clause may be specified.</source>
          <target state="translated">결과. 또한 &lt;code&gt;TALLYING&lt;/code&gt; 절만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16baccc36f9ebda34fff61982c26cfd8fcd0a383" translate="yes" xml:space="preserve">
          <source>result. Additionally, only the&lt;code&gt;TALLYING&lt;/code&gt;clause may be specified.</source>
          <target state="translated">결과. 또한 &lt;code&gt;TALLYING&lt;/code&gt; 절만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d25adff12aeca79ff39bbb8bb19fc4380115c08" translate="yes" xml:space="preserve">
          <source>return a return code, even if no&lt;code&gt;RETURNING&lt;/code&gt;or&lt;code&gt;STATUS&lt;/code&gt;clause is specified. In the absence of the use of these clauses, the value in the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) at the time the&lt;code&gt;STOP&lt;/code&gt;statement is executed will be used as the return code.</source>
          <target state="translated">&lt;code&gt;RETURNING&lt;/code&gt; 또는 &lt;code&gt;STATUS&lt;/code&gt; 절이 지정 되지 않은 경우에도 리턴 코드를 리턴하십시오 . 이 조항의 사용의 부재에서의 값 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터를&lt;/a&gt; 하여 시간) &lt;code&gt;STOP&lt;/code&gt; 의 문이 리턴 코드로 사용됩니다 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4b487f2769b2cd01919d36bb8914771655b37112" translate="yes" xml:space="preserve">
          <source>return an exit status, even if no &lt;code&gt;RETURNING&lt;/code&gt; or &lt;code&gt;STATUS&lt;/code&gt; clause is specified. In the absence of the use of these clauses, the value in the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) at the time the &lt;code&gt;STOP&lt;/code&gt; statement is executed will be used as the exit status.</source>
          <target state="translated">&lt;code&gt;RETURNING&lt;/code&gt; 또는 &lt;code&gt;STATUS&lt;/code&gt; 절이 지정 되지 않은 경우에도 종료 상태를 반환 합니다. 이 조항의 사용의 부재에서의 값 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; 시간 상기) &lt;code&gt;STOP&lt;/code&gt; 문은 종료 상태로 사용됩니다 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5bc45587e88faa8f15780a08e796216aafcf7257" translate="yes" xml:space="preserve">
          <source>return-code</source>
          <target state="translated">return-code</target>
        </trans-unit>
        <trans-unit id="d194afe1d8cc0b0e9bcfbbe1bfb2a7d8d66c97c3" translate="yes" xml:space="preserve">
          <source>revolutionary</source>
          <target state="translated">revolutionary</target>
        </trans-unit>
        <trans-unit id="6a7ef641dd9552f46f0ea72685cbccf06a072f6c" translate="yes" xml:space="preserve">
          <source>rm_CH, ro_RO, ru_RU, rw_RW</source>
          <target state="translated">rm_CH, ro_RO, ru_RU, rw_RW</target>
        </trans-unit>
        <trans-unit id="843cbacc61c8fe45886819ff1516e2e179374496" translate="yes" xml:space="preserve">
          <source>rr</source>
          <target state="translated">rr</target>
        </trans-unit>
        <trans-unit id="ff48cb77c2c17f5600b64e1410d077583c514d6b" translate="yes" xml:space="preserve">
          <source>rrcc</source>
          <target state="translated">rrcc</target>
        </trans-unit>
        <trans-unit id="8578173555a47d4ea49e697badfda270dee0858f" translate="yes" xml:space="preserve">
          <source>rrr</source>
          <target state="translated">rrr</target>
        </trans-unit>
        <trans-unit id="4439f8aa45de8805ac42465fb377262ee056d0da" translate="yes" xml:space="preserve">
          <source>rrrccc</source>
          <target state="translated">rrrccc</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
