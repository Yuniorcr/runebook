<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="gnu_cobol">
    <body>
      <group id="gnu_cobol">
        <trans-unit id="f547dc12438ab22b5b500d3ffc787450b4c04c18" translate="yes" xml:space="preserve">
          <source>Multiple-item search strings can be specified using the &lt;code&gt;==&lt;var&gt;pseudo-text-1&lt;/var&gt;==&lt;/code&gt; option. For example, to replace all occurrences of &lt;code&gt;UPON PRINTER&lt;/code&gt;, you would specify &lt;code&gt;==UPON PRINTER==&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;==&lt;var&gt;pseudo-text-1&lt;/var&gt;==&lt;/code&gt; 옵션을 사용하여 여러 항목 검색 문자열을 지정할 수 있습니다 . 예를 들어, &lt;code&gt;UPON PRINTER&lt;/code&gt; 의 모든 발생을 바꾸 려면 &lt;code&gt;==UPON PRINTER==&lt;/code&gt; 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="0c9327341de5e837b95068cae1399d3901498283" translate="yes" xml:space="preserve">
          <source>Multiple-item search strings can be specified using the&lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-1&lt;/i&gt;&amp;gt;==&lt;/code&gt;option. For example, to replace all occurrences of&lt;code&gt;UPON PRINTER&lt;/code&gt; you would specify&lt;code&gt;==UPON PRINTER==&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-1&lt;/i&gt;&amp;gt;==&lt;/code&gt; 옵션을 사용하여 여러 항목 검색 문자열을 지정할 수 있습니다 . 예를 들어, 모든 &lt;code&gt;UPON PRINTER&lt;/code&gt; 항목을 바꾸 려면 &lt;code&gt;==UPON PRINTER==&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="512c7a9b64ee7852d8007b60e8e382406285cb64" translate="yes" xml:space="preserve">
          <source>Multiple&lt;code&gt;/&lt;/code&gt;symbols may be coded.</source>
          <target state="translated">여러 개의 &lt;code&gt;/&lt;/code&gt; 기호가 코딩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bb573db89249b4de6d85f0d6303b423ef55f890" translate="yes" xml:space="preserve">
          <source>Multiple&lt;code&gt;0&lt;/code&gt;symbols may be coded.</source>
          <target state="translated">다수의 &lt;code&gt;0&lt;/code&gt; 심볼이 코딩 될 수있다.</target>
        </trans-unit>
        <trans-unit id="4e4e78bcc251379bcccaef2662ec5c92b786e53d" translate="yes" xml:space="preserve">
          <source>Multiple&lt;code&gt;B&lt;/code&gt;symbols may be coded.</source>
          <target state="translated">다수의 &lt;code&gt;B&lt;/code&gt; 심볼이 코딩 될 수있다.</target>
        </trans-unit>
        <trans-unit id="4272ab5411f12b91ef6d0e34934e3b2c6d362159" translate="yes" xml:space="preserve">
          <source>Multiply the result of this function times the desired principal amount to determine the amount of each period&amp;rsquo;s payment.</source>
          <target state="translated">이 함수의 결과에 원하는 원금 금액을 곱하여 각 기간의 지불 금액을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="ebfd18b697456992a7cea5cfb0d97d2bdb52017d" translate="yes" xml:space="preserve">
          <source>Murach&amp;rsquo;s Structured COBOL</source>
          <target state="translated">Murach의 구조화 된 COBOL</target>
        </trans-unit>
        <trans-unit id="4afe19d4a7d70ea4349c430b39697da2f281257d" translate="yes" xml:space="preserve">
          <source>My familiarity with COBOL may be prejudicing my opinion, but it doesn&amp;rsquo;t appear to me that the Java code is any simpler than the COBOL code. In case you&amp;rsquo;re interested in character counts, the Java code comes in at 278 (not counting indentation characters). The COBOL code is 298 (274 without the &lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt; header).</source>
          <target state="translated">COBOL에 대한 나의 친숙 함은 내 의견을 편견 할 수 있지만 Java 코드가 COBOL 코드보다 더 단순한 것 같지는 않습니다. 문자 수에 관심이있는 경우 Java 코드는 278 개로 표시됩니다 (들여 쓰기 문자는 포함되지 않음). COBOL 코드는 298 ( &lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt; 헤더가 없는 274 )입니다.</target>
        </trans-unit>
        <trans-unit id="257327ddfd98406ae03a0f3e1b7b410f8b01fe5e" translate="yes" xml:space="preserve">
          <source>My familiarity with COBOL may be prejudicing my opinion, but it doesn&amp;rsquo;t appear to me that the Java code is any simpler than the COBOL code. In case you&amp;rsquo;re interested in character counts, the Java code comes in at 278 (not counting indentation characters). The COBOL code is 298 (274 without the&lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt;header).</source>
          <target state="translated">COBOL에 대해 잘 알고 있으면 내 의견이 편견 일 수 있지만 Java 코드가 COBOL 코드보다 간단한 것으로 보이지는 않습니다. 문자 수에 관심이있는 경우 Java 코드는 278 (들여 쓰기 문자는 제외)로 제공됩니다. COBOL 코드는 298입니다 ( &lt;code&gt;IDENTIFICATION DIVISION.&lt;/code&gt; 헤더가 없는 274 ).</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="4813c2e244b49602a6107537b9c8810d6cb7377f" translate="yes" xml:space="preserve">
          <source>N/2</source>
          <target state="translated">N/2</target>
        </trans-unit>
        <trans-unit id="8841ca9cf4a3d6697ad899f49ceee826a96da464" translate="yes" xml:space="preserve">
          <source>N/A (no GnuCOBOL equivalent)</source>
          <target state="translated">해당 없음 (GnuCOBOL에 해당 없음)</target>
        </trans-unit>
        <trans-unit id="456048850e9d09e5cbfde5c2a6be5799c526a49a" translate="yes" xml:space="preserve">
          <source>NAME, NATIONAL, NATIONAL-EDITED, NATIONAL-OF, NATIVE, NEAREST-AWAY-FROM-ZERO, NEAREST-EVEN, NEAREST-TOWARD-ZERO, NEGATIVE, NESTED, NEXT, NO, NO-ECHO, NONE, NORMAL, NOT, NOTHING, NULL, NULLS, NUMBER, NUMBER-OF-CALL-PARAMETERS, NUMBERS, NUMERIC, NUMERIC-DECIMAL-POINT, NUMERIC-EDITED, NUMERIC-THOUSANDS-SEPARATOR, NUMVAL, NUMVAL-C, NUMVAL-F</source>
          <target state="translated">NAME, NATIONAL, NATIONAL-EDITED, NATIONAL-OF, NATIVE, ANEEST-AWAY-FROM-ZERO, NESTEST-EVEN, NEAREST-TOWARD-ZERO, NEGATIVE, NESTED, NEXT, NO, NO-ECHO, NONE, NORMAL, NOT, NOTHING, NULL, NULLS, NUMBER, NUMBER-OF-CALL-PARAMETERS, NUMBERS, NUMERIC, NUMERIC-DECIMAL-POINT, NUMERIC-EDITED, NUMERIC-THOUSANDS-SEPARATOR, NUMVAL, NUMVAL-C, NUMVAL-F</target>
        </trans-unit>
        <trans-unit id="12a4ea36a49cd885f134496f6c7b205e0d1b8c27" translate="yes" xml:space="preserve">
          <source>NAME, NATIONAL-EDITED, NATIONAL-OF, NATIONAL, NATIVE, NAVIGATE-URL, NEAREST-AWAY-FROM-ZERO, NEAREST-EVEN, NEAREST-TOWARD-ZERO, NEGATIVE, NESTED, NEW, NEXT-ITEM, NEXT, NO-AUTO-DEFAULT, NO-AUTOSEL, NO-BOX, NO-DIVIDERS, NO-ECHO, NO-F4, NO-FOCUS, NO-GROUP-TAB, NO-KEY-LETTER, NONE, NORMAL, NO-SEARCH, NOTAB, NOTHING, NOTIFY-CHANGE, NOTIFY-DBLCLICK, NOTIFY-SELCHANGE, NOTIFY, NOT, NO-UPDOWN, NO, NULLS, NULL, NUMBER-OF-CALL-PARAMETERS, NUMBERS, NUMBER, NUM-COL-HEADINGS, NUMERIC-DECIMAL-POINT, NUMERIC-EDITED, NUMERIC-THOUSANDS-SEPARATOR, NUMERIC, NUM-ROWS, NUMVAL-C, NUMVAL-F, NUMVAL</source>
          <target state="translated">NAME, NATIONAL-EDITED, NATIONAL-OF, NATIONAL, NATIVE, NAVIGATE-URL, NEAREST-AWAY-FROM-ZERO, NEAREST-EVEN, NEAREST-TOWARD-ZERO, NEGATIVE, NESTED, NEW, NEXT-ITEM, NEXT, NO- 자동 기본값, 자동 없음, 상자 없음, 분할 자 없음, 에코 없음, F4 없음, 초점 없음, 그룹 탭 없음, 키 문자 없음, 없음, 일반, 검색 없음, 알림, 알림 없음, 자동 기본값, NO-AUTOSEL, NO-BOX, NO-DIVIDERS, NO-ECHO, NO-F4, NO-FOCUS, NO-GROUP-TAB, NO-KEY-LETTER, NONE, NORMAL, NO-SEARCH, NOTAB, NOTHING, NOTIFY-CHANGE, NOTIFY-DBLCLICK, NOTIFY-SELCHANGE, NOTIFY, NOT, NO-UPDOWN, NO, NULLS, NULL, NUMBER-OF-CALL-PARAMETERS, NUMBERS, NUMBER, NUM-COL-HEADINGS, NUMERIC-DECIMAL- POINT, NUMERIC-EDITED, NUMERIC-THOUSANDS-SEPARATOR, NUMERIC, NUM-ROWS, NUMVAL-C, NUMVAL-F, NUMVAL</target>
        </trans-unit>
        <trans-unit id="f949d8c36379cf9fe5e5fb919bc3184c4b16697b" translate="yes" xml:space="preserve">
          <source>NATIONAL</source>
          <target state="translated">NATIONAL</target>
        </trans-unit>
        <trans-unit id="fae23f1189e3d3029fc3bbc84fee5a14e571aa43" translate="yes" xml:space="preserve">
          <source>NATIONAL-EDITED</source>
          <target state="translated">NATIONAL-EDITED</target>
        </trans-unit>
        <trans-unit id="2ded80afcde5b3617fd0cdaa426a25c2c07b25aa" translate="yes" xml:space="preserve">
          <source>NATIONAL-OF Function Syntax</source>
          <target state="translated">NATIONAL-OF 함수 구문</target>
        </trans-unit>
        <trans-unit id="9f621eb5fd3bcb2fa5c7bd228c9b1ad42edc46c8" translate="yes" xml:space="preserve">
          <source>NEWS</source>
          <target state="translated">NEWS</target>
        </trans-unit>
        <trans-unit id="23579a7244afbe343b0ef7777f40fe65dd6d391f" translate="yes" xml:space="preserve">
          <source>NEXT-GROUP Clause Syntax</source>
          <target state="translated">다음 그룹 절 구문</target>
        </trans-unit>
        <trans-unit id="26eb9f7afcd3204c7dddc57725c1467cf0c79148" translate="yes" xml:space="preserve">
          <source>NO Field</source>
          <target state="translated">필드 없음</target>
        </trans-unit>
        <trans-unit id="4fd04833b3755cfdf59219f364a4c19cf95dcc36" translate="yes" xml:space="preserve">
          <source>NO-ECHO Attribute Syntax</source>
          <target state="translated">NO-ECHO 속성 구문</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="a9ea4f7a4f03a9c52a7aa0d54a54e0ee6d21feed" translate="yes" xml:space="preserve">
          <source>NOTE that CBL_GC_PRINTABLE replaces this although it is currently still supported for legacy reasons.</source>
          <target state="translated">CBL_GC_PRINTABLE은 현재 레거시 이유로 여전히 지원되지만이를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="58ad270de77802cc63222e273fa800c4b248cdd7" translate="yes" xml:space="preserve">
          <source>NUMERIC</source>
          <target state="translated">NUMERIC</target>
        </trans-unit>
        <trans-unit id="1c7a5d29d866f9947d87ce89b623e7dcee44fb1b" translate="yes" xml:space="preserve">
          <source>NUMERIC-DECIMAL-POINT Function Syntax</source>
          <target state="translated">NUMERIC-DECIMAL-POINT 함수 구문</target>
        </trans-unit>
        <trans-unit id="6517b42cd023209f5cc4861083a3c58f87384484" translate="yes" xml:space="preserve">
          <source>NUMERIC-EDITED</source>
          <target state="translated">NUMERIC-EDITED</target>
        </trans-unit>
        <trans-unit id="0f7032d6214932877eaeb90684d8b5e91b84fe2d" translate="yes" xml:space="preserve">
          <source>NUMERIC-THOUSANDS-SEPARATOR Function Syntax</source>
          <target state="translated">숫자-천 단위 구분자 함수 구문</target>
        </trans-unit>
        <trans-unit id="24a2cb0031362dfda9217165484fefd16498a931" translate="yes" xml:space="preserve">
          <source>NUMVAL Function Syntax</source>
          <target state="translated">NUMVAL 함수 구문</target>
        </trans-unit>
        <trans-unit id="31988bddc5cc6a4166042e84de6cbd874cb74a99" translate="yes" xml:space="preserve">
          <source>NUMVAL-C Function Syntax</source>
          <target state="translated">NUMVAL-C 함수 구문</target>
        </trans-unit>
        <trans-unit id="ae21c526020f5a22401b17f7aa4bfb1762439159" translate="yes" xml:space="preserve">
          <source>NUMVAL-F Function Syntax</source>
          <target state="translated">NUMVAL-F 함수 구문</target>
        </trans-unit>
        <trans-unit id="057d3c3f4e6e8dc1ec58c53e9789c01dd0b62e89" translate="yes" xml:space="preserve">
          <source>National Character set</source>
          <target state="translated">자국 문자 세트</target>
        </trans-unit>
        <trans-unit id="d7d37c587c780599f710ed6affbe68a1bcf357e7" translate="yes" xml:space="preserve">
          <source>National Literals (Hexadecimal) &lt;code&gt;NX&quot;&lt;var&gt; character &lt;/var&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">National Literals (16 진수) &lt;code&gt;NX&quot;&lt;var&gt; character &lt;/var&gt;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c447eed62bdd87000db9fc4992f2863a32144f5" translate="yes" xml:space="preserve">
          <source>National Literals (Standard) &lt;code&gt;N&quot;&lt;var&gt; character &lt;/var&gt;&quot;&lt;/code&gt; or &lt;code&gt;NC&quot;&lt;var&gt; character &lt;/var&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">National Literals (표준) &lt;code&gt;N&quot;&lt;var&gt; character &lt;/var&gt;&quot;&lt;/code&gt; 또는 &lt;code&gt;NC&quot;&lt;var&gt; character &lt;/var&gt;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4245f0ee71bd17093500ac16c41a1dd1b33008e5" translate="yes" xml:space="preserve">
          <source>Native Binary Integer</source>
          <target state="translated">기본 이진 정수</target>
        </trans-unit>
        <trans-unit id="3f00afda761d5e13a699220ac15df2aa008259c3" translate="yes" xml:space="preserve">
          <source>Native IEEE 754 Binary32</source>
          <target state="translated">네이티브 IEEE 754 Binary32</target>
        </trans-unit>
        <trans-unit id="38d71bfaf2af5e86c02dd007bae5cd22e8350547" translate="yes" xml:space="preserve">
          <source>Native IEEE 754 Binary64 Floating-point</source>
          <target state="translated">기본 IEEE 754 Binary64 부동 소수점</target>
        </trans-unit>
        <trans-unit id="4775cd57bf8ad48397acf03e156ee31bbc505817" translate="yes" xml:space="preserve">
          <source>Native IEEE 754 Decimal128 Floating-point</source>
          <target state="translated">기본 IEEE 754 Decimal128 부동 소수점</target>
        </trans-unit>
        <trans-unit id="1579bca067a63e4a82df0092b6bb19e611a1879b" translate="yes" xml:space="preserve">
          <source>Native IEEE 754 Decimal64 Floating-point</source>
          <target state="translated">기본 IEEE 754 Decimal64 부동 소수점</target>
        </trans-unit>
        <trans-unit id="663645109bc4810ff83f3fcb9242af60d6271f15" translate="yes" xml:space="preserve">
          <source>Native unsigned (X) or signed (9) Binary</source>
          <target state="translated">네이티브 부호없는 (X) 또는 부호있는 (9) 이진</target>
        </trans-unit>
        <trans-unit id="0bb1805002fe928c11731e2fe434c6710e0546aa" translate="yes" xml:space="preserve">
          <source>Negated Condition Syntax</source>
          <target state="translated">부정 조건 구문</target>
        </trans-unit>
        <trans-unit id="b258f825a32604b32cf66b5f27af5bbeed3d0dbd" translate="yes" xml:space="preserve">
          <source>Negative Values Allowed?:</source>
          <target state="translated">허용되는 음수? :</target>
        </trans-unit>
        <trans-unit id="569eabdf4b8f2757a51f46ddb9444a185ebc7cb4" translate="yes" xml:space="preserve">
          <source>Negative values are returned for system dependand error codes and -1 if the function is not available on the current system.</source>
          <target state="translated">시스템 종속 오류 코드에 대해 음수 값이 리턴되고 현재 시스템에서 기능을 사용할 수없는 경우 -1이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e749bae177f75d382ea705f34562fdde16594e75" translate="yes" xml:space="preserve">
          <source>Negative values are returned for system dependant error codes and -1 if the function is not available on the current system.</source>
          <target state="translated">시스템 종속 오류 코드에 대해 음수 값이 반환되고 현재 시스템에서 함수를 사용할 수없는 경우 -1이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fac968968fa4c7a06b3ca207e37616b4cf010c7c" translate="yes" xml:space="preserve">
          <source>Neither &amp;lt;</source>
          <target state="translated">둘 다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="498053453b61f2ca863574cf728e4c26d5207770" translate="yes" xml:space="preserve">
          <source>Neither &lt;code&gt;EXIT PROGRAM&lt;/code&gt; nor &lt;code&gt;EXIT FUNCTION&lt;/code&gt; may be used within a &lt;code&gt;USE GLOBAL&lt;/code&gt; routine in &lt;code&gt;DECLARATIVES&lt;/code&gt; (see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;).</source>
          <target state="translated">어느 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 이나 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 내에서 사용할 수 있습니다 &lt;code&gt;USE GLOBAL&lt;/code&gt; 의 일상 &lt;code&gt;DECLARATIVES&lt;/code&gt; (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a648c3eef2063a295935657ca99ab8899d91bea3" translate="yes" xml:space="preserve">
          <source>Neither &lt;var&gt;argument-1&lt;/var&gt; nor &lt;var&gt;argument-2&lt;/var&gt; shall be a zero-length literal.</source>
          <target state="translated">둘 다 &lt;var&gt;argument-1&lt;/var&gt; 이나 &lt;var&gt;argument-2&lt;/var&gt; 길이 제로의 문자가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="eecfe7e804c7ffe3b279ae24497f834970036015" translate="yes" xml:space="preserve">
          <source>Neither &lt;var&gt;data-item-1&lt;/var&gt; nor &lt;var&gt;data-item-2&lt;/var&gt; may be a &lt;code&gt;REDEFINES&lt;/code&gt; (see &lt;a href=&quot;#REDEFINES&quot;&gt;REDEFINES&lt;/a&gt;) or &lt;code&gt;RENAMES&lt;/code&gt; (see &lt;a href=&quot;#RENAMES&quot;&gt;RENAMES&lt;/a&gt;) of another data item.</source>
          <target state="translated">어느 &lt;var&gt;data-item-1&lt;/var&gt; 나 &lt;var&gt;data-item-2&lt;/var&gt; 수있다 &lt;code&gt;REDEFINES&lt;/code&gt; (참조 &lt;a href=&quot;#REDEFINES&quot;&gt;REDEFINES을&lt;/a&gt; ) 또는 &lt;code&gt;RENAMES&lt;/code&gt; (참조 &lt;a href=&quot;#RENAMES&quot;&gt;이름 변경을&lt;/a&gt; 다른 데이터 항목).</target>
        </trans-unit>
        <trans-unit id="c3f3857d67ae94f8d7cddd5329535889cff6638b" translate="yes" xml:space="preserve">
          <source>Neither &lt;var&gt;data-item-1&lt;/var&gt; nor &lt;var&gt;data-item-2&lt;/var&gt; may have an &lt;code&gt;OCCURS&lt;/code&gt; (see &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt;) clause, although either may contain subordinate data items that</source>
          <target state="translated">어느 &lt;var&gt;data-item-1&lt;/var&gt; 나 &lt;var&gt;data-item-2&lt;/var&gt; 가질 수 &lt;code&gt;OCCURS&lt;/code&gt; (참고는 &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt; 하나가 하위 데이터 항목을 포함 할 수 있지만) 제 그런</target>
        </trans-unit>
        <trans-unit id="929c909c77bbcdec7cb09699977c322ae8085237" translate="yes" xml:space="preserve">
          <source>Neither a another file-based &lt;code&gt;SORT&lt;/code&gt; statement nor a &lt;code&gt;MERGE&lt;/code&gt; statement may be executed within the input procedure unless those statements utilize a different sort or merge work file.</source>
          <target state="translated">다른 파일 기반 &lt;code&gt;SORT&lt;/code&gt; 문이나 &lt;code&gt;MERGE&lt;/code&gt; 문은 다른 정렬 또는 병합 작업 파일을 사용하지 않는 한 입력 프로 시저 내에서 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0fa3e63c5ae8e3d45d610e9d28aaa33d956a0776" translate="yes" xml:space="preserve">
          <source>Neither a another file-based &lt;code&gt;SORT&lt;/code&gt; statement nor a &lt;code&gt;MERGE&lt;/code&gt; statement may be executed within the output procedure unless those statements utilize a different sort or merge work file.</source>
          <target state="translated">다른 파일 기반 &lt;code&gt;SORT&lt;/code&gt; 문이나 &lt;code&gt;MERGE&lt;/code&gt; 문은 해당 문이 다른 정렬 또는 병합 작업 파일을 사용하지 않는 한 출력 프로 시저 내에서 실행될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dcdcf73a59a8f2ad5bc285a8314df00761fcb686" translate="yes" xml:space="preserve">
          <source>Neither a another file-based&lt;code&gt;SORT&lt;/code&gt;statement nor a&lt;code&gt;MERGE&lt;/code&gt;statement may be executed within the input procedure unless those statements utilize a different sort or merge work file.</source>
          <target state="translated">다른 파일 기반 &lt;code&gt;SORT&lt;/code&gt; 문이나 &lt;code&gt;MERGE&lt;/code&gt; 문은 다른 정렬 또는 병합 작업 파일을 사용하지 않는 한 입력 프로 시저 내에서 실행될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="24fe46648b02cf0f40c1f64b86fe9a8a1b238380" translate="yes" xml:space="preserve">
          <source>Neither a another file-based&lt;code&gt;SORT&lt;/code&gt;statement nor a&lt;code&gt;MERGE&lt;/code&gt;statement may be executed within the output procedure unless those statements utilize a different sort or merge work file.</source>
          <target state="translated">다른 정렬 또는 병합 작업 파일을 사용하지 않는 한 다른 파일 기반 &lt;code&gt;SORT&lt;/code&gt; 문이나 &lt;code&gt;MERGE&lt;/code&gt; 문은 출력 프로 시저 내에서 실행될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="084a96e3a60e16d19485d2d34359397510465247" translate="yes" xml:space="preserve">
          <source>Neither a file-based &lt;code&gt;SORT&lt;/code&gt; statement (see &lt;a href=&quot;#File_002dBased-SORT&quot;&gt;File-Based SORT&lt;/a&gt;) nor another &lt;code&gt;MERGE&lt;/code&gt; statement may be executed within the scope of the procedures comprising the output procedure unless those statements utilize a different sort or merge work file.</source>
          <target state="translated">파일 기반 &lt;code&gt;SORT&lt;/code&gt; 문 ( &lt;a href=&quot;#File_002dBased-SORT&quot;&gt;파일 기반 SORT&lt;/a&gt; 참조 )이나 다른 &lt;code&gt;MERGE&lt;/code&gt; 문은 해당 문이 다른 정렬 또는 병합 작업 파일을 사용하지 않는 한 출력 프로 시저를 구성하는 프로 시저의 범위 내에서 실행될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a3ec78fb2431caff148e7bb1cf8ea0ff18e700c" translate="yes" xml:space="preserve">
          <source>Neither a file-based&lt;code&gt;SORT&lt;/code&gt;statement (see &lt;a href=&quot;#File_002dBased-SORT&quot;&gt;File-Based SORT&lt;/a&gt;) nor another&lt;code&gt;MERGE&lt;/code&gt;statement may be executed within the scope of the procedures comprising the output procedure unless those statements utilize a different sort or merge work file.</source>
          <target state="translated">파일 기반 &lt;code&gt;SORT&lt;/code&gt; 문 ( &lt;a href=&quot;#File_002dBased-SORT&quot;&gt;File-Based SORT&lt;/a&gt; 참조 )이나 다른 &lt;code&gt;MERGE&lt;/code&gt; 문은 다른 정렬 또는 병합 작업 파일을 사용하지 않는 한 출력 프로 시저를 구성하는 프로 시저 범위 내에서 실행될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="09d241bd244c403aca378ac0d0df2d3a90b6406f" translate="yes" xml:space="preserve">
          <source>Neither the presence of an encoded digit (see above) nor an actual &amp;lsquo;</source>
          <target state="translated">인코딩 된 숫자 (위 참조) 나 실제 '</target>
        </trans-unit>
        <trans-unit id="cc989bf49db06aa48ebb1422a2de0e6c00423d9d" translate="yes" xml:space="preserve">
          <source>Neither the presence of an encoded digit (see above) nor an actual&lt;code&gt;+&lt;/code&gt;or&lt;code&gt;-&lt;/code&gt;character embedded within the data item&amp;rsquo;s storage prevents the data item from being used as a source field in arithmetic operations.</source>
          <target state="translated">인코딩 된 숫자 (위 참조)가 존재하지 않거나 데이터 항목의 저장소에 실제 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 문자가 포함되어 있어도 데이터 항목이 산술 연산에서 소스 필드로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5e391e55efc04c3c0f99e29e799c743a6b88a5c" translate="yes" xml:space="preserve">
          <source>Neither the value of &amp;lt;</source>
          <target state="translated">&amp;lt;의 값 모두</target>
        </trans-unit>
        <trans-unit id="8ba6eef8eac3b809b7c7d9d4c566295fcd67b555" translate="yes" xml:space="preserve">
          <source>Neither the value of &lt;var&gt;identifier-1&lt;/var&gt; nor &lt;var&gt;identifier-2&lt;/var&gt; will be altered, unless either appears as an &lt;var&gt;identifier-3&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;identifier-3&lt;/var&gt; 으로 나타나지 않는 한 &lt;var&gt;identifier-1&lt;/var&gt; 과 &lt;var&gt;identifier-2&lt;/var&gt; 값은 변경되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a8d23bd6a6b56505c754a0566832b43e6c7deddd" translate="yes" xml:space="preserve">
          <source>Neither&lt;code&gt;EXIT PROGRAM&lt;/code&gt;nor&lt;code&gt;EXIT FUNCTION&lt;/code&gt;may be used within a&lt;code&gt;USE GLOBAL&lt;/code&gt;routine in&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;).</source>
          <target state="translated">어느 &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 이나 &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 내에서 사용할 수 있습니다 &lt;code&gt;USE GLOBAL&lt;/code&gt; 의 일상 &lt;code&gt;DECLARATIVES&lt;/code&gt; (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2ef44da87cf7da408056f5b8df3aee8b08f3e63d" translate="yes" xml:space="preserve">
          <source>Nested Subprograms</source>
          <target state="translated">중첩 서브 프로그램</target>
        </trans-unit>
        <trans-unit id="02345bc4e59618249ddd33b89a552e74eefc9cca" translate="yes" xml:space="preserve">
          <source>New programs requiring a stand-alone elementary item should be coded to use a level number of 01 rather than 77.</source>
          <target state="translated">독립형 기본 항목이 필요한 새 프로그램은 77이 아닌 01의 레벨 번호를 사용하도록 코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="2cb277bcf0e845a7751a4837a56f660c664aab62" translate="yes" xml:space="preserve">
          <source>Next, the &lt;code&gt;CONTROL HEADING&lt;/code&gt; for each &lt;var&gt;identifier-2&lt;/var&gt; having a control break (if any such report group is defined) will be presented.</source>
          <target state="translated">다음으로, &lt;code&gt;CONTROL HEADING&lt;/code&gt; 이있는 각 &lt;var&gt;identifier-2&lt;/var&gt; 에 대한 CONTROL HEADING (해당 보고서 그룹이 정의 된 경우)이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cb2f4a912a9c59ceb0b74adc342b766667a643e7" translate="yes" xml:space="preserve">
          <source>Next, the&lt;code&gt;CONTROL HEADING&lt;/code&gt;for each &amp;lt;</source>
          <target state="translated">다음에, &lt;code&gt;CONTROL HEADING&lt;/code&gt; 각 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="25ca8cc06f258fc623523fef33154141cdf7a832" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;INVALID KEY&lt;/code&gt; or &lt;code&gt;NOT INVALID KEY&lt;/code&gt; clause may be specified for a file who&amp;rsquo;s &lt;code&gt;ACCESS MODE IS SEQUENTIAL&lt;/code&gt;.</source>
          <target state="translated">아니 &lt;code&gt;INVALID KEY&lt;/code&gt; 또는 &lt;code&gt;NOT INVALID KEY&lt;/code&gt; 의 절의 파일을 지정할 수 있습니다 &lt;code&gt;ACCESS MODE IS SEQUENTIAL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="139b832f1804c5099e18b43d42448f0f0b6e7c9b" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;OCCURS&lt;/code&gt; (see &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt;) clause may be part of the definition of either the subject or object data items. Either or both, however, may be group items that</source>
          <target state="translated">없음 &lt;code&gt;OCCURS&lt;/code&gt; (참조가 &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt; ) 절은 주체 또는 객체 데이터 항목 중 하나의 정의의 일부가 될 수 있습니다. 그러나 둘 중 하나 또는 둘 다</target>
        </trans-unit>
        <trans-unit id="acf76423a3c2a77929eaada12f5c72ae1776e93a" translate="yes" xml:space="preserve">
          <source>No &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause may be defined on the object data item, and no data items subordinate to the object data item may have &lt;code&gt;VALUE&lt;/code&gt; clauses, with the exception of level-88 condition names.</source>
          <target state="translated">없음 &lt;code&gt;VALUE&lt;/code&gt; 없습니다 (참조 &lt;a href=&quot;#VALUE&quot;&gt;VALUE를&lt;/a&gt; ) 절 오브젝트 데이터 항목을 정의 할 수 있고, 가질 수있는 객체 데이터 항목에 종속 데이터가없는 항목 &lt;code&gt;VALUE&lt;/code&gt; 의 레벨 88의 조건 이름을 제외하고 절을.</target>
        </trans-unit>
        <trans-unit id="1a6b2761c5a03cb41776cc1a48760cf197b63fc7" translate="yes" xml:space="preserve">
          <source>No data is available on screen ACCEPT</source>
          <target state="translated">ACCEPT 화면에 데이터가 없습니다</target>
        </trans-unit>
        <trans-unit id="4062206b6830d356f4eb1c6e0802aad55b74b161" translate="yes" xml:space="preserve">
          <source>No more than 251 arguments may be passed to a subroutine, unless the GnuCOBOL compiler was built with a specifically different argument limit specified for it. If you have access to the GnuCOBOL source code, you may adjust this limit by changing the value of the &lt;code&gt;COB_MAX_FIELD_PARAMS&lt;/code&gt; in the</source>
          <target state="translated">GnuCOBOL 컴파일러가 특별히 다른 인수 제한을 지정하여 빌드하지 않는 한 251 개 이하의 인수를 서브 루틴에 전달할 수 있습니다. 당신이 GnuCOBOL 소스 코드에 액세스 할 수있는 경우의 값을 변경하여이 제한을 조정할 수 있습니다 &lt;code&gt;COB_MAX_FIELD_PARAMS&lt;/code&gt; 을 에</target>
        </trans-unit>
        <trans-unit id="22f4fdea4baac33f85e6d27a113ce40e1b051a05" translate="yes" xml:space="preserve">
          <source>No more than 36 arguments may be passed to a subroutine, unless the GnuCOBOL compiler was built with a specifically different argument limit specified for it. If you have access to the GnuCOBOL source code, you may adjust this limit by changing the value of the&lt;code&gt;COB_MAX_FIELD_PARAMS&lt;/code&gt;in the&lt;code&gt;common.h&lt;/code&gt;file (found in the&lt;code&gt;libcob&lt;/code&gt;folder) before you run&lt;code&gt;make&lt;/code&gt;to build the compiler and run-time library.</source>
          <target state="translated">GnuCOBOL 컴파일러가 특별히 다른 인수 제한으로 지정된 경우를 제외하고는 36 개의 인수 만 서브 루틴에 전달 될 수 없습니다. 당신이 GnuCOBOL 소스 코드에 액세스 할 수있는 경우, 당신은의 값을 변경하여이 제한을 조정할 수 있습니다 &lt;code&gt;COB_MAX_FIELD_PARAMS&lt;/code&gt; 에서 &lt;code&gt;common.h&lt;/code&gt; 의 파일을 삭제합니다 (에서 발견 &lt;code&gt;libcob&lt;/code&gt; 의 당신이 실행하기 전에 폴더) &lt;code&gt;make&lt;/code&gt; 컴파일러와 런타임 라이브러리를 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0b56017138fce867253042d601fa10f962235f8" translate="yes" xml:space="preserve">
          <source>No report content will actually presented to the report file as a result of a successful &lt;code&gt;INITIATE&lt;/code&gt; statement &amp;mdash; that will not occur until the first &lt;code&gt;GENERATE&lt;/code&gt; statement (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) is executed.</source>
          <target state="translated">성공적인 &lt;code&gt;INITIATE&lt;/code&gt; 문의 결과로 보고서 파일에 실제로 보고서 내용이 표시 되지 않습니다. 이는 첫 번째 &lt;code&gt;GENERATE&lt;/code&gt; 문 ( &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt; 참조 )이 실행될 때까지 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9d5b904086ff2a2ac1ab9032a0b17994d3c8146f" translate="yes" xml:space="preserve">
          <source>No report content will actually presented to the report file as a result of a successful&lt;code&gt;INITIATE&lt;/code&gt;statement &amp;mdash; that will not occur until the first&lt;code&gt;GENERATE&lt;/code&gt;statement (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) is executed.</source>
          <target state="translated">성공적인 &lt;code&gt;INITIATE&lt;/code&gt; 문의 결과로 보고서 내용이 실제로 보고서 파일 에 표시되지 않습니다. 이는 첫 번째 &lt;code&gt;GENERATE&lt;/code&gt; 문 ( &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt; 참조 )이 실행될 때까지 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="11eee78dfa316d6cb7ec5797854112dec4eef327" translate="yes" xml:space="preserve">
          <source>No rounding is performed. If the value cannot be represented exactly in the desired format, the &lt;code&gt;EC-SIZE-TRUNCATION&lt;/code&gt; condition (exception code 1005) is set (and may be retrieved via the &lt;code&gt;ACCEPT&lt;/code&gt; (see &lt;a href=&quot;#ACCEPT-FROM-Runtime_002dInfo&quot;&gt;ACCEPT FROM Runtime-Info&lt;/a&gt;) statement) and the results of the operation are undefined.</source>
          <target state="translated">반올림이 수행되지 않습니다. 값을 원하는 형식으로 정확하게 표현할 수없는 경우 &lt;code&gt;EC-SIZE-TRUNCATION&lt;/code&gt; 조건 (예외 코드 1005)이 설정되고 &lt;code&gt;ACCEPT&lt;/code&gt; ( &lt;a href=&quot;#ACCEPT-FROM-Runtime_002dInfo&quot;&gt;ACCEPT FROM Runtime-Info&lt;/a&gt; 문 참조) 문을 통해 검색 할 수 있으며 작업 결과 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="841e2fb51fda0ae1893e020320984500822af311" translate="yes" xml:space="preserve">
          <source>No rounding is performed. If the value cannot be represented exactly in the desired format, the EC-SIZE-TRUNCATION condition (exception code 1005) is set (and may be retrieved via the&lt;code&gt;ACCEPT&lt;/code&gt;(see &lt;a href=&quot;#ACCEPT-FROM-Runtime_002dInfo&quot;&gt;ACCEPT FROM Runtime-Info&lt;/a&gt;) statement) and the results of the operation are undefined.</source>
          <target state="translated">반올림이 수행되지 않습니다. 값을 원하는 형식으로 정확하게 표현할 수없는 경우 EC-SIZE-TRUNCATION 조건 (예외 코드 1005)이 설정되고 &lt;code&gt;ACCEPT&lt;/code&gt; ( &lt;a href=&quot;#ACCEPT-FROM-Runtime_002dInfo&quot;&gt;ACCEPT FROM Runtime-Info 참조&lt;/a&gt; ) 문을 통해 검색 될 수 있으며 작업 결과 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="eae4ac248869b9a9f5a910afc02caead622a3640" translate="yes" xml:space="preserve">
          <source>No special meaning &amp;mdash; this is the normal character that will appear in this area.</source>
          <target state="translated">특별한 의미는 없습니다. 이것은이 영역에 나타날 일반적인 문자입니다.</target>
        </trans-unit>
        <trans-unit id="0cfdaae490927c423f2c8197638d2a8e5c4b9c06" translate="yes" xml:space="preserve">
          <source>No storage is allocated for data defined in the linkage section; the data descriptions there are merely defining storage areas that will be passed to the subprogram by a calling program. Therefore, any discussion of the default initialization of such data is irrelevant. It</source>
          <target state="translated">연계 섹션에 정의 된 데이터에 스토리지가 할당되지 않습니다. 데이터 설명은 호출 프로그램에 의해 서브 프로그램으로 전달 될 저장 영역을 정의하기 만합니다. 따라서 이러한 데이터의 기본 초기화에 대한 설명은 관련이 없습니다. 그것</target>
        </trans-unit>
        <trans-unit id="af210c88dc8772797ecc0e53167af870f6831d21" translate="yes" xml:space="preserve">
          <source>No two of those files may be referenced on a &lt;code&gt;SAME RECORD AREA&lt;/code&gt; (see &lt;a href=&quot;#SAME-RECORD-AREA&quot;&gt;SAME RECORD AREA&lt;/a&gt;), &lt;code&gt;SAME SORT AREA&lt;/code&gt; or &lt;code&gt;SAME SORT-MERGE AREA&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;SAME RECORD AREA&lt;/code&gt; ( &lt;a href=&quot;#SAME-RECORD-AREA&quot;&gt;SAME RECORD AREA&lt;/a&gt; 참조 ), &lt;code&gt;SAME SORT AREA&lt;/code&gt; 또는 &lt;code&gt;SAME SORT-MERGE AREA&lt;/code&gt; 문 에서 이러한 파일 중 두 개를 참조 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7438d13425aae9891e97195f6fa784ef1702eda9" translate="yes" xml:space="preserve">
          <source>No two of those files may be referenced on a&lt;code&gt;SAME RECORD AREA&lt;/code&gt;(see &lt;a href=&quot;#SAME-RECORD-AREA&quot;&gt;SAME RECORD AREA&lt;/a&gt;),&lt;code&gt;SAME SORT AREA&lt;/code&gt;or&lt;code&gt;SAME SORT-MERGE AREA&lt;/code&gt;statement.</source>
          <target state="translated">이러한 파일 중 어느 것도 &lt;code&gt;SAME RECORD AREA&lt;/code&gt; ( &lt;a href=&quot;#SAME-RECORD-AREA&quot;&gt;SAM RECORD AREA&lt;/a&gt; 참조 ), &lt;code&gt;SAME SORT AREA&lt;/code&gt; 또는 &lt;code&gt;SAME SORT-MERGE AREA&lt;/code&gt; 문에서 참조 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9cc4f2a8b6d28ab1185c94f1a5e2a64143702d50" translate="yes" xml:space="preserve">
          <source>No two records in the table may have the same &lt;code&gt;KEY&lt;/code&gt; field values. If the table has multiple &lt;code&gt;KEY&lt;/code&gt; definitions, then no two records in the table may have the same</source>
          <target state="translated">테이블의 두 레코드는 동일한 &lt;code&gt;KEY&lt;/code&gt; 필드 값을 가질 수 없습니다 . 테이블에 여러 개의 &lt;code&gt;KEY&lt;/code&gt; 정의 가있는 경우 테이블의 두 레코드가 동일하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de44dc71aad924a999900997ea794d8dd652830f" translate="yes" xml:space="preserve">
          <source>No two records in the table may have the same&lt;code&gt;KEY&lt;/code&gt;field values. If the table has multiple&lt;code&gt;KEY&lt;/code&gt;definitions, then no two records in the table may have the same</source>
          <target state="translated">테이블의 두 레코드가 동일한 &lt;code&gt;KEY&lt;/code&gt; 필드 값을 가질 수 없습니다 . 테이블에 여러 &lt;code&gt;KEY&lt;/code&gt; 정의 가있는 경우 테이블의 두 레코드가 동일하지 않을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="701e46d71db3ef717300ef28e2186a627c3a8343" translate="yes" xml:space="preserve">
          <source>No two report groups in the same report (&lt;code&gt;RD&lt;/code&gt;) may named with the same &lt;var&gt;identifier-1&lt;/var&gt;. There may, however, be multiple &lt;var&gt;identifier-1&lt;/var&gt; definitions in different reports. In such instances, references to &lt;var&gt;identifier-1&lt;/var&gt; must be qualified by the report name.</source>
          <target state="translated">동일한 보고서 ( &lt;code&gt;RD&lt;/code&gt; ) 에있는 두 보고서 그룹 은 동일한 &lt;var&gt;identifier-1&lt;/var&gt; 이름을 지정할 수 없습니다 . 그러나 서로 다른 보고서에 여러 &lt;var&gt;identifier-1&lt;/var&gt; 정의 가있을 수 있습니다 . 이러한 경우 &lt;var&gt;identifier-1&lt;/var&gt; 대한 참조 는 보고서 이름으로 한정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a81a89d7fe3f234fdfe59b26feaf85b577259ebb" translate="yes" xml:space="preserve">
          <source>No two report groups in the same report &lt;code&gt;RD&lt;/code&gt; may named with the same &amp;lt;</source>
          <target state="translated">동일한 보고서 &lt;code&gt;RD&lt;/code&gt; 의 두 보고서 그룹 이 동일한 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="d7e5774021597c332a13e1b5235f812224be797b" translate="yes" xml:space="preserve">
          <source>No&lt;code&gt;INVALID KEY&lt;/code&gt;or&lt;code&gt;NOT INVALID KEY&lt;/code&gt;clause may be specified for a file who&amp;rsquo;s&lt;code&gt;ACCESS MODE IS SEQUENTIAL&lt;/code&gt;</source>
          <target state="translated">아니 &lt;code&gt;INVALID KEY&lt;/code&gt; 또는 &lt;code&gt;NOT INVALID KEY&lt;/code&gt; 의 절의 파일을 지정할 수 있습니다 &lt;code&gt;ACCESS MODE IS SEQUENTIAL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf0db7b3bb9f408f9b74f8f298755ddc3e66b9b8" translate="yes" xml:space="preserve">
          <source>No&lt;code&gt;OCCURS&lt;/code&gt;(see &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt;) clause may be part of the definition of either the subject or object data items. Either or both, however, may be group items that</source>
          <target state="translated">없음 &lt;code&gt;OCCURS&lt;/code&gt; (참조가 &lt;a href=&quot;#OCCURS&quot;&gt;OCCURS&lt;/a&gt; ) 절은 주체 또는 객체 데이터 항목 중 하나의 정의의 일부가 될 수 있습니다. 그러나 둘 중 하나 또는 둘 다 그룹 항목 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca1b683a95bedaa03b1b7fa72858ee0c6ecd486e" translate="yes" xml:space="preserve">
          <source>No&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause may be defined on the object data item, and no data items subordinate to the object data item may have&lt;code&gt;VALUE&lt;/code&gt;clauses, with the exception of level-88 condition names.</source>
          <target state="translated">없음 &lt;code&gt;VALUE&lt;/code&gt; 없습니다 (참조 &lt;a href=&quot;#VALUE&quot;&gt;VALUE를&lt;/a&gt; ) 절 오브젝트 데이터 항목을 정의 할 수 있고, 가질 수있는 객체 데이터 항목에 종속 데이터가없는 항목 &lt;code&gt;VALUE&lt;/code&gt; 의 레벨 88의 조건 이름을 제외하고 절을.</target>
        </trans-unit>
        <trans-unit id="25fc4526232d80ffb715ab31181b4409345c2f9b" translate="yes" xml:space="preserve">
          <source>Non-integer fixed point values such as 1.317 or -2.95.</source>
          <target state="translated">1.317 또는 -2.95와 같은 정수가 아닌 고정 소수점 값</target>
        </trans-unit>
        <trans-unit id="e2c9b438099e818e760bdec714a929f4ed0713ad" translate="yes" xml:space="preserve">
          <source>None of &amp;lt;</source>
          <target state="translated">&amp;lt;없음</target>
        </trans-unit>
        <trans-unit id="a9941a75e96821f165129b0e4f2d6a9c3077350a" translate="yes" xml:space="preserve">
          <source>None of &lt;var&gt;identifier-4&lt;/var&gt;, &lt;var&gt;identifier-5&lt;/var&gt;, &lt;var&gt;identifier-6&lt;/var&gt;, &lt;var&gt;identifier-7&lt;/var&gt; or &lt;var&gt;identifier-8&lt;/var&gt; are initialized by the &lt;code&gt;UNSTRING&lt;/code&gt; statement. You need to do that yourself via a &lt;code&gt;MOVE&lt;/code&gt; (see &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt;) or &lt;code&gt;INITIALIZE&lt;/code&gt; statement (see &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;).</source>
          <target state="translated">아무도 &lt;var&gt;identifier-4&lt;/var&gt; , &lt;var&gt;identifier-5&lt;/var&gt; , &lt;var&gt;identifier-6&lt;/var&gt; , &lt;var&gt;identifier-7&lt;/var&gt; 또는 &lt;var&gt;identifier-8&lt;/var&gt; 에 의해 초기화되지 &lt;code&gt;UNSTRING&lt;/code&gt; 문. 당신은을 통해 자신을 그렇게 할 필요가 &lt;code&gt;MOVE&lt;/code&gt; (참조 &lt;a href=&quot;#MOVE&quot;&gt;MOVE를&lt;/a&gt; ) 또는 &lt;code&gt;INITIALIZE&lt;/code&gt; 의 문 (참조 &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3847348edd31651119c38766dbc8b99b0e838aa9" translate="yes" xml:space="preserve">
          <source>None of them may be open at the time the &lt;code&gt;MERGE&lt;/code&gt; is executed.</source>
          <target state="translated">&lt;code&gt;MERGE&lt;/code&gt; 가 실행될 때 이들 중 어느 것도 열 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b822fcd670cee5b981bb06fc3472b35bc909a687" translate="yes" xml:space="preserve">
          <source>None of them may be open at the time the&lt;code&gt;MERGE&lt;/code&gt;is executed.</source>
          <target state="translated">&lt;code&gt;MERGE&lt;/code&gt; 가 실행될 때 열 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e27f545e660688ab7b2fa768237fd2139f657e72" translate="yes" xml:space="preserve">
          <source>Not all GnuCOBOL implementations support file sharing and record-locking options. Whether they do or not depends upon the operating system they were built for and the build options that were used when the specific GnuCOBOL implementation was generated.</source>
          <target state="translated">모든 GnuCOBOL 구현이 파일 공유 및 레코드 잠금 옵션을 지원하는 것은 아닙니다. 사용 여부는 빌드 된 운영 체제 및 특정 GnuCOBOL 구현 생성시 사용 된 빌드 옵션에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="306e41cc992ba155fc93cf3121e83571aae63d84" translate="yes" xml:space="preserve">
          <source>Not all GnuCOBOL implementations support locking. Whether they do or not depends upon the operating system they were built for and the build options that were used when GnuCOBOL was generated. When a program using one of those GnuCOBOL implementations issues an UNLOCK, it will ignored. There will be no compiler message issued. Buffer syncing, if needed, will still occur.</source>
          <target state="translated">모든 GnuCOBOL 구현이 잠금을 지원하는 것은 아닙니다. 사용 여부는 빌드 된 운영 체제 및 GnuCOBOL 생성시 사용 된 빌드 옵션에 따라 다릅니다. 이러한 GnuCOBOL 구현 중 하나를 사용하는 프로그램이 UNLOCK을 발행하면 무시됩니다. 컴파일러 메시지가 발행되지 않습니다. 필요한 경우 버퍼 동기화가 계속 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e9c1ce73c055e69ee3402cf0e4efbc368e26f9fc" translate="yes" xml:space="preserve">
          <source>Not all divisions are needed in every program, but they must be specified in the order shown when they</source>
          <target state="translated">모든 프로그램에 모든 부서가 필요한 것은 아니지만, 표시 될 때 순서대로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="70ba7f89a0cdff0df48d89a63760a916d2a3530e" translate="yes" xml:space="preserve">
          <source>Not specifying an &amp;lt;</source>
          <target state="translated">&amp;lt;를 지정하지 않음</target>
        </trans-unit>
        <trans-unit id="d448fa80cc92991751f9e490867790af5b7ca5b7" translate="yes" xml:space="preserve">
          <source>Not specifying an &lt;var&gt;identifier-1&lt;/var&gt; or &lt;code&gt;FILLER&lt;/code&gt; immediately after the level number has the same effect as if &lt;code&gt;FILLER&lt;/code&gt; were specified. A data item named &lt;code&gt;FILLER&lt;/code&gt; cannot be referenced directly; these items are generally used to specify an unused portion of the total storage allocated to a group item or to describe a group item whose contents which will only be referenced using the names of those items that belong to it.</source>
          <target state="translated">레벨 번호 바로 뒤에 &lt;var&gt;identifier-1&lt;/var&gt; 또는 &lt;code&gt;FILLER&lt;/code&gt; 를 지정하지 않으면 &lt;code&gt;FILLER&lt;/code&gt; 가 지정된 것과 동일한 효과 가 있습니다. &lt;code&gt;FILLER&lt;/code&gt; 라는 데이터 항목은 직접 참조 할 수 없습니다. 이러한 항목은 일반적으로 그룹 항목에 할당 된 총 스토리지의 사용되지 않은 부분을 지정하거나 해당 항목에 속한 항목의 이름을 사용하여 참조 할 내용이있는 그룹 항목을 설명하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eca1720b4cd982b67332a8c431041a425436b516" translate="yes" xml:space="preserve">
          <source>Not specifying an &lt;var&gt;identifier-1&lt;/var&gt; or &lt;code&gt;FILLER&lt;/code&gt; immediately after the level number has the same effect as if &lt;code&gt;FILLER&lt;/code&gt; were specified. A data item named &lt;code&gt;FILLER&lt;/code&gt; cannot be referenced directly; these items are generally used to specify an unused portion of the total storage allocated to a group item or to describe a group item whose contents which will only be referenced using the names of those items that belong to it. In the linkage section, 01-level data items cannot be named &lt;code&gt;FILLER&lt;/code&gt;.</source>
          <target state="translated">레벨 번호 바로 뒤에 &lt;var&gt;identifier-1&lt;/var&gt; 또는 &lt;code&gt;FILLER&lt;/code&gt; 를 지정하지 않으면 &lt;code&gt;FILLER&lt;/code&gt; 가 지정된 것과 동일한 효과 가 있습니다. &lt;code&gt;FILLER&lt;/code&gt; 라는 데이터 항목은 직접 참조 할 수 없습니다. 이러한 항목은 일반적으로 그룹 항목에 할당 된 총 스토리지의 사용되지 않은 부분을 지정하거나 해당 항목에 속한 항목의 이름을 사용하여 참조 할 내용이있는 그룹 항목을 설명하는 데 사용됩니다. 연결 섹션에서 01 레벨 데이터 항목의 이름은 &lt;code&gt;FILLER&lt;/code&gt; 로 지정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="acb32811a10aeb5cdd9fd5772253064a242b86bc" translate="yes" xml:space="preserve">
          <source>Note how the &lt;code&gt;cobcrun&lt;/code&gt; command does not allow a path to be specified with the program name &amp;mdash; the directory in which the programs dynamically loadable module exists must either be the current directory or must be defined in the current &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cobcrun&lt;/code&gt; 명령이 프로그램 이름으로 경로를 지정할 수 없다는 점에 유의하십시오. 동적으로로드 가능한 모듈이있는 프로그램이있는 디렉토리는 현재 디렉토리이거나 현재 &lt;code&gt;PATH&lt;/code&gt; 에 정의되어 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="dc309739aae3a8f2ebf82a717d61d549c5be4bac" translate="yes" xml:space="preserve">
          <source>Note how the COBOL program ensures that a null end-of-string terminator is present on both string arguments.</source>
          <target state="translated">COBOL 프로그램이 두 문자열 인수 모두에 널 (NULL) 문자열 끝 종결자가 있는지 확인하는 방법에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="183fb1decb6efb7828d7f6dd44fcbd653f28888b" translate="yes" xml:space="preserve">
          <source>Note how the word &lt;code&gt;FUNCTION&lt;/code&gt; is part of the syntax when you use an intrinsic function. You can use intrinsic functions without having to include the reserved word &lt;code&gt;FUNCTION&lt;/code&gt; via settings in the &lt;code&gt;REPOSITORY&lt;/code&gt; (see &lt;a href=&quot;#REPOSITORY&quot;&gt;REPOSITORY&lt;/a&gt;) paragraph. You may accomplish the same thing by specifying the</source>
          <target state="translated">내장 함수를 사용할 때 &lt;code&gt;FUNCTION&lt;/code&gt; 이라는 단어 가 구문의 일부 인지 확인하십시오 . &lt;code&gt;REPOSITORY&lt;/code&gt; ( &lt;a href=&quot;#REPOSITORY&quot;&gt;REPOSITORY&lt;/a&gt; 참조 ) 단락의 설정을 통해 예약어 &lt;code&gt;FUNCTION&lt;/code&gt; 을 포함하지 않고도 내장 함수를 사용할 수 있습니다 . 다음을 지정하여 동일한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c109c67ad2b3a941d3d17742fa522392c11f75b" translate="yes" xml:space="preserve">
          <source>Note how the word&lt;code&gt;FUNCTION&lt;/code&gt;is part of the syntax when you use an intrinsic function. You can use intrinsic functions without having to include the reserved word&lt;code&gt;FUNCTION&lt;/code&gt;via settings in the&lt;code&gt;REPOSITORY&lt;/code&gt;(see &lt;a href=&quot;#REPOSITORY&quot;&gt;REPOSITORY&lt;/a&gt;) paragraph. You may accomplish the same thing by specifying the&lt;code&gt;-fintrinsics&lt;/code&gt;switch</source>
          <target state="translated">내장 함수를 사용할 때 &lt;code&gt;FUNCTION&lt;/code&gt; 이라는 단어 가 구문의 일부인 방법에 유의하십시오 . &lt;code&gt;REPOSITORY&lt;/code&gt; ( &lt;a href=&quot;#REPOSITORY&quot;&gt;REPOSITORY&lt;/a&gt; 참조 ) 단락의 설정을 통해 예약어 &lt;code&gt;FUNCTION&lt;/code&gt; 을 포함하지 않고도 내장 함수를 사용할 수 있습니다 . &lt;code&gt;-fintrinsics&lt;/code&gt; 스위치 를 지정하여 동일한 작업을 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="d04e9fec76c5812c7a9b640cbfeccc8e41ebd984" translate="yes" xml:space="preserve">
          <source>Note how the&lt;code&gt;cobcrun&lt;/code&gt;command does not allow a path to be specified with the program name &amp;mdash; the directory in which the programs dynamically loadable module exists must either be the current directory or must be defined in the current PATH.</source>
          <target state="translated">&lt;code&gt;cobcrun&lt;/code&gt; 명령으로 프로그램 이름으로 경로를 지정할 수없는 방법에 유의 하십시오. 프로그램이 동적으로로드 할 수있는 모듈이 존재하는 디렉토리는 현재 디렉토리이거나 현재 PATH에 정의되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="22d0d2f4c5b59717940c0e72d1a8b9cca0d01d10" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ABSOLUTE-VALUE&lt;/code&gt; has an alias for this function.</source>
          <target state="translated">참고 것을 &lt;code&gt;ABSOLUTE-VALUE&lt;/code&gt; 이 기능에 대한 별칭을 가지고있다.</target>
        </trans-unit>
        <trans-unit id="ec332543bc6a4b8ecabc6857c2e09711a937c08d" translate="yes" xml:space="preserve">
          <source>Note that bit 0 is the right-most bit in the binary value.</source>
          <target state="translated">비트 0은 이진 값에서 가장 오른쪽에있는 비트입니다.</target>
        </trans-unit>
        <trans-unit id="e2138fe3e1e1ef1f0f6b05f72e9f9e338fde700f" translate="yes" xml:space="preserve">
          <source>Note that even though we told GnuCOBOL that the 1st argument was to be &lt;code&gt;BY VALUE&lt;/code&gt;, it was treated as if it were &lt;code&gt;BY REFERENCE&lt;/code&gt; anyway. String (char array) arguments passed from C callers to GnuCOBOL subprograms will be modifiable by the subprogram. It&amp;rsquo;s best to pass a copy of such data if you want to ensure that the subprogram doesn&amp;rsquo;t change it.</source>
          <target state="translated">우리가 GnuCOBOL에게 첫 번째 인수가 &lt;code&gt;BY VALUE&lt;/code&gt; 라고 말했지만 어쨌든 &lt;code&gt;BY REFERENCE&lt;/code&gt; 것처럼 취급되었습니다 . C 호출자에서 GnuCOBOL 하위 프로그램으로 전달 된 문자열 (문자 배열) 인수는 하위 프로그램에서 수정할 수 있습니다. 하위 프로그램이 데이터를 변경하지 않도록하려면 이러한 데이터의 복사본을 전달하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2539952aecc19d7b3a92ef3357fabc279c56a247" translate="yes" xml:space="preserve">
          <source>Note that even though we told GnuCOBOL that the 1st argument was to be&lt;code&gt;BY VALUE&lt;/code&gt; it was treated as if it were&lt;code&gt;BY REFERENCE&lt;/code&gt;anyway. String (char array) arguments passed from C callers to GnuCOBOL subprograms will be modifiable by the subprogram. It&amp;rsquo;s best to pass a copy of such data if you want to ensure that the subprogram doesn&amp;rsquo;t change it.</source>
          <target state="translated">주 우리가 1 인자가 될 것을 GnuCOBOL 말했다 비록 &lt;code&gt;BY VALUE&lt;/code&gt; 를 그 것처럼 그것을 처리 &lt;code&gt;BY REFERENCE&lt;/code&gt; 어쨌든. C 호출자에서 GnuCOBOL 서브 프로그램으로 전달 된 문자열 (char 배열) 인수는 서브 프로그램에 의해 수정 될 수 있습니다. 서브 프로그램이 변경하지 않도록하려면 그러한 데이터의 사본을 전달하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="092d66dd347f9d0f0198d3a5cda5558a8906cb01" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;OUTPUT&lt;/code&gt; phrase changes the way in which the default field size is computed. See that heading above for details. Also note that the &lt;code&gt;OUTPUT&lt;/code&gt; phrase affects only the way items are displayed on the screen; the internal format of accepted data is not affected.</source>
          <target state="translated">점을 유의 &lt;code&gt;OUTPUT&lt;/code&gt; 문구가 기본 필드의 크기를 계산하는 방식을 변경합니다. 자세한 내용은 위의 제목을 참조하십시오. 또한 &lt;code&gt;OUTPUT&lt;/code&gt; 구문은 항목이 화면에 표시되는 방식에만 영향을 미칩니다. 승인 된 데이터의 내부 형식은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="871c018f1f8ef5bab7bedbfc57441be80385c284" translate="yes" xml:space="preserve">
          <source>Note that the OUTPUT phrase changes the way in which the default field size is computed. See that heading above for details. Also note that the OUTPUT phrase affects only the way items are displayed on the screen; the internal format of accepted data is not affected.</source>
          <target state="translated">OUTPUT 문구는 기본 필드 크기가 계산되는 방식을 변경합니다. 자세한 내용은 위의 제목을 참조하십시오. 또한 OUTPUT 문구는 항목이 화면에 표시되는 방식에만 영향을 미칩니다. 허용 된 데이터의 내부 형식은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73ca23565a924502144491bc13719f661401068e" translate="yes" xml:space="preserve">
          <source>Note that the legacy name of this routine starts with &amp;ldquo;CBL_OC&amp;rdquo; is deprecated, as is &lt;code&gt;HOSTED&lt;/code&gt;, but will still work. It is recommended that all library routines names starting with &amp;ldquo;CBL_OC&amp;rdquo; are replaced with &amp;ldquo;CBL_GC&amp;rdquo; to minimise issues.</source>
          <target state="translated">&quot;CBL_OC&quot;이 루틴 시작의 기존 이름이 될 때, 사용되지 않습니다 &lt;code&gt;HOSTED&lt;/code&gt; 작업을 하겠지만 여전히. 문제를 최소화하기 위해&amp;ldquo;CBL_OC&amp;rdquo;로 시작하는 모든 라이브러리 루틴 이름을&amp;ldquo;CBL_GC&amp;rdquo;로 바꾸는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1fbd4eeb5f6972ceb99cdf3aac9f4be0886c77cb" translate="yes" xml:space="preserve">
          <source>Note that the legacy name of this routine starts with CBL_OC is deprecated, as is HOSTED but will still work. It is recommended that all libary routines names starting with CBL_OC are replaced with CBL_GC to minimise issues.</source>
          <target state="translated">이 루틴의 레거시 이름은 CBL_OC로 시작하지만 HOSTED와 같이 더 이상 사용되지 않지만 여전히 작동합니다. 문제를 최소화하기 위해 CBL_OC로 시작하는 모든 라이브러리 루틴 이름을 CBL_GC로 바꾸는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="51fa3c32776b59476d40090b9247a2fa13f21bb0" translate="yes" xml:space="preserve">
          <source>Note that the legacy name of this routine that starts with &lt;code&gt;CBL_OC&lt;/code&gt; is deprecated, as is &lt;code&gt;NANOSLEEP&lt;/code&gt; but will still work. It is recommended that all library routines names starting with &lt;code&gt;CBL_OC&lt;/code&gt; are replaced with &lt;code&gt;CBL_GC&lt;/code&gt; to minimise issues.</source>
          <target state="translated">참고로 시작하는이 루틴의 기존 이름 &lt;code&gt;CBL_OC&lt;/code&gt; 이 있는 한, 사용되지 않습니다 &lt;code&gt;NANOSLEEP&lt;/code&gt; 하지만 여전히 작동합니다. 문제를 최소화하기 위해 &lt;code&gt;CBL_GC&lt;/code&gt; 로 시작하는 모든 라이브러리 루틴 이름을 &lt;code&gt;CBL_OC&lt;/code&gt; 로 바꾸는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7a40b40bf40810b907f7cf0d8aaaa83843011c4d" translate="yes" xml:space="preserve">
          <source>Note that the legacy name of this routine that starts with CBL_OC is deprecated, as is NANOSLEEP but will still work. It is recommended that all libary routines names starting with CBL_OC are replaced with CBL_GC to minimise issues.</source>
          <target state="translated">CBL_OC로 시작하는이 루틴의 레거시 이름은 NANOSLEEP와 같이 더 이상 사용되지 않지만 여전히 작동합니다. 문제를 최소화하기 위해 CBL_OC로 시작하는 모든 라이브러리 루틴 이름을 CBL_GC로 바꾸는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="efe51ebdd06327d81c22d954a952f012e8b5debd" translate="yes" xml:space="preserve">
          <source>Note that the value returned by this function is not the number of</source>
          <target state="translated">이 함수에 의해 반환되는 값은</target>
        </trans-unit>
        <trans-unit id="6e8cfcde44ca037484ab7aea2c239bb66679ec70" translate="yes" xml:space="preserve">
          <source>Note that these errors include but are not limited to: argument (&lt;var&gt;string&lt;/var&gt;) is zero length, contains only spaces or contains valid characters but is incomplete, such as the string &amp;lsquo;</source>
          <target state="translated">이러한 오류에는 다음이 포함되지만 이에 국한되지는 않습니다. 인수 ( &lt;var&gt;string&lt;/var&gt; ) 길이가 0이고, 공백 만 포함하거나 유효한 문자를 포함하지만 '문자열'과 같이 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="f3452b747551a3e31882fb7b479a113ecf58accb" translate="yes" xml:space="preserve">
          <source>Note that these errors include but are not limited to: argument (string) is zero length, contains only spaces or contains valid characters but is incomplete, such as the string &quot;+.&quot;.</source>
          <target state="translated">인수 (문자열)의 길이가 0이거나 공백 만 포함하거나 유효한 문자를 포함하지만 문자열 &quot;+&quot;와 같이 불완전한 오류입니다.</target>
        </trans-unit>
        <trans-unit id="5a0f3696fb05aebf6890ba93476c007aded86f55" translate="yes" xml:space="preserve">
          <source>Note that these errors include but are not limited to: argument (string) is zero length, contains only spaces or contains valid characters but is incomplete, such as the string &amp;lsquo;</source>
          <target state="translated">이러한 오류에는 다음이 포함되지만 이에 국한되지는 않습니다. 인수 (문자열) 길이가 0이고 공백 만 포함하거나 유효한 문자를 포함하지만 '문자열'과 같이 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="cc0412d45415b86da0a43a8c1ca6e6dc158f2456" translate="yes" xml:space="preserve">
          <source>Note that what constitutes a &quot;letter&quot; (or upper/lower case too, for that manner) may be influenced through the use of&lt;code&gt;CHARACTER CLASSIFICATION&lt;/code&gt;specifications in the&lt;code&gt;OBJECT-COMPUTER&lt;/code&gt;(see &lt;a href=&quot;#OBJECT_002dCOMPUTER&quot;&gt;OBJECT-COMPUTER&lt;/a&gt;) paragraph.</source>
          <target state="translated">&quot;문자&quot;를 구성하는 것 (또는 그런 방식으로 대문자 / 소문자도)은 &lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; ( &lt;a href=&quot;#OBJECT_002dCOMPUTER&quot;&gt;OBJECT-COMPUTER&lt;/a&gt; 참조 ) 단락 에서 &lt;code&gt;CHARACTER CLASSIFICATION&lt;/code&gt; 스펙을 사용하여 영향을받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="62ddaee439780c7798fa13166b25f5c860f4ff2d" translate="yes" xml:space="preserve">
          <source>Note that what constitutes a &amp;ldquo;letter&amp;rdquo; (or upper/lower case too, for that manner) may be influenced through the use of &lt;code&gt;CHARACTER CLASSIFICATION&lt;/code&gt; specifications in the &lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; (see &lt;a href=&quot;#OBJECT_002dCOMPUTER&quot;&gt;OBJECT-COMPUTER&lt;/a&gt;) paragraph.</source>
          <target state="translated">&lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; ( &lt;a href=&quot;#OBJECT_002dCOMPUTER&quot;&gt;OBJECT-COMPUTER&lt;/a&gt; 참조 ) 단락 에서 &lt;code&gt;CHARACTER CLASSIFICATION&lt;/code&gt; 사양을 사용하면 &quot;문자&quot;(또는 대문자 / 소문자도 해당 방식)를 구성하는 요소가 영향을받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91d9c5ae964daaf24d6471c5047859c42f3c1e8e" translate="yes" xml:space="preserve">
          <source>Note that you cannot supply the &lt;code&gt;CONVERT&lt;/code&gt; phrase in the Screen Section. Thus the size of a Screen Section field is always the size of its screen entry unless the &lt;code&gt;SIZE&lt;/code&gt; phrase is specified.</source>
          <target state="translated">화면 섹션 에는 &lt;code&gt;CONVERT&lt;/code&gt; 구문을 제공 할 수 없습니다 . 따라서 화면 섹션 필드의 크기는 &lt;code&gt;SIZE&lt;/code&gt; 구문이 지정 되지 않는 한 항상 화면 항목의 크기 입니다.</target>
        </trans-unit>
        <trans-unit id="5d3c2b08b61d1a38bbeee29bc320c48df653d057" translate="yes" xml:space="preserve">
          <source>Note that you cannot supply the CONVERT phrase in the Screen Section. Thus the size of a Screen Section field is always the size of its screen entry unless the SIZE phrase is specified.</source>
          <target state="translated">화면 섹션에는 CONVERT 문구를 제공 할 수 없습니다. 따라서 SIZE 구문을 지정하지 않으면 스크린 섹션 필드의 크기는 항상 스크린 항목의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="b71c125eb5c206746bd62c2d42dec3309f4fd188" translate="yes" xml:space="preserve">
          <source>Note: The offset value 1439 represents 23 hours 59 minutes which is one minutes less than a day.</source>
          <target state="translated">참고 : 오프셋 값 1439는 하루보다 1 분 적은 23 시간 59 분을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="13a24e6195c1e1b94c4dd056c0d5fd8a03948d3d" translate="yes" xml:space="preserve">
          <source>Now observe the following code, which will execute the &lt;code&gt;150-Process-Hex-Value&lt;/code&gt; procedure if &lt;code&gt;Entered-Value&lt;/code&gt; contains nothing but valid hexadecimal digits:</source>
          <target state="translated">이제 &lt;code&gt;Entered-Value&lt;/code&gt; 에 유효한 16 진수 만 포함 된 경우 &lt;code&gt;150-Process-Hex-Value&lt;/code&gt; 프로 시저 를 실행하는 다음 코드를 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="28b8e9bdefe3979b0685c44999ad9084995ed4c9" translate="yes" xml:space="preserve">
          <source>Now observe the following code, which will execute the&lt;code&gt;150-Process-Hex-Value&lt;/code&gt;procedure if&lt;code&gt;Entered-Value&lt;/code&gt;contains nothing but valid hexadecimal digits:</source>
          <target state="translated">&lt;code&gt;Entered-Value&lt;/code&gt; 에 유효한 16 진수 만 있으면 &lt;code&gt;150-Process-Hex-Value&lt;/code&gt; 프로 시저 를 실행하는 다음 코드를 관찰하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9e0e91f86531814b287253e68ce747a1135f32c" translate="yes" xml:space="preserve">
          <source>Now that you know</source>
          <target state="translated">이제 알았습니다</target>
        </trans-unit>
        <trans-unit id="51d733cbc7afeb6829e46e54cb89522a4021ffd6" translate="yes" xml:space="preserve">
          <source>Now there can be no confusion as to which &lt;code&gt;CITY&lt;/code&gt; is being changed. Fortunately, you don&amp;rsquo;t need to be quite so specific; COBOL allows intermediate and unnecessary qualification levels to be omitted. This allows &lt;code&gt;MOVE 'Philadelphia' TO CITY OF EMPLOYEE&lt;/code&gt; to do the job nicely.</source>
          <target state="translated">이제 어떤 &lt;code&gt;CITY&lt;/code&gt; 가 변경 되는지 혼동 할 수 없습니다 . 다행스럽게도 그렇게 구체적 일 필요는 없습니다. COBOL에서는 중간 및 불필요한 자격 수준을 생략 할 수 있습니다. 이를 통해 &lt;code&gt;MOVE 'Philadelphia' TO CITY OF EMPLOYEE&lt;/code&gt; 이 작업을 잘 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0861e2e052b3dc839be9fe7e44875aa59ec9523" translate="yes" xml:space="preserve">
          <source>Now there can be no confusion as to which CITY is being changed. Fortunately, you don&amp;rsquo;t need to be quite so specific; COBOL allows intermediate and unnecessary qualification levels to be omitted. This allows&lt;code&gt;MOVE 'Philadelphia' TO CITY OF EMPLOYEE&lt;/code&gt;to do the job nicely.</source>
          <target state="translated">이제 어떤 도시가 변경되고 있는지 혼동 될 수 없습니다. 다행히도, 당신은 그렇게 구체적 일 필요는 없습니다. COBOL을 사용하면 중간 및 불필요한 자격 수준을 생략 할 수 있습니다. 이를 통해 &lt;code&gt;MOVE 'Philadelphia' TO CITY OF EMPLOYEE&lt;/code&gt; 에게 '필라델피아'MOVE가 훌륭하게 업무를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cca0ffe80614cff58f27f48f8e3a36d4fe4b2df" translate="yes" xml:space="preserve">
          <source>Now we have the tools to run &lt;code&gt;CBL_GC_GETOPT&lt;/code&gt; within the procedure division.</source>
          <target state="translated">이제 프로 시저 분할 내에서 &lt;code&gt;CBL_GC_GETOPT&lt;/code&gt; 를 실행하는 도구가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="219877a3941189d29da78605ffc816ab5f2a7b89" translate="yes" xml:space="preserve">
          <source>Now, assume that another program reads this file, but describes 10-character records rather than 6. Here are the records</source>
          <target state="translated">이제 다른 프로그램이이 파일을 읽지 만 6이 아닌 10 자 레코드를 설명한다고 가정하십시오. 레코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="90dbab146724f39b3e9bc621d7639950a26f4b2d" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s deal with the problem of setting the &lt;code&gt;CITY&lt;/code&gt; portion of an &lt;code&gt;EMPLOYEE&lt;/code&gt;s &lt;code&gt;MAILING-ADDRESS&lt;/code&gt; to &amp;lsquo;</source>
          <target state="translated">이제 &lt;code&gt;EMPLOYEE&lt;/code&gt; s &lt;code&gt;MAILING-ADDRESS&lt;/code&gt; 의 &lt;code&gt;CITY&lt;/code&gt; 부분 을 ' 로 설정하는 문제를 다루겠습니다.</target>
        </trans-unit>
        <trans-unit id="9b0d34c0dc28860109b36ba3a6f8a912103ad454" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s deal with the problem of setting the CITY portion of an EMPLOYEEs MAILING-ADDRESS to &quot;Philadelphia&quot;. Clearly,&lt;code&gt;MOVE 'Philadelphia' TO CITY&lt;/code&gt;cannot work because the compiler will be unable to determine which of the two CITY fields you are referring to.</source>
          <target state="translated">이제 직원 우편 주소의 CITY 부분을 &quot;필라델피아&quot;로 설정하는 문제를 해결해 보겠습니다. 컴파일러가 사용자가 참조하는 두 개의 CITY 필드를 판별 할 수 없기 때문에 분명히 &lt;code&gt;MOVE 'Philadelphia' TO CITY&lt;/code&gt; 은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce50db412280505597bf9414695fbcc5fc0e3f7b" translate="yes" xml:space="preserve">
          <source>Now, the roles of the two languages in the previous section will be reversed, having a C main program execute a GnuCOBOL subprogram.</source>
          <target state="translated">이제 이전 섹션에서 두 언어의 역할이 바뀌어 C 메인 프로그램이 GnuCOBOL 서브 프로그램을 실행하게됩니다.</target>
        </trans-unit>
        <trans-unit id="b9a0cb2a79aa6bb54fefd7df31d703c9a5f82f4f" translate="yes" xml:space="preserve">
          <source>Null terminated literals</source>
          <target state="translated">널로 끝나는 리터럴</target>
        </trans-unit>
        <trans-unit id="5d6820962ed41a3c8df147927428ecba6ad7b8f2" translate="yes" xml:space="preserve">
          <source>Number of unused (</source>
          <target state="translated">미사용 수량 (</target>
        </trans-unit>
        <trans-unit id="f60c8b64229a047f941675b68f85587ecce4b520" translate="yes" xml:space="preserve">
          <source>Numeric Data Item</source>
          <target state="translated">숫자 데이터 항목</target>
        </trans-unit>
        <trans-unit id="c9fbc7f3c5ecccd87db3e696a9c121879251fe81" translate="yes" xml:space="preserve">
          <source>Numeric Edited</source>
          <target state="translated">숫자 편집</target>
        </trans-unit>
        <trans-unit id="63ddf527a277f4c347e2246f00b1c4f8cda03669" translate="yes" xml:space="preserve">
          <source>Numeric Edited Data Item</source>
          <target state="translated">숫자 편집 된 데이터 항목</target>
        </trans-unit>
        <trans-unit id="a24a22f9b40fcfe4d2691a6016ec524613059e17" translate="yes" xml:space="preserve">
          <source>Numeric Literal</source>
          <target state="translated">숫자 리터럴</target>
        </trans-unit>
        <trans-unit id="8eefce14ad64237aed9590a466c38dd080fec5d1" translate="yes" xml:space="preserve">
          <source>Numeric data items are truncated according to their &lt;code&gt;PICTURE&lt;/code&gt; clauses.</source>
          <target state="translated">숫자 데이터 항목은 &lt;code&gt;PICTURE&lt;/code&gt; 절 에 따라 잘립니다 .</target>
        </trans-unit>
        <trans-unit id="ce2aa4191d1438aef80784c8e9228ab5733e4ef8" translate="yes" xml:space="preserve">
          <source>Numeric data items are truncated according to their internal representation.</source>
          <target state="translated">숫자 데이터 항목은 내부 표현에 따라 잘립니다.</target>
        </trans-unit>
        <trans-unit id="7e59ff5a1d75e3b7324d0a79c5cf95e1845a8a70" translate="yes" xml:space="preserve">
          <source>Numeric data items will be initialized to a value of &lt;code&gt;ZERO&lt;/code&gt;.</source>
          <target state="translated">숫자 데이터 항목은 &lt;code&gt;ZERO&lt;/code&gt; 값으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="be2d608e3fa3ed6ad269186745305eb23ec33b56" translate="yes" xml:space="preserve">
          <source>Numeric data items will be initialized to a value of&lt;code&gt;ZERO&lt;/code&gt;</source>
          <target state="translated">숫자 데이터 항목은 &lt;code&gt;ZERO&lt;/code&gt; 값으로 초기화됩니다</target>
        </trans-unit>
        <trans-unit id="289405511920b64e6183e96801f299b0a1170932" translate="yes" xml:space="preserve">
          <source>Numeric keypad keys are not recognizable on Windows MinGW/PDCurses builds of GnuCOBOL, regardless of the number lock settings. Windows Cygwin/NCurses builds recognize numeric keypad inputs properly. Although not tested during the preparation of this documentation, I would expect native Windows builds using PDCurses to behave as MinGW builds do and native Unix builds using NCurses to behave as do Cygwin builds.</source>
          <target state="translated">숫자 잠금 설정에 관계없이 GnuCOBOL의 Windows MinGW / PDCurses 빌드에서 숫자 키패드 키를 인식 할 수 없습니다. Windows Cygwin / NCurses 빌드는 숫자 키패드 입력을 올바르게 인식합니다. 이 문서를 준비하는 동안 테스트되지는 않았지만 PDCurses를 사용하는 기본 Windows 빌드는 MinGW 빌드와 마찬가지로 작동하고 NCurses를 사용하는 기본 Unix 빌드는 Cygwin 빌드와 같이 동작합니다.</target>
        </trans-unit>
        <trans-unit id="8eeea7541c21f9801d7c1875ed5f9c434348ce35" translate="yes" xml:space="preserve">
          <source>Numeric literals may be split across lines just as alphanumeric literals are, using either of the above techniques and both reserved and user-defined words can be split across lines too (using the first technique). The continuation of numeric literals and user-defined/reserved words is provided merely to provide compatibility with older COBOL versions and programs, but should not be used with new programs &amp;mdash; it just makes for ugly-looking programs.</source>
          <target state="translated">위의 기술 중 하나를 사용하여 영숫자 리터럴과 같이 숫자 리터럴을 여러 줄로 나눌 수 있으며 예약 된 단어와 사용자 정의 단어를 모두 줄로 나눌 수 있습니다 (첫 번째 기술 사용). 숫자 리터럴과 사용자 정의 / 예약 단어의 연속은 이전 COBOL 버전 및 프로그램과의 호환성을 제공하기 위해 제공되지만 새로운 프로그램과 함께 사용해서는 안됩니다. 이는보기 흉한 프로그램을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="6f2932e8faff18c0314f3a04f9aec75edec07a2f" translate="yes" xml:space="preserve">
          <source>OBJECT, OBJECT-COMPUTER, OBJECT-REFERENCE, OCCURS, OF, OFF, OMITTED, ON, ONLY, OPEN, OPTIONAL, OPTIONS, OR, ORD, ORDER, ORD-MAX, ORD-MIN, ORGANISATION, ORGANIZATION, OTHER, OUTPUT, OVERFLOW, OVERLINE, OVERRIDE</source>
          <target state="translated">객체, 객체 컴퓨터, 객체 참조, 발생, OF, OFF, 생략, ON, ONLY, OPEN, OPTIONAL, OPTIONS, OR, ORD, ORDER, ORD-MAX, ORD-MIN, ORGANISATION, ORGANIZATION, OTHER, OUTPUT, 오버플로, 개요, 오버라이드</target>
        </trans-unit>
        <trans-unit id="2e78bec2d3800e6a21f1a284d7a3afd18c2fcd63" translate="yes" xml:space="preserve">
          <source>OBJECT-COMPUTER Syntax</source>
          <target state="translated">객체 컴퓨터 구문</target>
        </trans-unit>
        <trans-unit id="98d4fe9c9ba7eedf87784e4d6e824cac62353113" translate="yes" xml:space="preserve">
          <source>OBJECT-COMPUTER, OBJECT-REFERENCE, OBJECT, OCCURS, OFF, OF, OK-BUTTON, OMITTED, ONLY, ON, OPEN, OPTIONAL, OPTIONS, ORDER, ORD-MAX, ORD-MIN, ORD, ORGANISATION, ORGANIZATION, OR, OTHER, OUTPUT, OVERFLOW, OVERLAP-LEFT, OVERLAP-TOP, OVERLINE, OVERRIDE</source>
          <target state="translated">OBJECT-COMPUTER, OBJECT-REFERENCE, OBJECT, OCCURS, OFF, OF, OK-BUTTON, OMITTED, ONLY, ON, OPEN, OPTIONAL, OPTIONS, ORDER, ORD-MAX, ORD-MIN, ORD, ORGANISATION, ORGANIZATION, OR, 기타, 출력, 오버플로, OVERLAP-LEFT, OVERLAP-TOP, OVERLINE, OVERRIDE</target>
        </trans-unit>
        <trans-unit id="cec1574213ff5c57fb26687d05dd766be420fc2b" translate="yes" xml:space="preserve">
          <source>OCCURS &amp;hellip; DEPENDING ON data item out of bounds</source>
          <target state="translated">OCCURS&amp;hellip; 범위를 벗어난 데이터 항목에 따라 다름</target>
        </trans-unit>
        <trans-unit id="b800486653c7a1c77e853e0c004749a0fd2748a9" translate="yes" xml:space="preserve">
          <source>OCCURS (All Other Sections Clause Syntax</source>
          <target state="translated">OCCURS (다른 모든 섹션 조항 구문</target>
        </trans-unit>
        <trans-unit id="dd0b3221d40b5306dd784b27996de5c44ec57b1a" translate="yes" xml:space="preserve">
          <source>OCCURS (REPORT SECTION) Clause Syntax</source>
          <target state="translated">OCCURS (보고서 섹션) 조항 구문</target>
        </trans-unit>
        <trans-unit id="6b31ee2b7fdf9b827a81f695d24c794e1825c9ac" translate="yes" xml:space="preserve">
          <source>OCCURS (SCREEN SECTION) Clause Syntax</source>
          <target state="translated">OCCURS (스크린 섹션) 절 구문</target>
        </trans-unit>
        <trans-unit id="12163d548f84d0d3a65be49f9405b588882fb830" translate="yes" xml:space="preserve">
          <source>ON EXCEPTION Syntax</source>
          <target state="translated">익셉션 구문</target>
        </trans-unit>
        <trans-unit id="fae727086e90c1747900d70ffd7f8b15f8dbda95" translate="yes" xml:space="preserve">
          <source>ON OVERFLOW Syntax</source>
          <target state="translated">오버플로 구문</target>
        </trans-unit>
        <trans-unit id="66bebaca5aeeed104d7154b3d0f92463c9dd8dd1" translate="yes" xml:space="preserve">
          <source>ON SIZE ERROR Syntax</source>
          <target state="translated">크기 오류 구문</target>
        </trans-unit>
        <trans-unit id="36dfa4bed24bebe94e869396499f245644973c4a" translate="yes" xml:space="preserve">
          <source>OPEN Syntax</source>
          <target state="translated">구문 열기</target>
        </trans-unit>
        <trans-unit id="cf0fe9af8bea7d1e731289cfef0c8038f4bc83dd" translate="yes" xml:space="preserve">
          <source>ORD Function Syntax</source>
          <target state="translated">ORD 함수 구문</target>
        </trans-unit>
        <trans-unit id="9ad6006b98ba7b9576a4512aa283c527f6a05c6a" translate="yes" xml:space="preserve">
          <source>ORD-MAX Function Syntax</source>
          <target state="translated">ORD-MAX 함수 구문</target>
        </trans-unit>
        <trans-unit id="09ee84df5eb17ff7d1f3553b1cbd5d58418d7791" translate="yes" xml:space="preserve">
          <source>ORD-MIN Function Syntax</source>
          <target state="translated">ORD-MIN 함수 구문</target>
        </trans-unit>
        <trans-unit id="08b26f9634d2a732e998aa2218316415ad38194c" translate="yes" xml:space="preserve">
          <source>ORGANIZATION INDEXED Clause Syntax</source>
          <target state="translated">조직 INDEXED 절 구문</target>
        </trans-unit>
        <trans-unit id="2df4622dcdea677d5d9a83663b8cbf91c2189a6b" translate="yes" xml:space="preserve">
          <source>ORGANIZATION LINE SEQUENTIAL Clause Syntax</source>
          <target state="translated">ORGANIZATION LINE SEQUENTIAL 절 구문</target>
        </trans-unit>
        <trans-unit id="86ee1da50c2e8a0ec7111d29363f3c837bd97118" translate="yes" xml:space="preserve">
          <source>ORGANIZATION RELATIVE Clause Syntax</source>
          <target state="translated">조직 관련 조항 구문</target>
        </trans-unit>
        <trans-unit id="750186647b33c3656503302d8eccc530bc37f0af" translate="yes" xml:space="preserve">
          <source>ORGANIZATION SEQUENTIAL Clause Syntax</source>
          <target state="translated">조직 순서 조항 구문</target>
        </trans-unit>
        <trans-unit id="578fbcff15d7037e9429c12a53b4d74f6a1577f1" translate="yes" xml:space="preserve">
          <source>OS/2 &quot;OPTLINK&quot; conventions will be used to CALL the subprogram.</source>
          <target state="translated">서브 프로그램을 호출하는 데 OS / 2 &quot;OPTLINK&quot;규칙이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c666501d06dc9305a9b7b68de3b3d3562fd28b49" translate="yes" xml:space="preserve">
          <source>OS/2 &quot;OPTLINK&quot; conventions will not be used to CALL the subprogram.</source>
          <target state="translated">서브 프로그램을 호출하는 데 OS / 2 &quot;OPTLINK&quot;규칙이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f27666d6409fb25219ce16339fb1c8bef9d03f0" translate="yes" xml:space="preserve">
          <source>OS/2 &amp;ldquo;OPTLINK&amp;rdquo; conventions will be used to CALL the subprogram.</source>
          <target state="translated">OS / 2 &quot;OPTLINK&quot;규칙은 서브 프로그램을 호출하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1d08cd083ab2d61b0c0ec3a69e3aaf002cac1bfb" translate="yes" xml:space="preserve">
          <source>OS/2 &amp;ldquo;OPTLINK&amp;rdquo; conventions will not be used to CALL the subprogram.</source>
          <target state="translated">OS / 2 &quot;OPTLINK&quot;규칙은 서브 프로그램을 호출하는 데 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8e1209593b1149f5f3f8ee76008515520f2193a" translate="yes" xml:space="preserve">
          <source>OVERLINE Attribute Syntax</source>
          <target state="translated">개요 속성 구문</target>
        </trans-unit>
        <trans-unit id="4924a4d3bf56aa4a828e65f5066f009ce7e62b7d" translate="yes" xml:space="preserve">
          <source>Observe the definitions of data items &quot;Q&quot; and &quot;Y&quot;&amp;hellip;</source>
          <target state="translated">&quot;Q&quot;및 &quot;Y&quot;데이터 항목의 정의를 준수하십시오&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="2602780ef6522b52c7725288d8a3e8285ac74790" translate="yes" xml:space="preserve">
          <source>Observe the definitions of data items &amp;lsquo;</source>
          <target state="translated">데이터 항목의 정의를 준수하십시오.</target>
        </trans-unit>
        <trans-unit id="46c20583dd7802c40938fc2ba6c6048df2b3e1e9" translate="yes" xml:space="preserve">
          <source>Observe the following example, which illustrates a fourth manner in which tables may be initialized in GnuCOBOL:</source>
          <target state="translated">GnuCOBOL에서 테이블을 초기화 할 수있는 네 번째 방법을 보여주는 다음 예를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="34853f9fd3af3261ae1d13b30a481dda5e6e6ffb" translate="yes" xml:space="preserve">
          <source>Octal using O#0 - 7. (That is the letter &amp;lsquo;</source>
          <target state="translated">O # 0-7을 사용하는 8 진법. (즉, '</target>
        </trans-unit>
        <trans-unit id="cec634d4f1c842c1c34e5d70b1e1bba15a325f09" translate="yes" xml:space="preserve">
          <source>Of course, arithmetic expression operands may be numeric data items (any USAGE except POINTER or PROGRAM POINTER) as well as numeric literals.</source>
          <target state="translated">물론, 산술 연산 식 피연산자는 숫자 리터럴뿐만 아니라 숫자 데이터 항목 (POINTER 또는 PROGRAM POINTER를 제외한 모든 USAGE) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c771f9f082c2303d9a9bbc0ebb8ba28e8d3b77c" translate="yes" xml:space="preserve">
          <source>Of course, in keeping with the long-standing COBOL tradition of maintaining backwards compatibility with older standards, programmers (and, of course, compliant COBOL compilers) are capable of working in either mode. It is even possible to switch back and forth in the same program. The terms  &lt;em&gt;Fixed Format Mode&lt;/em&gt;  and  &lt;em&gt;Free Format Mode&lt;/em&gt;  are used to refer to these two modes of source code formatting.</source>
          <target state="translated">물론, 이전 표준과의 하위 호환성을 유지하는 오랜 COBOL 전통에 따라 프로그래머 (물론 호환 COBOL 컴파일러)는 어느 모드에서든 작업 할 수 있습니다. 동일한 프로그램에서 앞뒤로 전환하는 것도 가능합니다. &lt;em&gt;고정 형식 모드&lt;/em&gt; 및 &lt;em&gt;자유 형식 모드&lt;/em&gt; 라는 용어 는 이러한 두 가지 소스 코드 형식 모드를 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="78a794760583154700dfa158ef52ff59305ad6d4" translate="yes" xml:space="preserve">
          <source>Of course, in keeping with the long-standing COBOL tradition of maintaining backwards compatibility with older standards, programmers (and, of course, compliant COBOL compilers) are capable of working in either mode. It is even possible to switch back and forth in the same program. The terms &amp;rsquo;</source>
          <target state="translated">물론, 오래된 표준과의 하위 호환성을 유지하는 오랜 COBOL 전통을 유지하면서 프로그래머 (물론 호환되는 COBOL 컴파일러)는 어느 모드에서나 작업 할 수 있습니다. 동일한 프로그램에서 앞뒤로 전환 할 수도 있습니다. '</target>
        </trans-unit>
        <trans-unit id="c2e2ad12fe5d5be1ef373c4a92ce471d2c101183" translate="yes" xml:space="preserve">
          <source>Of course, whatever software you are using to deliver the printed document to the printer with must allow the ASCII form-feed character to pass through to the printer.</source>
          <target state="translated">물론 인쇄 된 문서를 프린터로 전달하는 데 사용하는 소프트웨어는 ASCII 용지 공급 문자를 프린터로 전달할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6347601d7b82e1f8887fbeb6b2289e39be3948bd" translate="yes" xml:space="preserve">
          <source>Of course, whatever software you are using to deliver the printed document to the printer with, must allow the &lt;small&gt;ASCII&lt;/small&gt; form-feed character to pass through to the printer.</source>
          <target state="translated">물론 인쇄 된 문서를 프린터로 전달하는 데 사용하는 소프트웨어가 무엇이든 &lt;small&gt;ASCII&lt;/small&gt; 용지 공급 문자가 프린터로 전달 될 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7ba8188f943f6bdc2d9048e32dcd7fb33cff506b" translate="yes" xml:space="preserve">
          <source>Of those &amp;lsquo;</source>
          <target state="translated">저것들의 '</target>
        </trans-unit>
        <trans-unit id="debcb349f44f33085c8c31a98daa95f7f75004d5" translate="yes" xml:space="preserve">
          <source>Of those currency symbols that correspond to character positions in which leading zeros reside, the right-most will have its &quot;0&quot; value replaced by the currency symbol in-effect for the program (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;). Any remaining leading zero values occupying positions described by this symbol will be replaced by spaces.</source>
          <target state="translated">선행 0이있는 문자 위치에 해당하는 통화 기호 중 가장 오른쪽에 &quot;0&quot;값이 프로그램에 영향을주는 통화 기호로 대체됩니다 ( &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 참조 ). 이 기호로 표시된 위치를 차지하는 나머지 선행 0 값은 공백으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="e456ff407b5ecd1b59e82896448ea6f0e2deb80d" translate="yes" xml:space="preserve">
          <source>Of those currency symbols that correspond to character positions in which leading zeros reside, the right-most will have its &amp;lsquo;</source>
          <target state="translated">선행 0이있는 문자 위치에 해당하는 통화 기호 중 맨 오른쪽에는 '</target>
        </trans-unit>
        <trans-unit id="6b4cb7a0fee3f3079461060f2f2b75e5bfc06ee6" translate="yes" xml:space="preserve">
          <source>Of those&lt;code&gt;+&lt;/code&gt;symbols that correspond to character positions in which leading zeros reside, the right-most will have its &quot;0&quot; value replaced by a &quot;+&quot; if the value in the data item is zero or greater or a &quot;-&quot; otherwise. Any remaining leading zero values occupying positions described by this symbol will be replaced by spaces. You cannot use both&lt;code&gt;+&lt;/code&gt;and&lt;code&gt;-&lt;/code&gt;in the same &amp;lt;</source>
          <target state="translated">선행 0이있는 문자 위치에 해당 하는 &lt;code&gt;+&lt;/code&gt; 기호 중 데이터 항목의 값이 0 이상이면 가장 오른쪽에있는 &quot;0&quot;값이 &quot;+&quot;로 바뀌고 그렇지 않으면 &quot;-&quot;가됩니다. 이 기호로 표시된 위치를 차지하는 나머지 선행 0 값은 공백으로 바뀝니다. &lt;code&gt;+&lt;/code&gt; 와 &lt;code&gt;-&lt;/code&gt; 를 동시에 사용할 수 없습니다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="bbf75e8475f5c8168cfdefa614e07198b0695e55" translate="yes" xml:space="preserve">
          <source>Of those&lt;code&gt;-&lt;/code&gt;symbols that correspond to character positions in which leading zeros reside, the right-most will have its &quot;0&quot; value replaced by a space if the value in the data item is zero or greater or a &quot;-&quot; otherwise. Any remaining leading zero values occupying positions described by this symbol will be replaced by spaces. You cannot use both&lt;code&gt;+&lt;/code&gt;and&lt;code&gt;-&lt;/code&gt;in the same &amp;lt;</source>
          <target state="translated">이 중 &lt;code&gt;-&lt;/code&gt; &quot;-&quot;그렇지 않으면 데이터 항목의 값이 0 이상이거나 경우 문자 앞에 0이 상주하는 문자 위치에 해당하는이, 우측은 가장 공백으로 대체의 &quot;0&quot;값을 가질 것이다. 이 기호로 표시된 위치를 차지하는 나머지 선행 0 값은 공백으로 바뀝니다. &lt;code&gt;+&lt;/code&gt; 와 &lt;code&gt;-&lt;/code&gt; 를 동시에 사용할 수 없습니다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="ef88e18e5314e5accac7e1424be9abc4cbdad69c" translate="yes" xml:space="preserve">
          <source>Offers support for MF Compiler Directives.</source>
          <target state="translated">MF 컴파일러 지시문에 대한 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8b1fab1aa655192e46dd089ef5dc5c15017129e0" translate="yes" xml:space="preserve">
          <source>On UNIX (including OSX, Windows/Cygwin and Windows/MinGW) systems, your locale is established via the</source>
          <target state="translated">UNIX (OSX, Windows / Cygwin 및 Windows / MinGW 포함) 시스템에서 로케일은</target>
        </trans-unit>
        <trans-unit id="4371dbb58ffcbfdae973e7019abb0ab41757b09a" translate="yes" xml:space="preserve">
          <source>On UNIX (including OSX, Windows/Cygwin and Windows/MinGW) systems, your locale is established via the   &lt;code&gt;LANG&lt;/code&gt; run-time environment variable (see &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;Run Time Environment Variables&lt;/a&gt;) environment variable. On Windows, the Control Panel&amp;rsquo;s Regional and Language Options define the locale.</source>
          <target state="translated">UNIX (OSX, Windows / Cygwin 및 Windows / MinGW 포함) 시스템에서는 &lt;code&gt;LANG&lt;/code&gt; 런타임 환경 변수 ( &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;런타임&lt;/a&gt; 환경 변수 참조 ) 환경 변수 를 통해 로케일이 설정됩니다 . Windows에서 제어판의 국가 및 언어 옵션은 로케일을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="02e632569f509af03efa7964cb1fa55564bdf21c" translate="yes" xml:space="preserve">
          <source>On Unix, OSX, or Windows/Cygwin builds, the</source>
          <target state="translated">Unix, OSX 또는 Windows / Cygwin 빌드에서</target>
        </trans-unit>
        <trans-unit id="7a4815ab2f080a81cd2be95835f85ca49905ca48" translate="yes" xml:space="preserve">
          <source>On Unix, OSX, or Windows/Cygwin builds, the&lt;code&gt;-x&lt;/code&gt;switch switch will generate an executable binary file, usually with no particular extension unless one is explicitly requested of the compiler via the&lt;code&gt;-o&lt;/code&gt;switch</source>
          <target state="translated">Unix, OSX 또는 Windows / Cygwin 빌드에서 &lt;code&gt;-x&lt;/code&gt; 스위치 스위치는 실행 가능한 이진 파일을 생성합니다. 일반적으로 &lt;code&gt;-o&lt;/code&gt; 스위치 를 통해 명시 적으로 컴파일러에 요청 된 경우가 아니면 특별한 확장명을 갖지 않습니다.</target>
        </trans-unit>
        <trans-unit id="baa101f65e9944384124638ea3189587789c566a" translate="yes" xml:space="preserve">
          <source>On Windows systems, single-quote, or apostrophe characters (&amp;rsquo;) will be treated just like any other data character and will NOT delineate argument strings.</source>
          <target state="translated">Windows 시스템에서 작은 따옴표 또는 아포스트로피 문자 ( ')는 다른 데이터 문자처럼 취급되며 인수 문자열을 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e22591213060e776766253051d21caed9cc1a81" translate="yes" xml:space="preserve">
          <source>On Windows systems, single-quote, or apostrophe, characters (&amp;lsquo;</source>
          <target state="translated">Windows 시스템에서 작은 따옴표 또는 아포스트로피 문자 ( '</target>
        </trans-unit>
        <trans-unit id="4161aa6155f2b3b50bafe2e0ddddef206267705b" translate="yes" xml:space="preserve">
          <source>On a UNIX system this means the programs may be executed from a command shell such as bash, csh, ksh and so forth. When a GnuCOBOL program runs on a Windows system, it runs within a console window (i.e.</source>
          <target state="translated">UNIX 시스템에서 이것은 프로그램이 bash, csh, ksh 등과 같은 명령 쉘에서 실행될 수 있음을 의미합니다. GnuCOBOL 프로그램이 Windows 시스템에서 실행되면 콘솔 창 (예 :</target>
        </trans-unit>
        <trans-unit id="4540801fc126e86f0e453dd121110c00baa3a3f3" translate="yes" xml:space="preserve">
          <source>On a UNIX system this means the programs may be executed from a command shell such as bash, csh, ksh and so forth. When a GnuCOBOL program runs on a Windows system, it runs within a console window (i.e. &quot;cmd.exe&quot;). OSX versions of GnuCOBOL programs run within a &quot;terminal.app&quot; window.</source>
          <target state="translated">UNIX 시스템에서 이것은 프로그램이 bash, csh, ksh 등과 같은 명령 쉘에서 실행될 수 있음을 의미합니다. GnuCOBOL 프로그램이 Windows 시스템에서 실행될 때 콘솔 창 (예 : &quot;cmd.exe&quot;) 내에서 실행됩니다. GnuCOBOL 프로그램의 OSX 버전은 &quot;terminal.app&quot;창에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="29e07a8440be1b45abe631d62a1c13d7f8e27480" translate="yes" xml:space="preserve">
          <source>On a Unix system, the shell environment will be established using the default shell program. This is also true when using a GnuCOBOL build created with and for OSX or the Cygwin Unix emulator.</source>
          <target state="translated">유닉스 시스템에서 쉘 환경은 기본 쉘 프로그램을 사용하여 설정됩니다. OSX 또는 Cygwin Unix 에뮬레이터로 생성 된 GnuCOBOL 빌드를 사용할 때도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="af55e7b1cbcd2989727c3429230b16527d3721da" translate="yes" xml:space="preserve">
          <source>On a Windows system, the &lt;code&gt;TMP&lt;/code&gt; environment variable is normally set for you when you logon. If you wish to use a different temporary folder, you may set &lt;code&gt;TMPDIR&lt;/code&gt; yourself and have no fear of disrupting other Windows software that relies on TMP.</source>
          <target state="translated">Windows 시스템에서 &lt;code&gt;TMP&lt;/code&gt; 환경 변수는 일반적으로 로그온 할 때 설정됩니다. 다른 임시 폴더를 사용하려는 경우 &lt;code&gt;TMPDIR&lt;/code&gt; 을 직접 설정 하고 TMP에 의존하는 다른 Windows 소프트웨어를 중단 할 염려가 없습니다.</target>
        </trans-unit>
        <trans-unit id="09cea21f0e62fb9defc06b78067faf5ba65df913" translate="yes" xml:space="preserve">
          <source>On a Windows system, the&lt;code&gt;TMP&lt;/code&gt;environment variable is normally set for you when you logon. If you wish to use a different temporary folder, you may set&lt;code&gt;TMPDIR&lt;/code&gt;yourself and have no fear of disrupting other Windows software that relies on TMP.</source>
          <target state="translated">Windows 시스템에서는 일반적으로 로그온 할 때 &lt;code&gt;TMP&lt;/code&gt; 환경 변수가 설정됩니다. 다른 임시 폴더를 사용하려면 &lt;code&gt;TMPDIR&lt;/code&gt; 을 직접 설정 하고 TMP에 의존하는 다른 Windows 소프트웨어를 방해 할 염려가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0f6d26b550b1ee3dcc3a84507d1eb437199ba578" translate="yes" xml:space="preserve">
          <source>On a system supporting only one format of binary storage (generally, that would be big-endian), the terms</source>
          <target state="translated">한 가지 형식의 바이너리 저장소 (일반적으로 빅 엔디안) 만 지원하는 시스템에서 용어</target>
        </trans-unit>
        <trans-unit id="49c811f291ecda0c24fa5479b92e28877266432a" translate="yes" xml:space="preserve">
          <source>On a system supporting only one format of binary storage (generally, that would be big-endian), the terms &amp;rsquo;most-efficient&amp;rsquo; and &amp;rsquo;native format&amp;rsquo; are synonymous.</source>
          <target state="translated">하나의 이진 저장 형식 (일반적으로 빅 엔디안) 만 지원하는 시스템에서 '가장 효율적인'및 '네이티브 형식'이라는 용어는 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="8cf55637bf6e9946a839f557065a9756657be924" translate="yes" xml:space="preserve">
          <source>On the first presentation of the detail group after any control break occurs.</source>
          <target state="translated">제어 중단 후 세부 사항 그룹의 첫 번째 프리젠 테이션에서.</target>
        </trans-unit>
        <trans-unit id="e5bea69f1d184e8b4396de7835faab7aa40b288f" translate="yes" xml:space="preserve">
          <source>On the first presentation of the detail group after every new page is started.</source>
          <target state="translated">모든 새 페이지가 시작된 후 세부 사항 그룹의 첫 번째 프리젠 테이션에서.</target>
        </trans-unit>
        <trans-unit id="610e218a02d7bb1f016c3ef41783ef19dcf52059" translate="yes" xml:space="preserve">
          <source>On the first presentation of the detail group following the &lt;code&gt;INITIATE&lt;/code&gt; (see &lt;a href=&quot;#INITIATE&quot;&gt;INITIATE&lt;/a&gt;) of the report.</source>
          <target state="translated">보고서 의 &lt;code&gt;INITIATE&lt;/code&gt; ( &lt;a href=&quot;#INITIATE&quot;&gt;INITIATE&lt;/a&gt; 참조 ) 이후 세부 그룹의 첫 번째 프레젠테이션에서 .</target>
        </trans-unit>
        <trans-unit id="17545f79b06e402b5aa4758aadea0e8d4f7b4497" translate="yes" xml:space="preserve">
          <source>On the first presentation of the detail group following the&lt;code&gt;INITIATE&lt;/code&gt;(see &lt;a href=&quot;#INITIATE&quot;&gt;INITIATE&lt;/a&gt;) of the report.</source>
          <target state="translated">보고서 의 &lt;code&gt;INITIATE&lt;/code&gt; ( &lt;a href=&quot;#INITIATE&quot;&gt;INITIATE&lt;/a&gt; 참조 ) 다음에 세부 사항 그룹의 첫 번째 프리젠 테이션에서 .</target>
        </trans-unit>
        <trans-unit id="9525ae88a058bce1077fdfcee161a09188f2755b" translate="yes" xml:space="preserve">
          <source>Once GnuCOBOL programs have been compiled into either directly-executable programs (created via the</source>
          <target state="translated">GnuCOBOL 프로그램이 직접 실행 가능한 프로그램 (</target>
        </trans-unit>
        <trans-unit id="621bb9957748f1c9660b66609e36e16b3f8976de" translate="yes" xml:space="preserve">
          <source>Once GnuCOBOL programs have been compiled into either directly-executable programs (created via the&lt;code&gt;-x&lt;/code&gt;switch) or dynamically-loadable libraries (created via the&lt;code&gt;-m&lt;/code&gt;switch), those programs may be executed from any shell environment. The exact manner in which the two are executed will differ, as described in the upcoming sections.</source>
          <target state="translated">GnuCOBOL 프로그램이 직접 실행 가능한 프로그램 ( &lt;code&gt;-x&lt;/code&gt; 스위치 를 통해 생성됨 ) 또는 동적으로로드 가능한 라이브러리 ( &lt;code&gt;-m&lt;/code&gt; 스위치 를 통해 생성됨) 로 컴파일되면 해당 프로그램은 모든 쉘 환경에서 실행될 수 있습니다. 다음 섹션에서 설명하는 것처럼 두 가지를 실행하는 정확한 방식은 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1ef03c1edf38bb7749581fc6cd2e170dfcec7965" translate="yes" xml:space="preserve">
          <source>Once a Format 1 &lt;code&gt;REPLACE&lt;/code&gt; statement is encountered in the currently-compiling source file, Replace Mode becomes active, and the change(s) specified by that statement will be automatically made on all subsequent source statements the compiler reads from the file.</source>
          <target state="translated">현재 컴파일중인 소스 파일에서 Format 1 &lt;code&gt;REPLACE&lt;/code&gt; 문이 발견되면 Replace Mode가 활성화되고 해당 문에 지정된 변경 사항은 컴파일러가 파일에서 읽는 모든 후속 소스 문에서 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="77004179f0b5866728a6a173ab6e2cd8c6678cae" translate="yes" xml:space="preserve">
          <source>Once a Format 1&lt;code&gt;REPLACE&lt;/code&gt;statement is encountered in the currently-compiling source file, Replace Mode becomes active, and the change(s) specified by that statement will be automatically made on all subsequent source statements the compiler reads from the file.</source>
          <target state="translated">현재 컴파일중인 소스 파일에서 형식 1 &lt;code&gt;REPLACE&lt;/code&gt; 문이 발생하면 대체 모드가 활성화되고 해당 명령문으로 지정된 변경이 컴파일러가 파일에서 읽는 모든 후속 소스 명령문에서 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6d2c64519a47a1491ded5e591752c517d14bf328" translate="yes" xml:space="preserve">
          <source>Once a dynamically-loadable module is actually loaded into memory, even if it is subsequently unloaded (via the &lt;code&gt;CANCEL&lt;/code&gt; statement), its list of entry-points remain available to the GnuCOBOL run-time library and subsequent re-executions of any of those entry points will be able to bypass the search (rule #4) as well as the</source>
          <target state="translated">동적으로로드 할 수있는 모듈이 실제로 메모리에로드되면 ( &lt;code&gt;CANCEL&lt;/code&gt; 문을 통해) 이후에 언로드 되더라도 진입 점 목록은 GnuCOBOL 런타임 라이브러리 및 해당 항목의 후속 재실행에서 계속 사용할 수 있습니다. 포인트는 검색 (규칙 # 4)뿐 아니라</target>
        </trans-unit>
        <trans-unit id="dc16e338caa3250507aeb7e1c7c59077ca7fc160" translate="yes" xml:space="preserve">
          <source>Once a dynamically-loadable module is actually loaded into memory, even if it is subsequently unloaded (via the&lt;code&gt;CANCEL&lt;/code&gt;statement), it&amp;rsquo;s list of entry-points remain available to the GnuCOBOL run-time library and subsequent re-executions of any of those entry points will be able to bypass the search (rule #4) as well as the &quot;first-execution rule&quot; (rule #3).</source>
          <target state="translated">동적으로로드 가능한 모듈이 실제로 메모리에로드되면 ( &lt;code&gt;CANCEL&lt;/code&gt; 문을 통해) 나중에 언로드하더라도 엔트리 포인트 목록은 GnuCOBOL 런타임 라이브러리에서 계속 사용할 수 있으며 해당 엔트리의 재실행은 계속 유지됩니다. 포인트는 &quot;첫 실행 규칙&quot;(규칙 # 3)뿐만 아니라 검색 (규칙 # 4)을 우회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f4ebf79a6128ffb4296f6d51960e2abeced39da" translate="yes" xml:space="preserve">
          <source>Once a field list has been determined, each item in that field list will be initialized as if an individual &lt;code&gt;MOVE&lt;/code&gt; (see &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt;) statement to that effect had been coded. The rules for initialization are as follows:</source>
          <target state="translated">필드 목록이 결정되면 해당 필드 목록의 각 항목은 해당 효과에 대한 개별 &lt;code&gt;MOVE&lt;/code&gt; ( &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt; 참조 ) 문이 코딩 된 것처럼 초기화됩니다 . 초기화 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59e918dab4bdf59a27422aa9bebbbdf5591d8385" translate="yes" xml:space="preserve">
          <source>Once a field list has been determined, each item in that field list will be initialized as if an individual&lt;code&gt;MOVE&lt;/code&gt;(see &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt;) statement to that effect had been coded. The rules for initialization are as follows:</source>
          <target state="translated">필드 목록이 결정되면 해당 필드 목록의 각 항목은 해당 효과에 대한 개별 &lt;code&gt;MOVE&lt;/code&gt; ( &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt; 참조 ) 명령문이 코딩 된 것처럼 초기화됩니다 . 초기화 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="286757838794003214e83168a9d3c53442e79df6" translate="yes" xml:space="preserve">
          <source>Once an environment variable name base (let&amp;rsquo;s refer to it as &quot;bbbb&quot;) has been determined, the runtime system will look for the first one of the following environment variables that exists, in this sequence:</source>
          <target state="translated">환경 변수 이름 기반 ( &quot;bbbb&quot;라고 함)이 결정되면 런타임 시스템은 다음 순서로 존재하는 다음 환경 변수 중 첫 번째 변수를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="fb26d1ca93153363fd5fbfd4cc09a22ab21757f3" translate="yes" xml:space="preserve">
          <source>Once an environment variable name base (let&amp;rsquo;s refer to it as &lt;code&gt;&lt;var&gt;bbbb&lt;/var&gt;&lt;/code&gt;) has been determined, the runtime system will look for the first one of the following environment variables that exists, in this sequence:</source>
          <target state="translated">환경 변수 이름베이스 ( &lt;code&gt;&lt;var&gt;bbbb&lt;/var&gt;&lt;/code&gt; 라고 함 )가 결정되면 런타임 시스템은이 순서대로 존재하는 다음 환경 변수 중 첫 번째를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="e625244fde391b91510dca176749dade404d9a46" translate="yes" xml:space="preserve">
          <source>Once class &quot;Hexadecimal&quot; has been defined, program code could then use a statement such as&lt;code&gt;IF input-item IS Hexadecimal&lt;/code&gt;to determine if the value of characters in a data item are valid according to that class.</source>
          <target state="translated">&quot;16 진수&quot;클래스가 정의되면 프로그램 코드는 &lt;code&gt;IF input-item IS Hexadecimal&lt;/code&gt; 와 같은 명령문을 사용 하여 데이터 항목의 문자 값이 해당 클래스에 따라 유효한지 여부를 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fd0689c6061a45691138c95fa71cdc6f29d354f" translate="yes" xml:space="preserve">
          <source>Once class &lt;code&gt;Hexadecimal&lt;/code&gt; has been defined, program code could then use a statement such as &lt;code&gt;IF input-item IS Hexadecimal&lt;/code&gt; to determine if the value of characters in a data item are valid according to that class.</source>
          <target state="translated">클래스 &lt;code&gt;Hexadecimal&lt;/code&gt; 이 정의되면 프로그램 코드는 &lt;code&gt;IF input-item IS Hexadecimal&lt;/code&gt; 과 같은 문을 사용 하여 데이터 항목의 문자 값이 해당 클래스에 따라 유효한지 여부를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a7607f575f1fa9fa2920755a20a174fae035147" translate="yes" xml:space="preserve">
          <source>Once in that form, mathematical operations may be performed against the internal date before it is transformed back into a date using the &lt;code&gt;DATE-OF-INTEGER&lt;/code&gt; (see &lt;a href=&quot;#DATE_002dOF_002dINTEGER&quot;&gt;DATE-OF-INTEGER&lt;/a&gt;) or &lt;code&gt;DAY-OF-INTEGER&lt;/code&gt; (see &lt;a href=&quot;#DAY_002dOF_002dINTEGER&quot;&gt;DAY-OF-INTEGER&lt;/a&gt;) function.</source>
          <target state="translated">해당 형식이되면 &lt;code&gt;DATE-OF-INTEGER&lt;/code&gt; ( &lt;a href=&quot;#DATE_002dOF_002dINTEGER&quot;&gt;DATE-OF-INTEGER 참조&lt;/a&gt; ) 또는 &lt;code&gt;DAY-OF-INTEGER&lt;/code&gt; ( &lt;a href=&quot;#DAY_002dOF_002dINTEGER&quot;&gt;DAY-OF-INTEGER&lt;/a&gt; 참조 )를 사용하여 날짜 로 다시 변환되기 전에 내부 날짜에 대해 수학적 연산을 수행 할 수 있습니다. ) 함수.</target>
        </trans-unit>
        <trans-unit id="0585d2910d0c3575c9ce966ec284963466eee0b8" translate="yes" xml:space="preserve">
          <source>Once in that form, mathematical operations may be performed against the internal date before it is transformed back into a date using the&lt;code&gt;DATE-OF-INTEGER&lt;/code&gt;(see &lt;a href=&quot;#DATE_002dOF_002dINTEGER&quot;&gt;DATE-OF-INTEGER&lt;/a&gt;) or&lt;code&gt;DAY-OF-INTEGER&lt;/code&gt;(see &lt;a href=&quot;#DAY_002dOF_002dINTEGER&quot;&gt;DAY-OF-INTEGER&lt;/a&gt;) function.</source>
          <target state="translated">해당 양식에 들어가면 &lt;code&gt;DATE-OF-INTEGER&lt;/code&gt; ( &lt;a href=&quot;#DATE_002dOF_002dINTEGER&quot;&gt;DATE-OF-INTEGER 참조&lt;/a&gt; ) 또는 &lt;code&gt;DAY-OF-INTEGER&lt;/code&gt; ( &lt;a href=&quot;#DAY_002dOF_002dINTEGER&quot;&gt;DAY-OF-INTEGER&lt;/a&gt; 참조 )를 사용하여 날짜 로 다시 변환되기 전에 내부 날짜에 대해 수학 연산을 수행 할 수 있습니다. ) 함수.</target>
        </trans-unit>
        <trans-unit id="27a460e37f19959ffeef81697854eed6253ff720" translate="yes" xml:space="preserve">
          <source>Once read from the file, the newly-retrieved record data will be saved into the 01-level record structure(s) that immediately follow the file&amp;rsquo;s &lt;code&gt;FD&lt;/code&gt;. If the optional  &lt;code&gt;INTO&lt;/code&gt; clause is present, a copy of the just-retrieved record will be automatically moved to &lt;var&gt;identifier-1&lt;/var&gt;.</source>
          <target state="translated">파일에서 읽은 후에 새로 검색된 레코드 데이터는 파일의 &lt;code&gt;FD&lt;/code&gt; 바로 뒤에 오는 01 레벨 레코드 구조에 저장됩니다 . 선택적 &lt;code&gt;INTO&lt;/code&gt; 절이있는 경우 방금 검색된 레코드의 복사본이 자동으로 &lt;var&gt;identifier-1&lt;/var&gt; 로 이동됩니다 .</target>
        </trans-unit>
        <trans-unit id="3d181d18b6a5fa0a6fa8cff3acb56941d7cd3053" translate="yes" xml:space="preserve">
          <source>Once read from the file, the newly-retrieved record data will be saved into the 01-level record structure(s) that immediately follow the file&amp;rsquo;s&lt;code&gt;FD&lt;/code&gt; If the optional&lt;code&gt;INTO&lt;/code&gt;</source>
          <target state="translated">파일에서 읽은 후 새로 검색된 레코드 데이터는 파일의 &lt;code&gt;FD&lt;/code&gt; 를 바로 따르는 01 레벨 레코드 구조에 저장됩니다 ( 선택적 &lt;code&gt;INTO&lt;/code&gt; 인 경우).</target>
        </trans-unit>
        <trans-unit id="f9b7144965544259e3f97d35c9ae743160170dca" translate="yes" xml:space="preserve">
          <source>Once that has been done, every (extended) ACCEPT, will return a value in COB_CRT_STATUS reflecting mouse activity, when such activity occurs. The applicable values are shown in screenio.cpy under ?Exception keys for mouse handling?. If you define a variable in SPECIAL NAMES as follows:</source>
          <target state="translated">이 작업이 완료되면 모든 (확장 된) ACCEPT는 이러한 활동이 발생할 때 마우스 활동을 반영하는 COB_CRT_STATUS의 값을 반환합니다. 적용 가능한 값은 &quot;마우스 처리를위한 예외 키&quot;아래 screenio.cpy에 표시됩니다. SPECIAL NAMES에서 다음과 같이 변수를 정의하는 경우 :</target>
        </trans-unit>
        <trans-unit id="ed7991d9259d5488ffed54f05830f63330c16c88" translate="yes" xml:space="preserve">
          <source>Once the &amp;lt;</source>
          <target state="translated">한 번 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="099be0ad066e470c8f7df22253bba59177591c86" translate="yes" xml:space="preserve">
          <source>Once the &lt;var&gt;imperative-statement-1&lt;/var&gt; has been executed, or no &lt;var&gt;imperative-statement-1&lt;/var&gt; was found anywhere after the &amp;rsquo;</source>
          <target state="translated">Once the &lt;var&gt;imperative-statement-1&lt;/var&gt; has been executed, or no &lt;var&gt;imperative-statement-1&lt;/var&gt; was found anywhere after the &amp;rsquo;</target>
        </trans-unit>
        <trans-unit id="264435854347c75ecb5af8a5bf18fc2e6979a2d1" translate="yes" xml:space="preserve">
          <source>Once the address of a procedure division code area has been acquired in this way, the address could be passed to a subroutine (usually written in C) for whatever use it needs it for. For examples of &lt;code&gt;PROGRAM-POINTER&lt;/code&gt;s at work, see the discussions of the &lt;code&gt;CBL_ERROR_PROC&lt;/code&gt; built-in system subroutine (see &lt;a href=&quot;#CBL_005fERROR_005fPROC&quot;&gt;CBL_ERROR_PROC&lt;/a&gt;) and &lt;code&gt;CBL_EXIT_PROC&lt;/code&gt; built-in system subroutine (see &lt;a href=&quot;#CBL_005fEXIT_005fPROC&quot;&gt;CBL_EXIT_PROC&lt;/a&gt;).</source>
          <target state="translated">Once the address of a procedure division code area has been acquired in this way, the address could be passed to a subroutine (usually written in C) for whatever use it needs it for. For examples of &lt;code&gt;PROGRAM-POINTER&lt;/code&gt; s at work, see the discussions of the &lt;code&gt;CBL_ERROR_PROC&lt;/code&gt; built-in system subroutine (see &lt;a href=&quot;#CBL_005fERROR_005fPROC&quot;&gt;CBL_ERROR_PROC&lt;/a&gt;) and &lt;code&gt;CBL_EXIT_PROC&lt;/code&gt; built-in system subroutine (see &lt;a href=&quot;#CBL_005fEXIT_005fPROC&quot;&gt;CBL_EXIT_PROC&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="76eaa092cafda97efbcf2f6303d6984802250d02" translate="yes" xml:space="preserve">
          <source>Once the address of a procedure division code area has been acquired in this way, the address could be passed to a subroutine (usually written in C) for whatever use it needs it for. For examples of&lt;code&gt;PROGRAM-POINTER&lt;/code&gt; at work, see the discussions of the&lt;code&gt;CBL_ERROR_PROC&lt;/code&gt;built-in system subroutine (see &lt;a href=&quot;#CBL_005fERROR_005fPROC&quot;&gt;CBL_ERROR_PROC&lt;/a&gt;) and&lt;code&gt;CBL_EXIT_PROC&lt;/code&gt;built-in system subroutine (see &lt;a href=&quot;#CBL_005fEXIT_005fPROC&quot;&gt;CBL_EXIT_PROC&lt;/a&gt;).</source>
          <target state="translated">절차 분할 코드 영역의 주소가 이러한 방식으로 획득되면, 주소는 필요한 용도로 서브 루틴 (일반적으로 C로 작성 됨)으로 전달 될 수 있습니다. 작동중인 &lt;code&gt;PROGRAM-POINTER&lt;/code&gt; 의 예는 &lt;code&gt;CBL_ERROR_PROC&lt;/code&gt; 내장 시스템 서브 루틴 ( &lt;a href=&quot;#CBL_005fERROR_005fPROC&quot;&gt;CBL_ERROR_PROC&lt;/a&gt; 참조 ) 및 &lt;code&gt;CBL_EXIT_PROC&lt;/code&gt; 내장 시스템 서브 루틴 ( &lt;a href=&quot;#CBL_005fEXIT_005fPROC&quot;&gt;CBL_EXIT_PROC&lt;/a&gt; 참조 )에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7b3e993beace23677f33388c1750dc84928bf9a" translate="yes" xml:space="preserve">
          <source>Once the dynamically-loadable module has been successfully loaded, any of the entry-points contained within it are now available for reference.</source>
          <target state="translated">동적으로로드 가능한 모듈이 성공적으로로드되면 모듈에 포함 된 진입 점을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf655804b96355c58d780ad7c184b2358e70ed87" translate="yes" xml:space="preserve">
          <source>Once the input procedure terminates, the input phase is complete.</source>
          <target state="translated">입력 절차가 끝나면 입력 단계가 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="c3c67cac00280fcb367535119a29438c7a49b6c1" translate="yes" xml:space="preserve">
          <source>Once the list of control breaks has been determined, the &lt;code&gt;CONTROL FOOTING&lt;/code&gt; for each &lt;var&gt;identifier-2&lt;/var&gt; having a control break (if any such report group is defined) will be presented.</source>
          <target state="translated">Once the list of control breaks has been determined, the &lt;code&gt;CONTROL FOOTING&lt;/code&gt; for each &lt;var&gt;identifier-2&lt;/var&gt; having a control break (if any such report group is defined) will be presented.</target>
        </trans-unit>
        <trans-unit id="3fd5f8ce1885cd5e6704d4107925ee0fa79ae370" translate="yes" xml:space="preserve">
          <source>Once the list of control breaks has been determined, the&lt;code&gt;CONTROL FOOTING&lt;/code&gt;for each &amp;lt;</source>
          <target state="translated">브레이크 제어 목록은 결정되면 &lt;code&gt;CONTROL FOOTING&lt;/code&gt; 각각을 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="da82fa2addff5a8b53971b5198ac5b3f2dbaf44c" translate="yes" xml:space="preserve">
          <source>Once the module has been located (if location was needed), it will be loaded into memory (if not already loaded).</source>
          <target state="translated">일단 모듈을 찾으면 (위치가 필요한 경우) 메모리에로드됩니다 (아직로드되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="4ea7f4222f4e79b517953879f7a0910e37dccbb7" translate="yes" xml:space="preserve">
          <source>Once the output procedure terminates, or the last &amp;lt;</source>
          <target state="translated">출력 절차가 종료되거나 마지막 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="aaa0833d3db41ac1347c6b5bf79fb0df2decfc42" translate="yes" xml:space="preserve">
          <source>Once the output procedure terminates, or the last &lt;var&gt;file-name-3&lt;/var&gt; file has been populated with merged data, the output phase &amp;mdash; and the &lt;code&gt;MERGE&lt;/code&gt; statement itself &amp;mdash; is complete.</source>
          <target state="translated">Once the output procedure terminates, or the last &lt;var&gt;file-name-3&lt;/var&gt; file has been populated with merged data, the output phase &amp;mdash; and the &lt;code&gt;MERGE&lt;/code&gt; statement itself &amp;mdash; is complete.</target>
        </trans-unit>
        <trans-unit id="ff0f3a202fb5e56e9e5055a0c22a464e320087b3" translate="yes" xml:space="preserve">
          <source>Once the output procedure terminates, the sort is complete.</source>
          <target state="translated">출력 절차가 끝나면 정렬이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="aa2d27ad2b6a5bb2d485b2b3cf531800fdf57d2a" translate="yes" xml:space="preserve">
          <source>Once the sort stage is complete, a copy of the sorted data will be written to each &amp;lt;</source>
          <target state="translated">정렬 단계가 완료되면 정렬 된 데이터의 사본이 각 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c2b31d50fc738d0b1586f3c6b1ed68f5906665b4" translate="yes" xml:space="preserve">
          <source>Once the sort stage is complete, a copy of the sorted data will be written to each &lt;var&gt;file-name-2&lt;/var&gt; if the  &lt;code&gt;GIVING&lt;/code&gt; clause was specified. None of the &lt;var&gt;file-name-2&lt;/var&gt; files can be open at the time the sort is executed.</source>
          <target state="translated">Once the sort stage is complete, a copy of the sorted data will be written to each &lt;var&gt;file-name-2&lt;/var&gt; if the &lt;code&gt;GIVING&lt;/code&gt; clause was specified. None of the &lt;var&gt;file-name-2&lt;/var&gt; files can be open at the time the sort is executed.</target>
        </trans-unit>
        <trans-unit id="a952da0c3633e235f52bb16ddddf1c8394a97156" translate="yes" xml:space="preserve">
          <source>Once tokens have been identified, the first (the command) will be discarded; the rest will be stored into the &quot;CHAINING&quot; arguments when the program begins execution, with the 2nd token going to the 1st argument, the 3rd token going to the 2nd argument and so forth.</source>
          <target state="translated">토큰이 식별되면 첫 번째 (명령)가 삭제됩니다. 나머지는 프로그램이 실행을 시작할 때 &quot;CHAINING&quot;인수에 저장되며, 두 번째 토큰은 첫 번째 인수로, 세 번째 토큰은 두 번째 인수로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="e96bd4b7d9454c7ae8c13f2d3cc74a634a9784b0" translate="yes" xml:space="preserve">
          <source>Once tokens have been identified, the first one (the command) will be discarded; the rest will be stored into the &lt;code&gt;CHAINING&lt;/code&gt; arguments when the program begins execution, with the 2nd token going to the 1&lt;sup&gt;st&lt;/sup&gt; argument, the 3rd token going to the 2nd argument and so forth.</source>
          <target state="translated">Once tokens have been identified, the first one (the command) will be discarded; the rest will be stored into the &lt;code&gt;CHAINING&lt;/code&gt; arguments when the program begins execution, with the 2nd token going to the 1&lt;sup&gt;st&lt;/sup&gt; argument, the 3rd token going to the 2nd argument and so forth.</target>
        </trans-unit>
        <trans-unit id="15cdd4ea42611c8aef9419d97cee120ed7df8109" translate="yes" xml:space="preserve">
          <source>Once you have defined an alphabet name, that alphabet name may be used on specifications in &lt;code&gt;CODE-SET&lt;/code&gt;, &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt;, or &lt;code&gt;SYMBOLIC CHARACTERS&lt;/code&gt; clauses elsewhere in the program.</source>
          <target state="translated">Once you have defined an alphabet name, that alphabet name may be used on specifications in &lt;code&gt;CODE-SET&lt;/code&gt; , &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; , or &lt;code&gt;SYMBOLIC CHARACTERS&lt;/code&gt; clauses elsewhere in the program.</target>
        </trans-unit>
        <trans-unit id="fc842de35b43065fcc2486b3f9cd1a54afa40e68" translate="yes" xml:space="preserve">
          <source>Once you have defined an alphabet name, that alphabet name may be used on specifications in&lt;code&gt;CODE-SET&lt;/code&gt;&lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; or&lt;code&gt;SYMBOLIC CHARACTERS&lt;/code&gt;clauses elsewhere in the program.</source>
          <target state="translated">알파벳 이름을 정의하면 해당 알파벳 이름을 프로그램의 다른 곳에서 &lt;code&gt;CODE-SET&lt;/code&gt; &lt;code&gt;SYMBOLIC CHARACTERS&lt;/code&gt; &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; 또는 SYMBOLIC CHARACTERS 절의 스펙에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1db8d869f5e31c2a114146e31c6c3bb19304efe6" translate="yes" xml:space="preserve">
          <source>Once you know the answer to questions 1-4, you may easily determine the answers to the remaining questions as follows:</source>
          <target state="translated">질문 1-4에 대한 답을 알고 나면 다음과 같이 나머지 질문에 대한 답을 쉽게 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d64e944e7805a2994fd1366f274fdd6a314f0fc1" translate="yes" xml:space="preserve">
          <source>Once your program has been thoroughly tested, you&amp;rsquo;ll want different sequences to be generated each time the program runs. One possible way to accomplish this is to use a &amp;lt;</source>
          <target state="translated">프로그램이 철저히 테스트되면 프로그램이 실행될 때마다 다른 시퀀스가 ​​생성되기를 원할 것입니다. 이를 수행하는 한 가지 가능한 방법은 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="bf37040bfaedfe2d348e9a0d2741f73ecc8dc3be" translate="yes" xml:space="preserve">
          <source>Once your program has been thoroughly tested, you&amp;rsquo;ll want different sequences to be generated each time the program runs. One possible way to accomplish this is to use a &lt;var&gt;seed&lt;/var&gt; that is likely to be different every time the program is executed, as is likely to be the case if the first &lt;code&gt;MOVE&lt;/code&gt; statement in the previous example were replaced by this:</source>
          <target state="translated">Once your program has been thoroughly tested, you&amp;rsquo;ll want different sequences to be generated each time the program runs. One possible way to accomplish this is to use a &lt;var&gt;seed&lt;/var&gt; that is likely to be different every time the program is executed, as is likely to be the case if the first &lt;code&gt;MOVE&lt;/code&gt; statement in the previous example were replaced by this:</target>
        </trans-unit>
        <trans-unit id="1007c41e5b30e5bc282ba8e877ad350a95367078" translate="yes" xml:space="preserve">
          <source>One of COBOL&amp;rsquo;s strengths is the wide variety of data files it is capable of accessing. GnuCOBOL programs, like those created with other COBOL implementations, need to have the structure of any files they will be reading and/or writing described to them. The highest-level characteristic of a file&amp;rsquo;s structure is defined by specifying the organization of the file, as follows:</source>
          <target state="translated">One of COBOL&amp;rsquo;s strengths is the wide variety of data files it is capable of accessing. GnuCOBOL programs, like those created with other COBOL implementations, need to have the structure of any files they will be reading and/or writing described to them. The highest-level characteristic of a file&amp;rsquo;s structure is defined by specifying the organization of the file, as follows:</target>
        </trans-unit>
        <trans-unit id="1b78c56a06d1111a84b2f488c993f432b739bce9" translate="yes" xml:space="preserve">
          <source>One of these environment variables must be set to a directory/folder appropriate to create temporary files in. They will be checked in the order shown. This will be used by the &lt;code&gt;SORT&lt;/code&gt; statement (see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) and &lt;code&gt;MERGE&lt;/code&gt; statement (see &lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt;) to create temporary work files. You may also use this folder for any temporary files your application may require.</source>
          <target state="translated">One of these environment variables must be set to a directory/folder appropriate to create temporary files in. They will be checked in the order shown. This will be used by the &lt;code&gt;SORT&lt;/code&gt; statement (see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) and &lt;code&gt;MERGE&lt;/code&gt; statement (see &lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt;) to create temporary work files. You may also use this folder for any temporary files your application may require.</target>
        </trans-unit>
        <trans-unit id="54f89a5962f679ffd2d3e844b0b1ce85b6df3297" translate="yes" xml:space="preserve">
          <source>One of these environment variables must be set to a directory/folder appropriate to create temporary files in. They will be checked in the order shown. This will be used by the&lt;code&gt;SORT&lt;/code&gt;statement (see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) and&lt;code&gt;MERGE&lt;/code&gt;statement (see &lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt;) to create temporary work files. You may also use this folder for any temporary files your application may require.</source>
          <target state="translated">이러한 환경 변수 중 하나는 임시 파일을 작성하기에 적합한 디렉토리 / 폴더로 설정해야합니다. 표시된 순서대로 검사됩니다. 이것은에 의해 사용됩니다 &lt;code&gt;SORT&lt;/code&gt; 의 문 (참조 &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt; ) 및 &lt;code&gt;MERGE&lt;/code&gt; 의 문 (참조 &lt;a href=&quot;#MERGE&quot;&gt;MERGE를&lt;/a&gt; ) 임시 작업 파일을 만들 수 있습니다. 응용 프로그램에 필요할 수있는 임시 파일에이 폴더를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6463f11b8fdf738c63c7b961b5112c2ffeb1404" translate="yes" xml:space="preserve">
          <source>One or more consecutive lines on a report that serve a common informational purpose or function. For example, lines of text that are displayed at the top or bottom of every printed page of a report.</source>
          <target state="translated">공통 정보 목적 또는 기능을 제공하는 보고서에서 하나 이상의 연속 행. 예를 들어, 보고서의 인쇄 된 모든 페이지의 상단 또는 하단에 표시되는 텍스트 줄입니다.</target>
        </trans-unit>
        <trans-unit id="3c39ac374029c24f83bf8591d48eb3909021e14c" translate="yes" xml:space="preserve">
          <source>Only after this processing has occurred will the detail report group specified on the &lt;code&gt;GENERATE&lt;/code&gt; be presented.</source>
          <target state="translated">Only after this processing has occurred will the detail report group specified on the &lt;code&gt;GENERATE&lt;/code&gt; be presented.</target>
        </trans-unit>
        <trans-unit id="6c681ed8f13156a1b9ed27937daab32b1e788722" translate="yes" xml:space="preserve">
          <source>Only after this processing has occurred will the detail report group specified on the&lt;code&gt;GENERATE&lt;/code&gt;be presented.</source>
          <target state="translated">이 처리가 수행 된 후에 만 &lt;code&gt;GENERATE&lt;/code&gt; 에 지정된 세부 사항 보고서 그룹 이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0878acfc97c4bcb73f941a94c4ad372a7d6b027a" translate="yes" xml:space="preserve">
          <source>Only data items whose &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) is either explicitly or implicitly defined as &lt;code&gt;DISPLAY&lt;/code&gt; may be used in &lt;code&gt;NUMERIC&lt;/code&gt; or any of the &lt;code&gt;ALPHABETIC&lt;/code&gt; class conditions.</source>
          <target state="translated">Only data items whose &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) is either explicitly or implicitly defined as &lt;code&gt;DISPLAY&lt;/code&gt; may be used in &lt;code&gt;NUMERIC&lt;/code&gt; or any of the &lt;code&gt;ALPHABETIC&lt;/code&gt; class conditions.</target>
        </trans-unit>
        <trans-unit id="003eead4533ce41b48b2d118ad6982ea6215902b" translate="yes" xml:space="preserve">
          <source>Only data items whose&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) is either explicitly or implicitly defined as&lt;code&gt;DISPLAY&lt;/code&gt;may be used in&lt;code&gt;NUMERIC&lt;/code&gt;or any of the&lt;code&gt;ALPHABETIC&lt;/code&gt;class conditions.</source>
          <target state="translated">그의 유일한 데이터 항목 &lt;code&gt;USAGE&lt;/code&gt; (참조 &lt;a href=&quot;#USAGE&quot;&gt;사용&lt;/a&gt; ) 명시 적으로 또는 암시 적으로 정의 &lt;code&gt;DISPLAY&lt;/code&gt; 사용될 수있다 &lt;code&gt;NUMERIC&lt;/code&gt; 또는 임의의 &lt;code&gt;ALPHABETIC&lt;/code&gt; 클래스 조건.</target>
        </trans-unit>
        <trans-unit id="aaecd5a9bfef1b6b18b34a342db9bff51d9af2d8" translate="yes" xml:space="preserve">
          <source>Only files intended for use as work files for either the &lt;code&gt;SORT&lt;/code&gt; (see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) or &lt;code&gt;MERGE&lt;/code&gt; (see &lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt;) statements should be coded with an SD &amp;mdash; all others should be defined with a FD.</source>
          <target state="translated">Only files intended for use as work files for either the &lt;code&gt;SORT&lt;/code&gt; (see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) or &lt;code&gt;MERGE&lt;/code&gt; (see &lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt;) statements should be coded with an SD &amp;mdash; all others should be defined with a FD.</target>
        </trans-unit>
        <trans-unit id="d711ce7b6238bc52f8a6bcb50fdf5f00798177b9" translate="yes" xml:space="preserve">
          <source>Only files intended for use as work files for either the&lt;code&gt;SORT&lt;/code&gt;(see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) or&lt;code&gt;MERGE&lt;/code&gt;(see &lt;a href=&quot;#MERGE&quot;&gt;MERGE&lt;/a&gt;) statements should be coded with an SD &amp;mdash; all others should be defined with a FD.</source>
          <target state="translated">오직 하나의 작업 파일로 사용하기위한 파일 &lt;code&gt;SORT&lt;/code&gt; (참조 &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt; ) 또는 &lt;code&gt;MERGE&lt;/code&gt; (참조 &lt;a href=&quot;#MERGE&quot;&gt;병합&lt;/a&gt; ) 문가 SD로 코딩해야한다 - 모든 사람은 FD로 정의되어야한다.</target>
        </trans-unit>
        <trans-unit id="5e7f05d01153592a3701f9579ca1ebed0c7e36f8" translate="yes" xml:space="preserve">
          <source>Only numeric data can be moved to a numeric or numeric-edited &amp;lt;</source>
          <target state="translated">숫자 데이터 만 숫자 또는 숫자로 편집 된 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="1d3c31f94bcd1e842b319e54618163a1e309e182" translate="yes" xml:space="preserve">
          <source>Only numeric data can be moved to a numeric or numeric-edited &lt;var&gt;identifier-2&lt;/var&gt;. A &lt;code&gt;MOVE&lt;/code&gt; involving numeric data will perform any necessary format conversions that might be necessary due to differing &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) specifications.</source>
          <target state="translated">Only numeric data can be moved to a numeric or numeric-edited &lt;var&gt;identifier-2&lt;/var&gt; . A &lt;code&gt;MOVE&lt;/code&gt; involving numeric data will perform any necessary format conversions that might be necessary due to differing &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) specifications.</target>
        </trans-unit>
        <trans-unit id="1a023314ae52d9ab2ebf57a5486f828683de142e" translate="yes" xml:space="preserve">
          <source>Only one of the &amp;lt;&amp;lt;</source>
          <target state="translated">&amp;lt;&amp;lt; 중 하나만</target>
        </trans-unit>
        <trans-unit id="2fa60291551a07d9e20f8e8f7b56d377829a2b75" translate="yes" xml:space="preserve">
          <source>Only one of the &lt;var&gt;Program-Source-Lines-n&lt;/var&gt; block of statements that lie within the scope of the &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; &amp;hellip; &lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; may be processed by the compiler. Which one (if any) that gets processed will be decided as follows:</source>
          <target state="translated">Only one of the &lt;var&gt;Program-Source-Lines-n&lt;/var&gt; block of statements that lie within the scope of the &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; &amp;hellip; &lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; may be processed by the compiler. Which one (if any) that gets processed will be decided as follows:</target>
        </trans-unit>
        <trans-unit id="6e90f6903d2acd5d4289ceddbb76ae736395dc5d" translate="yes" xml:space="preserve">
          <source>Only one user-defined error procedure may be in effect at any time.</source>
          <target state="translated">언제든지 하나의 사용자 정의 오류 절차 만 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27fae19fb8fcab28fe3712f2fe8be9894d412e8a" translate="yes" xml:space="preserve">
          <source>Only one user-defined exit procedure may be in effect at any time.</source>
          <target state="translated">언제든지 하나의 사용자 정의 종료 절차 만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8276bb34bd3b8954c5e1d44b6e4b6663af21c5d2" translate="yes" xml:space="preserve">
          <source>Only the final clause specified within this paragraph should be terminated with a period.</source>
          <target state="translated">이 단락에 지정된 최종 조항 만 마침표로 종료해야합니다.</target>
        </trans-unit>
        <trans-unit id="a38ff83076ee4107d134eef3c32fe0b34a146d76" translate="yes" xml:space="preserve">
          <source>Only the lowest-level directory (last) in the specified path can be created &amp;mdash; all others must already exist. This subroutine will</source>
          <target state="translated">Only the lowest-level directory (last) in the specified path can be created &amp;mdash; all others must already exist. This subroutine will</target>
        </trans-unit>
        <trans-unit id="19093a1f09bb5bb1f9ea7e1e012a0f82b409bbd3" translate="yes" xml:space="preserve">
          <source>Only the lowest-level directory (last) in the specified path can be created &amp;mdash; all others must already exist. This subroutine will NOT behave as a&lt;code&gt;mkdir -p&lt;/code&gt;(Unix) or&lt;code&gt;mkdir /p&lt;/code&gt;(Windows).</source>
          <target state="translated">지정된 경로에서 최하위 디렉토리 (마지막) 만 만들 수 있습니다. 다른 모든 디렉토리는 이미 존재해야합니다. 이 서브 루틴은 &lt;code&gt;mkdir -p&lt;/code&gt; (Unix) 또는 &lt;code&gt;mkdir /p&lt;/code&gt; (Windows) 로 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="18a2770fd2028b8848e5939f9beca76f8630c1c6" translate="yes" xml:space="preserve">
          <source>Only the lowest-level directory (last) in the specified path will be deleted, and that directory must be empty to be deleted.</source>
          <target state="translated">지정된 경로에서 최하위 디렉토리 (마지막) 만 삭제되며 해당 디렉토리는 비어 있어야 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="1aec312e1ee36a7183965a81eb1e3cb89dc201e9" translate="yes" xml:space="preserve">
          <source>Only those as-yet uninitialized list members meeting the criteria set forth for the specified &amp;lt;</source>
          <target state="translated">아직 초기화되지 않은리스트 멤버 만 지정된 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="74b9edb1f81581f0e6ce322d29834df2b52c72fb" translate="yes" xml:space="preserve">
          <source>Only those as-yet uninitialized list members meeting the criteria set forth for the specified &lt;var&gt;category-name-2&lt;/var&gt; will qualify for this initialization.</source>
          <target state="translated">Only those as-yet uninitialized list members meeting the criteria set forth for the specified &lt;var&gt;category-name-2&lt;/var&gt; will qualify for this initialization.</target>
        </trans-unit>
        <trans-unit id="166d658006e30be1b3535cc3c406eb98b0534317" translate="yes" xml:space="preserve">
          <source>Opening a file with this sharing option indicates you are willing to allow other programs to &lt;code&gt;OPEN&lt;/code&gt; the file for input while you have it open. If they attempt any other &lt;code&gt;OPEN&lt;/code&gt;, theirs will fail with a file status of 37. Of course, your program may fail if someone else got to the file first and opened it with a sharing option that imposed file-sharing limitations.</source>
          <target state="translated">Opening a file with this sharing option indicates you are willing to allow other programs to &lt;code&gt;OPEN&lt;/code&gt; the file for input while you have it open. If they attempt any other &lt;code&gt;OPEN&lt;/code&gt; , theirs will fail with a file status of 37. Of course, your program may fail if someone else got to the file first and opened it with a sharing option that imposed file-sharing limitations.</target>
        </trans-unit>
        <trans-unit id="e4d4f39f5c6f13114530b1c856be188e28a33feb" translate="yes" xml:space="preserve">
          <source>Opening a file with this sharing option indicates you are willing to allow other programs to&lt;code&gt;OPEN&lt;/code&gt;the file for input while you have it open. If they attempt any other&lt;code&gt;OPEN&lt;/code&gt; theirs will fail with a file status of 37. Of course, your program may fail if someone else got to the file first and opened it with a sharing option that imposed file-sharing limitations.</source>
          <target state="translated">이 공유 옵션으로 파일을 열면 다른 프로그램이 할 수 있도록 기꺼이 나타냅니다 &lt;code&gt;OPEN&lt;/code&gt; 당신이 그것을 열려있는 동안 입력 파일을. 다른 &lt;code&gt;OPEN&lt;/code&gt; 을 시도 하면 파일 상태가 37 인 상태로 실패합니다. 물론 다른 사람이 먼저 파일을 가져 와서 파일 공유 제한을 부과하는 공유 옵션으로 파일을 열면 프로그램이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29cc34f8ed315d18fb371f87372eec6af99da9e0" translate="yes" xml:space="preserve">
          <source>Optionally, the</source>
          <target state="translated">Optionally, the</target>
        </trans-unit>
        <trans-unit id="b290988bf20769fb3be0ec9ad35e8ff883c8e032" translate="yes" xml:space="preserve">
          <source>Optionally, the&lt;code&gt;-o&lt;/code&gt;switch</source>
          <target state="translated">선택적으로 &lt;code&gt;-o&lt;/code&gt; 스위치</target>
        </trans-unit>
        <trans-unit id="447171bcea279a3f9260c4de4e227c2d6dd68c76" translate="yes" xml:space="preserve">
          <source>Or it could simply utilize the condition name XL as follows:</source>
          <target state="translated">또는 다음과 같이 조건 이름 XL을 간단히 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="370e4c255f90d246d5721bdc9fd05e213464a25e" translate="yes" xml:space="preserve">
          <source>Or, on a Native Windows or Windows/MinGW system:</source>
          <target state="translated">또는 기본 Windows 또는 Windows / MinGW 시스템에서 :</target>
        </trans-unit>
        <trans-unit id="64a91b697330d7da4ef4061456bbad4813428829" translate="yes" xml:space="preserve">
          <source>Other documents that should be read is the</source>
          <target state="translated">Other documents that should be read is the</target>
        </trans-unit>
        <trans-unit id="be5deb42fb6fd7ce67cd61c124e6e3a2f67bb605" translate="yes" xml:space="preserve">
          <source>Other errors</source>
          <target state="translated">다른 오류</target>
        </trans-unit>
        <trans-unit id="ba479d2e9dd775cad43c293e560fad3af36bde42" translate="yes" xml:space="preserve">
          <source>Other programming language provide the programmer with a similar capability of creating their own words (names) for parts of a program; COBOL is somewhat unusual when compared to other languages in that user-defined words may</source>
          <target state="translated">다른 프로그래밍 언어는 프로그래머에게 프로그램의 일부에 대해 고유 한 단어 (이름)를 작성하는 유사한 기능을 제공합니다. COBOL은 사용자 정의 단어에서 다른 언어와 비교할 때 다소 특이합니다.</target>
        </trans-unit>
        <trans-unit id="cecc7ec953206f23410eda50f5ad47b03ef500c3" translate="yes" xml:space="preserve">
          <source>Other programming languages have arrays; COBOL has tables. They&amp;rsquo;re basically the same thing. There are two special statements that exist in the COBOL language &amp;mdash; &lt;code&gt;SEARCH&lt;/code&gt; and &lt;code&gt;SEARCH ALL&lt;/code&gt; &amp;mdash; that make finding data in a table easy.</source>
          <target state="translated">Other programming languages have arrays; COBOL has tables. They&amp;rsquo;re basically the same thing. There are two special statements that exist in the COBOL language &amp;mdash; &lt;code&gt;SEARCH&lt;/code&gt; and &lt;code&gt;SEARCH ALL&lt;/code&gt; &amp;mdash; that make finding data in a table easy.</target>
        </trans-unit>
        <trans-unit id="6ee0c13160980824559efa0eadcf83a58beccb23" translate="yes" xml:space="preserve">
          <source>Other programming languages provide the programmer with a similar capability of creating their own words (names) for parts of a program; COBOL is somewhat unusual when compared to other languages in that user-defined words may</source>
          <target state="translated">Other programming languages provide the programmer with a similar capability of creating their own words (names) for parts of a program; COBOL is somewhat unusual when compared to other languages in that user-defined words may</target>
        </trans-unit>
        <trans-unit id="8f68708fb0db08268086a998b55604ec95563cd0" translate="yes" xml:space="preserve">
          <source>Otherwise the returned value is a character string that is as long as is needed to contain the I-O status value and the filename. The first two characters are the I-O status value in national characters. The succeeding characters contain the file-name exactly as specified in the &lt;code&gt;SELECT&lt;/code&gt; clause converted at runtime to the runtime national character set.</source>
          <target state="translated">Otherwise the returned value is a character string that is as long as is needed to contain the I-O status value and the filename. The first two characters are the I-O status value in national characters. The succeeding characters contain the file-name exactly as specified in the &lt;code&gt;SELECT&lt;/code&gt; clause converted at runtime to the runtime national character set.</target>
        </trans-unit>
        <trans-unit id="8bbcce1456c742787b1580fde33b8148c8987df5" translate="yes" xml:space="preserve">
          <source>Out of key range</source>
          <target state="translated">키 범위를 벗어남</target>
        </trans-unit>
        <trans-unit id="a553d2153badfb1db45ee73715be9107f08adc68" translate="yes" xml:space="preserve">
          <source>Output from the command (if any) will appear in the command window in which the GnuCOBOL program was executed.</source>
          <target state="translated">GnuCOBOL 프로그램이 실행 된 명령 창에 명령의 출력 (있는 경우)이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="43dc44dc387ec0ff8f1bb71fc10e88f483dab533" translate="yes" xml:space="preserve">
          <source>Over the years, there has been much debate over the efficiency and arithmetic accuracy of using the &lt;code&gt;COMPUTE&lt;/code&gt; statement (see &lt;a href=&quot;#COMPUTE&quot;&gt;COMPUTE&lt;/a&gt;) rather than the four basic arithmetic operation statements.</source>
          <target state="translated">Over the years, there has been much debate over the efficiency and arithmetic accuracy of using the &lt;code&gt;COMPUTE&lt;/code&gt; statement (see &lt;a href=&quot;#COMPUTE&quot;&gt;COMPUTE&lt;/a&gt;) rather than the four basic arithmetic operation statements.</target>
        </trans-unit>
        <trans-unit id="bf18ec4bed8c30a9b19eac1b32547e33a663188d" translate="yes" xml:space="preserve">
          <source>Over the years, there has been much debate over the efficiency and arithmetic accuracy of using the&lt;code&gt;COMPUTE&lt;/code&gt;statement (see &lt;a href=&quot;#COMPUTE&quot;&gt;COMPUTE&lt;/a&gt;) rather than the four basic arithmetic operation statements.</source>
          <target state="translated">수년에 걸쳐 4 가지 기본 산술 연산 문 대신 &lt;code&gt;COMPUTE&lt;/code&gt; 문 ( &lt;a href=&quot;#COMPUTE&quot;&gt;COMPUTE&lt;/a&gt; 참조 ) 을 사용하는 효율성과 산술 정확도에 대해 많은 논쟁이있었습니다 .</target>
        </trans-unit>
        <trans-unit id="0e6ac5f3f6d5399374fefa09919d1c279a782632" translate="yes" xml:space="preserve">
          <source>Overflow condition</source>
          <target state="translated">오버 플로우 조건</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="9caea4b058bdda37551cfd4b0757e6365f49b9e6" translate="yes" xml:space="preserve">
          <source>PACKED-DECIMAL, PADDING, PAGE, PAGE-COUNTER, PARAGRAPH, PERFORM, PF, PH, PI, PIC, PICTURE, PLUS, POINTER, POSITION, POSITIVE, PREFIXED, PRESENT, PRESENT-VALUE, PREVIOUS, PRINT, PRINTER, PRINTER-1, PRINTING, PROCEDURE, PROCEDURE-POINTER, PROCEDURES, PROCEED, PROGRAM, PROGRAM-ID, PROGRAM-POINTER, PROHIBITED, PROMPT, PROPERTY, PROTECTED, PROTOTYPE, PURGE</source>
          <target state="translated">팩형, 패딩, 페이지, 페이지 카운터, 패러 그래프, 퍼포먼스, PF, PH, PI, PIC, PICTURE, PLUS, POINTER, POSITION, POSITIVE, PREFIXED, PRESENT, 현재 가치, 이전, 인쇄, 프린터, 프린터- 1, 인쇄, 절차, 절차 -POINTER, 절차, PROCERAMRES, PROGRAM, PROGRAM-ID, 프로그램 -POINTER, 금지, 프롬프트, 속성, 보호, 프로토 타입, 퍼지</target>
        </trans-unit>
        <trans-unit id="73318b246c3196cef01ce769fd4d71ba5d8a5e0c" translate="yes" xml:space="preserve">
          <source>PACKED-DECIMAL, PADDING, PAGE-COUNTER, PAGED, PAGE-SETUP, PAGE, PARAGRAPH, PARENT, PASSWORD, PERFORM, PERMANENT, PF, PH, PHYSICAL, PICTURE, PIC, PIXELS, PIXEL, PI, PLACEMENT, PLUS, POINTER, POP-UP, POSITION-SHIFT, POSITION, POSITIVE, PREFIXED, PRESENT-VALUE, PRESENT, PREVIOUS, PRINT, PRINTER-1, PRINTER, PRINTING, PRINT-NO-PROMPT, PRINT-PREVIEW, PRINT, PRIORITY, PROCEDURE-POINTER, PROCEDURES, PROCEDURE, PROCEED, PROGRAM-ID, PROGRAM-POINTER, PROGRAM, PROGRESS, PROHIBITED, PROMPT, PROPERTIES, PROPERTY, PROTECTED, PROTOTYPE, PURGE, PUSH-BUTTON</source>
          <target state="translated">PACKED-DECIMAL, PADDING, PAGE-COUNTER, PAGED, PAGE-SETUP, PAGE, PARAGRAPH, PARENT, PASSWORD, PERFORM, PERMANENT, PF, PH, PHYSICAL, PICTURE, PIC, PIXELS, PIXEL, PI, PLACEMENT, PLUS, POINTER, POP-UP, POSITION-SHIFT, POSITION, POSITIVE, PREFIXED, PRESENT-VALUE, PRESENT, PREVIOUS, PRINT, PRINTER-1, PRINTER, PRINTING, PRINT-NO-PROMPT, PRINT-PREVIEW, PRINT, PRIORITY, PROCEDURE-POINTER, PROCEDURES, PROCEDURE, PROCEED, PROGRAM-ID, PROGRAM-POINTER, PROGRAM, PROGRESS, PROHIBITED, PROMPT, PROPERTIES, PROPERTY, PROTECTED, PROTOTYPE, PURGE, PUSH-BUTTON</target>
        </trans-unit>
        <trans-unit id="d48971351ade6fc5f890bc67a75e3fa21b22ca7e" translate="yes" xml:space="preserve">
          <source>PAGE FOOTING [1]</source>
          <target state="translated">페이지 풋팅 [1]</target>
        </trans-unit>
        <trans-unit id="74d126652169159b5d6e6ea5e735209263036ae6" translate="yes" xml:space="preserve">
          <source>PAGE HEADING [1]</source>
          <target state="translated">페이지 머리글 [1]</target>
        </trans-unit>
        <trans-unit id="fa7ff6fb00a7ace8d98cf880a492dc6c5ffc8ca7" translate="yes" xml:space="preserve">
          <source>PI</source>
          <target state="translated">PI</target>
        </trans-unit>
        <trans-unit id="a7aa2c13f70d4d267a113972d52fc8706a2f0e22" translate="yes" xml:space="preserve">
          <source>PI Function Syntax</source>
          <target state="translated">PI 함수 구문</target>
        </trans-unit>
        <trans-unit id="6b16b3819a2ed2799c010b6832ba9348628bf93b" translate="yes" xml:space="preserve">
          <source>PIC 9(4) &amp;mdash; This is the default data item allocated for use by the &lt;code&gt;ACCEPT &lt;var&gt;screen-data-item&lt;/var&gt;&lt;/code&gt; statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;), if no &lt;code&gt;CRT STATUS&lt;/code&gt; (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) clause was specified..</source>
          <target state="translated">PIC 9(4) &amp;mdash; This is the default data item allocated for use by the &lt;code&gt;ACCEPT &lt;var&gt;screen-data-item&lt;/var&gt;&lt;/code&gt; statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;), if no &lt;code&gt;CRT STATUS&lt;/code&gt; (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) clause was specified..</target>
        </trans-unit>
        <trans-unit id="b3194ebbb74c1fdb2502a50c00eae2deeb0fe962" translate="yes" xml:space="preserve">
          <source>PIC 9(4) &amp;mdash; This is the default data item allocated for use by the&lt;code&gt;ACCEPT &amp;lt;&lt;i&gt;screen-data-item&lt;/i&gt;&amp;gt;&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;), if no&lt;code&gt;CRT STATUS&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) clause was specified..</source>
          <target state="translated">PIC 9 (4) &amp;mdash; &lt;code&gt;CRT STATUS&lt;/code&gt; ( &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 참조 ) 절이 지정 되지 않은 경우 &lt;code&gt;ACCEPT &amp;lt;&lt;i&gt;screen-data-item&lt;/i&gt;&amp;gt;&lt;/code&gt; 문 ( &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt; 참조) 에서 사용하도록 할당 된 기본 데이터 항목 입니다. .</target>
        </trans-unit>
        <trans-unit id="c4d58ce0b1bb54c0f561e8907e04ffe9d89e88c5" translate="yes" xml:space="preserve">
          <source>PIC X(16) &amp;mdash; This register contains the date and time the program was compiled in the format &quot;mm/dd/yyhh.mm.ss&quot;. Note that only a two-digit year is provided.</source>
          <target state="translated">PIC X (16) &amp;mdash;이 레지스터에는 프로그램이 &quot;mm / dd / yyhh.mm.ss&quot;형식으로 컴파일 된 날짜와 시간이 포함되어 있습니다. 두 자리 연도 만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6faab1a3c4ec203b389c6383f2fd9a0b1b5967bf" translate="yes" xml:space="preserve">
          <source>PICTURE Clause Syntax</source>
          <target state="translated">영상 절 구문</target>
        </trans-unit>
        <trans-unit id="5c6a530b5ee01a71031bbf926dd0d04d7d729821" translate="yes" xml:space="preserve">
          <source>PRESENT-VALUE Function Syntax</source>
          <target state="translated">PRESENT-VALUE 함수 구문</target>
        </trans-unit>
        <trans-unit id="4de6def8d27ffaffd715bb05a0f1de913d677f1f" translate="yes" xml:space="preserve">
          <source>PRESENT-WHEN Clause Syntax</source>
          <target state="translated">현재 시점 절 구문</target>
        </trans-unit>
        <trans-unit id="3d3a31c9fb0612106236d826f985656c27fa00fe" translate="yes" xml:space="preserve">
          <source>PROCEDURE DIVISION Main-Program-Argument Syntax</source>
          <target state="translated">절차 부문 메인 프로그램 인수 구문</target>
        </trans-unit>
        <trans-unit id="b12c49de171e8ff45e7691afead86a30c33cf2b7" translate="yes" xml:space="preserve">
          <source>PROCEDURE DIVISION RETURNING Syntax</source>
          <target state="translated">절차 구분 반환 구문</target>
        </trans-unit>
        <trans-unit id="4c47e678129694787452f711b5ce9e476e0339d7" translate="yes" xml:space="preserve">
          <source>PROCEDURE DIVISION Subprogram-Argument Syntax</source>
          <target state="translated">절차 부문 서브 프로그램 인수 구문</target>
        </trans-unit>
        <trans-unit id="f4a478a1ada18c25f1d672cd086d9b5594b16518" translate="yes" xml:space="preserve">
          <source>PROCEDURE DIVISION Syntax</source>
          <target state="translated">절차 구분 구문</target>
        </trans-unit>
        <trans-unit id="25ca8d091026e55d615f2ebed52ad90192bd4666" translate="yes" xml:space="preserve">
          <source>PROGRAM-ID Type Clause Syntax</source>
          <target state="translated">PROGRAM-ID 유형 절 구문</target>
        </trans-unit>
        <trans-unit id="a05a7ddbe232076f4b718b4f0b93a1bf867fd986" translate="yes" xml:space="preserve">
          <source>PROMPT Clause Syntax</source>
          <target state="translated">프롬프트 절 구문</target>
        </trans-unit>
        <trans-unit id="af5435be0c54489a569b0a291b3f067fd4481460" translate="yes" xml:space="preserve">
          <source>PROTECTED Attribute Syntax</source>
          <target state="translated">보호 된 속성 구문</target>
        </trans-unit>
        <trans-unit id="b5c3d75a6f451c0f7cb543f448c19539a4c23235" translate="yes" xml:space="preserve">
          <source>Packed-decimal (</source>
          <target state="translated">Packed-decimal (</target>
        </trans-unit>
        <trans-unit id="ee8b3ce3e38db02acd8124f259036255874b20ab" translate="yes" xml:space="preserve">
          <source>Packed-decimal (i.e.&lt;code&gt;USAGE PACKED-DECIMAL&lt;/code&gt;&lt;code&gt;USAGE COMP-3&lt;/code&gt;or&lt;code&gt;USAGE COMP-6&lt;/code&gt; data is stored as a series of bytes such that each byte contains two 4-bit fields, referred to as &amp;rsquo;nibbles&amp;rsquo; (since they comprise half a &quot;byte&quot;, they&amp;rsquo;re just &quot;nibbles&quot; &amp;mdash; don&amp;rsquo;t groan, I don&amp;rsquo;t just make this stuff up!). Each nibble represents a&lt;code&gt;9&lt;/code&gt;in the&lt;code&gt;PICTURE&lt;/code&gt;and each holds a single decimal digit encoded as its binary value (0 = 0000, 1 = 0001, &amp;hellip; , 9 = 1001).</source>
          <target state="translated">팩형 10 진수 (예 : &lt;code&gt;USAGE PACKED-DECIMAL&lt;/code&gt; &lt;code&gt;USAGE COMP-3&lt;/code&gt; 또는 &lt;code&gt;USAGE COMP-6&lt;/code&gt; 데이터는 일련의 바이트로 저장되므로 각 바이트에는 '니블'이라고하는 두 개의 4 비트 필드가 포함됩니다. 바이트 &quot;, 그들은 단지&quot;니블 &quot;입니다 &amp;ndash; 신음하지 않습니다, 나는 단지이 재료들을 구성하지 않습니다!). 각 니블은 &lt;code&gt;PICTURE&lt;/code&gt; 에서 &lt;code&gt;9&lt;/code&gt; 를 나타내고 각각의 이진수 값으로 인코딩 된 하나의 10 진수를 보유합니다 (0 = 0000, 1 = 0001,&amp;hellip;, 9 = 1001).</target>
        </trans-unit>
        <trans-unit id="7df4debd8c25c3d331c6d6f74d9c512ed615340b" translate="yes" xml:space="preserve">
          <source>Page Footing</source>
          <target state="translated">페이지 푸팅</target>
        </trans-unit>
        <trans-unit id="baddf38bfa7e551158f6ec6ea53979d031e77c1c" translate="yes" xml:space="preserve">
          <source>Page Heading</source>
          <target state="translated">페이지 제목</target>
        </trans-unit>
        <trans-unit id="9d70ad3341da999410066a37aeaecbfb647f7ed0" translate="yes" xml:space="preserve">
          <source>Parameters: char &lt;code&gt;PIC X&lt;/code&gt;. Receives the character that was typed, in &lt;small&gt;ASCII&lt;/small&gt;.</source>
          <target state="translated">Parameters: char &lt;code&gt;PIC X&lt;/code&gt; . Receives the character that was typed, in &lt;small&gt;ASCII&lt;/small&gt;.</target>
        </trans-unit>
        <trans-unit id="aca113b5c5ca35ce64ecec07ec135aa642081332" translate="yes" xml:space="preserve">
          <source>Parameters: none</source>
          <target state="translated">Parameters: none</target>
        </trans-unit>
        <trans-unit id="2cc422d197f885cd73bbf6cb19ad07f143f64cc5" translate="yes" xml:space="preserve">
          <source>Parameters: none Returns: PID (the child process gets &amp;acirc;0&amp;acirc; returned, the calling process gets the PID of the created children).</source>
          <target state="translated">매개 변수 : 없음 반환 값 : PID (자식 프로세스는 &quot;0&quot;을 반환하고 호출 프로세스는 만들어진 자식의 PID를 가져옵니다).</target>
        </trans-unit>
        <trans-unit id="d8c0b8614e902d865b389a981de864968906fe3a" translate="yes" xml:space="preserve">
          <source>Parenthesis must be used to explicitly signify the sequence in which conditions are evaluated and processed if the default precedence isn&amp;rsquo;t desired. For example:</source>
          <target state="translated">기본 우선 순위가 바람직하지 않은 경우 조건을 평가하고 처리하는 순서를 명시 적으로 나타내려면 괄호를 사용해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1727880630dd1fbf9ecb1fb3a261512a196787cf" translate="yes" xml:space="preserve">
          <source>Parenthesis provide for a recursive application of the arithmetic expression rules, effectively allowing you to alter the precedence of operations. 4 times 2 is 8 (the use of parenthesis &quot;trumps&quot; the exponentiation operator, so the multiplication happens first); 8 ^ 3 is 512, minus 10 is 502.</source>
          <target state="translated">괄호는 연산 식 규칙을 재귀 적으로 적용하여 연산의 우선 순위를 효과적으로 변경할 수 있습니다. 4 곱하기 2는 8입니다 (괄호를 사용하면 지수 연산자를 &quot;나팔&quot;하므로 곱셈이 먼저 발생합니다). 8 ^ 3은 512이고, 빼기 10은 502입니다.</target>
        </trans-unit>
        <trans-unit id="0be66a6051dddc648eb15d341d62e40bbb1f2b64" translate="yes" xml:space="preserve">
          <source>Parenthesis provide for a recursive application of the arithmetic expression rules, effectively allowing you to alter the precedence of operations. 4 times 2 is 8 (the use of parenthesis &amp;ldquo;trumps&amp;rdquo; the exponentiation operator, so the multiplication happens first); 8 ^ 3 is 512, minus 10 is 502.</source>
          <target state="translated">Parenthesis provide for a recursive application of the arithmetic expression rules, effectively allowing you to alter the precedence of operations. 4 times 2 is 8 (the use of parenthesis &amp;ldquo;trumps&amp;rdquo; the exponentiation operator, so the multiplication happens first); 8 ^ 3 is 512, minus 10 is 502.</target>
        </trans-unit>
        <trans-unit id="43ed3f6df842ef59a8b5928f5ce11ffdc6bea6d4" translate="yes" xml:space="preserve">
          <source>Parse a string, breaking it up into sub strings based upon one or more delimiting character sequences&lt;a href=&quot;#FOOT1&quot; name=&quot;DOCF1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;</source>
          <target state="translated">Parse a string, breaking it up into sub strings based upon one or more delimiting character sequences&lt;a href=&quot;#FOOT1&quot; name=&quot;DOCF1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e8f38b7046bb542d678cb81a4130cdce52f1dff7" translate="yes" xml:space="preserve">
          <source>Partial-line comments</source>
          <target state="translated">부분 설명</target>
        </trans-unit>
        <trans-unit id="88b82cec95a870091303c03d7f7893e2ae462521" translate="yes" xml:space="preserve">
          <source>Pass a quoted literal string from GnuCOBOL to C as a zero-delimited string literal (&lt;code&gt;Z'&lt;var&gt;string&lt;/var&gt;'&lt;/code&gt;).</source>
          <target state="translated">Pass a quoted literal string from GnuCOBOL to C as a zero-delimited string literal ( &lt;code&gt;Z'&lt;var&gt;string&lt;/var&gt;'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c91b4eacd5a0ee6e28cebb6a8883adce2fae1f00" translate="yes" xml:space="preserve">
          <source>Pass a quoted literal string from GnuCOBOL to C as a zero-delimited string literal (Z&amp;rsquo;&amp;lt;</source>
          <target state="translated">GnuCOBOL에서 인용 된 리터럴 문자열을 0으로 구분 된 문자열 리터럴 (Z '&amp;lt;</target>
        </trans-unit>
        <trans-unit id="cd7fdf9b3c5c06f7dbbaa56150d4d37dbafb9737" translate="yes" xml:space="preserve">
          <source>Pass alphanumeric (&lt;code&gt;PIC X&lt;/code&gt;) or alphabetic (&lt;code&gt;PIC A&lt;/code&gt;) data items to C subroutines by appending an &lt;small&gt;ASCII&lt;/small&gt;&lt;code&gt;NUL&lt;/code&gt; character (&lt;code&gt;X'00'&lt;/code&gt;) to them. For example, to pass the 15-character &lt;code&gt;LastName&lt;/code&gt; data item described above to a C subroutine:</source>
          <target state="translated">Pass alphanumeric ( &lt;code&gt;PIC X&lt;/code&gt; ) or alphabetic ( &lt;code&gt;PIC A&lt;/code&gt; ) data items to C subroutines by appending an &lt;small&gt;ASCII&lt;/small&gt; &lt;code&gt;NUL&lt;/code&gt; character ( &lt;code&gt;X'00'&lt;/code&gt; ) to them. For example, to pass the 15-character &lt;code&gt;LastName&lt;/code&gt; data item described above to a C subroutine:</target>
        </trans-unit>
        <trans-unit id="1f223212e3bb2ae17ffe15b3b3a10416a5c4b36f" translate="yes" xml:space="preserve">
          <source>Pass alphanumeric (PIC X) or alphabetic (PIC A) data items to C subroutines by appending an ASCII NULL character (X&amp;rsquo;00&amp;rsquo;) to them. For example, to pass the 15-character LastName data item described above to a C subroutine:</source>
          <target state="translated">ASCII NULL 문자 (X'00 ')를 추가하여 영숫자 (PIC X) 또는 알파벳 (PIC A) 데이터 항목을 C 서브 루틴에 전달하십시오. 예를 들어, 위에서 설명한 15 자리 LastName 데이터 항목을 C 서브 루틴으로 전달하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="71cc8e7cdf775711e91e1777543be56d51f3ccd7" translate="yes" xml:space="preserve">
          <source>Passing a subroutine argument  &lt;code&gt;BY VALUE&lt;/code&gt; passes the</source>
          <target state="translated">Passing a subroutine argument &lt;code&gt;BY VALUE&lt;/code&gt; passes the</target>
        </trans-unit>
        <trans-unit id="681583e47a37f7049858cf1cb42196b9023932d0" translate="yes" xml:space="preserve">
          <source>Passing a subroutine argument&lt;code&gt;BY VALUE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BY VALUE&lt;/code&gt; 로 서브 루틴 인수 전달</target>
        </trans-unit>
        <trans-unit id="dfabccc5c1f363a790178f029432c7d782d4b70a" translate="yes" xml:space="preserve">
          <source>Paths and file names may be specified on an absolute (&lt;code&gt;C:\\Data\\datafile.dat&lt;/code&gt;, &lt;code&gt;/Data/datafile.dat&lt;/code&gt;, &amp;hellip;) or relative to the current directory (&lt;code&gt;Data\\datafile.dat&lt;/code&gt;, &lt;code&gt;Data/datafile.dat&lt;/code&gt;, &amp;hellip;) basis. If no directory name is included (&lt;code&gt;datafile.dat&lt;/code&gt;), the file must be in the current directory.</source>
          <target state="translated">Paths and file names may be specified on an absolute ( &lt;code&gt;C:\\Data\\datafile.dat&lt;/code&gt; , &lt;code&gt;/Data/datafile.dat&lt;/code&gt; , &amp;hellip;) or relative to the current directory ( &lt;code&gt;Data\\datafile.dat&lt;/code&gt; , &lt;code&gt;Data/datafile.dat&lt;/code&gt; , &amp;hellip;) basis. If no directory name is included ( &lt;code&gt;datafile.dat&lt;/code&gt; ), the file must be in the current directory.</target>
        </trans-unit>
        <trans-unit id="ad7c6f196285b117ee69f8c6840027349a6f0c75" translate="yes" xml:space="preserve">
          <source>Paths and file names may be specified on an absolute &lt;code&gt;C:\Data\datafile.dat&lt;/code&gt;&lt;code&gt;/Data/datafile.dat&lt;/code&gt; &amp;hellip;) or relative-to-the-current-directory &lt;code&gt;Data\datafile.dat&lt;/code&gt;&lt;code&gt;Data/datafile.dat&lt;/code&gt; &amp;hellip;) basis.</source>
          <target state="translated">경로 및 파일 이름은 절대 &lt;code&gt;C:\Data\datafile.dat&lt;/code&gt; &lt;code&gt;/Data/datafile.dat&lt;/code&gt; &amp;hellip; ) 또는 현재 디렉토리에 대한 &lt;code&gt;Data\datafile.dat&lt;/code&gt; &lt;code&gt;Data/datafile.dat&lt;/code&gt; &amp;hellip;) 기준 으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de86c41a1c8cd24f4c25886876f4c3423363b963" translate="yes" xml:space="preserve">
          <source>Perform data summarise, as follows:</source>
          <target state="translated">다음과 같이 데이터 요약을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b065be49e80915c4f1ecfba0a26c906331c34747" translate="yes" xml:space="preserve">
          <source>Performing special reporting actions based upon the fact that the data being used to generate the report has been sorted according to one or more key fields:</source>
          <target state="translated">보고서를 생성하는 데 사용되는 데이터가 하나 이상의 키 필드에 따라 정렬되어 있다는 사실을 기반으로 특수보고 작업 수행 :</target>
        </trans-unit>
        <trans-unit id="b3e0f1c8caa9a9f011e54f531c5d051a6f3b8c55" translate="yes" xml:space="preserve">
          <source>Permanent I/O error</source>
          <target state="translated">영구적 인 I / O 오류</target>
        </trans-unit>
        <trans-unit id="d016004473e0e58d7682856755147e33256bb813" translate="yes" xml:space="preserve">
          <source>Permission denied</source>
          <target state="translated">권한이 거부되었습니다</target>
        </trans-unit>
        <trans-unit id="1431c6f1cea824d656da841b10c8f47251e336a0" translate="yes" xml:space="preserve">
          <source>PgDn,was pressed</source>
          <target state="translated">PgDn을 눌렀습니다.</target>
        </trans-unit>
        <trans-unit id="0d92a8344a4dcd6944aa8972c0546d576535b292" translate="yes" xml:space="preserve">
          <source>PgUp was pressed</source>
          <target state="translated">PgUp을 눌렀습니다.</target>
        </trans-unit>
        <trans-unit id="70ad097f49cd2f413ac1aa6541b4dca5e3119e9f" translate="yes" xml:space="preserve">
          <source>Philadelphia</source>
          <target state="translated">Philadelphia</target>
        </trans-unit>
        <trans-unit id="08414b3fc797a48153d27b836c711e9af07d13e1" translate="yes" xml:space="preserve">
          <source>Phrase-Clause</source>
          <target state="translated">Phrase-Clause</target>
        </trans-unit>
        <trans-unit id="98f3f7d386a961bb37f5f1c2d7a434319267544b" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;#Report-Writer-Features&quot;&gt;Report Writer Features&lt;/a&gt;, if you have not read it already. It will familiarize you with the Report Writer terminology that follows.</source>
          <target state="translated">Please see &lt;a href=&quot;#Report-Writer-Features&quot;&gt;Report Writer Features&lt;/a&gt;, if you have not read it already. It will familiarize you with the Report Writer terminology that follows.</target>
        </trans-unit>
        <trans-unit id="9cac84948702f6e6a49575f66c4e4043ce1e90b9" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;#Report-Writer-Features&quot;&gt;Report Writer Features&lt;/a&gt;, if you have not read it already. This will familiarize you with the Report Writer terminology that will follow.</source>
          <target state="translated">아직 읽지 않은 경우 &lt;a href=&quot;#Report-Writer-Features&quot;&gt;보고서 작성기 기능을&lt;/a&gt; 참조하십시오 . 다음에 나오는 보고서 작성기 용어에 익숙해집니다.</target>
        </trans-unit>
        <trans-unit id="2602ffae44e122955827b0cd473f9039072f75d0" translate="yes" xml:space="preserve">
          <source>Please see availability notes on this at 1.3.13. There are a number of terms that describe various aspects of the operation of the Report Writer Control System (RWCS). Understanding the meanings of these terms is vital to developing an understanding of the subject.</source>
          <target state="translated">1.3.13의 가용성 정보를 참조하십시오. RWCS (Report Writer Control System) 작동의 다양한 측면을 설명하는 용어가 많이 있습니다. 이 용어의 의미를 이해하는 것은 주제에 대한 이해를 발전시키는 데 필수적입니다.</target>
        </trans-unit>
        <trans-unit id="bf6b24e032f4e1ad65513a3850fae7476408780b" translate="yes" xml:space="preserve">
          <source>Pointers are greater than 32 bits long</source>
          <target state="translated">Pointers are greater than 32 bits long</target>
        </trans-unit>
        <trans-unit id="c7a7e210419a91cff89bb15bdcfbe9b2c2038ee7" translate="yes" xml:space="preserve">
          <source>Pointers are greater than 32 bits.</source>
          <target state="translated">Pointers are greater than 32 bits.</target>
        </trans-unit>
        <trans-unit id="80d96d4390ded548a6d8f7dd2ff845de9c18a78e" translate="yes" xml:space="preserve">
          <source>Pre-compiled object-code subprograms may be automatically located by the GnuCOBOL compiler and the loader by using the &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; compilation-time environment variable   (see &lt;a href=&quot;#Compilation-Time-Environment-Variables&quot;&gt;Compilation Time Environment Variables&lt;/a&gt;). If they are locatable through that environment variable, they need not be named on the &lt;code&gt;cobc&lt;/code&gt; command.</source>
          <target state="translated">Pre-compiled object-code subprograms may be automatically located by the GnuCOBOL compiler and the loader by using the &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; compilation-time environment variable (see &lt;a href=&quot;#Compilation-Time-Environment-Variables&quot;&gt;Compilation Time Environment Variables&lt;/a&gt;). If they are locatable through that environment variable, they need not be named on the &lt;code&gt;cobc&lt;/code&gt; command.</target>
        </trans-unit>
        <trans-unit id="254c646ba844fb66c2b9d7c96eff3e33b0023b0b" translate="yes" xml:space="preserve">
          <source>Pre-compiled object-code subprograms may be automatically located by the GnuCOBOL compiler and the loader by using the&lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt;compilation-time environment variable  The collection of compilation units supplied on a</source>
          <target state="translated">사전 컴파일 된 객체 코드 서브 프로그램은 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; 컴파일 타임 환경 변수 를 사용하여 GnuCOBOL 컴파일러와 로더가 자동으로 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef50aa1e1a6709b3ff59bdd7a22c8030dbae86df" translate="yes" xml:space="preserve">
          <source>Prefix explanation:</source>
          <target state="translated">Prefix explanation:</target>
        </trans-unit>
        <trans-unit id="e77a63faa85f582ba8a7492d259837cef6f72e0c" translate="yes" xml:space="preserve">
          <source>Prepare a text file containing 100 or so records, each consisting of a numeric scale (&lt;code&gt;123456789012345678901234&lt;/code&gt;&amp;hellip;).</source>
          <target state="translated">Prepare a text file containing 100 or so records, each consisting of a numeric scale ( &lt;code&gt;123456789012345678901234&lt;/code&gt; &amp;hellip;).</target>
        </trans-unit>
        <trans-unit id="2c7b5fccdbb449ec2c551649d5898d352077f7f4" translate="yes" xml:space="preserve">
          <source>Prepare a text file containing 100 or so records, each consisting of a numeric scale &lt;code&gt;123456789012345678901234&lt;/code&gt;).</source>
          <target state="translated">각각 숫자 스케일 ( &lt;code&gt;123456789012345678901234&lt;/code&gt; ) 로 구성된 100 개 정도의 레코드가 포함 된 텍스트 파일을 준비하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e4d59948adf7751277e60ef5b8dcba523662f1d" translate="yes" xml:space="preserve">
          <source>Presented throughout the report, as needed</source>
          <target state="translated">필요에 따라 보고서 전체에 발표</target>
        </trans-unit>
        <trans-unit id="df23f2f29cdba6cde69b3fa2a8d89b0fced491b1" translate="yes" xml:space="preserve">
          <source>Primary Entry-Point</source>
          <target state="translated">기본 진입 점</target>
        </trans-unit>
        <trans-unit id="a8f9ce32d08588f834c56376d9dc94ccfe00e53b" translate="yes" xml:space="preserve">
          <source>Print the file in a manner consistent with your answers to questions 1-4.</source>
          <target state="translated">질문 1-4에 대한 답변과 일치하는 방식으로 파일을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="2e5a507a8fc83697bf613f4d29c4c2f58980754a" translate="yes" xml:space="preserve">
          <source>Printers supporting channel positioning are generally mainframe-type line printers. When writing to printers that do not support channel positioning, a formfeed will be issued to the printer.</source>
          <target state="translated">채널 포지셔닝을 지원하는 프린터는 일반적으로 메인 프레임 형 라인 프린터입니다. 채널 위치 지정을 지원하지 않는 프린터에 쓸 때는 프린터에 용지 공급이 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="9207cd3a020fc03ca0dd40e02158d966e4f5f2b7" translate="yes" xml:space="preserve">
          <source>Prior to the 1985 COBOL standard, using a period character was the only way to signal the end of a statement&amp;rsquo;s scope.</source>
          <target state="translated">Prior to the 1985 COBOL standard, using a period character was the only way to signal the end of a statement&amp;rsquo;s scope.</target>
        </trans-unit>
        <trans-unit id="cc7e3b1f52737a6533432f632305c4e6ee7083da" translate="yes" xml:space="preserve">
          <source>Prior to the COBOL2002 standard, source statements in COBOL programs were structured around 80-column punched cards. This means that each source line in a COBOL program consisted of five different &amp;ldquo;areas&amp;rdquo;, defined by their column number(s).</source>
          <target state="translated">Prior to the COBOL2002 standard, source statements in COBOL programs were structured around 80-column punched cards. This means that each source line in a COBOL program consisted of five different &amp;ldquo;areas&amp;rdquo;, defined by their column number(s).</target>
        </trans-unit>
        <trans-unit id="657d6289c4aca78075281817dcd5c1921c50a61e" translate="yes" xml:space="preserve">
          <source>Procedural PERFORM Syntax</source>
          <target state="translated">절차 적 수행 구문</target>
        </trans-unit>
        <trans-unit id="a4ea781ed99930cb2040f2b3d1f7277fa799d5c7" translate="yes" xml:space="preserve">
          <source>Procedure</source>
          <target state="translated">Procedure</target>
        </trans-unit>
        <trans-unit id="6e1ab28e843a99805bbdb57ed1c711c419e1aa51" translate="yes" xml:space="preserve">
          <source>Procedure name</source>
          <target state="translated">절차 이름</target>
        </trans-unit>
        <trans-unit id="5896c1082bcafe544f5bd83e214a0b689583a766" translate="yes" xml:space="preserve">
          <source>Procedure names are optional in the procedure division and &amp;mdash; when used &amp;mdash; are named entirely according to the needs and whims of the programmer.</source>
          <target state="translated">Procedure names are optional in the procedure division and &amp;mdash; when used &amp;mdash; are named entirely according to the needs and whims of the programmer.</target>
        </trans-unit>
        <trans-unit id="cf750f590b69f555680ec0c206ab17337eb50a20" translate="yes" xml:space="preserve">
          <source>Procedure names may be up to thirty one (31) characters long and may consist of letters, numbers, dashes and underscores. A procedure name may neither begin nor end with a dash (&amp;lsquo;</source>
          <target state="translated">Procedure names may be up to thirty one (31) characters long and may consist of letters, numbers, dashes and underscores. A procedure name may neither begin nor end with a dash (&amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="92f87251fcb83be18c4fa1e9400471f023bee612" translate="yes" xml:space="preserve">
          <source>Procedure names may be up to thirty one (31) characters long and may consist of letters, numbers, dashes and underscores. A procedure name may neither begin nor end with a dash (-) or underscore (_) character. This means that &quot;Main&quot;, &quot;0100-Read-Transaction&quot; and &quot;17&quot; are all perfectly valid procedure names.</source>
          <target state="translated">프로 시저 이름은 최대 31 자까지 가능하며 문자, 숫자, 대시 및 밑줄로 구성 될 수 있습니다. 프로 시저 이름은 대시 (-) 또는 밑줄 (_) 문자로 시작하거나 끝나지 않아야합니다. 이것은 &quot;Main&quot;, &quot;0100-Read-Transaction&quot;및 &quot;17&quot;이 모두 완벽하게 유효한 프로 시저 이름임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d682fc9dab69c1d2daf94fe72d9c9c2027249415" translate="yes" xml:space="preserve">
          <source>Procedures</source>
          <target state="translated">Procedures</target>
        </trans-unit>
        <trans-unit id="ba7d706676c81486ef93d5625a7041a2c3fee61e" translate="yes" xml:space="preserve">
          <source>Processing of any &lt;code&gt;LINE&lt;/code&gt; (see &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;) clauses within the report group in question.</source>
          <target state="translated">Processing of any &lt;code&gt;LINE&lt;/code&gt; (see &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;) clauses within the report group in question.</target>
        </trans-unit>
        <trans-unit id="f726a7d843f5607354d5fb12395564570f1b96b0" translate="yes" xml:space="preserve">
          <source>Processing of any&lt;code&gt;LINE&lt;/code&gt;(see &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt;) clauses within the report group in question.</source>
          <target state="translated">어떤 처리 &lt;code&gt;LINE&lt;/code&gt; (참조 &lt;a href=&quot;#LINE&quot;&gt;LINE&lt;/a&gt; 문제의 보고서 그룹 내에서 절을).</target>
        </trans-unit>
        <trans-unit id="dcf248c6f1a0cfb83cdc45e92e9f8cdbce3f15b2" translate="yes" xml:space="preserve">
          <source>Processing of the &lt;code&gt;NEXT GROUP&lt;/code&gt; (see &lt;a href=&quot;#NEXT-GROUP&quot;&gt;NEXT GROUP&lt;/a&gt;) clause (if any) within the report group in question.</source>
          <target state="translated">Processing of the &lt;code&gt;NEXT GROUP&lt;/code&gt; (see &lt;a href=&quot;#NEXT-GROUP&quot;&gt;NEXT GROUP&lt;/a&gt;) clause (if any) within the report group in question.</target>
        </trans-unit>
        <trans-unit id="7ca535fcf65ddac45b10bbd190bd912efb8febc8" translate="yes" xml:space="preserve">
          <source>Processing of the&lt;code&gt;NEXT GROUP&lt;/code&gt;(see &lt;a href=&quot;#NEXT-GROUP&quot;&gt;NEXT GROUP&lt;/a&gt;) clause (if any) within the report group in question.</source>
          <target state="translated">의 처리 &lt;code&gt;NEXT GROUP&lt;/code&gt; (참조 &lt;a href=&quot;#NEXT-GROUP&quot;&gt;NEXT GROUP&lt;/a&gt; 문제의 보고서 그룹 내에서 절을 (있는 경우)).</target>
        </trans-unit>
        <trans-unit id="9bf95463f80efe59bac0a5ec88028c32e9047c22" translate="yes" xml:space="preserve">
          <source>Producing a footer, known as a control footing after the detail lines that shared the same old value for the control field.</source>
          <target state="translated">제어 필드에 대해 동일한 이전 값을 공유 한 상세 선 다음에 제어 기반으로 알려진 바닥 글을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6a031b41f38921ea04f5486bed7bf8b3dd63fc44" translate="yes" xml:space="preserve">
          <source>Producing a header, known as a control heading before the detail lines that share the same new value for the control field.</source>
          <target state="translated">제어 필드에 대해 동일한 새 값을 공유하는 상세 행 앞에 제어 표제라고하는 헤더를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9d68007b0763cb230f9034ec96f52b39d03ad630" translate="yes" xml:space="preserve">
          <source>Program</source>
          <target state="translated">Program</target>
        </trans-unit>
        <trans-unit id="b4657dd9e3173cfc213f4a1e9f3f07a786bade77" translate="yes" xml:space="preserve">
          <source>Program Name Area</source>
          <target state="translated">Program Name Area</target>
        </trans-unit>
        <trans-unit id="14c6030c8dbaa7f9e4d8f3c9a3c5b96b4c4eab45" translate="yes" xml:space="preserve">
          <source>Program file names should match exactly the specification of &lt;code&gt;PROGRAM-ID&lt;/code&gt; (including case).</source>
          <target state="translated">Program file names should match exactly the specification of &lt;code&gt;PROGRAM-ID&lt;/code&gt; (including case).</target>
        </trans-unit>
        <trans-unit id="54e7e8e624bf02687707da11dd8ce3501a9e30d0" translate="yes" xml:space="preserve">
          <source>Program file names should match exactly the specification of PROGRAM-ID (including case).</source>
          <target state="translated">프로그램 파일 이름은 PROGRAM-ID의 사양 (케이스 포함)과 정확히 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7bab0bdff2214a8c292d4902e5d23d8d128b6f9" translate="yes" xml:space="preserve">
          <source>Program source code may be concatenated as shown here, provided an &lt;code&gt;END PROGRAM&lt;/code&gt; marker naming the &lt;code&gt;PROGRAM-ID&lt;/code&gt; of the just-completed program is used to separate one program from another.</source>
          <target state="translated">Program source code may be concatenated as shown here, provided an &lt;code&gt;END PROGRAM&lt;/code&gt; marker naming the &lt;code&gt;PROGRAM-ID&lt;/code&gt; of the just-completed program is used to separate one program from another.</target>
        </trans-unit>
        <trans-unit id="cc1d5bfc26224f1a15ab4aea7046cdbbdc25cd1b" translate="yes" xml:space="preserve">
          <source>Program source code may be concatenated as shown here, provided an&lt;code&gt;END PROGRAM&lt;/code&gt;marker naming the&lt;code&gt;PROGRAM-ID&lt;/code&gt;of the just-completed program is used to separate one program from another.</source>
          <target state="translated">방금 완료된 프로그램 의 &lt;code&gt;PROGRAM-ID&lt;/code&gt; 를 명명 하는 &lt;code&gt;END PROGRAM&lt;/code&gt; 마커 가 한 프로그램을 다른 프로그램과 분리하는 데 사용되는 경우 프로그램 소스 코드는 여기에 표시된대로 연결될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72ee618acc7bf1d94f59546b9cb03d3c49ab8ed5" translate="yes" xml:space="preserve">
          <source>Program source files should have extensions of</source>
          <target state="translated">Program source files should have extensions of</target>
        </trans-unit>
        <trans-unit id="de21741dc59a32e0e7c8ba7a44dd3af330fe83fa" translate="yes" xml:space="preserve">
          <source>Program source files should have extensions of &quot;.cob&quot; or &quot;.cbl&quot;.</source>
          <target state="translated">프로그램 소스 파일의 확장자는 &quot;.cob&quot;또는 &quot;.cbl&quot;이어야합니다.</target>
        </trans-unit>
        <trans-unit id="275b5a83064b03891d014483794645ab21eadb7b" translate="yes" xml:space="preserve">
          <source>Program-Source-Lines-3</source>
          <target state="translated">Program-Source-Lines-3</target>
        </trans-unit>
        <trans-unit id="2a9e3057057dc7e2c578bf3e6184686cd6169420" translate="yes" xml:space="preserve">
          <source>Program-Source-Lines-n</source>
          <target state="translated">Program-Source-Lines-n</target>
        </trans-unit>
        <trans-unit id="1d4c600a3763078367c5deb7f0b0d27eb6b96fce" translate="yes" xml:space="preserve">
          <source>Programmers may create their own figurative constants via the &lt;code&gt;SYMBOLIC CHARACTERS&lt;/code&gt; (see &lt;a href=&quot;#Symbolic_002dCharacters_002dClause&quot;&gt;Symbolic-Characters-Clause&lt;/a&gt;) clause of the &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) paragraph.</source>
          <target state="translated">Programmers may create their own figurative constants via the &lt;code&gt;SYMBOLIC CHARACTERS&lt;/code&gt; (see &lt;a href=&quot;#Symbolic_002dCharacters_002dClause&quot;&gt;Symbolic-Characters-Clause&lt;/a&gt;) clause of the &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) paragraph.</target>
        </trans-unit>
        <trans-unit id="5488eb52d0b2069f39abbb1920ab8b988889fe47" translate="yes" xml:space="preserve">
          <source>Programmers may create their own figurative constants via the&lt;code&gt;SYMBOLIC CHARACTERS&lt;/code&gt;(see &lt;a href=&quot;#Symbolic_002dCharacters_002dClause&quot;&gt;Symbolic-Characters-Clause&lt;/a&gt;) clause of the&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) paragraph.</source>
          <target state="translated">프로그래머는 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; ( &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 참조 ) 단락 의 &lt;code&gt;SYMBOLIC CHARACTERS&lt;/code&gt; ( &lt;a href=&quot;#Symbolic_002dCharacters_002dClause&quot;&gt;Symbolic-Characters-Clause 참조&lt;/a&gt; ) 절을 통해 고유 한 형상 상수를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1df5ce010ae9a6c18dff20bf206a26ce5f2a2c5" translate="yes" xml:space="preserve">
          <source>Programmers may use a reserved word as</source>
          <target state="translated">프로그래머는 예약어를 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d08c487baefef0c053fe408dfb3951ad1242be3f" translate="yes" xml:space="preserve">
          <source>Programs coded for 1985 (and beyond) standards don&amp;rsquo;t need it, instead using the explicit scope-terminator &lt;code&gt;END-IF&lt;/code&gt; to inform the compiler where &lt;var&gt;imperative-statement-2&lt;/var&gt; (or &lt;var&gt;imperative-statement-1&lt;/var&gt; if there is no &lt;code&gt;ELSE&lt;/code&gt; clause coded) ends. New GnuCOBOL programs should be coded to use the &lt;code&gt;END-IF&lt;/code&gt; scope terminator for &lt;code&gt;IF&lt;/code&gt; statements. See &lt;a href=&quot;#Use-of-VERB_002fEND_002dVERB-Constructs&quot;&gt;Use of VERB/END-VERB Constructs&lt;/a&gt;, for additional information.</source>
          <target state="translated">Programs coded for 1985 (and beyond) standards don&amp;rsquo;t need it, instead using the explicit scope-terminator &lt;code&gt;END-IF&lt;/code&gt; to inform the compiler where &lt;var&gt;imperative-statement-2&lt;/var&gt; (or &lt;var&gt;imperative-statement-1&lt;/var&gt; if there is no &lt;code&gt;ELSE&lt;/code&gt; clause coded) ends. New GnuCOBOL programs should be coded to use the &lt;code&gt;END-IF&lt;/code&gt; scope terminator for &lt;code&gt;IF&lt;/code&gt; statements. See &lt;a href=&quot;#Use-of-VERB_002fEND_002dVERB-Constructs&quot;&gt;Use of VERB/END-VERB Constructs&lt;/a&gt;, for additional information.</target>
        </trans-unit>
        <trans-unit id="3f49b39beacf3661dbc95559f2addb85dc7b9aee" translate="yes" xml:space="preserve">
          <source>Programs coded for 1985 (and beyond) standards don&amp;rsquo;t need it, instead using the explicit scope-terminator&lt;code&gt;END-IF&lt;/code&gt;to inform the compiler where &amp;lt;</source>
          <target state="translated">1985 (및 그 이후) 표준으로 코딩 된 프로그램은 필요하지 않습니다. 대신 명시 적 범위 종결 자 &lt;code&gt;END-IF&lt;/code&gt; 를 사용하여 컴파일러에 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="55d080ddb65112a4fbc1c1e54f907db42a9976aa" translate="yes" xml:space="preserve">
          <source>Prompt Character</source>
          <target state="translated">프롬프트 캐릭터</target>
        </trans-unit>
        <trans-unit id="4a220b87a7be509dbece00789d4b3d878c3a60b1" translate="yes" xml:space="preserve">
          <source>Prompt characters will be automatically transformed into spaces upon input.</source>
          <target state="translated">프롬프트 문자는 입력시 공백으로 자동 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="adf45316af5e41facda6d4ce2eb62cdd65e8a987" translate="yes" xml:space="preserve">
          <source>PrtSc (Print Screen) was pressed</source>
          <target state="translated">PrtSc (인쇄 화면)를 눌렀습니다.</target>
        </trans-unit>
        <trans-unit id="cdf277873b64970f78a3708b4990064e7dfff4db" translate="yes" xml:space="preserve">
          <source>Putting the program &amp;ldquo;to sleep&amp;rdquo;, specifying the sleep time in nanoseconds;</source>
          <target state="translated">Putting the program &amp;ldquo;to sleep&amp;rdquo;, specifying the sleep time in nanoseconds;</target>
        </trans-unit>
        <trans-unit id="56d834e7db309d21f505c6ba2385c35396a93865" translate="yes" xml:space="preserve">
          <source>Putting the program &amp;ldquo;to sleep&amp;rdquo;, specifying the sleep time in seconds</source>
          <target state="translated">Putting the program &amp;ldquo;to sleep&amp;rdquo;, specifying the sleep time in seconds</target>
        </trans-unit>
        <trans-unit id="96f9ef15986bae3ffde2ed5089694e852bf420de" translate="yes" xml:space="preserve">
          <source>Putting the program &amp;rsquo;to sleep&amp;rsquo;, specifying the sleep time in nanoseconds; CAVEAT: although you&amp;rsquo;ll express the time in nanoseconds, Windows systems will only be able to sleep at a millisecond granularity</source>
          <target state="translated">수면 시간을 나노초 단위로 지정하여 프로그램을 '휴면 상태'로 전환합니다. 주의 사항 : 시간은 나노초 단위로 표시되지만 Windows 시스템은 밀리 초 단위로만 절전 모드로 전환 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="08d07e7e49c86dad93291362c0dab33a6083e56e" translate="yes" xml:space="preserve">
          <source>Putting the program &amp;rsquo;to sleep&amp;rsquo;, specifying the sleep time in seconds</source>
          <target state="translated">수면 시간을 초 단위로 지정하여 프로그램을 '잠자기'로 설정</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="1c09e5740de9035fcd0c1fa8a63516480c1e5022" translate="yes" xml:space="preserve">
          <source>QUERY-INDEX, QUEUE, QUOTES, QUOTE</source>
          <target state="translated">QUERY-INDEX, QUEUE, QUOTES, QUOTE</target>
        </trans-unit>
        <trans-unit id="10dfe59bf8fd63e613158ecf86f77c108701c252" translate="yes" xml:space="preserve">
          <source>QUEUE, QUOTE, QUOTES</source>
          <target state="translated">대기열, 견적, 견적</target>
        </trans-unit>
        <trans-unit id="2ffe44e547583bf61e0c2b02d0288df152e1e76d" translate="yes" xml:space="preserve">
          <source>Qualification</source>
          <target state="translated">Qualification</target>
        </trans-unit>
        <trans-unit id="06576556d1ad802f247cad11ae748be47b70cd9c" translate="yes" xml:space="preserve">
          <source>R</source>
          <target state="translated">R</target>
        </trans-unit>
        <trans-unit id="666bfb3506071d041bc953a3b96327c975564f94" translate="yes" xml:space="preserve">
          <source>RADIO-BUTTON, RAISED, RAISE, RAISING, RANDOM, RANGE, RD, READ-ONLY, READ, RECEIVE, RECORD-DATA, RECORDING, RECORDS, RECORD-TO-ADD, RECORD-TO-DELETE, RECORD, RECURSIVE, REDEFINES, REEL, REFERENCE, REFERENCES, REFRESH, REGION-COLOR, RELATION, RELATIVE, RELEASE, REMAINDER, REMARKS, REMOVAL, REM, RENAMES, REPLACE, REPLACING, REPORTING, REPORTS, REPORT, REPOSITORY, REQUIRED, RESERVE, RESET-GRID, RESET-LIST, RESET-TABS, RESET, RESUME, RETRY, RETURN-CODE, RETURNING, RETURN, REVERSED, REVERSE-VIDEO, REVERSE, REWIND, REWRITE, RF, RH, RIGHT-ALIGN, RIGHT-JUSTIFY, RIGHT, RIMMED, ROLLBACK, ROUNDED, ROUNDING, ROW-COLOR-PATTERN, ROW-COLOR, ROW-DIVIDERS, ROW-FONT, ROW-HEADINGS, ROW-PROTECTION, RUN</source>
          <target state="translated">RADIO-BUTTON, RAISED, RAISE, RAISING, RANDOM, RANGE, RD, READ-ONLY, READ, RECEIVE, RECORD-DATA, RECORDING, RECORDS, RECORD-TO-ADD, RECORD-TO-DELETE, RECORD, RECURSIVE, REDEFINES, REEL, REFERENCE, REFERENCES, REFRESH, REGION-COLOR, RELATION, RELATIVE, RELEASE, REMAINDER, REMARKS, REMOVAL, REM, RENAMES, REPLACE, REPLACING, REPORTING, REPORTS, REPORT, REPOSITORY, REQUIRED, RESERVE, RESET-GRID, RESET-LIST, RESET-TABS, RESET, RESUME, RETRY, RETURN-CODE, RETURNING, RETURN, REVERSED, REVERSE-VIDEO, REVERSE, REWIND, REWRITE, RF, RH, RIGHT-ALIGN, RIGHT-JUSTIFY, RIGHT, RIMMED, ROLLBACK, ROUNDED, ROUNDING, ROW-COLOR-PATTERN, ROW-COLOR, ROW-DIVIDERS, ROW-FONT, ROW-HEADINGS, ROW-PROTECTION, RUN</target>
        </trans-unit>
        <trans-unit id="f08a1db7e6b2f2c1d6778ded5854c67530551d51" translate="yes" xml:space="preserve">
          <source>RAISE, RAISING, RANDOM, RANGE, RD, READ, RECEIVE, RECORD, RECORDING, RECORDS, RECURSIVE, REDEFINES, REEL, REFERENCE, REFERENCES, RELATION, RELATIVE, RELEASE, REM, REMAINDER, REMARKS, REMOVAL, RENAMES, REPLACE, REPLACING, REPORT, REPORTING, REPORTS, REPOSITORY, REQUIRED, RESERVE, RESET, RESUME, RETRY, RETURN, RETURN-CODE, RETURNING, REVERSE, REVERSED, REVERSE-VIDEO, REWIND, REWRITE, RF, RH, RIGHT, RIGHT-JUSTIFY, ROLLBACK, ROUNDED, ROUNDING, RUN</source>
          <target state="translated">인상, 양육, RANDOM, 범위, RD, 읽기, 수신, 기록, 녹화, 기록, 수신, 정의, 릴, 참조, 참조, 관계, 상대, 릴리스, 렘, 남아, 비고, 제거, 이름 바꾸기, 교체, 교체 보고,보고,보고, 저장소, 필요, 예약, 재설정, 재개, 재시도, 반환, 리턴 코드, 반환, 리버스, 리버스, 리버스 비디오, 되감기, 다시 쓰기, RF, RH, 오른쪽, 오른쪽 합법, 롤백, 라운드, 라운드, 런</target>
        </trans-unit>
        <trans-unit id="aa2ad98025c5ccedb9a8062b45fc81b9a85a1f9b" translate="yes" xml:space="preserve">
          <source>RANDOM Function Syntax</source>
          <target state="translated">RANDOM 함수 구문</target>
        </trans-unit>
        <trans-unit id="dbba2fb2211acfc6f7e82c9b2672b38909b3350b" translate="yes" xml:space="preserve">
          <source>RANGE Function Syntax</source>
          <target state="translated">범위 함수 구문</target>
        </trans-unit>
        <trans-unit id="6cc93d25cff28225305221453ea4729b237fbf4f" translate="yes" xml:space="preserve">
          <source>READ formats. For that reason, when &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt; has been specified and you want to tell the GnuCOBOL compiler that this minimal statement should be treated as a</source>
          <target state="translated">READ formats. For that reason, when &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt; has been specified and you want to tell the GnuCOBOL compiler that this minimal statement should be treated as a</target>
        </trans-unit>
        <trans-unit id="db466c67d7c924cf8154e41dc48967a59e9f1388" translate="yes" xml:space="preserve">
          <source>READ formats. For that reason, when&lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt;has been specified and you want to tell the GnuCOBOL compiler that this minimal statement should be treated as a</source>
          <target state="translated">읽기 형식. 따라서 &lt;code&gt;ACCESS MODE DYNAMIC&lt;/code&gt; 이 지정되어 있고 GnuCOBOL 컴파일러에이 최소 명령문을</target>
        </trans-unit>
        <trans-unit id="297a219959d7e33eb60f63d58ef1707009c5589b" translate="yes" xml:space="preserve">
          <source>READY TRACE Syntax</source>
          <target state="translated">READY TRACE 구문</target>
        </trans-unit>
        <trans-unit id="f2443315e578a83c109e2573005e5d586a47e1f1" translate="yes" xml:space="preserve">
          <source>REDEFINES Clause Syntax</source>
          <target state="translated">REDEFINES 절 구문</target>
        </trans-unit>
        <trans-unit id="6e0eda3b4da0e9ceb260e9bdb8e5e7288b128d72" translate="yes" xml:space="preserve">
          <source>RELEASE Syntax</source>
          <target state="translated">릴리스 구문</target>
        </trans-unit>
        <trans-unit id="1452eb67d984473ae14ca789abb0dd5e6572d980" translate="yes" xml:space="preserve">
          <source>REM Function Syntax</source>
          <target state="translated">REM 함수 구문</target>
        </trans-unit>
        <trans-unit id="860c8f47d893f4be74f855bc3ab2e7755e06e9f8" translate="yes" xml:space="preserve">
          <source>RENAMES Clause Syntax</source>
          <target state="translated">RENAMES 절 구문</target>
        </trans-unit>
        <trans-unit id="0ee104cf480ad829d0d18846195f1ae3e42608d2" translate="yes" xml:space="preserve">
          <source>REPORT FOOTING</source>
          <target state="translated">보고 후드</target>
        </trans-unit>
        <trans-unit id="45db7be4ee99a037495a1b32a06d59c28c970b98" translate="yes" xml:space="preserve">
          <source>REPORT HEADING</source>
          <target state="translated">보고 머리글</target>
        </trans-unit>
        <trans-unit id="06102dd7b6d8bbeea07ca6248d2d0491f36ca514" translate="yes" xml:space="preserve">
          <source>REPORT SECTION Syntax</source>
          <target state="translated">보고서 섹션 구문</target>
        </trans-unit>
        <trans-unit id="56bae7109eaffc652415c08257a2232ce3d6d355" translate="yes" xml:space="preserve">
          <source>REPORT-SECTION-Data-Item</source>
          <target state="translated">REPORT-SECTION-Data-Item</target>
        </trans-unit>
        <trans-unit id="bbf4d4bf6e7c7b88c13cb244b20c9db60fea7fe8" translate="yes" xml:space="preserve">
          <source>REPORT-SECTION-Data-Item Syntax</source>
          <target state="translated">보고서 섹션 데이터 항목 구문</target>
        </trans-unit>
        <trans-unit id="76b842cd5554e5443ec37175b86f0a7439277eaa" translate="yes" xml:space="preserve">
          <source>REPOSITORY Syntax</source>
          <target state="translated">리포지토리 구문</target>
        </trans-unit>
        <trans-unit id="3e46f46f9ea86a2a9553486ee7aa2c96ae58ba11" translate="yes" xml:space="preserve">
          <source>REQUIRED Attribute Syntax</source>
          <target state="translated">필수 속성 구문</target>
        </trans-unit>
        <trans-unit id="cda8fbff28f8810780b1a56c33efc20d1dde8b3d" translate="yes" xml:space="preserve">
          <source>RESET TRACE Syntax</source>
          <target state="translated">RESET TRACE 구문</target>
        </trans-unit>
        <trans-unit id="4ed24f6619445e8cfbe948cba81942311748cd46" translate="yes" xml:space="preserve">
          <source>RETURN Syntax</source>
          <target state="translated">리턴 구문</target>
        </trans-unit>
        <trans-unit id="d3589e955cfc0488a73e50210ba64c73c4db3d5b" translate="yes" xml:space="preserve">
          <source>REVERSE Function Syntax</source>
          <target state="translated">REVERSE 함수 구문</target>
        </trans-unit>
        <trans-unit id="62008f8b8cc34e29b2ffb97c051904c56144fb42" translate="yes" xml:space="preserve">
          <source>REVERSE-VIDEO Attribute Syntax</source>
          <target state="translated">REVERSE-VIDEO 속성 구문</target>
        </trans-unit>
        <trans-unit id="9c8603e175aadbb76620be9e78e2b5af2c6f0031" translate="yes" xml:space="preserve">
          <source>REWRITE Syntax</source>
          <target state="translated">재 작성 구문</target>
        </trans-unit>
        <trans-unit id="8278d68f89bd316de6fc950777060e28082a6774" translate="yes" xml:space="preserve">
          <source>ROLLBACK Syntax</source>
          <target state="translated">롤백 구문</target>
        </trans-unit>
        <trans-unit id="013737bd37ee61fd6988b27b61f124f3f09c2c5b" translate="yes" xml:space="preserve">
          <source>ROUNDED Syntax</source>
          <target state="translated">둥근 구문</target>
        </trans-unit>
        <trans-unit id="7086af21cea218894d38b86c0f36ebe5431a8978" translate="yes" xml:space="preserve">
          <source>RWCS will still be counting lines to decide when to close off one page and start a new one, but when a new page is started it&amp;rsquo;s page heading will</source>
          <target state="translated">RWCS는 여전히 한 페이지를 닫고 새 페이지를 시작할시기를 결정하기 위해 줄을 세지 만 새 페이지가 시작되면 페이지 제목이</target>
        </trans-unit>
        <trans-unit id="f79da70bedb27f6d17326c84593c5acb2650ffc4" translate="yes" xml:space="preserve">
          <source>RWCS will still be counting lines to decide when to close off one page and start a new one, but when a new page is started its page heading will</source>
          <target state="translated">RWCS will still be counting lines to decide when to close off one page and start a new one, but when a new page is started its page heading will</target>
        </trans-unit>
        <trans-unit id="b743a7c1306a4852bcc4d9446e41b820e314cfb0" translate="yes" xml:space="preserve">
          <source>Random READ Syntax</source>
          <target state="translated">무작위 읽기 구문</target>
        </trans-unit>
        <trans-unit id="2fe6d420b581df57a36800ee0b4e6d48b9222c04" translate="yes" xml:space="preserve">
          <source>Range of Values:</source>
          <target state="translated">가치의 범위 :</target>
        </trans-unit>
        <trans-unit id="5d65b6aaa07a1c4a008e947c5b301e902e455c7f" translate="yes" xml:space="preserve">
          <source>Raw C string using &lt;code&gt;L&quot;&lt;var&gt;characters&lt;/var&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">Raw C string using &lt;code&gt;L&quot;&lt;var&gt;characters&lt;/var&gt;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8fb69456149034e0c74e43230f8241bc8a15df6" translate="yes" xml:space="preserve">
          <source>Read error</source>
          <target state="translated">읽기 오류</target>
        </trans-unit>
        <trans-unit id="c96936a418561c4f0cf4ce37907f034b2ce74117" translate="yes" xml:space="preserve">
          <source>Read not done</source>
          <target state="translated">읽지 않음</target>
        </trans-unit>
        <trans-unit id="dafb118dad5716d1f4c57baa3f0db8b651fa4447" translate="yes" xml:space="preserve">
          <source>Reads all eight of the COBOL switches (&lt;code&gt;SWITCH-1&lt;/code&gt; through &lt;code&gt;SWITCH-8&lt;/code&gt;)</source>
          <target state="translated">Reads all eight of the COBOL switches ( &lt;code&gt;SWITCH-1&lt;/code&gt; through &lt;code&gt;SWITCH-8&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a32211bbc813e496d9a82dc784c0086ff3f040eb" translate="yes" xml:space="preserve">
          <source>Reads all eight of the COBOL switches (SWITCH-1 through SWITCH-8)</source>
          <target state="translated">8 개의 COBOL 스위치 (SWITCH-1 ~ SWITCH-8)를 모두 읽습니다.</target>
        </trans-unit>
        <trans-unit id="004bb4a29efe64beb34a61c3267da0fc0dfeb392" translate="yes" xml:space="preserve">
          <source>Recognizing when control fields on the report &amp;mdash; fields tied to those that were used as &lt;code&gt;SORT&lt;/code&gt; statement (see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) keys &amp;mdash; have changed. This is known as a control break. The RWCS can automatically perform the following reporting actions when a control break occurs:</source>
          <target state="translated">Recognizing when control fields on the report &amp;mdash; fields tied to those that were used as &lt;code&gt;SORT&lt;/code&gt; statement (see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) keys &amp;mdash; have changed. This is known as a control break. The RWCS can automatically perform the following reporting actions when a control break occurs:</target>
        </trans-unit>
        <trans-unit id="09acbc68ca2f9bb219e307419a9388579ddd5613" translate="yes" xml:space="preserve">
          <source>Recognizing when control fields on the report &amp;mdash; fields tied to those that were used as&lt;code&gt;SORT&lt;/code&gt;statement (see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) keys &amp;mdash; have changed. This is known as a control break. The RWCS can automatically perform the following reporting actions when a control break occurs:</source>
          <target state="translated">보고서의 제어 필드 ( &lt;code&gt;SORT&lt;/code&gt; 문 ( &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt; 참조 ) 키로 사용 된 필드와 연결된 필드 )가 변경 되는 시점을 인식 합니다. 이를 제어 중단이라고합니다. 제어 중단이 발생하면 RWCS는 다음보고 조치를 자동으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c54132b8e5a9fa44a9a1a7d30b1be36ab3c4247" translate="yes" xml:space="preserve">
          <source>Record</source>
          <target state="translated">Record</target>
        </trans-unit>
        <trans-unit id="ce416265562e75e05fc8d34feb2de4e9ae68719c" translate="yes" xml:space="preserve">
          <source>Record locked</source>
          <target state="translated">기록 잠금</target>
        </trans-unit>
        <trans-unit id="aafe95bf83724804fd5d5b773a1aceb42c757e0f" translate="yes" xml:space="preserve">
          <source>Record overflow</source>
          <target state="translated">오버플로 기록</target>
        </trans-unit>
        <trans-unit id="cab727edd7e859fb6449e9df6dfd703893e3d3ba" translate="yes" xml:space="preserve">
          <source>Record-locking is supported by advanced file-management software built-in to the GnuCOBOL implementation you are using. This software provides a single point-of-control for access to files &amp;mdash; usually &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; files. One such runtime package capable of doing this is the Berkeley Database (BDB) package &amp;mdash; a package frequently used in GnuCOBOL builds to support indexed files.</source>
          <target state="translated">Record-locking is supported by advanced file-management software built-in to the GnuCOBOL implementation you are using. This software provides a single point-of-control for access to files &amp;mdash; usually &lt;code&gt;ORGANIZATION INDEXED&lt;/code&gt; files. One such runtime package capable of doing this is the Berkeley Database (BDB) package &amp;mdash; a package frequently used in GnuCOBOL builds to support indexed files.</target>
        </trans-unit>
        <trans-unit id="683f2af03fd2b451e73dee88eff2a425d1ecd97a" translate="yes" xml:space="preserve">
          <source>Records in this type of file are all the same physical length, except possibly for the very last record in the file, which may be shorter than the others. If variable-length logical records are defined to the program, the space occupied by each physical record in the file will occupy the space described by the longest record description in the program.</source>
          <target state="translated">이 파일 형식의 레코드는 파일의 마지막 레코드를 제외하고 다른 실제 길이보다 짧은 실제 길이를 제외하고 모두 같습니다. 가변 길이 논리 레코드가 프로그램에 정의 된 경우 파일의 각 실제 레코드가 차지하는 공간은 프로그램에서 가장 긴 레코드 설명으로 설명 된 공간을 차지합니다.</target>
        </trans-unit>
        <trans-unit id="ff8bfa364f950637050d748a4e18c3576f1bf748" translate="yes" xml:space="preserve">
          <source>Records in this type of file are all the same physical length. If variable-length logical records are defined to the program, the space occupied by each physical record in the file will occupy the maximum possible space, and the logical record length field will contain the number of bytes of data in the record that are actually in use.</source>
          <target state="translated">이 유형의 파일에있는 레코드는 모두 동일한 물리적 길이입니다. 가변 길이 논리 레코드가 프로그램에 정의 된 경우 파일의 각 실제 레코드가 차지하는 공간은 가능한 최대 공간을 차지하며 논리 레코드 길이 필드는 실제로 레코드에있는 데이터의 바이트 수를 포함합니다. 사용하다.</target>
        </trans-unit>
        <trans-unit id="0cc533c96861929cfb20ffe2f1ccaa0c199fe22c" translate="yes" xml:space="preserve">
          <source>Records must be read from or written to these files in a purely sequential manner. The only way to read (or write) record number 100 would be to have read (or written) records number 1 through 99 first.</source>
          <target state="translated">순차 순차 방식으로 이러한 파일에서 레코드를 읽거나 기록해야합니다. 레코드 번호 100을 읽거나 쓰는 유일한 방법은 레코드 번호 1-99를 먼저 읽거나 쓰는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dbbeae30df9c604bb1a30ed80ec60f1cebdc2b9f" translate="yes" xml:space="preserve">
          <source>Recursive Subprogram</source>
          <target state="translated">재귀 서브 프로그램</target>
        </trans-unit>
        <trans-unit id="da484c501d81e3eb5897020437a8f807f382208e" translate="yes" xml:space="preserve">
          <source>Red: COB-COLOR-RED</source>
          <target state="translated">레드 : COB-COLOR-RED</target>
        </trans-unit>
        <trans-unit id="111f6b94230823d5f9d9b5c8661cde1fc214b6f9" translate="yes" xml:space="preserve">
          <source>Reference Modifier (Format 1) Syntax</source>
          <target state="translated">참조 수정 자 (형식 1) 구문</target>
        </trans-unit>
        <trans-unit id="01e36307df79002e130ab3dd97ca6835f5f295a6" translate="yes" xml:space="preserve">
          <source>Reference Modifier (Format 2) Syntax</source>
          <target state="translated">참조 수정 자 (형식 2) 구문</target>
        </trans-unit>
        <trans-unit id="358264423a41d0a625c503e421abf6a22e8eac8f" translate="yes" xml:space="preserve">
          <source>Reference modification may be used anywhere an identifier is legal, including serving as the receiving field of statements like &lt;code&gt;MOVE&lt;/code&gt; (see &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt;), &lt;code&gt;STRING&lt;/code&gt; (see &lt;a href=&quot;#STRING&quot;&gt;STRING&lt;/a&gt;) and &lt;code&gt;ACCEPT&lt;/code&gt; (see &lt;a href=&quot;#ACCEPT&quot;&gt;ACCEPT&lt;/a&gt;), to name a few.</source>
          <target state="translated">Reference modification may be used anywhere an identifier is legal, including serving as the receiving field of statements like &lt;code&gt;MOVE&lt;/code&gt; (see &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt;), &lt;code&gt;STRING&lt;/code&gt; (see &lt;a href=&quot;#STRING&quot;&gt;STRING&lt;/a&gt;) and &lt;code&gt;ACCEPT&lt;/code&gt; (see &lt;a href=&quot;#ACCEPT&quot;&gt;ACCEPT&lt;/a&gt;), to name a few.</target>
        </trans-unit>
        <trans-unit id="30329903751ce4ff8417bb80e18251dd7c760418" translate="yes" xml:space="preserve">
          <source>Reference modification may be used anywhere an identifier is legal, including serving as the receiving field of statements like&lt;code&gt;MOVE&lt;/code&gt;(see &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt;),&lt;code&gt;STRING&lt;/code&gt;(see &lt;a href=&quot;#STRING&quot;&gt;STRING&lt;/a&gt;) and&lt;code&gt;ACCEPT&lt;/code&gt;(see &lt;a href=&quot;#ACCEPT&quot;&gt;ACCEPT&lt;/a&gt;), to name a few.</source>
          <target state="translated">참조 수정은 &lt;code&gt;MOVE&lt;/code&gt; ( &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt; 참조 ), &lt;code&gt;STRING&lt;/code&gt; ( &lt;a href=&quot;#STRING&quot;&gt;STRING&lt;/a&gt; 참조 ) 및 &lt;code&gt;ACCEPT&lt;/code&gt; ( &lt;a href=&quot;#ACCEPT&quot;&gt;ACCEPT&lt;/a&gt; 참조 )와 같은 수 신문 필드 역할을하는 등 식별자가 합법적 인 모든 곳에서 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b929dfaa30d9c57fc875dc3ae211dcda30183e2" translate="yes" xml:space="preserve">
          <source>Reference modifier out of bounds</source>
          <target state="translated">범위를 벗어난 참조 수정 자</target>
        </trans-unit>
        <trans-unit id="cde7218d52e9084aa68259dd46a019dfe15e1db2" translate="yes" xml:space="preserve">
          <source>References all character positions of &lt;code&gt;CUSTOMER-LAST-NAME&lt;/code&gt; from the fourth onward.</source>
          <target state="translated">References all character positions of &lt;code&gt;CUSTOMER-LAST-NAME&lt;/code&gt; from the fourth onward.</target>
        </trans-unit>
        <trans-unit id="292bc0cf7eadba7bffbf9a17d47d5c140de33bd9" translate="yes" xml:space="preserve">
          <source>References all character positions of CUSTOMER-LAST-NAME from the fourth onward.</source>
          <target state="translated">네 번째부터 CUSTOMER-LAST-NAME의 모든 문자 위치를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="5b2358ec73c08c61f19384f30ea6b4e2a0fbbd83" translate="yes" xml:space="preserve">
          <source>References characters 7 through 11 (5 characters in total) in the 6th occurrence of Table-Entry.</source>
          <target state="translated">6 번째 Table-Entry에서 문자 7-11 (총 5 자)을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="767a4b3e7cf181198eb8a779db4f399f44e6d264" translate="yes" xml:space="preserve">
          <source>References the current month as a 2-digit number in character form. See &lt;a href=&quot;#CURRENT_002dDATE&quot;&gt;CURRENT-DATE&lt;/a&gt;, for more information.</source>
          <target state="translated">현재 월을 문자 형식의 2 자리 숫자로 나타냅니다. 자세한 정보는 &lt;a href=&quot;#CURRENT_002dDATE&quot;&gt;CURRENT-DATE&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0879d30101a7fc6e6032761f5f3ad2d49b7d7628" translate="yes" xml:space="preserve">
          <source>References the first three characters of &lt;code&gt;CUSTOMER-LAST-NAME&lt;/code&gt;.</source>
          <target state="translated">References the first three characters of &lt;code&gt;CUSTOMER-LAST-NAME&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="038d770e8d89d23f07610fa1be0137c66a6fea57" translate="yes" xml:space="preserve">
          <source>References the first three characters of CUSTOMER-LAST-NAME.</source>
          <target state="translated">CUSTOMER-LAST-NAME의 처음 세 문자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="99250bddd4a310831b5538663928ec44d0c3d3c6" translate="yes" xml:space="preserve">
          <source>References to &lt;code&gt;PAGE-COUNTER&lt;/code&gt; in the procedure division must be qualified with the appropriate report name if there are multiple &lt;code&gt;RD&lt;/code&gt;s defined.</source>
          <target state="translated">References to &lt;code&gt;PAGE-COUNTER&lt;/code&gt; in the procedure division must be qualified with the appropriate report name if there are multiple &lt;code&gt;RD&lt;/code&gt; s defined.</target>
        </trans-unit>
        <trans-unit id="6587b76409337fab0cfb6dfaf62a1e1bb0b7642d" translate="yes" xml:space="preserve">
          <source>References to &lt;code&gt;PAGE-COUNTER&lt;/code&gt; within the report section will be implicitly qualified with the name of the report to which the report group referencing the register belongs.</source>
          <target state="translated">References to &lt;code&gt;PAGE-COUNTER&lt;/code&gt; within the report section will be implicitly qualified with the name of the report to which the report group referencing the register belongs.</target>
        </trans-unit>
        <trans-unit id="53c0c22f11cdf98888eb8e2651eb44a37d101835" translate="yes" xml:space="preserve">
          <source>References to&lt;code&gt;PAGE-COUNTER&lt;/code&gt;in the procedure division must be qualified with the appropriate report name if there are multiple&lt;code&gt;RD&lt;/code&gt; defined.</source>
          <target state="translated">&lt;code&gt;RD&lt;/code&gt; 가 여러 개 정의 되어있는 경우 절차 부서에서 &lt;code&gt;PAGE-COUNTER&lt;/code&gt; 에 대한 참조 는 적절한 보고서 이름으로 규정되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="bdc6721faab5f2802ecdc12b1549bca72e8dd5a2" translate="yes" xml:space="preserve">
          <source>References to&lt;code&gt;PAGE-COUNTER&lt;/code&gt;within the report section will be implicitly qualified with the name of the report to which the report group referencing the register belongs.</source>
          <target state="translated">에 대한 참조 &lt;code&gt;PAGE-COUNTER&lt;/code&gt; 보고서 섹션 내 레지스터를 참조하는 보고서 그룹이 속한 보고서의 이름을 내재적으로 규정됩니다.</target>
        </trans-unit>
        <trans-unit id="05682635f6134950786dd1ccfb1517045fea0f7e" translate="yes" xml:space="preserve">
          <source>Referencing a &lt;code&gt;BASED&lt;/code&gt; data item either before its storage has been allocated or after its storage has been released (via the &lt;code&gt;FREE&lt;/code&gt; statement) will lead to &amp;ldquo;unpredictable results&amp;rdquo;. That&amp;rsquo;s how reference manuals and standards specifications talk about this situation. In the author&amp;rsquo;s experience, the results are all too predictable: the program aborts from an attempt to reference an unallocated area of memory.</source>
          <target state="translated">Referencing a &lt;code&gt;BASED&lt;/code&gt; data item either before its storage has been allocated or after its storage has been released (via the &lt;code&gt;FREE&lt;/code&gt; statement) will lead to &amp;ldquo;unpredictable results&amp;rdquo;. That&amp;rsquo;s how reference manuals and standards specifications talk about this situation. In the author&amp;rsquo;s experience, the results are all too predictable: the program aborts from an attempt to reference an unallocated area of memory.</target>
        </trans-unit>
        <trans-unit id="71b4727d522cc8fd132f13dbc1bd77418c2f5fa2" translate="yes" xml:space="preserve">
          <source>Referencing a&lt;code&gt;BASED&lt;/code&gt;data item either before its storage has been allocated or after its storage has been released (via the&lt;code&gt;FREE&lt;/code&gt;statement) will lead to &quot;unpredictable results&quot;. That&amp;rsquo;s how reference manuals and standards specifications talk about this situation. In the author&amp;rsquo;s experience, the results are all too predictable &amp;mdash; the program aborts from an attempt to reference an unallocated area of memory.</source>
          <target state="translated">스토리지가 할당되기 전에 또는 &lt;code&gt;FREE&lt;/code&gt; 문을 통해 스토리지가 해제 된 후 &lt;code&gt;BASED&lt;/code&gt; 데이터 항목을 참조하면 &quot;예측할 수없는 결과&quot;가 발생합니다. 이것이 참조 매뉴얼과 표준 사양이이 상황에 대해 말하는 방식입니다. 필자의 경험에 따르면 결과는 너무 예측 가능합니다. 프로그램은 할당되지 않은 메모리 영역을 참조하려는 시도에서 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="409fda81216da86f4b719672a1c841c502a8a320" translate="yes" xml:space="preserve">
          <source>Regardless of how many programs comprise a single GnuCOBOL source file, only a single output executable program will be generated from that source file when the file is compiled.</source>
          <target state="translated">단일 GnuCOBOL 소스 파일을 구성하는 프로그램 수에 관계없이 파일을 컴파일 할 때 해당 소스 파일에서 단일 출력 실행 프로그램 만 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="3c3a31a17ba82d290e221d49e19bfdc636896d10" translate="yes" xml:space="preserve">
          <source>Regardless of the manner in which a main program is executed (i.e. directly or via &lt;code&gt;cobcrun&lt;/code&gt;), any arguments specified to the program may be retrieved via any of the following:</source>
          <target state="translated">Regardless of the manner in which a main program is executed (i.e. directly or via &lt;code&gt;cobcrun&lt;/code&gt; ), any arguments specified to the program may be retrieved via any of the following:</target>
        </trans-unit>
        <trans-unit id="ff7478f48888d55ca4c1a34fa362ca62073e45fb" translate="yes" xml:space="preserve">
          <source>Regardless of the manner in which a main program is executed (i.e. directly or via&lt;code&gt;cobcrun&lt;/code&gt;, any arguments specified to the program may be retrieved via any of the following:</source>
          <target state="translated">주 프로그램이 실행되는 방식에 관계없이 (즉, 직접 또는 &lt;code&gt;cobcrun&lt;/code&gt; 을 통해) 프로그램에 지정된 인수는 다음 중 하나를 통해 검색 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="754b50352cbeb073b05a92d3dc3dd894a1fd30c8" translate="yes" xml:space="preserve">
          <source>Regardless of the value moved into the field, this symbol will insert the currency symbol into the data item&amp;rsquo;s value in the position where it occurs in the &amp;lt;</source>
          <target state="translated">필드로 이동 한 값에 관계없이이 기호는 통화 기호를 데이터 항목의 값에 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="e8fb933566bf5e71bc3a22aa4c051fc982235b82" translate="yes" xml:space="preserve">
          <source>Regardless of the value moved into the field, this symbol will insert the currency symbol into the data item&amp;rsquo;s value in the position where it occurs in the &lt;var&gt;picture-string&lt;/var&gt; (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;).</source>
          <target state="translated">Regardless of the value moved into the field, this symbol will insert the currency symbol into the data item&amp;rsquo;s value in the position where it occurs in the &lt;var&gt;picture-string&lt;/var&gt; (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="f8d10a49661c56094a589b50b21f808472559b68" translate="yes" xml:space="preserve">
          <source>Regardless of whether the compiler is operating in Fixed or Free Format Mode, GnuCOBOL allows alphanumeric literals to be broken up into separate fragments. These fragments have their own beginning and ending quote/apostrophe characters and are &quot;glued together&quot; at compilation time using &quot;&amp;amp;&quot;</source>
          <target state="translated">컴파일러가 고정 또는 자유 형식 모드에서 작동하는지 여부에 관계없이 GnuCOBOL을 사용하면 영숫자 리터럴을 개별 조각으로 나눌 수 있습니다. 이 조각들은 고유 한 시작 및 끝 따옴표 / 아포스트로피 문자를 가지며 컴파일 타임에 &quot;&amp;amp;&quot;를 사용하여 &quot;함께 붙입니다&quot;</target>
        </trans-unit>
        <trans-unit id="1446e57d9bea1f44cc2f86d540b982072bdd6344" translate="yes" xml:space="preserve">
          <source>Regardless of whether the compiler is operating in Fixed or Free Format Mode, GnuCOBOL allows alphanumeric literals to be broken up into separate fragments. These fragments have their own beginning and ending quote/apostrophe characters and are &amp;ldquo;glued together&amp;rdquo; at compilation time using &amp;lsquo;</source>
          <target state="translated">Regardless of whether the compiler is operating in Fixed or Free Format Mode, GnuCOBOL allows alphanumeric literals to be broken up into separate fragments. These fragments have their own beginning and ending quote/apostrophe characters and are &amp;ldquo;glued together&amp;rdquo; at compilation time using &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="06b5e0b9af6147c0242db84e0c4a13e171c5553f" translate="yes" xml:space="preserve">
          <source>RelOp Syntax</source>
          <target state="translated">RelOp 구문</target>
        </trans-unit>
        <trans-unit id="22b451c449833edcae74df44c9b1e2774aa11aba" translate="yes" xml:space="preserve">
          <source>Relation-Condition Syntax</source>
          <target state="translated">관계 조건 구문</target>
        </trans-unit>
        <trans-unit id="ae2bbee2af3f24cebcd54dfe968efd8b4dc84da8" translate="yes" xml:space="preserve">
          <source>Relative files are processed using the following statements:</source>
          <target state="translated">상대 파일은 다음 명령문을 사용하여 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="a8074a49fb497726af6af68fe038ef3c63f14d75" translate="yes" xml:space="preserve">
          <source>Remember that the null characters are actually in the GnuCOBOL &quot;Arg1&quot; and &quot;Arg2&quot; data items. They don&amp;rsquo;t appear in the output, but they ARE there.</source>
          <target state="translated">널 문자는 실제로 GnuCOBOL &quot;Arg1&quot;및 &quot;Arg2&quot;데이터 항목에 있음을 기억하십시오. 출력에는 나타나지 않지만 거기에 있습니다.</target>
        </trans-unit>
        <trans-unit id="80d0caf3bcad222d6d3b975298a7c44c77f7baff" translate="yes" xml:space="preserve">
          <source>Remember that the null characters are actually in the GnuCOBOL &lt;code&gt;Arg1&lt;/code&gt; and &lt;code&gt;Arg2&lt;/code&gt; data items. They don&amp;rsquo;t appear in the output, but they</source>
          <target state="translated">Remember that the null characters are actually in the GnuCOBOL &lt;code&gt;Arg1&lt;/code&gt; and &lt;code&gt;Arg2&lt;/code&gt; data items. They don&amp;rsquo;t appear in the output, but they</target>
        </trans-unit>
        <trans-unit id="9b41aeb9a8ef66492ba2168a625b9aeb689e33ca" translate="yes" xml:space="preserve">
          <source>Remember that the points described here are intended to make things easier for you, the programmer. No COBOL compiler cares one way or another whether any of these suggestions are followed.</source>
          <target state="translated">여기에 설명 된 요점은 프로그래머가보다 쉽게 ​​사용할 수 있도록하기위한 것입니다. COBOL 컴파일러는 이러한 제안 중 하나를 따르는 지 여부를 상관하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ecf0a1884749f073e1a9ac912f6365cffd7995e2" translate="yes" xml:space="preserve">
          <source>Removal of leading or trailing spaces from a string</source>
          <target state="translated">Removal of leading or trailing spaces from a string</target>
        </trans-unit>
        <trans-unit id="cf3c352d613abe4e31f868838e58187f552464af" translate="yes" xml:space="preserve">
          <source>Repeated, as needed</source>
          <target state="translated">필요에 따라 반복</target>
        </trans-unit>
        <trans-unit id="0a7b86bde619fdcaeb2f1a1f61e591e3c33e5b57" translate="yes" xml:space="preserve">
          <source>Replace Mode remains in-effect &amp;mdash; continuing to make source code changes &amp;mdash; until another Format 1 &lt;code&gt;REPLACE&lt;/code&gt; is encountered, the end of currently compiling program source file is reached or a Format 2 &lt;code&gt;REPLACE&lt;/code&gt; statement is encountered.</source>
          <target state="translated">Replace Mode remains in-effect &amp;mdash; continuing to make source code changes &amp;mdash; until another Format 1 &lt;code&gt;REPLACE&lt;/code&gt; is encountered, the end of currently compiling program source file is reached or a Format 2 &lt;code&gt;REPLACE&lt;/code&gt; statement is encountered.</target>
        </trans-unit>
        <trans-unit id="086db9ae73624a8fd462fa0d1f01022947edee6c" translate="yes" xml:space="preserve">
          <source>Replace Mode remains in-effect &amp;mdash; continuing to make source code changes &amp;mdash; until another Format 1&lt;code&gt;REPLACE&lt;/code&gt;is encountered, the end of currently compiling program source file is reached or a Format 2&lt;code&gt;REPLACE&lt;/code&gt;statement is encountered.</source>
          <target state="translated">대체 모드는 다른 형식 1 &lt;code&gt;REPLACE&lt;/code&gt; 에 도달하거나 현재 컴파일중인 프로그램 소스 파일의 끝에 도달하거나 형식 2 &lt;code&gt;REPLACE&lt;/code&gt; 문에 도달 할 때까지 소스 코드 변경을 계속 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="87b67c018726c13647c572f1447f0e2a6fa2576e" translate="yes" xml:space="preserve">
          <source>Replace one or more complete reserved words, user-defined identifiers or literals; the following points apply to this option:</source>
          <target state="translated">하나 이상의 완전한 예약어, 사용자 정의 식별자 또는 리터럴을 교체하십시오. 이 옵션에는 다음 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="10c1a853f5318fa583f60512501f1e7bbab158ad" translate="yes" xml:space="preserve">
          <source>Replacement of one or more complete reserved words, user-defined identifiers or literals; the following points apply to this option:</source>
          <target state="translated">하나 이상의 완전한 예약어, 사용자 정의 식별자 또는 리터럴의 교체; 이 옵션에는 다음 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b3584f020632f05d39728f2ebe9927cf604a1725" translate="yes" xml:space="preserve">
          <source>Report Footing</source>
          <target state="translated">바닥 글 신고</target>
        </trans-unit>
        <trans-unit id="5b52f1abe3ac29f70381d19510c3cba0043a6bbd" translate="yes" xml:space="preserve">
          <source>Report Group</source>
          <target state="translated">보고서 그룹</target>
        </trans-unit>
        <trans-unit id="ac7f2e7a7c1eab0ca6e6f5f80c57a1506edbb36d" translate="yes" xml:space="preserve">
          <source>Report Heading</source>
          <target state="translated">보고서 제목</target>
        </trans-unit>
        <trans-unit id="ae0e8276f3c85c4332b49cc15cda40edfc99748e" translate="yes" xml:space="preserve">
          <source>Report group declarations must be followed by at least one &amp;lt;&amp;lt;</source>
          <target state="translated">보고서 그룹 선언 다음에는 하나 이상의 &amp;lt;&amp;lt;가 와야합니다.</target>
        </trans-unit>
        <trans-unit id="2ee39b3bd3491ab1319d9a2ee65ef04d56a83748" translate="yes" xml:space="preserve">
          <source>Report group declarations must be followed by at least one &lt;code&gt;&lt;var&gt;REPORT-SECTION-Data-Item&lt;/var&gt;&lt;/code&gt; with a level number in the range 02-49.</source>
          <target state="translated">Report group declarations must be followed by at least one &lt;code&gt;&lt;var&gt;REPORT-SECTION-Data-Item&lt;/var&gt;&lt;/code&gt; with a level number in the range 02-49.</target>
        </trans-unit>
        <trans-unit id="c3c0ff29655342b1619cb8511d8231760ec3468c" translate="yes" xml:space="preserve">
          <source>Report-Description (RD) Syntax</source>
          <target state="translated">보고서 설명 (RD) 구문</target>
        </trans-unit>
        <trans-unit id="21d8d840181db86a81475c4ecbc7c1aebafea842" translate="yes" xml:space="preserve">
          <source>Report-Group-Definition Syntax</source>
          <target state="translated">보고서 그룹 정의 구문</target>
        </trans-unit>
        <trans-unit id="7fc78c4dd35e76513ea8698d9cdd17d8aadc720d" translate="yes" xml:space="preserve">
          <source>Reserved Word</source>
          <target state="translated">예약어</target>
        </trans-unit>
        <trans-unit id="7f80623ffda4637ef16987aa5f47e5c605a09b42" translate="yes" xml:space="preserve">
          <source>Reserved Words</source>
          <target state="translated">예약어</target>
        </trans-unit>
        <trans-unit id="4f811c8adb8a6b1e9b9b9faaf6f3806186fa7fe0" translate="yes" xml:space="preserve">
          <source>Reserved words of the COBOL language will appear in UPPER-CASE. When they appear underlined, as this one is, they are required reserved words.</source>
          <target state="translated">COBOL 언어의 예약어는 대문자로 표시됩니다. 밑줄이 표시되면 예약어가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="87aabf77f1614bb799bcfe523cf223008537a766" translate="yes" xml:space="preserve">
          <source>Respectively</source>
          <target state="translated">Respectively</target>
        </trans-unit>
        <trans-unit id="5faa59d4bc3756040b8ce9e673c09f929e6ee9ba" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">Result</target>
        </trans-unit>
        <trans-unit id="61a3a6e39b507fd50579c74b81260ece96d65764" translate="yes" xml:space="preserve">
          <source>Result is &amp;rsquo;</source>
          <target state="translated">결과는 '</target>
        </trans-unit>
        <trans-unit id="635841ecd7e49d52016a2baa42fe40227b28508e" translate="yes" xml:space="preserve">
          <source>Result is &amp;rsquo;ABC</source>
          <target state="translated">결과는 'ABC</target>
        </trans-unit>
        <trans-unit id="34e077fbe236df277dc5c01298886daa0417a3d9" translate="yes" xml:space="preserve">
          <source>Result is &amp;rsquo;ABCDEF&amp;rsquo;</source>
          <target state="translated">결과는 'ABCDEF'입니다</target>
        </trans-unit>
        <trans-unit id="8d662f46412276c6c8a8d7c81378948cbde22381" translate="yes" xml:space="preserve">
          <source>Result is &amp;rsquo;DEFGHI&amp;rsquo;</source>
          <target state="translated">결과는 'DEFGHI'입니다</target>
        </trans-unit>
        <trans-unit id="a774bbc895c3d7efe635d1d11a8e005f7ec809a6" translate="yes" xml:space="preserve">
          <source>Retrieves the number of arguments passed to the program executing the &lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt;, saving that number into the &lt;var&gt;variable-arg&lt;/var&gt; argument. That should be a binary numeric data item (&lt;code&gt;USAGE BINARY-CHAR&lt;/code&gt; is recommended).</source>
          <target state="translated">Retrieves the number of arguments passed to the program executing the &lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt; , saving that number into the &lt;var&gt;variable-arg&lt;/var&gt; argument. That should be a binary numeric data item ( &lt;code&gt;USAGE BINARY-CHAR&lt;/code&gt; is recommended).</target>
        </trans-unit>
        <trans-unit id="e3b027c7cc37d7818b9336c7ca74e14d71d4fdfb" translate="yes" xml:space="preserve">
          <source>Retrieves the number of arguments passed to the program executing the CALL X&quot;91&quot;, saving that number into the &amp;lt;</source>
          <target state="translated">CALL X &quot;91&quot;을 실행하는 프로그램에 전달 된 인수 수를 검색하여 해당 수를 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="c590f5f3ec023804208a621501668d27e0e77ec1" translate="yes" xml:space="preserve">
          <source>Retrieving information about the currently-executing program</source>
          <target state="translated">현재 실행중인 프로그램에 대한 정보 검색</target>
        </trans-unit>
        <trans-unit id="5c570687be468812fdc35b94e1681fcc239fc3dc" translate="yes" xml:space="preserve">
          <source>Retrieving the number of arguments passed to a subroutine.</source>
          <target state="translated">서브 루틴에 전달 된 인수 수를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="a3f4c7dc209de44ce48630dcaecde0952de812d1" translate="yes" xml:space="preserve">
          <source>Return to step (C).</source>
          <target state="translated">(C) 단계로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="30bd1c21c7f5eddeea30b3001d4922cad418e533" translate="yes" xml:space="preserve">
          <source>Return to step C.</source>
          <target state="translated">Return to step C.</target>
        </trans-unit>
        <trans-unit id="45d42eebc7bd462db3ca38bad351e98a9c609584" translate="yes" xml:space="preserve">
          <source>Returned value :</source>
          <target state="translated">Returned value :</target>
        </trans-unit>
        <trans-unit id="6eeccf995350c7e94d285c22880aca8342c12b6b" translate="yes" xml:space="preserve">
          <source>Returned value as &lt;var&gt;argument-1&lt;/var&gt; is assigned to a temporary boolean data item of usage bit described with the same number of boolean positions.</source>
          <target state="translated">Returned value as &lt;var&gt;argument-1&lt;/var&gt; is assigned to a temporary boolean data item of usage bit described with the same number of boolean positions.</target>
        </trans-unit>
        <trans-unit id="6d144a31fe86038c563e9bbc5f345bedc3ab922c" translate="yes" xml:space="preserve">
          <source>Returned value is a boolean item of usage bit that has the same bit configuration as the binary representation of the value of &lt;var&gt;argument-1&lt;/var&gt;, where the rightmost boolean position is the low-order binary digit. The boolean value is zero-filled or truncated on the left, if necessary, in order to return a boolean item whose length is specified by &lt;var&gt;argument-2&lt;/var&gt; in therms of boolean positions.</source>
          <target state="translated">Returned value is a boolean item of usage bit that has the same bit configuration as the binary representation of the value of &lt;var&gt;argument-1&lt;/var&gt; , where the rightmost boolean position is the low-order binary digit. The boolean value is zero-filled or truncated on the left, if necessary, in order to return a boolean item whose length is specified by &lt;var&gt;argument-2&lt;/var&gt; in therms of boolean positions.</target>
        </trans-unit>
        <trans-unit id="0aafbc84ad48b25e722faf43d4d775e825b941f6" translate="yes" xml:space="preserve">
          <source>Returned value:</source>
          <target state="translated">Returned value:</target>
        </trans-unit>
        <trans-unit id="7f5b5da823f7ed043d3fb1765c31b042e9e35e69" translate="yes" xml:space="preserve">
          <source>Returned values:</source>
          <target state="translated">Returned values:</target>
        </trans-unit>
        <trans-unit id="1b904b7d61d345cf912ebd8551ae193e4f81ce5d" translate="yes" xml:space="preserve">
          <source>Returns the current date and time as the following 21-character structure:</source>
          <target state="translated">Returns the current date and time as the following 21-character structure:</target>
        </trans-unit>
        <trans-unit id="9ffa99b3d192b809de2c7d7bb177af363c246c9e" translate="yes" xml:space="preserve">
          <source>Returns the integer portion of &lt;var&gt;number&lt;/var&gt; (a numeric literal or data item).</source>
          <target state="translated">Returns the integer portion of &lt;var&gt;number&lt;/var&gt; (a numeric literal or data item).</target>
        </trans-unit>
        <trans-unit id="07d3e376e01f826657a12379dbe397b459617441" translate="yes" xml:space="preserve">
          <source>Returns the length &amp;mdash; in bytes &amp;mdash; of the specified &lt;code&gt;string&lt;/code&gt; (a group item, &lt;code&gt;USAGE DISPLAY&lt;/code&gt; elementary item or alphanumeric literal), minus the total number of trailing spaces, if any.</source>
          <target state="translated">Returns the length &amp;mdash; in bytes &amp;mdash; of the specified &lt;code&gt;string&lt;/code&gt; (a group item, &lt;code&gt;USAGE DISPLAY&lt;/code&gt; elementary item or alphanumeric literal), minus the total number of trailing spaces, if any.</target>
        </trans-unit>
        <trans-unit id="917c83ee070b45e610515185e0fdc0e5fd689b8b" translate="yes" xml:space="preserve">
          <source>Returns the length &amp;mdash; in characters &amp;mdash; of &lt;var&gt;string&lt;/var&gt; (a group item, &lt;code&gt;USAGE DISPLAY&lt;/code&gt; elementary item or alphanumeric literal).</source>
          <target state="translated">Returns the length &amp;mdash; in characters &amp;mdash; of &lt;var&gt;string&lt;/var&gt; (a group item, &lt;code&gt;USAGE DISPLAY&lt;/code&gt; elementary item or alphanumeric literal).</target>
        </trans-unit>
        <trans-unit id="c2462429170c0887f438d676ccffaf475ae55d44" translate="yes" xml:space="preserve">
          <source>Returns: &lt;code&gt;pid&lt;/code&gt; (the child process gets &amp;rsquo;0&amp;rsquo; returned, the calling process gets the &lt;code&gt;pid&lt;/code&gt; of the created child).</source>
          <target state="translated">Returns: &lt;code&gt;pid&lt;/code&gt; (the child process gets &amp;rsquo;0&amp;rsquo; returned, the calling process gets the &lt;code&gt;pid&lt;/code&gt; of the created child).</target>
        </trans-unit>
        <trans-unit id="ffbf13702e0fe12404a30857b9a96e25550e1f88" translate="yes" xml:space="preserve">
          <source>Returns: function-status / child-status</source>
          <target state="translated">Returns: function-status / child-status</target>
        </trans-unit>
        <trans-unit id="7d71ad8c451fa23368b22f5954a4b59a775302a6" translate="yes" xml:space="preserve">
          <source>Reverse Video</source>
          <target state="translated">비디오 반전</target>
        </trans-unit>
        <trans-unit id="7932a24fec98a881494794877d2b4c4562d08867" translate="yes" xml:space="preserve">
          <source>Rewriting a record does not cause the contents of the file to be physically updated until the next block of the file is read, a &lt;code&gt;COMMIT&lt;/code&gt; (see &lt;a href=&quot;#COMMIT&quot;&gt;COMMIT&lt;/a&gt;) or &lt;code&gt;UNLOCK&lt;/code&gt; statement (see &lt;a href=&quot;#UNLOCK&quot;&gt;UNLOCK&lt;/a&gt;) is issued or that file is closed.</source>
          <target state="translated">Rewriting a record does not cause the contents of the file to be physically updated until the next block of the file is read, a &lt;code&gt;COMMIT&lt;/code&gt; (see &lt;a href=&quot;#COMMIT&quot;&gt;COMMIT&lt;/a&gt;) or &lt;code&gt;UNLOCK&lt;/code&gt; statement (see &lt;a href=&quot;#UNLOCK&quot;&gt;UNLOCK&lt;/a&gt;) is issued or that file is closed.</target>
        </trans-unit>
        <trans-unit id="8fcf181cd4a0a23c939d756ac0bf62d450c9e879" translate="yes" xml:space="preserve">
          <source>Rewriting a record does not cause the contents of the file to be physically updated until the next block of the file is read, a&lt;code&gt;COMMIT&lt;/code&gt;(see &lt;a href=&quot;#COMMIT&quot;&gt;COMMIT&lt;/a&gt;) or&lt;code&gt;UNLOCK&lt;/code&gt;statement (see &lt;a href=&quot;#UNLOCK&quot;&gt;UNLOCK&lt;/a&gt;) is issued or that file is closed.</source>
          <target state="translated">레코드를 다시 쓰더라도 파일의 다음 블록을 읽거나 &lt;code&gt;COMMIT&lt;/code&gt; ( &lt;a href=&quot;#COMMIT&quot;&gt;COMMIT&lt;/a&gt; 참조 ) 또는 &lt;code&gt;UNLOCK&lt;/code&gt; 문 ( &lt;a href=&quot;#UNLOCK&quot;&gt;UNLOCK&lt;/a&gt; 참조 )이 발행되거나 해당 파일이 닫힐 때까지 파일의 내용이 실제로 업데이트되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f898038d7cf3b2de5c8551462e42607f9fd8e4bd" translate="yes" xml:space="preserve">
          <source>Right Dbl Click</source>
          <target state="translated">Right Dbl Click</target>
        </trans-unit>
        <trans-unit id="e8e04ebc95805899a3ec808267304f20ad412899" translate="yes" xml:space="preserve">
          <source>Right Pressed</source>
          <target state="translated">Right Pressed</target>
        </trans-unit>
        <trans-unit id="8c90924664dcb63bc826e9606b0c0768f41090df" translate="yes" xml:space="preserve">
          <source>Right Released</source>
          <target state="translated">Right Released</target>
        </trans-unit>
        <trans-unit id="895b1d11588a96b44e2ed96b65592ce6a4f7de4b" translate="yes" xml:space="preserve">
          <source>Rounding is to the nearest value (larger or smaller). If two values are equally near, the value whose rightmost digit is</source>
          <target state="translated">반올림은 가장 가까운 값 (크거나 작음)입니다. 두 값이 동일하게 가까운 경우 가장 오른쪽 자릿수가</target>
        </trans-unit>
        <trans-unit id="cad6706b3cf4bc7ae1c6f29e19ebf628256c5d56" translate="yes" xml:space="preserve">
          <source>Rounding is to the nearest value (larger or smaller). If two values are equally near, the value with the larger absolute value is selected.</source>
          <target state="translated">반올림은 가장 가까운 값 (크거나 작음)입니다. 두 값이 동일하게 가까운 경우 절대 값이 큰 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="7615ee1054e581dcc3a8de4ea377f1d1dc3d34fc" translate="yes" xml:space="preserve">
          <source>Rounding is to the nearest value (larger or smaller). If two values are equally near, the value with the smaller absolute value is selected.</source>
          <target state="translated">반올림은 가장 가까운 값 (크거나 작음)입니다. 두 값이 거의 같으면 절대 값이 더 작은 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="cef9cebf7a4f3fc0f3641120885da85acae7fab9" translate="yes" xml:space="preserve">
          <source>Rounding is to the nearest value of larger magnitude.</source>
          <target state="translated">반올림은 가장 큰 값의 가장 가까운 값입니다.</target>
        </trans-unit>
        <trans-unit id="c473e95e70ef4113c7e4d23d6d9d39d929f8ba56" translate="yes" xml:space="preserve">
          <source>Rounding is to the nearest value whose magnitude is smaller.</source>
          <target state="translated">반올림은 크기가 작은 가장 가까운 값입니다.</target>
        </trans-unit>
        <trans-unit id="749f6595f010ab3ccab08d1309aeff0232369c6b" translate="yes" xml:space="preserve">
          <source>Rounding is toward the nearest value whose algebraic value is larger.</source>
          <target state="translated">반올림은 대수 값이 더 큰 가장 가까운 값을 향합니다.</target>
        </trans-unit>
        <trans-unit id="789a21df2c0ea997aa47256c6917e1c2bd59b330" translate="yes" xml:space="preserve">
          <source>Rounding is toward the nearest value whose algebraic value is smaller.</source>
          <target state="translated">반올림은 대수 값이 작은 가장 가까운 값을 향합니다.</target>
        </trans-unit>
        <trans-unit id="f9308ec227504e571d5cfd515e9af3d94153b539" translate="yes" xml:space="preserve">
          <source>Rounding only applies when the result being saved to a receiving field with a &lt;code&gt;ROUNDED&lt;/code&gt; clause is a non-integer value.</source>
          <target state="translated">Rounding only applies when the result being saved to a receiving field with a &lt;code&gt;ROUNDED&lt;/code&gt; clause is a non-integer value.</target>
        </trans-unit>
        <trans-unit id="90e4915dc94f8f7ed08953e738a14007e25b02c6" translate="yes" xml:space="preserve">
          <source>Rounding only applies when the result being saved to a receiving field with a&lt;code&gt;ROUNDED&lt;/code&gt;clause is a non-integer value.</source>
          <target state="translated">반올림은 &lt;code&gt;ROUNDED&lt;/code&gt; 절 을 사용하여 수신 필드에 결과를 저장하는 경우 정수가 아닌 값 에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="02aa629c8b16cd17a44f3a0efec2feed43937642" translate="yes" xml:space="preserve">
          <source>S</source>
          <target state="translated">S</target>
        </trans-unit>
        <trans-unit id="be9e9a1d0c4922b7c1901ab24cea6e46ad881df0" translate="yes" xml:space="preserve">
          <source>S, SAME, SAVE-AS-NO-PROMPT, SAVE-AS, SCREEN, SCROLL-BAR, SCROLL, SD, SEARCH-OPTIONS, SEARCH-TEXT, SEARCH, SECONDS-FROM-FORMATTED-TIME, SECONDS-PAST-MIDNIGHT, SECONDS, SECTION, SECURE, SECURITY, SEGMENT-LIMIT, SEGMENT, SELECT-ALL, SELECTION-INDEX, SELECTION-TEXT, SELECT, SELF-ACT, SELF, SEND, SENTENCE, SEPARATE, SEPARATION, SEQUENCE, SEQUENTIAL, SET, SHADING, SHADOW, SHARING, SHORT-DATE, SHOW-LINES, SHOW-NONE, SHOW-SEL-ALWAYS, SIGNED-INT, SIGNED-LONG, SIGNED-SHORT, SIGNED, SIGN, SIN, SIZE, SMALL-FONT, SORT-MERGE, SORT-ORDER, SORT-RETURN, SORT, SOURCE-COMPUTER, SOURCES, SOURCE, SPACE-FILL, SPACES, SPACE, SPECIAL-NAMES, SPINNER, SQRT, SQUARE, STANDARD-1, STANDARD-2, STANDARD-BINARY, STANDARD-COMPARE, STANDARD-DECIMAL, STANDARD-DEVIATION, STANDARD, START-X, START, START-Y, STATEMENT, STATIC-LIST, STATIC, STATUS-BAR, STATUS-TEXT, STATUS, STDCALL, STDERR, STDIN, STDOUT, STEP, STOP, STORED-CHAR-LENGTH, STRING, STRONG, STYLE, SUB-QUEUE-1, SUB-QUEUE-2, SUB-QUEUE-3, SUBSTITUTE-CASE, SUBSTITUTE, SUBTRACT, SUBWINDOW, SUM, SUM, SUPER, SUPPRESS, SWITCH-0, SWITCH-10, SWITCH-11, SWITCH-12, SWITCH-13, SWITCH-14, SWITCH-15, SWITCH-16, SWITCH-17, SWITCH-18, SWITCH-19, SWITCH-1, SWITCH-20, SWITCH-21, SWITCH-22, SWITCH-23, SWITCH-24, SWITCH-25, SWITCH-26, SWITCH-27, SWITCH-28, SWITCH-29, SWITCH-2, SWITCH-30, SWITCH-31, SWITCH-32, SWITCH-33, SWITCH-34, SWITCH-35, SWITCH-36, SWITCH-3, SWITCH-4, SWITCH-5, SWITCH-6, SWITCH-7, SWITCH-8, SWITCH-9, SYMBOLIC, SYMBOL, SYNCHRONISED, SYNCHRONIZED, SYNC, SYSERR, SYSIN, SYSIPT, SYSLIST, SYSLST, SYSOUT, SYSTEM, SYSTEM-DEFAULT, SYSTEM-OFFSET</source>
          <target state="translated">S, SAME, SAVE-AS-NO-PROMPT, SAVE-AS, SCREEN, SCROLL-BAR, SCROLL, SD, SEARCH-OPTIONS, SEARCH-TEXT, SEARCH, SECONDS-FROM-FORMATTED-TIME, SECONDS-PAST-MIDNIGHT, SECONDS, SECTION, SECURE, SECURITY, SEGMENT-LIMIT, SEGMENT, SELECT-ALL, SELECTION-INDEX, SELECTION-TEXT, SELECT, SELF-ACT, SELF, SEND, SENTENCE, SEPARATE, SEPARATION, SEQUENCE, SEQUENTIAL, SET, SHADING, SHADOW, SHARING, SHORT-DATE, SHOW-LINES, SHOW-NONE, SHOW-SEL-ALWAYS, SIGNED-INT, SIGNED-LONG, SIGNED-SHORT, SIGNED, SIGN, SIN, SIZE, SMALL-FONT, SORT-MERGE, SORT-ORDER, SORT-RETURN, SORT, SOURCE-COMPUTER, SOURCES, SOURCE, SPACE-FILL, SPACES, SPACE, SPECIAL-NAMES, SPINNER, SQRT, SQUARE, STANDARD-1, STANDARD-2, STANDARD-BINARY, STANDARD-COMPARE, STANDARD-DECIMAL, STANDARD-DEVIATION, STANDARD, START-X, START, START-Y, STATEMENT, STATIC-LIST, STATIC, STATUS-BAR, STATUS-TEXT, STATUS, STDCALL, STDERR, STDIN, STDOUT, STEP, STOP, STORED-CHAR-LENGTH, STRING, STRONG, STYLE, SUB-QUEUE-1, SUB-QUEUE-2, SUB-QUEUE-3, SUBSTITUTE-CASE, SUBSTITUTE, SUBTRACT, SUBWINDOW, SUM, SUM, SUPER, SUPPRESS, SWITCH-0, SWITCH-10, SWITCH-11, SWITCH-12, SWITCH-13, SWITCH-14, SWITCH-15, SWITCH-16, SWITCH-17, SWITCH-18, SWITCH-19, SWITCH-1, SWITCH-20, SWITCH-21, SWITCH-22, SWITCH-23, SWITCH-24, SWITCH-25, SWITCH-26, SWITCH-27, SWITCH-28, SWITCH-29, SWITCH-2, SWITCH-30, SWITCH-31, SWITCH-32, SWITCH-33, SWITCH-34, SWITCH-35, SWITCH-36, SWITCH-3, SWITCH-4, SWITCH-5, SWITCH-6, SWITCH-7, SWITCH-8, SWITCH-9, SYMBOLIC, SYMBOL, SYNCHRONISED, SYNCHRONIZED, SYNC, SYSERR, SYSIN, SYSIPT, SYSLIST, SYSLST, SYSOUT, SYSTEM, SYSTEM-DEFAULT, SYSTEM-OFFSET</target>
        </trans-unit>
        <trans-unit id="e0e9028a32cf8efdb6c7f70c0a91cdae3cb6e291" translate="yes" xml:space="preserve">
          <source>S, SAME, SCREEN, SCROLL, SD, SEARCH, SECONDS, SECONDS-FROM-FORMATTED-TIME, SECONDS-PAST-MIDNIGHT, SECTION, SECURE, SECURITY, SEGMENT, SEGMENT-LIMIT, SELECT, SELF, SEND, SENTENCE, SEPARATE, SEQUENCE, SEQUENTIAL, SET, SHARING, SIGN, SIGNED, SIGNED-INT, SIGNED-LONG, SIGNED-SHORT, SIN, SIZE, SORT, SORT-MERGE, SORT-RETURN, SOURCE, SOURCE-COMPUTER, SOURCES, SPACE, SPACE-FILL, SPACES, SPECIAL-NAMES, SQRT, STANDARD, STANDARD-1, STANDARD-2, STANDARD-BINARY, STANDARD-COMPARE, STANDARD-DECIMAL, STANDARD-DEVIATION, START, STATEMENT, STATIC, STATUS, STDCALL, STDERR, STDIN, STDOUT, STEP, STOP, STORED-CHAR-LENGTH, STRING, STRONG, SUB-QUEUE-1, SUB-QUEUE-2, SUB-QUEUE-3, SUBSTITUTE, SUBSTITUTE-CASE, SUBTRACT, SUM, SUPER, SUPPRESS, SW0, SW1, SW10, SW11, SW12, SW13, SW14, SW15, SW2, SW3, SW4, SW5, SW6, SW7, SW8, SW9, SWITCH 0, SWITCH-0, SWITCH 1, SWITCH-1, SWITCH 10, SWITCH-10, SWITCH 11, SWITCH-11, SWITCH 12, SWITCH-12, SWITCH 13, SWITCH-13, SWITCH 14, SWITCH-14, SWITCH 15, SWITCH-15, SWITCH 16, SWITCH-16, SWITCH 17, SWITCH-17, SWITCH 18, SWITCH-18, SWITCH 19, SWITCH-19, SWITCH 2, SWITCH-2, SWITCH 20, SWITCH-20, SWITCH 21, SWITCH-21, SWITCH 22, SWITCH-22, SWITCH 23, SWITCH-23, SWITCH 24, SWITCH-24, SWITCH 25, SWITCH-25, SWITCH 26, SWITCH-26, SWITCH-27, SWITCH-28, SWITCH-29, SWITCH 3, SWITCH-3, SWITCH-30, SWITCH-31, SWITCH-32, SWITCH-33, SWITCH-34, SWITCH-35, SWITCH-36, SWITCH 4, SWITCH-4, SWITCH 5, SWITCH-5, SWITCH 6, SWITCH-6, SWITCH 7, SWITCH-7, SWITCH 8, SWITCH-8, SWITCH 9, SWITCH-9, SWITCH A, SWITCH B, SWITCH C, SWITCH D, SWITCH E, SWITCH F, SWITCH G, SWITCH H, SWITCH I, SWITCH J, SWITCH K, SWITCH L, SWITCH M, SWITCH N, SWITCH O, SWITCH P, SWITCH Q, SWITCH R, SWITCH S, SWITCH T, SWITCH U, SWITCH V, SWITCH W, SWITCH X, SWITCH Y, SWITCH Z, SYMBOL, SYMBOLIC, SYNC, SYNCHRONISED, SYNCHRONIZED, SYSERR, SYSIN, SYSIPT, SYSLIST, SYSLST, SYSOUT, SYSTEM, SYSTEM-DEFAULT, SYSTEM-OFFSET</source>
          <target state="translated">S, SAME, SCREEN, SCROLL, SD, SEARCH, SECONDS, SECONDS-FROM-FORMATTED-TIME, SECONDS-FAST-MIDNIGHT, SECTION, SECURE, SECURITY, SEGMENT, SEGMENT-LIMIT, SELECT, SELF, SEND, SENTENCE, SEPARATE, 시퀀스, 시퀀스, 세트, ​​공유, 부호, 부호, 부호있는 부호, 부호있는 긴 부호, 부호있는 단락, 죄, 크기, 배열, 소트-머지, 소트 리턴, 소스, 소스 컴퓨터, 소스, 스페이스, 스페이스- 채우기, 공백, 특수 이름, SQRT, 표준, 표준 -1, 표준 -2, 표준 이진, 표준 비교, 표준-데시, 표준 편차, 시작, 진술, 정적, 상태, STDCALL, STDERR, STDIN, STDOUT, STEP, STOP, STORED-CHAR-LENGTH, STRING, STRONG, SUB-QUEUE-1, SUB-QUEUE-2, SUB-QUEUE-3, SUBSTITUTE, SUBSTITUTE-CASE, SUBTRACT, SUM, SUPER, SUPPRESS, SW0, SW1, SW10, SW11, SW12, SW13, SW14, SW15, SW2, SW3, SW4, SW5, SW6, SW7, SW8, SW9, SWITCH 0, SWITCH-0, SWITCH 1, SWITCH-1, SWITCH 10,스위치 -10, 스위치 11, 스위치 -11, 스위치 12, 스위치 -12, 스위치 13, 스위치 -13, 스위치 14, 스위치 -14, 스위치 15, 스위치 -15, 스위치 16, 스위치 -16, 스위치 17, 스위치 -17, 스위치 18, 스위치 18, 스위치 19, 스위치 19, 스위치 2, 스위치 -2, 스위치 20, 스위치 -20, 스위치 21, 스위치 21, 스위치 22, 스위치 22, 스위치 23, 스위치 23 23, 스위치 24, 스위치 24, 스위치 25, 스위치 25, 스위치 26, 스위치 26, 스위치 27, 스위치 28, 스위치 29, 스위치 3, 스위치 3, 스위치 30, 스위치 31, 스위치 -32, 스위치 -33, 스위치 -34, 스위치 -35, 스위치 -36, 스위치 4, 스위치 -4, 스위치 5, 스위치 -5, 스위치 6, 스위치 -6, 스위치 7, 스위치 -7, 스위치 8 , 스위치 -8, 스위치 9, 스위치 -9, 스위치 A, 스위치 B, 스위치 C, 스위치 D, 스위치 E, 스위치 F, 스위치 G, 스위치 H, 스위치 I, 스위치 J, 스위치 K, 스위치 L, 스위치 M , 스위치 N, 스위치 O, 스위치 P, 스위치 Q, 스위치 R, 스위치 S, 스위치 T, 스위치 U, 스위치 V,스위치 W, 스위치 X, 스위치 Y, 스위치 Z, 심볼, 기호, 동기화, 동기화, 동기화, 동기화, SYSERR, SYSIN, SYSIPT, SYSLIST, SYSLST, SYSOUT, 시스템, 시스템-디폴트, 시스템 오프셋</target>
        </trans-unit>
        <trans-unit id="363f373bfcd4d4ccbf275f3c0f160a1af75ccf07" translate="yes" xml:space="preserve">
          <source>SCREEN-SECTION-Data-Item Syntax</source>
          <target state="translated">화면 섹션 데이터 항목 구문</target>
        </trans-unit>
        <trans-unit id="a09a03255901a0557a4c216efea055996652af0e" translate="yes" xml:space="preserve">
          <source>SEARCH ALL Syntax</source>
          <target state="translated">모든 구문 검색</target>
        </trans-unit>
        <trans-unit id="fe39b36b8b7acffcfcbc17625fbf54678d5ee131" translate="yes" xml:space="preserve">
          <source>SEARCH Syntax</source>
          <target state="translated">검색 구문</target>
        </trans-unit>
        <trans-unit id="c4a8f26d4a02b40195ab4a41bc77f226df838e64" translate="yes" xml:space="preserve">
          <source>SECONDS-FROM-FORMATTED-TIME Function Syntax</source>
          <target state="translated">SECONDS-FROM-FORMATTED-TIME 함수 구문</target>
        </trans-unit>
        <trans-unit id="c9aab22ee485d02b4bbb39677a796867aeb41d0e" translate="yes" xml:space="preserve">
          <source>SECONDS-PAST-MIDNIGHT Function Syntax</source>
          <target state="translated">SECONDS-PAST-MIDNIGHT 함수 구문</target>
        </trans-unit>
        <trans-unit id="c7c90a5cbf1a7f1839010593040298c9ab3b34b8" translate="yes" xml:space="preserve">
          <source>SECURE Attribute Syntax</source>
          <target state="translated">보안 속성 구문</target>
        </trans-unit>
        <trans-unit id="e326685f4538da2210aeadc79af06dbf194c59d9" translate="yes" xml:space="preserve">
          <source>SELECT Statement Syntax</source>
          <target state="translated">SELECT 문 구문</target>
        </trans-unit>
        <trans-unit id="7d32fc8e8ff19d8791ede4bf59ac75915e6b38cd" translate="yes" xml:space="preserve">
          <source>SET ADDRESS Syntax</source>
          <target state="translated">주소 설정 구문</target>
        </trans-unit>
        <trans-unit id="93d4d9a313dba20aac9d8d7ddd4d383a4a9d3598" translate="yes" xml:space="preserve">
          <source>SET ATTRIBUTE Syntax</source>
          <target state="translated">SET ATTRIBUTE 구문</target>
        </trans-unit>
        <trans-unit id="5a2d0741307e9153e4830db935a4421d66c8e424" translate="yes" xml:space="preserve">
          <source>SET Condition Name Syntax</source>
          <target state="translated">SET 조건 이름 구문</target>
        </trans-unit>
        <trans-unit id="07e13fb57e6cdb5df1f70992f5cb3ebc302f9040" translate="yes" xml:space="preserve">
          <source>SET ENVIRONMENT Syntax</source>
          <target state="translated">환경 설정 구문</target>
        </trans-unit>
        <trans-unit id="14fd5faabb7ac0b2fde2d5cc29abd3105f8d0c3b" translate="yes" xml:space="preserve">
          <source>SET Index Syntax</source>
          <target state="translated">SET 인덱스 구문</target>
        </trans-unit>
        <trans-unit id="cc56c1e0ac9b84b165916822141c813590e6c08f" translate="yes" xml:space="preserve">
          <source>SET Program-Pointer Syntax</source>
          <target state="translated">SET 프로그램 포인터 구문</target>
        </trans-unit>
        <trans-unit id="43a664d01bd559812f3d03a6aabd6f96c15cdf91" translate="yes" xml:space="preserve">
          <source>SET Switch Syntax</source>
          <target state="translated">SET 스위치 구문</target>
        </trans-unit>
        <trans-unit id="5d73a61b9e17a56f006be99946149090b878499f" translate="yes" xml:space="preserve">
          <source>SET UP/DOWN Syntax</source>
          <target state="translated">SET UP / DOWN 구문</target>
        </trans-unit>
        <trans-unit id="5bd9270b5f3cde6595a4438ab2187803ce42d925" translate="yes" xml:space="preserve">
          <source>SIGN Function Syntax</source>
          <target state="translated">부호 함수 구문</target>
        </trans-unit>
        <trans-unit id="8a83dac46af2e8cb72a955b050e5cc8eaefd4e2a" translate="yes" xml:space="preserve">
          <source>SIGN-IS Clause Syntax</source>
          <target state="translated">SIGN-IS 조항 구문</target>
        </trans-unit>
        <trans-unit id="5015ee6d44e7a4080b421d17c2335eceeae1e10f" translate="yes" xml:space="preserve">
          <source>SIN Function Syntax</source>
          <target state="translated">SIN 함수 구문</target>
        </trans-unit>
        <trans-unit id="0af17e6b0426030851200e5ff8767dfd96a2cb12" translate="yes" xml:space="preserve">
          <source>SOURCE Clause Syntax</source>
          <target state="translated">소스 절 구문</target>
        </trans-unit>
        <trans-unit id="12d74693606d01495ff55af3e47c91d7ec6bef52" translate="yes" xml:space="preserve">
          <source>SOURCE-COMPUTER Syntax</source>
          <target state="translated">소스 컴퓨터 구문</target>
        </trans-unit>
        <trans-unit id="b57836c206edabe132d738320da3ab285c5dfe13" translate="yes" xml:space="preserve">
          <source>SPECIAL-NAMES ALPHABET Literal-Clause Syntax</source>
          <target state="translated">SPECIAL-NAMES ALPHABET 리터럴 원인 구문</target>
        </trans-unit>
        <trans-unit id="fa23f2f84269c3dd438fcab08787b633b64d7642" translate="yes" xml:space="preserve">
          <source>SPECIAL-NAMES Alphabet-Clause Syntax</source>
          <target state="translated">SPECIAL-NAMES 알파벳 원인 구문</target>
        </trans-unit>
        <trans-unit id="602bd9218579d2b3939ad13100ea8a12a4534df3" translate="yes" xml:space="preserve">
          <source>SPECIAL-NAMES Class-Definition-Clause Syntax</source>
          <target state="translated">SPECIAL-NAMES 클래스 정의 원인 구문</target>
        </trans-unit>
        <trans-unit id="e97458739dc8559d7da877dee902df118a77f419" translate="yes" xml:space="preserve">
          <source>SPECIAL-NAMES Switch-Definition-Clause Syntax</source>
          <target state="translated">SPECIAL-NAMES 스위치 정의 원인 구문</target>
        </trans-unit>
        <trans-unit id="bc81091dcec56a8dd5e4bff7530560b6a90ab3fe" translate="yes" xml:space="preserve">
          <source>SPECIAL-NAMES Syntax</source>
          <target state="translated">SPECIAL-NAMES 구문</target>
        </trans-unit>
        <trans-unit id="8cd12df6e50de8878ab5fac21624129b15878369" translate="yes" xml:space="preserve">
          <source>SPECIAL-NAMES-Symbolic-Characters-Clause Syntax</source>
          <target state="translated">특수 이름-기호-문자-구문 구문</target>
        </trans-unit>
        <trans-unit id="209b015447e2b6acc94d8ac0319e13f9c5a4130f" translate="yes" xml:space="preserve">
          <source>SQRT Function Syntax</source>
          <target state="translated">SQRT 함수 구문</target>
        </trans-unit>
        <trans-unit id="c46cbdf7f8b8b3499bc817d81bd658aa302e075b" translate="yes" xml:space="preserve">
          <source>STANDARD-COMPARE Function Syntax</source>
          <target state="translated">STANDARD-COMPARE Function Syntax</target>
        </trans-unit>
        <trans-unit id="dac339bd3f97676e1542e0534ed5895fed5588dd" translate="yes" xml:space="preserve">
          <source>STANDARD-DEVIATION Function Syntax</source>
          <target state="translated">표준 편차 함수 구문</target>
        </trans-unit>
        <trans-unit id="324703735b466c4ab95c0f7c2fb52f9b248bfcf7" translate="yes" xml:space="preserve">
          <source>START Syntax</source>
          <target state="translated">시작 구문</target>
        </trans-unit>
        <trans-unit id="154247a34e87fedbcd87e0036c7ef9c150466631" translate="yes" xml:space="preserve">
          <source>STATIC the program name is called as a included element and not dynamically which is the normal default.</source>
          <target state="translated">STATIC 프로그램 이름은 포함 된 요소로 호출되며 일반적인 기본값은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4d8b1214e6877778710445249f6455d61e23558b" translate="yes" xml:space="preserve">
          <source>STDCALL. &amp;lt; more info needed &amp;gt;</source>
          <target state="translated">STDCALL. &amp;lt;추가 정보 필요&amp;gt;</target>
        </trans-unit>
        <trans-unit id="043f458614daa43f0a3ab72aa35d366b88a5502c" translate="yes" xml:space="preserve">
          <source>STOP Syntax</source>
          <target state="translated">정지 구문</target>
        </trans-unit>
        <trans-unit id="b73adc9f6477b49121c2d68f1d5964e7524cfd34" translate="yes" xml:space="preserve">
          <source>STORED-CHAR-LENGTH Function Syntax</source>
          <target state="translated">STORED-CHAR-LENGTH 함수 구문</target>
        </trans-unit>
        <trans-unit id="b37eaf43b32bdd6e65b4016cc10646aea2f72ef2" translate="yes" xml:space="preserve">
          <source>STRING Syntax</source>
          <target state="translated">STRING 구문</target>
        </trans-unit>
        <trans-unit id="ff55ce740d5c2c585b9bbceb393487ac9e4807b2" translate="yes" xml:space="preserve">
          <source>STRING overflow condition</source>
          <target state="translated">STRING 오버 플로우 조건</target>
        </trans-unit>
        <trans-unit id="2587e8ac8e0d653df815007d01377f32dc9f7e55" translate="yes" xml:space="preserve">
          <source>SUBSTITUTE Function Syntax</source>
          <target state="translated">SUBSTITUTE 함수 구문</target>
        </trans-unit>
        <trans-unit id="b32d41f6b43771bab0f678b538fa382f91459d5a" translate="yes" xml:space="preserve">
          <source>SUBSTITUTE-CASE Function Syntax</source>
          <target state="translated">대체 사례 함수 구문</target>
        </trans-unit>
        <trans-unit id="f2dc00ca1e6859602e36de8cc97a942f3af747aa" translate="yes" xml:space="preserve">
          <source>SUBTRACT CORRESPONDING Syntax</source>
          <target state="translated">SUBTRACT CORRESPONDING 구문</target>
        </trans-unit>
        <trans-unit id="c7e6dfbce21db0afec1fefa289a119b9142fd152" translate="yes" xml:space="preserve">
          <source>SUBTRACT FROM Syntax</source>
          <target state="translated">구문에서 구문</target>
        </trans-unit>
        <trans-unit id="2b64cdce88721394e621b40d4588fd111017952c" translate="yes" xml:space="preserve">
          <source>SUBTRACT GIVING Syntax</source>
          <target state="translated">SUBTRACT GIVING 구문</target>
        </trans-unit>
        <trans-unit id="d110e717f81cc113ec939395eba1cd94bd8dddda" translate="yes" xml:space="preserve">
          <source>SUM Function Syntax</source>
          <target state="translated">SUM 함수 구문</target>
        </trans-unit>
        <trans-unit id="f665dc4d3c0ab4d0010b2ef1482cc5557d7677bb" translate="yes" xml:space="preserve">
          <source>SUM-OF Clause Syntax</source>
          <target state="translated">SUM-OF 절 구문</target>
        </trans-unit>
        <trans-unit id="2faa7be059c987f7fbbdb165d29cb72d83c29f61" translate="yes" xml:space="preserve">
          <source>SUPPRESS Syntax</source>
          <target state="translated">SUPPRESS 구문</target>
        </trans-unit>
        <trans-unit id="23f93c80ea5570a868c2cf2d9c0763d3ee2d040e" translate="yes" xml:space="preserve">
          <source>SYNCRONIZED Syntax</source>
          <target state="translated">동기화 된 구문</target>
        </trans-unit>
        <trans-unit id="12e6d18bb77ec762badd07ecc62e3f71ce9ac1ba" translate="yes" xml:space="preserve">
          <source>SYSLIB</source>
          <target state="translated">SYSLIB</target>
        </trans-unit>
        <trans-unit id="386ea13c23fc6b30b837120168afda6138fdba11" translate="yes" xml:space="preserve">
          <source>SYSTEM Built-In Subroutine Syntax</source>
          <target state="translated">SYSTEM 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="aa7bdbb7a883e6fcdf3c6acd236c188aea8c5433" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;BINARY-DOUBLE SIGNED&lt;/code&gt;</source>
          <target state="translated">Same as &lt;code&gt;BINARY-DOUBLE SIGNED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24f220423674a5332c7164883c812c6b65335261" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;BINARY-DOUBLE UNSIGNED&lt;/code&gt;</source>
          <target state="translated">Same as &lt;code&gt;BINARY-DOUBLE UNSIGNED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="da2f4d9bf9b464c09d4bb658345dbf8d9a006212" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;BINARY-LONG SIGNED&lt;/code&gt;</source>
          <target state="translated">Same as &lt;code&gt;BINARY-LONG SIGNED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f31f78a9e782858cae830a954fc2875e0573f1b" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;BINARY-LONG UNSIGNED&lt;/code&gt;</source>
          <target state="translated">Same as &lt;code&gt;BINARY-LONG UNSIGNED&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0359ac09e4ca19ccee103e4ea4d51b7e5eb4d024" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;BINARY-SHORT SIGNED&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BINARY-SHORT SIGNED&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="1db2e8e2a096e94f5301e97d6304b34c32fdb981" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;BINARY-SHORT UNSIGNED&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BINARY-SHORT UNSIGNED&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="f627a96ecba475a6c2ceeea5bf429da7429db7ad" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;BINARY&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BINARY&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="3a193b16880f00e9b4c7255f799bc67a0e2d41a3" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;FLOAT-LONG&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;FLOAT-LONG&lt;/code&gt; 과 동일</target>
        </trans-unit>
        <trans-unit id="71df2f4a489b2292d83d9e7354b8412715342818" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;FLOAT-SHORT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;FLOAT-SHORT&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="13cd1d2814ccd2849bf26be6ddd14394caa63970" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;PACKED-DECIMAL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PACKED-DECIMAL&lt;/code&gt; 과 동일</target>
        </trans-unit>
        <trans-unit id="c8ce7bd90aa526952ecd7155788a5fcd999dbe59" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;PROGRAM-POINTER&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PROGRAM-POINTER&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="5106a38fa95381ab7467e5d99851adc23ee8ca87" translate="yes" xml:space="preserve">
          <source>Same as&lt;code&gt;BINARY-DOUBLE SIGNED&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BINARY-DOUBLE SIGNED&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="ef15899c334707599da1bec824ea706414edbf1c" translate="yes" xml:space="preserve">
          <source>Same as&lt;code&gt;BINARY-DOUBLE UNSIGNED&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BINARY-DOUBLE UNSIGNED&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="99b0dcb23774b5d593e582959996eb9b385b6198" translate="yes" xml:space="preserve">
          <source>Same as&lt;code&gt;BINARY-LONG SIGNED&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BINARY-LONG SIGNED&lt;/code&gt; 과 동일</target>
        </trans-unit>
        <trans-unit id="e5dc348776c8fdd2d0b3c1ef214828b69dda40cd" translate="yes" xml:space="preserve">
          <source>Same as&lt;code&gt;BINARY-LONG UNSIGNED&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BINARY-LONG UNSIGNED&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="555c6e1ae2e0b06dc311892979bc8b84fd9e27c3" translate="yes" xml:space="preserve">
          <source>Same as&lt;code&gt;BINARY-SHORT SIGNED&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BINARY-SHORT SIGNED&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="0f034bddabbf417bf47e6a9e1c793ff1212ed946" translate="yes" xml:space="preserve">
          <source>Same as&lt;code&gt;BINARY-SHORT UNSIGNED&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BINARY-SHORT UNSIGNED&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="bd30040d8d743dbc60082e2570938677e309c3fd" translate="yes" xml:space="preserve">
          <source>Same as&lt;code&gt;BINARY&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;BINARY&lt;/code&gt; 과 동일</target>
        </trans-unit>
        <trans-unit id="afedf7e3c06d1546cd6ac3d2c0204feaa662feff" translate="yes" xml:space="preserve">
          <source>Same as&lt;code&gt;FLOAT-LONG&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;FLOAT-LONG&lt;/code&gt; 과 동일</target>
        </trans-unit>
        <trans-unit id="2c6bec079b1c594d6d87e98f77e3e81304dc4baa" translate="yes" xml:space="preserve">
          <source>Same as&lt;code&gt;FLOAT-SHORT&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;FLOAT-SHORT&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="eb2bfc2f19760e379604c6320e46f148858e0419" translate="yes" xml:space="preserve">
          <source>Same as&lt;code&gt;PACKED-DECIMAL&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PACKED-DECIMAL&lt;/code&gt; 과 동일</target>
        </trans-unit>
        <trans-unit id="c11fcd905fd88a8614e24b2c200c07274a2134a9" translate="yes" xml:space="preserve">
          <source>Same as&lt;code&gt;PROGRAM-POINTER&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PROGRAM-POINTER&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="7a6da08e551938fa2b87009535cb436c43d0471f" translate="yes" xml:space="preserve">
          <source>Sample Programs</source>
          <target state="translated">샘플 프로그램</target>
        </trans-unit>
        <trans-unit id="0e89b3033248a068fcc7db3e7b076e9cf271dd61" translate="yes" xml:space="preserve">
          <source>Screens are defined in the screen section of the data division. Once defined, screens are used at run-time via the &lt;code&gt;ACCEPT&lt;/code&gt; and &lt;code&gt;DISPLAY&lt;/code&gt; statements.</source>
          <target state="translated">화면은 데이터 분할의 화면 섹션에서 정의됩니다. 일단 정의되면 &lt;code&gt;ACCEPT&lt;/code&gt; 및 &lt;code&gt;DISPLAY&lt;/code&gt; 문을 통해 런타임에 화면이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f6c05d4340d834aacc1d450cda307aadf3195eab" translate="yes" xml:space="preserve">
          <source>Screens are defined in the screen section of the data division. Once defined, screens are used at run-time via the&lt;code&gt;ACCEPT&lt;/code&gt;and&lt;code&gt;DISPLAY&lt;/code&gt;statements.</source>
          <target state="translated">Screens are defined in the screen section of the data division. Once defined, screens are used at run-time via the &lt;code&gt;ACCEPT&lt;/code&gt; and &lt;code&gt;DISPLAY&lt;/code&gt; statements.</target>
        </trans-unit>
        <trans-unit id="79ba7d1f8387f740be70a48afccd300b20cc8bb6" translate="yes" xml:space="preserve">
          <source>Search Index</source>
          <target state="translated">Search Index</target>
        </trans-unit>
        <trans-unit id="7e44e05457b67b59985531f48d09fceb1a8a6112" translate="yes" xml:space="preserve">
          <source>Search strings on &lt;code&gt;REPLACE&lt;/code&gt; are always specified using the &lt;code&gt;==&lt;var&gt;pseudo-text-1&lt;/var&gt;==&lt;/code&gt; option. For example, to replace all occurrences of &lt;code&gt;UPON PRINTER&lt;/code&gt;, you would specify &lt;code&gt;==UPON PRINTER==&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;REPLACE&lt;/code&gt; 의 검색 문자열 은 항상 &lt;code&gt;==&lt;var&gt;pseudo-text-1&lt;/var&gt;==&lt;/code&gt; 옵션을 사용하여 지정됩니다 . 예를 들어, &lt;code&gt;UPON PRINTER&lt;/code&gt; 의 모든 발생을 바꾸 려면 &lt;code&gt;==UPON PRINTER==&lt;/code&gt; 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="40601b4434e43631bc325b4da992f8cb48c0b8d8" translate="yes" xml:space="preserve">
          <source>Search strings on&lt;code&gt;REPLACE&lt;/code&gt;are always specified using the&lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-1&lt;/i&gt;&amp;gt;==&lt;/code&gt;option. For example, to replace all occurrences of&lt;code&gt;UPON PRINTER&lt;/code&gt; you would specify&lt;code&gt;==UPON PRINTER==&lt;/code&gt;</source>
          <target state="translated">Search strings on &lt;code&gt;REPLACE&lt;/code&gt; are always specified using the &lt;code&gt;==&amp;lt;&lt;i&gt;pseudo-text-1&lt;/i&gt;&amp;gt;==&lt;/code&gt; option. For example, to replace all occurrences of &lt;code&gt;UPON PRINTER&lt;/code&gt; you would specify &lt;code&gt;==UPON PRINTER==&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bff9d0095b351752582d903743ceaaa221d4b1a8" translate="yes" xml:space="preserve">
          <source>Secure Input</source>
          <target state="translated">Secure Input</target>
        </trans-unit>
        <trans-unit id="f9c8195e938be36b1e04d3391bce11db62fd2094" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;, for additional information on the other &lt;code&gt;WITH&lt;/code&gt; clause options.</source>
          <target state="translated">다른 &lt;code&gt;WITH&lt;/code&gt; 절 옵션 에 대한 추가 정보는 &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6a37acd3f90ce06fc1f2074663a39689f43fb23" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;, for additional information on the other&lt;code&gt;WITH&lt;/code&gt;clause options.</source>
          <target state="translated">See &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;, for additional information on the other &lt;code&gt;WITH&lt;/code&gt; clause options.</target>
        </trans-unit>
        <trans-unit id="eb2ade3e4ab5020431033f4e83efe1738a632bf8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Appendix-B-_002d-Reserved-Word-List&quot;&gt;Appendix B - Reserved Word List&lt;/a&gt;, for a complete list of GnuCOBOL reserved words .</source>
          <target state="translated">GnuCOBOL 예약어의 전체 목록은 &lt;a href=&quot;#Appendix-B-_002d-Reserved-Word-List&quot;&gt;부록 B- 예약어 목록을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ccc9b201c947e1e014cf775eff33dbb02a79b3d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Appendix-B-_002d-Reserved-Word-List&quot;&gt;Appendix B - Reserved Word List&lt;/a&gt;, for a complete list of GnuCOBOL reserved words for the current release.</source>
          <target state="translated">See &lt;a href=&quot;#Appendix-B-_002d-Reserved-Word-List&quot;&gt;Appendix B - Reserved Word List&lt;/a&gt;, for a complete list of GnuCOBOL reserved words for the current release.</target>
        </trans-unit>
        <trans-unit id="61ea85685c5ddd17d8579147c4356dac31b42b17" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Arithmetic-Expressions&quot;&gt;Arithmetic Expressions&lt;/a&gt;, for more information on arithmetic expressions.</source>
          <target state="translated">See &lt;a href=&quot;#Arithmetic-Expressions&quot;&gt;Arithmetic Expressions&lt;/a&gt;, for more information on arithmetic expressions.</target>
        </trans-unit>
        <trans-unit id="e8866370949273481f1934447dd6937e1e8a3d98" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#CORRESPONDING&quot;&gt;CORRESPONDING&lt;/a&gt;, for a discussion of how corresponding matches between two group items are established.</source>
          <target state="translated">See &lt;a href=&quot;#CORRESPONDING&quot;&gt;CORRESPONDING&lt;/a&gt;, for a discussion of how corresponding matches between two group items are established.</target>
        </trans-unit>
        <trans-unit id="8c4a948663718e8e3965f21bc5143e1baa895ca4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#CORRESPONDING&quot;&gt;CORRESPONDING&lt;/a&gt;, for information on how corresponding matches will be found between &amp;lt;</source>
          <target state="translated">See &lt;a href=&quot;#CORRESPONDING&quot;&gt;CORRESPONDING&lt;/a&gt;, for information on how corresponding matches will be found between &amp;lt;</target>
        </trans-unit>
        <trans-unit id="6c3a5f7a0123d24b994fcc78557244cf88d15769" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#CORRESPONDING&quot;&gt;CORRESPONDING&lt;/a&gt;, for information on how corresponding matches will be found between &lt;var&gt;identifier-1&lt;/var&gt; and &lt;var&gt;identifier-2&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;identifier-1&lt;/var&gt; 과 &lt;var&gt;identifier-2&lt;/var&gt; 간에 일치하는 일치 항목을 &lt;a href=&quot;#CORRESPONDING&quot;&gt;찾는 방법&lt;/a&gt; 에 대한 정보는 CORRESPONDING을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a012a8c47df41cb8d01f62880e8787f65affbc5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Color-Palette-and-Video-Attributes&quot;&gt;Color Palette and Video Attributes&lt;/a&gt;, for more information on screen colors and video attributes.</source>
          <target state="translated">See &lt;a href=&quot;#Color-Palette-and-Video-Attributes&quot;&gt;Color Palette and Video Attributes&lt;/a&gt;, for more information on screen colors and video attributes.</target>
        </trans-unit>
        <trans-unit id="6e1480fd1d08ee87eedcf11c4ba7778d9dcdd724" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Condition-Names&quot;&gt;Condition Names&lt;/a&gt;, for a discussion of how condition names are used.</source>
          <target state="translated">See &lt;a href=&quot;#Condition-Names&quot;&gt;Condition Names&lt;/a&gt;, for a discussion of how condition names are used.</target>
        </trans-unit>
        <trans-unit id="4e9f4738b5b7a58141efe1f0c74e6f5b4fccc9ae" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Condition-Names&quot;&gt;Condition Names&lt;/a&gt;, for more information.</source>
          <target state="translated">See &lt;a href=&quot;#Condition-Names&quot;&gt;Condition Names&lt;/a&gt;, for more information.</target>
        </trans-unit>
        <trans-unit id="3fa30d3946970284544ff15439bda6f9c59db64b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Data-Description-Clauses&quot;&gt;Data Description Clauses&lt;/a&gt;, for information on the &lt;code&gt;EXTERNAL&lt;/code&gt; and &lt;code&gt;GLOBAL&lt;/code&gt; options.</source>
          <target state="translated">&lt;code&gt;EXTERNAL&lt;/code&gt; 및 &lt;code&gt;GLOBAL&lt;/code&gt; 옵션 에 대한 정보는 &lt;a href=&quot;#Data-Description-Clauses&quot;&gt;데이터 설명 조항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ffe237ef6114ed30bab01f7d6d321b66227fff97" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Data-Description-Clauses&quot;&gt;Data Description Clauses&lt;/a&gt;, for information on the usage of the various data description clauses.</source>
          <target state="translated">See &lt;a href=&quot;#Data-Description-Clauses&quot;&gt;Data Description Clauses&lt;/a&gt;, for information on the usage of the various data description clauses.</target>
        </trans-unit>
        <trans-unit id="e22c51f2e35f61813b65110710ced3e5ff98a7d3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Data-Description-Clauses&quot;&gt;Data Description Clauses&lt;/a&gt;, for information on the&lt;code&gt;EXTERNAL&lt;/code&gt;and&lt;code&gt;GLOBAL&lt;/code&gt;options.</source>
          <target state="translated">See &lt;a href=&quot;#Data-Description-Clauses&quot;&gt;Data Description Clauses&lt;/a&gt;, for information on the &lt;code&gt;EXTERNAL&lt;/code&gt; and &lt;code&gt;GLOBAL&lt;/code&gt; options.</target>
        </trans-unit>
        <trans-unit id="ec3c7cd1032e7441ffb83dbf23e1e704c0704b51" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Error-Exception-Codes&quot;&gt;Error Exception Codes&lt;/a&gt;, for a complete list of the exception codes and their meanings.</source>
          <target state="translated">예외 코드 및 해당 의미의 전체 목록은 &lt;a href=&quot;#Error-Exception-Codes&quot;&gt;오류 예외 코드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ad6ddb0f5497d5a05d071a86ce6326e7163bbbc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt;, for information on the &lt;code&gt;GLOBAL&lt;/code&gt; option.</source>
          <target state="translated">참조 &lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt; 의에 대한 정보 &lt;code&gt;GLOBAL&lt;/code&gt; 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="0314bef84f31293f922a9a59460c263f0d332ee8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt;, for information on the&lt;code&gt;GLOBAL&lt;/code&gt;option.</source>
          <target state="translated">참조 &lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt; 의에 대한 정보 &lt;code&gt;GLOBAL&lt;/code&gt; 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="f50f456669b7cf3e0ba57085c4d5b594dc2c00af" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#LOCALE-Names&quot;&gt;LOCALE Names&lt;/a&gt;, for a list of typically-available locale names.</source>
          <target state="translated">일반적으로 사용 가능한 로케일 이름 목록은 &lt;a href=&quot;#LOCALE-Names&quot;&gt;LOCALE 이름을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="43cfed89ec2c088c8977784439f946e77d59b0dc" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Locating-Copybooks&quot;&gt;Locating Copybooks&lt;/a&gt;, for the specific rules on how copybooks are located by the compiler.</source>
          <target state="translated">컴파일러가 카피 북을 찾는 방법에 대한 특정 규칙은 카피 북 &lt;a href=&quot;#Locating-Copybooks&quot;&gt;찾기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4b67d5bc7c5941961d0f9dac13632cd266def73" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Marking-Changes-in-Programs&quot;&gt;Marking Changes in Programs&lt;/a&gt;, for discussion of a valuable use to which the program name area may be put today.</source>
          <target state="translated">오늘날 프로그램 이름 영역에 적용 할 수있는 귀중한 사용법에 대한 설명은 &lt;a href=&quot;#Marking-Changes-in-Programs&quot;&gt;프로그램 변경 사항 표시를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35290b00862a216af9784d021af6d0aea693e158" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Marking-Changes-in-Programs&quot;&gt;Marking Changes in Programs&lt;/a&gt;, for discussion of a valuable use to which the sequence number area may be put today.</source>
          <target state="translated">오늘날 시퀀스 번호 영역을 사용할 수있는 귀중한 사용법에 대한 설명은 &lt;a href=&quot;#Marking-Changes-in-Programs&quot;&gt;프로그램의 변경 표시를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a0fb183f0445e0492e5e5f3c0c2ccb051bc33e1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#RWCS-Lexicon&quot;&gt;RWCS Lexicon&lt;/a&gt;, for a description of the seven different types of report groups.</source>
          <target state="translated">7 가지 유형의 보고서 그룹에 대한 설명은 &lt;a href=&quot;#RWCS-Lexicon&quot;&gt;RWCS Lexicon을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="92b243f9c7300442e9e15584d6d67d1fd0d6687d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Record-Locking&quot;&gt;Record Locking&lt;/a&gt;, for additional information on record locking.</source>
          <target state="translated">&lt;a href=&quot;#Record-Locking&quot;&gt;레코드 잠금&lt;/a&gt; 에 대한 추가 정보는 레코드 잠금을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6c61dbdf796fbc7816c83984e2f7f701aab05cb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Record-Locking&quot;&gt;Record Locking&lt;/a&gt;, to review the various record locking behaviours.</source>
          <target state="translated">다양한 레코드 잠금 동작을 검토하려면 &lt;a href=&quot;#Record-Locking&quot;&gt;레코드 잠금을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="46dacf046ac16c5ec82c7d16a35e13747f33184d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Sub_002dProgramming&quot;&gt;Sub-Programming&lt;/a&gt;, for a complete discussion of sub-programming.</source>
          <target state="translated">&lt;a href=&quot;#Sub_002dProgramming&quot;&gt;하위 프로그래밍&lt;/a&gt; 에 대한 자세한 내용은 하위 프로그래밍을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4744e3c317efad88cd3f30d57284098ab648ae69" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#g_t01_002dLevel-Constants&quot;&gt;01-Level Constants&lt;/a&gt;, for additional information.</source>
          <target state="translated">추가 정보는 &lt;a href=&quot;#g_t01_002dLevel-Constants&quot;&gt;01- 레벨 상수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="600fbdfa8e8cca09bf6de6c33182c4d09772a19d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#g_t66_002dLevel-Data-Items&quot;&gt;66-Level Data Items&lt;/a&gt;, for additional information on the &lt;code&gt;RENAMES&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;RENAMES&lt;/code&gt; 절 에 대한 추가 정보는 &lt;a href=&quot;#g_t66_002dLevel-Data-Items&quot;&gt;66 레벨 데이터 항목을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e29463cf63812e1b76d8c63e9fb349f445d0401c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#g_t66_002dLevel-Data-Items&quot;&gt;66-Level Data Items&lt;/a&gt;, for additional information on the RENAMES clause.</source>
          <target state="translated">RENAMES 절에 대한 추가 정보는 &lt;a href=&quot;#g_t66_002dLevel-Data-Items&quot;&gt;66 레벨 데이터 항목을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0fd371b3be8e39e77f7a6ba721f03ce4c01500dd" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#g_t88_002dLevel-Data-Items&quot;&gt;88-Level Data Items&lt;/a&gt;, for a discussion of how this format of &lt;code&gt;VALUE&lt;/code&gt; is used to create condition names.</source>
          <target state="translated">이 &lt;code&gt;VALUE&lt;/code&gt; 형식이 조건 이름을 만드는 데 사용되는 방법에 대한 설명은 &lt;a href=&quot;#g_t88_002dLevel-Data-Items&quot;&gt;88 수준 데이터 항목을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2fd431c22a0e7c6eecc05c2248dc4896286df057" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#g_t88_002dLevel-Data-Items&quot;&gt;88-Level Data Items&lt;/a&gt;, for a discussion of how this format of&lt;code&gt;VALUE&lt;/code&gt;is used to create condition names.</source>
          <target state="translated">이 형식의 &lt;code&gt;VALUE&lt;/code&gt; 가 조건 이름을 작성하는 데 사용되는 방법에 대한 설명은 &lt;a href=&quot;#g_t88_002dLevel-Data-Items&quot;&gt;88 레벨 데이터 항목을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="294e8e066a44f1dcccc715bdb14fa18d882d4136" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#g_t88_002dLevel-Data-Items&quot;&gt;88-Level Data Items&lt;/a&gt;, or See &lt;a href=&quot;#Condition-Names&quot;&gt;Condition Names&lt;/a&gt;, for more information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#g_t88_002dLevel-Data-Items&quot;&gt;88 수준 데이터 항목&lt;/a&gt; 또는 &lt;a href=&quot;#Condition-Names&quot;&gt;조건 이름&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="178a59fd5932b18f2ddd26c707a26a5d24743a32" translate="yes" xml:space="preserve">
          <source>See entry-point.</source>
          <target state="translated">진입 점을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e083de973c136f91bac4d56cb40dbb24375cbb3a" translate="yes" xml:space="preserve">
          <source>See the documentation of the &lt;code&gt;SEARCH&lt;/code&gt; (see &lt;a href=&quot;#SEARCH&quot;&gt;SEARCH&lt;/a&gt;), &lt;code&gt;SEARCH ALL&lt;/code&gt; (see &lt;a href=&quot;#SEARCH-ALL&quot;&gt;SEARCH ALL&lt;/a&gt;) and &lt;code&gt;SORT&lt;/code&gt; (see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) statements for explanations of the  &lt;code&gt;KEY&lt;/code&gt; and  &lt;code&gt;INDEXED BY&lt;/code&gt; clauses.</source>
          <target state="translated">의 문서를 참조하십시오 &lt;code&gt;SEARCH&lt;/code&gt; 합니다 ( &lt;a href=&quot;#SEARCH&quot;&gt;검색하기&lt;/a&gt; ), &lt;code&gt;SEARCH ALL&lt;/code&gt; (참조 &lt;a href=&quot;#SEARCH-ALL&quot;&gt;검색 ALL을&lt;/a&gt; )과 &lt;code&gt;SORT&lt;/code&gt; (참조 &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt; 의 설명에 대한 문) &lt;code&gt;KEY&lt;/code&gt; 와 &lt;code&gt;INDEXED BY&lt;/code&gt; 절을.</target>
        </trans-unit>
        <trans-unit id="16737e1bcd19306dcb16f4adbd4bc1ee0ad6b7f5" translate="yes" xml:space="preserve">
          <source>See the documentation of the&lt;code&gt;SEARCH&lt;/code&gt;(see &lt;a href=&quot;#SEARCH&quot;&gt;SEARCH&lt;/a&gt;),&lt;code&gt;SEARCH ALL&lt;/code&gt;(see &lt;a href=&quot;#SEARCH-ALL&quot;&gt;SEARCH ALL&lt;/a&gt;) and&lt;code&gt;SORT&lt;/code&gt;(see &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt;) statements for explanations of the&lt;code&gt;KEY&lt;/code&gt;</source>
          <target state="translated">의 문서를 참조하십시오 &lt;code&gt;SEARCH&lt;/code&gt; 합니다 ( &lt;a href=&quot;#SEARCH&quot;&gt;검색하기&lt;/a&gt; ), &lt;code&gt;SEARCH ALL&lt;/code&gt; (참조 &lt;a href=&quot;#SEARCH-ALL&quot;&gt;검색 ALL&lt;/a&gt; )과 &lt;code&gt;SORT&lt;/code&gt; (참조 &lt;a href=&quot;#SORT&quot;&gt;SORT&lt;/a&gt; 의 설명에 대한 문) &lt;code&gt;KEY&lt;/code&gt; 를</target>
        </trans-unit>
        <trans-unit id="4559f13dbc4b51652298930a9859a11ddfa1e684" translate="yes" xml:space="preserve">
          <source>See the documentation on the &lt;code&gt;CBL_GET_SCR_SIZE&lt;/code&gt; built-in system subroutine (see &lt;a href=&quot;#CBL_005fGET_005fSCR_005fSIZE&quot;&gt;CBL_GET_SCR_SIZE&lt;/a&gt;) for another way to retrieve this information.</source>
          <target state="translated">상의 문서를 참조하십시오 &lt;code&gt;CBL_GET_SCR_SIZE&lt;/code&gt; 가 내장 된 시스템의 서브 루틴 (참조 &lt;a href=&quot;#CBL_005fGET_005fSCR_005fSIZE&quot;&gt;CBL_GET_SCR_SIZE을&lt;/a&gt; )이 정보를 검색하는 또 다른 방법을.</target>
        </trans-unit>
        <trans-unit id="b99d16c50e28774b9367c6efdc9ae504f33ee4f7" translate="yes" xml:space="preserve">
          <source>See the documentation on the&lt;code&gt;CBL_GET_SCR_SIZE&lt;/code&gt;built-in system subroutine (see &lt;a href=&quot;#CBL_005fGET_005fSCR_005fSIZE&quot;&gt;CBL_GET_SCR_SIZE&lt;/a&gt;) for another way to retrieve this information.</source>
          <target state="translated">상의 문서를 참조하십시오 &lt;code&gt;CBL_GET_SCR_SIZE&lt;/code&gt; 가 내장 된 시스템의 서브 루틴 (참조 &lt;a href=&quot;#CBL_005fGET_005fSCR_005fSIZE&quot;&gt;CBL_GET_SCR_SIZE을&lt;/a&gt; )이 정보를 검색하는 또 다른 방법을.</target>
        </trans-unit>
        <trans-unit id="4fe00b90c464b7b4f61b43d70bc3ad28367a1e9d" translate="yes" xml:space="preserve">
          <source>See the period at the end of the second &lt;code&gt;MULTIPLY&lt;/code&gt; (see &lt;a href=&quot;#MULTIPLY&quot;&gt;MULTIPLY&lt;/a&gt;)? That is what terminates the scope of the &lt;code&gt;IF&lt;/code&gt;, thus making the &lt;code&gt;DISPLAY&lt;/code&gt; statement&amp;rsquo;s execution completely independent of the &lt;code&gt;TRUE&lt;/code&gt;/&lt;code&gt;FALSE&lt;/code&gt; status of the &lt;code&gt;IF&lt;/code&gt;.</source>
          <target state="translated">두 번째 &lt;code&gt;MULTIPLY&lt;/code&gt; 끝에 마침표가 표시 됩니까 ( &lt;a href=&quot;#MULTIPLY&quot;&gt;MULTIPLY&lt;/a&gt; 참조 )? 이것이 &lt;code&gt;IF&lt;/code&gt; 의 범위를 종료 하므로 &lt;code&gt;DISPLAY&lt;/code&gt; 문의 실행 이 &lt;code&gt;IF&lt;/code&gt; 의 &lt;code&gt;TRUE&lt;/code&gt; / &lt;code&gt;FALSE&lt;/code&gt; 상태와 완전히 독립적으로 됩니다.</target>
        </trans-unit>
        <trans-unit id="a3e9c6422faf2d00e499d2d38fa0bb509b141b92" translate="yes" xml:space="preserve">
          <source>See the period at the end of the second&lt;code&gt;MULTIPLY&lt;/code&gt;(see &lt;a href=&quot;#MULTIPLY&quot;&gt;MULTIPLY&lt;/a&gt;)? That is what terminates the scope of the&lt;code&gt;IF&lt;/code&gt; thus making the&lt;code&gt;DISPLAY&lt;/code&gt;statement&amp;rsquo;s execution completely independent of the TRUE/FALSE status of the&lt;code&gt;IF&lt;/code&gt;</source>
          <target state="translated">두 번째의 끝에 마침표를 참조하십시오 &lt;code&gt;MULTIPLY&lt;/code&gt; (참조 &lt;a href=&quot;#MULTIPLY&quot;&gt;곱하기&lt;/a&gt; )? 이것이 &lt;code&gt;IF&lt;/code&gt; 의 범위를 종료시켜 &lt;code&gt;DISPLAY&lt;/code&gt; 문의 실행을 &lt;code&gt;IF&lt;/code&gt; 의 TRUE / FALSE 상태와 완전히 독립적으로 만드는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="909ff939ec981953f61ffe1fe6213ae8d9c03027" translate="yes" xml:space="preserve">
          <source>See the&lt;code&gt;UNLOCK&lt;/code&gt;statement (see &lt;a href=&quot;#UNLOCK&quot;&gt;UNLOCK&lt;/a&gt;) for additional details.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;UNLOCK&lt;/code&gt; 문 ( &lt;a href=&quot;#UNLOCK&quot;&gt;UNLOCK&lt;/a&gt; 참조 )을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="367bca9f464537df5c942a3ab8170b21d106dd3d" translate="yes" xml:space="preserve">
          <source>Selected WHEN Clause</source>
          <target state="translated">언제 조항 선택</target>
        </trans-unit>
        <trans-unit id="90426e9620111fd78abcc549ff6e519a422fa8ce" translate="yes" xml:space="preserve">
          <source>Selected WHEN clause</source>
          <target state="translated">선택된 WHEN 절</target>
        </trans-unit>
        <trans-unit id="12cc059fea3b82fb7364f83d2b0d3f838e439dd4" translate="yes" xml:space="preserve">
          <source>Selection-Object</source>
          <target state="translated">Selection-Object</target>
        </trans-unit>
        <trans-unit id="c12c9c50c093ba4e7bfc61ba93c5785b24d1edc4" translate="yes" xml:space="preserve">
          <source>Selection-Subject</source>
          <target state="translated">Selection-Subject</target>
        </trans-unit>
        <trans-unit id="1bb1f30ec48f10e1a7e3a2acbd5f28a35dc4644c" translate="yes" xml:space="preserve">
          <source>Sentence</source>
          <target state="translated">Sentence</target>
        </trans-unit>
        <trans-unit id="71addf3a3d48680e130dc33780d38b63a187464c" translate="yes" xml:space="preserve">
          <source>Sequence Number Area</source>
          <target state="translated">시퀀스 번호 영역</target>
        </trans-unit>
        <trans-unit id="d9786d8821a96e23e9013330d6148c6bcf5afb8e" translate="yes" xml:space="preserve">
          <source>Sequential READ Syntax</source>
          <target state="translated">순차 읽기 구문</target>
        </trans-unit>
        <trans-unit id="a91120e27157f99e4885921bd23d39f5ce9bfed7" translate="yes" xml:space="preserve">
          <source>Sequential files are processed using the following statements:</source>
          <target state="translated">순차 파일은 다음 명령문을 사용하여 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="c5805f3ca1e9f0f1ef7a6eafb6b5c84cb549e66e" translate="yes" xml:space="preserve">
          <source>Set current position on terminal.</source>
          <target state="translated">터미널에서 현재 위치를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="069ee1877b1845d947f09c9a0e31f74c8dff31df" translate="yes" xml:space="preserve">
          <source>Set to a directory/folder appropriate to create temporary files in. The intermediate working files created by the compiler will be created here (and deleted once they&amp;rsquo;re no longer needed).</source>
          <target state="translated">임시 파일을 작성하기에 적합한 디렉토리 / 폴더로 설정하십시오. 컴파일러가 작성한 중간 작업 파일이 여기에 작성되고 더 이상 필요하지 않으면 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="7d744e087d8ed8b103ef95cee6571f760db36bab" translate="yes" xml:space="preserve">
          <source>Set to any additional linker switches (&lt;code&gt;ld&lt;/code&gt;) that can specify where standard libraries that must be linked with the program can be found. The default is &quot;&quot; (empty).</source>
          <target state="translated">프로그램과 연결되어야하는 표준 라이브러리를 찾을 수있는 위치를 지정할 수 있는 추가 링커 스위치 ( &lt;code&gt;ld&lt;/code&gt; )로 설정 합니다. 기본값은 &quot;&quot;(비어 있음)입니다.</target>
        </trans-unit>
        <trans-unit id="b0afa4233d7741ab8d407d6b11f7222a52c49858" translate="yes" xml:space="preserve">
          <source>Set to any additional linker switches (ld) that can specify where standard libraries that must be linked with the program can be found. The default is &quot;&quot; (null).</source>
          <target state="translated">프로그램과 연결해야하는 표준 라이브러리를 찾을 수있는 위치를 지정할 수있는 추가 링커 스위치 (ld)로 설정하십시오. 기본값은 &quot;&quot;(널)입니다.</target>
        </trans-unit>
        <trans-unit id="65cbff5002667b4ba0099770aafd5734619eaab5" translate="yes" xml:space="preserve">
          <source>Set to any linker (&lt;code&gt;ld&lt;/code&gt;) switches that you&amp;rsquo;d like to pass on to the C compiler from the &lt;code&gt;cobc&lt;/code&gt; compiler (in addition to any that cobc will specify).</source>
          <target state="translated">&lt;code&gt;cobc&lt;/code&gt; 컴파일러 에서 C 컴파일러로 전달하려는 링커 ( &lt;code&gt;ld&lt;/code&gt; ) 스위치로 설정합니다 ( cobc가 지정하는 모든 스위치에 추가).</target>
        </trans-unit>
        <trans-unit id="e7729ec720d5cb121e904e6421f098453e46e844" translate="yes" xml:space="preserve">
          <source>Set to any linker switches (&lt;code&gt;ld&lt;/code&gt;) that specify where standard libraries that must be linked with the program can be found.</source>
          <target state="translated">프로그램과 연결되어야하는 표준 라이브러리를 찾을 수있는 위치를 지정 하는 링커 스위치 ( &lt;code&gt;ld&lt;/code&gt; )로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3d6f31a473a4c76473967ddbb7c7996f26a3a672" translate="yes" xml:space="preserve">
          <source>Set to any linker switches (ld) that specify where standard libraries that must be linked with the program can be found.</source>
          <target state="translated">프로그램과 연결해야하는 표준 라이브러리를 찾을 수있는 위치를 지정하는 링커 스위치 (ld)로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="5faf23e3b89e0820f532679031bd15696dc10e40" translate="yes" xml:space="preserve">
          <source>Set to any linker/loader (ld) switches that you&amp;rsquo;d like to pass on to the C compiler from the&lt;code&gt;cobc&lt;/code&gt;compiler (in addition to any that cobc will specify).</source>
          <target state="translated">&lt;code&gt;cobc&lt;/code&gt; 컴파일러 에서 C 컴파일러로 전달하려는 링커 / 로더 (ld) 스위치로 설정합니다 (cobc가 지정하는 것 외에도).</target>
        </trans-unit>
        <trans-unit id="b175fd9e637c5d0df66a2243d76a4bb5a06987b9" translate="yes" xml:space="preserve">
          <source>Set to any switches that you&amp;rsquo;d like to pass on to the C compiler from the &lt;code&gt;cobc&lt;/code&gt; compiler (in addition to any that &lt;code&gt;cobc&lt;/code&gt; will specify).</source>
          <target state="translated">&lt;code&gt;cobc&lt;/code&gt; 컴파일러 에서 C 컴파일러로 전달하려는 스위치로 설정합니다 ( &lt;code&gt;cobc&lt;/code&gt; 가 지정할 모든 스위치 에 추가 ).</target>
        </trans-unit>
        <trans-unit id="b75fcfa6f7d79959cd815db6ecb29300e5f8f829" translate="yes" xml:space="preserve">
          <source>Set to any switches that you&amp;rsquo;d like to pass on to the C compiler from the&lt;code&gt;cobc&lt;/code&gt;compiler (in addition to any that&lt;code&gt;cobc&lt;/code&gt;will specify).</source>
          <target state="translated">&lt;code&gt;cobc&lt;/code&gt; 컴파일러 에서 cobc 컴파일러 로 전달할 스위치로 설정하십시오 ( &lt;code&gt;cobc&lt;/code&gt; 가 지정 하는 스위치 외에도 ).</target>
        </trans-unit>
        <trans-unit id="54f3d4af00ad5fd089a0cd86a7c91daab5b6f150" translate="yes" xml:space="preserve">
          <source>Set to the name of the C compiler you wish GnuCOBOL to use.</source>
          <target state="translated">GnuCOBOL이 사용할 C 컴파일러의 이름으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="931403a28a6f9c0d541a7dbdff91b8106c493eaa" translate="yes" xml:space="preserve">
          <source>Set to the path to the folder where GnuCOBOL</source>
          <target state="translated">GnuCOBOL이있는 폴더의 경로로 설정</target>
        </trans-unit>
        <trans-unit id="e48e1c6eb499ac6dacdaa2e499873107fe37034b" translate="yes" xml:space="preserve">
          <source>Set to the path to the folder where GnuCOBOL &quot;config&quot; files are kept.</source>
          <target state="translated">GnuCOBOL &quot;config&quot;파일이 보관 된 폴더의 경로로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="e081a67177f9edfda31cc637258bc9a10c5a748a" translate="yes" xml:space="preserve">
          <source>Sets and/or clears all eight of the COBOL switches (&lt;code&gt;SWITCH-1&lt;/code&gt; through &lt;code&gt;SWITCH-8&lt;/code&gt;). See &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;, for an explanation of those switches.</source>
          <target state="translated">8 개의 COBOL 스위치 ( &lt;code&gt;SWITCH-1&lt;/code&gt; ~ &lt;code&gt;SWITCH-8&lt;/code&gt; ) 를 모두 설정 및 / 또는 지 웁니다 . 이러한 스위치에 대한 설명은 &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="551db50d808968c66636de937ee33fd8893766c2" translate="yes" xml:space="preserve">
          <source>Sets and/or clears all eight of the COBOL switches (SWITCH-1 through SWITCH-8). See &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;, for an explanation of those switches.</source>
          <target state="translated">8 개의 COBOL 스위치 (SWITCH-1 ~ SWITCH-8)를 설정 및 / 또는 지 웁니다. 해당 스위치에 대한 설명은 &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5f9337e9bd07361f3b7cf24b8d68d1f8b4798dc" translate="yes" xml:space="preserve">
          <source>Setting this variable to any non-blank value will allow the &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) to detect the pressing of the &lt;code&gt;Esc&lt;/code&gt;, &lt;code&gt;PgUp&lt;/code&gt; and &lt;code&gt;PgDn&lt;/code&gt; keys.</source>
          <target state="translated">이 변수를 공백이 아닌 값으로 설정하면 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 문 ( &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item 참조&lt;/a&gt; )이 &lt;code&gt;Esc&lt;/code&gt; , &lt;code&gt;PgUp&lt;/code&gt; 및 &lt;code&gt;PgDn&lt;/code&gt; 키 누름을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af8f36edddce014edfb752b86686adfa96f5118b" translate="yes" xml:space="preserve">
          <source>Setting this variable to any non-blank value will allow the&lt;code&gt;ACCEPT screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) to detect the pressing of the &quot;Esc&quot;, &quot;PgUp&quot; and &quot;PgDn&quot; keys.</source>
          <target state="translated">이 변수를 공백이 아닌 값으로 설정하면 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 문 ( &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item 참조&lt;/a&gt; )이 &quot;Esc&quot;, &quot;PgUp&quot;및 &quot;PgDn&quot;키 누르기를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b851981ce8958c032d4eb43bd5b82975c990ba8a" translate="yes" xml:space="preserve">
          <source>Shift Left Dbl Click</source>
          <target state="translated">왼쪽 더블 클릭 시프트</target>
        </trans-unit>
        <trans-unit id="13d05b6f9c5bbfff9a3a837baa699f4bf6b1b3cb" translate="yes" xml:space="preserve">
          <source>Shift Left Pressed</source>
          <target state="translated">왼쪽으로 눌림</target>
        </trans-unit>
        <trans-unit id="e75c5668b5dd8510512c8ea61cea2be6138d9761" translate="yes" xml:space="preserve">
          <source>Shift Left Released</source>
          <target state="translated">왼쪽으로 이동 해제</target>
        </trans-unit>
        <trans-unit id="1cf194eda76a9212ae2a99b2669edc12bdc03163" translate="yes" xml:space="preserve">
          <source>Shift Mid Dbl Click</source>
          <target state="translated">중간 더블 클릭 시프트</target>
        </trans-unit>
        <trans-unit id="bb4451caa3d8fe307b2e41d0e1f3f33499a5c5ab" translate="yes" xml:space="preserve">
          <source>Shift Mid Pressed</source>
          <target state="translated">누르면 중간 시프트</target>
        </trans-unit>
        <trans-unit id="d8d4249ef22c9ac7aee850fe44a9746efad7e16a" translate="yes" xml:space="preserve">
          <source>Shift Mid Released</source>
          <target state="translated">릴리스 중간 시프트</target>
        </trans-unit>
        <trans-unit id="8b05e277bfdbfbf71132c633d55279b295bc4242" translate="yes" xml:space="preserve">
          <source>Shift Move</source>
          <target state="translated">이동 이동</target>
        </trans-unit>
        <trans-unit id="ab590d025a08ae006e748422a357058cbebea15b" translate="yes" xml:space="preserve">
          <source>Shift Right Dbl Click</source>
          <target state="translated">오른쪽 더블 클릭 시프트</target>
        </trans-unit>
        <trans-unit id="5b9d4f227bdb1c529af7cc4f2492bcf762be16a9" translate="yes" xml:space="preserve">
          <source>Shift Right Pressed</source>
          <target state="translated">오른쪽으로 이동</target>
        </trans-unit>
        <trans-unit id="85896c96693466c5b85ee2abe16bc0a466dc8963" translate="yes" xml:space="preserve">
          <source>Shift Right Released</source>
          <target state="translated">오른쪽으로 시프트 해제</target>
        </trans-unit>
        <trans-unit id="360afd7990b83b6b6dc7e087ab3bc00df1f1b8a0" translate="yes" xml:space="preserve">
          <source>Shift Wheel Down</source>
          <target state="translated">휠을 아래로 이동</target>
        </trans-unit>
        <trans-unit id="1bcc42ec7602adba1b05470c584e3aa3e2eb6a11" translate="yes" xml:space="preserve">
          <source>Shift Wheel Left</source>
          <target state="translated">휠을 왼쪽으로 이동</target>
        </trans-unit>
        <trans-unit id="a8c0e4d273489bc9dc1e37a5fdd5e8b2d50f29d0" translate="yes" xml:space="preserve">
          <source>Shift Wheel Right</source>
          <target state="translated">휠을 오른쪽으로 이동</target>
        </trans-unit>
        <trans-unit id="e6ecbbfca6d3b7e77b9b8ef6ed3e8a6c9be1883a" translate="yes" xml:space="preserve">
          <source>Shift Wheel Up</source>
          <target state="translated">휠 위로 이동</target>
        </trans-unit>
        <trans-unit id="d6f26a09f01e5b0e60f0a4d452cb6b1b4d899ccd" translate="yes" xml:space="preserve">
          <source>Should actual disk work files be necessary due to the amount of data being sorted or merged, they will be automatically allocated to disk in a folder defined by:</source>
          <target state="translated">정렬 또는 병합되는 데이터 양으로 인해 실제 디스크 작업 파일이 필요한 경우 다음에 의해 정의 된 폴더의 디스크에 자동으로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="37c789e6192501860e398e9f024664d486d3044d" translate="yes" xml:space="preserve">
          <source>Should any &amp;lt;</source>
          <target state="translated">어떤 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="d0a3bf517b40b25f01d15475c6f20a6c57fc3276" translate="yes" xml:space="preserve">
          <source>Should any &lt;var&gt;identifier-2&lt;/var&gt; be an integer numeric data item, the result computed when that &lt;var&gt;identifier-2&lt;/var&gt; is divided by &lt;var&gt;literal-1&lt;/var&gt; or &lt;var&gt;identifier-1&lt;/var&gt; will also be an integer &amp;mdash; any remainder from that division will be discarded.</source>
          <target state="translated">임의한다 &lt;var&gt;identifier-2&lt;/var&gt; 그 때 정수 숫자 데이터 항목 일 결과는 연산 &lt;var&gt;identifier-2&lt;/var&gt; 로 나누어 &lt;var&gt;literal-1&lt;/var&gt; 또는 &lt;var&gt;identifier-1&lt;/var&gt; 나눗셈 어떠한 나머지 폐기한다 - 또한 정수 것이다.</target>
        </trans-unit>
        <trans-unit id="4fb64eda71bd9c5e3bea41b0953821a085fb4af5" translate="yes" xml:space="preserve">
          <source>Should disk work files be necessary due to the amount of data being sorted, they will be automatically allocated to disk in a folder defined by the</source>
          <target state="translated">정렬되는 데이터의 양으로 인해 디스크 작업 파일이 필요한 경우이 파일은 다음으로 정의 된 폴더의 디스크에 자동으로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="f32cbd33dc25c2538d052559e20cfa0910f90a5c" translate="yes" xml:space="preserve">
          <source>Should disk work files be necessary due to the amount of data being sorted, they will be automatically allocated to disk in a folder defined by the   &lt;code&gt;TMPDIR&lt;/code&gt; run-time environment variable,   &lt;code&gt;TMP&lt;/code&gt; run-time environment variable or   &lt;code&gt;TEMP&lt;/code&gt; run-time environment variable run-time environment variables (see &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;Run Time Environment Variables&lt;/a&gt;) (checked for existence in that sequence). These disk files will be automatically purged upon &lt;code&gt;SORT&lt;/code&gt; termination or program execution termination (normal or otherwise).</source>
          <target state="translated">정렬되는 데이터의 양으로 인해 디스크 작업 파일이 필요한 경우 &lt;code&gt;TMPDIR&lt;/code&gt; 런타임 환경 변수, &lt;code&gt;TMP&lt;/code&gt; 런타임 환경 변수 또는 &lt;code&gt;TEMP&lt;/code&gt; 런타임 환경 변수 런타임에 의해 정의 된 폴더의 디스크에 자동으로 할당됩니다. 시간 환경 변수 ( &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;런타임&lt;/a&gt; 환경 변수 참조 ) (해당 시퀀스에 존재하는지 확인). 이러한 디스크 파일은 &lt;code&gt;SORT&lt;/code&gt; 종료 또는 프로그램 실행 종료 (정상 또는 기타) 시 자동으로 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="09e8970c2fc09b6b3703058238f05e0f78a7a2ae" translate="yes" xml:space="preserve">
          <source>Sign conditions evaluate the numeric state of a data item defined with a &lt;code&gt;PICTURE&lt;/code&gt; (see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) and/or &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) that supports numeric values.</source>
          <target state="translated">부호 조건 은 숫자 값을 지원 하는 &lt;code&gt;PICTURE&lt;/code&gt; ( &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt; 참조 ) 및 / 또는 &lt;code&gt;USAGE&lt;/code&gt; ( &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt; 참조 )로 정의 된 데이터 항목의 숫자 상태를 평가 합니다.</target>
        </trans-unit>
        <trans-unit id="6e9ee72471e723c65e456d4172eb51dd544d91e6" translate="yes" xml:space="preserve">
          <source>Sign-Condition Syntax</source>
          <target state="translated">부호 조건 구문</target>
        </trans-unit>
        <trans-unit id="ca4dc5601dadd4ed4dae70b7491398f13c8a8df3" translate="yes" xml:space="preserve">
          <source>Signed Packed Decimal</source>
          <target state="translated">부호있는 10 진수</target>
        </trans-unit>
        <trans-unit id="05f9dde621a30a6f3fe9457983ad3598eee536c5" translate="yes" xml:space="preserve">
          <source>Significant digits truncated in store</source>
          <target state="translated">상점에서 많은 숫자가 잘림</target>
        </trans-unit>
        <trans-unit id="7c430f8c906b473ab7e1d7e211ca65e38236d898" translate="yes" xml:space="preserve">
          <source>Similarly, since there is no &lt;code&gt;END PROGRAM&lt;/code&gt; marker separating &lt;code&gt;PROG3&lt;/code&gt; from &lt;code&gt;PROG2&lt;/code&gt;, it is possible for &lt;code&gt;PROG3&lt;/code&gt; to access &lt;code&gt;GLOBAL&lt;/code&gt; files and data items defined within &lt;code&gt;PROG2&lt;/code&gt;. Since &lt;code&gt;PROG2&lt;/code&gt; is nested within &lt;code&gt;PROG1&lt;/code&gt;, any &lt;code&gt;GLOBAL&lt;/code&gt; resources defined within &lt;code&gt;PROG1&lt;/code&gt; will be available to &lt;code&gt;PROG3&lt;/code&gt; as well.</source>
          <target state="translated">전혀 없으므로 마찬가지로 &lt;code&gt;END PROGRAM&lt;/code&gt; 분리 마커 &lt;code&gt;PROG3&lt;/code&gt; 를 으로부터 &lt;code&gt;PROG2&lt;/code&gt; 는 , 그것이 가능하다 &lt;code&gt;PROG3&lt;/code&gt; 액세스 &lt;code&gt;GLOBAL&lt;/code&gt; 내에 정의 파일과 데이터 항목 &lt;code&gt;PROG2&lt;/code&gt; . 이후 &lt;code&gt;PROG2&lt;/code&gt; 가 중첩되어 &lt;code&gt;PROG1&lt;/code&gt; , 어떤 &lt;code&gt;GLOBAL&lt;/code&gt; 내에서 정의 된 자원 &lt;code&gt;PROG1&lt;/code&gt; 은 로 사용할 수 있습니다 &lt;code&gt;PROG3&lt;/code&gt; 뿐만 아니라.</target>
        </trans-unit>
        <trans-unit id="b4dbebd9bce34e14cf01b533ea8828acf5b44171" translate="yes" xml:space="preserve">
          <source>Similarly, since there is no&lt;code&gt;END PROGRAM&lt;/code&gt;marker separating PROG3 from PROG2, it is possible for PROG3 to access&lt;code&gt;GLOBAL&lt;/code&gt;files and data items defined within PROG2. Since PROG2 is nested within PROG1, any&lt;code&gt;GLOBAL&lt;/code&gt;resources defined within PROG1 will be available to PROG3 as well.</source>
          <target state="translated">마찬가지로 PROG3과 PROG2를 분리하는 &lt;code&gt;END PROGRAM&lt;/code&gt; 마커 가 없으므로 PROG3이 PROG2 내에 정의 된 &lt;code&gt;GLOBAL&lt;/code&gt; 파일과 데이터 항목 에 액세스 할 수 있습니다 . PROG2는 PROG1 내에 중첩되므로 PROG1 내에 정의 된 모든 &lt;code&gt;GLOBAL&lt;/code&gt; 자원을 PROG3에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a2b5c21b86c9349b865faca01a3f8367ffa7f8b" translate="yes" xml:space="preserve">
          <source>Simple GO TO Syntax</source>
          <target state="translated">간단한 GO TO 구문</target>
        </trans-unit>
        <trans-unit id="be95c7b05b0ed152ce1e8a1f2c5cd796b53caee4" translate="yes" xml:space="preserve">
          <source>Simple MOVE Syntax</source>
          <target state="translated">간단한 이동 구문</target>
        </trans-unit>
        <trans-unit id="18126350d3d34e0a9b8ebe73e963984d0c26fd2d" translate="yes" xml:space="preserve">
          <source>Simply Change This&amp;hellip;</source>
          <target state="translated">간단히 변경&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="f761d3cfd1db760e9c0cd6e97ac77721c3b66b92" translate="yes" xml:space="preserve">
          <source>Simply stated, a  &lt;em&gt;Subprogram&lt;/em&gt; is a program that is invoked by another program; the subprogram performs whatever its designed operations are and &amp;mdash; when complete &amp;mdash; typically returns control back to the program that invoked it. There are two different types of subprograms supported by GnuCOBOL, subroutines and user-defined functions. The distinction between these two subprogram types lies in the manner in which they are executed.</source>
          <target state="translated">간단히 말해서 &lt;em&gt;서브 프로그램&lt;/em&gt; 은 다른 프로그램에 의해 호출되는 프로그램입니다. 서브 프로그램은 설계된 작업이 무엇이든 수행하고 (완료되면) 일반적으로이를 호출 한 프로그램에 제어권을 반환합니다. GnuCOBOL, 서브 루틴 및 사용자 정의 함수가 지원하는 두 가지 다른 유형의 서브 프로그램이 있습니다. 이 두 하위 프로그램 유형의 차이점은 실행 방식에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a80baeb12e86a81876a8a769b70e07531ec125d0" translate="yes" xml:space="preserve">
          <source>Simply stated, a &amp;rsquo;</source>
          <target state="translated">간단히 말해서 '</target>
        </trans-unit>
        <trans-unit id="f6287acd20987f4dc314ce910f933c4d6f67c20e" translate="yes" xml:space="preserve">
          <source>Since it is difficult to write any non-trivial COBOL program that uses none of the above, lets assume you will be including at least one section or paragraph in your GnuCOBOL programs.</source>
          <target state="translated">위의 어느 것도 사용하지 않는 사소한 COBOL 프로그램을 작성하는 것은 어렵 기 때문에 GnuCOBOL 프로그램에 하나 이상의 섹션 또는 단락을 포함한다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="c0ccb1f309576bb1671901c92cf01054b24aa9c4" translate="yes" xml:space="preserve">
          <source>Since the C program is planning on making changes to all three arguments, it declares all three as pointers in the function header and references the third argument as a pointer in the function body. It actually had no choice for the two string (char array) arguments &amp;mdash; they must be defined as pointers in the function even though the function code references them without the leading &amp;lsquo;</source>
          <target state="translated">C 프로그램은 세 인수를 모두 변경할 계획이므로 세 인수를 모두 함수 헤더의 포인터로 선언하고 세 번째 인수를 함수 본문의 포인터로 참조합니다. 실제로 두 개의 문자열 (char 배열) 인수에 대한 선택의 여지가 없었습니다. 함수 코드가 선행 '없이 인수를 참조하더라도 함수의 포인터로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="508ea858fa9e3c52de9eb67315c2deb6679294f1" translate="yes" xml:space="preserve">
          <source>Since the C program is planning on making changes to all three arguments, it declares all three as pointers in the function header and references the third argument as a pointer in the function body. It actually had no choice for the two string (char array) arguments &amp;ndash; they must be defined as pointers in the function even though the function code references them without the leading * that normally signifies pointers.</source>
          <target state="translated">C 프로그램은 세 가지 인수 모두를 변경하려고 계획하고 있기 때문에 세 가지 인수를 모두 함수 헤더에서 포인터로 선언하고 세 번째 인수를 함수 본문에서 포인터로 참조합니다. 실제로는 두 개의 문자열 (char 배열) 인수를 선택할 수 없었습니다. &amp;ndash; 함수 코드가 일반적으로 포인터를 나타내는 선행 &quot;*&quot;없이 참조하더라도 함수에서 포인터로 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6dcfa8549e408829c8ef205384c0464a133ff588" translate="yes" xml:space="preserve">
          <source>Since the C program is the one that will execute first, before the GnuCOBOL subroutine, the burden of initializing the GnuCOBOL run-time environment lies with that C program; it will have to invoke the &quot;cob_init&quot; function, which is part of the &quot;libcob&quot; library. The two required C statements are shown highlighted.</source>
          <target state="translated">C 프로그램은 GnuCOBOL 서브 루틴 이전에 먼저 실행될 프로그램이므로 GnuCOBOL 런타임 환경을 초기화하는 부담은 해당 C 프로그램에 있습니다. &quot;libcob&quot;라이브러리의 일부인 &quot;cob_init&quot;함수를 호출해야합니다. 두 개의 필수 C 문이 강조 표시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="311962b15a98e7a97c1bb5ab1df42856bcf02b3b" translate="yes" xml:space="preserve">
          <source>Since the C program is the one that will execute first, before the GnuCOBOL subroutine, the burden of initializing the GnuCOBOL run-time environment lies with that C program; it will have to invoke the &lt;code&gt;cob_init&lt;/code&gt; function, which is part of the &lt;code&gt;libcob&lt;/code&gt; library. The two required C statements are shown highlighted.</source>
          <target state="translated">C 프로그램은 GnuCOBOL 서브 루틴 이전에 먼저 실행되는 프로그램이므로 GnuCOBOL 런타임 환경을 초기화하는 부담은 해당 C 프로그램에 있습니다. &lt;code&gt;libcob&lt;/code&gt; 라이브러리의 일부인 &lt;code&gt;cob_init&lt;/code&gt; 함수 를 호출해야합니다 . 두 개의 필수 C 문이 강조 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="50ed98a3b42bc3e899d745b6442e6b282aa14998" translate="yes" xml:space="preserve">
          <source>Since the C program wants to allow &quot;arg3&quot; to be changed by the subprogram, it prefixes it with a &quot;&amp;amp;&quot; to force a CALL BY REFERENCE for that argument. Since &quot;arg1&quot; and &quot;arg2&quot; are strings (char arrays), they are automatically passed by reference.</source>
          <target state="translated">C 프로그램은 서브 프로그램에 의해 &quot;arg3&quot;이 변경되기를 원하므로, &quot;&amp;amp;&quot;접두어를 붙여 해당 인수에 대해 CALL BY REFERENCE를 강제 실행합니다. &quot;arg1&quot;및 &quot;arg2&quot;는 문자열 (char 배열)이므로 참조로 자동 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8ff936fe7e92cd4258af10a24b4da74f4d408467" translate="yes" xml:space="preserve">
          <source>Since the C program wants to allow &lt;code&gt;arg3&lt;/code&gt; to be changed by the subprogram, it prefixes it with a &amp;lsquo;</source>
          <target state="translated">C 프로그램은 &lt;code&gt;arg3&lt;/code&gt; 이 서브 프로그램에 의해 변경 되도록 허용하기를 원하기 때문에 '</target>
        </trans-unit>
        <trans-unit id="d5e41c0dac5490469dc23a6e8d0593afb7f53584" translate="yes" xml:space="preserve">
          <source>Since the intent of a copybook is to introduce COBOL code into a particular spot in a program via the &lt;code&gt;COPY&lt;/code&gt; statement (see &lt;a href=&quot;#COPY&quot;&gt;COPY&lt;/a&gt;), it is always a good idea to prefix copybook names with a character sequence that identifies where in a program its contents are intended to be &lt;code&gt;COPY&lt;/code&gt;ed.</source>
          <target state="translated">카피 북의 의도는 &lt;code&gt;COPY&lt;/code&gt; 문 ( &lt;a href=&quot;#COPY&quot;&gt;COPY&lt;/a&gt; 참조 )을 통해 프로그램의 특정 지점에 COBOL 코드를 도입하는 것이기 때문에 프로그램에서 내용이있는 위치를 식별하는 문자 시퀀스를 카피 북 이름에 접두사로 붙이는 것이 항상 좋습니다. &lt;code&gt;COPY&lt;/code&gt; 할 예정 입니다.</target>
        </trans-unit>
        <trans-unit id="2f7bab4fc5d71cb794895a09e1ed73766c2e54c7" translate="yes" xml:space="preserve">
          <source>Since the intent of a copybook is to introduce COBOL code into a particular spot in a program via the&lt;code&gt;COPY&lt;/code&gt;statement (see &lt;a href=&quot;#COPY&quot;&gt;COPY&lt;/a&gt;), it is always a good idea to prefix copybook names with a character sequence that identifies where in a program it&amp;rsquo;s contents are intended to be copyed.</source>
          <target state="translated">카피 북의 의도는 &lt;code&gt;COPY&lt;/code&gt; 문을 통해 프로그램의 특정 지점에 COBOL 코드를 도입하는 것이므로 ( &lt;a href=&quot;#COPY&quot;&gt;COPY&lt;/a&gt; 참조 ), 카피 북 이름 앞에 프로그램의 내용이있는 위치를 식별하는 문자 순서를 접두어로 사용하는 것이 좋습니다. 복사하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="01687eba61aa14fc82f0d3d3c96fabe9d23f4a49" translate="yes" xml:space="preserve">
          <source>Since this function has no arguments, no parenthesis should be specified.</source>
          <target state="translated">이 함수에는 인수가 없으므로 괄호를 지정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="555334f6e5b9883111c4b52b66ec442e517593e5" translate="yes" xml:space="preserve">
          <source>Single-item search strings can be specified by coding the &lt;code&gt;&lt;var&gt;identifier-1&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;&lt;var&gt;literal-1&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;&lt;var&gt;word-1&lt;/var&gt;&lt;/code&gt; being replaced.</source>
          <target state="translated">단일 항목 검색 문자열은 대체되는 &lt;code&gt;&lt;var&gt;identifier-1&lt;/var&gt;&lt;/code&gt; , &lt;code&gt;&lt;var&gt;literal-1&lt;/var&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;var&gt;word-1&lt;/var&gt;&lt;/code&gt; 을 코딩하여 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="909cdd47d871721cc7fa46227c59ad8caaa71e90" translate="yes" xml:space="preserve">
          <source>Single-item search strings can be specified by coding the&lt;code&gt;&amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;i&gt;literal-1&lt;/i&gt;&amp;gt;&lt;/code&gt;or&lt;code&gt;&amp;lt;&lt;i&gt;word-1&lt;/i&gt;&amp;gt;&lt;/code&gt;being replaced.</source>
          <target state="translated">대체되는 &lt;code&gt;&amp;lt;&lt;i&gt;identifier-1&lt;/i&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;i&gt;literal-1&lt;/i&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;&lt;i&gt;word-1&lt;/i&gt;&amp;gt;&lt;/code&gt; 을 코딩하여 단일 항목 검색 문자열을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4295e77fa1a8eaec34e91836edb92bba39265cd0" translate="yes" xml:space="preserve">
          <source>Size error exception</source>
          <target state="translated">크기 오류 예외</target>
        </trans-unit>
        <trans-unit id="55ff7b830260495b0240f0046e9e9268b1fb21ad" translate="yes" xml:space="preserve">
          <source>Size of replace item in inspect differs</source>
          <target state="translated">검사에서 교체 품목의 크기가 다릅니다</target>
        </trans-unit>
        <trans-unit id="a4041acbfe1a65f58b7575a3cf0e385ecb143ef3" translate="yes" xml:space="preserve">
          <source>Sleep times less than 1 will be interpreted as 0, which immediately returns control to the calling program without any sleep delay.</source>
          <target state="translated">1보다 작은 수면 시간은 0으로 해석되어 수면 지연없이 즉시 호출 프로그램에 제어권을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="39e6206ac873378c94c8c4690558fd8e350a7737" translate="yes" xml:space="preserve">
          <source>So how then do we inform the compiler that the&lt;code&gt;DISPLAY&lt;/code&gt;statement is outside the scope of the&lt;code&gt;IF&lt;/code&gt;</source>
          <target state="translated">그렇다면 컴파일러에게 &lt;code&gt;DISPLAY&lt;/code&gt; 문이 &lt;code&gt;IF&lt;/code&gt; 의 범위를 벗어 났다 는 것을 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="c39b0db998bb52a914adf20287d42556dbfec542" translate="yes" xml:space="preserve">
          <source>So, GnuCOBOL programmers expecting to pass strings to or receive strings from C programs had best be prepared to deal with the null-termination issue, as follows:</source>
          <target state="translated">따라서 C 프로그램에 문자열을 전달하거나 C 프로그램에서 문자열을 수신 할 것으로 예상되는 GnuCOBOL 프로그래머는 다음과 같이 널 종료 문제를 처리 할 수있는 최선의 준비를 갖추 었습니다.</target>
        </trans-unit>
        <trans-unit id="4c02e57130c8f0ffde209d228a9499b7d42235d8" translate="yes" xml:space="preserve">
          <source>So, assuming a sort file has been defined and it&amp;rsquo;s record layout (essentially a mirror of the raw data file) is defined as follows:</source>
          <target state="translated">따라서 정렬 파일이 정의되었고 레코드 레이아웃 (실제로 원시 데이터 파일의 미러)이 다음과 같이 정의되었다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f8709b5425243b80ec96d59bf8ff19078d815e1c" translate="yes" xml:space="preserve">
          <source>So, assuming a sort file has been defined and its record layout (essentially a mirror of the raw data file) is defined as follows:</source>
          <target state="translated">따라서 정렬 파일이 정의되고 레코드 레이아웃 (기본적으로 원시 데이터 파일의 미러)이 다음과 같이 정의되었다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="7a46fafc141a2555ad25145a52a1e94cf613e5cf" translate="yes" xml:space="preserve">
          <source>So, if a file contains 1275 characters of data, and a program defines the structure of that file as containing 100-character records, then the file contents will consist of twelve (12) 100-character records with a final record containing only 75 characters.</source>
          <target state="translated">따라서 파일에 1275 자의 데이터가 포함되어 있고 프로그램이 해당 파일의 구조를 100 자 레코드를 포함하는 것으로 정의하면 파일 내용은 최종 문자가 75자인 12 개의 100 자 레코드로 구성됩니다. .</target>
        </trans-unit>
        <trans-unit id="18d5fdae2f1b64cdbabb3e4ace710843106e2c78" translate="yes" xml:space="preserve">
          <source>So, the definition of these data items in a GnuCOBOL program would go something like this:</source>
          <target state="translated">따라서 GnuCOBOL 프로그램에서 이러한 데이터 항목의 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8aef6726a7909be993cbbbb1b3eb0d562e7ce887" translate="yes" xml:space="preserve">
          <source>Some COBOL implementations disallow the use of group items or &lt;code&gt;PIC A&lt;/code&gt; items with &lt;code&gt;NUMERIC&lt;/code&gt; class conditions and the use of &lt;code&gt;PIC 9&lt;/code&gt; items with &lt;code&gt;ALPHABETIC&lt;/code&gt; class conditions. GnuCOBOL has no such restrictions.</source>
          <target state="translated">일부 COBOL 구현 은 &lt;code&gt;NUMERIC&lt;/code&gt; 클래스 조건 이있는 그룹 항목 또는 &lt;code&gt;PIC A&lt;/code&gt; 항목 의 사용 과 &lt;code&gt;ALPHABETIC&lt;/code&gt; 클래스 조건 이있는 &lt;code&gt;PIC 9&lt;/code&gt; 항목 의 사용을 허용하지 않습니다 . GnuCOBOL에는 그러한 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ea50cf6b9b69104f7a42a089305b29d51c4c5501" translate="yes" xml:space="preserve">
          <source>Some COBOL implementations disallow the use of group items or&lt;code&gt;PIC A&lt;/code&gt;items with&lt;code&gt;NUMERIC&lt;/code&gt;class conditions and the use of&lt;code&gt;PIC 9&lt;/code&gt;items with&lt;code&gt;ALPHABETIC&lt;/code&gt;class conditions. GnuCOBOL has no such restrictions.</source>
          <target state="translated">일부 COBOL 구현 에서는 &lt;code&gt;NUMERIC&lt;/code&gt; 클래스 조건 이있는 그룹 항목 또는 &lt;code&gt;PIC A&lt;/code&gt; 항목과 &lt;code&gt;ALPHABETIC&lt;/code&gt; 클래스 조건 이있는 &lt;code&gt;PIC 9&lt;/code&gt; 항목을 사용할 수 없습니다 . GnuCOBOL에는 그러한 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e4225172aabb92fa6a43677763853e5011b635e6" translate="yes" xml:space="preserve">
          <source>Some COBOL implementations provide this optional clause to force their sort and merge facilities to retain duplicate key-value records in their original input sequence, relative to one another.</source>
          <target state="translated">일부 COBOL 구현은이 선택적 절을 제공하여 정렬 및 병합 기능이 중복 키-값 레코드를 원래 입력 순서대로 서로 유지하도록합니다.</target>
        </trans-unit>
        <trans-unit id="3bd0bbd233792c7dfd9e82425698ec005de32876" translate="yes" xml:space="preserve">
          <source>Some COBOL shops prefer to use the eight-character Program Name Area (columns 73-80) as a change code area.</source>
          <target state="translated">일부 COBOL 상점은 8 자 프로그램 이름 영역 (73-80 열)을 변경 코드 영역으로 사용하는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="ea090b365fe10df2f74f8fb7841c2b481451fba0" translate="yes" xml:space="preserve">
          <source>Some COBOL statements (&lt;code&gt;SEARCH&lt;/code&gt; (see &lt;a href=&quot;#SEARCH&quot;&gt;SEARCH&lt;/a&gt;), &lt;code&gt;SEARCH ALL&lt;/code&gt; (see &lt;a href=&quot;#SEARCH-ALL&quot;&gt;SEARCH ALL&lt;/a&gt;) and the table-based &lt;code&gt;SORT&lt;/code&gt; (see &lt;a href=&quot;#Table-SORT&quot;&gt;Table SORT&lt;/a&gt;)) require you to index the affected table and to utilize that index with those statements. With any other references to tables, the choice is left to the programmer as to which approach should be used. In general, follow these rules:</source>
          <target state="translated">일부 COBOL 문 ( &lt;code&gt;SEARCH&lt;/code&gt; 합니다 ( &lt;a href=&quot;#SEARCH&quot;&gt;검색하기&lt;/a&gt; ), &lt;code&gt;SEARCH ALL&lt;/code&gt; (참조 &lt;a href=&quot;#SEARCH-ALL&quot;&gt;검색 ALL&lt;/a&gt; )과 테이블 기반 &lt;code&gt;SORT&lt;/code&gt; (참조 &lt;a href=&quot;#Table-SORT&quot;&gt;표를 정렬이&lt;/a&gt; 지수에 영향을받는 테이블을 필요로 그 문에 해당 인덱스를 활용하는)). 테이블에 대한 다른 참조의 경우 어떤 접근 방식을 사용해야하는지에 대한 선택은 프로그래머에게 있습니다. 일반적으로 다음 규칙을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="fd3ce505aa8be30003a54074dddef831cb8ca66c" translate="yes" xml:space="preserve">
          <source>Some COBOL statements &lt;code&gt;SEARCH&lt;/code&gt;(see &lt;a href=&quot;#SEARCH&quot;&gt;SEARCH&lt;/a&gt;),&lt;code&gt;SEARCH ALL&lt;/code&gt;(see &lt;a href=&quot;#SEARCH-ALL&quot;&gt;SEARCH ALL&lt;/a&gt;) and the table-based&lt;code&gt;SORT&lt;/code&gt;(see &lt;a href=&quot;#Table-SORT&quot;&gt;Table SORT&lt;/a&gt;)) require you to index the affected table and to utilize that index with those statements. With any other references to tables, the choice is left to the programmer as to which approach should be used. In general, follow these rules:</source>
          <target state="translated">일부 COBOL 문을 &lt;code&gt;SEARCH&lt;/code&gt; 합니다 ( &lt;a href=&quot;#SEARCH&quot;&gt;검색하기&lt;/a&gt; ), &lt;code&gt;SEARCH ALL&lt;/code&gt; (참조 &lt;a href=&quot;#SEARCH-ALL&quot;&gt;검색 ALL을&lt;/a&gt; ) 테이블 기반의 &lt;code&gt;SORT&lt;/code&gt; (참조 &lt;a href=&quot;#Table-SORT&quot;&gt;표 정렬&lt;/a&gt; )) 지수에 영향을받는 테이블을 필요로 그 문에 그 인덱스를 사용 할 수 있습니다. 테이블에 대한 다른 참조와 함께, 어떤 접근법을 사용해야하는지 프로그래머가 선택할 수 있습니다. 일반적으로 다음 규칙을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="5b22dce4738b4f157ef592f9314c98adc75d5f43" translate="yes" xml:space="preserve">
          <source>Some COBOL statements have a</source>
          <target state="translated">일부 COBOL 문에는</target>
        </trans-unit>
        <trans-unit id="fb0c0f69dc4186cb9681a9a690539b79e8d8f41b" translate="yes" xml:space="preserve">
          <source>Some COBOL statements have a &quot;scope of applicability&quot; associated with them where one or more other statements can be considered to be part of or related to the statement in question. An example of such a situation might be the following, where the interest on a loan is being calculated and displayed &amp;mdash; 4% interest if the loan balance is under $10000 and 4.5% otherwise (WARNING &amp;ndash; the following code has an error!):</source>
          <target state="translated">일부 COBOL 문에는 하나 이상의 다른 명령문이 해당 명령문의 일부 또는 관련이있는 것으로 간주 될 수있는 &quot;적용 범위&quot;가 있습니다. 이러한 상황의 예는 다음과 같습니다. 대출 잔액이 $ 10000 미만인 경우 4 %, 그렇지 않으면 4.5 % 인 경우 대출에 대한이자를 계산하여 표시합니다 (경고 &amp;ndash; 다음 코드에 오류가 있습니다!).</target>
        </trans-unit>
        <trans-unit id="3073aa8624bbdd57793c5724e51d18d4e3c40b8b" translate="yes" xml:space="preserve">
          <source>Some CPUs &amp;mdash; such as the Intel/AMD i386/x64 architecture processors used in most Windows PCs &amp;mdash; prefer to process binary data stored in a little-endian format. Since that format is more efficient on those systems, it is referred to as the</source>
          <target state="translated">대부분의 Windows PC에서 사용되는 Intel / AMD i386 / x64 아키텍처 프로세서와 같은 일부 CPU는 little-endian 형식으로 저장된 바이너리 데이터를 처리하는 것을 선호합니다. 이 형식은 이러한 시스템에서 더 효율적이기 때문에</target>
        </trans-unit>
        <trans-unit id="9df4c4d5334a475fece7d66e11d3c3ddac824f97" translate="yes" xml:space="preserve">
          <source>Some CPUs  such as the Intel/AMD i386/x64 architecture processors used in most Windows PCs  prefer to process binary data stored in a little-endian format. Since that format is more efficient on those systems, it is referred to as the&lt;code&gt;native&lt;/code&gt;binary format.</source>
          <target state="translated">대부분의 Windows PC에서 사용되는 Intel / AMD i386 / x64 아키텍처 프로세서와 같은 일부 CPU는 리틀 엔디안 형식으로 저장된 이진 데이터를 처리하는 것을 선호합니다. 해당 시스템에서 해당 형식이 더 효율적이므로 &lt;code&gt;native&lt;/code&gt; 이진 형식 이라고 합니다.</target>
        </trans-unit>
        <trans-unit id="38550f9056e86e4d797738185be0b86af3597727" translate="yes" xml:space="preserve">
          <source>Some may prefer to compile their GnuCOBOL main programs into these dynamically-loadable modules in the interests of using the same general compilation command for all programs without having to think &quot;Is it a main program or a subprogram?&quot;.</source>
          <target state="translated">어떤 사람들은 &quot;메인 프로그램 또는 서브 프로그램입니까?&quot;라고 생각하지 않고 모든 프로그램에 대해 동일한 일반 컴파일 명령을 사용하기 위해 GnuCOBOL 메인 프로그램을 이러한 동적으로로드 가능한 모듈로 컴파일하는 것을 선호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f096c98e643d6f5d47f6aa7bcecb17cc7792ce37" translate="yes" xml:space="preserve">
          <source>Some may prefer to compile their GnuCOBOL main programs into these dynamically-loadable modules in the interests of using the same general compilation command for all programs without having to think &amp;ldquo;Is it a main program or a subprogram?&amp;rdquo;.</source>
          <target state="translated">어떤 사람들은 GnuCOBOL 메인 프로그램을 동적으로로드 할 수있는 모듈로 컴파일하는 것을 선호 할 수 있습니다. &quot;메인 프로그램인가요 아니면 서브 프로그램인가요?&quot;라고 생각할 필요없이 모든 프로그램에 대해 동일한 일반 컴파일 명령을 사용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="5a1fb85663d128d59abcf9635115d32fc5c135b3" translate="yes" xml:space="preserve">
          <source>Some of the original call-by-number routines never evolved call-by-name equivalents; GnuCOBOL supports some of these routines.</source>
          <target state="translated">원래의 전화 번호순 루틴 중 일부는 이름 별 전화 번호로 진화하지 않았습니다. GnuCOBOL은 이러한 루틴 중 일부를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d9a38b51a9ed8d9aa72530a6f73c2e911f49b3d5" translate="yes" xml:space="preserve">
          <source>Sometimes the quest for improved programmer productivity (and therefore reduced programming</source>
          <target state="translated">프로그래머의 생산성 향상 (따라서 프로그래밍 감소)에 대한 추구</target>
        </trans-unit>
        <trans-unit id="5b72a236d81d3118037bf4abca92414a93e598e5" translate="yes" xml:space="preserve">
          <source>Sort/merge work files should be assigned to &lt;code&gt;DISK&lt;/code&gt; (or &lt;code&gt;DISC&lt;/code&gt;) on their &lt;code&gt;SELECT&lt;/code&gt; statements.</source>
          <target state="translated">정렬 / 병합 작업 파일은 &lt;code&gt;SELECT&lt;/code&gt; 문 에서 &lt;code&gt;DISK&lt;/code&gt; (또는 &lt;code&gt;DISC&lt;/code&gt; )에 할당되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3ce8ecca6ac372b2671a4b175cfc95f43e37cda4" translate="yes" xml:space="preserve">
          <source>Sort/merge work files should be assigned to&lt;code&gt;DISK&lt;/code&gt;(or&lt;code&gt;DISC&lt;/code&gt; on their&lt;code&gt;SELECT&lt;/code&gt;statements.</source>
          <target state="translated">정렬 / 병합 작업 파일은 &lt;code&gt;DISK&lt;/code&gt; (또는 &lt;code&gt;SELECT&lt;/code&gt; 문 에서 &lt;code&gt;DISC&lt;/code&gt; ) 에 지정되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="181cdd056b8d00c3943fec61de5bb0e8654421f5" translate="yes" xml:space="preserve">
          <source>Sorts and merges will be performed in memory, if the amount of data being sorted allows.</source>
          <target state="translated">정렬중인 데이터의 양이 허용하는 경우 정렬 및 병합이 메모리에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="489383c4ee164ec5ed5cea2619852156b1d2a469" translate="yes" xml:space="preserve">
          <source>Source Mode &amp;mdash; Description</source>
          <target state="translated">소스 모드 &amp;mdash; 설명</target>
        </trans-unit>
        <trans-unit id="9e13332d21eba49e8089bdc8abaea2f5ea8ebf3d" translate="yes" xml:space="preserve">
          <source>Spaces cannot be included in primary entry-point names and therefore should not be included in program file names.</source>
          <target state="translated">공백은 기본 진입 점 이름에 포함될 수 없으므로 프로그램 파일 이름에 포함해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="ed55e29dafc932b11e4821a2bb2579422ef1545b" translate="yes" xml:space="preserve">
          <source>Special Registers</source>
          <target state="translated">Special Registers</target>
        </trans-unit>
        <trans-unit id="b475069bb5d03f66e3620c012d1dc9b060e18337" translate="yes" xml:space="preserve">
          <source>Special data items that are automatically defined for your use by the GnuCOBOL compiler. See &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;, for a complete list.</source>
          <target state="translated">Special data items that are automatically defined for your use by the GnuCOBOL compiler. See &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;, for a complete list.</target>
        </trans-unit>
        <trans-unit id="92f4028fdf3721f3d46dcb7d44bdba4b099e1ade" translate="yes" xml:space="preserve">
          <source>Specification of an &lt;code&gt;INVALID KEY&lt;/code&gt; clause will allow your program to trap an I/O failure condition (with an I/O error code in the file&amp;rsquo;s &lt;code&gt;FILE-STATUS&lt;/code&gt; (see &lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt;) field) that has occurred due to a record-not-found condition and handle it gracefully by executing &lt;var&gt;imperative-statement-1&lt;/var&gt; (see &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt;).</source>
          <target state="translated">의 사양 &lt;code&gt;INVALID KEY&lt;/code&gt; 의 절은 함정에 I / O 오류 조건 프로그램을 수 있습니다 (파일의에 I / O 오류 코드와 &lt;code&gt;FILE-STATUS&lt;/code&gt; (참조 &lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt; 인해 기록-없는 상태로 발생하는) 필드) 그리고 &lt;var&gt;imperative-statement-1&lt;/var&gt; 을 실행하여 우아하게 처리합니다 ( &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="951ca5a73616e8583d8c3f86ed17472460bfdc27" translate="yes" xml:space="preserve">
          <source>Specification of an exception clause will allow your program to trap a failure condition that has occurred and handle it gracefully by executing &amp;lt;</source>
          <target state="translated">Specification of an exception clause will allow your program to trap a failure condition that has occurred and handle it gracefully by executing &amp;lt;</target>
        </trans-unit>
        <trans-unit id="177449fe06bee4a9812ed9f138b15c62b238ba3c" translate="yes" xml:space="preserve">
          <source>Specification of an exception clause will allow your program to trap a failure condition that has occurred and handle it gracefully by executing &lt;var&gt;imperative-statement-1&lt;/var&gt; (see &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt;). If such a condition occurs at runtime without having one of these clauses specified, an error message will be generated (by the GnuCOBOL runtime library) to the &lt;code&gt;SYSERR&lt;/code&gt; device (pipe 2). The program may also be terminated, depending upon the type and severity of the error.</source>
          <target state="translated">예외 절을 지정하면 프로그램이 발생한 실패 조건을 포착하고 &lt;var&gt;imperative-statement-1&lt;/var&gt; 을 실행하여이를 적절하게 처리 할 수 있습니다 ( &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt; 참조 ). 이러한 조건이 이러한 절 중 하나를 지정하지 않고 런타임에 발생하면 &lt;code&gt;SYSERR&lt;/code&gt; 장치 (파이프 2)에 오류 메시지가 생성됩니다 (GnuCOBOL 런타임 라이브러리에 의해 ). 오류의 유형과 심각도에 따라 프로그램이 종료 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ff4b0f98e4425a1d9af2c678aab3288763e69ca" translate="yes" xml:space="preserve">
          <source>Specification of an&lt;code&gt;INVALID KEY&lt;/code&gt;clause will allow your program to trap an I/O failure condition (with an I/O error code in the file&amp;rsquo;s&lt;code&gt;FILE-STATUS&lt;/code&gt;(see &lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt;) field) that has occurred due to a record-not-found condition and handle it gracefully by executing &amp;lt;</source>
          <target state="translated">Specification of an &lt;code&gt;INVALID KEY&lt;/code&gt; clause will allow your program to trap an I/O failure condition (with an I/O error code in the file&amp;rsquo;s &lt;code&gt;FILE-STATUS&lt;/code&gt; (see &lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt;) field) that has occurred due to a record-not-found condition and handle it gracefully by executing &amp;lt;</target>
        </trans-unit>
        <trans-unit id="8bd45cf9f886c436a484da6198a1bc68ce48be1e" translate="yes" xml:space="preserve">
          <source>Specifying a &lt;code&gt;LINAGE&lt;/code&gt; clause in an &lt;code&gt;FD&lt;/code&gt; will cause the   &lt;code&gt;LINAGE-COUNTER&lt;/code&gt; special register to be created for the file. This automatically-created data item will always contain the current relative line number on the page being prepared which will serve as the starting point for a &lt;code&gt;WRITE&lt;/code&gt; statement.</source>
          <target state="translated">&lt;code&gt;FD&lt;/code&gt; 에 &lt;code&gt;LINAGE&lt;/code&gt; 절을 지정 하면 &lt;code&gt;LINAGE-COUNTER&lt;/code&gt; 특수 레지스터가 파일에 대해 작성됩니다. 이 자동 생성 데이터 항목은 항상 준비중인 페이지의 현재 상대 행 번호를 포함하며 &lt;code&gt;WRITE&lt;/code&gt; 문의 시작점으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3c9191817281588c815a068ade17b41d296154b" translate="yes" xml:space="preserve">
          <source>Specifying a&lt;code&gt;LINAGE&lt;/code&gt;clause in an&lt;code&gt;FD&lt;/code&gt;will cause the&lt;code&gt;LINAGE-COUNTER&lt;/code&gt;special register to be created for the file. This automatically-created data item will always contain the current relative line number on the page being prepared which will serve as the starting point for a&lt;code&gt;WRITE&lt;/code&gt;statement.</source>
          <target state="translated">Specifying a &lt;code&gt;LINAGE&lt;/code&gt; clause in an &lt;code&gt;FD&lt;/code&gt; will cause the &lt;code&gt;LINAGE-COUNTER&lt;/code&gt; special register to be created for the file. This automatically-created data item will always contain the current relative line number on the page being prepared which will serve as the starting point for a &lt;code&gt;WRITE&lt;/code&gt; statement.</target>
        </trans-unit>
        <trans-unit id="3fb12382997025a330688fcc8fa6bba9e89dc5fb" translate="yes" xml:space="preserve">
          <source>Square bracket meta characters on syntax diagrams document language syntax that is optional. The [] characters themselves should not be coded. If a syntax diagram contains &quot;a [b] c&quot;, the &quot;a&quot; and &quot;c&quot; syntax elements are mandatory but the &quot;b&quot; element is optional.</source>
          <target state="translated">Square bracket meta characters on syntax diagrams document language syntax that is optional. The [] characters themselves should not be coded. If a syntax diagram contains &quot;a [b] c&quot;, the &quot;a&quot; and &quot;c&quot; syntax elements are mandatory but the &quot;b&quot; element is optional.</target>
        </trans-unit>
        <trans-unit id="1760705430d27e319ba6ad1b31fabee6130ae944" translate="yes" xml:space="preserve">
          <source>Square bracket meta characters on syntax diagrams document language syntax that is optional. The [] characters themselves should not be coded. If a syntax diagram contains &amp;lsquo;</source>
          <target state="translated">구문 다이어그램의 대괄호 메타 문자는 선택적인 언어 구문을 문서화합니다. [] 문자 자체는 코딩되지 않아야합니다. 구문 다이어그램에 '</target>
        </trans-unit>
        <trans-unit id="89ccdc56e323f98c63656e35f5fbaa819e99b2e2" translate="yes" xml:space="preserve">
          <source>Start everything defined in local-storage with &quot;LS-&quot;</source>
          <target state="translated">Start everything defined in local-storage with &quot;LS-&quot;</target>
        </trans-unit>
        <trans-unit id="eb2bb9b0f5e185045973928cc73818887e8ed610" translate="yes" xml:space="preserve">
          <source>Start everything defined in local-storage with &amp;ldquo;LS-&amp;rdquo;</source>
          <target state="translated">로컬 스토리지에 정의 된 모든 것을 &quot;LS-&quot;로 시작</target>
        </trans-unit>
        <trans-unit id="e1a334460a50c63866143c2bcb289cda69f1521d" translate="yes" xml:space="preserve">
          <source>Start everything defined in the file section with &quot;F-&quot;</source>
          <target state="translated">Start everything defined in the file section with &quot;F-&quot;</target>
        </trans-unit>
        <trans-unit id="f89ba21e5b311d4563e58bd6b3089cd1f7f18c91" translate="yes" xml:space="preserve">
          <source>Start everything defined in the file section with &amp;ldquo;F-&amp;rdquo;</source>
          <target state="translated">파일 섹션에 정의 된 모든 것을 &quot;F-&quot;로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="9cec1a7d3c5f2c2947b6d1e7fa5c83fd8313a211" translate="yes" xml:space="preserve">
          <source>Start everything defined in the linkage section with &quot;L-&quot;</source>
          <target state="translated">Start everything defined in the linkage section with &quot;L-&quot;</target>
        </trans-unit>
        <trans-unit id="a7a282b75e5f1cfaee41900afa26fe67aa4721b6" translate="yes" xml:space="preserve">
          <source>Start everything defined in the linkage section with &amp;ldquo;L-&amp;rdquo;</source>
          <target state="translated">연결 섹션에 정의 된 모든 것을 &quot;L-&quot;로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="edfb566db3b78c59979e9964596bd66f65e73213" translate="yes" xml:space="preserve">
          <source>Start everything defined in the report section with &quot;R-&quot;</source>
          <target state="translated">Start everything defined in the report section with &quot;R-&quot;</target>
        </trans-unit>
        <trans-unit id="23a2552238b65ee12efa041994dbcd6d117578aa" translate="yes" xml:space="preserve">
          <source>Start everything defined in the report section with &amp;ldquo;R-&amp;rdquo;</source>
          <target state="translated">보고서 섹션에 정의 된 모든 것을 &quot;R-&quot;로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="7d6cae6dd514bccc9d72546b58cffd5203aaf53d" translate="yes" xml:space="preserve">
          <source>Start everything defined in the screen section with &quot;S-&quot;</source>
          <target state="translated">Start everything defined in the screen section with &quot;S-&quot;</target>
        </trans-unit>
        <trans-unit id="c5e38a75b0fe059989ef5fa2a558e5988f260f95" translate="yes" xml:space="preserve">
          <source>Start everything defined in the screen section with &amp;ldquo;S-&amp;rdquo;</source>
          <target state="translated">화면 섹션에 정의 된 모든 것을 &quot;S-&quot;로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d794a0ab7bd5ca758c77608d1a7e4499d174230f" translate="yes" xml:space="preserve">
          <source>Start everything defined in working-storage with &quot;WS-&quot;</source>
          <target state="translated">Start everything defined in working-storage with &quot;WS-&quot;</target>
        </trans-unit>
        <trans-unit id="e07339729515c7e21f635c496a81b068f686f3f8" translate="yes" xml:space="preserve">
          <source>Start everything defined in working-storage with &amp;ldquo;WS-&amp;rdquo;</source>
          <target state="translated">&quot;WS-&quot;로 작업 스토리지에 정의 된 모든 것을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="a72ca256dc49e55a1a57b9a727fbde9834c9a3f7" translate="yes" xml:space="preserve">
          <source>Statement</source>
          <target state="translated">Statement</target>
        </trans-unit>
        <trans-unit id="c39d2034c8d11d82a7a2a3f44c3ed8b06f3647b5" translate="yes" xml:space="preserve">
          <source>Static Subprogram</source>
          <target state="translated">Static Subprogram</target>
        </trans-unit>
        <trans-unit id="a9ae3455ed4d77cffa9454ba5d34b0442c69f348" translate="yes" xml:space="preserve">
          <source>Static-linkable form</source>
          <target state="translated">Static-linkable form</target>
        </trans-unit>
        <trans-unit id="3eefe19a6db5e7e71ce7dfa1947d7ac7029d849b" translate="yes" xml:space="preserve">
          <source>Sticky linkage (linkage section items remaining allocated between invocations) is</source>
          <target state="translated">고정 연결 (호출간에 할당 된 나머지 연결 섹션 항목)은</target>
        </trans-unit>
        <trans-unit id="2a77d3a28d7db638022aca2fc47d8d3cc7cd350f" translate="yes" xml:space="preserve">
          <source>Sticky linkage (linkage section items remaining allocated between invocations) is active.</source>
          <target state="translated">고정 연결 (호출간에 할당 된 나머지 연결 섹션 항목)이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="97674125b37eaddcf0087ccb755f7533a5c89a44" translate="yes" xml:space="preserve">
          <source>Sticky-linkage (linkage-section items remaining allocated between invocations) is enabled.</source>
          <target state="translated">고정 연결 (호출간에 할당 된 나머지 연결 섹션 항목)이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="ff062f96dc1df91e5c796406182c7ddc394a5e00" translate="yes" xml:space="preserve">
          <source>Sticky-linkage (linkage-section items remaining allocated between invocations) is not enabled.</source>
          <target state="translated">고정 연결 (호출 사이에 할당 된 나머지 연결 섹션 항목)은 활성화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dfcef9f75eb7dd61beea9259f4e7c9e8945c543c" translate="yes" xml:space="preserve">
          <source>Storage Format:</source>
          <target state="translated">Storage Format:</target>
        </trans-unit>
        <trans-unit id="42f036f0002bc8f4898250e0d9f2151320e13a16" translate="yes" xml:space="preserve">
          <source>String-Clause</source>
          <target state="translated">String-Clause</target>
        </trans-unit>
        <trans-unit id="610e80bb94900da3f5e97068e213f2ca2b1715df" translate="yes" xml:space="preserve">
          <source>Strings enclosed in double-quote characters (&quot;) will be treated as a single argument, regardless of how many spaces or tab characters (if any) might be embedded within those quotation characters.</source>
          <target state="translated">Strings enclosed in double-quote characters (&quot;) will be treated as a single argument, regardless of how many spaces or tab characters (if any) might be embedded within those quotation characters.</target>
        </trans-unit>
        <trans-unit id="fa14d8f1591eda6c75bbb98390478141cd78f1ac" translate="yes" xml:space="preserve">
          <source>Strings enclosed in double-quote characters (&amp;lsquo;</source>
          <target state="translated">큰 따옴표 문자 ( '</target>
        </trans-unit>
        <trans-unit id="8ea2553a31b788157b73395943c919cc222d5603" translate="yes" xml:space="preserve">
          <source>Submitting a command to the shell environment appropriate for the version of GnuCOBOL you are using for execution</source>
          <target state="translated">Submitting a command to the shell environment appropriate for the version of GnuCOBOL you are using for execution</target>
        </trans-unit>
        <trans-unit id="202a02ec26bf87caf0fe72d9cf37185be4172ca5" translate="yes" xml:space="preserve">
          <source>Subprogram</source>
          <target state="translated">Subprogram</target>
        </trans-unit>
        <trans-unit id="52ebf9910454677c51e370d3c50ad494b952c8c3" translate="yes" xml:space="preserve">
          <source>Subprogram &quot;B&quot; may be nested inside program &quot;A&quot; by including program B&amp;rsquo;s source code at the end of program A&amp;rsquo;s procedure division without an intervening&lt;code&gt;END PROGRAM A.&lt;/code&gt;or&lt;code&gt;END FUNCTION A.&lt;/code&gt;statement. For now, that&amp;rsquo;s all that will be said about nesting. See &lt;a href=&quot;#Independent-vs-Contained-vs-Nested-Subprograms&quot;&gt;Independent vs Contained vs Nested Subprograms&lt;/a&gt;, for more information.</source>
          <target state="translated">Subprogram &quot;B&quot; may be nested inside program &quot;A&quot; by including program B&amp;rsquo;s source code at the end of program A&amp;rsquo;s procedure division without an intervening &lt;code&gt;END PROGRAM A.&lt;/code&gt; or &lt;code&gt;END FUNCTION A.&lt;/code&gt; statement. For now, that&amp;rsquo;s all that will be said about nesting. See &lt;a href=&quot;#Independent-vs-Contained-vs-Nested-Subprograms&quot;&gt;Independent vs Contained vs Nested Subprograms&lt;/a&gt;, for more information.</target>
        </trans-unit>
        <trans-unit id="58799dc91346da4c88256bfcfeab27e814162185" translate="yes" xml:space="preserve">
          <source>Subprogram &amp;lsquo;</source>
          <target state="translated">서브 프로그램 '</target>
        </trans-unit>
        <trans-unit id="5f041b3b26073b44aaedd78af7207b2cb692fa21" translate="yes" xml:space="preserve">
          <source>Subprograms (either subroutines or user-defined functions) can be implemented in three different ways.</source>
          <target state="translated">Subprograms (either subroutines or user-defined functions) can be implemented in three different ways.</target>
        </trans-unit>
        <trans-unit id="d1889bba143969c108d68eb72184e742c5e04cfb" translate="yes" xml:space="preserve">
          <source>Subroutine</source>
          <target state="translated">Subroutine</target>
        </trans-unit>
        <trans-unit id="58802942db0b555fec26b47d260b0bbf15c56086" translate="yes" xml:space="preserve">
          <source>Subscript out of bounds</source>
          <target state="translated">Subscript out of bounds</target>
        </trans-unit>
        <trans-unit id="76b0f8f5e3eafb5efd52e8814f9a8a2f7acebe13" translate="yes" xml:space="preserve">
          <source>Subscripting</source>
          <target state="translated">Subscripting</target>
        </trans-unit>
        <trans-unit id="3523493d2845761109c102ef91fdabfa8f15f8f9" translate="yes" xml:space="preserve">
          <source>Subscripting is the process of referencing an element of a table utilizing either a numeric constant or an unedited numeric data item to select the desired occurrence.</source>
          <target state="translated">Subscripting is the process of referencing an element of a table utilizing either a numeric constant or an unedited numeric data item to select the desired occurrence.</target>
        </trans-unit>
        <trans-unit id="2e620482345468100545d7d9e9b05c0300a4d844" translate="yes" xml:space="preserve">
          <source>Subscripts may be specified as numeric (integer) literals, numeric (integer) data items, data items created with any of the picture-less integer &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) specifications, &lt;code&gt;USAGE INDEX&lt;/code&gt; data items or arithmetic expressions resulting in a non-zero integer value.</source>
          <target state="translated">첨자는 숫자 (정수) 리터럴, 숫자 (정수) 데이터 항목, 그림없는 정수 &lt;code&gt;USAGE&lt;/code&gt; ( &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt; 참조 ) 사양 중 하나로 생성 된 데이터 항목 , &lt;code&gt;USAGE INDEX&lt;/code&gt; 데이터 항목 또는 0이 아닌 정수를 생성하는 산술 표현식으로 지정 될 수 있습니다. 값.</target>
        </trans-unit>
        <trans-unit id="58cafd262f4d9e094951b7c057b4cad08ca57a0d" translate="yes" xml:space="preserve">
          <source>Subscripts may be specified as numeric (integer) literals, numeric (integer) data items, data items created with any of the picture-less integer&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) specifications,&lt;code&gt;USAGE INDEX&lt;/code&gt;data items or arithmetic expressions resulting in a non-zero integer value.</source>
          <target state="translated">Subscripts may be specified as numeric (integer) literals, numeric (integer) data items, data items created with any of the picture-less integer &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) specifications, &lt;code&gt;USAGE INDEX&lt;/code&gt; data items or arithmetic expressions resulting in a non-zero integer value.</target>
        </trans-unit>
        <trans-unit id="994fca5573aaaa88d93ab58a580aceb006b894f4" translate="yes" xml:space="preserve">
          <source>Substitution of a single sub string with another of the same length, based upon the sub strings starting character position and length</source>
          <target state="translated">문자 위치 및 길이를 시작하는 하위 문자열을 기반으로 단일 하위 문자열을 동일한 길이의 다른 문자열로 대체</target>
        </trans-unit>
        <trans-unit id="f19bc61f20fe57f3b1d4460524593042ed8c7b0e" translate="yes" xml:space="preserve">
          <source>Substitution of one or more sub strings in a string with replacement sub strings of a potentially different length, regardless of where they occur</source>
          <target state="translated">문자열에서 하나 이상의 하위 문자열을 발생 위치에 관계없이 잠재적으로 다른 길이의 대체 하위 문자열로 대체</target>
        </trans-unit>
        <trans-unit id="16bec54817327721d3632d9305434a023b13b1c9" translate="yes" xml:space="preserve">
          <source>Substitution of one or more sub strings in a string with replacement sub strings of the same length, regardless of where they occur</source>
          <target state="translated">문자열에서 하나 이상의 하위 문자열을 발생 위치에 관계없이 동일한 길이의 대체 하위 문자열로 대체</target>
        </trans-unit>
        <trans-unit id="42a8f651d79fd005eeac0612df6442b983a01184" translate="yes" xml:space="preserve">
          <source>Success</source>
          <target state="translated">Success</target>
        </trans-unit>
        <trans-unit id="95c1cefa2242449ff0c6e9b76518e25b94853944" translate="yes" xml:space="preserve">
          <source>Success (Duplicate Record Key Written)</source>
          <target state="translated">Success (Duplicate Record Key Written)</target>
        </trans-unit>
        <trans-unit id="2bae8593493faa95fc274d56fb0f56d1074f19a4" translate="yes" xml:space="preserve">
          <source>Success (Incomplete)</source>
          <target state="translated">성공 (불완전)</target>
        </trans-unit>
        <trans-unit id="66c27e800ef6815ddb5314c0883d6b619fc07bfb" translate="yes" xml:space="preserve">
          <source>Success (No Unit)</source>
          <target state="translated">Success (No Unit)</target>
        </trans-unit>
        <trans-unit id="7843628755fdcace8f2c62d0842df66017b6258a" translate="yes" xml:space="preserve">
          <source>Success (Optional File Not Found)</source>
          <target state="translated">Success (Optional File Not Found)</target>
        </trans-unit>
        <trans-unit id="33153a6b2063a39aab251bbc86628e7422e22418" translate="yes" xml:space="preserve">
          <source>Suggestion: use a copybook to describe the record layouts of any file; this guarantees that multiple programs accessing that file will &quot;see&quot; the same record sizes and layouts by coding a&lt;code&gt;COPY&lt;/code&gt;statement (see &lt;a href=&quot;#COPY&quot;&gt;COPY&lt;/a&gt;) to import the record layout(s) rather than hand-coding them.</source>
          <target state="translated">Suggestion: use a copybook to describe the record layouts of any file; this guarantees that multiple programs accessing that file will &quot;see&quot; the same record sizes and layouts by coding a &lt;code&gt;COPY&lt;/code&gt; statement (see &lt;a href=&quot;#COPY&quot;&gt;COPY&lt;/a&gt;) to import the record layout(s) rather than hand-coding them.</target>
        </trans-unit>
        <trans-unit id="6c580018a28048b5bfdeb3575d788d77d34a29d1" translate="yes" xml:space="preserve">
          <source>Suggestion: use a copybook to describe the record layouts of any file; this guarantees that multiple programs accessing that file will &amp;ldquo;see&amp;rdquo; the same record sizes and layouts by coding a &lt;code&gt;COPY&lt;/code&gt; statement (see &lt;a href=&quot;#COPY&quot;&gt;COPY&lt;/a&gt;) to import the record layout(s) rather than hand-coding them.</source>
          <target state="translated">제안 : 카피 북을 사용하여 파일의 레코드 레이아웃을 설명하십시오. 이렇게하면 해당 파일에 액세스하는 여러 프로그램이 레코드 레이아웃을 직접 코딩하는 대신 &lt;code&gt;COPY&lt;/code&gt; 문 ( &lt;a href=&quot;#COPY&quot;&gt;COPY&lt;/a&gt; 참조 )을 코딩하여 동일한 레코드 크기와 레이아웃을 &quot;보게&quot; 됩니다.</target>
        </trans-unit>
        <trans-unit id="a38af8d3e6886e6fbc84a1a535b9ce13c8e0c4f5" translate="yes" xml:space="preserve">
          <source>Summary Report</source>
          <target state="translated">Summary Report</target>
        </trans-unit>
        <trans-unit id="b87ab47a9a2763a975c8e97c613f198c02e4f487" translate="yes" xml:space="preserve">
          <source>Support for national character sets in GnuCOBOL is currently only partially implemented, and the compile- and run-time effect of using the &lt;code&gt;N&lt;/code&gt; symbol in a &lt;code&gt;PICTURE&lt;/code&gt; (see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause to define a field as containing national characters is the same as if &lt;code&gt;X(2)&lt;/code&gt; had been coded, with the additional effect that such a field will qualify as a &lt;code&gt;NATIONAL&lt;/code&gt; or &lt;code&gt;NATIONAL-EDITED&lt;/code&gt; field on an &lt;code&gt;INITIALIZE&lt;/code&gt; (see &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;) statement.</source>
          <target state="translated">GnuCOBOL의 국가 별 문자 집합에 대한 지원은 현재 부분적으로 만 구현되며, 국가 별 문자를 포함하는 것으로 필드를 정의하기 위해 &lt;code&gt;PICTURE&lt;/code&gt; ( &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt; 참조 ) 절 에서 &lt;code&gt;N&lt;/code&gt; 기호 를 사용하는 컴파일 및 런타임 효과는 &lt;code&gt;X(2)&lt;/code&gt; 이러한 필드가 &lt;code&gt;INITIALIZE&lt;/code&gt; ( &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt; 참조 ) 문 에서 &lt;code&gt;NATIONAL&lt;/code&gt; 또는 &lt;code&gt;NATIONAL-EDITED&lt;/code&gt; 필드 로 한정된다는 추가 효과와 함께 코딩되었습니다 .</target>
        </trans-unit>
        <trans-unit id="18cbddbe89e9462ebd808e11380e474f148057f8" translate="yes" xml:space="preserve">
          <source>Support for national character sets in GnuCOBOL is currently only partially implemented, and the compile- and run-time effect of using the&lt;code&gt;N&lt;/code&gt;symbol in a&lt;code&gt;PICTURE&lt;/code&gt;(see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause to define a field as containing national characters is the same as if&lt;code&gt;X(2)&lt;/code&gt;had been coded, with the additional effect that such a field will qualify as a&lt;code&gt;NATIONAL&lt;/code&gt;or&lt;code&gt;NATIONAL-EDITED&lt;/code&gt;field on an&lt;code&gt;INITIALIZE&lt;/code&gt;(see &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;) statement.</source>
          <target state="translated">Support for national character sets in GnuCOBOL is currently only partially implemented, and the compile- and run-time effect of using the &lt;code&gt;N&lt;/code&gt; symbol in a &lt;code&gt;PICTURE&lt;/code&gt; (see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause to define a field as containing national characters is the same as if &lt;code&gt;X(2)&lt;/code&gt; had been coded, with the additional effect that such a field will qualify as a &lt;code&gt;NATIONAL&lt;/code&gt; or &lt;code&gt;NATIONAL-EDITED&lt;/code&gt; field on an &lt;code&gt;INITIALIZE&lt;/code&gt; (see &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;) statement.</target>
        </trans-unit>
        <trans-unit id="1f40ed62723a237ce40e508931a7aff3fdec1b3c" translate="yes" xml:space="preserve">
          <source>Support for the &lt;code&gt;ALTER&lt;/code&gt; verb has been added to GnuCOBOL for the purpose of enabling GnuCOBOL to pass those National Institute of Standards and Technology (NIST) tests for the COBOL programming language that require support for &lt;code&gt;ALTER&lt;/code&gt;.</source>
          <target state="translated">GnuCOBOL이 &lt;code&gt;ALTER&lt;/code&gt; 지원이 필요한 COBOL 프로그래밍 언어에 대한 NIST (National Institute of Standards and Technology) 테스트를 통과 할 수 있도록 &lt;code&gt;ALTER&lt;/code&gt; 동사에 대한 지원 이 GnuCOBOL에 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="be2eb5fd8af440754ec9d55b0cf8113c3bdec568" translate="yes" xml:space="preserve">
          <source>Support for the&lt;code&gt;ALTER&lt;/code&gt;verb has been added to GnuCOBOL for the purpose of enabling GnuCOBOL to pass those National Institute of Standards and Technology (NIST) tests for the COBOL programming language that require support for&lt;code&gt;ALTER&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ALTER&lt;/code&gt; 동사에 대한 지원이 GnuCOBOL이 &lt;code&gt;ALTER&lt;/code&gt; 에 대한 지원이 필요한 COBOL 프로그래밍 언어에 대한 NIST (National Institute of Standards and Technology) 테스트를 통과 할 수 있도록 GnuCOBOL에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="0bf8509ba5ecde4589d8872597ed2ff4969a9a4c" translate="yes" xml:space="preserve">
          <source>Supported</source>
          <target state="translated">Supported</target>
        </trans-unit>
        <trans-unit id="2242dd7b179605b4edfaf01f88f0870d969f667a" translate="yes" xml:space="preserve">
          <source>Switch-Definition-Clause</source>
          <target state="translated">Switch-Definition-Clause</target>
        </trans-unit>
        <trans-unit id="e90e43c18d147807fbe11825c858f376c6a54022" translate="yes" xml:space="preserve">
          <source>Switches are defined using the &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) paragraph.</source>
          <target state="translated">스위치는 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; ( &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 참조 ) 단락을 사용하여 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="f37335dd0060f12a67182342cc341f3362f6a715" translate="yes" xml:space="preserve">
          <source>Switches are defined using the&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) paragraph.</source>
          <target state="translated">스위치는 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; ( &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 참조 ) 단락을 사용하여 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="9330e94681f74696cb8450b77f5a231020bb6ba8" translate="yes" xml:space="preserve">
          <source>Switches may be tested via the &lt;code&gt;IF&lt;/code&gt; statement (see &lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt;) and a Switch-Status Condition. See &lt;a href=&quot;#Switch_002dStatus-Conditions&quot;&gt;Switch-Status Conditions&lt;/a&gt;, for more information.</source>
          <target state="translated">스위치는 &lt;code&gt;IF&lt;/code&gt; 문 ( &lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt; 참조 ) 및 스위치 상태 조건을 통해 테스트 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;#Switch_002dStatus-Conditions&quot;&gt;스위치 상태 조건&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1894e80c232a43f8f22c0f6ce7a3d4717a7ae254" translate="yes" xml:space="preserve">
          <source>Switches may be tested via the&lt;code&gt;IF&lt;/code&gt;statement (see &lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt;) and a Switch-Status Condition. See &lt;a href=&quot;#Switch_002dStatus-Conditions&quot;&gt;Switch-Status Conditions&lt;/a&gt;, for more information.</source>
          <target state="translated">스위치는 &lt;code&gt;IF&lt;/code&gt; 문 ( &lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt; 참조 )과 스위치 상태 조건을 통해 테스트 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;#Switch_002dStatus-Conditions&quot;&gt;스위치 상태 조건&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="700222fb1270f971142bcd5fad7e680c99e01f31" translate="yes" xml:space="preserve">
          <source>Symbolic-Characters-Clause</source>
          <target state="translated">Symbolic-Characters-Clause</target>
        </trans-unit>
        <trans-unit id="fddcab9dffe6d8830ccb45a7c8db9b5343c5a3e4" translate="yes" xml:space="preserve">
          <source>Synchronization is performed (by the compiler) as follows:</source>
          <target state="translated">다음과 같이 (컴파일러에 의해) 동기화가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="d96570d426e390b2f9ec7d5ff875227815dd6d57" translate="yes" xml:space="preserve">
          <source>Syntax of the GnuCOBOL language will be described in special</source>
          <target state="translated">GnuCOBOL 언어의 구문은 특별하게 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="d2b0128b209edde67e3b85be66f7f3f76958a747" translate="yes" xml:space="preserve">
          <source>TABLE, TAB-TO-ADD, TAB-TO-DELETE, TAB, TALLYING, TALLY, TAN, TAPE, TEMPORARY, TERMINATE, TERMINATION-VALUE, TEST-DATE-YYYYMMDD, TEST-DAY-YYYYDDD, TEST-FORMATTED-DATETIME, TEST-NUMVAL-C, TEST-NUMVAL-F, TEST-NUMVAL, TEXT, THAN, THEN, THREADS, THREAD, THROUGH, THRU, THUMB-POSITION, TILED-HEADINGS, TIMEOUT, TIME-OUT, TIMES, TIME, TITLE-POSITION, TITLE, TOP, TOWARD-GREATER, TOWARD-LESSER, TO, TRADITIONAL-FONT, TRAILING-SHIFT, TRAILING-SIGN, TRAILING, TRANSFORM, TRANSPARENT, TREE-VIEW, TRIM, TRUE, TRUNCATION, TYPEDEF, TYPE</source>
          <target state="translated">TABLE, TAB-TO-ADD, TAB-TO-DELETE, TAB, TALLYING, TALLY, TAN, TAPE, TEMPORARY, TERMINATE, TERMINATION-VALUE, TEST-DATE-YYYYMMDD, TEST-DAY-YYYYDDD, TEST-FORMATTED-DATETIME, TEST-NUMVAL-C, TEST-NUMVAL-F, TEST-NUMVAL, TEXT, THAN, THEN, THREADS, THREAD, THROUGH, THRU, THUMB-POSITION, 타일 머리글, 시간 초과, 시간 초과, 시간, 시간, 제목- 위치, 제목, 맨 위, 더 크게, 더 적게,받는 사람, 전통 글꼴, 뒤틀림-교대, 뒤틀림 표시, 뒤틀림, 변형, 투명, 트 리뷰, 자르기, 참, 자르기, 유형 정의, 유형</target>
        </trans-unit>
        <trans-unit id="2e83c6fd9eb7ff73d298792db8b25150926bf35d" translate="yes" xml:space="preserve">
          <source>TABLE, TALLYING, TAN, TAPE, TERMINAL, TERMINATE, TEST, TEST-DATE-YYYYMMDD, TEST-DAY-YYYYDDD, TEST-FORMATTED-DATETIME, TEST-NUMVAL, TEST-NUMVAL-C, TEST-NUMVAL-F, TEXT, THAN, THEN, THROUGH, THRU, TIME, TIME-OUT, TIMEOUT, TIMES, TO, TOP, TOWARD-GREATER, TOWARD-LESSER, TRAILING, TRAILING-SIGN, TRANSFORM, TRIM, TRUE, TRUNCATION, TYPE, TYPEDEF</source>
          <target state="translated">표, TALLYING, TAN, TAPE, TERMINAL, TERMINATE, TEST, TEST-DATE-YYYYMMDD, TEST-DAY-YYYYDDD, TEST-FORMATTED-DATETIME, TEST-NUMVAL, TEST-NUMVAL-C, TEST-NUMVAL-F, TEXT, THAN, THEN, THROUGH, THRU, TIME, TIME-OUT, TIMEOUT, TIMES, TO, TOP, TOWARD-GREATER, TOWARD-LESSER, TRAILING, TRAILING-SIGN, TRANSFORM, TRIM, TRUE, TRUNCATION, TYPE, TYPEDEF 타입</target>
        </trans-unit>
        <trans-unit id="60faada67896a97f2ea96cd90b95c7d678d79697" translate="yes" xml:space="preserve">
          <source>TAN Function Syntax</source>
          <target state="translated">TAN 함수 구문</target>
        </trans-unit>
        <trans-unit id="dfc6eff5e2fd66b59b00c7f06962e5dbe779902e" translate="yes" xml:space="preserve">
          <source>TERMINATE Syntax</source>
          <target state="translated">종료 구문</target>
        </trans-unit>
        <trans-unit id="984816fd329622876e14907634264e6f332e9fb3" translate="yes" xml:space="preserve">
          <source>TEST</source>
          <target state="translated">TEST</target>
        </trans-unit>
        <trans-unit id="5cee4330239724251591ef17a82ec4b7dab1d2af" translate="yes" xml:space="preserve">
          <source>TEST-DATE-YYYYMMDD Function Syntax</source>
          <target state="translated">테스트 날짜 -YYYYMMDD 함수 구문</target>
        </trans-unit>
        <trans-unit id="1dbac88ce14883739f91aa7c7b9e26b1a8da1217" translate="yes" xml:space="preserve">
          <source>TEST-DAY-YYYYDDD Function Syntax</source>
          <target state="translated">TEST-DAY-YYYYDDD 함수 구문</target>
        </trans-unit>
        <trans-unit id="d420f5fb068b5cfbe93a3c8b13b78d3c7c8c83d3" translate="yes" xml:space="preserve">
          <source>TEST-FORMATTED-DATETIME Function Syntax</source>
          <target state="translated">TEST-FORMATTED-DATETIME 함수 구문</target>
        </trans-unit>
        <trans-unit id="2e5cef966d37067d1842521d6b6c1bf755d5a9aa" translate="yes" xml:space="preserve">
          <source>TEST-NUMVAL Function Syntax</source>
          <target state="translated">TEST-NUMVAL 함수 구문</target>
        </trans-unit>
        <trans-unit id="883c9f5d50b2fdb3f38db682764e475839396f64" translate="yes" xml:space="preserve">
          <source>TEST-NUMVAL-C Function Syntax</source>
          <target state="translated">TEST-NUMVAL-C 함수 구문</target>
        </trans-unit>
        <trans-unit id="cb253979d4d5e749205bc4953cd6b602e7d76cf2" translate="yes" xml:space="preserve">
          <source>TEST-NUMVAL-F Function Syntax</source>
          <target state="translated">TEST-NUMVAL-F 함수 구문</target>
        </trans-unit>
        <trans-unit id="b8d962f5bb90637331652bdd7361911bfa4f11ec" translate="yes" xml:space="preserve">
          <source>THIS</source>
          <target state="translated">THIS</target>
        </trans-unit>
        <trans-unit id="3f3171bcfa41b19b85d240ca0d841f761573f0cd" translate="yes" xml:space="preserve">
          <source>THIS IS A</source>
          <target state="translated">이것은</target>
        </trans-unit>
        <trans-unit id="04b2a20a8cc0ccd88af0dc68dadd361fd70529b2" translate="yes" xml:space="preserve">
          <source>TO Clause Syntax</source>
          <target state="translated">TO 절 구문</target>
        </trans-unit>
        <trans-unit id="2ad446ff3497e3afc345808baff49525fdcb6f06" translate="yes" xml:space="preserve">
          <source>TRANSFORM Syntax</source>
          <target state="translated">변환 구문</target>
        </trans-unit>
        <trans-unit id="894be5481118c02f19f200a477242c84de1f3bb0" translate="yes" xml:space="preserve">
          <source>TRIM Function Syntax</source>
          <target state="translated">TRIM 함수 구문</target>
        </trans-unit>
        <trans-unit id="ecbe476c93ca7878b56e6d7cd5b65ffa34ae1f1e" translate="yes" xml:space="preserve">
          <source>TYPE Clause Syntax</source>
          <target state="translated">TYPE 절 구문</target>
        </trans-unit>
        <trans-unit id="aff806d8afcbebfaea8b61c37d9832b5131e8778" translate="yes" xml:space="preserve">
          <source>Table SORT Syntax</source>
          <target state="translated">테이블 SORT 구문</target>
        </trans-unit>
        <trans-unit id="c559d775715fd2f56d9888245572042914adbc7f" translate="yes" xml:space="preserve">
          <source>Table references such as example #3 (table indexing) generate object code that falls in the middle of the other two but is far closer in efficiency to example #1 than #2.</source>
          <target state="translated">예제 # 3 (테이블 인덱싱)과 같은 테이블 참조는 다른 두 가지 중간에 해당하지만 # 2보다 예제 # 1에 훨씬 더 가까운 개체 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f66af24f4127cc42adf617d025d6cd37ff689156" translate="yes" xml:space="preserve">
          <source>Take, for example, the following sample program:</source>
          <target state="translated">예를 들어 다음 샘플 프로그램을 보자.</target>
        </trans-unit>
        <trans-unit id="c129ddcc17bbf3036fea845103495c3a3e4103de" translate="yes" xml:space="preserve">
          <source>Technically, GnuCOBOL does not require ANY procedure names be defined unless:</source>
          <target state="translated">기술적으로 GnuCOBOL은 다음과 같은 경우를 제외하고 모든 프로 시저 이름을 정의하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="2710741cc1f93fcc3e1018f638485351a7a33490" translate="yes" xml:space="preserve">
          <source>Text Brightness</source>
          <target state="translated">텍스트 밝기</target>
        </trans-unit>
        <trans-unit id="dd4d9c084e367f9986faa13df954584c43707262" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s where sentences come in.</source>
          <target state="translated">그것이 문장이 나오는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="e4783d8ae7b9afc0facc612bb2a6d6ffae08fdb6" translate="yes" xml:space="preserve">
          <source>The   &lt;code&gt;COB_SET_TRACE&lt;/code&gt; run-time environment variable (see &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;Run Time Environment Variables&lt;/a&gt;) provides another way to control tracing. If this environment variable is set to a value of &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;COB_SET_TRACE&lt;/code&gt; 의 런타임 환경 변수 (참조 &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;실행 시간 환경 변수를&lt;/a&gt; ) 제어 추적하는 또 다른 방법을 제공합니다. 이 환경 변수가 '</target>
        </trans-unit>
        <trans-unit id="cd736f3f3986486b086d057b8c3445d517c2d0d1" translate="yes" xml:space="preserve">
          <source>The   &lt;code&gt;LINE-COUNTER&lt;/code&gt; special register, which will contain the current line number on the current page.</source>
          <target state="translated">&lt;code&gt;LINE-COUNTER&lt;/code&gt; 현재 페이지의 현재 행 번호를 포함 특수 레지스터.</target>
        </trans-unit>
        <trans-unit id="7e0ec258377f735b26cb88e06e5d4b1afea37e3d" translate="yes" xml:space="preserve">
          <source>The   &lt;code&gt;PAGE-COUNTER&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;), which will contain the current report page number.</source>
          <target state="translated">&lt;code&gt;PAGE-COUNTER&lt;/code&gt; 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터를&lt;/a&gt; 현재 보고서의 페이지 번호를 포함하는).</target>
        </trans-unit>
        <trans-unit id="c4b2aa6d0f1dac7e8719c7a24b4c2ab9dbf72309" translate="yes" xml:space="preserve">
          <source>The   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to one of the following values:</source>
          <target state="translated">&lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터를&lt;/a&gt; 다음 값 중 하나로 설정됩니다)</target>
        </trans-unit>
        <trans-unit id="604bd9c4e1e18259b179afe1f61d0db674abcf2c" translate="yes" xml:space="preserve">
          <source>The   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be set to the return code of the operation; the value will be either 0=Success or 128=failure.</source>
          <target state="translated">&lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터를&lt;/a&gt; 작업의 반환 코드로 설정됩니다) 값은 0 = 성공 또는 128 = 실패입니다.</target>
        </trans-unit>
        <trans-unit id="c06e32dd5ab0d4a5d0f40e0553b2a6c04a358450" translate="yes" xml:space="preserve">
          <source>The   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) will be updated in addition to any &lt;code&gt;RETURNING&lt;/code&gt; or &lt;code&gt;GIVING&lt;/code&gt; data item.</source>
          <target state="translated">&lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; ) 어떤 외에도 업데이트됩니다 &lt;code&gt;RETURNING&lt;/code&gt; 또는 &lt;code&gt;GIVING&lt;/code&gt; 데이터 항목.</target>
        </trans-unit>
        <trans-unit id="3ad36e2c6bf1f6003ba43f058cfa27dde8976cb0" translate="yes" xml:space="preserve">
          <source>The   &lt;code&gt;TEMP&lt;/code&gt; run-time environment variable</source>
          <target state="translated">&lt;code&gt;TEMP&lt;/code&gt; 런타임 환경 변수</target>
        </trans-unit>
        <trans-unit id="5a2c66b1041998a88f1b156a645ce29a19586ed9" translate="yes" xml:space="preserve">
          <source>The   &lt;code&gt;TMP&lt;/code&gt; run-time environment variable</source>
          <target state="translated">&lt;code&gt;TMP&lt;/code&gt; 런타임 환경 변수</target>
        </trans-unit>
        <trans-unit id="784f580e52d43819030e1dc584f7df5d5c5bcf4c" translate="yes" xml:space="preserve">
          <source>The   &lt;code&gt;TMPDIR&lt;/code&gt; run-time environment variable (see &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;Run Time Environment Variables&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;TMPDIR&lt;/code&gt; 런타임 환경 변수 (참조 &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;실행 시간 환경 변수&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="b9906a84b46792a3cd8c6f78ca64985556ee0194" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; clause is optional because, if absent, it will be assumed anyway for this type of file. The internal structure of these files is such that the data can only be processed in a sequential manner; in order to read the 100th record in such a file, for example, you first must read records 1 through 99.</source>
          <target state="translated">&lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; 의 절은 선택 사항으로 인해 결석 한 경우,이 파일 형식 어쨌든 가정 할 것입니다. 이러한 파일의 내부 구조는 데이터가 순차적 인 방식으로 만 처리 될 수 있도록되어 있습니다. 예를 들어, 이러한 파일에서 100 번째 레코드를 읽으려면 먼저 레코드 1부터 99까지 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="70203de983908f32a36013af21384e4a86322ce5" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; clause is optional because, if absent, it will be assumed anyway for this type of file. The internal structure of these files is such that they can only be processed in a sequential manner; in order to read the 100th record in such a file, for example, you first must read records 1 through 99.</source>
          <target state="translated">&lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; 의 절은 선택 사항으로 인해 결석 한 경우,이 파일 형식 어쨌든 가정 할 것입니다. 이러한 파일의 내부 구조는 순차적 인 방식으로 만 처리 할 수 ​​있습니다. 예를 들어, 이러한 파일에서 100 번째 레코드를 읽으려면 먼저 레코드 1부터 99까지 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="d09ed138e897234705b34da07454dc8f44eccbe3" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;ADVANCING PAGE&lt;/code&gt; clause will introduce an ASCII formfeed character into the file either before the written record (&lt;code&gt;AFTER PAGE&lt;/code&gt;) or after the written record (&lt;code&gt;BEFORE PAGE&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ADVANCING PAGE&lt;/code&gt; 절 중 하나 (서면 기록하기 전에 파일에 문자를 폼 피드는 ASCII를 소개합니다 &lt;code&gt;AFTER PAGE&lt;/code&gt; () 또는 서면 기록 후 &lt;code&gt;BEFORE PAGE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9a4f04242a2dc283f032b014745b087d80cf14e1" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;AFTER EXCEPTION CONDITION&lt;/code&gt; and &lt;code&gt;AFTER EC&lt;/code&gt; clauses are syntactically recognized but are otherwise non-functional.</source>
          <target state="translated">&lt;code&gt;AFTER EXCEPTION CONDITION&lt;/code&gt; 및 &lt;code&gt;AFTER EC&lt;/code&gt; 의 조항은 구문 적으로 인식하지만, 그렇지 않으면 비 기능적된다.</target>
        </trans-unit>
        <trans-unit id="9e09700f40468b5e15b9e201e119c997cf0d95af" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;ALPHABET&lt;/code&gt; clause relates &lt;var&gt;alphabet-name-1&lt;/var&gt; to a specified character code set or collating sequence, including one you define yourself using the &lt;var&gt;literal-1&lt;/var&gt; option.</source>
          <target state="translated">&lt;code&gt;ALPHABET&lt;/code&gt; 절은 관련 &lt;var&gt;alphabet-name-1&lt;/var&gt; 당신이 사용하여 자신을 정의하는 하나를 포함하여 지정된 문자 코드 세트 또는 조합 순서에 &lt;var&gt;literal-1&lt;/var&gt; 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6bcd69d66d5ffca693136c0fc4f125efaa64aa57" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;ALTERNATE RECORD KEY&lt;/code&gt; clause, if used, defines an additional field within the record that provides an alternate means of directly accessing records or an additional field by which the file&amp;rsquo;s contents may be processed sequentially. You have the choice of allowing records to have duplicate alternate key values, if necessary.</source>
          <target state="translated">&lt;code&gt;ALTERNATE RECORD KEY&lt;/code&gt; 절 사용되는 경우, 직접 기록 또는 파일의 내용을 순차적으로 처리 될 수있는 추가 필드를 액세스하는 다른 방법을 제공 레코드 내에 추가 필드를 정의한다. 필요한 경우 레코드가 중복 된 대체 키 값을 가질 수 있도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84664b4fb9cb6e1ae82e72c1ae9e3889dcc4009d" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;AUTHOR&lt;/code&gt;,  &lt;code&gt;DATE-COMPILED&lt;/code&gt;,  &lt;code&gt;DATE-MODIFIED&lt;/code&gt;,  &lt;code&gt;DATE-WRITTEN&lt;/code&gt;,  &lt;code&gt;INSTALLATION&lt;/code&gt;,  &lt;code&gt;REMARKS&lt;/code&gt; and  &lt;code&gt;SECURITY&lt;/code&gt; paragraphs are supported by GnuCOBOL only to provide compatibility with programs written for the ANS1974 (or earlier) standards. As of the ANS1985 standard, these clauses have become obsolete and should not be used in new programs.</source>
          <target state="translated">&lt;code&gt;AUTHOR&lt;/code&gt; , &lt;code&gt;DATE-COMPILED&lt;/code&gt; , &lt;code&gt;DATE-MODIFIED&lt;/code&gt; , &lt;code&gt;DATE-WRITTEN&lt;/code&gt; , &lt;code&gt;INSTALLATION&lt;/code&gt; , &lt;code&gt;REMARKS&lt;/code&gt; 및 &lt;code&gt;SECURITY&lt;/code&gt; 단락 만 ANS1974 (또는 이전) 표준 용으로 작성된 프로그램과의 호환성을 제공하기 위해 GnuCOBOL 지원합니다. ANS1985 표준에서 이러한 절은 더 이상 사용되지 않으며 새 프로그램에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e00ac45fc69d379bf2082e8d733c0d49eeec4f68" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;BLOCK CONTAINS&lt;/code&gt;,  &lt;code&gt;DATA RECORD&lt;/code&gt;,  &lt;code&gt;LABEL RECORD&lt;/code&gt;,  &lt;code&gt;RECORDING MODE&lt;/code&gt; and  &lt;code&gt;VALUE OF&lt;/code&gt; clauses are syntactically recognized but are obsolete and non-functional. These clauses should not be coded in new programs.</source>
          <target state="translated">&lt;code&gt;BLOCK CONTAINS&lt;/code&gt; , &lt;code&gt;DATA RECORD&lt;/code&gt; , &lt;code&gt;LABEL RECORD&lt;/code&gt; , &lt;code&gt;RECORDING MODE&lt;/code&gt; 와 &lt;code&gt;VALUE OF&lt;/code&gt; 절은 구문 적으로 인식하지만, 사용되지 않는 비 기능적된다. 이러한 절은 새 프로그램에서 코딩되어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="19c161b455f1b798008f5e5ddb5498982200913c" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;CALL-CONVENTION&lt;/code&gt; clause allows a decimal integer, representing a series of ON/OFF switch settings, to be associated with a mnemonic name which may then be coded on a &lt;code&gt;CALL&lt;/code&gt; statement (see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;). The switch settings defined by this mnemonic will then control how the linkage to a subroutine invoked by the &lt;code&gt;CALL&lt;/code&gt; statement that references &lt;var&gt;mnemonic-name-1&lt;/var&gt; will be handled.</source>
          <target state="translated">&lt;code&gt;CALL-CONVENTION&lt;/code&gt; 절은 다음에 코딩 할 수있는 코드 이름에 관련 지을 수 ON / OFF 스위치 설정하는 일련의 대표, 진수 정수를 허용 &lt;code&gt;CALL&lt;/code&gt; (참조 문 &lt;a href=&quot;#CALL&quot;&gt;CALL을&lt;/a&gt; ). 이 니모닉에 의해 정의 된 스위치 설정은 &lt;var&gt;mnemonic-name-1&lt;/var&gt; 을 참조 하는 &lt;code&gt;CALL&lt;/code&gt; 문에 의해 호출 된 서브 루틴에 대한 연결 방법을 제어합니다. .</target>
        </trans-unit>
        <trans-unit id="1cc3106e2c9e94876c7445161186ea0935e77233" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;CODE-SET&lt;/code&gt; clause allows a custom alphabet, defined in the &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) paragraph, to be associated with a file. This clause is valid only when used with sequential or line sequential files.</source>
          <target state="translated">&lt;code&gt;CODE-SET&lt;/code&gt; 의 절은에 정의 된 사용자 정의 알파벳, 수 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; 는 (참조 &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-이름을&lt;/a&gt; 파일과 관련된 것으로, 단락). 이 절은 순차 또는 행 순차 파일과 함께 사용될 때만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="63b77ecaefdc19c13c8b0110b7f11a2ea2cc8f6d" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; clause allows you to specify a customized character collating sequence to be used when alphanumeric values are compared to one another. Data will still be stored in the character set native to the computer, but the logical sequence in which characters are ordered for comparison purposes can be altered from that defined by the computer&amp;rsquo;s native character set. The &lt;var&gt;alphabet-name-1&lt;/var&gt; you specify needs to be defined in the &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) paragraph.</source>
          <target state="translated">&lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; 절은 숫자 값을 서로 비교할 때 사용하는 사용자 정의 된 문자 조합 순서를 지정할 수 있습니다. 데이터는 여전히 컴퓨터 고유의 문자 집합에 저장되지만 비교 목적으로 문자가 정렬되는 논리적 순서는 컴퓨터의 고유 문자 집합에서 정의한 순서에서 변경할 수 있습니다. 지정한 &lt;var&gt;alphabet-name-1&lt;/var&gt; 은 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; 에서 정의해야합니다 ( &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 참조). ) 단락 .</target>
        </trans-unit>
        <trans-unit id="add3c152066bb7544063ee6548556380f7409ea7" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt;,  &lt;code&gt;RECORD DELIMITER&lt;/code&gt;,  &lt;code&gt;RESERVE&lt;/code&gt; and  &lt;code&gt;ALL OTHER&lt;/code&gt; clauses are syntactically recognized but are otherwise non-functional.</source>
          <target state="translated">&lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; , &lt;code&gt;RECORD DELIMITER&lt;/code&gt; , &lt;code&gt;RESERVE&lt;/code&gt; 및 &lt;code&gt;ALL OTHER&lt;/code&gt; 조항은 구문 적으로 인식하지만, 그렇지 않으면 비 기능적된다.</target>
        </trans-unit>
        <trans-unit id="5a926368a4c880d35eba25a192f91f86efa8e952" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;CONSOLE IS CRT&lt;/code&gt; clause, if specified, will cause a &lt;code&gt;DISPLAY&lt;/code&gt; statement lacking an explicit &lt;code&gt;UPON&lt;/code&gt; clause to be treated as a &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; statement (see &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-item&lt;/a&gt;), and any &lt;code&gt;ACCEPT&lt;/code&gt; statement lacking a &lt;code&gt;FROM&lt;/code&gt; clause to be treated as a &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;CONSOLE IS CRT&lt;/code&gt; 절은 지정된 경우, 원인이됩니다 &lt;code&gt;DISPLAY&lt;/code&gt; 명시 적으로 부족한 문 &lt;code&gt;UPON&lt;/code&gt; A와 처리 할 절을 &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; (참조 문 &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY 화면 데이터 항목&lt;/a&gt; ) 및 &lt;code&gt;ACCEPT&lt;/code&gt; 결여 문을 &lt;code&gt;FROM&lt;/code&gt; 에 절 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 문 으로 취급됩니다 ( &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item 참조).&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8d1132fd4faa7fd2022d9f29f050c9b8596ceb53" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;CURRENCY SIGN&lt;/code&gt; clause may be used to redefine the character to be used as a currency sign in a &lt;code&gt;PICTURE&lt;/code&gt; (see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause. The default currency sign is a dollar-sign (&amp;lsquo;</source>
          <target state="translated">&lt;code&gt;CURRENCY SIGN&lt;/code&gt; 절이에서 통화 기호로 사용되는 문자를 재정의하는 데 사용될 수있다 &lt;code&gt;PICTURE&lt;/code&gt; (참조 &lt;a href=&quot;#PICTURE&quot;&gt;영상&lt;/a&gt; 절). 기본 통화 기호는 달러 기호 ( '</target>
        </trans-unit>
        <trans-unit id="44c990ac72f8e1b55d3f949a65f595444cf533c4" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;CURSOR IS&lt;/code&gt; clause allows you to specify a 4- or 6-character data item into which the cursor screen location at the time a screen &lt;code&gt;ACCEPT&lt;/code&gt; is satisfied. The value will be returned as</source>
          <target state="translated">&lt;code&gt;CURSOR IS&lt;/code&gt; 절에서는 화면이, 커서 화면 위치되는 4- 또는 6- 문자 데이터 항목을 지정할 수 있도록 &lt;code&gt;ACCEPT&lt;/code&gt; 만족한다. 값은 다음과 같이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e8d948783f422a15b8db65701c8d8ae6c2f8e097" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;DEBUGGING MODE&lt;/code&gt; clause, if present, will inform the compiler that debugging lines (those with a &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;DEBUGGING MODE&lt;/code&gt; 절은, 존재하는 경우, 컴파일러를 통보 디버깅 라인 (a와 그 '</target>
        </trans-unit>
        <trans-unit id="840f6a9579f0e761823e46dac0591287fe40ae23" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;DECIMAL POINT IS COMMA&lt;/code&gt; clause reverses the definition of the &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;DECIMAL POINT IS COMMA&lt;/code&gt; 절은 '의 정의를 반대로</target>
        </trans-unit>
        <trans-unit id="4e96cb97ea8a66bf0fb6146144be8d2e84aeb7c2" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;DEFINED&lt;/code&gt; option tests for whether &lt;var&gt;cdf-variable-1&lt;/var&gt; has been defined, but not yet assigned a value (&lt;code&gt;&amp;gt;&amp;gt;DEFINE &amp;hellip; OFF&lt;/code&gt;); use the &lt;code&gt;NOT&lt;/code&gt; option to test for the variable not being defined.</source>
          <target state="translated">&lt;code&gt;DEFINED&lt;/code&gt; 여부에 대한 옵션을 테스트 &lt;var&gt;cdf-variable-1&lt;/var&gt; 정의되어 있지만 아직 값이 할당되었는지를 ( &lt;code&gt;&amp;gt;&amp;gt;DEFINE &amp;hellip; OFF&lt;/code&gt; ); &lt;code&gt;NOT&lt;/code&gt; 옵션을 사용하여 정의되지 않은 변수를 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="f282a135dfdc142c064d1b75d3c0efcf801c21e4" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;DELIMITED BY&lt;/code&gt; clause specifies how much of each source item will be copied into &lt;var&gt;identifier-3&lt;/var&gt;. &lt;code&gt;DELIMITED BY SIZE&lt;/code&gt; (the default if no &lt;code&gt;DELIMITED BY&lt;/code&gt; clause is specified) causes the</source>
          <target state="translated">&lt;code&gt;DELIMITED BY&lt;/code&gt; 각 소스 항목의 얼마나 많은 절 지정에 복사됩니다 &lt;var&gt;identifier-3&lt;/var&gt; . &lt;code&gt;DELIMITED BY SIZE&lt;/code&gt; (없는 경우 기본 &lt;code&gt;DELIMITED BY&lt;/code&gt; 절이 지정 )은</target>
        </trans-unit>
        <trans-unit id="57c01d00d52c2469a821bd2e86e0b7eddcde9cb8" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;DUPLICATES&lt;/code&gt; clause is syntactically recognized but is otherwise non-functional.</source>
          <target state="translated">&lt;code&gt;DUPLICATES&lt;/code&gt; 절은 구문 적으로 인식하지만, 그렇지 않은 비 기능입니다.</target>
        </trans-unit>
        <trans-unit id="0b55ddfd66ffea3103eb8f553cac04a971762fdf" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;ESCAPE KEY&lt;/code&gt; option may be used after the &lt;code&gt;ACCEPT FROM Screen-Info&lt;/code&gt; statement (see &lt;a href=&quot;#ACCEPT-FROM-Screen_002dInfo&quot;&gt;ACCEPT FROM Screen-Info&lt;/a&gt;) has executed. The result returned will be the four-digit &lt;code&gt;CRT STATUS&lt;/code&gt; (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) identifier value. See &lt;a href=&quot;#CRT-STATUS-Codes&quot;&gt;CRT STATUS Codes&lt;/a&gt;, for the specific code values.</source>
          <target state="translated">&lt;code&gt;ESCAPE KEY&lt;/code&gt; (가) 한 후 옵션을 사용할 수 있습니다 &lt;code&gt;ACCEPT FROM Screen-Info&lt;/code&gt; 문 (참조 &lt;a href=&quot;#ACCEPT-FROM-Screen_002dInfo&quot;&gt;화면-정보로부터 동의&lt;/a&gt; 를 실행하고있다). 반환 된 결과는 4 자리 &lt;code&gt;CRT STATUS&lt;/code&gt; ( &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 참조 ) 식별자 값입니다. 특정 코드 값 은 &lt;a href=&quot;#CRT-STATUS-Codes&quot;&gt;CRT STATUS 코드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc2db71b648b8f1f445fb5645c9f658114b9045a" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;EVENT STATUS&lt;/code&gt; and  &lt;code&gt;SCREEN CONTROL&lt;/code&gt; clauses are syntactically recognized but are otherwise non-functional.</source>
          <target state="translated">&lt;code&gt;EVENT STATUS&lt;/code&gt; 및 &lt;code&gt;SCREEN CONTROL&lt;/code&gt; 절은 구문 적으로 인식하지만, 그렇지 않은 비 기능입니다.</target>
        </trans-unit>
        <trans-unit id="25b83300936d9ed6f517a07a850d311601652bea" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;FILE STATUS&lt;/code&gt; or  &lt;code&gt;SORT STATUS&lt;/code&gt; clause (they are both equivalent and only one or the other, if any, should be specified) is used to specify the name of a two-digit numeric data item into which an I/O status code will be saved after every I/O verb that is executed against the file. This does not actually allocate the data item &amp;mdash; you must define the item yourself somewhere in the data division. Note that the following list is not definitive: more can be added and any tests should include one for non zeros as a catch all.  Possible status codes that can be returned to a &lt;code&gt;FILE STATUS&lt;/code&gt; data item are as follows:</source>
          <target state="translated">&lt;code&gt;FILE STATUS&lt;/code&gt; 또는 &lt;code&gt;SORT STATUS&lt;/code&gt; 절 (그들은 모두 동등 만 하나있는 경우, 지정해야 다른) 두 자리 숫자 데이터 항목의 이름을 지정하는 데 사용되는 것은되는의 I / O 상태 코드가 될 것입니다 파일에 대해 실행되는 모든 I / O 동사 후에 저장됩니다. 이것은 실제로 데이터 항목을 할당하지 않습니다. 데이터 분할의 어딘가에 항목을 직접 정의해야합니다. 다음 목록은 결정적이지 않습니다. 더 추가 할 수 있으며 모든 테스트에는 0이 아닌 항목을 모두 포함해야합니다. &lt;code&gt;FILE STATUS&lt;/code&gt; 데이터 항목 으로 리턴 될 수있는 가능한 상태 코드 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2eee895c8932b578c63bdc13cbbaff584828f312" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;FIRST DETAIL&lt;/code&gt; clause defines the first line at which a detail group may be presented.</source>
          <target state="translated">첫 &lt;code&gt;FIRST DETAIL&lt;/code&gt; 절 상세 그룹이 제시 될 수있는 첫 번째 행을 정의한다.</target>
        </trans-unit>
        <trans-unit id="4d8c5daa685f43897fa1a1f3053eec8276233eff" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;FOLDCOPYNAME&lt;/code&gt; option provides the equivalent of specifying the compiler</source>
          <target state="translated">&lt;code&gt;FOLDCOPYNAME&lt;/code&gt; 의 옵션은 컴파일러를 지정하는 것과을 제공합니다</target>
        </trans-unit>
        <trans-unit id="531d02d896a82d63192fd3a6d85144d4d72e030e" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;FOOTING&lt;/code&gt; clause defines the last line at which any line of a control footing group may be presented.</source>
          <target state="translated">&lt;code&gt;FOOTING&lt;/code&gt; 절은 제어 각주 그룹의 라인이 제시 될 수있는 마지막 행을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="39ec71cfb54298cde0706492dba0b7145cd47158" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;FROM CRT&lt;/code&gt;,  &lt;code&gt;MODE IS BLOCK&lt;/code&gt; and  &lt;code&gt;CONVERSION&lt;/code&gt; clauses are syntactically recognized but are otherwise non-functional.</source>
          <target state="translated">&lt;code&gt;FROM CRT&lt;/code&gt; , &lt;code&gt;MODE IS BLOCK&lt;/code&gt; 과 &lt;code&gt;CONVERSION&lt;/code&gt; 의 절은 문법적으로 인식되지만, 그렇지 않은 기능적된다.</target>
        </trans-unit>
        <trans-unit id="ff7263b8f3650812257bfa58eb08945ebd3d8bd6" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;HEADING&lt;/code&gt; clause defines the first line number at which a report heading or page heading may be presented.</source>
          <target state="translated">&lt;code&gt;HEADING&lt;/code&gt; 절은 보고서의 제목 또는 페이지 제목이 제시 될 수있는 첫 번째 행 번호를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="89e8af69c206ce1d49fa449c0994f217f18fad77" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;INITIAL&lt;/code&gt; clause, if specified, guarantees the subprogram will be in its initial (i.e. compiled) state each and every time it is executed, not just the first time.</source>
          <target state="translated">&lt;code&gt;INITIAL&lt;/code&gt; 절은 지정된 경우, 서브 프로그램은 초기 (즉, 컴파일 된) 상태로이 실행될 때마다 모든 시간뿐 아니라 처음이다 보장합니다.</target>
        </trans-unit>
        <trans-unit id="9ff9268e15d513e0143ec1c497696ac92591affb" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;INPUT&lt;/code&gt;,  &lt;code&gt;OUTPUT&lt;/code&gt;,  &lt;code&gt;I-O&lt;/code&gt; and  &lt;code&gt;EXTEND&lt;/code&gt; open modes inform GnuCOBOL of the manner in which you wish to use the file, as follows:</source>
          <target state="translated">&lt;code&gt;INPUT&lt;/code&gt; , &lt;code&gt;OUTPUT&lt;/code&gt; , &lt;code&gt;I-O&lt;/code&gt; 및 &lt;code&gt;EXTEND&lt;/code&gt; 개방 모드는 다음, 당신이 파일을 사용하고자하는 방식의 GnuCOBOL 통보 :</target>
        </trans-unit>
        <trans-unit id="d136db3640cc5ee6440a8c90b164ff1ba27a939f" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;INTRINSIC&lt;/code&gt; clause allows you to flag one or more (or  &lt;code&gt;ALL&lt;/code&gt;) built-in intrinsic functions as being usable without the need to code the keyword  &lt;code&gt;FUNCTION&lt;/code&gt; in front of the function names.</source>
          <target state="translated">&lt;code&gt;INTRINSIC&lt;/code&gt; 절은 플래그 하나 이상의 (또는 당신을 수 있도록 &lt;code&gt;ALL&lt;/code&gt; 내장 된 내장 함수 코드를 필요로하지 않고 키워드 가능한 것으로) &lt;code&gt;FUNCTION&lt;/code&gt; 함수 이름 앞에있다.</target>
        </trans-unit>
        <trans-unit id="432694b0fdf19129db6245e5e605221a318067fc" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;LAST CONTROL&lt;/code&gt;&lt;code&gt;HEADING&lt;/code&gt; clause defines the last line at which any line of a control heading may be presented.</source>
          <target state="translated">&lt;code&gt;LAST CONTROL&lt;/code&gt; 의 &lt;code&gt;HEADING&lt;/code&gt; 의 절 제어 호의 모든 라인이 제공 될 수있는 마지막 행을 정의한다.</target>
        </trans-unit>
        <trans-unit id="386a38d0bd399732f717d6fdb89c03a2541fd183" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;LAST DETAIL&lt;/code&gt; clause defines the last line at which any line of a detail group may be presented.</source>
          <target state="translated">&lt;code&gt;LAST DETAIL&lt;/code&gt; 절 상세 그룹의 모든 광고가 제시 될 수있는 마지막 행을 정의한다.</target>
        </trans-unit>
        <trans-unit id="39bc9e6c98d396627c62ab1626e413787d28da53" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;LINES&lt;/code&gt; and  &lt;code&gt;COLUMNS&lt;/code&gt; options will retrieve the respective components of the size of the console display.</source>
          <target state="translated">&lt;code&gt;LINES&lt;/code&gt; 과 &lt;code&gt;COLUMNS&lt;/code&gt; 의 옵션은 콘솔 디스플레이의 크기의 각 구성 요소를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="53623b9d54f9bc8f2c0bb9355b774e92f80a4f28" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;LOCALE&lt;/code&gt; clause may be used to associate external OS-defined locale names (&lt;var&gt;literal-2&lt;/var&gt;) with an internal name (&lt;var&gt;locale-name-1&lt;/var&gt;) that may then be referenced within the program. Locale names are defined by the Operating System and/or C compiler GnuCOBOL will be utilizing on your computer.</source>
          <target state="translated">&lt;code&gt;LOCALE&lt;/code&gt; 절 연관 외부 OS 정의 로케일 이름 (하는데 사용될 수있다 &lt;var&gt;literal-2&lt;/var&gt; 내부 이름 ()와 &lt;var&gt;locale-name-1&lt;/var&gt; 그 프로그램 내에서 참조 될 수있다). 로케일 이름은 운영 체제에 의해 정의되며 GnuCOBOL이 컴퓨터에서 사용할 C 컴파일러입니다.</target>
        </trans-unit>
        <trans-unit id="8acc773243e773127af454560c0b7ecd2ef15eb6" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;LOCK&lt;/code&gt; clause defines how concurrent access to the file will be managed on a record-by-record basis. See &lt;a href=&quot;#Record-Locking&quot;&gt;Record Locking&lt;/a&gt;, for the details.</source>
          <target state="translated">&lt;code&gt;LOCK&lt;/code&gt; 의 절은 파일에 대한 동시 액세스는 레코드 단위로 관리되는 방법을 정의합니다. 자세한 내용은 &lt;a href=&quot;#Record-Locking&quot;&gt;레코드 잠금을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="3b7c37fafdff8d069de528a8fe9e50aeb0a01acc" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;MEMORY SIZE&lt;/code&gt; and  &lt;code&gt;SEGMENT-LIMIT&lt;/code&gt; clauses are syntactically recognized but are otherwise non-functional.</source>
          <target state="translated">&lt;code&gt;MEMORY SIZE&lt;/code&gt; 및 &lt;code&gt;SEGMENT-LIMIT&lt;/code&gt; 절은 구문 적으로 인식하지만, 그렇지 않은 비 기능입니다.</target>
        </trans-unit>
        <trans-unit id="16d8b3bd092772db7db071aa240b498929e2023e" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;NO ADVANCING&lt;/code&gt; clause, if used, will suppress the carriage-return / line-feed sequence that is normally added to the end of any console display.</source>
          <target state="translated">&lt;code&gt;NO ADVANCING&lt;/code&gt; 절 사용되는 경우, 일반적으로 모든 콘솔 화면의 끝에 추가되는 캐리지 리턴 / 라인 피드 시퀀스를 억제한다.</target>
        </trans-unit>
        <trans-unit id="d35d3ee1131ce0094bcbbcb97bb88b3cd8e42c74" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;NO REWIND&lt;/code&gt;, and  &lt;code&gt;REVERSED&lt;/code&gt; clauses are syntactically recognized but are otherwise non-functional.</source>
          <target state="translated">&lt;code&gt;NO REWIND&lt;/code&gt; , 그리고 &lt;code&gt;REVERSED&lt;/code&gt; 절은 구문 적으로 인식하지만, 그렇지 않으면 비 기능적된다.</target>
        </trans-unit>
        <trans-unit id="ab7e60586318e878f39e37ab0269948184c45b54" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;NOFOLDCOPYNAME&lt;/code&gt; option turns off the effect of either the &lt;code&gt;&amp;gt;&amp;gt;SET FOLDCOPYNAME&lt;/code&gt; statement or the compiler</source>
          <target state="translated">&lt;code&gt;NOFOLDCOPYNAME&lt;/code&gt; 의 중 하나의 효과 오프 옵션 회전 &lt;code&gt;&amp;gt;&amp;gt;SET FOLDCOPYNAME&lt;/code&gt; 문 또는 컴파일러</target>
        </trans-unit>
        <trans-unit id="c8bdfdddeacaff63c3ab640aacfadd64639c9f3d" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;NUMERIC SIGN TRAILING SEPARATE&lt;/code&gt; specification causes all signed numeric &lt;code&gt;USAGE DISPLAY&lt;/code&gt; data items to be created as if the &lt;code&gt;SIGN IS TRAILING SEPARATE CHARACTER&lt;/code&gt; clause was included in their definitions.</source>
          <target state="translated">&lt;code&gt;NUMERIC SIGN TRAILING SEPARATE&lt;/code&gt; 명세는 모든 서명 된 숫자 발생 &lt;code&gt;USAGE DISPLAY&lt;/code&gt; 는 IF와 같은 데이터 항목을 작성할 수 &lt;code&gt;SIGN IS TRAILING SEPARATE CHARACTER&lt;/code&gt; 절은 그 정의에 포함시켰다.</target>
        </trans-unit>
        <trans-unit id="259c5a22ac22d346e60a6c514da9ff6bf21ff6cd" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;ON STATUS&lt;/code&gt; and  &lt;code&gt;OFF STATUS&lt;/code&gt; syntax provides a way of associating a condition-name with either the on or off status of the switch, so that status may be tested at execution time via the &lt;code&gt;IF&lt;/code&gt; statement (see &lt;a href=&quot;#IF&quot;&gt;IF&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;ON STATUS&lt;/code&gt; 및 &lt;code&gt;OFF STATUS&lt;/code&gt; 구문 어느 그 상태를 통하여 실행 시간에 테스트 될 수 있도록, 또는 스위치의 OFF 상태를 가진 상태 이름을 연관시키는 방법을 제공하는 &lt;code&gt;IF&lt;/code&gt; 문 (참조 &lt;a href=&quot;#IF&quot;&gt;IF을&lt;/a&gt; )한다.</target>
        </trans-unit>
        <trans-unit id="afbd8f2805222ded38e4c85de432fdb02d823251" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;OPTIONAL&lt;/code&gt; clause, to be used only for files that will be used to provide input data to the program, indicates the file may or may not actually be available at run-time. Attempts to &lt;code&gt;OPEN&lt;/code&gt; an &lt;code&gt;OPTIONAL&lt;/code&gt; file when the file does not exist will receive a special non-fatal file status value (see status 05 in the list of file status values below) indicating the file is not available; a subsequent attempt to &lt;code&gt;READ&lt;/code&gt; that file will return an &lt;code&gt;AT END&lt;/code&gt; (end-of-file) condition. Optionally, files may be designated as &lt;code&gt;NOT OPTIONAL&lt;/code&gt;, if desired. This is useful when specifying the compiler&amp;rsquo;s</source>
          <target state="translated">&lt;code&gt;OPTIONAL&lt;/code&gt; 절에만 프로그램에 입력 데이터를 제공하는 데 사용되는 파일에 사용되는 파일이 나 실제로 런타임에서 사용하지 못할 수 있습니다 나타냅니다. 하는 시도 &lt;code&gt;OPEN&lt;/code&gt; &lt;code&gt;OPTIONAL&lt;/code&gt; 파일이 특별한 비 치명적 파일 상태 값을받을 것이다 존재하지 않는 경우 파일이 파일을 나타내는 (아래 파일 상태 값의 목록에 상태 05 참조)을 사용할 수 없습니다; 이후에 해당 파일 을 &lt;code&gt;READ&lt;/code&gt; 려고 하면 &lt;code&gt;AT END&lt;/code&gt; (파일 끝) 조건 이 반환 됩니다. 필요에 따라 파일을 &lt;code&gt;NOT OPTIONAL&lt;/code&gt; 로 지정할 수도 있습니다 . 이것은 컴파일러의</target>
        </trans-unit>
        <trans-unit id="4c8a0ec68108c5a2bc3944e89ec7d36fb212ca49" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;OPTIONAL&lt;/code&gt; keyword, legal only on &lt;code&gt;BY REFERENCE&lt;/code&gt; arguments, allows calling programs to code  &lt;code&gt;OMITTED&lt;/code&gt; for that corresponding argument when they call this subprogram. See &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;. for additional information on this feature.</source>
          <target state="translated">&lt;code&gt;OPTIONAL&lt;/code&gt; 에서만 법적 키워드 &lt;code&gt;BY REFERENCE&lt;/code&gt; 인수, 코드 프로그램을 호출 할 수 있습니다 &lt;code&gt;OMITTED&lt;/code&gt; 위해를 그들이이 서브 프로그램을 호출 할 때 인수를 해당. &lt;a href=&quot;#CALL&quot;&gt;CALL을&lt;/a&gt; 참조하십시오 . 이 기능에 대한 추가 정보는</target>
        </trans-unit>
        <trans-unit id="4f0216ebe492af8c5e88cfd78c8f2469259c5885" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;PARAMETER&lt;/code&gt; option is used to create a variable whose value is that of the environment variable of the same name. Note that this value assignment occurs at compilation time, not program execution time.</source>
          <target state="translated">&lt;code&gt;PARAMETER&lt;/code&gt; 의 옵션 값이 같은 이름의 환경 변수의되는 변수를 생성하기 위해 사용된다. 이 값 할당은 프로그램 실행 시간이 아니라 컴파일 시간에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e36e19c3508e4603172a71f192924842da943604" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;POINTER&lt;/code&gt; data item &amp;mdash; &lt;var&gt;identifier-4&lt;/var&gt; &amp;mdash; must be a non-edited elementary integer numeric data item with a value greater than zero.</source>
          <target state="translated">&lt;code&gt;POINTER&lt;/code&gt; 의 데이터 항목 - &lt;var&gt;identifier-4&lt;/var&gt; - 0보다 큰 값을 가진 비 편집 기본 정수 숫자 데이터 항목이어야한다.</target>
        </trans-unit>
        <trans-unit id="4728ae272c664ed20828690e7ed70d836ea8fbdb" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;RECORD CONTAINS&lt;/code&gt; and  &lt;code&gt;RECORD IS VARYING&lt;/code&gt; clauses are ignored (with a warning message issued) when used with line sequential files. With other file organizations, these mutually-exclusive clauses define the length of data records within the file. The data item specified as &lt;var&gt;identifier-6&lt;/var&gt; must be defined within one of the record descriptions of &lt;var&gt;file-name-1&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;RECORD CONTAINS&lt;/code&gt; 하고 &lt;code&gt;RECORD IS VARYING&lt;/code&gt; 의 절은 라인 순차 파일 사용 (발행 경고 메시지가) 무시됩니다. 다른 파일 구성에서 이러한 상호 배타적 인 절은 파일 내의 데이터 레코드 길이를 정의합니다. &lt;var&gt;identifier-6&lt;/var&gt; 으로 지정된 데이터 항목 은 &lt;var&gt;file-name-1&lt;/var&gt; 의 레코드 설명 중 하나 내에 정의되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="98b682ff7c15a5fa9875ee1916c0776475d73fe8" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;RECORD KEY&lt;/code&gt; clause defines the field within the record used to provide the primary access to records within the file. No two records in the file will be allowed to have the same &lt;code&gt;PRIMARY KEY&lt;/code&gt; field value. The  &lt;code&gt;SOURCE IS&lt;/code&gt; clause is for use with  &lt;code&gt;Split Keys&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RECORD KEY&lt;/code&gt; 절은 파일 내의 레코드에 대한 기본 액세스를 제공하는 데 사용되는 기록 내의 필드를 정의합니다. 파일의 두 레코드는 동일한 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 필드 값 을 가질 수 없습니다 . &lt;code&gt;SOURCE IS&lt;/code&gt; 절은 함께 사용하기위한 것입니다 &lt;code&gt;Split Keys&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc82a369523305af04cf4f9f915efcf16b0a1d62" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;RECURSIVE&lt;/code&gt; clause, if any, will cause the compiler to generate different object code for the subprogram that will enable it to invoke itself and to properly return back to the program that invoked it.</source>
          <target state="translated">&lt;code&gt;RECURSIVE&lt;/code&gt; 절은 어떤 경우, 컴파일러 자체를 호출 할 수 있도록하고 제대로 호출 프로그램으로 다시 돌아갑니다 서브 프로그램에 대해 서로 다른 오브젝트 코드를 생성하게됩니다.</target>
        </trans-unit>
        <trans-unit id="4b20c5f00fa64627d49ea757ec56df0e913987ea" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;REEL&lt;/code&gt;,  &lt;code&gt;LOCK&lt;/code&gt; and  &lt;code&gt;NO REWIND&lt;/code&gt; clauses are syntactically recognized but are otherwise non-functional, except for the &lt;code&gt;CLOSE&amp;hellip;NO REWIND&lt;/code&gt; statement, which will generate a file status of 07 rather than the usual 00 (but take no other action).</source>
          <target state="translated">&lt;code&gt;REEL&lt;/code&gt; , &lt;code&gt;LOCK&lt;/code&gt; 및 &lt;code&gt;NO REWIND&lt;/code&gt; 절은 구문 적으로 인식하지만,를 제외하고, 그렇지 않으면 비 기능적된다 &lt;code&gt;CLOSE&amp;hellip;NO REWIND&lt;/code&gt; 오히려 보통 00보다 07의 파일 상태를 생성 (하지만 다른 작업을 수행하지 않음) 것입니다 문.</target>
        </trans-unit>
        <trans-unit id="474c3f6d1bbfdeb67e797add930cfab064415ffc" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;RELATIVE KEY&lt;/code&gt; clause is optional only if &lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; is specified.</source>
          <target state="translated">&lt;code&gt;RELATIVE KEY&lt;/code&gt; 의 절은 경우에만 선택 사항입니다 &lt;code&gt;ACCESS MODE SEQUENTIAL&lt;/code&gt; 이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="569d6df6b7554cffe0fe1b791648e4ef14242ded" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;RELATIVE KEY&lt;/code&gt; data item is a numeric data item that cannot be defined as a field within records of this file. Its purpose is to return the current relative record number of a relative file that is being processed in &lt;code&gt;SEQUENTIAL&lt;/code&gt; access mode and to serve as a key that specifies the relative record number to be read or written when processing a relative file in &lt;code&gt;RANDOM&lt;/code&gt; access mode.</source>
          <target state="translated">&lt;code&gt;RELATIVE KEY&lt;/code&gt; 의 데이터 항목이 파일의 기록에서 필드로 정의 할 수없는 숫자 데이터 항목입니다. 그 목적은 &lt;code&gt;SEQUENTIAL&lt;/code&gt; 액세스 모드 에서 처리중인 상대 파일의 현재 상대 레코드 번호를 반환하고 &lt;code&gt;RANDOM&lt;/code&gt; 액세스 모드 에서 상대 파일을 처리 할 때 읽거나 쓸 상대 레코드 번호를 지정하는 키 역할을하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="8d756ebfeaa290d5e7585ffe1c832f5da562434c" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;REPORT IS&lt;/code&gt; clause announces to the compiler that the file will be dedicated to the Report Writer Control System (RWCS); the clause names one or more reports, each to be described in the report section. The following special rules apply when the &lt;code&gt;REPORT&lt;/code&gt; clause is used:</source>
          <target state="translated">&lt;code&gt;REPORT IS&lt;/code&gt; 파일이 보고서 작성기 제어 시스템 (RWCS)에 전념 할 것을 컴파일러에 절 발표; 이 절은 하나 이상의 보고서를 명명하며 각각 보고서 섹션에서 설명합니다. &lt;code&gt;REPORT&lt;/code&gt; 절이 사용될 때 다음과 같은 특수 규칙이 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="6071dd56abfbe62c4a206269645c668dd3cb9dc2" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;RETURNING&lt;/code&gt; clause allows you to specify a numeric data item into which the subroutine should return a numeric value. If you use this clause on the &lt;code&gt;CALL&lt;/code&gt;, the subroutine should include a &lt;code&gt;RETURNING&lt;/code&gt; (see &lt;a href=&quot;#PROCEDURE-DIVISION-RETURNING&quot;&gt;PROCEDURE DIVISION RETURNING&lt;/a&gt;) clause on its procedure division header. Of course, a subroutine may pass a value of any kind back in any argument passed &lt;code&gt;BY REFERENCE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RETURNING&lt;/code&gt; 절은 서브 루틴이 숫자 값을 반환해야되는 숫자 데이터 항목을 지정할 수 있습니다. &lt;code&gt;CALL&lt;/code&gt; 에이 절을 사용하는 경우 서브 루틴은 프로 시저 분할 헤더에 &lt;code&gt;RETURNING&lt;/code&gt; ( &lt;a href=&quot;#PROCEDURE-DIVISION-RETURNING&quot;&gt;PROCEDURE DIVISION RETURNING&lt;/a&gt; 참조 ) 절을 포함해야합니다. 물론, 서브 루틴은 &lt;code&gt;BY REFERENCE&lt;/code&gt; 전달 된 모든 인수에서 모든 종류의 값을 다시 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a476b169b0e6a976c3d6bd5bd2d33226481c2e8b" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;RUN&lt;/code&gt; clause halts the program without displaying any special message to that effect.</source>
          <target state="translated">&lt;code&gt;RUN&lt;/code&gt; 의 절은 그 효과에 특별한 메시지를 표시하지 않고 프로그램을 중단합니다.</target>
        </trans-unit>
        <trans-unit id="6419f821b45f6fbf498400509a1f2a2ec261cef8" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;SAME SORT-MERGE&lt;/code&gt; and  &lt;code&gt;SAME SORT&lt;/code&gt; clauses are syntactically recognized but are otherwise non-functional.</source>
          <target state="translated">&lt;code&gt;SAME SORT-MERGE&lt;/code&gt; 과 &lt;code&gt;SAME SORT&lt;/code&gt; 절은 구문 적으로 인식하지만, 그렇지 않은 비 기능입니다.</target>
        </trans-unit>
        <trans-unit id="dab2b898c85f7c018afb0ed20e45b72fb0748073" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;SCROLL&lt;/code&gt; option will cause the entire contents of the screen to be scrolled &lt;code&gt;UP&lt;/code&gt; or &lt;code&gt;DOWN&lt;/code&gt; by the specified number of lines before any value is displayed on the screen. It is syntactically allowable to specify a &lt;code&gt;SCROLL UP&lt;/code&gt; clause as well as a &lt;code&gt;SCROLL DOWN&lt;/code&gt; clause. In such an instance, it is the last one specified that will be honoured. If no &lt;code&gt;LINES&lt;/code&gt; specification is made, &lt;code&gt;1 LINE&lt;/code&gt; will be assumed.</source>
          <target state="translated">&lt;code&gt;SCROLL&lt;/code&gt; 화면의 전체 내용을 발생합니다 옵션을 스크롤 할 &lt;code&gt;UP&lt;/code&gt; 또는 &lt;code&gt;DOWN&lt;/code&gt; 을 임의의 값이 화면에 표시되기 전에 라인의 지정된 번호로. &lt;code&gt;SCROLL DOWN&lt;/code&gt; 절 뿐만 아니라 &lt;code&gt;SCROLL UP&lt;/code&gt; 절도 구문 상 으로 지정할 수 있습니다. 그러한 경우에, 그것은 영광을 받게 될 마지막 지정된 것입니다. &lt;code&gt;LINES&lt;/code&gt; 를 지정 하지 않으면 &lt;code&gt;1 LINE&lt;/code&gt; 으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ad964b5874985a5043e00dc5a5244901edcbac46" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;SET&lt;/code&gt; option tests for whether &lt;var&gt;cdf-variable-1&lt;/var&gt; has been given a value, either via a &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; statement or via a &lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt; without the &lt;code&gt;OFF&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;SET&lt;/code&gt; 의 여부에 대한 옵션을 테스트 &lt;var&gt;cdf-variable-1&lt;/var&gt; 비아 중, 값이 주어졌다 &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; 의 문 또는 비아 &lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt; 를 빼고 &lt;code&gt;OFF&lt;/code&gt; 의 선택.</target>
        </trans-unit>
        <trans-unit id="76ef9d3c020803c6ebc868e2c0e24029462d058c" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;SHARING&lt;/code&gt; clause defines the conditions under which the program will be willing (or not) to allow other programs executing at the same time to access the file. See &lt;a href=&quot;#File-Sharing&quot;&gt;File Sharing&lt;/a&gt;, for the details.</source>
          <target state="translated">&lt;code&gt;SHARING&lt;/code&gt; 절은 프로그램이 동시에 실행 다른 프로그램에서 파일을 액세스 할 수 있도록 기꺼이 (여부) 할 조건을 정의합니다. 자세한 내용은 &lt;a href=&quot;#File-Sharing&quot;&gt;파일 공유를&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="8d3f78c51293bae86a85347517ae96b938a534b0" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;SHARING&lt;/code&gt; clause informs the GnuCOBOL file runtime modules how you are willing to co-exist with any other GnuCOBOL programs that may attempt to open the same file after your program does. See &lt;a href=&quot;#File-Sharing&quot;&gt;File Sharing&lt;/a&gt;, for an explanation of the &lt;code&gt;SHARING&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;SHARING&lt;/code&gt; 절은 당신이 당신의 프로그램이 실행 후 동일한 파일을 열려고 수있는 다른 GnuCOBOL 프로그램과 공존 기꺼이 방법 GnuCOBOL 파일 런타임 모듈을 알려줍니다. &lt;code&gt;SHARING&lt;/code&gt; 절 에 대한 설명은 &lt;a href=&quot;#File-Sharing&quot;&gt;파일 공유를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="10e3d80fd5c4390d09d30ea3a32d8df6b0ad5003" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;STATUS&lt;/code&gt; clause provides another means of returning an exit status. Using the &lt;code&gt;STATUS&lt;/code&gt; clause is functionally equivalent to using the &lt;code&gt;RETURNING&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;STATUS&lt;/code&gt; 절은 종료 상태를 반환하는 또 다른 수단을 제공합니다. 은 Using &lt;code&gt;STATUS&lt;/code&gt; 절은 사용 기능적으로 동일 &lt;code&gt;RETURNING&lt;/code&gt; 절을.</target>
        </trans-unit>
        <trans-unit id="ba4af926283d50a17ca44a126a27f1ccc6c10de3" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;TIMEOUT&lt;/code&gt; option will cause the &lt;code&gt;ACCEPT&lt;/code&gt; to wait no more than the specified number of seconds for input. The wait count may be specified as a positive integer or a numeric data item with a positive value.</source>
          <target state="translated">&lt;code&gt;TIMEOUT&lt;/code&gt; 의 옵션은이 발생합니다 &lt;code&gt;ACCEPT&lt;/code&gt; 입력에 지정된 시간 (초)보다 더 이상 기다릴. 대기 횟수는 양의 정수 또는 양의 값을 가진 숫자 데이터 항목으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ed72fab74c0a97dc6f830da6eb1a40b7d670193" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;UPDATE&lt;/code&gt; option will enable the supplied data field to be updated having been displayed on screen prior to data being entered by overwriting, if needed. When this option is</source>
          <target state="translated">&lt;code&gt;UPDATE&lt;/code&gt; 제공된 데이터 필드있게 옵션은 필요한 경우, 덮어 쓰기에 의해 입력되는 데이터에 앞서 화면 상에 디스플레이 된 갱신한다. 이 옵션이</target>
        </trans-unit>
        <trans-unit id="8f814ee572105020480b2d5c109781818f79475e" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;UPON CRT&lt;/code&gt;,  &lt;code&gt;UPON CRT-UNDER&lt;/code&gt; and  &lt;code&gt;CONVERSION&lt;/code&gt; clauses are syntactically recognized but are otherwise non-functional. They are supported to provide compatibility with COBOL source written for other COBOL implementations.</source>
          <target state="translated">&lt;code&gt;UPON CRT&lt;/code&gt; , &lt;code&gt;UPON CRT-UNDER&lt;/code&gt; 및 &lt;code&gt;CONVERSION&lt;/code&gt; 절은 구문 적으로 인식하지만, 그렇지 않으면 비 기능적된다. 다른 COBOL 구현 용으로 작성된 COBOL 소스와의 호환성을 제공하기 위해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1e9048cbff31d7d051f4f29327c832e57d33478c" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;USE AFTER STANDARD ERROR PROCEDURE&lt;/code&gt; clause defines a declarative procedure invoked any time a failure is encountered with the specified I/O type (or against the specified file(s)).</source>
          <target state="translated">&lt;code&gt;USE AFTER STANDARD ERROR PROCEDURE&lt;/code&gt; 절은 선언적인 절차는가 / O 형 (또는 지정된 파일에 대해 (들)) I 지정과 실패가 발생 될 때마다 호출 정의합니다.</target>
        </trans-unit>
        <trans-unit id="78e8346fd40b55d3f2bd972af7ae0f67898d464a" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;USING&lt;/code&gt; clause defines a list of arguments that may be passed from the calling program to the subprogram. The manner in which any given argument is passed to the subroutine depends upon the &lt;code&gt;BY&lt;/code&gt; clause (if any) coded (or implied) for that argument, as follows:</source>
          <target state="translated">&lt;code&gt;USING&lt;/code&gt; 절은 서브 프로그램으로 호출 프로그램에서 전달 될 수 인수 목록을 정의합니다. 주어진 인수가 서브 루틴에 전달되는 방식은 다음과 같이 해당 인수에 대해 코딩 된 (또는 암시 된) &lt;code&gt;BY&lt;/code&gt; 절 (있는 경우)에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="4d7c539d6785f77f4c0576ee8354e4759a3c153f" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;USING&lt;/code&gt; clause defines the arguments the subroutine entry-point supports. This list of arguments must match up against the &lt;code&gt;USING&lt;/code&gt; clause of any &lt;code&gt;CALL&lt;/code&gt; statement that will be invoking the subroutine using this entry-point.</source>
          <target state="translated">&lt;code&gt;USING&lt;/code&gt; 절은 인수를 서브 루틴 진입 점 지원을 정의합니다. 이 인수 목록은 이 진입 점을 사용하여 서브 루틴을 호출 할 &lt;code&gt;CALL&lt;/code&gt; 문의 &lt;code&gt;USING&lt;/code&gt; 절 과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6c2fe3193a0de8661d51ad83d70795993295d713" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;USING&lt;/code&gt; clause should only be used on the procedure division header of subprograms (subroutines or user-defined functions).</source>
          <target state="translated">&lt;code&gt;USING&lt;/code&gt; 절은 서브 프로그램 (서브 루틴 또는 유저 정의 함수)의 공정 분할 헤더를 사용한다.</target>
        </trans-unit>
        <trans-unit id="d5c83eab589342444dc063907ec418700cab1bd0" translate="yes" xml:space="preserve">
          <source>The  &lt;code&gt;WITH LOCK&lt;/code&gt; option will be functional only if your GnuCOBOL build can support it. GnuCOBOL built for MinGW or native Windows will not, because the Unix &lt;code&gt;fcntl&lt;/code&gt; primitive doesn&amp;rsquo;t exist in those environments. GnuCOBOL built for Cygwin or Unix will.</source>
          <target state="translated">&lt;code&gt;WITH LOCK&lt;/code&gt; 의 당신의 GnuCOBOL 빌드를 지원할 수있는 경우에만 옵션이 작동 될 것입니다. MinGW 또는 네이티브 Windows 용으로 빌드 된 GnuCOBOL은 그렇지 않습니다. Unix &lt;code&gt;fcntl&lt;/code&gt; 프리미티브가 이러한 환경에 존재하지 않기 때문 입니다. Cygwin 또는 Unix 용으로 구축 된 GnuCOBOL이됩니다.</target>
        </trans-unit>
        <trans-unit id="715c7586c26634bd644f6277bf072c6aad3fa9d8" translate="yes" xml:space="preserve">
          <source>The  &lt;em&gt;perform scope&lt;/em&gt; is defined as being the statements within &lt;var&gt;procedure-name-1&lt;/var&gt;, the statements within &lt;var&gt;procedure-name-2&lt;/var&gt; and all statements in all procedures defined between them.</source>
          <target state="translated">&lt;em&gt;수행 범위는&lt;/em&gt; 내 문장 인 것으로 정의되는 &lt;var&gt;procedure-name-1&lt;/var&gt; 내의 명령문 &lt;var&gt;procedure-name-2&lt;/var&gt; 그들 사이에 형성된 모든 절차의 모든 진술.</target>
        </trans-unit>
        <trans-unit id="b5f7198f8fb40448c22faa814a712229edde5a67" translate="yes" xml:space="preserve">
          <source>The &quot;-FSM-&quot; acronyms make it easier to locate the description of the 01-item the status code and message text items belong to.</source>
          <target state="translated">&quot;-FSM-&quot;약어는 상태 코드 및 메시지 텍스트 항목이 속하는 01- 항목에 대한 설명을 쉽게 찾을 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="529b6992580424a3a1799c8f12f4aa404043a076" translate="yes" xml:space="preserve">
          <source>The &quot;modern&quot; languages, like Java, also have their own &quot;boilerplate&quot; infrastructure overhead that must be coded in order to write the logic that is necessary in the program. Take for example the&lt;code&gt;public static void main(String[] arg)&lt;/code&gt;and&lt;code&gt;import java.util.Scanner;&lt;/code&gt;statements. The critics tend to forget about this when they criticize COBOL for it&amp;rsquo;s structural &quot;overhead&quot;.</source>
          <target state="translated">Java와 같은 &quot;현대&quot;언어에는 프로그램에 필요한 논리를 작성하기 위해 코딩해야하는 자체 &quot;보일러 플레이트&quot;인프라 오버 헤드가 있습니다. 예를 들어 &lt;code&gt;public static void main(String[] arg)&lt;/code&gt; 을 &lt;code&gt;import java.util.Scanner;&lt;/code&gt; 진술. 비평가들은 COBOL이 구조적 &quot;오버 헤드&quot;라고 비난 할 때이를 잊어 버리는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1f244259e8e2fa0f6c459ed1bffa3b9a3a03280" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;-FSM-&amp;rdquo; acronyms make it easier to locate the description of the 01-item the status code and message text items belong to.</source>
          <target state="translated">&quot;-FSM-&quot;두문자어를 사용하면 상태 코드와 메시지 텍스트 항목이 속한 01- 항목의 설명을 쉽게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36925241e1190d3fa411748cd3ce02cc95a9c793" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;modern&amp;rdquo; languages, like Java, also have their own &amp;ldquo;boilerplate&amp;rdquo; infrastructure overhead that must be coded in order to write the logic that is necessary in the program. Take for example the &lt;code&gt;public static void main(String[] arg)&lt;/code&gt; and &lt;code&gt;import java.util.Scanner;&lt;/code&gt; statements. The critics tend to forget about this when they criticize COBOL for its structural &amp;ldquo;overhead&amp;rdquo;.</source>
          <target state="translated">Java와 같은 &quot;현대&quot;언어에는 프로그램에 필요한 논리를 작성하기 위해 코딩해야하는 자체 &quot;상용구&quot;인프라 오버 헤드도 있습니다. 예를 들어 &lt;code&gt;public static void main(String[] arg)&lt;/code&gt; 및 &lt;code&gt;import java.util.Scanner;&lt;/code&gt; 진술. 비평가들은 구조적&amp;ldquo;오버 헤드&amp;rdquo;때문에 COBOL을 비판 할 때 이것을 잊어 버리는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ed4c9f9933dd9e4b8da3ca824145866c18f6a63" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="79e19534bd0a509db696aed2669a9388d6786761" translate="yes" xml:space="preserve">
          <source>The &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="4dd012025b215fb64723048dc5378511513993c3" translate="yes" xml:space="preserve">
          <source>The &amp;rsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="291eec57baddb509fdea3caa503c86c1ddaed1da" translate="yes" xml:space="preserve">
          <source>The -d debug flag is specified.</source>
          <target state="translated">-d 디버그 플래그가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="1362295b273781807d4dd883163bd8b930256da8" translate="yes" xml:space="preserve">
          <source>The ... meta character sequence signifies that the syntax element immediately preceding it may be repeated. The ... sequence itself should not be coded. If a syntax diagram contains &lt;code&gt;a b... c&lt;/code&gt;, syntax element &amp;lsquo;</source>
          <target state="translated">... 메타 문자 시퀀스는 바로 앞의 구문 요소가 반복 될 수 있음을 나타냅니다. ... 시퀀스 자체는 코딩되지 않아야합니다. 구문 다이어그램 &lt;code&gt;a b... c&lt;/code&gt; 가 포함 된 경우 구문 요소 '</target>
        </trans-unit>
        <trans-unit id="db50be534d16628548e2d2960f4c7bcdd0ff8e2e" translate="yes" xml:space="preserve">
          <source>The ... meta character sequence signifies that the syntax element immediately preceding it may be repeated. The ... sequence itself should not be coded. If a syntax diagram contains&lt;code&gt;a b... c&lt;/code&gt; syntax element &quot;a&quot; must be followed by at least one &quot;b&quot; element (possibly more) and the entire sequence must be terminated by a &quot;c&quot; syntax element.</source>
          <target state="translated">... 메타 문자 시퀀스는 바로 앞에있는 구문 요소가 반복 될 수 있음을 나타냅니다. ... 시퀀스 자체는 코딩해서는 안됩니다. 구문 다이어그램 &lt;code&gt;a b... c&lt;/code&gt; 구문 요소 가 포함 된 경우 &quot;a&quot;다음에 하나 이상의 &quot;b&quot;요소 (아마도 더 많음)가 와야하며 전체 시퀀스는 &quot;c&quot;구문 요소로 끝나야합니다.</target>
        </trans-unit>
        <trans-unit id="5096c4858ca56d38873ba4dd6117bcda2b86c7f6" translate="yes" xml:space="preserve">
          <source>The 01-level constant is one of four types of compilation-time constants that can be declared within a program. The other three types are &lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt; CDF directive (see &lt;a href=&quot;#g_t_003e_003eDEFINE&quot;&gt;&amp;gt;&amp;gt;DEFINE&lt;/a&gt;) constants, &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; CDF directive (see &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt;SET&lt;/a&gt;) constants and 78-level constants (see &lt;a href=&quot;#g_t78_002dLevel-Data-Items&quot;&gt;78-Level Data Items&lt;/a&gt;).</source>
          <target state="translated">01 레벨 상수는 프로그램 내에서 선언 할 수있는 네 가지 유형의 컴파일 시간 상수 중 하나입니다. 다른 세 가지 유형은 &lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt; CDF 지시문 ( &lt;a href=&quot;#g_t_003e_003eDEFINE&quot;&gt;&amp;gt;&amp;gt; DEFINE&lt;/a&gt; 참조 ) 상수, &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; CDF 지시문 ( &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt; SET&lt;/a&gt; 참조 ) 상수 및 78 레벨 상수 ( &lt;a href=&quot;#g_t78_002dLevel-Data-Items&quot;&gt;78 레벨 데이터 항목 참조&lt;/a&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="02dde9a86042eaa0a1d7d271ae63ee3e64e957db" translate="yes" xml:space="preserve">
          <source>The 01-level constant is one of four types of compilation-time constants that can be declared within a program. The other three types are&lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt;CDF directive (see &lt;a href=&quot;#g_t_003e_003eDEFINE&quot;&gt;&amp;gt;&amp;gt;DEFINE&lt;/a&gt;) constants,&lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt;CDF directive (see &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt;SET&lt;/a&gt;) constants and 78-level constants (see &lt;a href=&quot;#g_t78_002dLevel-Data-Items&quot;&gt;78-Level Data Items&lt;/a&gt;).</source>
          <target state="translated">01 수준 상수는 프로그램 내에서 선언 할 수있는 4 가지 유형의 컴파일 타임 상수 중 하나입니다. 다른 세 가지 유형은 &lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt; CDF 지시문 ( &lt;a href=&quot;#g_t_003e_003eDEFINE&quot;&gt;&amp;gt;&amp;gt; DEFINE&lt;/a&gt; 참조 ) 상수, &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; CDF 지시문 ( &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt; SET&lt;/a&gt; 참조 ) 상수 및 78 레벨 상수 ( &lt;a href=&quot;#g_t78_002dLevel-Data-Items&quot;&gt;78 레벨 데이터 항목 참조&lt;/a&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="17fc061dd6b1c9a35a4c53fa4d1701e3f82a4956" translate="yes" xml:space="preserve">
          <source>The 1st and 2nd examples are referred to as  &lt;em&gt;Subscripting&lt;/em&gt; while the 3rd is known as  &lt;em&gt;Indexing&lt;/em&gt;. The distinction is fairly simple.</source>
          <target state="translated">제 1 회, 2 예는 다음과 같이 언급되어 &lt;em&gt;첨자&lt;/em&gt; 3가로 알려져 동안 &lt;em&gt;인덱싱&lt;/em&gt; . 구분은 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="2203aaa05e683d198781f9270706d87c15e5a5f0" translate="yes" xml:space="preserve">
          <source>The 1st and 2nd examples are referred to as &amp;rsquo;</source>
          <target state="translated">첫 번째와 두 번째 예는 '</target>
        </trans-unit>
        <trans-unit id="adb0c408adad7c2963d9683e7d26945d511c90c3" translate="yes" xml:space="preserve">
          <source>The 7-character family of CPU products the CPU falls into. This will have values such as &quot;A4&quot;, &quot;A10&quot;, &quot;Core i5&quot;, &quot;Core i7&quot;, etc.</source>
          <target state="translated">CPU가 속하는 7 자 CPU 제품군. 여기에는 &quot;A4&quot;, &quot;A10&quot;, &quot;Core i5&quot;, &quot;Core i7&quot;등과 같은 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6697057c3b941cef1c028241eee3cd95f178d68f" translate="yes" xml:space="preserve">
          <source>The 7-character family of CPU products the CPU falls into. This will have values such as &amp;ldquo;A4&amp;rdquo;, &amp;ldquo;A10&amp;rdquo;, &amp;ldquo;Core i5&amp;rdquo;, &amp;ldquo;Core i7&amp;rdquo;, etc.</source>
          <target state="translated">CPU가 속하는 7 자 CPU 제품군입니다. 여기에는 &quot;A4&quot;, &quot;A10&quot;, &quot;Core i5&quot;, &quot;Core i7&quot;등과 같은 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2c194b745f4fe03509d3547dbaf88ba2a05d42b" translate="yes" xml:space="preserve">
          <source>The 78-level constant is one of four types of compilation-time constants that can be declared within a program. The other three types are &lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt; CDF directive (see &lt;a href=&quot;#g_t_003e_003eDEFINE&quot;&gt;&amp;gt;&amp;gt;DEFINE&lt;/a&gt;) constants, &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; CDF directive (see &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt;SET&lt;/a&gt;) constants and 01-level constants (see &lt;a href=&quot;#g_t01_002dLevel-Constants&quot;&gt;01-Level Constants&lt;/a&gt;).</source>
          <target state="translated">78 레벨 상수는 프로그램 내에서 선언 할 수있는 네 가지 유형의 컴파일 시간 상수 중 하나입니다. 다른 세 가지 유형은 &lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt; CDF 지시문 ( &lt;a href=&quot;#g_t_003e_003eDEFINE&quot;&gt;&amp;gt;&amp;gt; DEFINE&lt;/a&gt; 참조 ) 상수, &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; CDF 지시문 ( &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt; SET&lt;/a&gt; 참조 ) 상수 및 01 레벨 상수 ( &lt;a href=&quot;#g_t01_002dLevel-Constants&quot;&gt;01 레벨 상수&lt;/a&gt; 참조 )입니다.</target>
        </trans-unit>
        <trans-unit id="0029539fb2f900dfff21f3e206abf0f50473e6e3" translate="yes" xml:space="preserve">
          <source>The 78-level constant is one of four types of compilation-time constants that can be declared within a program. The other three types are&lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt;CDF directive (see &lt;a href=&quot;#g_t_003e_003eDEFINE&quot;&gt;&amp;gt;&amp;gt;DEFINE&lt;/a&gt;) constants,&lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt;CDF directive (see &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt;SET&lt;/a&gt;) constants and 01-level constants (see &lt;a href=&quot;#g_t01_002dLevel-Constants&quot;&gt;01-Level Constants&lt;/a&gt;).</source>
          <target state="translated">78 레벨 상수는 프로그램 내에서 선언 할 수있는 네 가지 유형의 컴파일 타임 상수 중 하나입니다. 다른 세 가지 유형은 &lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt; CDF 지시문 ( &lt;a href=&quot;#g_t_003e_003eDEFINE&quot;&gt;&amp;gt;&amp;gt; DEFINE&lt;/a&gt; 참조 ) 상수, &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; CDF 지시문 ( &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt; SET&lt;/a&gt; 참조 ) 상수 및 01 레벨 상수 ( &lt;a href=&quot;#g_t01_002dLevel-Constants&quot;&gt;01 레벨 상수&lt;/a&gt; 참조 )입니다.</target>
        </trans-unit>
        <trans-unit id="667d912751614d4776c960330a2ebb17711b8f5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt; CDF directive is one way to create CDF variables that may be processed by other CDF statements such as &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; (see &lt;a href=&quot;#g_t_003e_003eIF&quot;&gt;&amp;gt;&amp;gt;IF&lt;/a&gt;). The &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; CDF directive (see &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt;SET&lt;/a&gt;) provides another way to create them.</source>
          <target state="translated">&lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt; CDF 지정하는 등의 다른 CDF 문에 의해 처리 될 수있다 CDF 변수를 생성하는 한 가지 방법 &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; (참조 &lt;a href=&quot;#g_t_003e_003eIF&quot;&gt;&amp;gt;&amp;gt;를 IF&lt;/a&gt; ). &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; CDF 지침 (참조 &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt; SET는&lt;/a&gt; )을 만들 수있는 또 다른 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="83b519c68907255a9fc3a2ef201d2dd27a00de51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; CDF directive causes the GnuCOBOL compiler to process or ignore COBOL source statements, CDF text-manipulation statements and/or CDF directives depending upon the value of one or more conditional expressions based upon CDF variables.</source>
          <target state="translated">&lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; CDF 지시자 프로세스에 GnuCOBOL 컴파일러 발생하거나 CDF 변수에 기초하여 하나 이상의 조건식의 값에 따라 COBOL 소스 문 CDF 텍스트 조작 명령문 및 / 또는 CDF 지시를 무시.</target>
        </trans-unit>
        <trans-unit id="00aed29f8022c6c47d5a4dd1142f5c5cef31951d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&amp;gt;LEAP-SECONDS&lt;/code&gt; CDF directive is syntactically recognized but is otherwise non-functional.</source>
          <target state="translated">&lt;code&gt;&amp;gt;&amp;gt;LEAP-SECONDS&lt;/code&gt; CDF 지시어는 구문 적으로 인식하지만, 그렇지 않은 비 기능입니다.</target>
        </trans-unit>
        <trans-unit id="e699081e755c9b543fa3b269c8dce98f25a97a21" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; CDF directive provides an alternate means of performing the actions of the &lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;SOURCE&lt;/code&gt; directives, as well as a means of controlling the compiler&amp;rsquo;s</source>
          <target state="translated">&lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; CDF 지시어는의 행동 수행의 대체 수단 제공 &lt;code&gt;&amp;gt;&amp;gt;DEFINE&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;SOURCE&lt;/code&gt; 의 지침을뿐만 아니라, 컴파일러의를 제어하는 방법을</target>
        </trans-unit>
        <trans-unit id="4982995ac0285e486ce499055a22e8656112db46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&amp;gt;SOURCE&lt;/code&gt; CDF directive puts the compiler into &lt;code&gt;FIXED&lt;/code&gt; or &lt;code&gt;FREE&lt;/code&gt; source-code format mode. This, in effect, provides yet another mechanism for controlling the compiler&amp;rsquo;s</source>
          <target state="translated">&lt;code&gt;&amp;gt;&amp;gt;SOURCE&lt;/code&gt; 에 CDF는 지시 풋 컴파일러를 &lt;code&gt;FIXED&lt;/code&gt; 또는 &lt;code&gt;FREE&lt;/code&gt; 소스 코드 포맷 모드. 실제로 이것은 컴파일러의 제어를위한 또 다른 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cc81608c8051cf8280ff12a2614143396e12f488" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; symbol stands for &lt;code&gt;NOT EQUAL TO&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 기호는 의미 &lt;code&gt;NOT EQUAL TO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a3a08899017ca5612956ffd22b62e62720f8b83" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*&lt;/code&gt; operator computes the product of the left and right arguments while the &lt;code&gt;/&lt;/code&gt; operator computes the value of the left argument divided by the value of the right argument. If the right argument has a value of zero, expression evaluation will be prematurely terminated before a value is generated. This may cause program failure at run-time.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 그동안 연산자 좌우 인수의 곱을 계산 &lt;code&gt;/&lt;/code&gt; 의 조작자가 우측 인수의 값으로 나누어 왼쪽 인자의 값을 계산한다. 오른쪽 인수의 값이 0이면 값이 생성되기 전에 식 평가가 조기에 종료됩니다. 이로 인해 런타임에 프로그램 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8c88f621f4aabf6aa7554389ed288aa11694300" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; operator calculates the sum of the left and right arguments while the &lt;code&gt;-&lt;/code&gt; operator computes the value of the right argument subtracted from that of the left argument.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 의 그동안 연산자 좌우 인자의 합을 산출한다 &lt;code&gt;-&lt;/code&gt; 오퍼레이터 왼쪽 인자의 감산 오른쪽 인자의 값을 계산한다.</target>
        </trans-unit>
        <trans-unit id="e275afa7a9c71be2b25fb354aafa0649363305ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;var&gt;device-name-1&lt;/var&gt; IS &lt;var&gt;mnemonic-name-2&lt;/var&gt;&lt;/code&gt; clause allows you to specify an alternate name (&lt;var&gt;device-name-1&lt;/var&gt;) for one of the built-in GnuCOBOL device name &lt;var&gt;mnemonic-name-2&lt;/var&gt;. The list of device names built-into GnuCOBOL, and the physical device associated with that name, are as follows:</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;device-name-1&lt;/var&gt; IS &lt;var&gt;mnemonic-name-2&lt;/var&gt;&lt;/code&gt; 절은 당신이 다른 이름 (지정할 수 있습니다 &lt;var&gt;device-name-1&lt;/var&gt; 중 하나) 내장 GnuCOBOL 장치의 이름을 &lt;var&gt;mnemonic-name-2&lt;/var&gt; . GnuCOBOL에 내장 된 장치 이름 목록 및 해당 이름과 관련된 물리적 장치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7533ca680b65e0a271d0a4a2a45ca7de180ddcf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;var&gt;feature-name-1&lt;/var&gt; IS &lt;var&gt;mnemonic-name-3&lt;/var&gt;&lt;/code&gt; clause allow for mnemonic names to be assigned to up to the 13 printer channel (i.e. vertical page positioning) position feature names &lt;code&gt;C&lt;var&gt;nn&lt;/var&gt;&lt;/code&gt; (&lt;code&gt;&lt;var&gt;nn&lt;/var&gt;=01-12&lt;/code&gt;) and &lt;code&gt;CSP&lt;/code&gt;. Once a channel position has been assigned a mnemonic name, statements of the form &lt;code&gt;WRITE &lt;var&gt;record-name&lt;/var&gt; AFTER ADVANCING &lt;var&gt;mnemonic-name-3&lt;/var&gt;&lt;/code&gt; may be coded to write the specified print record at the channel position assigned to &lt;var&gt;mnemonic-name-3&lt;/var&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;feature-name-1&lt;/var&gt; IS &lt;var&gt;mnemonic-name-3&lt;/var&gt;&lt;/code&gt; 절 (즉 수직 페이지 위치) 위치 기능 이름 니모닉 이름이 13 프린터 채널까지 할당 할 수 있도록 &lt;code&gt;C&lt;var&gt;nn&lt;/var&gt;&lt;/code&gt; ( &lt;code&gt;&lt;var&gt;nn&lt;/var&gt;=01-12&lt;/code&gt; ) 및 &lt;code&gt;CSP&lt;/code&gt; . 채널 위치는 호명 할당되면 형식의 문장 &lt;code&gt;WRITE &lt;var&gt;record-name&lt;/var&gt; AFTER ADVANCING &lt;var&gt;mnemonic-name-3&lt;/var&gt;&lt;/code&gt; 에 할당 된 채널 위치에서 지정된 인쇄 레코드 작성 코딩 될 수도 &lt;var&gt;mnemonic-name-3&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="c8ba518194bcac50caa65451b706c871e1b2621a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) will ignore the Enter key and any other cursor-moving keystrokes that would cause the cursor to move to another screen item</source>
          <target state="translated">&lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 문 (참조 &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;화면 데이터 항목에 동의&lt;/a&gt; Enter 키와 커서를 원인이 다른 커서 이동 키가 다른 화면 항목으로 이동 무시)</target>
        </trans-unit>
        <trans-unit id="1db3487139fee46dec9ae6874a2230fce380ea4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) will ignore the Enter key and any other cursor-moving keystrokes that would cause the cursor to move to another screen item unless the proper amount of data has been entered into the field. Function keys will still be allowed to terminate the &lt;code&gt;ACCEPT&lt;/code&gt;, however.</source>
          <target state="translated">&lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 문 (참조 &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;화면 데이터 항목에 동의&lt;/a&gt; Enter 키를 무시합니다) 다른 커서 이동 키 입력 데이터의 적절한 양을 체결하지 않는 한 커서가 다른 화면 항목으로 이동시킬 것 필드. 그러나 기능 키는 여전히 &lt;code&gt;ACCEPT&lt;/code&gt; 를 종료 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea84da2cf956e64f3be3a531f5ccefb6c554ec8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ACOS&lt;/code&gt; function determines and returns the trigonometric arc-cosine, or inverse cosine, of &lt;var&gt;cosine&lt;/var&gt; value (a numeric literal or data item) supplied as an argument.</source>
          <target state="translated">&lt;code&gt;ACOS&lt;/code&gt; 의 기능을 결정하고, 삼각의 아크 코사인 변환 또는 역 코사인 반환 &lt;var&gt;cosine&lt;/var&gt; 인수로서 값 (숫자 나 문자 데이터 항목).</target>
        </trans-unit>
        <trans-unit id="62f3a3698b5d743231cd43773657f8bd689658cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ADDRESS OF&lt;/code&gt; clause is optional and may be omitted. The presence or absence of this clause has no effect upon the program.</source>
          <target state="translated">&lt;code&gt;ADDRESS OF&lt;/code&gt; 절은 선택 사항이며 생략 할 수있다. 이 조항의 존재 여부는 프로그램에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0223d143baca6e14f106743f7c0475ac95763cda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ADVANCING PAGE&lt;/code&gt; clause will introduce the appropriate number of line-terminator character sequences into the file either before the written record (&lt;code&gt;AFTER ADVANCING&lt;/code&gt;) or after the written record (&lt;code&gt;BEFORE ADVANCING&lt;/code&gt;) so as to force the printer to automatically advance to a new sheet of paper when the file prints. No formfeed characters will be generated when &lt;code&gt;LINAGE&lt;/code&gt; is specified &amp;mdash; instead, it is assumed that the printer to which the report will be printed will be loaded with special forms that conform to the specifications defined by the &lt;code&gt;LINAGE&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;ADVANCING PAGE&lt;/code&gt; 절 (서면 기록하기 전에 두 파일에 라인 종료 문자 시퀀스의 적절한 수를 소개합니다 &lt;code&gt;AFTER ADVANCING&lt;/code&gt; ) 또는 서면 기록 후 ( &lt;code&gt;BEFORE ADVANCING&lt;/code&gt; 자동적으로 새 시트에 진출에 프린터를 강제로 이렇게 같이) 파일이 인쇄 될 때 종이. &lt;code&gt;LINAGE&lt;/code&gt; 가 지정 되면 폼 피드 문자가 생성되지 않습니다. 대신 보고서가 인쇄 될 프린터가 &lt;code&gt;LINAGE&lt;/code&gt; 절에 정의 된 사양을 준수하는 특수 양식으로로드되는 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="6e2ee1b7d44a7b016faeacc1f2219109e6bfa46f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ADVANCING n LINES&lt;/code&gt; clause will introduce the specified number of line-terminator character sequences into the file either before the written record (&lt;code&gt;AFTER ADVANCING&lt;/code&gt;) or after the written record (&lt;code&gt;BEFORE ADVANCING&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;ADVANCING n LINES&lt;/code&gt; 절은 서면 기록하기 전에 (중 파일에 라인 종료 문자 시퀀스의 특정 번호를 소개합니다 &lt;code&gt;AFTER ADVANCING&lt;/code&gt; ) 또는 (서면 기록 후 &lt;code&gt;BEFORE ADVANCING&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bdbdd9b23ae4a3adf0fa9b95f0b6d5f2c5bc7ff6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ALLOCATE&lt;/code&gt; statement is used to dynamically allocate memory at run-time.</source>
          <target state="translated">는 &lt;code&gt;ALLOCATE&lt;/code&gt; 문을 동적으로 실행시 메모리를 할당하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0ea0d4fd04f352980dabe3a16bc787198b92b939" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ALPHABETIC-LOWER&lt;/code&gt; and &lt;code&gt;ALPHABETIC-UPPER&lt;/code&gt; class conditions consider only spaces and the respective type of letters to be acceptable in order to pass such a class test.</source>
          <target state="translated">&lt;code&gt;ALPHABETIC-LOWER&lt;/code&gt; 하고 &lt;code&gt;ALPHABETIC-UPPER&lt;/code&gt; 클래스 조건은 이러한 클래스 테스트를 통과하기 위해 허용되는 것으로 만 공백 문자와의 각각의 유형을 고려한다.</target>
        </trans-unit>
        <trans-unit id="02edb573a71fffd6e4240034051d305b603c3a9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ALPHABETIC&lt;/code&gt; class test considers only upper-case letters, lower-case letters and spaces to be alphabetic in nature.</source>
          <target state="translated">&lt;code&gt;ALPHABETIC&lt;/code&gt; 클래스 테스트는 자연에서 영문자 만 대문자, 소문자 및 공백을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="1782e4c418c6c26c0f5b1875e3afefc2e734ea6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ALTER&lt;/code&gt; statement was used in the early years of the COBOL language to edit the object code of a program &lt;strong&gt;at execution time&lt;/strong&gt;, changing a &lt;code&gt;GO TO&lt;/code&gt; (see &lt;a href=&quot;#Simple-GO-TO&quot;&gt;Simple GO TO&lt;/a&gt;) statement to branch to a spot in the program different than where the &lt;code&gt;GO TO&lt;/code&gt; statement was originally compiled for.</source>
          <target state="translated">&lt;code&gt;ALTER&lt;/code&gt; 의 문은 편집에 COBOL 언어 프로그램의 목적 코드의 초기에 사용 된 &lt;strong&gt;실행 시간의&lt;/strong&gt; 변화, &lt;code&gt;GO TO&lt;/code&gt; 합니다 ( &lt;a href=&quot;#Simple-GO-TO&quot;&gt;단순 GO TO&lt;/a&gt; 곳보다 프로그램의 다른의 지점에 지점에 문을) &lt;code&gt;GO TO&lt;/code&gt; 성명은 원래 컴파일되었습니다.</target>
        </trans-unit>
        <trans-unit id="a4ae323b80c5fc9272db92d8494a26bf38f4d163" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ANY LENGTH&lt;/code&gt; and &lt;code&gt;BASED&lt;/code&gt; (see &lt;a href=&quot;#BASED&quot;&gt;BASED&lt;/a&gt;) clauses cannot be used together in the same data item description.</source>
          <target state="translated">&lt;code&gt;ANY LENGTH&lt;/code&gt; 와 &lt;code&gt;BASED&lt;/code&gt; (참고 &lt;a href=&quot;#BASED&quot;&gt;BASED&lt;/a&gt; ) 조항은 동일한 데이터 항목의 설명을 함께 사용할 수 없다.</target>
        </trans-unit>
        <trans-unit id="278da24b3371049b38bb3202716000550db237ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ASIN&lt;/code&gt; function determines and returns the trigonometric arc-sine, or inverse sine, of &lt;var&gt;sine&lt;/var&gt; value (a numeric literal or data item) supplied as an argument.</source>
          <target state="translated">&lt;code&gt;ASIN&lt;/code&gt; 의 기능을 결정하고, 삼각의 아크 사인, 또는 역 사인 반환 &lt;var&gt;sine&lt;/var&gt; 인수로서 값 (숫자 나 문자 데이터 항목).</target>
        </trans-unit>
        <trans-unit id="de6da974266ec004c3611f0d717c4f1432277c43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AT END-OF-PAGE&lt;/code&gt; clause will be triggered, thus executing &lt;var&gt;imperative-statement-1&lt;/var&gt; (see &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt;), if the &lt;code&gt;WRITE&lt;/code&gt; statement introduces a data line or line-feed character into the file at a line position within the Page Footer area defined by the &lt;code&gt;LINAGE&lt;/code&gt; clause. The &lt;code&gt;NOT AT END-OF-PAGE&lt;/code&gt; clause will be triggered (thus executing &lt;var&gt;imperative-statement-2&lt;/var&gt;) if no end-of-page condition occurred during the &lt;code&gt;WRITE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;AT END-OF-PAGE&lt;/code&gt; 절 따라서 실행 트리거한다 &lt;var&gt;imperative-statement-1&lt;/var&gt; (참조 &lt;a href=&quot;#Imperative-Statement&quot;&gt;명령형 문&lt;/a&gt; )의 경우 &lt;code&gt;WRITE&lt;/code&gt; 의 문 소개 페이지 풋터 영역 내의 행 위치에서 파일로 데이터 선이나 개행 문자 &lt;code&gt;LINAGE&lt;/code&gt; 절에 의해 정의됩니다 . &lt;code&gt;NOT AT END-OF-PAGE&lt;/code&gt; 절 (따라서 실행 트리거됩니다 &lt;var&gt;imperative-statement-2&lt;/var&gt; 에는 끝 페이지 상태가 동안 발생하지 않는 경우) &lt;code&gt;WRITE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24e095f163a3d494ac71a894abbd8cc836812521" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AT END&lt;/code&gt; clause will &amp;mdash; if present &amp;mdash; cause &lt;var&gt;imperative-statement-1&lt;/var&gt; (see &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt;) to be executed if the statement fails due to a file status of 10 (end-of-file). See &lt;a href=&quot;#File-Status-Codes&quot;&gt;File Status Codes&lt;/a&gt;, for a list of possible File Status codes.</source>
          <target state="translated">The &lt;code&gt;AT END&lt;/code&gt; clause will &amp;mdash; if present &amp;mdash; cause &lt;var&gt;imperative-statement-1&lt;/var&gt; (see &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt;) to be executed if the statement fails due to a file status of 10 (end-of-file). See &lt;a href=&quot;#File-Status-Codes&quot;&gt;File Status Codes&lt;/a&gt;, for a list of possible File Status codes.</target>
        </trans-unit>
        <trans-unit id="f9828f2fae8dd75150905123492762f993d97b63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AUTO&lt;/code&gt; (see &lt;a href=&quot;#AUTO&quot;&gt;AUTO&lt;/a&gt;), &lt;code&gt;AUTO-SKIP&lt;/code&gt; (see &lt;a href=&quot;#AUTO_002dSKIP&quot;&gt;AUTO-SKIP&lt;/a&gt;) and &lt;code&gt;AUTOTERMINATE&lt;/code&gt; clauses are interchangeable, and may not be used together in the same data item description.</source>
          <target state="translated">The &lt;code&gt;AUTO&lt;/code&gt; (see &lt;a href=&quot;#AUTO&quot;&gt;AUTO&lt;/a&gt;), &lt;code&gt;AUTO-SKIP&lt;/code&gt; (see &lt;a href=&quot;#AUTO_002dSKIP&quot;&gt;AUTO-SKIP&lt;/a&gt;) and &lt;code&gt;AUTOTERMINATE&lt;/code&gt; clauses are interchangeable, and may not be used together in the same data item description.</target>
        </trans-unit>
        <trans-unit id="140488a17d51e3187792b0a8a8b691f376badd43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AUTO&lt;/code&gt; (see &lt;a href=&quot;#AUTO&quot;&gt;AUTO&lt;/a&gt;), &lt;code&gt;AUTO-SKIP&lt;/code&gt; and &lt;code&gt;AUTOTERMINATE&lt;/code&gt; (see &lt;a href=&quot;#AUTOTERMINATE&quot;&gt;AUTOTERMINATE&lt;/a&gt;) clauses are interchangeable, and may not be used together in the same data item description.</source>
          <target state="translated">The &lt;code&gt;AUTO&lt;/code&gt; (see &lt;a href=&quot;#AUTO&quot;&gt;AUTO&lt;/a&gt;), &lt;code&gt;AUTO-SKIP&lt;/code&gt; and &lt;code&gt;AUTOTERMINATE&lt;/code&gt; (see &lt;a href=&quot;#AUTOTERMINATE&quot;&gt;AUTOTERMINATE&lt;/a&gt;) clauses are interchangeable, and may not be used together in the same data item description.</target>
        </trans-unit>
        <trans-unit id="c42098ebc26a0f038705a75a6561674b05407042" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AUTO&lt;/code&gt;, &lt;code&gt;AUTO-SKIP&lt;/code&gt; (see &lt;a href=&quot;#AUTO_002dSKIP&quot;&gt;AUTO-SKIP&lt;/a&gt;) and &lt;code&gt;AUTOTERMINATE&lt;/code&gt; (see &lt;a href=&quot;#AUTOTERMINATE&quot;&gt;AUTOTERMINATE&lt;/a&gt;) clauses are interchangeable, and may not be used together in the same data item description.</source>
          <target state="translated">The &lt;code&gt;AUTO&lt;/code&gt; , &lt;code&gt;AUTO-SKIP&lt;/code&gt; (see &lt;a href=&quot;#AUTO_002dSKIP&quot;&gt;AUTO-SKIP&lt;/a&gt;) and &lt;code&gt;AUTOTERMINATE&lt;/code&gt; (see &lt;a href=&quot;#AUTOTERMINATE&quot;&gt;AUTOTERMINATE&lt;/a&gt;) clauses are interchangeable, and may not be used together in the same data item description.</target>
        </trans-unit>
        <trans-unit id="2494acc2e7a8ace9860bd76a94afef97aa96655d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BASED&lt;/code&gt; and &lt;code&gt;ANY LENGTH&lt;/code&gt; (see &lt;a href=&quot;#ANY-LENGTH&quot;&gt;ANY LENGTH&lt;/a&gt;) clauses cannot be used together in the same data item description.</source>
          <target state="translated">The &lt;code&gt;BASED&lt;/code&gt; and &lt;code&gt;ANY LENGTH&lt;/code&gt; (see &lt;a href=&quot;#ANY-LENGTH&quot;&gt;ANY LENGTH&lt;/a&gt;) clauses cannot be used together in the same data item description.</target>
        </trans-unit>
        <trans-unit id="d5f91e7da50c21be8c75ebaba2c51b7eed1b301b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BASED&lt;/code&gt; clause may only be used on level 01 and level 77 data items.</source>
          <target state="translated">The &lt;code&gt;BASED&lt;/code&gt; clause may only be used on level 01 and level 77 data items.</target>
        </trans-unit>
        <trans-unit id="0b29fd13b0c160aa683c1a8ec07166d728ecaf61" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEEP&lt;/code&gt; (see &lt;a href=&quot;#BEEP&quot;&gt;BEEP&lt;/a&gt;) and &lt;code&gt;BELL&lt;/code&gt; clauses are interchangeable, and may not be used together in the same data item description.</source>
          <target state="translated">The &lt;code&gt;BEEP&lt;/code&gt; (see &lt;a href=&quot;#BEEP&quot;&gt;BEEP&lt;/a&gt;) and &lt;code&gt;BELL&lt;/code&gt; clauses are interchangeable, and may not be used together in the same data item description.</target>
        </trans-unit>
        <trans-unit id="d8699b815ff4a77819cab01c59b87c6c828d48fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEEP&lt;/code&gt; and &lt;code&gt;BELL&lt;/code&gt; (see &lt;a href=&quot;#BELL&quot;&gt;BELL&lt;/a&gt;) clauses are interchangeable, and may not be used together in the same data item description.</source>
          <target state="translated">The &lt;code&gt;BEEP&lt;/code&gt; and &lt;code&gt;BELL&lt;/code&gt; (see &lt;a href=&quot;#BELL&quot;&gt;BELL&lt;/a&gt;) clauses are interchangeable, and may not be used together in the same data item description.</target>
        </trans-unit>
        <trans-unit id="503eaf118811ae9a6e8d3f7322bc3c4e5b0b82ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BLINK&lt;/code&gt; clause modifies the visual appearance of the displayed field by making the field contents blink.</source>
          <target state="translated">The &lt;code&gt;BLINK&lt;/code&gt; clause modifies the visual appearance of the displayed field by making the field contents blink.</target>
        </trans-unit>
        <trans-unit id="e1a48a32d471c68f0219df0ea8b892ea0120eff4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BY&lt;/code&gt; value, if any, will be added to &lt;var&gt;identifier-2&lt;/var&gt;. If no &lt;code&gt;BY&lt;/code&gt; is specified, it will be treated as if &lt;code&gt;BY 1&lt;/code&gt; had been specified.</source>
          <target state="translated">The &lt;code&gt;BY&lt;/code&gt; value, if any, will be added to &lt;var&gt;identifier-2&lt;/var&gt; . If no &lt;code&gt;BY&lt;/code&gt; is specified, it will be treated as if &lt;code&gt;BY 1&lt;/code&gt; had been specified.</target>
        </trans-unit>
        <trans-unit id="59ba5f8b6b4ce3708bf504e5071d8a575ae607c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BYTE-LENGTH&lt;/code&gt; clause will produce a numeric value for &lt;var&gt;constant-name-1&lt;/var&gt; identical to that which would be returned by the &lt;code&gt;BYTE-LENGTH&lt;/code&gt; intrinsic function executed against &lt;var&gt;identifier-1&lt;/var&gt; or a data item declared with a &lt;code&gt;USAGE&lt;/code&gt; of &lt;var&gt;usage-name&lt;/var&gt;.</source>
          <target state="translated">The &lt;code&gt;BYTE-LENGTH&lt;/code&gt; clause will produce a numeric value for &lt;var&gt;constant-name-1&lt;/var&gt; identical to that which would be returned by the &lt;code&gt;BYTE-LENGTH&lt;/code&gt; intrinsic function executed against &lt;var&gt;identifier-1&lt;/var&gt; or a data item declared with a &lt;code&gt;USAGE&lt;/code&gt; of &lt;var&gt;usage-name&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="79791b31ba9a211cf40a3a1e2d1af33669e5570f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;C$PRINTABLE&lt;/code&gt; subroutine converts the contents of the data-item specified as the first argument to printable characters. Those characters that are deemed printable (as defined by the character set used by &lt;var&gt;data-item&lt;/var&gt;) will remain unchanged, while those that are NOT printable will be converted to the character specified as the second argument.</source>
          <target state="translated">The &lt;code&gt;C$PRINTABLE&lt;/code&gt; subroutine converts the contents of the data-item specified as the first argument to printable characters. Those characters that are deemed printable (as defined by the character set used by &lt;var&gt;data-item&lt;/var&gt; ) will remain unchanged, while those that are NOT printable will be converted to the character specified as the second argument.</target>
        </trans-unit>
        <trans-unit id="a8f587f45de443d3566df2a972e994675c4ee80f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CALL&lt;/code&gt; statement is used to transfer control to a subroutine. See &lt;a href=&quot;#Sub_002dProgramming&quot;&gt;Sub-Programming&lt;/a&gt;, for the specifics of using subprograms with GnuCOBOL programs.</source>
          <target state="translated">The &lt;code&gt;CALL&lt;/code&gt; statement is used to transfer control to a subroutine. See &lt;a href=&quot;#Sub_002dProgramming&quot;&gt;Sub-Programming&lt;/a&gt;, for the specifics of using subprograms with GnuCOBOL programs.</target>
        </trans-unit>
        <trans-unit id="5f85323d661b47ac5a1616445fc3fa60c7f64ab1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CANCEL&lt;/code&gt; statement unloads the dynamically-loadable subprogram module containing the entry-point specified as &lt;var&gt;literal-1&lt;/var&gt; or &lt;var&gt;identifier-1&lt;/var&gt; from memory.</source>
          <target state="translated">The &lt;code&gt;CANCEL&lt;/code&gt; statement unloads the dynamically-loadable subprogram module containing the entry-point specified as &lt;var&gt;literal-1&lt;/var&gt; or &lt;var&gt;identifier-1&lt;/var&gt; from memory.</target>
        </trans-unit>
        <trans-unit id="f4a27cdb3507d2e93bd220bdae742793f50323b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CBL_CLOSE_FILE&lt;/code&gt; subroutine closes a byte stream file previously opened by either the &lt;code&gt;CBL_OPEN_FILE&lt;/code&gt; built-in system subroutine (see &lt;a href=&quot;#CBL_005fOPEN_005fFILE&quot;&gt;CBL_OPEN_FILE&lt;/a&gt;) or &lt;code&gt;CBL_CREATE_FILE&lt;/code&gt; built-in system subroutine (see &lt;a href=&quot;#CBL_005fCREATE_005fFILE&quot;&gt;CBL_CREATE_FILE&lt;/a&gt;) subroutines.</source>
          <target state="translated">The &lt;code&gt;CBL_CLOSE_FILE&lt;/code&gt; subroutine closes a byte stream file previously opened by either the &lt;code&gt;CBL_OPEN_FILE&lt;/code&gt; built-in system subroutine (see &lt;a href=&quot;#CBL_005fOPEN_005fFILE&quot;&gt;CBL_OPEN_FILE&lt;/a&gt;) or &lt;code&gt;CBL_CREATE_FILE&lt;/code&gt; built-in system subroutine (see &lt;a href=&quot;#CBL_005fCREATE_005fFILE&quot;&gt;CBL_CREATE_FILE&lt;/a&gt;) subroutines.</target>
        </trans-unit>
        <trans-unit id="847d9241b5798002d520f534a1379d6672fbdb90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CBL_CREATE_FILE&lt;/code&gt; subroutine creates the new file specified using the file-path argument and opens it for output as a byte-stream file usable by &lt;code&gt;CBL_WRITE_FILE&lt;/code&gt; built-in system subroutine (see &lt;a href=&quot;#CBL_005fWRITE_005fFILE&quot;&gt;CBL_WRITE_FILE&lt;/a&gt;).</source>
          <target state="translated">The &lt;code&gt;CBL_CREATE_FILE&lt;/code&gt; subroutine creates the new file specified using the file-path argument and opens it for output as a byte-stream file usable by &lt;code&gt;CBL_WRITE_FILE&lt;/code&gt; built-in system subroutine (see &lt;a href=&quot;#CBL_005fWRITE_005fFILE&quot;&gt;CBL_WRITE_FILE&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="bde592ae38c0817da21ce8c41a6ce70708349c04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CBL_GC_PRINTABLE&lt;/code&gt; subroutine converts the contents of the data-item specified as the first argument to printable characters.</source>
          <target state="translated">The &lt;code&gt;CBL_GC_PRINTABLE&lt;/code&gt; subroutine converts the contents of the data-item specified as the first argument to printable characters.</target>
        </trans-unit>
        <trans-unit id="1477a9878a93563051a2d45e0bdd3de13732025d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHAINING&lt;/code&gt; clause defines arguments that will be passed to a main program from the operating system. The argument identifiers specified on the &lt;code&gt;CHAINING&lt;/code&gt; clause will be populated by character strings comprised of the parameters specified to the program on the command line that executed it, as follows:</source>
          <target state="translated">The &lt;code&gt;CHAINING&lt;/code&gt; clause defines arguments that will be passed to a main program from the operating system. The argument identifiers specified on the &lt;code&gt;CHAINING&lt;/code&gt; clause will be populated by character strings comprised of the parameters specified to the program on the command line that executed it, as follows:</target>
        </trans-unit>
        <trans-unit id="86b8c23771e3988e02de155674cbcf72eadf9e27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHAINING&lt;/code&gt; term provides one mechanism a programmer may use to retrieve command-line arguments passed to a program at execution time.</source>
          <target state="translated">The &lt;code&gt;CHAINING&lt;/code&gt; term provides one mechanism a programmer may use to retrieve command-line arguments passed to a program at execution time.</target>
        </trans-unit>
        <trans-unit id="20cfe967fb2635fdf2797dedd2ab6586b2e1c39f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHARACTERS&lt;/code&gt; option will match any one single character, regardless of what that character is.</source>
          <target state="translated">The &lt;code&gt;CHARACTERS&lt;/code&gt; option will match any one single character, regardless of what that character is.</target>
        </trans-unit>
        <trans-unit id="dfc8a606234c39b4ecbb4c441c7fa6a0b953cdd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHARACTERS&lt;/code&gt; option will match any one single character. When you use this option, the replacement sub string (see the next item) must be exactly one character in length.</source>
          <target state="translated">The &lt;code&gt;CHARACTERS&lt;/code&gt; option will match any one single character. When you use this option, the replacement sub string (see the next item) must be exactly one character in length.</target>
        </trans-unit>
        <trans-unit id="a40c909c34d3609f4e9fbebb3ed0ef9a73055873" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CLOSE&lt;/code&gt; statement may only be executed against files that have been successfully opened.</source>
          <target state="translated">The &lt;code&gt;CLOSE&lt;/code&gt; statement may only be executed against files that have been successfully opened.</target>
        </trans-unit>
        <trans-unit id="fea898d5d53e6d0013bc24a7a38cf4ceb302db11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CLOSE&lt;/code&gt; statement terminates the program&amp;rsquo;s access to the specified file(s).</source>
          <target state="translated">The &lt;code&gt;CLOSE&lt;/code&gt; statement terminates the program&amp;rsquo;s access to the specified file(s).</target>
        </trans-unit>
        <trans-unit id="2f2632e8258a7ef5b16d86f0edf489015afe1614" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COLUMN&lt;/code&gt; clause provides the means of stating in which column a field should be presented on the console window (screen section) or a report (report section).</source>
          <target state="translated">The &lt;code&gt;COLUMN&lt;/code&gt; clause provides the means of stating in which column a field should be presented on the console window (screen section) or a report (report section).</target>
        </trans-unit>
        <trans-unit id="8bdd07ecb8c78d7f9cacae7e24c6888f86e7e942" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COMMIT&lt;/code&gt; statement performs an &lt;code&gt;UNLOCK&lt;/code&gt; against every currently-open file, but does not close any of the files. See the &lt;code&gt;UNLOCK&lt;/code&gt; statement (see &lt;a href=&quot;#UNLOCK&quot;&gt;UNLOCK&lt;/a&gt;) for additional details.</source>
          <target state="translated">The &lt;code&gt;COMMIT&lt;/code&gt; statement performs an &lt;code&gt;UNLOCK&lt;/code&gt; against every currently-open file, but does not close any of the files. See the &lt;code&gt;UNLOCK&lt;/code&gt; statement (see &lt;a href=&quot;#UNLOCK&quot;&gt;UNLOCK&lt;/a&gt;) for additional details.</target>
        </trans-unit>
        <trans-unit id="17b51041adf332170c36522d8e047cc07b67c5e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COMPUTE&lt;/code&gt; (see &lt;a href=&quot;#COMPUTE&quot;&gt;COMPUTE&lt;/a&gt;) statement will evaluate the arithmetic expression &lt;code&gt;C-D+1&lt;/code&gt; and then save that result in &lt;code&gt;I&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;COMPUTE&lt;/code&gt; (see &lt;a href=&quot;#COMPUTE&quot;&gt;COMPUTE&lt;/a&gt;) statement will evaluate the arithmetic expression &lt;code&gt;C-D+1&lt;/code&gt; and then save that result in &lt;code&gt;I&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="843ddb17793efa77fe8263932c8452a3b8831a25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COMPUTE&lt;/code&gt; statement provides a means of easily performing complex arithmetic operations with a single statement, instead of using cumbersome and possibly confusing sequences of &lt;code&gt;ADD&lt;/code&gt;, &lt;code&gt;SUBTRACT&lt;/code&gt;, &lt;code&gt;MULTIPLY&lt;/code&gt; and &lt;code&gt;DIVIDE&lt;/code&gt; statements. &lt;code&gt;COMPUTE&lt;/code&gt; also allows the use of exponentiation &amp;mdash; an arithmetic operation for which no other statement exists in COBOL.</source>
          <target state="translated">The &lt;code&gt;COMPUTE&lt;/code&gt; statement provides a means of easily performing complex arithmetic operations with a single statement, instead of using cumbersome and possibly confusing sequences of &lt;code&gt;ADD&lt;/code&gt; , &lt;code&gt;SUBTRACT&lt;/code&gt; , &lt;code&gt;MULTIPLY&lt;/code&gt; and &lt;code&gt;DIVIDE&lt;/code&gt; statements. &lt;code&gt;COMPUTE&lt;/code&gt; also allows the use of exponentiation &amp;mdash; an arithmetic operation for which no other statement exists in COBOL.</target>
        </trans-unit>
        <trans-unit id="50ace4f54b8816c2e9f15b750a89b0704b879aa6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COMPUTE&lt;/code&gt; statement supports exponentiation (via the &amp;lsquo;</source>
          <target state="translated">The &lt;code&gt;COMPUTE&lt;/code&gt; statement supports exponentiation (via the &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="d1a21fc38b8fa90b3fabd77ec373eafe00e0e42a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONSTANT&lt;/code&gt; option is valid only in conjunction with &lt;var&gt;literal-1&lt;/var&gt;. When &lt;code&gt;CONSTANT&lt;/code&gt; is specified, the CDF variable that is created may be used within your regular COBOL code as if it were a literal value. Without this option, the CDF variable may only be referenced on other CDF statements. The  &lt;code&gt;OFF&lt;/code&gt; option is used to create a variable without assigning it any value.</source>
          <target state="translated">The &lt;code&gt;CONSTANT&lt;/code&gt; option is valid only in conjunction with &lt;var&gt;literal-1&lt;/var&gt; . When &lt;code&gt;CONSTANT&lt;/code&gt; is specified, the CDF variable that is created may be used within your regular COBOL code as if it were a literal value. Without this option, the CDF variable may only be referenced on other CDF statements. The &lt;code&gt;OFF&lt;/code&gt; option is used to create a variable without assigning it any value.</target>
        </trans-unit>
        <trans-unit id="e7c9bc682ecc14f62dfbbd040956307b2f99bc4a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONTINUE&lt;/code&gt; statement has no effect on the execution of the program.</source>
          <target state="translated">The &lt;code&gt;CONTINUE&lt;/code&gt; statement has no effect on the execution of the program.</target>
        </trans-unit>
        <trans-unit id="448695e618593e72224ee21a490ad502e6ab7358" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONTINUE&lt;/code&gt; statement is a no-operation statement that may be coded anywhere an imperative statement (see &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt;) may be coded.</source>
          <target state="translated">The &lt;code&gt;CONTINUE&lt;/code&gt; statement is a no-operation statement that may be coded anywhere an imperative statement (see &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt;) may be coded.</target>
        </trans-unit>
        <trans-unit id="5d9cfab401430c6439344c49cc913b370f212f94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONTROL FOOTING&lt;/code&gt; and &lt;code&gt;CONTROL HEADING&lt;/code&gt; report groups will be presented in the sequence in which they are listed on the &lt;code&gt;CONTROL&lt;/code&gt; clause.</source>
          <target state="translated">The &lt;code&gt;CONTROL FOOTING&lt;/code&gt; and &lt;code&gt;CONTROL HEADING&lt;/code&gt; report groups will be presented in the sequence in which they are listed on the &lt;code&gt;CONTROL&lt;/code&gt; clause.</target>
        </trans-unit>
        <trans-unit id="b94ff2f4a66703e0e8c77422e690bd9d6426ba57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONVERTING&lt;/code&gt; clause replaces one or more individual characters found in the inspect subject with a different character in much the same manner as is possible with the &lt;code&gt;TRANSFORM&lt;/code&gt; statement (see &lt;a href=&quot;#TRANSFORM&quot;&gt;TRANSFORM&lt;/a&gt;).</source>
          <target state="translated">The &lt;code&gt;CONVERTING&lt;/code&gt; clause replaces one or more individual characters found in the inspect subject with a different character in much the same manner as is possible with the &lt;code&gt;TRANSFORM&lt;/code&gt; statement (see &lt;a href=&quot;#TRANSFORM&quot;&gt;TRANSFORM&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="5d00c36f35e8b0c6f76fa9952986756f6326002a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COPY&lt;/code&gt; statement is case-sensitive on UNIX systems; &lt;code&gt;COPY copybookname&lt;/code&gt; and &lt;code&gt;COPY COPYBOOKNAME&lt;/code&gt; will both fail to locate the &lt;code&gt;CopyBookName&lt;/code&gt; copybook on a UNIX system.</source>
          <target state="translated">The &lt;code&gt;COPY&lt;/code&gt; statement is case-sensitive on UNIX systems; &lt;code&gt;COPY copybookname&lt;/code&gt; and &lt;code&gt;COPY COPYBOOKNAME&lt;/code&gt; will both fail to locate the &lt;code&gt;CopyBookName&lt;/code&gt; copybook on a UNIX system.</target>
        </trans-unit>
        <trans-unit id="116074a32b13ac9c731aa6d4eb84199a532732ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COS&lt;/code&gt; function determines and returns the trigonometric cosine of &lt;var&gt;angle&lt;/var&gt; (a numeric literal or data item) supplied as an argument.</source>
          <target state="translated">The &lt;code&gt;COS&lt;/code&gt; function determines and returns the trigonometric cosine of &lt;var&gt;angle&lt;/var&gt; (a numeric literal or data item) supplied as an argument.</target>
        </trans-unit>
        <trans-unit id="07215873656ed599105ab9ba77c5f61ccc1afb93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CR&lt;/code&gt; symbol is not allowed in conjunction with &amp;lsquo;</source>
          <target state="translated">The &lt;code&gt;CR&lt;/code&gt; symbol is not allowed in conjunction with &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="344f7bca2e2f356501b667a3ebf2b6d3d76b889a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CSP&lt;/code&gt; positioning option stands for &amp;ldquo;No Spacing&amp;rdquo;. Testing on a MinGW build of GnuCOBOL shows that this too results in a formfeed being issued.</source>
          <target state="translated">The &lt;code&gt;CSP&lt;/code&gt; positioning option stands for &amp;ldquo;No Spacing&amp;rdquo;. Testing on a MinGW build of GnuCOBOL shows that this too results in a formfeed being issued.</target>
        </trans-unit>
        <trans-unit id="00773fc8c12b09e960d5f9034f12578d1bef1acf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CURRENCY-SYMBOL&lt;/code&gt; function returns the currency symbol character currently in effect for the locale under which your program is running. On UNIX systems, your locale is established via the   &lt;code&gt;LANG&lt;/code&gt; run-time environment variable (see &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;Run Time Environment Variables&lt;/a&gt;) environment variable. On Windows, the Control Panel&amp;rsquo;s &quot;Regional and Language Options&quot; define the locale.</source>
          <target state="translated">The &lt;code&gt;CURRENCY-SYMBOL&lt;/code&gt; function returns the currency symbol character currently in effect for the locale under which your program is running. On UNIX systems, your locale is established via the &lt;code&gt;LANG&lt;/code&gt; run-time environment variable (see &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;Run Time Environment Variables&lt;/a&gt;) environment variable. On Windows, the Control Panel&amp;rsquo;s &quot;Regional and Language Options&quot; define the locale.</target>
        </trans-unit>
        <trans-unit id="5adf3036fbe52e179c9d8cde5ad7fa269fefb944" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Char-Value&lt;/code&gt; item now has the corresponding &lt;small&gt;ASCII&lt;/small&gt; character value.</source>
          <target state="translated">The &lt;code&gt;Char-Value&lt;/code&gt; item now has the corresponding &lt;small&gt;ASCII&lt;/small&gt; character value.</target>
        </trans-unit>
        <trans-unit id="113934966ded725a5b4c41b438ffff84e60cc8c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DB&lt;/code&gt; symbol is not allowed in conjunction with &amp;lsquo;</source>
          <target state="translated">The &lt;code&gt;DB&lt;/code&gt; symbol is not allowed in conjunction with &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="f1aa2cdb677a8cdcb1e4c127c7cd4fec21218510" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DECLARATIVES&lt;/code&gt; area of the procedure division allows the programmer to define a series of &amp;ldquo;trap&amp;rdquo; procedures (referred to as declarative procedures) capable of intercepting certain events that may occur at program execution time. The syntax diagram above shows the format of a single such procedure.</source>
          <target state="translated">The &lt;code&gt;DECLARATIVES&lt;/code&gt; area of the procedure division allows the programmer to define a series of &amp;ldquo;trap&amp;rdquo; procedures (referred to as declarative procedures) capable of intercepting certain events that may occur at program execution time. The syntax diagram above shows the format of a single such procedure.</target>
        </trans-unit>
        <trans-unit id="559e755d8e524c3dcff57f45bd32b6d481c721e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELETE&lt;/code&gt; statement logically deletes a record from a COBOL file.</source>
          <target state="translated">The &lt;code&gt;DELETE&lt;/code&gt; statement logically deletes a record from a COBOL file.</target>
        </trans-unit>
        <trans-unit id="078ec23e503850f3753cf6cd29c503c78ab1f560" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DETAIL&lt;/code&gt; group which is defined for &lt;var&gt;report-name-1&lt;/var&gt;</source>
          <target state="translated">The &lt;code&gt;DETAIL&lt;/code&gt; group which is defined for &lt;var&gt;report-name-1&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="f27792c67476ba1ce5ad00f630718411370f76af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EMPTY-CHECK&lt;/code&gt; (see &lt;a href=&quot;#EMPTY_002dCHECK&quot;&gt;EMPTY-CHECK&lt;/a&gt;) and &lt;code&gt;REQUIRED&lt;/code&gt; clauses are interchangeable, and may not be used together in the same data item description.</source>
          <target state="translated">The &lt;code&gt;EMPTY-CHECK&lt;/code&gt; (see &lt;a href=&quot;#EMPTY_002dCHECK&quot;&gt;EMPTY-CHECK&lt;/a&gt;) and &lt;code&gt;REQUIRED&lt;/code&gt; clauses are interchangeable, and may not be used together in the same data item description.</target>
        </trans-unit>
        <trans-unit id="d13c785fccd2226fc565ab43cda81aac1789b229" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EMPTY-CHECK&lt;/code&gt; and &lt;code&gt;REQUIRED&lt;/code&gt; (see &lt;a href=&quot;#REQUIRED&quot;&gt;REQUIRED&lt;/a&gt;) clauses are interchangeable, and may not be used together in the same data item description.</source>
          <target state="translated">The &lt;code&gt;EMPTY-CHECK&lt;/code&gt; and &lt;code&gt;REQUIRED&lt;/code&gt; (see &lt;a href=&quot;#REQUIRED&quot;&gt;REQUIRED&lt;/a&gt;) clauses are interchangeable, and may not be used together in the same data item description.</target>
        </trans-unit>
        <trans-unit id="35311847ee16219acad06e2afb3828d75715e3b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;END PROGRAM PROG1.&lt;/code&gt; marker, since it is the last line in the source file, is entirely optional.</source>
          <target state="translated">The &lt;code&gt;END PROGRAM PROG1.&lt;/code&gt; marker, since it is the last line in the source file, is entirely optional.</target>
        </trans-unit>
        <trans-unit id="dd4e1e5e40a638ff4896a1da44881c84087d1602" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ENTRY&lt;/code&gt; statement is used to define an alternate entry-point into a subroutine, along with the arguments that subroutine will be expecting.</source>
          <target state="translated">The &lt;code&gt;ENTRY&lt;/code&gt; statement is used to define an alternate entry-point into a subroutine, along with the arguments that subroutine will be expecting.</target>
        </trans-unit>
        <trans-unit id="b6844c80464e46e35aa24a739ff34f2d4ab17b6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EVALUATE&lt;/code&gt; statement provides a means of defining processing that should take place under any number of mutually-exclusive conditions.</source>
          <target state="translated">The &lt;code&gt;EVALUATE&lt;/code&gt; statement provides a means of defining processing that should take place under any number of mutually-exclusive conditions.</target>
        </trans-unit>
        <trans-unit id="c456e33ad7c4e40bdfb78ec0330feb764ee8ba44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXIT FUNCTION&lt;/code&gt; statement cannot be used anywhere within a subroutine.</source>
          <target state="translated">The &lt;code&gt;EXIT FUNCTION&lt;/code&gt; statement cannot be used anywhere within a subroutine.</target>
        </trans-unit>
        <trans-unit id="c78f6599b1799a78ab626c23edb833932eaba97f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXIT PERFORM&lt;/code&gt; and &lt;code&gt;EXIT PERFORM CYCLE&lt;/code&gt; statements are intended to be used in conjunction with an in-line &lt;code&gt;PERFORM&lt;/code&gt; statement (see &lt;a href=&quot;#Inline-PERFORM&quot;&gt;Inline PERFORM&lt;/a&gt;).</source>
          <target state="translated">The &lt;code&gt;EXIT PERFORM&lt;/code&gt; and &lt;code&gt;EXIT PERFORM CYCLE&lt;/code&gt; statements are intended to be used in conjunction with an in-line &lt;code&gt;PERFORM&lt;/code&gt; statement (see &lt;a href=&quot;#Inline-PERFORM&quot;&gt;Inline PERFORM&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="960acf38c58317c72a302b55e98f09ea411b139b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXIT PROGRAM&lt;/code&gt; and &lt;code&gt;EXIT FUNCTION&lt;/code&gt; statements terminate the execution of a subroutine (i.e. a program that has been CALLed by another) or user-defined function, respectively, returning control back to the calling program.</source>
          <target state="translated">The &lt;code&gt;EXIT PROGRAM&lt;/code&gt; and &lt;code&gt;EXIT FUNCTION&lt;/code&gt; statements terminate the execution of a subroutine (i.e. a program that has been CALLed by another) or user-defined function, respectively, returning control back to the calling program.</target>
        </trans-unit>
        <trans-unit id="19f245c8589a4f593c50c0753aa8faaa0cdfca62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXIT PROGRAM&lt;/code&gt; statement is not legal anywhere within a user-defined function.</source>
          <target state="translated">The &lt;code&gt;EXIT PROGRAM&lt;/code&gt; statement is not legal anywhere within a user-defined function.</target>
        </trans-unit>
        <trans-unit id="21231f38823b421421e38f968141251ef55af48b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXIT&lt;/code&gt; statement is a multi-purpose statement; it may provide a common end point for a series of procedures, exit an in-line &lt;code&gt;PERFORM&lt;/code&gt;, paragraph or section or it may mark the logical end of a subprogram, returning control back to the calling program.</source>
          <target state="translated">The &lt;code&gt;EXIT&lt;/code&gt; statement is a multi-purpose statement; it may provide a common end point for a series of procedures, exit an in-line &lt;code&gt;PERFORM&lt;/code&gt; , paragraph or section or it may mark the logical end of a subprogram, returning control back to the calling program.</target>
        </trans-unit>
        <trans-unit id="d44f79e5aefdc9ae90bbab54ae45c9d346776933" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXTERNAL&lt;/code&gt; clause may only be specified at the 77 or 01 level.</source>
          <target state="translated">The &lt;code&gt;EXTERNAL&lt;/code&gt; clause may only be specified at the 77 or 01 level.</target>
        </trans-unit>
        <trans-unit id="c744859047c315ba78949a6175f62b1c6eb1c67c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Employee&lt;/code&gt; data item consists of two subordinate data items &amp;mdash; an &lt;code&gt;Employee-Name&lt;/code&gt; and an &lt;code&gt;Employment-Dates&lt;/code&gt; data item (presumably there would be a lot of others too, but we don&amp;rsquo;t care about them right now). As the diagram shows, each of those data items are, in turn, broken down into subordinate data items. This hierarchy of data items can get rather &lt;code&gt;deep&lt;/code&gt;, and GnuCOBOL, like other COBOL implementations, can handle up to 49 levels of such hierarchical structures.</source>
          <target state="translated">The &lt;code&gt;Employee&lt;/code&gt; data item consists of two subordinate data items &amp;mdash; an &lt;code&gt;Employee-Name&lt;/code&gt; and an &lt;code&gt;Employment-Dates&lt;/code&gt; data item (presumably there would be a lot of others too, but we don&amp;rsquo;t care about them right now). As the diagram shows, each of those data items are, in turn, broken down into subordinate data items. This hierarchy of data items can get rather &lt;code&gt;deep&lt;/code&gt; , and GnuCOBOL, like other COBOL implementations, can handle up to 49 levels of such hierarchical structures.</target>
        </trans-unit>
        <trans-unit id="6bdeadfd13f17dab03ce0fccfdad57270887124c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FD&lt;/code&gt; cannot be followed by record descriptions. Detailed descriptions of data to be printed to the file will be defined in the &lt;code&gt;REPORT SECTION&lt;/code&gt; (see &lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;).</source>
          <target state="translated">The &lt;code&gt;FD&lt;/code&gt; cannot be followed by record descriptions. Detailed descriptions of data to be printed to the file will be defined in the &lt;code&gt;REPORT SECTION&lt;/code&gt; (see &lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="cf726b5510b698f5290bd18f85f01877d6131c4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FOREVER&lt;/code&gt; option will repeatedly execute the code within the perform scope with no conditions defined for termination of the repetition &amp;mdash; it will be up to the programmer to include an &lt;code&gt;EXIT SECTION&lt;/code&gt; statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;) or &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; statement within the procedure(s) being performed that will break out of the loop.</source>
          <target state="translated">The &lt;code&gt;FOREVER&lt;/code&gt; option will repeatedly execute the code within the perform scope with no conditions defined for termination of the repetition &amp;mdash; it will be up to the programmer to include an &lt;code&gt;EXIT SECTION&lt;/code&gt; statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;) or &lt;code&gt;EXIT PARAGRAPH&lt;/code&gt; statement within the procedure(s) being performed that will break out of the loop.</target>
        </trans-unit>
        <trans-unit id="47c39d3d04385d636465ebe8e0e91946c2be8777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FREE&lt;/code&gt; statement releases memory previously allocated to the program by the &lt;code&gt;ALLOCATE&lt;/code&gt; statement (see &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt;).</source>
          <target state="translated">The &lt;code&gt;FREE&lt;/code&gt; statement releases memory previously allocated to the program by the &lt;code&gt;ALLOCATE&lt;/code&gt; statement (see &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="1541ddaebcbddad875fd1498691786377e268bf6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FROM&lt;/code&gt; (see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;), &lt;code&gt;TO&lt;/code&gt; (see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;), &lt;code&gt;USING&lt;/code&gt; (see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) and &lt;code&gt;VALUE&lt;/code&gt; clauses are mutually-exclusive in any screen section data item&amp;rsquo;s definition.</source>
          <target state="translated">The &lt;code&gt;FROM&lt;/code&gt; (see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;), &lt;code&gt;TO&lt;/code&gt; (see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;), &lt;code&gt;USING&lt;/code&gt; (see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) and &lt;code&gt;VALUE&lt;/code&gt; clauses are mutually-exclusive in any screen section data item&amp;rsquo;s definition.</target>
        </trans-unit>
        <trans-unit id="fe67a35c0e735780beb22a331c716cb25d2a3d32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FROM&lt;/code&gt; (see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;), &lt;code&gt;TO&lt;/code&gt; (see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;), &lt;code&gt;USING&lt;/code&gt; and &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clauses are mutually-exclusive in any screen section data item&amp;rsquo;s definition.</source>
          <target state="translated">The &lt;code&gt;FROM&lt;/code&gt; (see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;), &lt;code&gt;TO&lt;/code&gt; (see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;), &lt;code&gt;USING&lt;/code&gt; and &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clauses are mutually-exclusive in any screen section data item&amp;rsquo;s definition.</target>
        </trans-unit>
        <trans-unit id="1bdb7fc2d4087c0153928e1f25c57ecf947f613c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FROM&lt;/code&gt; (see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;), &lt;code&gt;TO&lt;/code&gt;, &lt;code&gt;USING&lt;/code&gt; (see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) and &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clauses are mutually-exclusive in any screen section data item&amp;rsquo;s definition.</source>
          <target state="translated">The &lt;code&gt;FROM&lt;/code&gt; (see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;), &lt;code&gt;TO&lt;/code&gt; , &lt;code&gt;USING&lt;/code&gt; (see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) and &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clauses are mutually-exclusive in any screen section data item&amp;rsquo;s definition.</target>
        </trans-unit>
        <trans-unit id="01345daee18c648a4469ad749e752fbe90a7cba4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FROM&lt;/code&gt;, &lt;code&gt;TO&lt;/code&gt; (see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;), &lt;code&gt;USING&lt;/code&gt; (see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) and &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clauses are mutually-exclusive in any screen section data item&amp;rsquo;s definition.</source>
          <target state="translated">The &lt;code&gt;FROM&lt;/code&gt; , &lt;code&gt;TO&lt;/code&gt; (see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;), &lt;code&gt;USING&lt;/code&gt; (see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) and &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clauses are mutually-exclusive in any screen section data item&amp;rsquo;s definition.</target>
        </trans-unit>
        <trans-unit id="54bdd3075e39b0c9cabecb7f0863948dd651bfbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FULL&lt;/code&gt; (see &lt;a href=&quot;#FULL&quot;&gt;FULL&lt;/a&gt;) and &lt;code&gt;LENGTH-CHECK&lt;/code&gt; clauses are interchangeable, and may not be used together in the same data item description.</source>
          <target state="translated">The &lt;code&gt;FULL&lt;/code&gt; (see &lt;a href=&quot;#FULL&quot;&gt;FULL&lt;/a&gt;) and &lt;code&gt;LENGTH-CHECK&lt;/code&gt; clauses are interchangeable, and may not be used together in the same data item description.</target>
        </trans-unit>
        <trans-unit id="ba4313ebb23bc375cc6dee1f45360970199cc357" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FULL&lt;/code&gt; and &lt;code&gt;LENGTH-CHECK&lt;/code&gt; (see &lt;a href=&quot;#LENGTH_002dCHECK&quot;&gt;LENGTH-CHECK&lt;/a&gt;) clauses are interchangeable, and may not be used together in the same data item description.</source>
          <target state="translated">The &lt;code&gt;FULL&lt;/code&gt; and &lt;code&gt;LENGTH-CHECK&lt;/code&gt; (see &lt;a href=&quot;#LENGTH_002dCHECK&quot;&gt;LENGTH-CHECK&lt;/a&gt;) clauses are interchangeable, and may not be used together in the same data item description.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
