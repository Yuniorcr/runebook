<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="gnu_cobol">
    <body>
      <group id="gnu_cobol">
        <trans-unit id="d8ca2a7fe9d20757fa054958e759ddbc31c70e89" translate="yes" xml:space="preserve">
          <source>All data used by any COBOL program must be defined in one of the six sections of the data division, depending upon the purpose of the data.</source>
          <target state="translated">COBOL 프로그램에서 사용하는 모든 데이터는 데이터의 목적에 따라 데이터 분할의 6 개 섹션 중 하나에 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="bced720d4dd924cd3c9818ae2d0dff46ad4205ec" translate="yes" xml:space="preserve">
          <source>All destination fields have been fully processed</source>
          <target state="translated">모든 대상 필드가 완전히 처리되었습니다</target>
        </trans-unit>
        <trans-unit id="b2ffb55c8790be0003f9850d39658d38ffc06f1a" translate="yes" xml:space="preserve">
          <source>All executable code statements within a single procedure division paragraph or section.</source>
          <target state="translated">단일 프로 시저 분할 단락 또는 섹션 내의 모든 실행 가능 코드 문.</target>
        </trans-unit>
        <trans-unit id="5dde62fedc386ac283832f33a7a15a32d3d3c6f8" translate="yes" xml:space="preserve">
          <source>All files are initially described to a GnuCOBOL program using a &lt;code&gt;SELECT&lt;/code&gt; statement (see &lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt;). In addition to defining a name by which the file will be referenced within the program, the &lt;code&gt;SELECT&lt;/code&gt; statement will specify the name and path by which the file will be known to the operating system along with its organization, locking and sharing attributes.</source>
          <target state="translated">모든 파일은 처음에 &lt;code&gt;SELECT&lt;/code&gt; 문을 사용하여 GnuCOBOL 프로그램에 설명됩니다 ( &lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt; 참조 ). 프로그램 내에서 파일이 참조되는 이름을 정의하는 것 외에도 &lt;code&gt;SELECT&lt;/code&gt; 문은 파일이 구성, 잠금 및 공유 속성과 함께 운영 체제에 알려지는 이름과 경로를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4a828d776f56b3fa47fbbd3025d63ab153cd3d17" translate="yes" xml:space="preserve">
          <source>All files are initially described to a GnuCOBOL program using a&lt;code&gt;SELECT&lt;/code&gt;statement (see &lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt;). In addition to defining a name by which the file will be referenced within the program, the&lt;code&gt;SELECT&lt;/code&gt;statement will specify the name and path by which the file will be known to the operating system along with its organization, locking and sharing attributes.</source>
          <target state="translated">모든 파일은 처음에 &lt;code&gt;SELECT&lt;/code&gt; 문을 사용하여 GnuCOBOL 프로그램에 설명됩니다 ( &lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt; 참조 ). 프로그램 내에서 파일이 참조 될 이름을 정의하는 것 외에도 &lt;code&gt;SELECT&lt;/code&gt; 문은 파일이 조직, 잠금 및 공유 속성과 함께 운영 체제에 알려질 이름과 경로를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1e328143b72f71fac6248afd324e96319510a5d4" translate="yes" xml:space="preserve">
          <source>All identifiers (&amp;lt;</source>
          <target state="translated">모든 식별자 (&amp;lt;</target>
        </trans-unit>
        <trans-unit id="5ca0e53b0e350d94a5fa89ee5885f52984faf289" translate="yes" xml:space="preserve">
          <source>All identifiers (&lt;var&gt;identifier-2&lt;/var&gt; through &lt;var&gt;identifier-8&lt;/var&gt;) must be numeric, unedited with non-zero positive integer values.</source>
          <target state="translated">모든 식별자 ( &lt;var&gt;identifier-2&lt;/var&gt; ~ &lt;var&gt;identifier-8&lt;/var&gt; )는 0이 아닌 양의 정수 값으로 편집되지 않은 숫자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e70fad951ae8947075621f33a325f3471cd1fadb" translate="yes" xml:space="preserve">
          <source>All identifiers specified on the &lt;code&gt;CHAINING&lt;/code&gt; clause should be defined as &lt;code&gt;PIC X, PIC A&lt;/code&gt;, group items (which are treated implicitly as &lt;code&gt;PIC X&lt;/code&gt;) or as &lt;code&gt;PIC 9 USAGE DISPLAY&lt;/code&gt;. The use of &lt;code&gt;USAGE BINARY&lt;/code&gt; (or the like) data items as &lt;code&gt;CHAINING&lt;/code&gt; arguments is not recommended as all command-line tokens will be retained in their original character form as they are moved into the argument data items.</source>
          <target state="translated">&lt;code&gt;CHAINING&lt;/code&gt; 절 에 지정된 모든 식별자 는 &lt;code&gt;PIC X, PIC A&lt;/code&gt; , 그룹 항목 (암시 적으로 &lt;code&gt;PIC X&lt;/code&gt; 로 처리됨 ) 또는 &lt;code&gt;PIC 9 USAGE DISPLAY&lt;/code&gt; 로 정의되어야 합니다. 의 사용 &lt;code&gt;USAGE BINARY&lt;/code&gt; (등)와 같은 데이터 항목 &lt;code&gt;CHAINING&lt;/code&gt; 의 가 인수 데이터 항목으로 이동하는 모든 명령 줄 토큰은 원래의 문자 형태로 유지 될 것이다 인수는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3f4100a417e93168d069e03cbc8382833c07eca3" translate="yes" xml:space="preserve">
          <source>All identifiers specified on the CHAINING clause should be defined as PIC X, PIC A, group items (which are treated implicitly as PIC X) or as PIC 9 USAGE DISPLAY. The use of USAGE BINARY (or the like) data items as CHAINING arguments is not recommended as all command-line tokens will be retained in their original character form as they are moved into the argument data items.</source>
          <target state="translated">CHAINING 절에 지정된 모든 식별자는 PIC X, PIC A, 그룹 항목 (암시 적으로 PIC X로 처리됨) 또는 PIC 9 USAGE DISPLAY로 정의해야합니다. CHAINING 인수로 USAGE BINARY (또는 이와 유사한) 데이터 항목을 사용하는 것은 권장되지 않습니다. 모든 명령 행 토큰은 인수 데이터 항목으로 이동할 때 원래 문자 형식으로 유지되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1fbafbdaeebb2cfe3180fbaae9955985546e7b97" translate="yes" xml:space="preserve">
          <source>All identifiers used in a &amp;lt;</source>
          <target state="translated">&amp;lt;에 사용 된 모든 식별자</target>
        </trans-unit>
        <trans-unit id="a4c9bb54380885ba739ed3f2a35f0ddd52bd9497" translate="yes" xml:space="preserve">
          <source>All identifiers used in a &lt;var&gt;VARYING-Clause&lt;/var&gt; must be elementary, un-edited numeric data items. All literals must be numeric literals.</source>
          <target state="translated">&lt;var&gt;VARYING-Clause&lt;/var&gt; 에서 사용되는 모든 식별자 는 편집되지 않은 기본 숫자 데이터 항목이어야합니다. 모든 리터럴은 숫자 리터럴이어야합니다.</target>
        </trans-unit>
        <trans-unit id="1d59b3a685a1300faafde8cf819bd33531c1c427" translate="yes" xml:space="preserve">
          <source>All literals (&amp;lt;</source>
          <target state="translated">모든 리터럴 (&amp;lt;</target>
        </trans-unit>
        <trans-unit id="7f2da221d7db26e17531c97e327a09645e86cf24" translate="yes" xml:space="preserve">
          <source>All literals (&lt;var&gt;literal-2&lt;/var&gt; through &lt;var&gt;literal-8&lt;/var&gt;) must be numeric with non-zero positive integer values.</source>
          <target state="translated">모든 리터럴 ( &lt;var&gt;literal-2&lt;/var&gt; ~ &lt;var&gt;literal-8&lt;/var&gt; )은 0이 아닌 양의 정수 값이있는 숫자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="bba7f01f5e187ec9ff4d29b64023e35a6dc2346a" translate="yes" xml:space="preserve">
          <source>All literals and identifiers (except for &amp;lt;</source>
          <target state="translated">모든 리터럴 및 식별자 (&amp;lt;제외</target>
        </trans-unit>
        <trans-unit id="5cd98d07379eee8fe90e5d0b696ec5349e890e94" translate="yes" xml:space="preserve">
          <source>All literals and identifiers (except for &lt;var&gt;identifier-4&lt;/var&gt;) must be explicitly or implicitly defined with a &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of &lt;code&gt;DISPLAY&lt;/code&gt;. Any of the identifiers may be group items.</source>
          <target state="translated">모든 리터럴과 식별자 ( &lt;var&gt;identifier-4&lt;/var&gt; 제외 )는 &lt;code&gt;DISPLAY&lt;/code&gt; 의 &lt;code&gt;USAGE&lt;/code&gt; ( &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt; 참조 )를 사용 하여 명시 적 또는 암시 적으로 정의되어야합니다 . 모든 식별자는 그룹 항목 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="905d5a04e7360c55ec09cb9c601163d00091808f" translate="yes" xml:space="preserve">
          <source>All literals and identifiers must be explicitly or implicitly defined as alphanumeric or alphabetic.</source>
          <target state="translated">모든 리터럴과 식별자는 명시 적 또는 암시 적으로 영숫자 또는 알파벳으로 정의되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ae39d2fdf62dacec472bde2da872c41a110af7cf" translate="yes" xml:space="preserve">
          <source>All locks currently being held for all open files will be released.</source>
          <target state="translated">열려있는 모든 파일에 대해 현재 보유중인 모든 잠금이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="9adaa3e2a38e11cde9aefb1762bf988d9293f6d7" translate="yes" xml:space="preserve">
          <source>All of &amp;lt;</source>
          <target state="translated">모든 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="baf4be88c819899ce7f8a0c327cc7e91512a034a" translate="yes" xml:space="preserve">
          <source>All of &lt;var&gt;identifier-1&lt;/var&gt;, &lt;var&gt;identifier-2&lt;/var&gt; and &lt;var&gt;identifier-3&lt;/var&gt; must either be group items or alphanumeric data items. Numeric data items with a &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of &lt;code&gt;DISPLAY&lt;/code&gt; are accepted, but will generate warning messages from the compiler.</source>
          <target state="translated">모든 &lt;var&gt;identifier-1&lt;/var&gt; , &lt;var&gt;identifier-2&lt;/var&gt; 및 &lt;var&gt;identifier-3&lt;/var&gt; 어느 그룹 항목 또는 영숫자 데이터 아이템이어야한다. A의 숫자 데이터 항목 &lt;code&gt;USAGE&lt;/code&gt; 는 (참조 &lt;a href=&quot;#USAGE&quot;&gt;사용&lt;/a&gt; 의) &lt;code&gt;DISPLAY&lt;/code&gt; 허용됩니다,하지만 컴파일러에서 경고 메시지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ff299c8c3c7d7154628eb1636c0c2f8a75cf5266" translate="yes" xml:space="preserve">
          <source>All or a portion of a person&amp;rsquo;s name. These could be extended to include business names, product names, etc.</source>
          <target state="translated">사람 이름의 전부 또는 일부. 비즈니스 이름, 제품 이름 등을 포함하도록 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83cf0d2d610bbb95f243ddbb03987c0d1c0e4052" translate="yes" xml:space="preserve">
          <source>All or part of a telephone number</source>
          <target state="translated">전화 번호의 전부 또는 일부</target>
        </trans-unit>
        <trans-unit id="d5a601bb2f1d0dfe5966165aa4b93c596039eaaa" translate="yes" xml:space="preserve">
          <source>All other COBOL programming language components are coded in these columns.</source>
          <target state="translated">다른 모든 COBOL 프로그래밍 언어 구성 요소는이 열에 코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="7f15414d483c68f5de0651e9729c6b20245d32ca" translate="yes" xml:space="preserve">
          <source>All sending items have been fully processed</source>
          <target state="translated">모든 발송 품목이 완전히 처리되었습니다</target>
        </trans-unit>
        <trans-unit id="ab6e70e48eee690cdb828113592dd509d85b6471" translate="yes" xml:space="preserve">
          <source>All subroutine arguments are mandatory except where explicitly noted to the contrary</source>
          <target state="translated">반대로 명시 적으로 언급 된 경우를 제외하고 모든 서브 루틴 인수는 필수입니다.</target>
        </trans-unit>
        <trans-unit id="f330e70f20a7bf09b5555bc91b884dfc772bd9ac" translate="yes" xml:space="preserve">
          <source>All sum counters, if any, will be set to 0</source>
          <target state="translated">모든 합계 카운터 (있는 경우)는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ef64daeb21d9797a9d72059f47e97e21999e7009" translate="yes" xml:space="preserve">
          <source>All tests above carried out under Linux with a AMD FX8350 under very low loading prior to the test. I would have also tried on a i7-7700 but that is under Windows 10 and I do not have a GC version on it - Vince.</source>
          <target state="translated">위의 모든 테스트는 테스트 전에 매우 낮은로드에서 AMD FX8350으로 Linux에서 수행되었습니다. 나는 또한 i7-7700에서 시도했지만 Windows 10에서는 GC 버전이 없습니다-Vince.</target>
        </trans-unit>
        <trans-unit id="0ff18c97d087b17a90257f4e255ffcacf0dd0ebc" translate="yes" xml:space="preserve">
          <source>All&lt;code&gt;COPY&lt;/code&gt;statements are located and the contents of the corresponding copybooks inserted into the program source code before the actual compilation process begins. If a copybook contains a&lt;code&gt;COPY&lt;/code&gt;statement, the copybook insertion process will be repeated to resolve the embedded&lt;code&gt;COPY&lt;/code&gt; This will continue until no unresolved&lt;code&gt;COPY&lt;/code&gt;statements remain. At that point, actual program compilation will begin.</source>
          <target state="translated">모든 &lt;code&gt;COPY&lt;/code&gt; 문이 있으며 실제 컴파일 프로세스가 시작되기 전에 해당 카피 북의 내용이 프로그램 소스 코드에 삽입됩니다. 카피 북에 &lt;code&gt;COPY&lt;/code&gt; 문이 포함되어 있으면 카피 북 삽입 프로세스가 반복되어 포함 된 &lt;code&gt;COPY&lt;/code&gt; 를 해결합니다 . 해결되지 않은 &lt;code&gt;COPY&lt;/code&gt; 문이 남아 있지 않을 때까지 계속됩니다. 이 시점에서 실제 프로그램 컴파일이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="a101efb30081b9a7d745fc8788273f95f6c81dae" translate="yes" xml:space="preserve">
          <source>All&lt;code&gt;RENAMES&lt;/code&gt;entries associated with one logical record must immediately follow that record&amp;rsquo;s last data description entry.</source>
          <target state="translated">하나의 논리 레코드와 연관된 모든 &lt;code&gt;RENAMES&lt;/code&gt; 항목은 해당 레코드의 마지막 데이터 설명 항목 바로 뒤에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="94b3fcb864d14fdf63072b5e953169893a577e01" translate="yes" xml:space="preserve">
          <source>All&lt;code&gt;Z&lt;/code&gt;symbols that correspond to character positions in which leading zeros reside will have their &quot;0&quot; values replaced by spaces.</source>
          <target state="translated">선행 0이있는 문자 위치에 해당하는 모든 &lt;code&gt;Z&lt;/code&gt; 기호는 &quot;0&quot;값이 공백으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="e2fe4917dbe0460e482c064e582fd68e6b45be7d" translate="yes" xml:space="preserve">
          <source>Allocate level-01 data items in alphabetical sequence in the program source wherever practical. This will make it vastly easier to locate the definitions of 01-level items in the program source without having to resort to a compilation cross-reference listing and/or text editor &quot;find&quot; command to locate them.</source>
          <target state="translated">가능한 경우 프로그램 소스에서 레벨 01 데이터 항목을 알파벳 순서로 할당하십시오. 이렇게하면 컴파일 상호 참조 목록 및 / 또는 텍스트 편집기 &quot;find&quot;명령을 사용하지 않고도 프로그램 소스에서 01 레벨 항목의 정의를 훨씬 쉽게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b08b97dc30d40ccb411f2a1cedd80cbe9585bd8a" translate="yes" xml:space="preserve">
          <source>Allocate level-01 data items in alphabetical sequence in the program source wherever practical. This will make it vastly easier to locate the definitions of 01-level items in the program source without having to resort to a compilation cross-reference listing and/or text editor &amp;ldquo;find&amp;rdquo; command to locate them.</source>
          <target state="translated">프로그램 소스에서 가능한 한 사전 순으로 레벨 -01 데이터 항목을 할당하십시오. 이렇게하면 컴파일 상호 참조 목록 및 / 또는 텍스트 편집기 &quot;찾기&quot;명령을 사용하여 찾을 필요없이 프로그램 소스에서 01 수준 항목의 정의를 훨씬 쉽게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4e9d8e92f8014702ae38e8fb371d00e48028645" translate="yes" xml:space="preserve">
          <source>Allows for more than 60 seconds per minute.</source>
          <target state="translated">분당 60 초 이상을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a3284dfe19d8cc7737c4e9fb3be014c89e85ac4c" translate="yes" xml:space="preserve">
          <source>Along with every release of the compiler sources is the file</source>
          <target state="translated">컴파일러 소스의 모든 릴리스와 함께 파일</target>
        </trans-unit>
        <trans-unit id="cb73fa20d3b5514b729e8ce7057d939085a58147" translate="yes" xml:space="preserve">
          <source>Alphabet-Name-Clause</source>
          <target state="translated">Alphabet-Name-Clause</target>
        </trans-unit>
        <trans-unit id="e0a4e02665e66436669ab6e50f0a87c76707ccf2" translate="yes" xml:space="preserve">
          <source>Alphabetic Data Item</source>
          <target state="translated">알파벳 데이터 아이템</target>
        </trans-unit>
        <trans-unit id="716942537b1060189a24d41ebb942ff8aff4ce29" translate="yes" xml:space="preserve">
          <source>Alphabetic Data Items</source>
          <target state="translated">알파벳 데이터 항목</target>
        </trans-unit>
        <trans-unit id="a5b153bb4fc31ab35c94e5870d9113346b96bcd9" translate="yes" xml:space="preserve">
          <source>Alphanumeric Data Item</source>
          <target state="translated">영숫자 데이터 항목</target>
        </trans-unit>
        <trans-unit id="649c5b48ff612f6a435f23f0c0255844f9731001" translate="yes" xml:space="preserve">
          <source>Alphanumeric Literal</source>
          <target state="translated">영숫자 리터럴</target>
        </trans-unit>
        <trans-unit id="6f84b4cf9ca4589773fa74426cdcf6f9325a9329" translate="yes" xml:space="preserve">
          <source>Alphanumeric and alphabetic (i.e. text) data items will be initialized to &lt;code&gt;SPACES&lt;/code&gt;.</source>
          <target state="translated">영숫자 및 영문자 (예 : 텍스트) 데이터 항목은 &lt;code&gt;SPACES&lt;/code&gt; 로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="2656ba75be192380d08900217cad46480544bd9b" translate="yes" xml:space="preserve">
          <source>Alphanumeric and alphabetic (i.e. text) data items will be initialized to&lt;code&gt;SPACES&lt;/code&gt;</source>
          <target state="translated">영숫자 및 알파벳 (예 : 텍스트) 데이터 항목은 &lt;code&gt;SPACES&lt;/code&gt; 로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="f920b7d21b8ecbd8b4695faddc87f556ea58d423" translate="yes" xml:space="preserve">
          <source>Alphanumeric data entered into &amp;lt;</source>
          <target state="translated">&amp;lt;숫자에 입력 한 영숫자 데이터</target>
        </trans-unit>
        <trans-unit id="7920cfaa5a189515cb03758a7a4cd6ac6a82f208" translate="yes" xml:space="preserve">
          <source>Alphanumeric data entered into &lt;var&gt;identifier-1&lt;/var&gt;</source>
          <target state="translated">&lt;var&gt;identifier-1&lt;/var&gt; 입력 된 영숫자 데이터</target>
        </trans-unit>
        <trans-unit id="ecaf51d3f7562c9e885bdab2ea79483cc95d31b4" translate="yes" xml:space="preserve">
          <source>Alphanumeric data entered into &lt;var&gt;identifier-1&lt;/var&gt; or any screen data item subordinate to it</source>
          <target state="translated">&lt;var&gt;identifier-1&lt;/var&gt; 입력 된 영숫자 데이터 또는 이에 종속 된 모든 화면 데이터 항목</target>
        </trans-unit>
        <trans-unit id="e9e95358f5f3f1bc5ae1f73309e7cfb3a66ff451" translate="yes" xml:space="preserve">
          <source>Alphanumeric literals and identifiers may optionally be prefixed with the &lt;code&gt;LENGTH OF&lt;/code&gt; clause. The compile-time value generated by this clause will be the number of bytes in the alphanumeric literal or the defined size (in bytes) of the identifier.</source>
          <target state="translated">영숫자 리터럴 및 식별자는 선택적으로 &lt;code&gt;LENGTH OF&lt;/code&gt; 절을 접두어로 사용할 수 있습니다 . 이 절에 의해 생성되는 컴파일 시간 값은 영숫자 리터럴의 바이트 수 또는 정의 된 식별자 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="fb511e236aa6e2cfaebe56e01a86eadcd6899ea5" translate="yes" xml:space="preserve">
          <source>Alphanumeric literals and identifiers may optionally be prefixed with the&lt;code&gt;LENGTH OF&lt;/code&gt;clause. The compile-time value generated by this clause will be the number of bytes in the alphanumeric literal or the defined size (in bytes) of the identifier.</source>
          <target state="translated">영숫자 리터럴 및 식별자는 선택적으로 &lt;code&gt;LENGTH OF&lt;/code&gt; 절이 앞에 붙을 수 있습니다 . 이 절에서 생성 된 컴파일 타임 값은 영숫자 리터럴의 바이트 수 또는 식별자의 정의 된 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="9f735a4ce4da16e0e774362931934a03e2abe2c0" translate="yes" xml:space="preserve">
          <source>Alphanumeric literals may take any of the following forms:</source>
          <target state="translated">영숫자 리터럴은 다음 형식 중 하나를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67ccdee962dd6744e2e7fb3550a928e20903bb57" translate="yes" xml:space="preserve">
          <source>Alphanumeric literals too long to fit on a single line may be continued to the next line in one of two ways:</source>
          <target state="translated">한 줄에 맞지 않는 영숫자 리터럴은 다음 두 가지 방법 중 하나로 다음 줄로 계속 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b89101858aabaab9443207e67caf73e13007c5dc" translate="yes" xml:space="preserve">
          <source>Also used during execution of programs is runtime.cfg also found in /usr/local/share/gnucobol/config for *nix and this file can also be changed to match your environment if needed.</source>
          <target state="translated">또한 프로그램 실행 중에는 runtime.cfg도 사용됩니다. * nix 용 / usr / local / share / gnucobol / config에도 있으며이 파일은 필요한 경우 환경에 맞게 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a61842311a9392e53ec3cc675f32c50be30ff2e1" translate="yes" xml:space="preserve">
          <source>Also used during execution of programs is runtime.cfg also found in &lt;code&gt;/usr/local/share/gnucobol/config&lt;/code&gt; for *nix and this file can also be changed to match your environment if needed. When viewing, note the Default settings.</source>
          <target state="translated">또한 프로그램 실행 중에 사용되는 runtime.cfg는 * nix 용 &lt;code&gt;/usr/local/share/gnucobol/config&lt;/code&gt; 에 있으며이 파일은 필요한 경우 환경에 맞게 변경할 수도 있습니다. 볼 때 기본 설정에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="526fc9f4c2139717bde59d2a98ad02937aa1a3ce" translate="yes" xml:space="preserve">
          <source>Alt Left Dbl Click</source>
          <target state="translated">Alt 왼쪽 더블 클릭</target>
        </trans-unit>
        <trans-unit id="22f2ed163633e373ea00b56f5abe83ae04910267" translate="yes" xml:space="preserve">
          <source>Alt Left Pressed</source>
          <target state="translated">Alt 왼쪽 누름</target>
        </trans-unit>
        <trans-unit id="23b7055795b4ddbb9432dd781445cc8961a2c5c3" translate="yes" xml:space="preserve">
          <source>Alt Left Released</source>
          <target state="translated">Alt 왼쪽 해제</target>
        </trans-unit>
        <trans-unit id="eafa33409c743d0d73d6589d93dcc5ea18ec6518" translate="yes" xml:space="preserve">
          <source>Alt Mid Dbl Click</source>
          <target state="translated">Alt Mid Dbl 클릭</target>
        </trans-unit>
        <trans-unit id="7bc7b17b6c4a3f74474ff662378c4935e82eb3ef" translate="yes" xml:space="preserve">
          <source>Alt Mid Pressed</source>
          <target state="translated">Alt Mid 누름</target>
        </trans-unit>
        <trans-unit id="e18466205ba607cd0851d9019dc68ee96fd8bbbf" translate="yes" xml:space="preserve">
          <source>Alt Mid Released</source>
          <target state="translated">Alt Mid 출시</target>
        </trans-unit>
        <trans-unit id="05ac294d73d26a948209654b49db3de76aa8d598" translate="yes" xml:space="preserve">
          <source>Alt Move</source>
          <target state="translated">Alt 이동</target>
        </trans-unit>
        <trans-unit id="f5a1d9f511598e87bc604c8788bf20997c6db376" translate="yes" xml:space="preserve">
          <source>Alt Right Dbl Click</source>
          <target state="translated">Alt 오른쪽 더블 클릭</target>
        </trans-unit>
        <trans-unit id="b8fb283036059c447ae2e2c8efc6ef5c8b4933f8" translate="yes" xml:space="preserve">
          <source>Alt Right Pressed</source>
          <target state="translated">Alt 오른쪽 누름</target>
        </trans-unit>
        <trans-unit id="3d7e567bef8355b18615a5879060d8feec71b52f" translate="yes" xml:space="preserve">
          <source>Alt Right Released</source>
          <target state="translated">Alt 오른쪽 해제</target>
        </trans-unit>
        <trans-unit id="2562b5fdaae27ec8dfe4a6ab5ca589661b26ff1c" translate="yes" xml:space="preserve">
          <source>Alt Wheel Down</source>
          <target state="translated">Alt 휠 아래로</target>
        </trans-unit>
        <trans-unit id="c1991e30f00c87f23e04146021bcaf0007cfbf58" translate="yes" xml:space="preserve">
          <source>Alt Wheel Left</source>
          <target state="translated">Alt 휠 왼쪽</target>
        </trans-unit>
        <trans-unit id="3a83edf52490a23f0d5faad03b5de7feaac187ab" translate="yes" xml:space="preserve">
          <source>Alt Wheel Right</source>
          <target state="translated">Alt 휠 오른쪽</target>
        </trans-unit>
        <trans-unit id="20cba8b910fc191a0d81deb3aed0ad5ffd982a33" translate="yes" xml:space="preserve">
          <source>Alt Wheel Up</source>
          <target state="translated">Alt 휠 위로</target>
        </trans-unit>
        <trans-unit id="fb3eb3b3b9b95cd33cfd1a58706dcdc7e32750ea" translate="yes" xml:space="preserve">
          <source>Alternate entry-points provide multiple ways in which the same subroutine may be called; presumably, each entry-point will provide some different functionality to the calling program. For example, if you wished to write a subroutine that manipulates &quot;student&quot; records in a database, you might have the primary entry-point name retrieve a student record from the database, while the alternate entry points &lt;code&gt;Add-Student&lt;/code&gt;, &lt;code&gt;Update-Student&lt;/code&gt; and &lt;code&gt;Delete-Student&lt;/code&gt; could provide the alternate functions implied by their entry-point names.</source>
          <target state="translated">대체 진입 점은 동일한 서브 루틴을 호출 할 수있는 여러 방법을 제공합니다. 아마도 각 진입 점은 호출 프로그램에 몇 가지 다른 기능을 제공 할 것입니다. 예를 들어, 데이터베이스에서 &quot;학생&quot;레코드를 조작하는 서브 루틴을 작성하려는 경우 기본 진입 점 이름으로 데이터베이스에서 학생 레코드를 검색하고 대체 진입 점 &lt;code&gt;Add-Student&lt;/code&gt; , &lt;code&gt;Update-Student&lt;/code&gt; 및 &lt;code&gt;Delete-Student&lt;/code&gt; 는 진입 점 이름이 암시하는 대체 기능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d1d2c575fbd8e943786dc808790ede9a6872afe" translate="yes" xml:space="preserve">
          <source>Alternate entry-points provide multiple ways in which the same subroutine may be called; presumably, each entry-point will provide some different functionality to the calling program. For example, if you wished to write a subroutine that manipulates &quot;student&quot; records in a database, you might have the primary entry-point name retrieve a student record from the database, while the alternate entry points&lt;code&gt;Add-Student&lt;/code&gt;&lt;code&gt;Update-Student&lt;/code&gt;and&lt;code&gt;Delete-Student&lt;/code&gt;could provide the alternate functions implied by their entry-point names.</source>
          <target state="translated">대체 진입 점은 동일한 서브 루틴을 호출 할 수있는 여러 가지 방법을 제공합니다. 아마도 각 진입 점은 호출 프로그램에 다른 기능을 제공 할 것입니다. 예를 들어, 데이터베이스에서 &quot;학생&quot;레코드를 조작하는 서브 루틴을 작성하려는 경우 기본 진입 점 이름이 데이터베이스에서 학생 레코드를 검색하는 반면 대체 진입 점 &lt;code&gt;Add-Student&lt;/code&gt; &lt;code&gt;Update-Student&lt;/code&gt; 및 &lt;code&gt;Delete-Student&lt;/code&gt; 은 진입 점 이름으로 암시 된 대체 기능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c58305ee66637fd737c8d0f42036a41ce89d248f" translate="yes" xml:space="preserve">
          <source>Although the specification of one or more &lt;code&gt;KEY&lt;/code&gt; clauses is optional, currently, a table sort with no &lt;code&gt;KEY&lt;/code&gt; specification(s) made on the &lt;code&gt;SORT&lt;/code&gt; statement is unsupported by GnuCOBOL and will be rejected by the compiler.</source>
          <target state="translated">하나 이상의 &lt;code&gt;KEY&lt;/code&gt; 절의 사양은 선택 사항이지만 현재 &lt;code&gt;SORT&lt;/code&gt; 문 에 &lt;code&gt;KEY&lt;/code&gt; 사양 이없는 테이블 정렬 은 GnuCOBOL에서 지원되지 않으며 컴파일러에서 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="b8a86b49c25dd29cdaf3912801cf640a6f60db10" translate="yes" xml:space="preserve">
          <source>Although the specification of one or more KEY clauses is optional, currently, a table sort with no&lt;code&gt;KEY&lt;/code&gt;specification(s) made on the&lt;code&gt;SORT&lt;/code&gt;statement is unsupported by GnuCOBOL and will be rejected by the compiler.</source>
          <target state="translated">하나 이상의 KEY 절 지정이 선택 사항이지만 현재 &lt;code&gt;SORT&lt;/code&gt; 문에서 작성된 &lt;code&gt;KEY&lt;/code&gt; 스펙 이없는 테이블 정렬 은 GnuCOBOL에 의해 지원되지 않으며 컴파일러에 의해 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="456e68703dc0c5e8bb765efa3c274f10d6f546d3" translate="yes" xml:space="preserve">
          <source>An  &lt;code&gt;ASCENDING KEY&lt;/code&gt; or  &lt;code&gt;DESCENDING KEY&lt;/code&gt; clause to specify the field within the table by which all entries in the table are sorted.</source>
          <target state="translated">&lt;code&gt;ASCENDING KEY&lt;/code&gt; 또는 &lt;code&gt;DESCENDING KEY&lt;/code&gt; 절은 테이블의 모든 항목이 분류되어있는 테이블 내의 필드를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="64101a316bca0c8d3d1fc8ac802882312683533a" translate="yes" xml:space="preserve">
          <source>An  &lt;code&gt;INDEXED BY&lt;/code&gt; entry to define an implicit search index data item with a &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of &lt;code&gt;INDEX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;INDEXED BY&lt;/code&gt; 항목은 함께 암시 검색 인덱스 데이터 항목을 정의하는 &lt;code&gt;USAGE&lt;/code&gt; (참조 &lt;a href=&quot;#USAGE&quot;&gt;사용&lt;/a&gt; 의) &lt;code&gt;INDEX&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b54adf1624256b2e5fe75c56f0f3d55b3b88fa10" translate="yes" xml:space="preserve">
          <source>An &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="8ade6575e1d358c15c8e894aa3e622aaf4f135b4" translate="yes" xml:space="preserve">
          <source>An &amp;rsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="0318ae2e728e1d13b787a427c73a7312c196cae3" translate="yes" xml:space="preserve">
          <source>An 01-level item defined in the &lt;code&gt;FILE SECTION&lt;/code&gt; (constituting the layout of a record within a file). Note that these items would probably also have a &amp;ldquo;F-&amp;rdquo; prefix.</source>
          <target state="translated">&lt;code&gt;FILE SECTION&lt;/code&gt; 에 정의 된 01 레벨 항목 (파일 내의 레코드 레이아웃 구성). 이러한 항목에는 &quot;F-&quot;접두사가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e4d3e8918ff2a9cc69187b0c51202b0db70a3b9" translate="yes" xml:space="preserve">
          <source>An 01-level item defined in the FILE SECTION (constituting the layout of a record within a file). Note that these items would probably also have a &quot;F-&quot; prefix.</source>
          <target state="translated">파일 섹션에 정의 된 01 레벨 항목 (파일 내 레코드의 레이아웃 구성). 이 항목들은 아마도 &quot;F-&quot;접두사를 가질 것입니다.</target>
        </trans-unit>
        <trans-unit id="1e2dde7681cab94da1757efd1ada4a5968a92876" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AT END&lt;/code&gt; clause</source>
          <target state="translated">&lt;code&gt;AT END&lt;/code&gt; 의 절</target>
        </trans-unit>
        <trans-unit id="91de7b1bd5b95988a39f01c5efb5b8cfb6f67aab" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AT END&lt;/code&gt; clause detects and handles the case where either form of table search has failed to locate an entry that satisfies the search conditions being used.</source>
          <target state="translated">&lt;code&gt;AT END&lt;/code&gt; 의 절 검출 및 핸들 테이블 검색은 어느 형태 만족 검색 조건이 사용되고 있는지 엔트리를 찾는 데 실패하는 경우.</target>
        </trans-unit>
        <trans-unit id="1bd8a8bae23a635faa67354ffd6b573a24bf1cd5" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;EXIT PERFORM CYCLE&lt;/code&gt; statement will terminate the current iteration of the in-line &lt;code&gt;PERFORM&lt;/code&gt;, giving control to any &lt;code&gt;TIMES&lt;/code&gt;, &lt;code&gt;VARYING&lt;/code&gt; and/or &lt;code&gt;UNTIL&lt;/code&gt; clauses for them to determine if another cycle needs to be performed.</source>
          <target state="translated">&lt;code&gt;EXIT PERFORM CYCLE&lt;/code&gt; 문은 인라인 (in-line)의 현재 반복이 종료됩니다 &lt;code&gt;PERFORM&lt;/code&gt; 을 어느 제어 제공 &lt;code&gt;TIMES&lt;/code&gt; , &lt;code&gt;VARYING&lt;/code&gt; 을 및 / 또는 &lt;code&gt;UNTIL&lt;/code&gt; 다른주기의 요구를 수행 할 경우 그들에게 절을 결정하기를.</target>
        </trans-unit>
        <trans-unit id="54c0515cd69204b6cf4c60a1b0db47680b486de8" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;EXIT PERFORM&lt;/code&gt; statement will terminate the in-line PERFORM outright, transferring control to the first statement following the &lt;code&gt;END-PERFORM&lt;/code&gt; (if there is one) or to the next sentence following the &lt;code&gt;PERFORM&lt;/code&gt; if there is no &lt;code&gt;END-PERFORM&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;EXIT PERFORM&lt;/code&gt; 문이 (가) - 라인은 다음 첫 번째 문으로 제어를 전송, 크게 PERFORM 종료됩니다 &lt;code&gt;END-PERFORM&lt;/code&gt; 또는이 다음에 다음 문장에 (있는 경우) &lt;code&gt;PERFORM&lt;/code&gt; 을 더이없는 경우 &lt;code&gt;END-PERFORM&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f1c3c41fc7be6cbd11929114365ff22159636e8" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;EXIT PROGRAM&lt;/code&gt; statement returns control back to the statement following the &lt;code&gt;CALL&lt;/code&gt; (see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;) of the subprogram. An &lt;code&gt;EXIT FUNCTION&lt;/code&gt; statement returns control back to the processing of the statement in the calling program that invoked the user-defined function.</source>
          <target state="translated">&lt;code&gt;EXIT PROGRAM&lt;/code&gt; 다음은 문으로 반환 제어 다시 &lt;code&gt;CALL&lt;/code&gt; (참조 &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt; 서브 프로그램의). &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 사용자 정의 함수를 호출 호출 프로그램에서 명령문의 처리에 문을 반환 제어 다시.</target>
        </trans-unit>
        <trans-unit id="c5148b03942c9ac22286dc2fb7c34de7a5bda2bc" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;EXTERNAL&lt;/code&gt; item must have a data name and that name cannot be &lt;code&gt;FILLER&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;EXTERNAL&lt;/code&gt; 항목은 데이터 이름이 있어야하고 그 이름이 될 수 없습니다 &lt;code&gt;FILLER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="977eb625a0b59267c72123ca0b4a295a2e50428f" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ON OVERFLOW&lt;/code&gt; clause will allow your program to trap a failure condition that has occurred and handle it gracefully by executing &lt;var&gt;imperative-statement-1&lt;/var&gt; (see &lt;a href=&quot;#Imperative-Statement&quot;&gt;Imperative Statement&lt;/a&gt;). If such a condition occurs at runtime without having one of these clauses specified, an error message will be generated (by the GnuCOBOL runtime library) to the &lt;code&gt;SYSERR&lt;/code&gt; device (pipe 2). The program may also be terminated, depending upon the type and severity of the error.</source>
          <target state="translated">&lt;code&gt;ON OVERFLOW&lt;/code&gt; 절은 함정에 발생한 오류 조건을 프로그램을 허용하고 실행하여 정상적으로 그것을 처리 할 &lt;var&gt;imperative-statement-1&lt;/var&gt; (참조 &lt;a href=&quot;#Imperative-Statement&quot;&gt;명령형 문&lt;/a&gt; ). 이러한 조건이 이러한 절 중 하나를 지정하지 않고 런타임에 발생하면 &lt;code&gt;SYSERR&lt;/code&gt; 장치 (파이프 2)에 오류 메시지가 생성됩니다 (GnuCOBOL 런타임 라이브러리에 의해 ). 오류의 유형과 심각도에 따라 프로그램이 종료 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a26609a6de764b5b9857faecf386444ab8f79386" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;UNLOCK&lt;/code&gt; statement (see &lt;a href=&quot;#UNLOCK&quot;&gt;UNLOCK&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;UNLOCK&lt;/code&gt; 문 (참조 &lt;a href=&quot;#UNLOCK&quot;&gt;UNLOCK를&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="dacec864c98ba47321e339d5b81be46373dc0f91" translate="yes" xml:space="preserve">
          <source>An &lt;var&gt;identifier-1&lt;/var&gt; data item may also be coded as an &lt;var&gt;identifier-2&lt;/var&gt;. Note, however, that the value of such a data item will therefore be included</source>
          <target state="translated">&lt;var&gt;identifier-1&lt;/var&gt; 데이터 항목은 또한로 코딩 될 수도 &lt;var&gt;identifier-2&lt;/var&gt; . 그러나 이러한 데이터 항목의 값은 따라서 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ba87600b329e78baf0e3ac38dbc7f7d88b46a454" translate="yes" xml:space="preserve">
          <source>An &lt;var&gt;identifier-1&lt;/var&gt; or &lt;var&gt;identifier-2&lt;/var&gt; data item may be used as an &lt;var&gt;identifier-3&lt;/var&gt;, if desired.</source>
          <target state="translated">&lt;var&gt;identifier-1&lt;/var&gt; 또는 &lt;var&gt;identifier-2&lt;/var&gt; 데이터 항목은 사용될 수있다 &lt;var&gt;identifier-3&lt;/var&gt; 원한다면.</target>
        </trans-unit>
        <trans-unit id="4725accf032580bb79aab44f026bcbafad236be5" translate="yes" xml:space="preserve">
          <source>An RWCS-generated report to which at least one type of detail group is presented.</source>
          <target state="translated">하나 이상의 유형의 세부 사항 그룹이 제공되는 RWCS 생성 보고서.</target>
        </trans-unit>
        <trans-unit id="52bba8c30c7337908a19fe6d2ad7e2626759f68b" translate="yes" xml:space="preserve">
          <source>An RWCS-generated report to which no detail groups are presented.</source>
          <target state="translated">세부 사항 그룹이 제시되지 않은 RWCS 생성 보고서.</target>
        </trans-unit>
        <trans-unit id="021c274afc42ea781466b7160620421502e62c32" translate="yes" xml:space="preserve">
          <source>An alphanumeric literal</source>
          <target state="translated">영숫자 리터럴</target>
        </trans-unit>
        <trans-unit id="13f94cf8b1227e7450d59a3736c6204064a6a6b2" translate="yes" xml:space="preserve">
          <source>An alphanumeric literal is not valid for use in arithmetic expressions unless it is first converted to it&amp;rsquo;s numeric computational equivalent; there are three numeric conversion intrinsic functions built into GnuCOBOL that can perform this conversion &amp;mdash;&lt;code&gt;NUMVAL&lt;/code&gt;(see &lt;a href=&quot;#NUMVAL&quot;&gt;NUMVAL&lt;/a&gt;),&lt;code&gt;NUMVAL-C&lt;/code&gt;(see &lt;a href=&quot;#NUMVAL_002dC&quot;&gt;NUMVAL-C&lt;/a&gt;) and&lt;code&gt;NUMVAL-F&lt;/code&gt;(see &lt;a href=&quot;#NUMVAL_002dF&quot;&gt;NUMVAL-F&lt;/a&gt;).</source>
          <target state="translated">영숫자 리터럴은 숫자 계산에 해당하는 숫자로 먼저 변환되지 않으면 산술 표현식에 사용할 수 없습니다. 이 변환을 수행 할 수있는 GnuCOBOL에는 세 가지 숫자 변환 고유 함수 ( &lt;code&gt;NUMVAL&lt;/code&gt; ( &lt;a href=&quot;#NUMVAL&quot;&gt;NUMVAL&lt;/a&gt; 참조 ), &lt;code&gt;NUMVAL-C&lt;/code&gt; ( &lt;a href=&quot;#NUMVAL_002dC&quot;&gt;NUMVAL-C&lt;/a&gt; 참조 ) 및 &lt;code&gt;NUMVAL-F&lt;/code&gt; ( &lt;a href=&quot;#NUMVAL_002dF&quot;&gt;NUMVAL-F&lt;/a&gt; 참조 ))가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e97e1a0984593e7e736a0ef561b835c32666ba34" translate="yes" xml:space="preserve">
          <source>An alphanumeric literal is not valid for use in arithmetic expressions unless it is first converted to its numeric computational equivalent; there are three numeric conversion intrinsic functions built into GnuCOBOL that can perform this conversion &amp;mdash; &lt;code&gt;NUMVAL&lt;/code&gt; (see &lt;a href=&quot;#NUMVAL&quot;&gt;NUMVAL&lt;/a&gt;), &lt;code&gt;NUMVAL-C&lt;/code&gt; (see &lt;a href=&quot;#NUMVAL_002dC&quot;&gt;NUMVAL-C&lt;/a&gt;) and &lt;code&gt;NUMVAL-F&lt;/code&gt; (see &lt;a href=&quot;#NUMVAL_002dF&quot;&gt;NUMVAL-F&lt;/a&gt;).</source>
          <target state="translated">영숫자 리터럴은 먼저 해당 숫자 계산으로 변환되지 않는 한 산술 표현식에서 사용할 수 없습니다. 이 변환을 수행 할 수있는 GnuCOBOL에 내장 된 세 가지 숫자 변환 내장 함수 ( &lt;code&gt;NUMVAL&lt;/code&gt; ( &lt;a href=&quot;#NUMVAL&quot;&gt;NUMVAL&lt;/a&gt; 참조 ), &lt;code&gt;NUMVAL-C&lt;/code&gt; ( &lt;a href=&quot;#NUMVAL_002dC&quot;&gt;NUMVAL-C&lt;/a&gt; 참조 ) 및 &lt;code&gt;NUMVAL-F&lt;/code&gt; ( &lt;a href=&quot;#NUMVAL_002dF&quot;&gt;NUMVAL-F&lt;/a&gt; 참조 ))가 있습니다.</target>
        </trans-unit>
        <trans-unit id="58be08d7e828764fa15bd43c0a6d1d0a57c144cb" translate="yes" xml:space="preserve">
          <source>An alphanumeric literal prefixed with an upper- or lower-case &quot;Z&quot; character &amp;mdash; for example,&lt;code&gt;Z'ABC'&lt;/code&gt; These literals are one character longer than the value within apostrophes or quotes would make them appear. The extra character (the last character) will be a null character (comprised entirely of zero bits). These literals are ideal when defining or assigning values to alphanumeric data items that will be passed as arguments to a C subroutine. See &lt;a href=&quot;#Alphanumeric-Literals&quot;&gt;Alphanumeric Literals&lt;/a&gt;.</source>
          <target state="translated">대문자 또는 소문자 &quot;Z&quot;문자 (예 : &lt;code&gt;Z'ABC'&lt;/code&gt; 접두어로 붙은 영숫자 리터럴 이 리터럴은 아포스트로피 또는 따옴표 안의 값보다 한 문자가 길어 표시됩니다. 추가 문자 (마지막 문자)는 널 문자 (전적으로 0 비트로 구성됨)가됩니다. 이 리터럴은 C 서브 루틴에 인수로 전달 될 영숫자 데이터 항목에 값을 정의하거나 지정할 때 이상적입니다. &lt;a href=&quot;#Alphanumeric-Literals&quot;&gt;영숫자 리터럴을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="730c18a8d3a40f54a1446c977a8f89ce279fd28b" translate="yes" xml:space="preserve">
          <source>An alphanumeric literal prefixed with an upper- or lower-case &amp;lsquo;</source>
          <target state="translated">대문자 또는 소문자 '로 시작하는 영숫자 리터럴</target>
        </trans-unit>
        <trans-unit id="e740fb08f67fedac7db1b4b5acaaf62b474c0393" translate="yes" xml:space="preserve">
          <source>An alternate entry point is added to a subroutine using the &lt;code&gt;ENTRY&lt;/code&gt; statement (see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;).</source>
          <target state="translated">대체 진입 점은 &lt;code&gt;ENTRY&lt;/code&gt; 문을 사용하여 서브 루틴에 추가됩니다 ( &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d1c1f98c112351956e6e6801dc71b9249112dee1" translate="yes" xml:space="preserve">
          <source>An alternate entry point is added to a subroutine using the&lt;code&gt;ENTRY&lt;/code&gt;statement (see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;).</source>
          <target state="translated">대체 진입 점은 &lt;code&gt;ENTRY&lt;/code&gt; 문을 사용하여 서브 루틴에 추가됩니다 ( &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8b57102fb1abfe157781294a52b9a4e32346538b" translate="yes" xml:space="preserve">
          <source>An alternative to the use of &lt;code&gt;ACCEPT FROM Runtime-Info&lt;/code&gt; is to use the &lt;code&gt;EXCEPTION-STATUS&lt;/code&gt; intrinsic function (see &lt;a href=&quot;#EXCEPTION_002dSTATUS&quot;&gt;EXCEPTION-STATUS&lt;/a&gt;).</source>
          <target state="translated">의 사용에 대한 대안 &lt;code&gt;ACCEPT FROM Runtime-Info&lt;/code&gt; 사용하는 &lt;code&gt;EXCEPTION-STATUS&lt;/code&gt; (참조 내장 함수를 &lt;a href=&quot;#EXCEPTION_002dSTATUS&quot;&gt;예외 상태&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4e9cd9613bc2af541405ec4b5b278597d8b559dc" translate="yes" xml:space="preserve">
          <source>An alternative to the use of&lt;code&gt;ACCEPT FROM Runtime-Info&lt;/code&gt;is to use the&lt;code&gt;EXCEPTION-STATUS&lt;/code&gt;intrinsic function (see &lt;a href=&quot;#EXCEPTION_002dSTATUS&quot;&gt;EXCEPTION-STATUS&lt;/a&gt;).</source>
          <target state="translated">의 사용에 대한 대안 &lt;code&gt;ACCEPT FROM Runtime-Info&lt;/code&gt; 사용하는 &lt;code&gt;EXCEPTION-STATUS&lt;/code&gt; (참조 내장 함수를 &lt;a href=&quot;#EXCEPTION_002dSTATUS&quot;&gt;예외 상태&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4dd7e177c7f3d9154d5422184b9ed91071f9ad9c" translate="yes" xml:space="preserve">
          <source>An arbitrarily long sequence of statements terminated by a period.</source>
          <target state="translated">임의의 긴 문장 시퀀스는 마침표로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="3a8796c35255f963f524410b42571f347eb41e04" translate="yes" xml:space="preserve">
          <source>An end of page condition occurred</source>
          <target state="translated">페이지 끝 조건이 발생했습니다</target>
        </trans-unit>
        <trans-unit id="5a1e30b56ad12127305ae43936a433a928875a61" translate="yes" xml:space="preserve">
          <source>An error occurred. The &amp;lt;</source>
          <target state="translated">에러 발생됨. &amp;lt;</target>
        </trans-unit>
        <trans-unit id="5cfe3f046c003d5e096bb03b74e4832260d7c325" translate="yes" xml:space="preserve">
          <source>An error occurred. The &lt;var&gt;prog-name-area&lt;/var&gt; contents will be unchanged.</source>
          <target state="translated">오류가 발생하였습니다. &lt;var&gt;prog-name-area&lt;/var&gt; 내용이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7112bc0e61d39be7c53ae09aa4ddfb197467ba5d" translate="yes" xml:space="preserve">
          <source>An error procedure may be used to take whatever actions might be warranted to display additional information or to gracefully close down work in progress, but it cannot</source>
          <target state="translated">추가 정보를 표시하거나 진행중인 작업을 정상적으로 종료하기 위해 보증 할 수있는 모든 조치를 취하기 위해 오류 절차를 사용할 수 있지만이를 수행 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="21a91ab87db3695a69babb64f71c3724f9bf5b86" translate="yes" xml:space="preserve">
          <source>An event that is triggered when a control field on an RWCS-generated report changes value. It is these events that trigger the generation of control heading and control footing groups.</source>
          <target state="translated">RWCS 생성 보고서의 제어 필드 값이 변경 될 때 트리거되는 이벤트입니다. 이러한 이벤트는 제어 표제 및 제어 기초 그룹의 생성을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="0275e9802ec04bd7a2de35caf31f7d1e3f17fac0" translate="yes" xml:space="preserve">
          <source>An example should really help you see this at work. Observe the following code which defines a two-dimensional (3 row by 4 column) table and a pair of numeric data items to be used to subscript references to each element of the table:</source>
          <target state="translated">예를 들어 직장에서 이것을 볼 수 있습니다. 2 차원 (3 행 x 4 열) 테이블과 테이블의 각 요소에 대한 참조를 첨자하는 데 사용할 숫자 데이터 항목 쌍을 정의하는 다음 코드를 관찰하십시오.</target>
        </trans-unit>
        <trans-unit id="c560e4e3334f91095f8e4965e6db0a28094e61df" translate="yes" xml:space="preserve">
          <source>An example will probably help:</source>
          <target state="translated">예를 들어 도움이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="a7e3d12a8215552574605949d37f508e8a513a03" translate="yes" xml:space="preserve">
          <source>An exit procedure, once registered, will trigger whenever a &lt;code&gt;STOP RUN&lt;/code&gt; statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) or a &lt;code&gt;GOBACK&lt;/code&gt; statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) is executed anywhere in the program. The exit procedure may execute whatever code is desired to undertake an orderly shut down of the program. Once the exit procedure terminates by executing an &lt;code&gt;EXIT PROGRAM&lt;/code&gt; statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;) or a &lt;code&gt;GOBACK&lt;/code&gt; statement, the system-standard program termination routine will be executed.</source>
          <target state="translated">일단 등록 된 종료 프로시 저는 &lt;code&gt;STOP RUN&lt;/code&gt; 문 ( &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt; 참조 ) 또는 &lt;code&gt;GOBACK&lt;/code&gt; 문 ( &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt; 참조 )이 프로그램의 어느 곳에서나 실행될 때마다 트리거 됩니다. 종료 절차는 프로그램을 순서대로 종료하기 위해 원하는 코드를 실행할 수 있습니다. &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 문 ( &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt; 참조 ) 또는 &lt;code&gt;GOBACK&lt;/code&gt; 문 을 실행하여 종료 프로 시저가 종료되면 시스템 표준 프로그램 종료 루틴이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="fb9a16fb6f75fe3deeba61d6a7faad0124812994" translate="yes" xml:space="preserve">
          <source>An exit procedure, once registered, will trigger whenever a&lt;code&gt;STOP RUN&lt;/code&gt;statement (see &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt;) or a&lt;code&gt;GOBACK&lt;/code&gt;statement (see &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt;) is executed anywhere in the program. The exit procedure may execute whatever code is desired to undertake an orderly shut down of the program. Once the exit procedure terminates by executing an&lt;code&gt;EXIT PROGRAM&lt;/code&gt;statement (see &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt;) or a&lt;code&gt;GOBACK&lt;/code&gt;statement, the system-standard program termination routine will be executed.</source>
          <target state="translated">일단 등록 된 종료 절차 는 프로그램의 어느 곳에서나 &lt;code&gt;STOP RUN&lt;/code&gt; 문 ( &lt;a href=&quot;#STOP&quot;&gt;STOP&lt;/a&gt; 참조 ) 또는 &lt;code&gt;GOBACK&lt;/code&gt; 문 ( &lt;a href=&quot;#GOBACK&quot;&gt;GOBACK&lt;/a&gt; 참조 )이 실행될 때마다 트리거 됩니다. 종료 프로시 저는 프로그램을 정상적으로 종료하기 위해 원하는 코드를 실행할 수 있습니다. &lt;code&gt;EXIT PROGRAM&lt;/code&gt; 문 ( &lt;a href=&quot;#EXIT&quot;&gt;EXIT&lt;/a&gt; 참조 ) 또는 &lt;code&gt;GOBACK&lt;/code&gt; 문 을 실행하여 종료 프로 시저가 종료되면 시스템 표준 프로그램 종료 루틴이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5e3be0abf77b781e1efcc2df3d201cccfd34f3dc" translate="yes" xml:space="preserve">
          <source>An extension of &lt;code&gt;CALL&lt;/code&gt; allows a call to a &lt;var&gt;Program-Pointer-1&lt;/var&gt; which is preset using &lt;code&gt;SET &lt;var&gt;program-pointer-1&lt;/var&gt; TO ENTRY &lt;var&gt;x&lt;/var&gt;&lt;/code&gt;. Additional the &lt;code&gt;RETURNING&lt;/code&gt; clause may return a data pointer or a &lt;code&gt;PROGRAM-POINTER&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CALL&lt;/code&gt; 을 확장 하면 &lt;code&gt;SET &lt;var&gt;program-pointer-1&lt;/var&gt; TO ENTRY &lt;var&gt;x&lt;/var&gt;&lt;/code&gt; &lt;var&gt;program-pointer-1&lt;/var&gt; TO ENTRY &lt;var&gt;x&lt;/var&gt; 를 사용하여 미리 설정된 &lt;var&gt;Program-Pointer-1&lt;/var&gt; 을 호출 할 수 있습니다 . 추가로 &lt;code&gt;RETURNING&lt;/code&gt; 절은 데이터 포인터 또는 &lt;code&gt;PROGRAM-POINTER&lt;/code&gt; 를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c14e976d4de1adc1800e6eceea55c8ee523630af" translate="yes" xml:space="preserve">
          <source>An input procedure should be terminated in the same way a procedural &lt;code&gt;PERFORM&lt;/code&gt; statement would be.</source>
          <target state="translated">입력 프로시 저는 프로 시저 &lt;code&gt;PERFORM&lt;/code&gt; 문과 동일한 방식으로 종료되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="aae7294fe3bc4c3ec605f5a18822cf8153c72352" translate="yes" xml:space="preserve">
          <source>An input procedure should be terminated in the same way a procedural&lt;code&gt;PERFORM&lt;/code&gt;statement would be.</source>
          <target state="translated">입력 절차는 절차 적 &lt;code&gt;PERFORM&lt;/code&gt; 문과 같은 방식으로 종료해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1f1e7d2ce85fb76385f43efe9e1ec5272608971a" translate="yes" xml:space="preserve">
          <source>An optional  &lt;code&gt;NOT INVALID KEY&lt;/code&gt; clause will cause &lt;var&gt;imperative-statement-2&lt;/var&gt; to be executed if the statement&amp;rsquo;s execution was successful.</source>
          <target state="translated">선택적 &lt;code&gt;NOT INVALID KEY&lt;/code&gt; 절은 명령문 실행이 성공한 경우 &lt;var&gt;imperative-statement-2&lt;/var&gt; 가 실행되도록합니다.</target>
        </trans-unit>
        <trans-unit id="72f7042516527f7d9425a0b86b8e54bffd9c8187" translate="yes" xml:space="preserve">
          <source>An optional  &lt;code&gt;NOT ON EXCEPTION&lt;/code&gt; clause will cause &lt;var&gt;imperative-statement-2&lt;/var&gt; to be executed if the statement&amp;rsquo;s execution was successful.</source>
          <target state="translated">선택적 &lt;code&gt;NOT ON EXCEPTION&lt;/code&gt; 절은 명령문 실행이 성공한 경우 &lt;var&gt;imperative-statement-2&lt;/var&gt; 가 실행되도록합니다.</target>
        </trans-unit>
        <trans-unit id="bcad9a99b7b4455e064dd67d054659b3cbe680ff" translate="yes" xml:space="preserve">
          <source>An optional  &lt;code&gt;NOT ON OVERFLOW&lt;/code&gt; clause will cause &lt;var&gt;imperative-statement-2&lt;/var&gt; to be executed if the statement&amp;rsquo;s execution was successful.</source>
          <target state="translated">선택적 &lt;code&gt;NOT ON OVERFLOW&lt;/code&gt; 절은 명령문 실행이 성공한 경우 &lt;var&gt;imperative-statement-2&lt;/var&gt; 가 실행되도록합니다.</target>
        </trans-unit>
        <trans-unit id="5602bfc4c8e7b5764f2758c493dfd16698970061" translate="yes" xml:space="preserve">
          <source>An optional  &lt;code&gt;NOT ON SIZE ERROR&lt;/code&gt; clause will cause &lt;var&gt;imperative-statement-2&lt;/var&gt; to be executed if the arithmetic statement&amp;rsquo;s execution was successful.</source>
          <target state="translated">선택적 &lt;code&gt;NOT ON SIZE ERROR&lt;/code&gt; 절은 산술 명령문의 실행이 성공한 경우 &lt;var&gt;imperative-statement-2&lt;/var&gt; 가 실행되도록합니다.</target>
        </trans-unit>
        <trans-unit id="5229c512e61b0d727d9911bde06163ee5ecfc0e1" translate="yes" xml:space="preserve">
          <source>An optional&lt;code&gt;NOT INVALID KEY&lt;/code&gt;</source>
          <target state="translated">선택적 &lt;code&gt;NOT INVALID KEY&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b5cb62f1f63fe844a97bd26c7f5233c9b0ae60a" translate="yes" xml:space="preserve">
          <source>An optional&lt;code&gt;NOT ON EXCEPTION&lt;/code&gt;</source>
          <target state="translated">선택적인 &lt;code&gt;NOT ON EXCEPTION&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9aa73b992453b6eae92e838025cd2f18049b366a" translate="yes" xml:space="preserve">
          <source>An optional&lt;code&gt;NOT ON OVERFLOW&lt;/code&gt;</source>
          <target state="translated">옵션 &lt;code&gt;NOT ON OVERFLOW&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52b717f180698740ad6d13f32e0cf960140d50af" translate="yes" xml:space="preserve">
          <source>An optional&lt;code&gt;NOT ON SIZE ERROR&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;NOT ON SIZE ERROR&lt;/code&gt; 옵션</target>
        </trans-unit>
        <trans-unit id="af24938e4c0e59510f17268d047d6da0c2218adc" translate="yes" xml:space="preserve">
          <source>An otherwise numeric data item whose &lt;code&gt;PICTURE&lt;/code&gt; (see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause also contains any of the editing symbols &amp;lsquo;</source>
          <target state="translated">그의 다르게 숫자 데이터 항목 &lt;code&gt;PICTURE&lt;/code&gt; (참조 &lt;a href=&quot;#PICTURE&quot;&gt;그림을&lt;/a&gt; 절은 또한 편집 상징 '중 하나를 포함)</target>
        </trans-unit>
        <trans-unit id="7ad9ca471559f5b0c3dd250bee53f0867b2ea95c" translate="yes" xml:space="preserve">
          <source>An otherwise numeric data item whose&lt;code&gt;PICTURE&lt;/code&gt;(see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause also contains any of the editing symbols&lt;code&gt;$&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;+&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;0&lt;/code&gt;(zero),&lt;code&gt;B&lt;/code&gt;&lt;code&gt;CR&lt;/code&gt;&lt;code&gt;DB&lt;/code&gt;or&lt;code&gt;Z&lt;/code&gt; Numeric edited data items are not eligible to serve as table subscripts or source arguments on arithmetic statements.</source>
          <target state="translated">그의 다르게 숫자 데이터 항목 &lt;code&gt;PICTURE&lt;/code&gt; (참조 &lt;a href=&quot;#PICTURE&quot;&gt;사진&lt;/a&gt; ) 절은 또한 편집 기호의 포함 &lt;code&gt;$&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;+&lt;/code&gt; 를 &lt;code&gt;,&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;0&lt;/code&gt; (영), &lt;code&gt;B&lt;/code&gt; &lt;code&gt;CR&lt;/code&gt; &lt;code&gt;DB&lt;/code&gt; 또는 &lt;code&gt;Z&lt;/code&gt; 숫자 편집 된 데이터 항목은 산술 명령문에서 테이블 첨자 또는 소스 인수로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="436ca0d621b5c92dd61689d745fef4435d0efcf9" translate="yes" xml:space="preserve">
          <source>An output procedure should be terminated in the same way a procedural &lt;code&gt;PERFORM&lt;/code&gt; statement would be.</source>
          <target state="translated">출력 프로시 저는 프로 시저 &lt;code&gt;PERFORM&lt;/code&gt; 문과 동일한 방식으로 종료되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="0a1a19a2a0c7790b3edb9dde7b386a0e161f21cf" translate="yes" xml:space="preserve">
          <source>An output procedure should be terminated in the same way a procedural &lt;code&gt;PERFORM&lt;/code&gt; statement would be. Usually, this action will be taken once the &lt;code&gt;RETURN&lt;/code&gt; statement indicates that all records in the merge work file have been processed, but termination could occur at</source>
          <target state="translated">출력 프로시 저는 프로 시저 &lt;code&gt;PERFORM&lt;/code&gt; 문과 동일한 방식으로 종료되어야 합니다. 일반적으로이 작업은 &lt;code&gt;RETURN&lt;/code&gt; 문이 병합 작업 파일의 모든 레코드가 처리되었음을 나타내면 수행되지만 다음에서 종료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90d90822998a8c58f9ffe74634b5f07c27637510" translate="yes" xml:space="preserve">
          <source>An output procedure should be terminated in the same way a procedural&lt;code&gt;PERFORM&lt;/code&gt;statement would be.</source>
          <target state="translated">출력 절차는 절차가 같은 방법으로 종료되어야 &lt;code&gt;PERFORM&lt;/code&gt; 문이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="be9710b378e25551b79a38b49fb569b6027836cb" translate="yes" xml:space="preserve">
          <source>An output procedure should be terminated in the same way a procedural&lt;code&gt;PERFORM&lt;/code&gt;statement would be. Usually, this action will be taken once the&lt;code&gt;RETURN&lt;/code&gt;statement indicates that all records in the merge work file have been processed, but termination could occur at</source>
          <target state="translated">출력 절차는 절차가 같은 방법으로 종료되어야 &lt;code&gt;PERFORM&lt;/code&gt; 문이 될 것입니다. 일반적으로이 작업은 &lt;code&gt;RETURN&lt;/code&gt; 문에서 병합 작업 파일의 모든 레코드가 처리되었지만 종료시 발생할 수 있음을 나타내면 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="840d1885430c345e3368202fe5d10d0ccd03e6b4" translate="yes" xml:space="preserve">
          <source>An&lt;code&gt;ASCENDING KEY&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ASCENDING KEY&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa7385a0eb8f460df8fd378a7433597df0140d47" translate="yes" xml:space="preserve">
          <source>An&lt;code&gt;AT END&lt;/code&gt;clause</source>
          <target state="translated">&lt;code&gt;AT END&lt;/code&gt; 의 절</target>
        </trans-unit>
        <trans-unit id="e18c1c4bc70b6f7e71f3b7dedee4cf0a608296f2" translate="yes" xml:space="preserve">
          <source>An&lt;code&gt;AT END&lt;/code&gt;clause detects and handles the case where either form of table search has failed to locate an entry that satisfies the search conditions being used.</source>
          <target state="translated">&lt;code&gt;AT END&lt;/code&gt; 의 절 검출 및 핸들 테이블 검색은 어느 형태 만족 검색 조건이 사용되고 있는지 엔트리를 찾는 데 실패하는 경우.</target>
        </trans-unit>
        <trans-unit id="cedc455b517c6a18d97fd38d04af7e70791575e7" translate="yes" xml:space="preserve">
          <source>An&lt;code&gt;EXIT PERFORM CYCLE&lt;/code&gt;statement will terminate the current iteration of the in-line&lt;code&gt;PERFORM&lt;/code&gt; giving control to any&lt;code&gt;TIMES&lt;/code&gt;&lt;code&gt;VARYING&lt;/code&gt;and/or&lt;code&gt;UNTIL&lt;/code&gt;clauses for them to determine if another cycle needs to be performed.</source>
          <target state="translated">&lt;code&gt;EXIT PERFORM CYCLE&lt;/code&gt; 문은 인라인 (in-line)의 현재 반복이 종료됩니다 &lt;code&gt;PERFORM&lt;/code&gt; 어떤을 제어 제공 &lt;code&gt;TIMES&lt;/code&gt; &lt;code&gt;VARYING&lt;/code&gt; 을 및 / 또는 &lt;code&gt;UNTIL&lt;/code&gt; 다른주기의 요구를 수행 할 경우 그들에게 절을 결정하기를.</target>
        </trans-unit>
        <trans-unit id="107d6552838783c1a6f10f091c9371724d474b64" translate="yes" xml:space="preserve">
          <source>An&lt;code&gt;EXIT PERFORM&lt;/code&gt;statement will terminate the in-line PERFORM outright, transferring control to the first statement following the&lt;code&gt;END-PERFORM&lt;/code&gt;(if there is one) or to the next sentence following the&lt;code&gt;PERFORM&lt;/code&gt;if there is no&lt;code&gt;END-PERFORM&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;EXIT PERFORM&lt;/code&gt; 문은 인라인은 다음 첫 번째 문으로 제어를 전송, 크게 PERFORM 종료됩니다 &lt;code&gt;END-PERFORM&lt;/code&gt; (있는 경우) 또는 다음 문장은 다음 &lt;code&gt;PERFORM&lt;/code&gt; 에는 존재하지 않는 경우 &lt;code&gt;END-PERFORM&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0558b101714720a3ff3ca9607a6354d79525306b" translate="yes" xml:space="preserve">
          <source>An&lt;code&gt;EXIT PROGRAM&lt;/code&gt;statement returns control back to the statement following the&lt;code&gt;CALL&lt;/code&gt;(see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;) of the subprogram. An&lt;code&gt;EXIT FUNCTION&lt;/code&gt;statement returns control back to the processing of the statement in the calling program that invoked the user-defined function.</source>
          <target state="translated">&lt;code&gt;EXIT PROGRAM&lt;/code&gt; 다음은 문으로 반환 제어 다시 &lt;code&gt;CALL&lt;/code&gt; (참조 &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt; 서브 프로그램의). &lt;code&gt;EXIT FUNCTION&lt;/code&gt; 사용자 정의 함수를 호출 호출 프로그램에서 명령문의 처리에 문을 반환 제어 다시.</target>
        </trans-unit>
        <trans-unit id="4a6b6ab4109d112285f069fb07818114e4bebc69" translate="yes" xml:space="preserve">
          <source>An&lt;code&gt;EXTERNAL&lt;/code&gt;item must have a data name and that name cannot be&lt;code&gt;FILLER&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;EXTERNAL&lt;/code&gt; 항목은 데이터 이름이 있어야하고 그 이름이 될 수 없습니다 &lt;code&gt;FILLER&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc2fd6712885b1b3703e12505f7749bdef1bfdf0" translate="yes" xml:space="preserve">
          <source>An&lt;code&gt;INDEXED BY&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;INDEXED BY&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac745675a8a2742bc9ba41f7b7314ee4e3881723" translate="yes" xml:space="preserve">
          <source>An&lt;code&gt;ON OVERFLOW&lt;/code&gt;clause will allow your program to trap a failure condition that has occurred and handle it gracefully by executing &amp;lt;</source>
          <target state="translated">&lt;code&gt;ON OVERFLOW&lt;/code&gt; 절은 함정에 발생한 오류 조건을 프로그램을 허용하고 실행하여 정상적으로 처리 할 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="b474394379bfff80d947b78c9f32acbcbf70832a" translate="yes" xml:space="preserve">
          <source>An&lt;code&gt;UNLOCK&lt;/code&gt;statement (see &lt;a href=&quot;#UNLOCK&quot;&gt;UNLOCK&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;UNLOCK&lt;/code&gt; 문 (참조 &lt;a href=&quot;#UNLOCK&quot;&gt;UNLOCK를&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="03d303d2014295d3c641cff39f40b3ea41a785dd" translate="yes" xml:space="preserve">
          <source>And here is the same program, written in GnuCOBOL:</source>
          <target state="translated">다음은 GnuCOBOL로 작성된 동일한 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="908c7702d4b49075c887e8c2a07a4d2cb8791611" translate="yes" xml:space="preserve">
          <source>And now for the COBOL version:</source>
          <target state="translated">그리고 이제 COBOL 버전의 경우 :</target>
        </trans-unit>
        <trans-unit id="68e6e7bf7b4e4c60445c87b347dbafdaaba69943" translate="yes" xml:space="preserve">
          <source>And then pass &lt;code&gt;LastName-Arg-to-C&lt;/code&gt; to the C subprogram!</source>
          <target state="translated">그런 다음 &lt;code&gt;LastName-Arg-to-C&lt;/code&gt; 를 C 서브 프로그램에 전달하십시오!</target>
        </trans-unit>
        <trans-unit id="9fb9c91cbf19f123ad108025f0e19d0e384ea8f6" translate="yes" xml:space="preserve">
          <source>And then pass LastName-Arg-to-C to the C subprogram!</source>
          <target state="translated">그리고 LastName-Arg-to-C를 C 서브 프로그램에 전달하십시오!</target>
        </trans-unit>
        <trans-unit id="09bf44abda227aefc2699ef6191b50430d22275e" translate="yes" xml:space="preserve">
          <source>And then ran the report again. Here are the first two pages of that new report. See what happened to the control breaks?</source>
          <target state="translated">그런 다음 보고서를 다시 실행하십시오. 새 보고서의 처음 두 페이지는 다음과 같습니다. 제어 중단에 무슨 일이 있었는지 봅니까?</target>
        </trans-unit>
        <trans-unit id="94750e19b7dc978321e961bcdced7940324abc44" translate="yes" xml:space="preserve">
          <source>And then using &lt;code&gt;STEP&lt;/code&gt; and &lt;code&gt;VARYING&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;STEP&lt;/code&gt; 및 &lt;code&gt;VARYING&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="ff1ef9c30f1fe7eb72699782dca2ee2c8d7a9635" translate="yes" xml:space="preserve">
          <source>And then using&lt;code&gt;STEP&lt;/code&gt;and&lt;code&gt;VARYING&lt;/code&gt;</source>
          <target state="translated">그런 다음 &lt;code&gt;STEP&lt;/code&gt; 및 &lt;code&gt;VARYING&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="689cc005d9a5b470f694666be003b117d2e9da92" translate="yes" xml:space="preserve">
          <source>Another 01-level item is found</source>
          <target state="translated">다른 01 레벨 항목이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="0505ee5f4fbcd8cfad246d5a081bebd17da40318" translate="yes" xml:space="preserve">
          <source>Another 01-level item is found &amp;mdash; this signifies the end of the definition of one record and the start of a another.</source>
          <target state="translated">또 다른 01 레벨 항목이 발견되었습니다. 이는 한 레코드의 정의가 끝나고 다른 레코드가 시작되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="382abb431c292b8295311889484d3fd9c8bddf7d" translate="yes" xml:space="preserve">
          <source>Another 01-level item is found &amp;mdash; this signifies the start of another record layout for the file.</source>
          <target state="translated">다른 01- 레벨 항목이 발견되었습니다. 이것은 파일에 대한 다른 레코드 레이아웃의 시작을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="518375cf7ffdd1acde09571425ecc57715b23a9f" translate="yes" xml:space="preserve">
          <source>Another &lt;code&gt;FD&lt;/code&gt; or &lt;code&gt;SD&lt;/code&gt; is found</source>
          <target state="translated">다른 &lt;code&gt;FD&lt;/code&gt; 또는 &lt;code&gt;SD&lt;/code&gt; 가 발견됨</target>
        </trans-unit>
        <trans-unit id="6889b74b31ee2802d979c9e890a817570f57515b" translate="yes" xml:space="preserve">
          <source>Another way in which a data item may be shared between a calling program (</source>
          <target state="translated">호출 프로그램간에 데이터 항목을 공유 할 수있는 또 다른 방법 (</target>
        </trans-unit>
        <trans-unit id="96b85ec2ac9e747684a4b8344cf7bb3a37649976" translate="yes" xml:space="preserve">
          <source>Another way in which a data item may be shared between a calling program (&quot;A&quot;) and a called program (&quot;B&quot;) is by defining the data item in the calling program and attaching the&lt;code&gt;GLOBAL&lt;/code&gt;(see &lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt;) clause to it so that it may be used within the called program. In order for this to work, program &quot;B&quot; (the one called by program &quot;A&quot;) must be a nested subprogram within program &quot;A&quot;.</source>
          <target state="translated">호출 프로그램 ( &quot;A&quot;)과 호출 프로그램 ( &quot;B&quot;)간에 데이터 항목을 공유 할 수있는 다른 방법은 호출 프로그램에서 데이터 항목을 정의하고 &lt;code&gt;GLOBAL&lt;/code&gt; ( &lt;a href=&quot;#GLOBAL&quot;&gt;GLOBAL&lt;/a&gt; 참조 ) 절을 첨부하는 것입니다. 호출 된 프로그램 내에서 사용될 수 있습니다. 이것이 작동하려면 프로그램 &quot;B&quot;(프로그램 &quot;A&quot;에 의해 호출 된 프로그램)는 프로그램 &quot;A&quot;내에 중첩 된 서브 프로그램이어야합니다.</target>
        </trans-unit>
        <trans-unit id="12d7b76f82a19dd4ed02f3d565d4b238371f7e19" translate="yes" xml:space="preserve">
          <source>Another way to refer to a subprogram. Note that a called program may also be a calling program.</source>
          <target state="translated">서브 프로그램을 참조하는 다른 방법. 호출 된 프로그램은 호출 프로그램 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fd77fff888553d016fc399fbb94325e518c5453" translate="yes" xml:space="preserve">
          <source>Another&lt;code&gt;FD&lt;/code&gt;or&lt;code&gt;SD&lt;/code&gt;is found &amp;mdash; this marks the completion of the detailed description of the file and begins another.</source>
          <target state="translated">다른 &lt;code&gt;FD&lt;/code&gt; 또는 &lt;code&gt;SD&lt;/code&gt; 가 발견되었습니다. 이것은 파일에 대한 자세한 설명이 완료되었음을 나타내며 다른 것을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="56531e8c469cb52104e3f624f006f91587199181" translate="yes" xml:space="preserve">
          <source>Any &amp;lsquo;</source>
          <target state="translated">모든 '</target>
        </trans-unit>
        <trans-unit id="ece376507b4b04f63bc6355db795ce553f81c7c9" translate="yes" xml:space="preserve">
          <source>Any &amp;lt;</source>
          <target state="translated">어떤 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="8382f83cb65159ee448d6e722ffbeba60f501ebf" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;FROM&lt;/code&gt; (see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;), &lt;code&gt;TO&lt;/code&gt; (see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;) or &lt;code&gt;USING&lt;/code&gt; (see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) clause in the same data item&amp;rsquo;s definition will be ignored.</source>
          <target state="translated">모든 &lt;code&gt;FROM&lt;/code&gt; 은 (참조 &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt; ), &lt;code&gt;TO&lt;/code&gt; (참조 &lt;a href=&quot;#TO&quot;&gt;하는 방법에 대해&lt;/a&gt; ) 또는 &lt;code&gt;USING&lt;/code&gt; (참조 &lt;a href=&quot;#USING&quot;&gt;사용&lt;/a&gt; ) 동일한 데이터 항목의 정의에 절은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="75194f9557bbcfd5e3aef8eca0b4aa4c0049cfc5" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; declarative procedures will be ignored at</source>
          <target state="translated">모든 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; 선언 절차에서 무시됩니다</target>
        </trans-unit>
        <trans-unit id="af5b5035dbbb96fe4a1b0dbcd10ad06b141d69d7" translate="yes" xml:space="preserve">
          <source>Any &lt;var&gt;identifier-7&lt;/var&gt; data items that are sum counters must either be defined in the same report group as the data item in which this &lt;code&gt;SUM&lt;/code&gt; clause appears or they must be defined in a report data item that exists at a lower level in this report&amp;rsquo;s control hierarchy. See &lt;a href=&quot;#Control-Hierarchy&quot;&gt;Control Hierarchy&lt;/a&gt;, for additional information.</source>
          <target state="translated">Any &lt;var&gt;identifier-7&lt;/var&gt; data items that are sum counters must either be defined in the same report group as the data item in which this &lt;code&gt;SUM&lt;/code&gt; clause appears or they must be defined in a report data item that exists at a lower level in this report&amp;rsquo;s control hierarchy. See &lt;a href=&quot;#Control-Hierarchy&quot;&gt;Control Hierarchy&lt;/a&gt;, for additional information.</target>
        </trans-unit>
        <trans-unit id="6da82a484e63fbc21beaad685f8113d1089aa9bb" translate="yes" xml:space="preserve">
          <source>Any &lt;var&gt;identifier-9&lt;/var&gt; specifications included on the &lt;code&gt;CONTROL&lt;/code&gt; clause are referencing data names defined in any data division section except for the report section.</source>
          <target state="translated">Any &lt;var&gt;identifier-9&lt;/var&gt; specifications included on the &lt;code&gt;CONTROL&lt;/code&gt; clause are referencing data names defined in any data division section except for the report section.</target>
        </trans-unit>
        <trans-unit id="a2f898c0f518503bf1220b9309e8ef39f93e3196" translate="yes" xml:space="preserve">
          <source>Any GnuCOBOL subroutine can be recursively invoked only if it is defined to the GnuCOBOL compiler as</source>
          <target state="translated">GnuCOBOL 서브 루틴은 다음과 같이 GnuCOBOL 컴파일러에 정의 된 경우에만 재귀 적으로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="faaae76b7dfe57cbf67adc9423099599c8487ed1" translate="yes" xml:space="preserve">
          <source>Any attempt to open a file that is already open will fail with a file status of 41 (see &lt;a href=&quot;#File-Status-Codes&quot;&gt;File Status Codes&lt;/a&gt;).</source>
          <target state="translated">Any attempt to open a file that is already open will fail with a file status of 41 (see &lt;a href=&quot;#File-Status-Codes&quot;&gt;File Status Codes&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="100ab34d30a1d379ee442e2d204a31b6b3ed3860" translate="yes" xml:space="preserve">
          <source>Any attempt to open a file that is already open will fail with a file status of 41 (see &lt;a href=&quot;#File-Status-Codes&quot;&gt;File Status Codes&lt;/a&gt;). This is a fatal error that will terminate the program.</source>
          <target state="translated">이미 열려있는 파일을 열려고하면 파일 상태가 41 인 상태로 실패합니다 ( &lt;a href=&quot;#File-Status-Codes&quot;&gt;파일 상태 코드&lt;/a&gt; 참조 ). 프로그램을 종료시키는 치명적인 오류입니다.</target>
        </trans-unit>
        <trans-unit id="7c8fd1559498131c77671bcd2a7a57fb07ffbbb9" translate="yes" xml:space="preserve">
          <source>Any bits in &amp;lt;</source>
          <target state="translated">&amp;lt;의 모든 비트</target>
        </trans-unit>
        <trans-unit id="b879aec54c54230a3e5a05cbdf585e6800355869" translate="yes" xml:space="preserve">
          <source>Any bits in &lt;var&gt;item-1&lt;/var&gt; after the 8*&lt;var&gt;byte-length&lt;/var&gt; point will be unaffected.</source>
          <target state="translated">Any bits in &lt;var&gt;item-1&lt;/var&gt; after the 8* &lt;var&gt;byte-length&lt;/var&gt; point will be unaffected.</target>
        </trans-unit>
        <trans-unit id="73149d45a834754a9af23f002d5bbd2572fd133a" translate="yes" xml:space="preserve">
          <source>Any bits in &lt;var&gt;item-2&lt;/var&gt; after the 8*&lt;var&gt;byte-length&lt;/var&gt; point will be unaffected.</source>
          <target state="translated">Any bits in &lt;var&gt;item-2&lt;/var&gt; after the 8* &lt;var&gt;byte-length&lt;/var&gt; point will be unaffected.</target>
        </trans-unit>
        <trans-unit id="67ae9e1e98355da4134d72c69849170da98a4cb1" translate="yes" xml:space="preserve">
          <source>Any check-suppression symbol coded to the right of a &amp;lsquo;</source>
          <target state="translated">Any check-suppression symbol coded to the right of a &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="6bef0fbd343651d26482d90e9696df8dad5bf7e0" translate="yes" xml:space="preserve">
          <source>Any check-suppression symbol coded to the right of a&lt;code&gt;.&lt;/code&gt;will be treated exactly like a&lt;code&gt;9&lt;/code&gt;</source>
          <target state="translated">의 오른쪽에 코딩 된 모든 억제 억제 기호 &lt;code&gt;.&lt;/code&gt; 정확히 &lt;code&gt;9&lt;/code&gt; 처럼 취급됩니다</target>
        </trans-unit>
        <trans-unit id="e61a49ae749b49ee902ff4b2ae633ca15b31b510" translate="yes" xml:space="preserve">
          <source>Any currency symbol coded to the right of a &amp;lsquo;</source>
          <target state="translated">Any currency symbol coded to the right of a &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="e3bcf58cd2fc67e0354e8ffc50841f9ea3131ccf" translate="yes" xml:space="preserve">
          <source>Any currency symbol coded to the right of a&lt;code&gt;.&lt;/code&gt;will be treated exactly like a&lt;code&gt;9&lt;/code&gt;</source>
          <target state="translated">모든 통화 기호는 오른쪽에 코딩 &lt;code&gt;.&lt;/code&gt; 정확히 &lt;code&gt;9&lt;/code&gt; 처럼 취급됩니다</target>
        </trans-unit>
        <trans-unit id="a320db675bf5a15ad72e91a96c50735a520e849b" translate="yes" xml:space="preserve">
          <source>Any editing symbols introduced past this point will, if coded in the picture clause of an otherwise numeric data item, transform that data item from a numeric to a  &lt;em&gt;Numeric Edited&lt;/em&gt; data item. Numeric edited data items are treated as alphanumeric and may not serve either as table subscripts or as source arguments on an arithmetic statement.</source>
          <target state="translated">Any editing symbols introduced past this point will, if coded in the picture clause of an otherwise numeric data item, transform that data item from a numeric to a &lt;em&gt;Numeric Edited&lt;/em&gt; data item. Numeric edited data items are treated as alphanumeric and may not serve either as table subscripts or as source arguments on an arithmetic statement.</target>
        </trans-unit>
        <trans-unit id="f77cfa80a154156b5bd42b458486005f66fbb774" translate="yes" xml:space="preserve">
          <source>Any editing symbols introduced past this point will, if coded in the picture clause of an otherwise numeric data item, transform that data item from a numeric to a &amp;rsquo;</source>
          <target state="translated">이 시점 이후에 도입 된 편집 기호는 숫자 데이터 항목의 그림 절에 코딩 된 경우 해당 데이터 항목을 숫자에서 '</target>
        </trans-unit>
        <trans-unit id="90b9ccb1ecab8f99534dc262df737d5f05bd8262" translate="yes" xml:space="preserve">
          <source>Any file defined in a GnuCOBOL program must be successfully opened before it or any of it&amp;rsquo;s record descriptions may be referenced on:</source>
          <target state="translated">GnuCOBOL 프로그램에 정의 된 모든 파일은 파일 또는 레코드 설명이 참조되기 전에 성공적으로 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="5b7a1af2dd2779e01dc7df92b9f2e58e6577d3a9" translate="yes" xml:space="preserve">
          <source>Any file defined in a GnuCOBOL program must be successfully opened before it or any of its record descriptions may be referenced on:</source>
          <target state="translated">Any file defined in a GnuCOBOL program must be successfully opened before it or any of its record descriptions may be referenced on:</target>
        </trans-unit>
        <trans-unit id="ff02ac007f44656c52eb4d60b56ba46ef78440ef" translate="yes" xml:space="preserve">
          <source>Any limitations imposed on a successful &lt;code&gt;OPEN&lt;/code&gt; (see &lt;a href=&quot;#OPEN&quot;&gt;OPEN&lt;/a&gt;) will remain in place until your program either issues a &lt;code&gt;CLOSE&lt;/code&gt; (see &lt;a href=&quot;#CLOSE&quot;&gt;CLOSE&lt;/a&gt;) against the file or the program terminates.</source>
          <target state="translated">Any limitations imposed on a successful &lt;code&gt;OPEN&lt;/code&gt; (see &lt;a href=&quot;#OPEN&quot;&gt;OPEN&lt;/a&gt;) will remain in place until your program either issues a &lt;code&gt;CLOSE&lt;/code&gt; (see &lt;a href=&quot;#CLOSE&quot;&gt;CLOSE&lt;/a&gt;) against the file or the program terminates.</target>
        </trans-unit>
        <trans-unit id="cf723a992e40cd4aba4d8614163d705ffa6fcf27" translate="yes" xml:space="preserve">
          <source>Any limitations imposed on a successful&lt;code&gt;OPEN&lt;/code&gt;(see &lt;a href=&quot;#OPEN&quot;&gt;OPEN&lt;/a&gt;) will remain in place until your program either issues a&lt;code&gt;CLOSE&lt;/code&gt;(see &lt;a href=&quot;#CLOSE&quot;&gt;CLOSE&lt;/a&gt;) against the file or the program terminates.</source>
          <target state="translated">성공에 부과 된 제한 &lt;code&gt;OPEN&lt;/code&gt; 은 (참조 &lt;a href=&quot;#OPEN&quot;&gt;OPEN을&lt;/a&gt; ) 프로그램 때까지 자리에 발행 중 하나 남아 &lt;code&gt;CLOSE&lt;/code&gt; (참조 &lt;a href=&quot;#CLOSE&quot;&gt;CLOSE&lt;/a&gt; 파일에 대한) 또는 프로그램 종료를.</target>
        </trans-unit>
        <trans-unit id="7d682e132d7c3c4806d88ca80c81f84fc3da5985" translate="yes" xml:space="preserve">
          <source>Any modification to the   &lt;code&gt;LINE-COUNTER&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;).</source>
          <target state="translated">Any modification to the &lt;code&gt;LINE-COUNTER&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="9ecdbd73028de3eeb96ef22283a5db8c8860831a" translate="yes" xml:space="preserve">
          <source>Any modification to the   &lt;code&gt;PAGE-COUNTER&lt;/code&gt; special register.</source>
          <target state="translated">Any modification to the &lt;code&gt;PAGE-COUNTER&lt;/code&gt; special register.</target>
        </trans-unit>
        <trans-unit id="07309495035024e00199d745b0565e378e8a4c37" translate="yes" xml:space="preserve">
          <source>Any modification to the&lt;code&gt;LINE-COUNTER&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;).</source>
          <target state="translated">받는 모든 수정 &lt;code&gt;LINE-COUNTER&lt;/code&gt; 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7e9510ca3b2e3093c2eaea38b5cb662ac9023afa" translate="yes" xml:space="preserve">
          <source>Any modification to the&lt;code&gt;PAGE-COUNTER&lt;/code&gt;special register .</source>
          <target state="translated">&lt;code&gt;PAGE-COUNTER&lt;/code&gt; 특수 레지스터 수정 .</target>
        </trans-unit>
        <trans-unit id="5596e2fb14f2973ae87df25ad559a88f3670b77e" translate="yes" xml:space="preserve">
          <source>Any of these characters appearing within a syntax diagram are to be interpreted literally, and are characters that must be coded &amp;mdash; where allowed &amp;mdash; in the statement whose format is being described. Note that a &quot;.&quot; character is a literal character that must be coded on a statement whereas a &quot;...&quot; symbol is the meta character sequence described above.</source>
          <target state="translated">구문 다이어그램 내에 나타나는 이러한 문자는 문자 그대로 해석되어야하며 형식이 설명되는 명령문에서 허용되는 경우 코딩해야하는 문자입니다. &quot;.&quot; 문자는 명령문에서 코딩해야하는 리터럴 문자이고 &quot;...&quot;기호는 위에서 설명한 메타 문자 순서입니다.</target>
        </trans-unit>
        <trans-unit id="748c5fc489bb4f19b33361d0bb343fd95e3536f9" translate="yes" xml:space="preserve">
          <source>Any of these characters appearing within a syntax diagram are to be interpreted literally, and are characters that must be coded &amp;mdash; where allowed &amp;mdash; in the statement whose format is being described. Note that a &amp;lsquo;</source>
          <target state="translated">Any of these characters appearing within a syntax diagram are to be interpreted literally, and are characters that must be coded &amp;mdash; where allowed &amp;mdash; in the statement whose format is being described. Note that a &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="0573f3a3b482095180533ec3deab3815b4c66248" translate="yes" xml:space="preserve">
          <source>Any open failure (including status 41) may be trapped using &lt;code&gt;DECLARATIVES&lt;/code&gt; (see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) or an error procedure established using the &lt;code&gt;CBL_ERROR_PROC&lt;/code&gt; built-in system subroutine (see &lt;a href=&quot;#CBL_005fERROR_005fPROC&quot;&gt;CBL_ERROR_PROC&lt;/a&gt;) built-in subroutine or even just checking the status field defined. It is up to the programmer to check for bad statuses and respond accordingly such as issue a CLOSE before dealing with the problem.</source>
          <target state="translated">Any open failure (including status 41) may be trapped using &lt;code&gt;DECLARATIVES&lt;/code&gt; (see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) or an error procedure established using the &lt;code&gt;CBL_ERROR_PROC&lt;/code&gt; built-in system subroutine (see &lt;a href=&quot;#CBL_005fERROR_005fPROC&quot;&gt;CBL_ERROR_PROC&lt;/a&gt;) built-in subroutine or even just checking the status field defined. It is up to the programmer to check for bad statuses and respond accordingly such as issue a CLOSE before dealing with the problem.</target>
        </trans-unit>
        <trans-unit id="05c8005e639ef075bb5c029fa3f90090c950c54b" translate="yes" xml:space="preserve">
          <source>Any open failure (including status 41) may be trapped using&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) or an error procedure established using the&lt;code&gt;CBL_ERROR_PROC&lt;/code&gt;built-in system subroutine (see &lt;a href=&quot;#CBL_005fERROR_005fPROC&quot;&gt;CBL_ERROR_PROC&lt;/a&gt;) built-in subroutine. When either of these trap routines</source>
          <target state="translated">모든 오픈 불량 (상태 (41)을 포함)을 이용하여 포획 될 수 &lt;code&gt;DECLARATIVES&lt;/code&gt; (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES을&lt;/a&gt; ) 또는하여 설정된 에러 절차 &lt;code&gt;CBL_ERROR_PROC&lt;/code&gt; 내장 시스템 서브 루틴 (참조 &lt;a href=&quot;#CBL_005fERROR_005fPROC&quot;&gt;CBL_ERROR_PROC을&lt;/a&gt; )에 내장 된 서브 루틴. 이 트랩 루틴 중 하나가</target>
        </trans-unit>
        <trans-unit id="38d177c6ad83b9ea06dad59b249b92bfd4368ac5" translate="yes" xml:space="preserve">
          <source>Any procedures referenced by &lt;code&gt;GO TO&lt;/code&gt; statements will be defined as paragraphs, and those paragraphs will be defined in the same section as the &lt;code&gt;GO TO&lt;/code&gt; statements that reference them. In other words, &lt;code&gt;GO TO&lt;/code&gt; statements may not be used to transfer control to a point in a different section. This is</source>
          <target state="translated">Any procedures referenced by &lt;code&gt;GO TO&lt;/code&gt; statements will be defined as paragraphs, and those paragraphs will be defined in the same section as the &lt;code&gt;GO TO&lt;/code&gt; statements that reference them. In other words, &lt;code&gt;GO TO&lt;/code&gt; statements may not be used to transfer control to a point in a different section. This is</target>
        </trans-unit>
        <trans-unit id="ccc8bf26333530994b18d4d03564a0070a7d4a75" translate="yes" xml:space="preserve">
          <source>Any procedures referenced by &lt;code&gt;MERGE&lt;/code&gt;, &lt;code&gt;PERFORM&lt;/code&gt;, or &lt;code&gt;SORT&lt;/code&gt; statements will be defined as sections.</source>
          <target state="translated">Any procedures referenced by &lt;code&gt;MERGE&lt;/code&gt; , &lt;code&gt;PERFORM&lt;/code&gt; , or &lt;code&gt;SORT&lt;/code&gt; statements will be defined as sections.</target>
        </trans-unit>
        <trans-unit id="5781772e084e444be68b9e695c83552d1ee473fb" translate="yes" xml:space="preserve">
          <source>Any procedures referenced by&lt;code&gt;GO TO&lt;/code&gt;statements will be defined as paragraphs, and those paragraphs will be defined in the same section as the&lt;code&gt;GO TO&lt;/code&gt;statements that reference them. In other words,&lt;code&gt;GO TO&lt;/code&gt;statements may not be used to transfer control to a point in a different section. This is</source>
          <target state="translated">&lt;code&gt;GO TO&lt;/code&gt; 문에서 참조하는 모든 프로시 저는 단락으로 정의되며 해당 단락은이 를 참조 하는 &lt;code&gt;GO TO&lt;/code&gt; 문과 동일한 섹션에서 정의 됩니다. 즉, &lt;code&gt;GO TO&lt;/code&gt; 문을 사용하여 제어를 다른 섹션의 한 지점으로 이전 할 수 없습니다. 이것은</target>
        </trans-unit>
        <trans-unit id="eecd6d60d2d9d5868c3f314cdb3b483e10e23de4" translate="yes" xml:space="preserve">
          <source>Any procedures referenced by&lt;code&gt;MERGE&lt;/code&gt;&lt;code&gt;PERFORM&lt;/code&gt; or&lt;code&gt;SORT&lt;/code&gt;statements will be defined as sections.</source>
          <target state="translated">&lt;code&gt;MERGE&lt;/code&gt; &lt;code&gt;PERFORM&lt;/code&gt; 또는 &lt;code&gt;SORT&lt;/code&gt; 문에서 참조하는 모든 절차 는 섹션으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="ed1c3fc20474dca4e5afa8fac8ef4eb1715e6ead" translate="yes" xml:space="preserve">
          <source>Any programmer-defined exit procedure (established via the &lt;code&gt;CBL_EXIT_PROC&lt;/code&gt; built-in system subroutine (see &lt;a href=&quot;#CBL_005fEXIT_005fPROC&quot;&gt;CBL_EXIT_PROC&lt;/a&gt;)) will be executed by &lt;code&gt;STOP RUN&lt;/code&gt;, but not by &lt;code&gt;STOP &lt;var&gt;literal-3&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">Any programmer-defined exit procedure (established via the &lt;code&gt;CBL_EXIT_PROC&lt;/code&gt; built-in system subroutine (see &lt;a href=&quot;#CBL_005fEXIT_005fPROC&quot;&gt;CBL_EXIT_PROC&lt;/a&gt;)) will be executed by &lt;code&gt;STOP RUN&lt;/code&gt; , but not by &lt;code&gt;STOP &lt;var&gt;literal-3&lt;/var&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="184906523a150d69bc1a9c1f23192c4de8a46740" translate="yes" xml:space="preserve">
          <source>Any programmer-defined exit procedure (established via the&lt;code&gt;CBL_EXIT_PROC&lt;/code&gt;built-in system subroutine (see &lt;a href=&quot;#CBL_005fEXIT_005fPROC&quot;&gt;CBL_EXIT_PROC&lt;/a&gt;)) will be executed by&lt;code&gt;STOP RUN&lt;/code&gt; but not by&lt;code&gt;STOP &amp;lt;&lt;i&gt;literal-3&lt;/i&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">프로그래머 정의 종료 프로 시저 ( &lt;code&gt;CBL_EXIT_PROC&lt;/code&gt; 내장 시스템 서브 루틴 ( &lt;a href=&quot;#CBL_005fEXIT_005fPROC&quot;&gt;CBL_EXIT_PROC&lt;/a&gt; 참조)를 통해 설정 됨)는 &lt;code&gt;STOP RUN&lt;/code&gt; 에 의해 실행 되지만 &lt;code&gt;STOP &amp;lt;&lt;i&gt;literal-3&lt;/i&gt;&amp;gt;&lt;/code&gt; &lt;i&gt;literal-3&lt;/i&gt; &amp;gt;에 의해 실행 되지 않습니다.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="c0b666e80a44d1fa49194ffd3d323d6df8a7fee4" translate="yes" xml:space="preserve">
          <source>Any subprogram may be either statically or dynamically loaded into memory.</source>
          <target state="translated">모든 서브 프로그램은 메모리에 정적으로 또는 동적으로로드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="662f40cfd453ce96cd358bffc9a69da378cd8403" translate="yes" xml:space="preserve">
          <source>Any subroutine may have multiple entry-points defined within it. This means the subroutine could be called either via a &lt;code&gt;CALL '&lt;var&gt;program-id&lt;/var&gt;'&lt;/code&gt; or a &lt;code&gt;CALL '&lt;var&gt;entry-point&lt;/var&gt;'&lt;/code&gt; statement. There may be any number of alternate entry-points defined within a subroutine.</source>
          <target state="translated">Any subroutine may have multiple entry-points defined within it. This means the subroutine could be called either via a &lt;code&gt;CALL '&lt;var&gt;program-id&lt;/var&gt;'&lt;/code&gt; or a &lt;code&gt;CALL '&lt;var&gt;entry-point&lt;/var&gt;'&lt;/code&gt; statement. There may be any number of alternate entry-points defined within a subroutine.</target>
        </trans-unit>
        <trans-unit id="504d18753df605f9f9ca9cb22a61c5d08a964b9a" translate="yes" xml:space="preserve">
          <source>Any subroutine may have multiple entry-points defined within it. This means the subroutine could be called either via a&lt;code&gt;CALL '&amp;lt;&lt;i&gt;program-id&lt;/i&gt;&amp;gt;'&lt;/code&gt;or a&lt;code&gt;CALL '&amp;lt;&lt;i&gt;entry-point&lt;/i&gt;&amp;gt;'&lt;/code&gt;statement. There may be any number of alternate entry-points defined within a subroutine.</source>
          <target state="translated">모든 서브 루틴에는 여러 개의 진입 점이 정의 될 수 있습니다. 이는 서브 루틴이 &lt;code&gt;CALL '&amp;lt;&lt;i&gt;program-id&lt;/i&gt;&amp;gt;'&lt;/code&gt; 또는 &lt;code&gt;CALL '&amp;lt;&lt;i&gt;entry-point&lt;/i&gt;&amp;gt;'&lt;/code&gt; 문을 통해 호출 될 수 있음을 의미합니다 . 서브 루틴 내에 여러 개의 대체 진입 점이 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1fc58b4f56f6457f4484e3ee645ab7d9e6dec47" translate="yes" xml:space="preserve">
          <source>Any subroutines or user-defined functions that weren&amp;rsquo;t included in any of the source files comprising the compilation group will be treated as dynamically loadable subprograms (see &lt;a href=&quot;#Dynamic-vs-Static-Subprograms&quot;&gt;Dynamic vs Static Subprograms&lt;/a&gt;).</source>
          <target state="translated">컴파일 그룹을 구성하는 소스 파일에 포함되지 않은 서브 루틴 또는 사용자 정의 함수는 동적으로로드 가능한 서브 프로그램으로 처리됩니다 ( &lt;a href=&quot;#Dynamic-vs-Static-Subprograms&quot;&gt;동적 및 정적 서브 프로그램&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6c1d8bfb396f82cd0be3e1b2f29c9dd40ad412c9" translate="yes" xml:space="preserve">
          <source>Any value specified for &amp;lt;</source>
          <target state="translated">&amp;lt;에 지정된 값</target>
        </trans-unit>
        <trans-unit id="b9af064dd24805ee9769a86502dc8552c2aef723" translate="yes" xml:space="preserve">
          <source>Any value specified for &lt;var&gt;literal-2&lt;/var&gt; or &lt;var&gt;identifier-2&lt;/var&gt; will define the total number of available lines on any report page, not counting any unused margins at the top and/or bottom of the page (defined by the &lt;code&gt;LINES AT TOP&lt;/code&gt; and &lt;code&gt;LINES AT BOTTOM&lt;/code&gt; values specified on the &lt;code&gt;LINAGE&lt;/code&gt; clause of the &lt;code&gt;FD&lt;/code&gt; this &lt;code&gt;RD&lt;/code&gt; is linked to &amp;mdash; see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;).</source>
          <target state="translated">Any value specified for &lt;var&gt;literal-2&lt;/var&gt; or &lt;var&gt;identifier-2&lt;/var&gt; will define the total number of available lines on any report page, not counting any unused margins at the top and/or bottom of the page (defined by the &lt;code&gt;LINES AT TOP&lt;/code&gt; and &lt;code&gt;LINES AT BOTTOM&lt;/code&gt; values specified on the &lt;code&gt;LINAGE&lt;/code&gt; clause of the &lt;code&gt;FD&lt;/code&gt; this &lt;code&gt;RD&lt;/code&gt; is linked to &amp;mdash; see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="2ad93c2c0de21d31ea47a77039dee19dd24a2301" translate="yes" xml:space="preserve">
          <source>Any value specified for &lt;var&gt;literal-3&lt;/var&gt; or &lt;var&gt;identifier-3&lt;/var&gt; will be ignored.</source>
          <target state="translated">Any value specified for &lt;var&gt;literal-3&lt;/var&gt; or &lt;var&gt;identifier-3&lt;/var&gt; will be ignored.</target>
        </trans-unit>
        <trans-unit id="8de75ab99f8def55ad9727e64b7c126160cab956" translate="yes" xml:space="preserve">
          <source>Any zero-suppression symbol coded to the right of a &amp;lsquo;</source>
          <target state="translated">Any zero-suppression symbol coded to the right of a &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="8ae8b2f4162d32085d93a05bffe959d3dc6c2c99" translate="yes" xml:space="preserve">
          <source>Any zero-suppression symbol coded to the right of a&lt;code&gt;.&lt;/code&gt;will be treated exactly like a&lt;code&gt;9&lt;/code&gt;</source>
          <target state="translated">제로 억제 기호는의 오른쪽에 코딩됩니다 &lt;code&gt;.&lt;/code&gt; 정확히 &lt;code&gt;9&lt;/code&gt; 처럼 취급됩니다</target>
        </trans-unit>
        <trans-unit id="609550b887a3665c33285cf377eeab02fdad2f81" translate="yes" xml:space="preserve">
          <source>Any&lt;code&gt;+&lt;/code&gt;symbol coded to the right of a&lt;code&gt;.&lt;/code&gt;will be treated exactly like a&lt;code&gt;9&lt;/code&gt;</source>
          <target state="translated">모든 &lt;code&gt;+&lt;/code&gt; 의 기호는 오른쪽에 코딩 &lt;code&gt;.&lt;/code&gt; 정확히 &lt;code&gt;9&lt;/code&gt; 처럼 취급됩니다</target>
        </trans-unit>
        <trans-unit id="90d69db88d33f5d818bfe45bab965b5cb19e7247" translate="yes" xml:space="preserve">
          <source>Any&lt;code&gt;-&lt;/code&gt;symbol coded to the right of a&lt;code&gt;.&lt;/code&gt;will be treated exactly like a&lt;code&gt;9&lt;/code&gt;</source>
          <target state="translated">모든 &lt;code&gt;-&lt;/code&gt; 기호는 오른쪽에 코딩 &lt;code&gt;.&lt;/code&gt; 정확히 &lt;code&gt;9&lt;/code&gt; 처럼 취급됩니다</target>
        </trans-unit>
        <trans-unit id="3317b9bd439ca7b44560972fca6ecc8f24de4ec7" translate="yes" xml:space="preserve">
          <source>Any&lt;code&gt;FROM&lt;/code&gt;(see &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt;),&lt;code&gt;TO&lt;/code&gt;(see &lt;a href=&quot;#TO&quot;&gt;TO&lt;/a&gt;) or&lt;code&gt;USING&lt;/code&gt;(see &lt;a href=&quot;#USING&quot;&gt;USING&lt;/a&gt;) clause in the same data item&amp;rsquo;s definition will be ignored.</source>
          <target state="translated">모든 &lt;code&gt;FROM&lt;/code&gt; 은 (참조 &lt;a href=&quot;#FROM&quot;&gt;FROM&lt;/a&gt; ), &lt;code&gt;TO&lt;/code&gt; (참조 &lt;a href=&quot;#TO&quot;&gt;하는 방법에 대해&lt;/a&gt; ) 또는 &lt;code&gt;USING&lt;/code&gt; (참조 &lt;a href=&quot;#USING&quot;&gt;사용&lt;/a&gt; ) 동일한 데이터 항목의 정의에 절은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0d67012185f3b5a9a5acefa8efe44be45ccd9181" translate="yes" xml:space="preserve">
          <source>Any&lt;code&gt;USE FOR DEBUGGING&lt;/code&gt;declarative procedures will be ignored at</source>
          <target state="translated">모든 &lt;code&gt;USE FOR DEBUGGING&lt;/code&gt; 선언 절차에서 무시됩니다</target>
        </trans-unit>
        <trans-unit id="73973cfd168d40bb8277e2f6044ecdb605409c4e" translate="yes" xml:space="preserve">
          <source>Appendices</source>
          <target state="translated">Appendices</target>
        </trans-unit>
        <trans-unit id="48bf7afa8d3cf106e9d055154eefcbf6a6d17e88" translate="yes" xml:space="preserve">
          <source>Appendix A - Glossary of Terms</source>
          <target state="translated">부록 A-용어집</target>
        </trans-unit>
        <trans-unit id="b3caa5ecaad1a99ce9408f043c78a5025c7f21c7" translate="yes" xml:space="preserve">
          <source>Appendix B - Reserved Word List</source>
          <target state="translated">부록 B-예약어 목록</target>
        </trans-unit>
        <trans-unit id="072be2b86e2e9778cc6f6ac1a62af09a26ea8764" translate="yes" xml:space="preserve">
          <source>Approximately -1.797693134862316 * 10&lt;sup&gt;308&lt;/sup&gt; &amp;ndash; 1.797693134862316 * 10&lt;sup&gt;308&lt;/sup&gt;</source>
          <target state="translated">Approximately -1.797693134862316 * 10&lt;sup&gt;308&lt;/sup&gt; &amp;ndash; 1.797693134862316 * 10&lt;sup&gt;308&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="4f8efb9dd8dc8979930f5cce4db0b4ac9f57e430" translate="yes" xml:space="preserve">
          <source>Approximately -1.797693134862316&amp;times;10^308 to 1.797693134862316&amp;times;10^308</source>
          <target state="translated">약 -1.797693134862316 &amp;times; 10 ^ 308 ~ 1.797693134862316 &amp;times; 10 ^ 308</target>
        </trans-unit>
        <trans-unit id="554a24e23c3198fff8657009a0bf71949a8faebb" translate="yes" xml:space="preserve">
          <source>Approximately -3.4028235 * 10&lt;sup&gt;38&lt;/sup&gt; &amp;ndash; 3.4028235 * 10&lt;sup&gt;38&lt;/sup&gt;</source>
          <target state="translated">Approximately -3.4028235 * 10&lt;sup&gt;38&lt;/sup&gt; &amp;ndash; 3.4028235 * 10&lt;sup&gt;38&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ec0a8efc23f1cd8a47ecd61a1a44af541b83ab89" translate="yes" xml:space="preserve">
          <source>Approximately -3.4028235&amp;times;10^38 to 3.4028235&amp;times;10^38</source>
          <target state="translated">약 -3.4028235 &amp;times; 10 ^ 38 ~ 3.4028235 &amp;times; 10 ^ 38</target>
        </trans-unit>
        <trans-unit id="ef76957fbf0cf421a9e00a02ecd10f44eb914d5b" translate="yes" xml:space="preserve">
          <source>Area A</source>
          <target state="translated">Area A</target>
        </trans-unit>
        <trans-unit id="a0f1cdfbee6014b784e8cd0453a50f77e3bee1f8" translate="yes" xml:space="preserve">
          <source>Area B</source>
          <target state="translated">Area B</target>
        </trans-unit>
        <trans-unit id="37353e5c3760cc4ebefcf993ed8fb20f61cefbe6" translate="yes" xml:space="preserve">
          <source>Arguments 2, 3 and 4 should be coded as the constant values shown. &lt;code&gt;CBL_CREATE_FILE&lt;/code&gt; is actually a special-case of the &lt;code&gt;CBL_OPEN_FILE&lt;/code&gt; built-in system subroutine (see &lt;a href=&quot;#CBL_005fOPEN_005fFILE&quot;&gt;CBL_OPEN_FILE&lt;/a&gt;) routine &amp;mdash; see that routine for a description of the meanings of arguments 2, 3 and 4.</source>
          <target state="translated">Arguments 2, 3 and 4 should be coded as the constant values shown. &lt;code&gt;CBL_CREATE_FILE&lt;/code&gt; is actually a special-case of the &lt;code&gt;CBL_OPEN_FILE&lt;/code&gt; built-in system subroutine (see &lt;a href=&quot;#CBL_005fOPEN_005fFILE&quot;&gt;CBL_OPEN_FILE&lt;/a&gt;) routine &amp;mdash; see that routine for a description of the meanings of arguments 2, 3 and 4.</target>
        </trans-unit>
        <trans-unit id="dacce68e3bbdcbcc2b9399d8af85171c0f0c35c0" translate="yes" xml:space="preserve">
          <source>Arguments 2, 3 and 4 should be coded as the constant values shown.&lt;code&gt;CBL_CREATE_FILE&lt;/code&gt;is actually a special-case of the&lt;code&gt;CBL_OPEN_FILE&lt;/code&gt;built-in system subroutine (see &lt;a href=&quot;#CBL_005fOPEN_005fFILE&quot;&gt;CBL_OPEN_FILE&lt;/a&gt;) routine &amp;mdash; see that routine for a description of the meanings of arguments 2, 3 and 4.</source>
          <target state="translated">인수 2, 3 및 4는 표시된 상수 값으로 코딩해야합니다. &lt;code&gt;CBL_CREATE_FILE&lt;/code&gt; 은 실제로 &lt;code&gt;CBL_OPEN_FILE&lt;/code&gt; 내장 시스템 서브 루틴 ( &lt;a href=&quot;#CBL_005fOPEN_005fFILE&quot;&gt;CBL_OPEN_FILE&lt;/a&gt; 참조 ) 루틴 의 특수한 경우입니다. 인수 2, 3 및 4의 의미에 대한 설명은 해당 루틴을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2f3b277fc84585ddc67f049324e34e0258469da4" translate="yes" xml:space="preserve">
          <source>Arguments must be described in both the calling and called programs, and while they don&amp;rsquo;t need to have the same names in both programs, they should be described in an identical manner with regard to the following characteristics:</source>
          <target state="translated">인수는 호출 된 프로그램과 호출 된 프로그램 모두에 설명되어야하며 두 프로그램에서 동일한 이름을 가질 필요는 없지만 다음 특성과 관련하여 동일한 방식으로 설명되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3afc598b571906c0776a2f06b23501e757b48d2a" translate="yes" xml:space="preserve">
          <source>Arguments to a user-defined function are always to be specified as &lt;code&gt;BY REFERENCE&lt;/code&gt; (either explicitly or by not using any &lt;code&gt;BY&lt;/code&gt;).</source>
          <target state="translated">Arguments to a user-defined function are always to be specified as &lt;code&gt;BY REFERENCE&lt;/code&gt; (either explicitly or by not using any &lt;code&gt;BY&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="07c268e7dc75ae19cfce107f9220c59392c5162c" translate="yes" xml:space="preserve">
          <source>Arguments to a user-defined function are always to be specified as&lt;code&gt;BY REFERENCE&lt;/code&gt;(either explicitly or by not using any&lt;code&gt;BY&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 함수에 대한 인수는 항상 &lt;code&gt;BY REFERENCE&lt;/code&gt; (명시 적으로 또는 &lt;code&gt;BY&lt;/code&gt; 를 사용하지 않음) 로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fbc24241a0054f7cba259986d000337d4452d4aa" translate="yes" xml:space="preserve">
          <source>Arguments to user-defined functions are always passed &lt;code&gt;BY REFERENCE&lt;/code&gt;.</source>
          <target state="translated">Arguments to user-defined functions are always passed &lt;code&gt;BY REFERENCE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a520bd4d4137463c9fa4f4db1926ad17ae4aeec" translate="yes" xml:space="preserve">
          <source>Arguments to user-defined functions are always passed&lt;code&gt;BY REFERENCE&lt;/code&gt;</source>
          <target state="translated">사용자 정의 함수에 대한 인수는 항상 &lt;code&gt;BY REFERENCE&lt;/code&gt; 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="73d03321e72215121bde5deab4f021ad90feeeaf" translate="yes" xml:space="preserve">
          <source>Arguments will be passed in left-to-right sequence.</source>
          <target state="translated">인수는 왼쪽에서 오른쪽 순서로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6553652d52b882b2fa85e1ddeed243f74a2a8cfe" translate="yes" xml:space="preserve">
          <source>Arguments will be passed in right-to-left sequence</source>
          <target state="translated">인수는 오른쪽에서 왼쪽 순서로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="13f8cae111c9429795ca36d0d8ea0de0ed73fa2e" translate="yes" xml:space="preserve">
          <source>Arguments will be separated by treating spaces and/or tab characters as the delimiters between arguments. The number of such delimiters separating two non-blank argument values is irrelevant.</source>
          <target state="translated">인수는 공백 및 / 또는 탭 문자를 인수 사이의 구분자로 처리하여 분리됩니다. 두 개의 공백이 아닌 인수 값을 분리하는 이러한 분리 문자의 수는 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7916a12fca1750cc9ed24af496c281048c649162" translate="yes" xml:space="preserve">
          <source>Arithmetic expressions are formed using four categories of operations &amp;mdash; exponentiation, multiplication &amp;amp; division, addition &amp;amp; subtraction, and sign specification.</source>
          <target state="translated">Arithmetic expressions are formed using four categories of operations &amp;mdash; exponentiation, multiplication &amp;amp; division, addition &amp;amp; subtraction, and sign specification.</target>
        </trans-unit>
        <trans-unit id="88b8b7be3d74c23d3dcc83074799de5e5c536973" translate="yes" xml:space="preserve">
          <source>Arithmetic overflow in calculation</source>
          <target state="translated">계산시 산술 오버플로</target>
        </trans-unit>
        <trans-unit id="80db2ce40cc9814703d58bd80f29165f71702f70" translate="yes" xml:space="preserve">
          <source>Arithmetic-Expression Syntax</source>
          <target state="translated">산술 표현 구문</target>
        </trans-unit>
        <trans-unit id="ca11394a0b053ab0f486150df6563b365bcc4080" translate="yes" xml:space="preserve">
          <source>As a general rule of thumb, Windows implementations support two levels while Unix ones support all three.</source>
          <target state="translated">일반적으로 Windows 구현은 두 가지 수준을 지원하는 반면 Unix는 세 가지 수준을 모두 지원합니다.</target>
        </trans-unit>
        <trans-unit id="23e3795d0ffdc85df6595641a282fec4cee1b019" translate="yes" xml:space="preserve">
          <source>As a result of the sort, our program might expect to see data somewhat like this (date, time and sales totals are shown as &quot;&amp;hellip;&quot;):</source>
          <target state="translated">정렬 결과 Google 프로그램은 다음과 같은 데이터를 예상 할 수 있습니다 (날짜, 시간 및 총 판매량은 &quot;&amp;hellip;&quot;로 표시됨).</target>
        </trans-unit>
        <trans-unit id="07b7464425cc13f1b75723867012405ff31ea80d" translate="yes" xml:space="preserve">
          <source>As a result of the sort, our program might expect to see data somewhat like this (date, time and sales totals are shown as &amp;ldquo;&amp;hellip;&amp;rdquo;):</source>
          <target state="translated">As a result of the sort, our program might expect to see data somewhat like this (date, time and sales totals are shown as &amp;ldquo;&amp;hellip;&amp;rdquo;):</target>
        </trans-unit>
        <trans-unit id="79e97cb7b9075f47df3433b5132aca0b002264de" translate="yes" xml:space="preserve">
          <source>As an alternative to using the  &lt;code&gt;ALL INTRINSIC&lt;/code&gt; clause, you may instead compile your GnuCOBOL programs using the</source>
          <target state="translated">As an alternative to using the &lt;code&gt;ALL INTRINSIC&lt;/code&gt; clause, you may instead compile your GnuCOBOL programs using the</target>
        </trans-unit>
        <trans-unit id="4940f97a91d71dcdb635d4a2e00daa08b2606846" translate="yes" xml:space="preserve">
          <source>As an alternative to using the&lt;code&gt;ALL INTRINSIC&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ALL INTRINSIC&lt;/code&gt; 사용에 대한 대안으로</target>
        </trans-unit>
        <trans-unit id="ed3cb936dd4f7b90bf8660668779f10b38d855da" translate="yes" xml:space="preserve">
          <source>As an example, the following statement passes three arguments to a subroutine &amp;mdash; each argument is passed differently.</source>
          <target state="translated">예를 들어, 다음 명령문은 세 개의 인수를 서브 루틴에 전달합니다. 각 인수는 다르게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d08c9e1d43bf3266b629d31500d42492d8c881ed" translate="yes" xml:space="preserve">
          <source>As compared to:</source>
          <target state="translated">비교하자면:</target>
        </trans-unit>
        <trans-unit id="db6506b02535815ce8b9ce2ba0ca60872f2c269c" translate="yes" xml:space="preserve">
          <source>As data is loaded into the sort work file, it is actually being buffered in dynamically-allocated memory. Only if the amount of data to be sorted exceeds the amount of available sort memory (128 MB) will actual disk files be allocated and utilized. There is a</source>
          <target state="translated">데이터가 정렬 작업 파일에로드 될 때 실제로 동적으로 할당 된 메모리에 버퍼링됩니다. 정렬 할 데이터의 양이 사용 가능한 정렬 메모리 (128MB)를 초과하는 경우에만 실제 디스크 파일이 할당되고 활용됩니다. 이있다</target>
        </trans-unit>
        <trans-unit id="17e862ea09e7ebaab3a489d170c1217d3f510897" translate="yes" xml:space="preserve">
          <source>As data is loaded into the sort work file, it is actually being buffered in dynamically-allocated memory. Only if the amount of data to be sorted exceeds the amount of available sort memory (128 MB) will actual disk files be allocated and utilized. There is a   &lt;code&gt;COB_SORT_MEMORY&lt;/code&gt; run-time environment variable (see &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;Run Time Environment Variables&lt;/a&gt;) that you may use to allocate more or less memory to the sorting process.</source>
          <target state="translated">As data is loaded into the sort work file, it is actually being buffered in dynamically-allocated memory. Only if the amount of data to be sorted exceeds the amount of available sort memory (128 MB) will actual disk files be allocated and utilized. There is a &lt;code&gt;COB_SORT_MEMORY&lt;/code&gt; run-time environment variable (see &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;Run Time Environment Variables&lt;/a&gt;) that you may use to allocate more or less memory to the sorting process.</target>
        </trans-unit>
        <trans-unit id="357b7b0ad5ecd29f746fa2dde581cd8aa0e2a352" translate="yes" xml:space="preserve">
          <source>As discussed previously, dynamically-loadable libraries are created via the compiler&amp;rsquo;s</source>
          <target state="translated">As discussed previously, dynamically-loadable libraries are created via the compiler&amp;rsquo;s</target>
        </trans-unit>
        <trans-unit id="130f906685b8ffff68b8730ad2a15f8e8f5583c4" translate="yes" xml:space="preserve">
          <source>As discussed previously, dynamically-loadable libraries are created via the compiler&amp;rsquo;s&lt;code&gt;-m&lt;/code&gt;switch. Once so created, the program(s) in these libraries are executed from the command line (via the GnuCOBOL&lt;code&gt;cobcrun&lt;/code&gt;utility), or as dynamically-loadable subprograms.</source>
          <target state="translated">앞에서 설명한 것처럼 동적으로로드 가능한 라이브러리는 컴파일러의 &lt;code&gt;-m&lt;/code&gt; 스위치 를 통해 생성됩니다 . 이렇게 만들어진 라이브러리의 프로그램은 명령 줄 (GnuCOBOL &lt;code&gt;cobcrun&lt;/code&gt; 유틸리티 를 통해 )에서 또는 동적으로로드 가능한 서브 프로그램으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="bf294a7904a387f4b244a94b210d1b2d9c1c54ba" translate="yes" xml:space="preserve">
          <source>As each of the above folders is searched for a copybook &amp;mdash; &lt;code&gt;COPY &lt;var&gt;XXXXXXXX&lt;/var&gt;.&lt;/code&gt;, for example &amp;mdash; the GnuCOBOL compiler will attempt to locate the copybook file by any of the following names, in the sequence shown:</source>
          <target state="translated">As each of the above folders is searched for a copybook &amp;mdash; &lt;code&gt;COPY &lt;var&gt;XXXXXXXX&lt;/var&gt;.&lt;/code&gt; , for example &amp;mdash; the GnuCOBOL compiler will attempt to locate the copybook file by any of the following names, in the sequence shown:</target>
        </trans-unit>
        <trans-unit id="e399bfe42d083f8487e6c9d998df2c372852b952" translate="yes" xml:space="preserve">
          <source>As each of the above folders is searched for a copybook &amp;mdash;&lt;code&gt;COPY XXXXXXXX.&lt;/code&gt; for example &amp;mdash; the GnuCOBOL compiler will attempt to locate the copybook file by any of the following names, in the sequence shown:</source>
          <target state="translated">위의 각 폴더에서 카피 북 ( &lt;code&gt;COPY XXXXXXXX.&lt;/code&gt; )을 검색합니다 . 예를 들어 &amp;mdash; GnuCOBOL 컴파일러는 표시된 순서대로 다음 이름 중 하나를 사용하여 카피 북 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="b4b9c9f14350cbf32c6e16e0f3ab9c89980eaa43" translate="yes" xml:space="preserve">
          <source>As far as enforcement goes, however, both alphabetic and numeric picture strings do provide for both compile-time and run-time enforcement capabilities. In the case of compilation enforcement, the compiler can issue warning messages if you attempt to specify a non-numeric value for a numeric data item or if you attempt to &lt;code&gt;MOVE&lt;/code&gt; (see &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt;) a non-numeric data item to one that is numeric. Similar capabilities exist for alphabetic data items. At run-time, you may use a special class test (see &lt;a href=&quot;#Class-Conditions&quot;&gt;Class Conditions&lt;/a&gt;) to determine if the contents of a data item are entirely numeric or entirely alphabetic.</source>
          <target state="translated">As far as enforcement goes, however, both alphabetic and numeric picture strings do provide for both compile-time and run-time enforcement capabilities. In the case of compilation enforcement, the compiler can issue warning messages if you attempt to specify a non-numeric value for a numeric data item or if you attempt to &lt;code&gt;MOVE&lt;/code&gt; (see &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt;) a non-numeric data item to one that is numeric. Similar capabilities exist for alphabetic data items. At run-time, you may use a special class test (see &lt;a href=&quot;#Class-Conditions&quot;&gt;Class Conditions&lt;/a&gt;) to determine if the contents of a data item are entirely numeric or entirely alphabetic.</target>
        </trans-unit>
        <trans-unit id="2b9ef072c68e60e92d584a7454cb8966303b7996" translate="yes" xml:space="preserve">
          <source>As far as enforcement goes, however, both alphabetic and numeric picture strings do provide for both compile-time and run-time enforcement capabilities. In the case of compilation enforcement, the compiler can issue warning messages if you attempt to specify a non-numeric value for a numeric data item or if you attempt to&lt;code&gt;MOVE&lt;/code&gt;(see &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt;) a non-numeric data item to one that is numeric. Similar capabilities exist for alphabetic data items. At run-time, you may use a special class test (see &lt;a href=&quot;#Class-Conditions&quot;&gt;Class Conditions&lt;/a&gt;) to determine if the contents of a data item are entirely numeric or entirely alphabetic.</source>
          <target state="translated">그러나 적용 범위 내에서 알파벳 및 숫자 그림 문자열은 모두 컴파일 타임 및 런타임 시행 기능을 제공합니다. 컴파일 적용의 경우 숫자 데이터 항목에 숫자가 아닌 값을 지정하려고 시도하거나 숫자가 아닌 데이터 항목을 숫자 인 항목으로 &lt;code&gt;MOVE&lt;/code&gt; ( &lt;a href=&quot;#MOVE&quot;&gt;이동&lt;/a&gt; 참조 ) 하려는 경우 컴파일러에서 경고 메시지를 발행 할 수 있습니다 . 알파벳 데이터 항목에도 비슷한 기능이 있습니다. 런타임에 특수 클래스 테스트 ( &lt;a href=&quot;#Class-Conditions&quot;&gt;클래스 조건&lt;/a&gt; 참조 )를 사용하여 데이터 항목의 컨텐츠가 완전히 숫자인지 알파벳인지를 판별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ad40a909df10f422708e91b6cbf3a539c3e0185" translate="yes" xml:space="preserve">
          <source>As is the case in almost any other programming language, the programmer is always free to use pairs of parenthesis to enclose sub-expressions of complex expressions that are to be evaluated before other sub-expressions rather than let operator precedence dictate the sequence of evaluation.</source>
          <target state="translated">거의 모든 다른 프로그래밍 언어에서와 같이, 프로그래머는 항상 괄호 쌍을 사용하여 연산자 우선 순위가 평가 순서를 지시하지 않고 다른 하위 식보다 먼저 평가할 복잡한 식의 하위 식을 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4554dd5b047e612be263380b9463354fcc00ea7b" translate="yes" xml:space="preserve">
          <source>As of the COBOL2002 standard, a second mode now exists for COBOL source code statements &amp;mdash; in this mode of operation, COBOL statements may each be up to 255 characters long, with no specific requirements as to what should appear in which columns.</source>
          <target state="translated">COBOL2002 표준에 따라 COBOL 소스 코드 명령문에 대한 두 번째 모드가 존재합니다.이 조작 모드에서 COBOL 명령문의 길이는 최대 255 자일 수 있으며 어떤 컬럼에 표시되어야하는 것에 대한 특정 요구 사항이 없습니다.</target>
        </trans-unit>
        <trans-unit id="bbf4ec3fd027ea442265a55111b5061b935e2373" translate="yes" xml:space="preserve">
          <source>As part of the &lt;code&gt;FROM&lt;/code&gt; clause of a &lt;code&gt;WRITE&lt;/code&gt; (see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;) or &lt;code&gt;RELEASE&lt;/code&gt; statement (see &lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt;).</source>
          <target state="translated">As part of the &lt;code&gt;FROM&lt;/code&gt; clause of a &lt;code&gt;WRITE&lt;/code&gt; (see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;) or &lt;code&gt;RELEASE&lt;/code&gt; statement (see &lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="fb58d585f15052eb908472a7a363374cbf8ad1b6" translate="yes" xml:space="preserve">
          <source>As part of the &lt;code&gt;TIMES&lt;/code&gt; clause of a &lt;code&gt;PERFORM&lt;/code&gt; statement (see &lt;a href=&quot;#PERFORM&quot;&gt;PERFORM&lt;/a&gt;).</source>
          <target state="translated">As part of the &lt;code&gt;TIMES&lt;/code&gt; clause of a &lt;code&gt;PERFORM&lt;/code&gt; statement (see &lt;a href=&quot;#PERFORM&quot;&gt;PERFORM&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="1c8a528c8a5db43a4c93339f852a40ec0f50d952" translate="yes" xml:space="preserve">
          <source>As part of the&lt;code&gt;FROM&lt;/code&gt;clause of a&lt;code&gt;WRITE&lt;/code&gt;(see &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt;) or&lt;code&gt;RELEASE&lt;/code&gt;statement (see &lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt;).</source>
          <target state="translated">의 일환으로 &lt;code&gt;FROM&lt;/code&gt; (A)의 절 &lt;code&gt;WRITE&lt;/code&gt; (참조 &lt;a href=&quot;#WRITE&quot;&gt;WRITE&lt;/a&gt; ) 또는 &lt;code&gt;RELEASE&lt;/code&gt; 의 문 (참조 &lt;a href=&quot;#RELEASE&quot;&gt;유출&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a73a4ca502e493378755eafa2beace7b47077369" translate="yes" xml:space="preserve">
          <source>As part of the&lt;code&gt;TIMES&lt;/code&gt;clause of a&lt;code&gt;PERFORM&lt;/code&gt;statement (see &lt;a href=&quot;#PERFORM&quot;&gt;PERFORM&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;PERFORM&lt;/code&gt; 문의 &lt;code&gt;TIMES&lt;/code&gt; 절의 일부로 ( &lt;a href=&quot;#PERFORM&quot;&gt;PERFORM&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="cc65d45b9011ac878d2498dcd83d119719e2ba99" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;MERGE&lt;/code&gt; statement begins execution, the first record in each of the  &lt;code&gt;USING&lt;/code&gt; files is read automatically.</source>
          <target state="translated">As the &lt;code&gt;MERGE&lt;/code&gt; statement begins execution, the first record in each of the &lt;code&gt;USING&lt;/code&gt; files is read automatically.</target>
        </trans-unit>
        <trans-unit id="63f3ab7d286ce0ad479b4c3595ba167d791cfbef" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;MERGE&lt;/code&gt; statement executes, the current record from each of the &lt;code&gt;USING&lt;/code&gt; files is examined and compared to each other according to the rules set forth by the &lt;code&gt;KEY&lt;/code&gt; clause and the alphabet (see &lt;a href=&quot;#Alphabet_002dName_002dClause&quot;&gt;Alphabet-Name-Clause&lt;/a&gt;) specified on the  &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; clause. The record that should be next in sequence will be written to the merge work file and the &lt;code&gt;USING&lt;/code&gt; file from which that record came will be read so that its next record is available. As end-of-file conditions are reached on &lt;code&gt;USING&lt;/code&gt; files, those files will be excluded from further processing &amp;mdash; processing continues with the remaining files until all the contents of all of them have been exhausted.</source>
          <target state="translated">As the &lt;code&gt;MERGE&lt;/code&gt; statement executes, the current record from each of the &lt;code&gt;USING&lt;/code&gt; files is examined and compared to each other according to the rules set forth by the &lt;code&gt;KEY&lt;/code&gt; clause and the alphabet (see &lt;a href=&quot;#Alphabet_002dName_002dClause&quot;&gt;Alphabet-Name-Clause&lt;/a&gt;) specified on the &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; clause. The record that should be next in sequence will be written to the merge work file and the &lt;code&gt;USING&lt;/code&gt; file from which that record came will be read so that its next record is available. As end-of-file conditions are reached on &lt;code&gt;USING&lt;/code&gt; files, those files will be excluded from further processing &amp;mdash; processing continues with the remaining files until all the contents of all of them have been exhausted.</target>
        </trans-unit>
        <trans-unit id="61bc43269493911cc16b9d89987b310d7a490a16" translate="yes" xml:space="preserve">
          <source>As the diagram shows, there are three types of statements that may occur in the two paragraphs of this section. If none of the statements are coded in a particular paragraph, the paragraph itself may be omitted, otherwise it is required.</source>
          <target state="translated">다이어그램에서 알 수 있듯이이 섹션의 두 단락에서 발생할 수있는 세 가지 유형의 진술이 있습니다. 특정 문단에서 어떤 문장도 코딩되지 않으면, 문단 자체는 생략 될 수 있고, 그렇지 않으면 필요하다.</target>
        </trans-unit>
        <trans-unit id="3ffa23f73df55fe9017e41640911e5d5e7d20faf" translate="yes" xml:space="preserve">
          <source>As the syntax diagram shows, the definition of a &amp;lt;&amp;lt;</source>
          <target state="translated">구문 다이어그램에서 볼 수 있듯이 &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="cff12ad98a0c9de372e14dcdf790c28b35280735" translate="yes" xml:space="preserve">
          <source>As the syntax diagram shows, the definition of a &lt;code&gt;&lt;var&gt;LINKAGE-SECTION-Data-Item&lt;/var&gt;&lt;/code&gt; is a recursive one in that there may be any number of such specifications coded following one another. The first such specification must have a level number of 01. Specifications that follow that one may have level numbers greater than 01, in which case they are defining a hierarchical breakdown of a record. The definition of a record is terminated when one of the following occurs:</source>
          <target state="translated">As the syntax diagram shows, the definition of a &lt;code&gt;&lt;var&gt;LINKAGE-SECTION-Data-Item&lt;/var&gt;&lt;/code&gt; is a recursive one in that there may be any number of such specifications coded following one another. The first such specification must have a level number of 01. Specifications that follow that one may have level numbers greater than 01, in which case they are defining a hierarchical breakdown of a record. The definition of a record is terminated when one of the following occurs:</target>
        </trans-unit>
        <trans-unit id="5f0b1b1f6f2944c9421f6744a0907d40a8a65c25" translate="yes" xml:space="preserve">
          <source>As the syntax diagram shows, the definition of a &lt;code&gt;&lt;var&gt;LOCAL-STORAGE-SECTION-Data-Item&lt;/var&gt;&lt;/code&gt; is a recursive one in that there may be any number of such specifications coded following one another. The first such specification must have a level number of 01. Specifications that follow that one may have level numbers greater than 01, in which case they are defining a hierarchical breakdown of a record. The definition of a record is terminated when one of the following occurs:</source>
          <target state="translated">As the syntax diagram shows, the definition of a &lt;code&gt;&lt;var&gt;LOCAL-STORAGE-SECTION-Data-Item&lt;/var&gt;&lt;/code&gt; is a recursive one in that there may be any number of such specifications coded following one another. The first such specification must have a level number of 01. Specifications that follow that one may have level numbers greater than 01, in which case they are defining a hierarchical breakdown of a record. The definition of a record is terminated when one of the following occurs:</target>
        </trans-unit>
        <trans-unit id="39dc2498a30b5d566019356c890469467bf54380" translate="yes" xml:space="preserve">
          <source>As the syntax diagram shows, the definition of a &lt;code&gt;&lt;var&gt;WORKING-STORAGE-SECTION-Data-Item&lt;/var&gt;&lt;/code&gt; is a recursive one in that there may be any number of such specifications coded following one another. The first such specification must have a level number of 01. Specifications that follow that one may have level numbers greater than 01, in which case they are defining a hierarchical breakdown of a record. The definition of a record is terminated when one of the following occurs:</source>
          <target state="translated">As the syntax diagram shows, the definition of a &lt;code&gt;&lt;var&gt;WORKING-STORAGE-SECTION-Data-Item&lt;/var&gt;&lt;/code&gt; is a recursive one in that there may be any number of such specifications coded following one another. The first such specification must have a level number of 01. Specifications that follow that one may have level numbers greater than 01, in which case they are defining a hierarchical breakdown of a record. The definition of a record is terminated when one of the following occurs:</target>
        </trans-unit>
        <trans-unit id="ec580ad87a6ea88762c54a0d31bab4da9e4fdef7" translate="yes" xml:space="preserve">
          <source>As the syntax diagram shows, the definition of a &lt;var&gt;FILE-SECTION-Data-Item&lt;/var&gt; is a recursive one in that there may be any number of such specifications coded following a FD or SD. The first such specification must have a level number of 01, and will describe a specific format of data record within the file. Specifications that follow that one may have level numbers greater than 01, in which case they are defining a hierarchical breakdown of the record. The definition of a record is terminated when one of the following occurs:</source>
          <target state="translated">As the syntax diagram shows, the definition of a &lt;var&gt;FILE-SECTION-Data-Item&lt;/var&gt; is a recursive one in that there may be any number of such specifications coded following a FD or SD. The first such specification must have a level number of 01, and will describe a specific format of data record within the file. Specifications that follow that one may have level numbers greater than 01, in which case they are defining a hierarchical breakdown of the record. The definition of a record is terminated when one of the following occurs:</target>
        </trans-unit>
        <trans-unit id="296b852b8448d93942a077ab3a1b94c0c3fed6cf" translate="yes" xml:space="preserve">
          <source>As the&lt;code&gt;MERGE&lt;/code&gt;statement begins execution, the first record in each of the&lt;code&gt;USING&lt;/code&gt;</source>
          <target state="translated">는 AS &lt;code&gt;MERGE&lt;/code&gt; 의 문은 실행의 각각의 첫 번째 레코드 시작 &lt;code&gt;USING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46e9f2414adf575e04776803bd34d80ab6b46c0b" translate="yes" xml:space="preserve">
          <source>As the&lt;code&gt;MERGE&lt;/code&gt;statement executes, the current record from each of the&lt;code&gt;USING&lt;/code&gt;files is examined and compared to each other according to the rules set forth by the&lt;code&gt;KEY&lt;/code&gt;clause and the alphabet (see &lt;a href=&quot;#Alphabet_002dName_002dClause&quot;&gt;Alphabet-Name-Clause&lt;/a&gt;) specified on the&lt;code&gt;COLLATING SEQUENCE&lt;/code&gt;</source>
          <target state="translated">는 AS &lt;code&gt;MERGE&lt;/code&gt; 의 문이 실행의 각에서 현재 레코드 &lt;code&gt;USING&lt;/code&gt; 파일을 검사하고 정한 규칙에 서로있어서 비교됩니다 &lt;code&gt;KEY&lt;/code&gt; 의 절과 알파벳 (참조 &lt;a href=&quot;#Alphabet_002dName_002dClause&quot;&gt;알파벳 - 이름 - 조&lt;/a&gt; 상의 지정) &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3223505cf0f385fb48234e866679fed3fe9b7f4e" translate="yes" xml:space="preserve">
          <source>As was presented earlier (see &lt;a href=&quot;#Structured-Data&quot;&gt;Structured Data&lt;/a&gt;), a data item that is broken down into other data items is referred to as a group item, while one that isn&amp;rsquo;t broken down is called an elementary item.</source>
          <target state="translated">앞에서 설명한 것처럼 ( &lt;a href=&quot;#Structured-Data&quot;&gt;구조적 데이터&lt;/a&gt; 참조 ) 다른 데이터 항목으로 분류 된 데이터 항목을 그룹 항목이라고하며, 분류되지 않은 항목을 기본 항목이라고합니다.</target>
        </trans-unit>
        <trans-unit id="981d288884a6c738196484a0a06ae81b95b8662d" translate="yes" xml:space="preserve">
          <source>As with the other divisions, the procedure division may consist of sections and those sections may &amp;mdash; in turn &amp;mdash; consist of paragraphs. Unlike the other divisions, however, section and paragraph names are defined by the programmer, and there may not be any defined at all if the programmer so wishes.</source>
          <target state="translated">다른 부서와 마찬가지로 절차 부서는 섹션으로 구성 될 수 있으며 해당 섹션은 단락으로 구성 될 수 있습니다. 그러나 다른 부서와 달리 섹션과 단락 이름은 프로그래머가 정의하며 프로그래머가 원하는 경우 전혀 정의되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca7e2fab21e4edc6af668af55edb54e9ffaad2a0" translate="yes" xml:space="preserve">
          <source>As you can see, there was a huge drop in &lt;code&gt;USAGE COMP&lt;/code&gt; timings by turning off truncation. As a result, I see absolutely no reason whatsoever why the</source>
          <target state="translated">As you can see, there was a huge drop in &lt;code&gt;USAGE COMP&lt;/code&gt; timings by turning off truncation. As a result, I see absolutely no reason whatsoever why the</target>
        </trans-unit>
        <trans-unit id="9ae745acf0a462b1dd7c6cde5493e5c68ae7843d" translate="yes" xml:space="preserve">
          <source>As you can see, there was a huge drop in&lt;code&gt;USAGE COMP&lt;/code&gt;timings by turning off truncation. As a result, I see absolutely no reason whatsoever why the&lt;code&gt;-fnotrunc&lt;/code&gt;switch option shouldn&amp;rsquo;t be used on all GnuCOBOL compilations.</source>
          <target state="translated">보다시피 잘림을 끄면 &lt;code&gt;USAGE COMP&lt;/code&gt; 타이밍 이 크게 떨어졌습니다 . 결과적으로, &lt;code&gt;-fnotrunc&lt;/code&gt; 스위치 옵션이 모든 GnuCOBOL 컴파일에 사용되어서 는 안되는 이유가 전혀 없습니다.</target>
        </trans-unit>
        <trans-unit id="45127190d833b850823da0c28cb0b1bc991d2347" translate="yes" xml:space="preserve">
          <source>Ascending sequence of store number</source>
          <target state="translated">상점 번호의 오름차순</target>
        </trans-unit>
        <trans-unit id="4b58cd30268fe2ebaba2141e1041c33967620f38" translate="yes" xml:space="preserve">
          <source>Assuming that &quot;Nibble&quot; is a numeric data item with a value in the range 0-15, and Hex-Digits is a&lt;code&gt;PIC X(16)&lt;/code&gt;item with a value of &quot;0123456789ABCDEF&quot;, this converts that numeric value to a hexadecimal digit.</source>
          <target state="translated">&quot;니블&quot;이 0-15 범위의 값을 갖는 숫자 데이터 항목이고 16 진 숫자가 &quot;0123456789ABCDEF&quot;값을 갖는 &lt;code&gt;PIC X(16)&lt;/code&gt; 항목이라고 가정하면이 숫자 값을 16 진수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="66bbdec3cd4a241123166427097f1442a7b63dab" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;Nibble&lt;/code&gt; is a numeric data item with a value in the range 0-15, and Hex-Digits is a &lt;code&gt;PIC X(16)&lt;/code&gt; item with a value of &lt;code&gt;0123456789ABCDEF&lt;/code&gt;, this converts that numeric value to a hexadecimal digit.</source>
          <target state="translated">Assuming that &lt;code&gt;Nibble&lt;/code&gt; is a numeric data item with a value in the range 0-15, and Hex-Digits is a &lt;code&gt;PIC X(16)&lt;/code&gt; item with a value of &lt;code&gt;0123456789ABCDEF&lt;/code&gt; , this converts that numeric value to a hexadecimal digit.</target>
        </trans-unit>
        <trans-unit id="32f2c23c8e677b039e091ee427f68717b15f7c3d" translate="yes" xml:space="preserve">
          <source>At any point in time, there may well be multipl&lt;code&gt;REPLACING&lt;/code&gt;and/or&lt;code&gt;TALLYING&lt;/code&gt;operational instructions active. Only one of the&lt;code&gt;TALLYING&lt;/code&gt;and one of the&lt;code&gt;REPLACING&lt;/code&gt;instructions (if any) can be executed for any one character pointer position. In each case, it will be the first of the instructions in each category that produces a match with it&amp;rsquo;s target string specification.</source>
          <target state="translated">어느 시점에서나, 복수 &lt;code&gt;REPLACING&lt;/code&gt; 및 / 또는 &lt;code&gt;TALLYING&lt;/code&gt; 운영 설명서가 활성화되어 있을 수 있습니다 . 오직 하나 &lt;code&gt;TALLYING&lt;/code&gt; 과 하나 &lt;code&gt;REPLACING&lt;/code&gt; 지시 사항 (있는 경우) 한 문자와 포인터 위치를 실행할 수 있습니다. 각각의 경우, 대상 문자열 사양과 일치하는 각 범주의 첫 번째 명령이됩니다.</target>
        </trans-unit>
        <trans-unit id="d4407aff9b6ef34f7a22c45895bf6189a2b5ab4c" translate="yes" xml:space="preserve">
          <source>At any point in time, there may well be multiple&lt;code&gt;REPLACING&lt;/code&gt; and/or &lt;code&gt;TALLYING&lt;/code&gt; operational instructions active. Only one of the &lt;code&gt;TALLYING&lt;/code&gt; and one of the &lt;code&gt;REPLACING&lt;/code&gt; instructions (if any) can be executed for any one character pointer position. In each case, it will be the first of the instructions in each category that produces a match with its target string specification.</source>
          <target state="translated">At any point in time, there may well be multiple &lt;code&gt;REPLACING&lt;/code&gt; and/or &lt;code&gt;TALLYING&lt;/code&gt; operational instructions active. Only one of the &lt;code&gt;TALLYING&lt;/code&gt; and one of the &lt;code&gt;REPLACING&lt;/code&gt; instructions (if any) can be executed for any one character pointer position. In each case, it will be the first of the instructions in each category that produces a match with its target string specification.</target>
        </trans-unit>
        <trans-unit id="58024c82e77f41a36e760c889c0d9e393020d8c4" translate="yes" xml:space="preserve">
          <source>At execution time, each &amp;lt;</source>
          <target state="translated">실행시 각 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="dee76242c11145e778baf4ac5644916e93897119" translate="yes" xml:space="preserve">
          <source>At execution time, each &lt;var&gt;Selection-Subject&lt;/var&gt; on the &lt;code&gt;EVALUATE&lt;/code&gt; statement will have its value matched against that of the corresponding &lt;var&gt;Selection-Object&lt;/var&gt; on a &lt;code&gt;WHEN&lt;/code&gt; clause, in turn, until:</source>
          <target state="translated">At execution time, each &lt;var&gt;Selection-Subject&lt;/var&gt; on the &lt;code&gt;EVALUATE&lt;/code&gt; statement will have its value matched against that of the corresponding &lt;var&gt;Selection-Object&lt;/var&gt; on a &lt;code&gt;WHEN&lt;/code&gt; clause, in turn, until:</target>
        </trans-unit>
        <trans-unit id="25a6ce82acdc6bc612fd3d2cffdae1b97075c917" translate="yes" xml:space="preserve">
          <source>At execution time, each switch will be associated with a</source>
          <target state="translated">실행 시간에 각 스위치는</target>
        </trans-unit>
        <trans-unit id="0feed9ce50537151cf27bd118346051a85bdbb57" translate="yes" xml:space="preserve">
          <source>At execution time, each switch will be associated with a   &lt;code&gt;COB_SWITCH_n&lt;/code&gt; run-time environment variable, where &lt;code&gt;&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; will have the value &amp;lsquo;</source>
          <target state="translated">At execution time, each switch will be associated with a &lt;code&gt;COB_SWITCH_n&lt;/code&gt; run-time environment variable, where &lt;code&gt;&lt;var&gt;n&lt;/var&gt;&lt;/code&gt; will have the value &amp;lsquo;</target>
        </trans-unit>
        <trans-unit id="f11e7555a3db0fbb052544056af2d1e237d33472" translate="yes" xml:space="preserve">
          <source>At execution time:</source>
          <target state="translated">실행시 :</target>
        </trans-unit>
        <trans-unit id="647179385f65989bb1991c21428c0fb0057583a7" translate="yes" xml:space="preserve">
          <source>At run-time, the declaratives procedure will be executed prior to the processing of the specified report group&amp;rsquo;s presentation; within the procedure you may take either of the following actions:</source>
          <target state="translated">런타임에 선언 절차는 지정된 보고서 그룹의 프리젠 테이션을 처리하기 전에 실행됩니다. 절차 내에서 다음 작업 중 하나를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01310ca02d6126e684ea6f952a4183e369fb93b9" translate="yes" xml:space="preserve">
          <source>At runtime, GnuCOBOL will attempt to locate and load any application dynamically-loadable libraries using from the directory in which the program executable was found or, if it wasn&amp;rsquo;t found there, using the &lt;code&gt;PATH&lt;/code&gt; environment variable. If these library files could be somewhere else, specify the directory path using this variable.</source>
          <target state="translated">At runtime, GnuCOBOL will attempt to locate and load any application dynamically-loadable libraries using from the directory in which the program executable was found or, if it wasn&amp;rsquo;t found there, using the &lt;code&gt;PATH&lt;/code&gt; environment variable. If these library files could be somewhere else, specify the directory path using this variable.</target>
        </trans-unit>
        <trans-unit id="5f8a283974d95356738167d0faee952966ac8cf5" translate="yes" xml:space="preserve">
          <source>At runtime, GnuCOBOL will attempt to locate and load any application dynamically-loadable libraries using from the directory in which the program executable was found or, if it wasn&amp;rsquo;t found there, using the&lt;code&gt;PATH&lt;/code&gt;environment variable. If these library files could be somewhere else, specify the directory path using this variable.</source>
          <target state="translated">런타임시 GnuCOBOL은 프로그램 실행 파일이 발견 된 디렉토리 또는 &lt;code&gt;PATH&lt;/code&gt; 환경 변수를 사용하는 디렉토리를 사용하여 동적으로로드 가능한 응용 프로그램 라이브러리를 찾아로드하려고 시도 합니다. 이러한 라이브러리 파일이 다른 곳에있을 수 있으면이 변수를 사용하여 디렉토리 경로를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="69680062a5d35f9afe3998d8e2b8f54fac45f3f0" translate="yes" xml:space="preserve">
          <source>At the time the &lt;code&gt;SEARCH&lt;/code&gt; statement is executed, the current value of the search index data item will define the starting position in the table where the searching process will begin. Typically, one initializes that index to a value of 1 before starting the &lt;code&gt;SEARCH&lt;/code&gt; via &lt;code&gt;SET &lt;var&gt;search-index&lt;/var&gt; TO 1&lt;/code&gt;.</source>
          <target state="translated">At the time the &lt;code&gt;SEARCH&lt;/code&gt; statement is executed, the current value of the search index data item will define the starting position in the table where the searching process will begin. Typically, one initializes that index to a value of 1 before starting the &lt;code&gt;SEARCH&lt;/code&gt; via &lt;code&gt;SET &lt;var&gt;search-index&lt;/var&gt; TO 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37e1eae840e0c2a638d59f8b7735b08d5540b3e4" translate="yes" xml:space="preserve">
          <source>At the time the &lt;code&gt;UNSTRING&lt;/code&gt; statement begins execution, &lt;var&gt;identifier-7&lt;/var&gt; must have a value greater than 0.</source>
          <target state="translated">At the time the &lt;code&gt;UNSTRING&lt;/code&gt; statement begins execution, &lt;var&gt;identifier-7&lt;/var&gt; must have a value greater than 0.</target>
        </trans-unit>
        <trans-unit id="35d00c7319a69497c5e9e19b0ab3f8ae51f105d6" translate="yes" xml:space="preserve">
          <source>At the time the&lt;code&gt;SEARCH&lt;/code&gt;statement is executed, the current value of the search index data item will define the starting position in the table where the searching process will begin. Typically, one initializes that index to a value of 1 before starting the&lt;code&gt;SEARCH&lt;/code&gt;via&lt;code&gt;SET &amp;lt;&lt;i&gt;search-index&lt;/i&gt;&amp;gt; TO 1&lt;/code&gt;</source>
          <target state="translated">하여 시간에 &lt;code&gt;SEARCH&lt;/code&gt; 문을 실행, 검색 인덱스 데이터 항목의 현재 값은 검색 프로세스가 시작됩니다 테이블의 시작 위치를 정의합니다. 일반적으로 &lt;code&gt;SET &amp;lt;&lt;i&gt;search-index&lt;/i&gt;&amp;gt; TO 1&lt;/code&gt; &lt;i&gt;search-index&lt;/i&gt; &amp;gt; TO 1을 통해 &lt;code&gt;SEARCH&lt;/code&gt; 을 시작하기 전에 해당 색인을 1의 값으로 초기화합니다 .&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="ed45c44186dd9ae465a476d4332ba30e71a68719" translate="yes" xml:space="preserve">
          <source>At the time the&lt;code&gt;UNSTRING&lt;/code&gt;statement begins execution, &amp;lt;</source>
          <target state="translated">당시의 &lt;code&gt;UNSTRING&lt;/code&gt; 문은 실행을, &amp;lt;시작</target>
        </trans-unit>
        <trans-unit id="9d1f58c02dd35fe4d5f7ac2161db8990ad89caff" translate="yes" xml:space="preserve">
          <source>At the time this statement is executed, &amp;lt;</source>
          <target state="translated">이 문장이 실행될 때 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="55c475b22c4b316290db34999f18d64f0bacae09" translate="yes" xml:space="preserve">
          <source>At the time this statement is executed, &lt;var&gt;file-name-1&lt;/var&gt; must be open in either &lt;code&gt;INPUT&lt;/code&gt; or &lt;code&gt;I-O&lt;/code&gt; (see &lt;a href=&quot;#File-OPEN-Modes&quot;&gt;File OPEN Modes&lt;/a&gt;) mode.</source>
          <target state="translated">At the time this statement is executed, &lt;var&gt;file-name-1&lt;/var&gt; must be open in either &lt;code&gt;INPUT&lt;/code&gt; or &lt;code&gt;I-O&lt;/code&gt; (see &lt;a href=&quot;#File-OPEN-Modes&quot;&gt;File OPEN Modes&lt;/a&gt;) mode.</target>
        </trans-unit>
        <trans-unit id="606af63484a4ca0821092a5d382caa79df9a9798" translate="yes" xml:space="preserve">
          <source>Attempt to duplicate key value</source>
          <target state="translated">키 값을 복제하려고 시도</target>
        </trans-unit>
        <trans-unit id="0f2be3e5f21db8b67415235941f1f245af15e343" translate="yes" xml:space="preserve">
          <source>Attribute-Specification</source>
          <target state="translated">Attribute-Specification</target>
        </trans-unit>
        <trans-unit id="ea2809bc9bb1b5b06bf996a1198fef6b345d333c" translate="yes" xml:space="preserve">
          <source>Attribute-Specifications</source>
          <target state="translated">Attribute-Specifications</target>
        </trans-unit>
        <trans-unit id="678a0be9e390f7d62bca8435a3ee764c8865eaed" translate="yes" xml:space="preserve">
          <source>Automatically causing suppressed detail group-indicate fields to re-appear should a detail group be printed on a new page.</source>
          <target state="translated">상세 페이지가 새 페이지에 인쇄 될 때 억제 된 상세 그룹 표시 필드가 자동으로 다시 나타납니다.</target>
        </trans-unit>
        <trans-unit id="f2a17b9929690e89a26864251426fe169ae08b7e" translate="yes" xml:space="preserve">
          <source>Automatically generating crossfoot totals in detail groups. These would be sums of two or more values presented in the detail group.</source>
          <target state="translated">세부 그룹에서 십자 총계를 자동으로 생성합니다. 세부 사항 그룹에 제시된 둘 이상의 값의 합계입니다.</target>
        </trans-unit>
        <trans-unit id="bb8ed6d8eda696a34ea023ee1af0984ead161cd5" translate="yes" xml:space="preserve">
          <source>Automatically generating subtotals in control and/or report footings, summarizing values of any fields in the detail group.</source>
          <target state="translated">세부 그룹의 모든 필드 값을 요약하여 제어 및 / 또는 보고서 기초에 부분합을 자동으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="60128589a15735e233953a12911eaaf135fa1bba" translate="yes" xml:space="preserve">
          <source>Automatically suppressing the presentation of one or more fields of data from the detail group when the value(s) of the field(s) duplicate those of the previously generated detail group. Fields such as these are referred to as group-indicate fields.</source>
          <target state="translated">필드 값이 이전에 생성 된 세부 그룹의 값을 복제 할 때 세부 그룹에서 하나 이상의 데이터 필드 표시를 자동으로 억제합니다. 이와 같은 필드를 그룹 표시 필드라고합니다.</target>
        </trans-unit>
        <trans-unit id="15e6d5aff64c44c6c09e58d6ca500c39b31497c6" translate="yes" xml:space="preserve">
          <source>Avoid the use of level 77 data items in new programs. Once (1968 and before) there were valid reasons for creating level-77 data items, but since the 1974 ANSI standard of COBOL there really hasn&amp;rsquo;t been any reason why an elementary level-01 data item couldn&amp;rsquo;t have been used instead of a level-77 item.</source>
          <target state="translated">새 프로그램에서 레벨 77 데이터 항목을 사용하지 마십시오. 한 번 (1968 년과 그 이전) 수준 -77 데이터 항목을 작성해야하는 유효한 이유가 있었지만 1974 년 ANSI COBOL 표준 이후 기본 수준 -01 데이터 항목을 대신 사용할 수 없었던 이유는 없었습니다. 레벨 77 아이템.</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="1c1352f1426459c3d08f8eff48d2f3c2579dd8a8" translate="yes" xml:space="preserve">
          <source>B.cbl</source>
          <target state="translated">B.cbl</target>
        </trans-unit>
        <trans-unit id="3da6b74c184d77268e852ed014f324e193e614bb" translate="yes" xml:space="preserve">
          <source>BACKGROUND-COLOR Attribute Syntax</source>
          <target state="translated">배경색 속성 구문</target>
        </trans-unit>
        <trans-unit id="f411ede3baea24605588cbb252fe62af571daa22" translate="yes" xml:space="preserve">
          <source>BACKGROUND-COLOR, BACKGROUND-COLOUR, B-AND, BASED, BEEP, BEFORE, BELL, BINARY, BINARY-CHAR, BINARY-C-LONG, BINARY-DOUBLE, BINARY-INT, BINARY-LONG, BINARY-LONG-LONG, BINARY-SHORT, BIT, BLANK, BLINK, BLOCK, B-NOT, BOOLEAN, BOOLEAN-OF-INTEGER, B-OR, BOTTOM, B-XOR, BY, BYTE-LENGTH</source>
          <target state="translated">배경색, 배경색, B-AND, BASED, BEEP, BEFORE, BELL, BINARY, BINARY-CHAR, BINARY-C-LONG, BINARY-DOUBLE, BINARY-INT, BINARY-LONG, BINARY-LONG-LONG, 이진-짧음, 비트, 공백, 깜박임, 블록, B-NOT, BOOLEAN, BOOLEAN-OF-INTEGER, B-OR, BOTTOM, B-XOR, BY, BYTE-LENGTH</target>
        </trans-unit>
        <trans-unit id="7223a83910d26a564feef68e00ad2df02de25d01" translate="yes" xml:space="preserve">
          <source>BACKGROUND-COLOR, BACKGROUND-COLOUR, BACKGROUND-HIGH, BACKGROUND-LOW, BACKGROUND-STANDARD, B-AND, BAR, BASED, BEEP, BEFORE, BELL, BINARY-CHAR, BINARY-C-LONG, BINARY-DOUBLE, BINARY-INT, BINARY-LONG-LONG, BINARY-LONG, BINARY-SEQUENTIAL, BINARY-SHORT, BINARY, BITMAP-END, BITMAP-HANDLE, BITMAP-NUMBER, BITMAP-START, BITMAP-TIMER, BITMAP-TRAILING, BITMAP-TRANSPARENT-COLOR, BITMAP-WIDTH, BITMAP, BIT, BLANK, BLINK, BLOCK, B-NOT, BOOLEAN, BOOLEAN-OF-INTEGER, B-OR, BOTTOM, BOXED, BOX, BUSY, BUTTONS, B-XOR, BYTE-LENGTH, BY</source>
          <target state="translated">BACKGROUND-COLOR, BACKGROUND-COLOUR, BACKGROUND-HIGH, BACKGROUND-LOW, BACKGROUND-STANDARD, B-AND, BAR, BASED, BEEP, BEFORE, BELL, BINARY-CHAR, BINARY-C-LONG, BINARY-DOUBLE, BINARY-INT, BINARY-LONG-LONG, BINARY-LONG, BINARY-SEQUENTIAL, BINARY-SHORT, BINARY, BITMAP-END, BITMAP-HANDLE, BITMAP-NUMBER, BITMAP-START, BITMAP-TIMER, BITMAP-TRAILING, BITMAP-TRANSPARENT-COLOR, BITMAP-WIDTH, BITMAP, BIT, BLANK, BLINK, BLOCK, B-NOT, BOOLEAN, BOOLEAN-OF-INTEGER, B-OR, BOTTOM, BOXED, BOX, BUSY, BUTTONS, B-XOR, BYTE-LENGTH, BY</target>
        </trans-unit>
        <trans-unit id="246940a5ee7e2cc2179d2d28728ee99881870940" translate="yes" xml:space="preserve">
          <source>BASED Attribute Syntax</source>
          <target state="translated">기본 속성 구문</target>
        </trans-unit>
        <trans-unit id="25363e98eb50cc813f0d3eff743f34908419b557" translate="yes" xml:space="preserve">
          <source>BBBBBB</source>
          <target state="translated">BBBBBB</target>
        </trans-unit>
        <trans-unit id="8ea177ae44348802ce4e93e2c7d006f279b4d490" translate="yes" xml:space="preserve">
          <source>BBCCCCCCDD</source>
          <target state="translated">BBCCCCCCDD</target>
        </trans-unit>
        <trans-unit id="3e18c13faa05badb60aaead205679019d4320361" translate="yes" xml:space="preserve">
          <source>BCDE</source>
          <target state="translated">BCDE</target>
        </trans-unit>
        <trans-unit id="70ba3961bcb1e582a85eb1b34470c7230cbc539c" translate="yes" xml:space="preserve">
          <source>BEEP Attribute Syntax</source>
          <target state="translated">BEEP 속성 구문</target>
        </trans-unit>
        <trans-unit id="d558960d76fe706c5df114072aeb815b11efb49a" translate="yes" xml:space="preserve">
          <source>BELL Attribute Syntax</source>
          <target state="translated">BELL 속성 구문</target>
        </trans-unit>
        <trans-unit id="57c09c231f43d038a40874ee57c32eb4b4d4358e" translate="yes" xml:space="preserve">
          <source>BINARY-C-LONG SIGNED</source>
          <target state="translated">이진 C- 긴 서명</target>
        </trans-unit>
        <trans-unit id="dfad4a92eb32368ec9cfca9b772e8872465ce772" translate="yes" xml:space="preserve">
          <source>BINARY-C-LONG [ SIGNED ]</source>
          <target state="translated">BINARY-C-LONG [ SIGNED ]</target>
        </trans-unit>
        <trans-unit id="c532cb84fc65eabdea9215c7926d16c9453a0660" translate="yes" xml:space="preserve">
          <source>BINARY-CHAR SIGNED</source>
          <target state="translated">이진 문자 서명</target>
        </trans-unit>
        <trans-unit id="145ed4577cd51da9f6c530926d8034460db40ec1" translate="yes" xml:space="preserve">
          <source>BINARY-CHAR UNSIGNED</source>
          <target state="translated">BINARY-CHAR UNSIGNED</target>
        </trans-unit>
        <trans-unit id="ac9795d79f19daad12eea06df82b53717e890134" translate="yes" xml:space="preserve">
          <source>BINARY-CHAR [ SIGNED ]</source>
          <target state="translated">BINARY-CHAR [ SIGNED ]</target>
        </trans-unit>
        <trans-unit id="934c091fd7ba5885d6ae1783ee5da221368bbd09" translate="yes" xml:space="preserve">
          <source>BINARY-CHAR [ UNSIGNED ]</source>
          <target state="translated">이진 문자 [부호 없음]</target>
        </trans-unit>
        <trans-unit id="aafe074f1cc1d847beb11978954e0ba87923a323" translate="yes" xml:space="preserve">
          <source>BINARY-DOUBLE SIGNED  BINARY-LONG-LONG</source>
          <target state="translated">이진-더블 서명 된 이진-장기</target>
        </trans-unit>
        <trans-unit id="84372cccccc31245e954c74c8262dc88bbd76c44" translate="yes" xml:space="preserve">
          <source>BINARY-DOUBLE UNSIGNED</source>
          <target state="translated">BINARY-DOUBLE UNSIGNED</target>
        </trans-unit>
        <trans-unit id="c9bdcca4ee8cbb493a3622ef00a2e4eeba9baa54" translate="yes" xml:space="preserve">
          <source>BINARY-DOUBLE [ SIGNED ]  BINARY-LONG-LONG</source>
          <target state="translated">BINARY-DOUBLE [ SIGNED ] BINARY-LONG-LONG</target>
        </trans-unit>
        <trans-unit id="075818c3573fccee0500d38f830276c42183e050" translate="yes" xml:space="preserve">
          <source>BINARY-DOUBLE [ UNSIGNED ]</source>
          <target state="translated">이진수 더블 [부호 없음]</target>
        </trans-unit>
        <trans-unit id="64ca5c23f684a3e2bf961756a5622b8f8b0fd166" translate="yes" xml:space="preserve">
          <source>BINARY-LONG SIGNED  BINARY-INT</source>
          <target state="translated">이진-긴 서명 된 이진 -INT</target>
        </trans-unit>
        <trans-unit id="a2d5664e7380adc57231aa0207eda3f7890cf78b" translate="yes" xml:space="preserve">
          <source>BINARY-LONG SIGNED &amp;mdash; An occurrence of this register exists for each report defined in the program (via an&lt;code&gt;RD&lt;/code&gt;(see &lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;)). If there are multiple reports, any explicit references to this register not made in the report section will require qualification &lt;code&gt;OF report-name&lt;/code&gt;. The value of this register will be the current logical line number on the current page. The value of this register cannot be modified.</source>
          <target state="translated">BINARY-LONG SIGNED &amp;mdash;이 레지스터는 &lt;code&gt;RD&lt;/code&gt; 를 통해 프로그램에 정의 된 각 보고서마다 존재합니다 ( &lt;a href=&quot;#REPORT-SECTION&quot;&gt;보고서 섹션&lt;/a&gt; 참조). 여러 개의 보고서가있는 경우 보고서 섹션에서 작성되지 않은이 레지스터에 대한 명시적인 참조는 &lt;code&gt;OF report-name&lt;/code&gt; 자격이 필요합니다 . 이 레지스터의 값은 현재 페이지의 현재 논리 행 번호입니다. 이 레지스터의 값은 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="96d54aa9c6bdc14a259e2115e9bbbc98d0ec7b76" translate="yes" xml:space="preserve">
          <source>BINARY-LONG SIGNED &amp;mdash; An occurrence of this register exists for each report having an&lt;code&gt;RD&lt;/code&gt;(see &lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;). If there are multiple such reports, any explicit references to this register not made in the report section will require qualification (&lt;code&gt;OF report-name&lt;/code&gt;. The value of this register will be the current report page number. The value of this register cannot be modified.</source>
          <target state="translated">BINARY-LONG SIGNED &amp;mdash; &lt;code&gt;RD&lt;/code&gt; 가있는 각 보고서마다이 레지스터가 발생합니다 ( &lt;a href=&quot;#REPORT-SECTION&quot;&gt;보고서 섹션&lt;/a&gt; 참조 ). 이러한 보고서가 여러 개있는 경우 보고서 섹션에서 작성되지 않은이 레지스터에 대한 명시 적 참조는 규정 ( &lt;code&gt;OF report-name&lt;/code&gt; ) 이 필요합니다 .이 레지스터의 값은 현재 보고서 페이지 번호가되므로이 레지스터의 값을 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="301ddb41243ae8a1bb0469ad0facce57428c71d1" translate="yes" xml:space="preserve">
          <source>BINARY-LONG SIGNED &amp;mdash; An occurrence of this register exists for each selected file having a&lt;code&gt;LINAGE&lt;/code&gt;(see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;) clause. If there are multiple files whose file descriptions have&lt;code&gt;LINAGE&lt;/code&gt;clauses, any explicit references to this register will require qualification (using&lt;code&gt;OF file-name&lt;/code&gt;. The value of this register will be the current logical line number within the page body. The value of this register cannot be modified.</source>
          <target state="translated">BINARY-LONG SIGNED &amp;mdash; &lt;code&gt;LINAGE&lt;/code&gt; ( &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;파일 / 정렬 설명 참조&lt;/a&gt; ) 절이 있는 선택된 각 파일에 대해이 레지스터가 발생합니다 . 파일 설명에 &lt;code&gt;LINAGE&lt;/code&gt; 절이 있는 파일이 여러 개있는 경우이 레지스터에 대한 명시 적 참조는 규정이 필요합니다 ( &lt;code&gt;OF file-name&lt;/code&gt; 사용) .이 레지스터의 값은 페이지 본문 내의 현재 논리 행 번호입니다.이 레지스터의 값 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fa4246a0836a99373296efaa9aeb30a14c387022" translate="yes" xml:space="preserve">
          <source>BINARY-LONG SIGNED &amp;mdash; This register contains the number of arguments passed to a subroutine &amp;mdash; the same value that would be returned by the&lt;code&gt;C$NARG&lt;/code&gt;built-in system subroutine (see &lt;a href=&quot;#C_0024NARG&quot;&gt;C$NARG&lt;/a&gt;). Its value will be zero when referenced in a main program. This register, when referenced from within a user-defined function, returns a value of one (1) if the function has any number of arguments and a zero if it has no arguments.</source>
          <target state="translated">BINARY-LONG SIGNED &amp;mdash;이 레지스터는 서브 루틴에 전달 된 인수의 수를 포함합니다. &lt;code&gt;C$NARG&lt;/code&gt; 내장 시스템 서브 루틴에 의해 리턴되는 것과 동일한 값입니다 ( &lt;a href=&quot;#C_0024NARG&quot;&gt;C $ NARG&lt;/a&gt; 참조 ). 기본 프로그램에서 참조 될 때 그 값은 0이됩니다. 이 레지스터는 사용자 정의 함수 내에서 참조 될 때 함수에 여러 개의 인수가 있으면 1을 반환하고 인수가 없으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6b365a3917f2c77fadaebe0e884f83432c6fa091" translate="yes" xml:space="preserve">
          <source>BINARY-LONG SIGNED &amp;mdash; This register is used to report the success/fail status of a&lt;code&gt;RELEASE&lt;/code&gt;(see &lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt;) or&lt;code&gt;RETURN&lt;/code&gt;(see &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt;) statement. A value of 0 is reported on success. A value of 16 denotes failure. An&lt;code&gt;AT END&lt;/code&gt;(see &lt;a href=&quot;#AT-END-_002b-NOT-AT-END&quot;&gt;AT END + NOT AT END&lt;/a&gt;) condition on a&lt;code&gt;RETURN&lt;/code&gt;is not considered a failure.</source>
          <target state="translated">BINARY-LONG SIGNED &amp;mdash;이 레지스터는 &lt;code&gt;RELEASE&lt;/code&gt; ( &lt;a href=&quot;#RELEASE&quot;&gt;RELEASE&lt;/a&gt; 참조 ) 또는 &lt;code&gt;RETURN&lt;/code&gt; ( &lt;a href=&quot;#RETURN&quot;&gt;RETURN&lt;/a&gt; 참조 ) 문의 성공 / 실패 상태를보고하는 데 사용됩니다 . 성공하면 0 값이보고됩니다. 16의 값은 실패를 나타냅니다. &lt;code&gt;RETURN&lt;/code&gt; 의 &lt;code&gt;AT END&lt;/code&gt; ( &lt;a href=&quot;#AT-END-_002b-NOT-AT-END&quot;&gt;AT END + NOT AT END 참조&lt;/a&gt; ) 조건 은 실패로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="281502201847865cdea73cf4e5a9e802f6a160de" translate="yes" xml:space="preserve">
          <source>BINARY-LONG SIGNED &amp;mdash; This register provides a numeric data item into which a subroutine may&lt;code&gt;MOVE&lt;/code&gt;(see &lt;a href=&quot;#MOVE&quot;&gt;MOVE&lt;/a&gt;) a value (which will then be available to the calling program) prior to transferring control back to the program that called it, or into which a main program may&lt;code&gt;MOVE&lt;/code&gt;a value before returning control to the operating system. Many built-in subroutines will return a value using this register. These values are &amp;mdash; by convention &amp;mdash; used to signify success (usually with a value of 0) or failure (usually with a non-zero value) of the process the program was attempting to perform. This register may also be modified by a subprogram as a result of that subprogram&amp;rsquo;s use of the&lt;code&gt;RETURNING&lt;/code&gt;(see &lt;a href=&quot;#PROCEDURE-DIVISION-RETURNING&quot;&gt;PROCEDURE DIVISION RETURNING&lt;/a&gt;) clause.</source>
          <target state="translated">바이너리 긴 서명 -이 레지스터는 서브 루틴있다되는 수치 데이터 항목 제공 &lt;code&gt;MOVE&lt;/code&gt; (참조 : &lt;a href=&quot;#MOVE&quot;&gt;MOVE를&lt;/a&gt; 사전을 호출하거나되는 프로그램에 대한 제어를 다시 전송하기 (다음 호출 프로그램에 사용할 수있는) 값) 주 프로그램은 운영 체제로 제어를 리턴하기 전에 값을 &lt;code&gt;MOVE&lt;/code&gt; 수 있습니다. 많은 내장 서브 루틴이이 레지스터를 사용하여 값을 반환합니다. 이러한 값은 규칙에 따라 프로그램이 수행하려고 시도한 프로세스의 성공 (일반적으로 0 값) 또는 실패 (일반적으로 0이 아닌 값)를 나타내는 데 사용됩니다. 이 레지스터는 서브 프로그램이 &lt;code&gt;RETURNING&lt;/code&gt; 을 사용한 결과로 서브 프로그램에 의해 수정 될 수도 있습니다 ( &lt;a href=&quot;#PROCEDURE-DIVISION-RETURNING&quot;&gt;프로세스 구역 리턴&lt;/a&gt; 참조).) 절.</target>
        </trans-unit>
        <trans-unit id="0b2d35057ea047bd48609def2f5e53596b49b447" translate="yes" xml:space="preserve">
          <source>BINARY-LONG UNSIGNED</source>
          <target state="translated">BINARY-LONG UNSIGNED</target>
        </trans-unit>
        <trans-unit id="380ef2588f745d7b38fd6ca660ff0d01e64689d1" translate="yes" xml:space="preserve">
          <source>BINARY-LONG [ SIGNED ]  BINARY-INT</source>
          <target state="translated">BINARY-LONG [ SIGNED ] BINARY-INT</target>
        </trans-unit>
        <trans-unit id="f2d6edbc89733d33e22775d6d14c2d8e488258bc" translate="yes" xml:space="preserve">
          <source>BINARY-LONG [ UNSIGNED ]</source>
          <target state="translated">이진-길이 [부호 없음]</target>
        </trans-unit>
        <trans-unit id="ec492d0da770779cdab338b865b0f56c65f643c6" translate="yes" xml:space="preserve">
          <source>BINARY-SHORT SIGNED</source>
          <target state="translated">이진-단축 서명</target>
        </trans-unit>
        <trans-unit id="1a247fc8db1d6a85ae62f8d62c68a2ff2ea54bc0" translate="yes" xml:space="preserve">
          <source>BINARY-SHORT UNSIGNED</source>
          <target state="translated">BINARY-SHORT UNSIGNED</target>
        </trans-unit>
        <trans-unit id="27072ddddb8609d2e7b2aea71b8b6039698008f3" translate="yes" xml:space="preserve">
          <source>BINARY-SHORT [ SIGNED ]</source>
          <target state="translated">BINARY-SHORT [ SIGNED ]</target>
        </trans-unit>
        <trans-unit id="7cac1a19a032ecff3d83d34ca1abdccac4a7484b" translate="yes" xml:space="preserve">
          <source>BINARY-SHORT [ UNSIGNED ]</source>
          <target state="translated">이진-단순 [부호 없음]</target>
        </trans-unit>
        <trans-unit id="4d7c905147ff436c20b8a277191d3099e9cef7d7" translate="yes" xml:space="preserve">
          <source>BLANK Attribute Syntax</source>
          <target state="translated">공백 속성 구문</target>
        </trans-unit>
        <trans-unit id="1c83616118343aeebed8244f237c3eef48c560f0" translate="yes" xml:space="preserve">
          <source>BLANK-WHEN-ZERO Attribute Syntax</source>
          <target state="translated">공백 -WHEN-ZERO 속성 구문</target>
        </trans-unit>
        <trans-unit id="11a676bbdca1e916c6978cc077c4ce3b75f26a38" translate="yes" xml:space="preserve">
          <source>BLINK Attribute Syntax</source>
          <target state="translated">깜박임 속성 구문</target>
        </trans-unit>
        <trans-unit id="5c58545de8dfcbd18c96c78f3334701ae9756b53" translate="yes" xml:space="preserve">
          <source>BOOLEAN-OF-INTEGER Function Syntax</source>
          <target state="translated">BOOLEAN-OF-INTEGER Function Syntax</target>
        </trans-unit>
        <trans-unit id="f98551917c7b41c079bdb715caa142efe39bc871" translate="yes" xml:space="preserve">
          <source>BYTE-LENGTH Function Syntax</source>
          <target state="translated">BYTE-LENGTH 함수 구문</target>
        </trans-unit>
        <trans-unit id="f71c397089e295a1cd92071728264fe12797554c" translate="yes" xml:space="preserve">
          <source>Bad character</source>
          <target state="translated">Bad character</target>
        </trans-unit>
        <trans-unit id="732d1a64c87c763a8928b8d0c8ae7ef0e320e26f" translate="yes" xml:space="preserve">
          <source>Be defined in the procedure division in non-decreasing sequence of that numeric component.</source>
          <target state="translated">해당 숫자 구성 요소의 비 감소 순서로 프로 시저 분할에 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="7140cf29652f35a7197985b5d583b99204a8072c" translate="yes" xml:space="preserve">
          <source>Because of its inherent readability, I would MUCH rather be handed an assignment to make significant changes to a COBOL program about which I know nothing than to be asked to do the same with a C, C++, C# or Java program.</source>
          <target state="translated">고유 한 가독성으로 인해 C, C ++, C # 또는 Java 프로그램과 동일한 작업을 수행하도록 요청받지 않은 COBOL 프로그램을 대폭 변경하도록 과제를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="8a2664777f8936ef9bf539016f7515d4c9a875f1" translate="yes" xml:space="preserve">
          <source>Because of the catastrophic effect this statement has on program readability and therefore the programmer&amp;rsquo;s ability to debug problems with program logic, the use of &lt;code&gt;ALTER&lt;/code&gt; in new programs is &lt;strong&gt;STRONGLY&lt;/strong&gt; discouraged.</source>
          <target state="translated">Because of the catastrophic effect this statement has on program readability and therefore the programmer&amp;rsquo;s ability to debug problems with program logic, the use of &lt;code&gt;ALTER&lt;/code&gt; in new programs is &lt;strong&gt;STRONGLY&lt;/strong&gt; discouraged.</target>
        </trans-unit>
        <trans-unit id="d13e0ce15866e81127740db57e67454e615e094a" translate="yes" xml:space="preserve">
          <source>Because of the catastrophic effect this statement has on program readability and therefore the programmer&amp;rsquo;s ability to debug problems with program logic, the use of&lt;code&gt;ALTER&lt;/code&gt;in new programs is &lt;strong&gt;STRONGLY&lt;/strong&gt; discouraged.</source>
          <target state="translated">이 때문에 문은 프로그램의 가독성 때문에 프로그램 로직 디버그 문제에 대한 프로그래머의 능력에 미치는 치명적인 효과의 사용 &lt;code&gt;ALTER&lt;/code&gt; 새로운 프로그램입니다 &lt;strong&gt;강력히&lt;/strong&gt; 낙심.</target>
        </trans-unit>
        <trans-unit id="7c133602d991f626c8a6f0020426ea2978169f18" translate="yes" xml:space="preserve">
          <source>Because of the sort, the most-frequently changing value of the three sort keys will be that of &lt;code&gt;Sorted-Register-Number&lt;/code&gt;. This essentially defines the &amp;ldquo;detail&amp;rdquo; level of the report.</source>
          <target state="translated">Because of the sort, the most-frequently changing value of the three sort keys will be that of &lt;code&gt;Sorted-Register-Number&lt;/code&gt; . This essentially defines the &amp;ldquo;detail&amp;rdquo; level of the report.</target>
        </trans-unit>
        <trans-unit id="3897568192e57c70d682a4284b7e70387e8fd192" translate="yes" xml:space="preserve">
          <source>Because of the sort, the most-frequently changing value of the three sort keys will be that of Sorted-Register-Number. This essentially defines the &quot;detail&quot; level of the report.</source>
          <target state="translated">정렬 때문에 세 가지 정렬 키에서 가장 자주 변경되는 값은 Sorted-Register-Number의 값입니다. 이것은 본질적으로 보고서의 &quot;세부 사항&quot;수준을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="8eae3d3b27b7db953038339724b71016c328c79e" translate="yes" xml:space="preserve">
          <source>Because this is the way the GnuCOBOL RWCS works, in order to design an RWCS-generated report you&amp;rsquo;ll need to know answers to the following questions:</source>
          <target state="translated">이것이 GnuCOBOL RWCS의 작동 방식이므로 RWCS 생성 보고서를 디자인하려면 다음 질문에 대한 답을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="d34df28c2dd055914810b70b828e5babc98622f8" translate="yes" xml:space="preserve">
          <source>Before continuing, it&amp;rsquo;s worth making the point that we&amp;rsquo;re</source>
          <target state="translated">Before continuing, it&amp;rsquo;s worth making the point that we&amp;rsquo;re</target>
        </trans-unit>
        <trans-unit id="1f29deec2a6a03120562a08602ed9bb23f78df63" translate="yes" xml:space="preserve">
          <source>Before continuing, it&amp;rsquo;s worth making the point that we&amp;rsquo;re NOT talking about astronomical performance degradations here. Today&amp;rsquo;s computers are FAST, and a user sitting at the keyboard, running a GnuCOBOL program is unlikely to notice. BUT &amp;hellip; if you have a GnuCOBOL program that has to process large amounts of data, performing some significant &quot;number crunching&quot; against that data as it goes, the impact of truncation could become noticeable.</source>
          <target state="translated">계속하기 전에 여기서 천문학적 성능 저하에 대해 이야기하고 있지 않다는 것을 강조 할 가치가 있습니다. 오늘날의 컴퓨터는 빠르며 GnuCOBOL 프로그램을 실행하는 키보드에 앉아있는 사용자는 눈치 채지 못할 것입니다. 그러나&amp;hellip; 대량의 데이터를 처리해야하는 GnuCOBOL 프로그램이있는 경우 해당 데이터에 대해 상당한 &quot;숫자 크 런칭&quot;을 수행하면 잘림의 영향이 현저해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd82bd1afe40ba0df821eea5f523d006f0a112ee" translate="yes" xml:space="preserve">
          <source>Big-Endian</source>
          <target state="translated">Big-Endian</target>
        </trans-unit>
        <trans-unit id="df920c2aca56c9814330d567bccea8b54d2026db" translate="yes" xml:space="preserve">
          <source>Big-endian data allocation calls for the bytes that comprise a binary item to be allocated such that the least-significant byte is the right-most byte. For example, a four-byte binary item having a value of decimal 20 would be big-endian allocated as 00000014 (shown in hexadecimal notation).</source>
          <target state="translated">빅 엔디안 데이터 할당은 가장 중요하지 않은 바이트가 가장 오른쪽 바이트가되도록 할당 할 이진 항목을 구성하는 바이트를 요구합니다. 예를 들어, 10 진수 값이 20 인 4 바이트 2 진 항목은 00000014 (16 진 표기법으로 표시)로 할당 된 빅 엔디안입니다.</target>
        </trans-unit>
        <trans-unit id="ef0811bb71c6ad0b2245ae48055cbd19d7fb2a0a" translate="yes" xml:space="preserve">
          <source>Binary data (integer or floating-point) can be stored in either a</source>
          <target state="translated">이진 데이터 (정수 또는 부동 소수점)는</target>
        </trans-unit>
        <trans-unit id="5c401fb3e0d3ef267f587c1bea177bd29f39c4c6" translate="yes" xml:space="preserve">
          <source>Binary using B#0 or 1.</source>
          <target state="translated">Binary using B#0 or 1.</target>
        </trans-unit>
        <trans-unit id="53bda16204ff0e069875d05371a4c9bab05ffb42" translate="yes" xml:space="preserve">
          <source>Binary32</source>
          <target state="translated">Binary32</target>
        </trans-unit>
        <trans-unit id="3269560b6b91452a03dc3c6642eeab4852843818" translate="yes" xml:space="preserve">
          <source>Binary64</source>
          <target state="translated">Binary64</target>
        </trans-unit>
        <trans-unit id="e8835c712451999e0a892ac12f5715c4350423b1" translate="yes" xml:space="preserve">
          <source>Bit</source>
          <target state="translated">Bit</target>
        </trans-unit>
        <trans-unit id="dc1854a1d1a2eca13a52186e1806592639416b71" translate="yes" xml:space="preserve">
          <source>Black: COB-COLOR-BLACK</source>
          <target state="translated">블랙 : COB-COLOR-BLACK</target>
        </trans-unit>
        <trans-unit id="79a404b912bfc8636e47c79e8ce78b322899dc9c" translate="yes" xml:space="preserve">
          <source>Blank Lines</source>
          <target state="translated">빈 줄</target>
        </trans-unit>
        <trans-unit id="9f92663ab15aab9702f05ad8437e93e242427aeb" translate="yes" xml:space="preserve">
          <source>Blanked-out areas will have their foreground and background colors set to the attributes of the field containing the &lt;code&gt;BLANK&lt;/code&gt; clause.</source>
          <target state="translated">Blanked-out areas will have their foreground and background colors set to the attributes of the field containing the &lt;code&gt;BLANK&lt;/code&gt; clause.</target>
        </trans-unit>
        <trans-unit id="8b3247dd5ed6f1b06af04402591e168b57875808" translate="yes" xml:space="preserve">
          <source>Blanked-out areas will have their foreground and background colors set to the attributes of the field containing the&lt;code&gt;BLANK&lt;/code&gt;clause.</source>
          <target state="translated">공백 영역은 전경색과 배경색이 &lt;code&gt;BLANK&lt;/code&gt; 절을 포함하는 필드의 속성으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="db50375354d4d4be17c08fff5dc056bcdd3e73ba" translate="yes" xml:space="preserve">
          <source>Blinking</source>
          <target state="translated">Blinking</target>
        </trans-unit>
        <trans-unit id="d3c04e9819f277a93d8553958c2e891397695a43" translate="yes" xml:space="preserve">
          <source>Blue: COB-COLOR-BLUE</source>
          <target state="translated">블루 : COB-COLOR-BLUE</target>
        </trans-unit>
        <trans-unit id="4d776735c23da73cf905876ea92e8afe69363017" translate="yes" xml:space="preserve">
          <source>Body Area, but no line of a control footing report group is allowed past the line number specified by &lt;code&gt;FOOTING&lt;/code&gt;</source>
          <target state="translated">Body Area, but no line of a control footing report group is allowed past the line number specified by &lt;code&gt;FOOTING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="94345820b53050a7872628cb3026d65358a65609" translate="yes" xml:space="preserve">
          <source>Body Area, but no line of a control footing report group is allowed past the line number specified by&lt;code&gt;FOOTING&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;FOOTING&lt;/code&gt; 에 의해 지정된 행 번호를 지나서 제어 푸팅 보고서 그룹의 행이 허용되지 않는 본문 영역</target>
        </trans-unit>
        <trans-unit id="561d7ca0d5693d0aa781a91d0b89c690be9c5ed9" translate="yes" xml:space="preserve">
          <source>Body Area, but no line of a control heading is allowed past the line number specified by &lt;code&gt;LAST CONTROL HEADING&lt;/code&gt;</source>
          <target state="translated">Body Area, but no line of a control heading is allowed past the line number specified by &lt;code&gt;LAST CONTROL HEADING&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="23009096f02f5db9c5d67dfbf5d7e0d034a25a39" translate="yes" xml:space="preserve">
          <source>Body Area, but no line of a control heading is allowed past the line number specified by&lt;code&gt;LAST CONTROL HEADING&lt;/code&gt;</source>
          <target state="translated">본문 영역이지만 제어 표제의 행은 &lt;code&gt;LAST CONTROL HEADING&lt;/code&gt; 에 지정된 행 번호를 지나서 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a89ece30412ad43312c514ddfcd5b68224c32ff" translate="yes" xml:space="preserve">
          <source>Body Area, but no line of a detail report group is allowed past the line number specified by &lt;code&gt;LAST DETAIL&lt;/code&gt;</source>
          <target state="translated">Body Area, but no line of a detail report group is allowed past the line number specified by &lt;code&gt;LAST DETAIL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6710b289a308e35e20a48dde80be658f2115922" translate="yes" xml:space="preserve">
          <source>Body Area, but no line of a detail report group is allowed past the line number specified by&lt;code&gt;LAST DETAIL&lt;/code&gt;</source>
          <target state="translated">본문 영역이지만 세부 보고서 그룹의 행은 &lt;code&gt;LAST DETAIL&lt;/code&gt; 에 지정된 행 번호를 지나서 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="864a0764d48c2f2a55e0ef38685a75b5ca64fc8b" translate="yes" xml:space="preserve">
          <source>Boolean Literals (Hexadecimal) &lt;code&gt;BX&quot;&lt;var&gt; hex character &lt;/var&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">Boolean Literals (Hexadecimal) &lt;code&gt;BX&quot;&lt;var&gt; hex character &lt;/var&gt;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2652dcbd781b3a10581922ac9138972dd667fabf" translate="yes" xml:space="preserve">
          <source>Boolean Literals (Standard) &lt;code&gt;B&quot;&lt;var&gt; character &lt;/var&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">Boolean Literals (Standard) &lt;code&gt;B&quot;&lt;var&gt; character &lt;/var&gt;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bc1dc3e246465501e090e39547e5b3b3bf59d05" translate="yes" xml:space="preserve">
          <source>Both &amp;lt;</source>
          <target state="translated">둘 다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="61d6dc5ef4ae4ba16e643582933f104baa1739f1" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;data-item-1&lt;/var&gt; and &lt;var&gt;data-item-2&lt;/var&gt; must have the same name, and that name may not explicitly or implicitly be &lt;code&gt;FILLER&lt;/code&gt;.</source>
          <target state="translated">Both &lt;var&gt;data-item-1&lt;/var&gt; and &lt;var&gt;data-item-2&lt;/var&gt; must have the same name, and that name may not explicitly or implicitly be &lt;code&gt;FILLER&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5fc73c8e6f18c6192115fb1accd1c0c4438252f" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;data-item-1&lt;/var&gt; and &lt;var&gt;data-item-2&lt;/var&gt;&amp;hellip;</source>
          <target state="translated">Both &lt;var&gt;data-item-1&lt;/var&gt; and &lt;var&gt;data-item-2&lt;/var&gt; &amp;hellip;</target>
        </trans-unit>
        <trans-unit id="96aed45aa4c498c8d05c7b5df5cf1a2f12fe7269" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;identifier-1&lt;/var&gt; and &lt;code&gt;RETURNING &lt;var&gt;identifier-2&lt;/var&gt;&lt;/code&gt; may not be specified in the same statement.</source>
          <target state="translated">Both &lt;var&gt;identifier-1&lt;/var&gt; and &lt;code&gt;RETURNING &lt;var&gt;identifier-2&lt;/var&gt;&lt;/code&gt; may not be specified in the same statement.</target>
        </trans-unit>
        <trans-unit id="e0e70bef40da9edaed087bb71dfc62edba798612" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;identifier-1&lt;/var&gt; and &lt;var&gt;identifier-2&lt;/var&gt; must be group items.</source>
          <target state="translated">Both &lt;var&gt;identifier-1&lt;/var&gt; and &lt;var&gt;identifier-2&lt;/var&gt; must be group items.</target>
        </trans-unit>
        <trans-unit id="9d037690755c251ab65ce5d0f3f2ac78afe842ed" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;identifier-1&lt;/var&gt; and &lt;var&gt;identifier-2&lt;/var&gt; must be numeric un-edited data items; &lt;var&gt;literal-1&lt;/var&gt; and &lt;var&gt;literal-2&lt;/var&gt; must be numeric literals.</source>
          <target state="translated">Both &lt;var&gt;identifier-1&lt;/var&gt; and &lt;var&gt;identifier-2&lt;/var&gt; must be numeric un-edited data items; &lt;var&gt;literal-1&lt;/var&gt; and &lt;var&gt;literal-2&lt;/var&gt; must be numeric literals.</target>
        </trans-unit>
        <trans-unit id="5527254b9716326dad7a4050169cee5aaef1d21a" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;identifier-1&lt;/var&gt; and &lt;var&gt;identifier-2&lt;/var&gt; must be numeric un-edited data items; &lt;var&gt;literal-1&lt;/var&gt; must be a numeric literal.</source>
          <target state="translated">Both &lt;var&gt;identifier-1&lt;/var&gt; and &lt;var&gt;identifier-2&lt;/var&gt; must be numeric un-edited data items; &lt;var&gt;literal-1&lt;/var&gt; must be a numeric literal.</target>
        </trans-unit>
        <trans-unit id="53e7d59b02c1c10f4cb4c8f8c877060580eff170" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;identifier-1&lt;/var&gt; and &lt;var&gt;identifier-2&lt;/var&gt; must be numeric unedited data items and &lt;var&gt;literal-1&lt;/var&gt; must be a numeric literal.</source>
          <target state="translated">Both &lt;var&gt;identifier-1&lt;/var&gt; and &lt;var&gt;identifier-2&lt;/var&gt; must be numeric unedited data items and &lt;var&gt;literal-1&lt;/var&gt; must be a numeric literal.</target>
        </trans-unit>
        <trans-unit id="661639b34cfcce33ae8886fda5ae9f5c2080f8a9" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;identifier-1&lt;/var&gt; and &lt;var&gt;identifier-2&lt;/var&gt; must be numeric unedited data items while &lt;var&gt;literal-1&lt;/var&gt; must be a numeric literal.</source>
          <target state="translated">Both &lt;var&gt;identifier-1&lt;/var&gt; and &lt;var&gt;identifier-2&lt;/var&gt; must be numeric unedited data items while &lt;var&gt;literal-1&lt;/var&gt; must be a numeric literal.</target>
        </trans-unit>
        <trans-unit id="b696fea5bff93c873f79e83f0109310080c8e047" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;identifier-1&lt;/var&gt; and &lt;var&gt;identifier-2&lt;/var&gt; must be numeric unedited data items while &lt;var&gt;literal-1&lt;/var&gt; must be a numeric literal; &lt;var&gt;identifier-3&lt;/var&gt; may be either a numeric or numeric edited data item.</source>
          <target state="translated">Both &lt;var&gt;identifier-1&lt;/var&gt; and &lt;var&gt;identifier-2&lt;/var&gt; must be numeric unedited data items while &lt;var&gt;literal-1&lt;/var&gt; must be a numeric literal; &lt;var&gt;identifier-3&lt;/var&gt; may be either a numeric or numeric edited data item.</target>
        </trans-unit>
        <trans-unit id="b05cc00e41563a51e737e1b4e756e583b2ff421f" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;identifier-1&lt;/var&gt; and &lt;var&gt;identifier-2&lt;/var&gt; must be numeric unedited data items while both &lt;var&gt;identifier-3&lt;/var&gt; and &lt;var&gt;identifier-4&lt;/var&gt; must be numeric (edited or unedited) data items.</source>
          <target state="translated">Both &lt;var&gt;identifier-1&lt;/var&gt; and &lt;var&gt;identifier-2&lt;/var&gt; must be numeric unedited data items while both &lt;var&gt;identifier-3&lt;/var&gt; and &lt;var&gt;identifier-4&lt;/var&gt; must be numeric (edited or unedited) data items.</target>
        </trans-unit>
        <trans-unit id="5e7394f0e88e2ffcbfa98a2214864c9e37eaa337" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;identifier-1&lt;/var&gt; and &lt;var&gt;identifier-2&lt;/var&gt; must be numeric unedited data items.</source>
          <target state="translated">Both &lt;var&gt;identifier-1&lt;/var&gt; and &lt;var&gt;identifier-2&lt;/var&gt; must be numeric unedited data items.</target>
        </trans-unit>
        <trans-unit id="17b16918fa83f6f2f33d5adf230c7ca8a30a311a" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;literal-1&lt;/var&gt; and &lt;var&gt;literal-2&lt;/var&gt; must be alphanumeric literals of length 1.</source>
          <target state="translated">Both &lt;var&gt;literal-1&lt;/var&gt; and &lt;var&gt;literal-2&lt;/var&gt; must be alphanumeric literals of length 1.</target>
        </trans-unit>
        <trans-unit id="a1cb8e572bfa8b4dfab4af59bbc2475fa95369fe" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;literal-1&lt;/var&gt; and &lt;var&gt;literal-2&lt;/var&gt; must be alphanumeric literals.</source>
          <target state="translated">Both &lt;var&gt;literal-1&lt;/var&gt; and &lt;var&gt;literal-2&lt;/var&gt; must be alphanumeric literals.</target>
        </trans-unit>
        <trans-unit id="4a8ed391ca1ee02aab25fa6f714c60f630b97efd" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;literal-1&lt;/var&gt; and &lt;var&gt;literal-2&lt;/var&gt; must be numeric literals.</source>
          <target state="translated">Both &lt;var&gt;literal-1&lt;/var&gt; and &lt;var&gt;literal-2&lt;/var&gt; must be numeric literals.</target>
        </trans-unit>
        <trans-unit id="00132b3bf070f438722a9e409c38a89dfa386b83" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;literal-1&lt;/var&gt; and/or &lt;var&gt;literal-2&lt;/var&gt; must be alphanumeric literals.</source>
          <target state="translated">Both &lt;var&gt;literal-1&lt;/var&gt; and/or &lt;var&gt;literal-2&lt;/var&gt; must be alphanumeric literals.</target>
        </trans-unit>
        <trans-unit id="d8d79fa624956cf0d3105a3fa4b544211ecaf6b1" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;procedure-name-1&lt;/var&gt; and &lt;var&gt;procedure-name-2&lt;/var&gt; must be procedure division sections or paragraphs defined in the same program as the &lt;code&gt;PERFORM&lt;/code&gt; statement. If &lt;var&gt;procedure-name-2&lt;/var&gt; is specified, it must follow &lt;var&gt;procedure-name-1&lt;/var&gt; in the program&amp;rsquo;s source code.</source>
          <target state="translated">Both &lt;var&gt;procedure-name-1&lt;/var&gt; and &lt;var&gt;procedure-name-2&lt;/var&gt; must be procedure division sections or paragraphs defined in the same program as the &lt;code&gt;PERFORM&lt;/code&gt; statement. If &lt;var&gt;procedure-name-2&lt;/var&gt; is specified, it must follow &lt;var&gt;procedure-name-1&lt;/var&gt; in the program&amp;rsquo;s source code.</target>
        </trans-unit>
        <trans-unit id="3e27aaa3aa3cdb1d7e1ed322a7d2b4e74ecb9752" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;pseudo-text-2&lt;/var&gt; and &lt;var&gt;partial-word-2&lt;/var&gt; may be null.</source>
          <target state="translated">Both &lt;var&gt;pseudo-text-2&lt;/var&gt; and &lt;var&gt;partial-word-2&lt;/var&gt; may be null.</target>
        </trans-unit>
        <trans-unit id="fba7d23be2c6f83c27c037875c5cb67f69d0e321" translate="yes" xml:space="preserve">
          <source>Both &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;length&lt;/var&gt; may be specified as integer numeric literals, integer numeric data items or arithmetic expressions with an integer value.</source>
          <target state="translated">Both &lt;var&gt;start&lt;/var&gt; and &lt;var&gt;length&lt;/var&gt; may be specified as integer numeric literals, integer numeric data items or arithmetic expressions with an integer value.</target>
        </trans-unit>
        <trans-unit id="62f5b6e735a653497e081fcece40998738d3757f" translate="yes" xml:space="preserve">
          <source>Both arguments may be alphanumeric literals or identifiers.</source>
          <target state="translated">두 인수 모두 영숫자 리터럴 또는 식별자 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dd361aa66175415490584d2dbc5c638993ce9fe" translate="yes" xml:space="preserve">
          <source>Both arguments must be numeric data items or numeric literals.</source>
          <target state="translated">두 인수 모두 숫자 데이터 항목 또는 숫자 리터럴이어야합니다.</target>
        </trans-unit>
        <trans-unit id="1cbec7c2bbe5a9b7ed97689a43559007445ebd07" translate="yes" xml:space="preserve">
          <source>Both data item definitions</source>
          <target state="translated">두 데이터 항목 정의</target>
        </trans-unit>
        <trans-unit id="73ffee561a0c87ad6ed5de89dbabcd25997adf00" translate="yes" xml:space="preserve">
          <source>Both file path arguments may be alphanumeric literals or identifiers.</source>
          <target state="translated">두 파일 경로 인수는 영숫자 리터럴 또는 식별자 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86bdf7d72ba8a02ed06721e3541f52baf0f1b609" translate="yes" xml:space="preserve">
          <source>Both fixed- and variable-length record formats are supported.</source>
          <target state="translated">고정 길이 및 가변 길이 레코드 형식이 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8d753f35c20a41f09891e686786ce1dede9c1f4b" translate="yes" xml:space="preserve">
          <source>Both languages store strings as a fixed-length continuous sequence of characters.</source>
          <target state="translated">두 언어 모두 문자열을 고정 길이 연속 문자 시퀀스로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="d9212305982a9b34c5e63c55b74cd4446fc9bda7" translate="yes" xml:space="preserve">
          <source>Both of the above programs could have been written on a single line, if desired, and both languages allow a programmer to use (or not use) indentation as they see fit to improve program readability. Sounds like a tie so far.</source>
          <target state="translated">원하는 경우 위의 두 프로그램을 모두 한 줄로 작성했을 수 있으며, 두 언어 모두 프로그래머가 프로그램 가독성을 향상시키는 데 적합한 들여 쓰기를 사용할 수 있습니다. 지금까지 넥타이처럼 들립니다.</target>
        </trans-unit>
        <trans-unit id="53d76fca241c7762a48afcac98b1fff53bc39fec" translate="yes" xml:space="preserve">
          <source>Both subroutines and user-defined functions may return a value. The value they return must be an integer in the range -2147483648 to +2147483647. This value will be available in the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) and also as the value of the data item specified on the &lt;code&gt;RETURNING&lt;/code&gt; (see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;) clause of a subroutine&amp;rsquo;s &lt;code&gt;CALL&lt;/code&gt;.</source>
          <target state="translated">Both subroutines and user-defined functions may return a value. The value they return must be an integer in the range -2147483648 to +2147483647. This value will be available in the &lt;code&gt;RETURN-CODE&lt;/code&gt; special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) and also as the value of the data item specified on the &lt;code&gt;RETURNING&lt;/code&gt; (see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;) clause of a subroutine&amp;rsquo;s &lt;code&gt;CALL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de7033bf1a9de7c2244f45f9f7594167e640b181" translate="yes" xml:space="preserve">
          <source>Both subroutines and user-defined functions may return a value. The value they return must be an integer in the range -2147483648 to +2147483647. This value will be available in the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register (see &lt;a href=&quot;#Special-Registers&quot;&gt;Special Registers&lt;/a&gt;) and also as the value of the data item specified on the&lt;code&gt;RETURNING&lt;/code&gt;(see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;) clause of a subroutine&amp;rsquo;s CALL.</source>
          <target state="translated">서브 루틴 및 사용자 정의 함수 모두 값을 반환 할 수 있습니다. 그들이 반환하는 값은 -2147483648에서 +2147483647 범위의 정수 여야합니다. 이 값은에서 사용할 수 &lt;code&gt;RETURN-CODE&lt;/code&gt; 의 특수 레지스터 (참조 &lt;a href=&quot;#Special-Registers&quot;&gt;특수 레지스터&lt;/a&gt; ) 또한에 지정된 데이터 항목의 값으로 &lt;code&gt;RETURNING&lt;/code&gt; (참조 &lt;a href=&quot;#CALL&quot;&gt;CALL을&lt;/a&gt; 서브 루틴의 CALL의) 절.</target>
        </trans-unit>
        <trans-unit id="ce2e02c4f2f64e08494079e611275f7b1133ff07" translate="yes" xml:space="preserve">
          <source>Boundary violation</source>
          <target state="translated">경계 위반</target>
        </trans-unit>
        <trans-unit id="86d9d5d62f61d46204402182103e9fb5796ca9ab" translate="yes" xml:space="preserve">
          <source>Businesses are addressing the COBOL challenge in different ways:</source>
          <target state="translated">기업은 다양한 방식으로 COBOL 과제를 해결하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d71f7e1b353d405d0ac11988a391e51c106c8d8" translate="yes" xml:space="preserve">
          <source>But this is not:</source>
          <target state="translated">그러나 이것은 아닙니다 :</target>
        </trans-unit>
        <trans-unit id="d6034baf101109a548d80a79196fa3960e95d84d" translate="yes" xml:space="preserve">
          <source>But, if the&lt;code&gt;KEY&lt;/code&gt;clause</source>
          <target state="translated">그러나 &lt;code&gt;KEY&lt;/code&gt; 절이</target>
        </trans-unit>
        <trans-unit id="3827f58de560d114c532e14e2971bb55664b1f8a" translate="yes" xml:space="preserve">
          <source>By accepting from  &lt;code&gt;ARGUMENT-NUMBER&lt;/code&gt;, you will be asking the GnuCOBOL run-time system to parse the arguments from the command line and return the number of arguments found. Parsing will be conducted according to the following rules:</source>
          <target state="translated">By accepting from &lt;code&gt;ARGUMENT-NUMBER&lt;/code&gt; , you will be asking the GnuCOBOL run-time system to parse the arguments from the command line and return the number of arguments found. Parsing will be conducted according to the following rules:</target>
        </trans-unit>
        <trans-unit id="7b9d42a0e05506cfc4d0210e727009413dc9ee82" translate="yes" xml:space="preserve">
          <source>By accepting from  &lt;code&gt;ARGUMENT-VALUE&lt;/code&gt;, you will be asking the GnuCOBOL run-time system to parse the arguments from the command line and return the &amp;ldquo;current&amp;rdquo; argument. You specify which argument number is &amp;ldquo;current&amp;rdquo; via the &lt;code&gt;ARGUMENT-NUMBER&lt;/code&gt; option on the &lt;code&gt;DISPLAY&lt;/code&gt; statement (see &lt;a href=&quot;#DISPLAY-UPON-COMMAND_002dLINE&quot;&gt;DISPLAY UPON COMMAND-LINE&lt;/a&gt;). Parsing of arguments will be conducted according to the rules set forth above.</source>
          <target state="translated">By accepting from &lt;code&gt;ARGUMENT-VALUE&lt;/code&gt; , you will be asking the GnuCOBOL run-time system to parse the arguments from the command line and return the &amp;ldquo;current&amp;rdquo; argument. You specify which argument number is &amp;ldquo;current&amp;rdquo; via the &lt;code&gt;ARGUMENT-NUMBER&lt;/code&gt; option on the &lt;code&gt;DISPLAY&lt;/code&gt; statement (see &lt;a href=&quot;#DISPLAY-UPON-COMMAND_002dLINE&quot;&gt;DISPLAY UPON COMMAND-LINE&lt;/a&gt;). Parsing of arguments will be conducted according to the rules set forth above.</target>
        </trans-unit>
        <trans-unit id="764d4abcb617d05c9427e382d8de2791cac7127c" translate="yes" xml:space="preserve">
          <source>By accepting from  &lt;code&gt;ENVIRONMENT-VALUE&lt;/code&gt;, you will be asking the GnuCOBOL run-time system to retrieve the value of the environment variable whose name is currently in the  &lt;code&gt;ENVIRONMENT-NAME&lt;/code&gt; register. A value may be placed into the &lt;code&gt;ENVIRONMENT-NAME&lt;/code&gt; register using the &lt;code&gt;ENVIRONMENT-NAME&lt;/code&gt; option of the &lt;code&gt;DISPLAY&lt;/code&gt; statement (see &lt;a href=&quot;#DISPLAY-UPON-ENVIRONMENT_002dNAME&quot;&gt;DISPLAY UPON ENVIRONMENT-NAME&lt;/a&gt;).</source>
          <target state="translated">By accepting from &lt;code&gt;ENVIRONMENT-VALUE&lt;/code&gt; , you will be asking the GnuCOBOL run-time system to retrieve the value of the environment variable whose name is currently in the &lt;code&gt;ENVIRONMENT-NAME&lt;/code&gt; register. A value may be placed into the &lt;code&gt;ENVIRONMENT-NAME&lt;/code&gt; register using the &lt;code&gt;ENVIRONMENT-NAME&lt;/code&gt; option of the &lt;code&gt;DISPLAY&lt;/code&gt; statement (see &lt;a href=&quot;#DISPLAY-UPON-ENVIRONMENT_002dNAME&quot;&gt;DISPLAY UPON ENVIRONMENT-NAME&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="bd77697a4182cd3b13a40705bd5e627399d95bd3" translate="yes" xml:space="preserve">
          <source>By accepting from&lt;code&gt;ARGUMENT-NUMBER&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ARGUMENT-NUMBER&lt;/code&gt; 에서 수락함으로써</target>
        </trans-unit>
        <trans-unit id="32783d23a2b57069dfd27bf6ebf2f729ab1d9e9d" translate="yes" xml:space="preserve">
          <source>By accepting from&lt;code&gt;ARGUMENT-VALUE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ARGUMENT-VALUE&lt;/code&gt; 에서 수락함으로써</target>
        </trans-unit>
        <trans-unit id="0823bd188f4cd132b1f5cf0d0527264a44cb4dc1" translate="yes" xml:space="preserve">
          <source>By accepting from&lt;code&gt;ENVIRONMENT-VALUE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ENVIRONMENT-VALUE&lt;/code&gt; 에서 수락함으로써</target>
        </trans-unit>
        <trans-unit id="6ab3ff67e4479fcd1100f7d6a19475c06970f317" translate="yes" xml:space="preserve">
          <source>By convention throughout this document, COBOL reserved words will be shown entirely in &lt;code&gt;UPPER-CASE&lt;/code&gt; while those words that were created by a programmer will be represented by tokens in mixed or lower case.</source>
          <target state="translated">By convention throughout this document, COBOL reserved words will be shown entirely in &lt;code&gt;UPPER-CASE&lt;/code&gt; while those words that were created by a programmer will be represented by tokens in mixed or lower case.</target>
        </trans-unit>
        <trans-unit id="850d2ea9cacd64b27c9ce36e8d2804cf274ec6a0" translate="yes" xml:space="preserve">
          <source>By convention throughout this document, COBOL reserved words will be shown entirely in UPPER-CASE while those words that were created by a programmer will be represented by tokens in mixed or lower case.</source>
          <target state="translated">이 문서 전체에서 관례 적으로 COBOL 예약어는 대문자로 표시되며 프로그래머가 만든 단어는 대소 문자를 혼합하여 소문자로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e3f96ce9962fb36a0c92a812a3b5398a552a2522" translate="yes" xml:space="preserve">
          <source>By default, all arguments are assumed to be &lt;code&gt;BY REFERENCE&lt;/code&gt; unless explicitly stated otherwise on the procedure division header.</source>
          <target state="translated">By default, all arguments are assumed to be &lt;code&gt;BY REFERENCE&lt;/code&gt; unless explicitly stated otherwise on the procedure division header.</target>
        </trans-unit>
        <trans-unit id="fbc942875d4f00039bda2626332f5ea98c184c4d" translate="yes" xml:space="preserve">
          <source>By default, all arguments are assumed to be&lt;code&gt;BY REFERENCE&lt;/code&gt;unless explicitly stated otherwise on the procedure division header.</source>
          <target state="translated">기본적 으로 프로 시저 분할 헤더에 명시 적으로 명시되지 않은 한 모든 인수는 &lt;code&gt;BY REFERENCE&lt;/code&gt; 인 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="d6654a8d0cb47663f16ffe6979976c5e330b6df0" translate="yes" xml:space="preserve">
          <source>By default, procedure and procedure-and-statement tracing is off as programs begin execution. The &lt;code&gt;READY TRACE&lt;/code&gt; statement (see &lt;a href=&quot;#READY-TRACE&quot;&gt;READY TRACE&lt;/a&gt;) can be used to turn tracing on.</source>
          <target state="translated">By default, procedure and procedure-and-statement tracing is off as programs begin execution. The &lt;code&gt;READY TRACE&lt;/code&gt; statement (see &lt;a href=&quot;#READY-TRACE&quot;&gt;READY TRACE&lt;/a&gt;) can be used to turn tracing on.</target>
        </trans-unit>
        <trans-unit id="7ce3af4b0bcbc6101e3c26191d093e765d0d0837" translate="yes" xml:space="preserve">
          <source>By default, procedure and procedure-and-statement tracing is off as programs begin execution. The&lt;code&gt;READY TRACE&lt;/code&gt;statement (see &lt;a href=&quot;#READY-TRACE&quot;&gt;READY TRACE&lt;/a&gt;) can be used to turn tracing on.</source>
          <target state="translated">프로그램이 실행을 시작하면 기본적으로 프로 시저 및 프로 시저 및 명령문 추적이 해제됩니다. &lt;code&gt;READY TRACE&lt;/code&gt; 문 (참조 &lt;a href=&quot;#READY-TRACE&quot;&gt;READY TRACE를&lt;/a&gt; ) 추적을 설정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89e2d8e02187ae096f81ccddd37120c7d11f6684" translate="yes" xml:space="preserve">
          <source>By default, the GnuCOBOL compiler will truncate binary data items to the precision indicated by their &lt;code&gt;PICTURE&lt;/code&gt; (see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause, if they have one. This applies to COMP, BINARY and COMP-4 items Only.  The fact is, however, that binary truncation has a significant effect on the performance of GnuCOBOL programs. When binary truncation is in effect, arithmetic operations performed against all types of numeric data items (even &lt;code&gt;USAGE DISPLAY&lt;/code&gt;) are slowed down.</source>
          <target state="translated">By default, the GnuCOBOL compiler will truncate binary data items to the precision indicated by their &lt;code&gt;PICTURE&lt;/code&gt; (see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause, if they have one. This applies to COMP, BINARY and COMP-4 items Only. The fact is, however, that binary truncation has a significant effect on the performance of GnuCOBOL programs. When binary truncation is in effect, arithmetic operations performed against all types of numeric data items (even &lt;code&gt;USAGE DISPLAY&lt;/code&gt; ) are slowed down.</target>
        </trans-unit>
        <trans-unit id="df2f48f030c1739505d2c566e27aeb7e52d9aed1" translate="yes" xml:space="preserve">
          <source>By default, the GnuCOBOL compiler will truncate binary data items to the precision indicated by their&lt;code&gt;PICTURE&lt;/code&gt;(see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause, if they have one. This applies to COMP, BINARY and COMP-4 items Only.  The fact is, however, that binary truncation has a significant effect on the performance of GnuCOBOL programs. When binary truncation is in effect, arithmetic operations performed against all types of numeric data items (even&lt;code&gt;USAGE DISPLAY&lt;/code&gt; are slowed down.</source>
          <target state="translated">기본적으로 GnuCOBOL 컴파일러는 바이너리 데이터 항목이 &lt;code&gt;PICTURE&lt;/code&gt; ( &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt; 참조 ) 절에 표시된 정밀도 (자세한 경우)로 잘립니다 . 이것은 COMP, BINARY 및 COMP-4 항목에만 적용됩니다. 그러나 이진 잘림은 GnuCOBOL 프로그램의 성능에 상당한 영향을 미칩니다. 이진 잘림이 적용되면 모든 유형의 숫자 ​​데이터 항목에 대해 산술 연산이 수행됩니다 ( &lt;code&gt;USAGE DISPLAY&lt;/code&gt; 도 느려집니다).</target>
        </trans-unit>
        <trans-unit id="1425dbde0837cbea5550b48390a0792d0dca675a" translate="yes" xml:space="preserve">
          <source>By default, the program&amp;rsquo;s &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; will, however, be based entirely on the bit-pattern values of the various characters.</source>
          <target state="translated">그러나 기본적으로 프로그램의 &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; 는 전적으로 다양한 문자의 비트 패턴 값을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="bdf1723b13aa92389c3cfc21f4d3b09a741ea127" translate="yes" xml:space="preserve">
          <source>By default, the program&amp;rsquo;s&lt;code&gt;COLLATING SEQUENCE&lt;/code&gt;will, however, be based entirely on the bit-pattern values of the various characters.</source>
          <target state="translated">그러나 기본적으로 프로그램의 &lt;code&gt;COLLATING SEQUENCE&lt;/code&gt; 는 전적으로 다양한 문자의 비트 패턴 값을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="ae85549fea19dfa02375c3b11313c4613a392d2d" translate="yes" xml:space="preserve">
          <source>By displaying a numeric integer value &lt;code&gt;UPON&lt;/code&gt;&lt;code&gt;ARGUMENT-NUMBER&lt;/code&gt;, you will specify which argument (by its relative number) will be retrieved by a subsequent &lt;code&gt;ACCEPT FROM ARGUMENT-VALUE&lt;/code&gt; statement.</source>
          <target state="translated">숫자 정수 값 &lt;code&gt;UPON&lt;/code&gt; &lt;code&gt;ARGUMENT-NUMBER&lt;/code&gt; 를 표시하여 후속 &lt;code&gt;ACCEPT FROM ARGUMENT-VALUE&lt;/code&gt; 문 에서 검색 할 인수 (상대 번호로)를 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="60f9a6197452d933f11649c97e71150a45c0731f" translate="yes" xml:space="preserve">
          <source>By displaying a numeric integer value UPON&lt;code&gt;ARGUMENT-NUMBER&lt;/code&gt;</source>
          <target state="translated">숫자 정수 값 UPON &lt;code&gt;ARGUMENT-NUMBER&lt;/code&gt; 표시</target>
        </trans-unit>
        <trans-unit id="bd9a7a0b8d662fbdea6b17bbd14fcf8889798841" translate="yes" xml:space="preserve">
          <source>By moving the user-interface onto the desktop; such efforts involve running modern-language front-end clients on user desktops (or laptops or smart phones, etc.) with COBOL programs providing server functionality on mainframe or midframe platforms, providing all the database and file &quot;heavy lifting&quot; on the back-end. Solutions like this provide users with the user-interfaces they want/need while still leveraging Cobol&amp;rsquo;s strengths on (possibly) downsized legacy mainframe or midframe systems.</source>
          <target state="translated">사용자 인터페이스를 데스크탑으로 이동 이러한 노력에는 메인 프레임 또는 미드 프레임 플랫폼에서 서버 기능을 제공하는 COBOL 프로그램을 사용하여 사용자 데스크톱 (또는 랩톱 또는 스마트 폰 등)에서 최신 언어 프런트 엔드 클라이언트를 실행하고 모든 데이터베이스 및 파일을 &quot;무거운 리프팅&quot; 종료. 이와 같은 솔루션은 사용자가 원하는 / 필요한 사용자 인터페이스를 제공하면서도 축소 된 레거시 메인 프레임 또는 미드 프레임 시스템에서 Cobol의 강점을 활용합니다.</target>
        </trans-unit>
        <trans-unit id="3492279344ec6653b90e27d3459eec3cc103df71" translate="yes" xml:space="preserve">
          <source>By moving the user-interface onto the desktop; such efforts involve running modern-language front-end clients on user desktops (or laptops or smart phones, etc.) with COBOL programs providing server functionality on mainframe or midframe platforms, providing all the database and file &amp;ldquo;heavy lifting&amp;rdquo; on the back-end. Solutions like this provide users with the user-interfaces they want/need while still leveraging COBOL&amp;rsquo;s strengths on (possibly) downsized legacy mainframe or midframe systems.</source>
          <target state="translated">사용자 인터페이스를 데스크탑으로 이동합니다. 이러한 노력에는 메인 프레임 또는 미드 프레임 플랫폼에서 서버 기능을 제공하는 COBOL 프로그램을 사용하여 사용자 데스크톱 (또는 랩톱 또는 스마트 폰 등)에서 최신 언어 프런트 엔드 클라이언트를 실행하여 모든 데이터베이스 및 파일을 &quot;무거운 작업&quot;으로 제공하는 것이 포함됩니다. 종료. 이와 같은 솔루션은 사용자에게 원하는 / 필요한 사용자 인터페이스를 제공하는 동시에 축소 된 레거시 메인 프레임 또는 미드 프레임 시스템에서 COBOL의 강점을 계속 활용합니다.</target>
        </trans-unit>
        <trans-unit id="d797eb055af75b05fab2b686613a1d26d36425e5" translate="yes" xml:space="preserve">
          <source>By removing the &lt;code&gt;WITH TEST&lt;/code&gt; clause, the statement is now assuming &lt;code&gt;WITH TEST BEFORE&lt;/code&gt;. Since testing now happens</source>
          <target state="translated">&lt;code&gt;WITH TEST&lt;/code&gt; 절 을 제거하면 명령문은 이제 &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; 라고 가정 합니다. 이제 테스트가 발생하기 때문에</target>
        </trans-unit>
        <trans-unit id="9a4ec6e85cf4b3b0c4d0278afe7e57d35f30ed23" translate="yes" xml:space="preserve">
          <source>By removing the&lt;code&gt;WITH TEST&lt;/code&gt;clause, the statement is now assuming&lt;code&gt;WITH TEST BEFORE&lt;/code&gt; Since testing now happens</source>
          <target state="translated">&lt;code&gt;WITH TEST&lt;/code&gt; 절 을 제거하면 명령문은 이제 &lt;code&gt;WITH TEST BEFORE&lt;/code&gt; 를 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="38b42a07bf6c6911ca5675f23376cbefcd1c2058" translate="yes" xml:space="preserve">
          <source>By running on almost as many different computing platforms as Java can. You can&amp;rsquo;t run COBOL programs in your smart phone, but desktops, workstations, midframes/servers, mainframes and supercomputers are all fair game.</source>
          <target state="translated">Java가 가능한 많은 컴퓨팅 플랫폼에서 실행 스마트 폰에서 COBOL 프로그램을 실행할 수는 없지만 데스크탑, 워크 스테이션, 미드 프레임 / 서버, 메인 프레임 및 슈퍼 컴퓨터는 모두 공정한 게임입니다.</target>
        </trans-unit>
        <trans-unit id="e99b3ecfc2c73284a8dbbf42ccb65c863f33ef43" translate="yes" xml:space="preserve">
          <source>By setting the specified &amp;lt;</source>
          <target state="translated">지정된 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="1b719d7bd5bf5722c16ac646e34705599ad56563" translate="yes" xml:space="preserve">
          <source>By setting the specified &lt;var&gt;condition-name-1&lt;/var&gt;(s) to a &lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt; value, you will actually be assigning a value to the parent data item(s) to which the condition name data item(s) is(are) subordinate to.</source>
          <target state="translated">지정된 &lt;var&gt;condition-name-1&lt;/var&gt; (s)을 &lt;code&gt;TRUE&lt;/code&gt; 또는 &lt;code&gt;FALSE&lt;/code&gt; 값으로 설정하면 실제로 조건 이름 데이터 항목이 종속 된 상위 데이터 항목에 값을 할당하게됩니다. .</target>
        </trans-unit>
        <trans-unit id="3edb9729db17e6eb4e2ac61bd38fe867fb37e3d2" translate="yes" xml:space="preserve">
          <source>By specifying the &lt;code&gt;EXTERNAL&lt;/code&gt; clause on either an &lt;code&gt;FD&lt;/code&gt; or an &lt;code&gt;SD&lt;/code&gt;, the file description is capable of being shared between all programs executed from the same execution thread, provided an &lt;code&gt;EXTERNAL&lt;/code&gt; clause is coded with the file&amp;rsquo;s description in</source>
          <target state="translated">시방함으로써 &lt;code&gt;EXTERNAL&lt;/code&gt; 양자 택일에 절 &lt;code&gt;FD&lt;/code&gt; 나 &lt;code&gt;SD&lt;/code&gt; 파일 정보가 제공되고, 동일한 실행 스레드에서 실행되는 모든 프로그램들 사이에서 공유 될 수있는 &lt;code&gt;EXTERNAL&lt;/code&gt; 절에서 파일의 설명과 코딩</target>
        </trans-unit>
        <trans-unit id="e07f56e6253b8fcd96907af082363e71c51ce5b1" translate="yes" xml:space="preserve">
          <source>By specifying the &lt;code&gt;EXTERNAL&lt;/code&gt; clause on the description of a data item, the data item is capable of being shared between all programs executed from the same execution thread, provided the data item is coded (with an &lt;code&gt;EXTERNAL&lt;/code&gt; clause) in each program requiring it.</source>
          <target state="translated">데이터 항목 설명에 &lt;code&gt;EXTERNAL&lt;/code&gt; 절을 지정하면 데이터 항목이 필요한 각 프로그램에서 코드화 ( &lt;code&gt;EXTERNAL&lt;/code&gt; 절 사용) 된 경우 데이터 항목이 동일한 실행 스레드에서 실행되는 모든 프로그램간에 공유 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81f0f06242cb565847a975f3777ee7138f378ca4" translate="yes" xml:space="preserve">
          <source>By specifying the &lt;code&gt;GLOBAL&lt;/code&gt; clause on the description of a data item, the data item is capable of being shared between a program and any nested subprograms within it, provided the data item is coded (with a &lt;code&gt;GLOBAL&lt;/code&gt; clause) in each program requiring it.</source>
          <target state="translated">데이터 항목 설명에 &lt;code&gt;GLOBAL&lt;/code&gt; 절을 지정하면 데이터 항목이 필요한 각 프로그램에서 &lt;code&gt;GLOBAL&lt;/code&gt; 절을 사용하여 코딩 된 경우 데이터 항목이 프로그램과 그 안의 중첩 된 하위 프로그램간에 공유 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95cf418423e1bfef3102fa0f5175b33155f77d60" translate="yes" xml:space="preserve">
          <source>By specifying the &lt;code&gt;GLOBAL&lt;/code&gt; clause on the description of a file or a report, that description is capable of being shared between a program and any nested subprograms within it, provided the &lt;code&gt;FD&lt;/code&gt;, &lt;code&gt;SD&lt;/code&gt; or &lt;code&gt;RD&lt;/code&gt; is coded (with a &lt;code&gt;GLOBAL&lt;/code&gt; clause) in each nested subprogram requiring it. This sharing allows the file to be opened, read and/or written and closed or the report to be initiated or terminated in those programs. Separately compiled programs may not share a &lt;code&gt;GLOBAL&lt;/code&gt; file description, but they may share an &lt;code&gt;EXTERNAL&lt;/code&gt; (see &lt;a href=&quot;#EXTERNAL&quot;&gt;EXTERNAL&lt;/a&gt;) file description. This sharing applies to the record descriptions subordinate to the file description and the report groups subordinate to the &lt;code&gt;RD&lt;/code&gt; also.</source>
          <target state="translated">파일 또는 보고서의 설명에 &lt;code&gt;GLOBAL&lt;/code&gt; 절을 지정하면 &lt;code&gt;FD&lt;/code&gt; , &lt;code&gt;SD&lt;/code&gt; 또는 &lt;code&gt;RD&lt;/code&gt; 가 각 중첩 된 파일에 코딩 된 경우 ( &lt;code&gt;GLOBAL&lt;/code&gt; 절을 사용하여 ) 프로그램과 그 안의 중첩 된 하위 프로그램간에 해당 설명을 공유 할 수 있습니다. 그것을 요구하는 서브 프로그램. 이러한 공유를 통해 파일을 열고, 읽고, 쓰고, 닫거나, 해당 프로그램에서 보고서를 시작하거나 종료 할 수 있습니다. 별도로 컴파일 된 프로그램은 &lt;code&gt;GLOBAL&lt;/code&gt; 파일 설명을 공유하지 않을 수 있지만 &lt;code&gt;EXTERNAL&lt;/code&gt; 을 공유 할 수 있습니다 ( &lt;a href=&quot;#EXTERNAL&quot;&gt;EXTERNAL&lt;/a&gt; 참조).) 파일 설명. 이 공유는 파일 설명에 종속 된 레코드 설명과 &lt;code&gt;RD&lt;/code&gt; 에 종속 된 보고서 그룹 에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9265844e717179a7b2a438d467adc0a85b8d0a1" translate="yes" xml:space="preserve">
          <source>By specifying the&lt;code&gt;EXTERNAL&lt;/code&gt;clause on either an FD or an SD, the file description is capable of being shared between all programs executed from the same execution thread, provided an&lt;code&gt;EXTERNAL&lt;/code&gt;clause is coded with the file&amp;rsquo;s description in</source>
          <target state="translated">시방으로 &lt;code&gt;EXTERNAL&lt;/code&gt; FD 나 SD 하나에 절 파일 정보가 제공되고, 동일한 실행 스레드에서 실행되는 모든 프로그램들 사이에서 공유 될 수있는 &lt;code&gt;EXTERNAL&lt;/code&gt; 절에서 파일의 설명과 코딩</target>
        </trans-unit>
        <trans-unit id="8fb5f1e57497d646258a731c81a2122674f9f57e" translate="yes" xml:space="preserve">
          <source>By specifying the&lt;code&gt;EXTERNAL&lt;/code&gt;clause on the description of a data item, the data item is capable of being shared between all programs executed from the same execution thread, provided the data item is coded (with an&lt;code&gt;EXTERNAL&lt;/code&gt;clause) in each program requiring it.</source>
          <target state="translated">데이터 항목 설명에 &lt;code&gt;EXTERNAL&lt;/code&gt; 절을 지정하면 데이터 항목이 필요한 각 프로그램에서 데이터 항목이 코딩 된 경우 ( &lt;code&gt;EXTERNAL&lt;/code&gt; 절 과 함께) 데이터 항목은 동일한 실행 스레드에서 실행 된 모든 프로그램간에 공유 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78a771ee6fb1e15eb97cd1a3294a78c644eba223" translate="yes" xml:space="preserve">
          <source>By specifying the&lt;code&gt;GLOBAL&lt;/code&gt;clause on the description of a data item, the data item is capable of being shared between a program and any nested subprograms within it, provided the data item is coded (with a&lt;code&gt;GLOBAL&lt;/code&gt;clause) in each program requiring it.</source>
          <target state="translated">데이터 항목 설명에 &lt;code&gt;GLOBAL&lt;/code&gt; 절을 지정하면 데이터 항목이 필요한 각 프로그램에서 데이터 항목이 코딩 된 경우 ( &lt;code&gt;GLOBAL&lt;/code&gt; 절 과 함께) 데이터 항목은 프로그램과 그 안에 중첩 된 서브 프로그램간에 공유 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e2416e940bd79bf4912ad6547f50c2bfe220b82" translate="yes" xml:space="preserve">
          <source>By specifying the&lt;code&gt;GLOBAL&lt;/code&gt;clause on the description of a file or a report, that description is capable of being shared between a program and any nested subprograms within it, provided the&lt;code&gt;FD&lt;/code&gt;&lt;code&gt;SD&lt;/code&gt;or&lt;code&gt;RD&lt;/code&gt;is coded (with a&lt;code&gt;GLOBAL&lt;/code&gt;clause) in each nested subprogram requiring it. This sharing allows the file to be opened, read and/or written and closed or the report to be initiated or terminated in those programs. Separately compiled programs may not share a&lt;code&gt;GLOBAL&lt;/code&gt;file description, but they may share an&lt;code&gt;EXTERNAL&lt;/code&gt;(see &lt;a href=&quot;#EXTERNAL&quot;&gt;EXTERNAL&lt;/a&gt;) file description. This sharing applies to the record descriptions subordinate to the file description and the report groups subordinate to the&lt;code&gt;RD&lt;/code&gt;also.</source>
          <target state="translated">파일 또는 보고서 설명에 &lt;code&gt;GLOBAL&lt;/code&gt; 절을 지정하면 &lt;code&gt;FD&lt;/code&gt; &lt;code&gt;SD&lt;/code&gt; 또는 &lt;code&gt;RD&lt;/code&gt; 가 중첩 된 각 서브 프로그램에서 ( &lt;code&gt;GLOBAL&lt;/code&gt; 절 과 함께) 코딩 되는 경우 해당 설명은 프로그램과 그 안에 중첩 된 서브 프로그램간에 공유 될 수 있습니다. 그것을 요구합니다. 이러한 공유를 통해 파일을 열고, 읽거나 쓰고 / 닫거나 보고서를 해당 프로그램에서 시작하거나 종료 할 수 있습니다. 별도로 컴파일 된 프로그램은 &lt;code&gt;GLOBAL&lt;/code&gt; 파일 설명을 공유 할 수 없지만 &lt;code&gt;EXTERNAL&lt;/code&gt; 을 공유 할 수 있습니다 ( &lt;a href=&quot;#EXTERNAL&quot;&gt;EXTERNAL&lt;/a&gt; 참조).) 파일 설명. 이 공유는 파일 설명에 종속 된 레코드 설명 및 &lt;code&gt;RD&lt;/code&gt; 에 종속 된 보고서 그룹 에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="efcc05f648154d08ba04ed3ff4bfc640d7cca8bc" translate="yes" xml:space="preserve">
          <source>By undertaking so-called &quot;modernization projects&quot;, where existing applications are either rewritten in &quot;modern&quot; languages or replaced outright with purchased packages. Most of these businesses are using such activities as an excuse to abandon &quot;expensive&quot; mainframes in favour of (presumably) less-expensive &quot;open systems&quot; (mid frame/server) solutions.</source>
          <target state="translated">기존 애플리케이션을 &quot;현대&quot;언어로 다시 작성하거나 구매 한 패키지로 완전히 대체하는 소위 &quot;현대화 프로젝트&quot;를 수행합니다. 이러한 비즈니스의 대부분은 (비록) 저렴한 &quot;오픈 시스템&quot;(중간 프레임 / 서버) 솔루션을 선호하여 &quot;비싼&quot;메인 프레임을 포기하는 변명으로 이러한 활동을 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="715706274ddfcea7206514ce3a930e958b4c22bd" translate="yes" xml:space="preserve">
          <source>By undertaking so-called &amp;ldquo;modernization projects&amp;rdquo;, where existing applications are either rewritten in &amp;ldquo;modern&amp;rdquo; languages or replaced outright with purchased packages. Most of these businesses are using such activities as an excuse to abandon &amp;ldquo;expensive&amp;rdquo; mainframes in favour of (presumably) less-expensive &amp;ldquo;open systems&amp;rdquo; (mid frame/server) solutions.</source>
          <target state="translated">소위 &quot;현대화 프로젝트&quot;를 수행하여 기존 응용 프로그램을 &quot;현대&quot;언어로 다시 작성하거나 구매 한 패키지로 완전히 대체합니다. 이들 기업의 대부분은 (아마도) 저렴한 &quot;오픈 시스템&quot;(미드 프레임 / 서버) 솔루션을 선호하여 &quot;고가의&quot;메인 프레임을 포기하는 핑계로 이러한 활동을 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="308360143dd8d05e93d993a5a7724f3c1a3f223d" translate="yes" xml:space="preserve">
          <source>C &lt;code&gt;int&lt;/code&gt;, will be 1 during daylight savings</source>
          <target state="translated">C &lt;code&gt;int&lt;/code&gt; , 일광 절약 시간 동안 1이됩니다.</target>
        </trans-unit>
        <trans-unit id="c940e0c9cf2752e3e857b27f386c7312b6be944d" translate="yes" xml:space="preserve">
          <source>C &lt;code&gt;long&lt;/code&gt;, will be seconds west of UTC</source>
          <target state="translated">C &lt;code&gt;long&lt;/code&gt; , UTC 서쪽의 초입니다.</target>
        </trans-unit>
        <trans-unit id="b2d330f2fca96f1b05b308c57b06bfbb0866d3dd" translate="yes" xml:space="preserve">
          <source>C actually has no &quot;string&quot; data type; it stores strings as an array of&lt;code&gt;char&lt;/code&gt;data type items where each element of the array is a single character. Being an array, there is an upper limit to how many characters may be stored in a given &quot;string&quot;. For example:</source>
          <target state="translated">C에는 실제로 &quot;문자열&quot;데이터 유형이 없습니다. 배열의 각 요소가 단일 문자 인 &lt;code&gt;char&lt;/code&gt; 데이터 유형 항목 의 배열로 문자열을 저장 합니다. 배열이므로 지정된 &quot;문자열&quot;에 저장할 수있는 문자 수에는 상한이 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b3e8cb4ade20352dd5f21d47ecde75214d80992f" translate="yes" xml:space="preserve">
          <source>C actually has no &amp;ldquo;string&amp;rdquo; data type; it stores strings as an array of &lt;code&gt;char&lt;/code&gt; data type items where each element of the array is a single character. Being an array, there is an upper limit to how many characters may be stored in a given &amp;ldquo;string&amp;rdquo;. For example:</source>
          <target state="translated">C에는 실제로 &quot;문자열&quot;데이터 유형이 없습니다. 배열의 각 요소가 단일 문자 인 &lt;code&gt;char&lt;/code&gt; 데이터 유형 항목 의 배열로 문자열을 저장 합니다. 배열이기 때문에 주어진 &quot;문자열&quot;에 저장할 수있는 문자 수에 대한 상한이 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="23c3efab3e8f592b22e96b29b33ad31e771e23df" translate="yes" xml:space="preserve">
          <source>C provides a robust set of string-manipulation functions to copy strings from one char array to another, search strings for certain characters, compare one char array to another, concatenate char arrays and so forth. To make these functions possible, it was necessary to be able to define the logical end of a string. C accomplishes this via the expectation that all strings (char arrays) will be terminated by a NULL character (&lt;code&gt;x'00'&lt;/code&gt;). Of course, no one forces a programmer to do this, but if [s]he ever expects to use any of the C standard functions to manipulate that string they had</source>
          <target state="translated">C는 문자열을 한 char 배열에서 다른 배열로 복사하고, 특정 문자에 대한 문자열을 검색하고, 한 char 배열을 다른 배열과 비교하고, char 배열을 연결하는 등의 강력한 문자열 조작 기능을 제공합니다. 이러한 기능을 가능하게하려면 문자열의 논리적 끝을 정의 할 수 있어야했습니다. C는 모든 문자열 (char 배열)이 NULL 문자 ( &lt;code&gt;x'00'&lt;/code&gt; )로 끝날 것이라는 기대를 통해이를 수행합니다 . 물론, 프로그래머에게이 작업을 강요하는 사람은 없지만 C 표준 함수를 사용하여 해당 문자열을 조작 할 것으로 예상하면</target>
        </trans-unit>
        <trans-unit id="e9e27a8aa29a84e7706c6e8607e195451cdbd1f4" translate="yes" xml:space="preserve">
          <source>C provides a robust set of string-manipulation functions to copy strings from one char array to another, search strings for certain characters, compare one char array to another, concatenate char arrays and so forth. To make these functions possible, it was necessary to be able to define the logical end of a string. C accomplishes this via the expectation that all strings (char arrays) will be terminated by a NULL character (x&amp;rsquo;00&amp;rsquo;). Of course, no one forces a programmer to do this, but if [s]he ever expects to use any of the C standard functions to manipulate that string they had</source>
          <target state="translated">C는 한 문자 배열에서 다른 문자 배열로 문자열을 복사하고, 특정 문자에 대한 문자열을 검색하고, 한 문자 배열을 다른 문자 배열과 비교하고, 문자 배열을 연결하는 강력한 문자열 조작 함수 세트를 제공합니다. 이러한 기능을 가능하게하려면 문자열의 논리적 끝을 정의 할 수 있어야합니다. C는 모든 문자열 (char 배열)이 NULL 문자 (x'00 ')로 종료 될 것이라는 기대를 통해이를 달성합니다. 물론 프로그래머가이 작업을 수행하도록 강요하지는 않지만 C 표준 함수를 사용하여 해당 문자열을 조작하려는 경우</target>
        </trans-unit>
        <trans-unit id="8dcda46f8c65a9976fb21d248ed465647b6bde4c" translate="yes" xml:space="preserve">
          <source>C$CALLEDBY Built-In Subroutine Syntax</source>
          <target state="translated">C $ CALLEDBY 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="25aa760761479301e30e8a8c445c9432dd492410" translate="yes" xml:space="preserve">
          <source>C$CHDIR Built-In Subroutine Syntax</source>
          <target state="translated">C $ CHDIR 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="a6c60be72b5b88f58236cf8fb94ebaf0eefca5d7" translate="yes" xml:space="preserve">
          <source>C$COPY Built-In Subroutine Syntax</source>
          <target state="translated">C $ COPY 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="63fb329eb6628c3bd515a3892d5ea9aacf0522a8" translate="yes" xml:space="preserve">
          <source>C$DELETE Built-In Subroutine Syntax</source>
          <target state="translated">C $ DELETE 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="275df22fd79b6fa47dd5b523f6ebac52e1fdb8f6" translate="yes" xml:space="preserve">
          <source>C$FILEINFO Built-In Subroutine Syntax</source>
          <target state="translated">C $ FILEINFO 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="af04ab8b5e8f7046d43c002178e5c722059d13c1" translate="yes" xml:space="preserve">
          <source>C$GETPID Built-In Subroutine Syntax</source>
          <target state="translated">C $ GETPID 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="fb7ded84339e057daf0184a49ef164c65bc6b32a" translate="yes" xml:space="preserve">
          <source>C$JUSTIFY Built-In Subroutine Syntax</source>
          <target state="translated">C $ JUSTIFY 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="0b15c319201eb0d4f86b0cc53c98fc7d9d42c234" translate="yes" xml:space="preserve">
          <source>C$MAKEDIR Built-In Subroutine Syntax</source>
          <target state="translated">C $ MAKEDIR 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="60a0d45d44d016ceeda857f92ebe2f939551c1f9" translate="yes" xml:space="preserve">
          <source>C$NARG Built-In Subroutine Syntax</source>
          <target state="translated">C $ NARG 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="a4301ab99f38a6a937974d4fe3bd89d3d6e681f4" translate="yes" xml:space="preserve">
          <source>C$PARAMSIZE Built-In Subroutine Syntax</source>
          <target state="translated">C $ PARAMSIZE 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="ba12494eafa0188cb40b98d9c876a7425631a690" translate="yes" xml:space="preserve">
          <source>C$PRINTABLE Built-In Subroutine Syntax</source>
          <target state="translated">C $ PRINTABLE 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="70c2b1326b1c714146c0ce2aba499e0b8e206680" translate="yes" xml:space="preserve">
          <source>C$SLEEP Built-In Subroutine Syntax</source>
          <target state="translated">C $ SLEEP 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="0dbf00546e6a8778875a41b5b9d93ca091c5f5d9" translate="yes" xml:space="preserve">
          <source>C$TOLOWER Built-In Subroutine Syntax</source>
          <target state="translated">C $ TOLOWER 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="235bb9fb32c0abea6f7b04592732444d58218db6" translate="yes" xml:space="preserve">
          <source>C$TOUPPER Built-In Subroutine Syntax</source>
          <target state="translated">C $ TOUPPER 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="3663d9b51164847bc0a69f15726b5e044bb31706" translate="yes" xml:space="preserve">
          <source>C.cbl</source>
          <target state="translated">C.cbl</target>
        </trans-unit>
        <trans-unit id="6299f033afbfeafa65936acdd57ea1a7d2f87a08" translate="yes" xml:space="preserve">
          <source>C01, C02, C03, C04, C05, C06, C07, C08, C09, C10, C11, C12, CALENDAR-FONT, CALL-CONVENTION, CALL, CANCEL-BUTTON, CANCEL, CAPACITY, CARD-PUNCH, CARD-READER, CASSETTE, CBL_AND, CBL_CHANGE_DIR, CBL_CHECK_FILE_EXIST, CBL_CLOSE_FILE, CBL_COPY_FILE, CBL_CREATE_DIR, CBL_CREATE_FILE, CBL_DELETE_DIR, CBL_DELETE_FILE, CBL_EQ, CBL_ERROR_PROC, CBL_EXIT_PROC, CBL_FLUSH_FILE, CBL_GC_FORK, CBL_GC_GETOPT, CBL_GC_HOSTED, CBL_GC_NANOSLEEP, CBL_GC_PRINTABLE, CBL_GC_WAITPID, CBL_GET_CSR_POS, CBL_GET_CURRENT_DIR, CBL_GET_SCR_SIZE, CBL_IMP, CBL_NIMP, CBL_NOR, CBL_NOT, CBL_OC_GETOPT, CBL_OC_HOSTED, CBL_OC_NANOSLEEP, CBL_OPEN_FILE, CBL_OR, CBL_READ_FILE, CBL_READ_KBD_CHAR, CBL_RENAME_FILE, CBL_SET_CSR_POS, CBL_TOLOWER, CBL_TOUPPER, CBL_WRITE_FILE, CBL_XOR, C$CALLEDBY, C$CHDIR, CCOL, C$COPY, C$DELETE, CD, CELL-COLOR, CELL-DATA, CELL-FONT, CELL-PROTECTION, CELLS, CELL, CENTERED-HEADINGS, CENTER, CENTURY-DATE, C$FILEINFO, CF, C$GETPID, CHAINING, CHAIN, CHARACTERS, CHARACTER, CHAR-NATIONAL, CHAR, CHECK-BOX, CH, C$JUSTIFY, CLASS-ID, CLASSIFICATION, CLASS, CLEAR-SELECTION, CLINES, CLINE, CLOSE, C$MAKEDIR, C$NARG, COB-CRT-STATUS, COBOL, CODE-SET, CODE, COLLATING, COLORS, COLOR, COLOURS, COLS, COLUMN-COLOR, COLUMN-DIVIDERS, COLUMN-FONT, COLUMN-HEADINGS, COLUMN-PROTECTION, COLUMNS, COLUMN, COL, COMBINED-DATETIME, COMBO-BOX, COMMAND-LINE, COMMA, COMMIT, COMMON, COMMUNICATION, COMP-1, COMP-2, COMP-3, COMP-4, COMP-5, COMP-6, COMPUTATIONAL-1, COMPUTATIONAL-2, COMPUTATIONAL-3, COMPUTATIONAL-4, COMPUTATIONAL-5, COMPUTATIONAL-6, COMPUTATIONAL-X, COMPUTATIONAL, COMPUTE, COMP-X, COMP, CONCATENATE, CONDITION, CONFIGURATION, CONSOLE, CONSTANT, CONTAINS, CONTENT, CONTINUE, CONTROLS, CONTROL, CONVERSION, CONVERTING, COPY-SELECTION, COPY, CORRESPONDING, CORR, COS, COUNT, C$PARAMSIZE, C$PRINTABLE, CRT-UNDER, CRT, CSIZE, C$SLEEP, CSP, C$TOLOWER, C$TOUPPER, CURRENCY-SYMBOL, CURRENCY, CURRENT-DATE, CURSOR-COLOR, CURSOR-COL, CURSOR-FRAME-WIDTH, CURSOR-ROW, CURSOR-X, CURSOR, CURSOR-Y, CUSTOM-PRINT-TEMPLATE, CYCLE</source>
          <target state="translated">C01, C02, C03, C04, C05, C06, C07, C08, C09, C10, C11, C12, CALENDAR-FONT, CALL-CONVENTION, CALL, CANCEL-BUTTON, CANCEL, CAPACITY, CARD-PUNCH, CARD-READER, CASSETTE, CBL_AND, CBL_CHANGE_DIR, CBL_CHECK_FILE_EXIST, CBL_CLOSE_FILE, CBL_COPY_FILE, CBL_CREATE_DIR, CBL_CREATE_FILE, CBL_DELETE_DIR, CBL_DELETE_FILE, CBL_EQ, CBL_ERROR_PROC, CBL_EXIT_PROC, CBL_FLUSH_FILE, CBL_GC_FORK, CBL_GC_GETOPT, CBL_GC_HOSTED, CBL_GC_NANOSLEEP, CBL_GC_PRINTABLE, CBL_GC_WAITPID, CBL_GET_CSR_POS, CBL_GET_CURRENT_DIR, CBL_GET_SCR_SIZE, CBL_IMP, CBL_NIMP, CBL_NOR, CBL_NOT, CBL_OC_GETOPT, CBL_OC_HOSTED, CBL_OC_NANOSLEEP, CBL_OPEN_FILE, CBL_OR, CBL_READ_FILE, CBL_READ_KBD_CHAR, CBL_RENAME_FILE, CBL_SET_CBLSR_POS, CBL_UP, CBLDE_POS $, CBL_TOLOWER, CBL_TOCH 세포 색상, 세포 데이터, 세포 글꼴, 세포 보호, 세포, 세포,CENTERED-HEADINGS, CENTER, CENTURY-DATE, C $ FILEINFO, CF, C $ GETPID, CHAINING, CHAIN, CHARACTERS, CHARACTER, CHAR-NATIONAL, CHAR, CHECK-BOX, CH, C $ JUSTIFY, CLASS-ID, CLASSIFICATION, CLASS, CLEAR-SELECTION, CLINES, CLINE, CLOSE, C $ MAKEDIR, C $ NARG, COB-CRT-STATUS, COBOL, CODE-SET, CODE, COLLATING, COLORS, COLOR, COLOURS, COLS, COLUMN-COLOR, COLUMN- DIVIDERS, COLUMN-FONT, COLUMN-HEADINGS, COLUMN-PROTECTION, COLUMNS, COLUMN, COL, COMBINED-DATETIME, COMBO-BOX, COMMAND-LINE, COMMA, COMMIT, COMMON, COMMUNICATION, COMP-1, COMP-2, COMP- 3, COMP-4, COMP-5, COMP-6, COMPUTATIONAL-1, COMPUTATIONAL-2, COMPUTATIONAL-3, COMPUTATIONAL-4, COMPUTATIONAL-5, COMPUTATIONAL-6, COMPUTATIONAL-X, COMPUTATIONAL, COMPUTE, COMP-X, COMP, CONCATENATE, CONDITION, CONFIGURATION, CONSOLE, CONSTANT, CONTAINS, CONTENT, CONTINUE, CONTROLS, CONTROL, CONVERSION, CONVERTING, COPY-SELECTION,COPY, CORRESPONDING, CORR, COS, COUNT, C $ PARAMSIZE, C $ PRINTABLE, CRT-UNDER, CRT, CSIZE, C $ SLEEP, CSP, C $ TOLOWER, C $ TOUPPER, CURRENCY-SYMBOL, CURRENCY, CURRENT-DATE, CURSOR-COLOR, CURSOR-COL, CURSOR-FRAME-WIDTH, CURSOR-ROW, CURSOR-X, CURSOR, CURSOR-Y, CUSTOM-PRINT-TEMPLATE, CYCLE</target>
        </trans-unit>
        <trans-unit id="b586454872ec65496b80499102380369642ddd7c" translate="yes" xml:space="preserve">
          <source>C01, C02, C03, C04, C05, C06, C07, C08, C09, C10, C11, C12, CALL, CALL-CONVENTION, CANCEL, CAPACITY, CD, CENTER, CF, CH, CHAIN, CHAINING, CHAR, CHAR-NATIONAL, CHARACTER, CHARACTERS, CLASS, CLASS-ID, CLASSIFICATION, CLOSE, COB-CRT-STATUS, CODE, CODE-SET, COL, COLLATING, COLS, COLUMN, COLUMNS, COMBINED-DATETIME, COMMA, COMMAND-LINE, COMMIT, COMMON, COMMUNICATION, COMP, COMP-1, COMP-2, COMP-3, COMP-4, COMP-5, COMP-6, COMP-X, COMPUTATIONAL, COMPUTATIONAL-1, COMPUTATIONAL-2, COMPUTATIONAL-3, COMPUTATIONAL-4, COMPUTATIONAL-5, COMPUTATIONAL-X, COMPUTE, CONCATENATE, CONDITION, CONFIGURATION, CONSOLE, CONSTANT, CONTAINS, CONTENT, CONTINUE, CONTROL, CONTROLS, CONVERSION, CONVERTING, COPY, CORR, CORRESPONDING, COS, COUNT, CRT, CRT-UNDER, CSP, CURRENCY, CURRENCY-SYMBOL, CURRENT-DATE, CURSOR, CYCLE</source>
          <target state="translated">C01, C02, C03, C04, C05, C06, C07, C08, C09, C10, C11, C12, 통화, 통화 컨벤션, 취소, 용량, CD, 센터, CF, CH, 체인, 체인, CHAR, CHAR- 국가, 문자, 문자, 클래스, 클래스 ID, 분류, 닫기, COC-CRT- 상태, 코드, 코드 세트, COL, 콜 라이징, 콜스, 열, 열, 결합 날짜-시간, 쉼표, 명령 줄, 커밋, 일반, 통신, COMP, COMP-1, COMP-2, COMP-3, COMP-4, COMP-5, COMP-6, COMP-X, 계산, 계산 -1, 계산 -2, 계산 -3, 계산 -3, 계산- 4, 컴퓨터 5, 컴퓨터 X, 컴퓨터, 연결, 조건, 구성, 콘솔, 콘텐츠, 내용물, 내용물, 계속, 제어, 제어, 변환, 변환, 복사, 수정, 조정, COS, 카운트, CRT, CRT- 언더, CSP, 통화, 통화 기호, 현재 날짜, 커서, 사이클</target>
        </trans-unit>
        <trans-unit id="d7112487f9b801b5ed48a8fe0185ff002f67d359" translate="yes" xml:space="preserve">
          <source>C:\Pgms\myprog.exe</source>
          <target state="translated">C:\Pgms\myprog.exe</target>
        </trans-unit>
        <trans-unit id="de6043bc6c403ff9d2b6046c2362a636bfea53d8" translate="yes" xml:space="preserve">
          <source>CALL Argument Syntax</source>
          <target state="translated">호출 인수 구문</target>
        </trans-unit>
        <trans-unit id="2671d70df7d4a08926d8332357381e9f61c8e58b" translate="yes" xml:space="preserve">
          <source>CALL Syntax</source>
          <target state="translated">전화 구문</target>
        </trans-unit>
        <trans-unit id="526726fc890dc36e6dd8ae3a02580ed875790716" translate="yes" xml:space="preserve">
          <source>CANCEL Syntax</source>
          <target state="translated">취소 구문</target>
        </trans-unit>
        <trans-unit id="010c33a3c5669abc0d4c3e13b16ca99cd56d0d3d" translate="yes" xml:space="preserve">
          <source>CBL_AND Built-In Subroutine Syntax</source>
          <target state="translated">CBL_AND 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="c4b7fee42c3a84585978282604e00a5fb93a05ec" translate="yes" xml:space="preserve">
          <source>CBL_CHANGE_DIR Built-In Subroutine Syntax</source>
          <target state="translated">CBL_CHANGE_DIR 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="ffbc78325958ee05b70bb94019a16479e308ea2a" translate="yes" xml:space="preserve">
          <source>CBL_CHECK_FILE_EXIST Built-In Subroutine Syntax</source>
          <target state="translated">CBL_CHECK_FILE_EXIST 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="0d018ed830260089d76bfd38d1e7919cdcbdc024" translate="yes" xml:space="preserve">
          <source>CBL_CLOSE_FILE Built-In Subroutine Syntax</source>
          <target state="translated">CBL_CLOSE_FILE 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="b855b91a0b8fa8059790047a5423baec5643c25e" translate="yes" xml:space="preserve">
          <source>CBL_COPY_FILE Built-In Subroutine Syntax</source>
          <target state="translated">CBL_COPY_FILE 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="32251cdaf8beff67a4b3e7d1d106d86e40a1b100" translate="yes" xml:space="preserve">
          <source>CBL_CREATE_DIR Built-In Subroutine Syntax</source>
          <target state="translated">CBL_CREATE_DIR 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="f67e278d9381e059f5d21ba70a0ed735d91d5ee2" translate="yes" xml:space="preserve">
          <source>CBL_CREATE_FILE Built-In Subroutine Syntax</source>
          <target state="translated">CBL_CREATE_FILE 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="2aac303e78bc6ea49b38f3aaffb8696802f08b21" translate="yes" xml:space="preserve">
          <source>CBL_DELETE_DIR Built-In Subroutine Syntax</source>
          <target state="translated">CBL_DELETE_DIR 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="a9a2b66b1511e8c70416c9fb446dfa9d760f4409" translate="yes" xml:space="preserve">
          <source>CBL_DELETE_FILE Built-In Subroutine Syntax</source>
          <target state="translated">CBL_DELETE_FILE 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="9ae015083f02e9d041e26ed70b9a6fffc894949a" translate="yes" xml:space="preserve">
          <source>CBL_EQ Built-In Subroutine Syntax</source>
          <target state="translated">CBL_EQ 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="15f5e8eac7a336edda31e136c3f10dcb76eae126" translate="yes" xml:space="preserve">
          <source>CBL_ERROR_PROC Built-In Subroutine Syntax</source>
          <target state="translated">CBL_ERROR_PROC 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="3ae4f40d8c9a5da6bc0002c9319000e30916e9a3" translate="yes" xml:space="preserve">
          <source>CBL_EXIT_PROC Built-In Subroutine Syntax</source>
          <target state="translated">CBL_EXIT_PROC 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="2c8fd1e852b667bcff38aa9a4b3dace1a9c43521" translate="yes" xml:space="preserve">
          <source>CBL_FLUSH_FILE Built-In Subroutine Syntax</source>
          <target state="translated">CBL_FLUSH_FILE 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="e0bc84b9285576d6734e6beec514af63569e077c" translate="yes" xml:space="preserve">
          <source>CBL_GC_FORK Built-In Subroute Syntax</source>
          <target state="translated">CBL_GC_FORK 내장 서브 루트 구문</target>
        </trans-unit>
        <trans-unit id="444a554fdd59dc086037d0b015b21d8b23a1d476" translate="yes" xml:space="preserve">
          <source>CBL_GC_FORK allows you to fork the current COBOL process to a new one.</source>
          <target state="translated">CBL_GC_FORK를 사용하면 현재 COBOL 프로세스를 새 프로세스로 분기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1d3c0a940a8711fd973e8fc803b857b7de36bd4" translate="yes" xml:space="preserve">
          <source>CBL_GC_GETOPT Built-In Subroutine Syntax</source>
          <target state="translated">CBL_GC_GETOPT 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="474dd94a99e0f4504a3911e4ce0454b97922c3c1" translate="yes" xml:space="preserve">
          <source>CBL_GC_GETOPT realises the quite well-known option parser, getopt, for GnuCOBOL.</source>
          <target state="translated">CBL_GC_GETOPT는 GnuCOBOL에 대해 잘 알려진 옵션 파서 getopt를 실현합니다.</target>
        </trans-unit>
        <trans-unit id="a9a7fc3ba8bdc0eb16662e3346c6fffcf9382b20" translate="yes" xml:space="preserve">
          <source>CBL_GC_HOSTED Built-In Subroutine Syntax</source>
          <target state="translated">CBL_GC_HOSTED 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="1bfeab54a31d8553275c0736120372f4fd5e50c9" translate="yes" xml:space="preserve">
          <source>CBL_GC_NANOSLEEP Built-In Subroutine Syntax</source>
          <target state="translated">CBL_GC_NANOSLEEP 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="c3c7acc9905049c52db82c8c37dcdfbb6f5c396a" translate="yes" xml:space="preserve">
          <source>CBL_GC_PRINTABLE Built-In Subroutine Syntax</source>
          <target state="translated">CBL_GC_PRINTABLE 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="002a375b4e5e465227461332d42e7dfc4592f8d3" translate="yes" xml:space="preserve">
          <source>CBL_GC_WAITPID Built-In Subroutine Syntax</source>
          <target state="translated">CBL_GC_WAITPID 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="ac766867276b2aabf42d5cdfd47fb121f6240105" translate="yes" xml:space="preserve">
          <source>CBL_GET_CSR_POS Built-In Subroutine Syntax</source>
          <target state="translated">CBL_GET_CSR_POS 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="a9e5239f190652a889d9f29f10075e094c5d1f81" translate="yes" xml:space="preserve">
          <source>CBL_GET_CURRENT_DIR Built-In Subroutine Syntax</source>
          <target state="translated">CBL_GET_CURRENT_DIR 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="0bdeda2be1413a3e0154004ce2a6b0f698702b2c" translate="yes" xml:space="preserve">
          <source>CBL_GET_SCR_SIZE Built-In Subroutine Syntax</source>
          <target state="translated">CBL_GET_SCR_SIZE 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="ea53b33fa0fb048875430a66dede00fd79b11ae1" translate="yes" xml:space="preserve">
          <source>CBL_IMP Built-In Subroutine Syntax</source>
          <target state="translated">CBL_IMP 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="304410d70b67551eb4b5124bf58781cbe676608e" translate="yes" xml:space="preserve">
          <source>CBL_NIMP Built-In Subroutine Syntax</source>
          <target state="translated">CBL_NIMP 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="01330765ee05a71a49eb8a8266774fd9df168a0e" translate="yes" xml:space="preserve">
          <source>CBL_NOR Built-In Subroutine Syntax</source>
          <target state="translated">CBL_NOR 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="ae325b0b46a6629e90042a3330b4d6576832abee" translate="yes" xml:space="preserve">
          <source>CBL_NOT Built-In Subroutine Syntax</source>
          <target state="translated">CBL_NOT 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="72f3a1214c7ce4e4db541490264fce718bdb0b99" translate="yes" xml:space="preserve">
          <source>CBL_OPEN_FILE Built-In Subroutine Syntax</source>
          <target state="translated">CBL_OPEN_FILE 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="ea0d4c798253d7a104de0e6e336cb822d128317a" translate="yes" xml:space="preserve">
          <source>CBL_OR Built-In Subroutine Syntax</source>
          <target state="translated">CBL_OR 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="eaded8b3b2cce2d257ac7d4c3e1db62dd816b37d" translate="yes" xml:space="preserve">
          <source>CBL_READ_FILE Built-In Subroutine Syntax</source>
          <target state="translated">CBL_READ_FILE 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="d5869a0e4389714112ce1f0e3c52f1456938ee15" translate="yes" xml:space="preserve">
          <source>CBL_READ_KBD_CHAR Build-In Subroutine Syntax</source>
          <target state="translated">CBL_READ_KBD_CHAR 빌드-인 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="4cc6a542ee9584d1722e8a0254c05146e7a4bb23" translate="yes" xml:space="preserve">
          <source>CBL_RENAME_FILE Built-In Subroutine Syntax</source>
          <target state="translated">CBL_RENAME_FILE 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="4d25c38941724fdda5d272585e7c2c8b292abb8c" translate="yes" xml:space="preserve">
          <source>CBL_SET_CSR_POS Build-In Subroutine Syntax</source>
          <target state="translated">CBL_SET_CSR_POS 빌드-인 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="f083aaeb9579fac0486dd9732f32e424a58b291b" translate="yes" xml:space="preserve">
          <source>CBL_TOLOWER Built-In Subroutine Syntax</source>
          <target state="translated">CBL_TOLOWER 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="1d1313f5ae06b6506dffc0469a5b748ccadecaca" translate="yes" xml:space="preserve">
          <source>CBL_TOUPPER Built-In Subroutine Syntax</source>
          <target state="translated">CBL_TOUPPER 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="7b336aa7e9d6788405e2364f4cafc6c27b8fbf20" translate="yes" xml:space="preserve">
          <source>CBL_WRITE_FILE Built-In Subroutine Syntax</source>
          <target state="translated">CBL_WRITE_FILE 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="4838a4b796a648ad42c85059b4eb0c62946608f2" translate="yes" xml:space="preserve">
          <source>CBL_XOR Built-In Subroutine Syntax</source>
          <target state="translated">CBL_XOR 내장 서브 루틴 구문</target>
        </trans-unit>
        <trans-unit id="d88f27a7c7715ba85c6756380d4a86888335e802" translate="yes" xml:space="preserve">
          <source>CCCCCC</source>
          <target state="translated">CCCCCC</target>
        </trans-unit>
        <trans-unit id="ffe65e3de5a121cbb1a34ecf4bc260c413d9fa38" translate="yes" xml:space="preserve">
          <source>CDF $ Directive Syntax</source>
          <target state="translated">CDF $ 지시어 구문</target>
        </trans-unit>
        <trans-unit id="591b8a7ec66f16bf4faa0ec3a4deb122c5ea5b1d" translate="yes" xml:space="preserve">
          <source>CDF &amp;gt;&amp;gt;CALL-CONVENTION Syntax</source>
          <target state="translated">CDF &amp;gt;&amp;gt; 통화 구문</target>
        </trans-unit>
        <trans-unit id="869c317303145158af9e6e90164e7cd2f813dbb8" translate="yes" xml:space="preserve">
          <source>CDF &amp;gt;&amp;gt;D Directive Syntax</source>
          <target state="translated">CDF &amp;gt;&amp;gt; D 지시문 구문</target>
        </trans-unit>
        <trans-unit id="f050ae59c3cda50e2ce97a4e292c4f6b54cbd82f" translate="yes" xml:space="preserve">
          <source>CDF &amp;gt;&amp;gt;DEFINE Directive Syntax</source>
          <target state="translated">CDF &amp;gt;&amp;gt; DEFINE 지시문 구문</target>
        </trans-unit>
        <trans-unit id="a4dcdac96ffe39d449482c58407ae247c86d80c7" translate="yes" xml:space="preserve">
          <source>CDF &amp;gt;&amp;gt;DISPLAY Directive Syntax</source>
          <target state="translated">CDF &amp;gt;&amp;gt; DISPLAY 지시문 구문</target>
        </trans-unit>
        <trans-unit id="df4fd934a8558901c019c5c42be0fc334c6c6eb7" translate="yes" xml:space="preserve">
          <source>CDF &amp;gt;&amp;gt;IF Directive Syntax</source>
          <target state="translated">CDF &amp;gt;&amp;gt; IF 지시문 구문</target>
        </trans-unit>
        <trans-unit id="824fbca66d4ddb25c3dea88c697a1b3036fdd461" translate="yes" xml:space="preserve">
          <source>CDF &amp;gt;&amp;gt;LEAP-SECONDS Directive Syntax</source>
          <target state="translated">CDF &amp;gt;&amp;gt; LEAP-SECONDS 지시어 구문</target>
        </trans-unit>
        <trans-unit id="64ccb1c1d9bf1268318c29a01115271ec9043888" translate="yes" xml:space="preserve">
          <source>CDF &amp;gt;&amp;gt;LISTING Directive Syntax</source>
          <target state="translated">CDF &amp;gt;&amp;gt; LISTING 지시문 구문</target>
        </trans-unit>
        <trans-unit id="609992c93b4c3ac2672f59a190856a6003ae6098" translate="yes" xml:space="preserve">
          <source>CDF &amp;gt;&amp;gt;PAGE Directive Syntax</source>
          <target state="translated">CDF &amp;gt;&amp;gt; PAGE 지시문 구문</target>
        </trans-unit>
        <trans-unit id="2873759e8f982b49f15e9310726ffc1e448d2044" translate="yes" xml:space="preserve">
          <source>CDF &amp;gt;&amp;gt;SET Directive Syntax</source>
          <target state="translated">CDF &amp;gt;&amp;gt; SET 지시문 구문</target>
        </trans-unit>
        <trans-unit id="63ae47c2f2858a6c8094141c6269f6f02a37d0bb" translate="yes" xml:space="preserve">
          <source>CDF &amp;gt;&amp;gt;SOURCE Directive Syntax</source>
          <target state="translated">CDF &amp;gt;&amp;gt; SOURCE 지시어 구문</target>
        </trans-unit>
        <trans-unit id="0caac43c2a77c2d325c3effddadbdcdbb3a10132" translate="yes" xml:space="preserve">
          <source>CDF &amp;gt;&amp;gt;TURN Directive Syntax</source>
          <target state="translated">CDF &amp;gt;&amp;gt; TURN 지시문 구문</target>
        </trans-unit>
        <trans-unit id="3ea76d0141389cb93e5bd48077697b5d0cc98c38" translate="yes" xml:space="preserve">
          <source>CDF * Directive Syntax</source>
          <target state="translated">CDF * 지시문 구문</target>
        </trans-unit>
        <trans-unit id="c79f56e26f38fafdd62c99b49082274f30e09bbc" translate="yes" xml:space="preserve">
          <source>CDF COPY Phrase-Clause Syntax</source>
          <target state="translated">CDF COPY 문구-구문 구문</target>
        </trans-unit>
        <trans-unit id="ecd0c28c6783f66ff7fe78daee799faae6ea01dd" translate="yes" xml:space="preserve">
          <source>CDF COPY Statement Syntax</source>
          <target state="translated">CDF COPY 문 구문</target>
        </trans-unit>
        <trans-unit id="3bf0d1248eeeb581bbdb0cc930febc01a8f681aa" translate="yes" xml:space="preserve">
          <source>CDF COPY String-Clause Syntax</source>
          <target state="translated">CDF COPY 문자열 원인 구문</target>
        </trans-unit>
        <trans-unit id="045ab09524dc5447cd0cf03aa5eb3501bdffb25b" translate="yes" xml:space="preserve">
          <source>CDF REPLACE Phrase-Clause Syntax</source>
          <target state="translated">CDF 교체 문구-구문 구문</target>
        </trans-unit>
        <trans-unit id="375676f99be00b04e212eb20bff17e5558f0a46d" translate="yes" xml:space="preserve">
          <source>CDF REPLACE Statement (Format 1) Syntax</source>
          <target state="translated">CDF REPLACE 문 (형식 1) 구문</target>
        </trans-unit>
        <trans-unit id="2383d7055a0b1410fa38fa42aa494bc482941c7d" translate="yes" xml:space="preserve">
          <source>CDF REPLACE Statement (Format 2) Syntax</source>
          <target state="translated">CDF REPLACE 문 (형식 2) 구문</target>
        </trans-unit>
        <trans-unit id="3735b9293b76c2de3ece344ec6d5b55d226a7092" translate="yes" xml:space="preserve">
          <source>CDF REPLACE String-Clause Syntax</source>
          <target state="translated">CDF REPLACE 문자열 원인 구문</target>
        </trans-unit>
        <trans-unit id="f780a869f81377accdf06e9dfedadc683bf0692e" translate="yes" xml:space="preserve">
          <source>CDF directives, denoted by the presence of a &quot;&amp;gt;&amp;gt;&quot; character sequence as part of the statement name itself, are used to influence the process of program compilation.</source>
          <target state="translated">명령문 이름 자체의 일부로 &quot;&amp;gt;&amp;gt;&quot;문자 시퀀스가 ​​있음으로 표시되는 CDF 지시문은 프로그램 컴파일 프로세스에 영향을주기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5b882991aad746d8c7ab8e254bde1658902d0333" translate="yes" xml:space="preserve">
          <source>CDF directives, denoted by the presence of a &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; character sequence as part of the statement name itself, influence the process of program compilation.</source>
          <target state="translated">명령문 이름 자체의 일부로 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 문자 시퀀스 의 존재로 표시되는 CDF 지시문 은 프로그램 컴파일 프로세스에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="fecc3546fcec8d553d001b55777257b1ac13ddcb" translate="yes" xml:space="preserve">
          <source>CDF variable names follow the rules for standard GnuCOBOL user-defined names, and may not duplicate any CDF reserved word. CDF variable names may duplicate COBOL reserved words, provided the  &lt;code&gt;CONSTANT&lt;/code&gt; option is not specified, but such names are not recommended.</source>
          <target state="translated">CDF 변수 이름은 표준 GnuCOBOL 사용자 정의 이름에 대한 규칙을 따르며 CDF 예약어를 복제 할 수 없습니다. &lt;code&gt;CONSTANT&lt;/code&gt; 옵션이 지정되지 않은 경우 CDF 변수 이름은 COBOL 예약어와 중복 될 수 있지만 이러한 이름은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc9770a9ad7daa753f5b06243cae55af53abb717" translate="yes" xml:space="preserve">
          <source>CDF variable names follow the rules for standard GnuCOBOL user-defined names, and may not duplicate any CDF reserved word. CDF variable names may duplicate COBOL reserved words, provided the&lt;code&gt;CONSTANT&lt;/code&gt;</source>
          <target state="translated">CDF 변수 이름은 표준 GnuCOBOL 사용자 정의 이름에 대한 규칙을 따르며 CDF 예약어를 복제 할 수 없습니다. &lt;code&gt;CONSTANT&lt;/code&gt; 있으면 CDF 변수 이름이 COBOL 예약어를 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1c88610b8d7bdc380f8f72e92ae0e9921bd36e0" translate="yes" xml:space="preserve">
          <source>CDF variables defined in this way become undefined once an &lt;code&gt;END PROGRAM&lt;/code&gt; or &lt;code&gt;END FUNCTION&lt;/code&gt; directive is encountered in the input source.</source>
          <target state="translated">이러한 방식으로 정의 된 CDF 변수는 &lt;code&gt;END PROGRAM&lt;/code&gt; 또는 &lt;code&gt;END FUNCTION&lt;/code&gt; 지시문이 입력 소스에서 발견 되면 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3087363482395db318308c5f193a16c28c675dc0" translate="yes" xml:space="preserve">
          <source>CDF variables defined in this way become undefined once an&lt;code&gt;END PROGRAM&lt;/code&gt;or&lt;code&gt;END FUNCTION&lt;/code&gt;directive is encountered in the input source.</source>
          <target state="translated">이러한 방식으로 정의 된 CDF 변수 는 입력 소스에서 &lt;code&gt;END PROGRAM&lt;/code&gt; 또는 &lt;code&gt;END FUNCTION&lt;/code&gt; 지시어가 발생 하면 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="40c106188bad3afd1ea3ef1e235247ac585ffea3" translate="yes" xml:space="preserve">
          <source>CDF-Conditional-Expression</source>
          <target state="translated">CDF-Conditional-Expression</target>
        </trans-unit>
        <trans-unit id="860fddb177df40e4e9448d281b9d62e5d7dbf445" translate="yes" xml:space="preserve">
          <source>CDF-Conditional-Expression Syntax</source>
          <target state="translated">CDF 조건식 구문</target>
        </trans-unit>
        <trans-unit id="c8f787b98efc8a28519cd79611110f3f03f0701e" translate="yes" xml:space="preserve">
          <source>CDF-Conditional-Expression-n</source>
          <target state="translated">CDF-Conditional-Expression-n</target>
        </trans-unit>
        <trans-unit id="486a9febb65e04c40f48a599b8b975e230efd5dd" translate="yes" xml:space="preserve">
          <source>CDF-RelOp Syntax</source>
          <target state="translated">CDF-RelOp 구문</target>
        </trans-unit>
        <trans-unit id="2e70fa0781b6f4e906d33d795a5ed0279c57c5f9" translate="yes" xml:space="preserve">
          <source>CHAR Function Syntax</source>
          <target state="translated">CHAR 함수 구문</target>
        </trans-unit>
        <trans-unit id="0e538d3a75bbca0165f32d7d1c053a8929a8b130" translate="yes" xml:space="preserve">
          <source>CHAR-NATIONAL Function Syntax</source>
          <target state="translated">CHAR-NATIONAL 함수 구문</target>
        </trans-unit>
        <trans-unit id="5d2b785d4279a4a46339f75de21da44960c6322a" translate="yes" xml:space="preserve">
          <source>CLOSE Syntax</source>
          <target state="translated">CLOSE 구문</target>
        </trans-unit>
        <trans-unit id="b56db732d567166c7442e0554b48fca84550e947" translate="yes" xml:space="preserve">
          <source>COB-COLOR-BLACK</source>
          <target state="translated">COB-COLOR-BLACK</target>
        </trans-unit>
        <trans-unit id="cb4619cb37e6b5b8697c08e8c5e336b3e5fd7583" translate="yes" xml:space="preserve">
          <source>COB-COLOR-BLUE</source>
          <target state="translated">COB-COLOR-BLUE</target>
        </trans-unit>
        <trans-unit id="29b9973c67fa35f969e562c44aae035e1e245789" translate="yes" xml:space="preserve">
          <source>COB-COLOR-CYAN</source>
          <target state="translated">COB-COLOR-CYAN</target>
        </trans-unit>
        <trans-unit id="44cd3fd995eaf807cbb1d3b23c3ffba2af92ad08" translate="yes" xml:space="preserve">
          <source>COB-COLOR-GREEN</source>
          <target state="translated">COB-COLOR-GREEN</target>
        </trans-unit>
        <trans-unit id="6f0f3cf54c45e3b0610a2f32418cea17b3098113" translate="yes" xml:space="preserve">
          <source>COB-COLOR-MAGENTA</source>
          <target state="translated">COB-COLOR-MAGENTA</target>
        </trans-unit>
        <trans-unit id="31045d6b5fdabc7b4fd64345701940291c3fbf3f" translate="yes" xml:space="preserve">
          <source>COB-COLOR-RED</source>
          <target state="translated">COB-COLOR-RED</target>
        </trans-unit>
        <trans-unit id="bd43a22c0eb6b187d0325e3088ace819b7929aa0" translate="yes" xml:space="preserve">
          <source>COB-COLOR-WHITE</source>
          <target state="translated">COB-COLOR-WHITE</target>
        </trans-unit>
        <trans-unit id="e2030988a7874109279c5ae4e2014012495610c6" translate="yes" xml:space="preserve">
          <source>COB-COLOR-YELLOW</source>
          <target state="translated">COB-COLOR-YELLOW</target>
        </trans-unit>
        <trans-unit id="90a2fc9d8928d812fbfa67cc8815fa975746d710" translate="yes" xml:space="preserve">
          <source>COBOL</source>
          <target state="translated">COBOL</target>
        </trans-unit>
        <trans-unit id="eadfe5afbc4bdc9323ff76aabd892e614a42f98a" translate="yes" xml:space="preserve">
          <source>COBOL (GnuCOBOL included) still requires that each procedure division paragraph contain at least one sentence if there is any executable code in that paragraph, but a popular coding style is now to simply code a single period right before the end of each paragraph.</source>
          <target state="translated">COBOL (GnuCOBOL 포함)은 해당 단락에 실행 코드가있는 경우 각 프로 시저 분할 단락에 적어도 하나의 문장이 포함되도록 요구하지만, 인기있는 코딩 스타일은 이제 각 단락이 끝나기 직전에 단일 기간을 단순히 코딩하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3f259b701df0ffea124e9e9d93fa38f5515d1dc6" translate="yes" xml:space="preserve">
          <source>COBOL (the default) the program name is treated as a COBOL word that maps to the externalised name program to be called, cancelled or referenced in the program-address-identifier, applying the same mapping rules as for a program name for which no AS phrase is specified.</source>
          <target state="translated">COBOL (기본값) 프로그램 이름은 AS- 코드가없는 프로그램 이름과 동일한 맵핑 규칙을 적용하여 프로그램 주소 식별자에서 호출, 취소 또는 참조 될 외부화 된 이름 프로그램에 맵핑되는 COBOL 단어로 처리됩니다. 문구가 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="48fb8f2f43202777e485002999e4bff39f18277a" translate="yes" xml:space="preserve">
          <source>COBOL allows data names to be duplicated within a program, provided references to those data names may be made in such a manner as to make those references unique through a process known as qualification.</source>
          <target state="translated">COBOL을 사용하면 프로그램 내에서 데이터 이름을 복제 할 수 있습니다. 단, 해당 데이터 이름에 대한 참조는 자격으로 알려진 프로세스를 통해 고유하게 만드는 방식으로 만들어 질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a497059411f21246aa0ed246a4c62fff7c4a465" translate="yes" xml:space="preserve">
          <source>COBOL introduced the concept of structured data. The principle of structured data in COBOL is based on the idea of being able to group related and contiguously-allocated data items together into a single aggregate data item, called a  &lt;em&gt;Group Item&lt;/em&gt;. For example, a 35-character &amp;rsquo;Employee-Name&amp;rsquo; group item might consist of a 20-character &amp;rsquo;Last-Name&amp;rsquo; followed by a 14-character &amp;rsquo;First-Name&amp;rsquo; and a 1-character &amp;rsquo;Middle-Initial&amp;rsquo;.</source>
          <target state="translated">COBOL은 구조화 된 데이터의 개념을 도입했습니다. COBOL에서 구조화 된 데이터의 원칙은 관련되고 연속적으로 할당 된 데이터 항목을 &lt;em&gt;그룹 항목&lt;/em&gt; 이라고하는 단일 집계 데이터 항목으로 함께 그룹화 할 수 있다는 개념에 기반합니다 . 예를 들어, 35 자 'Employee-Name'그룹 항목은 20 자 'Last-Name'과 14 자 'First-Name'및 1 자 'Middle-Initial'로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bad4eaa4bb2e0dd2937ccfeadd29c67245044240" translate="yes" xml:space="preserve">
          <source>COBOL introduced the concept of structured data. The principle of structured data in COBOL is based on the idea of being able to group related and contiguously-allocated data items together into a single aggregate data item, called a &amp;rsquo;</source>
          <target state="translated">COBOL은 구조화 된 데이터 개념을 도입했습니다. COBOL에서 구조화 된 데이터의 원칙은 관련되고 연속적으로 할당 된 데이터 항목을 '집합'이라는 단일 집계 데이터 항목으로 그룹화 할 수 있다는 아이디어를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="88f7e793363c359f805338e8ab3bfc1ba1b12ce9" translate="yes" xml:space="preserve">
          <source>COBOL is no exception, although it does include some very powerful string manipulation capabilities; GnuCOBOL actually has even more string-manipulation capabilities than many other COBOL implementations. The following summarizes GnuCOBOL&amp;rsquo;s string-processing capabilities:</source>
          <target state="translated">COBOL도 매우 강력한 문자열 조작 기능을 포함하지만 예외는 아닙니다. GnuCOBOL은 실제로 다른 많은 COBOL 구현보다 훨씬 많은 문자열 조작 기능을 가지고 있습니다. 다음은 GnuCOBOL의 문자열 처리 기능을 요약 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="dde8c6334c994b5347cfada0a05a26b03a15ab9b" translate="yes" xml:space="preserve">
          <source>COBOL programming standards used by many organizations that use the language generally call for procedure names to:</source>
          <target state="translated">언어를 사용하는 많은 조직에서 사용하는 COBOL 프로그래밍 표준은 일반적으로 다음과 같은 절차 이름을 요구합니다.</target>
        </trans-unit>
        <trans-unit id="237c5dec647d58128f7e92bd3621d1dca2820712" translate="yes" xml:space="preserve">
          <source>COBOL programs are structured into four major areas of coding, each with its own purpose. These four areas are known as divisions.</source>
          <target state="translated">COBOL 프로그램은 각각 고유 한 목적을 가진 네 가지 주요 코딩 영역으로 구성됩니다. 이 네 가지 영역을 부서라고합니다.</target>
        </trans-unit>
        <trans-unit id="40d677d08c7bd935e12b6567e3a0a71e438d7f4e" translate="yes" xml:space="preserve">
          <source>COBOL stores these character sequences up to a specific quantity limit imposed by the &lt;code&gt;PICTURE&lt;/code&gt; (see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause of the data item. For example: &lt;code&gt;01  LastName   PIC X(15).&lt;/code&gt;.</source>
          <target state="translated">COBOL 은 데이터 항목 의 &lt;code&gt;PICTURE&lt;/code&gt; ( &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt; 참조 ) 절 에 의해 부과 된 특정 수량 제한까지 이러한 문자 시퀀스를 저장합니다 . 예 : &lt;code&gt;01 LastName PIC X(15).&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dac3fc3307f5261c119816a3d0eb8a309a74395c" translate="yes" xml:space="preserve">
          <source>COBOL stores these character sequences up to a specific quantity limit imposed by the&lt;code&gt;PICTURE&lt;/code&gt;(see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause of the data item. For example:&lt;code&gt;01 LastName PIC X(15).&lt;/code&gt;</source>
          <target state="translated">COBOL은 이러한 문자 시퀀스를 데이터 항목 의 &lt;code&gt;PICTURE&lt;/code&gt; ( &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt; 참조 ) 절 에 의해 지정된 특정 수량 제한까지 저장합니다 . 예 : &lt;code&gt;01 LastName PIC X(15).&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="909b919ed1edcb2747079bf5361924010f7d94b1" translate="yes" xml:space="preserve">
          <source>COBOL uses parenthesis to specify the subscripts used to reference table entries (tables in COBOL are what other programming languages refer to as arrays).</source>
          <target state="translated">COBOL은 괄호를 사용하여 테이블 항목을 참조하는 데 사용되는 첨자를 지정합니다 (COBOL의 테이블은 다른 프로그래밍 언어가 배열로 참조하는 것임).</target>
        </trans-unit>
        <trans-unit id="8f31338688ef4d62ce570b667480bdfbfbfe6872" translate="yes" xml:space="preserve">
          <source>COBOL uses the concept of a</source>
          <target state="translated">COBOL은</target>
        </trans-unit>
        <trans-unit id="ce9ef7dc01343b612f6c4d064720d1b0787f7476" translate="yes" xml:space="preserve">
          <source>COBOL uses the concept of a &quot;level number&quot; to indicate the level at which a data item occurs in a data structure such as the example shown above. When these data items are defined, they are all defined together with a number in the range 1-49 specified in front of their names. Over the years, a convention has come to exist among COBOL programmers that level numbers are always coded as two-digit numbers &amp;mdash; they don&amp;rsquo;t</source>
          <target state="translated">COBOL은 &quot;레벨 번호&quot;개념을 사용하여 위에 표시된 예와 같은 데이터 구조에서 데이터 항목이 발생하는 레벨을 나타냅니다. 이러한 데이터 항목이 정의되면 이름 앞에 지정된 1-49 범위의 숫자와 함께 모두 정의됩니다. 수년에 걸쳐 COBOL 프로그래머들 사이에서 레벨 번호는 항상 두 자리 숫자로 코딩된다는 협약이 생겨났습니다.</target>
        </trans-unit>
        <trans-unit id="e6ef4657869782222ae93ff64fc2b30b55f64086" translate="yes" xml:space="preserve">
          <source>COBOL, first introduced to the programming public in 1959, was the very first programming language to become standardized (in 1960). This meant that a standard-compliant COBOL program written on computer &quot;A&quot; made by company &quot;B&quot; would be able to be compiled and executed on computer &quot;X&quot; made by company &quot;Y&quot; with very few, if any, changes. This may not seem like such a big deal today, but it was a radical departure from all programming languages that came before it and even many that came after it.</source>
          <target state="translated">1959 년에 프로그래밍 대중에게 처음 소개 된 COBOL은 표준화 된 최초의 프로그래밍 언어였습니다 (1960 년). 이것은 회사 &quot;B&quot;에 의해 만들어진 컴퓨터 &quot;A&quot;에 작성된 표준 호환 COBOL 프로그램이 거의 변경되지 않으면 서 회사 &quot;Y&quot;에 의해 만들어진 컴퓨터 &quot;X&quot;에서 컴파일되고 실행될 수 있음을 의미했습니다. 이것은 오늘날 그렇게 큰 일이 아닌 것처럼 보일지 모르지만, 그 이전에 온 모든 프로그래밍 언어와 그 이후의 많은 언어에서 급격히 벗어났습니다.</target>
        </trans-unit>
        <trans-unit id="19613655dc62ee256d5471ff556e9dc1fb626bc0" translate="yes" xml:space="preserve">
          <source>COBOL, first introduced to the programming public in 1959, was the very first programming language to become standardized (in 1960). This meant that a standard-compliant COBOL program written on computer &amp;ldquo;A&amp;rdquo; made by company &amp;ldquo;B&amp;rdquo; would be able to be compiled and executed on computer &amp;ldquo;X&amp;rdquo; made by company &amp;ldquo;Y&amp;rdquo; with very few, if any, changes. This may not seem like such a big deal today, but it was a radical departure from all programming languages that came before it and even many that came after it.</source>
          <target state="translated">1959 년 프로그래밍 대중에게 처음 소개 된 COBOL은 표준화 된 최초의 프로그래밍 언어였습니다 (1960 년). 즉, 회사&amp;ldquo;B&amp;rdquo;가 만든 컴퓨터&amp;ldquo;A&amp;rdquo;에 작성된 표준 호환 COBOL 프로그램은 거의 변경하지 않고 회사&amp;ldquo;Y&amp;rdquo;가 만든 컴퓨터&amp;ldquo;X&amp;rdquo;에서 컴파일 및 실행할 수 있습니다. 이것은 오늘날 그렇게 큰 문제처럼 보이지 않을 수도 있지만 이전에 나온 모든 프로그래밍 언어와 그 이후에 나온 많은 프로그래밍 언어에서 급격한 출발이었습니다.</target>
        </trans-unit>
        <trans-unit id="c7feed455a4b79b075fdccc23d9b50c81b9be30b" translate="yes" xml:space="preserve">
          <source>COLUMN (REPORT SECTION) Clause Syntax</source>
          <target state="translated">열 (보고서 섹션) 조항 구문</target>
        </trans-unit>
        <trans-unit id="67926b14557077295e873f6eb0943e04447ace62" translate="yes" xml:space="preserve">
          <source>COLUMN (SCREEN SECTION) Clause Syntax</source>
          <target state="translated">COLUMN (SCREEN SECTION) 절 구문</target>
        </trans-unit>
        <trans-unit id="e947ac3b421a25bfd653c90f78152c95ca1753e4" translate="yes" xml:space="preserve">
          <source>COMBINED-DATETIME Function Syntax</source>
          <target state="translated">COMBINED-DATETIME 함수 구문</target>
        </trans-unit>
        <trans-unit id="10223130153973998a9c9edb1ab0e28808779d2b" translate="yes" xml:space="preserve">
          <source>COMMIT Syntax</source>
          <target state="translated">커밋 구문</target>
        </trans-unit>
        <trans-unit id="9023f069fa53953217be7784a46e321ea47b5e6c" translate="yes" xml:space="preserve">
          <source>COMPUTATIONAL-1</source>
          <target state="translated">COMPUTATIONAL-1</target>
        </trans-unit>
        <trans-unit id="77d504bbedfdd326fb91883e0396fb0c0711c5e2" translate="yes" xml:space="preserve">
          <source>COMPUTATIONAL-2</source>
          <target state="translated">COMPUTATIONAL-2</target>
        </trans-unit>
        <trans-unit id="42f2cf4efe24a37906cd89833c42647573a1a66e" translate="yes" xml:space="preserve">
          <source>COMPUTE Syntax</source>
          <target state="translated">계산 구문</target>
        </trans-unit>
        <trans-unit id="ce9a1104da0ef136acfdecfada86cc49b918885e" translate="yes" xml:space="preserve">
          <source>CONCATENATE Function Syntax</source>
          <target state="translated">CONCATENATE 함수 구문</target>
        </trans-unit>
        <trans-unit id="e9543acb0a3b6ae140b676bdd75a9f04b94c736b" translate="yes" xml:space="preserve">
          <source>CONFIGURATION SECTION Syntax</source>
          <target state="translated">구성 섹션 구문</target>
        </trans-unit>
        <trans-unit id="fd14e0768d8e03137017ff03d76cc74754b47cbb" translate="yes" xml:space="preserve">
          <source>CONSTANT Attribute Syntax</source>
          <target state="translated">상수 속성 구문</target>
        </trans-unit>
        <trans-unit id="45f863a18c883ddde1c38a1609e1083371a910f8" translate="yes" xml:space="preserve">
          <source>CONTINUE Syntax</source>
          <target state="translated">계속 구문</target>
        </trans-unit>
        <trans-unit id="57c118d0153aad86aee87fdaf7399dce402a08bd" translate="yes" xml:space="preserve">
          <source>CONTROL FOOTING(S) [2]</source>
          <target state="translated">컨트롤 풋 (들) [2]</target>
        </trans-unit>
        <trans-unit id="a0b77db4412f953dc79ec3e8dadb8c3312edb9f0" translate="yes" xml:space="preserve">
          <source>CONTROL HEADING(S) [2]</source>
          <target state="translated">제어 청각 (들) [2]</target>
        </trans-unit>
        <trans-unit id="a0fe3388635d6d014a065ee11d0aee898e490bea" translate="yes" xml:space="preserve">
          <source>COS Function Syntax</source>
          <target state="translated">COS 함수 구문</target>
        </trans-unit>
        <trans-unit id="e2bf90245c3eae70b50309837f6647c1f83fdf58" translate="yes" xml:space="preserve">
          <source>COUNT</source>
          <target state="translated">COUNT</target>
        </trans-unit>
        <trans-unit id="762cf7076b068d306d32ea79b0d0e2277121f2b5" translate="yes" xml:space="preserve">
          <source>CR</source>
          <target state="translated">CR</target>
        </trans-unit>
        <trans-unit id="46a355610c958a2df7dbd1b4d7bf89438582b10c" translate="yes" xml:space="preserve">
          <source>CURRENCY-SYMBOL Function Syntax</source>
          <target state="translated">CURRENCY-SYMBOL 함수 구문</target>
        </trans-unit>
        <trans-unit id="7ab87c3b533221867b4462ee901838685c51bd46" translate="yes" xml:space="preserve">
          <source>CURRENT-DATE Function Syntax</source>
          <target state="translated">CURRENT-DATE 함수 구문</target>
        </trans-unit>
        <trans-unit id="8980ae6fd73bcc82840b7888df9223d5cb16f6b5" translate="yes" xml:space="preserve">
          <source>Call Folding</source>
          <target state="translated">콜 폴딩</target>
        </trans-unit>
        <trans-unit id="7f55d49edf888f806f705f970cf3931b2d28dc46" translate="yes" xml:space="preserve">
          <source>Call also supports using an entry point stored in a &lt;code&gt;PROGRAM-POINTER&lt;/code&gt;, avoiding the dynamic runtime lookup. GnuCOBOL keeps a cache of lookups during a program run. Repeated use of a named function does not suffer much penalty, but &lt;code&gt;PROGRAM-POINTER&lt;/code&gt; will be just that little bit faster. To set a &lt;code&gt;PROGRAM-POINTER&lt;/code&gt; use &lt;code&gt;SET &lt;var&gt;program-reference&lt;/var&gt; TO ENTRY &quot;&lt;var&gt;name&lt;/var&gt;&quot;&lt;/code&gt; (or get the address from an API, and take part in callback programming).</source>
          <target state="translated">또한 호출은 &lt;code&gt;PROGRAM-POINTER&lt;/code&gt; 에 저장된 진입 점 사용을 지원하여 동적 런타임 조회를 방지합니다. GnuCOBOL은 프로그램 실행 중에 조회 캐시를 유지합니다. 명명 된 함수를 반복적으로 사용하는 것은 많은 불이익을받지 않지만 &lt;code&gt;PROGRAM-POINTER&lt;/code&gt; 는 조금 더 빠를 것입니다. 세트에 &lt;code&gt;PROGRAM-POINTER&lt;/code&gt; 를 사용 &lt;code&gt;SET &lt;var&gt;program-reference&lt;/var&gt; TO ENTRY &quot;&lt;var&gt;name&lt;/var&gt;&quot;&lt;/code&gt; (또는 API의 주소를 얻고, 콜백 프로그램에 참여).</target>
        </trans-unit>
        <trans-unit id="a2b6abc7961dcf84b76adf0da7d0e3cb7258497a" translate="yes" xml:space="preserve">
          <source>Called Program</source>
          <target state="translated">호출 된 프로그램</target>
        </trans-unit>
        <trans-unit id="08e86dd2cb3e588792e5a1445c80be0d6ca86b4d" translate="yes" xml:space="preserve">
          <source>Called program not found</source>
          <target state="translated">호출 된 프로그램을 찾을 수 없습니다</target>
        </trans-unit>
        <trans-unit id="79de0a0be26f9fe0196ab734446be6015cb155b5" translate="yes" xml:space="preserve">
          <source>Calling Program</source>
          <target state="translated">전화 프로그램</target>
        </trans-unit>
        <trans-unit id="4aa75fa92437b6df595f9667af7d64254448be0b" translate="yes" xml:space="preserve">
          <source>Care must be taken that &amp;lt;</source>
          <target state="translated">&amp;lt;</target>
        </trans-unit>
        <trans-unit id="44f46fc57da5c8811a3fdc2e20a7f14a4f5fcca4" translate="yes" xml:space="preserve">
          <source>Care must be taken that &lt;var&gt;constant-name-1&lt;/var&gt; does not duplicate any other data item name that has been defined in the program as references to that data item name will refer to the constant and not the data item. The GnuCOBOL compiler will not issue a warning about this condition.</source>
          <target state="translated">데이터 항목 이름에 대한 참조는 데이터 항목이 아니라 &lt;var&gt;constant-name-1&lt;/var&gt; 를 참조 하므로 constant-name-1 이 프로그램에 정의 된 다른 데이터 항목 이름을 복제하지 않도록 주의해야합니다 . GnuCOBOL 컴파일러는이 조건에 대한 경고를 발행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0fdf8af8472823c51043780169333ae53b188ec1" translate="yes" xml:space="preserve">
          <source>Care must be taken that programs reading such a file describe records whose length is exactly the same as that used by the program that created the file. For example, the following shows the contents of a &lt;code&gt;SEQUENTIAL&lt;/code&gt; file created by a program that wrote five 6-character records to it. The &amp;lsquo;</source>
          <target state="translated">그러한 파일을 읽는 프로그램이 파일을 작성한 프로그램에서 사용한 길이와 정확히 동일한 레코드를 설명하도록주의해야합니다. 예를 들어, 다음은 5 개의 6 자 레코드를 기록한 프로그램에 의해 작성된 &lt;code&gt;SEQUENTIAL&lt;/code&gt; 파일 의 내용을 보여줍니다 . '</target>
        </trans-unit>
        <trans-unit id="232276f2c2caa7b4c6621023fcbe761e2f25eb06" translate="yes" xml:space="preserve">
          <source>Care must be taken that programs reading such a file describe records whose length is exactly the same as that used by the program that created the file. For example, the following shows the contents of a&lt;code&gt;SEQUENTIAL&lt;/code&gt;file created by a program that wrote five 6-character records to it. The &quot;A&quot;, &quot;B&quot;, &amp;hellip; values reflect the records that were written to the file:</source>
          <target state="translated">이러한 파일을 읽는 프로그램은 길이가 파일을 작성한 프로그램에서 사용한 길이와 정확히 동일한 레코드를 설명하도록주의해야합니다. 예를 들어, 다음은 5 개의 6 문자 레코드를 기록한 프로그램으로 작성된 &lt;code&gt;SEQUENTIAL&lt;/code&gt; 파일 의 내용을 보여줍니다 . &quot;A&quot;, &quot;B&quot;,&amp;hellip; 값은 파일에 기록 된 레코드를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="0d6ab5c40892951a44701a3cbbc3363615028003" translate="yes" xml:space="preserve">
          <source>Care must be taken that programs reading such a file describe records whose length is exactly the same as that used by the programs that created the file. It won&amp;rsquo;t end well if the GnuCOBOL runtime library interprets a four-byte ASCII character string as a record length when it transfers data from the file into the program!</source>
          <target state="translated">이러한 파일을 읽는 프로그램은 길이가 파일을 작성한 프로그램에서 사용한 길이와 정확히 동일한 레코드를 설명하도록주의해야합니다. 파일에서 프로그램으로 데이터를 전송할 때 GnuCOBOL 런타임 라이브러리가 4 바이트 ASCII 문자열을 레코드 길이로 해석하면 제대로 끝나지 않습니다!</target>
        </trans-unit>
        <trans-unit id="7c6c97c84f8056669f430c4736312352ec00b4b7" translate="yes" xml:space="preserve">
          <source>Case-folding may also be turned on and off within the program source code using the CDF &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; statement (see &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt;SET&lt;/a&gt;).</source>
          <target state="translated">CDF &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; 문을 사용하여 프로그램 소스 코드 내에서 대소 문자 구분을 켜고 끌 수도 있습니다 ( &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt; SET&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="008af863881dc7149313286a97c8945b993a34fe" translate="yes" xml:space="preserve">
          <source>Case-folding may also be turned on and off within the program source code using the CDF&lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt;statement (see &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt;SET&lt;/a&gt;).</source>
          <target state="translated">CDF &lt;code&gt;&amp;gt;&amp;gt;SET&lt;/code&gt; 문을 사용하여 프로그램 소스 코드 내에서 케이스 폴딩을 켜거나 끌 수도 있습니다 ( &lt;a href=&quot;#g_t_003e_003eSET&quot;&gt;&amp;gt;&amp;gt; SET&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="98accb26910de4948b37b8fbb0b408fbd1a965e0" translate="yes" xml:space="preserve">
          <source>Caution. Although this document is for version 2.2 of the compiler, it also includes a description of the functions of the RWCS (Report Writer module) which is not included in the compiler version 2.2. Please see availability notes on this at 1.3.13.</source>
          <target state="translated">주의. 이 문서는 컴파일러 버전 2.2 용이지만 컴파일러 버전 2.2에 포함되지 않은 RWCS (보고서 작성기 모듈) 기능에 대한 설명도 포함합니다. 1.3.13의 가용성 정보를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="09dbd187de708ee21b01806ae5b0ca883102654a" translate="yes" xml:space="preserve">
          <source>Caveat</source>
          <target state="translated">Caveat</target>
        </trans-unit>
        <trans-unit id="c31bd54462bc43518a54ac972e844efe356173ba" translate="yes" xml:space="preserve">
          <source>Changes made by a subprogram to the value of an argument specified on the &lt;code&gt;USING&lt;/code&gt; clause will &amp;ldquo;be visible&amp;rdquo; to the calling program only if &lt;code&gt;BY REFERENCE&lt;/code&gt; was explicitly specified or implicitly assumed for the argument on the subprogram&amp;rsquo;s procedure division header</source>
          <target state="translated">&lt;code&gt;USING&lt;/code&gt; 절 에 지정된 인수 값에 대한 서브 프로그램의 변경 사항은 &lt;code&gt;BY REFERENCE&lt;/code&gt; 가 명시 적으로 지정되었거나 서브 프로그램의 프로 시저 분할 헤더의 인수에 대해 암시 적으로 가정 된 경우에만 호출 프로그램에 &quot;표시&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="fb48ed86295c01e223491405da96e0725331ba29" translate="yes" xml:space="preserve">
          <source>Changes made by a subprogram to the value of an argument specified on the&lt;code&gt;USING&lt;/code&gt;clause will &quot;be visible&quot; to the calling program only if&lt;code&gt;BY REFERENCE&lt;/code&gt;was explicitly specified or implicitly assumed for the argument on the subprogram&amp;rsquo;s procedure division header</source>
          <target state="translated">서브 프로그램이 &lt;code&gt;USING&lt;/code&gt; 절 에 지정된 인수 값을 변경 하면 &lt;code&gt;BY REFERENCE&lt;/code&gt; 가 서브 프로그램의 프로 시저 분할 헤더의 인수에 대해 명시 적으로 지정되거나 내재적으로 가정 된 경우에만 호출 프로그램에 &quot;표시됩니다&quot;</target>
        </trans-unit>
        <trans-unit id="f61e9aefa37a7365181d1fa0b629667eb50199ce" translate="yes" xml:space="preserve">
          <source>Changing the currency symbol via the &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) paragraph&amp;rsquo;s &lt;code&gt;CURRENCY SYMBOL&lt;/code&gt; setting will</source>
          <target state="translated">&lt;code&gt;SPECIAL-NAMES&lt;/code&gt; ( &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 참조 ) 단락의 &lt;code&gt;CURRENCY SYMBOL&lt;/code&gt; 설정을 통해 통화 기호를 변경 하면</target>
        </trans-unit>
        <trans-unit id="678f855b53417fc91a2994a62e401b38bf2f483b" translate="yes" xml:space="preserve">
          <source>Changing the currency symbol via the &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; paragraph&amp;rsquo;s &lt;code&gt;CURRENCY SYMBOL&lt;/code&gt; setting will not affect the value returned by this function.</source>
          <target state="translated">&lt;code&gt;SPECIAL-NAMES&lt;/code&gt; 단락의 &lt;code&gt;CURRENCY SYMBOL&lt;/code&gt; 설정을 통해 통화 기호를 변경 해도이 함수가 반환하는 값에는 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1cf367703f62db4730492b29e986ff87aabe8968" translate="yes" xml:space="preserve">
          <source>Changing the currency symbol via the&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) paragraph&amp;rsquo;s&lt;code&gt;CURRENCY SYMBOL&lt;/code&gt;setting will</source>
          <target state="translated">&lt;code&gt;SPECIAL-NAMES&lt;/code&gt; ( &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt; 참조 ) 단락의 &lt;code&gt;CURRENCY SYMBOL&lt;/code&gt; 설정을 통해 통화 기호를 변경 하면</target>
        </trans-unit>
        <trans-unit id="3290313e1574c3d689ba9eb70ce2b545abfe41ec" translate="yes" xml:space="preserve">
          <source>Changing the current directory</source>
          <target state="translated">현재 디렉토리 변경</target>
        </trans-unit>
        <trans-unit id="6dd47dabb9df79c85d4c9bbf8e536ca75ef3576e" translate="yes" xml:space="preserve">
          <source>Character positions in this list do not affect the actual binary storage values used for the characters &amp;mdash; binary values will still be those of the&lt;code&gt;NATIVE&lt;/code&gt;character set.</source>
          <target state="translated">이 목록의 문자 위치는 문자에 사용 된 실제 이진 저장 값에 영향을 미치지 않습니다. 이진 값은 여전히 &lt;code&gt;NATIVE&lt;/code&gt; 문자 집합의 값입니다.</target>
        </trans-unit>
        <trans-unit id="c97e2e5b4b78422a55a87f515002b13b1f68e3fd" translate="yes" xml:space="preserve">
          <source>Character positions in this list do not affect the actual binary storage values used for the characters. Binary values will still be those of the &lt;code&gt;NATIVE&lt;/code&gt; character set.</source>
          <target state="translated">이 목록의 문자 위치는 문자에 사용되는 실제 2 진 저장 값에 영향을주지 않습니다. 이진 값은 여전히 &lt;code&gt;NATIVE&lt;/code&gt; 문자 집합 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="b6f59f08fd6d58c6725e21a9ec24e068148ec586" translate="yes" xml:space="preserve">
          <source>Characters</source>
          <target state="translated">Characters</target>
        </trans-unit>
        <trans-unit id="e9a243cc115ca2c9d82457002477fb2c95c7cc98" translate="yes" xml:space="preserve">
          <source>Class conditions evaluate the type of data that is currently stored in a data item.</source>
          <target state="translated">클래스 조건은 현재 데이터 항목에 저장된 데이터 유형을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="06ba9f8b51464a92c09ba8adb0428ae07c0698c2" translate="yes" xml:space="preserve">
          <source>Class-Condition Syntax</source>
          <target state="translated">클래스 조건 구문</target>
        </trans-unit>
        <trans-unit id="6dcfeb045a3fd680afc99e0a6405f85f4b06bc0e" translate="yes" xml:space="preserve">
          <source>Class-Definition-Clause</source>
          <target state="translated">Class-Definition-Clause</target>
        </trans-unit>
        <trans-unit id="88225646933261b2af20b61cd0a15701c0f8d989" translate="yes" xml:space="preserve">
          <source>Clearly, even a non-programmer could at least conceptually understand what was going on! Over time, languages like FORTRAN evolved more robust variable names, and COBOL introduced a more formula-based syntactical capability for arithmetic operations, but FORTRAN was never as readable as COBOL.</source>
          <target state="translated">분명히 프로그래머가 아닌 사람조차도 적어도 무슨 일이 있었는지 개념적으로 이해할 수있었습니다! 시간이 지남에 따라 FORTRAN과 같은 언어는보다 강력한 변수 이름을 발전 시켰으며 COBOL은 산술 연산을위한보다 공식 기반의 구문 기능을 도입했지만 FORTRAN은 COBOL만큼 읽을 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="732a5387092d26a94fef7e2ce8d5d9519c238b19" translate="yes" xml:space="preserve">
          <source>Closed with lock</source>
          <target state="translated">자물쇠로 마감</target>
        </trans-unit>
        <trans-unit id="3e7b28f577b1b916299b12ea5b8e92a3ed9e96c3" translate="yes" xml:space="preserve">
          <source>Cobol programs consist of a sequence of words and symbols. Words, which consist of sequences of letters (upper- and/or lower-case), digits, dashes (&amp;lsquo;</source>
          <target state="translated">Cobol 프로그램은 일련의 단어와 기호로 구성됩니다. 일련의 문자 (대문자 및 / 또는 소문자), 숫자, 대시 ( ')로 구성된 단어</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="594422a8373a45016503112a0d76d479ebc2de36" translate="yes" xml:space="preserve">
          <source>Collating Sequence</source>
          <target state="translated">조합 순서</target>
        </trans-unit>
        <trans-unit id="1d0c8304baedcf8e3a78982c2e7c0b04622bf2a0" translate="yes" xml:space="preserve">
          <source>Color</source>
          <target state="translated">Color</target>
        </trans-unit>
        <trans-unit id="5ff247b294c4c4680923f6b83955ad2dd9bcc50b" translate="yes" xml:space="preserve">
          <source>Colors may also be specified using a numeric non-edited identifier whose value is in the range 0-7.</source>
          <target state="translated">색상은 값이 0-7 범위 인 편집되지 않은 숫자로 된 식별자를 사용하여 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a03f9752614a149f260012e412a1b73ed0200eb0" translate="yes" xml:space="preserve">
          <source>Column 7 serves as an indicator in which one of five possible values will appear &amp;mdash; space, &lt;code&gt;D&lt;/code&gt; (or &lt;code&gt;d&lt;/code&gt;), &lt;code&gt;-&lt;/code&gt; (dash), &lt;code&gt;/&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;. The meanings of these characters are as follows:</source>
          <target state="translated">7 열은 공백, &lt;code&gt;D&lt;/code&gt; (또는 &lt;code&gt;d&lt;/code&gt; ), &lt;code&gt;-&lt;/code&gt; (대시), &lt;code&gt;/&lt;/code&gt; 또는 &lt;code&gt;*&lt;/code&gt; 등 5 가지 가능한 값 중 하나가 표시되는 표시기 역할을합니다 . 이러한 문자의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3da9b0a1bd95ee2ff92f0876a9bc1660e1b7f92d" translate="yes" xml:space="preserve">
          <source>Column 7 serves as an indicator in which one of five possible values will appear &amp;mdash; space,&lt;code&gt;D&lt;/code&gt;(or&lt;code&gt;d&lt;/code&gt;,&lt;code&gt;-&lt;/code&gt;(dash),&lt;code&gt;/&lt;/code&gt;or&lt;code&gt;*&lt;/code&gt; The meanings of these characters are as follows:</source>
          <target state="translated">7 열은 공백, &lt;code&gt;D&lt;/code&gt; (또는 &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; (대시) 또는 &lt;code&gt;/&lt;/code&gt; 또는 &lt;code&gt;*&lt;/code&gt; ) 의 5 가지 값 중 하나가 나타나는 표시기 역할을합니다. 이러한 문자의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f92afaa3e8bfcd3ea4fa0e30b81b8a7e79d9e878" translate="yes" xml:space="preserve">
          <source>Column headings describing the fields within the detail group(s)</source>
          <target state="translated">세부 사항 그룹 내의 필드를 설명하는 열 표제</target>
        </trans-unit>
        <trans-unit id="ef3b24c82e2e70a56915cb2e013177a3e224de2a" translate="yes" xml:space="preserve">
          <source>Combined Condition Syntax</source>
          <target state="translated">결합 된 조건 구문</target>
        </trans-unit>
        <trans-unit id="11bac06e449288d8a0080c4c6a977a78a032bea7" translate="yes" xml:space="preserve">
          <source>Comment Type</source>
          <target state="translated">댓글 유형</target>
        </trans-unit>
        <trans-unit id="94ef186c06d95cc1077474be4d410b632a210905" translate="yes" xml:space="preserve">
          <source>Comments that may be treated as code, typically for debugging purposes</source>
          <target state="translated">일반적으로 디버깅 목적으로 코드로 취급 될 수있는 주석</target>
        </trans-unit>
        <trans-unit id="2fd8ee31128a27c3741cf64157f9abf402269ba4" translate="yes" xml:space="preserve">
          <source>Compatible Binary Integer</source>
          <target state="translated">호환되는 이진 정수</target>
        </trans-unit>
        <trans-unit id="da8cf05ee405cd9a986668c8c46c9a8e120fd720" translate="yes" xml:space="preserve">
          <source>Compilation Group</source>
          <target state="translated">편집 그룹</target>
        </trans-unit>
        <trans-unit id="96cd345d12b5b7ca5ae139bb77e1a9c53007e491" translate="yes" xml:space="preserve">
          <source>Compilation Unit</source>
          <target state="translated">컴파일 유닛</target>
        </trans-unit>
        <trans-unit id="ee44cd6d5372fc490db806331bcc272c21b33e64" translate="yes" xml:space="preserve">
          <source>Compilations may be performed to generate dynamically-loadable modules (or dynamically-loadable libraries, as they are frequently called). These compilations are performed by using the</source>
          <target state="translated">컴파일은 동적으로로드 가능한 모듈 (또는 자주 호출되는 동적로드 가능한 라이브러리)을 생성하기 위해 수행 될 수 있습니다. 이러한 컴파일은</target>
        </trans-unit>
        <trans-unit id="e859ddacb886ecaac3920b7f115299577527697c" translate="yes" xml:space="preserve">
          <source>Compilations may be performed to generate dynamically-loadable modules (or dynamically-loadable libraries, as they are frequently called). These compilations are performed by using the&lt;code&gt;-m&lt;/code&gt;switch</source>
          <target state="translated">동적으로로드 가능한 모듈 (또는 자주 호출되는 동적으로로드 가능한 라이브러리)을 생성하기 위해 컴파일이 수행 될 수 있습니다. 이러한 컴파일은 &lt;code&gt;-m&lt;/code&gt; 스위치 를 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c27883a2a29651bc6269791ecb4e4a6de53939f0" translate="yes" xml:space="preserve">
          <source>Compile this program as follows (the assumption is made that you are executing the &lt;code&gt;cobc&lt;/code&gt; command from the directory in which the above program source code (subvsindex.cbl) exists.</source>
          <target state="translated">이 프로그램을 다음과 같이 컴파일합니다 ( 위 프로그램 소스 코드 (subvsindex.cbl)가있는 디렉토리에서 &lt;code&gt;cobc&lt;/code&gt; 명령을 실행한다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="6218c92ed166d6dee1c3823d57775cd989a17afa" translate="yes" xml:space="preserve">
          <source>Compile this program as follows (the assumption is made that you are executing the&lt;code&gt;cobc&lt;/code&gt;command from the directory in which the above program source code (subvsindex.cbl) exists.</source>
          <target state="translated">이 프로그램을 다음과 같이 컴파일하십시오 ( 위의 프로그램 소스 코드 (subvsindex.cbl)가 존재하는 디렉토리에서 &lt;code&gt;cobc&lt;/code&gt; 명령을 실행한다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="c4e180aae5f5ffed0f5284c8c7daee050f8017a2" translate="yes" xml:space="preserve">
          <source>Compiler directives are</source>
          <target state="translated">컴파일러 지시문은</target>
        </trans-unit>
        <trans-unit id="746fe304b6da04f2948db99dc5a6735e74cebf7a" translate="yes" xml:space="preserve">
          <source>Complete GnuCOBOL Program Syntax</source>
          <target state="translated">완전한 GnuCOBOL 프로그램 구문</target>
        </trans-unit>
        <trans-unit id="e0f7f8b906be02847bd6c0bc57ead1c617c67102" translate="yes" xml:space="preserve">
          <source>Complex-Syntax-Clause</source>
          <target state="translated">Complex-Syntax-Clause</target>
        </trans-unit>
        <trans-unit id="7b6d3f0a4b7700d70eab7d3bfc0cf5ce99830923" translate="yes" xml:space="preserve">
          <source>Computer scientists will compare the two techniques implemented by the &lt;code&gt;SEARCH&lt;/code&gt; and &lt;code&gt;SEARCH ALL&lt;/code&gt; statements as follows:</source>
          <target state="translated">컴퓨터 과학자는 &lt;code&gt;SEARCH&lt;/code&gt; 및 &lt;code&gt;SEARCH ALL&lt;/code&gt; 문으로 구현 된 두 가지 기술 을 다음과 같이 비교합니다.</target>
        </trans-unit>
        <trans-unit id="8e66b8e5477316fe83d734c891de408f9f788241" translate="yes" xml:space="preserve">
          <source>Computer scientists will compare the two techniques implemented by the&lt;code&gt;SEARCH&lt;/code&gt;and&lt;code&gt;SEARCH ALL&lt;/code&gt;statements as follows:</source>
          <target state="translated">컴퓨터 과학자는 &lt;code&gt;SEARCH&lt;/code&gt; 및 &lt;code&gt;SEARCH ALL&lt;/code&gt; 문으로 구현 된 두 가지 기술 을 다음과 같이 비교합니다.</target>
        </trans-unit>
        <trans-unit id="f91f22436d30f1bdac4eaf08c14dfe256b5c5193" translate="yes" xml:space="preserve">
          <source>Computes and returns the base 10 logarithm of &lt;var&gt;number&lt;/var&gt; (a numeric literal or data item).</source>
          <target state="translated">계산하여 반환의베이스 (10) 로그 &lt;var&gt;number&lt;/var&gt; (숫자 나 문자 데이터 항목).</target>
        </trans-unit>
        <trans-unit id="4691047b3448d97e560b5338ee30e62c3fe3b018" translate="yes" xml:space="preserve">
          <source>Computes and returns the natural logarithm (base</source>
          <target state="translated">자연 로그 (밑</target>
        </trans-unit>
        <trans-unit id="aa04e46eb1b113b087b3851e223aedd60a2a55a5" translate="yes" xml:space="preserve">
          <source>Computes and returns the value of 10 raised to the power specified by &lt;var&gt;number&lt;/var&gt; (a numeric literal or data item).</source>
          <target state="translated">&lt;var&gt;number&lt;/var&gt; (숫자 리터럴 또는 데이터 항목)로 지정된 거듭 제곱으로 제곱 한 값을 계산하고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cd64c6c2aa2b7724043a20f3696e0128eff17642" translate="yes" xml:space="preserve">
          <source>Computes and returns the value of the mathematical constant</source>
          <target state="translated">수학 상수의 값을 계산하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1af62c2b68c3eb29ff07e6773d513d394791b6d1" translate="yes" xml:space="preserve">
          <source>Concatenate two or more strings</source>
          <target state="translated">두 개 이상의 문자열 연결</target>
        </trans-unit>
        <trans-unit id="615d6ac378b703a386d796090691259a39659479" translate="yes" xml:space="preserve">
          <source>Condition names are Boolean (</source>
          <target state="translated">조건 이름은 부울 (</target>
        </trans-unit>
        <trans-unit id="333d34a78170ebdea1656c8398a11eab37b54584" translate="yes" xml:space="preserve">
          <source>Condition names are Boolean (i.e. TRUE / FALSE) data items that receive their TRUE and FALSE values based upon the values of the non 88-level data item whose definition they immediately follow.</source>
          <target state="translated">조건 이름은 정의가 바로 따르는 88 레벨이 아닌 데이터 항목의 값을 기반으로 TRUE 및 FALSE 값을받는 부울 (예 : TRUE / FALSE) 데이터 항목입니다.</target>
        </trans-unit>
        <trans-unit id="89151d00261c073f9243c411408f27c262aac1b5" translate="yes" xml:space="preserve">
          <source>Condition names are always defined subordinate to another (non 88-level) data item. That data item must be an elementary item. Whenever the parent data item assumes one of the values specified on the 88-level item&amp;rsquo;s &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause, &lt;var&gt;condition-name-1&lt;/var&gt; will take on the value of &lt;code&gt;TRUE&lt;/code&gt;.</source>
          <target state="translated">조건 이름은 항상 다른 (88 수준이 아닌) 데이터 항목에 종속되어 정의됩니다. 해당 데이터 항목은 기본 항목이어야합니다. 상위 데이터 항목이 88 레벨 항목의 &lt;code&gt;VALUE&lt;/code&gt; ( &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt; 참조 ) 절 에 지정된 값 중 하나를 가정 할 때마다 &lt;var&gt;condition-name-1&lt;/var&gt; 은 &lt;code&gt;TRUE&lt;/code&gt; 값을 취 합니다 .</target>
        </trans-unit>
        <trans-unit id="c87464dfce9a9aff3851d0944fefb1558383352f" translate="yes" xml:space="preserve">
          <source>Condition names are always defined subordinate to another (non 88-level) data item. That data item must be an elementary item. Whenever the parent data item assumes one of the values specified on the 88-level item&amp;rsquo;s&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause, &amp;lt;</source>
          <target state="translated">조건 이름은 항상 다른 (88 수준이 아닌) 데이터 항목에 종속적으로 정의됩니다. 해당 데이터 항목은 기본 항목이어야합니다. 상위 데이터 항목이 88 수준 항목의 &lt;code&gt;VALUE&lt;/code&gt; ( &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt; 참조 ) 절에 지정된 값 중 하나를 가정 할 때마다 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="027a11b37533ca20669bb17281d210c5767e61eb" translate="yes" xml:space="preserve">
          <source>Condition names do not occupy any storage.</source>
          <target state="translated">조건 이름은 스토리지를 차지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87c70d1eb416499e14f1ef27cbb2bafdd783e379" translate="yes" xml:space="preserve">
          <source>Conditional expressions are expressions which identify the circumstances under which a program may take an action or cease taking an action. As such, conditional expressions produce a value of &lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">조건식은 프로그램이 조치를 취하거나 조치를 중단 할 수있는 상황을 식별하는 표현식입니다. 따라서 조건식은 &lt;code&gt;TRUE&lt;/code&gt; 또는 &lt;code&gt;FALSE&lt;/code&gt; 값을 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="300654fa157f6c6e091010b7777c8e3f6af9ccc2" translate="yes" xml:space="preserve">
          <source>Conflicting attribute</source>
          <target state="translated">충돌하는 속성</target>
        </trans-unit>
        <trans-unit id="bd243da61bc83e255c691b0eeb1676f5cf315d17" translate="yes" xml:space="preserve">
          <source>Consider</source>
          <target state="translated">Consider</target>
        </trans-unit>
        <trans-unit id="fdb2d9eaefe67e778b752e4f472db4c9da926388" translate="yes" xml:space="preserve">
          <source>Consider including a trailing descriptor of the nature of all data items in their names. The following chart presents a variety of such descriptors the author has encountered and used through the years.</source>
          <target state="translated">이름에 모든 데이터 항목의 특성에 대한 후미 설명자를 포함시키는 것을 고려하십시오. 다음 차트는 저자가 여러 해 동안 접해 왔던 다양한 설명자를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="49ad35a272291924fe1567effd78bef2707d1787" translate="yes" xml:space="preserve">
          <source>Consider including an acronym to be inserted into the name of any data item defined directly or indirectly subordinate to an 01-level item, typically to be specified after any section-level tag, if you&amp;rsquo;re using them. For example, consider the names used in the following structure:</source>
          <target state="translated">01 레벨 항목에 직간접 적으로 정의 된 데이터 항목의 이름에 약어를 포함하는 것을 고려하십시오 (일반적으로 섹션 레벨 태그를 사용하는 경우). 예를 들어, 다음 구조에서 사용 된 이름을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3111a113fb90bb672247e425589adaeae2d968a2" translate="yes" xml:space="preserve">
          <source>Consider using &lt;code&gt;SET ENVIRONMENT&lt;/code&gt; (see &lt;a href=&quot;#SET-ENVIRONMENT&quot;&gt;SET ENVIRONMENT&lt;/a&gt;) in lieu of &lt;code&gt;DISPLAY&lt;/code&gt; to set environment variables as it is much simpler.</source>
          <target state="translated">사용을 고려 &lt;code&gt;SET ENVIRONMENT&lt;/code&gt; 합니다 ( &lt;a href=&quot;#SET-ENVIRONMENT&quot;&gt;SET 환경을&lt;/a&gt; 대신) &lt;code&gt;DISPLAY&lt;/code&gt; 가 훨씬 간단로 설정 환경 변수.</target>
        </trans-unit>
        <trans-unit id="474092c4530711a5712f2088d0c7006e1c6ea236" translate="yes" xml:space="preserve">
          <source>Consider using&lt;code&gt;SET ENVIRONMENT&lt;/code&gt;(see &lt;a href=&quot;#SET-ENVIRONMENT&quot;&gt;SET ENVIRONMENT&lt;/a&gt;) in lieu of&lt;code&gt;DISPLAY&lt;/code&gt;to set environment variables as it is much simpler.</source>
          <target state="translated">사용을 고려 &lt;code&gt;SET ENVIRONMENT&lt;/code&gt; 합니다 ( &lt;a href=&quot;#SET-ENVIRONMENT&quot;&gt;SET 환경을&lt;/a&gt; 대신) &lt;code&gt;DISPLAY&lt;/code&gt; 가 훨씬 간단로 설정 환경 변수.</target>
        </trans-unit>
        <trans-unit id="cd60aa178f4b05c8b4e18662c70566d29b29c05b" translate="yes" xml:space="preserve">
          <source>Console output when run (user input follows the colons on the prompts for input):</source>
          <target state="translated">실행시 콘솔 출력 (사용자 입력은 입력 프롬프트에서 콜론을 따릅니다) :</target>
        </trans-unit>
        <trans-unit id="96c096a812a6aebfa49142bbdbe0db4a5434e650" translate="yes" xml:space="preserve">
          <source>Constants defined in this way become undefined once an &lt;code&gt;END PROGRAM&lt;/code&gt; or &lt;code&gt;END FUNCTION&lt;/code&gt; is encountered in the input source.</source>
          <target state="translated">이러한 방식으로 정의 된 상수 는 입력 소스에서 &lt;code&gt;END PROGRAM&lt;/code&gt; 또는 &lt;code&gt;END FUNCTION&lt;/code&gt; 이 발견 되면 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="482dcfb6a26e7cc8dbfee8b9c6882a08cb82b778" translate="yes" xml:space="preserve">
          <source>Constants defined in this way become undefined once an&lt;code&gt;END PROGRAM&lt;/code&gt;or&lt;code&gt;END FUNCTION&lt;/code&gt;is encountered in the input source.</source>
          <target state="translated">이 방법으로 정의 된 상수 는 입력 소스에서 &lt;code&gt;END PROGRAM&lt;/code&gt; 또는 &lt;code&gt;END FUNCTION&lt;/code&gt; 이 발생 하면 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="97f677ffe8002bb978e6196b88b1b9221d3315cd" translate="yes" xml:space="preserve">
          <source>Consult the documentation on the</source>
          <target state="translated">의 설명서를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="f3ab4e8e93cadb02c8891ed067637bcc601d5d17" translate="yes" xml:space="preserve">
          <source>Consult the documentation on the   &lt;code&gt;COB_PRE_LOAD&lt;/code&gt; run-time environment variable,   &lt;code&gt;COB_PHYSICAL_CANCEL&lt;/code&gt; run-time environment variable and   &lt;code&gt;COB_LOAD_CASE&lt;/code&gt; run-time environment variable run-time environment variables (see &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;Run Time Environment Variables&lt;/a&gt;) for additional options when using dynamically-loadable modules.</source>
          <target state="translated">동적으로로드 가능한 모듈을 사용할 때 추가 옵션 은 &lt;code&gt;COB_PRE_LOAD&lt;/code&gt; 런타임 환경 변수, &lt;code&gt;COB_PHYSICAL_CANCEL&lt;/code&gt; 런타임 환경 변수 및 &lt;code&gt;COB_LOAD_CASE&lt;/code&gt; 런타임 환경 변수 런타임 환경 변수 ( &lt;a href=&quot;#Run-Time-Environment-Variables&quot;&gt;런타임&lt;/a&gt; 환경 변수 참조 )에 대한 설명서를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="aece2a78e16b7c77ba476b001a3e284cd35e2b2c" translate="yes" xml:space="preserve">
          <source>Contain a leading numeric component (for example: &lt;code&gt;2000-Update-Customer&lt;/code&gt;), AND&amp;hellip;</source>
          <target state="translated">선행 숫자 구성 요소 (예 : &lt;code&gt;2000-Update-Customer&lt;/code&gt; )를 포함하고, 그리고&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="ee9d7834b4e03028e401f780d9d177af07cb943c" translate="yes" xml:space="preserve">
          <source>Contain a leading numeric component (for example:&lt;code&gt;2000-Update-Customer&lt;/code&gt;, AND&amp;hellip;</source>
          <target state="translated">선행 숫자 구성 요소를 포함합니다 (예 : &lt;code&gt;2000-Update-Customer&lt;/code&gt; , AND&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="d504f89e29051ac2c61a4e1307b823272b01fbfa" translate="yes" xml:space="preserve">
          <source>Contained Subprograms</source>
          <target state="translated">포함 된 서브 프로그램</target>
        </trans-unit>
        <trans-unit id="bfd6778fd4ac82c10d85f3d0a68e06cc492e0593" translate="yes" xml:space="preserve">
          <source>Contrast this function with the &lt;code&gt;BYTE-LENGTH&lt;/code&gt; (see &lt;a href=&quot;#BYTE_002dLENGTH&quot;&gt;BYTE-LENGTH&lt;/a&gt;) and &lt;code&gt;LENGTH-AN&lt;/code&gt; (see &lt;a href=&quot;#LENGTH_002dAN&quot;&gt;LENGTH-AN&lt;/a&gt;) functions.</source>
          <target state="translated">이 함수 대조 &lt;code&gt;BYTE-LENGTH&lt;/code&gt; (참조 &lt;a href=&quot;#BYTE_002dLENGTH&quot;&gt;BYTE 길이&lt;/a&gt; 등) &lt;code&gt;LENGTH-AN&lt;/code&gt; (참조 &lt;a href=&quot;#LENGTH_002dAN&quot;&gt;길이&lt;/a&gt; 기능).</target>
        </trans-unit>
        <trans-unit id="32b3d87c6ceda12546f190f2210a22df0cdf6e15" translate="yes" xml:space="preserve">
          <source>Contrast this function with the&lt;code&gt;BYTE-LENGTH&lt;/code&gt;(see &lt;a href=&quot;#BYTE_002dLENGTH&quot;&gt;BYTE-LENGTH&lt;/a&gt;) and&lt;code&gt;LENGTH-AN&lt;/code&gt;(see &lt;a href=&quot;#LENGTH_002dAN&quot;&gt;LENGTH-AN&lt;/a&gt;) functions.</source>
          <target state="translated">이 함수 대조 &lt;code&gt;BYTE-LENGTH&lt;/code&gt; (참조 &lt;a href=&quot;#BYTE_002dLENGTH&quot;&gt;BYTE 길이&lt;/a&gt; 등) &lt;code&gt;LENGTH-AN&lt;/code&gt; (참조 &lt;a href=&quot;#LENGTH_002dAN&quot;&gt;길이&lt;/a&gt; 기능).</target>
        </trans-unit>
        <trans-unit id="a7e40a5d58b3551418cee9da955b4b9a215b32d2" translate="yes" xml:space="preserve">
          <source>Contrast this with the &lt;code&gt;LENGTH&lt;/code&gt; (see &lt;a href=&quot;#LENGTH&quot;&gt;LENGTH&lt;/a&gt;) function.</source>
          <target state="translated">이것을 &lt;code&gt;LENGTH&lt;/code&gt; ( &lt;a href=&quot;#LENGTH&quot;&gt;LENGTH&lt;/a&gt; 참조 ) 함수 와 대조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c13b5b85342bf60c0e7b3cad62d98a00d84bed25" translate="yes" xml:space="preserve">
          <source>Contrast this with the&lt;code&gt;LENGTH&lt;/code&gt;(see &lt;a href=&quot;#LENGTH&quot;&gt;LENGTH&lt;/a&gt;) function.</source>
          <target state="translated">이것을 &lt;code&gt;LENGTH&lt;/code&gt; ( &lt;a href=&quot;#LENGTH&quot;&gt;LENGTH&lt;/a&gt; 참조 ) 함수 와 대조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d864d1d594bb58da63124b3e532077a2280da211" translate="yes" xml:space="preserve">
          <source>Control Break</source>
          <target state="translated">컨트롤 브레이크</target>
        </trans-unit>
        <trans-unit id="e707dbac72bfee188a71125817eb3d24f8da1780" translate="yes" xml:space="preserve">
          <source>Control Field</source>
          <target state="translated">컨트롤 필드</target>
        </trans-unit>
        <trans-unit id="960257afeb12f77fa6f8f055108e92a370b0072a" translate="yes" xml:space="preserve">
          <source>Control Footing</source>
          <target state="translated">기초 조정</target>
        </trans-unit>
        <trans-unit id="b37055601ddd24b634819c08af5e0ee3aec0c2f5" translate="yes" xml:space="preserve">
          <source>Control Heading</source>
          <target state="translated">제어 제목</target>
        </trans-unit>
        <trans-unit id="3089ab53c60beb89e389be8470443c8bae92e074" translate="yes" xml:space="preserve">
          <source>Control Hierarchy</source>
          <target state="translated">제어 계층</target>
        </trans-unit>
        <trans-unit id="1bef2ffd2d898c95784379f9d8d159b85d5b9c39" translate="yes" xml:space="preserve">
          <source>Control will return back to the&lt;code&gt;PERFORM&lt;/code&gt; where &amp;mdash; if&lt;code&gt;WITH TEST AFTER&lt;/code&gt;was specified &amp;mdash; &amp;lt;</source>
          <target state="translated">&lt;code&gt;WITH TEST AFTER&lt;/code&gt; 가 지정된 경우 제어는 &lt;code&gt;PERFORM&lt;/code&gt; 으로 되돌아갑니다. &amp;lt;</target>
        </trans-unit>
        <trans-unit id="2f813658dc69bc55b7f2ce4bbc17a2a51345df0a" translate="yes" xml:space="preserve">
          <source>Control will then proceed to the statement following the &lt;code&gt;END-EVALUATE&lt;/code&gt; or the first statement that follows the next period if there is no &lt;code&gt;END-EVALUATE&lt;/code&gt;. If,however, the &lt;var&gt;imperative-statement-other&lt;/var&gt; included a &lt;code&gt;GO TO&lt;/code&gt; statement, and that &lt;code&gt;GO TO&lt;/code&gt; was executed, then control will transfer to the procedure named on the &lt;code&gt;GO TO&lt;/code&gt; instead.</source>
          <target state="translated">컨트롤은 다음 문으로 진행됩니다 &lt;code&gt;END-EVALUATE&lt;/code&gt; 없거나 존재하지 않는 경우 다음 기간을 다음 첫 번째 문 &lt;code&gt;END-EVALUATE&lt;/code&gt; . 그러나 &lt;var&gt;imperative-statement-other&lt;/var&gt; 에 &lt;code&gt;GO TO&lt;/code&gt; 문이 포함되어 있고 해당 &lt;code&gt;GO TO&lt;/code&gt; 가 실행 된 경우 제어는 대신 &lt;code&gt;GO TO&lt;/code&gt; 에 명명 된 프로 시저로 전송 됩니다.</target>
        </trans-unit>
        <trans-unit id="6b631a4ffc81ee3a9a3caa199af3dfcb4b9eebb2" translate="yes" xml:space="preserve">
          <source>Control will then proceed to the statement following the&lt;code&gt;END-EVALUATE&lt;/code&gt;or the first statement that follows the next period if there is no&lt;code&gt;END-EVALUATE&lt;/code&gt; If,however, the &amp;lt;</source>
          <target state="translated">제어는 다음 문으로 진행됩니다 &lt;code&gt;END-EVALUATE&lt;/code&gt; 더가없는 경우에는 다음 기간을 다음 첫 번째 문 &lt;code&gt;END-EVALUATE&lt;/code&gt; 경우에는, 그러나, &amp;lt;</target>
        </trans-unit>
        <trans-unit id="6821ab076fc8e4c97eea6b8244b17e70476d24ee" translate="yes" xml:space="preserve">
          <source>Controlling the pagination of reports, including:</source>
          <target state="translated">다음을 포함하여 보고서의 페이지 매김 제어</target>
        </trans-unit>
        <trans-unit id="b08eadae7bddf7f7dd80e9f64aceb10ba5a6628d" translate="yes" xml:space="preserve">
          <source>Conversion of a numeric time or date to a formatted character string</source>
          <target state="translated">숫자 시간 또는 날짜를 형식화 된 문자열로 변환</target>
        </trans-unit>
        <trans-unit id="19d9d5fc5f00a5f0448d53b676ac0c4328ba347f" translate="yes" xml:space="preserve">
          <source>Convert a binary value to its corresponding character in the program&amp;rsquo;s character set</source>
          <target state="translated">이진 값을 프로그램 문자 집합의 해당 문자로 변환</target>
        </trans-unit>
        <trans-unit id="75a17a1758817b5ddc7dcf74881e440650a52c7c" translate="yes" xml:space="preserve">
          <source>Convert a character string to lower-case</source>
          <target state="translated">문자열을 소문자로 변환</target>
        </trans-unit>
        <trans-unit id="160bf37902105bc7898b5c3f6d51408ab2a10135" translate="yes" xml:space="preserve">
          <source>Convert a character string to only printable characters</source>
          <target state="translated">문자열을 인쇄 가능한 문자로만 변환</target>
        </trans-unit>
        <trans-unit id="1da23cf598b2a0f519db492fae32d913e3bdb127" translate="yes" xml:space="preserve">
          <source>Convert a character string to upper-case</source>
          <target state="translated">문자열을 대문자로 변환</target>
        </trans-unit>
        <trans-unit id="61e41cbc63c504ad81ab6c2bd36aa274a7b3167d" translate="yes" xml:space="preserve">
          <source>Convert a character to its numeric value in the program&amp;rsquo;s character set</source>
          <target state="translated">문자를 프로그램 문자 집합의 숫자 값으로 변환</target>
        </trans-unit>
        <trans-unit id="1dba2ae50d005d2e3eb8ef0eaeba495d4e1d4209" translate="yes" xml:space="preserve">
          <source>Converts the eight-digit Gregorian &lt;var&gt;date&lt;/var&gt; (a numeric integer data item or literal) from yyyymmdd format to the format appropriate to the current locale. On a Windows system, this will be the &amp;ldquo;short date&amp;rdquo; format as set using Control Panel.</source>
          <target state="translated">8 자리 그레고리 안 &lt;var&gt;date&lt;/var&gt; (숫자 정수 데이터 항목 또는 리터럴)를 yyyymmdd 형식에서 현재 로케일에 적합한 형식으로 변환합니다. Windows 시스템에서는 제어판을 사용하여 설정 한 &quot;짧은 날짜&quot;형식입니다.</target>
        </trans-unit>
        <trans-unit id="a3a0ab9e2ac8dad5ac8957d3acd06f7b1400fe00" translate="yes" xml:space="preserve">
          <source>Converts the four- (hhmm) or six-digit (hhmmss) &lt;var&gt;time&lt;/var&gt; (a numeric integer data item or literal) to a format appropriate to the current locale. On a Windows system, this will be the &amp;ldquo;time&amp;rdquo; format as set using Control Panel.</source>
          <target state="translated">4 자리 (hhmm) 또는 6 자리 (hhmmss) &lt;var&gt;time&lt;/var&gt; (숫자 정수 데이터 항목 또는 리터럴)을 현재 로케일에 적합한 형식으로 변환합니다. Windows 시스템에서는 제어판을 사용하여 설정 한 &quot;시간&quot;형식입니다.</target>
        </trans-unit>
        <trans-unit id="f548344bd9aadae14bab2f0dba4aebd5f4bcb825" translate="yes" xml:space="preserve">
          <source>Converts the number of &lt;var&gt;seconds&lt;/var&gt; since midnight (a numeric integer data item or literal) to a format appropriate to the current locale. On a Windows system, this will be the &amp;ldquo;time&amp;rdquo; format as set using Control Panel.</source>
          <target state="translated">수 변환 &lt;var&gt;seconds&lt;/var&gt; 현재의 지역에 적합한 포맷으로 시부 (숫자 정수 데이터 항목 또는 리터럴). Windows 시스템에서는 제어판을 사용하여 설정 한 &quot;시간&quot;형식입니다.</target>
        </trans-unit>
        <trans-unit id="7dd804bb2edf5c6b71e08057b1fe7806375aa80d" translate="yes" xml:space="preserve">
          <source>Copybook</source>
          <target state="translated">Copybook</target>
        </trans-unit>
        <trans-unit id="e2aa0e7c3bd507e669da6cc819890494774937c3" translate="yes" xml:space="preserve">
          <source>Copybooks containing code intended for the identification division. These will be rare as you almost never encounter copied code in the identification division.</source>
          <target state="translated">식별 부서 용 코드가 포함 된 카피 북 식별 부서에서 복사 된 코드가 거의 발생하지 않기 때문에 이러한 경우는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="b6cb73f8aab879264878f9d5268c50dc15b63de2" translate="yes" xml:space="preserve">
          <source>Copybooks containing code intended for use in the environment division. These copybooks are generally used for predefined &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; (see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) or &lt;code&gt;FILE-CONTROL&lt;/code&gt; (see &lt;a href=&quot;#INPUT_002dOUTPUT-SECTION&quot;&gt;INPUT-OUTPUT SECTION&lt;/a&gt;) syntax,</source>
          <target state="translated">환경 부서에서 사용하기위한 코드가 포함 된 카피 북. 이러한 카피 북은 일반적으로 사전 정의 된 사용되는 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; (참조 &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL - 이름&lt;/a&gt; 또는) &lt;code&gt;FILE-CONTROL&lt;/code&gt; 는 (참조 &lt;a href=&quot;#INPUT_002dOUTPUT-SECTION&quot;&gt;입출력 SECTION&lt;/a&gt; , 구문)</target>
        </trans-unit>
        <trans-unit id="ae4bb1674f81c29f3e27ad4dcb083e8655d69118" translate="yes" xml:space="preserve">
          <source>Copybooks containing code intended for use in the environment division. These copybooks are generally used for predefined&lt;code&gt;SPECIAL-NAMES&lt;/code&gt;(see &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL-NAMES&lt;/a&gt;) or&lt;code&gt;FILE-CONTROL&lt;/code&gt;(see &lt;a href=&quot;#INPUT_002dOUTPUT-SECTION&quot;&gt;INPUT-OUTPUT SECTION&lt;/a&gt;) syntax,</source>
          <target state="translated">환경 부서에서 사용하기위한 코드가 들어있는 카피 북. 이러한 카피 북은 일반적으로 사전 정의 된 사용되는 &lt;code&gt;SPECIAL-NAMES&lt;/code&gt; (참조 &lt;a href=&quot;#SPECIAL_002dNAMES&quot;&gt;SPECIAL - 이름&lt;/a&gt; 또는) &lt;code&gt;FILE-CONTROL&lt;/code&gt; 는 (참조 &lt;a href=&quot;#INPUT_002dOUTPUT-SECTION&quot;&gt;입출력 SECTION&lt;/a&gt; , 구문)</target>
        </trans-unit>
        <trans-unit id="2518777d2abfc517966e28f0596ae3116363bcc5" translate="yes" xml:space="preserve">
          <source>Copybooks that contain data definitions.</source>
          <target state="translated">데이터 정의가 포함 된 카피 북</target>
        </trans-unit>
        <trans-unit id="752aff643f4fc290408c7437031076a71eebc79b" translate="yes" xml:space="preserve">
          <source>Copybooks that contain executable instructions.</source>
          <target state="translated">실행 가능한 지침이 포함 된 카피 북</target>
        </trans-unit>
        <trans-unit id="b6a8b5660c828f3b2c93bf54e7099762c731d4dd" translate="yes" xml:space="preserve">
          <source>Copying files</source>
          <target state="translated">파일 복사</target>
        </trans-unit>
        <trans-unit id="154784820baffd42626a2bcde20aa0381aaae095" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.</source>
          <target state="translated">저작권 &amp;copy; 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.</target>
        </trans-unit>
        <trans-unit id="cb54a4d008dbbbce9c32d6cda871fb64051a8eba" translate="yes" xml:space="preserve">
          <source>Could be abbreviated as:</source>
          <target state="translated">다음과 같이 축약 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="89ea001ccab46e56818743fe353b4dbd4f087131" translate="yes" xml:space="preserve">
          <source>Count occurrences of sub strings in a larger string</source>
          <target state="translated">더 큰 문자열에서 하위 문자열의 발생 횟수 계산</target>
        </trans-unit>
        <trans-unit id="8e7fb87ed35f3e95693d0d85ac2e5bb078a3fccb" translate="yes" xml:space="preserve">
          <source>Creating a directory</source>
          <target state="translated">디렉토리 만들기</target>
        </trans-unit>
        <trans-unit id="364920436a8c309c1b52c0fc8087c58a7ed12784" translate="yes" xml:space="preserve">
          <source>Creating, Opening, Closing, Reading and Writing byte-stream files</source>
          <target state="translated">바이트 스트림 파일 작성, 열기, 닫기, 읽기 및 쓰기</target>
        </trans-unit>
        <trans-unit id="4aa8c2406ca6f6f050ab445a1eded2c5fd854c40" translate="yes" xml:space="preserve">
          <source>Critics of COBOL frequently focus on the wordiness of the language, often citing the case of a so-called &amp;ldquo;Hello World&amp;rdquo; program as the &amp;ldquo;proof&amp;rdquo; that COBOL is so much more tedious to program in than more &amp;ldquo;modern&amp;rdquo; languages. This tedium is cited as such a significant impact to programmer productivity that, in their opinions, COBOL can&amp;rsquo;t go away quickly enough.</source>
          <target state="translated">COBOL의 비평가들은 종종 소위&amp;ldquo;Hello World&amp;rdquo;프로그램의 경우를&amp;ldquo;증거&amp;rdquo;로 인용하여 COBOL이보다&amp;ldquo;현대적인&amp;rdquo;언어로 프로그래밍하는 것보다 훨씬 더 지루하다는 사실을 언급하면서 언어의 단어성에 초점을 맞 춥니 다. 이 지루함은 프로그래머 생산성에 큰 영향을 미치므로 COBOL이 충분히 빨리 사라질 수 없다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="46ee87eda2a116ad83be4c0a9225f45f1d31eac4" translate="yes" xml:space="preserve">
          <source>Ctrl Left Dbl Click</source>
          <target state="translated">Ctrl 왼쪽 더블 클릭</target>
        </trans-unit>
        <trans-unit id="aa900b51dcf306bc11c11bbb590b88d6477fb971" translate="yes" xml:space="preserve">
          <source>Ctrl Left Pressed</source>
          <target state="translated">Ctrl 왼쪽 누름</target>
        </trans-unit>
        <trans-unit id="fb1f4ce8a945df3e7f7abdda97756f9dee831347" translate="yes" xml:space="preserve">
          <source>Ctrl Left Released</source>
          <target state="translated">Ctrl 왼쪽 해제</target>
        </trans-unit>
        <trans-unit id="774ee7df0195fc8c3e29e8e19d923b3ab51104d9" translate="yes" xml:space="preserve">
          <source>Ctrl Mid Dbl Click</source>
          <target state="translated">Ctrl 중간 Dbl 클릭</target>
        </trans-unit>
        <trans-unit id="4e09dc1495d32dac4a4ad06eeb06e60f63dbb599" translate="yes" xml:space="preserve">
          <source>Ctrl Mid Pressed</source>
          <target state="translated">Ctrl Mid 누름</target>
        </trans-unit>
        <trans-unit id="a373db519179ada9bd63ffa3f7fb3ff7454a6597" translate="yes" xml:space="preserve">
          <source>Ctrl Mid Released</source>
          <target state="translated">Ctrl 중간 해제</target>
        </trans-unit>
        <trans-unit id="738257e354f70cc1f4633fc440e0728c88b50ac2" translate="yes" xml:space="preserve">
          <source>Ctrl Move</source>
          <target state="translated">Ctrl 이동</target>
        </trans-unit>
        <trans-unit id="1ccc1603025edcdc2ab540566f0b8e7ff97b67ad" translate="yes" xml:space="preserve">
          <source>Ctrl Right Dbl Click</source>
          <target state="translated">Ctrl 오른쪽 더블 클릭</target>
        </trans-unit>
        <trans-unit id="9837de0b42bed3caf88ac2868a015a7e8a8d1cba" translate="yes" xml:space="preserve">
          <source>Ctrl Right Pressed</source>
          <target state="translated">Ctrl 오른쪽 누름</target>
        </trans-unit>
        <trans-unit id="c1a31f8f6f885d1fa7cfa25566546698c941e142" translate="yes" xml:space="preserve">
          <source>Ctrl Right Released</source>
          <target state="translated">Ctrl 오른쪽 해제</target>
        </trans-unit>
        <trans-unit id="0aea7faf497d7c8e758faaf304920bbbcf84206f" translate="yes" xml:space="preserve">
          <source>Ctrl Wheel Down</source>
          <target state="translated">Ctrl 휠 아래로</target>
        </trans-unit>
        <trans-unit id="1e802315f8a72bb3f510a9aaf4d04cb5a2a8413c" translate="yes" xml:space="preserve">
          <source>Ctrl Wheel Left</source>
          <target state="translated">Ctrl 휠 왼쪽</target>
        </trans-unit>
        <trans-unit id="c2b77c0637aefb35b4640b9ddfcbffd48ca4fccd" translate="yes" xml:space="preserve">
          <source>Ctrl Wheel Right</source>
          <target state="translated">Ctrl 휠 오른쪽</target>
        </trans-unit>
        <trans-unit id="c34fd28d165ab003ebba59bc89f0f84d110021ba" translate="yes" xml:space="preserve">
          <source>Ctrl Wheel Up</source>
          <target state="translated">Ctrl 휠 위로</target>
        </trans-unit>
        <trans-unit id="03cc92b2de6a93842702049006d74479339df02c" translate="yes" xml:space="preserve">
          <source>Current date in Gregorian form</source>
          <target state="translated">그레고리 안 형식의 현재 날짜</target>
        </trans-unit>
        <trans-unit id="1ff8e9efb80c4e62bf5d39a66f9af66f72010f2d" translate="yes" xml:space="preserve">
          <source>Current date in Julian form</source>
          <target state="translated">줄리안 형태의 현재 날짜</target>
        </trans-unit>
        <trans-unit id="cb8c3f41764642d74e599b187ee3571c5fb3c0dd" translate="yes" xml:space="preserve">
          <source>Current programming philosophy would prefer the use of the &lt;code&gt;EVALUATE&lt;/code&gt; statement to that of this form of the &lt;code&gt;GO TO&lt;/code&gt; statement.</source>
          <target state="translated">현재 프로그래밍 철학은 &lt;code&gt;GO TO&lt;/code&gt; 문 형식 보다 &lt;code&gt;EVALUATE&lt;/code&gt; 문 사용을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="38570a962a72c984faa65f99b9fe8bbed297680c" translate="yes" xml:space="preserve">
          <source>Current programming philosophy would prefer the use of the&lt;code&gt;EVALUATE&lt;/code&gt;statement to that of this form of the&lt;code&gt;GO TO&lt;/code&gt;statement.</source>
          <target state="translated">현재 프로그래밍 철학은 &lt;code&gt;EVALUATE&lt;/code&gt; 문을이 형태의 &lt;code&gt;GO TO&lt;/code&gt; 문에 사용하는 것을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="51e91e511c6d01b417d01b7b04a3c2d45ae116c0" translate="yes" xml:space="preserve">
          <source>Currently, the only allowable value for the flags argument is 0. This argument may be specified either as a numeric literal or as a &lt;code&gt;PIC X(1) USAGE COMP-X&lt;/code&gt; data item.</source>
          <target state="translated">현재 flags 인수에 허용되는 유일한 값은 0입니다.이 인수는 숫자 리터럴 또는 &lt;code&gt;PIC X(1) USAGE COMP-X&lt;/code&gt; 데이터 항목 으로 지정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="176c3c5df0bbd0c7ccd68b1562b9f4c3348a64ae" translate="yes" xml:space="preserve">
          <source>Currently, the only allowable value for the flags argument is 0. This argument may be specified either as a numeric literal or as a&lt;code&gt;PIC X(1) USAGE COMP-X&lt;/code&gt;data item.</source>
          <target state="translated">현재 flags 인수에 허용되는 유일한 값은 0입니다.이 인수는 숫자 리터럴 또는 &lt;code&gt;PIC X(1) USAGE COMP-X&lt;/code&gt; 데이터 항목 으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93fe007c4c23a7d4870c091f49c3529c51d38ef8" translate="yes" xml:space="preserve">
          <source>Cyan (Turquoise): COB-COLOR-CYAN</source>
          <target state="translated">청록색 (청록색) : COB-COLOR-CYAN</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="d2b0ee310620d9febc825ce9071e2fb5b6a37cd7" translate="yes" xml:space="preserve">
          <source>D/d</source>
          <target state="translated">D/d</target>
        </trans-unit>
        <trans-unit id="1c70179c39c919a483e3990fcff0e11a83f76d8d" translate="yes" xml:space="preserve">
          <source>DASHED, DATA-COLUMNS, DATA-POINTER, DATA-TYPES, DATA, DATE-COMPILED, DATE-ENTRY, DATE-MODIFIED, DATE-OF-INTEGER, DATE-TO-YYYYMMDD, DATE-WRITTEN, DATE, DAY-OF-INTEGER, DAY-OF-WEEK, DAY-TO-YYYYDDD, DAY, DEBUGGING, DEBUG-ITEM, DECIMAL-POINT, DECLARATIVES, DEFAULT-BUTTON, DEFAULT-FONT, DEFAULT, DELETE, DELIMITED, DELIMITER, DEPENDING, DESCENDING, DESTINATION, DESTROY, DETAIL, DE, DISABLE, DISC, DISK, DISPLAY-COLUMNS, DISPLAY-FORMAT, DISPLAY-OF, DISPLAY, DIVIDER-COLOR, DIVIDERS, DIVIDE, DIVISION, DOTDASH, DOTTED, DOUBLE, DOWN, DRAG-COLOR, DROP-DOWN, DROP-LIST, DUPLICATES, DYNAMIC</source>
          <target state="translated">DASHED, DATA-COLUMNS, DATA-POINTER, DATA-TYPES, DATA, DATE-COMPILED, DATE-ENTRY, DATE-MODIFIED, DATE-OF-INTEGER, DATE-TO-YYYYMMDD, DATE-WRITTEN, DATE, DAY-OF- INTEGER, DAY-OF-WEEK, DAY-TO-YYYYDDD, DAY, DEBUGGING, DEBUG-ITEM, DECIMAL-POINT, DECLARATIVES, DEFAULT-BUTTON, DEFAULT-FONT, DEFAULT, DELETE, DELIMITED, DELIMITER, DEPENDING, DESCENDING, DESTINATION, DESTROY, DETAIL, DE, DISABLE, DISC, DISK, DISPLAY-COLUMNS, DISPLAY-FORMAT, DISPLAY-OF, DISPLAY, DIVIDER-COLOR, DIVIDERS, DIVIDE, DIVISION, DOTDASH, DOTTED, DOUBLE, DOWN, DRAG-COLOR, DROP- DOWN, DROP-LIST, DUPLICATES, DYNAMIC</target>
        </trans-unit>
        <trans-unit id="cacf54f34dffa98ab8fe95ec01049b87cf34a8a2" translate="yes" xml:space="preserve">
          <source>DATA DIVISION Syntax</source>
          <target state="translated">데이터 분할 구문</target>
        </trans-unit>
        <trans-unit id="ef1ab2c530e1e7a4a273bb9ed22fe35098c7702a" translate="yes" xml:space="preserve">
          <source>DATA, DATA-POINTER, DATE, DATE-COMPILED, DATE-MODIFIED, DATE-OF-INTEGER, DATE-TO-YYYYMMDD, DATE-WRITTEN, DAY, DAY-OF-INTEGER, DAY-OF-WEEK, DAY-TO-YYYYDDD, DE, DEBUGGING, DECIMAL-POINT, DECLARATIVES, DEFAULT, DELETE, DELIMITED, DELIMITER, DEPENDING, DESCENDING, DESTINATION, DETAIL, DISABLE, DISC, DISK, DISPLAY, DISPLAY-OF, DIVIDE, DIVISION, DOWN, DUPLICATES, DYNAMIC</source>
          <target state="translated">DATA, DATA-POINTER, DATE, DATE-COMPILED, DATE-MODIFIED, DATE-OF-INTEGER, DATE-TO-YYYYMMDD, DATE-WRITTEN, DAY, OF-INTEGER, DAY-OF-WEEK, DAY-TO-WEEK YYYYDDD, DE, DEBUGGING, DECIMAL-POINT, DECLARATIVES, DEFAULT, DELETE, DELIMITED, DELIMITER, DEPENDING, DESCENDING, DESTINATION, DETAIL, DISABLE, DISC, DISK, DISPLAY, DISPLAY-OF, DIVIDE, DIVISION, DOWN, DDYLICATES</target>
        </trans-unit>
        <trans-unit id="9a7769dbf47324c33f9163090c128fdce266a34c" translate="yes" xml:space="preserve">
          <source>DATE-OF-INTEGER Function Syntax</source>
          <target state="translated">DATE-OF-INTEGER 함수 구문</target>
        </trans-unit>
        <trans-unit id="de2d56241f31b520010f3bce0b98db0bbbf5b2cb" translate="yes" xml:space="preserve">
          <source>DATE-TO-YYYYMMDD Function Syntax</source>
          <target state="translated">DATE-TO-YYYYMMDD 함수 구문</target>
        </trans-unit>
        <trans-unit id="39bcedb8c2b80fd139b489090f66d6091874fd22" translate="yes" xml:space="preserve">
          <source>DAY-OF-INTEGER Function Syntax</source>
          <target state="translated">DAY-OF-INTEGER 함수 구문</target>
        </trans-unit>
        <trans-unit id="2bf1dfe2e631bd8b0d7dad6f48c0cacb9a884526" translate="yes" xml:space="preserve">
          <source>DAY-TO-YYYYDDD Function Syntax</source>
          <target state="translated">DAY-TO-YYYYDDD 함수 구문</target>
        </trans-unit>
        <trans-unit id="c12b32a0cc17b3f8909c76d7b1bfe6c328500bd4" translate="yes" xml:space="preserve">
          <source>DB</source>
          <target state="translated">DB</target>
        </trans-unit>
        <trans-unit id="ce60ccc4df9eb3a38c2616d86365e0c0f43df13c" translate="yes" xml:space="preserve">
          <source>DDDDDD</source>
          <target state="translated">DDDDDD</target>
        </trans-unit>
        <trans-unit id="025121e8c60ec006f18d8b8d88589c258c15c1d7" translate="yes" xml:space="preserve">
          <source>DDDDEEEEEE</source>
          <target state="translated">DDDDEEEEEE</target>
        </trans-unit>
        <trans-unit id="86bb1aaff76c60b46fc6063e792d77c4344339b1" translate="yes" xml:space="preserve">
          <source>DECLARATIVES Syntax</source>
          <target state="translated">선언적 구문</target>
        </trans-unit>
        <trans-unit id="d6f5636098cd458ce9d22939f8e3e8deab0e9bd0" translate="yes" xml:space="preserve">
          <source>DELETE</source>
          <target state="translated">DELETE</target>
        </trans-unit>
        <trans-unit id="143eef2ea0db77ce833000c49d3c0b7fd423279e" translate="yes" xml:space="preserve">
          <source>DELETE Syntax</source>
          <target state="translated">삭제 구문</target>
        </trans-unit>
        <trans-unit id="3a15730e7f841dfe68e53a32b12047839a2d3fb6" translate="yes" xml:space="preserve">
          <source>DETAIL GROUP(S) [2]</source>
          <target state="translated">세부 그룹 (들) [2]</target>
        </trans-unit>
        <trans-unit id="4f10c1a7a81f590cb0c5833f5f9e81467169d145" translate="yes" xml:space="preserve">
          <source>DISPLAY UPON COMMAND-LINE Syntax</source>
          <target state="translated">명령 행 구문 표시 구문</target>
        </trans-unit>
        <trans-unit id="adda0092f73a761f60d98ab42f5c7b4bba54e2d5" translate="yes" xml:space="preserve">
          <source>DISPLAY UPON ENVIRONMENT-NAME Syntax</source>
          <target state="translated">ENVIRONMENT-NAME 구문 표시</target>
        </trans-unit>
        <trans-unit id="dc0e227d85b3e8e67592171973f030e41c7ab926" translate="yes" xml:space="preserve">
          <source>DISPLAY UPON device Syntax</source>
          <target state="translated">DISPLAY UPON 장치 구문</target>
        </trans-unit>
        <trans-unit id="6145b9122a8e41c787d9431bd205fd12fd53c5a1" translate="yes" xml:space="preserve">
          <source>DISPLAY screen-data-item Syntax</source>
          <target state="translated">DISPLAY 화면 데이터 항목 구문</target>
        </trans-unit>
        <trans-unit id="1da0cf7c02605adccb99101c92fe38279b3c663a" translate="yes" xml:space="preserve">
          <source>DISPLAY-OF Function Syntax</source>
          <target state="translated">DISPLAY-OF 함수 구문</target>
        </trans-unit>
        <trans-unit id="c274523a24ad6574ea39bdfb176f7732c4c4c3d8" translate="yes" xml:space="preserve">
          <source>DIVIDE BY GIVING Syntax</source>
          <target state="translated">GIVING 구문으로 나누기</target>
        </trans-unit>
        <trans-unit id="1719d6e667413941c4bdcd1de4638431f43816ff" translate="yes" xml:space="preserve">
          <source>DIVIDE INTO GIVING Syntax</source>
          <target state="translated">GIVING 구문으로 나누기</target>
        </trans-unit>
        <trans-unit id="b020f4b6ba07306586627a0af3f4509d6885ff83" translate="yes" xml:space="preserve">
          <source>DIVIDE INTO Syntax</source>
          <target state="translated">구문으로 나누기</target>
        </trans-unit>
        <trans-unit id="542d08c7255dff568bdff9294205546046c0a7c5" translate="yes" xml:space="preserve">
          <source>Data Item</source>
          <target state="translated">데이터 아이템</target>
        </trans-unit>
        <trans-unit id="b5ab5631945fc781f3a554ec97b7ea5c28882fb6" translate="yes" xml:space="preserve">
          <source>Data Retrieved</source>
          <target state="translated">검색된 데이터</target>
        </trans-unit>
        <trans-unit id="86ce25bf2c845338976617d76d9424c933ce8444" translate="yes" xml:space="preserve">
          <source>Data descriptions of this form do not actually allocate any storage &amp;mdash; they merely define a name (&amp;lt;</source>
          <target state="translated">이 형식의 데이터 설명은 실제로 스토리지를 할당하지 않으며 단지 이름을 정의합니다 (&amp;lt;</target>
        </trans-unit>
        <trans-unit id="250ae0a93401c939f1d3a2717ed0f5768d942319" translate="yes" xml:space="preserve">
          <source>Data descriptions of this form do not actually allocate any storage &amp;mdash; they merely define a name (&lt;var&gt;constant-name-1&lt;/var&gt;) that may be used anywhere a literal of the same type as &lt;var&gt;literal-1&lt;/var&gt; may be used.</source>
          <target state="translated">이 형식의 데이터 설명은 실제로 저장소를 할당하지 않습니다. 단순히 &lt;var&gt;literal-1&lt;/var&gt; 과 동일한 유형의 리터럴이 사용될 수있는 모든 곳에서 사용될 수 있는 이름 ( &lt;var&gt;constant-name-1&lt;/var&gt; )을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="5410af708233513539ff4e59c9db8de861bdca7c" translate="yes" xml:space="preserve">
          <source>Data descriptions of this form do not actually allocate any storage &amp;mdash; they merely define a name (&lt;var&gt;constant-name-1&lt;/var&gt;) that may be used anywhere a numeric literal (see  &lt;code&gt;BYTE-LENGTH&lt;/code&gt; or  &lt;code&gt;LENGTH&lt;/code&gt; options) or a literal of the same type as &lt;var&gt;literal-1&lt;/var&gt; may be used.</source>
          <target state="translated">이 양식의 데이터 설명은 실제로 스토리지를 할당하지 않습니다 - 그들은 단지 이름을 정의 ( &lt;var&gt;constant-name-1&lt;/var&gt; ) 숫자 리터럴 (참조 어디서나 사용할 수 있습니다 &lt;code&gt;BYTE-LENGTH&lt;/code&gt; 또는 &lt;code&gt;LENGTH&lt;/code&gt; 옵션) 또는 동일한 유형의 리터럴 &lt;var&gt;literal-1&lt;/var&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="245c46ca18c5d37e5c002598ea788d447f91aba3" translate="yes" xml:space="preserve">
          <source>Data item descriptions describing the report lines and fields that make up the substance of a report group immediately follow the definition of that group.</source>
          <target state="translated">보고서 그룹의 내용을 구성하는 보고서 라인 및 필드를 설명하는 데이터 항목 설명은 해당 그룹의 정의를 즉시 따릅니다.</target>
        </trans-unit>
        <trans-unit id="ff44c584ca6ca8d400c2d505853458c01d44ef9c" translate="yes" xml:space="preserve">
          <source>Data items declared with &lt;code&gt;BASED&lt;/code&gt; are allocated no storage at compilation time. At run-time, the &lt;code&gt;ALLOCATE&lt;/code&gt; (see &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt;) or &lt;code&gt;SET ADDRESS&lt;/code&gt; (see &lt;a href=&quot;#SET-ADDRESS&quot;&gt;SET ADDRESS&lt;/a&gt;) statements are used to allocate space for and (optionally) initialize such items.</source>
          <target state="translated">&lt;code&gt;BASED&lt;/code&gt; 로 선언 된 데이터 항목은 컴파일시 스토리지가 할당되지 않습니다. 런타임에서,이 &lt;code&gt;ALLOCATE&lt;/code&gt; (참조 &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt; ) 또는 &lt;code&gt;SET ADDRESS&lt;/code&gt; (참조 &lt;a href=&quot;#SET-ADDRESS&quot;&gt;SET 주소를&lt;/a&gt; ) 문에 대한 (선택 사항) 공간을 할당하는 데 사용되는이 같은 항목을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="613feb51ddc5e794502cb0ea894587a8556331a3" translate="yes" xml:space="preserve">
          <source>Data items declared with the &lt;code&gt;ANY LENGTH&lt;/code&gt; attribute have no fixed compile-time length. Such items may only be defined in the linkage section of a subprogram as they may only serve as subroutine argument descriptions. These items must have a &lt;code&gt;PICTURE&lt;/code&gt; (see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause that specifies exactly one A, X or 9 symbol.</source>
          <target state="translated">&lt;code&gt;ANY LENGTH&lt;/code&gt; 속성으로 선언 된 데이터 항목 에는 고정 된 컴파일 시간 길이가 없습니다. 이러한 항목은 서브 루틴 인수 설명으로 만 사용할 수 있으므로 서브 프로그램의 연결 섹션에서만 정의 할 수 있습니다. 이 항목은이 있어야 &lt;code&gt;PICTURE&lt;/code&gt; (참조 &lt;a href=&quot;#PICTURE&quot;&gt;사진&lt;/a&gt; ) 절을 지정 정확히 하나의 A, X 또는 9 기호가.</target>
        </trans-unit>
        <trans-unit id="e82b1d0242f8c91a364756e74c764b6e3af9b59f" translate="yes" xml:space="preserve">
          <source>Data items declared with the&lt;code&gt;ANY LENGTH&lt;/code&gt;attribute have no fixed compile-time length. Such items may only be defined in the linkage section of a subprogram as they may only serve as subroutine argument descriptions. These items must have a&lt;code&gt;PICTURE&lt;/code&gt;(see &lt;a href=&quot;#PICTURE&quot;&gt;PICTURE&lt;/a&gt;) clause that specifies exactly one A, X or 9 symbol.</source>
          <target state="translated">&lt;code&gt;ANY LENGTH&lt;/code&gt; 속성으로 선언 된 데이터 항목 에는 고정 컴파일 시간 길이가 없습니다. 이러한 항목은 서브 루틴 인수 설명으로 만 사용될 수 있으므로 서브 프로그램의 링크 섹션에서만 정의 될 수 있습니다. 이 항목은이 있어야 &lt;code&gt;PICTURE&lt;/code&gt; (참조 &lt;a href=&quot;#PICTURE&quot;&gt;사진&lt;/a&gt; ) 절을 지정 정확히 하나의 A, X 또는 9 기호가.</target>
        </trans-unit>
        <trans-unit id="8ff9e95bc3e45b129ac52c4861ceb28707b8b1d0" translate="yes" xml:space="preserve">
          <source>Data items declared with&lt;code&gt;BASED&lt;/code&gt;are allocated no storage at compilation time. At run-time, the&lt;code&gt;ALLOCATE&lt;/code&gt;(see &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt;) or&lt;code&gt;SET ADDRESS&lt;/code&gt;(see &lt;a href=&quot;#SET-ADDRESS&quot;&gt;SET ADDRESS&lt;/a&gt;) statements are used to allocate space for and (optionally) initialize such items.</source>
          <target state="translated">&lt;code&gt;BASED&lt;/code&gt; 로 선언 된 데이터 항목 에는 컴파일시 스토리지가 할당되지 않습니다. 런타임에서,이 &lt;code&gt;ALLOCATE&lt;/code&gt; (참조 &lt;a href=&quot;#ALLOCATE&quot;&gt;ALLOCATE&lt;/a&gt; ) 또는 &lt;code&gt;SET ADDRESS&lt;/code&gt; (참조 &lt;a href=&quot;#SET-ADDRESS&quot;&gt;SET 주소를&lt;/a&gt; ) 문에 대한 (선택 사항) 공간을 할당하는 데 사용되는이 같은 항목을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="3884223bd8738175ccb76e30292953182185f26d" translate="yes" xml:space="preserve">
          <source>Data items defined in a calling program may be passed to either type of called program (subroutine or user-defined function) as arguments.</source>
          <target state="translated">호출 프로그램에 정의 된 데이터 항목은 호출 된 프로그램 유형 (서브 루틴 또는 사용자 정의 함수)에 인수로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7bc20da44b7c1e9a2ba243b517c81177d7d55e7" translate="yes" xml:space="preserve">
          <source>Data items defined in the screen section describe input, output or combination screen layouts to be used with &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) or &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; statement (see &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-item&lt;/a&gt;) statements. These screen layouts may define the entire available screen area or any subset of it.</source>
          <target state="translated">화면 섹션에 정의 된 데이터 항목은 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 문 ( &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT 화면 데이터 항목 참조&lt;/a&gt; ) 또는 &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; 문 ( &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY 화면 &lt;/a&gt;데이터 항목 참조) 과 함께 사용할 입력, 출력 또는 조합 화면 레이아웃을 설명합니다. 항목 ) 문. 이러한 화면 레이아웃은 사용 가능한 전체 화면 영역 또는 일부 하위 집합을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b6be4a0a08f89796b4ca060304e3df78e6642bf" translate="yes" xml:space="preserve">
          <source>Data items defined in the screen section describe input, output or combination screen layouts to be used with&lt;code&gt;ACCEPT screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT screen-data-item&lt;/a&gt;) or&lt;code&gt;DISPLAY screen-data-item&lt;/code&gt;statement (see &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY screen-data-item&lt;/a&gt;) statements. These screen layouts may define the entire available screen area or any subset of it.</source>
          <target state="translated">화면 섹션에 정의 된 데이터 항목은 &lt;code&gt;ACCEPT screen-data-item&lt;/code&gt; 명령문 ( &lt;a href=&quot;#ACCEPT-screen_002ddata_002ditem&quot;&gt;ACCEPT 화면 데이터 항목 참조&lt;/a&gt; ) 또는 &lt;code&gt;DISPLAY screen-data-item&lt;/code&gt; 명령문 ( &lt;a href=&quot;#DISPLAY-screen_002ddata_002ditem&quot;&gt;DISPLAY 화면 &lt;/a&gt;데이터 항목 참조) 과 함께 사용할 입력, 출력 또는 조합 화면 레이아웃을 설명합니다. 항목 ) 진술. 이러한 화면 레이아웃은 사용 가능한 전체 화면 영역 또는 그 일부를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0bc4de49a1c2e9ebf03ef7562dcdfc26ef5e0a8" translate="yes" xml:space="preserve">
          <source>Data items defined within the working-storage section are automatically initialized once &amp;mdash; as the program in which the data is defined is loaded into memory. Subprograms may be loaded into memory more than once (see the &lt;code&gt;CANCEL&lt;/code&gt; statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;)), in which case initialization will happen each time they are loaded. See &lt;a href=&quot;#Data-Initialization&quot;&gt;Data Initialization&lt;/a&gt;, for a discussion of the initialization rules.</source>
          <target state="translated">작업 저장 섹션 내에 정의 된 데이터 항목은 데이터가 정의 된 프로그램이 메모리에로드 될 때 한 번 자동으로 초기화됩니다. 서브 프로그램은 두 번 이상 메모리에로드 될 수 있으며 ( &lt;code&gt;CANCEL&lt;/code&gt; 문 참조 ( &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt; 참조 )),이 경우 초기화는로드 될 때마다 발생합니다. 초기화 규칙에 대한 설명은 &lt;a href=&quot;#Data-Initialization&quot;&gt;데이터 초기화를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b209ac3623f15088290faf41d529558938a6bd3" translate="yes" xml:space="preserve">
          <source>Data items defined within the working-storage section are automatically initialized once &amp;mdash; as the program in which the data is defined is loaded into memory. Subprograms may be loaded into memory more than once (see the&lt;code&gt;CANCEL&lt;/code&gt;statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;)), in which case initialization will happen each time they are loaded. See &lt;a href=&quot;#Data-Initialization&quot;&gt;Data Initialization&lt;/a&gt;, for a discussion of the initialization rules.</source>
          <target state="translated">작업 스토리지 섹션에 정의 된 데이터 항목은 데이터가 정의 된 프로그램이 메모리에로드되므로 자동으로 한 번 초기화됩니다. 서브 프로그램은 메모리에 두 번 이상로드 될 수 있습니다 ( &lt;code&gt;CANCEL&lt;/code&gt; 문 ( &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt; 참조 ) 참조 ).이 경우로드 될 때마다 초기화가 수행됩니다. 초기화 규칙에 대한 설명은 &lt;a href=&quot;#Data-Initialization&quot;&gt;데이터 초기화를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="98c51b886c0b0f7a16a64e545b62eaaf62c1cf1c" translate="yes" xml:space="preserve">
          <source>Data items that have the  &lt;code&gt;UNSIGNED&lt;/code&gt; attribute explicitly coded, or &lt;code&gt;DISPLAY&lt;/code&gt;, &lt;code&gt;PACKED-DECIMAL&lt;/code&gt;, &lt;code&gt;COMP-5&lt;/code&gt;, &lt;code&gt;COMP-X&lt;/code&gt; items that do not have an &amp;lsquo;</source>
          <target state="translated">&lt;code&gt;UNSIGNED&lt;/code&gt; 속성이 명시 적으로 코딩 된 데이터 항목 또는 '가없는 &lt;code&gt;DISPLAY&lt;/code&gt; , &lt;code&gt;PACKED-DECIMAL&lt;/code&gt; , &lt;code&gt;COMP-5&lt;/code&gt; , &lt;code&gt;COMP-X&lt;/code&gt; 항목</target>
        </trans-unit>
        <trans-unit id="4eb8574d2d5270d2d786dec0a24f5040d14d6919" translate="yes" xml:space="preserve">
          <source>Data items that have the&lt;code&gt;UNSIGNED&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;UNSIGNED&lt;/code&gt; 가있는 데이터 항목</target>
        </trans-unit>
        <trans-unit id="d521e914965525b65ae268fff463a172021c77bd" translate="yes" xml:space="preserve">
          <source>Data items with an explicit &lt;code&gt;VALUE&lt;/code&gt; (see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause in their definition will be initialized to that specific value.</source>
          <target state="translated">명시 적으로 데이터 항목 &lt;code&gt;VALUE&lt;/code&gt; (참조 &lt;a href=&quot;#VALUE&quot;&gt;VALUE를&lt;/a&gt; 자신의 정의) 절은 특정 값으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="b9af005425ba8ce8de1a932e2c2f2ab684e4ed8c" translate="yes" xml:space="preserve">
          <source>Data items with an explicit&lt;code&gt;VALUE&lt;/code&gt;(see &lt;a href=&quot;#VALUE&quot;&gt;VALUE&lt;/a&gt;) clause in their definition will be initialized to that specific value.</source>
          <target state="translated">명시 적으로 데이터 항목 &lt;code&gt;VALUE&lt;/code&gt; (참조 &lt;a href=&quot;#VALUE&quot;&gt;VALUE를&lt;/a&gt; 자신의 정의) 절은 특정 값으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="25d47c3faf24644ac0e22641a7e663390a36c7aa" translate="yes" xml:space="preserve">
          <source>Data items with level numbers 01 (Constants), 66, 78 and 88 may be used in the screen section; they have the same syntax, rules and usage as they do in the other data division sections.</source>
          <target state="translated">레벨 번호 01 (상수), 66, 78 및 88의 데이터 항목이 화면 섹션에 사용될 수 있습니다. 다른 데이터 분할 섹션에서와 동일한 구문, 규칙 및 사용법을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="3f037b50f5ed4565ce4707a24021f4f6ad083ed5" translate="yes" xml:space="preserve">
          <source>Data-pointer contains an address that is out of bounds</source>
          <target state="translated">데이터 포인터에 범위를 벗어난 주소가 포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="4198fda882a12627596a5f4028ac7cc6184f889d" translate="yes" xml:space="preserve">
          <source>Debugging statements may be compiled either by specifying the</source>
          <target state="translated">디버깅 문은 다음을 지정하여 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67c1e236faf50d37cb37da121db5222de83e8a41" translate="yes" xml:space="preserve">
          <source>Decimal128</source>
          <target state="translated">Decimal128</target>
        </trans-unit>
        <trans-unit id="c0b4c8cca49b3c9805bb35c6e300bcfd3896e32a" translate="yes" xml:space="preserve">
          <source>Decimal64</source>
          <target state="translated">Decimal64</target>
        </trans-unit>
        <trans-unit id="874809dfddadcc0363d1a9a37ac20f4611145b1a" translate="yes" xml:space="preserve">
          <source>Declarative procedures may not reference any other procedures defined outside the scope of DECLARATIVES.</source>
          <target state="translated">선언적 절차는 선언의 범위 밖에서 정의 된 다른 절차를 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1926bf7b1e26ebe7de6d0ebb9ef5c4439fb50dbf" translate="yes" xml:space="preserve">
          <source>Decode a formatted numeric string back to a numeric value</source>
          <target state="translated">형식화 된 숫자 문자열을 다시 숫자 값으로 디코딩</target>
        </trans-unit>
        <trans-unit id="77160803e82d16c8b1910db09f1f8206f3b07c54" translate="yes" xml:space="preserve">
          <source>Defined by the quantity of &amp;lsquo;</source>
          <target state="translated">'의 수량으로 정의</target>
        </trans-unit>
        <trans-unit id="d14e2f78a3303228220a36dc985b5fd5e385137b" translate="yes" xml:space="preserve">
          <source>Defined by the quantity of&lt;code&gt;9&lt;/code&gt; and the presence or absence of an&lt;code&gt;S&lt;/code&gt;in the PICTURE</source>
          <target state="translated">의 금액에서 정의 &lt;code&gt;9&lt;/code&gt; 와의 유무 &lt;code&gt;S&lt;/code&gt; 그림에</target>
        </trans-unit>
        <trans-unit id="1e681574ae7448c8ae4c05d776be5265b2dc953d" translate="yes" xml:space="preserve">
          <source>Defined by the quantity of&lt;code&gt;9&lt;/code&gt; and the presence or absence of an&lt;code&gt;S&lt;/code&gt;in the&lt;code&gt;PICTURE&lt;/code&gt;</source>
          <target state="translated">의 금액에서 정의 &lt;code&gt;9&lt;/code&gt; 와의 유무 &lt;code&gt;S&lt;/code&gt; 에 &lt;code&gt;PICTURE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c4f902095fbdd9a51f64589a0c9cbb5ca0476412" translate="yes" xml:space="preserve">
          <source>Defines an implied digit position that will be considered to be a zero when the data item is referenced at run-time. This symbol is used to allow data items that will contain very large values to be allocated using less storage by assuming a certain number of trailing zeros (one per &amp;lsquo;</source>
          <target state="translated">런타임시 데이터 항목이 참조 될 때 0으로 간주되는 암시 적 숫자 위치를 정의합니다. 이 기호는 특정 수의 후행 0 ( '당 하나)을 가정하여 더 적은 스토리지를 사용하여 매우 큰 값을 포함 할 데이터 항목을 할당하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3721726af464447c08ddb23c2de0ce50d614e3dd" translate="yes" xml:space="preserve">
          <source>Defines an implied digit position that will be considered to be a zero when the data item is referenced at run-time. This symbol is used to allow data items that will contain very large values to be allocated using less storage by assuming a certain number of trailing zeros (one per&lt;code&gt;P&lt;/code&gt; to exist at the end of values.</source>
          <target state="translated">데이터 항목이 런타임에 참조 될 때 0으로 간주 될 암시 적 숫자 위치를 정의합니다. 이 기호는 특정 수의 후행 0 ( 값의 끝에 &lt;code&gt;P&lt;/code&gt; 당 하나씩 있음)을 가정하여 매우 큰 값을 포함하는 데이터 항목을 적은 스토리지를 사용하여 할당 할 수 있도록하는 데 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="4d3e8e9bbc748923af33b49ac640f19a5a564427" translate="yes" xml:space="preserve">
          <source>Defines storage reserved for a single alphabetic character (&amp;lsquo;</source>
          <target state="translated">단일 알파벳 문자 ( '</target>
        </trans-unit>
        <trans-unit id="d2dadb60fe73f669fa3a07340c506372af50e9c1" translate="yes" xml:space="preserve">
          <source>Defines storage reserved for a single alphabetic character &lt;code&gt;A&lt;/code&gt;&lt;code&gt;Z&lt;/code&gt;&lt;code&gt;a&lt;/code&gt;&lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">단일 알파벳 문자 &lt;code&gt;A&lt;/code&gt; &lt;code&gt;Z&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;z&lt;/code&gt; 에 예약 된 스토리지를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="cc276340305e669eb0c75e2233fed96937f0eb10" translate="yes" xml:space="preserve">
          <source>Defines storage reserved for a single alphanumeric character (any character).</source>
          <target state="translated">단일 영숫자 문자 (모든 문자)를 위해 예약 된 스토리지를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="fafaf60ab65fe56f4f0a976cd819bff8a10abfe2" translate="yes" xml:space="preserve">
          <source>Defines storage reserved for a single character in the computer&amp;rsquo;s  &lt;em&gt;National Character set&lt;/em&gt;. Support for national character sets in GnuCOBOL is currently only partially implemented, and the compile- and run-time effect of using the &amp;lsquo;</source>
          <target state="translated">컴퓨터의 &lt;em&gt;국가 별 문자 집합&lt;/em&gt; 에서 단일 문자 용으로 예약 된 저장소를 정의합니다 . GnuCOBOL의 국가 별 문자 집합에 대한 지원은 현재 부분적으로 만 구현되며 '를 사용하는 컴파일 및 런타임 효과</target>
        </trans-unit>
        <trans-unit id="9157b25b7fe6ae0f7d0e3ba566a50c8e263af1e0" translate="yes" xml:space="preserve">
          <source>Defines storage reserved for a single character in the computer&amp;rsquo;s &amp;rsquo;</source>
          <target state="translated">컴퓨터의 '에서 단일 문자 용으로 예약 된 저장소를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d0349172c083c195705d6e928b07b013780e23ed" translate="yes" xml:space="preserve">
          <source>Defines storage reserved for a single numeric digit character (&amp;lsquo;</source>
          <target state="translated">단일 숫자 문자 ( '</target>
        </trans-unit>
        <trans-unit id="94ae1e544866ccd53a2d46a1a530f0a06f98b727" translate="yes" xml:space="preserve">
          <source>Defines storage reserved for a single numeric digit character &lt;code&gt;0&lt;/code&gt;&lt;code&gt;9&lt;/code&gt;.</source>
          <target state="translated">단일 숫자 숫자 문자 &lt;code&gt;0&lt;/code&gt; &lt;code&gt;9&lt;/code&gt; 에 예약 된 스토리지를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a67088220472afe80c47135eab1f636a9b0734f0" translate="yes" xml:space="preserve">
          <source>Defining a control hierarchy (via &lt;code&gt;CONTROLS ARE&lt;/code&gt;) that does not match the actual sequence in which data will be processed is a great way to guarantee a &amp;ldquo;broken&amp;rdquo; report. I&amp;rsquo;ll show you an example in a later section.</source>
          <target state="translated">데이터가 처리 될 실제 순서와 일치하지 않는 제어 계층 구조 ( &lt;code&gt;CONTROLS ARE&lt;/code&gt; 를 통해 )를 정의하는 것은 &quot;깨진&quot;보고서를 보장하는 좋은 방법입니다. 이후 섹션에서 예제를 보여 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="4c35955c5a43713921be58f39b4f9f08b952ef23" translate="yes" xml:space="preserve">
          <source>Defining a control hierarchy (via&lt;code&gt;CONTROLS ARE&lt;/code&gt; that does not match the actual sequence in which data will be processed is a great way to guarantee a &quot;broken&quot; report. I&amp;rsquo;ll show you an example in a later section.</source>
          <target state="translated">데이터가 처리되는 실제 순서와 일치하지 않는 &lt;code&gt;CONTROLS ARE&lt;/code&gt; 를 통해 제어 계층 정의는 &quot;손상된&quot;보고서를 보장하는 좋은 방법입니다. 나중 섹션에서 예제를 보여 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="86f4d7d5ec62e8d3cd6d42936730cd899552e6b1" translate="yes" xml:space="preserve">
          <source>Deleting directories (folders)</source>
          <target state="translated">디렉토리 (폴더) 삭제</target>
        </trans-unit>
        <trans-unit id="184170aedafad0bad24b165d0963d2623119dff1" translate="yes" xml:space="preserve">
          <source>Deleting files</source>
          <target state="translated">파일 삭제</target>
        </trans-unit>
        <trans-unit id="a00d1ea1d07a37d00d4674304143c5da9d08c63e" translate="yes" xml:space="preserve">
          <source>Demonstration Value</source>
          <target state="translated">데모 값</target>
        </trans-unit>
        <trans-unit id="a300dcf45b8bb3ac35bf8bf6fa05fb9627dec545" translate="yes" xml:space="preserve">
          <source>Depending upon which source format mode the compiler is in, you will need to follow various rules for the format mode currently in effect. These rules are presented in the upcoming paragraphs.</source>
          <target state="translated">컴파일러가 어떤 소스 형식 모드에 있는지에 따라 현재 유효한 형식 모드에 대한 다양한 규칙을 따라야합니다. 이 규칙은 다음 단락에 제시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="aab0bae82793f3236a9c2ba797e070b6fb3aec3f" translate="yes" xml:space="preserve">
          <source>Depends on &lt;code&gt;PICTURE&lt;/code&gt; &amp;mdash; One character per X, A, 9, period, $, Z, 0, *, S (if &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt; specified), +, - or B symbol in &lt;code&gt;PICTURE&lt;/code&gt;; Add 2 more bytes if the &lt;code&gt;DB&lt;/code&gt; or &lt;code&gt;CR&lt;/code&gt; editing symbol is used</source>
          <target state="translated">에 따라 &lt;code&gt;PICTURE&lt;/code&gt; - X, A, 9, 기간, $, Z, 0 당 한 문자 *, S (경우 &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt; 가 지정됨), +, - 또는 B 심볼 &lt;code&gt;PICTURE&lt;/code&gt; ; &lt;code&gt;DB&lt;/code&gt; 또는 &lt;code&gt;CR&lt;/code&gt; 편집 기호를 사용하는 경우 2 바이트 추가</target>
        </trans-unit>
        <trans-unit id="d53a15407d4f8da31632dd569ad849cee11f6f27" translate="yes" xml:space="preserve">
          <source>Depends on number of &amp;lsquo;</source>
          <target state="translated">'의 수에 따라 다름</target>
        </trans-unit>
        <trans-unit id="e1d3403c95ff976211a614c7aff47a8b06f0d474" translate="yes" xml:space="preserve">
          <source>Depends on number of&lt;code&gt;9&lt;/code&gt; in the&lt;code&gt;PICTURE&lt;/code&gt;and the&lt;code&gt;binary-size&lt;/code&gt;setting of the configuration file used to compile the program</source>
          <target state="translated">의 수에 따라 &lt;code&gt;9&lt;/code&gt; 의 &lt;code&gt;PICTURE&lt;/code&gt; 과 &lt;code&gt;binary-size&lt;/code&gt; 구성 파일의 설정은 프로그램을 컴파일하는 데 사용</target>
        </trans-unit>
        <trans-unit id="8f554af0cabf84f3acc6bcb170a806e225d3ade1" translate="yes" xml:space="preserve">
          <source>Depends on&lt;code&gt;PICTURE&lt;/code&gt; One character per X, A, 9, period, $, Z, 0, *, S (if&lt;code&gt;SEPARATE CHARACTER&lt;/code&gt;specified), +, - or B symbol in&lt;code&gt;PICTURE&lt;/code&gt; Add 2 more bytes if the&lt;code&gt;DB&lt;/code&gt;or&lt;code&gt;CR&lt;/code&gt;editing symbol is used</source>
          <target state="translated">에 따라 다릅니다 &lt;code&gt;PICTURE&lt;/code&gt; - (경우 X, A, 9, 기간, $, Z, 0 당 하나 개의 캐릭터가, *, S는 &lt;code&gt;SEPARATE CHARACTER&lt;/code&gt; 지정), +, -에서 B 기호 또는 &lt;code&gt;PICTURE&lt;/code&gt; 2 바이트 이상을 추가하면 &lt;code&gt;DB&lt;/code&gt; 또는 &lt;code&gt;CR&lt;/code&gt; 편집 기호 사용</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="b0e8e1b165f149c1a596ac6c3f9a6aa8dac95a1b" translate="yes" xml:space="preserve">
          <source>Despite statements from industry &amp;ldquo;insiders&amp;rdquo;, the COBOL programming language is not dead, even though newer and so-called &amp;ldquo;modern&amp;rdquo; languages like Java, C#, .NET, Ruby on Rails and so on appear to have become the languages of choice in the Information Technology world. These languages have become popular because they address the following desired requirements for &amp;ldquo;modern&amp;rdquo; programming:</source>
          <target state="translated">업계 &quot;내부자&quot;의 말에도 불구하고 Java, C #, .NET, Ruby on Rails 등과 같은 새롭고 소위 &quot;현대&quot;언어가에서 선택되는 언어가 된 것처럼 보이지만 COBOL 프로그래밍 언어는 죽지 않았습니다. 정보 기술 세계. 이러한 언어는 &quot;현대&quot;프로그래밍에 대해 다음과 같은 요구 사항을 충족하기 때문에 널리 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="a7bc7ee00f8b51dc232f39ec929df41c6a0ebda7" translate="yes" xml:space="preserve">
          <source>Despite what the name of this routine might make you believe, this routine is more than just a simple &quot;rename&quot; &amp;mdash; it will actually move the file supplied as the 1st argument to the file specified as the 2nd argument. Think of it as a two-step sequence, first copying the &amp;lt;</source>
          <target state="translated">이 루틴의 이름이 당신을 믿게 만들 수도 있지만,이 루틴은 단순한 &quot;이름 바꾸기&quot;그 이상입니다. 실제로 첫 번째 인수로 제공된 파일을 두 번째 인수로 지정된 파일로 옮깁니다. 이를 2 단계 시퀀스로 생각하고 먼저 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="40922ec31558cbab9fe9b910abfa2f103d20a0f2" translate="yes" xml:space="preserve">
          <source>Despite what the name of this routine might make you believe, this routine is more than just a simple &amp;ldquo;rename&amp;rdquo; &amp;mdash; it will actually move the file supplied as the 1&lt;sup&gt;st&lt;/sup&gt; argument to the file specified as the 2nd argument. Think of it as a two-step sequence, first copying the &lt;var&gt;old-file-path&lt;/var&gt; file to the &lt;var&gt;new-file-path&lt;/var&gt; file and then a second step where the &lt;var&gt;old-file-path&lt;/var&gt; is deleted.</source>
          <target state="translated">이 루틴의 이름이 당신을 믿게 할 수도 있지만,이 루틴은 단순한 &quot;이름 바꾸기&quot;이상입니다. 실제로 &lt;sup&gt;첫 번째&lt;/sup&gt; 인수로 제공된 파일을 두 번째 인수로 지정된 파일로 이동합니다. 먼저 &lt;var&gt;old-file-path&lt;/var&gt; 파일을 &lt;var&gt;new-file-path&lt;/var&gt; 파일 경로 파일에 복사 한 다음 &lt;var&gt;old-file-path&lt;/var&gt; 를 삭제 하는 두 번째 단계로 두 단계 시퀀스로 생각하십시오 .</target>
        </trans-unit>
        <trans-unit id="6dc01a0b93964e7ed3110112972c2448074cd5a5" translate="yes" xml:space="preserve">
          <source>Despite what you&amp;rsquo;ve seen here, the more complex the programming logic being implemented, the more concise the Java code will appear to be, even compared to 2002-standard COBOL. That conciseness comes with a price though &amp;mdash; program code readability. Java (or C or C++ or C#) programs are generally intelligible only to trained programmers. COBOL programs can, however, be quite understandable by non-programmers. This is actually a side-effect of the &quot;wordiness&quot; of the language, where COBOL statements use natural English words to describe their actions. This inherent readability has come in handy many times throughout my career when I&amp;rsquo;ve had to learn obscure business (or legal) processes by reading the COBOL program code that supports them.</source>
          <target state="translated">여기에서 보았지만 프로그래밍 로직이 복잡할수록 2002 표준 COBOL에 비해 Java 코드가 더 간결 해 보입니다. 간결함은 프로그램 코드 가독성과 같은 가격으로 제공됩니다. Java (또는 C 또는 C ++ 또는 C #) 프로그램은 일반적으로 숙련 된 프로그래머 만 이해할 수 있습니다. 그러나 COBOL 프로그램은 비 프로그래머가 이해할 수 있습니다. 이것은 실제로 언어의 &quot;단어&quot;의 부작용이며, COBOL 문은 자연 영어 단어를 사용하여 동작을 설명합니다. 이 고유 한 가독성은 내가 지원하는 COBOL 프로그램 코드를 읽음으로써 모호한 비즈니스 (또는 법적) 프로세스를 배워야 할 때 내 경력 전반에 걸쳐 여러 번 유용했습니다.</target>
        </trans-unit>
        <trans-unit id="86d6174d999fceda80f111d5777fe68fade2ca97" translate="yes" xml:space="preserve">
          <source>Despite what you&amp;rsquo;ve seen here, the more complex the programming logic being implemented, the more concise the Java code will appear to be, even compared to 2002-standard COBOL. That conciseness comes with a price though &amp;mdash; program code readability. Java (or C or C++ or C#) programs are generally intelligible only to trained programmers. COBOL programs can, however, be quite understandable by non-programmers. This is actually a side-effect of the &amp;ldquo;wordiness&amp;rdquo; of the language, where COBOL statements use natural English words to describe their actions. This inherent readability has come in handy many times throughout my career when I&amp;rsquo;ve had to learn obscure business (or legal) processes by reading the COBOL program code that supports them.</source>
          <target state="translated">여기에서 본 내용에도 불구하고 구현되는 프로그래밍 로직이 더 복잡할수록 Java 코드는 2002 표준 COBOL과 비교해도 더 간결 해 보입니다. 그 간결함은 가격과 함께 제공됩니다-프로그램 코드 가독성. Java (또는 C 또는 C ++ 또는 C #) 프로그램은 일반적으로 숙련 된 프로그래머 만 이해할 수 있습니다. 그러나 COBOL 프로그램은 프로그래머가 아닌 사람도 충분히 이해할 수 있습니다. 이것은 실제로 COBOL 문이 자연스러운 영어 단어를 사용하여 행동을 설명하는 언어의&amp;ldquo;말씀 함&amp;rdquo;의 부작용입니다. 이 내재 된 가독성은 저를 지원하는 COBOL 프로그램 코드를 읽음으로써 모호한 비즈니스 (또는 법적) 프로세스를 배워야 할 때 제 경력 전반에 걸쳐 여러 번 유용했습니다.</target>
        </trans-unit>
        <trans-unit id="7d18a0bca02af71f36038a10035b4fe89b253e6e" translate="yes" xml:space="preserve">
          <source>Detail Group</source>
          <target state="translated">상세 그룹</target>
        </trans-unit>
        <trans-unit id="fc513aa1c1486f07867ac9c63a186583402ee0ec" translate="yes" xml:space="preserve">
          <source>Detail Report</source>
          <target state="translated">상세 보고서</target>
        </trans-unit>
        <trans-unit id="e7c7a57e94f04db7f9ae6062a2b43e934856df05" translate="yes" xml:space="preserve">
          <source>Determine the length of a string or data-item capable of storing strings</source>
          <target state="translated">문자열을 저장할 수있는 문자열 또는 데이터 항목의 길이 결정</target>
        </trans-unit>
        <trans-unit id="c352d575e112605537ad32d24ea8d1abed42a987" translate="yes" xml:space="preserve">
          <source>Determining how many arguments were passed to a subroutine</source>
          <target state="translated">서브 루틴에 전달 된 인수 수 결정</target>
        </trans-unit>
        <trans-unit id="a5a74a6df09278b88cb6ea23b7d7f2570c33babf" translate="yes" xml:space="preserve">
          <source>Device</source>
          <target state="translated">Device</target>
        </trans-unit>
        <trans-unit id="3bb1ab7b7ef406080993faa1bf1afc98ee63fdb6" translate="yes" xml:space="preserve">
          <source>Did you notice that there are two each of &lt;code&gt;Year&lt;/code&gt;, &lt;code&gt;Month&lt;/code&gt; and &lt;code&gt;Day&lt;/code&gt; data names defined? That&amp;rsquo;s perfectly legal, provided that each can be uniquely &lt;code&gt;qualified&lt;/code&gt; so as to be distinct from the other. Take for example the &lt;code&gt;Year&lt;/code&gt; items. One is defined as part of the &lt;code&gt;From-Date&lt;/code&gt; data item while the other is defined as part of the &lt;code&gt;To-Date&lt;/code&gt; data item. In COBOL, we would actually code references to these two data items as either &lt;code&gt;Year OF From-Date&lt;/code&gt; and &lt;code&gt;Year OF To-Date&lt;/code&gt; or &lt;code&gt;Year IN From-Date&lt;/code&gt; and &lt;code&gt;Year IN To-Date&lt;/code&gt; (COBOL allows either &lt;code&gt;IN&lt;/code&gt; or &lt;code&gt;OF&lt;/code&gt; to be used). Since these references would clarify any confusion to us as to which &lt;code&gt;Year&lt;/code&gt; might be referenced, the GnuCOBOL compiler won&amp;rsquo;t be confused either.</source>
          <target state="translated">&lt;code&gt;Year&lt;/code&gt; , &lt;code&gt;Month&lt;/code&gt; 및 &lt;code&gt;Day&lt;/code&gt; 데이터 이름이 각각 두 개 정의되어 있음을 알고 계셨습니까? 그것은 완벽하게 합법적입니다. 단, 각각이 서로 구별되도록 고유 한 &lt;code&gt;qualified&lt;/code&gt; 할 수 있다는 점을 전제로합니다 . 예를 들어 &lt;code&gt;Year&lt;/code&gt; 항목을 살펴보십시오 . 하나는 &lt;code&gt;From-Date&lt;/code&gt; 데이터 항목의 일부로 정의되고 다른 하나는 &lt;code&gt;To-Date&lt;/code&gt; 데이터 항목의 일부로 정의됩니다 . COBOL에서, 우리 것 실제로 하나 이러한 두 개의 데이터 항목에 코드를 참조 &lt;code&gt;Year OF From-Date&lt;/code&gt; 와 &lt;code&gt;Year OF To-Date&lt;/code&gt; 또는 &lt;code&gt;Year IN From-Date&lt;/code&gt; 와 &lt;code&gt;Year IN To-Date&lt;/code&gt; (COBOL 허용하거나 &lt;code&gt;IN&lt;/code&gt; 또는 &lt;code&gt;OF&lt;/code&gt; 사용될). 이러한 참조는 &lt;code&gt;Year&lt;/code&gt; 가 참조 될 수있는 것에 대해 우리에게 혼란을 줄 것이기 때문에 GnuCOBOL 컴파일러도 혼란스럽지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="b4bdf8d06c8ee9447b53a8835fd50fd6f2691a97" translate="yes" xml:space="preserve">
          <source>Did you notice that there are two each of&lt;code&gt;Year&lt;/code&gt;&lt;code&gt;Month&lt;/code&gt;and&lt;code&gt;Day&lt;/code&gt;data names defined? That&amp;rsquo;s perfectly legal, provided that each can be uniquely&lt;code&gt;qualified&lt;/code&gt;so as to be distinct from the other. Take for example the&lt;code&gt;Year&lt;/code&gt;items. One is defined as part of the&lt;code&gt;From-Date&lt;/code&gt;data item while the other is defined as part of the &quot;To-Date&quot; data item. In COBOL, we would actually code references to these two data items as either&lt;code&gt;Year OF From-Date&lt;/code&gt;and&lt;code&gt;Year OF To-Date&lt;/code&gt;or&lt;code&gt;Year IN From-Date&lt;/code&gt;and&lt;code&gt;Year IN To-Date&lt;/code&gt;(COBOL allows either&lt;code&gt;IN&lt;/code&gt;or&lt;code&gt;OF&lt;/code&gt;to be used). Since these references would clarify any confusion to us as to which&lt;code&gt;Year&lt;/code&gt;might be referenced, the GnuCOBOL compiler won&amp;rsquo;t be confused either.</source>
          <target state="translated">&lt;code&gt;Year&lt;/code&gt; &lt;code&gt;Month&lt;/code&gt; 및 &lt;code&gt;Day&lt;/code&gt; 데이터 이름이 각각 두 개씩 정의되어 있습니까? 각각이 서로 구별되도록 고유하게 &lt;code&gt;qualified&lt;/code&gt; 할 수 있다면 이는 완전히 합법적 입니다. &lt;code&gt;Year&lt;/code&gt; 항목 을 예로 들어 보겠습니다 . 하나는 &lt;code&gt;From-Date&lt;/code&gt; 데이터 항목의 일부로 정의되고 다른 하나는 &quot;To-Date&quot;데이터 항목의 일부로 정의됩니다. COBOL에서는 실제로이 두 데이터 항목에 대한 참조를 &lt;code&gt;Year OF From-Date&lt;/code&gt; &lt;code&gt;Year OF To-Date&lt;/code&gt; 및 날짜 &lt;code&gt;Year IN From-Date&lt;/code&gt; 또는 연도 시작 날짜 및 &lt;code&gt;Year IN To-Date&lt;/code&gt; 날짜 또는 연도 허용)으로 코딩합니다 (COBOL은 &lt;code&gt;IN&lt;/code&gt; 또는 &lt;code&gt;OF&lt;/code&gt; 를 허용 함)사용될). 이러한 참조는 어느 &lt;code&gt;Year&lt;/code&gt; 가 참조 될 수 있는지에 대한 혼동을 명확히하기 때문에 GnuCOBOL 컴파일러도 혼동되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3dae4df8e307eadc33cccfbf09afcf7803b28a27" translate="yes" xml:space="preserve">
          <source>Did you notice the output showing the contents of &quot;Arg1&quot; after the subroutine was called? Those contents were unchanged! The subroutine</source>
          <target state="translated">서브 루틴이 호출 된 후 &quot;Arg1&quot;의 내용을 보여주는 출력을 보셨습니까? 그 내용은 바뀌지 않았습니다! 서브 루틴</target>
        </trans-unit>
        <trans-unit id="27a0e6db152d459ea9ca2c04bec5a9f10e8422a8" translate="yes" xml:space="preserve">
          <source>Did you notice the output showing the contents of &lt;code&gt;Arg1&lt;/code&gt; after the subroutine was called? Those contents were unchanged! The subroutine</source>
          <target state="translated">서브 루틴이 호출 된 후 &lt;code&gt;Arg1&lt;/code&gt; 의 내용을 보여주는 출력을 보셨습니까 ? 그 내용은 변경되지 않았습니다! 서브 루틴</target>
        </trans-unit>
        <trans-unit id="b715cee1c1b9be48a112ee6f3d85a10725180731" translate="yes" xml:space="preserve">
          <source>Direct access and conditional access to the following variables:</source>
          <target state="translated">다음 변수에 대한 직접 액세스 및 조건부 액세스 :</target>
        </trans-unit>
        <trans-unit id="6e1b2f2be5fd4ec430320157951e3b9625d998af" translate="yes" xml:space="preserve">
          <source>Direct program execution syntax is &lt;code&gt;[&lt;var&gt;path&lt;/var&gt;]&lt;var&gt;program&lt;/var&gt; [&lt;var&gt;arguments&lt;/var&gt;]&lt;/code&gt;.</source>
          <target state="translated">직접 프로그램 실행 구문은 &lt;code&gt;[&lt;var&gt;path&lt;/var&gt;]&lt;var&gt;program&lt;/var&gt; [&lt;var&gt;arguments&lt;/var&gt;]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6db57f7358d87d80d9ffe675eab1fa80c2597c75" translate="yes" xml:space="preserve">
          <source>Direct program execution syntax is as follows:</source>
          <target state="translated">직접 프로그램 실행 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3a08a300c1fa7c7b7c3869e07803b1ee488a676" translate="yes" xml:space="preserve">
          <source>Directly executable form</source>
          <target state="translated">직접 실행 가능한 양식</target>
        </trans-unit>
        <trans-unit id="bbbec44416269797757a1579d0b1247911acd066" translate="yes" xml:space="preserve">
          <source>Division</source>
          <target state="translated">Division</target>
        </trans-unit>
        <trans-unit id="50a314209c54751015d5ea87733dbccc98864d31" translate="yes" xml:space="preserve">
          <source>Division by zero</source>
          <target state="translated">0으로 나누기</target>
        </trans-unit>
        <trans-unit id="3c91054f46891fec1cae6331f29fdbccb03d6a39" translate="yes" xml:space="preserve">
          <source>Divisions</source>
          <target state="translated">Divisions</target>
        </trans-unit>
        <trans-unit id="bfed8a27b8007686a54c60cbb2b8f522bfc8a067" translate="yes" xml:space="preserve">
          <source>Do not specify the</source>
          <target state="translated">지정하지 마십시오</target>
        </trans-unit>
        <trans-unit id="768a18bcfd50a4cdbad454ea5c1997d92ec2f9ed" translate="yes" xml:space="preserve">
          <source>Do not specify the &quot;.so&quot; or &quot;.dll&quot; extension on the program name. The</source>
          <target state="translated">프로그램 이름에 &quot;.so&quot;또는 &quot;.dll&quot;확장자를 지정하지 마십시오. 그만큼</target>
        </trans-unit>
        <trans-unit id="d518fbdcc1583627074bd0312ac84a7ed352847b" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t bother worrying about it at compile-time. Use the &lt;code&gt;INITIALIZE&lt;/code&gt; (see &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;) to initialize all data item occurrences in a table (at run-time) to their data-type-specific default values (numerics: 0, alphabetic and alphanumerics: spaces).</source>
          <target state="translated">컴파일 타임에 그것에 대해 걱정하지 마십시오. 사용 &lt;code&gt;INITIALIZE&lt;/code&gt; 를 (참조 &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE를&lt;/a&gt; 데이터 형 고유의 디폴트 값 (0, 알파벳과 알파벳과 숫자 : 공간 수치)에 (실행시) 테이블에있는 모든 데이터 항목의 발생을 초기화).</target>
        </trans-unit>
        <trans-unit id="fa34cf297b7f3240b7cd6005ab3bf76a3b53feb2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t bother worrying about it at compile-time. Use the&lt;code&gt;INITIALIZE&lt;/code&gt;(see &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE&lt;/a&gt;) to initialize all data item occurrences in a table (at run-time) to their data-type-specific default values (numerics: 0, alphabetic and alphanumerics: spaces).</source>
          <target state="translated">컴파일 타임에 걱정하지 마십시오. 사용 &lt;code&gt;INITIALIZE&lt;/code&gt; 를 (참조 &lt;a href=&quot;#INITIALIZE&quot;&gt;INITIALIZE를&lt;/a&gt; 데이터 형 고유의 디폴트 값 (0, 알파벳과 알파벳과 숫자 : 공간 수치)에 (실행시) 테이블에있는 모든 데이터 항목의 발생을 초기화).</target>
        </trans-unit>
        <trans-unit id="a1aca23a3aa1e9e5ee434e5c251ba724ccb58be9" translate="yes" xml:space="preserve">
          <source>Down-Arrow was pressed</source>
          <target state="translated">아래쪽 화살표를 눌렀습니다.</target>
        </trans-unit>
        <trans-unit id="30c07ce5caf5deecde3deef6ab423e4aec558db0" translate="yes" xml:space="preserve">
          <source>During the presentation of the &lt;code&gt;CONTROL FOOTING&lt;/code&gt; groups, any necessary &lt;code&gt;PAGE FOOTING&lt;/code&gt; and &lt;code&gt;PAGE HEADING&lt;/code&gt; groups will be presented as well.</source>
          <target state="translated">&lt;code&gt;CONTROL FOOTING&lt;/code&gt; 그룹을 발표하는 동안 필요한 &lt;code&gt;PAGE FOOTING&lt;/code&gt; 및 &lt;code&gt;PAGE HEADING&lt;/code&gt; 그룹도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c121671e83c83f33db959abee0785d1ae6b8351f" translate="yes" xml:space="preserve">
          <source>During the presentation of the&lt;code&gt;CONTROL FOOTING&lt;/code&gt;groups, any necessary&lt;code&gt;PAGE FOOTING&lt;/code&gt;and&lt;code&gt;PAGE HEADING&lt;/code&gt;groups will be presented as well.</source>
          <target state="translated">&lt;code&gt;CONTROL FOOTING&lt;/code&gt; 그룹 의 프레젠테이션 중에 필요한 &lt;code&gt;PAGE FOOTING&lt;/code&gt; 및 &lt;code&gt;PAGE HEADING&lt;/code&gt; 그룹도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a70150b4c0486379b53b2bc61cc3b9e1cb791978" translate="yes" xml:space="preserve">
          <source>Dynamic Subprogram</source>
          <target state="translated">다이나믹 서브 프로그램</target>
        </trans-unit>
        <trans-unit id="6eb0f764570bb14c352993b6d496277e64157960" translate="yes" xml:space="preserve">
          <source>Dynamically-loadable</source>
          <target state="translated">Dynamically-loadable</target>
        </trans-unit>
        <trans-unit id="1348d390510adbb26537a28adfa74ec9b8165ca8" translate="yes" xml:space="preserve">
          <source>Dynamically-loadable executable form</source>
          <target state="translated">동적으로로드 가능한 실행 양식</target>
        </trans-unit>
        <trans-unit id="7e3705199d92a31df87165c76c1558b1ecf9d250" translate="yes" xml:space="preserve">
          <source>Dynamically-loadable modules may be removed from memory via the &lt;code&gt;CANCEL&lt;/code&gt; statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;).</source>
          <target state="translated">동적으로로드 할 수있는 모듈은 &lt;code&gt;CANCEL&lt;/code&gt; 문을 통해 메모리에서 제거 할 수 있습니다 ( &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="eb8d20220991838c8009592b6e63139e1b78c3ba" translate="yes" xml:space="preserve">
          <source>Dynamically-loadable modules may be removed from memory via the&lt;code&gt;CANCEL&lt;/code&gt;statement (see &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;CANCEL&lt;/code&gt; 문을 통해 동적으로로드 가능한 모듈을 메모리에서 제거 할 수 있습니다 ( &lt;a href=&quot;#CANCEL&quot;&gt;CANCEL&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0fa10c416b610a8f4e61e630e86571f7fc9a58d6" translate="yes" xml:space="preserve">
          <source>Dynamically-loadable modules will be named</source>
          <target state="translated">동적으로로드 가능한 모듈의 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="901bdca5f99ca3f0f8c3c45d17df5cd4768b3649" translate="yes" xml:space="preserve">
          <source>Dynamically-loadable modules will be named &quot;xxxxxxxx.dll&quot; on a Windows system, &quot;xxxxxxxx.so&quot; on a Unix system or &quot;xxxxxxxx.dylib&quot; on an OSX system, where &quot;xxxxxxxx&quot; exactly matches, including the usage of upper- and lower-case letters, the primary entry-point name &lt;code&gt;PROGRAM-ID&lt;/code&gt;or&lt;code&gt;FUNCTION-ID&lt;/code&gt; or an alternate entry point name defined via the&lt;code&gt;ENTRY&lt;/code&gt;statement (see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;) of any one of the GnuCOBOL programs included in that module.</source>
          <target state="translated">동적으로로드 가능한 모듈은 Windows 시스템에서 &quot;xxxxxxxx.dll&quot;, Unix 시스템에서 &quot;xxxxxxxx.so&quot;또는 OSX 시스템에서 &quot;xxxxxxxx.dylib&quot;로 이름이 지정됩니다. 여기서 &quot;xxxxxxxx&quot;는 상위- 소문자, 기본 진입 점 이름 &lt;code&gt;PROGRAM-ID&lt;/code&gt; 또는 &lt;code&gt;FUNCTION-ID&lt;/code&gt; 또는 해당 모듈에 포함 된 GnuCOBOL 프로그램 중 하나의 &lt;code&gt;ENTRY&lt;/code&gt; 문 ( &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt; 참조 )을 통해 정의 된 대체 진입 점 이름 .</target>
        </trans-unit>
        <trans-unit id="1ba95e0268763043cd1e34a29d8c36e35ba2d644" translate="yes" xml:space="preserve">
          <source>Dynamically-loaded subprograms are executed (from a COBOL syntax point of view) just like any other subprograms. What makes them unique, however, is that they are loaded into memory only when they are actually used the first time during the execution of a program.</source>
          <target state="translated">동적으로로드 된 서브 프로그램은 다른 서브 프로그램과 마찬가지로 (COBOL 구문 관점에서) 실행됩니다. 그러나 그것들을 독특하게 만드는 것은 실제로 프로그램을 실행하는 동안 처음 사용될 때만 메모리에로드된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e0184adedf913b076626646d3f52c3b49c39ad6d" translate="yes" xml:space="preserve">
          <source>E</source>
          <target state="translated">E</target>
        </trans-unit>
        <trans-unit id="030dcb4209a1709b74f2d59ef6da0355f006e9c6" translate="yes" xml:space="preserve">
          <source>E Function Syntax</source>
          <target state="translated">E 함수 구문</target>
        </trans-unit>
        <trans-unit id="765a70eecffa68061065b3955fd85a92329d8392" translate="yes" xml:space="preserve">
          <source>E, EBCDIC, EC, ECHO, EGI, ELSE, EMI, EMPTY-CHECK, ENABLE, END, END-ACCEPT, END-ADD, END-CALL, END-CHAIN, END-COMPUTE, END-DELETE, END-DISPLAY, END-DIVIDE, END-EVALUATE, END-IF, END-MULTIPLY, END-OF-PAGE, END-PERFORM, END-READ, END-RECEIVE, END-RETURN, END-REWRITE, END-SEARCH, END-START, END-STRING, END-SUBTRACT, END-UNSTRING, END-WRITE, ENTRY, ENTRY-CONVENTION, ENVIRONMENT, ENVIRONMENT-NAME, ENVIRONMENT-VALUE, EO, EOL, EOP, EOS, EQUAL, EQUALS, ERASE, ERROR, ESCAPE, ESI, EVALUATE, EXCEPTION, EXCEPTION-FILE, EXCEPTION-FILE-N, EXCEPTION-LOCATION, EXCEPTION-LOCATION-N, EXCEPTION-OBJECT, EXCEPTION-STATEMENT, EXCEPTION-STATUS, EXCLUSIVE, EXIT, EXP, EXP10, EXPANDS, EXTEND, EXTERN, EXTERNAL</source>
          <target state="translated">E, EBCDIC, EC, ECHO, EGI, ELSE, EMI, EMPTY-CHECK, ENABLE, END, END-ACCEPT, END-ADD, END-CALL, END-CHAIN, END-COMPUTE, END-DELETE, END-DISPLAY, END-DIVIDE, END-EVALUATE, END-IF, END-IF, END-OF, END-OF-PAGE, END-PERFORM, END-READ, END-RECEIVE, END-RETURN, END-REWRITE, END-SEARCH, END-START, 끝말, 끝말, 끝말, 끝-쓰기, 항목, 항목-컨벤션, 환경, 환경-이름, 환경-값, EO, EOL, EOP, EOS, EQUAL, EQUALS, ERASE, ERROR, ECAPE, ESI, 평가, 예외, 예외 파일, 예외 파일 -N, 예외 위치, 예외 위치 -N, 예외 목표, 예외 상태, 예외 상태, 예외, 종료, EXP, EXP10, 확장, 확장, 외부, 외부</target>
        </trans-unit>
        <trans-unit id="ff4355cb9ec2c88cbc132299d98f12e6aa6beedd" translate="yes" xml:space="preserve">
          <source>E, EBCDIC, ECHO, EC, EGI, ELSE, EMI, EMPTY-CHECK, ENABLE, END-ACCEPT, END-ADD, END-CALL, END-CHAIN, END-COLOR, END-COMPUTE, END-DELETE, END-DISPLAY, END-DIVIDE, END-EVALUATE, END-IF, END-MODIFY, END-MULTIPLY, END-OF-PAGE, END-PERFORM, END-READ, END-RECEIVE, END-RETURN, END-REWRITE, END-SEARCH, END-START, END-STRING, END-SUBTRACT, END-UNSTRING, END-WRITE, END, ENGRAVED, ENSURE-VISIBLE, ENTRY-CONVENTION, ENTRY-FIELD, ENTRY-REASON, ENTRY, ENVIRONMENT-NAME, ENVIRONMENT-VALUE, ENVIRONMENT, EOL, EO, EOP, EOS, EQUALS, EQUAL, ERASE, ERROR, ESCAPE-BUTTON, ESCAPE, ESI, EVALUATE, EVENT-LIST, EVENT, EXCEPTION-FILE-N, EXCEPTION-FILE, EXCEPTION-LOCATION-N, EXCEPTION-LOCATION, EXCEPTION-OBJECT, EXCEPTION-STATEMENT, EXCEPTION-STATUS, EXCEPTION-VALUE, EXCEPTION, EXCLUSIVE, EXIT, EXP10, EXPANDS, EXPAND, EXP, EXTEND, EXTERNAL-FORM, EXTERNAL, EXTERN</source>
          <target state="translated">E, EBCDIC, ECHO, EC, EGI, ELSE, EMI, EMPTY-CHECK, ENABLE, END-ACCEPT, END-ADD, END-CALL, END-CHAIN, END-COLOR, END-COMPUTE, END-DELETE, END- DISPLAY, END-DIVIDE, END-EVALUATE, END-IF, END-MODIFY, END-MULTIPLY, END-OF-PAGE, END-PERFORM, END-READ, END-RECEIVE, END-RETURN, END-REWRITE, END- SEARCH, END-START, END-STRING, END-SUBTRACT, END-UNSTRING, END-WRITE, END, ENGRAVED, ENSURE-VISIBLE, ENTRY-CONVENTION, ENTRY-FIELD, ENTRY-REASON, ENTRY, ENVIRONMENT-NAME, ENVIRONMENT- VALUE, ENVIRONMENT, EOL, EO, EOP, EOS, EQUALS, EQUAL, ERASE, ERROR, ESCAPE-BUTTON, ESCAPE, ESI, EVALUATE, EVENT-LIST, EVENT, EXCEPTION-FILE-N, EXCEPTION-FILE, EXCEPTION-LOCATION- N, EXCEPTION-LOCATION, EXCEPTION-OBJECT, EXCEPTION-STATEMENT, EXCEPTION-STATUS, EXCEPTION-VALUE, EXCEPTION, EXCLUSIVE, EXIT, EXP10, EXPANDS, EXPAND, EXP, EXTEND, EXTERNAL-FORM, EXTERNAL, EXTERN</target>
        </trans-unit>
        <trans-unit id="df984a0fcaacf728b4e9bc549b441c13997eb83a" translate="yes" xml:space="preserve">
          <source>E&lt;var&gt;nn&lt;/var&gt;</source>
          <target state="translated">E&lt;var&gt;nn&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="5effca06a41a1d22ea816cb82b7101e0e5ef5985" translate="yes" xml:space="preserve">
          <source>EC-ARGUMENT-FUNCTION</source>
          <target state="translated">EC-ARGUMENT-FUNCTION</target>
        </trans-unit>
        <trans-unit id="6f64130193ed68a9cf43ad043a1db86b51b7732f" translate="yes" xml:space="preserve">
          <source>EC-BOUND-ODO</source>
          <target state="translated">EC-BOUND-ODO</target>
        </trans-unit>
        <trans-unit id="7758bece637db0db2aa2eaf68b0a5ca23becb2f7" translate="yes" xml:space="preserve">
          <source>EC-BOUND-PTR</source>
          <target state="translated">EC-BOUND-PTR</target>
        </trans-unit>
        <trans-unit id="35ce6218474a39cc348cc1b04f5cfeb6a7093fba" translate="yes" xml:space="preserve">
          <source>EC-BOUND-REF-MOD</source>
          <target state="translated">EC-BOUND-REF-MOD</target>
        </trans-unit>
        <trans-unit id="b180672a32ac9f504a398165500845e145ddac86" translate="yes" xml:space="preserve">
          <source>EC-BOUND-SUBSCRIPT</source>
          <target state="translated">EC-BOUND-SUBSCRIPT</target>
        </trans-unit>
        <trans-unit id="47bd90096a9329462194bb3efc2ec0777c1cc384" translate="yes" xml:space="preserve">
          <source>EC-DATA-INCOMPATIBLE</source>
          <target state="translated">EC-DATA-INCOMPATIBLE</target>
        </trans-unit>
        <trans-unit id="599ae453fdf489e4c5507f42fe19ed6e9f07ec45" translate="yes" xml:space="preserve">
          <source>EC-I-O</source>
          <target state="translated">EC-I-O</target>
        </trans-unit>
        <trans-unit id="37a26c3979aa50c34cd4c0ac08b0ca77f51e47c2" translate="yes" xml:space="preserve">
          <source>EC-I-O-AT-END</source>
          <target state="translated">EC-I-O-AT-END</target>
        </trans-unit>
        <trans-unit id="7695dbca75bfb201f44d69c5f1d6236c16575ead" translate="yes" xml:space="preserve">
          <source>EC-I-O-EOP</source>
          <target state="translated">EC-I-O-EOP</target>
        </trans-unit>
        <trans-unit id="f5e8f83ff584e8d475c4cd5b0545216bba034cd9" translate="yes" xml:space="preserve">
          <source>EC-I-O-FILE-SHARING</source>
          <target state="translated">EC-I-O-FILE-SHARING</target>
        </trans-unit>
        <trans-unit id="6f67df493e29d40d1c466d3532abcf2151feb116" translate="yes" xml:space="preserve">
          <source>EC-I-O-IMP</source>
          <target state="translated">EC-I-O-IMP</target>
        </trans-unit>
        <trans-unit id="2bedcca397988fdafc22d2b1db2fe596c55b7abc" translate="yes" xml:space="preserve">
          <source>EC-I-O-INVALID-KEY</source>
          <target state="translated">EC-I-O-INVALID-KEY</target>
        </trans-unit>
        <trans-unit id="d37a719c5ec9cc280a3423d35c359f53361556cf" translate="yes" xml:space="preserve">
          <source>EC-I-O-LOGIC-ERROR</source>
          <target state="translated">EC-I-O-LOGIC-ERROR</target>
        </trans-unit>
        <trans-unit id="22c38171abcae25c72623446be7e409f53d9f1cb" translate="yes" xml:space="preserve">
          <source>EC-I-O-PERMANENT-ERROR</source>
          <target state="translated">EC-I-O-PERMANENT-ERROR</target>
        </trans-unit>
        <trans-unit id="e57f56d25192a637896e66e92bcae79d33a72575" translate="yes" xml:space="preserve">
          <source>EC-I-O-RECORD-OPERATION</source>
          <target state="translated">EC-I-O-RECORD-OPERATION</target>
        </trans-unit>
        <trans-unit id="f232808a3899bdcf8d909765f6e715db467fc08e" translate="yes" xml:space="preserve">
          <source>EC-IMP-ACCEPT</source>
          <target state="translated">EC-IMP-ACCEPT</target>
        </trans-unit>
        <trans-unit id="5b7c6f8d33dccc651230c71c804f70a23dfd3fb3" translate="yes" xml:space="preserve">
          <source>EC-IMP-DISPLAY</source>
          <target state="translated">EC-IMP-DISPLAY</target>
        </trans-unit>
        <trans-unit id="0348c4c249e24b62ec6318d07a0918b290c97136" translate="yes" xml:space="preserve">
          <source>EC-OVERFLOW</source>
          <target state="translated">EC-OVERFLOW</target>
        </trans-unit>
        <trans-unit id="39873e8196f86a467a7a5394f6dae0df7cb7ec49" translate="yes" xml:space="preserve">
          <source>EC-OVERFLOW-STRING</source>
          <target state="translated">EC-OVERFLOW-STRING</target>
        </trans-unit>
        <trans-unit id="a912b54889e1360e1822bf001ecc4bcce0057de1" translate="yes" xml:space="preserve">
          <source>EC-OVERFLOW-UNSTRING</source>
          <target state="translated">EC-OVERFLOW-UNSTRING</target>
        </trans-unit>
        <trans-unit id="642796743342819c46389d927083877ea07d115a" translate="yes" xml:space="preserve">
          <source>EC-PROGRAM-NOT-FOUND</source>
          <target state="translated">EC-PROGRAM-NOT-FOUND</target>
        </trans-unit>
        <trans-unit id="fbeac2b7df577454ec16676f61d4d1c2dd9e4b66" translate="yes" xml:space="preserve">
          <source>EC-RANGE-INSPECT-SIZE</source>
          <target state="translated">EC-RANGE-INSPECT-SIZE</target>
        </trans-unit>
        <trans-unit id="44603209bfd2fe1e4c13a73d2183c6926c88fa44" translate="yes" xml:space="preserve">
          <source>EC-SIZE</source>
          <target state="translated">EC-SIZE</target>
        </trans-unit>
        <trans-unit id="d4c83319eed34736080dc026b83369dc0ab0f9e0" translate="yes" xml:space="preserve">
          <source>EC-SIZE-OVERFLOW</source>
          <target state="translated">EC-SIZE-OVERFLOW</target>
        </trans-unit>
        <trans-unit id="995fc7c1e9f2389fb223769d4efff5b6078bcd23" translate="yes" xml:space="preserve">
          <source>EC-SIZE-TRUNCATION</source>
          <target state="translated">EC-SIZE-TRUNCATION</target>
        </trans-unit>
        <trans-unit id="2b0855452a33f27ee0e3591f258c880264670a28" translate="yes" xml:space="preserve">
          <source>EC-SIZE-ZERO-DIVIDE</source>
          <target state="translated">EC-SIZE-ZERO-DIVIDE</target>
        </trans-unit>
        <trans-unit id="74425f6db6d6bbce95e0144ef83b5f7377196c52" translate="yes" xml:space="preserve">
          <source>EC-STORAGE-NOT-ALLOC</source>
          <target state="translated">EC-STORAGE-NOT-ALLOC</target>
        </trans-unit>
        <trans-unit id="2bcce8379324db20847e97d1dbdd7613e1e978ce" translate="yes" xml:space="preserve">
          <source>EC-STORAGE-NOT-AVAIL</source>
          <target state="translated">EC-STORAGE-NOT-AVAIL</target>
        </trans-unit>
        <trans-unit id="8a1d9b464a3fd8c9e5f06af5b43005029d7c16b1" translate="yes" xml:space="preserve">
          <source>EEEEEE</source>
          <target state="translated">EEEEEE</target>
        </trans-unit>
        <trans-unit id="af80c9b4c454f7d961a11331ae6fb9445df82b42" translate="yes" xml:space="preserve">
          <source>EMPTY-CHECK Attribute Syntax</source>
          <target state="translated">비어있는 점검 속성 구문</target>
        </trans-unit>
        <trans-unit id="f84802327b6f04b6ca9f5ad265dd6839e26a2682" translate="yes" xml:space="preserve">
          <source>ENTER key pressed</source>
          <target state="translated">ENTER 키를 눌렀습니다.</target>
        </trans-unit>
        <trans-unit id="1737c25f7adeb7b4b0cf8beddc7007f6c44cee3c" translate="yes" xml:space="preserve">
          <source>ENTRY Syntax</source>
          <target state="translated">ENTRY 구문</target>
        </trans-unit>
        <trans-unit id="c8d3810b7c62cddd57ba48b6b05b3d7aaeb1d1c3" translate="yes" xml:space="preserve">
          <source>ENTRY-Argument</source>
          <target state="translated">ENTRY-Argument</target>
        </trans-unit>
        <trans-unit id="56bc597bd92048db144c774480c4ac8ebc388d8a" translate="yes" xml:space="preserve">
          <source>ENTRY-Argument Syntax</source>
          <target state="translated">ENTRY- 인수 구문</target>
        </trans-unit>
        <trans-unit id="aeefff7bdd0630e9dbc6edcccf44b29d8e1b5f66" translate="yes" xml:space="preserve">
          <source>ENVIRONMENT DIVISION Syntax</source>
          <target state="translated">환경 분할 구문</target>
        </trans-unit>
        <trans-unit id="10be88097f9b48fa4b8f5918ab59b09ba828e0cf" translate="yes" xml:space="preserve">
          <source>ERASE Clause Syntax</source>
          <target state="translated">지우기 절 구문</target>
        </trans-unit>
        <trans-unit id="ac9203c958d901638098a3a27f18842d1485d81c" translate="yes" xml:space="preserve">
          <source>EVALUATE</source>
          <target state="translated">EVALUATE</target>
        </trans-unit>
        <trans-unit id="5dad113e5d1b8f3e62a36027129de407d3e20ed5" translate="yes" xml:space="preserve">
          <source>EVALUATE Selection Object Syntax</source>
          <target state="translated">평가 선택 객체 구문</target>
        </trans-unit>
        <trans-unit id="5a83d6a3d7ae8bc96fedf1c772fbc996a4a470be" translate="yes" xml:space="preserve">
          <source>EVALUATE Selection Subject Syntax</source>
          <target state="translated">평가 선택 주제 구문</target>
        </trans-unit>
        <trans-unit id="692ff2f950c444cebee2d4c4c60df5cc939b8fd9" translate="yes" xml:space="preserve">
          <source>EVALUATE Syntax</source>
          <target state="translated">평가 구문</target>
        </trans-unit>
        <trans-unit id="469cc380359b81f762280d15538dfac8966996c9" translate="yes" xml:space="preserve">
          <source>EXCEPTION-FILE Function Syntax</source>
          <target state="translated">EXCEPTION-FILE 함수 구문</target>
        </trans-unit>
        <trans-unit id="75bfe6f4536ac0ec1c07de964364a292e1b9db96" translate="yes" xml:space="preserve">
          <source>EXCEPTION-FILE-N Function Syntax</source>
          <target state="translated">EXCEPTION-FILE-N 함수 구문</target>
        </trans-unit>
        <trans-unit id="479aad1c99b2dd0808d2f3ab8cbcb8f9343aaefd" translate="yes" xml:space="preserve">
          <source>EXCEPTION-LOCATION Function Syntax</source>
          <target state="translated">EXCEPTION-LOCATION 함수 구문</target>
        </trans-unit>
        <trans-unit id="422a126495bc1b3fee7deb7aca538449bf5eb05e" translate="yes" xml:space="preserve">
          <source>EXCEPTION-LOCATION-N Function Syntax</source>
          <target state="translated">EXCEPTION-LOCATION-N 함수 구문</target>
        </trans-unit>
        <trans-unit id="33912bed8a51a3f75c3314cf3a0622c55f3ea0f0" translate="yes" xml:space="preserve">
          <source>EXCEPTION-STATEMENT Function Syntax</source>
          <target state="translated">EXCEPTION-STATEMENT 함수 구문</target>
        </trans-unit>
        <trans-unit id="e953091eafe979edb67d0cb82e5a7cfb2279431b" translate="yes" xml:space="preserve">
          <source>EXCEPTION-STATUS Function Syntax</source>
          <target state="translated">EXCEPTION-STATUS 함수 구문</target>
        </trans-unit>
        <trans-unit id="2d0d9c09a42e3d4ca8de4f760e2a0e18040ed305" translate="yes" xml:space="preserve">
          <source>EXIT Syntax</source>
          <target state="translated">종료 구문</target>
        </trans-unit>
        <trans-unit id="d686d0c0c789b999f85984848eb8e9e113877d1c" translate="yes" xml:space="preserve">
          <source>EXP Function Syntax</source>
          <target state="translated">EXP 함수 구문</target>
        </trans-unit>
        <trans-unit id="82ec30d94a7c621453c959d12251cec86e515836" translate="yes" xml:space="preserve">
          <source>EXP10 Function Syntax</source>
          <target state="translated">EXP10 함수 구문</target>
        </trans-unit>
        <trans-unit id="f6c4ca6abf37447285ca9c9057e5a05661c09827" translate="yes" xml:space="preserve">
          <source>EXTERN the program name is treated as an external reference.</source>
          <target state="translated">EXTERN 프로그램 이름은 외부 참조로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="03fa72b305c4462fb55710bd2cd41b8ac8239e43" translate="yes" xml:space="preserve">
          <source>EXTERNAL Attribute Syntax</source>
          <target state="translated">외부 속성 구문</target>
        </trans-unit>
        <trans-unit id="76da433919c17ebd8d966fabcaa51186d16cbb3c" translate="yes" xml:space="preserve">
          <source>Each &amp;lt;</source>
          <target state="translated">각 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="ab7a12a52c6f9b3787b7205827450dfa5e210ea2" translate="yes" xml:space="preserve">
          <source>Each &amp;lt;&amp;lt;</source>
          <target state="translated">각 &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="900ec32090cdb9a3320e1a78085e5fe28837f0e3" translate="yes" xml:space="preserve">
          <source>Each 01-level data item described within a subprogram&amp;rsquo;s linkage section should correspond to an argument passed on a &lt;code&gt;CALL&lt;/code&gt; statement (see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;) or an argument on a function call to the subprogram.</source>
          <target state="translated">서브 프로그램의 연결 섹션에 설명 된 각 01 레벨 데이터 항목은 &lt;code&gt;CALL&lt;/code&gt; 문 ( &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt; 참조 )에 전달 된 인수 또는 서브 프로그램에 대한 함수 호출의 인수에 대응해야합니다.</target>
        </trans-unit>
        <trans-unit id="212df151f4df6b415b0184ea3c628ccc78c3a454" translate="yes" xml:space="preserve">
          <source>Each 01-level data item described within a subprogram&amp;rsquo;s linkage section should correspond to an argument passed on a&lt;code&gt;CALL&lt;/code&gt;statement (see &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt;) or an argument on a function call to the subprogram.</source>
          <target state="translated">서브 프로그램의 링크 섹션에 설명 된 각 01 레벨 데이터 항목은 &lt;code&gt;CALL&lt;/code&gt; 문 에 전달 된 인수 ( &lt;a href=&quot;#CALL&quot;&gt;CALL&lt;/a&gt; 참조 ) 또는 서브 프로그램에 대한 함수 호출의 인수와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="115717c65e80cd5824c32661a8d77c36da7fcfdf" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; directive must be terminated by an  &lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; directive.</source>
          <target state="translated">각 &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; 지시문은 &lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; 지시문 으로 종료되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="38832343fe1ed825a2cbac8e9d80c0f342cb4a1d" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;RD&lt;/code&gt; will have the following allocated for it:</source>
          <target state="translated">각 &lt;code&gt;RD&lt;/code&gt; 에는 다음이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="921f886ae3ffaa77e00f545e0c06dbb1d94e2029" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;WHEN&lt;/code&gt; clause (other than the  &lt;code&gt;WHEN OTHER&lt;/code&gt; clause, if any) must have the same number of &lt;var&gt;Selection-Object&lt;/var&gt; clauses as there are &lt;var&gt;Selection-Subject&lt;/var&gt; clauses.</source>
          <target state="translated">각 &lt;code&gt;WHEN&lt;/code&gt; 절 (있는 경우 &lt;code&gt;WHEN OTHER&lt;/code&gt; 절 제외) 에는 &lt;var&gt;Selection-Subject&lt;/var&gt; 절 과 동일한 수의 &lt;var&gt;Selection-Object&lt;/var&gt; 절이 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="443bc8f743c2aa71daaad9dc46ec5b0f598a0590" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;CDF-Conditional-Expression-n&lt;/var&gt; will be evaluated, in turn, in the sequence in which they are coded in the &amp;gt;&amp;gt;IF statement and any &lt;code&gt;&amp;gt;&amp;gt;ELIF&lt;/code&gt; clauses that may be present until one evaluates to &lt;code&gt;TRUE&lt;/code&gt;. Once one of them evaluates to &lt;code&gt;TRUE&lt;/code&gt;, the &lt;var&gt;Program-Source-Lines-n&lt;/var&gt; block of code that corresponds to the &lt;code&gt;TRUE&lt;/code&gt;&lt;var&gt;CDF-Conditional-Expression-n&lt;/var&gt; will be one that is processed. All others within the &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt;-&lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; scope will be ignored.</source>
          <target state="translated">각 &lt;var&gt;CDF-Conditional-Expression-n&lt;/var&gt; 은 &amp;gt;&amp;gt; IF 문과 &lt;code&gt;TRUE&lt;/code&gt; 로 평가 될 때까지 존재할 수있는 &lt;code&gt;&amp;gt;&amp;gt;ELIF&lt;/code&gt; 절에 코딩 된 순서로 차례로 평가됩니다 . 그 중 하나가 평가되면 &lt;code&gt;TRUE&lt;/code&gt; 상기 &lt;var&gt;Program-Source-Lines-n&lt;/var&gt; 코드 블록에 대응하는 &lt;code&gt;TRUE&lt;/code&gt; &lt;var&gt;CDF-Conditional-Expression-n&lt;/var&gt; 가공 한 것이다. &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; - &lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; 범위 내의 다른 모든 항목 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3f6587562c16624da235296e266b71749a07a083" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;ENTRY-Argument&lt;/var&gt; specified on the &lt;code&gt;ENTRY&lt;/code&gt; statement must be defined in the linkage section of the subroutine in which the &lt;code&gt;ENTRY&lt;/code&gt; statement exists.</source>
          <target state="translated">&lt;code&gt;ENTRY&lt;/code&gt; 문 에 지정된 각 &lt;var&gt;ENTRY-Argument&lt;/var&gt; 는 &lt;code&gt;ENTRY&lt;/code&gt; 문이 존재 하는 서브 루틴의 연결 섹션에 정의되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="fb7d1f9fd639efe6754262d5ceb8ea7ae40bbd28" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;conditional-expression-n&lt;/var&gt; will be evaluated, in turn, until either one evaluates to a value of &lt;code&gt;TRUE&lt;/code&gt; or all have evaluated to &lt;code&gt;FALSE&lt;/code&gt;.</source>
          <target state="translated">각 &lt;var&gt;conditional-expression-n&lt;/var&gt; 은 하나가 &lt;code&gt;TRUE&lt;/code&gt; 값으로 평가되거나 모두 &lt;code&gt;FALSE&lt;/code&gt; 로 평가 될 때까지 차례로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="b6878e47bf6df2f2a91e53ac73fdcc30c966fa21" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;file-name-1&lt;/var&gt;, &lt;var&gt;file-name-2&lt;/var&gt; and &lt;var&gt;file-name-3&lt;/var&gt; (if specified) must reference &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt;) or &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; (see &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt;) files. These files must be defined using a file description (&lt;code&gt;FD&lt;/code&gt; (see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;)).</source>
          <target state="translated">각 &lt;var&gt;file-name-1&lt;/var&gt; , &lt;var&gt;file-name-2&lt;/var&gt; 및 &lt;var&gt;file-name-3&lt;/var&gt; (지정된 경우)은 &lt;code&gt;ORGANIZATION LINE SEQUENTIAL&lt;/code&gt; ( &lt;a href=&quot;#ORGANIZATION-LINE-SEQUENTIAL&quot;&gt;ORGANIZATION LINE SEQUENTIAL&lt;/a&gt; 참조 ) 또는 &lt;code&gt;ORGANIZATION SEQUENTIAL&lt;/code&gt; ( &lt;a href=&quot;#ORGANIZATION-SEQUENTIAL&quot;&gt;ORGANIZATION SEQUENTIAL&lt;/a&gt; 참조 ) 파일을 참조해야 합니다. 이러한 파일은 파일 설명을 사용하여 정의해야합니다 ( &lt;code&gt;FD&lt;/code&gt; ( &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File / Sort-Description 참조&lt;/a&gt; )).</target>
        </trans-unit>
        <trans-unit id="cd44d0a6a48e3cb5454dd2527bb158d843786124" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;identifier-1&lt;/var&gt; must be a numeric or numeric-edited data item.</source>
          <target state="translated">각 &lt;var&gt;identifier-1&lt;/var&gt; 은 숫자 또는 숫자로 편집 된 데이터 항목이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a5d2215490bd5d8ccbcb8ce83e4d44e626cc69d6" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;literal-1&lt;/var&gt; / &lt;var&gt;identifier-1&lt;/var&gt; will be referred to as a source item. The receiving data item is &lt;var&gt;identifier-3&lt;/var&gt;.</source>
          <target state="translated">각 &lt;var&gt;literal-1&lt;/var&gt; / &lt;var&gt;identifier-1&lt;/var&gt; 은 소스 항목이라고합니다. 수신 데이터 항목은 &lt;var&gt;identifier-3&lt;/var&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7d37e9deb20c6f9a95e03d94a50fd89c54c2786d" translate="yes" xml:space="preserve">
          <source>Each &lt;var&gt;report-name-1&lt;/var&gt; must be the name of a report having an &lt;code&gt;RD&lt;/code&gt; (see &lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt;) defined for it.</source>
          <target state="translated">각 &lt;var&gt;report-name-1&lt;/var&gt; 은 &lt;code&gt;RD&lt;/code&gt; ( &lt;a href=&quot;#REPORT-SECTION&quot;&gt;REPORT SECTION&lt;/a&gt; 참조 )가 정의 된 보고서의 이름이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="e05312e63008629d1548d37cc3382fa2fdc5457d" translate="yes" xml:space="preserve">
          <source>Each Event-Handler-Routine will be a separate section devoted to trapping a particular run-time event. If there are no such sections coded, the &lt;code&gt;DECLARATIVES.&lt;/code&gt; and &lt;code&gt;END DECLARATIVES.&lt;/code&gt; lines may be omitted.</source>
          <target state="translated">각 Event-Handler-Routine은 특정 런타임 이벤트를 트랩하는 데 전념하는 별도의 섹션입니다. 코딩 된 섹션이없는 경우 &lt;code&gt;DECLARATIVES.&lt;/code&gt; 및 &lt;code&gt;END DECLARATIVES.&lt;/code&gt; 줄을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50184d6f70a255b3866145aa336ae939da7ab9ab" translate="yes" xml:space="preserve">
          <source>Each Event-Handler-Routine will be a separate section devoted to trapping a particular run-time event. If there are no such sections coded, the&lt;code&gt;DECLARATIVES.&lt;/code&gt;and&lt;code&gt;END DECLARATIVES.&lt;/code&gt;lines may be omitted.</source>
          <target state="translated">각 Event-Handler-Routine은 특정 런타임 이벤트를 포착하기위한 별도의 섹션입니다. 그러한 섹션이 코딩되어 있지 않으면, &lt;code&gt;DECLARATIVES.&lt;/code&gt; 그리고 &lt;code&gt;END DECLARATIVES.&lt;/code&gt; 라인은 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b25dfd77ca9db15d2164fe35f200c91c7b2bda7" translate="yes" xml:space="preserve">
          <source>Each character, in turn, within the &quot;from&quot; string will be searched for in the target range of the inspect subject. Each located occurrence will be replaced by the corresponding character of the &quot;to&quot; string.</source>
          <target state="translated">&quot;from&quot;문자열 내의 각 문자는 검사 대상의 대상 범위에서 검색됩니다. 찾은 각 발생은 &quot;to&quot;문자열의 해당 문자로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="b543ee1616a4bbe14b82d846d38eb42687fc36f4" translate="yes" xml:space="preserve">
          <source>Each character, in turn, within the &amp;ldquo;from&amp;rdquo; string will be searched for in the target range of the inspect subject. Each located occurrence will be replaced by the corresponding character of the &amp;ldquo;to&amp;rdquo; string.</source>
          <target state="translated">차례로 &quot;from&quot;문자열 내의 각 문자는 검사 대상의 대상 범위에서 검색됩니다. 발견 된 각 항목은 &quot;to&quot;문자열의 해당 문자로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="97de2fc8d281d19be767cf651c3cbc1b7509f469" translate="yes" xml:space="preserve">
          <source>Each data item has 7 added to it ten</source>
          <target state="translated">각 데이터 항목에는 10이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="ab9334c293ad692df1c39f41752b9038645373a6" translate="yes" xml:space="preserve">
          <source>Each destination field may have an optional  &lt;code&gt;COUNT&lt;/code&gt; clause. If a &lt;code&gt;COUNT&lt;/code&gt; clause is specified, &lt;var&gt;identifier-6&lt;/var&gt; will have the size of the sub string (in characters) for the destination field moved into it. If a destination field was not altered (because an insufficient number of sub strings were identified), &lt;var&gt;identifier-6&lt;/var&gt; for that destination field will also be unchanged.</source>
          <target state="translated">각 대상 필드에는 선택적 &lt;code&gt;COUNT&lt;/code&gt; 절이 있을 수 있습니다 . 경우 &lt;code&gt;COUNT&lt;/code&gt; 의 절이 지정, &lt;var&gt;identifier-6&lt;/var&gt; 그것으로 이동 목적지 필드 (문자) 하위 문자열의 크기를해야합니다. 대상 필드가 변경되지 않은 경우 (불충분 한 수의 하위 문자열이 식별 되었기 때문에) 해당 대상 필드의 &lt;var&gt;identifier-6&lt;/var&gt; 도 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c73df2fc0d418efb070a92e84af9f4f1dd43625" translate="yes" xml:space="preserve">
          <source>Each destination field may have an optional  &lt;code&gt;DELIMITER&lt;/code&gt; clause. If a &lt;code&gt;DELIMITER&lt;/code&gt; clause is specified, &lt;var&gt;identifier-5&lt;/var&gt; will have the delimiter character string used to identify the sub string for the destination field moved into it. If a destination field was not altered (because an insufficient number of sub strings were identified), &lt;var&gt;identifier-5&lt;/var&gt; for that destination field will also be unchanged.</source>
          <target state="translated">각 대상 필드에는 선택적 &lt;code&gt;DELIMITER&lt;/code&gt; 절이 있을 수 있습니다 . 경우 &lt;code&gt;DELIMITER&lt;/code&gt; 의 절이 지정, &lt;var&gt;identifier-5&lt;/var&gt; 그것으로 이동 대상 필드의 하위 문자열을 식별하는 데 사용되는 구분 기호 문자열을해야합니다. 대상 필드가 변경되지 않은 경우 (불충분 한 수의 하위 문자열이 식별 되었기 때문에) 해당 대상 필드의 &lt;var&gt;identifier-5&lt;/var&gt; 도 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83ca16f4859e7d91cc156f672d81b61c4963b390" translate="yes" xml:space="preserve">
          <source>Each destination field may have an optional&lt;code&gt;COUNT&lt;/code&gt;</source>
          <target state="translated">각 목적지 입력란에는 선택 사항 인 &lt;code&gt;COUNT&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ce3fcdc8c9dc594c99b3c39bb2ebb465ca20a452" translate="yes" xml:space="preserve">
          <source>Each destination field may have an optional&lt;code&gt;DELIMITER&lt;/code&gt;</source>
          <target state="translated">각 목적지 필드에는 선택 사항 인 &lt;code&gt;DELIMITER&lt;/code&gt; 가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="824ef1a5b203c9da09868c95374d778cb8131338" translate="yes" xml:space="preserve">
          <source>Each division may consist of a variety of sections and each section consists of one or more paragraphs. A paragraph consists of sentences, each of which consists of one or more statements.</source>
          <target state="translated">각 부서는 다양한 섹션으로 구성 될 수 있으며 각 섹션은 하나 이상의 단락으로 구성됩니다. 단락은 문장으로 구성되며 각 문장은 하나 이상의 문장으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3e510dab54525f1b1c6a22ae1d10e5768762c025" translate="yes" xml:space="preserve">
          <source>Each file specified on the &lt;code&gt;cobc&lt;/code&gt; command constitutes a  &lt;em&gt;Compilation Unit&lt;/em&gt;. A compilation unit may be a single GnuCOBOL program &amp;mdash; with or without nested subprograms(see &lt;a href=&quot;#Independent-vs-Contained-vs-Nested-Subprograms&quot;&gt;Independent vs Contained vs Nested Subprograms&lt;/a&gt;) &amp;mdash; or multiple GnuCOBOL programs, separated by &lt;code&gt;END PROGRAM&lt;/code&gt; or &lt;code&gt;END FUNCTION&lt;/code&gt; marker lines, as appropriate. See &lt;a href=&quot;#Independent-vs-Contained-vs-Nested-Subprograms&quot;&gt;Independent vs Contained vs Nested Subprograms&lt;/a&gt;, for some examples of these marker lines.</source>
          <target state="translated">&lt;code&gt;cobc&lt;/code&gt; 명령 에 지정된 각 파일 은 &lt;em&gt;컴파일 단위를&lt;/em&gt; 구성합니다 . 컴파일 단위는 중첩 된 하위 프로그램이 있거나없는 단일 GnuCOBOL 프로그램 ( &lt;a href=&quot;#Independent-vs-Contained-vs-Nested-Subprograms&quot;&gt;독립 대 포함 된 하위 프로그램과 중첩 된 하위 프로그램 참조&lt;/a&gt; ) 또는 &lt;code&gt;END PROGRAM&lt;/code&gt; 또는 &lt;code&gt;END FUNCTION&lt;/code&gt; 마커 행으로 구분 된 여러 GnuCOBOL 프로그램 일 수 있습니다. 이러한 마커 라인의 몇 가지 예는 &lt;a href=&quot;#Independent-vs-Contained-vs-Nested-Subprograms&quot;&gt;독립 대 포함 대 중첩 하위 프로그램을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e2bd01ccaa12000bd7c8aa2fcbf0347999187549" translate="yes" xml:space="preserve">
          <source>Each file specified on the&lt;code&gt;cobc&lt;/code&gt;command constitutes a &amp;rsquo;</source>
          <target state="translated">&lt;code&gt;cobc&lt;/code&gt; 명령 에 지정된 각 파일 은 '</target>
        </trans-unit>
        <trans-unit id="00f5259fa9f0d932f10e8397b1eec6feeb68f182" translate="yes" xml:space="preserve">
          <source>Each occurrence is referenced using the subscript syntax (a numeric literal, arithmetic expression or numeric identifier enclosed within parenthesis) shown above.</source>
          <target state="translated">각 어커런스는 위에 표시된 아래 첨자 구문 (숫자 리터럴, 산술 표현식 또는 괄호로 묶인 숫자 식별자)을 사용하여 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="0bfdf714118b0517a29efa6c64d0dfc4da15a1be" translate="yes" xml:space="preserve">
          <source>Each occurrence that is set to a value of zero prior to the &lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt; will cause the corresponding switch to be cleared. Each occurrence set to 1 prior to the &lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt; will cause the corresponding switch to be set.</source>
          <target state="translated">&lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt; 이전에 0 값으로 설정된 각 발생 은 해당 스위치가 지워지게합니다. &lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt; 이전에 1로 설정된 각 발생 은 해당 스위치가 설정되도록합니다.</target>
        </trans-unit>
        <trans-unit id="2246e9f359281d69c5119e3504fc16ed25bac66e" translate="yes" xml:space="preserve">
          <source>Each occurrence that is set to a value of zero prior to the&lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt;will cause the corresponding switch to be cleared. Each occurrence set to 1 prior to the&lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt;will cause the corresponding switch to be set.</source>
          <target state="translated">&lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt; 이전에 값이 0으로 설정 될 때마다 해당 스위치가 지워집니다. &lt;code&gt;CALL X&quot;91&quot;&lt;/code&gt; 이전에 각각 1을 설정 하면 해당 스위치가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="47a2c92912290d0b93c63c77a2120c44882c45e8" translate="yes" xml:space="preserve">
          <source>Each of &amp;lt;</source>
          <target state="translated">각각의 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="86fdfce12b8a18bd22af0360afc91496fd89cc05" translate="yes" xml:space="preserve">
          <source>Each of &lt;var&gt;identifier-6&lt;/var&gt;, &lt;var&gt;identifier-7&lt;/var&gt; and &lt;var&gt;identifier-8&lt;/var&gt; must be elementary non-edited integer numeric items.</source>
          <target state="translated">각 &lt;var&gt;identifier-6&lt;/var&gt; , &lt;var&gt;identifier-7&lt;/var&gt; 및 &lt;var&gt;identifier-8&lt;/var&gt; 초이어야 숫자 항목 정수 비 편집.</target>
        </trans-unit>
        <trans-unit id="a97f6698ca0ef433fb7ac939df954fa715d8f25a" translate="yes" xml:space="preserve">
          <source>Each of the &amp;lt;</source>
          <target state="translated">각각의 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="2d26415007053c16356543a3cca49abac4eedd03" translate="yes" xml:space="preserve">
          <source>Each of the 1&lt;sup&gt;st&lt;/sup&gt; eight occurrences of the array will be set to either 0 or 1 &amp;mdash; 1 if the corresponding switch is set, 0 otherwise.</source>
          <target state="translated">어레이의 &lt;sup&gt;처음&lt;/sup&gt; 여덟 번 발생 하는 각 항목은 해당 스위치가 설정되어 있으면 0 또는 1-1로 설정되고 그렇지 않으면 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7287503eaa543018b27e0323b8db19263aedff48" translate="yes" xml:space="preserve">
          <source>Each of the 1st eight occurrences of the array will be set to either 0 or 1 &amp;mdash; 1 if the corresponding switch is set, 0 otherwise.</source>
          <target state="translated">어레이의 첫 8 개 발생은 각각 해당 스위치가 설정된 경우 0 또는 1-1로 설정되고 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="11ebabd5c143f745aa346130644dcd37fd1138df" translate="yes" xml:space="preserve">
          <source>Each of the &lt;var&gt;conditional-expression-n&lt;/var&gt;s on the &lt;code&gt;WHEN&lt;/code&gt; clause(s) should involve a data element within the table, subscripted using the search index.</source>
          <target state="translated">각각의 &lt;var&gt;conditional-expression-n&lt;/var&gt; 상의이야 &lt;code&gt;WHEN&lt;/code&gt; 검색 인덱스를 사용 첨자 테이블 내의 데이터 요소를 포함한다 절 발.</target>
        </trans-unit>
        <trans-unit id="1ef84c99be243270ff93ad6c09027b70f5557750" translate="yes" xml:space="preserve">
          <source>Each of the folders named on the &lt;code&gt;COBCPY&lt;/code&gt; compilation-time environment variable   (see &lt;a href=&quot;#Compilation-Time-Environment-Variables&quot;&gt;Compilation Time Environment Variables&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;COBCPY&lt;/code&gt; 컴파일 시간 환경 변수 에 이름이 지정된 각 폴더 ( &lt;a href=&quot;#Compilation-Time-Environment-Variables&quot;&gt;컴파일 시간 환경 변수&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="c09592cadb2ed51d0f1c709d0f7fdfe9b96c7560" translate="yes" xml:space="preserve">
          <source>Each of the folders named on the&lt;code&gt;COBCPY&lt;/code&gt;compilation-time environment variable</source>
          <target state="translated">&lt;code&gt;COBCPY&lt;/code&gt; 컴파일 타임 환경 변수 에 이름이 지정된 각 폴더</target>
        </trans-unit>
        <trans-unit id="3f7beaa4ee55fb71c23eb50c89657f496dec6493" translate="yes" xml:space="preserve">
          <source>Each of the following symbols behave like a &amp;lsquo;</source>
          <target state="translated">다음 각 기호는 '</target>
        </trans-unit>
        <trans-unit id="324c91e30099fbc60529755c27c3efdd05d14a69" translate="yes" xml:space="preserve">
          <source>Each of the following symbols behave like a&lt;code&gt;9&lt;/code&gt; until such point as all digits in the numeric value are exhausted and leading zeros are about to be inserted. In effect, these editing symbols define what should happen to those leading zero.</source>
          <target state="translated">다음의 각 기호 는 숫자 값의 모든 숫자가 소진되고 선행 0이 삽입 될 때까지 &lt;code&gt;9&lt;/code&gt; 처럼 작동합니다 . 실제로, 이러한 편집 기호는 0을 선행하는 사람들에게 발생할 일을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="88ebb4e5a49ceef8e46efb8e8acf86bf9a88eaf3" translate="yes" xml:space="preserve">
          <source>Each of these sections consists of a series of specific paragraphs (&lt;code&gt;SOURCE-COMPUTER&lt;/code&gt; and &lt;code&gt;OBJECT-COMPUTER&lt;/code&gt;, for example). Each of these paragraphs serves a specific purpose. If no code is required for the purpose one of the paragraphs serves, the entire paragraph may be omitted.</source>
          <target state="translated">이러한 각 섹션은 일련의 특정 단락 (예 : &lt;code&gt;SOURCE-COMPUTER&lt;/code&gt; 및 &lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; )으로 구성됩니다. 이러한 각 단락은 특정 용도로 사용됩니다. 단락 중 하나가 제공하는 목적에 코드가 필요하지 않은 경우 전체 단락을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9d2be1b968bb484ea3bd99238ffa88f1a9b097c" translate="yes" xml:space="preserve">
          <source>Each of these sections consists of a series of specific paragraphs &lt;code&gt;SOURCE-COMPUTER&lt;/code&gt;and&lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; for example). Each of these paragraphs serves a specific purpose. If no code is required for the purpose one of the paragraphs serves, the entire paragraph may be omitted.</source>
          <target state="translated">이러한 각 섹션은 예를 들어 &lt;code&gt;SOURCE-COMPUTER&lt;/code&gt; 및 &lt;code&gt;OBJECT-COMPUTER&lt;/code&gt; 와 같은 일련의 특정 단락으로 구성됩니다 . 이러한 각 단락은 특정 목적에 사용됩니다. 단락 중 하나가 제공하는 목적으로 코드가 필요하지 않으면 전체 단락을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49fb2845c3cf679efe7de1449e9eb5da506280b3" translate="yes" xml:space="preserve">
          <source>Each of these sections consists of code which serves a specific purpose. If no code is required for the purpose one of those sections serves, the entire section, including it&amp;rsquo;s header, may be omitted.</source>
          <target state="translated">이러한 각 섹션은 특정 목적을 수행하는 코드로 구성됩니다. 해당 섹션 중 하나가 제공하는 목적으로 코드가 필요하지 않으면 헤더를 포함하여 전체 섹션이 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbbe01c13c07c2a319c02b3a7fdf365a1c55a3a5" translate="yes" xml:space="preserve">
          <source>Each of these sections consists of code which serves a specific purpose. If no code is required for the purpose one of those sections serves, the entire section, including its header, may be omitted.</source>
          <target state="translated">각 섹션은 특정 목적에 맞는 코드로 구성됩니다. 해당 섹션 중 하나가 제공하는 목적에 코드가 필요하지 않은 경우 헤더를 포함하여 전체 섹션을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0ca9aaf89bca4498a4af9a6a7c47fe0fd680355" translate="yes" xml:space="preserve">
          <source>Each of those files is assumed to be already sorted according to the specifications set forth on the &lt;code&gt;MERGE&lt;/code&gt; statement&amp;rsquo;s  &lt;code&gt;KEY&lt;/code&gt; clause.</source>
          <target state="translated">각 파일은 &lt;code&gt;MERGE&lt;/code&gt; 문의 &lt;code&gt;KEY&lt;/code&gt; 절 에 명시된 사양에 따라 이미 정렬 된 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="e5476f035d3a01cedf662032e9a562423f2c27af" translate="yes" xml:space="preserve">
          <source>Each of those files is assumed to be already sorted according to the specifications set forth on the&lt;code&gt;MERGE&lt;/code&gt;statement&amp;rsquo;s&lt;code&gt;KEY&lt;/code&gt;</source>
          <target state="translated">각 파일은 &lt;code&gt;MERGE&lt;/code&gt; 문의 &lt;code&gt;KEY&lt;/code&gt; 에 명시된 사양에 따라 이미 정렬 된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="39b6b7cca90aab953adf3ec432fdd03b2921cced" translate="yes" xml:space="preserve">
          <source>Each page of a report is divided into as many as five (5) areas, as shown in the following diagram.</source>
          <target state="translated">보고서의 각 페이지는 다음 다이어그램과 같이 최대 5 개의 영역으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="dbc5af6ba1192408c07303d49748541aefc7c891" translate="yes" xml:space="preserve">
          <source>Each program consists of up to four  &lt;em&gt;Divisions&lt;/em&gt; (major groupings of sections, paragraphs and descriptive or procedural coding that all relate to a common purpose), named Identification, Environment, Data and Procedure.</source>
          <target state="translated">각 프로그램은 식별, 환경, 데이터 및 절차라는 이름 의 최대 4 개의 &lt;em&gt;부서&lt;/em&gt; (섹션, 단락 및 설명 또는 절차 적 코딩의 주요 그룹)로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e972c979eeb51709c3026fa1585338428e0bcde2" translate="yes" xml:space="preserve">
          <source>Each program consists of up to four &amp;rsquo;</source>
          <target state="translated">각 프로그램은 최대 4 개의 '</target>
        </trans-unit>
        <trans-unit id="0c16a7519f43118f3f20773610b8efc8daa8c7f8" translate="yes" xml:space="preserve">
          <source>Each report referenced on a &lt;code&gt;REPORT IS&lt;/code&gt; clause (see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;) must be described with a report description (&lt;code&gt;RD&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;REPORT IS&lt;/code&gt; 절 ( &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File / Sort-Description&lt;/a&gt; 참조)에서 참조되는 각 보고서 는 보고서 설명 ( &lt;code&gt;RD&lt;/code&gt; ) 과 함께 설명되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="41ad41c5b7c7e05b20b0cee772dbf1deebed0213" translate="yes" xml:space="preserve">
          <source>Each report referenced on a&lt;code&gt;REPORT IS&lt;/code&gt;clause (see &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;File/Sort-Description&lt;/a&gt;) must be described with a report description &lt;code&gt;RD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;REPORT IS&lt;/code&gt; 절 ( &lt;a href=&quot;#File_002fSort_002dDescription&quot;&gt;파일 / 정렬 설명&lt;/a&gt; 참조)에서 참조 된 각 보고서 는 보고서 설명 &lt;code&gt;RD&lt;/code&gt; 로 설명해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c43f0748874dff6862d449d932e3f73e50432ff7" translate="yes" xml:space="preserve">
          <source>Each set of counting instructions contains the following information:</source>
          <target state="translated">각 계산 지침 세트에는 다음 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1713797d1fd5be38aa62ec74f40cb5e4ea9a66cb" translate="yes" xml:space="preserve">
          <source>Each set of replacement instructions contains the following information:</source>
          <target state="translated">각 교체 지침 세트에는 다음 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="94096305d3992a99e3c2729f0f875135ae22be5f" translate="yes" xml:space="preserve">
          <source>Each specified switch must have at least one of a &lt;code&gt;IS &lt;var&gt;mnemonic-name-1&lt;/var&gt;&lt;/code&gt;, &lt;code&gt;ON STATUS&lt;/code&gt; or an &lt;code&gt;OFF STATUS&lt;/code&gt; option defined for it, otherwise there will be no way to reference the switch from within a GnuCOBOL program.</source>
          <target state="translated">지정된 각 스위치에는 &lt;code&gt;IS &lt;var&gt;mnemonic-name-1&lt;/var&gt;&lt;/code&gt; , &lt;code&gt;ON STATUS&lt;/code&gt; 또는 &lt;code&gt;OFF STATUS&lt;/code&gt; 옵션 중 하나 이상이 정의되어 있어야합니다. 그렇지 않으면 GnuCOBOL 프로그램 내에서 스위치를 참조 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec64521d31f73aadd610d57e3314c5c0cb07d6c8" translate="yes" xml:space="preserve">
          <source>Each specified switch must have at least one of a&lt;code&gt;IS &amp;lt;&lt;i&gt;mnemonic-name-1&lt;/i&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;ON STATUS&lt;/code&gt;or an&lt;code&gt;OFF STATUS&lt;/code&gt;option defined for it, otherwise there will be no way to reference the switch from within a GnuCOBOL program.</source>
          <target state="translated">지정된 각 스위치에는 &lt;code&gt;IS &amp;lt;&lt;i&gt;mnemonic-name-1&lt;/i&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;ON STATUS&lt;/code&gt; 또는 &lt;code&gt;OFF STATUS&lt;/code&gt; 옵션 중 하나 이상이 정의되어 있어야합니다. 그렇지 않으면 GnuCOBOL 프로그램 내에서 스위치를 참조 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e559cbff67ac689ef745772d42537a3b513d5011" translate="yes" xml:space="preserve">
          <source>Each symbolic character name will be associated with the corresponding &amp;lt;</source>
          <target state="translated">각 기호 문자 이름은 해당 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="2ee8b1f21d9474c60fbbb9caaacb2b2612673deb" translate="yes" xml:space="preserve">
          <source>Each symbolic character name will be associated with the corresponding &lt;var&gt;integer-1&lt;/var&gt;&lt;sup&gt;th&lt;/sup&gt; character in the alphabet named in the &lt;code&gt;IN&lt;/code&gt; clause. The integer values are selecting characters from the alphabet by their ordinal position and not by their numeric value; thus, an integer of 15 will select the 15&lt;sup&gt;th&lt;/sup&gt; character in the specified alphabet, regardless of the actual numeric value of the bit pattern that constitutes that character.</source>
          <target state="translated">각 기호 문자 이름은 &lt;code&gt;IN&lt;/code&gt; 절에 명명 된 알파벳 의 해당 &lt;var&gt;integer-1&lt;/var&gt; &lt;sup&gt;번째&lt;/sup&gt; 문자 와 연관됩니다 . 정수 값은 숫자 값이 아닌 서수 위치에 따라 알파벳에서 문자를 선택합니다. 따라서 정수 15는 해당 문자를 구성하는 비트 패턴의 실제 숫자 값에 관계없이 지정된 알파벳 의 15 &lt;sup&gt;번째&lt;/sup&gt; 문자를 선택합니다 .&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="98b45c1a48ea0c8af797bfc20035b54a3dfc2e12" translate="yes" xml:space="preserve">
          <source>Each time a &lt;code&gt;GENERATE&lt;/code&gt; statement (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) is executed against a detail report group defined for this &lt;code&gt;RD&lt;/code&gt;, the RWCS will check the contents of each &lt;var&gt;identifier-2&lt;/var&gt; data item; whenever an &lt;var&gt;identifier-9&lt;/var&gt;&amp;rsquo;s value has changed since the previous &lt;code&gt;GENERATE&lt;/code&gt;, a control break condition will be in effect for that &lt;var&gt;identifier-2&lt;/var&gt;.</source>
          <target state="translated">마다는 &lt;code&gt;GENERATE&lt;/code&gt; (참조 문 &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt; )이 정의 상세 보고서 그룹에 대해 실행되는 &lt;code&gt;RD&lt;/code&gt; 는 RWCS 각각의 내용 확인한다 &lt;var&gt;identifier-2&lt;/var&gt; 데이터 항목을; 마다 &lt;var&gt;identifier-9&lt;/var&gt; 이전 이후의 값이 변경 &lt;code&gt;GENERATE&lt;/code&gt; , 제어 중단 조건은에 유효한 것 &lt;var&gt;identifier-2&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="4c00430742f8eba1eaf3bd142512606b4b7f5494" translate="yes" xml:space="preserve">
          <source>Each time a&lt;code&gt;GENERATE&lt;/code&gt;statement (see &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt;) is executed against a detail report group defined for this&lt;code&gt;RD&lt;/code&gt; the RWCS will check the contents of each &amp;lt;</source>
          <target state="translated">마다는 &lt;code&gt;GENERATE&lt;/code&gt; (참조 문 &lt;a href=&quot;#GENERATE&quot;&gt;GENERATE&lt;/a&gt; )이 정의 상세 보고서 그룹에 대해 실행되는 &lt;code&gt;RD&lt;/code&gt; 각각의 내용을 검사 할 RWCS &amp;lt;</target>
        </trans-unit>
        <trans-unit id="48545f108d6d890063854ad082ddb7636b0f7c42" translate="yes" xml:space="preserve">
          <source>Each&lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt;directive must be terminated by an&lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt;</source>
          <target state="translated">각 &lt;code&gt;&amp;gt;&amp;gt;IF&lt;/code&gt; 지시문은 &lt;code&gt;&amp;gt;&amp;gt;END-IF&lt;/code&gt; 로 끝나야합니다.</target>
        </trans-unit>
        <trans-unit id="3fecee34669e35b4e24782aec546eab94e861c5a" translate="yes" xml:space="preserve">
          <source>Each&lt;code&gt;RD&lt;/code&gt;will have the following allocated for it:</source>
          <target state="translated">각 &lt;code&gt;RD&lt;/code&gt; 에는 다음이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="558bbf35a31701a51f5e603c87d6e37860e5bac5" translate="yes" xml:space="preserve">
          <source>Each&lt;code&gt;WHEN&lt;/code&gt;clause (other than the&lt;code&gt;WHEN OTHER&lt;/code&gt;</source>
          <target state="translated">각 &lt;code&gt;WHEN&lt;/code&gt; 절 ( &lt;code&gt;WHEN OTHER&lt;/code&gt; 이외)</target>
        </trans-unit>
        <trans-unit id="db708aa4613d2d89fc52c61a7a68b8e5310b35b1" translate="yes" xml:space="preserve">
          <source>Early versions of Micro Focus COBOL allowed programmers to access various runtime library routines by using a single two-digit hexadecimal number as the entry-point name. These were known as call-by-number routines. Over time, Micro Focus COBOL evolved, replacing most of the call-by-number routines with ones accessible using a more conventional call-by-name technique.</source>
          <target state="translated">초기 버전의 Micro Focus COBOL을 사용하면 프로그래머는 단일 두 자리 16 진 숫자를 시작점 이름으로 사용하여 다양한 런타임 라이브러리 루틴에 액세스 할 수있었습니다. 이것을 번호 별 호출 루틴이라고합니다. 시간이 지남에 따라 Micro Focus COBOL이 발전하여 대부분의 번호순 루틴을보다 일반적인 이름 별 통화 기술을 사용하여 액세스 가능한 루틴으로 대체했습니다.</target>
        </trans-unit>
        <trans-unit id="60914652372d8aacfba426f94ef0a27b6bd64788" translate="yes" xml:space="preserve">
          <source>Effortlessly providing arithmetic accuracy to 31 digits, with performance approaching that of well-written assembly-language programs. Don&amp;rsquo;t think this isn&amp;rsquo;t critically important to banks, investment houses and any business interested in tracking revenues, expenses and profits (duh - like ALL of them).</source>
          <target state="translated">잘 작성된 어셈블리 언어 프로그램의 성능에 근접한 성능으로 31 자리까지 산술 정확도를 손쉽게 제공합니다. 이것이 은행, 투자 회사 및 수익, 지출 및 이익을 추적하는 데 관심이있는 모든 비즈니스에 중요하지 않다고 생각하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a59fca542ae29ccf842788b4f2074620547d58d1" translate="yes" xml:space="preserve">
          <source>Eight (8) different colors may be specified for both the background (screen) and foreground (text) color of any row/column position on the screen. Colors are specified by number, although a copybook supplied with all GnuCOBOL distributions (</source>
          <target state="translated">화면에서 행 / 열 위치의 배경색 (화면)과 전경색 (텍스트) 모두에 대해 여덟 (8) 가지 색상을 지정할 수 있습니다. 모든 GnuCOBOL 배포판에 카피 북이 제공되지만 색상은 번호로 지정됩니다 (</target>
        </trans-unit>
        <trans-unit id="eb8c33f1bd7b54199aabb312bdff6ad20c4a00e4" translate="yes" xml:space="preserve">
          <source>Eight (8) different colors may be specified for both the background (screen) and foreground (text) color of any row/column position on the screen. Colors are specified by number, although a copybook supplied with all GnuCOBOL distributions (&quot;screenio.cpy&quot;) defines COB-COLOR-xxxxxx names for the various colors so they may be specified as a more meaningful name rather than a number. The eight colors, by number, with the constant names defined in screenio.cpy, are as follows:</source>
          <target state="translated">화면에서 행 / 열 위치의 배경 (화면) 및 전경 (텍스트) 색상 모두에 대해 8 가지 색상을 지정할 수 있습니다. 색상은 숫자로 지정되지만 모든 GnuCOBOL 배포판 ( &quot;screenio.cpy&quot;)과 함께 제공된 카피 북은 다양한 색상에 대해 COB-COLOR-xxxxxx 이름을 정의하므로 숫자가 아닌보다 의미있는 이름으로 지정 될 수 있습니다. screenio.cpy에 정의 된 상수 이름을 가진 숫자로 된 8 가지 색상은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="258a8dd8616decea722b746b080a919f0bae0599" translate="yes" xml:space="preserve">
          <source>Either a &lt;code&gt;BEFORE&lt;/code&gt; phrase, an &lt;code&gt;AFTER&lt;/code&gt; phrase or both may be specified. They may be specified in any order.</source>
          <target state="translated">어느 &lt;code&gt;BEFORE&lt;/code&gt; 문구, &lt;code&gt;AFTER&lt;/code&gt; 의 문구 또는 둘 모두를 지정할 수 있습니다. 임의의 순서로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd7c38f335668ca14fd913489d9d498092b7eb94" translate="yes" xml:space="preserve">
          <source>Either a statement that begins with a non decision-making verb and specifies an unconditional action to be taken or a conditional verb such as &lt;code&gt;IF&lt;/code&gt; or &lt;code&gt;EVALUATE&lt;/code&gt;, delimited by its explicit scope terminator (such as &lt;code&gt;END-IF&lt;/code&gt; or &lt;code&gt;END-EVALUATE&lt;/code&gt;). An imperative statement can consist of a sequence of imperative statements.</source>
          <target state="translated">비 의사 결정 동사로 시작하고 취해야 할 무조건 조치를 지정하는 문 또는 명시 적 범위 종결 자로 구분 된 &lt;code&gt;IF&lt;/code&gt; 또는 &lt;code&gt;EVALUATE&lt;/code&gt; 와 같은 조건부 동사 (예 : &lt;code&gt;END-IF&lt;/code&gt; 또는 &lt;code&gt;END-EVALUATE&lt;/code&gt; )입니다. 명령문은 일련의 명령문으로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0de188972590d50f27e84d7799cae74d5422d21a" translate="yes" xml:space="preserve">
          <source>Either a statement that begins with a non decision-making verb and specifies an unconditional action to be taken or a conditional verb such as&lt;code&gt;IF&lt;/code&gt;or&lt;code&gt;EVALUATE&lt;/code&gt; delimited by its explicit scope terminator (such as&lt;code&gt;END-IF&lt;/code&gt;or&lt;code&gt;END-EVALUATE&lt;/code&gt;. An imperative statement can consist of a sequence of imperative statements.</source>
          <target state="translated">비 의사 결정 동사로 시작하고 수행 할 무조건적 조치 또는 명시 적 범위 종결 자 (예 : &lt;code&gt;END-IF&lt;/code&gt; 또는 &lt;code&gt;END-EVALUATE&lt;/code&gt; ) 로 구분 된 조건부 동사 (예 : &lt;code&gt;IF&lt;/code&gt; 또는 &lt;code&gt;EVALUATE&lt;/code&gt; )를 지정 하는 명령문입니다. 일련의 명령문으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="30ea0da285c9a0b0bf611b3900abc0d992ef03bb" translate="yes" xml:space="preserve">
          <source>Either a&lt;code&gt;BEFORE&lt;/code&gt;phrase, an&lt;code&gt;AFTER&lt;/code&gt;phrase or both may be specified. They may be specified in any order.</source>
          <target state="translated">어느 &lt;code&gt;BEFORE&lt;/code&gt; 문구, &lt;code&gt;AFTER&lt;/code&gt; 의 문구 또는 둘 모두를 지정할 수 있습니다. 어떤 순서로도 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="571742073ce654e60b2c5b7dd0ecea8054f8056e" translate="yes" xml:space="preserve">
          <source>Either or both of the 1&lt;sup&gt;st&lt;/sup&gt; two arguments may be an alphanumeric literal, a group item or an elementary item appropriate to storing alphabetic or alphanumeric data. If the lengths of the two arguments are unequal, the shorter will be assumed to be padded to the right with spaces.</source>
          <target state="translated">&lt;sup&gt;첫 번째&lt;/sup&gt; 두 인수 중 하나 또는 둘 모두 는 영숫자 리터럴, 그룹 항목 또는 알파벳 또는 영숫자 데이터를 저장하는 데 적합한 기본 항목 &lt;sup&gt;일&lt;/sup&gt; 수 있습니다. 두 인수의 길이가 같지 않으면 더 짧은 것은 오른쪽이 공백으로 채워지는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0caa91b8f1f5f36fcf7fbe55099f1de176c8fde9" translate="yes" xml:space="preserve">
          <source>Either or both of the 1st two arguments may be an alphanumeric literal, a group item or an elementary item appropriate to storing alphabetic or alphanumeric data. If the lengths of the two arguments are unequal, the shorter will be assumed to be padded to the right with spaces.</source>
          <target state="translated">첫 번째 두 인수 중 하나 또는 둘다는 영숫자 리터럴, 그룹 항목 또는 영문자 또는 영숫자 데이터를 저장하기에 적합한 기본 항목 일 수 있습니다. 두 인수의 길이가 동일하지 않은 경우 공백으로 오른쪽에 더 짧은 것으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="2604514e99668b5fe356a2a35b37a6d80cc13bca" translate="yes" xml:space="preserve">
          <source>Either the &lt;code&gt;USAGE&lt;/code&gt; (see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of &lt;var&gt;index-name-1&lt;/var&gt; should be &lt;code&gt;INDEX&lt;/code&gt;, or &lt;var&gt;index-name-1&lt;/var&gt; must be identified in a table &lt;code&gt;INDEXED BY&lt;/code&gt; clause.</source>
          <target state="translated">어느 &lt;code&gt;USAGE&lt;/code&gt; (참조 &lt;a href=&quot;#USAGE&quot;&gt;사용&lt;/a&gt; 의) &lt;var&gt;index-name-1&lt;/var&gt; 해야 &lt;code&gt;INDEX&lt;/code&gt; , 또는 &lt;var&gt;index-name-1&lt;/var&gt; 테이블에 식별해야 &lt;code&gt;INDEXED BY&lt;/code&gt; 절.</target>
        </trans-unit>
        <trans-unit id="858e7defec8698672940f8ce436c406862616ecb" translate="yes" xml:space="preserve">
          <source>Either the name of an identifier or a procedure in the program. GnuCOBOL limits user-defined names to a maximum of 31 characters taken from the set of numeric digits, upper- and lower-case letters, hyphens and underscores. A user-defined name may neither begin nor end with a hyphen or underscore. User-defined names used as file names may additionally not begin with a digit although - unlike many other programming languages - user-defined names used as identifiers or procedure names may.</source>
          <target state="translated">프로그램의 식별자 또는 프로 시저 이름입니다. GnuCOBOL은 사용자 정의 이름을 숫자, 대문자 및 소문자, 하이픈 및 밑줄 집합에서 가져온 최대 31 자로 제한합니다. 사용자 정의 이름은 하이픈이나 밑줄로 시작하거나 끝날 수 없습니다. 파일 이름으로 사용되는 사용자 정의 이름은 다른 프로그래밍 언어와 달리 식별자 또는 프로 시저 이름으로 사용되는 사용자 정의 이름 일 수도 있지만 숫자로 시작하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7567d0d8aa3c2f98c0119f54054a4094bbdf6b09" translate="yes" xml:space="preserve">
          <source>Either the&lt;code&gt;USAGE&lt;/code&gt;(see &lt;a href=&quot;#USAGE&quot;&gt;USAGE&lt;/a&gt;) of &amp;lt;</source>
          <target state="translated">어느 &lt;code&gt;USAGE&lt;/code&gt; 는 (참조 &lt;a href=&quot;#USAGE&quot;&gt;사용&lt;/a&gt; 중) &amp;lt;</target>
        </trans-unit>
        <trans-unit id="12419b0638b06653e626b1a31d9f95a7e8c75d0a" translate="yes" xml:space="preserve">
          <source>Elementary Item</source>
          <target state="translated">초등학교 아이템</target>
        </trans-unit>
        <trans-unit id="f61c9f064c3d39237a20a4d7d3d38cc92ed48b49" translate="yes" xml:space="preserve">
          <source>End of file reached if reading forward or beginning-of-file reached if reading backward</source>
          <target state="translated">앞으로 읽을 경우 파일 끝에 도달하거나 뒤로 읽을 경우 파일 시작에 도달</target>
        </trans-unit>
        <trans-unit id="eb4a1c1bc69354df732a1fb660f7766fbc1365bb" translate="yes" xml:space="preserve">
          <source>End of page</source>
          <target state="translated">페이지 끝</target>
        </trans-unit>
        <trans-unit id="1f90eed9e128990aa3916d4821f0afedd06fce42" translate="yes" xml:space="preserve">
          <source>Entry-point</source>
          <target state="translated">Entry-point</target>
        </trans-unit>
        <trans-unit id="318f6eeac5e0a5f73cec3c1a7fec998a2d2b42bf" translate="yes" xml:space="preserve">
          <source>Entry-point Name</source>
          <target state="translated">진입 점 이름</target>
        </trans-unit>
        <trans-unit id="9b06bb34e16d4cae97cdcb9f7c6429d9591ae99a" translate="yes" xml:space="preserve">
          <source>Environment variables created or changed from within GnuCOBOL programs will be available to any sub-shell processes spawned by that program (i.e. &lt;code&gt;CALL &quot;SYSTEM&quot;&lt;/code&gt;) but will not be known to the shell or console window that started the GnuCOBOL program.</source>
          <target state="translated">GnuCOBOL 프로그램 내에서 생성되거나 변경된 환경 변수는 해당 프로그램에 의해 생성 된 모든 하위 쉘 프로세스 (예 : &lt;code&gt;CALL &quot;SYSTEM&quot;&lt;/code&gt; )에서 사용할 수 있지만 GnuCOBOL 프로그램을 시작한 쉘 또는 콘솔 창에는 알려지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24148f77bd77c65e8eb0f7d637191b454de38585" translate="yes" xml:space="preserve">
          <source>Environment variables created or changed from within GnuCOBOL programs will be available to any sub-shell processes spawned by that program (i.e. &lt;code&gt;CALL 'SYSTEM'&lt;/code&gt; (see &lt;a href=&quot;#SYSTEM&quot;&gt;SYSTEM&lt;/a&gt;)) but will not be known to the shell or console window that started the GnuCOBOL program.</source>
          <target state="translated">GnuCOBOL 프로그램 내에서 생성되거나 변경된 환경 변수는 해당 프로그램 (예 : &lt;code&gt;CALL 'SYSTEM'&lt;/code&gt; ( &lt;a href=&quot;#SYSTEM&quot;&gt;SYSTEM&lt;/a&gt; 참조 ))에 의해 생성 된 모든 하위 쉘 프로세스에서 사용할 수 있지만 GnuCOBOL 프로그램을 시작한 쉘 또는 콘솔 창에는 알려지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f15859f3eeefa48c8447da8cc8be18ae2f96c167" translate="yes" xml:space="preserve">
          <source>Environment variables created or changed from within GnuCOBOL programs will be available to any sub-shell processes spawned by that program (i.e. CALL &quot;SYSTEM&quot;) but will not be known to the shell or console window that started the GnuCOBOL program.</source>
          <target state="translated">GnuCOBOL 프로그램 내에서 작성 또는 변경된 환경 변수는 해당 프로그램이 생성 한 서브 쉘 프로세스 (예 : CALL &quot;SYSTEM&quot;)에서 사용할 수 있지만 GnuCOBOL 프로그램을 시작한 쉘 또는 콘솔 창에는 알려지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9b239553d90073cbc48e1842b57308d0f503d32" translate="yes" xml:space="preserve">
          <source>Environment variables created or changed from within GnuCOBOL programs will be available to any sub-shell processes spawned by that program (i.e.&lt;code&gt;CALL 'SYSTEM'&lt;/code&gt;(see &lt;a href=&quot;#SYSTEM&quot;&gt;SYSTEM&lt;/a&gt;)) but will not be known to the shell or console window that started the GnuCOBOL program.</source>
          <target state="translated">GnuCOBOL 프로그램 내에서 작성 또는 변경된 환경 변수는 해당 프로그램이 생성 한 모든 서브 쉘 프로세스 (예 : &lt;code&gt;CALL 'SYSTEM'&lt;/code&gt; ( &lt;a href=&quot;#SYSTEM&quot;&gt;SYSTEM&lt;/a&gt; 참조 ))에서 사용할 수 있지만 GnuCOBOL 프로그램을 시작한 쉘 또는 콘솔 창에는 알려지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="88fb9054570505b3fb04b9e1c9ce73dc5464f51a" translate="yes" xml:space="preserve">
          <source>Erased areas will have their foreground and background colors set to the attributes of the field containing the &lt;code&gt;ERASE&lt;/code&gt; clause.</source>
          <target state="translated">지워진 영역의 전경색과 배경색은 &lt;code&gt;ERASE&lt;/code&gt; 절을 포함하는 필드의 속성으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a831ca77884d7fa1627dca65d5bcf5b32460e5b1" translate="yes" xml:space="preserve">
          <source>Erased areas will have their foreground and background colors set to the attributes of the field containing the&lt;code&gt;ERASE&lt;/code&gt;clause.</source>
          <target state="translated">지워진 영역의 전경색과 배경색은 &lt;code&gt;ERASE&lt;/code&gt; 절을 포함하는 필드의 속성으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5da25ad570031cfc548ccf057713182fe2696bf6" translate="yes" xml:space="preserve">
          <source>Error Type</source>
          <target state="translated">오류 유형</target>
        </trans-unit>
        <trans-unit id="091e812df524f11e726f776aeeac24e5d0a26bc7" translate="yes" xml:space="preserve">
          <source>Esc was pressed</source>
          <target state="translated">Esc를 누르면</target>
        </trans-unit>
        <trans-unit id="c93b64e7bfc8fc13fce94a765a7f9b654e0636be" translate="yes" xml:space="preserve">
          <source>Evaluates to &lt;code&gt;FALSE AND (FALSE AND TRUE)&lt;/code&gt; which evaluates to &lt;code&gt;FALSE&lt;/code&gt;</source>
          <target state="translated">평가 &lt;code&gt;FALSE AND (FALSE AND TRUE)&lt;/code&gt; 로 평가 &lt;code&gt;FALSE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cba3e6319f42486d6d5910abc790586fcc04bda" translate="yes" xml:space="preserve">
          <source>Evaluates to &lt;code&gt;FALSE AND FALSE AND TRUE&lt;/code&gt; which evaluates to &lt;code&gt;FALSE&lt;/code&gt;</source>
          <target state="translated">로 평가 &lt;code&gt;FALSE AND FALSE AND TRUE&lt;/code&gt; 로 평가 &lt;code&gt;FALSE&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14c647d0b2997b2ea9d48fe5d26d0314573fe89e" translate="yes" xml:space="preserve">
          <source>Evaluates to &lt;code&gt;FALSE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;FALSE&lt;/code&gt; 로 평가</target>
        </trans-unit>
        <trans-unit id="c1d8ae6bdb5e5a0d55449c470c9109ca98750a63" translate="yes" xml:space="preserve">
          <source>Evaluates to &lt;code&gt;NOT (FALSE)&lt;/code&gt; which evaluates to &lt;code&gt;TRUE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;TRUE&lt;/code&gt; 로 평가되는 &lt;code&gt;NOT (FALSE)&lt;/code&gt; 으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="1f5ca6838b73d15a7c870d8245c1cd9c977900f9" translate="yes" xml:space="preserve">
          <source>Evaluates to &lt;code&gt;TRUE&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;TRUE&lt;/code&gt; 로 평가</target>
        </trans-unit>
        <trans-unit id="51f59465310b441b085b95d0d05314201ace6421" translate="yes" xml:space="preserve">
          <source>Evaluates to &lt;code&gt;TRUE&lt;/code&gt; (since AND has precedence over OR) - this is identical to the previous example</source>
          <target state="translated">&lt;code&gt;TRUE&lt;/code&gt; 로 평가됩니다 (AND가 OR보다 우선하므로)-이는 이전 예와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1d5c1c82e60d938ff99b4032766d8759f53965f9" translate="yes" xml:space="preserve">
          <source>Evaluates to FALSE</source>
          <target state="translated">거짓으로 평가</target>
        </trans-unit>
        <trans-unit id="7718b010814db3432233ea3bdf4b33cc8999b495" translate="yes" xml:space="preserve">
          <source>Evaluates to FALSE AND (FALSE AND TRUE) which evaluates to FALSE</source>
          <target state="translated">FALSE로 평가되는 FALSE AND (FALSE AND TRUE)로 평가</target>
        </trans-unit>
        <trans-unit id="e61648f7d13955bbfcf9bc100110e4859aa8fce4" translate="yes" xml:space="preserve">
          <source>Evaluates to FALSE AND FALSE AND TRUE which evaluates to FALSE</source>
          <target state="translated">FALSE로 평가되는 FALSE 및 FALSE AND TRUE로 평가</target>
        </trans-unit>
        <trans-unit id="dcd13fd025cd8853636d96d1e4febe9db19f5d33" translate="yes" xml:space="preserve">
          <source>Evaluates to NOT (FALSE) which evaluates to TRUE</source>
          <target state="translated">NOT으로 평가되는 NOT (FALSE), TRUE로 평가</target>
        </trans-unit>
        <trans-unit id="382d1cb13ed9d55b2c9159d78c596a71f0163e66" translate="yes" xml:space="preserve">
          <source>Evaluates to TRUE</source>
          <target state="translated">TRUE로 평가</target>
        </trans-unit>
        <trans-unit id="f75486ff1410d50667eeed0386b80ad55880746c" translate="yes" xml:space="preserve">
          <source>Evaluates to TRUE (since AND has precedence over OR) - this is identical to the previous example</source>
          <target state="translated">AND가 OR보다 우선하므로 TRUE로 평가됩니다. 이는 이전 예와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4e4ce6d4a34f8cbbb84a2b7c3ed5ad0ae2e0447d" translate="yes" xml:space="preserve">
          <source>Even without the &lt;code&gt;DEBUGGING MODE&lt;/code&gt; clause, it is still possible to compile debugging lines. Debugging lines may also be compiled by specifying the</source>
          <target state="translated">&lt;code&gt;DEBUGGING MODE&lt;/code&gt; 절이 없어도 디버깅 줄을 컴파일 할 수 있습니다. 디버깅 라인은 다음을 지정하여 컴파일 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d6d770c334405188a688baa0a731edb1fd48f77" translate="yes" xml:space="preserve">
          <source>Even without the&lt;code&gt;DEBUGGING MODE&lt;/code&gt;clause, it is still possible to compile debugging lines. Debugging lines may also be compiled by specifying the&lt;code&gt;-fdebugging-line&lt;/code&gt;switch</source>
          <target state="translated">&lt;code&gt;DEBUGGING MODE&lt;/code&gt; 절이 없어도 디버깅 라인을 컴파일 할 수 있습니다. &lt;code&gt;-fdebugging-line&lt;/code&gt; 스위치를 지정하여 디버깅 라인을 컴파일 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="91552a3314a03734e404c7b97ca06f17613df4cd" translate="yes" xml:space="preserve">
          <source>Every &amp;lt;</source>
          <target state="translated">모든 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="9f42753b88c31f07e6bcdfda34cbd05a816f1808" translate="yes" xml:space="preserve">
          <source>Every &amp;lt;&amp;lt;</source>
          <target state="translated">모든 &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="6ee5857b25477c47a887c2e413ca2373812abe76" translate="yes" xml:space="preserve">
          <source>Every &lt;code&gt;&lt;var&gt;LINKAGE-SECTION-Data-Item&lt;/var&gt;&lt;/code&gt; description must be terminated with a period.</source>
          <target state="translated">모든 &lt;code&gt;&lt;var&gt;LINKAGE-SECTION-Data-Item&lt;/var&gt;&lt;/code&gt; 설명은 마침표로 종료되어야합니다.</target>
        </trans-unit>
        <trans-unit id="661a1653e521852d600069b1bce07e2242a45008" translate="yes" xml:space="preserve">
          <source>Every &lt;code&gt;&lt;var&gt;LOCAL-STORAGE-SECTION-Data-Item&lt;/var&gt;&lt;/code&gt; description must be terminated with a period.</source>
          <target state="translated">모든 &lt;code&gt;&lt;var&gt;LOCAL-STORAGE-SECTION-Data-Item&lt;/var&gt;&lt;/code&gt; 설명은 마침표로 종료되어야합니다.</target>
        </trans-unit>
        <trans-unit id="cc642e5e9c10ed9f4fc2738c3c61201a96c951f8" translate="yes" xml:space="preserve">
          <source>Every &lt;code&gt;&lt;var&gt;WORKING-STORAGE-SECTION-Data-Item&lt;/var&gt;&lt;/code&gt; description must be terminated with a period.</source>
          <target state="translated">모든 &lt;code&gt;&lt;var&gt;WORKING-STORAGE-SECTION-Data-Item&lt;/var&gt;&lt;/code&gt; 설명은 마침표로 종료되어야합니다.</target>
        </trans-unit>
        <trans-unit id="75667c93ed71278715590e61f407a8a458223a72" translate="yes" xml:space="preserve">
          <source>Every &lt;var&gt;identifier-1&lt;/var&gt; that is an elementary item, including any that may have the &lt;code&gt;REDEFINES&lt;/code&gt; (see &lt;a href=&quot;#REDEFINES&quot;&gt;REDEFINES&lt;/a&gt;) clause in their descriptions.</source>
          <target state="translated">설명에 &lt;code&gt;REDEFINES&lt;/code&gt; ( &lt;a href=&quot;#REDEFINES&quot;&gt;REDEFINES&lt;/a&gt; 참조 ) 절이 있을 수있는 항목을 포함하여 기본 항목 인 모든 &lt;var&gt;identifier-1&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="57578c16661a3b7007d515ef52633af152da60d2" translate="yes" xml:space="preserve">
          <source>Every FILE-SECTION-Data-Item description must be terminated with a period.</source>
          <target state="translated">모든 FILE-SECTION-Data-Item 설명은 마침표로 종료되어야합니다.</target>
        </trans-unit>
        <trans-unit id="129d4af6fc8b739cc6b3cfc1e621b10bd80e7b97" translate="yes" xml:space="preserve">
          <source>Every data item at the same</source>
          <target state="translated">동일한 모든 데이터 항목</target>
        </trans-unit>
        <trans-unit id="77e9bb85e78385998b2213a27bb8d8376a21fddb" translate="yes" xml:space="preserve">
          <source>Every data item at the same&lt;code&gt;level&lt;/code&gt;of a hierarchy diagram such as the one you see here (if you were to make one, which you rarely &amp;mdash; if ever &amp;mdash; will, once you get used to this concept) must have the same level number.</source>
          <target state="translated">여기에 표시되는 것과 같이 동일한 &lt;code&gt;level&lt;/code&gt; 의 계층 구조 다이어그램에있는 모든 데이터 항목 (만약이 개념에 익숙해지면 거의 만들지 않는 경우)은 동일한 수준 번호를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="1874ad544d526d13a9380a9d6b8d4c67a66afb9c" translate="yes" xml:space="preserve">
          <source>Every entry-point has a name. That name must be unique for all programs that comprise an executable program. Entry-point names are defined using a subroutine&amp;rsquo;s &lt;code&gt;PROGRAM-ID&lt;/code&gt; paragraph, a user-defined function&amp;rsquo;s &lt;code&gt;FUNCTION-ID&lt;/code&gt; paragraph or via &lt;code&gt;ENTRY&lt;/code&gt; (see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;) statements coded in a subprogram&amp;rsquo;s procedure division.</source>
          <target state="translated">모든 진입 점에는 이름이 있습니다. 이 이름은 실행 가능한 프로그램을 구성하는 모든 프로그램에 대해 고유해야합니다. 진입 점 이름은 서브 루틴의 &lt;code&gt;PROGRAM-ID&lt;/code&gt; 단락, 사용자 정의 함수의 &lt;code&gt;FUNCTION-ID&lt;/code&gt; 단락을 사용하거나 서브 프로그램의 프로 시저 분할에서 코딩 된 &lt;code&gt;ENTRY&lt;/code&gt; ( &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt; 참조 ) 문을 통해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="464315bf9feceba501caec897c0b6079a97e791c" translate="yes" xml:space="preserve">
          <source>Every entry-point has a name. That name must be unique for all programs that comprise an executable program. Entry-point names are defined using a subroutine&amp;rsquo;s&lt;code&gt;PROGRAM-ID&lt;/code&gt;paragraph, a user-defined function&amp;rsquo;s&lt;code&gt;FUNCTION-ID&lt;/code&gt;paragraph or via&lt;code&gt;ENTRY&lt;/code&gt;(see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;) statements coded in a subprogram&amp;rsquo;s procedure division.</source>
          <target state="translated">모든 진입 점에는 이름이 있습니다. 해당 이름은 실행 프로그램을 구성하는 모든 프로그램에서 고유해야합니다. 진입 점 이름은 서브 루틴의 &lt;code&gt;PROGRAM-ID&lt;/code&gt; 단락, 사용자 정의 함수의 &lt;code&gt;FUNCTION-ID&lt;/code&gt; 단락을 사용하거나 서브 프로그램의 절차 부서에 코딩 된 &lt;code&gt;ENTRY&lt;/code&gt; ( &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt; 참조 ) 문을 통해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="6476d7be3c02b1b1ec9726d3ca1b4cc2a1d3dd85" translate="yes" xml:space="preserve">
          <source>Every file that has been referenced by a &lt;code&gt;SELECT&lt;/code&gt; statement (see &lt;a href=&quot;#SELECT&quot;&gt;SELECT&lt;/a&gt;) must also be described in the file section of the data division.</source>
          <target state="translated">a로 참조 된 모든 파일 &lt;code&gt;SELECT&lt;/code&gt; 문 (참조 &lt;a href=&quot;#SELECT&quot;&gt;SELECT를&lt;/a&gt; ) 또한 데이터 부문의 파일 섹션에 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="22c250c80a48d66257ba552ab395682e38c843f2" translate="yes" xml:space="preserve">
          <source>Every new level uses a level number that is strictly greater than the one used in the parent (next higher) level.</source>
          <target state="translated">모든 새 레벨은 상위 (다음 상위) 레벨에서 사용 된 레벨보다 엄격하게 큰 레벨 번호를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="50ca2cb95219666f9e5eca4a7c8de7e87d51cb54" translate="yes" xml:space="preserve">
          <source>Every non-&lt;code&gt;FILLER&lt;/code&gt; 3elementary item subordinate to &lt;var&gt;identifier-1&lt;/var&gt;, provided that elementary item neither contains a &lt;code&gt;REDEFINES&lt;/code&gt; clause in its definition nor belongs to a group item</source>
          <target state="translated">기본 항목 이 정의에 &lt;code&gt;REDEFINES&lt;/code&gt; 절을 포함 하지 않거나 그룹 항목에 속하지 않는 경우 모든 비 &lt;code&gt;FILLER&lt;/code&gt; 3 기본 항목은 &lt;var&gt;identifier-1&lt;/var&gt; 에 종속됩니다.</target>
        </trans-unit>
        <trans-unit id="e22c344c08f0a674fec53d0ccadbf31f6f3afb87" translate="yes" xml:space="preserve">
          <source>Every non-FILLER elementary item subordinate to &amp;lt;</source>
          <target state="translated">필러가 아닌 모든 기본 항목은 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="004439041e706926e609b461ee10ab7fd206e801" translate="yes" xml:space="preserve">
          <source>Every program has at least one entry-point &amp;mdash; known as the primary entry-point &amp;mdash; which corresponds to the first executable statement in the procedure division following the declaratives area, if any.</source>
          <target state="translated">모든 프로그램에는 선언 영역 다음에있는 프로 시저 분할의 첫 번째 실행 문에 해당하는 하나 이상의 진입 점이 기본 진입 점으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="1601a99f6446d942e939a06dabeb60be03814480" translate="yes" xml:space="preserve">
          <source>Every report has the same basic structure, as shown here, even though not all reports will have all of the groups shown. In fact, it is a very unusual report indeed that actually has every one of these groups:</source>
          <target state="translated">모든 보고서에 모든 그룹이 표시되는 것은 아니지만 모든 보고서는 여기에 표시된 것과 동일한 기본 구조를 갖습니다. 실제로 실제로 다음과 같은 그룹이 모두있는 매우 드문 보고서입니다.</target>
        </trans-unit>
        <trans-unit id="cec461b13ba9e76a1b658d70ba02bcb163ba81a4" translate="yes" xml:space="preserve">
          <source>Every report that employs control breaks has a natural hierarchy of those control breaks based upon the manner in which the data the report is being generated from is sorted. This concept is best understood using an example which assumes a COBOL program to process sales data collected from every computerized cash register across a chain of stores having multiple departments is being developed.</source>
          <target state="translated">제어 구분을 사용하는 모든 보고서에는 보고서가 생성되는 데이터가 정렬되는 방식에 따라 자연스럽게 제어 구분이 있습니다. 이 개념은 여러 부서의 상점 체인에 걸쳐 모든 전산화 된 금전 등록기에서 수집 된 판매 데이터를 처리하는 COBOL 프로그램을 가정하는 예를 사용하여 가장 잘 이해됩니다.</target>
        </trans-unit>
        <trans-unit id="429f5cb5b0f6e9260689b1e32055299a292139c7" translate="yes" xml:space="preserve">
          <source>Every sort file description (&lt;code&gt;SD&lt;/code&gt; or &lt;code&gt;FD&lt;/code&gt;) must be followed by at least one 01-level data item, except for file descriptions containing the &lt;code&gt;REPORT IS&lt;/code&gt; clause. These 01-level data items, in turn, may be broken down into subordinate group and elementary items. An 01-level data item defined here in the file section is also known as a  &lt;em&gt;Record&lt;/em&gt;, even if it is an elementary item, provided that elementary item lacks the  &lt;code&gt;CONSTANT&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;REPORT IS&lt;/code&gt; 절을 포함하는 파일 설명을 제외하고 모든 정렬 파일 설명 ( &lt;code&gt;SD&lt;/code&gt; 또는 &lt;code&gt;FD&lt;/code&gt; ) 뒤에는 하나 이상의 01 레벨 데이터 항목이 와야합니다 . 이러한 01 레벨 데이터 항목은 차례로 하위 그룹 및 기본 항목으로 나눌 수 있습니다. 여기에 파일 섹션에 정의 된 01 레벨 데이터 항목 은 기본 항목이더라도 기본 항목에 &lt;code&gt;CONSTANT&lt;/code&gt; 속성 이없는 경우 &lt;em&gt;레코드&lt;/em&gt; 라고도 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b56d93d247b7135e025b8bb06d8e4f1f8158cab1" translate="yes" xml:space="preserve">
          <source>Every time this program is executed, it will produce the same output, because the same sequence of pseudo-random numbers will be generated:</source>
          <target state="translated">이 프로그램이 실행될 때마다 동일한 시퀀스의 의사 난수가 생성되므로 동일한 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="631a83a57af68e8b556c535abcfba9d122280242" translate="yes" xml:space="preserve">
          <source>Executable File</source>
          <target state="translated">실행 가능 파일</target>
        </trans-unit>
        <trans-unit id="266766cb6674200866270efab0f914b9e8169b52" translate="yes" xml:space="preserve">
          <source>Executing a &lt;code&gt;DISPLAY UPON COMMAND-LINE&lt;/code&gt; will influence subsequent &lt;code&gt;ACCEPT FROM COMMAND-LINE&lt;/code&gt; statements (which will then return the value you displayed), but will not influence subsequent &lt;code&gt;ACCEPT FROM ARGUMENT-VALUE&lt;/code&gt; statements &amp;mdash; these will continue to return the original program execution parameters.</source>
          <target state="translated">&lt;code&gt;DISPLAY UPON COMMAND-LINE&lt;/code&gt; 에서 디스플레이 실행 이후의 &lt;code&gt;ACCEPT FROM COMMAND-LINE&lt;/code&gt; 문에 영향을 주지만 (그러면 표시 한 값이 반환됩니다) 이후 &lt;code&gt;ACCEPT FROM ARGUMENT-VALUE&lt;/code&gt; 문 에는 영향을주지 않습니다 . 원래 프로그램 실행 매개 변수를 계속 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c4aff9d44d0a696a912102a8ff52dc1f8917cec9" translate="yes" xml:space="preserve">
          <source>Executing a&lt;code&gt;DISPLAY UPON COMMAND-LINE&lt;/code&gt;will influence subsequent&lt;code&gt;ACCEPT FROM COMMAND-LINE&lt;/code&gt;statements (which will then return the value you displayed), but will not influence subsequent&lt;code&gt;ACCEPT FROM ARGUMENT-VALUE&lt;/code&gt;statements &amp;mdash; these will continue to return the original program execution parameters.</source>
          <target state="translated">&lt;code&gt;DISPLAY UPON COMMAND-LINE&lt;/code&gt; 실행하면 후속 &lt;code&gt;ACCEPT FROM COMMAND-LINE&lt;/code&gt; 문에 영향을 주지만 (표시된 값을 리턴 함) 이후 &lt;code&gt;ACCEPT FROM ARGUMENT-VALUE&lt;/code&gt; 문에 영향을 미치지 않습니다 . 이는 원래 프로그램 실행 매개 변수를 계속 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="294fd01fabe581df682eb4ea4d26a6143a102430" translate="yes" xml:space="preserve">
          <source>Executing the statement &lt;code&gt;SET &lt;var&gt;condition-name-1&lt;/var&gt; TO FALSE&lt;/code&gt; will cause &lt;var&gt;condition-name-1&lt;/var&gt;&amp;rsquo;s parent data item to take on the value specified on &lt;var&gt;condition-name-1&lt;/var&gt;&amp;rsquo;s &lt;code&gt;FALSE&lt;/code&gt; clause. If &lt;var&gt;condition-name-1&lt;/var&gt; does not have a &lt;code&gt;FALSE&lt;/code&gt; clause, the &lt;code&gt;SET&lt;/code&gt; (see &lt;a href=&quot;#SET&quot;&gt;SET&lt;/a&gt;) statement will generate an error message at compilation time.</source>
          <target state="translated">&lt;code&gt;SET &lt;var&gt;condition-name-1&lt;/var&gt; TO FALSE&lt;/code&gt; 문을 실행 하면 &lt;var&gt;condition-name-1&lt;/var&gt; 의 상위 데이터 항목이 &lt;var&gt;condition-name-1&lt;/var&gt; 의 &lt;code&gt;FALSE&lt;/code&gt; 절 에 지정된 값을 사용합니다 . 경우 &lt;var&gt;condition-name-1&lt;/var&gt; 이없는 &lt;code&gt;FALSE&lt;/code&gt; 절을의 &lt;code&gt;SET&lt;/code&gt; 는 (참조 &lt;a href=&quot;#SET&quot;&gt;SET&lt;/a&gt; 문이 컴파일시에 오류 메시지가 생성됩니다).</target>
        </trans-unit>
        <trans-unit id="47c73b41c17cd8d24bf63c33fb66c4d970e348d0" translate="yes" xml:space="preserve">
          <source>Executing the statement &lt;code&gt;SET &lt;var&gt;condition-name-1&lt;/var&gt; TO TRUE&lt;/code&gt; will cause &lt;var&gt;condition-name-1&lt;/var&gt;&amp;rsquo;s parent data item to take on the first value specified on &lt;var&gt;condition-name-1&lt;/var&gt;&amp;rsquo;s &lt;code&gt;VALUE&lt;/code&gt; clause.</source>
          <target state="translated">&lt;code&gt;SET &lt;var&gt;condition-name-1&lt;/var&gt; TO TRUE&lt;/code&gt; 문을 실행 하면 &lt;var&gt;condition-name-1&lt;/var&gt; 의 상위 데이터 항목이 &lt;var&gt;condition-name-1&lt;/var&gt; 의 &lt;code&gt;VALUE&lt;/code&gt; 절 에 지정된 첫 번째 값을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="b5eccd53038d68d6fe98e6c74bbc70fbdda0f1d8" translate="yes" xml:space="preserve">
          <source>Executing the statement&lt;code&gt;SET &amp;lt;&lt;i&gt;condition-name-1&lt;/i&gt;&amp;gt; TO FALSE&lt;/code&gt;will cause &amp;lt;</source>
          <target state="translated">&lt;code&gt;SET &amp;lt;&lt;i&gt;condition-name-1&lt;/i&gt;&amp;gt; TO FALSE&lt;/code&gt; 문을 실행 하면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="d3202330dc255528350ed15988600d69cebe769e" translate="yes" xml:space="preserve">
          <source>Executing the statement&lt;code&gt;SET &amp;lt;&lt;i&gt;condition-name-1&lt;/i&gt;&amp;gt; TO TRUE&lt;/code&gt;will cause &amp;lt;</source>
          <target state="translated">&lt;code&gt;SET &amp;lt;&lt;i&gt;condition-name-1&lt;/i&gt;&amp;gt; TO TRUE&lt;/code&gt; 문을 실행 하면 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="699332aeb03074ecdaa898353c6db354128e04e0" translate="yes" xml:space="preserve">
          <source>Execution Thread</source>
          <target state="translated">실행 스레드</target>
        </trans-unit>
        <trans-unit id="f7b699c1f1fca94c3574d70d8a9956ade47096d2" translate="yes" xml:space="preserve">
          <source>Execution of the calling program is suspended and control will transfer to the called program, as follows:</source>
          <target state="translated">호출 프로그램의 실행이 중지되고 다음과 같이 제어가 호출 된 프로그램으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="6fcf2812229dbe6eb074b9cb1f987a70fd54bb63" translate="yes" xml:space="preserve">
          <source>Execution will begin at the first executable statement following the subprograms entry-point. The entry point will be either the first executable statement following any &lt;code&gt;DECLARATIVES&lt;/code&gt; (see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) that might be present (if the subprogram was invoked using its primary entry-point name) or the first executable statement following the &lt;code&gt;ENTRY&lt;/code&gt; statement (see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;) naming the entry-point specified on the &lt;code&gt;CALL&lt;/code&gt; if the subprogram was invoked using an alternate entry point.</source>
          <target state="translated">실행은 서브 프로그램 진입 점 다음에 오는 첫 번째 실행 가능 문에서 시작됩니다. 중 어느 후 첫 실행 문 엔트리 포인트가 될 것입니다 &lt;code&gt;DECLARATIVES&lt;/code&gt; 이 (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES를&lt;/a&gt; 하거나 다음 첫 번째 실행 문 (서브 프로그램은 주 진입 점 이름을 사용하여 호출 된 경우))있을 수있는 그 &lt;code&gt;ENTRY&lt;/code&gt; 의 문을 (참조&lt;a href=&quot;#ENTRY&quot;&gt; ENTRY를&lt;/a&gt; 명명)를 서브 프로그램이 대체 진입 점을 사용하여 호출 된 경우 &lt;code&gt;CALL&lt;/code&gt; 에 지정된 진입 점.</target>
        </trans-unit>
        <trans-unit id="c1fdde2e7a98a43a8969fd6782e1df3e5e50ec04" translate="yes" xml:space="preserve">
          <source>Execution will begin at the first executable statement following the subprograms entry-point. The entry point will be either the first executable statement following any&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) that might be present (if the subprogram was invoked using its primary entry-point name) or the first executable statement following the&lt;code&gt;ENTRY&lt;/code&gt;statement (see &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY&lt;/a&gt;) naming the entry-point specified on the&lt;code&gt;CALL&lt;/code&gt;if the subprogram was invoked using an alternate entry point.</source>
          <target state="translated">서브 프로그램 진입 점 다음의 첫 번째 실행 문에서 실행이 시작됩니다. 엔트리 포인트는 것 중 어느 후 첫 실행 문 &lt;code&gt;DECLARATIVES&lt;/code&gt; 는 (참조 &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES를&lt;/a&gt; 하거나 다음 첫 번째 실행 문 (서브 프로그램은 주 진입 점 이름을 사용하여 호출 된 경우))있을 수있는 그 &lt;code&gt;ENTRY&lt;/code&gt; 의 문을 (참조 &lt;a href=&quot;#ENTRY&quot;&gt;ENTRY를&lt;/a&gt; 명명)를 서브 프로그램이 대체 시작점을 사용하여 호출 된 경우 &lt;code&gt;CALL&lt;/code&gt; 에 지정된 시작점.</target>
        </trans-unit>
        <trans-unit id="0c5a12fd2639f1c26778b5454e9680eb5ac97944" translate="yes" xml:space="preserve">
          <source>Execution will begin with the first executable statement in the procedure division following any &lt;code&gt;DECLARATIVES&lt;/code&gt; (see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) that might be present.</source>
          <target state="translated">실행은 &lt;code&gt;DECLARATIVES&lt;/code&gt; 다음에 오는 프로 시저 분할의 첫 번째 실행 가능 명령문으로 시작됩니다. 존재할 수있는 ( &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="df928d8218fa60aea80b123d18575cb29a66dc2a" translate="yes" xml:space="preserve">
          <source>Execution will begin with the first executable statement in the procedure division following any&lt;code&gt;DECLARATIVES&lt;/code&gt;(see &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt;) that might be present.</source>
          <target state="translated">실행은 존재할 수있는 &lt;code&gt;DECLARATIVES&lt;/code&gt; ( &lt;a href=&quot;#DECLARATIVES&quot;&gt;DECLARATIVES&lt;/a&gt; 참조 ) 다음에 프로 시저 분할의 첫 번째 실행 문으로 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="20886865e3b391a3ff09bedaa7cd18a43cf4535f" translate="yes" xml:space="preserve">
          <source>Execution will resume back in the calling program at the point where the returned value of the function is needed. At that point, the value in the   &lt;code&gt;RETURN-CODE&lt;/code&gt; special register will be used for the function&amp;rsquo;s value.</source>
          <target state="translated">함수의 반환 값이 필요한 지점에서 호출 프로그램에서 실행이 다시 시작됩니다. 그 시점에서 &lt;code&gt;RETURN-CODE&lt;/code&gt; 특수 레지스터의 값이 함수 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="813d8ff4c4f053c1fe5a4302c6f9c49604c7c000" translate="yes" xml:space="preserve">
          <source>Execution will resume back in the calling program at the point where the returned value of the function is needed. At that point, the value in the&lt;code&gt;RETURN-CODE&lt;/code&gt;special register will be used for the function&amp;rsquo;s value.</source>
          <target state="translated">함수의 반환 값이 필요한 시점에서 호출 프로그램에서 실행이 다시 시작됩니다. 이때 &lt;code&gt;RETURN-CODE&lt;/code&gt; 특수 레지스터의 값이 함수 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="66682ceffb06707a7edbe7536c201062e61176b8" translate="yes" xml:space="preserve">
          <source>Execution will resume back in the calling program with the first executable statement following the &lt;code&gt;CALL&lt;/code&gt; that invoked the subprogram.</source>
          <target state="translated">실행은 호출 프로그램에서 다시 시작되며 다음의 첫 번째 실행 문이 있습니다. &lt;code&gt;CALL&lt;/code&gt; 서브 프로그램을 호출 한 CALL 됩니다.</target>
        </trans-unit>
        <trans-unit id="6604bac134b018c911ef4c369060da53971d99cd" translate="yes" xml:space="preserve">
          <source>Execution will resume back in the calling program with the first executable statement following the&lt;code&gt;CALL&lt;/code&gt;that invoked the subprogram.</source>
          <target state="translated">서브 프로그램을 호출 한 &lt;code&gt;CALL&lt;/code&gt; 다음에 첫 번째 실행 문으로 호출 프로그램에서 실행이 다시 시작 됩니다.</target>
        </trans-unit>
        <trans-unit id="48fe8e9ca52a156853178d24b60a81903ae92574" translate="yes" xml:space="preserve">
          <source>Expiration of the &lt;code&gt;TIMEOUT&lt;/code&gt; timer &amp;mdash; this will be treated as if the &lt;code&gt;Enter&lt;/code&gt; key had been pressed with no data being entered.</source>
          <target state="translated">&lt;code&gt;TIMEOUT&lt;/code&gt; 만료 타이머 &amp;mdash; 데이터를 입력하지 않고 &lt;code&gt;Enter&lt;/code&gt; 키를 누른 것처럼 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="1c4f897e49f43d61c8c285a5f8b529c6df7d4952" translate="yes" xml:space="preserve">
          <source>Expiration of the&lt;code&gt;TIMEOUT&lt;/code&gt;timer &amp;mdash; this will be treated as if the Enter key had been pressed with no data being entered.</source>
          <target state="translated">&lt;code&gt;TIMEOUT&lt;/code&gt; 타이머의 만료 -이것은 데이터를 입력하지 않고 Enter 키를 누른 것처럼 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="97b695b9b9cfde3612c21b3add972cc0f21f4e26" translate="yes" xml:space="preserve">
          <source>Expression</source>
          <target state="translated">Expression</target>
        </trans-unit>
        <trans-unit id="d4f3d8cfa4bb2c410b3eceec3e30341ae311b92d" translate="yes" xml:space="preserve">
          <source>Extract a sub string from a string based on its starting character position and length</source>
          <target state="translated">시작 문자 위치 및 길이를 기준으로 문자열에서 하위 문자열 추출</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
