<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="ff4c946a3851841484bfe88da646bea6e5a5a750" translate="yes" xml:space="preserve">
          <source>Office paper material. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">사무실 종이 재료. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e5b4d5d08b2c4a1dd9ed75e0f01d5b0d8c6e227" translate="yes" xml:space="preserve">
          <source>Offline Installation</source>
          <target state="translated">오프라인 설치</target>
        </trans-unit>
        <trans-unit id="f04dd3eb6e5b722524af07586142a6a5e22a05d2" translate="yes" xml:space="preserve">
          <source>Offline geocoding is supported.</source>
          <target state="translated">오프라인 지오 코딩이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="e2b02b40206dadcaa999b070b1015221f9826829" translate="yes" xml:space="preserve">
          <source>Offline mapping is supported.</source>
          <target state="translated">오프라인 매핑이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0f03171d3974527f420ac51feda38bf492bf0e7c" translate="yes" xml:space="preserve">
          <source>Offline navigation is supported.</source>
          <target state="translated">오프라인 탐색이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4de115fa9165a74583fc9562660bb964a3f750b8" translate="yes" xml:space="preserve">
          <source>Offline places is supported.</source>
          <target state="translated">오프라인 장소가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1b3ad425580a2eef53462c2cf2e115d57798eec7" translate="yes" xml:space="preserve">
          <source>Offline routing is supported.</source>
          <target state="translated">오프라인 라우팅이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="223ce5d0faa863c1120f803c63b90fe913e088bc" translate="yes" xml:space="preserve">
          <source>Offscreen</source>
          <target state="translated">Offscreen</target>
        </trans-unit>
        <trans-unit id="c91f5afa194bf86b3169bcf5c239573fb510e226" translate="yes" xml:space="preserve">
          <source>Offset of the emission map mask. Default is &lt;code&gt;Qt.vector3d(0, 0, 0)&lt;/code&gt;.</source>
          <target state="translated">방출 맵 마스크의 오프셋. 기본값은 &lt;code&gt;Qt.vector3d(0, 0, 0)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="90db116c7b0ffc9c33b611e6e24d02b785766da5" translate="yes" xml:space="preserve">
          <source>Offset of the reflection map. Default is &lt;code&gt;0.5&lt;/code&gt;.</source>
          <target state="translated">반사 맵의 오프셋. 기본값은 &lt;code&gt;0.5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="10a4d688a6c48cc3dc2b288e36bf5b3636a47680" translate="yes" xml:space="preserve">
          <source>Offset of the roughness map. Default is &lt;code&gt;0.16&lt;/code&gt;.</source>
          <target state="translated">거칠기 맵의 오프셋. 기본값은 &lt;code&gt;0.16&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5bc62c6a6bdc8447e3e98a86b4a6c284573ceb44" translate="yes" xml:space="preserve">
          <source>OffsetData Struct</source>
          <target state="translated">오프셋 데이터 구조</target>
        </trans-unit>
        <trans-unit id="478b0ce81a8454b53cb8994943841aa6ee3577ce" translate="yes" xml:space="preserve">
          <source>OffsetData::abbreviation The abbreviation in effect at the datetime.</source>
          <target state="translated">OffsetData :: abbreviation 날짜 / 시간에 적용되는 약어입니다.</target>
        </trans-unit>
        <trans-unit id="809a2b71f3d6d907133331da1fcf794e18433002" translate="yes" xml:space="preserve">
          <source>OffsetData::atUtc The datetime of the offset data in UTC time.</source>
          <target state="translated">OffsetData :: atUtc 오프셋 데이터의 날짜 시간 (UTC 시간)입니다.</target>
        </trans-unit>
        <trans-unit id="d51b4e24aef300f101d0666b301db6b53d8915a9" translate="yes" xml:space="preserve">
          <source>OffsetData::daylightTimeOffset The DST offset component of the total offset.</source>
          <target state="translated">OffsetData :: daylightTimeOffset 총 오프셋의 DST 오프셋 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="b6a128d5c88c058a76a0bb3f99106b4d50940e3e" translate="yes" xml:space="preserve">
          <source>OffsetData::offsetFromUtc The total offset from UTC in effect at the datetime.</source>
          <target state="translated">OffsetData :: offsetFromUtc 날짜 시간에 적용된 UTC로부터의 총 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="5d8ebe0ff851df709200f23565e3b8c61bffe185" translate="yes" xml:space="preserve">
          <source>OffsetData::standardTimeOffset The standard time offset component of the total offset.</source>
          <target state="translated">OffsetData :: standardTimeOffset 총 오프셋의 표준 시간 오프셋 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="21e683ce4d08545b363ed41ad6d53878ec077e61" translate="yes" xml:space="preserve">
          <source>Offsets From UTC</source>
          <target state="translated">UTC로부터의 오프셋</target>
        </trans-unit>
        <trans-unit id="5db66a762da27792167b5e661317ef121ab59dcf" translate="yes" xml:space="preserve">
          <source>Offsets apply for horizontal center, vertical center, and baseline anchors.</source>
          <target state="translated">오프셋은 수평 중심, 수직 중심 및 기준선 앵커에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="083a5552133afe7c7b78d7e92bf25dc839408eb4" translate="yes" xml:space="preserve">
          <source>Often the item models will have a single role that contains information you want to map to multiple values. A typical example of this is a timestamp field when generating a bar graph with two time related axes, for example years and months. To enable mapping a single item model role to more than one data field, pattern matching and replacing mechanism is provided by item model proxies. You can also use this mechanism to reformat data even in one-to-one mapping cases.</source>
          <target state="translated">항목 모델에는 종종 여러 값에 매핑하려는 정보가 포함 된 단일 역할이 있습니다. 대표적인 예는 연도 및 월과 같이 두 개의 시간 관련 축이있는 막대 그래프를 생성 할 때 타임 스탬프 필드입니다. 단일 항목 모델 역할을 둘 이상의 데이터 필드에 매핑 할 수 있도록 항목 모델 프록시에서 패턴 일치 및 대체 메커니즘을 제공합니다. 이 메커니즘을 사용하여 일대일 매핑 사례에서도 데이터를 다시 포맷 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07351a73c13b6ecf21ea7d8a4dde2b05e544964c" translate="yes" xml:space="preserve">
          <source>Often this is used to update status information.</source>
          <target state="translated">상태 정보를 업데이트하는 데 종종 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3ffa543d2ed458a9b9a43ff40cd280625f0a189" translate="yes" xml:space="preserve">
          <source>Often when dealing with items in a scene, it can be useful to map coordinates and arbitrary shapes from the scene to an item, from item to item, or from the view to the scene. For example, when you click your mouse in &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;'s viewport, you can ask the scene what item is under the cursor by calling &lt;a href=&quot;qgraphicsview#mapToScene&quot;&gt;QGraphicsView::mapToScene&lt;/a&gt;(), followed by &lt;a href=&quot;qgraphicsscene#itemAt&quot;&gt;QGraphicsScene::itemAt&lt;/a&gt;(). If you want to know where in the viewport an item is located, you can call &lt;a href=&quot;qgraphicsitem#mapToScene&quot;&gt;QGraphicsItem::mapToScene&lt;/a&gt;() on the item, then &lt;a href=&quot;qgraphicsview#mapFromScene&quot;&gt;QGraphicsView::mapFromScene&lt;/a&gt;() on the view. Finally, if you use want to find what items are inside a view ellipse, you can pass a &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt; to mapToScene(), and then pass the mapped path to &lt;a href=&quot;qgraphicsscene#items&quot;&gt;QGraphicsScene::items&lt;/a&gt;().</source>
          <target state="translated">장면에서 항목을 처리 할 때 장면에서 항목으로, 항목에서 항목으로 또는보기에서 장면으로 좌표 및 임의 모양을 매핑하는 것이 유용 할 수 있습니다. 예를 들어, 당신이 당신의 마우스를 클릭 할 때 &lt;a href=&quot;qgraphicsview&quot;&gt;를 QGraphicsView&lt;/a&gt; 의 뷰포트를, 당신이 호출하여 커서 아래에 어떤 항목 장면 요청할 수 있습니다 &lt;a href=&quot;qgraphicsview#mapToScene&quot;&gt;를 QGraphicsView :: mapToScene를&lt;/a&gt; 다음 (), &lt;a href=&quot;qgraphicsscene#itemAt&quot;&gt;QGraphicsScene을 :: itemAt을&lt;/a&gt; (). 항목이 뷰포트에서 어디에 있는지 알고 싶다면 항목에서 &lt;a href=&quot;qgraphicsitem#mapToScene&quot;&gt;QGraphicsItem :: mapToScene&lt;/a&gt; ()을 호출 한 다음보기에서 &lt;a href=&quot;qgraphicsview#mapFromScene&quot;&gt;QGraphicsView :: mapFromScene&lt;/a&gt; ()을 호출 할 수 있습니다. 마지막으로 뷰 타원 안에있는 항목을 찾으려면 &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt; 를 mapToScene ()에 전달한 다음 매핑 된 경로를&lt;a href=&quot;qgraphicsscene#items&quot;&gt;QGraphicsScene :: items&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="e9d4b48fe3693b0cdf78b8dc6d9851b89bb75ecc" translate="yes" xml:space="preserve">
          <source>Often when linking against a library, qmake relies on the underlying platform to know what other libraries this library links against, and lets the platform pull them in. In many cases, however, this is not sufficient. For example, when statically linking a library, no other libraries are linked to, and therefore no dependencies to those libraries are created. However, an application that later links against this library will need to know where to find the symbols that the static library will require. qmake attempts to keep track of the dependencies of a library, where appropriate, if you explicitly enable tracking.</source>
          <target state="translated">라이브러리와 링크 할 때 qmake는 기본 플랫폼에 의존하여이 라이브러리가 링크하는 다른 라이브러리를 알고 플랫폼이 라이브러리를 가져 오도록합니다. 그러나 대부분의 경우 충분하지 않습니다. 예를 들어 라이브러리를 정적으로 링크 할 때 다른 라이브러리는 링크되지 않으므로 해당 라이브러리에 대한 종속성이 작성되지 않습니다. 그러나 나중에이 라이브러리와 링크되는 응용 프로그램은 정적 라이브러리에 필요한 기호를 찾을 위치를 알아야합니다. qmake는 명시 적으로 추적을 활성화 한 경우 적절한 경우 라이브러리의 종속성을 추적하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="8113d33edda2a9347e8827e56055228866817309" translate="yes" xml:space="preserve">
          <source>Often, QML applications are prototyped with test data that is later replaced by real data sources from C++ plugins. The &lt;code&gt;qmlscene&lt;/code&gt; utility assists in this aspect by loading test data into the application context. It looks for a directory named &lt;code&gt;dummydata&lt;/code&gt; in the same directory as the target QML file, and loads the .qml files in that directory as QML objects and bind them to the root context as properties named after the files.</source>
          <target state="translated">종종 QML 애플리케이션은 테스트 데이터로 프로토 타입 화되어 나중에 C ++ 플러그인의 실제 데이터 소스로 대체됩니다. &lt;code&gt;qmlscene&lt;/code&gt; 의 유틸리티는 응용 프로그램 컨텍스트에로드 테스트 데이터에 의해 이러한 측면에서 도움이됩니다. 대상 QML 파일과 동일한 디렉토리에서 &lt;code&gt;dummydata&lt;/code&gt; 라는 디렉토리를 찾고 해당 디렉토리의 .qml 파일을 QML 오브젝트로로드하고 파일의 이름을 딴 특성으로 루트 컨텍스트에 바인드합니다.</target>
        </trans-unit>
        <trans-unit id="2ff6652bbae9100b879243bc1708a5778f0cca77" translate="yes" xml:space="preserve">
          <source>Often, it is required to set a fill pattern similar to the styles in &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::BrushStyle&lt;/a&gt;. You can use the background-color property for &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::SolidPattern&lt;/a&gt;, &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::RadialGradientPattern&lt;/a&gt;, &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::LinearGradientPattern&lt;/a&gt; and &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::ConicalGradientPattern&lt;/a&gt;. The other patterns are easily achieved by creating a background image that contains the pattern.</source>
          <target state="translated">종종 &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: BrushStyle&lt;/a&gt; 의 스타일과 유사한 채우기 패턴을 설정해야합니다 . &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: SolidPattern&lt;/a&gt; , &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: RadialGradientPattern&lt;/a&gt; , &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: LinearGradientPattern&lt;/a&gt; 및 &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: ConicalGradientPattern에&lt;/a&gt; 배경색 속성을 사용할 수 있습니다 . 다른 패턴은 패턴이 포함 된 배경 이미지를 만들어 쉽게 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eff7f785639780a987136b4902b533bccaf698b9" translate="yes" xml:space="preserve">
          <source>Often, the design of RPC is such that different clients are independent of each other: for instance, two clients can ask a mapping service for directions and get different results.</source>
          <target state="translated">종종 RPC의 디자인은 서로 다른 클라이언트가 서로 독립적 이도록 설계됩니다. 예를 들어, 두 클라이언트는 매핑 서비스에 방향을 요청하고 다른 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="602ad5e704343341cb60cce74db092f1bad4f667" translate="yes" xml:space="preserve">
          <source>Often, the documentor knows which Qt module the link target is in. When the module name is known, use the module name as the</source>
          <target state="translated">종종 문서 작성자는 링크 대상이있는 Qt 모듈을 알고 있습니다. 모듈 이름을 알면 모듈 이름을</target>
        </trans-unit>
        <trans-unit id="ce673dc82d88a7fb26299bc0da6bea8af09e995c" translate="yes" xml:space="preserve">
          <source>Older QNX SDP releases and other architectures may also work, but are not subject to regular builds and testing.</source>
          <target state="translated">이전 QNX SDP 릴리스 및 기타 아키텍처도 작동 할 수 있지만 정기적 인 빌드 및 테스트 대상이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4d8b1438569bf0c09e303aa88ebfe324ecdff0d2" translate="yes" xml:space="preserve">
          <source>OldiesMusic</source>
          <target state="translated">OldiesMusic</target>
        </trans-unit>
        <trans-unit id="f84e621732c7417e4b038431f9cda4dfbe6e1e1e" translate="yes" xml:space="preserve">
          <source>Omits adding the padding equal signs at the end of the encoded data.</source>
          <target state="translated">인코딩 된 데이터 끝에 패딩 등호를 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="708c057c8ea1d7f4ab116e5d3cabcb22bb3a6b30" translate="yes" xml:space="preserve">
          <source>Omitting this import will allow you to have a QML environment without access to window system features.</source>
          <target state="translated">이 가져 오기를 생략하면 창 시스템 기능에 액세스하지 않고도 QML 환경을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="beb53630cea57a3b4463541f0e611323d0c3c7de" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;#macos&quot;&gt;macOS&lt;/a&gt;, if the default &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; is set after the application instance, the application will exit with &lt;a href=&quot;#qFatal&quot;&gt;qFatal&lt;/a&gt;(), and print a message that the default &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; should be set before the application instance.</source>
          <target state="translated">에 &lt;a href=&quot;#macos&quot;&gt;맥 OS&lt;/a&gt; 기본 경우, &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat이&lt;/a&gt; 응용 프로그램 인스턴스 후 설정, 응용 프로그램과 함께 종료됩니다 &lt;a href=&quot;#qFatal&quot;&gt;qFatal&lt;/a&gt; () 및 기본 있다는 메시지를 인쇄 &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat이&lt;/a&gt; 응용 프로그램 인스턴스하기 전에 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="48983f7907a89cb00fd4a0e1da0a76bd00c7750e" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;#macos&quot;&gt;macOS&lt;/a&gt;, the following are required:</source>
          <target state="translated">에 &lt;a href=&quot;#macos&quot;&gt;맥 OS&lt;/a&gt; , 다음이 필요합니다 :</target>
        </trans-unit>
        <trans-unit id="5f8f3bcad2004aa59e2b7948d34aca8342d16877" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;#macos&quot;&gt;macOS&lt;/a&gt;, there are no special requirements for enabling sandbox support.</source>
          <target state="translated">에 &lt;a href=&quot;#macos&quot;&gt;맥 OS&lt;/a&gt; , 샌드 박스 지원을 가능하게하기위한 특별한 요구 사항이 없습니다.</target>
        </trans-unit>
        <trans-unit id="02407378beec6ff1f9fd53476003148fce3032f0" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;MacOS&lt;/a&gt; the color dialog is only allowed to be non-modal.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 색상 대화 상자는 비 모달로 할 수있다.</target>
        </trans-unit>
        <trans-unit id="896e5aeb9f74a7eae8da5b7aefbd0e6400cc7a1c" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; adds a fullscreen button.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 전체 화면 버튼을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1263f61e81dd5282840aff4a8e24fd1f82c20e3b" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; adds a tool bar button (i.e., the oblong button that is on the top right of windows that have toolbars).</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 도구 모음 버튼을 추가합니다 (즉, 도구 모음이 윈도우의 상단 오른쪽에있는 직사각형 버튼).</target>
        </trans-unit>
        <trans-unit id="fe348f0673364ee4617b20e1f55989c2b3f17704" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS this function compares according the &quot;Order for sorted lists&quot; setting in the International preferences panel.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 및 iOS이 기능은 &quot;주문을위한 정렬 된 목록&quot;에 따라 비교하여 국제 환경 설정 패널에서 설정.</target>
        </trans-unit>
        <trans-unit id="b97b0a04a3472cc7c0aa2fab68d1ec5936119928" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS this returns the proper localized name for a bundle if the path &lt;a href=&quot;qfileinfo#isBundle&quot;&gt;isBundle&lt;/a&gt;(). On all other platforms an empty &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; is returned.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 와 iOS의 경우 경로 번들이 반환 적절한 지역화 된 이름 &lt;a href=&quot;qfileinfo#isBundle&quot;&gt;isBundle&lt;/a&gt; (). 다른 모든 플랫폼에서는 빈 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1bacab286a6bc6c27c2d11a36406a4fc8b1f9dba" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS this will point to the directory actually containing the executable, which may be inside an application bundle (if the application is bundled).</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 및 iOS이 실제로 (응용 프로그램이 번들로 제공되는 경우) 응용 프로그램 번들 내에서 될 수있는 실행 파일을 포함하는 디렉토리를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="74fca3806b524f89c61474a23c98de0edc165b5e" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS, &lt;a href=&quot;qsettings#allKeys&quot;&gt;allKeys&lt;/a&gt;() will return some extra keys for global settings that apply to all applications. These keys can be read using &lt;a href=&quot;qsettings#value&quot;&gt;value&lt;/a&gt;() but cannot be changed, only shadowed. Calling &lt;a href=&quot;qsettings#setFallbacksEnabled&quot;&gt;setFallbacksEnabled&lt;/a&gt;(false) will hide these global settings.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 및 iOS, &lt;a href=&quot;qsettings#allKeys&quot;&gt;해서 AllKeys는&lt;/a&gt; () 모든 응용 프로그램에 적용되는 전역 설정에 대한 몇 가지 여분의 키를 반환합니다. 이 키는 &lt;a href=&quot;qsettings#value&quot;&gt;값&lt;/a&gt; ()을 사용하여 읽을 수 있지만 변경할 수 없으며 그림자 만 있습니다. &lt;a href=&quot;qsettings#setFallbacksEnabled&quot;&gt;setFallbacksEnabled&lt;/a&gt; (false)를 호출 하면 이러한 전역 설정이 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="a9784bd0835cdc1d60a8d6be41cf3fae4c475ec0" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS, the CFPreferences API used by &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; expects Internet domain names rather than organization names. To provide a uniform API, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; derives a fake domain name from the organization name (unless the organization name already is a domain name, e.g. OpenOffice.org). The algorithm appends &quot;.com&quot; to the company name and replaces spaces and other illegal characters with hyphens. If you want to specify a different domain name, call &lt;a href=&quot;qcoreapplication#organizationDomain-prop&quot;&gt;QCoreApplication::setOrganizationDomain&lt;/a&gt;(), &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;QCoreApplication::setOrganizationName&lt;/a&gt;(), and &lt;a href=&quot;qcoreapplication#applicationName-prop&quot;&gt;QCoreApplication::setApplicationName&lt;/a&gt;() in your &lt;code&gt;main()&lt;/code&gt; function and then use the default &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; constructor. Another solution is to use preprocessor directives, for example:</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 및 iOS에서 사용하는 CFPreferences의 API &lt;a href=&quot;qsettings&quot;&gt;QSettings는&lt;/a&gt; 인터넷 도메인 이름이 아닌 조직의 이름을 기대하고있다. 균일 한 API를 제공하기 위해 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 는 조직 이름에서 가짜 도메인 이름을 파생합니다 (조직 이름이 이미 OpenOffice.org와 같은 도메인 이름이 아닌 한). 이 알고리즘은 회사 이름에 &quot;.com&quot;을 추가하고 공백 및 기타 잘못된 문자를 하이픈으로 바꿉니다. 다른 도메인 이름을 지정하려면 &lt;code&gt;main()&lt;/code&gt; 함수 에서 &lt;a href=&quot;qcoreapplication#organizationDomain-prop&quot;&gt;QCoreApplication :: setOrganizationDomain&lt;/a&gt; (), &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;QCoreApplication :: setOrganizationName&lt;/a&gt; () 및 &lt;a href=&quot;qcoreapplication#applicationName-prop&quot;&gt;QCoreApplication :: setApplicationName&lt;/a&gt; ()을 호출 한 다음 기본 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 를 사용하십시오.건설자. 또 다른 솔루션은 전 처리기 지시문을 사용하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da0aaa820fd6ef22793ef435bf386f39ba1162e8" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS, this function compares according the &quot;Order for sorted lists&quot; setting in the International prefereces panel.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 국제에서 설정 패널을 prefereces 및 iOS,이 기능은 &quot;정렬 된리스트가 순서&quot;에 따라 비교합니다.</target>
        </trans-unit>
        <trans-unit id="571535e6d5a4810b87bbb8adfbfdb99e81578b79" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS, you can access property list &lt;code&gt;.plist&lt;/code&gt; files by passing &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings::NativeFormat&lt;/a&gt; as second argument. For example:</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 및 iOS, 당신은 속성 목록에 액세스 할 수 있습니다 &lt;code&gt;.plist&lt;/code&gt; 전달하여 파일을 &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings :: NativeFormat을&lt;/a&gt; 두 번째 인수로. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd67470be80f5cf6282fa567bbbecb7e060ec1a1" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and on certain Linux desktop environments such as Ubuntu Unity, &lt;a href=&quot;qmenubar&quot;&gt;QMenuBar&lt;/a&gt; is a wrapper for using the system-wide menu bar. If you have multiple menu bars in one dialog the outermost menu bar (normally inside a widget with widget flag &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Window&lt;/a&gt;) will be used for the system-wide menu bar.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 및 우분투 유니티와 같은 특정 리눅스 데스크톱 환경에 &lt;a href=&quot;qmenubar&quot;&gt;QMenuBar는&lt;/a&gt; 시스템 전체 메뉴 표시 줄을 사용하는 래퍼입니다. 하나의 대화 상자에 여러 개의 메뉴 표시 줄이있는 경우 가장 바깥 쪽 메뉴 표시 줄 (일반적으로 위젯 플래그가 &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: Window 인&lt;/a&gt; 위젯 내부) )이 시스템 전체 메뉴 표시 줄에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="50371ff4facf12b43ac86104b79a75268fc089a3" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and with Qt version 4.3 or higher, clipboard changes made by other applications will only be detected when the application is activated.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 응용 프로그램이 활성화 될 때와 Qt는 버전 4.3 이상과는 다른 응용 프로그램에서 만든 클립 보드의 변화 만 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="e6ccdce7fdcb9c3206b9165c144f45728d52799a" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; by default, Qt swaps the Control and Meta (Command) keys (i.e., whenever Control is pressed, Qt sends Meta, and whenever Meta is pressed Control is sent). When this attribute is true, Qt will not do the flip. &lt;a href=&quot;qkeysequence#StandardKey-enum&quot;&gt;QKeySequence::StandardKey&lt;/a&gt; will also flip accordingly (i.e., &lt;a href=&quot;qkeysequence#StandardKey-enum&quot;&gt;QKeySequence::Copy&lt;/a&gt; will be Command+C on the keyboard regardless of the value set, though what is output for &lt;a href=&quot;qkeysequence#toString&quot;&gt;QKeySequence::toString&lt;/a&gt;() will be different).</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 는 기본적으로, Qt는이 제어 및 메타 (명령) 키를 교환합니다 (즉, 제어를 누를 때마다, Qt는 메타는 전송하고, 메타 누를 때마다 제어가 전송됩니다). 이 속성이 true이면 Qt는 플립을 수행하지 않습니다. &lt;a href=&quot;qkeysequence#StandardKey-enum&quot;&gt;QKeySequence :: StandardKey&lt;/a&gt; 도 그에 따라 뒤집 &lt;a href=&quot;qkeysequence#StandardKey-enum&quot;&gt;힙니다&lt;/a&gt; (예 : &lt;a href=&quot;qkeysequence#toString&quot;&gt;QKeySequence :: toString에&lt;/a&gt; 대해 출력되는 내용이 설정되어 있지만 QKeySequence :: Copy 는 값 설정에 상관없이 키보드에서 Command + C가됩니다) ()에 가됩니다).</target>
        </trans-unit>
        <trans-unit id="bffe222338b643c2477ba996114f1133f75cfd9c" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; only, if there is exactly one button with the role &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;QMessageBox::RejectRole&lt;/a&gt;, it is made the escape button.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 역할과 정확히 하나 개의 버튼이있는 경우에만, &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;QMessageBox :: RejectRole&lt;/a&gt; , 그것은 이스케이프 버튼을한다.</target>
        </trans-unit>
        <trans-unit id="f19cde677c2916be9dcaf95716c315a18f596126" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; versions 10.2 and 10.3, these files are used by default:</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 버전 10.2 및 10.3,이 파일은 기본적으로 사용됩니다</target>
        </trans-unit>
        <trans-unit id="137ab3c697e78f6f2e6deec928018a72318cf267" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;,</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="a2ba4249a4d1704d0e563fdfe0da86c2b5ffcda0" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, data goes to</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 데이터로 이동</target>
        </trans-unit>
        <trans-unit id="1cf94bbce32ce9a9a1f88a2545fed9e5441426cd" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, if</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 경우</target>
        </trans-unit>
        <trans-unit id="e02d7a3a20669ba308c919d34f684f48c01488d1" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, if the modality is set to &lt;a href=&quot;qt#WindowModality-enum&quot;&gt;Qt::WindowModal&lt;/a&gt; and the message box has a parent, then the message box will be a &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Sheet&lt;/a&gt;, otherwise the message box will be a standard dialog.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 모달로 설정되어있는 경우, &lt;a href=&quot;qt#WindowModality-enum&quot;&gt;Qt는 :: WindowModal&lt;/a&gt; 및 메시지 상자가 부모가, 다음 메시지 상자가 될 것입니다 &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt는 :: 시트&lt;/a&gt; 그렇지 않으면 메시지 상자는 표준 대화 상자가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="0881ce6136c22ae57b7049c765ec8e08e3b2c3f0" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, if you want your message box to appear as a &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Sheet&lt;/a&gt; of its</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 당신이 원하는 경우, 메시지 상자가로 표시하는 &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt는 :: 시트&lt;/a&gt; 의 그것</target>
        </trans-unit>
        <trans-unit id="bdd25851047c8427f1ea42edfa248f6d340c43f9" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, it is not possible to unpair a device. If Unpaired is requested, &lt;a href=&quot;qbluetoothlocaldevice#pairingFinished&quot;&gt;pairingFinished&lt;/a&gt;() is immediately emitted although the device remains paired. It is possible to request the pairing for a previously unpaired device. In addition &lt;a href=&quot;qbluetoothlocaldevice#Pairing-enum&quot;&gt;AuthorizedPaired&lt;/a&gt; has the same behavior as &lt;a href=&quot;qbluetoothlocaldevice#Pairing-enum&quot;&gt;Paired&lt;/a&gt;.</source>
          <target state="translated">일 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 장치를 연결 해제 할 수 없다. Unpaired가 요청되면 장치가 페어링 된 상태로 남아 있지만 &lt;a href=&quot;qbluetoothlocaldevice#pairingFinished&quot;&gt;pairingFinished&lt;/a&gt; ()가 즉시 방출됩니다. 이전에 페어링되지 않은 장치에 대한 페어링을 요청할 수 있습니다. 또한 &lt;a href=&quot;qbluetoothlocaldevice#Pairing-enum&quot;&gt;AuthorizedPaired&lt;/a&gt; 는 &lt;a href=&quot;qbluetoothlocaldevice#Pairing-enum&quot;&gt;Paired&lt;/a&gt; 와 동일한 동작을 합니다.</target>
        </trans-unit>
        <trans-unit id="97ccb6feb705e423758172c8ff7ae512c93b6598" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, permissions to access settings not belonging to the current user (i.e. &lt;a href=&quot;qsettings#Scope-enum&quot;&gt;SystemScope&lt;/a&gt;) have changed with 10.7 (Lion). Prior to that version, users having admin rights could access these. For 10.7 and 10.8 (Mountain Lion), only root can. However, 10.9 (Mavericks) changes that rule again but only for the native format (plist files).</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 현재 사용자 (예에 속하지 않는 설정에 액세스 권한 &lt;a href=&quot;qsettings#Scope-enum&quot;&gt;SystemScope는&lt;/a&gt; ) 10.7 (사자)로 변경되었습니다. 해당 버전 이전에는 관리자 권한이있는 사용자가 이에 액세스 할 수있었습니다. 10.7 및 10.8 (마운틴 라이온)의 경우 루트 만 가능합니다. 그러나 10.9 (Mavericks)는 해당 규칙을 다시 변경하지만 기본 형식 (plist 파일)에 대해서만 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="c988eedd182f7aa69e779c11100a56d0e5217c5e" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, security flags are not supported and will be ignored.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 보안 플래그는 지원되지 않으며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3daff32b3d70038ff27a9fff6456ce23c43ffd09" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, show the tool window even when the application is not active. By default, all tool windows are hidden when the application is inactive.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 응용 프로그램이 활성화되어 있지 않은 경우에도 도구 창을 보여줍니다. 기본적으로 응용 프로그램이 비활성화되면 모든 도구 창이 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="41bb25290e5ced6d2e4655900e8268895af65ec7" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, the Up/Down key bindings for Home/End are explicitly disabled. If you want such bindings (on any platform), you will need to construct them in QML.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 홈 / 엔드의 위 / 아래 키 바인딩은 명시 적으로 사용할 수 없습니다. 이러한 바인딩을 원하는 경우 (플랫폼에서) QML로 바인딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="d9360f7e65dc3917d81977d44c9e83bb1515131d" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, the about box is popped up as a modeless window; on other platforms, it is currently application modal.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 정보 상자는 모덜리스 창으로 팝업됩니다; 다른 플랫폼에서는 현재 응용 프로그램 모달입니다.</target>
        </trans-unit>
        <trans-unit id="ab3457bf26c7bbccfc755f084a6a734e19ac4bdd" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, the string returned resembles the sequence that is shown in the menu bar if</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 문자열과 유사에게 메뉴 바의 경우에 표시되는 순서를 반환</target>
        </trans-unit>
        <trans-unit id="3c209eddec42f62fe0b0847af7729ce53a32e681" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, the threaded render loop is not supported when building with XCode 10 (10.14 SDK) or later, since this opts in to layer-backed views on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 10.14. You can build with Xcode 9 (10.13 SDK) to opt out of layer-backing, in which case the threaded render loop is available and used by default.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 에 레이어 백업 뷰에이 OPTS 때문에, 나중에 엑스 코드 (10) (10.14 SDK) 또는 건물 때, 렌더 스레드 루프는 지원되지 않습니다 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 10.14. Xcode 9 (10.13 SDK)로 빌드하여 레이어 백업을 옵트 아웃 할 수 있습니다.이 경우 스레드 렌더링 루프를 사용할 수 있으며 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="20c8c82ed4737ad355dc66de46b9c968eba39f83" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, there is a difference between a window and view; normally expressed as widgets in Qt. Qt makes assumptions about its parent-child hierarchy that make it complex to put an arbitrary Qt widget into a hierarchy of &quot;normal&quot; views from Apple frameworks. &lt;a href=&quot;qmacnativewidget&quot;&gt;QMacNativeWidget&lt;/a&gt; bridges the gap between views and windows and makes it possible to put a hierarchy of Qt widgets into a non-Qt window or view.</source>
          <target state="translated">일 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 윈도우 및 뷰 사이의 차이가있다; 일반적으로 Qt에서 위젯으로 표시됩니다. Qt는 임의의 Qt 위젯을 Apple 프레임 워크의 &quot;정상&quot;뷰 계층 구조에 배치하기가 어려운 부모-자식 계층 구조를 가정합니다. &lt;a href=&quot;qmacnativewidget&quot;&gt;QMacNativeWidget&lt;/a&gt; 은보기와 창 사이의 간격을 메우고 Qt 위젯 계층을 Qt가 아닌 창이나보기에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4e9e1a6e0bd01c2b3df3d1e521de78fd87e87fc" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this corresponds to the Command keys.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 명령 키에이 해당한다.</target>
        </trans-unit>
        <trans-unit id="a03ef9a5a6ca2b6c7189ec951ef3efa94d47d173" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this corresponds to the Control keys. On Windows keyboards, this key is mapped to the Windows key.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 컨트롤 키에이 해당한다. Windows 키보드에서이 키는 Windows 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="0315922804130991e6d6ee4a53830a731f5ef05e" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this flag is always set to &lt;a href=&quot;qbluetooth#Security-enum&quot;&gt;QBluetooth::Secure&lt;/a&gt;.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; ,이 플래그는 항상로 설정되어 &lt;a href=&quot;qbluetooth#Security-enum&quot;&gt;QBluetooth :: 안전&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17ab0291187163bb381d29fb4917bd52100ce9ba" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this function will ignore the Proxy Auto Configuration settings, since it cannot execute the associated ECMAScript code.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 는 관련 인 ECMAScript 코드를 실행할 수 없기 때문에,이 기능은 프록시 자동 구성 설정을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="99de586dbee9328e2ad3dc83f95209b0bbbca885" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this function will obtain the proxy settings using the SystemConfiguration framework from Apple. It will apply the FTP, HTTP and HTTPS proxy configurations for queries that contain the protocol tag &quot;ftp&quot;, &quot;http&quot; and &quot;https&quot;, respectively. If the SOCKS proxy is enabled in that configuration, this function will use the SOCKS server for all queries. If SOCKS isn't enabled, it will use the HTTPS proxy for all TcpSocket and UrlRequest queries.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; ,이 기능은 애플에서에서 SystemConfiguration 프레임 워크를 사용하여 프록시 설정을 얻을 것이다. 프로토콜 태그 &quot;ftp&quot;, &quot;http&quot;및 &quot;https&quot;를 각각 포함하는 쿼리에 FTP, HTTP 및 HTTPS 프록시 구성을 적용합니다. 해당 구성에서 SOCKS 프록시가 사용 가능한 경우이 기능은 모든 조회에 SOCKS 서버를 사용합니다. SOCKS를 사용하지 않으면 모든 TcpSocket 및 UrlRequest 쿼리에 HTTPS 프록시를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9bd0075037d9af00366805910b74ee7b22c148a6" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this is currenly converted to a NSMenu, so the aboutToHide() signal is not emitted.</source>
          <target state="translated">일 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; aboutToHide () 신호가 방출되지 않도록,이 currenly하는 NSMenu로 변환된다.</target>
        </trans-unit>
        <trans-unit id="3e9b8a514ee8a5e1aefdd8de972ff8cbfed33d69" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this value is ignored as the platform does not permit access to the security parameter of the socket. By default the platform prefers secure/encrypted connections though and therefore this function always returns &lt;a href=&quot;qbluetooth#Security-enum&quot;&gt;QBluetooth::Secure&lt;/a&gt;.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 플랫폼이 소켓의 보안 매개 변수에 대한 액세스를 허용하지 않는 한,이 값은 무시됩니다. 기본적으로 플랫폼은 보안 / 암호화 된 연결을 선호 &lt;a href=&quot;qbluetooth#Security-enum&quot;&gt;하므로이&lt;/a&gt; 함수는 항상 QBluetooth :: Secure를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d46bca2f6d20f99c43e27ea2a02a87e7f1ccd8f5" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this works more at the application level and will cause the application icon to bounce in the dock.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; ,이 작품을 더 많은 응용 프로그램 수준에서 응용 프로그램 아이콘이 도크에 반송하게됩니다.</target>
        </trans-unit>
        <trans-unit id="ed641e37d6e60c795f761bd151b9333173ad7a4c" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;/iOS/tvOS CoreBluetooth does not expose/accept hardware addresses for LE devices; instead developers are supposed to use unique 128-bit UUIDs, generated by CoreBluetooth. These UUIDS will stay constant for the same central &amp;lt;-&amp;gt; peripheral pair and we use them when connecting to a remote device. For a controller in the &lt;a href=&quot;qlowenergycontroller#Role-enum&quot;&gt;CentralRole&lt;/a&gt;, this value will always be the one passed in when the controller object was created. For a controller in the &lt;a href=&quot;qlowenergycontroller#Role-enum&quot;&gt;PeripheralRole&lt;/a&gt;, this value is invalid.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; / 아이폰 OS / tvOS CoreBluetooth은 / 노출 LE 장치의 하드웨어 주소를 허용하지 않습니다; 대신 개발자는 CoreBluetooth에서 생성 한 고유 한 128 비트 UUID를 사용해야합니다. 이 UUIDS는 동일한 중앙 &amp;lt;-&amp;gt; 주변 장치 쌍에 대해 일정하게 유지되며 원격 장치에 연결할 때 사용합니다. &lt;a href=&quot;qlowenergycontroller#Role-enum&quot;&gt;CentralRole&lt;/a&gt; 의 컨트롤러의 경우이 값은 항상 컨트롤러 개체를 만들 때 전달 된 값입니다. &lt;a href=&quot;qlowenergycontroller#Role-enum&quot;&gt;PeripheralRole&lt;/a&gt; 의 컨트롤러에 대해서는 이 값이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d1fc5e449dc389fccc7ea9794a709d546ef66a0" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::HoverEnter&lt;/a&gt; events, this position will always be &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;(-1, -1).</source>
          <target state="translated">에 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: HoverEnter의&lt;/a&gt; 이벤트,이 위치는 항상있을 것입니다 &lt;a href=&quot;qpoint&quot;&gt;의 QPoint&lt;/a&gt; (-1, -1).</target>
        </trans-unit>
        <trans-unit id="eca3159a31c71a6096451f0020afb882ea28272e" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::HoverEnter&lt;/a&gt; events, this position will always be &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;(-1, -1).</source>
          <target state="translated">에 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: HoverEnter의&lt;/a&gt; 이벤트,이 위치는 항상있을 것입니다 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; (-1, -1).</target>
        </trans-unit>
        <trans-unit id="5be8cee74ee586a968e595661b0504acbb74fb12" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::HoverLeave&lt;/a&gt; events, this position will always be &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;(-1, -1).</source>
          <target state="translated">에 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: HoverLeave의&lt;/a&gt; 이벤트,이 위치는 항상있을 것입니다 &lt;a href=&quot;qpoint&quot;&gt;의 QPoint&lt;/a&gt; (-1, -1).</target>
        </trans-unit>
        <trans-unit id="d6065b3aece372537d4f0991300b9b49a9d7091a" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::HoverLeave&lt;/a&gt; events, this position will always be &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;(-1, -1).</source>
          <target state="translated">에 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: HoverLeave의&lt;/a&gt; 이벤트,이 위치는 항상있을 것입니다 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; (-1, -1).</target>
        </trans-unit>
        <trans-unit id="274f958c0eae3155ea8914ca95a23815e0090326" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;qtwebengine-platform-notes#macos&quot;&gt;macOS&lt;/a&gt;, depending on how Qt WebEngine is configured at build time, there are two possibilities how spellchecking data is found:</source>
          <target state="translated">에 &lt;a href=&quot;qtwebengine-platform-notes#macos&quot;&gt;맥 OS&lt;/a&gt; , Qt는 WebEngine이 빌드시에 구성 방식에 따라, 맞춤법 검사 데이터를 발견하는 방법을 두 가지 가능성이있다 :</target>
        </trans-unit>
        <trans-unit id="312cfb23402492c9dba9019443c70a3da3229225" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt;, the default value is the value of the environment variable &lt;code&gt;UCRTVERSION&lt;/code&gt;.</source>
          <target state="translated">에 &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt; , 디폴트 값은 환경 변수의 값입니다 &lt;code&gt;UCRTVERSION&lt;/code&gt; 은 .</target>
        </trans-unit>
        <trans-unit id="5248dab8a678e7827d8faf7dd52bc2a892f37839" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt;, this isn't relevant because the backend there always uses a composition swapchain which is associated with the ISwapChainPanel that backs &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; on that platform.</source>
          <target state="translated">에 &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt; 백엔드가 항상 백업이있는 ISwapChainPanel와 연관된 구성 swapchain 사용하기 때문에, 이것은 관련이 없습니다 &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; 해당 플랫폼에 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e6478c9d4b1aea6bb2f93a9091144157062c962" translate="yes" xml:space="preserve">
          <source>On Android and &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtbluetooth-attribution-bluez.html#&quot;&gt;BlueZ&lt;/a&gt; (version 5.46 or above), a connection to a service can not be established using a port. Calling this function will emit a &lt;a href=&quot;qbluetoothsocket#SocketError-enum&quot;&gt;ServiceNotFoundError&lt;/a&gt;.</source>
          <target state="translated">Android 및 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtbluetooth-attribution-bluez.html#&quot;&gt;BlueZ&lt;/a&gt; (버전 5.46 이상)에서는 포트를 사용하여 서비스에 연결할 수 없습니다. 이 함수를 호출하면 &lt;a href=&quot;qbluetoothsocket#SocketError-enum&quot;&gt;ServiceNotFoundError가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="aa0bc4d8e5d48c5512bb81f57e44159d847bb87e" translate="yes" xml:space="preserve">
          <source>On Android and &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtbluetooth-attribution-bluez.html&quot;&gt;BlueZ&lt;/a&gt; (version 5.46 or above), a connection to a service can not be established using a port. Calling this function will emit a &lt;a href=&quot;qbluetoothsocket#SocketError-enum&quot;&gt;ServiceNotFoundError&lt;/a&gt;.</source>
          <target state="translated">Android 및 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtbluetooth-attribution-bluez.html&quot;&gt;BlueZ&lt;/a&gt; (버전 5.46 이상)에서는 포트를 사용하여 서비스에 연결할 수 없습니다. 이 함수를 호출하면 &lt;a href=&quot;qbluetoothsocket#SocketError-enum&quot;&gt;ServiceNotFoundError가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="815f65d23f664d13f8648829ba0d4205930d38fa" translate="yes" xml:space="preserve">
          <source>On Android and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, it is not possible to retrieve a list of connected devices. It is only possible to listen to (dis)connect changes. For convenience, this class monitors all connect and disconnect events since its instanciation and returns the current list when calling this function. Therefore it is possible that this function returns an empty list shortly after creating an instance.</source>
          <target state="translated">Android 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서는 연결된 장치 목록을 검색 할 수 없습니다. 연결 변경 사항을들을 수 있습니다. 편의상이 클래스는 인스턴스화 이후 모든 연결 및 연결 끊기 이벤트를 모니터하고이 함수를 호출 할 때 현재 목록을 리턴합니다. 따라서이 함수는 인스턴스를 생성 한 직후 빈 목록을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19265de97bfc16b2f9ea0375c004e5540a968f5f" translate="yes" xml:space="preserve">
          <source>On Android and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this feature is not supported and returns 0.</source>
          <target state="translated">Android 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서이 기능은 지원되지 않으며 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="856613fd1b6f579b13b8d57c43c2bf1969feaf49" translate="yes" xml:space="preserve">
          <source>On Android and macOS, it is not possible to retrieve a list of connected devices. It is only possible to listen to (dis)connect changes. For convenience, this class monitors all connect and disconnect events since its instanciation and returns the current list when calling this function. Therefore it is possible that this function returns an empty list shortly after creating an instance.</source>
          <target state="translated">Android 및 macOS에서는 연결된 장치 목록을 검색 할 수 없습니다. 연결 변경 사항을 청취 (연결 해제)하는 것만 가능합니다. 편의를 위해이 클래스는 인스턴스 이후의 모든 연결 및 연결 해제 이벤트를 모니터링하고이 함수를 호출 할 때 현재 목록을 반환합니다. 따라서이 함수는 인스턴스 생성 직후 빈 목록을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22cbf326052fa8032e9e9507bfd6093a8b8234e7" translate="yes" xml:space="preserve">
          <source>On Android and macOS, this feature is not supported and returns 0.</source>
          <target state="translated">Android 및 macOS에서는이 기능이 지원되지 않으며 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="63fcd2d9c70d71102c353c1cb82e59375e7f08d8" translate="yes" xml:space="preserve">
          <source>On Android, Vulkan headers were added in API level 24 of the NDK.</source>
          <target state="translated">Android에서는 Vulkan 헤더가 NDK의 API 레벨 24에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="be4db8b98b4f6164235f4d89c54546ee114c1c59" translate="yes" xml:space="preserve">
          <source>On Android, apps are distributed in packages called</source>
          <target state="translated">Android에서 앱은</target>
        </trans-unit>
        <trans-unit id="08898b8735cdaec5447779b90e5ed1d5212126a2" translate="yes" xml:space="preserve">
          <source>On Android, apps are distributed to devices as &lt;b&gt;APK&lt;/b&gt; packages. For distributing apps in Google Play, a different format called &lt;b&gt;AAB&lt;/b&gt; is used instead. For more information, see &lt;a href=&quot;android-publishing-to-googleplay&quot;&gt;Publishing to Google Play&lt;/a&gt;.</source>
          <target state="translated">Android에서 앱은 &lt;b&gt;APK&lt;/b&gt; 패키지 로 기기에 배포 됩니다. Google Play에서 앱을 배포 하기 위해 대신 &lt;b&gt;AAB&lt;/b&gt; 라는 다른 형식 이 사용됩니다. 자세한 내용은 &lt;a href=&quot;android-publishing-to-googleplay&quot;&gt;Google Play에 게시를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dbc9aae4c83116bcdc68d109344ce9e60a8f4125" translate="yes" xml:space="preserve">
          <source>On Android, only RFCOMM connections are possible. This function ignores any socket protocol indicator and assumes RFCOMM.</source>
          <target state="translated">Android에서는 RFCOMM 연결 만 가능합니다. 이 기능은 모든 소켓 프로토콜 표시기를 무시하고 RFCOMM을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="770e981e9a4839b09d200fe33ae180ff79808d01" translate="yes" xml:space="preserve">
          <source>On Android, the local name cannot be changed. Android always uses the device name. If this local name is not empty, the Android implementation includes the device name in the advertisement packet; otherwise the device name is omitted from the advertisement packet.</source>
          <target state="translated">Android에서는 로컬 이름을 변경할 수 없습니다. Android는 항상 기기 이름을 사용합니다. 이 로컬 이름이 비어 있지 않으면 Android 구현은 광고 패킷에 장치 이름을 포함합니다. 그렇지 않으면 장치 이름이 보급 알림 패킷에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="f65b58aaa1b281afed9ed3918396f4b1bdf264b1" translate="yes" xml:space="preserve">
          <source>On Android, the service connection can directly be established using the UUID of the remote service. Therefore the platform does not require the &lt;a href=&quot;qbluetoothsocket#SocketState-enum&quot;&gt;ServiceLookupState&lt;/a&gt; and &lt;a href=&quot;qbluetoothsocket#socketType&quot;&gt;socketType&lt;/a&gt;() is always set to &lt;a href=&quot;qbluetoothserviceinfo#Protocol-enum&quot;&gt;QBluetoothServiceInfo::RfcommProtocol&lt;/a&gt;.</source>
          <target state="translated">Android에서는 원격 서비스의 UUID를 사용하여 서비스 연결을 직접 설정할 수 있습니다. 따라서 플랫폼은 필요하지 않습니다 &lt;a href=&quot;qbluetoothsocket#SocketState-enum&quot;&gt;ServiceLookupState&lt;/a&gt; 및 &lt;a href=&quot;qbluetoothsocket#socketType&quot;&gt;socketType이&lt;/a&gt; ()는 항상로 설정 &lt;a href=&quot;qbluetoothserviceinfo#Protocol-enum&quot;&gt;QBluetoothServiceInfo :: RfcommProtocol을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d89c9874989e9b8b9d98b80e3b3a534396717417" translate="yes" xml:space="preserve">
          <source>On Android, this timeout is not adjustable and therefore ignored.</source>
          <target state="translated">Android에서는이 시간 제한을 조정할 수 없으므로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6416a86402f10d7bee16b446d89f7c5bff574c53" translate="yes" xml:space="preserve">
          <source>On Bluez this property is set to &lt;a href=&quot;qbluetooth#Security-enum&quot;&gt;QBluetooth::Authorization&lt;/a&gt; by default.</source>
          <target state="translated">Bluez에서이 속성은 기본적 으로 &lt;a href=&quot;qbluetooth#Security-enum&quot;&gt;QBluetooth :: Authorization&lt;/a&gt; 으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="38be6ebf6ed6321d81be56cae6640824c62d19dc" translate="yes" xml:space="preserve">
          <source>On Embedded Linux and X11 platforms, parts of this class rely on code obtained under the following licenses:</source>
          <target state="translated">임베디드 Linux 및 X11 플랫폼에서이 클래스의 일부는 다음 라이센스에 따라 얻은 코드에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="39517387790a4ddc25d1fee2b8ee49b79463ca57" translate="yes" xml:space="preserve">
          <source>On Embedded Linux systems that do not have their terminal sessions disabled, the behavior on a key press can be confusing as input event is processed by the Qt application and the tty. To overcome this, the following options are available:</source>
          <target state="translated">터미널 세션을 비활성화하지 않은 내장 Linux 시스템에서는 입력 이벤트가 Qt 응용 프로그램 및 tty에 의해 처리 될 때 키 누름 동작이 혼동 될 수 있습니다. 이를 극복하기 위해 다음 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecdf72d25c9c90b4bc50cd384c795e20986e8959" translate="yes" xml:space="preserve">
          <source>On Embedded Linux systems that don't have their terminal sessions disabled, the behavior on a key press can be confusing, as the input event is processed by the Qt application and the tty. To overcome this, the following options are available:</source>
          <target state="translated">터미널 세션이 비활성화되지 않은 임베디드 Linux 시스템에서는 입력 이벤트가 Qt 응용 프로그램과 tty에 의해 처리되기 때문에 키 누름 동작이 혼란 스러울 수 있습니다. 이를 극복하기 위해 다음 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1903a3af5f94e99f63f667d5b59e51dbaf4f5865" translate="yes" xml:space="preserve">
          <source>On Embedded Linux systems, there are multiple platform plugins that you can use: EGLFS, &lt;a href=&quot;#linuxfb&quot;&gt;LinuxFB&lt;/a&gt;, DirectFB, or Wayland. However, the availability of these plugins depend on how Qt is configured.</source>
          <target state="translated">임베디드 Linux 시스템에는 EGLFS, &lt;a href=&quot;#linuxfb&quot;&gt;LinuxFB&lt;/a&gt; , DirectFB 또는 Wayland 와 같이 사용할 수있는 여러 플랫폼 플러그인이 있습니다 . 그러나 이러한 플러그인의 가용성은 Qt 구성 방법에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="98bec7ba4ddeace89ae6061646dac31811f0b50d" translate="yes" xml:space="preserve">
          <source>On Embedded Linux systems, there are multiple platform plugins that you can use: EGLFS, &lt;a href=&quot;embedded-linux#linuxfb&quot;&gt;LinuxFB&lt;/a&gt;, DirectFB, or Wayland. However, the availability of these plugins depend on how Qt is configured.</source>
          <target state="translated">임베디드 Linux 시스템에는 EGLFS, &lt;a href=&quot;embedded-linux#linuxfb&quot;&gt;LinuxFB&lt;/a&gt; , DirectFB 또는 Wayland 와 같이 사용할 수있는 여러 플랫폼 플러그인이 있습니다 . 그러나 이러한 플러그인의 가용성은 Qt 구성 방법에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b72b71796549861f9cc9c6ae3627134f48e74eed" translate="yes" xml:space="preserve">
          <source>On GPUs that use a tiled rendering architecture, which is common in mobile and embedded systems, it is recommended to set this to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">모바일 및 임베디드 시스템에서 일반적으로 사용되는 타일 렌더링 아키텍처를 사용하는 GPU에서는이를 &lt;code&gt;false&lt;/code&gt; 로 설정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c875176e29005a39575f662aa8a4e291ef8024c9" translate="yes" xml:space="preserve">
          <source>On INTEGRITY, the returned value is the &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; socket descriptor and the type is defined by &lt;a href=&quot;qtcpserver#socketDescriptor&quot;&gt;socketDescriptor&lt;/a&gt;.</source>
          <target state="translated">INTEGRITY에서 리턴 된 값은 &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; 소켓 설명자이고 유형은 &lt;a href=&quot;qtcpserver#socketDescriptor&quot;&gt;socketDescriptor에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="65546d18a537a44a71a31b3293a6734b0f1a3265" translate="yes" xml:space="preserve">
          <source>On INTEGRITY, the returned value is the &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; socket descriptor and the type is defined by &lt;a href=&quot;qabstractsocket#socketDescriptor&quot;&gt;socketDescriptor&lt;/a&gt;.</source>
          <target state="translated">INTEGRITY에서 리턴 된 값은 &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; 소켓 설명자이고 유형은 &lt;a href=&quot;qabstractsocket#socketDescriptor&quot;&gt;socketDescriptor에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="11d7dd25953d11e666864822cf6e9d7877cb7d94" translate="yes" xml:space="preserve">
          <source>On Linux systems, it will try to determine the distribution version and will return that. This is also done on Debian/kFreeBSD, so this function will return Debian version in that case.</source>
          <target state="translated">Linux 시스템에서는 배포 버전을 확인하려고 시도하고이를 반환합니다. 이것은 Debian / kFreeBSD에서도 수행되므로이 ​​경우 데비안 버전을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="050fee7dfb12508ea2f91e1c95c371c4d9b0ee6e" translate="yes" xml:space="preserve">
          <source>On Linux, Clang or GCC version 5 or later is required. Supported configurations are &lt;code&gt;linux-g++&lt;/code&gt; and &lt;code&gt;linux-clang&lt;/code&gt;.</source>
          <target state="translated">Linux에서는 Clang 또는 GCC 버전 5 이상이 필요합니다. 지원되는 구성은 &lt;code&gt;linux-g++&lt;/code&gt; 및 &lt;code&gt;linux-clang&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6f1e0f08920cbc420155221e187795a3a98c2467" translate="yes" xml:space="preserve">
          <source>On Linux, Clang or GCC version 5 or later is required. Supported configurations are &lt;code&gt;linux-g++&lt;/code&gt;, &lt;code&gt;linux-clang&lt;/code&gt; and &lt;code&gt;linux-clang-libc++&lt;/code&gt;</source>
          <target state="translated">Linux에서는 Clang 또는 GCC 버전 5 이상이 필요합니다. 지원되는 구성은 &lt;code&gt;linux-g++&lt;/code&gt; , &lt;code&gt;linux-clang&lt;/code&gt; 및 &lt;code&gt;linux-clang-libc++&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c6db7933f7885ae873ea9d6b85de74fc5c4be3e7" translate="yes" xml:space="preserve">
          <source>On Linux, Qt Bluetooth uses a separate executable, &lt;code&gt;sdpscanner&lt;/code&gt;, to integrate with the official Linux bluetooth protocol stack &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtbluetooth-attribution-bluez.html#&quot;&gt;BlueZ&lt;/a&gt;. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtbluetooth-attribution-bluez.html#&quot;&gt;BlueZ&lt;/a&gt; is available under the &lt;a href=&quot;http://www.gnu.org/licenses/gpl-2.0.html&quot;&gt;GNU General Public License, version 2&lt;/a&gt;.</source>
          <target state="translated">Linux에서 Qt Bluetooth는 별도의 실행 파일 인 &lt;code&gt;sdpscanner&lt;/code&gt; 를 사용하여 공식 Linux Bluetooth 프로토콜 스택 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtbluetooth-attribution-bluez.html#&quot;&gt;BlueZ&lt;/a&gt; 와 통합합니다 . &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtbluetooth-attribution-bluez.html#&quot;&gt;BlueZ&lt;/a&gt; 는 &lt;a href=&quot;http://www.gnu.org/licenses/gpl-2.0.html&quot;&gt;GNU General Public License, version 2&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba73576bb4f5db5dc0dcd46e4a069ba3b32c13d3" translate="yes" xml:space="preserve">
          <source>On Linux, Qt Bluetooth uses a separate executable, &lt;code&gt;sdpscanner&lt;/code&gt;, to integrate with the official Linux bluetooth protocol stack &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtbluetooth-attribution-bluez.html&quot;&gt;BlueZ&lt;/a&gt;. &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtbluetooth-attribution-bluez.html&quot;&gt;BlueZ&lt;/a&gt; is available under the &lt;a href=&quot;http://www.gnu.org/licenses/gpl-2.0.html&quot;&gt;GNU General Public License, version 2&lt;/a&gt;.</source>
          <target state="translated">Linux에서 Qt Bluetooth는 별도의 실행 파일 인 &lt;code&gt;sdpscanner&lt;/code&gt; 를 사용하여 공식 Linux Bluetooth 프로토콜 스택 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtbluetooth-attribution-bluez.html&quot;&gt;BlueZ&lt;/a&gt; 와 통합합니다 . &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtbluetooth-attribution-bluez.html&quot;&gt;BlueZ&lt;/a&gt; 는 &lt;a href=&quot;http://www.gnu.org/licenses/gpl-2.0.html&quot;&gt;GNU General Public License, 버전 2에&lt;/a&gt; 따라 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2b3f797e33b6ce2d5f62a1251736f6421be715d" translate="yes" xml:space="preserve">
          <source>On Linux, Windows and Apple platforms, this value is usually the time since the system boot, though it usually does not include the time the system has spent in sleep states.</source>
          <target state="translated">Linux, Windows 및 Apple 플랫폼에서이 값은 일반적으로 시스템 부팅 이후의 시간이지만 일반적으로 시스템이 휴면 상태에서 소비 한 시간은 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2428c6d6d23ba5348e97fec794f179fe55c5cdc9" translate="yes" xml:space="preserve">
          <source>On Linux, note the following restrictions:</source>
          <target state="translated">Linux에서는 다음 제한 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="9868f3840fcc2cfb72fa85ed6470a1c5286ad448" translate="yes" xml:space="preserve">
          <source>On Linux, retrieving the volume's label requires &lt;code&gt;udev&lt;/code&gt; to be present in the system.</source>
          <target state="translated">Linux에서 볼륨 레이블을 검색하려면 시스템에 &lt;code&gt;udev&lt;/code&gt; 가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="860b940943efd67e5351c2fa69ea361b0a647f4f" translate="yes" xml:space="preserve">
          <source>On Linux, the</source>
          <target state="translated">Linux에서</target>
        </trans-unit>
        <trans-unit id="48890158ae2cda54f400fa9db2242f01fbca64c4" translate="yes" xml:space="preserve">
          <source>On Linux, the kernel has to support the anonymous namespaces feature (kernel version &amp;gt;= 3.8) and seccomp-bpf feature (kernel version &amp;gt;= 3.5). Setuid sandboxes are not supported and are thus disabled.</source>
          <target state="translated">Linux에서 커널은 익명 네임 스페이스 기능 (커널 버전&amp;gt; = 3.8) 및 seccomp-bpf 기능 (커널 버전&amp;gt; = 3.5)을 지원해야합니다. Setuid 샌드 박스는 지원되지 않으므로 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="e18810d4ece678f4372cf474aca3fc209ebfc264" translate="yes" xml:space="preserve">
          <source>On Linux/&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtbluetooth-attribution-bluez.html#&quot;&gt;BlueZ&lt;/a&gt; systems, it is not possible to connect to the same remote device using two instances of this class. The second call to this function may fail with an error. This limitation may be removed in future releases.</source>
          <target state="translated">Linux / &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtbluetooth-attribution-bluez.html#&quot;&gt;BlueZ&lt;/a&gt; 시스템에서는이 클래스의 두 인스턴스를 사용하여 동일한 원격 장치에 연결할 수 없습니다. 이 함수에 대한 두 번째 호출은 오류와 함께 실패 할 수 있습니다. 이 제한은 향후 릴리스에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc99b7ade5b99b96dc5e8aa6f5075ac0269ab3bb" translate="yes" xml:space="preserve">
          <source>On Linux/&lt;a href=&quot;https://doc.qt.io/qt-5.15/qtbluetooth-attribution-bluez.html&quot;&gt;BlueZ&lt;/a&gt; systems, it is not possible to connect to the same remote device using two instances of this class. The second call to this function may fail with an error. This limitation may be removed in future releases.</source>
          <target state="translated">Linux / &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtbluetooth-attribution-bluez.html&quot;&gt;BlueZ&lt;/a&gt; 시스템에서는이 클래스의 두 인스턴스를 사용하여 동일한 원격 장치에 연결할 수 없습니다. 이 함수에 대한 두 번째 호출은 오류와 함께 실패 할 수 있습니다. 이 제한은 향후 릴리스에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efb10eaaa960fb4907555f096aef5bf9fa09f863" translate="yes" xml:space="preserve">
          <source>On Linux/X11, Windows and macOS, Qt provides support for session management. Sessions allow events to be propagated to processes, for example, to notify when a shutdown occurs. The process and applications can then perform any necessary operations such as save open documents.</source>
          <target state="translated">Linux / X11, Windows 및 macOS에서 Qt는 세션 관리를 지원합니다. 세션을 사용하면 이벤트를 프로세스로 전파 할 수 있습니다. 예를 들어 종료가 발생할 때이를 알립니다. 그러면 프로세스 및 응용 프로그램에서 열린 문서 저장과 같은 필요한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fc3d52902162d74f8ed313c5de739bb86f3a25d" translate="yes" xml:space="preserve">
          <source>On Linux:</source>
          <target state="translated">Linux에서 :</target>
        </trans-unit>
        <trans-unit id="be86cf8677a1438eaed02b537278783288f434af" translate="yes" xml:space="preserve">
          <source>On Mac, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; uses &lt;a href=&quot;qcoreapplication#organizationDomain-prop&quot;&gt;organizationDomain()&lt;/a&gt; as the organization if it's not an empty string; otherwise it uses organizationName(). On all other platforms, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; uses organizationName() as the organization.</source>
          <target state="translated">Mac에서 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 는 빈 문자열이 아닌 경우 &lt;a href=&quot;qcoreapplication#organizationDomain-prop&quot;&gt;organizationDomain ()&lt;/a&gt; 을 조직으로 사용 합니다. 그렇지 않으면 organizationName ()을 사용합니다. 다른 모든 플랫폼에서 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 는 organizationName ()을 조직으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fdcac537267b374784eb9ce033e40b4e0eb5764c" translate="yes" xml:space="preserve">
          <source>On Mac, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; uses organizationDomain() as the organization if it's not an empty string; otherwise it uses &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;organizationName&lt;/a&gt;(). On all other platforms, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; uses &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;organizationName&lt;/a&gt;() as the organization.</source>
          <target state="translated">Mac에서 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 는 빈 문자열이 아닌 경우 organizationDomain ()을 조직으로 사용합니다. 그렇지 않으면 &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;organizationName&lt;/a&gt; ()을 사용 합니다 . 다른 모든 플랫폼에서 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 는 &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;organizationName&lt;/a&gt; ()을 조직으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="936548b28a7b4a6e49bd38e06c550258eed3eeba" translate="yes" xml:space="preserve">
          <source>On Microsoft Windows, mouse wheel usage is always handled by the widget that has keyboard focus. On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and X11, it's handled by the widget that gets other mouse events.</source>
          <target state="translated">Microsoft Windows에서 마우스 휠 사용은 항상 키보드 포커스가있는 위젯에 의해 처리됩니다. 에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 와 X11, 그것은 다른 마우스 이벤트를 가져옵니다 위젯에 의해 처리합니다.</target>
        </trans-unit>
        <trans-unit id="fe3403df2fdcc4730139d60587156a4d721c186f" translate="yes" xml:space="preserve">
          <source>On Microsoft Windows, mouse wheel usage is always handled by the widget that has keyboard focus. On macOS and X11, it's handled by the widget that gets other mouse events.</source>
          <target state="translated">Microsoft Windows에서 마우스 휠 사용은 항상 키보드 포커스가있는 위젯에 의해 처리됩니다. macOS 및 X11에서는 다른 마우스 이벤트를 가져 오는 위젯에서 처리합니다.</target>
        </trans-unit>
        <trans-unit id="104b5202331c5da26bf22f5bad018a37e0ceda3c" translate="yes" xml:space="preserve">
          <source>On UNIX (including Linux, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, and iOS), Qt will keep millisecond accuracy for Qt::PreciseTimer. For Qt::CoarseTimer, the interval will be adjusted up to 5% to align the timer with other timers that are expected to fire at or around the same time. The objective is to make most timers wake up at the same time, thereby reducing CPU wakeups and power consumption.</source>
          <target state="translated">UNIX (Linux, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 및 iOS 포함)에서 Qt는 Qt :: PreciseTimer의 밀리 초 정확도를 유지합니다. Qt :: CoarseTimer의 경우 간격이 최대 5 %로 조정되어 타이머가 동시에 또는 거의 동시에 발생할 것으로 예상되는 다른 타이머와 타이머를 정렬합니다. 목표는 대부분의 타이머를 동시에 깨우 게하여 CPU 깨우기와 전력 소비를 줄이는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4761363370402042cde54b98cc5a486ea3feabdc" translate="yes" xml:space="preserve">
          <source>On UNIX (including Linux, macOS, and iOS), Qt will keep millisecond accuracy for Qt::PreciseTimer. For Qt::CoarseTimer, the interval will be adjusted up to 5% to align the timer with other timers that are expected to fire at or around the same time. The objective is to make most timers wake up at the same time, thereby reducing CPU wakeups and power consumption.</source>
          <target state="translated">UNIX (Linux, macOS 및 iOS 포함)에서 Qt는 Qt :: PreciseTimer에 대해 밀리 초 정확도를 유지합니다. Qt :: CoarseTimer의 경우 간격이 최대 5 %까지 조정되어 동시에 실행될 것으로 예상되는 다른 타이머와 타이머를 정렬합니다. 목표는 대부분의 타이머를 동시에 깨워 CPU 깨우기와 전력 소비를 줄이는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e63d44de10b1980cb899a8990239749fb37f24ca" translate="yes" xml:space="preserve">
          <source>On Universal Windows Platform (UWP), the default value is the value of the environment variable &lt;code&gt;UCRTVERSION&lt;/code&gt;.</source>
          <target state="translated">UWP (유니버설 Windows 플랫폼)에서 기본값은 환경 변수 &lt;code&gt;UCRTVERSION&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="9e6bc2903e79f45ee2f81d86c0a91d5d49c7139a" translate="yes" xml:space="preserve">
          <source>On Unix (including &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS), the symlink has the same &lt;a href=&quot;qfileinfo#size&quot;&gt;size&lt;/a&gt;() has the file it points to, because Unix handles symlinks transparently; similarly, opening a symlink using &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; effectively opens the link's target. For example:</source>
          <target state="translated">유닉스 ( &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 및 iOS 포함)에서 심볼릭 링크의 &lt;a href=&quot;qfileinfo#size&quot;&gt;크기&lt;/a&gt; ()는 파일이 가리키는 파일 과 동일 합니다 . Unix는 심볼릭 링크를 투명하게 처리하기 때문입니다. 마찬가지로 &lt;a href=&quot;qfile&quot;&gt;QFile을&lt;/a&gt; 사용하여 심볼릭 링크를 열면 링크 대상이 효과적으로 열립니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="39c25dd694bf96255f18f2cb91fa793c5acdb2b7" translate="yes" xml:space="preserve">
          <source>On Unix (including macOS and iOS), the property getter functions in this class return the properties such as times and size of the target file, not the symlink, because Unix handles symlinks transparently. Opening a symlink using &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; effectively opens the link's target. For example:</source>
          <target state="translated">Unix (macOS 및 iOS 포함)에서이 클래스의 속성 getter 함수는 Unix가 심볼릭 링크를 투명하게 처리하기 때문에 심볼릭 링크가 아닌 대상 파일의 시간 및 크기와 같은 속성을 반환합니다. &lt;a href=&quot;qfile&quot;&gt;QFile을&lt;/a&gt; 사용하여 심볼릭 링크를 열면 링크의 대상이 효과적으로 열립니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="f6601c6c8c0ed07a385aac8cf7d5f6cad57fb84e" translate="yes" xml:space="preserve">
          <source>On Unix and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; (replace &lt;code&gt;$SQLITE&lt;/code&gt; with the directory where &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; resides):</source>
          <target state="translated">Unix 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; ( &lt;code&gt;$SQLITE&lt;/code&gt; 을 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; 가있는 디렉토리로 대체 ) :</target>
        </trans-unit>
        <trans-unit id="f60a02d3486206deb3ab1e6410ad148ada51fb30" translate="yes" xml:space="preserve">
          <source>On Unix and macOS (replace &lt;code&gt;$SQLITE&lt;/code&gt; with the directory where &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; resides):</source>
          <target state="translated">Unix 및 macOS에서 ( &lt;code&gt;$SQLITE&lt;/code&gt; 를 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; 가있는 디렉터리로 대체 ) :</target>
        </trans-unit>
        <trans-unit id="6e90f968f96c7a108db8f7fac8e46c58ec8da105" translate="yes" xml:space="preserve">
          <source>On Unix and macOS (replace &lt;code&gt;$SQLITE&lt;/code&gt; with the directory where &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; resides):</source>
          <target state="translated">Unix 및 macOS의 경우 ( &lt;code&gt;$SQLITE&lt;/code&gt; 를 &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; 가있는 디렉터리로 대체 ) :</target>
        </trans-unit>
        <trans-unit id="f17af98e38048982a6ae01200dfc2f8c351686df" translate="yes" xml:space="preserve">
          <source>On Unix filesystems, the root volume is a volume mounted on &lt;code&gt;/&lt;/code&gt;. On Windows, the root volume is the volume where the OS is installed.</source>
          <target state="translated">Unix 파일 시스템에서 루트 볼륨은 &lt;code&gt;/&lt;/code&gt; 에 마운트 된 볼륨입니다 . Windows에서 루트 볼륨은 OS가 설치된 볼륨입니다.</target>
        </trans-unit>
        <trans-unit id="bace692e6aba923077fe382f0c0ab904a3051d37" translate="yes" xml:space="preserve">
          <source>On Unix systems this call returns the root ('/') volume; in Windows the volume where the operating system is installed.</source>
          <target state="translated">유닉스 시스템에서이 호출은 루트 ( '/') 볼륨을 반환합니다. Windows에서는 운영 체제가 설치된 볼륨입니다.</target>
        </trans-unit>
        <trans-unit id="5aa9d4402ae9e8143461ecb3a0fb1cc0b173cd10" translate="yes" xml:space="preserve">
          <source>On Unix systems this is equivalen to &lt;a href=&quot;qstring#fromUtf8&quot;&gt;fromUtf8&lt;/a&gt;(), on Windows the systems current code page is being used.</source>
          <target state="translated">Unix 시스템에서는 &lt;a href=&quot;qstring#fromUtf8&quot;&gt;fromUtf8&lt;/a&gt; () 과 동일하며 Windows에서는 시스템의 현재 코드 페이지가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d28d9c24ae6990a741cd47e479e710cc52519812" translate="yes" xml:space="preserve">
          <source>On Unix systems this is equivalen to &lt;a href=&quot;qstring#toUtf8&quot;&gt;toUtf8&lt;/a&gt;(), on Windows the systems current code page is being used.</source>
          <target state="translated">Unix 시스템에서는 &lt;a href=&quot;qstring#toUtf8&quot;&gt;toUtf8&lt;/a&gt; () 과 동일하며 Windows에서는 시스템의 현재 코드 페이지가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="701e5658bca1d8b3d2069b780576ba87c6a22f7a" translate="yes" xml:space="preserve">
          <source>On Unix systems this is equivalen to &lt;a href=&quot;qstringview#toUtf8&quot;&gt;toUtf8&lt;/a&gt;(), on Windows the systems current code page is being used.</source>
          <target state="translated">Unix 시스템에서는 &lt;a href=&quot;qstringview#toUtf8&quot;&gt;toUtf8&lt;/a&gt; () 과 동일하며 Windows에서는 시스템의 현재 코드 페이지가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="afb2d139c1b873a083088b2510e71647e18163db" translate="yes" xml:space="preserve">
          <source>On Unix systems this is equivalent to &lt;a href=&quot;qstringref#toUtf8&quot;&gt;toUtf8&lt;/a&gt;(), on Windows the systems current code page is being used.</source>
          <target state="translated">Unix 시스템에서는 &lt;a href=&quot;qstringref#toUtf8&quot;&gt;Utf8&lt;/a&gt; () 과 동일하며 Windows에서는 시스템의 현재 코드 페이지가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fbccf7366e1baa7565e0b1f8d2ddc72d16e641ba" translate="yes" xml:space="preserve">
          <source>On Unix systems, a binary cache is used for more performance. This cache is generated by the command &quot;update-mime-database path&quot;, where path would be /opt/myapp/share/mime in the above example. Make sure to run this command when installing the MIME type definition file.</source>
          <target state="translated">Unix 시스템에서는 성능 향상을 위해 이진 캐시가 사용됩니다. 이 캐시는 &quot;update-mime-database path&quot;명령으로 생성되며 여기서 위의 경로는 / opt / myapp / share / mime입니다. MIME 유형 정의 파일을 설치할 때이 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="e4cb0eaa6ed531dabf48c928b44a40335b561e57" translate="yes" xml:space="preserve">
          <source>On Unix systems, if the file format is &lt;a href=&quot;qsettings#Format-enum&quot;&gt;NativeFormat&lt;/a&gt;, the following files are used by default:</source>
          <target state="translated">Unix 시스템에서 파일 형식이 &lt;a href=&quot;qsettings#Format-enum&quot;&gt;NativeFormat&lt;/a&gt; 인 경우 기본적으로 다음 파일이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="93ba505e997dfa29c95903bafb91601da153ec19" translate="yes" xml:space="preserve">
          <source>On Unix systems, the variable names are case-sensitive. Note that the Unix environment allows both variable names and contents to contain arbitrary binary data (except for the NUL character). &lt;a href=&quot;qprocessenvironment&quot;&gt;QProcessEnvironment&lt;/a&gt; will preserve such variables, but does not support manipulating variables whose names or values cannot be encoded by the current locale settings (see &lt;a href=&quot;qtextcodec#codecForLocale&quot;&gt;QTextCodec::codecForLocale&lt;/a&gt;).</source>
          <target state="translated">Unix 시스템에서 변수 이름은 대소 문자를 구분합니다. Unix 환경에서는 변수 이름과 내용 모두 임의의 이진 데이터를 포함 할 수 있습니다 (NUL 문자 제외). &lt;a href=&quot;qprocessenvironment&quot;&gt;QProcessEnvironment&lt;/a&gt; 는 이러한 변수를 유지하지만 현재 로케일 설정으로 이름 또는 값을 인코딩 할 수없는 변수 조작을 지원하지 않습니다 ( &lt;a href=&quot;qtextcodec#codecForLocale&quot;&gt;QTextCodec :: codecForLocale&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="e430f306e83d2007ff707f86ff47bacb2ff9a381" translate="yes" xml:space="preserve">
          <source>On Unix systems, the variable names are case-sensitive. Note that the Unix environment allows both variable names and contents to contain arbitrary binary data (except for the NUL character). QProcessEnvironment will preserve such variables, but does not support manipulating variables whose names or values cannot be encoded by the current locale settings (see &lt;a href=&quot;qstring#toLocal8Bit&quot;&gt;QString::toLocal8Bit&lt;/a&gt;).</source>
          <target state="translated">Unix 시스템에서 변수 이름은 대소 문자를 구분합니다. Unix 환경에서는 변수 이름과 내용 모두 임의의 이진 데이터 (NUL 문자 제외)를 포함 할 수 있습니다. QProcessEnvironment는 이러한 변수를 보존하지만 현재 로케일 설정으로 이름이나 값을 인코딩 할 수없는 변수 조작을 지원하지 않습니다 ( &lt;a href=&quot;qstring#toLocal8Bit&quot;&gt;QString :: toLocal8Bit&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="665e30919ca5deb2015c61b1722ba66c444b393a" translate="yes" xml:space="preserve">
          <source>On Unix systems, the variable names are case-sensitive. Note that the Unix environment allows both variable names and contents to contain arbitrary binary data (except for the NUL character). QProcessEnvironment will preserve such variables, but does not support manipulating variables whose names or values cannot be encoded by the current locale settings (see &lt;a href=&quot;qtextcodec#codecForLocale&quot;&gt;QTextCodec::codecForLocale&lt;/a&gt;).</source>
          <target state="translated">Unix 시스템에서 변수 이름은 대소 문자를 구분합니다. Unix 환경에서는 변수 이름과 내용 모두 임의의 이진 데이터 (NUL 문자 제외)를 포함 할 수 있습니다. QProcessEnvironment는 이러한 변수를 유지하지만 현재 로케일 설정으로 이름이나 값을 인코딩 할 수없는 변수 조작을 지원하지 않습니다 ( &lt;a href=&quot;qtextcodec#codecForLocale&quot;&gt;QTextCodec :: codecForLocale&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="11fd2ef57d776661880d860224f2b7e6a97d35df" translate="yes" xml:space="preserve">
          <source>On Unix the absolute path will always begin with the root, '/', directory. On Windows this will always begin 'D:/' where D is a drive letter, except for network shares that are not mapped to a drive letter, in which case the path will begin '//sharename/'.</source>
          <target state="translated">유닉스에서 절대 경로는 항상 루트 '/', 디렉토리로 시작합니다. Windows에서는 항상 'D : /'로 시작합니다. 여기서 D는 드라이브 문자에 매핑되지 않은 네트워크 공유를 제외하고 드라이브 문자입니다.이 경우 경로는 '// sharename /'으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1e3b98776696cf1f7c4fdcd2ef4da38ddb1d19f1" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; is set to</source>
          <target state="translated">유닉스에서 &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="e112b2ed461033620dc39a7e6c6c0c114fe107ed" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; is set to &lt;code&gt;~/.qttest/share&lt;/code&gt;, &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; is set to &lt;code&gt;~/.qttest/config&lt;/code&gt;, and &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; is set to &lt;code&gt;~/.qttest/cache&lt;/code&gt;.</source>
          <target state="translated">Unix에서 &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; 은 &lt;code&gt;~/.qttest/share&lt;/code&gt; 로 , &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 은 &lt;code&gt;~/.qttest/config&lt;/code&gt; 로 , &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; 은 &lt;code&gt;~/.qttest/cache&lt;/code&gt; 로 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="f6b62d543e73f8db440c1c3ba2771570a56bf10a" translate="yes" xml:space="preserve">
          <source>On Unix, NativeFormat and IniFormat mean the same thing, except that the file extension is different (&lt;code&gt;.conf&lt;/code&gt; for NativeFormat, &lt;code&gt;.ini&lt;/code&gt; for IniFormat).</source>
          <target state="translated">Unix에서 NativeFormat과 IniFormat은 파일 확장자가 다릅니다 ( NativeFormat의 경우 &lt;code&gt;.conf&lt;/code&gt; , IniFormat의 경우 &lt;code&gt;.ini&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="dc950e9b8358b8d88c8e106325f9d8345417f694" translate="yes" xml:space="preserve">
          <source>On Unix, a boolean that describes whether Qt libraries and plugins were compiled with &lt;code&gt;-fvisibility=hidden&lt;/code&gt;. This means that only selected symbols are exported.</source>
          <target state="translated">Unix에서 Qt 라이브러리와 플러그인이 &lt;code&gt;-fvisibility=hidden&lt;/code&gt; 으로 컴파일되었는지 여부를 설명하는 부울입니다 . 즉, 선택한 심볼 만 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="2d890128146d13d56a5352b3c1af9b54f8e10e09" translate="yes" xml:space="preserve">
          <source>On Unix, at least two autotests (&lt;code&gt;tst_examples&lt;/code&gt; and &lt;code&gt;tst_gestures&lt;/code&gt;) require a window manager to be running. Therefore, if running these tests under a nested X-server, you must also run a window manager in that X-server.</source>
          <target state="translated">Unix에서 최소 2 개의 &lt;code&gt;tst_examples&lt;/code&gt; ( tst_examples 및 &lt;code&gt;tst_gestures&lt;/code&gt; )를 실행하려면 창 관리자가 실행되어야합니다. 따라서 중첩 된 X 서버에서 이러한 테스트를 실행하는 경우 해당 X 서버에서 창 관리자도 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d867696c469d1f032513ef5bf449c98acfa7dae" translate="yes" xml:space="preserve">
          <source>On Unix, one can also run the tests on a nested or virtual X-server, such as Xephyr. For example, to run the entire set of tests on Xephyr, execute the following commands:</source>
          <target state="translated">Unix에서는 Xephyr와 같은 중첩 또는 가상 X 서버에서 테스트를 실행할 수도 있습니다. 예를 들어 Xephyr에서 전체 테스트 세트를 실행하려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="09c58f46dccacecb57866673b0c94614f0721a76" translate="yes" xml:space="preserve">
          <source>On Unix, there are some special system files (e.g. in &lt;code&gt;/proc&lt;/code&gt;) for which &lt;a href=&quot;qfile#size&quot;&gt;size&lt;/a&gt;() will always return 0, yet you may still be able to read more data from such a file; the data is generated in direct response to you calling &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt;(). In this case, however, you cannot use &lt;a href=&quot;qfiledevice#atEnd&quot;&gt;atEnd&lt;/a&gt;() to determine if there is more data to read (since &lt;a href=&quot;qfiledevice#atEnd&quot;&gt;atEnd&lt;/a&gt;() will return true for a file that claims to have size 0). Instead, you should either call &lt;a href=&quot;qiodevice#readAll&quot;&gt;readAll&lt;/a&gt;(), or call &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt;() or &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt;() repeatedly until no more data can be read. The next example uses &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; to read &lt;code&gt;/proc/modules&lt;/code&gt; line by line:</source>
          <target state="translated">Unix에는 &lt;a href=&quot;qfile#size&quot;&gt;size&lt;/a&gt; ()가 항상 0을 반환 하는 특수 시스템 파일 (예 : &lt;code&gt;/proc&lt;/code&gt; ) 이 있지만 여전히 이러한 파일에서 더 많은 데이터를 읽을 수 있습니다. &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt; () 호출에 대한 직접적인 응답으로 데이터가 생성됩니다 . 그러나이 경우 &lt;a href=&quot;qfiledevice#atEnd&quot;&gt;atEnd&lt;/a&gt; ()를 사용 하여 읽을 데이터가 더 있는지 판별 할 수 없습니다 ( &lt;a href=&quot;qfiledevice#atEnd&quot;&gt;atEnd&lt;/a&gt; ()는 크기가 0이라고 주장하는 파일에 대해 true를 리턴하므로). 대신 더 이상 데이터를 읽을 수 없을 때까지 &lt;a href=&quot;qiodevice#readAll&quot;&gt;readAll&lt;/a&gt; ()을 호출하거나 &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt; () 또는 &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt; ()을 반복해서 호출해야합니다 . 다음 예제는 &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; 을 사용 하여 &lt;code&gt;/proc/modules&lt;/code&gt; 를 한 줄씩 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="0602921fc400588e0a70165d9faf3eaf62f0752d" translate="yes" xml:space="preserve">
          <source>On Unix, this function currently always returns the same as &lt;a href=&quot;qnetworkinterface#name&quot;&gt;name&lt;/a&gt;(), since Unix systems don't store a configuration for human-readable names.</source>
          <target state="translated">Unix에서이 함수는 현재 항상 &lt;a href=&quot;qnetworkinterface#name&quot;&gt;name&lt;/a&gt; () 과 동일하게 반환됩니다. Unix 시스템은 사람이 읽을 수있는 이름에 대한 구성을 저장하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="687c99b02f8e40a7be8b68d5fe13db95f6a22e8d" translate="yes" xml:space="preserve">
          <source>On Unix, this sets the executable flag.</source>
          <target state="translated">유닉스에서는 실행 플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="41c4bdcec681573ef1a70386454b43adf7ffeb9a" translate="yes" xml:space="preserve">
          <source>On Unix-like platforms (including Linux, macOS and iOS), when Qt is linked with the ICU library (which it usually is), its locale-aware sorting is used. Otherwise, on macOS and iOS, &lt;a href=&quot;qstring#localeAwareCompare&quot;&gt;localeAwareCompare&lt;/a&gt;() compares according the &quot;Order for sorted lists&quot; setting in the International preferences panel. On other Unix-like systems without ICU, the comparison falls back to the system library's &lt;code&gt;strcoll()&lt;/code&gt;,</source>
          <target state="translated">Unix와 유사한 플랫폼 (Linux, macOS 및 iOS 포함)에서 Qt가 ICU 라이브러리 (일반적으로 사용됨)와 연결되면 로케일 인식 정렬이 사용됩니다. 그렇지 않으면 macOS 및 iOS에서 &lt;a href=&quot;qstring#localeAwareCompare&quot;&gt;localeAwareCompare&lt;/a&gt; ()는 국제 환경 설정 패널의 &quot;정렬 된 목록 순서&quot;설정에 따라 비교합니다. ICU가없는 다른 유닉스 계열 시스템에서는 비교가 시스템 라이브러리의 &lt;code&gt;strcoll()&lt;/code&gt; 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="885d8dfdc058fa8af354259928c23010ca9ed6b1" translate="yes" xml:space="preserve">
          <source>On Unix-like platforms (including Linux, macOS and iOS), when Qt is linked with the ICU library (which it usually is), its locale-aware sorting is used. Otherwise, on macOS and iOS, &lt;a href=&quot;qstring#localeAwareCompare&quot;&gt;localeAwareCompare&lt;/a&gt;() compares according the &quot;Order for sorted lists&quot; setting in the International preferences panel. On other Unix-like systems without ICU, the comparison falls back to the system library's &lt;code&gt;strcoll()&lt;/code&gt;, falling back when it considers strings equal to QString's (locale-unaware) comparison, described above,</source>
          <target state="translated">Unix 계열 플랫폼 (Linux, macOS 및 iOS 포함)에서 Qt가 ICU 라이브러리 (일반적으로 사용됨)와 연결되면 로케일 인식 정렬이 사용됩니다. 그렇지 않으면 macOS 및 iOS에서 &lt;a href=&quot;qstring#localeAwareCompare&quot;&gt;localeAwareCompare&lt;/a&gt; ()는 다국어 환경 설정 패널의 &quot;정렬 된 목록 순서&quot;설정에 따라 비교합니다. ICU가없는 다른 유닉스 계열 시스템에서 비교는 시스템 라이브러리의 &lt;code&gt;strcoll()&lt;/code&gt; 로 돌아가며, 위에서 설명한 QString의 (로케일 인식하지 않는) 비교와 동일한 문자열을 고려할 때 폴백됩니다.</target>
        </trans-unit>
        <trans-unit id="c5a6786599b2cdaef1671f8f5d1e3f31e3b9479c" translate="yes" xml:space="preserve">
          <source>On Unix/Linux Qt is configured to use the system locale settings by default. This can cause a conflict when using POSIX functions, for instance, when converting between data types such as floats and strings, since the notation may differ between locales. To get around this problem, call the POSIX function &lt;code&gt;setlocale(LC_NUMERIC,&quot;C&quot;)&lt;/code&gt; right after initializing &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt;, &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; or &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; to reset the locale that is used for number formatting to &quot;C&quot;-locale.</source>
          <target state="translated">Unix / Linux에서 Qt는 기본적으로 시스템 로케일 설정을 사용하도록 구성되어 있습니다. 로케일마다 표기법이 다를 수 있으므로 POSIX 함수를 사용할 때 예를 들어 부동 소수점 및 문자열과 같은 데이터 유형 간 변환시 충돌이 발생할 수 있습니다. 이 문제를 해결하려면 &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; , &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; 또는 &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; 을 초기화 한 직후 POSIX 함수 &lt;code&gt;setlocale(LC_NUMERIC,&quot;C&quot;)&lt;/code&gt; 호출하여 숫자 형식에 사용되는 로케일을 &quot;C&quot;-로케일로 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="63e361f3477e8ef3ef3db54ce35541f29391ad75" translate="yes" xml:space="preserve">
          <source>On Unix/Linux Qt is configured to use the system locale settings by default. This can cause a conflict when using POSIX functions, for instance, when converting between data types such as floats and strings, since the notation may differ between locales. To get around this problem, call the POSIX function &lt;code&gt;setlocale(LC_NUMERIC,&quot;C&quot;)&lt;/code&gt; right after initializing &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt;, &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; or QCoreApplication to reset the locale that is used for number formatting to &quot;C&quot;-locale.</source>
          <target state="translated">Unix / Linux에서 Qt는 기본적으로 시스템 로케일 설정을 사용하도록 구성됩니다. 예를 들어 부동 소수점 및 문자열과 같은 데이터 유형간에 변환 할 때 POSIX 함수를 사용할 때 표기법이 로케일마다 다를 수 있으므로 충돌이 발생할 수 있습니다. 이 문제를 해결하려면 &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; , &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; 또는 QCoreApplication을 초기화 한 직후 POSIX 함수 &lt;code&gt;setlocale(LC_NUMERIC,&quot;C&quot;)&lt;/code&gt; 호출하여 숫자 형식화에 사용되는 로케일을 &quot;C&quot;-로케일로 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0eee08701b37711b726bc5c326a520a7795b78a1" translate="yes" xml:space="preserve">
          <source>On Unix/Linux systems this is the path in the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable or &lt;code&gt;/tmp&lt;/code&gt; if &lt;code&gt;TMPDIR&lt;/code&gt; is not defined. On Windows this is usually the path in the &lt;code&gt;TEMP&lt;/code&gt; or &lt;code&gt;TMP&lt;/code&gt; environment variable. The path returned by this method doesn't end with a directory separator unless it is the root directory (of a drive).</source>
          <target state="translated">Unix / Linux 시스템에서이 경로는 &lt;code&gt;TMPDIR&lt;/code&gt; 환경 변수 의 경로 이거나 &lt;code&gt;TMPDIR&lt;/code&gt; 이 정의되지 않은 경우 &lt;code&gt;/tmp&lt;/code&gt; 입니다. Windows에서 이는 일반적으로 &lt;code&gt;TEMP&lt;/code&gt; 또는 &lt;code&gt;TMP&lt;/code&gt; 환경 변수 의 경로입니다 . 이 메소드가 리턴 한 경로는 디렉토리 분리기가 드라이브의 루트 디렉토리가 아닌 경우 디렉토리 분리 자로 끝나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3844b76c72de9814ba134528a2e98ebfade0de2" translate="yes" xml:space="preserve">
          <source>On Unix/X11, the normal behavior of the file dialog is to resolve and follow symlinks. For example, if &lt;code&gt;/usr/tmp&lt;/code&gt; is a symlink to &lt;code&gt;/var/tmp&lt;/code&gt;, the file dialog will change to &lt;code&gt;/var/tmp&lt;/code&gt; after entering &lt;code&gt;/usr/tmp&lt;/code&gt;. If</source>
          <target state="translated">Unix / X11에서 파일 대화 상자의 일반적인 동작은 심볼릭 링크를 해결하고 따르는 것입니다. 예를 들어, &lt;code&gt;/usr/tmp&lt;/code&gt; 있는 심볼릭 링크로 &lt;code&gt;/var/tmp&lt;/code&gt; 파일 대화 상자가 변경됩니다에 &lt;code&gt;/var/tmp&lt;/code&gt; 입력 한 후 &lt;code&gt;/usr/tmp&lt;/code&gt; . 만약</target>
        </trans-unit>
        <trans-unit id="946affb9561bc980c61b450f36bafb68b8cc7412" translate="yes" xml:space="preserve">
          <source>On Unix/X11, the normal behavior of the file dialog is to resolve and follow symlinks. For example, if &lt;code&gt;/usr/tmp&lt;/code&gt; is a symlink to &lt;code&gt;/var/tmp&lt;/code&gt;, the file dialog will change to &lt;code&gt;/var/tmp&lt;/code&gt; after entering &lt;code&gt;/usr/tmp&lt;/code&gt;. The</source>
          <target state="translated">Unix / X11에서 파일 대화 상자의 일반적인 동작은 심볼릭 링크를 해결하고 따르는 것입니다. 예를 들어, &lt;code&gt;/usr/tmp&lt;/code&gt; 있는 심볼릭 링크로 &lt;code&gt;/var/tmp&lt;/code&gt; 파일 대화 상자가 변경됩니다에 &lt;code&gt;/var/tmp&lt;/code&gt; 입력 한 후 &lt;code&gt;/usr/tmp&lt;/code&gt; . 그만큼</target>
        </trans-unit>
        <trans-unit id="790549c0d3a3bfe5baf9fb5ced03f9d2ae73fd15" translate="yes" xml:space="preserve">
          <source>On WinRT, this isn't relevant because the backend there always uses a composition swapchain which is associated with the ISwapChainPanel that backs &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; on that platform.</source>
          <target state="translated">백엔드가 항상 백업이있는 ISwapChainPanel와 연관된 구성 swapchain 사용하기 때문에 WinRT에서이은 관련이 없습니다 &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; 해당 플랫폼에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8790ba2d042320ac0ff89cc6fbfd713e3f294b72" translate="yes" xml:space="preserve">
          <source>On Windows Vista and above grabbing a layered window, which is created by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_TranslucentBackground&lt;/a&gt; attribute, will not work. Instead grabbing the desktop widget should work.</source>
          <target state="translated">Windows Vista 이상에서 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_TranslucentBackground&lt;/a&gt; 속성 을 설정하여 만든 계층화 된 창을 가져 오면 작동하지 않습니다. 대신 데스크탑 위젯을 잡아야합니다.</target>
        </trans-unit>
        <trans-unit id="1d0e589073490d5159cfe11285c50f7a1f85db9b" translate="yes" xml:space="preserve">
          <source>On Windows and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; the page setup dialog is implemented using the native page setup dialogs.</source>
          <target state="translated">Windows 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서 페이지 설정 대화 상자는 기본 페이지 설정 대화 상자를 사용하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="153b1e39841abcf2158fa5299c7935bc61f925b4" translate="yes" xml:space="preserve">
          <source>On Windows and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, the native print dialog is used, which means that some &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; and &lt;a href=&quot;qdialog&quot;&gt;QDialog&lt;/a&gt; properties set on the dialog won't be respected. The native print dialog on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; does not support setting printer options, i.e. &lt;a href=&quot;qprintdialog#options-prop&quot;&gt;setOptions&lt;/a&gt;() and &lt;a href=&quot;qprintdialog#setOption&quot;&gt;setOption&lt;/a&gt;() have no effect.</source>
          <target state="translated">Windows 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서는 기본 인쇄 대화 상자가 사용 되므로 대화 상자에 설정된 일부 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 및 &lt;a href=&quot;qdialog&quot;&gt;QDialog&lt;/a&gt; 속성이 적용되지 않습니다. &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 의 기본 인쇄 대화 상자는 프린터 옵션 설정을 지원하지 않습니다. 즉 &lt;a href=&quot;qprintdialog#options-prop&quot;&gt;setOptions&lt;/a&gt; () 및 &lt;a href=&quot;qprintdialog#setOption&quot;&gt;setOption&lt;/a&gt; ()은 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fb552f0c6ee026f6a2d5cdf2c2faba130e66307" translate="yes" xml:space="preserve">
          <source>On Windows and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this static function will use the native file dialog and not a &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;. However, the native Windows file dialog does not support displaying files in the directory chooser. You need to pass &lt;a href=&quot;qfiledialog#Option-enum&quot;&gt;DontUseNativeDialog&lt;/a&gt; to display files using a &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;.</source>
          <target state="translated">Windows 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서이 정적 함수는 &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog가&lt;/a&gt; 아닌 기본 파일 대화 상자를 사용합니다 . 그러나 기본 Windows 파일 대화 상자는 디렉토리 선택기에 파일 표시를 지원하지 않습니다. 당신은 전달해야 &lt;a href=&quot;qfiledialog#Option-enum&quot;&gt;DontUseNativeDialog을&lt;/a&gt; 사용하여 표시 파일을 &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a70298dd5c537a10885dffc0b4796cc69c26b290" translate="yes" xml:space="preserve">
          <source>On Windows and Mac, this locale will use the decimal/grouping characters and date/time formats specified in the system configuration panel.</source>
          <target state="translated">Windows 및 Mac에서이 로케일은 시스템 구성 패널에 지정된 10 진수 / 그룹화 문자 및 날짜 / 시간 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d9517590c1b7334224700261590c3cf915514625" translate="yes" xml:space="preserve">
          <source>On Windows and Mac, this option can be changed while printing and will take effect from the next call to &lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt;().</source>
          <target state="translated">Windows 및 Mac에서이 옵션은 인쇄하는 동안 변경 될 수 있으며 다음에 &lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt; ()를 호출 할 때 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="005c72f31e8e4788fed43ee14d746717e095e475" translate="yes" xml:space="preserve">
          <source>On Windows and macOS the page setup dialog is implemented using the native page setup dialogs.</source>
          <target state="translated">Windows 및 macOS에서 페이지 설정 대화 상자는 기본 페이지 설정 대화 상자를 사용하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="7d3c6cdcafd391c8d0a7c1479d4f25233e98f454" translate="yes" xml:space="preserve">
          <source>On Windows and macOS, the native print dialog is used, which means that some &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; and &lt;a href=&quot;qdialog&quot;&gt;QDialog&lt;/a&gt; properties set on the dialog won't be respected. The native print dialog on macOS does not support setting printer options, i.e. &lt;a href=&quot;qprintdialog#options-prop&quot;&gt;setOptions&lt;/a&gt;() and &lt;a href=&quot;qprintdialog#setOption&quot;&gt;setOption&lt;/a&gt;() have no effect.</source>
          <target state="translated">Windows 및 macOS에서는 기본 인쇄 대화 상자가 사용되며 이는 대화 상자에 설정된 일부 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 및 &lt;a href=&quot;qdialog&quot;&gt;QDialog&lt;/a&gt; 속성이 적용되지 않음을 의미합니다. macOS의 기본 인쇄 대화 상자는 프린터 옵션 설정을 지원하지 않습니다. 즉, &lt;a href=&quot;qprintdialog#options-prop&quot;&gt;setOptions&lt;/a&gt; () 및 &lt;a href=&quot;qprintdialog#setOption&quot;&gt;setOption&lt;/a&gt; ()은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="525d9d80dde519138d351d097281097c7462525d" translate="yes" xml:space="preserve">
          <source>On Windows and macOS, this static function will use the native file dialog and not a &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;. However, the native Windows file dialog does not support displaying files in the directory chooser. You need to pass &lt;a href=&quot;qfiledialog#Option-enum&quot;&gt;DontUseNativeDialog&lt;/a&gt; to display files using a &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;.</source>
          <target state="translated">Windows 및 macOS에서이 정적 함수는 &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog가&lt;/a&gt; 아닌 기본 파일 대화 상자를 사용합니다 . 그러나 기본 Windows 파일 대화 상자는 디렉토리 선택기에 파일 표시를 지원하지 않습니다. 당신은 전달해야 &lt;a href=&quot;qfiledialog#Option-enum&quot;&gt;DontUseNativeDialog을&lt;/a&gt; 사용하여 표시 파일을 &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5d18eab9424efb8eb9d67b73f2554a661d53b8d" translate="yes" xml:space="preserve">
          <source>On Windows and on systems where files do not have groups this function always returns (uint) -2.</source>
          <target state="translated">Windows 및 파일에 그룹이없는 시스템에서이 기능은 항상 (uint) -2를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="79144f75391086deffcb8615df18ab19f80fdaf7" translate="yes" xml:space="preserve">
          <source>On Windows and on systems where files do not have owners this function returns ((uint) -2).</source>
          <target state="translated">Windows 및 파일에 소유자가없는 시스템에서이 함수는 ((uint) -2)를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="32afade7d47abda738aacc3512c2b30ffaabeca2" translate="yes" xml:space="preserve">
          <source>On Windows platforms, this function may take several seconds to execute depending on the configuration of the user's system.</source>
          <target state="translated">Windows 플랫폼에서이 기능은 사용자 시스템 구성에 따라 몇 초가 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5aecee188c7f1b1294a2d0e762ebebb7959f0ca" translate="yes" xml:space="preserve">
          <source>On Windows systems, the clock overflows after 2^32 milliseconds, which corresponds to roughly 49.7 days. This means two processes' reckoning of the time since the reference may be different by multiples of 2^32 milliseconds. When comparing such values, it's recommended that the high 32 bits of the millisecond count be masked off.</source>
          <target state="translated">Windows 시스템에서 시계는 2 ^ 32 밀리 초 후에 오버플로되며 이는 대략 49.7 일에 해당합니다. 이는 기준이 2 ^ 32 밀리 초의 배수로 다를 수 있기 때문에 두 프로세스의 시간 계산을 의미합니다. 이러한 값을 비교할 때는 밀리 초 카운트의 상위 32 비트를 마스킹하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4438b8406b08ce691061664d1b8e89e958e240ba" translate="yes" xml:space="preserve">
          <source>On Windows the dialog will spin a blocking modal event loop that will not dispatch any QTimers, and if</source>
          <target state="translated">Windows에서 대화 상자는 QTimers를 전달하지 않는 차단 모달 이벤트 루프를 회전시킵니다.</target>
        </trans-unit>
        <trans-unit id="d60ef4abd5ddf2ac11833e853cd9b3a90a8a9a4c" translate="yes" xml:space="preserve">
          <source>On Windows this ID is translated from the Windows ID using an internal translation table and the user's selected country. As a consequence there is a small chance any Windows install may have IDs not known by Qt, in which case &quot;UTC&quot; will be returned.</source>
          <target state="translated">Windows에서이 ID는 내부 변환 테이블과 사용자가 선택한 국가를 사용하여 Windows ID에서 변환됩니다. 결과적으로 Windows 설치에 Qt에 의해 알려지지 않은 ID가있을 가능성이 적습니다.이 경우 &quot;UTC&quot;가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0f5bb54d8a742f78761067d364ae5dee864e5618" translate="yes" xml:space="preserve">
          <source>On Windows this is a named pipe and on Unix this is a local domain socket.</source>
          <target state="translated">Windows에서 이것은 명명 된 파이프이고 Unix에서 이것은 로컬 도메인 소켓입니다.</target>
        </trans-unit>
        <trans-unit id="173484095c13480d2e28bd6242bb96dbc6170feb" translate="yes" xml:space="preserve">
          <source>On Windows this returns a list of &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; objects containing &quot;C:/&quot;, &quot;D:/&quot;, etc. On other operating systems, it returns a list containing just one root directory (i.e. &quot;/&quot;).</source>
          <target state="translated">Windows에서는 &quot;C : /&quot;, &quot;D : /&quot;등을 포함하는 &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; 객체 의 목록을 반환합니다 . 다른 운영 체제에서는 루트 디렉토리가 하나만 포함 된 목록 (예 : &quot;/&quot;)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d081113f7df8bc79a1aef37cb9f1492bed7c99fc" translate="yes" xml:space="preserve">
          <source>On Windows,</source>
          <target state="translated">Windows에서는</target>
        </trans-unit>
        <trans-unit id="2f9f91efe038a9e14ae2e98d9d2d49df516d2ec0" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;qcommandlineparser&quot;&gt;QCommandLineParser&lt;/a&gt; uses message boxes to display usage information and errors if no console window can be obtained.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;qcommandlineparser&quot;&gt;QCommandLineParser&lt;/a&gt; 는 콘솔 창을 확보 할 수없는 경우 메시지 상자를 사용하여 사용 정보 및 오류를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7aaacc0a16e055c426abc12b5c974f97f3a6cc14" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;qlocalserver#SocketOption-enum&quot;&gt;UserAccessOption&lt;/a&gt; is sufficient to allow a non elevated process to connect to a local server created by an elevated process run by the same user. &lt;a href=&quot;qlocalserver#SocketOption-enum&quot;&gt;GroupAccessOption&lt;/a&gt; refers to the primary group of the process (see TokenPrimaryGroup in the Windows documentation). &lt;a href=&quot;qlocalserver#SocketOption-enum&quot;&gt;OtherAccessOption&lt;/a&gt; refers to the well known &quot;Everyone&quot; group.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;qlocalserver#SocketOption-enum&quot;&gt;UserAccessOption&lt;/a&gt; 은 비 높은 프로세스가 동일한 사용자가 실행하는 높은 프로세스로 작성된 로컬 서버에 연결하기에 충분합니다. &lt;a href=&quot;qlocalserver#SocketOption-enum&quot;&gt;GroupAccessOption&lt;/a&gt; 은 프로세스의 기본 그룹을 나타냅니다 (Windows 설명서의 TokenPrimaryGroup 참조). &lt;a href=&quot;qlocalserver#SocketOption-enum&quot;&gt;OtherAccessOption&lt;/a&gt; 은 잘 알려진 &quot;모두&quot;그룹을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7657792c855355b2e1bf8322e309cc98bee5fb9b" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;qmimedata#formats&quot;&gt;formats&lt;/a&gt;() will also return custom formats available in the MIME data, using the &lt;code&gt;x-qt-windows-mime&lt;/code&gt; subtype to indicate that they represent data in non-standard formats. The formats will take the following form:</source>
          <target state="translated">Windows에서 &lt;a href=&quot;qmimedata#formats&quot;&gt;형식&lt;/a&gt; ()은 &lt;code&gt;x-qt-windows-mime&lt;/code&gt; 하위 유형을 사용하여 MIME 데이터에서 사용 가능한 사용자 지정 형식을 반환하여 비표준 형식의 데이터를 나타냅니다. 형식은 다음 형식을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="1d34b7d36338db117c47d6d8a642c55e9be69ad9" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; uses the Win32 API function &lt;code&gt;CreateProcess&lt;/code&gt; to start child processes. While &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; provides a comfortable way to start processes without worrying about platform details, it is in some cases desirable to fine-tune the parameters that are passed to &lt;code&gt;CreateProcess&lt;/code&gt;. This is done by defining a &lt;code&gt;CreateProcessArgumentModifier&lt;/code&gt; function and passing it to &lt;code&gt;setCreateProcessArgumentsModifier&lt;/code&gt;.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; 는 Win32 API 함수 &lt;code&gt;CreateProcess&lt;/code&gt; 를 사용하여 하위 프로세스를 시작합니다. &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; 는 플랫폼 세부 사항에 대해 걱정하지 않고 프로세스를 시작하는 편안한 방법을 제공 하지만 &lt;code&gt;CreateProcess&lt;/code&gt; 로 전달되는 매개 변수를 미세 조정하는 것이 바람직한 경우도 있습니다. 이것은 &lt;code&gt;CreateProcessArgumentModifier&lt;/code&gt; 함수 이를 &lt;code&gt;setCreateProcessArgumentsModifier&lt;/code&gt; 에 전달하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="6211efcbbb8b3d6c4e6c2ffb8fe77c3c3f76389c" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; lets you access settings that have been written with &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; (or settings in a supported format, e.g., string data) in the system registry. This is done by constructing a &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; object with a path in the registry and &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings::NativeFormat&lt;/a&gt;.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;qsettings&quot;&gt;QSettings를&lt;/a&gt; 사용하면 시스템 레지스트리에서 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 로 작성된 설정 (또는 지원되는 형식 (예 : 문자열 데이터) 설정)에 액세스 할 수 있습니다 . 이것은&lt;a href=&quot;qsettings&quot;&gt;&lt;/a&gt;레지스트리의 경로와 &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings :: NativeFormat을 사용&lt;/a&gt; QSettings 객체를 됩니다.</target>
        </trans-unit>
        <trans-unit id="bd0c88cc322d1d15cf5b6bfab2befeec4005d8b4" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;qsettings#Format-enum&quot;&gt;NativeFormat&lt;/a&gt; settings are stored in the following registry paths:</source>
          <target state="translated">Windows에서는 &lt;a href=&quot;qsettings#Format-enum&quot;&gt; NativeFormat&lt;/a&gt; 설정은 다음 레지스트리 경로에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="94852db06226697f5a831247465cc2af867c02e0" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;qtcore-changes-qt6#qprocess&quot;&gt;QProcess&lt;/a&gt; uses the Win32 API function &lt;code&gt;CreateProcess&lt;/code&gt; to start child processes. While &lt;a href=&quot;qtcore-changes-qt6#qprocess&quot;&gt;QProcess&lt;/a&gt; provides a comfortable way to start processes without worrying about platform details, it is in some cases desirable to fine-tune the parameters that are passed to &lt;code&gt;CreateProcess&lt;/code&gt;. This is done by defining a &lt;code&gt;CreateProcessArgumentModifier&lt;/code&gt; function and passing it to &lt;code&gt;setCreateProcessArgumentsModifier&lt;/code&gt;.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;qtcore-changes-qt6#qprocess&quot;&gt;QProcess&lt;/a&gt; 는 Win32 API 함수 &lt;code&gt;CreateProcess&lt;/code&gt; 를 사용하여 자식 프로세스를 시작합니다. &lt;a href=&quot;qtcore-changes-qt6#qprocess&quot;&gt;QProcess&lt;/a&gt; 는 플랫폼 세부 사항에 대해 걱정하지 않고 프로세스를 시작할 수있는 편안한 방법을 제공 하지만 , 경우에 따라 &lt;code&gt;CreateProcess&lt;/code&gt; 에 전달되는 매개 변수를 미세 조정하는 것이 바람직합니다 . 이는 &lt;code&gt;CreateProcessArgumentModifier&lt;/code&gt; 함수 를 정의하고 이를 &lt;code&gt;setCreateProcessArgumentsModifier&lt;/code&gt; 에 전달 하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="273747cc7999cee5b8f3d7d8165402e17286236f" translate="yes" xml:space="preserve">
          <source>On Windows, ANGLE, a third-party OpenGL ES to Direct 3D translator, is no longer included in Qt 6. This means &lt;code&gt;Qt::AA_UseOpenGLES&lt;/code&gt; and the environment variable &lt;code&gt;QT_OPENGL=angle&lt;/code&gt; no longer has any effect. In dynamic OpenGL builds there is no automatic fallback to ANGLE in case OpenGL-proper fails to initialize. For &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; or &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; based applications using OpenGL directly, for example via &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;, this means that OpenGL-proper is the only option at runtime. However, the use of a pure software OpenGL implementation, such as Mesa llvmpipe that is shipped with the pre-built Qt packages, is still available.</source>
          <target state="translated">Windows에서 타사 OpenGL ES to Direct 3D 변환기 인 ANGLE은 더 이상 Qt 6에 포함되지 않습니다. 이는 &lt;code&gt;Qt::AA_UseOpenGLES&lt;/code&gt; 및 환경 변수 &lt;code&gt;QT_OPENGL=angle&lt;/code&gt; 이 더 이상 효과가 없음을 의미합니다. 동적 OpenGL 빌드에서는 OpenGL- 적절한 초기화에 실패한 경우 ANGLE로 자동 대체되지 않습니다. 용 &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; 하거나 &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;는 QWidget&lt;/a&gt; 통해 직접 예는 OpenGL을 사용 기반 애플리케이션 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; , OpenGL에 적절한 런타임시 옵션 만이 있음을 의미. 그러나 사전 빌드 된 Qt 패키지와 함께 제공되는 Mesa llvmpipe와 같은 순수 소프트웨어 OpenGL 구현의 사용은 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14ab9ffede2ea3a49550674e47ff7350c2742c59" translate="yes" xml:space="preserve">
          <source>On Windows, ANGLE, a third-party OpenGL ES to Direct 3D translator, is no longer included in Qt. This means &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt::AA_UseOpenGLES&lt;/a&gt; and the environment variable &lt;code&gt;QT_OPENGL=angle&lt;/code&gt; no longer have any effect. In &lt;a href=&quot;windows-requirements&quot;&gt;dynamic OpenGL builds&lt;/a&gt; there is no automatic fallback to ANGLE in case OpenGL proper fails to initialize. For &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; or &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; based applications using OpenGL directly, for example via &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;, this means that OpenGL proper is the only option at run time. However, the alternative of using a pure software OpenGL implementation, such as Mesa llvmpipe that is shipped with the pre-built Qt packages, is still available. For Qt Quick and Qt Quick 3D applications, Qt 6 introduces support for Direct 3D 11, Vulkan, and Metal, in addition to OpenGL. On Windows the default choice is Direct 3D, therefore the removal of ANGLE is alleviated by having support for graphics APIs other than OpenGL as well.</source>
          <target state="translated">Windows에서 타사 OpenGL ES to Direct 3D 변환기 인 ANGLE은 더 이상 Qt에 포함되지 않습니다. 이는 &lt;a href=&quot;qt#ApplicationAttribute-enum&quot;&gt;Qt :: AA_UseOpenGLES&lt;/a&gt; 및 환경 변수 &lt;code&gt;QT_OPENGL=angle&lt;/code&gt; 이 더 이상 효과가 없음을 의미합니다. &lt;a href=&quot;windows-requirements&quot;&gt;동적 OpenGL 빌드&lt;/a&gt; 에서는 OpenGL 이 초기화에 실패 할 경우 ANGLE로 자동 대체되지 않습니다. 용 &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; 하거나 &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;는 QWidget&lt;/a&gt; 기반 애플리케이션을 통해 예를 들어, 직접적으로는 OpenGL을 사용 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;, 이것은 OpenGL이 런타임에 유일한 옵션임을 의미합니다. 그러나 사전 빌드 된 Qt 패키지와 함께 제공되는 Mesa llvmpipe와 같은 순수한 소프트웨어 OpenGL 구현을 사용하는 대안은 여전히 ​​사용할 수 있습니다. Qt Quick 및 Qt Quick 3D 애플리케이션의 경우 Qt 6은 OpenGL 외에도 Direct 3D 11, Vulkan 및 Metal에 대한 지원을 도입합니다. Windows에서 기본 선택은 Direct 3D이므로 OpenGL 이외의 그래픽 API도 지원함으로써 ANGLE 제거가 완화됩니다.</target>
        </trans-unit>
        <trans-unit id="c9f6224e430c62533d0c15d70a2952272d66f0c4" translate="yes" xml:space="preserve">
          <source>On Windows, Linux and Unix with FontConfig (client side font support) the following languages are also supported:</source>
          <target state="translated">FontConfig (클라이언트 측 글꼴 지원)가있는 Windows, Linux 및 Unix에서는 다음 언어도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8ec750030fc86c431fc0cc22d96c707066b1bf1d" translate="yes" xml:space="preserve">
          <source>On Windows, Linux, and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, Qt WebView depends on the &lt;a href=&quot;qtwebengine-index&quot;&gt;Qt WebEngine&lt;/a&gt; module to render content.</source>
          <target state="translated">Windows, Linux 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서 Qt WebView는 컨텐츠를 렌더링하기 위해 &lt;a href=&quot;qtwebengine-index&quot;&gt;Qt WebEngine&lt;/a&gt; 모듈 에 의존 합니다.</target>
        </trans-unit>
        <trans-unit id="fb010bb9ae623dfe12cb2082c48c8f946484a62b" translate="yes" xml:space="preserve">
          <source>On Windows, Linux, and macOS, Qt WebView depends on the &lt;a href=&quot;qtwebengine-index&quot;&gt;Qt WebEngine&lt;/a&gt; module to render content.</source>
          <target state="translated">Windows, Linux 및 macOS에서 Qt WebView는 콘텐츠를 렌더링하기 위해 &lt;a href=&quot;qtwebengine-index&quot;&gt;Qt WebEngine&lt;/a&gt; 모듈 에 의존 합니다.</target>
        </trans-unit>
        <trans-unit id="d574c885b384b3a5f690df7426307fddb8242507" translate="yes" xml:space="preserve">
          <source>On Windows, QCommandLineParser uses message boxes to display usage information and errors if no console window can be obtained.</source>
          <target state="translated">Windows에서 QCommandLineParser는 콘솔 창을 가져올 수없는 경우 메시지 상자를 사용하여 사용 정보 및 오류를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e169b57c650bd6581aeed67e13f7d754def8df0c" translate="yes" xml:space="preserve">
          <source>On Windows, QSettings lets you access settings that have been written with QSettings (or settings in a supported format, e.g., string data) in the system registry. This is done by constructing a QSettings object with a path in the registry and &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings::NativeFormat&lt;/a&gt;.</source>
          <target state="translated">Windows에서 QSettings를 사용하면 시스템 레지스트리에서 QSettings로 작성된 설정 (또는 지원되는 형식 (예 : 문자열 데이터)의 설정)에 액세스 할 수 있습니다. 이것은 레지스트리의 경로와 &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings :: NativeFormat&lt;/a&gt; 으로 QSettings 객체를 생성함으로써 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="c8ff7ae9872aa787caccaf0ac562ff34894acf65" translate="yes" xml:space="preserve">
          <source>On Windows, Qt can be configured with the system OpenGL or with &lt;a href=&quot;https://chromium.googlesource.com/angle/angle/+/master/README.md&quot;&gt;ANGLE&lt;/a&gt;. By default, Qt is configured to use dynamic OpenGL. This means that it tries to use system OpenGL and falls back to ANGLE, which is bundled with Qt and depends on the DirectX SDK, if native OpenGL does not work. ANGLE enables running Qt applications that depend on OpenGL, without installing the latest OpenGL drivers. If ANGLE also fails, Qt will fall back to software rendering, which is the slowest but most safe of the rendering methods.</source>
          <target state="translated">Windows에서 Qt는 시스템 OpenGL 또는 &lt;a href=&quot;https://chromium.googlesource.com/angle/angle/+/master/README.md&quot;&gt;ANGLE&lt;/a&gt; 로 구성 할 수 있습니다 . 기본적으로 Qt는 동적 OpenGL을 사용하도록 구성됩니다. 즉, 기본 OpenGL이 작동하지 않는 경우 시스템 OpenGL을 사용하고 Qt와 함께 번들로 제공되고 DirectX SDK에 의존하는 ANGLE로 폴백합니다. ANGLE을 사용하면 최신 OpenGL 드라이버를 설치하지 않고도 OpenGL에 의존하는 Qt 애플리케이션을 실행할 수 있습니다. ANGLE도 실패하면 Qt는 렌더링 방법 중 가장 느리지 만 가장 안전한 소프트웨어 렌더링으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="36084b6a38d0046457329edc1ce7035a57de9ca1" translate="yes" xml:space="preserve">
          <source>On Windows, Qt can be configured with the system OpenGL or with &lt;a href=&quot;https://chromium.googlesource.com/angle/angle/+/master/README.md#&quot;&gt;ANGLE&lt;/a&gt;. By default, Qt is configured to use dynamic OpenGL. This means that it tries to use system OpenGL and falls back to ANGLE, which is bundled with Qt and depends on the DirectX SDK, if native OpenGL does not work. ANGLE enables running Qt applications that depend on OpenGL, without installing the latest OpenGL drivers. If ANGLE also fails, Qt will fall back to software rendering, which is the slowest but most safe of the rendering methods.</source>
          <target state="translated">Windows에서 Qt는 시스템 OpenGL 또는 &lt;a href=&quot;https://chromium.googlesource.com/angle/angle/+/master/README.md#&quot;&gt;ANGLE&lt;/a&gt; 로 구성 할 수 있습니다 . 기본적으로 Qt는 동적 OpenGL을 사용하도록 구성되어 있습니다. 이것은 시스템 OpenGL을 사용하려고 시도하고 Qt에 번들로 제공되는 ANGLE로 폴백하며 기본 OpenGL이 작동하지 않는 경우 DirectX SDK에 의존합니다. ANGLE을 사용하면 최신 OpenGL 드라이버를 설치하지 않고도 OpenGL에 의존하는 Qt 응용 프로그램을 실행할 수 있습니다. ANGLE도 실패하면 Qt는 렌더링 방법 중 가장 느리지 만 가장 안전한 소프트웨어 렌더링으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="73482fb6819fa90fbb7392686bee562ee6bb85e6" translate="yes" xml:space="preserve">
          <source>On Windows, Qt can use the system's Secure Channel library for this purpose (configure option &lt;b&gt;-schannel&lt;/b&gt;). On macOS and iOS, Qt can be configured to use the SecureTransport API (configure option &lt;b&gt;-securetransport&lt;/b&gt;).</source>
          <target state="translated">Windows에서 Qt는 이러한 목적으로 시스템의 보안 채널 라이브러리를 사용할 수 있습니다 (구성 옵션 &lt;b&gt;-schannel&lt;/b&gt; ). macOS 및 iOS에서 Qt는 SecureTransport API를 사용하도록 구성 할 수 있습니다 (구성 옵션 &lt;b&gt;-securetransport&lt;/b&gt; ).</target>
        </trans-unit>
        <trans-unit id="86cb408cc7a3276abc43d23f5e1d0e4694746fda" translate="yes" xml:space="preserve">
          <source>On Windows, Qt will use Windows's Multimedia timer facility (if available) for Qt::PreciseTimer and normal Windows timers for Qt::CoarseTimer and Qt::VeryCoarseTimer.</source>
          <target state="translated">Windows에서 Qt는 Qt :: PreciseTimer에 Windows의 멀티미디어 타이머 기능 (사용 가능한 경우)을 사용하고 Qt :: CoarseTimer 및 Qt :: VeryCoarseTimer에 일반 Windows 타이머를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5f6c67b3c388f495ed43d8c62ac9b5423438cb1b" translate="yes" xml:space="preserve">
          <source>On Windows, Visual Studio 2017 and Windows 10 SDK are required.</source>
          <target state="translated">Windows에서는 Visual Studio 2017 및 Windows 10 SDK가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b94e7d980488a2cafad803911d11239698908891" translate="yes" xml:space="preserve">
          <source>On Windows, an ODBC driver manager should be installed by default. For Unix systems, there are some implementations which must be installed first. Note that every end user of your application is required to have an ODBC driver manager installed, otherwise the QODBC plugin will not work.</source>
          <target state="translated">Windows에서는 기본적으로 ODBC 드라이버 관리자가 설치되어 있어야합니다. 유닉스 시스템의 경우, 먼저 설치해야하는 구현이 있습니다. 응용 프로그램의 모든 최종 사용자는 ODBC 드라이버 관리자를 설치해야합니다. 그렇지 않으면 QODBC 플러그인이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a046a49eb862192bc389c249bdcd0b52a2654ed" translate="yes" xml:space="preserve">
          <source>On Windows, and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this static function will use the native file dialog and not a &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;.</source>
          <target state="translated">Windows 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서이 정적 함수는 &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog가&lt;/a&gt; 아닌 기본 파일 대화 상자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="10826623feadfa72a4485e34a17fbeb799e5b968" translate="yes" xml:space="preserve">
          <source>On Windows, and macOS, this static function will use the native file dialog and not a &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;.</source>
          <target state="translated">Windows 및 macOS에서이 정적 함수는 &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog가&lt;/a&gt; 아닌 기본 파일 대화 상자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="a5ad43c5b139fef3fa0a2f40b509afe66f604a22" translate="yes" xml:space="preserve">
          <source>On Windows, everything goes to a &quot;qttest&quot; directory under &lt;code&gt;%APPDATA%&lt;/code&gt;.</source>
          <target state="translated">Windows에서는 모든 것이 &lt;code&gt;%APPDATA%&lt;/code&gt; 아래의 &quot;qttest&quot;디렉토리로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="0a8742992833152e679e7ac230e6cd6497be0b03" translate="yes" xml:space="preserve">
          <source>On Windows, everything goes to a &quot;qttest&quot; directory under Application Data.</source>
          <target state="translated">Windows에서는 모든 것이 Application Data 아래의 &quot;qttest&quot;디렉토리로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="41e4b76e5497497f0e910648c84c8b22896c2a3d" translate="yes" xml:space="preserve">
          <source>On Windows, if the format is &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings::NativeFormat&lt;/a&gt;, the return value is a system registry path, not a file path.</source>
          <target state="translated">Windows에서 형식이 &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings :: NativeFormat&lt;/a&gt; 인 경우 리턴 값은 파일 경로가 아닌 시스템 레지스트리 경로입니다.</target>
        </trans-unit>
        <trans-unit id="19db6fa9c0e6ecdb9dc3ed8c0e4c8646568b7e81" translate="yes" xml:space="preserve">
          <source>On Windows, if the process was terminated with TerminateProcess() from another application, this function will still return &lt;a href=&quot;qprocess#ExitStatus-enum&quot;&gt;NormalExit&lt;/a&gt; unless the exit code is less than 0.</source>
          <target state="translated">Windows에서 프로세스가 다른 애플리케이션에서 TerminateProcess ()로 종료 된 경우 종료 코드가 0보다 &lt;a href=&quot;qprocess#ExitStatus-enum&quot;&gt;작지&lt;/a&gt; 않으면 이 함수는 여전히 NormalExit를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="f4de3ffade0f14541e5fc34016a77889d9f60f1d" translate="yes" xml:space="preserve">
          <source>On Windows, if you are calling this when the application is not currently the active one then it will not make it the active window. It will change the color of the taskbar entry to indicate that the window has changed in some way. This is because Microsoft does not allow an application to interrupt what the user is currently doing in another application.</source>
          <target state="translated">Windows에서 응용 프로그램이 현재 활성화되어 있지 않을 때 이것을 호출하면 응용 프로그램을 활성 창으로 만들지 않습니다. 작업 표시 줄 항목의 색상이 변경되어 창이 변경되었음을 나타냅니다. Microsoft가 사용자가 다른 응용 프로그램에서 현재하고있는 작업을 응용 프로그램이 중단하도록 허용하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="575d9b3a78af0da2b74620b3d569a1bc8e316a74" translate="yes" xml:space="preserve">
          <source>On Windows, it is possible for a key to have both a value and subkeys. Its default value is accessed by using &quot;Default&quot; or &quot;.&quot; in place of a subkey:</source>
          <target state="translated">Windows에서는 키에 값과 하위 키가 모두있을 수 있습니다. 기본값은 &quot;Default&quot;또는 &quot;.&quot;를 사용하여 액세스합니다. 하위 키 대신 :</target>
        </trans-unit>
        <trans-unit id="789849527f55dd326ab8965b01a0cd4e3d42c782" translate="yes" xml:space="preserve">
          <source>On Windows, it returns the volume letter in case the volume is not mounted to a directory.</source>
          <target state="translated">Windows에서는 볼륨이 디렉토리에 마운트되지 않은 경우 볼륨 문자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6f45ef2557d2763eeb9ce7f467fe135973457929" translate="yes" xml:space="preserve">
          <source>On Windows, kill() uses TerminateProcess, and on Unix and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, the SIGKILL signal is sent to the process.</source>
          <target state="translated">Windows에서 kill ()은 TerminateProcess를 사용하고 Unix 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서는 SIGKILL 신호가 프로세스로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="c1f2ddc90ea88c20db6dcf30567c41f324327c36" translate="yes" xml:space="preserve">
          <source>On Windows, kill() uses TerminateProcess, and on Unix and macOS, the SIGKILL signal is sent to the process.</source>
          <target state="translated">Windows에서는 kill ()이 TerminateProcess를 사용하고 Unix 및 macOS에서는 SIGKILL 신호가 프로세스로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="b7817e4f6372ea0ffb46fc54a14ab0108449385c" translate="yes" xml:space="preserve">
          <source>On Windows, make sure you have &lt;code&gt;MinGW&lt;/code&gt; as well as &lt;code&gt;sed&lt;/code&gt; in your &lt;code&gt;PATH&lt;/code&gt; and configure with the following:</source>
          <target state="translated">Windows에서 확인 당신은이 있는지 확인 &lt;code&gt;MinGW&lt;/code&gt; 뿐만 아니라으로 &lt;code&gt;sed&lt;/code&gt; 당신의 &lt;code&gt;PATH&lt;/code&gt; 다음과 및 구성 :</target>
        </trans-unit>
        <trans-unit id="be08508e87dfb9c0df0e01746b667cf36cea0b24" translate="yes" xml:space="preserve">
          <source>On Windows, sets the printer resolution to that defined for the printer in use. For PDF printing, sets the resolution of the PDF driver to 1200 dpi.</source>
          <target state="translated">Windows에서는 프린터 해상도를 사용중인 프린터에 정의 된 해상도로 설정합니다. PDF 인쇄의 경우 PDF 드라이버의 해상도를 1200dpi로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="86c265bb1809aa2eeda1160b8236aed44714a002" translate="yes" xml:space="preserve">
          <source>On Windows, shortcuts (&lt;code&gt;.lnk&lt;/code&gt; files) are currently treated as symlinks. As on Unix systems, the property getters return the size of the targeted file, not the &lt;code&gt;.lnk&lt;/code&gt; file itself. This behavior is deprecated and will likely be removed in a future version of Qt, after which &lt;code&gt;.lnk&lt;/code&gt; files will be treated as regular files.</source>
          <target state="translated">Windows에서 바로 가기 ( &lt;code&gt;.lnk&lt;/code&gt; 파일)는 현재 심볼릭 링크로 처리됩니다. Unix 시스템에서와 마찬가지로 속성 getter는 &lt;code&gt;.lnk&lt;/code&gt; 파일 자체가 아닌 대상 파일의 크기를 반환합니다 . 이 동작은 더 이상 사용되지 않으며 Qt의 차기 버전에서 제거 될 가능성이 높습니다. 그 이후에는 &lt;code&gt;.lnk&lt;/code&gt; 파일이 일반 파일로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="14d9e4ccb9a6bff1ad352d4396e5ff42f362bb10" translate="yes" xml:space="preserve">
          <source>On Windows, symlinks (shortcuts) are &lt;code&gt;.lnk&lt;/code&gt; files. The reported &lt;a href=&quot;qfileinfo#size&quot;&gt;size&lt;/a&gt;() is that of the symlink (not the link's target), and opening a symlink using &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; opens the &lt;code&gt;.lnk&lt;/code&gt; file. For example:</source>
          <target state="translated">Windows에서 심볼릭 링크 (바로 가기)는 &lt;code&gt;.lnk&lt;/code&gt; 파일입니다. 보고 된 &lt;a href=&quot;qfileinfo#size&quot;&gt;크기&lt;/a&gt; ()는 링크의 대상이 아닌 심볼릭 링크의 크기 이며 &lt;a href=&quot;qfile&quot;&gt;QFile을&lt;/a&gt; 사용하여 심볼릭 링크를 열면 &lt;code&gt;.lnk&lt;/code&gt; 파일이 열립니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="894c53cc3aa9870814680f88a38324b2cbcc4b60" translate="yes" xml:space="preserve">
          <source>On Windows, terminate() posts a WM_CLOSE message to all top-level windows of the process and then to the main thread of the process itself. On Unix and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; the &lt;code&gt;SIGTERM&lt;/code&gt; signal is sent.</source>
          <target state="translated">Windows에서 terminate ()는 프로세스의 모든 최상위 창에 WM_CLOSE 메시지를 게시 한 다음 프로세스 자체의 기본 스레드에 게시합니다. Unix 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서는 &lt;code&gt;SIGTERM&lt;/code&gt; 신호가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="bd77ce155260348822d2cf0793b1977b1e47571b" translate="yes" xml:space="preserve">
          <source>On Windows, terminate() posts a WM_CLOSE message to all top-level windows of the process and then to the main thread of the process itself. On Unix and macOS the &lt;code&gt;SIGTERM&lt;/code&gt; signal is sent.</source>
          <target state="translated">Windows에서, terminate ()는 프로세스의 모든 최상위 창에 WM_CLOSE 메시지를 게시 한 다음 프로세스 자체의 기본 스레드에 게시합니다. Unix 및 macOS에서는 &lt;code&gt;SIGTERM&lt;/code&gt; 신호가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="c023ed2fa00db5821f38f2a7733300b417f3e3d0" translate="yes" xml:space="preserve">
          <source>On Windows, the</source>
          <target state="translated">Windows에서는</target>
        </trans-unit>
        <trans-unit id="50b76eb87355aa84c9f176e1e2fa2a2d4e2b8c28" translate="yes" xml:space="preserve">
          <source>On Windows, the MIME format does not always map directly to the clipboard formats. Qt provides &lt;a href=&quot;qwinmime&quot;&gt;QWinMime&lt;/a&gt; to map clipboard formats to open-standard MIME formats. Similarly, the &lt;a href=&quot;qmacpasteboardmime&quot;&gt;QMacPasteboardMime&lt;/a&gt; maps MIME to Mac flavors.</source>
          <target state="translated">Windows에서 MIME 형식이 항상 클립 보드 형식으로 직접 매핑되는 것은 아닙니다. Qt는 &lt;a href=&quot;qwinmime&quot;&gt;QWinMime&lt;/a&gt; 을 제공 하여 클립 보드 형식을 공개 표준 MIME 형식으로 매핑 합니다 . 마찬가지로 &lt;a href=&quot;qmacpasteboardmime&quot;&gt;QMacPasteboardMime&lt;/a&gt; 은 MIME을 Mac 맛에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="f0ca664fd6fda6cabf64d4d1c83ec4a6b9fe92c2" translate="yes" xml:space="preserve">
          <source>On Windows, the MIME format does not always map directly to the clipboard formats. Qt provides QWinMime to map clipboard formats to open-standard MIME formats. Similarly, the QMacPasteboardMime maps MIME to Mac flavors.</source>
          <target state="translated">Windows에서 MIME 형식이 항상 클립 보드 형식에 직접 매핑되는 것은 아닙니다. Qt는 클립 보드 형식을 개방형 표준 MIME 형식으로 매핑하는 QWinMime을 제공합니다. 마찬가지로 QMacPasteboardMime은 MIME을 Mac 버전에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="c9d9f0d80797bfabd82eb565989c14db0a2d588d" translate="yes" xml:space="preserve">
          <source>On Windows, the SDK sets the environment variable &lt;code&gt;VULKAN_SDK&lt;/code&gt;, which will be detected by the &lt;code&gt;configure&lt;/code&gt; script.</source>
          <target state="translated">Windows에서 SDK는 환경 변수 &lt;code&gt;VULKAN_SDK&lt;/code&gt; 를 설정 하며이 변수 는 &lt;code&gt;configure&lt;/code&gt; 스크립트에 의해 감지됩니다 .</target>
        </trans-unit>
        <trans-unit id="3dd65d4ac7293575c89dbbc61edd2fa3c9540a48" translate="yes" xml:space="preserve">
          <source>On Windows, the dialog will spin a blocking modal event loop that will not dispatch any QTimers, and if</source>
          <target state="translated">Windows에서 대화 상자는 QTimers를 전달하지 않는 차단 모달 이벤트 루프를 회전시킵니다.</target>
        </trans-unit>
        <trans-unit id="601af0d47a12773216295a93de15e80b3012a215" translate="yes" xml:space="preserve">
          <source>On Windows, the following additional tools are required:</source>
          <target state="translated">Windows에서는 다음과 같은 추가 도구가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="070069766453e3eb3bc17c26dcc40196783ed1a2" translate="yes" xml:space="preserve">
          <source>On Windows, the following files are used:</source>
          <target state="translated">Windows에서는 다음 파일이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="357070b8ee3d0513c5e8e0a083173878f3a0115d" translate="yes" xml:space="preserve">
          <source>On Windows, the installation binaries provided by LLVM do not include &lt;code&gt;llvm-config&lt;/code&gt;. You may still have it on your system, if you have built LLVM yourself from source. If that is the case, and you want to let the build system find Clang automatically, add the path to &lt;code&gt;llvm-config&lt;/code&gt; to your &lt;code&gt;PATH&lt;/code&gt; environment variable. For example:</source>
          <target state="translated">Windows에서 LLVM이 제공하는 설치 바이너리에는 &lt;code&gt;llvm-config&lt;/code&gt; 가 포함되지 않습니다 . 소스에서 직접 LLVM을 빌드 한 경우 시스템에 여전히있을 수 있습니다. 그 경우, 당신은 빌드 시스템이 자동으로 연타를 찾을 경로 추가 할 수 있도록하려면 &lt;code&gt;llvm-config&lt;/code&gt; 사용자에 &lt;code&gt;PATH&lt;/code&gt; 의 환경 변수입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3c1657afc1bc02dca1b80b856b5ed6552a224065" translate="yes" xml:space="preserve">
          <source>On Windows, the list is built from the argc and argv parameters only if modified argv/argc parameters are passed to the constructor. In that case, encoding problems might occur.</source>
          <target state="translated">Windows에서 수정 된 argv / argc 매개 변수가 생성자에 전달되는 경우에만 argc 및 argv 매개 변수로 목록이 작성됩니다. 이 경우 인코딩 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30bdeaf7adcfd048228bfae9a8c9c60cf24a9435" translate="yes" xml:space="preserve">
          <source>On Windows, the returned value is a &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms740522(v=vs.85).aspx&quot;&gt;Winsock 2 Socket Handle&lt;/a&gt;.</source>
          <target state="translated">Windows에서 리턴 된 값은 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms740522(v=vs.85).aspx&quot;&gt;Winsock 2 Socket Handle&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8a57532f83aee4223bce412df8949bba23b8bbe1" translate="yes" xml:space="preserve">
          <source>On Windows, the second example above will be translated to &lt;code&gt;C:\Documents and Settings&lt;/code&gt; when used to access files.</source>
          <target state="translated">Windows에서 위의 두 번째 예는 파일에 액세스 할 때 &lt;code&gt;C:\Documents and Settings&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="c821ce0a17f8bc969c387de22bee5900320ead8a" translate="yes" xml:space="preserve">
          <source>On Windows, the system tray icon size is 16x16; on X11, the preferred size is 22x22. The icon will be scaled to the appropriate size as necessary.</source>
          <target state="translated">Windows에서 시스템 트레이 아이콘 크기는 16x16입니다. X11에서 기본 크기는 22x22입니다. 필요에 따라 아이콘 크기가 적절한 크기로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="6fa2dea46c7c5f0f1f0cbdcde22e07fe259c0a30" translate="yes" xml:space="preserve">
          <source>On Windows, the variable names are case-insensitive, but case-preserving. &lt;a href=&quot;qprocessenvironment&quot;&gt;QProcessEnvironment&lt;/a&gt; behaves accordingly.</source>
          <target state="translated">Windows에서 변수 이름은 대소 문자를 구분하지 않지만 대소 문자를 유지합니다. &lt;a href=&quot;qprocessenvironment&quot;&gt;QProcessEnvironment가&lt;/a&gt; 그에 따라 작동합니다.</target>
        </trans-unit>
        <trans-unit id="85e98a6a22472447569815ce185bce3c04119f2d" translate="yes" xml:space="preserve">
          <source>On Windows, the variable names are case-insensitive, but case-preserving. QProcessEnvironment behaves accordingly.</source>
          <target state="translated">Windows에서 변수 이름은 대소 문자를 구분하지 않지만 대소 문자를 유지합니다. QProcessEnvironment는 그에 따라 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b5b32a2cff36ed3a8a335860a856ed4c4634f194" translate="yes" xml:space="preserve">
          <source>On Windows, this causes the window's taskbar entry to flash for a time. If</source>
          <target state="translated">Windows에서는 이로 인해 창의 작업 표시 줄 항목이 한동안 깜박입니다. 만약</target>
        </trans-unit>
        <trans-unit id="7ad2a1df3d377f75556f4b4104f12737db507920" translate="yes" xml:space="preserve">
          <source>On Windows, this function does nothing; on Unix, it removes the socket file given by</source>
          <target state="translated">Windows에서이 기능은 아무 것도 수행하지 않습니다. 유닉스에서는 다음과 같이 주어진 소켓 파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="4e9aaa05bd9dc6baaf7d4a989f9f0a6399793467" translate="yes" xml:space="preserve">
          <source>On Windows, this function returns &lt;code&gt;true&lt;/code&gt; if the target file is hidden (not the symlink).</source>
          <target state="translated">Windows에서이 함수는 대상 파일이 숨겨져 있으면 (심볼 링크가 아님) &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="09eae3a8474264613a1bb0546b833063ce47363e" translate="yes" xml:space="preserve">
          <source>On Windows, this function returns the type of Windows kernel, like &quot;winnt&quot;. On Unix systems, it returns the same as the output of &lt;code&gt;uname -s&lt;/code&gt; (lowercased).</source>
          <target state="translated">Windows에서이 함수는 &quot;winnt&quot;와 같은 Windows 커널 유형을 리턴합니다. Unix 시스템에서는 &lt;code&gt;uname -s&lt;/code&gt; (소문자) 의 출력과 동일한 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7d6249275f9fbc46af397c053e27c8e82ae55f49" translate="yes" xml:space="preserve">
          <source>On Windows, this function will use the WinHTTP DLL functions. Despite its name, Microsoft suggests using it for all applications that require network connections, not just HTTP. This will respect the proxy settings set on the registry with the proxycfg.exe tool. If those settings are not found, this function will attempt to obtain Internet Explorer's settings and use them.</source>
          <target state="translated">Windows에서이 기능은 WinHTTP DLL 기능을 사용합니다. 그 이름에도 불구하고 Microsoft는 HTTP뿐만 아니라 네트워크 연결이 필요한 모든 응용 프로그램에 사용하는 것이 좋습니다. 이는 proxycfg.exe 도구를 사용하여 레지스트리에 설정된 프록시 설정을 준수합니다. 해당 설정을 찾지 못하면이 기능은 Internet Explorer의 설정을 가져 와서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="009e0df97f2e5d4e01405a88357006f9f19e7723" translate="yes" xml:space="preserve">
          <source>On Windows, this returns the drives visible in the &lt;b&gt;My Computer&lt;/b&gt; folder. On Unix operating systems, it returns the list of all mounted filesystems (except for pseudo filesystems).</source>
          <target state="translated">Windows에서는 &lt;b&gt;내 컴퓨터&lt;/b&gt; 폴더에 표시된 드라이브를 반환 합니다. Unix 운영 체제에서는 마운트 된 모든 파일 시스템 목록을 반환합니다 (의사 파일 시스템 제외).</target>
        </trans-unit>
        <trans-unit id="0936561a0967352768bfbc841c656154826ca8d9" translate="yes" xml:space="preserve">
          <source>On Windows, this value is used when the ownership of the D&amp;amp;D data should be taken over by the target application, i.e., the source application should not delete the data. On X11 this value is used to do a move. TargetMoveAction is not used on the Mac.</source>
          <target state="translated">Windows에서이 값은 대상 애플리케이션이 D &amp;amp; D 데이터의 소유권을 인계해야하는 경우에 사용됩니다. 즉, 소스 애플리케이션은 데이터를 삭제하지 않아야합니다. X11에서이 값은 이동을 수행하는 데 사용됩니다. Mac에서는 TargetMoveAction이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4eee6c744c3777dbddff6484cd65a374f2977b75" translate="yes" xml:space="preserve">
          <source>On Windows, toNativeSeparators(&quot;c:/winnt/system32&quot;) returns &quot;c:\winnt\system32&quot;.</source>
          <target state="translated">Windows에서 toNativeSeparators ( &quot;c : / winnt / system32&quot;)는 &quot;c : \ winnt \ system32&quot;를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6fb53d8edcc5cae3f92a646a3ff9898177717167" translate="yes" xml:space="preserve">
          <source>On Windows, triggers auto-generation of an .rc file if the &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set. The generated .rc file will have the FILEVERSION and PRODUCTVERSION entries filled with major, minor, patch level, and build number. Each number must be in the range from 0 to 65535. More details about the generation of .rc files can be found in the &lt;a href=&quot;qmake-platform-notes#&quot;&gt;Platform Notes&lt;/a&gt;.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우 .rc 파일의 자동 생성을 트리거합니다 . 생성 된 .rc 파일에는 FILEVERSION 및 PRODUCTVERSION 항목이 주, 부, 패치 레벨 및 빌드 번호로 채워집니다. 각 숫자의 범위는 0에서 65535 사이 여야합니다. .rc 파일 생성에 대한 자세한 내용은 &lt;a href=&quot;qmake-platform-notes#&quot;&gt;플랫폼 노트를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17635b63a5e5f6b5459a303d045e78a9e9cf7608" translate="yes" xml:space="preserve">
          <source>On Windows, triggers auto-generation of an .rc file if the &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set. The generated .rc file will have the FILEVERSION and PRODUCTVERSION entries filled with major, minor, patch level, and build number. Each number must be in the range from 0 to 65535. More details about the generation of .rc files can be found in the &lt;a href=&quot;qmake-platform-notes&quot;&gt;Platform Notes&lt;/a&gt;.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;qmake-variable-reference#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우 .rc 파일의 자동 생성을 트리거합니다 . 생성 된 .rc 파일에는 메이저, 마이너, 패치 수준 및 빌드 번호로 채워진 FILEVERSION 및 PRODUCTVERSION 항목이 있습니다. 각 숫자의 범위는 0에서 65535 사이 여야합니다. .rc 파일 생성에 대한 자세한 내용은 &lt;a href=&quot;qmake-platform-notes&quot;&gt;Platform Notes&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7804dbafb95752380b7a75defcc7241f6d49bcef" translate="yes" xml:space="preserve">
          <source>On Windows, when the KeyDown event for this key is sent, the Ctrl+Alt modifiers are also set.</source>
          <target state="translated">Windows에서이 키의 KeyDown 이벤트가 전송되면 Ctrl + Alt 수정 자도 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="730b836d8881154172539b5edb8b7c3bd51ef995" translate="yes" xml:space="preserve">
          <source>On Windows, when the Windows system registry is used, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; does not preserve the original type of the value. Therefore, the type of the value might change when a new value is set. For example, a value with type &lt;code&gt;REG_EXPAND_SZ&lt;/code&gt; will change to &lt;code&gt;REG_SZ&lt;/code&gt;.</source>
          <target state="translated">Windows에서 Windows 시스템 레지스트리가 사용될 때 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 는 원래 유형의 값을 유지하지 않습니다. 따라서 새 값이 설정되면 값 유형이 변경 될 수 있습니다. 예를 들어, &lt;code&gt;REG_EXPAND_SZ&lt;/code&gt; 유형의 값은 &lt;code&gt;REG_SZ&lt;/code&gt; 로 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="d807f2e4cbc7b11d6cf8cb01e99e5962c550d060" translate="yes" xml:space="preserve">
          <source>On Windows, when the Windows system registry is used, QSettings does not preserve the original type of the value. Therefore, the type of the value might change when a new value is set. For example, a value with type &lt;code&gt;REG_EXPAND_SZ&lt;/code&gt; will change to &lt;code&gt;REG_SZ&lt;/code&gt;.</source>
          <target state="translated">Windows에서 Windows 시스템 레지스트리를 사용할 때 QSettings는 값의 원래 유형을 보존하지 않습니다. 따라서 새 값이 설정되면 값의 유형이 변경 될 수 있습니다. 예를 들어 &lt;code&gt;REG_EXPAND_SZ&lt;/code&gt; 유형의 값은 &lt;code&gt;REG_SZ&lt;/code&gt; 로 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">Windows에서 :</target>
        </trans-unit>
        <trans-unit id="38bff627717e84c4edabc4f72056215a56db78a2" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to &quot;Calculator&quot; (XF86XK_Calculator) key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 &quot;계산기&quot;(XF86XK_Calculator) 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="eb011980df49c4979891a410f0db4938cb3a60ae" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to &quot;My Computer&quot; (XF86XK_MyComputer) key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 &quot;내 컴퓨터&quot;(XF86XK_MyComputer) 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="1bfe3c4f8fe5bd9ee3a20c50dccea55489cf6b63" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch0 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch0 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="38110747083a8ebebaf5bf2227de795089502230" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch1 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch1 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="b433e57774b23b1fba9ac94ebed25e6c5098b77e" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch2 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch2 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="215b19cd3792ab1e486526f2d225ecf7872a3a68" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch3 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch3 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="b6eba023acc8788fb39359621ce09415b381e3bb" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch4 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch4 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="044e49228d4ec744fae5846dcd722959672c193d" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch5 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch5 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="176c13710f95a8daaef6f59eb59cd96fe3499fa1" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch6 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch6 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="49ed2cc9414463eb9e5c87ff2895b838b0927830" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch7 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch7 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="eebef0fa1c574243e457f228b23d8b747720e57a" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch8 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch8 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="8973833e72301ced8eca68397f583495d93f340f" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch9 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch9 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="a9cda10da6811c461130577bf71c1b62570896a4" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_LaunchA key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_LaunchA 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="993b0f9701007d991189241d64f74b997482bcaf" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_LaunchB key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_LaunchB 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="edf8b286ee85c0b86bad62052749b94265fdc9c6" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_LaunchC key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_LaunchC 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="282a7579d151d39c6224732c8fd9e0e00d5e6878" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_LaunchD key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_LaunchD 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="0d49d72dc7b9cad7ec0bd39bc7e8903b3e9d0eb8" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_LaunchE key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_LaunchE 키에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="c3399a59cc479f88fd5846b477a3d2bbce888eeb" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_LaunchF key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_LaunchF 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="cf05a551e29074459d59198f9285d4acca8fe607" translate="yes" xml:space="preserve">
          <source>On X11 this key is not mapped for legacy reasons. Use Qt::Key_Launch1 instead.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 매핑되지 않습니다. Qt :: Key_Launch1을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ca4b93013030e6ab4726dc905a308d068ce1d21e" translate="yes" xml:space="preserve">
          <source>On X11,</source>
          <target state="translated">X11에서는</target>
        </trans-unit>
        <trans-unit id="6b6585d9074e4aa129ab3877f868a593cdbeb093" translate="yes" xml:space="preserve">
          <source>On X11, Qt supports the &lt;a href=&quot;http://www.xfree86.org/4.3.0/Xcursor.3.html&quot;&gt;Xcursor&lt;/a&gt; library, which allows for full color icon themes. The table below shows the cursor name used for each &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt::CursorShape&lt;/a&gt; value. If a cursor cannot be found using the name shown below, a standard X11 cursor will be used instead. Note: X11 does not provide appropriate cursors for all possible &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt::CursorShape&lt;/a&gt; values. It is possible that some cursors will be taken from the Xcursor theme, while others will use an internal bitmap cursor.</source>
          <target state="translated">X11에서 Qt는 풀 컬러 아이콘 테마를 허용 하는 &lt;a href=&quot;http://www.xfree86.org/4.3.0/Xcursor.3.html&quot;&gt;Xcursor&lt;/a&gt; 라이브러리를 지원합니다 . 아래 표는 각 &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt :: CursorShape&lt;/a&gt; 값에 사용되는 커서 이름을 보여줍니다 . 아래 표시된 이름을 사용하여 커서를 찾을 수없는 경우 표준 X11 커서가 대신 사용됩니다. 참고 : X11은 가능한 모든 &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt :: CursorShape&lt;/a&gt; 값에 대해 적절한 커서를 제공하지 않습니다 . 일부 커서는 Xcursor 테마에서 가져오고 다른 커서는 내부 비트 맵 커서를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b6fe6b086079c230da14348db2af20226d626fc" translate="yes" xml:space="preserve">
          <source>On X11, Qt supports the &lt;a href=&quot;http://www.xfree86.org/4.3.0/Xcursor.3.html#&quot;&gt;Xcursor&lt;/a&gt; library, which allows for full color icon themes. The table below shows the cursor name used for each &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt::CursorShape&lt;/a&gt; value. If a cursor cannot be found using the name shown below, a standard X11 cursor will be used instead. Note: X11 does not provide appropriate cursors for all possible &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt::CursorShape&lt;/a&gt; values. It is possible that some cursors will be taken from the Xcursor theme, while others will use an internal bitmap cursor.</source>
          <target state="translated">X11에서 Qt는 풀 &lt;a href=&quot;http://www.xfree86.org/4.3.0/Xcursor.3.html#&quot;&gt;커버&lt;/a&gt; 아이콘 테마를 허용 하는 Xcursor 라이브러리를 지원합니다 . 아래 표는 각 &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt :: CursorShape&lt;/a&gt; 값에 사용되는 커서 이름을 보여줍니다 . 아래 표시된 이름으로 커서를 찾을 수 없으면 표준 X11 커서가 대신 사용됩니다. 참고 : X11은 가능한 모든 &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt :: CursorShape&lt;/a&gt; 값에 적절한 커서를 제공하지 않습니다 . 일부 커서는 Xcursor 테마에서 가져 오는 반면 다른 커서는 내부 비트 맵 커서를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f66a29a941a3f1c1178fa1f4051ed7633dcc7944" translate="yes" xml:space="preserve">
          <source>On X11, a window does not have a frame until the window manager decorates it. This happens asynchronously at some point in time after calling &lt;a href=&quot;qwidget#show&quot;&gt;QWidget::show&lt;/a&gt;() and the first paint event the window receives, or it does not happen at all. Bear in mind that X11 is policy-free (others call it flexible). Thus you cannot make any safe assumption about the decoration frame your window will get. Basic rule: There's always one user who uses a window manager that breaks your assumption, and who will complain to you.</source>
          <target state="translated">X11에서는 창 관리자가 장식 할 때까지 창에 프레임이 없습니다. 이것은 &lt;a href=&quot;qwidget#show&quot;&gt;QWidget :: show&lt;/a&gt; ()를 호출 한 후 특정 시점에서 비동기 적으로 발생 하며 윈도우가 수신하는 첫 번째 페인트 이벤트이거나 전혀 발생하지 않습니다. X11은 정책이 필요 없습니다 (다른 사람들은 유연하다고 부릅니다). 따라서 창을 가져올 장식 프레임에 대해 안전한 가정을 할 수 없습니다. 기본 규칙 : 항상 가정 관리자를 사용하여 가정을 어 기고 불만을 제기하는 사용자는 한 명입니다.</target>
        </trans-unit>
        <trans-unit id="74bd622a9f5b268193d42ed1193ac4712fc8aefe" translate="yes" xml:space="preserve">
          <source>On X11, if not set, the fallback icon theme depends on your desktop settings. On other platforms it is not set by default.</source>
          <target state="translated">X11에서 설정하지 않은 경우 대체 아이콘 테마는 데스크탑 설정에 따라 다릅니다. 다른 플랫폼에서는 기본적으로 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54da02e1730b21efd6d44aefe3448beb691d16ba" translate="yes" xml:space="preserve">
          <source>On X11, it is also possible to draw on the desktop.</source>
          <target state="translated">X11에서는 바탕 화면에 그릴 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad44e1dbefcc93a469ce1e22bfadbf193d474b6d" translate="yes" xml:space="preserve">
          <source>On X11, the current icon theme depends on your desktop settings. On other platforms it is not set by default.</source>
          <target state="translated">X11에서 현재 아이콘 테마는 데스크탑 설정에 따라 다릅니다. 다른 플랫폼에서는 기본적으로 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="984489ecfc83d609f42ecee5acbf6bd8aa4e72cd" translate="yes" xml:space="preserve">
          <source>On X11, the document name is for example used as the default output filename in &lt;a href=&quot;qprintdialog&quot;&gt;QPrintDialog&lt;/a&gt;. Note that the document name does not affect the file name if the printer is printing to a file. Use the setOutputFile() function for this.</source>
          <target state="translated">X11에서 문서 이름은 예를 들어 &lt;a href=&quot;qprintdialog&quot;&gt;QPrintDialog&lt;/a&gt; 에서 기본 출력 파일 이름으로 사용됩니다 . 프린터가 파일로 인쇄하는 경우 문서 이름은 파일 이름에 영향을주지 않습니다. 이를 위해 setOutputFile () 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f27fe241c6c987ddd4ff6638b2510debe04bb5c0" translate="yes" xml:space="preserve">
          <source>On X11, the public &lt;a href=&quot;http://www.newplanetsoftware.com/xdnd/&quot;&gt;XDND protocol&lt;/a&gt; is used, while on Windows Qt uses the OLE standard, and Qt for &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; uses the Cocoa Drag Manager. On X11, XDND uses MIME, so no translation is necessary. The Qt API is the same regardless of the platform. On Windows, MIME-aware applications can communicate by using clipboard format names that are MIME types. Already some Windows applications use MIME naming conventions for their clipboard formats.</source>
          <target state="translated">X11에서는 공개 &lt;a href=&quot;http://www.newplanetsoftware.com/xdnd/&quot;&gt;XDND 프로토콜&lt;/a&gt; 이 사용되는 반면 Windows Qt는 OLE 표준을 사용하고 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS 용&lt;/a&gt; Qt 는 Cocoa Drag Manager를 사용합니다. X11에서 XDND는 MIME을 사용하므로 변환이 필요하지 않습니다. Qt API는 플랫폼에 관계없이 동일합니다. Windows에서 MIME 인식 응용 프로그램은 MIME 유형 인 클립 보드 형식 이름을 사용하여 통신 할 수 있습니다. 이미 일부 Windows 응용 프로그램은 클립 보드 형식에 MIME 명명 규칙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="985302818f764cf35aaeea8f228232e784f34c07" translate="yes" xml:space="preserve">
          <source>On X11, the public &lt;a href=&quot;http://www.newplanetsoftware.com/xdnd/&quot;&gt;XDND protocol&lt;/a&gt; is used, while on Windows Qt uses the OLE standard, and Qt for macOS uses the Cocoa Drag Manager. On X11, XDND uses MIME, so no translation is necessary. The Qt API is the same regardless of the platform. On Windows, MIME-aware applications can communicate by using clipboard format names that are MIME types. Already some Windows applications use MIME naming conventions for their clipboard formats.</source>
          <target state="translated">X11에서는 공용 &lt;a href=&quot;http://www.newplanetsoftware.com/xdnd/&quot;&gt;XDND 프로토콜&lt;/a&gt; 이 사용되는 반면 Windows에서는 Qt가 OLE 표준을 사용하고 macOS 용 Qt는 Cocoa Drag Manager를 사용합니다. X11에서 XDND는 MIME를 사용하므로 번역이 필요하지 않습니다. Qt API는 플랫폼에 관계없이 동일합니다. Windows에서 MIME 인식 응용 프로그램은 MIME 유형 인 클립 보드 형식 이름을 사용하여 통신 할 수 있습니다. 이미 일부 Windows 응용 프로그램은 클립 보드 형식에 MIME 명명 규칙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="746576bc1b84c50d9a8e7498467d0d47eb363722" translate="yes" xml:space="preserve">
          <source>On X11, the search path will use the XDG_DATA_DIRS environment variable if available.</source>
          <target state="translated">X11에서 검색 경로는 사용 가능한 경우 XDG_DATA_DIRS 환경 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a9074f202c6877dc2505a9ae7cf75c9f51f7cbf3" translate="yes" xml:space="preserve">
          <source>On X11, this function may not work properly with certain window managers. See the &lt;a href=&quot;application-windows#window-geometry&quot;&gt;Window Geometry&lt;/a&gt; documentation for an explanation.</source>
          <target state="translated">X11에서는이 기능이 특정 창 관리자에서 제대로 작동하지 않을 수 있습니다. 설명은 &lt;a href=&quot;application-windows#window-geometry&quot;&gt;Window Geometry&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca8a7c2c378269fc18338fdfb24d9563e2b0b997" translate="yes" xml:space="preserve">
          <source>On X11, this function sets the program to call with the PDF output. On other platforms, it has no effect.</source>
          <target state="translated">X11에서이 기능은 프로그램이 PDF 출력으로 호출하도록 설정합니다. 다른 플랫폼에서는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="378efc0cfc3a063ee9441da0010f98a74ba38499" translate="yes" xml:space="preserve">
          <source>On X11, this will cause the window to be marked as &quot;demands attention&quot;, the window must not be hidden (i.e. not have hide() called on it, but be visible in some sort of way) in order for this to work.</source>
          <target state="translated">X11에서는 이로 인해 창에 &quot;주의가 필요함&quot;으로 표시됩니다.이 작업을 수행하려면 창을 숨기지 않아야합니다 (즉, hide ()를 호출하지 말고 어떤 방식으로 볼 수 있어야 함).</target>
        </trans-unit>
        <trans-unit id="ce39c3052ac1f59f934bd2a1073483ba593e315a" translate="yes" xml:space="preserve">
          <source>On a Windows system with LLVM installed to &lt;code&gt;C:\Program Files\LLVM&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;C:\Program Files\LLVM&lt;/code&gt; LLVM이 설치된 Windows 시스템 :</target>
        </trans-unit>
        <trans-unit id="aa27746d74f17d76cf69db42d49e7edcd107a3bc" translate="yes" xml:space="preserve">
          <source>On a device there can be many types of sensors. Not all of the types that the Qt Sensors API supports may be available. There may also be types available that are not defined in the Qt Sensors API. The types of sensors available on a device is found using the &lt;a href=&quot;qsensor#sensorTypes&quot;&gt;QSensor::sensorTypes&lt;/a&gt;() function.</source>
          <target state="translated">장치에는 여러 유형의 센서가있을 수 있습니다. Qt 센서 API가 지원하는 모든 유형을 사용할 수있는 것은 아닙니다. Qt 센서 API에 정의되지 않은 사용 가능한 유형이있을 수도 있습니다. 장치에서 사용 가능한 센서 유형은 &lt;a href=&quot;qsensor#sensorTypes&quot;&gt;QSensor :: sensorTypes&lt;/a&gt; () 함수를 사용하여 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="340cb1db0d82a6cc7816d765de5e6299d3925a35" translate="yes" xml:space="preserve">
          <source>On a graphics tablet, each type of stylus or other tool often has a unique ID or serial number, which can be useful to respond in different ways to different tools.</source>
          <target state="translated">그래픽 태블릿에서 각 스타일러스 또는 기타 도구 유형은 종종 고유 한 ID 또는 일련 번호를 가지므로 다른 도구에 다른 방식으로 응답하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5a208e157e201403e7f8007e1aae656a1c9dcbe" translate="yes" xml:space="preserve">
          <source>On a mobile device it can be used to easily choose between front-facing and back-facing cameras. If this property is set to &lt;code&gt;Camera.UnspecifiedPosition&lt;/code&gt;, the system's default camera will be used.</source>
          <target state="translated">모바일 장치에서는 전면 카메라와 후면 카메라 중 하나를 쉽게 선택할 수 있습니다. 이 속성을 &lt;code&gt;Camera.UnspecifiedPosition&lt;/code&gt; 으로 설정 하면 시스템의 기본 카메라가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="491d790280531d0f6862a8c9d7407d4ffcb6efd3" translate="yes" xml:space="preserve">
          <source>On a mobile device, this property can be used to easily choose between front-facing and back-facing cameras. If this property is set to &lt;code&gt;Camera.UnspecifiedPosition&lt;/code&gt;, the system's default camera is used.</source>
          <target state="translated">모바일 장치에서이 속성을 사용하여 전면 카메라와 후면 카메라 중에서 쉽게 선택할 수 있습니다. 이 속성이 &lt;code&gt;Camera.UnspecifiedPosition&lt;/code&gt; 으로 설정 되면 시스템의 기본 카메라가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ca20d418a110fc0695735cdb329e225f1c92da2e" translate="yes" xml:space="preserve">
          <source>On a typical Unix system, this will be /usr/share/mime/packages/, but it is also possible to extend the list of directories by setting the environment variable &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt;. For instance adding /opt/myapp/share to &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; will result in /opt/myapp/share/mime/packages/ being searched for MIME definitions.</source>
          <target state="translated">일반적인 Unix 시스템에서 이것은 / usr / share / mime / packages /이지만 환경 변수 &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; 를 설정하여 디렉토리 목록을 확장 할 수도 있습니다 . 예를 들어 / opt / myapp / share를 &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; 에 추가하면 / opt / myapp / share / mime / packages /에서 MIME 정의를 검색하게됩니다.</target>
        </trans-unit>
        <trans-unit id="a045d83adbceaaf476607421f1d3a7548e3674dc" translate="yes" xml:space="preserve">
          <source>On accepting one gesture Qt can automatically cancel other gestures that belong to other targets. The policy is normally set to not cancel any other gestures and can be set to cancel all active gestures in the context. For example for all child widgets.</source>
          <target state="translated">하나의 제스처 수락시 Qt는 다른 대상에 속하는 다른 제스처를 자동으로 취소 할 수 있습니다. 정책은 일반적으로 다른 제스처를 취소하지 않도록 설정되며 컨텍스트에서 모든 활성 제스처를 취소하도록 설정할 수 있습니다. 예를 들어 모든 하위 위젯의 경우.</target>
        </trans-unit>
        <trans-unit id="3d5d4aac9f5bb2f56e17586b4f740822cb3feebc" translate="yes" xml:space="preserve">
          <source>On accepting this gesture all gestures that are active in the context (respecting the &lt;a href=&quot;qt#GestureFlag-enum&quot;&gt;Qt::GestureFlag&lt;/a&gt; that were specified when subscribed to the gesture) will be cancelled.</source>
          <target state="translated">이 제스처를 수락하면 컨텍스트에서 활성화 된 모든 제스처 (제스처를 구독 할 때 지정된 &lt;a href=&quot;qt#GestureFlag-enum&quot;&gt;Qt :: GestureFlag&lt;/a&gt; 와 관련)가 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="b421fa6b19590a40b1da7065155d72721b081222" translate="yes" xml:space="preserve">
          <source>On accepting this gesture no other gestures will be affected.</source>
          <target state="translated">이 제스처를 수락하면 다른 제스처는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2dae3f602210c8a1c83d3cfe0e15ba0c18cb1abd" translate="yes" xml:space="preserve">
          <source>On all other UNIX-like operating systems, the type is a file descriptor representing a listening socket.</source>
          <target state="translated">다른 모든 UNIX 유사 운영 체제에서 유형은 청취 소켓을 나타내는 파일 디스크립터입니다.</target>
        </trans-unit>
        <trans-unit id="a3e3bd97df1ff42c4cc75d81c6f780421ba4b461" translate="yes" xml:space="preserve">
          <source>On all other UNIX-like operating systems, the type is a file descriptor representing a socket.</source>
          <target state="translated">다른 모든 UNIX 유사 운영 체제에서 유형은 소켓을 나타내는 파일 디스크립터입니다.</target>
        </trans-unit>
        <trans-unit id="3015490dacdd20b476d47e7ff4c0f6c454b09ba0" translate="yes" xml:space="preserve">
          <source>On all platforms the depth of the primary screen will be returned.</source>
          <target state="translated">모든 플랫폼에서 기본 화면의 깊이가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="082bb82a57d92617162ab4a21855edeecb241b8d" translate="yes" xml:space="preserve">
          <source>On all platforms, the following tools are required:</source>
          <target state="translated">모든 플랫폼에서 다음 도구가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7cb19b7a63de8255c0da90508c370aab063f74ef" translate="yes" xml:space="preserve">
          <source>On all platforms, the interval for Qt::VeryCoarseTimer is rounded to the nearest full second (e.g. an interval of 23500ms will be rounded to 24000ms, and 20300ms to 20000ms).</source>
          <target state="translated">모든 플랫폼에서 Qt :: VeryCoarseTimer의 간격은 가장 가까운 초 단위로 반올림됩니다 (예 : 23500ms 간격은 24000ms로, 20300ms ~ 20000ms로 반올림 됨).</target>
        </trans-unit>
        <trans-unit id="45fdfa68c255f9c04c3bf620adbf177e0249cf92" translate="yes" xml:space="preserve">
          <source>On and Off states of a Switch.</source>
          <target state="translated">스위치의 켜짐 및 꺼짐 상태.</target>
        </trans-unit>
        <trans-unit id="8b8ba8893e72c59a415a54b794c557d21b211bf7" translate="yes" xml:space="preserve">
          <source>On any platform other than Windows, this function returns a new UUID with variant &lt;a href=&quot;quuid#Variant-enum&quot;&gt;QUuid::DCE&lt;/a&gt; and version &lt;a href=&quot;quuid#Version-enum&quot;&gt;QUuid::Random&lt;/a&gt;. On Windows, a GUID is generated using the Windows API and will be of the type that the API decides to create.</source>
          <target state="translated">Windows 이외의 플랫폼에서이 함수는 변형 &lt;a href=&quot;quuid#Variant-enum&quot;&gt;QUuid :: DCE&lt;/a&gt; 및 버전 &lt;a href=&quot;quuid#Version-enum&quot;&gt;QUuid :: Random&lt;/a&gt; 과 함께 새 UUID를 리턴합니다 . Windows에서 GUID는 Windows API를 사용하여 생성되며 API가 작성하기로 결정한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="70aae88ca52c27299c6a2609cdb44d734f570ae4" translate="yes" xml:space="preserve">
          <source>On application start-up, the default font depends on the window system. It can vary depending on both the window system version and the locale. This function lets you override the default font; but overriding may be a bad idea because, for example, some locales need extra large fonts to support their special characters.</source>
          <target state="translated">응용 프로그램 시작시 기본 글꼴은 창 시스템에 따라 다릅니다. 윈도우 시스템 버전과 로케일에 따라 다를 수 있습니다. 이 기능을 사용하면 기본 글꼴을 무시할 수 있습니다. 예를 들어, 일부 로케일은 특수 문자를 지원하기 위해 더 큰 글꼴이 필요하기 때문에 재정의는 나쁜 생각 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92d2687521999a064a90d13dfba6f9269e095356" translate="yes" xml:space="preserve">
          <source>On application startup, &lt;code&gt;EGLFS&lt;/code&gt; and &lt;code&gt;LinuxFB&lt;/code&gt; attempt to disable the terminal keyboard by setting the tty's keyboard mode to &lt;code&gt;K_OFF&lt;/code&gt;. This prevents keystrokes from being sent to the terminal. If the standard behavior is required, set the &lt;code&gt;QT_QPA_ENABLE_TERMINAL_KEYBOARD&lt;/code&gt; environment variable to &lt;code&gt;1&lt;/code&gt;. Note that this works only when the application is launched from a remote console, via &lt;code&gt;ssh&lt;/code&gt; for example, and the terminal keyboard input remains enabled.</source>
          <target state="translated">애플리케이션 시작시 &lt;code&gt;EGLFS&lt;/code&gt; 및 &lt;code&gt;LinuxFB&lt;/code&gt; 는 tty의 키보드 모드를 &lt;code&gt;K_OFF&lt;/code&gt; 로 설정하여 터미널 키보드를 사용 안함으로 설정하려고합니다 . 이렇게하면 키 입력이 터미널로 전송되지 않습니다. 표준 동작이 필요한 경우 &lt;code&gt;QT_QPA_ENABLE_TERMINAL_KEYBOARD&lt;/code&gt; 환경 변수를 &lt;code&gt;1&lt;/code&gt; 로 설정하십시오 . 이것은 예를 들어 &lt;code&gt;ssh&lt;/code&gt; 를 통해 원격 콘솔에서 응용 프로그램이 시작되고 터미널 키보드 입력이 활성화 된 상태로 유지 되는 경우에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="0568eb2583df7e6d21c288f87183e801bfabfbe9" translate="yes" xml:space="preserve">
          <source>On certain platforms, a framebuffer other than 0 might be the default frame buffer depending on the current surface. Instead of calling glBindFramebuffer(0), it is recommended that you use glBindFramebuffer(ctx-&amp;gt;&lt;a href=&quot;qopenglcontext#defaultFramebufferObject&quot;&gt;defaultFramebufferObject&lt;/a&gt;()), to ensure that your application is portable between different platforms. However, if you use &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html#glBindFramebuffer&quot;&gt;QOpenGLFunctions::glBindFramebuffer&lt;/a&gt;(), this is done automatically for you.</source>
          <target state="translated">특정 플랫폼에서 현재 표면에 따라 0 이외의 프레임 버퍼가 기본 프레임 버퍼 일 수 있습니다. glBindFramebuffer (0)를 호출하는 대신 glBindFramebuffer (ctx-&amp;gt; &lt;a href=&quot;qopenglcontext#defaultFramebufferObject&quot;&gt;defaultFramebufferObject&lt;/a&gt; ())를 사용하여 응용 프로그램이 다른 플랫폼간에 이식 가능하도록하는 것이 좋습니다 . 그러나 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html#glBindFramebuffer&quot;&gt;QOpenGLFunctions :: glBindFramebuffer&lt;/a&gt; ()를 사용하면 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c9146a892e68e606992b3008c3ea1ef7ac59ed53" translate="yes" xml:space="preserve">
          <source>On certain platforms, a framebuffer other than 0 might be the default frame buffer depending on the current surface. Instead of calling glBindFramebuffer(0), it is recommended that you use glBindFramebuffer(ctx-&amp;gt;&lt;a href=&quot;qopenglcontext#defaultFramebufferObject&quot;&gt;defaultFramebufferObject&lt;/a&gt;()), to ensure that your application is portable between different platforms. However, if you use &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html#glBindFramebuffer&quot;&gt;QOpenGLFunctions::glBindFramebuffer&lt;/a&gt;(), this is done automatically for you.</source>
          <target state="translated">특정 플랫폼에서는 현재 표면에 따라 0이 아닌 프레임 버퍼가 기본 프레임 버퍼가 될 수 있습니다. glBindFramebuffer (0)를 호출하는 대신 glBindFramebuffer (ctx-&amp;gt; &lt;a href=&quot;qopenglcontext#defaultFramebufferObject&quot;&gt;defaultFramebufferObject&lt;/a&gt; ())를 사용하여 애플리케이션이 서로 다른 플랫폼간에 이식 가능한지 확인하는 것이 좋습니다 . 그러나 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html#glBindFramebuffer&quot;&gt;QOpenGLFunctions :: glBindFramebuffer&lt;/a&gt; ()를 사용하면 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="1cfe0d4026de3d522cc9722da7e09768c50faa10" translate="yes" xml:space="preserve">
          <source>On certain platforms, a framebuffer other than 0 might be the default frame buffer depending on the current surface. Instead of calling glBindFramebuffer(0), it is recommended that you use glBindFramebuffer(ctx-&amp;gt;&lt;a href=&quot;qopenglcontext#defaultFramebufferObject&quot;&gt;defaultFramebufferObject&lt;/a&gt;()), to ensure that your application is portable between different platforms. However, if you use &lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html#glBindFramebuffer&quot;&gt;QOpenGLFunctions::glBindFramebuffer&lt;/a&gt;(), this is done automatically for you.</source>
          <target state="translated">특정 플랫폼에서는 현재 표면에 따라 0이 아닌 프레임 버퍼가 기본 프레임 버퍼가 될 수 있습니다. glBindFramebuffer (0)를 호출하는 대신 glBindFramebuffer (ctx-&amp;gt; &lt;a href=&quot;qopenglcontext#defaultFramebufferObject&quot;&gt;defaultFramebufferObject&lt;/a&gt; ())를 사용하여 애플리케이션이 서로 다른 플랫폼간에 이식 가능한지 확인하는 것이 좋습니다 . 그러나 &lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html#glBindFramebuffer&quot;&gt;QOpenGLFunctions :: glBindFramebuffer&lt;/a&gt; ()를 사용하면 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6156b0e0e39a185887766587b4acdb86aac5fbc4" translate="yes" xml:space="preserve">
          <source>On certain widgets, using '&amp;amp;' in front of a character will automatically create a mnemonic (a shortcut) for that character, e.g. &quot;E&amp;amp;xit&quot; will create the shortcut &lt;b&gt;Alt+X&lt;/b&gt; (use '&amp;amp;&amp;amp;' to display an actual ampersand). The widget might consume and perform an action on a given shortcut. On X11 the ampersand will not be shown and the character will be underlined. On Windows, shortcuts are normally not displayed until the user presses the &lt;b&gt;Alt&lt;/b&gt; key, but this is a setting the user can change. On Mac, shortcuts are disabled by default. Call &lt;a href=&quot;qkeysequence#qt_set_sequence_auto_mnemonic&quot;&gt;qt_set_sequence_auto_mnemonic&lt;/a&gt;() to enable them. However, because mnemonic shortcuts do not fit in with Aqua's guidelines, Qt will not show the shortcut character underlined.</source>
          <target state="translated">특정 위젯에서 문자 앞에 '&amp;amp;'를 사용하면 해당 문자에 대한 니모닉 (단축키)이 자동으로 생성됩니다. 예를 들어 &quot;E &amp;amp; xit&quot;는 단축키 &lt;b&gt;Alt + X를&lt;/b&gt; 생성합니다 ( '&amp;amp;&amp;amp;'를 사용하여 실제 앰퍼샌드 표시). 위젯은 주어진 단축키에 대해 조치를 수행하고 수행 할 수 있습니다. X11에서는 앰퍼샌드가 표시되지 않고 문자에 밑줄이 표시됩니다. Windows에서는 사용자가 &lt;b&gt;Alt&lt;/b&gt; 키를 누를 때까지 바로 가기가 일반적으로 표시되지 않지만 사용자가 변경할 수있는 설정입니다. Mac에서는 단축키가 기본적으로 비활성화되어 있습니다. 활성화하려면 &lt;a href=&quot;qkeysequence#qt_set_sequence_auto_mnemonic&quot;&gt;qt_set_sequence_auto_mnemonic&lt;/a&gt; ()을 호출 하십시오 . 그러나 니모닉 바로 가기는 Aqua의 지침에 맞지 않기 때문에 Qt는 바로 가기 문자에 밑줄이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3eb68cd74bebcf6de6cd1cde5ba9951e6cfab0cd" translate="yes" xml:space="preserve">
          <source>On desktop Windows, the default value is the value of the environment variable &lt;code&gt;WindowsSDKVersion&lt;/code&gt;.</source>
          <target state="translated">데스크탑 Windows에서 기본값은 환경 변수 &lt;code&gt;WindowsSDKVersion&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="cbcfc50480ff53139c39f8329ec33e7886b52267" translate="yes" xml:space="preserve">
          <source>On desktop platforms, it is common for modal popups to be closed only when the escape key is pressed. To achieve this behavior, set &lt;a href=&quot;qml-qtquick-controls2-popup#closePolicy-prop&quot;&gt;closePolicy&lt;/a&gt; to &lt;code&gt;Popup.CloseOnEscape&lt;/code&gt;. By default, &lt;code&gt;closePolicy&lt;/code&gt; is set to &lt;code&gt;Popup.CloseOnEscape | Popup.CloseOnPressOutside&lt;/code&gt;, which means that clicking outside of a modal popup will close it.</source>
          <target state="translated">데스크탑 플랫폼에서는 이스케이프 키를 누를 때만 모달 팝업이 닫히는 것이 일반적입니다. 이 동작을 수행하려면 &lt;a href=&quot;qml-qtquick-controls2-popup#closePolicy-prop&quot;&gt;closePolicy&lt;/a&gt; 를 &lt;code&gt;Popup.CloseOnEscape&lt;/code&gt; 로 설정 하십시오 . 기본적으로 &lt;code&gt;closePolicy&lt;/code&gt; 는 &lt;code&gt;Popup.CloseOnEscape | Popup.CloseOnPressOutside&lt;/code&gt; 는 모달 팝업 외부를 클릭하면 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="c915f9e77e2dea119e73f345df9b72d3f2df7349" translate="yes" xml:space="preserve">
          <source>On embedded systems, where the hardware has limited resources, this approach can be inefficient. Qt Quick Controls 2 was designed to solve this problem, using &lt;a href=&quot;https://blog.qt.io/blog/2015/03/31/qt-quick-controls-for-embedded/&quot;&gt;benchmarks&lt;/a&gt; to guide the development.</source>
          <target state="translated">하드웨어의 리소스가 제한적인 임베디드 시스템에서는이 방법이 비효율적 일 수 있습니다. Qt Quick Controls 2는 개발을 안내하기 위해 &lt;a href=&quot;https://blog.qt.io/blog/2015/03/31/qt-quick-controls-for-embedded/&quot;&gt;벤치 마크&lt;/a&gt; 를 사용하여이 문제를 해결하도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="33aeee0ea96e0d18986de40ff4bd90a3a293c350" translate="yes" xml:space="preserve">
          <source>On embedded systems, where the hardware has limited resources, this approach can be inefficient. Qt Quick Controls was designed to solve this problem, using &lt;a href=&quot;https://blog.qt.io/blog/2015/03/31/qt-quick-controls-for-embedded/&quot;&gt;benchmarks&lt;/a&gt; to guide the development.</source>
          <target state="translated">하드웨어에 제한된 리소스가있는 임베디드 시스템에서는이 접근 방식이 비효율적 일 수 있습니다. Qt Quick Controls는 &lt;a href=&quot;https://blog.qt.io/blog/2015/03/31/qt-quick-controls-for-embedded/&quot;&gt;벤치 마크&lt;/a&gt; 를 사용하여 개발을 안내 하여이 문제를 해결하도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ce146db8bcf0076c6e6ab523d6cb838851bd351f" translate="yes" xml:space="preserve">
          <source>On failure and if non-null, the</source>
          <target state="translated">실패시 및 널이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="05eb7270f90398951853ca19b852813c90eb6fdd" translate="yes" xml:space="preserve">
          <source>On failure, returns a &lt;a href=&quot;qnetworkdatagram&quot;&gt;QNetworkDatagram&lt;/a&gt; that reports &lt;a href=&quot;qnetworkdatagram#isValid&quot;&gt;not valid&lt;/a&gt;.</source>
          <target state="translated">실패하면 &lt;a href=&quot;qnetworkdatagram#isValid&quot;&gt;유효하지 않은&lt;/a&gt; 것으로보고 하는 &lt;a href=&quot;qnetworkdatagram&quot;&gt;QNetworkDatagram&lt;/a&gt; 을 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="cffad191a057506e0a048b861e4057f9315bad97" translate="yes" xml:space="preserve">
          <source>On hardware that supports it, this class lets you adjust the focus or zoom (both optical and digital). This also includes things like &quot;Macro&quot; mode for close up work (e.g. reading barcodes, or recognising letters), or &quot;touch to focus&quot; - indicating an interesting area of the viewfinder for the hardware to attempt to focus on.</source>
          <target state="translated">이를 지원하는 하드웨어에서이 클래스를 사용하면 초점 또는 줌 (광학 및 디지털)을 조정할 수 있습니다. 여기에는 근접 작업을위한 &quot;매크로&quot;모드 (예 : 바코드 읽기 또는 문자 인식) 또는 &quot;초점을 터치&quot;와 같은 것들이 포함됩니다. 이는 하드웨어가 초점을 맞추려고하는 뷰 파인더의 흥미로운 영역을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8363885fcb9687f6ab4a2f24d0dcc370caef0bdb" translate="yes" xml:space="preserve">
          <source>On iOS and Windows, this class cannot be used because the platform does not expose any data or API which may provide information on the local Bluetooth device.</source>
          <target state="translated">iOS 및 Windows에서는 플랫폼이 로컬 Bluetooth 장치에 대한 정보를 제공 할 수있는 데이터 또는 API를 노출하지 않으므로이 클래스를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a56aadea1cc7d6d509c113bc4866c5274d8796fb" translate="yes" xml:space="preserve">
          <source>On iOS, starting from version 8, Core Location framework requires additional entries in the application's Info.plist with keys NSLocationAlwaysUsageDescription or NSLocationWhenInUseUsageDescription and a string to be displayed in the authorization prompt. The key NSLocationWhenInUseUsageDescription is used when requesting permission to use location services while the app is in the foreground. The key NSLocationAlwaysUsageDescription is used when requesting permission to use location services whenever the app is running (both the foreground and the background). If both entries are defined, NSLocationWhenInUseUsageDescription has a priority in the foreground mode.</source>
          <target state="translated">iOS에서 버전 8부터 핵심 위치 프레임 워크는 애플리케이션의 Info.plist에 NSLocationAlwaysUsageDescription 또는 NSLocationWhenInUseUsageDescription 키와 함께 권한 프롬프트에 표시 할 추가 항목이 필요합니다. NSLocationWhenInUseUsageDescription 키는 앱이 포 그라운드에있는 동안 위치 서비스 사용 권한을 요청할 때 사용됩니다. NSLocationAlwaysUsageDescription 키는 앱이 실행될 때마다 (포 그라운드 및 백그라운드 모두) 위치 서비스 사용 권한을 요청할 때 사용됩니다. 두 항목이 모두 정의 된 경우 NSLocationWhenInUseUsageDescription은 포 그라운드 모드에서 우선 순위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="7ec73f72e47f18ae88197f2e4f20a3d1a36d1ce2" translate="yes" xml:space="preserve">
          <source>On iOS, this class cannot be used because the platform does not expose an API which may permit access to &lt;a href=&quot;qbluetoothserver&quot;&gt;QBluetoothServer&lt;/a&gt; related features.</source>
          <target state="translated">iOS에서는 플랫폼이 &lt;a href=&quot;qbluetoothserver&quot;&gt;QBluetoothServer&lt;/a&gt; 관련 기능에 대한 액세스를 허용 할 수있는 API를 노출하지 않으므로이 클래스를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="339598eed30335c3b1dba3c33ce2e9524cb4dfb3" translate="yes" xml:space="preserve">
          <source>On iOS, this class cannot be used because the platform does not expose an API which may permit access to &lt;a href=&quot;qbluetoothservicediscoveryagent&quot;&gt;QBluetoothServiceDiscoveryAgent&lt;/a&gt; related features.</source>
          <target state="translated">iOS에서는 플랫폼이 &lt;a href=&quot;qbluetoothservicediscoveryagent&quot;&gt;QBluetoothServiceDiscoveryAgent&lt;/a&gt; 관련 기능에 대한 액세스를 허용 할 수있는 API를 노출하지 않으므로이 클래스를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d1eaa32fa95be2fefceece0a927dee8f9ec94159" translate="yes" xml:space="preserve">
          <source>On iOS, this class cannot be used because the platform does not expose an API which may permit access to &lt;a href=&quot;qbluetoothserviceinfo&quot;&gt;QBluetoothServiceInfo&lt;/a&gt; related features.</source>
          <target state="translated">iOS에서는 플랫폼이 &lt;a href=&quot;qbluetoothserviceinfo&quot;&gt;QBluetoothServiceInfo&lt;/a&gt; 관련 기능에 대한 액세스를 허용 할 수있는 API를 노출하지 않으므로이 클래스를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9faf3405ced15a18dfd9b103a487f9e78fd57842" translate="yes" xml:space="preserve">
          <source>On iOS, this class cannot be used because the platform does not expose an API which may permit access to &lt;a href=&quot;qbluetoothsocket&quot;&gt;QBluetoothSocket&lt;/a&gt; related features.</source>
          <target state="translated">iOS에서는 플랫폼이 &lt;a href=&quot;qbluetoothsocket&quot;&gt;QBluetoothSocket&lt;/a&gt; 관련 기능에 대한 액세스를 허용 할 수있는 API를 노출하지 않으므로이 클래스를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="59798b824ae8d6dbb35d12ef5e1879ce2b0c0cc2" translate="yes" xml:space="preserve">
          <source>On iOS, this class cannot be used because the platform does not expose an API which may permit access to QBluetoothServer related features.</source>
          <target state="translated">iOS에서는 플랫폼이 QBluetoothServer 관련 기능에 대한 액세스를 허용 할 수있는 API를 노출하지 않기 때문에이 클래스를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1c8f1150b23d26c2ae6a06ccc4d1ec7d1f7e0f49" translate="yes" xml:space="preserve">
          <source>On iOS, this class cannot be used because the platform does not expose an API which may permit access to QBluetoothServiceDiscoveryAgent related features.</source>
          <target state="translated">iOS에서는 플랫폼이 QBluetoothServiceDiscoveryAgent 관련 기능에 대한 액세스를 허용 할 수있는 API를 노출하지 않기 때문에이 클래스를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6fe6ab2479d83c839e03d6132ddf945623a2fbbc" translate="yes" xml:space="preserve">
          <source>On iOS, this class cannot be used because the platform does not expose an API which may permit access to QBluetoothServiceInfo related features.</source>
          <target state="translated">iOS에서는 플랫폼이 QBluetoothServiceInfo 관련 기능에 대한 액세스를 허용 할 수있는 API를 노출하지 않기 때문에이 클래스를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="730877eabbbb911a3cf9a5f5ce25a71c3bc0e03f" translate="yes" xml:space="preserve">
          <source>On iOS, this class cannot be used because the platform does not expose an API which may permit access to QBluetoothSocket related features.</source>
          <target state="translated">On iOS, this class cannot be used because the platform does not expose an API which may permit access to QBluetoothSocket related features.</target>
        </trans-unit>
        <trans-unit id="93397ef8a3c751fea0b8cb626257ac44c252230a" translate="yes" xml:space="preserve">
          <source>On low-end hardware blending can also be quite expensive so for an image or rounded rectangle that covers most of the screen, the amount of blending needed for the interior of these primitives can result in significant performance loss as the entire primitive must be blended.</source>
          <target state="translated">로우 엔드 하드웨어 블렌딩은 상당히 비싸기 때문에 대부분의 화면을 덮는 이미지 또는 둥근 사각형의 경우, 프리미티브의 내부에 필요한 블렌딩 양은 전체 프리미티브를 블렌딩해야하기 때문에 상당한 성능 손실을 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcbcc8f437fddaab4caf419554575d776e143eb9" translate="yes" xml:space="preserve">
          <source>On macOS adds a fullscreen button.</source>
          <target state="translated">On macOS adds a fullscreen button.</target>
        </trans-unit>
        <trans-unit id="440ab2351667eb52cbd7f2f8b6960b091b811079" translate="yes" xml:space="preserve">
          <source>On macOS adds a tool bar button (i.e., the oblong button that is on the top right of windows that have toolbars).</source>
          <target state="translated">On macOS adds a tool bar button (i.e., the oblong button that is on the top right of windows that have toolbars).</target>
        </trans-unit>
        <trans-unit id="bca992f374634884a9a791ea7cb95391cd151ef8" translate="yes" xml:space="preserve">
          <source>On macOS and OpenGL, the threaded render loop is not supported when building with XCode 10 (10.14 SDK) or later, since this opts in to layer-backed views on macOS 10.14. You can build with Xcode 9 (10.13 SDK) to opt out of layer-backing, in which case the threaded render loop is available and used by default. There is no such restriction with Metal.</source>
          <target state="translated">On macOS and OpenGL, the threaded render loop is not supported when building with XCode 10 (10.14 SDK) or later, since this opts in to layer-backed views on macOS 10.14. You can build with Xcode 9 (10.13 SDK) to opt out of layer-backing, in which case the threaded render loop is available and used by default. There is no such restriction with Metal.</target>
        </trans-unit>
        <trans-unit id="7498b95352ca7a31a6760ccfe0fb7b77ca18f27e" translate="yes" xml:space="preserve">
          <source>On macOS and iOS this returns the proper localized name for a bundle if the path &lt;a href=&quot;qfileinfo#isBundle&quot;&gt;isBundle&lt;/a&gt;(). On all other platforms an empty &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; is returned.</source>
          <target state="translated">On macOS and iOS this returns the proper localized name for a bundle if the path &lt;a href=&quot;qfileinfo#isBundle&quot;&gt;isBundle&lt;/a&gt;(). On all other platforms an empty &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; is returned.</target>
        </trans-unit>
        <trans-unit id="ef4d46063b6be6c310ddd36a861cab01a2bf2704" translate="yes" xml:space="preserve">
          <source>On macOS and iOS this will point to the directory actually containing the executable, which may be inside an application bundle (if the application is bundled).</source>
          <target state="translated">On macOS and iOS this will point to the directory actually containing the executable, which may be inside an application bundle (if the application is bundled).</target>
        </trans-unit>
        <trans-unit id="62b17df84aa1fb46462200b50afdb9b1cf5fd2f3" translate="yes" xml:space="preserve">
          <source>On macOS and iOS, &lt;a href=&quot;qsettings#allKeys&quot;&gt;allKeys&lt;/a&gt;() will return some extra keys for global settings that apply to all applications. These keys can be read using &lt;a href=&quot;qsettings#value&quot;&gt;value&lt;/a&gt;() but cannot be changed, only shadowed. Calling &lt;a href=&quot;qsettings#setFallbacksEnabled&quot;&gt;setFallbacksEnabled&lt;/a&gt;(false) will hide these global settings.</source>
          <target state="translated">On macOS and iOS, &lt;a href=&quot;qsettings#allKeys&quot;&gt;allKeys&lt;/a&gt;() will return some extra keys for global settings that apply to all applications. These keys can be read using &lt;a href=&quot;qsettings#value&quot;&gt;value&lt;/a&gt;() but cannot be changed, only shadowed. Calling &lt;a href=&quot;qsettings#setFallbacksEnabled&quot;&gt;setFallbacksEnabled&lt;/a&gt;(false) will hide these global settings.</target>
        </trans-unit>
        <trans-unit id="26497e54bcb16136f9810f304cfbbc4ab21300b5" translate="yes" xml:space="preserve">
          <source>On macOS and iOS, if the file format is &lt;a href=&quot;qsettings#Format-enum&quot;&gt;NativeFormat&lt;/a&gt;, these files are used by default:</source>
          <target state="translated">macOS 및 iOS에서 파일 형식이 &lt;a href=&quot;qsettings#Format-enum&quot;&gt;NativeFormat 인&lt;/a&gt; 경우 다음 파일이 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e3701f1211a6a7633a97ecf459fbc98dbb06b4a2" translate="yes" xml:space="preserve">
          <source>On macOS and iOS, the CFPreferences API used by QSettings expects Internet domain names rather than organization names. To provide a uniform API, QSettings derives a fake domain name from the organization name (unless the organization name already is a domain name, e.g. OpenOffice.org). The algorithm appends &quot;.com&quot; to the company name and replaces spaces and other illegal characters with hyphens. If you want to specify a different domain name, call &lt;a href=&quot;qcoreapplication#organizationDomain-prop&quot;&gt;QCoreApplication::setOrganizationDomain&lt;/a&gt;(), &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;QCoreApplication::setOrganizationName&lt;/a&gt;(), and &lt;a href=&quot;qcoreapplication#applicationName-prop&quot;&gt;QCoreApplication::setApplicationName&lt;/a&gt;() in your &lt;code&gt;main()&lt;/code&gt; function and then use the default QSettings constructor. Another solution is to use preprocessor directives, for example:</source>
          <target state="translated">On macOS and iOS, the CFPreferences API used by QSettings expects Internet domain names rather than organization names. To provide a uniform API, QSettings derives a fake domain name from the organization name (unless the organization name already is a domain name, e.g. OpenOffice.org). The algorithm appends &quot;.com&quot; to the company name and replaces spaces and other illegal characters with hyphens. If you want to specify a different domain name, call &lt;a href=&quot;qcoreapplication#organizationDomain-prop&quot;&gt;QCoreApplication::setOrganizationDomain&lt;/a&gt;(), &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;QCoreApplication::setOrganizationName&lt;/a&gt;(), and &lt;a href=&quot;qcoreapplication#applicationName-prop&quot;&gt;QCoreApplication::setApplicationName&lt;/a&gt;() in your &lt;code&gt;main()&lt;/code&gt; function and then use the default QSettings constructor. Another solution is to use preprocessor directives, for example:</target>
        </trans-unit>
        <trans-unit id="5cbf60e7cb3a071ef2a4c2cb97a9e22ae75321c6" translate="yes" xml:space="preserve">
          <source>On macOS and iOS, you can access property list &lt;code&gt;.plist&lt;/code&gt; files by passing &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings::NativeFormat&lt;/a&gt; as second argument. For example:</source>
          <target state="translated">On macOS and iOS, you can access property list &lt;code&gt;.plist&lt;/code&gt; files by passing &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings::NativeFormat&lt;/a&gt; as second argument. For example:</target>
        </trans-unit>
        <trans-unit id="823a2e63d367f147b03859214c869c5aae823fff" translate="yes" xml:space="preserve">
          <source>On macOS and on certain Linux desktop environments such as Ubuntu Unity, QMenuBar is a wrapper for using the system-wide menu bar. If you have multiple menu bars in one dialog the outermost menu bar (normally inside a widget with widget flag &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Window&lt;/a&gt;) will be used for the system-wide menu bar.</source>
          <target state="translated">On macOS and on certain Linux desktop environments such as Ubuntu Unity, QMenuBar is a wrapper for using the system-wide menu bar. If you have multiple menu bars in one dialog the outermost menu bar (normally inside a widget with widget flag &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Window&lt;/a&gt;) will be used for the system-wide menu bar.</target>
        </trans-unit>
        <trans-unit id="98f769c7de277cebcfd228fff50e2e6262f05264" translate="yes" xml:space="preserve">
          <source>On macOS and with Qt version 4.3 or higher, clipboard changes made by other applications will only be detected when the application is activated.</source>
          <target state="translated">On macOS and with Qt version 4.3 or higher, clipboard changes made by other applications will only be detected when the application is activated.</target>
        </trans-unit>
        <trans-unit id="70aa0c8eb12a9169d3522c43975ea3b3beeaa9ae" translate="yes" xml:space="preserve">
          <source>On macOS by default, Qt swaps the Control and Meta (Command) keys (i.e., whenever Control is pressed, Qt sends Meta, and whenever Meta is pressed Control is sent). When this attribute is true, Qt will not do the flip. &lt;a href=&quot;qkeysequence#StandardKey-enum&quot;&gt;QKeySequence::StandardKey&lt;/a&gt; will also flip accordingly (i.e., &lt;a href=&quot;qkeysequence#StandardKey-enum&quot;&gt;QKeySequence::Copy&lt;/a&gt; will be Command+C on the keyboard regardless of the value set, though what is output for &lt;a href=&quot;qkeysequence#toString&quot;&gt;QKeySequence::toString&lt;/a&gt;() will be different).</source>
          <target state="translated">On macOS by default, Qt swaps the Control and Meta (Command) keys (i.e., whenever Control is pressed, Qt sends Meta, and whenever Meta is pressed Control is sent). When this attribute is true, Qt will not do the flip. &lt;a href=&quot;qkeysequence#StandardKey-enum&quot;&gt;QKeySequence::StandardKey&lt;/a&gt; will also flip accordingly (i.e., &lt;a href=&quot;qkeysequence#StandardKey-enum&quot;&gt;QKeySequence::Copy&lt;/a&gt; will be Command+C on the keyboard regardless of the value set, though what is output for &lt;a href=&quot;qkeysequence#toString&quot;&gt;QKeySequence::toString&lt;/a&gt;() will be different).</target>
        </trans-unit>
        <trans-unit id="9d363e303f21137ed09aa1a90c2e5c8497ec7053" translate="yes" xml:space="preserve">
          <source>On macOS only, if there is exactly one button with the role &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;QMessageBox::RejectRole&lt;/a&gt;, it is made the escape button.</source>
          <target state="translated">On macOS only, if there is exactly one button with the role &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;QMessageBox::RejectRole&lt;/a&gt;, it is made the escape button.</target>
        </trans-unit>
        <trans-unit id="9cc5a64a41d143a71b708828f166640f298e4e58" translate="yes" xml:space="preserve">
          <source>On macOS versions 10.2 and 10.3, these files are used by default:</source>
          <target state="translated">On macOS versions 10.2 and 10.3, these files are used by default:</target>
        </trans-unit>
        <trans-unit id="a4b0ddc5f8caf0143fe7f1949a6c495a9ce41f03" translate="yes" xml:space="preserve">
          <source>On macOS,</source>
          <target state="translated">On macOS,</target>
        </trans-unit>
        <trans-unit id="6b99e17b8feabbc4ed47b9d0de5cbf53dcd97c20" translate="yes" xml:space="preserve">
          <source>On macOS, data goes to &lt;code&gt;~/.qttest/Application Support&lt;/code&gt;, cache goes to &lt;code&gt;~/.qttest/Cache&lt;/code&gt;, and config goes to &lt;code&gt;~/.qttest/Preferences&lt;/code&gt;.</source>
          <target state="translated">On macOS, data goes to &lt;code&gt;~/.qttest/Application Support&lt;/code&gt; , cache goes to &lt;code&gt;~/.qttest/Cache&lt;/code&gt; , and config goes to &lt;code&gt;~/.qttest/Preferences&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ede5b19eb45167aba6f2eae937d4a83a99805ddf" translate="yes" xml:space="preserve">
          <source>On macOS, depending on how Qt WebEngine is configured at build time, there are two possibilities how spellchecking data is found:</source>
          <target state="translated">On macOS, depending on how Qt WebEngine is configured at build time, there are two possibilities how spellchecking data is found:</target>
        </trans-unit>
        <trans-unit id="2f91c884323ac48e7b6f31aa34875c843a3969b0" translate="yes" xml:space="preserve">
          <source>On macOS, high-DPI support is enabled by settings in the &lt;code&gt;Info.plist&lt;/code&gt; file; so make sure these settings are present.</source>
          <target state="translated">On macOS, high-DPI support is enabled by settings in the &lt;code&gt;Info.plist&lt;/code&gt; file; so make sure these settings are present.</target>
        </trans-unit>
        <trans-unit id="6866ec1798179600ee15bdcd1a3ebbc8db99d69c" translate="yes" xml:space="preserve">
          <source>On macOS, if</source>
          <target state="translated">On macOS, if</target>
        </trans-unit>
        <trans-unit id="1924443f95ec76a8193448334d16f49714084a81" translate="yes" xml:space="preserve">
          <source>On macOS, if the default &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; is set after the application instance, the application will exit with &lt;a href=&quot;qtglobal#qFatal&quot;&gt;qFatal&lt;/a&gt;(), and print a message that the default &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; should be set before the application instance.</source>
          <target state="translated">On macOS, if the default &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; is set after the application instance, the application will exit with &lt;a href=&quot;qtglobal#qFatal&quot;&gt;qFatal&lt;/a&gt;(), and print a message that the default &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; should be set before the application instance.</target>
        </trans-unit>
        <trans-unit id="278c39af648e85224b62270b10beb3c6de11b889" translate="yes" xml:space="preserve">
          <source>On macOS, if the modality is set to &lt;a href=&quot;qt#WindowModality-enum&quot;&gt;Qt::WindowModal&lt;/a&gt; and the message box has a parent, then the message box will be a &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Sheet&lt;/a&gt;, otherwise the message box will be a standard dialog.</source>
          <target state="translated">On macOS, if the modality is set to &lt;a href=&quot;qt#WindowModality-enum&quot;&gt;Qt::WindowModal&lt;/a&gt; and the message box has a parent, then the message box will be a &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Sheet&lt;/a&gt;, otherwise the message box will be a standard dialog.</target>
        </trans-unit>
        <trans-unit id="61eea0801d6c0f4969a258bbecfac2958f9905ac" translate="yes" xml:space="preserve">
          <source>On macOS, if you want your message box to appear as a &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Sheet&lt;/a&gt; of its</source>
          <target state="translated">On macOS, if you want your message box to appear as a &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Sheet&lt;/a&gt; of its</target>
        </trans-unit>
        <trans-unit id="7c32941a7cabbdb5a0698343955601248c1e3c71" translate="yes" xml:space="preserve">
          <source>On macOS, it is not possible to unpair a device. If Unpaired is requested, &lt;a href=&quot;qbluetoothlocaldevice#pairingFinished&quot;&gt;pairingFinished&lt;/a&gt;() is immediately emitted although the device remains paired. It is possible to request the pairing for a previously unpaired device. In addition &lt;a href=&quot;qbluetoothlocaldevice#Pairing-enum&quot;&gt;AuthorizedPaired&lt;/a&gt; has the same behavior as &lt;a href=&quot;qbluetoothlocaldevice#Pairing-enum&quot;&gt;Paired&lt;/a&gt;.</source>
          <target state="translated">On macOS, it is not possible to unpair a device. If Unpaired is requested, &lt;a href=&quot;qbluetoothlocaldevice#pairingFinished&quot;&gt;pairingFinished&lt;/a&gt;() is immediately emitted although the device remains paired. It is possible to request the pairing for a previously unpaired device. In addition &lt;a href=&quot;qbluetoothlocaldevice#Pairing-enum&quot;&gt;AuthorizedPaired&lt;/a&gt; has the same behavior as &lt;a href=&quot;qbluetoothlocaldevice#Pairing-enum&quot;&gt;Paired&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7792428425fa305646808531e587749308caf835" translate="yes" xml:space="preserve">
          <source>On macOS, permissions to access settings not belonging to the current user (i.e. &lt;a href=&quot;qsettings#Scope-enum&quot;&gt;SystemScope&lt;/a&gt;) have changed with 10.7 (Lion). Prior to that version, users having admin rights could access these. For 10.7 and 10.8 (Mountain Lion), only root can. However, 10.9 (Mavericks) changes that rule again but only for the native format (plist files).</source>
          <target state="translated">On macOS, permissions to access settings not belonging to the current user (i.e. &lt;a href=&quot;qsettings#Scope-enum&quot;&gt;SystemScope&lt;/a&gt;) have changed with 10.7 (Lion). Prior to that version, users having admin rights could access these. For 10.7 and 10.8 (Mountain Lion), only root can. However, 10.9 (Mavericks) changes that rule again but only for the native format (plist files).</target>
        </trans-unit>
        <trans-unit id="4b85617303975b62b4fda0fc04063ed913dadf60" translate="yes" xml:space="preserve">
          <source>On macOS, security flags are not supported and will be ignored.</source>
          <target state="translated">On macOS, security flags are not supported and will be ignored.</target>
        </trans-unit>
        <trans-unit id="6e4fb0779f376d9b7f13cc101dbc56945ce8a0c8" translate="yes" xml:space="preserve">
          <source>On macOS, show the tool window even when the application is not active. By default, all tool windows are hidden when the application is inactive.</source>
          <target state="translated">On macOS, show the tool window even when the application is not active. By default, all tool windows are hidden when the application is inactive.</target>
        </trans-unit>
        <trans-unit id="2fc773e8e5574c0b087f4006cf6520e5ea3ae6b7" translate="yes" xml:space="preserve">
          <source>On macOS, the Up/Down key bindings for Home/End are explicitly disabled. If you want such bindings (on any platform), you will need to construct them in QML.</source>
          <target state="translated">On macOS, the Up/Down key bindings for Home/End are explicitly disabled. If you want such bindings (on any platform), you will need to construct them in QML.</target>
        </trans-unit>
        <trans-unit id="3035c75001d22474cc4c391892aa6a68624f41e7" translate="yes" xml:space="preserve">
          <source>On macOS, the about box is popped up as a modeless window; on other platforms, it is currently application modal.</source>
          <target state="translated">On macOS, the about box is popped up as a modeless window; on other platforms, it is currently application modal.</target>
        </trans-unit>
        <trans-unit id="6ecd45d0dac95698ed49572895a4b0d52f4bf26e" translate="yes" xml:space="preserve">
          <source>On macOS, the following are required:</source>
          <target state="translated">On macOS, the following are required:</target>
        </trans-unit>
        <trans-unit id="0b1d13fa7b490c6c0a0822b9a6ac39354b8a6525" translate="yes" xml:space="preserve">
          <source>On macOS, the following languages are also supported:</source>
          <target state="translated">macOS에서는 다음 언어도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="133fca1b86b107774dcbcfcc6c24ec3c99ee26a9" translate="yes" xml:space="preserve">
          <source>On macOS, the string returned resembles the sequence that is shown in the menu bar if</source>
          <target state="translated">On macOS, the string returned resembles the sequence that is shown in the menu bar if</target>
        </trans-unit>
        <trans-unit id="b8ab55f5144c99d488618e9a05f53c154c698f77" translate="yes" xml:space="preserve">
          <source>On macOS, there is a difference between a window and view; normally expressed as widgets in Qt. Qt makes assumptions about its parent-child hierarchy that make it complex to put an arbitrary Qt widget into a hierarchy of &quot;normal&quot; views from Apple frameworks. QMacNativeWidget bridges the gap between views and windows and makes it possible to put a hierarchy of Qt widgets into a non-Qt window or view.</source>
          <target state="translated">On macOS, there is a difference between a window and view; normally expressed as widgets in Qt. Qt makes assumptions about its parent-child hierarchy that make it complex to put an arbitrary Qt widget into a hierarchy of &quot;normal&quot; views from Apple frameworks. QMacNativeWidget bridges the gap between views and windows and makes it possible to put a hierarchy of Qt widgets into a non-Qt window or view.</target>
        </trans-unit>
        <trans-unit id="926491bb7182cd1e18a7e7dd02f638a6ad20ccc5" translate="yes" xml:space="preserve">
          <source>On macOS, this corresponds to the Command keys.</source>
          <target state="translated">On macOS, this corresponds to the Command keys.</target>
        </trans-unit>
        <trans-unit id="997b0636751a770507100441ec0546ac9baa3138" translate="yes" xml:space="preserve">
          <source>On macOS, this corresponds to the Control keys. On Windows keyboards, this key is mapped to the Windows key.</source>
          <target state="translated">On macOS, this corresponds to the Control keys. On Windows keyboards, this key is mapped to the Windows key.</target>
        </trans-unit>
        <trans-unit id="c319afe08eb298a3bddc7108164e851bfabf67da" translate="yes" xml:space="preserve">
          <source>On macOS, this flag is always set to &lt;a href=&quot;qbluetooth#Security-enum&quot;&gt;QBluetooth::Secure&lt;/a&gt;.</source>
          <target state="translated">On macOS, this flag is always set to &lt;a href=&quot;qbluetooth#Security-enum&quot;&gt;QBluetooth::Secure&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="400e5a23077bc9037ba3e0e7dce13ac405addf7f" translate="yes" xml:space="preserve">
          <source>On macOS, this function will ignore the Proxy Auto Configuration settings, since it cannot execute the associated ECMAScript code.</source>
          <target state="translated">On macOS, this function will ignore the Proxy Auto Configuration settings, since it cannot execute the associated ECMAScript code.</target>
        </trans-unit>
        <trans-unit id="7d57f8b6fda83cdd1c380230b694702be6fb291b" translate="yes" xml:space="preserve">
          <source>On macOS, this function will obtain the proxy settings using the SystemConfiguration framework from Apple. It will apply the FTP, HTTP and HTTPS proxy configurations for queries that contain the protocol tag &quot;ftp&quot;, &quot;http&quot; and &quot;https&quot;, respectively. If the SOCKS proxy is enabled in that configuration, this function will use the SOCKS server for all queries. If SOCKS isn't enabled, it will use the HTTPS proxy for all TcpSocket and UrlRequest queries.</source>
          <target state="translated">On macOS, this function will obtain the proxy settings using the SystemConfiguration framework from Apple. It will apply the FTP, HTTP and HTTPS proxy configurations for queries that contain the protocol tag &quot;ftp&quot;, &quot;http&quot; and &quot;https&quot;, respectively. If the SOCKS proxy is enabled in that configuration, this function will use the SOCKS server for all queries. If SOCKS isn't enabled, it will use the HTTPS proxy for all TcpSocket and UrlRequest queries.</target>
        </trans-unit>
        <trans-unit id="1a8387b7bb736c1850bba3803e693bbaaa0bfe00" translate="yes" xml:space="preserve">
          <source>On macOS, this is currenly converted to a NSMenu, so the aboutToHide() signal is not emitted.</source>
          <target state="translated">On macOS, this is currenly converted to a NSMenu, so the aboutToHide() signal is not emitted.</target>
        </trans-unit>
        <trans-unit id="9a5716a29b03574dcbe1252ce5b07030d6c53a8f" translate="yes" xml:space="preserve">
          <source>On macOS, this value is ignored as the platform does not permit access to the security parameter of the socket. By default the platform prefers secure/encrypted connections though and therefore this function always returns &lt;a href=&quot;qbluetooth#Security-enum&quot;&gt;QBluetooth::Secure&lt;/a&gt;.</source>
          <target state="translated">On macOS, this value is ignored as the platform does not permit access to the security parameter of the socket. By default the platform prefers secure/encrypted connections though and therefore this function always returns &lt;a href=&quot;qbluetooth#Security-enum&quot;&gt;QBluetooth::Secure&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="21d4fcccb2eef200ead810289a5bf14579776bb2" translate="yes" xml:space="preserve">
          <source>On macOS, this works more at the application level and will cause the application icon to bounce in the dock.</source>
          <target state="translated">On macOS, this works more at the application level and will cause the application icon to bounce in the dock.</target>
        </trans-unit>
        <trans-unit id="d9d89f596ef21e450a1b17ee5e08b21f7658d15b" translate="yes" xml:space="preserve">
          <source>On macOS, you can also use Homebrew's &lt;a href=&quot;https://formulae.brew.sh/formula/llvm&quot;&gt;llvm formula&lt;/a&gt;.</source>
          <target state="translated">macOS에서는 Homebrew의 &lt;a href=&quot;https://formulae.brew.sh/formula/llvm&quot;&gt;llvm 공식을&lt;/a&gt; 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dbc9a30a4a874e65b3735c5d3cd575c785428521" translate="yes" xml:space="preserve">
          <source>On macOS/iOS/tvOS CoreBluetooth does not expose/accept hardware addresses for LE devices; instead developers are supposed to use unique 128-bit UUIDs, generated by CoreBluetooth. These UUIDS will stay constant for the same central &amp;lt;-&amp;gt; peripheral pair and we use them when connecting to a remote device. For a controller in the &lt;a href=&quot;qlowenergycontroller#Role-enum&quot;&gt;CentralRole&lt;/a&gt;, this value will always be the one passed in when the controller object was created. For a controller in the &lt;a href=&quot;qlowenergycontroller#Role-enum&quot;&gt;PeripheralRole&lt;/a&gt;, this value is invalid.</source>
          <target state="translated">On macOS/iOS/tvOS CoreBluetooth does not expose/accept hardware addresses for LE devices; instead developers are supposed to use unique 128-bit UUIDs, generated by CoreBluetooth. These UUIDS will stay constant for the same central &amp;lt;-&amp;gt; peripheral pair and we use them when connecting to a remote device. For a controller in the &lt;a href=&quot;qlowenergycontroller#Role-enum&quot;&gt;CentralRole&lt;/a&gt;, this value will always be the one passed in when the controller object was created. For a controller in the &lt;a href=&quot;qlowenergycontroller#Role-enum&quot;&gt;PeripheralRole&lt;/a&gt;, this value is invalid.</target>
        </trans-unit>
        <trans-unit id="05fa8d4a31ff2dd443da846d8cd791198ad32ce6" translate="yes" xml:space="preserve">
          <source>On macOS:</source>
          <target state="translated">macOS에서 :</target>
        </trans-unit>
        <trans-unit id="111aed6ab634b5c659cced0c05d60a0030105831" translate="yes" xml:space="preserve">
          <source>On macOs, Qt will create a menu item &lt;code&gt;Quit&lt;/code&gt; if there is no menu item whose text is &quot;quit&quot; or &quot;exit&quot;. This menu item calls the &lt;code&gt;QCoreApplication::quit&lt;/code&gt; signal, not the &lt;code&gt;QQuickWindow::closing()&lt;/code&gt; signal.</source>
          <target state="translated">On macOs, Qt will create a menu item &lt;code&gt;Quit&lt;/code&gt; if there is no menu item whose text is &quot;quit&quot; or &quot;exit&quot;. This menu item calls the &lt;code&gt;QCoreApplication::quit&lt;/code&gt; signal, not the &lt;code&gt;QQuickWindow::closing()&lt;/code&gt; signal.</target>
        </trans-unit>
        <trans-unit id="8a0410214f377ebe2837d431e983e7ed11b07c0e" translate="yes" xml:space="preserve">
          <source>On many configurations, the scene graph rendering will happen on a dedicated render thread. This is done to increase parallelism of multi-core processors and make better use of stall times such as waiting for a blocking swap buffer call. This offers significant performance improvements, but imposes certain restrictions on where and when interaction with the scene graph can happen.</source>
          <target state="translated">많은 구성에서 장면 그래프 렌더링은 전용 렌더링 스레드에서 발생합니다. 이는 멀티 코어 프로세서의 병렬성을 높이고 차단 스왑 버퍼 호출 대기와 같은 스톨 시간을 더 잘 활용하기 위해 수행됩니다. 이를 통해 성능이 크게 향상되지만 장면 그래프와 상호 작용할 수있는 위치와시기에 특정 제한이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c4bb4017320968dc14a101cf9ab007de6abbaffa" translate="yes" xml:space="preserve">
          <source>On many platforms, the &lt;a href=&quot;https://doc.qt.io/qt-5.13/topics-graphics.html#qt-quick-scene-graph&quot;&gt;scene graph&lt;/a&gt; will even be rendered on a dedicated render thread while the GUI thread is preparing the next frame's state.</source>
          <target state="translated">많은 플랫폼 에서 GUI 스레드가 다음 프레임의 상태를 준비하는 동안 &lt;a href=&quot;https://doc.qt.io/qt-5.13/topics-graphics.html#qt-quick-scene-graph&quot;&gt;장면 그래프&lt;/a&gt; 는 전용 렌더링 스레드에서 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="28c4753aa92097c0e9edbff76015da06419266fc" translate="yes" xml:space="preserve">
          <source>On many platforms, the &lt;a href=&quot;https://doc.qt.io/qt-5.15/topics-graphics.html#qt-quick-scene-graph&quot;&gt;scene graph&lt;/a&gt; will even be rendered on a dedicated render thread while the GUI thread is preparing the next frame's state.</source>
          <target state="translated">On many platforms, the &lt;a href=&quot;https://doc.qt.io/qt-5.15/topics-graphics.html#qt-quick-scene-graph&quot;&gt;scene graph&lt;/a&gt; will even be rendered on a dedicated render thread while the GUI thread is preparing the next frame's state.</target>
        </trans-unit>
        <trans-unit id="1f2294b173fa00f42e1dc8880ac84178d20f0a23" translate="yes" xml:space="preserve">
          <source>On mobile platforms, switches are commonly used to enable or disable features.</source>
          <target state="translated">모바일 플랫폼에서 스위치는 일반적으로 기능을 활성화 또는 비활성화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a5a9de5d6cdeb88a2c4ac6389030bc54e56f99e" translate="yes" xml:space="preserve">
          <source>On models that support this, inserts</source>
          <target state="translated">이를 지원하는 모델에서는</target>
        </trans-unit>
        <trans-unit id="41592e465ed21517e25d1b60b76d4898a3a7a988" translate="yes" xml:space="preserve">
          <source>On models that support this, moves</source>
          <target state="translated">이를 지원하는 모델에서는</target>
        </trans-unit>
        <trans-unit id="ade874bfdcf68f6016f74be542e10e3dda132736" translate="yes" xml:space="preserve">
          <source>On models that support this, removes</source>
          <target state="translated">이를 지원하는 모델에서 제거</target>
        </trans-unit>
        <trans-unit id="fd0206cd94aa8cab3850091bd8cf6f5f8adff5cd" translate="yes" xml:space="preserve">
          <source>On modern Unix systems, this means &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; usually has accurate information about historical transitions (including DST, see below) whenever possible. On Windows, where the system doesn't support historical timezone data, historical accuracy is not maintained with respect to timezone transitions, notably including DST.</source>
          <target state="translated">현대 유닉스 시스템에서 이것은 &lt;a href=&quot;qdatetime&quot;&gt;QDateTime이&lt;/a&gt; 일반적으로 가능할 때마다 역사적 전환 (DST 포함, 아래 참조)에 대한 정확한 정보를 가지고 있음을 의미 합니다. 시스템이 과거 시간대 데이터를 지원하지 않는 Windows에서는 특히 DST를 포함하여 시간대 전환과 관련하여 과거 정확도가 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bfd4729f2dce093f436ccddf7409f403a119be3a" translate="yes" xml:space="preserve">
          <source>On modern Unix systems, this means QDateTime usually has accurate information about historical transitions (including DST, see below) whenever possible. On Windows, where the system doesn't support historical timezone data, historical accuracy is not maintained with respect to timezone transitions, notably including DST.</source>
          <target state="translated">On modern Unix systems, this means QDateTime usually has accurate information about historical transitions (including DST, see below) whenever possible. On Windows, where the system doesn't support historical timezone data, historical accuracy is not maintained with respect to timezone transitions, notably including DST.</target>
        </trans-unit>
        <trans-unit id="c5c6c7e7a600194ac0290642a7c35ead0986ada6" translate="yes" xml:space="preserve">
          <source>On most file systems, rename() fails only if</source>
          <target state="translated">대부분의 파일 시스템에서 rename ()은 다음과 같은 경우에만 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c4a5b2acc8daf9bc161e1ce2107416cbb5562ac6" translate="yes" xml:space="preserve">
          <source>On most operating systems the system path is determined by the &lt;code&gt;PATH&lt;/code&gt; environment variable. The directories where to search for the executable can be set in the paths argument. To search in both your own paths and the system paths, call findExecutable twice, once with paths set and once with paths empty. Symlinks are not resolved in order to preserve behavior for the case of executables whose behavior depends on the name they are invoked with .</source>
          <target state="translated">On most operating systems the system path is determined by the &lt;code&gt;PATH&lt;/code&gt; environment variable. The directories where to search for the executable can be set in the paths argument. To search in both your own paths and the system paths, call findExecutable twice, once with paths set and once with paths empty. Symlinks are not resolved in order to preserve behavior for the case of executables whose behavior depends on the name they are invoked with .</target>
        </trans-unit>
        <trans-unit id="c4189cdb33281e6173c000846c64209d4eb96979" translate="yes" xml:space="preserve">
          <source>On most operating systems the system path is determined by the PATH environment variable.</source>
          <target state="translated">대부분의 운영 체제에서 시스템 경로는 PATH 환경 변수에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="9e599cf93a104519a9331e2aca4dc391624e212f" translate="yes" xml:space="preserve">
          <source>On most platforms, the rendering will occur on a &lt;a href=&quot;qtquick-visualcanvas-scenegraph#scene-graph-and-rendering&quot;&gt;dedicated thread&lt;/a&gt;. For this reason, the &lt;a href=&quot;qquickframebufferobject&quot;&gt;QQuickFramebufferObject&lt;/a&gt; class enforces a strict separation between the item implementation and the FBO rendering. All item logic, such as properties and UI-related helper functions needed by QML should be located in a &lt;a href=&quot;qquickframebufferobject&quot;&gt;QQuickFramebufferObject&lt;/a&gt; class subclass. Everything that relates to rendering must be located in the &lt;a href=&quot;qquickframebufferobject-renderer&quot;&gt;QQuickFramebufferObject::Renderer&lt;/a&gt; class.</source>
          <target state="translated">대부분의 플랫폼에서 렌더링은 &lt;a href=&quot;qtquick-visualcanvas-scenegraph#scene-graph-and-rendering&quot;&gt;전용 스레드&lt;/a&gt; 에서 발생 합니다 . 이러한 이유로 &lt;a href=&quot;qquickframebufferobject&quot;&gt;QQuickFramebufferObject&lt;/a&gt; 클래스는 항목 구현과 FBO 렌더링을 엄격하게 분리합니다. QML에 필요한 속성 및 UI 관련 도우미 함수와 같은 모든 항목 논리는 &lt;a href=&quot;qquickframebufferobject&quot;&gt;QQuickFramebufferObject&lt;/a&gt; 클래스 서브 클래스 에 있어야합니다 . 렌더링과 관련된 모든 것은 &lt;a href=&quot;qquickframebufferobject-renderer&quot;&gt;QQuickFramebufferObject :: Renderer&lt;/a&gt; 클래스 에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f78d8681a24f3c55f8218f80b46395c1e46f5de2" translate="yes" xml:space="preserve">
          <source>On most platforms, the rendering will occur on a &lt;a href=&quot;qtquick-visualcanvas-scenegraph#scene-graph-and-rendering&quot;&gt;dedicated thread&lt;/a&gt;. For this reason, the QQuickFramebufferObject class enforces a strict separation between the item implementation and the FBO rendering. All item logic, such as properties and UI-related helper functions needed by QML should be located in a QQuickFramebufferObject class subclass. Everything that relates to rendering must be located in the &lt;a href=&quot;qquickframebufferobject-renderer&quot;&gt;QQuickFramebufferObject::Renderer&lt;/a&gt; class.</source>
          <target state="translated">On most platforms, the rendering will occur on a &lt;a href=&quot;qtquick-visualcanvas-scenegraph#scene-graph-and-rendering&quot;&gt;dedicated thread&lt;/a&gt;. For this reason, the QQuickFramebufferObject class enforces a strict separation between the item implementation and the FBO rendering. All item logic, such as properties and UI-related helper functions needed by QML should be located in a QQuickFramebufferObject class subclass. Everything that relates to rendering must be located in the &lt;a href=&quot;qquickframebufferobject-renderer&quot;&gt;QQuickFramebufferObject::Renderer&lt;/a&gt; class.</target>
        </trans-unit>
        <trans-unit id="e56f7e639613b5b65503e1bb78af1b62cc5594cb" translate="yes" xml:space="preserve">
          <source>On most systems this function will return true. However, on X11 systems that do not support CUPS, this function will return false. That means the application has to handle the number of copies by printing the same document the required number of times.</source>
          <target state="translated">대부분의 시스템에서이 기능은 true를 반환합니다. 그러나 CUPS를 지원하지 않는 X11 시스템에서는이 함수가 false를 반환합니다. 즉, 응용 프로그램은 필요한 횟수만큼 동일한 문서를 인쇄하여 인쇄 매수를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f23b1863f40dc4ba0720c4de3e06f71c2964972" translate="yes" xml:space="preserve">
          <source>On most systems, inserting a variable with no contents will have the same effect for applications as if the variable had not been set at all. However, to guarantee that there are no incompatibilities, to remove a variable, please use the &lt;a href=&quot;qprocessenvironment#remove&quot;&gt;remove&lt;/a&gt;() function.</source>
          <target state="translated">대부분의 시스템에서 내용이없는 변수를 삽입하면 변수가 전혀 설정되지 않은 것처럼 응용 프로그램에 동일한 효과가 있습니다. 그러나 비 호환성이 없도록 변수를 제거하려면 &lt;a href=&quot;qprocessenvironment#remove&quot;&gt;remove&lt;/a&gt; () 함수 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="efac2b84fadb23f4a588caa9754c76356866e879" translate="yes" xml:space="preserve">
          <source>On non-Unix systems, &lt;a href=&quot;qdbusunixfiledescriptor&quot;&gt;QDBusUnixFileDescriptor&lt;/a&gt; will always report an invalid state and &lt;a href=&quot;qdbusunixfiledescriptor#isSupported&quot;&gt;QDBusUnixFileDescriptor::isSupported&lt;/a&gt;() will return false.</source>
          <target state="translated">비 유닉스 시스템에서 &lt;a href=&quot;qdbusunixfiledescriptor&quot;&gt;QDBusUnixFileDescriptor&lt;/a&gt; 는 항상 유효하지 않은 상태를보고하며 &lt;a href=&quot;qdbusunixfiledescriptor#isSupported&quot;&gt;QDBusUnixFileDescriptor :: isSupported&lt;/a&gt; ()는 false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7999423d46d3c58e88ef959eaff6e634a4be5b1a" translate="yes" xml:space="preserve">
          <source>On non-Unix systems, QDBusUnixFileDescriptor will always report an invalid state and &lt;a href=&quot;qdbusunixfiledescriptor#isSupported&quot;&gt;QDBusUnixFileDescriptor::isSupported&lt;/a&gt;() will return false.</source>
          <target state="translated">On non-Unix systems, QDBusUnixFileDescriptor will always report an invalid state and &lt;a href=&quot;qdbusunixfiledescriptor#isSupported&quot;&gt;QDBusUnixFileDescriptor::isSupported&lt;/a&gt;() will return false.</target>
        </trans-unit>
        <trans-unit id="e38c3a23dee5fa9311a5107003b6936f0a0d73bb" translate="yes" xml:space="preserve">
          <source>On operating systems where file system is case sensitive, &lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt; also tries to load a lower-cased version of the locale name.</source>
          <target state="translated">파일 시스템이 대소 문자를 구분하는 운영 체제에서 &lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt; 는 로케일 이름의 소문자 버전을로드하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="1aa7f8494db2fc0822ab3e263ae6aa016fb72ef0" translate="yes" xml:space="preserve">
          <source>On operating systems where the system API for passing command line</source>
          <target state="translated">명령 행을 전달하기위한 시스템 API가있는 운영 체제에서</target>
        </trans-unit>
        <trans-unit id="05e5202b8c925c0c913ef79c144980eb361aa914" translate="yes" xml:space="preserve">
          <source>On operating systems where the system API for passing command line arguments to a subprocess natively uses a single string (Windows), one can conceive command lines which cannot be passed via &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt;'s portable list-based API. In these rare cases you need to use &lt;a href=&quot;qprocess#setProgram&quot;&gt;setProgram&lt;/a&gt;() and &lt;a href=&quot;qprocess#setNativeArguments&quot;&gt;setNativeArguments&lt;/a&gt;() instead of this function.</source>
          <target state="translated">서브 프로세스에 명령 행 인수를 전달하기위한 시스템 API가 기본적으로 단일 문자열 (Windows)을 사용하는 운영 체제에서 &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; 의 이식 가능한 목록 기반 API 를 통해 전달할 수없는 명령 행을 생각할 수 있습니다 . 드문 경우이지만 이 함수 대신 &lt;a href=&quot;qprocess#setProgram&quot;&gt;setProgram&lt;/a&gt; () 및 &lt;a href=&quot;qprocess#setNativeArguments&quot;&gt;setNativeArguments&lt;/a&gt; () 를 사용해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="bfe890c63f0bd059f8b1cd81c7d73de11b806d5e" translate="yes" xml:space="preserve">
          <source>On operating systems where the system API for passing command line arguments to a subprocess natively uses a single string (Windows), one can conceive command lines which cannot be passed via &lt;a href=&quot;qtcore-changes-qt6#qprocess&quot;&gt;QProcess&lt;/a&gt;'s portable list-based API. In these rare cases you need to use &lt;a href=&quot;qprocess#setProgram&quot;&gt;setProgram&lt;/a&gt;() and &lt;a href=&quot;qprocess#setNativeArguments&quot;&gt;setNativeArguments&lt;/a&gt;() instead of this function.</source>
          <target state="translated">명령 줄 인수를 하위 프로세스에 전달하기위한 시스템 API가 기본적으로 단일 문자열 (Windows)을 사용하는 운영 체제에서는 &lt;a href=&quot;qtcore-changes-qt6#qprocess&quot;&gt;QProcess&lt;/a&gt; 의 이식 가능한 목록 기반 API 를 통해 전달할 수없는 명령 줄을 생각할 수 있습니다 . 이러한 드문 경우 에이 함수 대신 &lt;a href=&quot;qprocess#setProgram&quot;&gt;setProgram&lt;/a&gt; () 및 &lt;a href=&quot;qprocess#setNativeArguments&quot;&gt;setNativeArguments&lt;/a&gt; () 를 사용해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="28136e7d36f13be0dbb0c61f2f62bad732585c92" translate="yes" xml:space="preserve">
          <source>On or off (only for toggling push buttons).</source>
          <target state="translated">켜짐 또는 꺼짐 (푸시 버튼 토글 전용).</target>
        </trans-unit>
        <trans-unit id="3f1b1f250acb8d5ddcc132e442f60e2cb28137a4" translate="yes" xml:space="preserve">
          <source>On other operating systems, &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; will fall back to a PRNG of good numeric distribution, but it cannot guarantee proper seeding in all cases. Please consult the OS documentation for more information.</source>
          <target state="translated">다른 운영 체제에서 &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; 는 양호한 숫자 분배 PRNG로 대체 되지만 모든 경우에 올바른 시딩을 보장 할 수는 없습니다. 자세한 내용은 OS 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2bbede3df925eda68d8fe819b6b61812a597b64c" translate="yes" xml:space="preserve">
          <source>On other operating systems, QRandomGenerator will fall back to a PRNG of good numeric distribution, but it cannot guarantee proper seeding in all cases. Please consult the OS documentation for more information.</source>
          <target state="translated">On other operating systems, QRandomGenerator will fall back to a PRNG of good numeric distribution, but it cannot guarantee proper seeding in all cases. Please consult the OS documentation for more information.</target>
        </trans-unit>
        <trans-unit id="d15b206f77ee2ee8cfd8115fd9c168f87e0d6541" translate="yes" xml:space="preserve">
          <source>On other platforms than Windows, &quot;Default&quot; and &quot;.&quot; would be treated as regular subkeys.</source>
          <target state="translated">Windows 이외의 다른 플랫폼에서는 &quot;기본&quot;및 &quot;.&quot; 일반 하위 키로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="707eb1c8724241a1e87379d817c5d04fe6cf181a" translate="yes" xml:space="preserve">
          <source>On other platforms, the default is the empty string.</source>
          <target state="translated">다른 플랫폼에서 기본값은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c16c91f3148fe99500ed5d9ed9ec9a9afcaa8921" translate="yes" xml:space="preserve">
          <source>On other systems, this function will pick up proxy settings from the &quot;http_proxy&quot; environment variable. This variable must be a URL using one of the following schemes: &quot;http&quot;, &quot;socks5&quot; or &quot;socks5h&quot;.</source>
          <target state="translated">다른 시스템에서는이 기능이 &quot;http_proxy&quot;환경 변수에서 프록시 설정을 선택합니다. 이 변수는 &quot;http&quot;, &quot;socks5&quot;또는 &quot;socks5h&quot;체계 중 하나를 사용하는 URL이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ffa936f15b2bfcf36e9b62a214708044a04b8087" translate="yes" xml:space="preserve">
          <source>On platforms that do not provide nanosecond resolution, the value returned will be the best estimate available.</source>
          <target state="translated">나노초 해상도를 제공하지 않는 플랫폼에서는 반환되는 값이 사용 가능한 최상의 추정치입니다.</target>
        </trans-unit>
        <trans-unit id="f8e36630f309db9813967e18eaa4f77c0b022776" translate="yes" xml:space="preserve">
          <source>On platforms that do not use dynamic GL switching, the return value is &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">동적 GL 스위칭을 사용하지 않는 플랫폼에서 리턴 값은 &lt;code&gt;nullptr&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="50c4185d33f086855aaf80873eb80641afeea45d" translate="yes" xml:space="preserve">
          <source>On platforms that support it, this method of moving windows is preferred over &lt;code&gt;setPosition&lt;/code&gt;, because it allows a more native look-and-feel of moving windows, e.g. letting the window manager snap this window against other windows, or special tiling or resizing behavior with animations when dragged to the edge of the screen. Furthermore, on some platforms such as Wayland, &lt;code&gt;setPosition&lt;/code&gt; is not supported, so this is the only way the application can influence its position.</source>
          <target state="translated">On platforms that support it, this method of moving windows is preferred over &lt;code&gt;setPosition&lt;/code&gt; , because it allows a more native look-and-feel of moving windows, e.g. letting the window manager snap this window against other windows, or special tiling or resizing behavior with animations when dragged to the edge of the screen. Furthermore, on some platforms such as Wayland, &lt;code&gt;setPosition&lt;/code&gt; is not supported, so this is the only way the application can influence its position.</target>
        </trans-unit>
        <trans-unit id="86d7baaf899c808eb5077ff1f8b8ca1a697d9b5c" translate="yes" xml:space="preserve">
          <source>On platforms that support it, this method of resizing windows is preferred over &lt;code&gt;setGeometry&lt;/code&gt;, because it allows a more native look and feel of resizing windows, e.g. letting the window manager snap this window against other windows, or special resizing behavior with animations when dragged to the edge of the screen.</source>
          <target state="translated">이를 지원하는 플랫폼에서는 창 크기를 조정하는이 방법이 &lt;code&gt;setGeometry&lt;/code&gt; 보다 선호됩니다 . 예를 들어 창 관리자가이 창을 다른 창에 맞출 수 있도록하는 것과 같이 창 관리자가이 창을 다른 창에 맞출 수 있도록하거나, 애니메이션을 사용하여 특정 크기를 조정할 수 있기 때문에 setGeometry 보다 선호 됩니다. 화면 가장자리.</target>
        </trans-unit>
        <trans-unit id="1b3c1056bb54f6c5d06383834d667d7c6194a04d" translate="yes" xml:space="preserve">
          <source>On platforms that support it, this method of resizing windows is preferred over &lt;code&gt;setGeometry&lt;/code&gt;, because it allows a more native look-and-feel of resizing windows, e.g. letting the window manager snap this window against other windows, or special resizing behavior with animations when dragged to the edge of the screen.</source>
          <target state="translated">On platforms that support it, this method of resizing windows is preferred over &lt;code&gt;setGeometry&lt;/code&gt; , because it allows a more native look-and-feel of resizing windows, e.g. letting the window manager snap this window against other windows, or special resizing behavior with animations when dragged to the edge of the screen.</target>
        </trans-unit>
        <trans-unit id="e089be5b188ff534e5a5114f53ca6db3653567b5" translate="yes" xml:space="preserve">
          <source>On platforms where retrieving the native handle is not supported, or if neither &lt;a href=&quot;qopenglcontext#create&quot;&gt;create&lt;/a&gt;() nor &lt;a href=&quot;qopenglcontext#setNativeHandle&quot;&gt;setNativeHandle&lt;/a&gt;() was called, a null variant is returned.</source>
          <target state="translated">원시 핸들 검색이 지원되지 않거나 &lt;a href=&quot;qopenglcontext#create&quot;&gt;create&lt;/a&gt; () 또는 &lt;a href=&quot;qopenglcontext#setNativeHandle&quot;&gt;setNativeHandle&lt;/a&gt; ()이 호출 되지 않은 플랫폼에서는 널 (null) 변형이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="097e335f3aa7896ef14a46c7227eceadb182fa7f" translate="yes" xml:space="preserve">
          <source>On platforms where the OpenGL implementation is not dynamically loaded, the return value is determined during compile time and never changes.</source>
          <target state="translated">OpenGL 구현이 동적으로로드되지 않는 플랫폼에서는 반환 시간이 컴파일 시간 동안 결정되며 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11551870c462ac03be9f07e2e333fda2d6df3f73" translate="yes" xml:space="preserve">
          <source>On platforms where this information is not available, returns the same as &lt;a href=&quot;qfileinfo#lastModified&quot;&gt;lastModified&lt;/a&gt;().</source>
          <target state="translated">이 정보를 사용할 수없는 플랫폼에서는 &lt;a href=&quot;qfileinfo#lastModified&quot;&gt;lastModified&lt;/a&gt; () 와 동일한 정보를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="de86b2310b46ab95d774db26591152dc57268371" translate="yes" xml:space="preserve">
          <source>On press of the &lt;code&gt;[TAB]&lt;/code&gt; key, the item inside the &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; gets focus. If this item can handle &lt;code&gt;[TAB]&lt;/code&gt; key press, focus will change accordingly within the item, otherwise the next widget in the focus chain gets focus.</source>
          <target state="translated">의 키를 누릅니다에 &lt;code&gt;[TAB]&lt;/code&gt; 키를 내부 항목 &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget는&lt;/a&gt; 초점을 가져옵니다. 이 항목이 &lt;code&gt;[TAB]&lt;/code&gt; 키 누름을 처리 할 수 ​​있으면 항목 내에서 초점이 적절하게 변경되고, 그렇지 않으면 초점 체인의 다음 위젯이 초점을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="7c48ef163182db2a7fcae5fdd297decbb9801888" translate="yes" xml:space="preserve">
          <source>On press of the &lt;code&gt;[TAB]&lt;/code&gt; key, the item inside the QQuickWidget gets focus. If this item can handle &lt;code&gt;[TAB]&lt;/code&gt; key press, focus will change accordingly within the item, otherwise the next widget in the focus chain gets focus.</source>
          <target state="translated">On press of the &lt;code&gt;[TAB]&lt;/code&gt; key, the item inside the QQuickWidget gets focus. If this item can handle &lt;code&gt;[TAB]&lt;/code&gt; key press, focus will change accordingly within the item, otherwise the next widget in the focus chain gets focus.</target>
        </trans-unit>
        <trans-unit id="216f293e577fbbb41756144aacb2342b7d858e73" translate="yes" xml:space="preserve">
          <source>On some desktop platforms (including Windows and Unix), the application name (from &lt;a href=&quot;qguiapplication#applicationDisplayName-prop&quot;&gt;QGuiApplication::applicationDisplayName&lt;/a&gt;) is added at the end of the window title, if set. This is done by the QPA plugin, so it is shown to the user, but isn't part of the windowTitle string.</source>
          <target state="translated">일부 데스크탑 플랫폼 (Windows 및 Unix 포함)에서 응용 프로그램 이름 ( &lt;a href=&quot;qguiapplication#applicationDisplayName-prop&quot;&gt;QGuiApplication :: applicationDisplayName&lt;/a&gt; )은 설정된 경우 창 제목 끝에 추가됩니다. 이것은 QPA 플러그인에 의해 수행되므로 사용자에게 표시되지만 windowTitle 문자열의 일부는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="13fac2949d067de8eee19c6e772df44625a7e5d3" translate="yes" xml:space="preserve">
          <source>On some platforms (e.g. X11), the drawConvexPolygon() function can be faster than the &lt;a href=&quot;qpainter#drawPolygon&quot;&gt;drawPolygon&lt;/a&gt;() function.</source>
          <target state="translated">일부 플랫폼 (예 : X11)에서 drawConvexPolygon () 함수는 &lt;a href=&quot;qpainter#drawPolygon&quot;&gt;drawPolygon&lt;/a&gt; () 함수 보다 빠를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34f97bbe7845b46e635a2c35b414f90487ac3ba8" translate="yes" xml:space="preserve">
          <source>On some platforms (for instance, iOS) the default framebuffer object depends on the surface being rendered to, and might be different from 0. Thus, instead of calling glBindFramebuffer(0), you should call glBindFramebuffer(ctx-&amp;gt;defaultFramebufferObject()) if you want your application to work across different Qt platforms.</source>
          <target state="translated">일부 플랫폼 (예 : iOS)에서 기본 프레임 버퍼 객체는 렌더링되는 표면에 따라 다르며 0과 다를 수 있습니다. 따라서 glBindFramebuffer (0)를 호출하는 대신 glBindFramebuffer (ctx-&amp;gt; defaultFramebufferObject ())를 호출해야합니다. 애플리케이션이 다른 Qt 플랫폼에서 작동하게하려면</target>
        </trans-unit>
        <trans-unit id="7b39ff62b0777892f192f7cda66e142a06182e6c" translate="yes" xml:space="preserve">
          <source>On some platforms context loss situations is not something that can avoided. On others however, they may need to be opted-in to. This can be done by enabling &lt;a href=&quot;qsurfaceformat#FormatOption-enum&quot;&gt;ResetNotification&lt;/a&gt; in the &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt;. This will lead to setting &lt;code&gt;RESET_NOTIFICATION_STRATEGY_EXT&lt;/code&gt; to &lt;code&gt;LOSE_CONTEXT_ON_RESET_EXT&lt;/code&gt; in the underlying native OpenGL context. &lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; will then monitor the status via &lt;code&gt;glGetGraphicsResetStatusEXT()&lt;/code&gt; in every &lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent&lt;/a&gt;().</source>
          <target state="translated">일부 플랫폼에서는 컨텍스트 손실 상황을 피할 수 없습니다. 그러나 다른 경우에는 선택해야 할 수도 있습니다. 이것은 가능하게하여 수행 할 수 있습니다 &lt;a href=&quot;qsurfaceformat#FormatOption-enum&quot;&gt;ResetNotification을&lt;/a&gt; 에 &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; . 이렇게하면 기본 기본 OpenGL 컨텍스트에서 &lt;code&gt;RESET_NOTIFICATION_STRATEGY_EXT&lt;/code&gt; 를 &lt;code&gt;LOSE_CONTEXT_ON_RESET_EXT&lt;/code&gt; 로 설정합니다 . 그런 다음 &lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; 는 모든 &lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent&lt;/a&gt; () 에서 &lt;code&gt;glGetGraphicsResetStatusEXT()&lt;/code&gt; 를 통해 상태를 모니터링합니다 .</target>
        </trans-unit>
        <trans-unit id="de6d802b44b245bdb7ef87a8e2ea75a66a8508de" translate="yes" xml:space="preserve">
          <source>On some platforms context loss situations is not something that can avoided. On others however, they may need to be opted-in to. This can be done by enabling &lt;a href=&quot;qsurfaceformat#FormatOption-enum&quot;&gt;ResetNotification&lt;/a&gt; in the &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt;. This will lead to setting &lt;code&gt;RESET_NOTIFICATION_STRATEGY_EXT&lt;/code&gt; to &lt;code&gt;LOSE_CONTEXT_ON_RESET_EXT&lt;/code&gt; in the underlying native OpenGL context. &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; will then monitor the status via &lt;code&gt;glGetGraphicsResetStatusEXT()&lt;/code&gt; in every &lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent&lt;/a&gt;().</source>
          <target state="translated">On some platforms context loss situations is not something that can avoided. On others however, they may need to be opted-in to. This can be done by enabling &lt;a href=&quot;qsurfaceformat#FormatOption-enum&quot;&gt;ResetNotification&lt;/a&gt; in the &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt;. This will lead to setting &lt;code&gt;RESET_NOTIFICATION_STRATEGY_EXT&lt;/code&gt; to &lt;code&gt;LOSE_CONTEXT_ON_RESET_EXT&lt;/code&gt; in the underlying native OpenGL context. &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; will then monitor the status via &lt;code&gt;glGetGraphicsResetStatusEXT()&lt;/code&gt; in every &lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent&lt;/a&gt;().</target>
        </trans-unit>
        <trans-unit id="0cb4e721238ec59021d213a4d04d779ecf98d2b8" translate="yes" xml:space="preserve">
          <source>On some platforms it is a platform requirement that the application open a network session before any network operations can be performed. This can be tested by the presents of the &lt;a href=&quot;qnetworkconfigurationmanager#Capability-enum&quot;&gt;QNetworkConfigurationManager::NetworkSessionRequired&lt;/a&gt; flag in the value returned by the &lt;a href=&quot;qnetworkconfigurationmanager#capabilities&quot;&gt;QNetworkConfigurationManager::capabilities&lt;/a&gt;() function.</source>
          <target state="translated">일부 플랫폼에서는 네트워크 작업을 수행하기 전에 응용 프로그램에서 네트워크 세션을 열어야합니다. 이것은 &lt;a href=&quot;qnetworkconfigurationmanager#capabilities&quot;&gt;QNetworkConfigurationManager :: capabilities&lt;/a&gt; () 함수가 반환 한 값에 &lt;a href=&quot;qnetworkconfigurationmanager#Capability-enum&quot;&gt;QNetworkConfigurationManager :: NetworkSessionRequired&lt;/a&gt; 플래그를 제시하여 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="958c141ccc5a684fa33965a31052364570d61d43" translate="yes" xml:space="preserve">
          <source>On some platforms it is possible to pre-register an application to receive NDEF messages matching a given criteria. This is useful to get the system to automatically launch your application when a matching NDEF message is received. This removes the need to have the user manually launch NDEF handling applications, prior to touching a tag, or to have those applications always running and using system resources.</source>
          <target state="translated">일부 플랫폼에서는 지정된 기준과 일치하는 NDEF 메시지를 수신하도록 애플리케이션을 사전 등록 할 수 있습니다. 일치하는 NDEF 메시지가 수신 될 때 시스템이 자동으로 응용 프로그램을 시작하도록하는 데 유용합니다. 따라서 태그를 만지기 전에 사용자가 NDEF 처리 응용 프로그램을 수동으로 시작하거나 해당 응용 프로그램이 항상 실행되고 시스템 리소스를 사용하도록 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c2a2a1e397e164b7f23274f35cdc6d18e0a707f9" translate="yes" xml:space="preserve">
          <source>On some platforms the native context handle is not sufficient and other related handles (for example, for a window or display) have to be provided in addition. Therefore</source>
          <target state="translated">일부 플랫폼에서는 기본 컨텍스트 핸들이 충분하지 않으며 다른 관련 핸들 (예 : 창 또는 디스플레이)이 추가로 제공되어야합니다. 따라서</target>
        </trans-unit>
        <trans-unit id="20010ff5a4b8e3a16de71feedf70aa68fe2c3db7" translate="yes" xml:space="preserve">
          <source>On some platforms the return value of &lt;code&gt;false&lt;/code&gt; for a context that was successfully created previously indicates that the OpenGL context was lost.</source>
          <target state="translated">일부 플랫폼에서 이전에 성공적으로 작성된 컨텍스트에 대한 리턴 값 &lt;code&gt;false&lt;/code&gt; 는 OpenGL 컨텍스트가 유실되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9c8be1c2d514ab4d9b4b152b27947d9b30037220" translate="yes" xml:space="preserve">
          <source>On some platforms the service discovery might lead to pairing requests. Therefore it is not recommended to do service discoveries on all devices. This function can be used to restrict the service discovery to a particular device.</source>
          <target state="translated">일부 플랫폼에서 서비스 검색으로 인해 요청 요청이 발생할 수 있습니다. 따라서 모든 장치에서 서비스 검색을 수행하지 않는 것이 좋습니다. 이 기능을 사용하여 서비스 검색을 특정 장치로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="684b93ba29be6c4ee11d9560ae8a7c160f610ce5" translate="yes" xml:space="preserve">
          <source>On some platforms the size grip automatically hides itself when the window is shown full screen or maximised.</source>
          <target state="translated">일부 플랫폼에서 창을 전체 화면으로 표시하거나 최대화하면 크기 그립이 자동으로 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="02bee986cbf2492c7d23749e33b81016094ebe37" translate="yes" xml:space="preserve">
          <source>On some platforms, device discovery may lead to pairing requests.</source>
          <target state="translated">일부 플랫폼에서는 장치 검색으로 인해 페어링 요청이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46574dd13730a320c02663d04dec60fd6f1ff980" translate="yes" xml:space="preserve">
          <source>On some platforms, the file name suffix for precompiled header files is the same as that for other object files. For example, the following declarations may cause two different object files with the same name to be generated:</source>
          <target state="translated">일부 플랫폼에서 사전 컴파일 된 헤더 파일의 파일 이름 접미사는 다른 오브젝트 파일의 파일 이름 접미 부와 동일합니다. 예를 들어, 다음 선언으로 인해 동일한 이름을 가진 두 개의 다른 오브젝트 파일이 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b07f91e16f98dc094fe104a3dd260214ab60fd05" translate="yes" xml:space="preserve">
          <source>On some platforms, the frame may be put into a queue and the return value may only indicate a successful insertion into the queue. The actual frame will be send later on. Therefore the &lt;a href=&quot;qcanbusdevice#framesWritten&quot;&gt;framesWritten&lt;/a&gt;() signal is the final confirmation that the frame has been handed off to the transport layer. If an error occurs the &lt;a href=&quot;qcanbusdevice#errorOccurred&quot;&gt;errorOccurred&lt;/a&gt;() is emitted.</source>
          <target state="translated">일부 플랫폼에서는 프레임이 대기열에 배치 될 수 있으며 반환 값은 대기열에 성공적으로 삽입되었음을 나타냅니다. 실제 프레임은 나중에 전송됩니다. 따라서 &lt;a href=&quot;qcanbusdevice#framesWritten&quot;&gt;framesWritten&lt;/a&gt; () 신호는 프레임이 전송 계층으로 전달되었음을 최종 확인합니다. 오류가 발생하면 &lt;a href=&quot;qcanbusdevice#errorOccurred&quot;&gt;errorOccurred&lt;/a&gt; ()가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b14591797de380c2198aeb57dc2186da2a5f17cc" translate="yes" xml:space="preserve">
          <source>On some platforms, the symbols required by</source>
          <target state="translated">일부 플랫폼에서 필요한 기호</target>
        </trans-unit>
        <trans-unit id="e492c97f7f48a3b1d74e81536ecae5753a49beaf" translate="yes" xml:space="preserve">
          <source>On some systems it is possible for there to be available printers but none of them set to be the default printer.</source>
          <target state="translated">일부 시스템에서는 사용 가능한 프린터가있을 수 있지만 기본 프린터로 설정된 프린터는 없습니다.</target>
        </trans-unit>
        <trans-unit id="87e8d766af5194858d7c9f0eb0881452ec8c871f" translate="yes" xml:space="preserve">
          <source>On some systems it may become necessary to target a specific overlay plane through a pre-defined connector. Just forcing a layer index via &lt;code&gt;QT_QPA_EGLFS_LAYER_INDEX&lt;/code&gt; does not perform plane configuration and is therefore not suitable in itself. Instead, in such special scenarios use the &lt;code&gt;QT_QPA_EGLFS_KMS_CONNECTOR_INDEX&lt;/code&gt; and &lt;code&gt;QT_QPA_EGLFS_KMS_PLANE_INDEX&lt;/code&gt; environment variables. When these are set, only the specified connector and plane will be in use, all other outputs will get ignored. The backend will take care of picking the EGL layer that corresponds to the desired plane, and the configuring of the plane.</source>
          <target state="translated">일부 시스템에서는 사전 정의 된 커넥터를 통해 특정 오버레이 평면을 대상으로해야 할 수도 있습니다. &lt;code&gt;QT_QPA_EGLFS_LAYER_INDEX&lt;/code&gt; 를 통해 레이어 인덱스를 강제 실행하면 평면 구성이 수행되지 않으므로 자체적으로 적합하지 않습니다. 대신, 이러한 특수 시나리오에서 &lt;code&gt;QT_QPA_EGLFS_KMS_CONNECTOR_INDEX&lt;/code&gt; 및 &lt;code&gt;QT_QPA_EGLFS_KMS_PLANE_INDEX&lt;/code&gt; 환경 변수를 사용하십시오 . 이들을 설정하면 지정된 커넥터와 평면 만 사용되며 다른 모든 출력은 무시됩니다. 백엔드는 원하는 평면에 해당하는 EGL 계층을 선택하고 평면을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="283b10be9f34b91b6891d6c6ccb6950c21d9f437" translate="yes" xml:space="preserve">
          <source>On some systems, &lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface&lt;/a&gt; will need to heuristically determine which addresses are eligible.</source>
          <target state="translated">일부 시스템에서 &lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface&lt;/a&gt; 는 적격 인 주소를 경험적으로 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0dee526eee6dcf66479929545416072bde171509" translate="yes" xml:space="preserve">
          <source>On some systems, if &lt;a href=&quot;qtemporaryfile#fileName&quot;&gt;fileName&lt;/a&gt;() is not called before closing the file, the temporary file may be removed regardless of the state of this property. This behavior should not be relied upon, so application code should either call &lt;a href=&quot;qtemporaryfile#fileName&quot;&gt;fileName&lt;/a&gt;() or leave the auto removal functionality enabled.</source>
          <target state="translated">일부 시스템 에서 파일을 닫기 전에 &lt;a href=&quot;qtemporaryfile#fileName&quot;&gt;fileName&lt;/a&gt; ()을 호출하지 않으면이 특성의 상태에 관계없이 임시 파일이 제거 될 수 있습니다. 이 동작에 의존해서는 &lt;a href=&quot;qtemporaryfile#fileName&quot;&gt;안되므로&lt;/a&gt; 응용 프로그램 코드는 fileName ()을 호출 하거나 자동 제거 기능을 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="c80e7654a8bec1f4d5facbbd74deaca93f98ee25" translate="yes" xml:space="preserve">
          <source>On some systems, reading an image directly to &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; can use less memory than reading a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; to convert it to &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt;.</source>
          <target state="translated">일부 시스템에서 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap으로&lt;/a&gt; 직접 이미지를 읽는 것은 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 를 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 으로 변환하기 위해 읽는 것보다 적은 메모리를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0317377699bff9eb7d97170a601767a6a9cfb34e" translate="yes" xml:space="preserve">
          <source>On some systems, the tooltip's length is limited. The tooltip will be truncated if necessary.</source>
          <target state="translated">일부 시스템에서는 툴팁 길이가 제한됩니다. 필요한 경우 툴팁이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="8acffa276c4f7f8f8e7bf0d6d37e74022ed7de05" translate="yes" xml:space="preserve">
          <source>On some touch screens the coordinates must be rotated by setting &lt;code&gt;rotate&lt;/code&gt; to 90, 180, or 270.</source>
          <target state="translated">On some touch screens the coordinates must be rotated by setting &lt;code&gt;rotate&lt;/code&gt; to 90, 180, or 270.</target>
        </trans-unit>
        <trans-unit id="6d596c23df0bcb80eb02dee73f5b9614aa3ed6e0" translate="yes" xml:space="preserve">
          <source>On some types of touchscreens, especially those using TUIO drivers, it's possible to use recognizable physical tokens (fiducial objects) in addition to fingers. So if this point is a touch point, and uniqueId is set, it is the identifier for such an object.</source>
          <target state="translated">일부 유형의 터치 스크린, 특히 TUIO 드라이버를 사용하는 터치 스크린에서는 손가락 외에 인식 가능한 물리적 토큰 (기준 객체)을 사용할 수 있습니다. 따라서이 점이 터치 점이고 uniqueId가 설정된 경우 해당 점의 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="e04c70e0a07d9e15dd2ce9a8af14e64663eef194" translate="yes" xml:space="preserve">
          <source>On standard Linux distributions such as Ubuntu, gamepads such as XBox or PlayStation controllers are detected out-of-the-box. To check if the gamepad is detected, &lt;code&gt;grep&lt;/code&gt; the &lt;code&gt;dmesg&lt;/code&gt; logs using:</source>
          <target state="translated">Ubuntu와 같은 표준 Linux 배포에서는 XBox 또는 PlayStation 컨트롤러와 같은 게임 패드가 기본적으로 감지됩니다. 게임 패드가 감지되는지 확인하려면 다음을 사용하여 &lt;code&gt;dmesg&lt;/code&gt; 로그를 &lt;code&gt;grep&lt;/code&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d5472790337d1d4e59cdd56ed2dea3a96341787" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;true&lt;/code&gt; and the socket enters &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;BoundState&lt;/a&gt;; otherwise it returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">성공하면 함수는 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 소켓은 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;BoundState에&lt;/a&gt; 들어 갑니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="217a151d2ba7560a1f4a4b2e9000d3ada58dd09c" translate="yes" xml:space="preserve">
          <source>On success, this function returns the integer which has been entered by the user; on failure, it returns the initial</source>
          <target state="translated">성공하면이 함수는 사용자가 입력 한 정수를 반환합니다. 실패하면 초기 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0a549d2d16f78dece6ffe5f4ba948cc6c05ced1e" translate="yes" xml:space="preserve">
          <source>On successful completion of the operation, the reply will contain a list of search term suggestions. See &lt;a href=&quot;location-places-cpp#search-suggestions&quot;&gt;Search Suggestions&lt;/a&gt; for an example on how to use a search suggestion reply.</source>
          <target state="translated">작업이 성공적으로 완료되면 회신에 검색어 제안 목록이 포함됩니다. 검색 제안 응답을 사용하는 방법에 대한 예는 &lt;a href=&quot;location-places-cpp#search-suggestions&quot;&gt;검색 제안&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="48432cc5d48df67b159bc70dcb3b1ff5be20eb08" translate="yes" xml:space="preserve">
          <source>On system start-up, the default layout direction depends on the application's language.</source>
          <target state="translated">시스템 시작시 기본 레이아웃 방향은 응용 프로그램의 언어에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9f6f61c3a0a5edacdb6941ae738f76fa70e3be35" translate="yes" xml:space="preserve">
          <source>On systems running a Linux kernel without inotify support, file systems that contain watched paths cannot be unmounted.</source>
          <target state="translated">inotify를 지원하지 않고 Linux 커널을 실행하는 시스템에서는 감시 경로가 포함 된 파일 시스템을 마운트 해제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fa66645afc6a39ae41bd9362f5877b326bd036c5" translate="yes" xml:space="preserve">
          <source>On systems that are configured to use the available screens as a single, large virtual desktop, the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qdesktopwidget-obsolete.html#virtualDesktop-prop&quot;&gt;virtualDesktop&lt;/a&gt; property will be set to true. In this case, the widget's size is usually the size of the bounding rectangle of all the screens.</source>
          <target state="translated">사용 가능한 화면을 하나의 큰 가상 데스크톱으로 사용하도록 구성된 시스템에서 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qdesktopwidget-obsolete.html#virtualDesktop-prop&quot;&gt;virtualDesktop&lt;/a&gt; 속성이 true로 설정됩니다. 이 경우 위젯의 크기는 일반적으로 모든 화면의 경계 사각형 크기입니다.</target>
        </trans-unit>
        <trans-unit id="5ce06ea7ef750ab64d75b86a57bfd0821bc61477" translate="yes" xml:space="preserve">
          <source>On systems that are configured to use the available screens as a single, large virtual desktop, the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qdesktopwidget-obsolete.html#virtualDesktop-prop&quot;&gt;virtualDesktop&lt;/a&gt; property will be set to true. In this case, the widget's size is usually the size of the bounding rectangle of all the screens.</source>
          <target state="translated">On systems that are configured to use the available screens as a single, large virtual desktop, the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qdesktopwidget-obsolete.html#virtualDesktop-prop&quot;&gt;virtualDesktop&lt;/a&gt; property will be set to true. In this case, the widget's size is usually the size of the bounding rectangle of all the screens.</target>
        </trans-unit>
        <trans-unit id="6b75b64683e6a4695e0bfa1ff74f76fc05dfdc7a" translate="yes" xml:space="preserve">
          <source>On systems that do not have symbolic links this function will always return the same string that &lt;a href=&quot;qdir#absolutePath&quot;&gt;absolutePath&lt;/a&gt;() returns. If the canonical path does not exist (normally due to dangling symbolic links) canonicalPath() returns an empty string.</source>
          <target state="translated">심볼릭 링크가없는 시스템에서이 함수는 항상 &lt;a href=&quot;qdir#absolutePath&quot;&gt;absolutePath&lt;/a&gt; ()가 반환하는 것과 동일한 문자열을 반환합니다. 표준 경로가 존재하지 않으면 (일반적으로 매달려있는 심볼릭 링크로 인해) canonicalPath ()는 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bf055bffb495271e6b40153e0db0d5bea81548b3" translate="yes" xml:space="preserve">
          <source>On systems that do not support time zones, this function will behave as if local time were &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt::UTC&lt;/a&gt;.</source>
          <target state="translated">시간대를 지원하지 않는 시스템에서이 기능은 현지 시간이 &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt :: UTC 인&lt;/a&gt; 것처럼 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="8426a5b516aee828131cfae3e4c5e93ba71cdc42" translate="yes" xml:space="preserve">
          <source>On systems where files do not have permissions this function always returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">파일에 권한이없는 시스템에서이 함수는 항상 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="d9f5896ef661837ef656cf71b6500f89533d6442" translate="yes" xml:space="preserve">
          <source>On systems where the user's desktop is displayed using more than one screen, certain types of applications may need to obtain information about the configuration of the user's workspace to ensure that new windows and dialogs are opened in appropriate locations.</source>
          <target state="translated">사용자 바탕 화면이 둘 이상의 화면을 사용하여 표시되는 시스템에서 특정 유형의 응용 프로그램은 적절한 위치에서 새 창과 대화 상자가 열리도록 사용자 작업 공간 구성에 대한 정보를 얻어야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ff05ff4d4fd2a0c4ec48dd98879ec9f55a8f523" translate="yes" xml:space="preserve">
          <source>On systems which do not maintain a list of &lt;a href=&quot;qnetworkconfigurationmanager#defaultConfiguration&quot;&gt;defaultConfiguration()&lt;/a&gt; an invalid configuration is returned. A possible workaround could be to implement a custom dialog which is populated based on what &lt;a href=&quot;qnetworkconfigurationmanager#allConfigurations&quot;&gt;QNetworkConfigurationManager::allConfigurations&lt;/a&gt;() returns.</source>
          <target state="translated">&lt;a href=&quot;qnetworkconfigurationmanager#defaultConfiguration&quot;&gt;defaultConfiguration ()&lt;/a&gt; 목록을 유지 보수하지 않는 시스템 에서는 유효하지 않은 구성이 리턴됩니다. 가능한 해결책은 &lt;a href=&quot;qnetworkconfigurationmanager#allConfigurations&quot;&gt;QNetworkConfigurationManager :: allConfigurations&lt;/a&gt; ()가 리턴 하는 내용에 따라 채워지는 사용자 정의 대화 상자를 구현하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="be67d578a0a19a7c002cb93d3f49e9f5cab50f22" translate="yes" xml:space="preserve">
          <source>On that same note, the overload of &lt;a href=&quot;qtest#touchEvent&quot;&gt;QTest::touchEvent&lt;/a&gt;() taking a &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; parameter has been changed to return a QTouchEventWidgetSequence object.</source>
          <target state="translated">같은 메모에서 &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; 매개 변수 를 사용하는 &lt;a href=&quot;qtest#touchEvent&quot;&gt;QTest :: touchEvent&lt;/a&gt; () 의 오버로드가 QTouchEventWidgetSequence 개체를 반환하도록 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="8c7112f14169be9a416c8fe33e65874cb5a01deb" translate="yes" xml:space="preserve">
          <source>On the &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; side, the &lt;a href=&quot;qremoteobjectnode&quot;&gt;QRemoteObjectNode&lt;/a&gt; needs to register a callback to be used when the external schema is detected. The callback must be a &lt;a href=&quot;qremoteobjectnode#RemoteObjectSchemaHandler-typedef&quot;&gt;RemoteObjectSchemaHandler&lt;/a&gt;.</source>
          <target state="translated">온 &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;복제&lt;/a&gt; 측의 &lt;a href=&quot;qremoteobjectnode&quot;&gt;QRemoteObjectNode는&lt;/a&gt; 외부 스키마가 검출 될 때 사용될 콜백을 등록 할 필요가있다. 콜백은 &lt;a href=&quot;qremoteobjectnode#RemoteObjectSchemaHandler-typedef&quot;&gt;RemoteObjectSchemaHandler&lt;/a&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="434b12f1d40f9f93e07ace07abf7185c1c9c874a" translate="yes" xml:space="preserve">
          <source>On the QML side, you can now use the registered enums:</source>
          <target state="translated">QML 측에서 등록 된 열거 형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2d93553590cf4d762928f286dacc78e76252159" translate="yes" xml:space="preserve">
          <source>On the Session Bus, one can find other applications by the same user that are sharing the same desktop session (hence the name). On the System Bus, however, processes shared for the whole system are usually found.</source>
          <target state="translated">세션 버스에서 동일한 데스크톱 세션을 공유하는 동일한 사용자 (따라서 이름)가 다른 응용 프로그램을 찾을 수 있습니다. 그러나 시스템 버스에서는 일반적으로 전체 시스템에 대해 공유 된 프로세스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac0312dc21f0f689a2421be25d12d0f7d2a078ba" translate="yes" xml:space="preserve">
          <source>On the command-line, applications can be built using &lt;code&gt;qmake&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt;. Optionally, &lt;code&gt;qmake&lt;/code&gt; can generate project files for Xcode with &lt;code&gt;-spec macx-xcode&lt;/code&gt;. If you are using the binary package, &lt;code&gt;qmake&lt;/code&gt; generates Xcode projects by default; use &lt;code&gt;-spec macx-gcc&lt;/code&gt; to generate makefiles. For example:</source>
          <target state="translated">명령 행에서 &lt;code&gt;qmake&lt;/code&gt; 및 &lt;code&gt;make&lt;/code&gt; 를 사용하여 애플리케이션을 빌드 할 수 있습니다 . 선택적으로 &lt;code&gt;qmake&lt;/code&gt; 는 &lt;code&gt;-spec macx-xcode&lt;/code&gt; 를 사용 하여 Xcode 용 프로젝트 파일을 생성 할 수 있습니다 . 이진 패키지를 사용하는 경우 &lt;code&gt;qmake&lt;/code&gt; 는 기본적으로 Xcode 프로젝트를 생성합니다. makefile을 생성 하려면 &lt;code&gt;-spec macx-gcc&lt;/code&gt; 를 사용 하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e7a075199183b4ffd28da5b3a472c3762bf816a8" translate="yes" xml:space="preserve">
          <source>On the left of the text.</source>
          <target state="translated">텍스트 왼쪽</target>
        </trans-unit>
        <trans-unit id="b893e06264de3baeae08aa2679375bca3ba98d66" translate="yes" xml:space="preserve">
          <source>On the low level, applications communicate over D-Bus by sending messages to one another. Messages are used to relay the remote procedure calls as well as the replies and errors associated with them. When used over a bus, messages have a destination, which means they are routed only to the interested parties, avoiding congestion due to &quot;swarming&quot; or broadcasting.</source>
          <target state="translated">낮은 수준에서 응용 프로그램은 서로에게 메시지를 보내 D-Bus를 통해 통신합니다. 메시지는 원격 프로 시저 호출과 관련된 응답 및 오류를 릴레이하는 데 사용됩니다. 버스를 통해 사용될 때, 메시지는 목적지를 가지게됩니다. 즉, 메시지는 &quot;스 워밍&quot;또는 브로드 캐스트로 인한 혼잡을 피하면서 이해 당사자에게만 라우팅됩니다.</target>
        </trans-unit>
        <trans-unit id="474353455aaf6ed877e94689a204a43c53528cfe" translate="yes" xml:space="preserve">
          <source>On the next page you will need to select the certificates that will be distributed with your Provisioning Profile. You would have needed to uploaded a certificate on your local development machine to the Apple Developer Certificate, Identifiers, and Profiles manger previously. Generally you will want to add any certificates of the members of your team who will need to build your App.</source>
          <target state="translated">다음 페이지에서 프로비저닝 프로파일과 함께 배포 할 인증서를 선택해야합니다. 로컬 개발 시스템의 인증서를 이전에 Apple Developer Certificate, Identifiers 및 Profiles 관리자에 업로드해야했습니다. 일반적으로 앱을 빌드해야하는 팀 구성원의 인증서를 추가하려고합니다.</target>
        </trans-unit>
        <trans-unit id="4cd8b38bae57b5c4b4f560bf9622743d3abe6099" translate="yes" xml:space="preserve">
          <source>On the next page you will need to select the devices you will be developing and testing your app on. You must register your devices to the Apple Developer Certificate, Identifiers, and Profiles manger previously. The devices you select here are the only ones capable of running apps signed against this provisioning profile, so select all the devices you intend use during the development and testing phase.</source>
          <target state="translated">다음 페이지에서 앱을 개발하고 테스트 할 장치를 선택해야합니다. 이전에 장치를 Apple 개발자 인증서, 식별자 및 프로파일 관리자에 등록해야합니다. 여기에서 선택한 장치는이 프로비저닝 프로파일에 서명 된 앱을 실행할 수있는 유일한 장치이므로 개발 및 테스트 단계에서 사용하려는 모든 장치를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="1095c34dea0969f3125e4d8c989adc79207f7f0a" translate="yes" xml:space="preserve">
          <source>On the next page, you must fill out the details about your product. The &lt;b&gt;Reference Name&lt;/b&gt; field refers to how the product will be displayed in iTunes Connect and in sales reports, but not in the App Store itself. The &lt;b&gt;Product ID&lt;/b&gt; field is very important as it is the unique ID that will be used to query for the product from your app itself. If possible make this the same ID as the corresponding products in the other platform&amp;rsquo;s stores, otherwise you will have to conditional logic in your app for each platform when specifying product identifiers.</source>
          <target state="translated">다음 페이지에서 제품에 대한 세부 사항을 작성해야합니다. &lt;b&gt;Reference Name&lt;/b&gt; ( &lt;b&gt;참조 이름)&lt;/b&gt; 필드는 제품이 iTunes Connect 및 판매 보고서에 표시되지만 App Store 자체에는 표시되지 않는 방식을 나타냅니다. &lt;b&gt;제품 ID&lt;/b&gt; 이 앱 자체에서 제품에 대한 쿼리에 사용되는 고유 한 ID가 같은 필드는 매우 중요하다. 가능하면이 ID를 다른 플랫폼의 상점에있는 해당 제품과 동일한 ID로 설정하십시오. 그렇지 않으면 제품 식별자를 지정할 때 각 플랫폼에 대해 앱의 조건부 논리를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb222a18690f0b2c76bb9525cee3e76a8903aa6d" translate="yes" xml:space="preserve">
          <source>On the other hand, if a bus is not used, service names are also not used. If we compare this to a computer network again, this would equate to a point-to-point network: since the peer is known, there is no need to use hostnames to find it or its IP address.</source>
          <target state="translated">한편, 버스를 사용하지 않으면 서비스 이름도 사용되지 않습니다. 이것을 컴퓨터 네트워크와 다시 비교하면, 이것은 포인트-투-포인트 네트워크와 같습니다. 피어가 알려져 있기 때문에 호스트 이름을 사용하여 호스트 나 IP 주소를 찾을 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="dcdc862fdefd8cd0bf302443bbccbf1004374cfc" translate="yes" xml:space="preserve">
          <source>On the other hand, logging in synchronous mode has a high overhead, but the OpenGL implementation guarantees that all the messages caused by a certain command are received in order, before the command returns, and from the same thread the OpenGL context is bound to.</source>
          <target state="translated">반면, 동기 모드로 로깅하면 오버 헤드가 크지 만 OpenGL 구현은 명령이 리턴되기 전에 OpenGL 컨텍스트가 바인드 된 동일한 스레드에서 특정 명령으로 인해 발생하는 모든 메시지가 순서대로 수신되도록합니다.</target>
        </trans-unit>
        <trans-unit id="1e9c8ca1de36db669e292891fcbf1796fb641b2f" translate="yes" xml:space="preserve">
          <source>On the other hand, suppose you really want only one &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; element, the first one in the document (i.e., you only want the first &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; element in the first &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element). Then you have to do more filtering. There are two ways you can do it. You can apply the &lt;code&gt;[1]&lt;/code&gt; filter in the same place as above but enclose the path expression in parentheses:</source>
          <target state="translated">반면에, 당신이 정말로 하나의 경우를 가정 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; , 문서의 첫 번째 (즉, 당신이 첫 번째 원하는 요소를 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 최초의 요소 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 요소). 그런 다음 더 많은 필터링을 수행해야합니다. 당신이 그것을 할 수있는 두 가지 방법이 있습니다. &lt;code&gt;[1]&lt;/code&gt; 필터를 위와 같은 곳에 적용 할 수 있지만 경로 식을 괄호로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a6cc0954d4400f7b8d60c4b505bd97e38e7f9c3" translate="yes" xml:space="preserve">
          <source>On the other hand, this means &lt;a href=&quot;qelapsedtimer&quot;&gt;QElapsedTimer&lt;/a&gt; values can only be compared with other values that use the same reference. This is especially true if the time since the reference is extracted from the &lt;a href=&quot;qelapsedtimer&quot;&gt;QElapsedTimer&lt;/a&gt; object (&lt;a href=&quot;qelapsedtimer#msecsSinceReference&quot;&gt;QElapsedTimer::msecsSinceReference&lt;/a&gt;()) and serialised. These values should never be exchanged across the network or saved to disk, since there's no telling whether the computer node receiving the data is the same as the one originating it or if it has rebooted since.</source>
          <target state="translated">반면에 &lt;a href=&quot;qelapsedtimer&quot;&gt;QElapsedTimer&lt;/a&gt; 값은 동일한 참조를 사용하는 다른 값과 만 비교할 수 있습니다. 이는 &lt;a href=&quot;qelapsedtimer&quot;&gt;QElapsedTimer&lt;/a&gt; 오브젝트 ( &lt;a href=&quot;qelapsedtimer#msecsSinceReference&quot;&gt;QElapsedTimer :: msecsSinceReference&lt;/a&gt; ()) 에서 참조 이후의 시간이 추출되어 직렬화 된 경우 특히 그렇습니다 . 이 값은 네트워크를 통해 교환하거나 디스크에 저장해서는 안됩니다. 데이터를 수신하는 컴퓨터 노드가 데이터를 수신 한 컴퓨터 노드가 원래 노드와 동일한 지 또는 그 이후에 재부팅되었는지를 알 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="40cd37db24fc45b9afd18fe5f46b8a662dcc3d91" translate="yes" xml:space="preserve">
          <source>On the other hand, this means QElapsedTimer values can only be compared with other values that use the same reference. This is especially true if the time since the reference is extracted from the QElapsedTimer object (&lt;a href=&quot;qelapsedtimer#msecsSinceReference&quot;&gt;QElapsedTimer::msecsSinceReference&lt;/a&gt;()) and serialised. These values should never be exchanged across the network or saved to disk, since there's no telling whether the computer node receiving the data is the same as the one originating it or if it has rebooted since.</source>
          <target state="translated">On the other hand, this means QElapsedTimer values can only be compared with other values that use the same reference. This is especially true if the time since the reference is extracted from the QElapsedTimer object (&lt;a href=&quot;qelapsedtimer#msecsSinceReference&quot;&gt;QElapsedTimer::msecsSinceReference&lt;/a&gt;()) and serialised. These values should never be exchanged across the network or saved to disk, since there's no telling whether the computer node receiving the data is the same as the one originating it or if it has rebooted since.</target>
        </trans-unit>
        <trans-unit id="77efd63831eb7f5c8d427c682d396f441648e591" translate="yes" xml:space="preserve">
          <source>On the other hand, you can safely emit signals from your &lt;a href=&quot;qthread#run&quot;&gt;QThread::run&lt;/a&gt;() implementation, because signal emission is thread-safe.</source>
          <target state="translated">반면, 신호 방출은 스레드로부터 안전하기 때문에 &lt;a href=&quot;qthread#run&quot;&gt;QThread :: run&lt;/a&gt; () 구현 에서 신호를 안전하게 방출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bf88653bfda95e8a89fbed43dbde4d043afbe5d" translate="yes" xml:space="preserve">
          <source>On the replica side, we need to:</source>
          <target state="translated">On the replica side, we need to:</target>
        </trans-unit>
        <trans-unit id="344ebd30c1691d76097cb441fd3a73887ee9baef" translate="yes" xml:space="preserve">
          <source>On the right of the text.</source>
          <target state="translated">텍스트 오른쪽에</target>
        </trans-unit>
        <trans-unit id="d9695003eed75e0367ce194cd0631e7c102416ac" translate="yes" xml:space="preserve">
          <source>On the system bus, one can also expect to find restrictions on what services each application is allowed to offer. Therefore, one can be reasonably certain that, if a certain service is present, it is being offered by a trusted application.</source>
          <target state="translated">또한 시스템 버스에서 각 응용 프로그램이 제공 할 수있는 서비스에 대한 제한 사항을 찾을 수 있습니다. 따라서 특정 서비스가있는 경우 신뢰할 수있는 응용 프로그램에서 제공하고 있다고 합리적으로 확신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1d30a51f1a28aaad2ba00d5b901c1fe57bc5e80" translate="yes" xml:space="preserve">
          <source>On touch, &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt; enables flicking and makes the scroll bars non-interactive.</source>
          <target state="translated">터치하면 &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView가 깜박임을&lt;/a&gt; 활성화하고 스크롤 막대를 비 대화식으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8918fe1b643b1e2d15cbeb59abc161026f7563a9" translate="yes" xml:space="preserve">
          <source>On touch, ScrollView enables flicking and makes the scroll bars non-interactive.</source>
          <target state="translated">On touch, ScrollView enables flicking and makes the scroll bars non-interactive.</target>
        </trans-unit>
        <trans-unit id="c953e28176379d2bdf43ea5238ba0de72683afb1" translate="yes" xml:space="preserve">
          <source>On touchscreens that can track physical objects (such as knobs or game pieces) in addition to fingers, each object usually has a unique ID. Likewise, each stylus that can be used with a graphics tablet usually has a unique serial number. Qt so far only supports numeric IDs. You can get the actual number as uniqueId.numeric, but that is a device-specific detail. In the future, there may be support for non-numeric IDs, so you should not assume that the number is meaningful.</source>
          <target state="translated">손가락 외에 물리적 인 물체 (예 : 손잡이 또는 게임 조각)를 추적 할 수있는 터치 스크린에서 각 물체에는 일반적으로 고유 한 ID가 있습니다. 마찬가지로 그래픽 태블릿과 함께 사용할 수있는 각 스타일러스에는 일반적으로 고유 한 일련 번호가 있습니다. 지금까지 Qt는 숫자 ID 만 지원합니다. 실제 숫자는 uniqueId.numeric로 얻을 수 있지만 장치 별 세부 정보입니다. 앞으로는 숫자가 아닌 ID를 지원할 수 있으므로 숫자가 의미가 있다고 가정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6ba13ef24b5b098754a4165ca757a51542b2947b" translate="yes" xml:space="preserve">
          <source>On your Embedded Linux device, when there's no windowing system present, the mouse, keyboard, and touch input are read directly via &lt;code&gt;evdev&lt;/code&gt; or using helper libraries such as &lt;code&gt;libinput&lt;/code&gt; or &lt;code&gt;tslib&lt;/code&gt;. However, this behavior requires that device nodes &lt;code&gt;/dev/input/event*&lt;/code&gt; are readable by the user. &lt;code&gt;eglfs&lt;/code&gt; and &lt;code&gt;linuxfb&lt;/code&gt; have all the input handling code compiled-in.</source>
          <target state="translated">On your Embedded Linux device, when there's no windowing system present, the mouse, keyboard, and touch input are read directly via &lt;code&gt;evdev&lt;/code&gt; or using helper libraries such as &lt;code&gt;libinput&lt;/code&gt; or &lt;code&gt;tslib&lt;/code&gt; . However, this behavior requires that device nodes &lt;code&gt;/dev/input/event*&lt;/code&gt; are readable by the user. &lt;code&gt;eglfs&lt;/code&gt; and &lt;code&gt;linuxfb&lt;/code&gt; have all the input handling code compiled-in.</target>
        </trans-unit>
        <trans-unit id="acea668c9e98f42ef4ea326d649ea01ba5737ffb" translate="yes" xml:space="preserve">
          <source>On/off indicator for a view item.</source>
          <target state="translated">보기 항목의 켜짐 / 꺼짐 표시기.</target>
        </trans-unit>
        <trans-unit id="5fa999adb84b2c0031f4fad0cfc3a2031e391918" translate="yes" xml:space="preserve">
          <source>On/off indicator, for example, a &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt;.</source>
          <target state="translated">켜짐 / 꺼짐 표시기 (예 : &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c88a3d71536ddc26913f73b46ff11d4bbed4857e" translate="yes" xml:space="preserve">
          <source>Once &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtvirtualkeyboard-deployment-guide.html#&quot;&gt;properly installed&lt;/a&gt;, the virtual keyboard can be opened by clicking on a text input field.</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtvirtualkeyboard-deployment-guide.html#&quot;&gt;올바르게 설치&lt;/a&gt; 되면 텍스트 입력 필드를 클릭하여 가상 키보드를 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31e4cfa5dc1a88f96ee40352ea9cf380bab72c11" translate="yes" xml:space="preserve">
          <source>Once &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtvirtualkeyboard-deployment-guide.html&quot;&gt;properly installed&lt;/a&gt;, the virtual keyboard can be opened by clicking on a text input field.</source>
          <target state="translated">Once &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtvirtualkeyboard-deployment-guide.html&quot;&gt;properly installed&lt;/a&gt;, the virtual keyboard can be opened by clicking on a text input field.</target>
        </trans-unit>
        <trans-unit id="4d8ad2f36ec3282a9f11a068428d2804dd485c82" translate="yes" xml:space="preserve">
          <source>Once &lt;a href=&quot;qtextline#setLineWidth&quot;&gt;QTextLine::setLineWidth&lt;/a&gt;() is called, a new line can be created and filled with text. Repeating this process will lay out the whole block of text contained in the &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt;. If there is no text left to be inserted into the layout, the &lt;a href=&quot;qtextline&quot;&gt;QTextLine&lt;/a&gt; returned will not be valid (isValid() will return false).</source>
          <target state="translated">일단 &lt;a href=&quot;qtextline#setLineWidth&quot;&gt;QTextLine :: setLineWidth은&lt;/a&gt; ()가 호출, 새로운 라인이 생성 및 텍스트로 가득 할 수 있습니다. 이 과정을 반복하면 &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout에&lt;/a&gt; 포함 된 전체 텍스트 블록이 레이아웃됩니다 . 레이아웃에 삽입 할 텍스트가 없으면 반환 된 &lt;a href=&quot;qtextline&quot;&gt;QTextLine&lt;/a&gt; 이 유효하지 않습니다 (isValid ()는 false를 반환 함).</target>
        </trans-unit>
        <trans-unit id="fc12fd14aa59b1809aeda499e402a77f7adedf6b" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;KeyReader.qml&lt;/code&gt; is loaded, it accepts key events and sets &lt;code&gt;event.accepted&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; so that the event is not propagated to the parent &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;KeyReader.qml&lt;/code&gt; 이로 드 되면 키 이벤트를 승인하고 &lt;code&gt;event.accepted&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정 하여 이벤트가 상위 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle로&lt;/a&gt; 전파되지 않도록합니다 .</target>
        </trans-unit>
        <trans-unit id="369b21cf40402245a2f9ab26af7722f2887f9ea4" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;doc&lt;/code&gt; and &lt;code&gt;elem&lt;/code&gt; go out of scope, the whole internal tree representing the XML document is deleted.</source>
          <target state="translated">일단 &lt;code&gt;doc&lt;/code&gt; 및 &lt;code&gt;elem&lt;/code&gt; 범위의 외출, XML 문서를 나타내는 전체 내부 트리가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="e2733f23a6718804c20daaf4d4d47b6a64f59d3d" translate="yes" xml:space="preserve">
          <source>Once Qt is installed, you can use the</source>
          <target state="translated">Qt가 설치되면</target>
        </trans-unit>
        <trans-unit id="ee1dc491fdd55ffd0fc4b2fbeb16f60438de0327" translate="yes" xml:space="preserve">
          <source>Once Qt is installed, you can use the Maintenance Tool under</source>
          <target state="translated">Qt가 설치되면 아래의 유지 관리 도구를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="83d0b39e5b2ba9fd3ca62bf11a2e51fe3ba848ee" translate="yes" xml:space="preserve">
          <source>Once a &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; has been created it should be added to the relevant menu and toolbar, then connected to the slot which will perform the action. For example:</source>
          <target state="translated">&lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; 이 생성 되면 관련 메뉴 및 도구 모음에 추가 된 다음 작업을 수행 할 슬롯에 연결되어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43e1f30afc29295352c577708ea4d49f0ba6df3c" translate="yes" xml:space="preserve">
          <source>Once a &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; has been created for a target object, the gesture recognizer will receive events for it in its &lt;a href=&quot;qgesturerecognizer#recognize&quot;&gt;recognize&lt;/a&gt;() handler function.</source>
          <target state="translated">대상 객체에 대한 &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; 가 작성 되면 제스처 인식기는 &lt;a href=&quot;qgesturerecognizer#recognize&quot;&gt;인식&lt;/a&gt; () 핸들러 함수 에서 해당 이벤트에 대한 이벤트를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="61d56c40b76bb9d0bb53c2596af9a9d3b932c1f7" translate="yes" xml:space="preserve">
          <source>Once a &lt;a href=&quot;qmodbusclient&quot;&gt;QModbusClient&lt;/a&gt; object has been created, the application can use it to send requests. The returned object is used to obtain any data returned in response to the corresponding request.</source>
          <target state="translated">한 번 &lt;a href=&quot;qmodbusclient&quot;&gt;QModbusClient의&lt;/a&gt; 객체가 생성 된 응용 프로그램이 요청을 전송하는 데 사용할 수 있습니다. 반환 된 객체는 해당 요청에 대한 응답으로 반환 된 데이터를 가져 오는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d98a7ef943520707456603e0929cc41dd24752d6" translate="yes" xml:space="preserve">
          <source>Once a &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; object has been created, the application can use it to send requests over the network. A group of standard functions are supplied that take a request and optional data, and each return a &lt;a href=&quot;qnetworkreply&quot;&gt;QNetworkReply&lt;/a&gt; object. The returned object is used to obtain any data returned in response to the corresponding request.</source>
          <target state="translated">한 번 &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager의&lt;/a&gt; 객체가 생성 된 응용 프로그램은 네트워크를 통해 요청을 전송하는 데 사용할 수 있습니다. 요청 및 선택적 데이터를 취하는 표준 기능 그룹이 제공되며 각각 &lt;a href=&quot;qnetworkreply&quot;&gt;QNetworkReply&lt;/a&gt; 객체를 반환 합니다. 반환 된 객체는 해당 요청에 대한 응답으로 반환 된 데이터를 가져 오는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3b084b214d79ee12ee2d4e237b98fa9681392b7d" translate="yes" xml:space="preserve">
          <source>Once a &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; has been made current, you can render to it in a platform independent way by using Qt's OpenGL enablers such as &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt;, &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt;, &lt;a href=&quot;qopenglshaderprogram&quot;&gt;QOpenGLShaderProgram&lt;/a&gt;, and &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject&lt;/a&gt;. It is also possible to use the platform's OpenGL API directly, without using the Qt enablers, although potentially at the cost of portability. The latter is necessary when wanting to use OpenGL 1.x or OpenGL ES 1.x.</source>
          <target state="translated">&lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; 가 최신 상태 가 되면 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; , &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt; , &lt;a href=&quot;qopenglshaderprogram&quot;&gt;QOpenGLShaderProgram&lt;/a&gt; 및 &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject&lt;/a&gt; 와 같은 Qt의 OpenGL 인 에이 블러를 사용하여 플랫폼 독립적 인 방식으로 렌더링 할 수 있습니다 . Qt 인 에이 블러를 사용하지 않고도 플랫폼의 OpenGL API를 직접 사용할 수도 있지만 이식성이 떨어질 수 있습니다. 후자는 OpenGL 1.x 또는 OpenGL ES 1.x를 사용하고자 할 때 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e27bff41670537dc5d121238abb2648ff3024d56" translate="yes" xml:space="preserve">
          <source>Once a &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt; object is constructed, subpaths like lines and curves can be added to the path (creating &lt;a href=&quot;qpainterpath#ElementType-enum&quot;&gt;QPainterPath::LineToElement&lt;/a&gt; and &lt;a href=&quot;qpainterpath#ElementType-enum&quot;&gt;QPainterPath::CurveToElement&lt;/a&gt; components).</source>
          <target state="translated">&lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt; 오브젝트가 구성 되면 선 및 곡선과 같은 서브 패스를 경로에 추가 할 수 있습니다 ( &lt;a href=&quot;qpainterpath#ElementType-enum&quot;&gt;QPainterPath :: LineToElement&lt;/a&gt; 및 &lt;a href=&quot;qpainterpath#ElementType-enum&quot;&gt;QPainterPath :: CurveToElement&lt;/a&gt; 컴포넌트 작성).</target>
        </trans-unit>
        <trans-unit id="6a2d4470eae5a525141184fc66126986ce9f96a3" translate="yes" xml:space="preserve">
          <source>Once a &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; object has been constructed and set up, a &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; can be used to perform painting operations on it. We can construct and set up a painter in the following way:</source>
          <target state="translated">한 번 &lt;a href=&quot;qprinter&quot;&gt;QPrinter의&lt;/a&gt; 개체를 구성하고 설정 한하는 &lt;a href=&quot;qpainter&quot;&gt;QPainter를가&lt;/a&gt; 그 위에 그림 작업을 수행 할 수 있습니다. 다음과 같은 방법으로 화가를 구성하고 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd0721eed9935f2e299cbcbdde10a7b0feb6fe4d" translate="yes" xml:space="preserve">
          <source>Once a QAction has been created it should be added to the relevant menu and toolbar, then connected to the slot which will perform the action. For example:</source>
          <target state="translated">Once a QAction has been created it should be added to the relevant menu and toolbar, then connected to the slot which will perform the action. For example:</target>
        </trans-unit>
        <trans-unit id="6a811fafe26d686311e7bed27410ad8f9cc95408" translate="yes" xml:space="preserve">
          <source>Once a QAction has been created, it should be added to the relevant menu and toolbar, then connected to the slot which will perform the action. For example:</source>
          <target state="translated">QAction이 생성되면 관련 메뉴 및 도구 모음에 추가 한 다음 해당 작업을 수행 할 슬롯에 연결해야합니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3613c1dffcb14effdec6c7212c9fcc2898a5e78f" translate="yes" xml:space="preserve">
          <source>Once a QModbusClient object has been created, the application can use it to send requests. The returned object is used to obtain any data returned in response to the corresponding request.</source>
          <target state="translated">Once a QModbusClient object has been created, the application can use it to send requests. The returned object is used to obtain any data returned in response to the corresponding request.</target>
        </trans-unit>
        <trans-unit id="f603432194155193688fb9a08fe600db985b6201" translate="yes" xml:space="preserve">
          <source>Once a QNetworkAccessManager object has been created, the application can use it to send requests over the network. A group of standard functions are supplied that take a request and optional data, and each return a &lt;a href=&quot;qnetworkreply&quot;&gt;QNetworkReply&lt;/a&gt; object. The returned object is used to obtain any data returned in response to the corresponding request.</source>
          <target state="translated">Once a QNetworkAccessManager object has been created, the application can use it to send requests over the network. A group of standard functions are supplied that take a request and optional data, and each return a &lt;a href=&quot;qnetworkreply&quot;&gt;QNetworkReply&lt;/a&gt; object. The returned object is used to obtain any data returned in response to the corresponding request.</target>
        </trans-unit>
        <trans-unit id="5fda68cb0bc3e311f823ec3cf4230458f5c8806e" translate="yes" xml:space="preserve">
          <source>Once a QOpenGLContext has been made current, you can render to it in a platform independent way by using Qt's OpenGL enablers such as &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt;, &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt;, &lt;a href=&quot;qopenglshaderprogram&quot;&gt;QOpenGLShaderProgram&lt;/a&gt;, and &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject&lt;/a&gt;. It is also possible to use the platform's OpenGL API directly, without using the Qt enablers, although potentially at the cost of portability. The latter is necessary when wanting to use OpenGL 1.x or OpenGL ES 1.x.</source>
          <target state="translated">Once a QOpenGLContext has been made current, you can render to it in a platform independent way by using Qt's OpenGL enablers such as &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt;, &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt;, &lt;a href=&quot;qopenglshaderprogram&quot;&gt;QOpenGLShaderProgram&lt;/a&gt;, and &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject&lt;/a&gt;. It is also possible to use the platform's OpenGL API directly, without using the Qt enablers, although potentially at the cost of portability. The latter is necessary when wanting to use OpenGL 1.x or OpenGL ES 1.x.</target>
        </trans-unit>
        <trans-unit id="eff758df4832ec35e3cc87f628295a7d11603154" translate="yes" xml:space="preserve">
          <source>Once a QOpenGLContext has been made current, you can render to it in a platform independent way by using Qt's OpenGL enablers such as &lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt;, &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt;, &lt;a href=&quot;qopenglshaderprogram&quot;&gt;QOpenGLShaderProgram&lt;/a&gt;, and &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject&lt;/a&gt;. It is also possible to use the platform's OpenGL API directly, without using the Qt enablers, although potentially at the cost of portability. The latter is necessary when wanting to use OpenGL 1.x or OpenGL ES 1.x.</source>
          <target state="translated">QOpenGLContext가 최신 상태가되면 &lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; , &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt; , &lt;a href=&quot;qopenglshaderprogram&quot;&gt;QOpenGLShaderProgram&lt;/a&gt; 및 &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject&lt;/a&gt; 와 같은 Qt의 OpenGL 인 에이 블러를 사용하여 플랫폼 독립적 인 방식으로 렌더링 할 수 있습니다 . Qt 인 에이 블러를 사용하지 않고 플랫폼의 OpenGL API를 직접 사용할 수도 있지만 잠재적으로 이식성이 떨어집니다. 후자는 OpenGL 1.x 또는 OpenGL ES 1.x를 사용하려는 경우 필요합니다.</target>
        </trans-unit>
        <trans-unit id="27b48feb01099b3cfeaf6cb1cbf57f32d92d8f98" translate="yes" xml:space="preserve">
          <source>Once a client is connected to a host, valid Replicas can then be acquired if the corresponding Source is being remoted.</source>
          <target state="translated">클라이언트가 호스트에 연결되면 해당 소스가 원격 인 경우 유효한 복제본을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="865107c84714f3448d7fb0b9cda071b0e4feba9e" translate="yes" xml:space="preserve">
          <source>Once a command is pushed, the stack takes ownership of it. There are no getters to return the command, since modifying it after it has been executed will almost always lead to corruption of the document's state.</source>
          <target state="translated">명령이 푸시되면 스택이 그 소유권을 갖습니다. 명령을 실행 한 후에 수정하면 거의 항상 문서 상태가 손상되므로 명령을 반환 할 게터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5256abfdd146b98943e67f2f6ec9c59215b01a99" translate="yes" xml:space="preserve">
          <source>Once a connection is established, we can call the static function &lt;a href=&quot;qsqldatabase#database&quot;&gt;QSqlDatabase::database&lt;/a&gt;() from anywhere with a connection name to get a pointer to that database connection. If we don't pass a connection name, it will return the default connection. For example:</source>
          <target state="translated">연결이 설정되면 연결 이름이있는 곳 어디에서나 정적 함수 &lt;a href=&quot;qsqldatabase#database&quot;&gt;QSqlDatabase :: database&lt;/a&gt; ()를 호출하여 해당 데이터베이스 연결에 대한 포인터를 얻을 수 있습니다. 연결 이름을 전달하지 않으면 기본 연결이 반환됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e3e1292f78955db255d4d252e5a0511c1b9c9e2" translate="yes" xml:space="preserve">
          <source>Once a document has been parsed, its internal representation is maintained in the &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; instance and shared among multiple &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; instances.</source>
          <target state="translated">문서가 구문 분석되면 내부 표현이 &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; 인스턴스 에서 유지 관리되고 여러 &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; 인스턴스 간에 공유 됩니다.</target>
        </trans-unit>
        <trans-unit id="ab459ae4caeb629e682fb6dac38c3b74ee4d260e" translate="yes" xml:space="preserve">
          <source>Once a document has been parsed, its internal representation is maintained in the QXmlQuery instance and shared among multiple QXmlQuery instances.</source>
          <target state="translated">Once a document has been parsed, its internal representation is maintained in the QXmlQuery instance and shared among multiple QXmlQuery instances.</target>
        </trans-unit>
        <trans-unit id="3e617583a12847fefb05daac54125f2414156dfa" translate="yes" xml:space="preserve">
          <source>Once a font is found, the remaining attributes are matched in order of priority:</source>
          <target state="translated">글꼴이 발견되면 나머지 속성은 우선 순위에 따라 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8c022caf014d337f979e44b5cdd38456d077c269" translate="yes" xml:space="preserve">
          <source>Once a place is saved the reply contains the new identifier for that place.</source>
          <target state="translated">장소가 저장되면 회신에 해당 장소의 새 식별자가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="985c8565b7a16848e0e99e52adeb2e4c33ee20e9" translate="yes" xml:space="preserve">
          <source>Once a resource file is loaded, you can create or remove entries in it using the given &lt;b&gt;Add Files&lt;/b&gt;</source>
          <target state="translated">리소스 파일이로드되면 주어진 &lt;b&gt;파일 추가를&lt;/b&gt; 사용하여 리소스 파일을 만들거나 제거 할 수 있습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="89dca9c65c1ee78fa05b806a46ab88c2d614e34b" translate="yes" xml:space="preserve">
          <source>Once a scene render target is determined, then some global states are set.</source>
          <target state="translated">장면 렌더링 대상이 결정되면 일부 전역 상태가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c67240efc1ed0ad6dc10910948e36f600f7638a5" translate="yes" xml:space="preserve">
          <source>Once a service object was created for the first time, its details are yet to be discovered. This is indicated by its current &lt;a href=&quot;qlowenergyservice#state&quot;&gt;state&lt;/a&gt;() being &lt;a href=&quot;qlowenergyservice#ServiceState-enum&quot;&gt;DiscoveryRequired&lt;/a&gt;. It is only possible to retrieve the &lt;a href=&quot;qlowenergyservice#serviceUuid&quot;&gt;serviceUuid&lt;/a&gt;() and &lt;a href=&quot;qlowenergyservice#serviceName&quot;&gt;serviceName&lt;/a&gt;().</source>
          <target state="translated">서비스 오브젝트가 처음 작성된 후에는 세부 사항이 아직 발견되지 않았습니다. 현재 &lt;a href=&quot;qlowenergyservice#state&quot;&gt;상태&lt;/a&gt; ()가 &lt;a href=&quot;qlowenergyservice#ServiceState-enum&quot;&gt;DiscoveryRequired로 표시&lt;/a&gt; 됩니다. &lt;a href=&quot;qlowenergyservice#serviceUuid&quot;&gt;serviceUuid&lt;/a&gt; () 및 &lt;a href=&quot;qlowenergyservice#serviceName&quot;&gt;serviceName&lt;/a&gt; () 만 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e53733a3477bb6bf01bf485f428bc1bbf91fcb57" translate="yes" xml:space="preserve">
          <source>Once a transaction is started, subsequent calls to this function will make the transaction recursive. Inner transactions act as agents of the outermost transaction (i.e., report the status of read operations to the outermost transaction, which can restore the position of the stream).</source>
          <target state="translated">트랜잭션이 시작되면이 함수에 대한 후속 호출은 트랜잭션을 재귀 적으로 만듭니다. 내부 트랜잭션은 가장 바깥 쪽 트랜잭션의 에이전트 역할을합니다 (즉, 읽기 작업 상태를 가장 바깥 쪽 트랜잭션에보고하여 스트림의 위치를 ​​복원 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="5a48b1bd8759f52d071295cfdc69c1cd7f1884fd" translate="yes" xml:space="preserve">
          <source>Once actions have been created, we can add them to the main window components. To begin with, we add them to the pop-up menus:</source>
          <target state="translated">조치가 작성되면 기본 창 구성 요소에 추가 할 수 있습니다. 우선 팝업 메뉴에 추가합니다 :</target>
        </trans-unit>
        <trans-unit id="3faa39f01db6ebf3d4a8f5b16def0e447e0383ca" translate="yes" xml:space="preserve">
          <source>Once all of the main window components have been set up, the central widget is created and installed by using code similar to the following:</source>
          <target state="translated">모든 기본 창 구성 요소가 설정되면 다음과 유사한 코드를 사용하여 중앙 위젯이 작성되고 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="fce4756a3b2fcb3adfa961f884ca86f0a7647bbc" translate="yes" xml:space="preserve">
          <source>Once all the meshes have been drawn, the G-Buffer is filled with all the meshes that can currently be seen by the camera. The second render pass is then used to render the scene to the back buffer with the final color shading by reading the normal, color, and position values from the G-buffer textures and outputting a color onto a full screen quad.</source>
          <target state="translated">모든 메쉬가 그려지면 G-Buffer는 현재 카메라에서 볼 수있는 모든 메쉬로 채워집니다. 그런 다음 두 번째 렌더 패스를 사용하여 G- 버퍼 텍스처에서 법선, 색상 및 위치 값을 읽고 전체 화면 쿼드로 색상을 출력하여 최종 색상 음영으로 장면을 백 버퍼로 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="ae1c4a2bb77b441f2cea129f7c14216ee5ea4029" translate="yes" xml:space="preserve">
          <source>Once an application has started a sensor it must wait until the sensor receives a new value before it can query the sensor's values. This is due to how the sensor receives values from the system. Sensors do not (in general) poll for new values, rather new values are pushed to the sensors as they happen.</source>
          <target state="translated">애플리케이션이 센서를 시작하면 센서 값을 쿼리하기 전에 센서가 새로운 값을 수신 할 때까지 기다려야합니다. 이는 센서가 시스템에서 값을받는 방식 때문입니다. 센서는 일반적으로 새로운 값을 폴링하지 않고 새로운 값이 센서에 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="cf3bcacf32514d75fb5446b9cc235894721a3d4a" translate="yes" xml:space="preserve">
          <source>Once an image is unloaded it cannot be painted by the canvas context unless it is loaded again.</source>
          <target state="translated">이미지가 언로드되면 다시로드되지 않으면 캔버스 컨텍스트에서 이미지를 페인트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a3adcd87693b8ec5b34e52167be155bdc60a07e" translate="yes" xml:space="preserve">
          <source>Once an image is unloaded, it cannot be painted by the canvas context unless it is loaded again.</source>
          <target state="translated">Once an image is unloaded, it cannot be painted by the canvas context unless it is loaded again.</target>
        </trans-unit>
        <trans-unit id="daa3720dcc2e979ce83cc61dee70ef7eeb6add35" translate="yes" xml:space="preserve">
          <source>Once an install set has been fully described, you can append it to the install list with a line like this:</source>
          <target state="translated">설치 세트에 대한 설명이 완료되면 다음과 같이 설치 목록에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e181648ef9fa7a0206e5311b32e008cb1d0d2fac" translate="yes" xml:space="preserve">
          <source>Once an object instance is created, the value of its</source>
          <target state="translated">객체 인스턴스가 생성되면 객체 인스턴스의 값</target>
        </trans-unit>
        <trans-unit id="b7d193ac2a6316f487a04fe32ee9b74c0b8dfdce" translate="yes" xml:space="preserve">
          <source>Once any setter methods are called, &lt;a href=&quot;qsslconfiguration#isNull&quot;&gt;isNull&lt;/a&gt;() will return false.</source>
          <target state="translated">setter 메소드가 호출되면 &lt;a href=&quot;qsslconfiguration#isNull&quot;&gt;isNull&lt;/a&gt; ()은 false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c1ec356434daf43ee99f34ac3d62059f73505f2e" translate="yes" xml:space="preserve">
          <source>Once associated with a Shape, here is the output with a joinStyleIndex of 2 (&lt;a href=&quot;qml-qtquick-shapes-shapepath&quot;&gt;ShapePath&lt;/a&gt;.RoundJoin):</source>
          <target state="translated">Shape와 연결되면 joinStyleIndex가 2 ( &lt;a href=&quot;qml-qtquick-shapes-shapepath&quot;&gt;ShapePath&lt;/a&gt; .RoundJoin) 인 출력이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b9e45228205ee6663abfe1434702a9a28bef19e" translate="yes" xml:space="preserve">
          <source>Once associated with a Shape, here is the output with a joinStyleIndex of 2 (ShapePath.RoundJoin):</source>
          <target state="translated">Once associated with a Shape, here is the output with a joinStyleIndex of 2 (ShapePath.RoundJoin):</target>
        </trans-unit>
        <trans-unit id="fbe54f034d829bd5488d65cec04f9840368fb934" translate="yes" xml:space="preserve">
          <source>Once configuration completes without errors, run &lt;code&gt;cmake --build . --parallel&lt;/code&gt; to build. Once built, run &lt;code&gt;cmake --install .&lt;/code&gt; to install the results to &lt;code&gt;$HOME/qt6-rpi&lt;/code&gt;. From there the Qt build can be deployed to the device by using rsync, scp, or another method.</source>
          <target state="translated">구성이 오류없이 완료되면 &lt;code&gt;cmake --build . --parallel&lt;/code&gt; 실행 합니다. -병렬 구축. 빌드되면 &lt;code&gt;cmake --install .&lt;/code&gt; 실행 합니다. 결과를 &lt;code&gt;$HOME/qt6-rpi&lt;/code&gt; 에 설치합니다 . 거기에서 rsync, scp 또는 다른 방법을 사용하여 Qt 빌드를 장치에 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28c2436490251b915132715a74d5cd996aab2852" translate="yes" xml:space="preserve">
          <source>Once configured, a default platform plugin is chosen. This is used when launching an application without the &lt;code&gt;-platform&lt;/code&gt; argument and without having the &lt;code&gt;QT_QPA_PLATFORM&lt;/code&gt; environment variable set.</source>
          <target state="translated">일단 구성되면 기본 플랫폼 플러그인이 선택됩니다. &lt;code&gt;-platform&lt;/code&gt; 인수없이 &lt;code&gt;QT_QPA_PLATFORM&lt;/code&gt; 환경 변수를 설정 하지 않고 애플리케이션을 시작할 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2e4ee61e7445fa6fb6664b755a4063025b9d41f7" translate="yes" xml:space="preserve">
          <source>Once created a &lt;a href=&quot;qsound&quot;&gt;QSound&lt;/a&gt; object can be queried for its &lt;a href=&quot;qsound#fileName&quot;&gt;fileName&lt;/a&gt;() and total number of &lt;a href=&quot;qsound#loops&quot;&gt;loops&lt;/a&gt;() (i.e. the number of times the sound will play). The number of repetitions can be altered using the &lt;a href=&quot;qsound#setLoops&quot;&gt;setLoops&lt;/a&gt;() function. While playing the sound, the &lt;a href=&quot;qsound#loopsRemaining&quot;&gt;loopsRemaining&lt;/a&gt;() function returns the remaining number of repetitions. Use the &lt;a href=&quot;qsound#isFinished&quot;&gt;isFinished&lt;/a&gt;() function to determine whether the sound has finished playing.</source>
          <target state="translated">일단 생성 된 &lt;a href=&quot;qsound&quot;&gt;QSound&lt;/a&gt; 객체는 &lt;a href=&quot;qsound#fileName&quot;&gt;fileName&lt;/a&gt; () 및 총 &lt;a href=&quot;qsound#loops&quot;&gt;루프 수&lt;/a&gt; () (즉, 사운드가 재생되는 횟수)를 쿼리 할 수 ​​있습니다 . 반복 횟수는 &lt;a href=&quot;qsound#setLoops&quot;&gt;setLoops&lt;/a&gt; () 함수를 사용하여 변경할 수 있습니다 . 사운드를 재생하는 동안 &lt;a href=&quot;qsound#loopsRemaining&quot;&gt;loopsRemaining&lt;/a&gt; () 함수는 나머지 반복 횟수를 반환합니다. 사용 &lt;a href=&quot;qsound#isFinished&quot;&gt;isFinished&lt;/a&gt; 소리가 재생 완료가 있는지 여부를 결정하기 위해 () 함수를.</target>
        </trans-unit>
        <trans-unit id="d75befe952fa6e9f45d4c3c951b495caa0b7ba79" translate="yes" xml:space="preserve">
          <source>Once created a QSound object can be queried for its &lt;a href=&quot;qsound#fileName&quot;&gt;fileName&lt;/a&gt;() and total number of &lt;a href=&quot;qsound#loops&quot;&gt;loops&lt;/a&gt;() (i.e. the number of times the sound will play). The number of repetitions can be altered using the &lt;a href=&quot;qsound#setLoops&quot;&gt;setLoops&lt;/a&gt;() function. While playing the sound, the &lt;a href=&quot;qsound#loopsRemaining&quot;&gt;loopsRemaining&lt;/a&gt;() function returns the remaining number of repetitions. Use the &lt;a href=&quot;qsound#isFinished&quot;&gt;isFinished&lt;/a&gt;() function to determine whether the sound has finished playing.</source>
          <target state="translated">Once created a QSound object can be queried for its &lt;a href=&quot;qsound#fileName&quot;&gt;fileName&lt;/a&gt;() and total number of &lt;a href=&quot;qsound#loops&quot;&gt;loops&lt;/a&gt;() (i.e. the number of times the sound will play). The number of repetitions can be altered using the &lt;a href=&quot;qsound#setLoops&quot;&gt;setLoops&lt;/a&gt;() function. While playing the sound, the &lt;a href=&quot;qsound#loopsRemaining&quot;&gt;loopsRemaining&lt;/a&gt;() function returns the remaining number of repetitions. Use the &lt;a href=&quot;qsound#isFinished&quot;&gt;isFinished&lt;/a&gt;() function to determine whether the sound has finished playing.</target>
        </trans-unit>
        <trans-unit id="a80eaeebd004cac4f94cd86d98f54dd28509f27b" translate="yes" xml:space="preserve">
          <source>Once created, &lt;a href=&quot;qvideofilterrunnable&quot;&gt;QVideoFilterRunnable&lt;/a&gt; instances are managed by Qt Multimedia and will be automatically destroyed and recreated when necessary, for example when the scene graph is invalidated or the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; changes or is closed. Creation happens via the &lt;a href=&quot;qabstractvideofilter#createFilterRunnable&quot;&gt;QAbstractVideoFilter::createFilterRunnable&lt;/a&gt;() factory function.</source>
          <target state="translated">일단 생성 된 &lt;a href=&quot;qvideofilterrunnable&quot;&gt;QVideoFilterRunnable&lt;/a&gt; 인스턴스는 Qt Multimedia에 의해 관리되며 필요에 따라 (예 : 장면 그래프가 무효화되거나 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow가&lt;/a&gt; 변경되거나 닫히는 경우) 자동으로 삭제되고 다시 생성됩니다 . 생성은 &lt;a href=&quot;qabstractvideofilter#createFilterRunnable&quot;&gt;QAbstractVideoFilter :: createFilterRunnable&lt;/a&gt; () 팩토리 함수 를 통해 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="90e9e520f8e108e89973fd36b6533fc5acffc187" translate="yes" xml:space="preserve">
          <source>Once created, QVideoFilterRunnable instances are managed by Qt Multimedia and will be automatically destroyed and recreated when necessary, for example when the scene graph is invalidated or the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; changes or is closed. Creation happens via the &lt;a href=&quot;qabstractvideofilter#createFilterRunnable&quot;&gt;QAbstractVideoFilter::createFilterRunnable&lt;/a&gt;() factory function.</source>
          <target state="translated">Once created, QVideoFilterRunnable instances are managed by Qt Multimedia and will be automatically destroyed and recreated when necessary, for example when the scene graph is invalidated or the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; changes or is closed. Creation happens via the &lt;a href=&quot;qabstractvideofilter#createFilterRunnable&quot;&gt;QAbstractVideoFilter::createFilterRunnable&lt;/a&gt;() factory function.</target>
        </trans-unit>
        <trans-unit id="cd5e2fb5148480d8fcfc9bd868cceb10c5f8a778" translate="yes" xml:space="preserve">
          <source>Once created, the object provides functions to access the individual metrics of the font, its characters, and for strings rendered in the font.</source>
          <target state="translated">생성 된 객체는 글꼴, 해당 문자 및 글꼴로 렌더링 된 문자열의 개별 메트릭에 액세스하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1340e8fa34d48e4b5e320a1558f7bb4ee5e8ed98" translate="yes" xml:space="preserve">
          <source>Once created, the properties of a menu can be accessed using the &lt;a href=&quot;designer-widget-mode#the-property-editor&quot;&gt;Property Editor&lt;/a&gt;, and each menu can be accessed for this purpose via the &lt;a href=&quot;designer-widget-mode#the-object-inspector&quot;&gt;The Object Inspector&lt;/a&gt;.</source>
          <target state="translated">일단 생성되면 메뉴의 속성은 &lt;a href=&quot;designer-widget-mode#the-property-editor&quot;&gt;속성 편집기를&lt;/a&gt; 사용하여 액세스 할 수 있으며 , 각 메뉴는이 목적으로 &lt;a href=&quot;designer-widget-mode#the-object-inspector&quot;&gt;Object Inspector&lt;/a&gt; 를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4318286cc00389860c860891593d046999063bf7" translate="yes" xml:space="preserve">
          <source>Once created, timer queries can be issued in one of several ways. The simplest method is to delimit a block of commands with calls to &lt;a href=&quot;qopengltimerquery#begin&quot;&gt;begin&lt;/a&gt;() and &lt;a href=&quot;qopengltimerquery#end&quot;&gt;end&lt;/a&gt;(). This instructs OpenGL to measure the time taken from completing all commands issued prior to &lt;a href=&quot;qopengltimerquery#begin&quot;&gt;begin&lt;/a&gt;() until the completion of all commands issued prior to &lt;a href=&quot;qopengltimerquery#end&quot;&gt;end&lt;/a&gt;().</source>
          <target state="translated">일단 타이머 쿼리는 여러 가지 방법 중 하나로 발행 될 수 있습니다. 가장 간단한 방법은 &lt;a href=&quot;qopengltimerquery#begin&quot;&gt;시작&lt;/a&gt; () 및 &lt;a href=&quot;qopengltimerquery#end&quot;&gt;종료&lt;/a&gt; () 호출로 명령 블록을 구분하는 것 입니다. 이것은 이전에 발행 된 모든 명령 완료까지의 시간을 측정하기 위해 OpenGL을 지시 &lt;a href=&quot;qopengltimerquery#begin&quot;&gt;시작&lt;/a&gt; 이전에 발행 된 모든 명령이 완료 될 때까지 (를) &lt;a href=&quot;qopengltimerquery#end&quot;&gt;종료&lt;/a&gt; ()를.</target>
        </trans-unit>
        <trans-unit id="3563861d604d9a741f2f3133b5b1fd396a55a5de" translate="yes" xml:space="preserve">
          <source>Once disconnected, calling &lt;a href=&quot;qdbusconnection#connectToBus&quot;&gt;connectToBus&lt;/a&gt;() will not reestablish a connection, you must create a new &lt;a href=&quot;qdbusconnection&quot;&gt;QDBusConnection&lt;/a&gt; instance.</source>
          <target state="translated">연결이 해제되면 &lt;a href=&quot;qdbusconnection#connectToBus&quot;&gt;connectToBus&lt;/a&gt; ()를 호출 해도 연결이 다시 설정되지 않으므로 새 &lt;a href=&quot;qdbusconnection&quot;&gt;QDBusConnection&lt;/a&gt; 인스턴스를 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7f10a3fd1de6e8469321a24bbb5dede1b4a5c772" translate="yes" xml:space="preserve">
          <source>Once disconnected, calling &lt;a href=&quot;qdbusconnection#connectToBus&quot;&gt;connectToBus&lt;/a&gt;() will not reestablish a connection, you must create a new QDBusConnection instance.</source>
          <target state="translated">Once disconnected, calling &lt;a href=&quot;qdbusconnection#connectToBus&quot;&gt;connectToBus&lt;/a&gt;() will not reestablish a connection, you must create a new QDBusConnection instance.</target>
        </trans-unit>
        <trans-unit id="0a771404be80a49f1bcd8129102f800ceae68ca3" translate="yes" xml:space="preserve">
          <source>Once enabled, applications have two typical choices to perform offscreen rendering in headless mode:</source>
          <target state="translated">활성화 된 응용 프로그램은 헤드리스 모드에서 오프 스크린 렌더링을 수행하기위한 두 가지 일반적인 선택 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="af11aa38925611d44c0c3134bc9e277087c165b5" translate="yes" xml:space="preserve">
          <source>Once encrypted, you use &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; as a regular &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;. When &lt;a href=&quot;qiodevice#readyRead&quot;&gt;readyRead&lt;/a&gt;() is emitted, you can call &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt;(), &lt;a href=&quot;qsslsocket#canReadLine&quot;&gt;canReadLine&lt;/a&gt;() and &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt;(), or &lt;a href=&quot;qiodevice#getChar&quot;&gt;getChar&lt;/a&gt;() to read decrypted data from &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt;'s internal buffer, and you can call &lt;a href=&quot;qiodevice#write&quot;&gt;write&lt;/a&gt;() or &lt;a href=&quot;qiodevice#putChar&quot;&gt;putChar&lt;/a&gt;() to write data back to the peer. &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; will automatically encrypt the written data for you, and emit &lt;a href=&quot;qsslsocket#encryptedBytesWritten&quot;&gt;encryptedBytesWritten&lt;/a&gt;() once the data has been written to the peer.</source>
          <target state="translated">암호화되면 &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 을 일반 &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket으로 사용&lt;/a&gt; 합니다. &lt;a href=&quot;qiodevice#readyRead&quot;&gt;readyRead&lt;/a&gt; ()가 생성 되면 &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt; (), &lt;a href=&quot;qsslsocket#canReadLine&quot;&gt;canReadLine&lt;/a&gt; () 및 &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt; () 또는 &lt;a href=&quot;qiodevice#getChar&quot;&gt;getChar&lt;/a&gt; ()를 호출 하여 &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 의 내부 버퍼 에서 해독 된 데이터를 읽고 &lt;a href=&quot;qiodevice#write&quot;&gt;write&lt;/a&gt; () 또는 &lt;a href=&quot;qiodevice#putChar&quot;&gt;putChar&lt;/a&gt; ()를 호출 하여 쓸 수 있습니다. 피어에게 데이터를 다시 보냅니다. &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 은 작성된 데이터를 자동으로 암호화하고 데이터가 피어에 쓰여지면 &lt;a href=&quot;qsslsocket#encryptedBytesWritten&quot;&gt;encryptedBytesWritten&lt;/a&gt; ()을 방출 합니다.</target>
        </trans-unit>
        <trans-unit id="524296a6b17edcdcde8b7d9d05a0f6ae76f3770d" translate="yes" xml:space="preserve">
          <source>Once encrypted, you use QSslSocket as a regular &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;. When &lt;a href=&quot;qiodevice#readyRead&quot;&gt;readyRead&lt;/a&gt;() is emitted, you can call &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt;(), &lt;a href=&quot;qsslsocket#canReadLine&quot;&gt;canReadLine&lt;/a&gt;() and &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt;(), or &lt;a href=&quot;qiodevice#getChar&quot;&gt;getChar&lt;/a&gt;() to read decrypted data from QSslSocket's internal buffer, and you can call &lt;a href=&quot;qiodevice#write&quot;&gt;write&lt;/a&gt;() or &lt;a href=&quot;qiodevice#putChar&quot;&gt;putChar&lt;/a&gt;() to write data back to the peer. QSslSocket will automatically encrypt the written data for you, and emit &lt;a href=&quot;qsslsocket#encryptedBytesWritten&quot;&gt;encryptedBytesWritten&lt;/a&gt;() once the data has been written to the peer.</source>
          <target state="translated">Once encrypted, you use QSslSocket as a regular &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;. When &lt;a href=&quot;qiodevice#readyRead&quot;&gt;readyRead&lt;/a&gt;() is emitted, you can call &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt;(), &lt;a href=&quot;qsslsocket#canReadLine&quot;&gt;canReadLine&lt;/a&gt;() and &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt;(), or &lt;a href=&quot;qiodevice#getChar&quot;&gt;getChar&lt;/a&gt;() to read decrypted data from QSslSocket's internal buffer, and you can call &lt;a href=&quot;qiodevice#write&quot;&gt;write&lt;/a&gt;() or &lt;a href=&quot;qiodevice#putChar&quot;&gt;putChar&lt;/a&gt;() to write data back to the peer. QSslSocket will automatically encrypt the written data for you, and emit &lt;a href=&quot;qsslsocket#encryptedBytesWritten&quot;&gt;encryptedBytesWritten&lt;/a&gt;() once the data has been written to the peer.</target>
        </trans-unit>
        <trans-unit id="47fd7e76dcd700654b875f9d31d09a0ed43c1e0f" translate="yes" xml:space="preserve">
          <source>Once individual animations are placed into a &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-parallelanimation&quot;&gt;ParallelAnimation&lt;/a&gt;, they can no longer be started and stopped independently. The sequential or parallel animation must be started and stopped as a group.</source>
          <target state="translated">개별 애니메이션을 &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-parallelanimation&quot;&gt;ParallelAnimation에&lt;/a&gt; 배치하면 더 이상 독립적으로 시작 및 중지 할 수 없습니다. 순차적 또는 병렬 애니메이션은 그룹으로 시작하고 중지해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7065d1862b32bf508458b0290a47c13567e0119" translate="yes" xml:space="preserve">
          <source>Once invalidate() has been called, it is possible to reuse the &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt; instance by calling &lt;a href=&quot;qquickrendercontrol#initialize&quot;&gt;initialize&lt;/a&gt;() again.</source>
          <target state="translated">invalidate ()가 호출되면 &lt;a href=&quot;qquickrendercontrol#initialize&quot;&gt;initialize&lt;/a&gt; ()를 다시 호출 하여 &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt; 인스턴스 를 재사용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a86569ce76e4c0379ce20067c838e075579f2bf0" translate="yes" xml:space="preserve">
          <source>Once loaded, plugins remain in memory until all instances of &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; has been unloaded, or until the application terminates. You can attempt to unload a plugin using &lt;a href=&quot;qpluginloader#unload&quot;&gt;unload&lt;/a&gt;(), but if other instances of &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; are using the same library, the call will fail, and unloading will only happen when every instance has called &lt;a href=&quot;qpluginloader#unload&quot;&gt;unload&lt;/a&gt;(). Right before the unloading happens, the root component will also be deleted.</source>
          <target state="translated">일단로드되면 플러그인은 &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader의&lt;/a&gt; 모든 인스턴스 가 언로드 될 때까지 또는 응용 프로그램이 종료 될 때까지 메모리에 남아 있습니다 . &lt;a href=&quot;qpluginloader#unload&quot;&gt;unload&lt;/a&gt; ()를 사용하여 플러그인 언로드를 시도 할 수 있지만 &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader의&lt;/a&gt; 다른 인스턴스가 동일한 라이브러리를 사용하는 경우 호출이 실패하며 언로드는 모든 인스턴스가 &lt;a href=&quot;qpluginloader#unload&quot;&gt;unload&lt;/a&gt; ()를 호출 한 경우에만 발생 합니다. 언로드가 발생하기 직전에 루트 구성 요소도 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="d6ed3cb72b2e312789ec57318a1cb6fc7e9e81c8" translate="yes" xml:space="preserve">
          <source>Once loaded, plugins remain in memory until all instances of QPluginLoader has been unloaded, or until the application terminates. You can attempt to unload a plugin using &lt;a href=&quot;qpluginloader#unload&quot;&gt;unload&lt;/a&gt;(), but if other instances of QPluginLoader are using the same library, the call will fail, and unloading will only happen when every instance has called &lt;a href=&quot;qpluginloader#unload&quot;&gt;unload&lt;/a&gt;(). Right before the unloading happens, the root component will also be deleted.</source>
          <target state="translated">Once loaded, plugins remain in memory until all instances of QPluginLoader has been unloaded, or until the application terminates. You can attempt to unload a plugin using &lt;a href=&quot;qpluginloader#unload&quot;&gt;unload&lt;/a&gt;(), but if other instances of QPluginLoader are using the same library, the call will fail, and unloading will only happen when every instance has called &lt;a href=&quot;qpluginloader#unload&quot;&gt;unload&lt;/a&gt;(). Right before the unloading happens, the root component will also be deleted.</target>
        </trans-unit>
        <trans-unit id="4fc26d0a14582bafdc9354c84ba528981f69fdec" translate="yes" xml:space="preserve">
          <source>Once opaque primitives have been drawn, the renderer will disable &lt;code&gt;glDepthMask&lt;/code&gt;, enable &lt;code&gt;GL_BLEND&lt;/code&gt; and render all alpha blended primitives in a back-to-front manner.</source>
          <target state="translated">불투명 프리미티브가 그려지면 렌더러는 &lt;code&gt;glDepthMask&lt;/code&gt; 를 비활성화하고 GL_BLEND 를 활성화 &lt;code&gt;GL_BLEND&lt;/code&gt; 모든 알파 블렌드 프리미티브를 연속적인 방식으로 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="b9db82184c27bdceb25bd1b08e3b5517bb8c8615" translate="yes" xml:space="preserve">
          <source>Once positioned, sub-controls can be styled using the &lt;a href=&quot;#box-model&quot;&gt;box model&lt;/a&gt;.</source>
          <target state="translated">일단 배치되면 &lt;a href=&quot;#box-model&quot;&gt;상자 모델을&lt;/a&gt; 사용하여 하위 제어를 스타일 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="484b85ea705b1bd2325d91eb3cedad5857196062" translate="yes" xml:space="preserve">
          <source>Once positioned, sub-controls can be styled using the &lt;a href=&quot;stylesheet-customizing#box-model&quot;&gt;box model&lt;/a&gt;.</source>
          <target state="translated">Once positioned, sub-controls can be styled using the &lt;a href=&quot;stylesheet-customizing#box-model&quot;&gt;box model&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="e44aa1cb73bede9c422aed8bc491a71274d8dc04" translate="yes" xml:space="preserve">
          <source>Once positioned, they are treated the same as widgets and can be styled using the &lt;a href=&quot;stylesheet-customizing#box-model&quot;&gt;box model&lt;/a&gt;.</source>
          <target state="translated">일단 배치되면 위젯과 동일하게 취급되며 &lt;a href=&quot;stylesheet-customizing#box-model&quot;&gt;상자 모델을&lt;/a&gt; 사용하여 스타일을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="011ec39e07e233ee8b7dbb26cded772667837811" translate="yes" xml:space="preserve">
          <source>Once registered, a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; singleton type may be imported and used like any other &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; instance exposed to QML. The following example assumes that a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; singleton type was registered into the &quot;MyThemeModule&quot; namespace with version 1.0, where that &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; has a &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; &quot;color&quot; &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt;:</source>
          <target state="translated">일단 등록되면 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 싱글 톤 유형을 가져 와서 QML에 노출 된 다른 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 인스턴스 와 같이 사용할 수 있습니다 . 다음 예제에서는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 싱글 톤 유형이 버전 1.0으로 &quot;MyThemeModule&quot;네임 스페이스에 등록 되었다고 가정합니다. 여기서 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 에는 &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; &quot;color&quot; &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY가 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f212ed18637128978ee635a7f85b1291a909b355" translate="yes" xml:space="preserve">
          <source>Once registered, a type can be used in outgoing method calls (placed with &lt;a href=&quot;qdbusabstractinterface#call&quot;&gt;QDBusAbstractInterface::call&lt;/a&gt;()), signal emissions from registered objects or in incoming calls from remote applications.</source>
          <target state="translated">등록 된 유형은 발신 메소드 호출 ( &lt;a href=&quot;qdbusabstractinterface#call&quot;&gt;QDBusAbstractInterface :: call&lt;/a&gt; ()로 배치 ), 등록 된 객체의 신호 방출 또는 원격 애플리케이션의 수신 호출에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="706ea40b430397571f95b08454d9fda927d95a54" translate="yes" xml:space="preserve">
          <source>Once registered, a type can be used in outgoing method calls (placed with &lt;a href=&quot;qdbusabstractinterface#call-1&quot;&gt;QDBusAbstractInterface::call&lt;/a&gt;()), signal emissions from registered objects or in incoming calls from remote applications.</source>
          <target state="translated">Once registered, a type can be used in outgoing method calls (placed with &lt;a href=&quot;qdbusabstractinterface#call-1&quot;&gt;QDBusAbstractInterface::call&lt;/a&gt;()), signal emissions from registered objects or in incoming calls from remote applications.</target>
        </trans-unit>
        <trans-unit id="76fdb923b97b3639512618d76df193ba658ae763" translate="yes" xml:space="preserve">
          <source>Once registered, all signals and property changes are automatically propagated to the clients. Public invokable methods, including slots, are also accessible to the clients.</source>
          <target state="translated">등록되면 모든 신호 및 속성 변경 사항이 클라이언트에 자동으로 전파됩니다. 슬롯을 포함한 공개 호출 가능 메소드도 클라이언트가 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2af748be4364a6f16ee59c52d59a11b686fe9cc1" translate="yes" xml:space="preserve">
          <source>Once registered, the type can be used in QML by importing the same type namespace and version number:</source>
          <target state="translated">Once registered, the type can be used in QML by importing the same type namespace and version number:</target>
        </trans-unit>
        <trans-unit id="88b7ecce84bef0c2b0872f0d6adfa7fbba28ea6b" translate="yes" xml:space="preserve">
          <source>Once simpleEffect is available, it can be associated with the effects list of a the &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt;'s &lt;a href=&quot;qml-qtquick3d-sceneenvironment&quot;&gt;SceneEnvironment&lt;/a&gt;:</source>
          <target state="translated">simpleEffect가 사용할 수있게되면, 그것은의 효과 목록과 연관 될 수 &lt;a href=&quot;qml-qtquick3d-view3d&quot;&gt;View3D&lt;/a&gt; 의 &lt;a href=&quot;qml-qtquick3d-sceneenvironment&quot;&gt;SceneEnvironment&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="9b2acb02284decccb2539c681f480973c653d7a5" translate="yes" xml:space="preserve">
          <source>Once storage has been allocated for the texture then pixel data can be uploaded via one of the &lt;a href=&quot;qopengltexture#setData&quot;&gt;setData&lt;/a&gt;() overloads.</source>
          <target state="translated">텍스처에 스토리지가 할당되면 &lt;a href=&quot;qopengltexture#setData&quot;&gt;setData&lt;/a&gt; () 오버로드 중 하나를 통해 픽셀 데이터를 업로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4066d6598bee2916f9c3b08e94545af3dd0223ef" translate="yes" xml:space="preserve">
          <source>Once storage has been allocated it is no longer possible to change these properties.</source>
          <target state="translated">스토리지가 할당되면 더 이상 이러한 속성을 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf5fd6231cbbc871a1f444bb695dec4a43eaab55" translate="yes" xml:space="preserve">
          <source>Once the &lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase&lt;/a&gt; object has been created, set the connection parameters with &lt;a href=&quot;qsqldatabase#setDatabaseName&quot;&gt;setDatabaseName&lt;/a&gt;(), &lt;a href=&quot;qsqldatabase#setUserName&quot;&gt;setUserName&lt;/a&gt;(), &lt;a href=&quot;qsqldatabase#setPassword&quot;&gt;setPassword&lt;/a&gt;(), &lt;a href=&quot;qsqldatabase#setHostName&quot;&gt;setHostName&lt;/a&gt;(), &lt;a href=&quot;qsqldatabase#setPort&quot;&gt;setPort&lt;/a&gt;(), and &lt;a href=&quot;qsqldatabase#setConnectOptions&quot;&gt;setConnectOptions&lt;/a&gt;(). Then call &lt;a href=&quot;qsqldatabase#open&quot;&gt;open&lt;/a&gt;() to activate the physical connection to the database. The connection is not usable until you open it.</source>
          <target state="translated">일단 &lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase의&lt;/a&gt; 객체가 생성되어, 함께 연결 매개 변수를 설정 &lt;a href=&quot;qsqldatabase#setDatabaseName&quot;&gt;하는 setDataBaseName&lt;/a&gt; () &lt;a href=&quot;qsqldatabase#setUserName&quot;&gt;setUserName&lt;/a&gt; () &lt;a href=&quot;qsqldatabase#setPassword&quot;&gt;SETPASSWORD&lt;/a&gt; () &lt;a href=&quot;qsqldatabase#setHostName&quot;&gt;sethostname시&lt;/a&gt; () &lt;a href=&quot;qsqldatabase#setPort&quot;&gt;setPort&lt;/a&gt; () 및 &lt;a href=&quot;qsqldatabase#setConnectOptions&quot;&gt;setConnectOptions&lt;/a&gt; (). 그런 다음 &lt;a href=&quot;qsqldatabase#open&quot;&gt;open&lt;/a&gt; ()을 호출 하여 데이터베이스에 대한 물리적 연결을 활성화하십시오. 연결을 열 때까지 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d693e653a5aefa95f90913cd528053a2853d850b" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;RandomNumberGenerator&lt;/code&gt; class has been registered with the QML type system, it can be used from QML as a property value source. Below, it is used to change the width of a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; every 500 milliseconds:</source>
          <target state="translated">일단 &lt;code&gt;RandomNumberGenerator&lt;/code&gt; 의 클래스가 QML 형 시스템에 등록되어,이를 속성 값 소스로 QML에서 사용될 수있다. 아래에서는 500 밀리 초마다 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;사각형&lt;/a&gt; 의 너비를 변경하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc4e61b0e31d8ea0efe7e1ce13e7532a4eec072f" translate="yes" xml:space="preserve">
          <source>Once the HTML documents are in place, a &lt;a href=&quot;qthelpproject&quot;&gt;Qt Help Project&lt;/a&gt; file, with an extension of &lt;code&gt;.qhp&lt;/code&gt;, has to be created. After specifying all the relevant information in this file, it needs to be compiled by calling:</source>
          <target state="translated">Once the HTML documents are in place, a &lt;a href=&quot;qthelpproject&quot;&gt;Qt Help Project&lt;/a&gt; file, with an extension of &lt;code&gt;.qhp&lt;/code&gt; , has to be created. After specifying all the relevant information in this file, it needs to be compiled by calling:</target>
        </trans-unit>
        <trans-unit id="56ae2c1e1c709d43479f94e48c10b97999f58390" translate="yes" xml:space="preserve">
          <source>Once the HTML documents are in place, a &lt;a href=&quot;qthelpproject#&quot;&gt;Qt Help Project&lt;/a&gt; file, with an extension of &lt;code&gt;.qhp&lt;/code&gt;, has to be created. After specifying all the relevant information in this file, it needs to be compiled by calling:</source>
          <target state="translated">HTML 문서가 &lt;code&gt;.qhp&lt;/code&gt; 되면 확장자가 .qhp 인 &lt;a href=&quot;qthelpproject#&quot;&gt;Qt 도움말 프로젝트&lt;/a&gt; 파일 을 작성해야합니다. 이 파일에 모든 관련 정보를 지정한 후 다음을 호출하여 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="550dc13bcc47d73cb367af625b17c1f72d056570" translate="yes" xml:space="preserve">
          <source>Once the QSqlDatabase object has been created, set the connection parameters with &lt;a href=&quot;qsqldatabase#setDatabaseName&quot;&gt;setDatabaseName&lt;/a&gt;(), &lt;a href=&quot;qsqldatabase#setUserName&quot;&gt;setUserName&lt;/a&gt;(), &lt;a href=&quot;qsqldatabase#setPassword&quot;&gt;setPassword&lt;/a&gt;(), &lt;a href=&quot;qsqldatabase#setHostName&quot;&gt;setHostName&lt;/a&gt;(), &lt;a href=&quot;qsqldatabase#setPort&quot;&gt;setPort&lt;/a&gt;(), and &lt;a href=&quot;qsqldatabase#setConnectOptions&quot;&gt;setConnectOptions&lt;/a&gt;(). Then call &lt;a href=&quot;qsqldatabase#open&quot;&gt;open&lt;/a&gt;() to activate the physical connection to the database. The connection is not usable until you open it.</source>
          <target state="translated">Once the QSqlDatabase object has been created, set the connection parameters with &lt;a href=&quot;qsqldatabase#setDatabaseName&quot;&gt;setDatabaseName&lt;/a&gt;(), &lt;a href=&quot;qsqldatabase#setUserName&quot;&gt;setUserName&lt;/a&gt;(), &lt;a href=&quot;qsqldatabase#setPassword&quot;&gt;setPassword&lt;/a&gt;(), &lt;a href=&quot;qsqldatabase#setHostName&quot;&gt;setHostName&lt;/a&gt;(), &lt;a href=&quot;qsqldatabase#setPort&quot;&gt;setPort&lt;/a&gt;(), and &lt;a href=&quot;qsqldatabase#setConnectOptions&quot;&gt;setConnectOptions&lt;/a&gt;(). Then call &lt;a href=&quot;qsqldatabase#open&quot;&gt;open&lt;/a&gt;() to activate the physical connection to the database. The connection is not usable until you open it.</target>
        </trans-unit>
        <trans-unit id="4b0109c40367a76a7f8e8bd52850331515ed5a56" translate="yes" xml:space="preserve">
          <source>Once the Qt build is done and installed to the staging location, examples or applications can be built.</source>
          <target state="translated">Qt 빌드가 완료되고 스테이징 위치에 설치되면 예제 또는 애플리케이션을 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bb5a703a85da112bfdfb22564c6b753fb342d2b" translate="yes" xml:space="preserve">
          <source>Once the action is created, it can be used wherever actions are applicable.</source>
          <target state="translated">조치가 작성되면 조치가 적용 가능한 모든 위치에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1f4caca220052a1d05453a5cf60436aa66ce30c" translate="yes" xml:space="preserve">
          <source>Once the animation clip has been populated with data using the above methods, the read-only duration property will be updated by the Qt 3D Animation backend.</source>
          <target state="translated">위의 방법을 사용하여 애니메이션 클립에 데이터가 채워지면 Qt 3D 애니메이션 백엔드에 의해 읽기 전용 지속 시간 속성이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="205b5c208dd11021e42c1f0cb029c8ea2f565ea8" translate="yes" xml:space="preserve">
          <source>Once the application is prepared for publishing, you can create a listing for it in Google Play.</source>
          <target state="translated">애플리케이션을 게시 할 준비가되면 Google Play에서 목록을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea0b767aded5ed6d7f67a23165e680f703e3eddf" translate="yes" xml:space="preserve">
          <source>Once the callback passed to the &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; object is invoked, the channel has finished initialization and all published objects are accessible to the HTML client via the &lt;code&gt;channel.objects&lt;/code&gt; property. Thus, assuming an object was published with the identifier &quot;foo&quot;, then we can interact with it as shown in the example below. Note that all communication between the HTML client and the QML/C++ server is asynchronous. Properties are cached on the HTML side. Furthermore keep in mind that only QML/C++ data types which can be converted to JSON will be (de-)serialized properly and thus accessible to HTML clients.</source>
          <target state="translated">&lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; 객체로 전달 된 콜백 이 호출되면 채널 초기화가 완료되고 게시 된 모든 객체는 &lt;code&gt;channel.objects&lt;/code&gt; 속성을 통해 HTML 클라이언트에 액세스 할 수 있습니다. 따라서 개체가 식별자 &quot;foo&quot;로 게시되었다고 가정하면 아래 예와 같이 해당 개체와 상호 작용할 수 있습니다. HTML 클라이언트와 QML / C ++ 서버 간의 모든 통신은 비동기 적입니다. 속성은 HTML 측에 캐시됩니다. 또한 JSON으로 변환 할 수있는 QML / C ++ 데이터 유형 만 올바르게 직렬화 해제되어 HTML 클라이언트가 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4870e02dd16024ea585e0185e39f0f403481f28d" translate="yes" xml:space="preserve">
          <source>Once the character format has been used with a cursor, that format becomes the default format for any text inserted with that cursor until another character format is specified.</source>
          <target state="translated">문자 형식을 커서와 함께 사용하면 해당 문자 형식은 다른 문자 형식이 지정 될 때까지 해당 커서로 삽입 된 텍스트의 기본 형식이됩니다.</target>
        </trans-unit>
        <trans-unit id="496af005595ecb484db08b997602438633276ba2" translate="yes" xml:space="preserve">
          <source>Once the component cache has been cleared, components must be loaded before any new objects can be created.</source>
          <target state="translated">구성 요소 캐시가 지워지면 새 오브젝트를 작성하기 전에 구성 요소를로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="d478d6665153cbfa2af22f055007c65ef12929ba" translate="yes" xml:space="preserve">
          <source>Once the image is ready, &lt;a href=&quot;qml-qtquick-canvas#imageLoaded-signal&quot;&gt;imageLoaded()&lt;/a&gt; signal will be emitted. The loaded image can be unloaded with the &lt;a href=&quot;qml-qtquick-canvas#unloadImage-method&quot;&gt;unloadImage()&lt;/a&gt; method.</source>
          <target state="translated">Once the image is ready, &lt;a href=&quot;qml-qtquick-canvas#imageLoaded-signal&quot;&gt;imageLoaded()&lt;/a&gt; signal will be emitted. The loaded image can be unloaded with the &lt;a href=&quot;qml-qtquick-canvas#unloadImage-method&quot;&gt;unloadImage()&lt;/a&gt; method.</target>
        </trans-unit>
        <trans-unit id="bc50afa14e96afab3d5b302b5c8574825cc0c758" translate="yes" xml:space="preserve">
          <source>Once the implementation is done, the class needs to be registered to make it visible in QML</source>
          <target state="translated">구현이 완료되면 QML에서 볼 수 있도록 클래스를 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="c23878cf26f59a37f5b55e0c5b866fe62d4c572e" translate="yes" xml:space="preserve">
          <source>Once the items have been successfully registered in the store, you can purchase them. Get the previously registered &lt;a href=&quot;qinappproduct&quot;&gt;QInAppProduct&lt;/a&gt; using &lt;a href=&quot;qinappstore#registeredProduct&quot;&gt;registeredProduct&lt;/a&gt;() and call &lt;a href=&quot;qinappproduct#purchase&quot;&gt;QInAppProduct::purchase&lt;/a&gt;(). This call is also asynchronous.</source>
          <target state="translated">상품이 상점에 등록되면 구입할 수 있습니다. &lt;a href=&quot;qinappstore#registeredProduct&quot;&gt;registeredProduct&lt;/a&gt; ()를 사용하여 이전에 등록 된 &lt;a href=&quot;qinappproduct&quot;&gt;QInAppProduct&lt;/a&gt; 를 &lt;a href=&quot;qinappproduct#purchase&quot;&gt;가져오고 QInAppProduct :: purchase&lt;/a&gt; ()를 호출 하십시오 . 이 호출은 또한 비동기 적입니다.</target>
        </trans-unit>
        <trans-unit id="b5dda2fa2d7123529d9fd69fe7226be909e75bed" translate="yes" xml:space="preserve">
          <source>Once the machine is started, we can post events to it.</source>
          <target state="translated">머신이 시작되면 이벤트를 게시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f87051ba877349a528b632247c69a275e5b35131" translate="yes" xml:space="preserve">
          <source>Once the manifest is added to your project, you can modify it. The most important parts are the application name and the package name. The package name must be unique, and it is recommended to follow the com.mycompany.myappname naming convention. The &quot;com.mycompany&quot; namespace is based on the Internet domain ownership to avoid naming collisions with other applications.</source>
          <target state="translated">매니페스트가 프로젝트에 추가되면 수정할 수 있습니다. 가장 중요한 부분은 응용 프로그램 이름과 패키지 이름입니다. 패키지 이름은 고유해야하며 com.mycompany.myappname 이름 지정 규칙을 따르는 것이 좋습니다. &quot;com.mycompany&quot;네임 스페이스는 다른 응용 프로그램과의 이름 충돌을 피하기 위해 인터넷 도메인 소유권을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="f521cefaaba3fda658fcaf0b5cd9bc12020db606" translate="yes" xml:space="preserve">
          <source>Once the numerical segments have been parsed, the remainder of the string is considered to be the suffix string. The start index of that string will be stored in</source>
          <target state="translated">숫자 세그먼트가 구문 분석되면 나머지 문자열은 접미사 문자열로 간주됩니다. 해당 문자열의 시작 색인은</target>
        </trans-unit>
        <trans-unit id="f1302f6bf7bb8a9fd947b5e568d478ba086c5f3a" translate="yes" xml:space="preserve">
          <source>Once the operation has completed, &lt;a href=&quot;qgeocodereply#locations&quot;&gt;QGeoCodeReply::locations&lt;/a&gt;() can be used to retrieve the results, which will consist of a list of &lt;a href=&quot;qgeolocation&quot;&gt;QGeoLocation&lt;/a&gt; objects. These objects represent a combination of coordinate and address data.</source>
          <target state="translated">작업이 완료되면 &lt;a href=&quot;qgeocodereply#locations&quot;&gt;QGeoCodeReply :: locations&lt;/a&gt; ()를 사용하여 결과를 검색 할 수 있으며, &lt;a href=&quot;qgeolocation&quot;&gt;QGeoLocation&lt;/a&gt; 객체 목록으로 구성 됩니다. 이러한 객체는 좌표 및 주소 데이터의 조합을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="01b5acac21beaef0597f322faf8c937236d32d9e" translate="yes" xml:space="preserve">
          <source>Once the operation has completed, &lt;a href=&quot;qgeoroutereply#routes&quot;&gt;QGeoRouteReply::routes&lt;/a&gt; can be used to retrieve the calculated route or routes.</source>
          <target state="translated">작업이 완료되면 &lt;a href=&quot;qgeoroutereply#routes&quot;&gt;QGeoRouteReply :: routes&lt;/a&gt; 를 사용하여 계산 된 경로를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a1009ef434c48bb9be4042007fd562ae5ccb125" translate="yes" xml:space="preserve">
          <source>Once the operation has completed, &lt;a href=&quot;qgeoroutereply#routes&quot;&gt;QGeoRouteReply::routes&lt;/a&gt; can be used to retrieve the updated route.</source>
          <target state="translated">작업이 완료되면 &lt;a href=&quot;qgeoroutereply#routes&quot;&gt;QGeoRouteReply :: routes&lt;/a&gt; 를 사용하여 업데이트 된 경로를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8237d24f440ae3aaa3b7945827ee52601fc76fe" translate="yes" xml:space="preserve">
          <source>Once the plugin is set, create a &lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteQuery&lt;/a&gt; with the appropriate waypoints and other settings, and set the &lt;a href=&quot;qml-qtlocation-routemodel&quot;&gt;RouteModel&lt;/a&gt;'s &lt;a href=&quot;qml-qtlocation-routemodel#query-prop&quot;&gt;query&lt;/a&gt; property. If &lt;a href=&quot;qml-qtlocation-routemodel#autoUpdate-prop&quot;&gt;autoUpdate&lt;/a&gt; is enabled, the update will being automatically. Otherwise, the &lt;a href=&quot;qml-qtlocation-routemodel#update-method&quot;&gt;update&lt;/a&gt; method may be used. By default, &lt;a href=&quot;qml-qtlocation-routemodel#autoUpdate-prop&quot;&gt;autoUpdate&lt;/a&gt; is disabled.</source>
          <target state="translated">플러그인이 설정되면 적절한 웨이 포인트 및 기타 설정 으로 &lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteQuery&lt;/a&gt; 를 생성 하고 &lt;a href=&quot;qml-qtlocation-routemodel&quot;&gt;RouteModel&lt;/a&gt; 의 &lt;a href=&quot;qml-qtlocation-routemodel#query-prop&quot;&gt;쿼리&lt;/a&gt; 속성을 설정하십시오 . 경우 &lt;a href=&quot;qml-qtlocation-routemodel#autoUpdate-prop&quot;&gt;자동 업데이트가&lt;/a&gt; 활성화되어 업데이트가 자동으로되는 것입니다. 그렇지 않으면 &lt;a href=&quot;qml-qtlocation-routemodel#update-method&quot;&gt;업데이트&lt;/a&gt; 방법을 사용할 수 있습니다. 기본적으로 &lt;a href=&quot;qml-qtlocation-routemodel#autoUpdate-prop&quot;&gt;자동 업데이트는&lt;/a&gt; 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="eef2855a47b2cc4af71a18bffd9ce510d7f34242" translate="yes" xml:space="preserve">
          <source>Once the plugin is set, create a &lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteQuery&lt;/a&gt; with the appropriate waypoints and other settings, and set the RouteModel's &lt;a href=&quot;qml-qtlocation-routemodel#query-prop&quot;&gt;query&lt;/a&gt; property. If &lt;a href=&quot;qml-qtlocation-routemodel#autoUpdate-prop&quot;&gt;autoUpdate&lt;/a&gt; is enabled, the update will being automatically. Otherwise, the &lt;a href=&quot;qml-qtlocation-routemodel#update-method&quot;&gt;update&lt;/a&gt; method may be used. By default, &lt;a href=&quot;qml-qtlocation-routemodel#autoUpdate-prop&quot;&gt;autoUpdate&lt;/a&gt; is disabled.</source>
          <target state="translated">Once the plugin is set, create a &lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteQuery&lt;/a&gt; with the appropriate waypoints and other settings, and set the RouteModel's &lt;a href=&quot;qml-qtlocation-routemodel#query-prop&quot;&gt;query&lt;/a&gt; property. If &lt;a href=&quot;qml-qtlocation-routemodel#autoUpdate-prop&quot;&gt;autoUpdate&lt;/a&gt; is enabled, the update will being automatically. Otherwise, the &lt;a href=&quot;qml-qtlocation-routemodel#update-method&quot;&gt;update&lt;/a&gt; method may be used. By default, &lt;a href=&quot;qml-qtlocation-routemodel#autoUpdate-prop&quot;&gt;autoUpdate&lt;/a&gt; is disabled.</target>
        </trans-unit>
        <trans-unit id="2a4a4e9814333870e00d88728fd47606694571eb" translate="yes" xml:space="preserve">
          <source>Once the plugin is set, the &lt;a href=&quot;qml-qtlocation-geocodemodel#query-prop&quot;&gt;query&lt;/a&gt; property can be used to specify the address or search string to match. If &lt;a href=&quot;qml-qtlocation-geocodemodel#autoUpdate-prop&quot;&gt;autoUpdate&lt;/a&gt; is enabled, the Model will update its output automatically. Otherwise, the &lt;a href=&quot;qml-qtlocation-geocodemodel#update-method&quot;&gt;update&lt;/a&gt; method may be used. By default, &lt;a href=&quot;qml-qtlocation-geocodemodel#autoUpdate-prop&quot;&gt;autoUpdate&lt;/a&gt; is disabled.</source>
          <target state="translated">플러그인이 설정되면 &lt;a href=&quot;qml-qtlocation-geocodemodel#query-prop&quot;&gt;검색어&lt;/a&gt; 속성을 사용하여 일치하는 주소 또는 검색 문자열을 지정할 수 있습니다. 경우 &lt;a href=&quot;qml-qtlocation-geocodemodel#autoUpdate-prop&quot;&gt;자동 업데이트가&lt;/a&gt; 활성화되어, 모델은 자동으로 출력을 업데이트합니다. 그렇지 않으면 &lt;a href=&quot;qml-qtlocation-geocodemodel#update-method&quot;&gt;업데이트&lt;/a&gt; 방법을 사용할 수 있습니다. 기본적으로 &lt;a href=&quot;qml-qtlocation-geocodemodel#autoUpdate-prop&quot;&gt;자동 업데이트는&lt;/a&gt; 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="51573a29d91f36ec0e9aa557f5fc03263d8d4e9a" translate="yes" xml:space="preserve">
          <source>Once the project is built and installed, the new &lt;code&gt;Time&lt;/code&gt; component is accessible by any QML component that imports the &lt;code&gt;TimeExample&lt;/code&gt; module</source>
          <target state="translated">프로젝트가 빌드되고 설치되면 &lt;code&gt;TimeExample&lt;/code&gt; 모듈 을 가져 오는 QML 구성 요소가 새 &lt;code&gt;Time&lt;/code&gt; 구성 요소에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d57a67cc01f03463e100ca785c789a48baaefd10" translate="yes" xml:space="preserve">
          <source>Once the rendering is done the pageRendered() signal is emitted with the result as parameters.</source>
          <target state="translated">Once the rendering is done the pageRendered() signal is emitted with the result as parameters.</target>
        </trans-unit>
        <trans-unit id="93b788d9ad88ab09075085e62bbb75e2121a947c" translate="yes" xml:space="preserve">
          <source>Once the request completes successfully the response can be retrieved from the &lt;a href=&quot;qnearfieldtarget#requestResponse&quot;&gt;requestResponse&lt;/a&gt;() function. The response of this request will be a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;.</source>
          <target state="translated">요청이 성공적으로 완료되면 &lt;a href=&quot;qnearfieldtarget#requestResponse&quot;&gt;requestResponse&lt;/a&gt; () 함수 에서 응답을 검색 할 수 있습니다 . 이 요청의 응답은 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b8111f76953cdb0759d595d2a88f5fa509a36db0" translate="yes" xml:space="preserve">
          <source>Once the request completes the response for successfully completed requests can be retrieved from the &lt;a href=&quot;qnearfieldtarget#requestResponse&quot;&gt;requestResponse&lt;/a&gt;() function. The response of this request will be a &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">요청이 완료되면 &lt;a href=&quot;qnearfieldtarget#requestResponse&quot;&gt;requestResponse&lt;/a&gt; () 함수 에서 성공적으로 완료된 요청에 대한 응답을 검색 할 수 있습니다 . 이 요청의 응답은 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; &amp;lt; &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; &amp;gt;입니다.</target>
        </trans-unit>
        <trans-unit id="6dff09d559cd10dbb9244d06b7374557ff114f63" translate="yes" xml:space="preserve">
          <source>Once the request finishes you can handle the results with:</source>
          <target state="translated">요청이 완료되면 다음을 사용하여 결과를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="9675df906f3b4dd39c0f3e7e2d9daa0adf9f201f" translate="yes" xml:space="preserve">
          <source>Once the resources are defined you can use them actively when composing your form. For example, you might want to create a tool button using an icon specified in the resource file.</source>
          <target state="translated">리소스가 정의되면 양식을 작성할 때 적극적으로 사용할 수 있습니다. 예를 들어 리소스 파일에 지정된 아이콘을 사용하여 도구 단추를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cef2ed87f29621407fe223b5c500043ff82db994" translate="yes" xml:space="preserve">
          <source>Once the texture object is created you can obtain the object name from the &lt;a href=&quot;qopengltexture#textureId&quot;&gt;textureId&lt;/a&gt;() function. This may be useful if you wish to make some raw OpenGL calls related to this texture.</source>
          <target state="translated">텍스처 오브젝트가 생성되면 &lt;a href=&quot;qopengltexture#textureId&quot;&gt;textureId&lt;/a&gt; () 함수 에서 오브젝트 이름을 얻을 수 있습니다 . 이 텍스처와 관련된 원시 OpenGL 호출을 원할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a854609fbf0cc0561a8527b2bba9a2242f014e3e" translate="yes" xml:space="preserve">
          <source>Once the window has been embedded into the container, the container will control the window's geometry and visibility. Explicit calls to &lt;a href=&quot;qwindow#setGeometry&quot;&gt;QWindow::setGeometry&lt;/a&gt;(), &lt;a href=&quot;qwindow#show&quot;&gt;QWindow::show&lt;/a&gt;() or &lt;a href=&quot;qwindow#hide&quot;&gt;QWindow::hide&lt;/a&gt;() on an embedded window is not recommended.</source>
          <target state="translated">윈도우가 컨테이너에 포함되면 컨테이너는 윈도우의 지오메트리와 가시성을 제어합니다. 내장 된 창 에서 &lt;a href=&quot;qwindow#setGeometry&quot;&gt;QWindow :: setGeometry&lt;/a&gt; (), &lt;a href=&quot;qwindow#show&quot;&gt;QWindow :: show&lt;/a&gt; () 또는 &lt;a href=&quot;qwindow#hide&quot;&gt;QWindow :: hide&lt;/a&gt; ()에 대한 명시 적 호출 은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf2e6243d5e6c8c2c5e1273d53d655f0a1ad06bd" translate="yes" xml:space="preserve">
          <source>Once these details are added, &lt;b&gt;Activate&lt;/b&gt; the product. If you have not published the application yet, the product is marked as &lt;b&gt;To be activated&lt;/b&gt;. Otherwise, it is marked as active. The product must be activated before it can be queried from the Qt Purchasing API. If the application has recently been published, then it may take a few hours before the in-app products can be accessed from your application. Look for the &lt;b&gt;Updates pending&lt;/b&gt; label on the top right side of the screen. If this is visible, then there are updates pending which are not yet visible from the outside.</source>
          <target state="translated">이러한 세부 사항이 추가되면 제품을 &lt;b&gt;활성화&lt;/b&gt; 하십시오. 아직 애플리케이션을 공개하지 않은 경우 제품은 &lt;b&gt;활성화&lt;/b&gt; 됨으로 표시 &lt;b&gt;됩니다&lt;/b&gt; . 그렇지 않으면 활성으로 표시됩니다. Qt 구매 API에서 쿼리하기 전에 제품을 활성화해야합니다. 응용 프로그램이 최근에 게시 된 경우 응용 프로그램에서 인앱 제품에 액세스하려면 몇 시간이 걸릴 수 있습니다. 화면 오른쪽 상단 에서 &lt;b&gt;업데이트 보류 중&lt;/b&gt; 레이블을 찾으십시오 . 이것이 보이는 경우 아직 외부에서 볼 수없는 업데이트 보류 중입니다.</target>
        </trans-unit>
        <trans-unit id="a7f71a05800de7ca2d4dd08b9121a4d845b7a47f" translate="yes" xml:space="preserve">
          <source>Once this is registered, the type can be used in QML by importing the specified type namespace and version number:</source>
          <target state="translated">등록되면 지정된 유형 네임 스페이스 및 버전 번호를 가져 와서 QML에서 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a44fb5711cc76be889a52ace7f57dfbfb5882981" translate="yes" xml:space="preserve">
          <source>Once this property is bound to another &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;, both header and table will synchronize with regard to column widths, column spacing, and flicking horizontally.</source>
          <target state="translated">Once this property is bound to another &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;, both header and table will synchronize with regard to column widths, column spacing, and flicking horizontally.</target>
        </trans-unit>
        <trans-unit id="23311eed06b33c3c9881162f1a3c1ef90b84868f" translate="yes" xml:space="preserve">
          <source>Once this property is bound to another &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;, both header and table will synchronize with regard to row heights, row spacing, and flicking vertically.</source>
          <target state="translated">Once this property is bound to another &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt;, both header and table will synchronize with regard to row heights, row spacing, and flicking vertically.</target>
        </trans-unit>
        <trans-unit id="9d11ad319c8411fb480cef806b8c18cbdbaa86f1" translate="yes" xml:space="preserve">
          <source>Once widgets have been inserted into a layout, it is not possible to move and resize them individually because the layout itself controls the geometry of each widget within it, taking account of the hints provided by spacers. Spacers can be added to the layout to influence the geometries of the widgets.</source>
          <target state="translated">위젯이 레이아웃에 삽입 된 후에는 레이아웃 자체가 스페이서에서 제공하는 힌트를 고려하여 레이아웃 자체가 위젯 내 각 위젯의 지오메트리를 제어하므로 개별적으로 이동하고 크기를 조정할 수 없습니다. 위젯의 형상에 영향을주기 위해 스페이서를 레이아웃에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48f853c377dfafa75d073fe8c2ac1f2d9bbf4804" translate="yes" xml:space="preserve">
          <source>Once you are done with the thread, call &lt;a href=&quot;qthreadpool#releaseThread&quot;&gt;releaseThread&lt;/a&gt;() to allow it to be reused.</source>
          <target state="translated">스레드가 완료되면 &lt;a href=&quot;qthreadpool#releaseThread&quot;&gt;releaseThread&lt;/a&gt; ()를 호출 하여 재사용 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="4f99787523ca86812e43fea58bf63058f32b7a4f" translate="yes" xml:space="preserve">
          <source>Once you have a &lt;a href=&quot;qml-qtqml-component&quot;&gt;Component&lt;/a&gt;, you can call its &lt;a href=&quot;qml-qtqml-component#createObject-method&quot;&gt;createObject()&lt;/a&gt; method to create an instance of the component. This function can take one or two arguments:</source>
          <target state="translated">당신은 일단 &lt;a href=&quot;qml-qtqml-component&quot;&gt;구성 요소&lt;/a&gt; , 당신은 호출 할 수 있습니다 &lt;a href=&quot;qml-qtqml-component#createObject-method&quot;&gt;CreateObject를 ()&lt;/a&gt; 구성 요소의 인스턴스를 만들 수있는 방법을. 이 함수는 하나 또는 두 개의 인수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c640f9181d5bd6296e2924bbca96e44926980a3" translate="yes" xml:space="preserve">
          <source>Once you have a custom widget plugin for</source>
          <target state="translated">에 대한 사용자 정의 위젯 플러그인이 있으면</target>
        </trans-unit>
        <trans-unit id="6e7fd47ef3ed9aa04b7236db70c3b3a14b8dea7b" translate="yes" xml:space="preserve">
          <source>Once you have a form window's cursor interface, you can check if the form window has a selection at all using the &lt;a href=&quot;qdesignerformwindowcursorinterface#hasSelection&quot;&gt;hasSelection&lt;/a&gt;() function. You can query the form window for its total &lt;a href=&quot;qdesignerformwindowcursorinterface#widgetCount&quot;&gt;widgetCount&lt;/a&gt;() and &lt;a href=&quot;qdesignerformwindowcursorinterface#selectedWidgetCount&quot;&gt;selectedWidgetCount&lt;/a&gt;(). You can retrieve the currently selected widget (or widgets) using the &lt;a href=&quot;qdesignerformwindowcursorinterface#current&quot;&gt;current&lt;/a&gt;() or &lt;a href=&quot;qdesignerformwindowcursorinterface#selectedWidget&quot;&gt;selectedWidget&lt;/a&gt;() functions.</source>
          <target state="translated">양식 창의 커서 인터페이스가 있으면 &lt;a href=&quot;qdesignerformwindowcursorinterface#hasSelection&quot;&gt;hasSelection&lt;/a&gt; () 함수를 사용하여 양식 창에 선택 항목이 있는지 확인할 수 있습니다 . 총 &lt;a href=&quot;qdesignerformwindowcursorinterface#widgetCount&quot;&gt;widgetCount&lt;/a&gt; () 및 &lt;a href=&quot;qdesignerformwindowcursorinterface#selectedWidgetCount&quot;&gt;selectedWidgetCount&lt;/a&gt; ()에 대해 양식 창을 쿼리 할 수 ​​있습니다 . &lt;a href=&quot;qdesignerformwindowcursorinterface#current&quot;&gt;현재&lt;/a&gt; () 또는 &lt;a href=&quot;qdesignerformwindowcursorinterface#selectedWidget&quot;&gt;selectedWidget&lt;/a&gt; () 함수를 사용하여 현재 선택된 위젯 (또는 위젯)을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86f4ced0f47e3cdafee5ebd0c20cd011a17a4dce" translate="yes" xml:space="preserve">
          <source>Once you have added your layout you can start putting widgets and other layouts into the cells of your grid layout using &lt;a href=&quot;qgridlayout#addWidget-1&quot;&gt;addWidget&lt;/a&gt;(), &lt;a href=&quot;qgridlayout#addItem&quot;&gt;addItem&lt;/a&gt;(), and &lt;a href=&quot;qgridlayout#addLayout&quot;&gt;addLayout&lt;/a&gt;().</source>
          <target state="translated">레이아웃을 추가 한 후에는 &lt;a href=&quot;qgridlayout#addWidget-1&quot;&gt;addWidget&lt;/a&gt; (), &lt;a href=&quot;qgridlayout#addItem&quot;&gt;addItem&lt;/a&gt; () 및 &lt;a href=&quot;qgridlayout#addLayout&quot;&gt;addLayout&lt;/a&gt; ()을 사용하여 위젯 및 기타 레이아웃을 그리드 레이아웃의 셀에 넣을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25fd7c4374dacc7fdac166445af55cb19e44130f" translate="yes" xml:space="preserve">
          <source>Once you have created a event object using Windows API such as CreateEvent() or OpenEvent(), you can create an event notifier to monitor the event handle. If the event notifier is enabled, it will emit the &lt;a href=&quot;qwineventnotifier#activated&quot;&gt;activated&lt;/a&gt;() signal whenever the corresponding event object is signalled.</source>
          <target state="translated">CreateEvent () 또는 OpenEvent ()와 같은 Windows API를 사용하여 이벤트 객체를 만든 후에는 이벤트 알리미를 만들어 이벤트 핸들을 모니터링 할 수 있습니다. 이벤트 알리미가 활성화 된 경우 해당 이벤트 객체가 시그널링 될 때마다 &lt;a href=&quot;qwineventnotifier#activated&quot;&gt;활성화 된&lt;/a&gt; () 신호를 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="ad85489ea8db0c725079f5ce1c8dbf56a58f4d84" translate="yes" xml:space="preserve">
          <source>Once you have created your iTunes test user, you will be able to log in to the sandbox app store when developing your app.</source>
          <target state="translated">iTunes 테스트 사용자를 생성하면 앱을 개발할 때 샌드 박스 앱 스토어에 로그인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58b03b1720b139f341a87cbf7ff93042e86f9554" translate="yes" xml:space="preserve">
          <source>Once you have done this, you can add boxes to the &lt;a href=&quot;qboxlayout&quot;&gt;QBoxLayout&lt;/a&gt; using one of four functions:</source>
          <target state="translated">이 작업을 완료하면 다음 네 가지 기능 중 하나를 사용 하여 &lt;a href=&quot;qboxlayout&quot;&gt;QBoxLayout&lt;/a&gt; 에 상자를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31b8502bd0f44d2949fed4f14a56e62dfc3ceaff" translate="yes" xml:space="preserve">
          <source>Once you have done this, you can add boxes to the QBoxLayout using one of four functions:</source>
          <target state="translated">Once you have done this, you can add boxes to the QBoxLayout using one of four functions:</target>
        </trans-unit>
        <trans-unit id="a50bf9b388f3951da2351041f5e385f3fd881082" translate="yes" xml:space="preserve">
          <source>Once you have followed the steps above, you have a separate light probe set for the material. This light probe overrides the scene light probe if there is one specified.</source>
          <target state="translated">Once you have followed the steps above, you have a separate light probe set for the material. This light probe overrides the scene light probe if there is one specified.</target>
        </trans-unit>
        <trans-unit id="4f03a38ef87621940dfad6538c8a44a1d3f2e107" translate="yes" xml:space="preserve">
          <source>Once you have installed Qt, you can start</source>
          <target state="translated">Qt를 설치하면 시작할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="95048dcfd3150cfb77e6dc7ba9e8b45084bb3618" translate="yes" xml:space="preserve">
          <source>Once you have loaded the SVG file successfully, you can render it with the &lt;a href=&quot;qsvgrenderer#render&quot;&gt;QSvgRenderer::render&lt;/a&gt;() function. Note that this scheme allows you to render SVG files on all paint devices supported by Qt, including &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;, QGLWidget, and &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. See the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsvg-svgviewer-example.html#&quot;&gt;SVG Viewer&lt;/a&gt; example for more details.</source>
          <target state="translated">SVG 파일을 성공적으로로드하면 &lt;a href=&quot;qsvgrenderer#render&quot;&gt;QSvgRenderer :: render&lt;/a&gt; () 함수를 사용하여 렌더링 할 수 있습니다 . 이 체계를 사용하면 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; , QGLWidget 및 &lt;a href=&quot;qimage&quot;&gt;QImage를&lt;/a&gt; 포함하여 Qt가 지원하는 모든 페인트 장치에서 SVG 파일을 렌더링 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsvg-svgviewer-example.html#&quot;&gt;SVG 뷰어&lt;/a&gt; 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c3f3dcc9cf59e9311124d8da3923db6e5bc376fc" translate="yes" xml:space="preserve">
          <source>Once you have loaded the SVG file successfully, you can render it with the &lt;a href=&quot;qsvgrenderer#render&quot;&gt;QSvgRenderer::render&lt;/a&gt;() function. Note that this scheme allows you to render SVG files on all paint devices supported by Qt, including &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;, QGLWidget, and &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. See the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsvg-svgviewer-example.html&quot;&gt;SVG Viewer&lt;/a&gt; example for more details.</source>
          <target state="translated">Once you have loaded the SVG file successfully, you can render it with the &lt;a href=&quot;qsvgrenderer#render&quot;&gt;QSvgRenderer::render&lt;/a&gt;() function. Note that this scheme allows you to render SVG files on all paint devices supported by Qt, including &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;, QGLWidget, and &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. See the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsvg-svgviewer-example.html&quot;&gt;SVG Viewer&lt;/a&gt; example for more details.</target>
        </trans-unit>
        <trans-unit id="eb607fb47d0583b00ef8a29f4e2e2a083a66be04" translate="yes" xml:space="preserve">
          <source>Once you have loaded the SVG file successfully, you can render it with the &lt;a href=&quot;qsvgrenderer#render&quot;&gt;QSvgRenderer::render&lt;/a&gt;() function. Note that this scheme allows you to render SVG files on all paint devices supported by Qt, including &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt;, QGLWidget, and &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. See the &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtsvg-svgviewer-example.html&quot;&gt;SVG Viewer&lt;/a&gt; example for more details.</source>
          <target state="translated">SVG 파일을 성공적으로로드 한 후에는 &lt;a href=&quot;qsvgrenderer#render&quot;&gt;QSvgRenderer :: render&lt;/a&gt; () 함수로 렌더링 할 수 있습니다 . 이 체계를 사용하면 &lt;a href=&quot;widgets-changes-qt6#qwidget&quot;&gt;QWidget&lt;/a&gt; , QGLWidget 및 &lt;a href=&quot;qimage&quot;&gt;QImage를&lt;/a&gt; 포함하여 Qt에서 지원하는 모든 페인트 장치에서 SVG 파일을 렌더링 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://doc.qt.io/qt-6.0/qtsvg-svgviewer-example.html&quot;&gt;SVG 뷰어&lt;/a&gt; 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ead5f946dd8a41570e30cb9f83c06bd9bcc6cc49" translate="yes" xml:space="preserve">
          <source>Once you have opened a device using a low-level (usually platform-specific) API, you can create a socket notifier to monitor the file descriptor. The socket notifier is enabled by default, i.e. it emits the &lt;a href=&quot;qsocketnotifier#activated&quot;&gt;activated&lt;/a&gt;() signal whenever a socket event corresponding to its type occurs. Connect the &lt;a href=&quot;qsocketnotifier#activated&quot;&gt;activated&lt;/a&gt;() signal to the slot you want to be called when an event corresponding to your socket notifier's type occurs.</source>
          <target state="translated">저수준 (일반적으로 플랫폼 별) API를 사용하여 장치를 열면 파일 설명자를 모니터링하는 소켓 알리미를 만들 수 있습니다. 소켓 알리미는 기본적으로 활성화되어 있습니다. 즉, 해당 유형에 해당하는 소켓 이벤트가 발생할 때마다 &lt;a href=&quot;qsocketnotifier#activated&quot;&gt;활성화 된&lt;/a&gt; () 신호를 방출 합니다. 소켓 알리미 유형에 해당하는 이벤트가 발생할 때 호출하려는 슬롯에 &lt;a href=&quot;qsocketnotifier#activated&quot;&gt;활성화 된&lt;/a&gt; () 신호를 연결하십시오 .</target>
        </trans-unit>
        <trans-unit id="856003ba62e3c792c5a48b82084d53965764bd9f" translate="yes" xml:space="preserve">
          <source>Once you have selected an image, IBL is set up for your scene. All models in the scene are illuminated by the light probe by default.</source>
          <target state="translated">Once you have selected an image, IBL is set up for your scene. All models in the scene are illuminated by the light probe by default.</target>
        </trans-unit>
        <trans-unit id="587696ac7394a789e6d77c3e76bb0fb746a545e6" translate="yes" xml:space="preserve">
          <source>Once you have successfully created a VAO the typical usage pattern is:</source>
          <target state="translated">VAO를 성공적으로 생성하면 일반적인 사용 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d0d6925f527558c514eaf74004bfb2fa5c285db" translate="yes" xml:space="preserve">
          <source>Once you have supplied a replacement drop action, call &lt;a href=&quot;qevent#accept&quot;&gt;accept&lt;/a&gt;() instead of &lt;a href=&quot;qdropevent#acceptProposedAction&quot;&gt;acceptProposedAction&lt;/a&gt;().</source>
          <target state="translated">대체 삭제 조치를 제공 한 후 &lt;a href=&quot;qdropevent#acceptProposedAction&quot;&gt;acceptProposedAction&lt;/a&gt; () 대신 &lt;a href=&quot;qevent#accept&quot;&gt;accept&lt;/a&gt; ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc887faa98989e4a295984bfa5e50ddccee219e1" translate="yes" xml:space="preserve">
          <source>Once you have the form window, you can query its properties. For example, a plain custom widget plugin is managed by</source>
          <target state="translated">양식 창이 있으면 속성을 쿼리 할 수 ​​있습니다. 예를 들어 일반 사용자 정의 위젯 플러그인은</target>
        </trans-unit>
        <trans-unit id="0cb9d678077cb6771f2d5c1164d88f0d756afb40" translate="yes" xml:space="preserve">
          <source>Once you know that the ports are ready to read or write, you can use the &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt;() or &lt;a href=&quot;qiodevice#write&quot;&gt;write&lt;/a&gt;() methods. Alternatively the &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt;() and &lt;a href=&quot;qiodevice#readAll&quot;&gt;readAll&lt;/a&gt;() convenience methods can also be invoked. If not all the data is read at once, the remaining data will be available for later as new incoming data is appended to the &lt;a href=&quot;qserialport&quot;&gt;QSerialPort&lt;/a&gt;'s internal read buffer. You can limit the size of the read buffer using &lt;a href=&quot;qserialport#setReadBufferSize&quot;&gt;setReadBufferSize&lt;/a&gt;().</source>
          <target state="translated">포트가 읽거나 쓸 준비가되었음을 알게되면 &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt; () 또는 &lt;a href=&quot;qiodevice#write&quot;&gt;write&lt;/a&gt; () 메소드를 사용할 수 있습니다 . 또는 &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt; () 및 &lt;a href=&quot;qiodevice#readAll&quot;&gt;readAll&lt;/a&gt; () 편의 메소드를 호출 할 수도 있습니다. 모든 데이터를 한 번에 읽을 수없는 경우 새로운 수신 데이터가 &lt;a href=&quot;qserialport&quot;&gt;QSerialPort&lt;/a&gt; 의 내부 읽기 버퍼에 추가 될 때 나머지 데이터를 나중에 사용할 수 있습니다 . &lt;a href=&quot;qserialport#setReadBufferSize&quot;&gt;setReadBufferSize&lt;/a&gt; ()를 사용하여 읽기 버퍼의 크기를 제한 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="577ee7c327443525aec4749067a313d887847abd" translate="yes" xml:space="preserve">
          <source>Once you know that the ports are ready to read or write, you can use the &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt;() or &lt;a href=&quot;qiodevice#write&quot;&gt;write&lt;/a&gt;() methods. Alternatively the &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt;() and &lt;a href=&quot;qiodevice#readAll&quot;&gt;readAll&lt;/a&gt;() convenience methods can also be invoked. If not all the data is read at once, the remaining data will be available for later as new incoming data is appended to the QSerialPort's internal read buffer. You can limit the size of the read buffer using &lt;a href=&quot;qserialport#setReadBufferSize&quot;&gt;setReadBufferSize&lt;/a&gt;().</source>
          <target state="translated">Once you know that the ports are ready to read or write, you can use the &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt;() or &lt;a href=&quot;qiodevice#write&quot;&gt;write&lt;/a&gt;() methods. Alternatively the &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt;() and &lt;a href=&quot;qiodevice#readAll&quot;&gt;readAll&lt;/a&gt;() convenience methods can also be invoked. If not all the data is read at once, the remaining data will be available for later as new incoming data is appended to the QSerialPort's internal read buffer. You can limit the size of the read buffer using &lt;a href=&quot;qserialport#setReadBufferSize&quot;&gt;setReadBufferSize&lt;/a&gt;().</target>
        </trans-unit>
        <trans-unit id="2e4978bbca70c81bd39582d9d963d8617f1d74dd" translate="yes" xml:space="preserve">
          <source>Once your app is registered in iTunes Connect you will have additional options available to manage that App. In the &lt;b&gt;Manage Your Apps&lt;/b&gt; page of iTunes Connect, click the icon representing your app to manage its details. Within this menu you can select the &lt;b&gt;Manage In-App Purchases&lt;/b&gt; button on the right to register in-app products you wish to offer.</source>
          <target state="translated">App이 iTunes Connect에 등록되면 해당 App을 관리하기위한 추가 옵션이 제공됩니다. (가)에서 &lt;b&gt;내 앱의 관리를&lt;/b&gt; 아이튠즈에 연결 페이지를 세부 정보를 관리 할 응용 프로그램을 나타내는 아이콘을 클릭합니다. 이 메뉴 내 에서 오른쪽의 &lt;b&gt;인앱 구매 관리&lt;/b&gt; 버튼을 선택하여 제공하려는 인앱 제품을 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82c37a941ba03279b12ed1a3e19e39a2cd9bc7f3" translate="yes" xml:space="preserve">
          <source>Once your products are registered you will be able to purchase them from your app. When you are developing your app it is desirable to test buying your products without spending real currency. There are actually two separate stores that requests can be sent to when using the In-App Purchasing service on iOS. While your app is being developed, any iOS App Store requests will be sent to a sandbox store. This occurs when your app has been signed with a developer Provisioning Profile. The sandbox store will only accept requests from test users and will not charge for the purchases. However, when you submit your app to the iOS App Store and it is accepted, all in-app purchasing requests are sent to the production store, which requires real iTunes users accounts, and will charge for the purchases.</source>
          <target state="translated">제품이 등록되면 앱에서 제품을 구입할 수 있습니다. 앱을 개발할 때 실제 통화를 소비하지 않고 제품 구매를 테스트하는 것이 바람직합니다. iOS에서 인앱 구매 서비스를 사용할 때 실제로 요청을 보낼 수있는 두 개의 개별 저장소가 있습니다. 앱이 개발되는 동안 모든 iOS 앱 스토어 요청은 샌드 박스 스토어로 전송됩니다. 앱이 개발자 프로비저닝 프로파일로 서명 된 경우 발생합니다. 샌드 박스 저장소는 테스트 사용자의 요청 만 수락하며 구매 비용을 청구하지 않습니다. 그러나 앱을 iOS App Store에 제출하고 승인하면 모든 인앱 구매 요청이 프로덕션 스토어로 전송되며, 실제 iTunes 사용자 계정이 필요하며 구매 비용이 청구됩니다.</target>
        </trans-unit>
        <trans-unit id="68a40ec4ea1c7cab77a9f3596ca2355b12bad46e" translate="yes" xml:space="preserve">
          <source>One advantage of using &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; as a paint device is that it is possible to guarantee the pixel exactness of any drawing operation in a platform-independent way. Another benefit is that the painting can be performed in another thread than the current GUI thread.</source>
          <target state="translated">페인트 장치로 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 를 사용 하면 플랫폼 독립적 인 방식으로 모든 드로잉 작업의 픽셀 정확도를 보장 할 수 있다는 이점 이 있습니다. 또 다른 이점은 현재 GUI 스레드가 아닌 다른 스레드에서 페인팅을 수행 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="552d0d068ba98a7ae885e564b90cd22da8285c55" translate="yes" xml:space="preserve">
          <source>One advantage of using &lt;a href=&quot;qstring#arg&quot;&gt;arg&lt;/a&gt;() over &lt;a href=&quot;qstring#asprintf&quot;&gt;asprintf&lt;/a&gt;() is that the order of the numbered place markers can change, if the application's strings are translated into other languages, but each &lt;a href=&quot;qstring#arg&quot;&gt;arg&lt;/a&gt;() will still replace the lowest-numbered unreplaced place-marker, no matter where it appears. Also, if place-marker &lt;code&gt;%i&lt;/code&gt; appears more than once in the string, &lt;a href=&quot;qstring#arg&quot;&gt;arg&lt;/a&gt;() replaces all of them.</source>
          <target state="translated">&lt;a href=&quot;qstring#asprintf&quot;&gt;asprintf&lt;/a&gt; ()보다 &lt;a href=&quot;qstring#arg&quot;&gt;arg&lt;/a&gt; () 를 사용 하면 응용 프로그램의 문자열이 다른 언어로 번역 된 경우 번호가 매겨진 자리 표시 자의 순서가 변경 될 수 있지만 각 &lt;a href=&quot;qstring#arg&quot;&gt;arg&lt;/a&gt; ()는 여전히 교체되지 않은 가장 낮은 자리 표시자를 대체합니다. 어디에 있든지 상관 없습니다. 또한 장소 표시기 &lt;code&gt;%i&lt;/code&gt; 가 문자열에 두 번 이상 나타나면 &lt;a href=&quot;qstring#arg&quot;&gt;arg&lt;/a&gt; ()가 모든 것을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="8a496cae007faea94b56b0456c6f81a542d18513" translate="yes" xml:space="preserve">
          <source>One advantage of using arg() over &lt;a href=&quot;qstring#asprintf&quot;&gt;asprintf&lt;/a&gt;() is that the order of the numbered place markers can change, if the application's strings are translated into other languages, but each arg() will still replace the lowest numbered unreplaced place marker, no matter where it appears. Also, if place marker &lt;code&gt;%i&lt;/code&gt; appears more than once in the string, the arg() replaces all of them.</source>
          <target state="translated">&lt;a href=&quot;qstring#asprintf&quot;&gt;asprintf&lt;/a&gt; ()에 비해 arg ()를 사용 하면 응용 프로그램의 문자열이 다른 언어로 번역 된 경우 번호가 매겨진 자리 표시 자의 순서가 변경 될 수 있지만 각 arg ()는 여전히 가장 낮은 번호의 대체되지 않은 장소 표식을 대체합니다. 그것이 나타나는 곳. 또한 자리 표시 자 &lt;code&gt;%i&lt;/code&gt; 가 문자열에 두 번 이상 나타나면 arg ()가 모든 것을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="49799b2853265a66e0f9eb11306af5d259a520f4" translate="yes" xml:space="preserve">
          <source>One advantage of using arg() over &lt;a href=&quot;qstring#asprintf&quot;&gt;asprintf&lt;/a&gt;() is that the order of the numbered place markers can change, if the application's strings are translated into other languages, but each arg() will still replace the lowest-numbered unreplaced place-marker, no matter where it appears. Also, if place-marker &lt;code&gt;%i&lt;/code&gt; appears more than once in the string, arg() replaces all of them.</source>
          <target state="translated">One advantage of using arg() over &lt;a href=&quot;qstring#asprintf&quot;&gt;asprintf&lt;/a&gt;() is that the order of the numbered place markers can change, if the application's strings are translated into other languages, but each arg() will still replace the lowest-numbered unreplaced place-marker, no matter where it appears. Also, if place-marker &lt;code&gt;%i&lt;/code&gt; appears more than once in the string, arg() replaces all of them.</target>
        </trans-unit>
        <trans-unit id="ca7219ee8d830a8dc83297bcaedbc1ec6c8f2430" translate="yes" xml:space="preserve">
          <source>One behavioral change to note is that the new &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; implementation will not provide stable references to elements in the hash when the table needs to grow, or when entries are removed. Applications that rely on such stability might now run into undefined behavior.</source>
          <target state="translated">주목해야 할 한 가지 동작 변경 사항은 테이블이 커져야하거나 항목이 제거 될 때 새로운 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; 구현이 해시의 요소에 대한 안정적인 참조를 제공하지 않는다는 것입니다. 이러한 안정성에 의존하는 응용 프로그램은 이제 정의되지 않은 동작으로 실행될 수 있습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="3651c6efb4c28103edacfd4bc6574f7b189b8dbf" translate="yes" xml:space="preserve">
          <source>One button has no elevation, and the other has an elevation of &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">한 버튼에는 표고가없고 다른 버튼에는 표고가 &lt;code&gt;10&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c7462448543cbd1c364bf32e079f8120754aeedc" translate="yes" xml:space="preserve">
          <source>One call</source>
          <target state="translated">한 번의 전화</target>
        </trans-unit>
        <trans-unit id="1d31b5cb24602913e72c9b9c94c60333e286c2d6" translate="yes" xml:space="preserve">
          <source>One call/Permanent</source>
          <target state="translated">한 번의 통화 / 영구</target>
        </trans-unit>
        <trans-unit id="4615cf68efe02b80727d8bb5e130a46af5cc2480" translate="yes" xml:space="preserve">
          <source>One can write a switch table like so:</source>
          <target state="translated">다음과 같이 스위치 테이블을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="021a5a769eb2a744869076c94a4ea5e56547536b" translate="yes" xml:space="preserve">
          <source>One caveat to using the latest Xcode version and SDK to build your application is that macOS's system frameworks will sometimes decide whether or not to enable behavior changes based on the SDK you built your application with.</source>
          <target state="translated">최신 Xcode 버전과 SDK를 사용하여 응용 프로그램을 빌드 할 때주의해야 할 점은 macOS의 시스템 프레임 워크가 응용 프로그램을 빌드 한 SDK를 기반으로 동작 변경을 활성화할지 여부를 결정한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="87ebc6df2d743bdf4de7159a1f5bedb57c85b959" translate="yes" xml:space="preserve">
          <source>One classic use of a tool button is to select tools; for example, the &quot;pen&quot; tool in a drawing program. This would be implemented by using a &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; as a toggle button (see &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;setCheckable&lt;/a&gt;()).</source>
          <target state="translated">툴 버튼의 전형적인 사용은 툴을 선택하는 것입니다. 예를 들어, 드로잉 프로그램의 &quot;펜&quot;도구입니다. 이것은 &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; 을 토글 버튼으로 사용하여 구현됩니다 ( &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;setCheckable&lt;/a&gt; () 참조 ).</target>
        </trans-unit>
        <trans-unit id="197b967081065134f8e05e142d1486a9f15d7b42" translate="yes" xml:space="preserve">
          <source>One classic use of a tool button is to select tools; for example, the &quot;pen&quot; tool in a drawing program. This would be implemented by using a QToolButton as a toggle button (see &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;setCheckable&lt;/a&gt;()).</source>
          <target state="translated">One classic use of a tool button is to select tools; for example, the &quot;pen&quot; tool in a drawing program. This would be implemented by using a QToolButton as a toggle button (see &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;setCheckable&lt;/a&gt;()).</target>
        </trans-unit>
        <trans-unit id="c4c4020dd2fd95c3515b537fd7886ebf59fcac10" translate="yes" xml:space="preserve">
          <source>One common use case is to set the value of &lt;code&gt;BASE_COLOR&lt;/code&gt; based on sampling a texture, be it a base color map, &lt;code&gt;SCREEN_TEXTURE&lt;/code&gt;, or some other kind of source. This can be relevant and convenient especially when no custom light processor functions are implemented. Setting &lt;code&gt;BASE_COLOR.a&lt;/code&gt; to something other than the default 1.0 allows affecting the final alpha value of the fragment. (note that this will often require also enabling alpha blending in &lt;a href=&quot;qml-qtquick3d-custommaterial#sourceBlend-prop&quot;&gt;sourceBlend&lt;/a&gt; and &lt;a href=&quot;qml-qtquick3d-custommaterial#destinationBlend-prop&quot;&gt;destinationBlend&lt;/a&gt;)</source>
          <target state="translated">일반적인 사용 사례 중 하나 는 텍스처 샘플링을 기반으로 &lt;code&gt;BASE_COLOR&lt;/code&gt; 값을 설정하는 것입니다 (기본 색상 맵, &lt;code&gt;SCREEN_TEXTURE&lt;/code&gt; 또는 다른 종류의 소스). 이는 특히 맞춤형 라이트 프로세서 기능이 구현되지 않은 경우 관련성이 높고 편리 할 수 ​​있습니다. 설정 &lt;code&gt;BASE_COLOR.a&lt;/code&gt; 을 기본 1.0 이외의 다른 것은 단편의 최종 알파 값에 영향을 미치는 수 있습니다. (이것은 종종 &lt;a href=&quot;qml-qtquick3d-custommaterial#sourceBlend-prop&quot;&gt;sourceBlend&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick3d-custommaterial#destinationBlend-prop&quot;&gt;destinationBlend&lt;/a&gt; 에서 알파 블렌딩을 활성화해야 합니다. )</target>
        </trans-unit>
        <trans-unit id="9e8892553d88581416dd3b2fcd31e82c19652dca" translate="yes" xml:space="preserve">
          <source>One common use of regexps is to split lines of delimited data into their component fields.</source>
          <target state="translated">정규 표현식의 일반적인 용도 중 하나는 구분 된 데이터 행을 구성 요소 필드로 분할하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a24ebc94394fa5f9d9f697e53dcf5f013c959c9e" translate="yes" xml:space="preserve">
          <source>One consequence of this is that setting a style rule on a widget automatically gives it precedence over other rules specified in the ancestor widgets' style sheets or the &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; style sheet. Consider the following example. First, we set a style sheet on the &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt;:</source>
          <target state="translated">그 결과 위젯에 스타일 규칙을 설정하면 &lt;a href=&quot;qapplication&quot;&gt;상위&lt;/a&gt; 위젯의 스타일 시트 또는 QApplication 스타일 시트에 지정된 다른 규칙보다 자동으로 우선 순위가 부여됩니다 . 다음 예를 고려하십시오. 먼저 &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; 에서 스타일 시트를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="38908edf573bb7b97e00bc1e6ec62c659e5cdcf0" translate="yes" xml:space="preserve">
          <source>One dash, two dots, one dash, two dots.</source>
          <target state="translated">하나의 대시, 두 개의 점, 하나의 대시, 두 개의 점.</target>
        </trans-unit>
        <trans-unit id="bb641bfb37d3bb45179d996104a3fdbdef166310" translate="yes" xml:space="preserve">
          <source>One data model can only belong to one state machine.</source>
          <target state="translated">하나의 데이터 모델은 하나의 상태 시스템에만 속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d9cb7313469561dfcceffea7241129fa4481e2e" translate="yes" xml:space="preserve">
          <source>One does not need to understand the internals of the renderer to get good performance. However, it might help when integrating with the scene graph or to figure out why it is not possible to squeeze the maximum efficiency out of the graphics chip.</source>
          <target state="translated">좋은 성능을 얻기 위해 렌더러의 내부를 이해할 필요는 없습니다. 그러나 장면 그래프와 통합하거나 그래픽 칩에서 최대 효율을 짜낼 수없는 이유를 알아내는 것이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d322aa94d574b82fc6b52bfde114ac5315193aae" translate="yes" xml:space="preserve">
          <source>One entry in an associative container: both the key and the value form one map-entry type.</source>
          <target state="translated">연관 컨테이너에있는 하나의 항목 : 키와 값 모두 하나의 맵 입력 유형을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="a7e131d96d2f2dc51922f5d25204edf525fe4a8e" translate="yes" xml:space="preserve">
          <source>One example of direct use is to forward errors that stem from a scripting language, e.g. QML:</source>
          <target state="translated">직접 사용의 한 예는 스크립팅 언어에서 발생하는 오류 (예 : QML)를 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ade3cab12057400fad5022687608c57749fe0637" translate="yes" xml:space="preserve">
          <source>One example of this is text-entry widgets, which often have a blinking cursor that can make comparisons of captured bitmaps succeed or fail depending on the state of the cursor when the bitmap is captured. This, in turn, may depend on the speed of the machine executing the test.</source>
          <target state="translated">One example of this is text-entry widgets, which often have a blinking cursor that can make comparisons of captured bitmaps succeed or fail depending on the state of the cursor when the bitmap is captured. This, in turn, may depend on the speed of the machine executing the test.</target>
        </trans-unit>
        <trans-unit id="924d7d4ee16dfff2662059020c1bdf8cf28b1b66" translate="yes" xml:space="preserve">
          <source>One frequent need for the transformation matrix is when reusing the same drawing code on a variety of paint devices. Without transformations, the results are tightly bound to the resolution of the paint device. Printers have high resolution, e.g. 600 dots per inch, whereas screens often have between 72 and 100 dots per inch.</source>
          <target state="translated">변환 매트릭스에 대한 한 가지 빈번한 요구는 다양한 페인트 장치에서 동일한 도면 코드를 재사용 할 때입니다. 변형이 없으면 결과가 페인트 장치의 해상도에 밀접하게 바인딩됩니다. 프린터는 해상도가 높으며 (예 : 인치당 600 도트) 화면은 종종 인치당 72-100 도트입니다.</target>
        </trans-unit>
        <trans-unit id="a41737d2b52315e3e7b77b5a84fc7cc9fe2b25ce" translate="yes" xml:space="preserve">
          <source>One input handler can control one scene. Setting a scene to an input handler does not transfer the ownership of the scene.</source>
          <target state="translated">하나의 입력 핸들러가 하나의 장면을 제어 할 수 있습니다. 장면을 입력 핸들러로 설정하면 장면의 소유권이 이전되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df1b400b13392aa822e4cb0b5acdac49738c9c08" translate="yes" xml:space="preserve">
          <source>One instance per day of month.</source>
          <target state="translated">한 달에 한 번 인스턴스.</target>
        </trans-unit>
        <trans-unit id="f3183f5f9d7dcdfd03d2cd7a8ac85c86fb10dfc4" translate="yes" xml:space="preserve">
          <source>One instance per day of week.</source>
          <target state="translated">요 일당 하나의 인스턴스.</target>
        </trans-unit>
        <trans-unit id="ba0ceb58ac884f9abf155cd9df5794beb04c7727" translate="yes" xml:space="preserve">
          <source>One instance per week.</source>
          <target state="translated">주당 하나의 인스턴스.</target>
        </trans-unit>
        <trans-unit id="3589f2b7c774a6be6d231f82ea0f6fae4a5452d0" translate="yes" xml:space="preserve">
          <source>One major cost of using JavaScript is that in most cases when a property from a QML type is accessed, a JavaScript object with an external resource containing the underlying C++ data (or a reference to it) is created. In most cases, this is fairly inexpensive, but in others it can be quite expensive. One example of where it is expensive is assigning a C++ &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt;&lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt; to a QML &quot;variant&quot; property. Lists can also be expensive, although sequences of specific types (&lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; of int, qreal, bool, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, and &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;) should be inexpensive; other list types involve an expensive conversion cost (creating a new JavaScript Array, and adding new types one by one, with per-type conversion from C++ type instance to JavaScript value).</source>
          <target state="translated">JavaScript를 사용하는 주요 비용 중 하나는 대부분의 경우 QML 유형의 특성에 액세스 할 때 기본 C ++ 데이터 (또는 이에 대한 참조)를 포함하는 외부 자원이있는 JavaScript 오브젝트가 작성되는 것입니다. 대부분의 경우 이것은 상당히 비싸지 만 다른 경우에는 꽤 비쌀 수 있습니다. 비용이 많이 드는 예 중 하나는 C ++ &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap &lt;/a&gt;&lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt; 를 QML &quot;variant&quot;속성에 할당하는 것 입니다. 특정 유형의 시퀀스 ( int, qreal, bool, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 및 &lt;a href=&quot;qurl&quot;&gt;QUrl의 &lt;/a&gt;&lt;a href=&quot;qlist&quot;&gt;QList)&lt;/a&gt; 에도 불구하고 목록은 비쌀 수 있습니다.) 저렴해야한다. 다른 목록 유형에는 변환 비용이 많이 듭니다 (새로운 JavaScript 배열 작성 및 C ++ 유형 인스턴스에서 JavaScript 값으로 유형별로 변환하여 하나씩 새 유형 추가).</target>
        </trans-unit>
        <trans-unit id="2ed3fac3f4a3805ea928e4e11366e07bd95f80cc" translate="yes" xml:space="preserve">
          <source>One notable exception is the class &lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;, which still resides in Qt GUI.</source>
          <target state="translated">한 가지 주목할만한 예외는 Qt GUI에 여전히 상주하는 &lt;a href=&quot;gui-changes-qt6#qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; 클래스 입니다.</target>
        </trans-unit>
        <trans-unit id="f8e864d68489bf38b989fae405a3102cc97b5939" translate="yes" xml:space="preserve">
          <source>One of &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;'s greatest strengths is its ability to efficiently determine the location of items. Even with millions of items on the scene, the &lt;a href=&quot;qgraphicsscene#items&quot;&gt;items&lt;/a&gt;() functions can determine the location of an item within a few milliseconds. There are several overloads to &lt;a href=&quot;qgraphicsscene#items&quot;&gt;items&lt;/a&gt;(): one that finds items at a certain position, one that finds items inside or intersecting with a polygon or a rectangle, and more. The list of returned items is sorted by stacking order, with the topmost item being the first item in the list. For convenience, there is also an &lt;a href=&quot;qgraphicsscene#itemAt&quot;&gt;itemAt&lt;/a&gt;() function that returns the topmost item at a given position.</source>
          <target state="translated">&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 의 가장 큰 강점 중 하나는 항목의 위치를 ​​효율적으로 결정하는 능력입니다. 장면에 수백만 개의 항목이 있어도 &lt;a href=&quot;qgraphicsscene#items&quot;&gt;items&lt;/a&gt; () 함수는 몇 밀리 초 내에 항목의 위치를 ​​결정할 수 있습니다. &lt;a href=&quot;qgraphicsscene#items&quot;&gt;항목&lt;/a&gt; () 에는 여러 가지 과부하가 있습니다 . 하나는 특정 위치에서 항목을 찾거나 하나는 다각형 또는 사각형 내부 또는 교차하는 항목을 찾습니다. 반환 된 항목 목록은 스택 순서에 따라 정렬되며 최상위 항목은 목록의 첫 번째 항목입니다. 편의상 주어진 위치에서 최상위 항목을 반환 하는 &lt;a href=&quot;qgraphicsscene#itemAt&quot;&gt;itemAt&lt;/a&gt; () 함수 도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2124ade4fb2bf06272d34869bf977cb448cef3c8" translate="yes" xml:space="preserve">
          <source>One of QGraphicsScene's greatest strengths is its ability to efficiently determine the location of items. Even with millions of items on the scene, the &lt;a href=&quot;qgraphicsscene#items&quot;&gt;items&lt;/a&gt;() functions can determine the location of an item within a few milliseconds. There are several overloads to &lt;a href=&quot;qgraphicsscene#items&quot;&gt;items&lt;/a&gt;(): one that finds items at a certain position, one that finds items inside or intersecting with a polygon or a rectangle, and more. The list of returned items is sorted by stacking order, with the topmost item being the first item in the list. For convenience, there is also an &lt;a href=&quot;qgraphicsscene#itemAt&quot;&gt;itemAt&lt;/a&gt;() function that returns the topmost item at a given position.</source>
          <target state="translated">One of QGraphicsScene's greatest strengths is its ability to efficiently determine the location of items. Even with millions of items on the scene, the &lt;a href=&quot;qgraphicsscene#items&quot;&gt;items&lt;/a&gt;() functions can determine the location of an item within a few milliseconds. There are several overloads to &lt;a href=&quot;qgraphicsscene#items&quot;&gt;items&lt;/a&gt;(): one that finds items at a certain position, one that finds items inside or intersecting with a polygon or a rectangle, and more. The list of returned items is sorted by stacking order, with the topmost item being the first item in the list. For convenience, there is also an &lt;a href=&quot;qgraphicsscene#itemAt&quot;&gt;itemAt&lt;/a&gt;() function that returns the topmost item at a given position.</target>
        </trans-unit>
        <trans-unit id="6877a7adf6c6f197b61a3386bee49d537fed067e" translate="yes" xml:space="preserve">
          <source>One of Qt's key features, to enable this information exchange, is the distinction between an object's API (defined by its properties, signals, and slots) and the implementation of that API. QtRO's purpose is to meet that expected API, even if the true &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is in a different process. A slot called on a copy of an object (the &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; in QtRO) is forwarded to the true object (the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; in QtRO) for handling. Every Replica receives updates to the Source, either property changes or emitted signals.</source>
          <target state="translated">이 정보 교환을 가능하게하는 Qt의 주요 기능 중 하나는 객체의 API (속성, 신호 및 슬롯으로 정의)와 해당 API의 구현을 구분하는 것입니다. QtRO의 목적은 실제 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 가 다른 프로세스에 있더라도 예상되는 API를 충족시키는 것입니다 . 오브젝트 사본 ( QtRO 의 &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;복제본)&lt;/a&gt; 에서 호출 된 슬롯 은 처리를 위해 실제 오브젝트 ( QtRO 의 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;소스&lt;/a&gt; )로 전달됩니다 . 모든 복제본은 속성 변경 또는 방출 된 신호 중 하나 인 소스에 대한 업데이트를받습니다.</target>
        </trans-unit>
        <trans-unit id="ab0dc330c8a6c23af3e80e8c2ab7c44bf261e934" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;q3dtheme#ColorStyle-enum&quot;&gt;ColorStyle&lt;/a&gt; enum values.</source>
          <target state="translated">&lt;a href=&quot;q3dtheme#ColorStyle-enum&quot;&gt;ColorStyle&lt;/a&gt; 열거 형 값 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="09637215558791f84dc766275fa305328d994a06" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;qabstract3dgraph#ShadowQuality-enum&quot;&gt;ShadowQuality&lt;/a&gt; enum values. By default, &lt;code&gt;ShadowQualityMedium&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qabstract3dgraph#ShadowQuality-enum&quot;&gt;ShadowQuality&lt;/a&gt; 열거 형 값 중 하나입니다 . 기본적으로 &lt;code&gt;ShadowQualityMedium&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="07d163b1ad469f9585e1ff0e2598072e284c843b" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;qabstract3dinputhandler#InputView-enum&quot;&gt;InputView&lt;/a&gt; enum values.</source>
          <target state="translated">&lt;a href=&quot;qabstract3dinputhandler#InputView-enum&quot;&gt;InputView&lt;/a&gt; 열거 형 값 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="613c05d992a3edd6749c6b40952f8297fa534928" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt::DateFormat&lt;/a&gt; enumeration values, such as &lt;code&gt;Qt.DefaultLocaleShortDate&lt;/code&gt; or &lt;code&gt;Qt.ISODate&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Qt.DefaultLocaleShortDate&lt;/code&gt; 또는 &lt;code&gt;Qt.ISODate&lt;/code&gt; 와 같은 &lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt :: DateFormat&lt;/a&gt; 열거 값 중 하나</target>
        </trans-unit>
        <trans-unit id="78f45c1b7627cd5722b0f72ce206427973168a19" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt::DateFormat&lt;/a&gt; enumeration values, such as &lt;code&gt;Qt.RFC2822Date&lt;/code&gt; or &lt;code&gt;Qt.ISODate&lt;/code&gt;.</source>
          <target state="translated">One of the &lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt::DateFormat&lt;/a&gt; enumeration values, such as &lt;code&gt;Qt.RFC2822Date&lt;/code&gt; or &lt;code&gt;Qt.ISODate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5831d1f70b9397cda568b627e5c2de6827e6831" translate="yes" xml:space="preserve">
          <source>One of the URL schemes built into Qt is the &quot;qrc&quot; scheme. This allows content to be compiled into the executable using &lt;a href=&quot;resources&quot;&gt;The Qt Resource System&lt;/a&gt;. Using this, an executable can reference QML content that is compiled into the executable:</source>
          <target state="translated">Qt에 내장 된 URL 체계 중 하나는 &quot;qrc&quot;체계입니다. 이를 통해 &lt;a href=&quot;resources&quot;&gt;Qt Resource System을&lt;/a&gt; 사용하여 컨텐츠를 실행 파일로 컴파일 할 수 있습니다 . 이를 사용하여 실행 파일은 실행 파일로 컴파일 된 QML 컨텐츠를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2243094924e8fa8a3ca2c547099978ca54ee34aa" translate="yes" xml:space="preserve">
          <source>One of the biggest obstacles for the offline shader generator is the amount of different materials that can be generated, not only based on the material properties themeself but also how the rest of the scene is set-up; for example, light count, light type, shadows, etc. all affect the generated shader(s). When we also take &lt;a href=&quot;qtquick3d-tool-shadergen#dynamic-properties&quot;&gt;dynamic properties&lt;/a&gt; into account, the share amount of material shader permutations can very quickly make it unfeasible to generate them all at build-time. To limit the amount of shaders the tool needs to generate, the tool tries to only generate the shaders it think the application needs. The heuristics used in the tool might not always be able to detect which materials should be generate, this is espcecially true for properties that change at run-time. To verify that the material shaders were successfully, and correctly, generated, the tool should have generated a &lt;a href=&quot;qtquick3d-tool-shadergen#genereated-content&quot;&gt;.qsbc&lt;/a&gt; file which can be inspected to verify that the content matches the material used by the application. It's also possible to verify that the material was loaded from the pre-built cache by setting the environment variable &lt;b&gt;QT_RHI_SHADER_DEBUG=1&lt;/b&gt; and looking at the debug output for mentions of the engine loading the &lt;b&gt;pre-compiled&lt;/b&gt; shader successfully.</source>
          <target state="translated">오프라인 셰이더 생성기의 가장 큰 장애물 중 하나는 재질 속성 테마 자체뿐만 아니라 장면의 나머지 설정 방법에 따라 생성 할 수있는 다양한 재질의 양입니다. 예를 들어 라이트 개수, 라이트 유형, 그림자 등은 모두 생성 된 셰이더에 영향을줍니다. 우리가 &lt;a href=&quot;qtquick3d-tool-shadergen#dynamic-properties&quot;&gt;동적 속성을&lt;/a&gt; 취할 때고려할 때, 머티리얼 셰이더 순열의 공유 량은 빌드 타임에 모두 생성하는 것을 매우 빠르게 불가능하게 만들 수 있습니다. 도구가 생성해야하는 셰이더의 양을 제한하기 위해 도구는 애플리케이션에 필요하다고 생각하는 셰이더 만 생성하려고합니다. 도구에 사용 된 휴리스틱 스가 생성해야하는 재료를 항상 감지 할 수있는 것은 아닙니다. 이는 특히 런타임에 변경되는 속성에 대해 사실입니다. 머티리얼 셰이더가 성공적으로 올바르게 생성되었는지 확인하려면 도구가 &lt;a href=&quot;qtquick3d-tool-shadergen#genereated-content&quot;&gt;.qsbc&lt;/a&gt; 파일을 생성해야합니다.이 파일은 콘텐츠가 애플리케이션에서 사용하는 머티리얼과 일치하는지 검사 할 수 있습니다. 환경 변수 &lt;b&gt;QT_RHI_SHADER_DEBUG = 1&lt;/b&gt; 을 설정하여 미리 빌드 된 캐시에서 재질이로드되었는지 확인할 수도 있습니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;미리 컴파일 된&lt;/b&gt; 셰이더를 성공적으로 로드하는 엔진에 대한 언급은 디버그 출력을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="de02ef4459ecf6d496f2215936d878afbff5850f" translate="yes" xml:space="preserve">
          <source>One of the core features of QML is that it enables QML object types to be easily defined in a lightweight manner through QML documents to suit the needs of individual QML applications. The standard &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; module provides various types like &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-image&quot;&gt;Image&lt;/a&gt; for building a QML application; beyond these, you can easily define your own QML types to be reused within your application. This ability to create your own types forms the building blocks of any QML application.</source>
          <target state="translated">QML의 핵심 기능 중 하나는 개별 QML 애플리케이션의 요구에 맞게 QML 문서를 통해 QML 객체 유형을 간단한 방식으로 쉽게 정의 할 수 있다는 것입니다. 표준 &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; 모듈은 QML 애플리케이션 구축을 위해 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-image&quot;&gt;Image&lt;/a&gt; 와 같은 다양한 유형을 제공 합니다. 이 외에도 애플리케이션 내에서 재사용 할 자체 QML 유형을 쉽게 정의 할 수 있습니다. 고유 한 유형을 만들 수있는이 기능은 모든 QML 응용 프로그램의 빌딩 블록을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="3809a20bc81eacc8be68aeec501f8c163ad6e90f" translate="yes" xml:space="preserve">
          <source>One of the great advantages of using QML to define a user interface is that it allows the user interface designer to define how the application should react to events with simple JavaScript expressions. In QML, we refer to those events as &lt;a href=&quot;qtqml-syntax-signals&quot;&gt;signals&lt;/a&gt; and these signals are handled by &lt;a href=&quot;qtqml-syntax-signals#qml-signals-and-handlers&quot;&gt;signal handlers&lt;/a&gt;.</source>
          <target state="translated">QML을 사용하여 사용자 인터페이스를 정의 할 때 얻을 수있는 가장 큰 장점 중 하나는 사용자 인터페이스 디자이너가 간단한 JavaScript 표현식으로 응용 프로그램이 이벤트에 반응하는 방식을 정의 할 수 있다는 것입니다. QML에서는 이러한 이벤트를 &lt;a href=&quot;qtqml-syntax-signals&quot;&gt;신호라고&lt;/a&gt; 하며 이러한 신호는 &lt;a href=&quot;qtqml-syntax-signals#qml-signals-and-handlers&quot;&gt;신호 처리기에서 처리&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b4c186fd917df6bd21db9cfed12c08d935e4fbb7" translate="yes" xml:space="preserve">
          <source>One of the key concepts of .NET is the idea of &quot;intermediate language code&quot; - the source code is compiled into a bytecode format, and at runtime, that bytecode is executed in a virtual machine - the</source>
          <target state="translated">.NET의 주요 개념 중 하나는 &quot;중급 언어 코드&quot;라는 아이디어입니다. 소스 코드는 바이트 코드 형식으로 컴파일되고 런타임에 해당 바이트 코드는 가상 머신에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f2165e2cfc45409f48d8a4ff1c18c18165fe8229" translate="yes" xml:space="preserve">
          <source>One of the key goals that most application developers want to achieve is to create a maintainable application. One of the ways to achieve this goal is to separate the user interface from the business logic. The following are a few reasons why an application's UI should be written in QML:</source>
          <target state="translated">대부분의 응용 프로그램 개발자가 달성하고자하는 주요 목표 중 하나는 유지 관리 가능한 응용 프로그램을 만드는 것입니다. 이 목표를 달성하는 방법 중 하나는 사용자 인터페이스와 비즈니스 로직을 분리하는 것입니다. 다음은 QML로 애플리케이션의 UI를 작성해야하는 몇 가지 이유입니다.</target>
        </trans-unit>
        <trans-unit id="cd16d5b033b6834a5a9611e78f3e2213cb9bd2c3" translate="yes" xml:space="preserve">
          <source>One of the most important concepts in QML is that of type re-use. An application will probably have multiple visual types which are all similar (for example, multiple push buttons), and QML allows these sort of things to be defined as re-usable, custom types, to minimize code duplication and maximize readability.</source>
          <target state="translated">QML에서 가장 중요한 개념 중 하나는 재사용 유형입니다. 응용 프로그램에는 아마도 여러 개의 시각적 유형이 모두 비슷할 것입니다 (예 : 다중 누름 버튼). QML을 사용하면 이러한 유형의 항목을 재사용 가능한 사용자 정의 유형으로 정의하여 코드 복제를 최소화하고 가독성을 극대화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="946011cfa449ec7f7b9caff43717b47b8e240db0" translate="yes" xml:space="preserve">
          <source>One of the most useful basic features of Qt is the support for buddy widgets. A buddy widget accepts the input focus on behalf of a &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; when the user types the label's shortcut key combination. The buddy concept is also used in Qt's &lt;a href=&quot;model-view-programming&quot;&gt;model/view&lt;/a&gt; framework.</source>
          <target state="translated">Qt의 가장 유용한 기본 기능 중 하나는 친구 위젯 지원입니다. 사용자가 레이블의 바로 가기 키 조합을 입력하면 대화 상대 위젯이 &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; 대신 입력 초점을 수락합니다 . 친구 개념은 Qt의 &lt;a href=&quot;model-view-programming&quot;&gt;모델 / 뷰&lt;/a&gt; 프레임 워크 에서도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="30363581ec584febf43e57cce904b9c9605766ff" translate="yes" xml:space="preserve">
          <source>One of the requested discovery methods is not supported by the current platform. This value was introduced by Qt 5.8.</source>
          <target state="translated">요청 된 검색 방법 중 하나가 현재 플랫폼에서 지원되지 않습니다. 이 값은 Qt 5.8에 의해 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="27872144c06fca2dc32bc579b3aff1208da29b65" translate="yes" xml:space="preserve">
          <source>One of the requirements to support in-app purchases on iOS is to have a registered unique App ID. This means that it is not possible to use an App ID that contains a wildcard character. You can check the existing App IDs and create new ones from the &lt;a href=&quot;https://developer.apple.com/account/ios/identifiers/bundle/bundleList.action&quot;&gt;Apple Developer Certificate, Identifiers, and Profiles manager&lt;/a&gt;.</source>
          <target state="translated">iOS에서 인앱 구매를 지원하기위한 요구 사항 중 하나는 고유 한 앱 ID를 등록하는 것입니다. 이는 와일드 카드 문자가 포함 된 앱 ID를 사용할 수 없음을 의미합니다. 기존 앱 ID를 확인하고 &lt;a href=&quot;https://developer.apple.com/account/ios/identifiers/bundle/bundleList.action&quot;&gt;Apple 개발자 인증서, 식별자 및 프로파일 관리자&lt;/a&gt; 에서 새 ID를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d829c82306decdaf26640b18173d9b3b96ca0b69" translate="yes" xml:space="preserve">
          <source>One of the signals might be emitted for the current state of the</source>
          <target state="translated">신호 중 하나가 현재 상태에서 방출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7312240af405956c435f0d722687ac2cd9912c5b" translate="yes" xml:space="preserve">
          <source>One or more errors has occurred. Call &lt;a href=&quot;qquickview#errors&quot;&gt;errors&lt;/a&gt;() to retrieve a list of errors.</source>
          <target state="translated">하나 이상의 오류가 발생했습니다. &lt;a href=&quot;qquickview#errors&quot;&gt;오류&lt;/a&gt; 목록을 검색하려면 오류 ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff1d7c07ab82ad3c6fe97e07e506c72e4b39eb60" translate="yes" xml:space="preserve">
          <source>One or more errors occurred. Call &lt;a href=&quot;qquickwidget#errors&quot;&gt;errors&lt;/a&gt;() to retrieve a list of errors.</source>
          <target state="translated">하나 이상의 오류가 발생했습니다. &lt;a href=&quot;qquickwidget#errors&quot;&gt;오류&lt;/a&gt; 목록을 검색하려면 오류 ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c562be14a0f3a541154814641a1055fb9c8c75c" translate="yes" xml:space="preserve">
          <source>One or two occurrences of &lt;a href=&quot;#length&quot;&gt;Length&lt;/a&gt;. If only one length is specified, it is used as the radius of the quarter circle defining the corner. If two lengths are specified, the first length is the horizontal radius of a quarter ellipse, whereas the second length is the vertical radius.</source>
          <target state="translated">&lt;a href=&quot;#length&quot;&gt;Length가&lt;/a&gt; 한두 번 나타납니다 . 길이가 하나만 지정된 경우 모서리를 정의하는 1/4 원의 반지름으로 사용됩니다. 두 개의 길이를 지정하면 첫 번째 길이는 1/4 타원의 가로 반지름이고 두 번째 길이는 세로 반지름입니다.</target>
        </trans-unit>
        <trans-unit id="2dafa06193c6c0de5f03ef1aa013eade7b316811" translate="yes" xml:space="preserve">
          <source>One or two occurrences of &lt;a href=&quot;stylesheet-reference#length&quot;&gt;Length&lt;/a&gt;. If only one length is specified, it is used as the radius of the quarter circle defining the corner. If two lengths are specified, the first length is the horizontal radius of a quarter ellipse, whereas the second length is the vertical radius.</source>
          <target state="translated">One or two occurrences of &lt;a href=&quot;stylesheet-reference#length&quot;&gt;Length&lt;/a&gt;. If only one length is specified, it is used as the radius of the quarter circle defining the corner. If two lengths are specified, the first length is the horizontal radius of a quarter ellipse, whereas the second length is the vertical radius.</target>
        </trans-unit>
        <trans-unit id="463a49dac2612f25b516e3cb3a7d4930f9d855ca" translate="yes" xml:space="preserve">
          <source>One or two pixel space between the menu bar and the dockarea, as done on Windows.</source>
          <target state="translated">Windows에서와 같이 메뉴 표시 줄과 도크 영역 사이에 하나 또는 두 개의 픽셀 공간이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9da412a9292ad6f936e19cb1d5a5101b43c83d66" translate="yes" xml:space="preserve">
          <source>One other common use cases is rendering points. This is fairly simple to do since the attribute specification is going to be minimal: we provide three floats (x, y, z) for each vertex, nothing else. A &lt;a href=&quot;qquick3dgeometry&quot;&gt;QQuick3DGeometry&lt;/a&gt; subclass could implement a geometry consisting of 2000 points similarly to the following:</source>
          <target state="translated">또 다른 일반적인 사용 사례는 렌더링 포인트입니다. 어트리뷰트 사양이 최소화 될 것이기 때문에 이것은 매우 간단합니다. 우리는 각 꼭지점에 대해 3 개의 부동 소수점 (x, y, z)을 제공합니다. &lt;a href=&quot;qquick3dgeometry&quot;&gt;QQuick3DGeometry의&lt;/a&gt; 서브 클래스는 다음과 유사하게 2000 점으로 구성된 형상을 구현할 수 :</target>
        </trans-unit>
        <trans-unit id="ab6ea547facb8d8e1977c533d0dff798d91798e2" translate="yes" xml:space="preserve">
          <source>One pixel wide pen</source>
          <target state="translated">1 픽셀 너비의 펜</target>
        </trans-unit>
        <trans-unit id="a1ef8c08328d1edf403fc8a36daace2fa3784639" translate="yes" xml:space="preserve">
          <source>One possible use case is to add this handler to a transparent Item which is on top of the rest of the scene (by having a high &lt;a href=&quot;qml-qtquick-item#z-prop&quot;&gt;z&lt;/a&gt; value), so that when a point is freshly pressed, it will be delivered to that Item and its handlers first, providing the opportunity to take the passive grab as early as possible. Such an item (like a pane of glass over the whole UI) can be a convenient parent for other Items which visualize the kind of reactive feedback which must always be on top; and likewise it can be the parent for popups, popovers, dialogs and so on. If it will be used in that way, it can be helpful for your main.cpp to use &lt;a href=&quot;qqmlcontext#setContextProperty&quot;&gt;QQmlContext::setContextProperty()&lt;/a&gt; to make the &quot;glass pane&quot; accessible by ID to the entire UI, so that other Items and PointHandlers can be reparented to it.</source>
          <target state="translated">가능한 사용 사례 중 하나는이 핸들러를 나머지 장면 위에있는 투명한 항목에 추가하고 ( &lt;a href=&quot;qml-qtquick-item#z-prop&quot;&gt;z&lt;/a&gt; 값 이 높음 ) 점을 새로 누르면 해당 항목과 해당 항목에 전달됩니다. 처리기를 먼저 시작하여 가능한 한 빨리 패시브를 잡을 수있는 기회를 제공합니다. 이러한 항목 (전체 UI의 유리 창과 같은)은 항상 맨 위에 있어야하는 반응 형 피드백의 종류를 시각화하는 다른 항목의 편리한 부모가 될 수 있습니다. 마찬가지로 팝업, 팝업, 대화 상자의 부모가 될 수 있습니다. 그런 식으로 사용될 경우 main.cpp가 &lt;a href=&quot;qqmlcontext#setContextProperty&quot;&gt;QQmlContext :: setContextProperty ()&lt;/a&gt; 를 사용하여 ID로 &quot;유리 창&quot;을 전체 UI에 액세스 할 수 있도록하여 다른 항목 및 PointHandler를 다시 만들 수 있습니다. 그것에.</target>
        </trans-unit>
        <trans-unit id="b94b0da25fe601fd37aaafc21d9d291d763695f0" translate="yes" xml:space="preserve">
          <source>One reason why isWritable() might return false is if &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; operates on a read-only file.</source>
          <target state="translated">isWritable ()이 false를 리턴하는 한 가지 이유는 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 가 읽기 전용 파일에서 작동하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="92bef01f9dd59d9f5483ce6e7064d464b098e27d" translate="yes" xml:space="preserve">
          <source>One section tag represents one item in the table of contents. The sections can be nested to any degree, but from a user's perspective it should not be more than four or five levels. A section is defined by its title and reference. The reference, like all file references in a Qt help project, are relative to the help project file itself.</source>
          <target state="translated">섹션 태그 하나는 목차에서 하나의 항목을 나타냅니다. 섹션은 어느 정도 중첩 될 수 있지만 사용자의 관점에서 4 ~ 5 레벨을 넘지 않아야합니다. 섹션은 제목과 참조로 정의됩니다. Qt 도움말 프로젝트의 모든 파일 참조와 마찬가지로 참조는 도움말 프로젝트 파일 자체와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3824fa50476a7eaeee5469d568f55cd47157896c" translate="yes" xml:space="preserve">
          <source>One shot auto focus to objects close to camera.</source>
          <target state="translated">카메라에 가까운 물체에 한 번의 자동 초점.</target>
        </trans-unit>
        <trans-unit id="b1e006560d98f655fe40c04d72790d15565a3184" translate="yes" xml:space="preserve">
          <source>One thing to keep in mind from this namespace discussion, whether you run XQueries in a Qt program using Qt XML Patterns, or you run them from the command line using xmlpatterns, is that if you don't get the output you expect, it might be because the data you are querying uses namespaces, but you didn't declare those namespaces in your &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;.</source>
          <target state="translated">One thing to keep in mind from this namespace discussion, whether you run XQueries in a Qt program using Qt XML Patterns, or you run them from the command line using xmlpatterns, is that if you don't get the output you expect, it might be because the data you are querying uses namespaces, but you didn't declare those namespaces in your &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="79890f10172a98fd3ab203c0cf2431528cfa371d" translate="yes" xml:space="preserve">
          <source>One thing to keep in mind from this namespace discussion, whether you run XQueries in a Qt program using Qt XML Patterns, or you run them from the command line using xmlpatterns, is that if you don't get the output you expect, it might be because the data you are querying uses namespaces, but you didn't declare those namespaces in your &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;.</source>
          <target state="translated">Qt XML 패턴을 사용하여 Qt 프로그램에서 XQueries를 실행하든 xmlpatterns를 사용하여 명령 행에서 XQueries를 실행하든,이 네임 스페이스 토론에서 명심해야 할 한 가지는 예상되는 출력을 얻지 못하면 쿼리하는 데이터가 네임 스페이스를 사용하기 때문에 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 에서 해당 네임 스페이스를 선언하지 않았기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="0ddf250291fc0a37a862cc3eb5dcdd0fa9eaffcb" translate="yes" xml:space="preserve">
          <source>One to four occurrences of &lt;a href=&quot;#brush&quot;&gt;Brush&lt;/a&gt;, specifying the top, right, bottom, and left edges of a box, respectively. If the left color is not specified, it is taken to be the same as the right color. If the bottom color is not specified, it is taken to be the same as the top color. If the right color is not specified, it is taken to be the same as the top color.</source>
          <target state="translated">상자의 위쪽, 오른쪽, 아래쪽 및 왼쪽 가장자리를 각각 지정하는 1 ~ 4 개의 &lt;a href=&quot;#brush&quot;&gt;브러시&lt;/a&gt; 발생 . 왼쪽 색상을 지정하지 않으면 오른쪽 색상과 동일하게 간주됩니다. 하단 색상을 지정하지 않으면 상단 색상과 동일하게 간주됩니다. 올바른 색상을 지정하지 않으면 상단 색상과 동일하게 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="e08ef974a3e7bb738b48f0eeaf9b9216a6d5c063" translate="yes" xml:space="preserve">
          <source>One to four occurrences of &lt;a href=&quot;#length&quot;&gt;Length&lt;/a&gt;, specifying the top, right, bottom, and left edges of a box, respectively. If the left length is not specified, it is taken to be the same as the right length. If the bottom length is not specified, is it taken to be the same as the top length. If the right length is not specified, it is taken to be the same as the top length.</source>
          <target state="translated">상자의 위쪽, 오른쪽, 아래쪽 및 왼쪽 가장자리를 각각 지정하여 &lt;a href=&quot;#length&quot;&gt;길이가&lt;/a&gt; 1 ~ 4 회 발생 합니다. 왼쪽 길이를 지정하지 않으면 오른쪽 길이와 동일하게됩니다. 하단 길이를 지정하지 않으면 상단 길이와 동일하게 설정됩니다. 올바른 길이를 지정하지 않으면 상단 길이와 동일하게 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="9220babe6f3a70b8d5b5612d29dbd17f818f7bdc" translate="yes" xml:space="preserve">
          <source>One to four occurrences of &lt;a href=&quot;stylesheet-reference#brush&quot;&gt;Brush&lt;/a&gt;, specifying the top, right, bottom, and left edges of a box, respectively. If the left color is not specified, it is taken to be the same as the right color. If the bottom color is not specified, it is taken to be the same as the top color. If the right color is not specified, it is taken to be the same as the top color.</source>
          <target state="translated">One to four occurrences of &lt;a href=&quot;stylesheet-reference#brush&quot;&gt;Brush&lt;/a&gt;, specifying the top, right, bottom, and left edges of a box, respectively. If the left color is not specified, it is taken to be the same as the right color. If the bottom color is not specified, it is taken to be the same as the top color. If the right color is not specified, it is taken to be the same as the top color.</target>
        </trans-unit>
        <trans-unit id="6f4ef6e9747b60abe4a589c97596b08fe59a21e0" translate="yes" xml:space="preserve">
          <source>One to four occurrences of &lt;a href=&quot;stylesheet-reference#length&quot;&gt;Length&lt;/a&gt;, specifying the top, right, bottom, and left edges of a box, respectively. If the left length is not specified, it is taken to be the same as the right length. If the bottom length is not specified, is it taken to be the same as the top length. If the right length is not specified, it is taken to be the same as the top length.</source>
          <target state="translated">One to four occurrences of &lt;a href=&quot;stylesheet-reference#length&quot;&gt;Length&lt;/a&gt;, specifying the top, right, bottom, and left edges of a box, respectively. If the left length is not specified, it is taken to be the same as the right length. If the bottom length is not specified, is it taken to be the same as the top length. If the right length is not specified, it is taken to be the same as the top length.</target>
        </trans-unit>
        <trans-unit id="bb13534be607b594e5d4fd2e50c8a12cd963a1b5" translate="yes" xml:space="preserve">
          <source>One way to define these preprocessor symbols globally for your application is to add the following entry to your &lt;a href=&quot;qmake-project-files&quot;&gt;qmake project file&lt;/a&gt;:</source>
          <target state="translated">응용 프로그램에 대해 이러한 전 처리기 기호를 전체적으로 정의하는 한 가지 방법은 &lt;a href=&quot;qmake-project-files&quot;&gt;qmake 프로젝트 파일에&lt;/a&gt; 다음 항목을 추가하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="223f7c148d75ac21a0035b635145d191f7358d4e" translate="yes" xml:space="preserve">
          <source>One way to do this is to add translation support to a non-Qt class using the &lt;a href=&quot;qcoreapplication#Q_DECLARE_TR_FUNCTIONS&quot;&gt;Q_DECLARE_TR_FUNCTIONS&lt;/a&gt;() macro; for example:</source>
          <target state="translated">이를 수행하는 한 가지 방법은 &lt;a href=&quot;qcoreapplication#Q_DECLARE_TR_FUNCTIONS&quot;&gt;Q_DECLARE_TR_FUNCTIONS&lt;/a&gt; () 매크로를 사용하여 비 Qt 클래스에 번역 지원을 추가하는 것입니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e8dad5716f44bbc2825b993d58097ca36e3e569" translate="yes" xml:space="preserve">
          <source>One way to initialize a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; is simply to pass a &lt;code&gt;const char *&lt;/code&gt; to its constructor. For example, the following code creates a byte array of size 5 containing the data &quot;Hello&quot;:</source>
          <target state="translated">&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 를 초기화하는 한 가지 방법 은 &lt;code&gt;const char *&lt;/code&gt; 를 생성자 에 전달하는 것 입니다. 예를 들어 다음 코드는 &quot;Hello&quot;데이터를 포함하는 크기 5의 바이트 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2ba2f1cc0f79034b36c2a103783eeb702b2a12a0" translate="yes" xml:space="preserve">
          <source>One way to initialize a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; is simply to pass a &lt;code&gt;const char *&lt;/code&gt; to its constructor. For example, the following code creates a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; of size 5 containing the data &quot;Hello&quot;:</source>
          <target state="translated">&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 을 초기화하는 한 가지 방법 은 &lt;code&gt;const char *&lt;/code&gt; 를 생성자 에 전달하는 것 입니다. 예를 들어 다음 코드 는 &quot;Hello&quot;데이터를 포함하는 크기 5 의 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="21edb82cfb16a143db2707df33bbc9fa1da4fcca" translate="yes" xml:space="preserve">
          <source>One way to initialize a QByteArray is simply to pass a &lt;code&gt;const char *&lt;/code&gt; to its constructor. For example, the following code creates a byte array of size 5 containing the data &quot;Hello&quot;:</source>
          <target state="translated">One way to initialize a QByteArray is simply to pass a &lt;code&gt;const char *&lt;/code&gt; to its constructor. For example, the following code creates a byte array of size 5 containing the data &quot;Hello&quot;:</target>
        </trans-unit>
        <trans-unit id="799283615a57ad8aa2e0c7ebda730539d150f466" translate="yes" xml:space="preserve">
          <source>One way to initialize a QString is simply to pass a &lt;code&gt;const char *&lt;/code&gt; to its constructor. For example, the following code creates a QString of size 5 containing the data &quot;Hello&quot;:</source>
          <target state="translated">One way to initialize a QString is simply to pass a &lt;code&gt;const char *&lt;/code&gt; to its constructor. For example, the following code creates a QString of size 5 containing the data &quot;Hello&quot;:</target>
        </trans-unit>
        <trans-unit id="cb26e00428206c5a087e4bd954ff814ca5ff8b6c" translate="yes" xml:space="preserve">
          <source>One way to speed up the &lt;code&gt;FillContains&lt;/code&gt; check is to generate an approximate outline with as few points as possible, place that in a transparent Shape on top, and add your Pointer Handlers to that, so that the containment check is cheaper during event delivery.</source>
          <target state="translated">&lt;code&gt;FillContains&lt;/code&gt; 검사 속도를 높이는 한 가지 방법 은 가능한 한 적은 수의 점으로 대략적인 개요를 생성하고 투명한 모양 위에 배치하고 포인터 처리기를 추가하여 이벤트 전달 중에 봉쇄 검사가 더 저렴하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0f3ae55a89898820823b772b68d03c22e2bd821c" translate="yes" xml:space="preserve">
          <source>One-line text editor</source>
          <target state="translated">한 줄 텍스트 편집기</target>
        </trans-unit>
        <trans-unit id="e59fd204b822f9c79f6aef0a50f084bf2214e1f8" translate="yes" xml:space="preserve">
          <source>One-shot auto focus mode.</source>
          <target state="translated">원샷 자동 초점 모드.</target>
        </trans-unit>
        <trans-unit id="8eb5dfce967d8a943c9326524741741275b32898" translate="yes" xml:space="preserve">
          <source>Online Installation</source>
          <target state="translated">온라인 설치</target>
        </trans-unit>
        <trans-unit id="e8fd5f2a0f9df3ef30bb295e56ff9a4f6501e8fd" translate="yes" xml:space="preserve">
          <source>Online geocoding is supported.</source>
          <target state="translated">온라인 지오 코딩이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6e94f4a22f48e532df16fc87be0d43fcc763a463" translate="yes" xml:space="preserve">
          <source>Online mapping is supported.</source>
          <target state="translated">온라인 매핑이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="37985b6e22c37ff83b1855d037ac0df9c2c84bf9" translate="yes" xml:space="preserve">
          <source>Online navigation is supported.</source>
          <target state="translated">온라인 탐색이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="af889436cf506e074df27705b4cc0b25fff47cab" translate="yes" xml:space="preserve">
          <source>Online places is supported.</source>
          <target state="translated">온라인 장소가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9f7147cd02926e21fb68213a11cbb540adb516aa" translate="yes" xml:space="preserve">
          <source>Online routing is supported.</source>
          <target state="translated">온라인 라우팅이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4f153935e68f74bbea5e8fc6ce480ca9811c1d7d" translate="yes" xml:space="preserve">
          <source>Only &quot;http&quot;-&amp;gt;&quot;http&quot;, &quot;http&quot; -&amp;gt; &quot;https&quot; or &quot;https&quot; -&amp;gt; &quot;https&quot; redirects are allowed. Equivalent to setting the old &lt;a href=&quot;qnetworkrequest#Attribute-enum&quot;&gt;FollowRedirectsAttribute&lt;/a&gt; to true</source>
          <target state="translated">&quot;http&quot;-&amp;gt; &quot;http&quot;, &quot;http&quot;-&amp;gt; &quot;https&quot;또는 &quot;https&quot;-&amp;gt; &quot;https&quot;리디렉션 만 허용됩니다. 이전 &lt;a href=&quot;qnetworkrequest#Attribute-enum&quot;&gt;FollowRedirectsAttribute&lt;/a&gt; 를 true 로 설정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="061c38f429d66e7bd7c7707bdeffdb4473422e38" translate="yes" xml:space="preserve">
          <source>Only &quot;plain data&quot; can be returned from JavaScript as the result value. Supported data types include all of the JSON data types as well as, for example, &lt;code&gt;Date&lt;/code&gt; and &lt;code&gt;ArrayBuffer&lt;/code&gt;. Unsupported data types include, for example, &lt;code&gt;Function&lt;/code&gt; and &lt;code&gt;Promise&lt;/code&gt;.</source>
          <target state="translated">JavaScript에서는 &quot;일반 데이터&quot;만 결과 값으로 반환 될 수 있습니다. 지원되는 데이터 유형에는 모든 JSON 데이터 유형뿐만 아니라 &lt;code&gt;Date&lt;/code&gt; 및 &lt;code&gt;ArrayBuffer&lt;/code&gt; 가 포함 됩니다. 지원되지 않는 데이터 유형은 예를 들어 &lt;code&gt;Function&lt;/code&gt; 및 &lt;code&gt;Promise&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d0cba37af2614a4e4f6ddf0c51d2fcd4cf170760" translate="yes" xml:space="preserve">
          <source>Only &lt;a href=&quot;#QtMsgType-enum&quot;&gt;QtWarningMsg&lt;/a&gt; and &lt;a href=&quot;#QtMsgType-enum&quot;&gt;QtFatalMsg&lt;/a&gt; are used. The former identifies a compile or runtime warning, while the latter identifies a dynamic or static error.</source>
          <target state="translated">만 &lt;a href=&quot;#QtMsgType-enum&quot;&gt;QtWarningMsg&lt;/a&gt; 및 &lt;a href=&quot;#QtMsgType-enum&quot;&gt;QtFatalMsg이&lt;/a&gt; 사용된다. 전자는 컴파일 또는 런타임 경고를 식별하고 후자는 동적 또는 정적 오류를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="5a7eec6f52e281f42b54e3d9ce6ff843282aa29e" translate="yes" xml:space="preserve">
          <source>Only &lt;a href=&quot;#QtMsgType-enum&quot;&gt;QtWarningMsg&lt;/a&gt; and &lt;a href=&quot;#QtMsgType-enum&quot;&gt;QtFatalMsg&lt;/a&gt; are used. The former identifies a warning, while the latter identifies an error.</source>
          <target state="translated">만 &lt;a href=&quot;#QtMsgType-enum&quot;&gt;QtWarningMsg&lt;/a&gt; 및 &lt;a href=&quot;#QtMsgType-enum&quot;&gt;QtFatalMsg이&lt;/a&gt; 사용된다. 전자는 경고를, 후자는 오류를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="00c0225557dcf5a66aeb0575fed3923085b73ec8" translate="yes" xml:space="preserve">
          <source>Only &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; uses &lt;a href=&quot;qabstractsocket&quot;&gt;QAbstractSocket&lt;/a&gt;'s internal buffer; &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt; does not use any buffering at all, but rather relies on the implicit buffering provided by the operating system. Because of this, calling this function on &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt; has no effect.</source>
          <target state="translated">전용 &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket는&lt;/a&gt; 사용 &lt;a href=&quot;qabstractsocket&quot;&gt;QAbstractSocket&lt;/a&gt; 의 내부 버퍼; &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt; 은 전혀 버퍼링을 사용하지 않고 운영 체제가 제공하는 암시 적 버퍼링에 의존합니다. 이 때문에 &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt; 에서이 함수를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8d62165147d05535990621a2783f3138e216fb36" translate="yes" xml:space="preserve">
          <source>Only &lt;a href=&quot;qtglobal#QtMsgType-enum&quot;&gt;QtWarningMsg&lt;/a&gt; and &lt;a href=&quot;qtglobal#QtMsgType-enum&quot;&gt;QtFatalMsg&lt;/a&gt; are used. The former identifies a compile or runtime warning, while the latter identifies a dynamic or static error.</source>
          <target state="translated">Only &lt;a href=&quot;qtglobal#QtMsgType-enum&quot;&gt;QtWarningMsg&lt;/a&gt; and &lt;a href=&quot;qtglobal#QtMsgType-enum&quot;&gt;QtFatalMsg&lt;/a&gt; are used. The former identifies a compile or runtime warning, while the latter identifies a dynamic or static error.</target>
        </trans-unit>
        <trans-unit id="7f8c37834884229bafc71300d1750d7bb47699c9" translate="yes" xml:space="preserve">
          <source>Only &lt;a href=&quot;qtglobal#QtMsgType-enum&quot;&gt;QtWarningMsg&lt;/a&gt; and &lt;a href=&quot;qtglobal#QtMsgType-enum&quot;&gt;QtFatalMsg&lt;/a&gt; are used. The former identifies a warning, while the latter identifies an error.</source>
          <target state="translated">Only &lt;a href=&quot;qtglobal#QtMsgType-enum&quot;&gt;QtWarningMsg&lt;/a&gt; and &lt;a href=&quot;qtglobal#QtMsgType-enum&quot;&gt;QtFatalMsg&lt;/a&gt; are used. The former identifies a warning, while the latter identifies an error.</target>
        </trans-unit>
        <trans-unit id="5102c1754518c4338955afd409dc169f702e8585" translate="yes" xml:space="preserve">
          <source>Only OpenGL ES 2</source>
          <target state="translated">OpenGL ES 2 만</target>
        </trans-unit>
        <trans-unit id="7243dc9588e7d32cd89d22c4fd52510a4994cbe2" translate="yes" xml:space="preserve">
          <source>Only Shape layer supported</source>
          <target state="translated">모양 레이어 만 지원</target>
        </trans-unit>
        <trans-unit id="997fa52e769e0a4d59c8365090166ca6b5927b69" translate="yes" xml:space="preserve">
          <source>Only Signals and Slots May Appear in the &lt;code&gt;signals&lt;/code&gt; and &lt;code&gt;slots&lt;/code&gt; Sections of a Class</source>
          <target state="translated">신호 및 슬롯 만 클래스 의 &lt;code&gt;signals&lt;/code&gt; 및 &lt;code&gt;slots&lt;/code&gt; 섹션에 나타날 수 있습니다</target>
        </trans-unit>
        <trans-unit id="3319c794abcdb28819b733bc2a2b0abb219f6fcf" translate="yes" xml:space="preserve">
          <source>Only a given</source>
          <target state="translated">주어진 것만</target>
        </trans-unit>
        <trans-unit id="a06c7e81c93a88a08338ca6aec75092f1ff90cec" translate="yes" xml:space="preserve">
          <source>Only a partial</source>
          <target state="translated">일부만</target>
        </trans-unit>
        <trans-unit id="7f046cd2892da95841135a185cd4f4e6ea1db36d" translate="yes" xml:space="preserve">
          <source>Only a single instance of this characteristic exists as part of a HID Service.</source>
          <target state="translated">이 특성의 단일 인스턴스 만 HID 서비스의 일부로 존재합니다.</target>
        </trans-unit>
        <trans-unit id="01749c411894106bfeb3addcbe0e8ae80d152af4" translate="yes" xml:space="preserve">
          <source>Only a subset of the properties in &lt;a href=&quot;qtextcharformat&quot;&gt;QTextCharFormat&lt;/a&gt; are used by the calendar widget. Currently, the foreground, background and font properties are used to determine the rendering of individual cells in the widget.</source>
          <target state="translated">캘린더 위젯은 &lt;a href=&quot;qtextcharformat&quot;&gt;QTextCharFormat&lt;/a&gt; 의 속성 중 일부만 사용합니다. 현재 전경, 배경 및 글꼴 속성은 위젯에서 개별 셀의 렌더링을 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7966f02e32af2bc52e892f9d86b8be70ebe8ac04" translate="yes" xml:space="preserve">
          <source>Only active items can gain input focus.</source>
          <target state="translated">활성 항목 만 입력 초점을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bb8d0321ed54742c0b1fc91a7b2d143bab06e67" translate="yes" xml:space="preserve">
          <source>Only allow the hostUrl to be set to a QtRO supported schema. This is the default value, and causes a Node error to be set if an unrecognized schema is provided.</source>
          <target state="translated">hostUrl 만 QtRO 지원 스키마로 설정하십시오. 이것이 기본값이며 인식 할 수없는 스키마가 제공되면 노드 오류가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="34cf96d4b14226df0b6ec792d6c4e3c938d7f8d6" translate="yes" xml:space="preserve">
          <source>Only back-facing triangles will be picked.</source>
          <target state="translated">후면 삼각형 만 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="acebd9b91d2a9373d89a75b647d1a05167876851" translate="yes" xml:space="preserve">
          <source>Only characters suitable for URLs are allowed.</source>
          <target state="translated">URL에 적합한 문자 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a6559e1245f41618e379cc4cfccde656e9462111" translate="yes" xml:space="preserve">
          <source>Only characters suitable for email addresses are allowed.</source>
          <target state="translated">이메일 주소에 적합한 문자 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="16b980c1676a070c2f8ef9d269147dba31003618" translate="yes" xml:space="preserve">
          <source>Only characters suitable for phone dialing are allowed.</source>
          <target state="translated">전화 걸기에 적합한 문자 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="e62882708034c57573cdd9e7f3b5f6cda8b08829" translate="yes" xml:space="preserve">
          <source>Only checkable actions can be checked. By default, this is false (the action is unchecked).</source>
          <target state="translated">점검 가능한 조치 만 점검 할 수 있습니다. 기본적으로 이것은 false입니다 (작업은 선택 해제되어 있음).</target>
        </trans-unit>
        <trans-unit id="d1df5af120516c42a3e9ca0be1b2c450f2973529" translate="yes" xml:space="preserve">
          <source>Only checkable buttons can be checked. By default, the button is unchecked.</source>
          <target state="translated">확인 가능한 버튼 만 확인할 수 있습니다. 기본적으로이 버튼은 선택되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9dc3b4af8780ed2b7244ae6ca4a682fbaa668e3" translate="yes" xml:space="preserve">
          <source>Only dialable input is allowed.</source>
          <target state="translated">다이얼 가능한 입력 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c8bebe53e929796679027326ec01f32cb9eca399" translate="yes" xml:space="preserve">
          <source>Only digits are allowed.</source>
          <target state="translated">숫자 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="344ffbc8b5ed91b54430eb6da6076aa5951e7cbc" translate="yes" xml:space="preserve">
          <source>Only display the icon.</source>
          <target state="translated">아이콘 만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="4c3c090015e545870f3cb11a2c51d47e8b827f0a" translate="yes" xml:space="preserve">
          <source>Only display the text.</source>
          <target state="translated">텍스트 만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="35eed40534af6dd7588605a96b90a6fea480866e" translate="yes" xml:space="preserve">
          <source>Only dither to indexed formats if the source image uses more different colors than the size of the color table of the destination format.</source>
          <target state="translated">소스 이미지가 대상 형식의 색상 표 크기와 다른 색상을 사용하는 경우에만 색인 형식으로 디더링하십시오.</target>
        </trans-unit>
        <trans-unit id="b3901def538061843c03f3797f5d3105889c2004" translate="yes" xml:space="preserve">
          <source>Only editable combo boxes have a line edit.</source>
          <target state="translated">편집 가능한 콤보 상자에만 줄 편집이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c2502f7d0a3edec7872a1fb7ab692c740e95d69" translate="yes" xml:space="preserve">
          <source>Only enabled items that set the &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt; flag can accept keyboard focus.</source>
          <target state="translated">&lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt; 플래그 를 설정 한 활성화 된 항목 만 키보드 포커스를 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c33f03b42aa5debac6e83482f764721b5e9a84b7" translate="yes" xml:space="preserve">
          <source>Only flat models (lists and tables) are supported, tree models are not.</source>
          <target state="translated">플랫 모델 (목록 및 테이블) 만 지원되며 트리 모델은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0886825525b27aef071d1d36dd9891332bc3c4d" translate="yes" xml:space="preserve">
          <source>Only for IPv6</source>
          <target state="translated">IPv6 전용</target>
        </trans-unit>
        <trans-unit id="0f7a6704e7a0ad432fcc65a63542d5bd64d35dd7" translate="yes" xml:space="preserve">
          <source>Only front-facing triangles will be picked (default).</source>
          <target state="translated">정면 삼각형 만 선택됩니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="1d349dcca0926ada1d5bba06ff5e98f26d653fbe" translate="yes" xml:space="preserve">
          <source>Only function names are returned.</source>
          <target state="translated">함수 이름 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5392b2ac53d6221666603d531f0410a99bf89ae2" translate="yes" xml:space="preserve">
          <source>Only integer frame-mode of a timeline supported (real frame numbers and time are rounded to the nearest integer)</source>
          <target state="translated">타임 라인의 정수 프레임 모드 만 지원됩니다 (실제 프레임 번호와 시간은 가장 가까운 정수로 반올림 됨)</target>
        </trans-unit>
        <trans-unit id="44948f37bb4db4bd9a2aed10375dc786efd3cadf" translate="yes" xml:space="preserve">
          <source>Only items that &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquickcontrols-chattutorial-example.html#stackview&quot;&gt;StackView&lt;/a&gt; created itself (from a &lt;a href=&quot;qml-qtqml-component&quot;&gt;Component&lt;/a&gt; or &lt;a href=&quot;qml-url&quot;&gt;url&lt;/a&gt;) will be destroyed when popped. See &lt;a href=&quot;qml-qtquick-controls2-stackview#item-ownership&quot;&gt;Item Ownership&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;qml-qtqml-component&quot;&gt;구성 요소&lt;/a&gt; 또는 &lt;a href=&quot;qml-url&quot;&gt;url&lt;/a&gt; 에서 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquickcontrols-chattutorial-example.html#stackview&quot;&gt;StackView&lt;/a&gt; 자체가 생성 한 항목 만 팝업되면 삭제됩니다. 자세한 내용은 &lt;a href=&quot;qml-qtquick-controls2-stackview#item-ownership&quot;&gt;항목 소유권&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3998088fb6af63aa5c0c0ef06eddae85f39c3d51" translate="yes" xml:space="preserve">
          <source>Only items that &lt;a href=&quot;qml-qtquick-controls2-stackview&quot;&gt;StackView&lt;/a&gt; created itself (from a &lt;a href=&quot;qml-qtqml-component&quot;&gt;Component&lt;/a&gt; or &lt;a href=&quot;qml-url&quot;&gt;url&lt;/a&gt;) will be destroyed when popped. See &lt;a href=&quot;qml-qtquick-controls2-stackview#item-ownership&quot;&gt;Item Ownership&lt;/a&gt; for more information.</source>
          <target state="translated">Only items that &lt;a href=&quot;qml-qtquick-controls2-stackview&quot;&gt;StackView&lt;/a&gt; created itself (from a &lt;a href=&quot;qml-qtqml-component&quot;&gt;Component&lt;/a&gt; or &lt;a href=&quot;qml-url&quot;&gt;url&lt;/a&gt;) will be destroyed when popped. See &lt;a href=&quot;qml-qtquick-controls2-stackview#item-ownership&quot;&gt;Item Ownership&lt;/a&gt; for more information.</target>
        </trans-unit>
        <trans-unit id="e49b7559c25c57197a502aeb074f2038159cfe2a" translate="yes" xml:space="preserve">
          <source>Only items that &lt;a href=&quot;qtquickcontrols-changes-qt6#stackview&quot;&gt;StackView&lt;/a&gt; created itself (from a &lt;a href=&quot;qml-qtqml-component&quot;&gt;Component&lt;/a&gt; or &lt;a href=&quot;qml-url&quot;&gt;url&lt;/a&gt;) will be destroyed when popped. See &lt;a href=&quot;qml-qtquick-controls2-stackview#item-ownership&quot;&gt;Item Ownership&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;qtquickcontrols-changes-qt6#stackview&quot;&gt;StackView&lt;/a&gt; 가 자체적으로 생성 한 항목 ( &lt;a href=&quot;qml-qtqml-component&quot;&gt;Component&lt;/a&gt; 또는 &lt;a href=&quot;qml-url&quot;&gt;url에서&lt;/a&gt; ) 만 팝될 때 파괴됩니다. 자세한 내용은 &lt;a href=&quot;qml-qtquick-controls2-stackview#item-ownership&quot;&gt;항목 소유권&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9e37f535e5c62f28a9a6e9ecae26a61dad1f62b3" translate="yes" xml:space="preserve">
          <source>Only items that are children of the &lt;a href=&quot;qml-qtquick-layouts-stacklayout&quot;&gt;StackLayout&lt;/a&gt; will be candidates for layouting.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-layouts-stacklayout&quot;&gt;StackLayout의&lt;/a&gt; 하위 항목 만 레이아웃 후보가됩니다.</target>
        </trans-unit>
        <trans-unit id="c9dfd3fb5bd8ed2bd6a32f48ee311389249f3218" translate="yes" xml:space="preserve">
          <source>Only items that belong to this group are visible to a view.</source>
          <target state="translated">이 그룹에 속하는 항목 만보기에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c8168ea033dd3d3d177585811115776bae643be6" translate="yes" xml:space="preserve">
          <source>Only items that set the &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt; flag, or widgets that set an appropriate focus policy, can accept keyboard focus.</source>
          <target state="translated">&lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt; 플래그 를 설정하는 항목 또는 적절한 초점 정책을 설정하는 위젯 만 키보드 초점을 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbbfc9d955628abe0b8994e7bc9e7fedd9ddf0eb" translate="yes" xml:space="preserve">
          <source>Only items which specify &lt;a href=&quot;qquickitem#Flag-enum&quot;&gt;QQuickItem::ItemHasContents&lt;/a&gt; are allowed to call QQuickItem::update().</source>
          <target state="translated">&lt;a href=&quot;qquickitem#Flag-enum&quot;&gt;QQuickItem :: ItemHasContents&lt;/a&gt; 를 지정하는 항목 만 QQuickItem :: update ()를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="547bf1587da62d5bef95920f2782ef465d057ee4" translate="yes" xml:space="preserve">
          <source>Only latin based input is allowed.</source>
          <target state="translated">라틴 기반 입력 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a4047b356fb29b5d84e935cb033fa90fbb1fe809" translate="yes" xml:space="preserve">
          <source>Only list .qrc file entries, do not generate code.</source>
          <target state="translated">.qrc 파일 항목 만 나열하고 코드를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d5482ecc95a82b6bfe1ed407a6c99d94d7e0da1c" translate="yes" xml:space="preserve">
          <source>Only list files that have been modified (ignored on Unix).</source>
          <target state="translated">수정 된 파일 만 나열하십시오 (Unix에서 무시).</target>
        </trans-unit>
        <trans-unit id="4ceaf763a33bcb125b8cfb24f1e36ffac2200774" translate="yes" xml:space="preserve">
          <source>Only lower case letter input is allowed.</source>
          <target state="translated">소문자 입력 만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="9862f27489035178e0538dccef177ac6a28c837d" translate="yes" xml:space="preserve">
          <source>Only match to a standard page size if the sizes match exactly.</source>
          <target state="translated">크기가 정확히 일치하는 경우에만 표준 페이지 크기와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c0d71635cf00a59e98c2eda6c62ad5991c0deb65" translate="yes" xml:space="preserve">
          <source>Only network configurations of type &lt;a href=&quot;qnetworkconfiguration#Type-enum&quot;&gt;ServiceNetwork&lt;/a&gt; can have children. Otherwise this function returns an empty list.</source>
          <target state="translated">&lt;a href=&quot;qnetworkconfiguration#Type-enum&quot;&gt;ServiceNetwork&lt;/a&gt; 유형의 네트워크 구성 만 하위를 가질 수 있습니다. 그렇지 않으면이 함수는 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="81e7ce30d833f00e89b96b50ef1962325eacb9ba" translate="yes" xml:space="preserve">
          <source>Only nodes of type &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;ElementNode&lt;/a&gt; or &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;AttributeNode&lt;/a&gt; can have namespaces. A namespace URI must be specified at creation time and cannot be changed later.</source>
          <target state="translated">&lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;ElementNode&lt;/a&gt; 또는 &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;AttributeNode&lt;/a&gt; 유형의 노드 만 네임 스페이스를 가질 수 있습니다. 네임 스페이스 URI는 생성시 지정해야하며 나중에 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="08af18848d1be9d81cb5216c9a56e01e3ae655d6" translate="yes" xml:space="preserve">
          <source>Only nodes of type &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;ElementNode&lt;/a&gt; or &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;AttributeNode&lt;/a&gt; can have namespaces. A namespace must have been specified at creation time; it is not possible to add a namespace afterwards.</source>
          <target state="translated">&lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;ElementNode&lt;/a&gt; 또는 &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;AttributeNode&lt;/a&gt; 유형의 노드 만 네임 스페이스를 가질 수 있습니다. 작성시 네임 스페이스가 지정되어 있어야합니다. 나중에 네임 스페이스를 추가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a49b9e1f13cc73159d3efb2e4bd7e96e1b0d5c8f" translate="yes" xml:space="preserve">
          <source>Only nodes of type &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;ElementNode&lt;/a&gt; or &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;AttributeNode&lt;/a&gt; can have namespaces. A namespace prefix must be specified at creation time. If a node was created with a namespace prefix, you can change it later with &lt;a href=&quot;qdomnode#setPrefix&quot;&gt;setPrefix&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;ElementNode&lt;/a&gt; 또는 &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;AttributeNode&lt;/a&gt; 유형의 노드 만 네임 스페이스를 가질 수 있습니다. 작성시 네임 스페이스 접 두부를 지정해야합니다. 네임 스페이스 접두사를 사용하여 노드를 만든 경우 나중에 &lt;a href=&quot;qdomnode#setPrefix&quot;&gt;setPrefix&lt;/a&gt; ()를 사용 하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4229d3dfaba3b86156753fc6e1e4cf70a2dc792f" translate="yes" xml:space="preserve">
          <source>Only nodes of type &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;ElementNode&lt;/a&gt; or &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;AttributeNode&lt;/a&gt; can have namespaces. A namespace prefix must have be specified at creation time; it is not possible to add a namespace prefix afterwards.</source>
          <target state="translated">&lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;ElementNode&lt;/a&gt; 또는 &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;AttributeNode&lt;/a&gt; 유형의 노드 만 네임 스페이스를 가질 수 있습니다. 네임 스페이스 접두사는 작성시 지정해야합니다. 나중에 네임 스페이스 접두사를 추가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="db7d2b4b74d3f19d24ab1738b1cd3550761be1cb" translate="yes" xml:space="preserve">
          <source>Only number input is allowed. This includes decimal point and minus sign.</source>
          <target state="translated">숫자 입력 만 허용됩니다. 여기에는 소수점과 빼기 부호가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bd3f064c7188629f6eedfba5abfa3b90080fc85c" translate="yes" xml:space="preserve">
          <source>Only numeric input is allowed.</source>
          <target state="translated">숫자 입력 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9d9b5680177318989bd0ac87a5b746c5fe565830" translate="yes" xml:space="preserve">
          <source>Only on X11, when a tooltip is requested, the &lt;a href=&quot;qsystemtrayicon&quot;&gt;QSystemTrayIcon&lt;/a&gt; receives a &lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;. Additionally, the &lt;a href=&quot;qsystemtrayicon&quot;&gt;QSystemTrayIcon&lt;/a&gt; receives wheel events of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::Wheel&lt;/a&gt;. These are not supported on any other platform.</source>
          <target state="translated">툴팁이 요청되면 X11에서만 &lt;a href=&quot;qhelpevent&quot;&gt;QSystemTrayIcon&lt;/a&gt; 이 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: ToolTip&lt;/a&gt; 유형 의 &lt;a href=&quot;qsystemtrayicon&quot;&gt;QHelpEvent를&lt;/a&gt; 수신합니다 . 또한 &lt;a href=&quot;qsystemtrayicon&quot;&gt;QSystemTrayIcon&lt;/a&gt; 은 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: Wheel&lt;/a&gt; 유형의 휠 이벤트를 수신합니다 . 다른 플랫폼에서는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd4ac69624bdcf89eff22ef254a3a58f81cd50b9" translate="yes" xml:space="preserve">
          <source>Only on X11, when a tooltip is requested, the QSystemTrayIcon receives a &lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;. Additionally, the QSystemTrayIcon receives wheel events of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::Wheel&lt;/a&gt;. These are not supported on any other platform.</source>
          <target state="translated">Only on X11, when a tooltip is requested, the QSystemTrayIcon receives a &lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;. Additionally, the QSystemTrayIcon receives wheel events of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::Wheel&lt;/a&gt;. These are not supported on any other platform.</target>
        </trans-unit>
        <trans-unit id="c966c2e5c8671dd2923be1ef96b426246e45e1b7" translate="yes" xml:space="preserve">
          <source>Only one &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; implementation may be instantiated and exported by an ActiveX server application. This instance is accessible through the global qAxFactory() function.</source>
          <target state="translated">ActiveX 서버 응용 프로그램에서 하나의 &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; 구현 만 인스턴스화하고 내보낼 수 있습니다. 이 인스턴스는 글로벌 qAxFactory () 함수를 통해 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e86f4ac4cc6b87c39c80af06e95ad366bf44a46" translate="yes" xml:space="preserve">
          <source>Only one &lt;a href=&quot;qwebengineprofile&quot;&gt;QWebEngineProfile&lt;/a&gt; can do this at a time, and it is recommended that the profile fullfilling this role has a disk HTTP cache to avoid needlessly re-downloading. If you set the option on a second profile, it will be disabled on the profile it is currently set.</source>
          <target state="translated">한 번에 하나의 &lt;a href=&quot;qwebengineprofile&quot;&gt;QWebEngineProfile&lt;/a&gt; 만이 작업을 수행 할 수 있으며,이 역할을 가득 채우는 프로파일에는 불필요하게 다시 다운로드하지 않도록 디스크 HTTP 캐시가있는 것이 좋습니다. 두 번째 프로필에서 옵션을 설정하면 현재 설정된 프로필에서 해당 옵션이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="e4c11af563f43ba6ea402c5a014c8f73ee682437" translate="yes" xml:space="preserve">
          <source>Only one Item can be a direct child of the &lt;a href=&quot;qml-qtquick-controls-scrollview&quot;&gt;ScrollView&lt;/a&gt; and the child is implicitly anchored to fill the scroll view.</source>
          <target state="translated">하나의 항목 만 &lt;a href=&quot;qml-qtquick-controls-scrollview&quot;&gt;ScrollView&lt;/a&gt; 의 직접적인 자식이 될 수 있으며 자식은 암시 적으로 스크롤 뷰를 채우도록 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="f542304090a05129257a2d09dd30d295babc28b1" translate="yes" xml:space="preserve">
          <source>Only one Item can be a direct child of the ScrollView and the child is implicitly anchored to fill the scroll view.</source>
          <target state="translated">하나의 항목 만 ScrollView의 직접 자식이 될 수 있으며 자식은 암시 적으로 고정되어 스크롤보기를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="3fb2cbfddfa2c8422a7f938e2864206f53db7379" translate="yes" xml:space="preserve">
          <source>Only one QAxFactory implementation may be instantiated and exported by an ActiveX server application. This instance is accessible through the global qAxFactory() function.</source>
          <target state="translated">ActiveX 서버 응용 프로그램에서 하나의 QAxFactory 구현 만 인스턴스화하고 내보낼 수 있습니다. 이 인스턴스는 전역 qAxFactory () 함수를 통해 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="292e949684a8f6c4b156ae93709d421ea5f0395b" translate="yes" xml:space="preserve">
          <source>Only one active client per process is permitted. Subsequent clients attempting to connect to the server will see a loading indicator until the previous client disconnects.</source>
          <target state="translated">프로세스 당 하나의 활성 클라이언트 만 허용됩니다. 서버에 연결하려는 후속 클라이언트는 이전 클라이언트의 연결이 끊어 질 때까지로드 표시기를 보게됩니다.</target>
        </trans-unit>
        <trans-unit id="c14a4f82853654d11a23a22cc141c5f953167116" translate="yes" xml:space="preserve">
          <source>Only one bar can be selected at a time.</source>
          <target state="translated">한 번에 하나의 막대 만 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2248a190c0d660c4e6fafd48299f24aadeb660a0" translate="yes" xml:space="preserve">
          <source>Only one buddy widget can be defined for each label. To change the buddy used, it is necessary to delete any existing buddy connection before you create a new one.</source>
          <target state="translated">각 레이블마다 하나의 친구 위젯 만 정의 할 수 있습니다. 사용 된 대화 상대를 변경하려면 새 대화 상대 연결을 작성하기 전에 기존 대화 상대 연결을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="b837aab653c3f13381cebe1c32aa58e3fc22bcd1" translate="yes" xml:space="preserve">
          <source>Only one header section</source>
          <target state="translated">하나의 헤더 섹션</target>
        </trans-unit>
        <trans-unit id="c32ad496411f8470797a9d1405de91a586a1592b" translate="yes" xml:space="preserve">
          <source>Only one initial value will be saved for any given property. If a value for a property has already been saved by the state machine, it will not be overwritten until the property has been successfully restored.</source>
          <target state="translated">주어진 속성에 대해 하나의 초기 값 만 저장됩니다. 상태 머신이 속성 값을 이미 저장 한 경우 속성이 성공적으로 복원 될 때까지 해당 값을 덮어 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56c4fb4a1b813dbde0f9b03691f0bcb74858feb3" translate="yes" xml:space="preserve">
          <source>Only one message handler can be defined, since this is usually done on an application-wide basis to control debug output.</source>
          <target state="translated">일반적으로 디버그 출력을 제어하기 위해 애플리케이션 전체에서 수행되므로 하나의 메시지 핸들러 만 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc87ea28a98ab006d46ca69cd53da1af243ce5d9" translate="yes" xml:space="preserve">
          <source>Only one mutable iterator can be active on a given hash at any time. Furthermore, no changes should be done directly to the hash while the iterator is active (as opposed to through the iterator), since this could invalidate the iterator and lead to undefined behavior.</source>
          <target state="translated">주어진 해시에서 언제든지 하나의 변경 가능한 반복자 만 활성화 할 수 있습니다. 또한 이터레이터가 활성화되어있는 동안 (이터레이터와 반대로) 해시를 직접 변경하면 안됩니다. 이터레이터는 무효화되고 정의되지 않은 동작이 발생할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c469cc338e6d0b9e955d25b2d6ead3b2a9ef65c3" translate="yes" xml:space="preserve">
          <source>Only one mutable iterator can be active on a given list at any time. Furthermore, no changes should be done directly to the list while the iterator is active (as opposed to through the iterator), since this could invalidate the iterator and lead to undefined behavior.</source>
          <target state="translated">주어진 목록에서 언제든지 하나의 변경 가능한 반복자 만 활성화 할 수 있습니다. 또한 이터레이터가 활성화되어있는 동안 (이터레이터와 반대되는) 목록을 직접 변경하면 안됩니다. 이터레이터가 무효화되고 정의되지 않은 동작이 발생할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="15df6c3f42b2f7115677be583aa34c4498d388ca" translate="yes" xml:space="preserve">
          <source>Only one mutable iterator can be active on a given map at any time. Furthermore, no changes should be done directly to the map while the iterator is active (as opposed to through the iterator), since this could invalidate the iterator and lead to undefined behavior.</source>
          <target state="translated">주어진 맵에서 언제든지 하나의 변경 가능한 반복자 만 활성화 할 수 있습니다. 또한 이터레이터가 활성화되어있는 동안 (이터레이터가 아닌) 맵을 직접 변경해서는 안됩니다. 이터레이터가 무효화되고 정의되지 않은 동작이 발생할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="5c64dda345ccabc4c3041144fe96e1a95beb363a" translate="yes" xml:space="preserve">
          <source>Only one mutable iterator can be active on a given set at any time. Furthermore, no changes should be done directly to the set while the iterator is active (as opposed to through the iterator), since this could invalidate the iterator and lead to undefined behavior.</source>
          <target state="translated">주어진 세트에서 언제든지 하나의 변경 가능한 반복자 만 활성화 할 수 있습니다. 또한 이터레이터가 활성화되어있는 동안 (이터레이터와 반대로) 세트를 직접 변경하지 않아야합니다. 이터레이터는 무효화되고 정의되지 않은 동작이 발생할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1830ab079be5c68c7386e6ec0031ce349b862861" translate="yes" xml:space="preserve">
          <source>Only one mutable iterator can be active on a given vector at any time. Furthermore, no changes should be done directly to the vector while the iterator is active (as opposed to through the iterator), since this could invalidate the iterator and lead to undefined behavior.</source>
          <target state="translated">주어진 벡터에서 언제든지 하나의 변경 가능한 반복자 만 활성화 할 수 있습니다. 또한 이터레이터가 활성화되어있는 동안 (이터레이터를 통하는 것과 달리) 벡터를 직접 변경하지 않아야합니다. 이터레이터는 무효화되고 정의되지 않은 동작이 발생할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1687e81a43679ccb19fe9f14a9cb45accf06cbac" translate="yes" xml:space="preserve">
          <source>Only one point can be selected at a time.</source>
          <target state="translated">한 번에 하나의 지점 만 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="093f87644501fdcc4886a90098fbd311f8306624" translate="yes" xml:space="preserve">
          <source>Only one scroll gesture can be active on a single object at the same time. If you call this function twice on the same object, it will ungrab the existing gesture before grabbing the new one.</source>
          <target state="translated">단일 객체에서 동시에 하나의 스크롤 제스처 만 활성화 할 수 있습니다. 같은 객체에서이 함수를 두 번 호출하면 새 제스처를 잡기 전에 기존 제스처를 풀게됩니다.</target>
        </trans-unit>
        <trans-unit id="66b250d5d0c68570b3f33abc58e8f0bac5ac63a9" translate="yes" xml:space="preserve">
          <source>Only one timeline should be active at a particular time.</source>
          <target state="translated">특정 시간에 하나의 타임 라인 만 활성화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2e4550eba5d2cb877022457af0a20f908987a632" translate="yes" xml:space="preserve">
          <source>Only one translation unit in a library or executable can define a category with a specific name. The implicitly defined &lt;a href=&quot;qloggingcategory&quot;&gt;QLoggingCategory&lt;/a&gt; object is created on first use, in a thread-safe manner.</source>
          <target state="translated">라이브러리 또는 실행 파일에서 하나의 번역 단위 만 특정 이름으로 범주를 정의 할 수 있습니다. 암시 적으로 정의 된 &lt;a href=&quot;qloggingcategory&quot;&gt;QLoggingCategory&lt;/a&gt; 오브젝트는 처음 사용시 스레드 안전 방식으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="431cfad90baeecf4e34d1ce46561784767bd5e2b" translate="yes" xml:space="preserve">
          <source>Only one translation unit in a library or executable can define a category with a specific name. The implicitly-defined &lt;a href=&quot;qloggingcategory&quot;&gt;QLoggingCategory&lt;/a&gt; object is created on first use, in a thread-safe manner.</source>
          <target state="translated">라이브러리 또는 실행 파일에서 하나의 번역 단위 만 특정 이름으로 범주를 정의 할 수 있습니다. 암시 적으로 정의 된 &lt;a href=&quot;qloggingcategory&quot;&gt;QLoggingCategory&lt;/a&gt; 개체는 스레드로부터 안전한 방식으로 처음 사용할 때 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5874588876a240484d30519201ad794f4662dd84" translate="yes" xml:space="preserve">
          <source>Only one-to-one mappings between sections and widgets are allowed. It is not possible to map a single section to multiple widgets, or to map a single widget to multiple sections.</source>
          <target state="translated">섹션과 위젯 간의 일대일 매핑 만 허용됩니다. 단일 섹션을 여러 위젯에 맵핑하거나 단일 위젯을 여러 섹션에 맵핑 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f2a45607d8658353b26735883f2e38c61635354a" translate="yes" xml:space="preserve">
          <source>Only options set by &lt;a href=&quot;qsslconfiguration#setBackendConfigurationOption&quot;&gt;setBackendConfigurationOption&lt;/a&gt;() or &lt;a href=&quot;qsslconfiguration#setBackendConfiguration&quot;&gt;setBackendConfiguration&lt;/a&gt;() will be returned. The internal standard configuration of the backend is not reported.</source>
          <target state="translated">&lt;a href=&quot;qsslconfiguration#setBackendConfigurationOption&quot;&gt;setBackendConfigurationOption&lt;/a&gt; () 또는 &lt;a href=&quot;qsslconfiguration#setBackendConfiguration&quot;&gt;setBackendConfiguration&lt;/a&gt; ()에 의해 설정된 옵션 만 리턴됩니다. 백엔드의 내부 표준 구성은보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4a5c6b841d6408cc1b09eaf7068ca617d6bfa3d" translate="yes" xml:space="preserve">
          <source>Only other popup widgets may be opened when a popup widget is shown. The popup widgets are organized in a stack. This function returns the active popup widget at the top of the stack.</source>
          <target state="translated">팝업 위젯이 표시되면 다른 팝업 위젯 만 열 수 있습니다. 팝업 위젯은 스택으로 구성됩니다. 이 함수는 스택 상단에 활성 팝업 위젯을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="866d723e76a41194ed02fe8b55eddeb99f66731f" translate="yes" xml:space="preserve">
          <source>Only output a mapping of resource paths to file system paths defined in the .qrc file, do not generate code.</source>
          <target state="translated">.qrc 파일에 정의 된 파일 시스템 경로에 대한 리소스 경로 매핑 만 출력하고 코드를 생성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3213412928a79f8f1d6dbe0ff3a3e452532e3d4" translate="yes" xml:space="preserve">
          <source>Only place details that are supported by this manager is present in the modified version. Manager specific data such as the place id, is not copied over from the</source>
          <target state="translated">이 관리자가 지원하는 장소 세부 정보 만 수정 된 버전으로 제공됩니다. 장소 ID와 같은 관리자 별 데이터는</target>
        </trans-unit>
        <trans-unit id="022afb059dd2523132844dbb94dc64522c374309" translate="yes" xml:space="preserve">
          <source>Only places stored on the local device will be part of the search results.</source>
          <target state="translated">로컬 장치에 저장된 장소 만 검색 결과의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="58dfa7ad56821797b65e4226af2c1b3e86ea2cd8" translate="yes" xml:space="preserve">
          <source>Only places that are private to the current user will be part of the search results.</source>
          <target state="translated">현재 사용자에게 비공개 인 장소 만 검색 결과에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ce754b83ce67299b26bccbd0672b437340fbf99e" translate="yes" xml:space="preserve">
          <source>Only places that are public will be part of the search results.</source>
          <target state="translated">공개 장소 만 검색 결과에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0d4ee827fd94873de2c91d4eec53a11fd417368a" translate="yes" xml:space="preserve">
          <source>Only plain data can be returned from JavaScript as the result value. Supported data types include all of the JSON data types as well as, for example, &lt;code&gt;Date&lt;/code&gt; and &lt;code&gt;ArrayBuffer&lt;/code&gt;. Unsupported data types include, for example, &lt;code&gt;Function&lt;/code&gt; and &lt;code&gt;Promise&lt;/code&gt;.</source>
          <target state="translated">JavaScript에서 결과 값으로 일반 데이터 만 반환 할 수 있습니다. 지원되는 데이터 유형에는 모든 JSON 데이터 유형과 예를 들어 &lt;code&gt;Date&lt;/code&gt; 및 &lt;code&gt;ArrayBuffer&lt;/code&gt; 가 포함 됩니다. 지원되지 않는 데이터 유형에는 예를 들어 &lt;code&gt;Function&lt;/code&gt; 및 &lt;code&gt;Promise&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="01f3c132b1849d856881232b4ef1c60be7e512ab" translate="yes" xml:space="preserve">
          <source>Only primitive type accepted by tesselation shader where a patch consists of arbitrary number of vertices</source>
          <target state="translated">패치가 임의의 수의 정점으로 구성된 테셀레이션 셰이더에서 허용되는 기본 유형 만</target>
        </trans-unit>
        <trans-unit id="9dfd6bfa7305895a60f77674f4e18dabf7f170e7" translate="yes" xml:space="preserve">
          <source>Only queries encoded in UTF-8 are supported.</source>
          <target state="translated">UTF-8로 인코딩 된 쿼리 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0d4fbcf17512917247dbcbcfe48e0004c8dc79cb" translate="yes" xml:space="preserve">
          <source>Only routes which contain the feature are considered, otherwise no route will be returned</source>
          <target state="translated">기능이 포함 된 경로 만 고려됩니다. 그렇지 않으면 경로가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f9255b8d5e908b1c057dedafa0e435395295dbc0" translate="yes" xml:space="preserve">
          <source>Only routes which contain the feature will be considered, otherwise no route will be returned</source>
          <target state="translated">지형지 물이 포함 된 경로 만 고려됩니다. 그렇지 않으면 경로가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7fdc0ad98caecb9009f0b11619aa918b2444b645" translate="yes" xml:space="preserve">
          <source>Only routes which contain the feature will be considered, otherwise no route will be returned.</source>
          <target state="translated">지형지 물이 포함 된 경로 만 고려되며, 그렇지 않으면 경로가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c2779898a7f5d5fb6d65e6b91be36c78875b714" translate="yes" xml:space="preserve">
          <source>Only routes which do not contain the feature are considered, otherwise no route will be returned</source>
          <target state="translated">기능이 포함되지 않은 경로 만 고려됩니다. 그렇지 않으면 경로가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8d85783e1de0673e901d7a4dca553574f5039c6" translate="yes" xml:space="preserve">
          <source>Only routes which do not contain the feature will be considered, otherwise no route will be returned</source>
          <target state="translated">지형지 물이 포함되지 않은 경로 만 고려됩니다. 그렇지 않으면 경로가 반환되지 않습니다</target>
        </trans-unit>
        <trans-unit id="007e500e4d7218935cd1d79463df12a7be146591" translate="yes" xml:space="preserve">
          <source>Only routes which do not contain the feature will be considered, otherwise no route will be returned.</source>
          <target state="translated">지형지 물이 포함되지 않은 경로 만 고려되며, 그렇지 않으면 경로가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b99c13a867fa4d3cbc645acd24ad9522fb48037" translate="yes" xml:space="preserve">
          <source>Only show directories in the file dialog. By default both files and directories are shown. (Valid only in the &lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;Directory&lt;/a&gt; file mode.)</source>
          <target state="translated">파일 대화 상자에만 디렉토리를 표시하십시오. 기본적으로 파일과 디렉토리가 모두 표시됩니다. ( &lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;디렉토리&lt;/a&gt; 파일 모드 에서만 유효 합니다.)</target>
        </trans-unit>
        <trans-unit id="900803d3a3fe28377b84720dbf28d5167a85641b" translate="yes" xml:space="preserve">
          <source>Only show directories in the folder dialog. By default both folders and directories are shown.</source>
          <target state="translated">폴더 대화 상자에만 디렉토리를 표시하십시오. 기본적으로 폴더와 디렉토리가 모두 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="88000814598313fb38d4e244e5dfccadf2621dbe" translate="yes" xml:space="preserve">
          <source>Only the acceleration caused by gravity is reported. Movements of the device caused by the user have no effect other than changing the direction when the device is rotated.</source>
          <target state="translated">중력으로 인한 가속 만보고됩니다. 사용자에 의한 장치의 움직임은 장치가 회전 할 때 방향을 변경하는 것 외에는 아무런 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b0b647478e89f4b60717d31245125ad915741989" translate="yes" xml:space="preserve">
          <source>Only the acceleration caused by the user moving the device is reported, the effect of gravity is canceled out. A device at rest therefore should report values of, or close to, zero. In other APIs, this mode might be known as</source>
          <target state="translated">사용자의 장치 이동으로 인한 가속 만보고되며 중력의 영향이 사라집니다. 그러므로 정지 상태의 장치는 0의 값 또는 0에 가까운 값을보고해야합니다. 다른 API에서이 모드는</target>
        </trans-unit>
        <trans-unit id="28c2b6d10db770a994e0a219eb84b16aee9277b9" translate="yes" xml:space="preserve">
          <source>Only the bounding volume was considered; the primitive and vertex indices will be undefined</source>
          <target state="translated">경계 볼륨 만 고려되었습니다. 프리미티브 및 버텍스 인덱스는 정의되지 않습니다</target>
        </trans-unit>
        <trans-unit id="8a39b6e783f61b06f884bdb7578b0f519b6f0796" translate="yes" xml:space="preserve">
          <source>Only the color of the brush is relevant.</source>
          <target state="translated">브러시 색상 만 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cf6237dd24c7bd1a6295a9932827ded0e6a55af" translate="yes" xml:space="preserve">
          <source>Only the current page should be printed.</source>
          <target state="translated">현재 페이지 만 인쇄해야합니다.</target>
        </trans-unit>
        <trans-unit id="080d8f02db3d9f7049ea42613d8101bfa3916fb0" translate="yes" xml:space="preserve">
          <source>Only the current widget is visible. This is the default.</source>
          <target state="translated">현재 위젯 만 표시됩니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="e090b7f0e8280ab6733d3dccc7d6169297d15cc0" translate="yes" xml:space="preserve">
          <source>Only the currently visible page should be printed.</source>
          <target state="translated">현재 보이는 페이지 만 인쇄해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0263b87dc2d8ed1730ca0ef21d5b77a0bcddd01" translate="yes" xml:space="preserve">
          <source>Only the file name is used to look for a match</source>
          <target state="translated">파일 이름 만 일치하는 것을 찾는 데 사용됩니다</target>
        </trans-unit>
        <trans-unit id="ca51e3744c12ca1c311c46a33f38c17885e7f9de" translate="yes" xml:space="preserve">
          <source>Only the five dash-separated fields, without the braces. Example: 00000000-0000-0000-0000-000000000000.</source>
          <target state="translated">중괄호가없는 5 개의 대시로 구분 된 필드 만. 예 : 00000000-0000-0000-0000-000000000000</target>
        </trans-unit>
        <trans-unit id="5fb5283a4d295a103b15f7350d1e633c563b86b6" translate="yes" xml:space="preserve">
          <source>Only the following property setters are supported by startDetached():</source>
          <target state="translated">startDetached ()는 다음 특성 설정기만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="4d2b8904c9938174062602ccd005d5844dabda29" translate="yes" xml:space="preserve">
          <source>Only the fractional part of the texture coordinate is used, causing values above 1 and below 0 to repeat.</source>
          <target state="translated">텍스처 좌표의 소수 부분 만 사용되어 1보다 크고 0보다 작은 값이 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="4bd209bd107698e95605e422a632c7b856ad3f4e" translate="yes" xml:space="preserve">
          <source>Only the grid is drawn.</source>
          <target state="translated">그리드 만 그려집니다.</target>
        </trans-unit>
        <trans-unit id="0ffe98cffb635c5a13e26848e8fb64b63941fdad" translate="yes" xml:space="preserve">
          <source>Only the hex digits, without braces or dashes. Note that &lt;a href=&quot;quuid&quot;&gt;QUuid&lt;/a&gt; cannot parse this back again as input.</source>
          <target state="translated">중괄호 나 대시가없는 16 진수 만. 참고 &lt;a href=&quot;quuid&quot;&gt;QUuid가&lt;/a&gt; 입력으로 다시 돌아 가기를 구문 분석 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1caea0229463e687ca2ede2d1d31bcbdff21faee" translate="yes" xml:space="preserve">
          <source>Only the horizontal element of the</source>
          <target state="translated">수평 요소 만</target>
        </trans-unit>
        <trans-unit id="2056d2cf08f1b908f168043b84febb65fbe3ecc4" translate="yes" xml:space="preserve">
          <source>Only the immediate child states of the parent state are recorded. In this case a transition with the history state as its target will end up in the immediate child state that the parent was in the last time it was exited. This is the default.</source>
          <target state="translated">부모 상태의 직계 자식 상태 만 기록됩니다. 이 경우 대상이 히스토리 상태 인 전이는 부모가 마지막으로 종료 된 직계 하위 상태가됩니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="ec1b677a36b6ffd73e6e4950cac57fee0ee608d9" translate="yes" xml:space="preserve">
          <source>Only the last moved item is returned to the &quot;lightsteelblue&quot; color; the others remain yellow. This is because the &lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;ScriptAction&lt;/a&gt; is not run until after the transition has already been initialized, by which time the &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt;.item value has changed to refer to a different item; the item that the script had intended to refer to is not the one held by &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt;.item at the time the &lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;ScriptAction&lt;/a&gt; is actually invoked.</source>
          <target state="translated">마지막으로 이동 한 항목 만 &quot;lightsteelblue&quot;색상으로 돌아갑니다. 나머지는 노란색으로 유지됩니다. 이는 전환이 이미 초기화 된 &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;후에야&lt;/a&gt; ViewTransition .item 값이 다른 항목을 참조하도록 변경 될 때까지 &lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;ScriptAction&lt;/a&gt; 이 실행되지 않기 때문 입니다. 스크립트가 참조하려는 항목 은 &lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;ScriptAction&lt;/a&gt; 이 실제로 호출 될 때 &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; .item이 보유한 항목이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="b447465bf0c66e3aa05f4ed491c856b7481ae9bd" translate="yes" xml:space="preserve">
          <source>Only the last moved item is returned to the &quot;lightsteelblue&quot; color; the others remain yellow. This is because the &lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;ScriptAction&lt;/a&gt; is not run until after the transition has already been initialized, by which time the ViewTransition.item value has changed to refer to a different item; the item that the script had intended to refer to is not the one held by ViewTransition.item at the time the &lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;ScriptAction&lt;/a&gt; is actually invoked.</source>
          <target state="translated">마지막으로 이동 한 항목 만 &quot;lightsteelblue&quot;색상으로 돌아갑니다. 나머지는 노란색으로 유지됩니다. 이는 전환이 이미 초기화 된 후 ViewTransition.item 값이 다른 항목을 참조하도록 변경 될 때까지 &lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;ScriptAction&lt;/a&gt; 이 실행되지 않기 때문 입니다. 스크립트가 참조하려고했던 항목이 &lt;a href=&quot;qml-qtquick-scriptaction&quot;&gt;ScriptAction&lt;/a&gt; 이 실제로 호출 될 때 ViewTransition.item이 보유한 항목이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="67a2014a4e9ee9f974bdab1665ff97411a19734b" translate="yes" xml:space="preserve">
          <source>Only the nearest entity to picking ray origin intersected by the picking ray is picked (default).</source>
          <target state="translated">피킹 광선과 교차 된 피킹 광선 원점에 가장 가까운 엔티티 만 선택됩니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="f97efd7a4aa1bfab99e483967c77f06a0a9f82ac" translate="yes" xml:space="preserve">
          <source>Only the outline of the polygon should be drawn.</source>
          <target state="translated">다각형의 외곽선 만 그려야합니다.</target>
        </trans-unit>
        <trans-unit id="aca71c0147c05907515f4ff15d2e7d5ca7be21a7" translate="yes" xml:space="preserve">
          <source>Only the selection should be printed.</source>
          <target state="translated">선택 사항 만 인쇄해야합니다.</target>
        </trans-unit>
        <trans-unit id="be441e0bdbc0515fb7e35936edf75f9bab2b5109" translate="yes" xml:space="preserve">
          <source>Only the standard editing functions for widget-based delegates are reimplemented here:</source>
          <target state="translated">위젯 기반 델리게이트에 대한 표준 편집 기능 만 여기에서 다시 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="29580644238e732f38b13dd5c82703fa15d11909" translate="yes" xml:space="preserve">
          <source>Only the surface is drawn.</source>
          <target state="translated">표면 만 그려집니다.</target>
        </trans-unit>
        <trans-unit id="5480b979811ae4fff5f6bcedc74670cef045aea4" translate="yes" xml:space="preserve">
          <source>Only the test is now on the fix-branch. The rest of the source tree is still on 5.14.</source>
          <target state="translated">이제 테스트 만 수정 분기에 있습니다. 나머지 소스 트리는 여전히 5.14에 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b0a77de23a69e30edff30601a0d3d23d5e928b7" translate="yes" xml:space="preserve">
          <source>Only the touch screen is used.</source>
          <target state="translated">터치 스크린 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="408c074f8c67e3b86cf6655119793937bb5e7997" translate="yes" xml:space="preserve">
          <source>Only the trees &lt;code&gt;HKEY_CURRENT_USER&lt;/code&gt; (&lt;code&gt;HKCU&lt;/code&gt;) and &lt;code&gt;HKEY_LOCAL_MACHINE&lt;/code&gt; (&lt;code&gt;HKLM&lt;/code&gt;) are supported.</source>
          <target state="translated">&lt;code&gt;HKEY_CURRENT_USER&lt;/code&gt; ( &lt;code&gt;HKCU&lt;/code&gt; ) 및 &lt;code&gt;HKEY_LOCAL_MACHINE&lt;/code&gt; ( &lt;code&gt;HKLM&lt;/code&gt; ) 트리 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4e6139d7f19eb94c8c38ef52a17a8882ef9d237d" translate="yes" xml:space="preserve">
          <source>Only themes for specific styles can be changed at runtime, styles are fixed</source>
          <target state="translated">런타임에 특정 스타일의 테마 만 변경할 수 있으며 스타일은 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="87f9c253543d9b4adb74c91e1d104432a173b3a1" translate="yes" xml:space="preserve">
          <source>Only upper case letter input is allowed.</source>
          <target state="translated">대문자 만 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ccbfdcc4a3ea2a9709b17f03f466f0a3c2fe141" translate="yes" xml:space="preserve">
          <source>Only use this constructor if there is no derived sensor class available. Note that all built-in sensors have a derived class, so using this constructor should only be necessary when implementing custom sensors, like in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsensors-grue-example.html#&quot;&gt;Grue sensor example&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 파생 된 센서 클래스가없는 경우에만이 생성자를 사용하십시오. 모든 내장 센서에는 파생 클래스가 있으므로 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsensors-grue-example.html#&quot;&gt;Grue 센서 예제&lt;/a&gt; 와 같이 사용자 정의 센서를 구현할 때만이 생성자를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d50e3bbf3dafbc6aa798fe8b36300dae22590670" translate="yes" xml:space="preserve">
          <source>Only use this constructor if there is no derived sensor class available. Note that all built-in sensors have a derived class, so using this constructor should only be necessary when implementing custom sensors, like in the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsensors-grue-example.html&quot;&gt;Grue sensor example&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 파생 센서 클래스가없는 경우에만이 생성자를 사용하십시오. 모든 내장 센서에는 파생 클래스가 있으므로 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsensors-grue-example.html&quot;&gt;Grue 센서 예제&lt;/a&gt; 에서와 같이 사용자 지정 센서를 구현할 때만이 생성자를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1ceac6eb2a46f17409c4768a114ad2b9f7e7d116" translate="yes" xml:space="preserve">
          <source>Only used when &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.shortcut&lt;/a&gt; is not empty.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.shortcut&lt;/a&gt; 이 비어 있지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="de1e77c3cbbbdb49990f560915ad8bf750f7c9a6" translate="yes" xml:space="preserve">
          <source>Only used when &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.type&lt;/a&gt; equals &lt;code&gt;MenuItemType.Menu&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.type&lt;/a&gt; 이 &lt;code&gt;MenuItemType.Menu&lt;/code&gt; 와 같은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="371af54db2f6e0c93113bdee7fb35c15761598ea" translate="yes" xml:space="preserve">
          <source>Only valid URLs are accepted. This mode is useful for general URL validation.</source>
          <target state="translated">유효한 URL 만 허용됩니다. 이 모드는 일반적인 URL 유효성 검사에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c58ede0030cae078c59b1d32eebd1e16ce613c31" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;a href=&quot;qsggeometrynode&quot;&gt;QSGGeometryNode&lt;/a&gt; and &lt;a href=&quot;qsgclipnode&quot;&gt;QSGClipNode&lt;/a&gt;. The node has ownership over the &lt;a href=&quot;qsggeometry&quot;&gt;QSGGeometry&lt;/a&gt; instance and will delete it when the node is destroyed or a geometry is assigned.</source>
          <target state="translated">&lt;a href=&quot;qsggeometrynode&quot;&gt;QSGGeometryNode&lt;/a&gt; 및 &lt;a href=&quot;qsgclipnode&quot;&gt;QSGClipNode&lt;/a&gt; 에만 유효합니다 . 노드는 &lt;a href=&quot;qsggeometry&quot;&gt;QSGGeometry&lt;/a&gt; 인스턴스에 대한 소유권을 가지며 노드가 파괴되거나 지오메트리가 할당 될 때 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="4bad280e60d2847c398d9e7cb98685cc945a3948" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;a href=&quot;qsggeometrynode&quot;&gt;QSGGeometryNode&lt;/a&gt;. The node has ownership over the material and will delete it when the node is destroyed or a material is assigned.</source>
          <target state="translated">&lt;a href=&quot;qsggeometrynode&quot;&gt;QSGGeometryNode&lt;/a&gt; 에만 유효합니다 . 노드는 재료에 대한 소유권을 가지며 노드가 파괴되거나 재료가 할당 될 때 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="24f4800ac476cd55f0a6bb9d113138df0c887c93" translate="yes" xml:space="preserve">
          <source>Only valid for &lt;a href=&quot;qsggeometrynode&quot;&gt;QSGGeometryNode&lt;/a&gt;. The node has ownership over the opaque material and will delete it when the node is destroyed or a material is assigned.</source>
          <target state="translated">&lt;a href=&quot;qsggeometrynode&quot;&gt;QSGGeometryNode&lt;/a&gt; 에만 유효합니다 . 노드는 불투명 재질에 대한 소유권을 가지며 노드가 파괴되거나 재질이 할당되면 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="40bae8187ede3cd33c240b6d9840d6c0f5a4a54b" translate="yes" xml:space="preserve">
          <source>Only visible, enabled, selectable items can be selected. If</source>
          <target state="translated">표시, 활성화 및 선택 가능한 항목 만 선택할 수 있습니다. 만약</target>
        </trans-unit>
        <trans-unit id="35915d86c62b7f9827e6d646aa3df8f953664aac" translate="yes" xml:space="preserve">
          <source>Oops! If you save this &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; in &lt;code&gt;file.xq&lt;/code&gt; and run it through &lt;code&gt;xmlpatterns&lt;/code&gt;, it doesn't work. You get an error message instead, something like this:</source>
          <target state="translated">이런! 이 저장하는 경우 &lt;a href=&quot;xmlprocessing&quot;&gt;는 XQuery&lt;/a&gt; 에서 &lt;code&gt;file.xq&lt;/code&gt; 를 하고를 통해 실행 &lt;code&gt;xmlpatterns&lt;/code&gt; , 그것은 작동하지 않습니다. 대신 다음과 같은 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="03f44562aec25af8ccf0c430b3017be9d8f8802a" translate="yes" xml:space="preserve">
          <source>Oops! If you save this &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; in &lt;code&gt;file.xq&lt;/code&gt; and run it through &lt;code&gt;xmlpatterns&lt;/code&gt;, it doesn't work. You get an error message instead, something like this:</source>
          <target state="translated">죄송합니다! 이 저장하는 경우 &lt;a href=&quot;xmlprocessing#&quot;&gt;는 XQuery&lt;/a&gt; 에서 &lt;code&gt;file.xq&lt;/code&gt; 를 하고를 통해 실행 &lt;code&gt;xmlpatterns&lt;/code&gt; , 그것은 작동하지 않습니다. 대신 다음과 같은 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c208e384200cbb97e07402fd6877cf6434b0855b" translate="yes" xml:space="preserve">
          <source>Opacity accumulates downwards in the scene graph so a node with two &lt;a href=&quot;qsgopacitynode&quot;&gt;QSGOpacityNode&lt;/a&gt; instances above it, both with opacity of 0.5, will have effective opacity of 0.25.</source>
          <target state="translated">불투명도는 장면 그래프에서 아래쪽으로 누적되므로 불투명도가 0.5 인 두 개의 &lt;a href=&quot;qsgopacitynode&quot;&gt;QSGOpacityNode&lt;/a&gt; 인스턴스가 있는 노드의 유효 불투명도는 0.25입니다.</target>
        </trans-unit>
        <trans-unit id="bf684625ef08d3418934013f7480a018508a2187" translate="yes" xml:space="preserve">
          <source>Opacity accumulates downwards in the scene graph so a node with two QSGOpacityNode instances above it, both with opacity of 0.5, will have effective opacity of 0.25.</source>
          <target state="translated">불투명도는 장면 그래프에서 아래쪽으로 누적되므로 그 위에 두 개의 QSGOpacityNode 인스턴스가 있고 둘 다 불투명도가 0.5 인 노드의 유효 불투명도는 0.25입니다.</target>
        </trans-unit>
        <trans-unit id="829150b60c0c0db0cc93329d53cfecf36c122934" translate="yes" xml:space="preserve">
          <source>Opacity applies to its subtree and can be nested. Multiple opacity nodes will be accumulated by multiplying their opacity. The accumulation happens as part of the rendering.</source>
          <target state="translated">불투명도는 해당 하위 트리에 적용되며 중첩 될 수 있습니다. 불투명도를 곱하면 여러 개의 불투명도 노드가 누적됩니다. 렌더링은 렌더링의 일부로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3b7449b2c081577ffb2b9006287432cb410a7d24" translate="yes" xml:space="preserve">
          <source>Opacity of the material. Range is &lt;code&gt;[0, 100]&lt;/code&gt;. Default is &lt;code&gt;100&lt;/code&gt;.</source>
          <target state="translated">재료의 불투명도. 범위는 &lt;code&gt;[0, 100]&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;100&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c7aca2013b5eb96ce3224e77138e39dc54638ccc" translate="yes" xml:space="preserve">
          <source>Opacity set on the painter will apply to all drawing operations individually.</source>
          <target state="translated">페인터에 설정된 불투명도는 모든 드로잉 작업에 개별적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="08fc9adf53d76f88b1af2b9c5584c7fc45a927df" translate="yes" xml:space="preserve">
          <source>OpacityAnimator (QML type)</source>
          <target state="translated">OpacityAnimator (QML 유형)</target>
        </trans-unit>
        <trans-unit id="96a14689298808b6d3522acf2d5a387c40a2a5d6" translate="yes" xml:space="preserve">
          <source>OpacityAnimator QML Type</source>
          <target state="translated">불투명도 애니메이터 QML 유형</target>
        </trans-unit>
        <trans-unit id="1cf283a66bdc2160323b926172359f70f1ab8c24" translate="yes" xml:space="preserve">
          <source>OpacityMask</source>
          <target state="translated">OpacityMask</target>
        </trans-unit>
        <trans-unit id="0b0f3b8da479b14e85623578c367d6b2440976fb" translate="yes" xml:space="preserve">
          <source>OpacityMask (QML type)</source>
          <target state="translated">불투명 마스크 (QML 유형)</target>
        </trans-unit>
        <trans-unit id="61d2e30e2dc6a4a40b621855945206afab7fca9c" translate="yes" xml:space="preserve">
          <source>OpacityMask QML Type</source>
          <target state="translated">불투명 마스크 QML 유형</target>
        </trans-unit>
        <trans-unit id="d15cbf99a785a31b9001bce9cc7b9a629fb48f89" translate="yes" xml:space="preserve">
          <source>OpacityMask.cached</source>
          <target state="translated">OpacityMask.cached</target>
        </trans-unit>
        <trans-unit id="424286b176ab75926f473d619a80a8c5dc509ddd" translate="yes" xml:space="preserve">
          <source>OpacityMask.invert</source>
          <target state="translated">OpacityMask.invert</target>
        </trans-unit>
        <trans-unit id="a7a70264498e2d4ca48121d092a85c8a64ecc990" translate="yes" xml:space="preserve">
          <source>OpacityMask.maskSource</source>
          <target state="translated">OpacityMask.maskSource</target>
        </trans-unit>
        <trans-unit id="e85c582c782457157b7bf01e1af21d6b123f8d90" translate="yes" xml:space="preserve">
          <source>OpacityMask.source</source>
          <target state="translated">OpacityMask.source</target>
        </trans-unit>
        <trans-unit id="558e3a64cc59695a139131081982f8710fcd3d0c" translate="yes" xml:space="preserve">
          <source>Opaque Items: these are sorted from front to back, or in other words from items that are closest to the camera to items that are furthest from the camera. This is done to take advantage of hardware occlusion culling or early z detection in the fragment shader.</source>
          <target state="translated">불투명 한 항목 : 앞쪽에서 뒤쪽으로, 즉 카메라에 가장 가까운 항목부터 카메라에서 가장 먼 항목까지 정렬됩니다. 이는 조각 셰이더에서 하드웨어 오 클루 전 컬링 또는 초기 z 감지를 활용하기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b019e2062e483cf700d186481cf928fe703897cd" translate="yes" xml:space="preserve">
          <source>Opaque Pass - Next all opaque items will be drawn. This just involves setting the pipeline state, and running the draw command for each item in the order in the list since they are already sorted at this point.</source>
          <target state="translated">불투명 패스-다음으로 모든 불투명 항목이 그려집니다. 여기에는 파이프 라인 상태를 설정하고이 시점에서 이미 정렬되어 있으므로 목록의 순서대로 각 항목에 대해 그리기 명령을 실행하는 작업 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e965ae68a3263a67cd6f78b5972dc71eae19d796" translate="yes" xml:space="preserve">
          <source>Opaque Primitives</source>
          <target state="translated">불투명 프리미티브</target>
        </trans-unit>
        <trans-unit id="5f4c80339b085a98ac9ae150448b318600a4b2ef" translate="yes" xml:space="preserve">
          <source>Opaque content is generally a lot faster to draw than translucent. The reason being that translucent content needs blending and that the renderer can potentially optimize opaque content better.</source>
          <target state="translated">불투명 한 내용은 일반적으로 반투명보다 그리는 것이 훨씬 빠릅니다. 반투명 컨텐츠에 블렌딩이 필요하고 렌더러가 불투명 컨텐츠를 더 잘 최적화 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="9ea890027c05fcabf8fc5cb784912143a4525700" translate="yes" xml:space="preserve">
          <source>Opaque items are not blended with the rest of the scene, you should set this to true if the content of the item is opaque to speed up rendering.</source>
          <target state="translated">불투명 한 항목은 나머지 장면과 혼합되지 않으므로 렌더링 속도를 높이기 위해 항목의 내용이 불투명 한 경우이를 true로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c022e509bc78be1cddf99e8ce898e85efc24290c" translate="yes" xml:space="preserve">
          <source>Opaque maskSource pixels produce blur with specified &lt;a href=&quot;qml-qtgraphicaleffects-maskedblur#radius-prop&quot;&gt;radius&lt;/a&gt;, while transparent pixels suppress the blur completely. Semitransparent maskSource pixels produce blur with a radius that is interpolated according to the pixel transparency level.</source>
          <target state="translated">불투명 마스크 소스 픽셀은 지정된 &lt;a href=&quot;qml-qtgraphicaleffects-maskedblur#radius-prop&quot;&gt;반경으로&lt;/a&gt; 블러를 생성 하는 반면 투명 픽셀은 블러를 완전히 억제합니다. 반투명 마스크 소스 픽셀은 픽셀 투명도 수준에 따라 보간되는 반경으로 흐림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="63e040c82fbe07d8831a8312e7ae49674bdecaa1" translate="yes" xml:space="preserve">
          <source>Opaque primitives are rendered in a front-to-back manner with &lt;code&gt;glDepthMask&lt;/code&gt; and &lt;code&gt;GL_DEPTH_TEST&lt;/code&gt; enabled. On GPUs that internally do early-z checks, this means that the fragment shader does not need to run for pixels or blocks of pixels that are obscured. Beware that the renderer still needs to take these nodes into account and the vertex shader is still run for every vertex in these primitives, so if the application knows that something is fully obscured, the best thing to do is to explicitly hide it using &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;Item::visible&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-item#opacity-prop&quot;&gt;Item::opacity&lt;/a&gt;.</source>
          <target state="translated">불투명 프리미티브는 &lt;code&gt;glDepthMask&lt;/code&gt; 및 &lt;code&gt;GL_DEPTH_TEST&lt;/code&gt; 를 사용 하여 앞뒤로 렌더링됩니다 . 내부적으로 z 조기 검사를 수행하는 GPU에서 이는 조각 셰이더가 가려진 픽셀 또는 픽셀 블록에 대해 실행될 필요가 없음을 의미합니다. 렌더러는 여전히 이러한 노드를 고려해야하고 버텍스 셰이더는이 프리미티브의 모든 버텍스에 대해 여전히 실행되므로 응용 프로그램에서 무언가가 완전히 가려져 있음을 알고 있으면 가장 좋은 방법은 &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;Item&lt;/a&gt; 을 사용하여 명시 적으로 숨기는 것입니다 . : visible 또는 &lt;a href=&quot;qml-qtquick-item#opacity-prop&quot;&gt;Item :: opacity&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cf9b77061f7b3126b49d50a6fa68f7ca8c26b7a3" translate="yes" xml:space="preserve">
          <source>Open</source>
          <target state="translated">Open</target>
        </trans-unit>
        <trans-unit id="12c9a9af2ccd9dd01f67598b70c3300035a3e1e7" translate="yes" xml:space="preserve">
          <source>Open Asset Import Library, version 4.1.0</source>
          <target state="translated">Open Asset Import Library, 버전 4.1.0</target>
        </trans-unit>
        <trans-unit id="b1c21017ebf496316313faf0fc4a9e7fef8dd76a" translate="yes" xml:space="preserve">
          <source>Open Asset Import Library, version 5.0.1</source>
          <target state="translated">Open Asset Import Library, 버전 5.0.1</target>
        </trans-unit>
        <trans-unit id="0394c45fa1e7c207d965b81ab85d25dc9696b016" translate="yes" xml:space="preserve">
          <source>Open Database Connectivity (ODBC) - Microsoft SQL Server and other ODBC-compliant databases</source>
          <target state="translated">ODBC (Open Database Connectivity)-Microsoft SQL Server 및 기타 ODBC 호환 데이터베이스</target>
        </trans-unit>
        <trans-unit id="bd1cc119778453c0b82c3296958c4092ec8c2832" translate="yes" xml:space="preserve">
          <source>Open GL (ES) 2.0, DirectX 9 or 11 (with ANGLE), or an &lt;a href=&quot;http://doc.qt.io/QtQuick2DRenderer&quot;&gt;alternative renderer&lt;/a&gt; is required for &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; 2. &lt;a href=&quot;qtwidgets-index&quot;&gt;Widgets&lt;/a&gt; can be used without hardware acceleration.</source>
          <target state="translated">Open GL (ES) 2.0, DirectX 9 또는 11 (ANGLE 포함) 또는 &lt;a href=&quot;http://doc.qt.io/QtQuick2DRenderer&quot;&gt;대체 렌더러&lt;/a&gt; 가 &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; 2에 필요합니다 . &lt;a href=&quot;qtwidgets-index&quot;&gt;위젯&lt;/a&gt; 은 하드웨어 가속없이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68d6b3f6db3b02f1d9e14f6315e4a2e193ce9054" translate="yes" xml:space="preserve">
          <source>Open GL (ES) 2.0, DirectX 9 or 11 (with ANGLE), or an &lt;a href=&quot;http://doc.qt.io/QtQuick2DRenderer#&quot;&gt;alternative renderer&lt;/a&gt; is required for &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; 2. &lt;a href=&quot;qtwidgets-index&quot;&gt;Widgets&lt;/a&gt; can be used without hardware acceleration.</source>
          <target state="translated">&lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; 2 에는 Open GL (ES) 2.0, DirectX 9 또는 11 (ANGLE 포함) 또는 &lt;a href=&quot;http://doc.qt.io/QtQuick2DRenderer#&quot;&gt;대체 렌더러&lt;/a&gt; 가 필요합니다 . 하드웨어 가속없이 &lt;a href=&quot;qtwidgets-index&quot;&gt;위젯을&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="662b5d5a6b5b0f5842c6b841a0fd6b2ddd2478be" translate="yes" xml:space="preserve">
          <source>Open Street Map Plugin</source>
          <target state="translated">오픈 스트리트 맵 플러그인</target>
        </trans-unit>
        <trans-unit id="278f12ef0327ab39f1757fcb937f465c865eb73b" translate="yes" xml:space="preserve">
          <source>Open Vector Graphics rendering</source>
          <target state="translated">오픈 벡터 그래픽스 렌더링</target>
        </trans-unit>
        <trans-unit id="4512ca03f3e9eafb3056a3a23239c25eab890a5d" translate="yes" xml:space="preserve">
          <source>Open and run examples within Qt Creator's &lt;b&gt;Welcome&lt;/b&gt; mode. Most of the examples run on various platforms and to search for platform-specific examples, type the platform name (or any keywords) in the search field. For example, typing &lt;code&gt;mobile&lt;/code&gt; in the search field lists the examples that are fully compatible with the &lt;a href=&quot;https://doc.qt.io/qt-5.13/topics-core.html#platform-support&quot;&gt;mobile&lt;/a&gt; platforms.</source>
          <target state="translated">Qt는 창조주의 내 열고 실행 예 &lt;b&gt;에 오신 것을 환영합니다&lt;/b&gt; 모드. 대부분의 예제는 다양한 플랫폼에서 실행되며 플랫폼 별 예제를 검색하려면 검색 필드에 플랫폼 이름 (또는 키워드)을 입력하십시오. 예를 들어, 검색 필드에 &lt;code&gt;mobile&lt;/code&gt; 을 입력 하면 &lt;a href=&quot;https://doc.qt.io/qt-5.13/topics-core.html#platform-support&quot;&gt;모바일&lt;/a&gt; 플랫폼 과 완전히 호환되는 예제가 나열 됩니다.</target>
        </trans-unit>
        <trans-unit id="64d2a4fd8f21bd80fdbaacda5378d5c58ab28488" translate="yes" xml:space="preserve">
          <source>Open and run examples within Qt Creator's &lt;b&gt;Welcome&lt;/b&gt; mode. Most of the examples run on various platforms and to search for platform-specific examples, type the platform name (or any keywords) in the search field. For example, typing &lt;code&gt;mobile&lt;/code&gt; in the search field lists the examples that are fully compatible with the &lt;a href=&quot;https://doc.qt.io/qt-5.15/topics-core.html#platform-support&quot;&gt;mobile&lt;/a&gt; platforms.</source>
          <target state="translated">Qt는 창조주의 내 열고 실행 예 &lt;b&gt;에 오신 것을 환영합니다&lt;/b&gt; 모드. 대부분의 예제는 다양한 플랫폼에서 실행되며 플랫폼 별 예제를 검색하려면 검색 필드에 플랫폼 이름 (또는 키워드)을 입력합니다. 예를 들어 검색 필드에 &lt;code&gt;mobile&lt;/code&gt; 을 입력 하면 &lt;a href=&quot;https://doc.qt.io/qt-5.15/topics-core.html#platform-support&quot;&gt;모바일&lt;/a&gt; 플랫폼 과 완벽하게 호환되는 예제가 나열 됩니다.</target>
        </trans-unit>
        <trans-unit id="fbe54a80e078e26712d2ee5ce4ea8f6c9783badb" translate="yes" xml:space="preserve">
          <source>Open and run examples within Qt Creator's &lt;b&gt;Welcome&lt;/b&gt; mode. Most of the examples run on various platforms and to search for platform-specific examples, type the platform name (or any keywords) in the search field. For example, typing &lt;code&gt;mobile&lt;/code&gt; in the search field lists the examples that are fully compatible with the &lt;a href=&quot;https://doc.qt.io/qt-6.0/topics-core.html#platform-support&quot;&gt;mobile&lt;/a&gt; platforms.</source>
          <target state="translated">Qt는 창조주의 내 열고 실행 예 &lt;b&gt;에 오신 것을 환영합니다&lt;/b&gt; 모드. 대부분의 예제는 다양한 플랫폼에서 실행되며 플랫폼 별 예제를 검색하려면 검색 필드에 플랫폼 이름 (또는 키워드)을 입력합니다. 예를 들어 검색 필드에 &lt;code&gt;mobile&lt;/code&gt; 을 입력 하면 &lt;a href=&quot;https://doc.qt.io/qt-6.0/topics-core.html#platform-support&quot;&gt;모바일&lt;/a&gt; 플랫폼 과 완전히 호환되는 예제가 나열 됩니다.</target>
        </trans-unit>
        <trans-unit id="8b18b3cb1d919113d468b6b7623afc8253f4c18b" translate="yes" xml:space="preserve">
          <source>Open document.</source>
          <target state="translated">문서를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="b6b3041906071e2e9c2102c5f76d2e25c7f3e745" translate="yes" xml:space="preserve">
          <source>Open for editing (open an SMS in the SMS editor, open the URI in a URI editor, open the telephone number for editing).</source>
          <target state="translated">편집을 위해 엽니 다 (SMS 편집기에서 SMS를 열고 URI 편집기에서 URI를 열고 편집 할 전화 번호를여십시오).</target>
        </trans-unit>
        <trans-unit id="40f296882c518355cdbb8edcd05790b9ec3c4641" translate="yes" xml:space="preserve">
          <source>Open help contents.</source>
          <target state="translated">도움말 내용을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="63d89569ac44ed6a4c778b9e2f60d18c0cdfb96b" translate="yes" xml:space="preserve">
          <source>Open the camera device. The camera state is changed to &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera::LoadedStatus&lt;/a&gt;.</source>
          <target state="translated">카메라 장치를 엽니 다. 카메라 상태가 &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera :: LoadedStatus로&lt;/a&gt; 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="3745b35555ada97705265c81b74c1ca85836778f" translate="yes" xml:space="preserve">
          <source>Open the current link in a new background tab. Requires implementation of &lt;a href=&quot;qwebenginepage#createWindow&quot;&gt;createWindow&lt;/a&gt;(). (Added in Qt 5.7)</source>
          <target state="translated">새 배경 탭에서 현재 링크를 엽니 다. &lt;a href=&quot;qwebenginepage#createWindow&quot;&gt;createWindow&lt;/a&gt; () 구현이 필요합니다 . (Qt 5.7에 추가)</target>
        </trans-unit>
        <trans-unit id="3d691305328e945c9f65cd275838f064c9506496" translate="yes" xml:space="preserve">
          <source>Open the current link in a new tab. Requires a handler for the &lt;a href=&quot;qml-qtwebengine-webengineview#newViewRequested-signal&quot;&gt;newViewRequested()&lt;/a&gt; signal. (Added in Qt 5.6)</source>
          <target state="translated">새 탭에서 현재 링크를 엽니 다. &lt;a href=&quot;qml-qtwebengine-webengineview#newViewRequested-signal&quot;&gt;newViewRequested ()&lt;/a&gt; 신호에 대한 핸들러가 필요합니다 . (Qt 5.6에서 추가됨)</target>
        </trans-unit>
        <trans-unit id="82128e25279b8bb1201668c83c78bb1070ded0a0" translate="yes" xml:space="preserve">
          <source>Open the current link in a new tab. Requires implementation of &lt;a href=&quot;qwebenginepage#createWindow&quot;&gt;createWindow&lt;/a&gt;(). (Added in Qt 5.6)</source>
          <target state="translated">새 탭에서 현재 링크를 엽니 다. &lt;a href=&quot;qwebenginepage#createWindow&quot;&gt;createWindow&lt;/a&gt; () 구현이 필요합니다 . (Qt 5.6에서 추가됨)</target>
        </trans-unit>
        <trans-unit id="9ea809cf8428cad9e799c81db11d21af837e28e0" translate="yes" xml:space="preserve">
          <source>Open the current link in a new window. Requires a handler for the &lt;a href=&quot;qml-qtwebengine-webengineview#newViewRequested-signal&quot;&gt;newViewRequested()&lt;/a&gt; signal. (Added in Qt 5.6)</source>
          <target state="translated">새 창에서 현재 링크를 엽니 다. &lt;a href=&quot;qml-qtwebengine-webengineview#newViewRequested-signal&quot;&gt;newViewRequested ()&lt;/a&gt; 신호에 대한 핸들러가 필요합니다 . (Qt 5.6에서 추가됨)</target>
        </trans-unit>
        <trans-unit id="ae6da494fcca9762429920a21f908d25600b5222" translate="yes" xml:space="preserve">
          <source>Open the current link in a new window. Requires implementation of &lt;a href=&quot;qwebenginepage#createWindow&quot;&gt;createWindow&lt;/a&gt;(). (Added in Qt 5.6)</source>
          <target state="translated">새 창에서 현재 링크를 엽니 다. &lt;a href=&quot;qwebenginepage#createWindow&quot;&gt;createWindow&lt;/a&gt; () 구현이 필요합니다 . (Qt 5.6에서 추가됨)</target>
        </trans-unit>
        <trans-unit id="97d4b2de4b5f441f4e975d86b0110002b0873bcf" translate="yes" xml:space="preserve">
          <source>Open the current link in the current window. (Added in Qt 5.6)</source>
          <target state="translated">현재 창에서 현재 링크를 엽니 다. (Qt 5.6에서 추가됨)</target>
        </trans-unit>
        <trans-unit id="5111ec84b2fda68a4ada2a5f2fcaa72c71a13f90" translate="yes" xml:space="preserve">
          <source>Open the downloaded file in XCode to install. Now the next time you plug in one of the registered devices, your Provisioning Profile should be installed to it automatically.</source>
          <target state="translated">XCode에서 다운로드 한 파일을 열어 설치하십시오. 다음에 등록 된 장치 중 하나를 연결하면 프로비저닝 프로파일이 자동으로 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="a789f149f1f14263e073d943c3d01a179d6b7835" translate="yes" xml:space="preserve">
          <source>Open the preferences dialog.</source>
          <target state="translated">환경 설정 대화 상자를여십시오.</target>
        </trans-unit>
        <trans-unit id="b820cf27c8331fa6c15a1db2c6f8e5022d105bd0" translate="yes" xml:space="preserve">
          <source>Open your Qt project using Qt Creator and update the &quot;Build Android APK&quot; settings to add</source>
          <target state="translated">Qt Creator를 사용하여 Qt 프로젝트를 열고 &quot;Android APK 빌드&quot;설정을 업데이트하여 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="84d92f56dc3762ec725f1b9f285427ff847a4821" translate="yes" xml:space="preserve">
          <source>Open your application project using Qt Creator v3.0 or later and change its &lt;b&gt;Build&lt;/b&gt; settings to build release version.</source>
          <target state="translated">Qt Creator v3.0 이상을 사용하여 애플리케이션 프로젝트를 열고 &lt;b&gt;빌드&lt;/b&gt; 설정을 빌드 릴리스 버전으로 변경 &lt;b&gt;하십시오&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="ce5e18fffa63a04452089fd124c29ad47b7dfd20" translate="yes" xml:space="preserve">
          <source>Open your project with Qt Creator 4.11 or later choosing a &lt;code&gt;Release Build&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Release Build&lt;/code&gt; 선택하여 Qt Creator 4.11 이상으로 프로젝트를 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="e82abfb14301374b0bf6bab941ad4a36972107f1" translate="yes" xml:space="preserve">
          <source>OpenDocument Format</source>
          <target state="translated">OpenDocument 형식</target>
        </trans-unit>
        <trans-unit id="64772f9d09ee3b76e5bdf35aaa7583343125a29f" translate="yes" xml:space="preserve">
          <source>OpenGL</source>
          <target state="translated">OpenGL</target>
        </trans-unit>
        <trans-unit id="d12efdce0e121c10fce10e3b3723f80b28aff57c" translate="yes" xml:space="preserve">
          <source>OpenGL &amp;gt;=3.3 offers full support for all timer query functionality.</source>
          <target state="translated">OpenGL&amp;gt; = 3.3은 모든 타이머 쿼리 기능을 완벽하게 지원합니다.</target>
        </trans-unit>
        <trans-unit id="bcc7e4ffde0447e8d94b409aa54d1df052a2173f" translate="yes" xml:space="preserve">
          <source>OpenGL &amp;lt;=3.2 with the EXT_timer_query extension offers limited support in that the timestamp of the GPU cannot be queried. Places where this impacts functions provided by Qt classes will be highlighted in the function documentation.</source>
          <target state="translated">EXT_timer_query 확장을 사용하는 OpenGL &amp;lt;= 3.2는 GPU의 타임 스탬프를 쿼리 할 수 ​​없다는 제한적인 지원을 제공합니다. 이것이 Qt 클래스가 제공하는 기능에 영향을 미치는 장소는 기능 문서에서 강조 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9b75b066713db25e48eedcfb6c8ded476f7f581a" translate="yes" xml:space="preserve">
          <source>OpenGL - Request with the &lt;code&gt;&quot;&quot;&lt;/code&gt; string or the &lt;a href=&quot;qsgrendererinterface#GraphicsApi-enum&quot;&gt;QSGRendererInterface::OpenGL&lt;/a&gt; enum value.</source>
          <target state="translated">OpenGL을 -에 요청 &lt;code&gt;&quot;&quot;&lt;/code&gt; 문자열이나 &lt;a href=&quot;qsgrendererinterface#GraphicsApi-enum&quot;&gt;QSGRendererInterface :: OpenGL을&lt;/a&gt; 열거 값입니다.</target>
        </trans-unit>
        <trans-unit id="5f032e0e29f26bb6d0f2e99a4a2243617b0f848e" translate="yes" xml:space="preserve">
          <source>OpenGL 2.0 (ES) - This backend is the primary backend for hardware accelerated graphics. It can be run on desktop machines and embedded devices supporting the OpenGL 2.0 or OpenGL/ES 2.0 specification. This includes most graphics chips produced in the last couple of years. The engine can be enabled by using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; onto a &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;.</source>
          <target state="translated">OpenGL 2.0 (ES)-이 백엔드는 하드웨어 가속 그래픽의 기본 백엔드입니다. OpenGL 2.0 또는 OpenGL / ES 2.0 사양을 지원하는 데스크탑 시스템 및 임베디드 장치에서 실행할 수 있습니다. 여기에는 지난 몇 년 동안 생산 된 대부분의 그래픽 칩이 포함됩니다. &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 를 사용하여 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 에 엔진을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6efb8bd544d6d15fd4166180e3dc22214055cbd" translate="yes" xml:space="preserve">
          <source>OpenGL 2.0 (ES) - This backend is the primary backend for hardware accelerated graphics. It can be run on desktop machines and embedded devices supporting the OpenGL 2.0 or OpenGL/ES 2.0 specification. This includes most graphics chips produced in the last couple of years. The engine can be enabled by using QPainter onto a &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;.</source>
          <target state="translated">OpenGL 2.0 (ES)-이 백엔드는 하드웨어 가속 그래픽을위한 기본 백엔드입니다. OpenGL 2.0 또는 OpenGL / ES 2.0 사양을 지원하는 데스크톱 컴퓨터 및 임베디드 장치에서 실행할 수 있습니다. 여기에는 지난 몇 년 동안 생산 된 대부분의 그래픽 칩이 포함됩니다. 엔진은 QPainter를 사용하여 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget에서&lt;/a&gt; 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f5d92dc82f07f9f744501c6bc8fa5ba15fd12b2" translate="yes" xml:space="preserve">
          <source>OpenGL 3.2 with the ARB_timer_query extension offers full support for all timer query functionality.</source>
          <target state="translated">ARB_timer_query 확장 기능이있는 OpenGL 3.2는 모든 타이머 쿼리 기능을 완벽하게 지원합니다.</target>
        </trans-unit>
        <trans-unit id="cc2b8bd006f1a57517adb44ab729ab6e83985bce" translate="yes" xml:space="preserve">
          <source>OpenGL 4 supports the following image types:</source>
          <target state="translated">OpenGL 4는 다음 이미지 유형을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2b36900738c0a893ab6919f890e8f56b7a386f66" translate="yes" xml:space="preserve">
          <source>OpenGL Context and Surface Formats</source>
          <target state="translated">OpenGL 컨텍스트 및 표면 형식</target>
        </trans-unit>
        <trans-unit id="30f78328bfe51246ab99f1ffe49114584e8cb9a6" translate="yes" xml:space="preserve">
          <source>OpenGL Dependencies</source>
          <target state="translated">OpenGL 종속성</target>
        </trans-unit>
        <trans-unit id="aca3dc169de5f38b5968729231439d3cd63067a1" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2 (and OpenGL ES 3) do not provide any support for OpenGL timer queries.</source>
          <target state="translated">OpenGL ES 2 (및 OpenGL ES 3)는 OpenGL 타이머 쿼리를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8528996357def6b2ee77b7ed4716c024a229c7bb" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2 Headers, version Revision 27673</source>
          <target state="translated">OpenGL ES 2 헤더, 버전 개정판 27673</target>
        </trans-unit>
        <trans-unit id="28ec8a1a4e144097de11fa9111581fb2f78bacbd" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0 and OpenGL 2.0 Adaptation</source>
          <target state="translated">OpenGL ES 2.0 및 OpenGL 2.0 적응</target>
        </trans-unit>
        <trans-unit id="b624a860458ca2802592749e5d6e04887207e2ec" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0 or higher</source>
          <target state="translated">OpenGL ES 2.0 이상</target>
        </trans-unit>
        <trans-unit id="c787f7804f7c027f7386757989e787a8809ea370" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0 or higher via a graphics abstraction layer. This value was introduced in Qt 5.14.</source>
          <target state="translated">그래픽 추상화 계층을 통한 OpenGL ES 2.0 이상. 이 값은 Qt 5.14에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="928fae1f36ba5f1a61ad9cd6282f9bc9274a6894" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0 rendering</source>
          <target state="translated">OpenGL ES 2.0 렌더링</target>
        </trans-unit>
        <trans-unit id="7bd26d5c9f5b257442ce04ba1950ffc381e54c6e" translate="yes" xml:space="preserve">
          <source>OpenGL ES 2.0 support</source>
          <target state="translated">OpenGL ES 2.0 지원</target>
        </trans-unit>
        <trans-unit id="ffd36959c7e2c9cda19077950e970fcc299baed7" translate="yes" xml:space="preserve">
          <source>OpenGL ES 3.1 supports the following image types:</source>
          <target state="translated">OpenGL ES 3.1은 다음 이미지 유형을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="109bce85707f386a325abddc58886228c1888366" translate="yes" xml:space="preserve">
          <source>OpenGL ES 3.2 supports all of the OpenGL ES 3.1 image types as well as the following:</source>
          <target state="translated">OpenGL ES 3.2는 모든 OpenGL ES 3.1 이미지 유형과 다음을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="93e570c1cc4d9045459f6ab709a96fff41b27d4a" translate="yes" xml:space="preserve">
          <source>OpenGL Example (ActiveQt)</source>
          <target state="translated">OpenGL 예 (ActiveQt)</target>
        </trans-unit>
        <trans-unit id="a0c527bf3fa5dad934d29c527693935796b2dc68" translate="yes" xml:space="preserve">
          <source>OpenGL Function Calls, Headers and QOpenGLFunctions</source>
          <target state="translated">OpenGL 함수 호출, 헤더 및 QOpenGL 함수</target>
        </trans-unit>
        <trans-unit id="d0006ab36f4957aaf0889a6c16f63ad773143d67" translate="yes" xml:space="preserve">
          <source>OpenGL Headers, version Revision 27684</source>
          <target state="translated">OpenGL 헤더, 버전 개정 27684</target>
        </trans-unit>
        <trans-unit id="2cb7103e96f7a466ba9c9b5d864938215a6fa50d" translate="yes" xml:space="preserve">
          <source>OpenGL Options for Windows</source>
          <target state="translated">Windows 용 OpenGL 옵션</target>
        </trans-unit>
        <trans-unit id="10479327b0637b356bf5072417694c9407fe896f" translate="yes" xml:space="preserve">
          <source>OpenGL Rendering</source>
          <target state="translated">OpenGL 렌더링</target>
        </trans-unit>
        <trans-unit id="68e160a8f4c96b2721ebbb37db644a3d99540eab" translate="yes" xml:space="preserve">
          <source>OpenGL Requirements</source>
          <target state="translated">OpenGL 요구 사항</target>
        </trans-unit>
        <trans-unit id="980dd0fad4f15bb580ff542e5a6d67c152defd17" translate="yes" xml:space="preserve">
          <source>OpenGL Special Considerations</source>
          <target state="translated">OpenGL 특별 고려 사항</target>
        </trans-unit>
        <trans-unit id="2f0013897cd3ac5b738dfa2ff5bfab59d16824ef" translate="yes" xml:space="preserve">
          <source>OpenGL Texture Files</source>
          <target state="translated">OpenGL 텍스처 파일</target>
        </trans-unit>
        <trans-unit id="42bf11baf873ac0a840dfda55c900ab17b72bec4" translate="yes" xml:space="preserve">
          <source>OpenGL Type Enum</source>
          <target state="translated">OpenGL 유형 열거 형</target>
        </trans-unit>
        <trans-unit id="d8e8a9d3932e7785c9ba77afea18d6965827f9b9" translate="yes" xml:space="preserve">
          <source>OpenGL Under QML</source>
          <target state="translated">QML에서 OpenGL</target>
        </trans-unit>
        <trans-unit id="f2e7e629cbe6e02e443fae121cebfd9bbcc65268" translate="yes" xml:space="preserve">
          <source>OpenGL and GLSL</source>
          <target state="translated">OpenGL과 GLSL</target>
        </trans-unit>
        <trans-unit id="de500a1f2e503efdf021f0170e6e3bf8d02346fa" translate="yes" xml:space="preserve">
          <source>OpenGL and OpenGL ES Integration</source>
          <target state="translated">OpenGL과 OpenGL ES 통합</target>
        </trans-unit>
        <trans-unit id="6aef5a49f83c73bc077153cf40a6d62de354c546" translate="yes" xml:space="preserve">
          <source>OpenGL classes</source>
          <target state="translated">OpenGL 클래스</target>
        </trans-unit>
        <trans-unit id="3f0e94498e0df0fe1e9678c76a569141379d3849" translate="yes" xml:space="preserve">
          <source>OpenGL debug log</source>
          <target state="translated">OpenGL 디버그 로그</target>
        </trans-unit>
        <trans-unit id="0a36c9883a584af1ab8e8efaf4cb32b2bc7673a2" translate="yes" xml:space="preserve">
          <source>OpenGL implementations keep an internal log of debug messages. Messages stored in this log can be retrieved by using the &lt;a href=&quot;qopengldebuglogger#loggedMessages&quot;&gt;loggedMessages&lt;/a&gt;() function:</source>
          <target state="translated">OpenGL 구현은 내부 디버그 메시지 로그를 유지합니다. 이 로그에 저장된 메시지는 &lt;a href=&quot;qopengldebuglogger#loggedMessages&quot;&gt;loggingMessages&lt;/a&gt; () 함수를 사용하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f82e967a5973c20a37a758671fdf52a222a11827" translate="yes" xml:space="preserve">
          <source>OpenGL implementations on different platforms are able to link to a variable number of OpenGL functions depending upon the OpenGL ABI on that platform. For example, on Microsoft Windows only functions up to those in OpenGL 1.1 can be linked to at build time. All other functions must be resolved at runtime. The traditional solution to this has been to use either &lt;a href=&quot;qopenglcontext#getProcAddress&quot;&gt;QOpenGLContext::getProcAddress&lt;/a&gt;() or &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt;. The former is tedious and error prone and means dealing directly with function pointers. The latter only exposes those functions common to OpenGL ES 2 and desktop OpenGL. There is however much new OpenGL functionality that is useful when writing real world OpenGL applications.</source>
          <target state="translated">다른 플랫폼에서의 OpenGL 구현은 해당 플랫폼의 OpenGL ABI에 따라 다양한 수의 OpenGL 함수에 링크 할 수 있습니다. 예를 들어, Microsoft Windows에서는 OpenGL 1.1의 기능까지만 빌드시 링크 할 수 있습니다. 다른 모든 기능은 런타임에 해결해야합니다. 이에 대한 기존 솔루션은 &lt;a href=&quot;qopenglcontext#getProcAddress&quot;&gt;QOpenGLContext :: getProcAddress&lt;/a&gt; () 또는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions를 사용하는 것&lt;/a&gt; 입니다. 전자는 지루하고 오류가 발생하기 쉽고 함수 포인터를 직접 처리하는 것을 의미합니다. 후자는 OpenGL ES 2 및 데스크탑 OpenGL에 공통적 인 기능 만 노출합니다. 그러나 실제 OpenGL 응용 프로그램을 작성할 때 유용한 새로운 OpenGL 기능이 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb4ddfad084a2a2291c8e56f4b3e56d55e8544de" translate="yes" xml:space="preserve">
          <source>OpenGL implementations on different platforms are able to link to a variable number of OpenGL functions depending upon the OpenGL ABI on that platform. For example, on Microsoft Windows only functions up to those in OpenGL 1.1 can be linked to at build time. All other functions must be resolved at runtime. The traditional solution to this has been to use either &lt;a href=&quot;qopenglcontext#getProcAddress&quot;&gt;QOpenGLContext::getProcAddress&lt;/a&gt;() or &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt;. The former is tedious and error prone and means dealing directly with function pointers. The latter only exposes those functions common to OpenGL ES 2 and desktop OpenGL. There is however much new OpenGL functionality that is useful when writing real world OpenGL applications.</source>
          <target state="translated">다른 플랫폼에서의 OpenGL 구현은 해당 플랫폼의 OpenGL ABI에 따라 다양한 수의 OpenGL 함수에 연결할 수 있습니다. 예를 들어, Microsoft Windows에서는 OpenGL 1.1의 기능까지만 빌드시 링크 할 수 있습니다. 다른 모든 함수는 런타임에 해결되어야합니다. 이에 대한 전통적인 해결책은 &lt;a href=&quot;qopenglcontext#getProcAddress&quot;&gt;QOpenGLContext :: getProcAddress&lt;/a&gt; () 또는 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qopenglfunctions.html&quot;&gt;QOpenGLFunctions를 사용하는 것&lt;/a&gt; 입니다. 전자는 지루하고 오류가 발생하기 쉬우 며 함수 포인터를 직접 처리하는 것을 의미합니다. 후자는 OpenGL ES 2 및 데스크톱 OpenGL에 공통적 인 기능 만 노출합니다. 그러나 실제 OpenGL 응용 프로그램을 작성할 때 유용한 새로운 OpenGL 기능이 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ae187bc83114d042a48f9fae0b78ae0e3340400" translate="yes" xml:space="preserve">
          <source>OpenGL implementations on different platforms are able to link to a variable number of OpenGL functions depending upon the OpenGL ABI on that platform. For example, on Microsoft Windows only functions up to those in OpenGL 1.1 can be linked to at build time. All other functions must be resolved at runtime. The traditional solution to this has been to use either &lt;a href=&quot;qopenglcontext#getProcAddress&quot;&gt;QOpenGLContext::getProcAddress&lt;/a&gt;() or &lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt;. The former is tedious and error prone and means dealing directly with function pointers. The latter only exposes those functions common to OpenGL ES 2 and desktop OpenGL. There is however much new OpenGL functionality that is useful when writing real world OpenGL applications.</source>
          <target state="translated">다른 플랫폼의 OpenGL 구현은 해당 플랫폼의 OpenGL ABI에 따라 다양한 수의 OpenGL 함수에 연결할 수 있습니다. 예를 들어, Microsoft Windows에서는 OpenGL 1.1의 기능까지만 빌드시 링크 할 수 있습니다. 다른 모든 함수는 런타임에 해결되어야합니다. 이에 대한 전통적인 해결책은 &lt;a href=&quot;qopenglcontext#getProcAddress&quot;&gt;QOpenGLContext :: getProcAddress&lt;/a&gt; () 또는 &lt;a href=&quot;https://doc.qt.io/qt-6.0/qopenglfunctions.html&quot;&gt;QOpenGLFunctions를 사용하는 것&lt;/a&gt; 입니다. 전자는 지루하고 오류가 발생하기 쉬우 며 함수 포인터를 직접 처리하는 것을 의미합니다. 후자는 OpenGL ES 2 및 데스크톱 OpenGL에 공통적 인 기능 만 노출합니다. 그러나 실제 OpenGL 응용 프로그램을 작성할 때 유용한 새로운 OpenGL 기능이 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0d3935585b34b3d7077e7f4ebc00a3b10364442" translate="yes" xml:space="preserve">
          <source>OpenGL is a trademark of Silicon Graphics, Inc. in the United States and other countries.</source>
          <target state="translated">OpenGL은 미국 및 기타 국가에서 Silicon Graphics, Inc.의 상표입니다.</target>
        </trans-unit>
        <trans-unit id="8a9b1426b2e41bf88077993ad398d30054178ea0" translate="yes" xml:space="preserve">
          <source>OpenGL offers various levels of support for timer queries, depending on the version of OpenGL you have and the presence of the ARB_timer_query or EXT_timer_query extensions. The support can be summarized as:</source>
          <target state="translated">OpenGL은 보유한 OpenGL의 버전과 ARB_timer_query 또는 EXT_timer_query 확장의 존재 여부에 따라 타이머 쿼리에 대한 다양한 수준의 지원을 제공합니다. 지원은 다음과 같이 요약 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff5da30ddf744e7958dfb126c7a199bcf764ce9a" translate="yes" xml:space="preserve">
          <source>OpenGL pre-3.0: Set the same blend state for all draw buffers (one &lt;a href=&quot;qt3drender-qblendequationarguments&quot;&gt;QBlendEquationArguments&lt;/a&gt;) OpenGL 3.0-pre4.0: Set the same blend state for all draw buffers, but can disable blending for particular buffers (one &lt;a href=&quot;qt3drender-qblendequationarguments&quot;&gt;QBlendEquationArguments&lt;/a&gt; for setting glBlendFunc, n QBlendEquationArgumentss for enabling/disabling Draw Buffers) OpenGL 4.0+: Can set blend state individually for each draw buffer.</source>
          <target state="translated">모든 연신 버퍼 (하나의 집합에 동일한 혼합 상태 : 3.0 미리 OpenGL은 &lt;a href=&quot;qt3drender-qblendequationarguments&quot;&gt;QBlendEquationArguments&lt;/a&gt; )는 OpenGL 3.0 pre4.0 모든 연신 버퍼에 설정된 동일한 혼합 상태로 할 수 있지만, 특히 버퍼 (하나 비활성화 혼합 &lt;a href=&quot;qt3drender-qblendequationarguments&quot;&gt;QBlendEquationArguments&lt;/a&gt; glBlendFunc 설정에있어서, n QBlendEquation 인발 버퍼 활성화 / 비활성화에 대한 인수) OpenGL 4.0+ : 각 인출 버퍼에 대해 개별적으로 혼합 상태를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e86f6a1c8a248e628e09c53599e252dd74d2ef2" translate="yes" xml:space="preserve">
          <source>OpenGL pre-3.0: Set the same blend state for all draw buffers (one QBlendEquationArguments) OpenGL 3.0-pre4.0: Set the same blend state for all draw buffers, but can disable blending for particular buffers (one QBlendEquationArguments for setting glBlendFunc, n QBlendEquationArgumentss for enabling/disabling Draw Buffers) OpenGL 4.0+: Can set blend state individually for each draw buffer.</source>
          <target state="translated">OpenGL 3.0 이전 버전 : 모든 드로 버퍼에 대해 동일한 블렌드 상태 설정 (QBlendEquationArguments 하나) OpenGL 3.0-pre4.0 : 모든 드로 버퍼에 대해 동일한 블렌드 상태를 설정하지만 특정 버퍼에 대한 블렌딩을 비활성화 할 수 있습니다 (glBlendFunc 설정을위한 하나의 QBlendEquationArguments, n 그리기 버퍼 활성화 / 비활성화를위한 QBlendEquationArgumentss) OpenGL 4.0+ : 각 그리기 버퍼에 대해 블렌드 상태를 개별적으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3a1862a13d7eb7f34735beabbce032097b0eab9" translate="yes" xml:space="preserve">
          <source>OpenGL pre-3.0: Set the same blend state for all draw buffers OpenGL 3.0-pre4.0: Set the same blend state for all draw buffers, but can disable blending for particular buffers OpenGL 4.0+: Can set blend state individually for each draw buffer.</source>
          <target state="translated">OpenGL pre-3.0 : 모든 드로우 버퍼에 대해 동일한 블렌드 상태 설정 OpenGL 3.0-pre4.0 : 모든 드로우 버퍼에 대해 동일한 블렌드 상태를 설정하지만 특정 버퍼에 대한 블렌딩을 비활성화 할 수 있습니다 OpenGL 4.0+ : 각 드로우에 대해 개별적으로 블렌드 상태를 설정할 수 있습니다 완충기.</target>
        </trans-unit>
        <trans-unit id="6636612aa6c727ff72ca590587d618c3013d1337" translate="yes" xml:space="preserve">
          <source>OpenGL programming can be very error prone. Most of the time, a single failing call to OpenGL can cause an entire portion of an application to stop working, with nothing being drawn on the screen.</source>
          <target state="translated">OpenGL 프로그래밍은 오류가 발생하기 쉽습니다. 대부분의 경우 OpenGL을 한 번만 호출하면 응용 프로그램의 전체 부분이 작동하지 않고 화면에 아무것도 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74929da08ad08e3e471771cad96fe3e9e68e1cac" translate="yes" xml:space="preserve">
          <source>OpenGL represents time with a granularity of 1 nanosecond (1e-9 seconds). As a consequence of this, 32-bit integers would only give a total possible duration of approximately 4 seconds, which would not be difficult to exceed in poorly performing or lengthy operations. OpenGL therefore uses 64 bit integer types to represent times. A GLuint64 variable has enough width to contain a duration of hundreds of years, which is plenty for real-time rendering needs.</source>
          <target state="translated">OpenGL은 1 나노초 (1e-9 초)의 단위 시간을 나타냅니다. 결과적으로 32 비트 정수는 총 약 4 초의 지속 시간 만 제공하므로 성능이 저하되거나 긴 작업에서 초과하기 어렵지 않습니다. 따라서 OpenGL은 64 비트 정수 유형을 사용하여 시간을 나타냅니다. GLuint64 변수는 수백 년의 지속 시간을 포함하기에 충분한 너비를 가지고있어 실시간 렌더링 요구에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="67ec6b6d738192d0de564256a8647a1cdcabf5ac" translate="yes" xml:space="preserve">
          <source>OpenGL specifics</source>
          <target state="translated">OpenGL 사양</target>
        </trans-unit>
        <trans-unit id="69798ea739aa41ef0c4de9bd92521f9162d1461a" translate="yes" xml:space="preserve">
          <source>OpenGL state when invoking &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;(). &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; sets up the viewport via glViewport(). It does not perform any clearing.</source>
          <target state="translated">&lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt; ()을 호출 할 때 OpenGL 상태 입니다. &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 은 glViewport ()를 통해 뷰포트를 설정합니다. 삭제를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c1c869d57dd2c8c3f3524df5d552165108bfd76" translate="yes" xml:space="preserve">
          <source>OpenGL state when invoking &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;(). QOpenGLWidget sets up the viewport via glViewport(). It does not perform any clearing.</source>
          <target state="translated">&lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt; () 호출시 OpenGL 상태 . QOpenGLWidget은 glViewport ()를 통해 뷰포트를 설정합니다. 지우기를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="804ac47a55b34e299195bb4758d3ebb407bbfbef" translate="yes" xml:space="preserve">
          <source>OpenGL timer query objects are OpenGL managed resources to measure the execution times of sequences of OpenGL commands on the GPU.</source>
          <target state="translated">OpenGL 타이머 쿼리 객체는 GPU에서 OpenGL 명령 시퀀스의 실행 시간을 측정하기위한 OpenGL 관리 리소스입니다.</target>
        </trans-unit>
        <trans-unit id="13688a054c6bd464f78b8a626dc59dbfa982fe4e" translate="yes" xml:space="preserve">
          <source>OpenGL version 3.1 removed many deprecated functions leading to a much simpler and generic API.</source>
          <target state="translated">OpenGL 버전 3.1은 더 이상 사용되지 않는 함수를 제거하여 훨씬 단순하고 일반적인 API로 이어졌습니다.</target>
        </trans-unit>
        <trans-unit id="23dde3419f800291716b40dc803f543cfc6c3c08" translate="yes" xml:space="preserve">
          <source>OpenGL version is lower than 3.2. For 3.2 and newer this is same as CoreProfile.</source>
          <target state="translated">OpenGL 버전이 3.2보다 낮습니다. 3.2 이상에서는 CoreProfile과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f75b5ecdaec2300b73e3e1c6fd168a7010d61e20" translate="yes" xml:space="preserve">
          <source>OpenGL version.</source>
          <target state="translated">OpenGL 버전.</target>
        </trans-unit>
        <trans-unit id="3cb3279787d68147999b20232be635a5bdbe5215" translate="yes" xml:space="preserve">
          <source>OpenGL versions.</source>
          <target state="translated">OpenGL 버전.</target>
        </trans-unit>
        <trans-unit id="443bcbfce9c582fb0ff3ab8d9e0842ce91a13bb7" translate="yes" xml:space="preserve">
          <source>OpenGLInfo (QML type)</source>
          <target state="translated">OpenGLInfo (QML 유형)</target>
        </trans-unit>
        <trans-unit id="d73e46bef76ec6fb139c37385d7f0b256e3c4e23" translate="yes" xml:space="preserve">
          <source>OpenGLInfo QML Type</source>
          <target state="translated">OpenGLInfo QML 유형</target>
        </trans-unit>
        <trans-unit id="2d38cd821a8b01f3a32ed81abcdd215d019b1232" translate="yes" xml:space="preserve">
          <source>OpenGLInfo.majorVersion</source>
          <target state="translated">OpenGLInfo.majorVersion</target>
        </trans-unit>
        <trans-unit id="585b561eab6d54d94b33e1a1382b6839b3a9d92c" translate="yes" xml:space="preserve">
          <source>OpenGLInfo.minorVersion</source>
          <target state="translated">OpenGLInfo.minorVersion</target>
        </trans-unit>
        <trans-unit id="97849a180b768b060dc07fa311636a9897cb9eb6" translate="yes" xml:space="preserve">
          <source>OpenGLInfo.profile</source>
          <target state="translated">OpenGLInfo.profile</target>
        </trans-unit>
        <trans-unit id="536b73656cc83f653756ed8fe0708babda11768e" translate="yes" xml:space="preserve">
          <source>OpenGLInfo.renderableType</source>
          <target state="translated">OpenGLInfo.renderableType</target>
        </trans-unit>
        <trans-unit id="472334b926db37e8b1ba9a091cdc0aa12469e6de" translate="yes" xml:space="preserve">
          <source>OpenID</source>
          <target state="translated">OpenID</target>
        </trans-unit>
        <trans-unit id="15d13e026d7f1cb8bf733e389ef768f5e8598b6b" translate="yes" xml:space="preserve">
          <source>OpenID Connect</source>
          <target state="translated">OpenID Connect</target>
        </trans-unit>
        <trans-unit id="2fe481bea9644021ef4e126d4f53f6ec4cf02f16" translate="yes" xml:space="preserve">
          <source>OpenSSL Support</source>
          <target state="translated">OpenSSL 지원</target>
        </trans-unit>
        <trans-unit id="0e7347494380c3d68e2ccca88d5e7547bdb65192" translate="yes" xml:space="preserve">
          <source>OpenType fonts</source>
          <target state="translated">OpenType 글꼴</target>
        </trans-unit>
        <trans-unit id="f41d9261b712e5021129d0856247ff2d97a74963" translate="yes" xml:space="preserve">
          <source>OpenVG</source>
          <target state="translated">OpenVG</target>
        </trans-unit>
        <trans-unit id="d332cce636468d0759e008a892bcfcc2ff00a440" translate="yes" xml:space="preserve">
          <source>OpenVG Adaptation</source>
          <target state="translated">OpenVG 적응</target>
        </trans-unit>
        <trans-unit id="19ee20683a8aa9b231bb591a1c280dec3da089bb" translate="yes" xml:space="preserve">
          <source>OpenWF Display support for managing display control hardware.</source>
          <target state="translated">디스플레이 제어 하드웨어 관리를위한 OpenWF 디스플레이 지원.</target>
        </trans-unit>
        <trans-unit id="968b17f019d0c5690bc98d3470cbb44054fb1437" translate="yes" xml:space="preserve">
          <source>OpenWnn</source>
          <target state="translated">OpenWnn</target>
        </trans-unit>
        <trans-unit id="eba068cf3b59b0869bdd6cfedbd83b7d5b61562d" translate="yes" xml:space="preserve">
          <source>Opening External Resources</source>
          <target state="translated">외부 자료 열기</target>
        </trans-unit>
        <trans-unit id="27fe08766cb424ed43989f55aaf282d844b436ed" translate="yes" xml:space="preserve">
          <source>Opening the Keyboard</source>
          <target state="translated">키보드 열기</target>
        </trans-unit>
        <trans-unit id="8514051decfc8de9c6a80891022135ac3565eb2b" translate="yes" xml:space="preserve">
          <source>Opens a &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; on the</source>
          <target state="translated">에 &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; 을 엽니 다</target>
        </trans-unit>
        <trans-unit id="66f371606e547d49af865516e43912b65e46989f" translate="yes" xml:space="preserve">
          <source>Opens a D-Bus map entry suitable for appending the key and value entries. This function is only valid when a map has been opened with &lt;a href=&quot;qdbusargument#beginMap-1&quot;&gt;beginMap&lt;/a&gt;().</source>
          <target state="translated">키 및 값 항목을 추가하기에 적합한 D-Bus 맵 항목을 엽니 다. 이 함수는 &lt;a href=&quot;qdbusargument#beginMap-1&quot;&gt;beginMap&lt;/a&gt; () 으로 맵을 연 경우에만 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="1cdb75ec9ab03beed194df942da781c2fdca8674" translate="yes" xml:space="preserve">
          <source>Opens a D-Bus map entry suitable for appending the key and value entries. This function is only valid when a map has been opened with &lt;a href=&quot;qdbusargument#beginMap-2&quot;&gt;beginMap&lt;/a&gt;().</source>
          <target state="translated">키 및 값 항목을 추가하는 데 적합한 D-Bus 맵 항목을 엽니 다. 이 함수는 &lt;a href=&quot;qdbusargument#beginMap-2&quot;&gt;beginMap&lt;/a&gt; () 으로 맵을 연 경우에만 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="74d56b2da788a2ff7922b049fe26dacd5a25773d" translate="yes" xml:space="preserve">
          <source>Opens a D-Bus structure suitable for extracting elements.</source>
          <target state="translated">요소 추출에 적합한 D-Bus 구조를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="aa3074c5a81b3d25e931eec32a88ed6051192d1c" translate="yes" xml:space="preserve">
          <source>Opens a WebSocket connection using the given</source>
          <target state="translated">주어진 것을 사용하여 WebSocket 연결을 엽니 다</target>
        </trans-unit>
        <trans-unit id="ef13174056a4b88128e92ecaf358a7ec8aa33d2c" translate="yes" xml:space="preserve">
          <source>Opens a connection of type</source>
          <target state="translated">유형의 연결을 엽니 다</target>
        </trans-unit>
        <trans-unit id="23d6253f7d2771f5765ce0ebc3b8e27ec71fa606" translate="yes" xml:space="preserve">
          <source>Opens a connection to a private bus on address</source>
          <target state="translated">주소에 개인 버스 연결을 엽니 다</target>
        </trans-unit>
        <trans-unit id="63e02885e93346120fc1fe7750f00e69e8d4f3db" translate="yes" xml:space="preserve">
          <source>Opens a critical message box with the given</source>
          <target state="translated">주어진 중요한 메시지 상자를 엽니 다</target>
        </trans-unit>
        <trans-unit id="91d8c3349dfc76fd55aaf7ea64135db73ece3b3e" translate="yes" xml:space="preserve">
          <source>Opens a dialog showing the plugins loaded by</source>
          <target state="translated">로드 한 플러그인을 보여주는 대화 상자를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="97d66350a79abf5d7d1ce53f421df0bcbb6013fe" translate="yes" xml:space="preserve">
          <source>Opens a new D-Bus array suitable for appending elements of meta-type</source>
          <target state="translated">메타 타입의 요소를 추가하기에 적합한 새로운 D- 버스 배열을 엽니 다</target>
        </trans-unit>
        <trans-unit id="8a3bab506d80395cf4d78d8ddb96e158adb282e3" translate="yes" xml:space="preserve">
          <source>Opens a new D-Bus map suitable for appending elements. Maps are containers that associate one entry (the key) to another (the value), such as Qt's &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; or &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;. The ids of the map's key and value meta types must be passed in</source>
          <target state="translated">요소 추가에 적합한 새로운 D- 버스 맵을 엽니 다. 맵은 한 항목 (키)을 다른 항목 (값) (예 : Qt 's &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; 또는 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash)에 연결하는 컨테이너&lt;/a&gt; 입니다. 지도의 키 및 값 메타 유형의 ID는</target>
        </trans-unit>
        <trans-unit id="9c47014befc4288a4176383fe88814302434b3b8" translate="yes" xml:space="preserve">
          <source>Opens a new D-Bus structure suitable for appending new arguments.</source>
          <target state="translated">새로운 인수를 추가하기에 적합한 새로운 D-Bus 구조를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="d1a111ecde9131326c70dc8736e2e0c6405c5e10" translate="yes" xml:space="preserve">
          <source>Opens a peer-to-peer connection on address</source>
          <target state="translated">주소에서 피어 투 피어 연결을 엽니 다</target>
        </trans-unit>
        <trans-unit id="15b8dbf9d202d94eb78e9883879d32f0ed05927f" translate="yes" xml:space="preserve">
          <source>Opens a persistent editor for the</source>
          <target state="translated">에 대한 영구 편집기를 엽니 다</target>
        </trans-unit>
        <trans-unit id="e4a6cab156d32b9604bbfbea75e5608b4ff7f73b" translate="yes" xml:space="preserve">
          <source>Opens a persistent editor on the item at the given</source>
          <target state="translated">주어진 항목에서 영구 편집기를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="3fb2e94012a7ef2d3ba59544d3bb174e7ebcfb64" translate="yes" xml:space="preserve">
          <source>Opens a question message box with the given</source>
          <target state="translated">주어진 질문 메시지 상자를 엽니 다</target>
        </trans-unit>
        <trans-unit id="ab4c01e328009965672d79122db9abc9a42c256e" translate="yes" xml:space="preserve">
          <source>Opens a warning message box with the given</source>
          <target state="translated">주어진 경고 메시지 상자를 엽니 다</target>
        </trans-unit>
        <trans-unit id="5a2c9424b166882775d47f640c389d95263cacf9" translate="yes" xml:space="preserve">
          <source>Opens an editor for the give</source>
          <target state="translated">기부에 대한 편집기를 엽니 다</target>
        </trans-unit>
        <trans-unit id="04140f785165ddff92c36fb1ef829c5e1a0ef856" translate="yes" xml:space="preserve">
          <source>Opens an editor for the given</source>
          <target state="translated">주어진 편집기를 엽니 다</target>
        </trans-unit>
        <trans-unit id="fb8fae47bdce07aacf91e703b806ca686f49c4b9" translate="yes" xml:space="preserve">
          <source>Opens an information message box with the given</source>
          <target state="translated">주어진 정보 메시지 상자를 엽니 다</target>
        </trans-unit>
        <trans-unit id="515775271b4a53c451c2a3915e283e324a11bc31" translate="yes" xml:space="preserve">
          <source>Opens the camera device. The camera state is changed to &lt;a href=&quot;qcamera#State-enum&quot;&gt;QCamera::LoadedState&lt;/a&gt;.</source>
          <target state="translated">카메라 장치를 엽니 다. 카메라 상태가 &lt;a href=&quot;qcamera#State-enum&quot;&gt;QCamera :: LoadedState로&lt;/a&gt; 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="31ab34e31dafd84be118819be9220d78ce486803" translate="yes" xml:space="preserve">
          <source>Opens the database connection using the current connection values. Returns &lt;code&gt;true&lt;/code&gt; on success; otherwise returns &lt;code&gt;false&lt;/code&gt;. Error information can be retrieved using &lt;a href=&quot;qsqldatabase#lastError&quot;&gt;lastError&lt;/a&gt;().</source>
          <target state="translated">현재 연결 값을 사용하여 데이터베이스 연결을 엽니 다. 성공하면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . &lt;a href=&quot;qsqldatabase#lastError&quot;&gt;lastError&lt;/a&gt; ()를 사용하여 오류 정보를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="993be9f3bb706f07f00b6182b8d3a0c8b25c6319" translate="yes" xml:space="preserve">
          <source>Opens the database connection using the given</source>
          <target state="translated">주어진 것을 사용하여 데이터베이스 연결을 엽니 다</target>
        </trans-unit>
        <trans-unit id="4301925a7020fb88a4b792f66a87ce1c02be265e" translate="yes" xml:space="preserve">
          <source>Opens the device and sets its &lt;a href=&quot;qiodevice#OpenModeFlag-enum&quot;&gt;OpenMode&lt;/a&gt; to</source>
          <target state="translated">장치를 &lt;a href=&quot;qiodevice#OpenModeFlag-enum&quot;&gt;열고 OpenMode&lt;/a&gt; 를</target>
        </trans-unit>
        <trans-unit id="2633c6d2902d9d3663d15cf15cfb268fbcde64ff" translate="yes" xml:space="preserve">
          <source>Opens the device and sets its &lt;a href=&quot;qiodevicebase#OpenModeFlag-enum&quot;&gt;OpenMode&lt;/a&gt; to</source>
          <target state="translated">장치를 &lt;a href=&quot;qiodevicebase#OpenModeFlag-enum&quot;&gt;열고 OpenMode&lt;/a&gt; 를 다음으로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="123e4507c7a0b637cfb40166dd065a3f17149e55" translate="yes" xml:space="preserve">
          <source>Opens the dialog and connects its &lt;a href=&quot;qcolordialog#colorSelected&quot;&gt;colorSelected&lt;/a&gt;() signal to the slot specified by</source>
          <target state="translated">대화 상자를 &lt;a href=&quot;qcolordialog#colorSelected&quot;&gt;열고 colorSelected&lt;/a&gt; () 신호를 지정된 슬롯에 연결합니다</target>
        </trans-unit>
        <trans-unit id="e5083a107f1177df363ca702507f56ddec21d01e" translate="yes" xml:space="preserve">
          <source>Opens the dialog and connects its &lt;a href=&quot;qdialog#accepted&quot;&gt;accepted&lt;/a&gt;() signal to the slot specified by</source>
          <target state="translated">대화 상자를 열고 &lt;a href=&quot;qdialog#accepted&quot;&gt;허용 된&lt;/a&gt; () 신호를</target>
        </trans-unit>
        <trans-unit id="3eb742621c223739e7f8808fc440f27bef3934cf" translate="yes" xml:space="preserve">
          <source>Opens the dialog and connects its &lt;a href=&quot;qdialog#finished&quot;&gt;finished&lt;/a&gt;() or &lt;a href=&quot;qmessagebox#buttonClicked&quot;&gt;buttonClicked&lt;/a&gt;() signal to the slot specified by</source>
          <target state="translated">대화 상자를 &lt;a href=&quot;qmessagebox#buttonClicked&quot;&gt;열고 &lt;/a&gt;&lt;a href=&quot;qdialog#finished&quot;&gt;완료된&lt;/a&gt; () 또는 buttonClicked () 신호를 지정된 슬롯에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="63a40029c97cc953f4f221972be9fb3a01154e0c" translate="yes" xml:space="preserve">
          <source>Opens the dialog and connects its &lt;a href=&quot;qfontdialog#fontSelected&quot;&gt;fontSelected&lt;/a&gt;() signal to the slot specified by</source>
          <target state="translated">대화 상자를 &lt;a href=&quot;qfontdialog#fontSelected&quot;&gt;열고 fontSelected&lt;/a&gt; () 신호를 지정된 슬롯에 연결합니다</target>
        </trans-unit>
        <trans-unit id="e36277a56397c0079c028872269761ff47976814" translate="yes" xml:space="preserve">
          <source>Opens the dialog and connects its &lt;a href=&quot;qprintdialog#accepted&quot;&gt;accepted&lt;/a&gt;() signal to the slot specified by</source>
          <target state="translated">대화 상자를 열고 &lt;a href=&quot;qprintdialog#accepted&quot;&gt;허용 된&lt;/a&gt; () 신호를</target>
        </trans-unit>
        <trans-unit id="0391e8ba283727c1adc9cd465b31b57187fa395b" translate="yes" xml:space="preserve">
          <source>Opens the dialog and connects its &lt;a href=&quot;qprogressdialog#canceled&quot;&gt;canceled&lt;/a&gt;() signal to the slot specified by</source>
          <target state="translated">대화 상자를 열고 &lt;a href=&quot;qprogressdialog#canceled&quot;&gt;취소 된&lt;/a&gt; () 신호를 지정된 슬롯에 연결합니다</target>
        </trans-unit>
        <trans-unit id="3011d3031b14f86f6abeb04480f8afb291450f2f" translate="yes" xml:space="preserve">
          <source>Opens the dialog and connects its finished(int) signal to the slot specified by</source>
          <target state="translated">대화 상자를 열고 완료된 (int) 신호를 지정된 슬롯에 연결합니다</target>
        </trans-unit>
        <trans-unit id="89766326de65daab04696f9fb139ae537eae1c59" translate="yes" xml:space="preserve">
          <source>Opens the dialog.</source>
          <target state="translated">대화 상자를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="67ef400fd2a69717900c44d971feabd3d725d45e" translate="yes" xml:space="preserve">
          <source>Opens the existing file descriptor</source>
          <target state="translated">기존 파일 디스크립터를 엽니 다</target>
        </trans-unit>
        <trans-unit id="16a4e1b316eb46680f1edf7ce57a80d698128d83" translate="yes" xml:space="preserve">
          <source>Opens the existing file handle</source>
          <target state="translated">기존 파일 핸들을 엽니 다</target>
        </trans-unit>
        <trans-unit id="2a08f5d5b170878c84f14e091d3943487ae05591" translate="yes" xml:space="preserve">
          <source>Opens the file using &lt;a href=&quot;qiodevice#OpenModeFlag-enum&quot;&gt;OpenMode&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qiodevice#OpenModeFlag-enum&quot;&gt;OpenMode를&lt;/a&gt; 사용하여 파일을 엽니 다</target>
        </trans-unit>
        <trans-unit id="d420ff55e8a83e6eed79c2b2ef08590cbe7d1205" translate="yes" xml:space="preserve">
          <source>Opens the file using &lt;a href=&quot;qiodevicebase#OpenModeFlag-enum&quot;&gt;OpenMode&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qiodevicebase#OpenModeFlag-enum&quot;&gt;OpenMode를&lt;/a&gt; 사용하여 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="63efd41d9c323e2c12100aa22e41c32f8cde6eb6" translate="yes" xml:space="preserve">
          <source>Opens the given</source>
          <target state="translated">주어진 것을 엽니 다</target>
        </trans-unit>
        <trans-unit id="22a64925ef8b97494a71be052ee1072f5fb42a32" translate="yes" xml:space="preserve">
          <source>Opens the menu at coordinates</source>
          <target state="translated">좌표에서 메뉴를 엽니 다</target>
        </trans-unit>
        <trans-unit id="69dc5484b8f2a3f2be653165ea58c934bd840d46" translate="yes" xml:space="preserve">
          <source>Opens the menu at the current mouse position, optionally aligned to a menu</source>
          <target state="translated">현재 마우스 위치에서 메뉴를 열고 선택적으로 메뉴에 정렬</target>
        </trans-unit>
        <trans-unit id="a694856e8cf13af519edad886da926187c569afd" translate="yes" xml:space="preserve">
          <source>Opens the menu at the mouse cursor on desktop platforms that have a mouse cursor available, and otherwise centers the menu over its</source>
          <target state="translated">마우스 커서를 사용할 수있는 데스크탑 플랫폼의 마우스 커서에서 메뉴를 열고 그렇지 않으면 메뉴를 가운데에 놓습니다</target>
        </trans-unit>
        <trans-unit id="14cff9bb66b1a801bec22fe0be811dac62cd71dc" translate="yes" xml:space="preserve">
          <source>Opens the menu at the specified</source>
          <target state="translated">지정된 메뉴를 엽니 다</target>
        </trans-unit>
        <trans-unit id="09fc43fee6bc84c6b48b3ce505fffba0b3331a53" translate="yes" xml:space="preserve">
          <source>Opens the menu at the specified position</source>
          <target state="translated">지정된 위치에서 메뉴를 엽니 다</target>
        </trans-unit>
        <trans-unit id="40d00c9ab6332dcd44bb4005fd7c97bc637fcfdf" translate="yes" xml:space="preserve">
          <source>Opens the popup.</source>
          <target state="translated">팝업을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="3a4b6723ac82e34929adc28d7d5512ab16745db9" translate="yes" xml:space="preserve">
          <source>Opens the requested page in the new web engine view</source>
          <target state="translated">새로운 웹 엔진보기에서 요청 된 페이지를 엽니 다</target>
        </trans-unit>
        <trans-unit id="42686bcc5be2bde4386f9b902dbe8cbb50a6a8fb" translate="yes" xml:space="preserve">
          <source>Opens the serial port using &lt;a href=&quot;qiodevice#OpenModeFlag-enum&quot;&gt;OpenMode&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qiodevice#OpenModeFlag-enum&quot;&gt;OpenMode를&lt;/a&gt; 사용하여 직렬 포트를 엽니 다</target>
        </trans-unit>
        <trans-unit id="7e8a05bde0eb1907e1abc5dcbb8a5b6b3e17208d" translate="yes" xml:space="preserve">
          <source>Opens this menu under the mouse cursor. It can block on some platforms, so test it accordingly.</source>
          <target state="translated">마우스 커서 아래에서이 메뉴를 엽니 다. 일부 플랫폼에서 차단 될 수 있으므로 적절하게 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="faff1ef71e5f887ec052282b1eee91b791fae18a" translate="yes" xml:space="preserve">
          <source>Operating Modes</source>
          <target state="translated">작동 모드</target>
        </trans-unit>
        <trans-unit id="e5ba86326755952233b0543acced2995e5faf457" translate="yes" xml:space="preserve">
          <source>Operating System</source>
          <target state="translated">운영 체제</target>
        </trans-unit>
        <trans-unit id="c77b69db3c3326eaa39cdeea3063e61d722af754" translate="yes" xml:space="preserve">
          <source>Operating System Support</source>
          <target state="translated">운영 체제 지원</target>
        </trans-unit>
        <trans-unit id="76966ea04d919598f6965c08ea4aee9e786b727f" translate="yes" xml:space="preserve">
          <source>Operating System setting</source>
          <target state="translated">운영 체제 설정</target>
        </trans-unit>
        <trans-unit id="5a35209b60ae46982b61db75f9984bec839cc172" translate="yes" xml:space="preserve">
          <source>Operating system</source>
          <target state="translated">운영 체제</target>
        </trans-unit>
        <trans-unit id="430d32076eb256f0fb1db5fd1333254c368ef1ba" translate="yes" xml:space="preserve">
          <source>Operation</source>
          <target state="translated">Operation</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="b3799b55b0f3fbdb9d84bcf9935ec60f823ce750" translate="yes" xml:space="preserve">
          <source>Operators for &lt;code&gt;xs:time&lt;/code&gt;, &lt;code&gt;xs:date&lt;/code&gt;, and &lt;code&gt;xs:dateTime&lt;/code&gt; are incomplete.</source>
          <target state="translated">&lt;code&gt;xs:time&lt;/code&gt; , &lt;code&gt;xs:date&lt;/code&gt; 및 &lt;code&gt;xs:dateTime&lt;/code&gt; 의 연산자 가 불완전합니다.</target>
        </trans-unit>
        <trans-unit id="d4309f080a0932c92321e84d13bd69df9bd3f95a" translate="yes" xml:space="preserve">
          <source>Operators for comparing</source>
          <target state="translated">비교 연산자</target>
        </trans-unit>
        <trans-unit id="216460a391f55802a71a8f2316d8fcf1d3002a72" translate="yes" xml:space="preserve">
          <source>Operators that compare</source>
          <target state="translated">비교하는 연산자</target>
        </trans-unit>
        <trans-unit id="e0f6c587ce8c3469fe1d8772236dfc104f2cb37e" translate="yes" xml:space="preserve">
          <source>Optimizations for Primitive and Relocatable Types</source>
          <target state="translated">프리미티브 및 재배치 가능 유형에 대한 최적화</target>
        </trans-unit>
        <trans-unit id="8522eecb5d22ab329fd8b1ec50e90d0c427921a2" translate="yes" xml:space="preserve">
          <source>Optimize Performance for Usage in Qt Containers</source>
          <target state="translated">Qt 컨테이너 사용을위한 성능 최적화</target>
        </trans-unit>
        <trans-unit id="9eec576f9bdb3dffa8a39d748e99a842ca11a7db" translate="yes" xml:space="preserve">
          <source>Optimize the usage of this matrix from its current elements.</source>
          <target state="translated">현재 요소에서이 매트릭스의 사용법을 최적화하십시오.</target>
        </trans-unit>
        <trans-unit id="50165a905b894fa8472cc61d5d4827c04f261812" translate="yes" xml:space="preserve">
          <source>Optimizes the rendering of static data sets at the expense of some features.</source>
          <target state="translated">일부 기능을 희생하여 정적 데이터 세트의 렌더링을 최적화합니다.</target>
        </trans-unit>
        <trans-unit id="8202dd483764bf9f543c7f059fba8a2598ab2b70" translate="yes" xml:space="preserve">
          <source>Optimizing 2D Assets</source>
          <target state="translated">2D 자산 최적화</target>
        </trans-unit>
        <trans-unit id="4567285538f7fe7e43b5047259433d826af9e4d3" translate="yes" xml:space="preserve">
          <source>Optimizing 3D Assets</source>
          <target state="translated">3D 자산 최적화</target>
        </trans-unit>
        <trans-unit id="c498c7592ea5e7bd2af38760045ea21dd4a4227f" translate="yes" xml:space="preserve">
          <source>Optimizing Assets</source>
          <target state="translated">자산 최적화</target>
        </trans-unit>
        <trans-unit id="ea56291c352c86319de4c21488b92c976f845475" translate="yes" xml:space="preserve">
          <source>Optimizing the images in your presentation can substantially improve both the startup and runtime performance of your application, as well as the visual quality in certain situations.</source>
          <target state="translated">프레젠테이션의 이미지를 최적화하면 응용 프로그램의 시작 및 런타임 성능은 물론 특정 상황에서 시각적 품질을 크게 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68edef17939954017f30770995583fce320f6e52" translate="yes" xml:space="preserve">
          <source>Optimizing the images used by Texture components in your scene can substantially improve both the startup and runtime performance of your application, as well as the visual quality in certain situations.</source>
          <target state="translated">장면의 텍스처 구성 요소에서 사용하는 이미지를 최적화하면 응용 프로그램의 시작 및 런타임 성능은 물론 특정 상황에서 시각적 품질을 크게 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0753cba3300b2133987bb17a468e7c6b0d34882e" translate="yes" xml:space="preserve">
          <source>Opting out of macOS behavior changes</source>
          <target state="translated">macOS 동작 변경 해제</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="08dbe38fab43c0583b2caa4db37287565d9a4b3c" translate="yes" xml:space="preserve">
          <source>Optional Pointer Tracking</source>
          <target state="translated">선택적 포인터 추적</target>
        </trans-unit>
        <trans-unit id="98076d862dd624bf1c0f8fe18757336471b2fade" translate="yes" xml:space="preserve">
          <source>Optional hint that allows the map to prefetch during this idle period</source>
          <target state="translated">이 유휴 기간 동안 맵을 프리 페치 할 수있는 선택적 힌트</target>
        </trans-unit>
        <trans-unit id="e1ace5043f2c85648ab0ee006654614fd0fdb4d3" translate="yes" xml:space="preserve">
          <source>Optional map parameters</source>
          <target state="translated">선택적지도 매개 변수</target>
        </trans-unit>
        <trans-unit id="ecb266b541e4b08a278d9159821a983ea3b5932f" translate="yes" xml:space="preserve">
          <source>Optional parameters</source>
          <target state="translated">선택적 매개 변수</target>
        </trans-unit>
        <trans-unit id="514a810de5c58b7a254827bb86cbc50f256b24d9" translate="yes" xml:space="preserve">
          <source>Optional plugin parameters</source>
          <target state="translated">선택적 플러그인 매개 변수</target>
        </trans-unit>
        <trans-unit id="0d39eefacb892a70286489d339f7d47deb0c13bf" translate="yes" xml:space="preserve">
          <source>Optionally define the minimum allowed margins</source>
          <target state="translated">선택적으로 최소 허용 마진을 정의하십시오</target>
        </trans-unit>
        <trans-unit id="53ae7125c6db724741ce5a863475c4df8a499392" translate="yes" xml:space="preserve">
          <source>Optionally set any additional properties e.g. filtering and border options</source>
          <target state="translated">필터링 및 테두리 옵션과 같은 추가 속성을 선택적으로 설정</target>
        </trans-unit>
        <trans-unit id="262051e06de4a07c090c7f18d30995101052fce9" translate="yes" xml:space="preserve">
          <source>Optionally upload pixel data</source>
          <target state="translated">선택적으로 픽셀 데이터를 업로드</target>
        </trans-unit>
        <trans-unit id="7b659a77b8821ebf7d9770a1bff0773979d248ff" translate="yes" xml:space="preserve">
          <source>Optionally, create the &lt;a href=&quot;qtremoteobjects-registry#registry&quot;&gt;Registry&lt;/a&gt;. Otherwise, use direct connections.</source>
          <target state="translated">선택적으로 &lt;a href=&quot;qtremoteobjects-registry#registry&quot;&gt;레지스트리를&lt;/a&gt; 만듭니다 . 그렇지 않으면 직접 연결을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="246b964c19557d08174a03f48e6a1e70dea562d5" translate="yes" xml:space="preserve">
          <source>Optionally, the command line arguments</source>
          <target state="translated">선택적으로 명령 행 인수</target>
        </trans-unit>
        <trans-unit id="139a84a36d0000a0ce3f1c84617b159b4912eae4" translate="yes" xml:space="preserve">
          <source>Optionally, use &lt;a href=&quot;qtremoteobjects-repc&quot;&gt;repc&lt;/a&gt; to generate a &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; header for your project.</source>
          <target state="translated">선택적으로 &lt;a href=&quot;qtremoteobjects-repc&quot;&gt;repc&lt;/a&gt; 를 사용 하여 프로젝트 의 &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;복제본&lt;/a&gt; 헤더 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="58eba5d2129b46bbd89134b37b2b597b198ed739" translate="yes" xml:space="preserve">
          <source>Optionally, you can set &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#y-prop&quot;&gt;y&lt;/a&gt; to change the needle's transform origin. Setting the &lt;code&gt;x&lt;/code&gt; position can be useful for needle images where the needle is not centered exactly horizontally. Setting the &lt;code&gt;y&lt;/code&gt; position allows you to make the base of the needle hang over the center of the gauge.</source>
          <target state="translated">선택적으로 &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; 와 &lt;a href=&quot;qml-qtquick-item#y-prop&quot;&gt;y&lt;/a&gt; 를 설정 하여 바늘의 변형 원점을 변경할 수 있습니다 . &lt;code&gt;x&lt;/code&gt; 위치를 설정하면 바늘이 수평으로 정확하게 가운데에 있지 않은 바늘 이미지에 유용 할 수 있습니다. &lt;code&gt;y&lt;/code&gt; 위치를 설정하면 바늘의베이스를 게이지 중앙에 걸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e25a4fd58f6052105b519f94dfab01531b0dc3d9" translate="yes" xml:space="preserve">
          <source>Optionally, you can specify</source>
          <target state="translated">선택적으로 다음을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="dcb2ae1a154944a1feaed3a82155638d5b7b721b" translate="yes" xml:space="preserve">
          <source>Options (particularly the DontUseNativeDialogs option) should be set before changing dialog properties or showing the dialog.</source>
          <target state="translated">대화 상자 속성을 변경하거나 대화 상자를 표시하기 전에 옵션 (특히 DontUseNativeDialogs 옵션)을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4cbb6af8a461d8ff4929ea249ec8047f7e2046b1" translate="yes" xml:space="preserve">
          <source>Options can be set using &lt;code&gt;set_source_file_property&lt;/code&gt; on each of the file arguments:</source>
          <target state="translated">각 파일 인수에서 &lt;code&gt;set_source_file_property&lt;/code&gt; 를 사용하여 옵션을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20850651b5368e589825bbead80e1b5e0c2e19fc" translate="yes" xml:space="preserve">
          <source>Options can be set using &lt;code&gt;set_source_file_property&lt;/code&gt; on the &lt;code&gt;dbus_spec&lt;/code&gt;:</source>
          <target state="translated">옵션을 사용하여 설정할 수 있습니다 &lt;code&gt;set_source_file_property&lt;/code&gt; 온 &lt;code&gt;dbus_spec&lt;/code&gt; 를 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
