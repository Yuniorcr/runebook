<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="8da27e376350611d95285d11a6f675949b019ca7" translate="yes" xml:space="preserve">
          <source>It is also possible to filter out certain types of node by passing certain &lt;a href=&quot;qtreewidgetitemiterator#IteratorFlag-enum&quot;&gt;flags&lt;/a&gt; to the constructor of &lt;a href=&quot;qtreewidgetitemiterator&quot;&gt;QTreeWidgetItemIterator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qtreewidgetitemiterator&quot;&gt;QTreeWidgetItemIterator&lt;/a&gt; 의 생성자에 특정 &lt;a href=&quot;qtreewidgetitemiterator#IteratorFlag-enum&quot;&gt;플래그&lt;/a&gt; 를 전달하여 특정 유형의 노드를 필터링 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b87e13aec474787050e0d33d1144b87663358e2e" translate="yes" xml:space="preserve">
          <source>It is also possible to filter out certain types of node by passing certain &lt;a href=&quot;qtreewidgetitemiterator#IteratorFlag-enum&quot;&gt;flags&lt;/a&gt; to the constructor of QTreeWidgetItemIterator.</source>
          <target state="translated">특정 &lt;a href=&quot;qtreewidgetitemiterator#IteratorFlag-enum&quot;&gt;플래그&lt;/a&gt; 를 QTreeWidgetItemIterator의 생성자 에 전달하여 특정 유형의 노드를 필터링 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a9cd6da091425f9c298c19e22f1b534444b3edf" translate="yes" xml:space="preserve">
          <source>It is also possible to get a shared pointer from an object outside of the class itself. This is especially useful in code that provides an interface to scripts, where it is currently not possible to use shared pointers. For example:</source>
          <target state="translated">클래스 외부의 객체에서 공유 포인터를 얻는 것도 가능합니다. 이것은 스크립트에 대한 인터페이스를 제공하는 코드에서 특히 유용하며, 현재 공유 포인터를 사용할 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c22c2d95f1becf636e9f75f0652c72ad6f10b783" translate="yes" xml:space="preserve">
          <source>It is also possible to have QML singleton types registered without using the &lt;a href=&quot;qqmlengine#qmlRegisterSingletonType&quot;&gt;qmlRegisterSingletonType&lt;/a&gt; function. That can be done by adding a pragma Singleton statement among the imports of the type's QML file. In addition the type must be defined in a qmldir file with a singleton keyword and the qmldir must be imported by the QML files using the singleton.</source>
          <target state="translated">&lt;a href=&quot;qqmlengine#qmlRegisterSingletonType&quot;&gt;qmlRegisterSingletonType&lt;/a&gt; 함수 를 사용하지 않고 QML 싱글 톤 유형을 등록 할 수도 있습니다. 형식의 QML 파일을 가져 오는 중에 pragma Singleton 문을 추가하면됩니다. 또한 단일 유형 키워드를 사용하여 qmldir 파일에 유형을 정의해야하며 단일 유형을 사용하여 QML 파일에서 qmldir을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="b7ecc1d1aa9c93a3ecc2108eb6d4372535567c13" translate="yes" xml:space="preserve">
          <source>It is also possible to have QML singleton types registered without using the qmlRegisterSingletonType function. That can be done by adding a pragma Singleton statement among the imports of the type's QML file. In addition the type must be defined in a qmldir file with a singleton keyword and the qmldir must be imported by the QML files using the singleton.</source>
          <target state="translated">qmlRegisterSingletonType 함수를 사용하지 않고 QML 싱글 톤 유형을 등록 할 수도 있습니다. 이는 유형의 QML 파일 가져 오기 사이에 pragma Singleton 문을 추가하여 수행 할 수 있습니다. 또한 유형은 싱글 톤 키워드를 사용하여 qmldir 파일에 정의되어야하며 qmldir은 싱글 톤을 사용하는 QML 파일에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="a2431e2de322561aaeda2e9041d6f8bfcc2bc519" translate="yes" xml:space="preserve">
          <source>It is also possible to initialize the object from a file, e.g.</source>
          <target state="translated">예를 들어 파일에서 객체를 초기화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="53ba905de9a0210b2bd577c0b528cab818142a66" translate="yes" xml:space="preserve">
          <source>It is also possible to instantiate components without blocking via the &lt;a href=&quot;qml-qtqml-component#incubateObject-method&quot;&gt;incubateObject()&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;qml-qtqml-component#incubateObject-method&quot;&gt;incubateObject ()&lt;/a&gt; 함수 를 통해 차단하지 않고 구성 요소를 인스턴스화 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97666956bf09a62e9c16aac8198a6e45fb3e3d9e" translate="yes" xml:space="preserve">
          <source>It is also possible to manually enable dependencies on Qt libraries by opening the &lt;b&gt;Run&lt;/b&gt; settings of your project, expanding &lt;b&gt;Package configurations&lt;/b&gt; and selecting the &lt;b&gt;Libraries&lt;/b&gt; tab. Manually check the libraries that are dependencies of your project.</source>
          <target state="translated">프로젝트 의 &lt;b&gt;실행&lt;/b&gt; 설정을 열고 &lt;b&gt;패키지 구성을&lt;/b&gt; 확장 하고 &lt;b&gt;라이브러리&lt;/b&gt; 탭을 선택하여 Qt 라이브러리에 대한 종속성을 수동으로 활성화 할 수도 있습니다 . 프로젝트의 종속성 인 라이브러리를 수동으로 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="636c707658d7a99b8a61c10e5c0176e751cf341a" translate="yes" xml:space="preserve">
          <source>It is also possible to misuse &lt;a href=&quot;qcborstreamwriter&quot;&gt;QCborStreamWriter&lt;/a&gt; and produce invalid CBOR streams that will fail to be decoded by a receiver. The following actions will produce invalid streams:</source>
          <target state="translated">&lt;a href=&quot;qcborstreamwriter&quot;&gt;QCborStreamWriter&lt;/a&gt; 를 잘못 사용 하고 수신자가 디코딩하지 못하는 유효하지 않은 CBOR 스트림을 생성 할 수도 있습니다. 다음 조치는 유효하지 않은 스트림을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0c69b384ae6c6b15e434fd0c9119947694c1f528" translate="yes" xml:space="preserve">
          <source>It is also possible to misuse QCborStreamWriter and produce invalid CBOR streams that will fail to be decoded by a receiver. The following actions will produce invalid streams:</source>
          <target state="translated">또한 QCborStreamWriter를 오용하여 수신자가 디코딩하지 못하는 잘못된 CBOR 스트림을 생성 할 수도 있습니다. 다음 작업은 잘못된 스트림을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="60c0bfb7deac43c8e29508d5238355ee0fb73c9c" translate="yes" xml:space="preserve">
          <source>It is also possible to modify the model's data via the delegate, as shown in the example above:</source>
          <target state="translated">위의 예와 같이 대리자를 통해 모델의 데이터를 수정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9e05499ebbd0e58be0348798001c333ad3452f2" translate="yes" xml:space="preserve">
          <source>It is also possible to override the antialiasing method used by setting the environment variable &lt;code&gt;QSG_ANTIALIASING_METHOD&lt;/code&gt; to either &lt;code&gt;vertex&lt;/code&gt; or &lt;code&gt;msaa&lt;/code&gt;.</source>
          <target state="translated">환경 변수 &lt;code&gt;QSG_ANTIALIASING_METHOD&lt;/code&gt; 를 &lt;code&gt;vertex&lt;/code&gt; 또는 &lt;code&gt;msaa&lt;/code&gt; 로 설정하여 사용되는 앤티 앨리어싱 방법을 재정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a6dc3e2e2acfd6c9cd819b5f38aad533a9fa384" translate="yes" xml:space="preserve">
          <source>It is also possible to perform dynamic casts using &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt;() on &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; classes. The &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt;() function behaves similarly to the standard C++ &lt;code&gt;dynamic_cast()&lt;/code&gt;, with the advantages that it doesn't require RTTI support and it works across dynamic library boundaries. It attempts to cast its argument to the pointer type specified in angle-brackets, returning a non-zero pointer if the object is of the correct type (determined at run-time), or &lt;code&gt;nullptr&lt;/code&gt; if the object's type is incompatible.</source>
          <target state="translated">&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 클래스 에서 &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt; ()를 사용하여 동적 캐스트를 수행 할 수도 있습니다 . &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt; 유사 표준 C ++ () 함수의 동작합니다 &lt;code&gt;dynamic_cast()&lt;/code&gt; 장점과 함께, 그것은 RTTI 지원이 필요하지 않습니다 그것은 동적 라이브러리의 경계를 넘어 작동합니다. 객체가 올바른 유형 (런타임으로 결정됨) 인 경우 0이 아닌 포인터를 반환하거나 객체 유형이 호환되지 않는 경우 &lt;code&gt;nullptr&lt;/code&gt; 을 반환하여 꺾쇠 괄호로 지정된 포인터 유형으로 인수를 캐스팅하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="bdb68f03a0442be419ce189e77451068fb01e681" translate="yes" xml:space="preserve">
          <source>It is also possible to receive a stream of debug messages from the OpenGL server</source>
          <target state="translated">OpenGL 서버에서 디버그 메시지 스트림을 수신 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e675e3d704952fccda2f9adfe47442a17da6d0b5" translate="yes" xml:space="preserve">
          <source>It is also possible to reference an existing scene by using the &lt;a href=&quot;qml-qtquick3d-view3d#importScene-prop&quot;&gt;importScene&lt;/a&gt; property of the scene you want to render. This scene does not have to exist as a child of the current View3D.</source>
          <target state="translated">렌더링하려는 장면 의 &lt;a href=&quot;qml-qtquick3d-view3d#importScene-prop&quot;&gt;importScene&lt;/a&gt; 속성을 사용하여 기존 장면을 참조 할 수도 있습니다 . 이 장면은 현재 View3D의 자식으로 존재할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2889cb70240788ffb44204acb38a9a94697971df" translate="yes" xml:space="preserve">
          <source>It is also possible to run a single file using the &lt;code&gt;-input&lt;/code&gt; option. For example:</source>
          <target state="translated">&lt;code&gt;-input&lt;/code&gt; 옵션을 사용하여 단일 파일을 실행할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db33c652c1a5643d022e7bff49e6246a7d979b19" translate="yes" xml:space="preserve">
          <source>It is also possible to set certain default properties by modifying the &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; before it is supplied to the print dialog. For example, applications that generate batches of reports for printing may set up the &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; to &lt;a href=&quot;qprinter#setOutputFileName&quot;&gt;write to a local file&lt;/a&gt; by default rather than to a printer.</source>
          <target state="translated">인쇄 대화 상자에 제공되기 전에 &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; 를 수정하여 특정 기본 속성을 설정할 수도 있습니다 . 예를 들어, 인쇄용 일괄 보고서를 생성하는 응용 프로그램은 기본적으로 프린터가 아닌 &lt;a href=&quot;qprinter#setOutputFileName&quot;&gt;로컬 파일&lt;/a&gt; 에 쓰도록 &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; 를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f60135b7b5eeb67132a2bbf1d8a21f6895fed4e" translate="yes" xml:space="preserve">
          <source>It is also possible to set multiple shortcut &lt;a href=&quot;qml-qtquick-shortcut#sequences-prop&quot;&gt;sequences&lt;/a&gt;, so that the shortcut can be &lt;a href=&quot;qml-qtquick-shortcut#activated-signal&quot;&gt;activated&lt;/a&gt; via several different sequences of key presses.</source>
          <target state="translated">또한 일련의 복수 단축 할 수있다 &lt;a href=&quot;qml-qtquick-shortcut#sequences-prop&quot;&gt;서열&lt;/a&gt; 단축을 할 수 있도록하는 것이, &lt;a href=&quot;qml-qtquick-shortcut#activated-signal&quot;&gt;활성화 된&lt;/a&gt; 키 누름의 시퀀스를 통해 여러.</target>
        </trans-unit>
        <trans-unit id="8526893572d2213609eb7b181c1f941c538f5115" translate="yes" xml:space="preserve">
          <source>It is also possible to set values at specified steps situated between the start and end value. The interpolation will then touch these points at the specified steps. Note that the start and end values are defined as the key values at 0.0 and 1.0.</source>
          <target state="translated">시작 값과 끝 값 사이에 위치한 지정된 단계에서 값을 설정할 수도 있습니다. 그러면 보간은 지정된 단계에서이 점들을 터치합니다. 시작 및 종료 값은 0.0 및 1.0의 키 값으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="58907f11a7ee5b997bf4379e8c4c134194cc383a" translate="yes" xml:space="preserve">
          <source>It is also possible to show different help texts for different regions of a widget, by using a &lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::WhatsThis&lt;/a&gt;. Intercept the help event in your widget's &lt;a href=&quot;qwidget#event&quot;&gt;QWidget::event&lt;/a&gt;() function and call &lt;a href=&quot;qwhatsthis#showText&quot;&gt;QWhatsThis::showText&lt;/a&gt;() with the text you want to display for the position specified in &lt;a href=&quot;qhelpevent#pos&quot;&gt;QHelpEvent::pos&lt;/a&gt;(). If the text is rich text and the user clicks on a link, the widget also receives a &lt;a href=&quot;qwhatsthisclickedevent&quot;&gt;QWhatsThisClickedEvent&lt;/a&gt; with the link's reference as &lt;a href=&quot;qwhatsthisclickedevent#href&quot;&gt;QWhatsThisClickedEvent::href&lt;/a&gt;(). If a &lt;a href=&quot;qwhatsthisclickedevent&quot;&gt;QWhatsThisClickedEvent&lt;/a&gt; is handled (i.e. &lt;a href=&quot;qwidget#event&quot;&gt;QWidget::event&lt;/a&gt;() returns true), the help window remains visible. Call &lt;a href=&quot;qwhatsthis#hideText&quot;&gt;QWhatsThis::hideText&lt;/a&gt;() to hide it explicitly.</source>
          <target state="translated">사용하여 위젯의 다른 지역에 대한 다른 도움말 텍스트를 표시 할 수도 있습니다 &lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt; 형의 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: WhatsThis을&lt;/a&gt; . 위젯의 &lt;a href=&quot;qwidget#event&quot;&gt;QWidget :: event&lt;/a&gt; () 함수 에서 도움말 이벤트를 가로 &lt;a href=&quot;qhelpevent#pos&quot;&gt;채고 QHelpEvent :: pos&lt;/a&gt; ()에 지정된 위치에 표시하려는 텍스트로 &lt;a href=&quot;qwhatsthis#showText&quot;&gt;QWhatsThis :: showText&lt;/a&gt; ()를 호출 하십시오 . 텍스트가 서식있는 텍스트와 링크를 사용자가 클릭하면 위젯도 수신 &lt;a href=&quot;qwhatsthisclickedevent&quot;&gt;QWhatsThisClickedEvent&lt;/a&gt; 로 링크의 참조 &lt;a href=&quot;qwhatsthisclickedevent#href&quot;&gt;QWhatsThisClickedEvent :: HREF를&lt;/a&gt; (). 경우 &lt;a href=&quot;qwhatsthisclickedevent&quot;&gt;QWhatsThisClickedEvent가&lt;/a&gt; (즉, 처리 &lt;a href=&quot;qwidget#event&quot;&gt;는 QWidget :: 이벤트를&lt;/a&gt; ()가 true를 돌려), 도움말 창이 계속 표시됩니다. 요구&lt;a href=&quot;qwhatsthis#hideText&quot;&gt;QWhatsThis :: hideText&lt;/a&gt; ()를 명시 적으로 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="9244191674a5b2c04ef44b034401cddef7f9141a" translate="yes" xml:space="preserve">
          <source>It is also possible to show different tool tips for different regions of a widget, by using a &lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;. Intercept the help event in your widget's &lt;a href=&quot;qwidget#event&quot;&gt;event()&lt;/a&gt; function and call &lt;a href=&quot;qtooltip#showText&quot;&gt;QToolTip::showText&lt;/a&gt;() with the text you want to display. The &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwidgets-widgets-tooltips-example.html#&quot;&gt;Tooltips&lt;/a&gt; example illustrates this technique.</source>
          <target state="translated">사용하여 위젯의 다른 지역에 대해 서로 다른 도구 팁을 표시 할 수도 있습니다 &lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt; 형의 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: 도구 설명을&lt;/a&gt; . 위젯의 &lt;a href=&quot;qwidget#event&quot;&gt;event ()&lt;/a&gt; 함수 에서 도움말 이벤트를 가로 &lt;a href=&quot;qtooltip#showText&quot;&gt;채고&lt;/a&gt; 표시하려는 텍스트로 QToolTip :: showText ()를 호출 하십시오 . &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwidgets-widgets-tooltips-example.html#&quot;&gt;툴팁&lt;/a&gt; 예는이 기술을 도시한다.</target>
        </trans-unit>
        <trans-unit id="08ce8ea1016fd5a72776dd0280d552e93ad757fa" translate="yes" xml:space="preserve">
          <source>It is also possible to show different tool tips for different regions of a widget, by using a &lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;. Intercept the help event in your widget's &lt;a href=&quot;qwidget#event&quot;&gt;event()&lt;/a&gt; function and call &lt;a href=&quot;qtooltip#showText&quot;&gt;QToolTip::showText&lt;/a&gt;() with the text you want to display. The &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwidgets-widgets-tooltips-example.html&quot;&gt;Tooltips&lt;/a&gt; example illustrates this technique.</source>
          <target state="translated">사용하여 위젯의 다른 지역에 대해 서로 다른 도구 팁을 표시 할 수도 있습니다 &lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt; 형의 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: 도구 설명을&lt;/a&gt; . 위젯의 &lt;a href=&quot;qwidget#event&quot;&gt;event ()&lt;/a&gt; 함수 에서 도움말 이벤트를 가로 &lt;a href=&quot;qtooltip#showText&quot;&gt;채고&lt;/a&gt; 표시 할 텍스트로 QToolTip :: showText ()를 호출 합니다. &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtwidgets-widgets-tooltips-example.html&quot;&gt;툴팁&lt;/a&gt; 예는이 기술을 도시한다.</target>
        </trans-unit>
        <trans-unit id="3ec11205dbe1a818a163c2297989fa3a069aca61" translate="yes" xml:space="preserve">
          <source>It is also possible to specify a member function directly, as in:</source>
          <target state="translated">다음과 같이 멤버 함수를 직접 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ec061b403c31a1522bc910e5dfaf840bf338b30" translate="yes" xml:space="preserve">
          <source>It is also possible to specify start and end in a single argument, with the numbers separated by two periods.</source>
          <target state="translated">숫자를 두 개의 마침표로 구분하여 단일 인수로 시작과 끝을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb12509294d47da34a51229bbe48ad84ad549e07" translate="yes" xml:space="preserve">
          <source>It is also possible to use &lt;a href=&quot;qabstractitemmodeltester&quot;&gt;QAbstractItemModelTester&lt;/a&gt; outside of a test case. For instance, it may be useful to test an item model used by an application without the need of building an explicit unit test for such a model (which might be challenging). In order to use &lt;a href=&quot;qabstractitemmodeltester&quot;&gt;QAbstractItemModelTester&lt;/a&gt; outside of a test case, pass one of the &lt;code&gt;QAbstractItemModelTester::FailureReportingMode&lt;/code&gt; enumerators to its constructor, therefore specifying how failures should be logged.</source>
          <target state="translated">테스트 케이스 외부에서 &lt;a href=&quot;qabstractitemmodeltester&quot;&gt;QAbstractItemModelTester&lt;/a&gt; 를 사용할 수도 있습니다 . 예를 들어, 이러한 모델에 대해 명시 적 단위 테스트를 구축 할 필요없이 애플리케이션에서 사용하는 항목 모델을 테스트하는 것이 유용 할 수 있습니다 (어려울 수 있음). 테스트 케이스 외부에서 &lt;a href=&quot;qabstractitemmodeltester&quot;&gt;QAbstractItemModelTester&lt;/a&gt; 를 사용 하려면 &lt;code&gt;QAbstractItemModelTester::FailureReportingMode&lt;/code&gt; 열거 자 중 하나를 생성자에 전달하여 실패를 기록하는 방법을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="644e2f21be422cbbf57e77faa182b8490616af02" translate="yes" xml:space="preserve">
          <source>It is also possible to use &lt;code&gt;threshold&lt;/code&gt;, &lt;code&gt;compress&lt;/code&gt;, and &lt;code&gt;compress-algo&lt;/code&gt; as attributes in a .qrc &lt;code&gt;file&lt;/code&gt; tag.</source>
          <target state="translated">.qrc &lt;code&gt;file&lt;/code&gt; 태그의 속성으로 &lt;code&gt;threshold&lt;/code&gt; , &lt;code&gt;compress&lt;/code&gt; 및 &lt;code&gt;compress-algo&lt;/code&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69db22c462e4ce0290c759dbaf4418e5b30a3657" translate="yes" xml:space="preserve">
          <source>It is also possible to use QAbstractItemModelTester outside of a test case. For instance, it may be useful to test an item model used by an application without the need of building an explicit unit test for such a model (which might be challenging). In order to use QAbstractItemModelTester outside of a test case, pass one of the &lt;code&gt;QAbstractItemModelTester::FailureReportingMode&lt;/code&gt; enumerators to its constructor, therefore specifying how failures should be logged.</source>
          <target state="translated">테스트 케이스 외부에서 QAbstractItemModelTester를 사용할 수도 있습니다. 예를 들어, 그러한 모델에 대한 명시적인 단위 테스트를 구축 할 필요없이 애플리케이션에서 사용하는 항목 모델을 테스트하는 것이 유용 할 수 있습니다 (어려울 수 있음). 테스트 케이스 외부에서 QAbstractItemModelTester를 사용하려면 &lt;code&gt;QAbstractItemModelTester::FailureReportingMode&lt;/code&gt; 열거 자 중 하나를 생성자에 전달하여 실패를 기록하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4b32458ed1959b27d9c08f30ba65b748c3cf361d" translate="yes" xml:space="preserve">
          <source>It is also possible to use a delegate as the template for the items created by a Repeater. This is specified using the &lt;a href=&quot;qml-qtquick-repeater#delegate-prop&quot;&gt;delegate&lt;/a&gt; property.</source>
          <target state="translated">또한 Repeater가 만든 항목의 템플릿으로 대리자를 사용할 수도 있습니다. 이것은 &lt;a href=&quot;qml-qtquick-repeater#delegate-prop&quot;&gt;delegate&lt;/a&gt; 속성을 사용하여 지정 됩니다.</target>
        </trans-unit>
        <trans-unit id="53e56b30a39183fbc13875a195f9cd389ac70fd4" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the &lt;a href=&quot;qml-qtquick-opacityanimator&quot;&gt;OpacityAnimator&lt;/a&gt; directly to an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용 하여 &lt;a href=&quot;qml-qtquick-opacityanimator&quot;&gt;OpacityAnimator&lt;/a&gt; 를 Item 인스턴스에 직접 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a19848eb55088cd32ed0468f7142a5d0d05a0a1" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the &lt;a href=&quot;qml-qtquick-rotationanimator&quot;&gt;RotationAnimator&lt;/a&gt; directly to the &lt;code&gt;rotation&lt;/code&gt; property of an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용하여 &lt;a href=&quot;qml-qtquick-rotationanimator&quot;&gt;RotationAnimator&lt;/a&gt; 를 Item 인스턴스 의 &lt;code&gt;rotation&lt;/code&gt; 속성에 직접 연결할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bdce0f3a3e277a98d60e74ce915b72408445641e" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the &lt;a href=&quot;qml-qtquick-scaleanimator&quot;&gt;ScaleAnimator&lt;/a&gt; directly to an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용 하여 &lt;a href=&quot;qml-qtquick-scaleanimator&quot;&gt;ScaleAnimator&lt;/a&gt; 를 Item 인스턴스에 직접 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c80ec327ff85447ee100d1bb71fa6dd3b2df115" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the &lt;a href=&quot;qml-qtquick-uniformanimator&quot;&gt;UniformAnimator&lt;/a&gt; directly to a uniform of a &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt; instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용하여 &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;UniformAnimator를 ShaderEffect&lt;/a&gt; 인스턴스 의 유니폼에 직접 &lt;a href=&quot;qml-qtquick-uniformanimator&quot;&gt;연결할&lt;/a&gt; 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e01460823de575901dc6f64cd863058b7be3562" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the &lt;a href=&quot;qml-qtquick-xanimator&quot;&gt;XAnimator&lt;/a&gt; directly to an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용 하여 &lt;a href=&quot;qml-qtquick-xanimator&quot;&gt;XAnimator&lt;/a&gt; 를 Item 인스턴스에 직접 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7daa6d7f3766cd43a117a7e6e32addc079bcba4" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the &lt;a href=&quot;qml-qtquick-yanimator&quot;&gt;YAnimator&lt;/a&gt; directly to an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용 하여 &lt;a href=&quot;qml-qtquick-yanimator&quot;&gt;YAnimator&lt;/a&gt; 를 Item 인스턴스에 직접 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c5e7e541cdf0f443d70dc0d3829b04c5acba3ee" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the OpacityAnimator directly to an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용 하여 OpacityAnimator를 Item 인스턴스에 직접 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="73be3d5520cc086b4db97c4b154d00a8822b177c" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the RotationAnimator directly to the &lt;code&gt;rotation&lt;/code&gt; property of an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용하여 RotationAnimator를 Item 인스턴스 의 &lt;code&gt;rotation&lt;/code&gt; 속성에 직접 연결할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfc80adae4ba4c754467dde48af5e7a725df58f9" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the ScaleAnimator directly to an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용 하여 ScaleAnimator를 Item 인스턴스에 직접 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dc943d09e3b1215f57ac2f09f472c2396f248b1" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the UniformAnimator directly to a uniform of a &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt; instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용하여 &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;UniformAnimator를 ShaderEffect&lt;/a&gt; 인스턴스 의 유니폼에 직접 연결할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3475ff2ddf138580fb349534fad2d34d667c64c0" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the XAnimator directly to an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용 하여 XAnimator를 Item 인스턴스에 직접 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4442deaba3438771a666397591fdf6e02649589" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;code&gt;on&lt;/code&gt; keyword to tie the YAnimator directly to an Item instance.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 키워드 를 사용 하여 YAnimator를 Item 인스턴스에 직접 연결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ac9d329eba8527f87838828d0a8dc9a7cdde5e7" translate="yes" xml:space="preserve">
          <source>It is also possible to write custom material without using the boilerplate code, in which case the main function must be implemented in the shader.</source>
          <target state="translated">상용구 코드를 사용하지 않고 커스텀 머티리얼을 작성할 수도 있습니다.이 경우 메인 함수는 셰이더에서 구현되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c5694751cea43b041f8e2a663660048fd0d27b61" translate="yes" xml:space="preserve">
          <source>It is also possible to write the custom material without the rest of the material system. In this case it is not necessary to write all the functions described above. Each pass needs a main function only.</source>
          <target state="translated">나머지 머티리얼 시스템없이 커스텀 머티리얼을 작성하는 것도 가능합니다. 이 경우 위에서 설명한 모든 함수를 작성할 필요는 없습니다. 각 패스에는 주 기능 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="70881c0db00dee2420383c49a6ca254a0f5476a4" translate="yes" xml:space="preserve">
          <source>It is also usual to use &lt;code&gt;PE_IndicatorCheckBox&lt;/code&gt; (instead of using &lt;code&gt;PE_IndicatorMenuCheckMark&lt;/code&gt;) and &lt;code&gt;PE_IndicatorRadioButton&lt;/code&gt; for drawing checkable menu items; we have not included them in the style tree as this is optional and varies from style to style.</source>
          <target state="translated">또한 사용하는 것이 일반적이다 &lt;code&gt;PE_IndicatorCheckBox&lt;/code&gt; (대신 사용하는 &lt;code&gt;PE_IndicatorMenuCheckMark&lt;/code&gt; 과) &lt;code&gt;PE_IndicatorRadioButton&lt;/code&gt; 을 체크 할 메뉴 항목을 그리기 위해; 선택 사항이며 스타일에 따라 스타일 트리에 포함하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="df5157cc775b9e7ee0e83e062447bc9ee2a95697" translate="yes" xml:space="preserve">
          <source>It is always best to cast integers to a Qt integer type, such as &lt;a href=&quot;qtglobal#qint16-typedef&quot;&gt;qint16&lt;/a&gt; or &lt;a href=&quot;qtglobal#quint32-typedef&quot;&gt;quint32&lt;/a&gt;, when reading and writing. This ensures that you always know exactly what size integers you are reading and writing, no matter what the underlying platform and architecture the application happens to be running on.</source>
          <target state="translated">읽고 쓸 때 항상 정수를 &lt;a href=&quot;qtglobal#qint16-typedef&quot;&gt;qint16&lt;/a&gt; 또는 &lt;a href=&quot;qtglobal#quint32-typedef&quot;&gt;quint32&lt;/a&gt; 와 같은 Qt 정수 유형으로 캐스트하는 것이 가장 좋습니다 . 이를 통해 응용 프로그램이 실행되는 기본 플랫폼 및 아키텍처에 관계없이 읽고 쓰는 크기의 정수를 항상 정확하게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10ae19d77ab28328d9e4f5073dc624a0bf2e5900" translate="yes" xml:space="preserve">
          <source>It is always safe to remove an event filter, even during event filter activation (i.e. from the &lt;a href=&quot;qobject#eventFilter&quot;&gt;eventFilter&lt;/a&gt;() function).</source>
          <target state="translated">이벤트 필터 활성화 중에도 (예 : &lt;a href=&quot;qobject#eventFilter&quot;&gt;eventFilter&lt;/a&gt; () 함수에서) 이벤트 필터를 제거하는 것이 항상 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="6bf2d74636c6daefde70cc25c6232998bb8b4e25" translate="yes" xml:space="preserve">
          <source>It is always safe to remove an event filter, even during event filter activation (i.e. from the nativeEventFilter() function).</source>
          <target state="translated">이벤트 필터 활성화 중에도 (예 : nativeEventFilter () 함수에서) 이벤트 필터를 제거하는 것이 항상 안전합니다.</target>
        </trans-unit>
        <trans-unit id="56aa8a6e88ada08148ea931a197072313c54af7d" translate="yes" xml:space="preserve">
          <source>It is always safe to remove an event filter, even during event filter filter activation (that is, even from within the &lt;a href=&quot;qabstractnativeeventfilter#nativeEventFilter&quot;&gt;nativeEventFilter()&lt;/a&gt; function).</source>
          <target state="translated">이벤트 필터 필터 활성화 중에 (즉, &lt;a href=&quot;qabstractnativeeventfilter#nativeEventFilter&quot;&gt;nativeEventFilter ()&lt;/a&gt; 함수 내에서도) 이벤트 필터를 제거하는 것이 항상 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="4d14cf07f967c7a4767253322ec7c24163ade430" translate="yes" xml:space="preserve">
          <source>It is an extended radial gradient.</source>
          <target state="translated">확장 된 방사형 그래디언트입니다.</target>
        </trans-unit>
        <trans-unit id="5a92cda40432e18765c5ad2d06c71b84593fb33d" translate="yes" xml:space="preserve">
          <source>It is an indicative measure calculated from the dimensions of the map area, roughly corresponding how much zoom level could change with maximum pinch zoom. Default value is 4.0, maximum value is 10.0</source>
          <target state="translated">이는 최대 핀치 확대 / 축소와 함께 확대 / 축소 수준이 얼마나 변할 수 있는지에 해당하는 맵 영역의 크기에서 계산 된 지표입니다. 기본값은 4.0이고 최대 값은 10.0입니다.</target>
        </trans-unit>
        <trans-unit id="4e766061a8aefde8309a4bc3115316659d910e0e" translate="yes" xml:space="preserve">
          <source>It is applied to all items that are created when:</source>
          <target state="translated">다음과 같은 경우 생성되는 모든 항목에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1ddb5a28e9a9113a838d12a815b586cb79fe380b" translate="yes" xml:space="preserve">
          <source>It is assumed that &lt;a href=&quot;qopenglbuffer#create&quot;&gt;create&lt;/a&gt;() has been called on this buffer and that it has been bound to the current context.</source>
          <target state="translated">이 버퍼에서 &lt;a href=&quot;qopenglbuffer#create&quot;&gt;create&lt;/a&gt; ()가 호출되었고 현재 컨텍스트에 바인딩 된 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="129e6e4bc27c2510269b13a04e570226d8f70ee3" translate="yes" xml:space="preserve">
          <source>It is assumed that this buffer has been bound to the current context, and that it was previously mapped with &lt;a href=&quot;qopenglbuffer#map&quot;&gt;map&lt;/a&gt;().</source>
          <target state="translated">이 버퍼는 현재 컨텍스트에 바인딩되었으며 이전에 &lt;a href=&quot;qopenglbuffer#map&quot;&gt;map&lt;/a&gt; ()으로 매핑 된 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="25534a13d5099963ed578b6caddd34729e8ef682" translate="yes" xml:space="preserve">
          <source>It is assumed that this buffer has been bound to the current context.</source>
          <target state="translated">이 버퍼는 현재 컨텍스트에 바인딩 된 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a766809687525fe238537020d0b462294c0551aa" translate="yes" xml:space="preserve">
          <source>It is assumed the list is given in highest to lowest preference order. By calling this function all previous configurations will be invalidated and replaced with the new list.</source>
          <target state="translated">목록이 가장 높은 우선 순위에서 가장 낮은 우선 순위로 제공되는 것으로 가정합니다. 이 함수를 호출하면 이전의 모든 구성이 무효화되고 새 목록으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="623d5b0a45435708982ac32b50cef0c73ce57c4f" translate="yes" xml:space="preserve">
          <source>It is at this point that the surface format set using &lt;a href=&quot;qoffscreensurface#setFormat&quot;&gt;setFormat&lt;/a&gt;() gets resolved into an actual native surface.</source>
          <target state="translated">이 시점에서 &lt;a href=&quot;qoffscreensurface#setFormat&quot;&gt;setFormat&lt;/a&gt; ()을 사용하여 설정된 표면 형식 이 실제 고유 표면으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="2a31fb5fe9a2a1a457a12df6097699e680812e6a" translate="yes" xml:space="preserve">
          <source>It is at this point that the surface format set using &lt;a href=&quot;qwindow#setFormat&quot;&gt;setFormat&lt;/a&gt;() gets resolved into an actual native surface. However, the window remains hidden until &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;() is called.</source>
          <target state="translated">이 시점에서 &lt;a href=&quot;qwindow#setFormat&quot;&gt;setFormat&lt;/a&gt; ()을 사용하여 설정된 표면 형식 이 실제 고유 표면으로 해석됩니다. 그러나 &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt; ()이 호출 될 때까지 창은 숨겨져 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c28bcedba1d45890d6d91a10dc5f317e31c8f3a" translate="yes" xml:space="preserve">
          <source>It is attached to each child item of the &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt; 의 각 하위 항목에 첨부됩니다 .</target>
        </trans-unit>
        <trans-unit id="0b1246f9ad07b0d01b165e9dd5dc88e69642faf1" translate="yes" xml:space="preserve">
          <source>It is attached to each instance of the delegate and also to the header, the footer and the highlight delegates.</source>
          <target state="translated">대리자의 각 인스턴스와 머리글, 바닥 글 및 강조 표시 대리자에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="ea71242f46d9f5013a2a5a6ca43e279a9780a018" translate="yes" xml:space="preserve">
          <source>It is attached to each instance of the delegate and also to the header, the footer, the section and the highlight delegates.</source>
          <target state="translated">델리게이트의 각 인스턴스와 머리글, 바닥 글, 섹션 및 강조 표시 델리게이트에 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="2c38e46008f8137c53006711504cd9a98470aad2" translate="yes" xml:space="preserve">
          <source>It is attached to each instance of the delegate.</source>
          <target state="translated">델리게이트의 각 인스턴스에 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="88cbca332b9fbdbdd4223c711fa5482c540788ed" translate="yes" xml:space="preserve">
          <source>It is attached to each tab button of the &lt;a href=&quot;qml-qtquick-controls2-tabbar&quot;&gt;TabBar&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-tabbar&quot;&gt;TabBar&lt;/a&gt; 의 각 탭 버튼에 첨부됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc92eb6b4d088ae6c3eac423e49dd78cb10de9f0" translate="yes" xml:space="preserve">
          <source>It is attached to each tab button of the &lt;a href=&quot;qtquickcontrols2-navigation#tabbar&quot;&gt;TabBar&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qtquickcontrols2-navigation#tabbar&quot;&gt;TabBar&lt;/a&gt; 의 각 탭 버튼에 첨부됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8538c9439c5972550d98139c45c3a0626307c25" translate="yes" xml:space="preserve">
          <source>It is available as a convenience for developers, as it offers a cleaner API.</source>
          <target state="translated">더 깨끗한 API를 제공하므로 개발자의 편의를 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="010aa57a32da8a16628682a57841d8fb968a7c5d" translate="yes" xml:space="preserve">
          <source>It is bright (eg. shade).</source>
          <target state="translated">밝습니다 (예 : 그늘).</target>
        </trans-unit>
        <trans-unit id="9452f6a38a6280572a93e2344caf809679c134db" translate="yes" xml:space="preserve">
          <source>It is called by the QPA platform plugin. On Windows, it is called by the event dispatcher.</source>
          <target state="translated">QPA 플랫폼 플러그인에 의해 호출됩니다. Windows에서는 이벤트 디스패처에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5ea61bddedc3d9d65839d53bbd5d5af2c31850dd" translate="yes" xml:space="preserve">
          <source>It is common for a style to have certain properties or attributes that apply to all controls. &lt;a href=&quot;qtqml-syntax-objectattributes#attached-properties-and-attached-signal-handlers&quot;&gt;Attached properties&lt;/a&gt; are a great way of extending an item in QML without having to modify any existing C++ belonging to that item. For example, both the &lt;a href=&quot;qtquickcontrols2-material&quot;&gt;Material&lt;/a&gt; and &lt;a href=&quot;qtquickcontrols2-universal&quot;&gt;Universal&lt;/a&gt; styles have an attached theme property that controls whether an item and its children will be rendered in a light or dark theme.</source>
          <target state="translated">스타일에 모든 컨트롤에 적용되는 특정 속성이나 특성이있는 것은 일반적입니다. &lt;a href=&quot;qtqml-syntax-objectattributes#attached-properties-and-attached-signal-handlers&quot;&gt;연결된 속성&lt;/a&gt; 은 해당 항목에 속한 기존 C ++를 수정하지 않고도 QML에서 항목을 확장하는 좋은 방법입니다. 예를 들어, &lt;a href=&quot;qtquickcontrols2-material&quot;&gt;Material&lt;/a&gt; 스타일 과 &lt;a href=&quot;qtquickcontrols2-universal&quot;&gt;Universal&lt;/a&gt; 스타일에는 항목과 해당 하위 항목이 밝은 테마 또는 어두운 테마로 렌더링되는지 여부를 제어하는 ​​연결된 테마 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e34fc78ca0cddadfd1d71a057b44c0bbaee4b35" translate="yes" xml:space="preserve">
          <source>It is common for a style to have certain properties or attributes that apply to all controls. &lt;a href=&quot;qtqml-syntax-objectattributes#attached-properties-and-attached-signal-handlers&quot;&gt;Attached properties&lt;/a&gt; are a great way of extending an item in QML without having to modify any existing C++ belonging to that item. For example, both the &lt;a href=&quot;qtquickcontrols2-material#&quot;&gt;Material&lt;/a&gt; and &lt;a href=&quot;qtquickcontrols2-universal#&quot;&gt;Universal&lt;/a&gt; styles have an attached theme property that controls whether an item and its children will be rendered in a light or dark theme.</source>
          <target state="translated">스타일에는 모든 컨트롤에 적용되는 특정 속성이나 특성이있는 것이 일반적입니다. &lt;a href=&quot;qtqml-syntax-objectattributes#attached-properties-and-attached-signal-handlers&quot;&gt;연결된 속성&lt;/a&gt; 은 해당 항목에 속하는 기존 C ++를 수정하지 않고도 QML에서 항목을 확장하는 좋은 방법입니다. 예를 들어, &lt;a href=&quot;qtquickcontrols2-material#&quot;&gt;재질&lt;/a&gt; 및 &lt;a href=&quot;qtquickcontrols2-universal#&quot;&gt;유니버설&lt;/a&gt; 스타일 모두 항목과 해당 하위 항목을 밝거나 어두운 테마로 렌더링할지 여부를 제어하는 ​​테마 속성이 첨부되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6b625dfd42310f7f1aadbb1abaae4aea0f2de45" translate="yes" xml:space="preserve">
          <source>It is common on Unix to also use the build tool to install applications and libraries; for example, by invoking &lt;code&gt;make install&lt;/code&gt;. For this reason, qmake has the concept of an &lt;code&gt;install set&lt;/code&gt;, an object which contains instructions about the way a part of a project is to be installed. For example, a collection of documentation files can be described in the following way:</source>
          <target state="translated">Unix에서는 빌드 도구를 사용하여 응용 프로그램 및 라이브러리를 설치하는 것이 일반적입니다. 예를 들어, 호출에 의해 &lt;code&gt;make install&lt;/code&gt; . 이러한 이유로 qmake는 프로젝트의 일부를 설치하는 방법에 대한 지시 사항을 포함하는 오브젝트 인 &lt;code&gt;install set&lt;/code&gt; 개념을 가지고 있습니다. 예를 들어 문서 파일 모음은 다음과 같은 방법으로 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3b456ff1e3f7af07002a6a66e055a7adc5746d6" translate="yes" xml:space="preserve">
          <source>It is currently not possible to set files in Xcode configuration settings from the qmake generated Xcode project file. The way the libraries are linked in the</source>
          <target state="translated">현재 qmake 생성 Xcode 프로젝트 파일에서 Xcode 구성 설정의 파일을 설정할 수 없습니다. 라이브러리가 라이브러리에서 연결되는 방식</target>
        </trans-unit>
        <trans-unit id="2e0fc9241cbe83d02a5bf3108392bd689bb47e49" translate="yes" xml:space="preserve">
          <source>It is customary to add a &quot;.&quot; at the end of the description.</source>
          <target state="translated">&quot;.&quot;를 추가하는 것이 일반적입니다. 설명의 끝에.</target>
        </trans-unit>
        <trans-unit id="c2e1e606a9787eacf9644145f8300a30fa1a6ba7" translate="yes" xml:space="preserve">
          <source>It is dark.</source>
          <target state="translated">어둡다.</target>
        </trans-unit>
        <trans-unit id="b2d6c2a997ce3b7935e828af41c611c9080b83d6" translate="yes" xml:space="preserve">
          <source>It is demonstrated by the uiloader example:</source>
          <target state="translated">uiloader 예제에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="27ea536d05b2b846cdd7c52afa6c124387447657" translate="yes" xml:space="preserve">
          <source>It is easier to list the source files and the headers only once in a script to build a static library. Then the &lt;code&gt;main()&lt;/code&gt; function will be linked against the static library to build the executable and the tests will be linked against the static libraries.</source>
          <target state="translated">정적 라이브러리를 빌드하기 위해 스크립트에서 소스 파일과 헤더를 한 번만 나열하는 것이 더 쉽습니다. 그런 다음 &lt;code&gt;main()&lt;/code&gt; 함수는 실행 파일을 빌드하기 위해 정적 라이브러리에 연결되고 테스트는 정적 라이브러리에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="8146302270fb45d397c493dd6468046828cb8bad" translate="yes" xml:space="preserve">
          <source>It is easy to move items around between the top level and lower levels in the tree. We just need to check whether the items are top-level items or not, and this information is supplied by each item's &lt;code&gt;parent()&lt;/code&gt; function. For example, we can remove the current item in the tree widget regardless of its location:</source>
          <target state="translated">트리에서 최상위 수준과 하위 수준 사이에서 항목을 쉽게 이동할 수 있습니다. 항목이 최상위 항목인지 여부를 확인하기 만하면됩니다.이 정보는 각 항목의 &lt;code&gt;parent()&lt;/code&gt; 함수 에 의해 제공됩니다 . 예를 들어, 위치에 관계없이 트리 위젯에서 현재 항목을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26cb0deebc5382597abfb9cef263ffa1378ccce5" translate="yes" xml:space="preserve">
          <source>It is equivalent to</source>
          <target state="translated">그것은</target>
        </trans-unit>
        <trans-unit id="75e0bfe833798efaebf20d3ba56c0a3ac5e09079" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;for (;;)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;for (;;)&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="56a78c541c5bf9c60110964633a0bba9f85fbbb9" translate="yes" xml:space="preserve">
          <source>It is equivalent to DefaultLocaleShortDate.</source>
          <target state="translated">DefaultLocaleShortDate와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="14069489fcbfc859dc0b97d0515b9db325b3a7f0" translate="yes" xml:space="preserve">
          <source>It is equivalent to SystemLocaleShortDate.</source>
          <target state="translated">SystemLocaleShortDate와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3bc23296d0636cfb2a92d034fdb9c24e9fdd10f7" translate="yes" xml:space="preserve">
          <source>It is equivalent to a plain &lt;code&gt;int&lt;/code&gt;, except with respect to function overloading and type conversions. You should never need to use this class in your applications.</source>
          <target state="translated">함수 오버로딩과 타입 변환을 제외하고 는 일반 &lt;code&gt;int&lt;/code&gt; 와 같습니다 . 응용 프로그램에서이 클래스를 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7c4c711893861b666a75432c98b3587a7ad0e21c" translate="yes" xml:space="preserve">
          <source>It is equivalent to a regular JavaScript variable. For example, var properties can store numbers, strings, objects, arrays and functions:</source>
          <target state="translated">일반 JavaScript 변수와 같습니다. 예를 들어 var 속성은 숫자, 문자열, 객체, 배열 및 함수를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2916d11bc42a9fa95831147ea86ce0f13f890c50" translate="yes" xml:space="preserve">
          <source>It is equivalent to the following code:</source>
          <target state="translated">다음 코드와 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ad0e9ce2d2116d74fb4ae3071167fd7914bb1ed" translate="yes" xml:space="preserve">
          <source>It is equivalent to the following snippet, but is faster and easier to use.</source>
          <target state="translated">다음 스 니펫과 동일하지만 더 빠르고 사용하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="dd682ac87607826c2b9f641beda6ad968ac97712" translate="yes" xml:space="preserve">
          <source>It is equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b8c3b404b69159368514d4f130296fab626f1329" translate="yes" xml:space="preserve">
          <source>It is expected that a Scene3DView's Entity provide a &lt;a href=&quot;qml-qt3d-render-rendersettings&quot;&gt;RenderSettings&lt;/a&gt; with a valid SceneGraph. Please note that only the &lt;a href=&quot;qml-qt3d-render-rendersettings&quot;&gt;RenderSettings&lt;/a&gt; of the first Scene3DView instantiated will be taken into account.</source>
          <target state="translated">Scene3DView의 엔티티 는 유효한 SceneGraph 와 함께 &lt;a href=&quot;qml-qt3d-render-rendersettings&quot;&gt;RenderSettings&lt;/a&gt; 를 제공 할 것으로 예상 됩니다. 인스턴스화 된 첫 번째 Scene3DView 의 &lt;a href=&quot;qml-qt3d-render-rendersettings&quot;&gt;RenderSettings&lt;/a&gt; 만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="9461ca819b79aca455e7db0ca5cfd3c74a66ccfa" translate="yes" xml:space="preserve">
          <source>It is generally advisable to explicitly enable or disable the socket notifier, especially for write notifiers.</source>
          <target state="translated">일반적으로 소켓 알리미, 특히 쓰기 알리미의 경우 명시 적으로 활성화 또는 비활성화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e74d2d8dea2295d8503926bc1b4e5bcc52917794" translate="yes" xml:space="preserve">
          <source>It is generally not advisable to add excessive amounts of pages to a &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt;. However, when the amount of pages grows larger, or individual pages are relatively complex, it may be desirable to free up resources by unloading pages that are outside the immediate reach of the user. The following example presents how to use &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; to keep a maximum of three pages simultaneously instantiated.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView에&lt;/a&gt; 과도한 양의 페이지를 추가하는 것은 일반적으로 권장되지 않습니다 . 그러나 페이지 수가 커지거나 개별 페이지가 상대적으로 복잡한 경우 사용자가 직접 접근 할 수없는 페이지를 언로드하여 리소스를 확보하는 것이 좋습니다. 다음 예는 &lt;a href=&quot;qml-qtquick-loader&quot;&gt;로더&lt;/a&gt; 를 사용 하여 최대 3 개의 페이지를 동시에 인스턴스화 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="3f2f8a5cb0c06f867db2fb281f9163f79d36b575" translate="yes" xml:space="preserve">
          <source>It is generally not advisable to add excessive amounts of pages to a SwipeView. However, when the amount of pages grows larger, or individual pages are relatively complex, it may be desirable to free up resources by unloading pages that are outside the immediate reach of the user. The following example presents how to use &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; to keep a maximum of three pages simultaneously instantiated.</source>
          <target state="translated">일반적으로 SwipeView에 과도한 양의 페이지를 추가하는 것은 바람직하지 않습니다. 그러나 페이지의 양이 더 커지거나 개별 페이지가 상대적으로 복잡한 경우 사용자가 직접 접근 할 수없는 페이지를 언로드하여 리소스를 확보하는 것이 바람직 할 수 있습니다. 다음 예제는 &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; 를 사용 하여 최대 세 페이지를 동시에 인스턴스화 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="975004d91ac6535aceecf578becbefc9384c7860" translate="yes" xml:space="preserve">
          <source>It is generally recommended that saving across plugins be handled as saving &lt;a href=&quot;qml-qtlocation-place#favorites&quot;&gt;favorites&lt;/a&gt; as explained in the Favorites section. However there is another approach which is to create a new place, set its (destination) plugin and then use the &lt;a href=&quot;qml-qtlocation-place#copyFrom-method&quot;&gt;copyFrom()&lt;/a&gt; method to copy the details of the original place. Using &lt;a href=&quot;qml-qtlocation-place#copyFrom-method&quot;&gt;copyFrom()&lt;/a&gt; only copies data that is supported by the destination plugin, plugin specific data such as the place identifier is not copied over. Once the copy is done, the place is in a suitable state to be saved.</source>
          <target state="translated">일반적으로 플러그인 전체에서 저장 &lt;a href=&quot;qml-qtlocation-place#favorites&quot;&gt;하는&lt;/a&gt; 것은 즐겨 찾기 섹션에 설명 된대로 즐겨 찾기 저장으로 처리하는 것이 좋습니다 . 그러나 새 장소를 작성하고 (목적지) 플러그인을 설정 한 다음 &lt;a href=&quot;qml-qtlocation-place#copyFrom-method&quot;&gt;copyFrom ()&lt;/a&gt; 메소드를 사용 하여 원래 장소의 세부 사항을 복사하는 다른 방법이 있습니다. &lt;a href=&quot;qml-qtlocation-place#copyFrom-method&quot;&gt;copyFrom ()을&lt;/a&gt; 사용 하면 대상 플러그인에서 지원하는 데이터 만 복사하며 장소 식별자와 같은 플러그인 특정 데이터는 복사되지 않습니다. 복사가 완료되면 장소는 저장하기에 적합한 상태입니다.</target>
        </trans-unit>
        <trans-unit id="4e39ad455f26cd03f557ebbfbd4f53805340369f" translate="yes" xml:space="preserve">
          <source>It is good practice to check that persistent model indexes are valid before using them.</source>
          <target state="translated">지속적 모델 색인이 사용하기 전에 유효한지 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="26b1103fa73cbd63a372437cb81f765f52b73d25" translate="yes" xml:space="preserve">
          <source>It is important that subclasses use this method to ensure that the engine reports its capabilities correctly. If this function is not used the engine will report that it supports no feature types at all.</source>
          <target state="translated">서브 클래스에서 엔진이 기능을 올바르게보고하도록하려면이 메소드를 사용하는 것이 중요합니다. 이 기능을 사용하지 않으면 엔진은 기능 유형이 전혀 지원되지 않는다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="174d037084f991bc15ed34658397b385c41ccb5b" translate="yes" xml:space="preserve">
          <source>It is important that subclasses use this method to ensure that the engine reports its capabilities correctly. If this function is not used the engine will report that it supports no feature weights at all.</source>
          <target state="translated">서브 클래스에서 엔진이 기능을 올바르게보고하도록하려면이 메소드를 사용하는 것이 중요합니다. 이 기능을 사용하지 않으면 엔진은 기능 가중치를 전혀 지원하지 않는다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="b14ab6f34d8cda255104be8a4e9ca871eb3dfdf8" translate="yes" xml:space="preserve">
          <source>It is important that subclasses use this method to ensure that the engine reports its capabilities correctly. If this function is not used the engine will report that it supports no maneuver details at all.</source>
          <target state="translated">서브 클래스에서 엔진이 기능을 올바르게보고하도록하려면이 메소드를 사용하는 것이 중요합니다. 이 기능을 사용하지 않으면 엔진은 조작 세부 사항을 전혀 지원하지 않는다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="1c43299b32dd759de87f92833b7128f8045469a4" translate="yes" xml:space="preserve">
          <source>It is important that subclasses use this method to ensure that the engine reports its capabilities correctly. If this function is not used the engine will report that it supports no route optimizations at all.</source>
          <target state="translated">서브 클래스에서 엔진이 기능을 올바르게보고하도록하려면이 메소드를 사용하는 것이 중요합니다. 이 기능을 사용하지 않으면 엔진은 경로 최적화를 전혀 지원하지 않는다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="2d676de6f84c7c803dd76e18f3e8d6ae1d3a74bc" translate="yes" xml:space="preserve">
          <source>It is important that subclasses use this method to ensure that the engine reports its capabilities correctly. If this function is not used the engine will report that it supports no segment detail at all.</source>
          <target state="translated">서브 클래스에서 엔진이 기능을 올바르게보고하도록하려면이 메소드를 사용하는 것이 중요합니다. 이 기능을 사용하지 않으면 엔진은 세그먼트 세부 사항을 전혀 지원하지 않는다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="cf9d03e573ee6966f0e0813b7eb5cbf1afe47954" translate="yes" xml:space="preserve">
          <source>It is important that subclasses use this method to ensure that the engine reports its capabilities correctly. If this function is not used the engine will report that it supports no travel modes at all.</source>
          <target state="translated">서브 클래스에서 엔진이 기능을 올바르게보고하도록하려면이 메소드를 사용하는 것이 중요합니다. 이 기능을 사용하지 않으면 엔진은 주행 모드를 전혀 지원하지 않는다고보고합니다.</target>
        </trans-unit>
        <trans-unit id="012d0f22fd1c0dfb663f652dd7215779724ddba3" translate="yes" xml:space="preserve">
          <source>It is important that the application stores the purchase information before calling &lt;a href=&quot;qinapptransaction#finalize&quot;&gt;finalize&lt;/a&gt;(). If a transaction is not finalized (for example because the application was interrupted before it had a chance to save the information), then the transaction will be emitted again the next time the product is registered by &lt;a href=&quot;qinappstore#registerProduct&quot;&gt;QInAppStore::registerProduct&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qinapptransaction#finalize&quot;&gt;finalize&lt;/a&gt; () 를 호출하기 전에 애플리케이션이 구매 정보를 저장하는 것이 중요합니다 . 트랜잭션이 완료되지 않은 경우 (예 : 정보를 저장하기 전에 응용 프로그램이 인터럽트 되었기 때문에) 다음에 &lt;a href=&quot;qinappstore#registerProduct&quot;&gt;QInAppStore :: registerProduct&lt;/a&gt; ()에 의해 제품을 등록 할 때 트랜잭션이 다시 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="1ab729fc211c7fc438a1b472feb77695e9c74eef" translate="yes" xml:space="preserve">
          <source>It is important that the lifetime of the creation context outlive any created objects. See &lt;a href=&quot;qtqml-javascript-dynamicobjectcreation#maintaining-dynamically-created-objects&quot;&gt;Maintaining Dynamically Created Objects&lt;/a&gt; for more details.</source>
          <target state="translated">생성 컨텍스트의 수명이 생성 된 개체보다 수명이 길어야합니다. 자세한 내용은 &lt;a href=&quot;qtqml-javascript-dynamicobjectcreation#maintaining-dynamically-created-objects&quot;&gt;동적으로 생성 된 객체 유지 관리&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cc0ab4889ed04d78385978d7ce346aae2f3489c5" translate="yes" xml:space="preserve">
          <source>It is important that this is done before &lt;a href=&quot;qgeoroutingmanagerengine#calculateRoute&quot;&gt;calculateRoute&lt;/a&gt;(), &lt;a href=&quot;qgeoroutingmanagerengine#updateRoute&quot;&gt;updateRoute&lt;/a&gt;() or any of the capability reporting functions are used to prevent incorrect or inconsistent behavior.</source>
          <target state="translated">&lt;a href=&quot;qgeoroutingmanagerengine#calculateRoute&quot;&gt;calculateRoute&lt;/a&gt; (), &lt;a href=&quot;qgeoroutingmanagerengine#updateRoute&quot;&gt;updateRoute&lt;/a&gt; () 또는 기능보고 기능을 사용하여 부정확하거나 일관성이없는 동작을 방지 하기 전에이 작업을 수행해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c907c36acbdba58842b6001078c74f66c1675903" translate="yes" xml:space="preserve">
          <source>It is important that you first log out of the current iTunes user on your Apple device. To do this, open the &lt;b&gt;Settings&lt;/b&gt; app from the homescreen and go to the &lt;b&gt;iTunes &amp;amp; App Store&lt;/b&gt; entry. Click the first entry (which should be &lt;b&gt;Apple ID&lt;/b&gt;) and select &lt;b&gt;Sign Out&lt;/b&gt;.</source>
          <target state="translated">먼저 Apple 장비에서 현재 iTunes 사용자를 로그 아웃해야합니다. 이렇게하려면 홈 화면에서 &lt;b&gt;설정&lt;/b&gt; 앱을 열고 &lt;b&gt;iTunes &amp;amp; App Store&lt;/b&gt; 항목으로 이동하십시오. 첫 번째 항목 ( &lt;b&gt;Apple ID&lt;/b&gt; 여야 함 )을 클릭하고 &lt;b&gt;로그 아웃을&lt;/b&gt; 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cffedcaff560f6aa27c9f8aa9e26b809601ccc7" translate="yes" xml:space="preserve">
          <source>It is important that you have a current OpenGL context set when creating the &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject&lt;/a&gt;, otherwise the initialization will fail.</source>
          <target state="translated">&lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject를&lt;/a&gt; 만들 때 현재 OpenGL 컨텍스트를 설정해야합니다 . 그렇지 않으면 초기화에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="79cbc92d33615fb197aeb2866986c188c1ee1f8a" translate="yes" xml:space="preserve">
          <source>It is important that you have a current OpenGL context set when creating the QOpenGLFramebufferObject, otherwise the initialization will fail.</source>
          <target state="translated">QOpenGLFramebufferObject를 생성 할 때 현재 OpenGL 컨텍스트가 설정되어 있어야합니다. 그렇지 않으면 초기화가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="03ee7437446422026062e49703fd2a5c4f792985" translate="yes" xml:space="preserve">
          <source>It is important to note that changes in regular properties of JavaScript objects assigned to a var property will &lt;b&gt;not&lt;/b&gt; trigger updates of bindings that access them. The example below will display &quot;The car has 4 wheels&quot; as the change to the wheels property will not cause the reevaluation of the binding assigned to the &quot;text&quot; property:</source>
          <target state="translated">var 속성에 할당 된 JavaScript 객체의 일반 속성을 변경해도 해당 객체에 액세스하는 바인딩의 업데이트는 트리거 &lt;b&gt;되지 않습니다&lt;/b&gt; . 아래 예제는 wheels 속성을 변경해도 &quot;text&quot;속성에 할당 된 바인딩을 재평가하지 않으므로 &quot;자동차에 4 개의 휠이 있습니다&quot;가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="edba41d969b8314c08ee7f1d257182c013dfed70" translate="yes" xml:space="preserve">
          <source>It is important to note that qAsConst() does not copy its argument, it just performs a &lt;code&gt;const_cast&amp;lt;const T&amp;amp;&amp;gt;(t)&lt;/code&gt;. This is also the reason why it is designed to fail for rvalues: The returned reference would go stale too soon. So while this works (but detaches the returned object):</source>
          <target state="translated">qAsConst ()는 인수를 복사하지 않고 &lt;code&gt;const_cast&amp;lt;const T&amp;amp;&amp;gt;(t)&lt;/code&gt; 만 수행합니다 . 이것이 rvalue에 실패하도록 설계된 이유이기도합니다. 반환 된 참조가 너무 빨리 만료됩니다. 그래서 이것이 작동하는 동안 (그러나 반환 된 객체를 분리합니다) :</target>
        </trans-unit>
        <trans-unit id="5c2278586684d35b34cc6ba1056194dd99c22c91" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; streaming functions must always produce the same number of entries in case of structures, both in reading and in writing (marshalling and demarshalling), otherwise calls and signals may start to silently fail.</source>
          <target state="translated">그것은 것이 중요하다 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 그렇지 않으면 호출 신호 실패를 자동으로 시작할 수 있고, 스트리밍 기능이 항상 읽기 및 쓰기 (마샬링하고, 분석하는)의 구조, 양자의 경우에 동일 항목 수를 생성해야 .</target>
        </trans-unit>
        <trans-unit id="76c0b9977aec506b6ffbafd7a03a8d8f6a14fbac" translate="yes" xml:space="preserve">
          <source>It is important to note that the above syntax is in fact an &lt;a href=&quot;qtqml-syntax-basics#object-declarations&quot;&gt;object declaration&lt;/a&gt; which will instantiate an object which acts on a pre-existing property.</source>
          <target state="translated">위의 구문은 사실 기존 속성에 작용하는 객체를 인스턴스화하는 객체 &lt;a href=&quot;qtqml-syntax-basics#object-declarations&quot;&gt;선언&lt;/a&gt; 이라는 점에 유의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b4fa2a7b79a59dd440bef47d100c165686e7ed47" translate="yes" xml:space="preserve">
          <source>It is important to note that the results in the &lt;a href=&quot;qplacecontentreply&quot;&gt;QPlaceContentReply&lt;/a&gt;, is a &lt;a href=&quot;qplacecontent#Collection-typedef&quot;&gt;QPlaceContent::Collection&lt;/a&gt; which is essentially a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;&amp;lt;int, &lt;a href=&quot;qplacecontent&quot;&gt;QPlaceContent&lt;/a&gt;&amp;gt;. The key &lt;code&gt;int&lt;/code&gt; in this case is the index of the content, and the value is the content itself. Due to the way Content is implemented it is possible to convert a content type as follows</source>
          <target state="translated">의 결과 것이 중요합니다 &lt;a href=&quot;qplacecontentreply&quot;&gt;QPlaceContentReply이&lt;/a&gt; 하는 것입니다 &lt;a href=&quot;qplacecontent#Collection-typedef&quot;&gt;QPlaceContent :: 컬렉션&lt;/a&gt; 본질적이다 &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; &amp;lt;INT, &lt;a href=&quot;qplacecontent&quot;&gt;QPlaceContent&lt;/a&gt; &amp;gt;. 이 경우 중요한 &lt;code&gt;int&lt;/code&gt; 는 컨텐츠의 색인이며 값은 컨텐츠 자체입니다. 컨텐츠 구현 방식으로 인해 컨텐츠 유형을 다음과 같이 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df991ff64539213f31feaa035b09649a6567217f" translate="yes" xml:space="preserve">
          <source>It is important to note that using a low-priority worker thread is recommended to minimize the risk of starving the GUI thread (which could result in worse perceived performance). Also, remember that synchronization and locking mechanisms can be a significant cause of slow performance, and so care should be taken to avoid unnecessary locking.</source>
          <target state="translated">GUI 스레드가 고갈 될 위험을 최소화하려면 우선 순위가 낮은 작업자 스레드를 사용하는 것이 좋습니다 (성능이 저하 될 수 있음). 또한 동기화 및 잠금 메커니즘이 성능 저하의 중요한 원인 일 수 있으므로 불필요한 잠금을 피하기 위해주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="d4d2dc43ca3893ab0de2b9987ff1f1831106ffb3" translate="yes" xml:space="preserve">
          <source>It is important to remember that Frameworks always link with</source>
          <target state="translated">프레임 워크는 항상</target>
        </trans-unit>
        <trans-unit id="5ec23f5aaa648d329361b5660b879ffea24d0fb4" translate="yes" xml:space="preserve">
          <source>It is important to remember that a &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt; instance &lt;a href=&quot;qobject#thread-affinity&quot;&gt;lives in&lt;/a&gt; the old thread that instantiated it, not in the new thread that calls &lt;a href=&quot;qthread#run&quot;&gt;run&lt;/a&gt;(). This means that all of &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt;'s queued slots and &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;invoked methods&lt;/a&gt; will execute in the old thread. Thus, a developer who wishes to invoke slots in the new thread must use the worker-object approach; new slots should not be implemented directly into a subclassed &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt;.</source>
          <target state="translated">기억하는 것이 중요하다 &lt;a href=&quot;qthread&quot;&gt;QThread의&lt;/a&gt; 인스턴스가 &lt;a href=&quot;qobject#thread-affinity&quot;&gt;에 살고&lt;/a&gt; 있지 호출하는 새 스레드에서, 그것을 인스턴스화 이전 스레드 &lt;a href=&quot;qthread#run&quot;&gt;실행&lt;/a&gt; (). 이것은 모든 &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt; 의 대기 된 슬롯과 &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;호출 된 메소드&lt;/a&gt; 가 이전 스레드에서 실행 됨을 의미합니다 . 따라서 새 스레드에서 슬롯을 호출하려는 개발자는 작업자-객체 접근 방식을 사용해야합니다. 새로운 슬롯을 서브 클래스 &lt;a href=&quot;qthread&quot;&gt;QThread에&lt;/a&gt; 직접 구현해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="dd5a015300b94069165de457fa50d30a4ad866f5" translate="yes" xml:space="preserve">
          <source>It is important to remember that a QThread instance &lt;a href=&quot;qobject#thread-affinity&quot;&gt;lives in&lt;/a&gt; the old thread that instantiated it, not in the new thread that calls &lt;a href=&quot;qthread#run&quot;&gt;run&lt;/a&gt;(). This means that all of QThread's queued slots and &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;invoked methods&lt;/a&gt; will execute in the old thread. Thus, a developer who wishes to invoke slots in the new thread must use the worker-object approach; new slots should not be implemented directly into a subclassed QThread.</source>
          <target state="translated">QThread 인스턴스 것을 기억하는 것이 중요하다 &lt;a href=&quot;qobject#thread-affinity&quot;&gt;에 살고&lt;/a&gt; 있지 호출하는 새 스레드에서, 그것을 인스턴스화 이전 스레드 &lt;a href=&quot;qthread#run&quot;&gt;실행&lt;/a&gt; (). 이것은 모든 QThread의 대기 슬롯과 &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;호출 된 메서드&lt;/a&gt; 가 이전 스레드에서 실행 된다는 것을 의미합니다 . 따라서 새 스레드에서 슬롯을 호출하려는 개발자는 작업자 개체 접근 방식을 사용해야합니다. 새 슬롯은 서브 클래 싱 된 QThread에 직접 구현해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d3ba072954ac0b0a6a28ee3a3e47bab04c5ae8b0" translate="yes" xml:space="preserve">
          <source>It is important to select the appropriate mechanism to exclude inapplicable tests: &lt;a href=&quot;qtest#QSKIP&quot;&gt;QSKIP&lt;/a&gt;(), using conditional statements to exclude parts of a test function, or not building the test for a particular platform.</source>
          <target state="translated">적용 할 수없는 테스트를 제외하는 적절한 메커니즘을 선택하는 것이 중요합니다. &lt;a href=&quot;qtest#QSKIP&quot;&gt;QSKIP&lt;/a&gt; (), 조건문을 사용하여 테스트 함수의 일부를 제외하거나 특정 플랫폼에 대한 테스트를 빌드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f22ff167f1710ecdaf6aa9a5d8eb1a4763d74693" translate="yes" xml:space="preserve">
          <source>It is important to set this property when the widget does not provide any text. For example a button that only contains an icon needs to set this property to work with screen readers. The name should be short and equivalent to the visual information conveyed by the widget.</source>
          <target state="translated">위젯이 텍스트를 제공하지 않으면이 특성을 설정해야합니다. 예를 들어, 아이콘 만 포함 된 버튼은 화면 판독기와 작동하도록이 속성을 설정해야합니다. 이름은 짧아야하며 위젯이 전달하는 시각적 정보와 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7e5eb8574e041c10f899c3971339da369260b9e" translate="yes" xml:space="preserve">
          <source>It is impossible to assign a weight to &lt;a href=&quot;qgeorouterequest#FeatureType-enum&quot;&gt;QGeoRouteRequest::NoFeature&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qgeorouterequest#FeatureType-enum&quot;&gt;QGeoRouteRequest :: NoFeature에&lt;/a&gt; 가중치를 할당 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ba50f25cd2e2c7ac90e6b2fa85b238318560387b" translate="yes" xml:space="preserve">
          <source>It is impossible to compare two numbers as strings directly. As a workaround, construct temporary values with a non-numeric prefix and compare these.</source>
          <target state="translated">두 숫자를 문자열로 직접 비교하는 것은 불가능합니다. 이 문제를 해결하려면 숫자가 아닌 접두사를 사용하여 임시 값을 구성하고이를 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="71bd4ea55e48a1e236d043fd181ff306e6781f44" translate="yes" xml:space="preserve">
          <source>It is instructive to compare &lt;a href=&quot;qexplicitlyshareddatapointer&quot;&gt;QExplicitlySharedDataPointer&lt;/a&gt; with &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; by way of an example. Consider the &lt;a href=&quot;qshareddatapointer#employee-example&quot;&gt;Employee example&lt;/a&gt; in &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt;, modified to use explicit sharing as explained in the discussion &lt;a href=&quot;qshareddatapointer#implicit-vs-explicit-sharing&quot;&gt;Implicit vs Explicit Sharing&lt;/a&gt;.</source>
          <target state="translated">예제를 통해 &lt;a href=&quot;qexplicitlyshareddatapointer&quot;&gt;QExplicitlySharedDataPointer&lt;/a&gt; 와 &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; 를 비교하는 것이 좋습니다 . &lt;a href=&quot;qshareddatapointer#implicit-vs-explicit-sharing&quot;&gt;암시 적 vs 명시 적 공유에&lt;/a&gt; 설명 된대로 명시 적 공유를 사용하도록 수정 된 &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; 의 &lt;a href=&quot;qshareddatapointer#employee-example&quot;&gt;직원 예제&lt;/a&gt; 를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9dbbc24fdf38c2051ceac477e36f8516ed33c67" translate="yes" xml:space="preserve">
          <source>It is instructive to compare QExplicitlySharedDataPointer with &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; by way of an example. Consider the &lt;a href=&quot;qshareddatapointer#employee-example&quot;&gt;Employee example&lt;/a&gt; in &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt;, modified to use explicit sharing as explained in the discussion &lt;a href=&quot;qshareddatapointer#implicit-vs-explicit-sharing&quot;&gt;Implicit vs Explicit Sharing&lt;/a&gt;.</source>
          <target state="translated">예를 들어 QExplicitlySharedDataPointer와 &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; 를 비교하는 것은 유익 합니다. &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; 의 &lt;a href=&quot;qshareddatapointer#employee-example&quot;&gt;Employee 예제&lt;/a&gt; 를 살펴보면 &lt;a href=&quot;qshareddatapointer#implicit-vs-explicit-sharing&quot;&gt;암시 적 공유 대 명시 적 공유&lt;/a&gt; 논의에 설명 된대로 명시 적 공유를 사용하도록 수정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6b00413076cac600bb2eb053b8081483aab47f5c" translate="yes" xml:space="preserve">
          <source>It is light (eg. internal lights).</source>
          <target state="translated">빛입니다 (예 : 내부 조명).</target>
        </trans-unit>
        <trans-unit id="a372ecb5f20dde23cc306a871312878490424cfb" translate="yes" xml:space="preserve">
          <source>It is likely at this point that you do not have all the necessary details to complete the information required to register your app. For now, just fill out the forms with stub data as everything except the &lt;b&gt;SKU&lt;/b&gt; and &lt;b&gt;Version&lt;/b&gt; fields are editable later.</source>
          <target state="translated">이 시점에서 앱 등록에 필요한 정보를 완성하는 데 필요한 모든 세부 정보가 없을 수 있습니다. 지금은 &lt;b&gt;SKU&lt;/b&gt; 및 &lt;b&gt;버전&lt;/b&gt; 필드를 제외한 모든 항목을 나중에 편집 할 수 있으므로 스텁 데이터로 양식을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="76d28b8d59ed5fa49f03e9e3e07f540ec8616817" translate="yes" xml:space="preserve">
          <source>It is mandatory to call this at the end of the saving operation, otherwise the file will be discarded.</source>
          <target state="translated">저장 작업이 끝나면이를 호출해야합니다. 그렇지 않으면 파일이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="1bee586e821a8226e0a973f772b2cb41652532fa" translate="yes" xml:space="preserve">
          <source>It is modeled after &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt;, and behaves the same. So, if you know how to use &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt;, you know how to use &lt;a href=&quot;qwebsocketserver&quot;&gt;QWebSocketServer&lt;/a&gt;. This class makes it possible to accept incoming WebSocket connections. You can specify the port or have &lt;a href=&quot;qwebsocketserver&quot;&gt;QWebSocketServer&lt;/a&gt; pick one automatically. You can listen on a specific address or on all the machine's addresses. Call &lt;a href=&quot;qwebsocketserver#listen&quot;&gt;listen&lt;/a&gt;() to have the server listen for incoming connections.</source>
          <target state="translated">&lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; 이후에 모델링되었으며 동일하게 작동합니다. 당신이 사용하는 방법을 알고있는 경우에 따라서, &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer을&lt;/a&gt; , 당신이 사용하는 방법을 알고 &lt;a href=&quot;qwebsocketserver&quot;&gt;QWebSocketServer을&lt;/a&gt; . 이 클래스를 사용하면 들어오는 WebSocket 연결을 수락 할 수 있습니다. 포트를 지정하거나 &lt;a href=&quot;qwebsocketserver&quot;&gt;QWebSocketServer가&lt;/a&gt; 자동으로 포트를 선택 하도록 할 수 있습니다 . 특정 주소 나 모든 기기의 주소를들을 수 있습니다. 서버가 수신 연결을 청취하게하려면 &lt;a href=&quot;qwebsocketserver#listen&quot;&gt;청취&lt;/a&gt; ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="93c99086159e259af9fca29f2fd8c5405ba13209" translate="yes" xml:space="preserve">
          <source>It is modeled after &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt;, and behaves the same. So, if you know how to use &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt;, you know how to use QWebSocketServer. This class makes it possible to accept incoming WebSocket connections. You can specify the port or have QWebSocketServer pick one automatically. You can listen on a specific address or on all the machine's addresses. Call &lt;a href=&quot;qwebsocketserver#listen&quot;&gt;listen&lt;/a&gt;() to have the server listen for incoming connections.</source>
          <target state="translated">&lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer를&lt;/a&gt; 모델로 하며 동일하게 작동합니다. 따라서 &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; 사용 방법을 알고 있다면 QWebSocketServer 사용 방법을 알 수 있습니다. 이 클래스를 사용하면 들어오는 WebSocket 연결을 수락 할 수 있습니다. 포트를 지정하거나 QWebSocketServer에서 자동으로 선택하도록 할 수 있습니다. 특정 주소 또는 모든 기기의 주소에서 수신 할 수 있습니다. 서버가 들어오는 연결을 수신하도록하려면 &lt;a href=&quot;qwebsocketserver#listen&quot;&gt;listen&lt;/a&gt; ()을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="b18da9b8db071e24e7df35de8d0f871165b4e024" translate="yes" xml:space="preserve">
          <source>It is moderately dark.</source>
          <target state="translated">약간 어둡습니다.</target>
        </trans-unit>
        <trans-unit id="3e8fa35edff019402eae8437fbebd56a6630061a" translate="yes" xml:space="preserve">
          <source>It is more efficient to use anchors rather than bindings to position items relative to each other. Consider this use of bindings to position rect2 relative to rect1:</source>
          <target state="translated">서로에 대해 항목을 배치하기 위해 바인딩보다 앵커를 사용하는 것이 더 효율적입니다. rect1을 기준으로 rect2를 배치하기 위해 이러한 바인딩 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9f507a367592c795347ff2370f9a8ed7dca3cc12" translate="yes" xml:space="preserve">
          <source>It is mostly used as a container to access other types such as &lt;a href=&quot;qml-qtaudioengine-audiocategory&quot;&gt;AudioCategory&lt;/a&gt;, &lt;a href=&quot;qml-qtaudioengine-audiosample&quot;&gt;AudioSample&lt;/a&gt; and Sound.</source>
          <target state="translated">&lt;a href=&quot;qml-qtaudioengine-audiocategory&quot;&gt;AudioCategory&lt;/a&gt; , &lt;a href=&quot;qml-qtaudioengine-audiosample&quot;&gt;AudioSample&lt;/a&gt; 및 Sound와 같은 다른 유형에 액세스하기위한 컨테이너로 주로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9dda7b4c6bc00b9014386313e0d52be49e51597b" translate="yes" xml:space="preserve">
          <source>It is necessary to call this function to start event handling. The main event loop receives events from the window system and dispatches these to the application widgets.</source>
          <target state="translated">이벤트 처리를 시작하려면이 함수를 호출해야합니다. 기본 이벤트 루프는 윈도우 시스템에서 이벤트를 수신하여이를 애플리케이션 위젯으로 디스패치합니다.</target>
        </trans-unit>
        <trans-unit id="606505cd6d77ddd79ff5d656d18538652790baa0" translate="yes" xml:space="preserve">
          <source>It is necessary to first register the scheme with &lt;a href=&quot;qwebengineurlscheme#registerScheme&quot;&gt;QWebEngineUrlScheme::registerScheme&lt;/a&gt; at application startup.</source>
          <target state="translated">응용 프로그램 시작시 먼저 &lt;a href=&quot;qwebengineurlscheme#registerScheme&quot;&gt;QWebEngineUrlScheme :: registerScheme&lt;/a&gt; 에 체계를 등록 해야합니다.</target>
        </trans-unit>
        <trans-unit id="de6e405c93cb5bc14f06c240caaaa03ca4361ab6" translate="yes" xml:space="preserve">
          <source>It is necessary to specify a format before writing an picture, but it is not necessary to specify a format before reading an picture.</source>
          <target state="translated">그림을 쓰기 전에 형식을 지정할 필요는 없지만 그림을 읽기 전에 형식을 지정할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="52ee4a50eba7009a5453a6049a18ca3b60cc4d5e" translate="yes" xml:space="preserve">
          <source>It is never emitted by &lt;a href=&quot;qlcdnumber#setDigitCount&quot;&gt;setDigitCount&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qlcdnumber#setDigitCount&quot;&gt;setDigitCount&lt;/a&gt; ()에 의해 방출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f161e07e48f805cb7a17fcf05290aa615986a9be" translate="yes" xml:space="preserve">
          <source>It is normal to begin using drag and drop in response to this event.</source>
          <target state="translated">이 이벤트에 대한 응답으로 끌어서 놓기를 사용하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="58cc8e1c38f68e8deff9d8880271e58d19c5be9d" translate="yes" xml:space="preserve">
          <source>It is normally empty, because touchscreens cannot uniquely identify fingers. But when it is set, it is expected to uniquely identify a specific token (fiducial object).</source>
          <target state="translated">터치 스크린은 손가락을 고유하게 식별 할 수 없으므로 일반적으로 비어 있습니다. 그러나 설정되면 특정 토큰 (기준 객체)을 고유하게 식별해야합니다.</target>
        </trans-unit>
        <trans-unit id="8db4ac30741536454b38d43b5cc31dc6282cde73" translate="yes" xml:space="preserve">
          <source>It is normally invalid (see &lt;a href=&quot;qpointingdeviceuniqueid#isValid&quot;&gt;isValid()&lt;/a&gt;), because touchscreens cannot uniquely identify fingers. But when the &lt;a href=&quot;qtouchevent-touchpoint#InfoFlag-enum&quot;&gt;Token&lt;/a&gt; flag is set, it is expected to uniquely identify a specific token (fiducial object).</source>
          <target state="translated">터치 스크린은 손가락을 고유하게 식별 할 수 없으므로 일반적으로 유효하지 않습니다 ( &lt;a href=&quot;qpointingdeviceuniqueid#isValid&quot;&gt;isValid ()&lt;/a&gt; 참조 ) . 그러나 &lt;a href=&quot;qtouchevent-touchpoint#InfoFlag-enum&quot;&gt;토큰&lt;/a&gt; 플래그가 설정되면 특정 토큰 (기준 객체)을 고유하게 식별해야합니다.</target>
        </trans-unit>
        <trans-unit id="5c2efce7eebe2344f5984edd91de8daea76feba5" translate="yes" xml:space="preserve">
          <source>It is not a requirement to open a session in order to monitor the underlying network interface.</source>
          <target state="translated">기본 네트워크 인터페이스를 모니터링하기 위해 세션을 열 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d8745ef2687adc004df7be098b6167dbc2b6f1b5" translate="yes" xml:space="preserve">
          <source>It is not always possible to abort a print job. For example, all the data has gone to the printer but the printer cannot or will not cancel the job when asked to.</source>
          <target state="translated">인쇄 작업을 중단 할 수있는 것은 아닙니다. 예를 들어 모든 데이터가 프린터로 전송되었지만 요청시 프린터가 작업을 취소 할 수 없거나 취소하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="370f72d25f0b3635cc3d0aeceac1f66cfc3259b3" translate="yes" xml:space="preserve">
          <source>It is not emitted when &lt;a href=&quot;qml-qtquick-animation#running-prop&quot;&gt;running&lt;/a&gt; is set to &lt;code&gt;false&lt;/code&gt;, nor for animations whose &lt;a href=&quot;qml-qtquick-animation#loops-prop&quot;&gt;loops&lt;/a&gt; property is set to &lt;code&gt;Animation.Infinite&lt;/code&gt;.</source>
          <target state="translated">그것은 때 방출되지 않고 &lt;a href=&quot;qml-qtquick-animation#running-prop&quot;&gt;실행이&lt;/a&gt; 설정되어 &lt;code&gt;false&lt;/code&gt; 않으며, 그 애니메이션 &lt;a href=&quot;qml-qtquick-animation#loops-prop&quot;&gt;루프&lt;/a&gt; 속성에 설정되어 &lt;code&gt;Animation.Infinite&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adea5774af0de95b05a6cea28620951ca8ecbe5e" translate="yes" xml:space="preserve">
          <source>It is not emitted when running is set to &lt;code&gt;false&lt;/code&gt;, nor for sprites whose &lt;a href=&quot;qml-qtquick-animatedsprite#loops-prop&quot;&gt;loops&lt;/a&gt; property is set to &lt;code&gt;AnimatedSprite.Infinite&lt;/code&gt;.</source>
          <target state="translated">running이 &lt;code&gt;false&lt;/code&gt; 로 설정 되거나 &lt;a href=&quot;qml-qtquick-animatedsprite#loops-prop&quot;&gt;loops&lt;/a&gt; 속성이 &lt;code&gt;AnimatedSprite.Infinite&lt;/code&gt; 로 설정된 스프라이트에 대해서는 방출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="bd7004a98b0fd7f3dd4bcef4010a21c5b6281566" translate="yes" xml:space="preserve">
          <source>It is not generally necessary to refer to these properties when adding child items or resources, as the default &lt;a href=&quot;qml-qtquick-item#data-prop&quot;&gt;data&lt;/a&gt; property will automatically assign child objects to the &lt;code&gt;children&lt;/code&gt; and &lt;code&gt;resources&lt;/code&gt; properties as appropriate. See the &lt;a href=&quot;qml-qtquick-item#data-prop&quot;&gt;data&lt;/a&gt; documentation for details.</source>
          <target state="translated">기본 &lt;a href=&quot;qml-qtquick-item#data-prop&quot;&gt;데이터&lt;/a&gt; 속성은 자동으로 하위 개체를 &lt;code&gt;children&lt;/code&gt; 및 &lt;code&gt;resources&lt;/code&gt; 속성에 자동으로 할당 하므로 하위 항목 또는 리소스를 추가 할 때 이러한 속성을 참조 할 필요는 없습니다 . 자세한 내용은 &lt;a href=&quot;qml-qtquick-item#data-prop&quot;&gt;데이터&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8976c9d396db9f7d57c5e934d66758c20802941c" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a &lt;a href=&quot;qscrollevent&quot;&gt;QScrollEvent&lt;/a&gt; will be sent after an acceepted &lt;a href=&quot;qscrollprepareevent&quot;&gt;QScrollPrepareEvent&lt;/a&gt;, e.g. in a case where the maximum content position is (0,0).</source>
          <target state="translated">&lt;a href=&quot;qscrollevent&quot;&gt;QScrollEvent&lt;/a&gt; 가 승인 된 &lt;a href=&quot;qscrollprepareevent&quot;&gt;QScrollPrepareEvent&lt;/a&gt; 후에 전송 되는 것은 보장되지 않습니다 ( 예 : 최대 컨텐츠 위치가 (0,0) 인 경우).</target>
        </trans-unit>
        <trans-unit id="782325e2375d4e6dc6bd1154f3d783f121f2fd4e" translate="yes" xml:space="preserve">
          <source>It is not guaranteed that a &lt;a href=&quot;qscrollevent&quot;&gt;QScrollEvent&lt;/a&gt; will be sent after an acceepted QScrollPrepareEvent, e.g. in a case where the maximum content position is (0,0).</source>
          <target state="translated">&lt;a href=&quot;qscrollevent&quot;&gt;QScrollEvent&lt;/a&gt; 가 acceepted QScrollPrepareEvent 이후에 전송 된다는 보장은 없습니다 . 예를 들어 최대 콘텐츠 위치가 (0,0) 인 경우.</target>
        </trans-unit>
        <trans-unit id="d0b30e2564372f87079bc08b049255a907f8ee0e" translate="yes" xml:space="preserve">
          <source>It is not instantiable; to use it, call the members of the global &lt;code&gt;Qt&lt;/code&gt; object directly. For example:</source>
          <target state="translated">인스턴스화 할 수 없습니다. 사용하려면 전역 &lt;code&gt;Qt&lt;/code&gt; 객체 의 멤버를 직접 호출하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="198eb1643ec70aa3ac8e082990a9b16239c3a817" translate="yes" xml:space="preserve">
          <source>It is not instantiable; to use it, call the members of the global &lt;code&gt;QtMultimedia&lt;/code&gt; object directly. For example:</source>
          <target state="translated">인스턴스화 할 수 없습니다. 이를 사용하려면 글로벌 &lt;code&gt;QtMultimedia&lt;/code&gt; 객체 의 멤버를 직접 호출하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="747d42c2e679834f47b93d131f6825d069da4b40" translate="yes" xml:space="preserve">
          <source>It is not necessary to call this function in most cases, because it is called automatically before invoking &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt; ()을 호출하기 전에 자동으로 호출되므로 대부분의 경우이 함수를 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="565c3cb09953498797ec4b760dd2ac75786b4108" translate="yes" xml:space="preserve">
          <source>It is not necessary to call this function in most cases, because it is called automatically before invoking &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;(). It is provided nonetheless to support advanced, multi-threaded scenarios where a thread different than the GUI or main thread may want to update the surface or framebuffer contents. See &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; for more information on threading related issues.</source>
          <target state="translated">&lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt; ()을 호출하기 전에 자동으로 호출되므로 대부분의 경우이 함수를 호출 할 필요는 없습니다 . 그럼에도 불구하고 GUI 또는 주 스레드와 다른 스레드가 표면 또는 프레임 버퍼 내용을 업데이트하려고 할 수있는 고급 다중 스레드 시나리오를 지원하기 위해 제공됩니다. 스레딩 관련 문제에 대한 자세한 내용 은 &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2bd03f2b1e729fdcf5fcd47df7e6ff49425e51f" translate="yes" xml:space="preserve">
          <source>It is not necessary to call this function in most cases, since the widget will make sure the context is bound and released properly when invoking &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt;().</source>
          <target state="translated">위젯은 &lt;a href=&quot;qopenglwidget#paintGL&quot;&gt;paintGL&lt;/a&gt; ()을 호출 할 때 컨텍스트가 바인드되고 올바르게 해제되도록하기 때문에 대부분의 경우이 함수를 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="36a78afe54b3319e999e942959ef7c3c8a9a336d" translate="yes" xml:space="preserve">
          <source>It is not necessary to call this function in most cases, since the widget will make sure the context is bound and released properly when invoking &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt;().</source>
          <target state="translated">위젯은 &lt;a href=&quot;qopenglwindow#paintGL&quot;&gt;paintGL&lt;/a&gt; ()을 호출 할 때 컨텍스트가 바인드되고 올바르게 해제되도록하기 때문에 대부분의 경우이 함수를 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5278023ba30ef3a642da426aee380f042e1dd070" translate="yes" xml:space="preserve">
          <source>It is not necessary to construct a &lt;a href=&quot;qpauseanimation&quot;&gt;QPauseAnimation&lt;/a&gt; yourself. &lt;a href=&quot;qsequentialanimationgroup&quot;&gt;QSequentialAnimationGroup&lt;/a&gt; provides the convenience functions &lt;a href=&quot;qsequentialanimationgroup#addPause&quot;&gt;addPause()&lt;/a&gt; and &lt;a href=&quot;qsequentialanimationgroup#insertPause&quot;&gt;insertPause()&lt;/a&gt;. These functions simply take the number of milliseconds the pause should last.</source>
          <target state="translated">&lt;a href=&quot;qpauseanimation&quot;&gt;QPauseAnimation을&lt;/a&gt; 직접 구성 할 필요는 없습니다 . &lt;a href=&quot;qsequentialanimationgroup&quot;&gt;QSequentialAnimationGroup&lt;/a&gt; 은 편리한 함수 &lt;a href=&quot;qsequentialanimationgroup#addPause&quot;&gt;addPause ()&lt;/a&gt; 및 &lt;a href=&quot;qsequentialanimationgroup#insertPause&quot;&gt;insertPause ()를 제공&lt;/a&gt; 합니다. 이러한 기능은 일시 정지가 지속되는 시간을 밀리 초 단위로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="7afdc6e7706c51decb3d7f10d2fc5c916a814f2c" translate="yes" xml:space="preserve">
          <source>It is not necessary to construct a QPauseAnimation yourself. &lt;a href=&quot;qsequentialanimationgroup&quot;&gt;QSequentialAnimationGroup&lt;/a&gt; provides the convenience functions &lt;a href=&quot;qsequentialanimationgroup#addPause&quot;&gt;addPause()&lt;/a&gt; and &lt;a href=&quot;qsequentialanimationgroup#insertPause&quot;&gt;insertPause()&lt;/a&gt;. These functions simply take the number of milliseconds the pause should last.</source>
          <target state="translated">QPauseAnimation을 직접 구성 할 필요는 없습니다. &lt;a href=&quot;qsequentialanimationgroup&quot;&gt;QSequentialAnimationGroup&lt;/a&gt; 은 편리한 함수 &lt;a href=&quot;qsequentialanimationgroup#addPause&quot;&gt;addPause ()&lt;/a&gt; 및 &lt;a href=&quot;qsequentialanimationgroup#insertPause&quot;&gt;insertPause ()를 제공&lt;/a&gt; 합니다. 이러한 함수는 일시 중지가 지속되어야하는 시간 (밀리 초) 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9f62c8b0355ca63906b99df0acd761a7cfe5e845" translate="yes" xml:space="preserve">
          <source>It is not necessary to support every role defined in &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::ItemDataRole&lt;/a&gt;. Depending on the type of data contained within a model, it may only be useful to implement the &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt;() function to return valid information for some of the more common roles. Most models provide at least a textual representation of item data for the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::DisplayRole&lt;/a&gt;, and well-behaved models should also provide valid information for the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::ToolTipRole&lt;/a&gt; and &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::WhatsThisRole&lt;/a&gt;. Supporting these roles enables models to be used with standard Qt views. However, for some models that handle highly-specialized data, it may be appropriate to provide data only for user-defined roles.</source>
          <target state="translated">&lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: ItemDataRole에&lt;/a&gt; 정의 된 모든 역할을 지원할 필요는 없습니다 . 모델에 포함 된 데이터 유형에 따라 일부 일반적인 역할에 대한 유효한 정보를 반환 하기 위해 &lt;a href=&quot;qabstractitemmodel#data&quot;&gt;data&lt;/a&gt; () 함수를 구현하는 것만 유용 할 수 있습니다 . 대부분의 모델은 최소한 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: DisplayRole에&lt;/a&gt; 대한 항목 데이터의 텍스트 표현을 제공하며 올바르게 작동하는 모델은 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: ToolTipRole&lt;/a&gt; 및 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: WhatsThisRole에&lt;/a&gt; 대한 유효한 정보도 제공해야합니다 . 이러한 역할을 지원하면 표준 Qt보기와 함께 모델을 사용할 수 있습니다. 그러나 고도로 전문화 된 데이터를 처리하는 일부 모델의 경우 사용자 정의 역할에 대해서만 데이터를 제공하는 것이 적절할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7c5c997f5d6e5d2c41507ae2ecf4dbff1a4c0cb" translate="yes" xml:space="preserve">
          <source>It is not possible to have the sensor report both single and double tap events. If both are needed the app should create 2 sensor objects.</source>
          <target state="translated">센서가 단일 및 이중 탭 이벤트를 모두보고하도록 할 수는 없습니다. 둘 다 필요한 경우 앱은 2 개의 센서 객체를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="fb3951e29337bf2c6afc962fb9f3be8d4958f719" translate="yes" xml:space="preserve">
          <source>It is not possible to lock for read if the thread already has locked for write.</source>
          <target state="translated">스레드가 쓰기를 위해 이미 잠겨 있으면 읽기 용으로 잠글 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="407c0ca79f739dbb49c78f0b660b686510558a09" translate="yes" xml:space="preserve">
          <source>It is not possible to lock for write if the thread already has locked for read.</source>
          <target state="translated">스레드가 이미 읽기를 위해 잠겨 있으면 쓰기를 위해 잠글 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8237e2a89c474f1de22d3ef095f336b0b21ef8bd" translate="yes" xml:space="preserve">
          <source>It is not possible to remove a title bar from a dock widget. However, a similar effect can be achieved by setting a default constructed &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; as the title bar widget.</source>
          <target state="translated">독 위젯에서 제목 표시 줄을 제거 할 수 없습니다. 그러나 기본 생성 된 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 을 제목 표시 줄 위젯으로 설정하여 유사한 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cdbca9cb736167f2551e7cc111d8d5a72c641fc3" translate="yes" xml:space="preserve">
          <source>It is not possible to render particle effects with the Software adaptation. Whenever possible, remove particles completely from the scene. Otherwise, they will still require some processing, even though they are not visible.</source>
          <target state="translated">소프트웨어 적응으로 입자 효과를 렌더링 할 수 없습니다. 가능하면 장면에서 파티클을 완전히 제거하십시오. 그렇지 않으면 보이지 않지만 여전히 일부 처리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a194e67d3b9ba693053771651527fab9b6d0dc13" translate="yes" xml:space="preserve">
          <source>It is not possible to retrieve the contents of a &lt;a href=&quot;qlcdnumber&quot;&gt;QLCDNumber&lt;/a&gt; object, although you can retrieve the numeric value with &lt;a href=&quot;qlcdnumber#value-prop&quot;&gt;value&lt;/a&gt;(). If you really need the text, we recommend that you connect the signals that feed the &lt;a href=&quot;qlcdnumber#display&quot;&gt;display&lt;/a&gt;() slot to another slot as well and store the value there.</source>
          <target state="translated">&lt;a href=&quot;qlcdnumber#value-prop&quot;&gt;값&lt;/a&gt; ()을 사용하여 숫자 값을 검색 할 수 있지만 &lt;a href=&quot;qlcdnumber&quot;&gt;QLCDNumber&lt;/a&gt; 오브젝트 의 컨텐츠를 검색 할 수 없습니다 . 실제로 텍스트가 필요한 경우 &lt;a href=&quot;qlcdnumber#display&quot;&gt;디스플레이&lt;/a&gt; () 슬롯을 공급하는 신호 를 다른 슬롯에 연결하고 값을 저장하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9272ced28c703315ee575cc29cec2a4be86cef6f" translate="yes" xml:space="preserve">
          <source>It is not possible to retrieve the contents of a QLCDNumber object, although you can retrieve the numeric value with &lt;a href=&quot;qlcdnumber#value-prop&quot;&gt;value&lt;/a&gt;(). If you really need the text, we recommend that you connect the signals that feed the &lt;a href=&quot;qlcdnumber#display&quot;&gt;display&lt;/a&gt;() slot to another slot as well and store the value there.</source>
          <target state="translated">&lt;a href=&quot;qlcdnumber#value-prop&quot;&gt;값&lt;/a&gt; ()으로 숫자 값을 검색 할 수 있지만 QLCDNumber 오브젝트의 컨텐츠를 검색 할 수 없습니다 . 텍스트가 정말로 필요한 경우 &lt;a href=&quot;qlcdnumber#display&quot;&gt;디스플레이&lt;/a&gt; () 슬롯을 공급하는 신호 를 다른 슬롯에도 연결하고 여기에 값을 저장하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3f122aa3d34a498c293d428fff185f0647f2f80d" translate="yes" xml:space="preserve">
          <source>It is not possible to set the SSL-state related fields.</source>
          <target state="translated">SSL 상태 관련 필드를 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a365dba196942232257912078423f52284c491d" translate="yes" xml:space="preserve">
          <source>It is not possible to set the port with &lt;a href=&quot;qsqldatabase#setPort&quot;&gt;QSqlDatabase::setPort&lt;/a&gt;() due to limitations in the Sybase client library. Refer to the Sybase documentation for information on how to set up a Sybase client configuration file to enable connections to databases on non-default ports.</source>
          <target state="translated">Sybase 클라이언트 라이브러리의 제한 사항으로 인해 &lt;a href=&quot;qsqldatabase#setPort&quot;&gt;QSqlDatabase :: setPort&lt;/a&gt; ()로 포트를 설정할 수 없습니다 . 기본이 아닌 포트의 데이터베이스에 연결할 수 있도록 Sybase 클라이언트 구성 파일을 설정하는 방법에 대한 정보는 Sybase 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bdfe83545ee39a27fb3eefcb5a42d9c208db28b5" translate="yes" xml:space="preserve">
          <source>It is not possible to simultanously request updates for more than one signal of the same monitor object. The last call to this function determines the signal upon which the updates cease to continue. At this stage only the &lt;a href=&quot;qgeoareamonitorsource#areaEntered&quot;&gt;areaEntered&lt;/a&gt;() and &lt;a href=&quot;qgeoareamonitorsource#areaExited&quot;&gt;areaExited&lt;/a&gt;() signals can be used to terminate the monitoring process.</source>
          <target state="translated">동일한 모니터 오브젝트의 둘 이상의 신호에 대한 업데이트를 동시에 요청할 수 없습니다. 이 함수에 대한 마지막 호출은 업데이트가 계속되는 신호를 결정합니다. 이 단계에서는 &lt;a href=&quot;qgeoareamonitorsource#areaEntered&quot;&gt;areaEntered&lt;/a&gt; () 및 &lt;a href=&quot;qgeoareamonitorsource#areaExited&quot;&gt;areaExited&lt;/a&gt; () 신호 만 모니터링 프로세스를 종료하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="320eea8d384cfe3b5bd1a19033202372c6c1f115" translate="yes" xml:space="preserve">
          <source>It is not recommended to hard-code colors, as applications and individual widgets can set their own palette and also use their style's palette for drawing. Note that none of Qt's widgets set their own palette. The Java style does hard-code some colors, but only as a decision of the author; it is not advised. Of course, it is not intended that the style should look good with any palette.</source>
          <target state="translated">응용 프로그램 및 개별 위젯은 자체 팔레트를 설정하고 스타일 팔레트를 사용하여 색상을 하드 코딩하는 것은 권장되지 않습니다. Qt의 위젯은 자체 팔레트를 설정하지 않습니다. Java 스타일은 일부 색상을 하드 코딩하지만 작성자의 결정으로 만 사용됩니다. 권장되지 않습니다. 물론 스타일이 팔레트에서 잘 보이도록 의도 된 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2bd083eae9a9ac83b3e84414859dcdd463b1e96c" translate="yes" xml:space="preserve">
          <source>It is not recommended to instantiate more than a single Scene3D instance per application. The reason for this is that a Scene3D instance instantiates the entire Qt 3D engine (memory managers, thread pool, render ...) under the scene. You should instead look into using &lt;a href=&quot;qml-qtquick-scene3d-scene3dview&quot;&gt;Scene3DView&lt;/a&gt; instances in conjunction with a single Scene3D instance.</source>
          <target state="translated">애플리케이션 당 두 개 이상의 Scene3D 인스턴스를 인스턴스화하지 않는 것이 좋습니다. 그 이유는 Scene3D 인스턴스가 장면 아래에서 전체 Qt 3D 엔진 (메모리 관리자, 스레드 풀, 렌더링 ...)을 인스턴스화하기 때문입니다. 대신 &lt;a href=&quot;qml-qtquick-scene3d-scene3dview&quot;&gt;Scene3DView&lt;/a&gt; 인스턴스를 단일 Scene3D 인스턴스와 함께 사용하는 것을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="46576e57b039a8113850b78a8e77b75d97627490" translate="yes" xml:space="preserve">
          <source>It is not recommended to override the default values set for a page size as this may be the minimum printable area for a physical print device.</source>
          <target state="translated">실제 인쇄 장치의 인쇄 가능한 최소 영역 일 수 있으므로 페이지 크기에 설정된 기본값을 무시하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a15694691ba6ba1c7e15e95fd833c0999342983d" translate="yes" xml:space="preserve">
          <source>It is not recommended to use &lt;a href=&quot;qml-qtquick-flickable#contentX-prop&quot;&gt;contentX&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-flickable#contentY-prop&quot;&gt;contentY&lt;/a&gt; to position the view at a particular index. This is unreliable since removing items from the start of the list does not cause all other items to be repositioned, and because the actual start of the view can vary based on the size of the delegates.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-flickable#contentX-prop&quot;&gt;contentX&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-flickable#contentY-prop&quot;&gt;contentY&lt;/a&gt; 를 사용 하여 뷰를 특정 인덱스에 배치 하지 않는 것이 좋습니다 . 목록의 시작 부분에서 항목을 제거해도 다른 모든 항목의 위치가 변경되지 않으며보기의 실제 시작 부분은 대리자의 크기에 따라 달라질 수 있기 때문에 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec22e1f9eb78230c8686b28a83777566c903a4ac" translate="yes" xml:space="preserve">
          <source>It is not recommended to use &lt;a href=&quot;qml-qtquick-flickable#contentX-prop&quot;&gt;contentX&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-flickable#contentY-prop&quot;&gt;contentY&lt;/a&gt; to position the view at a particular index. This is unreliable since removing items from the start of the list does not cause all other items to be repositioned, and because the actual start of the view can vary based on the size of the delegates. The correct way to bring an item into view is with &lt;code&gt;positionViewAtIndex&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-flickable#contentX-prop&quot;&gt;contentX&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-flickable#contentY-prop&quot;&gt;contentY&lt;/a&gt; 를 사용 하여 뷰를 특정 인덱스에 배치 하지 않는 것이 좋습니다 . 목록의 시작 부분에서 항목을 제거해도 다른 모든 항목의 위치가 변경되지 않으며보기의 실제 시작 부분은 대리자의 크기에 따라 달라질 수 있기 때문에 신뢰할 수 없습니다. 항목을 표시하는 올바른 방법은 &lt;code&gt;positionViewAtIndex&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="df103f2829f8eab2f7bcba5b6a4e444912eb33ab" translate="yes" xml:space="preserve">
          <source>It is not recommended to use &lt;a href=&quot;qml-qtquick-flickable#contentX-prop&quot;&gt;contentX&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-flickable#contentY-prop&quot;&gt;contentY&lt;/a&gt; to position the view at a particular index. This is unreliable since removing items from the start of the view does not cause all other items to be repositioned. The correct way to bring an item into view is with &lt;code&gt;positionViewAtIndex&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-flickable#contentX-prop&quot;&gt;contentX&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-flickable#contentY-prop&quot;&gt;contentY&lt;/a&gt; 를 사용 하여 뷰를 특정 인덱스에 배치 하지 않는 것이 좋습니다 . 보기의 시작 부분에서 항목을 제거해도 다른 모든 항목의 위치가 변경되지 않으므로 신뢰할 수 없습니다. 항목을 표시하는 올바른 방법은 &lt;code&gt;positionViewAtIndex&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2969b6f2eb3297a4b71d4aa1cedb47e4f4925739" translate="yes" xml:space="preserve">
          <source>It is not sufficient for an attribute or element to merely be called &lt;code&gt;id&lt;/code&gt;. Its value type must also be &lt;code&gt;ID&lt;/code&gt;. However, the reserved name &lt;code&gt;xml:id&lt;/code&gt; is sufficient.</source>
          <target state="translated">속성이나 요소를 단순히 &lt;code&gt;id&lt;/code&gt; 라고 부르는 것만으로는 충분하지 않습니다 . 값 유형도 &lt;code&gt;ID&lt;/code&gt; 여야합니다 . 그러나 예약 된 이름 &lt;code&gt;xml:id&lt;/code&gt; 이면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="e1e8640fc848463537ffc9df2a440df791599486" translate="yes" xml:space="preserve">
          <source>It is not sufficient for an attribute or element to merely be called &lt;code&gt;idref&lt;/code&gt;. It must also be of type &lt;code&gt;IDREF&lt;/code&gt;. Elements must be typed as &lt;code&gt;xs:IDREF&lt;/code&gt; or &lt;code&gt;xs:IDREFS&lt;/code&gt;, or, in the case of attributes, as &lt;code&gt;IDREF&lt;/code&gt; or &lt;code&gt;IDREFS&lt;/code&gt; in the schema.</source>
          <target state="translated">속성 또는 요소를 단순히 &lt;code&gt;idref&lt;/code&gt; 라고하는 것만으로는 충분하지 않습니다 . 또한 &lt;code&gt;IDREF&lt;/code&gt; 유형이어야합니다 . 요소는 &lt;code&gt;xs:IDREF&lt;/code&gt; 또는 &lt;code&gt;xs:IDREFS&lt;/code&gt; 로 입력하거나 속성의 경우 스키마에서 &lt;code&gt;IDREF&lt;/code&gt; 또는 &lt;code&gt;IDREFS&lt;/code&gt; 로 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="804fef8ec10154cd817a953dd48c757e879ee576" translate="yes" xml:space="preserve">
          <source>It is occasionally necessary to run some imperative code at application (or component instance) startup. While it is tempting to just include the startup script as</source>
          <target state="translated">응용 프로그램 (또는 구성 요소 인스턴스) 시작시 명령 코드를 실행해야하는 경우가 있습니다. 시작 스크립트를 다음과 같이 포함하고 싶은 유혹이 있습니다.</target>
        </trans-unit>
        <trans-unit id="78690aa9b0ed1c83b4d660b98f6a036c92b973c9" translate="yes" xml:space="preserve">
          <source>It is often desirable to delay some processing until the component is completed.</source>
          <target state="translated">구성 요소가 완료 될 때까지 일부 처리를 지연시키는 것이 종종 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="c8d55342fb1f34d5127ef080bc6d1bd3721a7381" translate="yes" xml:space="preserve">
          <source>It is often desirable to give the user a special (often default) choice in addition to the range of numeric values. See &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;setSpecialValueText&lt;/a&gt;() for how to do this with &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt;.</source>
          <target state="translated">숫자 값의 범위 외에 사용자에게 특별한 (종종 기본값) 선택을 제공하는 것이 종종 바람직합니다. 참조 &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;setSpecialValueText를&lt;/a&gt; 사용하여이 작업을 수행하는 방법은 () &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f19f84c0dec2a71fde1b5515317e4e3e4265f4ad" translate="yes" xml:space="preserve">
          <source>It is often desirable to give the user a special (often default) choice in addition to the range of numeric values. See &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;setSpecialValueText&lt;/a&gt;() for how to do this with &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt;.</source>
          <target state="translated">숫자 값의 범위 외에 사용자에게 특별한 (종종 기본값) 선택을 제공하는 것이 종종 바람직합니다. &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; 로이를 수행하는 방법 은 &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;setSpecialValueText&lt;/a&gt; ()를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="45095397a00b59a2f21c0972fa4078460e6a151b" translate="yes" xml:space="preserve">
          <source>It is often desirable to give the user a special (often default) choice in addition to the range of numeric values. See &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;setSpecialValueText&lt;/a&gt;() for how to do this with QDoubleSpinBox.</source>
          <target state="translated">사용자에게 숫자 값 범위 외에 특별한 (종종 기본값) 선택을 제공하는 것이 바람직합니다. &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;QDoubleSpinBox로이&lt;/a&gt; 를 수행하는 방법 은 setSpecialValueText ()를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a8545e7c8bb2ea3c9ec9e72a5866975b78dbfe7" translate="yes" xml:space="preserve">
          <source>It is often desirable to give the user a special (often default) choice in addition to the range of numeric values. See &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;setSpecialValueText&lt;/a&gt;() for how to do this with QSpinBox.</source>
          <target state="translated">사용자에게 숫자 값 범위 외에 특별한 (종종 기본값) 선택을 제공하는 것이 바람직합니다. QSpinBox로이를 수행하는 방법 은 &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;setSpecialValueText&lt;/a&gt; ()를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8590b20fd476fabe22ea676780c46a698f7e2de4" translate="yes" xml:space="preserve">
          <source>It is often desirable to write your own custom model in C++ for use with a view in QML. While the optimal implementation of any such model will depend heavily on the use-case it must fulfil, some general guidelines are as follows:</source>
          <target state="translated">QML의 뷰와 함께 사용하기 위해 C ++로 사용자 정의 모델을 작성하는 것이 종종 바람직합니다. 이러한 모델의 최적 구현은 이행해야하는 사용 사례에 따라 크게 다르지만 몇 가지 일반적인 지침은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="160a6b1c7425564459a3a362f29b3742e923ee6f" translate="yes" xml:space="preserve">
          <source>It is often easier and cleaner to define an ENUM inside a class (see &lt;a href=&quot;#enum&quot;&gt;ENUM&lt;/a&gt;), but if you need a standalone enum type, using the ENUM keyword outside of a class definition can be helpful. This will generate a new class in your header files that handles marshalling, etc.. The syntax is identical to &lt;a href=&quot;#enum&quot;&gt;ENUM&lt;/a&gt;, with the exception that the declaration in this case is not contained in a &lt;code&gt;class&lt;/code&gt; declaration.</source>
          <target state="translated">클래스 내에서 ENUM을 정의하는 것이 더 쉽고 깔끔한 경우가 많지만 ( &lt;a href=&quot;#enum&quot;&gt;ENUM&lt;/a&gt; 참조 ) 독립형 열거 형 유형이 필요한 경우 클래스 정의 외부에서 ENUM 키워드를 사용하면 도움이 될 수 있습니다. 이렇게하면 마샬링 등을 처리하는 헤더 파일에 새 클래스가 생성 됩니다.이 경우 선언이 &lt;code&gt;class&lt;/code&gt; 선언에 포함되지 않는다는 점을 제외하면 구문은 &lt;a href=&quot;#enum&quot;&gt;ENUM&lt;/a&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f290464adc08a63f0b6ec042546fa5413d9417cd" translate="yes" xml:space="preserve">
          <source>It is often easier and cleaner to define an ENUM inside a class (see &lt;a href=&quot;qtremoteobjects-repc#enum&quot;&gt;ENUM&lt;/a&gt;), but if you need a standalone enum type, using the ENUM keyword outside of a class definition can be helpful. This will generate a new class in your header files that handles marshalling, etc.. The syntax is identical to &lt;a href=&quot;qtremoteobjects-repc#enum&quot;&gt;ENUM&lt;/a&gt;, with the exception that the declaration in this case is not contained in a &lt;code&gt;class&lt;/code&gt; declaration.</source>
          <target state="translated">클래스 내에서 ENUM을 정의하는 것이 더 쉽고 깔끔 하지만 ( &lt;a href=&quot;qtremoteobjects-repc#enum&quot;&gt;ENUM&lt;/a&gt; 참조 ) 독립형 enum 유형이 필요한 경우 클래스 정의 외부에서 ENUM 키워드를 사용하는 것이 도움이 될 수 있습니다. 이렇게하면 마샬링 등을 처리하는 헤더 파일에 새 클래스가 생성됩니다. 구문은 &lt;a href=&quot;qtremoteobjects-repc#enum&quot;&gt;ENUM&lt;/a&gt; 과 동일하지만 이 경우 선언이 &lt;code&gt;class&lt;/code&gt; 선언에 포함되지 않는다는 점이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="480c6a8f35b7be35ec849611ef531650d27388ac" translate="yes" xml:space="preserve">
          <source>It is often more convenient to use &lt;a href=&quot;qdeadlinetimer&quot;&gt;QDeadlineTimer&lt;/a&gt; in this case, which counts towards a timeout in the future instead of tracking elapsed time.</source>
          <target state="translated">이 경우 &lt;a href=&quot;qdeadlinetimer&quot;&gt;QDeadlineTimer&lt;/a&gt; 를 사용하는 것이 더 편리합니다 .이 시간은 경과 시간을 추적하는 대신 미래의 시간 초과로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="d010f5292a2038c9bee95bcba519aeb7c0c73e17" translate="yes" xml:space="preserve">
          <source>It is often quite useful to make a custom type printable for debugging purposes, as in the following code:</source>
          <target state="translated">다음 코드와 같이 디버깅 목적으로 사용자 정의 유형을 인쇄 가능하게 만드는 것이 종종 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0f5822d82ed0604bb7346cd6ad61790d10b1c9d1" translate="yes" xml:space="preserve">
          <source>It is often useful to be able to find items within an item view widget, either as a developer or as a service to present to users. All three item view convenience classes provide a common &lt;code&gt;findItems()&lt;/code&gt; function to make this as consistent and simple as possible.</source>
          <target state="translated">개발자 또는 사용자에게 제공 할 서비스로 항목보기 위젯에서 항목을 찾을 수있는 것이 종종 유용합니다. 세 가지 항목보기 편의 클래스는 모두 공통적 인 &lt;code&gt;findItems()&lt;/code&gt; 함수를 제공하여 가능한 한 일관되고 단순하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5a21453b3d943980ad7aa41fbf1ccd8accbc5010" translate="yes" xml:space="preserve">
          <source>It is ok to obtain the value of the pointer and using that value itself, like for example in debugging statements:</source>
          <target state="translated">예를 들어 디버깅 명령문에서와 같이 포인터의 값을 얻고 해당 값 자체를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d21bb65e9bcc700397d9a5602e52f134cb88e660" translate="yes" xml:space="preserve">
          <source>It is only possible to call functions through dynamicCall() that have parameters or return values of datatypes supported by &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;. See the &lt;a href=&quot;qaxbase&quot;&gt;QAxBase&lt;/a&gt; class documentation for a list of supported and unsupported datatypes. If you want to call functions that have unsupported datatypes in the parameter list, use &lt;a href=&quot;qaxbase#queryInterface&quot;&gt;queryInterface&lt;/a&gt;() to retrieve the appropriate COM interface, and use the function directly.</source>
          <target state="translated">&lt;a href=&quot;qvariant&quot;&gt;QVariant가&lt;/a&gt; 지원하는 데이터 유형의 매개 변수 또는 리턴 값이있는 dynamicCall ()을 통해서만 함수를 호출 할 수 있습니다 . 지원 및 지원되지 않는 데이터 유형 목록은 &lt;a href=&quot;qaxbase&quot;&gt;QAxBase&lt;/a&gt; 클래스 문서를 참조하십시오 . 매개 변수 목록에서 지원되지 않는 데이터 유형이있는 함수를 호출하려면 &lt;a href=&quot;qaxbase#queryInterface&quot;&gt;queryInterface&lt;/a&gt; ()를 사용 하여 적절한 COM 인터페이스를 검색하고 함수를 직접 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9af2099d251964ebf57b90bdc95c255bc227e72f" translate="yes" xml:space="preserve">
          <source>It is only triggered for top-level, standalone animations. It will not be triggered for animations in a Behavior or Transition, or animations that are part of an animation group.</source>
          <target state="translated">최상위 독립 실행 형 애니메이션에 대해서만 트리거됩니다. 비헤이비어 또는 전환의 애니메이션 또는 애니메이션 그룹의 일부인 애니메이션에 대해서는 트리거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="65511d2a482e0599722c5cbefca357f129a5d2a9" translate="yes" xml:space="preserve">
          <source>It is perfectly OK to create an instance of &lt;a href=&quot;qmimedatabase&quot;&gt;QMimeDatabase&lt;/a&gt; every time you need to perform a lookup. The parsing of mimetypes is done on demand (when shared-mime-info is installed) or when the very first instance is constructed (when parsing XML files directly).</source>
          <target state="translated">조회를 수행해야 할 때마다 &lt;a href=&quot;qmimedatabase&quot;&gt;QMimeDatabase&lt;/a&gt; 인스턴스를 작성 해도 됩니다. mimetype의 구문 분석은 요청시 (shared-mime-info가 설치된 경우) 또는 첫 번째 인스턴스가 구성 될 때 (XML 파일을 직접 구문 분석 할 때) 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="26ea6491158ce6432e502f30801b3dd77fccfb70" translate="yes" xml:space="preserve">
          <source>It is perfectly OK to create an instance of QMimeDatabase every time you need to perform a lookup. The parsing of mimetypes is done on demand (when shared-mime-info is installed) or when the very first instance is constructed (when parsing XML files directly).</source>
          <target state="translated">조회를 수행해야 할 때마다 QMimeDatabase의 인스턴스를 생성하는 것은 완벽합니다. MIME 유형의 구문 분석은 요청시 (shared-mime-info가 설치된 경우) 또는 첫 번째 인스턴스가 생성 될 때 (XML 파일을 직접 구문 분석 할 때) 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="26c07d685926a4e9e18cfeb51b0da8c8af86d24f" translate="yes" xml:space="preserve">
          <source>It is positive if the property value exceeds &lt;a href=&quot;qml-qt-labs-animation-boundaryrule#maximum-prop&quot;&gt;maximum&lt;/a&gt;, negative if the property value is less than &lt;a href=&quot;qml-qt-labs-animation-boundaryrule#minimum-prop&quot;&gt;minimum&lt;/a&gt;, or 0 if the property value is within both boundaries.</source>
          <target state="translated">속성 값이 &lt;a href=&quot;qml-qt-labs-animation-boundaryrule#maximum-prop&quot;&gt;maximum을&lt;/a&gt; 초과하면 양수, 속성 값이 &lt;a href=&quot;qml-qt-labs-animation-boundaryrule#minimum-prop&quot;&gt;minimum&lt;/a&gt; 미만이면 음수 , 속성 값이 두 경계 내에 있으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="f797a1814c82acfaad7eb84efa973cda5156cfac" translate="yes" xml:space="preserve">
          <source>It is possible for a &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; object to be invalid because of syntax errors in the pattern string. The &lt;a href=&quot;qregularexpression#isValid&quot;&gt;isValid&lt;/a&gt;() function will return true if the regular expression is valid, or false otherwise:</source>
          <target state="translated">A에 대한 것이 가능하다 &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression의&lt;/a&gt; 객체가 있기 때문에 패턴 문자열에 구문 오류의 무효. &lt;a href=&quot;qregularexpression#isValid&quot;&gt;isValid&lt;/a&gt; 정규 표현식이 유효하거나, 그렇지 않은 경우는 false 경우 () 함수는 true를 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="62cc8075587ba85131cf56fbf31d37cb332d3fb6" translate="yes" xml:space="preserve">
          <source>It is possible for a QRegularExpression object to be invalid because of syntax errors in the pattern string. The &lt;a href=&quot;qregularexpression#isValid&quot;&gt;isValid&lt;/a&gt;() function will return true if the regular expression is valid, or false otherwise:</source>
          <target state="translated">패턴 문자열의 구문 오류로 인해 QRegularExpression 객체가 유효하지 않을 수 있습니다. &lt;a href=&quot;qregularexpression#isValid&quot;&gt;isValid&lt;/a&gt; 정규 표현식이 유효하거나, 그렇지 않은 경우는 false 경우 () 함수는 true를 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="9a4614ac6c8279c6ee6a9ba7c5a5822113d40371" translate="yes" xml:space="preserve">
          <source>It is possible for a custom delegate to provide editors without the use of an editor item factory. In this case, the following virtual functions must be reimplemented:</source>
          <target state="translated">커스텀 델리게이트는 에디터 아이템 팩토리를 사용하지 않고 에디터를 제공 할 수 있습니다. 이 경우 다음 가상 기능을 다시 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc885bdd2fcb6d6b24f79c0585f359f61d7bb804" translate="yes" xml:space="preserve">
          <source>It is possible for an aliasing property to have the same name as an existing property, effectively overwriting the existing property. For example, the following QML type has a &lt;code&gt;color&lt;/code&gt; alias property, named the same as the built-in &lt;a href=&quot;qml-qtquick-rectangle#color-prop&quot;&gt;Rectangle::color&lt;/a&gt; property:</source>
          <target state="translated">앨리어싱 속성이 기존 속성과 이름이 동일하여 기존 속성을 효과적으로 덮어 쓸 수 있습니다. 예를 들어 다음 QML 유형에는 내장 &lt;a href=&quot;qml-qtquick-rectangle#color-prop&quot;&gt;Rectangle :: color&lt;/a&gt; 속성 과 이름이 같은 &lt;code&gt;color&lt;/code&gt; 별칭 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="abf20951678d3358e7e308e0d573088880963f22" translate="yes" xml:space="preserve">
          <source>It is possible for applications and libraries to insert custom messages in the debug log, for instance for marking a group of related OpenGL commands and therefore being then able to identify eventual messages coming from them.</source>
          <target state="translated">응용 프로그램 및 라이브러리가 디버그 로그에 사용자 정의 메시지를 삽입 할 수 있습니다. 예를 들어 관련 OpenGL 명령 그룹을 표시하여 최종 메시지를 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d52d6c48f12268b10686307191eed95e8d165223" translate="yes" xml:space="preserve">
          <source>It is possible for roles to contain list data. In the following example we create a list of fruit attributes:</source>
          <target state="translated">역할이 목록 데이터를 포함 할 수 있습니다. 다음 예제에서는 과일 속성 목록을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="dc45547eb4d42a0586a127a8486ce9a6721910c5" translate="yes" xml:space="preserve">
          <source>It is possible that a newly created &lt;a href=&quot;qgeocodereply&quot;&gt;QGeoCodeReply&lt;/a&gt; may be in a finished state, most commonly because an error has occurred. Since such an instance will never emit the &lt;a href=&quot;qgeocodereply#finished&quot;&gt;finished&lt;/a&gt;() or error(&lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply::Error&lt;/a&gt;,&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;) signals, it is important to check the result of &lt;a href=&quot;qgeocodereply#isFinished&quot;&gt;isFinished&lt;/a&gt;() before making the connections to the signals. The documentation for &lt;a href=&quot;qgeocodingmanager&quot;&gt;QGeoCodingManager&lt;/a&gt; demonstrates how this might be carried out.</source>
          <target state="translated">새로 생성 된 &lt;a href=&quot;qgeocodereply&quot;&gt;QGeoCodeReply&lt;/a&gt; 가 완료 상태 일 수 있습니다. 가장 일반적으로 오류가 발생했기 때문입니다. 이러한 인스턴스는 &lt;a href=&quot;qgeocodereply#finished&quot;&gt;완료된&lt;/a&gt; () 또는 error ( &lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply :: Error&lt;/a&gt; , &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; ) 신호를 방출하지 않으므로 신호 에 연결하기 전에 &lt;a href=&quot;qgeocodereply#isFinished&quot;&gt;isFinished&lt;/a&gt; () 의 결과를 확인하는 것이 중요합니다 . &lt;a href=&quot;qgeocodingmanager&quot;&gt;QGeoCodingManager에&lt;/a&gt; 대한 문서는 이를 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7998b967136c5e4ab2a067a08f8136a06f5c34eb" translate="yes" xml:space="preserve">
          <source>It is possible that a newly created &lt;a href=&quot;qgeoroutereply&quot;&gt;QGeoRouteReply&lt;/a&gt; may be in a finished state, most commonly because an error has occurred. Since such an instance will never emit the &lt;a href=&quot;qgeoroutereply#finished&quot;&gt;finished&lt;/a&gt;() or error(&lt;a href=&quot;qgeoroutereply#Error-enum&quot;&gt;QGeoRouteReply::Error&lt;/a&gt;,&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;) signals, it is important to check the result of &lt;a href=&quot;qgeoroutereply#isFinished&quot;&gt;isFinished&lt;/a&gt;() before making the connections to the signals. The documentation for &lt;a href=&quot;qgeoroutingmanager&quot;&gt;QGeoRoutingManager&lt;/a&gt; demonstrates how this might be carried out.</source>
          <target state="translated">새로 생성 된 &lt;a href=&quot;qgeoroutereply&quot;&gt;QGeoRouteReply&lt;/a&gt; 가 완료 상태 일 수 있습니다. 가장 일반적으로 오류가 발생했기 때문입니다. 이러한 인스턴스는 &lt;a href=&quot;qgeoroutereply#finished&quot;&gt;완료된&lt;/a&gt; () 또는 error ( &lt;a href=&quot;qgeoroutereply#Error-enum&quot;&gt;QGeoRouteReply :: Error&lt;/a&gt; , &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; ) 신호 를 절대로 방출하지 않으므로 신호 에 연결하기 전에 &lt;a href=&quot;qgeoroutereply#isFinished&quot;&gt;isFinished&lt;/a&gt; () 의 결과를 확인하는 것이 중요합니다 . &lt;a href=&quot;qgeoroutingmanager&quot;&gt;QGeoRoutingManager에&lt;/a&gt; 대한 문서는 이를 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3e6653472cc9c63a8a3352ec24b09e0fa7bb56b1" translate="yes" xml:space="preserve">
          <source>It is possible that a newly created QGeoCodeReply may be in a finished state, most commonly because an error has occurred. Since such an instance will never emit the &lt;a href=&quot;qgeocodereply#finished&quot;&gt;finished&lt;/a&gt;() or error(&lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply::Error&lt;/a&gt;,&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;) signals, it is important to check the result of &lt;a href=&quot;qgeocodereply#isFinished&quot;&gt;isFinished&lt;/a&gt;() before making the connections to the signals. The documentation for &lt;a href=&quot;qgeocodingmanager&quot;&gt;QGeoCodingManager&lt;/a&gt; demonstrates how this might be carried out.</source>
          <target state="translated">새로 생성 된 QGeoCodeReply가 완료 상태 일 수 있으며, 가장 일반적으로 오류가 발생했기 때문입니다. 이러한 인스턴스는 &lt;a href=&quot;qgeocodereply#finished&quot;&gt;완료&lt;/a&gt; () 또는 오류 ( &lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply :: Error&lt;/a&gt; , &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; ) 신호를 방출하지 않으므로 신호 에 연결하기 전에 &lt;a href=&quot;qgeocodereply#isFinished&quot;&gt;isFinished&lt;/a&gt; () 의 결과를 확인하는 것이 중요합니다 . &lt;a href=&quot;qgeocodingmanager&quot;&gt;QGeoCodingManager에&lt;/a&gt; 대한 문서는 이것이 수행되는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="bb4ffd53abba8f1687d9b72588ed4d1ab53b5811" translate="yes" xml:space="preserve">
          <source>It is possible that a newly created QGeoRouteReply may be in a finished state, most commonly because an error has occurred. Since such an instance will never emit the &lt;a href=&quot;qgeoroutereply#finished&quot;&gt;finished&lt;/a&gt;() or error(&lt;a href=&quot;qgeoroutereply#Error-enum&quot;&gt;QGeoRouteReply::Error&lt;/a&gt;,&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;) signals, it is important to check the result of &lt;a href=&quot;qgeoroutereply#isFinished&quot;&gt;isFinished&lt;/a&gt;() before making the connections to the signals. The documentation for &lt;a href=&quot;qgeoroutingmanager&quot;&gt;QGeoRoutingManager&lt;/a&gt; demonstrates how this might be carried out.</source>
          <target state="translated">새로 생성 된 QGeoRouteReply가 완료 상태 일 수 있으며, 가장 일반적으로 오류가 발생했기 때문입니다. 이러한 인스턴스는 &lt;a href=&quot;qgeoroutereply#finished&quot;&gt;완료&lt;/a&gt; () 또는 오류 ( &lt;a href=&quot;qgeoroutereply#Error-enum&quot;&gt;QGeoRouteReply :: Error&lt;/a&gt; , &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; ) 신호 를 절대 방출하지 않으므로 신호 에 연결하기 전에 &lt;a href=&quot;qgeoroutereply#isFinished&quot;&gt;isFinished&lt;/a&gt; () 의 결과를 확인하는 것이 중요합니다 . &lt;a href=&quot;qgeoroutingmanager&quot;&gt;QGeoRoutingManager에&lt;/a&gt; 대한 문서는 이것이 수행되는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="507728da206e572853be7889ebeb42394d76bca8" translate="yes" xml:space="preserve">
          <source>It is possible that an included service contains yet another service. Such second level includes have to be obtained via their relevant first level &lt;a href=&quot;qlowenergyservice&quot;&gt;QLowEnergyService&lt;/a&gt; instance. Technically, this could create a circular dependency.</source>
          <target state="translated">포함 된 서비스에 또 다른 서비스가 포함되어있을 수 있습니다. 이러한 두 번째 수준은 관련 첫 번째 수준 &lt;a href=&quot;qlowenergyservice&quot;&gt;QLowEnergyService&lt;/a&gt; 인스턴스 를 통해 얻어야 합니다. 기술적으로 이것은 순환 종속성을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d065ee5c4ba894eac8a34c04e83f7dd9eb6fcd0e" translate="yes" xml:space="preserve">
          <source>It is possible that providers may only support a subset of these. See the &lt;a href=&quot;qtlocation-index#plugin-references-and-parameters&quot;&gt;plugin documentation&lt;/a&gt; for more details.</source>
          <target state="translated">공급자는 이들 중 일부만 지원할 수 있습니다. 자세한 내용은 &lt;a href=&quot;qtlocation-index#plugin-references-and-parameters&quot;&gt;플러그인 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dad59a08026da383ebafd37152286ae39d3294a9" translate="yes" xml:space="preserve">
          <source>It is possible to access elements in an array in two ways. The first is to use the array index as the property name:</source>
          <target state="translated">두 가지 방법으로 배열의 요소에 액세스 할 수 있습니다. 첫 번째는 배열 인덱스를 속성 이름으로 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="85bbadc260fbc055218e4e62503b4b8922f4d08f" translate="yes" xml:space="preserve">
          <source>It is possible to add modules to the &lt;a href=&quot;http://freetype.sourceforge.net/freetype2/index.html&quot;&gt;FreeType 2&lt;/a&gt; font engine to support other types of font files. For more information, see the font engine's own website: &lt;a href=&quot;http://freetype.sourceforge.net/freetype2/index.html&quot;&gt;http://freetype.sourceforge.net/freetype2/index.html&lt;/a&gt;.</source>
          <target state="translated">다른 유형의 글꼴 파일을 지원 하기 위해 &lt;a href=&quot;http://freetype.sourceforge.net/freetype2/index.html&quot;&gt;FreeType 2&lt;/a&gt; 글꼴 엔진에 모듈을 추가 할 수 있습니다 . 자세한 내용은 글꼴 엔진 자체 웹 사이트 ( &lt;a href=&quot;http://freetype.sourceforge.net/freetype2/index.html&quot;&gt;http://freetype.sourceforge.net/freetype2/index.html)를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="063222f7245b62b11a62e056ecc671a399e7a783" translate="yes" xml:space="preserve">
          <source>It is possible to add support for &lt;a href=&quot;qml-qtquick-controls-exclusivegroup&quot;&gt;ExclusiveGroup&lt;/a&gt; for an object or control. It should have a &lt;code&gt;checked&lt;/code&gt; property, and either a &lt;code&gt;checkedChanged&lt;/code&gt;, &lt;code&gt;toggled()&lt;/code&gt;, or &lt;code&gt;toggled(bool)&lt;/code&gt; signal. It also needs to be bound with &lt;a href=&quot;qml-qtquick-controls-exclusivegroup#bindCheckable-method&quot;&gt;ExclusiveGroup::bindCheckable()&lt;/a&gt; when its &lt;a href=&quot;qml-qtquick-controls-exclusivegroup&quot;&gt;ExclusiveGroup&lt;/a&gt; typed property is set.</source>
          <target state="translated">개체 또는 컨트롤에 대해 &lt;a href=&quot;qml-qtquick-controls-exclusivegroup&quot;&gt;ExclusiveGroup에&lt;/a&gt; 대한 지원을 추가 할 수 있습니다 . &lt;code&gt;checked&lt;/code&gt; 속성과 &lt;code&gt;checkedChanged&lt;/code&gt; , &lt;code&gt;toggled()&lt;/code&gt; 또는 &lt;code&gt;toggled(bool)&lt;/code&gt; 신호 가 있어야합니다 . 또한 &lt;a href=&quot;qml-qtquick-controls-exclusivegroup&quot;&gt;ExclusiveGroup&lt;/a&gt; 유형 속성이 설정 될 때 &lt;a href=&quot;qml-qtquick-controls-exclusivegroup#bindCheckable-method&quot;&gt;ExclusiveGroup :: bindCheckable ()&lt;/a&gt; 과 바인딩되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="182f8106b0f5ca4d2bc1366097c6177ea645915d" translate="yes" xml:space="preserve">
          <source>It is possible to add support for ExclusiveGroup for an object or control. It should have a &lt;code&gt;checked&lt;/code&gt; property, and either a &lt;code&gt;checkedChanged&lt;/code&gt;, &lt;code&gt;toggled()&lt;/code&gt;, or &lt;code&gt;toggled(bool)&lt;/code&gt; signal. It also needs to be bound with &lt;a href=&quot;qml-qtquick-controls-exclusivegroup#bindCheckable-method&quot;&gt;ExclusiveGroup::bindCheckable()&lt;/a&gt; when its ExclusiveGroup typed property is set.</source>
          <target state="translated">개체 또는 컨트롤에 대한 ExclusiveGroup 지원을 추가 할 수 있습니다. &lt;code&gt;checked&lt;/code&gt; 속성과 &lt;code&gt;checkedChanged&lt;/code&gt; , &lt;code&gt;toggled()&lt;/code&gt; 또는 &lt;code&gt;toggled(bool)&lt;/code&gt; 신호 가 있어야합니다 . 또한 ExclusiveGroup 유형 속성이 설정 될 때 &lt;a href=&quot;qml-qtquick-controls-exclusivegroup#bindCheckable-method&quot;&gt;ExclusiveGroup :: bindCheckable ()&lt;/a&gt; 로 바인드되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="2ca39ac0075b0065c052fd44a2e070e562b70c2f" translate="yes" xml:space="preserve">
          <source>It is possible to apply an effect on a layer at runtime using layer.effect:</source>
          <target state="translated">layer.effect를 사용하여 런타임에 레이어에 효과를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb9ebeb9c71f6448277c0b246056bbd498b7ce56" translate="yes" xml:space="preserve">
          <source>It is possible to call the grabWindow() function when the window is not visible. This requires that the window is &lt;a href=&quot;qwindow#create&quot;&gt;created&lt;/a&gt; and has a valid size and that no other &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; instances are rendering in the same process.</source>
          <target state="translated">창이 보이지 않을 때 grabWindow () 함수를 호출 할 수 있습니다. 이를 위해서는 윈도우가 &lt;a href=&quot;qwindow#create&quot;&gt;생성&lt;/a&gt; 되고 유효한 크기이고 다른 프로세스에서 동일한 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 인스턴스가 렌더링 되지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="f907026bc11813feef3696844e6d5ff9fa9e1679" translate="yes" xml:space="preserve">
          <source>It is possible to change the number of rows and columns in a model. In the string list model it only makes sense to change the number of rows, so we only reimplement the functions for inserting and removing rows. These are declared in the class definition:</source>
          <target state="translated">모델의 행과 열 수를 변경할 수 있습니다. 문자열 목록 모델에서는 행 수를 변경하는 것이 적합하므로 행 삽입 및 제거 기능 만 다시 구현합니다. 이들은 클래스 정의에 선언되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="493abb28ca1f3f3fd6768e37ad4e536457307aaf" translate="yes" xml:space="preserve">
          <source>It is possible to constrain the input to an editable combobox using &lt;a href=&quot;qvalidator&quot;&gt;QValidator&lt;/a&gt;; see &lt;a href=&quot;qcombobox#setValidator&quot;&gt;setValidator&lt;/a&gt;(). By default, any input is accepted.</source>
          <target state="translated">&lt;a href=&quot;qvalidator&quot;&gt;QValidator를&lt;/a&gt; 사용하여 입력을 편집 가능한 콤보 박스로 제한 할 수 있습니다 . &lt;a href=&quot;qcombobox#setValidator&quot;&gt;setValidator&lt;/a&gt; ()를 참조하십시오 . 기본적으로 모든 입력이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3e8835a269cbced2162831de5adaca57199fba7a" translate="yes" xml:space="preserve">
          <source>It is possible to create an instance of &lt;a href=&quot;qml-qtquick-controls2-scrollbar&quot;&gt;ScrollBar&lt;/a&gt; without using the attached property API. This is useful when the behavior of the attached scroll bar is not sufficient or a &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; is not in use. In the following example, horizontal and vertical scroll bars are used to scroll over the text without using &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt;:</source>
          <target state="translated">연결된 속성 API를 사용하지 않고 &lt;a href=&quot;qml-qtquick-controls2-scrollbar&quot;&gt;ScrollBar&lt;/a&gt; 인스턴스를 만들 수 있습니다 . 연결된 스크롤 막대의 동작이 충분하지 않거나 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; 을 사용하지 않는 경우에 유용합니다. 다음 예제에서는 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; 을 사용하지 않고 가로 및 세로 스크롤 막대를 사용하여 텍스트를 스크롤합니다 .</target>
        </trans-unit>
        <trans-unit id="80dabfd5d1d51a87ed7232851ffab1471df45bf1" translate="yes" xml:space="preserve">
          <source>It is possible to create an instance of &lt;a href=&quot;qml-qtquick-controls2-scrollindicator&quot;&gt;ScrollIndicator&lt;/a&gt; without using the attached property API. This is useful when the behavior of the attached scoll indicator is not sufficient or a &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; is not in use. In the following example, horizontal and vertical scroll indicators are used to indicate how far the user has scrolled over the text (using &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; instead of &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt;):</source>
          <target state="translated">연결된 속성 API를 사용하지 않고 &lt;a href=&quot;qml-qtquick-controls2-scrollindicator&quot;&gt;ScrollIndicator&lt;/a&gt; 인스턴스를 만들 수 있습니다 . 연결된 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;scoll&lt;/a&gt; 표시기의 동작이 충분하지 않거나 Flickable 을 사용하지 않을 때 유용 합니다. 다음 예제에서 가로 및 세로 스크롤 표시기는 사용자가 텍스트를 스크롤 한 거리를 나타내는 데 사용됩니다 ( &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;Flickable&lt;/a&gt; 대신 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;MouseArea 사용&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="af02d26c2adf77d87d583a2a890a5753d98dbe90" translate="yes" xml:space="preserve">
          <source>It is possible to create an instance of ScrollBar without using the attached property API. This is useful when the behavior of the attached scroll bar is not sufficient or a &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; is not in use. In the following example, horizontal and vertical scroll bars are used to scroll over the text without using &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt;:</source>
          <target state="translated">첨부 된 속성 API를 사용하지 않고 ScrollBar의 인스턴스를 생성 할 수 있습니다. 이것은 연결된 스크롤 막대의 동작이 충분하지 않거나 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; 이 사용되지 않을 때 유용 합니다. 다음 예제에서 가로 및 세로 스크롤 막대는 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; 을 사용하지 않고 텍스트를 스크롤하는 데 사용 됩니다 .</target>
        </trans-unit>
        <trans-unit id="c9a905697b45311c189e11c31de16a9c5a4df91e" translate="yes" xml:space="preserve">
          <source>It is possible to create an instance of ScrollIndicator without using the attached property API. This is useful when the behavior of the attached scoll indicator is not sufficient or a &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; is not in use. In the following example, horizontal and vertical scroll indicators are used to indicate how far the user has scrolled over the text (using &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; instead of &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt;):</source>
          <target state="translated">첨부 된 속성 API를 사용하지 않고도 ScrollIndicator의 인스턴스를 생성 할 수 있습니다. 이것은 첨부 된 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;scoll&lt;/a&gt; 표시기의 동작이 충분하지 않거나 Flickable 이 사용되지 않을 때 유용 합니다. 다음 예제에서는 가로 및 세로 스크롤 표시기를 사용하여 사용자가 텍스트 위로 스크롤 한 거리를 나타냅니다 ( &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;Flickable&lt;/a&gt; 대신 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;MouseArea 사용&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d0fd84a36335858392ae626e0427aaaca69e5ad8" translate="yes" xml:space="preserve">
          <source>It is possible to create each side of the &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; and call &lt;a href=&quot;qremoteobjectnode#addClientSideConnection&quot;&gt;QRemoteObjectNode::addClientSideConnection&lt;/a&gt;(QIODevice *ioDevice) and &lt;a href=&quot;qremoteobjecthostbase#addHostSideConnection&quot;&gt;QRemoteObjectHostBase::addHostSideConnection&lt;/a&gt;(QIODevice *ioDevice) as shown above. This is fully supported, but requires the client know how to establish the connection or have a way to discover that information. This is exactly the problem the registry was designed to solve.</source>
          <target state="translated">양쪽 만들 수 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; 및 통화 &lt;a href=&quot;qremoteobjectnode#addClientSideConnection&quot;&gt;QRemoteObjectNode :: addClientSideConnection&lt;/a&gt; (QIODevice ioDevice *) 및 &lt;a href=&quot;qremoteobjecthostbase#addHostSideConnection&quot;&gt;QRemoteObjectHostBase :: addHostSideConnection&lt;/a&gt; 위와 같이 (QIODevice * ioDevice 참조). 이것은 완전히 지원되지만 클라이언트가 연결을 설정하거나 해당 정보를 발견 할 수있는 방법을 알아야합니다. 이것은 레지스트리가 해결하도록 설계된 정확한 문제입니다.</target>
        </trans-unit>
        <trans-unit id="7c9ecfb67d93783492d60bb1323bd04f997cf24b" translate="yes" xml:space="preserve">
          <source>It is possible to customize qmake to support new compilers and preprocessors:</source>
          <target state="translated">새로운 컴파일러 및 전처리기를 지원하도록 qmake를 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08fb5c95d90a802fe13bbdc07f8c64df4e48aa12" translate="yes" xml:space="preserve">
          <source>It is possible to customize the names of the build targets depending on the target platform. For example, a library or plugin may be named using a different convention on Windows from the one used on Unix platforms:</source>
          <target state="translated">대상 플랫폼에 따라 빌드 대상의 이름을 사용자 정의 할 수 있습니다. 예를 들어, 라이브러리 또는 플러그인은 Windows에서 Unix 플랫폼에서 사용되는 것과 다른 규칙을 사용하여 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b40433af5fc4b0ec6d03815420ece79d42778910" translate="yes" xml:space="preserve">
          <source>It is possible to defer the decision of rejecting a certificate by calling &lt;a href=&quot;qml-qtwebengine-webenginecertificateerror#defer-method&quot;&gt;defer&lt;/a&gt;, which is useful when waiting for user input.</source>
          <target state="translated">defer를 호출하여 인증서 거부 결정을 &lt;a href=&quot;qml-qtwebengine-webenginecertificateerror#defer-method&quot;&gt;연기 할 수&lt;/a&gt; 있으며 이는 사용자 입력을 기다릴 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="850d247396a6a7df8768d301045642e77662f3f1" translate="yes" xml:space="preserve">
          <source>It is possible to define dependencies using either variable. Qt documentation only uses the &lt;code&gt;depends&lt;/code&gt; variable.</source>
          <target state="translated">두 변수 중 하나를 사용하여 종속성을 정의 할 수 있습니다. Qt 문서는 &lt;code&gt;depends&lt;/code&gt; 변수 만 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="3ef6937bbd477020adb4fba7786bc920609d299d" translate="yes" xml:space="preserve">
          <source>It is possible to define your own functions to provide conditions for scopes. The following example tests whether each file in a list exists and returns true if they all exist, or false if not:</source>
          <target state="translated">범위에 대한 조건을 제공하기 위해 고유 한 기능을 정의 할 수 있습니다. 다음 예제는 목록의 각 파일이 존재하는지 테스트하고 파일이 모두 존재하면 true를, 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="25828a143424d42054836f214555faa30d4e5704" translate="yes" xml:space="preserve">
          <source>It is possible to draw into a &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject&lt;/a&gt; using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; and &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt; in a separate thread.</source>
          <target state="translated">별도의 스레드에서 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 및 &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt; 를 사용하여 &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject&lt;/a&gt; 에 그릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30ba04dc3070f4f267d2288098c3e219f716a4d3" translate="yes" xml:space="preserve">
          <source>It is possible to draw into a QOpenGLFramebufferObject using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; and &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt; in a separate thread.</source>
          <target state="translated">별도의 스레드에서 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 및 &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt; 를 사용하여 QOpenGLFramebufferObject에 그릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9eea90551f075fa99ff39ad3674fc2173a79a46a" translate="yes" xml:space="preserve">
          <source>It is possible to dynamically generate menu items. One of the easiest ways to do so is with &lt;a href=&quot;qml-qtqml-instantiator&quot;&gt;Instantiator&lt;/a&gt;. For example, to implement a &quot;Recent Files&quot; submenu, where the items are based on a list of files stored in settings, the following code could be used:</source>
          <target state="translated">메뉴 항목을 동적으로 생성 할 수 있습니다. 가장 쉬운 방법 중 하나는 &lt;a href=&quot;qml-qtqml-instantiator&quot;&gt;Instantiator를 사용하는 것&lt;/a&gt; 입니다. 예를 들어 항목이 설정에 저장된 파일 목록을 기반으로하는 &quot;최근 파일&quot;하위 메뉴를 구현하려면 다음 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c3dabea509529360924b9ae97e8fa1bc32e5731" translate="yes" xml:space="preserve">
          <source>It is possible to dynamically generate menu items. One of the easiest ways to do so is with Instantiator. For example, to implement a &quot;Recent Files&quot; submenu, where the items are based on a list of files stored in settings, the following code could be used:</source>
          <target state="translated">메뉴 항목을 동적으로 생성 할 수 있습니다. 가장 쉬운 방법 중 하나는 Instantiator를 사용하는 것입니다. 예를 들어, 항목이 설정에 저장된 파일 목록을 기반으로하는 &quot;최근 파일&quot;하위 메뉴를 구현하려면 다음 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cab799898968dec0f46b6f87df3fc98718d7ee36" translate="yes" xml:space="preserve">
          <source>It is possible to enable or disable messages by selecting them by:</source>
          <target state="translated">다음을 통해 메시지를 선택하여 메시지를 활성화 또는 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf553d302c62ff4e7ba922a9de75c5c89cbec83d" translate="yes" xml:space="preserve">
          <source>It is possible to export meshes, lights, cameras, transform animations (scale/rotation/location), UV layouts, pivot points, object hierarchy, and material slots from Blender.</source>
          <target state="translated">블렌더에서 메시, 조명, 카메라, 변형 애니메이션 (스케일 / 회전 / 위치), UV 레이아웃, 피벗 포인트, 오브젝트 계층 및 재질 슬롯을 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eab9cc30f5f5f096f755d4e246c08d41b7209e5e" translate="yes" xml:space="preserve">
          <source>It is possible to filter the relations by using</source>
          <target state="translated">를 사용하여 관계를 필터링 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="3bbde10ca12a948e56a300407872e5984458b404" translate="yes" xml:space="preserve">
          <source>It is possible to get the pattern options currently set on a &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; object by using the &lt;a href=&quot;qregularexpression#patternOptions&quot;&gt;patternOptions&lt;/a&gt;() function:</source>
          <target state="translated">&lt;a href=&quot;qregularexpression#patternOptions&quot;&gt;patternOptions&lt;/a&gt; () 함수를 사용하여 &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; 객체에 현재 설정된 패턴 옵션을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="510ff62f27f940a03f584421d2d8a8cdeae63ecd" translate="yes" xml:space="preserve">
          <source>It is possible to get the pattern options currently set on a QRegularExpression object by using the &lt;a href=&quot;qregularexpression#patternOptions&quot;&gt;patternOptions&lt;/a&gt;() function:</source>
          <target state="translated">&lt;a href=&quot;qregularexpression#patternOptions&quot;&gt;patternOptions&lt;/a&gt; () 함수를 사용하여 QRegularExpression 객체에 현재 설정된 패턴 옵션을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83a3cbf7b2c6b49c35412b9ffba58fd375fa7d83" translate="yes" xml:space="preserve">
          <source>It is possible to give the view hints about the data it is handling in order to improve its performance when displaying large numbers of items. One approach that can be taken for views that are intended to display items with equal heights is to set the &lt;a href=&quot;qtreeview#uniformRowHeights-prop&quot;&gt;uniformRowHeights&lt;/a&gt; property to true.</source>
          <target state="translated">많은 수의 항목을 표시 할 때 성능을 향상시키기 위해 처리중인 데이터에 대한보기 힌트를 제공 할 수 있습니다. 높이가 동일한 항목을 표시하려는 뷰에 대해 수행 할 수있는 한 가지 방법은 &lt;a href=&quot;qtreeview#uniformRowHeights-prop&quot;&gt;uniformRowHeights&lt;/a&gt; 속성을 true 로 설정하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e5619fd65b7b52c3be98938941f5639f7ce4424a" translate="yes" xml:space="preserve">
          <source>It is possible to give the view hints about the data it is handling in order to improve its performance when displaying large numbers of items. One approach that can be taken for views that are intended to display items with equal sizes is to set the &lt;a href=&quot;qlistview#uniformItemSizes-prop&quot;&gt;uniformItemSizes&lt;/a&gt; property to true.</source>
          <target state="translated">많은 수의 항목을 표시 할 때 성능을 향상시키기 위해 처리중인 데이터에 대한보기 힌트를 제공 할 수 있습니다. 크기가 같은 항목을 표시하려는 뷰에 대해 수행 할 수있는 한 가지 방법은 &lt;a href=&quot;qlistview#uniformItemSizes-prop&quot;&gt;uniformItemSizes&lt;/a&gt; 속성을 true 로 설정하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e234f92b8c4fe733f641be93a3268d1838fa8965" translate="yes" xml:space="preserve">
          <source>It is possible to have multiple items which individually receive mouse and touch events. For example, to have two actions in the &lt;code&gt;swipe.right&lt;/code&gt; item, use the following code:</source>
          <target state="translated">마우스 및 터치 이벤트를 개별적으로받는 여러 항목을 가질 수 있습니다. 예를 들어 &lt;code&gt;swipe.right&lt;/code&gt; 항목 에 두 가지 작업을 수행 하려면 다음 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="21f041a7d59578aee510c40252df6352b0d21268" translate="yes" xml:space="preserve">
          <source>It is possible to implement interfaces by inheriting &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt; and implementing its pure virtual functions. In practice, however, it is usually preferable to inherit &lt;a href=&quot;qaccessibleobject&quot;&gt;QAccessibleObject&lt;/a&gt; or &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;, which implement part of the functionality for you. In the next section, we will see an example of implementing accessibility for a widget by inheriting the &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt; class.</source>
          <target state="translated">&lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt; 를 상속 하고 순수한 가상 함수를 구현하여 인터페이스를 구현할 수 있습니다. 그러나 실제로는 일반적으로 기능의 일부를 구현하는 &lt;a href=&quot;qaccessibleobject&quot;&gt;QAccessibleObject&lt;/a&gt; 또는 &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt; 을 상속하는 것이 좋습니다. 다음 섹션에서는 &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt; 클래스 를 상속하여 위젯에 대한 액세스 가능성을 구현하는 예를 보여 줍니다 .</target>
        </trans-unit>
        <trans-unit id="40f9f33cce8b29087a5db311299edc647cbae5b0" translate="yes" xml:space="preserve">
          <source>It is possible to insert a node from another document into the document using &lt;a href=&quot;qdomdocument#importNode&quot;&gt;importNode&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qdomdocument#importNode&quot;&gt;importNode&lt;/a&gt; ()를 사용하여 다른 문서에서 문서로 노드를 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="558faa704cc1093f2281c355d610b59a4c1649b3" translate="yes" xml:space="preserve">
          <source>It is possible to keep &lt;a href=&quot;qml-qtquick-controls2-scrollbar#binding-the-active-state-of-horizontal-and-vertical-scroll-bars&quot;&gt;both horizontal and vertical bars visible&lt;/a&gt; while scrolling in either direction.</source>
          <target state="translated">또한 유지할 수있다 &lt;a href=&quot;qml-qtquick-controls2-scrollbar#binding-the-active-state-of-horizontal-and-vertical-scroll-bars&quot;&gt;볼 모두 수평 및 수직 막대를&lt;/a&gt; 어느 방향으로 스크롤하는 동안.</target>
        </trans-unit>
        <trans-unit id="d447f4c6cf004298c362e8f59038d8787f585ecb" translate="yes" xml:space="preserve">
          <source>It is possible to keep &lt;a href=&quot;qml-qtquick-controls2-scrollindicator#binding-the-active-state-of-horizontal-and-vertical-scroll-indicators&quot;&gt;both horizontal and vertical indicators visible&lt;/a&gt; while scrolling in either direction.</source>
          <target state="translated">또한 유지할 수있다 &lt;a href=&quot;qml-qtquick-controls2-scrollindicator#binding-the-active-state-of-horizontal-and-vertical-scroll-indicators&quot;&gt;볼 상하 좌우 지표를&lt;/a&gt; 어느 방향으로 스크롤하는 동안.</target>
        </trans-unit>
        <trans-unit id="6ce60bbeffd22deb48dd97e09a931b57b9e3a3f5" translate="yes" xml:space="preserve">
          <source>It is possible to load animations from an arbitrary offset, but they will still follow the same pattern. Consider now the red numbers. If we specify that the animation begins at pixel location 120,0, with a frame count of 5 and the same frame size as before, then it will load the frames as they are numbered in red. The first 120x40 of the image will not be used, as it starts reading 40x40 blocks from the location of 120,0. When it reaches the end of the file at 160,0, it then starts to read the next row from 0,40.</source>
          <target state="translated">임의의 오프셋에서 애니메이션을로드 할 수 있지만 여전히 동일한 패턴을 따릅니다. 이제 빨간 숫자를 고려하십시오. 애니메이션이 픽셀 위치 120,0에서 시작하고 프레임 카운트가 5이고 이전과 동일한 프레임 크기를 지정하면 빨간색으로 번호가 매겨진 프레임이로드됩니다. 120,0의 위치에서 40x40 블록을 읽기 시작하므로 이미지의 첫 120x40은 사용되지 않습니다. 160,0에서 파일 끝에 도달하면 0,40에서 다음 행을 읽기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1863f7ea3766a69b11f135f5e18bbe93b4ddc48b" translate="yes" xml:space="preserve">
          <source>It is possible to look up a translation using &lt;a href=&quot;qtranslator#translate&quot;&gt;translate&lt;/a&gt;() (as &lt;a href=&quot;qobject#tr&quot;&gt;tr&lt;/a&gt;() and &lt;a href=&quot;qcoreapplication#translate&quot;&gt;QCoreApplication::translate&lt;/a&gt;() do). The &lt;a href=&quot;qtranslator#translate&quot;&gt;translate&lt;/a&gt;() function takes up to three parameters:</source>
          <target state="translated">&lt;a href=&quot;qtranslator#translate&quot;&gt;translate&lt;/a&gt; ()를 사용하여 번역 을 조회 할 수 있습니다 ( &lt;a href=&quot;qobject#tr&quot;&gt;tr&lt;/a&gt; () 및 &lt;a href=&quot;qcoreapplication#translate&quot;&gt;QCoreApplication :: translate&lt;/a&gt; () do). &lt;a href=&quot;qtranslator#translate&quot;&gt;번역&lt;/a&gt; () 함수는 세 개의 매개 변수를 취합니다</target>
        </trans-unit>
        <trans-unit id="4b648e475417c034c8bc8c53fc402bbe09651006" translate="yes" xml:space="preserve">
          <source>It is possible to make the item editable by setting the &lt;a href=&quot;qt#TextInteractionFlag-enum&quot;&gt;Qt::TextEditorInteraction&lt;/a&gt; flag using &lt;a href=&quot;qgraphicstextitem#setTextInteractionFlags&quot;&gt;setTextInteractionFlags&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qgraphicstextitem#setTextInteractionFlags&quot;&gt;setTextInteractionFlags&lt;/a&gt; ()를 사용하여 &lt;a href=&quot;qt#TextInteractionFlag-enum&quot;&gt;Qt :: TextEditorInteraction&lt;/a&gt; 플래그를 설정하여 항목을 편집 가능하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="315ce8d478a67fc413bec1c25b3bf0125af7076c" translate="yes" xml:space="preserve">
          <source>It is possible to mix and match service providers for the various domains, so that a geocoding manager from one service provider can be used with a geographic routing manager from another service provider.</source>
          <target state="translated">여러 도메인의 서비스 제공 업체를 혼합하여 일치시킬 수 있으므로 한 서비스 제공 업체의 지오 코딩 관리자를 다른 서비스 제공 업체의 지리적 라우팅 관리자와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="284ab1b869c730f4bbafe9b24cd3a9e64e4aec5d" translate="yes" xml:space="preserve">
          <source>It is possible to modify elements in an array in two ways. The first is to use the array index as the property name:</source>
          <target state="translated">두 가지 방법으로 배열의 요소를 수정할 수 있습니다. 첫 번째는 배열 인덱스를 속성 이름으로 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="42c2e97fa640360aaaa7704434b4fe5d49aa9e00" translate="yes" xml:space="preserve">
          <source>It is possible to modify this default behavior of &lt;code&gt;SUBDIRS&lt;/code&gt; by giving additional modifiers to &lt;code&gt;SUBDIRS&lt;/code&gt; elements. Supported modifiers are:</source>
          <target state="translated">&lt;code&gt;SUBDIRS&lt;/code&gt; 요소에 추가 수정자를 제공하여 &lt;code&gt;SUBDIRS&lt;/code&gt; 의이 기본 동작을 수정할 수 있습니다 . 지원되는 수정자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c0e34d812d6eea1b3767dc849420d74899731bf1" translate="yes" xml:space="preserve">
          <source>It is possible to nest calls to beginEditBlock and &lt;a href=&quot;qtextcursor#endEditBlock&quot;&gt;endEditBlock&lt;/a&gt;. The top-most pair will determine the scope of the undo/redo operation.</source>
          <target state="translated">beginEditBlock 및 &lt;a href=&quot;qtextcursor#endEditBlock&quot;&gt;endEditBlock&lt;/a&gt; 호출을 중첩시킬 수 있습니다 . 최상위 쌍은 실행 취소 / 다시 실행 작업의 범위를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="eaee15700bf298d17fe2c27b81e51d1715c040f6" translate="yes" xml:space="preserve">
          <source>It is possible to pass a starting offset and one or more match options to the &lt;a href=&quot;qregularexpression#globalMatch&quot;&gt;globalMatch&lt;/a&gt;() function, exactly like normal matching with &lt;a href=&quot;qregularexpression#match&quot;&gt;match&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qregularexpression#match&quot;&gt;match&lt;/a&gt; () 와 정확히 일치하는 것처럼 시작 오프셋과 하나 이상의 일치 옵션을 &lt;a href=&quot;qregularexpression#globalMatch&quot;&gt;globalMatch&lt;/a&gt; () 함수에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b66926ec47f7813837a6daa23e74d5564d5d2c67" translate="yes" xml:space="preserve">
          <source>It is possible to print some information to the debug output by enabling the &lt;code&gt;qt.qpa.input&lt;/code&gt; logging rule, for example by setting the &lt;code&gt;QT_LOGGING_RULES&lt;/code&gt; environment variable to &lt;code&gt;qt.qpa.input=true&lt;/code&gt;. This is useful for detecting which device is being used, or to troubleshoot device discovery issues.</source>
          <target state="translated">&lt;code&gt;qt.qpa.input&lt;/code&gt; 로깅 규칙을 사용하여 (예 : &lt;code&gt;QT_LOGGING_RULES&lt;/code&gt; 환경 변수를 &lt;code&gt;qt.qpa.input=true&lt;/code&gt; 로 설정하여) 일부 정보를 디버그 출력에 인쇄 할 수 있습니다 . 사용중인 장치를 감지하거나 장치 검색 문제를 해결하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="63edcc1f21a614363da265cdea51a3d6a229a8e4" translate="yes" xml:space="preserve">
          <source>It is possible to provide a JSON-format configuration file specifying which OpenGL implementation to use depending on the graphics card and driver version. The location is given by the environment variable &lt;code&gt;QT_OPENGL_BUGLIST&lt;/code&gt;. Relative paths are resolved using &lt;code&gt;QLibraryInfo::SettingsPath&lt;/code&gt; or &lt;code&gt;QStandardPaths::ConfigLocation&lt;/code&gt;. The file utilizes the format of the driver bug list used in &lt;a href=&quot;http://www.chromium.org/Home&quot;&gt;The Chromium Projects&lt;/a&gt;. It consists of a list of entries each of which specifies a set of conditions and a list of feature keywords. Typically, device id and vendor id are used to match a specific graphics card. They can be found in the output of the &lt;code&gt;qtdiag&lt;/code&gt; or &lt;code&gt;dxdiag&lt;/code&gt; tool.</source>
          <target state="translated">그래픽 카드 및 드라이버 버전에 따라 사용할 OpenGL 구현을 지정하는 JSON 형식 구성 파일을 제공 할 수 있습니다. 위치는 환경 변수 &lt;code&gt;QT_OPENGL_BUGLIST&lt;/code&gt; 에 의해 제공됩니다 . 상대 경로를 사용하여 해결 &lt;code&gt;QLibraryInfo::SettingsPath&lt;/code&gt; 또는 &lt;code&gt;QStandardPaths::ConfigLocation&lt;/code&gt; . 이 파일은 &lt;a href=&quot;http://www.chromium.org/Home&quot;&gt;Chromium 프로젝트에&lt;/a&gt; 사용 된 드라이버 버그 목록의 형식을 사용합니다 . 이는 각각 조건 세트와 기능 키워드 목록을 지정하는 항목 목록으로 구성됩니다. 일반적으로 장치 ID와 공급 업체 ID는 특정 그래픽 카드를 일치시키는 데 사용됩니다. &lt;code&gt;qtdiag&lt;/code&gt; 또는 &lt;code&gt;dxdiag&lt;/code&gt; 도구 의 출력에서 ​​찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb035718de3f546b101a1bab19524ac4084d9838" translate="yes" xml:space="preserve">
          <source>It is possible to provide high resolution versions of images should a scaling between</source>
          <target state="translated">이미지 사이의 배율을 조정하면 고해상도 버전의 이미지를 제공 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6633af5c997fb06b9dbeb56eec601ae68450b470" translate="yes" xml:space="preserve">
          <source>It is possible to recursively generate &lt;code&gt;.vcproj&lt;/code&gt; files in subdirectories and a &lt;code&gt;.sln&lt;/code&gt; file in the main directory, by typing:</source>
          <target state="translated">다음 을 입력하여 서브 디렉토리에서 &lt;code&gt;.vcproj&lt;/code&gt; 파일과 기본 디렉토리에서 &lt;code&gt;.sln&lt;/code&gt; 파일 을 재귀 적으로 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fffc49bccdceb851739293dca6d6af0357b4db26" translate="yes" xml:space="preserve">
          <source>It is possible to reduce the number of entries returned by &lt;a href=&quot;qdir#entryList&quot;&gt;entryList&lt;/a&gt;() and &lt;a href=&quot;qdir#entryInfoList&quot;&gt;entryInfoList&lt;/a&gt;() by applying filters to a &lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; object. You can apply a name filter to specify a pattern with wildcards that file names need to match, an attribute filter that selects properties of entries and can distinguish between files and directories, and a sort order.</source>
          <target state="translated">&lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; 오브젝트에 필터를 적용 하여 &lt;a href=&quot;qdir#entryList&quot;&gt;entryList&lt;/a&gt; () 및 &lt;a href=&quot;qdir#entryInfoList&quot;&gt;entryInfoList&lt;/a&gt; ()에 의해 리턴되는 항목 수를 줄일 수 있습니다. 이름 필터를 적용하여 파일 이름이 일치해야하는 와일드 카드, 항목의 속성을 선택하고 파일과 디렉토리를 구분할 수있는 속성 필터 및 정렬 순서로 패턴을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0ae1750034f22f8b8ee35ddf32576e742239639" translate="yes" xml:space="preserve">
          <source>It is possible to reduce the number of entries returned by &lt;a href=&quot;qdir#entryList&quot;&gt;entryList&lt;/a&gt;() and &lt;a href=&quot;qdir#entryInfoList&quot;&gt;entryInfoList&lt;/a&gt;() by applying filters to a QDir object. You can apply a name filter to specify a pattern with wildcards that file names need to match, an attribute filter that selects properties of entries and can distinguish between files and directories, and a sort order.</source>
          <target state="translated">QDir 객체에 필터를 적용 하여 &lt;a href=&quot;qdir#entryList&quot;&gt;entryList&lt;/a&gt; () 및 &lt;a href=&quot;qdir#entryInfoList&quot;&gt;entryInfoList&lt;/a&gt; ()에 의해 반환되는 항목 수를 줄일 수 있습니다. 이름 필터를 적용하여 파일 이름이 일치해야하는 와일드 카드, 항목의 속성을 선택하고 파일과 디렉터리를 구분할 수있는 속성 필터 및 정렬 순서를 사용하여 패턴을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54b91412914df51d9fba78e81327cbf979c92621" translate="yes" xml:space="preserve">
          <source>It is possible to repeat or reflect the gradient outside its area by specifiying the &lt;a href=&quot;qgradient#Spread-enum&quot;&gt;spread method&lt;/a&gt; using the &lt;a href=&quot;qgradient#setSpread&quot;&gt;setSpread&lt;/a&gt;() function. The default is to pad the outside area with the color at the closest stop point. The currently set &lt;a href=&quot;qgradient#Spread-enum&quot;&gt;spread method&lt;/a&gt; can be retrieved using the &lt;a href=&quot;qgradient#spread&quot;&gt;spread&lt;/a&gt;() function. The &lt;a href=&quot;qgradient#Spread-enum&quot;&gt;QGradient::Spread&lt;/a&gt; enum defines three different methods:</source>
          <target state="translated">&lt;a href=&quot;qgradient#setSpread&quot;&gt;setSpread&lt;/a&gt; () 함수를 사용하여 &lt;a href=&quot;qgradient#Spread-enum&quot;&gt;스프레드 방법&lt;/a&gt; 을 지정하여 영역 외부의 그래디언트를 반복하거나 반영 할 수 있습니다 . 기본값은 가장 가까운 정지 점에서 색상으로 외부 영역을 채우는 것입니다. &lt;a href=&quot;qgradient#spread&quot;&gt;spread&lt;/a&gt; () 함수를 사용하여 현재 설정된 &lt;a href=&quot;qgradient#Spread-enum&quot;&gt;스프레드 방법&lt;/a&gt; 을 검색 할 수 있습니다 . &lt;a href=&quot;qgradient#Spread-enum&quot;&gt;QGradient :: 확산&lt;/a&gt; 열거 세 가지 방법을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="1c8602a7cf1778ac70c8617865e642dadce6ab15" translate="yes" xml:space="preserve">
          <source>It is possible to request a functions object for a different version and profile than that for which the context was created. To do this either use the template version of this function specifying the desired functions object type as the template parameter or by passing in a &lt;a href=&quot;qopenglversionprofile&quot;&gt;QOpenGLVersionProfile&lt;/a&gt; object as an argument to the non-template function.</source>
          <target state="translated">컨텍스트가 작성된 것과 다른 버전 및 프로파일에 대해 함수 오브젝트를 요청할 수 있습니다. 이를 수행하려면 원하는 함수 오브젝트 유형을 템플리트 매개 변수로 지정하거나 &lt;a href=&quot;qopenglversionprofile&quot;&gt;QOpenGLVersionProfile&lt;/a&gt; 오브젝트를 템플리트가 아닌 함수의 인수로 전달하여이 함수의 템플리트 버전을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="35d980ce985de291287a972c73847c777f7f36b2" translate="yes" xml:space="preserve">
          <source>It is possible to reserve a margin area around the viewport, see &lt;a href=&quot;qabstractscrollarea#setViewportMargins&quot;&gt;setViewportMargins&lt;/a&gt;(). The feature is mostly used to place a &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; widget above or beside the scrolling area. Subclasses of &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; should implement margins.</source>
          <target state="translated">뷰포트 주위에 여백 영역을 예약 할 수 있습니다 . &lt;a href=&quot;qabstractscrollarea#setViewportMargins&quot;&gt;setViewportMargins&lt;/a&gt; ()를 참조하십시오 . 이 기능은 주로 스크롤 영역 위 또는 옆에 &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; 위젯 을 배치하는 데 사용됩니다 . &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea의&lt;/a&gt; 서브 클래스는 마진을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="7dc797f881085d2cf16eb8f26a2cdb95b916b785" translate="yes" xml:space="preserve">
          <source>It is possible to reserve a margin area around the viewport, see &lt;a href=&quot;qabstractscrollarea#setViewportMargins&quot;&gt;setViewportMargins&lt;/a&gt;(). The feature is mostly used to place a &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; widget above or beside the scrolling area. Subclasses of QAbstractScrollArea should implement margins.</source>
          <target state="translated">뷰포트 주변에 여백 영역을 예약 할 수 있습니다 . &lt;a href=&quot;qabstractscrollarea#setViewportMargins&quot;&gt;setViewportMargins&lt;/a&gt; ()를 참조하십시오 . 이 기능은 주로 스크롤 영역 위나 옆에 &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; 위젯 을 배치하는 데 사용됩니다 . QAbstractScrollArea의 서브 클래스는 여백을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="6426f19b666d01b41794ebe8132f71f9930a0e3a" translate="yes" xml:space="preserve">
          <source>It is possible to set an item delegate to support custom widgets. By default, a &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; is used to synchronize the model with the widgets.</source>
          <target state="translated">사용자 정의 위젯을 지원하도록 항목 대리자를 설정할 수 있습니다. 기본적으로 &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; 는 모델을 위젯과 동기화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="75e63a8576a859732fc8e6ed8a6f2c4e4da7012c" translate="yes" xml:space="preserve">
          <source>It is possible to set filters using &lt;a href=&quot;qsqltablemodel#setFilter&quot;&gt;setFilter&lt;/a&gt;(), or modify the sort order using &lt;a href=&quot;qsqltablemodel#setSort&quot;&gt;setSort&lt;/a&gt;(). At the end, you must call &lt;a href=&quot;qsqltablemodel#select&quot;&gt;select&lt;/a&gt;() to populate the model with data.</source>
          <target state="translated">&lt;a href=&quot;qsqltablemodel#setFilter&quot;&gt;setFilter&lt;/a&gt; ()를 사용하여 필터를 설정 하거나 &lt;a href=&quot;qsqltablemodel#setSort&quot;&gt;setSort&lt;/a&gt; ()를 사용하여 정렬 순서를 수정할 수 있습니다. 마지막으로 &lt;a href=&quot;qsqltablemodel#select&quot;&gt;select&lt;/a&gt; ()를 호출 하여 모델로 데이터를 채워야합니다.</target>
        </trans-unit>
        <trans-unit id="9b0991f502bfd33bc935f0420ebe469866dd0415" translate="yes" xml:space="preserve">
          <source>It is possible to set the height of characters shown on the screen to a specified number of pixels with &lt;a href=&quot;qfont#setPixelSize&quot;&gt;setPixelSize&lt;/a&gt;(); however using &lt;a href=&quot;qfont#setPointSize&quot;&gt;setPointSize&lt;/a&gt;() has a similar effect and provides device independence.</source>
          <target state="translated">&lt;a href=&quot;qfont#setPixelSize&quot;&gt;setPixelSize&lt;/a&gt; () 를 사용하여 화면에 표시되는 문자 높이를 지정된 픽셀 수로 설정할 수 있습니다 . 그러나 &lt;a href=&quot;qfont#setPointSize&quot;&gt;setPointSize&lt;/a&gt; ()를 사용하면 비슷한 효과가 있으며 장치 독립성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5b120f9e45b516d6f6d8dfa7b0f6ca144ab10e9f" translate="yes" xml:space="preserve">
          <source>It is possible to specify a custom location for the configuration file with the &lt;a href=&quot;qtquickcontrols2-environment&quot;&gt;QT_QUICK_CONTROLS_CONF&lt;/a&gt; environment variable.</source>
          <target state="translated">&lt;a href=&quot;qtquickcontrols2-environment&quot;&gt;QT_QUICK_CONTROLS_CONF&lt;/a&gt; 환경 변수 를 사용하여 구성 파일의 사용자 지정 위치를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a97b9ec23c4aa079171f977f41276de2ec57cded" translate="yes" xml:space="preserve">
          <source>It is possible to specify a custom location for the configuration file with the &lt;a href=&quot;qtquickcontrols2-environment#&quot;&gt;QT_QUICK_CONTROLS_CONF&lt;/a&gt; environment variable.</source>
          <target state="translated">&lt;a href=&quot;qtquickcontrols2-environment#&quot;&gt;QT_QUICK_CONTROLS_CONF&lt;/a&gt; 환경 변수 를 사용하여 구성 파일의 사용자 정의 위치를 ​​지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4dd7a93b793e557e9a79cd04a2b29090ea9d58b8" translate="yes" xml:space="preserve">
          <source>It is possible to specify multiple index files from several projects.</source>
          <target state="translated">여러 프로젝트에서 여러 색인 파일을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f741c21b65d6cf8a3194636c17aee74105654478" translate="yes" xml:space="preserve">
          <source>It is possible to supply a source string template like:</source>
          <target state="translated">다음과 같은 소스 문자열 템플릿을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2014ffcf4ae3fd31f280b7ecedbb05458687282" translate="yes" xml:space="preserve">
          <source>It is possible to turn off compression, if desired. This can be useful if your resources already contain a compressed format, such as &lt;code&gt;.png&lt;/code&gt; files, and you do not want to incur the CPU cost at build time to confirm that it can't be compressed. Another reason is if disk usage is not a problem and the application would prefer to keep the content as clean memory pages at runtime. You do this by giving the &lt;code&gt;-no-compress&lt;/code&gt; command line argument.</source>
          <target state="translated">원하는 경우 압축을 해제 할 수 있습니다. 리소스에 &lt;code&gt;.png&lt;/code&gt; 파일 과 같은 압축 된 형식이 이미 포함되어 있고 빌드 할 때 CPU 비용이 발생하여 압축 할 수 없는지 확인하려는 경우에 유용 할 수 있습니다 . 또 다른 이유는 디스크 사용에 문제가없고 애플리케이션이 런타임시 컨텐츠를 깨끗한 메모리 페이지로 유지하는 것을 선호하기 때문입니다. &lt;code&gt;-no-compress&lt;/code&gt; 명령 행 인수 를 제공하여이를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="56c39908e2a631fd6d55afbd26e8cf3d586ca99e" translate="yes" xml:space="preserve">
          <source>It is possible to use Qt with a 3rd party signal/slot mechanism. You can even use both mechanisms in the same project. Just add the following line to your qmake project (.pro) file.</source>
          <target state="translated">타사 신호 / 슬롯 메커니즘과 함께 Qt를 사용할 수 있습니다. 동일한 프로젝트에서 두 메커니즘을 모두 사용할 수도 있습니다. qmake 프로젝트 (.pro) 파일에 다음 줄을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="5ad9880696e514c9cab8fcbfb44f2a1df0ca39ef" translate="yes" xml:space="preserve">
          <source>It is possible to use launch images (PNG files), as described below, to support the iPhone 6, but it is not recommended. Qmake generates a default LaunchScreen.xib, so it is better to use another name for a custom launch screen to avoid clashes.</source>
          <target state="translated">iPhone 6을 지원하기 위해 아래에 설명 된대로 시작 이미지 (PNG 파일)를 사용할 수 있지만 권장되지는 않습니다. Qmake는 기본 LaunchScreen.xib를 생성하므로 충돌을 피하기 위해 사용자 정의 시작 화면에 다른 이름을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="05ec2650a6df8238d9013e80572a0328325f6d88" translate="yes" xml:space="preserve">
          <source>It is preferable to use standard shortcuts where possible. When creating key sequences for non-standard shortcuts, you should use human-readable strings in preference to hard-coded integer values.</source>
          <target state="translated">가능한 경우 표준 바로 가기를 사용하는 것이 좋습니다. 비표준 바로 가기 키 시퀀스를 만들 때는 하드 코딩 된 정수 값보다 사람이 읽을 수있는 문자열을 우선적으로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa9ea897f1945c20e4afbfbc3d0fd92017690d8f" translate="yes" xml:space="preserve">
          <source>It is provided so that index overflows can be corrected when using the cache as a circular buffer.</source>
          <target state="translated">캐시를 순환 버퍼로 사용할 때 인덱스 오버 플로우를 정정 할 수 있도록 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="adbf8655f8e49caaba7f8077b52ce062b0558e88" translate="yes" xml:space="preserve">
          <source>It is recommended that all custom URL schemes are first registered with this function at application startup, even if the default options are to be used.</source>
          <target state="translated">기본 옵션을 사용하더라도 응용 프로그램을 시작할 때 모든 사용자 정의 URL 체계를이 기능으로 먼저 등록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="78c7ddc2863ed3dd8db0ef7ade2b5563865659bc" translate="yes" xml:space="preserve">
          <source>It is recommended that the delegate's size be a whole number to avoid sub-pixel alignment of items.</source>
          <target state="translated">하위 픽셀 정렬 항목을 피하기 위해 델리게이트의 크기는 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="baf83cf8c69296840d648ac4b793607b0fb7f605" translate="yes" xml:space="preserve">
          <source>It is recommended that the project file in each subdirectory has the same base name as the subdirectory itself, because that makes it possible to omit the file name. For example, if the subdirectory is called &lt;code&gt;myapp&lt;/code&gt;, the project file in that directory should be called &lt;code&gt;myapp.pro&lt;/code&gt;.</source>
          <target state="translated">각 서브 디렉토리의 프로젝트 파일은 서브 디렉토리 자체와 동일한 기본 이름을 갖는 것이 좋습니다. 파일 이름을 생략 할 수 있기 때문입니다. 예를 들어, 서브 디렉토리가 &lt;code&gt;myapp&lt;/code&gt; 인 경우 해당 디렉토리 의 프로젝트 파일은 &lt;code&gt;myapp.pro&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cc812bb9330e642f8905ff72b12eb9398211c767" translate="yes" xml:space="preserve">
          <source>It is recommended that the styles do not alter the proposed size of widgets with the &lt;a href=&quot;qstyle#sizeFromContents&quot;&gt;QStyle::sizeFromContents&lt;/a&gt;() function, but let the &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle&lt;/a&gt; implementation handle it instead. If changes need to be made, you should try to keep them small; application development may be difficult if the layout of widgets looks considerably different in the various styles.</source>
          <target state="translated">스타일은 &lt;a href=&quot;qstyle#sizeFromContents&quot;&gt;QStyle :: sizeFromContents&lt;/a&gt; () 함수를 사용 하여 제안 된 위젯 크기를 변경하지 않고 &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle&lt;/a&gt; 구현이 대신 처리하도록하는 것이 좋습니다. 변경이 필요한 경우 변경을 작게 유지해야합니다. 위젯의 레이아웃이 다양한 스타일에서 상당히 다르게 보이는 경우 응용 프로그램 개발이 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a196675e3702d63bb79a5566780549020d651ea" translate="yes" xml:space="preserve">
          <source>It is recommended that you try to avoid multiple top-level windows in the case of Android apps, as there is no traditional window system on this platform.</source>
          <target state="translated">이 플랫폼에는 전통적인 윈도우 시스템이 없으므로 Android 앱의 경우 여러 최상위 윈도우를 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="44be777eb01da3028921fd8768e1ae895b5b8379" translate="yes" xml:space="preserve">
          <source>It is recommended that you use unixODBC. You can find the latest version and ODBC drivers at &lt;a href=&quot;http://www.unixodbc.org&quot;&gt;http://www.unixodbc.org&lt;/a&gt;. You need the unixODBC header files and shared libraries.</source>
          <target state="translated">unixODBC를 사용하는 것이 좋습니다. 최신 버전 및 ODBC 드라이버는 &lt;a href=&quot;http://www.unixodbc.org&quot;&gt;http://www.unixodbc.org&lt;/a&gt; 에서 찾을 수 있습니다 . unixODBC 헤더 파일 및 공유 라이브러리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="339c1eab3d6d724ace0be1b0cc1282b7bcaf9ecc" translate="yes" xml:space="preserve">
          <source>It is recommended to build Qt 5 using a</source>
          <target state="translated">Qt 5를 사용하여 빌드하는 것이 좋습니다</target>
        </trans-unit>
        <trans-unit id="c6dee651fb40f992dec56cf4fa999cdfc3a9cdb9" translate="yes" xml:space="preserve">
          <source>It is recommended to disable the cache when the source or the effect properties are animated.</source>
          <target state="translated">소스 또는 효과 속성에 애니메이션이 적용되는 경우 캐시를 비활성화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3f8efdfe1605c92c751763ef748fbd14f3f4bca3" translate="yes" xml:space="preserve">
          <source>It is recommended to keep these directories separate by shadow-building and using the &lt;code&gt;-prefix&lt;/code&gt; option. This enables you to keep the Qt</source>
          <target state="translated">새도우 빌드 및 &lt;code&gt;-prefix&lt;/code&gt; 옵션을 사용하여 이러한 디렉토리를 분리하는 것이 좋습니다 . 이를 통해 Qt를 유지할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0c492a720f4fa9f113504a0a8a9a1947829e5019" translate="yes" xml:space="preserve">
          <source>It is recommended to restrict the usage of QOpenGLContexts created this way. Various platform-specific behavior and issues may prevent such contexts to be made current with windows (surfaces) created by Qt due to non-matching pixel formats for example. A potentially safer solution is to use the wrapped context only to set up sharing and perform Qt-based rendering offscreen, using a separate, dedicated &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;. The resulting textures are then accessible in the foreign context too.</source>
          <target state="translated">이 방법으로 작성된 QOpenGLContexts의 사용을 제한하는 것이 좋습니다. 다양한 플랫폼 별 동작 및 문제로 인해 이러한 컨텍스트가 일치하지 않는 픽셀 형식으로 인해 Qt에서 만든 창 (표면)으로 최신 상태가되지 않을 수 있습니다. 잠재적으로 안전한 솔루션은 랩핑 된 컨텍스트 만 사용하여 별도의 전용 &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext를&lt;/a&gt; 사용하여 공유를 설정하고 Qt 기반 렌더링 오프 스크린을 수행하는 것 입니다. 결과 텍스처는 외부 컨텍스트에서도 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80338d71c593317d44dc5f10fad0aae8878ec321" translate="yes" xml:space="preserve">
          <source>It is recommended to store the QML type id during registration, e.g. as a static member in the singleton class. Otherwise, a costly lookup via &lt;a href=&quot;qqmlengine#qmlTypeId&quot;&gt;qmlTypeId&lt;/a&gt;() has to be performed at run-time.</source>
          <target state="translated">등록하는 동안 QML 유형 ID를 저장하는 것이 좋습니다 (예 : 싱글 톤 클래스의 정적 멤버). 그렇지 않으면 &lt;a href=&quot;qqmlengine#qmlTypeId&quot;&gt;qmlTypeId&lt;/a&gt; () 를 통한 비용이 많이 드는 조회를 런타임에 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="07c19ca8baa40c260fe400e16525b4a2b127c9ca" translate="yes" xml:space="preserve">
          <source>It is recommended to store the QML type id, e.g. as a static member in the singleton class. The lookup via &lt;a href=&quot;qqmlengine#qmlTypeId&quot;&gt;qmlTypeId&lt;/a&gt;() is costly.</source>
          <target state="translated">예를 들어 싱글 톤 클래스의 정적 멤버로 QML 유형 ID를 저장하는 것이 좋습니다. &lt;a href=&quot;qqmlengine#qmlTypeId&quot;&gt;qmlTypeId&lt;/a&gt; () 를 통한 조회 는 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="56e4e7198dca270dabf978e28be77f77c6d341e0" translate="yes" xml:space="preserve">
          <source>It is recommended to unset this property when developer tools are not visible; otherwise some debug information may appear in the inspected &lt;a href=&quot;qml-qtwebengine-webengineview&quot;&gt;WebEngineView&lt;/a&gt;.</source>
          <target state="translated">개발자 도구가 보이지 않으면이 속성을 설정 해제하는 것이 좋습니다. 그렇지 않으면 검사 된 &lt;a href=&quot;qml-qtwebengine-webengineview&quot;&gt;WebEngineView&lt;/a&gt; 에 일부 디버그 정보가 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ead83bf8189f3ea91b5a531707aa69f2d414ac1b" translate="yes" xml:space="preserve">
          <source>It is recommended to use &lt;a href=&quot;qml-qtquick-controls2-itemdelegate&quot;&gt;ItemDelegate&lt;/a&gt; (or any other &lt;a href=&quot;qml-qtquick-controls2-abstractbutton&quot;&gt;AbstractButton&lt;/a&gt; derivatives) as the delegate. This ensures that the interaction works as expected, and the popup will automatically close when appropriate. When other types are used as the delegate, the popup must be closed manually. For example, if &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; is used:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-itemdelegate&quot;&gt;ItemDelegate&lt;/a&gt; (또는 다른 &lt;a href=&quot;qml-qtquick-controls2-abstractbutton&quot;&gt;AbstractButton&lt;/a&gt; 파생)를 대리자 로 사용하는 것이 좋습니다 . 이를 통해 상호 작용이 예상대로 작동하고 팝업이 필요할 때 자동으로 닫힙니다. 다른 유형을 대리자로 사용하는 경우 팝업을 수동으로 닫아야합니다. 예를 들어 &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; 를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="2cc6a905f9fb02c8c95a035498d110f9b7aece9f" translate="yes" xml:space="preserve">
          <source>It is recommended to use this function to prevent expensive notifications via updateAccessibility() when they are not needed.</source>
          <target state="translated">필요하지 않은 경우 updateAccessibility ()를 통한 고가의 알림을 방지하려면이 함수를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a7a8b630c0e0caaf8871c9db4b8ad4381c8abfb6" translate="yes" xml:space="preserve">
          <source>It is recommended to use this instead of &lt;a href=&quot;qprinterinfo#availablePrinters&quot;&gt;availablePrinters&lt;/a&gt;() as it will be faster on most systems.</source>
          <target state="translated">대부분의 시스템에서 더 빠를 수 있기 때문에 &lt;a href=&quot;qprinterinfo#availablePrinters&quot;&gt;availablePrinters&lt;/a&gt; () 대신 이것을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a7dbc8e02f806ff4f344925e5d01daa2271c7314" translate="yes" xml:space="preserve">
          <source>It is relevant when the role is &lt;a href=&quot;qaccessible#Role-enum&quot;&gt;QAccessible::EditableText&lt;/a&gt; and set to be read-only. By default this property is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">역할이 &lt;a href=&quot;qaccessible#Role-enum&quot;&gt;QAccessible :: EditableText&lt;/a&gt; 이고 읽기 전용으로 설정된 경우에 관련 됩니다. 기본적으로이 속성은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ce272aafea9d127aac2714325412a18186055aba" translate="yes" xml:space="preserve">
          <source>It is returned as a &lt;a href=&quot;qprocessenvironment&quot;&gt;QProcessEnvironment&lt;/a&gt;. This function does not cache the system environment. Therefore, it's possible to obtain an updated version of the environment if low-level C library functions like &lt;code&gt;setenv&lt;/code&gt; or &lt;code&gt;putenv&lt;/code&gt; have been called.</source>
          <target state="translated">&lt;a href=&quot;qprocessenvironment&quot;&gt;QProcessEnvironment&lt;/a&gt; 로 리턴됩니다 . 이 기능은 시스템 환경을 캐시하지 않습니다. 따라서 &lt;code&gt;setenv&lt;/code&gt; 또는 &lt;code&gt;putenv&lt;/code&gt; 와 같은 저수준 C 라이브러리 함수 가 호출 된 경우 업데이트 된 버전의 환경을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41c8008152f562cd0b0ae8aa789ff33ad86794c0" translate="yes" xml:space="preserve">
          <source>It is safe to access properties of the associated &lt;a href=&quot;qabstractvideofilter&quot;&gt;QAbstractVideoFilter&lt;/a&gt; instance from this function.</source>
          <target state="translated">이 함수에서 관련 &lt;a href=&quot;qabstractvideofilter&quot;&gt;QAbstractVideoFilter&lt;/a&gt; 인스턴스의 속성에 액세스하는 것이 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="fc08ab1ecd65e0107a8d8e1b3f98adb32372b467" translate="yes" xml:space="preserve">
          <source>It is safe to call this function multiple times from the same context.</source>
          <target state="translated">동일한 컨텍스트에서이 함수를 여러 번 호출하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="aae1b13febc579890c2bfc6adb3b816cd224eed9" translate="yes" xml:space="preserve">
          <source>It is safe to delete a &lt;a href=&quot;qdnslookup&quot;&gt;QDnsLookup&lt;/a&gt; object even if it is not finished, you will simply never receive its results.</source>
          <target state="translated">완료되지 않은 경우에도 &lt;a href=&quot;qdnslookup&quot;&gt;QDnsLookup&lt;/a&gt; 객체 를 삭제하는 것이 안전 합니다. 결과를받지 못할 것입니다.</target>
        </trans-unit>
        <trans-unit id="1d20f02a0afbaef4162a3f39317e9284f045e7f7" translate="yes" xml:space="preserve">
          <source>It is safe to use this feature even with code compiled without the feature. &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; will ensure that the pointer is removed from the tracker even from code compiled without pointer tracking.</source>
          <target state="translated">기능없이 컴파일 된 코드에서도이 기능을 사용하는 것이 안전합니다. &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; 는 포인터 추적없이 컴파일 된 코드에서도 포인터가 추적기에서 제거되도록합니다.</target>
        </trans-unit>
        <trans-unit id="6d6cb32b82d4f6b2691c9ab86b7b662c798ef7d9" translate="yes" xml:space="preserve">
          <source>It is safe to use this feature even with code compiled without the feature. QSharedPointer will ensure that the pointer is removed from the tracker even from code compiled without pointer tracking.</source>
          <target state="translated">기능없이 컴파일 된 코드로도이 기능을 사용하는 것이 안전합니다. QSharedPointer는 포인터 추적없이 컴파일 된 코드에서도 추적기에서 포인터가 제거되도록합니다.</target>
        </trans-unit>
        <trans-unit id="9bc9703cc8c19891ddda44a312e928336c2e4992" translate="yes" xml:space="preserve">
          <source>It is simple to construct a tree view displaying data from a model. In the following example, the contents of a directory are supplied by a &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt; and displayed as a tree:</source>
          <target state="translated">모델의 데이터를 표시하는 트리 뷰를 구성하는 것은 간단합니다. 다음 예제에서 디렉토리의 내용은 &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt; 에 의해 제공되며 트리로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="469994c0d20a35e8ac1a59244c93cff450232624" translate="yes" xml:space="preserve">
          <source>It is simply a typedef for &lt;code&gt;std::reverse_iterator&amp;lt;QLinkedList::const_iterator&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">단순히 &lt;code&gt;std::reverse_iterator&amp;lt;QLinkedList::const_iterator&amp;gt;&lt;/code&gt; 의 typedef입니다 .</target>
        </trans-unit>
        <trans-unit id="f05929b58b72ba6f8215e6be6305d14c945bf50e" translate="yes" xml:space="preserve">
          <source>It is simply a typedef for &lt;code&gt;std::reverse_iterator&amp;lt;QLinkedList::iterator&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">단순히 &lt;code&gt;std::reverse_iterator&amp;lt;QLinkedList::iterator&amp;gt;&lt;/code&gt; 의 typedef입니다 .</target>
        </trans-unit>
        <trans-unit id="7adb3f514f28a10c1b894998b1ffe592387d358f" translate="yes" xml:space="preserve">
          <source>It is simply a typedef for &lt;code&gt;std::reverse_iterator&amp;lt;QSet::const_iterator&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">단순히 &lt;code&gt;std::reverse_iterator&amp;lt;QSet::const_iterator&amp;gt;&lt;/code&gt; 의 typedef입니다 .</target>
        </trans-unit>
        <trans-unit id="82d20bcd8deaea9a970944740ca614654b3b23b5" translate="yes" xml:space="preserve">
          <source>It is simply a typedef for &lt;code&gt;std::reverse_iterator&amp;lt;QSet::iterator&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">단순히 &lt;code&gt;std::reverse_iterator&amp;lt;QSet::iterator&amp;gt;&lt;/code&gt; 의 typedef입니다 .</target>
        </trans-unit>
        <trans-unit id="81314285fc40db886de573c546bc3207af7fe535" translate="yes" xml:space="preserve">
          <source>It is simply a typedef for &lt;code&gt;std::reverse_iterator&amp;lt;T*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">단순히 &lt;code&gt;std::reverse_iterator&amp;lt;T*&amp;gt;&lt;/code&gt; 의 typedef입니다 .</target>
        </trans-unit>
        <trans-unit id="a7a9dfc4740fbb00f43015215edf4b7ec85d5925" translate="yes" xml:space="preserve">
          <source>It is simply a typedef for &lt;code&gt;std::reverse_iterator&amp;lt;const T*&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">단순히 &lt;code&gt;std::reverse_iterator&amp;lt;const T*&amp;gt;&lt;/code&gt; 의 typedef입니다 .</target>
        </trans-unit>
        <trans-unit id="feb45b9497c2dd9d2e76702fb6e871af7e517c87" translate="yes" xml:space="preserve">
          <source>It is simply a typedef for &lt;code&gt;std::reverse_iterator&amp;lt;const_iterator&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">단순히 &lt;code&gt;std::reverse_iterator&amp;lt;const_iterator&amp;gt;&lt;/code&gt; 의 typedef입니다 .</target>
        </trans-unit>
        <trans-unit id="431a580c6160d9bd48ada33ae57793812a24a1df" translate="yes" xml:space="preserve">
          <source>It is simply a typedef for &lt;code&gt;std::reverse_iterator&amp;lt;iterator&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">단순히 &lt;code&gt;std::reverse_iterator&amp;lt;iterator&amp;gt;&lt;/code&gt; 의 typedef입니다 .</target>
        </trans-unit>
        <trans-unit id="7b41ef32e71627bcdf7890579f808a6aa41c71d2" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary to be able to show a path in the native representation for the user's platform. The static &lt;a href=&quot;qdir#toNativeSeparators&quot;&gt;toNativeSeparators&lt;/a&gt;() function returns a copy of the specified path in which each directory separator is replaced by the appropriate separator for the underlying operating system.</source>
          <target state="translated">때때로 사용자 플랫폼의 기본 표현에 경로를 표시 할 수 있어야합니다. static &lt;a href=&quot;qdir#toNativeSeparators&quot;&gt;toNativeSeparators&lt;/a&gt; () 함수는 각 디렉토리 분리자가 기본 운영 체제에 대한 적절한 분리 자로 대체되는 지정된 경로의 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dccac8ee753bb7d08d70e1f70a577f0f24841635" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary to delay the destruction of an item until an animation completes. The example delegate below ensures that the animation completes before the item is removed from the list.</source>
          <target state="translated">애니메이션이 완료 될 때까지 항목 파괴를 지연해야하는 경우가 있습니다. 아래의 델리게이트 예제는 항목이 목록에서 제거되기 전에 애니메이션이 완료되도록합니다.</target>
        </trans-unit>
        <trans-unit id="6e03c95e7f694a97d774299c92fb95e37fb47182" translate="yes" xml:space="preserve">
          <source>It is sometimes necessary to provide internationalization support for strings used in classes that do not inherit &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; or use the &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; macro to enable translation features. Since Qt translates strings at run-time based on the class they are associated with and &lt;code&gt;lupdate&lt;/code&gt; looks for translatable strings in the source code, non-Qt classes must use mechanisms that also provide this information.</source>
          <target state="translated">&lt;a href=&quot;qobject&quot;&gt;QObject를&lt;/a&gt; 상속하지 않거나 &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; 매크로를 사용하여 변환 기능을 사용 가능하게 하지 않는 클래스에 사용 된 문자열에 대한 국제화 지원을 제공 해야하는 경우가 있습니다. Qt는 연관된 클래스를 기반으로 런타임에 문자열을 변환하고 &lt;code&gt;lupdate&lt;/code&gt; 는 소스 코드에서 번역 가능한 문자열을 검색하므로 Qt가 아닌 클래스는이 정보를 제공하는 메커니즘을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d633961314a15745707044a8af6709cefd965b5f" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to be able to hide items in an item view widget rather than remove them. Items for all of the above widgets can be hidden and later shown again. You can determine whether an item is hidden by calling the isItemHidden() function, and items can be hidden with &lt;code&gt;setItemHidden()&lt;/code&gt;.</source>
          <target state="translated">항목보기 위젯에서 항목을 제거하지 않고 숨길 수있는 경우가 종종 있습니다. 위의 모든 위젯에 대한 항목을 숨기고 나중에 다시 표시 할 수 있습니다. 당신은 항목이 isItemHidden () 함수를 호출하여 숨겨져 있는지 여부를 확인 할 수 있으며, 항목으로 숨길 수 있습니다 &lt;code&gt;setItemHidden()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58e3a17abee31487c9241aeb3e073067cf4030dc" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to limit the files and directories exposed to those that the user can access. The &lt;a href=&quot;qml-qt-labs-folderlistmodel-folderlistmodel#showOnlyReadable-prop&quot;&gt;showOnlyReadable&lt;/a&gt; property can be set to enable this feature.</source>
          <target state="translated">때때로 사용자가 액세스 할 수있는 파일 및 디렉토리를 제한하는 것이 유용합니다. &lt;a href=&quot;qml-qt-labs-folderlistmodel-folderlistmodel#showOnlyReadable-prop&quot;&gt;showOnlyReadable&lt;/a&gt; 속성은이 기능을 사용하도록 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e49376b823a0359c043b48488c665f5b32cd35f" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to respond to property changes as events. For example, you might want to display a user notification when a certain property change occurs. However, this user notification would then also be triggered when a replica first became &lt;code&gt;QRemoteObjectReplica::Valid&lt;/code&gt;, as all property change signals are emitted at that time. This isn't always desirable, and &lt;code&gt;notified&lt;/code&gt; allows the developer to distinguish between these two cases.</source>
          <target state="translated">속성 변경에 이벤트로 응답하는 것이 유용한 경우가 있습니다. 예를 들어 특정 속성 변경이 발생하면 사용자 알림을 표시 할 수 있습니다. 그러나이 사용자 알림은 복제본이 처음 &lt;code&gt;QRemoteObjectReplica::Valid&lt;/code&gt; 가 될 때도 트리거됩니다. 그 때 모든 속성 변경 신호가 방출되기 때문입니다. 이것이 항상 바람직한 것은 아니며 &lt;code&gt;notified&lt;/code&gt; 통해 개발자가이 두 경우를 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2744524e31f7e53251513a310af52e486bd7d35f" translate="yes" xml:space="preserve">
          <source>It is sometimes useful to update the splash screen with messages, for example, announcing connections established or modules loaded as the application starts up:</source>
          <target state="translated">응용 프로그램이 시작될 때 연결이 설정되었거나로드 된 모듈을 알리는 등의 메시지로 스플래시 화면을 업데이트하는 것이 유용한 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="64ea90c9389d4ca6354bed0e0a5139515ac688d3" translate="yes" xml:space="preserve">
          <source>It is strongly recommended to verify that the gamepad's input device is present, and is sending events, via the &lt;code&gt;lsinput&lt;/code&gt; and &lt;code&gt;evtest&lt;/code&gt; utilities.</source>
          <target state="translated">&lt;code&gt;lsinput&lt;/code&gt; 및 &lt;code&gt;evtest&lt;/code&gt; 유틸리티 를 통해 게임 패드의 입력 장치가 있고 이벤트를 보내는 지 확인하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4abce180d73f49d71eb8e4e1800723c0e3af5ee0" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to release the &lt;code&gt;CGImageRef&lt;/code&gt; data after use.</source>
          <target state="translated">사용 후 &lt;code&gt;CGImageRef&lt;/code&gt; 데이터 를 해제하는 것은 호출자의 책임 입니다.</target>
        </trans-unit>
        <trans-unit id="7b3536c908df0425a65a5fecb52be405e775ae05" translate="yes" xml:space="preserve">
          <source>It is the caller's responsibility to release the &lt;code&gt;NSImage&lt;/code&gt; data after use.</source>
          <target state="translated">사용 후 &lt;code&gt;NSImage&lt;/code&gt; 데이터 를 해제하는 것은 호출자의 책임 입니다.</target>
        </trans-unit>
        <trans-unit id="c7e26b266ae865f4585e1113f95a8f417fbf1a84" translate="yes" xml:space="preserve">
          <source>It is the gradient's complete set of stop points (accessible through the &lt;a href=&quot;qgradient#stops&quot;&gt;stops&lt;/a&gt;() function) that describes how the gradient area should be filled. If no stop points have been specified, a gradient of black at 0 to white at 1 is used.</source>
          <target state="translated">그것은합니다 (통해 액세스 정지 점의 기울기의 전체 집합입니다 &lt;a href=&quot;qgradient#stops&quot;&gt;정거장&lt;/a&gt; () 함수) 그라데이션 영역이 채워 져야하는 방법을 설명하는. 정지 점이 지정되지 않은 경우 0에서 검은 색에서 1에서 흰색의 기울기가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5eaf6f9949bc04b1998876e2392c93c7ccd6bcf0" translate="yes" xml:space="preserve">
          <source>It is the order of the elements that is reversed: If a &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt; is composed by calling the &lt;a href=&quot;qpainterpath#moveTo&quot;&gt;moveTo&lt;/a&gt;(), &lt;a href=&quot;qpainterpath#lineTo&quot;&gt;lineTo&lt;/a&gt;() and &lt;a href=&quot;qpainterpath#cubicTo&quot;&gt;cubicTo&lt;/a&gt;() functions in the specified order, the reversed copy is composed by calling &lt;a href=&quot;qpainterpath#cubicTo&quot;&gt;cubicTo&lt;/a&gt;(), &lt;a href=&quot;qpainterpath#lineTo&quot;&gt;lineTo&lt;/a&gt;() and &lt;a href=&quot;qpainterpath#moveTo&quot;&gt;moveTo&lt;/a&gt;().</source>
          <target state="translated">이것은 반전 요소의 순서는 다음과하면 &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath이&lt;/a&gt; 호출에 의해 구성된다 &lt;a href=&quot;qpainterpath#moveTo&quot;&gt;의 moveTo&lt;/a&gt; () &lt;a href=&quot;qpainterpath#lineTo&quot;&gt;에 lineTo&lt;/a&gt; () 및 &lt;a href=&quot;qpainterpath#cubicTo&quot;&gt;cubicTo&lt;/a&gt; () 지정된 순서 기능, 반전 된 복사본을 호출하여 구성된다 &lt;a href=&quot;qpainterpath#cubicTo&quot;&gt;cubicTo&lt;/a&gt; () &lt;a href=&quot;qpainterpath#lineTo&quot;&gt;에 lineTo을&lt;/a&gt; () 및 &lt;a href=&quot;qpainterpath#moveTo&quot;&gt;moveTo&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="3c64376141c1254f880bd9be46bbfdd2d0b95adc" translate="yes" xml:space="preserve">
          <source>It is the programmer's responsibility to specify which stack is active by calling &lt;a href=&quot;qundostack#active-prop&quot;&gt;QUndoStack::setActive&lt;/a&gt;(), usually when the associated document window receives focus. The active stack may also be set with &lt;a href=&quot;qundogroup#setActiveStack&quot;&gt;setActiveStack&lt;/a&gt;(), and is returned by &lt;a href=&quot;qundogroup#activeStack&quot;&gt;activeStack&lt;/a&gt;().</source>
          <target state="translated">일반적으로 관련 문서 창이 포커스를받을 때 &lt;a href=&quot;qundostack#active-prop&quot;&gt;QUndoStack :: setActive&lt;/a&gt; () 를 호출하여 활성화 할 스택을 지정하는 것은 프로그래머의 책임 입니다. 활성 스택은 &lt;a href=&quot;qundogroup#setActiveStack&quot;&gt;setActiveStack&lt;/a&gt; () 으로 설정 될 수도 있으며 &lt;a href=&quot;qundogroup#activeStack&quot;&gt;activeStack&lt;/a&gt; ()에 의해 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="475f36a5a8b3a7018cd262241e3298beb6f897f8" translate="yes" xml:space="preserve">
          <source>It is the programmer's responsibility to specify which stack is active by calling setActive(), usually when the associated document window receives focus.</source>
          <target state="translated">일반적으로 관련 문서 창이 포커스를받을 때 setActive ()를 호출하여 활성화 할 스택을 지정하는 것은 프로그래머의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="22ecd0f2f3c0b76414c37afe7bd229960f952cd1" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the delegate to manage the editor's geometry. The geometry must be set when the editor is created, and when the item's size or position in the view is changed. Fortunately, the view provides all the necessary geometry information inside a &lt;a href=&quot;qstyleoptionviewitem&quot;&gt;view option&lt;/a&gt; object.</source>
          <target state="translated">편집자의 지오메트리를 관리하는 것은 대의원의 책임입니다. 편집기를 만들 때와보기에서 항목의 크기 나 위치가 변경 될 때 형상을 설정해야합니다. 다행히 뷰는 &lt;a href=&quot;qstyleoptionviewitem&quot;&gt;뷰 옵션&lt;/a&gt; 객체 내부에 필요한 모든 지오메트리 정보를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="0692ba535366f2eee2fbe9bcc4cbc8d99b2ddb61" translate="yes" xml:space="preserve">
          <source>It is the style that draws the headers of Qt's item views. The item views keep the dimensions on individual sections. Also note that the delegates may use the style to paint decorations and frames around items. &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt;, for instance, draws &lt;code&gt;PE_FrameFocusRect&lt;/code&gt; and &lt;code&gt;PE_IndicatorViewItemCheck&lt;/code&gt;.</source>
          <target state="translated">Qt의 아이템 뷰의 헤더를 그리는 스타일입니다. 항목보기는 개별 섹션의 치수를 유지합니다. 또한 대리인은 스타일을 사용하여 항목 주위에 장식 및 프레임을 페인트 할 수 있습니다. &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate는&lt;/a&gt; , 예를 들어, 무 &lt;code&gt;PE_FrameFocusRect&lt;/code&gt; 및 &lt;code&gt;PE_IndicatorViewItemCheck&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="7e9d727f3110c3fa764e7600a68b4915803838bd" translate="yes" xml:space="preserve">
          <source>It is the user's responsibility to send a</source>
          <target state="translated">이메일을 보내는 것은 사용자의 책임입니다</target>
        </trans-unit>
        <trans-unit id="64c285ba8a4f5a883e3f8d08e98ca74e56b91c96" translate="yes" xml:space="preserve">
          <source>It is then advisable to introduce a function to do the command line parsing which takes a struct or class receiving the option values returning an enumeration representing the result. The dnslookup example of the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnetwork-module.html&quot;&gt;QtNetwork&lt;/a&gt; module illustrates this:</source>
          <target state="translated">그런 다음 결과를 나타내는 열거를 반환하는 옵션 값을받는 구조체 또는 클래스를 사용하는 명령 줄 구문 분석을 수행하는 함수를 도입하는 것이 좋습니다. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtnetwork-module.html&quot;&gt;QtNetwork&lt;/a&gt; 모듈 의 dnslookup 예제는 다음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f42c883d66a148382dd7ec2989e338fc79994cd7" translate="yes" xml:space="preserve">
          <source>It is then advisable to introduce a function to do the command line parsing which takes a struct or class receiving the option values returning an enumeration representing the result. The dnslookup example of the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtnetwork-module.html&quot;&gt;QtNetwork&lt;/a&gt; module illustrates this:</source>
          <target state="translated">그런 다음 결과를 나타내는 열거 형을 반환하는 옵션 값을받는 구조체 또는 클래스를 사용하는 명령 줄 구문 분석을 수행하는 함수를 도입하는 것이 좋습니다. &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtnetwork-module.html&quot;&gt;QtNetwork&lt;/a&gt; 모듈 의 dnslookup 예제는 다음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="114d9e3472940f3d418ff0e689814f57751b29c6" translate="yes" xml:space="preserve">
          <source>It is typcally used through subclassing allowing to set the device name and defining enums for the various axis and buttons of your targeted device.</source>
          <target state="translated">일반적으로 서브 클래 싱을 통해 장치 이름을 설정하고 대상 장치의 다양한 축과 버튼에 대한 열거 형을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24d5cb58791201568a08d2e8498dd7df665f1d02" translate="yes" xml:space="preserve">
          <source>It is unknown whether the user grants or denies permission.</source>
          <target state="translated">사용자가 권한을 부여할지 거부하는지 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5034277fb7c700265da764152f49e873ba4aeb0" translate="yes" xml:space="preserve">
          <source>It is up to the application that requests the data to delete the &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; when done with it.</source>
          <target state="translated">완료 되면 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; 를 삭제하기 위해 데이터를 요청하는 것은 애플리케이션에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fd2f060ce6c2245304b3173676e93bd2e150322" translate="yes" xml:space="preserve">
          <source>It is used as follows:</source>
          <target state="translated">다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="68f3a5f0d404e82cb4076caf8b04c25d1d51e774" translate="yes" xml:space="preserve">
          <source>It is used by the input method to query a set of properties of the object to be able to support complex input method operations as support for surrounding text and reconversions.</source>
          <target state="translated">입력 방법에서 객체의 속성 집합을 쿼리하여 주변 텍스트 및 변환을 지원하는 복잡한 입력 방법 작업을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83823b0ad29439d5f4235011a1fe52d9f6d2b301" translate="yes" xml:space="preserve">
          <source>It is used on some platforms to be able to notify the AT client about state changes. The backend will traverse up all ancestors until it finds a window. (This means that at least one interface among the ancestors should return a valid &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; pointer).</source>
          <target state="translated">일부 플랫폼에서는 AT 클라이언트에게 상태 변경에 대해 알릴 수 있습니다. 백엔드는 창을 찾을 때까지 모든 조상을 순회합니다. 이것은 조상 중 하나 이상의 인터페이스가 유효한 &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; 포인터를 반환해야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="0f9c50f9bd5eb8e0494106a34d0c7c4e7a139f59" translate="yes" xml:space="preserve">
          <source>It is used to parse the query strings found in URLs like the following:</source>
          <target state="translated">다음과 같이 URL에있는 쿼리 문자열을 구문 분석하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="64f4efc75604a7e410c591b323d16cfa1d5a7e16" translate="yes" xml:space="preserve">
          <source>It is useful for &lt;a href=&quot;qtquickcontrols2-customize#customizing-toolseparator&quot;&gt;customizing ToolSeparator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qtquickcontrols2-customize#customizing-toolseparator&quot;&gt;ToolSeparator&lt;/a&gt; 를 사용자 정의하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="6721bdfcb5a66ce13d721aa3d5c6e61f357cb2ee" translate="yes" xml:space="preserve">
          <source>It is useful for custom styling.</source>
          <target state="translated">사용자 정의 스타일에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="65f75061ba89d59066892de2f51d7a2a2979dbe5" translate="yes" xml:space="preserve">
          <source>It is useful for performing some action upon cancellation of a swipe. For example, it can be used to cancel the removal of the delegate from the list that it is in.</source>
          <target state="translated">스 와이프 취소시 일부 작업을 수행하는 데 유용합니다. 예를 들어, 목록에있는 델리게이트 제거를 취소하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae77a32d0eaf533e1b92037316f3c7870e643f43" translate="yes" xml:space="preserve">
          <source>It is useful for performing some action upon completion of a swipe. For example, it can be used to remove the delegate from the list that it is in.</source>
          <target state="translated">스 와이프가 완료되면 일부 작업을 수행하는 데 유용합니다. 예를 들어, 목록에있는 대리자를 제거하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08ba2cb212f8024adb53cc7df30cdd314c483950" translate="yes" xml:space="preserve">
          <source>It is useful for setting non-animated property values during an animation.</source>
          <target state="translated">애니메이션 중에 애니메이션되지 않은 속성 값을 설정하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e5f7736b9866a18e4ef1d16c5d591af75ba1f926" translate="yes" xml:space="preserve">
          <source>It is useful to examine some of the functions inherited by &lt;a href=&quot;qxmldefaulthandler&quot;&gt;QXmlDefaultHandler&lt;/a&gt;, and consider why they might be reimplemented in a custom handler. Custom handlers will typically reimplement &lt;a href=&quot;qxmlcontenthandler#startDocument&quot;&gt;QXmlContentHandler::startDocument&lt;/a&gt;() to prepare the handler for new content. Document elements and the text within them can be processed by reimplementing &lt;a href=&quot;qxmlcontenthandler#startElement&quot;&gt;QXmlContentHandler::startElement&lt;/a&gt;(), &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;QXmlContentHandler::endElement&lt;/a&gt;(), and &lt;a href=&quot;qxmlcontenthandler#characters&quot;&gt;QXmlContentHandler::characters&lt;/a&gt;(). You may want to reimplement &lt;a href=&quot;qxmlcontenthandler#endDocument&quot;&gt;QXmlContentHandler::endDocument&lt;/a&gt;() to perform some finalization or validation on the content once the document has been read completely.</source>
          <target state="translated">&lt;a href=&quot;qxmldefaulthandler&quot;&gt;QXmlDefaultHandler&lt;/a&gt; 에 의해 상속 된 함수 중 일부를 검사 하고 사용자 정의 핸들러에서 다시 구현 될 수있는 이유를 고려 하는 것이 유용 합니다. 사용자 정의 핸들러는 일반적으로 &lt;a href=&quot;qxmlcontenthandler#startDocument&quot;&gt;QXmlContentHandler :: startDocument&lt;/a&gt; ()를 다시 구현 하여 새 컨텐츠에 대한 핸들러를 준비합니다. &lt;a href=&quot;qxmlcontenthandler#startElement&quot;&gt;QXmlContentHandler :: startElement&lt;/a&gt; (), &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;QXmlContentHandler :: endElement&lt;/a&gt; () 및 &lt;a href=&quot;qxmlcontenthandler#characters&quot;&gt;QXmlContentHandler :: characters&lt;/a&gt; () 를 다시 구현하여 문서 요소 및 그 안의 텍스트를 처리 할 수 ​​있습니다 . 문서를 완전히 읽은 후 &lt;a href=&quot;qxmlcontenthandler#endDocument&quot;&gt;QXmlContentHandler :: endDocument&lt;/a&gt; () 를 다시 구현 하여 컨텐츠에 대한 마무리 또는 유효성 검증을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58beb332fededc93d1694e262364389c5680796b" translate="yes" xml:space="preserve">
          <source>It is useful to examine some of the functions inherited by QXmlDefaultHandler, and consider why they might be reimplemented in a custom handler. Custom handlers will typically reimplement &lt;a href=&quot;qxmlcontenthandler#startDocument&quot;&gt;QXmlContentHandler::startDocument&lt;/a&gt;() to prepare the handler for new content. Document elements and the text within them can be processed by reimplementing &lt;a href=&quot;qxmlcontenthandler#startElement&quot;&gt;QXmlContentHandler::startElement&lt;/a&gt;(), &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;QXmlContentHandler::endElement&lt;/a&gt;(), and &lt;a href=&quot;qxmlcontenthandler#characters&quot;&gt;QXmlContentHandler::characters&lt;/a&gt;(). You may want to reimplement &lt;a href=&quot;qxmlcontenthandler#endDocument&quot;&gt;QXmlContentHandler::endDocument&lt;/a&gt;() to perform some finalization or validation on the content once the document has been read completely.</source>
          <target state="translated">QXmlDefaultHandler에서 상속 된 일부 함수를 검사하고 사용자 지정 처리기에서 다시 구현 될 수있는 이유를 고려하는 것이 유용합니다. 사용자 정의 핸들러는 일반적으로 &lt;a href=&quot;qxmlcontenthandler#startDocument&quot;&gt;QXmlContentHandler :: startDocument&lt;/a&gt; ()를 다시 구현 하여 새 콘텐츠에 대한 핸들러를 준비합니다. 문서 요소와 그 안에있는 텍스트는 &lt;a href=&quot;qxmlcontenthandler#startElement&quot;&gt;QXmlContentHandler :: startElement&lt;/a&gt; (), &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;QXmlContentHandler :: endElement&lt;/a&gt; () 및 &lt;a href=&quot;qxmlcontenthandler#characters&quot;&gt;QXmlContentHandler :: characters&lt;/a&gt; () 를 다시 구현하여 처리 할 수 ​​있습니다 . &lt;a href=&quot;qxmlcontenthandler#endDocument&quot;&gt;QXmlContentHandler :: endDocument&lt;/a&gt; () 를 다시 구현 하여 문서를 완전히 읽은 후 콘텐츠에 대한 일부 마무리 또는 유효성 검사를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2efa01bf9980151b6a23c5c8cc436840f126b2a" translate="yes" xml:space="preserve">
          <source>It is useful when you perform a &lt;a href=&quot;qtandroid#bindService&quot;&gt;QtAndroid::bindService&lt;/a&gt; operation.</source>
          <target state="translated">&lt;a href=&quot;qtandroid#bindService&quot;&gt;QtAndroid :: bindService&lt;/a&gt; 작업 을 수행 할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="ccedb2a0dcdae86de603453d5044478eca88cc70" translate="yes" xml:space="preserve">
          <source>It is usual to create one &lt;a href=&quot;qaxscriptmanager&quot;&gt;QAxScriptManager&lt;/a&gt; for each document in an application.</source>
          <target state="translated">애플리케이션의 각 문서마다 하나의 &lt;a href=&quot;qaxscriptmanager&quot;&gt;QAxScriptManager&lt;/a&gt; 를 작성하는 것이 일반적 입니다.</target>
        </trans-unit>
        <trans-unit id="ea7cbc32b5676c5b0fda47b75e0544bca39ddbe0" translate="yes" xml:space="preserve">
          <source>It is usual to create one QAxScriptManager for each document in an application.</source>
          <target state="translated">응용 프로그램의 각 문서에 대해 하나의 QAxScriptManager를 만드는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="99ee231891699e27206c153574172c6435601783" translate="yes" xml:space="preserve">
          <source>It is usual to use the class with a &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt;. The timeline's &lt;a href=&quot;qtimeline#valueChanged&quot;&gt;valueChanged()&lt;/a&gt; signal is then connected to the &lt;code&gt;setStep()&lt;/code&gt; slot. For example, you can set up an item for rotation by calling &lt;code&gt;setRotationAt()&lt;/code&gt; for different step values. The animations timeline is set with the &lt;a href=&quot;qgraphicsitemanimation#setTimeLine&quot;&gt;setTimeLine&lt;/a&gt;() function.</source>
          <target state="translated">클래스를 &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; 과 함께 사용하는 것이 일반적 입니다. 타임 라인의 &lt;a href=&quot;qtimeline#valueChanged&quot;&gt;valueChanged ()&lt;/a&gt; 신호는 &lt;code&gt;setStep()&lt;/code&gt; 슬롯에 연결됩니다 . 예를 들어, 다른 단계 값에 대해 &lt;code&gt;setRotationAt()&lt;/code&gt; 를 호출하여 회전 할 항목을 설정할 수 있습니다 . 애니메이션 타임 라인은 &lt;a href=&quot;qgraphicsitemanimation#setTimeLine&quot;&gt;setTimeLine&lt;/a&gt; () 함수로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2de5de8a1e21eb4d83f5aec2b82cddff448ba7e0" translate="yes" xml:space="preserve">
          <source>It is usually never necessary to invoke IDC manually, as the &lt;code&gt;qmake&lt;/code&gt; build system takes care of adding the required post processing steps to the build process. See the &lt;a href=&quot;activeqt-index&quot;&gt;ActiveQt&lt;/a&gt; documentation for details.</source>
          <target state="translated">&lt;code&gt;qmake&lt;/code&gt; 빌드 시스템은 빌드 프로세스에 필요한 사후 처리 단계를 추가하므로 IDC를 수동으로 호출 할 필요는 없습니다 . 자세한 내용은 &lt;a href=&quot;activeqt-index&quot;&gt;ActiveQt&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="125af56e31d2b987dd9caab4980b12ba8453c44f" translate="yes" xml:space="preserve">
          <source>It is usually not necessary to call this function on datagrams received from the network.</source>
          <target state="translated">일반적으로 네트워크에서 수신 한 데이터 그램에서이 함수를 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3fc23cf7e07dbb0d5d03f56879c55befa7dbf45f" translate="yes" xml:space="preserve">
          <source>It is usually not necessary to create a &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel&lt;/a&gt;. However, it can be useful for manipulating and accessing the &lt;a href=&quot;qml-qtqml-models-delegatemodel#modelIndex-method&quot;&gt;modelIndex&lt;/a&gt; when a &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass is used as the model. Also, &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel&lt;/a&gt; is used together with &lt;a href=&quot;qml-package&quot;&gt;Package&lt;/a&gt; to provide delegates to multiple views, and with &lt;a href=&quot;qml-qtqml-models-delegatemodelgroup&quot;&gt;DelegateModelGroup&lt;/a&gt; to sort and filter delegate items.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel&lt;/a&gt; 을 만들 필요는 없습니다 . 그러나 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 서브 클래스가 모델로 사용될 때 &lt;a href=&quot;qml-qtqml-models-delegatemodel#modelIndex-method&quot;&gt;modelIndex&lt;/a&gt; 를 조작하고 액세스하는 데 유용 할 수 있습니다 . 또한 &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel&lt;/a&gt; 은 &lt;a href=&quot;qml-package&quot;&gt;Package&lt;/a&gt; 와 함께 사용 하여 여러보기에 대리자를 제공하고 &lt;a href=&quot;qml-qtqml-models-delegatemodelgroup&quot;&gt;DelegateModelGroup&lt;/a&gt; 과 함께 대리 항목을 정렬 및 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="c091faa8e3c9187ee6ce887b4ea4c6e2ab424919" translate="yes" xml:space="preserve">
          <source>It is usually not necessary to create a DelegateModel. However, it can be useful for manipulating and accessing the &lt;a href=&quot;qml-qtqml-models-delegatemodel#modelIndex-method&quot;&gt;modelIndex&lt;/a&gt; when a &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass is used as the model. Also, DelegateModel is used together with &lt;a href=&quot;qml-qtqml-models-package&quot;&gt;Package&lt;/a&gt; to provide delegates to multiple views, and with &lt;a href=&quot;qml-qtqml-models-delegatemodelgroup&quot;&gt;DelegateModelGroup&lt;/a&gt; to sort and filter delegate items.</source>
          <target state="translated">일반적으로 DelegateModel을 생성 할 필요는 없습니다. 그러나 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 하위 클래스가 모델로 사용될 때 &lt;a href=&quot;qml-qtqml-models-delegatemodel#modelIndex-method&quot;&gt;modelIndex&lt;/a&gt; 를 조작하고 액세스하는 데 유용 할 수 있습니다 . 또한 DelegateModel은 &lt;a href=&quot;qml-qtqml-models-package&quot;&gt;Package&lt;/a&gt; 와 함께 사용 하여 여러 뷰에 대리자를 제공하고 &lt;a href=&quot;qml-qtqml-models-delegatemodelgroup&quot;&gt;DelegateModelGroup&lt;/a&gt; 과 함께 사용 하여 대리자 항목을 정렬 및 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="31dce88f7eed61ce7a451fc8f494e894bce7b1c5" translate="yes" xml:space="preserve">
          <source>It is usually used like the following example:</source>
          <target state="translated">일반적으로 다음 예제와 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af3a076e4a0d0c264d8fa05c2cdf3968867cd362" translate="yes" xml:space="preserve">
          <source>It is valid only with certain tablet stylus devices and touchscreens that can measure the rotation angle. Otherwise, it will be zero.</source>
          <target state="translated">회전 각도를 측정 할 수있는 특정 태블릿 스타일러스 장치 및 터치 스크린에서만 유효합니다. 그렇지 않으면 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="10863570d8c512bf0f5644f235600b7d4b119dcd" translate="yes" xml:space="preserve">
          <source>It is valid only with certain tablets and touchscreens that can measure pressure. Otherwise, it will be &lt;code&gt;1.0&lt;/code&gt; when pressed.</source>
          <target state="translated">압력을 측정 할 수있는 특정 태블릿 및 터치 스크린에서만 유효합니다. 그렇지 않으면 눌렀을 때 &lt;code&gt;1.0&lt;/code&gt; 이 됩니다.</target>
        </trans-unit>
        <trans-unit id="3c59c646f2ea200ba91b430917abe03b3c8e7811" translate="yes" xml:space="preserve">
          <source>It is valid only with certain tablets and touchscreens that can measure pressure. Otherwise, it will be zero.</source>
          <target state="translated">압력을 측정 할 수있는 특정 태블릿 및 터치 스크린에서만 유효합니다. 그렇지 않으면 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="37cae792ebf5a85c6950e20a135a14316e7098b3" translate="yes" xml:space="preserve">
          <source>It is very bright (eg. direct sunlight).</source>
          <target state="translated">매우 밝습니다 (예 : 직사광선).</target>
        </trans-unit>
        <trans-unit id="bfa7136fa67173bf3b61ce4bcf32a29192d3a877" translate="yes" xml:space="preserve">
          <source>It is very convenient to use this function because you do not need to bother with a &lt;a href=&quot;qobject#timerEvent&quot;&gt;timerEvent&lt;/a&gt; or create a local &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;qobject#timerEvent&quot;&gt;timerEvent를 사용&lt;/a&gt; 하거나 로컬 &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt; 객체를 만들 필요가 없기 때문에이 기능을 사용하는 것이 매우 편리 합니다.</target>
        </trans-unit>
        <trans-unit id="f3bc871ee447f1205606df0cf940007ac8daf536" translate="yes" xml:space="preserve">
          <source>It is very important to test that the temporary directory could be created, using &lt;a href=&quot;qtemporarydir#isValid&quot;&gt;isValid&lt;/a&gt;(). Do not use &lt;a href=&quot;qdir#exists-1&quot;&gt;exists()&lt;/a&gt;, since a default-constructed &lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; represents the current directory, which exists.</source>
          <target state="translated">&lt;a href=&quot;qtemporarydir#isValid&quot;&gt;isValid&lt;/a&gt; ()를 사용하여 임시 디렉토리를 작성할 수 있는지 테스트하는 것이 매우 중요합니다 . 기본으로 구성된 &lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; 은 존재하는 현재 디렉토리를 나타내므로 exist &lt;a href=&quot;qdir#exists-1&quot;&gt;()를&lt;/a&gt; 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="78663467a07fa6415050c51ec27d9b702ab36f8c" translate="yes" xml:space="preserve">
          <source>It is, however, possible to exchange the value with other processes running on the same machine, provided that they also use the same reference clock. &lt;a href=&quot;qelapsedtimer&quot;&gt;QElapsedTimer&lt;/a&gt; will always use the same clock, so it's safe to compare with the value coming from another process in the same machine. If comparing to values produced by other APIs, you should check that the clock used is the same as &lt;a href=&quot;qelapsedtimer&quot;&gt;QElapsedTimer&lt;/a&gt; (see &lt;a href=&quot;qelapsedtimer#clockType&quot;&gt;QElapsedTimer::clockType&lt;/a&gt;()).</source>
          <target state="translated">그러나 동일한 참조 클럭을 사용하는 경우 동일한 시스템에서 실행중인 다른 프로세스와 값을 교환 할 수 있습니다. &lt;a href=&quot;qelapsedtimer&quot;&gt;QElapsedTimer&lt;/a&gt; 는 항상 같은 시계를 사용하므로 동일한 컴퓨터의 다른 프로세스에서 오는 값과 비교하는 것이 안전합니다. 다른 API에서 생성 한 값과 비교할 경우 사용 된 시계가 &lt;a href=&quot;qelapsedtimer&quot;&gt;QElapsedTimer&lt;/a&gt; 와 같은지 확인해야합니다 ( &lt;a href=&quot;qelapsedtimer#clockType&quot;&gt;QElapsedTimer :: clockType&lt;/a&gt; () 참조).</target>
        </trans-unit>
        <trans-unit id="40391ad3ef454a60f35bc6a0a051678bdb0822bf" translate="yes" xml:space="preserve">
          <source>It is, however, possible to exchange the value with other processes running on the same machine, provided that they also use the same reference clock. QElapsedTimer will always use the same clock, so it's safe to compare with the value coming from another process in the same machine. If comparing to values produced by other APIs, you should check that the clock used is the same as QElapsedTimer (see &lt;a href=&quot;qelapsedtimer#clockType&quot;&gt;QElapsedTimer::clockType&lt;/a&gt;()).</source>
          <target state="translated">그러나 동일한 참조 클럭을 사용하는 경우 동일한 시스템에서 실행중인 다른 프로세스와 값을 교환 할 수 있습니다. QElapsedTimer는 항상 동일한 시계를 사용하므로 동일한 시스템의 다른 프로세스에서 오는 값과 비교하는 것이 안전합니다. 다른 API에서 생성 된 값과 비교할 경우 사용 된 시계가 QElapsedTimer와 동일한 지 확인해야합니다 ( &lt;a href=&quot;qelapsedtimer#clockType&quot;&gt;QElapsedTimer :: clockType&lt;/a&gt; () 참조).</target>
        </trans-unit>
        <trans-unit id="96b5e003824b7fb36c46e3d718683ec93456a894" translate="yes" xml:space="preserve">
          <source>It knows about the application's windows. You can ask which widget is at a certain position using &lt;a href=&quot;qapplication#widgetAt&quot;&gt;widgetAt&lt;/a&gt;(), get a list of &lt;a href=&quot;qapplication#topLevelWidgets&quot;&gt;topLevelWidgets&lt;/a&gt;() and &lt;a href=&quot;qapplication#closeAllWindows&quot;&gt;closeAllWindows&lt;/a&gt;(), etc.</source>
          <target state="translated">응용 프로그램의 창에 대해 알고 있습니다. &lt;a href=&quot;qapplication#widgetAt&quot;&gt;widgetAt&lt;/a&gt; ()를 사용하여 특정 위치에있는 위젯을 묻거나 &lt;a href=&quot;qapplication#topLevelWidgets&quot;&gt;topLevelWidgets&lt;/a&gt; () 및 &lt;a href=&quot;qapplication#closeAllWindows&quot;&gt;closeAllWindows&lt;/a&gt; () 목록을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="adfabdb8918f791cda1cd765b01a30c22e7a40d8" translate="yes" xml:space="preserve">
          <source>It knows about the application's windows. You can ask which window is at a certain position using &lt;a href=&quot;qguiapplication#topLevelAt&quot;&gt;topLevelAt&lt;/a&gt;(), get a list of &lt;a href=&quot;qguiapplication#topLevelWindows&quot;&gt;topLevelWindows&lt;/a&gt;(), etc.</source>
          <target state="translated">응용 프로그램의 창에 대해 알고 있습니다. 다음을 사용하여 특정 위치에있는 창을 요청할 수 있습니다 &lt;a href=&quot;qguiapplication#topLevelAt&quot;&gt;topLevelAt을&lt;/a&gt; 목록을 얻을, () &lt;a href=&quot;qguiapplication#topLevelWindows&quot;&gt;topLevelWindows를&lt;/a&gt; (), 등</target>
        </trans-unit>
        <trans-unit id="f04538e94aac32b0c0477a52b1c871381ea9fcb7" translate="yes" xml:space="preserve">
          <source>It looks ok, but it isn't. It is supposed to be a FLWOR expression comprising a</source>
          <target state="translated">괜찮아 보이지만 그렇지 않습니다. 그것은 다음을 포함하는 FLWOR 식이어야합니다</target>
        </trans-unit>
        <trans-unit id="2085bcffca702e08bdfbc7b4942f6739c0ab544f" translate="yes" xml:space="preserve">
          <source>It manages the application's mouse cursor handling, see &lt;a href=&quot;qguiapplication#setOverrideCursor&quot;&gt;setOverrideCursor&lt;/a&gt;()</source>
          <target state="translated">응용 프로그램의 마우스 커서 처리를 관리합니다. &lt;a href=&quot;qguiapplication#setOverrideCursor&quot;&gt;setOverrideCursor&lt;/a&gt; ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3523656e9ec7b9d36af749008cf1e4939e04bad7" translate="yes" xml:space="preserve">
          <source>It may be reimplemented to cancel a request in the provider side, however, it is not mandatory.</source>
          <target state="translated">제공자 측에서 요청을 취소하기 위해 다시 구현 될 수 있지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f14e501ea1266048a4e90c8f3ad18b7a8d6a1ade" translate="yes" xml:space="preserve">
          <source>It may sometimes be even better to replace the function pointer with inheritance and virtual functions.</source>
          <target state="translated">함수 포인터를 상속 및 가상 함수로 바꾸는 것이 더 나은 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcd65614fe6afe280e7e91d32b3dbfb4f07f2d53" translate="yes" xml:space="preserve">
          <source>It might be tempting to write code like this:</source>
          <target state="translated">다음과 같은 코드를 작성하고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6fa2249876933504db883250a6c0cebc3e37bc7" translate="yes" xml:space="preserve">
          <source>It must be comprised of alphanumeric characters or underscores.</source>
          <target state="translated">영숫자 또는 밑줄로 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e08af898bb3206b4f32676e1c3f698e529bd33ff" translate="yes" xml:space="preserve">
          <source>It must begin with an uppercase letter.</source>
          <target state="translated">대문자로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="98149ab065b1c766981dbd45f6e2d1ba02451e79" translate="yes" xml:space="preserve">
          <source>It offers better performance with opaque objects, which occlude other objects. Skipping the rendering of pixels that are hidden behind fully opaque objects is a common and powerful 3D rendering optimization known as z-culling.</source>
          <target state="translated">다른 개체를 가리는 불투명 한 개체로 더 나은 성능을 제공합니다. 완전히 불투명 한 개체 뒤에 숨겨진 픽셀의 렌더링을 건너 뛰는 것은 z-culling으로 알려진 일반적이고 강력한 3D 렌더링 최적화입니다.</target>
        </trans-unit>
        <trans-unit id="31714c0c4fadba26a36b0428869d7e26c8782ea3" translate="yes" xml:space="preserve">
          <source>It offers many features expected from a modern text layout engine, including Unicode compliant rendering, line breaking and handling of cursor positioning. It can also produce and render device independent layout, something that is important for WYSIWYG applications.</source>
          <target state="translated">유니 코드 호환 렌더링, 줄 바꿈 및 커서 위치 처리 등 최신 텍스트 레이아웃 엔진에서 예상되는 많은 기능을 제공합니다. 또한 WYSIWYG 응용 프로그램에 중요한 장치 독립 레이아웃을 생성하고 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d9a11fcc91321b1d87ff12d3b782e69e46c766b" translate="yes" xml:space="preserve">
          <source>It overwrites any declarative binding that was in place. In most cases this is intended, but sometimes it can be unintentional. See &lt;a href=&quot;qtqml-syntax-propertybinding#debugging-overwriting-of-bindings&quot;&gt;Debugging overwriting of bindings&lt;/a&gt; for more information.</source>
          <target state="translated">제자리에 있던 선언적 바인딩을 덮어 씁니다. 대부분의 경우 이는 의도 된 것이지만 의도하지 않은 경우도 있습니다. 자세한 내용 &lt;a href=&quot;qtqml-syntax-propertybinding#debugging-overwriting-of-bindings&quot;&gt;은 바인딩 덮어 쓰기 디버깅&lt;/a&gt; 을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="6c60853010c1995a24ecea5a753ce35e81cc39d6" translate="yes" xml:space="preserve">
          <source>It parses common command line arguments and sets its internal state accordingly. See the &lt;a href=&quot;qapplication#QApplication&quot;&gt;constructor documentation&lt;/a&gt; below for more details.</source>
          <target state="translated">일반적인 명령 줄 인수를 구문 분석하고 그에 따라 내부 상태를 설정합니다. 자세한 내용은 아래 &lt;a href=&quot;qapplication#QApplication&quot;&gt;생성자 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="632c6adc7891fdaa5367b8b0083ba31c7ab0c239" translate="yes" xml:space="preserve">
          <source>It parses common command line arguments and sets its internal state accordingly. See the &lt;a href=&quot;qguiapplication#QGuiApplication&quot;&gt;constructor documentation&lt;/a&gt; below for more details.</source>
          <target state="translated">일반적인 명령 줄 인수를 구문 분석하고 그에 따라 내부 상태를 설정합니다. 자세한 내용은 아래 &lt;a href=&quot;qguiapplication#QGuiApplication&quot;&gt;생성자 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a7e3971c6623682e574c9cadb107cdc096c38282" translate="yes" xml:space="preserve">
          <source>It performs event handling, meaning that it receives events from the underlying window system and dispatches them to the relevant widgets. By using &lt;a href=&quot;qcoreapplication#sendEvent&quot;&gt;sendEvent&lt;/a&gt;() and &lt;a href=&quot;qcoreapplication#postEvent&quot;&gt;postEvent&lt;/a&gt;() you can send your own events to widgets.</source>
          <target state="translated">이벤트 처리를 수행합니다. 즉, 기본 윈도우 시스템에서 이벤트를 수신하여 관련 위젯으로 디스패치합니다. 사용하여 &lt;a href=&quot;qcoreapplication#sendEvent&quot;&gt;sendEvent&lt;/a&gt; ()와 &lt;a href=&quot;qcoreapplication#postEvent&quot;&gt;postEvent를&lt;/a&gt; () 당신은 위젯에 자신의 이벤트를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14c4cd14798684a073c1bdfdc117388f3c27ebcc" translate="yes" xml:space="preserve">
          <source>It performs event handling, meaning that it receives events from the underlying window system and dispatches them to the relevant widgets. You can send your own events to windows by using &lt;a href=&quot;qcoreapplication#sendEvent&quot;&gt;sendEvent&lt;/a&gt;() and &lt;a href=&quot;qcoreapplication#postEvent&quot;&gt;postEvent&lt;/a&gt;().</source>
          <target state="translated">이벤트 처리를 수행합니다. 즉, 기본 윈도우 시스템에서 이벤트를 수신하여 관련 위젯으로 디스패치합니다. &lt;a href=&quot;qcoreapplication#sendEvent&quot;&gt;sendEvent&lt;/a&gt; () 및 &lt;a href=&quot;qcoreapplication#postEvent&quot;&gt;postEvent&lt;/a&gt; () 를 사용하여 고유 한 이벤트를 창으로 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="050b65797d00e21770e115a76cb58158d9fc6f93" translate="yes" xml:space="preserve">
          <source>It prefers &lt;a href=&quot;qwidget#windowIcon-prop&quot;&gt;parent-&amp;gt;icon()&lt;/a&gt; if that exists.</source>
          <target state="translated">&lt;a href=&quot;qwidget#windowIcon-prop&quot;&gt;부모-&amp;gt; icon ()이&lt;/a&gt; 있으면 선호 합니다.</target>
        </trans-unit>
        <trans-unit id="b13f727fecb1f86f6b15b167a215d8db189b4067" translate="yes" xml:space="preserve">
          <source>It provides a declarative API for the functions in &lt;a href=&quot;qfontmetricsf&quot;&gt;QFontMetricsF&lt;/a&gt; which take arguments.</source>
          <target state="translated">인수를 취하는 &lt;a href=&quot;qfontmetricsf&quot;&gt;QFontMetricsF&lt;/a&gt; 의 함수에 대한 선언적 API를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="f35a825461329d8709373b9f9366c2aec6f8a5c9" translate="yes" xml:space="preserve">
          <source>It provides a light-weight foundation for writing your own custom items. This includes defining the item's geometry, collision detection, its painting implementation and item interaction through its event handlers. &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; is part of the &lt;a href=&quot;graphicsview#&quot;&gt;Graphics View Framework&lt;/a&gt;</source>
          <target state="translated">사용자 정의 항목을 작성하기위한 간단한 기초를 제공합니다. 여기에는 아이템의 지오메트리 정의, 충돌 감지, 페인팅 구현 및 이벤트 핸들러를 통한 아이템 인터랙션이 포함됩니다. &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 은 &lt;a href=&quot;graphicsview#&quot;&gt;Graphics View Framework의&lt;/a&gt; 일부입니다</target>
        </trans-unit>
        <trans-unit id="90154bd0d8b2882da0091be7935f3754a88a089d" translate="yes" xml:space="preserve">
          <source>It provides a light-weight foundation for writing your own custom items. This includes defining the item's geometry, collision detection, its painting implementation and item interaction through its event handlers. QGraphicsItem is part of the &lt;a href=&quot;graphicsview&quot;&gt;Graphics View Framework&lt;/a&gt;</source>
          <target state="translated">사용자 지정 항목을 작성하기위한 가벼운 기초를 제공합니다. 여기에는 항목의 지오메트리 정의, 충돌 감지, 페인팅 구현 및 이벤트 핸들러를 통한 항목 상호 작용이 포함됩니다. QGraphicsItem은 &lt;a href=&quot;graphicsview&quot;&gt;기하 창 프레임 워크의&lt;/a&gt; 일부입니다.</target>
        </trans-unit>
        <trans-unit id="b46433abaa855d46f9fa4e0279862009644e3e92" translate="yes" xml:space="preserve">
          <source>It provides a subset of the C++ &lt;a href=&quot;qfontmetricsf&quot;&gt;QFontMetricsF&lt;/a&gt; API, with the added ability to change the font that is used for calculations via the &lt;a href=&quot;qml-qtquick-fontmetrics#font-prop&quot;&gt;font&lt;/a&gt; property.</source>
          <target state="translated">C ++ &lt;a href=&quot;qfontmetricsf&quot;&gt;QFontMetricsF&lt;/a&gt; API 의 서브 세트를 제공하며 &lt;a href=&quot;qml-qtquick-fontmetrics#font-prop&quot;&gt;font&lt;/a&gt; 속성을 통해 계산에 사용되는 글꼴을 변경하는 기능이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c485af1851c7509ea785bbd299e55a562b582b2c" translate="yes" xml:space="preserve">
          <source>It provides localization of strings that are visible to the user via &lt;a href=&quot;qcoreapplication#translate&quot;&gt;translate&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qcoreapplication#translate&quot;&gt;translate&lt;/a&gt; () 를 통해 사용자에게 표시되는 문자열의 현지화를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="1b8290a1411daa6ed9e05d1511a4eb9c72c0a321" translate="yes" xml:space="preserve">
          <source>It provides some basic functionality that is common to other high level classes like &lt;a href=&quot;qmediaplayer&quot;&gt;QMediaPlayer&lt;/a&gt;, &lt;a href=&quot;qaudiodecoder&quot;&gt;QAudioDecoder&lt;/a&gt; and &lt;a href=&quot;qcamera&quot;&gt;QCamera&lt;/a&gt;, including availability and meta-data functionality, as well as functionality to connect media objects with support classes like &lt;a href=&quot;qmediaplaylist&quot;&gt;QMediaPlaylist&lt;/a&gt;.</source>
          <target state="translated">그것은 몇 가지 기본적인 같은 다른 높은 수준의 클래스에 공통 기능 제공 &lt;a href=&quot;qmediaplayer&quot;&gt;QMediaPlayer&lt;/a&gt; , &lt;a href=&quot;qaudiodecoder&quot;&gt;QAudioDecoder&lt;/a&gt; 및 &lt;a href=&quot;qcamera&quot;&gt;QCamera&lt;/a&gt; 같은 지원 클래스와 연결 미디어 객체에 대한 가용성 및 메타 데이터 기능을 포함하여,뿐만 아니라 기능 &lt;a href=&quot;qmediaplaylist&quot;&gt;QMediaPlaylist을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64ffaff4ef87aa7e8ce67b5e2e09a3dd8644e86a" translate="yes" xml:space="preserve">
          <source>It provides some magical objects like the &lt;a href=&quot;qapplication#desktop&quot;&gt;desktop&lt;/a&gt;() and the &lt;a href=&quot;qguiapplication#clipboard&quot;&gt;clipboard&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qapplication#desktop&quot;&gt;바탕 화면&lt;/a&gt; () 및 &lt;a href=&quot;qguiapplication#clipboard&quot;&gt;클립 보드&lt;/a&gt; () 와 같은 마술 같은 물건을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d996c81db2eee1f908376e66f6838c7a90223734" translate="yes" xml:space="preserve">
          <source>It provides some magical objects like the &lt;a href=&quot;qguiapplication#clipboard&quot;&gt;clipboard&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qguiapplication#clipboard&quot;&gt;클립 보드&lt;/a&gt; () 와 같은 마술 같은 물건을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="283e6e02bf9f8242f6f54559d493484cf0c532a7" translate="yes" xml:space="preserve">
          <source>It provides support for sophisticated &lt;a href=&quot;ipc#session-management&quot;&gt;session management&lt;/a&gt;. This makes it possible for applications to terminate gracefully when the user logs out, to cancel a shutdown process if termination isn't possible and even to preserve the entire application's state for a future session. See &lt;a href=&quot;qguiapplication#isSessionRestored&quot;&gt;isSessionRestored&lt;/a&gt;(), &lt;a href=&quot;qguiapplication#sessionId&quot;&gt;sessionId&lt;/a&gt;() and &lt;a href=&quot;qguiapplication#commitDataRequest&quot;&gt;commitDataRequest&lt;/a&gt;() and &lt;a href=&quot;qguiapplication#saveStateRequest&quot;&gt;saveStateRequest&lt;/a&gt;() for details.</source>
          <target state="translated">정교한 &lt;a href=&quot;ipc#session-management&quot;&gt;세션 관리를&lt;/a&gt; 지원합니다 . 이를 통해 사용자가 로그 아웃 할 때 응용 프로그램이 정상적으로 종료되고 종료가 불가능한 경우 종료 프로세스를 취소하고 향후 세션을 위해 전체 응용 프로그램의 상태를 보존 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;qguiapplication#isSessionRestored&quot;&gt;isSessionRestored&lt;/a&gt; (), &lt;a href=&quot;qguiapplication#sessionId&quot;&gt;sessionId&lt;/a&gt; () 및 &lt;a href=&quot;qguiapplication#commitDataRequest&quot;&gt;commitDataRequest&lt;/a&gt; () 및 &lt;a href=&quot;qguiapplication#saveStateRequest&quot;&gt;saveStateRequest&lt;/a&gt; ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bb54262d5f3ed96e8c0a927bd467690ff5f4acc6" translate="yes" xml:space="preserve">
          <source>It returns an empty record, having only the field names. This function can be used to retrieve the field names of a record.</source>
          <target state="translated">필드 이름 만 가진 빈 레코드를 반환합니다. 이 함수는 레코드의 필드 이름을 검색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccc4d02d916dd76317ee65171b87d4f776c60066" translate="yes" xml:space="preserve">
          <source>It serves as a hook to display a custom language dialog instead of the built-in language popup in the virtual keyboard.</source>
          <target state="translated">가상 키보드의 내장 언어 팝업 대신 사용자 정의 언어 대화 상자를 표시하는 후크 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="5bbad91b4449ab7a9e800a20dffc948f12256d54" translate="yes" xml:space="preserve">
          <source>It serves no purpose outside the &lt;a href=&quot;qsgmaterial#type&quot;&gt;QSGMaterial::type&lt;/a&gt;() function.</source>
          <target state="translated">&lt;a href=&quot;qsgmaterial#type&quot;&gt;QSGMaterial :: type&lt;/a&gt; () 함수 이외의 용도로는 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fda683c69d529cee77d881c4434439ca51610ae7" translate="yes" xml:space="preserve">
          <source>It sets the &lt;a href=&quot;qaccessible-state&quot;&gt;states&lt;/a&gt; that are common for all widgets.</source>
          <target state="translated">모든 위젯에 공통적 인 &lt;a href=&quot;qaccessible-state&quot;&gt;상태&lt;/a&gt; 를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="0445b3a583d439420b88cc1a7abb39cf5a9d6370" translate="yes" xml:space="preserve">
          <source>It sets the &lt;a href=&quot;qapplication#activeWindow&quot;&gt;activeWindow&lt;/a&gt;() and &lt;a href=&quot;qapplication#focusWidget&quot;&gt;focusWidget&lt;/a&gt;() attributes and sends proper &lt;a href=&quot;qevent#Type-enum&quot;&gt;WindowActivate&lt;/a&gt;/&lt;a href=&quot;qevent#Type-enum&quot;&gt;WindowDeactivate&lt;/a&gt; and &lt;a href=&quot;qevent#Type-enum&quot;&gt;FocusIn&lt;/a&gt;/&lt;a href=&quot;qevent#Type-enum&quot;&gt;FocusOut&lt;/a&gt; events to all appropriate widgets. The window will then be painted in active state (e.g. cursors in line edits will blink), and it will have tool tips enabled.</source>
          <target state="translated">그것은 설정 &lt;a href=&quot;qapplication#activeWindow&quot;&gt;activeWindow&lt;/a&gt; ()와 &lt;a href=&quot;qapplication#focusWidget&quot;&gt;focusWidget를&lt;/a&gt; ) (속성 및 적절한 전송 &lt;a href=&quot;qevent#Type-enum&quot;&gt;WindowActivate&lt;/a&gt; / &lt;a href=&quot;qevent#Type-enum&quot;&gt;WindowDeactivate&lt;/a&gt; 와 &lt;a href=&quot;qevent#Type-enum&quot;&gt;하는 focusIn&lt;/a&gt; / &lt;a href=&quot;qevent#Type-enum&quot;&gt;대한 focusOut&lt;/a&gt; 모든 적절한 위젯 이벤트를. 그런 다음 창은 활성 상태로 페인트되고 (예 : 라인 편집의 커서가 깜박임) 도구 설명이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="7eda81c1968458d5a323115fab84bd2ccdc93114" translate="yes" xml:space="preserve">
          <source>It should be also noted that, at the Cocoa level, there is a difference between top-level windows and views (widgets that are inside a window). For this reason, make sure that the NSView that you are wrapping doesn't end up as a top-level window. The best way to ensure this is to make sure &lt;a href=&quot;qmaccocoaviewcontainer&quot;&gt;QMacCocoaViewContainer&lt;/a&gt;'s parent widget is not null.</source>
          <target state="translated">Cocoa 수준에서는 최상위 창과보기 (창 안에있는 위젯)간에 차이가 있습니다. 따라서 래핑중인 NSView가 최상위 창으로 끝나지 않아야합니다. 이를 보장하는 가장 좋은 방법은 &lt;a href=&quot;qmaccocoaviewcontainer&quot;&gt;QMacCocoaViewContainer&lt;/a&gt; 의 상위 위젯이 널이 아닌지 확인하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="f8846eeb96cebb771712a2fcea4b0a96cc1a4350" translate="yes" xml:space="preserve">
          <source>It should be also noted that, at the Cocoa level, there is a difference between top-level windows and views (widgets that are inside a window). For this reason, make sure that the NSView that you are wrapping doesn't end up as a top-level window. The best way to ensure this is to make sure QMacCocoaViewContainer's parent widget is not null.</source>
          <target state="translated">또한 Cocoa 수준에서는 최상위 창과 뷰 (창 안에있는 위젯)간에 차이가 있습니다. 이러한 이유로 래핑하는 NSView가 최상위 창으로 끝나지 않는지 확인하십시오. 이를 확인하는 가장 좋은 방법은 QMacCocoaViewContainer의 상위 위젯이 null이 아닌지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="99b3377a8c2a1a66f65a224727042954df20e5ef" translate="yes" xml:space="preserve">
          <source>It should be noted that a particle system can be disabled when not in use (for example, on a non-visible element) to avoid doing unnecessary simulation.</source>
          <target state="translated">불필요한 시뮬레이션을 피하기 위해 파티클 시스템을 사용하지 않을 때 (예 : 보이지 않는 요소에서) 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78642e380689c855b717abcbaaf70a28ed1e02fa" translate="yes" xml:space="preserve">
          <source>It should be noted that any of the criteria may be missing or unknown (an empty &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; for the hostname or protocol name, -1 for the port numbers). If that happens, the functions executing the query should make their best guess or apply some implementation-defined default values.</source>
          <target state="translated">기준 중 하나가 누락되었거나 알 수 없음 ( 호스트 이름 또는 프로토콜 이름의 경우 비어있는 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; , 포트 번호의 경우 -1)에 유의하십시오 . 이 경우 쿼리를 실행하는 함수가 최선의 추측을하거나 구현 정의 된 기본값을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9c5ae5f91fb472de6291442bc5fc5295c247a91" translate="yes" xml:space="preserve">
          <source>It should be noted that the orientation sensor reports the orientation of the device and not the UI. The orientation of the device will not change just because the UI is rotated. This means this sensor cannot be used to detect if a device is in portrait or landscape mode.</source>
          <target state="translated">방향 센서는 UI가 아닌 장치의 방향을보고합니다. UI가 회전되어 장치의 방향이 바뀌지 않습니다. 즉,이 센서를 사용하여 장치가 세로 또는 가로 모드인지 감지 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="72b5cf9526e4bc287e3e47cc45999c0b24495b40" translate="yes" xml:space="preserve">
          <source>It should be noted that, while the pointer value can be accessed in this manner (that is, by multiple threads at the same time, without synchronization), &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; and &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; provide no guarantee about the object being pointed to. The specific thread-safety and reentrancy rules for that object still apply.</source>
          <target state="translated">포인터 값은 이런 방식으로 (즉, 동기화없이 동시에 여러 스레드에 의해) 액세스 될 수 있지만 &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; 와 &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; 는 지시 된 오브젝트에 대해 보증하지 않습니다. 해당 객체에 대한 특정 스레드 안전성 및 재진입 규칙이 여전히 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c5d8b7f0d67184b7e61662bce5cb9ffb8a2327b1" translate="yes" xml:space="preserve">
          <source>It should be noted that, while the pointer value can be accessed in this manner (that is, by multiple threads at the same time, without synchronization), QSharedPointer and &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; provide no guarantee about the object being pointed to. The specific thread-safety and reentrancy rules for that object still apply.</source>
          <target state="translated">포인터 값은 이러한 방식으로 (즉, 동기화없이 동시에 여러 스레드에 의해) 액세스 할 수 있지만 QSharedPointer 및 &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; 는 가리키는 개체에 대한 보장을 제공하지 않습니다. 해당 객체에 대한 특정 스레드 안전성 및 재진입 규칙이 계속 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ca1f319524ba9d65b1d96320ecac98b9286b55de" translate="yes" xml:space="preserve">
          <source>It should be noted this may not reflect the actual buttons held on the input device at the time of calling but rather the mouse buttons as last reported in one of the above events. If no mouse buttons are being held &lt;a href=&quot;qt#MouseButton-enum&quot;&gt;Qt::NoButton&lt;/a&gt; is returned.</source>
          <target state="translated">이는 호출시 입력 장치에 고정 된 실제 버튼이 아니라 위의 이벤트 중 하나에서 마지막으로보고 된 마우스 버튼을 반영 할 수 있습니다. 마우스 버튼을 누르고 있지 않으면 &lt;a href=&quot;qt#MouseButton-enum&quot;&gt;Qt :: NoButton&lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="225279f26811d096f6f42d126b29339419d9b434" translate="yes" xml:space="preserve">
          <source>It should be noted this may not reflect the actual keys held on the input device at the time of calling but rather the modifiers as last reported in one of the above events. If no keys are being held &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt::NoModifier&lt;/a&gt; is returned.</source>
          <target state="translated">이는 호출시 입력 장치에 보유 된 실제 키가 아니라 위의 이벤트 중 하나에서 마지막으로보고 된 수정자를 반영 할 수 있습니다. 키를 누르고 있지 않으면 &lt;a href=&quot;qt#KeyboardModifier-enum&quot;&gt;Qt :: NoModifier&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="139fcba7fc599169861a807a06e15306ee61867f" translate="yes" xml:space="preserve">
          <source>It should not be constructed separately, instead the &lt;code&gt;exposure&lt;/code&gt; property of the a &lt;a href=&quot;qml-multimedia#camera&quot;&gt;Camera&lt;/a&gt; should be used.</source>
          <target state="translated">별도로 구성하지 말고 &lt;a href=&quot;qml-multimedia#camera&quot;&gt;카메라&lt;/a&gt; 의 &lt;code&gt;exposure&lt;/code&gt; 속성을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="25f7812fb5b0dba4991d8aebb2ac2d703e29075c" translate="yes" xml:space="preserve">
          <source>It should not be constructed separately, instead the &lt;code&gt;flash&lt;/code&gt; property of a &lt;a href=&quot;qml-multimedia#camera&quot;&gt;Camera&lt;/a&gt; should be used.</source>
          <target state="translated">별도로 구성하지 말고 대신 &lt;a href=&quot;qml-multimedia#camera&quot;&gt;카메라&lt;/a&gt; 의 &lt;code&gt;flash&lt;/code&gt; 속성을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="21f2bc77ae30107dc8fa8e907779df90ecc9f652" translate="yes" xml:space="preserve">
          <source>It should not be constructed separately, instead the &lt;code&gt;focus&lt;/code&gt; property of a &lt;a href=&quot;qml-multimedia#camera&quot;&gt;Camera&lt;/a&gt; should be used.</source>
          <target state="translated">별도로 구성하지 말고 &lt;a href=&quot;qml-multimedia#camera&quot;&gt;카메라&lt;/a&gt; 의 &lt;code&gt;focus&lt;/code&gt; 속성을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="bc5767a67208ac0fc1c008aabf398067d4e6343e" translate="yes" xml:space="preserve">
          <source>It should not be constructed separately, instead the &lt;code&gt;imageProcessing&lt;/code&gt; property of a &lt;a href=&quot;qml-multimedia#camera&quot;&gt;Camera&lt;/a&gt; should be used.</source>
          <target state="translated">별도로 구성하지 말고 &lt;a href=&quot;qml-multimedia#camera&quot;&gt;카메라&lt;/a&gt; 의 &lt;code&gt;imageProcessing&lt;/code&gt; 속성을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="862c55946b6ffcc84531f03f03e0d23ff4173d6a" translate="yes" xml:space="preserve">
          <source>It should not be constructed separately, instead the &lt;code&gt;videoRecorder&lt;/code&gt; property of a &lt;a href=&quot;qml-multimedia#camera&quot;&gt;Camera&lt;/a&gt; should be used.</source>
          <target state="translated">별도로 구성하지 말고 &lt;a href=&quot;qml-multimedia#camera&quot;&gt;카메라&lt;/a&gt; 의 &lt;code&gt;videoRecorder&lt;/code&gt; 속성을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="37f2b0e227cfe45bf881394f78a26bc9e3650a8f" translate="yes" xml:space="preserve">
          <source>It should not be set directly on the item, like in the below QML, as the specified value will be overridden and lost on focus changes.</source>
          <target state="translated">아래의 QML과 같이 항목에 직접 설정하면 포커스 값 변경시 지정된 값이 무시되고 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="f2e0538e9ef3f8b3d343c494bfc8705ab1294b36" translate="yes" xml:space="preserve">
          <source>It should not generally be necessary to refer to the &lt;code&gt;choices&lt;/code&gt; property, as it is the default property for &lt;a href=&quot;qml-qt-labs-qmlmodels-delegatechooser&quot;&gt;DelegateChooser&lt;/a&gt; and thus all child items are automatically assigned to this property.</source>
          <target state="translated">&lt;code&gt;choices&lt;/code&gt; 속성 은 일반적으로 &lt;a href=&quot;qml-qt-labs-qmlmodels-delegatechooser&quot;&gt;DelegateChooser&lt;/a&gt; 의 기본 속성 이므로 모든 자식 항목이이 속성에 자동으로 할당되므로 선택 속성 을 참조 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a2e858a4aeeda5adf9ed6da2289ed28e50552292" translate="yes" xml:space="preserve">
          <source>It should not generally be necessary to refer to the &lt;code&gt;data&lt;/code&gt; property, as it is the default property for Item and thus all child items are automatically assigned to this property.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 속성은 Item의 기본 속성이므로 모든 자식 항목이이 속성에 자동으로 할당되므로 일반적으로 data 속성 을 참조 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7539a8ca138e1f5602580a3f05b473ae419b23ec" translate="yes" xml:space="preserve">
          <source>It should not generally be necessary to refer to the &lt;code&gt;data&lt;/code&gt; property, as it is the default property for Window and thus all child items are automatically assigned to this property.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 속성은 Window의 기본 속성이므로 모든 자식 항목이이 속성에 자동으로 할당되므로 일반적으로 data 속성 을 참조 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="022debcd710bf394c10119619abc7e39207e78c7" translate="yes" xml:space="preserve">
          <source>It should not generally be necessary to refer to the contentData property, as it is the default property for &lt;a href=&quot;qml-qtquick-controls2-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; and thus all child items are automatically assigned to this property.</source>
          <target state="translated">contentWindow 속성은 &lt;a href=&quot;qml-qtquick-controls2-applicationwindow&quot;&gt;ApplicationWindow&lt;/a&gt; 의 기본 속성 이므로 모든 자식 항목이이 속성에 자동으로 할당되므로 일반적으로 contentData 속성을 참조 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b707c1833e629aa8ee6d45ca3a899b9f9d0437c0" translate="yes" xml:space="preserve">
          <source>It specifies how the application is to allocate colors. See setColorSpec() for details.</source>
          <target state="translated">응용 프로그램이 색상을 할당하는 방법을 지정합니다. 자세한 내용은 setColorSpec ()을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="24078cc39e4d72efcf776d430a8f61553e567f95" translate="yes" xml:space="preserve">
          <source>It tells Qt not to define the moc keywords &lt;code&gt;signals&lt;/code&gt;, &lt;code&gt;slots&lt;/code&gt;, and &lt;code&gt;emit&lt;/code&gt;, because these names will be used by a 3rd party library, e.g. Boost. Then to continue using Qt signals and slots with the &lt;code&gt;no_keywords&lt;/code&gt; flag, simply replace all uses of the Qt moc keywords in your sources with the corresponding Qt macros &lt;a href=&quot;qobject#Q_SIGNALS&quot;&gt;Q_SIGNALS&lt;/a&gt; (or &lt;a href=&quot;qobject#Q_SIGNAL&quot;&gt;Q_SIGNAL&lt;/a&gt;), &lt;a href=&quot;qobject#Q_SLOTS&quot;&gt;Q_SLOTS&lt;/a&gt; (or &lt;a href=&quot;qobject#Q_SLOT&quot;&gt;Q_SLOT&lt;/a&gt;), and &lt;a href=&quot;qobject#Q_EMIT&quot;&gt;Q_EMIT&lt;/a&gt;.</source>
          <target state="translated">그것은 mot 키워드 &lt;code&gt;signals&lt;/code&gt; , &lt;code&gt;slots&lt;/code&gt; 및 &lt;code&gt;emit&lt;/code&gt; 를 정의하지 말라고 Qt에 지시합니다. 이러한 이름은 타사 라이브러리 (예 : Boost)에서 사용되기 때문입니다. 그런 다음 &lt;code&gt;no_keywords&lt;/code&gt; 플래그 와 함께 Qt 신호 및 슬롯을 계속 사용하려면 소스의 Qt moc 키워드를 해당 Qt 매크로 &lt;a href=&quot;qobject#Q_SIGNALS&quot;&gt;Q_SIGNALS&lt;/a&gt; (또는 &lt;a href=&quot;qobject#Q_SIGNAL&quot;&gt;Q_SIGNAL&lt;/a&gt; ), &lt;a href=&quot;qobject#Q_SLOTS&quot;&gt;Q_SLOTS&lt;/a&gt; (또는 &lt;a href=&quot;qobject#Q_SLOT&quot;&gt;Q_SLOT&lt;/a&gt; ) 및 &lt;a href=&quot;qobject#Q_EMIT&quot;&gt;Q_EMIT로 바꾸십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f9c9e0080851b573b637cbf1457e9e6ab53587c6" translate="yes" xml:space="preserve">
          <source>It uses</source>
          <target state="translated">사용합니다</target>
        </trans-unit>
        <trans-unit id="8dc8881339a0a74b1fe0fb15ac829b0d2fc2bfa6" translate="yes" xml:space="preserve">
          <source>It uses a fast, binary message-passing protocol, which is suitable for same-machine communication due to its low latency and low overhead. Its specification is currently defined by the &lt;code&gt;freedesktop.org&lt;/code&gt; project, and is available to all parties.</source>
          <target state="translated">빠른 이진 메시지 전달 프로토콜을 사용합니다.이 프로토콜은 대기 시간이 짧고 오버 헤드가 적기 때문에 동일한 컴퓨터 통신에 적합합니다. 사양은 현재 &lt;code&gt;freedesktop.org&lt;/code&gt; 프로젝트에 의해 정의되며 모든 당사자가 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de256e7a1b61da59357d8b0dc0413b9b7ad9a396" translate="yes" xml:space="preserve">
          <source>It uses the same algorithm used in &lt;a href=&quot;qcolor#setNamedColor&quot;&gt;setNamedColor&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qcolor#setNamedColor&quot;&gt;setNamedColor&lt;/a&gt; () 에 사용 된 것과 동일한 알고리즘을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="d02616b17fc0f50dd565ca20adc50b4c4e43de2a" translate="yes" xml:space="preserve">
          <source>It was largely written by Mizi Research Inc. Here is the copyright statement for the code as it was at the point of contribution. The subsequent modifications are covered by the usual copyright for Qt.</source>
          <target state="translated">이 문서는 Mizi Research Inc.가 주로 작성했습니다. 다음은 코드 작성 시점의 코드에 대한 저작권 정보입니다. 후속 수정 사항은 Qt에 대한 일반 저작권이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d6583644a469f2d7b42e7815e504b6d5a3ead750" translate="yes" xml:space="preserve">
          <source>It will appear in the generated HTML as:</source>
          <target state="translated">생성 된 HTML에 다음과 같이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="89bd17c3c15a3f07500a2b8f94cd76f7340088c8" translate="yes" xml:space="preserve">
          <source>It will return the Android, iOS, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, Windows full-product versions on those systems.</source>
          <target state="translated">해당 시스템 에서 Android, iOS, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; , Windows 정식 버전을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="536f7912a4dccfd870decd78af38f7c7c7d1a510" translate="yes" xml:space="preserve">
          <source>It will return the Android, iOS, macOS, Windows full-product versions on those systems.</source>
          <target state="translated">해당 시스템에서 Android, iOS, macOS, Windows 전체 제품 버전을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e4e5994d267fbe49e27f06b791f4bdf75608ef62" translate="yes" xml:space="preserve">
          <source>It will trigger property binding updates every time &lt;a href=&quot;qml-qtqml-models-itemselectionmodel#selectionChanged-signal&quot;&gt;selectionChanged()&lt;/a&gt; is emitted, even though its value hasn't changed.</source>
          <target state="translated">&lt;a href=&quot;qml-qtqml-models-itemselectionmodel#selectionChanged-signal&quot;&gt;selectionChanged ()&lt;/a&gt; 가 생성 될 때마다 값이 변경되지 않은 경우에도 속성 바인딩 업데이트를 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="8a6477358ad587b294197262e6276126bdbe8040" translate="yes" xml:space="preserve">
          <source>It won't match anything because &lt;code&gt;index.html&lt;/code&gt; is an XHTML file, and all XHTML files declare the default namespace &lt;code&gt;&quot;http://www.w3.org/1999/xhtml&quot;&lt;/code&gt; in their top (&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;) element. But the query doesn't declare this namespace, so the path expression expands &lt;code&gt;html&lt;/code&gt; to &lt;code&gt;{}html&lt;/code&gt; and tries to match that expanded name. But the actual expanded name is &lt;code&gt;{http://www.w3.org/1999/xhtml}html&lt;/code&gt;. One possible fix is to declare the correct default namespace in the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;index.html&lt;/code&gt; 은 XHTML 파일이고 모든 XHTML 파일 은 최상위 ( &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; ) 요소에 기본 네임 스페이스 &lt;code&gt;&quot;http://www.w3.org/1999/xhtml&quot;&lt;/code&gt; 을 선언 하기 때문에 일치하지 않습니다 . 그러나 쿼리는이 네임 스페이스를 선언하지 않으므로 경로 표현식은 &lt;code&gt;html&lt;/code&gt; 을 &lt;code&gt;{}html&lt;/code&gt; 로 확장하고 확장 된 이름과 일치 시키려고합니다. 그러나 실제 확장 된 이름은 &lt;code&gt;{http://www.w3.org/1999/xhtml}html&lt;/code&gt; 입니다. 한 가지 가능한 수정 사항은 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 에서 올바른 기본 네임 스페이스를 선언하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="048907aa33c8dde564b20f9479d2cb5ee71b994c" translate="yes" xml:space="preserve">
          <source>It won't match anything because &lt;code&gt;index.html&lt;/code&gt; is an XHTML file, and all XHTML files declare the default namespace &lt;code&gt;&quot;http://www.w3.org/1999/xhtml&quot;&lt;/code&gt; in their top (&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;) element. But the query doesn't declare this namespace, so the path expression expands &lt;code&gt;html&lt;/code&gt; to &lt;code&gt;{}html&lt;/code&gt; and tries to match that expanded name. But the actual expanded name is &lt;code&gt;{http://www.w3.org/1999/xhtml}html&lt;/code&gt;. One possible fix is to declare the correct default namespace in the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;index.html&lt;/code&gt; 이 XHTML 파일이므로 모든 XHTML 파일 이 맨 위 ( &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; ) 요소에 기본 네임 스페이스 &lt;code&gt;&quot;http://www.w3.org/1999/xhtml&quot;&lt;/code&gt; 을 선언 하므로 아무 것도 일치하지 않습니다 . 그러나 쿼리는이 네임 스페이스를 선언하지 않으므로 경로 표현식은 &lt;code&gt;html&lt;/code&gt; 을 &lt;code&gt;{}html&lt;/code&gt; 로 확장하고 확장 된 이름과 일치 시키려고합니다. 그러나 실제 확장 이름은 &lt;code&gt;{http://www.w3.org/1999/xhtml}html&lt;/code&gt; 입니다. 가능한 한 가지 수정은 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 에서 올바른 기본 네임 스페이스를 선언하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="9dcfb8c304508b3595d3fe6b6f4753c041719595" translate="yes" xml:space="preserve">
          <source>It won't use the hardware cursor (falls back to rendering the mouse cursor via OpenGL; by default hardware cursors are enabled as they're more efficient).</source>
          <target state="translated">하드웨어 커서를 사용하지 않습니다 (OpenGL을 통해 마우스 커서를 렌더링하는 것으로 돌아갑니다. 기본적으로 하드웨어 커서는 더 효율적이므로 활성화됩니다).</target>
        </trans-unit>
        <trans-unit id="0bdfc7f59226ccb058609606896b72315c818434" translate="yes" xml:space="preserve">
          <source>It works as expected. The sequence of QDoc commands and text found between the two tags with the same name as the second argument is sent to the QDoc input stream. You can even have nested snippets.</source>
          <target state="translated">예상대로 작동합니다. 두 번째 인수와 동일한 이름을 가진 두 태그 사이에있는 QDoc 명령 시퀀스와 텍스트는 QDoc 입력 스트림으로 전송됩니다. 중첩 된 스 니펫을 가질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b770672fd5f67483ec92c1ac51fe1fe5dde1054a" translate="yes" xml:space="preserve">
          <source>It works as follows: The &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; to iterate over is passed to the &lt;a href=&quot;qlistiterator&quot;&gt;QListIterator&lt;/a&gt; constructor. At that point, the iterator is located just in front of the first item in the list (before item &quot;A&quot;). Then we call &lt;a href=&quot;qlistiterator#hasNext&quot;&gt;hasNext()&lt;/a&gt; to check whether there is an item after the iterator. If there is, we call &lt;a href=&quot;qlistiterator#next&quot;&gt;next()&lt;/a&gt; to jump over that item. The next() function returns the item that it jumps over. For a &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;&amp;gt;, that item is of type &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;.</source>
          <target state="translated">반복 되는 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 는 &lt;a href=&quot;qlistiterator&quot;&gt;QListIterator&lt;/a&gt; 생성자로 전달됩니다 . 이 시점에서 반복자는 목록의 첫 번째 항목 바로 앞에 있습니다 (항목 &quot;A&quot;앞). 그런 다음 &lt;a href=&quot;qlistiterator#hasNext&quot;&gt;hasNext ()&lt;/a&gt; 를 호출 하여 반복자 뒤에 항목이 있는지 확인합니다. 있는 경우 &lt;a href=&quot;qlistiterator#next&quot;&gt;next ()&lt;/a&gt; 를 호출 하여 해당 항목을 건너 뜁니다. next () 함수는 건너 뛴 항목을 반환합니다. A에 대한 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; &amp;lt; &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;gt; 해당 항목이 형이다 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d0890e37eed266b66cb9efed088e58ed917241a" translate="yes" xml:space="preserve">
          <source>It works exactly like the &lt;a href=&quot;qobject#Q_NAMESPACE&quot;&gt;Q_NAMESPACE&lt;/a&gt; macro. However, the external &lt;code&gt;staticMetaObject&lt;/code&gt; variable that gets defined in the namespace is declared with the supplied</source>
          <target state="translated">&lt;a href=&quot;qobject#Q_NAMESPACE&quot;&gt;Q_NAMESPACE&lt;/a&gt; 매크로 와 똑같이 작동합니다 . 그러나 네임 스페이스에 정의 된 외부 &lt;code&gt;staticMetaObject&lt;/code&gt; 변수는 제공된</target>
        </trans-unit>
        <trans-unit id="7ca919b67c5952b96becabdbdc9fb5fa7381586c" translate="yes" xml:space="preserve">
          <source>It would also be possible to put all the logic in one place, in a &lt;a href=&quot;qwizard#nextId&quot;&gt;QWizard::nextId&lt;/a&gt;() reimplementation. For example:</source>
          <target state="translated">&lt;a href=&quot;qwizard#nextId&quot;&gt;QWizard :: nextId&lt;/a&gt; () 재 구현 에서 모든 로직을 한 곳에 배치 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4d1a18266c745e51a78d1b68c1e9ab43d0ab67b8" translate="yes" xml:space="preserve">
          <source>It would have also been possible to make one call to &lt;a href=&quot;qrandomgenerator#generate64&quot;&gt;generate64&lt;/a&gt;() and then split the two halves of the 64-bit value.</source>
          <target state="translated">&lt;a href=&quot;qrandomgenerator#generate64&quot;&gt;generate64&lt;/a&gt; () 를 한 번 호출 한 다음 64 비트 값의 두 부분을 분할하는 것도 가능했을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="38a4b9c94883abc63cb9f5899f0e991708646693" translate="yes" xml:space="preserve">
          <source>It's allowed to change capture mode in any camera state, but if the camera is currently active, chaging capture mode is likely to lead to camera status chaged to &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera::LoadedStatus&lt;/a&gt;, &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera::LoadingStatus&lt;/a&gt;, and when the camera is ready to &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera::ActiveStatus&lt;/a&gt;.</source>
          <target state="translated">모든 카메라 상태에서 캡처 모드를 변경할 수 있지만 현재 카메라가 활성화되어있는 경우 캡처 모드를 사용하면 카메라 상태가 &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera :: LoadedStatus&lt;/a&gt; , &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera :: LoadingStatus로&lt;/a&gt; , 카메라가 &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera에&lt;/a&gt; 준비 될 때 : ActiveStatus .</target>
        </trans-unit>
        <trans-unit id="befdc05c66921d6537eb79537f07159a2270ce12" translate="yes" xml:space="preserve">
          <source>It's also acceptable to relock already locked settings, depending on the lock parameter this initiates new focusing, exposure or white balance calculation.</source>
          <target state="translated">잠금 매개 변수에 따라 새로운 초점 조정, 노출 또는 화이트 밸런스 계산을 시작하는 이미 잠금 설정을 다시 잠글 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb233380d0baf33d1ac5d03957b95fd6d88ec905" translate="yes" xml:space="preserve">
          <source>It's also common to use &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; to read console input and write console output. &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; is locale aware, and will automatically decode standard input using the correct codec. Example:</source>
          <target state="translated">&lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; 을 사용 하여 콘솔 입력을 읽고 콘솔 출력을 쓰는 것도 일반적 입니다. &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; 은 로케일을 인식하며 올바른 코덱을 사용하여 표준 입력을 자동으로 디코딩합니다. 예:</target>
        </trans-unit>
        <trans-unit id="b58e7f7d1a5dbab475d819064694f98e38b230e2" translate="yes" xml:space="preserve">
          <source>It's also common to use QTextStream to read console input and write console output. QTextStream is locale aware, and will automatically decode standard input using the correct codec. Example:</source>
          <target state="translated">콘솔 입력을 읽고 콘솔 출력을 쓰기 위해 QTextStream을 사용하는 것도 일반적입니다. QTextStream은 로케일을 인식하며 올바른 코덱을 사용하여 표준 입력을 자동으로 디코딩합니다. 예:</target>
        </trans-unit>
        <trans-unit id="259ccf2135186a55a894925c321f93fd84a50877" translate="yes" xml:space="preserve">
          <source>It's also possible for applications or third-party libraries and toolkits to create and insert messages in the debug log. In order to do so, you can use the &lt;a href=&quot;qopengldebugmessage#createApplicationMessage&quot;&gt;createApplicationMessage&lt;/a&gt;() or the &lt;a href=&quot;qopengldebugmessage#createThirdPartyMessage&quot;&gt;createThirdPartyMessage&lt;/a&gt;() static functions.</source>
          <target state="translated">응용 프로그램이나 타사 라이브러리 및 툴킷이 디버그 로그에 메시지를 작성하고 삽입 할 수도 있습니다. 그렇게하기 위해 &lt;a href=&quot;qopengldebugmessage#createApplicationMessage&quot;&gt;createApplicationMessage&lt;/a&gt; () 또는 &lt;a href=&quot;qopengldebugmessage#createThirdPartyMessage&quot;&gt;createThirdPartyMessage&lt;/a&gt; () 정적 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="488385a885ceac8608433f116b84708dfb1cfbe2" translate="yes" xml:space="preserve">
          <source>It's also possible to retrieve the starting and the ending offsets (inside the subject string) of each captured substring, by using the &lt;a href=&quot;qregularexpressionmatch#capturedStart&quot;&gt;capturedStart()&lt;/a&gt; and the &lt;a href=&quot;qregularexpressionmatch#capturedEnd&quot;&gt;capturedEnd()&lt;/a&gt; functions:</source>
          <target state="translated">&lt;a href=&quot;qregularexpressionmatch#capturedStart&quot;&gt;capturedStart ()&lt;/a&gt; 및 &lt;a href=&quot;qregularexpressionmatch#capturedEnd&quot;&gt;capturedEnd ()&lt;/a&gt; 함수 를 사용하여 캡처 된 각 하위 문자열의 시작 및 끝 오프셋 (제목 문자열 내)을 검색 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c75196d6814f5ca5f10ceb2c79c741f765d0d605" translate="yes" xml:space="preserve">
          <source>It's also possible to start a match at an arbitrary offset inside the subject string by passing the offset as an argument of the &lt;a href=&quot;qregularexpression#match&quot;&gt;match&lt;/a&gt;() function. In the following example &lt;code&gt;&quot;12 abc&quot;&lt;/code&gt; is not matched because the match is started at offset 1:</source>
          <target state="translated">&lt;a href=&quot;qregularexpression#match&quot;&gt;match&lt;/a&gt; () 함수 의 인수로 오프셋을 전달하여 제목 문자열 내에서 임의의 오프셋에서 일치를 시작할 수도 있습니다 . 다음 예 에서는 일치가 오프셋 1에서 시작되므로 &lt;code&gt;&quot;12 abc&quot;&lt;/code&gt; 가 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="147ea94bb3250d78868f58383d452dafa073d0e8" translate="yes" xml:space="preserve">
          <source>It's common to call fitInView() from inside a reimplementation of &lt;a href=&quot;qgraphicsview#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt;(), to ensure that the whole scene, or parts of the scene, scales automatically to fit the new size of the viewport as the view is resized. Note though, that calling fitInView() from inside &lt;a href=&quot;qgraphicsview#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt;() can lead to unwanted resize recursion, if the new transformation toggles the automatic state of the scrollbars. You can toggle the scrollbar policies to always on or always off to prevent this (see &lt;a href=&quot;qabstractscrollarea#horizontalScrollBarPolicy-prop&quot;&gt;horizontalScrollBarPolicy&lt;/a&gt;() and &lt;a href=&quot;qabstractscrollarea#verticalScrollBarPolicy-prop&quot;&gt;verticalScrollBarPolicy&lt;/a&gt;()).</source>
          <target state="translated">그것은의 재 구현 내부에서 () fitInView를 호출하는 것이 일반적이다 &lt;a href=&quot;qgraphicsview#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt; (), 뷰의 크기가 변경 될 때 자동으로 스케일이 뷰포트의 새로운 크기에 맞게, 그 전체 장면을 위해, 또는 장면의 일부입니다. 그러나 새 변환이 스크롤 막대의 자동 상태를 토글하는 경우 &lt;a href=&quot;qgraphicsview#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt; () 내부에서 fitInView ()를 호출 하면 원하지 않는 크기 조정 재귀가 발생할 수 있습니다. 이를 방지하기 위해 스크롤 막대 정책을 항상 사용 또는 사용 중지하도록 전환 할 수 있습니다 ( &lt;a href=&quot;qabstractscrollarea#horizontalScrollBarPolicy-prop&quot;&gt;horizontalScrollBarPolicy&lt;/a&gt; () 및 &lt;a href=&quot;qabstractscrollarea#verticalScrollBarPolicy-prop&quot;&gt;verticalScrollBarPolicy&lt;/a&gt; () 참조).</target>
        </trans-unit>
        <trans-unit id="bbd10b5236f6db72bddbee4b57ff66674f2736a4" translate="yes" xml:space="preserve">
          <source>It's common to connect the &lt;a href=&quot;qguiapplication#lastWindowClosed&quot;&gt;QGuiApplication::lastWindowClosed&lt;/a&gt;() signal to quit(), and you also often connect e.g. &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;QAbstractButton::clicked&lt;/a&gt;() or signals in &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt;, &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt;, or &lt;a href=&quot;qmenubar&quot;&gt;QMenuBar&lt;/a&gt; to it.</source>
          <target state="translated">&lt;a href=&quot;qguiapplication#lastWindowClosed&quot;&gt;QGuiApplication :: lastWindowClosed&lt;/a&gt; () 신호를 quit () 에 연결하는 것이 일반적 이며, &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;QAbstractButton :: clicked&lt;/a&gt; () 또는 &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; , &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; 또는 &lt;a href=&quot;qmenubar&quot;&gt;QMenuBar의&lt;/a&gt; 신호 도 종종 연결 합니다.</target>
        </trans-unit>
        <trans-unit id="c8c8e8a56110d0d95fbc510becf52ff3de3b9c6a" translate="yes" xml:space="preserve">
          <source>It's common to open a &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; in response to receiving a context menu event. Example:</source>
          <target state="translated">컨텍스트 메뉴 이벤트 수신에 대한 응답으로 &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; 를 여는 것이 일반적 입니다. 예:</target>
        </trans-unit>
        <trans-unit id="a12903f067a09160cf9d6d8bf10c1efd319d0025" translate="yes" xml:space="preserve">
          <source>It's easy to understand this behavior if we remember that the engine expects the subject string to be only a substring of the whole text we're looking for a match into (that is, how we said before, that the engine assumes that there are other characters beyond the end of the subject string).</source>
          <target state="translated">엔진이 제목 문자열이 우리가 찾고자하는 전체 텍스트의 하위 문자열 일 것으로 예상한다는 것을 기억하면이 동작을 이해하기 쉽습니다. 제목 문자열의 끝을 넘어서는 문자).</target>
        </trans-unit>
        <trans-unit id="514eabe773b2c5d57270826b78ebe5dfbd0e6f54" translate="yes" xml:space="preserve">
          <source>It's easy to understand this behaviour if we remember that the engine expects the subject string to be only a substring of the whole text we're looking for a match into (that is, how we said before, that the engine assumes that there are other characters beyond the end of the subject string).</source>
          <target state="translated">엔진이 주제 문자열이 일치시킬 전체 텍스트의 하위 문자열 일 것으로 예상한다는 것을 기억하면 쉽게 이해할 수 있습니다. 제목 문자열의 끝을 넘는 문자).</target>
        </trans-unit>
        <trans-unit id="61e345d6101dda4da8e36254184b2bffd576d760" translate="yes" xml:space="preserve">
          <source>It's encumbered by the manual delete calls. With &lt;a href=&quot;qscopedpointer&quot;&gt;QScopedPointer&lt;/a&gt;, the code can be simplified to:</source>
          <target state="translated">수동 삭제 호출에 의해 방해를받습니다. 로 &lt;a href=&quot;qscopedpointer&quot;&gt;QScopedPointer&lt;/a&gt; , 코드를 단순화 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e5034730aec3be9dabb248f610dea9c7582198aa" translate="yes" xml:space="preserve">
          <source>It's encumbered by the manual delete calls. With QScopedPointer, the code can be simplified to:</source>
          <target state="translated">수동 삭제 호출로 인해 방해가됩니다. QScopedPointer를 사용하면 코드를 다음과 같이 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b44a999204a02f01a2574682419707456f0b1895" translate="yes" xml:space="preserve">
          <source>It's good practice to always connect signals to this slot using a &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;QueuedConnection&lt;/a&gt;. If a signal connected (non-queued) to this slot is emitted before control enters the main event loop (such as before &quot;int main&quot; calls &lt;a href=&quot;qcoreapplication#exec&quot;&gt;exec()&lt;/a&gt;), the slot has no effect and the application never exits. Using a queued connection ensures that the slot will not be invoked until after control enters the main event loop.</source>
          <target state="translated">&lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;QueuedConnection을&lt;/a&gt; 사용하여 신호를 항상이 슬롯에 연결하는 것이 좋습니다 . 제어가 기본 이벤트 루프에 들어가기 전에 (예 : &quot;int main&quot;이 &lt;a href=&quot;qcoreapplication#exec&quot;&gt;exec ()를&lt;/a&gt; 호출하기 전에)이 슬롯에 연결된 (큐에없는) 신호가 발생 하면 슬롯이 영향을 미치지 않으며 응용 프로그램이 종료되지 않습니다. 대기 연결을 사용하면 제어가 기본 이벤트 루프에 들어갈 때까지 슬롯이 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e5873be8412f221225dc9c177cc89bdff85c521" translate="yes" xml:space="preserve">
          <source>It's important to note that &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; provides no automatic casting operators to prevent mistakes from happening. Even though &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; tracks a pointer, it should not be considered a pointer itself, since it doesn't guarantee that the pointed object remains valid.</source>
          <target state="translated">이 점에 유의하는 것이 중요 &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer가&lt;/a&gt; 일어나는 실수를 예방할 수있는 자동 캐스팅 연산자를 제공하지 않습니다. &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; 가 포인터를 추적 하더라도 뾰족한 개체가 유효한 상태를 보장하지는 않으므로 포인터 자체로 간주해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e247bd61d8351151098b30c67ef3933459d1d585" translate="yes" xml:space="preserve">
          <source>It's important to note that QWeakPointer provides no automatic casting operators to prevent mistakes from happening. Even though QWeakPointer tracks a pointer, it should not be considered a pointer itself, since it doesn't guarantee that the pointed object remains valid.</source>
          <target state="translated">QWeakPointer는 실수 발생을 방지하기 위해 자동 캐스팅 연산자를 제공하지 않는다는 점에 유의하는 것이 중요합니다. QWeakPointer가 포인터를 추적하더라도 뾰족한 개체가 유효한 상태로 유지된다는 것을 보장하지 않으므로 포인터 자체로 간주해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="4b45f2363272efcdd0ce2ec1b23edcdd328d88c4" translate="yes" xml:space="preserve">
          <source>It's most commonly used to animate a GUI control by calling a slot periodically. You can construct a timeline by passing its duration in milliseconds to &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt;'s constructor. The timeline's duration describes for how long the animation will run. Then you set a suitable frame range by calling &lt;a href=&quot;qtimeline#setFrameRange&quot;&gt;setFrameRange&lt;/a&gt;(). Finally connect the &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;() signal to a suitable slot in the widget you wish to animate (for example, &lt;a href=&quot;qprogressbar#value-prop&quot;&gt;setValue()&lt;/a&gt; in &lt;a href=&quot;qprogressbar&quot;&gt;QProgressBar&lt;/a&gt;). When you proceed to calling &lt;a href=&quot;qtimeline#start&quot;&gt;start&lt;/a&gt;(), &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; will enter Running state, and start emitting &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;() at regular intervals, causing your widget's connected property's value to grow from the lower end to the upper and of your frame range, at a steady rate. You can specify the update interval by calling &lt;a href=&quot;qtimeline#updateInterval-prop&quot;&gt;setUpdateInterval&lt;/a&gt;(). When done, &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; enters &lt;a href=&quot;qtimeline#State-enum&quot;&gt;NotRunning&lt;/a&gt; state, and emits &lt;a href=&quot;qtimeline#finished&quot;&gt;finished&lt;/a&gt;().</source>
          <target state="translated">슬롯을 주기적으로 호출하여 GUI 컨트롤에 애니메이션을 적용하는 데 가장 일반적으로 사용됩니다. 밀리 초 단위의 지속 시간을 &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; 의 생성자 에 전달하여 타임 라인을 구성 할 수 있습니다 . 타임 라인의 지속 시간은 애니메이션이 실행되는 시간을 나타냅니다. 그런 다음 &lt;a href=&quot;qtimeline#setFrameRange&quot;&gt;setFrameRange&lt;/a&gt; () 를 호출하여 적절한 프레임 범위를 설정하십시오 . 마지막으로 연결 &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt; (예를 들어, 애니메이션하고자하는 위젯에 적합한 슬롯 () 신호 &lt;a href=&quot;qprogressbar#value-prop&quot;&gt;의 setValue ()&lt;/a&gt; 에서 &lt;a href=&quot;qprogressbar&quot;&gt;QProgressBar&lt;/a&gt; ). &lt;a href=&quot;qtimeline#start&quot;&gt;start&lt;/a&gt; () 호출을 진행하면 &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; 이 Running 상태가 되고 frameChanged 가 방출 &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;됩니다.&lt;/a&gt;()가 일정한 간격으로 위젯의 연결된 속성 값이 꾸준한 속도로 하단에서 상단 및 프레임 범위로 증가합니다. &lt;a href=&quot;qtimeline#updateInterval-prop&quot;&gt;setUpdateInterval&lt;/a&gt; () 을 호출하여 업데이트 간격을 지정할 수 있습니다 . 완료되면 &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; 은 &lt;a href=&quot;qtimeline#State-enum&quot;&gt;NotRunning&lt;/a&gt; 상태가되고 &lt;a href=&quot;qtimeline#finished&quot;&gt;종료&lt;/a&gt; ()가됩니다.</target>
        </trans-unit>
        <trans-unit id="b30a01115b876bfa3212702fa17addbf8baf1f25" translate="yes" xml:space="preserve">
          <source>It's most commonly used to animate a GUI control by calling a slot periodically. You can construct a timeline by passing its duration in milliseconds to QTimeLine's constructor. The timeline's duration describes for how long the animation will run. Then you set a suitable frame range by calling &lt;a href=&quot;qtimeline#setFrameRange&quot;&gt;setFrameRange&lt;/a&gt;(). Finally connect the &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;() signal to a suitable slot in the widget you wish to animate (for example, &lt;a href=&quot;qprogressbar#value-prop&quot;&gt;setValue()&lt;/a&gt; in &lt;a href=&quot;qprogressbar&quot;&gt;QProgressBar&lt;/a&gt;). When you proceed to calling &lt;a href=&quot;qtimeline#start&quot;&gt;start&lt;/a&gt;(), QTimeLine will enter Running state, and start emitting &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;() at regular intervals, causing your widget's connected property's value to grow from the lower end to the upper and of your frame range, at a steady rate. You can specify the update interval by calling &lt;a href=&quot;qtimeline#updateInterval-prop&quot;&gt;setUpdateInterval&lt;/a&gt;(). When done, QTimeLine enters &lt;a href=&quot;qtimeline#State-enum&quot;&gt;NotRunning&lt;/a&gt; state, and emits &lt;a href=&quot;qtimeline#finished&quot;&gt;finished&lt;/a&gt;().</source>
          <target state="translated">주기적으로 슬롯을 호출하여 GUI 컨트롤을 애니메이션하는 데 가장 일반적으로 사용됩니다. 밀리 초 단위의 기간을 QTimeLine의 생성자에 전달하여 타임 라인을 구성 할 수 있습니다. 타임 라인의 기간은 애니메이션이 실행되는 시간을 나타냅니다. 그런 다음 &lt;a href=&quot;qtimeline#setFrameRange&quot;&gt;setFrameRange&lt;/a&gt; () 를 호출하여 적절한 프레임 범위를 설정합니다 . 마지막으로 연결 &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt; (예를 들어, 애니메이션하고자하는 위젯에 적합한 슬롯 () 신호 &lt;a href=&quot;qprogressbar#value-prop&quot;&gt;의 setValue ()&lt;/a&gt; 에서 &lt;a href=&quot;qprogressbar&quot;&gt;QProgressBar&lt;/a&gt; ). &lt;a href=&quot;qtimeline#start&quot;&gt;start&lt;/a&gt; () 호출을 진행하면 QTimeLine이 Running 상태로 &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;들어가고 frameChanged&lt;/a&gt; 방출을 시작합니다.() 일정한 간격으로 위젯의 연결된 속성 값이 일정한 속도로 하단에서 상단 및 프레임 범위로 증가합니다. &lt;a href=&quot;qtimeline#updateInterval-prop&quot;&gt;setUpdateInterval&lt;/a&gt; () 을 호출하여 업데이트 간격을 지정할 수 있습니다 . 완료되면 QTimeLine은 &lt;a href=&quot;qtimeline#State-enum&quot;&gt;NotRunning&lt;/a&gt; 상태 로 들어가고 &lt;a href=&quot;qtimeline#finished&quot;&gt;finished&lt;/a&gt; ()를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="54b9642b6281091b307ffba950d6791c368be218" translate="yes" xml:space="preserve">
          <source>It's not necessary to explcitly load the camera, unless unless the application have to read the supported camera settings and change the default depending on the camera capabilities.</source>
          <target state="translated">응용 프로그램에서 지원되는 카메라 설정을 읽고 카메라 기능에 따라 기본값을 변경하지 않는 한 카메라를 신속하게로드 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b6080153c6aa522cf0f78f33b809e2020f7430c" translate="yes" xml:space="preserve">
          <source>It's not necessary to explicitly load the camera, unless the application needs to read the supported camera settings and change the default values according to the camera capabilities.</source>
          <target state="translated">애플리케이션이 지원되는 카메라 설정을 읽고 카메라 기능에 따라 기본값을 변경해야하는 경우가 아니면 카메라를 명시 적으로로드 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1102653adee9d48b2b1da435e2cba0ef5762d6af" translate="yes" xml:space="preserve">
          <source>It's not possible to filter by the message text itself; applications have to do that on their own (in slots connected to the &lt;a href=&quot;qopengldebuglogger#messageLogged&quot;&gt;messageLogged&lt;/a&gt;() signal, or after fetching the messages in the internal debug log through &lt;a href=&quot;qopengldebuglogger#loggedMessages&quot;&gt;loggedMessages&lt;/a&gt;()).</source>
          <target state="translated">메시지 텍스트 자체로는 필터링 할 수 없습니다. 응용 프로그램은 자체적으로 ( &lt;a href=&quot;qopengldebuglogger#messageLogged&quot;&gt;messageLogged&lt;/a&gt; () 신호에 연결된 슬롯 에서 또는 &lt;a href=&quot;qopengldebuglogger#loggedMessages&quot;&gt;logsMessages&lt;/a&gt; ()를 통해 내부 디버그 로그에서 메시지를 가져온 후 )이를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ab514dd42ade474d4564581d7459a5421864906" translate="yes" xml:space="preserve">
          <source>It's not possible to render particle effects with the &lt;a href=&quot;qtquick-visualcanvas-adaptations#openvg&quot;&gt;OpenVG&lt;/a&gt; adaptation. Whenever possible, remove particles completely from the scene. Otherwise they'll still require some processing, even though they are not visible.</source>
          <target state="translated">&lt;a href=&quot;qtquick-visualcanvas-adaptations#openvg&quot;&gt;OpenVG&lt;/a&gt; 적응으로 입자 효과를 렌더링 할 수 없습니다 . 가능하면 장면에서 파티클을 완전히 제거하십시오. 그렇지 않으면 보이지 않지만 여전히 일부 처리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0a4f3534dfee6819410503ff681a7ad4b79da4c7" translate="yes" xml:space="preserve">
          <source>It's not unusual for keyboard shortcuts to move the focus. This can happen implicitly by opening modal dialogs, but also explicitly using focus accelerators such as those provided by &lt;a href=&quot;qlabel#setBuddy&quot;&gt;QLabel::setBuddy&lt;/a&gt;(), &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt;, and &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt;.</source>
          <target state="translated">키보드 단축키로 포커스를 이동하는 것은 드문 일이 아닙니다. 이것은 모달 대화 상자를 열어 암시 적으로 발생할 수 있지만 &lt;a href=&quot;qlabel#setBuddy&quot;&gt;QLabel :: setBuddy&lt;/a&gt; (), &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; 및 &lt;a href=&quot;qtabbar&quot;&gt;QTabBar에서&lt;/a&gt; 제공하는 것과 같은 포커스 가속기를 명시 적으로 사용하여 발생할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d10c7712090d61c634dc68db1051ea0eec38de1" translate="yes" xml:space="preserve">
          <source>It's only possible to change settings when the encoder is in the QMediaEncoder::StoppedState state.</source>
          <target state="translated">인코더가 QMediaEncoder :: StoppedState 상태에있을 때만 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="322ea46ac40b5fd52253ea3ce2a4ff6e0ae1a835" translate="yes" xml:space="preserve">
          <source>It's permissible to call &lt;a href=&quot;qcameraimagecapturecontrol#capture&quot;&gt;capture&lt;/a&gt;() while the camera status is &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera::ActiveStatus&lt;/a&gt; regardless of isReadyForCapture property value. If camera is not ready to capture image immediately, the capture request is queued with all the related camera settings to be executed as soon as possible.</source>
          <target state="translated">isReadyForCapture 속성 값에 관계없이 카메라 상태가 &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera :: ActiveStatus 인&lt;/a&gt; 동안 &lt;a href=&quot;qcameraimagecapturecontrol#capture&quot;&gt;캡처&lt;/a&gt; () 를 호출 할 수 있습니다. 카메라가 즉시 이미지를 캡처 할 준비가되지 않은 경우 캡처 관련 요청이 가능한 한 빨리 모든 관련 카메라 설정과 함께 대기합니다.</target>
        </trans-unit>
        <trans-unit id="773ee187fde8574421bde7a405a6ff1f56e42315" translate="yes" xml:space="preserve">
          <source>It's possible to combine multiple Camera::FocusMode values, for example Camera.FocusMacro + Camera.FocusContinuous.</source>
          <target state="translated">여러 Camera :: FocusMode 값을 결합 할 수 있습니다 (예 : Camera.FocusMacro + Camera.FocusContinuous).</target>
        </trans-unit>
        <trans-unit id="eee0875be64f0875c91975abf5130fe988a16462" translate="yes" xml:space="preserve">
          <source>It's possible to configure Qt with -qt-xcb, which compiles in a set of xcb helper libraries instead of trying to link against the system versions. This can help make Qt less dependent on some of the xcb helper libraries that might not be available on all distributions. The table specifies which dependencies are provided by -qt-xcb.</source>
          <target state="translated">-qt-xcb를 사용하여 Qt를 구성 할 수 있습니다. -qt-xcb는 시스템 버전에 연결하지 않고 일련의 xcb 헬퍼 라이브러리에서 컴파일합니다. 이것은 모든 배포판에서 사용 가능하지 않을 수있는 일부 xcb 헬퍼 라이브러리에 Qt의 의존성을 떨어 뜨릴 수 있습니다. 이 테이블은 -qt-xcb가 제공하는 종속성을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ac47cc2b9f12701bfce4a7cdce3d37fbb0d9b575" translate="yes" xml:space="preserve">
          <source>It's possible to connect to a Oracle database without a tnsnames.ora file. This requires that the database SID is passed to the driver as the database name, and that a hostname is given.</source>
          <target state="translated">tnsnames.ora 파일없이 Oracle 데이터베이스에 연결할 수 있습니다. 이를 위해서는 데이터베이스 SID가 데이터베이스 이름으로 드라이버에 전달되고 호스트 이름이 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3854f97d1b8f549a0600bb7d6556881c5cabed72" translate="yes" xml:space="preserve">
          <source>It's possible to make an existing property required with</source>
          <target state="translated">필요한 기존 속성을 다음과 같이 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19907609e77b36fffddfa7c26a58898dc5b09831" translate="yes" xml:space="preserve">
          <source>It's possible to make bindings to properties of a &lt;a href=&quot;qml-qtquick-singlepointhandler&quot;&gt;SinglePointHandler&lt;/a&gt;'s current point. For example:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-singlepointhandler&quot;&gt;SinglePointHandler&lt;/a&gt; 의 현재 포인트의 속성에 바인딩 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80bd82d89c7abe5d5226910fb0abf47f4e654adb" translate="yes" xml:space="preserve">
          <source>It's possible to make bindings to properties of a handler's current &lt;a href=&quot;qml-qtquick-singlepointhandler#point-prop&quot;&gt;point&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-multipointhandler#centroid-prop&quot;&gt;centroid&lt;/a&gt;. For example:</source>
          <target state="translated">핸들러의 현재 &lt;a href=&quot;qml-qtquick-singlepointhandler#point-prop&quot;&gt;point&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-multipointhandler#centroid-prop&quot;&gt;centroid&lt;/a&gt; 속성에 바인딩을 만들 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="15429f2a8419b04c9ce60059ccd19c3072cedc4e" translate="yes" xml:space="preserve">
          <source>It's possible to print some information to the debug output by enabling the &lt;code&gt;qt.qpa.input&lt;/code&gt; logging rule, for example by setting the &lt;code&gt;QT_LOGGING_RULES&lt;/code&gt; environment variable to &lt;code&gt;qt.qpa.input=true&lt;/code&gt;. This is useful for detecting which device is being used, or for troubleshooting device discovery issues.</source>
          <target state="translated">그것은 가능하게함으로써 디버그 출력에 대한 몇 가지 정보를 인쇄하는 것이 가능 &lt;code&gt;qt.qpa.input&lt;/code&gt; 의 설정에 따라, 예를 들어, 로깅 규칙을 &lt;code&gt;QT_LOGGING_RULES&lt;/code&gt; 의 에 환경 변수 &lt;code&gt;qt.qpa.input=true&lt;/code&gt; . 이는 사용중인 장치를 감지하거나 장치 검색 문제를 해결하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f7d2b6a8780b2c49fa72c8a01b46fccabaa21adb" translate="yes" xml:space="preserve">
          <source>It's similar to &lt;a href=&quot;qmoveevent&quot;&gt;QMoveEvent&lt;/a&gt;, but its positions, &lt;a href=&quot;qgraphicsscenemoveevent#oldPos&quot;&gt;oldPos&lt;/a&gt;() and &lt;a href=&quot;qgraphicsscenemoveevent#newPos&quot;&gt;newPos&lt;/a&gt;(), use &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; instead of &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qmoveevent&quot;&gt;QMoveEvent&lt;/a&gt; 와 비슷 하지만 &lt;a href=&quot;qgraphicsscenemoveevent#oldPos&quot;&gt;oldPos&lt;/a&gt; () 및 &lt;a href=&quot;qgraphicsscenemoveevent#newPos&quot;&gt;newPos&lt;/a&gt; () &lt;a href=&quot;qpoint&quot;&gt;위치&lt;/a&gt; 는 QPoint 대신 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="934dddf117f6c00d5fe09f928bc05ef75baa78ba" translate="yes" xml:space="preserve">
          <source>It's similar to &lt;a href=&quot;qresizeevent&quot;&gt;QResizeEvent&lt;/a&gt;, but its sizes, &lt;a href=&quot;qgraphicssceneresizeevent#oldSize&quot;&gt;oldSize&lt;/a&gt;() and &lt;a href=&quot;qgraphicssceneresizeevent#newSize&quot;&gt;newSize&lt;/a&gt;(), use &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; instead of &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qresizeevent&quot;&gt;QResizeEvent&lt;/a&gt; 와 비슷 하지만, &lt;a href=&quot;qgraphicssceneresizeevent#oldSize&quot;&gt;oldSize&lt;/a&gt; () 및 &lt;a href=&quot;qgraphicssceneresizeevent#newSize&quot;&gt;newSize&lt;/a&gt; () 크기 는 &lt;a href=&quot;qsizef&quot;&gt;QSize&lt;/a&gt; 대신 &lt;a href=&quot;qsize&quot;&gt;QSizeF를 사용&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="5817971605f9bb01f85106ef572fabcf10337acf" translate="yes" xml:space="preserve">
          <source>It's slow. The color property will first be evaluated with a default-constructed value, and then again with &quot;red&quot; later on.</source>
          <target state="translated">느립니다. color 속성은 먼저 기본 생성 값으로 평가되고 나중에 &quot;red&quot;로 다시 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="1808b38f031aaafd0f76411ccfd079e0b7cc3e9b" translate="yes" xml:space="preserve">
          <source>It's used only for parameters with a limited set of values, like &lt;a href=&quot;qcameraimageprocessingcontrol#ProcessingParameter-enum&quot;&gt;WhiteBalancePreset&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qcameraimageprocessingcontrol#ProcessingParameter-enum&quot;&gt;WhiteBalancePreset&lt;/a&gt; 과 같이 제한된 값 세트를 가진 매개 변수에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6dd3388c21da9cde23ff7b0ede81c771236912ef" translate="yes" xml:space="preserve">
          <source>It's useful when you have your own Java implementation. Of course &lt;a href=&quot;qandroidserviceconnection#onServiceConnected&quot;&gt;onServiceConnected&lt;/a&gt;()/&lt;a href=&quot;qandroidserviceconnection#onServiceDisconnected&quot;&gt;onServiceDisconnected&lt;/a&gt;() will not be called anymore.</source>
          <target state="translated">자체 Java 구현이있는 경우 유용합니다. 물론 &lt;a href=&quot;qandroidserviceconnection#onServiceConnected&quot;&gt;onServiceConnected&lt;/a&gt; () / &lt;a href=&quot;qandroidserviceconnection#onServiceDisconnected&quot;&gt;onServiceDisconnected&lt;/a&gt; ()는 더 이상 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="485b57adcc80650a0f376fe516e0ea35fef68007" translate="yes" xml:space="preserve">
          <source>Italian</source>
          <target state="translated">Italian</target>
        </trans-unit>
        <trans-unit id="af6824436fc11a904a07d98f2312bae08f1964cb" translate="yes" xml:space="preserve">
          <source>Italian Layout</source>
          <target state="translated">이탈리아어 레이아웃</target>
        </trans-unit>
        <trans-unit id="1616e2e5405e69c4e3914c67c644a9bd3ac00956" translate="yes" xml:space="preserve">
          <source>Italic</source>
          <target state="translated">Italic</target>
        </trans-unit>
        <trans-unit id="5a48ebbe67a9f8de5a7ee49a7b4eea0f31490eea" translate="yes" xml:space="preserve">
          <source>Italic glyphs that are specifically designed for the purpose of representing italicized text.</source>
          <target state="translated">이탤릭체 텍스트를 나타 내기 위해 특별히 설계된 이탤릭체 글리프.</target>
        </trans-unit>
        <trans-unit id="de8a44e4a35427b18e9c3ea12cb6129b204f89b1" translate="yes" xml:space="preserve">
          <source>Italic text.</source>
          <target state="translated">기울임 꼴 텍스트.</target>
        </trans-unit>
        <trans-unit id="ecdda59aea5ee67d7d854c969ccf7f4f4b4a4c54" translate="yes" xml:space="preserve">
          <source>Item</source>
          <target state="translated">Item</target>
        </trans-unit>
        <trans-unit id="a5df127683bb9b560ad23e6714912676402ca4be" translate="yes" xml:space="preserve">
          <source>Item &quot;A&quot; has a number of children. A model index for item &quot;B&quot; is obtained with the following code:</source>
          <target state="translated">항목 &quot;A&quot;에는 여러 자녀가 ​​있습니다. &quot;B&quot;항목에 대한 모델 색인은 다음 코드를 사용하여 얻습니다.</target>
        </trans-unit>
        <trans-unit id="e50ae63691519dfef4cc84f52f812d2db7b4b7df" translate="yes" xml:space="preserve">
          <source>Item (QML type)</source>
          <target state="translated">품목 (QML 유형)</target>
        </trans-unit>
        <trans-unit id="e4f898bb6d810d23a082edd694f438cb76b6b0a0" translate="yes" xml:space="preserve">
          <source>Item (and all derived types) provides built in support for states and transitions via its &lt;a href=&quot;qml-qtquick-item#state-prop&quot;&gt;state&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-item#states-prop&quot;&gt;states&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#transitions-prop&quot;&gt;transitions&lt;/a&gt; properties. &lt;a href=&quot;qml-qtquick-stategroup&quot;&gt;StateGroup&lt;/a&gt; provides an easy way to use this support in other (non-Item-derived) types.</source>
          <target state="translated">항목 (및 모든 파생 유형)은 &lt;a href=&quot;qml-qtquick-item#state-prop&quot;&gt;state&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-item#states-prop&quot;&gt;states&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-item#transitions-prop&quot;&gt;transitions&lt;/a&gt; 속성을 통해 상태 및 전환을 기본적으로 지원 합니다. &lt;a href=&quot;qml-qtquick-stategroup&quot;&gt;StateGroup&lt;/a&gt; 은 다른 (항목에서 파생되지 않은) 유형에서이 지원을 사용하는 쉬운 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f1a7412cc94c83e0a752584abb8cd43105f416eb" translate="yes" xml:space="preserve">
          <source>Item (and all derived types) provides built in support for states and transitions via its &lt;a href=&quot;qml-qtquick-item#state-prop&quot;&gt;state&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-item#states-prop&quot;&gt;states&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#transitions-prop&quot;&gt;transitions&lt;/a&gt; properties. StateGroup provides an easy way to use this support in other (non-Item-derived) types.</source>
          <target state="translated">항목 (및 모든 파생 유형)은 &lt;a href=&quot;qml-qtquick-item#state-prop&quot;&gt;state&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-item#states-prop&quot;&gt;states&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-item#transitions-prop&quot;&gt;transitions&lt;/a&gt; 속성을 통해 상태 및 전환에 대한 기본 지원을 제공 합니다. StateGroup은 다른 (항목 파생이 아닌) 유형에서이 지원을 사용하는 쉬운 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ddf70253940ac83f3ef72575e0f24057265b100c" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls-stackview#find-method&quot;&gt;find&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">아이템 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls-stackview#find-method&quot;&gt;찾기&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="0a2ce97121dfd0343ad3e3a9c0a5dbae36c7a194" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls-stackview#get-method&quot;&gt;get&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(int</source>
          <target state="translated">아이템 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls-stackview#get-method&quot;&gt;획득&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (int</target>
        </trans-unit>
        <trans-unit id="49e9c7d16507fed376977d7117be893a3f4131bb" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls-stackview#pop-method&quot;&gt;pop&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(Item</source>
          <target state="translated">아이템 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls-stackview#pop-method&quot;&gt;팝&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (Item</target>
        </trans-unit>
        <trans-unit id="3c1adbae60f92d0980809160f00fb7aa2ad05bc8" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls-stackview#push-method&quot;&gt;push&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(Item</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls-stackview#push-method&quot;&gt;푸시&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (항목</target>
        </trans-unit>
        <trans-unit id="c4438a00f1ed0f8a5454b0b16e6b60f8798d0b2e" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-container#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">품목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-container#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="fe4a116515a6738f82bd6666b56c273655cfb71d" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-container#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(int</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-container#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (int</target>
        </trans-unit>
        <trans-unit id="95367f592e8fd659c0a4cae32b7b06ec4462f6b1" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-container#takeItem-method&quot;&gt;takeItem&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">품목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-container#takeItem-method&quot;&gt;takeItem&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="8315abfc497d025c3cf8ab4c0c7603d5919818af" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-container#takeItem-method&quot;&gt;takeItem&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(int</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-container#takeItem-method&quot;&gt;takeItem&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (int</target>
        </trans-unit>
        <trans-unit id="6598f5548f0bf84a9d2e2ff93391e98dccc50e11" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-menu#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">품목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-menu#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="1041328ea0f8cda005e65701ed2f82cf234d1f9b" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-menu#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(int</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-menu#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (int</target>
        </trans-unit>
        <trans-unit id="5ffa5acbe6122a36f6c39f3f6c150487cc17d3a2" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#find-method&quot;&gt;find&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">아이템 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#find-method&quot;&gt;찾기&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="40dfdd761bb35a8ba345211c85096e98592a64e8" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#get-method&quot;&gt;get&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">아이템 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#get-method&quot;&gt;가져 오기&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="af5a36b33c11c6ae94ff99211db4c61d90861815" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#pop-method&quot;&gt;pop&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">아이템 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#pop-method&quot;&gt;팝&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="44d5299595db3963d567f7e443bb0ab016642bd2" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#push-method&quot;&gt;push&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">아이템 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#push-method&quot;&gt;푸시&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="a197847b9838a4df7e5cbd888ca2b6b77a380944" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#replace-method&quot;&gt;replace&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">아이템 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-controls2-stackview#replace-method&quot;&gt;교체&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="8c9f4c98345f7c74221211ef4cdd714936a0da4e" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-gridview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">품목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-gridview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="189dd7ecf23b221fe2549948a2b126fb9a3e7521" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-gridview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(real</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-gridview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (실제</target>
        </trans-unit>
        <trans-unit id="4622712203499e3e3324158820a2402a80575f72" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-gridview#itemAtIndex-method&quot;&gt;itemAtIndex&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-gridview#itemAtIndex-method&quot;&gt;itemAtIndex&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="e0cdbfdeaa28a9e7ae3da4c81344b27c64504f26" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-gridview#itemAtIndex-method&quot;&gt;itemAtIndex&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(int</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-gridview#itemAtIndex-method&quot;&gt;itemAtIndex&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (int</target>
        </trans-unit>
        <trans-unit id="41ef75f00c9dc9e65090489268adfae49d61a2cb" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-listview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">품목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-listview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="cb1bd569a0a017d50d6d4c20b9c73184b9054faf" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-listview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(real</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-listview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (실제</target>
        </trans-unit>
        <trans-unit id="d5fe1c8e89205b056dbb32746b23ae863c4c025c" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-listview#itemAtIndex-method&quot;&gt;itemAtIndex&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-listview#itemAtIndex-method&quot;&gt;itemAtIndex&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="f64f214afc79b84a239065393a5634cec0ebe682" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-listview#itemAtIndex-method&quot;&gt;itemAtIndex&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(int</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-listview#itemAtIndex-method&quot;&gt;itemAtIndex&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (int</target>
        </trans-unit>
        <trans-unit id="1af242103489c9a6d9c7e57c4460e059f34bdf62" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-pathview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">품목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-pathview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="978e18599ea404264d86b6366b220f092b2a8fb2" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-pathview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(real</source>
          <target state="translated">항목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-pathview#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (실제</target>
        </trans-unit>
        <trans-unit id="89a7c9297643a4f81addf172dcd1f961fb47ad2d" translate="yes" xml:space="preserve">
          <source>Item &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-repeater#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">품목 &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtquick-repeater#itemAt-method&quot;&gt;itemAt&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="201e7adb3886f8ea20f4aca9821c7de2ee20566d" translate="yes" xml:space="preserve">
          <source>Item Coordinates</source>
          <target state="translated">아이템 좌표</target>
        </trans-unit>
        <trans-unit id="09f472343e7cc56f3732b3128bd660dea6c4dc12" translate="yes" xml:space="preserve">
          <source>Item Groups</source>
          <target state="translated">품목 그룹</target>
        </trans-unit>
        <trans-unit id="4986df28cec7555918dc6e355c4a70c0d45a9f14" translate="yes" xml:space="preserve">
          <source>Item Layers</source>
          <target state="translated">아이템 레이어</target>
        </trans-unit>
        <trans-unit id="d5c9f5996caf101dabc161f4cd976e61de7fd1ab" translate="yes" xml:space="preserve">
          <source>Item Models and Data Mapping</source>
          <target state="translated">아이템 모델 및 데이터 매핑</target>
        </trans-unit>
        <trans-unit id="a1c537bd015c1c74434089d12c13d8e9ce682046" translate="yes" xml:space="preserve">
          <source>Item Ownership</source>
          <target state="translated">아이템 소유권</target>
        </trans-unit>
        <trans-unit id="b615a37bccc41fc6b14cd92f6a7372901c468d91" translate="yes" xml:space="preserve">
          <source>Item Positioners</source>
          <target state="translated">아이템 포지셔너</target>
        </trans-unit>
        <trans-unit id="aa610b2cb81002951dde08cb6b50e71c81105c5c" translate="yes" xml:space="preserve">
          <source>Item QML Type</source>
          <target state="translated">품목 QML 유형</target>
        </trans-unit>
        <trans-unit id="0b67c8d1f000678bb49d9dd13c1c665ba8dd6f82" translate="yes" xml:space="preserve">
          <source>Item View Convenience Classes</source>
          <target state="translated">아이템 뷰 편의 클래스</target>
        </trans-unit>
        <trans-unit id="d5caa284635328070a664054bc74cfb9e342c288" translate="yes" xml:space="preserve">
          <source>Item View Headers</source>
          <target state="translated">아이템 뷰 헤더</target>
        </trans-unit>
        <trans-unit id="c69d47ca34a82a2a69eda6bfd3740dea3536f02f" translate="yes" xml:space="preserve">
          <source>Item acts as a link to a file that the application can open.</source>
          <target state="translated">항목은 응용 프로그램이 열 수있는 파일에 대한 링크 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="d54c1ac2b23604a11002fb1b10ef3d82dec0f17e" translate="yes" xml:space="preserve">
          <source>Item data handling</source>
          <target state="translated">품목 데이터 처리</target>
        </trans-unit>
        <trans-unit id="d9d6fa91c0d8241dc5483dd85a978a1676ee1620" translate="yes" xml:space="preserve">
          <source>Item defaults to the value provided via touchEvent(). X and y default to the midpoint of the item.</source>
          <target state="translated">항목의 기본값은 touchEvent ()를 통해 제공된 값입니다. X와 y의 기본값은 항목의 중간 점입니다.</target>
        </trans-unit>
        <trans-unit id="dcde0507a8c37135d26f5570f88a09e4122c672e" translate="yes" xml:space="preserve">
          <source>Item delegate with a check indicator that can be toggled on or off</source>
          <target state="translated">켜거나 끌 수있는 점검 표시기가있는 품목 대리자</target>
        </trans-unit>
        <trans-unit id="1a822479578b56c19509293155fe1a5f94981db5" translate="yes" xml:space="preserve">
          <source>Item delegate with a check indicator that can be toggled on or off. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">켜거나 끌 수있는 확인 표시기가있는 항목 대리인. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dbd25052d707307af916ec9d28ab488c3a162182" translate="yes" xml:space="preserve">
          <source>Item delegate with a switch indicator that can be toggled on or off</source>
          <target state="translated">켜거나 끌 수있는 스위치 표시기가있는 항목 대리자</target>
        </trans-unit>
        <trans-unit id="7ef2d68e84d4ca7ef9776f53eb8b2ad5bd693f78" translate="yes" xml:space="preserve">
          <source>Item delegate with a switch indicator that can be toggled on or off. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">켜거나 끌 수있는 스위치 표시기가있는 항목 델리게이트. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="506296d3c72a1aa0f2cd3164eef98f7acad99131" translate="yes" xml:space="preserve">
          <source>Item displays the current valid copyright notice for a Map element</source>
          <target state="translated">항목은지도 요소에 대한 현재 유효한 저작권 표시를 표시합니다</target>
        </trans-unit>
        <trans-unit id="6113aef69f4201aff7843f045f83f593471f04d3" translate="yes" xml:space="preserve">
          <source>Item for use with the QListWidget item view class</source>
          <target state="translated">QListWidget 항목보기 클래스와 함께 사용하기위한 항목</target>
        </trans-unit>
        <trans-unit id="8f1ca4a2dbe5ee9d97bbd21b1388dda25000f6a0" translate="yes" xml:space="preserve">
          <source>Item for use with the QStandardItemModel class</source>
          <target state="translated">QStandardItemModel 클래스와 함께 사용할 항목</target>
        </trans-unit>
        <trans-unit id="638916425f8da3caeb872412247b281a28ae2233" translate="yes" xml:space="preserve">
          <source>Item for use with the QTableWidget class</source>
          <target state="translated">QTableWidget 클래스와 함께 사용할 항목</target>
        </trans-unit>
        <trans-unit id="1129f8b650f043ccd8fee0ebe8cd578eb4cc9810" translate="yes" xml:space="preserve">
          <source>Item for use with the QTreeWidget convenience class</source>
          <target state="translated">QTreeWidget 편의 클래스와 함께 사용하기위한 항목</target>
        </trans-unit>
        <trans-unit id="31ff6aa9d1812d8ae12d5306bf0d713e3fa4f144" translate="yes" xml:space="preserve">
          <source>Item gains keyboard grab (&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; only).</source>
          <target state="translated">아이템은 키보드 잡기 ( &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 만 해당)를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="d9bf006d143c45d829320e50970a54f53ffb5f59" translate="yes" xml:space="preserve">
          <source>Item gains mouse grab (&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; only).</source>
          <target state="translated">아이템은 마우스 잡기 ( &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 만 해당)를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="e2b110447bd1706f527420c4ad4abec94a9f83fd" translate="yes" xml:space="preserve">
          <source>Item is a separator. Only tasks category supports separators.</source>
          <target state="translated">항목은 구분 기호입니다. 작업 범주 만 구분 기호를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ac8384ec23bce7e8a4c667ea77cc8e1492678a85" translate="yes" xml:space="preserve">
          <source>Item layouts can be mirrored using the &lt;a href=&quot;qml-qtquick-layoutmirroring&quot;&gt;LayoutMirroring&lt;/a&gt; attached property. This causes &lt;a href=&quot;qml-qtquick-item#anchors.top-prop&quot;&gt;anchors&lt;/a&gt; to be horizontally reversed, and also causes items that lay out or position their children (such as &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-row&quot;&gt;Row&lt;/a&gt;) to horizontally reverse the direction of their layouts.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-layoutmirroring&quot;&gt;LayoutMirroring&lt;/a&gt; 연결된 속성을 사용하여 항목 레이아웃을 미러링 할 수 있습니다 . 이로 인해 &lt;a href=&quot;qml-qtquick-item#anchors.top-prop&quot;&gt;앵커&lt;/a&gt; 가 가로로 반전되고 자식을 배치하거나 배치하는 항목 (예 : &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-row&quot;&gt;Row&lt;/a&gt; )이 레이아웃 방향을 가로로 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="c5adc51350d8893a7dfcd3e6f731a76870e76046" translate="yes" xml:space="preserve">
          <source>Item loses keyboard grab (&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; only).</source>
          <target state="translated">항목이 키보드 잡기를 잃습니다 ( &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 만 해당).</target>
        </trans-unit>
        <trans-unit id="fa9b4bac29c744fe12dcb9539227c21e4f0200b1" translate="yes" xml:space="preserve">
          <source>Item loses mouse grab (&lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt;, &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt;).</source>
          <target state="translated">항목이 마우스 잡기 ( &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; , &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; )를 잃습니다 .</target>
        </trans-unit>
        <trans-unit id="abe6d1781ae90355780b2013dfef416755d0227c" translate="yes" xml:space="preserve">
          <source>Item position is specified either in data coordinates or in absolute coordinates, depending on the &lt;a href=&quot;qcustom3ditem#positionAbsolute-prop&quot;&gt;positionAbsolute&lt;/a&gt; property. When using absolute coordinates, values between &lt;code&gt;-1.0...1.0&lt;/code&gt; are within axis ranges.</source>
          <target state="translated">항목 위치는 &lt;a href=&quot;qcustom3ditem#positionAbsolute-prop&quot;&gt;positionAbsolute&lt;/a&gt; 속성 에 따라 데이터 좌표 또는 절대 좌표로 지정 됩니다. 절대 좌표를 사용할 때 &lt;code&gt;-1.0...1.0&lt;/code&gt; 사이의 값은 축 범위 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="405c9edf27f261290daf417a2ab81cde1d681176" translate="yes" xml:space="preserve">
          <source>Item position is specified either in data coordinates or in absolute coordinates, depending on the value of the &lt;a href=&quot;qml-qtdatavisualization-custom3ditem#positionAbsolute-prop&quot;&gt;positionAbsolute&lt;/a&gt; property. When using absolute coordinates, values between &lt;code&gt;-1.0...1.0&lt;/code&gt; are within axis ranges.</source>
          <target state="translated">항목 위치는 &lt;a href=&quot;qml-qtdatavisualization-custom3ditem#positionAbsolute-prop&quot;&gt;positionAbsolute&lt;/a&gt; 속성 값에 따라 데이터 좌표 또는 절대 좌표로 지정 됩니다. 절대 좌표를 사용할 때 &lt;code&gt;-1.0...1.0&lt;/code&gt; 사이의 값은 축 범위 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a3491e16dfc49da123573cf3ffafe746ec93ecb" translate="yes" xml:space="preserve">
          <source>Item represents a link to an application.</source>
          <target state="translated">항목은 응용 프로그램에 대한 링크를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="960d5f5595f91215aeed822d94655bb5610a8fa6" translate="yes" xml:space="preserve">
          <source>Item roles</source>
          <target state="translated">아이템 역할</target>
        </trans-unit>
        <trans-unit id="ba4cfc57592a7d5ebb2e689a0daffe9faccda501" translate="yes" xml:space="preserve">
          <source>Item scaling is either in data values or in absolute values, depending on the &lt;a href=&quot;qcustom3ditem#scalingAbsolute-prop&quot;&gt;scalingAbsolute&lt;/a&gt; property. The default vector interpreted as absolute values sets the item to 10% of the height of the graph, provided the item mesh is normalized and the graph aspect ratios have not been changed from the defaults.</source>
          <target state="translated">항목 배율은 &lt;a href=&quot;qcustom3ditem#scalingAbsolute-prop&quot;&gt;scalingAbsolute&lt;/a&gt; 속성 에 따라 데이터 값 또는 절대 값으로 표시 됩니다. 절대 값으로 해석되는 기본 벡터는 항목 메쉬가 정규화되고 그래프 종횡비가 기본값에서 변경되지 않은 경우 항목을 그래프 높이의 10 %로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ab82267a2614879c18f1880c7d81df26c10ed289" translate="yes" xml:space="preserve">
          <source>Item scaling is specified either in data values or in absolute values, depending on the value of the &lt;a href=&quot;qml-qtdatavisualization-custom3ditem#scalingAbsolute-prop&quot;&gt;scalingAbsolute&lt;/a&gt; property. The default vector interpreted as absolute values sets the item to 10% of the height of the graph, provided the item mesh is normalized and the graph aspect ratios have not been changed from the defaults.</source>
          <target state="translated">항목 크기 조정은 &lt;a href=&quot;qml-qtdatavisualization-custom3ditem#scalingAbsolute-prop&quot;&gt;scalingAbsolute&lt;/a&gt; 속성 값에 따라 데이터 값 또는 절대 값으로 지정 됩니다. 절대 값으로 해석되는 기본 벡터는 항목 메쉬가 정규화되고 그래프 종횡비가 기본값에서 변경되지 않은 경우 항목을 그래프 높이의 10 %로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0074f16162ca8f76fe096adf407ddcdd59ab4b02" translate="yes" xml:space="preserve">
          <source>Item selection mode.</source>
          <target state="translated">아이템 선택 모드.</target>
        </trans-unit>
        <trans-unit id="9e69764dae229258fa95590267574f01e61583f7" translate="yes" xml:space="preserve">
          <source>Item selection modes. Values of this enumeration can be combined with OR operator.</source>
          <target state="translated">아이템 선택 모드. 이 열거의 값은 OR 연산자와 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7c5726e41b643fba2a42b46bb8e1c4764109d76" translate="yes" xml:space="preserve">
          <source>Item size for the series.</source>
          <target state="translated">시리즈의 아이템 사이즈.</target>
        </trans-unit>
        <trans-unit id="2e8dca30b4bdb81076cc2094b5a88dca9313aa33" translate="yes" xml:space="preserve">
          <source>Item specific key handling, e.g. &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; key handling</source>
          <target state="translated">품목별 키 처리 (예 : &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; 키 처리)</target>
        </trans-unit>
        <trans-unit id="5a532fffe66a3a71159a44a9b3e97c279c89faf6" translate="yes" xml:space="preserve">
          <source>Item to add in a menu or a menu bar</source>
          <target state="translated">메뉴 또는 메뉴 막대에 추가 할 항목</target>
        </trans-unit>
        <trans-unit id="4d7030ddc07030386da8cf100b56ba380a474caf" translate="yes" xml:space="preserve">
          <source>Item transformations accumulate from parent to child, so if both a parent and child item are rotated 90 degrees, the child's total transformation will be 180 degrees. Similarly, if the item's parent is scaled to 2x its original size, its children will also be twice as large. An item's transformation does not affect its own local geometry; all geometry functions (e.g., &lt;a href=&quot;qgraphicsitem#contains&quot;&gt;contains&lt;/a&gt;(), &lt;a href=&quot;qgraphicsitem#update&quot;&gt;update&lt;/a&gt;(), and all the mapping functions) still operate in local coordinates. For convenience, &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; provides the functions &lt;a href=&quot;qgraphicsitem#sceneTransform&quot;&gt;sceneTransform&lt;/a&gt;(), which returns the item's total transformation matrix (including its position and all parents' positions and transformations), and &lt;a href=&quot;qgraphicsitem#scenePos&quot;&gt;scenePos&lt;/a&gt;(), which returns its position in scene coordinates. To reset an item's matrix, call &lt;a href=&quot;qgraphicsitem#resetTransform&quot;&gt;resetTransform&lt;/a&gt;().</source>
          <target state="translated">항목 변환은 상위 항목에서 하위 항목으로 누적되므로 상위 항목과 하위 항목이 모두 90도 회전하면 하위의 전체 변형이 180 도가됩니다. 마찬가지로 항목의 부모 크기가 원래 크기의 2 배로 조정되면 자식의 크기도 두 배가됩니다. 항목의 변형은 자체 로컬 지오메트리에 영향을 미치지 않습니다. 모든 지오메트리 함수 (예 : &lt;a href=&quot;qgraphicsitem#contains&quot;&gt;contains&lt;/a&gt; (), &lt;a href=&quot;qgraphicsitem#update&quot;&gt;update&lt;/a&gt; () 및 모든 매핑 함수)는 여전히 로컬 좌표로 작동합니다. 편의상 &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 은 항목의 전체 변환 행렬 (위치 및 모든 부모의 위치 및 변환 포함)과 &lt;a href=&quot;qgraphicsitem#scenePos&quot;&gt;scenePos&lt;/a&gt; 를 반환하는 &lt;a href=&quot;qgraphicsitem#sceneTransform&quot;&gt;sceneTransform&lt;/a&gt; () 함수를 제공합니다.() : 장면 좌표에서 위치를 반환합니다. 항목의 행렬을 재설정하려면 &lt;a href=&quot;qgraphicsitem#resetTransform&quot;&gt;resetTransform&lt;/a&gt; ()을 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee2012eee00149d102879f6cef822664d27b0b4f" translate="yes" xml:space="preserve">
          <source>Item transformations accumulate from parent to child, so if both a parent and child item are rotated 90 degrees, the child's total transformation will be 180 degrees. Similarly, if the item's parent is scaled to 2x its original size, its children will also be twice as large. An item's transformation does not affect its own local geometry; all geometry functions (e.g., &lt;a href=&quot;qgraphicsitem#contains&quot;&gt;contains&lt;/a&gt;(), &lt;a href=&quot;qgraphicsitem#update&quot;&gt;update&lt;/a&gt;(), and all the mapping functions) still operate in local coordinates. For convenience, QGraphicsItem provides the functions &lt;a href=&quot;qgraphicsitem#sceneTransform&quot;&gt;sceneTransform&lt;/a&gt;(), which returns the item's total transformation matrix (including its position and all parents' positions and transformations), and &lt;a href=&quot;qgraphicsitem#scenePos&quot;&gt;scenePos&lt;/a&gt;(), which returns its position in scene coordinates. To reset an item's matrix, call &lt;a href=&quot;qgraphicsitem#resetTransform&quot;&gt;resetTransform&lt;/a&gt;().</source>
          <target state="translated">항목 변형은 부모에서 자식으로 누적되므로 부모 및 자식 항목이 모두 90도 회전하면 자식의 총 변형은 180 도가됩니다. 마찬가지로 항목의 상위 항목이 원래 크기의 2 배로 조정되면 하위 항목도 두 배로 커집니다. 항목의 변형은 자체 로컬 지오메트리에 영향을주지 않습니다. 모든 지오메트리 함수 (예 : &lt;a href=&quot;qgraphicsitem#contains&quot;&gt;포함&lt;/a&gt; (), &lt;a href=&quot;qgraphicsitem#update&quot;&gt;업데이트&lt;/a&gt; () 및 모든 매핑 함수)는 여전히 로컬 좌표에서 작동합니다. 편의를 위해 QGraphicsItem은 항목의 전체 변환 행렬 (위치와 모든 상위 위치 및 변환 포함)을 반환하는 &lt;a href=&quot;qgraphicsitem#sceneTransform&quot;&gt;sceneTransform&lt;/a&gt; () 함수 와 &lt;a href=&quot;qgraphicsitem#scenePos&quot;&gt;scenePos를 제공합니다.&lt;/a&gt;(), 장면 좌표에서 위치를 반환합니다. 항목의 행렬을 재설정하려면 &lt;a href=&quot;qgraphicsitem#resetTransform&quot;&gt;resetTransform&lt;/a&gt; ()을 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="98149105b58e62d631ba2aaf35ad2bb547e37cb1" translate="yes" xml:space="preserve">
          <source>Item value formatted using the format of the value axis attached to the graph. For more information, see &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis::labelFormat&lt;/a&gt;.</source>
          <target state="translated">그래프에 첨부 된 값 축의 형식을 사용하여 형식이 지정된 항목 값. 자세한 정보는 &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis :: labelFormat을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="266c5eef2bfe7cba9ea69047b08d87122a4dc071" translate="yes" xml:space="preserve">
          <source>Item value formatted using the format of the x-axis. For more information, see &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis::setLabelFormat&lt;/a&gt;().</source>
          <target state="translated">x 축 형식을 사용하여 형식이 지정된 항목 값입니다. 자세한 정보는 &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis :: setLabelFormat&lt;/a&gt; ()을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a15392e40a7a05434f069780d3b5922e78a3a76c" translate="yes" xml:space="preserve">
          <source>Item value formatted using the format of the y-axis. For more information, see &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis::setLabelFormat&lt;/a&gt;().</source>
          <target state="translated">y 축 형식을 사용하여 형식이 지정된 항목 값입니다. 자세한 정보는 &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis :: setLabelFormat&lt;/a&gt; ()을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="df6e9a52853b926fcaafc46e06ea634958d81ccf" translate="yes" xml:space="preserve">
          <source>Item value formatted using the format of the z-axis. For more information, see &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis::setLabelFormat&lt;/a&gt;().</source>
          <target state="translated">z 축 형식을 사용하여 형식이 지정된 항목 값입니다. 자세한 정보는 &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis :: setLabelFormat&lt;/a&gt; ()을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1667ce1c291fa2e017ee5cfcb512c63315e4fcad" translate="yes" xml:space="preserve">
          <source>Item value in the specified format. Formatted using the same rules as &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis::labelFormat&lt;/a&gt;.</source>
          <target state="translated">지정된 형식의 항목 값 &lt;a href=&quot;qvalue3daxis#labelFormat-prop&quot;&gt;QValue3DAxis :: labelFormat&lt;/a&gt; 과 동일한 규칙을 사용하여 형식화됩니다 .</target>
        </trans-unit>
        <trans-unit id="66219a56567d29332f23188e5ef2583ab1a729c9" translate="yes" xml:space="preserve">
          <source>Item-based list widget</source>
          <target state="translated">아이템 기반 목록 위젯</target>
        </trans-unit>
        <trans-unit id="1a1ff76828862b83d034c8003013b5f1e0da11c2" translate="yes" xml:space="preserve">
          <source>Item-based table view with a default model</source>
          <target state="translated">기본 모델의 항목 기반 테이블보기</target>
        </trans-unit>
        <trans-unit id="d71ee514f124b58e8efd2db4a7b52e4f5c02db8c" translate="yes" xml:space="preserve">
          <source>Item.activeFocus</source>
          <target state="translated">Item.activeFocus</target>
        </trans-unit>
        <trans-unit id="b0f6ed9324058703ad0abd2e5aeb5b02eb6e2402" translate="yes" xml:space="preserve">
          <source>Item.activeFocusOnTab</source>
          <target state="translated">Item.activeFocusOnTab</target>
        </trans-unit>
        <trans-unit id="99f73e848e1a47d45fb82f37a8abd269ef1ca40a" translate="yes" xml:space="preserve">
          <source>Item.anchors.alignWhenCentered</source>
          <target state="translated">Item.anchors.alignWhenCentered</target>
        </trans-unit>
        <trans-unit id="648dec1468177bac4f366088a738b3ea62295b60" translate="yes" xml:space="preserve">
          <source>Item.antialiasing</source>
          <target state="translated">Item.antialiasing</target>
        </trans-unit>
        <trans-unit id="1dcb68f08b84479f9f044c783c049c51e9bd6f37" translate="yes" xml:space="preserve">
          <source>Item.baselineOffset</source>
          <target state="translated">Item.baselineOffset</target>
        </trans-unit>
        <trans-unit id="c7718760a49c645343545d9cd9a093354e96f659" translate="yes" xml:space="preserve">
          <source>Item.childAt()</source>
          <target state="translated">Item.childAt()</target>
        </trans-unit>
        <trans-unit id="a3fc2c9213406c79300077bd97d61587c1973e50" translate="yes" xml:space="preserve">
          <source>Item.children</source>
          <target state="translated">Item.children</target>
        </trans-unit>
        <trans-unit id="04bf25490fe94f3d6e6629b2c7181a75bf32308d" translate="yes" xml:space="preserve">
          <source>Item.childrenRect.height</source>
          <target state="translated">Item.childrenRect.height</target>
        </trans-unit>
        <trans-unit id="3a8dd3c9d2591e719b4601cb48cc73badd664ce5" translate="yes" xml:space="preserve">
          <source>Item.childrenRect.x</source>
          <target state="translated">Item.childrenRect.x</target>
        </trans-unit>
        <trans-unit id="4b0187fef6a32d6c649de2b82084902abf588068" translate="yes" xml:space="preserve">
          <source>Item.clip</source>
          <target state="translated">Item.clip</target>
        </trans-unit>
        <trans-unit id="50457da7b8530da1c842e0c9fbcdabdc2af272f5" translate="yes" xml:space="preserve">
          <source>Item.containmentMask</source>
          <target state="translated">Item.containmentMask</target>
        </trans-unit>
        <trans-unit id="4112a811d685dae838010670eeceb21eb463885e" translate="yes" xml:space="preserve">
          <source>Item.contains()</source>
          <target state="translated">Item.contains()</target>
        </trans-unit>
        <trans-unit id="e83ea1cf30733780fa3bf018a48498f647d68053" translate="yes" xml:space="preserve">
          <source>Item.data</source>
          <target state="translated">Item.data</target>
        </trans-unit>
        <trans-unit id="ec4421c33b5ed3c25c7cabf458ee157347971931" translate="yes" xml:space="preserve">
          <source>Item.enabled</source>
          <target state="translated">Item.enabled</target>
        </trans-unit>
        <trans-unit id="b5217c23c4612e1c38bd0b262cc273fbedb7f229" translate="yes" xml:space="preserve">
          <source>Item.focus</source>
          <target state="translated">Item.focus</target>
        </trans-unit>
        <trans-unit id="7e84d77c7563d241966998e105ea29a462c0a6ff" translate="yes" xml:space="preserve">
          <source>Item.forceActiveFocus()</source>
          <target state="translated">Item.forceActiveFocus()</target>
        </trans-unit>
        <trans-unit id="e5d5fc7a155fadf6e1e229d97b7e9bb9c711c91f" translate="yes" xml:space="preserve">
          <source>Item.grabToImage()</source>
          <target state="translated">Item.grabToImage()</target>
        </trans-unit>
        <trans-unit id="9bc42682539319d241f292f0a1c5ac600163640f" translate="yes" xml:space="preserve">
          <source>Item.groupanchors.top</source>
          <target state="translated">Item.groupanchors.top</target>
        </trans-unit>
        <trans-unit id="a68c240c117527351080e83f99af7268ad72f2e1" translate="yes" xml:space="preserve">
          <source>Item.height</source>
          <target state="translated">Item.height</target>
        </trans-unit>
        <trans-unit id="a14bc673bba1a441913b86bbf11036c0da50a03e" translate="yes" xml:space="preserve">
          <source>Item.implicitHeight</source>
          <target state="translated">Item.implicitHeight</target>
        </trans-unit>
        <trans-unit id="0f4084fe8ce2d122acd823167e9a6f70b3f1d6de" translate="yes" xml:space="preserve">
          <source>Item.implicitWidth</source>
          <target state="translated">Item.implicitWidth</target>
        </trans-unit>
        <trans-unit id="25eee9287b4d17cf22599dbe165db837874967cc" translate="yes" xml:space="preserve">
          <source>Item.layer.effect</source>
          <target state="translated">Item.layer.effect</target>
        </trans-unit>
        <trans-unit id="704162bd3a73d531caaf128646ec6aaed691b553" translate="yes" xml:space="preserve">
          <source>Item.layer.enabled</source>
          <target state="translated">Item.layer.enabled</target>
        </trans-unit>
        <trans-unit id="e4c54f1e21adf07f7e7758d66aa3afe402d19178" translate="yes" xml:space="preserve">
          <source>Item.layer.format</source>
          <target state="translated">Item.layer.format</target>
        </trans-unit>
        <trans-unit id="aa63a87947ff69acabd457aa4cd57db8aeac0e5b" translate="yes" xml:space="preserve">
          <source>Item.layer.mipmap</source>
          <target state="translated">Item.layer.mipmap</target>
        </trans-unit>
        <trans-unit id="499defac35a26b96e320eabda8161adfe6326538" translate="yes" xml:space="preserve">
          <source>Item.layer.samplerName</source>
          <target state="translated">Item.layer.samplerName</target>
        </trans-unit>
        <trans-unit id="2f60cea2cdbeacc8d47a80f074469ef5897eeb4f" translate="yes" xml:space="preserve">
          <source>Item.layer.samples</source>
          <target state="translated">Item.layer.samples</target>
        </trans-unit>
        <trans-unit id="73039fc683522df7851746a9551fb55c1919b978" translate="yes" xml:space="preserve">
          <source>Item.layer.smooth</source>
          <target state="translated">Item.layer.smooth</target>
        </trans-unit>
        <trans-unit id="64bb4c2c04c06caa9f50836130f8b715ac814543" translate="yes" xml:space="preserve">
          <source>Item.layer.sourceRect</source>
          <target state="translated">Item.layer.sourceRect</target>
        </trans-unit>
        <trans-unit id="55b851c7803a18907f319d8c8609ecfabf7aeaaf" translate="yes" xml:space="preserve">
          <source>Item.layer.textureMirroring</source>
          <target state="translated">Item.layer.textureMirroring</target>
        </trans-unit>
        <trans-unit id="d82e4209c0b3e7801f86eee2e0a2fc1b0fc61aab" translate="yes" xml:space="preserve">
          <source>Item.layer.textureSize</source>
          <target state="translated">Item.layer.textureSize</target>
        </trans-unit>
        <trans-unit id="980865b0abacacaebefa37646d20dd09c4f5898b" translate="yes" xml:space="preserve">
          <source>Item.layer.wrapMode</source>
          <target state="translated">Item.layer.wrapMode</target>
        </trans-unit>
        <trans-unit id="ecee123e02cdc70686f781839f572944d6edee2f" translate="yes" xml:space="preserve">
          <source>Item.mapFromGlobal()</source>
          <target state="translated">Item.mapFromGlobal()</target>
        </trans-unit>
        <trans-unit id="4a4b2ffb92fa06eeaea20c71a62f3910fd71fc36" translate="yes" xml:space="preserve">
          <source>Item.mapFromItem()</source>
          <target state="translated">Item.mapFromItem()</target>
        </trans-unit>
        <trans-unit id="ede43c5043eb8c4fd70f2b9a945d4347bb232282" translate="yes" xml:space="preserve">
          <source>Item.mapToGlobal()</source>
          <target state="translated">Item.mapToGlobal()</target>
        </trans-unit>
        <trans-unit id="980d2bbf8fef9f87dfb5b57982beb3350fd2e4ef" translate="yes" xml:space="preserve">
          <source>Item.mapToItem()</source>
          <target state="translated">Item.mapToItem()</target>
        </trans-unit>
        <trans-unit id="7ff4c1a72926bcb5cad78e784ea4be4d3c778819" translate="yes" xml:space="preserve">
          <source>Item.nextItemInFocusChain()</source>
          <target state="translated">Item.nextItemInFocusChain()</target>
        </trans-unit>
        <trans-unit id="ce16760e64736103c01cc396fa8848126d1259e2" translate="yes" xml:space="preserve">
          <source>Item.opacity</source>
          <target state="translated">Item.opacity</target>
        </trans-unit>
        <trans-unit id="6851de54caba283712995e0c05e73c257493eab9" translate="yes" xml:space="preserve">
          <source>Item.parent</source>
          <target state="translated">Item.parent</target>
        </trans-unit>
        <trans-unit id="bfc1d8d0da7a33fc0e0790f6caac39f2ebfcc08d" translate="yes" xml:space="preserve">
          <source>Item.rotation</source>
          <target state="translated">Item.rotation</target>
        </trans-unit>
        <trans-unit id="24fd4878eb8c2acbe48c8b7f749ad8ae43518ce1" translate="yes" xml:space="preserve">
          <source>Item.scale</source>
          <target state="translated">Item.scale</target>
        </trans-unit>
        <trans-unit id="3a1d14e2fb6b33e4bf90d8a3284577a06f77b967" translate="yes" xml:space="preserve">
          <source>Item.smooth</source>
          <target state="translated">Item.smooth</target>
        </trans-unit>
        <trans-unit id="64605fd62d8814ebea957e1ad660a8078cff122c" translate="yes" xml:space="preserve">
          <source>Item.state</source>
          <target state="translated">Item.state</target>
        </trans-unit>
        <trans-unit id="335ebd19659d8ccd5cb02d2db27578ff765b520e" translate="yes" xml:space="preserve">
          <source>Item.states</source>
          <target state="translated">Item.states</target>
        </trans-unit>
        <trans-unit id="e2616d10e51cb34ab36aac6114b61f0015286ff8" translate="yes" xml:space="preserve">
          <source>Item.transform</source>
          <target state="translated">Item.transform</target>
        </trans-unit>
        <trans-unit id="edfb7d3650e54aa73fe1307707d8564f15fecfac" translate="yes" xml:space="preserve">
          <source>Item.transformOrigin</source>
          <target state="translated">Item.transformOrigin</target>
        </trans-unit>
        <trans-unit id="cc993607e19c8c44433934a7c7308990e9160422" translate="yes" xml:space="preserve">
          <source>Item.transitions</source>
          <target state="translated">Item.transitions</target>
        </trans-unit>
        <trans-unit id="a7a33821c3855b8a2a6c87afb05db9111bdc706b" translate="yes" xml:space="preserve">
          <source>Item.visible</source>
          <target state="translated">Item.visible</target>
        </trans-unit>
        <trans-unit id="bb14ba6eabd7956b136e725fb286ce9e8da2717a" translate="yes" xml:space="preserve">
          <source>Item.visibleChildren</source>
          <target state="translated">Item.visibleChildren</target>
        </trans-unit>
        <trans-unit id="5e026367a5f0743de66e839a214aedc33a7577a5" translate="yes" xml:space="preserve">
          <source>Item.x</source>
          <target state="translated">Item.x</target>
        </trans-unit>
        <trans-unit id="a67f6252957c8222693e45dbf5dca5f206d2e876" translate="yes" xml:space="preserve">
          <source>Item.z</source>
          <target state="translated">Item.z</target>
        </trans-unit>
        <trans-unit id="3cb0cb271daf7d5a69a4c5259c7c358b9ec91d65" translate="yes" xml:space="preserve">
          <source>ItemChangeData Union</source>
          <target state="translated">ItemChangeData 연합</target>
        </trans-unit>
        <trans-unit id="76d2ddf46e72fbdfc28e0108bc64933229f8c97c" translate="yes" xml:space="preserve">
          <source>ItemChangeData::boolValue</source>
          <target state="translated">ItemChangeData::boolValue</target>
        </trans-unit>
        <trans-unit id="96c2fb53d609f4be6ee4d0dedd7d8bcfb1ca9c75" translate="yes" xml:space="preserve">
          <source>ItemChangeData::item</source>
          <target state="translated">ItemChangeData::item</target>
        </trans-unit>
        <trans-unit id="e64ff948a7f5d267348d9f243be1371a47ba35ef" translate="yes" xml:space="preserve">
          <source>ItemChangeData::realValue</source>
          <target state="translated">ItemChangeData::realValue</target>
        </trans-unit>
        <trans-unit id="5c26e35f78ec2e4245418d82b35b9a324ddb0322" translate="yes" xml:space="preserve">
          <source>ItemChangeData::window</source>
          <target state="translated">ItemChangeData::window</target>
        </trans-unit>
        <trans-unit id="e2e4050d7da13944711ac404be89b963b0652545" translate="yes" xml:space="preserve">
          <source>ItemDelegate</source>
          <target state="translated">ItemDelegate</target>
        </trans-unit>
        <trans-unit id="061a717c15d62af52f87fda1ef606cd6fdbb7b10" translate="yes" xml:space="preserve">
          <source>ItemDelegate (QML type)</source>
          <target state="translated">ItemDelegate (QML 유형)</target>
        </trans-unit>
        <trans-unit id="f8b6525eaf0338b9fa30d0fb55193e8bdf8b95a1" translate="yes" xml:space="preserve">
          <source>ItemDelegate Control</source>
          <target state="translated">항목 위임 제어</target>
        </trans-unit>
        <trans-unit id="12bda0d9c1e9c9e0caf42d57d173b423b4b37d51" translate="yes" xml:space="preserve">
          <source>ItemDelegate QML Type</source>
          <target state="translated">ItemDelegate QML 유형</target>
        </trans-unit>
        <trans-unit id="cf151464335cae8f344c0ed43abbbed24a6409e4" translate="yes" xml:space="preserve">
          <source>ItemDelegate inherits its API from &lt;a href=&quot;qml-qtquick-controls2-abstractbutton&quot;&gt;AbstractButton&lt;/a&gt;. For instance, you can set &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#text-prop&quot;&gt;text&lt;/a&gt;, display an &lt;a href=&quot;qtquickcontrols2-icons&quot;&gt;icon&lt;/a&gt;, and react to &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#clicked-signal&quot;&gt;clicks&lt;/a&gt; using the &lt;a href=&quot;qml-qtquick-controls2-abstractbutton&quot;&gt;AbstractButton&lt;/a&gt; API.</source>
          <target state="translated">ItemDelegate는 &lt;a href=&quot;qml-qtquick-controls2-abstractbutton&quot;&gt;AbstractButton&lt;/a&gt; 에서 API를 상속합니다 . 예를 들어 &lt;a href=&quot;qml-qtquick-controls2-abstractbutton&quot;&gt;AbstractButton&lt;/a&gt; API를 사용하여 &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#text-prop&quot;&gt;텍스트&lt;/a&gt; 를 설정 하고 &lt;a href=&quot;qtquickcontrols2-icons&quot;&gt;아이콘을&lt;/a&gt; 표시하고 클릭 에 반응 할 &lt;a href=&quot;qml-qtquick-controls2-abstractbutton#clicked-signal&quot;&gt;수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ef4fe0cf3313a5e19effd6101790d4a54f8c424" translate="yes" xml:space="preserve">
          <source>ItemDelegate presents a standard view item. It can be used as a delegate in various views and controls, such as &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-combobox&quot;&gt;ComboBox&lt;/a&gt;.</source>
          <target state="translated">ItemDelegate는 표준보기 항목을 제공합니다. &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-combobox&quot;&gt;ComboBox&lt;/a&gt; 와 같은 다양한보기 및 컨트롤에서 대리자로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbb6b091b8144cc11f08f9461eb154f7e8c90c30" translate="yes" xml:space="preserve">
          <source>ItemDelegate.highlighted</source>
          <target state="translated">ItemDelegate.highlighted</target>
        </trans-unit>
        <trans-unit id="9266f6ec1bbfc565be01364d85713feb2f7673ef" translate="yes" xml:space="preserve">
          <source>ItemGrabResult</source>
          <target state="translated">ItemGrabResult</target>
        </trans-unit>
        <trans-unit id="62a2808fd16bfa5a727bffe9475e9f2ec0a122a0" translate="yes" xml:space="preserve">
          <source>ItemGrabResult (QML type)</source>
          <target state="translated">ItemGrabResult (QML 유형)</target>
        </trans-unit>
        <trans-unit id="9c4dcafec047c8086b54dd7d90b5021907005f14" translate="yes" xml:space="preserve">
          <source>ItemGrabResult QML Type</source>
          <target state="translated">ItemGrabResult QML 유형</target>
        </trans-unit>
        <trans-unit id="f99a69d9f0eeb0c2b35a24a727446561aa3ce2c6" translate="yes" xml:space="preserve">
          <source>ItemGrabResult.image</source>
          <target state="translated">ItemGrabResult.image</target>
        </trans-unit>
        <trans-unit id="7a2678f07ac5add6a0e88b42e7d55e5f8e242584" translate="yes" xml:space="preserve">
          <source>ItemGrabResult.saveToFile()</source>
          <target state="translated">ItemGrabResult.saveToFile()</target>
        </trans-unit>
        <trans-unit id="5fcb44f7f7385467a495b26ed8746132b8f1951b" translate="yes" xml:space="preserve">
          <source>ItemGrabResult.url</source>
          <target state="translated">ItemGrabResult.url</target>
        </trans-unit>
        <trans-unit id="25d6fe855799241be95812106f4fb8d24bd8fb2d" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy</source>
          <target state="translated">ItemModelBarDataProxy</target>
        </trans-unit>
        <trans-unit id="252631736bb9e8c87964de278ca385377a9ea630" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy (QML type)</source>
          <target state="translated">ItemModelBarDataProxy (QML 유형)</target>
        </trans-unit>
        <trans-unit id="095d49ecc1adcc137b82088e004b3cd6f8af1067" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy QML Type</source>
          <target state="translated">ItemModelBarDataProxy QML 유형</target>
        </trans-unit>
        <trans-unit id="33bc3632483b8ee21272fff1f7c77f687b2fbc34" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.autoColumnCategories</source>
          <target state="translated">ItemModelBarDataProxy.autoColumnCategories</target>
        </trans-unit>
        <trans-unit id="cc9977655bf858a4bd7622880a80bfced30bffe6" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.autoRowCategories</source>
          <target state="translated">ItemModelBarDataProxy.autoRowCategories</target>
        </trans-unit>
        <trans-unit id="ffca0d87a40366e9628d3df7bb21167d068ececa" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.columnCategories</source>
          <target state="translated">ItemModelBarDataProxy.columnCategories</target>
        </trans-unit>
        <trans-unit id="17eb182c137622845d297cc0a5fcb95a9eada707" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.columnRole</source>
          <target state="translated">ItemModelBarDataProxy.columnRole</target>
        </trans-unit>
        <trans-unit id="fa789340debb344d56384cd1fd1884df7b07edb9" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.columnRolePattern</source>
          <target state="translated">ItemModelBarDataProxy.columnRolePattern</target>
        </trans-unit>
        <trans-unit id="51f8e4549d40bf5fc682dd30bbe7d16362fa8aad" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.columnRoleReplace</source>
          <target state="translated">ItemModelBarDataProxy.columnRoleReplace</target>
        </trans-unit>
        <trans-unit id="2b3cb55b99ac1ba2ee471294eb2476388009642e" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.itemModel</source>
          <target state="translated">ItemModelBarDataProxy.itemModel</target>
        </trans-unit>
        <trans-unit id="02af90c81cd96c1332853d9bf97c0e7438972a78" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.multiMatchBehavior</source>
          <target state="translated">ItemModelBarDataProxy.multiMatchBehavior</target>
        </trans-unit>
        <trans-unit id="0bae27ce81be571a531763233a3008c4e2c6596d" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.rotationRole</source>
          <target state="translated">ItemModelBarDataProxy.rotationRole</target>
        </trans-unit>
        <trans-unit id="5a28ea345b1d042feec6bf6dd6129f63efd0626c" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.rotationRolePattern</source>
          <target state="translated">ItemModelBarDataProxy.rotationRolePattern</target>
        </trans-unit>
        <trans-unit id="47a8e07c9eeda1dc487a334e2fa2e0455ef0e29d" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.rotationRoleReplace</source>
          <target state="translated">ItemModelBarDataProxy.rotationRoleReplace</target>
        </trans-unit>
        <trans-unit id="faa99d07fdf1bd31ab542e5f5c02bd6ec848d04a" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.rowCategories</source>
          <target state="translated">ItemModelBarDataProxy.rowCategories</target>
        </trans-unit>
        <trans-unit id="6958f9cf9b7dd74f86affa1ed0309c1e7ea0f5e4" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.rowRole</source>
          <target state="translated">ItemModelBarDataProxy.rowRole</target>
        </trans-unit>
        <trans-unit id="9af56d02c338e8f6e98e8d01149855837b144277" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.rowRolePattern</source>
          <target state="translated">ItemModelBarDataProxy.rowRolePattern</target>
        </trans-unit>
        <trans-unit id="2c5baf65fe7aa2768be23be40c729caac4c7bc29" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.rowRoleReplace</source>
          <target state="translated">ItemModelBarDataProxy.rowRoleReplace</target>
        </trans-unit>
        <trans-unit id="e29f8afd146412af918492ee9800e58d5c1ecbb6" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.useModelCategories</source>
          <target state="translated">ItemModelBarDataProxy.useModelCategories</target>
        </trans-unit>
        <trans-unit id="847c446f92eec01170e4bdb0c4586757fec8a342" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.valueRole</source>
          <target state="translated">ItemModelBarDataProxy.valueRole</target>
        </trans-unit>
        <trans-unit id="6d88dce67436066eccf7a4f4f74f00176e763c7a" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.valueRolePattern</source>
          <target state="translated">ItemModelBarDataProxy.valueRolePattern</target>
        </trans-unit>
        <trans-unit id="2d7bc9869f7c4353fdc16b5a2d9c5265033c17c0" translate="yes" xml:space="preserve">
          <source>ItemModelBarDataProxy.valueRoleReplace</source>
          <target state="translated">ItemModelBarDataProxy.valueRoleReplace</target>
        </trans-unit>
        <trans-unit id="9db442fccf817f8c55d4a93b93f17864fdcebb45" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy</source>
          <target state="translated">ItemModelScatterDataProxy</target>
        </trans-unit>
        <trans-unit id="24fe1905777e20ea518cdd31f9dba5577120d6cd" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy (QML type)</source>
          <target state="translated">ItemModelScatterDataProxy (QML 유형)</target>
        </trans-unit>
        <trans-unit id="5d040ba40acd09a3995f63133fe8943ac947c55d" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy QML Type</source>
          <target state="translated">ItemModelScatterDataProxy QML 유형</target>
        </trans-unit>
        <trans-unit id="d3728aed1ff2e86a4080682af4b064b0aacfa50e" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.itemModel</source>
          <target state="translated">ItemModelScatterDataProxy.itemModel</target>
        </trans-unit>
        <trans-unit id="b4f4a1d99b29159ea628edd04faaf902043d7a9c" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.rotationRole</source>
          <target state="translated">ItemModelScatterDataProxy.rotationRole</target>
        </trans-unit>
        <trans-unit id="aa737e1cb9c29a8a36cbbcb5f220d0af1535aa6b" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.rotationRolePattern</source>
          <target state="translated">ItemModelScatterDataProxy.rotationRolePattern</target>
        </trans-unit>
        <trans-unit id="191e290c1df8dfa7c451e45897ad61b018f2e2dd" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.rotationRoleReplace</source>
          <target state="translated">ItemModelScatterDataProxy.rotationRoleReplace</target>
        </trans-unit>
        <trans-unit id="d1529189c93dcaa9ea95152a9f5c44dad6504485" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.xPosRole</source>
          <target state="translated">ItemModelScatterDataProxy.xPosRole</target>
        </trans-unit>
        <trans-unit id="8c5304b2c4f2a4adb5363b4bc7492b632fd37d2c" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.xPosRolePattern</source>
          <target state="translated">ItemModelScatterDataProxy.xPosRolePattern</target>
        </trans-unit>
        <trans-unit id="e346e7d1e45d601e0286c7da44e20d4876e38446" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.xPosRoleReplace</source>
          <target state="translated">ItemModelScatterDataProxy.xPosRoleReplace</target>
        </trans-unit>
        <trans-unit id="a69abc69ce2255817f5869cf731a01cf7ea2bbf9" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.yPosRole</source>
          <target state="translated">ItemModelScatterDataProxy.yPosRole</target>
        </trans-unit>
        <trans-unit id="bc8a68f341cabc425388b9e04cf70fad458c929b" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.yPosRolePattern</source>
          <target state="translated">ItemModelScatterDataProxy.yPosRolePattern</target>
        </trans-unit>
        <trans-unit id="2e913b810d24b77377f7a49c180513ff35e88f0f" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.yPosRoleReplace</source>
          <target state="translated">ItemModelScatterDataProxy.yPosRoleReplace</target>
        </trans-unit>
        <trans-unit id="c5ee886e4a0d6218737a05f9ecc0ad0de974e937" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.zPosRole</source>
          <target state="translated">ItemModelScatterDataProxy.zPosRole</target>
        </trans-unit>
        <trans-unit id="97d4a42fb297f9defc769686924b5d1333bbedf5" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.zPosRolePattern</source>
          <target state="translated">ItemModelScatterDataProxy.zPosRolePattern</target>
        </trans-unit>
        <trans-unit id="347a30e4e1813ddb255d03b078dadf25cca86ed0" translate="yes" xml:space="preserve">
          <source>ItemModelScatterDataProxy.zPosRoleReplace</source>
          <target state="translated">ItemModelScatterDataProxy.zPosRoleReplace</target>
        </trans-unit>
        <trans-unit id="dc50393bd8a9fa2beb3d53a3a77f8f215cb9684f" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy</source>
          <target state="translated">ItemModelSurfaceDataProxy</target>
        </trans-unit>
        <trans-unit id="de4210de2596b98ae92e31354525d334157240ca" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy (QML type)</source>
          <target state="translated">ItemModelSurfaceDataProxy (QML 유형)</target>
        </trans-unit>
        <trans-unit id="bb0145632c975728c52910d3aade20ce0ef3e6d2" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy QML Type</source>
          <target state="translated">ItemModelSurfaceDataProxy QML 유형</target>
        </trans-unit>
        <trans-unit id="409167d10b11021dde2510df1858d2e25a6edf39" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.autoColumnCategories</source>
          <target state="translated">ItemModelSurfaceDataProxy.autoColumnCategories</target>
        </trans-unit>
        <trans-unit id="b3b26cfb70f90d1d240874bc36aea619d3f647bf" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.autoRowCategories</source>
          <target state="translated">ItemModelSurfaceDataProxy.autoRowCategories</target>
        </trans-unit>
        <trans-unit id="1e846167d590d8323242dd56b0c08fce53796909" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.columnCategories</source>
          <target state="translated">ItemModelSurfaceDataProxy.columnCategories</target>
        </trans-unit>
        <trans-unit id="9bb7befc661a5092624b0f5dc66dd53e175467a6" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.columnRole</source>
          <target state="translated">ItemModelSurfaceDataProxy.columnRole</target>
        </trans-unit>
        <trans-unit id="5b44c33e952fd90a0989bce537e6f035ee7d6bd6" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.columnRolePattern</source>
          <target state="translated">ItemModelSurfaceDataProxy.columnRolePattern</target>
        </trans-unit>
        <trans-unit id="d5774e73deccc8aeb903fe225dd2b685734e2423" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.columnRoleReplace</source>
          <target state="translated">ItemModelSurfaceDataProxy.columnRoleReplace</target>
        </trans-unit>
        <trans-unit id="fba9bfeebfd5e26187a6a05c83903b83df9e5bee" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.itemModel</source>
          <target state="translated">ItemModelSurfaceDataProxy.itemModel</target>
        </trans-unit>
        <trans-unit id="ea8a349fa2509ed30cc7aa35db4d99d9503c0acb" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.multiMatchBehavior</source>
          <target state="translated">ItemModelSurfaceDataProxy.multiMatchBehavior</target>
        </trans-unit>
        <trans-unit id="cecaf2fdedc6efe146765c314b5c1f725f2122f7" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.rowCategories</source>
          <target state="translated">ItemModelSurfaceDataProxy.rowCategories</target>
        </trans-unit>
        <trans-unit id="ccc04ac83167a688ed86bb8b712487b685e7b914" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.rowRole</source>
          <target state="translated">ItemModelSurfaceDataProxy.rowRole</target>
        </trans-unit>
        <trans-unit id="d9a21ed90407e963598308de6a0b36251732956f" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.rowRolePattern</source>
          <target state="translated">ItemModelSurfaceDataProxy.rowRolePattern</target>
        </trans-unit>
        <trans-unit id="7a9078969e874aabc8dca0e7b7117f44f1b384ee" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.rowRoleReplace</source>
          <target state="translated">ItemModelSurfaceDataProxy.rowRoleReplace</target>
        </trans-unit>
        <trans-unit id="1d070ae7363b392f7947a5fd68c9fc04511d869b" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.useModelCategories</source>
          <target state="translated">ItemModelSurfaceDataProxy.useModelCategories</target>
        </trans-unit>
        <trans-unit id="166de7b5b115dd918f4dc2c35fdf45c83d0567b8" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.xPosRole</source>
          <target state="translated">ItemModelSurfaceDataProxy.xPosRole</target>
        </trans-unit>
        <trans-unit id="ec34f45c3f2f255362b4f8bdc2b5d0517393f1a7" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.xPosRolePattern</source>
          <target state="translated">ItemModelSurfaceDataProxy.xPosRolePattern</target>
        </trans-unit>
        <trans-unit id="316a5824c1caf2401d4888bbeeee8fef66db2736" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.xPosRoleReplace</source>
          <target state="translated">ItemModelSurfaceDataProxy.xPosRoleReplace</target>
        </trans-unit>
        <trans-unit id="876e0fc937a5efcb869eac11d69a2cd5be589b59" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.yPosRole</source>
          <target state="translated">ItemModelSurfaceDataProxy.yPosRole</target>
        </trans-unit>
        <trans-unit id="e6010021e8bfe95c1bd411b8fb3339363702ce06" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.yPosRolePattern</source>
          <target state="translated">ItemModelSurfaceDataProxy.yPosRolePattern</target>
        </trans-unit>
        <trans-unit id="c2ace34bf57b08a5f74545ee6da3aece0169f82b" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.yPosRoleReplace</source>
          <target state="translated">ItemModelSurfaceDataProxy.yPosRoleReplace</target>
        </trans-unit>
        <trans-unit id="d80099b8aa8360fc68c61e13735104805e482855" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.zPosRole</source>
          <target state="translated">ItemModelSurfaceDataProxy.zPosRole</target>
        </trans-unit>
        <trans-unit id="98377022091b759589cf91dbb1a66fea86486ecf" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.zPosRolePattern</source>
          <target state="translated">ItemModelSurfaceDataProxy.zPosRolePattern</target>
        </trans-unit>
        <trans-unit id="8914993e172e61ddcbe2116798cbf36f58cec1f1" translate="yes" xml:space="preserve">
          <source>ItemModelSurfaceDataProxy.zPosRoleReplace</source>
          <target state="translated">ItemModelSurfaceDataProxy.zPosRoleReplace</target>
        </trans-unit>
        <trans-unit id="510c166f06a31c55ca1796b38c49af972b865608" translate="yes" xml:space="preserve">
          <source>ItemParticle (QML type)</source>
          <target state="translated">ItemParticle (QML 유형)</target>
        </trans-unit>
        <trans-unit id="ec643200fa57d3adbc90b4ef7ccb997c5fa01820" translate="yes" xml:space="preserve">
          <source>ItemParticle QML Type</source>
          <target state="translated">ItemParticle QML 유형</target>
        </trans-unit>
        <trans-unit id="cd7b8ea99d0d3ffb71ac54d53b87523b6de32115" translate="yes" xml:space="preserve">
          <source>ItemParticle.delegate</source>
          <target state="translated">ItemParticle.delegate</target>
        </trans-unit>
        <trans-unit id="168bf87c645df06dfbf58a39ea239d988bebf1b5" translate="yes" xml:space="preserve">
          <source>ItemParticle.fade</source>
          <target state="translated">ItemParticle.fade</target>
        </trans-unit>
        <trans-unit id="5f2797df202436c97730a21aa8ca07ecfb7bc2e1" translate="yes" xml:space="preserve">
          <source>ItemParticle.freeze()</source>
          <target state="translated">ItemParticle.freeze()</target>
        </trans-unit>
        <trans-unit id="105c94b84927800646757a592071c2f259f97ce2" translate="yes" xml:space="preserve">
          <source>ItemParticle.give()</source>
          <target state="translated">ItemParticle.give()</target>
        </trans-unit>
        <trans-unit id="baa621ed4fb486044df0ca4516c536f8108c6d78" translate="yes" xml:space="preserve">
          <source>ItemParticle.take()</source>
          <target state="translated">ItemParticle.take()</target>
        </trans-unit>
        <trans-unit id="816b7a8421510768d96a9531898f621a6badf641" translate="yes" xml:space="preserve">
          <source>ItemParticle.unfreeze()</source>
          <target state="translated">ItemParticle.unfreeze()</target>
        </trans-unit>
        <trans-unit id="b4e182c61cfd75b83e4f068403ec6b5b1cbd3c50" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel (QML type)</source>
          <target state="translated">ItemSelectionModel (QML 유형)</target>
        </trans-unit>
        <trans-unit id="365053800cbdb27788e868134a23f16080fd31db" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel QML Type</source>
          <target state="translated">ItemSelectionModel QML 유형</target>
        </trans-unit>
        <trans-unit id="eae41cb3c566799839ce2f3ed78dc7c31dfd28e9" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.clear()</source>
          <target state="translated">ItemSelectionModel.clear()</target>
        </trans-unit>
        <trans-unit id="658c25c60f34b6b43dd0eb9c2595d9ea21d779b4" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.clearCurrentIndex()</source>
          <target state="translated">ItemSelectionModel.clearCurrentIndex()</target>
        </trans-unit>
        <trans-unit id="58f058cd2a3e2d6bac4d6125e1d2afba1d5de9e5" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.clearSelection()</source>
          <target state="translated">ItemSelectionModel.clearSelection()</target>
        </trans-unit>
        <trans-unit id="781d67c3d53e1a28d8045a5171b02da0de123bfa" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.columnIntersectsSelection()</source>
          <target state="translated">ItemSelectionModel.columnIntersectsSelection()</target>
        </trans-unit>
        <trans-unit id="716784458671802620862b614462881acc6c0199" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.currentChanged()</source>
          <target state="translated">ItemSelectionModel.currentChanged()</target>
        </trans-unit>
        <trans-unit id="aa9a00d9e9b9a9ea5b19a1522ad3e1b45baeb0d3" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.currentIndex</source>
          <target state="translated">ItemSelectionModel.currentIndex</target>
        </trans-unit>
        <trans-unit id="68bd976e26ac0ad40839ad566cf88232b228a864" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.hasSelection</source>
          <target state="translated">ItemSelectionModel.hasSelection</target>
        </trans-unit>
        <trans-unit id="94280d1f5fe7b111f5fb8554e34a0fb8ab875a27" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.isColumnSelected()</source>
          <target state="translated">ItemSelectionModel.isColumnSelected()</target>
        </trans-unit>
        <trans-unit id="1d070dde923056eb944bbfa80419df715acfd1db" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.isRowSelected()</source>
          <target state="translated">ItemSelectionModel.isRowSelected()</target>
        </trans-unit>
        <trans-unit id="f353483c95bfb7eb5e36f2aedec9e948b0fedbee" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.isSelected()</source>
          <target state="translated">ItemSelectionModel.isSelected()</target>
        </trans-unit>
        <trans-unit id="841a854de63871867abe28a93d902432bda2b08c" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.model</source>
          <target state="translated">ItemSelectionModel.model</target>
        </trans-unit>
        <trans-unit id="3cc25ed79e859daf2b55a7358889eae3ab3b415e" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.reset()</source>
          <target state="translated">ItemSelectionModel.reset()</target>
        </trans-unit>
        <trans-unit id="0ff00782bccae101d794a5b2546d8636de09e870" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.rowIntersectsSelection()</source>
          <target state="translated">ItemSelectionModel.rowIntersectsSelection()</target>
        </trans-unit>
        <trans-unit id="c55528c3b36761c4073ed620961beda8f9f4bc20" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.select()</source>
          <target state="translated">ItemSelectionModel.select()</target>
        </trans-unit>
        <trans-unit id="7c3ca8577d437912b30592e6e1dce15cc91d843f" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.selectedColumns()</source>
          <target state="translated">ItemSelectionModel.selectedColumns()</target>
        </trans-unit>
        <trans-unit id="f073ffffd75c1a00d900e7a5f3a149be22c1aa54" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.selectedIndexes</source>
          <target state="translated">ItemSelectionModel.selectedIndexes</target>
        </trans-unit>
        <trans-unit id="0634f54552caf0cacbc753238215905001f49e2a" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.selectedRows()</source>
          <target state="translated">ItemSelectionModel.selectedRows()</target>
        </trans-unit>
        <trans-unit id="e42ca34903a5b62496a15ae4c76ad69443e60487" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.selection</source>
          <target state="translated">ItemSelectionModel.selection</target>
        </trans-unit>
        <trans-unit id="e9dc342e2db44b6bda8690961659a4ce31044cbd" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.selectionChanged()</source>
          <target state="translated">ItemSelectionModel.selectionChanged()</target>
        </trans-unit>
        <trans-unit id="c2477bb2bd63937b4d95b178b21727cdc5173008" translate="yes" xml:space="preserve">
          <source>ItemSelectionModel.setCurrentIndex()</source>
          <target state="translated">ItemSelectionModel.setCurrentIndex()</target>
        </trans-unit>
        <trans-unit id="65a9faf0566740be42792dfed4267bc02dd52174" translate="yes" xml:space="preserve">
          <source>Items &quot;A&quot; and &quot;C&quot; are represented as top-level siblings in the model:</source>
          <target state="translated">&quot;A&quot;및 &quot;C&quot;항목은 모델에서 최상위 형제로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="46212333ee13d5b8b649b5f4f7340dd0168a0401" translate="yes" xml:space="preserve">
          <source>Items Overlay Plugin</source>
          <target state="translated">아이템 오버레이 플러그인</target>
        </trans-unit>
        <trans-unit id="8be2d5d41bbc604f262bf2869c6873a499abfb26" translate="yes" xml:space="preserve">
          <source>Items are added to the layout by reparenting the item to the layout. Similarly, removal is done by reparenting the item from the layout. Both of these operations will affect the layout's &lt;a href=&quot;qml-qtquick-layouts-stacklayout#count-prop&quot;&gt;count&lt;/a&gt; property.</source>
          <target state="translated">항목을 레이아웃으로 재지 정하여 항목을 레이아웃에 추가합니다. 마찬가지로, 레이아웃에서 항목을 재지 정하여 제거를 수행합니다. 이 두 작업은 모두 레이아웃의 &lt;a href=&quot;qml-qtquick-layouts-stacklayout#count-prop&quot;&gt;개수&lt;/a&gt; 속성에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="f95270f6313d907758bdd6a6622c45a389f7d6bd" translate="yes" xml:space="preserve">
          <source>Items are added using &lt;a href=&quot;qtoolbox#addItem&quot;&gt;addItem&lt;/a&gt;(), or inserted at particular positions using &lt;a href=&quot;qtoolbox#insertItem&quot;&gt;insertItem&lt;/a&gt;(). The total number of items is given by &lt;a href=&quot;qtoolbox#count-prop&quot;&gt;count&lt;/a&gt;(). Items can be deleted with delete, or removed from the toolbox with &lt;a href=&quot;qtoolbox#removeItem&quot;&gt;removeItem&lt;/a&gt;(). Combining &lt;a href=&quot;qtoolbox#removeItem&quot;&gt;removeItem&lt;/a&gt;() and &lt;a href=&quot;qtoolbox#insertItem&quot;&gt;insertItem&lt;/a&gt;() allows you to move items to different positions.</source>
          <target state="translated">&lt;a href=&quot;qtoolbox#addItem&quot;&gt;addItem&lt;/a&gt; ()을 사용하여 항목을 추가 하거나 &lt;a href=&quot;qtoolbox#insertItem&quot;&gt;insertItem&lt;/a&gt; ()을 사용하여 특정 위치에 항목을 삽입 합니다. 총 항목 수는 &lt;a href=&quot;qtoolbox#count-prop&quot;&gt;개수&lt;/a&gt; ()로 제공됩니다. 항목을 삭제하면 삭제하거나 &lt;a href=&quot;qtoolbox#removeItem&quot;&gt;removeItem&lt;/a&gt; () 을 사용하여 도구 상자에서 제거 할 수 있습니다 . &lt;a href=&quot;qtoolbox#removeItem&quot;&gt;removeItem&lt;/a&gt; ()과 &lt;a href=&quot;qtoolbox#insertItem&quot;&gt;insertItem&lt;/a&gt; ()을 결합하면 항목을 다른 위치로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43cef668eaa4621f32f72f2ac815b17ddae7bfb0" translate="yes" xml:space="preserve">
          <source>Items are constructed outside the table before being added to the table at the required location:</source>
          <target state="translated">필요한 위치에서 테이블에 추가되기 전에 테이블 외부에 항목이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="236d26a72f36345cda6aeb534e4e2b0e85476a41" translate="yes" xml:space="preserve">
          <source>Items are created outside the table (with no parent widget) and inserted into the table with &lt;a href=&quot;qtablewidget#setItem&quot;&gt;setItem&lt;/a&gt;():</source>
          <target state="translated">항목은 상위 위젯없이 테이블 외부에서 작성되고 &lt;a href=&quot;qtablewidget#setItem&quot;&gt;setItem&lt;/a&gt; () 을 사용하여 테이블에 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="90a51a7db06ffa40d912bf2859725e04970d9737" translate="yes" xml:space="preserve">
          <source>Items are enabled by default.</source>
          <target state="translated">항목은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="63a50f895cf7c7348e097466311c210a82e215af" translate="yes" xml:space="preserve">
          <source>Items are laid out from left to right.</source>
          <target state="translated">항목은 왼쪽에서 오른쪽으로 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="679b6c26b596accf99943676e6b9c7381bad317a" translate="yes" xml:space="preserve">
          <source>Items are laid out from right to left.</source>
          <target state="translated">항목은 오른쪽에서 왼쪽으로 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="0ac57a8bbc502e2892f2200c94c022d0b693c649" translate="yes" xml:space="preserve">
          <source>Items are not selected by default.</source>
          <target state="translated">기본적으로 항목이 선택되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="767caf12d6ddbe938f8dd7fb62b28a4c131f3c29" translate="yes" xml:space="preserve">
          <source>Items are painted by the view, starting with the parent items and then drawing children, in ascending stacking order. You can set an item's stacking order by calling &lt;a href=&quot;qgraphicsitem#setZValue&quot;&gt;setZValue&lt;/a&gt;(), and test it by calling &lt;a href=&quot;qgraphicsitem#zValue&quot;&gt;zValue&lt;/a&gt;(), where items with low z-values are painted before items with high z-values. Stacking order applies to sibling items; parents are always drawn before their children.</source>
          <target state="translated">항목은 상위 항목부터 시작하여 하위 항목을 오름차순으로 오름차순으로 표시하여 뷰에 의해 페인트됩니다. &lt;a href=&quot;qgraphicsitem#setZValue&quot;&gt;setZValue&lt;/a&gt; () 를 호출하여 항목의 스택 순서를 설정하고 z 값이 낮은 항목이 z 값이 높은 항목보다 먼저 페인트되는 &lt;a href=&quot;qgraphicsitem#zValue&quot;&gt;zValue&lt;/a&gt; () 를 호출하여 테스트 할 수 있습니다. 스택 순서는 형제 항목에 적용됩니다. 부모는 항상 자녀보다 먼저 그려집니다.</target>
        </trans-unit>
        <trans-unit id="7d53dfd021bc1e218d6f0a38d8260aab35656b5f" translate="yes" xml:space="preserve">
          <source>Items are referred to by their row and column numbers, and by the model index of their parent items.</source>
          <target state="translated">항목은 행과 열 번호 및 상위 항목의 모델 색인으로 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="df295ae67c4f2705d78cb38b9cc596b98838f8a8" translate="yes" xml:space="preserve">
          <source>Items are rendered in the order they have been inserted. The rendering order needs to be taken into account when having solid and transparent items.</source>
          <target state="translated">항목은 삽입 된 순서대로 렌더링됩니다. 단단하고 투명한 항목이있는 경우 렌더링 순서를 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="9bf17fdd9ff4d8b4858c884d5ab9c18080f1744a" translate="yes" xml:space="preserve">
          <source>Items are searched for by the text that they contain according to criteria specified by a selection of values from &lt;a href=&quot;qt#MatchFlag-enum&quot;&gt;Qt::MatchFlags&lt;/a&gt;. We can obtain a list of matching items with the &lt;code&gt;findItems()&lt;/code&gt; function:</source>
          <target state="translated">&lt;a href=&quot;qt#MatchFlag-enum&quot;&gt;Qt :: MatchFlags&lt;/a&gt; 에서 값을 선택하여 지정된 기준에 따라 포함 된 텍스트로 항목을 검색합니다 . &lt;code&gt;findItems()&lt;/code&gt; 함수를 사용하여 일치하는 항목 목록을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="955d061888afb4e42b6c5d88930e75e9b513ada7" translate="yes" xml:space="preserve">
          <source>Items are usually constructed with a parent that is either a &lt;a href=&quot;qtreewidget&quot;&gt;QTreeWidget&lt;/a&gt; (for top-level items) or a &lt;a href=&quot;qtreewidgetitem&quot;&gt;QTreeWidgetItem&lt;/a&gt; (for items on lower levels of the tree). For example, the following code constructs a top-level item to represent cities of the world, and adds a entry for Oslo as a child item:</source>
          <target state="translated">항목은 일반적으로 &lt;a href=&quot;qtreewidget&quot;&gt;QTreeWidget&lt;/a&gt; (최상위 항목의 경우) 또는 &lt;a href=&quot;qtreewidgetitem&quot;&gt;QTreeWidgetItem&lt;/a&gt; (트리의 하위 레벨에있는 항목) 인 상위 항목으로 구성됩니다 . 예를 들어 다음 코드는 세계 도시를 나타내는 최상위 항목을 구성하고 오슬로 항목을 하위 항목으로 추가합니다.</target>
        </trans-unit>
        <trans-unit id="bdc479a7e1a6927f9cff74d07669be448d4e3a54" translate="yes" xml:space="preserve">
          <source>Items are usually constructed with a parent that is either a &lt;a href=&quot;qtreewidget&quot;&gt;QTreeWidget&lt;/a&gt; (for top-level items) or a QTreeWidgetItem (for items on lower levels of the tree). For example, the following code constructs a top-level item to represent cities of the world, and adds a entry for Oslo as a child item:</source>
          <target state="translated">항목은 일반적으로 &lt;a href=&quot;qtreewidget&quot;&gt;QTreeWidget&lt;/a&gt; (최상위 항목의 경우) 또는 QTreeWidgetItem (트리의 하위 수준에있는 항목의 경우) 인 부모로 구성됩니다 . 예를 들어 다음 코드는 세계의 도시를 나타내는 최상위 항목을 생성하고 Oslo에 대한 항목을 자식 항목으로 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d45046b9ad1adeae0dfb733a84cb3fcf4475394d" translate="yes" xml:space="preserve">
          <source>Items are visible by default; it is unnecessary to call setVisible() on a new item.</source>
          <target state="translated">기본적으로 항목이 표시됩니다. 새 항목에서 setVisible ()을 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="a9f0432b5887431e7c6de6ec34f28b674edf1c42" translate="yes" xml:space="preserve">
          <source>Items can be added at either end of the list using &lt;a href=&quot;qlist#append&quot;&gt;QList::append&lt;/a&gt;() and &lt;a href=&quot;qlist#prepend&quot;&gt;QList::prepend&lt;/a&gt;(), or they can be inserted in the middle using &lt;a href=&quot;qlist#insert&quot;&gt;QList::insert&lt;/a&gt;(). More than any other container class, &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; is highly optimized to expand to as little code as possible in the executable. &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; inherits from &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&lt;a href=&quot;qlist#append&quot;&gt;QList :: append&lt;/a&gt; () 및 &lt;a href=&quot;qlist#prepend&quot;&gt;QList :: prepend&lt;/a&gt; ()를 사용하여 목록의 한쪽 끝에 항목을 추가 하거나 &lt;a href=&quot;qlist#insert&quot;&gt;QList :: insert&lt;/a&gt; ()를 사용하여 중간에 항목을 삽입 할 수 있습니다 . 다른 컨테이너 클래스보다 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 는 실행 파일에서 가능한 적은 코드로 확장하도록 고도로 최적화되었습니다. &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; 는 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; &amp;lt; &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;gt; 에서 상속 합니다.</target>
        </trans-unit>
        <trans-unit id="245bec2b6eca6b76b8b850f229ec2f04fe84f5ba" translate="yes" xml:space="preserve">
          <source>Items can be added in a particular order by specifying the item they follow when they are constructed:</source>
          <target state="translated">아이템은 구성 될 때 따라 오는 아이템을 지정하여 특정 순서로 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24ba2c3ff8f6b0ebc6e290ac65a2f78559a465d5" translate="yes" xml:space="preserve">
          <source>Items can be deleted using the &lt;code&gt;destroy()&lt;/code&gt; method. This method has an optional argument (which defaults to 0) that specifies the approximate delay in milliseconds before the object is to be destroyed.</source>
          <target state="translated">&lt;code&gt;destroy()&lt;/code&gt; 메소드를 사용하여 항목을 삭제할 수 있습니다 . 이 메소드에는 객체가 소멸되기까지의 대략적인 지연 시간 (밀리 초)을 지정하는 선택적 인수 (기본값은 0)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc5e2f8204ce1996f46d3c130ac6f5e992d76b5c" translate="yes" xml:space="preserve">
          <source>Items can be queried with &lt;a href=&quot;qabstractitemmodel#flags&quot;&gt;flags&lt;/a&gt;() (see &lt;a href=&quot;qt#ItemFlag-enum&quot;&gt;Qt::ItemFlag&lt;/a&gt;) to see if they can be selected, dragged, or manipulated in other ways.</source>
          <target state="translated">항목을 &lt;a href=&quot;qabstractitemmodel#flags&quot;&gt;플래그&lt;/a&gt; () ( &lt;a href=&quot;qt#ItemFlag-enum&quot;&gt;Qt :: ItemFlag&lt;/a&gt; 참조) 로 쿼리하여 다른 방법으로 선택, 드래그 또는 조작 할 수 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3c5fc389e77da4e4e3c1eed3f2d25ba6b18421b" translate="yes" xml:space="preserve">
          <source>Items can be removed from the hash in several ways. One way is to call &lt;a href=&quot;qhash#remove&quot;&gt;remove&lt;/a&gt;(); this will remove any item with the given key. Another way is to use &lt;a href=&quot;qmutablehashiterator#remove&quot;&gt;QMutableHashIterator::remove&lt;/a&gt;(). In addition, you can clear the entire hash using &lt;a href=&quot;qhash#clear&quot;&gt;clear&lt;/a&gt;().</source>
          <target state="translated">여러 가지 방법으로 해시에서 항목을 제거 할 수 있습니다. 한 가지 방법은 &lt;a href=&quot;qhash#remove&quot;&gt;remove&lt;/a&gt; () 를 호출 하는 것입니다 . 주어진 키를 가진 항목을 제거합니다. 다른 방법은 &lt;a href=&quot;qmutablehashiterator#remove&quot;&gt;QMutableHashIterator :: remove&lt;/a&gt; () 를 사용하는 것 입니다. 또한 &lt;a href=&quot;qhash#clear&quot;&gt;clear&lt;/a&gt; ()를 사용하여 전체 해시를 지울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53e826644dcb3c865a4c85b92243f570be97dad2" translate="yes" xml:space="preserve">
          <source>Items can be removed from the map in several ways. One way is to call &lt;a href=&quot;qmap#remove&quot;&gt;remove&lt;/a&gt;(); this will remove any item with the given key. Another way is to use &lt;a href=&quot;qmutablemapiterator#remove&quot;&gt;QMutableMapIterator::remove&lt;/a&gt;(). In addition, you can clear the entire map using &lt;a href=&quot;qmap#clear&quot;&gt;clear&lt;/a&gt;().</source>
          <target state="translated">여러 가지 방법으로 맵에서 항목을 제거 할 수 있습니다. 한 가지 방법은 &lt;a href=&quot;qmap#remove&quot;&gt;remove&lt;/a&gt; () 를 호출 하는 것입니다 . 주어진 키를 가진 항목을 제거합니다. 또 다른 방법은 &lt;a href=&quot;qmutablemapiterator#remove&quot;&gt;QMutableMapIterator :: remove&lt;/a&gt; () 를 사용하는 것 입니다. 또한 &lt;a href=&quot;qmap#clear&quot;&gt;clear&lt;/a&gt; ()를 사용하여 전체 맵을 지울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f046308085b231e57cc99ac6daefb3479e49315d" translate="yes" xml:space="preserve">
          <source>Items can be removed from the set using &lt;a href=&quot;qset#remove&quot;&gt;remove&lt;/a&gt;(). There is also a &lt;a href=&quot;qset#clear&quot;&gt;clear&lt;/a&gt;() function that removes all items.</source>
          <target state="translated">&lt;a href=&quot;qset#remove&quot;&gt;remove&lt;/a&gt; ()를 사용하여 세트에서 항목을 제거 할 수 있습니다 . 모든 항목을 제거 하는 &lt;a href=&quot;qset#clear&quot;&gt;명확한&lt;/a&gt; () 함수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="34342d279cffc293359671d1b4097e4b0a4e0a9d" translate="yes" xml:space="preserve">
          <source>Items can contain other items (children). Parent items' transformations are inherited by all its children. Regardless of an item's accumulated transformation, though, all its functions (e.g., &lt;a href=&quot;qgraphicsitem#contains&quot;&gt;QGraphicsItem::contains&lt;/a&gt;(), &lt;a href=&quot;qgraphicsitem#boundingRect&quot;&gt;QGraphicsItem::boundingRect&lt;/a&gt;(), QGraphicsItem::collidesWith()) still operate in local coordinates.</source>
          <target state="translated">항목에는 다른 항목 (자식)이 포함될 수 있습니다. 부모 항목의 변형은 모든 자식에 의해 상속됩니다. 그러나 항목의 누적 변환에 관계없이 모든 함수 (예 : &lt;a href=&quot;qgraphicsitem#contains&quot;&gt;QGraphicsItem :: contains&lt;/a&gt; (), &lt;a href=&quot;qgraphicsitem#boundingRect&quot;&gt;QGraphicsItem :: boundingRect&lt;/a&gt; (), QGraphicsItem :: collidesWith ())는 여전히 로컬 좌표에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ce70e9230b5f455120a55449cf556b99c34cde48" translate="yes" xml:space="preserve">
          <source>Items can contain other items, and also be contained by other items. All items can have a parent item and a list of children. Unless the item has no parent, its position is in</source>
          <target state="translated">항목에는 다른 항목이 포함될 수 있으며 다른 항목에 포함될 수도 있습니다. 모든 항목에는 상위 항목과 하위 목록이있을 수 있습니다. 항목에 부모가없는 경우 해당 위치는</target>
        </trans-unit>
        <trans-unit id="02a2f6d3bbb465af3ea9b925cfe4e59f02956c5c" translate="yes" xml:space="preserve">
          <source>Items can enable drag and drop support by calling &lt;a href=&quot;qgraphicsitem#setAcceptDrops&quot;&gt;QGraphicsItem::setAcceptDrops&lt;/a&gt;(). To handle the incoming drag, reimplement &lt;a href=&quot;qgraphicsitem#dragEnterEvent&quot;&gt;QGraphicsItem::dragEnterEvent&lt;/a&gt;(), &lt;a href=&quot;qgraphicsitem#dragMoveEvent&quot;&gt;QGraphicsItem::dragMoveEvent&lt;/a&gt;(), &lt;a href=&quot;qgraphicsitem#dragLeaveEvent&quot;&gt;QGraphicsItem::dragLeaveEvent&lt;/a&gt;(), and &lt;a href=&quot;qgraphicsitem#dropEvent&quot;&gt;QGraphicsItem::dropEvent&lt;/a&gt;().</source>
          <target state="translated">항목은 &lt;a href=&quot;qgraphicsitem#setAcceptDrops&quot;&gt;QGraphicsItem :: setAcceptDrops&lt;/a&gt; ()를 호출하여 끌어서 놓기를 지원할 수 있습니다 . 들어오는 드래그를 처리하려면 &lt;a href=&quot;qgraphicsitem#dragEnterEvent&quot;&gt;QGraphicsItem :: dragEnterEvent&lt;/a&gt; (), &lt;a href=&quot;qgraphicsitem#dragMoveEvent&quot;&gt;QGraphicsItem :: dragMoveEvent&lt;/a&gt; (), &lt;a href=&quot;qgraphicsitem#dragLeaveEvent&quot;&gt;QGraphicsItem :: dragLeaveEvent&lt;/a&gt; () 및 &lt;a href=&quot;qgraphicsitem#dropEvent&quot;&gt;QGraphicsItem :: dropEvent&lt;/a&gt; ()를 다시 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="ae65c00b2f7df7fbaeae9741e8de9e707983dcee" translate="yes" xml:space="preserve">
          <source>Items cannot be selected.</source>
          <target state="translated">항목을 선택할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cf716742c37926fc82046172bfcd7c61e8e12759" translate="yes" xml:space="preserve">
          <source>Items contain data for different roles. To obtain the data for a particular role, both the model index and the role must be supplied to the model.</source>
          <target state="translated">항목에는 다른 역할에 대한 데이터가 포함됩니다. 특정 역할에 대한 데이터를 얻으려면 모델 색인과 역할을 모두 모델에 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d7518247183134b7a48a2fc0590d9413ccc7ed52" translate="yes" xml:space="preserve">
          <source>Items created dynamically need to be explicitly parented to the</source>
          <target state="translated">동적으로 생성 된 항목은</target>
        </trans-unit>
        <trans-unit id="9f3ecce6d0d92f6c1a4844bbd981aad64cd62d85" translate="yes" xml:space="preserve">
          <source>Items declared as children of a &lt;a href=&quot;qml-qtquick-controls-groupbox&quot;&gt;GroupBox&lt;/a&gt; are automatically parented to the &lt;a href=&quot;qml-qtquick-controls-groupbox&quot;&gt;GroupBox&lt;/a&gt;'s contentItem. Items created dynamically need to be explicitly parented to the contentItem:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-groupbox&quot;&gt;GroupBox의&lt;/a&gt; 자식으로 선언 된 항목 은 &lt;a href=&quot;qml-qtquick-controls-groupbox&quot;&gt;GroupBox&lt;/a&gt; 의 contentItem에 자동으로 부모됩니다 . 동적으로 생성 된 항목은 contentItem에 대해 명시 적으로 부모가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6f3c833e3c111b3d5f7829304de216e4594715af" translate="yes" xml:space="preserve">
          <source>Items declared as children of a &lt;a href=&quot;qml-qtquick-controls-statusbar&quot;&gt;StatusBar&lt;/a&gt; are automatically parented to the &lt;a href=&quot;qml-qtquick-controls-statusbar&quot;&gt;StatusBar&lt;/a&gt;'s contentItem. Items created dynamically need to be explicitly parented to the contentItem:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-statusbar&quot;&gt;StatusBar의&lt;/a&gt; 자식으로 선언 된 항목 은 &lt;a href=&quot;qml-qtquick-controls-statusbar&quot;&gt;StatusBar&lt;/a&gt; 의 contentItem에 자동으로 부모됩니다 . 동적으로 생성 된 항목은 contentItem에 대해 명시 적으로 부모가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="093b8789f2096755387781dbdb7750e0b49d75df" translate="yes" xml:space="preserve">
          <source>Items declared as children of a &lt;a href=&quot;qml-qtquick-controls-toolbar&quot;&gt;ToolBar&lt;/a&gt; are automatically parented to the &lt;a href=&quot;qml-qtquick-controls-toolbar&quot;&gt;ToolBar&lt;/a&gt;'s contentItem. Items created dynamically need to be explicitly parented to the contentItem:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-toolbar&quot;&gt;ToolBar의&lt;/a&gt; 자식으로 선언 된 항목 은 &lt;a href=&quot;qml-qtquick-controls-toolbar&quot;&gt;ToolBar&lt;/a&gt; 의 contentItem에 자동으로 부모됩니다 . 동적으로 생성 된 항목은 contentItem에 대해 명시 적으로 부모가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="090d8b100887cdc3f7b8228f2ced878f4e50ae43" translate="yes" xml:space="preserve">
          <source>Items declared as children of a &lt;a href=&quot;qml-qtquick-controls2-groupbox&quot;&gt;GroupBox&lt;/a&gt; are automatically parented to the &lt;a href=&quot;qml-qtquick-controls2-groupbox&quot;&gt;GroupBox&lt;/a&gt;'s &lt;a href=&quot;qml-qtquick-controls2-control#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;. Items created dynamically need to be explicitly parented to the contentItem.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-groupbox&quot;&gt;GroupBox의&lt;/a&gt; 자식으로 선언 된 항목 은 &lt;a href=&quot;qml-qtquick-controls2-groupbox&quot;&gt;GroupBox&lt;/a&gt; 의 &lt;a href=&quot;qml-qtquick-controls2-control#contentItem-prop&quot;&gt;contentItem에&lt;/a&gt; 자동으로 부모됩니다 . 동적으로 생성 된 항목은 contentItem에 대해 명시 적으로 부모가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="74e5f053cf23e9526878636eb6d0617ce36620c5" translate="yes" xml:space="preserve">
          <source>Items declared as children of a Flickable are automatically parented to the Flickable's &lt;a href=&quot;qml-qtquick-flickable#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;. This should be taken into account when operating on the children of the Flickable; it is usually the children of &lt;code&gt;contentItem&lt;/code&gt; that are relevant. For example, the bound of Items added to the Flickable will be available by &lt;code&gt;contentItem.childrenRect&lt;/code&gt;</source>
          <target state="translated">Flickable의 자식으로 선언 된 항목은 Flickable의 &lt;a href=&quot;qml-qtquick-flickable#contentItem-prop&quot;&gt;contentItem에&lt;/a&gt; 자동으로 부모됩니다 . 이것은 Flickable의 자식을 조작 할 때 고려해야합니다. 일반적으로 관련된 &lt;code&gt;contentItem&lt;/code&gt; 의 자식입니다 . 예를 들어, Flickable에 추가 된 항목의 경계는 &lt;code&gt;contentItem.childrenRect&lt;/code&gt; 에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bca2a385f1b079790c558b90319cc8c2fe64634f" translate="yes" xml:space="preserve">
          <source>Items declared as children of a Flickable are automatically parented to the Flickable's contentItem.</source>
          <target state="translated">Flickable의 자식으로 선언 된 항목은 Flickable의 contentItem에 자동으로 부모됩니다.</target>
        </trans-unit>
        <trans-unit id="36f62b10703d09425bd24e9026d2b76544f9a0a3" translate="yes" xml:space="preserve">
          <source>Items declared as children of a Frame are automatically parented to the Frame's &lt;a href=&quot;qml-qtquick-controls2-control#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;. Items created dynamically need to be explicitly parented to the contentItem.</source>
          <target state="translated">Frame의 자식으로 선언 된 항목은 Frame의 &lt;a href=&quot;qml-qtquick-controls2-control#contentItem-prop&quot;&gt;contentItem에&lt;/a&gt; 자동으로 부모됩니다 . 동적으로 생성 된 항목은 contentItem에 대해 명시 적으로 부모가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="651a8a7e9ce0e4f2afed546c9aaa7786f4553020" translate="yes" xml:space="preserve">
          <source>Items declared as children of a GroupBox are automatically parented to the GroupBox's &lt;a href=&quot;qml-qtquick-controls2-control#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;. Items created dynamically need to be explicitly parented to the contentItem.</source>
          <target state="translated">GroupBox의 자식으로 선언 된 항목은 자동으로 GroupBox의 &lt;a href=&quot;qml-qtquick-controls2-control#contentItem-prop&quot;&gt;contentItem&lt;/a&gt; 의 부모가됩니다 . 동적으로 생성 된 항목은 명시 적으로 contentItem의 상위 항목이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9ad27d94bbf338c54c3a386aae69f8df30579ff9" translate="yes" xml:space="preserve">
          <source>Items declared as children of a Pane are automatically parented to the Pane's &lt;a href=&quot;qml-qtquick-controls2-control#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;. Items created dynamically need to be explicitly parented to the contentItem.</source>
          <target state="translated">분할 창의 자식으로 선언 된 항목은 자동으로 분할 창의 &lt;a href=&quot;qml-qtquick-controls2-control#contentItem-prop&quot;&gt;contentItem&lt;/a&gt; 의 상위 항목 입니다. 동적으로 생성 된 항목은 contentItem에 대해 명시 적으로 부모가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0e5d56477b967bb3a428e1d43ac0c961fc66a007" translate="yes" xml:space="preserve">
          <source>Items declared as children of a Popup are automatically parented to the Popups's &lt;a href=&quot;qml-qtquick-controls2-popup#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;. Items created dynamically need to be explicitly parented to the &lt;a href=&quot;qml-qtquick-controls2-popup#contentItem-prop&quot;&gt;contentItem&lt;/a&gt;.</source>
          <target state="translated">Popup의 자식으로 선언 된 항목은 Popups의 &lt;a href=&quot;qml-qtquick-controls2-popup#contentItem-prop&quot;&gt;contentItem에&lt;/a&gt; 자동으로 부모됩니다 . 동적으로 생성 된 항목은 &lt;a href=&quot;qml-qtquick-controls2-popup#contentItem-prop&quot;&gt;contentItem의&lt;/a&gt; 부모로 명시 적으로 부모되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="8c81f312448552aeb85adedd8ebf107a7c625500" translate="yes" xml:space="preserve">
          <source>Items do not receive drag and drop events by default; to enable this feature, call &lt;code&gt;setAcceptDrops(true)&lt;/code&gt;.</source>
          <target state="translated">항목은 기본적으로 끌어서 놓기 이벤트를받지 않습니다. 이 기능을 사용하려면 &lt;code&gt;setAcceptDrops(true)&lt;/code&gt; 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee883b4d8fad4a59cf8ac86ed865ae74cfe768d0" translate="yes" xml:space="preserve">
          <source>Items in a &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; support these attached properties:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView의&lt;/a&gt; 항목은 다음과 같은 연결된 속성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="9763498e5c397fafbde95409cb697fac30094255" translate="yes" xml:space="preserve">
          <source>Items in a &lt;a href=&quot;qml-qtquick-layouts-columnlayout&quot;&gt;ColumnLayout&lt;/a&gt; support these attached properties:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-layouts-columnlayout&quot;&gt;ColumnLayout의&lt;/a&gt; 항목은 다음과 같은 연결된 속성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="adb71616d376f8bf6ac5b35579154e7995b82baf" translate="yes" xml:space="preserve">
          <source>Items in a &lt;a href=&quot;qml-qtquick-layouts-gridlayout&quot;&gt;GridLayout&lt;/a&gt; support these attached properties:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-layouts-gridlayout&quot;&gt;GridLayout의&lt;/a&gt; 항목은 다음과 같은 연결된 속성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="89eb90be1e119bf04e34cc9d1931eaf0a57f5333" translate="yes" xml:space="preserve">
          <source>Items in a &lt;a href=&quot;qml-qtquick-layouts-rowlayout&quot;&gt;RowLayout&lt;/a&gt; support these attached properties:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-layouts-rowlayout&quot;&gt;RowLayout의&lt;/a&gt; 항목은 다음과 같은 연결된 속성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="4f7fcf2058ad998af181a7b00e8aa58fa416029a" translate="yes" xml:space="preserve">
          <source>Items in a &lt;a href=&quot;qml-qtquick-layouts-stacklayout&quot;&gt;StackLayout&lt;/a&gt; support these attached properties:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-layouts-stacklayout&quot;&gt;StackLayout의&lt;/a&gt; 항목은 다음과 같은 연결된 속성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="45a83563b3f243a192a6b497294d4e5230adb2bd" translate="yes" xml:space="preserve">
          <source>Items in a ColumnLayout support these attached properties:</source>
          <target state="translated">ColumnLayout의 항목은 다음과 같은 연결된 속성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="597aea11b8a7e0abf1836c845b3af62f66927d4c" translate="yes" xml:space="preserve">
          <source>Items in a GridLayout support these attached properties:</source>
          <target state="translated">GridLayout의 항목은 다음과 같은 연결된 속성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e160567866aceba11af1571333d3fa9e7d819c28" translate="yes" xml:space="preserve">
          <source>Items in a RowLayout support these attached properties:</source>
          <target state="translated">RowLayout의 항목은 다음과 같은 연결된 속성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="857196c8a24e091fed154037caad5dd71bc13ade" translate="yes" xml:space="preserve">
          <source>Items in a StackLayout support these attached properties:</source>
          <target state="translated">StackLayout의 항목은 다음과 같은 연결된 속성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1aba2d58c328052bd1c3ba248a08a00782c23cc6" translate="yes" xml:space="preserve">
          <source>Items in a StackView support these attached properties:</source>
          <target state="translated">StackView의 항목은 다음과 같은 연결된 속성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8edb0482405135cd276507b2c25d96b28eb279c8" translate="yes" xml:space="preserve">
          <source>Items in a list view can be displayed using one of two view modes: In &lt;a href=&quot;qlistview#ViewMode-enum&quot;&gt;ListMode&lt;/a&gt;, the items are displayed in the form of a simple list; in &lt;a href=&quot;qlistview#ViewMode-enum&quot;&gt;IconMode&lt;/a&gt;, the list view takes the form of an</source>
          <target state="translated">목록보기 의 항목은 다음 두 가지보기 모드 중 하나를 사용하여 표시 할 수 있습니다. &lt;a href=&quot;qlistview#ViewMode-enum&quot;&gt;ListMode&lt;/a&gt; 에서 항목은 단순 목록의 형태로 표시됩니다. 에 &lt;a href=&quot;qlistview#ViewMode-enum&quot;&gt;IconMode&lt;/a&gt; 목록보기는의 형태를 취</target>
        </trans-unit>
        <trans-unit id="72f018e72dc845dbec852938e97a0c1e4506d744" translate="yes" xml:space="preserve">
          <source>Items in a model can perform various</source>
          <target state="translated">모델의 항목은 다양한 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4b14df5d091abc0c550b6d176443d08496f21883" translate="yes" xml:space="preserve">
          <source>Items in item views are drawn by &lt;a href=&quot;model-view-programming#delegate-classes&quot;&gt;delegates&lt;/a&gt; in Qt. The item view headers are still drawn by the style. Qt's default delegate, &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;, draws its items partially through the current style; it draws the check box indicators and calculates bounding rectangles for the elements of which the item consists. In this document, we only describe how to implement a &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; subclass. If you wish to add support for other datatypes than those supported by the &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;, you need to implement a custom delegate. Note that delegates must be set programmatically for each individual widget (i.e., default delegates cannot be provided as plugins).</source>
          <target state="translated">Qt에서 &lt;a href=&quot;model-view-programming#delegate-classes&quot;&gt;델리게이트&lt;/a&gt; 가 아이템 뷰의 아이템을 가져옵니다 . 아이템 뷰 헤더는 여전히 스타일에 의해 그려집니다. Qt의 기본 대리자 인 &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; 는 현재 스타일을 통해 항목을 부분적으로 그립니다. 확인란 표시기를 그리고 항목이 구성된 요소의 경계 사각형을 계산합니다. 이 문서에서는 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 서브 클래스 를 구현하는 방법 만 설명합니다 . &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate가&lt;/a&gt; 지원하는 것 이외의 다른 데이터 유형에 대한 지원을 추가 하려면 사용자 정의 델리게이트를 구현해야합니다. 델리게이트는 각 개별 위젯에 대해 프로그래밍 방식으로 설정해야합니다 (즉, 기본 델리게이트는 플러그인으로 제공 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="b1a84da1c932bdcc7c918f26d04e0e46a3918d6e" translate="yes" xml:space="preserve">
          <source>Items in the map are identified by the name which QDomNode::name() returns. Nodes are retrieved using &lt;a href=&quot;qdomnamednodemap#namedItem&quot;&gt;namedItem&lt;/a&gt;(), &lt;a href=&quot;qdomnamednodemap#namedItemNS&quot;&gt;namedItemNS&lt;/a&gt;() or &lt;a href=&quot;qdomnamednodemap#item&quot;&gt;item&lt;/a&gt;(). New nodes are inserted with &lt;a href=&quot;qdomnamednodemap#setNamedItem&quot;&gt;setNamedItem&lt;/a&gt;() or &lt;a href=&quot;qdomnamednodemap#setNamedItemNS&quot;&gt;setNamedItemNS&lt;/a&gt;() and removed with &lt;a href=&quot;qdomnamednodemap#removeNamedItem&quot;&gt;removeNamedItem&lt;/a&gt;() or &lt;a href=&quot;qdomnamednodemap#removeNamedItemNS&quot;&gt;removeNamedItemNS&lt;/a&gt;(). Use &lt;a href=&quot;qdomnamednodemap#contains&quot;&gt;contains&lt;/a&gt;() to see if an item with the given name is in the named node map. The number of items is returned by &lt;a href=&quot;qdomnamednodemap#length&quot;&gt;length&lt;/a&gt;().</source>
          <target state="translated">맵의 항목은 QDomNode :: name ()이 리턴하는 이름으로 식별됩니다. &lt;a href=&quot;qdomnamednodemap#namedItem&quot;&gt;namedItem&lt;/a&gt; (), &lt;a href=&quot;qdomnamednodemap#namedItemNS&quot;&gt;namedItemNS&lt;/a&gt; () 또는 &lt;a href=&quot;qdomnamednodemap#item&quot;&gt;item&lt;/a&gt; ()을 사용하여 노드를 검색 합니다. 새 노드는 &lt;a href=&quot;qdomnamednodemap#setNamedItem&quot;&gt;setNamedItem&lt;/a&gt; () 또는 &lt;a href=&quot;qdomnamednodemap#setNamedItemNS&quot;&gt;setNamedItemNS&lt;/a&gt; () 로 삽입되고 &lt;a href=&quot;qdomnamednodemap#removeNamedItem&quot;&gt;removeNamedItem&lt;/a&gt; () 또는 &lt;a href=&quot;qdomnamednodemap#removeNamedItemNS&quot;&gt;removeNamedItemNS&lt;/a&gt; ()로 제거됩니다 . &lt;a href=&quot;qdomnamednodemap#contains&quot;&gt;contains&lt;/a&gt; ()를 사용 하여 지정된 이름을 가진 항목이 명명 된 노드 맵에 있는지 확인하십시오. 항목 수는 &lt;a href=&quot;qdomnamednodemap#length&quot;&gt;길이&lt;/a&gt; () 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="3eadd3d4cb618268374b301e8e765484a5bdf3e1" translate="yes" xml:space="preserve">
          <source>Items in these views are laid out in the direction specified by the &lt;a href=&quot;qlistview#flow-prop&quot;&gt;flow&lt;/a&gt;() of the list view. The items may be fixed in place, or allowed to move, depending on the view's &lt;a href=&quot;qlistview#movement-prop&quot;&gt;movement&lt;/a&gt;() state.</source>
          <target state="translated">이러한보기의 항목 은 목록보기 의 &lt;a href=&quot;qlistview#flow-prop&quot;&gt;흐름&lt;/a&gt; () 으로 지정된 방향으로 배치됩니다 . 보기의 &lt;a href=&quot;qlistview#movement-prop&quot;&gt;이동&lt;/a&gt; () 상태 에 따라 항목이 고정되거나 이동 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="763473a8f49f73bf1c26ec1628541c7938b40c73" translate="yes" xml:space="preserve">
          <source>Items in this group are not destroyed when released by a view, instead they are persisted until removed from the group.</source>
          <target state="translated">이 그룹의 항목은 뷰에서 해제 될 때 소멸되지 않고 그룹에서 제거 될 때까지 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="db09fae9d95f4ba824e290bbfe60590c40b8ab6b" translate="yes" xml:space="preserve">
          <source>Items instantiated by the Repeater are inserted, in order, as children of the Repeater's parent. The insertion starts immediately after the repeater's position in its parent stacking list. This allows a Repeater to be used inside a layout. For example, the following Repeater's items are stacked between a red rectangle and a blue rectangle:</source>
          <target state="translated">리피터에 의해 인스턴스화 된 항목은 리피터의 상위의 하위 항목으로 순서대로 삽입됩니다. 삽입은 상위 스태킹 목록에서 리피터 위치 직후에 시작됩니다. 이를 통해 레이아웃 내에서 Repeater를 사용할 수 있습니다. 예를 들어, 다음 리피터 항목은 빨간색 사각형과 파란색 사각형 사이에 쌓입니다.</target>
        </trans-unit>
        <trans-unit id="757676308d19af614d4d217bcebf752a37d374bf" translate="yes" xml:space="preserve">
          <source>Items live in a local coordinate system, and like &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;, it also provides many functions for mapping coordinates between the item and the scene, and from item to item. Also, like &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;, it can transform its coordinate system using a matrix: &lt;a href=&quot;qgraphicsitem#transform&quot;&gt;QGraphicsItem::transform&lt;/a&gt;(). This is useful for rotating and scaling individual items.</source>
          <target state="translated">항목은 로컬 좌표계에 있으며 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 와 마찬가지로 항목과 장면 사이, 항목 간 좌표를 매핑하는 많은 기능도 제공합니다. 또한 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 와 같이 QGraphicsItem &lt;a href=&quot;qgraphicsitem#transform&quot;&gt;:: transform&lt;/a&gt; () 행렬을 사용하여 좌표계를 변환 할 수 있습니다 . 개별 항목을 회전하고 크기를 조정할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e6c7493ef6460d6181dfe8c558c75ed0f81231df" translate="yes" xml:space="preserve">
          <source>Items live in their own local coordinate system. Their coordinates are usually centered around its center point (0, 0), and this is also the center for all transformations. Geometric primitives in the item coordinate system are often referred to as item points, item lines, or item rectangles.</source>
          <target state="translated">아이템은 자체 로컬 좌표계에 있습니다. 이들의 좌표는 일반적으로 중심점 (0, 0)을 중심으로하며 모든 변환의 중심이기도합니다. 아이템 좌표 시스템의 기하학적 프리미티브는 종종 아이템 포인트, 아이템 라인 또는 아이템 사각형으로 지칭됩니다.</target>
        </trans-unit>
        <trans-unit id="d87e524d889591d033b2aec2023565d67f4a33dd" translate="yes" xml:space="preserve">
          <source>Items must belong to a scene for scene event filters to be installed and used.</source>
          <target state="translated">장면 이벤트 필터를 설치하고 사용하려면 항목이 장면에 속해야합니다.</target>
        </trans-unit>
        <trans-unit id="df00b652a90f3a4581e9c3b10fc3536d4e4cbc61" translate="yes" xml:space="preserve">
          <source>Items removed from a list widget will not be managed by Qt, and will need to be deleted manually.</source>
          <target state="translated">목록 위젯에서 제거 된 항목은 Qt에서 관리하지 않으며 수동으로 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="2e80f96714136e9003361371c332c741c6a84ec2" translate="yes" xml:space="preserve">
          <source>Items returned by the &lt;a href=&quot;qml-qtqml-models-delegatemodelgroup#create-method&quot;&gt;QtQml.Models::DelegateModelGroup::create()&lt;/a&gt; function are automatically added to this group.</source>
          <target state="translated">&lt;a href=&quot;qml-qtqml-models-delegatemodelgroup#create-method&quot;&gt;QtQml.Models :: DelegateModelGroup :: create ()&lt;/a&gt; 함수가 리턴 한 항목 이이 그룹에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6e1a8677a86ea012efa4a27da92feb3ed7743356" translate="yes" xml:space="preserve">
          <source>Items specified in &lt;code&gt;forwardTo&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;forwardTo&lt;/code&gt; 에 지정된 항목</target>
        </trans-unit>
        <trans-unit id="1c6cddc55d93c239f5979996084890b50b03171f" translate="yes" xml:space="preserve">
          <source>Items that are created or reparented as a child of the positioner after the positioner has been created</source>
          <target state="translated">포지셔너가 작성된 후 포지셔너의 하위 항목으로 작성되거나 보호되는 항목</target>
        </trans-unit>
        <trans-unit id="a79ff2f90f56673d6bbcef35cbc0602c5fa54f6d" translate="yes" xml:space="preserve">
          <source>Items that are in a group inherit the group's selected state.</source>
          <target state="translated">그룹에있는 항목은 그룹의 선택된 상태를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="e805d8242c4322300da024475244644906fea66b" translate="yes" xml:space="preserve">
          <source>Items that are not part of a panel follow scene activation when the scene has no active panel.</source>
          <target state="translated">장면에 활성 패널이없는 경우 패널에 포함되지 않은 항목은 장면 활성화를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="7c2bf0f53009bcca221aa83bb891e2f88740a97a" translate="yes" xml:space="preserve">
          <source>Items that have already been inserted somewhere else won't be inserted.</source>
          <target state="translated">다른 곳에 이미 삽입 된 항목은 삽입되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4c21ef57b3359209e30c1e30bb12607052d7918" translate="yes" xml:space="preserve">
          <source>Items that have children can be in an expanded (children are visible) or collapsed (children are hidden) state. When this state changes a &lt;a href=&quot;qtreeview#collapsed&quot;&gt;collapsed&lt;/a&gt;() or &lt;a href=&quot;qtreeview#expanded&quot;&gt;expanded&lt;/a&gt;() signal is emitted with the model index of the relevant item.</source>
          <target state="translated">자녀가있는 항목은 확장 (자식 표시) 또는 축소 (자식 숨김) 상태 일 수 있습니다. 이 상태가 변경되면 관련 항목의 모델 색인과 함께 &lt;a href=&quot;qtreeview#collapsed&quot;&gt;축소&lt;/a&gt; () 또는 &lt;a href=&quot;qtreeview#expanded&quot;&gt;확장&lt;/a&gt; () 신호가 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="c16f8816a91ef39c97d1974aab8f5e1190dd5af3" translate="yes" xml:space="preserve">
          <source>Items that have specified &lt;a href=&quot;qsgnode#Flag-enum&quot;&gt;QSGNode::UsePreprocess&lt;/a&gt;, will have their &lt;a href=&quot;qsgnode#preprocess&quot;&gt;QSGNode::preprocess&lt;/a&gt;() function invoked.</source>
          <target state="translated">지정한 항목 &lt;a href=&quot;qsgnode#Flag-enum&quot;&gt;QSGNode :: UsePreprocess가&lt;/a&gt; 그들의 것이다 &lt;a href=&quot;qsgnode#preprocess&quot;&gt;QSGNode :: 사전 처리를&lt;/a&gt; () 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0175c385927aff770756423449b186239210ddc7" translate="yes" xml:space="preserve">
          <source>Items the user interacts with or that give information to the user need to expose their information to the accessibility framework. Then assistive tools can make use of that information to enable users to interact with the application in various ways. This enables Qt Quick applications to be used with screen-readers for example.</source>
          <target state="translated">사용자가 상호 작용하거나 사용자에게 정보를 제공하는 항목은 정보를 접근성 프레임 워크에 노출해야합니다. 그런 다음 보조 도구는 해당 정보를 사용하여 사용자가 다양한 방식으로 응용 프로그램과 상호 작용할 수 있도록합니다. 이를 통해 Qt Quick 애플리케이션을 스크린 리더와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a1a6b7bbbbdb9beb060e62b141b8203178d98f5" translate="yes" xml:space="preserve">
          <source>Items usually contain text, icons, or checkboxes.</source>
          <target state="translated">항목에는 일반적으로 텍스트, 아이콘 또는 확인란이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a95a16ef746cc3b0f9f6ab7a95bbfec23866fed1" translate="yes" xml:space="preserve">
          <source>Items with a higher stacking value are drawn on top of siblings with a lower stacking order. Items with the same stacking value are drawn bottom up in the order they appear. Items with a negative stacking value are drawn under their parent's content.</source>
          <target state="translated">높은 쌓기 값을 가진 항목은 낮은 쌓임 순서로 형제 위에 그려집니다. 스택 값이 동일한 항목은 표시된 순서대로 아래로 그려집니다. 스택 값이 음수 인 항목은 상위 내용 아래에 그려집니다.</target>
        </trans-unit>
        <trans-unit id="7e438c8fac8abc8c92f8f962d96a6b25b7e48d49" translate="yes" xml:space="preserve">
          <source>Items with absolute scaling will be rendered at the same size, regardless of axis ranges. Items with data scaling will change their apparent size according to the axis ranges. If &lt;a href=&quot;qcustom3ditem#positionAbsolute-prop&quot;&gt;positionAbsolute&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt;, this property is ignored and scaling is interpreted as an absolute value. If the item has rotation, the data scaling is calculated on the unrotated item. Similarly, for &lt;a href=&quot;qcustom3dvolume&quot;&gt;QCustom3DVolume&lt;/a&gt; items, the range clipping is calculated on the unrotated item.</source>
          <target state="translated">절대 배율을 가진 항목은 축 범위에 관계없이 동일한 크기로 렌더링됩니다. 데이터 스케일링이있는 항목은 축 범위에 따라 겉보기 크기가 변경됩니다. 경우 &lt;a href=&quot;qcustom3ditem#positionAbsolute-prop&quot;&gt;positionAbsolute이&lt;/a&gt; 있다 &lt;code&gt;true&lt;/code&gt; ,이 속성은 무시되고 스케일링은 절대 값으로 해석됩니다. 항목에 회전이있는 경우 회전되지 않은 항목에 대한 데이터 스케일링이 계산됩니다. 마찬가지로 &lt;a href=&quot;qcustom3dvolume&quot;&gt;QCustom3DVolume&lt;/a&gt; 항목의 경우 회전되지 않은 항목에서 범위 클리핑이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="24011bb1715e60245fea83bf43f5ab8514b96fc3" translate="yes" xml:space="preserve">
          <source>Items with children are typically shown with controls to expand and collapse them, allowing their children to be shown or hidden. If this property is false, these controls are not shown for top-level items. This can be used to make a single level tree structure appear like a simple list of items.</source>
          <target state="translated">자식이있는 항목은 일반적으로 확장 및 축소 할 수있는 컨트롤과 함께 표시되어 자식을 표시하거나 숨길 수 있습니다. 이 속성이 false이면 최상위 항목에 이러한 컨트롤이 표시되지 않습니다. 단일 레벨 트리 구조를 간단한 항목 목록처럼 보이게하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03236fdd641d0a848922b6347aedb6e752deafb0" translate="yes" xml:space="preserve">
          <source>Iterate through the &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt; and test each &lt;a href=&quot;qxmlitem&quot;&gt;QXmlItem&lt;/a&gt; to see if it is an atomic value or a node. If it is an atomic value, convert it to a &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; with &lt;a href=&quot;qxmlitem#toAtomicValue&quot;&gt;toAtomicValue()&lt;/a&gt; and switch on its &lt;a href=&quot;qvariant#type&quot;&gt;variant type&lt;/a&gt; to handle all the atomic values your &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; might return. The following table shows the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; type to expect for each atomic value type (or &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt;):</source>
          <target state="translated">&lt;a href=&quot;qxmlresultitems&quot;&gt;결과 항목을&lt;/a&gt; 반복 하고 각 &lt;a href=&quot;qxmlitem&quot;&gt;QXmlItem&lt;/a&gt; 을 테스트 하여 원자 값인지 노드인지 확인합니다. 이 원자 값이 경우로 변환 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 와 &lt;a href=&quot;qxmlitem#toAtomicValue&quot;&gt;toAtomicValue ()&lt;/a&gt; 그와 스위치 &lt;a href=&quot;qvariant#type&quot;&gt;변형 유형&lt;/a&gt; 당신의 모든 원자 값 처리 &lt;a href=&quot;xmlprocessing&quot;&gt;는 XQuery가&lt;/a&gt; 반환 할 수 있습니다. 다음 표는 각 원자 값 유형 (또는 &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; ) 에 대해 예상 되는 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 유형을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="31f952be522a0d751ac82dcb43c3eb24ca66fd6d" translate="yes" xml:space="preserve">
          <source>Iterate through the &lt;a href=&quot;qxmlresultitems&quot;&gt;result items&lt;/a&gt; and test each &lt;a href=&quot;qxmlitem&quot;&gt;QXmlItem&lt;/a&gt; to see if it is an atomic value or a node. If it is an atomic value, convert it to a &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; with &lt;a href=&quot;qxmlitem#toAtomicValue&quot;&gt;toAtomicValue()&lt;/a&gt; and switch on its &lt;a href=&quot;qvariant#type&quot;&gt;variant type&lt;/a&gt; to handle all the atomic values your XQuery might return. The following table shows the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; type to expect for each atomic value type (or &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt;):</source>
          <target state="translated">&lt;a href=&quot;qxmlresultitems&quot;&gt;결과 항목을&lt;/a&gt; 반복 하고 각 &lt;a href=&quot;qxmlitem&quot;&gt;QXmlItem&lt;/a&gt; 을 테스트 하여 원자 값인지 또는 노드인지 확인하십시오. 이 원자 값이 경우로 변환 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 와 &lt;a href=&quot;qxmlitem#toAtomicValue&quot;&gt;toAtomicValue ()&lt;/a&gt; 그와 스위치 &lt;a href=&quot;qvariant#type&quot;&gt;변형 유형&lt;/a&gt; 당신의 XQuery를 반환 할 수있는 모든 원자 값을 처리 할 수 있습니다. 다음 표는 각 원자 값 유형 (또는 &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; ) 에 대해 예상 되는 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 유형을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="55a2dc3ae5c81261e53704a701571613e1e4b0c3" translate="yes" xml:space="preserve">
          <source>Iterating Over the Strings</source>
          <target state="translated">문자열을 반복</target>
        </trans-unit>
        <trans-unit id="7ba1b0cd8486ab94e7d92367220376eb8f4560c3" translate="yes" xml:space="preserve">
          <source>Iterating Through Completions</source>
          <target state="translated">완료를 통한 반복</target>
        </trans-unit>
        <trans-unit id="af8a2107347a0bb80c897b1b52db0246525a8836" translate="yes" xml:space="preserve">
          <source>Iterating backward with an STL-style iterator is done with reverse iterators:</source>
          <target state="translated">STL 스타일 반복자를 사용하여 뒤로 반복하는 작업은 역 반복자를 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6688552d180359aa3c545d32dc4372479d86d567" translate="yes" xml:space="preserve">
          <source>Iteration over the region (with &lt;a href=&quot;qregion#begin&quot;&gt;begin&lt;/a&gt;(), &lt;a href=&quot;qregion#end&quot;&gt;end&lt;/a&gt;(), or C++11 ranged-for loops) gives a decomposition of the region into rectangles.</source>
          <target state="translated">영역에 대한 반복 ( &lt;a href=&quot;qregion#begin&quot;&gt;시작&lt;/a&gt; (), &lt;a href=&quot;qregion#end&quot;&gt;끝&lt;/a&gt; () 또는 C ++ 11 범위가 지정된 루프 포함)은 영역을 사각형으로 분해합니다.</target>
        </trans-unit>
        <trans-unit id="bae8809b2429231a50c28ba87cecc038aac88855" translate="yes" xml:space="preserve">
          <source>Iterator</source>
          <target state="translated">Iterator</target>
        </trans-unit>
        <trans-unit id="0d8120d04a1d214bc7bf8d327e2ad6d7bb84b88b" translate="yes" xml:space="preserve">
          <source>Iterator &amp;amp;</source>
          <target state="translated">반복자 &amp;amp;</target>
        </trans-unit>
        <trans-unit id="34d301f1220eccf02a0b1edf7d25507ca6f0dc67" translate="yes" xml:space="preserve">
          <source>Iterator &amp;amp;Iterator::operator++()</source>
          <target state="translated">반복자 및 반복자 :: operator ++ ()</target>
        </trans-unit>
        <trans-unit id="09447e1668dc24914f00fb232fb6332bfdacb382" translate="yes" xml:space="preserve">
          <source>Iterator &amp;amp;Iterator::operator+=(qsizetype</source>
          <target state="translated">반복자 및 반복자 :: operator + = (qsizetype</target>
        </trans-unit>
        <trans-unit id="162bdad91e252a917d1737111ea678a3b92a267e" translate="yes" xml:space="preserve">
          <source>Iterator &amp;amp;Iterator::operator--()</source>
          <target state="translated">반복자 및 반복자 :: 연산자-()</target>
        </trans-unit>
        <trans-unit id="916626aa919086f60060b2661b09bc130732c107" translate="yes" xml:space="preserve">
          <source>Iterator &amp;amp;Iterator::operator-=(qsizetype</source>
          <target state="translated">반복자 및 반복자 :: operator-= (qsizetype</target>
        </trans-unit>
        <trans-unit id="97938704112bf993785ba68415733a9c7890d16a" translate="yes" xml:space="preserve">
          <source>Iterator &amp;amp;Iterator::operator=(const Iterator &amp;amp;</source>
          <target state="translated">반복자 및 반복자 :: operator = (const 반복자 &amp;amp;</target>
        </trans-unit>
        <trans-unit id="d0a689e8a9afd6252641e7750fa8432a580b569c" translate="yes" xml:space="preserve">
          <source>Iterator Class</source>
          <target state="translated">반복자 클래스</target>
        </trans-unit>
        <trans-unit id="23a7c0da07121a172831a4758fc0bf1b156b24d8" translate="yes" xml:space="preserve">
          <source>Iterator Iterator::operator+(qsizetype</source>
          <target state="translated">반복자 반복자 :: operator + (qsizetype</target>
        </trans-unit>
        <trans-unit id="1558619894c4da10ddc92905f7f213d34bee4d0e" translate="yes" xml:space="preserve">
          <source>Iterator Iterator::operator++(</source>
          <target state="translated">반복자 반복자 :: operator ++ (</target>
        </trans-unit>
        <trans-unit id="ecfb677e3ea6daa8e22248618e1fdb2f36e35f80" translate="yes" xml:space="preserve">
          <source>Iterator Iterator::operator-(qsizetype</source>
          <target state="translated">반복자 반복자 :: operator- (qsizetype</target>
        </trans-unit>
        <trans-unit id="c21ae1ba2b09e1e6fedb60182401608929af2f40" translate="yes" xml:space="preserve">
          <source>Iterator Iterator::operator--(</source>
          <target state="translated">반복자 반복자 :: 연산자-(</target>
        </trans-unit>
        <trans-unit id="c2ec6de67d3696a44b2155ed2a58eede43e833d7" translate="yes" xml:space="preserve">
          <source>Iterator QKeyValueIterator::base() const</source>
          <target state="translated">반복자 QKeyValueIterator :: base () const</target>
        </trans-unit>
        <trans-unit id="2c05fec9f69d79847d6049f898ba150aeedca087" translate="yes" xml:space="preserve">
          <source>Iterator Type</source>
          <target state="translated">반복자 유형</target>
        </trans-unit>
        <trans-unit id="7b01442a1267eac6273f72217b90f17b9eafbe53" translate="yes" xml:space="preserve">
          <source>Iterator for reading the contents of a QTextFrame</source>
          <target state="translated">QTextFrame의 내용을 읽는 반복자</target>
        </trans-unit>
        <trans-unit id="550f7c71fde32b688523c5bd76b58a57491a3453" translate="yes" xml:space="preserve">
          <source>Iterator on the results of a global match of a QRegularExpression object against a string</source>
          <target state="translated">문자열에 대한 QRegularExpression 객체의 전역 일치 결과에 대한 반복자</target>
        </trans-unit>
        <trans-unit id="0b68a11482790b93adf82175e81cc114c909c444" translate="yes" xml:space="preserve">
          <source>Iterator over the key/value pairs of an associative container. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">연관 컨테이너의 키 / 값 쌍에 대한 반복자입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b1b2c7f7a414c134a90dfa05da7dc4ce43378a43" translate="yes" xml:space="preserve">
          <source>Iterator::Iterator()</source>
          <target state="translated">Iterator::Iterator()</target>
        </trans-unit>
        <trans-unit id="ccd5e0878a461206e28b74cb160417213bf9ba39" translate="yes" xml:space="preserve">
          <source>Iterator::Iterator(const Iterator &amp;amp;</source>
          <target state="translated">반복자 :: 반복자 (const Iterator &amp;amp;</target>
        </trans-unit>
        <trans-unit id="b7c8629575080af438920ba23a9bc61ee2c65549" translate="yes" xml:space="preserve">
          <source>Iterator::value_type</source>
          <target state="translated">Iterator::value_type</target>
        </trans-unit>
        <trans-unit id="ec9923e2d3ef1ca49a40358680b761c7d97de7c3" translate="yes" xml:space="preserve">
          <source>Iterator::value_type Iterator::operator*() const</source>
          <target state="translated">반복자 :: value_type 반복자 :: operator * () const</target>
        </trans-unit>
        <trans-unit id="fa6e2471949424096723bb6b9d7ce0b30a1522a0" translate="yes" xml:space="preserve">
          <source>Iterators are initialized by using a &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt; function like &lt;a href=&quot;qcborarray#begin&quot;&gt;QCborArray::begin&lt;/a&gt;() or &lt;a href=&quot;qcborarray#end&quot;&gt;QCborArray::end&lt;/a&gt;(). Iteration is only possible after that.</source>
          <target state="translated">반복자는 &lt;a href=&quot;qcborarray#begin&quot;&gt;QCborArray :: begin&lt;/a&gt; () 또는 &lt;a href=&quot;qcborarray#end&quot;&gt;QCborArray :: end&lt;/a&gt; () 와 같은 &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt; 함수 를 사용하여 초기화됩니다 . 그 후에 만 ​​반복이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="78d3da915bed14ce3f691c3a055b6f8ab26f9203" translate="yes" xml:space="preserve">
          <source>Iterators are initialized by using a &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt; function like &lt;a href=&quot;qcborarray#begin&quot;&gt;QCborArray::begin&lt;/a&gt;(), &lt;a href=&quot;qcborarray#end&quot;&gt;QCborArray::end&lt;/a&gt;(), or &lt;a href=&quot;qcborarray#insert&quot;&gt;QCborArray::insert&lt;/a&gt;(). Iteration is only possible after that.</source>
          <target state="translated">반복자는 &lt;a href=&quot;qcborarray#begin&quot;&gt;QCborArray :: begin&lt;/a&gt; (), &lt;a href=&quot;qcborarray#end&quot;&gt;QCborArray :: end&lt;/a&gt; () 또는 &lt;a href=&quot;qcborarray#insert&quot;&gt;QCborArray :: insert&lt;/a&gt; () 와 같은 &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt; 함수 를 사용하여 초기화됩니다 . 그 후에 만 ​​반복이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="46c3dfeb71a9d86b8b3a95cad71483448b2afcfa" translate="yes" xml:space="preserve">
          <source>Iterators provide a uniform means to access items in a container. Qt's container classes provide two types of iterators: Java-style iterators and STL-style iterators. Iterators of both types are invalidated when the data in the container is modified or detached from &lt;a href=&quot;implicit-sharing&quot;&gt;implicitly shared copies&lt;/a&gt; due to a call to a non-const member function.</source>
          <target state="translated">반복자는 컨테이너의 항목에 액세스하는 균일 한 수단을 제공합니다. Qt의 컨테이너 클래스는 Java 스타일 반복기와 STL 스타일 반복기의 두 가지 유형의 반복기를 제공합니다. 비 const 멤버 함수에 대한 호출로 인해 컨테이너의 데이터가 수정되거나 &lt;a href=&quot;implicit-sharing&quot;&gt;암시 적으로 공유 된 복사본&lt;/a&gt; 에서 분리되면 두 유형의 반복기가 무효화됩니다 .</target>
        </trans-unit>
        <trans-unit id="2586b548bc621da1a61bdce198110ac52993c73d" translate="yes" xml:space="preserve">
          <source>Iterators provide a uniform means to access items in a container. Qt's container classes provide two types of iterators: Java-style iterators and STL-style iterators. Iterators of both types are invalidated when the data in the container is modified or detached from &lt;a href=&quot;implicit-sharing#&quot;&gt;implicitly shared copies&lt;/a&gt; due to a call to a non-const member function.</source>
          <target state="translated">반복자는 컨테이너의 항목에 액세스 할 수있는 균일 한 수단을 제공합니다. Qt의 컨테이너 클래스는 Java 스타일 이터레이터와 STL 스타일 이터레이터의 두 가지 이터레이터를 제공합니다. Const가 아닌 멤버 함수에 대한 호출로 인해 컨테이너의 데이터가 &lt;a href=&quot;implicit-sharing#&quot;&gt;내재적으로 공유 된 사본&lt;/a&gt; 에서 수정되거나 분리 될 때 두 유형의 반복자가 무효화됩니다 .</target>
        </trans-unit>
        <trans-unit id="a06c46ed7c6107f842b9df4d649ecbb349607353" translate="yes" xml:space="preserve">
          <source>Its</source>
          <target state="translated">Its</target>
        </trans-unit>
        <trans-unit id="615e3da9fd7612ca2d61cb9567318e7fb768ec81" translate="yes" xml:space="preserve">
          <source>Its &lt;a href=&quot;qbrush#texture&quot;&gt;texture&lt;/a&gt;() does not have an alpha channel and is not a &lt;a href=&quot;qbitmap&quot;&gt;QBitmap&lt;/a&gt;.</source>
          <target state="translated">그것의 &lt;a href=&quot;qbrush#texture&quot;&gt;질감&lt;/a&gt; () 알파 채널을 가지고 있지하고지지 않습니다 &lt;a href=&quot;qbitmap&quot;&gt;QBitmap&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="504ff2910cd5017a2c5a43310eece9b42d413940" translate="yes" xml:space="preserve">
          <source>Its appearance generally changes with &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.selected&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.enabled&lt;/a&gt;.</source>
          <target state="translated">모양은 일반적으로 &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.selected&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls-styles-menustyle#styledata-properties&quot;&gt;styleData.enabled로&lt;/a&gt; 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="187cc96aaca6a2d8ed7f8a9b501a2bc9b98c7c99" translate="yes" xml:space="preserve">
          <source>Its default value is an invalid &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt;, which means the whole model data is shown by the tree view (assigning &lt;code&gt;undefined&lt;/code&gt; to this proprety resets it to its default value.)</source>
          <target state="translated">기본값은 잘못된 &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex입니다&lt;/a&gt; . 이는 전체 모델 데이터가 트리보기로 표시됨을 의미합니다 ( 이 속성에 &lt;code&gt;undefined&lt;/code&gt; 를 지정 하면 기본값으로 재설정 됨).</target>
        </trans-unit>
        <trans-unit id="34cf409e97eaf4bb041ef15b85231cdbdfb451d4" translate="yes" xml:space="preserve">
          <source>Its element tree (see section &lt;a href=&quot;#the-style-elements&quot;&gt;The Style Elements&lt;/a&gt;).</source>
          <target state="translated">요소 트리 (섹션 &lt;a href=&quot;#the-style-elements&quot;&gt;요소&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ea43d468826a11b42e8b6baecaeda0642e218ec7" translate="yes" xml:space="preserve">
          <source>Its element tree (see section &lt;a href=&quot;style-reference#the-style-elements&quot;&gt;The Style Elements&lt;/a&gt;).</source>
          <target state="translated">요소 트리 ( &lt;a href=&quot;style-reference#the-style-elements&quot;&gt;스타일 요소&lt;/a&gt; 섹션 참조 ).</target>
        </trans-unit>
        <trans-unit id="5259c24a35cc22fd5ed439751425ce34067d86b1" translate="yes" xml:space="preserve">
          <source>Its main use in Qt is to prevent implicitly-shared Qt containers from detaching:</source>
          <target state="translated">Qt의 주요 용도는 암시 적으로 공유 된 Qt 컨테이너가 분리되는 것을 방지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="947d5c31adb9ea2c1fe93af257498d6441f0c5d6" translate="yes" xml:space="preserve">
          <source>Its presence in the method implementation (outside the class declaration) is optional.</source>
          <target state="translated">메소드 구현에서의 존재 (클래스 선언 외부)는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="51d08ea4fee97d44ea2f6c8f50a67428f61e20e1" translate="yes" xml:space="preserve">
          <source>Its properties are &lt;code&gt;deviceId&lt;/code&gt;, &lt;code&gt;displayName&lt;/code&gt;, &lt;code&gt;position&lt;/code&gt; and &lt;code&gt;orientation&lt;/code&gt;. See &lt;a href=&quot;qml-qtmultimedia-qtmultimedia#availableCameras-prop&quot;&gt;availableCameras&lt;/a&gt; for a description of each of them.</source>
          <target state="translated">속성은 &lt;code&gt;deviceId&lt;/code&gt; , &lt;code&gt;displayName&lt;/code&gt; , &lt;code&gt;position&lt;/code&gt; 및 &lt;code&gt;orientation&lt;/code&gt; 입니다. 각 카메라에 대한 설명은 &lt;a href=&quot;qml-qtmultimedia-qtmultimedia#availableCameras-prop&quot;&gt;availableCameras&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b356a7bf938d07a910d2e4783fc98b07420b1df0" translate="yes" xml:space="preserve">
          <source>Its properties are:</source>
          <target state="translated">속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="97cd63e4a56ba696bcaf794936664da27a573ad4" translate="yes" xml:space="preserve">
          <source>Its purpose is to enable code modularization by allowing the usage of qml files containing map elements related to each other, and the associated bindings.</source>
          <target state="translated">그 목적은 서로 관련된 맵 요소 및 연관된 바인딩을 포함하는 qml 파일의 사용을 허용하여 코드 모듈화를 가능하게하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7d7c4e3e3f912ee1f5ec14b92189b1b4bfdd4a7c" translate="yes" xml:space="preserve">
          <source>Its syntax is: &lt;code&gt;foreach&lt;/code&gt; (</source>
          <target state="translated">구문은 다음과 같습니다. &lt;code&gt;foreach&lt;/code&gt; (</target>
        </trans-unit>
        <trans-unit id="6d62883d3c62d508145503522f0257a75ace67e0" translate="yes" xml:space="preserve">
          <source>Its to provide an easy to use interface for indicating what writing systems a specific font supports.</source>
          <target state="translated">특정 글꼴이 지원하는 필기 시스템을 나타내는 데 사용하기 쉬운 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="99cf6f96e82f46730252a142b00640ee61a347f9" translate="yes" xml:space="preserve">
          <source>Its value defaults to an empty string.</source>
          <target state="translated">기본값은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4f6ee215d986399d1b4d2c51ddf9854c15f3efa7" translate="yes" xml:space="preserve">
          <source>Its value is a valid BCP 47 language tag, or the empty string.</source>
          <target state="translated">값은 유효한 BCP 47 언어 태그 또는 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="fc53d460b1baeb81f5a4e05fc5e9eea454cf2080" translate="yes" xml:space="preserve">
          <source>Its value is undefined when the menu is not visible.</source>
          <target state="translated">메뉴가 보이지 않으면 값이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2561a66c5bad24a94659bb96e07e4e33ac894ab3" translate="yes" xml:space="preserve">
          <source>Its value represents the maximum value of the height and width of a unity rectangle, mapped using the</source>
          <target state="translated">그 값은 단위 사각형의 높이와 너비의 최대 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e67da4ea416fe563a99a8d757cc843d2563649cd" translate="yes" xml:space="preserve">
          <source>IviApplication (QML type)</source>
          <target state="translated">IviApplication (QML 유형)</target>
        </trans-unit>
        <trans-unit id="76834cc46ec3dcc6a92611416e7021113d877d7f" translate="yes" xml:space="preserve">
          <source>IviApplication QML Type</source>
          <target state="translated">IviApplication QML 유형</target>
        </trans-unit>
        <trans-unit id="9e1770c185718e9e1ee82288e6169e645a25ba81" translate="yes" xml:space="preserve">
          <source>IviApplication corresponds to the Wayland &lt;code&gt;ivi_application&lt;/code&gt; interface.</source>
          <target state="translated">IviApplication은 Wayland &lt;code&gt;ivi_application&lt;/code&gt; 인터페이스에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="439ef8cec266e87d9e695bf18dc02fa44ea4e502" translate="yes" xml:space="preserve">
          <source>IviApplication.iviSurfaceCreated()</source>
          <target state="translated">IviApplication.iviSurfaceCreated()</target>
        </trans-unit>
        <trans-unit id="728cfc218103163c1c0648e0b57c3668dc704c59" translate="yes" xml:space="preserve">
          <source>IviApplication.iviSurfaceRequested()</source>
          <target state="translated">IviApplication.iviSurfaceRequested()</target>
        </trans-unit>
        <trans-unit id="d360967e0b5f909bd449ae0b3982b315abf3af43" translate="yes" xml:space="preserve">
          <source>IviSurface (QML type)</source>
          <target state="translated">IviSurface (QML 유형)</target>
        </trans-unit>
        <trans-unit id="90ab76c63ade1471ab9d44bb26672fbd96997413" translate="yes" xml:space="preserve">
          <source>IviSurface QML Type</source>
          <target state="translated">IviSurface QML 유형</target>
        </trans-unit>
        <trans-unit id="2b378ba64e099e55ff3b1e57e5ec5c82506931e7" translate="yes" xml:space="preserve">
          <source>IviSurface.initialize()</source>
          <target state="translated">IviSurface.initialize()</target>
        </trans-unit>
        <trans-unit id="097eda46d60ae8b03a7aa227fb771b34b849e749" translate="yes" xml:space="preserve">
          <source>IviSurface.iviId</source>
          <target state="translated">IviSurface.iviId</target>
        </trans-unit>
        <trans-unit id="217892801ba2092d572de935fbfc4ff825e8e82e" translate="yes" xml:space="preserve">
          <source>IviSurface.sendConfigure()</source>
          <target state="translated">IviSurface.sendConfigure()</target>
        </trans-unit>
        <trans-unit id="b7618f55a4d93f9b36a3cf6360c4b5882ef88b19" translate="yes" xml:space="preserve">
          <source>IviSurface.surface</source>
          <target state="translated">IviSurface.surface</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="c01ceebfcaaf3262991f1050f2d8e92b54b707d9" translate="yes" xml:space="preserve">
          <source>JAVA_HOME</source>
          <target state="translated">JAVA_HOME</target>
        </trans-unit>
        <trans-unit id="b5cb1b75f5bcf5b927fb6b9d18148211f229b1a1" translate="yes" xml:space="preserve">
          <source>JNI Types</source>
          <target state="translated">JNI 유형</target>
        </trans-unit>
        <trans-unit id="678f66cf27435b07bf6737b07a2ca8c6269806a0" translate="yes" xml:space="preserve">
          <source>JNIEnv *</source>
          <target state="translated">JNIEnv *</target>
        </trans-unit>
        <trans-unit id="380abcc49c946df70ce6cc7ef7a62b9a8066ef6e" translate="yes" xml:space="preserve">
          <source>JNIEnv *QAndroidJniEnvironment::operator JNIEnv *() const</source>
          <target state="translated">JNIEnv * QAndroidJniEnvironment :: 연산자 JNIEnv * () const</target>
        </trans-unit>
        <trans-unit id="855dad5523d783357eb2fe4102f2fdb6dbbd6838" translate="yes" xml:space="preserve">
          <source>JNIEnv *QAndroidJniEnvironment::operator-&amp;gt;()</source>
          <target state="translated">JNIEnv * QAndroidJniEnvironment :: operator-&amp;gt; ()</target>
        </trans-unit>
        <trans-unit id="8d9c5b6f99f2c6aeff049d2730ad66bdb86dae26" translate="yes" xml:space="preserve">
          <source>JP2</source>
          <target state="translated">JP2</target>
        </trans-unit>
        <trans-unit id="a45885aac538290762a4f7f3317abf411bb16059" translate="yes" xml:space="preserve">
          <source>JPEG</source>
          <target state="translated">JPEG</target>
        </trans-unit>
        <trans-unit id="45c9d11599074bb63e1dd7a5059ab11259e3a168" translate="yes" xml:space="preserve">
          <source>JPG</source>
          <target state="translated">JPG</target>
        </trans-unit>
        <trans-unit id="fcbebe43b7fb8a2cbbcd839cabba6a98f8b52696" translate="yes" xml:space="preserve">
          <source>JS API for loading Qt apps</source>
          <target state="translated">Qt 앱로드를위한 JS API</target>
        </trans-unit>
        <trans-unit id="7d6b41447d9df832dbbd6f417d4f00f05fef6963" translate="yes" xml:space="preserve">
          <source>JS stores Date objects in UTC time; all access to and from Date components in local time involves the application of the current offset from UTC. If the current offset changes due to the timezone being updated, the JS engine needs to be informed so that it can recalculate the offset.</source>
          <target state="translated">JS는 Date 객체를 UTC 시간으로 저장합니다. 현지 시간의 Date 구성 요소에 대한 모든 액세스에는 UTC의 현재 오프셋 적용이 포함됩니다. 시간대 업데이트로 인해 현재 오프셋이 변경되면 오프셋을 다시 계산할 수 있도록 JS 엔진에 알려야합니다.</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="249561bdc60823c920d0561dacbcec2675209e1b" translate="yes" xml:space="preserve">
          <source>JSON Support in Qt</source>
          <target state="translated">Qt의 JSON 지원</target>
        </trans-unit>
        <trans-unit id="853869a3a53285edcfd34c07e165413b35bb184c" translate="yes" xml:space="preserve">
          <source>JSON Type</source>
          <target state="translated">JSON 유형</target>
        </trans-unit>
        <trans-unit id="b1223fcc3a4c0e2f90d4d1b3e4722c355ddfd8e5" translate="yes" xml:space="preserve">
          <source>JSON is a format to store structured data. It has 6 basic data types:</source>
          <target state="translated">JSON은 구조화 된 데이터를 저장하는 형식입니다. 6 가지 기본 데이터 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="506e2599953e43f1d317ae689b01f4c2103a7710" translate="yes" xml:space="preserve">
          <source>JSON objects are defined as having string keys, unlike CBOR, so the conversion of a &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt; to &lt;a href=&quot;qjsonobject&quot;&gt;QJsonObject&lt;/a&gt; will imply a step of &quot;stringification&quot; of the key values. The conversion will use the special handling of tags and extended types from above and will also convert the rest of the types as follows:</source>
          <target state="translated">JSON 오브젝트는 CBOR과 달리 문자열 키를 갖는 것으로 정의되므로 &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt; 을 &lt;a href=&quot;qjsonobject&quot;&gt;QJsonObject로&lt;/a&gt; 변환하는 것은 키 값의 &quot; 문자열 &quot;단계를 의미합니다. 변환은 위에서 태그와 확장 유형의 특수 처리를 사용하고 다음과 같이 나머지 유형도 변환합니다.</target>
        </trans-unit>
        <trans-unit id="543dee3e7dea72bb91b9ad17f8f8dbcbe32cb88a" translate="yes" xml:space="preserve">
          <source>JSON support in Qt consists of these classes:</source>
          <target state="translated">Qt의 JSON 지원은 다음 클래스로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="1871ff14f52bf7e361f88ea91a3f712a4f74b424" translate="yes" xml:space="preserve">
          <source>James Su &amp;lt;suzhe@turbolinux.com.cn&amp;gt; &amp;lt;suzhe@gnuchina.org&amp;gt; generated the Big5-HKSCS-to-Unicode tables with a very space-efficient algorithm. He generously donated his code to glibc in May 2002. Subsequently, James has kindly allowed Anthony Fok &amp;lt;anthony@thizlinux.com&amp;gt; &amp;lt;foka@debian.org&amp;gt; to adapt the code for Qt.</source>
          <target state="translated">James Su &amp;lt;suzhe@turbolinux.com.cn&amp;gt; &amp;lt;suzhe@gnuchina.org&amp;gt;는 매우 공간 효율적인 알고리즘으로 Big5-HKSCS-to-Unicode 테이블을 생성했습니다. 그는 2002 년 5 월 자신의 코드를 glibc에 관대하게 기증했습니다. 이후 James는 Anthony Fok &amp;lt;anthony@thizlinux.com&amp;gt; &amp;lt;foka@debian.org&amp;gt;가 Qt에 맞게 코드를 수정하도록 친절하게 허용했습니다.</target>
        </trans-unit>
        <trans-unit id="77e326b63f74a0c1f198de25cea3b4ca0f6eb0dd" translate="yes" xml:space="preserve">
          <source>January (0)</source>
          <target state="translated">1 월 (0)</target>
        </trans-unit>
        <trans-unit id="9239c22d1d1c990ca8c206cb408b345a3ec8114c" translate="yes" xml:space="preserve">
          <source>Japanese</source>
          <target state="translated">Japanese</target>
        </trans-unit>
        <trans-unit id="4e54315dab818065272e669cac793624fec81566" translate="yes" xml:space="preserve">
          <source>Japanese (Full Width Latin)</source>
          <target state="translated">일본어 (전체 너비 라틴어)</target>
        </trans-unit>
        <trans-unit id="f60aa5cadcfc8b98bae866f98a84cc94a21e7db6" translate="yes" xml:space="preserve">
          <source>Japanese (Hiragana)</source>
          <target state="translated">일본어 (히라가나)</target>
        </trans-unit>
        <trans-unit id="1cab8c572e21000d1044c2bac03b5618f7ca80ea" translate="yes" xml:space="preserve">
          <source>Japanese (Katakana)</source>
          <target state="translated">일본어 (가타카나)</target>
        </trans-unit>
        <trans-unit id="b8e6ee1848b7277dbee1ac3892a225b659753017" translate="yes" xml:space="preserve">
          <source>Japanese (Latin)</source>
          <target state="translated">일본어 (라틴)</target>
        </trans-unit>
        <trans-unit id="8a3b175e8edcb86be8940e1a090b26c9a7018713" translate="yes" xml:space="preserve">
          <source>Japanese Layout (Full Width Latin)</source>
          <target state="translated">일본어 레이아웃 (전체 너비 라틴어)</target>
        </trans-unit>
        <trans-unit id="56a21e910392028d8cce237a948cfa9f77547233" translate="yes" xml:space="preserve">
          <source>Japanese Layout (Hiragana)</source>
          <target state="translated">일본어 레이아웃 (히라가나)</target>
        </trans-unit>
        <trans-unit id="e77fbab0a2df39878b7cad821f73b3846d3dd030" translate="yes" xml:space="preserve">
          <source>Japanese Layout (Katakana)</source>
          <target state="translated">일본어 레이아웃 (가타카나)</target>
        </trans-unit>
        <trans-unit id="857d049820a4ce6e04ed8342986257f34651822e" translate="yes" xml:space="preserve">
          <source>Japanese Layout (Latin)</source>
          <target state="translated">일본어 레이아웃 (라틴)</target>
        </trans-unit>
        <trans-unit id="781790b7671e585d37fef7848c6a7c95c9d5ab13" translate="yes" xml:space="preserve">
          <source>Japanese handwriting input mode.</source>
          <target state="translated">일본어 필기 입력 모드</target>
        </trans-unit>
        <trans-unit id="76252bff7709f2744d41b83f668df915f5bb53f3" translate="yes" xml:space="preserve">
          <source>Java Native Methods</source>
          <target state="translated">자바 네이티브 메소드</target>
        </trans-unit>
        <trans-unit id="9cf9edb8ef96503fbfc5c684ef953d34d45396e4" translate="yes" xml:space="preserve">
          <source>Java Style</source>
          <target state="translated">자바 스타일</target>
        </trans-unit>
        <trans-unit id="0f7976687b15780013be608563916b3199996ac8" translate="yes" xml:space="preserve">
          <source>Java combo boxes do not use the focus rect; it changes its background color when it has focus. The &lt;code&gt;SC_ComboBoxEdit&lt;/code&gt; field is used both by &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; to calculate the size of the edit field and the style for calculating the size of the combo box label.</source>
          <target state="translated">Java 콤보 박스는 포커스 렉트를 사용하지 않습니다. 초점이있을 때 배경색이 바뀝니다. &lt;code&gt;SC_ComboBoxEdit&lt;/code&gt; 의 필드로 모두 사용 &lt;a href=&quot;qcombobox&quot;&gt;QComboBox을&lt;/a&gt; 편집 필드의 크기와 콤보 상자 라벨의 크기를 계산하는 스타일을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="0d23903411cc2fd985f3f4d3cfa78ea1a15f5869" translate="yes" xml:space="preserve">
          <source>Java implementation:</source>
          <target state="translated">자바 구현 :</target>
        </trans-unit>
        <trans-unit id="fc508029bd7283de505c6cdaa22d1e911b0787ef" translate="yes" xml:space="preserve">
          <source>Java native methods makes it possible to call native code from Java, this is done by creating a function declaration in Java and prefixing it with the &lt;b&gt;native&lt;/b&gt; keyword. Before a native function can be called from Java, you need to map the Java native function to a native function in your code. Mapping functions can be done by calling the RegisterNatives() function through the &lt;a href=&quot;qandroidjnienvironment&quot;&gt;JNI environment pointer&lt;/a&gt;.</source>
          <target state="translated">Java 원시 메소드를 사용하면 Java에서 원시 코드를 호출 할 수 있습니다. 이는 Java에서 함수 선언을 작성하고 &lt;b&gt;native&lt;/b&gt; 키워드를 접두어로 사용하여 수행됩니다 . Java에서 기본 함수를 호출하기 전에 Java 기본 함수를 코드의 기본 함수에 맵핑해야합니다. &lt;a href=&quot;qandroidjnienvironment&quot;&gt;JNI 환경 포인터를&lt;/a&gt; 통해 RegisterNatives () 함수를 호출하여 맵핑 함수를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ed103d0faa79d701a75e9f1a77da8da08f70695" translate="yes" xml:space="preserve">
          <source>Java object.</source>
          <target state="translated">자바 객체.</target>
        </trans-unit>
        <trans-unit id="848a653748e5eebe7abd8e58f8f4c90aeeb45ec7" translate="yes" xml:space="preserve">
          <source>Java-Style Iterators</source>
          <target state="translated">자바 스타일 이터레이터</target>
        </trans-unit>
        <trans-unit id="4d7bcd1b4def0297d4ffd7e62325bb175c021030" translate="yes" xml:space="preserve">
          <source>Java-style iterator for QJSValue</source>
          <target state="translated">QJSValue에 대한 Java 스타일 반복자</target>
        </trans-unit>
        <trans-unit id="8a455d0d9c7ad534629f69c3c3d4baa09335e80c" translate="yes" xml:space="preserve">
          <source>Java-style iterator:</source>
          <target state="translated">자바 스타일 이터레이터 :</target>
        </trans-unit>
        <trans-unit id="db3b264152fd8c6bbd70b61bcded2b12ab3255a7" translate="yes" xml:space="preserve">
          <source>JavaScript API</source>
          <target state="translated">자바 스크립트 API</target>
        </trans-unit>
        <trans-unit id="eb0ba38a4b9eaf1c6804b5f4827da6816fbe23e1" translate="yes" xml:space="preserve">
          <source>JavaScript Code</source>
          <target state="translated">자바 스크립트 코드</target>
        </trans-unit>
        <trans-unit id="674e8d3579b28b1fa1081f86069898cebc06ba60" translate="yes" xml:space="preserve">
          <source>JavaScript Environment Restrictions</source>
          <target state="translated">자바 스크립트 환경 제한</target>
        </trans-unit>
        <trans-unit id="e633b2345ea801022b33bda2c537944f8a140480" translate="yes" xml:space="preserve">
          <source>JavaScript Environment for QML Applications</source>
          <target state="translated">QML 애플리케이션을위한 JavaScript 환경</target>
        </trans-unit>
        <trans-unit id="431d43558edf8c0b0cb2a79c0d222d25abc229f3" translate="yes" xml:space="preserve">
          <source>JavaScript Expressions in QML Documents</source>
          <target state="translated">QML 문서의 JavaScript 표현식</target>
        </trans-unit>
        <trans-unit id="d3c39fabe61dd89da00dd2e28ca073d49b03bd32" translate="yes" xml:space="preserve">
          <source>JavaScript Global Object</source>
          <target state="translated">자바 스크립트 글로벌 객체</target>
        </trans-unit>
        <trans-unit id="6832849d7095b0175278344f3727c728b26d0266" translate="yes" xml:space="preserve">
          <source>JavaScript Host Environment</source>
          <target state="translated">자바 스크립트 호스트 환경</target>
        </trans-unit>
        <trans-unit id="7b80ea5d72ad33ef275884a5a0657ab539f013c5" translate="yes" xml:space="preserve">
          <source>JavaScript Objects and Functions</source>
          <target state="translated">자바 스크립트 객체와 함수</target>
        </trans-unit>
        <trans-unit id="9098957173ee17596abe8bc5287568b7ec48573f" translate="yes" xml:space="preserve">
          <source>JavaScript Resource Declaration</source>
          <target state="translated">자바 스크립트 리소스 선언</target>
        </trans-unit>
        <trans-unit id="debf8acd3ec3f91bb5887773dc9c4ba5783a1706" translate="yes" xml:space="preserve">
          <source>JavaScript Resource Imports</source>
          <target state="translated">자바 스크립트 리소스 가져 오기</target>
        </trans-unit>
        <trans-unit id="c54c1ab9d730de0a215c4c228bd2d187a448ced9" translate="yes" xml:space="preserve">
          <source>JavaScript Resources from Modules</source>
          <target state="translated">모듈의 JavaScript 리소스</target>
        </trans-unit>
        <trans-unit id="d7bcb0df2eaeebdec88021f006fb0066151fe69d" translate="yes" xml:space="preserve">
          <source>JavaScript Scope</source>
          <target state="translated">자바 스크립트 범위</target>
        </trans-unit>
        <trans-unit id="1995147bb58af8710f4d3fa0dc985a3e82655902" translate="yes" xml:space="preserve">
          <source>JavaScript Types</source>
          <target state="translated">자바 스크립트 유형</target>
        </trans-unit>
        <trans-unit id="a01f82b5c7317dba756aa24a782363bb59f44f96" translate="yes" xml:space="preserve">
          <source>JavaScript can easily be used in QML to respond to events.</source>
          <target state="translated">QML에서 JavaScript를 사용하여 이벤트에 응답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58f886187fa89d81c0797d9ae1a66cccf851e675" translate="yes" xml:space="preserve">
          <source>JavaScript code written in a &lt;code&gt;.qml&lt;/code&gt; file cannot modify the global object. JavaScript code in a .js file can modify the global object, and those modifications will be visible to the .qml file when &lt;a href=&quot;qtqml-javascript-imports#importing-a-javascript-resource-from-a-qml-document&quot;&gt;imported&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.qml&lt;/code&gt; 파일로 작성된 JavaScript 코드 는 전역 객체를 수정할 수 없습니다. .js 파일의 JavaScript 코드는 전역 객체를 수정할 수 있으며 이러한 수정 사항은 &lt;a href=&quot;qtqml-javascript-imports#importing-a-javascript-resource-from-a-qml-document&quot;&gt;가져올&lt;/a&gt; 때 .qml 파일에 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="69a4812149985e45d1d00a4b5f0c96f02d5e1a0d" translate="yes" xml:space="preserve">
          <source>JavaScript executed inside Qt WebEngine can use the &lt;a href=&quot;https://developers.google.com/web/tools/javascript/console/console-write&quot;&gt;Chrome console API&lt;/a&gt; to log information to a console. The logging messages are forwarded to Qt's logging facilities inside a &lt;code&gt;js&lt;/code&gt;&lt;a href=&quot;qloggingcategory&quot;&gt;logging category&lt;/a&gt;. However, only warning and fatal messages are printed by default. To change this, you either have to set custom rules for the &lt;code&gt;js&lt;/code&gt; category, or provide custom message handlers by reimplementing &lt;a href=&quot;qwebenginepage#javaScriptConsoleMessage&quot;&gt;QWebEnginePage::javaScriptConsoleMessage&lt;/a&gt;(), or connecting to &lt;a href=&quot;qml-qtwebengine-webengineview#javaScriptConsoleMessage-signal&quot;&gt;WebEngineView::javaScriptConsoleMessage&lt;/a&gt;().</source>
          <target state="translated">Qt WebEngine 내에서 실행되는 JavaScript는 &lt;a href=&quot;https://developers.google.com/web/tools/javascript/console/console-write&quot;&gt;Chrome 콘솔 API&lt;/a&gt; 를 사용하여 정보를 콘솔에 기록 할 수 있습니다 . 로깅 메시지는 &lt;code&gt;js&lt;/code&gt; &lt;a href=&quot;qloggingcategory&quot;&gt;로깅 범주&lt;/a&gt; 내의 Qt 로깅 기능으로 전달됩니다 . 그러나 기본적으로 경고 및 치명적 메시지 만 인쇄됩니다. 이 설정을 변경하려면 중 하나에 대한 설정 사용자 지정 규칙을 가지고 &lt;code&gt;js&lt;/code&gt; 카테고리, 또는 재 구현하여 사용자 지정 메시지 처리기를 제공 &lt;a href=&quot;qwebenginepage#javaScriptConsoleMessage&quot;&gt;QWebEnginePage :: javaScriptConsoleMessage을&lt;/a&gt; () 또는 연결 &lt;a href=&quot;qml-qtwebengine-webengineview#javaScriptConsoleMessage-signal&quot;&gt;WebEngineView :: javaScriptConsoleMessage&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="b08256e393454a5e416788b8610af9ecb80a5316" translate="yes" xml:space="preserve">
          <source>JavaScript executed inside Qt WebEngine can use the &lt;a href=&quot;https://developers.google.com/web/tools/javascript/console/console-write#&quot;&gt;Chrome console API&lt;/a&gt; to log information to a console. The logging messages are forwarded to Qt's logging facilities inside a &lt;code&gt;js&lt;/code&gt;&lt;a href=&quot;qloggingcategory&quot;&gt;logging category&lt;/a&gt;. However, only warning and fatal messages are printed by default. To change this, you either have to set custom rules for the &lt;code&gt;js&lt;/code&gt; category, or provide custom message handlers by reimplementing &lt;a href=&quot;qwebenginepage#javaScriptConsoleMessage&quot;&gt;QWebEnginePage::javaScriptConsoleMessage&lt;/a&gt;(), or connecting to &lt;a href=&quot;qml-qtwebengine-webengineview#javaScriptConsoleMessage-signal&quot;&gt;WebEngineView::javaScriptConsoleMessage&lt;/a&gt;().</source>
          <target state="translated">Qt WebEngine에서 실행되는 JavaScript는 &lt;a href=&quot;https://developers.google.com/web/tools/javascript/console/console-write#&quot;&gt;Chrome 콘솔 API&lt;/a&gt; 를 사용하여 정보를 콘솔에 기록 할 수 있습니다 . 로깅 메시지는 &lt;code&gt;js&lt;/code&gt; &lt;a href=&quot;qloggingcategory&quot;&gt;logging category&lt;/a&gt; 내의 Qt 로깅 기능으로 전달됩니다 . 그러나 기본적으로 경고 및 치명적인 메시지 만 인쇄됩니다. 이 설정을 변경하려면 중 하나에 대한 설정 사용자 지정 규칙을 가지고 &lt;code&gt;js&lt;/code&gt; 카테고리, 또는 재 구현하여 사용자 지정 메시지 처리기를 제공 &lt;a href=&quot;qwebenginepage#javaScriptConsoleMessage&quot;&gt;QWebEnginePage :: javaScriptConsoleMessage을&lt;/a&gt; () 또는 연결 &lt;a href=&quot;qml-qtwebengine-webengineview#javaScriptConsoleMessage-signal&quot;&gt;WebEngineView :: javaScriptConsoleMessage&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="d80447f15882f7db0fe0be9925a9723e66411bae" translate="yes" xml:space="preserve">
          <source>JavaScript expressions allow QML code to contain application logic. Qt QML provides the framework for running JavaScript expressions in QML and from C++.</source>
          <target state="translated">JavaScript 표현식을 사용하면 QML 코드에 애플리케이션 로직이 포함될 수 있습니다. Qt QML은 QML 및 C ++에서 JavaScript 표현식을 실행하기위한 프레임 워크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5e18c4bfa1f5b7122293f377048396d25d69cbd4" translate="yes" xml:space="preserve">
          <source>JavaScript file imports must be qualified when imported, so that the properties and methods they provide can be accessed.</source>
          <target state="translated">JavaScript 파일 가져 오기는 가져올 때 규정되어야하며, 제공되는 특성 및 메소드에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f203f587fa46ea9960ac657174ac0716efbfc88" translate="yes" xml:space="preserve">
          <source>JavaScript functions</source>
          <target state="translated">자바 스크립트 함수</target>
        </trans-unit>
        <trans-unit id="88e02fb1bbbc157e88dc4ac3c1866499b15a1827" translate="yes" xml:space="preserve">
          <source>JavaScript in application startup code</source>
          <target state="translated">응용 프로그램 시작 코드의 JavaScript</target>
        </trans-unit>
        <trans-unit id="038986efd78af1b25e33cf792b36f1f091188c68" translate="yes" xml:space="preserve">
          <source>JavaScript in custom methods</source>
          <target state="translated">사용자 정의 메소드의 JavaScript</target>
        </trans-unit>
        <trans-unit id="074c751e73c67936120c7c3a6328f74f49803b4b" translate="yes" xml:space="preserve">
          <source>JavaScript in property bindings</source>
          <target state="translated">속성 바인딩의 JavaScript</target>
        </trans-unit>
        <trans-unit id="3aa0a6ae1e7905c12f5024894e5ce3de3aeecb93" translate="yes" xml:space="preserve">
          <source>JavaScript in signal handlers</source>
          <target state="translated">신호 처리기의 JavaScript</target>
        </trans-unit>
        <trans-unit id="3c40ff82fd5da73be08fa354cdfb992a5fa095e8" translate="yes" xml:space="preserve">
          <source>JavaScript in standalone functions</source>
          <target state="translated">독립형 함수의 JavaScript</target>
        </trans-unit>
        <trans-unit id="db01d568d032ae957e4a43f66e67383c7b8e8dde" translate="yes" xml:space="preserve">
          <source>JavaScript objects and arrays</source>
          <target state="translated">자바 스크립트 객체와 배열</target>
        </trans-unit>
        <trans-unit id="7e5a5bd1c2391be213934d16e4320a85a5e2ff0d" translate="yes" xml:space="preserve">
          <source>JavaScript programmers should also note that when a JavaScript object is copied to an array or map property, the</source>
          <target state="translated">JavaScript 프로그래머는 JavaScript 객체가 배열 또는 맵 속성으로 복사 될 때</target>
        </trans-unit>
        <trans-unit id="bb89c2d715d383dbdcbbfc8f0d6eacd332c9815d" translate="yes" xml:space="preserve">
          <source>JavaScript provides garbage collection. Memory which is allocated on the JavaScript heap (as opposed to the C++ heap) is owned by the JavaScript engine. The engine will periodically collect all unreferenced data on the JavaScript heap.</source>
          <target state="translated">JavaScript는 가비지 콜렉션을 제공합니다. C ++ 힙과 달리 JavaScript 힙에 할당 된 메모리는 JavaScript 엔진이 소유합니다. 엔진은 JavaScript 힙에서 참조되지 않은 모든 데이터를 주기적으로 수집합니다.</target>
        </trans-unit>
        <trans-unit id="9b85b0a166ed3b1ae688ab5e0a94048b0dd20dc5" translate="yes" xml:space="preserve">
          <source>JavaScript resources may also import QML modules and other JavaScript resources. The syntax of an import statement within a JavaScript resource differs slightly from an import statement within a QML document, which is documented thoroughly below.</source>
          <target state="translated">JavaScript 리소스는 QML 모듈 및 기타 JavaScript 리소스를 가져올 수도 있습니다. JavaScript 리소스 내의 import 문의 구문은 아래에 자세히 설명되어있는 QML 문서 내의 import 문과 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="686fcab6227cd19e27229605b2d559943522d4f4" translate="yes" xml:space="preserve">
          <source>JavaScript resources may be imported directly in a QML document. Every JavaScript resource must have an identifier by which it is accessed.</source>
          <target state="translated">JavaScript 리소스는 QML 문서에서 직접 가져올 수 있습니다. 모든 JavaScript 리소스에는 액세스 할 수있는 식별자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="67f93fbf35cefcc8cf2e5d9084e4da3948beeb72" translate="yes" xml:space="preserve">
          <source>JavaScript will be executed in the</source>
          <target state="translated">자바 스크립트는</target>
        </trans-unit>
        <trans-unit id="e98710078ec54b58216bcf04b3b9e0c3974e0afc" translate="yes" xml:space="preserve">
          <source>JavaScript world that the web channel instance used by this view is installed in. The world must be a number between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;256&lt;/code&gt;.</source>
          <target state="translated">자바 스크립트의 세계는이 뷰가 사용하는 웹 채널 인스턴스에 설치되어 있는지 확인합니다. 세계 사이의 숫자 여야 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;256&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba093357ac278733521f1bc31c10fbcee51106d9" translate="yes" xml:space="preserve">
          <source>JavaScriptConsoleMessageLevel : &lt;a href=&quot;qml-enumeration&quot;&gt;enumeration&lt;/a&gt;</source>
          <target state="translated">JavaScriptConsoleMessageLevel : &lt;a href=&quot;qml-enumeration&quot;&gt;열거&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="caadd28108bb8114ceebe8379cf9289e38930164" translate="yes" xml:space="preserve">
          <source>JavaScriptCore Macro Assembler</source>
          <target state="translated">JavaScriptCore 매크로 어셈블러</target>
        </trans-unit>
        <trans-unit id="9eeeecd4294119d31f1a4423cc4885b9e6802dee" translate="yes" xml:space="preserve">
          <source>JavaScriptDialogRequest (QML type)</source>
          <target state="translated">JavaScriptDialogRequest (QML 유형)</target>
        </trans-unit>
        <trans-unit id="75a41e81b6f01b5631cd0093c961a4249994d8ad" translate="yes" xml:space="preserve">
          <source>JavaScriptDialogRequest QML Type</source>
          <target state="translated">JavaScriptDialogRequest QML 유형</target>
        </trans-unit>
        <trans-unit id="977e35a7a8543318d160d3b3d69a4bfa1ab1168f" translate="yes" xml:space="preserve">
          <source>JavaScriptDialogRequest.accepted</source>
          <target state="translated">JavaScriptDialogRequest.accepted</target>
        </trans-unit>
        <trans-unit id="3984aa82261590de4f93a878fd49e96c4297d73a" translate="yes" xml:space="preserve">
          <source>JavaScriptDialogRequest.defaultText</source>
          <target state="translated">JavaScriptDialogRequest.defaultText</target>
        </trans-unit>
        <trans-unit id="864c55711391aa500f5b541982703ecd96737ce5" translate="yes" xml:space="preserve">
          <source>JavaScriptDialogRequest.dialogAccept()</source>
          <target state="translated">JavaScriptDialogRequest.dialogAccept()</target>
        </trans-unit>
        <trans-unit id="d57f743b8bc714d20d759c8d822e8715861a3734" translate="yes" xml:space="preserve">
          <source>JavaScriptDialogRequest.dialogReject()</source>
          <target state="translated">JavaScriptDialogRequest.dialogReject()</target>
        </trans-unit>
        <trans-unit id="f574edce68fdbab007912e61a174532094b3e2b4" translate="yes" xml:space="preserve">
          <source>JavaScriptDialogRequest.message</source>
          <target state="translated">JavaScriptDialogRequest.message</target>
        </trans-unit>
        <trans-unit id="ec5aaf52b2c6b7a4643f50e90f3e7fe2b3661a67" translate="yes" xml:space="preserve">
          <source>JavaScriptDialogRequest.securityOrigin</source>
          <target state="translated">JavaScriptDialogRequest.securityOrigin</target>
        </trans-unit>
        <trans-unit id="c16f7de27854d9ff0fe3a7946f0f9d1340f3233e" translate="yes" xml:space="preserve">
          <source>JavaScriptDialogRequest.title</source>
          <target state="translated">JavaScriptDialogRequest.title</target>
        </trans-unit>
        <trans-unit id="8ecb984ffcaf0e6293534b5d63da1c0a7f13522b" translate="yes" xml:space="preserve">
          <source>JavaScriptDialogRequest.type</source>
          <target state="translated">JavaScriptDialogRequest.type</target>
        </trans-unit>
        <trans-unit id="42d0ccec15dc73a2393867ff1eb4fa561220576c" translate="yes" xml:space="preserve">
          <source>JavaVM *</source>
          <target state="translated">JavaVM *</target>
        </trans-unit>
        <trans-unit id="542b31fb13a37e8655da22965c43454e89c730c2" translate="yes" xml:space="preserve">
          <source>Javascript files can be provided by modules, by adding identifier definitions to the &lt;code&gt;qmldir&lt;/code&gt; file which specifies the module.</source>
          <target state="translated">모듈 을 지정하는 &lt;code&gt;qmldir&lt;/code&gt; 파일에 식별자 정의를 추가하여 모듈에서 Javascript 파일을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ee0efdc0236741b560d7db08c5be94abf9436f6" translate="yes" xml:space="preserve">
          <source>JazzMusic</source>
          <target state="translated">JazzMusic</target>
        </trans-unit>
        <trans-unit id="347c5f236939f9616dae098d1d7b7cd291a41730" translate="yes" xml:space="preserve">
          <source>Join Style</source>
          <target state="translated">스타일 결합</target>
        </trans-unit>
        <trans-unit id="36071512fa06c6e29b2025945172ddce98c21e0d" translate="yes" xml:space="preserve">
          <source>JoiningType &lt;a href=&quot;qchar#joiningType&quot;&gt;joiningType&lt;/a&gt;() const &lt;code&gt;(preliminary)&lt;/code&gt;</source>
          <target state="translated">JoiningType &lt;a href=&quot;qchar#joiningType&quot;&gt;joiningType&lt;/a&gt; () const &lt;code&gt;(preliminary)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="99f99751f5ce3aee731176a059d3b8f2f1dcfb2f" translate="yes" xml:space="preserve">
          <source>Joins all the byte arrays into a single byte array with each element separated by the given</source>
          <target state="translated">모든 바이트 배열을 단일 바이트 배열로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="c0369af5b694a2ac9aefaa523c6103b89780a22b" translate="yes" xml:space="preserve">
          <source>Joins all the byte arrays into a single byte array.</source>
          <target state="translated">모든 바이트 배열을 단일 바이트 배열로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="d80c5b18d6fcfa3fca0e4295ff627fb282ce54f6" translate="yes" xml:space="preserve">
          <source>Joins all the string list's strings into a single string with each element separated by the given</source>
          <target state="translated">모든 문자열 목록의 문자열을 주어진 각 요소가 구분 된 단일 문자열로 결합합니다.</target>
        </trans-unit>
        <trans-unit id="1ed3523d1b28493715cfa0fd6342dccc3eeff669" translate="yes" xml:space="preserve">
          <source>Joins the multicast group address</source>
          <target state="translated">멀티 캐스트 그룹 주소에 참여</target>
        </trans-unit>
        <trans-unit id="510ab51b28c0e9fcfa5a89489ff07c4c56733b2d" translate="yes" xml:space="preserve">
          <source>Joins the multicast group specified by</source>
          <target state="translated">에 의해 지정된 멀티 캐스트 그룹에 참여</target>
        </trans-unit>
        <trans-unit id="702852193a880bba95a38d381e65cde2ab1358b5" translate="yes" xml:space="preserve">
          <source>Joins the value of &lt;code&gt;variablename&lt;/code&gt; with &lt;code&gt;glue&lt;/code&gt;. If this value is not empty, this function prefixes the value with &lt;code&gt;before&lt;/code&gt; and suffixes it with &lt;code&gt;after&lt;/code&gt;. &lt;code&gt;variablename&lt;/code&gt; is the only required field, the others default to empty strings. If you need to encode spaces in &lt;code&gt;glue&lt;/code&gt;, &lt;code&gt;before&lt;/code&gt;, or &lt;code&gt;after&lt;/code&gt;, you must quote them.</source>
          <target state="translated">의 값 조인 &lt;code&gt;variablename&lt;/code&gt; 와 &lt;code&gt;glue&lt;/code&gt; . 이 값이 비어 있지 않은 경우,이 기능을 사용하여 값을 접두사 &lt;code&gt;before&lt;/code&gt; 과 함께 접미사 &lt;code&gt;after&lt;/code&gt; . &lt;code&gt;variablename&lt;/code&gt; 은 유일한 필수 필드이고 다른 필드는 기본적으로 빈 문자열입니다. 공간을 &lt;code&gt;glue&lt;/code&gt; , &lt;code&gt;before&lt;/code&gt; 또는 &lt;code&gt;after&lt;/code&gt; 로 인코딩해야하는 경우 인용 부호를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e08e57447bc451c11bf4dd7d56173838cfb9b38b" translate="yes" xml:space="preserve">
          <source>Joint</source>
          <target state="translated">Joint</target>
        </trans-unit>
        <trans-unit id="a44acee107c76f5cd5a1315722baa9546321c024" translate="yes" xml:space="preserve">
          <source>Joint (QML type)</source>
          <target state="translated">조인트 (QML 타입)</target>
        </trans-unit>
        <trans-unit id="e040c179db7a2ea2e6c979a65fa9dae317dba7c7" translate="yes" xml:space="preserve">
          <source>Joint Photographic Experts Group</source>
          <target state="translated">공동 사진 전문가 그룹</target>
        </trans-unit>
        <trans-unit id="00607cfdbc4c3ab2fd81308bcdc12349ea094576" translate="yes" xml:space="preserve">
          <source>Joint Photographic Experts Group 2000</source>
          <target state="translated">공동 사진 전문가 그룹 2000</target>
        </trans-unit>
        <trans-unit id="fa330c6dede65364c324eaa224448a09524e7bb4" translate="yes" xml:space="preserve">
          <source>Joint QML Type</source>
          <target state="translated">공동 QML 유형</target>
        </trans-unit>
        <trans-unit id="844e728aaec84b8beba272ceced18b434247c16d" translate="yes" xml:space="preserve">
          <source>Joint.childJoints</source>
          <target state="translated">Joint.childJoints</target>
        </trans-unit>
        <trans-unit id="31f8c62fd55543da5587f69304a3c8aaee19ca13" translate="yes" xml:space="preserve">
          <source>Joint.inverseBindMatrix</source>
          <target state="translated">Joint.inverseBindMatrix</target>
        </trans-unit>
        <trans-unit id="df93afccce8f09a2def7baf02b519db0f5ab5e2d" translate="yes" xml:space="preserve">
          <source>Joint.rotation</source>
          <target state="translated">Joint.rotation</target>
        </trans-unit>
        <trans-unit id="bd116ac89b6e252dc6bb757f5d43dc5b453f2b47" translate="yes" xml:space="preserve">
          <source>Joint.rotationX</source>
          <target state="translated">Joint.rotationX</target>
        </trans-unit>
        <trans-unit id="0f8bca37d0e3ded174fdb3b0016e3a059f104195" translate="yes" xml:space="preserve">
          <source>Joint.rotationY</source>
          <target state="translated">Joint.rotationY</target>
        </trans-unit>
        <trans-unit id="5c74ee3e893c9e0c71e73595ee7b0ecfc35d497b" translate="yes" xml:space="preserve">
          <source>Joint.rotationZ</source>
          <target state="translated">Joint.rotationZ</target>
        </trans-unit>
        <trans-unit id="194a1f24dcdb4e7028d0cc776ea7597f97306d37" translate="yes" xml:space="preserve">
          <source>Joint.scale</source>
          <target state="translated">Joint.scale</target>
        </trans-unit>
        <trans-unit id="4206bcc39c8ed4b1a7f5678328a88b76e0f6e451" translate="yes" xml:space="preserve">
          <source>Joint.translation</source>
          <target state="translated">Joint.translation</target>
        </trans-unit>
        <trans-unit id="8968a3966abf380577ea74b453c61bbba5fa0f3e" translate="yes" xml:space="preserve">
          <source>Jul 2 69</source>
          <target state="translated">7 월 2 일 69</target>
        </trans-unit>
        <trans-unit id="bc36199b49b0624d5db48b67fd61ae7f17f10530" translate="yes" xml:space="preserve">
          <source>Julian Calendar</source>
          <target state="translated">율리우스 력</target>
        </trans-unit>
        <trans-unit id="b14735bc340ab88f29ae0a8eb597808eb625107e" translate="yes" xml:space="preserve">
          <source>July (6)</source>
          <target state="translated">7 월 (6)</target>
        </trans-unit>
        <trans-unit id="e3309ab897ccf83869e9a6b5f5cbed514e32e0a2" translate="yes" xml:space="preserve">
          <source>July 2 69</source>
          <target state="translated">7 월 2 일 69</target>
        </trans-unit>
        <trans-unit id="5eac28759f958509786f6970d5b3626e0fd5701d" translate="yes" xml:space="preserve">
          <source>JumpList (QML type)</source>
          <target state="translated">JumpList (QML 유형)</target>
        </trans-unit>
        <trans-unit id="4f9f032cd1b8e28af9e786f77121e58469d8cb82" translate="yes" xml:space="preserve">
          <source>JumpList QML Type</source>
          <target state="translated">JumpList QML 유형</target>
        </trans-unit>
        <trans-unit id="d39d2fe7fb691bcc5148a42927ce2e08654d9cbe" translate="yes" xml:space="preserve">
          <source>JumpList.categories</source>
          <target state="translated">JumpList.categories</target>
        </trans-unit>
        <trans-unit id="039499a01bd5c392021426061c333808821595df" translate="yes" xml:space="preserve">
          <source>JumpList.frequent</source>
          <target state="translated">JumpList.frequent</target>
        </trans-unit>
        <trans-unit id="af7f1790d4f76d1d4e8120ae2f0c0b49952fe9cc" translate="yes" xml:space="preserve">
          <source>JumpList.recent</source>
          <target state="translated">JumpList.recent</target>
        </trans-unit>
        <trans-unit id="ba9e36b9176e6e80dab69ed46828c9837313d4d7" translate="yes" xml:space="preserve">
          <source>JumpList.tasks</source>
          <target state="translated">JumpList.tasks</target>
        </trans-unit>
        <trans-unit id="f8cb48ed6d8d09f73ee0d737a9c690cf125cd02c" translate="yes" xml:space="preserve">
          <source>JumpListCategory (QML type)</source>
          <target state="translated">JumpListCategory (QML 유형)</target>
        </trans-unit>
        <trans-unit id="ee79017ccb5ee3d19dab3451f37fdd227eec6643" translate="yes" xml:space="preserve">
          <source>JumpListCategory QML Type</source>
          <target state="translated">JumpListCategory QML 유형</target>
        </trans-unit>
        <trans-unit id="dcc5ac64181198519149f1b9eb1eaa4f8a662d35" translate="yes" xml:space="preserve">
          <source>JumpListCategory.items</source>
          <target state="translated">JumpListCategory.items</target>
        </trans-unit>
        <trans-unit id="5bc678195f42591f1e70d8f23300fef57fdc8dc8" translate="yes" xml:space="preserve">
          <source>JumpListCategory.title</source>
          <target state="translated">JumpListCategory.title</target>
        </trans-unit>
        <trans-unit id="83f0483735bfc94cb694a17a46a7a18dc127eaeb" translate="yes" xml:space="preserve">
          <source>JumpListCategory.visible</source>
          <target state="translated">JumpListCategory.visible</target>
        </trans-unit>
        <trans-unit id="acd636f2acb927500d7c96a39dd975ce577ee534" translate="yes" xml:space="preserve">
          <source>JumpListDestination (QML type)</source>
          <target state="translated">JumpListDestination (QML 유형)</target>
        </trans-unit>
        <trans-unit id="1f51886700205f8c6f26dfec27287af1131af3ee" translate="yes" xml:space="preserve">
          <source>JumpListDestination QML Type</source>
          <target state="translated">대상 QML 유형</target>
        </trans-unit>
        <trans-unit id="30cdf62f0653d05402e4d3525b3c7410ff9a0385" translate="yes" xml:space="preserve">
          <source>JumpListDestination.filePath</source>
          <target state="translated">JumpListDestination.filePath</target>
        </trans-unit>
        <trans-unit id="a3fb23f7c04abcfa90f290e791dd23ef7086a4f4" translate="yes" xml:space="preserve">
          <source>JumpListLink (QML type)</source>
          <target state="translated">JumpListLink (QML 유형)</target>
        </trans-unit>
        <trans-unit id="cfd3009d2c719d21725d8cfa952914c0c3a61d14" translate="yes" xml:space="preserve">
          <source>JumpListLink QML Type</source>
          <target state="translated">JumpListLink QML 유형</target>
        </trans-unit>
        <trans-unit id="84f309ea5b5f133d44da0314f407c0d1e6f6873a" translate="yes" xml:space="preserve">
          <source>JumpListLink.arguments</source>
          <target state="translated">JumpListLink.arguments</target>
        </trans-unit>
        <trans-unit id="5d7a2afcb3c24f25efebd3916a7cf21bde1f363a" translate="yes" xml:space="preserve">
          <source>JumpListLink.description</source>
          <target state="translated">JumpListLink.description</target>
        </trans-unit>
        <trans-unit id="1cd941fb64d296f14ee63af726a891ed0ba58829" translate="yes" xml:space="preserve">
          <source>JumpListLink.executablePath</source>
          <target state="translated">JumpListLink.executablePath</target>
        </trans-unit>
        <trans-unit id="abd28316ad36d8f4e335c6551f1f7a9e303bd086" translate="yes" xml:space="preserve">
          <source>JumpListLink.iconPath</source>
          <target state="translated">JumpListLink.iconPath</target>
        </trans-unit>
        <trans-unit id="a43ae71858162cf5a50d2f91fd2891ed8746bc22" translate="yes" xml:space="preserve">
          <source>JumpListLink.title</source>
          <target state="translated">JumpListLink.title</target>
        </trans-unit>
        <trans-unit id="b284e5c8df1ef0e109e21528ddc3705ac711452f" translate="yes" xml:space="preserve">
          <source>JumpListSeparator (QML type)</source>
          <target state="translated">JumpListSeparator (QML 유형)</target>
        </trans-unit>
        <trans-unit id="31afda3976743dd11cedf3551dc782f566da5c0a" translate="yes" xml:space="preserve">
          <source>JumpListSeparator QML Type</source>
          <target state="translated">JumpListSeparator QML 유형</target>
        </trans-unit>
        <trans-unit id="2f9d67453f29234ffa201ab745a5ac50dae607c3" translate="yes" xml:space="preserve">
          <source>Jumps to frame number</source>
          <target state="translated">프레임 번호로 이동</target>
        </trans-unit>
        <trans-unit id="655a25249fc3afadf30872e11fde297b5f337104" translate="yes" xml:space="preserve">
          <source>Jumps to the next frame. Returns &lt;code&gt;true&lt;/code&gt; on success; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">다음 프레임으로 이동합니다. 성공하면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9b6dbdce4a49dcf723a997e645f05e481219eae9" translate="yes" xml:space="preserve">
          <source>Junctions only exist on Windows' NTFS file system, and are typically created by the &lt;code&gt;mklink&lt;/code&gt; command. They can be thought of as symlinks for directories, and can only be created for absolute paths on the local volume.</source>
          <target state="translated">접합은 Windows의 NTFS 파일 시스템에만 존재하며 일반적으로 &lt;code&gt;mklink&lt;/code&gt; 명령 으로 생성됩니다 . 디렉토리에 대한 심볼릭 링크로 생각할 수 있으며 로컬 볼륨의 절대 경로에 대해서만 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d3bf8ead54642447140cf480aafdab86cd43ae8" translate="yes" xml:space="preserve">
          <source>June (5)</source>
          <target state="translated">6 월 (5)</target>
        </trans-unit>
        <trans-unit id="7d1b7fd0adcb63da80c13949feaa0091af9a9769" translate="yes" xml:space="preserve">
          <source>Just a rectangle.</source>
          <target state="translated">그냥 직사각형.</target>
        </trans-unit>
        <trans-unit id="d8604d349b803f6dd95c134d6d32e8e570e69b5c" translate="yes" xml:space="preserve">
          <source>Just as the original image needs to have dimensions that are independently some multiple of 4, each mipmap level that you want to display must also be a multiple of 4. If it is not, you will see rendering artifacts as the mipmap level is displayed.</source>
          <target state="translated">원본 이미지가 독립적으로 4의 배수 인 차원을 가져야하는 것처럼 표시하려는 각 밉맵 레벨도 4의 배수 여야합니다. 그렇지 않은 경우 밉맵 레벨이 표시 될 때 렌더링 아티팩트가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d7dec92c07aefb938bf6d0be9045ab075e5a6ed0" translate="yes" xml:space="preserve">
          <source>Just as with containers, functions are available to examine the history in terms of a list. Arbitrary items in the history can be obtained with &lt;a href=&quot;qwebenginehistory#itemAt&quot;&gt;itemAt&lt;/a&gt;(), the total number of items is given by &lt;a href=&quot;qwebenginehistory#count&quot;&gt;count&lt;/a&gt;(), and the history can be cleared with the &lt;a href=&quot;qwebenginehistory#clear&quot;&gt;clear&lt;/a&gt;() function.</source>
          <target state="translated">컨테이너와 마찬가지로 목록을 통해 히스토리를 검사하는 기능을 사용할 수 있습니다. 히스토리의 임의 항목은 &lt;a href=&quot;qwebenginehistory#itemAt&quot;&gt;itemAt&lt;/a&gt; () 로 얻을 수 있으며 총 항목 수는 &lt;a href=&quot;qwebenginehistory#count&quot;&gt;count&lt;/a&gt; ()로 제공되며 &lt;a href=&quot;qwebenginehistory#clear&quot;&gt;clear&lt;/a&gt; () 함수를 사용하여 히스토리를 지울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6c3ea0fdcc8e567ad9a8f568fb511a7695998b8" translate="yes" xml:space="preserve">
          <source>Just comparing &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; pointers is not always sufficient because two &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; instances that refer to the same native texture object underneath should also be considered equal. Hence this function.</source>
          <target state="translated">동일한 네이티브 텍스처 객체를 참조하는 두 &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; 인스턴스도 동일한 것으로 간주되어야 하므로 &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; 포인터를 비교하는 것만으로 는 충분하지 않습니다 . 따라서이 기능.</target>
        </trans-unit>
        <trans-unit id="51587453949938d86b2e10259b58581776c457aa" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;qmutablelistiterator#remove&quot;&gt;remove()&lt;/a&gt;, &lt;a href=&quot;qmutablelistiterator#setValue&quot;&gt;setValue()&lt;/a&gt; operates on the last item that we jumped over. If we iterate forward, this is the item just before the iterator; if we iterate backward, this is the item just after the iterator.</source>
          <target state="translated">그냥 같은 &lt;a href=&quot;qmutablelistiterator#remove&quot;&gt;제거 ()&lt;/a&gt; , &lt;a href=&quot;qmutablelistiterator#setValue&quot;&gt;의 setValue ()는&lt;/a&gt; 우리가 이상 뛰어 것을 마지막 항목에서 작동합니다. 우리가 앞으로 반복한다면, 이것은 반복기 바로 앞의 항목입니다. 우리가 거꾸로 반복한다면, 이것은 반복자 바로 다음의 항목입니다.</target>
        </trans-unit>
        <trans-unit id="6be7c69206569b9da462887d4bae6893284128e5" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt;, a checkbox displays text, and optionally a small icon. The icon is set with &lt;a href=&quot;qabstractbutton#icon-prop&quot;&gt;setIcon&lt;/a&gt;(). The text can be set in the constructor or with &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;setText&lt;/a&gt;(). A shortcut key can be specified by preceding the preferred character with an ampersand. For example:</source>
          <target state="translated">&lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; 과 마찬가지로 확인란에도 텍스트가 표시되고 선택적으로 작은 아이콘이 표시됩니다. 아이콘은 &lt;a href=&quot;qabstractbutton#icon-prop&quot;&gt;setIcon&lt;/a&gt; ()으로 설정됩니다 . 텍스트는 생성자 또는 &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;setText&lt;/a&gt; ()를 사용하여 설정할 수 있습니다 . 선호하는 문자 앞에 앰퍼샌드를 붙여 단축키를 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba5d275541814d7f5ea1eedbff509a908f48884b" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt;, a radio button displays text, and optionally a small icon. The icon is set with &lt;a href=&quot;qabstractbutton#icon-prop&quot;&gt;setIcon&lt;/a&gt;(). The text can be set in the constructor or with &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;setText&lt;/a&gt;(). A shortcut key can be specified by preceding the preferred character with an ampersand in the text. For example:</source>
          <target state="translated">&lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; 과 마찬가지로 단일 선택 단추는 텍스트 및 선택적으로 작은 아이콘을 표시합니다. 아이콘은 &lt;a href=&quot;qabstractbutton#icon-prop&quot;&gt;setIcon&lt;/a&gt; ()으로 설정됩니다 . 텍스트는 생성자 또는 &lt;a href=&quot;qabstractbutton#text-prop&quot;&gt;setText&lt;/a&gt; ()를 사용하여 설정할 수 있습니다 . 텍스트에서 앰퍼샌드로 선호 문자를 앞에 붙여서 단축키를 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86e49f45b51ecf8d62918e91f3bb0d4ad5adb839" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt;, &lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit&lt;/a&gt; works together with &lt;a href=&quot;qsyntaxhighlighter&quot;&gt;QSyntaxHighlighter&lt;/a&gt;.</source>
          <target state="translated">것처럼 &lt;a href=&quot;qtextedit&quot;&gt;은 QTextEdit&lt;/a&gt; , &lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit는&lt;/a&gt; 함께 작동 &lt;a href=&quot;qsyntaxhighlighter&quot;&gt;QSyntaxHighlighter&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e33443d48650260c1a684afd209ed6fd67d230d" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt;, QPlainTextEdit works together with &lt;a href=&quot;qsyntaxhighlighter&quot;&gt;QSyntaxHighlighter&lt;/a&gt;.</source>
          <target state="translated">것처럼 &lt;a href=&quot;qtextedit&quot;&gt;은 QTextEdit&lt;/a&gt; , QPlainTextEdit는 함께 작동 &lt;a href=&quot;qsyntaxhighlighter&quot;&gt;QSyntaxHighlighter&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c73770321df9c54ac57b4f63b2eb63e3106e88d5" translate="yes" xml:space="preserve">
          <source>Just like in Qt &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;queued connections&lt;/a&gt; and QtRO SIGNALS, parameters in slots that are references will be copied when being passed to Replicas.</source>
          <target state="translated">Qt &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;대기 연결&lt;/a&gt; 및 QtRO SIGNALS에서와 같이 참조 인 슬롯의 매개 변수는 복제본으로 전달 될 때 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="9b89c9a90b9100d05fb4b40a58fcc63f707dfe63" translate="yes" xml:space="preserve">
          <source>Just like in Qt &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;queued connections&lt;/a&gt;, parameters in signals that are references will be copied when being passed to replicas.</source>
          <target state="translated">Qt &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;대기열 연결&lt;/a&gt; 과 마찬가지로 참조 신호의 매개 변수는 복제본으로 전달 될 때 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="00bdee47bb0072a9eb4dcc62d1ee777435ccec00" translate="yes" xml:space="preserve">
          <source>Just like the &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; class, &lt;a href=&quot;qbitmap&quot;&gt;QBitmap&lt;/a&gt; is optimized by the use of implicit data sharing. For more information, see the &lt;a href=&quot;implicit-sharing&quot;&gt;Implicit Data Sharing&lt;/a&gt; documentation.</source>
          <target state="translated">그냥 같은 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap의&lt;/a&gt; 클래스 &lt;a href=&quot;qbitmap&quot;&gt;QBitmap는&lt;/a&gt; 암시 적 데이터 공유를 사용하여 최적화되어 있습니다. 자세한 내용은 &lt;a href=&quot;implicit-sharing&quot;&gt;암시 적 데이터 공유&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2347737917443592ba6958af3a880173ba96aaeb" translate="yes" xml:space="preserve">
          <source>Just like the &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; class, QBitmap is optimized by the use of implicit data sharing. For more information, see the &lt;a href=&quot;implicit-sharing&quot;&gt;Implicit Data Sharing&lt;/a&gt; documentation.</source>
          <target state="translated">그냥 같은 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap의&lt;/a&gt; 클래스 QBitmap는 암시 적 데이터 공유를 사용하여 최적화되어 있습니다. 자세한 내용은 &lt;a href=&quot;implicit-sharing&quot;&gt;암시 적 데이터 공유&lt;/a&gt; 문서를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="75a892052751cf60a007c9616c86088a2fcd371b" translate="yes" xml:space="preserve">
          <source>Just like with &lt;a href=&quot;qml-qtquick-controls2-checkbox&quot;&gt;CheckBox&lt;/a&gt;, do not make the list too large.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-checkbox&quot;&gt;CheckBox&lt;/a&gt; 와 마찬가지로 목록을 너무 크게 만들지 마십시오.</target>
        </trans-unit>
        <trans-unit id="b650bd8ba2e2bfd4f4b7b57fa010894a3e835d8a" translate="yes" xml:space="preserve">
          <source>Just like with menus, entries can be moved around simply by dragging and dropping them in the preferred location. When an entry is dragged over a closed menu, the menu will open to allow it to be inserted there. Since menu entries are based on actions, they can also be dropped onto toolbars, where they will be displayed as toolbar buttons.</source>
          <target state="translated">메뉴와 마찬가지로 항목을 원하는 위치로 끌어서 놓기 만하면 항목을 이동할 수 있습니다. 닫힌 메뉴 위로 항목을 드래그하면 메뉴가 열리고 삽입 할 수 있습니다. 메뉴 항목은 작업을 기반으로하기 때문에 도구 모음에 놓을 수 있으며 도구 모음 단추로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="43b84051703c68abb2853dcbf0e75f395c949395" translate="yes" xml:space="preserve">
          <source>Just remember to declare both namespaces in your &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; and use them properly. Consider the following query, which is meant to generate XHTML output from XML input:</source>
          <target state="translated">&lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 에서 두 네임 스페이스를 모두 선언 하고 올바르게 사용하는 것을 잊지 마십시오. XML 입력에서 XHTML 출력을 생성하기위한 다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="31b6f1839bf3f0dbd76e0d568eac1c01bbe36000" translate="yes" xml:space="preserve">
          <source>Just remember to declare both namespaces in your &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; and use them properly. Consider the following query, which is meant to generate XHTML output from XML input:</source>
          <target state="translated">&lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 에서 두 네임 스페이스를 모두 선언 하고 올바르게 사용 하십시오 . XML 입력에서 XHTML 출력을 생성하기위한 다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="55e9f3d00e6e8b4e481cb8f0d67d8c6d81983c73" translate="yes" xml:space="preserve">
          <source>Just switching &lt;code&gt;device&lt;/code&gt; from &lt;code&gt;/dev/dri/card0&lt;/code&gt; to &lt;code&gt;/dev/dri/renderD128&lt;/code&gt; is futile on its own since there are a number of operations that cannot be performed in headless mode. Therefore, this must be combined with a &lt;code&gt;headless&lt;/code&gt; property, for example:</source>
          <target state="translated">다만 스위칭 &lt;code&gt;device&lt;/code&gt; 로부터 &lt;code&gt;/dev/dri/card0&lt;/code&gt; 행 &lt;code&gt;/dev/dri/renderD128&lt;/code&gt; 헤드리스 모드에서 수행 할 수없는 작업의 수가 있기 때문에 그 자체가 쓸데 IS. 따라서이 속성 은 &lt;code&gt;headless&lt;/code&gt; 속성 과 결합해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c739d2b50da58969f675cecb428cd022114f5b7" translate="yes" xml:space="preserve">
          <source>Just this simple change results in a significant performance improvement. Note that the code above can be improved even further (since the property being looked up never changes during the loop processing), by hoisting the property resolution out of the loop, as follows:</source>
          <target state="translated">이 간단한 변경만으로도 성능이 크게 향상됩니다. 다음 코드는 루프에서 속성 해상도를 올리면 다음과 같이 루프 처리 중에 조회되는 속성이 변경되지 않으므로 위의 코드를 훨씬 더 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93b078c606546ab60c75906d702910e0eb275c1f" translate="yes" xml:space="preserve">
          <source>Justifies the text in the available space.</source>
          <target state="translated">사용 가능한 공간에서 텍스트를 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="f81d3f9e0315c68aba07d516e4e91aab8a3598bf" translate="yes" xml:space="preserve">
          <source>KDAB has published a few articles about writing custom Qt3D aspects &lt;a href=&quot;https://www.kdab.com/writing-custom-qt-3d-aspect/&quot;&gt;on their blog&lt;/a&gt;. These provide an excellent starting point if you wish to learn more about it.</source>
          <target state="translated">KDAB는 &lt;a href=&quot;https://www.kdab.com/writing-custom-qt-3d-aspect/&quot;&gt;블로그에&lt;/a&gt; 커스텀 Qt3D 측면 을 작성하는 방법에 대한 몇 가지 기사를 발표했습니다 . 이것들은 당신이 그것에 대해 더 배우고 싶다면 훌륭한 출발점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="30ab77b10e3d2349c826da7577449422c34c63f9" translate="yes" xml:space="preserve">
          <source>KDE Plasma</source>
          <target state="translated">KDE 플라즈마</target>
        </trans-unit>
        <trans-unit id="8294464808d7a7d1c318247b5b133e6a7079d8d6" translate="yes" xml:space="preserve">
          <source>KMS/DRM can be used with two different DRM APIs which are</source>
          <target state="translated">KMS / DRM은 두 가지 다른 DRM API와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b88dae842421fa69ad059376e38f360417c6965" translate="yes" xml:space="preserve">
          <source>KOI8-R</source>
          <target state="translated">KOI8-R</target>
        </trans-unit>
        <trans-unit id="ad190609bef1a0712934b8949ffb7c06fbaa6862" translate="yes" xml:space="preserve">
          <source>KOI8-U</source>
          <target state="translated">KOI8-U</target>
        </trans-unit>
        <trans-unit id="c3ed665577f91f82c451742a0c8875950d42b19f" translate="yes" xml:space="preserve">
          <source>Kannada</source>
          <target state="translated">Kannada</target>
        </trans-unit>
        <trans-unit id="e3c128f4ad2ca3bc64b45aa7c0df1d580d728b4a" translate="yes" xml:space="preserve">
          <source>Katakana input mode for Japanese.</source>
          <target state="translated">일본어 카타카나 입력 모드.</target>
        </trans-unit>
        <trans-unit id="b9fedaa07b209e1f7a9c2d83295a76fe49f3b49f" translate="yes" xml:space="preserve">
          <source>Kazakh</source>
          <target state="translated">Kazakh</target>
        </trans-unit>
        <trans-unit id="f0cbda73663704a100a0cec6f9a0cde16768434e" translate="yes" xml:space="preserve">
          <source>KdeLayout</source>
          <target state="translated">KdeLayout</target>
        </trans-unit>
        <trans-unit id="7177d1fea1ceb58b671888e3e12e41344fb35828" translate="yes" xml:space="preserve">
          <source>Keep current stencil value.</source>
          <target state="translated">현재 스텐실 값을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="c83a09750088b812b1abdcaa7c9d65f2ce2b9ce2" translate="yes" xml:space="preserve">
          <source>Keep in mind that if you are using custom materials and shaders, you need to specify the correct sampler type to be used.</source>
          <target state="translated">사용자 정의 재질 및 셰이더를 사용하는 경우 사용할 올바른 샘플러 유형을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="95b3cc3149aa3ce12278c6b3b54c967325c21e79" translate="yes" xml:space="preserve">
          <source>Keep in mind that the returned states are the ones that have changed. To find out about the state of an object, use &lt;a href=&quot;qaccessibleinterface#state&quot;&gt;QAccessibleInterface::state&lt;/a&gt;().</source>
          <target state="translated">반환 된 상태는 변경된 상태입니다. 오브젝트의 상태에 대해 알려면 &lt;a href=&quot;qaccessibleinterface#state&quot;&gt;QAccessibleInterface :: state&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f4e568488acef8435eabfa98da71dd2b492f1392" translate="yes" xml:space="preserve">
          <source>Keep in mind that when reimplementing this function and calling &lt;a href=&quot;qgraphicsitem#shape&quot;&gt;shape&lt;/a&gt;() or &lt;a href=&quot;qgraphicsitem#boundingRect&quot;&gt;boundingRect&lt;/a&gt;() on</source>
          <target state="translated">이 함수를 다시 구현하고 호출 할 때 &lt;a href=&quot;qgraphicsitem#shape&quot;&gt;shape&lt;/a&gt; () 또는 &lt;a href=&quot;qgraphicsitem#boundingRect&quot;&gt;boundingRect&lt;/a&gt; ()를 호출 할 때</target>
        </trans-unit>
        <trans-unit id="6e49960d4110ed8cd9f20199cdc9778a6ea54225" translate="yes" xml:space="preserve">
          <source>Keep in mind that windows are still sized to match the - now virtual - screen size, hence the need for specifying a size in the &lt;code&gt;headless&lt;/code&gt; property. There is also a lack of vsync-based throttling.</source>
          <target state="translated">창은 여전히 ​​가상 화면 크기와 일치하도록 크기가 조정되므로 &lt;code&gt;headless&lt;/code&gt; 속성 에서 크기를 지정해야 합니다. vsync 기반 스로틀 링도 부족합니다.</target>
        </trans-unit>
        <trans-unit id="ba52aff053c85db905df6c0b1d4a5af051cbda41" translate="yes" xml:space="preserve">
          <source>Keep labels short and concise.</source>
          <target state="translated">라벨을 짧고 간결하게 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="9c4ebe0980a260fa0babdbdf3f4f6cd7464e740d" translate="yes" xml:space="preserve">
          <source>Keep the cursor where it is</source>
          <target state="translated">커서를 원래 위치에 유지하십시오</target>
        </trans-unit>
        <trans-unit id="3848158b25918bc1765271df1f56121dc585a01a" translate="yes" xml:space="preserve">
          <source>Keep the following limitations in mind:</source>
          <target state="translated">다음 제한 사항에 유의하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
