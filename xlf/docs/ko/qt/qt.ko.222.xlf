<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="06bc0d75a53caf819c54e1c7ccb9a39a114cde99" translate="yes" xml:space="preserve">
          <source>The returned string may be the same as the argument on some operating systems, for example on Unix.</source>
          <target state="translated">리턴 된 문자열은 일부 운영 체제 (예 : Unix)의 인수와 동일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a2115840f428cdcb25490cda081f657ca220992" translate="yes" xml:space="preserve">
          <source>The returned structure's &lt;a href=&quot;qcalendar#isValid&quot;&gt;isValid&lt;/a&gt;() shall be false if the calendar is unable to represent the given</source>
          <target state="translated">The returned structure's &lt;a href=&quot;qcalendar#isValid&quot;&gt;isValid&lt;/a&gt;() shall be false if the calendar is unable to represent the given</target>
        </trans-unit>
        <trans-unit id="ec298240d345b2f32419052868e727985dc41b7a" translate="yes" xml:space="preserve">
          <source>The returned text does not include any rich text formatting.</source>
          <target state="translated">반환 된 텍스트에는 서식있는 텍스트 형식이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85aab7e47cbf17ad99121f384d45709b912a8044" translate="yes" xml:space="preserve">
          <source>The returned text will be formatted according the &lt;a href=&quot;qml-qtquick-textedit#textFormat-prop&quot;&gt;textFormat&lt;/a&gt; property.</source>
          <target state="translated">반환 된 텍스트는 &lt;a href=&quot;qml-qtquick-textedit#textFormat-prop&quot;&gt;textFormat&lt;/a&gt; 속성 에 따라 서식이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="76c765fe8bf5697d108a758ed993984c4d224647" translate="yes" xml:space="preserve">
          <source>The returned text will be formatted according to the &lt;a href=&quot;qml-qtquick-controls-textarea#textFormat-prop&quot;&gt;textFormat&lt;/a&gt; property.</source>
          <target state="translated">반환 된 텍스트는 &lt;a href=&quot;qml-qtquick-controls-textarea#textFormat-prop&quot;&gt;textFormat&lt;/a&gt; 에 따라 서식이 지정됩니다 속성 .</target>
        </trans-unit>
        <trans-unit id="cae2d3a314122edb530e1618f3b65f7ea8121672" translate="yes" xml:space="preserve">
          <source>The returned texture is owned by the buffer. The texture is only valid for as long as the buffer reference exists. The caller of this function must not delete the texture, and must keep a reference to the buffer for as long as the texture is being used.</source>
          <target state="translated">반환 된 텍스처는 버퍼가 소유합니다. 텍스처는 버퍼 참조가 존재하는 한 유효합니다. 이 함수의 호출자는 텍스처를 삭제하지 않아야하며 텍스처가 사용되는 동안 버퍼에 대한 참조를 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="bdd3ea43c1f60c3d3037c81e0061b2ebc558ca98" translate="yes" xml:space="preserve">
          <source>The returned texture will be using &lt;code&gt;GL_TEXTURE_2D&lt;/code&gt; as texture target and assumes that internal format is &lt;code&gt;GL_RGBA&lt;/code&gt;. Reimplement &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; to create textures with different parameters.</source>
          <target state="translated">반환 된 텍스처는 &lt;code&gt;GL_TEXTURE_2D&lt;/code&gt; 를 텍스처 대상 으로 사용 하며 내부 형식이 &lt;code&gt;GL_RGBA&lt;/code&gt; 라고 가정합니다 . &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; 를 다시 구현 하여 다른 매개 변수로 텍스처를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="aa1b90873bdb6d53a77bda69570c53d8cd82e89b" translate="yes" xml:space="preserve">
          <source>The returned value doesn't include the space required by &lt;a href=&quot;qwidget#setContentsMargins&quot;&gt;QWidget::setContentsMargins&lt;/a&gt;() or &lt;a href=&quot;qlayout#menuBar&quot;&gt;menuBar&lt;/a&gt;().</source>
          <target state="translated">반환 된 값에는 &lt;a href=&quot;qwidget#setContentsMargins&quot;&gt;QWidget :: setContentsMargins&lt;/a&gt; () 또는 &lt;a href=&quot;qlayout#menuBar&quot;&gt;menuBar&lt;/a&gt; ()에 필요한 공간이 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="92b5d6c220a31650c82bd7d4356451241e4aa90f" translate="yes" xml:space="preserve">
          <source>The returned value is composed of three or more parts, separated by dashes (&quot;-&quot;). They are:</source>
          <target state="translated">반환 된 값은 대시 ( &quot;-&quot;)로 구분 된 세 개 이상의 부분으로 구성됩니다. 그들은:</target>
        </trans-unit>
        <trans-unit id="d2749e92ce3e83af127167920f4f0933bd5c82dd" translate="yes" xml:space="preserve">
          <source>The returned value is undefined if one of the two parameters is invalid and the other isn't. However, two invalid timers are equal and thus this function will return false.</source>
          <target state="translated">두 매개 변수 중 하나가 유효하지 않고 다른 매개 변수가 유효하지 않으면 리턴 값이 정의되지 않습니다. 그러나 두 개의 유효하지 않은 타이머는 동일하므로이 함수는 false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b7d80460f267bb240ad59a28b850047c50297f71" translate="yes" xml:space="preserve">
          <source>The returned value may be different tha passed to &lt;a href=&quot;qaudioencodersettingscontrol#setAudioSettings&quot;&gt;QAudioEncoderSettingsControl::setAudioSettings&lt;/a&gt;() if the settings contains the default or undefined parameters. In this case if the undefined parameters are already resolved, they should be returned.</source>
          <target state="translated">설정에 기본 또는 정의되지 않은 매개 변수가 포함되어 있으면 반환 된 값이 &lt;a href=&quot;qaudioencodersettingscontrol#setAudioSettings&quot;&gt;QAudioEncoderSettingsControl :: setAudioSettings&lt;/a&gt; ()에 전달 될 수 있습니다 . 이 경우 정의되지 않은 매개 변수가 이미 해결 된 경우 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4ffb99b27c80a3b3e670145b72c691fb3de8d48" translate="yes" xml:space="preserve">
          <source>The returned value may be different tha passed to &lt;a href=&quot;qimageencodercontrol#setImageSettings&quot;&gt;QImageEncoderControl::setImageSettings&lt;/a&gt;() if the settings contains the default or undefined parameters. In this case if the undefined parameters are already resolved, they should be returned.</source>
          <target state="translated">설정에 기본 또는 정의되지 않은 매개 변수가 포함되어 있으면 반환 된 값이 &lt;a href=&quot;qimageencodercontrol#setImageSettings&quot;&gt;QImageEncoderControl :: setImageSettings&lt;/a&gt; ()에 전달 될 수 있습니다 . 이 경우 정의되지 않은 매개 변수가 이미 해결 된 경우 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="2ef4c4ba6cc867089192da80f9dd3bab60e509a2" translate="yes" xml:space="preserve">
          <source>The returned value may be different tha passed to &lt;a href=&quot;qvideoencodersettingscontrol#setVideoSettings&quot;&gt;QVideoEncoderSettingsControl::setVideoSettings&lt;/a&gt;() if the settings contains the default or undefined parameters. In this case if the undefined parameters are already resolved, they should be returned.</source>
          <target state="translated">설정에 기본 또는 정의되지 않은 매개 변수가 포함되어 있으면 반환 된 값이 &lt;a href=&quot;qvideoencodersettingscontrol#setVideoSettings&quot;&gt;QVideoEncoderSettingsControl :: setVideoSettings&lt;/a&gt; ()에 전달 될 수 있습니다 . 이 경우 정의되지 않은 매개 변수가 이미 해결 된 경우 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="58554ce03cad12c62c51fe46c16c2038d24024a0" translate="yes" xml:space="preserve">
          <source>The returned value may be partially complete and indistinguishable from a valid &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; even if the decoding failed. To determine if there was an error, check if &lt;a href=&quot;qcborstreamreader#lastError&quot;&gt;reader.lastError()&lt;/a&gt; is indicating an error condition. This function stops decoding immediately after the first error.</source>
          <target state="translated">리턴 된 값은 디코딩에 실패한 경우에도 부분적으로 완전하고 유효한 &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; 와 구별 할 수 없습니다 . 오류가 있는지 확인하려면 &lt;a href=&quot;qcborstreamreader#lastError&quot;&gt;reader.lastError ()&lt;/a&gt; 가 오류 조건을 나타내는 지 확인하십시오 . 이 기능은 첫 번째 오류 직후 디코딩을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="2efcf7382ef3f359faf0d74358cfabd999c1fe99" translate="yes" xml:space="preserve">
          <source>The returned value may be partially complete and indistinguishable from a valid &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; even if the decoding failed. To determine if there was an error, check if there was an error stored in</source>
          <target state="translated">리턴 된 값은 디코딩에 실패한 경우에도 부분적으로 완전하고 유효한 &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; 와 구별 할 수 없습니다 . 오류가 있는지 확인하려면에 저장된 오류가 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2c7f2c920201f8e2c60e32df874828cb8f50db00" translate="yes" xml:space="preserve">
          <source>The returned value represents the number of degrees you need to add to this line to make it have the same angle as the given</source>
          <target state="translated">반환 된 값은 주어진 각도와 동일하게하기 위해이 선에 추가해야하는 각도를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a33601549f3f84d9339ce6ecb91108f48617fe0c" translate="yes" xml:space="preserve">
          <source>The returned variant will be a &lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList&lt;/a&gt; if the document is a &lt;a href=&quot;qjsonarray&quot;&gt;QJsonArray&lt;/a&gt; and a &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; if the document is a &lt;a href=&quot;qjsonobject&quot;&gt;QJsonObject&lt;/a&gt;.</source>
          <target state="translated">반환 변형이 될 것입니다 &lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList&lt;/a&gt; 문서가있는 경우 &lt;a href=&quot;qjsonarray&quot;&gt;QJsonArray&lt;/a&gt; 과 &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; 문서가있는 경우 &lt;a href=&quot;qjsonobject&quot;&gt;QJsonObject&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0af865e3a948efd9dc6e35fa5a5bff608faaabf0" translate="yes" xml:space="preserve">
          <source>The returned vector is not 0-terminated.</source>
          <target state="translated">반환 된 벡터는 0으로 끝나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6150585925edba6ac47ef98178ebe6ac8cc02fff" translate="yes" xml:space="preserve">
          <source>The returned vector is not \0'-terminated.</source>
          <target state="translated">반환 된 벡터는 \ 0'- 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a948af41ddaa8afb2808830abd79dd74e26c219" translate="yes" xml:space="preserve">
          <source>The returned vector of namespace declarations includes namespaces of the ancestors of</source>
          <target state="translated">반환 된 네임 스페이스 선언 벡터에는 조상의 네임 스페이스가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="77f0cc49cdc738436a61c4b64e42c2948c9f579e" translate="yes" xml:space="preserve">
          <source>The reverse axis is supported with a line, spline, and scatter series, as well as an area series with a cartesian chart. All axes of the same orientation attached to the same series must be reversed if one is reversed or the behavior is undefined.</source>
          <target state="translated">역축은 직교 차트가있는 영역 계열뿐만 아니라 선, 스플라인 및 분산 계열로 지원됩니다. 동일한 시리즈에 연결된 동일한 방향의 모든 축은 반전되거나 동작이 정의되지 않은 경우 반전되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7414d8a8805ed289f32a0472c2479dbb9bc262d5" translate="yes" xml:space="preserve">
          <source>The reverseProxy() function allows the &lt;a href=&quot;qremoteobjecthostbase#proxy&quot;&gt;proxy&lt;/a&gt;() functionality to be extended, in effect mirroring the proxy functionality in the &quot;reverse&quot; direction. These are distinct, because node communication is not symmetric, one side calls &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;enableRemoting&lt;/a&gt;() with a &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; object, the other side calls &lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;acquire&lt;/a&gt;() to get a &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt;. Using &lt;a href=&quot;qremoteobjecthostbase#proxy&quot;&gt;proxy&lt;/a&gt;() allows you to &quot;observe&quot; objects on a target device remotely via acquire, but it does not allow off-target &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; objects to be acquired from the device's local:* network. That is where reverseProxy() comes in. If a proxyNode is created like so:</source>
          <target state="translated">reverseProxy () 함수를 사용하면 &lt;a href=&quot;qremoteobjecthostbase#proxy&quot;&gt;프록시&lt;/a&gt; 기능을 &quot;역방향&quot;방향으로 미러링하여 프록시 기능을 확장 할 수 있습니다. 노드 통신은 대칭이 아니기 때문에 한 쪽 은 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; 객체를 사용하여 &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;enableRemoting&lt;/a&gt; ()을 호출하고 다른 쪽 은 &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; 를 얻기 &lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;위해 획득&lt;/a&gt; ()을 호출합니다 . 사용 &lt;a href=&quot;qremoteobjecthostbase#proxy&quot;&gt;프록시은&lt;/a&gt; () 원격 획득을 통해 대상 장치의 개체를 &quot;관찰&quot;할 수 있지만, 그것은 대상의 오프 허용하지 않는 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;소스&lt;/a&gt; 장치의 지역에서 취득 할 객체 : * 네트워크를. 여기에서 reverseProxy ()가 온다. proxyNode가 다음과 같이 생성되면 :</target>
        </trans-unit>
        <trans-unit id="b1abba55cbe6b589efac7f7cb1237a75b5af8472" translate="yes" xml:space="preserve">
          <source>The review's textual description of the place. It can be either rich (HTML based) text or plain text depending on the provider.</source>
          <target state="translated">장소에 대한 리뷰의 텍스트 설명. 공급자에 따라 서식있는 (HTML 기반) 텍스트 또는 일반 텍스트 일 ​​수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5877bb7986e1da8e8d542807a4ed0f6d17268ab6" translate="yes" xml:space="preserve">
          <source>The revision is guaranteed to increase when a document that is not modified is edited.</source>
          <target state="translated">수정되지 않은 문서를 편집하면 개정판이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="73f27df1ba01456ace9b5465c0de98dad6294789" translate="yes" xml:space="preserve">
          <source>The revisions given this way are automatically interpreted as minor versions to the major version given in the project file. In this case, &lt;code&gt;root&lt;/code&gt; is only available when &lt;code&gt;MyTypes&lt;/code&gt; version 1.1 or higher is imported. Imports of &lt;code&gt;MyTypes&lt;/code&gt; version 1.0 remain unaffected.</source>
          <target state="translated">The revisions given this way are automatically interpreted as minor versions to the major version given in the project file. In this case, &lt;code&gt;root&lt;/code&gt; is only available when &lt;code&gt;MyTypes&lt;/code&gt; version 1.1 or higher is imported. Imports of &lt;code&gt;MyTypes&lt;/code&gt; version 1.0 remain unaffected.</target>
        </trans-unit>
        <trans-unit id="9e1534274eee65bbfbe8885a9db6d8c82a8a147e" translate="yes" xml:space="preserve">
          <source>The rich content of a place consists of items such as images, reviews and editorials. Potentially there may be many rich content items, so they are treated separately from the place details. They can be retrieved in a paged fashion via &lt;a href=&quot;qplacemanager#getPlaceContent&quot;&gt;QPlaceManager::getPlaceContent&lt;/a&gt;(). If necessary, the content may be assigned to a place so it can act as a convenient container.</source>
          <target state="translated">장소의 풍부한 콘텐츠는 이미지, 리뷰 및 편집과 같은 항목으로 구성됩니다. 리치 콘텐츠 항목이 많을 수 있으므로 장소 세부 정보와 별도로 처리됩니다. &lt;a href=&quot;qplacemanager#getPlaceContent&quot;&gt;QPlaceManager :: getPlaceContent&lt;/a&gt; () 를 통해 페이지 방식으로 검색 할 수 있습니다 . 필요한 경우 컨텐츠를 장소에 할당하여 편리한 컨테이너 역할을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6e644f6c802eab0141c6c7079b36bcd4364d61c" translate="yes" xml:space="preserve">
          <source>The rich content of a place is typically made available as paginated items. The ability to convert between &lt;a href=&quot;qplacecontent&quot;&gt;QPlaceContent&lt;/a&gt; and it's subclasses means that code which handles the mechanics of paging can be easily shared for each of the sub types.</source>
          <target state="translated">장소의 풍부한 콘텐츠는 일반적으로 페이지 매김 항목으로 제공됩니다. &lt;a href=&quot;qplacecontent&quot;&gt;QPlaceContent&lt;/a&gt; 간 변환 기능 와 서브 클래스 은 페이징 메커니즘을 처리하는 코드를 각 서브 타입마다 쉽게 공유 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3f3ecea6f9ca7ce0cd98fb7876888df82d6074aa" translate="yes" xml:space="preserve">
          <source>The rich content of a place is typically made available as paginated items. The ability to convert between QPlaceContent and it's subclasses means that code which handles the mechanics of paging can be easily shared for each of the sub types.</source>
          <target state="translated">The rich content of a place is typically made available as paginated items. The ability to convert between QPlaceContent and it's subclasses means that code which handles the mechanics of paging can be easily shared for each of the sub types.</target>
        </trans-unit>
        <trans-unit id="71eeb7940a77134ba7eb42717b1d1a828cfde341" translate="yes" xml:space="preserve">
          <source>The rich text support in Qt is designed to provide a fast, portable and efficient way to add reasonable online help facilities to applications, and to provide a basis for rich text editors. If you find the HTML support insufficient for your needs you may consider the use of Qt WebKit, which provides a full-featured web browser widget.</source>
          <target state="translated">Qt의 서식있는 텍스트 지원은 응용 프로그램에 합리적인 온라인 도움말 기능을 추가하고 서식있는 텍스트 편집기를위한 기반을 제공하는 빠르고 이식 가능하며 효율적인 방법을 제공하도록 설계되었습니다. 필요에 따라 HTML 지원이 충분하지 않다면 완전한 기능을 갖춘 웹 브라우저 위젯을 제공하는 Qt WebKit의 사용을 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99dd693df8cb2af02ac6bf5eed9c5017104f1e26" translate="yes" xml:space="preserve">
          <source>The right arrow of a &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; or a &lt;a href=&quot;qscrollbar&quot;&gt;QScrollBar&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; 또는 &lt;a href=&quot;qscrollbar&quot;&gt;QScrollBar&lt;/a&gt; 의 오른쪽 화살표 .</target>
        </trans-unit>
        <trans-unit id="bbe4888899b155059df33d4328c7fa791225d6fa" translate="yes" xml:space="preserve">
          <source>The right bearing is the left-ward distance of the right-most pixel of the character from the logical origin of a subsequent character. This value is negative if the pixels of the character extend to the right of the &lt;a href=&quot;qfontmetrics#horizontalAdvance&quot;&gt;horizontalAdvance&lt;/a&gt;() of the character.</source>
          <target state="translated">The right bearing is the left-ward distance of the right-most pixel of the character from the logical origin of a subsequent character. This value is negative if the pixels of the character extend to the right of the &lt;a href=&quot;qfontmetrics#horizontalAdvance&quot;&gt;horizontalAdvance&lt;/a&gt;() of the character.</target>
        </trans-unit>
        <trans-unit id="696a508cc12afec9ed037211110478cea7143305" translate="yes" xml:space="preserve">
          <source>The right bearing is the left-ward distance of the right-most pixel of the character from the logical origin of a subsequent character. This value is negative if the pixels of the character extend to the right of the &lt;a href=&quot;qfontmetricsf#horizontalAdvance&quot;&gt;horizontalAdvance&lt;/a&gt;() of the character.</source>
          <target state="translated">The right bearing is the left-ward distance of the right-most pixel of the character from the logical origin of a subsequent character. This value is negative if the pixels of the character extend to the right of the &lt;a href=&quot;qfontmetricsf#horizontalAdvance&quot;&gt;horizontalAdvance&lt;/a&gt;() of the character.</target>
        </trans-unit>
        <trans-unit id="e93c6651e86eeefd3b1aad37e751cd59c753512c" translate="yes" xml:space="preserve">
          <source>The right bearing is the left-ward distance of the right-most pixel of the character from the logical origin of a subsequent character. This value is negative if the pixels of the character extend to the right of the width() of the character.</source>
          <target state="translated">오른쪽 방위는 후속 문자의 논리적 원점에서 문자의 가장 오른쪽 픽셀의 왼쪽 거리입니다. 문자의 픽셀이 문자의 width () 오른쪽으로 확장되면이 값은 음수입니다.</target>
        </trans-unit>
        <trans-unit id="ab2f8184239b88ea372c16f97f3223af4e1db729" translate="yes" xml:space="preserve">
          <source>The right button.</source>
          <target state="translated">오른쪽 버튼.</target>
        </trans-unit>
        <trans-unit id="c92d452ac412145262ffd0388a1b63087c1265bb" translate="yes" xml:space="preserve">
          <source>The right corner of a &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt;. For example, this control can be used to control the position the right corner widget in a &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; 의 오른쪽 모서리입니다 . 예를 &lt;a href=&quot;qtabwidget&quot;&gt;들어이&lt;/a&gt; 컨트롤을 사용하여 QTabWidget 의 오른쪽 모서리 위젯 위치를 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2641ce700fce54c0d0787283d24ebfa8378917e" translate="yes" xml:space="preserve">
          <source>The right delegate sits behind both &lt;a href=&quot;qml-qtquick-controls2-control#contentItem-prop&quot;&gt;contentItem&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-control#background-prop&quot;&gt;background&lt;/a&gt;. When the &lt;a href=&quot;qml-qtquick-controls2-swipedelegate&quot;&gt;SwipeDelegate&lt;/a&gt; is swiped to the left, this item will be gradually revealed.</source>
          <target state="translated">올바른 대리자는 &lt;a href=&quot;qml-qtquick-controls2-control#contentItem-prop&quot;&gt;contentItem&lt;/a&gt; 과 &lt;a href=&quot;qml-qtquick-controls2-control#background-prop&quot;&gt;background&lt;/a&gt; 뒤에 있습니다 . 때 &lt;a href=&quot;qml-qtquick-controls2-swipedelegate&quot;&gt;SwipeDelegate가&lt;/a&gt; 왼쪽으로 슬쩍되고,이 항목은 점차적으로 공개됩니다.</target>
        </trans-unit>
        <trans-unit id="6c3403d5fa0600fadf7ededcfcf6e8fb2fea832c" translate="yes" xml:space="preserve">
          <source>The right edge of the rectangle.</source>
          <target state="translated">사각형의 오른쪽 가장자리.</target>
        </trans-unit>
        <trans-unit id="d4a32f07aa5b04eb7a1cb80910fe44194e474029" translate="yes" xml:space="preserve">
          <source>The right edge of the window.</source>
          <target state="translated">창의 오른쪽 가장자리.</target>
        </trans-unit>
        <trans-unit id="e386084f091469109bde274f36109c53f659a146" translate="yes" xml:space="preserve">
          <source>The right edge.</source>
          <target state="translated">오른쪽 가장자리.</target>
        </trans-unit>
        <trans-unit id="ac9a398d2ac0d569742c133794702a43ee789d4e" translate="yes" xml:space="preserve">
          <source>The right glass frame margin. The default value is 0.</source>
          <target state="translated">오른쪽 유리 프레임 여백. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="4d9a8067fbe8080e2b12cd869da8957f073f8d60" translate="yes" xml:space="preserve">
          <source>The right margin.</source>
          <target state="translated">오른쪽 여백.</target>
        </trans-unit>
        <trans-unit id="3354152f4889baa8bfb0c866a1ec6aef216a05b2" translate="yes" xml:space="preserve">
          <source>The right most point of the vertical middle.</source>
          <target state="translated">수직 가운데 가장 오른쪽 지점.</target>
        </trans-unit>
        <trans-unit id="c04776204563369c3b69dbe2150d3fb4fbc6e507" translate="yes" xml:space="preserve">
          <source>The right side of a layout item.</source>
          <target state="translated">레이아웃 항목의 오른쪽</target>
        </trans-unit>
        <trans-unit id="eb6cae6d8142ad3c3f64738347654364ceaa7dd5" translate="yes" xml:space="preserve">
          <source>The right way is to create an instance of the derived class:</source>
          <target state="translated">올바른 방법은 파생 클래스의 인스턴스를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="441e73b39cd43aafcb464a4e90ad52d8d6a2b6c1" translate="yes" xml:space="preserve">
          <source>The right widget has the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_OpaquePaintEvent&lt;/a&gt; widget attribute set. This indicates that the widget will paint over its entire area with opaque colors. The widget's area will initially be</source>
          <target state="translated">오른쪽 위젯에는 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_OpaquePaintEvent&lt;/a&gt; 위젯 속성이 설정되어 있습니다. 이는 위젯이 전체 영역에 불투명 한 색상으로 페인트됨을 나타냅니다. 위젯 영역은 처음에</target>
        </trans-unit>
        <trans-unit id="431a5e0146296e30ca06fcca1492132bb2e6d70c" translate="yes" xml:space="preserve">
          <source>The role function should be reimplemented by all objects and describes the role of themselves and the children that do not provide accessible interfaces of their own.</source>
          <target state="translated">역할 기능은 모든 개체에 의해 다시 구현되어야하며 자신과 자신의 액세스 가능한 인터페이스를 제공하지 않는 자식의 역할을 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="f25dcf2aed1f16755548c0d9c63ff19306457664" translate="yes" xml:space="preserve">
          <source>The role indicates to the model which type of data is being referred to. Views can display the roles in different ways, so it is important to supply appropriate information for each role.</source>
          <target state="translated">역할은 참조되는 데이터 유형을 모델에 나타냅니다. 보기는 역할을 다른 방식으로 표시 할 수 있으므로 각 역할에 적절한 정보를 제공하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="22dec828a70c5c36f888ad8e68e1c2784f20c64f" translate="yes" xml:space="preserve">
          <source>The role is determined when constructing a &lt;a href=&quot;qlowenergycontroller&quot;&gt;QLowEnergyController&lt;/a&gt; instance using &lt;a href=&quot;qlowenergycontroller#createCentral&quot;&gt;createCentral&lt;/a&gt;() or &lt;a href=&quot;qlowenergycontroller#createPeripheral&quot;&gt;createPeripheral&lt;/a&gt;().</source>
          <target state="translated">구성 할 때 역할 판정 &lt;a href=&quot;qlowenergycontroller&quot;&gt;QLowEnergyController의&lt;/a&gt; 사용 예 &lt;a href=&quot;qlowenergycontroller#createCentral&quot;&gt;createCentral&lt;/a&gt; () 또는 &lt;a href=&quot;qlowenergycontroller#createPeripheral&quot;&gt;createPeripheral을&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="1ab83c42aa70dfc3f178a6450077f3c72fd75b45" translate="yes" xml:space="preserve">
          <source>The role is specified by &lt;a href=&quot;qmediaplayer#customAudioRole-prop&quot;&gt;QMediaPlayer::customAudioRole&lt;/a&gt;()</source>
          <target state="translated">역할은 &lt;a href=&quot;qmediaplayer#customAudioRole-prop&quot;&gt;QMediaPlayer :: customAudioRole&lt;/a&gt; ()에 의해 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="fff3a85dff21eb0434f1c01b0212dd6bb375b376" translate="yes" xml:space="preserve">
          <source>The role is undefined in this mode.</source>
          <target state="translated">이 모드에서는 역할이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de4dabc4aceec7a17dcad6f32bd3dec87320c866" translate="yes" xml:space="preserve">
          <source>The role is unknown or undefined</source>
          <target state="translated">알 수 없거나 정의되지 않은 역할</target>
        </trans-unit>
        <trans-unit id="f0667f0a1daba245040e5da6bdf7fc33120c1639" translate="yes" xml:space="preserve">
          <source>The role names are used by delegates to obtain data from list elements. Each role name is accessible in the delegate's scope, and refers to the corresponding role in the current element. Where a role name would be ambiguous to use, it can be accessed via the &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;model&lt;/a&gt; property (e.g., &lt;code&gt;model.cost&lt;/code&gt; instead of &lt;code&gt;cost&lt;/code&gt;).</source>
          <target state="translated">역할 이름은 목록 요소에서 데이터를 얻기 위해 대리자가 사용합니다. 각 역할 이름은 대리인의 범위에서 액세스 할 수 있으며 현재 요소의 해당 역할을 나타냅니다. 역할 이름이 사용하기 모호 할 것입니다 경우, 그것은을 통해 액세스 할 수 있습니다 &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;모델의&lt;/a&gt; 특성 (예를 들어, &lt;code&gt;model.cost&lt;/code&gt; 대신 &lt;code&gt;cost&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5bf01b6e821bbd1f2d972f3ecfe679ea232eaefd" translate="yes" xml:space="preserve">
          <source>The roles of a &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass can be exposed to QML by reimplementing &lt;a href=&quot;qabstractitemmodel#roleNames&quot;&gt;QAbstractItemModel::roleNames&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 서브 클래스 의 역할은 &lt;a href=&quot;qabstractitemmodel#roleNames&quot;&gt;QAbstractItemModel :: roleNames&lt;/a&gt; 를 다시 구현하여 QML에 노출 될 수 있습니다. ()를 .</target>
        </trans-unit>
        <trans-unit id="55e22341648579319a1b15f2cc8a254db24cb0bb" translate="yes" xml:space="preserve">
          <source>The roles to make available for this model.</source>
          <target state="translated">이 모델에 사용 가능한 역할.</target>
        </trans-unit>
        <trans-unit id="61dce86b73d6f7898af5753b8cd2cf219fee9fa6" translate="yes" xml:space="preserve">
          <source>The root component, returned by this function, is not deleted when the &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; is destroyed. If you want to ensure that the root component is deleted, you should call &lt;a href=&quot;qpluginloader#unload&quot;&gt;unload&lt;/a&gt;() as soon you don't need to access the core component anymore. When the library is finally unloaded, the root component will automatically be deleted.</source>
          <target state="translated">이 함수에 의해 리턴 된 루트 구성 요소는 &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; 가 제거 될 때 삭제되지 않습니다 . 루트 구성 요소가 삭제 되도록하려면 더 이상 코어 구성 요소에 액세스 할 필요가없는 즉시 &lt;a href=&quot;qpluginloader#unload&quot;&gt;unload&lt;/a&gt; ()를 호출 해야합니다. 라이브러리가 마지막으로 언로드되면 루트 구성 요소가 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="ef4b85aba7adbfe8baa6a403ff1df394d696f7e0" translate="yes" xml:space="preserve">
          <source>The root context is automatically created by the &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt;. Data that should be available to all QML component instances instantiated by the engine should be put in the root context.</source>
          <target state="translated">루트 컨텍스트는 &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine에&lt;/a&gt; 의해 자동으로 작성됩니다 . 엔진이 인스턴스화 한 모든 QML 구성 요소 인스턴스에 사용 가능한 데이터는 루트 컨텍스트에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ce8fa64e8b6c10e17e3291f44e3c277035bfed53" translate="yes" xml:space="preserve">
          <source>The root directory</source>
          <target state="translated">루트 디렉토리</target>
        </trans-unit>
        <trans-unit id="10715cc533b45902fae92f01a85c7e0a78ff3058" translate="yes" xml:space="preserve">
          <source>The root entity of the 3D scene to be displayed.</source>
          <target state="translated">표시 할 3D 장면의 루트 엔티티입니다.</target>
        </trans-unit>
        <trans-unit id="afd24d8a4552be77772f15753c07df61b95ec4fa" translate="yes" xml:space="preserve">
          <source>The root item is returned by &lt;a href=&quot;qabstractitemview#rootIndex&quot;&gt;rootIndex&lt;/a&gt;(), and the current item by &lt;a href=&quot;qabstractitemview#currentIndex&quot;&gt;currentIndex&lt;/a&gt;(). To make sure that an item is visible use &lt;a href=&quot;qabstractitemview#scrollTo&quot;&gt;scrollTo&lt;/a&gt;().</source>
          <target state="translated">루트 항목은 &lt;a href=&quot;qabstractitemview#rootIndex&quot;&gt;rootIndex&lt;/a&gt; ()로, 현재 항목은 &lt;a href=&quot;qabstractitemview#currentIndex&quot;&gt;currentIndex&lt;/a&gt; () 로 반환됩니다 . 항목이 표시되도록하려면 &lt;a href=&quot;qabstractitemview#scrollTo&quot;&gt;scrollTo&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8491f7b1fced8b98a3f6dbc163d15e930eb773b6" translate="yes" xml:space="preserve">
          <source>The rotation angle held by &lt;a href=&quot;qpinchgesture#rotationAngle-prop&quot;&gt;rotationAngle&lt;/a&gt; changed.</source>
          <target state="translated">에 의해 유지 된 회전 각도 &lt;a href=&quot;qpinchgesture#rotationAngle-prop&quot;&gt;rotationAngle은&lt;/a&gt; 변화했다.</target>
        </trans-unit>
        <trans-unit id="67f668c99bc13d91d7212fc54d294f22102d84ba" translate="yes" xml:space="preserve">
          <source>The rotation is combined with the item's &lt;a href=&quot;qgraphicsitem#scale-1&quot;&gt;scale&lt;/a&gt;(), &lt;a href=&quot;qgraphicsitem#transform&quot;&gt;transform&lt;/a&gt;() and &lt;a href=&quot;qgraphicsitem#transformations&quot;&gt;transformations&lt;/a&gt;() to map the item's coordinate system to the parent item.</source>
          <target state="translated">로테이션은 아이템의 &lt;a href=&quot;qgraphicsitem#scale-1&quot;&gt;스케일&lt;/a&gt; 과 결합됩니다 (), &lt;a href=&quot;qgraphicsitem#transform&quot;&gt;변환&lt;/a&gt; () 및 &lt;a href=&quot;qgraphicsitem#transformations&quot;&gt;변환&lt;/a&gt; () 과 항목의 좌표계를 상위 항목에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="c958a2b31fad580e90e1b31d025e4331019813fe" translate="yes" xml:space="preserve">
          <source>The rotation of axis titles.</source>
          <target state="translated">축 제목의 회전입니다.</target>
        </trans-unit>
        <trans-unit id="2fa14774e8a5763ea484d10eb03caf0d35bf0377" translate="yes" xml:space="preserve">
          <source>The rotation of the pinch gesture in degrees, with positive values clockwise. It is 0 when the gesture begins. If &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target&lt;/a&gt; is not null, this will be automatically applied to its &lt;a href=&quot;qml-qtquick-item#rotation-prop&quot;&gt;rotation&lt;/a&gt;. Otherwise, bindings can be used to do arbitrary things with this value.</source>
          <target state="translated">핀치 동작의 회전 (도)이며 양수 값은 시계 방향입니다. 제스처가 시작되면 0입니다. 만약&lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target&lt;/a&gt; 이 null이 아닌&lt;a href=&quot;qml-qtquick-item#rotation-prop&quot;&gt; 회전에&lt;/a&gt; 자동으로 적용됩니다 . 그렇지 않으면 바인딩을 사용하여이 값으로 임의의 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96df25200a240c754afb66a3ca47d6d500279647" translate="yes" xml:space="preserve">
          <source>The rotation reading contains 3 angles, measured in degrees that define the orientation of the device in three-dimensional space. These angles are similar to yaw, pitch and roll but are defined using only right hand rotation with axes as defined by the right hand cartesian coordinate system.</source>
          <target state="translated">회전 판독 값에는 3 차원 공간에서 장치의 방향을 정의하는 각도로 측정 된 3 개의 각도가 포함됩니다. 이 각도는 요, 피치 및 롤과 유사하지만 오른쪽 직교 좌표계에 의해 정의 된 축을 사용하여 오른쪽 회전 만 사용하여 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="508cee5eca781f5d075bf89f8c387c1424a817dc" translate="yes" xml:space="preserve">
          <source>The rotation should be a normalized &lt;a href=&quot;qquaternion&quot;&gt;QQuaternion&lt;/a&gt;. For those series types that support item specific rotation, the rotations are multiplied together. &lt;a href=&quot;qbar3dseries&quot;&gt;QBar3DSeries&lt;/a&gt; ignores any rotation that is not around the y-axis. &lt;a href=&quot;qsurface3dseries&quot;&gt;QSurface3DSeries&lt;/a&gt; applies the rotation only to the selection pointer. Defaults to no rotation.</source>
          <target state="translated">회전은 정규화 된 &lt;a href=&quot;qquaternion&quot;&gt;QQuaternion&lt;/a&gt; 이어야합니다 . 품목별 회전을 지원하는 시리즈 유형의 경우 회전이 함께 곱해집니다. &lt;a href=&quot;qbar3dseries&quot;&gt;QBar3DSeries&lt;/a&gt; 는 y 축을 중심으로하지 않는 회전을 무시합니다.&lt;a href=&quot;qsurface3dseries&quot;&gt;QSurface3DSeries&lt;/a&gt; 는 선택 포인터에만 회전을 적용합니다. 기본적으로 회전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c7da522c2af8b072f1a7059f8e23d775861b6a6" translate="yes" xml:space="preserve">
          <source>The rotation transformation matrix is as follows:</source>
          <target state="translated">회전 변환 행렬은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3083036fd82f09ff0ce7dec456aa143dcee9167b" translate="yes" xml:space="preserve">
          <source>The roughness texture map. Default is a &lt;a href=&quot;qml-qtquick3d-texture&quot;&gt;Texture&lt;/a&gt; with source &lt;code&gt;&quot;maps/grunge_d.png&quot;&lt;/code&gt;.</source>
          <target state="translated">The roughness texture map. Default is a &lt;a href=&quot;qml-qtquick3d-texture&quot;&gt;Texture&lt;/a&gt; with source &lt;code&gt;&quot;maps/grunge_d.png&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0863b2a2f8259098d887d3d56f1c39cb1ff1f177" translate="yes" xml:space="preserve">
          <source>The route optimizations which should be considered during the planning of the route. Values can be combined with OR ('|') -operator.</source>
          <target state="translated">경로를 계획 할 때 고려해야 할 경로 최적화. 값은 OR ( '|')-연산자와 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b58e155e27805151dbf8b127492193b20fae239" translate="yes" xml:space="preserve">
          <source>The route query extra parameters. This property is read only. If the query is defined by the user, these can be set by using MapParameters. If the route query comes from the engine via signals, the query is intended to be read-only.</source>
          <target state="translated">경로 쿼리 추가 매개 변수 이 속성은 읽기 전용입니다. 사용자가 쿼리를 정의한 경우 MapParameters를 사용하여 쿼리를 설정할 수 있습니다. 경로 쿼리가 신호를 통해 엔진에서 오는 경우 쿼리는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="3ec851f6be2b93558f46808414eebffc9eefed9d" translate="yes" xml:space="preserve">
          <source>The route segment will remain invalid until one of &lt;a href=&quot;qgeoroutesegment#setNextRouteSegment&quot;&gt;setNextRouteSegment&lt;/a&gt;(), &lt;a href=&quot;qgeoroutesegment#setTravelTime&quot;&gt;setTravelTime&lt;/a&gt;(), &lt;a href=&quot;qgeoroutesegment#setDistance&quot;&gt;setDistance&lt;/a&gt;(), &lt;a href=&quot;qgeoroutesegment#setPath&quot;&gt;setPath&lt;/a&gt;() or &lt;a href=&quot;qgeoroutesegment#setManeuver&quot;&gt;setManeuver&lt;/a&gt;() is called.</source>
          <target state="translated">경로 세그먼트는 &lt;a href=&quot;qgeoroutesegment#setNextRouteSegment&quot;&gt;setNextRouteSegment&lt;/a&gt; (), &lt;a href=&quot;qgeoroutesegment#setTravelTime&quot;&gt;setTravelTime&lt;/a&gt; (), &lt;a href=&quot;qgeoroutesegment#setDistance&quot;&gt;setDistance&lt;/a&gt; (), &lt;a href=&quot;qgeoroutesegment#setPath&quot;&gt;setPath&lt;/a&gt; () 또는&lt;a href=&quot;qgeoroutesegment#setManeuver&quot;&gt; setManeuver&lt;/a&gt; () .</target>
        </trans-unit>
        <trans-unit id="eb92271f25b0d3a94a078c822cabff6d4e27f685" translate="yes" xml:space="preserve">
          <source>The route will be optimized for someone who is driving a car</source>
          <target state="translated">경로는 자동차를 운전하는 사람에게 최적화됩니다</target>
        </trans-unit>
        <trans-unit id="134668c99e382d490a9c56bb45581ca3c59a29ec" translate="yes" xml:space="preserve">
          <source>The route will be optimized for someone who is driving a car.</source>
          <target state="translated">경로는 자동차를 운전하는 사람에게 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="dc7b10a911094dd10d2a4beddb2899d40d2cf46f" translate="yes" xml:space="preserve">
          <source>The route will be optimized for someone who is driving a truck</source>
          <target state="translated">경로는 트럭을 운전하는 사람에게 최적화됩니다</target>
        </trans-unit>
        <trans-unit id="c486c52bdbdb497a977fd98abfb192324c88c62c" translate="yes" xml:space="preserve">
          <source>The route will be optimized for someone who is driving a truck.</source>
          <target state="translated">경로는 트럭을 운전하는 사람에게 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="99786a233741a7fc720eeef5ea810bfc71c5fc52" translate="yes" xml:space="preserve">
          <source>The route will be optimized for someone who is making use of public transit.</source>
          <target state="translated">대중 교통을 이용하는 사람에게 최적의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="58f22fd4fa68b65b825a424171c319cceeab9d96" translate="yes" xml:space="preserve">
          <source>The route will be optimized for someone who is riding a bicycle</source>
          <target state="translated">자전거를 타는 사람에게 경로가 최적화됩니다</target>
        </trans-unit>
        <trans-unit id="612a0848de6048f41cc875962d036c7fa6f7a511" translate="yes" xml:space="preserve">
          <source>The route will be optimized for someone who is riding a bicycle.</source>
          <target state="translated">자전거를 타는 사람에게 경로가 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="fbdf64daac76a942f19a07c0f0522e601593bb35" translate="yes" xml:space="preserve">
          <source>The route will be optimized for someone who is walking</source>
          <target state="translated">경로는 걷는 사람에게 최적화됩니다</target>
        </trans-unit>
        <trans-unit id="62a336c3f08527b5555fa4ab2f87cb1e81b5f253" translate="yes" xml:space="preserve">
          <source>The route will be optimized for someone who is walking.</source>
          <target state="translated">경로는 걷는 사람에게 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="7a2d2e6db9fad3ee8be115c298ba1b0796bd6d95" translate="yes" xml:space="preserve">
          <source>The route will traverse the objects of</source>
          <target state="translated">경로는 객체를 통과합니다</target>
        </trans-unit>
        <trans-unit id="28ee81a61aef9a369fd6b17b494451b808400015" translate="yes" xml:space="preserve">
          <source>The routing manager that was used did not have a &lt;a href=&quot;qgeoroutingmanagerengine&quot;&gt;QGeoRoutingManagerEngine&lt;/a&gt; instance associated with it.</source>
          <target state="translated">사용 된 라우팅 관리자에 연관된 &lt;a href=&quot;qgeoroutingmanagerengine&quot;&gt;QGeoRoutingManagerEngine&lt;/a&gt; 인스턴스 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="adb362e351dcd6b2f58b22444e0159341d80bd1c" translate="yes" xml:space="preserve">
          <source>The row above is one example of a complex row.</source>
          <target state="translated">The row above is one example of a complex row.</target>
        </trans-unit>
        <trans-unit id="0413d096ad71615609e9563a59e7367f43afecc2" translate="yes" xml:space="preserve">
          <source>The row categories of the mapping. Only items with row role values that are found in this list are included when the data is resolved. The rows are ordered in the same order as they are in this list.</source>
          <target state="translated">매핑의 행 범주 이 목록에있는 행 역할 값이있는 항목 만 데이터가 분석 될 때 포함됩니다. 행은이 목록과 동일한 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="7a52624a0066c7b364d1e5ebd54f46aa016368e2" translate="yes" xml:space="preserve">
          <source>The row categories of the mapping. Only items with row roles that are found in this list are included when data is resolved. The rows are ordered in the same order as they are in this list.</source>
          <target state="translated">매핑의 행 범주 이 목록에서 찾은 행 역할이있는 항목 만 데이터가 분석 될 때 포함됩니다. 행은이 목록과 동일한 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="2ad49955354e3037174744967480f334e6432a74" translate="yes" xml:space="preserve">
          <source>The row of the model is used as the data source for the first box-and-whiskers item. The default value is -1 (invalid mapping).</source>
          <target state="translated">모델의 행은 첫 번째 상자 및 수염 항목의 데이터 소스로 사용됩니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="9aa53280bea7e48af37ae1b8a0c05edfd5c4c802" translate="yes" xml:space="preserve">
          <source>The row of the model is used as the data source for the last box-and-whiskers item. The default value is -1 (invalid mapping).</source>
          <target state="translated">모델의 행은 마지막 상자 및 수염 항목의 데이터 소스로 사용됩니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="ff87abe4fc465079f81d36d8aca87a1a0ef87438" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the close values of the candlestick items in the series. The default value is -1 (invalid mapping).</source>
          <target state="translated">시리즈에서 촛대 항목의 종가를 포함하는 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="5c76affccddf9954849096361336a91df00982b5" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the data for the first point of the series. The default value is 0.</source>
          <target state="translated">시리즈의 첫 번째 점에 대한 데이터를 포함하는 모델의 행입니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="9f512e2bc8eca4bc11bc36f34a6abe618904906a" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the first slice value. The default value is 0.</source>
          <target state="translated">첫 번째 슬라이스 값을 포함하는 모델의 행입니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="aebcd1e71101e4c41545703177e1ac68c0ae79bb" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the first values of the bar sets in the bar series. The default value is 0.</source>
          <target state="translated">막대 시리즈에서 막대 세트의 첫 번째 값을 포함하는 모델의 행입니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="c240f7cac4999a174b9089796641b7bd21b33250" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the first values of the box-and-whiskers items in the box plot series.</source>
          <target state="translated">상자 그림 시리즈의 상자 및 수염 항목의 첫 번째 값을 포함하는 모델의 행입니다.</target>
        </trans-unit>
        <trans-unit id="40f9fb2fb18c403b33711f21b40c729ebec25c41" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the high values of the candlestick items in the series. The default value is -1 (invalid mapping).</source>
          <target state="translated">시리즈에서 촛대 항목의 높은 값을 포함하는 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="e47e30cd321c8845cf679abeb78a192a7270ee79" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the low values of the candlestick items in the series. The default value is -1 (invalid mapping).</source>
          <target state="translated">시리즈에서 촛대 항목의 낮은 값을 포함하는 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="b3d9f1b25cc21bc9e3fe8697116b81a35da94ad3" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the open values of the candlestick items in the series. The default value is -1 (invalid mapping).</source>
          <target state="translated">시리즈에서 촛대 항목의 열린 값을 포함하는 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="5d56a5d3054a2a6792504dc2ce1fa34093fdf1f8" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the timestamp values of the candlestick items in the series. The default value is -1 (invalid mapping).</source>
          <target state="translated">시리즈의 촛대 항목의 타임 스탬프 값이 포함 된 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="62e02e86efc615ad60ac60d0f59e531665913514" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the x-coordinates of the data points. The default value is -1 (invalid mapping).</source>
          <target state="translated">데이터 포인트의 x 좌표를 포함하는 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="0cb76a7ecc158cb123f3b3eb3863913d3fac9b15" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the y-coordinates of the data points.</source>
          <target state="translated">데이터 포인트의 y 좌표를 포함하는 모델의 행입니다.</target>
        </trans-unit>
        <trans-unit id="809ef3ba8c73439c1658a2b1ff459189c6c478ff" translate="yes" xml:space="preserve">
          <source>The row of the model that is kept in sync with the labels of the pie's slices. The default value is -1 (invalid mapping).</source>
          <target state="translated">파이 조각 레이블과 동기화 된 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="c600102117cd6f3ec23cab0d37046c8bcfe7bf0d" translate="yes" xml:space="preserve">
          <source>The row of the model that is kept in sync with the values of the pie's slices. The default value is -1 (invalid mapping).</source>
          <target state="translated">파이 조각 값과 동기화 된 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="f55282dc2f19b4400498aa6ad662ce1322eb9899" translate="yes" xml:space="preserve">
          <source>The row of the model that is used as the data source for the first item. The default value is -1 (invalid mapping).</source>
          <target state="translated">첫 번째 항목의 데이터 소스로 사용되는 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="0dd7ae797f5d899931d2cd1642f3ccffc4ed12ac" translate="yes" xml:space="preserve">
          <source>The row of the model that is used as the data source for the last bar set. The default value is -1 (invalid mapping).</source>
          <target state="translated">마지막 막대 세트의 데이터 소스로 사용되는 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="6532ffc25a7f6ead22b76882e52f82962a190031" translate="yes" xml:space="preserve">
          <source>The row of the model that is used as the data source for the last item. The default value is -1 (invalid mapping).</source>
          <target state="translated">마지막 항목의 데이터 소스로 사용되는 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="d0a16e35ef453542a3ceec92ddedcc4a65823edd" translate="yes" xml:space="preserve">
          <source>The rubber band is fixed to the point that was clicked and can be pulled both vertically and horizontally.</source>
          <target state="translated">고무 밴드는 클릭 한 지점에 고정되며 수직 및 수평으로 당길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68440a3c796de6fd632c72c3597b73413fecaf6c" translate="yes" xml:space="preserve">
          <source>The rubber band is locked to the size of the chart horizontally and can be pulled vertically to specify the zooming area.</source>
          <target state="translated">고무 밴드는 차트의 크기에 가로로 고정되며 세로로 당겨 확대 / 축소 영역을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb706785fe189ee4761e610d79cec8b143b7cd61" translate="yes" xml:space="preserve">
          <source>The rubber band is locked to the size of the chart vertically and can be pulled horizontally to specify the zooming area.</source>
          <target state="translated">고무줄은 세로로 차트 크기에 고정되며 가로로 당겨 확대 / 축소 영역을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3873f6fcea23dc7d8dc4f4951beb5c4a44a3891e" translate="yes" xml:space="preserve">
          <source>The ruby text for a part of the preedit string. There should be at most one ruby text set for every part of the preedit string. If several are specified for any character in the string the behaviour is undefined.</source>
          <target state="translated">사전 편집 문자열의 일부에 대한 루비 텍스트입니다. 사전 편집 문자열의 모든 부분에 대해 최대 하나의 루비 텍스트 세트가 있어야합니다. 문자열의 문자에 대해 여러 개가 지정되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9648179cac19289d44266d5fe1134a1d81d5cd2b" translate="yes" xml:space="preserve">
          <source>The rule of thumb for alignment is that a type is aligned to its natural boundary, which is the smallest power of 2 that is bigger than the type, unless that alignment is larger than the maximum useful alignment for the platform. For practical purposes, alignment larger than 2 * sizeof(void*) is only necessary for special hardware instructions (e.g., aligned SSE loads and stores on x86).</source>
          <target state="translated">정렬의 경험 법칙은 유형이 플랫폼의 최대 유용한 정렬보다 큰 경우를 제외하고 유형이 자연 경계에 정렬되어 유형보다 큰 2의 가장 작은 거듭 제곱 인 2보다 작습니다. 실제적인 목적으로, 2 * sizeof (void *)보다 큰 정렬은 특수 하드웨어 명령어 (예 : x86의 정렬 된 SSE로드 및 저장)에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="197ed0600473672604fcc1bbf3701ccaf70ff285" translate="yes" xml:space="preserve">
          <source>The rulers are defined as a number of pixels from the left edge of the &lt;a href=&quot;qml-qtquick-virtualkeyboard-traceinputarea#boundingBox-prop&quot;&gt;boundingBox&lt;/a&gt;.</source>
          <target state="translated">눈금자는 &lt;a href=&quot;qml-qtquick-virtualkeyboard-traceinputarea#boundingBox-prop&quot;&gt;boundingBox&lt;/a&gt; 의 왼쪽 가장자리에서 여러 픽셀로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="0ea6e7cd53e7f37a14a5263a577fb3db9d8565a3" translate="yes" xml:space="preserve">
          <source>The rulers are defined as a number of pixels from the left edge of the bounding box.</source>
          <target state="translated">눈금자는 경계 상자의 왼쪽 가장자리에서 여러 픽셀로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f469db00f31ce6fe1dc161f384d4b1d874ecfa0a" translate="yes" xml:space="preserve">
          <source>The rulers are defined as a number of pixels from the top edge of the &lt;a href=&quot;qml-qtquick-virtualkeyboard-traceinputarea#boundingBox-prop&quot;&gt;boundingBox&lt;/a&gt;.</source>
          <target state="translated">눈금자는 &lt;a href=&quot;qml-qtquick-virtualkeyboard-traceinputarea#boundingBox-prop&quot;&gt;boundingBox&lt;/a&gt; 의 위쪽 가장자리부터 여러 픽셀로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="5373271afcd293aa496865f69ac61fbf5306502d" translate="yes" xml:space="preserve">
          <source>The rulers are defined as a number of pixels from the top edge of the bounding box.</source>
          <target state="translated">눈금자는 경계 상자의 위쪽 가장자리부터 여러 픽셀로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="bcc2c020272fb5b3e89a31576620bac9e2eb052a" translate="yes" xml:space="preserve">
          <source>The rules themselves are not documented and are internal to Qt Linguist and &lt;code&gt;lrelease&lt;/code&gt;.</source>
          <target state="translated">규칙 자체는 문서화되지 않았으며 Qt Linguist 및 &lt;code&gt;lrelease&lt;/code&gt; 내부에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2f2065cd772a9f0d348b02c915161af0825c045" translate="yes" xml:space="preserve">
          <source>The run indicator of the server. &lt;code&gt;quint8&lt;/code&gt;</source>
          <target state="translated">서버의 실행 표시기 &lt;code&gt;quint8&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f914b2e0834ee85267f4121040d0a8dbadc594f" translate="yes" xml:space="preserve">
          <source>The running state of this state machine.</source>
          <target state="translated">이 상태 머신의 실행 상태입니다.</target>
        </trans-unit>
        <trans-unit id="537c1f827cd1d854252895481ce05eda1e03b62c" translate="yes" xml:space="preserve">
          <source>The sRGB color space with linear gamma. Useful for gamma-corrected blending.</source>
          <target state="translated">The sRGB color space with linear gamma. Useful for gamma-corrected blending.</target>
        </trans-unit>
        <trans-unit id="06d88925557fa3d5fca6865c879193c3c36be452" translate="yes" xml:space="preserve">
          <source>The sRGB color space, which Qt operates in by default. It is a close approximation of how most classic monitors operate, and a mode most software and hardware support. &lt;a href=&quot;http://www.color.org/chardata/rgb/srgb.xalter&quot;&gt;ICC registration of sRGB&lt;/a&gt;.</source>
          <target state="translated">The sRGB color space, which Qt operates in by default. It is a close approximation of how most classic monitors operate, and a mode most software and hardware support. &lt;a href=&quot;http://www.color.org/chardata/rgb/srgb.xalter&quot;&gt;ICC registration of sRGB&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="a03146c29f4c7312518cefcd3ebc8a15939d0ef5" translate="yes" xml:space="preserve">
          <source>The sRGB primaries</source>
          <target state="translated">The sRGB primaries</target>
        </trans-unit>
        <trans-unit id="1240d889b28eb54d03039d3c5f0e631a2af327df" translate="yes" xml:space="preserve">
          <source>The sRGB transfer function, composed of linear and gamma parts</source>
          <target state="translated">The sRGB transfer function, composed of linear and gamma parts</target>
        </trans-unit>
        <trans-unit id="73c31463433fad5f51bc996be59942648947e348" translate="yes" xml:space="preserve">
          <source>The same API definition file as was used on the source side, &lt;code&gt;SimpleSwitch.rep&lt;/code&gt;, is used for creating a &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; header file using the &lt;a href=&quot;qtremoteobjects-repc#&quot;&gt;repc&lt;/a&gt; utility. Include the following line in your client side &lt;code&gt;.pro&lt;/code&gt; file, specifying a &lt;code&gt;.rep&lt;/code&gt; file input:</source>
          <target state="translated">소스 측에서 사용한 것과 동일한 API 정의 파일 인 &lt;code&gt;SimpleSwitch.rep&lt;/code&gt; 가 &lt;a href=&quot;qtremoteobjects-repc#&quot;&gt;repc&lt;/a&gt; 유틸리티를 사용하여 &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;복제본&lt;/a&gt; 헤더 파일 을 작성하는 데 사용됩니다 . &lt;code&gt;.rep&lt;/code&gt; 파일 입력을 지정 하여 클라이언트 측 &lt;code&gt;.pro&lt;/code&gt; 파일 에 다음 행을 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="76f36f94c78581353d5750602598e494004c29b0" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;qdragmoveevent#accept-1&quot;&gt;accept&lt;/a&gt;(), but also notifies that future moves will also be acceptable if they remain within the</source>
          <target state="translated">&lt;a href=&quot;qdragmoveevent#accept-1&quot;&gt;accept&lt;/a&gt; () 와 동일 하지만 향후 이동이</target>
        </trans-unit>
        <trans-unit id="d7cf1dc341f5b3f152b3a16f23040ab2474b2f00" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;qsysinfo#buildCpuArchitecture&quot;&gt;QSysInfo::buildCpuArchitecture&lt;/a&gt;(), such as &quot;arm&quot;, &quot;i386&quot;, &quot;mips&quot; or &quot;x86_64&quot;</source>
          <target state="translated">&quot;arm&quot;, &quot;i386&quot;, &quot;mips&quot;또는 &quot;x86_64&quot; 와 같은 &lt;a href=&quot;qsysinfo#buildCpuArchitecture&quot;&gt;QSysInfo :: buildCpuArchitecture&lt;/a&gt; () 와 동일</target>
        </trans-unit>
        <trans-unit id="217c9205a79fea6030be0adac287ad32db3ba53c" translate="yes" xml:space="preserve">
          <source>The same as accept(), but also notifies that future moves will also be acceptable if they remain within the</source>
          <target state="translated">The same as accept(), but also notifies that future moves will also be acceptable if they remain within the</target>
        </trans-unit>
        <trans-unit id="d1d3180510bdf119de00ab3511549e3877881dd8" translate="yes" xml:space="preserve">
          <source>The same as an empty plain text. This is the default. Set by &lt;a href=&quot;qlabel#clear&quot;&gt;clear&lt;/a&gt;().</source>
          <target state="translated">빈 일반 텍스트와 동일합니다. 이것이 기본값입니다. &lt;a href=&quot;qlabel#clear&quot;&gt;clear&lt;/a&gt; ()로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d89a5a8d888dd83a0588a06ef20ff2cfe1fe8c8f" translate="yes" xml:space="preserve">
          <source>The same command with a</source>
          <target state="translated">와 같은 명령</target>
        </trans-unit>
        <trans-unit id="ed77ef30a35d4fda8eb92be90c40a88e84d8a5f0" translate="yes" xml:space="preserve">
          <source>The same example using this constructor:</source>
          <target state="translated">이 생성자를 사용하는 동일한 예제 :</target>
        </trans-unit>
        <trans-unit id="c3c2e446be7d95e0655d15386ba577d7ea22e888" translate="yes" xml:space="preserve">
          <source>The same mapping functions are available in the view, for mapping to and from the scene. &lt;a href=&quot;qgraphicsview#mapFromScene&quot;&gt;QGraphicsView::mapFromScene&lt;/a&gt;() and &lt;a href=&quot;qgraphicsview#mapToScene&quot;&gt;QGraphicsView::mapToScene&lt;/a&gt;(). To map from a view to an item, you first map to the scene, and then map from the scene to the item.</source>
          <target state="translated">장면과의 매핑을 위해 뷰에서 동일한 매핑 기능을 사용할 수 있습니다. &lt;a href=&quot;qgraphicsview#mapFromScene&quot;&gt;QGraphicsView :: mapFromScene&lt;/a&gt; () 및 &lt;a href=&quot;qgraphicsview#mapToScene&quot;&gt;QGraphicsView :: mapToScene&lt;/a&gt; (). 뷰에서 항목으로 매핑하려면 먼저 장면에 매핑 한 다음 장면에서 항목으로 매핑하십시오.</target>
        </trans-unit>
        <trans-unit id="689c04a9c128cbcc93772b41fb460dd25f991bed" translate="yes" xml:space="preserve">
          <source>The same may also be obtained by using &lt;a href=&quot;http://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution&quot;&gt;&lt;code&gt;std::uniform_real_distribution&lt;/code&gt;&lt;/a&gt; with parameters 0 and 1.</source>
          <target state="translated">매개 변수 0 및 1과 함께 &lt;a href=&quot;http://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution&quot;&gt; &lt;code&gt;std::uniform_real_distribution&lt;/code&gt; &lt;/a&gt; 을 사용하여 동일한 결과를 얻을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="502118c44438ca798e2ff9b00eb7e3be4260a758" translate="yes" xml:space="preserve">
          <source>The same menu may sometimes contain items that should not be included in the same exclusive group. Such cases are best handled using the &lt;a href=&quot;qml-qt-labs-platform-menuitem#group-prop&quot;&gt;group&lt;/a&gt; property.</source>
          <target state="translated">동일한 메뉴에 동일한 독점 그룹에 포함되지 않아야하는 항목이 포함되는 경우가 있습니다. 이러한 경우는 &lt;a href=&quot;qml-qt-labs-platform-menuitem#group-prop&quot;&gt;그룹&lt;/a&gt; 속성을 사용하여 처리하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7c2735b67623f82115581b76f9c1876be8de8ca1" translate="yes" xml:space="preserve">
          <source>The same principle applies to any combination of view transitions. An added item may be moved before its add transition finishes, or a moved item may be removed before its moved transition finishes, and so on; so, the rule of thumb is that every transition should handle the same set of properties.</source>
          <target state="translated">뷰 전환의 모든 조합에 동일한 원칙이 적용됩니다. 추가 된 항목은 추가 전환이 완료되기 전에 이동되거나 이동 된 항목이 이동 된 전환이 완료되기 전에 제거 될 수 있습니다. 따라서 경험상 모든 전환은 동일한 속성 집합을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="db90f8ebc86d0fbe69fd25bd7d281c2379fd7bf5" translate="yes" xml:space="preserve">
          <source>The same principle applies to code that throws and catches exceptions. An exception that is not caught in the function that has locked the mutex has no way of unlocking the mutex before the exception is passed up the stack to the calling function.</source>
          <target state="translated">예외를 발생시키고 포착하는 코드에도 동일한 원칙이 적용됩니다. 뮤텍스를 잠근 함수에서 포착되지 않은 예외는 예외가 스택으로 호출 함수로 전달되기 전에 뮤텍스를 잠금 해제 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="aa0002ab51f3ae07af33daa8263d26fa274e89b2" translate="yes" xml:space="preserve">
          <source>The same reasoning as &lt;code&gt;QtActivity&lt;/code&gt; applies here. Unless you are using features that require the Qt libraries to be loaded, like native calls.</source>
          <target state="translated">The same reasoning as &lt;code&gt;QtActivity&lt;/code&gt; applies here. Unless you are using features that require the Qt libraries to be loaded, like native calls.</target>
        </trans-unit>
        <trans-unit id="9ea08bd44a252c20dc3fbef732c8a3d96e515364" translate="yes" xml:space="preserve">
          <source>The same request can be created like this, if the values are known at compile time:</source>
          <target state="translated">컴파일 타임에 값을 알고 있으면 다음과 같이 동일한 요청을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65845e08bb3f8745879541c0cf1dcf0f78025bf1" translate="yes" xml:space="preserve">
          <source>The same response can be created like this, if the values are known at compile time:</source>
          <target state="translated">컴파일 타임에 값을 알고 있으면 다음과 같은 응답을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93ab2cf59b0be81dd39ceb3022c498100782e7bf" translate="yes" xml:space="preserve">
          <source>The same result may also be obtained by using &lt;a href=&quot;http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution&quot;&gt;&lt;code&gt;std::uniform_int_distribution&lt;/code&gt;&lt;/a&gt; with parameters</source>
          <target state="translated">매개 변수와 함께 &lt;a href=&quot;http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution&quot;&gt; &lt;code&gt;std::uniform_int_distribution&lt;/code&gt; &lt;/a&gt; 을 사용하여 동일한 결과를 얻을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="63c8f307946a8481640e8e713dad9d2f094e1689" translate="yes" xml:space="preserve">
          <source>The same sequence with &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt;.SelectWords will extend the selection start to a word boundary before or on position 5 and extend the selection end to a word boundary on or past position 9.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; .SelectWords 와 동일한 시퀀스 는 선택 시작을 위치 5 이전 또는 위치의 단어 경계까지 확장하고 선택 끝을 위치 9 또는 이전 위치의 단어 경계까지 확장합니다.</target>
        </trans-unit>
        <trans-unit id="2f82894d7a3953a0f95a636cc11ea5b707f97e2f" translate="yes" xml:space="preserve">
          <source>The same sequence with &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt;.SelectWords will extend the selection start to a word boundary before or on the 5th position, and extend the selection end to a word boundary on or past the 9th position.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; .SelectWords 와 동일한 시퀀스 는 선택 시작을 5 번째 위치 앞 또는 5 번째 단어 경계로 확장하고 선택 종료를 9 번째 위치 이상의 단어 경계까지 확장합니다.</target>
        </trans-unit>
        <trans-unit id="73ee08592813baa3ddd10c94cbc475cdb6cbdd6e" translate="yes" xml:space="preserve">
          <source>The same sequence with &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt;.SelectWords will extend the selection start to a word boundary before or on position 5 and extend the selection end to a word boundary on or past position 9.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; .SelectWords 와 동일한 시퀀스 는 선택 시작을 위치 5 이전 또는 위치의 단어 경계까지 확장하고 선택 끝을 위치 9 또는 이전 위치의 단어 경계까지 확장합니다.</target>
        </trans-unit>
        <trans-unit id="9649f666ecbc288b7fcde25e2cfb903f672d8479" translate="yes" xml:space="preserve">
          <source>The same source model cannot be added more than once.</source>
          <target state="translated">동일한 소스 모델을 두 번 이상 추가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b14906f76e6cac0863aed1adeef1ae3ee105c89c" translate="yes" xml:space="preserve">
          <source>The sample rate of the media's audio stream in hertz.</source>
          <target state="translated">미디어 오디오 스트림의 샘플 레이트 (Hz)입니다.</target>
        </trans-unit>
        <trans-unit id="c004320fe12132d06bcaaef6b100a114624cbd71" translate="yes" xml:space="preserve">
          <source>The sand brown theme.</source>
          <target state="translated">모래 갈색 테마.</target>
        </trans-unit>
        <trans-unit id="eb90dab91e4a427e363e2776b96d94b7b9dc474f" translate="yes" xml:space="preserve">
          <source>The satellite backend closed the connection, which happens for example in case the user is switching location services to off. This object becomes invalid and should be deleted. A new satellite source can be created by calling &lt;a href=&quot;qgeosatelliteinfosource#createDefaultSource&quot;&gt;createDefaultSource&lt;/a&gt;() later on.</source>
          <target state="translated">위성 백엔드는 연결을 닫았습니다. 예를 들어 사용자가 위치 서비스를 끄는 경우에 발생합니다. 이 개체는 유효하지 않으므로 삭제해야합니다. 나중에 &lt;a href=&quot;qgeosatelliteinfosource#createDefaultSource&quot;&gt;createDefaultSource&lt;/a&gt; () 를 호출하여 새 위성 소스를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de97c6331dd4609897984f24f93b5e04aa46edf5" translate="yes" xml:space="preserve">
          <source>The satellite identifier number can be used to identify a satellite inside the satellite system. For satellite system GPS the satellite identifier number represents the PRN (Pseudo-random noise) number. For satellite system GLONASS the satellite identifier number represents the slot number.</source>
          <target state="translated">위성 식별자 번호는 위성 시스템 내부의 위성을 식별하는 데 사용될 수 있습니다. 위성 시스템 GPS의 경우 위성 식별자 번호는 PRN (Pseudo-random noise) 번호를 나타냅니다. 위성 시스템 GLONASS의 경우 위성 식별자 번호는 슬롯 번호를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3c535a32805edb07ef5d82ab251bf3af31d917c4" translate="yes" xml:space="preserve">
          <source>The saturation value from &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; is combined with hue and lightness from source and written.</source>
          <target state="translated">&lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; 의 채도 값은 소스의 색조 및 밝기와 결합되어 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="336e16642a0ac2b4436451d4eb0dcdc2857216b9" translate="yes" xml:space="preserve">
          <source>The saturation, value and alpha-channel values must be in the range 0-255, and the hue value must be greater than -1.</source>
          <target state="translated">채도, 값 및 알파 채널 값은 0-255 범위에 있어야하고 색조 값은 -1보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="8a8e4562655e8a25e62b6af104e52411f6468e83" translate="yes" xml:space="preserve">
          <source>The saving of a new place is performed as follows, we create a &lt;a href=&quot;qplace&quot;&gt;QPlace&lt;/a&gt; instance and populate it with information such as a name, address and coordinate. Once done we can invoke &lt;a href=&quot;qplacemanager#savePlace&quot;&gt;QPlaceManager::savePlace&lt;/a&gt;() to begin a save operation.</source>
          <target state="translated">새 장소 저장은 다음과 같이 수행됩니다. &lt;a href=&quot;qplace&quot;&gt;QPlace&lt;/a&gt; 인스턴스를 작성 하고 이름, 주소 및 좌표와 같은 정보로 채 웁니다. 완료되면 &lt;a href=&quot;qplacemanager#savePlace&quot;&gt;QPlaceManager :: savePlace&lt;/a&gt; ()를 호출 하여 저장 작업을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c97d4857ca70b69ce938acd178279e6a7b47fee2" translate="yes" xml:space="preserve">
          <source>The scale factor can be any real number; the default value is 1.0. If you set the factor to 0.0, the item will be collapsed to a single point. If you provide a negative value, the item will be flipped end for end around its origin.</source>
          <target state="translated">스케일 팩터는 임의의 실수 일 수 있습니다. 기본값은 1.0입니다. 계수를 0.0으로 설정하면 항목이 단일 지점으로 축소됩니다. 음수 값을 제공하면 항목이 원점을 기준으로 끝으로 뒤집 힙니다.</target>
        </trans-unit>
        <trans-unit id="472585844a5d9de56e7f99d368c2ce31f3753f74" translate="yes" xml:space="preserve">
          <source>The scale factor can be any real number; the default value is 1.0. If you set the factor to 0.0, the item will be collapsed to a single point. If you provide a negative value, the item will be flipped vertically around its origin.</source>
          <target state="translated">스케일 팩터는 임의의 실수 일 수 있습니다. 기본값은 1.0입니다. 계수를 0.0으로 설정하면 항목이 단일 지점으로 축소됩니다. 음수 값을 제공하면 항목이 원점을 기준으로 세로로 뒤집 힙니다.</target>
        </trans-unit>
        <trans-unit id="9e9d22c18eb346d18fb28e197c3f2e69d863a80d" translate="yes" xml:space="preserve">
          <source>The scale factor can be any real number; the default value is 1.0. If you set the factor to 0.0, the item will be collapsed to a single point. If you provide a negative value, the item will be mirrored horizontally around its origin.</source>
          <target state="translated">스케일 팩터는 임의의 실수 일 수 있습니다. 기본값은 1.0입니다. 계수를 0.0으로 설정하면 항목이 단일 지점으로 축소됩니다. 음수 값을 제공하면 항목이 원점을 기준으로 가로로 미러링됩니다.</target>
        </trans-unit>
        <trans-unit id="eae71440263f256ea4e1017f351adabfa84b96df" translate="yes" xml:space="preserve">
          <source>The scale factor held by &lt;a href=&quot;qpinchgesture#scaleFactor-prop&quot;&gt;scaleFactor&lt;/a&gt; changed.</source>
          <target state="translated">&lt;a href=&quot;qpinchgesture#scaleFactor-prop&quot;&gt;scaleFactor가&lt;/a&gt; 보유한 축척 비율이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="34ed232415f497f8913b753b9d23a391d6920863" translate="yes" xml:space="preserve">
          <source>The scale factor measures the scale factor associated with the distance between two of the user's inputs on a touch device.</source>
          <target state="translated">스케일 팩터는 터치 장치에서 사용자의 두 입력 사이의 거리와 관련된 스케일 팩터를 측정합니다.</target>
        </trans-unit>
        <trans-unit id="5bea88c95165a3bde951c5f6f2e73c4ca2548922" translate="yes" xml:space="preserve">
          <source>The scale factor that either the operating system or Qt applies.</source>
          <target state="translated">The scale factor that either the operating system or Qt applies.</target>
        </trans-unit>
        <trans-unit id="363177e71e677c481facf568afdb1da6621aee63" translate="yes" xml:space="preserve">
          <source>The scale factor that will automatically be set on the &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target&lt;/a&gt; if it is not null. Otherwise, bindings can be used to do arbitrary things with this value. While the pinch gesture is being performed, it is continuously multiplied by &lt;a href=&quot;qml-qtquick-pinchhandler#activeScale-prop&quot;&gt;activeScale&lt;/a&gt;; after the gesture ends, it stays the same; and when the next pinch gesture begins, it begins to be multiplied by &lt;a href=&quot;qml-qtquick-pinchhandler#activeScale-prop&quot;&gt;activeScale&lt;/a&gt; again.</source>
          <target state="translated">&lt;a href=&quot;qmake-variable-reference#target&quot;&gt;대상&lt;/a&gt; 이 null이 아닌 경우 자동으로 설정되는 배율입니다 . 그렇지 않으면 바인딩을 사용하여이 값으로 임의의 작업을 수행 할 수 있습니다. 핀치 제스처가 수행되는 동안 지속적으로 &lt;a href=&quot;qml-qtquick-pinchhandler#activeScale-prop&quot;&gt;activeScale을&lt;/a&gt; 곱합니다 . 제스처가 끝난 후에도 동일하게 유지됩니다. 다음 핀치 동작이 시작되면 &lt;a href=&quot;qml-qtquick-pinchhandler#activeScale-prop&quot;&gt;activeScale에&lt;/a&gt; 다시 곱하기 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="bf4bfc20e85ba470419a97aa5fe173061299289e" translate="yes" xml:space="preserve">
          <source>The scale factor while the pinch gesture is being performed. It is 1.0 when the gesture begins, increases as the touchpoints are spread apart, and decreases as the touchpoints are brought together. If &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target&lt;/a&gt; is not null, its &lt;a href=&quot;qml-qtquick-item#scale-prop&quot;&gt;scale&lt;/a&gt; will be automatically multiplied by this value. Otherwise, bindings can be used to do arbitrary things with this value.</source>
          <target state="translated">핀치 제스처가 수행되는 동안 스케일 팩터. 제스처가 시작될 때 1.0, 터치 포인트가 퍼짐에 따라 증가하고 터치 포인트가 결합되면 감소합니다. &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target&lt;/a&gt; 이 null이 아닌 경우 해당 &lt;a href=&quot;qml-qtquick-item#scale-prop&quot;&gt;배율&lt;/a&gt; 에이 값이 자동으로 곱해집니다. 그렇지 않으면 바인딩을 사용하여이 값으로 임의의 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="477ef1f25e0ee7dc53546b2e56787fe240575e30" translate="yes" xml:space="preserve">
          <source>The scale factors and skew factors are multiples;</source>
          <target state="translated">The scale factors and skew factors are multiples;</target>
        </trans-unit>
        <trans-unit id="5db7d297367f73d1c9d08bad97a4cb18b33b2d71" translate="yes" xml:space="preserve">
          <source>The scale factors and skew factors are multiples; &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; are coordinate space units, just like the units in the translate(x,y) method.</source>
          <target state="translated">스케일 팩터와 스큐 팩터는 배수입니다. &lt;code&gt;e&lt;/code&gt; 와 &lt;code&gt;f&lt;/code&gt; 는 translate (x, y) 메소드의 단위와 마찬가지로 좌표 공간 단위입니다.</target>
        </trans-unit>
        <trans-unit id="0f5c04225339c7f3338af49c7202f1f65feeb539" translate="yes" xml:space="preserve">
          <source>The scale is combined with the item's &lt;a href=&quot;qgraphicsitem#rotation&quot;&gt;rotation&lt;/a&gt;(), &lt;a href=&quot;qgraphicsitem#transform&quot;&gt;transform&lt;/a&gt;() and &lt;a href=&quot;qgraphicsitem#transformations&quot;&gt;transformations&lt;/a&gt;() to map the item's coordinate system to the parent item.</source>
          <target state="translated">배율은 항목의 &lt;a href=&quot;qgraphicsitem#rotation&quot;&gt;회전&lt;/a&gt; (), &lt;a href=&quot;qgraphicsitem#transform&quot;&gt;변형&lt;/a&gt; () 및 &lt;a href=&quot;qgraphicsitem#transformations&quot;&gt;변형&lt;/a&gt; () 과 결합되어 항목의 좌표계를 상위 항목에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="b56984da3345c8ecf733ae626a9fdf1691f4282c" translate="yes" xml:space="preserve">
          <source>The scale of the values is meters per second squared.</source>
          <target state="translated">값의 스케일은 초당 미터 제곱입니다.</target>
        </trans-unit>
        <trans-unit id="1a8764ac25d198e6061ce469b8dddda96c557a4c" translate="yes" xml:space="preserve">
          <source>The scale of the values is meters per second squared. The axes are arranged as follows.</source>
          <target state="translated">값의 스케일은 초당 미터 제곱입니다. 축은 다음과 같이 배열됩니다.</target>
        </trans-unit>
        <trans-unit id="0ae9b746ed4f77a73866e0c9549cfc1a6f40f172" translate="yes" xml:space="preserve">
          <source>The scaled clip rect (or ROI, Region Of Interest) of the image. A handler that supports this option is expected to apply the provided clip rect (a &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;), after applying any scaling (ScaleSize) or regular clipping (ClipRect). If the handler does not support this option, &lt;a href=&quot;qimagereader&quot;&gt;QImageReader&lt;/a&gt; will apply the scaled clip rect after the image has been read.</source>
          <target state="translated">이미지의 스케일 된 클립 rect (또는 ROI, 관심 영역) 이 옵션을 지원하는 핸들러는 스케일링 (ScaleSize) 또는 일반 클리핑 (ClipRect) 을 적용한 후 제공된 클립 rect ( &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; )를 적용해야합니다. 핸들러가이 옵션을 지원하지 않으면 &lt;a href=&quot;qimagereader&quot;&gt;QImageReader&lt;/a&gt; 는 이미지를 읽은 후에 스케일링 된 클립 rect를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="548bcc721fa9ca778b98e1836c3b83be9772bd34" translate="yes" xml:space="preserve">
          <source>The scaled device pixel ratio for the device. This is identical to PdmDevicePixelRatio, except that the value is scaled by a constant factor in order to support paint devices with fractional scale factors. The constant scaling factor used is devicePixelRatioFScale(). This enum value has been introduced in Qt 5.6.</source>
          <target state="translated">장치의 스케일 된 장치 픽셀 비율입니다. 분수 스케일 팩터로 페인트 디바이스를 지원하기 위해 값이 일정한 팩터로 스케일링된다는 점을 제외하면 PdmDevicePixelRatio와 동일합니다. 사용되는 상수 스케일링 계수는 devicePixelRatioFScale ()입니다. 이 열거 형 값은 Qt 5.6에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="d3faa6bd62c1b514fa796ed9414a1952bb5685f3" translate="yes" xml:space="preserve">
          <source>The scaled size of the image. A handler that supports this option is expected to scale the image to the provided size (a &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;), after applying any clip rect transformation (ClipRect). If the handler does not support this option, &lt;a href=&quot;qimagereader&quot;&gt;QImageReader&lt;/a&gt; will perform the scaling after the image has been read.</source>
          <target state="translated">이미지의 크기가 조정되었습니다. 이 옵션을 지원하는 핸들러는 클립 &lt;a href=&quot;qsize&quot;&gt;렉트&lt;/a&gt; 변환 (ClipRect)을 적용한 후 이미지를 제공된 크기 ( QSize )로 조정합니다. 핸들러가이 옵션을 지원하지 않으면 &lt;a href=&quot;qimagereader&quot;&gt;QImageReader&lt;/a&gt; 는 이미지를 읽은 후에 스케일링을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="492950a278feb99a774cb4025a606fd30204982d" translate="yes" xml:space="preserve">
          <source>The scaling factor for the X axis.</source>
          <target state="translated">X 축의 배율입니다.</target>
        </trans-unit>
        <trans-unit id="3a7eb990d9717a096b59f23c9f16c6e4b683c616" translate="yes" xml:space="preserve">
          <source>The scaling factor for the Y axis.</source>
          <target state="translated">Y 축의 배율입니다.</target>
        </trans-unit>
        <trans-unit id="89d8dcc47f8365825ea6126d81e398e4b7f2e12d" translate="yes" xml:space="preserve">
          <source>The scaling is needed for heights that include a fixed number of pixels, to scale them appropriately for printing.</source>
          <target state="translated">크기 조정은 고정 된 수의 픽셀을 포함하는 높이에 대해 인쇄에 맞게 크기를 조정하는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a86138ee24826207b1fafebc338f0148f3ca3f56" translate="yes" xml:space="preserve">
          <source>The scaling to be applied to the &lt;a href=&quot;qml-qtquick-wheelhandler#rotation-prop&quot;&gt;rotation&lt;/a&gt; property, and to the &lt;a href=&quot;qml-qtquick-wheelhandler#property-prop&quot;&gt;property&lt;/a&gt; on the &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target&lt;/a&gt; item, if any. The default is 1, such that &lt;a href=&quot;qml-qtquick-wheelhandler#rotation-prop&quot;&gt;rotation&lt;/a&gt; will be in units of degrees of rotation. It can be set to a negative number to invert the effect of the direction of mouse wheel rotation.</source>
          <target state="translated">The scaling to be applied to the &lt;a href=&quot;qml-qtquick-wheelhandler#rotation-prop&quot;&gt;rotation&lt;/a&gt; property, and to the &lt;a href=&quot;qml-qtquick-wheelhandler#property-prop&quot;&gt;property&lt;/a&gt; on the &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target&lt;/a&gt; item, if any. The default is 1, such that &lt;a href=&quot;qml-qtquick-wheelhandler#rotation-prop&quot;&gt;rotation&lt;/a&gt; will be in units of degrees of rotation. It can be set to a negative number to invert the effect of the direction of mouse wheel rotation.</target>
        </trans-unit>
        <trans-unit id="e477e58868476806857605cbc200accaea8db7a0" translate="yes" xml:space="preserve">
          <source>The scanline data is aligned on a 32-bit boundary.</source>
          <target state="translated">스캔 라인 데이터는 32 비트 경계에 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="10fb2f08157e21859c8a533abd5245d7ce06d450" translate="yes" xml:space="preserve">
          <source>The scanline data is as minimum 32-bit aligned. For 64-bit formats it follows the native alignment of 64-bit integers (64-bit for most platforms, but notably 32-bit on i386).</source>
          <target state="translated">스캔 라인 데이터는 최소 32 비트로 정렬됩니다. 64 비트 형식의 경우 64 비트 정수 (대부분의 플랫폼의 경우 64 비트, 특히 i386의 경우 32 비트)의 기본 정렬을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="046b8f5bdfe91a3545c5e4dcac152b7de3d7b8fa" translate="yes" xml:space="preserve">
          <source>The scatter data is displayed as a collection of points on the chart. For each point, two values are specified that determine its position on the horizontal axis and the vertical axis.</source>
          <target state="translated">산포 데이터는 차트에서 포인트 모음으로 표시됩니다. 각 점에 대해 가로 축과 세로 축에서의 위치를 ​​결정하는 두 개의 값이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="dc672ab30c7fc3eeb8150486e79b0c31461fd142" translate="yes" xml:space="preserve">
          <source>The scatter noise texture map. Default is a &lt;a href=&quot;qml-qtquick3d-texture&quot;&gt;Texture&lt;/a&gt; with source &lt;code&gt;&quot;maps/brushnoise.png&quot;&lt;/code&gt;.</source>
          <target state="translated">The scatter noise texture map. Default is a &lt;a href=&quot;qml-qtquick3d-texture&quot;&gt;Texture&lt;/a&gt; with source &lt;code&gt;&quot;maps/brushnoise.png&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5899ce19dfb79b4e75e7bad3e5dcac9db8918e60" translate="yes" xml:space="preserve">
          <source>The scene can be rotated, zoomed into, and a bar can be selected to view its value, but no other interaction is included in this minimal code example. You can learn more by familiarizing yourself with the examples provided, like the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdatavisualization-bars-example.html#&quot;&gt;Bars Example&lt;/a&gt;.</source>
          <target state="translated">값을보기 위해 장면을 회전하고 확대하고 막대를 선택할 수 있지만이 최소 코드 예제에는 다른 상호 작용이 포함되어 있지 않습니다. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdatavisualization-bars-example.html#&quot;&gt;Bars Example&lt;/a&gt; 과 같이 제공된 예제를 숙지하여 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b29c7ef58db565c3502f7feeacea854941991047" translate="yes" xml:space="preserve">
          <source>The scene can be rotated, zoomed into, and a bar can be selected to view its value, but no other interaction is included in this minimal code example. You can learn more by familiarizing yourself with the examples provided, like the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtdatavisualization-bars-example.html&quot;&gt;Bars Example&lt;/a&gt;.</source>
          <target state="translated">The scene can be rotated, zoomed into, and a bar can be selected to view its value, but no other interaction is included in this minimal code example. You can learn more by familiarizing yourself with the examples provided, like the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtdatavisualization-bars-example.html&quot;&gt;Bars Example&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2a040002c4ed1f762bcf304769897a99555b7a4e" translate="yes" xml:space="preserve">
          <source>The scene can be rotated, zoomed into, and a surface point can be selected to view its position, but no other interaction is included in this minimal code example. You can learn more by familiarizing yourself with the examples provided, like the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdatavisualization-surface-example.html#&quot;&gt;Surface Example&lt;/a&gt;.</source>
          <target state="translated">장면을 회전, 확대 및 표면 지점을 선택하여 위치를 볼 수 있지만이 최소 코드 예제에는 다른 상호 작용이 포함되어 있지 않습니다. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdatavisualization-surface-example.html#&quot;&gt;Surface 예제&lt;/a&gt; 와 같이 제공된 예제를 숙지하여 더 많은 것을 배울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5cfdfada0c80e56ba5ad8a2d6afeb90a24a167b" translate="yes" xml:space="preserve">
          <source>The scene can be rotated, zoomed into, and a surface point can be selected to view its position, but no other interaction is included in this minimal code example. You can learn more by familiarizing yourself with the examples provided, like the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtdatavisualization-surface-example.html&quot;&gt;Surface Example&lt;/a&gt;.</source>
          <target state="translated">The scene can be rotated, zoomed into, and a surface point can be selected to view its position, but no other interaction is included in this minimal code example. You can learn more by familiarizing yourself with the examples provided, like the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtdatavisualization-surface-example.html&quot;&gt;Surface Example&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2f099ff566957fa8fd8303dc9e21d2e966784ce2" translate="yes" xml:space="preserve">
          <source>The scene can be rotated, zoomed into, and an item can be selected to view its position, but no other interaction is included in this minimal code example. You can learn more by familiarizing yourself with the examples provided, like the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdatavisualization-scatter-example.html#&quot;&gt;Scatter Example&lt;/a&gt;.</source>
          <target state="translated">장면을 회전하고 확대하고 항목을 선택하여 위치를 볼 수 있지만이 최소 코드 예제에는 다른 상호 작용이 포함되어 있지 않습니다. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdatavisualization-scatter-example.html#&quot;&gt;Scatter Example&lt;/a&gt; 과 같이 제공된 예제를 숙지하여 자세한 내용을 배울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a7203e28727df2416eb58e5f1ed5e9c4f45039c" translate="yes" xml:space="preserve">
          <source>The scene can be rotated, zoomed into, and an item can be selected to view its position, but no other interaction is included in this minimal code example. You can learn more by familiarizing yourself with the examples provided, like the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtdatavisualization-scatter-example.html&quot;&gt;Scatter Example&lt;/a&gt;.</source>
          <target state="translated">The scene can be rotated, zoomed into, and an item can be selected to view its position, but no other interaction is included in this minimal code example. You can learn more by familiarizing yourself with the examples provided, like the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtdatavisualization-scatter-example.html&quot;&gt;Scatter Example&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="28457bfd2abced1839953597b8870db9c5a1ce21" translate="yes" xml:space="preserve">
          <source>The scene graph API is low-level and focuses on performance rather than convenience. Writing custom geometries and materials from scratch, even the most basic ones, requires a non-trivial amount of code. For this reason, the API includes a few convenience classes to make the most common custom nodes readily available.</source>
          <target state="translated">The scene graph API is low-level and focuses on performance rather than convenience. Writing custom geometries and materials from scratch, even the most basic ones, requires a non-trivial amount of code. For this reason, the API includes a few convenience classes to make the most common custom nodes readily available.</target>
        </trans-unit>
        <trans-unit id="29b647ef37c6189df4f409ff539a14e92ae58fd1" translate="yes" xml:space="preserve">
          <source>The scene graph API is very low-level and focuses on performance rather than convenience. Writing custom geometries and materials from scratch, even the most basic ones, requires a non-trivial amount of code. For this reason, the API includes a few convenience classes to make the most common custom nodes readily available.</source>
          <target state="translated">장면 그래프 API는 매우 저수준이며 편의성보다는 성능에 중점을 둡니다. 가장 기본적인 것부터 사용자 정의 형상과 재료를 처음부터 작성하려면 사소한 양의 코드가 필요합니다. 이러한 이유로 API에는 가장 일반적인 사용자 정의 노드를 쉽게 사용할 수 있도록 몇 가지 편의 클래스가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a109ea27b647ca47c2a3a4706848c73a5bae312" translate="yes" xml:space="preserve">
          <source>The scene graph can reorder geometry nodes to minimize state changes. The compare function is called during the sorting process so that the materials can be sorted to minimize state changes in each call to &lt;a href=&quot;qsgmaterialshader#updateState&quot;&gt;QSGMaterialShader::updateState&lt;/a&gt;().</source>
          <target state="translated">장면 그래프는 지오메트리 노드의 순서를 변경하여 상태 변경을 최소화 할 수 있습니다. &lt;a href=&quot;qsgmaterialshader#updateState&quot;&gt;QSGMaterialShader :: updateState&lt;/a&gt; () 에 대한 각 호출에서 상태 변경을 최소화하기 위해 재료를 정렬 할 수 있도록 정렬 프로세스 중에 비교 기능이 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="2120daa1fdfe82288b521446c5c16865ca7e0df2" translate="yes" xml:space="preserve">
          <source>The scene graph can support pseudo 3D and proper 3D primitives. For instance, one can implement a &quot;page curl&quot; effect using a &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt; or implement a bumpmapped torus using &lt;a href=&quot;qsggeometry&quot;&gt;QSGGeometry&lt;/a&gt; and a custom material. While doing so, one needs to take into account that the default renderer already makes use of the depth buffer.</source>
          <target state="translated">장면 그래프는 의사 3D 및 적절한 3D 프리미티브를 지원할 수 있습니다. 예를 들어, &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect를&lt;/a&gt; 사용하여 &quot;페이지 말림&quot;효과를 구현하거나 &lt;a href=&quot;qsggeometry&quot;&gt;QSGGeometry&lt;/a&gt; 및 사용자 정의 재료를 사용하여 범프 맵 토러스를 구현할 수 있습니다. 그렇게하는 동안 기본 렌더러가 이미 깊이 버퍼를 사용하고 있음을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="20c6ae896d3efacaba5d7c616a85f4da8f591dab" translate="yes" xml:space="preserve">
          <source>The scene graph has support for a number of logging categories. These can be useful in tracking down both performance issues and bugs in addition to being helpful to Qt contributors.</source>
          <target state="translated">장면 그래프는 다양한 로깅 범주를 지원합니다. 이는 Qt 기고자에게 도움이 될뿐만 아니라 성능 문제와 버그를 모두 추적하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee9ae7c7f82c9ce0f40cbee52503934e26bac6bf" translate="yes" xml:space="preserve">
          <source>The scene graph is a graphical representation of the Item scene, an independent structure that contains enough information to render all the items. Once it has been set up, it can be manipulated and rendered independently of the state of the items. On many platforms, the scene graph will even be rendered on a dedicated render thread while the GUI thread is preparing the next frame's state.</source>
          <target state="translated">장면 그래프는 모든 항목을 렌더링하기에 충분한 정보를 포함하는 독립적 인 구조 인 항목 장면의 그래픽 표현입니다. 일단 설정되면 항목의 상태와 독립적으로 조작하고 렌더링 할 수 있습니다. 많은 플랫폼에서 GUI 스레드가 다음 프레임의 상태를 준비하는 동안 장면 그래프가 전용 렌더링 스레드에서 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="d754d68a40b205538b685a1e7734461aeffac133" translate="yes" xml:space="preserve">
          <source>The scene graph is a graphical representation of the Item scene. It can be thought of as a graphical deep copy, an independent structure that contains enough information to render all the items.</source>
          <target state="translated">장면 그래프는 항목 장면을 그래픽으로 표현한 것입니다. 모든 항목을 렌더링하기에 충분한 정보가 포함 된 독립 구조 인 그래픽 딥 카피로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="650bee5e0077db979fe6b32aee77d708c2ec0449" translate="yes" xml:space="preserve">
          <source>The scene graph is closely tied to Qt Quick 2.0 and can not be used stand-alone. The scene graph is managed and rendered by the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; class and custom Item types can add their graphical primitives into the scene graph through a call to &lt;a href=&quot;qquickitem#updatePaintNode&quot;&gt;QQuickItem::updatePaintNode&lt;/a&gt;().</source>
          <target state="translated">장면 그래프는 Qt Quick 2.0과 밀접한 관련이 있으며 독립형으로 사용할 수 없습니다. 장면 그래프는 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 클래스에 의해 관리 및 렌더링되며 사용자 정의 항목 유형은 &lt;a href=&quot;qquickitem#updatePaintNode&quot;&gt;QQuickItem :: updatePaintNode&lt;/a&gt; ()를 호출하여 그래픽 프리미티브를 장면 그래프에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de4311cbb71c4dc37738c1867cc79db3eff8e98a" translate="yes" xml:space="preserve">
          <source>The scene graph is composed of a number of predefined node types, each serving a dedicated purpose. Although we refer to it as a scene graph, a more precise definition is node tree. The tree is built from &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; types in the QML scene and internally the scene is then processed by a renderer which draws the scene. The nodes themselves do &lt;b&gt;not&lt;/b&gt; contain any active drawing code nor virtual &lt;code&gt;paint()&lt;/code&gt; function.</source>
          <target state="translated">장면 그래프는 여러 가지 사전 정의 된 노드 유형으로 구성되며 각 노드는 전용 용도로 사용됩니다. 이것을 장면 그래프라고 부르지 만보다 정확한 정의는 노드 트리입니다. 트리는 QML 장면의 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 유형으로 빌드 되며 내부적으로 장면을 그리는 렌더러에서 장면을 처리합니다. 노드 자체 에는 활성 도면 코드 나 가상 &lt;code&gt;paint()&lt;/code&gt; 함수가 포함되어 있지 &lt;b&gt;않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="71ae958daf3ba9fb0794ed8d623a021330a76caf" translate="yes" xml:space="preserve">
          <source>The scene graph is invalidated; This can happen, for instance, if the window is hidden using &lt;a href=&quot;qwindow#hide&quot;&gt;QQuickWindow::hide&lt;/a&gt;(). If the item class implements a &lt;code&gt;slot&lt;/code&gt; named &lt;code&gt;invalidateSceneGraph()&lt;/code&gt;, this slot will be called on the rendering thread while the GUI thread is blocked. This is equivalent to connecting to &lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;QQuickWindow::sceneGraphInvalidated&lt;/a&gt;(). The OpenGL context of this item's window will be bound when this slot is called. The only exception is if the native OpenGL has been destroyed outside Qt's control, for instance through &lt;code&gt;EGL_CONTEXT_LOST&lt;/code&gt;.</source>
          <target state="translated">장면 그래프가 무효화되었습니다. 예를 들어, &lt;a href=&quot;qwindow#hide&quot;&gt;QQuickWindow :: hide&lt;/a&gt; ()를 사용하여 창이 숨겨져있는 경우에 발생할 수 있습니다 . 항목 클래스가 &lt;code&gt;invalidateSceneGraph()&lt;/code&gt; 라는 &lt;code&gt;slot&lt;/code&gt; 구현하는 경우이 스레드는 GUI 스레드가 차단되는 동안 렌더링 스레드에서 호출됩니다. 이것은 &lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;QQuickWindow :: sceneGraphInvalidated&lt;/a&gt; () 에 연결하는 것과 같습니다 . 이 슬롯이 호출되면이 항목 창의 OpenGL 컨텍스트가 바인딩됩니다. 유일한 예외는 네이티브 OpenGL이 Qt의 제어 외부에서 파괴 된 경우입니다 (예 : &lt;code&gt;EGL_CONTEXT_LOST&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="0797bae17b382355e23b495311b800fb60000003" translate="yes" xml:space="preserve">
          <source>The scene graph is rendered:</source>
          <target state="translated">장면 그래프가 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="f0ec912730456256572fad5bbf112ccc50414933" translate="yes" xml:space="preserve">
          <source>The scene graph nodes and resources are still released when the last &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; is deleted.</source>
          <target state="translated">씬 그래프 노드와 리소스는 마지막 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 가 삭제 될 때 여전히 해제 됩니다.</target>
        </trans-unit>
        <trans-unit id="2d3f640f04bb7b5c91299c8576649bfe2370ffad" translate="yes" xml:space="preserve">
          <source>The scene graph nodes and resources can be released to free up graphics resources when the window is obscured, hidden or not rendering. When this happens is implementation specific.</source>
          <target state="translated">윈도우가 가려 지거나 숨겨 지거나 렌더링되지 않을 때 그래픽 리소스를 확보하기 위해 장면 그래프 노드 및 리소스를 해제 할 수 있습니다. 이런 일이 발생하면 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d97f8ea14853699ac8c6a057feafb3125e82003f" translate="yes" xml:space="preserve">
          <source>The scene graph nodes contains a mechanism to describe which parts of the scene has changed. This includes the combined matrices, accumulated opacity, changes to the node hierarchy, and so on. This information can be used for optimizations inside the scene graph renderer. For the renderer to properly render the nodes, it is important that users call &lt;a href=&quot;qsgnode#markDirty&quot;&gt;QSGNode::markDirty&lt;/a&gt;() with the correct flags when nodes are changed. Most of the functions on the node classes will implicitly call &lt;a href=&quot;qsgnode#markDirty&quot;&gt;markDirty&lt;/a&gt;(). For example, &lt;a href=&quot;qsgnode#appendChildNode&quot;&gt;QSGNode::appendChildNode&lt;/a&gt;() will call &lt;a href=&quot;qsgnode#markDirty&quot;&gt;markDirty&lt;/a&gt;() passing in &lt;a href=&quot;qsgnode#DirtyStateBit-enum&quot;&gt;QSGNode::DirtyNodeAdded&lt;/a&gt;.</source>
          <target state="translated">장면 그래프 노드에는 장면의 어떤 부분이 변경되었는지 설명하는 메커니즘이 포함되어 있습니다. 여기에는 결합 된 행렬, 누적 된 불투명도, 노드 계층 구조 변경 등이 포함됩니다. 이 정보는 장면 그래프 렌더러 내부의 최적화에 사용될 수 있습니다. 렌더러가 노드를 올바르게 렌더링하려면 노드가 변경 될 때 사용자 가 올바른 플래그로 &lt;a href=&quot;qsgnode#markDirty&quot;&gt;QSGNode :: markDirty&lt;/a&gt; ()를 호출 해야합니다. 노드 클래스의 대부분의 함수는 암시 적으로 &lt;a href=&quot;qsgnode#markDirty&quot;&gt;markDirty&lt;/a&gt; ()를 호출 합니다. 예를 들어, &lt;a href=&quot;qsgnode#appendChildNode&quot;&gt;QSGNode :: appendChildNode&lt;/a&gt; ()는 &lt;a href=&quot;qsgnode#DirtyStateBit-enum&quot;&gt;QSGNode :: DirtyNodeAdded를&lt;/a&gt; 전달하는 &lt;a href=&quot;qsgnode#markDirty&quot;&gt;markDirty&lt;/a&gt; ()를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="f5159374a0ef222171b09e544dd69bd5a533dfbf" translate="yes" xml:space="preserve">
          <source>The scene graph offers two methods for integrating OpenGL content: by calling OpenGL commands directly and by creating a textured node in the scene graph.</source>
          <target state="translated">장면 그래프는 OpenGL 컨텐츠를 통합하는 두 가지 방법을 제공합니다. OpenGL 명령을 직접 호출하고 장면 그래프에서 텍스처 노드를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="5093ba26736ccfb25176e45efa7ce3adffd884e3" translate="yes" xml:space="preserve">
          <source>The scene graph offers two methods for integrating application-provided graphics commands: by issuing OpenGL, Vulkan, Metal, etc. commands directly, and by creating a textured node in the scene graph.</source>
          <target state="translated">The scene graph offers two methods for integrating application-provided graphics commands: by issuing OpenGL, Vulkan, Metal, etc. commands directly, and by creating a textured node in the scene graph.</target>
        </trans-unit>
        <trans-unit id="0730940a649c4a4bd872c62051369688c91d9e4c" translate="yes" xml:space="preserve">
          <source>The scene graph renderer in the D3D12 adaptation currently doesn't perform any batching. This is less of an issue, unlike OpenGL, because state changes don't present any problems in the first place. The simpler renderer logic can also lead to lower CPU overhead in some cases. The trade-offs between the various approaches are currently under research.</source>
          <target state="translated">D3D12 적응의 장면 그래프 렌더러는 현재 배치를 수행하지 않습니다. 상태 변경은 처음에는 아무런 문제가 없으므로 OpenGL과 달리 문제가되지 않습니다. 더 간단한 렌더러 로직은 경우에 따라 CPU 오버 헤드를 낮출 수도 있습니다. 다양한 접근법들 사이의 상충 관계는 현재 연구 중이다.</target>
        </trans-unit>
        <trans-unit id="32912754bebe83c7f023036ae323e182e9b11c87" translate="yes" xml:space="preserve">
          <source>The scene graph supports two types of antialiasing. By default, primitives such as rectangles and images will be antialiased by adding more vertices along the edge of the primitives so that the edges fade to transparent. We call this method</source>
          <target state="translated">장면 그래프는 두 가지 유형의 앤티 앨리어싱을 지원합니다. 기본적으로 사각형 및 이미지와 같은 기본 요소는 기본 요소의 가장자리를 따라 더 많은 정점을 추가하여 가장자리가 투명 해 지도록 앤티 앨리어싱됩니다. 우리는이 방법을 호출</target>
        </trans-unit>
        <trans-unit id="4ca5e18a8ee70f4cc8cb6f5cf84ec0a9f1390a88" translate="yes" xml:space="preserve">
          <source>The scene graph used for rendering in &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-qmlmodule.html&quot;&gt;QtQuick&lt;/a&gt; 2 allows highly dynamic, animated user interfaces to be rendered fluidly at 60 FPS. There are some things which can dramatically decrease rendering performance, however, and developers should be careful to avoid these pitfalls wherever possible.</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-qmlmodule.html&quot;&gt;QtQuick&lt;/a&gt; 2 에서 렌더링에 사용되는 장면 그래프를 통해 60FPS에서 매우 역동적 인 애니메이션 사용자 인터페이스를 유동적으로 렌더링 할 수 있습니다. 렌더링 성능을 크게 저하시킬 수있는 몇 가지 사항이 있지만 개발자는 가능한 한 이러한 함정을 피하도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="b8d46eed28b2adaca415281ac0d006ebfcce4587" translate="yes" xml:space="preserve">
          <source>The scene graph used for rendering in &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-module.html&quot;&gt;QtQuick&lt;/a&gt; 2 allows highly dynamic, animated user interfaces to be rendered fluidly at 60 FPS. There are some things which can dramatically decrease rendering performance, however, and developers should be careful to avoid these pitfalls wherever possible.</source>
          <target state="translated">The scene graph used for rendering in &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-module.html&quot;&gt;QtQuick&lt;/a&gt; 2 allows highly dynamic, animated user interfaces to be rendered fluidly at 60 FPS. There are some things which can dramatically decrease rendering performance, however, and developers should be careful to avoid these pitfalls wherever possible.</target>
        </trans-unit>
        <trans-unit id="74bc8a578c58450a866ceb5169a1b666544d0fdb" translate="yes" xml:space="preserve">
          <source>The scene graph uses heuristics to figure out how large the atlas should be and what the size threshold for being entered into the atlas is. If different values are needed, it is possible to override them using the environment variables &lt;code&gt;QSG_ATLAS_WIDTH=[width]&lt;/code&gt;, &lt;code&gt;QSG_ATLAS_HEIGHT=[height]&lt;/code&gt; and &lt;code&gt;QSG_ATLAS_SIZE_LIMIT=[size]&lt;/code&gt;. Changing these values will mostly be interesting for platform vendors.</source>
          <target state="translated">장면 그래프는 휴리스틱을 사용하여 아틀라스의 크기와 아틀라스에 입력하기위한 크기 임계 값을 파악합니다. 다른 값이 필요한 경우 환경 변수 &lt;code&gt;QSG_ATLAS_WIDTH=[width]&lt;/code&gt; , &lt;code&gt;QSG_ATLAS_HEIGHT=[height]&lt;/code&gt; 및 &lt;code&gt;QSG_ATLAS_SIZE_LIMIT=[size]&lt;/code&gt; 를 사용하여 값을 대체 할 수 있습니다 . 이러한 값을 변경하는 것은 플랫폼 공급 업체에게 주로 흥미로운 일입니다.</target>
        </trans-unit>
        <trans-unit id="a21dc2b647ad1bebc75814899d5a687105e57f2a" translate="yes" xml:space="preserve">
          <source>The scene graph uses the OpenGL context and will both rely on and clobber its state. When mixing raw OpenGL commands with scene graph rendering, this function provides a convenient way of resetting the OpenGL context state back to its default values.</source>
          <target state="translated">장면 그래프는 OpenGL 컨텍스트를 사용하며 해당 상태에 의존하고 클로버합니다. 원시 OpenGL 명령을 장면 그래프 렌더링과 혼합 할 때이 함수는 OpenGL 컨텍스트 상태를 기본값으로 재설정하는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bd844a57ce83ff2ff678ae4e7cf8e850d9e3d250" translate="yes" xml:space="preserve">
          <source>The scene graph will often try to find materials that have the same or at least similar state so that these can be batched together inside the renderer, which gives better performance. To specify sortable material states, use &lt;a href=&quot;qsgsimplematerialshader#QSG_DECLARE_SIMPLE_COMPARABLE_SHADER&quot;&gt;QSG_DECLARE_SIMPLE_COMPARABLE_SHADER&lt;/a&gt; instead of &lt;a href=&quot;qsgsimplematerialshader#QSG_DECLARE_SIMPLE_SHADER&quot;&gt;QSG_DECLARE_SIMPLE_SHADER&lt;/a&gt;. The state struct must then also define the function:</source>
          <target state="translated">장면 그래프는 종종 렌더러 내에서 함께 배치되어 더 나은 성능을 제공 할 수 있도록 동일하거나 적어도 유사한 상태의 재질을 찾으려고합니다. 정렬 가능한 재료 상태를 지정하려면 &lt;a href=&quot;qsgsimplematerialshader#QSG_DECLARE_SIMPLE_COMPARABLE_SHADER&quot;&gt;QSG_DECLARE_SIMPLE_SHADER&lt;/a&gt; 대신 QSG_DECLARE_SIMPLE_COMPARABLE_SHADER 를 사용 &lt;a href=&quot;qsgsimplematerialshader#QSG_DECLARE_SIMPLE_SHADER&quot;&gt;하십시오&lt;/a&gt; . 상태 구조체는 다음 함수도 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="779ff4be4003300b06598b96a66d2e07b028c602" translate="yes" xml:space="preserve">
          <source>The scene is cleared to be transparent. This is useful to render 3D content on top of another item.</source>
          <target state="translated">The scene is cleared to be transparent. This is useful to render 3D content on top of another item.</target>
        </trans-unit>
        <trans-unit id="3cc271b96e7f376a8247002409abe26a38a4d34e" translate="yes" xml:space="preserve">
          <source>The scene is cleared with the color specified by the &lt;a href=&quot;qml-qtquick3d-sceneenvironment#clearColor-prop&quot;&gt;clearColor&lt;/a&gt; property.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick3d-sceneenvironment#clearColor-prop&quot;&gt;clearColor&lt;/a&gt; 속성에 지정된 색상으로 장면이 지워집니다 .</target>
        </trans-unit>
        <trans-unit id="bff2984fd63f49eb1c53e71937a07728683a024d" translate="yes" xml:space="preserve">
          <source>The scene is rendered in a higher resolution, and then scaled down to actual resolution.</source>
          <target state="translated">장면은 더 높은 해상도로 렌더링 된 다음 실제 해상도로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="73d3765887e51113a92f7d13cf138f154f54195e" translate="yes" xml:space="preserve">
          <source>The scene point at the center of the view is used as the anchor.</source>
          <target state="translated">뷰 중앙의 장면 포인트가 앵커로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6d940fcd2d063c65edd14f6e3887e0e92ab6aad6" translate="yes" xml:space="preserve">
          <source>The scene position is the position in &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; coordinates if the &lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent&lt;/a&gt; is handled by a QGraphicsItem::touchEvent() reimplementation, and identical to the screen position for widgets.</source>
          <target state="translated">장면 위치는 &lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent&lt;/a&gt; 가 QGraphicsItem :: touchEvent () 재 구현에 의해 처리되고 위젯의 화면 위치와 동일한 경우 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 좌표의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="493ce714e7fd2d3d647c6a05bdb0abc209b0830c" translate="yes" xml:space="preserve">
          <source>The scene rectangle defines the extent of the scene, and in the view's case, this means the area of the scene that you can navigate using the scroll bars.</source>
          <target state="translated">장면 사각형은 장면의 범위를 정의하며 뷰의 경우 스크롤 막대를 사용하여 탐색 할 수있는 장면 영역을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ca8c30145c0f044229a1203a2eed333a9216a630" translate="yes" xml:space="preserve">
          <source>The scene rectangle defines the extent of the scene. It is primarily used by &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; to determine the view's default scrollable area, and by &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; to manage item indexing.</source>
          <target state="translated">장면 사각형은 장면의 범위를 정의합니다. 주로 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 에서보기의 기본 스크롤 가능 영역을 결정하고 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 에서 항목 인덱싱을 관리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="14e679e1910e0d48c0ece84eaa0dbc19143ad44a" translate="yes" xml:space="preserve">
          <source>The scene represents the base coordinate system for all its items. The scene coordinate system describes the position of each top-level item, and also forms the basis for all scene events delivered to the scene from the view. Each item on the scene has a scene position and bounding rectangle (&lt;a href=&quot;qgraphicsitem#scenePos&quot;&gt;QGraphicsItem::scenePos&lt;/a&gt;(), &lt;a href=&quot;qgraphicsitem#sceneBoundingRect&quot;&gt;QGraphicsItem::sceneBoundingRect&lt;/a&gt;()), in addition to its local item pos and bounding rectangle. The scene position describes the item's position in scene coordinates, and its scene bounding rect forms the basis for how &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; determines what areas of the scene have changed. Changes in the scene are communicated through the &lt;a href=&quot;qgraphicsscene#changed&quot;&gt;QGraphicsScene::changed&lt;/a&gt;() signal, and the argument is a list of scene rectangles.</source>
          <target state="translated">장면은 모든 항목의 기본 좌표계를 나타냅니다. 장면 좌표계는 각 최상위 항목의 위치를 ​​설명하고보기에서 장면으로 전달되는 모든 장면 이벤트의 기초를 형성합니다. 장면의 각 항목에는 로컬 항목 위치 및 경계 사각형 외에 장면 위치 및 경계 사각형 ( &lt;a href=&quot;qgraphicsitem#scenePos&quot;&gt;QGraphicsItem :: scenePos&lt;/a&gt; (), &lt;a href=&quot;qgraphicsitem#sceneBoundingRect&quot;&gt;QGraphicsItem :: sceneBoundingRect&lt;/a&gt; ())이 있습니다. 장면 위치는 장면 좌표에서 항목의 위치를 ​​설명하고 장면 경계 사각형은 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 이 장면의 어떤 영역이 변경되었는지를 결정 하는 기준을 형성합니다 . 장면의 변경 사항은 &lt;a href=&quot;qgraphicsscene#changed&quot;&gt;QGraphicsScene :: changed&lt;/a&gt; () 신호를 통해 전달되며 인수는 장면 사각형의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="faf265453acfa34c6e03d0501fbdb23a4e546b5d" translate="yes" xml:space="preserve">
          <source>The scene sends the event to the first &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; under the mouse cursor that accepts drops; a graphics item is set to accept drops with &lt;a href=&quot;qgraphicsitem#setAcceptDrops&quot;&gt;setAcceptDrops()&lt;/a&gt;.</source>
          <target state="translated">장면 은 드롭을 허용하는 마우스 커서 아래의 첫 번째 &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 으로 이벤트를 보냅니다 . 그래픽 항목은 &lt;a href=&quot;qgraphicsitem#setAcceptDrops&quot;&gt;setAcceptDrops ()를 사용&lt;/a&gt; 하여 드랍을 허용하도록 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b90f80f12389caec0864fb23ccc5c35faf653fd2" translate="yes" xml:space="preserve">
          <source>The scene serves as a container for &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; objects. Items are added to the scene by calling &lt;a href=&quot;qgraphicsscene#addItem&quot;&gt;QGraphicsScene::addItem&lt;/a&gt;(), and then retrieved by calling one of the many item discovery functions. &lt;a href=&quot;qgraphicsscene#items&quot;&gt;QGraphicsScene::items&lt;/a&gt;() and its overloads return all items contained by or intersecting with a point, a rectangle, a polygon or a general vector path. &lt;a href=&quot;qgraphicsscene#itemAt&quot;&gt;QGraphicsScene::itemAt&lt;/a&gt;() returns the topmost item at a particular point. All item discovery functions return the items in descending stacking order (i.e., the first returned item is topmost, and the last item is bottom-most).</source>
          <target state="translated">장면은 &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 객체 의 컨테이너 역할을 합니다. &lt;a href=&quot;qgraphicsscene#addItem&quot;&gt;QGraphicsScene :: addItem&lt;/a&gt; () 을 호출하여 장면에 항목을 추가 한 다음 많은 항목 검색 기능 중 하나를 호출하여 검색합니다. &lt;a href=&quot;qgraphicsscene#items&quot;&gt;QGraphicsScene :: items&lt;/a&gt; () 및 해당 과부하는 점, 사각형, 다각형 또는 일반 벡터 경로에 포함되거나 그와 교차하는 모든 항목을 반환합니다. &lt;a href=&quot;qgraphicsscene#itemAt&quot;&gt;QGraphicsScene :: itemAt&lt;/a&gt; ()는 특정 지점에서 최상위 항목을 반환합니다. 모든 항목 검색 기능은 항목을 내림차순으로 내림차순으로 반환합니다 (즉, 첫 번째로 반환 된 항목이 맨 위이고 마지막 항목이 맨 아래에 있음).</target>
        </trans-unit>
        <trans-unit id="560cf226c56b08d3d2c44acc771a9e9b4a08f6c5" translate="yes" xml:space="preserve">
          <source>The scene will not be cleared, but instead a Skybox or Skydome will be rendered. The Skybox is defined using the HDRI map defined in the &lt;a href=&quot;qml-qtquick3d-sceneenvironment#lightProbe-prop&quot;&gt;lightProbe&lt;/a&gt; property.</source>
          <target state="translated">장면은 지워지지 않지만 대신 Skybox 또는 Skydome이 렌더링됩니다. Skybox는 &lt;a href=&quot;qml-qtquick3d-sceneenvironment#lightProbe-prop&quot;&gt;lightProbe&lt;/a&gt; 속성에 정의 된 HDRI 맵을 사용하여 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="feb5e420ae4b761c7f72b4e5dbb74bc87634de18" translate="yes" xml:space="preserve">
          <source>The scene's bounding rect is set by calling &lt;a href=&quot;qgraphicsscene#sceneRect-prop&quot;&gt;setSceneRect&lt;/a&gt;(). Items can be placed at any position on the scene, and the size of the scene is by default unlimited. The scene rect is used only for internal bookkeeping, maintaining the scene's item index. If the scene rect is unset, &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; will use the bounding area of all items, as returned by &lt;a href=&quot;qgraphicsscene#itemsBoundingRect&quot;&gt;itemsBoundingRect&lt;/a&gt;(), as the scene rect. However, &lt;a href=&quot;qgraphicsscene#itemsBoundingRect&quot;&gt;itemsBoundingRect&lt;/a&gt;() is a relatively time consuming function, as it operates by collecting positional information for every item on the scene. Because of this, you should always set the scene rect when operating on large scenes.</source>
          <target state="translated">장면의 경계 &lt;a href=&quot;qgraphicsscene#sceneRect-prop&quot;&gt;사각형은 setSceneRect&lt;/a&gt; () 를 호출하여 설정됩니다 . 항목은 장면의 어느 위치 에나 배치 할 수 있으며 장면의 크기는 기본적으로 무제한입니다. 장면 rect는 장면의 항목 인덱스를 유지하면서 내부 부기에만 사용됩니다. 장면 rect가 설정되어 있지 않으면 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 은 &lt;a href=&quot;qgraphicsscene#itemsBoundingRect&quot;&gt;itemsBoundingRect&lt;/a&gt; ()에 의해 반환 된 모든 항목의 경계 영역을 장면 rect로 사용합니다. 그러나 &lt;a href=&quot;qgraphicsscene#itemsBoundingRect&quot;&gt;itemsBoundingRect&lt;/a&gt; ()는 장면의 모든 항목에 대한 위치 정보를 수집하여 작동하므로 상대적으로 시간이 많이 걸리는 기능입니다. 이 때문에 큰 장면에서 작업 할 때는 항상 장면을 rect로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="095218fcf3465381ffb3c4a5cdc9726f92e0a996" translate="yes" xml:space="preserve">
          <source>The scene's bounding rect is set by calling &lt;a href=&quot;qgraphicsscene#sceneRect-prop&quot;&gt;setSceneRect&lt;/a&gt;(). Items can be placed at any position on the scene, and the size of the scene is by default unlimited. The scene rect is used only for internal bookkeeping, maintaining the scene's item index. If the scene rect is unset, QGraphicsScene will use the bounding area of all items, as returned by &lt;a href=&quot;qgraphicsscene#itemsBoundingRect&quot;&gt;itemsBoundingRect&lt;/a&gt;(), as the scene rect. However, &lt;a href=&quot;qgraphicsscene#itemsBoundingRect&quot;&gt;itemsBoundingRect&lt;/a&gt;() is a relatively time consuming function, as it operates by collecting positional information for every item on the scene. Because of this, you should always set the scene rect when operating on large scenes.</source>
          <target state="translated">장면의 경계 &lt;a href=&quot;qgraphicsscene#sceneRect-prop&quot;&gt;사각형은 setSceneRect&lt;/a&gt; () 를 호출하여 설정됩니다 . 항목은 장면의 모든 위치에 배치 할 수 있으며 장면의 크기는 기본적으로 무제한입니다. 장면 직사각형은 장면의 항목 색인을 유지하면서 내부 부기에만 사용됩니다. 장면 사각형이 설정되지 않은 경우 QGraphicsScene은 &lt;a href=&quot;qgraphicsscene#itemsBoundingRect&quot;&gt;itemsBoundingRect&lt;/a&gt; ()에서 반환 된 모든 항목의 경계 영역을 장면 사각형 으로 사용합니다. 그러나 &lt;a href=&quot;qgraphicsscene#itemsBoundingRect&quot;&gt;itemsBoundingRect&lt;/a&gt; ()는 장면의 모든 항목에 대한 위치 정보를 수집하여 작동하므로 상대적으로 시간이 많이 걸리는 함수입니다. 이 때문에 큰 장면에서 작업 할 때는 항상 장면 사각형을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf44509ce4eff91ea4d1d9a0c82ce331c9190820" translate="yes" xml:space="preserve">
          <source>The scheme can also be empty, in which case the URL is interpreted as relative.</source>
          <target state="translated">스킴은 비어있을 수 있으며이 경우 URL은 상대로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="e6aaa5284a07d7e3032c5af3e0ce360264fefa0d" translate="yes" xml:space="preserve">
          <source>The scheme can only contain US-ASCII letters or digits, which means it cannot contain any character that would otherwise require encoding. Additionally, schemes are always returned in lowercase form.</source>
          <target state="translated">이 체계는 US-ASCII 문자 나 숫자 만 포함 할 수 있으므로 인코딩이 필요한 문자를 포함 할 수 없습니다. 또한 체계는 항상 소문자 형식으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4f936343d9419d2ee94994ec47eb20be29408955" translate="yes" xml:space="preserve">
          <source>The scheme describes the type (or protocol) of the URL. It's represented by one or more ASCII characters at the start the URL.</source>
          <target state="translated">체계는 URL의 유형 (또는 프로토콜)을 설명합니다. URL 시작시 하나 이상의 ASCII 문자로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="55bb1521ab34a320795b09d7534d3fef0f762a54" translate="yes" xml:space="preserve">
          <source>The scheme is removed from the URL.</source>
          <target state="translated">URL에서 구성표가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="d88de68ed0ef54a66fcf408a9359ef0bf1ce3b98" translate="yes" xml:space="preserve">
          <source>The scope for customizing the painting behavior of standard Qt widgets, without resorting to subclassing, is slightly less than that possible for custom widgets. Usually, the desired appearance of a standard widget can be achieved by setting its &lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;autoFillBackground&lt;/a&gt; property.</source>
          <target state="translated">서브 클래 싱에 의존하지 않고 표준 Qt 위젯의 페인팅 동작을 사용자 정의하는 범위는 사용자 정의 위젯에서 가능한 것보다 약간 작습니다. 일반적으로 &lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;autoFillBackground&lt;/a&gt; 속성 을 설정하여 표준 위젯의 원하는 모양을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c2d3c118939966273c2a57e29638f371d385719" translate="yes" xml:space="preserve">
          <source>The scope in the above snippet modifies the build target in each mode to ensure that the resulting targets have different names. Providing different names for targets ensures that one will not overwrite the other.</source>
          <target state="translated">위 스 니펫의 범위는 각 모드에서 빌드 대상을 수정하여 결과 대상이 다른 이름을 갖도록합니다. 대상에 다른 이름을 제공하면 한 대상이 다른 대상을 덮어 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1cf757056e0c0649131bcbcd5247e19be67fd4d1" translate="yes" xml:space="preserve">
          <source>The scope is &lt;a href=&quot;qsettings#Scope-enum&quot;&gt;QSettings::UserScope&lt;/a&gt; and the format is &lt;a href=&quot;qsettings#defaultFormat&quot;&gt;defaultFormat&lt;/a&gt;() (&lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings::NativeFormat&lt;/a&gt; by default). Use &lt;a href=&quot;qsettings#setDefaultFormat&quot;&gt;setDefaultFormat&lt;/a&gt;() before calling this constructor to change the default format used by this constructor.</source>
          <target state="translated">범위는 &lt;a href=&quot;qsettings#Scope-enum&quot;&gt;QSettings :: UserScope&lt;/a&gt; 이며 형식은 &lt;a href=&quot;qsettings#defaultFormat&quot;&gt;defaultFormat&lt;/a&gt; ()입니다 ( 기본적으로 &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings :: NativeFormat&lt;/a&gt; ). 이 생성자가 호출하기 전에 &lt;a href=&quot;qsettings#setDefaultFormat&quot;&gt;setDefaultFormat&lt;/a&gt; ()을 사용 하여이 생성자가 사용하는 기본 형식을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="e82b8abbaa5c8494f2cb29a0f4748e568ee59c76" translate="yes" xml:space="preserve">
          <source>The scope is set to &lt;a href=&quot;qsettings#Scope-enum&quot;&gt;QSettings::UserScope&lt;/a&gt;, and the format is set to &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings::NativeFormat&lt;/a&gt; (i.e. calling &lt;a href=&quot;qsettings#setDefaultFormat&quot;&gt;setDefaultFormat&lt;/a&gt;() before calling this constructor has no effect).</source>
          <target state="translated">범위는 &lt;a href=&quot;qsettings#Scope-enum&quot;&gt;QSettings :: UserScope&lt;/a&gt; 로 설정되고 형식은 &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings :: NativeFormat으로&lt;/a&gt; 설정됩니다 (즉, 이 생성자를 호출하기 전에 &lt;a href=&quot;qsettings#setDefaultFormat&quot;&gt;setDefaultFormat&lt;/a&gt; ()을 호출해도 효과가 없습니다).</target>
        </trans-unit>
        <trans-unit id="7468e7a6014216341825e17c83669985adb85d95" translate="yes" xml:space="preserve">
          <source>The screen is inherited from the parent.</source>
          <target state="translated">화면은 부모에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="97c635e02dec3e851595e6147c97f20f8dd4ed86" translate="yes" xml:space="preserve">
          <source>The screen orientation represents the physical orientation of the display. For example, the screen orientation of a mobile device will change based on how it is being held. A change to the orientation might or might not trigger a change to the primary orientation of the screen.</source>
          <target state="translated">화면 방향은 디스플레이의 물리적 방향을 나타냅니다. 예를 들어, 모바일 장치의 화면 방향은 개최 방법에 따라 변경됩니다. 방향을 변경하면 화면의 기본 방향이 변경되거나 트리거되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0433db79b0f7ea1e7269ab13c3208af1ab81f23c" translate="yes" xml:space="preserve">
          <source>The screen with which the window is associated.</source>
          <target state="translated">창이 연관된 화면.</target>
        </trans-unit>
        <trans-unit id="3bb3c3f495d57057a0c7e87148e895ec1b64f69d" translate="yes" xml:space="preserve">
          <source>The screen-occupation state of the window.</source>
          <target state="translated">창의 화면 점유 상태입니다.</target>
        </trans-unit>
        <trans-unit id="fe445e6fe630f99384b773302b09e136ca6a48dc" translate="yes" xml:space="preserve">
          <source>The screens orientation has changes (&lt;a href=&quot;qscreenorientationchangeevent&quot;&gt;QScreenOrientationChangeEvent&lt;/a&gt;).</source>
          <target state="translated">화면 방향이 변경되었습니다 ( &lt;a href=&quot;qscreenorientationchangeevent&quot;&gt;QScreenOrientationChangeEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bd626704a3311b9efe2e898c51ecde0aa557e1ed" translate="yes" xml:space="preserve">
          <source>The screenshot below shows the breakdown of a basic user interface designed using a grid. The coordinates on the screenshot show the position of each widget within the grid.</source>
          <target state="translated">아래 스크린 샷은 그리드를 사용하여 설계된 기본 사용자 인터페이스의 분석을 보여줍니다. 스크린 샷의 좌표는 그리드 내 각 위젯의 위치를 ​​보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6c640b9d90bc351fb6570639fc92baf6e714f606" translate="yes" xml:space="preserve">
          <source>The screenshot on the left shows a plain &lt;a href=&quot;qsqltablemodel&quot;&gt;QSqlTableModel&lt;/a&gt; in a &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;. Foreign keys (&lt;code&gt;city&lt;/code&gt; and &lt;code&gt;country&lt;/code&gt;) aren't resolved to human-readable values. The screenshot on the right shows a &lt;a href=&quot;qsqlrelationaltablemodel&quot;&gt;QSqlRelationalTableModel&lt;/a&gt;, with foreign keys resolved into human-readable text strings.</source>
          <target state="translated">왼쪽 쇼의 스크린 샷 일반 &lt;a href=&quot;qsqltablemodel&quot;&gt;QSqlTableModel&lt;/a&gt; A의 &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt; . 외래 키 ( &lt;code&gt;city&lt;/code&gt; 및 &lt;code&gt;country&lt;/code&gt; )는 사람이 읽을 수있는 값으로 해석되지 않습니다. 오른쪽의 스크린 샷은 외래 키를 사람이 읽을 수있는 텍스트 문자열로 &lt;a href=&quot;qsqlrelationaltablemodel&quot;&gt;확인한 QSqlRelationalTableModel을&lt;/a&gt; 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="04ca514762d47ac2ca1363d9c21c8d6cc15731f9" translate="yes" xml:space="preserve">
          <source>The screenshot on the left shows a plain &lt;a href=&quot;qsqltablemodel&quot;&gt;QSqlTableModel&lt;/a&gt; in a &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;. Foreign keys (&lt;code&gt;city&lt;/code&gt; and &lt;code&gt;country&lt;/code&gt;) aren't resolved to human-readable values. The screenshot on the right shows a QSqlRelationalTableModel, with foreign keys resolved into human-readable text strings.</source>
          <target state="translated">왼쪽 쇼의 스크린 샷 일반 &lt;a href=&quot;qsqltablemodel&quot;&gt;QSqlTableModel&lt;/a&gt; A의 &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt; . 외래 키 ( &lt;code&gt;city&lt;/code&gt; 및 &lt;code&gt;country&lt;/code&gt; )는 사람이 읽을 수있는 값으로 확인되지 않습니다. 오른쪽의 스크린 샷은 외래 키가 사람이 읽을 수있는 텍스트 문자열로 확인 된 QSqlRelationalTableModel을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5c6bd966a06f6a2b55f66a745cf7dd9571a41f35" translate="yes" xml:space="preserve">
          <source>The script can execute code and is connected so that it can handle events</source>
          <target state="translated">스크립트는 코드를 실행할 수 있고 이벤트를 처리 할 수 ​​있도록 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="20c4a9f45dbea7c04b698f8d64d4c08b4a6fc5e4" translate="yes" xml:space="preserve">
          <source>The script can execute code, but does not yet handle events</source>
          <target state="translated">스크립트는 코드를 실행할 수 있지만 아직 이벤트를 처리하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="89f79789f606f654a461bf98c7d7662a724d58dd" translate="yes" xml:space="preserve">
          <source>The script code will be evaluated in the context of the global object.</source>
          <target state="translated">스크립트 코드는 전역 객체의 컨텍스트에서 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="8ca21b31af718151d11d0c7d0580239f959acf7b" translate="yes" xml:space="preserve">
          <source>The script engine used is determined from the file's extension. By default &quot;.js&quot; files are interpreted as JScript files, and &quot;.vbs&quot; and &quot;.dsm&quot; files are interpreted as VBScript. Additional script engines can be registered using &lt;a href=&quot;qaxscriptmanager#registerEngine&quot;&gt;registerEngine&lt;/a&gt;().</source>
          <target state="translated">사용 된 스크립트 엔진은 파일 확장자에 따라 결정됩니다. 기본적으로 &quot;.js&quot;파일은 JScript 파일로 해석되고 &quot;.vbs&quot;및 &quot;.dsm&quot;파일은 VBScript로 해석됩니다. &lt;a href=&quot;qaxscriptmanager#registerEngine&quot;&gt;registerEngine&lt;/a&gt; ()을 사용하여 추가 스크립트 엔진을 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01d48bc106daf312c26b8330f6da6701a25e22e4" translate="yes" xml:space="preserve">
          <source>The script engine will be used when loading files with the given</source>
          <target state="translated">주어진 파일을로드 할 때 스크립트 엔진이 사용됩니다</target>
        </trans-unit>
        <trans-unit id="52d511d98ad324361603795d979a18e2afbada60" translate="yes" xml:space="preserve">
          <source>The script has been closed.</source>
          <target state="translated">스크립트가 닫혔습니다.</target>
        </trans-unit>
        <trans-unit id="4b2f190fb55cfe75925623e58522a31af0f551cf" translate="yes" xml:space="preserve">
          <source>The script has been created, but not yet initialized</source>
          <target state="translated">스크립트가 작성되었지만 아직 초기화되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="50ea86efb19eeb4baf46fbce374b72fa267be8ff" translate="yes" xml:space="preserve">
          <source>The script has been initialized, but is not running</source>
          <target state="translated">스크립트가 초기화되었지만 실행되고 있지 않습니다</target>
        </trans-unit>
        <trans-unit id="6a93312b0c43268af263f87da3fb3a8b70c0c714" translate="yes" xml:space="preserve">
          <source>The script is loaded, but is not connected to event sources</source>
          <target state="translated">스크립트가로드되었지만 이벤트 소스에 연결되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="e071d098280a0b3c3227958571040210bdd74547" translate="yes" xml:space="preserve">
          <source>The script provides &lt;a href=&quot;qaxscript#scriptEngine&quot;&gt;scriptEngine&lt;/a&gt;() provides feedback to the application through signals. The most important signal is the &lt;a href=&quot;qaxscript#error&quot;&gt;error&lt;/a&gt;() signal. Direct access to the &lt;a href=&quot;qaxscriptengine&quot;&gt;QAxScriptEngine&lt;/a&gt; is provided through the &lt;a href=&quot;qaxscript#scriptEngine&quot;&gt;scriptEngine&lt;/a&gt;() function.</source>
          <target state="translated">스크립트는 &lt;a href=&quot;qaxscript#scriptEngine&quot;&gt;scriptEngine&lt;/a&gt; ()을 제공하여 신호를 통해 애플리케이션에 피드백을 제공합니다. 가장 중요한 신호는 &lt;a href=&quot;qaxscript#error&quot;&gt;오류&lt;/a&gt; () 신호입니다. &lt;a href=&quot;qaxscriptengine&quot;&gt;QAxScriptEngine에&lt;/a&gt; 대한 직접 액세스 는 &lt;a href=&quot;qaxscript#scriptEngine&quot;&gt;scriptEngine&lt;/a&gt; () 함수를 통해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a9c3f3a69299b4715b39f0caddfe667d4bf188b" translate="yes" xml:space="preserve">
          <source>The script will be executed as soon as the document is created. This is not suitable for any DOM operation.</source>
          <target state="translated">문서가 생성 되 자마자 스크립트가 실행됩니다. 이것은 모든 DOM 작업에 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6514e1b825f4cbe96d69a069419ecaa4262c498e" translate="yes" xml:space="preserve">
          <source>The script will run as soon as the DOM is ready. This is equivalent to the &lt;code&gt;DOMContentLoaded&lt;/code&gt; event firing in JavaScript.</source>
          <target state="translated">DOM이 준비 되 자마자 스크립트가 실행됩니다. 이것은 JavaScript에서 &lt;code&gt;DOMContentLoaded&lt;/code&gt; 이벤트 발생 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="e58d96605eabb6534beb4fbd671d63dda3ff8317" translate="yes" xml:space="preserve">
          <source>The script will run in the same</source>
          <target state="translated">스크립트는 동일하게 실행됩니다</target>
        </trans-unit>
        <trans-unit id="1dcb36c75d814f57c89a2fb24247f51d5c7d27fa" translate="yes" xml:space="preserve">
          <source>The script will run when the page load finishes, or 500 ms after the document is ready, whichever comes first.</source>
          <target state="translated">스크립트는 페이지로드가 완료 될 때 또는 문서가 준비된 후 500ms 중 빠른 시간에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="15026690856d93a3e48ff369ba1670acb146ec0a" translate="yes" xml:space="preserve">
          <source>The script will run when the page load finishes, or 500ms after the document is ready, whichever comes first.</source>
          <target state="translated">스크립트는 페이지로드가 완료 될 때 또는 문서가 준비된 후 500ms 중 빠른 시간에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f5b95dd2c907ac3cad6780ba37c72c7c34652bab" translate="yes" xml:space="preserve">
          <source>The scroll area is currently following the touch point or mouse.</source>
          <target state="translated">스크롤 영역이 현재 터치 포인트 또는 마우스를 따르고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a355063775512859b973385737c1a49c46579730" translate="yes" xml:space="preserve">
          <source>The scroll area is moving on it's own.</source>
          <target state="translated">스크롤 영역이 자체적으로 움직입니다.</target>
        </trans-unit>
        <trans-unit id="5c56f1d856db7f65871b759f2b727c6de0bbf1d6" translate="yes" xml:space="preserve">
          <source>The scroll area will adjust to its viewport the first time it is shown.</source>
          <target state="translated">스크롤 영역은 처음 표시 될 때 뷰포트에 맞게 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="4903a40c5e6e4739030e9eee6c35f3fdfbf0151a" translate="yes" xml:space="preserve">
          <source>The scroll area will always adjust to the viewport</source>
          <target state="translated">스크롤 영역은 항상 뷰포트에 맞게 조정됩니다</target>
        </trans-unit>
        <trans-unit id="cfe63ddce05b0d44242749c47cad18765de71999" translate="yes" xml:space="preserve">
          <source>The scroll area will behave like before - and not do any adjust.</source>
          <target state="translated">스크롤 영역은 이전과 같이 작동하며 조정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4575f7e8b6dbe7c72a22198fddcd9aba79688990" translate="yes" xml:space="preserve">
          <source>The scroll bar is always shown.</source>
          <target state="translated">스크롤 막대가 항상 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="32ea78c39c4af6aca1439aa5e2a81e7c5c145893" translate="yes" xml:space="preserve">
          <source>The scroll bar is horizontal.</source>
          <target state="translated">스크롤 바가 수평입니다.</target>
        </trans-unit>
        <trans-unit id="b1eae49ec44af155b6a56289bfb30944473e429a" translate="yes" xml:space="preserve">
          <source>The scroll bar is never shown.</source>
          <target state="translated">스크롤 막대는 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9866ddbea8bad9083492e2ee4813b104fac3102d" translate="yes" xml:space="preserve">
          <source>The scroll bar is only shown when the content is too large to fit.</source>
          <target state="translated">스크롤 막대는 내용이 너무 커서 적합하지 않은 경우에만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0847d6f35a7bbacb0918990830471a78b061c92c" translate="yes" xml:space="preserve">
          <source>The scroll bar widget will be resized to fit the scroll bar geometry for the current style. The following describes the case for scroll bar widgets on the horizontal scroll bar:</source>
          <target state="translated">스크롤 막대 위젯은 현재 스타일의 스크롤 막대 형상에 맞게 크기가 조정됩니다. 다음은 가로 스크롤 막대에서 스크롤 막대 위젯의 경우를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="75237c60b3c8e5d3c4ccd0cc8d5b4deddf37c8d2" translate="yes" xml:space="preserve">
          <source>The scroll bars and viewport should be updated whenever the viewport receives a resize event or the size of the contents changes. The viewport also needs to be updated when the scroll bars values change. The initial values of the scroll bars are often set when the area receives new contents.</source>
          <target state="translated">스크롤 막대와 뷰포트는 뷰포트가 resize 이벤트를 받거나 내용의 크기가 변경 될 때마다 업데이트되어야합니다. 스크롤 막대 값이 변경되면 뷰포트도 업데이트해야합니다. 스크롤 막대의 초기 값은 영역에 새 내용이 수신 될 때 종종 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b24198ff87497274345992cdc195fd152406da6a" translate="yes" xml:space="preserve">
          <source>The scroll bars appearance depends on the currently set &lt;a href=&quot;qt#ScrollBarPolicy-enum&quot;&gt;scroll bar policies&lt;/a&gt;. You can control the appearance of the scroll bars using the inherited functionality from &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt;.</source>
          <target state="translated">스크롤 막대 모양은 현재 설정된 &lt;a href=&quot;qt#ScrollBarPolicy-enum&quot;&gt;스크롤 막대 정책&lt;/a&gt; 에 따라 다릅니다 . &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; 의 상속 된 기능을 사용하여 스크롤 막대의 모양을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4fde453d497daca3a94add05aa03065d82ce6ff0" translate="yes" xml:space="preserve">
          <source>The scroll event is sent to indicate that the receiver should be scrolled. Usually the receiver should be something visual like &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; or &lt;a href=&quot;qgraphicsobject&quot;&gt;QGraphicsObject&lt;/a&gt;.</source>
          <target state="translated">스크롤 이벤트는 수신자가 스크롤되어야 함을 표시하기 위해 전송됩니다. 일반적으로 수신자는 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 또는 &lt;a href=&quot;qgraphicsobject&quot;&gt;QGraphicsObject&lt;/a&gt; 와 같은 시각적이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b0f14badd14a1c35bf3fce0719cedf62a246cdfc" translate="yes" xml:space="preserve">
          <source>The scroll prepare event is sent before scrolling (usually by &lt;a href=&quot;qscroller&quot;&gt;QScroller&lt;/a&gt;) is started. The object receiving this event should set &lt;a href=&quot;qscrollprepareevent#viewportSize&quot;&gt;viewportSize&lt;/a&gt;, maxContentPos and &lt;a href=&quot;qscrollprepareevent#contentPos&quot;&gt;contentPos&lt;/a&gt;. It also should accept this event to indicate that scrolling should be started.</source>
          <target state="translated">스크롤 준비 이벤트는 스크롤 (일반적으로 &lt;a href=&quot;qscroller&quot;&gt;QScroller에&lt;/a&gt; 의해 )이 시작 되기 전에 전송 됩니다. 이 이벤트를받는 객체는 &lt;a href=&quot;qscrollprepareevent#viewportSize&quot;&gt;viewportSize&lt;/a&gt; , maxContentPos 및 &lt;a href=&quot;qscrollprepareevent#contentPos&quot;&gt;contentPos를&lt;/a&gt; 설정해야합니다 . 또한 스크롤이 시작되어야 함을 나타 내기 위해이 이벤트를 승인해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f700b1eb3114f9a9d641cda15f14141d9037508" translate="yes" xml:space="preserve">
          <source>The scrollbar does not snap (default).</source>
          <target state="translated">스크롤바가 스냅되지 않습니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="6b0626ee102076ca6d64a3893d970337d17a6479" translate="yes" xml:space="preserve">
          <source>The scrollbar does not snap while being dragged, but only after released.</source>
          <target state="translated">스크롤하는 동안 스크롤 막대가 스냅되지 않고 해제 된 후에 만 ​​스냅됩니다.</target>
        </trans-unit>
        <trans-unit id="d75380a837ce180f1a298340c984b4310fdf47f6" translate="yes" xml:space="preserve">
          <source>The scrollbar snaps while dragged.</source>
          <target state="translated">스크롤하는 동안 스크롤바가 스냅됩니다.</target>
        </trans-unit>
        <trans-unit id="51ce25c06c1c593a4a769f455dab7076a7fb77ec" translate="yes" xml:space="preserve">
          <source>The scrolled QObjects receive a &lt;a href=&quot;qscrollprepareevent&quot;&gt;QScrollPrepareEvent&lt;/a&gt; whenever the scroller needs to update its geometry information and a &lt;a href=&quot;qscrollevent&quot;&gt;QScrollEvent&lt;/a&gt; whenever the content of the object should actually be scrolled.</source>
          <target state="translated">스크롤 된 QObject 는 스크롤러가 지오메트리 정보를 업데이트해야 할 때마다 &lt;a href=&quot;qscrollevent&quot;&gt;QScrollPrepareEvent&lt;/a&gt; 를, 오브젝트의 내용을 실제로 스크롤해야 할 때마다 &lt;a href=&quot;qscrollprepareevent&quot;&gt;QScrollEvent를&lt;/a&gt; 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="324e1874c091307e6367cf335045e9ce10acf3bf" translate="yes" xml:space="preserve">
          <source>The scroller is not scrolling and nothing is pressed.</source>
          <target state="translated">스크롤러가 스크롤되지 않고 아무 것도 누르지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="7b9aae289fa0070a75b6de69f7655c5f00497c58" translate="yes" xml:space="preserve">
          <source>The scroller is styled using the &lt;a href=&quot;#scroller-sub&quot;&gt;::scroller&lt;/a&gt;.</source>
          <target state="translated">스크롤러는 &lt;a href=&quot;#scroller-sub&quot;&gt;:: scroller를&lt;/a&gt; 사용하여 스타일이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e152ae3c134d70fe60d74f86f1a671d88ef588c6" translate="yes" xml:space="preserve">
          <source>The scroller is styled using the &lt;a href=&quot;stylesheet-reference#scroller-sub&quot;&gt;::scroller&lt;/a&gt;.</source>
          <target state="translated">스크롤러는 &lt;a href=&quot;stylesheet-reference#scroller-sub&quot;&gt;:: scroller를&lt;/a&gt; 사용하여 스타일이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f0f1eb7961c13beccd347f4326afd7b0470c121" translate="yes" xml:space="preserve">
          <source>The scroller of a &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; or &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; 또는 &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; 의 스크롤러입니다 .</target>
        </trans-unit>
        <trans-unit id="838a9abf3e0559d9416bbb18f7f1bb9511052aab" translate="yes" xml:space="preserve">
          <source>The scroller uses the global &lt;a href=&quot;qabstractanimation&quot;&gt;QAbstractAnimation&lt;/a&gt; timer to generate its QScrollEvents. This can be changed with &lt;a href=&quot;qscrollerproperties#ScrollMetric-enum&quot;&gt;QScrollerProperties::FrameRate&lt;/a&gt; on a per-&lt;a href=&quot;qscroller&quot;&gt;QScroller&lt;/a&gt; basis.</source>
          <target state="translated">스크롤러는 글로벌 &lt;a href=&quot;qabstractanimation&quot;&gt;QAbstractAnimation&lt;/a&gt; 타이머를 사용하여 QScrollEvents를 생성합니다. 이것은 &lt;a href=&quot;qscroller&quot;&gt;QScroller&lt;/a&gt; 마다 &lt;a href=&quot;qscrollerproperties#ScrollMetric-enum&quot;&gt;QScrollerProperties :: FrameRate&lt;/a&gt; 를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2cc8756608b65b32b19384b72d8454040ce7ec5b" translate="yes" xml:space="preserve">
          <source>The scroller uses the global &lt;a href=&quot;qabstractanimation&quot;&gt;QAbstractAnimation&lt;/a&gt; timer to generate its QScrollEvents. This can be changed with &lt;a href=&quot;qscrollerproperties#ScrollMetric-enum&quot;&gt;QScrollerProperties::FrameRate&lt;/a&gt; on a per-QScroller basis.</source>
          <target state="translated">스크롤러는 글로벌 &lt;a href=&quot;qabstractanimation&quot;&gt;QAbstractAnimation&lt;/a&gt; 타이머를 사용하여 QScrollEvents를 생성합니다. 이것은 QScroller별로 &lt;a href=&quot;qscrollerproperties#ScrollMetric-enum&quot;&gt;QScrollerProperties :: FrameRate&lt;/a&gt; 로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6fc0ffd509cf4425b778a5c957aeed073a71ec82" translate="yes" xml:space="preserve">
          <source>The scrolling distance has changed (default).</source>
          <target state="translated">스크롤 거리가 변경되었습니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="e8c3dab5ba7a503e24afda15e7730d9d9e23ccc6" translate="yes" xml:space="preserve">
          <source>The scrolling phase of the event is specified by</source>
          <target state="translated">이벤트의 스크롤 단계는</target>
        </trans-unit>
        <trans-unit id="b2d4cbbda219e97ff86f0052fbe5db1ec4be9862" translate="yes" xml:space="preserve">
          <source>The scrolling speed is calculated so that the given position is reached after a platform-defined time span.</source>
          <target state="translated">스크롤 속도는 플랫폼 정의 시간 범위 이후에 주어진 위치에 도달하도록 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="7d5394e62c42d7ff2caac3ef14d704242a34237b" translate="yes" xml:space="preserve">
          <source>The scrolling speed will be calculated so that the given position will be reached after a platform-defined time span.</source>
          <target state="translated">플랫폼이 정의한 시간 범위 이후에 주어진 위치에 도달 할 수 있도록 스크롤 속도가 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="8293a08961d1041e7b535981b478f783e376ef05" translate="yes" xml:space="preserve">
          <source>The search begins from the</source>
          <target state="translated">검색은</target>
        </trans-unit>
        <trans-unit id="0e1ad895d07c4b12315a8ecff7ef2011d30af440" translate="yes" xml:space="preserve">
          <source>The search context can be of any type storable in a &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;. The value of the search context is not intended to be use directly by applications.</source>
          <target state="translated">검색 컨텍스트는 &lt;a href=&quot;qvariant&quot;&gt;QVariant에&lt;/a&gt; 저장 가능한 모든 유형이 될 수 있습니다 . 검색 컨텍스트의 값은 응용 프로그램에서 직접 사용하기위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e052c2a96cbd3152ed6f3500f906237cdec06482" translate="yes" xml:space="preserve">
          <source>The search context is used by backends to store additional search context related to the search request. Other relevant fields should also be filled in. For example, if the search context encodes a text search the search term should also be set with &lt;a href=&quot;qplacesearchrequest#setSearchTerm&quot;&gt;setSearchTerm&lt;/a&gt;(). The search context allows additional search context to be kept which is not directly accessible via the Qt Location API.</source>
          <target state="translated">검색 컨텍스트는 백엔드에서 검색 요청과 관련된 추가 검색 컨텍스트를 저장하는 데 사용됩니다. 다른 관련 필드도 채워야합니다. 예를 들어, 검색 컨텍스트가 텍스트 검색을 인코딩하는 경우 검색어도 &lt;a href=&quot;qplacesearchrequest#setSearchTerm&quot;&gt;setSearchTerm&lt;/a&gt; () 으로 설정해야합니다 . 검색 컨텍스트는 Qt Location API를 통해 직접 액세스 할 수없는 추가 검색 컨텍스트를 유지할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="0d1be2cef189b4f280fefc0190ebd5fef310a76b" translate="yes" xml:space="preserve">
          <source>The search is case sensitive.</source>
          <target state="translated">검색은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="6b48e60b739a4c5bb9b82a9c515daa0b37bd08d9" translate="yes" xml:space="preserve">
          <source>The search query has completed, and the results are available.</source>
          <target state="translated">검색 쿼리가 완료되었으며 결과를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd78e7a9db91c8ad3905ac232f4f1e42eb47f242" translate="yes" xml:space="preserve">
          <source>The search result contains a place.</source>
          <target state="translated">검색 결과에 장소가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1896452d88ae43200f3a1b7870d19e9341f357ba" translate="yes" xml:space="preserve">
          <source>The search result contains a proposed search which may be relevant.</source>
          <target state="translated">검색 결과에는 관련성이있는 제안 된 검색이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="74b27135226df0f3dbfacdae328e953263252ec1" translate="yes" xml:space="preserve">
          <source>The search starts at the given</source>
          <target state="translated">검색은 주어진 시간에 시작됩니다</target>
        </trans-unit>
        <trans-unit id="e59793a4f301c870c8c3877d2c82f1e7d5ee9df7" translate="yes" xml:space="preserve">
          <source>The search starts at the position of the given</source>
          <target state="translated">주어진 위치에서 검색이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="e1d1e306770aa84d0d6cd8e5b485ed3e3fcb7a22" translate="yes" xml:space="preserve">
          <source>The search starts at the position of the given from</source>
          <target state="translated">주어진 위치에서 검색이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="7e1859965d8cc3dfe950159c598201e11cfe2aad" translate="yes" xml:space="preserve">
          <source>The search term is contained in the item.</source>
          <target state="translated">검색어가 항목에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a68607b092250deb33062f4bb4fab806db740b9" translate="yes" xml:space="preserve">
          <source>The search term matches as a fixed string.</source>
          <target state="translated">검색어는 고정 문자열로 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7eddbbe6fd6f4140b5460652130cec013c4464b1" translate="yes" xml:space="preserve">
          <source>The search term matches as a regular expression.</source>
          <target state="translated">검색어는 정규식으로 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e0af5cee2d2358ed6e98cfda40e8248cd695e7b1" translate="yes" xml:space="preserve">
          <source>The search term matches exactly (default).</source>
          <target state="translated">검색어가 정확히 일치합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="15f25bd0eee60b1e205843af1497f5e6f8287adc" translate="yes" xml:space="preserve">
          <source>The search term matches the end of the item.</source>
          <target state="translated">검색어가 항목의 끝과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="5ede5b13d4e57852af12c88d235fb3f499a5473e" translate="yes" xml:space="preserve">
          <source>The search term matches the start of the item.</source>
          <target state="translated">검색어가 항목의 시작과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="189bfc317787eed62e871e365864407fc20166e3" translate="yes" xml:space="preserve">
          <source>The search term matches using wildcards.</source>
          <target state="translated">검색어는 와일드 카드를 사용하여 일치합니다.</target>
        </trans-unit>
        <trans-unit id="dc7f1f0ce3958a2c81484683200250e1dd5e6c96" translate="yes" xml:space="preserve">
          <source>The second &lt;code&gt;Text&lt;/code&gt; type uses an id to access the first's text directly. IDs are specified explicitly by the QML programmer so they always take precedence over other property names (except for those in the &lt;a href=&quot;#javascript-scope&quot;&gt;JavaScript Scope&lt;/a&gt;). For example, in the unlikely event that the binding's &lt;a href=&quot;#binding-scope-object&quot;&gt;scope object&lt;/a&gt; had a &lt;code&gt;titletype&lt;/code&gt; property in the previous example, the &lt;code&gt;titletype&lt;/code&gt; id would still take precedence.</source>
          <target state="translated">두 번째 &lt;code&gt;Text&lt;/code&gt; 유형은 id를 사용하여 첫 번째 텍스트에 직접 액세스합니다. ID는 QML 프로그래머가 명시 적으로 지정하므로 항상 다른 특성 이름보다 우선합니다 ( &lt;a href=&quot;#javascript-scope&quot;&gt;JavaScript 범위&lt;/a&gt; 의 경우 제외 ). 예를 들어, 이전 예제에서 바인딩의 &lt;a href=&quot;#binding-scope-object&quot;&gt;범위 객체&lt;/a&gt; 에 &lt;code&gt;titletype&lt;/code&gt; 속성 이있을 가능성은 거의 없지만 &lt;code&gt;titletype&lt;/code&gt; id가 여전히 우선합니다.</target>
        </trans-unit>
        <trans-unit id="0b9cbf9d09e53ade1dad91fcbbd8ab881dd843c2" translate="yes" xml:space="preserve">
          <source>The second &lt;code&gt;Text&lt;/code&gt; type uses an id to access the first's text directly. IDs are specified explicitly by the QML programmer so they always take precedence over other property names (except for those in the &lt;a href=&quot;qtqml-documents-scope#javascript-scope&quot;&gt;JavaScript Scope&lt;/a&gt;). For example, in the unlikely event that the binding's &lt;a href=&quot;qtqml-documents-scope#binding-scope-object&quot;&gt;scope object&lt;/a&gt; had a &lt;code&gt;titletype&lt;/code&gt; property in the previous example, the &lt;code&gt;titletype&lt;/code&gt; id would still take precedence.</source>
          <target state="translated">두 번째 &lt;code&gt;Text&lt;/code&gt; 유형은 ID를 사용하여 첫 번째 텍스트에 직접 액세스합니다. ID는 QML 프로그래머에 의해 명시 적으로 지정되므로 항상 다른 속성 이름보다 우선합니다 ( &lt;a href=&quot;qtqml-documents-scope#javascript-scope&quot;&gt;JavaScript 범위&lt;/a&gt; 에있는 이름 제외 ). 예를 들어 바인딩의 &lt;a href=&quot;qtqml-documents-scope#binding-scope-object&quot;&gt;범위 개체&lt;/a&gt; 에 이전 예제 의 &lt;code&gt;titletype&lt;/code&gt; 속성 이있는 드문 경우에도 &lt;code&gt;titletype&lt;/code&gt; id가 여전히 우선합니다.</target>
        </trans-unit>
        <trans-unit id="a39e45ee5c671cba6edfa331bb40500f96721340" translate="yes" xml:space="preserve">
          <source>The second approach is to handle user events directly by reimplementing &lt;a href=&quot;qabstractitemdelegate#editorEvent&quot;&gt;editorEvent&lt;/a&gt;().</source>
          <target state="translated">두 번째 방법은 &lt;a href=&quot;qabstractitemdelegate#editorEvent&quot;&gt;editorEvent&lt;/a&gt; () 를 다시 구현하여 사용자 이벤트를 직접 처리하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="2cd4877ab7a6785fff7c1e32f81ef325568c8af5" translate="yes" xml:space="preserve">
          <source>The second argument is the name of the page being referenced. The second argument is actually optional, for example if you are using a topicref as a container for other topicrefs and maprefs. It is also optional if you want qdoc to find the page name for you by looking up the title in its internal data structure. It is recommended that you provide the second parameter if you know the page name.</source>
          <target state="translated">두 번째 인수는 참조중인 페이지의 이름입니다. 예를 들어, topicref를 다른 topicref 및 mapref의 컨테이너로 사용하는 경우 두 번째 인수는 실제로 선택 사항입니다. 내부 데이터 구조에서 제목을 찾아서 qdoc이 페이지 이름을 찾도록하려면 선택 사항입니다. 페이지 이름을 알고있는 경우 두 번째 매개 변수를 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="05e2c9ea354948b3ce07acfc931d16809b2a78df" translate="yes" xml:space="preserve">
          <source>The second case is explained by example. Suppose you want to populate a list widget with the values of certain attributes from a set of result elements. You could write an &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; to return the set of elements, and then you would write the code to iterate over the result elements, get their attributes, and extract the desired string values. But the simpler way is to just augment your &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; to finding the desired attribute values. Then all you have to do is evaluate the &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; using the version of &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery::evaluateTo&lt;/a&gt;() that populates a &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt;, which you can send directly to your widget.</source>
          <target state="translated">두 번째 경우는 예제로 설명됩니다. 결과 요소 세트의 특정 속성 값으로 목록 위젯을 채우려 고한다고 가정하십시오. &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 를 작성하여 요소 집합을 반환 한 다음 결과 요소를 반복하고 해당 속성을 가져오고 원하는 문자열 값을 추출하는 코드를 작성할 수 있습니다. 그러나 더 간단한 방법은 원하는 속성 값을 찾기 위해 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 를 확장하는 것 입니다. 그런 다음 위젯에 직접 보낼 수 있는 &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; 를 채우는 &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery :: evaluateTo&lt;/a&gt; () 버전을 사용 하여 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 를 평가하기 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="0431539a45a3165b712decf353de082bef002c31" translate="yes" xml:space="preserve">
          <source>The second case is explained by example. Suppose you want to populate a list widget with the values of certain attributes from a set of result elements. You could write an &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; to return the set of elements, and then you would write the code to iterate over the result elements, get their attributes, and extract the desired string values. But the simpler way is to just augment your &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; to finding the desired attribute values. Then all you have to do is evaluate the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; using the version of &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery::evaluateTo&lt;/a&gt;() that populates a &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt;, which you can send directly to your widget.</source>
          <target state="translated">두 번째 경우는 예를 들어 설명합니다. 결과 요소 세트의 특정 속성 값으로 목록 위젯을 채우려 고한다고 가정하십시오. &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 를 작성하여 요소 세트를 리턴 한 다음 결과 요소를 반복하고 해당 속성을 가져오고 원하는 문자열 값을 추출하는 코드를 작성할 수 있습니다. 그러나 가장 간단한 방법은 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 를 보강하여 원하는 속성 값을 찾는 것입니다. 그런 다음 &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; 를 채우는 &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery :: evaluateTo&lt;/a&gt; () 버전을 사용 하여 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 를 평가하기 만하면 위젯에 직접 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe50d52a542c71e9f540338690eae571cd5d2eb2" translate="yes" xml:space="preserve">
          <source>The second element in the pair.</source>
          <target state="translated">쌍의 두 번째 요소.</target>
        </trans-unit>
        <trans-unit id="3496dceb93420817b0445619c900783688879a3d" translate="yes" xml:space="preserve">
          <source>The second element of the pair is of type &lt;a href=&quot;qcborvalue#qcborvalueref&quot;&gt;QCborValueRef&lt;/a&gt;, a helper class for &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt; and &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt;. When you get an object of type &lt;a href=&quot;qcborvalue#qcborvalueref&quot;&gt;QCborValueRef&lt;/a&gt;, you can use it as if it were a reference to a &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt;. If you assign to it, the assignment will apply to the element in the &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt; or &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt; from which you got the reference.</source>
          <target state="translated">쌍의 두 번째 요소는 &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt; 및 &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt; 의 헬퍼 클래스 인 &lt;a href=&quot;qcborvalue#qcborvalueref&quot;&gt;QCborValueRef&lt;/a&gt; 유형 입니다. 당신이 형식의 개체 얻을 때 &lt;a href=&quot;qcborvalue#qcborvalueref&quot;&gt;QCborValueRef을&lt;/a&gt; 그것의 참조 것처럼, 당신은 그것을 사용할 수 있습니다 &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; . 할당 하면 참조가있는 &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt; 또는 &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt; 의 요소에 할당이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d72f0d0aaa994652a39d632b9e45a7f0ba6ba41b" translate="yes" xml:space="preserve">
          <source>The second example illustrates using an existing &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt;, that is, a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;.</source>
          <target state="translated">두 번째 예는 기존 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; 즉, &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView 사용을 보여&lt;/a&gt; 줍니다.</target>
        </trans-unit>
        <trans-unit id="0b461065a4323a4ecb95c639d6fe9ebeee8ef1d6" translate="yes" xml:space="preserve">
          <source>The second fastest way is to use the registered control's class name (with or without version number), e.g.</source>
          <target state="translated">두 번째로 빠른 방법은 등록 된 컨트롤의 클래스 이름 (버전 번호가 있거나없는)을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3da66080d17140c2fab826e189393d06a6bd6b0e" translate="yes" xml:space="preserve">
          <source>The second group of functions insert elements that provide structure to the document, and return the structure that was inserted:</source>
          <target state="translated">두 번째 함수 그룹은 문서에 구조를 제공하는 요소를 삽입하고 삽입 된 구조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9e96cb474c3063418c5d6ed6d9ff3475b7727935" translate="yes" xml:space="preserve">
          <source>The second is optional and is a map of property-value pairs that define initial any property values for the object. Property values specified by this argument are applied to the object before its creation is finalized, avoiding binding errors that may occur if particular properties must be initialized to enable other property bindings. Additionally, there are small performance benefits when compared to defining property values and bindings after the object is created.</source>
          <target state="translated">두 번째는 선택 사항이며 객체의 초기 속성 값을 정의하는 속성 값 쌍의 맵입니다. 이 인수로 지정된 특성 값은 다른 특성 바인딩을 사용하기 위해 특정 특성을 초기화해야하는 경우 발생할 수있는 바인딩 오류를 피하기 위해 작성이 완료되기 전에 오브젝트에 적용됩니다. 또한 객체를 만든 후 속성 값과 바인딩을 정의하는 것과 비교할 때 성능상의 이점이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="c8c36b64af97dce3172eadf6675b20f97b2c5179" translate="yes" xml:space="preserve">
          <source>The second is that &lt;a href=&quot;qplacemanager#compatiblePlace&quot;&gt;QPlaceManager::compatiblePlace&lt;/a&gt;() of the destination manager use the &lt;code&gt;x_provider&lt;/code&gt; attribute of the initial place and set an alternative identifier attribute of the place to be saved. The key of the alternative identifier attribute is &lt;code&gt;x_id_&amp;lt;provider&lt;/code&gt; name&amp;gt; and the text value is the identifier of the initial place. The &lt;code&gt;x_provider&lt;/code&gt; attribute should not be passed to the compatible place. When it is saved, the x_provider of the saved place is considered to be the destination manager.</source>
          <target state="translated">두 번째는 대상 관리자의 &lt;a href=&quot;qplacemanager#compatiblePlace&quot;&gt;QPlaceManager :: compatiblePlace&lt;/a&gt; ()가 초기 장소 의 &lt;code&gt;x_provider&lt;/code&gt; 속성을 사용하고 저장할 장소의 대체 식별자 속성을 설정한다는 것입니다. 대체 식별자 속성의 키는 &lt;code&gt;x_id_&amp;lt;provider&lt;/code&gt; 이름&amp;gt;이고 텍스트 값은 초기 장소의 식별자입니다. &lt;code&gt;x_provider&lt;/code&gt; 의 속성은 호환 장소에 전달되어서는 안된다. 저장되면 저장된 장소의 x_provider가 대상 관리자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="fe2d8a000c460caaa5da4716b8b77ac7219de156" translate="yes" xml:space="preserve">
          <source>The second is to use the overload that takes an index:</source>
          <target state="translated">두 번째는 인덱스를 사용하는 오버로드를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="294554ac2fe55547371f68a14c6864cd6f10bbfa" translate="yes" xml:space="preserve">
          <source>The second method is suitable if you want to minimize the size of your APK, and can be selected by opening the &lt;b&gt;Run&lt;/b&gt; settings of your project, expanding &lt;b&gt;Deploy Configurations&lt;/b&gt; and removing the tick from the &lt;b&gt;Use local Qt libraries&lt;/b&gt; check box. In this case, your application will have an external dependency called &lt;b&gt;Ministro&lt;/b&gt;. If a user downloads your application, and it is the first application on their device to depend on Ministro, they will be asked to install it before they can run your application. Ministro downloads Qt libraries from a repository of your choice. The repository URL can be set by editing the file</source>
          <target state="translated">두 번째 방법은 APK 크기를 최소화하려는 경우에 적합 하며 프로젝트의 설정 &lt;b&gt;실행&lt;/b&gt; 을 열고 &lt;b&gt;구성 배포를&lt;/b&gt; 확장 하고 &lt;b&gt;로컬 Qt 라이브러리 사용&lt;/b&gt; 확인란 에서 틱을 제거하여 선택할 수 있습니다 . 이 경우 응용 프로그램에는 &lt;b&gt;Ministro&lt;/b&gt; 라는 외부 종속성이 있습니다 . 사용자가 응용 프로그램을 다운로드하고 장치에서 Ministro에 의존하는 첫 번째 응용 프로그램 인 경우 응용 프로그램을 실행하기 전에 설치하라는 메시지가 표시됩니다. Ministro는 선택한 리포지토리에서 Qt 라이브러리를 다운로드합니다. 파일을 편집하여 저장소 URL을 설정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="edafaffe0431542bd4a4a52022cd359d51cc292c" translate="yes" xml:space="preserve">
          <source>The second notation allows you to append the contents of the variable to another value without separating the two with a space. For example, the following will ensure that the final executable will be given a name that includes the project template being used:</source>
          <target state="translated">두 번째 표기법을 사용하면 변수를 공백으로 구분하지 않고 변수의 내용을 다른 값에 추가 할 수 있습니다. 예를 들어, 다음은 최종 실행 파일에 사용중인 프로젝트 템플릿이 포함 된 이름이 지정되도록합니다.</target>
        </trans-unit>
        <trans-unit id="be8117ce06a54b23b6bd45ed86077a4f7148653f" translate="yes" xml:space="preserve">
          <source>The second part of determining the projection of the camera is defining the frustum that defines the what parts of the scenes are visible, as well as how they are visible. The Camera subtypes provide multiple options to determine the shape of the Camera's frustum.</source>
          <target state="translated">카메라 투영을 결정하는 두 번째 부분은 장면의 어떤 부분이 보이는지 정의하는 절두체를 정의하는 것입니다. 카메라 하위 유형은 카메라 절두체의 모양을 결정하는 여러 옵션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c87329295e3c1a0ad123bac3947e5fff6eb4d270" translate="yes" xml:space="preserve">
          <source>The second step after establishing the connection is to discover the services offered by the remote peripheral device. This process is started via &lt;a href=&quot;qlowenergycontroller#discoverServices&quot;&gt;discoverServices&lt;/a&gt;() and has finished once the &lt;a href=&quot;qlowenergycontroller#discoveryFinished&quot;&gt;discoveryFinished&lt;/a&gt;() signal has been emitted. The discovered services can be enumerated via &lt;a href=&quot;qlowenergycontroller#services&quot;&gt;services&lt;/a&gt;().</source>
          <target state="translated">연결을 설정 한 후 두 번째 단계는 원격 주변 장치가 제공하는 서비스를 검색하는 것입니다. 이 프로세스는 &lt;a href=&quot;qlowenergycontroller#discoverServices&quot;&gt;discoverServices&lt;/a&gt; () 를 통해 시작되며 &lt;a href=&quot;qlowenergycontroller#discoveryFinished&quot;&gt;discoveryFinished&lt;/a&gt; () 신호가 방출 되면 완료 됩니다. 발견 된 서비스는 &lt;a href=&quot;qlowenergycontroller#services&quot;&gt;서비스&lt;/a&gt; () 를 통해 열거 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1033068ed153771ffbdb06bb3ea0f6ee81f0f441" translate="yes" xml:space="preserve">
          <source>The second step in this process is to enable reading of this meta information in the applications that use the static library:</source>
          <target state="translated">이 프로세스의 두 번째 단계는 정적 라이브러리를 사용하는 애플리케이션에서이 메타 정보를 읽을 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e8ce564d8eb432f944e59d66cb8811cdb6a90b66" translate="yes" xml:space="preserve">
          <source>The second string matches &quot;Please write the &lt;u&gt;letter&lt;/u&gt;&quot;. The word 'letter' is also captured (because of the parentheses). We can see what text we've captured like this:</source>
          <target state="translated">두 번째 문자열은 &quot; &lt;u&gt;문자를&lt;/u&gt; 작성하십시오&quot;와 일치 합니다. 괄호 때문에 'letter'라는 단어도 캡처됩니다. 다음과 같이 캡처 한 텍스트를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="caf90f56e505f8b277902afacce829efcad41120" translate="yes" xml:space="preserve">
          <source>The second string matches '&lt;u&gt;This_is-OK&lt;/u&gt;'. We've used the character set abbreviation '\S' (non-whitespace) and the anchors to match strings which contain no whitespace.</source>
          <target state="translated">두 번째 문자열은 ' &lt;u&gt;This_is-OK&lt;/u&gt; ' 와 일치 합니다. 문자 세트 약어 '\ S'(공백이 아님)와 앵커를 사용하여 공백이없는 문자열을 일치 시켰습니다.</target>
        </trans-unit>
        <trans-unit id="fd075b1e98cbfba52846c1843ea4d75533f31a4a" translate="yes" xml:space="preserve">
          <source>The second user-defined button (see also &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveCustomButton2&lt;/a&gt;)</source>
          <target state="translated">두 번째 사용자 정의 버튼 ( &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveCustomButton2&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="1904d9fd0f2733c9490a8b70fdbb10fe88ed560e" translate="yes" xml:space="preserve">
          <source>The second view is given the selection model for the first view. Both views now operate on the same selection model, keeping both the data and the selected items synchronized.</source>
          <target state="translated">두 번째보기에는 첫 번째보기의 선택 모델이 제공됩니다. 이제 두보기가 동일한 선택 모델에서 작동하여 데이터와 선택한 항목이 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="8307d5622515c9e2c943cf66ee3d8cf29f2d804d" translate="yes" xml:space="preserve">
          <source>The second way is to create an empty &lt;a href=&quot;qboxset&quot;&gt;QBoxSet&lt;/a&gt; instance and specify the values using the &lt;a href=&quot;qboxset#setValue&quot;&gt;setValue&lt;/a&gt;() method.</source>
          <target state="translated">두 번째 방법은 빈 &lt;a href=&quot;qboxset&quot;&gt;QBoxSet&lt;/a&gt; 인스턴스 를 만들고 &lt;a href=&quot;qboxset#setValue&quot;&gt;setValue&lt;/a&gt; () 메소드를 사용하여 값을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f3a720f65730f86547c91ae28e16f9ae742b61aa" translate="yes" xml:space="preserve">
          <source>The second way is to create an empty &lt;a href=&quot;qml-qtcharts-boxset&quot;&gt;BoxSet&lt;/a&gt; instance and specify the values using the &lt;a href=&quot;qml-qtcharts-boxset#setValue-method&quot;&gt;setValue()&lt;/a&gt; method.</source>
          <target state="translated">두 번째 방법은 빈 &lt;a href=&quot;qml-qtcharts-boxset&quot;&gt;BoxSet&lt;/a&gt; 인스턴스 를 만들고 &lt;a href=&quot;qml-qtcharts-boxset#setValue-method&quot;&gt;setValue ()&lt;/a&gt; 메서드를 사용하여 값을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="849fa2742f199b3f10cac048499fe1f069f1a576" translate="yes" xml:space="preserve">
          <source>The second way is to create an empty BoxSet instance and specify the values using the &lt;a href=&quot;qml-qtcharts-boxset#setValue-method&quot;&gt;setValue()&lt;/a&gt; method.</source>
          <target state="translated">두 번째 방법은 빈 BoxSet 인스턴스를 만들고 &lt;a href=&quot;qml-qtcharts-boxset#setValue-method&quot;&gt;setValue ()&lt;/a&gt; 메서드를 사용하여 값을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="732e43b6ef3eed78a1ec4ab836922366eb2f456f" translate="yes" xml:space="preserve">
          <source>The second way is to create an empty QBoxSet instance and specify the values using the &lt;a href=&quot;qboxset#setValue&quot;&gt;setValue&lt;/a&gt;() method.</source>
          <target state="translated">두 번째 방법은 빈 QBoxSet 인스턴스를 만들고 &lt;a href=&quot;qboxset#setValue&quot;&gt;setValue&lt;/a&gt; () 메서드를 사용하여 값을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="06e6b0bab6c01909316270cb3bbb8502835df20a" translate="yes" xml:space="preserve">
          <source>The second way to create the button is good if you plan to use your rounded button in several places. It involves moving the code into its own QML file within your project.</source>
          <target state="translated">둥근 단추를 여러 곳에서 사용하려는 경우 단추를 만드는 두 번째 방법이 좋습니다. 코드를 프로젝트 내에서 자체 QML 파일로 옮기는 작업이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="53aacc9bcedf75f97ea19c680c21ef11fda036e3" translate="yes" xml:space="preserve">
          <source>The secondary viewport is used for drawing the 2D slice view in some visualizations. If it has not been explicitly set, it will be equal to &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;. If &lt;a href=&quot;q3dscene#slicingActive-prop&quot;&gt;isSlicingActive&lt;/a&gt;() is &lt;code&gt;true&lt;/code&gt;, it will be equal to &lt;a href=&quot;q3dscene#viewport-prop&quot;&gt;viewport&lt;/a&gt;.</source>
          <target state="translated">보조 뷰포트는 일부 시각화에서 2D 슬라이스 뷰를 그리는 데 사용됩니다. 명시 적으로 설정되지 않은 경우 &lt;a href=&quot;qrect&quot;&gt;QRect와&lt;/a&gt; 같습니다 . 경우 &lt;a href=&quot;q3dscene#slicingActive-prop&quot;&gt;isSlicingActive은&lt;/a&gt; ()이다 &lt;code&gt;true&lt;/code&gt; , 같아야합니다 &lt;a href=&quot;q3dscene#viewport-prop&quot;&gt;뷰포트&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="024f9021eaf0bde9f987fc14d2dc5f23067b6023" translate="yes" xml:space="preserve">
          <source>The section is evaluated using the &lt;a href=&quot;qml-qtquick-listview#section.property-prop&quot;&gt;section&lt;/a&gt; properties.</source>
          <target state="translated">섹션은 &lt;a href=&quot;qml-qtquick-listview#section.property-prop&quot;&gt;섹션&lt;/a&gt; 속성을 사용하여 평가 됩니다.</target>
        </trans-unit>
        <trans-unit id="66eef1358f8d534fd435b0e6ac1f056857ad1225" translate="yes" xml:space="preserve">
          <source>The section of a &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; 의 섹션입니다 .</target>
        </trans-unit>
        <trans-unit id="6ba63ee3baa45e8ffcce3452c4298b27431ee413" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;#qdoc-topics&quot;&gt;topic commands&lt;/a&gt; gives an overview on several other topic types.</source>
          <target state="translated">&lt;a href=&quot;#qdoc-topics&quot;&gt;주제 명령&lt;/a&gt; 섹션에서는 여러 가지 다른 주제 유형에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="eaf6f076fbcf5f98f2b7ccfa784ee9c4b413b088" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;qdoc-guide-writing#qdoc-topics&quot;&gt;topic commands&lt;/a&gt; gives an overview on several other topic types.</source>
          <target state="translated">&lt;a href=&quot;qdoc-guide-writing#qdoc-topics&quot;&gt;주제 명령&lt;/a&gt; 에 대한 섹션에서는 다른 여러 주제 유형에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0507543e66104c274295ae601478ecc0fd4fc271" translate="yes" xml:space="preserve">
          <source>The security model of application scripting with JavaScript follows the same model as for C++ code: the user installs scripts to run that they trust in the same way as they install Qt applications.</source>
          <target state="translated">JavaScript를 사용한 응용 프로그램 스크립팅의 보안 모델은 C ++ 코드와 동일한 모델을 따릅니다. 사용자는 Qt 응용 프로그램을 설치할 때와 같은 방식으로 신뢰할 수있는 스크립트를 설치합니다.</target>
        </trans-unit>
        <trans-unit id="cfac5ae7af1be61bdbbe5a839a5c9b38275bb04f" translate="yes" xml:space="preserve">
          <source>The security parameters may be renegotiated between the two parties during or after the connection has been established. If such a change happens it is not reflected in the value of this flag.</source>
          <target state="translated">보안 매개 변수는 연결 중 또는 연결이 완료된 후 두 당사자간에 재협상 될 수 있습니다. 이러한 변경이 발생하면이 플래그의 값에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4fe95f34186c4ad1b9b9c1224a602a73163cde9" translate="yes" xml:space="preserve">
          <source>The seed data takes the form of one or more 32-bit words. The ideal seed size is approximately equal to the size of the &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; class itself. Due to mixing of the seed data, &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; cannot guarantee that distinct seeds will produce different sequences.</source>
          <target state="translated">시드 데이터는 하나 이상의 32 비트 워드 형태를 취합니다. 이상적인 시드 크기는 &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; 클래스 자체 의 크기와 거의 같습니다 . 시드 데이터의 혼합으로 인해 &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; 는 개별 시드가 다른 시퀀스를 생성 할 것이라고 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d12b5ceba248afa66108099e71f52f67c6315ee4" translate="yes" xml:space="preserve">
          <source>The seed data takes the form of one or more 32-bit words. The ideal seed size is approximately equal to the size of the QRandomGenerator class itself. Due to mixing of the seed data, QRandomGenerator cannot guarantee that distinct seeds will produce different sequences.</source>
          <target state="translated">시드 데이터는 하나 이상의 32 비트 단어 형식을 취합니다. 이상적인 시드 크기는 QRandomGenerator 클래스 자체의 크기와 거의 같습니다. 시드 데이터의 혼합으로 인해 QRandomGenerator는 별개의 시드가 다른 시퀀스를 생성한다고 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cd93bbb2d77841eba21647ff8763f98ab6a66376" translate="yes" xml:space="preserve">
          <source>The seed is set in any newly created &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;. See &lt;a href=&quot;qhash#qhash&quot;&gt;qHash&lt;/a&gt; about how this seed is being used by &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;.</source>
          <target state="translated">시드는 새로 생성 된 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash에&lt;/a&gt; 설정됩니다 . 참조 &lt;a href=&quot;qhash#qhash&quot;&gt;qHash을&lt;/a&gt; 이 씨에 의해 사용되는 방법에 대해 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43985e0138812050a29f9f9ec70db507a0f5a18c" translate="yes" xml:space="preserve">
          <source>The selected date can be set through &lt;a href=&quot;qml-qtquick-controls-calendar#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt;. A minimum and maximum date can be set through &lt;a href=&quot;qml-qtquick-controls-calendar#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls-calendar#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt;. The earliest minimum date that can be set is 1 January, 1 AD. The latest maximum date that can be set is 25 October, 275759 AD.</source>
          <target state="translated">선택한 날짜를 설정할 수 있습니다 &lt;a href=&quot;qml-qtquick-controls-calendar#selectedDate-prop&quot;&gt;되어 selectedDate&lt;/a&gt; . &lt;a href=&quot;qml-qtquick-controls-calendar#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls-calendar#maximumDate-prop&quot;&gt;maximumDate를&lt;/a&gt; 통해 최소 및 최대 날짜를 설정할 수 있습니다 . 설정할 수있는 가장 빠른 최소 날짜는 AD 1 월 1 일입니다. 설정할 수있는 최신 최대 날짜는 AD 275759 년 10 월 25 일입니다.</target>
        </trans-unit>
        <trans-unit id="bf969cacc7658bea3ee319fbfe2298015d19d4a1" translate="yes" xml:space="preserve">
          <source>The selected date is displayed using the format in the application's default locale.</source>
          <target state="translated">선택한 날짜는 응용 프로그램의 기본 로캘 형식을 사용하여 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b22d351cace32765dc201a46cbdfc45b0b31adca" translate="yes" xml:space="preserve">
          <source>The selected date must be within the date range specified by the &lt;a href=&quot;qcalendarwidget#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; and &lt;a href=&quot;qcalendarwidget#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; properties. By default, the selected date is the current date.</source>
          <target state="translated">선택한 날짜는 &lt;a href=&quot;qcalendarwidget#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; 및 &lt;a href=&quot;qcalendarwidget#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; 속성으로 지정된 날짜 범위 내에 있어야합니다 . 기본적으로 선택된 날짜는 현재 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="f7af228d7e9d6e0c92ee75b67f925d31853bf951" translate="yes" xml:space="preserve">
          <source>The selected items are indicated with the selection rectangle.</source>
          <target state="translated">선택한 항목은 선택 사각형으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="89f96d05df1124df8e76263bdddb941edbe5d500" translate="yes" xml:space="preserve">
          <source>The selected items are stored using ranges. Whenever you want to modify the selected items use &lt;a href=&quot;qitemselectionmodel#select&quot;&gt;select&lt;/a&gt;() and provide either a &lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt;, or a &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; and a &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;QItemSelectionModel::SelectionFlag&lt;/a&gt;.</source>
          <target state="translated">선택한 항목은 범위를 사용하여 저장됩니다. 선택한 항목을 수정할 때마다 &lt;a href=&quot;qitemselectionmodel#select&quot;&gt;select&lt;/a&gt; ()를 사용 하고 &lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt; 또는 &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; 및 &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;QItemSelectionModel :: SelectionFlag를 제공하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da8f5182b1a23ab3b6be2b12670b3bba25233b58" translate="yes" xml:space="preserve">
          <source>The selected items in a widget are read using the &lt;code&gt;selectedItems()&lt;/code&gt; function, providing a list of relevant items that can be iterated over. For example, we can find the sum of all the numeric values within a list of selected items with the following code:</source>
          <target state="translated">widget에서 선택된 항목은 &lt;code&gt;selectedItems()&lt;/code&gt; 함수를 사용하여 읽고 반복 할 수있는 관련 항목의 목록을 제공합니다. 예를 들어 다음 코드를 사용하여 선택한 항목 목록에서 모든 숫자 값의 합계를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea173bacd0142b549972732ae1638fdf19632b65" translate="yes" xml:space="preserve">
          <source>The selected series or &lt;code&gt;null&lt;/code&gt;. If &lt;a href=&quot;qabstract3dgraph#selectionMode-prop&quot;&gt;selectionMode&lt;/a&gt; has the &lt;code&gt;SelectionMultiSeries&lt;/code&gt; flag set, this property holds the series that owns the selected bar.</source>
          <target state="translated">선택한 시리즈 또는 &lt;code&gt;null&lt;/code&gt; . 경우 &lt;a href=&quot;qabstract3dgraph#selectionMode-prop&quot;&gt;의 selectionMode가&lt;/a&gt; 이 &lt;code&gt;SelectionMultiSeries&lt;/code&gt; 의 플래그가 설정이 속성은 선택한 막대를 소유하는 시리즈를 보유하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="f868c3e3563d31c44c121acc079893e8d3d64c07" translate="yes" xml:space="preserve">
          <source>The selected series or null.</source>
          <target state="translated">선택된 계열 또는 null</target>
        </trans-unit>
        <trans-unit id="a9545880f43af0ac871d8c1a86b6486de750864e" translate="yes" xml:space="preserve">
          <source>The selected series or null. If &lt;a href=&quot;qabstract3dgraph#selectionMode-prop&quot;&gt;selectionMode&lt;/a&gt; has the &lt;code&gt;SelectionMultiSeries&lt;/code&gt; flag set, this property holds the series which owns the selected point.</source>
          <target state="translated">선택된 계열 또는 null 경우 &lt;a href=&quot;qabstract3dgraph#selectionMode-prop&quot;&gt;의 selectionMode가&lt;/a&gt; 이 &lt;code&gt;SelectionMultiSeries&lt;/code&gt; 의 플래그 세트를,이 속성은 선택한 점을 소유하고있는 시리즈를 보유하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b28ca5b36879e7260535f1d3ef5c38209551953d" translate="yes" xml:space="preserve">
          <source>The selected state of items is set or unset, depending on several pre-defined modes - e.g., single selection, multiple selection, etc. - when the user interacts with the items.</source>
          <target state="translated">사용자가 항목과 상호 작용할 때 선택된 여러 상태 (예 : 단일 선택, 다중 선택 등)에 따라 선택한 항목 상태가 설정 또는 설정 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="027691232ac3acd28d7285bf31257cd20b02046d" translate="yes" xml:space="preserve">
          <source>The selected text color, used in selections.</source>
          <target state="translated">선택에 사용되는 선택된 텍스트 색상.</target>
        </trans-unit>
        <trans-unit id="e83c8e8372ab6d37b98e5af111064a0d9910b586" translate="yes" xml:space="preserve">
          <source>The selected text the context menu was created for.</source>
          <target state="translated">컨텍스트 메뉴가 작성된 선택된 텍스트</target>
        </trans-unit>
        <trans-unit id="225789d8c5ce64faf0c7e069a534d13563939653" translate="yes" xml:space="preserve">
          <source>The selection behavior is controlled by the &lt;a href=&quot;#show-decoration-selected-prop&quot;&gt;show-decoration-selected&lt;/a&gt; property.</source>
          <target state="translated">선택 동작은 &lt;a href=&quot;#show-decoration-selected-prop&quot;&gt;show-decoration-selected&lt;/a&gt; 속성에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a9990819d2cae5e74814fe6522839e37b394f7c" translate="yes" xml:space="preserve">
          <source>The selection behavior is controlled by the &lt;a href=&quot;stylesheet-reference#show-decoration-selected-prop&quot;&gt;show-decoration-selected&lt;/a&gt; property.</source>
          <target state="translated">선택 동작은 &lt;a href=&quot;stylesheet-reference#show-decoration-selected-prop&quot;&gt;show-decoration-selected&lt;/a&gt; 속성에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4a0079a940310022d313275b65bbb7d46f3f991" translate="yes" xml:space="preserve">
          <source>The selection changes whenever an item is selected or unselected, a selection area is set, cleared or otherwise changed, if a preselected item is added to the scene, or if a selected item is removed from the scene.</source>
          <target state="translated">사전 선택 항목이 장면에 추가되거나 선택한 항목이 장면에서 제거되면 항목을 선택하거나 선택 해제 할 때마다 선택 영역이 선택되거나 선택 영역이 지워지거나 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b8f40d878bfa593698118bc046ab82655b3ecfe" translate="yes" xml:space="preserve">
          <source>The selection color.</source>
          <target state="translated">선택 색상.</target>
        </trans-unit>
        <trans-unit id="2d46c060788df668273e7f9fa27f0470e465e562" translate="yes" xml:space="preserve">
          <source>The selection has changed in a menu or item view.</source>
          <target state="translated">메뉴 또는 항목보기에서 선택이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="b31a1e6711396af52f0270dd2c216b969cdd7517" translate="yes" xml:space="preserve">
          <source>The selection is applied to the selection model using a command defined by a combination of &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;selection flags&lt;/a&gt;. In this case, the flags used cause the items recorded in the selection object to be included in the selection model, regardless of their previous state. The resulting selection is shown by the view.</source>
          <target state="translated">선택은 &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;선택 플래그&lt;/a&gt; 의 조합으로 정의 된 명령을 사용하여 선택 모델에 적용됩니다 . 이 경우, 사용 된 플래그는 이전 상태에 관계없이 선택 오브젝트에 기록 된 항목이 선택 모델에 포함되도록합니다. 결과 선택은보기로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="20f6a4e4bd2d333777c8dc67a250d5e2e66c0a89" translate="yes" xml:space="preserve">
          <source>The selection is asynchronous. If no certificate is selected and no copy of the object is kept alive, loading will continue without a certificate.</source>
          <target state="translated">선택은 비동기 적입니다. 인증서를 선택하지 않고 오브젝트 사본이 활성 상태로 유지되지 않으면 인증서없이로드가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="4b805fd90dbe641a21d0d2422b1a073f3d54071f" translate="yes" xml:space="preserve">
          <source>The selection mode specifies whether the selection is updated on a per character or a per word basis. If not specified the selection mode will default to &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt;.SelectCharacters.</source>
          <target state="translated">선택 모드는 선택이 문자 또는 단어 단위로 업데이트되는지 여부를 지정합니다. 지정하지 않으면 선택 모드는 기본적으로 &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; .SelectCharacters로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e7be275e6780f0e340db55cdd1b7818ad78044da" translate="yes" xml:space="preserve">
          <source>The selection mode specifies whether the selection is updated on a per character or a per word basis. If not specified the selection mode will default to &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt;.SelectCharacters.</source>
          <target state="translated">선택 모드는 선택이 문자 또는 단어 단위로 업데이트되는지 여부를 지정합니다. 지정하지 않으면 선택 모드는 기본적으로 &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; .SelectCharacters로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ed68da46b3aa1881ad19587ae20c24bcd4bfeda5" translate="yes" xml:space="preserve">
          <source>The selection mode specifies whether the selection is updated on a per character or a per word basis. If not specified the selection mode will default to &lt;code&gt;TextEdit.SelectCharacters&lt;/code&gt;.</source>
          <target state="translated">선택 모드는 선택 항목이 문자 단위 또는 단어 단위로 업데이트되는지 여부를 지정합니다. 지정하지 않으면 선택 모드는 기본적으로 &lt;code&gt;TextEdit.SelectCharacters&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="57bace819c6835532bb72b1c8b68ea43d3c59e41" translate="yes" xml:space="preserve">
          <source>The selection mode specifies whether the selection is updated on a per character or a per word basis. If not specified the selection mode will default to &lt;code&gt;TextInput.SelectCharacters&lt;/code&gt;.</source>
          <target state="translated">선택 모드는 선택 항목이 문자 단위 또는 단어 단위로 업데이트되는지 여부를 지정합니다. 지정하지 않으면 선택 모드는 기본적으로 &lt;code&gt;TextInput.SelectCharacters&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a3929f0953d3c6a993bcddafaf1b379ea22dbb86" translate="yes" xml:space="preserve">
          <source>The selection model emits signals to indicate changes in the selection. These notify other components about changes to both the selection as a whole and the currently focused item in the item model. We can connect the &lt;a href=&quot;qitemselectionmodel#selectionChanged&quot;&gt;selectionChanged()&lt;/a&gt; signal to a slot, and examine the items in the model that are selected or deselected when the selection changes. The slot is called with two &lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt; objects: one contains a list of indexes that correspond to newly selected items; the other contains indexes that correspond to newly deselected items.</source>
          <target state="translated">선택 모델은 선택의 변화를 나타내는 신호를 방출합니다. 이들은 전체 선택 항목과 현재 초점이있는 항목에 대한 변경 사항을 다른 구성 요소에 알려줍니다. &lt;a href=&quot;qitemselectionmodel#selectionChanged&quot;&gt;selectionChanged ()&lt;/a&gt; 신호를 슬롯에 연결하고 선택 이 변경 될 때 선택되거나 선택 해제 된 모델의 항목을 검사 할 수 있습니다. 슬롯은 두 개의 &lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt; 오브젝트 로 호출 됩니다. 하나는 새로 선택된 항목에 해당하는 인덱스 목록을 포함합니다. 다른 하나는 새로 선택 해제 된 항목에 해당하는 색인을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9dc0e542db8937f936f1fbed256ddd6c742ed276" translate="yes" xml:space="preserve">
          <source>The selection model used in the item view classes provides a general description of selections based on the facilities of the model/view architecture. Although the standard classes for manipulating selections are sufficient for the item views provided, the selection model allows you to create specialized selection models to suit the requirements for your own item models and views.</source>
          <target state="translated">아이템 뷰 클래스에서 사용되는 선택 모델은 모델 / 뷰 아키텍처의 기능에 기반한 선택에 대한 일반적인 설명을 제공합니다. 선택 조작을위한 표준 클래스로 제공된 항목보기에 충분하지만 선택 모델을 사용하면 자체 항목 모델 및보기의 요구 사항에 맞게 특수한 선택 모델을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06ef40f5a02bf6f8a0eba1879414a96233579192" translate="yes" xml:space="preserve">
          <source>The selection of items can be modified using various operations that are defined by the selection flags. The selection that results from these operations may have a complex structure, but it is represented efficiently by the selection model. The use of different selection flags to manipulate the selected items is described when we examine how to update a selection.</source>
          <target state="translated">선택 플래그에 의해 정의 된 다양한 조작을 사용하여 항목 선택을 수정할 수 있습니다. 이러한 연산으로 인한 선택은 복잡한 구조를 가질 수 있지만 선택 모델로 효율적으로 표현됩니다. 선택된 항목을 조작하기 위해 다른 선택 플래그를 사용하는 것은 선택을 업데이트하는 방법을 검토 할 때 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="6d9536ffa403d2dc16ea8a7eeae41800f4acb59f" translate="yes" xml:space="preserve">
          <source>The selection of layouts at runtime is affected by the &lt;code&gt;QT_VIRTUALKEYBOARD_LAYOUT_PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">런타임시 레이아웃 선택은 &lt;code&gt;QT_VIRTUALKEYBOARD_LAYOUT_PATH&lt;/code&gt; 환경 변수의 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="b56fcd3712426022ab1b18efa5342ce09a25c8c9" translate="yes" xml:space="preserve">
          <source>The selection of the runtime style is affected by an environment variable QT_VIRTUALKEYBOARD_STYLE, which can be set to the name of the built-in style, e.g. &quot;retro&quot;, or any of the custom styles installed into the Styles directory:</source>
          <target state="translated">런타임 스타일 선택은 환경 변수 QT_VIRTUALKEYBOARD_STYLE의 영향을받습니다.이 변수는 내장 스타일의 이름 (예 : &quot;retro&quot;) 또는 스타일 디렉토리에 설치된 사용자 정의 스타일의 이름으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a1f38c0d0fe6497529229e1b0adfc656c0b1f84" translate="yes" xml:space="preserve">
          <source>The selection will be</source>
          <target state="translated">선택은</target>
        </trans-unit>
        <trans-unit id="9c1f507db5f0fece60d9f6b6f4882423a97a50a8" translate="yes" xml:space="preserve">
          <source>The semantic can be one of the following:</source>
          <target state="translated">의미는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83c3f8309b06aa0826ce1a92ba1534a686747adb" translate="yes" xml:space="preserve">
          <source>The semantic is not set.</source>
          <target state="translated">의미 체계가 설정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b4f65db0dd7cfe52390c48f32b338226d7c61132" translate="yes" xml:space="preserve">
          <source>The sender object which is associated with this signal transition.</source>
          <target state="translated">이 신호 전환과 관련된 발신자 개체입니다.</target>
        </trans-unit>
        <trans-unit id="3d04bee3eba332307293f0be5fc2cb032b928b0f" translate="yes" xml:space="preserve">
          <source>The sensor data is delivered via &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; and its sub-classes.</source>
          <target state="translated">센서 데이터는 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; 및 해당 서브 클래스 를 통해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="9aa520ce1bc9a7004e6f1824545f6a95fae3525f" translate="yes" xml:space="preserve">
          <source>The sensor does not take ownership of the filter. &lt;a href=&quot;qsensorfilter&quot;&gt;QSensorFilter&lt;/a&gt; will inform the sensor if it is destroyed.</source>
          <target state="translated">센서는 필터의 소유권을 갖지 않습니다. &lt;a href=&quot;qsensorfilter&quot;&gt;QSensorFilter&lt;/a&gt; 는 센서가 파손되면 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="2663833947a3a5cdf07f9534c8171a53b7702792" translate="yes" xml:space="preserve">
          <source>The sensor may fail to start for several reasons.</source>
          <target state="translated">여러 가지 이유로 센서가 시작되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="077dd2df099878f9d1bb9ec4ad1a2f7875639d60" translate="yes" xml:space="preserve">
          <source>The sensor reading can be found in the &lt;a href=&quot;qsensor#reading-prop&quot;&gt;QSensor::reading&lt;/a&gt; property. Note that the reading object is a volatile cache of the most recent sensor reading that has been received so the application should process the reading immediately or save the values somewhere for later processing.</source>
          <target state="translated">센서 판독 값은 &lt;a href=&quot;qsensor#reading-prop&quot;&gt;QSensor :: reading&lt;/a&gt; 특성 에서 찾을 수 있습니다 . 판독 개체는 가장 최근에 수신 된 센서 판독 값의 휘발성 캐시이므로 응용 프로그램에서 판독을 즉시 처리하거나 나중에 처리 할 수 ​​있도록 값을 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b3f459314e8c1506c401238363b10625e6efaaf" translate="yes" xml:space="preserve">
          <source>The sensor reports reflectance as a decimal fraction in the range of 0 - 1. That is, 0 indicates nothing was detected within the range of the sensor and 1 indicates the infra-red signal returned at the full power level that it was sent at.</source>
          <target state="translated">센서는 반사율을 0-1 범위의 소수로 표시합니다. 즉, 0은 센서 범위 내에서 아무것도 감지되지 않았 음을 나타내고 1은 전송 된 최대 전력 레벨에서 반환 된 적외선 신호를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ca9b979404e92d997a82408d6b792684f8e23f52" translate="yes" xml:space="preserve">
          <source>The sensor type.</source>
          <target state="translated">센서 타입.</target>
        </trans-unit>
        <trans-unit id="08d1d29ec8fa6d6c882bb37fa1e5575eaa027626" translate="yes" xml:space="preserve">
          <source>The separation of content and presentation is achieved by the use of a standard model interface provided by &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;, a standard view interface provided by &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt;, and the use of model indexes that represent items of data in a general way. Views typically manage the overall layout of the data obtained from models. They may render individual items of data themselves, or use &lt;a href=&quot;#delegate-classes&quot;&gt;delegates&lt;/a&gt; to handle both rendering and editing features.</source>
          <target state="translated">증거의 분리에 의해 제공된 표준 모델 인터페이스의 사용에 의해 달성된다 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 의해 제공된 표준보기 인터페이스 &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt; 하고 일반적인 방법으로 데이터의 항목을 나타내는 모델 인덱스의 용도. 뷰는 일반적으로 모델에서 얻은 데이터의 전체 레이아웃을 관리합니다. 개별 데이터 항목을 직접 렌더링하거나 &lt;a href=&quot;#delegate-classes&quot;&gt;대리자&lt;/a&gt; 를 사용하여 렌더링 및 편집 기능을 모두 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="512f9b32cf58b10648deaf54f64f84508d000736" translate="yes" xml:space="preserve">
          <source>The separation of content and presentation is achieved by the use of a standard model interface provided by &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;, a standard view interface provided by &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt;, and the use of model indexes that represent items of data in a general way. Views typically manage the overall layout of the data obtained from models. They may render individual items of data themselves, or use &lt;a href=&quot;model-view-programming#delegate-classes&quot;&gt;delegates&lt;/a&gt; to handle both rendering and editing features.</source>
          <target state="translated">증거의 분리에 의해 제공된 표준 모델 인터페이스의 사용에 의해 달성된다 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 의해 제공된 표준보기 인터페이스 &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt; 하고 일반적인 방법으로 데이터의 항목을 나타내는 모델 인덱스의 용도. 보기는 일반적으로 모델에서 얻은 데이터의 전체 레이아웃을 관리합니다. 개별 데이터 항목을 직접 렌더링하거나 &lt;a href=&quot;model-view-programming#delegate-classes&quot;&gt;대리자&lt;/a&gt; 를 사용하여 렌더링 및 편집 기능을 모두 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="fcccee6e0d426cdaaad9937e7b3b590baf27104f" translate="yes" xml:space="preserve">
          <source>The separation of functionality between the model/view components allows models to be created that can take advantage of existing views. This approach lets us present data from a variety of sources using standard graphical user interface components, such as &lt;a href=&quot;qlistview&quot;&gt;QListView&lt;/a&gt;, &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, and &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt;.</source>
          <target state="translated">모델 / 뷰 구성 요소 간 기능이 분리되어 기존 뷰를 활용할 수있는 모델을 작성할 수 있습니다. 이 접근 방식을 통해 &lt;a href=&quot;qlistview&quot;&gt;QListView&lt;/a&gt; , &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt; 및 &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; 와 같은 표준 그래픽 사용자 인터페이스 구성 요소를 사용하여 다양한 소스의 데이터를 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b952964f7c7f9e08f10f4173253541c4ca090bb5" translate="yes" xml:space="preserve">
          <source>The separator between each column.</source>
          <target state="translated">각 열 사이의 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="1a78bf82482dcada129f191ca8dc2bdd9d5451af" translate="yes" xml:space="preserve">
          <source>The separator can be either underscore or a minus sign.</source>
          <target state="translated">구분 기호는 밑줄 또는 빼기 기호 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fabc1c4326c376d7254796f1e47aeebdc562fa0" translate="yes" xml:space="preserve">
          <source>The separator in a &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; when using &lt;a href=&quot;qdockwidget&quot;&gt;QDockWidget&lt;/a&gt; is styled using the &lt;a href=&quot;#separator-sub&quot;&gt;::separator&lt;/a&gt; subcontrol.</source>
          <target state="translated">&lt;a href=&quot;qdockwidget&quot;&gt;QDockWidget을&lt;/a&gt; 사용할 때 &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; 의 구분 기호 는 &lt;a href=&quot;#separator-sub&quot;&gt;:: separator &lt;/a&gt;하위 컨트롤을 사용하여 스타일이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad25c575918277e6d80f4cbd9f020a8030c007fd" translate="yes" xml:space="preserve">
          <source>The separator in a &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; when using &lt;a href=&quot;qdockwidget&quot;&gt;QDockWidget&lt;/a&gt; is styled using the &lt;a href=&quot;stylesheet-reference#separator-sub&quot;&gt;::separator&lt;/a&gt; subcontrol.</source>
          <target state="translated">&lt;a href=&quot;qdockwidget&quot;&gt;QDockWidget을&lt;/a&gt; 사용할 때 &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; 의 구분 기호 는 &lt;a href=&quot;stylesheet-reference#separator-sub&quot;&gt;:: separator &lt;/a&gt;하위 컨트롤을 사용하여 스타일이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="77bddffcf82e9698d52ab1f4dfd22300d5286762" translate="yes" xml:space="preserve">
          <source>The separator in a toolbar.</source>
          <target state="translated">툴바의 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="1200fd769a6c9937943cc5bd9e55e22c0fe31673" translate="yes" xml:space="preserve">
          <source>The separator is styled using the &lt;a href=&quot;#separator-sub&quot;&gt;::separator&lt;/a&gt; subcontrol.</source>
          <target state="translated">구분 기호는 &lt;a href=&quot;#separator-sub&quot;&gt;:: separator&lt;/a&gt; 하위 컨트롤을 사용하여 스타일이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="923d46bc8a6fa4a5637b166ee84fe442bcb22bb0" translate="yes" xml:space="preserve">
          <source>The separator is styled using the &lt;a href=&quot;stylesheet-reference#separator-sub&quot;&gt;::separator&lt;/a&gt; subcontrol.</source>
          <target state="translated">구분 기호는 &lt;a href=&quot;stylesheet-reference#separator-sub&quot;&gt;:: separator&lt;/a&gt; 하위 제어를 사용하여 스타일이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce103b06586aef114cc7759f9ba9b53004218ffe" translate="yes" xml:space="preserve">
          <source>The separator of a &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; or in a &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; 또는 &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; 의 구분자입니다 .</target>
        </trans-unit>
        <trans-unit id="34b0cb4eaa5149f5edba78439e54abac92919a27" translate="yes" xml:space="preserve">
          <source>The separator of a &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt; is styled using the &lt;a href=&quot;#separator-sub&quot;&gt;::separator&lt;/a&gt; subcontrol.</source>
          <target state="translated">&lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt; 의 구분 기호 는 &lt;a href=&quot;#separator-sub&quot;&gt;:: separator &lt;/a&gt;하위 컨트롤을 사용하여 스타일이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="76058e5c6dabd1dabc7205b2dc1e8b36d092ecb9" translate="yes" xml:space="preserve">
          <source>The separator of a &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt; is styled using the &lt;a href=&quot;stylesheet-reference#separator-sub&quot;&gt;::separator&lt;/a&gt; subcontrol.</source>
          <target state="translated">&lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt; 의 구분 기호 는 &lt;a href=&quot;stylesheet-reference#separator-sub&quot;&gt;:: separator &lt;/a&gt;하위 컨트롤을 사용하여 스타일이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d22851eeaca036a75e6ea92e4001b0cb2e3d580e" translate="yes" xml:space="preserve">
          <source>The serial number of the screen.</source>
          <target state="translated">화면의 일련 번호입니다.</target>
        </trans-unit>
        <trans-unit id="6497317f401be2ce166744dca1d051262dc91331" translate="yes" xml:space="preserve">
          <source>The serial port where the NMEA stream is coming.</source>
          <target state="translated">NMEA 스트림이 들어오는 직렬 포트입니다.</target>
        </trans-unit>
        <trans-unit id="8fac2cd35241ffd0009ed10eff8d5a816928cc58" translate="yes" xml:space="preserve">
          <source>The serialization format is a quint32 length specifier first, then</source>
          <target state="translated">직렬화 형식은 먼저 quint32 길이 지정자입니다.</target>
        </trans-unit>
        <trans-unit id="4efbc5570c1b0216ffd4f4c60ed8cee1621c47b0" translate="yes" xml:space="preserve">
          <source>The series</source>
          <target state="translated">시리즈</target>
        </trans-unit>
        <trans-unit id="0a18732ac71955e5d00856fd829e1ff25aba4339" translate="yes" xml:space="preserve">
          <source>The series assumes ownership of any proxy set to it and deletes any previously set proxy when a new one is added. The proxy cannot be null or set to another series.</source>
          <target state="translated">이 시리즈는 프록시 세트의 소유권을 가정하고 새 프록시가 추가되면 이전에 설정된 프록시를 삭제합니다. 프록시는 null이거나 다른 시리즈로 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1ea217888f9f1129a122fd2ecf2aa2a6d063dbde" translate="yes" xml:space="preserve">
          <source>The series keeps track of the sum of all the slices it holds.</source>
          <target state="translated">시리즈는 보유하고있는 모든 슬라이스의 합계를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="c5ebd7f00d876c0ae6b96b81be4b517cac350332" translate="yes" xml:space="preserve">
          <source>The series name can be used in item label format with the tag &lt;code&gt;@seriesName&lt;/code&gt;.</source>
          <target state="translated">시리즈 이름은 &lt;code&gt;@seriesName&lt;/code&gt; 태그와 함께 항목 레이블 형식으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d36bad8cf642f8705a7c26e47ea64994381da674" translate="yes" xml:space="preserve">
          <source>The series name. It can be used in item label format with the tag &lt;code&gt;@seriesName&lt;/code&gt;.</source>
          <target state="translated">시리즈 이름. &lt;code&gt;@seriesName&lt;/code&gt; 태그를 사용하여 항목 레이블 형식으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c5a9b4e1eb65f890c8dbf501fdc3be00c3b9a901" translate="yes" xml:space="preserve">
          <source>The series of the graph. By default, this property contains an empty list. To set the series, either use the &lt;a href=&quot;qml-qtdatavisualization-bars3d#addSeries-method&quot;&gt;addSeries()&lt;/a&gt; function or define them as children of the graph.</source>
          <target state="translated">그래프의 시리즈. 기본적으로이 속성에는 빈 목록이 포함됩니다. 계열을 설정하려면 &lt;a href=&quot;qml-qtdatavisualization-bars3d#addSeries-method&quot;&gt;addSeries ()&lt;/a&gt; 함수를 사용하거나 그래프의 자식으로 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="186123839edf894db84cc5ecbbc5d359f5bd38ae" translate="yes" xml:space="preserve">
          <source>The series that is used by the mapper. All the data in the series is discarded when it is set to the mapper. When a new series is specified, the old series is disconnected (but it preserves its data).</source>
          <target state="translated">매퍼가 사용하는 시리즈입니다. 매퍼로 설정하면 계열의 모든 데이터가 삭제됩니다. 새 시리즈를 지정하면 이전 시리즈의 연결이 끊어 지지만 데이터는 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="2621e588ddf6f57fe34919656012f22b9411f199" translate="yes" xml:space="preserve">
          <source>The series this proxy is attached to.</source>
          <target state="translated">이 프록시가 첨부 된 시리즈입니다.</target>
        </trans-unit>
        <trans-unit id="2d1151d3c6cf747985723f167da67e90b8b2e138" translate="yes" xml:space="preserve">
          <source>The server answered the request with an error.</source>
          <target state="translated">서버가 오류로 요청에 응답했습니다.</target>
        </trans-unit>
        <trans-unit id="0bda6a51643ff3508ee838332a277c57cc0b0227" translate="yes" xml:space="preserve">
          <source>The server can create multiple instances of each exported class. This is the default. All instances will live in the same thread, and will share static resources.</source>
          <target state="translated">서버는 내 보낸 각 클래스의 인스턴스를 여러 개 만들 수 있습니다. 이것이 기본값입니다. 모든 인스턴스는 동일한 스레드에 있으며 정적 리소스를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="e23fea41beb82b97792beec3f181b1dee550750a" translate="yes" xml:space="preserve">
          <source>The server cannot perform the program function received in the query. This code is returned for an unsuccessful programming request. The client should request diagnostic or error information from the server.</source>
          <target state="translated">서버가 조회에서 수신 한 프로그램 기능을 수행 할 수 없습니다. 실패한 프로그래밍 요청에 대해이 코드가 리턴됩니다. 클라이언트는 서버에 진단 또는 오류 정보를 요청해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d0c4a40ec5b8789a3582d28229dda86e9c747ea" translate="yes" xml:space="preserve">
          <source>The server did not authorize access to the resource.</source>
          <target state="translated">서버가 자원에 대한 액세스 권한을 부여하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5ddb1711d2c8d4f66da9a7a81f1d27db5fde237a" translate="yes" xml:space="preserve">
          <source>The server does not export an implementation of a &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt;. Use the &lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt;() macro in one of the project's implementation files to instantiate and export a factory, or use the &lt;a href=&quot;qaxfactory#QAXCLASS&quot;&gt;QAXCLASS&lt;/a&gt;() or QAXFACTORY_DEFAULT() macro to use the default factory.</source>
          <target state="translated">서버는 &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; 의 구현을 내 보내지 않습니다 . 사용 &lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt; 의 인스턴스를 생성하기위한 프로젝트의 실행 파일 중 하나에 () 매크로를하고 공장을 수출하거나 사용 &lt;a href=&quot;qaxfactory#QAXCLASS&quot;&gt;QAXCLASS를&lt;/a&gt; () 또는 QAXFACTORY_DEFAULT () 디폴트의 팩토리를 사용하는 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="5f5ff42fc1b22da7df689ff990c4e79c952ff54b" translate="yes" xml:space="preserve">
          <source>The server does not export an implementation of a &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt;. Use the &lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt;() macro in one of the project's implementation files to instantiate and export a factory, or use the &lt;a href=&quot;qaxfactory#QAXFACTORY_DEFAULT&quot;&gt;QAXFACTORY_DEFAULT&lt;/a&gt;() macro to use the default factory.</source>
          <target state="translated">서버는 &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; 의 구현을 내 보내지 않습니다 . 사용 &lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt; 의 인스턴스를 생성하기위한 프로젝트의 실행 파일 중 하나에 () 매크로를하고 공장을 수출하거나 사용 &lt;a href=&quot;qaxfactory#QAXFACTORY_DEFAULT&quot;&gt;QAXFACTORY_DEFAULT&lt;/a&gt; 기본 팩토리를 사용하는 매크로를 ().</target>
        </trans-unit>
        <trans-unit id="dd528ffb322c8ea40bd4b7d6136912e32c25b357" translate="yes" xml:space="preserve">
          <source>The server does not have the requested data.</source>
          <target state="translated">서버에 요청 된 데이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e6feff97d123a45d6a16ad47e447e2b32b7a79c" translate="yes" xml:space="preserve">
          <source>The server exports more than one implementation of a &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt;, or exports the same implementation twice. If you use the default factory, the &lt;a href=&quot;qaxfactory#QAXFACTORY_BEGIN&quot;&gt;QAXFACTORY_BEGIN&lt;/a&gt;() or QAXFACTORY_DEFAULT() macro must only be used once in the project. Use a custom &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; implementation and the &lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt;() macro if the server provides multiple ActiveX controls.</source>
          <target state="translated">서버는 &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; 의 둘 이상의 구현을 내보내 거나 동일한 구현을 두 번 내 보냅니다. 기본 팩토리를 사용하는 경우 &lt;a href=&quot;qaxfactory#QAXFACTORY_BEGIN&quot;&gt;QAXFACTORY_BEGIN&lt;/a&gt; () 또는 QAXFACTORY_DEFAULT () 매크로는 프로젝트에서 한 번만 사용해야합니다. 서버가 여러 ActiveX 컨트롤을 제공하는 경우 사용자 정의 &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; 구현 및 &lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt; () 매크로를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="255040717b1cc12b6cb39df7905cacdf21bc33fc" translate="yes" xml:space="preserve">
          <source>The server exports more than one implementation of a &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt;, or exports the same implementation twice. If you use the default factory, the &lt;a href=&quot;qaxfactory#QAXFACTORY_DEFAULT&quot;&gt;QAXFACTORY_DEFAULT&lt;/a&gt;() macro must only be used once in the project. Use a custom &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; implementation and the &lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt;() macro if the server provides multiple ActiveX controls.</source>
          <target state="translated">서버는 둘 이상의 &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; 구현을 내보내 거나 동일한 구현을 두 번 내 보냅니다. 기본 팩토리를 사용하는 경우 &lt;a href=&quot;qaxfactory#QAXFACTORY_DEFAULT&quot;&gt;QAXFACTORY_DEFAULT&lt;/a&gt; () 매크로는 프로젝트에서 한 번만 사용해야합니다. 서버가 다중 ActiveX 제어를 제공하는 경우 사용자 정의 &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; 구현 및 &lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt; () 매크로를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a3a61222425a0cabf7af540f372b9df2d56e20ec" translate="yes" xml:space="preserve">
          <source>The server has gone down.</source>
          <target state="translated">서버가 다운되었습니다.</target>
        </trans-unit>
        <trans-unit id="fa67b1b830836d429892537ee4aeaf311e833f2d" translate="yes" xml:space="preserve">
          <source>The server is engaged in processing a long duration program command.</source>
          <target state="translated">서버가 장기간 프로그램 명령을 처리하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0c5704ce5c0ea6138a655094b7df4a065c2ae89" translate="yes" xml:space="preserve">
          <source>The server is started automatically with</source>
          <target state="translated">서버는 다음과 같이 자동으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="0a97ca97e984ce1b9f5798975dc075c542be36e8" translate="yes" xml:space="preserve">
          <source>The server is stopped automatically when the main() function returns.</source>
          <target state="translated">main () 함수가 반환되면 서버가 자동으로 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="a0748992293b4aa402fec2d25888934f597f16f7" translate="yes" xml:space="preserve">
          <source>The server operates in non-secure mode (over ws)</source>
          <target state="translated">서버가 비보안 모드로 작동합니다 (ws 이상)</target>
        </trans-unit>
        <trans-unit id="fedd632d24527afc51edfd5b82774f432a945c7e" translate="yes" xml:space="preserve">
          <source>The server operates in secure mode (over wss)</source>
          <target state="translated">서버가 보안 모드 (wss 이상)에서 작동</target>
        </trans-unit>
        <trans-unit id="33d11424b3a5ad59d53563b86562ea1fbb5bf760" translate="yes" xml:space="preserve">
          <source>The server process can create only one instance of each exported class. COM starts a new process for each request. This is typically used in servers that export only one creatable class.</source>
          <target state="translated">서버 프로세스는 내 보낸 각 클래스의 인스턴스를 하나만 만들 수 있습니다. COM은 각 요청에 대해 새로운 프로세스를 시작합니다. 이것은 일반적으로 하나의 작성 가능 클래스 만 내보내는 서버에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0c76c04006173d7aad437d4cb3f2f0ee4cf67a1a" translate="yes" xml:space="preserve">
          <source>The server push. Allows to enable or disable server push. Sent as 'SETTINGS_ENABLE_PUSH' parameter in the initial 'SETTINGS' frame.</source>
          <target state="translated">서버 푸시입니다. 서버 푸시를 활성화 또는 비활성화 할 수 있습니다. 초기 'SETTINGS'프레임에서 'SETTINGS_ENABLE_PUSH'매개 변수로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="1606fa13636bd90868689c2589e9c6f0e26579d6" translate="yes" xml:space="preserve">
          <source>The server's response to a token request provided no token identifier.</source>
          <target state="translated">토큰 요청에 대한 서버의 응답은 토큰 식별자를 제공하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5565f95a303296619425bf6d4afc96dd66a4663e" translate="yes" xml:space="preserve">
          <source>The server's response to a token request provided no token secret.</source>
          <target state="translated">토큰 요청에 대한 서버의 응답은 토큰 시크릿을 제공하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="67b4fc4ff7aaa7107d5a75b7b419c0cbe853573e" translate="yes" xml:space="preserve">
          <source>The service being bound is an isolated, external service. See &lt;a href=&quot;https://developer.android.com/reference/android/content/Context.html#BIND_EXTERNAL_SERVICE&quot;&gt;BIND_EXTERNAL_SERVICE&lt;/a&gt; documentation for more details.</source>
          <target state="translated">바인딩되는 서비스는 격리 된 외부 서비스입니다. 자세한 내용은 &lt;a href=&quot;https://developer.android.com/reference/android/content/Context.html#BIND_EXTERNAL_SERVICE&quot;&gt;BIND_EXTERNAL_SERVICE&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3e87a322c75a22e9d37b965dad70eafb0a3ab373" translate="yes" xml:space="preserve">
          <source>The service could not allocate resources required to function correctly.</source>
          <target state="translated">서비스가 올바르게 작동하는 데 필요한 자원을 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4c67d05c074bd5cce136c680c6e8d56b0ab1c0d5" translate="yes" xml:space="preserve">
          <source>The service details are being discovered.</source>
          <target state="translated">서비스 세부 사항이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="792a478eb56d5524d8a3f98c9b0c2a7408a98260" translate="yes" xml:space="preserve">
          <source>The service details are yet to be discovered by calling &lt;a href=&quot;qlowenergyservice#discoverDetails&quot;&gt;discoverDetails&lt;/a&gt;(). The only reliable pieces of information are its &lt;a href=&quot;qlowenergyservice#serviceUuid&quot;&gt;serviceUuid&lt;/a&gt;() and &lt;a href=&quot;qlowenergyservice#serviceName&quot;&gt;serviceName&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qlowenergyservice#discoverDetails&quot;&gt;discoverDetails&lt;/a&gt; () 를 호출하여 서비스 세부 사항을 아직 발견 할 수 없습니다 . 신뢰할 수있는 유일한 정보는 &lt;a href=&quot;qlowenergyservice#serviceUuid&quot;&gt;serviceUuid&lt;/a&gt; () 및 &lt;a href=&quot;qlowenergyservice#serviceName&quot;&gt;serviceName&lt;/a&gt; ()입니다.</target>
        </trans-unit>
        <trans-unit id="26177c9e14bded15574a12efed218e756974c43d" translate="yes" xml:space="preserve">
          <source>The service details have been discovered.</source>
          <target state="translated">서비스 세부 사항이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="ee02068568d9767f7ea30a14715582bd127856fa" translate="yes" xml:space="preserve">
          <source>The service discovery may find Bluetooth Low Energy services too if the target device is a combination of a classic and Low Energy device. Those devices are required to advertise their Low Energy services via SDP. If the target device only supports Bluetooth Low Energy services, it is likely to not advertise them via SDP. The &lt;a href=&quot;qlowenergycontroller&quot;&gt;QLowEnergyController&lt;/a&gt; class should be utilized to perform the service discovery on Low Energy devices.</source>
          <target state="translated">대상 장치가 클래식 장치와 저에너지 장치의 조합 인 경우 서비스 검색에서 Bluetooth 저에너지 서비스도 찾을 수 있습니다. 이러한 장치는 SDP를 통해 저에너지 서비스를 광고해야합니다. 대상 장치가 Bluetooth 저에너지 서비스 만 지원하는 경우 SDP를 통해 광고하지 않을 수 있습니다. &lt;a href=&quot;qlowenergycontroller&quot;&gt;QLowEnergyController의&lt;/a&gt; 클래스는 낮은 에너지 장치에서 서비스 검색을 수행하는 데 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="d772e68f67a4aebb2e167acd2199443215422dab" translate="yes" xml:space="preserve">
          <source>The service does not require any security.</source>
          <target state="translated">서비스에는 보안이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d86c51016ba95936bf86576e491d1612e29c3290" translate="yes" xml:space="preserve">
          <source>The service is a primary service.</source>
          <target state="translated">서비스는 기본 서비스입니다.</target>
        </trans-unit>
        <trans-unit id="05ef579646ea8f221322502f1cc0643037342a95" translate="yes" xml:space="preserve">
          <source>The service is a secondary service. Secondary services are included by other services to implement some higher-level functionality.</source>
          <target state="translated">서비스는 보조 서비스입니다. 보조 서비스는 다른 서비스에 포함되어 일부 고급 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="89faeafc744b4873178ea74106d1a56dae401b43" translate="yes" xml:space="preserve">
          <source>The service is a top-level/primary service. If this type flag is not set, the service is considered to be a secondary service. Each service may be included by another service which is indicated by IncludedService.</source>
          <target state="translated">이 서비스는 최상위 / 기본 서비스입니다. 이 유형 플래그를 설정하지 않으면 서비스는 보조 서비스로 간주됩니다. 각 서비스는 IncludedService로 표시되는 다른 서비스에 의해 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce673f11a23e08f6c7334bc7dce2edf38a3fa382" translate="yes" xml:space="preserve">
          <source>The service is associated with a controller object in the &lt;a href=&quot;qlowenergycontroller#Role-enum&quot;&gt;peripheral role&lt;/a&gt;. Such service objects do not change their state. This value was introduced by Qt 5.7.</source>
          <target state="translated">서비스는 &lt;a href=&quot;qlowenergycontroller#Role-enum&quot;&gt;주변 장치 역할&lt;/a&gt; 의 컨트롤러 개체와 연결됩니다 . 이러한 서비스 개체는 상태를 변경하지 않습니다. 이 값은 Qt 5.7에 의해 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="bc7c4dda9bec3373cdb156a182002caae696efca" translate="yes" xml:space="preserve">
          <source>The service is included by another service. On some platforms, this flag cannot be determined until the service that includes the current service was discovered.</source>
          <target state="translated">이 서비스는 다른 서비스에 포함되어 있습니다. 일부 플랫폼에서는 현재 서비스를 포함하는 서비스가 발견 될 때까지이 플래그를 판별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="30bfb43aa1b7d9674beca69eee8ff711b5cc1ec6" translate="yes" xml:space="preserve">
          <source>The service is not ready for capture yet.</source>
          <target state="translated">서비스를 아직 캡처 할 준비가되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1f3d07c41db730eabacd627ed67b527a65917f77" translate="yes" xml:space="preserve">
          <source>The service is operating correctly.</source>
          <target state="translated">서비스가 올바르게 작동하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8cec4a2d0a5bd2b3a7cac1be2a4f7183085d5d0" translate="yes" xml:space="preserve">
          <source>The service is the preferred provider of a service.</source>
          <target state="translated">서비스는 선호하는 서비스 공급자입니다.</target>
        </trans-unit>
        <trans-unit id="ebdd5a3de5f5da296d2cb0550b413fafa6579c38" translate="yes" xml:space="preserve">
          <source>The service must wait for access to necessary resources.</source>
          <target state="translated">서비스는 필요한 리소스에 대한 액세스를 기다려야합니다.</target>
        </trans-unit>
        <trans-unit id="4ba5b05cb06443c3b64136f153f57ccfc9aad9f1" translate="yes" xml:space="preserve">
          <source>The service name and the name of the device offering the service. If the device name is empty the devices address will be used.</source>
          <target state="translated">서비스 이름 및 서비스를 제공하는 장치 이름 장치 이름이 비어 있으면 장치 주소가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1d58e997c9931b4b108ff4a165c0e62b3689cd14" translate="yes" xml:space="preserve">
          <source>The service or port was already registered</source>
          <target state="translated">서비스 또는 포트가 이미 등록되었습니다</target>
        </trans-unit>
        <trans-unit id="2381fd1417f6ddc1a661f2b928301b7f0c3dafc6" translate="yes" xml:space="preserve">
          <source>The service requested is invalid.</source>
          <target state="translated">요청한 서비스가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="235222d1fd5989167844ed444889c7252cfe42ce" translate="yes" xml:space="preserve">
          <source>The service requires authentication. Device must be paired, and the user is prompted on connection unless the device is Authorized-Paired.</source>
          <target state="translated">이 서비스에는 인증이 필요합니다. 장치가 페어링되어 있어야하며 장치에 인증 된 쌍이 아닌 경우 연결하라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="92d9f8f858352c90c5e33e899493a6e0247baa26" translate="yes" xml:space="preserve">
          <source>The service requires authorization by the user, unless the device is Authorized-Paired.</source>
          <target state="translated">장치가 Authorized-Paired가 아닌 한, 서비스는 사용자의 승인이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="71c91d4919fe9e874134eb7f01158ce33e74da3a" translate="yes" xml:space="preserve">
          <source>The service requires the communication link to be encrypted. This requires the device to be paired.</source>
          <target state="translated">이 서비스를 사용하려면 통신 링크를 암호화해야합니다. 이를 위해서는 장치를 페어링해야합니다.</target>
        </trans-unit>
        <trans-unit id="d676870c9d85bfea7dad07b7b7d696b9cc2b43f2" translate="yes" xml:space="preserve">
          <source>The service requires the communication link to be secure. Simple Pairing from Bluetooth 2.1 or greater is required. Legacy pairing is not permitted.</source>
          <target state="translated">서비스를 위해서는 통신 링크가 안전해야합니다. Bluetooth 2.1 이상의 단순 페어링이 필요합니다. 레거시 페어링은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="397ac55e1b59cd3ca21621fe5f4470e1a15f3ca9" translate="yes" xml:space="preserve">
          <source>The service supports generating directions in the following languages:</source>
          <target state="translated">이 서비스는 다음 언어로 길 찾기 생성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="11075fe1b77df5b4fbffc5e31c498087f1194f20" translate="yes" xml:space="preserve">
          <source>The service uses an unknown socket protocol.</source>
          <target state="translated">이 서비스는 알 수없는 소켓 프로토콜을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7e5c88bd5529f8ee8b7aa62ca01ae41eee595840" translate="yes" xml:space="preserve">
          <source>The service uses the L2CAP socket protocol. This protocol is not supported for direct socket connections on Android.</source>
          <target state="translated">서비스는 L2CAP 소켓 프로토콜을 사용합니다. 이 프로토콜은 Android의 직접 소켓 연결에는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42248bdec29599de498b30666bbd90d7e03c2856" translate="yes" xml:space="preserve">
          <source>The service uses the RFCOMM socket protocol.</source>
          <target state="translated">이 서비스는 RFCOMM 소켓 프로토콜을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a0553702ee669fbadd063a2cc72251d41d4b23ff" translate="yes" xml:space="preserve">
          <source>The services are called from state machines via the mechanism described in &lt;a href=&quot;https://www.w3.org/TR/scxml/#invoke&quot;&gt;SCXML Specification - 6.4 &amp;lt;invoke&amp;gt;&lt;/a&gt;.</source>
          <target state="translated">서비스는 &lt;a href=&quot;https://www.w3.org/TR/scxml/#invoke&quot;&gt;SCXML 사양-6.4 &amp;lt;invoke&amp;gt;에&lt;/a&gt; 설명 된 메커니즘을 통해 상태 머신에서 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="d85e883fc8455d13f03cb75265c4109b24cf30be" translate="yes" xml:space="preserve">
          <source>The services are called from state machines via the mechanism described in &lt;a href=&quot;https://www.w3.org/TR/scxml/#invoke&quot;&gt;SCXML Specification - 6.4 &amp;lt;invoke&amp;gt;&lt;/a&gt;. This class represents an actual instance of an invoked service.</source>
          <target state="translated">서비스는 &lt;a href=&quot;https://www.w3.org/TR/scxml/#invoke&quot;&gt;SCXML 사양-6.4 &amp;lt;invoke&amp;gt;에&lt;/a&gt; 설명 된 메커니즘을 통해 상태 머신에서 호출 됩니다. 이 클래스는 호출 된 서비스의 실제 인스턴스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ff206d2bd1c9fc051297cbe23d738ef47be25e94" translate="yes" xml:space="preserve">
          <source>The services are called from state machines via the mechanism described in SCXML Specification - 6.4 &amp;lt;invoke&amp;gt;.</source>
          <target state="translated">서비스는 SCXML 사양-6.4 &amp;lt;invoke&amp;gt;에 설명 된 메커니즘을 통해 상태 머신에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8a3ec4c965bd91e04af7d87dc79d2ed9e0599531" translate="yes" xml:space="preserve">
          <source>The services are called from state machines via the mechanism described in SCXML Specification - 6.4 &amp;lt;invoke&amp;gt;. This class represents an actual instance of an invoked service.</source>
          <target state="translated">서비스는 SCXML 사양-6.4 &amp;lt;invoke&amp;gt;에 설명 된 메커니즘을 통해 상태 머신에서 호출됩니다. 이 클래스는 호출 된 서비스의 실제 인스턴스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c66d6877144949c52d9c8e0f20a8d563f9ea5d35" translate="yes" xml:space="preserve">
          <source>The services invoked by the state machine.</source>
          <target state="translated">상태 머신이 호출 한 서비스.</target>
        </trans-unit>
        <trans-unit id="2dfe96a256f52af4da0ec857aeef591a2d0f98f5" translate="yes" xml:space="preserve">
          <source>The session ID is used for message routing between parent and child state machines. If a state machine is started by an &lt;code&gt;&amp;lt;invoke&amp;gt;&lt;/code&gt; element, any event it sends will have the &lt;code&gt;invokeid&lt;/code&gt; field set to the session ID. The state machine will use the origin of an event (which is set by the</source>
          <target state="translated">세션 ID는 상위 및 하위 상태 시스템 간의 메시지 라우팅에 사용됩니다. 상태 머신이 &lt;code&gt;&amp;lt;invoke&amp;gt;&lt;/code&gt; 요소에 의해 시작 되면, 송신하는 모든 이벤트는 &lt;code&gt;invokeid&lt;/code&gt; 필드가 세션 ID로 설정됩니다. 상태 머신은 이벤트의 출처를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="58e1de06689e9fbfc2a3543e4fa89884cb5c942e" translate="yes" xml:space="preserve">
          <source>The session ID of the current state machine.</source>
          <target state="translated">현재 상태 머신의 세션 ID.</target>
        </trans-unit>
        <trans-unit id="9af515bb1f2e0859f9e341e15a8b526cf7c823d5" translate="yes" xml:space="preserve">
          <source>The session can be controlled via &lt;a href=&quot;qnetworksession#open&quot;&gt;open&lt;/a&gt;() and &lt;a href=&quot;qnetworksession#close&quot;&gt;close&lt;/a&gt;().</source>
          <target state="translated">세션은 &lt;a href=&quot;qnetworksession#open&quot;&gt;open&lt;/a&gt; () 및 &lt;a href=&quot;qnetworksession#close&quot;&gt;close&lt;/a&gt; () 를 통해 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb182384a526a640260c12e29ebbe434e991f105" translate="yes" xml:space="preserve">
          <source>The session cannot roam to a new configuration.</source>
          <target state="translated">세션이 새로운 구성으로 로밍 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1c15eedf69d513f3cb0d597cfd99bec810878923" translate="yes" xml:space="preserve">
          <source>The session is based on a defined but not yet discovered &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration&lt;/a&gt; (see &lt;a href=&quot;qnetworkconfiguration#StateFlag-enum&quot;&gt;QNetworkConfiguration::StateFlag&lt;/a&gt;).</source>
          <target state="translated">세션은 정의되었지만 아직 검색되지 않은 &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration을&lt;/a&gt; 기반으로합니다 ( &lt;a href=&quot;qnetworkconfiguration#StateFlag-enum&quot;&gt;QNetworkConfiguration :: StateFlag&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1fda9a27e38bb03d76ee93fde0f6b28044bd47e1" translate="yes" xml:space="preserve">
          <source>The session is based on a defined but not yet discovered QNetworkConfiguration (see &lt;a href=&quot;qnetworkconfiguration#StateFlag-enum&quot;&gt;QNetworkConfiguration::StateFlag&lt;/a&gt;).</source>
          <target state="translated">세션은 정의되었지만 아직 검색되지 않은 QNetworkConfiguration을 기반으로합니다 ( &lt;a href=&quot;qnetworkconfiguration#StateFlag-enum&quot;&gt;QNetworkConfiguration :: StateFlag&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="98a07fc5507bb20033160c2e5478ff6786f52aec" translate="yes" xml:space="preserve">
          <source>The session is based on an unknown or unspecified bearer type. The value of the string returned describes the bearer type.</source>
          <target state="translated">세션은 알 수 없거나 지정되지 않은 베어러 유형을 기반으로합니다. 리턴 된 문자열 값은 베어러 유형을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b61b92bb4eb44e5091c763ee6ce38ed2c25c581f" translate="yes" xml:space="preserve">
          <source>The session is invalid due to an invalid configuration. This may happen due to a removed access point or a configuration that was invalid to begin with.</source>
          <target state="translated">유효하지 않은 구성으로 인해 세션이 유효하지 않습니다. 액세스 포인트가 제거되었거나 처음부터 유효하지 않은 구성으로 인해 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e740aed07971e9ecb66e98f4cdd194736aa162d2" translate="yes" xml:space="preserve">
          <source>The session key changes every time the session is saved. If the shutdown process is cancelled, another session key will be used when shutting down again.</source>
          <target state="translated">세션 키는 세션이 저장 될 때마다 변경됩니다. 종료 프로세스가 취소되면 다시 종료 할 때 다른 세션 키가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d352be6ff30154826262517805a36261052e0469" translate="yes" xml:space="preserve">
          <source>The session key changes with every call of commitData() or saveState().</source>
          <target state="translated">세션 키는 commitData () 또는 saveState ()를 호출 할 때마다 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="90e2a6d27340e11c754229525b200ebcc24bcd57" translate="yes" xml:space="preserve">
          <source>The session manager is used to save the session, e.g., when the machine is shut down, and to restore a session, e.g., when the machine is started up. We recommend that you use &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; to save an application's settings, for example, window positions, recently used files, etc. When the application is restarted by the session manager, you can restore the settings.</source>
          <target state="translated">세션 관리자는 예를 들어 머신이 종료 될 때 세션을 저장하고 머신이 시작될 때 세션을 복원하는 데 사용됩니다. &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 를 사용하여 응용 프로그램의 설정 (예 : 창 위치, 최근에 사용한 파일 등)을 저장하는 것이 좋습니다 . 세션 관리자가 응용 프로그램을 다시 시작하면 설정을 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2c1bcf48ca65b836cacb552b644bbdf1518b678" translate="yes" xml:space="preserve">
          <source>The session was aborted by the user or system.</source>
          <target state="translated">사용자 또는 시스템에 의해 세션이 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="db52fa029d66eb97abc6b64e4bec94ee6d990fcf" translate="yes" xml:space="preserve">
          <source>The session window size for connection-level flow control. Will be sent to a remote peer when needed as 'WINDOW_UPDATE' frames on the stream with an identifier 0.</source>
          <target state="translated">연결 수준 흐름 제어를위한 세션 창 크기입니다. 식별자가 0 인 스트림에서 'WINDOW_UPDATE'프레임으로 필요할 때 원격 피어로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="40d120fa61c5b0ad66ef32dbdc179fd4c116a1d5" translate="yes" xml:space="preserve">
          <source>The set of D-Bus interfaces available in a system</source>
          <target state="translated">시스템에서 사용 가능한 D-Bus 인터페이스 세트</target>
        </trans-unit>
        <trans-unit id="634de14092d373e4c78be0cbf9d2cf97e10d2978" translate="yes" xml:space="preserve">
          <source>The set of QML object-type attribute types is as follows:</source>
          <target state="translated">QML 오브젝트 유형 속성 유형 세트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a7967131f5c2ac738c22ee366d2068bdbd3edc8" translate="yes" xml:space="preserve">
          <source>The set of dependencies for a software build system</source>
          <target state="translated">소프트웨어 빌드 시스템의 종속성 세트</target>
        </trans-unit>
        <trans-unit id="1e91f2e716fec643b8a64bf7991dcef2779f813f" translate="yes" xml:space="preserve">
          <source>The set of signals available allow the developer to create custom behavior when the following events occur,</source>
          <target state="translated">사용 가능한 신호 세트를 통해 개발자는 다음과 같은 이벤트가 발생할 때 사용자 지정 동작을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bb8a5e1daa777e90dbfa0c9aeee4c0ea0198506" translate="yes" xml:space="preserve">
          <source>The setContentsMargins function sets the margins around the widget's contents.</source>
          <target state="translated">setContentsMargins 함수는 위젯 콘텐츠 주변의 여백을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="473c3a3c3935608a329d7012caea17da497b4d9a" translate="yes" xml:space="preserve">
          <source>The setFirstName() helper function is defined as follows:</source>
          <target state="translated">setFirstName () 헬퍼 함수는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="00b60e830ea2fb5c237bc1af6d63125751173c9f" translate="yes" xml:space="preserve">
          <source>The setGraphicsEffect function is for setting the widget's graphics effect.</source>
          <target state="translated">setGraphicsEffect 기능은 위젯의 그래픽 효과를 설정하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1c099f08dd6f0c5db28602f2d07f932bf4a4d6b2" translate="yes" xml:space="preserve">
          <source>The setLastName() function is similar. See the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-querymodel-example.html#&quot;&gt;Query Model&lt;/a&gt; example for the complete source code.</source>
          <target state="translated">setLastName () 함수는 비슷합니다. 전체 소스 코드 는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-querymodel-example.html#&quot;&gt;쿼리 모델&lt;/a&gt; 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc5116e149bb6fd15ea3ba3c2f14028a0279a6fd" translate="yes" xml:space="preserve">
          <source>The setLastName() function is similar. See the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsql-querymodel-example.html&quot;&gt;Query Model&lt;/a&gt; example for the complete source code.</source>
          <target state="translated">setLastName () 함수는 비슷합니다. 전체 소스 코드 는 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtsql-querymodel-example.html&quot;&gt;쿼리 모델&lt;/a&gt; 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="649360fd4ca75fd5e8beaf4c8a635ca549674f5b" translate="yes" xml:space="preserve">
          <source>The setPendingResultsLimit() provides throttling control. When the number of pending &lt;a href=&quot;qfuturewatcher#resultReadyAt&quot;&gt;resultReadyAt&lt;/a&gt;() or &lt;a href=&quot;qfuturewatcher#resultsReadyAt&quot;&gt;resultsReadyAt&lt;/a&gt;() signals exceeds the</source>
          <target state="translated">setPendingResultsLimit ()는 조절 제어를 제공합니다. 보류중인 &lt;a href=&quot;qfuturewatcher#resultReadyAt&quot;&gt;resultReadyAt&lt;/a&gt; () 또는 &lt;a href=&quot;qfuturewatcher#resultsReadyAt&quot;&gt;resultsReadyAt&lt;/a&gt; () 신호의 수가</target>
        </trans-unit>
        <trans-unit id="1f60012864cd360c7b76f7d6c366da74467e79f5" translate="yes" xml:space="preserve">
          <source>The setRelation() call specifies that column 2 in table &lt;code&gt;employee&lt;/code&gt; is a foreign key that maps with field &lt;code&gt;id&lt;/code&gt; of table &lt;code&gt;city&lt;/code&gt;, and that the view should present the &lt;code&gt;city&lt;/code&gt;'s &lt;code&gt;name&lt;/code&gt; field to the user.</source>
          <target state="translated">setRelation () 호출은 테이블 &lt;code&gt;employee&lt;/code&gt; 의 열 2 가 table &lt;code&gt;city&lt;/code&gt; 의 필드 &lt;code&gt;id&lt;/code&gt; 로 맵핑되는 외래 키 이고보기가 &lt;code&gt;city&lt;/code&gt; 의 &lt;code&gt;name&lt;/code&gt; 필드를 사용자에게 제공하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ea9c897618d8732d51050189daf49f4f9ec67633" translate="yes" xml:space="preserve">
          <source>The setSocketOptions method controls how the socket operates. For example the socket may restrict access to what user ids can connect to the socket.</source>
          <target state="translated">setSocketOptions 메소드는 소켓 작동 방식을 제어합니다. 예를 들어, 소켓은 소켓에 연결할 수있는 사용자 ID에 대한 액세스를 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b0b44bc9e739c58842e46fa4a695199ee9758aa" translate="yes" xml:space="preserve">
          <source>The setter setCurrentText() simply calls &lt;a href=&quot;qcombobox#setEditText&quot;&gt;setEditText&lt;/a&gt;() if the combo box is editable. Otherwise, if there is a matching text in the list, &lt;a href=&quot;qcombobox#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; is set to the corresponding index.</source>
          <target state="translated">콤보 상자를 편집 할 수있는 경우 setter setCurrentText ()는 단순히 &lt;a href=&quot;qcombobox#setEditText&quot;&gt;setEditText&lt;/a&gt; ()를 호출합니다 . 그렇지 않으면 목록에 일치하는 텍스트가 있으면 &lt;a href=&quot;qcombobox#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; 가 해당 인덱스로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3f1f6c4549b4872766bdc1b4321c5e2faa165a79" translate="yes" xml:space="preserve">
          <source>The settings for creating and printing the PDF document will be retrieved from the</source>
          <target state="translated">PDF 문서를 생성하고 인쇄하기위한 설정은</target>
        </trans-unit>
        <trans-unit id="e282fec7f856e6988f18d139be504731c2330ba1" translate="yes" xml:space="preserve">
          <source>The settings live in the Default group and the general format is:</source>
          <target state="translated">설정은 기본 그룹에 있으며 일반적인 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af11ecb0ddcefbd3004fe0412b4a61fd7ea23561" translate="yes" xml:space="preserve">
          <source>The settings of the internal &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; are also saved and restored, so that using &amp;lt;&amp;lt; &lt;a href=&quot;qt#hex&quot;&gt;Qt::hex&lt;/a&gt; in a &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; operator doesn't affect other &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; operators.</source>
          <target state="translated">내부 &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; 의 설정 도 저장 및 복원되므로 &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; 연산자 에서 &amp;lt;&amp;lt; &lt;a href=&quot;qt#hex&quot;&gt;Qt :: hex&lt;/a&gt; 를 사용해도 다른 &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; 연산자에 영향을주지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9b28e5f6c57a56a0a90d243bf7ab07681fe2341c" translate="yes" xml:space="preserve">
          <source>The settings of the internal &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; are also saved and restored, so that using &amp;lt;&amp;lt; hex in a &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; operator doesn't affect other &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; operators.</source>
          <target state="translated">내부 &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; 의 설정 도 저장 및 복원되므로 &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; 연산자 에서 &amp;lt;&amp;lt; 16 진수를 사용해도 다른 &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; 연산자에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d61af833a3dc7a320b43fc1d514a6a7310224f2a" translate="yes" xml:space="preserve">
          <source>The settings that &lt;a href=&quot;qsslconfiguration&quot;&gt;QSslConfiguration&lt;/a&gt; currently supports are:</source>
          <target state="translated">&lt;a href=&quot;qsslconfiguration&quot;&gt;QSslConfiguration이&lt;/a&gt; 현재 지원 하는 설정 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c06eaf08d9aebe9c14ae33c6bad538c7899943f2" translate="yes" xml:space="preserve">
          <source>The settings that QSslConfiguration currently supports are:</source>
          <target state="translated">QSslConfiguration이 현재 지원하는 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="83d15ce8ff4b07b98284106f5a8f61660c31113b" translate="yes" xml:space="preserve">
          <source>The setup of the style option for &lt;code&gt;CE_MenuTearOff&lt;/code&gt; and &lt;code&gt;CE_MenuScroller&lt;/code&gt; also uses &lt;a href=&quot;qstyleoptionmenuitem&quot;&gt;QStyleOptionMenuItem&lt;/a&gt;; they only set the &lt;code&gt;menuRect&lt;/code&gt; variable in addition to the common settings with &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;'s &lt;a href=&quot;qstyleoption#initFrom&quot;&gt;initFrom()&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;CE_MenuTearOff&lt;/code&gt; 및 &lt;code&gt;CE_MenuScroller&lt;/code&gt; 에 대한 스타일 옵션 설정은 QStyleOptionMenuItem 도 사용 &lt;a href=&quot;qstyleoptionmenuitem&quot;&gt;합니다&lt;/a&gt; . &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; 의 &lt;a href=&quot;qstyleoption#initFrom&quot;&gt;initFrom ()&lt;/a&gt; 을 사용한 공통 설정 외에도 &lt;code&gt;menuRect&lt;/code&gt; 변수 만 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="d8f5053cf990b39390f20f6e78b5c321797d0dee" translate="yes" xml:space="preserve">
          <source>The severity of the message is invalid; this is the severity of a default-constructed &lt;a href=&quot;qopengldebugmessage&quot;&gt;QOpenGLDebugMessage&lt;/a&gt; object.</source>
          <target state="translated">메시지의 심각도가 유효하지 않습니다. 이것은 기본적으로 구성된 &lt;a href=&quot;qopengldebugmessage&quot;&gt;QOpenGLDebugMessage&lt;/a&gt; 객체 의 심각도입니다 .</target>
        </trans-unit>
        <trans-unit id="54acb9dcc430bba085b98f7d35c1c4cd56da6666" translate="yes" xml:space="preserve">
          <source>The shader can be shared among different stages</source>
          <target state="translated">셰이더는 여러 단계에서 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f77012f78a0962ee102ff0951c4295191961a8a" translate="yes" xml:space="preserve">
          <source>The shader hasn't been compiled and linked yet</source>
          <target state="translated">셰이더가 아직 컴파일 및 링크되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="5ac637d0bee2bc57ee6d00a28c9cb1b02ffc1a4b" translate="yes" xml:space="preserve">
          <source>The shader is a compute shader</source>
          <target state="translated">셰이더는 컴퓨팅 셰이더입니다.</target>
        </trans-unit>
        <trans-unit id="f7517a0cb2bf00b89de4455fdd72725aa4536433" translate="yes" xml:space="preserve">
          <source>The shader is a fragment shader</source>
          <target state="translated">셰이더는 조각 셰이더입니다.</target>
        </trans-unit>
        <trans-unit id="748a257e1753a69c28990b2b23fc22195905f49c" translate="yes" xml:space="preserve">
          <source>The shader is a geometry shader</source>
          <target state="translated">셰이더는 지오메트리 셰이더입니다.</target>
        </trans-unit>
        <trans-unit id="fc86d7612eb0d268d67d874cf7a393ceb32929e0" translate="yes" xml:space="preserve">
          <source>The shader is a vertex shader</source>
          <target state="translated">셰이더는 정점 셰이더입니다.</target>
        </trans-unit>
        <trans-unit id="6e414caba0d29ea2d1bed4e442100e9aee20d7db" translate="yes" xml:space="preserve">
          <source>The shader is default glossy. This is a combination of &lt;code&gt;ShaderInfo.Diffuse&lt;/code&gt; and &lt;code&gt;ShaderInfo.Specular&lt;/code&gt;.</source>
          <target state="translated">셰이더는 기본 광택입니다. 이것은 &lt;code&gt;ShaderInfo.Diffuse&lt;/code&gt; 및 &lt;code&gt;ShaderInfo.Specular&lt;/code&gt; 의 조합입니다 .</target>
        </trans-unit>
        <trans-unit id="12b44ae86e0a517198db9112f2423743dd570b9a" translate="yes" xml:space="preserve">
          <source>The shader program must be valid in the current &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;.</source>
          <target state="translated">셰이더 프로그램은 현재 &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; 에서 유효해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b67288c8d7161f4365bd4dc03a860f45a5b7f3d8" translate="yes" xml:space="preserve">
          <source>The shader program will be associated with the current &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;.</source>
          <target state="translated">셰이더 프로그램은 현재 &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; 와 연관됩니다 .</target>
        </trans-unit>
        <trans-unit id="f119c0831a80ba3f9565350d66f9f761837087c2" translate="yes" xml:space="preserve">
          <source>The shader sources in the &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt; module have not been ported to any format other than the OpenGL 2.0 compatible one, meaning that the QML types provided by that module are currently not functional with the D3D12 backend.</source>
          <target state="translated">&lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt 그래픽 효과&lt;/a&gt; 모듈 의 셰이더 소스 는 OpenGL 2.0 호환 형식 이외의 다른 형식으로 포팅되지 않았습니다. 이는 해당 모듈에서 제공하는 QML 유형이 현재 D3D12 백엔드에서 작동하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bf70ab7d7872546236f414f9f2b772f829650020" translate="yes" xml:space="preserve">
          <source>The shader uses alpha cutout.</source>
          <target state="translated">셰이더는 알파 컷 아웃을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6460e82a010744d6da42d928b2c36afca9033afd" translate="yes" xml:space="preserve">
          <source>The shader uses diffuse lighting.</source>
          <target state="translated">셰이더는 확산 조명을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4e248815f9b890f8172817c736af6b018e930f60" translate="yes" xml:space="preserve">
          <source>The shader uses displacement mapping.</source>
          <target state="translated">셰이더는 변위 매핑을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1841be158939ed9e21e184613fcdab7a4edf08e1" translate="yes" xml:space="preserve">
          <source>The shader uses refraction.</source>
          <target state="translated">셰이더는 굴절을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bd28a93334ccd83c8d46c546d548817d41bdf50a" translate="yes" xml:space="preserve">
          <source>The shader uses specular lighting.</source>
          <target state="translated">셰이더는 반사광을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bb0717f1d1cb18ffc6ee34ab5b6d1c2c07ecac6e" translate="yes" xml:space="preserve">
          <source>The shader uses transmissiveness.</source>
          <target state="translated">셰이더는 투과성을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="32c417659de8237a6772fae53050cb3ff00d0ccb" translate="yes" xml:space="preserve">
          <source>The shader uses transparency.</source>
          <target state="translated">셰이더는 투명도를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="48aaebe5e0aa7a31a62e8d609c7f0dd924998254" translate="yes" xml:space="preserve">
          <source>The shader was successfully compiled</source>
          <target state="translated">셰이더가 성공적으로 컴파일되었습니다</target>
        </trans-unit>
        <trans-unit id="5869743776c1434547feb86b48727b4f7202d168" translate="yes" xml:space="preserve">
          <source>The shader will be associated with the current &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;.</source>
          <target state="translated">셰이더는 현재 &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; 와 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce53efaa770dda26cdb149efabe33b06a7110b19" translate="yes" xml:space="preserve">
          <source>The shadow color of the current color group.</source>
          <target state="translated">현재 색상 그룹의 그림자 색상입니다.</target>
        </trans-unit>
        <trans-unit id="c9725510ce32cd3ccc4e2a7f9defde582350c0ec" translate="yes" xml:space="preserve">
          <source>The shadow color.</source>
          <target state="translated">그림자 색.</target>
        </trans-unit>
        <trans-unit id="911ccf28c5f1f5e4ec61664bb36f4048ab051d44" translate="yes" xml:space="preserve">
          <source>The shadow radius.</source>
          <target state="translated">그림자 반경.</target>
        </trans-unit>
        <trans-unit id="f34fc5792232b6e4ffa8dfaaffd02a8c71d61dcc" translate="yes" xml:space="preserve">
          <source>The shadow spread.</source>
          <target state="translated">그림자가 퍼졌습니다.</target>
        </trans-unit>
        <trans-unit id="2f36f7d0407d0683cff54bba7e1c0187ae63cc3e" translate="yes" xml:space="preserve">
          <source>The shape is determine by calling &lt;a href=&quot;qpixmap#createHeuristicMask&quot;&gt;QPixmap::createHeuristicMask&lt;/a&gt;(). The performance and memory consumption is similar to MaskShape.</source>
          <target state="translated">모양은 &lt;a href=&quot;qpixmap#createHeuristicMask&quot;&gt;QPixmap :: createHeuristicMask&lt;/a&gt; ()를 호출하여 결정됩니다 . 성능 및 메모리 소비는 MaskShape와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="9cdabc6eab65a494ea63874b553ecadd8139707a" translate="yes" xml:space="preserve">
          <source>The shape is determined by calling &lt;a href=&quot;qpixmap#mask&quot;&gt;QPixmap::mask&lt;/a&gt;(). This shape includes only the opaque pixels of the pixmap. Because the shape is more complex, however, it can be slower than the other modes, and uses more memory.</source>
          <target state="translated">모양은 &lt;a href=&quot;qpixmap#mask&quot;&gt;QPixmap :: mask&lt;/a&gt; ()를 호출하여 결정됩니다 . 이 모양에는 픽스맵의 불투명 픽셀 만 포함됩니다. 그러나 모양이 더 복잡하기 때문에 다른 모드보다 속도가 느릴 수 있으며 더 많은 메모리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="43ba951567e21689a63f5b77c6162433f7610f3e" translate="yes" xml:space="preserve">
          <source>The shape is determined by tracing the outline of the pixmap. This is the fastest shape mode, but it does not take into account any transparent areas on the pixmap.</source>
          <target state="translated">모양은 픽스맵의 윤곽을 따라 결정됩니다. 가장 빠른 모양 모드이지만 픽스맵의 투명 영역을 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44b258c27841756c5cb48acc404fd462b934803c" translate="yes" xml:space="preserve">
          <source>The shape of the legend marker. Defaults to &lt;a href=&quot;qlegend#MarkerShape-enum&quot;&gt;QLegend::MarkerShapeDefault&lt;/a&gt;, which indicates the shape is determined by &lt;a href=&quot;qlegend#markerShape-prop&quot;&gt;QLegend::markerShape&lt;/a&gt; property.</source>
          <target state="translated">범례 마커의 모양입니다. &lt;a href=&quot;qlegend#MarkerShape-enum&quot;&gt;QLegend :: MarkerShapeDefault의&lt;/a&gt; 기본값 은 셰이프가 &lt;a href=&quot;qlegend#markerShape-prop&quot;&gt;QLegend :: markerShape&lt;/a&gt; 속성에 의해 결정됨 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1118267d7a94f85d3a914e33ce79c946931e5bc1" translate="yes" xml:space="preserve">
          <source>The shape of the mouse cursor on a &lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit&lt;/a&gt; is &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt::IBeamCursor&lt;/a&gt; by default. It can be changed through the &lt;a href=&quot;qabstractscrollarea#viewport&quot;&gt;viewport&lt;/a&gt;()'s cursor property.</source>
          <target state="translated">A의 마우스 커서의 모양 &lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit는&lt;/a&gt; 것입니다 &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt는 :: IBeamCursor&lt;/a&gt; 기본적으로. &lt;a href=&quot;qabstractscrollarea#viewport&quot;&gt;뷰포트&lt;/a&gt; ()의 커서 속성을 통해 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="724db3a73bc22860417c52e291b280fb2259b1e6" translate="yes" xml:space="preserve">
          <source>The shape of the mouse cursor on a &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; is &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt::IBeamCursor&lt;/a&gt; by default. It can be changed through the &lt;a href=&quot;qabstractscrollarea#viewport&quot;&gt;viewport&lt;/a&gt;()'s cursor property.</source>
          <target state="translated">A의 마우스 커서의 모양 &lt;a href=&quot;qtextedit&quot;&gt;은 QTextEdit는&lt;/a&gt; 것입니다 &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt는 :: IBeamCursor&lt;/a&gt; 기본적으로. &lt;a href=&quot;qabstractscrollarea#viewport&quot;&gt;뷰포트&lt;/a&gt; ()의 커서 속성을 통해 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ace7eb8c8d190407e4f03dee97aa2d92f068d86" translate="yes" xml:space="preserve">
          <source>The shape of the mouse cursor on a QPlainTextEdit is &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt::IBeamCursor&lt;/a&gt; by default. It can be changed through the &lt;a href=&quot;qabstractscrollarea#viewport&quot;&gt;viewport&lt;/a&gt;()'s cursor property.</source>
          <target state="translated">QPlainTextEdit의 마우스 커서 모양은 기본적으로 &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt :: IBeamCursor&lt;/a&gt; 입니다. &lt;a href=&quot;qabstractscrollarea#viewport&quot;&gt;뷰포트&lt;/a&gt; ()의 커서 속성을 통해 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70ef9fe36d66c77c4d3cc21f0468fbd4301a1b19" translate="yes" xml:space="preserve">
          <source>The shape of the mouse cursor on a QTextEdit is &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt::IBeamCursor&lt;/a&gt; by default. It can be changed through the &lt;a href=&quot;qabstractscrollarea#viewport&quot;&gt;viewport&lt;/a&gt;()'s cursor property.</source>
          <target state="translated">QTextEdit의 마우스 커서 모양은 기본적으로 &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt :: IBeamCursor&lt;/a&gt; 입니다. &lt;a href=&quot;qabstractscrollarea#viewport&quot;&gt;뷰포트&lt;/a&gt; ()의 커서 속성을 통해 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b5ee91e8ca39be340a1e72e75f41b9ae2c6331a" translate="yes" xml:space="preserve">
          <source>The shape of the tabs on the tab bar.</source>
          <target state="translated">탭 막대의 탭 모양.</target>
        </trans-unit>
        <trans-unit id="8bde36425e4f5b528e7ccd6fd0f2c0f65f1149e5" translate="yes" xml:space="preserve">
          <source>The shape used when rendering marker items:</source>
          <target state="translated">마커 항목을 렌더링 할 때 사용되는 모양 :</target>
        </trans-unit>
        <trans-unit id="a53dbebb56890475a9c634c28d8bb36c1eeb16ac" translate="yes" xml:space="preserve">
          <source>The shared memory segment is read-only. Writing to the shared memory segment is not allowed. An attempt to write to a shared memory segment created with ReadOnly causes the program to abort.</source>
          <target state="translated">공유 메모리 세그먼트는 읽기 전용입니다. 공유 메모리 세그먼트에 쓰는 것은 허용되지 않습니다. ReadOnly로 작성된 공유 메모리 세그먼트에 쓰려고하면 프로그램이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="4caadab66e0868af477a07d84bb3871a3bb909f5" translate="yes" xml:space="preserve">
          <source>The shininess of a surface is controlled by a float property.</source>
          <target state="translated">표면의 광택은 플로트 속성에 의해 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="ffdcf8101dd6362d468ac7f01633197ab758d064" translate="yes" xml:space="preserve">
          <source>The short answer is your elements are</source>
          <target state="translated">짧은 대답은 당신의 요소입니다</target>
        </trans-unit>
        <trans-unit id="87f7c04253feb4982b1e65f844501e949ecb3403" translate="yes" xml:space="preserve">
          <source>The short form of the time zone name, usually an abbreviation, e.g. &quot;CET&quot;</source>
          <target state="translated">시간대 이름의 짧은 형식, 일반적으로 약어 (예 : &quot;CET&quot;)</target>
        </trans-unit>
        <trans-unit id="30023d450e45dad95a70cd7f9d9e3624d272e00b" translate="yes" xml:space="preserve">
          <source>The short version of day and month names; for example, returning &quot;Jan&quot; as a month name.</source>
          <target state="translated">일 및 월 이름의 짧은 버전입니다. 예를 들어 월 이름으로 &quot;Jan&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="16ffc826aaaf8f119bf2981e574d229b0d0be593" translate="yes" xml:space="preserve">
          <source>The short version of the day name; for example, &quot;Mon&quot; (&lt;a href=&quot;qlocale#FormatType-enum&quot;&gt;QLocale::ShortFormat&lt;/a&gt;)</source>
          <target state="translated">요일 이름의 짧은 버전. 예를 들어 &quot;Mon&quot;( &lt;a href=&quot;qlocale#FormatType-enum&quot;&gt;QLocale :: ShortFormat&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="bdaf65b854f5795e65184cc933d9cc7883028c31" translate="yes" xml:space="preserve">
          <source>The short version of the string; for example, returning &quot;Jan&quot; as a month name.</source>
          <target state="translated">문자열의 짧은 버전. 예를 들어 월 이름으로 &quot;Jan&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8181d3894d5322aed5c2540d65ce29b8fc69543a" translate="yes" xml:space="preserve">
          <source>The shortcut (.lnk) files are treated as regular files. Opening those will open the &lt;code&gt;.lnk&lt;/code&gt; file itself. In order to open the file a shortcut references to, it must uses &lt;a href=&quot;qfileinfo#symLinkTarget&quot;&gt;symLinkTarget&lt;/a&gt;() on a shortcut.</source>
          <target state="translated">바로 가기 (.lnk) 파일은 일반 파일로 처리됩니다. 이 파일 을 열면 &lt;code&gt;.lnk&lt;/code&gt; 파일 자체 가 열립니다 . 바로 가기가 참조하는 파일을 열려면 바로 가기에서 &lt;a href=&quot;qfileinfo#symLinkTarget&quot;&gt;symLinkTarget&lt;/a&gt; ()을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="06df5613b203543f88827f70fc45f5d243cc54ba" translate="yes" xml:space="preserve">
          <source>The shortcut can be changed by the user or via setter function.</source>
          <target state="translated">바로 가기는 사용자 또는 세터 기능을 통해 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e99c44db9880c20fa54e88bd40ea9d8f66ac0ac" translate="yes" xml:space="preserve">
          <source>The shortcut is active when its parent widget has focus.</source>
          <target state="translated">바로 가기는 부모 위젯에 포커스가있을 때 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="47ee1f61ac23a711b13a126b69da35ea89ecfabc" translate="yes" xml:space="preserve">
          <source>The shortcut is active when its parent widget is a logical subwidget of the active top-level window.</source>
          <target state="translated">바로 가기는 상위 위젯이 활성 최상위 창의 논리적 하위 위젯 일 때 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="f546591807068dee658fcb71ba91a4ed1eb8ca7f" translate="yes" xml:space="preserve">
          <source>The shortcut is active when its parent widget, or any of its children has focus. Children which are top-level widgets, except pop-ups, are not affected by this shortcut context.</source>
          <target state="translated">바로 가기는 부모 위젯이나 그 자식 중 하나에 포커스가있을 때 활성화됩니다. 팝업을 제외한 최상위 위젯 인 하위 항목은이 바로 가기 컨텍스트의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d37eedb8293ab3fdf049dcab267093e9fffde5e" translate="yes" xml:space="preserve">
          <source>The shortcut is active when one of the applications windows are active.</source>
          <target state="translated">바로 가기는 응용 프로그램 창 중 하나가 활성화되면 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="e17491d57a1633f4987fc65b5cfc9a499a5f5580" translate="yes" xml:space="preserve">
          <source>The shortcut is specified as a Unicode code point, not as a Qt Key.</source>
          <target state="translated">바로 가기는 Qt 키가 아닌 유니 코드 코드 포인트로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="0ba78ec82b04ce3f5d89e5758a2b6a272579ceac" translate="yes" xml:space="preserve">
          <source>The shortcut key sequence can be set to one of the &lt;a href=&quot;qkeysequence#StandardKey-enum&quot;&gt;standard keyboard shortcuts&lt;/a&gt;, or it can be specified by a string containing a sequence of up to four key presses that are needed to &lt;a href=&quot;qml-qt-labs-platform-menuitem#triggered-signal&quot;&gt;trigger&lt;/a&gt; the shortcut.</source>
          <target state="translated">바로 가기 키 시퀀스는 &lt;a href=&quot;qkeysequence#StandardKey-enum&quot;&gt;표준 키보드 바로 가기&lt;/a&gt; 중 하나로 설정 하거나 바로 가기 를 &lt;a href=&quot;qml-qt-labs-platform-menuitem#triggered-signal&quot;&gt;트리거&lt;/a&gt; 하는 데 필요한 최대 4 개의 키 누름 시퀀스가 ​​포함 된 문자열로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39cd7e7182fa9712bace6996322f3560e0354031" translate="yes" xml:space="preserve">
          <source>The side of the Flipable currently visible. Possible values are &lt;code&gt;Flipable.Front&lt;/code&gt; and &lt;code&gt;Flipable.Back&lt;/code&gt;.</source>
          <target state="translated">Flipable의 측면이 현재 보입니다. 가능한 값은 &lt;code&gt;Flipable.Front&lt;/code&gt; 및 &lt;code&gt;Flipable.Back&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="209af747aef71b17788cb34c2705efedfacc9b6d" translate="yes" xml:space="preserve">
          <source>The signal &lt;a href=&quot;qtabwidget#currentChanged&quot;&gt;currentChanged&lt;/a&gt;() is emitted when the user selects a page.</source>
          <target state="translated">사용자가 페이지를 선택할 때 &lt;a href=&quot;qtabwidget#currentChanged&quot;&gt;currentChanged&lt;/a&gt; () 신호 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="47d8373b027c6e72e66e2b93fed1c58cc1d2f79e" translate="yes" xml:space="preserve">
          <source>The signal and slot used in a connection can be changed after it has been set up. When a connection is configured, it becomes visible in</source>
          <target state="translated">연결에 사용 된 신호 및 슬롯은 설정 후 변경할 수 있습니다. 연결이 구성되면</target>
        </trans-unit>
        <trans-unit id="524d961195c884a0ffd02067e733fe97497f8d20" translate="yes" xml:space="preserve">
          <source>The signal can be attached to any item, popup, or window. When attached to an item or a popup, the signal is only emitted if the item or popup is in a window.</source>
          <target state="translated">신호는 모든 항목, 팝업 또는 창에 연결될 수 있습니다. 항목 또는 팝업에 연결되면 항목 또는 팝업이 창에있는 경우에만 신호가 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="f5df15e060b329ae0e66b674a04dd45df9c57257" translate="yes" xml:space="preserve">
          <source>The signal can be used for example for implementing custom input handlers, as demonstrated by the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdatavisualization-draggableaxes-example.html#&quot;&gt;Axis Range Dragging With Labels Example&lt;/a&gt;.</source>
          <target state="translated">이 신호는 예를 들어 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdatavisualization-draggableaxes-example.html#&quot;&gt;레이블이&lt;/a&gt; 있는 축 범위 드래그 예제 에서 설명 된 것처럼 사용자 정의 입력 핸들러를 구현하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd656c015550a73e0ee411c49df0bbc5f42dc669" translate="yes" xml:space="preserve">
          <source>The signal can be used for example for implementing custom input handlers, as demonstrated by the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtdatavisualization-draggableaxes-example.html&quot;&gt;Axis Range Dragging With Labels Example&lt;/a&gt;.</source>
          <target state="translated">이 신호는 예를 들어 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtdatavisualization-draggableaxes-example.html&quot;&gt;레이블을 사용&lt;/a&gt; 하여 드래그 하는 축 범위 예제 에서 설명하는대로 사용자 지정 입력 처리기를 구현하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b7e4e0c1d2b944b19f37a669a86ead412957e7f" translate="yes" xml:space="preserve">
          <source>The signal can be used for example for implementing customized input handling, as demonstrated by the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdatavisualization-qmlaxisdrag-example.html#&quot;&gt;Qt Quick 2 Axis Dragging Example&lt;/a&gt;.</source>
          <target state="translated">이 신호는 예를 들어 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdatavisualization-qmlaxisdrag-example.html#&quot;&gt;Qt Quick 2 Axis Dragging Example&lt;/a&gt; 에서 설명하는 것처럼 맞춤형 입력 처리를 구현하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9bb2a499f83ba0afa1620cc00b6b54d3092d5239" translate="yes" xml:space="preserve">
          <source>The signal can be used for example for implementing customized input handling, as demonstrated by the &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtdatavisualization-qmlaxisdrag-example.html&quot;&gt;Qt Quick 2 Axis Dragging Example&lt;/a&gt;.</source>
          <target state="translated">신호는 예를 들어 &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtdatavisualization-qmlaxisdrag-example.html&quot;&gt;Qt Quick 2 Axis Dragging Example&lt;/a&gt; 에서 보여준 것처럼 사용자 정의 입력 처리를 구현하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d50ed7ac50271f2291b14d668ed14f9496aebd7" translate="yes" xml:space="preserve">
          <source>The signal carries a &lt;a href=&quot;qsslpresharedkeyauthenticator&quot;&gt;QSslPreSharedKeyAuthenticator&lt;/a&gt; object containing the identity hint the server sent to the client, and which must be filled with the corresponding client identity and the derived key:</source>
          <target state="translated">이 신호는 서버가 클라이언트에게 보낸 아이디 힌트를 포함하고 해당 클라이언트 아이디와 파생 된 키로 채워 져야 하는 &lt;a href=&quot;qsslpresharedkeyauthenticator&quot;&gt;QSslPreSharedKeyAuthenticator&lt;/a&gt; 객체를 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="daad4dee27007f36e2902695eac33a9d8546f9ea" translate="yes" xml:space="preserve">
          <source>The signal carries a QSslPreSharedKeyAuthenticator object containing the identity hint the server sent to the client, and which must be filled with the corresponding client identity and the derived key:</source>
          <target state="translated">신호는 서버가 클라이언트에 보낸 ID 힌트를 포함하는 QSslPreSharedKeyAuthenticator 개체를 전달하며, 해당 클라이언트 ID와 파생 키로 채워야합니다.</target>
        </trans-unit>
        <trans-unit id="4b893a084a57974b7ac34abf93fefcbd9039a261" translate="yes" xml:space="preserve">
          <source>The signal handlers should handle the incoming transaction. Once the transaction has been handled appropriately, it should be finalized. For instance, when a purchase has succeeded, it's appropriate to save information about the purchased product in persistent storage, so that this product can still be available the next time the application launches.</source>
          <target state="translated">신호 처리기는 들어오는 트랜잭션을 처리해야합니다. 거래가 적절하게 처리되면 완료해야합니다. 예를 들어, 구매가 성공하면 다음에 응용 프로그램을 시작할 때이 제품을 계속 사용할 수 있도록 구매 한 제품에 대한 정보를 영구 저장소에 저장하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ae975f63cf2ae5f69c3bda1f5fdf429262f0bbbd" translate="yes" xml:space="preserve">
          <source>The signal is emitted after both widget have been notified about the change through &lt;a href=&quot;qfocusevent&quot;&gt;QFocusEvent&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qfocusevent&quot;&gt;QFocusEvent를&lt;/a&gt; 통한 변경에 대해 두 위젯 모두에 통지 한 후에 신호가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="8644edacdb335001bd624e5d209ed42439b01d59" translate="yes" xml:space="preserve">
          <source>The signal is emitted as soon as the most important device information has been collected. However, as long as the &lt;a href=&quot;qbluetoothdevicediscoveryagent#finished&quot;&gt;finished&lt;/a&gt;() signal has not been emitted the information collection continues even for already discovered devices. This is particularly true for signal strength information (RSSI) and manufacturer data updates. If the use case requires continuous manufacturer data or RSSI updates it is advisable to retrieve the device information via &lt;a href=&quot;qbluetoothdevicediscoveryagent#discoveredDevices&quot;&gt;discoveredDevices&lt;/a&gt;() once the discovery has finished or listen to the &lt;a href=&quot;qbluetoothdevicediscoveryagent#deviceUpdated&quot;&gt;deviceUpdated&lt;/a&gt;() signal.</source>
          <target state="translated">가장 중요한 장치 정보가 수집되는 즉시 신호가 방출됩니다. 그러나 &lt;a href=&quot;qbluetoothdevicediscoveryagent#finished&quot;&gt;완료된&lt;/a&gt; () 신호가 방출되지 않는 한 이미 검색된 장치에 대해서도 정보 수집이 계속됩니다. 이것은 특히 신호 강도 정보 (RSSI) 및 제조업체 데이터 업데이트에 해당됩니다. 유스 케이스가 연속 제조 업체의 데이터를 필요로하거나 RSSI가 업데이트되면 그것을 통해 장치 정보를 검색하는 것이 좋습니다 &lt;a href=&quot;qbluetoothdevicediscoveryagent#discoveredDevices&quot;&gt;discoveredDevices을&lt;/a&gt; 발견 완료 또는 듣고되면 () &lt;a href=&quot;qbluetoothdevicediscoveryagent#deviceUpdated&quot;&gt;deviceUpdated&lt;/a&gt; () 신호.</target>
        </trans-unit>
        <trans-unit id="18afd8eb86d3b1bb4f83b3cb0041c82ff2bdec66" translate="yes" xml:space="preserve">
          <source>The signal is emitted before the document's layout manager is notified about the change. This hook allows you to implement syntax highlighting for the document.</source>
          <target state="translated">신호는 문서의 레이아웃 관리자에게 변경 사항에 대한 알림을 받기 전에 생성됩니다. 이 후크를 사용하면 문서의 구문 강조를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6874e355996a9c5d889d27bdccda9540d97cc2b9" translate="yes" xml:space="preserve">
          <source>The signal is emitted when the active streams list is changed.</source>
          <target state="translated">활성 스트림 목록이 변경되면 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c9a9cb27e653e72eb35d1e6d1991f2cd823bf6c4" translate="yes" xml:space="preserve">
          <source>The signal is emitted when the available streams list is changed.</source>
          <target state="translated">사용 가능한 스트림 목록이 변경되면 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a2c442f3578cf1c7a94febe17a99513b6f1a1904" translate="yes" xml:space="preserve">
          <source>The signal is emitted while a user is selecting a font. Ultimately, the chosen font may differ from the font currently selected.</source>
          <target state="translated">사용자가 글꼴을 선택하는 동안 신호가 발생합니다. 궁극적으로 선택한 글꼴은 현재 선택한 글꼴과 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa43372c097d1cb461f1cbead869dde5f9fad326" translate="yes" xml:space="preserve">
          <source>The signal is emitted with</source>
          <target state="translated">신호는</target>
        </trans-unit>
        <trans-unit id="7a07cf1960e0c63d7cfa93d25bbffb35ef0af5c5" translate="yes" xml:space="preserve">
          <source>The signal is not emitted when the to-be-written fields have not changed due to no change in value.</source>
          <target state="translated">값이 변경되지 않아 기록 될 필드가 변경되지 않은 경우 신호가 방출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b170cb776c51484e0ca01973559acac9e751ec8c" translate="yes" xml:space="preserve">
          <source>The signal is only emitted when a user has chosen the final font to be used. It is not emitted while the user is changing the current font in the font dialog.</source>
          <target state="translated">사용자가 사용할 최종 글꼴을 선택한 경우에만 신호가 방출됩니다. 사용자가 글꼴 대화 상자에서 현재 글꼴을 변경하는 동안에는 방출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f15546a80f17bd80ed47c28d46f26d0d889185b6" translate="yes" xml:space="preserve">
          <source>The signal is particularly useful if your application has to do some last-second cleanup. Note that no user interaction is possible in this state.</source>
          <target state="translated">이 신호는 응용 프로그램이 마지막으로 정리해야하는 경우에 특히 유용합니다. 이 상태에서는 사용자 상호 작용이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="4f8f47145d6f4e2b037b878f3850892880408f10" translate="yes" xml:space="preserve">
          <source>The signal must be a function declared as a signal in the header. The slot function can be any function or functor that can be connected to the signal. A function can be connected to a given signal if the signal has at least as many argument as the slot. A functor can be connected to a signal if they have exactly the same number of arguments. There must exist implicit conversion between the types of the corresponding arguments in the signal and the slot.</source>
          <target state="translated">신호는 헤더에서 신호로 선언 된 함수 여야합니다. 슬롯 기능은 신호에 연결할 수있는 기능 또는 기능 일 수 있습니다. 신호가 최소한 슬롯만큼 많은 인수를 갖는 경우 함수를 주어진 신호에 연결할 수 있습니다. Functor는 정확히 동일한 개수의 인수가있는 경우 신호에 연결할 수 있습니다. 신호의 해당 인수 유형과 슬롯간에 암시 적 변환이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="969c5fdee4c16403eb25ce6c9ffd5debb01e04d2" translate="yes" xml:space="preserve">
          <source>The signal must be a function declared as a signal in the header. The slot function can be any member function that can be connected to the signal. A slot can be connected to a given signal if the signal has at least as many arguments as the slot, and there is an implicit conversion between the types of the corresponding arguments in the signal and the slot.</source>
          <target state="translated">신호는 헤더에서 신호로 선언 된 함수 여야합니다. 슬롯 기능은 신호에 연결할 수있는 모든 구성원 기능 일 수 있습니다. 신호가 최소한 슬롯만큼 많은 인수를 가지고 있고 신호의 해당 인수 유형과 슬롯간에 암시 적 변환이있는 경우 슬롯을 지정된 신호에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ba8582545ce204f106d6d09c44873a4cfb77613" translate="yes" xml:space="preserve">
          <source>The signal properties have a &lt;a href=&quot;qml-qtquick-keyevent&quot;&gt;KeyEvent&lt;/a&gt; parameter, named</source>
          <target state="translated">신호 속성에는 &lt;a href=&quot;qml-qtquick-keyevent&quot;&gt;KeyEvent&lt;/a&gt; 매개 변수가 있으며</target>
        </trans-unit>
        <trans-unit id="ac0f39444f9b7ca8721afe54e8f72758ef373298" translate="yes" xml:space="preserve">
          <source>The signal specified respresents the default signal of this class. Ie. the default signal of a push button would be &quot;clicked&quot;.</source>
          <target state="translated">지정된 신호는이 클래스의 기본 신호를 나타냅니다. 즉. 누름 버튼의 기본 신호는 &quot;클릭&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="608182cb8c500e7120c984e333a67c68920eaaeb" translate="yes" xml:space="preserve">
          <source>The signal which is associated with this signal transition.</source>
          <target state="translated">이 신호 전환과 관련된 신호입니다.</target>
        </trans-unit>
        <trans-unit id="d4cc5d3b532fc57d04b4b1432fc6b1800fa59654" translate="yes" xml:space="preserve">
          <source>The signal will be disconnected from the slot when the dialog is closed.</source>
          <target state="translated">대화 상자가 닫히면 신호가 슬롯에서 분리됩니다.</target>
        </trans-unit>
        <trans-unit id="545ccef3a7bf7200f085725901642ab3b795d82c" translate="yes" xml:space="preserve">
          <source>The signals &lt;a href=&quot;qml-qt3d-render-objectpicker#pressed-signal&quot;&gt;pressed()&lt;/a&gt;, &lt;a href=&quot;qml-qt3d-render-objectpicker#released-signal&quot;&gt;released()&lt;/a&gt;, &lt;a href=&quot;qml-qt3d-render-objectpicker#clicked-signal&quot;&gt;clicked()&lt;/a&gt;, &lt;a href=&quot;qml-qt3d-render-objectpicker#moved-signal&quot;&gt;moved()&lt;/a&gt;, &lt;a href=&quot;qml-qt3d-render-objectpicker#entered-signal&quot;&gt;entered()&lt;/a&gt;, and &lt;a href=&quot;qml-qt3d-render-objectpicker#exited-signal&quot;&gt;exited()&lt;/a&gt; are emitted when the bounding volume defined by the pickAttribute property intersects with a ray.</source>
          <target state="translated">신호는 &lt;a href=&quot;qml-qt3d-render-objectpicker#pressed-signal&quot;&gt;가압 ()&lt;/a&gt; , &lt;a href=&quot;qml-qt3d-render-objectpicker#released-signal&quot;&gt;릴리스 ()&lt;/a&gt; , &lt;a href=&quot;qml-qt3d-render-objectpicker#clicked-signal&quot;&gt;클릭 ()&lt;/a&gt; , &lt;a href=&quot;qml-qt3d-render-objectpicker#moved-signal&quot;&gt;이동 ()&lt;/a&gt; , &lt;a href=&quot;qml-qt3d-render-objectpicker#entered-signal&quot;&gt;입력 ()&lt;/a&gt; , 및 &lt;a href=&quot;qml-qt3d-render-objectpicker#exited-signal&quot;&gt;종료 ()&lt;/a&gt; 바운딩 볼륨 광선과 pickAttribute 속성 교차에 의해 정의 될 때 방출된다.</target>
        </trans-unit>
        <trans-unit id="3e2168702b0a57b5caafb589a4bfafe08ef060ae" translate="yes" xml:space="preserve">
          <source>The signals &lt;a href=&quot;qt3drender-qobjectpicker#pressed&quot;&gt;pressed&lt;/a&gt;(), &lt;a href=&quot;qt3drender-qobjectpicker#released&quot;&gt;released&lt;/a&gt;(), &lt;a href=&quot;qt3drender-qobjectpicker#clicked&quot;&gt;clicked&lt;/a&gt;(), &lt;a href=&quot;qt3drender-qobjectpicker#moved&quot;&gt;moved&lt;/a&gt;(), &lt;a href=&quot;qt3drender-qobjectpicker#entered&quot;&gt;entered&lt;/a&gt;(), and &lt;a href=&quot;qt3drender-qobjectpicker#exited&quot;&gt;exited&lt;/a&gt;() are emitted when the bounding volume defined by the pickAttribute property intersects with a ray.</source>
          <target state="translated">신호는 &lt;a href=&quot;qt3drender-qobjectpicker#pressed&quot;&gt;가압&lt;/a&gt; (), &lt;a href=&quot;qt3drender-qobjectpicker#released&quot;&gt;릴리스&lt;/a&gt; (), &lt;a href=&quot;qt3drender-qobjectpicker#clicked&quot;&gt;클릭&lt;/a&gt; (), &lt;a href=&quot;qt3drender-qobjectpicker#moved&quot;&gt;이동&lt;/a&gt; (), &lt;a href=&quot;qt3drender-qobjectpicker#entered&quot;&gt;입력&lt;/a&gt; () 및 &lt;a href=&quot;qt3drender-qobjectpicker#exited&quot;&gt;종료&lt;/a&gt; ()은 경계 체적을 광선과 pickAttribute 속성 교차에 의해 정의 될 때 방출된다.</target>
        </trans-unit>
        <trans-unit id="17d8e2171d57d1559a7867266737c25c1497b292" translate="yes" xml:space="preserve">
          <source>The signals and slots connections defined for compile time or run time forms can either be set up manually or automatically, using &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject&lt;/a&gt;'s ability to make connections between signals and suitably-named slots.</source>
          <target state="translated">컴파일 타임 또는 런타임 형식으로 정의 된 신호 및 슬롯 연결은 &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject&lt;/a&gt; 의 신호와 적절한 이름의 슬롯을 연결하는 기능을 사용하여 수동 또는 자동으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e4a44e585caad99aff83ef0803ee2bdb0174179" translate="yes" xml:space="preserve">
          <source>The signals and slots mechanism is type safe: The signature of a signal must match the signature of the receiving slot. (In fact a slot may have a shorter signature than the signal it receives because it can ignore extra arguments.) Since the signatures are compatible, the compiler can help us detect type mismatches when using the function pointer-based syntax. The string-based SIGNAL and SLOT syntax will detect type mismatches at runtime. Signals and slots are loosely coupled: A class which emits a signal neither knows nor cares which slots receive the signal. Qt's signals and slots mechanism ensures that if you connect a signal to a slot, the slot will be called with the signal's parameters at the right time. Signals and slots can take any number of arguments of any type. They are completely type safe.</source>
          <target state="translated">신호 및 슬롯 메커니즘은 유형 안전합니다. 신호의 서명은 수신 슬롯의 서명과 일치해야합니다. (실제로 슬롯은 추가 인수를 무시할 수 있기 때문에 수신하는 신호보다 서명이 짧을 수 있습니다.) 서명이 호환되므로 컴파일러는 함수 포인터 기반 구문을 사용할 때 유형 불일치를 감지 할 수 있습니다. 문자열 기반 SIGNAL 및 SLOT 구문은 런타임시 유형 불일치를 감지합니다. 신호와 슬롯이 느슨하게 결합되어 있습니다. 신호를 방출하는 클래스는 어느 슬롯이 신호를 수신하는지 알거나 신경 쓰지 않습니다. Qt의 신호 및 슬롯 메커니즘을 사용하면 신호를 슬롯에 연결하면 신호 매개 변수가 적시에 슬롯에 호출됩니다. 신호와 슬롯은 모든 유형의 여러 인수를 취할 수 있습니다. 그들은 완전히 타입 안전합니다.</target>
        </trans-unit>
        <trans-unit id="562c9e64ca7080edc2b80f020b4f5c6643b47441" translate="yes" xml:space="preserve">
          <source>The signals emitted by the functions called in implementations of the resizing API give attached components the chance to take action before any data becomes unavailable. The encapsulation of insert and remove operations with begin and end functions also enable the model to manage &lt;a href=&quot;qpersistentmodelindex&quot;&gt;persistent model indexes&lt;/a&gt; correctly.</source>
          <target state="translated">크기 조정 API 구현에서 호출 된 함수에 의해 생성 된 신호는 연결된 구성 요소에 데이터를 사용할 수 없게되기 전에 조치를 취할 수있는 기회를 제공합니다. 시작 및 종료 기능으로 삽입 및 제거 조작을 캡슐화하면 모델이 &lt;a href=&quot;qpersistentmodelindex&quot;&gt;지속적 모델 색인을&lt;/a&gt; 올바르게 관리 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86436de89c2a80423b16556679f2901745d882f8" translate="yes" xml:space="preserve">
          <source>The signature for the first function is &lt;b&gt;&quot;(I)Ljava/lang/String;&quot;&lt;/b&gt;</source>
          <target state="translated">첫 번째 함수의 서명은 &lt;b&gt;&quot;(I) Ljava / lang / String;&quot;입니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fc71ca11e09b0f0063c89ab8633bf03e59950cb7" translate="yes" xml:space="preserve">
          <source>The signatures of signals and slots may contain arguments, and the arguments can have default values. Consider &lt;a href=&quot;qobject#destroyed&quot;&gt;QObject::destroyed&lt;/a&gt;():</source>
          <target state="translated">신호 및 슬롯의 서명은 인수를 포함 할 수 있으며 인수는 기본값을 가질 수 있습니다. &lt;a href=&quot;qobject#destroyed&quot;&gt;QObject :: destroyed&lt;/a&gt; ()를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b5e4e08fec4cb19c3558e7b3ea4f9e9e85e1538" translate="yes" xml:space="preserve">
          <source>The similar mode to FlashSlowSyncFrontCurtain but flash is fired at the end of exposure.</source>
          <target state="translated">FlashSlowSyncFrontCurtain과 유사한 모드이지만 노출이 끝나면 플래시가 터집니다.</target>
        </trans-unit>
        <trans-unit id="c8632f5e659e9c544f7a10b3240a5430e1f2f12c" translate="yes" xml:space="preserve">
          <source>The simple text item can have both a fill and an outline; &lt;a href=&quot;qabstractgraphicsshapeitem#setBrush&quot;&gt;setBrush&lt;/a&gt;() will set the text fill (i.e., text color), and &lt;a href=&quot;qabstractgraphicsshapeitem#setPen&quot;&gt;setPen&lt;/a&gt;() sets the pen that will be used to draw the text outline. (The latter can be slow, especially for complex pens, and items with long text content.) If all you want is to draw a simple line of text, you should call &lt;a href=&quot;qabstractgraphicsshapeitem#setBrush&quot;&gt;setBrush&lt;/a&gt;() only, and leave the pen unset; &lt;a href=&quot;qgraphicssimpletextitem&quot;&gt;QGraphicsSimpleTextItem&lt;/a&gt;'s pen is by default &lt;a href=&quot;qt#PenStyle-enum&quot;&gt;Qt::NoPen&lt;/a&gt;.</source>
          <target state="translated">간단한 텍스트 항목은 채우기와 윤곽선을 모두 가질 수 있습니다. &lt;a href=&quot;qabstractgraphicsshapeitem#setBrush&quot;&gt;setBrush&lt;/a&gt; ()는 텍스트 채우기 (예 : 텍스트 색상 )를 설정 하고 &lt;a href=&quot;qabstractgraphicsshapeitem#setPen&quot;&gt;setPen&lt;/a&gt; ()은 텍스트 윤곽선을 그리는 데 사용할 펜을 설정합니다. 후자는 특히 복잡한 펜 및 텍스트 내용이 긴 항목의 경우 속도가 느릴 수 있습니다. 간단한 텍스트 줄을 그리려면 &lt;a href=&quot;qabstractgraphicsshapeitem#setBrush&quot;&gt;setBrush&lt;/a&gt; () 만 호출 하고 펜을 설정하지 않은 상태로 두어야합니다. &lt;a href=&quot;qgraphicssimpletextitem&quot;&gt;QGraphicsSimpleTextItem&lt;/a&gt; 의 펜은 기본적으로 &lt;a href=&quot;qt#PenStyle-enum&quot;&gt;Qt :: NoPen&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="39d85ca72a66ff24c08d00e01620d8fd06e0526a" translate="yes" xml:space="preserve">
          <source>The simple text item can have both a fill and an outline; &lt;a href=&quot;qabstractgraphicsshapeitem#setBrush&quot;&gt;setBrush&lt;/a&gt;() will set the text fill (i.e., text color), and &lt;a href=&quot;qabstractgraphicsshapeitem#setPen&quot;&gt;setPen&lt;/a&gt;() sets the pen that will be used to draw the text outline. (The latter can be slow, especially for complex pens, and items with long text content.) If all you want is to draw a simple line of text, you should call &lt;a href=&quot;qabstractgraphicsshapeitem#setBrush&quot;&gt;setBrush&lt;/a&gt;() only, and leave the pen unset; QGraphicsSimpleTextItem's pen is by default &lt;a href=&quot;qt#PenStyle-enum&quot;&gt;Qt::NoPen&lt;/a&gt;.</source>
          <target state="translated">단순 텍스트 항목에는 채우기와 윤곽선이 모두있을 수 있습니다. &lt;a href=&quot;qabstractgraphicsshapeitem#setBrush&quot;&gt;setBrush&lt;/a&gt; ()는 텍스트 채우기 (즉, 텍스트 색상 )를 설정 하고 &lt;a href=&quot;qabstractgraphicsshapeitem#setPen&quot;&gt;setPen&lt;/a&gt; ()은 텍스트 윤곽선을 그리는 데 사용할 펜을 설정합니다. (후자는 특히 복잡한 펜과 긴 텍스트 내용이있는 항목의 경우 속도가 느릴 수 있습니다.) 단순한 텍스트 줄을 그리는 것 뿐 &lt;a href=&quot;qabstractgraphicsshapeitem#setBrush&quot;&gt;이라면 setBrush&lt;/a&gt; () 만 호출 하고 펜을 설정하지 않은 상태로 두어야합니다. QGraphicsSimpleTextItem의 펜은 기본적으로 &lt;a href=&quot;qt#PenStyle-enum&quot;&gt;Qt :: NoPen&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a32c06e73e0a74a3e39b441fad35a69411c07b81" translate="yes" xml:space="preserve">
          <source>The simplest (and arguably the best) fix for this problem is to use &lt;a href=&quot;quick3d-asset-conditioning-anti-aliasing#mipmaps&quot;&gt;mipmapping in the image texture&lt;/a&gt; itself. Alternative fixes include using either &lt;a href=&quot;quick3d-asset-conditioning-anti-aliasing#temporal-aa&quot;&gt;Temporal AA&lt;/a&gt; or &lt;a href=&quot;quick3d-asset-conditioning-anti-aliasing#progressive-aa&quot;&gt;Progressive AA&lt;/a&gt; to gather more information from the texture.</source>
          <target state="translated">이 문제에 대한 가장 간단한 (그리고 틀림없이 가장 좋은) 수정 &lt;a href=&quot;quick3d-asset-conditioning-anti-aliasing#mipmaps&quot;&gt;은 이미지 텍스처&lt;/a&gt; 자체 에서 밉 매핑 을 사용 하는 것입니다. 대체 수정 사항에는 &lt;a href=&quot;quick3d-asset-conditioning-anti-aliasing#temporal-aa&quot;&gt;Temporal AA&lt;/a&gt; 또는 &lt;a href=&quot;quick3d-asset-conditioning-anti-aliasing#progressive-aa&quot;&gt;Progressive AA&lt;/a&gt; 를 사용하여 텍스처에서 더 많은 정보를 수집하는 것이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b71b4f8cae1dfa059db0615c7c038dfb4d44b99f" translate="yes" xml:space="preserve">
          <source>The simplest and most common way to set a widget's tool tip is by calling its &lt;a href=&quot;qwidget#toolTip-prop&quot;&gt;QWidget::setToolTip&lt;/a&gt;() function.</source>
          <target state="translated">위젯의 툴팁을 설정하는 가장 단순하고 가장 일반적인 방법은 &lt;a href=&quot;qwidget#toolTip-prop&quot;&gt;QWidget :: setToolTip&lt;/a&gt; () 함수 를 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a6ec11a0c882a8f7f4766a044cf6d4c0e3c2c9e8" translate="yes" xml:space="preserve">
          <source>The simplest plugin will have just once sensor backend although there is no reason that multiple sensor backends cannot be in a plugin.</source>
          <target state="translated">가장 간단한 플러그인은 센서 백엔드를 한 번만 가질 수 있지만 여러 센서 백엔드가 플러그인에있을 이유는 없습니다.</target>
        </trans-unit>
        <trans-unit id="cc7a51842f7c60fd33ba5fca3e39d1d8449320ca" translate="yes" xml:space="preserve">
          <source>The simplest use of &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; is to create one from a &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; file or resource, and then use it, allowing Qt to work out all the required icon styles and sizes. For example:</source>
          <target state="translated">&lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; 의 가장 간단한 사용은 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 파일 또는 리소스 에서 하나를 만든 다음이를 사용하여 Qt가 필요한 모든 아이콘 스타일과 크기를 해결할 수 있도록하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7204d0a7bbf4e4d178159e5d5f4db47c0244993" translate="yes" xml:space="preserve">
          <source>The simplest use of QIcon is to create one from a &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; file or resource, and then use it, allowing Qt to work out all the required icon styles and sizes. For example:</source>
          <target state="translated">QIcon의 가장 간단한 사용은 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 파일 또는 리소스 에서 하나를 만든 다음이를 사용하여 Qt가 필요한 모든 아이콘 스타일과 크기를 처리 할 수 ​​있도록하는 것입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="84ee5d3756ef8931e5abf1eedc0581a217f1741d" translate="yes" xml:space="preserve">
          <source>The simplest use of the class is like this:</source>
          <target state="translated">클래스의 가장 간단한 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a9722d0db1ecc59caa68fb1f2f1f66cbd9eff5b2" translate="yes" xml:space="preserve">
          <source>The simplest way of drawing this list is on a cell-by-cell basis. First, the background is drawn. This is a rectangle of a specific color. In OpenGL terms this means selecting a shader program to do solid color fills, setting up the fill color, setting the transformation matrix containing the x and y offsets and then using for instance &lt;code&gt;glDrawArrays&lt;/code&gt; to draw two triangles making up the rectangle. The icon is drawn next. In OpenGL terms this means selecting a shader program to draw textures, selecting the active texture to use, setting the transformation matrix, enabling alpha-blending and then using for instance &lt;code&gt;glDrawArrays&lt;/code&gt; to draw the two triangles making up the bounding rectangle of the icon. The text and separator line between cells follow a similar pattern. And this process is repeated for every cell in the list, so for a longer list, the overhead imposed by OpenGL state changes and draw calls completely outweighs the benefit that using a hardware accelerated API could provide.</source>
          <target state="translated">이 목록을 그리는 가장 간단한 방법은 셀 단위입니다. 먼저 배경이 그려집니다. 이것은 특정 색상의 사각형입니다. OpenGL 용어에서 이것은 단색 채우기를 수행하는 쉐이더 프로그램을 선택하고, 채우기 색상을 설정하고, x 및 y 오프셋을 포함하는 변환 행렬을 설정 한 다음 &lt;code&gt;glDrawArrays&lt;/code&gt; 를 사용 하여 사각형을 구성하는 두 개의 삼각형을 그립니다. 다음에 아이콘이 그려집니다. OpenGL 용어에서 이것은 텍스처를 그릴 셰이더 프로그램 선택, 사용할 활성 텍스처 선택, 변환 매트릭스 설정, 알파 블렌딩 활성화 및 &lt;code&gt;glDrawArrays&lt;/code&gt; 사용 등을 의미합니다 .아이콘의 경계 사각형을 구성하는 두 개의 삼각형을 그립니다. 셀 사이의 텍스트와 구분선은 비슷한 패턴을 따릅니다. 이 프로세스는 목록의 모든 셀에 대해 반복되므로 목록이 길어질수록 OpenGL 상태 변경 및 드로우 콜에 의해 부과되는 오버 헤드는 하드웨어 가속 API를 사용하면 얻을 수있는 이점을 완전히 능가합니다.</target>
        </trans-unit>
        <trans-unit id="71a7f93100a7cf250cfdc1e22b39390ca3991713" translate="yes" xml:space="preserve">
          <source>The simplest way of using a contiguous cache is to use the &lt;a href=&quot;qcontiguouscache#append&quot;&gt;append&lt;/a&gt;() and &lt;a href=&quot;qcontiguouscache#prepend&quot;&gt;prepend&lt;/a&gt;().</source>
          <target state="translated">연속 캐시를 사용하는 가장 간단한 방법은 &lt;a href=&quot;qcontiguouscache#append&quot;&gt;append&lt;/a&gt; () 및 &lt;a href=&quot;qcontiguouscache#prepend&quot;&gt;prepend&lt;/a&gt; () 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="09005e3efdb3584561892cbdaf9938a4f183ef07" translate="yes" xml:space="preserve">
          <source>The simplest way to arrange objects on a form is to place them in a horizontal or vertical layout. Horizontal layouts ensure that the widgets within are aligned horizontally; vertical layouts ensure that they are aligned vertically.</source>
          <target state="translated">양식에 객체를 정렬하는 가장 간단한 방법은 수평 또는 수직 레이아웃에 배치하는 것입니다. 가로 레이아웃은 위젯이 가로로 정렬되도록합니다. 수직 레이아웃은 수직으로 정렬되도록합니다.</target>
        </trans-unit>
        <trans-unit id="3563eabe8475fbf652e4db09bfdbaa7b3541fd0f" translate="yes" xml:space="preserve">
          <source>The simplest way to create a shortcut for a particular widget is to construct the shortcut with a key sequence. For example:</source>
          <target state="translated">특정 위젯에 대한 바로 가기를 만드는 가장 간단한 방법은 키 시퀀스를 사용하여 바로 가기를 구성하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c0aae0882518320d4253f846b8a7753fe1a4de0" translate="yes" xml:space="preserve">
          <source>The simulation loop is launched as soon as a root &lt;a href=&quot;qt3dcore-qentity&quot;&gt;Qt3DCore::QEntity&lt;/a&gt; is set on the &lt;a href=&quot;qt3dcore-qaspectengine&quot;&gt;Qt3DCore::QAspectEngine&lt;/a&gt;. This is followed by a call to onEngineStartup() on each aspect so that they can start their simulation work.</source>
          <target state="translated">루트 &lt;a href=&quot;qt3dcore-qentity&quot;&gt;Qt3DCore :: QEntity&lt;/a&gt; 로 시뮬레이션 루프가 시작됩니다. 온 설정 &lt;a href=&quot;qt3dcore-qaspectengine&quot;&gt;Qt3DCore :: QAspectEngine&lt;/a&gt; . 그런 다음 각 측면에서 onEngineStartup ()을 호출하여 시뮬레이션 작업을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a765f47c2a6c062ea4fb119a84180741a8c4f81" translate="yes" xml:space="preserve">
          <source>The simulation loop is stopped when the root entity is set to Qt3DCore::QEntityPtr(). This calls onEngineShutdown() on each aspect so that they can stop performing their simulation work.</source>
          <target state="translated">루트 엔티티가 Qt3DCore :: QEntityPtr ()로 설정되면 시뮬레이션 루프가 중지됩니다. 각 측면에서 onEngineShutdown ()을 호출하여 시뮬레이션 작업 수행을 중지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30b9e2877b614eaa083374b459594776b3dd666a" translate="yes" xml:space="preserve">
          <source>The simulation will automatically pause if it detects that there are no live particles left, and unpause when new live particles are added.</source>
          <target state="translated">라이브 입자가 남아 있지 않은 것을 감지하면 시뮬레이션이 자동으로 일시 중지되고 새 라이브 입자가 추가되면 일시 중지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb34ec5ed4f96cad2d4b82eb20066cd13ef9a235" translate="yes" xml:space="preserve">
          <source>The singular forms are slightly optimized, so if you do have only a single target/property to animate you should try to use them.</source>
          <target state="translated">단수형은 약간 최적화되었으므로 애니메이션 할 대상 / 프로퍼티가 하나 뿐인 경우 사용을 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="80ba691e2a063ee0eefd2b656f7e15733f622989" translate="yes" xml:space="preserve">
          <source>The site that would be showing in the location bar if the application has one.</source>
          <target state="translated">애플리케이션에 위치 표시 줄에 표시되는 사이트입니다.</target>
        </trans-unit>
        <trans-unit id="f47e4b6f74ae6003047d4e701c45fece3c68df1e" translate="yes" xml:space="preserve">
          <source>The size (width and height) of a graphics primitive always correspond to its mathematical model, ignoring the width of the pen it is rendered with:</source>
          <target state="translated">그래픽 프리미티브의 크기 (너비 및 높이)는 항상 렌더링되는 펜의 너비를 무시하고 수학적 모델에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="899643a567b5f555677c7364b9152436c709f8a2" translate="yes" xml:space="preserve">
          <source>The size calculated will be used for subsequent calls to &lt;a href=&quot;qtextobjectinterface#drawObject&quot;&gt;drawObject&lt;/a&gt;() for this</source>
          <target state="translated">계산 된 크기는 이후에 &lt;a href=&quot;qtextobjectinterface#drawObject&quot;&gt;drawObject&lt;/a&gt; ()를 호출하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fc1a1a45d87c8263cf46a19fdaaf1ae4ce9f20a7" translate="yes" xml:space="preserve">
          <source>The size component is adjusted if it lies outside the range defined by &lt;a href=&quot;qwidget#minimumSize-prop&quot;&gt;minimumSize&lt;/a&gt;() and &lt;a href=&quot;qwidget#maximumSize-prop&quot;&gt;maximumSize&lt;/a&gt;().</source>
          <target state="translated">크기 구성 요소가 &lt;a href=&quot;qwidget#minimumSize-prop&quot;&gt;minimumSize&lt;/a&gt; () 및 &lt;a href=&quot;qwidget#maximumSize-prop&quot;&gt;maximumSize&lt;/a&gt; ()에 의해 정의 된 범위를 벗어나면 조정됩니다 .</target>
        </trans-unit>
        <trans-unit id="95de11d8aeeaf5134dcb68b0bad5c9ef6253257d" translate="yes" xml:space="preserve">
          <source>The size grip calculates its size hint with &lt;code&gt;CT_SizeGrip&lt;/code&gt;. The pixel metric &lt;code&gt;PM_SizeGripSize&lt;/code&gt; is currently unused by Qt. The element tree for an image in the Plastique style of &lt;a href=&quot;qsizegrip&quot;&gt;QSizeGrip&lt;/a&gt; follows:</source>
          <target state="translated">크기 그립은 &lt;code&gt;CT_SizeGrip&lt;/code&gt; 을 사용하여 크기 힌트를 계산합니다 . 픽셀 메트릭 &lt;code&gt;PM_SizeGripSize&lt;/code&gt; 는 현재 Qt에서 사용되지 않습니다. Plastique 스타일의 &lt;a href=&quot;qsizegrip&quot;&gt;QSizeGrip&lt;/a&gt; 에서 이미지의 요소 트리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e36b005afb3d552aee5dbf5f8ccbbdd3ab9a1f46" translate="yes" xml:space="preserve">
          <source>The size grip is enabled by default.</source>
          <target state="translated">크기 그립은 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1c6921fba5ac69a0a5a878f4891ad7e7b14700e" translate="yes" xml:space="preserve">
          <source>The size grip style option, &lt;a href=&quot;qstyleoptionsizegrip&quot;&gt;QStyleOptionSizeGrip&lt;/a&gt;, has one member besides the common members from &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;:</source>
          <target state="translated">크기 그립 스타일 옵션 인 &lt;a href=&quot;qstyleoptionsizegrip&quot;&gt;QStyleOptionSizeGrip&lt;/a&gt; 은 QStyleOption 의 공통 멤버 외에 하나의 멤버를 &lt;a href=&quot;qstyleoption&quot;&gt;갖습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44b824e0d7e57f0c9db6634c745ecb73b354bdb0" translate="yes" xml:space="preserve">
          <source>The size hint for the item that will be supplied to views. (&lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;)</source>
          <target state="translated">뷰에 제공 될 항목의 크기 힌트입니다. ( &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="9107524eff6dacbc22b4ec51b17a09a0a7ca8bfe" translate="yes" xml:space="preserve">
          <source>The size in bits of a pointer for the platform on which the application is compiled (32 or 64).</source>
          <target state="translated">응용 프로그램이 컴파일되는 플랫폼에 대한 포인터의 비트 크기 (32 또는 64)입니다.</target>
        </trans-unit>
        <trans-unit id="79bac3b561d6ddb215a7d9955501de461408ef0e" translate="yes" xml:space="preserve">
          <source>The size in bytes of the media.</source>
          <target state="translated">미디어의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="2e625d03c78075a3a0d1d606973da6bbe730bf63" translate="yes" xml:space="preserve">
          <source>The size in pixels of the particles at the end of their life. Size will be linearly interpolated during the life of the particle from this value and size. If endSize is -1, then the size of the particle will remain constant at the starting size.</source>
          <target state="translated">수명이 다한 입자의 크기 (픽셀)입니다. 이 값과 크기에서 입자의 수명 동안 크기가 선형 보간됩니다. endSize가 -1이면 입자의 크기가 시작 크기에서 일정하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="27d3a2a9dbab1d3b4594efcdc49d8d8c0463f53f" translate="yes" xml:space="preserve">
          <source>The size in pixels of the particles at the start of their life.</source>
          <target state="translated">수명이 시작될 때 입자의 픽셀 크기입니다.</target>
        </trans-unit>
        <trans-unit id="a9615d78b39a640994dfcc16b3a2009187a96290" translate="yes" xml:space="preserve">
          <source>The size in pixels that the particle image is at the end of its life. If this value is less than 0, then it is disregarded and the particle will have its &lt;a href=&quot;qml-qtquick-particles-particle#startSize-prop&quot;&gt;startSize&lt;/a&gt; for the entire lifetime.</source>
          <target state="translated">입자 이미지의 수명이 다한 픽셀 단위의 크기입니다. 이 값이 0보다 작 으면 무시되고 입자의 시작 &lt;a href=&quot;qml-qtquick-particles-particle#startSize-prop&quot;&gt;크기가&lt;/a&gt; 전체 수명 동안 를 .</target>
        </trans-unit>
        <trans-unit id="bb4de0ef5bb6e1dc2ee14db2c603762023396177" translate="yes" xml:space="preserve">
          <source>The size in pixels that the particle image is at the start of its life.</source>
          <target state="translated">입자 이미지의 수명이 시작되는 시점의 픽셀 크기입니다.</target>
        </trans-unit>
        <trans-unit id="4c3cc4dc700b1d4f4e04713f9616644a497c2dbe" translate="yes" xml:space="preserve">
          <source>The size is adjusted if it lies outside the range defined by &lt;a href=&quot;qwidget#minimumSize-prop&quot;&gt;minimumSize&lt;/a&gt;() and &lt;a href=&quot;qwidget#maximumSize-prop&quot;&gt;maximumSize&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qwidget#minimumSize-prop&quot;&gt;minimumSize&lt;/a&gt; () 및 &lt;a href=&quot;qwidget#maximumSize-prop&quot;&gt;maximumSize&lt;/a&gt; ()에 의해 정의 된 범위를 벗어나면 크기가 조정됩니다 .</target>
        </trans-unit>
        <trans-unit id="783d010c5dc8cda5a65aa04e8d197b15a97bdc75" translate="yes" xml:space="preserve">
          <source>The size is scaled freely. The aspect ratio is not preserved.</source>
          <target state="translated">크기는 자유롭게 조정됩니다. 종횡비가 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8538408f26ca11d7b7474d6e9f6c4d67ff3f3ba" translate="yes" xml:space="preserve">
          <source>The size is scaled to a rectangle as large as possible inside a given rectangle, preserving the aspect ratio.</source>
          <target state="translated">크기는 주어진 사각형 내에서 가능한 한 큰 사각형으로 조정되어 종횡비를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="b323dffad3f2966f985d38ce35e04f9dd33e6695" translate="yes" xml:space="preserve">
          <source>The size is scaled to a rectangle as small as possible outside a given rectangle, preserving the aspect ratio.</source>
          <target state="translated">크기는 지정된 사각형 외부에서 가능한 한 작은 사각형으로 조정되어 종횡비를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="a8215bfa99ecb5eca03e86b0c9c3b5d918ab237d" translate="yes" xml:space="preserve">
          <source>The size must be between &lt;code&gt;0.0f&lt;/code&gt; and &lt;code&gt;1.0f&lt;/code&gt;. Setting the size to &lt;code&gt;0.0f&lt;/code&gt; causes the item size to be automatically scaled based on the total number of items in all the series for the graph.</source>
          <target state="translated">크기는 &lt;code&gt;0.0f&lt;/code&gt; ~ &lt;code&gt;1.0f&lt;/code&gt; 사이 여야합니다 . 크기를 &lt;code&gt;0.0f&lt;/code&gt; 로 설정 그래프의 모든 계열에있는 총 항목 수를 기준으로 항목 크기가 자동으로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="dcfb6e9f6898b08413514ead7aca38aba3eb0cf1" translate="yes" xml:space="preserve">
          <source>The size of a font.</source>
          <target state="translated">글꼴의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="80b21fc9ade08178f9959edf7b2f81d203510b76" translate="yes" xml:space="preserve">
          <source>The size of a particle can vary by this much up or down from size/&lt;a href=&quot;qml-qtquick-particles-emitter#endSize-prop&quot;&gt;endSize&lt;/a&gt;. The same random addition is made to both size and &lt;a href=&quot;qml-qtquick-particles-emitter#endSize-prop&quot;&gt;endSize&lt;/a&gt; for a single particle.</source>
          <target state="translated">파티클의 크기는 size / &lt;a href=&quot;qml-qtquick-particles-emitter#endSize-prop&quot;&gt;endSize&lt;/a&gt; 에서 위 또는 아래로 크게 달라질 수 있습니다 . 단일 입자에 대해 size와 &lt;a href=&quot;qml-qtquick-particles-emitter#endSize-prop&quot;&gt;endSize&lt;/a&gt; 에 동일한 무작위 추가가 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="328cc0d2f52118826675f2c1e6c8411bf9834529" translate="yes" xml:space="preserve">
          <source>The size of a size grip.</source>
          <target state="translated">그립 사이즈입니다.</target>
        </trans-unit>
        <trans-unit id="23ac9b48744f4520b5a9b4dd909c4397828394bd" translate="yes" xml:space="preserve">
          <source>The size of button icons on a title bar. This enum value has been introduced in Qt 5.8.</source>
          <target state="translated">제목 표시 줄의 단추 아이콘 크기입니다. 이 열거 형 값은 Qt 5.8에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="86b70614f597d5434a481f53670cca00acfa3370" translate="yes" xml:space="preserve">
          <source>The size of buttons on a title bar. This enum value has been introduced in Qt 5.8.</source>
          <target state="translated">제목 표시 줄의 단추 크기입니다. 이 열거 형 값은 Qt 5.8에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="3e09d367b421f35f1ede7461f569385457fc708f" translate="yes" xml:space="preserve">
          <source>The size of the</source>
          <target state="translated">의 크기</target>
        </trans-unit>
        <trans-unit id="643a11f954ce2521504e711bfd997c7660111eab" translate="yes" xml:space="preserve">
          <source>The size of the FBO will by default adapt to the size of the item. If a fixed size is preferred, set &lt;a href=&quot;qquickframebufferobject#textureFollowsItemSize-prop&quot;&gt;textureFollowsItemSize&lt;/a&gt; to &lt;code&gt;false&lt;/code&gt; and return a texture of your choosing from &lt;a href=&quot;qquickframebufferobject-renderer#createFramebufferObject&quot;&gt;QQuickFramebufferObject::Renderer::createFramebufferObject&lt;/a&gt;().</source>
          <target state="translated">FBO의 크기는 기본적으로 항목의 크기에 맞게 조정됩니다. 고정 된 크기를 선호하는 경우 &lt;a href=&quot;qquickframebufferobject#textureFollowsItemSize-prop&quot;&gt;textureFollowsItemSize&lt;/a&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정 하고 &lt;a href=&quot;qquickframebufferobject-renderer#createFramebufferObject&quot;&gt;QQuickFramebufferObject :: Renderer :: createFramebufferObject&lt;/a&gt; () 에서 선택한 텍스처를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2471bda81445c6608b25eefc895e2f33d3799045" translate="yes" xml:space="preserve">
          <source>The size of the air gap left between the volume itself and the frame in each dimension. The gap can be different on different dimensions. The values are fractions of the volume thickness in the same dimension. The values cannot be negative.</source>
          <target state="translated">볼륨 자체와 각 치수의 프레임 사이에 남아있는 에어 갭의 크기입니다. 간격은 치수에 따라 다를 수 있습니다. 값은 동일한 치수에서 부피 두께의 분수입니다. 값은 음수 일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bb7b498009a46aaf7f9aef80a148f338f9bcd70e" translate="yes" xml:space="preserve">
          <source>The size of the current items icon.</source>
          <target state="translated">현재 항목 아이콘의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="f84b44ee09ee588ea3af9ba9ee15060ec6ddf4eb" translate="yes" xml:space="preserve">
          <source>The size of the document can be changed either by setting a text width or setting an entire page size.</source>
          <target state="translated">텍스트 크기를 설정하거나 전체 페이지 크기를 설정하여 문서 크기를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3478a57511c2d165e78848a7c89dc06e0515d0b" translate="yes" xml:space="preserve">
          <source>The size of the drop down button when the combobox is editable.</source>
          <target state="translated">콤보 박스를 편집 할 수있는 드롭 다운 버튼의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="50a129f2a1aa12af78a097deac7ec473d8ff7e0a" translate="yes" xml:space="preserve">
          <source>The size of the file is returned by &lt;a href=&quot;qfile#size&quot;&gt;size&lt;/a&gt;(). You can get the current file position using &lt;a href=&quot;qfiledevice#pos&quot;&gt;pos&lt;/a&gt;(), or move to a new file position using &lt;a href=&quot;qfiledevice#seek&quot;&gt;seek&lt;/a&gt;(). If you've reached the end of the file, &lt;a href=&quot;qfiledevice#atEnd&quot;&gt;atEnd&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">파일 크기는 &lt;a href=&quot;qfile#size&quot;&gt;크기&lt;/a&gt; () 로 반환됩니다 . &lt;a href=&quot;qfiledevice#pos&quot;&gt;pos&lt;/a&gt; ()를 사용하여 현재 파일 위치를 얻 거나 &lt;a href=&quot;qfiledevice#seek&quot;&gt;seek&lt;/a&gt; ()를 사용하여 새 파일 위치로 이동할 수 있습니다. 파일의 끝에 도달하면 &lt;a href=&quot;qfiledevice#atEnd&quot;&gt;atEnd&lt;/a&gt; ()가 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="321e10b82d2d9688484cf8b50a7a20b9d8e1b66f" translate="yes" xml:space="preserve">
          <source>The size of the icon as it will be shown on the map.</source>
          <target state="translated">지도에 표시 될 아이콘의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="b8e8675d4ffb7f10a91189263c10cdee6d1a8b1c" translate="yes" xml:space="preserve">
          <source>The size of the margin between the sort indicator and the text.</source>
          <target state="translated">정렬 표시기와 텍스트 사이의 여백 크기입니다.</target>
        </trans-unit>
        <trans-unit id="6807d46ddab3de38e719646a7e1c9402982df839" translate="yes" xml:space="preserve">
          <source>The size of the marker used to render the points in the series. The default size is 15.0.</source>
          <target state="translated">시리즈에서 점을 렌더링하는 데 사용되는 마커의 크기입니다. 기본 크기는 15.0입니다.</target>
        </trans-unit>
        <trans-unit id="f20ac2c362789307100928330231e31c26781aa9" translate="yes" xml:space="preserve">
          <source>The size of the rectangle,</source>
          <target state="translated">사각형의 크기</target>
        </trans-unit>
        <trans-unit id="779136aecbe6f3c631c3953feab7bd220f2dfdb0" translate="yes" xml:space="preserve">
          <source>The size of the resize grip in a header.</source>
          <target state="translated">헤더의 크기 조정 그립 크기입니다.</target>
        </trans-unit>
        <trans-unit id="61523e0a46be780a4cb2871650b3058cf109c1d4" translate="yes" xml:space="preserve">
          <source>The size of the sort indicator in a header.</source>
          <target state="translated">헤더의 정렬 표시기 크기입니다.</target>
        </trans-unit>
        <trans-unit id="3c34f2f1945377a4477cd1747f661cb12b0aa3de" translate="yes" xml:space="preserve">
          <source>The size of the standard icons in a message box</source>
          <target state="translated">메시지 상자의 표준 아이콘 크기</target>
        </trans-unit>
        <trans-unit id="3aaea774fc2779c1c695f57e526b508098bd1217" translate="yes" xml:space="preserve">
          <source>The size of the surface is accessible with the &lt;a href=&quot;qsurface#size&quot;&gt;size&lt;/a&gt;() function. The rendering specific attributes of the surface are accessible through the &lt;a href=&quot;qsurface#format&quot;&gt;format&lt;/a&gt;() function.</source>
          <target state="translated">표면의 &lt;a href=&quot;qsurface#size&quot;&gt;크기&lt;/a&gt; 는 size () 함수를 사용하여 액세스 할 수 있습니다. 표면의 렌더링 특정 속성은 &lt;a href=&quot;qsurface#format&quot;&gt;format&lt;/a&gt; () 함수를 통해 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae0845157a27bf685d82f8704d11b1166181af92" translate="yes" xml:space="preserve">
          <source>The size of this array must be at least (&lt;code&gt;textureDataWidth * textureHeight * textureDepth * texture format color depth in bytes&lt;/code&gt;).</source>
          <target state="translated">이 배열의 크기는 최소한 ( &lt;code&gt;textureDataWidth * textureHeight * textureDepth * texture format color depth in bytes&lt;/code&gt; )) 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="7f7282a3eec94d99fbb33083fd3a315ca685a815" translate="yes" xml:space="preserve">
          <source>The size of toolbar icons can be retrieved with &lt;code&gt;iconSize()&lt;/code&gt;. The sizes are platform dependent; you can set a fixed size with &lt;code&gt;setIconSize()&lt;/code&gt;. You can alter the appearance of all tool buttons in the toolbars with &lt;code&gt;setToolButtonStyle()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;iconSize()&lt;/code&gt; 로 툴바 아이콘의 크기를 검색 할 수 있습니다 . 크기는 플랫폼에 따라 다릅니다. &lt;code&gt;setIconSize()&lt;/code&gt; 로 고정 크기를 설정할 수 있습니다 . &lt;code&gt;setToolButtonStyle()&lt;/code&gt; 을 사용하여 툴바의 모든 도구 버튼 모양을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ff7bc3041c106b6866a7ccb43da69e1fcba5d3c" translate="yes" xml:space="preserve">
          <source>The size policy lets you supply good default behavior for the layout management system, so that other widgets can contain and manage yours easily. The default size policy indicates that the size hint represents the preferred size of the widget, and this is often good enough for many widgets.</source>
          <target state="translated">크기 정책을 사용하면 레이아웃 관리 시스템에 기본 동작을 제공하여 다른 위젯이 사용자를 쉽게 포함하고 관리 할 수 ​​있습니다. 기본 크기 정책은 크기 힌트가 위젯의 기본 크기를 나타내며 많은 위젯에 충분할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7e628ba4d5118befdf7e110efd11dfe33772deb4" translate="yes" xml:space="preserve">
          <source>The size policy of a widget is an expression of its willingness to be resized in various ways, and affects how the widget is treated by the &lt;a href=&quot;layout&quot;&gt;layout engine&lt;/a&gt;. Each widget returns a QSizePolicy that describes the horizontal and vertical resizing policy it prefers when being laid out. You can change this for a specific widget by changing its &lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;QWidget::sizePolicy&lt;/a&gt; property.</source>
          <target state="translated">위젯의 크기 정책은 다양한 방식으로 크기를 조정하려는 의지의 표현이며 &lt;a href=&quot;layout&quot;&gt;레이아웃 엔진&lt;/a&gt; 에서 위젯을 처리하는 방식에 영향을줍니다 . 각 위젯은 레이아웃시 선호하는 수평 및 수직 크기 조정 정책을 설명하는 QSizePolicy를 반환합니다. &lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;QWidget :: sizePolicy&lt;/a&gt; 속성 을 변경하여 특정 위젯에 대해이를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1099fe030f6a6d2c51785d48ac840e45ff31b3d6" translate="yes" xml:space="preserve">
          <source>The size policy of a widget is an expression of its willingness to be resized in various ways, and affects how the widget is treated by the &lt;a href=&quot;layout#&quot;&gt;layout engine&lt;/a&gt;. Each widget returns a &lt;a href=&quot;qsizepolicy&quot;&gt;QSizePolicy&lt;/a&gt; that describes the horizontal and vertical resizing policy it prefers when being laid out. You can change this for a specific widget by changing its &lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;QWidget::sizePolicy&lt;/a&gt; property.</source>
          <target state="translated">위젯의 크기 정책은 다양한 방법으로 크기를 조정하려는 의지의 표현이며 위젯이 &lt;a href=&quot;layout#&quot;&gt;레이아웃 엔진에&lt;/a&gt; 의해 처리되는 방식에 영향을줍니다 . 각 위젯은 배치 할 때 선호하는 가로 및 세로 크기 조정 정책을 설명 하는 &lt;a href=&quot;qsizepolicy&quot;&gt;QSizePolicy&lt;/a&gt; 를 반환합니다 . &lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;QWidget :: sizePolicy&lt;/a&gt; 특성 을 변경하여 특정 위젯에 대해이를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2d1bd68bfbd9994032218254eff81d105799646" translate="yes" xml:space="preserve">
          <source>The size requested for the window geometry by the positioner object.</source>
          <target state="translated">포지셔너 객체가 창 지오메트리에 요청한 크기입니다.</target>
        </trans-unit>
        <trans-unit id="40059d0f6682b091f1cdbe849582d81255b22ebb" translate="yes" xml:space="preserve">
          <source>The sizeHint() is a maximum. The widget can be shrunk any amount without detriment if other widgets need the space (e.g. a separator line). It cannot be larger than the size provided by sizeHint().</source>
          <target state="translated">sizeHint ()는 최대입니다. 다른 위젯에 공간이 필요한 경우 (예 : 구분선) 위젯이 손상없이 어느 정도 줄어들 수 있습니다. sizeHint ()가 제공하는 크기보다 클 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ccaee7cb44fa31de0d8db3a9ec0a476eadb36588" translate="yes" xml:space="preserve">
          <source>The sizeHint() is a sensible size, but the widget can be shrunk and still be useful. The widget can make use of extra space, so it should get as much space as possible (e.g. the horizontal direction of a horizontal slider).</source>
          <target state="translated">sizeHint ()는 적당한 크기이지만 위젯이 축소되어 여전히 유용 할 수 있습니다. 위젯은 추가 공간을 사용할 수 있으므로 가능한 많은 공간을 확보해야합니다 (예 : 수평 슬라이더의 수평 방향).</target>
        </trans-unit>
        <trans-unit id="5dc7339ec976c70e32fe06ff662f47cae8bcef13" translate="yes" xml:space="preserve">
          <source>The sizeHint() is best, but the widget can be shrunk and still be useful. The widget can be expanded, but there is no advantage to it being larger than sizeHint() (the default &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; policy).</source>
          <target state="translated">sizeHint ()가 가장 좋지만 위젯이 축소되어 여전히 유용 할 수 있습니다. 위젯을 확장 할 수 있지만 sizeHint () (기본 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 정책) 보다 큰 이점은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="489d4f1309097fe4f1bbc5582ea3880deb44b958" translate="yes" xml:space="preserve">
          <source>The sizeHint() is ignored. The widget will get as much space as possible.</source>
          <target state="translated">sizeHint ()는 무시됩니다. 위젯은 가능한 많은 공간을 확보합니다.</target>
        </trans-unit>
        <trans-unit id="836bf25e7ce9fe423bb010483d590fadcb86091a" translate="yes" xml:space="preserve">
          <source>The sizeHint() is minimal, and sufficient. The widget can be expanded, but there is no advantage to it being larger (e.g. the horizontal direction of a push button). It cannot be smaller than the size provided by sizeHint().</source>
          <target state="translated">sizeHint ()는 최소이고 충분합니다. 위젯은 확장 할 수 있지만 더 큰 장점은 없습니다 (예 : 푸시 버튼의 가로 방향). sizeHint ()에서 제공하는 크기보다 작을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0429eff7f14673719920eefec32cd463568a28e9" translate="yes" xml:space="preserve">
          <source>The sizeHint() is minimal, and sufficient. The widget can make use of extra space, so it should get as much space as possible (e.g. the horizontal direction of a horizontal slider).</source>
          <target state="translated">sizeHint ()는 최소이고 충분합니다. 위젯은 추가 공간을 사용할 수 있으므로 가능한 많은 공간을 확보해야합니다 (예 : 수평 슬라이더의 수평 방향).</target>
        </trans-unit>
        <trans-unit id="242646025c55f21f9d0420ab70a4f29e2c92e5a8" translate="yes" xml:space="preserve">
          <source>The skeleton has not been loaded yet</source>
          <target state="translated">스켈레톤이 아직로드되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="08ee8366d6ce883516f3a28f5aa77ced492a4772" translate="yes" xml:space="preserve">
          <source>The skeleton was successfully loaded</source>
          <target state="translated">스켈레톤이 성공적으로로드되었습니다</target>
        </trans-unit>
        <trans-unit id="d58f6e3f925895c8e5a5cd1b8a0c3c11c4485196" translate="yes" xml:space="preserve">
          <source>The slider can be styled using the &lt;a href=&quot;#handle-sub&quot;&gt;::handle&lt;/a&gt; subcontrol. Setting the &lt;a href=&quot;#min-width-prop&quot;&gt;min-width&lt;/a&gt; or &lt;a href=&quot;#min-height-prop&quot;&gt;min-height&lt;/a&gt; provides size contraints for the slider depending on the orientation.</source>
          <target state="translated">&lt;a href=&quot;#handle-sub&quot;&gt;:: handle&lt;/a&gt; 하위 컨트롤을 사용하여 슬라이더 스타일을 지정할 수 있습니다 . 설정 &lt;a href=&quot;#min-width-prop&quot;&gt;최소 폭&lt;/a&gt; 또는 &lt;a href=&quot;#min-height-prop&quot;&gt;최소 높이하는&lt;/a&gt; 방향에 따라 상기 슬라이더에 대한 사이즈 제약 조건을 제공한다.</target>
        </trans-unit>
        <trans-unit id="9c3685d461f3e567cdcdc6d7e44857d5b220a280" translate="yes" xml:space="preserve">
          <source>The slider can be styled using the &lt;a href=&quot;stylesheet-reference#handle-sub&quot;&gt;::handle&lt;/a&gt; subcontrol. Setting the &lt;a href=&quot;stylesheet-reference#min-width-prop&quot;&gt;min-width&lt;/a&gt; or &lt;a href=&quot;stylesheet-reference#min-height-prop&quot;&gt;min-height&lt;/a&gt; provides size contraints for the slider depending on the orientation.</source>
          <target state="translated">슬라이더는 &lt;a href=&quot;stylesheet-reference#handle-sub&quot;&gt;:: handle&lt;/a&gt; 하위 컨트롤을 사용하여 스타일을 지정할 수 있습니다 . 설정 &lt;a href=&quot;stylesheet-reference#min-width-prop&quot;&gt;최소 폭&lt;/a&gt; 또는 &lt;a href=&quot;stylesheet-reference#min-height-prop&quot;&gt;최소 높이하는&lt;/a&gt; 방향에 따라 상기 슬라이더에 대한 사이즈 제약 조건을 제공한다.</target>
        </trans-unit>
        <trans-unit id="46fcc564c24226afcf7c3e90af2ff9865886e919" translate="yes" xml:space="preserve">
          <source>The slider does not snap (default).</source>
          <target state="translated">슬라이더가 스냅되지 않습니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="0f4c61ea48b1a3f24360012968c60b705b209997" translate="yes" xml:space="preserve">
          <source>The slider does not snap while being dragged, but only after the handle is released.</source>
          <target state="translated">드래그하는 동안 슬라이더가 스냅되지 않고 핸들을 놓은 후에 만 ​​스냅됩니다.</target>
        </trans-unit>
        <trans-unit id="c9e5839116490d1307eea05da83a658d91b91540" translate="yes" xml:space="preserve">
          <source>The slider forces the value to be within the legal range: &lt;a href=&quot;qabstractslider#minimum-prop&quot;&gt;minimum&lt;/a&gt; &amp;lt;= &lt;code&gt;value&lt;/code&gt; &amp;lt;= &lt;a href=&quot;qabstractslider#maximum-prop&quot;&gt;maximum&lt;/a&gt;.</source>
          <target state="translated">슬라이더는 값이 유효한 범위 ( &lt;a href=&quot;qabstractslider#minimum-prop&quot;&gt;최소&lt;/a&gt; &amp;lt;= &lt;code&gt;value&lt;/code&gt; &amp;lt;= &lt;a href=&quot;qabstractslider#maximum-prop&quot;&gt;maximum) 내에 있도록&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="051c1bdab1d246601df0c604b8a11a3ba68bba25" translate="yes" xml:space="preserve">
          <source>The slider is a complex control that functions as a &lt;a href=&quot;qaccessible#RelationFlag-enum&quot;&gt;Controller&lt;/a&gt; for its accessible children. This relationship must be known by the interface (for &lt;a href=&quot;qaccessibleinterface#parent&quot;&gt;parent()&lt;/a&gt;, &lt;a href=&quot;qaccessibleinterface#child&quot;&gt;child()&lt;/a&gt; and &lt;a href=&quot;qaccessibleinterface#relations&quot;&gt;relations()&lt;/a&gt;). This can be done using a controlling signal, which is a mechanism provided by &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;. We do this in the constructor:</source>
          <target state="translated">슬라이더는 접근하기 쉬운 자식을위한 &lt;a href=&quot;qaccessible#RelationFlag-enum&quot;&gt;컨트롤러&lt;/a&gt; 역할을하는 복잡한 컨트롤입니다 . 이 관계는 인터페이스 ( &lt;a href=&quot;qaccessibleinterface#parent&quot;&gt;parent ()&lt;/a&gt; , &lt;a href=&quot;qaccessibleinterface#child&quot;&gt;child ()&lt;/a&gt; 및 &lt;a href=&quot;qaccessibleinterface#relations&quot;&gt;relations ()&lt;/a&gt; )에 의해 알아야합니다 . 제어 신호를 사용하여 수행 할 수 있으며 이는 &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget에서&lt;/a&gt; 제공하는 메커니즘 입니다. 우리는 생성자에서 이것을합니다 :</target>
        </trans-unit>
        <trans-unit id="6f49c18397ee5235789bea658fe23aaa9b0ff4a9" translate="yes" xml:space="preserve">
          <source>The slider is the classic control for providing a bounded value. It lets the user move a slider handle along a horizontal or vertical groove and translates the handle's position into a value within the legal range.</source>
          <target state="translated">슬라이더는 경계 값을 제공하는 기본 컨트롤입니다. 사용자가 수평 또는 수직 홈을 따라 슬라이더 핸들을 움직여 핸들의 위치를 ​​유효한 범위 내의 값으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fd24718fb67d04f5ff21b7bcc4e0c59ea72aae9" translate="yes" xml:space="preserve">
          <source>The slider is the classic widget for controlling a bounded value. It lets the user move a slider handle along a horizontal or vertical groove and translates the handle's position into an integer value within the legal range.</source>
          <target state="translated">슬라이더는 경계 값을 제어하기위한 기본 위젯입니다. 그것은 사용자가 수평 또는 수직 그루브를 따라 슬라이더 핸들을 움직일 수 있고 핸들의 위치를 ​​유효한 범위 내에서 정수 값으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="150f674d56d6ed80eaed58e61dc440cf2585e3cf" translate="yes" xml:space="preserve">
          <source>The slider itself can be controlled by using the &lt;a href=&quot;qabstractslider#triggerAction&quot;&gt;triggerAction()&lt;/a&gt; function to simulate user interaction with the scroll bar controls. This is useful if you have many different widgets that use a common range of values.</source>
          <target state="translated">슬라이더를 사용하여 슬라이더 자체를 제어 할 수 있습니다 &lt;a href=&quot;qabstractslider#triggerAction&quot;&gt; triggerAction ()&lt;/a&gt; 함수를 사용하여 스크롤 막대 컨트롤과의 사용자 상호 작용을 시뮬레이션 . 공통 범위의 값을 사용하는 여러 가지 다른 위젯이있는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8260fe82a65f88ee039a3fd9c6d907bd997d8a41" translate="yes" xml:space="preserve">
          <source>The slider snaps while the handle is dragged.</source>
          <target state="translated">핸들을 드래그하는 동안 슬라이더가 스냅됩니다.</target>
        </trans-unit>
        <trans-unit id="f871f3db07f872f83b130fdc91ebb0cff8c9ef3e" translate="yes" xml:space="preserve">
          <source>The slider style allows you to create a custom appearance for a &lt;a href=&quot;qml-qtquick-controls-slider&quot;&gt;Slider&lt;/a&gt; control.</source>
          <target state="translated">슬라이더 스타일은 당신이에 대한 사용자 정의 모양을 만들 수 있습니다 &lt;a href=&quot;qml-qtquick-controls-slider&quot;&gt;슬라이더를&lt;/a&gt; 컨트롤 .</target>
        </trans-unit>
        <trans-unit id="7bcda2fcafcf426e1697472b50dd8e2c2cedb81a" translate="yes" xml:space="preserve">
          <source>The slider value is by default in the range [0, 1]. If integer values are needed, you can set the &lt;a href=&quot;qml-qtquick-controls-slider#stepSize-prop&quot;&gt;stepSize&lt;/a&gt;.</source>
          <target state="translated">슬라이더 값은 기본적으로 [0, 1] 범위에 있습니다. 정수 값이 필요한 경우 &lt;a href=&quot;qml-qtquick-controls-slider#stepSize-prop&quot;&gt;stepSize를&lt;/a&gt; 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a354201b3678783ed42c26cc4870f02476a60f69" translate="yes" xml:space="preserve">
          <source>The slot connected to by the above code could be something similar to the following:</source>
          <target state="translated">위 코드로 연결된 슬롯은 다음과 유사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe46305fe52aebcaec65acb64559e4b98fdbe31f" translate="yes" xml:space="preserve">
          <source>The slot connected to this signal can read the data on the clipboard using one of the MIME types that can be used to represent it:</source>
          <target state="translated">이 신호에 연결된 슬롯은이를 나타내는 데 사용할 수있는 MIME 유형 중 하나를 사용하여 클립 보드의 데이터를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9b6f0336f789f8d973e727d07a1ab90707bcecb" translate="yes" xml:space="preserve">
          <source>The slot connecting to this signal may create and initialize a &lt;a href=&quot;qml-qtwayland-compositor-waylandsurface&quot;&gt;WaylandSurface&lt;/a&gt; instance in the scope of the slot. Otherwise a default surface is created.</source>
          <target state="translated">이 신호에 연결되는 슬롯은 슬롯 범위에서 &lt;a href=&quot;qml-qtwayland-compositor-waylandsurface&quot;&gt;WaylandSurface&lt;/a&gt; 인스턴스를 생성하고 초기화 할 수 있습니다 . 그렇지 않으면 기본 표면이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a40d4d22883a1625b68b65fb2f7188836d22da48" translate="yes" xml:space="preserve">
          <source>The slot connecting to this signal may create and initialize a &lt;a href=&quot;qwaylandsurface&quot;&gt;QWaylandSurface&lt;/a&gt; instance in the scope of the slot. Otherwise a default surface is created.</source>
          <target state="translated">이 신호 에 연결된 슬롯은 슬롯 범위에서 &lt;a href=&quot;qwaylandsurface&quot;&gt;QWaylandSurface&lt;/a&gt; 인스턴스를 생성하고 초기화 할 수 있습니다 . 그렇지 않으면 기본 표면이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="efa1e8a54c7de8c846fdecbae43bf10074f64972" translate="yes" xml:space="preserve">
          <source>The slot is invoked immediately when the signal is emitted. The slot is executed in the signalling thread.</source>
          <target state="translated">신호가 방출되면 즉시 슬롯이 호출됩니다. 슬롯은 시그널링 스레드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="bc9627f3ee2179e6ac96a49ef335f4b908a27bc4" translate="yes" xml:space="preserve">
          <source>The slot is invoked when control returns to the event loop of the receiver's thread. The slot is executed in the receiver's thread.</source>
          <target state="translated">제어가 수신자 스레드의 이벤트 루프로 리턴 될 때 슬롯이 호출됩니다. 슬롯은 수신기의 스레드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ce4a352409c319e77ec564304f1677a30d49a409" translate="yes" xml:space="preserve">
          <source>The slot is invoked when the results are ready. The results are stored in a &lt;a href=&quot;qhostinfo&quot;&gt;QHostInfo&lt;/a&gt; object. Call &lt;a href=&quot;qhostinfo#addresses&quot;&gt;addresses&lt;/a&gt;() to get the list of IP addresses for the host, and &lt;a href=&quot;qhostinfo#hostName&quot;&gt;hostName&lt;/a&gt;() to get the host name that was looked up.</source>
          <target state="translated">결과가 준비되면 슬롯이 호출됩니다. 결과는 &lt;a href=&quot;qhostinfo&quot;&gt;QHostInfo&lt;/a&gt; 객체에 저장됩니다 . 호스트의 IP 주소 목록을 얻으려면 &lt;a href=&quot;qhostinfo#addresses&quot;&gt;주소&lt;/a&gt; ()를 호출 하고 조회 된 호스트 이름을 얻으려면 &lt;a href=&quot;qhostinfo#hostName&quot;&gt;hostName&lt;/a&gt; ()을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="4384cd606a6ef32bdcc6a9b63190bdab2f482973" translate="yes" xml:space="preserve">
          <source>The slot is invoked when the results are ready. The results are stored in a QHostInfo object. Call &lt;a href=&quot;qhostinfo#addresses&quot;&gt;addresses&lt;/a&gt;() to get the list of IP addresses for the host, and &lt;a href=&quot;qhostinfo#hostName&quot;&gt;hostName&lt;/a&gt;() to get the host name that was looked up.</source>
          <target state="translated">결과가 준비되면 슬롯이 호출됩니다. 결과는 QHostInfo 객체에 저장됩니다. &lt;a href=&quot;qhostinfo#addresses&quot;&gt;주소&lt;/a&gt; ()를 호출 하여 호스트의 IP 주소 목록을 가져오고 &lt;a href=&quot;qhostinfo#hostName&quot;&gt;hostName&lt;/a&gt; ()을 호출 하여 검색된 호스트 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d558370f6aec0d6dd7c2636f5c90d2a2c82b992d" translate="yes" xml:space="preserve">
          <source>The slots could be connected to &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButtons&lt;/a&gt; with &lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;autoRepeat&lt;/a&gt; enabled.</source>
          <target state="translated">슬롯은에 연결 할 수 &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButtons&lt;/a&gt; 으로 &lt;a href=&quot;qabstractbutton#autoRepeat-prop&quot;&gt;자동 반복이&lt;/a&gt; 가능.</target>
        </trans-unit>
        <trans-unit id="2fae843f33ee3535ba56b0fe2ee7b47373345788" translate="yes" xml:space="preserve">
          <source>The slots manipulating the property editor's state are the &lt;a href=&quot;qdesignerpropertyeditorinterface#setObject&quot;&gt;setObject&lt;/a&gt;() slot that you can use to change the currently selected object in</source>
          <target state="translated">프로퍼티 에디터의 상태를 조작하는 슬롯은 &lt;a href=&quot;qdesignerpropertyeditorinterface#setObject&quot;&gt;setObject입니다.&lt;/a&gt; 슬롯은 현재 선택된 객체를 변경하는 데 사용할 수 () 슬롯입니다.</target>
        </trans-unit>
        <trans-unit id="dd92a0c591599f092301af7a3bab2873e8032835" translate="yes" xml:space="preserve">
          <source>The slowest, but easiest way to use is to use the control's full name, e.g.</source>
          <target state="translated">가장 느리지 만 사용하기 쉬운 방법은 컨트롤의 전체 이름을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f11ae52320e75a90400ecdb4a42d808f86aaf3cb" translate="yes" xml:space="preserve">
          <source>The small pixmap on the right side of a &lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;ClassicStyle&lt;/a&gt; or &lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;ModernStyle&lt;/a&gt; page header</source>
          <target state="translated">&lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;ClassicStyle&lt;/a&gt; 또는 &lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;ModernStyle&lt;/a&gt; 페이지 헤더 의 오른쪽에있는 작은 픽스맵</target>
        </trans-unit>
        <trans-unit id="1d29eac8000265ffba5b35bb43c23fea9600370e" translate="yes" xml:space="preserve">
          <source>The smaller of two natural steps that an abstract sliders provides and typically corresponds to the user pressing an arrow key.</source>
          <target state="translated">추상 슬라이더가 제공하는 두 개의 자연스런 단계 중 더 작으며 일반적으로 화살표 키를 누르는 사용자에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="3b0778096e8ff2853f61a020ceee905719818937" translate="yes" xml:space="preserve">
          <source>The smallest readable system font.</source>
          <target state="translated">읽을 수있는 가장 작은 시스템 글꼴입니다.</target>
        </trans-unit>
        <trans-unit id="99d3164a3af02e151a170d9c1f92ee54ba320958" translate="yes" xml:space="preserve">
          <source>The smallest rectangle that contains all the lines in the layout.</source>
          <target state="translated">레이아웃의 모든 선을 포함하는 가장 작은 사각형입니다.</target>
        </trans-unit>
        <trans-unit id="681bc4d0e8a69a56f70d793e7aa799bc61e6c065" translate="yes" xml:space="preserve">
          <source>The smallest value allowed by the dial.</source>
          <target state="translated">다이얼이 허용하는 가장 작은 값입니다.</target>
        </trans-unit>
        <trans-unit id="938bc37aadc1ec9453218c790ab20ffb2717c250" translate="yes" xml:space="preserve">
          <source>The smallest value of the box-and-whiskers item.</source>
          <target state="translated">상자와 수염 항목의 가장 작은 값입니다.</target>
        </trans-unit>
        <trans-unit id="9ab5423fbdcc1b65d48666bbb723cafdd3cdc139" translate="yes" xml:space="preserve">
          <source>The snap mode determines how the slider handle behaves with regards to the &lt;a href=&quot;qml-qtquick-controls2-slider#stepSize-prop&quot;&gt;stepSize&lt;/a&gt;.</source>
          <target state="translated">스냅 모드는 &lt;a href=&quot;qml-qtquick-controls2-slider#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; 와 관련하여 슬라이더 핸들의 작동 방식을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="ae00587cc0b73eeebfabc0c51631f112eb9df0b4" translate="yes" xml:space="preserve">
          <source>The snap mode determines how the slider handles behave with regards to the &lt;a href=&quot;qml-qtquick-controls2-rangeslider#stepSize-prop&quot;&gt;stepSize&lt;/a&gt;.</source>
          <target state="translated">슬라이더 핸들이 관련하여 어떻게 행동하는지 스냅 모드를 결정 &lt;a href=&quot;qml-qtquick-controls2-rangeslider#stepSize-prop&quot;&gt;스텝 사이즈&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78a36fb32b201bfa1d21835cc4d55c85f1e98fc2" translate="yes" xml:space="preserve">
          <source>The snap mode works with the &lt;a href=&quot;qml-qtquick-controls2-dial#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; to allow the handle to snap to certain points along the dial.</source>
          <target state="translated">스냅 모드는 &lt;a href=&quot;qml-qtquick-controls2-dial#stepSize-prop&quot;&gt;stepSize&lt;/a&gt; 와 함께 작동 하여 핸들이 다이얼을 따라 특정 지점에 스냅되도록합니다.</target>
        </trans-unit>
        <trans-unit id="0e7fbc1a277fdced34da81f0be9e23ac6db1ddb6" translate="yes" xml:space="preserve">
          <source>The snippet above shows how the inclusion of</source>
          <target state="translated">위의 스 니펫은</target>
        </trans-unit>
        <trans-unit id="0f81cb02e310776ad5a7befee764aab9bb22c323" translate="yes" xml:space="preserve">
          <source>The snippet below uses &lt;code&gt;searchAllStations&lt;/code&gt; with &lt;code&gt;SearchGetStationId&lt;/code&gt; to receive all the radio stations in the current band, and store them in a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;. The station Id is shown to the user and if the user presses a station, the radio is tuned to this station.</source>
          <target state="translated">아래 스 니펫은 &lt;code&gt;searchAllStations&lt;/code&gt; 와 함께 &lt;code&gt;SearchGetStationId&lt;/code&gt; 을 사용 하여 현재 밴드의 모든 라디오 방송국을 수신하고 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView에&lt;/a&gt; 저장합니다 . 스테이션 ID가 사용자에게 표시되고 사용자가 스테이션을 누르면 라디오가이 스테이션으로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="77e9938cffb7fcb65971e39b0e230c22c6ee76e7" translate="yes" xml:space="preserve">
          <source>The snippet code will replace any instances of &lt;code&gt;\\pi&lt;/code&gt; with &lt;code&gt;&amp;amp;Pi&lt;/code&gt;; in the HTML file, which will appear as the Greek &amp;Pi; symbol when viewed in browsers.</source>
          <target state="translated">스 니펫 코드는 &lt;code&gt;\\pi&lt;/code&gt; 의 모든 인스턴스 를 &lt;code&gt;&amp;amp;Pi&lt;/code&gt; ; HTML 파일에서 브라우저에서 볼 때 그리스어 &amp;Pi; 기호로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4f8784fc8b2fc883183b878724b0e17d03db4ff2" translate="yes" xml:space="preserve">
          <source>The socket descriptor is not available when &lt;a href=&quot;qabstractsocket&quot;&gt;QAbstractSocket&lt;/a&gt; is in &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;UnconnectedState&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qabstractsocket&quot;&gt;QAbstractSocket&lt;/a&gt; 이 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;UnconnectedState에&lt;/a&gt; 있으면 소켓 설명자를 사용할 수 없습니다. .</target>
        </trans-unit>
        <trans-unit id="dafe633df5228181ef9b055d9e6286a2f4b96bd6" translate="yes" xml:space="preserve">
          <source>The socket descriptor is not available when &lt;a href=&quot;qlocalsocket&quot;&gt;QLocalSocket&lt;/a&gt; is in &lt;a href=&quot;qlocalsocket#LocalSocketState-enum&quot;&gt;UnconnectedState&lt;/a&gt;. The type of the descriptor depends on the platform:</source>
          <target state="translated">&lt;a href=&quot;qlocalsocket&quot;&gt;QLocalSocket&lt;/a&gt; 이 &lt;a href=&quot;qlocalsocket#LocalSocketState-enum&quot;&gt;UnconnectedState에&lt;/a&gt; 있으면 소켓 설명자를 사용할 수 없습니다 . 디스크립터의 유형은 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e0a9430debc15fd585c6b3e76e07b949d11eeddd" translate="yes" xml:space="preserve">
          <source>The socket emits the &lt;a href=&quot;qiodevice#bytesWritten&quot;&gt;bytesWritten&lt;/a&gt;() signal every time a datagram is written to the network. If you just want to send datagrams, you don't need to call &lt;a href=&quot;qabstractsocket#bind&quot;&gt;bind&lt;/a&gt;().</source>
          <target state="translated">소켓은 데이터 그램이 네트워크에 기록 될 때마다 &lt;a href=&quot;qiodevice#bytesWritten&quot;&gt;bytesWritten&lt;/a&gt; () 신호를 방출합니다 . 데이터 그램 만 보내려면 &lt;a href=&quot;qabstractsocket#bind&quot;&gt;bind&lt;/a&gt; () 를 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f3f9b9d63ec16fd6151a53e39aa8372eb6ccfa8e" translate="yes" xml:space="preserve">
          <source>The socket first enters &lt;a href=&quot;qbluetoothsocket#SocketState-enum&quot;&gt;ConnectingState&lt;/a&gt; and attempts to connect to the device providing</source>
          <target state="translated">소켓은 먼저 &lt;a href=&quot;qbluetoothsocket#SocketState-enum&quot;&gt;ConnectingState에&lt;/a&gt; 들어갑니다 제공하는 장치에 연결을 시도합니다</target>
        </trans-unit>
        <trans-unit id="0a5d8a9174a7bb759c63b4b9f40114e40bfb2bb9" translate="yes" xml:space="preserve">
          <source>The socket first enters &lt;a href=&quot;qbluetoothsocket#SocketState-enum&quot;&gt;ConnectingState&lt;/a&gt;, and attempts to connect to</source>
          <target state="translated">소켓은 먼저 &lt;a href=&quot;qbluetoothsocket#SocketState-enum&quot;&gt;ConnectingState에&lt;/a&gt; 들어갑니다 에 을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="fb6dc14ad06e98c64ed5e017d5f819e7ba0668ac" translate="yes" xml:space="preserve">
          <source>The socket has started establishing a connection.</source>
          <target state="translated">소켓이 연결을 시작했습니다.</target>
        </trans-unit>
        <trans-unit id="e1479cd71146eb19e5796e62baee95f1f6d040d3" translate="yes" xml:space="preserve">
          <source>The socket identifier is passed in the</source>
          <target state="translated">소켓 식별자는</target>
        </trans-unit>
        <trans-unit id="dd1979af0d8876c49b5162265ab024810cbb584b" translate="yes" xml:space="preserve">
          <source>The socket is a client-side SSL socket. It is either alreayd encrypted, or it is in the SSL handshake phase (see &lt;a href=&quot;qsslsocket#isEncrypted&quot;&gt;QSslSocket::isEncrypted&lt;/a&gt;()).</source>
          <target state="translated">소켓은 클라이언트 측 SSL 소켓입니다. 이미 암호화되었거나 SSL 핸드 셰이크 단계에 있습니다 ( &lt;a href=&quot;qsslsocket#isEncrypted&quot;&gt;QSslSocket :: isEncrypted&lt;/a&gt; 참조). () 참조).</target>
        </trans-unit>
        <trans-unit id="c885d003d1fc8042223138bd847da51b73b99793" translate="yes" xml:space="preserve">
          <source>The socket is a server-side SSL socket. It is either already encrypted, or it is in the SSL handshake phase (see &lt;a href=&quot;qsslsocket#isEncrypted&quot;&gt;QSslSocket::isEncrypted&lt;/a&gt;()).</source>
          <target state="translated">소켓은 서버 측 SSL 소켓입니다. 이미 암호화되었거나 SSL 핸드 쉐이크 단계에 있습니다 ( &lt;a href=&quot;qsslsocket#isEncrypted&quot;&gt;QSslSocket :: isEncrypted&lt;/a&gt; () 참조).</target>
        </trans-unit>
        <trans-unit id="47ebe5371eb6aed9a23242e3dd7ba7b4467ae5d3" translate="yes" xml:space="preserve">
          <source>The socket is about to close (data may still be waiting to be written).</source>
          <target state="translated">소켓이 닫히려고합니다 (데이터 쓰기가 아직 대기 중일 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="fefad64ade0b569409ed87bc90fb23280dc4340d" translate="yes" xml:space="preserve">
          <source>The socket is assumed to be in listening state.</source>
          <target state="translated">소켓이 청취 상태 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="86529eb89e6225da9a2aeb3bfb757249d00a7cee" translate="yes" xml:space="preserve">
          <source>The socket is bound to an address and port.</source>
          <target state="translated">소켓은 주소와 포트에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="8580df2fbaa8765c746386781da983038a36ec6f" translate="yes" xml:space="preserve">
          <source>The socket is created as a child of the server, which means that it is automatically deleted when the &lt;a href=&quot;qlocalserver&quot;&gt;QLocalServer&lt;/a&gt; object is destroyed. It is still a good idea to delete the object explicitly when you are done with it, to avoid wasting memory.</source>
          <target state="translated">소켓은 서버의 하위로 작성되므로 &lt;a href=&quot;qlocalserver&quot;&gt;QLocalServer&lt;/a&gt; 오브젝트가 삭제되면 자동으로 삭제됩니다 . 메모리 낭비를 피하기 위해 작업을 마쳤을 때 개체를 명시 적으로 삭제하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b5652264bf569a83d4c3f178591ce4a8574d649d" translate="yes" xml:space="preserve">
          <source>The socket is created as a child of the server, which means that it is automatically deleted when the &lt;a href=&quot;qsctpserver&quot;&gt;QSctpServer&lt;/a&gt; object is destroyed. It is still a good idea to delete the object explicitly when you are done with it, to avoid wasting memory.</source>
          <target state="translated">소켓은 서버의 하위로 작성되므로 &lt;a href=&quot;qsctpserver&quot;&gt;QSctpServer&lt;/a&gt; 오브젝트가 삭제되면 자동으로 삭제됩니다 . 메모리 낭비를 피하기 위해 작업을 마쳤을 때 개체를 명시 적으로 삭제하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="04aa93b859a27e5f288c44a4227b8e4579d32d8e" translate="yes" xml:space="preserve">
          <source>The socket is created as a child of the server, which means that it is automatically deleted when the &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; object is destroyed. It is still a good idea to delete the object explicitly when you are done with it, to avoid wasting memory.</source>
          <target state="translated">소켓은 서버의 하위로 작성되므로 &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; 오브젝트가 삭제되면 소켓이 자동으로 삭제됩니다 . 메모리 낭비를 피하기 위해 작업을 마쳤을 때 개체를 명시 적으로 삭제하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="108c8f0a47315a3d42394e6a5e156159fa1c5e8c" translate="yes" xml:space="preserve">
          <source>The socket is not connected.</source>
          <target state="translated">소켓이 연결되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="781f185451015c13ca53edc0b479c7085b79dd77" translate="yes" xml:space="preserve">
          <source>The socket is opened in the given</source>
          <target state="translated">주어진 소켓이 열린다</target>
        </trans-unit>
        <trans-unit id="839a9ae9c141195ccc73e559b49905d716bb0483" translate="yes" xml:space="preserve">
          <source>The socket is performing a host name lookup.</source>
          <target state="translated">소켓이 호스트 이름 조회를 수행하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="4169f3c1b57c6d132c184a3da818386f57f98400" translate="yes" xml:space="preserve">
          <source>The socket is unencrypted. Its behavior is identical to &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;.</source>
          <target state="translated">소켓이 암호화되지 않았습니다. 동작은 &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3143f2371bc008731b5fab8cde8fc9ebea2c67ff" translate="yes" xml:space="preserve">
          <source>The socket is using a proxy, and the proxy requires authentication.</source>
          <target state="translated">소켓이 프록시를 사용 중이며 프록시에 인증이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0d35341ffc0350d66f3f5c9f51f1c66daba43ede" translate="yes" xml:space="preserve">
          <source>The socket operation failed because the application lacked the required privileges.</source>
          <target state="translated">응용 프로그램에 필요한 권한이 없기 때문에 소켓 조작에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="8fc3bb6c8e9419a39f2be47f3609245d4e3a73ce" translate="yes" xml:space="preserve">
          <source>The socket operation timed out.</source>
          <target state="translated">소켓 작동 시간이 초과되었습니다.</target>
        </trans-unit>
        <trans-unit id="339a98104212173ffe06092d924fc091a0e0f621" translate="yes" xml:space="preserve">
          <source>The socket's cryptographic cipher suite can be customized before the handshake phase with &lt;a href=&quot;qsslconfiguration#setCiphers&quot;&gt;QSslConfiguration::setCiphers&lt;/a&gt;() and QSslConfiguration::setDefaultCiphers().</source>
          <target state="translated">&lt;a href=&quot;qsslconfiguration#setCiphers&quot;&gt;QSslConfiguration :: setCiphers&lt;/a&gt; () 및 QSslConfiguration :: setDefaultCiphers () 를 사용하여 핸드 쉐이크 단계 전에 소켓의 암호화 암호 스위트를 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61d52f882f08a7911d7ae394e82e5d8069eddd93" translate="yes" xml:space="preserve">
          <source>The socket's local certificate and private key can be customized before the handshake phase with &lt;a href=&quot;qsslsocket#setLocalCertificate&quot;&gt;setLocalCertificate&lt;/a&gt;() and &lt;a href=&quot;qsslsocket#setPrivateKey&quot;&gt;setPrivateKey&lt;/a&gt;().</source>
          <target state="translated">소켓의 로컬 인증서 및 개인 키는 &lt;a href=&quot;qsslsocket#setLocalCertificate&quot;&gt;setLocalCertificate&lt;/a&gt; () 및 &lt;a href=&quot;qsslsocket#setPrivateKey&quot;&gt;setPrivateKey&lt;/a&gt; ()를 사용 하여 핸드 쉐이크 단계 전에 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ea721008d9cc9520af1a4ca910cba3bea9ddc7a" translate="yes" xml:space="preserve">
          <source>The socket's private key is set to the constructed key. The private key and the local &lt;a href=&quot;qsslcertificate&quot;&gt;certificate&lt;/a&gt; are used by clients and servers that must prove their identity to SSL peers.</source>
          <target state="translated">소켓의 개인 키는 생성 된 키로 설정됩니다. 개인 키와 로컬 &lt;a href=&quot;qsslcertificate&quot;&gt;인증서&lt;/a&gt; 는 SSL 피어에 대한 신원을 증명해야하는 클라이언트와 서버에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4bfb8eb926f5ccc8e8b62ea0149772dc9f473d52" translate="yes" xml:space="preserve">
          <source>The soft shadow is created by blurring the image live using a gaussian blur. Performing blur live is a costly operation. Fullscreen gaussian blur with even a moderate number of samples will only run at 60 fps on highend graphics hardware.</source>
          <target state="translated">부드러운 그림자는 가우시안 블러를 사용하여 이미지를 실시간으로 흐리게 만듭니다. 블러 라이브를 수행하는 것은 비용이 많이 드는 작업입니다. 적당한 수의 샘플이 포함 된 전체 화면 가우시안 블러는 고급 그래픽 하드웨어에서 60fps로만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="8c9e14e28c70b135bf862f1dade1f50ef0f99c79" translate="yes" xml:space="preserve">
          <source>The software backend exposes its &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; and saves and restores before and after invoking &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;(). Therefore reporting any changed states from here is not necessary.</source>
          <target state="translated">소프트웨어 백엔드는 &lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; 노출하고 &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt; ()를 호출하기 전후에 저장하고 복원 합니다. 따라서 여기에서 변경된 상태를보고 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="07aca885369650a65cbe7836047ba5073635eea3" translate="yes" xml:space="preserve">
          <source>The sole purpose of this function is to provide a means of fine tuning &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;'s memory usage. In general, you will rarely ever need to call this function.</source>
          <target state="translated">이 함수의 유일한 목적은 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 의 메모리 사용량 을 미세 조정하는 방법을 제공하는 것입니다. 일반적으로이 함수를 호출 할 필요는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="c1cc57628c16f4b787531b930459abbf5af0d128" translate="yes" xml:space="preserve">
          <source>The sole purpose of this function is to provide a means of fine tuning &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;'s memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the byte array, call &lt;a href=&quot;qbytearray#resize&quot;&gt;resize&lt;/a&gt;().</source>
          <target state="translated">이 함수의 유일한 목적은 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 의 메모리 사용량 을 미세 조정하는 방법을 제공하는 것입니다. 일반적으로이 함수를 호출 할 필요는 거의 없습니다. 바이트 배열의 크기를 변경하려면 &lt;a href=&quot;qbytearray#resize&quot;&gt;resize&lt;/a&gt; ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea9183e0ad2af83a47e7cd7f8e0f27927fdbc1b0" translate="yes" xml:space="preserve">
          <source>The sole purpose of this function is to provide a means of fine tuning &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many bytes are in the byte array, call &lt;a href=&quot;qbytearray#size&quot;&gt;size&lt;/a&gt;().</source>
          <target state="translated">이 함수의 유일한 목적은 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 의 메모리 사용량 을 미세 조정하는 방법을 제공하는 것입니다. 일반적으로이 함수를 호출 할 필요는 거의 없습니다. 바이트 배열에 몇 바이트가 있는지 알고 싶으면 &lt;a href=&quot;qbytearray#size&quot;&gt;size&lt;/a&gt; ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce202e784757206dced4e72af009a0e0b59addd9" translate="yes" xml:space="preserve">
          <source>The sole purpose of this function is to provide a means of fine tuning &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;'s memory usage. In general, you will rarely ever need to call this function.</source>
          <target state="translated">이 기능의 유일한 목적은 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; 의 메모리 사용량 을 미세 조정하는 방법을 제공하는 것입니다. 일반적으로이 함수를 호출 할 필요는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="8ceaa48ec5cecd0c2a31d385fc4eaa693dc2129a" translate="yes" xml:space="preserve">
          <source>The sole purpose of this function is to provide a means of fine tuning &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the hash, call &lt;a href=&quot;qhash#size&quot;&gt;size&lt;/a&gt;().</source>
          <target state="translated">이 기능의 유일한 목적은 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; 의 메모리 사용량 을 미세 조정하는 방법을 제공하는 것입니다. 일반적으로이 함수를 호출 할 필요는 거의 없습니다. 해시에 몇 개의 항목이 있는지 알고 싶다면 &lt;a href=&quot;qhash#size&quot;&gt;size&lt;/a&gt; ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa4ee2dbbd2aa385660ae3a5a433679d0c569526" translate="yes" xml:space="preserve">
          <source>The sole purpose of this function is to provide a means of fine tuning &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;'s memory usage. In general, you will rarely ever need to call this function.</source>
          <target state="translated">이 기능의 유일한 목적은 &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; 의 메모리 사용량 을 미세 조정하는 방법을 제공하는 것입니다. 일반적으로이 함수를 호출 할 필요는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="cea278b7c899a7b75b0adcf07d94b268de4b8959" translate="yes" xml:space="preserve">
          <source>The sole purpose of this function is to provide a means of fine tuning &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt;'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the set, call &lt;a href=&quot;qset#size&quot;&gt;size&lt;/a&gt;().</source>
          <target state="translated">이 기능의 유일한 목적은 &lt;a href=&quot;qset&quot;&gt;QSet&lt;/a&gt; 의 메모리 사용량 을 미세 조정하는 방법을 제공하는 것입니다. 일반적으로이 함수를 호출 할 필요는 거의 없습니다. 세트에 몇 개의 항목이 있는지 알고 싶으면 &lt;a href=&quot;qset#size&quot;&gt;크기&lt;/a&gt; ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="4bfd4ad7a7c02d0a22c98605702bb6a8b3948c06" translate="yes" xml:space="preserve">
          <source>The sole purpose of this function is to provide a means of fine tuning &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;'s memory usage. In general, you will rarely ever need to call this function.</source>
          <target state="translated">이 함수의 유일한 목적은 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 의 메모리 사용량 을 미세 조정하는 방법을 제공하는 것입니다. 일반적으로이 함수를 호출 할 필요는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="b17fb6ce0ed5b6e84b4c4bdd953a5be1d17bdb21" translate="yes" xml:space="preserve">
          <source>The sole purpose of this function is to provide a means of fine tuning &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;'s memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the string, call &lt;a href=&quot;qstring#resize&quot;&gt;resize&lt;/a&gt;().</source>
          <target state="translated">이 함수의 유일한 목적은 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 의 메모리 사용량 을 미세 조정하는 방법을 제공하는 것입니다. 일반적으로이 함수를 호출 할 필요는 거의 없습니다. 문자열의 크기를 변경하려면 &lt;a href=&quot;qstring#resize&quot;&gt;resize&lt;/a&gt; ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="1a892d010f9dadd2d60a1e6e32071cf1e7297a99" translate="yes" xml:space="preserve">
          <source>The sole purpose of this function is to provide a means of fine tuning &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many characters are in the string, call &lt;a href=&quot;qstring#size&quot;&gt;size&lt;/a&gt;().</source>
          <target state="translated">이 함수의 유일한 목적은 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 의 메모리 사용량 을 미세 조정하는 방법을 제공하는 것입니다. 일반적으로이 함수를 호출 할 필요는 거의 없습니다. 문자열에 몇 개의 문자가 있는지 알고 싶으면 &lt;a href=&quot;qstring#size&quot;&gt;size&lt;/a&gt; ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee41b9ce0b4ad01ec1aee52c1f7a49be9d633d88" translate="yes" xml:space="preserve">
          <source>The sole purpose of this function is to provide a means of fine tuning &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt;'s memory usage. In general, you will rarely ever need to call this function.</source>
          <target state="translated">이 기능의 유일한 목적은 &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt; 의 메모리 사용량 을 미세 조정하는 방법을 제공하는 것입니다. 일반적으로이 함수를 호출 할 필요는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="e7dcf050d8e45690337f0094595a41481d73c0f1" translate="yes" xml:space="preserve">
          <source>The sole purpose of this function is to provide a means of fine tuning &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt;'s memory usage. In general, you will rarely ever need to call this function. If you want to change the size of the array, call &lt;a href=&quot;qvarlengtharray#resize&quot;&gt;resize&lt;/a&gt;().</source>
          <target state="translated">이 기능의 유일한 목적은 &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt; 의 메모리 사용량 을 미세 조정하는 방법을 제공하는 것입니다. 일반적으로이 함수를 호출 할 필요는 거의 없습니다. 배열의 크기를 변경하려면 &lt;a href=&quot;qvarlengtharray#resize&quot;&gt;resize&lt;/a&gt; ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="30725e9e2ac89f43ee987fe96a0293ec6bd47b43" translate="yes" xml:space="preserve">
          <source>The sole purpose of this function is to provide a means of fine tuning &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt;'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the array, call &lt;a href=&quot;qvarlengtharray#size&quot;&gt;size&lt;/a&gt;().</source>
          <target state="translated">이 기능의 유일한 목적은 &lt;a href=&quot;qvarlengtharray&quot;&gt;QVarLengthArray&lt;/a&gt; 의 메모리 사용량 을 미세 조정하는 방법을 제공하는 것입니다. 일반적으로이 함수를 호출 할 필요는 거의 없습니다. 배열에 몇 개의 항목이 있는지 알고 싶으면 &lt;a href=&quot;qvarlengtharray#size&quot;&gt;size&lt;/a&gt; ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="28e72d029a63fbde628e5aa3dd3f958692a4a371" translate="yes" xml:space="preserve">
          <source>The sole purpose of this function is to provide a means of fine tuning &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;'s memory usage. In general, you will rarely ever need to call this function.</source>
          <target state="translated">이 기능의 유일한 목적은 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 메모리 사용량 을 미세 조정하는 수단을 제공하는 것입니다. 일반적으로이 함수를 호출 할 필요는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="fae35706e24f840f79ff304e9b3d3835232b59e0" translate="yes" xml:space="preserve">
          <source>The sole purpose of this function is to provide a means of fine tuning &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt;'s memory usage. In general, you will rarely ever need to call this function. If you want to know how many items are in the vector, call &lt;a href=&quot;qvector#size&quot;&gt;size&lt;/a&gt;().</source>
          <target state="translated">이 기능의 유일한 목적은 &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 메모리 사용량 을 미세 조정하는 수단을 제공하는 것입니다. 일반적으로이 함수를 호출 할 필요는 거의 없습니다. 벡터에 몇 개의 항목이 있는지 알고 싶으면 &lt;a href=&quot;qvector#size&quot;&gt;size&lt;/a&gt; ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e395a1e4ad7863486333f50146878b426b5e08c" translate="yes" xml:space="preserve">
          <source>The solution would be to have some means of identifying the first occurrence of</source>
          <target state="translated">해결책은 첫 번째 발생을 식별하는 몇 가지 수단을 갖는 것입니다.</target>
        </trans-unit>
        <trans-unit id="10afda9808846e7adb11a72975dda16fa6dfa1ec" translate="yes" xml:space="preserve">
          <source>The sort indicator can be styled using the &lt;a href=&quot;#up-arrow-sub&quot;&gt;::up-arrow&lt;/a&gt; and the &lt;a href=&quot;#down-arrow-sub&quot;&gt;::down-arrow&lt;/a&gt; Sub-control.</source>
          <target state="translated">정렬 표시기는 &lt;a href=&quot;#up-arrow-sub&quot;&gt;:: 위쪽 화살표&lt;/a&gt; 및 &lt;a href=&quot;#down-arrow-sub&quot;&gt;:: 아래쪽 화살표&lt;/a&gt; 하위 제어를 사용하여 스타일을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2083f58446cd80d8a0c1141e7b64bff8dbe0b186" translate="yes" xml:space="preserve">
          <source>The sort indicator can be styled using the &lt;a href=&quot;stylesheet-reference#up-arrow-sub&quot;&gt;::up-arrow&lt;/a&gt; and the &lt;a href=&quot;stylesheet-reference#down-arrow-sub&quot;&gt;::down-arrow&lt;/a&gt; Sub-control.</source>
          <target state="translated">정렬 표시기는 &lt;a href=&quot;stylesheet-reference#up-arrow-sub&quot;&gt;:: up-arrow&lt;/a&gt; 및 &lt;a href=&quot;stylesheet-reference#down-arrow-sub&quot;&gt;:: down-arrow&lt;/a&gt; 하위 컨트롤을 사용하여 스타일을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da47af154e03b8d58bdc4c32ddd2c48e22917c3e" translate="yes" xml:space="preserve">
          <source>The sort order (i.e ascending or descending order) of the model is determined dynamically by inspecting the contents of the model.</source>
          <target state="translated">모델의 정렬 순서 (즉, 오름차순 또는 내림차순)는 모델의 내용을 검사하여 동적으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="f411b633ec2927852a33d1caa771b3f519490ddf" translate="yes" xml:space="preserve">
          <source>The sorting in</source>
          <target state="translated">정렬</target>
        </trans-unit>
        <trans-unit id="49b1ee9590e5bb1dcba2cb9bf8e8580ff7bfb648" translate="yes" xml:space="preserve">
          <source>The source URL of the media.</source>
          <target state="translated">미디어의 소스 URL입니다.</target>
        </trans-unit>
        <trans-unit id="78f1622737932937b3eacfadc3bd9def1d6624fe" translate="yes" xml:space="preserve">
          <source>The source URL to the menu item's icon. Undefined if it has no icon.</source>
          <target state="translated">메뉴 항목 아이콘의 소스 URL입니다. 아이콘이 없으면 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31bbc093f07116fe361b53fbda151febdacf0097" translate="yes" xml:space="preserve">
          <source>The source and destination colors are inverted and then multiplied. Screening a color with white produces white, whereas screening a color with black leaves the color unchanged.</source>
          <target state="translated">소스 및 대상 색상이 반전 된 다음 곱해집니다. 흰색으로 색상을 선별하면 흰색이 생성되고 검정색으로 색상을 선별하면 색상이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e26d29d55ba51281fbe87d45e604aa35f5f8a72" translate="yes" xml:space="preserve">
          <source>The source and header file of the custom widget can be shared between the application and</source>
          <target state="translated">사용자 정의 위젯의 소스 및 헤더 파일은 애플리케이션과</target>
        </trans-unit>
        <trans-unit id="8741188475f8882dfff846130bc887c86fe0da30" translate="yes" xml:space="preserve">
          <source>The source and target widgets can be found with &lt;a href=&quot;qdrag#source&quot;&gt;source&lt;/a&gt;() and &lt;a href=&quot;qdrag#target&quot;&gt;target&lt;/a&gt;(). These functions are often used to determine whether drag and drop operations started and finished at the same widget, so that special behavior can be implemented.</source>
          <target state="translated">소스 및 대상 위젯은 &lt;a href=&quot;qdrag#source&quot;&gt;소스&lt;/a&gt; () 및 &lt;a href=&quot;qdrag#target&quot;&gt;대상&lt;/a&gt; () 으로 찾을 수 있습니다 . 이러한 기능은 종종 동일한 위젯에서 끌어서 놓기 조작이 시작되고 완료되었는지 판별하여 특수한 동작을 구현할 수 있도록하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="75f9a011e5a76ccea8e359590ee591cad40e1a45" translate="yes" xml:space="preserve">
          <source>The source being monitored does not need to be active.</source>
          <target state="translated">모니터링중인 소스를 활성화 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7c5fb23bfc48f564e8298fcb6c89d56c3153fa9c" translate="yes" xml:space="preserve">
          <source>The source can be used to distinguish between events that come from a mouse with a physical wheel and events that are generated by some other means, such as a flick gesture on a touchpad.</source>
          <target state="translated">이 소스는 물리적 휠이있는 마우스에서 발생하는 이벤트와 터치 패드의 제스처 제스처와 같은 다른 방법으로 생성 된 이벤트를 구별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79cdf6a06196181f1764d8124d7a49ca3edd4474" translate="yes" xml:space="preserve">
          <source>The source code for a custom widget is not available, or the user interface designers are unable to use the widget for non-technical reasons.</source>
          <target state="translated">사용자 정의 위젯의 소스 코드를 사용할 수 없거나 사용자 인터페이스 디자이너가 기술적이지 않은 이유로 위젯을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e460d44551b3d6f2373fe9db6e30a9bc1f1de29" translate="yes" xml:space="preserve">
          <source>The source code in the original file has not changed</source>
          <target state="translated">원본 파일의 소스 코드가 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="f7b98ec13449821dfb2ea3f026695bd34a606afa" translate="yes" xml:space="preserve">
          <source>The source code of the example files can be found in the current directory.</source>
          <target state="translated">예제 파일의 소스 코드는 현재 디렉토리에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b736b85533672431326676d2a151df5de509ca30" translate="yes" xml:space="preserve">
          <source>The source code returned from &lt;a href=&quot;qsgmaterialshader#vertexShader&quot;&gt;vertexShader&lt;/a&gt;() is used to control what the material does with the vertiex data that comes in from the geometry. The source code returned from the &lt;a href=&quot;qsgmaterialshader#fragmentShader&quot;&gt;fragmentShader&lt;/a&gt;() is used to control what how the material should fill each individual pixel in the geometry. The vertex and fragment source code is queried once during initialization, changing what is returned from these functions later will not have any effect.</source>
          <target state="translated">&lt;a href=&quot;qsgmaterialshader#vertexShader&quot;&gt;vertexShader&lt;/a&gt; () 에서 반환 된 소스 코드 는 형상에서 나오는 vertiex 데이터로 재료가 수행하는 작업을 제어하는 ​​데 사용됩니다. &lt;a href=&quot;qsgmaterialshader#fragmentShader&quot;&gt;fragmentShader&lt;/a&gt; () 에서 반환 된 소스 코드 는 재료가 형상의 각 개별 픽셀을 채우는 방법을 제어하는 ​​데 사용됩니다. 버텍스 및 프래그먼트 소스 코드는 초기화 중에 한 번 쿼리되며,이 함수에서 반환 된 내용을 변경해도 아무런 영향이 없습니다.</target>
        </trans-unit>
        <trans-unit id="707bcd26486a84e87fa3e28e31cc25c649a345cd" translate="yes" xml:space="preserve">
          <source>The source device can only be set once and must be set before calling &lt;a href=&quot;qnmeapositioninfosource#startUpdates&quot;&gt;startUpdates&lt;/a&gt;() or &lt;a href=&quot;qnmeapositioninfosource#requestUpdate&quot;&gt;requestUpdate&lt;/a&gt;().</source>
          <target state="translated">소스 장치는 한 번만 설정할 수 있으며 &lt;a href=&quot;qnmeapositioninfosource#startUpdates&quot;&gt;startUpdates&lt;/a&gt; () 또는 &lt;a href=&quot;qnmeapositioninfosource#requestUpdate&quot;&gt;requestUpdate&lt;/a&gt; () 를 호출하기 전에 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6b2bca5553dfc43be75f1aa8f3abd15083b1ea3b" translate="yes" xml:space="preserve">
          <source>The source device for the &lt;a href=&quot;qt3dinput-qabstractaxisinput&quot;&gt;QAbstractAxisInput&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3dinput-qabstractaxisinput&quot;&gt;QAbstractAxisInput&lt;/a&gt; 의 소스 디바이스입니다 .</target>
        </trans-unit>
        <trans-unit id="494bff1e2191272e07da567f127cfcbb23124b50" translate="yes" xml:space="preserve">
          <source>The source file is closed before it is copied.</source>
          <target state="translated">소스 파일은 복사되기 전에 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="fde0df0d102eaef4f741a50135ff55c8b9c73c9f" translate="yes" xml:space="preserve">
          <source>The source image may not be loaded instantaneously, depending on its original location. Loading progress can be monitored with the &lt;a href=&quot;qml-qtquick-borderimage#progress-prop&quot;&gt;progress&lt;/a&gt; property.</source>
          <target state="translated">원본 이미지는 원래 위치에 따라 즉시로드되지 않을 수 있습니다. 로딩 속성 은 &lt;a href=&quot;qml-qtquick-borderimage#progress-prop&quot;&gt;progress&lt;/a&gt; 속성 으로 모니터링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78a884c05d5363f7a7c8fc5d9717e6bbee2dad2b" translate="yes" xml:space="preserve">
          <source>The source image to be used.</source>
          <target state="translated">사용될 소스 이미지.</target>
        </trans-unit>
        <trans-unit id="54ef6fee861b09cc6b2b13e12e8c33c381a151ec" translate="yes" xml:space="preserve">
          <source>The source image to generate the turbulence from. It will be scaled to the size of the element, so equal or larger sizes will give better results. Tweaking this image is the only way to tweak behavior such as where vortices are or how many exist.</source>
          <target state="translated">난기류를 생성하는 소스 이미지입니다. 요소의 크기에 맞게 조정되므로 크기가 같거나 크면 더 나은 결과를 얻을 수 있습니다. 이 이미지를 조정하는 것은 소용돌이가있는 위치 또는 존재하는 수와 같은 동작을 조정하는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ca7296f4bd50f4bc2aa87cad9f2001aec0582dc4" translate="yes" xml:space="preserve">
          <source>The source image.</source>
          <target state="translated">소스 이미지</target>
        </trans-unit>
        <trans-unit id="63f2a0226e86633c4d29b4f3e812a67531ac1a8f" translate="yes" xml:space="preserve">
          <source>The source is loaded and ready for play.</source>
          <target state="translated">소스가로드되어 재생할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="6c0ee8dfde25a0416bb19015fe13f4aca7cde3f9" translate="yes" xml:space="preserve">
          <source>The source of NMEA data is set with &lt;a href=&quot;qnmeapositioninfosource#setDevice&quot;&gt;setDevice&lt;/a&gt;().</source>
          <target state="translated">NMEA 데이터의 소스는 &lt;a href=&quot;qnmeapositioninfosource#setDevice&quot;&gt;setDevice&lt;/a&gt; ()로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="92229018788dbcb06804d2e3a3a0d155273d7a73" translate="yes" xml:space="preserve">
          <source>The source of the Bodymovin asset that &lt;a href=&quot;qml-qt-labs-lottieqt-lottieanimation&quot;&gt;LottieAnimation&lt;/a&gt; plays.</source>
          <target state="translated">&lt;a href=&quot;qml-qt-labs-lottieqt-lottieanimation&quot;&gt;LottieAnimation이&lt;/a&gt; 재생 하는 Bodymovin 자산의 소스입니다 .</target>
        </trans-unit>
        <trans-unit id="d416e2ee59ec2e86daa375dec3a2d7a8a1c2a421" translate="yes" xml:space="preserve">
          <source>The source of the event is specified by</source>
          <target state="translated">이벤트의 소스는</target>
        </trans-unit>
        <trans-unit id="f4c8432dc7ca1de402b276422691e155e4f1738e" translate="yes" xml:space="preserve">
          <source>The source of the image is specified as a URL using the &lt;a href=&quot;qml-qtquick-image#source-prop&quot;&gt;source&lt;/a&gt; property. Images can be supplied in any of the standard image formats supported by Qt, including bitmap formats such as PNG and JPEG, and vector graphics formats such as SVG. If you need to display animated images, use &lt;a href=&quot;qml-qtquick-animatedsprite&quot;&gt;AnimatedSprite&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-animatedimage&quot;&gt;AnimatedImage&lt;/a&gt;.</source>
          <target state="translated">이미지의 &lt;a href=&quot;qml-qtquick-image#source-prop&quot;&gt;소스&lt;/a&gt; 는 source 속성을 사용하여 URL로 지정됩니다 . PNG 및 JPEG와 같은 비트 맵 형식과 SVG와 같은 벡터 그래픽 형식을 포함하여 Qt에서 지원하는 모든 표준 이미지 형식으로 이미지를 제공 할 수 있습니다. 애니메이션 이미지를 표시해야하는 경우 &lt;a href=&quot;qml-qtquick-animatedsprite&quot;&gt;AnimatedSprite&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-animatedimage&quot;&gt;AnimatedImage를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17ce0519910b424d94b6ed7181d80a431d9ea503" translate="yes" xml:space="preserve">
          <source>The source of the message is invalid; this is the source of a default-constructed &lt;a href=&quot;qopengldebugmessage&quot;&gt;QOpenGLDebugMessage&lt;/a&gt; object.</source>
          <target state="translated">메시지의 출처가 잘못되었습니다. 이것이 기본적으로 구성된 &lt;a href=&quot;qopengldebugmessage&quot;&gt;QOpenGLDebugMessage&lt;/a&gt; 객체 의 소스입니다 .</target>
        </trans-unit>
        <trans-unit id="883bcac21f490719fc84af9b1c3aabee56fa745f" translate="yes" xml:space="preserve">
          <source>The source pixel is blended on top of the destination, with the alpha of the source pixel reduced by the alpha of the destination pixel.</source>
          <target state="translated">소스 픽셀은 대상 위에 혼합되며 소스 픽셀의 알파는 대상 픽셀의 알파만큼 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="a472fa1642880a1e562041007cc3a25cffd2a6ce" translate="yes" xml:space="preserve">
          <source>The source rect contents will be transformed according to</source>
          <target state="translated">소스 rect 컨텐츠는 다음에 따라 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="c3bf8e964eb157494069beca241d4f6f7e2405a5" translate="yes" xml:space="preserve">
          <source>The source should be a relatively smooth black and white noise image, such as perlin noise. A default image will be used if none is provided.</source>
          <target state="translated">소스는 펄린 노이즈와 같이 비교적 부드러운 흑백 노이즈 이미지 여야합니다. 제공되지 않은 경우 기본 이미지가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="10523320d0ce68a76b327bdc5a1092484915aca3" translate="yes" xml:space="preserve">
          <source>The source should be relatively smooth black and white noise, such as perlin noise.</source>
          <target state="translated">소스는 펄린 노이즈와 같이 비교적 부드러운 흑백 노이즈 여야합니다.</target>
        </trans-unit>
        <trans-unit id="956c4599478eb95054fec0ea108d92ecf37b537e" translate="yes" xml:space="preserve">
          <source>The source state (parent) of this transition.</source>
          <target state="translated">이 전환의 소스 상태 (부모)입니다.</target>
        </trans-unit>
        <trans-unit id="38350bb983686d05e2be17f11216a706dc042eb4" translate="yes" xml:space="preserve">
          <source>The source, whose alpha is reduced with the inverse of the destination alpha, is merged with the destination, whose alpha is reduced by the inverse of the source alpha. CompositionMode_Xor is not the same as the bitwise Xor.</source>
          <target state="translated">대상 알파의 역수에 따라 알파가 감소 된 소스는 소스 알파의 역수에 의해 알파가 감소 된 대상과 병합됩니다. CompositionMode_Xor는 비트 Xor와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="78c07598e2d74a58a1ca75114306e8b14c69ab0e" translate="yes" xml:space="preserve">
          <source>The sourceAxisType property specifies how the accumulator treats the values from the source axis.</source>
          <target state="translated">sourceAxisType 속성은 누산기가 소스 축의 값을 처리하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d706c2a94be1186a7f3e86b8a5de3aed8a781e22" translate="yes" xml:space="preserve">
          <source>The sourceState() property has the source of the transition. The &lt;a href=&quot;qml-qtqml-statemachine-qabstracttransition#targetState-prop&quot;&gt;targetState&lt;/a&gt; and &lt;a href=&quot;qml-qtqml-statemachine-qabstracttransition#targetStates-prop&quot;&gt;targetStates&lt;/a&gt; properties return the target(s) of the transition.</source>
          <target state="translated">sourceState () 속성에는 전환 소스가 있습니다. &lt;a href=&quot;qml-qtqml-statemachine-qabstracttransition#targetState-prop&quot;&gt;targetState&lt;/a&gt; 및 &lt;a href=&quot;qml-qtqml-statemachine-qabstracttransition#targetStates-prop&quot;&gt;targetStates&lt;/a&gt; 특성은 전이의 타겟 (들)를 리턴한다.</target>
        </trans-unit>
        <trans-unit id="b8f23013f0600e6cbace8e98bae1b7a62d0ab009" translate="yes" xml:space="preserve">
          <source>The spacing an anchor will get depends on the type of anchor. For instance, anchors from the Right edge of one item to the Left edge of another (or vice versa) will use the default horizontal spacing. The same behaviour applies to Bottom to Top anchors, (but they will use the default vertical spacing). For all other anchor combinations, the spacing will be 0. All anchoring functions will follow this rule.</source>
          <target state="translated">앵커의 간격은 앵커 유형에 따라 다릅니다. 예를 들어 한 항목의 오른쪽 가장자리에서 다른 항목의 왼쪽 가장자리 (또는 그 반대)까지의 앵커는 기본 가로 간격을 사용합니다. 하단에서 상단 앵커에도 동일한 동작이 적용되지만 기본 세로 간격이 사용됩니다. 다른 모든 앵커 조합의 경우 간격은 0이됩니다. 모든 앵커 기능은이 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="c10f5e8c2dc5cd188522b37865bfbb402ebaac3b" translate="yes" xml:space="preserve">
          <source>The spacing between a check box indicator and its label.</source>
          <target state="translated">확인란 표시기와 레이블 사이의 간격입니다.</target>
        </trans-unit>
        <trans-unit id="55b27db2dc34131b12cee3fc0c86bc419acab57f" translate="yes" xml:space="preserve">
          <source>The spacing between a radio button indicator and its label.</source>
          <target state="translated">단일 선택 단추 표시기와 해당 레이블 사이의 간격입니다.</target>
        </trans-unit>
        <trans-unit id="8c52f530e67e06843ec4f7d42a370daddc1e1969" translate="yes" xml:space="preserve">
          <source>The spacing between indicator and label.</source>
          <target state="translated">표시기와 레이블 사이의 간격입니다.</target>
        </trans-unit>
        <trans-unit id="664c82750b0ecf5d892540c3e55bade3403b3de8" translate="yes" xml:space="preserve">
          <source>The spacing can also be set manually by using &lt;a href=&quot;qgraphicsanchor#spacing-prop&quot;&gt;QGraphicsAnchor::setSpacing&lt;/a&gt;() method.</source>
          <target state="translated">간격은 &lt;a href=&quot;qgraphicsanchor#spacing-prop&quot;&gt;QGraphicsAnchor :: setSpacing&lt;/a&gt; () 메소드를 사용하여 수동으로 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="784d2c560002766ac734875a1f860142b3db5c5a" translate="yes" xml:space="preserve">
          <source>The spacing is the amount in pixels left empty between adjacent items. The amount of spacing applied will be the same in the horizontal and vertical directions. The default spacing is 0.</source>
          <target state="translated">간격은 인접한 항목 사이에 비어있는 픽셀 단위의 양입니다. 적용되는 간격은 수평 및 수직 방향에서 동일합니다. 기본 간격은 0입니다.</target>
        </trans-unit>
        <trans-unit id="ceec7982eb2df20c19f1048d909c9880bf9a1212" translate="yes" xml:space="preserve">
          <source>The spacing is the amount in pixels left empty between adjacent items. The default spacing is 0.</source>
          <target state="translated">간격은 인접한 항목 사이에 비어있는 픽셀 단위의 양입니다. 기본 간격은 0입니다.</target>
        </trans-unit>
        <trans-unit id="370de26df7d1a105cd4ff2c75d73443eed46fd1c" translate="yes" xml:space="preserve">
          <source>The spacing of the items along the Path can be adjusted via a &lt;a href=&quot;qml-qtquick-pathpercent&quot;&gt;PathPercent&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-pathpercent&quot;&gt;PathPercent&lt;/a&gt; 객체 를 통해 Path를 따라 항목의 간격을 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5ed3130309f7cdfe02b22fb6a5a0d3f07ace008" translate="yes" xml:space="preserve">
          <source>The span of the slice in degrees. A full pie is 360 degrees, where 0 degrees is at 12 a'clock. Updated automatically once the slice is added to the series.</source>
          <target state="translated">슬라이스의 범위 (도)입니다. 전체 파이는 360도이며 0 도는 12시입니다. 슬라이스가 시리즈에 추가되면 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="8453bf4d2afac9a1ecd50e09a3b3ba6b96ef231f" translate="yes" xml:space="preserve">
          <source>The spatial constraint for a tap or long press gesture to be recognized, in addition to the constraint that the release must occur before &lt;a href=&quot;qml-qtquick-taphandler#longPressThreshold-prop&quot;&gt;longPressThreshold&lt;/a&gt; has elapsed. If these constraints are not satisfied, the &lt;a href=&quot;qml-qtquick-taphandler#tapped-signal&quot;&gt;tapped&lt;/a&gt; signal is not emitted, and &lt;a href=&quot;qml-qtquick-taphandler#tapCount-prop&quot;&gt;tapCount&lt;/a&gt; is not incremented. If the spatial constraint is violated, &lt;a href=&quot;qml-qtquick-taphandler#pressed-prop&quot;&gt;pressed&lt;/a&gt; transitions immediately from true to false, regardless of the time held.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-taphandler#longPressThreshold-prop&quot;&gt;longPressThreshold&lt;/a&gt; 가 경과 하기 전에 해제해야하는 제약 조건과 함께 탭 또는 길게 누르기 제스처에 대한 공간 제약 조건이 인식 됩니다. 이러한 제약 조건이 충족되지 않으면 &lt;a href=&quot;qml-qtquick-taphandler#tapped-signal&quot;&gt;탭된&lt;/a&gt; 신호가 방출 되지 않으며 &lt;a href=&quot;qml-qtquick-taphandler#tapCount-prop&quot;&gt;tapCount&lt;/a&gt; 가 증가하지 않습니다. 공간 제약 조건을 위반하면 &lt;a href=&quot;qml-qtquick-taphandler#pressed-prop&quot;&gt;누른&lt;/a&gt; 시간에 관계없이 눌림 상태가 즉시 참에서 거짓으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="efe69e1ce62c3bbab60676ae62b77d9ff94d320c" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;$$[...]&lt;/code&gt; operator can be used to access qmake properties:</source>
          <target state="translated">특별한 &lt;code&gt;$$[...]&lt;/code&gt; 연산자를 사용하여 qmake 속성에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7889037608bd11b3e854c28f9b9a352e6539a3b7" translate="yes" xml:space="preserve">
          <source>The special feature of this file is the &lt;code&gt;FORMS&lt;/code&gt; declaration that tells &lt;code&gt;qmake&lt;/code&gt; which files to process with &lt;code&gt;uic&lt;/code&gt;. In this case, the &lt;code&gt;calculatorform.ui&lt;/code&gt; file is used to create a &lt;code&gt;ui_calculatorform.h&lt;/code&gt; file that can be used by any file listed in the &lt;code&gt;SOURCES&lt;/code&gt; declaration.</source>
          <target state="translated">이 파일의 특징은 &lt;code&gt;uic&lt;/code&gt; 로 처리 할 파일을 &lt;code&gt;qmake&lt;/code&gt; 에 알려주 는 &lt;code&gt;FORMS&lt;/code&gt; 선언입니다 . 이 경우 &lt;code&gt;calculatorform.ui&lt;/code&gt; 파일은 &lt;code&gt;SOURCES&lt;/code&gt; 선언에 나열된 모든 파일에서 사용할 수 있는 &lt;code&gt;ui_calculatorform.h&lt;/code&gt; 파일 을 작성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e149f37dcc1e8110200a6e1043d7d8aaad0b1e6e" translate="yes" xml:space="preserve">
          <source>The specification does not clearly indicate what sorting order should be done for values of different types (it says sorting should not pay &quot;attention to the 3/5 bit splitting for major types&quot;). &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; makes the assumption that types should be sorted too. The numeric values of the &lt;a href=&quot;qcborvalue#Type-enum&quot;&gt;QCborValue::Type&lt;/a&gt; enumeration are in that order, with the exception of the extended types, which compare as their tagged equivalents.</source>
          <target state="translated">사양은 다른 유형의 값에 대해 어떤 정렬 순서를 수행해야하는지 명확하게 나타내지 않습니다 (정렬은 &quot;주요 유형의 3/5 비트 분할에주의&quot;하지 않아야 함). &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; 는 유형도 정렬해야한다는 가정을합니다. &lt;a href=&quot;qcborvalue#Type-enum&quot;&gt;QCborValue :: Type&lt;/a&gt; 열거 의 숫자 값은 태그가있는 동등 항목과 비교되는 확장 유형을 제외하고 순서대로 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="d7fe06eb8c84c95220ed0a7293cb933b3b76b6e1" translate="yes" xml:space="preserve">
          <source>The specifications discusses conformance further: &lt;a href=&quot;http://www.w3.org/TR/xquery/&quot;&gt;XQuery 1.0: An XML Query Language&lt;/a&gt;. W3C's &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; testing effort can be of interest as well, &lt;a href=&quot;http://www.w3.org/XML/Query/test-suite/&quot;&gt;XML Query Test Suite&lt;/a&gt;.</source>
          <target state="translated">사양에서는 적합성에 대해 자세히 설명합니다. &lt;a href=&quot;http://www.w3.org/TR/xquery/&quot;&gt;XQuery 1.0 : XML 쿼리 언어&lt;/a&gt; . W3C의 &lt;a href=&quot;xmlprocessing&quot;&gt;XQuery&lt;/a&gt; 테스트 노력도 흥미로울 수 있습니다 . &lt;a href=&quot;http://www.w3.org/XML/Query/test-suite/&quot;&gt;XML Query Test Suite&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e82277d3493b0b650f47f907c9957c194b29c5f" translate="yes" xml:space="preserve">
          <source>The specifications discusses conformance further: &lt;a href=&quot;http://www.w3.org/TR/xquery/&quot;&gt;XQuery 1.0: An XML Query Language&lt;/a&gt;. W3C's XQuery testing effort can be of interest as well, &lt;a href=&quot;http://www.w3.org/XML/Query/test-suite/&quot;&gt;XML Query Test Suite&lt;/a&gt;.</source>
          <target state="translated">이 사양은 &lt;a href=&quot;http://www.w3.org/TR/xquery/&quot;&gt;XQuery 1.0 : XML 쿼리 언어에 대한&lt;/a&gt; 추가 적합성에 대해 설명 합니다. W3C의 XQuery 테스트 노력은 &lt;a href=&quot;http://www.w3.org/XML/Query/test-suite/&quot;&gt;XML Query Test Suite&lt;/a&gt; 에도 관심이있다 .</target>
        </trans-unit>
        <trans-unit id="5249ead0cea582438ce306dee2ff065c9121394e" translate="yes" xml:space="preserve">
          <source>The specified</source>
          <target state="translated">지정된</target>
        </trans-unit>
        <trans-unit id="86839ebabf3538c8763e7d531596c634ccbc32aa" translate="yes" xml:space="preserve">
          <source>The specified FBO must be created in the context of the window or one that shares with it.</source>
          <target state="translated">지정된 FBO는 창의 컨텍스트 또는 공유 창의 컨텍스트에서 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="5e3d20809babb30e5e1b79aa4514e46282dfcef0" translate="yes" xml:space="preserve">
          <source>The specified fbo must be created in the context of the window or one that shares with it.</source>
          <target state="translated">지정된 fbo는 창의 컨텍스트 또는 공유 창의 컨텍스트에서 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="16615f092e2c6c61d84b43611286fb37f6c19daf" translate="yes" xml:space="preserve">
          <source>The specified font families (set by &lt;a href=&quot;qfont#setFamilies&quot;&gt;setFamilies&lt;/a&gt;()) are searched for.</source>
          <target state="translated">지정된 글꼴 패밀리 ( &lt;a href=&quot;qfont#setFamilies&quot;&gt;setFamilies&lt;/a&gt; ()로 설정 )가 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="cbb259104b0fb87afcede47742b1ed3a920b680e" translate="yes" xml:space="preserve">
          <source>The specified image conversion</source>
          <target state="translated">지정된 이미지 변환</target>
        </trans-unit>
        <trans-unit id="67f406fca7127609cfe4f110abea18beaf23406a" translate="yes" xml:space="preserve">
          <source>The specified page range should be printed.</source>
          <target state="translated">지정된 페이지 범위가 인쇄되어야합니다.</target>
        </trans-unit>
        <trans-unit id="257ad4f61e22e1b6f96c9f04a32742cced39befb" translate="yes" xml:space="preserve">
          <source>The specified text should be a short user-readable string describing what this command does.</source>
          <target state="translated">지정된 텍스트는이 명령의 기능을 설명하는 짧은 사용자가 읽을 수있는 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9706b01c216929ef060cbe3589d719d992259dcc" translate="yes" xml:space="preserve">
          <source>The specular light strength for selected objects. The value must be between &lt;code&gt;0.0&lt;/code&gt; and &lt;code&gt;10.0&lt;/code&gt;.</source>
          <target state="translated">선택한 객체의 정반사 강도입니다. 값은 &lt;code&gt;0.0&lt;/code&gt; 과 &lt;code&gt;10.0&lt;/code&gt; 사이 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="5a8cd7d3a3ffe8ea50be93d7eec45d476760238b" translate="yes" xml:space="preserve">
          <source>The specular light strength for the whole graph. The value must be between &lt;code&gt;0.0&lt;/code&gt; and &lt;code&gt;10.0&lt;/code&gt;.</source>
          <target state="translated">전체 그래프의 반사광 강도. 값은 &lt;code&gt;0.0&lt;/code&gt; 과 &lt;code&gt;10.0&lt;/code&gt; 사이 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="9ce8eadfdac8e9b25d602f63828804f2379f9812" translate="yes" xml:space="preserve">
          <source>The specular lighting effect is based on the combination of 3 lighting components ambient, diffuse and specular. The relative strengths of these components are controlled by means of their reflectivity coefficients which are modelled as RGB triplets:</source>
          <target state="translated">스페 큘러 라이팅 효과는 앰비언트, 디퓨즈 및 스페 큘러의 3 가지 조명 구성 요소의 조합을 기반으로합니다. 이러한 구성 요소의 상대 강도는 RGB 삼중 항으로 모델링 된 반사 계수를 통해 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="ac69bc255a25c581b9cb977daebd9abbd2d26db6" translate="yes" xml:space="preserve">
          <source>The speed is measured in percentage of the original animated image speed. The default speed is 1.0 (original speed).</source>
          <target state="translated">속도는 원래 애니메이션 이미지 속도의 백분율로 측정됩니다. 기본 속도는 1.0 (원래 속도)입니다.</target>
        </trans-unit>
        <trans-unit id="574fd0de947fbf9e05ee4b599533e09d34d28699" translate="yes" xml:space="preserve">
          <source>The speed is measured in percentage of the original movie speed. The default speed is 100%. Example:</source>
          <target state="translated">속도는 원래 동영상 속도의 백분율로 측정됩니다. 기본 속도는 100 %입니다. 예:</target>
        </trans-unit>
        <trans-unit id="5a29a991314e4d9a7e1a2a234e355de0e471463a" translate="yes" xml:space="preserve">
          <source>The spinbox will revert to the last valid value.</source>
          <target state="translated">스핀 박스가 마지막 유효 값으로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="fa418f03794d74ed73c33f475bbd5e5decef3fa3" translate="yes" xml:space="preserve">
          <source>The spinbox will revert to the nearest valid value.</source>
          <target state="translated">스핀 박스가 가장 가까운 유효한 값으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="7c87d92578a7dff7ea33178f70fa29d363f05e33" translate="yes" xml:space="preserve">
          <source>The splash screen appears in the center of the screen. It may be useful to add the &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::WindowStaysOnTopHint&lt;/a&gt; to the splash widget's window flags if you want to keep it above all the other windows on the desktop.</source>
          <target state="translated">스플래시 화면이 화면 중앙에 나타납니다. &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: WindowStaysOnTopHint&lt;/a&gt; 를 스플래시 위젯의 창 플래그에 추가하면 데스크탑의 다른 모든 창 위에 유지하려는 경우 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="87ecaa1b90733c1665189df2d6e219e8e69f1a76" translate="yes" xml:space="preserve">
          <source>The spot light emits light towards one direction in a cone shape, which is defined by the &lt;a href=&quot;qml-qtquick3d-spotlight#coneAngle-prop&quot;&gt;coneAngle&lt;/a&gt; property. The light intensity diminishes when approaching the &lt;a href=&quot;qml-qtquick3d-spotlight#coneAngle-prop&quot;&gt;coneAngle&lt;/a&gt;. The angle at which the light intensity starts to diminish is defined by &lt;a href=&quot;qml-qtquick3d-spotlight#innerConeAngle-prop&quot;&gt;innerConeAngle&lt;/a&gt;. Both angles are defined in degrees.</source>
          <target state="translated">스폿 라이트는 &lt;a href=&quot;qml-qtquick3d-spotlight#coneAngle-prop&quot;&gt;coneAngle&lt;/a&gt; 속성으로 정의되는 원뿔 모양의 한 방향으로 빛을 방출 합니다. &lt;a href=&quot;qml-qtquick3d-spotlight#coneAngle-prop&quot;&gt;coneAngle에&lt;/a&gt; 접근하면 빛의 강도가 감소합니다 . 조명 강도가 감소하기 시작하는 각도는 &lt;a href=&quot;qml-qtquick3d-spotlight#innerConeAngle-prop&quot;&gt;innerConeAngle에&lt;/a&gt; 의해 정의됩니다 . 두 각도 모두 각도로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a9a619f111b7aba029ccfbad5669158b38e5f4c5" translate="yes" xml:space="preserve">
          <source>The spot metering point is only used with spot metering mode.</source>
          <target state="translated">스팟 미터링 포인트는 스팟 미터링 모드에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0145ecd2599375e2d04e31841641f42e583f43a0" translate="yes" xml:space="preserve">
          <source>The spread between ripples. Sensible values are in the range &lt;code&gt;[0...100]&lt;/code&gt;. &lt;code&gt;100&lt;/code&gt; by default.</source>
          <target state="translated">잔물결 사이의 확산입니다. 적절한 값은 &lt;code&gt;[0...100]&lt;/code&gt; 범위에 있습니다. 기본적으로 &lt;code&gt;100&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="60ea3680e313f1edca2f565bfd8535111519a869" translate="yes" xml:space="preserve">
          <source>The sprite engine internally copies and cuts up images to fit in an easier-to-read internal format, which leads to some graphics memory limitations. Because it requires all the sprites for a single engine to be in the same texture, attempting to load many different animations can run into texture memory limits on embedded devices. In these situations, a warning will be output to the console containing the maximum texture size.</source>
          <target state="translated">스프라이트 엔진은 읽기 쉬운 내부 형식에 맞게 이미지를 내부적으로 복사하고 잘라내므로 일부 그래픽 메모리 제한이 발생합니다. 단일 엔진에 대한 모든 스프라이트가 동일한 텍스처에 있어야하기 때문에 다양한 애니메이션을로드하려고하면 포함 된 장치의 텍스처 메모리 제한이 발생할 수 있습니다. 이러한 상황에서는 최대 텍스처 크기를 포함하는 경고가 콘솔에 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="73a75b67ea9bcb4b8fad38d212c69f03edc86f25" translate="yes" xml:space="preserve">
          <source>The sprite or sprites to draw. Sprites will be scaled to the size of this item.</source>
          <target state="translated">그릴 스프라이트입니다. 스프라이트는이 항목의 크기에 맞게 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="dadaaaae6c2c97b26774fb65e54c56cac9c74ab9" translate="yes" xml:space="preserve">
          <source>The sprite or sprites used to draw this particle.</source>
          <target state="translated">이 입자를 그리는 데 사용되는 스프라이트</target>
        </trans-unit>
        <trans-unit id="44d4c9869d1c63556ceec6da5ea2546567f5e048" translate="yes" xml:space="preserve">
          <source>The stack becomes enabled and appropriate signals are emitted when &lt;a href=&quot;qundostack#endMacro&quot;&gt;endMacro&lt;/a&gt;() is called for the outermost macro.</source>
          <target state="translated">가장 바깥 쪽 매크로에 &lt;a href=&quot;qundostack#endMacro&quot;&gt;endMacro&lt;/a&gt; ()를 호출 하면 스택이 활성화되고 적절한 신호가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab1fc5134e807181732e6d6c75bc9ae00b5c6fd7" translate="yes" xml:space="preserve">
          <source>The stack can be set explicitly with &lt;a href=&quot;qundoview#setStack&quot;&gt;setStack&lt;/a&gt;(). Alternatively, a &lt;a href=&quot;qundogroup&quot;&gt;QUndoGroup&lt;/a&gt; object can be set with &lt;a href=&quot;qundoview#setGroup&quot;&gt;setGroup&lt;/a&gt;(). The view will then update itself automatically whenever the active stack of the group changes.</source>
          <target state="translated">스택은 &lt;a href=&quot;qundoview#setStack&quot;&gt;setStack&lt;/a&gt; ()을 사용 하여 명시 적으로 설정할 수 있습니다 . 또는 &lt;a href=&quot;qundogroup&quot;&gt;QUndoGroup&lt;/a&gt; 객체를 &lt;a href=&quot;qundoview#setGroup&quot;&gt;setGroup&lt;/a&gt; () 으로 설정할 수 있습니다 . 그러면 그룹의 활성 스택이 변경 될 때마다보기가 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="5c2abc9c1d7aeb658c22001d4dcd91173ac10459" translate="yes" xml:space="preserve">
          <source>The stack now contains a single item: &lt;code&gt;[A]&lt;/code&gt;.</source>
          <target state="translated">이제 스택에는 &lt;code&gt;[A]&lt;/code&gt; 단일 항목이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="acc1b57bc12dc7107417bfcd12fc099754c92730" translate="yes" xml:space="preserve">
          <source>The stack now contains the following items: &lt;code&gt;[A, B, C]&lt;/code&gt;.</source>
          <target state="translated">스택에는 이제 다음 항목이 포함됩니다 : &lt;code&gt;[A, B, C]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17534ff642479a5f6931e89781998e087d118389" translate="yes" xml:space="preserve">
          <source>The stack now contains the following items: &lt;code&gt;[A, B, D]&lt;/code&gt;.</source>
          <target state="translated">스택에는 이제 다음 항목이 포함됩니다 : &lt;code&gt;[A, B, D]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35a0dce6099d88daf08983f3756382b3b91ab75c" translate="yes" xml:space="preserve">
          <source>The stack now contains the following items: &lt;code&gt;[A, B]&lt;/code&gt;.</source>
          <target state="translated">스택에는 이제 다음 항목이 포함됩니다. &lt;code&gt;[A, B]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aaeb7cf9a95e67316d8e5eda515b4126e848e22b" translate="yes" xml:space="preserve">
          <source>The stacking order of two sibling items also counts for each item's children and descendant items. So if one item is on top of another, then all its children will also be on top of all the other item's children as well.</source>
          <target state="translated">두 형제 항목의 누적 순서는 각 항목의 하위 항목과 하위 항목에도 계산됩니다. 따라서 한 항목이 다른 항목 위에 있으면 모든 하위 항목도 다른 항목의 하위 항목 위에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="5e08c0058e9483166601b6d7bc46194445154477" translate="yes" xml:space="preserve">
          <source>The standard</source>
          <target state="translated">표준</target>
        </trans-unit>
        <trans-unit id="20b8c5efa0869fe4b29e785455ad1de5ea1b501a" translate="yes" xml:space="preserve">
          <source>The standard &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; class informs the view when it has finished editing by emitting the &lt;a href=&quot;qabstractitemdelegate#closeEditor&quot;&gt;closeEditor()&lt;/a&gt; signal. The view ensures that the editor widget is closed and destroyed. In this example, we only provide simple editing facilities, so we need never emit this signal.</source>
          <target state="translated">표준 &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; 클래스는 &lt;a href=&quot;qabstractitemdelegate#closeEditor&quot;&gt;closeEditor ()&lt;/a&gt; 신호를 방출하여 편집이 완료되면 뷰에 알립니다 . 뷰는 편집기 위젯이 닫히고 파괴되도록합니다. 이 예제에서는 간단한 편집 기능 만 제공하므로이 신호를 방출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a9ebacc9413b226158fffc3d0ce51814ca908fa" translate="yes" xml:space="preserve">
          <source>The standard C++ object model provides very efficient runtime support for the object paradigm. But its static nature is inflexibile in certain problem domains. Graphical user interface programming is a domain that requires both runtime efficiency and a high level of flexibility. Qt provides this, by combining the speed of C++ with the flexibility of the Qt Object Model.</source>
          <target state="translated">표준 C ++ 객체 모델은 객체 패러다임에 대한 매우 효율적인 런타임 지원을 제공합니다. 그러나 정적 특성은 특정 문제 영역에서 융통성이 없습니다. 그래픽 사용자 인터페이스 프로그래밍은 런타임 효율성과 높은 수준의 유연성이 모두 필요한 도메인입니다. Qt는 C ++의 속도와 Qt Object Model의 유연성을 결합하여이를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="352071b61069cc76b879ee7dedc23bc9c7d6ee90" translate="yes" xml:space="preserve">
          <source>The standard ECMAScript built-ins are not explicitly documented in the QML documentation. For more information on their use, please refer to the ECMA-262 7th edition standard or one of the many online JavaScript reference and tutorial sites, such as the &lt;a href=&quot;http://www.w3schools.com/jsref/default.asp&quot;&gt;W3Schools JavaScript Reference&lt;/a&gt; (JavaScript Objects Reference section). Many sites focus on JavaScript in the browser, so in some cases you may need to double check the specification to determine whether a given function or object is part of standard ECMAScript or specific to the browser environment. In the case of the W3Schools link above, the &lt;code&gt;JavaScript Objects Reference&lt;/code&gt; section generally covers the standard, while the &lt;code&gt;Browser Objects Reference&lt;/code&gt; and &lt;code&gt;HTML DOM Objects Reference&lt;/code&gt; sections are browser specific (and thus not applicable to QML).</source>
          <target state="translated">표준 ECMAScript 내장 기능은 QML 문서에 명시 적으로 문서화되어 있지 않습니다. 사용에 대한 자세한 내용은 ECMA-262 7th edition 표준 또는 &lt;a href=&quot;http://www.w3schools.com/jsref/default.asp&quot;&gt;W3Schools JavaScript Reference&lt;/a&gt; (JavaScript Objects Reference 섹션) 와 같은 많은 온라인 JavaScript 참조 및 자습서 사이트 중 하나를 참조하십시오. 많은 사이트가 브라우저의 JavaScript에 중점을두기 때문에 특정 함수 나 객체가 표준 ECMAScript의 일부인지 아니면 브라우저 환경에 특정한 것인지 확인하기 위해 사양을 다시 확인해야 할 수도 있습니다. 위의 W3Schools 링크의 경우 &lt;code&gt;JavaScript Objects Reference&lt;/code&gt; 섹션에서 일반적으로 표준을 다루고 &lt;code&gt;Browser Objects Reference&lt;/code&gt; 및 &lt;code&gt;HTML DOM Objects Reference&lt;/code&gt; 섹션은 브라우저에 따라 다릅니다 (따라서 QML에 적용되지 않음).</target>
        </trans-unit>
        <trans-unit id="594e6fdcb2771f2f7ffde626d56360c425617012" translate="yes" xml:space="preserve">
          <source>The standard ECMAScript built-ins are not explicitly documented in the QML documentation. For more information on their use, please refer to the ECMA-262 7th edition standard or one of the many online JavaScript reference and tutorial sites, such as the &lt;a href=&quot;http://www.w3schools.com/jsref/default.asp#&quot;&gt;W3Schools JavaScript Reference&lt;/a&gt; (JavaScript Objects Reference section). Many sites focus on JavaScript in the browser, so in some cases you may need to double check the specification to determine whether a given function or object is part of standard ECMAScript or specific to the browser environment. In the case of the W3Schools link above, the &lt;code&gt;JavaScript Objects Reference&lt;/code&gt; section generally covers the standard, while the &lt;code&gt;Browser Objects Reference&lt;/code&gt; and &lt;code&gt;HTML DOM Objects Reference&lt;/code&gt; sections are browser specific (and thus not applicable to QML).</source>
          <target state="translated">표준 ECMAScript 내장 기능은 QML 문서에 명시 적으로 문서화되어 있지 않습니다. 사용에 대한 자세한 내용은 ECMA-262 7 판 표준 또는 &lt;a href=&quot;http://www.w3schools.com/jsref/default.asp#&quot;&gt;W3Schools JavaScript Reference&lt;/a&gt; (JavaScript Objects Reference 섹션) 와 같은 많은 온라인 JavaScript 참조 및 자습서 사이트 중 하나를 참조하십시오. 많은 사이트가 브라우저에서 JavaScript에 중점을두기 때문에 특정 기능이나 객체가 표준 ECMAScript의 일부인지 또는 브라우저 환경에 특정한지 여부를 확인하기 위해 사양을 다시 확인해야 할 수도 있습니다. 위의 W3Schools 링크의 경우, &lt;code&gt;JavaScript Objects Reference&lt;/code&gt; 섹션은 일반적으로 표준을 다루는 반면, &lt;code&gt;Browser Objects Reference&lt;/code&gt; 및 &lt;code&gt;HTML DOM Objects Reference&lt;/code&gt; 는 섹션은 브라우저마다 다르므로 QML에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b241f02dfe18e01246a96e0059610a08f31c96d2" translate="yes" xml:space="preserve">
          <source>The standard ISO offset form of the time zone name, e.g. &quot;UTC+01:00&quot;</source>
          <target state="translated">표준 시간대 이름의 표준 ISO 오프셋 형식 (예 : &quot;UTC + 01 : 00&quot;</target>
        </trans-unit>
        <trans-unit id="89e8aa7ae39d2846a7d844bc23139662f5b9ac6f" translate="yes" xml:space="preserve">
          <source>The standard arrow cursor is the default for widgets in a normal state.</source>
          <target state="translated">표준 화살표 커서는 일반 상태의 위젯에 대한 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="194f0c6539c95c5e5fefa4da5da0a8c07c655582" translate="yes" xml:space="preserve">
          <source>The standard arrow cursor.</source>
          <target state="translated">표준 화살표 커서</target>
        </trans-unit>
        <trans-unit id="687bdb48e0e7ee7d07339ebd11447a2da96cdab2" translate="yes" xml:space="preserve">
          <source>The standard error (stderr) of the running process.</source>
          <target state="translated">실행중인 프로세스의 표준 오류 (stderr)</target>
        </trans-unit>
        <trans-unit id="20950cf56865d0fb3b942dac21a01dbfccacc563" translate="yes" xml:space="preserve">
          <source>The standard factory implementation provides editors for a variety of data types. These are created whenever a delegate needs to provide an editor for data supplied by a model. The following table shows the relationship between types and the standard editors provided.</source>
          <target state="translated">표준 팩토리 구현은 다양한 데이터 유형에 대한 편집기를 제공합니다. 델리게이트가 모델이 제공 한 데이터에 대한 편집기를 제공해야 할 때마다 생성됩니다. 다음 표는 유형과 제공된 표준 편집기 간의 관계를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5e267bfa7bf5a06f20094a353e01577e4403efc1" translate="yes" xml:space="preserve">
          <source>The standard layout provided by Qt can handle simple word processing including inline images, lists and tables.</source>
          <target state="translated">Qt가 제공하는 표준 레이아웃은 인라인 이미지, 목록 및 테이블을 포함한 간단한 워드 프로세싱을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="2ced9b0dfff4a44590f9a4c7f778f880d687a321" translate="yes" xml:space="preserve">
          <source>The standard library of types and functionality for the QML language, which is provided by the Qt Quick module, and may be accessed with &quot;import &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-qmlmodule.html&quot;&gt;QtQuick&lt;/a&gt; 2.3&quot;.</source>
          <target state="translated">Qt Quick 모듈에서 제공하며 &quot;import &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-qmlmodule.html&quot;&gt;QtQuick&lt;/a&gt; 2.3&quot; 으로 액세스 할 수있는 QML 언어의 표준 유형 및 기능 라이브러리입니다 .</target>
        </trans-unit>
        <trans-unit id="d75350c112d57dea4962d71d2a2bc45dde71e97c" translate="yes" xml:space="preserve">
          <source>The standard library of types and functionality for the QML language, which is provided by the Qt Quick module, and may be accessed with &quot;import &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-module.html&quot;&gt;QtQuick&lt;/a&gt; 2.3&quot;.</source>
          <target state="translated">Qt Quick 모듈에서 제공하고 &quot;import &lt;a href=&quot;https://doc.qt.io/qt-5.15/qtquick-module.html&quot;&gt;QtQuick&lt;/a&gt; 2.3&quot;을 사용 하여 액세스 할 수있는 QML 언어의 표준 유형 및 기능 라이브러리입니다 .</target>
        </trans-unit>
        <trans-unit id="87863833db7caa81314de86ce4fd81f07f83d6e3" translate="yes" xml:space="preserve">
          <source>The standard output (stdout) of the running process.</source>
          <target state="translated">실행중인 프로세스의 표준 출력 (stdout)</target>
        </trans-unit>
        <trans-unit id="7ba3eaf46241fab02d05444481dab54513255d8a" translate="yes" xml:space="preserve">
          <source>The standard time in a time zone, i.e. when Daylight-Saving is not in effect. For example when formatting a display name this will show something like &quot;Pacific Standard Time&quot;.</source>
          <target state="translated">표준 시간대, 즉 일광 절약이 적용되지 않는 표준 시간입니다. 예를 들어 표시 이름을 형식화 할 때 &quot;태평양 표준시&quot;와 같은 것이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b736383f3cde809f7db89ffe82d9130313b6556b" translate="yes" xml:space="preserve">
          <source>The standard view classes provide default selection models that can be used in most applications. A selection model belonging to one view can be obtained using the view's &lt;a href=&quot;qabstractitemview#selectionModel&quot;&gt;selectionModel()&lt;/a&gt; function, and shared between many views with &lt;a href=&quot;qabstractitemview#setSelectionModel&quot;&gt;setSelectionModel()&lt;/a&gt;, so the construction of new selection models is generally not required.</source>
          <target state="translated">표준 뷰 클래스는 대부분의 응용 프로그램에서 사용할 수있는 기본 선택 모델을 제공합니다. 뷰의 &lt;a href=&quot;qabstractitemview#selectionModel&quot;&gt;selectionModel ()&lt;/a&gt; 함수 를 사용하여 하나의 뷰에 속하는 선택 모델을 얻을 수 있으며 &lt;a href=&quot;qabstractitemview#setSelectionModel&quot;&gt;setSelectionModel ()을 사용&lt;/a&gt; 하여 여러 뷰간에 공유 할 수 있으므로 일반적으로 새 선택 모델을 구성 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="39400caccbe04043a92b08893bb201f111d52490" translate="yes" xml:space="preserve">
          <source>The standard views automatically support internal drag and drop, where items are moved around to change the order in which they are displayed. By default, drag and drop is not enabled for these views because they are configured for the simplest, most common uses. To allow items to be dragged around, certain properties of the view need to be enabled, and the items themselves must also allow dragging to occur.</source>
          <target state="translated">표준보기는 항목을 이동하여 표시되는 순서를 변경하는 내부 드래그 앤 드롭을 자동으로 지원합니다. 기본적으로 끌어서 놓기는 가장 단순하고 가장 일반적인 용도로 구성되어 있으므로 이러한보기에 대해 활성화되어 있지 않습니다. 항목을 끌어다 놓으려면보기의 특정 속성을 활성화해야하며 항목 자체에서도 끌어서 놓기를 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ff5dd462fbae79f8d9f51dc5e710bc5a2572db0" translate="yes" xml:space="preserve">
          <source>The standard views provided with Qt use instances of &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; to provide editing facilities. This default implementation of the delegate interface renders items in the usual style for each of the standard views: &lt;a href=&quot;qlistview&quot;&gt;QListView&lt;/a&gt;, &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, and &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt;.</source>
          <target state="translated">Qt와 함께 제공되는 표준 뷰는 &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; 인스턴스를 사용 하여 편집 기능을 제공합니다. 델리게이트 인터페이스의이 기본 구현은 각 표준 뷰 ( &lt;a href=&quot;qlistview&quot;&gt;QListView&lt;/a&gt; , &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt; 및 &lt;a href=&quot;qtreeview&quot;&gt;QTreeView)&lt;/a&gt; 에 대해 일반적인 스타일로 항목을 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="52161a5f75d230b561debf31aee1f9b87a05cd26" translate="yes" xml:space="preserve">
          <source>The start angle is reported clockwise, with zero degrees at the 3 o'clock position.</source>
          <target state="translated">시작 각도는 시계 방향으로보고되며 3시 위치에 0 도입니다.</target>
        </trans-unit>
        <trans-unit id="4ef247b39e9867444dc16381e10e990820a76aef" translate="yes" xml:space="preserve">
          <source>The start of the timeline.</source>
          <target state="translated">타임 라인의 시작입니다.</target>
        </trans-unit>
        <trans-unit id="faa52616e7256757dfcfc7be7e120ed3e13d6cea" translate="yes" xml:space="preserve">
          <source>The start position of the display text for a hypertext link has changed.</source>
          <target state="translated">하이퍼 텍스트 링크의 표시 텍스트 시작 위치가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="c8fc82e5ed34a66572197a1054ab8017f17723c5" translate="yes" xml:space="preserve">
          <source>The startAngle and spanAngle must be specified in 1/16th of a degree, i.e. a full circle equals 5760 (16 * 360). Positive values for the angles mean counter-clockwise while negative values mean the clockwise direction. Zero degrees is at the 3 o'clock position.</source>
          <target state="translated">startAngle 및 spanAngle은 1/16 도로 지정해야합니다. 즉 전체 원은 5760 (16 * 360)입니다. 각도의 양수 값은 시계 반대 방향을 의미하고 음수 값은 시계 방향을 의미합니다. 0 도는 3시 방향에 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ca6b3ec435e9e8b22ca1b4fe7391042911ca56b" translate="yes" xml:space="preserve">
          <source>The starting acceleraton of the particles emitted.</source>
          <target state="translated">방출되는 입자의 시작 가속도.</target>
        </trans-unit>
        <trans-unit id="7606ef7fcff1928ec685acacc2412201b0bf65aa" translate="yes" xml:space="preserve">
          <source>The starting and ending positions of table rows can be found by moving a cursor within a table, and using the &lt;a href=&quot;qtexttable#rowStart&quot;&gt;rowStart&lt;/a&gt;() and &lt;a href=&quot;qtexttable#rowEnd&quot;&gt;rowEnd&lt;/a&gt;() functions to obtain cursors at the start and end of each row.</source>
          <target state="translated">테이블 행의 시작 및 종료 위치는 테이블 내에서 커서를 이동하고 &lt;a href=&quot;qtexttable#rowStart&quot;&gt;rowStart&lt;/a&gt; () 및 &lt;a href=&quot;qtexttable#rowEnd&quot;&gt;rowEnd&lt;/a&gt; () 함수를 사용하여 각 행의 시작 및 끝에서 커서를 확보하여 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="032e6b332d1dfc1e1663d8e1c868e442e7cf6deb" translate="yes" xml:space="preserve">
          <source>The starting angle of the pie.</source>
          <target state="translated">파이의 시작 각도.</target>
        </trans-unit>
        <trans-unit id="d7c2ad0aa40b060de291f1c0f2e1c871cb381551" translate="yes" xml:space="preserve">
          <source>The starting angle of this slice in the series it belongs to. A full pie is 360 degrees, where 0 degrees is at 12 a'clock. Updated automatically once the slice is added to the series.</source>
          <target state="translated">이 슬라이스가 속한 시리즈에서이 슬라이스의 시작 각도입니다. 전체 파이는 360도이며 0 도는 12시입니다. 슬라이스가 시리즈에 추가되면 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="be4e87630f12dcf59ad208b1a792a9baae230723" translate="yes" xml:space="preserve">
          <source>The starting point for the thread. After calling &lt;a href=&quot;qthread#start&quot;&gt;start&lt;/a&gt;(), the newly created thread calls this function. The default implementation simply calls &lt;a href=&quot;qthread#exec&quot;&gt;exec&lt;/a&gt;().</source>
          <target state="translated">스레드의 시작점. &lt;a href=&quot;qthread#start&quot;&gt;start&lt;/a&gt; ()를 호출 한 후 새로 작성된 스레드가이 함수를 호출합니다. 기본 구현은 단순히 &lt;a href=&quot;qthread#exec&quot;&gt;exec&lt;/a&gt; () 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="800008187bad688486f56cf5b4f12fa519503fa7" translate="yes" xml:space="preserve">
          <source>The starting velocity of the particles emitted.</source>
          <target state="translated">방출되는 입자의 시작 속도.</target>
        </trans-unit>
        <trans-unit id="251253c98d5f692c3d8ce310c15a4ce803a76983" translate="yes" xml:space="preserve">
          <source>The startup ID of the first window comes from the environment variable DESKTOP_STARTUP_ID. This method is useful for subsequent windows, when the request comes from another process (e.g. via DBus).</source>
          <target state="translated">첫 번째 창의 시작 ID는 환경 변수 DESKTOP_STARTUP_ID에서 가져옵니다. 이 방법은 요청이 다른 프로세스에서 온 경우 (예 : DBus를 통해) 후속 창에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3a12c940d9adfb45bb072a0516d151c9970a2586" translate="yes" xml:space="preserve">
          <source>The state being changed in this event can be retrieved through</source>
          <target state="translated">이 이벤트에서 변경되는 상태는</target>
        </trans-unit>
        <trans-unit id="591b11c7be843d1b4440398683159d78d0d4b842" translate="yes" xml:space="preserve">
          <source>The state being changed in this event can be retrieved through the</source>
          <target state="translated">이 이벤트에서 변경되는 상태는</target>
        </trans-unit>
        <trans-unit id="616f5fb4e2f0e94b55ee905727ddded8f3fb3ac5" translate="yes" xml:space="preserve">
          <source>The state being extended is treated as the base state in regards to the changes specified by the extending state.</source>
          <target state="translated">확장되는 상태는 확장 상태에 의해 지정된 변경과 관련하여 기본 상태로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="caa0153c65423f257b944f189c421ec7cea31413" translate="yes" xml:space="preserve">
          <source>The state can be one of these two:</source>
          <target state="translated">상태는 다음 두 가지 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83409be4a8e9bf25a1be356b83b75d249733ce47" translate="yes" xml:space="preserve">
          <source>The state can only be obtained once the SSL connection starts, but not necessarily before it's done. Some settings may change during the course of the SSL connection without need to restart it (for instance, the cipher can be changed over time).</source>
          <target state="translated">SSL 연결이 시작된 후에 만 ​​상태를 얻을 수 있지만 반드시 완료하기 전에는 불가능합니다. SSL 연결 과정에서 일부 설정을 다시 시작할 필요없이 변경 될 수 있습니다 (예 : 시간이 지남에 따라 암호를 변경할 수 있음).</target>
        </trans-unit>
        <trans-unit id="18cf1647182f7434b413589ef34d503425e13b3b" translate="yes" xml:space="preserve">
          <source>The state emits the &lt;a href=&quot;qml-qtqml-statemachine-state#finished-signal&quot;&gt;State::finished()&lt;/a&gt; signal when a final child state (&lt;a href=&quot;qml-qtqml-statemachine-finalstate&quot;&gt;FinalState&lt;/a&gt;) is entered.</source>
          <target state="translated">상태는 방출 &lt;a href=&quot;qml-qtqml-statemachine-state#finished-signal&quot;&gt;주 : 종료 ()&lt;/a&gt; 최종 아이 상태 (신호 &lt;a href=&quot;qml-qtqml-statemachine-finalstate&quot;&gt;최종 상태 (FinalState)가&lt;/a&gt; )를 입력합니다.</target>
        </trans-unit>
        <trans-unit id="1bb5acf517638167a4d8117093d3ff105782b4c1" translate="yes" xml:space="preserve">
          <source>The state emits the &lt;a href=&quot;qstate#finished&quot;&gt;QState::finished&lt;/a&gt;() signal when a final child state (&lt;a href=&quot;qfinalstate&quot;&gt;QFinalState&lt;/a&gt;) is entered.</source>
          <target state="translated">최종 하위 상태 ( &lt;a href=&quot;qfinalstate&quot;&gt;QFinalState&lt;/a&gt; )가 입력 되면 상태는 &lt;a href=&quot;qstate#finished&quot;&gt;QState :: finished&lt;/a&gt; () 신호를 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="25694c4d0315cb642f92ce1a8f90b6e41f63bd61" translate="yes" xml:space="preserve">
          <source>The state graph in the State Machine framework is hierarchical. States can be nested inside of other states, and the current configuration of the state machine consists of the set of states which are currently active. All the states in a valid configuration of the state machine will have a common ancestor.</source>
          <target state="translated">State Machine 프레임 워크의 상태 그래프는 계층 적입니다. 상태는 다른 상태 안에 중첩 될 수 있으며 상태 머신의 현재 구성은 현재 활성화 된 상태 세트로 구성됩니다. 상태 머신의 유효한 구성에있는 모든 상태에는 공통 조상이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c269b0b4b56e97869a617531a9fe97ca01133785" translate="yes" xml:space="preserve">
          <source>The state is considered to be online for as long as &lt;a href=&quot;qnetworkconfigurationmanager#allConfigurations&quot;&gt;allConfigurations&lt;/a&gt;(&lt;a href=&quot;qnetworkconfiguration#StateFlag-enum&quot;&gt;QNetworkConfiguration::Active&lt;/a&gt;) returns a list with at least one entry.</source>
          <target state="translated">&lt;a href=&quot;qnetworkconfigurationmanager#allConfigurations&quot;&gt;allConfigurations&lt;/a&gt; ( &lt;a href=&quot;qnetworkconfiguration#StateFlag-enum&quot;&gt;QNetworkConfiguration :: Active&lt;/a&gt; )가 하나 이상의 항목이있는 목록을 반환하는 한 상태는 온라인 인 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="a37d5694e3be1fa9d68dad0eb07eabdb838840bb" translate="yes" xml:space="preserve">
          <source>The state is fast forwarded to determine the complete set of end values.</source>
          <target state="translated">종료 값의 전체 세트를 판별하기 위해 상태가 빨리 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4948bbc7febda5f42d388251a535cb07575d0f28" translate="yes" xml:space="preserve">
          <source>The state is fully applied, with transitions.</source>
          <target state="translated">상태는 전이와 함께 완전히 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d49d26b4cac780e0e51b67465385e09d8cb09b76" translate="yes" xml:space="preserve">
          <source>The state is rewound.</source>
          <target state="translated">상태가 되감습니다.</target>
        </trans-unit>
        <trans-unit id="7699d38f4fa356aec20682417954628a93e3ffdf" translate="yes" xml:space="preserve">
          <source>The state machine defined in the previous section never finishes. In order for a state machine to be able to finish, it needs to have a top-level</source>
          <target state="translated">이전 섹션에서 정의 된 상태 머신은 완료되지 않습니다. 상태 머신을 완료하려면 최상위 레벨이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ec700cd9aeba06166a1708f8179ec630e3d7d50c" translate="yes" xml:space="preserve">
          <source>The state machine executes asynchronously, i.e. it becomes part of your application's event loop.</source>
          <target state="translated">상태 머신은 비동기 적으로 실행됩니다. 즉, 애플리케이션의 이벤트 루프의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="82a686ea323c46708372426a841835da3de29f2c" translate="yes" xml:space="preserve">
          <source>The state machine instance.</source>
          <target state="translated">상태 머신 인스턴스.</target>
        </trans-unit>
        <trans-unit id="a1420a8fdabb702b6a488e0239a9eb8f90252227" translate="yes" xml:space="preserve">
          <source>The state machine processes events and takes transitions until a top-level final state is entered; the state machine then emits the &lt;a href=&quot;qstate#finished&quot;&gt;finished&lt;/a&gt;() signal. You can also &lt;a href=&quot;qstatemachine#stop&quot;&gt;stop&lt;/a&gt;() the state machine explicitly. The &lt;a href=&quot;qstatemachine#stopped&quot;&gt;stopped&lt;/a&gt;() signal is emitted in this case.</source>
          <target state="translated">상태 머신은 이벤트를 처리하고 최상위 최종 상태가 될 때까지 전환을 수행합니다. 상태 머신은 &lt;a href=&quot;qstate#finished&quot;&gt;완료된&lt;/a&gt; () 신호 를 방출합니다 . 상태 머신을 명시 적으로 &lt;a href=&quot;qstatemachine#stop&quot;&gt;중지&lt;/a&gt; () 할 수도 있습니다 . 이 경우 &lt;a href=&quot;qstatemachine#stopped&quot;&gt;정지&lt;/a&gt; () 신호가 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="a14b73ab8bc5374fb51d56c64d9b14dc1d287f9f" translate="yes" xml:space="preserve">
          <source>The state machine processes events and takes transitions until a top-level final state is entered; the state machine then emits the finished() signal. You can also &lt;a href=&quot;qml-qtqml-statemachine-statemachine#stop-method&quot;&gt;stop()&lt;/a&gt; the state machine explicitly (you can also set running property to false). The stopped signal is emitted in this case.</source>
          <target state="translated">상태 머신은 이벤트를 처리하고 최상위 최종 상태가 될 때까지 전환을 수행합니다. 상태 머신은 finished () 신호를 방출합니다. 당신은 또한 수 &lt;a href=&quot;qml-qtqml-statemachine-statemachine#stop-method&quot;&gt;) (중지&lt;/a&gt; (당신은 또한 등록 정보를 false로 실행 설정할 수 있습니다) 명시 적으로 상태 머신을. 이 경우 정지 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1a89b667059eee3f4e5e3cea829be77c4c8c7b83" translate="yes" xml:space="preserve">
          <source>The state machine runs asynchronously to become part of your application's event loop.</source>
          <target state="translated">상태 머신은 비동기 적으로 실행되어 애플리케이션의 이벤트 루프의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="c646164c705e691f465a97f0009ac4382f74fcb4" translate="yes" xml:space="preserve">
          <source>The state machine should not save the initial values of properties and restore them later.</source>
          <target state="translated">상태 머신은 속성의 초기 값을 저장하고 나중에 복원해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="efcf5ff29f4d4838466b787798e6ed54862fbd73" translate="yes" xml:space="preserve">
          <source>The state machine should save the initial values of properties and restore them later.</source>
          <target state="translated">상태 머신은 속성의 초기 값을 저장하고 나중에 복원해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e54442e98c653c3ff606a4a06399b663946b015" translate="yes" xml:space="preserve">
          <source>The state machine that invoked the services.</source>
          <target state="translated">서비스를 호출 한 상태 머신.</target>
        </trans-unit>
        <trans-unit id="9f98dad619709d9c9c807ca5a30fcce9638a88db" translate="yes" xml:space="preserve">
          <source>The state machine that sends out the event.</source>
          <target state="translated">이벤트를 보내는 상태 머신.</target>
        </trans-unit>
        <trans-unit id="afc8a0632ce5075b3cba3b124e3ae61c291499e2" translate="yes" xml:space="preserve">
          <source>The state of the A button. The value is &lt;code&gt;true&lt;/code&gt; when pressed, and &lt;code&gt;false&lt;/code&gt; when not pressed.</source>
          <target state="translated">A 버튼의 상태입니다. 누르면 값이 &lt;code&gt;true&lt;/code&gt; 이고, 누르지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2f80a57218d863af19159e428d6553ad585b46a0" translate="yes" xml:space="preserve">
          <source>The state of the B button. The value is &lt;code&gt;true&lt;/code&gt; when pressed, and &lt;code&gt;false&lt;/code&gt; when not pressed.</source>
          <target state="translated">B 버튼의 상태입니다. 누르면 값이 &lt;code&gt;true&lt;/code&gt; 이고, 누르지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e67b557e6502a377edd3dad9072848d0fd13068f" translate="yes" xml:space="preserve">
          <source>The state of the Select button. The value is &lt;code&gt;true&lt;/code&gt; when pressed, and &lt;code&gt;false&lt;/code&gt; when not pressed. This button can sometimes be labeled as the Back button on some gamepads.</source>
          <target state="translated">선택 버튼의 상태입니다. 누르면 값이 &lt;code&gt;true&lt;/code&gt; 이고, 누르지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다. 이 버튼은 일부 게임 패드에서 뒤로 버튼으로 표시되는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d40b5d21e88ee633f8857bbaff49d21cf028a7e4" translate="yes" xml:space="preserve">
          <source>The state of the Start button. The value is &lt;code&gt;true&lt;/code&gt; when pressed, and &lt;code&gt;false&lt;/code&gt; when not pressed. This button can sometimes be labeled as the Forward button on some gamepads.</source>
          <target state="translated">시작 버튼의 상태입니다. 누르면 값이 &lt;code&gt;true&lt;/code&gt; 이고, 누르지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다. 이 버튼은 때때로 일부 게임 패드에서 앞으로 버튼으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d707b3fd12bc97de7f3badf470dcde59647712c" translate="yes" xml:space="preserve">
          <source>The state of the X button. The value is &lt;code&gt;true&lt;/code&gt; when pressed, and &lt;code&gt;false&lt;/code&gt; when not pressed.</source>
          <target state="translated">X 버튼의 상태입니다. 누르면 값이 &lt;code&gt;true&lt;/code&gt; 이고, 누르지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="39b89eb364f85eeb2f3b0fd369955744bd16ef70" translate="yes" xml:space="preserve">
          <source>The state of the Y button. The value is &lt;code&gt;true&lt;/code&gt; when pressed, and &lt;code&gt;false&lt;/code&gt; when not pressed.</source>
          <target state="translated">Y 버튼의 상태입니다. 누르면 값이 &lt;code&gt;true&lt;/code&gt; 이고, 누르지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6fb844e334c6ead643c59bda05dab348a216337d" translate="yes" xml:space="preserve">
          <source>The state of the application has changed.</source>
          <target state="translated">응용 프로그램의 상태가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="fce054949e8890ec4095bfb223273ada03c76eaf" translate="yes" xml:space="preserve">
          <source>The state of the center button. The value is &lt;code&gt;true&lt;/code&gt; when pressed, and &lt;code&gt;false&lt;/code&gt; when not pressed.</source>
          <target state="translated">가운데 버튼의 상태입니다. 누르면 값이 &lt;code&gt;true&lt;/code&gt; 이고, 누르지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e20244db092a1b2bf2575b5a4f163d706451a021" translate="yes" xml:space="preserve">
          <source>The state of the checkbox can be set with the &lt;a href=&quot;qml-qtquick-controls-checkbox#checked-prop&quot;&gt;checked&lt;/a&gt; property.</source>
          <target state="translated">확인란의 상태는 &lt;a href=&quot;qml-qtquick-controls-checkbox#checked-prop&quot;&gt;checked&lt;/a&gt; 속성 으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee350904441a983e22e21b3d2d9945dbe17f5d33" translate="yes" xml:space="preserve">
          <source>The state of the computation represented by a &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt; can be queried using the &lt;a href=&quot;qfuture#isCanceled&quot;&gt;isCanceled&lt;/a&gt;(), &lt;a href=&quot;qfuture#isStarted&quot;&gt;isStarted&lt;/a&gt;(), &lt;a href=&quot;qfuture#isFinished&quot;&gt;isFinished&lt;/a&gt;(), &lt;a href=&quot;qfuture#isRunning&quot;&gt;isRunning&lt;/a&gt;(), or &lt;a href=&quot;qfuture#isPaused&quot;&gt;isPaused&lt;/a&gt;() functions.</source>
          <target state="translated">&lt;a href=&quot;qfuture&quot;&gt;QFuture로&lt;/a&gt; 표시되는 계산 상태는 &lt;a href=&quot;qfuture#isCanceled&quot;&gt;isCanceled&lt;/a&gt; (), &lt;a href=&quot;qfuture#isStarted&quot;&gt;isStarted&lt;/a&gt; (), &lt;a href=&quot;qfuture#isFinished&quot;&gt;isFinished&lt;/a&gt; (), &lt;a href=&quot;qfuture#isRunning&quot;&gt;isRunning&lt;/a&gt; () 또는 &lt;a href=&quot;qfuture#isPaused&quot;&gt;isPaused&lt;/a&gt; () 함수를 사용하여 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="038219ec89d18cb8a0f626fdd2bab5885016b1e9" translate="yes" xml:space="preserve">
          <source>The state of the computation represented by a QFuture can be queried using the &lt;a href=&quot;qfuture#isCanceled&quot;&gt;isCanceled&lt;/a&gt;(), &lt;a href=&quot;qfuture#isStarted&quot;&gt;isStarted&lt;/a&gt;(), &lt;a href=&quot;qfuture#isFinished&quot;&gt;isFinished&lt;/a&gt;(), &lt;a href=&quot;qfuture#isRunning&quot;&gt;isRunning&lt;/a&gt;(), or &lt;a href=&quot;qfuture#isPaused&quot;&gt;isPaused&lt;/a&gt;() functions.</source>
          <target state="translated">QFuture가 나타내는 계산 상태는 &lt;a href=&quot;qfuture#isCanceled&quot;&gt;isCanceled&lt;/a&gt; (), &lt;a href=&quot;qfuture#isStarted&quot;&gt;isStarted&lt;/a&gt; (), &lt;a href=&quot;qfuture#isFinished&quot;&gt;isFinished&lt;/a&gt; (), &lt;a href=&quot;qfuture#isRunning&quot;&gt;isRunning&lt;/a&gt; () 또는 &lt;a href=&quot;qfuture#isPaused&quot;&gt;isPaused&lt;/a&gt; () 함수를 사용하여 쿼리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="86ad8d38c12af522a4b349fc37a4abca7405c56a" translate="yes" xml:space="preserve">
          <source>The state of the direction pad down button. The value is &lt;code&gt;true&lt;/code&gt; when pressed, and &lt;code&gt;false&lt;/code&gt; when not pressed.</source>
          <target state="translated">방향 패드 아래로 버튼의 상태입니다. 누르면 값이 &lt;code&gt;true&lt;/code&gt; 이고, 누르지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d23ed6dcda1bc9153c916c5b76639222dca3f062" translate="yes" xml:space="preserve">
          <source>The state of the direction pad left button. The value is &lt;code&gt;true&lt;/code&gt; when pressed, and &lt;code&gt;false&lt;/code&gt; when not pressed.</source>
          <target state="translated">방향 패드의 왼쪽 버튼 상태입니다. 누르면 값이 &lt;code&gt;true&lt;/code&gt; 이고, 누르지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f8c3d5e40e0d9e471644ef698b39b3994a58650f" translate="yes" xml:space="preserve">
          <source>The state of the direction pad right button. The value is &lt;code&gt;true&lt;/code&gt; when pressed, and &lt;code&gt;false&lt;/code&gt; when not pressed.</source>
          <target state="translated">방향 패드 오른쪽 버튼의 상태입니다. 누르면 값이 &lt;code&gt;true&lt;/code&gt; 이고, 누르지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="95345465162e0656f4a6769ebe726c2c6577218e" translate="yes" xml:space="preserve">
          <source>The state of the direction pad up button. The value is &lt;code&gt;true&lt;/code&gt; when pressed, and &lt;code&gt;false&lt;/code&gt; when not pressed.</source>
          <target state="translated">방향 패드 위로 버튼의 상태입니다. 누르면 값이 &lt;code&gt;true&lt;/code&gt; 이고, 누르지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="730da99edef9272605527e1628c38e9761e29bf7" translate="yes" xml:space="preserve">
          <source>The state of the event is not modified in the process, so if it is a manual reset event, you will need to reset it after the notification.</source>
          <target state="translated">이벤트 상태는 프로세스에서 수정되지 않으므로 수동 재설정 이벤트 인 경우 알림 후에 재설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="727c3642022abcbe7b7e3c85229b6659c73b4bc0" translate="yes" xml:space="preserve">
          <source>The state of the guide button. The value is &lt;code&gt;true&lt;/code&gt; when pressed, and &lt;code&gt;false&lt;/code&gt; when not pressed. This button is typically the one in the center of the gamepad with a logo. Not all gamepads have a guide button.</source>
          <target state="translated">안내 버튼의 상태입니다. 누르면 값이 &lt;code&gt;true&lt;/code&gt; 이고, 누르지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다. 이 버튼은 일반적으로 로고가있는 게임 패드 중앙에있는 버튼입니다. 모든 게임 패드에 안내 버튼이있는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7174e62c8d5e5334756e89ef23b82653ecf4c992" translate="yes" xml:space="preserve">
          <source>The state of the keyboard modifier keys can be found by calling the &lt;a href=&quot;qinputevent#modifiers&quot;&gt;modifiers()&lt;/a&gt; function, inherited from &lt;a href=&quot;qinputevent&quot;&gt;QInputEvent&lt;/a&gt;.</source>
          <target state="translated">키보드 수정 자 키의 상태는 &lt;a href=&quot;qinputevent&quot;&gt;QInputEvent&lt;/a&gt; 에서 상속 된 &lt;a href=&quot;qinputevent#modifiers&quot;&gt;modifiers ()&lt;/a&gt; 함수 를 호출하여 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ad0aeed6a95a5eb2a45b229596a5a76a9806986" translate="yes" xml:space="preserve">
          <source>The state of the left shoulder button. The value is &lt;code&gt;true&lt;/code&gt; when pressed, and &lt;code&gt;false&lt;/code&gt; when not pressed.</source>
          <target state="translated">왼쪽 어깨 버튼의 상태입니다. 누르면 값이 &lt;code&gt;true&lt;/code&gt; 이고, 누르지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="32f86eadeb9421c5eba49815d6cf9d0e2d79e65a" translate="yes" xml:space="preserve">
          <source>The state of the left stick button. The value is &lt;code&gt;true&lt;/code&gt; when pressed, and &lt;code&gt;false&lt;/code&gt; when not pressed. This button is usually triggered by pressing the left joystick itself.</source>
          <target state="translated">왼쪽 스틱 버튼의 상태입니다. 누르면 값이 &lt;code&gt;true&lt;/code&gt; 이고, 누르지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다. 이 버튼은 일반적으로 왼쪽 조이스틱 자체를 누르면 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="e131e8e609376d913652b6d62ced8c0f86eed6bb" translate="yes" xml:space="preserve">
          <source>The state of the material is accessible through the template generated state() function.</source>
          <target state="translated">재료의 상태는 템플릿 생성 state () 함수를 통해 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2290902dc07e65d6f42cb43f12df50610ef28a74" translate="yes" xml:space="preserve">
          <source>The state of the right shoulder button. The value is &lt;code&gt;true&lt;/code&gt; when pressed, and &lt;code&gt;false&lt;/code&gt; when not pressed.</source>
          <target state="translated">오른쪽 어깨 버튼의 상태입니다. 누르면 값이 &lt;code&gt;true&lt;/code&gt; 이고, 누르지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="43d10645f745406a3c41ce45899afc295bd2a6af" translate="yes" xml:space="preserve">
          <source>The state of the right stick button. The value is &lt;code&gt;true&lt;/code&gt; when pressed, and &lt;code&gt;false&lt;/code&gt; when not pressed. This button is usually triggered by pressing the right joystick itself.</source>
          <target state="translated">오른쪽 스틱 버튼의 상태입니다. 누르면 값이 &lt;code&gt;true&lt;/code&gt; 이고, 누르지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다. 이 버튼은 일반적으로 오른쪽 조이스틱 자체를 누르면 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="6cfedfe406db3cae17d851e306b94e22b75270f4" translate="yes" xml:space="preserve">
          <source>The state of the session represents the state of the underlying access point whereas the session's openness implies the networking/connectivity state available to the current process.</source>
          <target state="translated">세션 상태는 기본 액세스 포인트의 상태를 나타내는 반면 세션의 개방성은 현재 프로세스에서 사용 가능한 네트워킹 / 연결 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ac7cba8e3213ebc06ccd565675dc97f5a818572b" translate="yes" xml:space="preserve">
          <source>The state of whether the current page audio is muted.</source>
          <target state="translated">현재 페이지 오디오가 음소거되었는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="e9aa2a7fce4b8f8f93b163c82922835fdcc4c243" translate="yes" xml:space="preserve">
          <source>The state property represents the user request and is changed synchronously during &lt;a href=&quot;qmediarecorder#record&quot;&gt;record&lt;/a&gt;(), &lt;a href=&quot;qmediarecorder#pause&quot;&gt;pause&lt;/a&gt;() or &lt;a href=&quot;qmediarecorder#stop&quot;&gt;stop&lt;/a&gt;() calls. Recorder state may also change asynchronously when recording fails.</source>
          <target state="translated">state 속성은 사용자 요청을 나타내며 &lt;a href=&quot;qmediarecorder#record&quot;&gt;레코드&lt;/a&gt; (), &lt;a href=&quot;qmediarecorder#pause&quot;&gt;일시 중지&lt;/a&gt; () 또는 &lt;a href=&quot;qmediarecorder#stop&quot;&gt;중지&lt;/a&gt; () 호출 중에 동 기적으로 변경 됩니다. 녹음이 실패하면 레코더 상태도 비동기 적으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="272c8d3b0a630b814addec2840eb0279fcd05f68" translate="yes" xml:space="preserve">
          <source>The state that &lt;a href=&quot;qsslconfiguration&quot;&gt;QSslConfiguration&lt;/a&gt; supports are:</source>
          <target state="translated">&lt;a href=&quot;qsslconfiguration&quot;&gt;QSslConfiguration이&lt;/a&gt; 지원 하는 상태 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="656ac96d70853cec9aab1c6e2bb0726af8c5ab1a" translate="yes" xml:space="preserve">
          <source>The state that QSslConfiguration supports are:</source>
          <target state="translated">QSslConfiguration이 지원하는 상태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d56c6163c6eb34c3c67bee75eefd13421c5204a6" translate="yes" xml:space="preserve">
          <source>The state() attribute enables developers to detect whether the system currently maintains a global network session for the given &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration&lt;/a&gt;. If &lt;a href=&quot;qnetworksession#isOpen&quot;&gt;isOpen()&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt; the &lt;a href=&quot;qnetworksession&quot;&gt;QNetworkSession&lt;/a&gt; instance at hand was at least one of the entities requesting the global network session. This distinction is required to support the notion of session registrations. For as long as there are one or more open &lt;a href=&quot;qnetworksession&quot;&gt;QNetworkSession&lt;/a&gt; instances the underlying network interface is not shut down. Therefore the session &lt;a href=&quot;qnetworksession#state&quot;&gt;state()&lt;/a&gt; can be used to monitor the state of network interfaces.</source>
          <target state="translated">state () 속성을 통해 개발자는 시스템이 현재 지정된 &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration에&lt;/a&gt; 대한 글로벌 네트워크 세션을 유지하고 있는지 여부를 감지 할 수 있습니다 . 경우 &lt;a href=&quot;qnetworksession#isOpen&quot;&gt;ISOPEN ()가&lt;/a&gt; 반환 &lt;code&gt;true&lt;/code&gt; &lt;a href=&quot;qnetworksession&quot;&gt;QNetworkSession의&lt;/a&gt; 손 인스턴스는 글로벌 네트워크 세션을 요청하는 기관 중 적어도 하나였다. 이 등록은 세션 등록 개념을 지원하기 위해 필요합니다. 하나 이상의 열린 &lt;a href=&quot;qnetworksession&quot;&gt;QNetworkSession&lt;/a&gt; 인스턴스가있는 한 기본 네트워크 인터페이스가 종료되지 않습니다. 따라서 세션 &lt;a href=&quot;qnetworksession#state&quot;&gt;상태 ()&lt;/a&gt; 를 사용하여 네트워크 인터페이스의 상태를 모니터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcdb9f639401b6124d9fde16dba5a1af3717c07a" translate="yes" xml:space="preserve">
          <source>The states (except &lt;code&gt;NoServiceSet&lt;/code&gt;) are derived from &lt;a href=&quot;qbluetoothsocket#SocketState-enum&quot;&gt;QBluetoothSocket::SocketState&lt;/a&gt;. This property is read-only. &lt;code&gt;NoServiceSet&lt;/code&gt; indicates that the socket state is not yet available due to the &lt;a href=&quot;qml-qtbluetooth-bluetoothsocket#service-prop&quot;&gt;service&lt;/a&gt; not being set yet.</source>
          <target state="translated">상태 ( &lt;code&gt;NoServiceSet&lt;/code&gt; 제외 )는 &lt;a href=&quot;qbluetoothsocket#SocketState-enum&quot;&gt;QBluetoothSocket :: SocketState&lt;/a&gt; 에서 파생됩니다 . 이 속성은 읽기 전용입니다. &lt;code&gt;NoServiceSet&lt;/code&gt; 은 &lt;a href=&quot;qml-qtbluetooth-bluetoothsocket#service-prop&quot;&gt;서비스&lt;/a&gt; 가 아직 설정 되지 않아서 소켓 상태를 아직 사용할 수 없음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="ba18a6e5742eceb6362a2ff431a834c33a75b96e" translate="yes" xml:space="preserve">
          <source>The states are</source>
          <target state="translated">상태는</target>
        </trans-unit>
        <trans-unit id="91cd2086c9ad0e370f9c869f9c15694be57ce9af" translate="yes" xml:space="preserve">
          <source>The states of buttons in exclusive button groups are updated before this signal is emitted. This means that slots can act on either the &quot;off&quot; signal or the &quot;on&quot; signal emitted by the buttons in the group whose states have changed.</source>
          <target state="translated">배타적 버튼 그룹의 버튼 상태는이 신호가 방출되기 전에 업데이트됩니다. 이것은 슬롯이 상태가 변경된 그룹의 버튼에 의해 방출되는 &quot;off&quot;신호 또는 &quot;on&quot;신호에 작용할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="38bdde7b74c0e63e586ae7cad5a4a6c3243372ab" translate="yes" xml:space="preserve">
          <source>The states of the mouse buttons and keyboard modifiers at the time of the drop are specified by</source>
          <target state="translated">드롭시 마우스 버튼 및 키보드 수정 자의 상태는 다음과 같이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="95fe671fd8e99b50dd21d47a2f38dcd4ea506fa9" translate="yes" xml:space="preserve">
          <source>The static &lt;a href=&quot;qcolordialog#getColor&quot;&gt;getColor&lt;/a&gt;() function shows the dialog, and allows the user to specify a color. This function can also be used to let users choose a color with a level of transparency: pass the &lt;a href=&quot;qcolordialog#ColorDialogOption-enum&quot;&gt;ShowAlphaChannel&lt;/a&gt; option as an additional argument.</source>
          <target state="translated">정적 &lt;a href=&quot;qcolordialog#getColor&quot;&gt;getColor&lt;/a&gt; () 함수는 대화 상자를 표시하고 사용자가 색상을 지정할 수있게합니다. 이 기능을 사용하면 사용자가 투명도를 가진 색상을 선택할 수 있습니다 . 추가 인수로 &lt;a href=&quot;qcolordialog#ColorDialogOption-enum&quot;&gt;ShowAlphaChannel&lt;/a&gt; 옵션을 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="5fff1cca1d651656544e6cf1171b113dc6724502" translate="yes" xml:space="preserve">
          <source>The static &lt;a href=&quot;qerrormessage#qtHandler&quot;&gt;qtHandler&lt;/a&gt;() function installs a message handler using &lt;a href=&quot;#qInstallMessageHandler&quot;&gt;qInstallMessageHandler&lt;/a&gt;() and creates a &lt;a href=&quot;qerrormessage&quot;&gt;QErrorMessage&lt;/a&gt; that displays &lt;a href=&quot;#qDebug&quot;&gt;qDebug&lt;/a&gt;(), &lt;a href=&quot;#qWarning&quot;&gt;qWarning&lt;/a&gt;() and &lt;a href=&quot;#qFatal&quot;&gt;qFatal&lt;/a&gt;() messages. This is most useful in environments where no console is available to display warnings and error messages.</source>
          <target state="translated">정적 &lt;a href=&quot;qerrormessage#qtHandler&quot;&gt;qtHandler&lt;/a&gt; () 함수는 &lt;a href=&quot;#qInstallMessageHandler&quot;&gt;qInstallMessageHandler&lt;/a&gt; ()를 사용하여 메시지 핸들러를 설치하고 &lt;a href=&quot;#qDebug&quot;&gt;qDebug&lt;/a&gt; (), &lt;a href=&quot;#qWarning&quot;&gt;qWarning&lt;/a&gt; () 및 &lt;a href=&quot;#qFatal&quot;&gt;qFatal&lt;/a&gt; () 메시지 를 표시 하는 &lt;a href=&quot;qerrormessage&quot;&gt;QErrorMessage&lt;/a&gt; 를 작성 합니다. 이것은 경고 및 오류 메시지를 표시 할 콘솔이없는 환경에서 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="47dc11e7476230cba1a5663b0b557754454fe61a" translate="yes" xml:space="preserve">
          <source>The static &lt;a href=&quot;qerrormessage#qtHandler&quot;&gt;qtHandler&lt;/a&gt;() function installs a message handler using &lt;a href=&quot;qtglobal#qInstallMessageHandler&quot;&gt;qInstallMessageHandler&lt;/a&gt;() and creates a QErrorMessage that displays &lt;a href=&quot;qtglobal#qDebug&quot;&gt;qDebug&lt;/a&gt;(), &lt;a href=&quot;qtglobal#qWarning&quot;&gt;qWarning&lt;/a&gt;() and &lt;a href=&quot;qtglobal#qFatal&quot;&gt;qFatal&lt;/a&gt;() messages. This is most useful in environments where no console is available to display warnings and error messages.</source>
          <target state="translated">정적 &lt;a href=&quot;qerrormessage#qtHandler&quot;&gt;qtHandler&lt;/a&gt; () 함수는 &lt;a href=&quot;qtglobal#qInstallMessageHandler&quot;&gt;qInstallMessageHandler&lt;/a&gt; ()를 사용하여 메시지 핸들러를 설치하고 &lt;a href=&quot;qtglobal#qDebug&quot;&gt;qDebug&lt;/a&gt; (), &lt;a href=&quot;qtglobal#qWarning&quot;&gt;qWarning&lt;/a&gt; () 및 &lt;a href=&quot;qtglobal#qFatal&quot;&gt;qFatal&lt;/a&gt; () 메시지 를 표시하는 QErrorMessage를 생성 합니다. 이는 경고 및 오류 메시지를 표시하는 데 사용할 수있는 콘솔이없는 환경에서 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="31614f1e36f57398459b5d81c531cc6c5bfd4dca" translate="yes" xml:space="preserve">
          <source>The static function &lt;a href=&quot;qgeopositioninfosource#createDefaultSource&quot;&gt;QGeoPositionInfoSource::createDefaultSource&lt;/a&gt;() creates a default position source that is appropriate for the platform, if one is available. Otherwise, &lt;a href=&quot;qgeopositioninfosource&quot;&gt;QGeoPositionInfoSource&lt;/a&gt; will check for available plugins that implement the &lt;a href=&quot;qgeopositioninfosourcefactory&quot;&gt;QGeoPositionInfoSourceFactory&lt;/a&gt; interface.</source>
          <target state="translated">정적 함수 &lt;a href=&quot;qgeopositioninfosource#createDefaultSource&quot;&gt;QGeoPositionInfoSource :: createDefaultSource&lt;/a&gt; ()는 사용 가능한 경우 플랫폼에 적합한 기본 위치 소스를 작성합니다. 그렇지 않으면 &lt;a href=&quot;qgeopositioninfosource&quot;&gt;QGeoPositionInfoSource&lt;/a&gt; 는 &lt;a href=&quot;qgeopositioninfosourcefactory&quot;&gt;QGeoPositionInfoSourceFactory&lt;/a&gt; 인터페이스 를 구현하는 사용 가능한 플러그인을 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="1c412d108c1a736edff3c85e483e7d776d093a97" translate="yes" xml:space="preserve">
          <source>The static function &lt;a href=&quot;qgeopositioninfosource#createDefaultSource&quot;&gt;QGeoPositionInfoSource::createDefaultSource&lt;/a&gt;() creates a default position source that is appropriate for the platform, if one is available. Otherwise, QGeoPositionInfoSource will check for available plugins that implement the &lt;a href=&quot;qgeopositioninfosourcefactory&quot;&gt;QGeoPositionInfoSourceFactory&lt;/a&gt; interface.</source>
          <target state="translated">정적 함수 &lt;a href=&quot;qgeopositioninfosource#createDefaultSource&quot;&gt;QGeoPositionInfoSource :: createDefaultSource&lt;/a&gt; ()는 사용 가능한 경우 플랫폼에 적합한 기본 위치 소스를 만듭니다. 그렇지 않으면 QGeoPositionInfoSource는 &lt;a href=&quot;qgeopositioninfosourcefactory&quot;&gt;QGeoPositionInfoSourceFactory&lt;/a&gt; 인터페이스 를 구현하는 사용 가능한 플러그인을 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="a0466e48119b79c0f2f493d2eef0982bbf68e671" translate="yes" xml:space="preserve">
          <source>The static function &lt;a href=&quot;qgeosatelliteinfosource#createDefaultSource&quot;&gt;QGeoSatelliteInfoSource::createDefaultSource&lt;/a&gt;() creates a default satellite data source that is appropriate for the platform, if one is available. Otherwise, available &lt;a href=&quot;qgeopositioninfosourcefactory&quot;&gt;QGeoPositionInfoSourceFactory&lt;/a&gt; plugins will be checked for one that has a satellite data source available.</source>
          <target state="translated">정적 함수 &lt;a href=&quot;qgeosatelliteinfosource#createDefaultSource&quot;&gt;QGeoSatelliteInfoSource :: createDefaultSource&lt;/a&gt; ()는 사용 가능한 경우 플랫폼에 적합한 기본 위성 데이터 소스를 작성합니다. 그렇지 않으면 사용 가능한 &lt;a href=&quot;qgeopositioninfosourcefactory&quot;&gt;QGeoPositionInfoSourceFactory&lt;/a&gt; 플러그인 에서 사용 가능한 위성 데이터 소스가있는 플러그인이 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="8d62bec466d20408090e3d0f0d045976ea3c576d" translate="yes" xml:space="preserve">
          <source>The static functions &lt;a href=&quot;qaudiodeviceinfo#defaultInputDevice&quot;&gt;defaultInputDevice&lt;/a&gt;(), &lt;a href=&quot;qaudiodeviceinfo#defaultOutputDevice&quot;&gt;defaultOutputDevice&lt;/a&gt;(), and &lt;a href=&quot;qaudiodeviceinfo#availableDevices&quot;&gt;availableDevices&lt;/a&gt;() let you get a list of all available devices. Devices are fetched according to the value of mode this is specified by the &lt;a href=&quot;qaudio&quot;&gt;QAudio&lt;/a&gt;::Mode enum. The &lt;a href=&quot;qaudiodeviceinfo&quot;&gt;QAudioDeviceInfo&lt;/a&gt; returned are only valid for the &lt;a href=&quot;qaudio&quot;&gt;QAudio&lt;/a&gt;::Mode.</source>
          <target state="translated">정적 함수 &lt;a href=&quot;qaudiodeviceinfo#defaultInputDevice&quot;&gt;defaultInputDevice&lt;/a&gt; (), &lt;a href=&quot;qaudiodeviceinfo#defaultOutputDevice&quot;&gt;defaultOutputDevice&lt;/a&gt; () 및 &lt;a href=&quot;qaudiodeviceinfo#availableDevices&quot;&gt;availableDevices&lt;/a&gt; ()를 사용하면 사용 가능한 모든 장치 목록을 얻을 수 있습니다. &lt;a href=&quot;qaudio&quot;&gt;QAudio&lt;/a&gt; :: Mode 열거 형에 의해 지정된 모드 값에 따라 장치가 페치됩니다 . 반환 된 &lt;a href=&quot;qaudiodeviceinfo&quot;&gt;QAudioDeviceInfo&lt;/a&gt; 는 &lt;a href=&quot;qaudio&quot;&gt;QAudio&lt;/a&gt; :: Mode 에만 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="a25113b1a81c2a51233956c1d778cd69498a380a" translate="yes" xml:space="preserve">
          <source>The static functions &lt;a href=&quot;qaudiodeviceinfo#defaultInputDevice&quot;&gt;defaultInputDevice&lt;/a&gt;(), &lt;a href=&quot;qaudiodeviceinfo#defaultOutputDevice&quot;&gt;defaultOutputDevice&lt;/a&gt;(), and &lt;a href=&quot;qaudiodeviceinfo#availableDevices&quot;&gt;availableDevices&lt;/a&gt;() let you get a list of all available devices. Devices are fetched according to the value of mode this is specified by the &lt;a href=&quot;qaudio&quot;&gt;QAudio&lt;/a&gt;::Mode enum. The QAudioDeviceInfo returned are only valid for the &lt;a href=&quot;qaudio&quot;&gt;QAudio&lt;/a&gt;::Mode.</source>
          <target state="translated">정적 함수 &lt;a href=&quot;qaudiodeviceinfo#defaultInputDevice&quot;&gt;defaultInputDevice&lt;/a&gt; (), &lt;a href=&quot;qaudiodeviceinfo#defaultOutputDevice&quot;&gt;defaultOutputDevice&lt;/a&gt; () 및 &lt;a href=&quot;qaudiodeviceinfo#availableDevices&quot;&gt;availableDevices&lt;/a&gt; ()를 사용하면 사용 가능한 모든 장치 목록을 가져올 수 있습니다. 장치는 &lt;a href=&quot;qaudio&quot;&gt;QAudio&lt;/a&gt; :: Mode 열거 형에 지정된 mode 값에 따라 가져옵니다 . 반환 된 QAudioDeviceInfo는 &lt;a href=&quot;qaudio&quot;&gt;QAudio&lt;/a&gt; :: Mode에 대해서만 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="13e6acbf59f634945a754ad651c20b57176e0829" translate="yes" xml:space="preserve">
          <source>The static functions &lt;a href=&quot;qcamerainfo#defaultCamera&quot;&gt;defaultCamera&lt;/a&gt;() and &lt;a href=&quot;qcamerainfo#availableCameras&quot;&gt;availableCameras&lt;/a&gt;() provide you a list of all available cameras.</source>
          <target state="translated">정적 기능인 &lt;a href=&quot;qcamerainfo#defaultCamera&quot;&gt;defaultCamera&lt;/a&gt; () 및 &lt;a href=&quot;qcamerainfo#availableCameras&quot;&gt;availableCameras&lt;/a&gt; ()는 사용 가능한 모든 카메라 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c7a70eea44002078a9bd8d0355f1e256276aab44" translate="yes" xml:space="preserve">
          <source>The static functions &lt;a href=&quot;qthread#currentThreadId&quot;&gt;currentThreadId&lt;/a&gt;() and &lt;a href=&quot;qthread#currentThread&quot;&gt;currentThread&lt;/a&gt;() return identifiers for the currently executing thread. The former returns a platform specific ID for the thread; the latter returns a &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt; pointer.</source>
          <target state="translated">정적 함수 &lt;a href=&quot;qthread#currentThreadId&quot;&gt;currentThreadId&lt;/a&gt; () 및 &lt;a href=&quot;qthread#currentThread&quot;&gt;currentThread&lt;/a&gt; ()는 현재 실행중인 스레드의 식별자를 반환합니다. 전자는 스레드에 대한 플랫폼 특정 ID를 리턴합니다. 후자는 &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt; 포인터를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0af1d21e1b8b0ba275de6df3d626b4e6b438afaa" translate="yes" xml:space="preserve">
          <source>The static functions &lt;a href=&quot;qthread#currentThreadId&quot;&gt;currentThreadId&lt;/a&gt;() and &lt;a href=&quot;qthread#currentThread&quot;&gt;currentThread&lt;/a&gt;() return identifiers for the currently executing thread. The former returns a platform specific ID for the thread; the latter returns a QThread pointer.</source>
          <target state="translated">정적 함수 &lt;a href=&quot;qthread#currentThreadId&quot;&gt;currentThreadId&lt;/a&gt; () 및 &lt;a href=&quot;qthread#currentThread&quot;&gt;currentThread&lt;/a&gt; ()는 현재 실행중인 스레드의 식별자를 반환합니다. 전자는 스레드에 대한 플랫폼 특정 ID를 반환합니다. 후자는 QThread 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="69e49ab1641008f13870ec803be5eb293f8a8e6a" translate="yes" xml:space="preserve">
          <source>The static functions provide modal color dialogs.</source>
          <target state="translated">정적 함수는 모달 색상 대화 상자를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6f62ff55f6f0647cfbf7ff138acbe770de35cdea" translate="yes" xml:space="preserve">
          <source>The status after &lt;a href=&quot;qpdfdocument#close&quot;&gt;close&lt;/a&gt;() has been called on an open document. At this point the document is still valid and all its data can be accessed.</source>
          <target state="translated">열린 문서에서 &lt;a href=&quot;qpdfdocument#close&quot;&gt;닫기&lt;/a&gt; 후 상태 ()가 호출되었습니다. 이 시점에서 문서는 여전히 유효하며 모든 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90203752a28ea2fd43135ea720247f5b5b89e82f" translate="yes" xml:space="preserve">
          <source>The status after Loading, if loading has failed.</source>
          <target state="translated">로드가 실패한 경우로드 후 상태입니다.</target>
        </trans-unit>
        <trans-unit id="83f643e3dc59bcc8af37dedac0a0296794acecfa" translate="yes" xml:space="preserve">
          <source>The status after close() has been called on an open document. At this point the document is still valid and all its data can be accessed.</source>
          <target state="translated">close () 이후의 상태는 열린 문서에서 호출되었습니다. 이 시점에서 문서는 여전히 유효하며 모든 데이터에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb56546033d383cd9154f41c7e63f6c1db04332f" translate="yes" xml:space="preserve">
          <source>The status after load() has been called and before the document is fully loaded.</source>
          <target state="translated">load ()가 호출 된 후 문서가 완전히로드되기 전의 상태입니다.</target>
        </trans-unit>
        <trans-unit id="38186dba98e8e40950784c843a6a9d80ac4f3f14" translate="yes" xml:space="preserve">
          <source>The status bar can be defined by overriding the background component and setting the content padding.</source>
          <target state="translated">배경 구성 요소를 재정의하고 내용 패딩을 설정하여 상태 표시 줄을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c85e2ba5b10f33ef187eb6fca3490da8e9c711d" translate="yes" xml:space="preserve">
          <source>The status can be one of the following values:</source>
          <target state="translated">상태는 다음 값 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="091755c16956a61f3d13198f946b7af95208526a" translate="yes" xml:space="preserve">
          <source>The status can have the following values:</source>
          <target state="translated">상태는 다음 값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="735295b6fa4a3053cd0ad935929300745556db74" translate="yes" xml:space="preserve">
          <source>The status is changed asynchronously and represents the actual status of media recorder.</source>
          <target state="translated">상태는 비동기 적으로 변경되며 미디어 레코더의 실제 상태를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="665fa94341b2a4fc06df777cf2ac4ea6a7b544ec" translate="yes" xml:space="preserve">
          <source>The status of a place can be checked by connecting the status property to a handler function, and then have the handler function process the change in status.</source>
          <target state="translated">장소 속성은 status 속성을 핸들러 함수에 연결하여 확인한 다음 핸들러 함수가 상태 변경을 처리하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc77b5ee8a874a570482f526f02b56d78263e602" translate="yes" xml:space="preserve">
          <source>The status of loading the image.</source>
          <target state="translated">이미지 로딩 상태.</target>
        </trans-unit>
        <trans-unit id="18ad92738b62ce1e5c5a79febcfa25d06b3daa48" translate="yes" xml:space="preserve">
          <source>The status of media loading.</source>
          <target state="translated">미디어 로딩 상태.</target>
        </trans-unit>
        <trans-unit id="7da3ba22e22d03b39c3d3bdf1353222eae98608a" translate="yes" xml:space="preserve">
          <source>The status of the camera must be &lt;a href=&quot;qcamera#Status-enum&quot;&gt;LoadedStatus&lt;/a&gt; before calling this function, otherwise the returned list is empty.</source>
          <target state="translated">이 함수를 호출하기 전에 카메라의 상태가 &lt;a href=&quot;qcamera#Status-enum&quot;&gt;LoadedStatus&lt;/a&gt; 여야합니다 . 그렇지 않으면 반환 된 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6a176d6846969bb58bc1b37f45d5379c71cb58c" translate="yes" xml:space="preserve">
          <source>The status of the engine.</source>
          <target state="translated">엔진의 상태입니다.</target>
        </trans-unit>
        <trans-unit id="0709707a098f70eda25304da024b3e1931f96f72" translate="yes" xml:space="preserve">
          <source>The status of the media cannot be determined.</source>
          <target state="translated">미디어 상태를 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e33534b34465c174c5130a41a136d94c0721a8e8" translate="yes" xml:space="preserve">
          <source>The status of the transaction is not &lt;a href=&quot;qinapptransaction#TransactionStatus-enum&quot;&gt;PurchaseFailed&lt;/a&gt;.</source>
          <target state="translated">트랜잭션 상태가 &lt;a href=&quot;qinapptransaction#TransactionStatus-enum&quot;&gt;PurchaseFailed&lt;/a&gt; 가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="8bfdb74344ac9ea1e514e9635aff5ee8b8d5fa14" translate="yes" xml:space="preserve">
          <source>The status tip is displayed on all status bars provided by the action's top-level parent widget.</source>
          <target state="translated">상태 팁은 조치의 최상위 상위 위젯이 제공하는 모든 상태 표시 줄에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3adee285bf670aa0e712c9c44f28574920461dfd" translate="yes" xml:space="preserve">
          <source>The status when the document is fully loaded and its data can be accessed.</source>
          <target state="translated">문서가 완전히로드되고 해당 데이터에 액세스 할 수있는 상태입니다.</target>
        </trans-unit>
        <trans-unit id="966ef1ecbd3940ac289ac518231d239770c911c0" translate="yes" xml:space="preserve">
          <source>The step size determines the amount by which the dial's value is increased and decreased when interacted with via the keyboard. For example, a step size of &lt;code&gt;0.2&lt;/code&gt;, will result in the dial's value increasing and decreasing in increments of &lt;code&gt;0.2&lt;/code&gt;.</source>
          <target state="translated">단계 크기는 키보드를 통해 상호 작용할 때 다이얼 값이 증가 및 감소하는 양을 결정합니다. 예를 들어, 단계 크기가 &lt;code&gt;0.2&lt;/code&gt; 이면 다이얼 값이 &lt;code&gt;0.2&lt;/code&gt; 씩 증가하고 감소 합니다.</target>
        </trans-unit>
        <trans-unit id="8375496ab40f8c3ad4b3a9715a6e4ce318b003e2" translate="yes" xml:space="preserve">
          <source>The step size is only respected for touch and mouse interaction when &lt;a href=&quot;qml-qtquick-controls2-dial#snapMode-prop&quot;&gt;snapMode&lt;/a&gt; is set to a value other than &lt;code&gt;Dial.NoSnap&lt;/code&gt;.</source>
          <target state="translated">단계 크기는 &lt;a href=&quot;qml-qtquick-controls2-dial#snapMode-prop&quot;&gt;snapMode&lt;/a&gt; 가 &lt;code&gt;Dial.NoSnap&lt;/code&gt; 이외의 값으로 설정된 경우 터치 및 마우스 상호 작용에만 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="4ac7fd0ac7295f844f82c15af8f4c4da9aafa0ba" translate="yes" xml:space="preserve">
          <source>The step type can be single step or adaptive decimal step.</source>
          <target state="translated">단계 유형은 단일 단계 또는 적응 10 진수 단계 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9e0d4e351e2c18c54febb0e2bf51481979f6d76" translate="yes" xml:space="preserve">
          <source>The steps to render a rule are as follows:</source>
          <target state="translated">규칙을 렌더링하는 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a9870b58b0492dac133e0171837bbf80a3c5e5e3" translate="yes" xml:space="preserve">
          <source>The storage format is set to &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings::NativeFormat&lt;/a&gt; (i.e. calling &lt;a href=&quot;qsettings#setDefaultFormat&quot;&gt;setDefaultFormat&lt;/a&gt;() before calling this constructor has no effect).</source>
          <target state="translated">저장 형식은 &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings :: NativeFormat으로&lt;/a&gt; 설정됩니다 (즉, 이 생성자를 호출하기 전에 &lt;a href=&quot;qsettings#setDefaultFormat&quot;&gt;setDefaultFormat&lt;/a&gt; ()을 호출해도 효과가 없습니다).</target>
        </trans-unit>
        <trans-unit id="b22974e8e37b875bbd81f43f236c956c480f54bc" translate="yes" xml:space="preserve">
          <source>The storage name is used to give each profile that uses the disk separate subdirectories for persistent data and cache.</source>
          <target state="translated">스토리지 이름은 디스크를 사용하는 각 프로파일에 영구 데이터 및 캐시에 대한 별도의 서브 디렉토리를 제공하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="72a67770b38e173e3cbaeddac527640df3b7993f" translate="yes" xml:space="preserve">
          <source>The storage name must be unique.</source>
          <target state="translated">저장소 이름은 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="775f45dda4e7daa3b1920f974b3f830de3e1d43a" translate="yes" xml:space="preserve">
          <source>The storage name that is used to create separate subdirectories for each profile that uses the disk for storing persistent data and cache.</source>
          <target state="translated">영구 데이터 및 캐시를 저장하기 위해 디스크를 사용하는 각 프로파일에 대해 별도의 서브 디렉토리를 작성하는 데 사용되는 스토리지 이름입니다.</target>
        </trans-unit>
        <trans-unit id="cd228070dfd0985e2ab107ac8af02163aaed6058" translate="yes" xml:space="preserve">
          <source>The stream operators should have the following signatures:</source>
          <target state="translated">스트림 연산자에는 다음과 같은 서명이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d1fa7e64507344a8d71ed1f70ad3e1dec7d3af31" translate="yes" xml:space="preserve">
          <source>The stream reader does</source>
          <target state="translated">스트림 리더는</target>
        </trans-unit>
        <trans-unit id="cbd8d51d575a1d8d8c75257e0db1940d010156e3" translate="yes" xml:space="preserve">
          <source>The stream receiving window size for stream-level flow control. Sent as 'SETTINGS_INITIAL_WINDOW_SIZE' parameter in the initial SETTINGS frame and, when needed, 'WINDOW_UPDATE' frames will be sent on streams that &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; opens.</source>
          <target state="translated">스트림 수준 흐름 제어를위한 스트림 수신 창 크기입니다. 초기 SETTINGS 프레임에서 'SETTINGS_INITIAL_WINDOW_SIZE'매개 변수로 전송되며 필요한 경우 'WINDOW_UPDATE'프레임이 &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; 가 열리는 스트림에 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="0b830261097846a578c61a66778f7e92df4d1a54" translate="yes" xml:space="preserve">
          <source>The stream remembers that automatic insertion of spaces is enabled for future writes.</source>
          <target state="translated">스트림은 공간의 자동 삽입이 향후 쓰기에 사용 가능하다는 것을 기억합니다.</target>
        </trans-unit>
        <trans-unit id="cd05bf8e787123014d90b69ac40e633782c32894" translate="yes" xml:space="preserve">
          <source>The stream status describes how the playback of the current stream is progressing.</source>
          <target state="translated">스트림 상태는 현재 스트림의 재생 진행 상태를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b970ac3e4374a8a3dd1ad43184e03471af2008dd" translate="yes" xml:space="preserve">
          <source>The stream type is unknown.</source>
          <target state="translated">스트림 유형을 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f87101bb4477cde316bca446c382127bb3df5a9" translate="yes" xml:space="preserve">
          <source>The stream writer can automatically format the generated XML data by adding line-breaks and indentation to empty sections between elements, making the XML data more readable for humans and easier to work with for most source code management systems. The feature can be turned on with the &lt;a href=&quot;qxmlstreamwriter#autoFormatting&quot;&gt;autoFormatting&lt;/a&gt; property, and customized with the &lt;a href=&quot;qxmlstreamwriter#autoFormattingIndent-prop&quot;&gt;autoFormattingIndent&lt;/a&gt; property.</source>
          <target state="translated">스트림 작성기는 요소 사이의 빈 섹션에 줄 바꿈과 들여 쓰기를 추가하여 생성 된 XML 데이터의 형식을 자동으로 지정하여 사람이 XML 데이터를보다 읽기 쉽게 만들고 대부분의 소스 코드 관리 시스템에서보다 쉽게 ​​작업 할 수 있습니다. 이 기능은 &lt;a href=&quot;qxmlstreamwriter#autoFormatting&quot;&gt;autoFormatting&lt;/a&gt; 속성으로 설정하고 &lt;a href=&quot;qxmlstreamwriter#autoFormattingIndent-prop&quot;&gt;autoFormattingIndent&lt;/a&gt; 속성으로 사용자 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a641e2100d2c7214f122f16e9c1a519441f69713" translate="yes" xml:space="preserve">
          <source>The strength of blue color. Range is &lt;code&gt;[0...2]&lt;/code&gt;. &lt;code&gt;1&lt;/code&gt; by default.</source>
          <target state="translated">파란색의 강도. 범위는 &lt;code&gt;[0...2]&lt;/code&gt; 입니다. 기본적으로 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0f33c93e813a96a0c0fd77a2037a21ec9507c026" translate="yes" xml:space="preserve">
          <source>The strength of blur when out of focus. Sensible values are in the range &lt;code&gt;[1...10]&lt;/code&gt;. &lt;code&gt;4&lt;/code&gt; by default.</source>
          <target state="translated">초점이 맞지 않을 때의 흐림 강도입니다. 합리적인 값은 &lt;code&gt;[1...10]&lt;/code&gt; 범위에 있습니다. 기본적으로 &lt;code&gt;4&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a50691a6042609b59f8e0cb5cb6091b4f410f8af" translate="yes" xml:space="preserve">
          <source>The strength of green color. Range is &lt;code&gt;[0...2]&lt;/code&gt;. &lt;code&gt;1.5&lt;/code&gt; by default.</source>
          <target state="translated">녹색의 강도. 범위는 &lt;code&gt;[0...2]&lt;/code&gt; 입니다. 기본적으로 &lt;code&gt;1.5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1d73fbe37472e05e108756747423ad8183c12161" translate="yes" xml:space="preserve">
          <source>The strength of red color. Range is &lt;code&gt;[0...2]&lt;/code&gt;. &lt;code&gt;1&lt;/code&gt; by default.</source>
          <target state="translated">붉은 색의 강도. 범위는 &lt;code&gt;[0...2]&lt;/code&gt; 입니다. 기본적으로 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4b33c785522814802819d7fd276550ad05ac5f50" translate="yes" xml:space="preserve">
          <source>The strength of the blur. Sensible values are in the range &lt;code&gt;[0...0.01]&lt;/code&gt;. &lt;code&gt;0.01&lt;/code&gt; by default.</source>
          <target state="translated">흐림의 강도입니다. 적절한 값은 &lt;code&gt;[0...0.01]&lt;/code&gt; 범위에 있습니다. 기본적으로 &lt;code&gt;0.01&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="763499ac802077a482ba3739340c8491fc89784f" translate="yes" xml:space="preserve">
          <source>The strength of the blur. Sensible values are in the range &lt;code&gt;[0...10]&lt;/code&gt;. &lt;code&gt;2&lt;/code&gt; by default.</source>
          <target state="translated">흐림의 강도입니다. 적절한 값은 &lt;code&gt;[0...10]&lt;/code&gt; 범위에 있습니다. 기본적으로 &lt;code&gt;2&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0db51e5ca36581020bca4f62ecbff875227d9853" translate="yes" xml:space="preserve">
          <source>The strength of the color. Range is &lt;code&gt;[-1...1]&lt;/code&gt;. &lt;code&gt;0&lt;/code&gt; by default.</source>
          <target state="translated">색상의 강도. 범위는 &lt;code&gt;[-1...1]&lt;/code&gt; 입니다. 기본적으로 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6d0a88920950dad21fc208d4f246d83da94cb515" translate="yes" xml:space="preserve">
          <source>The strength of the current radio signal as a percentage where 0% equals no signal, and 100% is a very good signal.</source>
          <target state="translated">현재 무선 신호의 강도는 0 %가 신호가없는 비율이며 100 %는 매우 양호한 신호입니다.</target>
        </trans-unit>
        <trans-unit id="913a70a7d96c3683cdf801dc8c5147c82d66c0f7" translate="yes" xml:space="preserve">
          <source>The strength of the edge highlighting. Range is &lt;code&gt;[0...1]&lt;/code&gt;. &lt;code&gt;0.5&lt;/code&gt; by default.</source>
          <target state="translated">가장자리 강조의 강도입니다. 범위는 &lt;code&gt;[0...1]&lt;/code&gt; 입니다. 기본적으로 &lt;code&gt;0.5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b0586358cbd16c9ab718392375705e6b7ec126f1" translate="yes" xml:space="preserve">
          <source>The strength of the emboss effect. Sensible values are in the range &lt;code&gt;[0...0.01]&lt;/code&gt;. &lt;code&gt;0.003&lt;/code&gt; by default.</source>
          <target state="translated">엠 보스 효과의 강도입니다. 적절한 값은 &lt;code&gt;[0...0.01]&lt;/code&gt; 범위에 있습니다. 기본적으로 &lt;code&gt;0.003&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b59b8dd5c3b4b35aab49e203031a010e111d639f" translate="yes" xml:space="preserve">
          <source>The stretch factor applies only in the &lt;a href=&quot;qboxlayout#direction&quot;&gt;direction&lt;/a&gt; of the &lt;a href=&quot;qboxlayout&quot;&gt;QBoxLayout&lt;/a&gt;, and is relative to the other boxes and widgets in this &lt;a href=&quot;qboxlayout&quot;&gt;QBoxLayout&lt;/a&gt;. Widgets and boxes with higher stretch factors grow more.</source>
          <target state="translated">스트레치 요소에만 적용된다 &lt;a href=&quot;qboxlayout#direction&quot;&gt;방향&lt;/a&gt; 의 &lt;a href=&quot;qboxlayout&quot;&gt;QBoxLayout&lt;/a&gt; ,이에있는 다른 상자와 위젯을 기준으로 &lt;a href=&quot;qboxlayout&quot;&gt;QBoxLayout&lt;/a&gt; . 신축 계수가 높은 위젯 및 상자가 더 커집니다.</target>
        </trans-unit>
        <trans-unit id="f8c3da86445d2daac5670a398374d11b6c6eeb0a" translate="yes" xml:space="preserve">
          <source>The stretch factor changes the width of all characters in the font by factor percent. For example, setting</source>
          <target state="translated">신축 계수는 글꼴의 모든 문자 너비를 인수 백분율로 변경합니다. 예를 들어, 설정</target>
        </trans-unit>
        <trans-unit id="8a8d196d4d1f3c63f0c4b48009e5d49665345f30" translate="yes" xml:space="preserve">
          <source>The stretch factor is only applied to outline fonts. The stretch factor is ignored for bitmap fonts.</source>
          <target state="translated">신축 계수는 윤곽선 글꼴에만 적용됩니다. 비트 맵 글꼴의 신축 계수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="fd0a69397c93c8c85fabce502fde89b769afcb52" translate="yes" xml:space="preserve">
          <source>The stretch factor is relative to the other columns in this grid. Columns with a higher stretch factor take more of the available space.</source>
          <target state="translated">신축 계수는이 그리드의 다른 열을 기준으로합니다. 신축 계수가 높은 열은 사용 가능한 공간을 더 많이 차지합니다.</target>
        </trans-unit>
        <trans-unit id="08e9e235407b3cd8a7db9637211d74a35ba2836c" translate="yes" xml:space="preserve">
          <source>The stretch factor is relative to the other rows in this grid. Rows with a higher stretch factor take more of the available space.</source>
          <target state="translated">신축 계수는이 그리드의 다른 행을 기준으로합니다. 신축 계수가 높은 행은 사용 가능한 공간을 더 많이 차지합니다.</target>
        </trans-unit>
        <trans-unit id="8f677c7f42683e4bf0ac0361312c8732db82f5f8" translate="yes" xml:space="preserve">
          <source>The stretch factor matches a condensed or expanded version of the font or applies a stretch transform that changes the width of all characters in the font by</source>
          <target state="translated">신축 계수는 글꼴의 압축 또는 확장 버전과 일치하거나 글꼴의 모든 문자 너비를 다음과 같이 변경하는 신축 변환을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="e911f691c7cb34beab00b7ef1307be95e1e8eaae" translate="yes" xml:space="preserve">
          <source>The stretch of the reflection. Default is &lt;code&gt;0.5&lt;/code&gt;.</source>
          <target state="translated">반사의 스트레치. 기본값은 &lt;code&gt;0.5&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="18822dcb8b0bc3c64136bcaebcbf45df0cd6a713" translate="yes" xml:space="preserve">
          <source>The string</source>
          <target state="translated">끈</target>
        </trans-unit>
        <trans-unit id="26c8ee7d799197f5537efbe313512ed146e6b911" translate="yes" xml:space="preserve">
          <source>The string &quot;#cdata-section&quot;</source>
          <target state="translated">문자열 &quot;# cdata-section&quot;</target>
        </trans-unit>
        <trans-unit id="6d2e55245c26e70bf597e96d7dbde6c91de8d781" translate="yes" xml:space="preserve">
          <source>The string &quot;#comment&quot;</source>
          <target state="translated">문자열 &quot;#comment&quot;</target>
        </trans-unit>
        <trans-unit id="4d0a0a40a1f0780e0e4b6f98f493dce5105b891c" translate="yes" xml:space="preserve">
          <source>The string &quot;#document&quot;</source>
          <target state="translated">문자열 &quot;#document&quot;</target>
        </trans-unit>
        <trans-unit id="b316f378c1c924485cfa9e27bc73c1811c2feeeb" translate="yes" xml:space="preserve">
          <source>The string &quot;#document-fragment&quot;</source>
          <target state="translated">&quot;# document-fragment&quot;문자열</target>
        </trans-unit>
        <trans-unit id="06fc000cca60fcfb455d835fd54c2f957f852ea7" translate="yes" xml:space="preserve">
          <source>The string &quot;#text&quot;</source>
          <target state="translated">문자열 &quot;#text&quot;</target>
        </trans-unit>
        <trans-unit id="d06f4faef00e5b0ba2dbe9398c86fb2e4d307382" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;s&lt;/code&gt; contains:</source>
          <target state="translated">문자열 &lt;code&gt;s&lt;/code&gt; 포함</target>
        </trans-unit>
        <trans-unit id="655526af0b7c42d934e69651b7f07cd5e32c2872" translate="yes" xml:space="preserve">
          <source>The string conversion will always happen in the 'C' locale. For locale dependent conversion use &lt;a href=&quot;qlocale#toDouble&quot;&gt;QLocale::toDouble&lt;/a&gt;()</source>
          <target state="translated">문자열 변환은 항상 'C'로캘에서 발생합니다. 로케일 종속 변환의 경우 &lt;a href=&quot;qlocale#toDouble&quot;&gt;QLocale :: toDouble&lt;/a&gt; ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="245e415d9fbb3ae0692127b6a07bfc03a9cc31da" translate="yes" xml:space="preserve">
          <source>The string conversion will always happen in the 'C' locale. For locale dependent conversion use &lt;a href=&quot;qlocale#toFloat&quot;&gt;QLocale::toFloat&lt;/a&gt;()</source>
          <target state="translated">문자열 변환은 항상 'C'로캘에서 발생합니다. 로케일 종속 변환의 경우 &lt;a href=&quot;qlocale#toFloat&quot;&gt;QLocale :: toFloat&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="820d891367256d520abae88ffabb6743539ad4e2" translate="yes" xml:space="preserve">
          <source>The string conversion will always happen in the 'C' locale. For locale dependent conversion use &lt;a href=&quot;qlocale#toInt&quot;&gt;QLocale::toInt&lt;/a&gt;()</source>
          <target state="translated">문자열 변환은 항상 'C'로캘에서 발생합니다. 로케일 종속 변환의 경우 &lt;a href=&quot;qlocale#toInt&quot;&gt;QLocale :: toInt&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="16b02a2f12707812f75c24349a4a0078b64645af" translate="yes" xml:space="preserve">
          <source>The string conversion will always happen in the 'C' locale. For locale dependent conversion use &lt;a href=&quot;qlocale#toLong&quot;&gt;QLocale::toLong&lt;/a&gt;()</source>
          <target state="translated">문자열 변환은 항상 'C'로캘에서 발생합니다. 로케일 종속 변환의 경우 &lt;a href=&quot;qlocale#toLong&quot;&gt;QLocale :: toLong&lt;/a&gt; ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="18c7c15c37d6fa3786c175db979bd075ed72c716" translate="yes" xml:space="preserve">
          <source>The string conversion will always happen in the 'C' locale. For locale dependent conversion use &lt;a href=&quot;qlocale#toLongLong&quot;&gt;QLocale::toLongLong&lt;/a&gt;()</source>
          <target state="translated">문자열 변환은 항상 'C'로캘에서 발생합니다. 로케일 종속 변환의 경우 &lt;a href=&quot;qlocale#toLongLong&quot;&gt;QLocale :: toLongLong&lt;/a&gt; ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3a7b5592c4eae901751c5c36dc5ba78cc6e56425" translate="yes" xml:space="preserve">
          <source>The string conversion will always happen in the 'C' locale. For locale dependent conversion use &lt;a href=&quot;qlocale#toShort&quot;&gt;QLocale::toShort&lt;/a&gt;()</source>
          <target state="translated">문자열 변환은 항상 'C'로캘에서 발생합니다. 로케일 종속 변환의 경우 &lt;a href=&quot;qlocale#toShort&quot;&gt;QLocale :: toShort&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="731188f29ba336b19d99bdada50b00e780089448" translate="yes" xml:space="preserve">
          <source>The string conversion will always happen in the 'C' locale. For locale dependent conversion use &lt;a href=&quot;qlocale#toUInt&quot;&gt;QLocale::toUInt&lt;/a&gt;()</source>
          <target state="translated">문자열 변환은 항상 'C'로캘에서 발생합니다. 로케일 종속 변환의 경우 &lt;a href=&quot;qlocale#toUInt&quot;&gt;QLocale :: toUInt&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="310530a81b959a315248e6b8d7fb2f618a4bab83" translate="yes" xml:space="preserve">
          <source>The string conversion will always happen in the 'C' locale. For locale dependent conversion use &lt;a href=&quot;qlocale#toULongLong&quot;&gt;QLocale::toULongLong&lt;/a&gt;()</source>
          <target state="translated">문자열 변환은 항상 'C'로캘에서 발생합니다. 로케일 종속 변환의 경우 &lt;a href=&quot;qlocale#toULongLong&quot;&gt;QLocale :: toULongLong&lt;/a&gt; ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="47838751fe30b41bcb4e3efb4004626707014df6" translate="yes" xml:space="preserve">
          <source>The string conversion will always happen in the 'C' locale. For locale dependent conversion use &lt;a href=&quot;qlocale#toUShort&quot;&gt;QLocale::toUShort&lt;/a&gt;()</source>
          <target state="translated">문자열 변환은 항상 'C'로캘에서 발생합니다. 로케일 종속 변환의 경우 &lt;a href=&quot;qlocale#toUShort&quot;&gt;QLocale :: toUShort&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6ff82922655abe891ce41cc9f92b1b7036cac788" translate="yes" xml:space="preserve">
          <source>The string data is</source>
          <target state="translated">문자열 데이터는</target>
        </trans-unit>
        <trans-unit id="1e235ae4015280c4f9d104cac8eea548f26338de" translate="yes" xml:space="preserve">
          <source>The string found.</source>
          <target state="translated">찾은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="54f578d7b7ceefb31f125f119c51cfac104a12ee" translate="yes" xml:space="preserve">
          <source>The string functions include &lt;a href=&quot;qfontmetrics#horizontalAdvance&quot;&gt;horizontalAdvance&lt;/a&gt;(), to return the width of a string in pixels (or points, for a printer), &lt;a href=&quot;qfontmetrics#boundingRect&quot;&gt;boundingRect&lt;/a&gt;(), to return a rectangle large enough to contain the rendered string, and &lt;a href=&quot;qfontmetrics#size&quot;&gt;size&lt;/a&gt;(), to return the size of that rectangle.</source>
          <target state="translated">문자열 함수에는 &lt;a href=&quot;qfontmetrics#horizontalAdvance&quot;&gt;horizontalAdvance&lt;/a&gt; (), 픽셀 (또는 프린터의 경우 포인트) 단위로 문자열 너비를 반환하고 &lt;a href=&quot;qfontmetrics#boundingRect&quot;&gt;boundingRect&lt;/a&gt; (), 렌더링 된 문자열을 포함 할 수있을만큼 큰 사각형을 반환하고 &lt;a href=&quot;qfontmetrics#size&quot;&gt;크기&lt;/a&gt; () 를 포함 하여 그 직사각형의 크기.</target>
        </trans-unit>
        <trans-unit id="ab548d93fbc50457dd995513eb63402097686a5b" translate="yes" xml:space="preserve">
          <source>The string functions include &lt;a href=&quot;qfontmetricsf#horizontalAdvance&quot;&gt;horizontalAdvance&lt;/a&gt;(), to return the width of a string in pixels (or points, for a printer), &lt;a href=&quot;qfontmetricsf#boundingRect&quot;&gt;boundingRect&lt;/a&gt;(), to return a rectangle large enough to contain the rendered string, and &lt;a href=&quot;qfontmetricsf#size&quot;&gt;size&lt;/a&gt;(), to return the size of that rectangle.</source>
          <target state="translated">문자열 함수에는 &lt;a href=&quot;qfontmetricsf#horizontalAdvance&quot;&gt;horizontalAdvance&lt;/a&gt; (), 픽셀 (또는 프린터의 경우 포인트) 단위로 문자열 너비를 반환하고 &lt;a href=&quot;qfontmetricsf#boundingRect&quot;&gt;boundingRect&lt;/a&gt; (), 렌더링 된 문자열을 포함 할 수있을만큼 큰 사각형을 반환하고 &lt;a href=&quot;qfontmetricsf#size&quot;&gt;크기&lt;/a&gt; () 를 포함 하여 그 직사각형의 크기.</target>
        </trans-unit>
        <trans-unit id="9b5ed341269a3fd84a616f79b237004f77322c33" translate="yes" xml:space="preserve">
          <source>The string functions include width(), to return the width of a string in pixels (or points, for a printer), &lt;a href=&quot;qfontmetrics#boundingRect&quot;&gt;boundingRect&lt;/a&gt;(), to return a rectangle large enough to contain the rendered string, and &lt;a href=&quot;qfontmetrics#size&quot;&gt;size&lt;/a&gt;(), to return the size of that rectangle.</source>
          <target state="translated">문자열 함수에는 width (), 문자열의 너비를 픽셀 단위로 (또는 프린터의 경우) 반환하고 , &lt;a href=&quot;qfontmetrics#boundingRect&quot;&gt;boundingRect&lt;/a&gt; (), 렌더링 된 문자열을 포함하기에 충분히 큰 사각형을 반환하고 &lt;a href=&quot;qfontmetrics#size&quot;&gt;size&lt;/a&gt; (), 그 사각형의 크기.</target>
        </trans-unit>
        <trans-unit id="ebcbc5f0971a4cf1192c48d1b88ee3a826bd4542" translate="yes" xml:space="preserve">
          <source>The string functions include width(), to return the width of a string in pixels (or points, for a printer), &lt;a href=&quot;qfontmetricsf#boundingRect&quot;&gt;boundingRect&lt;/a&gt;(), to return a rectangle large enough to contain the rendered string, and &lt;a href=&quot;qfontmetricsf#size&quot;&gt;size&lt;/a&gt;(), to return the size of that rectangle.</source>
          <target state="translated">문자열 함수에는 width (), 문자열의 너비를 픽셀 단위로 (또는 프린터의 경우) 반환하고 , &lt;a href=&quot;qfontmetricsf#boundingRect&quot;&gt;boundingRect&lt;/a&gt; (), 렌더링 된 문자열을 포함하기에 충분히 큰 사각형을 반환하고 &lt;a href=&quot;qfontmetricsf#size&quot;&gt;size&lt;/a&gt; (), 그 사각형의 크기.</target>
        </trans-unit>
        <trans-unit id="3d6fa0ac1cd8e66ee8f47e6591cb2db03fcd4e5b" translate="yes" xml:space="preserve">
          <source>The string includes the file, location, and description of each error. If multiple errors are present, they are separated by a newline character.</source>
          <target state="translated">문자열에는 파일, 위치 및 각 오류에 대한 설명이 포함됩니다. 여러 개의 오류가 있으면 개행 문자로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="89d04091545d63bac488a1a1c108439b56c06bd0" translate="yes" xml:space="preserve">
          <source>The string is</source>
          <target state="translated">문자열은</target>
        </trans-unit>
        <trans-unit id="64f66f6402a4d39ffdc17166389628c1e46df230" translate="yes" xml:space="preserve">
          <source>The string is a plausible intermediate value.</source>
          <target state="translated">문자열은 그럴듯한 중간 값입니다.</target>
        </trans-unit>
        <trans-unit id="820f3492b40b665f9f5b9f8a282e5e79cf1a49f4" translate="yes" xml:space="preserve">
          <source>The string is acceptable as a final result; i.e. it is valid.</source>
          <target state="translated">문자열은 최종 결과로 허용됩니다. 즉, 유효합니다.</target>
        </trans-unit>
        <trans-unit id="06116c8061fedafea82e206ea2f3b907f481e9ec" translate="yes" xml:space="preserve">
          <source>The string is deserialized using &lt;code&gt;readBytes()&lt;/code&gt;.</source>
          <target state="translated">문자열은 &lt;code&gt;readBytes()&lt;/code&gt; 사용하여 역 직렬화됩니다 .</target>
        </trans-unit>
        <trans-unit id="98cb63a88b2eb3ea5197c95422f831b1b55fc616" translate="yes" xml:space="preserve">
          <source>The string is inserted after the current item in the combobox.</source>
          <target state="translated">문자열은 콤보 상자에서 현재 항목 뒤에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="3da58e04a6c37530ea57eb6fba69f4c4c48d286b" translate="yes" xml:space="preserve">
          <source>The string is inserted before the current item in the combobox.</source>
          <target state="translated">문자열은 콤보 상자에서 현재 항목 앞에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="f6a21c627566b5a2589734c53513699b1eff755d" translate="yes" xml:space="preserve">
          <source>The string is inserted in the alphabetic order in the combobox.</source>
          <target state="translated">문자열은 콤보 상자에서 알파벳 순서로 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="44dd52e91c7169f3729a342606d8f71fd0cb1e21" translate="yes" xml:space="preserve">
          <source>The string is not translated and therefore cannot be shown to the user. The subsequent table shows the fixed mappings between &lt;a href=&quot;qnetworkconfiguration#BearerType-enum&quot;&gt;BearerType&lt;/a&gt; and the bearer type name for known types. If the &lt;a href=&quot;qnetworkconfiguration#BearerType-enum&quot;&gt;BearerType&lt;/a&gt; is unknown this function may return additional information if it is available; otherwise an empty string will be returned.</source>
          <target state="translated">문자열은 변환되지 않으므로 사용자에게 표시 할 수 없습니다. 다음 표는 알려진 유형의 &lt;a href=&quot;qnetworkconfiguration#BearerType-enum&quot;&gt;BearerType&lt;/a&gt; 과 베어러 유형 이름 간의 고정 맵핑을 보여줍니다 . 는 IF &lt;a href=&quot;qnetworkconfiguration#BearerType-enum&quot;&gt;BearerType가&lt;/a&gt; 알 수없는 사용할 수있는 경우이 기능을 추가 정보를 반환 할 수 있습니다; 그렇지 않으면 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f93e066df1c50911d2dd2840958180e8d33615be" translate="yes" xml:space="preserve">
          <source>The string is serialized using &lt;code&gt;writeBytes()&lt;/code&gt;.</source>
          <target state="translated">문자열은 &lt;code&gt;writeBytes()&lt;/code&gt; 사용하여 직렬화됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e7ea24cfed682e9aca9429308af9e86b589c2a6" translate="yes" xml:space="preserve">
          <source>The string is written as a standard number (i.e. 0.015).</source>
          <target state="translated">문자열은 표준 번호 (즉, 0.015)로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="9b36f44716bc3183e9fe2b5b440217db1264a324" translate="yes" xml:space="preserve">
          <source>The string is written in scientific form. It may have an exponent part(i.e. 1.5E-2).</source>
          <target state="translated">문자열은 과학적인 형태로 작성됩니다. 지수 부분 (예 : 1.5E-2)을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6144d8cd2e1a499bf733ab9a0743e6d2b109c187" translate="yes" xml:space="preserve">
          <source>The string must be one of the &lt;a href=&quot;qstylefactory#keys&quot;&gt;QStyleFactory::keys&lt;/a&gt;(), typically one of &quot;windows&quot;, &quot;windowsvista&quot;, &quot;fusion&quot;, or &quot;macintosh&quot;. Style names are case insensitive.</source>
          <target state="translated">문자열은 &lt;a href=&quot;qstylefactory#keys&quot;&gt;QStyleFactory :: keys&lt;/a&gt; () 중 하나 여야하며 일반적으로 &quot;windows&quot;, &quot;windowsvista&quot;, &quot;fusion&quot;또는 &quot;macintosh&quot; 중 하나 여야합니다 . 스타일 이름은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="559220e657e9a125b6b7ad3e0edd6c16219c364b" translate="yes" xml:space="preserve">
          <source>The string pointed to by</source>
          <target state="translated">에 의해 지적 된 문자열</target>
        </trans-unit>
        <trans-unit id="9cc6e2ee3223a6de71966020a68a27ff089d3615" translate="yes" xml:space="preserve">
          <source>The string search can be initiated by the &lt;a href=&quot;qwebenginepage#findText&quot;&gt;QWebEnginePage::findText&lt;/a&gt;() or &lt;a href=&quot;qml-qtwebengine-webengineview#findText-method&quot;&gt;WebEngineView.findText()&lt;/a&gt; method. The results of the search are highlighted in the view. The details of this result are passed as a QWebEngineFindTextResult object that can be used to show a status message, such as &quot;2 of 2 matches&quot;. For example:</source>
          <target state="translated">문자열 검색은 &lt;a href=&quot;qwebenginepage#findText&quot;&gt;QWebEnginePage :: findText&lt;/a&gt; () 또는 WebEngineView.findText &lt;a href=&quot;qml-qtwebengine-webengineview#findText-method&quot;&gt;()&lt;/a&gt; 메소드 로 시작할 수 있습니다 . 검색 결과가보기에서 강조 표시됩니다. 이 결과의 세부 사항은 &quot;2/2 일치&quot;와 같은 상태 메시지를 표시하는 데 사용할 수있는 QWebEngineFindTextResult 객체로 전달됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="efe1abda6d6cf830fffcb83adc58d50eed35acf6" translate="yes" xml:space="preserve">
          <source>The string to search for.</source>
          <target state="translated">검색 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="47d4ec504eeec686bd80b95ce9fa0bb7411eb009" translate="yes" xml:space="preserve">
          <source>The string view will be empty if and only if &lt;code&gt;str.empty()&lt;/code&gt;. It is unspecified whether this constructor can result in a null string view (&lt;code&gt;str.data()&lt;/code&gt; would have to return &lt;code&gt;nullptr&lt;/code&gt; for this).</source>
          <target state="translated">&lt;code&gt;str.empty()&lt;/code&gt; 경우에만 문자열보기가 비어 있습니다 . 이 생성자가 널 문자열보기를 생성 할 수 있는지 여부는 지정되지 않습니다 ( &lt;code&gt;str.data()&lt;/code&gt; 는이를 위해 &lt;code&gt;nullptr&lt;/code&gt; 을 리턴 해야합니다).</target>
        </trans-unit>
        <trans-unit id="f7085f796ecc3fabaf0aa83c42f07d9d6e08c21e" translate="yes" xml:space="preserve">
          <source>The string view will be null if and only if &lt;code&gt;str.isNull()&lt;/code&gt;.</source>
          <target state="translated">문자열보기는 &lt;code&gt;str.isNull()&lt;/code&gt; 경우에만 null 입니다.</target>
        </trans-unit>
        <trans-unit id="30ce103a64c2f2a6c4c2c16afa569e863e045703" translate="yes" xml:space="preserve">
          <source>The string will be inserted after the last item in the combobox.</source>
          <target state="translated">문자열은 콤보 상자의 마지막 항목 뒤에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="35b555bd0c516ef58b57b9b13f3548b3ce427091" translate="yes" xml:space="preserve">
          <source>The string will be inserted as the first item in the combobox.</source>
          <target state="translated">문자열은 콤보 상자에서 첫 번째 항목으로 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="01fa94154881be9547b14633a2ef6d1f3a56db3e" translate="yes" xml:space="preserve">
          <source>The string will not be inserted into the combobox.</source>
          <target state="translated">문자열은 콤보 상자에 삽입되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b67b495067de34b1dbb2203e7440e65cf76c08fd" translate="yes" xml:space="preserve">
          <source>The string-based connection syntax provides a workaround for this rule: If the slot has default parameters, those parameters can be omitted from the signal. When the signal is emitted with fewer arguments than the slot, Qt runs the slot using default parameter values.</source>
          <target state="translated">문자열 기반 연결 구문은이 규칙에 대한 해결 방법을 제공합니다. 슬롯에 기본 매개 변수가있는 경우 해당 매개 변수를 신호에서 생략 할 수 있습니다. 신호가 슬롯보다 적은 인수로 방출되면 Qt는 기본 매개 변수 값을 사용하여 슬롯을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="0145779b8611aa48b39c82a35485cb658886373d" translate="yes" xml:space="preserve">
          <source>The string-based syntax can connect C++ objects to QML objects, but the functor-based syntax cannot. This is because QML types are resolved at run-time, so they are not available to the C++ compiler.</source>
          <target state="translated">문자열 기반 구문은 C ++ 오브젝트를 QML 오브젝트에 연결할 수 있지만 functor 기반 구문은 불가능합니다. QML 유형은 런타임시 분석되므로 C ++ 컴파일러에서 사용할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8e5b3394010ccfb08b339c3a3d2f2d2ec8d8fd5d" translate="yes" xml:space="preserve">
          <source>The stringified error message in case an error occurred.</source>
          <target state="translated">오류가 발생한 경우 문자열 화 된 오류 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="be7da9ad2318354bb5869cac73f67947d32cfcc1" translate="yes" xml:space="preserve">
          <source>The strings can then be inserted into the underlying data store. For consistency, this can be done through the model's own interface:</source>
          <target state="translated">그런 다음 문자열을 기본 데이터 저장소에 삽입 할 수 있습니다. 일관성을 유지하려면 모델 자체 인터페이스를 통해 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="296c048899c287236685307e2a8354e5289dd3bd" translate="yes" xml:space="preserve">
          <source>The struct provides a way for icons created via &lt;a href=&quot;qicon#fromTheme&quot;&gt;QIcon::fromTheme&lt;/a&gt;() to return pixmaps that are designed for the current &lt;a href=&quot;highdpi#glossary-of-high-dpi-terms&quot;&gt;device pixel ratio&lt;/a&gt;. The scale for such an icon is specified using the &lt;a href=&quot;https://standards.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html#directory_layout&quot;&gt;Scale directory key&lt;/a&gt; in the appropriate &lt;code&gt;index.theme&lt;/code&gt; file.</source>
          <target state="translated">구조체는 &lt;a href=&quot;qicon#fromTheme&quot;&gt;QIcon :: fromTheme&lt;/a&gt; ()를 통해 생성 된 아이콘 이 현재 &lt;a href=&quot;highdpi#glossary-of-high-dpi-terms&quot;&gt;장치 픽셀 비율에&lt;/a&gt; 맞게 설계된 픽스맵을 반환 하는 방법을 제공합니다 . 이러한 아이콘의 &lt;a href=&quot;https://standards.freedesktop.org/icon-theme-spec/icon-theme-spec-latest.html#directory_layout&quot;&gt;스케일&lt;/a&gt; 은 적절한 &lt;code&gt;index.theme&lt;/code&gt; 파일 의 Scale 디렉토리 키 를 사용하여 지정 됩니다.</target>
        </trans-unit>
        <trans-unit id="ddafb5d08cf86e785dbdf5a132fc77c50acd4c99" translate="yes" xml:space="preserve">
          <source>The struct provides a way for icons created via &lt;a href=&quot;qicon#fromTheme&quot;&gt;QIcon::fromTheme&lt;/a&gt;() to return pixmaps that are designed for the current &lt;a href=&quot;highdpi#glossary-of-high-dpi-terms&quot;&gt;device pixel ratio&lt;/a&gt;. The scale for such an icon is specified using the Scale directory key in the appropriate &lt;code&gt;index.theme&lt;/code&gt; file.</source>
          <target state="translated">이 구조체는 &lt;a href=&quot;qicon#fromTheme&quot;&gt;QIcon :: fromTheme&lt;/a&gt; ()을 통해 생성 된 아이콘 이 현재 &lt;a href=&quot;highdpi#glossary-of-high-dpi-terms&quot;&gt;장치 픽셀 비율에&lt;/a&gt; 맞게 설계된 픽스맵을 반환 하는 방법을 제공합니다 . 이러한 아이콘의 스케일은 적절한 &lt;code&gt;index.theme&lt;/code&gt; 파일 에서 Scale 디렉토리 키를 사용하여 지정 됩니다.</target>
        </trans-unit>
        <trans-unit id="21254b9de495b8903c223f5671288fdaa395f7db" translate="yes" xml:space="preserve">
          <source>The structure of the UI is represented as a tree of &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt; subclasses. This is often a mirror of the hierarchy of QWidgets that make up the UI of the application.</source>
          <target state="translated">UI의 구조는 &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt; 서브 클래스 의 트리로 표시됩니다 . 이것은 종종 응용 프로그램의 UI를 구성하는 QWidget 계층 구조의 미러입니다.</target>
        </trans-unit>
        <trans-unit id="661b4529dbf265215207d4c0624f7e6ab27e77b1" translate="yes" xml:space="preserve">
          <source>The structure of the pixel data pointed to by</source>
          <target state="translated">픽셀 데이터의 구조는</target>
        </trans-unit>
        <trans-unit id="2e11c081f3aa3cab49e4647e59f1423becdd517b" translate="yes" xml:space="preserve">
          <source>The structured emissive plastic material has the following properties:</source>
          <target state="translated">구조화 된 발광 플라스틱 재료는 다음과 같은 특성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="14d4d521dda8b2fb8608cadb478dfde3605f93bf" translate="yes" xml:space="preserve">
          <source>The structured plastic material has the following properties:</source>
          <target state="translated">The structured plastic material has the following properties:</target>
        </trans-unit>
        <trans-unit id="34bc5f0da46637a0bc9fcc6af471ba49c8ca4eca" translate="yes" xml:space="preserve">
          <source>The structured representation of a text document presents its contents as a hierarchy of text blocks, frames, tables, and other objects. These provide a logical structure to the document and describe how their contents will be displayed. Generally, frames and tables are used to group other structures while text blocks contain the actual textual information.</source>
          <target state="translated">텍스트 문서의 구조적 표현은 내용을 텍스트 블록, 프레임, 테이블 및 기타 개체의 계층 구조로 나타냅니다. 이들은 문서에 논리적 구조를 제공하고 내용이 표시되는 방법을 설명합니다. 일반적으로 프레임과 테이블은 다른 구조를 그룹화하는 데 사용되며 텍스트 블록에는 실제 텍스트 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="29a0072e743c3e73b9c62a64145f805c1d2aa0d6" translate="yes" xml:space="preserve">
          <source>The structures for radio and check buttons are identical. We show the structure using &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; element and pixel metric names:</source>
          <target state="translated">라디오 및 확인 버튼의 구조는 동일합니다. &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; 요소 및 픽셀 메트릭 이름을 사용하여 구조를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="270369b6e9c967e7abed6172c57e1879ac32d890" translate="yes" xml:space="preserve">
          <source>The style Component for the window.</source>
          <target state="translated">창의 스타일 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="e345bbcabf5d1c8ecc84130e9d1305f9b3c2f9c3" translate="yes" xml:space="preserve">
          <source>The style Component for this control.</source>
          <target state="translated">이 컨트롤의 스타일 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="1403fd440e51fff9d5b52416380449155cb8a795" translate="yes" xml:space="preserve">
          <source>The style also contains a set of style hints, which is represented as values in the &lt;a href=&quot;qstyle#StyleHint-enum&quot;&gt;StyleHint&lt;/a&gt; enum. All widgets do not have the same functionality and look in the different styles. For instance, when the menu items in a menu do not fit in a single column on the screen, some styles support scrolling while others draw more than one column to fit all items.</source>
          <target state="translated">스타일에는 스타일 힌트 세트가 포함되어 있으며 &lt;a href=&quot;qstyle#StyleHint-enum&quot;&gt;StyleHint&lt;/a&gt; 열거 형에 값으로 표시됩니다 . 모든 위젯은 기능이 동일하지 않으며 다른 스타일로 보입니다. 예를 들어, 메뉴의 메뉴 항목이 화면의 단일 열에 맞지 않는 경우 일부 스타일은 스크롤을 지원하는 반면 다른 스타일은 모든 항목에 맞게 하나 이상의 열을 그립니다.</target>
        </trans-unit>
        <trans-unit id="1a91c831f7601f526b8cc4d02e12f9ae71aa3405" translate="yes" xml:space="preserve">
          <source>The style calculates the spacing between widgets in layouts. There are two ways the style can handle these calculations. You can set the &lt;code&gt;PM_LayoutHorizontalSpacing&lt;/code&gt; and &lt;code&gt;PM_LayoutVerticalSpacing&lt;/code&gt;, which is the way the Java style does it (through &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle&lt;/a&gt;). Alternatively, you can implement &lt;a href=&quot;qstyle#layoutSpacing&quot;&gt;QStyle::layoutSpacing&lt;/a&gt;() and QStyle::layoutSpacingImplementation() if you need more control over this part of the layout. In these functions you can calculate the spacing based on control types (&lt;a href=&quot;qsizepolicy#ControlType-enum&quot;&gt;QSizePolicy::ControlType&lt;/a&gt;) for different size policies (&lt;a href=&quot;qsizepolicy#Policy-enum&quot;&gt;QSizePolicy::Policy&lt;/a&gt;) and also the style option for the widget in question.</source>
          <target state="translated">스타일은 레이아웃에서 위젯 간 간격을 계산합니다. 스타일이 이러한 계산을 처리 할 수있는 두 가지 방법이 있습니다. &lt;code&gt;PM_LayoutHorizontalSpacing&lt;/code&gt; 및 &lt;code&gt;PM_LayoutVerticalSpacing&lt;/code&gt; 을 설정할 수 있으며 , 이는 Java 스타일이 수행하는 방식입니다 ( &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle을&lt;/a&gt; 통해 ). 또는 레이아웃의이 부분에 대해 더 많은 제어가 필요한 경우 &lt;a href=&quot;qstyle#layoutSpacing&quot;&gt;QStyle :: layoutSpacing&lt;/a&gt; () 및 QStyle :: layoutSpacingImplementation ()을 구현할 수 있습니다 . 이 함수에서는 다양한 크기 정책 ( &lt;a href=&quot;qsizepolicy#Policy-enum&quot;&gt;QSizePolicy :: Policy&lt;/a&gt; ) 에 대한 제어 유형 ( &lt;a href=&quot;qsizepolicy#ControlType-enum&quot;&gt;QSizePolicy :: ControlType&lt;/a&gt; ) 및 해당 위젯의 스타일 옵션을 기반으로 간격을 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e70a994d9499876f96deff7f4fcf5d6122247ac" translate="yes" xml:space="preserve">
          <source>The style can also be specified as a path to a custom style, such as &lt;code&gt;&quot;:/mystyle&quot;&lt;/code&gt;. See &lt;a href=&quot;qtquickcontrols2-customize#creating-a-custom-style&quot;&gt;Creating a Custom Style&lt;/a&gt; for more details about building custom styles. Custom styles do not need to implement all controls. By default, the styling system uses the &lt;a href=&quot;qtquickcontrols2-default&quot;&gt;Default style&lt;/a&gt; as a fallback for controls that a custom style does not provide. It is possible to specify a different fallback style to customize or extend one of the built-in styles.</source>
          <target state="translated">The style can also be specified as a path to a custom style, such as &lt;code&gt;&quot;:/mystyle&quot;&lt;/code&gt; . See &lt;a href=&quot;qtquickcontrols2-customize#creating-a-custom-style&quot;&gt;Creating a Custom Style&lt;/a&gt; for more details about building custom styles. Custom styles do not need to implement all controls. By default, the styling system uses the &lt;a href=&quot;qtquickcontrols2-default&quot;&gt;Default style&lt;/a&gt; as a fallback for controls that a custom style does not provide. It is possible to specify a different fallback style to customize or extend one of the built-in styles.</target>
        </trans-unit>
        <trans-unit id="dfa4c63caacc3f033762051c500bf21598bef105" translate="yes" xml:space="preserve">
          <source>The style can also be specified as a path to a custom style, such as &lt;code&gt;&quot;:/mystyle&quot;&lt;/code&gt;. See &lt;a href=&quot;qtquickcontrols2-customize#creating-a-custom-style&quot;&gt;Creating a Custom Style&lt;/a&gt; for more details about building custom styles. Custom styles do not need to implement all controls. By default, the styling system uses the &lt;a href=&quot;qtquickcontrols2-default#&quot;&gt;Default style&lt;/a&gt; as a fallback for controls that a custom style does not provide. It is possible to specify a different fallback style to customize or extend one of the built-in styles.</source>
          <target state="translated">스타일은 &lt;code&gt;&quot;:/mystyle&quot;&lt;/code&gt; 과 같은 사용자 정의 스타일의 경로로 지정할 수도 있습니다 . &lt;a href=&quot;qtquickcontrols2-customize#creating-a-custom-style&quot;&gt;사용자 정의 스타일 작성에&lt;/a&gt; 대한 자세한 내용은 사용자 정의 스타일 작성을 참조하십시오 . 사용자 정의 스타일이 모든 컨트롤을 구현할 필요는 없습니다. 기본적으로 스타일 지정 시스템은 &lt;a href=&quot;qtquickcontrols2-default#&quot;&gt;기본 스타일&lt;/a&gt; 을 사용자 지정 스타일이 제공하지 않는 컨트롤의 대체로 사용합니다 . 내장 스타일 중 하나를 사용자 정의하거나 확장하기 위해 다른 폴백 스타일을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b44a11f22d912d8e27e989326fd7078a1d55e29" translate="yes" xml:space="preserve">
          <source>The style component for the menubar's own menus and their submenus.</source>
          <target state="translated">메뉴 막대 자체 메뉴 및 해당 하위 메뉴의 스타일 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="92fb22daddaa541351cc80fe92273c68f9ff8113" translate="yes" xml:space="preserve">
          <source>The style does not handle reverse layouts. We assume that the layout direction is left to right. &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle&lt;/a&gt; handles reverse widgets; if we implemented reverse layouts, widgets that we change the position of sub elements, or handle text alignment in labels ourselves would need to be updated.</source>
          <target state="translated">스타일은 리버스 레이아웃을 처리하지 않습니다. 레이아웃 방향이 왼쪽에서 오른쪽이라고 가정합니다. &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle&lt;/a&gt; 은 리버스 위젯을 처리합니다. 역 레이아웃을 구현 한 경우 하위 요소의 위치를 ​​변경하거나 레이블 자체에서 텍스트 정렬을 처리하는 위젯을 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="f2005b66864c4e3f530c3aaaa67805678f8475e6" translate="yes" xml:space="preserve">
          <source>The style elements and widgets, as mentioned, use the style to calculate bounding rectangles of sub elements and sub controls. Pixel metrics, which are style-dependent sizes in screen pixels, are also used for measurements when drawing. The available rectangles and pixel metrics are represented by three enums in &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;: &lt;a href=&quot;qstyle#SubElement-enum&quot;&gt;SubElement&lt;/a&gt;, &lt;a href=&quot;qstyle#SubControl-enum&quot;&gt;SubControl&lt;/a&gt;, and &lt;a href=&quot;qstyle#PixelMetric-enum&quot;&gt;PixelMetric&lt;/a&gt;. Values of the enums can easily by identified as they start with SE_, SC_ and PM_.</source>
          <target state="translated">언급 한대로 스타일 요소 및 위젯은 스타일을 사용하여 하위 요소 및 하위 컨트롤의 경계 사각형을 계산합니다. 화면 픽셀에서 스타일에 따라 크기가 다른 픽셀 메트릭도 그릴 때 측정에 사용됩니다. 가능한 사각형 화소 메트릭 세 열거로 표시되는 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; : &lt;a href=&quot;qstyle#SubElement-enum&quot;&gt;하위 요소&lt;/a&gt; , &lt;a href=&quot;qstyle#SubControl-enum&quot;&gt;서브 컨트롤&lt;/a&gt; 및 &lt;a href=&quot;qstyle#PixelMetric-enum&quot;&gt;PixelMetric&lt;/a&gt; . 열거 형의 값은 SE_, SC_ 및 PM_로 시작할 때 쉽게 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54d23adae09a8930eb1a7bd5fbee19d47ef353e5" translate="yes" xml:space="preserve">
          <source>The style expects the needle to be pointing up at a rotation of &lt;code&gt;0&lt;/code&gt;, in order for the rotation to be correct. For example:</source>
          <target state="translated">스타일 은 회전이 정확하기 위해 바늘이 &lt;code&gt;0&lt;/code&gt; 회전을 가리 키도록 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6bb6d2f4570121b59b1423a923cc44f34c01e581" translate="yes" xml:space="preserve">
          <source>The style gets all the information it needs to render the graphical element from the &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; class. The widget is passed as the last argument in case the style needs it to perform special effects (such as animated default buttons on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;), but it isn't mandatory. In fact, &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; can be used to draw on any paint device (not just widgets), in which case the widget argument is a zero pointer.</source>
          <target state="translated">스타일은 &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; 클래스 에서 그래픽 요소를 렌더링하는 데 필요한 모든 정보를 가져 옵니다 . 스타일에 특수 효과 (예 : &lt;a href=&quot;internationalization#macos&quot;&gt;macOS의&lt;/a&gt; 애니메이션 기본 버튼 ) 를 수행해야하는 경우 위젯이 마지막 인수로 전달 되지만 필수는 아닙니다. 실제로 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 을 사용하여 모든 페인트 장치 (위젯뿐만 아니라)에 그릴 수 있습니다.이 경우 위젯 인수는 0 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="f0e5a1e765e9e15e9401676a4492d38c8e1ed7ff" translate="yes" xml:space="preserve">
          <source>The style gets all the information it needs to render the graphical element from the &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; class. The widget is passed as the last argument in case the style needs it to perform special effects (such as animated default buttons on macOS), but it isn't mandatory. In fact, &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; can be used to draw on any paint device (not just widgets), in which case the widget argument is a zero pointer.</source>
          <target state="translated">The style gets all the information it needs to render the graphical element from the &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; class. The widget is passed as the last argument in case the style needs it to perform special effects (such as animated default buttons on macOS), but it isn't mandatory. In fact, &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; can be used to draw on any paint device (not just widgets), in which case the widget argument is a zero pointer.</target>
        </trans-unit>
        <trans-unit id="545af0ad4181f9c2aa075e9aec4d70b3099cb8c6" translate="yes" xml:space="preserve">
          <source>The style hint affects the &lt;a href=&quot;qfont#fontmatching&quot;&gt;font matching algorithm&lt;/a&gt;. See &lt;a href=&quot;qfont#StyleHint-enum&quot;&gt;QFont::StyleHint&lt;/a&gt; for the list of available hints.</source>
          <target state="translated">스타일 힌트는 &lt;a href=&quot;qfont#fontmatching&quot;&gt;글꼴 일치 알고리즘에&lt;/a&gt; 영향을줍니다 . 사용 가능한 힌트 목록은 &lt;a href=&quot;qfont#StyleHint-enum&quot;&gt;QFont :: StyleHint&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d0f63f1048683a969308f34e4d6a03a6bd96cb7" translate="yes" xml:space="preserve">
          <source>The style hints encapsulate a set of platform dependent properties such as double click intervals, full width selection and others.</source>
          <target state="translated">스타일 힌트는 더블 클릭 간격, 전체 너비 선택 등의 플랫폼 종속 속성 집합을 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="5924bec7b3dacc03790aead1114820f722989aba" translate="yes" xml:space="preserve">
          <source>The style is automatically selected and deployed on Android. See &lt;a href=&quot;android-getting-started&quot;&gt;Getting Started with Qt for Android&lt;/a&gt; and &lt;a href=&quot;https://doc.qt.io/qt-5.13/deployment-android.html&quot;&gt;Deploying an Application on Android&lt;/a&gt; for more details on the Android essentials.</source>
          <target state="translated">스타일은 Android에서 자동으로 선택되어 배포됩니다. 보기는 &lt;a href=&quot;android-getting-started&quot;&gt;안드로이드를위한 Qt를 시작하기&lt;/a&gt; 및 &lt;a href=&quot;https://doc.qt.io/qt-5.13/deployment-android.html&quot;&gt;안드로이드에 대한 응용 프로그램 배포&lt;/a&gt; 안드로이드 필수 요소에 대한 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="2002ee8158c13c358ddda0854c7e7196a5b6c5d2" translate="yes" xml:space="preserve">
          <source>The style is automatically selected and deployed on Android. See &lt;a href=&quot;android-getting-started&quot;&gt;Getting Started with Qt for Android&lt;/a&gt; and &lt;a href=&quot;https://doc.qt.io/qt-5.15/deployment-android.html&quot;&gt;Deploying an Application on Android&lt;/a&gt; for more details on the Android essentials.</source>
          <target state="translated">The style is automatically selected and deployed on Android. See &lt;a href=&quot;android-getting-started&quot;&gt;Getting Started with Qt for Android&lt;/a&gt; and &lt;a href=&quot;https://doc.qt.io/qt-5.15/deployment-android.html&quot;&gt;Deploying an Application on Android&lt;/a&gt; for more details on the Android essentials.</target>
        </trans-unit>
        <trans-unit id="49fc322bafcbbdabe4b4a02eeda7b3e60a7b1d00" translate="yes" xml:space="preserve">
          <source>The style is implemented in one class. We have done this because we find it convenient to keep all code in one file. Also, it is an advantage with regards to optimization as we instantiate less objects. We also keep the number of functions at a minimum by using switches to identify which element to draw in the functions. This results in large functions, but since we divide the code for each element in the switches, the code should still be easy to read.</source>
          <target state="translated">스타일은 하나의 클래스로 구현됩니다. 우리는 모든 코드를 하나의 파일에 보관하는 것이 편리하다는 것을 알았 기 때문에이 작업을 수행했습니다. 또한 적은 객체를 인스턴스화 할 때 최적화와 관련하여 이점이 있습니다. 또한 스위치를 사용하여 함수에 그릴 요소를 식별하여 함수 수를 최소로 유지합니다. 이로 인해 큰 기능이 발생하지만 스위치의 각 요소에 대한 코드를 나누기 때문에 코드를 쉽게 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7277af5049a8a33b7223c691237256fbd78aa2e9" translate="yes" xml:space="preserve">
          <source>The style is selected by default when running Qt Quick Controls 2 applications. It is built into the module's resources, so by default it is shipped with any application that depends on the Qt Quick Controls 2 module</source>
          <target state="translated">Qt Quick Controls 2 애플리케이션을 실행할 때이 스타일이 기본적으로 선택됩니다. 모듈의 리소스에 내장되어 있으므로 기본적으로 Qt Quick Controls 2 모듈에 의존하는 모든 응용 프로그램과 함께 제공됩니다</target>
        </trans-unit>
        <trans-unit id="61e11a7e429ddd957287fcb8b3ad81f59a076e7a" translate="yes" xml:space="preserve">
          <source>The style is selected by default when running Qt Quick Controls applications. It is built into the module's resources, so by default it is shipped with any application that depends on the Qt Quick Controls module</source>
          <target state="translated">The style is selected by default when running Qt Quick Controls applications. It is built into the module's resources, so by default it is shipped with any application that depends on the Qt Quick Controls module</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
